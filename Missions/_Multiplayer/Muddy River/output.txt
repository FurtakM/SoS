// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 350 0 0
// InitMultiplayer ;
  20: CALL 611 0 0
// InitMacro ;
  24: CALL 47055 0 0
// if debug then
  28: LD_EXP 1
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: CALL 42466 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: CALL 1893 0 1
  79: PPUSH
  80: CALL 5848 0 1
// Multiplayer_Start ;
  84: CALL 3757 0 0
// MC_Start ( ) ;
  88: CALL 49167 0 0
// Multiplayer_End ;
  92: CALL 3881 0 0
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: CALL 70409 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: LD_OWVAR 67
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: CALL 70409 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_OWVAR 67
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: CALL 70409 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: CALL 70409 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: LD_OWVAR 67
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: CALL 70409 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: LD_ADDR_EXP 67
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: LD_ADDR_EXP 68
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_EXP 38
 330: PUSH
 331: LD_VAR 0 2
 335: ARRAY
 336: PPUSH
 337: CALL 70835 0 2
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := false ;
 353: LD_ADDR_EXP 1
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: LD_ADDR_EXP 4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: LD_ADDR_EXP 5
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: LD_EXP 2
 489: PUSH
 490: LD_OWVAR 48
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: CALL 4582 0 0
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: LD_EXP 1
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: LD_ADDR_VAR 0 2
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: CALL_OW 44
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: LD_ADDR_EXP 18
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: LD_OWVAR 4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: LD_OWVAR 7
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: LD_ADDR_EXP 6
 646: PUSH
 647: LD_OWVAR 6
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: LD_ADDR_EXP 7
 656: PUSH
 657: LD_OWVAR 17
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: LD_ADDR_EXP 8
 666: PUSH
 667: LD_OWVAR 15
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: LD_ADDR_EXP 9
 676: PUSH
 677: LD_OWVAR 16
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: LD_ADDR_EXP 10
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: LD_OWVAR 12
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: LD_ADDR_EXP 10
 706: PUSH
 707: LD_EXP 10
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: LD_EXP 10
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: CALL 14797 0 3
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: LD_ADDR_VAR 0 2
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_EXP 18
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: LD_ADDR_EXP 17
 772: PUSH
 773: LD_EXP 17
 777: PPUSH
 778: LD_EXP 17
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 426
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: CALL_OW 2
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: LD_ADDR_EXP 6
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: LD_ADDR_EXP 7
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: LD_ADDR_EXP 8
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: LD_ADDR_EXP 10
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: LD_ADDR_EXP 17
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: LD_ADDR_EXP 11
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: LD_ADDR_EXP 25
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: LD_ADDR_EXP 15
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: LD_ADDR_EXP 13
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: LD_ADDR_EXP 16
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: LD_ADDR_EXP 24
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: LD_ADDR_EXP 27
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: LD_ADDR_EXP 26
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: LD_ADDR_EXP 12
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: LD_VAR 0 2
1232: PPUSH
1233: CALL_OW 530
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: LD_ADDR_EXP 11
1243: PUSH
1244: LD_EXP 11
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: CALL_OW 1
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: LD_ADDR_EXP 9
1266: PUSH
1267: LD_EXP 9
1271: PPUSH
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 1
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_EXP 7
1294: PPUSH
1295: LD_VAR 0 2
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: CALL_OW 1
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_EXP 10
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: LD_VAR 0 2
1330: PUSH
1331: LD_EXP 10
1335: PUSH
1336: LD_VAR 0 3
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: LD_ADDR_VAR 0 5
1348: PUSH
1349: LD_EXP 10
1353: PUSH
1354: LD_VAR 0 3
1358: ARRAY
1359: PUSH
1360: LD_VAR 0 2
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: LD_ADDR_EXP 10
1370: PUSH
1371: LD_EXP 10
1375: PPUSH
1376: LD_VAR 0 3
1380: PPUSH
1381: LD_VAR 0 5
1385: PPUSH
1386: CALL_OW 1
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: LD_EXP 9
1399: PUSH
1400: LD_VAR 0 2
1404: ARRAY
1405: PUSH
1406: LD_EXP 9
1410: PUSH
1411: LD_VAR 0 2
1415: ARRAY
1416: PUSH
1417: LD_EXP 13
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: LD_ADDR_EXP 9
1430: PUSH
1431: LD_EXP 9
1435: PPUSH
1436: LD_VAR 0 2
1440: PPUSH
1441: LD_EXP 13
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: LD_EXP 13
1453: PPUSH
1454: CALL_OW 12
1458: ARRAY
1459: PPUSH
1460: CALL_OW 1
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: LD_EXP 9
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: PUSH
1477: LD_EXP 7
1481: PUSH
1482: LD_VAR 0 2
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: LD_EXP 11
1494: PUSH
1495: LD_VAR 0 2
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: LD_ADDR_EXP 14
1508: PUSH
1509: LD_EXP 14
1513: PPUSH
1514: LD_VAR 0 2
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: CALL_OW 1
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: LD_EXP 7
1531: PUSH
1532: LD_VAR 0 2
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: LD_ADDR_EXP 26
1543: PUSH
1544: LD_EXP 26
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_EXP 10
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: LD_VAR 0 2
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 3
1597: ARRAY
1598: PPUSH
1599: LD_VAR 0 2
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: CALL_OW 343
// for x = 1 to j - 1 do
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: LD_VAR 0 3
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: LD_VAR 0 2
1638: PUSH
1639: LD_VAR 0 3
1643: ARRAY
1644: PPUSH
1645: LD_VAR 0 2
1649: PUSH
1650: LD_VAR 0 4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 80
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_EXP 17
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: LD_ADDR_EXP 20
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: LD_ADDR_EXP 21
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: LD_ADDR_EXP 22
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_EXP 17
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: LD_ADDR_EXP 23
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: LD_EXP 17
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: LD_VAR 0 1
1901: PUSH
1902: LD_EXP 7
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: LD_ADDR_VAR 0 2
1914: PUSH
1915: LD_VAR 0 1
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: LD_ADDR_VAR 0 3
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: LD_EXP 7
1942: PUSH
1943: LD_VAR 0 3
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: LD_VAR 0 3
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_VAR 0 1
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: LD_ADDR_VAR 0 3
2095: PUSH
2096: CALL_OW 44
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: LD_VAR 0 2
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: CALL_OW 44
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: LD_VAR 0 2
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: CALL_OW 44
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: LD_EXP 7
2317: PUSH
2318: LD_VAR 0 2
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: LD_EXP 16
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 2
2343: PPUSH
2344: LD_EXP 7
2348: PUSH
2349: LD_VAR 0 2
2353: ARRAY
2354: PPUSH
2355: CALL 1974 0 2
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: LD_ADDR_EXP 24
2364: PUSH
2365: LD_EXP 24
2369: PPUSH
2370: LD_EXP 24
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: CALL_OW 2
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: LD_VAR 0 5
2393: PPUSH
2394: LD_EXP 12
2398: PUSH
2399: LD_EXP 7
2403: PUSH
2404: LD_VAR 0 2
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 49
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_VAR 0 2
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: LD_EXP 9
2443: PUSH
2444: LD_VAR 0 2
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: LD_EXP 20
2468: PPUSH
2469: CALL_OW 380
// if multiplayer then
2473: LD_OWVAR 4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: LD_OWVAR 19
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: LD_VAR 0 2
2512: PPUSH
2513: CALL_OW 525
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: LD_VAR 0 2
2527: PPUSH
2528: CALL_OW 526
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: CALL_OW 12
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: LD_VAR 0 5
2581: PPUSH
2582: LD_EXP 12
2586: PUSH
2587: LD_EXP 7
2591: PUSH
2592: LD_VAR 0 2
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: LD_ADDR_EXP 24
2614: PUSH
2615: LD_EXP 24
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: LD_VAR 0 5
2629: PPUSH
2630: CALL_OW 1
2634: ST_TO_ADDR
// end ; InitHc ;
2635: CALL_OW 19
// InitUc ;
2639: CALL_OW 18
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: LD_EXP 9
2662: PUSH
2663: LD_VAR 0 2
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: LD_ADDR_VAR 0 3
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: LD_EXP 19
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: LD_EXP 19
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_EXP 20
2773: PPUSH
2774: CALL_OW 380
// un := CreateHuman ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: CALL_OW 44
2787: ST_TO_ADDR
// if j > copy then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_VAR 0 8
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: LD_ADDR_VAR 0 8
2804: PUSH
2805: LD_VAR 0 8
2809: PPUSH
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 1
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: LD_VAR 0 8
2831: PUSH
2832: LD_VAR 0 3
2836: ARRAY
2837: PPUSH
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: LD_VAR 0 5
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: LD_VAR 0 8
2859: PUSH
2860: LD_VAR 0 3
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: CALL_OW 260
2873: PPUSH
2874: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: LD_VAR 0 5
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 8
2890: PUSH
2891: LD_VAR 0 3
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: CALL_OW 260
2904: PPUSH
2905: CALL_OW 239
// end ; if multi_pos_area then
2909: LD_EXP 12
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: LD_VAR 0 5
2919: PPUSH
2920: CALL_OW 257
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_VAR 0 3
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_VAR 0 3
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: CALL 14675 0 5
// veh := CreateVehicle ;
2995: LD_ADDR_VAR 0 6
2999: PUSH
3000: CALL_OW 45
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_EXP 12
3014: PUSH
3015: LD_EXP 7
3019: PUSH
3020: LD_VAR 0 2
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3038: LD_VAR 0 5
3042: PPUSH
3043: LD_VAR 0 6
3047: PPUSH
3048: CALL_OW 52
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_EXP 12
3063: PUSH
3064: LD_EXP 7
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 49
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: LD_ADDR_VAR 0 3
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: CALL_OW 12
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_VAR 0 3
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: CALL 14675 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: CALL_OW 45
3166: PPUSH
3167: LD_EXP 12
3171: PUSH
3172: LD_EXP 7
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: CALL_OW 49
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: LD_EXP 23
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: LD_ADDR_VAR 0 1
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: LD_EXP 7
3251: PUSH
3252: LD_VAR 0 2
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: LD_ADDR_VAR 0 5
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: LD_EXP 23
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: LD_VAR 0 2
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: LD_EXP 9
3295: PUSH
3296: LD_VAR 0 2
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3321: LD_ADDR_VAR 0 5
3325: PUSH
3326: LD_VAR 0 5
3330: PUSH
3331: CALL_OW 45
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: LD_VAR 0 5
3365: PUSH
3366: CALL_OW 45
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: LD_VAR 0 5
3400: PUSH
3401: CALL_OW 45
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_VAR 0 5
3435: PUSH
3436: CALL_OW 45
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: LD_EXP 23
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: LD_VAR 0 2
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: LD_EXP 9
3471: PUSH
3472: LD_VAR 0 2
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3497: LD_ADDR_VAR 0 5
3501: PUSH
3502: LD_VAR 0 5
3506: PUSH
3507: CALL_OW 45
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3532: LD_ADDR_VAR 0 5
3536: PUSH
3537: LD_VAR 0 5
3541: PUSH
3542: CALL_OW 45
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3567: LD_ADDR_VAR 0 5
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: CALL_OW 45
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_VAR 0 5
3611: PUSH
3612: CALL_OW 45
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3637: LD_ADDR_VAR 0 5
3641: PUSH
3642: LD_VAR 0 5
3646: PUSH
3647: CALL_OW 45
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: CALL_OW 45
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3707: LD_ADDR_VAR 0 5
3711: PUSH
3712: LD_VAR 0 5
3716: PUSH
3717: CALL_OW 45
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: LD_ADDR_VAR 0 1
3727: PUSH
3728: LD_VAR 0 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_VAR 0 5
3742: PPUSH
3743: CALL_OW 2
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: CALL 2286 0 0
// Multiplayer_InitPointSystem ( ) ;
3764: CALL 4681 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: CALL 4857 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: CALL 4857 0 1
// Multiplayer_SpawnArtifact ;
3811: CALL 5297 0 0
// if multi_support then
3815: LD_EXP 23
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: LD_ADDR_EXP 27
3825: PUSH
3826: CALL 3208 0 0
3830: ST_TO_ADDR
// game := true ;
3831: LD_ADDR_EXP 2
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: LD_EXP 7
3843: PUSH
3844: LD_OWVAR 2
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: LD_OWVAR 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: CALL_OW 69
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: CALL_OW 87
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: LD_ADDR_VAR 0 5
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: LD_OWVAR 1
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: LD_EXP 28
3916: NOT
3917: AND
3918: PUSH
3919: LD_EXP 23
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: LD_ADDR_EXP 28
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: LD_ADDR_VAR 0 2
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: LD_EXP 7
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PUSH
3965: LD_EXP 25
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: LD_EXP 27
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: LD_EXP 27
4000: PUSH
4001: LD_VAR 0 2
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: LD_ADDR_VAR 0 3
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 3
4032: ARRAY
4033: PPUSH
4034: LD_EXP 12
4038: PUSH
4039: LD_EXP 7
4043: PUSH
4044: LD_VAR 0 2
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 3
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: LD_ADDR_EXP 27
4088: PUSH
4089: LD_EXP 27
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 1
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: LD_OWVAR 1
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: LD_OWVAR 1
4136: LESS
4137: PUSH
4138: LD_EXP 28
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: LD_EXP 23
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: LD_ADDR_EXP 28
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: LD_ADDR_VAR 0 2
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: LD_EXP 7
4187: PUSH
4188: LD_VAR 0 2
4192: ARRAY
4193: PUSH
4194: LD_EXP 25
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: LD_EXP 27
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_EXP 27
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: LD_ADDR_VAR 0 3
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: LD_VAR 0 4
4256: PUSH
4257: LD_VAR 0 3
4261: ARRAY
4262: PPUSH
4263: LD_EXP 12
4267: PUSH
4268: LD_EXP 7
4272: PUSH
4273: LD_VAR 0 2
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: CALL_OW 3
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: LD_ADDR_EXP 27
4317: PUSH
4318: LD_EXP 27
4322: PPUSH
4323: LD_VAR 0 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PPUSH
4333: CALL_OW 1
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: LD_EXP 16
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: LD_ADDR_VAR 0 2
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 69
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_VAR 0 2
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: LD_ADDR_EXP 25
4404: PUSH
4405: LD_EXP 25
4409: PPUSH
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: CALL_OW 1
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: CALL 4927 0 1
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: LD_EXP 25
4440: PPUSH
4441: CALL 11949 0 1
4445: PUSH
4446: LD_EXP 7
4450: PPUSH
4451: CALL 11949 0 1
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: LD_EXP 3
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: LD_EXP 2
4485: AND
4486: PUSH
4487: LD_EXP 24
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: LD_ADDR_EXP 2
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: LD_ADDR_VAR 0 2
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: LD_EXP 7
4523: PUSH
4524: LD_VAR 0 2
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_EXP 29
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: CALL_OW 506
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: LD_EXP 25
4559: PUSH
4560: LD_OWVAR 2
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: CALL_OW 107
4571: GO 4577
// YouWinInMultiplayer ;
4573: CALL_OW 106
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: LD_ADDR_VAR 0 1
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: LD_OWVAR 1
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: LD_EXP 7
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: LD_ADDR_VAR 0 1
4635: PUSH
4636: LD_VAR 0 1
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_VAR 0 2
4653: PUSH
4654: LD_EXP 29
4658: PUSH
4659: LD_VAR 0 2
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: LD_ADDR_EXP 29
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: LD_ADDR_EXP 30
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: LD_EXP 29
4743: NOT
4744: PUSH
4745: LD_VAR 0 1
4749: NOT
4750: OR
4751: PUSH
4752: LD_VAR 0 1
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: LD_ADDR_EXP 29
4769: PUSH
4770: LD_EXP 29
4774: PPUSH
4775: LD_VAR 0 1
4779: PPUSH
4780: LD_EXP 29
4784: PUSH
4785: LD_VAR 0 1
4789: ARRAY
4790: PUSH
4791: LD_VAR 0 2
4795: PLUS
4796: PPUSH
4797: CALL_OW 1
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: LD_EXP 29
4814: NOT
4815: PUSH
4816: LD_VAR 0 1
4820: NOT
4821: OR
4822: PUSH
4823: LD_VAR 0 1
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: LD_EXP 29
4845: PUSH
4846: LD_VAR 0 1
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: LD_ADDR_EXP 30
4864: PUSH
4865: LD_EXP 30
4869: PPUSH
4870: LD_EXP 30
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: LD_VAR 0 1
4883: PPUSH
4884: CALL_OW 2
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: LD_VAR 0 1
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: LD_EXP 30
4915: PUSH
4916: LD_VAR 0 1
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: LD_ADDR_VAR 0 3
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: LD_ADDR_VAR 0 4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: LD_VAR 0 4
4961: PUSH
4962: LD_VAR 0 1
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: LD_EXP 7
4975: PUSH
4976: LD_VAR 0 4
4980: ARRAY
4981: PUSH
4982: LD_EXP 25
4986: PUSH
4987: LD_VAR 0 4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_VAR 0 4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: LD_VAR 0 3
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: LD_ADDR_VAR 0 4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_VAR 0 1
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL_OW 69
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: LD_VAR 0 4
5074: PPUSH
5075: LD_VAR 0 3
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: CALL_OW 235
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: LD_ADDR_VAR 0 5
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: LD_VAR 0 1
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: LD_VAR 0 4
5173: PPUSH
5174: LD_VAR 0 3
5178: PUSH
5179: LD_VAR 0 5
5183: ARRAY
5184: PPUSH
5185: CALL_OW 235
// if IsDrivenBy ( i ) then
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 311
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: LD_VAR 0 3
5214: PUSH
5215: LD_VAR 0 5
5219: ARRAY
5220: PPUSH
5221: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 310
5234: PPUSH
5235: CALL_OW 247
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: LD_VAR 0 4
5249: PPUSH
5250: CALL_OW 122
// j := j + 1 ;
5254: LD_ADDR_VAR 0 5
5258: PUSH
5259: LD_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: LD_VAR 0 5
5272: PUSH
5273: LD_VAR 0 3
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: LD_ADDR_VAR 0 5
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PPUSH
5366: CALL_OW 12
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: LD_VAR 0 3
5381: PUSH
5382: LD_VAR 0 2
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: LD_VAR 0 3
5396: PUSH
5397: LD_VAR 0 2
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 58
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: LD_VAR 0 1
5426: NOT
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: CALL 4894 0 1
5453: PPUSH
5454: CALL 4736 0 2
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: LD_VAR 0 1
5470: NOT
5471: PUSH
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: CALL 4894 0 1
5497: PPUSH
5498: CALL 4736 0 2
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: LD_VAR 0 1
5514: NOT
5515: PUSH
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: LD_VAR 0 2
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL 4894 0 1
5567: PPUSH
5568: CALL 4736 0 2
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: LD_VAR 0 1
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: LD_VAR 0 2
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: LD_ADDR_VAR 0 8
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: CALL 4894 0 1
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: LD_ADDR_VAR 0 8
5620: PUSH
5621: LD_VAR 0 2
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: LD_ADDR_VAR 0 6
5630: PUSH
5631: LD_VAR 0 1
5635: PPUSH
5636: CALL_OW 503
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: LD_VAR 0 6
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: LD_ADDR_VAR 0 4
5656: PUSH
5657: LD_VAR 0 6
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: LD_ADDR_VAR 0 7
5666: PUSH
5667: LD_OWVAR 3
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: DIFF
5694: PPUSH
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 74
5704: ST_TO_ADDR
// if nearest_unit then
5705: LD_VAR 0 7
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_VAR 0 7
5720: PPUSH
5721: CALL_OW 255
5725: ST_TO_ADDR
// if not side and not side2 then
5726: LD_VAR 0 4
5730: NOT
5731: PUSH
5732: LD_VAR 0 5
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 5
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: LD_VAR 0 4
5758: PPUSH
5759: LD_VAR 0 8
5763: PPUSH
5764: CALL 4736 0 2
5768: GO 5818
// begin if side then
5770: LD_VAR 0 4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: LD_VAR 0 4
5780: PPUSH
5781: LD_VAR 0 8
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: CALL 4736 0 2
// if side2 then
5794: LD_VAR 0 5
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: LD_VAR 0 5
5804: PPUSH
5805: LD_VAR 0 8
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: CALL 4736 0 2
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 4894 0 1
5838: PPUSH
5839: CALL 4736 0 2
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: LD_ADDR_VAR 0 9
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: CALL_OW 69
5878: ST_TO_ADDR
// side_bot := side ;
5879: LD_ADDR_EXP 3
5883: PUSH
5884: LD_VAR 0 1
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: LD_VAR 0 9
5893: PUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_VAR 0 9
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: LD_VAR 0 3
5922: PPUSH
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 235
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: LD_ADDR_VAR 0 10
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 10
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: LD_VAR 0 3
6012: PPUSH
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 322
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: LD_ADDR_VAR 0 8
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_OWVAR 67
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: CALL_OW 169
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: CALL_OW 67
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: LD_VAR 0 1
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: LD_ADDR_EXP 33
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: LD_VAR 0 8
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: CALL 18084 0 6
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: LD_ADDR_EXP 34
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: LD_VAR 0 8
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL 18084 0 6
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
6205: LD_ADDR_EXP 31
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: LD_VAR 0 8
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 10
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL 18084 0 6
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: LD_ADDR_EXP 32
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: LD_VAR 0 8
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL 18084 0 6
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: LD_ADDR_EXP 35
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: LD_VAR 0 8
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: CALL 18084 0 6
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: LD_ADDR_EXP 43
6377: PUSH
6378: LD_EXP 33
6382: PUSH
6383: LD_EXP 31
6387: PUSH
6388: LD_EXP 35
6392: PUSH
6393: LD_EXP 32
6397: PUSH
6398: LD_EXP 34
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: LD_ADDR_VAR 0 5
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: LD_VAR 0 3
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: LD_VAR 0 8
6511: PPUSH
6512: CALL_OW 380
// un := CreateVehicle ;
6516: LD_ADDR_VAR 0 6
6520: PUSH
6521: CALL_OW 45
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: PPUSH
6542: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: LD_VAR 0 5
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: CALL_OW 50
// un2 := CreateHuman ;
6579: LD_ADDR_VAR 0 7
6583: PUSH
6584: CALL_OW 44
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: LD_VAR 0 7
6593: PPUSH
6594: LD_VAR 0 6
6598: PPUSH
6599: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: LD_ADDR_EXP 43
6607: PUSH
6608: LD_EXP 43
6612: PPUSH
6613: LD_VAR 0 3
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: LD_EXP 43
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: LD_VAR 0 6
6657: PPUSH
6658: CALL 14797 0 3
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: LD_ADDR_EXP 43
6667: PUSH
6668: LD_EXP 43
6672: PPUSH
6673: LD_VAR 0 3
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: LD_EXP 43
6690: PUSH
6691: LD_VAR 0 3
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: LD_VAR 0 7
6717: PPUSH
6718: CALL 14797 0 3
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: LD_EXP 3
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: LD_VAR 0 3
6777: PPUSH
6778: CALL_OW 274
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: LD_ADDR_VAR 0 4
6790: PUSH
6791: LD_VAR 0 3
6795: PPUSH
6796: CALL_OW 254
6800: ST_TO_ADDR
// if d < 3 then
6801: LD_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: LD_ADDR_VAR 0 4
6815: PUSH
6816: LD_VAR 0 4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: LD_ADDR_VAR 0 4
6831: PUSH
6832: LD_VAR 0 4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: LD_VAR 0 8
6851: PPUSH
6852: CALL_OW 380
// un := CreateHuman ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: CALL_OW 44
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: LD_VAR 0 6
6870: PPUSH
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6880: LD_VAR 0 6
6884: PPUSH
6885: LD_VAR 0 3
6889: PPUSH
6890: CALL_OW 52
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: LD_ADDR_EXP 36
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_VAR 0 8
6915: PPUSH
6916: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: LD_ADDR_EXP 36
6940: PUSH
6941: LD_EXP 36
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: CALL_OW 44
6953: PPUSH
6954: CALL_OW 1
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: LD_VAR 0 8
6969: PPUSH
6970: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: LD_ADDR_EXP 36
6994: PUSH
6995: LD_EXP 36
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: CALL_OW 44
7007: PPUSH
7008: CALL_OW 1
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: LD_VAR 0 8
7023: PPUSH
7024: CALL_OW 380
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: LD_ADDR_EXP 36
7040: PUSH
7041: LD_EXP 36
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 44
7053: PPUSH
7054: CALL_OW 1
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: LD_ADDR_EXP 39
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: LD_EXP 39
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: CALL_OW 52
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: LD_ADDR_EXP 40
7203: PUSH
7204: CALL_OW 44
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: LD_EXP 40
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: CALL_OW 52
// InitHc ;
7221: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: LD_ADDR_EXP 38
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: LD_ADDR_VAR 0 4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: LD_OWVAR 67
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: LD_ADDR_VAR 0 3
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 12
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: CALL 14675 0 5
// un := CreateVehicle ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: CALL_OW 45
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: LD_ADDR_EXP 38
7391: PUSH
7392: LD_EXP 38
7396: PPUSH
7397: LD_VAR 0 3
7401: PUSH
7402: LD_EXP 38
7406: PUSH
7407: LD_VAR 0 3
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: LD_VAR 0 6
7425: PPUSH
7426: CALL 14797 0 3
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: LD_VAR 0 6
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: CALL_OW 12
7446: PPUSH
7447: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: LD_VAR 0 6
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_VAR 0 3
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: CALL_OW 19
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: CALL_OW 302
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: CALL_OW 255
7519: PUSH
7520: LD_EXP 3
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: LD_ADDR_VAR 0 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: LD_ADDR_VAR 0 7
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: LD_ADDR_VAR 0 6
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: LD_ADDR_VAR 0 9
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: LD_ADDR_VAR 0 5
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: LD_OWVAR 67
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: LD_ADDR_VAR 0 1
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_OWVAR 67
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_VAR 0 5
7790: PPUSH
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: CALL_OW 12
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 2
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: LD_VAR 0 4
7858: PPUSH
7859: LD_VAR 0 5
7863: PPUSH
7864: CALL 70727 0 2
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7875: LD_VAR 0 4
7879: PPUSH
7880: CALL 71123 0 1
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: CALL_OW 67
// for i = 1 to coords do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: LD_VAR 0 6
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: LD_EXP 3
7924: PPUSH
7925: LD_VAR 0 6
7929: PUSH
7930: LD_VAR 0 1
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: LD_VAR 0 6
7944: PUSH
7945: LD_VAR 0 1
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: CALL 15693 0 4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: LD_VAR 0 2
7971: PUSH
7972: LD_VAR 0 3
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 2
7988: ST_TO_ADDR
// target := i ;
7989: LD_ADDR_VAR 0 9
7993: PUSH
7994: LD_VAR 0 1
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: LD_VAR 0 9
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: LD_ADDR_VAR 0 10
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: LD_ADDR_VAR 0 10
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: LD_VAR 0 10
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: LD_ADDR_VAR 0 10
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: LD_VAR 0 4
8209: PPUSH
8210: LD_EXP 62
8214: PUSH
8215: LD_VAR 0 4
8219: ARRAY
8220: PPUSH
8221: LD_VAR 0 10
8225: PPUSH
8226: LD_VAR 0 7
8230: PPUSH
8231: CALL 70960 0 4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: CALL_OW 302
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: CALL_OW 255
8253: PUSH
8254: LD_EXP 3
8258: EQUAL
8259: AND
8260: PUSH
8261: LD_EXP 26
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: CALL_OW 301
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: CALL_OW 255
8286: PUSH
8287: LD_EXP 3
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: LD_ADDR_VAR 0 7
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: LD_ADDR_VAR 0 9
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: LD_ADDR_VAR 0 5
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: LD_OWVAR 67
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: LD_ADDR_VAR 0 1
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: LD_OWVAR 67
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: LD_ADDR_VAR 0 5
8512: PUSH
8513: LD_VAR 0 5
8517: PPUSH
8518: LD_VAR 0 5
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 1
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 2
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 5
8588: PPUSH
8589: CALL 70727 0 2
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL 71123 0 1
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: CALL_OW 67
// for i = 1 to coords do
8622: LD_ADDR_VAR 0 1
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: LD_VAR 0 6
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_EXP 3
8649: PPUSH
8650: LD_VAR 0 6
8654: PUSH
8655: LD_VAR 0 1
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_VAR 0 6
8669: PUSH
8670: LD_VAR 0 1
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: CALL 15693 0 4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_VAR 0 3
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_VAR 0 2
8713: ST_TO_ADDR
// target := i ;
8714: LD_ADDR_VAR 0 9
8718: PUSH
8719: LD_VAR 0 1
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: LD_VAR 0 9
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: LD_ADDR_VAR 0 10
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: LD_VAR 0 10
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: LD_ADDR_VAR 0 10
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_EXP 62
8859: PUSH
8860: LD_VAR 0 4
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 10
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL 70960 0 4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: LD_EXP 4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 255
8904: PPUSH
8905: CALL 5823 0 1
// artifact_get := true ;
8909: LD_ADDR_EXP 4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: LD_ADDR_VAR 0 3
8928: PUSH
8929: LD_VAR 0 1
8933: PPUSH
8934: CALL_OW 255
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_EXP 69
8948: IN
8949: NOT
8950: PUSH
8951: LD_EXP 7
8955: PUSH
8956: LD_VAR 0 3
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: LD_VAR 0 1
8968: PPUSH
8969: CALL_OW 247
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: LD_VAR 0 3
8983: PPUSH
8984: CALL 5463 0 1
// if side in mc_sides then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_EXP 69
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: LD_VAR 0 1
9004: PUSH
9005: LD_EXP 40
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: CALL 5577 0 2
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: CALL 4894 0 1
9038: PPUSH
9039: CALL 5577 0 2
// if multi_commanders and multi_custom_commanders then
9043: LD_EXP 24
9047: PUSH
9048: LD_EXP 16
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: LD_VAR 0 1
9059: PUSH
9060: LD_EXP 24
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: LD_ADDR_EXP 25
9071: PUSH
9072: LD_EXP 25
9076: PPUSH
9077: LD_VAR 0 3
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: CALL_OW 1
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: LD_ADDR_EXP 24
9094: PUSH
9095: LD_EXP 24
9099: PUSH
9100: LD_VAR 0 1
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: CALL 4927 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL 74186 0 1
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL 76520 0 2
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: LD_VAR 0 1
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_EXP 69
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: LD_VAR 0 1
9169: PPUSH
9170: CALL_OW 255
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 266
9184: PPUSH
9185: CALL 5507 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: LD_VAR 0 1
9193: PPUSH
9194: CALL_OW 266
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_EXP 69
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: LD_EXP 5
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: LD_VAR 0 1
9232: PPUSH
9233: LD_EXP 5
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9246: LD_ADDR_EXP 5
9250: PUSH
9251: LD_EXP 5
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: CALL_OW 3
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: CALL 75829 0 1
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL 73882 0 2
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: LD_VAR 0 1
9297: PPUSH
9298: LD_VAR 0 2
9302: PPUSH
9303: LD_VAR 0 3
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: LD_VAR 0 5
9317: PPUSH
9318: CALL 73502 0 5
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 255
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: LD_VAR 0 4
9349: PUSH
9350: LD_EXP 69
9354: IN
9355: NOT
9356: PUSH
9357: LD_EXP 7
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: LD_VAR 0 4
9374: PPUSH
9375: CALL 5419 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_VAR 0 2
9388: PPUSH
9389: CALL 73092 0 2
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: LD_VAR 0 1
9400: PPUSH
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 3
9410: PPUSH
9411: LD_VAR 0 4
9415: PPUSH
9416: CALL 72930 0 4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: LD_VAR 0 3
9437: PPUSH
9438: CALL 72705 0 3
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_VAR 0 2
9454: PPUSH
9455: CALL 72590 0 2
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: LD_VAR 0 1
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: CALL 76781 0 2
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PPUSH
9489: LD_VAR 0 3
9493: PPUSH
9494: LD_VAR 0 4
9498: PPUSH
9499: CALL 76997 0 4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: LD_EXP 2
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: LD_EXP 21
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: LD_EXP 21
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: CALL 9556 0 3
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: LD_VAR 0 1
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 67
// x := 5 ;
9599: LD_ADDR_VAR 0 6
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: LD_OWVAR 1
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: LD_OWVAR 67
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: LD_ADDR_VAR 0 5
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_EXP 7
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: LD_EXP 7
9656: PUSH
9657: LD_VAR 0 5
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: LD_VAR 0 6
9668: PPUSH
9669: LD_VAR 0 7
9673: PUSH
9674: LD_EXP 7
9678: PUSH
9679: LD_VAR 0 5
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 55
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: CALL_OW 67
// end ; for i in areas do
9704: LD_ADDR_VAR 0 5
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9724: LD_VAR 0 6
9728: PPUSH
9729: LD_VAR 0 5
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL_OW 55
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_VAR 0 2
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: LD_ADDR_VAR 0 3
9763: PUSH
9764: LD_VAR 0 3
9768: PUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: LD_ADDR_VAR 0 6
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: LD_ADDR_VAR 0 6
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: LD_EXP 2
9833: NOT
9834: PUSH
9835: LD_VAR 0 3
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: LD_VAR 0 2
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: LD_ADDR_VAR 0 5
9865: PUSH
9866: LD_VAR 0 3
9870: PUSH
9871: LD_VAR 0 1
9875: STR
9876: PPUSH
9877: CALL_OW 34
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: LD_ADDR_VAR 0 5
9888: PUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 25
9898: ST_TO_ADDR
// result := unit ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_VAR 0 5
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: LD_VAR 0 1
9922: NOT
9923: PUSH
9924: LD_VAR 0 2
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10698
// case nation of nation_american :
9934: LD_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: LD_ADDR_VAR 0 4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10622
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10391
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10170: LD_ADDR_VAR 0 4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: ST_TO_ADDR
10389: GO 10622
10391: LD_INT 3
10393: DOUBLE
10394: EQUAL
10395: IFTRUE 10399
10397: GO 10621
10399: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10400: LD_ADDR_VAR 0 4
10404: PUSH
10405: LD_INT 46
10407: PUSH
10408: LD_INT 47
10410: PUSH
10411: LD_INT 1
10413: PUSH
10414: LD_INT 2
10416: PUSH
10417: LD_INT 82
10419: PUSH
10420: LD_INT 83
10422: PUSH
10423: LD_INT 84
10425: PUSH
10426: LD_INT 85
10428: PUSH
10429: LD_INT 86
10431: PUSH
10432: LD_INT 11
10434: PUSH
10435: LD_INT 9
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 19
10443: PUSH
10444: LD_INT 21
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 25
10455: PUSH
10456: LD_INT 28
10458: PUSH
10459: LD_INT 29
10461: PUSH
10462: LD_INT 30
10464: PUSH
10465: LD_INT 31
10467: PUSH
10468: LD_INT 37
10470: PUSH
10471: LD_INT 38
10473: PUSH
10474: LD_INT 32
10476: PUSH
10477: LD_INT 27
10479: PUSH
10480: LD_INT 33
10482: PUSH
10483: LD_INT 69
10485: PUSH
10486: LD_INT 39
10488: PUSH
10489: LD_INT 34
10491: PUSH
10492: LD_INT 40
10494: PUSH
10495: LD_INT 71
10497: PUSH
10498: LD_INT 23
10500: PUSH
10501: LD_INT 44
10503: PUSH
10504: LD_INT 48
10506: PUSH
10507: LD_INT 49
10509: PUSH
10510: LD_INT 50
10512: PUSH
10513: LD_INT 51
10515: PUSH
10516: LD_INT 52
10518: PUSH
10519: LD_INT 53
10521: PUSH
10522: LD_INT 54
10524: PUSH
10525: LD_INT 55
10527: PUSH
10528: LD_INT 56
10530: PUSH
10531: LD_INT 57
10533: PUSH
10534: LD_INT 58
10536: PUSH
10537: LD_INT 59
10539: PUSH
10540: LD_INT 63
10542: PUSH
10543: LD_INT 64
10545: PUSH
10546: LD_INT 65
10548: PUSH
10549: LD_INT 82
10551: PUSH
10552: LD_INT 83
10554: PUSH
10555: LD_INT 84
10557: PUSH
10558: LD_INT 85
10560: PUSH
10561: LD_INT 86
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: ST_TO_ADDR
10619: GO 10622
10621: POP
// if state > - 1 and state < 3 then
10622: LD_VAR 0 3
10626: PUSH
10627: LD_INT 1
10629: NEG
10630: GREATER
10631: PUSH
10632: LD_VAR 0 3
10636: PUSH
10637: LD_INT 3
10639: LESS
10640: AND
10641: IFFALSE 10698
// for i in result do
10643: LD_ADDR_VAR 0 5
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: FOR_IN
10654: IFFALSE 10696
// if GetTech ( i , side ) <> state then
10656: LD_VAR 0 5
10660: PPUSH
10661: LD_VAR 0 1
10665: PPUSH
10666: CALL_OW 321
10670: PUSH
10671: LD_VAR 0 3
10675: NONEQUAL
10676: IFFALSE 10694
// result := result diff i ;
10678: LD_ADDR_VAR 0 4
10682: PUSH
10683: LD_VAR 0 4
10687: PUSH
10688: LD_VAR 0 5
10692: DIFF
10693: ST_TO_ADDR
10694: GO 10653
10696: POP
10697: POP
// end ;
10698: LD_VAR 0 4
10702: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
// result := true ;
10708: LD_ADDR_VAR 0 3
10712: PUSH
10713: LD_INT 1
10715: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10716: LD_ADDR_VAR 0 5
10720: PUSH
10721: LD_VAR 0 2
10725: PPUSH
10726: CALL_OW 480
10730: ST_TO_ADDR
// if not tmp then
10731: LD_VAR 0 5
10735: NOT
10736: IFFALSE 10740
// exit ;
10738: GO 10789
// for i in tmp do
10740: LD_ADDR_VAR 0 4
10744: PUSH
10745: LD_VAR 0 5
10749: PUSH
10750: FOR_IN
10751: IFFALSE 10787
// if GetTech ( i , side ) <> state_researched then
10753: LD_VAR 0 4
10757: PPUSH
10758: LD_VAR 0 1
10762: PPUSH
10763: CALL_OW 321
10767: PUSH
10768: LD_INT 2
10770: NONEQUAL
10771: IFFALSE 10785
// begin result := false ;
10773: LD_ADDR_VAR 0 3
10777: PUSH
10778: LD_INT 0
10780: ST_TO_ADDR
// exit ;
10781: POP
10782: POP
10783: GO 10789
// end ;
10785: GO 10750
10787: POP
10788: POP
// end ;
10789: LD_VAR 0 3
10793: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10794: LD_INT 0
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10809: LD_VAR 0 1
10813: NOT
10814: PUSH
10815: LD_VAR 0 1
10819: PPUSH
10820: CALL_OW 257
10824: PUSH
10825: LD_INT 9
10827: NONEQUAL
10828: OR
10829: IFFALSE 10833
// exit ;
10831: GO 11406
// side := GetSide ( unit ) ;
10833: LD_ADDR_VAR 0 9
10837: PUSH
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 255
10847: ST_TO_ADDR
// tech_space := tech_spacanom ;
10848: LD_ADDR_VAR 0 12
10852: PUSH
10853: LD_INT 29
10855: ST_TO_ADDR
// tech_time := tech_taurad ;
10856: LD_ADDR_VAR 0 13
10860: PUSH
10861: LD_INT 28
10863: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10864: LD_ADDR_VAR 0 11
10868: PUSH
10869: LD_VAR 0 1
10873: PPUSH
10874: CALL_OW 310
10878: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10879: LD_VAR 0 11
10883: PPUSH
10884: CALL_OW 247
10888: PUSH
10889: LD_INT 2
10891: EQUAL
10892: IFFALSE 10896
// exit ;
10894: GO 11406
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10896: LD_ADDR_VAR 0 8
10900: PUSH
10901: LD_INT 81
10903: PUSH
10904: LD_VAR 0 9
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 3
10915: PUSH
10916: LD_INT 21
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PPUSH
10934: CALL_OW 69
10938: ST_TO_ADDR
// if not tmp then
10939: LD_VAR 0 8
10943: NOT
10944: IFFALSE 10948
// exit ;
10946: GO 11406
// if in_unit then
10948: LD_VAR 0 11
10952: IFFALSE 10976
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10954: LD_ADDR_VAR 0 10
10958: PUSH
10959: LD_VAR 0 8
10963: PPUSH
10964: LD_VAR 0 11
10968: PPUSH
10969: CALL_OW 74
10973: ST_TO_ADDR
10974: GO 10996
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10976: LD_ADDR_VAR 0 10
10980: PUSH
10981: LD_VAR 0 8
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: ST_TO_ADDR
// if not enemy then
10996: LD_VAR 0 10
11000: NOT
11001: IFFALSE 11005
// exit ;
11003: GO 11406
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11005: LD_VAR 0 11
11009: PUSH
11010: LD_VAR 0 11
11014: PPUSH
11015: LD_VAR 0 10
11019: PPUSH
11020: CALL_OW 296
11024: PUSH
11025: LD_INT 13
11027: GREATER
11028: AND
11029: PUSH
11030: LD_VAR 0 1
11034: PPUSH
11035: LD_VAR 0 10
11039: PPUSH
11040: CALL_OW 296
11044: PUSH
11045: LD_INT 12
11047: GREATER
11048: OR
11049: IFFALSE 11053
// exit ;
11051: GO 11406
// missile := [ 1 ] ;
11053: LD_ADDR_VAR 0 14
11057: PUSH
11058: LD_INT 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11064: LD_VAR 0 9
11068: PPUSH
11069: LD_VAR 0 12
11073: PPUSH
11074: CALL_OW 325
11078: IFFALSE 11107
// missile := Insert ( missile , missile + 1 , 2 ) ;
11080: LD_ADDR_VAR 0 14
11084: PUSH
11085: LD_VAR 0 14
11089: PPUSH
11090: LD_VAR 0 14
11094: PUSH
11095: LD_INT 1
11097: PLUS
11098: PPUSH
11099: LD_INT 2
11101: PPUSH
11102: CALL_OW 2
11106: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11107: LD_VAR 0 9
11111: PPUSH
11112: LD_VAR 0 13
11116: PPUSH
11117: CALL_OW 325
11121: PUSH
11122: LD_VAR 0 10
11126: PPUSH
11127: CALL_OW 255
11131: PPUSH
11132: LD_VAR 0 13
11136: PPUSH
11137: CALL_OW 325
11141: NOT
11142: AND
11143: IFFALSE 11172
// missile := Insert ( missile , missile + 1 , 3 ) ;
11145: LD_ADDR_VAR 0 14
11149: PUSH
11150: LD_VAR 0 14
11154: PPUSH
11155: LD_VAR 0 14
11159: PUSH
11160: LD_INT 1
11162: PLUS
11163: PPUSH
11164: LD_INT 3
11166: PPUSH
11167: CALL_OW 2
11171: ST_TO_ADDR
// if missile < 2 then
11172: LD_VAR 0 14
11176: PUSH
11177: LD_INT 2
11179: LESS
11180: IFFALSE 11184
// exit ;
11182: GO 11406
// x := GetX ( enemy ) ;
11184: LD_ADDR_VAR 0 4
11188: PUSH
11189: LD_VAR 0 10
11193: PPUSH
11194: CALL_OW 250
11198: ST_TO_ADDR
// y := GetY ( enemy ) ;
11199: LD_ADDR_VAR 0 5
11203: PUSH
11204: LD_VAR 0 10
11208: PPUSH
11209: CALL_OW 251
11213: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 4
11223: PUSH
11224: LD_INT 1
11226: NEG
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL_OW 12
11235: PLUS
11236: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11237: LD_ADDR_VAR 0 7
11241: PUSH
11242: LD_VAR 0 5
11246: PUSH
11247: LD_INT 1
11249: NEG
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: CALL_OW 12
11258: PLUS
11259: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11260: LD_VAR 0 6
11264: PPUSH
11265: LD_VAR 0 7
11269: PPUSH
11270: CALL_OW 488
11274: NOT
11275: IFFALSE 11297
// begin _x := x ;
11277: LD_ADDR_VAR 0 6
11281: PUSH
11282: LD_VAR 0 4
11286: ST_TO_ADDR
// _y := y ;
11287: LD_ADDR_VAR 0 7
11291: PUSH
11292: LD_VAR 0 5
11296: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11297: LD_ADDR_VAR 0 3
11301: PUSH
11302: LD_INT 1
11304: PPUSH
11305: LD_VAR 0 14
11309: PPUSH
11310: CALL_OW 12
11314: ST_TO_ADDR
// case i of 1 :
11315: LD_VAR 0 3
11319: PUSH
11320: LD_INT 1
11322: DOUBLE
11323: EQUAL
11324: IFTRUE 11328
11326: GO 11345
11328: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11329: LD_VAR 0 1
11333: PPUSH
11334: LD_VAR 0 10
11338: PPUSH
11339: CALL_OW 115
11343: GO 11406
11345: LD_INT 2
11347: DOUBLE
11348: EQUAL
11349: IFTRUE 11353
11351: GO 11375
11353: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_VAR 0 6
11363: PPUSH
11364: LD_VAR 0 7
11368: PPUSH
11369: CALL_OW 153
11373: GO 11406
11375: LD_INT 3
11377: DOUBLE
11378: EQUAL
11379: IFTRUE 11383
11381: GO 11405
11383: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11384: LD_VAR 0 1
11388: PPUSH
11389: LD_VAR 0 6
11393: PPUSH
11394: LD_VAR 0 7
11398: PPUSH
11399: CALL_OW 154
11403: GO 11406
11405: POP
// end ;
11406: LD_VAR 0 2
11410: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11411: LD_INT 0
11413: PPUSH
11414: PPUSH
11415: PPUSH
11416: PPUSH
11417: PPUSH
11418: PPUSH
// if not unit or not building then
11419: LD_VAR 0 1
11423: NOT
11424: PUSH
11425: LD_VAR 0 2
11429: NOT
11430: OR
11431: IFFALSE 11435
// exit ;
11433: GO 11593
// x := GetX ( building ) ;
11435: LD_ADDR_VAR 0 5
11439: PUSH
11440: LD_VAR 0 2
11444: PPUSH
11445: CALL_OW 250
11449: ST_TO_ADDR
// y := GetY ( building ) ;
11450: LD_ADDR_VAR 0 6
11454: PUSH
11455: LD_VAR 0 2
11459: PPUSH
11460: CALL_OW 251
11464: ST_TO_ADDR
// for i = 0 to 5 do
11465: LD_ADDR_VAR 0 4
11469: PUSH
11470: DOUBLE
11471: LD_INT 0
11473: DEC
11474: ST_TO_ADDR
11475: LD_INT 5
11477: PUSH
11478: FOR_TO
11479: IFFALSE 11591
// begin _x := ShiftX ( x , i , 3 ) ;
11481: LD_ADDR_VAR 0 7
11485: PUSH
11486: LD_VAR 0 5
11490: PPUSH
11491: LD_VAR 0 4
11495: PPUSH
11496: LD_INT 3
11498: PPUSH
11499: CALL_OW 272
11503: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11504: LD_ADDR_VAR 0 8
11508: PUSH
11509: LD_VAR 0 6
11513: PPUSH
11514: LD_VAR 0 4
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: CALL_OW 273
11526: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11527: LD_VAR 0 7
11531: PPUSH
11532: LD_VAR 0 8
11536: PPUSH
11537: CALL_OW 488
11541: NOT
11542: IFFALSE 11546
// continue ;
11544: GO 11478
// if HexInfo ( _x , _y ) = 0 then
11546: LD_VAR 0 7
11550: PPUSH
11551: LD_VAR 0 8
11555: PPUSH
11556: CALL_OW 428
11560: PUSH
11561: LD_INT 0
11563: EQUAL
11564: IFFALSE 11589
// begin ComMoveXY ( unit , _x , _y ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: LD_VAR 0 7
11575: PPUSH
11576: LD_VAR 0 8
11580: PPUSH
11581: CALL_OW 111
// exit ;
11585: POP
11586: POP
11587: GO 11593
// end ; end ;
11589: GO 11478
11591: POP
11592: POP
// end ;
11593: LD_VAR 0 3
11597: RET
// export function ScanBase ( side , base_area ) ; begin
11598: LD_INT 0
11600: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11601: LD_ADDR_VAR 0 3
11605: PUSH
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 81
11613: PUSH
11614: LD_VAR 0 1
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 70
11627: ST_TO_ADDR
// end ;
11628: LD_VAR 0 3
11632: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11633: LD_INT 0
11635: PPUSH
11636: PPUSH
11637: PPUSH
11638: PPUSH
// result := false ;
11639: LD_ADDR_VAR 0 2
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
// side := GetSide ( unit ) ;
11647: LD_ADDR_VAR 0 3
11651: PUSH
11652: LD_VAR 0 1
11656: PPUSH
11657: CALL_OW 255
11661: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11662: LD_ADDR_VAR 0 4
11666: PUSH
11667: LD_VAR 0 1
11671: PPUSH
11672: CALL_OW 248
11676: ST_TO_ADDR
// case nat of 1 :
11677: LD_VAR 0 4
11681: PUSH
11682: LD_INT 1
11684: DOUBLE
11685: EQUAL
11686: IFTRUE 11690
11688: GO 11701
11690: POP
// tech := tech_lassight ; 2 :
11691: LD_ADDR_VAR 0 5
11695: PUSH
11696: LD_INT 12
11698: ST_TO_ADDR
11699: GO 11740
11701: LD_INT 2
11703: DOUBLE
11704: EQUAL
11705: IFTRUE 11709
11707: GO 11720
11709: POP
// tech := tech_mortar ; 3 :
11710: LD_ADDR_VAR 0 5
11714: PUSH
11715: LD_INT 41
11717: ST_TO_ADDR
11718: GO 11740
11720: LD_INT 3
11722: DOUBLE
11723: EQUAL
11724: IFTRUE 11728
11726: GO 11739
11728: POP
// tech := tech_bazooka ; end ;
11729: LD_ADDR_VAR 0 5
11733: PUSH
11734: LD_INT 44
11736: ST_TO_ADDR
11737: GO 11740
11739: POP
// if Researched ( side , tech ) then
11740: LD_VAR 0 3
11744: PPUSH
11745: LD_VAR 0 5
11749: PPUSH
11750: CALL_OW 325
11754: IFFALSE 11781
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11756: LD_ADDR_VAR 0 2
11760: PUSH
11761: LD_INT 5
11763: PUSH
11764: LD_INT 8
11766: PUSH
11767: LD_INT 9
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_VAR 0 4
11779: ARRAY
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 2
11785: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11786: LD_INT 0
11788: PPUSH
11789: PPUSH
11790: PPUSH
// if not mines then
11791: LD_VAR 0 2
11795: NOT
11796: IFFALSE 11800
// exit ;
11798: GO 11944
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_INT 81
11807: PUSH
11808: LD_VAR 0 1
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: PUSH
11817: LD_INT 3
11819: PUSH
11820: LD_INT 21
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PPUSH
11838: CALL_OW 69
11842: ST_TO_ADDR
// for i in mines do
11843: LD_ADDR_VAR 0 4
11847: PUSH
11848: LD_VAR 0 2
11852: PUSH
11853: FOR_IN
11854: IFFALSE 11942
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11856: LD_VAR 0 4
11860: PUSH
11861: LD_INT 1
11863: ARRAY
11864: PPUSH
11865: LD_VAR 0 4
11869: PUSH
11870: LD_INT 2
11872: ARRAY
11873: PPUSH
11874: CALL_OW 458
11878: NOT
11879: IFFALSE 11883
// continue ;
11881: GO 11853
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11883: LD_VAR 0 4
11887: PUSH
11888: LD_INT 1
11890: ARRAY
11891: PPUSH
11892: LD_VAR 0 4
11896: PUSH
11897: LD_INT 2
11899: ARRAY
11900: PPUSH
11901: CALL_OW 428
11905: PUSH
11906: LD_VAR 0 5
11910: IN
11911: IFFALSE 11940
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11913: LD_VAR 0 4
11917: PUSH
11918: LD_INT 1
11920: ARRAY
11921: PPUSH
11922: LD_VAR 0 4
11926: PUSH
11927: LD_INT 2
11929: ARRAY
11930: PPUSH
11931: LD_VAR 0 1
11935: PPUSH
11936: CALL_OW 456
// end ;
11940: GO 11853
11942: POP
11943: POP
// end ;
11944: LD_VAR 0 3
11948: RET
// export function Count ( array ) ; var i ; begin
11949: LD_INT 0
11951: PPUSH
11952: PPUSH
// result := 0 ;
11953: LD_ADDR_VAR 0 2
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// for i in array do
11961: LD_ADDR_VAR 0 3
11965: PUSH
11966: LD_VAR 0 1
11970: PUSH
11971: FOR_IN
11972: IFFALSE 11996
// if i then
11974: LD_VAR 0 3
11978: IFFALSE 11994
// result := result + 1 ;
11980: LD_ADDR_VAR 0 2
11984: PUSH
11985: LD_VAR 0 2
11989: PUSH
11990: LD_INT 1
11992: PLUS
11993: ST_TO_ADDR
11994: GO 11971
11996: POP
11997: POP
// end ;
11998: LD_VAR 0 2
12002: RET
// export function IsEmpty ( building ) ; begin
12003: LD_INT 0
12005: PPUSH
// if not building then
12006: LD_VAR 0 1
12010: NOT
12011: IFFALSE 12015
// exit ;
12013: GO 12058
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12015: LD_ADDR_VAR 0 2
12019: PUSH
12020: LD_VAR 0 1
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 58
12044: PUSH
12045: EMPTY
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PPUSH
12052: CALL_OW 69
12056: IN
12057: ST_TO_ADDR
// end ;
12058: LD_VAR 0 2
12062: RET
// export function IsNotFull ( building ) ; begin
12063: LD_INT 0
12065: PPUSH
// if not building then
12066: LD_VAR 0 1
12070: NOT
12071: IFFALSE 12075
// exit ;
12073: GO 12094
// result := UnitsInside ( building ) < 6 ;
12075: LD_ADDR_VAR 0 2
12079: PUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 313
12089: PUSH
12090: LD_INT 6
12092: LESS
12093: ST_TO_ADDR
// end ;
12094: LD_VAR 0 2
12098: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
12103: PPUSH
12104: PPUSH
// tmp := [ ] ;
12105: LD_ADDR_VAR 0 3
12109: PUSH
12110: EMPTY
12111: ST_TO_ADDR
// list := [ ] ;
12112: LD_ADDR_VAR 0 5
12116: PUSH
12117: EMPTY
12118: ST_TO_ADDR
// for i = 16 to 25 do
12119: LD_ADDR_VAR 0 4
12123: PUSH
12124: DOUBLE
12125: LD_INT 16
12127: DEC
12128: ST_TO_ADDR
12129: LD_INT 25
12131: PUSH
12132: FOR_TO
12133: IFFALSE 12206
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12135: LD_ADDR_VAR 0 3
12139: PUSH
12140: LD_VAR 0 3
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: LD_VAR 0 1
12152: PPUSH
12153: CALL_OW 255
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 91
12164: PUSH
12165: LD_VAR 0 1
12169: PUSH
12170: LD_INT 6
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 30
12180: PUSH
12181: LD_VAR 0 4
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: PUSH
12195: EMPTY
12196: LIST
12197: PPUSH
12198: CALL_OW 69
12202: ADD
12203: ST_TO_ADDR
12204: GO 12132
12206: POP
12207: POP
// for i = 1 to tmp do
12208: LD_ADDR_VAR 0 4
12212: PUSH
12213: DOUBLE
12214: LD_INT 1
12216: DEC
12217: ST_TO_ADDR
12218: LD_VAR 0 3
12222: PUSH
12223: FOR_TO
12224: IFFALSE 12312
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12226: LD_ADDR_VAR 0 5
12230: PUSH
12231: LD_VAR 0 5
12235: PUSH
12236: LD_VAR 0 3
12240: PUSH
12241: LD_VAR 0 4
12245: ARRAY
12246: PPUSH
12247: CALL_OW 266
12251: PUSH
12252: LD_VAR 0 3
12256: PUSH
12257: LD_VAR 0 4
12261: ARRAY
12262: PPUSH
12263: CALL_OW 250
12267: PUSH
12268: LD_VAR 0 3
12272: PUSH
12273: LD_VAR 0 4
12277: ARRAY
12278: PPUSH
12279: CALL_OW 251
12283: PUSH
12284: LD_VAR 0 3
12288: PUSH
12289: LD_VAR 0 4
12293: ARRAY
12294: PPUSH
12295: CALL_OW 254
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: PUSH
12306: EMPTY
12307: LIST
12308: ADD
12309: ST_TO_ADDR
12310: GO 12223
12312: POP
12313: POP
// result := list ;
12314: LD_ADDR_VAR 0 2
12318: PUSH
12319: LD_VAR 0 5
12323: ST_TO_ADDR
// end ;
12324: LD_VAR 0 2
12328: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12329: LD_INT 0
12331: PPUSH
12332: PPUSH
12333: PPUSH
12334: PPUSH
12335: PPUSH
12336: PPUSH
12337: PPUSH
// if not factory then
12338: LD_VAR 0 1
12342: NOT
12343: IFFALSE 12347
// exit ;
12345: GO 12940
// if control = control_apeman then
12347: LD_VAR 0 4
12351: PUSH
12352: LD_INT 5
12354: EQUAL
12355: IFFALSE 12464
// begin tmp := UnitsInside ( factory ) ;
12357: LD_ADDR_VAR 0 8
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 313
12371: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12372: LD_VAR 0 8
12376: PPUSH
12377: LD_INT 25
12379: PUSH
12380: LD_INT 12
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PPUSH
12387: CALL_OW 72
12391: NOT
12392: IFFALSE 12402
// control := control_manual ;
12394: LD_ADDR_VAR 0 4
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12402: LD_ADDR_VAR 0 8
12406: PUSH
12407: LD_VAR 0 1
12411: PPUSH
12412: CALL 12099 0 1
12416: ST_TO_ADDR
// if tmp then
12417: LD_VAR 0 8
12421: IFFALSE 12464
// begin for i in tmp do
12423: LD_ADDR_VAR 0 7
12427: PUSH
12428: LD_VAR 0 8
12432: PUSH
12433: FOR_IN
12434: IFFALSE 12462
// if i [ 1 ] = b_ext_radio then
12436: LD_VAR 0 7
12440: PUSH
12441: LD_INT 1
12443: ARRAY
12444: PUSH
12445: LD_INT 22
12447: EQUAL
12448: IFFALSE 12460
// begin control := control_remote ;
12450: LD_ADDR_VAR 0 4
12454: PUSH
12455: LD_INT 2
12457: ST_TO_ADDR
// break ;
12458: GO 12462
// end ;
12460: GO 12433
12462: POP
12463: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12464: LD_VAR 0 1
12468: PPUSH
12469: LD_VAR 0 2
12473: PPUSH
12474: LD_VAR 0 3
12478: PPUSH
12479: LD_VAR 0 4
12483: PPUSH
12484: LD_VAR 0 5
12488: PPUSH
12489: CALL_OW 448
12493: IFFALSE 12528
// begin result := [ chassis , engine , control , weapon ] ;
12495: LD_ADDR_VAR 0 6
12499: PUSH
12500: LD_VAR 0 2
12504: PUSH
12505: LD_VAR 0 3
12509: PUSH
12510: LD_VAR 0 4
12514: PUSH
12515: LD_VAR 0 5
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: ST_TO_ADDR
// exit ;
12526: GO 12940
// end ; _chassis := AvailableChassisList ( factory ) ;
12528: LD_ADDR_VAR 0 9
12532: PUSH
12533: LD_VAR 0 1
12537: PPUSH
12538: CALL_OW 475
12542: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12543: LD_ADDR_VAR 0 11
12547: PUSH
12548: LD_VAR 0 1
12552: PPUSH
12553: CALL_OW 476
12557: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12558: LD_ADDR_VAR 0 12
12562: PUSH
12563: LD_VAR 0 1
12567: PPUSH
12568: CALL_OW 477
12572: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12573: LD_ADDR_VAR 0 10
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 478
12587: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12588: LD_VAR 0 9
12592: NOT
12593: PUSH
12594: LD_VAR 0 11
12598: NOT
12599: OR
12600: PUSH
12601: LD_VAR 0 12
12605: NOT
12606: OR
12607: PUSH
12608: LD_VAR 0 10
12612: NOT
12613: OR
12614: IFFALSE 12649
// begin result := [ chassis , engine , control , weapon ] ;
12616: LD_ADDR_VAR 0 6
12620: PUSH
12621: LD_VAR 0 2
12625: PUSH
12626: LD_VAR 0 3
12630: PUSH
12631: LD_VAR 0 4
12635: PUSH
12636: LD_VAR 0 5
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: ST_TO_ADDR
// exit ;
12647: GO 12940
// end ; if not chassis in _chassis then
12649: LD_VAR 0 2
12653: PUSH
12654: LD_VAR 0 9
12658: IN
12659: NOT
12660: IFFALSE 12686
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 9
12671: PUSH
12672: LD_INT 1
12674: PPUSH
12675: LD_VAR 0 9
12679: PPUSH
12680: CALL_OW 12
12684: ARRAY
12685: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12686: LD_VAR 0 2
12690: PPUSH
12691: LD_VAR 0 3
12695: PPUSH
12696: CALL 12945 0 2
12700: NOT
12701: IFFALSE 12760
// repeat engine := _engine [ 1 ] ;
12703: LD_ADDR_VAR 0 3
12707: PUSH
12708: LD_VAR 0 11
12712: PUSH
12713: LD_INT 1
12715: ARRAY
12716: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12717: LD_ADDR_VAR 0 11
12721: PUSH
12722: LD_VAR 0 11
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 3
12734: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_VAR 0 3
12744: PPUSH
12745: CALL 12945 0 2
12749: PUSH
12750: LD_VAR 0 11
12754: PUSH
12755: EMPTY
12756: EQUAL
12757: OR
12758: IFFALSE 12703
// if not control in _control then
12760: LD_VAR 0 4
12764: PUSH
12765: LD_VAR 0 12
12769: IN
12770: NOT
12771: IFFALSE 12797
// control := _control [ rand ( 1 , _control ) ] ;
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: LD_VAR 0 12
12782: PUSH
12783: LD_INT 1
12785: PPUSH
12786: LD_VAR 0 12
12790: PPUSH
12791: CALL_OW 12
12795: ARRAY
12796: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12797: LD_VAR 0 2
12801: PPUSH
12802: LD_VAR 0 5
12806: PPUSH
12807: CALL 13165 0 2
12811: NOT
12812: IFFALSE 12871
// repeat weapon := _weapon [ 1 ] ;
12814: LD_ADDR_VAR 0 5
12818: PUSH
12819: LD_VAR 0 10
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12828: LD_ADDR_VAR 0 10
12832: PUSH
12833: LD_VAR 0 10
12837: PPUSH
12838: LD_INT 1
12840: PPUSH
12841: CALL_OW 3
12845: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12846: LD_VAR 0 2
12850: PPUSH
12851: LD_VAR 0 5
12855: PPUSH
12856: CALL 13165 0 2
12860: PUSH
12861: LD_VAR 0 10
12865: PUSH
12866: EMPTY
12867: EQUAL
12868: OR
12869: IFFALSE 12814
// result := [ ] ;
12871: LD_ADDR_VAR 0 6
12875: PUSH
12876: EMPTY
12877: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12878: LD_VAR 0 1
12882: PPUSH
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_VAR 0 3
12892: PPUSH
12893: LD_VAR 0 4
12897: PPUSH
12898: LD_VAR 0 5
12902: PPUSH
12903: CALL_OW 448
12907: IFFALSE 12940
// result := [ chassis , engine , control , weapon ] ;
12909: LD_ADDR_VAR 0 6
12913: PUSH
12914: LD_VAR 0 2
12918: PUSH
12919: LD_VAR 0 3
12923: PUSH
12924: LD_VAR 0 4
12928: PUSH
12929: LD_VAR 0 5
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: ST_TO_ADDR
// end ;
12940: LD_VAR 0 6
12944: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12945: LD_INT 0
12947: PPUSH
// if not chassis or not engine then
12948: LD_VAR 0 1
12952: NOT
12953: PUSH
12954: LD_VAR 0 2
12958: NOT
12959: OR
12960: IFFALSE 12964
// exit ;
12962: GO 13160
// case engine of engine_solar :
12964: LD_VAR 0 2
12968: PUSH
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 13015
12977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12978: LD_ADDR_VAR 0 3
12982: PUSH
12983: LD_INT 11
12985: PUSH
12986: LD_INT 12
12988: PUSH
12989: LD_INT 13
12991: PUSH
12992: LD_INT 14
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: ST_TO_ADDR
13013: GO 13144
13015: LD_INT 1
13017: DOUBLE
13018: EQUAL
13019: IFTRUE 13023
13021: GO 13085
13023: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13024: LD_ADDR_VAR 0 3
13028: PUSH
13029: LD_INT 11
13031: PUSH
13032: LD_INT 12
13034: PUSH
13035: LD_INT 13
13037: PUSH
13038: LD_INT 14
13040: PUSH
13041: LD_INT 1
13043: PUSH
13044: LD_INT 2
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 4
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 21
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 22
13064: PUSH
13065: LD_INT 24
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 13144
13085: LD_INT 3
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13143
13093: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 13
13101: PUSH
13102: LD_INT 14
13104: PUSH
13105: LD_INT 2
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: LD_INT 4
13113: PUSH
13114: LD_INT 5
13116: PUSH
13117: LD_INT 21
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 23
13125: PUSH
13126: LD_INT 24
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: ST_TO_ADDR
13141: GO 13144
13143: POP
// result := ( chassis in result ) ;
13144: LD_ADDR_VAR 0 3
13148: PUSH
13149: LD_VAR 0 1
13153: PUSH
13154: LD_VAR 0 3
13158: IN
13159: ST_TO_ADDR
// end ;
13160: LD_VAR 0 3
13164: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13165: LD_INT 0
13167: PPUSH
// if not chassis or not weapon then
13168: LD_VAR 0 1
13172: NOT
13173: PUSH
13174: LD_VAR 0 2
13178: NOT
13179: OR
13180: IFFALSE 13184
// exit ;
13182: GO 14210
// case weapon of us_machine_gun :
13184: LD_VAR 0 2
13188: PUSH
13189: LD_INT 2
13191: DOUBLE
13192: EQUAL
13193: IFTRUE 13197
13195: GO 13227
13197: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13198: LD_ADDR_VAR 0 3
13202: PUSH
13203: LD_INT 1
13205: PUSH
13206: LD_INT 2
13208: PUSH
13209: LD_INT 3
13211: PUSH
13212: LD_INT 4
13214: PUSH
13215: LD_INT 5
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: ST_TO_ADDR
13225: GO 14194
13227: LD_INT 3
13229: DOUBLE
13230: EQUAL
13231: IFTRUE 13235
13233: GO 13265
13235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13236: LD_ADDR_VAR 0 3
13240: PUSH
13241: LD_INT 1
13243: PUSH
13244: LD_INT 2
13246: PUSH
13247: LD_INT 3
13249: PUSH
13250: LD_INT 4
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: ST_TO_ADDR
13263: GO 14194
13265: LD_INT 11
13267: DOUBLE
13268: EQUAL
13269: IFTRUE 13273
13271: GO 13303
13273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13274: LD_ADDR_VAR 0 3
13278: PUSH
13279: LD_INT 1
13281: PUSH
13282: LD_INT 2
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 4
13290: PUSH
13291: LD_INT 5
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: ST_TO_ADDR
13301: GO 14194
13303: LD_INT 4
13305: DOUBLE
13306: EQUAL
13307: IFTRUE 13311
13309: GO 13337
13311: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13312: LD_ADDR_VAR 0 3
13316: PUSH
13317: LD_INT 2
13319: PUSH
13320: LD_INT 3
13322: PUSH
13323: LD_INT 4
13325: PUSH
13326: LD_INT 5
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: ST_TO_ADDR
13335: GO 14194
13337: LD_INT 5
13339: DOUBLE
13340: EQUAL
13341: IFTRUE 13345
13343: GO 13371
13345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13346: LD_ADDR_VAR 0 3
13350: PUSH
13351: LD_INT 2
13353: PUSH
13354: LD_INT 3
13356: PUSH
13357: LD_INT 4
13359: PUSH
13360: LD_INT 5
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: ST_TO_ADDR
13369: GO 14194
13371: LD_INT 9
13373: DOUBLE
13374: EQUAL
13375: IFTRUE 13379
13377: GO 13405
13379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13380: LD_ADDR_VAR 0 3
13384: PUSH
13385: LD_INT 2
13387: PUSH
13388: LD_INT 3
13390: PUSH
13391: LD_INT 4
13393: PUSH
13394: LD_INT 5
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: ST_TO_ADDR
13403: GO 14194
13405: LD_INT 7
13407: DOUBLE
13408: EQUAL
13409: IFTRUE 13413
13411: GO 13439
13413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13414: LD_ADDR_VAR 0 3
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: LD_INT 3
13424: PUSH
13425: LD_INT 4
13427: PUSH
13428: LD_INT 5
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: ST_TO_ADDR
13437: GO 14194
13439: LD_INT 12
13441: DOUBLE
13442: EQUAL
13443: IFTRUE 13447
13445: GO 13473
13447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_INT 2
13455: PUSH
13456: LD_INT 3
13458: PUSH
13459: LD_INT 4
13461: PUSH
13462: LD_INT 5
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: ST_TO_ADDR
13471: GO 14194
13473: LD_INT 13
13475: DOUBLE
13476: EQUAL
13477: IFTRUE 13481
13479: GO 13507
13481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: LD_INT 3
13492: PUSH
13493: LD_INT 4
13495: PUSH
13496: LD_INT 5
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: LIST
13504: ST_TO_ADDR
13505: GO 14194
13507: LD_INT 14
13509: DOUBLE
13510: EQUAL
13511: IFTRUE 13515
13513: GO 13533
13515: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13516: LD_ADDR_VAR 0 3
13520: PUSH
13521: LD_INT 4
13523: PUSH
13524: LD_INT 5
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: ST_TO_ADDR
13531: GO 14194
13533: LD_INT 6
13535: DOUBLE
13536: EQUAL
13537: IFTRUE 13541
13539: GO 13559
13541: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13542: LD_ADDR_VAR 0 3
13546: PUSH
13547: LD_INT 4
13549: PUSH
13550: LD_INT 5
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: ST_TO_ADDR
13557: GO 14194
13559: LD_INT 10
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13585
13567: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13568: LD_ADDR_VAR 0 3
13572: PUSH
13573: LD_INT 4
13575: PUSH
13576: LD_INT 5
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: ST_TO_ADDR
13583: GO 14194
13585: LD_INT 22
13587: DOUBLE
13588: EQUAL
13589: IFTRUE 13593
13591: GO 13619
13593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13594: LD_ADDR_VAR 0 3
13598: PUSH
13599: LD_INT 11
13601: PUSH
13602: LD_INT 12
13604: PUSH
13605: LD_INT 13
13607: PUSH
13608: LD_INT 14
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: ST_TO_ADDR
13617: GO 14194
13619: LD_INT 23
13621: DOUBLE
13622: EQUAL
13623: IFTRUE 13627
13625: GO 13653
13627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13628: LD_ADDR_VAR 0 3
13632: PUSH
13633: LD_INT 11
13635: PUSH
13636: LD_INT 12
13638: PUSH
13639: LD_INT 13
13641: PUSH
13642: LD_INT 14
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: ST_TO_ADDR
13651: GO 14194
13653: LD_INT 24
13655: DOUBLE
13656: EQUAL
13657: IFTRUE 13661
13659: GO 13687
13661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13662: LD_ADDR_VAR 0 3
13666: PUSH
13667: LD_INT 11
13669: PUSH
13670: LD_INT 12
13672: PUSH
13673: LD_INT 13
13675: PUSH
13676: LD_INT 14
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: ST_TO_ADDR
13685: GO 14194
13687: LD_INT 30
13689: DOUBLE
13690: EQUAL
13691: IFTRUE 13695
13693: GO 13721
13695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13696: LD_ADDR_VAR 0 3
13700: PUSH
13701: LD_INT 11
13703: PUSH
13704: LD_INT 12
13706: PUSH
13707: LD_INT 13
13709: PUSH
13710: LD_INT 14
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: ST_TO_ADDR
13719: GO 14194
13721: LD_INT 25
13723: DOUBLE
13724: EQUAL
13725: IFTRUE 13729
13727: GO 13747
13729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13730: LD_ADDR_VAR 0 3
13734: PUSH
13735: LD_INT 13
13737: PUSH
13738: LD_INT 14
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: ST_TO_ADDR
13745: GO 14194
13747: LD_INT 27
13749: DOUBLE
13750: EQUAL
13751: IFTRUE 13755
13753: GO 13773
13755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13756: LD_ADDR_VAR 0 3
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 14
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14194
13773: LD_INT 28
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13799
13781: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13782: LD_ADDR_VAR 0 3
13786: PUSH
13787: LD_INT 13
13789: PUSH
13790: LD_INT 14
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: ST_TO_ADDR
13797: GO 14194
13799: LD_INT 29
13801: DOUBLE
13802: EQUAL
13803: IFTRUE 13807
13805: GO 13825
13807: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_INT 13
13815: PUSH
13816: LD_INT 14
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: ST_TO_ADDR
13823: GO 14194
13825: LD_INT 31
13827: DOUBLE
13828: EQUAL
13829: IFTRUE 13833
13831: GO 13851
13833: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: ST_TO_ADDR
13849: GO 14194
13851: LD_INT 26
13853: DOUBLE
13854: EQUAL
13855: IFTRUE 13859
13857: GO 13877
13859: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_INT 13
13867: PUSH
13868: LD_INT 14
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: ST_TO_ADDR
13875: GO 14194
13877: LD_INT 42
13879: DOUBLE
13880: EQUAL
13881: IFTRUE 13885
13883: GO 13911
13885: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13886: LD_ADDR_VAR 0 3
13890: PUSH
13891: LD_INT 21
13893: PUSH
13894: LD_INT 22
13896: PUSH
13897: LD_INT 23
13899: PUSH
13900: LD_INT 24
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: ST_TO_ADDR
13909: GO 14194
13911: LD_INT 43
13913: DOUBLE
13914: EQUAL
13915: IFTRUE 13919
13917: GO 13945
13919: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: LD_INT 21
13927: PUSH
13928: LD_INT 22
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 24
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14194
13945: LD_INT 44
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 13979
13953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13954: LD_ADDR_VAR 0 3
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 22
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: ST_TO_ADDR
13977: GO 14194
13979: LD_INT 45
13981: DOUBLE
13982: EQUAL
13983: IFTRUE 13987
13985: GO 14013
13987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13988: LD_ADDR_VAR 0 3
13992: PUSH
13993: LD_INT 21
13995: PUSH
13996: LD_INT 22
13998: PUSH
13999: LD_INT 23
14001: PUSH
14002: LD_INT 24
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: ST_TO_ADDR
14011: GO 14194
14013: LD_INT 49
14015: DOUBLE
14016: EQUAL
14017: IFTRUE 14021
14019: GO 14047
14021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14022: LD_ADDR_VAR 0 3
14026: PUSH
14027: LD_INT 21
14029: PUSH
14030: LD_INT 22
14032: PUSH
14033: LD_INT 23
14035: PUSH
14036: LD_INT 24
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: ST_TO_ADDR
14045: GO 14194
14047: LD_INT 51
14049: DOUBLE
14050: EQUAL
14051: IFTRUE 14055
14053: GO 14081
14055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14056: LD_ADDR_VAR 0 3
14060: PUSH
14061: LD_INT 21
14063: PUSH
14064: LD_INT 22
14066: PUSH
14067: LD_INT 23
14069: PUSH
14070: LD_INT 24
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: ST_TO_ADDR
14079: GO 14194
14081: LD_INT 52
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14115
14089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14090: LD_ADDR_VAR 0 3
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_INT 23
14103: PUSH
14104: LD_INT 24
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: ST_TO_ADDR
14113: GO 14194
14115: LD_INT 53
14117: DOUBLE
14118: EQUAL
14119: IFTRUE 14123
14121: GO 14141
14123: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14124: LD_ADDR_VAR 0 3
14128: PUSH
14129: LD_INT 23
14131: PUSH
14132: LD_INT 24
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: ST_TO_ADDR
14139: GO 14194
14141: LD_INT 46
14143: DOUBLE
14144: EQUAL
14145: IFTRUE 14149
14147: GO 14167
14149: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_INT 23
14157: PUSH
14158: LD_INT 24
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
14165: GO 14194
14167: LD_INT 47
14169: DOUBLE
14170: EQUAL
14171: IFTRUE 14175
14173: GO 14193
14175: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14176: LD_ADDR_VAR 0 3
14180: PUSH
14181: LD_INT 23
14183: PUSH
14184: LD_INT 24
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: ST_TO_ADDR
14191: GO 14194
14193: POP
// result := ( chassis in result ) ;
14194: LD_ADDR_VAR 0 3
14198: PUSH
14199: LD_VAR 0 1
14203: PUSH
14204: LD_VAR 0 3
14208: IN
14209: ST_TO_ADDR
// end ;
14210: LD_VAR 0 3
14214: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14215: LD_INT 0
14217: PPUSH
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
14223: PPUSH
// result := array ;
14224: LD_ADDR_VAR 0 5
14228: PUSH
14229: LD_VAR 0 1
14233: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14234: LD_VAR 0 1
14238: NOT
14239: PUSH
14240: LD_VAR 0 2
14244: NOT
14245: OR
14246: PUSH
14247: LD_VAR 0 3
14251: NOT
14252: OR
14253: PUSH
14254: LD_VAR 0 2
14258: PUSH
14259: LD_VAR 0 1
14263: GREATER
14264: OR
14265: PUSH
14266: LD_VAR 0 3
14270: PUSH
14271: LD_VAR 0 1
14275: GREATER
14276: OR
14277: IFFALSE 14281
// exit ;
14279: GO 14577
// if direction then
14281: LD_VAR 0 4
14285: IFFALSE 14349
// begin d := 1 ;
14287: LD_ADDR_VAR 0 9
14291: PUSH
14292: LD_INT 1
14294: ST_TO_ADDR
// if i_from > i_to then
14295: LD_VAR 0 2
14299: PUSH
14300: LD_VAR 0 3
14304: GREATER
14305: IFFALSE 14331
// length := ( array - i_from ) + i_to else
14307: LD_ADDR_VAR 0 11
14311: PUSH
14312: LD_VAR 0 1
14316: PUSH
14317: LD_VAR 0 2
14321: MINUS
14322: PUSH
14323: LD_VAR 0 3
14327: PLUS
14328: ST_TO_ADDR
14329: GO 14347
// length := i_to - i_from ;
14331: LD_ADDR_VAR 0 11
14335: PUSH
14336: LD_VAR 0 3
14340: PUSH
14341: LD_VAR 0 2
14345: MINUS
14346: ST_TO_ADDR
// end else
14347: GO 14410
// begin d := - 1 ;
14349: LD_ADDR_VAR 0 9
14353: PUSH
14354: LD_INT 1
14356: NEG
14357: ST_TO_ADDR
// if i_from > i_to then
14358: LD_VAR 0 2
14362: PUSH
14363: LD_VAR 0 3
14367: GREATER
14368: IFFALSE 14388
// length := i_from - i_to else
14370: LD_ADDR_VAR 0 11
14374: PUSH
14375: LD_VAR 0 2
14379: PUSH
14380: LD_VAR 0 3
14384: MINUS
14385: ST_TO_ADDR
14386: GO 14410
// length := ( array - i_to ) + i_from ;
14388: LD_ADDR_VAR 0 11
14392: PUSH
14393: LD_VAR 0 1
14397: PUSH
14398: LD_VAR 0 3
14402: MINUS
14403: PUSH
14404: LD_VAR 0 2
14408: PLUS
14409: ST_TO_ADDR
// end ; if not length then
14410: LD_VAR 0 11
14414: NOT
14415: IFFALSE 14419
// exit ;
14417: GO 14577
// tmp := array ;
14419: LD_ADDR_VAR 0 10
14423: PUSH
14424: LD_VAR 0 1
14428: ST_TO_ADDR
// for i = 1 to length do
14429: LD_ADDR_VAR 0 6
14433: PUSH
14434: DOUBLE
14435: LD_INT 1
14437: DEC
14438: ST_TO_ADDR
14439: LD_VAR 0 11
14443: PUSH
14444: FOR_TO
14445: IFFALSE 14565
// begin for j = 1 to array do
14447: LD_ADDR_VAR 0 7
14451: PUSH
14452: DOUBLE
14453: LD_INT 1
14455: DEC
14456: ST_TO_ADDR
14457: LD_VAR 0 1
14461: PUSH
14462: FOR_TO
14463: IFFALSE 14551
// begin k := j + d ;
14465: LD_ADDR_VAR 0 8
14469: PUSH
14470: LD_VAR 0 7
14474: PUSH
14475: LD_VAR 0 9
14479: PLUS
14480: ST_TO_ADDR
// if k > array then
14481: LD_VAR 0 8
14485: PUSH
14486: LD_VAR 0 1
14490: GREATER
14491: IFFALSE 14501
// k := 1 ;
14493: LD_ADDR_VAR 0 8
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// if not k then
14501: LD_VAR 0 8
14505: NOT
14506: IFFALSE 14518
// k := array ;
14508: LD_ADDR_VAR 0 8
14512: PUSH
14513: LD_VAR 0 1
14517: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14518: LD_ADDR_VAR 0 10
14522: PUSH
14523: LD_VAR 0 10
14527: PPUSH
14528: LD_VAR 0 8
14532: PPUSH
14533: LD_VAR 0 1
14537: PUSH
14538: LD_VAR 0 7
14542: ARRAY
14543: PPUSH
14544: CALL_OW 1
14548: ST_TO_ADDR
// end ;
14549: GO 14462
14551: POP
14552: POP
// array := tmp ;
14553: LD_ADDR_VAR 0 1
14557: PUSH
14558: LD_VAR 0 10
14562: ST_TO_ADDR
// end ;
14563: GO 14444
14565: POP
14566: POP
// result := array ;
14567: LD_ADDR_VAR 0 5
14571: PUSH
14572: LD_VAR 0 1
14576: ST_TO_ADDR
// end ;
14577: LD_VAR 0 5
14581: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14582: LD_INT 0
14584: PPUSH
14585: PPUSH
// result := 0 ;
14586: LD_ADDR_VAR 0 3
14590: PUSH
14591: LD_INT 0
14593: ST_TO_ADDR
// if not array or not value in array then
14594: LD_VAR 0 1
14598: NOT
14599: PUSH
14600: LD_VAR 0 2
14604: PUSH
14605: LD_VAR 0 1
14609: IN
14610: NOT
14611: OR
14612: IFFALSE 14616
// exit ;
14614: GO 14670
// for i = 1 to array do
14616: LD_ADDR_VAR 0 4
14620: PUSH
14621: DOUBLE
14622: LD_INT 1
14624: DEC
14625: ST_TO_ADDR
14626: LD_VAR 0 1
14630: PUSH
14631: FOR_TO
14632: IFFALSE 14668
// if value = array [ i ] then
14634: LD_VAR 0 2
14638: PUSH
14639: LD_VAR 0 1
14643: PUSH
14644: LD_VAR 0 4
14648: ARRAY
14649: EQUAL
14650: IFFALSE 14666
// begin result := i ;
14652: LD_ADDR_VAR 0 3
14656: PUSH
14657: LD_VAR 0 4
14661: ST_TO_ADDR
// exit ;
14662: POP
14663: POP
14664: GO 14670
// end ;
14666: GO 14631
14668: POP
14669: POP
// end ;
14670: LD_VAR 0 3
14674: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14675: LD_INT 0
14677: PPUSH
// vc_chassis := chassis ;
14678: LD_ADDR_OWVAR 37
14682: PUSH
14683: LD_VAR 0 1
14687: ST_TO_ADDR
// vc_engine := engine ;
14688: LD_ADDR_OWVAR 39
14692: PUSH
14693: LD_VAR 0 2
14697: ST_TO_ADDR
// vc_control := control ;
14698: LD_ADDR_OWVAR 38
14702: PUSH
14703: LD_VAR 0 3
14707: ST_TO_ADDR
// vc_weapon := weapon ;
14708: LD_ADDR_OWVAR 40
14712: PUSH
14713: LD_VAR 0 4
14717: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14718: LD_ADDR_OWVAR 41
14722: PUSH
14723: LD_VAR 0 5
14727: ST_TO_ADDR
// end ;
14728: LD_VAR 0 6
14732: RET
// export function WantPlant ( unit ) ; var task ; begin
14733: LD_INT 0
14735: PPUSH
14736: PPUSH
// result := false ;
14737: LD_ADDR_VAR 0 2
14741: PUSH
14742: LD_INT 0
14744: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14745: LD_ADDR_VAR 0 3
14749: PUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 437
14759: ST_TO_ADDR
// if task then
14760: LD_VAR 0 3
14764: IFFALSE 14792
// if task [ 1 ] [ 1 ] = p then
14766: LD_VAR 0 3
14770: PUSH
14771: LD_INT 1
14773: ARRAY
14774: PUSH
14775: LD_INT 1
14777: ARRAY
14778: PUSH
14779: LD_STRING p
14781: EQUAL
14782: IFFALSE 14792
// result := true ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
// end ;
14792: LD_VAR 0 2
14796: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
// if pos < 1 then
14803: LD_VAR 0 2
14807: PUSH
14808: LD_INT 1
14810: LESS
14811: IFFALSE 14815
// exit ;
14813: GO 15118
// if pos = 1 then
14815: LD_VAR 0 2
14819: PUSH
14820: LD_INT 1
14822: EQUAL
14823: IFFALSE 14856
// result := Replace ( arr , pos [ 1 ] , value ) else
14825: LD_ADDR_VAR 0 4
14829: PUSH
14830: LD_VAR 0 1
14834: PPUSH
14835: LD_VAR 0 2
14839: PUSH
14840: LD_INT 1
14842: ARRAY
14843: PPUSH
14844: LD_VAR 0 3
14848: PPUSH
14849: CALL_OW 1
14853: ST_TO_ADDR
14854: GO 15118
// begin tmp := arr ;
14856: LD_ADDR_VAR 0 6
14860: PUSH
14861: LD_VAR 0 1
14865: ST_TO_ADDR
// s_arr := [ tmp ] ;
14866: LD_ADDR_VAR 0 7
14870: PUSH
14871: LD_VAR 0 6
14875: PUSH
14876: EMPTY
14877: LIST
14878: ST_TO_ADDR
// for i = 1 to pos - 1 do
14879: LD_ADDR_VAR 0 5
14883: PUSH
14884: DOUBLE
14885: LD_INT 1
14887: DEC
14888: ST_TO_ADDR
14889: LD_VAR 0 2
14893: PUSH
14894: LD_INT 1
14896: MINUS
14897: PUSH
14898: FOR_TO
14899: IFFALSE 14944
// begin tmp := tmp [ pos [ i ] ] ;
14901: LD_ADDR_VAR 0 6
14905: PUSH
14906: LD_VAR 0 6
14910: PUSH
14911: LD_VAR 0 2
14915: PUSH
14916: LD_VAR 0 5
14920: ARRAY
14921: ARRAY
14922: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14923: LD_ADDR_VAR 0 7
14927: PUSH
14928: LD_VAR 0 7
14932: PUSH
14933: LD_VAR 0 6
14937: PUSH
14938: EMPTY
14939: LIST
14940: ADD
14941: ST_TO_ADDR
// end ;
14942: GO 14898
14944: POP
14945: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14946: LD_ADDR_VAR 0 6
14950: PUSH
14951: LD_VAR 0 6
14955: PPUSH
14956: LD_VAR 0 2
14960: PUSH
14961: LD_VAR 0 2
14965: ARRAY
14966: PPUSH
14967: LD_VAR 0 3
14971: PPUSH
14972: CALL_OW 1
14976: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14977: LD_ADDR_VAR 0 7
14981: PUSH
14982: LD_VAR 0 7
14986: PPUSH
14987: LD_VAR 0 7
14991: PPUSH
14992: LD_VAR 0 6
14996: PPUSH
14997: CALL_OW 1
15001: ST_TO_ADDR
// for i = s_arr downto 2 do
15002: LD_ADDR_VAR 0 5
15006: PUSH
15007: DOUBLE
15008: LD_VAR 0 7
15012: INC
15013: ST_TO_ADDR
15014: LD_INT 2
15016: PUSH
15017: FOR_DOWNTO
15018: IFFALSE 15102
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15020: LD_ADDR_VAR 0 6
15024: PUSH
15025: LD_VAR 0 7
15029: PUSH
15030: LD_VAR 0 5
15034: PUSH
15035: LD_INT 1
15037: MINUS
15038: ARRAY
15039: PPUSH
15040: LD_VAR 0 2
15044: PUSH
15045: LD_VAR 0 5
15049: PUSH
15050: LD_INT 1
15052: MINUS
15053: ARRAY
15054: PPUSH
15055: LD_VAR 0 7
15059: PUSH
15060: LD_VAR 0 5
15064: ARRAY
15065: PPUSH
15066: CALL_OW 1
15070: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15071: LD_ADDR_VAR 0 7
15075: PUSH
15076: LD_VAR 0 7
15080: PPUSH
15081: LD_VAR 0 5
15085: PUSH
15086: LD_INT 1
15088: MINUS
15089: PPUSH
15090: LD_VAR 0 6
15094: PPUSH
15095: CALL_OW 1
15099: ST_TO_ADDR
// end ;
15100: GO 15017
15102: POP
15103: POP
// result := s_arr [ 1 ] ;
15104: LD_ADDR_VAR 0 4
15108: PUSH
15109: LD_VAR 0 7
15113: PUSH
15114: LD_INT 1
15116: ARRAY
15117: ST_TO_ADDR
// end ; end ;
15118: LD_VAR 0 4
15122: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15123: LD_INT 0
15125: PPUSH
15126: PPUSH
// if not list then
15127: LD_VAR 0 1
15131: NOT
15132: IFFALSE 15136
// exit ;
15134: GO 15227
// i := list [ pos1 ] ;
15136: LD_ADDR_VAR 0 5
15140: PUSH
15141: LD_VAR 0 1
15145: PUSH
15146: LD_VAR 0 2
15150: ARRAY
15151: ST_TO_ADDR
// if not i then
15152: LD_VAR 0 5
15156: NOT
15157: IFFALSE 15161
// exit ;
15159: GO 15227
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15161: LD_ADDR_VAR 0 1
15165: PUSH
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 2
15175: PPUSH
15176: LD_VAR 0 1
15180: PUSH
15181: LD_VAR 0 3
15185: ARRAY
15186: PPUSH
15187: CALL_OW 1
15191: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15192: LD_ADDR_VAR 0 1
15196: PUSH
15197: LD_VAR 0 1
15201: PPUSH
15202: LD_VAR 0 3
15206: PPUSH
15207: LD_VAR 0 5
15211: PPUSH
15212: CALL_OW 1
15216: ST_TO_ADDR
// result := list ;
15217: LD_ADDR_VAR 0 4
15221: PUSH
15222: LD_VAR 0 1
15226: ST_TO_ADDR
// end ;
15227: LD_VAR 0 4
15231: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15232: LD_INT 0
15234: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15235: LD_ADDR_VAR 0 5
15239: PUSH
15240: LD_VAR 0 1
15244: PPUSH
15245: CALL_OW 250
15249: PPUSH
15250: LD_VAR 0 1
15254: PPUSH
15255: CALL_OW 251
15259: PPUSH
15260: LD_VAR 0 2
15264: PPUSH
15265: LD_VAR 0 3
15269: PPUSH
15270: LD_VAR 0 4
15274: PPUSH
15275: CALL 15285 0 5
15279: ST_TO_ADDR
// end ;
15280: LD_VAR 0 5
15284: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15285: LD_INT 0
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
// if not list then
15291: LD_VAR 0 3
15295: NOT
15296: IFFALSE 15300
// exit ;
15298: GO 15688
// result := [ ] ;
15300: LD_ADDR_VAR 0 6
15304: PUSH
15305: EMPTY
15306: ST_TO_ADDR
// for i in list do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_VAR 0 3
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15520
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15320: LD_ADDR_VAR 0 9
15324: PUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 2
15339: PPUSH
15340: CALL_OW 297
15344: ST_TO_ADDR
// if not result then
15345: LD_VAR 0 6
15349: NOT
15350: IFFALSE 15376
// result := [ [ i , tmp ] ] else
15352: LD_ADDR_VAR 0 6
15356: PUSH
15357: LD_VAR 0 7
15361: PUSH
15362: LD_VAR 0 9
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: ST_TO_ADDR
15374: GO 15518
// begin if result [ result ] [ 2 ] < tmp then
15376: LD_VAR 0 6
15380: PUSH
15381: LD_VAR 0 6
15385: ARRAY
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PUSH
15391: LD_VAR 0 9
15395: LESS
15396: IFFALSE 15438
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15398: LD_ADDR_VAR 0 6
15402: PUSH
15403: LD_VAR 0 6
15407: PPUSH
15408: LD_VAR 0 6
15412: PUSH
15413: LD_INT 1
15415: PLUS
15416: PPUSH
15417: LD_VAR 0 7
15421: PUSH
15422: LD_VAR 0 9
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PPUSH
15431: CALL_OW 2
15435: ST_TO_ADDR
15436: GO 15518
// for j = 1 to result do
15438: LD_ADDR_VAR 0 8
15442: PUSH
15443: DOUBLE
15444: LD_INT 1
15446: DEC
15447: ST_TO_ADDR
15448: LD_VAR 0 6
15452: PUSH
15453: FOR_TO
15454: IFFALSE 15516
// begin if tmp < result [ j ] [ 2 ] then
15456: LD_VAR 0 9
15460: PUSH
15461: LD_VAR 0 6
15465: PUSH
15466: LD_VAR 0 8
15470: ARRAY
15471: PUSH
15472: LD_INT 2
15474: ARRAY
15475: LESS
15476: IFFALSE 15514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15478: LD_ADDR_VAR 0 6
15482: PUSH
15483: LD_VAR 0 6
15487: PPUSH
15488: LD_VAR 0 8
15492: PPUSH
15493: LD_VAR 0 7
15497: PUSH
15498: LD_VAR 0 9
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: PPUSH
15507: CALL_OW 2
15511: ST_TO_ADDR
// break ;
15512: GO 15516
// end ; end ;
15514: GO 15453
15516: POP
15517: POP
// end ; end ;
15518: GO 15317
15520: POP
15521: POP
// if result and not asc then
15522: LD_VAR 0 6
15526: PUSH
15527: LD_VAR 0 4
15531: NOT
15532: AND
15533: IFFALSE 15608
// begin tmp := result ;
15535: LD_ADDR_VAR 0 9
15539: PUSH
15540: LD_VAR 0 6
15544: ST_TO_ADDR
// for i = tmp downto 1 do
15545: LD_ADDR_VAR 0 7
15549: PUSH
15550: DOUBLE
15551: LD_VAR 0 9
15555: INC
15556: ST_TO_ADDR
15557: LD_INT 1
15559: PUSH
15560: FOR_DOWNTO
15561: IFFALSE 15606
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15563: LD_ADDR_VAR 0 6
15567: PUSH
15568: LD_VAR 0 6
15572: PPUSH
15573: LD_VAR 0 9
15577: PUSH
15578: LD_VAR 0 7
15582: MINUS
15583: PUSH
15584: LD_INT 1
15586: PLUS
15587: PPUSH
15588: LD_VAR 0 9
15592: PUSH
15593: LD_VAR 0 7
15597: ARRAY
15598: PPUSH
15599: CALL_OW 1
15603: ST_TO_ADDR
15604: GO 15560
15606: POP
15607: POP
// end ; tmp := [ ] ;
15608: LD_ADDR_VAR 0 9
15612: PUSH
15613: EMPTY
15614: ST_TO_ADDR
// if mode then
15615: LD_VAR 0 5
15619: IFFALSE 15688
// begin for i = 1 to result do
15621: LD_ADDR_VAR 0 7
15625: PUSH
15626: DOUBLE
15627: LD_INT 1
15629: DEC
15630: ST_TO_ADDR
15631: LD_VAR 0 6
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15676
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15639: LD_ADDR_VAR 0 9
15643: PUSH
15644: LD_VAR 0 9
15648: PPUSH
15649: LD_VAR 0 7
15653: PPUSH
15654: LD_VAR 0 6
15658: PUSH
15659: LD_VAR 0 7
15663: ARRAY
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: PPUSH
15669: CALL_OW 1
15673: ST_TO_ADDR
15674: GO 15636
15676: POP
15677: POP
// result := tmp ;
15678: LD_ADDR_VAR 0 6
15682: PUSH
15683: LD_VAR 0 9
15687: ST_TO_ADDR
// end ; end ;
15688: LD_VAR 0 6
15692: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15693: LD_INT 0
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15701: LD_ADDR_VAR 0 5
15705: PUSH
15706: LD_INT 0
15708: PUSH
15709: LD_INT 0
15711: PUSH
15712: LD_INT 0
15714: PUSH
15715: EMPTY
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: LIST
15722: ST_TO_ADDR
// if not x or not y then
15723: LD_VAR 0 2
15727: NOT
15728: PUSH
15729: LD_VAR 0 3
15733: NOT
15734: OR
15735: IFFALSE 15739
// exit ;
15737: GO 17385
// if not range then
15739: LD_VAR 0 4
15743: NOT
15744: IFFALSE 15754
// range := 10 ;
15746: LD_ADDR_VAR 0 4
15750: PUSH
15751: LD_INT 10
15753: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15754: LD_ADDR_VAR 0 8
15758: PUSH
15759: LD_INT 81
15761: PUSH
15762: LD_VAR 0 1
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: LD_INT 92
15773: PUSH
15774: LD_VAR 0 2
15778: PUSH
15779: LD_VAR 0 3
15783: PUSH
15784: LD_VAR 0 4
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: LD_INT 21
15800: PUSH
15801: LD_INT 3
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PPUSH
15817: CALL_OW 69
15821: ST_TO_ADDR
// if not tmp then
15822: LD_VAR 0 8
15826: NOT
15827: IFFALSE 15831
// exit ;
15829: GO 17385
// for i in tmp do
15831: LD_ADDR_VAR 0 6
15835: PUSH
15836: LD_VAR 0 8
15840: PUSH
15841: FOR_IN
15842: IFFALSE 17360
// begin points := [ 0 , 0 , 0 ] ;
15844: LD_ADDR_VAR 0 9
15848: PUSH
15849: LD_INT 0
15851: PUSH
15852: LD_INT 0
15854: PUSH
15855: LD_INT 0
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: LIST
15862: ST_TO_ADDR
// bpoints := 1 ;
15863: LD_ADDR_VAR 0 10
15867: PUSH
15868: LD_INT 1
15870: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15871: LD_VAR 0 6
15875: PPUSH
15876: CALL_OW 247
15880: PUSH
15881: LD_INT 1
15883: DOUBLE
15884: EQUAL
15885: IFTRUE 15889
15887: GO 16467
15889: POP
// begin if GetClass ( i ) = 1 then
15890: LD_VAR 0 6
15894: PPUSH
15895: CALL_OW 257
15899: PUSH
15900: LD_INT 1
15902: EQUAL
15903: IFFALSE 15924
// points := [ 10 , 5 , 3 ] ;
15905: LD_ADDR_VAR 0 9
15909: PUSH
15910: LD_INT 10
15912: PUSH
15913: LD_INT 5
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15924: LD_VAR 0 6
15928: PPUSH
15929: CALL_OW 257
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 3 , 2 , 1 ] ;
15950: LD_ADDR_VAR 0 9
15954: PUSH
15955: LD_INT 3
15957: PUSH
15958: LD_INT 2
15960: PUSH
15961: LD_INT 1
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15969: LD_VAR 0 6
15973: PPUSH
15974: CALL_OW 257
15978: PUSH
15979: LD_INT 5
15981: EQUAL
15982: IFFALSE 16003
// points := [ 130 , 5 , 2 ] ;
15984: LD_ADDR_VAR 0 9
15988: PUSH
15989: LD_INT 130
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 2
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16003: LD_VAR 0 6
16007: PPUSH
16008: CALL_OW 257
16012: PUSH
16013: LD_INT 8
16015: EQUAL
16016: IFFALSE 16037
// points := [ 35 , 35 , 30 ] ;
16018: LD_ADDR_VAR 0 9
16022: PUSH
16023: LD_INT 35
16025: PUSH
16026: LD_INT 35
16028: PUSH
16029: LD_INT 30
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL_OW 257
16046: PUSH
16047: LD_INT 9
16049: EQUAL
16050: IFFALSE 16071
// points := [ 20 , 55 , 40 ] ;
16052: LD_ADDR_VAR 0 9
16056: PUSH
16057: LD_INT 20
16059: PUSH
16060: LD_INT 55
16062: PUSH
16063: LD_INT 40
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: LIST
16070: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16071: LD_VAR 0 6
16075: PPUSH
16076: CALL_OW 257
16080: PUSH
16081: LD_INT 12
16083: PUSH
16084: LD_INT 16
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: IN
16091: IFFALSE 16112
// points := [ 5 , 3 , 2 ] ;
16093: LD_ADDR_VAR 0 9
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 3
16103: PUSH
16104: LD_INT 2
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL_OW 257
16121: PUSH
16122: LD_INT 17
16124: EQUAL
16125: IFFALSE 16146
// points := [ 100 , 50 , 75 ] ;
16127: LD_ADDR_VAR 0 9
16131: PUSH
16132: LD_INT 100
16134: PUSH
16135: LD_INT 50
16137: PUSH
16138: LD_INT 75
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: LIST
16145: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16146: LD_VAR 0 6
16150: PPUSH
16151: CALL_OW 257
16155: PUSH
16156: LD_INT 15
16158: EQUAL
16159: IFFALSE 16180
// points := [ 10 , 5 , 3 ] ;
16161: LD_ADDR_VAR 0 9
16165: PUSH
16166: LD_INT 10
16168: PUSH
16169: LD_INT 5
16171: PUSH
16172: LD_INT 3
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 257
16189: PUSH
16190: LD_INT 14
16192: EQUAL
16193: IFFALSE 16214
// points := [ 10 , 0 , 0 ] ;
16195: LD_ADDR_VAR 0 9
16199: PUSH
16200: LD_INT 10
16202: PUSH
16203: LD_INT 0
16205: PUSH
16206: LD_INT 0
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16214: LD_VAR 0 6
16218: PPUSH
16219: CALL_OW 257
16223: PUSH
16224: LD_INT 11
16226: EQUAL
16227: IFFALSE 16248
// points := [ 30 , 10 , 5 ] ;
16229: LD_ADDR_VAR 0 9
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 10
16239: PUSH
16240: LD_INT 5
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: LIST
16247: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16248: LD_VAR 0 1
16252: PPUSH
16253: LD_INT 5
16255: PPUSH
16256: CALL_OW 321
16260: PUSH
16261: LD_INT 2
16263: EQUAL
16264: IFFALSE 16281
// bpoints := bpoints * 1.8 ;
16266: LD_ADDR_VAR 0 10
16270: PUSH
16271: LD_VAR 0 10
16275: PUSH
16276: LD_REAL  1.80000000000000E+0000
16279: MUL
16280: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16281: LD_VAR 0 6
16285: PPUSH
16286: CALL_OW 257
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: LD_INT 3
16299: PUSH
16300: LD_INT 4
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: IN
16309: PUSH
16310: LD_VAR 0 1
16314: PPUSH
16315: LD_INT 51
16317: PPUSH
16318: CALL_OW 321
16322: PUSH
16323: LD_INT 2
16325: EQUAL
16326: AND
16327: IFFALSE 16344
// bpoints := bpoints * 1.2 ;
16329: LD_ADDR_VAR 0 10
16333: PUSH
16334: LD_VAR 0 10
16338: PUSH
16339: LD_REAL  1.20000000000000E+0000
16342: MUL
16343: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16344: LD_VAR 0 6
16348: PPUSH
16349: CALL_OW 257
16353: PUSH
16354: LD_INT 5
16356: PUSH
16357: LD_INT 7
16359: PUSH
16360: LD_INT 9
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: IN
16368: PUSH
16369: LD_VAR 0 1
16373: PPUSH
16374: LD_INT 52
16376: PPUSH
16377: CALL_OW 321
16381: PUSH
16382: LD_INT 2
16384: EQUAL
16385: AND
16386: IFFALSE 16403
// bpoints := bpoints * 1.5 ;
16388: LD_ADDR_VAR 0 10
16392: PUSH
16393: LD_VAR 0 10
16397: PUSH
16398: LD_REAL  1.50000000000000E+0000
16401: MUL
16402: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16403: LD_VAR 0 1
16407: PPUSH
16408: LD_INT 66
16410: PPUSH
16411: CALL_OW 321
16415: PUSH
16416: LD_INT 2
16418: EQUAL
16419: IFFALSE 16436
// bpoints := bpoints * 1.1 ;
16421: LD_ADDR_VAR 0 10
16425: PUSH
16426: LD_VAR 0 10
16430: PUSH
16431: LD_REAL  1.10000000000000E+0000
16434: MUL
16435: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16436: LD_ADDR_VAR 0 10
16440: PUSH
16441: LD_VAR 0 10
16445: PUSH
16446: LD_VAR 0 6
16450: PPUSH
16451: LD_INT 1
16453: PPUSH
16454: CALL_OW 259
16458: PUSH
16459: LD_REAL  1.15000000000000E+0000
16462: MUL
16463: MUL
16464: ST_TO_ADDR
// end ; unit_vehicle :
16465: GO 17289
16467: LD_INT 2
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 17277
16475: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16476: LD_VAR 0 6
16480: PPUSH
16481: CALL_OW 264
16485: PUSH
16486: LD_INT 2
16488: PUSH
16489: LD_INT 42
16491: PUSH
16492: LD_INT 24
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: IFFALSE 16521
// points := [ 25 , 5 , 3 ] ;
16502: LD_ADDR_VAR 0 9
16506: PUSH
16507: LD_INT 25
16509: PUSH
16510: LD_INT 5
16512: PUSH
16513: LD_INT 3
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: LIST
16520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16521: LD_VAR 0 6
16525: PPUSH
16526: CALL_OW 264
16530: PUSH
16531: LD_INT 4
16533: PUSH
16534: LD_INT 43
16536: PUSH
16537: LD_INT 25
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: LIST
16544: IN
16545: IFFALSE 16566
// points := [ 40 , 15 , 5 ] ;
16547: LD_ADDR_VAR 0 9
16551: PUSH
16552: LD_INT 40
16554: PUSH
16555: LD_INT 15
16557: PUSH
16558: LD_INT 5
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16566: LD_VAR 0 6
16570: PPUSH
16571: CALL_OW 264
16575: PUSH
16576: LD_INT 3
16578: PUSH
16579: LD_INT 23
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: IN
16586: IFFALSE 16607
// points := [ 7 , 25 , 8 ] ;
16588: LD_ADDR_VAR 0 9
16592: PUSH
16593: LD_INT 7
16595: PUSH
16596: LD_INT 25
16598: PUSH
16599: LD_INT 8
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16607: LD_VAR 0 6
16611: PPUSH
16612: CALL_OW 264
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: LD_INT 27
16622: PUSH
16623: LD_INT 44
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: LIST
16630: IN
16631: IFFALSE 16652
// points := [ 14 , 50 , 16 ] ;
16633: LD_ADDR_VAR 0 9
16637: PUSH
16638: LD_INT 14
16640: PUSH
16641: LD_INT 50
16643: PUSH
16644: LD_INT 16
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16652: LD_VAR 0 6
16656: PPUSH
16657: CALL_OW 264
16661: PUSH
16662: LD_INT 6
16664: PUSH
16665: LD_INT 46
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: IN
16672: IFFALSE 16693
// points := [ 32 , 120 , 70 ] ;
16674: LD_ADDR_VAR 0 9
16678: PUSH
16679: LD_INT 32
16681: PUSH
16682: LD_INT 120
16684: PUSH
16685: LD_INT 70
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16693: LD_VAR 0 6
16697: PPUSH
16698: CALL_OW 264
16702: PUSH
16703: LD_INT 7
16705: PUSH
16706: LD_INT 28
16708: PUSH
16709: LD_INT 45
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: LIST
16716: IN
16717: IFFALSE 16738
// points := [ 35 , 20 , 45 ] ;
16719: LD_ADDR_VAR 0 9
16723: PUSH
16724: LD_INT 35
16726: PUSH
16727: LD_INT 20
16729: PUSH
16730: LD_INT 45
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16738: LD_VAR 0 6
16742: PPUSH
16743: CALL_OW 264
16747: PUSH
16748: LD_INT 47
16750: PUSH
16751: EMPTY
16752: LIST
16753: IN
16754: IFFALSE 16775
// points := [ 67 , 45 , 75 ] ;
16756: LD_ADDR_VAR 0 9
16760: PUSH
16761: LD_INT 67
16763: PUSH
16764: LD_INT 45
16766: PUSH
16767: LD_INT 75
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: LIST
16774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16775: LD_VAR 0 6
16779: PPUSH
16780: CALL_OW 264
16784: PUSH
16785: LD_INT 26
16787: PUSH
16788: EMPTY
16789: LIST
16790: IN
16791: IFFALSE 16812
// points := [ 120 , 30 , 80 ] ;
16793: LD_ADDR_VAR 0 9
16797: PUSH
16798: LD_INT 120
16800: PUSH
16801: LD_INT 30
16803: PUSH
16804: LD_INT 80
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16812: LD_VAR 0 6
16816: PPUSH
16817: CALL_OW 264
16821: PUSH
16822: LD_INT 22
16824: PUSH
16825: EMPTY
16826: LIST
16827: IN
16828: IFFALSE 16849
// points := [ 40 , 1 , 1 ] ;
16830: LD_ADDR_VAR 0 9
16834: PUSH
16835: LD_INT 40
16837: PUSH
16838: LD_INT 1
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16849: LD_VAR 0 6
16853: PPUSH
16854: CALL_OW 264
16858: PUSH
16859: LD_INT 29
16861: PUSH
16862: EMPTY
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 70 , 200 , 400 ] ;
16867: LD_ADDR_VAR 0 9
16871: PUSH
16872: LD_INT 70
16874: PUSH
16875: LD_INT 200
16877: PUSH
16878: LD_INT 400
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16886: LD_VAR 0 6
16890: PPUSH
16891: CALL_OW 264
16895: PUSH
16896: LD_INT 14
16898: PUSH
16899: LD_INT 53
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: IN
16906: IFFALSE 16927
// points := [ 40 , 10 , 20 ] ;
16908: LD_ADDR_VAR 0 9
16912: PUSH
16913: LD_INT 40
16915: PUSH
16916: LD_INT 10
16918: PUSH
16919: LD_INT 20
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16927: LD_VAR 0 6
16931: PPUSH
16932: CALL_OW 264
16936: PUSH
16937: LD_INT 9
16939: PUSH
16940: EMPTY
16941: LIST
16942: IN
16943: IFFALSE 16964
// points := [ 5 , 70 , 20 ] ;
16945: LD_ADDR_VAR 0 9
16949: PUSH
16950: LD_INT 5
16952: PUSH
16953: LD_INT 70
16955: PUSH
16956: LD_INT 20
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16964: LD_VAR 0 6
16968: PPUSH
16969: CALL_OW 264
16973: PUSH
16974: LD_INT 10
16976: PUSH
16977: EMPTY
16978: LIST
16979: IN
16980: IFFALSE 17001
// points := [ 35 , 110 , 70 ] ;
16982: LD_ADDR_VAR 0 9
16986: PUSH
16987: LD_INT 35
16989: PUSH
16990: LD_INT 110
16992: PUSH
16993: LD_INT 70
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17001: LD_VAR 0 6
17005: PPUSH
17006: CALL_OW 265
17010: PUSH
17011: LD_INT 25
17013: EQUAL
17014: IFFALSE 17035
// points := [ 80 , 65 , 100 ] ;
17016: LD_ADDR_VAR 0 9
17020: PUSH
17021: LD_INT 80
17023: PUSH
17024: LD_INT 65
17026: PUSH
17027: LD_INT 100
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17035: LD_VAR 0 6
17039: PPUSH
17040: CALL_OW 263
17044: PUSH
17045: LD_INT 1
17047: EQUAL
17048: IFFALSE 17083
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17050: LD_ADDR_VAR 0 10
17054: PUSH
17055: LD_VAR 0 10
17059: PUSH
17060: LD_VAR 0 6
17064: PPUSH
17065: CALL_OW 311
17069: PPUSH
17070: LD_INT 3
17072: PPUSH
17073: CALL_OW 259
17077: PUSH
17078: LD_INT 4
17080: MUL
17081: MUL
17082: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 263
17092: PUSH
17093: LD_INT 2
17095: EQUAL
17096: IFFALSE 17147
// begin j := IsControledBy ( i ) ;
17098: LD_ADDR_VAR 0 7
17102: PUSH
17103: LD_VAR 0 6
17107: PPUSH
17108: CALL_OW 312
17112: ST_TO_ADDR
// if j then
17113: LD_VAR 0 7
17117: IFFALSE 17147
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17119: LD_ADDR_VAR 0 10
17123: PUSH
17124: LD_VAR 0 10
17128: PUSH
17129: LD_VAR 0 7
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: CALL_OW 259
17141: PUSH
17142: LD_INT 3
17144: MUL
17145: MUL
17146: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17147: LD_VAR 0 6
17151: PPUSH
17152: CALL_OW 264
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: LD_INT 46
17165: PUSH
17166: LD_INT 44
17168: PUSH
17169: LD_INT 47
17171: PUSH
17172: LD_INT 45
17174: PUSH
17175: LD_INT 28
17177: PUSH
17178: LD_INT 7
17180: PUSH
17181: LD_INT 27
17183: PUSH
17184: LD_INT 29
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: IN
17199: PUSH
17200: LD_VAR 0 1
17204: PPUSH
17205: LD_INT 52
17207: PPUSH
17208: CALL_OW 321
17212: PUSH
17213: LD_INT 2
17215: EQUAL
17216: AND
17217: IFFALSE 17234
// bpoints := bpoints * 1.2 ;
17219: LD_ADDR_VAR 0 10
17223: PUSH
17224: LD_VAR 0 10
17228: PUSH
17229: LD_REAL  1.20000000000000E+0000
17232: MUL
17233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17234: LD_VAR 0 6
17238: PPUSH
17239: CALL_OW 264
17243: PUSH
17244: LD_INT 6
17246: PUSH
17247: LD_INT 46
17249: PUSH
17250: LD_INT 47
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: IN
17258: IFFALSE 17275
// bpoints := bpoints * 1.2 ;
17260: LD_ADDR_VAR 0 10
17264: PUSH
17265: LD_VAR 0 10
17269: PUSH
17270: LD_REAL  1.20000000000000E+0000
17273: MUL
17274: ST_TO_ADDR
// end ; unit_building :
17275: GO 17289
17277: LD_INT 3
17279: DOUBLE
17280: EQUAL
17281: IFTRUE 17285
17283: GO 17288
17285: POP
// ; end ;
17286: GO 17289
17288: POP
// for j = 1 to 3 do
17289: LD_ADDR_VAR 0 7
17293: PUSH
17294: DOUBLE
17295: LD_INT 1
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 3
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17356
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17305: LD_ADDR_VAR 0 5
17309: PUSH
17310: LD_VAR 0 5
17314: PPUSH
17315: LD_VAR 0 7
17319: PPUSH
17320: LD_VAR 0 5
17324: PUSH
17325: LD_VAR 0 7
17329: ARRAY
17330: PUSH
17331: LD_VAR 0 9
17335: PUSH
17336: LD_VAR 0 7
17340: ARRAY
17341: PUSH
17342: LD_VAR 0 10
17346: MUL
17347: PLUS
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
17354: GO 17302
17356: POP
17357: POP
// end ;
17358: GO 15841
17360: POP
17361: POP
// result := Replace ( result , 4 , tmp ) ;
17362: LD_ADDR_VAR 0 5
17366: PUSH
17367: LD_VAR 0 5
17371: PPUSH
17372: LD_INT 4
17374: PPUSH
17375: LD_VAR 0 8
17379: PPUSH
17380: CALL_OW 1
17384: ST_TO_ADDR
// end ;
17385: LD_VAR 0 5
17389: RET
// export function DangerAtRange ( unit , range ) ; begin
17390: LD_INT 0
17392: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17393: LD_ADDR_VAR 0 3
17397: PUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL_OW 255
17407: PPUSH
17408: LD_VAR 0 1
17412: PPUSH
17413: CALL_OW 250
17417: PPUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: CALL_OW 251
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL 15693 0 4
17437: ST_TO_ADDR
// end ;
17438: LD_VAR 0 3
17442: RET
// export function DangerInArea ( side , area ) ; begin
17443: LD_INT 0
17445: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17446: LD_ADDR_VAR 0 3
17450: PUSH
17451: LD_VAR 0 2
17455: PPUSH
17456: LD_INT 81
17458: PUSH
17459: LD_VAR 0 1
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PPUSH
17468: CALL_OW 70
17472: ST_TO_ADDR
// end ;
17473: LD_VAR 0 3
17477: RET
// export function IsExtension ( b ) ; begin
17478: LD_INT 0
17480: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17481: LD_ADDR_VAR 0 2
17485: PUSH
17486: LD_VAR 0 1
17490: PUSH
17491: LD_INT 23
17493: PUSH
17494: LD_INT 20
17496: PUSH
17497: LD_INT 22
17499: PUSH
17500: LD_INT 17
17502: PUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 21
17508: PUSH
17509: LD_INT 19
17511: PUSH
17512: LD_INT 16
17514: PUSH
17515: LD_INT 25
17517: PUSH
17518: LD_INT 18
17520: PUSH
17521: EMPTY
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: IN
17533: ST_TO_ADDR
// end ;
17534: LD_VAR 0 2
17538: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
17543: PPUSH
// result := [ ] ;
17544: LD_ADDR_VAR 0 3
17548: PUSH
17549: EMPTY
17550: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17551: LD_ADDR_VAR 0 4
17555: PUSH
17556: LD_VAR 0 2
17560: PPUSH
17561: LD_INT 21
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: CALL_OW 70
17575: ST_TO_ADDR
// if not tmp then
17576: LD_VAR 0 4
17580: NOT
17581: IFFALSE 17585
// exit ;
17583: GO 17643
// for i in tmp do
17585: LD_ADDR_VAR 0 5
17589: PUSH
17590: LD_VAR 0 4
17594: PUSH
17595: FOR_IN
17596: IFFALSE 17631
// if GetBase ( i ) <> base then
17598: LD_VAR 0 5
17602: PPUSH
17603: CALL_OW 274
17607: PUSH
17608: LD_VAR 0 1
17612: NONEQUAL
17613: IFFALSE 17629
// ComLinkToBase ( base , i ) ;
17615: LD_VAR 0 1
17619: PPUSH
17620: LD_VAR 0 5
17624: PPUSH
17625: CALL_OW 169
17629: GO 17595
17631: POP
17632: POP
// result := tmp ;
17633: LD_ADDR_VAR 0 3
17637: PUSH
17638: LD_VAR 0 4
17642: ST_TO_ADDR
// end ;
17643: LD_VAR 0 3
17647: RET
// export function ComComplete ( unit , b ) ; var i ; begin
17648: LD_INT 0
17650: PPUSH
17651: PPUSH
// if BuildingStatus ( b ) = bs_build then
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL_OW 461
17661: PUSH
17662: LD_INT 1
17664: EQUAL
17665: IFFALSE 17725
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17667: LD_VAR 0 1
17671: PPUSH
17672: LD_STRING h
17674: PUSH
17675: LD_VAR 0 2
17679: PPUSH
17680: CALL_OW 250
17684: PUSH
17685: LD_VAR 0 2
17689: PPUSH
17690: CALL_OW 251
17694: PUSH
17695: LD_VAR 0 2
17699: PUSH
17700: LD_INT 0
17702: PUSH
17703: LD_INT 0
17705: PUSH
17706: LD_INT 0
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: LIST
17715: LIST
17716: LIST
17717: PUSH
17718: EMPTY
17719: LIST
17720: PPUSH
17721: CALL_OW 446
// end ;
17725: LD_VAR 0 3
17729: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17730: LD_INT 0
17732: PPUSH
17733: PPUSH
17734: PPUSH
17735: PPUSH
17736: PPUSH
17737: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17738: LD_VAR 0 1
17742: NOT
17743: PUSH
17744: LD_VAR 0 1
17748: PPUSH
17749: CALL_OW 263
17753: PUSH
17754: LD_INT 2
17756: EQUAL
17757: NOT
17758: OR
17759: IFFALSE 17763
// exit ;
17761: GO 18079
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17763: LD_ADDR_VAR 0 6
17767: PUSH
17768: LD_INT 22
17770: PUSH
17771: LD_VAR 0 1
17775: PPUSH
17776: CALL_OW 255
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: PUSH
17785: LD_INT 2
17787: PUSH
17788: LD_INT 30
17790: PUSH
17791: LD_INT 36
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: PUSH
17798: LD_INT 34
17800: PUSH
17801: LD_INT 31
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: PUSH
17808: EMPTY
17809: LIST
17810: LIST
17811: LIST
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: PPUSH
17817: CALL_OW 69
17821: ST_TO_ADDR
// if not tmp then
17822: LD_VAR 0 6
17826: NOT
17827: IFFALSE 17831
// exit ;
17829: GO 18079
// result := [ ] ;
17831: LD_ADDR_VAR 0 2
17835: PUSH
17836: EMPTY
17837: ST_TO_ADDR
// for i in tmp do
17838: LD_ADDR_VAR 0 3
17842: PUSH
17843: LD_VAR 0 6
17847: PUSH
17848: FOR_IN
17849: IFFALSE 17920
// begin t := UnitsInside ( i ) ;
17851: LD_ADDR_VAR 0 4
17855: PUSH
17856: LD_VAR 0 3
17860: PPUSH
17861: CALL_OW 313
17865: ST_TO_ADDR
// if t then
17866: LD_VAR 0 4
17870: IFFALSE 17918
// for j in t do
17872: LD_ADDR_VAR 0 7
17876: PUSH
17877: LD_VAR 0 4
17881: PUSH
17882: FOR_IN
17883: IFFALSE 17916
// result := Insert ( result , result + 1 , j ) ;
17885: LD_ADDR_VAR 0 2
17889: PUSH
17890: LD_VAR 0 2
17894: PPUSH
17895: LD_VAR 0 2
17899: PUSH
17900: LD_INT 1
17902: PLUS
17903: PPUSH
17904: LD_VAR 0 7
17908: PPUSH
17909: CALL_OW 2
17913: ST_TO_ADDR
17914: GO 17882
17916: POP
17917: POP
// end ;
17918: GO 17848
17920: POP
17921: POP
// if not result then
17922: LD_VAR 0 2
17926: NOT
17927: IFFALSE 17931
// exit ;
17929: GO 18079
// mech := result [ 1 ] ;
17931: LD_ADDR_VAR 0 5
17935: PUSH
17936: LD_VAR 0 2
17940: PUSH
17941: LD_INT 1
17943: ARRAY
17944: ST_TO_ADDR
// if result > 1 then
17945: LD_VAR 0 2
17949: PUSH
17950: LD_INT 1
17952: GREATER
17953: IFFALSE 18065
// for i = 2 to result do
17955: LD_ADDR_VAR 0 3
17959: PUSH
17960: DOUBLE
17961: LD_INT 2
17963: DEC
17964: ST_TO_ADDR
17965: LD_VAR 0 2
17969: PUSH
17970: FOR_TO
17971: IFFALSE 18063
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17973: LD_ADDR_VAR 0 4
17977: PUSH
17978: LD_VAR 0 2
17982: PUSH
17983: LD_VAR 0 3
17987: ARRAY
17988: PPUSH
17989: LD_INT 3
17991: PPUSH
17992: CALL_OW 259
17996: PUSH
17997: LD_VAR 0 2
18001: PUSH
18002: LD_VAR 0 3
18006: ARRAY
18007: PPUSH
18008: CALL_OW 432
18012: MINUS
18013: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18014: LD_VAR 0 4
18018: PUSH
18019: LD_VAR 0 5
18023: PPUSH
18024: LD_INT 3
18026: PPUSH
18027: CALL_OW 259
18031: PUSH
18032: LD_VAR 0 5
18036: PPUSH
18037: CALL_OW 432
18041: MINUS
18042: GREATEREQUAL
18043: IFFALSE 18061
// mech := result [ i ] ;
18045: LD_ADDR_VAR 0 5
18049: PUSH
18050: LD_VAR 0 2
18054: PUSH
18055: LD_VAR 0 3
18059: ARRAY
18060: ST_TO_ADDR
// end ;
18061: GO 17970
18063: POP
18064: POP
// ComLinkTo ( vehicle , mech ) ;
18065: LD_VAR 0 1
18069: PPUSH
18070: LD_VAR 0 5
18074: PPUSH
18075: CALL_OW 135
// end ;
18079: LD_VAR 0 2
18083: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18084: LD_INT 0
18086: PPUSH
18087: PPUSH
18088: PPUSH
18089: PPUSH
18090: PPUSH
18091: PPUSH
18092: PPUSH
18093: PPUSH
18094: PPUSH
18095: PPUSH
18096: PPUSH
18097: PPUSH
18098: PPUSH
// result := [ ] ;
18099: LD_ADDR_VAR 0 7
18103: PUSH
18104: EMPTY
18105: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18106: LD_VAR 0 1
18110: PPUSH
18111: CALL_OW 266
18115: PUSH
18116: LD_INT 0
18118: PUSH
18119: LD_INT 1
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: IN
18126: NOT
18127: IFFALSE 18131
// exit ;
18129: GO 19762
// if name then
18131: LD_VAR 0 3
18135: IFFALSE 18151
// SetBName ( base_dep , name ) ;
18137: LD_VAR 0 1
18141: PPUSH
18142: LD_VAR 0 3
18146: PPUSH
18147: CALL_OW 500
// base := GetBase ( base_dep ) ;
18151: LD_ADDR_VAR 0 15
18155: PUSH
18156: LD_VAR 0 1
18160: PPUSH
18161: CALL_OW 274
18165: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18166: LD_ADDR_VAR 0 16
18170: PUSH
18171: LD_VAR 0 1
18175: PPUSH
18176: CALL_OW 255
18180: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18181: LD_ADDR_VAR 0 17
18185: PUSH
18186: LD_VAR 0 1
18190: PPUSH
18191: CALL_OW 248
18195: ST_TO_ADDR
// if sources then
18196: LD_VAR 0 5
18200: IFFALSE 18247
// for i = 1 to 3 do
18202: LD_ADDR_VAR 0 8
18206: PUSH
18207: DOUBLE
18208: LD_INT 1
18210: DEC
18211: ST_TO_ADDR
18212: LD_INT 3
18214: PUSH
18215: FOR_TO
18216: IFFALSE 18245
// AddResourceType ( base , i , sources [ i ] ) ;
18218: LD_VAR 0 15
18222: PPUSH
18223: LD_VAR 0 8
18227: PPUSH
18228: LD_VAR 0 5
18232: PUSH
18233: LD_VAR 0 8
18237: ARRAY
18238: PPUSH
18239: CALL_OW 276
18243: GO 18215
18245: POP
18246: POP
// buildings := GetBaseBuildings ( base , area ) ;
18247: LD_ADDR_VAR 0 18
18251: PUSH
18252: LD_VAR 0 15
18256: PPUSH
18257: LD_VAR 0 2
18261: PPUSH
18262: CALL 17539 0 2
18266: ST_TO_ADDR
// InitHc ;
18267: CALL_OW 19
// InitUc ;
18271: CALL_OW 18
// uc_side := side ;
18275: LD_ADDR_OWVAR 20
18279: PUSH
18280: LD_VAR 0 16
18284: ST_TO_ADDR
// uc_nation := nation ;
18285: LD_ADDR_OWVAR 21
18289: PUSH
18290: LD_VAR 0 17
18294: ST_TO_ADDR
// if buildings then
18295: LD_VAR 0 18
18299: IFFALSE 19621
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18301: LD_ADDR_VAR 0 19
18305: PUSH
18306: LD_VAR 0 18
18310: PPUSH
18311: LD_INT 2
18313: PUSH
18314: LD_INT 30
18316: PUSH
18317: LD_INT 29
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: PUSH
18324: LD_INT 30
18326: PUSH
18327: LD_INT 30
18329: PUSH
18330: EMPTY
18331: LIST
18332: LIST
18333: PUSH
18334: EMPTY
18335: LIST
18336: LIST
18337: LIST
18338: PPUSH
18339: CALL_OW 72
18343: ST_TO_ADDR
// if tmp then
18344: LD_VAR 0 19
18348: IFFALSE 18396
// for i in tmp do
18350: LD_ADDR_VAR 0 8
18354: PUSH
18355: LD_VAR 0 19
18359: PUSH
18360: FOR_IN
18361: IFFALSE 18394
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18363: LD_VAR 0 8
18367: PPUSH
18368: CALL_OW 250
18372: PPUSH
18373: LD_VAR 0 8
18377: PPUSH
18378: CALL_OW 251
18382: PPUSH
18383: LD_VAR 0 16
18387: PPUSH
18388: CALL_OW 441
18392: GO 18360
18394: POP
18395: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18396: LD_VAR 0 18
18400: PPUSH
18401: LD_INT 2
18403: PUSH
18404: LD_INT 30
18406: PUSH
18407: LD_INT 32
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: LD_INT 30
18416: PUSH
18417: LD_INT 33
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 72
18433: IFFALSE 18521
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18435: LD_ADDR_VAR 0 8
18439: PUSH
18440: LD_VAR 0 18
18444: PPUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 30
18450: PUSH
18451: LD_INT 32
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 30
18460: PUSH
18461: LD_INT 33
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: EMPTY
18469: LIST
18470: LIST
18471: LIST
18472: PPUSH
18473: CALL_OW 72
18477: PUSH
18478: FOR_IN
18479: IFFALSE 18519
// begin if not GetBWeapon ( i ) then
18481: LD_VAR 0 8
18485: PPUSH
18486: CALL_OW 269
18490: NOT
18491: IFFALSE 18517
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18493: LD_VAR 0 8
18497: PPUSH
18498: LD_VAR 0 8
18502: PPUSH
18503: LD_VAR 0 2
18507: PPUSH
18508: CALL 19767 0 2
18512: PPUSH
18513: CALL_OW 431
// end ;
18517: GO 18478
18519: POP
18520: POP
// end ; for i = 1 to personel do
18521: LD_ADDR_VAR 0 8
18525: PUSH
18526: DOUBLE
18527: LD_INT 1
18529: DEC
18530: ST_TO_ADDR
18531: LD_VAR 0 6
18535: PUSH
18536: FOR_TO
18537: IFFALSE 19601
// begin if i > 4 then
18539: LD_VAR 0 8
18543: PUSH
18544: LD_INT 4
18546: GREATER
18547: IFFALSE 18551
// break ;
18549: GO 19601
// case i of 1 :
18551: LD_VAR 0 8
18555: PUSH
18556: LD_INT 1
18558: DOUBLE
18559: EQUAL
18560: IFTRUE 18564
18562: GO 18644
18564: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18565: LD_ADDR_VAR 0 12
18569: PUSH
18570: LD_VAR 0 18
18574: PPUSH
18575: LD_INT 22
18577: PUSH
18578: LD_VAR 0 16
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: PUSH
18587: LD_INT 58
18589: PUSH
18590: EMPTY
18591: LIST
18592: PUSH
18593: LD_INT 2
18595: PUSH
18596: LD_INT 30
18598: PUSH
18599: LD_INT 32
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: PUSH
18606: LD_INT 30
18608: PUSH
18609: LD_INT 4
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: PUSH
18616: LD_INT 30
18618: PUSH
18619: LD_INT 5
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: LIST
18636: PPUSH
18637: CALL_OW 72
18641: ST_TO_ADDR
18642: GO 18866
18644: LD_INT 2
18646: DOUBLE
18647: EQUAL
18648: IFTRUE 18652
18650: GO 18714
18652: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18653: LD_ADDR_VAR 0 12
18657: PUSH
18658: LD_VAR 0 18
18662: PPUSH
18663: LD_INT 22
18665: PUSH
18666: LD_VAR 0 16
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: LD_INT 2
18677: PUSH
18678: LD_INT 30
18680: PUSH
18681: LD_INT 0
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: PUSH
18688: LD_INT 30
18690: PUSH
18691: LD_INT 1
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: PPUSH
18707: CALL_OW 72
18711: ST_TO_ADDR
18712: GO 18866
18714: LD_INT 3
18716: DOUBLE
18717: EQUAL
18718: IFTRUE 18722
18720: GO 18784
18722: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18723: LD_ADDR_VAR 0 12
18727: PUSH
18728: LD_VAR 0 18
18732: PPUSH
18733: LD_INT 22
18735: PUSH
18736: LD_VAR 0 16
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: PUSH
18745: LD_INT 2
18747: PUSH
18748: LD_INT 30
18750: PUSH
18751: LD_INT 2
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 30
18760: PUSH
18761: LD_INT 3
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: LIST
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PPUSH
18777: CALL_OW 72
18781: ST_TO_ADDR
18782: GO 18866
18784: LD_INT 4
18786: DOUBLE
18787: EQUAL
18788: IFTRUE 18792
18790: GO 18865
18792: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18793: LD_ADDR_VAR 0 12
18797: PUSH
18798: LD_VAR 0 18
18802: PPUSH
18803: LD_INT 22
18805: PUSH
18806: LD_VAR 0 16
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 2
18817: PUSH
18818: LD_INT 30
18820: PUSH
18821: LD_INT 6
18823: PUSH
18824: EMPTY
18825: LIST
18826: LIST
18827: PUSH
18828: LD_INT 30
18830: PUSH
18831: LD_INT 7
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 30
18840: PUSH
18841: LD_INT 8
18843: PUSH
18844: EMPTY
18845: LIST
18846: LIST
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: LIST
18852: LIST
18853: PUSH
18854: EMPTY
18855: LIST
18856: LIST
18857: PPUSH
18858: CALL_OW 72
18862: ST_TO_ADDR
18863: GO 18866
18865: POP
// if i = 1 then
18866: LD_VAR 0 8
18870: PUSH
18871: LD_INT 1
18873: EQUAL
18874: IFFALSE 18985
// begin tmp := [ ] ;
18876: LD_ADDR_VAR 0 19
18880: PUSH
18881: EMPTY
18882: ST_TO_ADDR
// for j in f do
18883: LD_ADDR_VAR 0 9
18887: PUSH
18888: LD_VAR 0 12
18892: PUSH
18893: FOR_IN
18894: IFFALSE 18967
// if GetBType ( j ) = b_bunker then
18896: LD_VAR 0 9
18900: PPUSH
18901: CALL_OW 266
18905: PUSH
18906: LD_INT 32
18908: EQUAL
18909: IFFALSE 18936
// tmp := Insert ( tmp , 1 , j ) else
18911: LD_ADDR_VAR 0 19
18915: PUSH
18916: LD_VAR 0 19
18920: PPUSH
18921: LD_INT 1
18923: PPUSH
18924: LD_VAR 0 9
18928: PPUSH
18929: CALL_OW 2
18933: ST_TO_ADDR
18934: GO 18965
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18936: LD_ADDR_VAR 0 19
18940: PUSH
18941: LD_VAR 0 19
18945: PPUSH
18946: LD_VAR 0 19
18950: PUSH
18951: LD_INT 1
18953: PLUS
18954: PPUSH
18955: LD_VAR 0 9
18959: PPUSH
18960: CALL_OW 2
18964: ST_TO_ADDR
18965: GO 18893
18967: POP
18968: POP
// if tmp then
18969: LD_VAR 0 19
18973: IFFALSE 18985
// f := tmp ;
18975: LD_ADDR_VAR 0 12
18979: PUSH
18980: LD_VAR 0 19
18984: ST_TO_ADDR
// end ; x := personel [ i ] ;
18985: LD_ADDR_VAR 0 13
18989: PUSH
18990: LD_VAR 0 6
18994: PUSH
18995: LD_VAR 0 8
18999: ARRAY
19000: ST_TO_ADDR
// if x = - 1 then
19001: LD_VAR 0 13
19005: PUSH
19006: LD_INT 1
19008: NEG
19009: EQUAL
19010: IFFALSE 19219
// begin for j in f do
19012: LD_ADDR_VAR 0 9
19016: PUSH
19017: LD_VAR 0 12
19021: PUSH
19022: FOR_IN
19023: IFFALSE 19215
// repeat InitHc ;
19025: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19029: LD_VAR 0 9
19033: PPUSH
19034: CALL_OW 266
19038: PUSH
19039: LD_INT 5
19041: EQUAL
19042: IFFALSE 19112
// begin if UnitsInside ( j ) < 3 then
19044: LD_VAR 0 9
19048: PPUSH
19049: CALL_OW 313
19053: PUSH
19054: LD_INT 3
19056: LESS
19057: IFFALSE 19093
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19059: LD_INT 0
19061: PPUSH
19062: LD_INT 5
19064: PUSH
19065: LD_INT 8
19067: PUSH
19068: LD_INT 9
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: LIST
19075: PUSH
19076: LD_VAR 0 17
19080: ARRAY
19081: PPUSH
19082: LD_VAR 0 4
19086: PPUSH
19087: CALL_OW 380
19091: GO 19110
// PrepareHuman ( false , i , skill ) ;
19093: LD_INT 0
19095: PPUSH
19096: LD_VAR 0 8
19100: PPUSH
19101: LD_VAR 0 4
19105: PPUSH
19106: CALL_OW 380
// end else
19110: GO 19129
// PrepareHuman ( false , i , skill ) ;
19112: LD_INT 0
19114: PPUSH
19115: LD_VAR 0 8
19119: PPUSH
19120: LD_VAR 0 4
19124: PPUSH
19125: CALL_OW 380
// un := CreateHuman ;
19129: LD_ADDR_VAR 0 14
19133: PUSH
19134: CALL_OW 44
19138: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19139: LD_ADDR_VAR 0 7
19143: PUSH
19144: LD_VAR 0 7
19148: PPUSH
19149: LD_INT 1
19151: PPUSH
19152: LD_VAR 0 14
19156: PPUSH
19157: CALL_OW 2
19161: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19162: LD_VAR 0 14
19166: PPUSH
19167: LD_VAR 0 9
19171: PPUSH
19172: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19176: LD_VAR 0 9
19180: PPUSH
19181: CALL_OW 313
19185: PUSH
19186: LD_INT 6
19188: EQUAL
19189: PUSH
19190: LD_VAR 0 9
19194: PPUSH
19195: CALL_OW 266
19199: PUSH
19200: LD_INT 32
19202: PUSH
19203: LD_INT 31
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: IN
19210: OR
19211: IFFALSE 19025
19213: GO 19022
19215: POP
19216: POP
// end else
19217: GO 19599
// for j = 1 to x do
19219: LD_ADDR_VAR 0 9
19223: PUSH
19224: DOUBLE
19225: LD_INT 1
19227: DEC
19228: ST_TO_ADDR
19229: LD_VAR 0 13
19233: PUSH
19234: FOR_TO
19235: IFFALSE 19597
// begin InitHc ;
19237: CALL_OW 19
// if not f then
19241: LD_VAR 0 12
19245: NOT
19246: IFFALSE 19335
// begin PrepareHuman ( false , i , skill ) ;
19248: LD_INT 0
19250: PPUSH
19251: LD_VAR 0 8
19255: PPUSH
19256: LD_VAR 0 4
19260: PPUSH
19261: CALL_OW 380
// un := CreateHuman ;
19265: LD_ADDR_VAR 0 14
19269: PUSH
19270: CALL_OW 44
19274: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19275: LD_ADDR_VAR 0 7
19279: PUSH
19280: LD_VAR 0 7
19284: PPUSH
19285: LD_INT 1
19287: PPUSH
19288: LD_VAR 0 14
19292: PPUSH
19293: CALL_OW 2
19297: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19298: LD_VAR 0 14
19302: PPUSH
19303: LD_VAR 0 1
19307: PPUSH
19308: CALL_OW 250
19312: PPUSH
19313: LD_VAR 0 1
19317: PPUSH
19318: CALL_OW 251
19322: PPUSH
19323: LD_INT 10
19325: PPUSH
19326: LD_INT 0
19328: PPUSH
19329: CALL_OW 50
// continue ;
19333: GO 19234
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19335: LD_VAR 0 12
19339: PUSH
19340: LD_INT 1
19342: ARRAY
19343: PPUSH
19344: CALL_OW 313
19348: PUSH
19349: LD_VAR 0 12
19353: PUSH
19354: LD_INT 1
19356: ARRAY
19357: PPUSH
19358: CALL_OW 266
19362: PUSH
19363: LD_INT 32
19365: PUSH
19366: LD_INT 31
19368: PUSH
19369: EMPTY
19370: LIST
19371: LIST
19372: IN
19373: AND
19374: PUSH
19375: LD_VAR 0 12
19379: PUSH
19380: LD_INT 1
19382: ARRAY
19383: PPUSH
19384: CALL_OW 313
19388: PUSH
19389: LD_INT 6
19391: EQUAL
19392: OR
19393: IFFALSE 19413
// f := Delete ( f , 1 ) ;
19395: LD_ADDR_VAR 0 12
19399: PUSH
19400: LD_VAR 0 12
19404: PPUSH
19405: LD_INT 1
19407: PPUSH
19408: CALL_OW 3
19412: ST_TO_ADDR
// if not f then
19413: LD_VAR 0 12
19417: NOT
19418: IFFALSE 19436
// begin x := x + 2 ;
19420: LD_ADDR_VAR 0 13
19424: PUSH
19425: LD_VAR 0 13
19429: PUSH
19430: LD_INT 2
19432: PLUS
19433: ST_TO_ADDR
// continue ;
19434: GO 19234
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19436: LD_VAR 0 12
19440: PUSH
19441: LD_INT 1
19443: ARRAY
19444: PPUSH
19445: CALL_OW 266
19449: PUSH
19450: LD_INT 5
19452: EQUAL
19453: IFFALSE 19527
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19455: LD_VAR 0 12
19459: PUSH
19460: LD_INT 1
19462: ARRAY
19463: PPUSH
19464: CALL_OW 313
19468: PUSH
19469: LD_INT 3
19471: LESS
19472: IFFALSE 19508
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19474: LD_INT 0
19476: PPUSH
19477: LD_INT 5
19479: PUSH
19480: LD_INT 8
19482: PUSH
19483: LD_INT 9
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: LIST
19490: PUSH
19491: LD_VAR 0 17
19495: ARRAY
19496: PPUSH
19497: LD_VAR 0 4
19501: PPUSH
19502: CALL_OW 380
19506: GO 19525
// PrepareHuman ( false , i , skill ) ;
19508: LD_INT 0
19510: PPUSH
19511: LD_VAR 0 8
19515: PPUSH
19516: LD_VAR 0 4
19520: PPUSH
19521: CALL_OW 380
// end else
19525: GO 19544
// PrepareHuman ( false , i , skill ) ;
19527: LD_INT 0
19529: PPUSH
19530: LD_VAR 0 8
19534: PPUSH
19535: LD_VAR 0 4
19539: PPUSH
19540: CALL_OW 380
// un := CreateHuman ;
19544: LD_ADDR_VAR 0 14
19548: PUSH
19549: CALL_OW 44
19553: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19554: LD_ADDR_VAR 0 7
19558: PUSH
19559: LD_VAR 0 7
19563: PPUSH
19564: LD_INT 1
19566: PPUSH
19567: LD_VAR 0 14
19571: PPUSH
19572: CALL_OW 2
19576: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19577: LD_VAR 0 14
19581: PPUSH
19582: LD_VAR 0 12
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: CALL_OW 52
// end ;
19595: GO 19234
19597: POP
19598: POP
// end ;
19599: GO 18536
19601: POP
19602: POP
// result := result ^ buildings ;
19603: LD_ADDR_VAR 0 7
19607: PUSH
19608: LD_VAR 0 7
19612: PUSH
19613: LD_VAR 0 18
19617: ADD
19618: ST_TO_ADDR
// end else
19619: GO 19762
// begin for i = 1 to personel do
19621: LD_ADDR_VAR 0 8
19625: PUSH
19626: DOUBLE
19627: LD_INT 1
19629: DEC
19630: ST_TO_ADDR
19631: LD_VAR 0 6
19635: PUSH
19636: FOR_TO
19637: IFFALSE 19760
// begin if i > 4 then
19639: LD_VAR 0 8
19643: PUSH
19644: LD_INT 4
19646: GREATER
19647: IFFALSE 19651
// break ;
19649: GO 19760
// x := personel [ i ] ;
19651: LD_ADDR_VAR 0 13
19655: PUSH
19656: LD_VAR 0 6
19660: PUSH
19661: LD_VAR 0 8
19665: ARRAY
19666: ST_TO_ADDR
// if x = - 1 then
19667: LD_VAR 0 13
19671: PUSH
19672: LD_INT 1
19674: NEG
19675: EQUAL
19676: IFFALSE 19680
// continue ;
19678: GO 19636
// PrepareHuman ( false , i , skill ) ;
19680: LD_INT 0
19682: PPUSH
19683: LD_VAR 0 8
19687: PPUSH
19688: LD_VAR 0 4
19692: PPUSH
19693: CALL_OW 380
// un := CreateHuman ;
19697: LD_ADDR_VAR 0 14
19701: PUSH
19702: CALL_OW 44
19706: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19707: LD_VAR 0 14
19711: PPUSH
19712: LD_VAR 0 1
19716: PPUSH
19717: CALL_OW 250
19721: PPUSH
19722: LD_VAR 0 1
19726: PPUSH
19727: CALL_OW 251
19731: PPUSH
19732: LD_INT 10
19734: PPUSH
19735: LD_INT 0
19737: PPUSH
19738: CALL_OW 50
// result := result ^ un ;
19742: LD_ADDR_VAR 0 7
19746: PUSH
19747: LD_VAR 0 7
19751: PUSH
19752: LD_VAR 0 14
19756: ADD
19757: ST_TO_ADDR
// end ;
19758: GO 19636
19760: POP
19761: POP
// end ; end ;
19762: LD_VAR 0 7
19766: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19767: LD_INT 0
19769: PPUSH
19770: PPUSH
19771: PPUSH
19772: PPUSH
19773: PPUSH
19774: PPUSH
19775: PPUSH
19776: PPUSH
19777: PPUSH
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
// result := false ;
19785: LD_ADDR_VAR 0 3
19789: PUSH
19790: LD_INT 0
19792: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19793: LD_VAR 0 1
19797: NOT
19798: PUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: CALL_OW 266
19808: PUSH
19809: LD_INT 32
19811: PUSH
19812: LD_INT 33
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: IN
19819: NOT
19820: OR
19821: IFFALSE 19825
// exit ;
19823: GO 20961
// nat := GetNation ( tower ) ;
19825: LD_ADDR_VAR 0 12
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 248
19839: ST_TO_ADDR
// side := GetSide ( tower ) ;
19840: LD_ADDR_VAR 0 16
19844: PUSH
19845: LD_VAR 0 1
19849: PPUSH
19850: CALL_OW 255
19854: ST_TO_ADDR
// x := GetX ( tower ) ;
19855: LD_ADDR_VAR 0 10
19859: PUSH
19860: LD_VAR 0 1
19864: PPUSH
19865: CALL_OW 250
19869: ST_TO_ADDR
// y := GetY ( tower ) ;
19870: LD_ADDR_VAR 0 11
19874: PUSH
19875: LD_VAR 0 1
19879: PPUSH
19880: CALL_OW 251
19884: ST_TO_ADDR
// if not x or not y then
19885: LD_VAR 0 10
19889: NOT
19890: PUSH
19891: LD_VAR 0 11
19895: NOT
19896: OR
19897: IFFALSE 19901
// exit ;
19899: GO 20961
// weapon := 0 ;
19901: LD_ADDR_VAR 0 18
19905: PUSH
19906: LD_INT 0
19908: ST_TO_ADDR
// fac_list := [ ] ;
19909: LD_ADDR_VAR 0 17
19913: PUSH
19914: EMPTY
19915: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
19916: LD_ADDR_VAR 0 6
19920: PUSH
19921: LD_VAR 0 1
19925: PPUSH
19926: CALL_OW 274
19930: PPUSH
19931: LD_VAR 0 2
19935: PPUSH
19936: CALL 17539 0 2
19940: PPUSH
19941: LD_INT 30
19943: PUSH
19944: LD_INT 3
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PPUSH
19951: CALL_OW 72
19955: ST_TO_ADDR
// if not factories then
19956: LD_VAR 0 6
19960: NOT
19961: IFFALSE 19965
// exit ;
19963: GO 20961
// for i in factories do
19965: LD_ADDR_VAR 0 8
19969: PUSH
19970: LD_VAR 0 6
19974: PUSH
19975: FOR_IN
19976: IFFALSE 20001
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19978: LD_ADDR_VAR 0 17
19982: PUSH
19983: LD_VAR 0 17
19987: PUSH
19988: LD_VAR 0 8
19992: PPUSH
19993: CALL_OW 478
19997: UNION
19998: ST_TO_ADDR
19999: GO 19975
20001: POP
20002: POP
// if not fac_list then
20003: LD_VAR 0 17
20007: NOT
20008: IFFALSE 20012
// exit ;
20010: GO 20961
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20012: LD_ADDR_VAR 0 5
20016: PUSH
20017: LD_INT 4
20019: PUSH
20020: LD_INT 5
20022: PUSH
20023: LD_INT 9
20025: PUSH
20026: LD_INT 10
20028: PUSH
20029: LD_INT 6
20031: PUSH
20032: LD_INT 7
20034: PUSH
20035: LD_INT 11
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: LIST
20042: LIST
20043: LIST
20044: LIST
20045: LIST
20046: PUSH
20047: LD_INT 27
20049: PUSH
20050: LD_INT 28
20052: PUSH
20053: LD_INT 26
20055: PUSH
20056: LD_INT 30
20058: PUSH
20059: EMPTY
20060: LIST
20061: LIST
20062: LIST
20063: LIST
20064: PUSH
20065: LD_INT 43
20067: PUSH
20068: LD_INT 44
20070: PUSH
20071: LD_INT 46
20073: PUSH
20074: LD_INT 45
20076: PUSH
20077: LD_INT 47
20079: PUSH
20080: LD_INT 49
20082: PUSH
20083: EMPTY
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: PUSH
20096: LD_VAR 0 12
20100: ARRAY
20101: ST_TO_ADDR
// for i in list do
20102: LD_ADDR_VAR 0 8
20106: PUSH
20107: LD_VAR 0 5
20111: PUSH
20112: FOR_IN
20113: IFFALSE 20146
// if not i in fac_list then
20115: LD_VAR 0 8
20119: PUSH
20120: LD_VAR 0 17
20124: IN
20125: NOT
20126: IFFALSE 20144
// list := list diff i ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_VAR 0 5
20137: PUSH
20138: LD_VAR 0 8
20142: DIFF
20143: ST_TO_ADDR
20144: GO 20112
20146: POP
20147: POP
// if not list then
20148: LD_VAR 0 5
20152: NOT
20153: IFFALSE 20157
// exit ;
20155: GO 20961
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20157: LD_VAR 0 12
20161: PUSH
20162: LD_INT 3
20164: EQUAL
20165: PUSH
20166: LD_INT 49
20168: PUSH
20169: LD_VAR 0 5
20173: IN
20174: AND
20175: PUSH
20176: LD_INT 31
20178: PPUSH
20179: LD_VAR 0 16
20183: PPUSH
20184: CALL_OW 321
20188: PUSH
20189: LD_INT 2
20191: EQUAL
20192: AND
20193: IFFALSE 20253
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20195: LD_INT 22
20197: PUSH
20198: LD_VAR 0 16
20202: PUSH
20203: EMPTY
20204: LIST
20205: LIST
20206: PUSH
20207: LD_INT 35
20209: PUSH
20210: LD_INT 49
20212: PUSH
20213: EMPTY
20214: LIST
20215: LIST
20216: PUSH
20217: LD_INT 91
20219: PUSH
20220: LD_VAR 0 1
20224: PUSH
20225: LD_INT 10
20227: PUSH
20228: EMPTY
20229: LIST
20230: LIST
20231: LIST
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: LIST
20237: PPUSH
20238: CALL_OW 69
20242: NOT
20243: IFFALSE 20253
// weapon := ru_time_lapser ;
20245: LD_ADDR_VAR 0 18
20249: PUSH
20250: LD_INT 49
20252: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20253: LD_VAR 0 12
20257: PUSH
20258: LD_INT 1
20260: PUSH
20261: LD_INT 2
20263: PUSH
20264: EMPTY
20265: LIST
20266: LIST
20267: IN
20268: PUSH
20269: LD_INT 11
20271: PUSH
20272: LD_VAR 0 5
20276: IN
20277: PUSH
20278: LD_INT 30
20280: PUSH
20281: LD_VAR 0 5
20285: IN
20286: OR
20287: AND
20288: PUSH
20289: LD_INT 6
20291: PPUSH
20292: LD_VAR 0 16
20296: PPUSH
20297: CALL_OW 321
20301: PUSH
20302: LD_INT 2
20304: EQUAL
20305: AND
20306: IFFALSE 20471
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20308: LD_INT 22
20310: PUSH
20311: LD_VAR 0 16
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: PUSH
20320: LD_INT 2
20322: PUSH
20323: LD_INT 35
20325: PUSH
20326: LD_INT 11
20328: PUSH
20329: EMPTY
20330: LIST
20331: LIST
20332: PUSH
20333: LD_INT 35
20335: PUSH
20336: LD_INT 30
20338: PUSH
20339: EMPTY
20340: LIST
20341: LIST
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: LIST
20347: PUSH
20348: LD_INT 91
20350: PUSH
20351: LD_VAR 0 1
20355: PUSH
20356: LD_INT 18
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: LIST
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: LIST
20368: PPUSH
20369: CALL_OW 69
20373: NOT
20374: PUSH
20375: LD_INT 22
20377: PUSH
20378: LD_VAR 0 16
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 2
20389: PUSH
20390: LD_INT 30
20392: PUSH
20393: LD_INT 32
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: PUSH
20400: LD_INT 30
20402: PUSH
20403: LD_INT 33
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: LIST
20414: PUSH
20415: LD_INT 91
20417: PUSH
20418: LD_VAR 0 1
20422: PUSH
20423: LD_INT 12
20425: PUSH
20426: EMPTY
20427: LIST
20428: LIST
20429: LIST
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: LIST
20435: PUSH
20436: EMPTY
20437: LIST
20438: PPUSH
20439: CALL_OW 69
20443: PUSH
20444: LD_INT 2
20446: GREATER
20447: AND
20448: IFFALSE 20471
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20450: LD_ADDR_VAR 0 18
20454: PUSH
20455: LD_INT 11
20457: PUSH
20458: LD_INT 30
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: LD_VAR 0 12
20469: ARRAY
20470: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20471: LD_VAR 0 18
20475: NOT
20476: PUSH
20477: LD_INT 40
20479: PPUSH
20480: LD_VAR 0 16
20484: PPUSH
20485: CALL_OW 321
20489: PUSH
20490: LD_INT 2
20492: EQUAL
20493: AND
20494: PUSH
20495: LD_INT 7
20497: PUSH
20498: LD_VAR 0 5
20502: IN
20503: PUSH
20504: LD_INT 28
20506: PUSH
20507: LD_VAR 0 5
20511: IN
20512: OR
20513: PUSH
20514: LD_INT 45
20516: PUSH
20517: LD_VAR 0 5
20521: IN
20522: OR
20523: AND
20524: IFFALSE 20778
// begin hex := GetHexInfo ( x , y ) ;
20526: LD_ADDR_VAR 0 4
20530: PUSH
20531: LD_VAR 0 10
20535: PPUSH
20536: LD_VAR 0 11
20540: PPUSH
20541: CALL_OW 546
20545: ST_TO_ADDR
// if hex [ 1 ] then
20546: LD_VAR 0 4
20550: PUSH
20551: LD_INT 1
20553: ARRAY
20554: IFFALSE 20558
// exit ;
20556: GO 20961
// height := hex [ 2 ] ;
20558: LD_ADDR_VAR 0 15
20562: PUSH
20563: LD_VAR 0 4
20567: PUSH
20568: LD_INT 2
20570: ARRAY
20571: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20572: LD_ADDR_VAR 0 14
20576: PUSH
20577: LD_INT 0
20579: PUSH
20580: LD_INT 2
20582: PUSH
20583: LD_INT 3
20585: PUSH
20586: LD_INT 5
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: ST_TO_ADDR
// for i in tmp do
20595: LD_ADDR_VAR 0 8
20599: PUSH
20600: LD_VAR 0 14
20604: PUSH
20605: FOR_IN
20606: IFFALSE 20776
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20608: LD_ADDR_VAR 0 9
20612: PUSH
20613: LD_VAR 0 10
20617: PPUSH
20618: LD_VAR 0 8
20622: PPUSH
20623: LD_INT 5
20625: PPUSH
20626: CALL_OW 272
20630: PUSH
20631: LD_VAR 0 11
20635: PPUSH
20636: LD_VAR 0 8
20640: PPUSH
20641: LD_INT 5
20643: PPUSH
20644: CALL_OW 273
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20653: LD_VAR 0 9
20657: PUSH
20658: LD_INT 1
20660: ARRAY
20661: PPUSH
20662: LD_VAR 0 9
20666: PUSH
20667: LD_INT 2
20669: ARRAY
20670: PPUSH
20671: CALL_OW 488
20675: IFFALSE 20774
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20677: LD_ADDR_VAR 0 4
20681: PUSH
20682: LD_VAR 0 9
20686: PUSH
20687: LD_INT 1
20689: ARRAY
20690: PPUSH
20691: LD_VAR 0 9
20695: PUSH
20696: LD_INT 2
20698: ARRAY
20699: PPUSH
20700: CALL_OW 546
20704: ST_TO_ADDR
// if hex [ 1 ] then
20705: LD_VAR 0 4
20709: PUSH
20710: LD_INT 1
20712: ARRAY
20713: IFFALSE 20717
// continue ;
20715: GO 20605
// h := hex [ 2 ] ;
20717: LD_ADDR_VAR 0 13
20721: PUSH
20722: LD_VAR 0 4
20726: PUSH
20727: LD_INT 2
20729: ARRAY
20730: ST_TO_ADDR
// if h + 7 < height then
20731: LD_VAR 0 13
20735: PUSH
20736: LD_INT 7
20738: PLUS
20739: PUSH
20740: LD_VAR 0 15
20744: LESS
20745: IFFALSE 20774
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20747: LD_ADDR_VAR 0 18
20751: PUSH
20752: LD_INT 7
20754: PUSH
20755: LD_INT 28
20757: PUSH
20758: LD_INT 45
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: LIST
20765: PUSH
20766: LD_VAR 0 12
20770: ARRAY
20771: ST_TO_ADDR
// break ;
20772: GO 20776
// end ; end ; end ;
20774: GO 20605
20776: POP
20777: POP
// end ; if not weapon then
20778: LD_VAR 0 18
20782: NOT
20783: IFFALSE 20843
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20785: LD_ADDR_VAR 0 5
20789: PUSH
20790: LD_VAR 0 5
20794: PUSH
20795: LD_INT 11
20797: PUSH
20798: LD_INT 30
20800: PUSH
20801: LD_INT 49
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: DIFF
20809: ST_TO_ADDR
// if not list then
20810: LD_VAR 0 5
20814: NOT
20815: IFFALSE 20819
// exit ;
20817: GO 20961
// weapon := list [ rand ( 1 , list ) ] ;
20819: LD_ADDR_VAR 0 18
20823: PUSH
20824: LD_VAR 0 5
20828: PUSH
20829: LD_INT 1
20831: PPUSH
20832: LD_VAR 0 5
20836: PPUSH
20837: CALL_OW 12
20841: ARRAY
20842: ST_TO_ADDR
// end ; if weapon then
20843: LD_VAR 0 18
20847: IFFALSE 20961
// begin tmp := CostOfWeapon ( weapon ) ;
20849: LD_ADDR_VAR 0 14
20853: PUSH
20854: LD_VAR 0 18
20858: PPUSH
20859: CALL_OW 451
20863: ST_TO_ADDR
// j := GetBase ( tower ) ;
20864: LD_ADDR_VAR 0 9
20868: PUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: CALL_OW 274
20878: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20879: LD_VAR 0 9
20883: PPUSH
20884: LD_INT 1
20886: PPUSH
20887: CALL_OW 275
20891: PUSH
20892: LD_VAR 0 14
20896: PUSH
20897: LD_INT 1
20899: ARRAY
20900: GREATEREQUAL
20901: PUSH
20902: LD_VAR 0 9
20906: PPUSH
20907: LD_INT 2
20909: PPUSH
20910: CALL_OW 275
20914: PUSH
20915: LD_VAR 0 14
20919: PUSH
20920: LD_INT 2
20922: ARRAY
20923: GREATEREQUAL
20924: AND
20925: PUSH
20926: LD_VAR 0 9
20930: PPUSH
20931: LD_INT 3
20933: PPUSH
20934: CALL_OW 275
20938: PUSH
20939: LD_VAR 0 14
20943: PUSH
20944: LD_INT 3
20946: ARRAY
20947: GREATEREQUAL
20948: AND
20949: IFFALSE 20961
// result := weapon ;
20951: LD_ADDR_VAR 0 3
20955: PUSH
20956: LD_VAR 0 18
20960: ST_TO_ADDR
// end ; end ;
20961: LD_VAR 0 3
20965: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20966: LD_INT 0
20968: PPUSH
20969: PPUSH
// result := true ;
20970: LD_ADDR_VAR 0 3
20974: PUSH
20975: LD_INT 1
20977: ST_TO_ADDR
// if array1 = array2 then
20978: LD_VAR 0 1
20982: PUSH
20983: LD_VAR 0 2
20987: EQUAL
20988: IFFALSE 21048
// begin for i = 1 to array1 do
20990: LD_ADDR_VAR 0 4
20994: PUSH
20995: DOUBLE
20996: LD_INT 1
20998: DEC
20999: ST_TO_ADDR
21000: LD_VAR 0 1
21004: PUSH
21005: FOR_TO
21006: IFFALSE 21044
// if array1 [ i ] <> array2 [ i ] then
21008: LD_VAR 0 1
21012: PUSH
21013: LD_VAR 0 4
21017: ARRAY
21018: PUSH
21019: LD_VAR 0 2
21023: PUSH
21024: LD_VAR 0 4
21028: ARRAY
21029: NONEQUAL
21030: IFFALSE 21042
// begin result := false ;
21032: LD_ADDR_VAR 0 3
21036: PUSH
21037: LD_INT 0
21039: ST_TO_ADDR
// break ;
21040: GO 21044
// end ;
21042: GO 21005
21044: POP
21045: POP
// end else
21046: GO 21056
// result := false ;
21048: LD_ADDR_VAR 0 3
21052: PUSH
21053: LD_INT 0
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21061: LD_INT 0
21063: PPUSH
21064: PPUSH
21065: PPUSH
// pom := GetBase ( fac ) ;
21066: LD_ADDR_VAR 0 5
21070: PUSH
21071: LD_VAR 0 1
21075: PPUSH
21076: CALL_OW 274
21080: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21081: LD_ADDR_VAR 0 4
21085: PUSH
21086: LD_VAR 0 2
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: PPUSH
21095: LD_VAR 0 2
21099: PUSH
21100: LD_INT 2
21102: ARRAY
21103: PPUSH
21104: LD_VAR 0 2
21108: PUSH
21109: LD_INT 3
21111: ARRAY
21112: PPUSH
21113: LD_VAR 0 2
21117: PUSH
21118: LD_INT 4
21120: ARRAY
21121: PPUSH
21122: CALL_OW 449
21126: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21127: LD_ADDR_VAR 0 3
21131: PUSH
21132: LD_VAR 0 5
21136: PPUSH
21137: LD_INT 1
21139: PPUSH
21140: CALL_OW 275
21144: PUSH
21145: LD_VAR 0 4
21149: PUSH
21150: LD_INT 1
21152: ARRAY
21153: GREATEREQUAL
21154: PUSH
21155: LD_VAR 0 5
21159: PPUSH
21160: LD_INT 2
21162: PPUSH
21163: CALL_OW 275
21167: PUSH
21168: LD_VAR 0 4
21172: PUSH
21173: LD_INT 2
21175: ARRAY
21176: GREATEREQUAL
21177: AND
21178: PUSH
21179: LD_VAR 0 5
21183: PPUSH
21184: LD_INT 3
21186: PPUSH
21187: CALL_OW 275
21191: PUSH
21192: LD_VAR 0 4
21196: PUSH
21197: LD_INT 3
21199: ARRAY
21200: GREATEREQUAL
21201: AND
21202: ST_TO_ADDR
// end ;
21203: LD_VAR 0 3
21207: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21208: LD_INT 0
21210: PPUSH
21211: PPUSH
21212: PPUSH
21213: PPUSH
// pom := GetBase ( building ) ;
21214: LD_ADDR_VAR 0 3
21218: PUSH
21219: LD_VAR 0 1
21223: PPUSH
21224: CALL_OW 274
21228: ST_TO_ADDR
// if not pom then
21229: LD_VAR 0 3
21233: NOT
21234: IFFALSE 21238
// exit ;
21236: GO 21408
// btype := GetBType ( building ) ;
21238: LD_ADDR_VAR 0 5
21242: PUSH
21243: LD_VAR 0 1
21247: PPUSH
21248: CALL_OW 266
21252: ST_TO_ADDR
// if btype = b_armoury then
21253: LD_VAR 0 5
21257: PUSH
21258: LD_INT 4
21260: EQUAL
21261: IFFALSE 21271
// btype := b_barracks ;
21263: LD_ADDR_VAR 0 5
21267: PUSH
21268: LD_INT 5
21270: ST_TO_ADDR
// if btype = b_depot then
21271: LD_VAR 0 5
21275: PUSH
21276: LD_INT 0
21278: EQUAL
21279: IFFALSE 21289
// btype := b_warehouse ;
21281: LD_ADDR_VAR 0 5
21285: PUSH
21286: LD_INT 1
21288: ST_TO_ADDR
// if btype = b_workshop then
21289: LD_VAR 0 5
21293: PUSH
21294: LD_INT 2
21296: EQUAL
21297: IFFALSE 21307
// btype := b_factory ;
21299: LD_ADDR_VAR 0 5
21303: PUSH
21304: LD_INT 3
21306: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21307: LD_ADDR_VAR 0 4
21311: PUSH
21312: LD_VAR 0 5
21316: PPUSH
21317: LD_VAR 0 1
21321: PPUSH
21322: CALL_OW 248
21326: PPUSH
21327: CALL_OW 450
21331: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21332: LD_ADDR_VAR 0 2
21336: PUSH
21337: LD_VAR 0 3
21341: PPUSH
21342: LD_INT 1
21344: PPUSH
21345: CALL_OW 275
21349: PUSH
21350: LD_VAR 0 4
21354: PUSH
21355: LD_INT 1
21357: ARRAY
21358: GREATEREQUAL
21359: PUSH
21360: LD_VAR 0 3
21364: PPUSH
21365: LD_INT 2
21367: PPUSH
21368: CALL_OW 275
21372: PUSH
21373: LD_VAR 0 4
21377: PUSH
21378: LD_INT 2
21380: ARRAY
21381: GREATEREQUAL
21382: AND
21383: PUSH
21384: LD_VAR 0 3
21388: PPUSH
21389: LD_INT 3
21391: PPUSH
21392: CALL_OW 275
21396: PUSH
21397: LD_VAR 0 4
21401: PUSH
21402: LD_INT 3
21404: ARRAY
21405: GREATEREQUAL
21406: AND
21407: ST_TO_ADDR
// end ;
21408: LD_VAR 0 2
21412: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21413: LD_INT 0
21415: PPUSH
21416: PPUSH
21417: PPUSH
// pom := GetBase ( building ) ;
21418: LD_ADDR_VAR 0 4
21422: PUSH
21423: LD_VAR 0 1
21427: PPUSH
21428: CALL_OW 274
21432: ST_TO_ADDR
// if not pom then
21433: LD_VAR 0 4
21437: NOT
21438: IFFALSE 21442
// exit ;
21440: GO 21543
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21442: LD_ADDR_VAR 0 5
21446: PUSH
21447: LD_VAR 0 2
21451: PPUSH
21452: LD_VAR 0 1
21456: PPUSH
21457: CALL_OW 248
21461: PPUSH
21462: CALL_OW 450
21466: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21467: LD_ADDR_VAR 0 3
21471: PUSH
21472: LD_VAR 0 4
21476: PPUSH
21477: LD_INT 1
21479: PPUSH
21480: CALL_OW 275
21484: PUSH
21485: LD_VAR 0 5
21489: PUSH
21490: LD_INT 1
21492: ARRAY
21493: GREATEREQUAL
21494: PUSH
21495: LD_VAR 0 4
21499: PPUSH
21500: LD_INT 2
21502: PPUSH
21503: CALL_OW 275
21507: PUSH
21508: LD_VAR 0 5
21512: PUSH
21513: LD_INT 2
21515: ARRAY
21516: GREATEREQUAL
21517: AND
21518: PUSH
21519: LD_VAR 0 4
21523: PPUSH
21524: LD_INT 3
21526: PPUSH
21527: CALL_OW 275
21531: PUSH
21532: LD_VAR 0 5
21536: PUSH
21537: LD_INT 3
21539: ARRAY
21540: GREATEREQUAL
21541: AND
21542: ST_TO_ADDR
// end ;
21543: LD_VAR 0 3
21547: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
21548: LD_INT 0
21550: PPUSH
21551: PPUSH
21552: PPUSH
21553: PPUSH
21554: PPUSH
21555: PPUSH
21556: PPUSH
21557: PPUSH
21558: PPUSH
21559: PPUSH
// result := false ;
21560: LD_ADDR_VAR 0 6
21564: PUSH
21565: LD_INT 0
21567: ST_TO_ADDR
// if not base or not btype or not x or not y then
21568: LD_VAR 0 1
21572: NOT
21573: PUSH
21574: LD_VAR 0 2
21578: NOT
21579: OR
21580: PUSH
21581: LD_VAR 0 3
21585: NOT
21586: OR
21587: PUSH
21588: LD_VAR 0 4
21592: NOT
21593: OR
21594: IFFALSE 21598
// exit ;
21596: GO 22207
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
21598: LD_ADDR_VAR 0 12
21602: PUSH
21603: LD_VAR 0 2
21607: PPUSH
21608: LD_VAR 0 3
21612: PPUSH
21613: LD_VAR 0 4
21617: PPUSH
21618: LD_VAR 0 5
21622: PPUSH
21623: LD_VAR 0 1
21627: PUSH
21628: LD_INT 1
21630: ARRAY
21631: PPUSH
21632: CALL_OW 248
21636: PPUSH
21637: LD_INT 0
21639: PPUSH
21640: CALL 23044 0 6
21644: ST_TO_ADDR
// if not hexes then
21645: LD_VAR 0 12
21649: NOT
21650: IFFALSE 21654
// exit ;
21652: GO 22207
// for i = 1 to hexes do
21654: LD_ADDR_VAR 0 7
21658: PUSH
21659: DOUBLE
21660: LD_INT 1
21662: DEC
21663: ST_TO_ADDR
21664: LD_VAR 0 12
21668: PUSH
21669: FOR_TO
21670: IFFALSE 22205
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21672: LD_ADDR_VAR 0 11
21676: PUSH
21677: LD_VAR 0 12
21681: PUSH
21682: LD_VAR 0 7
21686: ARRAY
21687: PUSH
21688: LD_INT 1
21690: ARRAY
21691: PPUSH
21692: LD_VAR 0 12
21696: PUSH
21697: LD_VAR 0 7
21701: ARRAY
21702: PUSH
21703: LD_INT 2
21705: ARRAY
21706: PPUSH
21707: CALL_OW 428
21711: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21712: LD_VAR 0 12
21716: PUSH
21717: LD_VAR 0 7
21721: ARRAY
21722: PUSH
21723: LD_INT 1
21725: ARRAY
21726: PPUSH
21727: LD_VAR 0 12
21731: PUSH
21732: LD_VAR 0 7
21736: ARRAY
21737: PUSH
21738: LD_INT 2
21740: ARRAY
21741: PPUSH
21742: CALL_OW 351
21746: PUSH
21747: LD_VAR 0 12
21751: PUSH
21752: LD_VAR 0 7
21756: ARRAY
21757: PUSH
21758: LD_INT 1
21760: ARRAY
21761: PPUSH
21762: LD_VAR 0 12
21766: PUSH
21767: LD_VAR 0 7
21771: ARRAY
21772: PUSH
21773: LD_INT 2
21775: ARRAY
21776: PPUSH
21777: CALL_OW 488
21781: NOT
21782: OR
21783: PUSH
21784: LD_VAR 0 11
21788: PPUSH
21789: CALL_OW 247
21793: PUSH
21794: LD_INT 3
21796: EQUAL
21797: OR
21798: IFFALSE 21804
// exit ;
21800: POP
21801: POP
21802: GO 22207
// if not tmp or not tmp in base then
21804: LD_VAR 0 11
21808: NOT
21809: PUSH
21810: LD_VAR 0 11
21814: PUSH
21815: LD_VAR 0 1
21819: IN
21820: NOT
21821: OR
21822: IFFALSE 21826
// continue ;
21824: GO 21669
// result := true ;
21826: LD_ADDR_VAR 0 6
21830: PUSH
21831: LD_INT 1
21833: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21834: LD_ADDR_VAR 0 15
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: LD_INT 22
21846: PUSH
21847: LD_VAR 0 11
21851: PPUSH
21852: CALL_OW 255
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: PUSH
21861: LD_INT 2
21863: PUSH
21864: LD_INT 30
21866: PUSH
21867: LD_INT 0
21869: PUSH
21870: EMPTY
21871: LIST
21872: LIST
21873: PUSH
21874: LD_INT 30
21876: PUSH
21877: LD_INT 1
21879: PUSH
21880: EMPTY
21881: LIST
21882: LIST
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: LIST
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: PPUSH
21893: CALL_OW 72
21897: ST_TO_ADDR
// if dep then
21898: LD_VAR 0 15
21902: IFFALSE 22038
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21904: LD_ADDR_VAR 0 14
21908: PUSH
21909: LD_VAR 0 15
21913: PUSH
21914: LD_INT 1
21916: ARRAY
21917: PPUSH
21918: CALL_OW 250
21922: PPUSH
21923: LD_VAR 0 15
21927: PUSH
21928: LD_INT 1
21930: ARRAY
21931: PPUSH
21932: CALL_OW 254
21936: PPUSH
21937: LD_INT 5
21939: PPUSH
21940: CALL_OW 272
21944: PUSH
21945: LD_VAR 0 15
21949: PUSH
21950: LD_INT 1
21952: ARRAY
21953: PPUSH
21954: CALL_OW 251
21958: PPUSH
21959: LD_VAR 0 15
21963: PUSH
21964: LD_INT 1
21966: ARRAY
21967: PPUSH
21968: CALL_OW 254
21972: PPUSH
21973: LD_INT 5
21975: PPUSH
21976: CALL_OW 273
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21985: LD_VAR 0 14
21989: PUSH
21990: LD_INT 1
21992: ARRAY
21993: PPUSH
21994: LD_VAR 0 14
21998: PUSH
21999: LD_INT 2
22001: ARRAY
22002: PPUSH
22003: CALL_OW 488
22007: IFFALSE 22038
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22009: LD_VAR 0 11
22013: PPUSH
22014: LD_VAR 0 14
22018: PUSH
22019: LD_INT 1
22021: ARRAY
22022: PPUSH
22023: LD_VAR 0 14
22027: PUSH
22028: LD_INT 2
22030: ARRAY
22031: PPUSH
22032: CALL_OW 111
// continue ;
22036: GO 21669
// end ; end ; r := GetDir ( tmp ) ;
22038: LD_ADDR_VAR 0 13
22042: PUSH
22043: LD_VAR 0 11
22047: PPUSH
22048: CALL_OW 254
22052: ST_TO_ADDR
// if r = 5 then
22053: LD_VAR 0 13
22057: PUSH
22058: LD_INT 5
22060: EQUAL
22061: IFFALSE 22071
// r := 0 ;
22063: LD_ADDR_VAR 0 13
22067: PUSH
22068: LD_INT 0
22070: ST_TO_ADDR
// for j = r to 5 do
22071: LD_ADDR_VAR 0 8
22075: PUSH
22076: DOUBLE
22077: LD_VAR 0 13
22081: DEC
22082: ST_TO_ADDR
22083: LD_INT 5
22085: PUSH
22086: FOR_TO
22087: IFFALSE 22201
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22089: LD_ADDR_VAR 0 9
22093: PUSH
22094: LD_VAR 0 11
22098: PPUSH
22099: CALL_OW 250
22103: PPUSH
22104: LD_VAR 0 8
22108: PPUSH
22109: LD_INT 2
22111: PPUSH
22112: CALL_OW 272
22116: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22117: LD_ADDR_VAR 0 10
22121: PUSH
22122: LD_VAR 0 11
22126: PPUSH
22127: CALL_OW 251
22131: PPUSH
22132: LD_VAR 0 8
22136: PPUSH
22137: LD_INT 2
22139: PPUSH
22140: CALL_OW 273
22144: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22145: LD_VAR 0 9
22149: PPUSH
22150: LD_VAR 0 10
22154: PPUSH
22155: CALL_OW 488
22159: PUSH
22160: LD_VAR 0 9
22164: PPUSH
22165: LD_VAR 0 10
22169: PPUSH
22170: CALL_OW 428
22174: NOT
22175: AND
22176: IFFALSE 22199
// begin ComMoveXY ( tmp , _x , _y ) ;
22178: LD_VAR 0 11
22182: PPUSH
22183: LD_VAR 0 9
22187: PPUSH
22188: LD_VAR 0 10
22192: PPUSH
22193: CALL_OW 111
// break ;
22197: GO 22201
// end ; end ;
22199: GO 22086
22201: POP
22202: POP
// end ;
22203: GO 21669
22205: POP
22206: POP
// end ;
22207: LD_VAR 0 6
22211: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22212: LD_INT 0
22214: PPUSH
22215: PPUSH
22216: PPUSH
22217: PPUSH
22218: PPUSH
22219: PPUSH
22220: PPUSH
22221: PPUSH
22222: PPUSH
22223: PPUSH
// result := false ;
22224: LD_ADDR_VAR 0 6
22228: PUSH
22229: LD_INT 0
22231: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22232: LD_VAR 0 1
22236: NOT
22237: PUSH
22238: LD_VAR 0 1
22242: PPUSH
22243: CALL_OW 266
22247: PUSH
22248: LD_INT 0
22250: PUSH
22251: LD_INT 1
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: IN
22258: NOT
22259: OR
22260: PUSH
22261: LD_VAR 0 2
22265: NOT
22266: OR
22267: PUSH
22268: LD_VAR 0 5
22272: PUSH
22273: LD_INT 0
22275: PUSH
22276: LD_INT 1
22278: PUSH
22279: LD_INT 2
22281: PUSH
22282: LD_INT 3
22284: PUSH
22285: LD_INT 4
22287: PUSH
22288: LD_INT 5
22290: PUSH
22291: EMPTY
22292: LIST
22293: LIST
22294: LIST
22295: LIST
22296: LIST
22297: LIST
22298: IN
22299: NOT
22300: OR
22301: PUSH
22302: LD_VAR 0 3
22306: PPUSH
22307: LD_VAR 0 4
22311: PPUSH
22312: CALL_OW 488
22316: NOT
22317: OR
22318: IFFALSE 22322
// exit ;
22320: GO 23039
// pom := GetBase ( depot ) ;
22322: LD_ADDR_VAR 0 10
22326: PUSH
22327: LD_VAR 0 1
22331: PPUSH
22332: CALL_OW 274
22336: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22337: LD_ADDR_VAR 0 11
22341: PUSH
22342: LD_VAR 0 2
22346: PPUSH
22347: LD_VAR 0 1
22351: PPUSH
22352: CALL_OW 248
22356: PPUSH
22357: CALL_OW 450
22361: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22362: LD_VAR 0 10
22366: PPUSH
22367: LD_INT 1
22369: PPUSH
22370: CALL_OW 275
22374: PUSH
22375: LD_VAR 0 11
22379: PUSH
22380: LD_INT 1
22382: ARRAY
22383: GREATEREQUAL
22384: PUSH
22385: LD_VAR 0 10
22389: PPUSH
22390: LD_INT 2
22392: PPUSH
22393: CALL_OW 275
22397: PUSH
22398: LD_VAR 0 11
22402: PUSH
22403: LD_INT 2
22405: ARRAY
22406: GREATEREQUAL
22407: AND
22408: PUSH
22409: LD_VAR 0 10
22413: PPUSH
22414: LD_INT 3
22416: PPUSH
22417: CALL_OW 275
22421: PUSH
22422: LD_VAR 0 11
22426: PUSH
22427: LD_INT 3
22429: ARRAY
22430: GREATEREQUAL
22431: AND
22432: NOT
22433: IFFALSE 22437
// exit ;
22435: GO 23039
// if GetBType ( depot ) = b_depot then
22437: LD_VAR 0 1
22441: PPUSH
22442: CALL_OW 266
22446: PUSH
22447: LD_INT 0
22449: EQUAL
22450: IFFALSE 22462
// dist := 28 else
22452: LD_ADDR_VAR 0 14
22456: PUSH
22457: LD_INT 28
22459: ST_TO_ADDR
22460: GO 22470
// dist := 36 ;
22462: LD_ADDR_VAR 0 14
22466: PUSH
22467: LD_INT 36
22469: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22470: LD_VAR 0 1
22474: PPUSH
22475: LD_VAR 0 3
22479: PPUSH
22480: LD_VAR 0 4
22484: PPUSH
22485: CALL_OW 297
22489: PUSH
22490: LD_VAR 0 14
22494: GREATER
22495: IFFALSE 22499
// exit ;
22497: GO 23039
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22499: LD_ADDR_VAR 0 12
22503: PUSH
22504: LD_VAR 0 2
22508: PPUSH
22509: LD_VAR 0 3
22513: PPUSH
22514: LD_VAR 0 4
22518: PPUSH
22519: LD_VAR 0 5
22523: PPUSH
22524: LD_VAR 0 1
22528: PPUSH
22529: CALL_OW 248
22533: PPUSH
22534: LD_INT 0
22536: PPUSH
22537: CALL 23044 0 6
22541: ST_TO_ADDR
// if not hexes then
22542: LD_VAR 0 12
22546: NOT
22547: IFFALSE 22551
// exit ;
22549: GO 23039
// hex := GetHexInfo ( x , y ) ;
22551: LD_ADDR_VAR 0 15
22555: PUSH
22556: LD_VAR 0 3
22560: PPUSH
22561: LD_VAR 0 4
22565: PPUSH
22566: CALL_OW 546
22570: ST_TO_ADDR
// if hex [ 1 ] then
22571: LD_VAR 0 15
22575: PUSH
22576: LD_INT 1
22578: ARRAY
22579: IFFALSE 22583
// exit ;
22581: GO 23039
// height := hex [ 2 ] ;
22583: LD_ADDR_VAR 0 13
22587: PUSH
22588: LD_VAR 0 15
22592: PUSH
22593: LD_INT 2
22595: ARRAY
22596: ST_TO_ADDR
// for i = 1 to hexes do
22597: LD_ADDR_VAR 0 7
22601: PUSH
22602: DOUBLE
22603: LD_INT 1
22605: DEC
22606: ST_TO_ADDR
22607: LD_VAR 0 12
22611: PUSH
22612: FOR_TO
22613: IFFALSE 22943
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22615: LD_VAR 0 12
22619: PUSH
22620: LD_VAR 0 7
22624: ARRAY
22625: PUSH
22626: LD_INT 1
22628: ARRAY
22629: PPUSH
22630: LD_VAR 0 12
22634: PUSH
22635: LD_VAR 0 7
22639: ARRAY
22640: PUSH
22641: LD_INT 2
22643: ARRAY
22644: PPUSH
22645: CALL_OW 488
22649: NOT
22650: PUSH
22651: LD_VAR 0 12
22655: PUSH
22656: LD_VAR 0 7
22660: ARRAY
22661: PUSH
22662: LD_INT 1
22664: ARRAY
22665: PPUSH
22666: LD_VAR 0 12
22670: PUSH
22671: LD_VAR 0 7
22675: ARRAY
22676: PUSH
22677: LD_INT 2
22679: ARRAY
22680: PPUSH
22681: CALL_OW 428
22685: PUSH
22686: LD_INT 0
22688: GREATER
22689: OR
22690: PUSH
22691: LD_VAR 0 12
22695: PUSH
22696: LD_VAR 0 7
22700: ARRAY
22701: PUSH
22702: LD_INT 1
22704: ARRAY
22705: PPUSH
22706: LD_VAR 0 12
22710: PUSH
22711: LD_VAR 0 7
22715: ARRAY
22716: PUSH
22717: LD_INT 2
22719: ARRAY
22720: PPUSH
22721: CALL_OW 351
22725: OR
22726: IFFALSE 22732
// exit ;
22728: POP
22729: POP
22730: GO 23039
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22732: LD_ADDR_VAR 0 8
22736: PUSH
22737: LD_VAR 0 12
22741: PUSH
22742: LD_VAR 0 7
22746: ARRAY
22747: PUSH
22748: LD_INT 1
22750: ARRAY
22751: PPUSH
22752: LD_VAR 0 12
22756: PUSH
22757: LD_VAR 0 7
22761: ARRAY
22762: PUSH
22763: LD_INT 2
22765: ARRAY
22766: PPUSH
22767: CALL_OW 546
22771: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22772: LD_VAR 0 8
22776: PUSH
22777: LD_INT 1
22779: ARRAY
22780: PUSH
22781: LD_VAR 0 8
22785: PUSH
22786: LD_INT 2
22788: ARRAY
22789: PUSH
22790: LD_VAR 0 13
22794: PUSH
22795: LD_INT 2
22797: PLUS
22798: GREATER
22799: OR
22800: PUSH
22801: LD_VAR 0 8
22805: PUSH
22806: LD_INT 2
22808: ARRAY
22809: PUSH
22810: LD_VAR 0 13
22814: PUSH
22815: LD_INT 2
22817: MINUS
22818: LESS
22819: OR
22820: PUSH
22821: LD_VAR 0 8
22825: PUSH
22826: LD_INT 3
22828: ARRAY
22829: PUSH
22830: LD_INT 0
22832: PUSH
22833: LD_INT 8
22835: PUSH
22836: LD_INT 9
22838: PUSH
22839: LD_INT 10
22841: PUSH
22842: LD_INT 11
22844: PUSH
22845: LD_INT 12
22847: PUSH
22848: LD_INT 13
22850: PUSH
22851: LD_INT 16
22853: PUSH
22854: LD_INT 17
22856: PUSH
22857: LD_INT 18
22859: PUSH
22860: LD_INT 19
22862: PUSH
22863: LD_INT 20
22865: PUSH
22866: LD_INT 21
22868: PUSH
22869: EMPTY
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: LIST
22882: LIST
22883: IN
22884: NOT
22885: OR
22886: PUSH
22887: LD_VAR 0 8
22891: PUSH
22892: LD_INT 5
22894: ARRAY
22895: NOT
22896: OR
22897: PUSH
22898: LD_VAR 0 8
22902: PUSH
22903: LD_INT 6
22905: ARRAY
22906: PUSH
22907: LD_INT 1
22909: PUSH
22910: LD_INT 2
22912: PUSH
22913: LD_INT 7
22915: PUSH
22916: LD_INT 9
22918: PUSH
22919: LD_INT 10
22921: PUSH
22922: LD_INT 11
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: IN
22933: NOT
22934: OR
22935: IFFALSE 22941
// exit ;
22937: POP
22938: POP
22939: GO 23039
// end ;
22941: GO 22612
22943: POP
22944: POP
// side := GetSide ( depot ) ;
22945: LD_ADDR_VAR 0 9
22949: PUSH
22950: LD_VAR 0 1
22954: PPUSH
22955: CALL_OW 255
22959: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22960: LD_VAR 0 9
22964: PPUSH
22965: LD_VAR 0 3
22969: PPUSH
22970: LD_VAR 0 4
22974: PPUSH
22975: LD_INT 20
22977: PPUSH
22978: CALL 15693 0 4
22982: PUSH
22983: LD_INT 4
22985: ARRAY
22986: IFFALSE 22990
// exit ;
22988: GO 23039
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22990: LD_VAR 0 2
22994: PUSH
22995: LD_INT 29
22997: PUSH
22998: LD_INT 30
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: IN
23005: PUSH
23006: LD_VAR 0 3
23010: PPUSH
23011: LD_VAR 0 4
23015: PPUSH
23016: LD_VAR 0 9
23020: PPUSH
23021: CALL_OW 440
23025: NOT
23026: AND
23027: IFFALSE 23031
// exit ;
23029: GO 23039
// result := true ;
23031: LD_ADDR_VAR 0 6
23035: PUSH
23036: LD_INT 1
23038: ST_TO_ADDR
// end ;
23039: LD_VAR 0 6
23043: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23044: LD_INT 0
23046: PPUSH
23047: PPUSH
23048: PPUSH
23049: PPUSH
23050: PPUSH
23051: PPUSH
23052: PPUSH
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
23065: PPUSH
23066: PPUSH
23067: PPUSH
23068: PPUSH
23069: PPUSH
23070: PPUSH
23071: PPUSH
23072: PPUSH
23073: PPUSH
23074: PPUSH
23075: PPUSH
23076: PPUSH
23077: PPUSH
23078: PPUSH
23079: PPUSH
23080: PPUSH
23081: PPUSH
23082: PPUSH
23083: PPUSH
23084: PPUSH
23085: PPUSH
23086: PPUSH
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
// result = [ ] ;
23104: LD_ADDR_VAR 0 7
23108: PUSH
23109: EMPTY
23110: ST_TO_ADDR
// temp_list = [ ] ;
23111: LD_ADDR_VAR 0 9
23115: PUSH
23116: EMPTY
23117: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23118: LD_VAR 0 4
23122: PUSH
23123: LD_INT 0
23125: PUSH
23126: LD_INT 1
23128: PUSH
23129: LD_INT 2
23131: PUSH
23132: LD_INT 3
23134: PUSH
23135: LD_INT 4
23137: PUSH
23138: LD_INT 5
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: LIST
23147: LIST
23148: IN
23149: NOT
23150: PUSH
23151: LD_VAR 0 1
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 1
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: IN
23166: PUSH
23167: LD_VAR 0 5
23171: PUSH
23172: LD_INT 1
23174: PUSH
23175: LD_INT 2
23177: PUSH
23178: LD_INT 3
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: LIST
23185: IN
23186: NOT
23187: AND
23188: OR
23189: IFFALSE 23193
// exit ;
23191: GO 41584
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23193: LD_VAR 0 1
23197: PUSH
23198: LD_INT 6
23200: PUSH
23201: LD_INT 7
23203: PUSH
23204: LD_INT 8
23206: PUSH
23207: LD_INT 13
23209: PUSH
23210: LD_INT 12
23212: PUSH
23213: LD_INT 15
23215: PUSH
23216: LD_INT 11
23218: PUSH
23219: LD_INT 14
23221: PUSH
23222: LD_INT 10
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: LIST
23235: IN
23236: IFFALSE 23246
// btype = b_lab ;
23238: LD_ADDR_VAR 0 1
23242: PUSH
23243: LD_INT 6
23245: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23246: LD_VAR 0 6
23250: PUSH
23251: LD_INT 0
23253: PUSH
23254: LD_INT 1
23256: PUSH
23257: LD_INT 2
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: LIST
23264: IN
23265: NOT
23266: PUSH
23267: LD_VAR 0 1
23271: PUSH
23272: LD_INT 0
23274: PUSH
23275: LD_INT 1
23277: PUSH
23278: LD_INT 2
23280: PUSH
23281: LD_INT 3
23283: PUSH
23284: LD_INT 6
23286: PUSH
23287: LD_INT 36
23289: PUSH
23290: LD_INT 4
23292: PUSH
23293: LD_INT 5
23295: PUSH
23296: LD_INT 31
23298: PUSH
23299: LD_INT 32
23301: PUSH
23302: LD_INT 33
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: LIST
23309: LIST
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: IN
23318: NOT
23319: PUSH
23320: LD_VAR 0 6
23324: PUSH
23325: LD_INT 1
23327: EQUAL
23328: AND
23329: OR
23330: PUSH
23331: LD_VAR 0 1
23335: PUSH
23336: LD_INT 2
23338: PUSH
23339: LD_INT 3
23341: PUSH
23342: EMPTY
23343: LIST
23344: LIST
23345: IN
23346: NOT
23347: PUSH
23348: LD_VAR 0 6
23352: PUSH
23353: LD_INT 2
23355: EQUAL
23356: AND
23357: OR
23358: IFFALSE 23368
// mode = 0 ;
23360: LD_ADDR_VAR 0 6
23364: PUSH
23365: LD_INT 0
23367: ST_TO_ADDR
// case mode of 0 :
23368: LD_VAR 0 6
23372: PUSH
23373: LD_INT 0
23375: DOUBLE
23376: EQUAL
23377: IFTRUE 23381
23379: GO 34834
23381: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23382: LD_ADDR_VAR 0 11
23386: PUSH
23387: LD_INT 0
23389: PUSH
23390: LD_INT 0
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PUSH
23397: LD_INT 0
23399: PUSH
23400: LD_INT 1
23402: NEG
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: LD_INT 1
23410: PUSH
23411: LD_INT 0
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: PUSH
23418: LD_INT 1
23420: PUSH
23421: LD_INT 1
23423: PUSH
23424: EMPTY
23425: LIST
23426: LIST
23427: PUSH
23428: LD_INT 0
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: PUSH
23438: LD_INT 1
23440: NEG
23441: PUSH
23442: LD_INT 0
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: PUSH
23449: LD_INT 1
23451: NEG
23452: PUSH
23453: LD_INT 1
23455: NEG
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PUSH
23461: LD_INT 1
23463: NEG
23464: PUSH
23465: LD_INT 2
23467: NEG
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: PUSH
23473: LD_INT 0
23475: PUSH
23476: LD_INT 2
23478: NEG
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: PUSH
23484: LD_INT 1
23486: PUSH
23487: LD_INT 1
23489: NEG
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: PUSH
23495: LD_INT 1
23497: PUSH
23498: LD_INT 2
23500: PUSH
23501: EMPTY
23502: LIST
23503: LIST
23504: PUSH
23505: LD_INT 0
23507: PUSH
23508: LD_INT 2
23510: PUSH
23511: EMPTY
23512: LIST
23513: LIST
23514: PUSH
23515: LD_INT 1
23517: NEG
23518: PUSH
23519: LD_INT 1
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: PUSH
23526: LD_INT 1
23528: PUSH
23529: LD_INT 3
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: LD_INT 0
23538: PUSH
23539: LD_INT 3
23541: PUSH
23542: EMPTY
23543: LIST
23544: LIST
23545: PUSH
23546: LD_INT 1
23548: NEG
23549: PUSH
23550: LD_INT 2
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: LIST
23561: LIST
23562: LIST
23563: LIST
23564: LIST
23565: LIST
23566: LIST
23567: LIST
23568: LIST
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23575: LD_ADDR_VAR 0 12
23579: PUSH
23580: LD_INT 0
23582: PUSH
23583: LD_INT 0
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: PUSH
23590: LD_INT 0
23592: PUSH
23593: LD_INT 1
23595: NEG
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 1
23603: PUSH
23604: LD_INT 0
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: PUSH
23611: LD_INT 1
23613: PUSH
23614: LD_INT 1
23616: PUSH
23617: EMPTY
23618: LIST
23619: LIST
23620: PUSH
23621: LD_INT 0
23623: PUSH
23624: LD_INT 1
23626: PUSH
23627: EMPTY
23628: LIST
23629: LIST
23630: PUSH
23631: LD_INT 1
23633: NEG
23634: PUSH
23635: LD_INT 0
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: LD_INT 1
23644: NEG
23645: PUSH
23646: LD_INT 1
23648: NEG
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 1
23656: PUSH
23657: LD_INT 1
23659: NEG
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 2
23667: PUSH
23668: LD_INT 0
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: LD_INT 2
23677: PUSH
23678: LD_INT 1
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: PUSH
23685: LD_INT 1
23687: NEG
23688: PUSH
23689: LD_INT 1
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: PUSH
23696: LD_INT 2
23698: NEG
23699: PUSH
23700: LD_INT 0
23702: PUSH
23703: EMPTY
23704: LIST
23705: LIST
23706: PUSH
23707: LD_INT 2
23709: NEG
23710: PUSH
23711: LD_INT 1
23713: NEG
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 2
23721: NEG
23722: PUSH
23723: LD_INT 1
23725: PUSH
23726: EMPTY
23727: LIST
23728: LIST
23729: PUSH
23730: LD_INT 3
23732: NEG
23733: PUSH
23734: LD_INT 0
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: PUSH
23741: LD_INT 3
23743: NEG
23744: PUSH
23745: LD_INT 1
23747: NEG
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: LIST
23757: LIST
23758: LIST
23759: LIST
23760: LIST
23761: LIST
23762: LIST
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: LIST
23768: LIST
23769: LIST
23770: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23771: LD_ADDR_VAR 0 13
23775: PUSH
23776: LD_INT 0
23778: PUSH
23779: LD_INT 0
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: PUSH
23786: LD_INT 0
23788: PUSH
23789: LD_INT 1
23791: NEG
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 1
23799: PUSH
23800: LD_INT 0
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: LD_INT 1
23809: PUSH
23810: LD_INT 1
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 0
23819: PUSH
23820: LD_INT 1
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: LD_INT 1
23829: NEG
23830: PUSH
23831: LD_INT 0
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PUSH
23838: LD_INT 1
23840: NEG
23841: PUSH
23842: LD_INT 1
23844: NEG
23845: PUSH
23846: EMPTY
23847: LIST
23848: LIST
23849: PUSH
23850: LD_INT 1
23852: NEG
23853: PUSH
23854: LD_INT 2
23856: NEG
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 2
23864: PUSH
23865: LD_INT 1
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: LD_INT 2
23874: PUSH
23875: LD_INT 2
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PUSH
23882: LD_INT 1
23884: PUSH
23885: LD_INT 2
23887: PUSH
23888: EMPTY
23889: LIST
23890: LIST
23891: PUSH
23892: LD_INT 2
23894: NEG
23895: PUSH
23896: LD_INT 1
23898: NEG
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PUSH
23904: LD_INT 2
23906: NEG
23907: PUSH
23908: LD_INT 2
23910: NEG
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: PUSH
23916: LD_INT 2
23918: NEG
23919: PUSH
23920: LD_INT 3
23922: NEG
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 3
23930: NEG
23931: PUSH
23932: LD_INT 2
23934: NEG
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: PUSH
23940: LD_INT 3
23942: NEG
23943: PUSH
23944: LD_INT 3
23946: NEG
23947: PUSH
23948: EMPTY
23949: LIST
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: LIST
23957: LIST
23958: LIST
23959: LIST
23960: LIST
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23970: LD_ADDR_VAR 0 14
23974: PUSH
23975: LD_INT 0
23977: PUSH
23978: LD_INT 0
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PUSH
23985: LD_INT 0
23987: PUSH
23988: LD_INT 1
23990: NEG
23991: PUSH
23992: EMPTY
23993: LIST
23994: LIST
23995: PUSH
23996: LD_INT 1
23998: PUSH
23999: LD_INT 0
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: PUSH
24006: LD_INT 1
24008: PUSH
24009: LD_INT 1
24011: PUSH
24012: EMPTY
24013: LIST
24014: LIST
24015: PUSH
24016: LD_INT 0
24018: PUSH
24019: LD_INT 1
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: PUSH
24026: LD_INT 1
24028: NEG
24029: PUSH
24030: LD_INT 0
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 1
24039: NEG
24040: PUSH
24041: LD_INT 1
24043: NEG
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PUSH
24049: LD_INT 1
24051: NEG
24052: PUSH
24053: LD_INT 2
24055: NEG
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 0
24063: PUSH
24064: LD_INT 2
24066: NEG
24067: PUSH
24068: EMPTY
24069: LIST
24070: LIST
24071: PUSH
24072: LD_INT 1
24074: PUSH
24075: LD_INT 1
24077: NEG
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: PUSH
24083: LD_INT 1
24085: PUSH
24086: LD_INT 2
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: PUSH
24093: LD_INT 0
24095: PUSH
24096: LD_INT 2
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: PUSH
24103: LD_INT 1
24105: NEG
24106: PUSH
24107: LD_INT 1
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: LD_INT 1
24116: NEG
24117: PUSH
24118: LD_INT 3
24120: NEG
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: LD_INT 0
24128: PUSH
24129: LD_INT 3
24131: NEG
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 1
24139: PUSH
24140: LD_INT 2
24142: NEG
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: LIST
24153: LIST
24154: LIST
24155: LIST
24156: LIST
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24166: LD_ADDR_VAR 0 15
24170: PUSH
24171: LD_INT 0
24173: PUSH
24174: LD_INT 0
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_INT 1
24186: NEG
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: LD_INT 1
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: PUSH
24202: LD_INT 1
24204: PUSH
24205: LD_INT 1
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PUSH
24212: LD_INT 0
24214: PUSH
24215: LD_INT 1
24217: PUSH
24218: EMPTY
24219: LIST
24220: LIST
24221: PUSH
24222: LD_INT 1
24224: NEG
24225: PUSH
24226: LD_INT 0
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: PUSH
24233: LD_INT 1
24235: NEG
24236: PUSH
24237: LD_INT 1
24239: NEG
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PUSH
24245: LD_INT 1
24247: PUSH
24248: LD_INT 1
24250: NEG
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: LD_INT 2
24258: PUSH
24259: LD_INT 0
24261: PUSH
24262: EMPTY
24263: LIST
24264: LIST
24265: PUSH
24266: LD_INT 2
24268: PUSH
24269: LD_INT 1
24271: PUSH
24272: EMPTY
24273: LIST
24274: LIST
24275: PUSH
24276: LD_INT 1
24278: NEG
24279: PUSH
24280: LD_INT 1
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: PUSH
24287: LD_INT 2
24289: NEG
24290: PUSH
24291: LD_INT 0
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: LD_INT 2
24300: NEG
24301: PUSH
24302: LD_INT 1
24304: NEG
24305: PUSH
24306: EMPTY
24307: LIST
24308: LIST
24309: PUSH
24310: LD_INT 2
24312: PUSH
24313: LD_INT 1
24315: NEG
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: LD_INT 3
24323: PUSH
24324: LD_INT 0
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PUSH
24331: LD_INT 3
24333: PUSH
24334: LD_INT 1
24336: PUSH
24337: EMPTY
24338: LIST
24339: LIST
24340: PUSH
24341: EMPTY
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24359: LD_ADDR_VAR 0 16
24363: PUSH
24364: LD_INT 0
24366: PUSH
24367: LD_INT 0
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PUSH
24374: LD_INT 0
24376: PUSH
24377: LD_INT 1
24379: NEG
24380: PUSH
24381: EMPTY
24382: LIST
24383: LIST
24384: PUSH
24385: LD_INT 1
24387: PUSH
24388: LD_INT 0
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PUSH
24395: LD_INT 1
24397: PUSH
24398: LD_INT 1
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: LD_INT 0
24407: PUSH
24408: LD_INT 1
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: PUSH
24415: LD_INT 1
24417: NEG
24418: PUSH
24419: LD_INT 0
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 1
24428: NEG
24429: PUSH
24430: LD_INT 1
24432: NEG
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 1
24440: NEG
24441: PUSH
24442: LD_INT 2
24444: NEG
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: LD_INT 2
24452: PUSH
24453: LD_INT 1
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: PUSH
24460: LD_INT 2
24462: PUSH
24463: LD_INT 2
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: PUSH
24470: LD_INT 1
24472: PUSH
24473: LD_INT 2
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PUSH
24480: LD_INT 2
24482: NEG
24483: PUSH
24484: LD_INT 1
24486: NEG
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: LD_INT 2
24494: NEG
24495: PUSH
24496: LD_INT 2
24498: NEG
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 3
24506: PUSH
24507: LD_INT 2
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 3
24516: PUSH
24517: LD_INT 3
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 2
24526: PUSH
24527: LD_INT 3
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: LIST
24540: LIST
24541: LIST
24542: LIST
24543: LIST
24544: LIST
24545: LIST
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24552: LD_ADDR_VAR 0 17
24556: PUSH
24557: LD_INT 0
24559: PUSH
24560: LD_INT 0
24562: PUSH
24563: EMPTY
24564: LIST
24565: LIST
24566: PUSH
24567: LD_INT 0
24569: PUSH
24570: LD_INT 1
24572: NEG
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 1
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: LD_INT 1
24590: PUSH
24591: LD_INT 1
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: LD_INT 0
24600: PUSH
24601: LD_INT 1
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: LD_INT 1
24610: NEG
24611: PUSH
24612: LD_INT 0
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: PUSH
24619: LD_INT 1
24621: NEG
24622: PUSH
24623: LD_INT 1
24625: NEG
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 1
24633: NEG
24634: PUSH
24635: LD_INT 2
24637: NEG
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 0
24645: PUSH
24646: LD_INT 2
24648: NEG
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 1
24656: PUSH
24657: LD_INT 1
24659: NEG
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PUSH
24665: LD_INT 2
24667: PUSH
24668: LD_INT 0
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PUSH
24675: LD_INT 2
24677: PUSH
24678: LD_INT 1
24680: PUSH
24681: EMPTY
24682: LIST
24683: LIST
24684: PUSH
24685: LD_INT 2
24687: PUSH
24688: LD_INT 2
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: PUSH
24695: LD_INT 1
24697: PUSH
24698: LD_INT 2
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 0
24707: PUSH
24708: LD_INT 2
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: LD_INT 1
24717: NEG
24718: PUSH
24719: LD_INT 1
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PUSH
24726: LD_INT 2
24728: NEG
24729: PUSH
24730: LD_INT 0
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: PUSH
24737: LD_INT 2
24739: NEG
24740: PUSH
24741: LD_INT 1
24743: NEG
24744: PUSH
24745: EMPTY
24746: LIST
24747: LIST
24748: PUSH
24749: LD_INT 2
24751: NEG
24752: PUSH
24753: LD_INT 2
24755: NEG
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: LIST
24765: LIST
24766: LIST
24767: LIST
24768: LIST
24769: LIST
24770: LIST
24771: LIST
24772: LIST
24773: LIST
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24782: LD_ADDR_VAR 0 18
24786: PUSH
24787: LD_INT 0
24789: PUSH
24790: LD_INT 0
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: LD_INT 1
24802: NEG
24803: PUSH
24804: EMPTY
24805: LIST
24806: LIST
24807: PUSH
24808: LD_INT 1
24810: PUSH
24811: LD_INT 0
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: PUSH
24818: LD_INT 1
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 0
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: PUSH
24838: LD_INT 1
24840: NEG
24841: PUSH
24842: LD_INT 0
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: PUSH
24849: LD_INT 1
24851: NEG
24852: PUSH
24853: LD_INT 1
24855: NEG
24856: PUSH
24857: EMPTY
24858: LIST
24859: LIST
24860: PUSH
24861: LD_INT 1
24863: NEG
24864: PUSH
24865: LD_INT 2
24867: NEG
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 0
24875: PUSH
24876: LD_INT 2
24878: NEG
24879: PUSH
24880: EMPTY
24881: LIST
24882: LIST
24883: PUSH
24884: LD_INT 1
24886: PUSH
24887: LD_INT 1
24889: NEG
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 2
24897: PUSH
24898: LD_INT 0
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 2
24907: PUSH
24908: LD_INT 1
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: LD_INT 2
24917: PUSH
24918: LD_INT 2
24920: PUSH
24921: EMPTY
24922: LIST
24923: LIST
24924: PUSH
24925: LD_INT 1
24927: PUSH
24928: LD_INT 2
24930: PUSH
24931: EMPTY
24932: LIST
24933: LIST
24934: PUSH
24935: LD_INT 0
24937: PUSH
24938: LD_INT 2
24940: PUSH
24941: EMPTY
24942: LIST
24943: LIST
24944: PUSH
24945: LD_INT 1
24947: NEG
24948: PUSH
24949: LD_INT 1
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PUSH
24956: LD_INT 2
24958: NEG
24959: PUSH
24960: LD_INT 0
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: LD_INT 2
24969: NEG
24970: PUSH
24971: LD_INT 1
24973: NEG
24974: PUSH
24975: EMPTY
24976: LIST
24977: LIST
24978: PUSH
24979: LD_INT 2
24981: NEG
24982: PUSH
24983: LD_INT 2
24985: NEG
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: LIST
24995: LIST
24996: LIST
24997: LIST
24998: LIST
24999: LIST
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: LIST
25011: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25012: LD_ADDR_VAR 0 19
25016: PUSH
25017: LD_INT 0
25019: PUSH
25020: LD_INT 0
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: LD_INT 0
25029: PUSH
25030: LD_INT 1
25032: NEG
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 1
25040: PUSH
25041: LD_INT 0
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 1
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 0
25060: PUSH
25061: LD_INT 1
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: LD_INT 1
25070: NEG
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: LD_INT 1
25081: NEG
25082: PUSH
25083: LD_INT 1
25085: NEG
25086: PUSH
25087: EMPTY
25088: LIST
25089: LIST
25090: PUSH
25091: LD_INT 1
25093: NEG
25094: PUSH
25095: LD_INT 2
25097: NEG
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 0
25105: PUSH
25106: LD_INT 2
25108: NEG
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: PUSH
25114: LD_INT 1
25116: PUSH
25117: LD_INT 1
25119: NEG
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: LD_INT 2
25127: PUSH
25128: LD_INT 0
25130: PUSH
25131: EMPTY
25132: LIST
25133: LIST
25134: PUSH
25135: LD_INT 2
25137: PUSH
25138: LD_INT 1
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: PUSH
25145: LD_INT 2
25147: PUSH
25148: LD_INT 2
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: PUSH
25165: LD_INT 0
25167: PUSH
25168: LD_INT 2
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PUSH
25175: LD_INT 1
25177: NEG
25178: PUSH
25179: LD_INT 1
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 2
25188: NEG
25189: PUSH
25190: LD_INT 0
25192: PUSH
25193: EMPTY
25194: LIST
25195: LIST
25196: PUSH
25197: LD_INT 2
25199: NEG
25200: PUSH
25201: LD_INT 1
25203: NEG
25204: PUSH
25205: EMPTY
25206: LIST
25207: LIST
25208: PUSH
25209: LD_INT 2
25211: NEG
25212: PUSH
25213: LD_INT 2
25215: NEG
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25242: LD_ADDR_VAR 0 20
25246: PUSH
25247: LD_INT 0
25249: PUSH
25250: LD_INT 0
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 0
25259: PUSH
25260: LD_INT 1
25262: NEG
25263: PUSH
25264: EMPTY
25265: LIST
25266: LIST
25267: PUSH
25268: LD_INT 1
25270: PUSH
25271: LD_INT 0
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 1
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 1
25300: NEG
25301: PUSH
25302: LD_INT 0
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: NEG
25312: PUSH
25313: LD_INT 1
25315: NEG
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 1
25323: NEG
25324: PUSH
25325: LD_INT 2
25327: NEG
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: LD_INT 0
25335: PUSH
25336: LD_INT 2
25338: NEG
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PUSH
25344: LD_INT 1
25346: PUSH
25347: LD_INT 1
25349: NEG
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PUSH
25355: LD_INT 2
25357: PUSH
25358: LD_INT 0
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 2
25367: PUSH
25368: LD_INT 1
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: PUSH
25375: LD_INT 2
25377: PUSH
25378: LD_INT 2
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PUSH
25388: LD_INT 2
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PUSH
25395: LD_INT 0
25397: PUSH
25398: LD_INT 2
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: LD_INT 1
25407: NEG
25408: PUSH
25409: LD_INT 1
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 2
25418: NEG
25419: PUSH
25420: LD_INT 0
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 2
25429: NEG
25430: PUSH
25431: LD_INT 1
25433: NEG
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 2
25441: NEG
25442: PUSH
25443: LD_INT 2
25445: NEG
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: PUSH
25451: EMPTY
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25472: LD_ADDR_VAR 0 21
25476: PUSH
25477: LD_INT 0
25479: PUSH
25480: LD_INT 0
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: PUSH
25487: LD_INT 0
25489: PUSH
25490: LD_INT 1
25492: NEG
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 1
25500: PUSH
25501: LD_INT 0
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 1
25510: PUSH
25511: LD_INT 1
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 0
25520: PUSH
25521: LD_INT 1
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: PUSH
25528: LD_INT 1
25530: NEG
25531: PUSH
25532: LD_INT 0
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 1
25541: NEG
25542: PUSH
25543: LD_INT 1
25545: NEG
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: PUSH
25551: LD_INT 1
25553: NEG
25554: PUSH
25555: LD_INT 2
25557: NEG
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: PUSH
25563: LD_INT 0
25565: PUSH
25566: LD_INT 2
25568: NEG
25569: PUSH
25570: EMPTY
25571: LIST
25572: LIST
25573: PUSH
25574: LD_INT 1
25576: PUSH
25577: LD_INT 1
25579: NEG
25580: PUSH
25581: EMPTY
25582: LIST
25583: LIST
25584: PUSH
25585: LD_INT 2
25587: PUSH
25588: LD_INT 0
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: LD_INT 2
25597: PUSH
25598: LD_INT 1
25600: PUSH
25601: EMPTY
25602: LIST
25603: LIST
25604: PUSH
25605: LD_INT 2
25607: PUSH
25608: LD_INT 2
25610: PUSH
25611: EMPTY
25612: LIST
25613: LIST
25614: PUSH
25615: LD_INT 1
25617: PUSH
25618: LD_INT 2
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: LD_INT 0
25627: PUSH
25628: LD_INT 2
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: LD_INT 1
25637: NEG
25638: PUSH
25639: LD_INT 1
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PUSH
25646: LD_INT 2
25648: NEG
25649: PUSH
25650: LD_INT 0
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: PUSH
25657: LD_INT 2
25659: NEG
25660: PUSH
25661: LD_INT 1
25663: NEG
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: LD_INT 2
25671: NEG
25672: PUSH
25673: LD_INT 2
25675: NEG
25676: PUSH
25677: EMPTY
25678: LIST
25679: LIST
25680: PUSH
25681: EMPTY
25682: LIST
25683: LIST
25684: LIST
25685: LIST
25686: LIST
25687: LIST
25688: LIST
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: LIST
25694: LIST
25695: LIST
25696: LIST
25697: LIST
25698: LIST
25699: LIST
25700: LIST
25701: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25702: LD_ADDR_VAR 0 22
25706: PUSH
25707: LD_INT 0
25709: PUSH
25710: LD_INT 0
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: PUSH
25717: LD_INT 0
25719: PUSH
25720: LD_INT 1
25722: NEG
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 1
25730: PUSH
25731: LD_INT 0
25733: PUSH
25734: EMPTY
25735: LIST
25736: LIST
25737: PUSH
25738: LD_INT 1
25740: PUSH
25741: LD_INT 1
25743: PUSH
25744: EMPTY
25745: LIST
25746: LIST
25747: PUSH
25748: LD_INT 0
25750: PUSH
25751: LD_INT 1
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: PUSH
25758: LD_INT 1
25760: NEG
25761: PUSH
25762: LD_INT 0
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PUSH
25769: LD_INT 1
25771: NEG
25772: PUSH
25773: LD_INT 1
25775: NEG
25776: PUSH
25777: EMPTY
25778: LIST
25779: LIST
25780: PUSH
25781: LD_INT 1
25783: NEG
25784: PUSH
25785: LD_INT 2
25787: NEG
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 0
25795: PUSH
25796: LD_INT 2
25798: NEG
25799: PUSH
25800: EMPTY
25801: LIST
25802: LIST
25803: PUSH
25804: LD_INT 1
25806: PUSH
25807: LD_INT 1
25809: NEG
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: PUSH
25815: LD_INT 2
25817: PUSH
25818: LD_INT 0
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: PUSH
25825: LD_INT 2
25827: PUSH
25828: LD_INT 1
25830: PUSH
25831: EMPTY
25832: LIST
25833: LIST
25834: PUSH
25835: LD_INT 2
25837: PUSH
25838: LD_INT 2
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: PUSH
25845: LD_INT 1
25847: PUSH
25848: LD_INT 2
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: LD_INT 0
25857: PUSH
25858: LD_INT 2
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: LD_INT 1
25871: PUSH
25872: EMPTY
25873: LIST
25874: LIST
25875: PUSH
25876: LD_INT 2
25878: NEG
25879: PUSH
25880: LD_INT 0
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: LD_INT 2
25889: NEG
25890: PUSH
25891: LD_INT 1
25893: NEG
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PUSH
25899: LD_INT 2
25901: NEG
25902: PUSH
25903: LD_INT 2
25905: NEG
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: LIST
25915: LIST
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: LIST
25921: LIST
25922: LIST
25923: LIST
25924: LIST
25925: LIST
25926: LIST
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25932: LD_ADDR_VAR 0 23
25936: PUSH
25937: LD_INT 0
25939: PUSH
25940: LD_INT 0
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: PUSH
25947: LD_INT 0
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PUSH
25958: LD_INT 1
25960: PUSH
25961: LD_INT 0
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: PUSH
25968: LD_INT 1
25970: PUSH
25971: LD_INT 1
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: PUSH
25978: LD_INT 0
25980: PUSH
25981: LD_INT 1
25983: PUSH
25984: EMPTY
25985: LIST
25986: LIST
25987: PUSH
25988: LD_INT 1
25990: NEG
25991: PUSH
25992: LD_INT 0
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: PUSH
25999: LD_INT 1
26001: NEG
26002: PUSH
26003: LD_INT 1
26005: NEG
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: NEG
26014: PUSH
26015: LD_INT 2
26017: NEG
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 0
26025: PUSH
26026: LD_INT 2
26028: NEG
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 1
26036: PUSH
26037: LD_INT 1
26039: NEG
26040: PUSH
26041: EMPTY
26042: LIST
26043: LIST
26044: PUSH
26045: LD_INT 2
26047: PUSH
26048: LD_INT 0
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 2
26057: PUSH
26058: LD_INT 1
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: LD_INT 2
26067: PUSH
26068: LD_INT 2
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 1
26077: PUSH
26078: LD_INT 2
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 0
26087: PUSH
26088: LD_INT 2
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 1
26097: NEG
26098: PUSH
26099: LD_INT 1
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 2
26108: NEG
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: PUSH
26117: LD_INT 2
26119: NEG
26120: PUSH
26121: LD_INT 1
26123: NEG
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 2
26131: NEG
26132: PUSH
26133: LD_INT 2
26135: NEG
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PUSH
26141: LD_INT 2
26143: NEG
26144: PUSH
26145: LD_INT 3
26147: NEG
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: LD_INT 3
26159: NEG
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_INT 1
26167: PUSH
26168: LD_INT 2
26170: NEG
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 2
26178: PUSH
26179: LD_INT 1
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: LIST
26191: LIST
26192: LIST
26193: LIST
26194: LIST
26195: LIST
26196: LIST
26197: LIST
26198: LIST
26199: LIST
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26212: LD_ADDR_VAR 0 24
26216: PUSH
26217: LD_INT 0
26219: PUSH
26220: LD_INT 0
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: LD_INT 1
26232: NEG
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 1
26240: PUSH
26241: LD_INT 0
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 1
26250: PUSH
26251: LD_INT 1
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 0
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 1
26270: NEG
26271: PUSH
26272: LD_INT 0
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 1
26281: NEG
26282: PUSH
26283: LD_INT 1
26285: NEG
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: LD_INT 2
26297: NEG
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: PUSH
26303: LD_INT 0
26305: PUSH
26306: LD_INT 2
26308: NEG
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 1
26316: PUSH
26317: LD_INT 1
26319: NEG
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: LD_INT 2
26327: PUSH
26328: LD_INT 0
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 1
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: LD_INT 2
26347: PUSH
26348: LD_INT 2
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 1
26357: PUSH
26358: LD_INT 2
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: PUSH
26365: LD_INT 0
26367: PUSH
26368: LD_INT 2
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 1
26377: NEG
26378: PUSH
26379: LD_INT 1
26381: PUSH
26382: EMPTY
26383: LIST
26384: LIST
26385: PUSH
26386: LD_INT 2
26388: NEG
26389: PUSH
26390: LD_INT 0
26392: PUSH
26393: EMPTY
26394: LIST
26395: LIST
26396: PUSH
26397: LD_INT 2
26399: NEG
26400: PUSH
26401: LD_INT 1
26403: NEG
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 2
26411: NEG
26412: PUSH
26413: LD_INT 2
26415: NEG
26416: PUSH
26417: EMPTY
26418: LIST
26419: LIST
26420: PUSH
26421: LD_INT 1
26423: PUSH
26424: LD_INT 2
26426: NEG
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 2
26434: PUSH
26435: LD_INT 1
26437: NEG
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: LD_INT 3
26445: PUSH
26446: LD_INT 1
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 3
26455: PUSH
26456: LD_INT 2
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: LIST
26467: LIST
26468: LIST
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: LIST
26474: LIST
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: LIST
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26488: LD_ADDR_VAR 0 25
26492: PUSH
26493: LD_INT 0
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 0
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 1
26516: PUSH
26517: LD_INT 0
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 1
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: LD_INT 0
26536: PUSH
26537: LD_INT 1
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 1
26546: NEG
26547: PUSH
26548: LD_INT 0
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: LD_INT 1
26561: NEG
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 1
26569: NEG
26570: PUSH
26571: LD_INT 2
26573: NEG
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 0
26581: PUSH
26582: LD_INT 2
26584: NEG
26585: PUSH
26586: EMPTY
26587: LIST
26588: LIST
26589: PUSH
26590: LD_INT 1
26592: PUSH
26593: LD_INT 1
26595: NEG
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 2
26603: PUSH
26604: LD_INT 0
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: LD_INT 2
26613: PUSH
26614: LD_INT 1
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 2
26623: PUSH
26624: LD_INT 2
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: LD_INT 1
26633: PUSH
26634: LD_INT 2
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 0
26643: PUSH
26644: LD_INT 2
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 1
26653: NEG
26654: PUSH
26655: LD_INT 1
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: LD_INT 2
26664: NEG
26665: PUSH
26666: LD_INT 0
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PUSH
26673: LD_INT 2
26675: NEG
26676: PUSH
26677: LD_INT 1
26679: NEG
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 2
26687: NEG
26688: PUSH
26689: LD_INT 2
26691: NEG
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 3
26699: PUSH
26700: LD_INT 1
26702: PUSH
26703: EMPTY
26704: LIST
26705: LIST
26706: PUSH
26707: LD_INT 3
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: PUSH
26717: LD_INT 2
26719: PUSH
26720: LD_INT 3
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PUSH
26727: LD_INT 1
26729: PUSH
26730: LD_INT 3
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: LIST
26741: LIST
26742: LIST
26743: LIST
26744: LIST
26745: LIST
26746: LIST
26747: LIST
26748: LIST
26749: LIST
26750: LIST
26751: LIST
26752: LIST
26753: LIST
26754: LIST
26755: LIST
26756: LIST
26757: LIST
26758: LIST
26759: LIST
26760: LIST
26761: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26762: LD_ADDR_VAR 0 26
26766: PUSH
26767: LD_INT 0
26769: PUSH
26770: LD_INT 0
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PUSH
26777: LD_INT 0
26779: PUSH
26780: LD_INT 1
26782: NEG
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 1
26790: PUSH
26791: LD_INT 0
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: LD_INT 1
26800: PUSH
26801: LD_INT 1
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 0
26810: PUSH
26811: LD_INT 1
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: LD_INT 1
26820: NEG
26821: PUSH
26822: LD_INT 0
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 1
26831: NEG
26832: PUSH
26833: LD_INT 1
26835: NEG
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: PUSH
26841: LD_INT 1
26843: NEG
26844: PUSH
26845: LD_INT 2
26847: NEG
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 0
26855: PUSH
26856: LD_INT 2
26858: NEG
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: LD_INT 1
26866: PUSH
26867: LD_INT 1
26869: NEG
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 2
26877: PUSH
26878: LD_INT 0
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 2
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 2
26897: PUSH
26898: LD_INT 2
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 1
26907: PUSH
26908: LD_INT 2
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: LD_INT 0
26917: PUSH
26918: LD_INT 2
26920: PUSH
26921: EMPTY
26922: LIST
26923: LIST
26924: PUSH
26925: LD_INT 1
26927: NEG
26928: PUSH
26929: LD_INT 1
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: PUSH
26936: LD_INT 2
26938: NEG
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: LD_INT 2
26949: NEG
26950: PUSH
26951: LD_INT 1
26953: NEG
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 2
26961: NEG
26962: PUSH
26963: LD_INT 2
26965: NEG
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 2
26973: PUSH
26974: LD_INT 3
26976: PUSH
26977: EMPTY
26978: LIST
26979: LIST
26980: PUSH
26981: LD_INT 1
26983: PUSH
26984: LD_INT 3
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: PUSH
26991: LD_INT 1
26993: NEG
26994: PUSH
26995: LD_INT 2
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 2
27004: NEG
27005: PUSH
27006: LD_INT 1
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27038: LD_ADDR_VAR 0 27
27042: PUSH
27043: LD_INT 0
27045: PUSH
27046: LD_INT 0
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 0
27055: PUSH
27056: LD_INT 1
27058: NEG
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 1
27066: PUSH
27067: LD_INT 0
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 1
27076: PUSH
27077: LD_INT 1
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 1
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 0
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: NEG
27108: PUSH
27109: LD_INT 1
27111: NEG
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: LD_INT 1
27119: NEG
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 0
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: LD_INT 1
27145: NEG
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 2
27153: PUSH
27154: LD_INT 0
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 2
27163: PUSH
27164: LD_INT 1
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 2
27173: PUSH
27174: LD_INT 2
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: PUSH
27181: LD_INT 1
27183: PUSH
27184: LD_INT 2
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 0
27193: PUSH
27194: LD_INT 2
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 1
27203: NEG
27204: PUSH
27205: LD_INT 1
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 2
27214: NEG
27215: PUSH
27216: LD_INT 0
27218: PUSH
27219: EMPTY
27220: LIST
27221: LIST
27222: PUSH
27223: LD_INT 2
27225: NEG
27226: PUSH
27227: LD_INT 1
27229: NEG
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: NEG
27238: PUSH
27239: LD_INT 2
27241: NEG
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 1
27249: NEG
27250: PUSH
27251: LD_INT 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 2
27260: NEG
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: PUSH
27269: LD_INT 3
27271: NEG
27272: PUSH
27273: LD_INT 1
27275: NEG
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 3
27283: NEG
27284: PUSH
27285: LD_INT 2
27287: NEG
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27318: LD_ADDR_VAR 0 28
27322: PUSH
27323: LD_INT 0
27325: PUSH
27326: LD_INT 0
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PUSH
27333: LD_INT 0
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 1
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 1
27356: PUSH
27357: LD_INT 1
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 0
27366: PUSH
27367: LD_INT 1
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 1
27376: NEG
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: LD_INT 1
27387: NEG
27388: PUSH
27389: LD_INT 1
27391: NEG
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 1
27399: NEG
27400: PUSH
27401: LD_INT 2
27403: NEG
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 0
27411: PUSH
27412: LD_INT 2
27414: NEG
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: LD_INT 1
27425: NEG
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 2
27433: PUSH
27434: LD_INT 0
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: LD_INT 2
27443: PUSH
27444: LD_INT 1
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: PUSH
27451: LD_INT 2
27453: PUSH
27454: LD_INT 2
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: PUSH
27461: LD_INT 1
27463: PUSH
27464: LD_INT 2
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 0
27473: PUSH
27474: LD_INT 2
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 1
27483: NEG
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 2
27494: NEG
27495: PUSH
27496: LD_INT 0
27498: PUSH
27499: EMPTY
27500: LIST
27501: LIST
27502: PUSH
27503: LD_INT 2
27505: NEG
27506: PUSH
27507: LD_INT 1
27509: NEG
27510: PUSH
27511: EMPTY
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 2
27517: NEG
27518: PUSH
27519: LD_INT 2
27521: NEG
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PUSH
27527: LD_INT 2
27529: NEG
27530: PUSH
27531: LD_INT 3
27533: NEG
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 1
27541: NEG
27542: PUSH
27543: LD_INT 3
27545: NEG
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PUSH
27551: LD_INT 3
27553: NEG
27554: PUSH
27555: LD_INT 1
27557: NEG
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 3
27565: NEG
27566: PUSH
27567: LD_INT 2
27569: NEG
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27600: LD_ADDR_VAR 0 29
27604: PUSH
27605: LD_INT 0
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: EMPTY
27612: LIST
27613: LIST
27614: PUSH
27615: LD_INT 0
27617: PUSH
27618: LD_INT 1
27620: NEG
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: PUSH
27626: LD_INT 1
27628: PUSH
27629: LD_INT 0
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: PUSH
27636: LD_INT 1
27638: PUSH
27639: LD_INT 1
27641: PUSH
27642: EMPTY
27643: LIST
27644: LIST
27645: PUSH
27646: LD_INT 0
27648: PUSH
27649: LD_INT 1
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: NEG
27659: PUSH
27660: LD_INT 0
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 1
27669: NEG
27670: PUSH
27671: LD_INT 1
27673: NEG
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 1
27681: NEG
27682: PUSH
27683: LD_INT 2
27685: NEG
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 0
27693: PUSH
27694: LD_INT 2
27696: NEG
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: PUSH
27702: LD_INT 1
27704: PUSH
27705: LD_INT 1
27707: NEG
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: LD_INT 2
27715: PUSH
27716: LD_INT 0
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 2
27725: PUSH
27726: LD_INT 1
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: PUSH
27733: LD_INT 1
27735: PUSH
27736: LD_INT 2
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: LD_INT 0
27745: PUSH
27746: LD_INT 2
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: NEG
27756: PUSH
27757: LD_INT 1
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 2
27766: NEG
27767: PUSH
27768: LD_INT 1
27770: NEG
27771: PUSH
27772: EMPTY
27773: LIST
27774: LIST
27775: PUSH
27776: LD_INT 2
27778: NEG
27779: PUSH
27780: LD_INT 2
27782: NEG
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 3
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: PUSH
27803: LD_INT 1
27805: NEG
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: LD_INT 3
27813: PUSH
27814: LD_INT 1
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 1
27823: PUSH
27824: LD_INT 3
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: LD_INT 1
27833: NEG
27834: PUSH
27835: LD_INT 2
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 3
27844: NEG
27845: PUSH
27846: LD_INT 2
27848: NEG
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: EMPTY
27855: LIST
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: LIST
27861: LIST
27862: LIST
27863: LIST
27864: LIST
27865: LIST
27866: LIST
27867: LIST
27868: LIST
27869: LIST
27870: LIST
27871: LIST
27872: LIST
27873: LIST
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27879: LD_ADDR_VAR 0 30
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: LD_INT 1
27899: NEG
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: PUSH
27905: LD_INT 1
27907: PUSH
27908: LD_INT 0
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 1
27917: PUSH
27918: LD_INT 1
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: LD_INT 1
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 1
27948: NEG
27949: PUSH
27950: LD_INT 1
27952: NEG
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 1
27960: NEG
27961: PUSH
27962: LD_INT 2
27964: NEG
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 0
27972: PUSH
27973: LD_INT 2
27975: NEG
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 1
27983: PUSH
27984: LD_INT 1
27986: NEG
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 2
27994: PUSH
27995: LD_INT 0
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 2
28004: PUSH
28005: LD_INT 1
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 2
28014: PUSH
28015: LD_INT 2
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: PUSH
28025: LD_INT 2
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PUSH
28032: LD_INT 1
28034: NEG
28035: PUSH
28036: LD_INT 1
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: PUSH
28043: LD_INT 2
28045: NEG
28046: PUSH
28047: LD_INT 0
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 2
28056: NEG
28057: PUSH
28058: LD_INT 1
28060: NEG
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: NEG
28069: PUSH
28070: LD_INT 3
28072: NEG
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 1
28080: PUSH
28081: LD_INT 2
28083: NEG
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 3
28091: PUSH
28092: LD_INT 2
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: LD_INT 2
28101: PUSH
28102: LD_INT 3
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 2
28111: NEG
28112: PUSH
28113: LD_INT 1
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 3
28122: NEG
28123: PUSH
28124: LD_INT 1
28126: NEG
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: LIST
28156: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28157: LD_ADDR_VAR 0 31
28161: PUSH
28162: LD_INT 0
28164: PUSH
28165: LD_INT 0
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 0
28174: PUSH
28175: LD_INT 1
28177: NEG
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 1
28185: PUSH
28186: LD_INT 0
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: LD_INT 1
28195: PUSH
28196: LD_INT 1
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PUSH
28203: LD_INT 0
28205: PUSH
28206: LD_INT 1
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PUSH
28213: LD_INT 1
28215: NEG
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: LD_INT 1
28226: NEG
28227: PUSH
28228: LD_INT 1
28230: NEG
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 1
28238: NEG
28239: PUSH
28240: LD_INT 2
28242: NEG
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: NEG
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: LD_INT 0
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: LD_INT 1
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 2
28281: PUSH
28282: LD_INT 2
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: PUSH
28289: LD_INT 1
28291: PUSH
28292: LD_INT 2
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 0
28301: PUSH
28302: LD_INT 2
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PUSH
28309: LD_INT 1
28311: NEG
28312: PUSH
28313: LD_INT 1
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PUSH
28320: LD_INT 2
28322: NEG
28323: PUSH
28324: LD_INT 1
28326: NEG
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 2
28334: NEG
28335: PUSH
28336: LD_INT 2
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 2
28346: NEG
28347: PUSH
28348: LD_INT 3
28350: NEG
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 2
28358: PUSH
28359: LD_INT 1
28361: NEG
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: LD_INT 1
28379: PUSH
28380: LD_INT 3
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 1
28389: NEG
28390: PUSH
28391: LD_INT 2
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: PUSH
28398: LD_INT 3
28400: NEG
28401: PUSH
28402: LD_INT 2
28404: NEG
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: LIST
28414: LIST
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28435: LD_ADDR_VAR 0 32
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: LD_INT 0
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: LD_INT 1
28455: NEG
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 1
28473: PUSH
28474: LD_INT 1
28476: PUSH
28477: EMPTY
28478: LIST
28479: LIST
28480: PUSH
28481: LD_INT 0
28483: PUSH
28484: LD_INT 1
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: NEG
28494: PUSH
28495: LD_INT 0
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 1
28504: NEG
28505: PUSH
28506: LD_INT 1
28508: NEG
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 1
28516: NEG
28517: PUSH
28518: LD_INT 2
28520: NEG
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 0
28528: PUSH
28529: LD_INT 2
28531: NEG
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: LD_INT 1
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: LD_INT 1
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: PUSH
28558: LD_INT 2
28560: PUSH
28561: LD_INT 2
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 1
28570: PUSH
28571: LD_INT 2
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: LD_INT 2
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: PUSH
28588: LD_INT 1
28590: NEG
28591: PUSH
28592: LD_INT 1
28594: PUSH
28595: EMPTY
28596: LIST
28597: LIST
28598: PUSH
28599: LD_INT 2
28601: NEG
28602: PUSH
28603: LD_INT 0
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 2
28612: NEG
28613: PUSH
28614: LD_INT 1
28616: NEG
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 1
28624: NEG
28625: PUSH
28626: LD_INT 3
28628: NEG
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: NEG
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: LD_INT 3
28647: PUSH
28648: LD_INT 2
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: LD_INT 2
28657: PUSH
28658: LD_INT 3
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 1
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 3
28678: NEG
28679: PUSH
28680: LD_INT 1
28682: NEG
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: LIST
28692: LIST
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28713: LD_ADDR_VAR 0 33
28717: PUSH
28718: LD_INT 0
28720: PUSH
28721: LD_INT 0
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 0
28730: PUSH
28731: LD_INT 1
28733: NEG
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 1
28741: PUSH
28742: LD_INT 0
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: LD_INT 1
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 0
28761: PUSH
28762: LD_INT 1
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 1
28771: NEG
28772: PUSH
28773: LD_INT 0
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: LD_INT 1
28786: NEG
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: LD_INT 1
28794: NEG
28795: PUSH
28796: LD_INT 2
28798: NEG
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 1
28806: PUSH
28807: LD_INT 1
28809: NEG
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 2
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: EMPTY
28822: LIST
28823: LIST
28824: PUSH
28825: LD_INT 2
28827: PUSH
28828: LD_INT 1
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 1
28837: PUSH
28838: LD_INT 2
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 0
28847: PUSH
28848: LD_INT 2
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 1
28857: NEG
28858: PUSH
28859: LD_INT 1
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: LD_INT 2
28868: NEG
28869: PUSH
28870: LD_INT 0
28872: PUSH
28873: EMPTY
28874: LIST
28875: LIST
28876: PUSH
28877: LD_INT 2
28879: NEG
28880: PUSH
28881: LD_INT 1
28883: NEG
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 2
28891: NEG
28892: PUSH
28893: LD_INT 2
28895: NEG
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: LD_INT 3
28907: NEG
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: LD_INT 1
28918: NEG
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 3
28926: PUSH
28927: LD_INT 1
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 1
28936: PUSH
28937: LD_INT 3
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: LD_INT 1
28946: NEG
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 3
28957: NEG
28958: PUSH
28959: LD_INT 2
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28992: LD_ADDR_VAR 0 34
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: LD_INT 0
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 0
29009: PUSH
29010: LD_INT 1
29012: NEG
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: PUSH
29021: LD_INT 0
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 1
29030: PUSH
29031: LD_INT 1
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 0
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 1
29061: NEG
29062: PUSH
29063: LD_INT 1
29065: NEG
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: PUSH
29071: LD_INT 1
29073: NEG
29074: PUSH
29075: LD_INT 2
29077: NEG
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 0
29085: PUSH
29086: LD_INT 2
29088: NEG
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 1
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 2
29107: PUSH
29108: LD_INT 1
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 2
29117: PUSH
29118: LD_INT 2
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: LD_INT 1
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 2
29148: NEG
29149: PUSH
29150: LD_INT 0
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 2
29159: NEG
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 2
29171: NEG
29172: PUSH
29173: LD_INT 2
29175: NEG
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: LD_INT 3
29187: NEG
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 1
29195: PUSH
29196: LD_INT 2
29198: NEG
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 3
29206: PUSH
29207: LD_INT 2
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 2
29216: PUSH
29217: LD_INT 3
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 2
29226: NEG
29227: PUSH
29228: LD_INT 1
29230: PUSH
29231: EMPTY
29232: LIST
29233: LIST
29234: PUSH
29235: LD_INT 3
29237: NEG
29238: PUSH
29239: LD_INT 1
29241: NEG
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29272: LD_ADDR_VAR 0 35
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: LD_INT 0
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PUSH
29287: LD_INT 0
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: LD_INT 1
29310: PUSH
29311: LD_INT 1
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: LD_INT 0
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: LD_INT 1
29341: NEG
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 2
29353: PUSH
29354: LD_INT 1
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 2
29363: NEG
29364: PUSH
29365: LD_INT 1
29367: NEG
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: LIST
29377: LIST
29378: LIST
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29384: LD_ADDR_VAR 0 36
29388: PUSH
29389: LD_INT 0
29391: PUSH
29392: LD_INT 0
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: PUSH
29399: LD_INT 0
29401: PUSH
29402: LD_INT 1
29404: NEG
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: LD_INT 0
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 1
29422: PUSH
29423: LD_INT 1
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 1
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: LD_INT 0
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: NEG
29454: PUSH
29455: LD_INT 1
29457: NEG
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: LD_INT 2
29469: NEG
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 1
29477: PUSH
29478: LD_INT 2
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29496: LD_ADDR_VAR 0 37
29500: PUSH
29501: LD_INT 0
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 0
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 1
29554: NEG
29555: PUSH
29556: LD_INT 0
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 1
29565: NEG
29566: PUSH
29567: LD_INT 1
29569: NEG
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 1
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: NEG
29589: PUSH
29590: LD_INT 1
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29608: LD_ADDR_VAR 0 38
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: LD_INT 1
29628: NEG
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 0
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: LD_INT 0
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: LD_INT 1
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: LD_INT 1
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 2
29699: NEG
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: LIST
29717: LIST
29718: LIST
29719: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29720: LD_ADDR_VAR 0 39
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: LD_INT 0
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PUSH
29735: LD_INT 0
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: LD_INT 0
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 0
29768: PUSH
29769: LD_INT 1
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: LD_INT 0
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: LD_INT 1
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 1
29801: NEG
29802: PUSH
29803: LD_INT 2
29805: NEG
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: LD_INT 2
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: LIST
29829: LIST
29830: LIST
29831: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29832: LD_ADDR_VAR 0 40
29836: PUSH
29837: LD_INT 0
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: LD_INT 1
29852: NEG
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 1
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: LD_INT 1
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: PUSH
29878: LD_INT 0
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: NEG
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 1
29901: NEG
29902: PUSH
29903: LD_INT 1
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: LD_INT 1
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: NEG
29925: PUSH
29926: LD_INT 1
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29944: LD_ADDR_VAR 0 41
29948: PUSH
29949: LD_INT 0
29951: PUSH
29952: LD_INT 0
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: LD_INT 1
29964: NEG
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PUSH
29970: LD_INT 1
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: PUSH
29983: LD_INT 1
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 0
29992: PUSH
29993: LD_INT 1
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 1
30002: NEG
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 1
30013: NEG
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 1
30025: NEG
30026: PUSH
30027: LD_INT 2
30029: NEG
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 2
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 2
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: PUSH
30079: LD_INT 2
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: NEG
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 2
30099: NEG
30100: PUSH
30101: LD_INT 0
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: LD_INT 2
30110: NEG
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: NEG
30123: PUSH
30124: LD_INT 2
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 2
30134: NEG
30135: PUSH
30136: LD_INT 3
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 2
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 3
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: EMPTY
30162: LIST
30163: LIST
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: LD_INT 1
30170: PUSH
30171: EMPTY
30172: LIST
30173: LIST
30174: PUSH
30175: LD_INT 3
30177: PUSH
30178: LD_INT 2
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 3
30187: PUSH
30188: LD_INT 3
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 2
30197: PUSH
30198: LD_INT 3
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 2
30207: NEG
30208: PUSH
30209: LD_INT 1
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 3
30218: NEG
30219: PUSH
30220: LD_INT 0
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 3
30229: NEG
30230: PUSH
30231: LD_INT 1
30233: NEG
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 3
30241: NEG
30242: PUSH
30243: LD_INT 2
30245: NEG
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 3
30253: NEG
30254: PUSH
30255: LD_INT 3
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30294: LD_ADDR_VAR 0 42
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: LD_INT 0
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 0
30311: PUSH
30312: LD_INT 1
30314: NEG
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 1
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 0
30342: PUSH
30343: LD_INT 1
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 1
30352: NEG
30353: PUSH
30354: LD_INT 0
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 1
30363: NEG
30364: PUSH
30365: LD_INT 1
30367: NEG
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 1
30375: NEG
30376: PUSH
30377: LD_INT 2
30379: NEG
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: PUSH
30385: LD_INT 0
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 1
30398: PUSH
30399: LD_INT 1
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 2
30409: PUSH
30410: LD_INT 1
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 2
30419: PUSH
30420: LD_INT 2
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: LD_INT 2
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 0
30439: PUSH
30440: LD_INT 2
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 1
30449: NEG
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 2
30460: NEG
30461: PUSH
30462: LD_INT 1
30464: NEG
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 2
30472: NEG
30473: PUSH
30474: LD_INT 2
30476: NEG
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 2
30484: NEG
30485: PUSH
30486: LD_INT 3
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: NEG
30497: PUSH
30498: LD_INT 3
30500: NEG
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: LD_INT 3
30511: NEG
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 1
30519: PUSH
30520: LD_INT 2
30522: NEG
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 3
30530: PUSH
30531: LD_INT 2
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 3
30540: PUSH
30541: LD_INT 3
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: LD_INT 3
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 1
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 0
30570: PUSH
30571: LD_INT 3
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 1
30580: NEG
30581: PUSH
30582: LD_INT 2
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 3
30591: NEG
30592: PUSH
30593: LD_INT 2
30595: NEG
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 3
30603: NEG
30604: PUSH
30605: LD_INT 3
30607: NEG
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30644: LD_ADDR_VAR 0 43
30648: PUSH
30649: LD_INT 0
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 0
30692: PUSH
30693: LD_INT 1
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 1
30702: NEG
30703: PUSH
30704: LD_INT 0
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: NEG
30714: PUSH
30715: LD_INT 1
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 1
30725: NEG
30726: PUSH
30727: LD_INT 2
30729: NEG
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 0
30737: PUSH
30738: LD_INT 2
30740: NEG
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: LD_INT 1
30751: NEG
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 2
30759: PUSH
30760: LD_INT 0
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: PUSH
30770: LD_INT 1
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 1
30779: PUSH
30780: LD_INT 2
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 0
30789: PUSH
30790: LD_INT 2
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: LD_INT 1
30799: NEG
30800: PUSH
30801: LD_INT 1
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 2
30810: NEG
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 2
30821: NEG
30822: PUSH
30823: LD_INT 1
30825: NEG
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 1
30833: NEG
30834: PUSH
30835: LD_INT 3
30837: NEG
30838: PUSH
30839: EMPTY
30840: LIST
30841: LIST
30842: PUSH
30843: LD_INT 0
30845: PUSH
30846: LD_INT 3
30848: NEG
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: PUSH
30857: LD_INT 2
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 2
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 3
30878: PUSH
30879: LD_INT 0
30881: PUSH
30882: EMPTY
30883: LIST
30884: LIST
30885: PUSH
30886: LD_INT 3
30888: PUSH
30889: LD_INT 1
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: LD_INT 3
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: LD_INT 3
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: LD_INT 2
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 2
30929: NEG
30930: PUSH
30931: LD_INT 1
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: PUSH
30938: LD_INT 3
30940: NEG
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 3
30951: NEG
30952: PUSH
30953: LD_INT 1
30955: NEG
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30992: LD_ADDR_VAR 0 44
30996: PUSH
30997: LD_INT 0
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 1
31020: PUSH
31021: LD_INT 0
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: LD_INT 0
31040: PUSH
31041: LD_INT 1
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: LD_INT 0
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: LD_INT 1
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: LD_INT 2
31077: NEG
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 1
31085: PUSH
31086: LD_INT 1
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 2
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PUSH
31104: LD_INT 2
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: PUSH
31117: LD_INT 2
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: LD_INT 1
31126: PUSH
31127: LD_INT 2
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PUSH
31134: LD_INT 1
31136: NEG
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 2
31147: NEG
31148: PUSH
31149: LD_INT 0
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 2
31158: NEG
31159: PUSH
31160: LD_INT 1
31162: NEG
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 2
31170: NEG
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: NEG
31183: PUSH
31184: LD_INT 3
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 3
31205: PUSH
31206: LD_INT 0
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 3
31215: PUSH
31216: LD_INT 1
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 3
31225: PUSH
31226: LD_INT 2
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 3
31235: PUSH
31236: LD_INT 3
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 2
31245: PUSH
31246: LD_INT 3
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 2
31255: NEG
31256: PUSH
31257: LD_INT 1
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 3
31266: NEG
31267: PUSH
31268: LD_INT 0
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 3
31277: NEG
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 3
31289: NEG
31290: PUSH
31291: LD_INT 2
31293: NEG
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 3
31301: NEG
31302: PUSH
31303: LD_INT 3
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31342: LD_ADDR_VAR 0 45
31346: PUSH
31347: LD_INT 0
31349: PUSH
31350: LD_INT 0
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: LD_INT 1
31362: NEG
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: LD_INT 0
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: LD_INT 1
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 0
31390: PUSH
31391: LD_INT 1
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 1
31400: NEG
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 1
31411: NEG
31412: PUSH
31413: LD_INT 1
31415: NEG
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 1
31423: NEG
31424: PUSH
31425: LD_INT 2
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 2
31438: NEG
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 1
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 2
31457: PUSH
31458: LD_INT 1
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: LD_INT 2
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: LD_INT 2
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 2
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 1
31497: NEG
31498: PUSH
31499: LD_INT 1
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 2
31508: NEG
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: LD_INT 2
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: LD_INT 3
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 1
31544: NEG
31545: PUSH
31546: LD_INT 3
31548: NEG
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 0
31556: PUSH
31557: LD_INT 3
31559: NEG
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: PUSH
31568: LD_INT 2
31570: NEG
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 3
31578: PUSH
31579: LD_INT 2
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 3
31588: PUSH
31589: LD_INT 3
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 2
31598: PUSH
31599: LD_INT 3
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: LD_INT 3
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 0
31618: PUSH
31619: LD_INT 3
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 2
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 3
31639: NEG
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 3
31651: NEG
31652: PUSH
31653: LD_INT 3
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31692: LD_ADDR_VAR 0 46
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: LD_INT 0
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: LD_INT 1
31712: NEG
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: LD_INT 1
31730: PUSH
31731: LD_INT 1
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 1
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: NEG
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: NEG
31774: PUSH
31775: LD_INT 2
31777: NEG
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: LD_INT 2
31788: NEG
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 1
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 2
31807: PUSH
31808: LD_INT 0
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 2
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: LD_INT 2
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 2
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 1
31847: NEG
31848: PUSH
31849: LD_INT 1
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 2
31858: NEG
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 2
31869: NEG
31870: PUSH
31871: LD_INT 1
31873: NEG
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: NEG
31882: PUSH
31883: LD_INT 3
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 3
31896: NEG
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 2
31907: NEG
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 2
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 3
31926: PUSH
31927: LD_INT 0
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 3
31936: PUSH
31937: LD_INT 1
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 3
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: LD_INT 3
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 2
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 3
31988: NEG
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 3
31999: NEG
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32040: LD_ADDR_VAR 0 47
32044: PUSH
32045: LD_INT 0
32047: PUSH
32048: LD_INT 0
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 0
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 1
32068: PUSH
32069: LD_INT 0
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: LD_INT 1
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: LD_INT 0
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 1
32109: NEG
32110: PUSH
32111: LD_INT 1
32113: NEG
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: LD_INT 2
32125: NEG
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: LD_INT 2
32136: NEG
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 1
32144: PUSH
32145: LD_INT 1
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 2
32171: NEG
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32191: LD_ADDR_VAR 0 48
32195: PUSH
32196: LD_INT 0
32198: PUSH
32199: LD_INT 0
32201: PUSH
32202: EMPTY
32203: LIST
32204: LIST
32205: PUSH
32206: LD_INT 0
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 1
32219: PUSH
32220: LD_INT 0
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: LD_INT 1
32229: PUSH
32230: LD_INT 1
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: PUSH
32237: LD_INT 0
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 1
32249: NEG
32250: PUSH
32251: LD_INT 0
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 1
32272: NEG
32273: PUSH
32274: LD_INT 2
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 0
32284: PUSH
32285: LD_INT 2
32287: NEG
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 1
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 2
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 2
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32338: LD_ADDR_VAR 0 49
32342: PUSH
32343: LD_INT 0
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: LD_INT 0
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: LD_INT 1
32411: NEG
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: PUSH
32420: LD_INT 1
32422: NEG
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 2
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 2
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32482: LD_ADDR_VAR 0 50
32486: PUSH
32487: LD_INT 0
32489: PUSH
32490: LD_INT 0
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 0
32499: PUSH
32500: LD_INT 1
32502: NEG
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 1
32510: PUSH
32511: LD_INT 0
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: LD_INT 1
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 0
32530: PUSH
32531: LD_INT 1
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 1
32540: NEG
32541: PUSH
32542: LD_INT 0
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 1
32555: NEG
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 2
32563: PUSH
32564: LD_INT 1
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 2
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 2
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32626: LD_ADDR_VAR 0 51
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 0
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: LD_INT 1
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: LD_INT 1
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 1
32699: NEG
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: LD_INT 2
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 0
32717: PUSH
32718: LD_INT 2
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 1
32727: NEG
32728: PUSH
32729: LD_INT 1
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 2
32738: NEG
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 2
32749: NEG
32750: PUSH
32751: LD_INT 1
32753: NEG
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32773: LD_ADDR_VAR 0 52
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 2
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 1
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 2
32877: NEG
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: LD_INT 1
32892: NEG
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: LD_INT 2
32904: NEG
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32924: LD_ADDR_VAR 0 53
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 0
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: NEG
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: LD_INT 1
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 1
32982: NEG
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 1
32993: NEG
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: NEG
33006: PUSH
33007: LD_INT 2
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: LD_INT 2
33020: NEG
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: PUSH
33037: LD_INT 2
33039: PUSH
33040: LD_INT 0
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 2
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: NEG
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: NEG
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: NEG
33124: PUSH
33125: LD_INT 2
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33154: LD_ADDR_VAR 0 54
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: LD_INT 1
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 2
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 1
33261: NEG
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 2
33269: PUSH
33270: LD_INT 0
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 2
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 2
33289: PUSH
33290: LD_INT 2
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 1
33299: PUSH
33300: LD_INT 2
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: LD_INT 2
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: LD_INT 1
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 2
33330: NEG
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: NEG
33342: PUSH
33343: LD_INT 1
33345: NEG
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 2
33353: NEG
33354: PUSH
33355: LD_INT 2
33357: NEG
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33384: LD_ADDR_VAR 0 55
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 0
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 0
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: LD_INT 0
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: LD_INT 1
33457: NEG
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 1
33465: NEG
33466: PUSH
33467: LD_INT 2
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 0
33477: PUSH
33478: LD_INT 2
33480: NEG
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 2
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 2
33519: PUSH
33520: LD_INT 2
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 2
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 2
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 1
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 2
33560: NEG
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33614: LD_ADDR_VAR 0 56
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 1
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: NEG
33696: PUSH
33697: LD_INT 2
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: LD_INT 2
33710: NEG
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 1
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: LD_INT 0
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: LD_INT 1
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 2
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 2
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 2
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: LD_INT 1
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 2
33790: NEG
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33844: LD_ADDR_VAR 0 57
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 1
33872: PUSH
33873: LD_INT 0
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: LD_INT 1
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 0
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 1
33902: NEG
33903: PUSH
33904: LD_INT 0
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 1
33913: NEG
33914: PUSH
33915: LD_INT 1
33917: NEG
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: LD_INT 2
33929: NEG
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: LD_INT 2
33940: NEG
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: PUSH
33949: LD_INT 1
33951: NEG
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 2
33959: PUSH
33960: LD_INT 0
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: LD_INT 2
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 1
33989: PUSH
33990: LD_INT 2
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: LD_INT 1
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 2
34043: NEG
34044: PUSH
34045: LD_INT 2
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34074: LD_ADDR_VAR 0 58
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: LD_INT 0
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: LD_INT 1
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: NEG
34133: PUSH
34134: LD_INT 0
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: NEG
34144: PUSH
34145: LD_INT 1
34147: NEG
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 2
34159: NEG
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: LD_INT 2
34170: NEG
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 1
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 2
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 2
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: LD_INT 2
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: LD_INT 2
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: LD_INT 2
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 1
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 2
34250: NEG
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 2
34261: NEG
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: LD_INT 2
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34304: LD_ADDR_VAR 0 59
34308: PUSH
34309: LD_INT 0
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 1
34324: NEG
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 1
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: PUSH
34343: LD_INT 1
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: LD_INT 1
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: NEG
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: LD_INT 1
34377: NEG
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34392: LD_ADDR_VAR 0 60
34396: PUSH
34397: LD_INT 0
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: LD_INT 1
34412: NEG
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 0
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 1
34461: NEG
34462: PUSH
34463: LD_INT 1
34465: NEG
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34480: LD_ADDR_VAR 0 61
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34568: LD_ADDR_VAR 0 62
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 0
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: LD_INT 0
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: LD_INT 1
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 1
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 1
34626: NEG
34627: PUSH
34628: LD_INT 0
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: LD_INT 1
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: LIST
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34656: LD_ADDR_VAR 0 63
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: LD_INT 0
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: LD_INT 1
34676: NEG
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: PUSH
34695: LD_INT 1
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: LD_INT 0
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: NEG
34726: PUSH
34727: LD_INT 1
34729: NEG
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34744: LD_ADDR_VAR 0 64
34748: PUSH
34749: LD_INT 0
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: LD_INT 1
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: LD_INT 0
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 1
34782: PUSH
34783: LD_INT 1
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 0
34792: PUSH
34793: LD_INT 1
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 1
34802: NEG
34803: PUSH
34804: LD_INT 0
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 1
34813: NEG
34814: PUSH
34815: LD_INT 1
34817: NEG
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: ST_TO_ADDR
// end ; 1 :
34832: GO 40729
34834: LD_INT 1
34836: DOUBLE
34837: EQUAL
34838: IFTRUE 34842
34840: GO 37465
34842: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34843: LD_ADDR_VAR 0 11
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: LD_INT 3
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: LD_INT 3
34865: NEG
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: LIST
34886: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34887: LD_ADDR_VAR 0 12
34891: PUSH
34892: LD_INT 2
34894: PUSH
34895: LD_INT 1
34897: NEG
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 3
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 3
34915: PUSH
34916: LD_INT 1
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34928: LD_ADDR_VAR 0 13
34932: PUSH
34933: LD_INT 3
34935: PUSH
34936: LD_INT 2
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 3
34945: PUSH
34946: LD_INT 3
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 2
34955: PUSH
34956: LD_INT 3
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: LIST
34967: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34968: LD_ADDR_VAR 0 14
34972: PUSH
34973: LD_INT 1
34975: PUSH
34976: LD_INT 3
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 0
34985: PUSH
34986: LD_INT 3
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: LIST
35008: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35009: LD_ADDR_VAR 0 15
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: LD_INT 1
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 3
35027: NEG
35028: PUSH
35029: LD_INT 0
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 3
35038: NEG
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: LIST
35052: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35053: LD_ADDR_VAR 0 16
35057: PUSH
35058: LD_INT 2
35060: NEG
35061: PUSH
35062: LD_INT 3
35064: NEG
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 3
35072: NEG
35073: PUSH
35074: LD_INT 2
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 3
35084: NEG
35085: PUSH
35086: LD_INT 3
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: LIST
35098: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35099: LD_ADDR_VAR 0 17
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 3
35110: NEG
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 0
35118: PUSH
35119: LD_INT 3
35121: NEG
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: PUSH
35130: LD_INT 2
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: LIST
35142: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35143: LD_ADDR_VAR 0 18
35147: PUSH
35148: LD_INT 2
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 3
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 3
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: LIST
35183: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35184: LD_ADDR_VAR 0 19
35188: PUSH
35189: LD_INT 3
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 3
35201: PUSH
35202: LD_INT 3
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 2
35211: PUSH
35212: LD_INT 3
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: LIST
35223: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35224: LD_ADDR_VAR 0 20
35228: PUSH
35229: LD_INT 1
35231: PUSH
35232: LD_INT 3
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 3
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: LD_INT 2
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: LIST
35264: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35265: LD_ADDR_VAR 0 21
35269: PUSH
35270: LD_INT 2
35272: NEG
35273: PUSH
35274: LD_INT 1
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 3
35283: NEG
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 3
35294: NEG
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: LIST
35308: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35309: LD_ADDR_VAR 0 22
35313: PUSH
35314: LD_INT 2
35316: NEG
35317: PUSH
35318: LD_INT 3
35320: NEG
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 3
35328: NEG
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 3
35340: NEG
35341: PUSH
35342: LD_INT 3
35344: NEG
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: LIST
35354: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35355: LD_ADDR_VAR 0 23
35359: PUSH
35360: LD_INT 0
35362: PUSH
35363: LD_INT 3
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 1
35373: NEG
35374: PUSH
35375: LD_INT 4
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: LD_INT 3
35388: NEG
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35399: LD_ADDR_VAR 0 24
35403: PUSH
35404: LD_INT 3
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 3
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 4
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: EMPTY
35436: LIST
35437: LIST
35438: LIST
35439: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35440: LD_ADDR_VAR 0 25
35444: PUSH
35445: LD_INT 3
35447: PUSH
35448: LD_INT 3
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 4
35457: PUSH
35458: LD_INT 3
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 3
35467: PUSH
35468: LD_INT 4
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: LIST
35479: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35480: LD_ADDR_VAR 0 26
35484: PUSH
35485: LD_INT 0
35487: PUSH
35488: LD_INT 3
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 4
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: LD_INT 3
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: LIST
35520: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35521: LD_ADDR_VAR 0 27
35525: PUSH
35526: LD_INT 3
35528: NEG
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 3
35539: NEG
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 4
35550: NEG
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: LIST
35564: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35565: LD_ADDR_VAR 0 28
35569: PUSH
35570: LD_INT 3
35572: NEG
35573: PUSH
35574: LD_INT 3
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 3
35584: NEG
35585: PUSH
35586: LD_INT 4
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 4
35596: NEG
35597: PUSH
35598: LD_INT 3
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: LIST
35610: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35611: LD_ADDR_VAR 0 29
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: LD_INT 3
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 0
35630: PUSH
35631: LD_INT 3
35633: NEG
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: LD_INT 4
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 0
35664: PUSH
35665: LD_INT 4
35667: NEG
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 3
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 1
35686: NEG
35687: PUSH
35688: LD_INT 5
35690: NEG
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 0
35698: PUSH
35699: LD_INT 5
35701: NEG
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: LD_INT 4
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: NEG
35721: PUSH
35722: LD_INT 6
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 0
35732: PUSH
35733: LD_INT 6
35735: NEG
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: PUSH
35744: LD_INT 5
35746: NEG
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35766: LD_ADDR_VAR 0 30
35770: PUSH
35771: LD_INT 2
35773: PUSH
35774: LD_INT 1
35776: NEG
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 3
35784: PUSH
35785: LD_INT 0
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 3
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 3
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 4
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 4
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 4
35835: PUSH
35836: LD_INT 1
35838: NEG
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 5
35846: PUSH
35847: LD_INT 0
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 5
35856: PUSH
35857: LD_INT 1
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 5
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 6
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 6
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: EMPTY
35892: LIST
35893: LIST
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: LIST
35899: LIST
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35909: LD_ADDR_VAR 0 31
35913: PUSH
35914: LD_INT 3
35916: PUSH
35917: LD_INT 2
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 3
35926: PUSH
35927: LD_INT 3
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 2
35936: PUSH
35937: LD_INT 3
35939: PUSH
35940: EMPTY
35941: LIST
35942: LIST
35943: PUSH
35944: LD_INT 4
35946: PUSH
35947: LD_INT 3
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 4
35956: PUSH
35957: LD_INT 4
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 3
35966: PUSH
35967: LD_INT 4
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 5
35976: PUSH
35977: LD_INT 4
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 5
35986: PUSH
35987: LD_INT 5
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 4
35996: PUSH
35997: LD_INT 5
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 6
36006: PUSH
36007: LD_INT 5
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 6
36016: PUSH
36017: LD_INT 6
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 5
36026: PUSH
36027: LD_INT 6
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36048: LD_ADDR_VAR 0 32
36052: PUSH
36053: LD_INT 1
36055: PUSH
36056: LD_INT 3
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: LD_INT 2
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 1
36086: PUSH
36087: LD_INT 4
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 4
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 1
36106: NEG
36107: PUSH
36108: LD_INT 3
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 5
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: LD_INT 5
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 1
36137: NEG
36138: PUSH
36139: LD_INT 4
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: LD_INT 6
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 0
36158: PUSH
36159: LD_INT 6
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: LD_INT 5
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36191: LD_ADDR_VAR 0 33
36195: PUSH
36196: LD_INT 2
36198: NEG
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 3
36209: NEG
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 3
36220: NEG
36221: PUSH
36222: LD_INT 1
36224: NEG
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 3
36232: NEG
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 4
36243: NEG
36244: PUSH
36245: LD_INT 0
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 4
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 4
36266: NEG
36267: PUSH
36268: LD_INT 1
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 5
36277: NEG
36278: PUSH
36279: LD_INT 0
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 5
36288: NEG
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 5
36300: NEG
36301: PUSH
36302: LD_INT 1
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 6
36311: NEG
36312: PUSH
36313: LD_INT 0
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 6
36322: NEG
36323: PUSH
36324: LD_INT 1
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36346: LD_ADDR_VAR 0 34
36350: PUSH
36351: LD_INT 2
36353: NEG
36354: PUSH
36355: LD_INT 3
36357: NEG
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 3
36365: NEG
36366: PUSH
36367: LD_INT 2
36369: NEG
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: LD_INT 3
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 3
36389: NEG
36390: PUSH
36391: LD_INT 4
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 4
36401: NEG
36402: PUSH
36403: LD_INT 3
36405: NEG
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 4
36413: NEG
36414: PUSH
36415: LD_INT 4
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 4
36425: NEG
36426: PUSH
36427: LD_INT 5
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 5
36437: NEG
36438: PUSH
36439: LD_INT 4
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: LD_INT 5
36453: NEG
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 5
36461: NEG
36462: PUSH
36463: LD_INT 6
36465: NEG
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 6
36473: NEG
36474: PUSH
36475: LD_INT 5
36477: NEG
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 6
36485: NEG
36486: PUSH
36487: LD_INT 6
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36509: LD_ADDR_VAR 0 41
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 3
36531: NEG
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: LD_INT 2
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36553: LD_ADDR_VAR 0 42
36557: PUSH
36558: LD_INT 2
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 2
36570: PUSH
36571: LD_INT 1
36573: NEG
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 3
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: LIST
36593: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36594: LD_ADDR_VAR 0 43
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 2
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 3
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: PUSH
36622: LD_INT 3
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: LIST
36633: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36634: LD_ADDR_VAR 0 44
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: LD_INT 3
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: LD_INT 1
36661: NEG
36662: PUSH
36663: LD_INT 2
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: LIST
36674: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36675: LD_ADDR_VAR 0 45
36679: PUSH
36680: LD_INT 2
36682: NEG
36683: PUSH
36684: LD_INT 0
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 2
36693: NEG
36694: PUSH
36695: LD_INT 1
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 3
36704: NEG
36705: PUSH
36706: LD_INT 1
36708: NEG
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: LIST
36718: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36719: LD_ADDR_VAR 0 46
36723: PUSH
36724: LD_INT 2
36726: NEG
36727: PUSH
36728: LD_INT 2
36730: NEG
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 2
36738: NEG
36739: PUSH
36740: LD_INT 3
36742: NEG
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 3
36750: NEG
36751: PUSH
36752: LD_INT 2
36754: NEG
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: LIST
36764: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36765: LD_ADDR_VAR 0 47
36769: PUSH
36770: LD_INT 2
36772: NEG
36773: PUSH
36774: LD_INT 3
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 1
36784: NEG
36785: PUSH
36786: LD_INT 3
36788: NEG
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36798: LD_ADDR_VAR 0 48
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36829: LD_ADDR_VAR 0 49
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 1
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: LD_INT 2
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36858: LD_ADDR_VAR 0 50
36862: PUSH
36863: LD_INT 2
36865: PUSH
36866: LD_INT 3
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 3
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36887: LD_ADDR_VAR 0 51
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: LD_INT 2
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 2
36905: NEG
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36918: LD_ADDR_VAR 0 52
36922: PUSH
36923: LD_INT 3
36925: NEG
36926: PUSH
36927: LD_INT 1
36929: NEG
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 3
36937: NEG
36938: PUSH
36939: LD_INT 2
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36951: LD_ADDR_VAR 0 53
36955: PUSH
36956: LD_INT 1
36958: NEG
36959: PUSH
36960: LD_INT 3
36962: NEG
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 0
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: PUSH
36982: LD_INT 2
36984: NEG
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: LIST
36994: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36995: LD_ADDR_VAR 0 54
36999: PUSH
37000: LD_INT 2
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 3
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 3
37023: PUSH
37024: LD_INT 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: LIST
37035: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37036: LD_ADDR_VAR 0 55
37040: PUSH
37041: LD_INT 3
37043: PUSH
37044: LD_INT 2
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 3
37053: PUSH
37054: LD_INT 3
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 2
37063: PUSH
37064: LD_INT 3
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: LIST
37075: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37076: LD_ADDR_VAR 0 56
37080: PUSH
37081: LD_INT 1
37083: PUSH
37084: LD_INT 3
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 0
37093: PUSH
37094: LD_INT 3
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: LIST
37116: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37117: LD_ADDR_VAR 0 57
37121: PUSH
37122: LD_INT 2
37124: NEG
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 3
37135: NEG
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 3
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: LIST
37160: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37161: LD_ADDR_VAR 0 58
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: LD_INT 3
37172: NEG
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: NEG
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 3
37192: NEG
37193: PUSH
37194: LD_INT 3
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: LIST
37206: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37207: LD_ADDR_VAR 0 59
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: LD_INT 2
37218: NEG
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 0
37226: PUSH
37227: LD_INT 2
37229: NEG
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 1
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: LIST
37250: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37251: LD_ADDR_VAR 0 60
37255: PUSH
37256: LD_INT 1
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 2
37269: PUSH
37270: LD_INT 0
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 2
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: LIST
37291: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37292: LD_ADDR_VAR 0 61
37296: PUSH
37297: LD_INT 2
37299: PUSH
37300: LD_INT 1
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 2
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: LD_INT 2
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: LIST
37331: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37332: LD_ADDR_VAR 0 62
37336: PUSH
37337: LD_INT 1
37339: PUSH
37340: LD_INT 2
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: LD_INT 2
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: LD_INT 1
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: LIST
37372: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37373: LD_ADDR_VAR 0 63
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 2
37391: NEG
37392: PUSH
37393: LD_INT 0
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 2
37402: NEG
37403: PUSH
37404: LD_INT 1
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: LIST
37416: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37417: LD_ADDR_VAR 0 64
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: LD_INT 2
37428: NEG
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 2
37436: NEG
37437: PUSH
37438: LD_INT 1
37440: NEG
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: NEG
37449: PUSH
37450: LD_INT 2
37452: NEG
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: LIST
37462: ST_TO_ADDR
// end ; 2 :
37463: GO 40729
37465: LD_INT 2
37467: DOUBLE
37468: EQUAL
37469: IFTRUE 37473
37471: GO 40728
37473: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37474: LD_ADDR_VAR 0 29
37478: PUSH
37479: LD_INT 4
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 4
37491: PUSH
37492: LD_INT 1
37494: NEG
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 5
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 5
37512: PUSH
37513: LD_INT 1
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 4
37522: PUSH
37523: LD_INT 1
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 3
37532: PUSH
37533: LD_INT 0
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 3
37542: PUSH
37543: LD_INT 1
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: PUSH
37554: LD_INT 2
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 5
37564: PUSH
37565: LD_INT 2
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 3
37574: PUSH
37575: LD_INT 3
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 4
37594: PUSH
37595: LD_INT 3
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 4
37604: PUSH
37605: LD_INT 4
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 3
37614: PUSH
37615: LD_INT 4
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 2
37624: PUSH
37625: LD_INT 3
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: LD_INT 2
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 4
37644: PUSH
37645: LD_INT 2
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 2
37654: PUSH
37655: LD_INT 4
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: LD_INT 4
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: LD_INT 3
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 4
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: LD_INT 5
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 0
37704: PUSH
37705: LD_INT 5
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: PUSH
37712: LD_INT 1
37714: NEG
37715: PUSH
37716: LD_INT 4
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 1
37725: NEG
37726: PUSH
37727: LD_INT 3
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 2
37736: PUSH
37737: LD_INT 5
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 2
37746: NEG
37747: PUSH
37748: LD_INT 3
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 3
37757: NEG
37758: PUSH
37759: LD_INT 0
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 3
37768: NEG
37769: PUSH
37770: LD_INT 1
37772: NEG
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 2
37780: NEG
37781: PUSH
37782: LD_INT 0
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 2
37791: NEG
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 3
37802: NEG
37803: PUSH
37804: LD_INT 1
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 4
37813: NEG
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 4
37824: NEG
37825: PUSH
37826: LD_INT 1
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 4
37836: NEG
37837: PUSH
37838: LD_INT 2
37840: NEG
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 2
37848: NEG
37849: PUSH
37850: LD_INT 2
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 4
37859: NEG
37860: PUSH
37861: LD_INT 4
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 4
37871: NEG
37872: PUSH
37873: LD_INT 5
37875: NEG
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: LD_INT 4
37887: NEG
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 3
37895: NEG
37896: PUSH
37897: LD_INT 3
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 4
37907: NEG
37908: PUSH
37909: LD_INT 3
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 5
37919: NEG
37920: PUSH
37921: LD_INT 4
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 5
37931: NEG
37932: PUSH
37933: LD_INT 5
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 3
37943: NEG
37944: PUSH
37945: LD_INT 5
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 5
37955: NEG
37956: PUSH
37957: LD_INT 3
37959: NEG
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38012: LD_ADDR_VAR 0 30
38016: PUSH
38017: LD_INT 4
38019: PUSH
38020: LD_INT 4
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 4
38029: PUSH
38030: LD_INT 3
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: LD_INT 5
38039: PUSH
38040: LD_INT 4
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 5
38049: PUSH
38050: LD_INT 5
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 4
38059: PUSH
38060: LD_INT 5
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 3
38069: PUSH
38070: LD_INT 4
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 3
38079: PUSH
38080: LD_INT 3
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 5
38089: PUSH
38090: LD_INT 3
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 3
38099: PUSH
38100: LD_INT 5
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 0
38109: PUSH
38110: LD_INT 3
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: PUSH
38130: LD_INT 3
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: PUSH
38140: LD_INT 4
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 0
38149: PUSH
38150: LD_INT 4
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: LD_INT 3
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 1
38170: NEG
38171: PUSH
38172: LD_INT 2
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: PUSH
38182: LD_INT 4
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 2
38191: NEG
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 4
38202: NEG
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 4
38213: NEG
38214: PUSH
38215: LD_INT 1
38217: NEG
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 3
38225: NEG
38226: PUSH
38227: LD_INT 0
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 3
38236: NEG
38237: PUSH
38238: LD_INT 1
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 4
38247: NEG
38248: PUSH
38249: LD_INT 1
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 5
38258: NEG
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 5
38269: NEG
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 5
38281: NEG
38282: PUSH
38283: LD_INT 2
38285: NEG
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 3
38293: NEG
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 3
38304: NEG
38305: PUSH
38306: LD_INT 3
38308: NEG
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 3
38316: NEG
38317: PUSH
38318: LD_INT 4
38320: NEG
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 2
38328: NEG
38329: PUSH
38330: LD_INT 3
38332: NEG
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: LD_INT 2
38344: NEG
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 3
38352: NEG
38353: PUSH
38354: LD_INT 2
38356: NEG
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 4
38364: NEG
38365: PUSH
38366: LD_INT 3
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 4
38376: NEG
38377: PUSH
38378: LD_INT 4
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 2
38388: NEG
38389: PUSH
38390: LD_INT 4
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 4
38400: NEG
38401: PUSH
38402: LD_INT 2
38404: NEG
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 4
38415: NEG
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 0
38423: PUSH
38424: LD_INT 5
38426: NEG
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: LD_INT 4
38437: NEG
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 3
38448: NEG
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 0
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 4
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: NEG
38480: PUSH
38481: LD_INT 5
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: LD_INT 3
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 2
38502: NEG
38503: PUSH
38504: LD_INT 5
38506: NEG
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38559: LD_ADDR_VAR 0 31
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: LD_INT 4
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: LD_INT 3
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 1
38586: PUSH
38587: LD_INT 4
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 5
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 0
38606: PUSH
38607: LD_INT 5
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: LD_INT 1
38616: NEG
38617: PUSH
38618: LD_INT 4
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: LD_INT 3
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 2
38638: PUSH
38639: LD_INT 5
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 2
38648: NEG
38649: PUSH
38650: LD_INT 3
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 3
38659: NEG
38660: PUSH
38661: LD_INT 0
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 3
38670: NEG
38671: PUSH
38672: LD_INT 1
38674: NEG
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 2
38682: NEG
38683: PUSH
38684: LD_INT 0
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: PUSH
38691: LD_INT 2
38693: NEG
38694: PUSH
38695: LD_INT 1
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 3
38704: NEG
38705: PUSH
38706: LD_INT 1
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 4
38715: NEG
38716: PUSH
38717: LD_INT 0
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 4
38726: NEG
38727: PUSH
38728: LD_INT 1
38730: NEG
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 4
38738: NEG
38739: PUSH
38740: LD_INT 2
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 4
38761: NEG
38762: PUSH
38763: LD_INT 4
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 4
38773: NEG
38774: PUSH
38775: LD_INT 5
38777: NEG
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 3
38785: NEG
38786: PUSH
38787: LD_INT 4
38789: NEG
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 3
38797: NEG
38798: PUSH
38799: LD_INT 3
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 4
38809: NEG
38810: PUSH
38811: LD_INT 3
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: LD_INT 5
38821: NEG
38822: PUSH
38823: LD_INT 4
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 5
38833: NEG
38834: PUSH
38835: LD_INT 5
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 3
38845: NEG
38846: PUSH
38847: LD_INT 5
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 5
38857: NEG
38858: PUSH
38859: LD_INT 3
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: LD_INT 3
38872: NEG
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 0
38880: PUSH
38881: LD_INT 4
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: PUSH
38892: LD_INT 3
38894: NEG
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: LD_INT 2
38905: NEG
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 0
38913: PUSH
38914: LD_INT 2
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 3
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 4
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 2
38959: NEG
38960: PUSH
38961: LD_INT 4
38963: NEG
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 4
38971: PUSH
38972: LD_INT 0
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 4
38981: PUSH
38982: LD_INT 1
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 5
38992: PUSH
38993: LD_INT 0
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 5
39002: PUSH
39003: LD_INT 1
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 4
39012: PUSH
39013: LD_INT 1
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 3
39022: PUSH
39023: LD_INT 0
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 3
39032: PUSH
39033: LD_INT 1
39035: NEG
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: LD_INT 3
39043: PUSH
39044: LD_INT 2
39046: NEG
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 5
39054: PUSH
39055: LD_INT 2
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39109: LD_ADDR_VAR 0 32
39113: PUSH
39114: LD_INT 4
39116: NEG
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 4
39127: NEG
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 3
39139: NEG
39140: PUSH
39141: LD_INT 0
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 3
39150: NEG
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 4
39161: NEG
39162: PUSH
39163: LD_INT 1
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 5
39172: NEG
39173: PUSH
39174: LD_INT 0
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 5
39183: NEG
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 5
39195: NEG
39196: PUSH
39197: LD_INT 2
39199: NEG
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: LD_INT 2
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 3
39218: NEG
39219: PUSH
39220: LD_INT 3
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 3
39230: NEG
39231: PUSH
39232: LD_INT 4
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: LD_INT 3
39246: NEG
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: NEG
39255: PUSH
39256: LD_INT 2
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 3
39266: NEG
39267: PUSH
39268: LD_INT 2
39270: NEG
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 4
39278: NEG
39279: PUSH
39280: LD_INT 3
39282: NEG
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 4
39290: NEG
39291: PUSH
39292: LD_INT 4
39294: NEG
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 2
39302: NEG
39303: PUSH
39304: LD_INT 4
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 4
39314: NEG
39315: PUSH
39316: LD_INT 2
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 0
39326: PUSH
39327: LD_INT 4
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 0
39337: PUSH
39338: LD_INT 5
39340: NEG
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: LD_INT 1
39348: PUSH
39349: LD_INT 4
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: LD_INT 3
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 0
39370: PUSH
39371: LD_INT 3
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: LD_INT 4
39385: NEG
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: NEG
39394: PUSH
39395: LD_INT 5
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 2
39405: PUSH
39406: LD_INT 3
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 2
39416: NEG
39417: PUSH
39418: LD_INT 5
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 3
39428: PUSH
39429: LD_INT 0
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 3
39438: PUSH
39439: LD_INT 1
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 4
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 4
39459: PUSH
39460: LD_INT 1
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 3
39469: PUSH
39470: LD_INT 1
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 2
39479: PUSH
39480: LD_INT 0
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: LD_INT 2
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 2
39500: PUSH
39501: LD_INT 2
39503: NEG
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 4
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 4
39521: PUSH
39522: LD_INT 4
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 4
39531: PUSH
39532: LD_INT 3
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 5
39541: PUSH
39542: LD_INT 4
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 5
39551: PUSH
39552: LD_INT 5
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: LD_INT 4
39561: PUSH
39562: LD_INT 5
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: PUSH
39572: LD_INT 4
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 3
39581: PUSH
39582: LD_INT 3
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 5
39591: PUSH
39592: LD_INT 3
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 3
39601: PUSH
39602: LD_INT 5
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39656: LD_ADDR_VAR 0 33
39660: PUSH
39661: LD_INT 4
39663: NEG
39664: PUSH
39665: LD_INT 4
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 4
39675: NEG
39676: PUSH
39677: LD_INT 5
39679: NEG
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: LD_INT 4
39691: NEG
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: LD_INT 3
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 4
39711: NEG
39712: PUSH
39713: LD_INT 3
39715: NEG
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 5
39723: NEG
39724: PUSH
39725: LD_INT 4
39727: NEG
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 5
39735: NEG
39736: PUSH
39737: LD_INT 5
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 3
39747: NEG
39748: PUSH
39749: LD_INT 5
39751: NEG
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 5
39759: NEG
39760: PUSH
39761: LD_INT 3
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: LD_INT 3
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 4
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 3
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: PUSH
39805: LD_INT 2
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 0
39815: PUSH
39816: LD_INT 2
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: NEG
39827: PUSH
39828: LD_INT 3
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: LD_INT 4
39842: NEG
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 2
39850: PUSH
39851: LD_INT 2
39853: NEG
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 2
39861: NEG
39862: PUSH
39863: LD_INT 4
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 4
39873: PUSH
39874: LD_INT 0
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 4
39883: PUSH
39884: LD_INT 1
39886: NEG
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 5
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: LD_INT 5
39904: PUSH
39905: LD_INT 1
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 4
39914: PUSH
39915: LD_INT 1
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 3
39924: PUSH
39925: LD_INT 0
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 3
39934: PUSH
39935: LD_INT 1
39937: NEG
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 3
39945: PUSH
39946: LD_INT 2
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 5
39956: PUSH
39957: LD_INT 2
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: PUSH
39967: LD_INT 3
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 3
39976: PUSH
39977: LD_INT 2
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 4
39986: PUSH
39987: LD_INT 3
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 4
39996: PUSH
39997: LD_INT 4
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 3
40006: PUSH
40007: LD_INT 4
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: LD_INT 3
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: LD_INT 2
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 4
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: LD_INT 4
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: LD_INT 4
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 3
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 1
40076: PUSH
40077: LD_INT 4
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 1
40086: PUSH
40087: LD_INT 5
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: LD_INT 5
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 1
40106: NEG
40107: PUSH
40108: LD_INT 4
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: LD_INT 1
40117: NEG
40118: PUSH
40119: LD_INT 3
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 2
40128: PUSH
40129: LD_INT 5
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 2
40138: NEG
40139: PUSH
40140: LD_INT 3
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40194: LD_ADDR_VAR 0 34
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: LD_INT 4
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: LD_INT 5
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 1
40223: PUSH
40224: LD_INT 4
40226: NEG
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: PUSH
40235: LD_INT 3
40237: NEG
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 0
40245: PUSH
40246: LD_INT 3
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 4
40260: NEG
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 5
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 2
40280: PUSH
40281: LD_INT 3
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 2
40291: NEG
40292: PUSH
40293: LD_INT 5
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 3
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 3
40313: PUSH
40314: LD_INT 1
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 4
40334: PUSH
40335: LD_INT 1
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 3
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 2
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 2
40364: PUSH
40365: LD_INT 1
40367: NEG
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 2
40375: PUSH
40376: LD_INT 2
40378: NEG
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 4
40386: PUSH
40387: LD_INT 2
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 4
40396: PUSH
40397: LD_INT 4
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 4
40406: PUSH
40407: LD_INT 3
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 5
40416: PUSH
40417: LD_INT 4
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 5
40426: PUSH
40427: LD_INT 5
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 4
40436: PUSH
40437: LD_INT 5
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 3
40446: PUSH
40447: LD_INT 4
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 3
40456: PUSH
40457: LD_INT 3
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 5
40466: PUSH
40467: LD_INT 3
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 3
40476: PUSH
40477: LD_INT 5
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 3
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: LD_INT 2
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: LD_INT 3
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: PUSH
40517: LD_INT 4
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: LD_INT 0
40526: PUSH
40527: LD_INT 4
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 1
40536: NEG
40537: PUSH
40538: LD_INT 3
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 2
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 2
40558: PUSH
40559: LD_INT 4
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 2
40568: NEG
40569: PUSH
40570: LD_INT 2
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: PUSH
40577: LD_INT 4
40579: NEG
40580: PUSH
40581: LD_INT 0
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: LD_INT 4
40590: NEG
40591: PUSH
40592: LD_INT 1
40594: NEG
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 3
40602: NEG
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 3
40613: NEG
40614: PUSH
40615: LD_INT 1
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 4
40624: NEG
40625: PUSH
40626: LD_INT 1
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 5
40635: NEG
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 5
40646: NEG
40647: PUSH
40648: LD_INT 1
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 5
40658: NEG
40659: PUSH
40660: LD_INT 2
40662: NEG
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 3
40670: NEG
40671: PUSH
40672: LD_INT 2
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: ST_TO_ADDR
// end ; end ;
40726: GO 40729
40728: POP
// case btype of b_depot , b_warehouse :
40729: LD_VAR 0 1
40733: PUSH
40734: LD_INT 0
40736: DOUBLE
40737: EQUAL
40738: IFTRUE 40748
40740: LD_INT 1
40742: DOUBLE
40743: EQUAL
40744: IFTRUE 40748
40746: GO 40949
40748: POP
// case nation of nation_american :
40749: LD_VAR 0 5
40753: PUSH
40754: LD_INT 1
40756: DOUBLE
40757: EQUAL
40758: IFTRUE 40762
40760: GO 40818
40762: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40763: LD_ADDR_VAR 0 9
40767: PUSH
40768: LD_VAR 0 11
40772: PUSH
40773: LD_VAR 0 12
40777: PUSH
40778: LD_VAR 0 13
40782: PUSH
40783: LD_VAR 0 14
40787: PUSH
40788: LD_VAR 0 15
40792: PUSH
40793: LD_VAR 0 16
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: PUSH
40806: LD_VAR 0 4
40810: PUSH
40811: LD_INT 1
40813: PLUS
40814: ARRAY
40815: ST_TO_ADDR
40816: GO 40947
40818: LD_INT 2
40820: DOUBLE
40821: EQUAL
40822: IFTRUE 40826
40824: GO 40882
40826: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40827: LD_ADDR_VAR 0 9
40831: PUSH
40832: LD_VAR 0 17
40836: PUSH
40837: LD_VAR 0 18
40841: PUSH
40842: LD_VAR 0 19
40846: PUSH
40847: LD_VAR 0 20
40851: PUSH
40852: LD_VAR 0 21
40856: PUSH
40857: LD_VAR 0 22
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: PUSH
40870: LD_VAR 0 4
40874: PUSH
40875: LD_INT 1
40877: PLUS
40878: ARRAY
40879: ST_TO_ADDR
40880: GO 40947
40882: LD_INT 3
40884: DOUBLE
40885: EQUAL
40886: IFTRUE 40890
40888: GO 40946
40890: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40891: LD_ADDR_VAR 0 9
40895: PUSH
40896: LD_VAR 0 23
40900: PUSH
40901: LD_VAR 0 24
40905: PUSH
40906: LD_VAR 0 25
40910: PUSH
40911: LD_VAR 0 26
40915: PUSH
40916: LD_VAR 0 27
40920: PUSH
40921: LD_VAR 0 28
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: PUSH
40934: LD_VAR 0 4
40938: PUSH
40939: LD_INT 1
40941: PLUS
40942: ARRAY
40943: ST_TO_ADDR
40944: GO 40947
40946: POP
40947: GO 41502
40949: LD_INT 2
40951: DOUBLE
40952: EQUAL
40953: IFTRUE 40963
40955: LD_INT 3
40957: DOUBLE
40958: EQUAL
40959: IFTRUE 40963
40961: GO 41019
40963: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40964: LD_ADDR_VAR 0 9
40968: PUSH
40969: LD_VAR 0 29
40973: PUSH
40974: LD_VAR 0 30
40978: PUSH
40979: LD_VAR 0 31
40983: PUSH
40984: LD_VAR 0 32
40988: PUSH
40989: LD_VAR 0 33
40993: PUSH
40994: LD_VAR 0 34
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: PUSH
41007: LD_VAR 0 4
41011: PUSH
41012: LD_INT 1
41014: PLUS
41015: ARRAY
41016: ST_TO_ADDR
41017: GO 41502
41019: LD_INT 16
41021: DOUBLE
41022: EQUAL
41023: IFTRUE 41081
41025: LD_INT 17
41027: DOUBLE
41028: EQUAL
41029: IFTRUE 41081
41031: LD_INT 18
41033: DOUBLE
41034: EQUAL
41035: IFTRUE 41081
41037: LD_INT 19
41039: DOUBLE
41040: EQUAL
41041: IFTRUE 41081
41043: LD_INT 22
41045: DOUBLE
41046: EQUAL
41047: IFTRUE 41081
41049: LD_INT 20
41051: DOUBLE
41052: EQUAL
41053: IFTRUE 41081
41055: LD_INT 21
41057: DOUBLE
41058: EQUAL
41059: IFTRUE 41081
41061: LD_INT 23
41063: DOUBLE
41064: EQUAL
41065: IFTRUE 41081
41067: LD_INT 24
41069: DOUBLE
41070: EQUAL
41071: IFTRUE 41081
41073: LD_INT 25
41075: DOUBLE
41076: EQUAL
41077: IFTRUE 41081
41079: GO 41137
41081: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41082: LD_ADDR_VAR 0 9
41086: PUSH
41087: LD_VAR 0 35
41091: PUSH
41092: LD_VAR 0 36
41096: PUSH
41097: LD_VAR 0 37
41101: PUSH
41102: LD_VAR 0 38
41106: PUSH
41107: LD_VAR 0 39
41111: PUSH
41112: LD_VAR 0 40
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: LIST
41124: PUSH
41125: LD_VAR 0 4
41129: PUSH
41130: LD_INT 1
41132: PLUS
41133: ARRAY
41134: ST_TO_ADDR
41135: GO 41502
41137: LD_INT 6
41139: DOUBLE
41140: EQUAL
41141: IFTRUE 41193
41143: LD_INT 7
41145: DOUBLE
41146: EQUAL
41147: IFTRUE 41193
41149: LD_INT 8
41151: DOUBLE
41152: EQUAL
41153: IFTRUE 41193
41155: LD_INT 13
41157: DOUBLE
41158: EQUAL
41159: IFTRUE 41193
41161: LD_INT 12
41163: DOUBLE
41164: EQUAL
41165: IFTRUE 41193
41167: LD_INT 15
41169: DOUBLE
41170: EQUAL
41171: IFTRUE 41193
41173: LD_INT 11
41175: DOUBLE
41176: EQUAL
41177: IFTRUE 41193
41179: LD_INT 14
41181: DOUBLE
41182: EQUAL
41183: IFTRUE 41193
41185: LD_INT 10
41187: DOUBLE
41188: EQUAL
41189: IFTRUE 41193
41191: GO 41249
41193: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41194: LD_ADDR_VAR 0 9
41198: PUSH
41199: LD_VAR 0 41
41203: PUSH
41204: LD_VAR 0 42
41208: PUSH
41209: LD_VAR 0 43
41213: PUSH
41214: LD_VAR 0 44
41218: PUSH
41219: LD_VAR 0 45
41223: PUSH
41224: LD_VAR 0 46
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: PUSH
41237: LD_VAR 0 4
41241: PUSH
41242: LD_INT 1
41244: PLUS
41245: ARRAY
41246: ST_TO_ADDR
41247: GO 41502
41249: LD_INT 36
41251: DOUBLE
41252: EQUAL
41253: IFTRUE 41257
41255: GO 41313
41257: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41258: LD_ADDR_VAR 0 9
41262: PUSH
41263: LD_VAR 0 47
41267: PUSH
41268: LD_VAR 0 48
41272: PUSH
41273: LD_VAR 0 49
41277: PUSH
41278: LD_VAR 0 50
41282: PUSH
41283: LD_VAR 0 51
41287: PUSH
41288: LD_VAR 0 52
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: PUSH
41301: LD_VAR 0 4
41305: PUSH
41306: LD_INT 1
41308: PLUS
41309: ARRAY
41310: ST_TO_ADDR
41311: GO 41502
41313: LD_INT 4
41315: DOUBLE
41316: EQUAL
41317: IFTRUE 41339
41319: LD_INT 5
41321: DOUBLE
41322: EQUAL
41323: IFTRUE 41339
41325: LD_INT 34
41327: DOUBLE
41328: EQUAL
41329: IFTRUE 41339
41331: LD_INT 37
41333: DOUBLE
41334: EQUAL
41335: IFTRUE 41339
41337: GO 41395
41339: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41340: LD_ADDR_VAR 0 9
41344: PUSH
41345: LD_VAR 0 53
41349: PUSH
41350: LD_VAR 0 54
41354: PUSH
41355: LD_VAR 0 55
41359: PUSH
41360: LD_VAR 0 56
41364: PUSH
41365: LD_VAR 0 57
41369: PUSH
41370: LD_VAR 0 58
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PUSH
41383: LD_VAR 0 4
41387: PUSH
41388: LD_INT 1
41390: PLUS
41391: ARRAY
41392: ST_TO_ADDR
41393: GO 41502
41395: LD_INT 31
41397: DOUBLE
41398: EQUAL
41399: IFTRUE 41445
41401: LD_INT 32
41403: DOUBLE
41404: EQUAL
41405: IFTRUE 41445
41407: LD_INT 33
41409: DOUBLE
41410: EQUAL
41411: IFTRUE 41445
41413: LD_INT 27
41415: DOUBLE
41416: EQUAL
41417: IFTRUE 41445
41419: LD_INT 26
41421: DOUBLE
41422: EQUAL
41423: IFTRUE 41445
41425: LD_INT 28
41427: DOUBLE
41428: EQUAL
41429: IFTRUE 41445
41431: LD_INT 29
41433: DOUBLE
41434: EQUAL
41435: IFTRUE 41445
41437: LD_INT 30
41439: DOUBLE
41440: EQUAL
41441: IFTRUE 41445
41443: GO 41501
41445: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41446: LD_ADDR_VAR 0 9
41450: PUSH
41451: LD_VAR 0 59
41455: PUSH
41456: LD_VAR 0 60
41460: PUSH
41461: LD_VAR 0 61
41465: PUSH
41466: LD_VAR 0 62
41470: PUSH
41471: LD_VAR 0 63
41475: PUSH
41476: LD_VAR 0 64
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: LIST
41487: LIST
41488: PUSH
41489: LD_VAR 0 4
41493: PUSH
41494: LD_INT 1
41496: PLUS
41497: ARRAY
41498: ST_TO_ADDR
41499: GO 41502
41501: POP
// temp_list2 = [ ] ;
41502: LD_ADDR_VAR 0 10
41506: PUSH
41507: EMPTY
41508: ST_TO_ADDR
// for i in temp_list do
41509: LD_ADDR_VAR 0 8
41513: PUSH
41514: LD_VAR 0 9
41518: PUSH
41519: FOR_IN
41520: IFFALSE 41572
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41522: LD_ADDR_VAR 0 10
41526: PUSH
41527: LD_VAR 0 10
41531: PUSH
41532: LD_VAR 0 8
41536: PUSH
41537: LD_INT 1
41539: ARRAY
41540: PUSH
41541: LD_VAR 0 2
41545: PLUS
41546: PUSH
41547: LD_VAR 0 8
41551: PUSH
41552: LD_INT 2
41554: ARRAY
41555: PUSH
41556: LD_VAR 0 3
41560: PLUS
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: EMPTY
41567: LIST
41568: ADD
41569: ST_TO_ADDR
41570: GO 41519
41572: POP
41573: POP
// result = temp_list2 ;
41574: LD_ADDR_VAR 0 7
41578: PUSH
41579: LD_VAR 0 10
41583: ST_TO_ADDR
// end ;
41584: LD_VAR 0 7
41588: RET
// export function EnemyInRange ( unit , dist ) ; begin
41589: LD_INT 0
41591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41592: LD_ADDR_VAR 0 3
41596: PUSH
41597: LD_VAR 0 1
41601: PPUSH
41602: CALL_OW 255
41606: PPUSH
41607: LD_VAR 0 1
41611: PPUSH
41612: CALL_OW 250
41616: PPUSH
41617: LD_VAR 0 1
41621: PPUSH
41622: CALL_OW 251
41626: PPUSH
41627: LD_VAR 0 2
41631: PPUSH
41632: CALL 15693 0 4
41636: PUSH
41637: LD_INT 4
41639: ARRAY
41640: ST_TO_ADDR
// end ;
41641: LD_VAR 0 3
41645: RET
// export function PlayerSeeMe ( unit ) ; begin
41646: LD_INT 0
41648: PPUSH
// result := See ( your_side , unit ) ;
41649: LD_ADDR_VAR 0 2
41653: PUSH
41654: LD_OWVAR 2
41658: PPUSH
41659: LD_VAR 0 1
41663: PPUSH
41664: CALL_OW 292
41668: ST_TO_ADDR
// end ;
41669: LD_VAR 0 2
41673: RET
// export function ReverseDir ( unit ) ; begin
41674: LD_INT 0
41676: PPUSH
// if not unit then
41677: LD_VAR 0 1
41681: NOT
41682: IFFALSE 41686
// exit ;
41684: GO 41709
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41686: LD_ADDR_VAR 0 2
41690: PUSH
41691: LD_VAR 0 1
41695: PPUSH
41696: CALL_OW 254
41700: PUSH
41701: LD_INT 3
41703: PLUS
41704: PUSH
41705: LD_INT 6
41707: MOD
41708: ST_TO_ADDR
// end ;
41709: LD_VAR 0 2
41713: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41714: LD_INT 0
41716: PPUSH
41717: PPUSH
41718: PPUSH
41719: PPUSH
41720: PPUSH
// if not hexes then
41721: LD_VAR 0 2
41725: NOT
41726: IFFALSE 41730
// exit ;
41728: GO 41878
// dist := 9999 ;
41730: LD_ADDR_VAR 0 5
41734: PUSH
41735: LD_INT 9999
41737: ST_TO_ADDR
// for i = 1 to hexes do
41738: LD_ADDR_VAR 0 4
41742: PUSH
41743: DOUBLE
41744: LD_INT 1
41746: DEC
41747: ST_TO_ADDR
41748: LD_VAR 0 2
41752: PUSH
41753: FOR_TO
41754: IFFALSE 41866
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41756: LD_VAR 0 1
41760: PPUSH
41761: LD_VAR 0 2
41765: PUSH
41766: LD_VAR 0 4
41770: ARRAY
41771: PUSH
41772: LD_INT 1
41774: ARRAY
41775: PPUSH
41776: LD_VAR 0 2
41780: PUSH
41781: LD_VAR 0 4
41785: ARRAY
41786: PUSH
41787: LD_INT 2
41789: ARRAY
41790: PPUSH
41791: CALL_OW 297
41795: PUSH
41796: LD_VAR 0 5
41800: LESS
41801: IFFALSE 41864
// begin hex := hexes [ i ] ;
41803: LD_ADDR_VAR 0 7
41807: PUSH
41808: LD_VAR 0 2
41812: PUSH
41813: LD_VAR 0 4
41817: ARRAY
41818: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41819: LD_ADDR_VAR 0 5
41823: PUSH
41824: LD_VAR 0 1
41828: PPUSH
41829: LD_VAR 0 2
41833: PUSH
41834: LD_VAR 0 4
41838: ARRAY
41839: PUSH
41840: LD_INT 1
41842: ARRAY
41843: PPUSH
41844: LD_VAR 0 2
41848: PUSH
41849: LD_VAR 0 4
41853: ARRAY
41854: PUSH
41855: LD_INT 2
41857: ARRAY
41858: PPUSH
41859: CALL_OW 297
41863: ST_TO_ADDR
// end ; end ;
41864: GO 41753
41866: POP
41867: POP
// result := hex ;
41868: LD_ADDR_VAR 0 3
41872: PUSH
41873: LD_VAR 0 7
41877: ST_TO_ADDR
// end ;
41878: LD_VAR 0 3
41882: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41883: LD_INT 0
41885: PPUSH
41886: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41887: LD_VAR 0 1
41891: NOT
41892: PUSH
41893: LD_VAR 0 1
41897: PUSH
41898: LD_INT 21
41900: PUSH
41901: LD_INT 2
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 23
41910: PUSH
41911: LD_INT 2
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PPUSH
41922: CALL_OW 69
41926: IN
41927: NOT
41928: OR
41929: IFFALSE 41933
// exit ;
41931: GO 41980
// for i = 1 to 3 do
41933: LD_ADDR_VAR 0 3
41937: PUSH
41938: DOUBLE
41939: LD_INT 1
41941: DEC
41942: ST_TO_ADDR
41943: LD_INT 3
41945: PUSH
41946: FOR_TO
41947: IFFALSE 41978
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41949: LD_VAR 0 1
41953: PPUSH
41954: CALL_OW 250
41958: PPUSH
41959: LD_VAR 0 1
41963: PPUSH
41964: CALL_OW 251
41968: PPUSH
41969: LD_INT 1
41971: PPUSH
41972: CALL_OW 453
41976: GO 41946
41978: POP
41979: POP
// end ;
41980: LD_VAR 0 2
41984: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41985: LD_INT 0
41987: PPUSH
41988: PPUSH
41989: PPUSH
41990: PPUSH
41991: PPUSH
41992: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
41993: LD_VAR 0 1
41997: NOT
41998: PUSH
41999: LD_VAR 0 2
42003: NOT
42004: OR
42005: PUSH
42006: LD_VAR 0 1
42010: PPUSH
42011: CALL_OW 314
42015: OR
42016: IFFALSE 42020
// exit ;
42018: GO 42461
// x := GetX ( enemy_unit ) ;
42020: LD_ADDR_VAR 0 7
42024: PUSH
42025: LD_VAR 0 2
42029: PPUSH
42030: CALL_OW 250
42034: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42035: LD_ADDR_VAR 0 8
42039: PUSH
42040: LD_VAR 0 2
42044: PPUSH
42045: CALL_OW 251
42049: ST_TO_ADDR
// if not x or not y then
42050: LD_VAR 0 7
42054: NOT
42055: PUSH
42056: LD_VAR 0 8
42060: NOT
42061: OR
42062: IFFALSE 42066
// exit ;
42064: GO 42461
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42066: LD_ADDR_VAR 0 6
42070: PUSH
42071: LD_VAR 0 7
42075: PPUSH
42076: LD_INT 0
42078: PPUSH
42079: LD_INT 4
42081: PPUSH
42082: CALL_OW 272
42086: PUSH
42087: LD_VAR 0 8
42091: PPUSH
42092: LD_INT 0
42094: PPUSH
42095: LD_INT 4
42097: PPUSH
42098: CALL_OW 273
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_VAR 0 7
42111: PPUSH
42112: LD_INT 1
42114: PPUSH
42115: LD_INT 4
42117: PPUSH
42118: CALL_OW 272
42122: PUSH
42123: LD_VAR 0 8
42127: PPUSH
42128: LD_INT 1
42130: PPUSH
42131: LD_INT 4
42133: PPUSH
42134: CALL_OW 273
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_VAR 0 7
42147: PPUSH
42148: LD_INT 2
42150: PPUSH
42151: LD_INT 4
42153: PPUSH
42154: CALL_OW 272
42158: PUSH
42159: LD_VAR 0 8
42163: PPUSH
42164: LD_INT 2
42166: PPUSH
42167: LD_INT 4
42169: PPUSH
42170: CALL_OW 273
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_VAR 0 7
42183: PPUSH
42184: LD_INT 3
42186: PPUSH
42187: LD_INT 4
42189: PPUSH
42190: CALL_OW 272
42194: PUSH
42195: LD_VAR 0 8
42199: PPUSH
42200: LD_INT 3
42202: PPUSH
42203: LD_INT 4
42205: PPUSH
42206: CALL_OW 273
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_VAR 0 7
42219: PPUSH
42220: LD_INT 4
42222: PPUSH
42223: LD_INT 4
42225: PPUSH
42226: CALL_OW 272
42230: PUSH
42231: LD_VAR 0 8
42235: PPUSH
42236: LD_INT 4
42238: PPUSH
42239: LD_INT 4
42241: PPUSH
42242: CALL_OW 273
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_VAR 0 7
42255: PPUSH
42256: LD_INT 5
42258: PPUSH
42259: LD_INT 4
42261: PPUSH
42262: CALL_OW 272
42266: PUSH
42267: LD_VAR 0 8
42271: PPUSH
42272: LD_INT 5
42274: PPUSH
42275: LD_INT 4
42277: PPUSH
42278: CALL_OW 273
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: ST_TO_ADDR
// for i = tmp downto 1 do
42295: LD_ADDR_VAR 0 4
42299: PUSH
42300: DOUBLE
42301: LD_VAR 0 6
42305: INC
42306: ST_TO_ADDR
42307: LD_INT 1
42309: PUSH
42310: FOR_DOWNTO
42311: IFFALSE 42412
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42313: LD_VAR 0 6
42317: PUSH
42318: LD_VAR 0 4
42322: ARRAY
42323: PUSH
42324: LD_INT 1
42326: ARRAY
42327: PPUSH
42328: LD_VAR 0 6
42332: PUSH
42333: LD_VAR 0 4
42337: ARRAY
42338: PUSH
42339: LD_INT 2
42341: ARRAY
42342: PPUSH
42343: CALL_OW 488
42347: NOT
42348: PUSH
42349: LD_VAR 0 6
42353: PUSH
42354: LD_VAR 0 4
42358: ARRAY
42359: PUSH
42360: LD_INT 1
42362: ARRAY
42363: PPUSH
42364: LD_VAR 0 6
42368: PUSH
42369: LD_VAR 0 4
42373: ARRAY
42374: PUSH
42375: LD_INT 2
42377: ARRAY
42378: PPUSH
42379: CALL_OW 428
42383: PUSH
42384: LD_INT 0
42386: NONEQUAL
42387: OR
42388: IFFALSE 42410
// tmp := Delete ( tmp , i ) ;
42390: LD_ADDR_VAR 0 6
42394: PUSH
42395: LD_VAR 0 6
42399: PPUSH
42400: LD_VAR 0 4
42404: PPUSH
42405: CALL_OW 3
42409: ST_TO_ADDR
42410: GO 42310
42412: POP
42413: POP
// j := GetClosestHex ( unit , tmp ) ;
42414: LD_ADDR_VAR 0 5
42418: PUSH
42419: LD_VAR 0 1
42423: PPUSH
42424: LD_VAR 0 6
42428: PPUSH
42429: CALL 41714 0 2
42433: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42434: LD_VAR 0 1
42438: PPUSH
42439: LD_VAR 0 5
42443: PUSH
42444: LD_INT 1
42446: ARRAY
42447: PPUSH
42448: LD_VAR 0 5
42452: PUSH
42453: LD_INT 2
42455: ARRAY
42456: PPUSH
42457: CALL_OW 111
// end ;
42461: LD_VAR 0 3
42465: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42466: LD_INT 0
42468: PPUSH
42469: PPUSH
42470: PPUSH
// uc_side = 0 ;
42471: LD_ADDR_OWVAR 20
42475: PUSH
42476: LD_INT 0
42478: ST_TO_ADDR
// uc_nation = 0 ;
42479: LD_ADDR_OWVAR 21
42483: PUSH
42484: LD_INT 0
42486: ST_TO_ADDR
// InitHc_All ( ) ;
42487: CALL_OW 584
// InitVc ;
42491: CALL_OW 20
// if mastodonts then
42495: LD_VAR 0 6
42499: IFFALSE 42566
// for i = 1 to mastodonts do
42501: LD_ADDR_VAR 0 11
42505: PUSH
42506: DOUBLE
42507: LD_INT 1
42509: DEC
42510: ST_TO_ADDR
42511: LD_VAR 0 6
42515: PUSH
42516: FOR_TO
42517: IFFALSE 42564
// begin vc_chassis := 31 ;
42519: LD_ADDR_OWVAR 37
42523: PUSH
42524: LD_INT 31
42526: ST_TO_ADDR
// vc_control := control_rider ;
42527: LD_ADDR_OWVAR 38
42531: PUSH
42532: LD_INT 4
42534: ST_TO_ADDR
// animal := CreateVehicle ;
42535: LD_ADDR_VAR 0 12
42539: PUSH
42540: CALL_OW 45
42544: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42545: LD_VAR 0 12
42549: PPUSH
42550: LD_VAR 0 8
42554: PPUSH
42555: LD_INT 0
42557: PPUSH
42558: CALL 44754 0 3
// end ;
42562: GO 42516
42564: POP
42565: POP
// if horses then
42566: LD_VAR 0 5
42570: IFFALSE 42637
// for i = 1 to horses do
42572: LD_ADDR_VAR 0 11
42576: PUSH
42577: DOUBLE
42578: LD_INT 1
42580: DEC
42581: ST_TO_ADDR
42582: LD_VAR 0 5
42586: PUSH
42587: FOR_TO
42588: IFFALSE 42635
// begin hc_class := 21 ;
42590: LD_ADDR_OWVAR 28
42594: PUSH
42595: LD_INT 21
42597: ST_TO_ADDR
// hc_gallery :=  ;
42598: LD_ADDR_OWVAR 33
42602: PUSH
42603: LD_STRING 
42605: ST_TO_ADDR
// animal := CreateHuman ;
42606: LD_ADDR_VAR 0 12
42610: PUSH
42611: CALL_OW 44
42615: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42616: LD_VAR 0 12
42620: PPUSH
42621: LD_VAR 0 8
42625: PPUSH
42626: LD_INT 0
42628: PPUSH
42629: CALL 44754 0 3
// end ;
42633: GO 42587
42635: POP
42636: POP
// if birds then
42637: LD_VAR 0 1
42641: IFFALSE 42708
// for i = 1 to birds do
42643: LD_ADDR_VAR 0 11
42647: PUSH
42648: DOUBLE
42649: LD_INT 1
42651: DEC
42652: ST_TO_ADDR
42653: LD_VAR 0 1
42657: PUSH
42658: FOR_TO
42659: IFFALSE 42706
// begin hc_class = 18 ;
42661: LD_ADDR_OWVAR 28
42665: PUSH
42666: LD_INT 18
42668: ST_TO_ADDR
// hc_gallery =  ;
42669: LD_ADDR_OWVAR 33
42673: PUSH
42674: LD_STRING 
42676: ST_TO_ADDR
// animal := CreateHuman ;
42677: LD_ADDR_VAR 0 12
42681: PUSH
42682: CALL_OW 44
42686: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42687: LD_VAR 0 12
42691: PPUSH
42692: LD_VAR 0 8
42696: PPUSH
42697: LD_INT 0
42699: PPUSH
42700: CALL 44754 0 3
// end ;
42704: GO 42658
42706: POP
42707: POP
// if tigers then
42708: LD_VAR 0 2
42712: IFFALSE 42796
// for i = 1 to tigers do
42714: LD_ADDR_VAR 0 11
42718: PUSH
42719: DOUBLE
42720: LD_INT 1
42722: DEC
42723: ST_TO_ADDR
42724: LD_VAR 0 2
42728: PUSH
42729: FOR_TO
42730: IFFALSE 42794
// begin hc_class = class_tiger ;
42732: LD_ADDR_OWVAR 28
42736: PUSH
42737: LD_INT 14
42739: ST_TO_ADDR
// hc_gallery =  ;
42740: LD_ADDR_OWVAR 33
42744: PUSH
42745: LD_STRING 
42747: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42748: LD_ADDR_OWVAR 35
42752: PUSH
42753: LD_INT 7
42755: NEG
42756: PPUSH
42757: LD_INT 7
42759: PPUSH
42760: CALL_OW 12
42764: ST_TO_ADDR
// animal := CreateHuman ;
42765: LD_ADDR_VAR 0 12
42769: PUSH
42770: CALL_OW 44
42774: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42775: LD_VAR 0 12
42779: PPUSH
42780: LD_VAR 0 8
42784: PPUSH
42785: LD_INT 0
42787: PPUSH
42788: CALL 44754 0 3
// end ;
42792: GO 42729
42794: POP
42795: POP
// if apemans then
42796: LD_VAR 0 3
42800: IFFALSE 42923
// for i = 1 to apemans do
42802: LD_ADDR_VAR 0 11
42806: PUSH
42807: DOUBLE
42808: LD_INT 1
42810: DEC
42811: ST_TO_ADDR
42812: LD_VAR 0 3
42816: PUSH
42817: FOR_TO
42818: IFFALSE 42921
// begin hc_class = class_apeman ;
42820: LD_ADDR_OWVAR 28
42824: PUSH
42825: LD_INT 12
42827: ST_TO_ADDR
// hc_gallery =  ;
42828: LD_ADDR_OWVAR 33
42832: PUSH
42833: LD_STRING 
42835: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42836: LD_ADDR_OWVAR 35
42840: PUSH
42841: LD_INT 5
42843: NEG
42844: PPUSH
42845: LD_INT 5
42847: PPUSH
42848: CALL_OW 12
42852: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42853: LD_ADDR_OWVAR 31
42857: PUSH
42858: LD_INT 1
42860: PPUSH
42861: LD_INT 3
42863: PPUSH
42864: CALL_OW 12
42868: PUSH
42869: LD_INT 1
42871: PPUSH
42872: LD_INT 3
42874: PPUSH
42875: CALL_OW 12
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 0
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: ST_TO_ADDR
// animal := CreateHuman ;
42892: LD_ADDR_VAR 0 12
42896: PUSH
42897: CALL_OW 44
42901: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42902: LD_VAR 0 12
42906: PPUSH
42907: LD_VAR 0 8
42911: PPUSH
42912: LD_INT 0
42914: PPUSH
42915: CALL 44754 0 3
// end ;
42919: GO 42817
42921: POP
42922: POP
// if enchidnas then
42923: LD_VAR 0 4
42927: IFFALSE 42994
// for i = 1 to enchidnas do
42929: LD_ADDR_VAR 0 11
42933: PUSH
42934: DOUBLE
42935: LD_INT 1
42937: DEC
42938: ST_TO_ADDR
42939: LD_VAR 0 4
42943: PUSH
42944: FOR_TO
42945: IFFALSE 42992
// begin hc_class = 13 ;
42947: LD_ADDR_OWVAR 28
42951: PUSH
42952: LD_INT 13
42954: ST_TO_ADDR
// hc_gallery =  ;
42955: LD_ADDR_OWVAR 33
42959: PUSH
42960: LD_STRING 
42962: ST_TO_ADDR
// animal := CreateHuman ;
42963: LD_ADDR_VAR 0 12
42967: PUSH
42968: CALL_OW 44
42972: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42973: LD_VAR 0 12
42977: PPUSH
42978: LD_VAR 0 8
42982: PPUSH
42983: LD_INT 0
42985: PPUSH
42986: CALL 44754 0 3
// end ;
42990: GO 42944
42992: POP
42993: POP
// if fishes then
42994: LD_VAR 0 7
42998: IFFALSE 43065
// for i = 1 to fishes do
43000: LD_ADDR_VAR 0 11
43004: PUSH
43005: DOUBLE
43006: LD_INT 1
43008: DEC
43009: ST_TO_ADDR
43010: LD_VAR 0 7
43014: PUSH
43015: FOR_TO
43016: IFFALSE 43063
// begin hc_class = 20 ;
43018: LD_ADDR_OWVAR 28
43022: PUSH
43023: LD_INT 20
43025: ST_TO_ADDR
// hc_gallery =  ;
43026: LD_ADDR_OWVAR 33
43030: PUSH
43031: LD_STRING 
43033: ST_TO_ADDR
// animal := CreateHuman ;
43034: LD_ADDR_VAR 0 12
43038: PUSH
43039: CALL_OW 44
43043: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43044: LD_VAR 0 12
43048: PPUSH
43049: LD_VAR 0 9
43053: PPUSH
43054: LD_INT 0
43056: PPUSH
43057: CALL 44754 0 3
// end ;
43061: GO 43015
43063: POP
43064: POP
// end ;
43065: LD_VAR 0 10
43069: RET
// export function WantHeal ( sci , unit ) ; begin
43070: LD_INT 0
43072: PPUSH
// if GetTaskList ( sci ) > 0 then
43073: LD_VAR 0 1
43077: PPUSH
43078: CALL_OW 437
43082: PUSH
43083: LD_INT 0
43085: GREATER
43086: IFFALSE 43156
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43088: LD_VAR 0 1
43092: PPUSH
43093: CALL_OW 437
43097: PUSH
43098: LD_INT 1
43100: ARRAY
43101: PUSH
43102: LD_INT 1
43104: ARRAY
43105: PUSH
43106: LD_STRING l
43108: EQUAL
43109: PUSH
43110: LD_VAR 0 1
43114: PPUSH
43115: CALL_OW 437
43119: PUSH
43120: LD_INT 1
43122: ARRAY
43123: PUSH
43124: LD_INT 4
43126: ARRAY
43127: PUSH
43128: LD_VAR 0 2
43132: EQUAL
43133: AND
43134: IFFALSE 43146
// result := true else
43136: LD_ADDR_VAR 0 3
43140: PUSH
43141: LD_INT 1
43143: ST_TO_ADDR
43144: GO 43154
// result := false ;
43146: LD_ADDR_VAR 0 3
43150: PUSH
43151: LD_INT 0
43153: ST_TO_ADDR
// end else
43154: GO 43164
// result := false ;
43156: LD_ADDR_VAR 0 3
43160: PUSH
43161: LD_INT 0
43163: ST_TO_ADDR
// end ;
43164: LD_VAR 0 3
43168: RET
// export function HealTarget ( sci ) ; begin
43169: LD_INT 0
43171: PPUSH
// if not sci then
43172: LD_VAR 0 1
43176: NOT
43177: IFFALSE 43181
// exit ;
43179: GO 43246
// result := 0 ;
43181: LD_ADDR_VAR 0 2
43185: PUSH
43186: LD_INT 0
43188: ST_TO_ADDR
// if GetTaskList ( sci ) then
43189: LD_VAR 0 1
43193: PPUSH
43194: CALL_OW 437
43198: IFFALSE 43246
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43200: LD_VAR 0 1
43204: PPUSH
43205: CALL_OW 437
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_INT 1
43216: ARRAY
43217: PUSH
43218: LD_STRING l
43220: EQUAL
43221: IFFALSE 43246
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43223: LD_ADDR_VAR 0 2
43227: PUSH
43228: LD_VAR 0 1
43232: PPUSH
43233: CALL_OW 437
43237: PUSH
43238: LD_INT 1
43240: ARRAY
43241: PUSH
43242: LD_INT 4
43244: ARRAY
43245: ST_TO_ADDR
// end ;
43246: LD_VAR 0 2
43250: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43251: LD_INT 0
43253: PPUSH
43254: PPUSH
43255: PPUSH
43256: PPUSH
// if not base_units then
43257: LD_VAR 0 1
43261: NOT
43262: IFFALSE 43266
// exit ;
43264: GO 43353
// result := false ;
43266: LD_ADDR_VAR 0 2
43270: PUSH
43271: LD_INT 0
43273: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43274: LD_ADDR_VAR 0 5
43278: PUSH
43279: LD_VAR 0 1
43283: PPUSH
43284: LD_INT 21
43286: PUSH
43287: LD_INT 3
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PPUSH
43294: CALL_OW 72
43298: ST_TO_ADDR
// if not tmp then
43299: LD_VAR 0 5
43303: NOT
43304: IFFALSE 43308
// exit ;
43306: GO 43353
// for i in tmp do
43308: LD_ADDR_VAR 0 3
43312: PUSH
43313: LD_VAR 0 5
43317: PUSH
43318: FOR_IN
43319: IFFALSE 43351
// begin result := EnemyInRange ( i , 22 ) ;
43321: LD_ADDR_VAR 0 2
43325: PUSH
43326: LD_VAR 0 3
43330: PPUSH
43331: LD_INT 22
43333: PPUSH
43334: CALL 41589 0 2
43338: ST_TO_ADDR
// if result then
43339: LD_VAR 0 2
43343: IFFALSE 43349
// exit ;
43345: POP
43346: POP
43347: GO 43353
// end ;
43349: GO 43318
43351: POP
43352: POP
// end ;
43353: LD_VAR 0 2
43357: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43358: LD_INT 0
43360: PPUSH
43361: PPUSH
// if not units then
43362: LD_VAR 0 1
43366: NOT
43367: IFFALSE 43371
// exit ;
43369: GO 43441
// result := [ ] ;
43371: LD_ADDR_VAR 0 3
43375: PUSH
43376: EMPTY
43377: ST_TO_ADDR
// for i in units do
43378: LD_ADDR_VAR 0 4
43382: PUSH
43383: LD_VAR 0 1
43387: PUSH
43388: FOR_IN
43389: IFFALSE 43439
// if GetTag ( i ) = tag then
43391: LD_VAR 0 4
43395: PPUSH
43396: CALL_OW 110
43400: PUSH
43401: LD_VAR 0 2
43405: EQUAL
43406: IFFALSE 43437
// result := Insert ( result , result + 1 , i ) ;
43408: LD_ADDR_VAR 0 3
43412: PUSH
43413: LD_VAR 0 3
43417: PPUSH
43418: LD_VAR 0 3
43422: PUSH
43423: LD_INT 1
43425: PLUS
43426: PPUSH
43427: LD_VAR 0 4
43431: PPUSH
43432: CALL_OW 2
43436: ST_TO_ADDR
43437: GO 43388
43439: POP
43440: POP
// end ;
43441: LD_VAR 0 3
43445: RET
// export function IsDriver ( un ) ; begin
43446: LD_INT 0
43448: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43449: LD_ADDR_VAR 0 2
43453: PUSH
43454: LD_VAR 0 1
43458: PUSH
43459: LD_INT 55
43461: PUSH
43462: EMPTY
43463: LIST
43464: PPUSH
43465: CALL_OW 69
43469: IN
43470: ST_TO_ADDR
// end ;
43471: LD_VAR 0 2
43475: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43476: LD_INT 0
43478: PPUSH
43479: PPUSH
// list := [ ] ;
43480: LD_ADDR_VAR 0 5
43484: PUSH
43485: EMPTY
43486: ST_TO_ADDR
// case d of 0 :
43487: LD_VAR 0 3
43491: PUSH
43492: LD_INT 0
43494: DOUBLE
43495: EQUAL
43496: IFTRUE 43500
43498: GO 43633
43500: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43501: LD_ADDR_VAR 0 5
43505: PUSH
43506: LD_VAR 0 1
43510: PUSH
43511: LD_INT 4
43513: MINUS
43514: PUSH
43515: LD_VAR 0 2
43519: PUSH
43520: LD_INT 4
43522: MINUS
43523: PUSH
43524: LD_INT 2
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: LIST
43531: PUSH
43532: LD_VAR 0 1
43536: PUSH
43537: LD_INT 3
43539: MINUS
43540: PUSH
43541: LD_VAR 0 2
43545: PUSH
43546: LD_INT 1
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: LIST
43553: PUSH
43554: LD_VAR 0 1
43558: PUSH
43559: LD_INT 4
43561: PLUS
43562: PUSH
43563: LD_VAR 0 2
43567: PUSH
43568: LD_INT 4
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: LIST
43575: PUSH
43576: LD_VAR 0 1
43580: PUSH
43581: LD_INT 3
43583: PLUS
43584: PUSH
43585: LD_VAR 0 2
43589: PUSH
43590: LD_INT 3
43592: PLUS
43593: PUSH
43594: LD_INT 5
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: LIST
43601: PUSH
43602: LD_VAR 0 1
43606: PUSH
43607: LD_VAR 0 2
43611: PUSH
43612: LD_INT 4
43614: PLUS
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: LIST
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: LIST
43628: LIST
43629: LIST
43630: ST_TO_ADDR
// end ; 1 :
43631: GO 44331
43633: LD_INT 1
43635: DOUBLE
43636: EQUAL
43637: IFTRUE 43641
43639: GO 43774
43641: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43642: LD_ADDR_VAR 0 5
43646: PUSH
43647: LD_VAR 0 1
43651: PUSH
43652: LD_VAR 0 2
43656: PUSH
43657: LD_INT 4
43659: MINUS
43660: PUSH
43661: LD_INT 3
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PUSH
43669: LD_VAR 0 1
43673: PUSH
43674: LD_INT 3
43676: MINUS
43677: PUSH
43678: LD_VAR 0 2
43682: PUSH
43683: LD_INT 3
43685: MINUS
43686: PUSH
43687: LD_INT 2
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: LIST
43694: PUSH
43695: LD_VAR 0 1
43699: PUSH
43700: LD_INT 4
43702: MINUS
43703: PUSH
43704: LD_VAR 0 2
43708: PUSH
43709: LD_INT 1
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: LIST
43716: PUSH
43717: LD_VAR 0 1
43721: PUSH
43722: LD_VAR 0 2
43726: PUSH
43727: LD_INT 3
43729: PLUS
43730: PUSH
43731: LD_INT 0
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: LIST
43738: PUSH
43739: LD_VAR 0 1
43743: PUSH
43744: LD_INT 4
43746: PLUS
43747: PUSH
43748: LD_VAR 0 2
43752: PUSH
43753: LD_INT 4
43755: PLUS
43756: PUSH
43757: LD_INT 5
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: LIST
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: LIST
43769: LIST
43770: LIST
43771: ST_TO_ADDR
// end ; 2 :
43772: GO 44331
43774: LD_INT 2
43776: DOUBLE
43777: EQUAL
43778: IFTRUE 43782
43780: GO 43911
43782: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43783: LD_ADDR_VAR 0 5
43787: PUSH
43788: LD_VAR 0 1
43792: PUSH
43793: LD_VAR 0 2
43797: PUSH
43798: LD_INT 3
43800: MINUS
43801: PUSH
43802: LD_INT 3
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: LIST
43809: PUSH
43810: LD_VAR 0 1
43814: PUSH
43815: LD_INT 4
43817: PLUS
43818: PUSH
43819: LD_VAR 0 2
43823: PUSH
43824: LD_INT 4
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: LIST
43831: PUSH
43832: LD_VAR 0 1
43836: PUSH
43837: LD_VAR 0 2
43841: PUSH
43842: LD_INT 4
43844: PLUS
43845: PUSH
43846: LD_INT 0
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: LIST
43853: PUSH
43854: LD_VAR 0 1
43858: PUSH
43859: LD_INT 3
43861: MINUS
43862: PUSH
43863: LD_VAR 0 2
43867: PUSH
43868: LD_INT 1
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: LIST
43875: PUSH
43876: LD_VAR 0 1
43880: PUSH
43881: LD_INT 4
43883: MINUS
43884: PUSH
43885: LD_VAR 0 2
43889: PUSH
43890: LD_INT 4
43892: MINUS
43893: PUSH
43894: LD_INT 2
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: LIST
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: ST_TO_ADDR
// end ; 3 :
43909: GO 44331
43911: LD_INT 3
43913: DOUBLE
43914: EQUAL
43915: IFTRUE 43919
43917: GO 44052
43919: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43920: LD_ADDR_VAR 0 5
43924: PUSH
43925: LD_VAR 0 1
43929: PUSH
43930: LD_INT 3
43932: PLUS
43933: PUSH
43934: LD_VAR 0 2
43938: PUSH
43939: LD_INT 4
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: LIST
43946: PUSH
43947: LD_VAR 0 1
43951: PUSH
43952: LD_INT 4
43954: PLUS
43955: PUSH
43956: LD_VAR 0 2
43960: PUSH
43961: LD_INT 4
43963: PLUS
43964: PUSH
43965: LD_INT 5
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: LIST
43972: PUSH
43973: LD_VAR 0 1
43977: PUSH
43978: LD_INT 4
43980: MINUS
43981: PUSH
43982: LD_VAR 0 2
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: LIST
43994: PUSH
43995: LD_VAR 0 1
43999: PUSH
44000: LD_VAR 0 2
44004: PUSH
44005: LD_INT 4
44007: MINUS
44008: PUSH
44009: LD_INT 3
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: LIST
44016: PUSH
44017: LD_VAR 0 1
44021: PUSH
44022: LD_INT 3
44024: MINUS
44025: PUSH
44026: LD_VAR 0 2
44030: PUSH
44031: LD_INT 3
44033: MINUS
44034: PUSH
44035: LD_INT 2
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: LIST
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: LIST
44047: LIST
44048: LIST
44049: ST_TO_ADDR
// end ; 4 :
44050: GO 44331
44052: LD_INT 4
44054: DOUBLE
44055: EQUAL
44056: IFTRUE 44060
44058: GO 44193
44060: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44061: LD_ADDR_VAR 0 5
44065: PUSH
44066: LD_VAR 0 1
44070: PUSH
44071: LD_VAR 0 2
44075: PUSH
44076: LD_INT 4
44078: PLUS
44079: PUSH
44080: LD_INT 0
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: LIST
44087: PUSH
44088: LD_VAR 0 1
44092: PUSH
44093: LD_INT 3
44095: PLUS
44096: PUSH
44097: LD_VAR 0 2
44101: PUSH
44102: LD_INT 3
44104: PLUS
44105: PUSH
44106: LD_INT 5
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: LIST
44113: PUSH
44114: LD_VAR 0 1
44118: PUSH
44119: LD_INT 4
44121: PLUS
44122: PUSH
44123: LD_VAR 0 2
44127: PUSH
44128: LD_INT 4
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: LIST
44135: PUSH
44136: LD_VAR 0 1
44140: PUSH
44141: LD_VAR 0 2
44145: PUSH
44146: LD_INT 3
44148: MINUS
44149: PUSH
44150: LD_INT 3
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: LIST
44157: PUSH
44158: LD_VAR 0 1
44162: PUSH
44163: LD_INT 4
44165: MINUS
44166: PUSH
44167: LD_VAR 0 2
44171: PUSH
44172: LD_INT 4
44174: MINUS
44175: PUSH
44176: LD_INT 2
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: LIST
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: ST_TO_ADDR
// end ; 5 :
44191: GO 44331
44193: LD_INT 5
44195: DOUBLE
44196: EQUAL
44197: IFTRUE 44201
44199: GO 44330
44201: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44202: LD_ADDR_VAR 0 5
44206: PUSH
44207: LD_VAR 0 1
44211: PUSH
44212: LD_INT 4
44214: MINUS
44215: PUSH
44216: LD_VAR 0 2
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: LIST
44228: PUSH
44229: LD_VAR 0 1
44233: PUSH
44234: LD_VAR 0 2
44238: PUSH
44239: LD_INT 4
44241: MINUS
44242: PUSH
44243: LD_INT 3
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: LIST
44250: PUSH
44251: LD_VAR 0 1
44255: PUSH
44256: LD_INT 4
44258: PLUS
44259: PUSH
44260: LD_VAR 0 2
44264: PUSH
44265: LD_INT 4
44267: PLUS
44268: PUSH
44269: LD_INT 5
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: LIST
44276: PUSH
44277: LD_VAR 0 1
44281: PUSH
44282: LD_INT 3
44284: PLUS
44285: PUSH
44286: LD_VAR 0 2
44290: PUSH
44291: LD_INT 4
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: LIST
44298: PUSH
44299: LD_VAR 0 1
44303: PUSH
44304: LD_VAR 0 2
44308: PUSH
44309: LD_INT 3
44311: PLUS
44312: PUSH
44313: LD_INT 0
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: LIST
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: ST_TO_ADDR
// end ; end ;
44328: GO 44331
44330: POP
// result := list ;
44331: LD_ADDR_VAR 0 4
44335: PUSH
44336: LD_VAR 0 5
44340: ST_TO_ADDR
// end ;
44341: LD_VAR 0 4
44345: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44346: LD_INT 0
44348: PPUSH
44349: PPUSH
44350: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44351: LD_VAR 0 1
44355: NOT
44356: PUSH
44357: LD_VAR 0 2
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: LD_INT 2
44367: PUSH
44368: LD_INT 3
44370: PUSH
44371: LD_INT 4
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: IN
44380: NOT
44381: OR
44382: IFFALSE 44386
// exit ;
44384: GO 44478
// tmp := [ ] ;
44386: LD_ADDR_VAR 0 5
44390: PUSH
44391: EMPTY
44392: ST_TO_ADDR
// for i in units do
44393: LD_ADDR_VAR 0 4
44397: PUSH
44398: LD_VAR 0 1
44402: PUSH
44403: FOR_IN
44404: IFFALSE 44447
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44406: LD_ADDR_VAR 0 5
44410: PUSH
44411: LD_VAR 0 5
44415: PPUSH
44416: LD_VAR 0 5
44420: PUSH
44421: LD_INT 1
44423: PLUS
44424: PPUSH
44425: LD_VAR 0 4
44429: PPUSH
44430: LD_VAR 0 2
44434: PPUSH
44435: CALL_OW 259
44439: PPUSH
44440: CALL_OW 2
44444: ST_TO_ADDR
44445: GO 44403
44447: POP
44448: POP
// if not tmp then
44449: LD_VAR 0 5
44453: NOT
44454: IFFALSE 44458
// exit ;
44456: GO 44478
// result := SortListByListDesc ( units , tmp ) ;
44458: LD_ADDR_VAR 0 3
44462: PUSH
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 5
44472: PPUSH
44473: CALL_OW 77
44477: ST_TO_ADDR
// end ;
44478: LD_VAR 0 3
44482: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44483: LD_INT 0
44485: PPUSH
44486: PPUSH
44487: PPUSH
// result := false ;
44488: LD_ADDR_VAR 0 3
44492: PUSH
44493: LD_INT 0
44495: ST_TO_ADDR
// x := GetX ( building ) ;
44496: LD_ADDR_VAR 0 4
44500: PUSH
44501: LD_VAR 0 2
44505: PPUSH
44506: CALL_OW 250
44510: ST_TO_ADDR
// y := GetY ( building ) ;
44511: LD_ADDR_VAR 0 5
44515: PUSH
44516: LD_VAR 0 2
44520: PPUSH
44521: CALL_OW 251
44525: ST_TO_ADDR
// if not building or not x or not y then
44526: LD_VAR 0 2
44530: NOT
44531: PUSH
44532: LD_VAR 0 4
44536: NOT
44537: OR
44538: PUSH
44539: LD_VAR 0 5
44543: NOT
44544: OR
44545: IFFALSE 44549
// exit ;
44547: GO 44641
// if GetTaskList ( unit ) then
44549: LD_VAR 0 1
44553: PPUSH
44554: CALL_OW 437
44558: IFFALSE 44641
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44560: LD_STRING e
44562: PUSH
44563: LD_VAR 0 1
44567: PPUSH
44568: CALL_OW 437
44572: PUSH
44573: LD_INT 1
44575: ARRAY
44576: PUSH
44577: LD_INT 1
44579: ARRAY
44580: EQUAL
44581: PUSH
44582: LD_VAR 0 4
44586: PUSH
44587: LD_VAR 0 1
44591: PPUSH
44592: CALL_OW 437
44596: PUSH
44597: LD_INT 1
44599: ARRAY
44600: PUSH
44601: LD_INT 2
44603: ARRAY
44604: EQUAL
44605: AND
44606: PUSH
44607: LD_VAR 0 5
44611: PUSH
44612: LD_VAR 0 1
44616: PPUSH
44617: CALL_OW 437
44621: PUSH
44622: LD_INT 1
44624: ARRAY
44625: PUSH
44626: LD_INT 3
44628: ARRAY
44629: EQUAL
44630: AND
44631: IFFALSE 44641
// result := true end ;
44633: LD_ADDR_VAR 0 3
44637: PUSH
44638: LD_INT 1
44640: ST_TO_ADDR
// end ;
44641: LD_VAR 0 3
44645: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44646: LD_INT 0
44648: PPUSH
// result := false ;
44649: LD_ADDR_VAR 0 4
44653: PUSH
44654: LD_INT 0
44656: ST_TO_ADDR
// if GetTaskList ( unit ) then
44657: LD_VAR 0 1
44661: PPUSH
44662: CALL_OW 437
44666: IFFALSE 44749
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44668: LD_STRING M
44670: PUSH
44671: LD_VAR 0 1
44675: PPUSH
44676: CALL_OW 437
44680: PUSH
44681: LD_INT 1
44683: ARRAY
44684: PUSH
44685: LD_INT 1
44687: ARRAY
44688: EQUAL
44689: PUSH
44690: LD_VAR 0 2
44694: PUSH
44695: LD_VAR 0 1
44699: PPUSH
44700: CALL_OW 437
44704: PUSH
44705: LD_INT 1
44707: ARRAY
44708: PUSH
44709: LD_INT 2
44711: ARRAY
44712: EQUAL
44713: AND
44714: PUSH
44715: LD_VAR 0 3
44719: PUSH
44720: LD_VAR 0 1
44724: PPUSH
44725: CALL_OW 437
44729: PUSH
44730: LD_INT 1
44732: ARRAY
44733: PUSH
44734: LD_INT 3
44736: ARRAY
44737: EQUAL
44738: AND
44739: IFFALSE 44749
// result := true ;
44741: LD_ADDR_VAR 0 4
44745: PUSH
44746: LD_INT 1
44748: ST_TO_ADDR
// end ; end ;
44749: LD_VAR 0 4
44753: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44754: LD_INT 0
44756: PPUSH
44757: PPUSH
44758: PPUSH
44759: PPUSH
// if not unit or not area then
44760: LD_VAR 0 1
44764: NOT
44765: PUSH
44766: LD_VAR 0 2
44770: NOT
44771: OR
44772: IFFALSE 44776
// exit ;
44774: GO 44940
// tmp := AreaToList ( area , i ) ;
44776: LD_ADDR_VAR 0 6
44780: PUSH
44781: LD_VAR 0 2
44785: PPUSH
44786: LD_VAR 0 5
44790: PPUSH
44791: CALL_OW 517
44795: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44796: LD_ADDR_VAR 0 5
44800: PUSH
44801: DOUBLE
44802: LD_INT 1
44804: DEC
44805: ST_TO_ADDR
44806: LD_VAR 0 6
44810: PUSH
44811: LD_INT 1
44813: ARRAY
44814: PUSH
44815: FOR_TO
44816: IFFALSE 44938
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44818: LD_ADDR_VAR 0 7
44822: PUSH
44823: LD_VAR 0 6
44827: PUSH
44828: LD_INT 1
44830: ARRAY
44831: PUSH
44832: LD_VAR 0 5
44836: ARRAY
44837: PUSH
44838: LD_VAR 0 6
44842: PUSH
44843: LD_INT 2
44845: ARRAY
44846: PUSH
44847: LD_VAR 0 5
44851: ARRAY
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44857: LD_VAR 0 7
44861: PUSH
44862: LD_INT 1
44864: ARRAY
44865: PPUSH
44866: LD_VAR 0 7
44870: PUSH
44871: LD_INT 2
44873: ARRAY
44874: PPUSH
44875: CALL_OW 428
44879: PUSH
44880: LD_INT 0
44882: EQUAL
44883: IFFALSE 44936
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44885: LD_VAR 0 1
44889: PPUSH
44890: LD_VAR 0 7
44894: PUSH
44895: LD_INT 1
44897: ARRAY
44898: PPUSH
44899: LD_VAR 0 7
44903: PUSH
44904: LD_INT 2
44906: ARRAY
44907: PPUSH
44908: LD_VAR 0 3
44912: PPUSH
44913: CALL_OW 48
// result := IsPlaced ( unit ) ;
44917: LD_ADDR_VAR 0 4
44921: PUSH
44922: LD_VAR 0 1
44926: PPUSH
44927: CALL_OW 305
44931: ST_TO_ADDR
// exit ;
44932: POP
44933: POP
44934: GO 44940
// end ; end ;
44936: GO 44815
44938: POP
44939: POP
// end ;
44940: LD_VAR 0 4
44944: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44945: LD_INT 0
44947: PPUSH
44948: PPUSH
44949: PPUSH
// if not side or side > 8 then
44950: LD_VAR 0 1
44954: NOT
44955: PUSH
44956: LD_VAR 0 1
44960: PUSH
44961: LD_INT 8
44963: GREATER
44964: OR
44965: IFFALSE 44969
// exit ;
44967: GO 45156
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44969: LD_ADDR_VAR 0 4
44973: PUSH
44974: LD_INT 22
44976: PUSH
44977: LD_VAR 0 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 21
44988: PUSH
44989: LD_INT 3
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PPUSH
45000: CALL_OW 69
45004: ST_TO_ADDR
// if not tmp then
45005: LD_VAR 0 4
45009: NOT
45010: IFFALSE 45014
// exit ;
45012: GO 45156
// enable_addtolog := true ;
45014: LD_ADDR_OWVAR 81
45018: PUSH
45019: LD_INT 1
45021: ST_TO_ADDR
// AddToLog ( [ ) ;
45022: LD_STRING [
45024: PPUSH
45025: CALL_OW 561
// for i in tmp do
45029: LD_ADDR_VAR 0 3
45033: PUSH
45034: LD_VAR 0 4
45038: PUSH
45039: FOR_IN
45040: IFFALSE 45147
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45042: LD_STRING [
45044: PUSH
45045: LD_VAR 0 3
45049: PPUSH
45050: CALL_OW 266
45054: STR
45055: PUSH
45056: LD_STRING , 
45058: STR
45059: PUSH
45060: LD_VAR 0 3
45064: PPUSH
45065: CALL_OW 250
45069: STR
45070: PUSH
45071: LD_STRING , 
45073: STR
45074: PUSH
45075: LD_VAR 0 3
45079: PPUSH
45080: CALL_OW 251
45084: STR
45085: PUSH
45086: LD_STRING , 
45088: STR
45089: PUSH
45090: LD_VAR 0 3
45094: PPUSH
45095: CALL_OW 254
45099: STR
45100: PUSH
45101: LD_STRING , 
45103: STR
45104: PUSH
45105: LD_VAR 0 3
45109: PPUSH
45110: LD_INT 1
45112: PPUSH
45113: CALL_OW 268
45117: STR
45118: PUSH
45119: LD_STRING , 
45121: STR
45122: PUSH
45123: LD_VAR 0 3
45127: PPUSH
45128: LD_INT 2
45130: PPUSH
45131: CALL_OW 268
45135: STR
45136: PUSH
45137: LD_STRING ],
45139: STR
45140: PPUSH
45141: CALL_OW 561
// end ;
45145: GO 45039
45147: POP
45148: POP
// AddToLog ( ]; ) ;
45149: LD_STRING ];
45151: PPUSH
45152: CALL_OW 561
// end ;
45156: LD_VAR 0 2
45160: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45161: LD_INT 0
45163: PPUSH
45164: PPUSH
45165: PPUSH
45166: PPUSH
45167: PPUSH
// if not area or not rate or not max then
45168: LD_VAR 0 1
45172: NOT
45173: PUSH
45174: LD_VAR 0 2
45178: NOT
45179: OR
45180: PUSH
45181: LD_VAR 0 4
45185: NOT
45186: OR
45187: IFFALSE 45191
// exit ;
45189: GO 45383
// while 1 do
45191: LD_INT 1
45193: IFFALSE 45383
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45195: LD_ADDR_VAR 0 9
45199: PUSH
45200: LD_VAR 0 1
45204: PPUSH
45205: LD_INT 1
45207: PPUSH
45208: CALL_OW 287
45212: PUSH
45213: LD_INT 10
45215: MUL
45216: ST_TO_ADDR
// r := rate / 10 ;
45217: LD_ADDR_VAR 0 7
45221: PUSH
45222: LD_VAR 0 2
45226: PUSH
45227: LD_INT 10
45229: DIVREAL
45230: ST_TO_ADDR
// time := 1 1$00 ;
45231: LD_ADDR_VAR 0 8
45235: PUSH
45236: LD_INT 2100
45238: ST_TO_ADDR
// if amount < min then
45239: LD_VAR 0 9
45243: PUSH
45244: LD_VAR 0 3
45248: LESS
45249: IFFALSE 45267
// r := r * 2 else
45251: LD_ADDR_VAR 0 7
45255: PUSH
45256: LD_VAR 0 7
45260: PUSH
45261: LD_INT 2
45263: MUL
45264: ST_TO_ADDR
45265: GO 45293
// if amount > max then
45267: LD_VAR 0 9
45271: PUSH
45272: LD_VAR 0 4
45276: GREATER
45277: IFFALSE 45293
// r := r / 2 ;
45279: LD_ADDR_VAR 0 7
45283: PUSH
45284: LD_VAR 0 7
45288: PUSH
45289: LD_INT 2
45291: DIVREAL
45292: ST_TO_ADDR
// time := time / r ;
45293: LD_ADDR_VAR 0 8
45297: PUSH
45298: LD_VAR 0 8
45302: PUSH
45303: LD_VAR 0 7
45307: DIVREAL
45308: ST_TO_ADDR
// if time < 0 then
45309: LD_VAR 0 8
45313: PUSH
45314: LD_INT 0
45316: LESS
45317: IFFALSE 45334
// time := time * - 1 ;
45319: LD_ADDR_VAR 0 8
45323: PUSH
45324: LD_VAR 0 8
45328: PUSH
45329: LD_INT 1
45331: NEG
45332: MUL
45333: ST_TO_ADDR
// wait ( time ) ;
45334: LD_VAR 0 8
45338: PPUSH
45339: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45343: LD_INT 35
45345: PPUSH
45346: LD_INT 875
45348: PPUSH
45349: CALL_OW 12
45353: PPUSH
45354: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45358: LD_INT 1
45360: PPUSH
45361: LD_INT 5
45363: PPUSH
45364: CALL_OW 12
45368: PPUSH
45369: LD_VAR 0 1
45373: PPUSH
45374: LD_INT 1
45376: PPUSH
45377: CALL_OW 55
// end ;
45381: GO 45191
// end ;
45383: LD_VAR 0 5
45387: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45388: LD_INT 0
45390: PPUSH
45391: PPUSH
45392: PPUSH
45393: PPUSH
45394: PPUSH
45395: PPUSH
45396: PPUSH
45397: PPUSH
// if not turrets or not factories then
45398: LD_VAR 0 1
45402: NOT
45403: PUSH
45404: LD_VAR 0 2
45408: NOT
45409: OR
45410: IFFALSE 45414
// exit ;
45412: GO 45721
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45414: LD_ADDR_VAR 0 10
45418: PUSH
45419: LD_INT 5
45421: PUSH
45422: LD_INT 6
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 2
45431: PUSH
45432: LD_INT 4
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: LD_INT 5
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 24
45456: PUSH
45457: LD_INT 25
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 23
45466: PUSH
45467: LD_INT 27
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: LD_INT 42
45480: PUSH
45481: LD_INT 43
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 44
45490: PUSH
45491: LD_INT 46
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 45
45500: PUSH
45501: LD_INT 47
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: EMPTY
45509: LIST
45510: LIST
45511: LIST
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: LIST
45517: ST_TO_ADDR
// result := [ ] ;
45518: LD_ADDR_VAR 0 3
45522: PUSH
45523: EMPTY
45524: ST_TO_ADDR
// for i in turrets do
45525: LD_ADDR_VAR 0 4
45529: PUSH
45530: LD_VAR 0 1
45534: PUSH
45535: FOR_IN
45536: IFFALSE 45719
// begin nat := GetNation ( i ) ;
45538: LD_ADDR_VAR 0 7
45542: PUSH
45543: LD_VAR 0 4
45547: PPUSH
45548: CALL_OW 248
45552: ST_TO_ADDR
// weapon := 0 ;
45553: LD_ADDR_VAR 0 8
45557: PUSH
45558: LD_INT 0
45560: ST_TO_ADDR
// if not nat then
45561: LD_VAR 0 7
45565: NOT
45566: IFFALSE 45570
// continue ;
45568: GO 45535
// for j in list [ nat ] do
45570: LD_ADDR_VAR 0 5
45574: PUSH
45575: LD_VAR 0 10
45579: PUSH
45580: LD_VAR 0 7
45584: ARRAY
45585: PUSH
45586: FOR_IN
45587: IFFALSE 45628
// if GetBWeapon ( i ) = j [ 1 ] then
45589: LD_VAR 0 4
45593: PPUSH
45594: CALL_OW 269
45598: PUSH
45599: LD_VAR 0 5
45603: PUSH
45604: LD_INT 1
45606: ARRAY
45607: EQUAL
45608: IFFALSE 45626
// begin weapon := j [ 2 ] ;
45610: LD_ADDR_VAR 0 8
45614: PUSH
45615: LD_VAR 0 5
45619: PUSH
45620: LD_INT 2
45622: ARRAY
45623: ST_TO_ADDR
// break ;
45624: GO 45628
// end ;
45626: GO 45586
45628: POP
45629: POP
// if not weapon then
45630: LD_VAR 0 8
45634: NOT
45635: IFFALSE 45639
// continue ;
45637: GO 45535
// for k in factories do
45639: LD_ADDR_VAR 0 6
45643: PUSH
45644: LD_VAR 0 2
45648: PUSH
45649: FOR_IN
45650: IFFALSE 45715
// begin weapons := AvailableWeaponList ( k ) ;
45652: LD_ADDR_VAR 0 9
45656: PUSH
45657: LD_VAR 0 6
45661: PPUSH
45662: CALL_OW 478
45666: ST_TO_ADDR
// if not weapons then
45667: LD_VAR 0 9
45671: NOT
45672: IFFALSE 45676
// continue ;
45674: GO 45649
// if weapon in weapons then
45676: LD_VAR 0 8
45680: PUSH
45681: LD_VAR 0 9
45685: IN
45686: IFFALSE 45713
// begin result := [ i , weapon ] ;
45688: LD_ADDR_VAR 0 3
45692: PUSH
45693: LD_VAR 0 4
45697: PUSH
45698: LD_VAR 0 8
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: ST_TO_ADDR
// exit ;
45707: POP
45708: POP
45709: POP
45710: POP
45711: GO 45721
// end ; end ;
45713: GO 45649
45715: POP
45716: POP
// end ;
45717: GO 45535
45719: POP
45720: POP
// end ;
45721: LD_VAR 0 3
45725: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45726: LD_INT 0
45728: PPUSH
// if not side or side > 8 then
45729: LD_VAR 0 3
45733: NOT
45734: PUSH
45735: LD_VAR 0 3
45739: PUSH
45740: LD_INT 8
45742: GREATER
45743: OR
45744: IFFALSE 45748
// exit ;
45746: GO 45807
// if not range then
45748: LD_VAR 0 4
45752: NOT
45753: IFFALSE 45764
// range := - 12 ;
45755: LD_ADDR_VAR 0 4
45759: PUSH
45760: LD_INT 12
45762: NEG
45763: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45764: LD_VAR 0 1
45768: PPUSH
45769: LD_VAR 0 2
45773: PPUSH
45774: LD_VAR 0 3
45778: PPUSH
45779: LD_VAR 0 4
45783: PPUSH
45784: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45788: LD_VAR 0 1
45792: PPUSH
45793: LD_VAR 0 2
45797: PPUSH
45798: LD_VAR 0 3
45802: PPUSH
45803: CALL_OW 331
// end ;
45807: LD_VAR 0 5
45811: RET
// export function Video ( mode ) ; begin
45812: LD_INT 0
45814: PPUSH
// ingame_video = mode ;
45815: LD_ADDR_OWVAR 52
45819: PUSH
45820: LD_VAR 0 1
45824: ST_TO_ADDR
// interface_hidden = mode ;
45825: LD_ADDR_OWVAR 54
45829: PUSH
45830: LD_VAR 0 1
45834: ST_TO_ADDR
// end ;
45835: LD_VAR 0 2
45839: RET
// export function Join ( array , element ) ; begin
45840: LD_INT 0
45842: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45843: LD_ADDR_VAR 0 3
45847: PUSH
45848: LD_VAR 0 1
45852: PPUSH
45853: LD_VAR 0 1
45857: PUSH
45858: LD_INT 1
45860: PLUS
45861: PPUSH
45862: LD_VAR 0 2
45866: PPUSH
45867: CALL_OW 1
45871: ST_TO_ADDR
// end ;
45872: LD_VAR 0 3
45876: RET
// export function JoinUnion ( array , element ) ; begin
45877: LD_INT 0
45879: PPUSH
// result := array union element ;
45880: LD_ADDR_VAR 0 3
45884: PUSH
45885: LD_VAR 0 1
45889: PUSH
45890: LD_VAR 0 2
45894: UNION
45895: ST_TO_ADDR
// end ;
45896: LD_VAR 0 3
45900: RET
// export function GetBehemoths ( side ) ; begin
45901: LD_INT 0
45903: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45904: LD_ADDR_VAR 0 2
45908: PUSH
45909: LD_INT 22
45911: PUSH
45912: LD_VAR 0 1
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 31
45923: PUSH
45924: LD_INT 25
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: PPUSH
45935: CALL_OW 69
45939: ST_TO_ADDR
// end ;
45940: LD_VAR 0 2
45944: RET
// export function Shuffle ( array ) ; var i , index ; begin
45945: LD_INT 0
45947: PPUSH
45948: PPUSH
45949: PPUSH
// result := [ ] ;
45950: LD_ADDR_VAR 0 2
45954: PUSH
45955: EMPTY
45956: ST_TO_ADDR
// if not array then
45957: LD_VAR 0 1
45961: NOT
45962: IFFALSE 45966
// exit ;
45964: GO 46065
// Randomize ;
45966: CALL_OW 10
// for i = array downto 1 do
45970: LD_ADDR_VAR 0 3
45974: PUSH
45975: DOUBLE
45976: LD_VAR 0 1
45980: INC
45981: ST_TO_ADDR
45982: LD_INT 1
45984: PUSH
45985: FOR_DOWNTO
45986: IFFALSE 46063
// begin index := rand ( 1 , array ) ;
45988: LD_ADDR_VAR 0 4
45992: PUSH
45993: LD_INT 1
45995: PPUSH
45996: LD_VAR 0 1
46000: PPUSH
46001: CALL_OW 12
46005: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46006: LD_ADDR_VAR 0 2
46010: PUSH
46011: LD_VAR 0 2
46015: PPUSH
46016: LD_VAR 0 2
46020: PUSH
46021: LD_INT 1
46023: PLUS
46024: PPUSH
46025: LD_VAR 0 1
46029: PUSH
46030: LD_VAR 0 4
46034: ARRAY
46035: PPUSH
46036: CALL_OW 2
46040: ST_TO_ADDR
// array := Delete ( array , index ) ;
46041: LD_ADDR_VAR 0 1
46045: PUSH
46046: LD_VAR 0 1
46050: PPUSH
46051: LD_VAR 0 4
46055: PPUSH
46056: CALL_OW 3
46060: ST_TO_ADDR
// end ;
46061: GO 45985
46063: POP
46064: POP
// end ;
46065: LD_VAR 0 2
46069: RET
// export function GetBaseMaterials ( base ) ; begin
46070: LD_INT 0
46072: PPUSH
// result := [ 0 , 0 , 0 ] ;
46073: LD_ADDR_VAR 0 2
46077: PUSH
46078: LD_INT 0
46080: PUSH
46081: LD_INT 0
46083: PUSH
46084: LD_INT 0
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: LIST
46091: ST_TO_ADDR
// if not base then
46092: LD_VAR 0 1
46096: NOT
46097: IFFALSE 46101
// exit ;
46099: GO 46150
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46101: LD_ADDR_VAR 0 2
46105: PUSH
46106: LD_VAR 0 1
46110: PPUSH
46111: LD_INT 1
46113: PPUSH
46114: CALL_OW 275
46118: PUSH
46119: LD_VAR 0 1
46123: PPUSH
46124: LD_INT 2
46126: PPUSH
46127: CALL_OW 275
46131: PUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: LD_INT 3
46139: PPUSH
46140: CALL_OW 275
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// end ;
46150: LD_VAR 0 2
46154: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
// result := array ;
46159: LD_ADDR_VAR 0 3
46163: PUSH
46164: LD_VAR 0 1
46168: ST_TO_ADDR
// if size > 0 then
46169: LD_VAR 0 2
46173: PUSH
46174: LD_INT 0
46176: GREATER
46177: IFFALSE 46223
// for i := array downto size do
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: DOUBLE
46185: LD_VAR 0 1
46189: INC
46190: ST_TO_ADDR
46191: LD_VAR 0 2
46195: PUSH
46196: FOR_DOWNTO
46197: IFFALSE 46221
// result := Delete ( result , result ) ;
46199: LD_ADDR_VAR 0 3
46203: PUSH
46204: LD_VAR 0 3
46208: PPUSH
46209: LD_VAR 0 3
46213: PPUSH
46214: CALL_OW 3
46218: ST_TO_ADDR
46219: GO 46196
46221: POP
46222: POP
// end ;
46223: LD_VAR 0 3
46227: RET
// export function ComExit ( unit ) ; var tmp ; begin
46228: LD_INT 0
46230: PPUSH
46231: PPUSH
// if not IsInUnit ( unit ) then
46232: LD_VAR 0 1
46236: PPUSH
46237: CALL_OW 310
46241: NOT
46242: IFFALSE 46246
// exit ;
46244: GO 46306
// tmp := IsInUnit ( unit ) ;
46246: LD_ADDR_VAR 0 3
46250: PUSH
46251: LD_VAR 0 1
46255: PPUSH
46256: CALL_OW 310
46260: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46261: LD_VAR 0 3
46265: PPUSH
46266: CALL_OW 247
46270: PUSH
46271: LD_INT 2
46273: EQUAL
46274: IFFALSE 46287
// ComExitVehicle ( unit ) else
46276: LD_VAR 0 1
46280: PPUSH
46281: CALL_OW 121
46285: GO 46296
// ComExitBuilding ( unit ) ;
46287: LD_VAR 0 1
46291: PPUSH
46292: CALL_OW 122
// result := tmp ;
46296: LD_ADDR_VAR 0 2
46300: PUSH
46301: LD_VAR 0 3
46305: ST_TO_ADDR
// end ;
46306: LD_VAR 0 2
46310: RET
// export function ResetHc ; begin
46311: LD_INT 0
46313: PPUSH
// InitHc ;
46314: CALL_OW 19
// hc_importance := 0 ;
46318: LD_ADDR_OWVAR 32
46322: PUSH
46323: LD_INT 0
46325: ST_TO_ADDR
// end ;
46326: LD_VAR 0 1
46330: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46331: LD_INT 0
46333: PPUSH
46334: PPUSH
46335: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46336: LD_ADDR_VAR 0 6
46340: PUSH
46341: LD_VAR 0 1
46345: PUSH
46346: LD_VAR 0 3
46350: PLUS
46351: PUSH
46352: LD_INT 2
46354: DIV
46355: ST_TO_ADDR
// if _x < 0 then
46356: LD_VAR 0 6
46360: PUSH
46361: LD_INT 0
46363: LESS
46364: IFFALSE 46381
// _x := _x * - 1 ;
46366: LD_ADDR_VAR 0 6
46370: PUSH
46371: LD_VAR 0 6
46375: PUSH
46376: LD_INT 1
46378: NEG
46379: MUL
46380: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46381: LD_ADDR_VAR 0 7
46385: PUSH
46386: LD_VAR 0 2
46390: PUSH
46391: LD_VAR 0 4
46395: PLUS
46396: PUSH
46397: LD_INT 2
46399: DIV
46400: ST_TO_ADDR
// if _y < 0 then
46401: LD_VAR 0 7
46405: PUSH
46406: LD_INT 0
46408: LESS
46409: IFFALSE 46426
// _y := _y * - 1 ;
46411: LD_ADDR_VAR 0 7
46415: PUSH
46416: LD_VAR 0 7
46420: PUSH
46421: LD_INT 1
46423: NEG
46424: MUL
46425: ST_TO_ADDR
// result := [ _x , _y ] ;
46426: LD_ADDR_VAR 0 5
46430: PUSH
46431: LD_VAR 0 6
46435: PUSH
46436: LD_VAR 0 7
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: ST_TO_ADDR
// end ;
46445: LD_VAR 0 5
46449: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46450: LD_INT 0
46452: PPUSH
46453: PPUSH
46454: PPUSH
46455: PPUSH
// task := GetTaskList ( unit ) ;
46456: LD_ADDR_VAR 0 7
46460: PUSH
46461: LD_VAR 0 1
46465: PPUSH
46466: CALL_OW 437
46470: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46471: LD_VAR 0 7
46475: NOT
46476: PUSH
46477: LD_VAR 0 1
46481: PPUSH
46482: LD_VAR 0 2
46486: PPUSH
46487: CALL_OW 308
46491: NOT
46492: AND
46493: IFFALSE 46497
// exit ;
46495: GO 46615
// if IsInArea ( unit , area ) then
46497: LD_VAR 0 1
46501: PPUSH
46502: LD_VAR 0 2
46506: PPUSH
46507: CALL_OW 308
46511: IFFALSE 46529
// begin ComMoveToArea ( unit , goAway ) ;
46513: LD_VAR 0 1
46517: PPUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: CALL_OW 113
// exit ;
46527: GO 46615
// end ; if task [ 1 ] [ 1 ] <> M then
46529: LD_VAR 0 7
46533: PUSH
46534: LD_INT 1
46536: ARRAY
46537: PUSH
46538: LD_INT 1
46540: ARRAY
46541: PUSH
46542: LD_STRING M
46544: NONEQUAL
46545: IFFALSE 46549
// exit ;
46547: GO 46615
// x := task [ 1 ] [ 2 ] ;
46549: LD_ADDR_VAR 0 5
46553: PUSH
46554: LD_VAR 0 7
46558: PUSH
46559: LD_INT 1
46561: ARRAY
46562: PUSH
46563: LD_INT 2
46565: ARRAY
46566: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46567: LD_ADDR_VAR 0 6
46571: PUSH
46572: LD_VAR 0 7
46576: PUSH
46577: LD_INT 1
46579: ARRAY
46580: PUSH
46581: LD_INT 3
46583: ARRAY
46584: ST_TO_ADDR
// if InArea ( x , y , area ) then
46585: LD_VAR 0 5
46589: PPUSH
46590: LD_VAR 0 6
46594: PPUSH
46595: LD_VAR 0 2
46599: PPUSH
46600: CALL_OW 309
46604: IFFALSE 46615
// ComStop ( unit ) ;
46606: LD_VAR 0 1
46610: PPUSH
46611: CALL_OW 141
// end ;
46615: LD_VAR 0 4
46619: RET
// export function Abs ( value ) ; begin
46620: LD_INT 0
46622: PPUSH
// result := value ;
46623: LD_ADDR_VAR 0 2
46627: PUSH
46628: LD_VAR 0 1
46632: ST_TO_ADDR
// if value < 0 then
46633: LD_VAR 0 1
46637: PUSH
46638: LD_INT 0
46640: LESS
46641: IFFALSE 46658
// result := value * - 1 ;
46643: LD_ADDR_VAR 0 2
46647: PUSH
46648: LD_VAR 0 1
46652: PUSH
46653: LD_INT 1
46655: NEG
46656: MUL
46657: ST_TO_ADDR
// end ;
46658: LD_VAR 0 2
46662: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46663: LD_INT 0
46665: PPUSH
46666: PPUSH
46667: PPUSH
46668: PPUSH
46669: PPUSH
46670: PPUSH
46671: PPUSH
46672: PPUSH
// if not unit or not building then
46673: LD_VAR 0 1
46677: NOT
46678: PUSH
46679: LD_VAR 0 2
46683: NOT
46684: OR
46685: IFFALSE 46689
// exit ;
46687: GO 46915
// x := GetX ( building ) ;
46689: LD_ADDR_VAR 0 4
46693: PUSH
46694: LD_VAR 0 2
46698: PPUSH
46699: CALL_OW 250
46703: ST_TO_ADDR
// y := GetY ( building ) ;
46704: LD_ADDR_VAR 0 6
46708: PUSH
46709: LD_VAR 0 2
46713: PPUSH
46714: CALL_OW 251
46718: ST_TO_ADDR
// d := GetDir ( building ) ;
46719: LD_ADDR_VAR 0 8
46723: PUSH
46724: LD_VAR 0 2
46728: PPUSH
46729: CALL_OW 254
46733: ST_TO_ADDR
// r := 4 ;
46734: LD_ADDR_VAR 0 9
46738: PUSH
46739: LD_INT 4
46741: ST_TO_ADDR
// for i := 1 to 5 do
46742: LD_ADDR_VAR 0 10
46746: PUSH
46747: DOUBLE
46748: LD_INT 1
46750: DEC
46751: ST_TO_ADDR
46752: LD_INT 5
46754: PUSH
46755: FOR_TO
46756: IFFALSE 46913
// begin _x := ShiftX ( x , d , r + i ) ;
46758: LD_ADDR_VAR 0 5
46762: PUSH
46763: LD_VAR 0 4
46767: PPUSH
46768: LD_VAR 0 8
46772: PPUSH
46773: LD_VAR 0 9
46777: PUSH
46778: LD_VAR 0 10
46782: PLUS
46783: PPUSH
46784: CALL_OW 272
46788: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46789: LD_ADDR_VAR 0 7
46793: PUSH
46794: LD_VAR 0 6
46798: PPUSH
46799: LD_VAR 0 8
46803: PPUSH
46804: LD_VAR 0 9
46808: PUSH
46809: LD_VAR 0 10
46813: PLUS
46814: PPUSH
46815: CALL_OW 273
46819: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46820: LD_VAR 0 5
46824: PPUSH
46825: LD_VAR 0 7
46829: PPUSH
46830: CALL_OW 488
46834: PUSH
46835: LD_VAR 0 5
46839: PPUSH
46840: LD_VAR 0 7
46844: PPUSH
46845: CALL_OW 428
46849: PPUSH
46850: CALL_OW 247
46854: PUSH
46855: LD_INT 3
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: IN
46865: NOT
46866: AND
46867: IFFALSE 46911
// begin ComMoveXY ( unit , _x , _y ) ;
46869: LD_VAR 0 1
46873: PPUSH
46874: LD_VAR 0 5
46878: PPUSH
46879: LD_VAR 0 7
46883: PPUSH
46884: CALL_OW 111
// result := [ _x , _y ] ;
46888: LD_ADDR_VAR 0 3
46892: PUSH
46893: LD_VAR 0 5
46897: PUSH
46898: LD_VAR 0 7
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: ST_TO_ADDR
// exit ;
46907: POP
46908: POP
46909: GO 46915
// end ; end ;
46911: GO 46755
46913: POP
46914: POP
// end ;
46915: LD_VAR 0 3
46919: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46920: LD_INT 0
46922: PPUSH
46923: PPUSH
46924: PPUSH
// result := 0 ;
46925: LD_ADDR_VAR 0 3
46929: PUSH
46930: LD_INT 0
46932: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46933: LD_VAR 0 1
46937: PUSH
46938: LD_INT 0
46940: LESS
46941: PUSH
46942: LD_VAR 0 1
46946: PUSH
46947: LD_INT 8
46949: GREATER
46950: OR
46951: PUSH
46952: LD_VAR 0 2
46956: PUSH
46957: LD_INT 0
46959: LESS
46960: OR
46961: PUSH
46962: LD_VAR 0 2
46966: PUSH
46967: LD_INT 8
46969: GREATER
46970: OR
46971: IFFALSE 46975
// exit ;
46973: GO 47050
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46975: LD_ADDR_VAR 0 4
46979: PUSH
46980: LD_INT 22
46982: PUSH
46983: LD_VAR 0 2
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PPUSH
46992: CALL_OW 69
46996: PUSH
46997: FOR_IN
46998: IFFALSE 47048
// begin un := UnitShoot ( i ) ;
47000: LD_ADDR_VAR 0 5
47004: PUSH
47005: LD_VAR 0 4
47009: PPUSH
47010: CALL_OW 504
47014: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47015: LD_VAR 0 5
47019: PPUSH
47020: CALL_OW 255
47024: PUSH
47025: LD_VAR 0 1
47029: EQUAL
47030: IFFALSE 47046
// begin result := un ;
47032: LD_ADDR_VAR 0 3
47036: PUSH
47037: LD_VAR 0 5
47041: ST_TO_ADDR
// exit ;
47042: POP
47043: POP
47044: GO 47050
// end ; end ;
47046: GO 46997
47048: POP
47049: POP
// end ; end_of_file
47050: LD_VAR 0 3
47054: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
47055: LD_INT 0
47057: PPUSH
47058: PPUSH
// skirmish := false ;
47059: LD_ADDR_EXP 41
47063: PUSH
47064: LD_INT 0
47066: ST_TO_ADDR
// debug_mc := false ;
47067: LD_ADDR_EXP 42
47071: PUSH
47072: LD_INT 0
47074: ST_TO_ADDR
// mc_bases := [ ] ;
47075: LD_ADDR_EXP 43
47079: PUSH
47080: EMPTY
47081: ST_TO_ADDR
// mc_sides := [ ] ;
47082: LD_ADDR_EXP 69
47086: PUSH
47087: EMPTY
47088: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47089: LD_ADDR_EXP 44
47093: PUSH
47094: EMPTY
47095: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47096: LD_ADDR_EXP 45
47100: PUSH
47101: EMPTY
47102: ST_TO_ADDR
// mc_need_heal := [ ] ;
47103: LD_ADDR_EXP 46
47107: PUSH
47108: EMPTY
47109: ST_TO_ADDR
// mc_healers := [ ] ;
47110: LD_ADDR_EXP 47
47114: PUSH
47115: EMPTY
47116: ST_TO_ADDR
// mc_build_list := [ ] ;
47117: LD_ADDR_EXP 48
47121: PUSH
47122: EMPTY
47123: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47124: LD_ADDR_EXP 75
47128: PUSH
47129: EMPTY
47130: ST_TO_ADDR
// mc_builders := [ ] ;
47131: LD_ADDR_EXP 49
47135: PUSH
47136: EMPTY
47137: ST_TO_ADDR
// mc_construct_list := [ ] ;
47138: LD_ADDR_EXP 50
47142: PUSH
47143: EMPTY
47144: ST_TO_ADDR
// mc_turret_list := [ ] ;
47145: LD_ADDR_EXP 51
47149: PUSH
47150: EMPTY
47151: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47152: LD_ADDR_EXP 52
47156: PUSH
47157: EMPTY
47158: ST_TO_ADDR
// mc_miners := [ ] ;
47159: LD_ADDR_EXP 57
47163: PUSH
47164: EMPTY
47165: ST_TO_ADDR
// mc_mines := [ ] ;
47166: LD_ADDR_EXP 56
47170: PUSH
47171: EMPTY
47172: ST_TO_ADDR
// mc_minefields := [ ] ;
47173: LD_ADDR_EXP 58
47177: PUSH
47178: EMPTY
47179: ST_TO_ADDR
// mc_crates := [ ] ;
47180: LD_ADDR_EXP 59
47184: PUSH
47185: EMPTY
47186: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47187: LD_ADDR_EXP 60
47191: PUSH
47192: EMPTY
47193: ST_TO_ADDR
// mc_crates_area := [ ] ;
47194: LD_ADDR_EXP 61
47198: PUSH
47199: EMPTY
47200: ST_TO_ADDR
// mc_vehicles := [ ] ;
47201: LD_ADDR_EXP 62
47205: PUSH
47206: EMPTY
47207: ST_TO_ADDR
// mc_attack := [ ] ;
47208: LD_ADDR_EXP 63
47212: PUSH
47213: EMPTY
47214: ST_TO_ADDR
// mc_produce := [ ] ;
47215: LD_ADDR_EXP 64
47219: PUSH
47220: EMPTY
47221: ST_TO_ADDR
// mc_defender := [ ] ;
47222: LD_ADDR_EXP 65
47226: PUSH
47227: EMPTY
47228: ST_TO_ADDR
// mc_parking := [ ] ;
47229: LD_ADDR_EXP 67
47233: PUSH
47234: EMPTY
47235: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47236: LD_ADDR_EXP 53
47240: PUSH
47241: EMPTY
47242: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47243: LD_ADDR_EXP 55
47247: PUSH
47248: EMPTY
47249: ST_TO_ADDR
// mc_scan := [ ] ;
47250: LD_ADDR_EXP 66
47254: PUSH
47255: EMPTY
47256: ST_TO_ADDR
// mc_scan_area := [ ] ;
47257: LD_ADDR_EXP 68
47261: PUSH
47262: EMPTY
47263: ST_TO_ADDR
// mc_tech := [ ] ;
47264: LD_ADDR_EXP 70
47268: PUSH
47269: EMPTY
47270: ST_TO_ADDR
// mc_class := [ ] ;
47271: LD_ADDR_EXP 84
47275: PUSH
47276: EMPTY
47277: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47278: LD_ADDR_EXP 85
47282: PUSH
47283: EMPTY
47284: ST_TO_ADDR
// end ;
47285: LD_VAR 0 1
47289: RET
// export function MC_Kill ( base ) ; begin
47290: LD_INT 0
47292: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47293: LD_ADDR_EXP 43
47297: PUSH
47298: LD_EXP 43
47302: PPUSH
47303: LD_VAR 0 1
47307: PPUSH
47308: EMPTY
47309: PPUSH
47310: CALL_OW 1
47314: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47315: LD_ADDR_EXP 44
47319: PUSH
47320: LD_EXP 44
47324: PPUSH
47325: LD_VAR 0 1
47329: PPUSH
47330: EMPTY
47331: PPUSH
47332: CALL_OW 1
47336: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47337: LD_ADDR_EXP 45
47341: PUSH
47342: LD_EXP 45
47346: PPUSH
47347: LD_VAR 0 1
47351: PPUSH
47352: EMPTY
47353: PPUSH
47354: CALL_OW 1
47358: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47359: LD_ADDR_EXP 46
47363: PUSH
47364: LD_EXP 46
47368: PPUSH
47369: LD_VAR 0 1
47373: PPUSH
47374: EMPTY
47375: PPUSH
47376: CALL_OW 1
47380: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47381: LD_ADDR_EXP 47
47385: PUSH
47386: LD_EXP 47
47390: PPUSH
47391: LD_VAR 0 1
47395: PPUSH
47396: EMPTY
47397: PPUSH
47398: CALL_OW 1
47402: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47403: LD_ADDR_EXP 48
47407: PUSH
47408: LD_EXP 48
47412: PPUSH
47413: LD_VAR 0 1
47417: PPUSH
47418: EMPTY
47419: PPUSH
47420: CALL_OW 1
47424: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47425: LD_ADDR_EXP 49
47429: PUSH
47430: LD_EXP 49
47434: PPUSH
47435: LD_VAR 0 1
47439: PPUSH
47440: EMPTY
47441: PPUSH
47442: CALL_OW 1
47446: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47447: LD_ADDR_EXP 50
47451: PUSH
47452: LD_EXP 50
47456: PPUSH
47457: LD_VAR 0 1
47461: PPUSH
47462: EMPTY
47463: PPUSH
47464: CALL_OW 1
47468: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47469: LD_ADDR_EXP 51
47473: PUSH
47474: LD_EXP 51
47478: PPUSH
47479: LD_VAR 0 1
47483: PPUSH
47484: EMPTY
47485: PPUSH
47486: CALL_OW 1
47490: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47491: LD_ADDR_EXP 52
47495: PUSH
47496: LD_EXP 52
47500: PPUSH
47501: LD_VAR 0 1
47505: PPUSH
47506: EMPTY
47507: PPUSH
47508: CALL_OW 1
47512: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47513: LD_ADDR_EXP 53
47517: PUSH
47518: LD_EXP 53
47522: PPUSH
47523: LD_VAR 0 1
47527: PPUSH
47528: EMPTY
47529: PPUSH
47530: CALL_OW 1
47534: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47535: LD_ADDR_EXP 54
47539: PUSH
47540: LD_EXP 54
47544: PPUSH
47545: LD_VAR 0 1
47549: PPUSH
47550: LD_INT 0
47552: PPUSH
47553: CALL_OW 1
47557: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47558: LD_ADDR_EXP 55
47562: PUSH
47563: LD_EXP 55
47567: PPUSH
47568: LD_VAR 0 1
47572: PPUSH
47573: EMPTY
47574: PPUSH
47575: CALL_OW 1
47579: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47580: LD_ADDR_EXP 56
47584: PUSH
47585: LD_EXP 56
47589: PPUSH
47590: LD_VAR 0 1
47594: PPUSH
47595: EMPTY
47596: PPUSH
47597: CALL_OW 1
47601: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47602: LD_ADDR_EXP 57
47606: PUSH
47607: LD_EXP 57
47611: PPUSH
47612: LD_VAR 0 1
47616: PPUSH
47617: EMPTY
47618: PPUSH
47619: CALL_OW 1
47623: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47624: LD_ADDR_EXP 58
47628: PUSH
47629: LD_EXP 58
47633: PPUSH
47634: LD_VAR 0 1
47638: PPUSH
47639: EMPTY
47640: PPUSH
47641: CALL_OW 1
47645: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47646: LD_ADDR_EXP 59
47650: PUSH
47651: LD_EXP 59
47655: PPUSH
47656: LD_VAR 0 1
47660: PPUSH
47661: EMPTY
47662: PPUSH
47663: CALL_OW 1
47667: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47668: LD_ADDR_EXP 60
47672: PUSH
47673: LD_EXP 60
47677: PPUSH
47678: LD_VAR 0 1
47682: PPUSH
47683: EMPTY
47684: PPUSH
47685: CALL_OW 1
47689: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47690: LD_ADDR_EXP 61
47694: PUSH
47695: LD_EXP 61
47699: PPUSH
47700: LD_VAR 0 1
47704: PPUSH
47705: EMPTY
47706: PPUSH
47707: CALL_OW 1
47711: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47712: LD_ADDR_EXP 62
47716: PUSH
47717: LD_EXP 62
47721: PPUSH
47722: LD_VAR 0 1
47726: PPUSH
47727: EMPTY
47728: PPUSH
47729: CALL_OW 1
47733: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47734: LD_ADDR_EXP 63
47738: PUSH
47739: LD_EXP 63
47743: PPUSH
47744: LD_VAR 0 1
47748: PPUSH
47749: EMPTY
47750: PPUSH
47751: CALL_OW 1
47755: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47756: LD_ADDR_EXP 64
47760: PUSH
47761: LD_EXP 64
47765: PPUSH
47766: LD_VAR 0 1
47770: PPUSH
47771: EMPTY
47772: PPUSH
47773: CALL_OW 1
47777: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47778: LD_ADDR_EXP 65
47782: PUSH
47783: LD_EXP 65
47787: PPUSH
47788: LD_VAR 0 1
47792: PPUSH
47793: EMPTY
47794: PPUSH
47795: CALL_OW 1
47799: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47800: LD_ADDR_EXP 66
47804: PUSH
47805: LD_EXP 66
47809: PPUSH
47810: LD_VAR 0 1
47814: PPUSH
47815: EMPTY
47816: PPUSH
47817: CALL_OW 1
47821: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47822: LD_ADDR_EXP 67
47826: PUSH
47827: LD_EXP 67
47831: PPUSH
47832: LD_VAR 0 1
47836: PPUSH
47837: EMPTY
47838: PPUSH
47839: CALL_OW 1
47843: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47844: LD_ADDR_EXP 68
47848: PUSH
47849: LD_EXP 68
47853: PPUSH
47854: LD_VAR 0 1
47858: PPUSH
47859: EMPTY
47860: PPUSH
47861: CALL_OW 1
47865: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47866: LD_ADDR_EXP 70
47870: PUSH
47871: LD_EXP 70
47875: PPUSH
47876: LD_VAR 0 1
47880: PPUSH
47881: EMPTY
47882: PPUSH
47883: CALL_OW 1
47887: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47888: LD_ADDR_EXP 72
47892: PUSH
47893: LD_EXP 72
47897: PPUSH
47898: LD_VAR 0 1
47902: PPUSH
47903: EMPTY
47904: PPUSH
47905: CALL_OW 1
47909: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47910: LD_ADDR_EXP 73
47914: PUSH
47915: LD_EXP 73
47919: PPUSH
47920: LD_VAR 0 1
47924: PPUSH
47925: EMPTY
47926: PPUSH
47927: CALL_OW 1
47931: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
47932: LD_ADDR_EXP 74
47936: PUSH
47937: LD_EXP 74
47941: PPUSH
47942: LD_VAR 0 1
47946: PPUSH
47947: EMPTY
47948: PPUSH
47949: CALL_OW 1
47953: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
47954: LD_ADDR_EXP 75
47958: PUSH
47959: LD_EXP 75
47963: PPUSH
47964: LD_VAR 0 1
47968: PPUSH
47969: EMPTY
47970: PPUSH
47971: CALL_OW 1
47975: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
47976: LD_ADDR_EXP 76
47980: PUSH
47981: LD_EXP 76
47985: PPUSH
47986: LD_VAR 0 1
47990: PPUSH
47991: EMPTY
47992: PPUSH
47993: CALL_OW 1
47997: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
47998: LD_ADDR_EXP 77
48002: PUSH
48003: LD_EXP 77
48007: PPUSH
48008: LD_VAR 0 1
48012: PPUSH
48013: EMPTY
48014: PPUSH
48015: CALL_OW 1
48019: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48020: LD_ADDR_EXP 78
48024: PUSH
48025: LD_EXP 78
48029: PPUSH
48030: LD_VAR 0 1
48034: PPUSH
48035: EMPTY
48036: PPUSH
48037: CALL_OW 1
48041: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48042: LD_ADDR_EXP 79
48046: PUSH
48047: LD_EXP 79
48051: PPUSH
48052: LD_VAR 0 1
48056: PPUSH
48057: EMPTY
48058: PPUSH
48059: CALL_OW 1
48063: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48064: LD_ADDR_EXP 80
48068: PUSH
48069: LD_EXP 80
48073: PPUSH
48074: LD_VAR 0 1
48078: PPUSH
48079: EMPTY
48080: PPUSH
48081: CALL_OW 1
48085: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48086: LD_ADDR_EXP 81
48090: PUSH
48091: LD_EXP 81
48095: PPUSH
48096: LD_VAR 0 1
48100: PPUSH
48101: EMPTY
48102: PPUSH
48103: CALL_OW 1
48107: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48108: LD_ADDR_EXP 82
48112: PUSH
48113: LD_EXP 82
48117: PPUSH
48118: LD_VAR 0 1
48122: PPUSH
48123: EMPTY
48124: PPUSH
48125: CALL_OW 1
48129: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48130: LD_ADDR_EXP 83
48134: PUSH
48135: LD_EXP 83
48139: PPUSH
48140: LD_VAR 0 1
48144: PPUSH
48145: EMPTY
48146: PPUSH
48147: CALL_OW 1
48151: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48152: LD_ADDR_EXP 84
48156: PUSH
48157: LD_EXP 84
48161: PPUSH
48162: LD_VAR 0 1
48166: PPUSH
48167: EMPTY
48168: PPUSH
48169: CALL_OW 1
48173: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48174: LD_ADDR_EXP 85
48178: PUSH
48179: LD_EXP 85
48183: PPUSH
48184: LD_VAR 0 1
48188: PPUSH
48189: LD_INT 0
48191: PPUSH
48192: CALL_OW 1
48196: ST_TO_ADDR
// end ;
48197: LD_VAR 0 2
48201: RET
// export function MC_Add ( side , units ) ; var base ; begin
48202: LD_INT 0
48204: PPUSH
48205: PPUSH
// base := mc_bases + 1 ;
48206: LD_ADDR_VAR 0 4
48210: PUSH
48211: LD_EXP 43
48215: PUSH
48216: LD_INT 1
48218: PLUS
48219: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48220: LD_ADDR_EXP 69
48224: PUSH
48225: LD_EXP 69
48229: PPUSH
48230: LD_VAR 0 4
48234: PPUSH
48235: LD_VAR 0 1
48239: PPUSH
48240: CALL_OW 1
48244: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48245: LD_ADDR_EXP 43
48249: PUSH
48250: LD_EXP 43
48254: PPUSH
48255: LD_VAR 0 4
48259: PPUSH
48260: LD_VAR 0 2
48264: PPUSH
48265: CALL_OW 1
48269: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48270: LD_ADDR_EXP 44
48274: PUSH
48275: LD_EXP 44
48279: PPUSH
48280: LD_VAR 0 4
48284: PPUSH
48285: EMPTY
48286: PPUSH
48287: CALL_OW 1
48291: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48292: LD_ADDR_EXP 45
48296: PUSH
48297: LD_EXP 45
48301: PPUSH
48302: LD_VAR 0 4
48306: PPUSH
48307: EMPTY
48308: PPUSH
48309: CALL_OW 1
48313: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48314: LD_ADDR_EXP 46
48318: PUSH
48319: LD_EXP 46
48323: PPUSH
48324: LD_VAR 0 4
48328: PPUSH
48329: EMPTY
48330: PPUSH
48331: CALL_OW 1
48335: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48336: LD_ADDR_EXP 47
48340: PUSH
48341: LD_EXP 47
48345: PPUSH
48346: LD_VAR 0 4
48350: PPUSH
48351: EMPTY
48352: PPUSH
48353: CALL_OW 1
48357: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48358: LD_ADDR_EXP 48
48362: PUSH
48363: LD_EXP 48
48367: PPUSH
48368: LD_VAR 0 4
48372: PPUSH
48373: EMPTY
48374: PPUSH
48375: CALL_OW 1
48379: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48380: LD_ADDR_EXP 49
48384: PUSH
48385: LD_EXP 49
48389: PPUSH
48390: LD_VAR 0 4
48394: PPUSH
48395: EMPTY
48396: PPUSH
48397: CALL_OW 1
48401: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48402: LD_ADDR_EXP 50
48406: PUSH
48407: LD_EXP 50
48411: PPUSH
48412: LD_VAR 0 4
48416: PPUSH
48417: EMPTY
48418: PPUSH
48419: CALL_OW 1
48423: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48424: LD_ADDR_EXP 51
48428: PUSH
48429: LD_EXP 51
48433: PPUSH
48434: LD_VAR 0 4
48438: PPUSH
48439: EMPTY
48440: PPUSH
48441: CALL_OW 1
48445: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48446: LD_ADDR_EXP 52
48450: PUSH
48451: LD_EXP 52
48455: PPUSH
48456: LD_VAR 0 4
48460: PPUSH
48461: EMPTY
48462: PPUSH
48463: CALL_OW 1
48467: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48468: LD_ADDR_EXP 53
48472: PUSH
48473: LD_EXP 53
48477: PPUSH
48478: LD_VAR 0 4
48482: PPUSH
48483: EMPTY
48484: PPUSH
48485: CALL_OW 1
48489: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48490: LD_ADDR_EXP 54
48494: PUSH
48495: LD_EXP 54
48499: PPUSH
48500: LD_VAR 0 4
48504: PPUSH
48505: LD_INT 0
48507: PPUSH
48508: CALL_OW 1
48512: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48513: LD_ADDR_EXP 55
48517: PUSH
48518: LD_EXP 55
48522: PPUSH
48523: LD_VAR 0 4
48527: PPUSH
48528: EMPTY
48529: PPUSH
48530: CALL_OW 1
48534: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48535: LD_ADDR_EXP 56
48539: PUSH
48540: LD_EXP 56
48544: PPUSH
48545: LD_VAR 0 4
48549: PPUSH
48550: EMPTY
48551: PPUSH
48552: CALL_OW 1
48556: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48557: LD_ADDR_EXP 57
48561: PUSH
48562: LD_EXP 57
48566: PPUSH
48567: LD_VAR 0 4
48571: PPUSH
48572: EMPTY
48573: PPUSH
48574: CALL_OW 1
48578: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48579: LD_ADDR_EXP 58
48583: PUSH
48584: LD_EXP 58
48588: PPUSH
48589: LD_VAR 0 4
48593: PPUSH
48594: EMPTY
48595: PPUSH
48596: CALL_OW 1
48600: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48601: LD_ADDR_EXP 59
48605: PUSH
48606: LD_EXP 59
48610: PPUSH
48611: LD_VAR 0 4
48615: PPUSH
48616: EMPTY
48617: PPUSH
48618: CALL_OW 1
48622: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48623: LD_ADDR_EXP 60
48627: PUSH
48628: LD_EXP 60
48632: PPUSH
48633: LD_VAR 0 4
48637: PPUSH
48638: EMPTY
48639: PPUSH
48640: CALL_OW 1
48644: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48645: LD_ADDR_EXP 61
48649: PUSH
48650: LD_EXP 61
48654: PPUSH
48655: LD_VAR 0 4
48659: PPUSH
48660: EMPTY
48661: PPUSH
48662: CALL_OW 1
48666: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48667: LD_ADDR_EXP 62
48671: PUSH
48672: LD_EXP 62
48676: PPUSH
48677: LD_VAR 0 4
48681: PPUSH
48682: EMPTY
48683: PPUSH
48684: CALL_OW 1
48688: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48689: LD_ADDR_EXP 63
48693: PUSH
48694: LD_EXP 63
48698: PPUSH
48699: LD_VAR 0 4
48703: PPUSH
48704: EMPTY
48705: PPUSH
48706: CALL_OW 1
48710: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48711: LD_ADDR_EXP 64
48715: PUSH
48716: LD_EXP 64
48720: PPUSH
48721: LD_VAR 0 4
48725: PPUSH
48726: EMPTY
48727: PPUSH
48728: CALL_OW 1
48732: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48733: LD_ADDR_EXP 65
48737: PUSH
48738: LD_EXP 65
48742: PPUSH
48743: LD_VAR 0 4
48747: PPUSH
48748: EMPTY
48749: PPUSH
48750: CALL_OW 1
48754: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48755: LD_ADDR_EXP 66
48759: PUSH
48760: LD_EXP 66
48764: PPUSH
48765: LD_VAR 0 4
48769: PPUSH
48770: EMPTY
48771: PPUSH
48772: CALL_OW 1
48776: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48777: LD_ADDR_EXP 67
48781: PUSH
48782: LD_EXP 67
48786: PPUSH
48787: LD_VAR 0 4
48791: PPUSH
48792: EMPTY
48793: PPUSH
48794: CALL_OW 1
48798: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48799: LD_ADDR_EXP 68
48803: PUSH
48804: LD_EXP 68
48808: PPUSH
48809: LD_VAR 0 4
48813: PPUSH
48814: EMPTY
48815: PPUSH
48816: CALL_OW 1
48820: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48821: LD_ADDR_EXP 70
48825: PUSH
48826: LD_EXP 70
48830: PPUSH
48831: LD_VAR 0 4
48835: PPUSH
48836: EMPTY
48837: PPUSH
48838: CALL_OW 1
48842: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48843: LD_ADDR_EXP 72
48847: PUSH
48848: LD_EXP 72
48852: PPUSH
48853: LD_VAR 0 4
48857: PPUSH
48858: EMPTY
48859: PPUSH
48860: CALL_OW 1
48864: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48865: LD_ADDR_EXP 73
48869: PUSH
48870: LD_EXP 73
48874: PPUSH
48875: LD_VAR 0 4
48879: PPUSH
48880: EMPTY
48881: PPUSH
48882: CALL_OW 1
48886: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48887: LD_ADDR_EXP 74
48891: PUSH
48892: LD_EXP 74
48896: PPUSH
48897: LD_VAR 0 4
48901: PPUSH
48902: EMPTY
48903: PPUSH
48904: CALL_OW 1
48908: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48909: LD_ADDR_EXP 75
48913: PUSH
48914: LD_EXP 75
48918: PPUSH
48919: LD_VAR 0 4
48923: PPUSH
48924: EMPTY
48925: PPUSH
48926: CALL_OW 1
48930: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48931: LD_ADDR_EXP 76
48935: PUSH
48936: LD_EXP 76
48940: PPUSH
48941: LD_VAR 0 4
48945: PPUSH
48946: EMPTY
48947: PPUSH
48948: CALL_OW 1
48952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48953: LD_ADDR_EXP 77
48957: PUSH
48958: LD_EXP 77
48962: PPUSH
48963: LD_VAR 0 4
48967: PPUSH
48968: EMPTY
48969: PPUSH
48970: CALL_OW 1
48974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48975: LD_ADDR_EXP 78
48979: PUSH
48980: LD_EXP 78
48984: PPUSH
48985: LD_VAR 0 4
48989: PPUSH
48990: EMPTY
48991: PPUSH
48992: CALL_OW 1
48996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48997: LD_ADDR_EXP 79
49001: PUSH
49002: LD_EXP 79
49006: PPUSH
49007: LD_VAR 0 4
49011: PPUSH
49012: EMPTY
49013: PPUSH
49014: CALL_OW 1
49018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49019: LD_ADDR_EXP 80
49023: PUSH
49024: LD_EXP 80
49028: PPUSH
49029: LD_VAR 0 4
49033: PPUSH
49034: EMPTY
49035: PPUSH
49036: CALL_OW 1
49040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49041: LD_ADDR_EXP 81
49045: PUSH
49046: LD_EXP 81
49050: PPUSH
49051: LD_VAR 0 4
49055: PPUSH
49056: EMPTY
49057: PPUSH
49058: CALL_OW 1
49062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49063: LD_ADDR_EXP 82
49067: PUSH
49068: LD_EXP 82
49072: PPUSH
49073: LD_VAR 0 4
49077: PPUSH
49078: EMPTY
49079: PPUSH
49080: CALL_OW 1
49084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49085: LD_ADDR_EXP 83
49089: PUSH
49090: LD_EXP 83
49094: PPUSH
49095: LD_VAR 0 4
49099: PPUSH
49100: EMPTY
49101: PPUSH
49102: CALL_OW 1
49106: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49107: LD_ADDR_EXP 84
49111: PUSH
49112: LD_EXP 84
49116: PPUSH
49117: LD_VAR 0 4
49121: PPUSH
49122: EMPTY
49123: PPUSH
49124: CALL_OW 1
49128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49129: LD_ADDR_EXP 85
49133: PUSH
49134: LD_EXP 85
49138: PPUSH
49139: LD_VAR 0 4
49143: PPUSH
49144: LD_INT 0
49146: PPUSH
49147: CALL_OW 1
49151: ST_TO_ADDR
// result := base ;
49152: LD_ADDR_VAR 0 3
49156: PUSH
49157: LD_VAR 0 4
49161: ST_TO_ADDR
// end ;
49162: LD_VAR 0 3
49166: RET
// export function MC_Start ( ) ; var i ; begin
49167: LD_INT 0
49169: PPUSH
49170: PPUSH
// for i = 1 to mc_bases do
49171: LD_ADDR_VAR 0 2
49175: PUSH
49176: DOUBLE
49177: LD_INT 1
49179: DEC
49180: ST_TO_ADDR
49181: LD_EXP 43
49185: PUSH
49186: FOR_TO
49187: IFFALSE 50264
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49189: LD_ADDR_EXP 43
49193: PUSH
49194: LD_EXP 43
49198: PPUSH
49199: LD_VAR 0 2
49203: PPUSH
49204: LD_EXP 43
49208: PUSH
49209: LD_VAR 0 2
49213: ARRAY
49214: PUSH
49215: LD_INT 0
49217: DIFF
49218: PPUSH
49219: CALL_OW 1
49223: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49224: LD_ADDR_EXP 44
49228: PUSH
49229: LD_EXP 44
49233: PPUSH
49234: LD_VAR 0 2
49238: PPUSH
49239: EMPTY
49240: PPUSH
49241: CALL_OW 1
49245: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49246: LD_ADDR_EXP 45
49250: PUSH
49251: LD_EXP 45
49255: PPUSH
49256: LD_VAR 0 2
49260: PPUSH
49261: EMPTY
49262: PPUSH
49263: CALL_OW 1
49267: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49268: LD_ADDR_EXP 46
49272: PUSH
49273: LD_EXP 46
49277: PPUSH
49278: LD_VAR 0 2
49282: PPUSH
49283: EMPTY
49284: PPUSH
49285: CALL_OW 1
49289: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49290: LD_ADDR_EXP 47
49294: PUSH
49295: LD_EXP 47
49299: PPUSH
49300: LD_VAR 0 2
49304: PPUSH
49305: EMPTY
49306: PUSH
49307: EMPTY
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: PPUSH
49313: CALL_OW 1
49317: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49318: LD_ADDR_EXP 48
49322: PUSH
49323: LD_EXP 48
49327: PPUSH
49328: LD_VAR 0 2
49332: PPUSH
49333: EMPTY
49334: PPUSH
49335: CALL_OW 1
49339: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49340: LD_ADDR_EXP 75
49344: PUSH
49345: LD_EXP 75
49349: PPUSH
49350: LD_VAR 0 2
49354: PPUSH
49355: EMPTY
49356: PPUSH
49357: CALL_OW 1
49361: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49362: LD_ADDR_EXP 49
49366: PUSH
49367: LD_EXP 49
49371: PPUSH
49372: LD_VAR 0 2
49376: PPUSH
49377: EMPTY
49378: PPUSH
49379: CALL_OW 1
49383: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49384: LD_ADDR_EXP 50
49388: PUSH
49389: LD_EXP 50
49393: PPUSH
49394: LD_VAR 0 2
49398: PPUSH
49399: EMPTY
49400: PPUSH
49401: CALL_OW 1
49405: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49406: LD_ADDR_EXP 51
49410: PUSH
49411: LD_EXP 51
49415: PPUSH
49416: LD_VAR 0 2
49420: PPUSH
49421: LD_EXP 43
49425: PUSH
49426: LD_VAR 0 2
49430: ARRAY
49431: PPUSH
49432: LD_INT 2
49434: PUSH
49435: LD_INT 30
49437: PUSH
49438: LD_INT 32
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 30
49447: PUSH
49448: LD_INT 33
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: LIST
49459: PPUSH
49460: CALL_OW 72
49464: PPUSH
49465: CALL_OW 1
49469: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49470: LD_ADDR_EXP 52
49474: PUSH
49475: LD_EXP 52
49479: PPUSH
49480: LD_VAR 0 2
49484: PPUSH
49485: LD_EXP 43
49489: PUSH
49490: LD_VAR 0 2
49494: ARRAY
49495: PPUSH
49496: LD_INT 2
49498: PUSH
49499: LD_INT 30
49501: PUSH
49502: LD_INT 32
49504: PUSH
49505: EMPTY
49506: LIST
49507: LIST
49508: PUSH
49509: LD_INT 30
49511: PUSH
49512: LD_INT 31
49514: PUSH
49515: EMPTY
49516: LIST
49517: LIST
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 58
49526: PUSH
49527: EMPTY
49528: LIST
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PPUSH
49534: CALL_OW 72
49538: PPUSH
49539: CALL_OW 1
49543: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49544: LD_ADDR_EXP 53
49548: PUSH
49549: LD_EXP 53
49553: PPUSH
49554: LD_VAR 0 2
49558: PPUSH
49559: EMPTY
49560: PPUSH
49561: CALL_OW 1
49565: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49566: LD_ADDR_EXP 57
49570: PUSH
49571: LD_EXP 57
49575: PPUSH
49576: LD_VAR 0 2
49580: PPUSH
49581: EMPTY
49582: PPUSH
49583: CALL_OW 1
49587: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49588: LD_ADDR_EXP 56
49592: PUSH
49593: LD_EXP 56
49597: PPUSH
49598: LD_VAR 0 2
49602: PPUSH
49603: EMPTY
49604: PPUSH
49605: CALL_OW 1
49609: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49610: LD_ADDR_EXP 58
49614: PUSH
49615: LD_EXP 58
49619: PPUSH
49620: LD_VAR 0 2
49624: PPUSH
49625: EMPTY
49626: PPUSH
49627: CALL_OW 1
49631: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49632: LD_ADDR_EXP 59
49636: PUSH
49637: LD_EXP 59
49641: PPUSH
49642: LD_VAR 0 2
49646: PPUSH
49647: EMPTY
49648: PPUSH
49649: CALL_OW 1
49653: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49654: LD_ADDR_EXP 60
49658: PUSH
49659: LD_EXP 60
49663: PPUSH
49664: LD_VAR 0 2
49668: PPUSH
49669: EMPTY
49670: PPUSH
49671: CALL_OW 1
49675: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49676: LD_ADDR_EXP 61
49680: PUSH
49681: LD_EXP 61
49685: PPUSH
49686: LD_VAR 0 2
49690: PPUSH
49691: EMPTY
49692: PPUSH
49693: CALL_OW 1
49697: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49698: LD_ADDR_EXP 62
49702: PUSH
49703: LD_EXP 62
49707: PPUSH
49708: LD_VAR 0 2
49712: PPUSH
49713: EMPTY
49714: PPUSH
49715: CALL_OW 1
49719: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49720: LD_ADDR_EXP 63
49724: PUSH
49725: LD_EXP 63
49729: PPUSH
49730: LD_VAR 0 2
49734: PPUSH
49735: EMPTY
49736: PPUSH
49737: CALL_OW 1
49741: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49742: LD_ADDR_EXP 64
49746: PUSH
49747: LD_EXP 64
49751: PPUSH
49752: LD_VAR 0 2
49756: PPUSH
49757: EMPTY
49758: PPUSH
49759: CALL_OW 1
49763: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49764: LD_ADDR_EXP 65
49768: PUSH
49769: LD_EXP 65
49773: PPUSH
49774: LD_VAR 0 2
49778: PPUSH
49779: EMPTY
49780: PPUSH
49781: CALL_OW 1
49785: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49786: LD_ADDR_EXP 54
49790: PUSH
49791: LD_EXP 54
49795: PPUSH
49796: LD_VAR 0 2
49800: PPUSH
49801: LD_INT 0
49803: PPUSH
49804: CALL_OW 1
49808: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49809: LD_ADDR_EXP 67
49813: PUSH
49814: LD_EXP 67
49818: PPUSH
49819: LD_VAR 0 2
49823: PPUSH
49824: LD_INT 0
49826: PPUSH
49827: CALL_OW 1
49831: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49832: LD_ADDR_EXP 55
49836: PUSH
49837: LD_EXP 55
49841: PPUSH
49842: LD_VAR 0 2
49846: PPUSH
49847: EMPTY
49848: PPUSH
49849: CALL_OW 1
49853: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49854: LD_ADDR_EXP 66
49858: PUSH
49859: LD_EXP 66
49863: PPUSH
49864: LD_VAR 0 2
49868: PPUSH
49869: LD_INT 0
49871: PPUSH
49872: CALL_OW 1
49876: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49877: LD_ADDR_EXP 68
49881: PUSH
49882: LD_EXP 68
49886: PPUSH
49887: LD_VAR 0 2
49891: PPUSH
49892: EMPTY
49893: PPUSH
49894: CALL_OW 1
49898: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
49899: LD_ADDR_EXP 71
49903: PUSH
49904: LD_EXP 71
49908: PPUSH
49909: LD_VAR 0 2
49913: PPUSH
49914: LD_INT 0
49916: PPUSH
49917: CALL_OW 1
49921: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
49922: LD_ADDR_EXP 72
49926: PUSH
49927: LD_EXP 72
49931: PPUSH
49932: LD_VAR 0 2
49936: PPUSH
49937: EMPTY
49938: PPUSH
49939: CALL_OW 1
49943: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49944: LD_ADDR_EXP 73
49948: PUSH
49949: LD_EXP 73
49953: PPUSH
49954: LD_VAR 0 2
49958: PPUSH
49959: EMPTY
49960: PPUSH
49961: CALL_OW 1
49965: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49966: LD_ADDR_EXP 74
49970: PUSH
49971: LD_EXP 74
49975: PPUSH
49976: LD_VAR 0 2
49980: PPUSH
49981: EMPTY
49982: PPUSH
49983: CALL_OW 1
49987: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
49988: LD_ADDR_EXP 76
49992: PUSH
49993: LD_EXP 76
49997: PPUSH
49998: LD_VAR 0 2
50002: PPUSH
50003: LD_EXP 43
50007: PUSH
50008: LD_VAR 0 2
50012: ARRAY
50013: PPUSH
50014: LD_INT 2
50016: PUSH
50017: LD_INT 30
50019: PUSH
50020: LD_INT 6
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PUSH
50027: LD_INT 30
50029: PUSH
50030: LD_INT 7
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: PUSH
50037: LD_INT 30
50039: PUSH
50040: LD_INT 8
50042: PUSH
50043: EMPTY
50044: LIST
50045: LIST
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: LIST
50051: LIST
50052: PPUSH
50053: CALL_OW 72
50057: PPUSH
50058: CALL_OW 1
50062: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50063: LD_ADDR_EXP 77
50067: PUSH
50068: LD_EXP 77
50072: PPUSH
50073: LD_VAR 0 2
50077: PPUSH
50078: EMPTY
50079: PPUSH
50080: CALL_OW 1
50084: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50085: LD_ADDR_EXP 78
50089: PUSH
50090: LD_EXP 78
50094: PPUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: EMPTY
50101: PPUSH
50102: CALL_OW 1
50106: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50107: LD_ADDR_EXP 79
50111: PUSH
50112: LD_EXP 79
50116: PPUSH
50117: LD_VAR 0 2
50121: PPUSH
50122: EMPTY
50123: PPUSH
50124: CALL_OW 1
50128: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50129: LD_ADDR_EXP 80
50133: PUSH
50134: LD_EXP 80
50138: PPUSH
50139: LD_VAR 0 2
50143: PPUSH
50144: EMPTY
50145: PPUSH
50146: CALL_OW 1
50150: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50151: LD_ADDR_EXP 81
50155: PUSH
50156: LD_EXP 81
50160: PPUSH
50161: LD_VAR 0 2
50165: PPUSH
50166: EMPTY
50167: PPUSH
50168: CALL_OW 1
50172: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50173: LD_ADDR_EXP 82
50177: PUSH
50178: LD_EXP 82
50182: PPUSH
50183: LD_VAR 0 2
50187: PPUSH
50188: EMPTY
50189: PPUSH
50190: CALL_OW 1
50194: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50195: LD_ADDR_EXP 83
50199: PUSH
50200: LD_EXP 83
50204: PPUSH
50205: LD_VAR 0 2
50209: PPUSH
50210: EMPTY
50211: PPUSH
50212: CALL_OW 1
50216: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50217: LD_ADDR_EXP 84
50221: PUSH
50222: LD_EXP 84
50226: PPUSH
50227: LD_VAR 0 2
50231: PPUSH
50232: EMPTY
50233: PPUSH
50234: CALL_OW 1
50238: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50239: LD_ADDR_EXP 85
50243: PUSH
50244: LD_EXP 85
50248: PPUSH
50249: LD_VAR 0 2
50253: PPUSH
50254: LD_INT 0
50256: PPUSH
50257: CALL_OW 1
50261: ST_TO_ADDR
// end ;
50262: GO 49186
50264: POP
50265: POP
// MC_InitSides ( ) ;
50266: CALL 50552 0 0
// MC_InitResearch ( ) ;
50270: CALL 50291 0 0
// CustomInitMacro ( ) ;
50274: CALL 97 0 0
// skirmish := true ;
50278: LD_ADDR_EXP 41
50282: PUSH
50283: LD_INT 1
50285: ST_TO_ADDR
// end ;
50286: LD_VAR 0 1
50290: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50291: LD_INT 0
50293: PPUSH
50294: PPUSH
50295: PPUSH
50296: PPUSH
50297: PPUSH
50298: PPUSH
// if not mc_bases then
50299: LD_EXP 43
50303: NOT
50304: IFFALSE 50308
// exit ;
50306: GO 50547
// for i = 1 to 8 do
50308: LD_ADDR_VAR 0 2
50312: PUSH
50313: DOUBLE
50314: LD_INT 1
50316: DEC
50317: ST_TO_ADDR
50318: LD_INT 8
50320: PUSH
50321: FOR_TO
50322: IFFALSE 50348
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50324: LD_ADDR_EXP 70
50328: PUSH
50329: LD_EXP 70
50333: PPUSH
50334: LD_VAR 0 2
50338: PPUSH
50339: EMPTY
50340: PPUSH
50341: CALL_OW 1
50345: ST_TO_ADDR
50346: GO 50321
50348: POP
50349: POP
// tmp := [ ] ;
50350: LD_ADDR_VAR 0 5
50354: PUSH
50355: EMPTY
50356: ST_TO_ADDR
// for i = 1 to mc_sides do
50357: LD_ADDR_VAR 0 2
50361: PUSH
50362: DOUBLE
50363: LD_INT 1
50365: DEC
50366: ST_TO_ADDR
50367: LD_EXP 69
50371: PUSH
50372: FOR_TO
50373: IFFALSE 50431
// if not mc_sides [ i ] in tmp then
50375: LD_EXP 69
50379: PUSH
50380: LD_VAR 0 2
50384: ARRAY
50385: PUSH
50386: LD_VAR 0 5
50390: IN
50391: NOT
50392: IFFALSE 50429
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50394: LD_ADDR_VAR 0 5
50398: PUSH
50399: LD_VAR 0 5
50403: PPUSH
50404: LD_VAR 0 5
50408: PUSH
50409: LD_INT 1
50411: PLUS
50412: PPUSH
50413: LD_EXP 69
50417: PUSH
50418: LD_VAR 0 2
50422: ARRAY
50423: PPUSH
50424: CALL_OW 2
50428: ST_TO_ADDR
50429: GO 50372
50431: POP
50432: POP
// if not tmp then
50433: LD_VAR 0 5
50437: NOT
50438: IFFALSE 50442
// exit ;
50440: GO 50547
// for j in tmp do
50442: LD_ADDR_VAR 0 3
50446: PUSH
50447: LD_VAR 0 5
50451: PUSH
50452: FOR_IN
50453: IFFALSE 50545
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50455: LD_ADDR_VAR 0 6
50459: PUSH
50460: LD_INT 22
50462: PUSH
50463: LD_VAR 0 3
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: PPUSH
50472: CALL_OW 69
50476: ST_TO_ADDR
// if not un then
50477: LD_VAR 0 6
50481: NOT
50482: IFFALSE 50486
// continue ;
50484: GO 50452
// nation := GetNation ( un [ 1 ] ) ;
50486: LD_ADDR_VAR 0 4
50490: PUSH
50491: LD_VAR 0 6
50495: PUSH
50496: LD_INT 1
50498: ARRAY
50499: PPUSH
50500: CALL_OW 248
50504: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50505: LD_ADDR_EXP 70
50509: PUSH
50510: LD_EXP 70
50514: PPUSH
50515: LD_VAR 0 3
50519: PPUSH
50520: LD_VAR 0 3
50524: PPUSH
50525: LD_VAR 0 4
50529: PPUSH
50530: LD_INT 1
50532: PPUSH
50533: CALL 9914 0 3
50537: PPUSH
50538: CALL_OW 1
50542: ST_TO_ADDR
// end ;
50543: GO 50452
50545: POP
50546: POP
// end ;
50547: LD_VAR 0 1
50551: RET
// export function MC_InitSides ( ) ; var i ; begin
50552: LD_INT 0
50554: PPUSH
50555: PPUSH
// if not mc_bases then
50556: LD_EXP 43
50560: NOT
50561: IFFALSE 50565
// exit ;
50563: GO 50639
// for i = 1 to mc_bases do
50565: LD_ADDR_VAR 0 2
50569: PUSH
50570: DOUBLE
50571: LD_INT 1
50573: DEC
50574: ST_TO_ADDR
50575: LD_EXP 43
50579: PUSH
50580: FOR_TO
50581: IFFALSE 50637
// if mc_bases [ i ] then
50583: LD_EXP 43
50587: PUSH
50588: LD_VAR 0 2
50592: ARRAY
50593: IFFALSE 50635
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50595: LD_ADDR_EXP 69
50599: PUSH
50600: LD_EXP 69
50604: PPUSH
50605: LD_VAR 0 2
50609: PPUSH
50610: LD_EXP 43
50614: PUSH
50615: LD_VAR 0 2
50619: ARRAY
50620: PUSH
50621: LD_INT 1
50623: ARRAY
50624: PPUSH
50625: CALL_OW 255
50629: PPUSH
50630: CALL_OW 1
50634: ST_TO_ADDR
50635: GO 50580
50637: POP
50638: POP
// end ;
50639: LD_VAR 0 1
50643: RET
// every 0 0$01 trigger skirmish do
50644: LD_EXP 41
50648: IFFALSE 50802
50650: GO 50652
50652: DISABLE
// begin enable ;
50653: ENABLE
// MC_CheckBuildings ( ) ;
50654: CALL 55300 0 0
// MC_CheckPeopleLife ( ) ;
50658: CALL 55425 0 0
// RaiseSailEvent ( 100 ) ;
50662: LD_INT 100
50664: PPUSH
50665: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50669: LD_INT 103
50671: PPUSH
50672: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50676: LD_INT 104
50678: PPUSH
50679: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50683: LD_INT 105
50685: PPUSH
50686: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50690: LD_INT 106
50692: PPUSH
50693: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50697: LD_INT 107
50699: PPUSH
50700: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50704: LD_INT 108
50706: PPUSH
50707: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50711: LD_INT 109
50713: PPUSH
50714: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50718: LD_INT 110
50720: PPUSH
50721: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50725: LD_INT 111
50727: PPUSH
50728: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50732: LD_INT 112
50734: PPUSH
50735: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50739: LD_INT 113
50741: PPUSH
50742: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50746: LD_INT 120
50748: PPUSH
50749: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50753: LD_INT 121
50755: PPUSH
50756: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50760: LD_INT 122
50762: PPUSH
50763: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50767: LD_INT 123
50769: PPUSH
50770: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50774: LD_INT 124
50776: PPUSH
50777: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50781: LD_INT 125
50783: PPUSH
50784: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50788: LD_INT 126
50790: PPUSH
50791: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50795: LD_INT 200
50797: PPUSH
50798: CALL_OW 427
// end ;
50802: END
// on SailEvent ( event ) do begin if event < 100 then
50803: LD_VAR 0 1
50807: PUSH
50808: LD_INT 100
50810: LESS
50811: IFFALSE 50822
// CustomEvent ( event ) ;
50813: LD_VAR 0 1
50817: PPUSH
50818: CALL 603 0 1
// if event = 100 then
50822: LD_VAR 0 1
50826: PUSH
50827: LD_INT 100
50829: EQUAL
50830: IFFALSE 50836
// MC_ClassManager ( ) ;
50832: CALL 51228 0 0
// if event = 101 then
50836: LD_VAR 0 1
50840: PUSH
50841: LD_INT 101
50843: EQUAL
50844: IFFALSE 50850
// MC_RepairBuildings ( ) ;
50846: CALL 56010 0 0
// if event = 102 then
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 102
50857: EQUAL
50858: IFFALSE 50864
// MC_Heal ( ) ;
50860: CALL 56895 0 0
// if event = 103 then
50864: LD_VAR 0 1
50868: PUSH
50869: LD_INT 103
50871: EQUAL
50872: IFFALSE 50878
// MC_Build ( ) ;
50874: CALL 57317 0 0
// if event = 104 then
50878: LD_VAR 0 1
50882: PUSH
50883: LD_INT 104
50885: EQUAL
50886: IFFALSE 50892
// MC_TurretWeapon ( ) ;
50888: CALL 58930 0 0
// if event = 105 then
50892: LD_VAR 0 1
50896: PUSH
50897: LD_INT 105
50899: EQUAL
50900: IFFALSE 50906
// MC_BuildUpgrade ( ) ;
50902: CALL 58481 0 0
// if event = 106 then
50906: LD_VAR 0 1
50910: PUSH
50911: LD_INT 106
50913: EQUAL
50914: IFFALSE 50920
// MC_PlantMines ( ) ;
50916: CALL 59360 0 0
// if event = 107 then
50920: LD_VAR 0 1
50924: PUSH
50925: LD_INT 107
50927: EQUAL
50928: IFFALSE 50934
// MC_CollectCrates ( ) ;
50930: CALL 60151 0 0
// if event = 108 then
50934: LD_VAR 0 1
50938: PUSH
50939: LD_INT 108
50941: EQUAL
50942: IFFALSE 50948
// MC_LinkRemoteControl ( ) ;
50944: CALL 61927 0 0
// if event = 109 then
50948: LD_VAR 0 1
50952: PUSH
50953: LD_INT 109
50955: EQUAL
50956: IFFALSE 50962
// MC_ProduceVehicle ( ) ;
50958: CALL 62108 0 0
// if event = 110 then
50962: LD_VAR 0 1
50966: PUSH
50967: LD_INT 110
50969: EQUAL
50970: IFFALSE 50976
// MC_SendAttack ( ) ;
50972: CALL 62574 0 0
// if event = 111 then
50976: LD_VAR 0 1
50980: PUSH
50981: LD_INT 111
50983: EQUAL
50984: IFFALSE 50990
// MC_Defend ( ) ;
50986: CALL 62682 0 0
// if event = 112 then
50990: LD_VAR 0 1
50994: PUSH
50995: LD_INT 112
50997: EQUAL
50998: IFFALSE 51004
// MC_Research ( ) ;
51000: CALL 63309 0 0
// if event = 113 then
51004: LD_VAR 0 1
51008: PUSH
51009: LD_INT 113
51011: EQUAL
51012: IFFALSE 51018
// MC_MinesTrigger ( ) ;
51014: CALL 64423 0 0
// if event = 120 then
51018: LD_VAR 0 1
51022: PUSH
51023: LD_INT 120
51025: EQUAL
51026: IFFALSE 51032
// MC_RepairVehicle ( ) ;
51028: CALL 64522 0 0
// if event = 121 then
51032: LD_VAR 0 1
51036: PUSH
51037: LD_INT 121
51039: EQUAL
51040: IFFALSE 51046
// MC_TameApe ( ) ;
51042: CALL 65252 0 0
// if event = 122 then
51046: LD_VAR 0 1
51050: PUSH
51051: LD_INT 122
51053: EQUAL
51054: IFFALSE 51060
// MC_ChangeApeClass ( ) ;
51056: CALL 66081 0 0
// if event = 123 then
51060: LD_VAR 0 1
51064: PUSH
51065: LD_INT 123
51067: EQUAL
51068: IFFALSE 51074
// MC_Bazooka ( ) ;
51070: CALL 66731 0 0
// if event = 124 then
51074: LD_VAR 0 1
51078: PUSH
51079: LD_INT 124
51081: EQUAL
51082: IFFALSE 51088
// MC_TeleportExit ( ) ;
51084: CALL 66929 0 0
// if event = 125 then
51088: LD_VAR 0 1
51092: PUSH
51093: LD_INT 125
51095: EQUAL
51096: IFFALSE 51102
// MC_Deposits ( ) ;
51098: CALL 67576 0 0
// if event = 126 then
51102: LD_VAR 0 1
51106: PUSH
51107: LD_INT 126
51109: EQUAL
51110: IFFALSE 51116
// MC_RemoteDriver ( ) ;
51112: CALL 68201 0 0
// if event = 200 then
51116: LD_VAR 0 1
51120: PUSH
51121: LD_INT 200
51123: EQUAL
51124: IFFALSE 51130
// MC_Idle ( ) ;
51126: CALL 70150 0 0
// end ;
51130: PPOPN 1
51132: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51133: LD_INT 0
51135: PPUSH
51136: PPUSH
// if not mc_bases [ base ] or not tag then
51137: LD_EXP 43
51141: PUSH
51142: LD_VAR 0 1
51146: ARRAY
51147: NOT
51148: PUSH
51149: LD_VAR 0 2
51153: NOT
51154: OR
51155: IFFALSE 51159
// exit ;
51157: GO 51223
// for i in mc_bases [ base ] union mc_ape [ base ] do
51159: LD_ADDR_VAR 0 4
51163: PUSH
51164: LD_EXP 43
51168: PUSH
51169: LD_VAR 0 1
51173: ARRAY
51174: PUSH
51175: LD_EXP 72
51179: PUSH
51180: LD_VAR 0 1
51184: ARRAY
51185: UNION
51186: PUSH
51187: FOR_IN
51188: IFFALSE 51221
// if GetTag ( i ) = tag then
51190: LD_VAR 0 4
51194: PPUSH
51195: CALL_OW 110
51199: PUSH
51200: LD_VAR 0 2
51204: EQUAL
51205: IFFALSE 51219
// SetTag ( i , 0 ) ;
51207: LD_VAR 0 4
51211: PPUSH
51212: LD_INT 0
51214: PPUSH
51215: CALL_OW 109
51219: GO 51187
51221: POP
51222: POP
// end ;
51223: LD_VAR 0 3
51227: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51228: LD_INT 0
51230: PPUSH
51231: PPUSH
51232: PPUSH
51233: PPUSH
51234: PPUSH
51235: PPUSH
51236: PPUSH
51237: PPUSH
// if not mc_bases then
51238: LD_EXP 43
51242: NOT
51243: IFFALSE 51247
// exit ;
51245: GO 51705
// for i = 1 to mc_bases do
51247: LD_ADDR_VAR 0 2
51251: PUSH
51252: DOUBLE
51253: LD_INT 1
51255: DEC
51256: ST_TO_ADDR
51257: LD_EXP 43
51261: PUSH
51262: FOR_TO
51263: IFFALSE 51703
// begin tmp := MC_ClassCheckReq ( i ) ;
51265: LD_ADDR_VAR 0 4
51269: PUSH
51270: LD_VAR 0 2
51274: PPUSH
51275: CALL 51710 0 1
51279: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51280: LD_ADDR_EXP 84
51284: PUSH
51285: LD_EXP 84
51289: PPUSH
51290: LD_VAR 0 2
51294: PPUSH
51295: LD_VAR 0 4
51299: PPUSH
51300: CALL_OW 1
51304: ST_TO_ADDR
// if not tmp then
51305: LD_VAR 0 4
51309: NOT
51310: IFFALSE 51314
// continue ;
51312: GO 51262
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51314: LD_ADDR_VAR 0 6
51318: PUSH
51319: LD_EXP 43
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: PPUSH
51330: LD_INT 2
51332: PUSH
51333: LD_INT 30
51335: PUSH
51336: LD_INT 4
51338: PUSH
51339: EMPTY
51340: LIST
51341: LIST
51342: PUSH
51343: LD_INT 30
51345: PUSH
51346: LD_INT 5
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: LIST
51357: PPUSH
51358: CALL_OW 72
51362: PUSH
51363: LD_EXP 43
51367: PUSH
51368: LD_VAR 0 2
51372: ARRAY
51373: PPUSH
51374: LD_INT 2
51376: PUSH
51377: LD_INT 30
51379: PUSH
51380: LD_INT 0
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: PUSH
51387: LD_INT 30
51389: PUSH
51390: LD_INT 1
51392: PUSH
51393: EMPTY
51394: LIST
51395: LIST
51396: PUSH
51397: EMPTY
51398: LIST
51399: LIST
51400: LIST
51401: PPUSH
51402: CALL_OW 72
51406: PUSH
51407: LD_EXP 43
51411: PUSH
51412: LD_VAR 0 2
51416: ARRAY
51417: PPUSH
51418: LD_INT 30
51420: PUSH
51421: LD_INT 3
51423: PUSH
51424: EMPTY
51425: LIST
51426: LIST
51427: PPUSH
51428: CALL_OW 72
51432: PUSH
51433: LD_EXP 43
51437: PUSH
51438: LD_VAR 0 2
51442: ARRAY
51443: PPUSH
51444: LD_INT 2
51446: PUSH
51447: LD_INT 30
51449: PUSH
51450: LD_INT 6
51452: PUSH
51453: EMPTY
51454: LIST
51455: LIST
51456: PUSH
51457: LD_INT 30
51459: PUSH
51460: LD_INT 7
51462: PUSH
51463: EMPTY
51464: LIST
51465: LIST
51466: PUSH
51467: LD_INT 30
51469: PUSH
51470: LD_INT 8
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: PPUSH
51483: CALL_OW 72
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: ST_TO_ADDR
// for j = 1 to 4 do
51494: LD_ADDR_VAR 0 3
51498: PUSH
51499: DOUBLE
51500: LD_INT 1
51502: DEC
51503: ST_TO_ADDR
51504: LD_INT 4
51506: PUSH
51507: FOR_TO
51508: IFFALSE 51699
// begin if not tmp [ j ] then
51510: LD_VAR 0 4
51514: PUSH
51515: LD_VAR 0 3
51519: ARRAY
51520: NOT
51521: IFFALSE 51525
// continue ;
51523: GO 51507
// for p in tmp [ j ] do
51525: LD_ADDR_VAR 0 5
51529: PUSH
51530: LD_VAR 0 4
51534: PUSH
51535: LD_VAR 0 3
51539: ARRAY
51540: PUSH
51541: FOR_IN
51542: IFFALSE 51695
// begin if not b [ j ] then
51544: LD_VAR 0 6
51548: PUSH
51549: LD_VAR 0 3
51553: ARRAY
51554: NOT
51555: IFFALSE 51559
// break ;
51557: GO 51695
// e := 0 ;
51559: LD_ADDR_VAR 0 7
51563: PUSH
51564: LD_INT 0
51566: ST_TO_ADDR
// for k in b [ j ] do
51567: LD_ADDR_VAR 0 8
51571: PUSH
51572: LD_VAR 0 6
51576: PUSH
51577: LD_VAR 0 3
51581: ARRAY
51582: PUSH
51583: FOR_IN
51584: IFFALSE 51611
// if IsNotFull ( k ) then
51586: LD_VAR 0 8
51590: PPUSH
51591: CALL 12063 0 1
51595: IFFALSE 51609
// begin e := k ;
51597: LD_ADDR_VAR 0 7
51601: PUSH
51602: LD_VAR 0 8
51606: ST_TO_ADDR
// break ;
51607: GO 51611
// end ;
51609: GO 51583
51611: POP
51612: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51613: LD_VAR 0 7
51617: PUSH
51618: LD_VAR 0 5
51622: PPUSH
51623: LD_VAR 0 7
51627: PPUSH
51628: CALL 44483 0 2
51632: NOT
51633: AND
51634: IFFALSE 51693
// begin if IsInUnit ( p ) then
51636: LD_VAR 0 5
51640: PPUSH
51641: CALL_OW 310
51645: IFFALSE 51656
// ComExitBuilding ( p ) ;
51647: LD_VAR 0 5
51651: PPUSH
51652: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51656: LD_VAR 0 5
51660: PPUSH
51661: LD_VAR 0 7
51665: PPUSH
51666: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51670: LD_VAR 0 5
51674: PPUSH
51675: LD_VAR 0 3
51679: PPUSH
51680: CALL_OW 183
// AddComExitBuilding ( p ) ;
51684: LD_VAR 0 5
51688: PPUSH
51689: CALL_OW 182
// end ; end ;
51693: GO 51541
51695: POP
51696: POP
// end ;
51697: GO 51507
51699: POP
51700: POP
// end ;
51701: GO 51262
51703: POP
51704: POP
// end ;
51705: LD_VAR 0 1
51709: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51710: LD_INT 0
51712: PPUSH
51713: PPUSH
51714: PPUSH
51715: PPUSH
51716: PPUSH
51717: PPUSH
51718: PPUSH
51719: PPUSH
51720: PPUSH
51721: PPUSH
51722: PPUSH
51723: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51724: LD_VAR 0 1
51728: NOT
51729: PUSH
51730: LD_EXP 43
51734: PUSH
51735: LD_VAR 0 1
51739: ARRAY
51740: NOT
51741: OR
51742: PUSH
51743: LD_EXP 43
51747: PUSH
51748: LD_VAR 0 1
51752: ARRAY
51753: PPUSH
51754: LD_INT 2
51756: PUSH
51757: LD_INT 30
51759: PUSH
51760: LD_INT 0
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: PUSH
51767: LD_INT 30
51769: PUSH
51770: LD_INT 1
51772: PUSH
51773: EMPTY
51774: LIST
51775: LIST
51776: PUSH
51777: EMPTY
51778: LIST
51779: LIST
51780: LIST
51781: PPUSH
51782: CALL_OW 72
51786: NOT
51787: OR
51788: IFFALSE 51792
// exit ;
51790: GO 55295
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51792: LD_ADDR_VAR 0 4
51796: PUSH
51797: LD_EXP 43
51801: PUSH
51802: LD_VAR 0 1
51806: ARRAY
51807: PPUSH
51808: LD_INT 2
51810: PUSH
51811: LD_INT 25
51813: PUSH
51814: LD_INT 1
51816: PUSH
51817: EMPTY
51818: LIST
51819: LIST
51820: PUSH
51821: LD_INT 25
51823: PUSH
51824: LD_INT 2
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: PUSH
51831: LD_INT 25
51833: PUSH
51834: LD_INT 3
51836: PUSH
51837: EMPTY
51838: LIST
51839: LIST
51840: PUSH
51841: LD_INT 25
51843: PUSH
51844: LD_INT 4
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: PUSH
51851: LD_INT 25
51853: PUSH
51854: LD_INT 5
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: PUSH
51861: LD_INT 25
51863: PUSH
51864: LD_INT 8
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: PUSH
51871: LD_INT 25
51873: PUSH
51874: LD_INT 9
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: LIST
51885: LIST
51886: LIST
51887: LIST
51888: LIST
51889: LIST
51890: PPUSH
51891: CALL_OW 72
51895: ST_TO_ADDR
// if not tmp then
51896: LD_VAR 0 4
51900: NOT
51901: IFFALSE 51905
// exit ;
51903: GO 55295
// for i in tmp do
51905: LD_ADDR_VAR 0 3
51909: PUSH
51910: LD_VAR 0 4
51914: PUSH
51915: FOR_IN
51916: IFFALSE 51947
// if GetTag ( i ) then
51918: LD_VAR 0 3
51922: PPUSH
51923: CALL_OW 110
51927: IFFALSE 51945
// tmp := tmp diff i ;
51929: LD_ADDR_VAR 0 4
51933: PUSH
51934: LD_VAR 0 4
51938: PUSH
51939: LD_VAR 0 3
51943: DIFF
51944: ST_TO_ADDR
51945: GO 51915
51947: POP
51948: POP
// if not tmp then
51949: LD_VAR 0 4
51953: NOT
51954: IFFALSE 51958
// exit ;
51956: GO 55295
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51958: LD_ADDR_VAR 0 5
51962: PUSH
51963: LD_EXP 43
51967: PUSH
51968: LD_VAR 0 1
51972: ARRAY
51973: PPUSH
51974: LD_INT 2
51976: PUSH
51977: LD_INT 25
51979: PUSH
51980: LD_INT 1
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: LD_INT 25
51989: PUSH
51990: LD_INT 5
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PUSH
51997: LD_INT 25
51999: PUSH
52000: LD_INT 8
52002: PUSH
52003: EMPTY
52004: LIST
52005: LIST
52006: PUSH
52007: LD_INT 25
52009: PUSH
52010: LD_INT 9
52012: PUSH
52013: EMPTY
52014: LIST
52015: LIST
52016: PUSH
52017: EMPTY
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: PPUSH
52024: CALL_OW 72
52028: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52029: LD_ADDR_VAR 0 6
52033: PUSH
52034: LD_EXP 43
52038: PUSH
52039: LD_VAR 0 1
52043: ARRAY
52044: PPUSH
52045: LD_INT 25
52047: PUSH
52048: LD_INT 2
52050: PUSH
52051: EMPTY
52052: LIST
52053: LIST
52054: PPUSH
52055: CALL_OW 72
52059: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52060: LD_ADDR_VAR 0 7
52064: PUSH
52065: LD_EXP 43
52069: PUSH
52070: LD_VAR 0 1
52074: ARRAY
52075: PPUSH
52076: LD_INT 25
52078: PUSH
52079: LD_INT 3
52081: PUSH
52082: EMPTY
52083: LIST
52084: LIST
52085: PPUSH
52086: CALL_OW 72
52090: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52091: LD_ADDR_VAR 0 8
52095: PUSH
52096: LD_EXP 43
52100: PUSH
52101: LD_VAR 0 1
52105: ARRAY
52106: PPUSH
52107: LD_INT 25
52109: PUSH
52110: LD_INT 4
52112: PUSH
52113: EMPTY
52114: LIST
52115: LIST
52116: PUSH
52117: LD_INT 24
52119: PUSH
52120: LD_INT 251
52122: PUSH
52123: EMPTY
52124: LIST
52125: LIST
52126: PUSH
52127: EMPTY
52128: LIST
52129: LIST
52130: PPUSH
52131: CALL_OW 72
52135: ST_TO_ADDR
// if mc_scan [ base ] then
52136: LD_EXP 66
52140: PUSH
52141: LD_VAR 0 1
52145: ARRAY
52146: IFFALSE 52607
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52148: LD_ADDR_EXP 85
52152: PUSH
52153: LD_EXP 85
52157: PPUSH
52158: LD_VAR 0 1
52162: PPUSH
52163: LD_INT 4
52165: PPUSH
52166: CALL_OW 1
52170: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52171: LD_ADDR_VAR 0 12
52175: PUSH
52176: LD_EXP 43
52180: PUSH
52181: LD_VAR 0 1
52185: ARRAY
52186: PPUSH
52187: LD_INT 2
52189: PUSH
52190: LD_INT 30
52192: PUSH
52193: LD_INT 4
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PUSH
52200: LD_INT 30
52202: PUSH
52203: LD_INT 5
52205: PUSH
52206: EMPTY
52207: LIST
52208: LIST
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: LIST
52214: PPUSH
52215: CALL_OW 72
52219: ST_TO_ADDR
// if not b then
52220: LD_VAR 0 12
52224: NOT
52225: IFFALSE 52229
// exit ;
52227: GO 55295
// p := [ ] ;
52229: LD_ADDR_VAR 0 11
52233: PUSH
52234: EMPTY
52235: ST_TO_ADDR
// if sci >= 2 then
52236: LD_VAR 0 8
52240: PUSH
52241: LD_INT 2
52243: GREATEREQUAL
52244: IFFALSE 52275
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52246: LD_ADDR_VAR 0 8
52250: PUSH
52251: LD_VAR 0 8
52255: PUSH
52256: LD_INT 1
52258: ARRAY
52259: PUSH
52260: LD_VAR 0 8
52264: PUSH
52265: LD_INT 2
52267: ARRAY
52268: PUSH
52269: EMPTY
52270: LIST
52271: LIST
52272: ST_TO_ADDR
52273: GO 52336
// if sci = 1 then
52275: LD_VAR 0 8
52279: PUSH
52280: LD_INT 1
52282: EQUAL
52283: IFFALSE 52304
// sci := [ sci [ 1 ] ] else
52285: LD_ADDR_VAR 0 8
52289: PUSH
52290: LD_VAR 0 8
52294: PUSH
52295: LD_INT 1
52297: ARRAY
52298: PUSH
52299: EMPTY
52300: LIST
52301: ST_TO_ADDR
52302: GO 52336
// if sci = 0 then
52304: LD_VAR 0 8
52308: PUSH
52309: LD_INT 0
52311: EQUAL
52312: IFFALSE 52336
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52314: LD_ADDR_VAR 0 11
52318: PUSH
52319: LD_VAR 0 4
52323: PPUSH
52324: LD_INT 4
52326: PPUSH
52327: CALL 44346 0 2
52331: PUSH
52332: LD_INT 1
52334: ARRAY
52335: ST_TO_ADDR
// if eng > 4 then
52336: LD_VAR 0 6
52340: PUSH
52341: LD_INT 4
52343: GREATER
52344: IFFALSE 52390
// for i = eng downto 4 do
52346: LD_ADDR_VAR 0 3
52350: PUSH
52351: DOUBLE
52352: LD_VAR 0 6
52356: INC
52357: ST_TO_ADDR
52358: LD_INT 4
52360: PUSH
52361: FOR_DOWNTO
52362: IFFALSE 52388
// eng := eng diff eng [ i ] ;
52364: LD_ADDR_VAR 0 6
52368: PUSH
52369: LD_VAR 0 6
52373: PUSH
52374: LD_VAR 0 6
52378: PUSH
52379: LD_VAR 0 3
52383: ARRAY
52384: DIFF
52385: ST_TO_ADDR
52386: GO 52361
52388: POP
52389: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52390: LD_ADDR_VAR 0 4
52394: PUSH
52395: LD_VAR 0 4
52399: PUSH
52400: LD_VAR 0 5
52404: PUSH
52405: LD_VAR 0 6
52409: UNION
52410: PUSH
52411: LD_VAR 0 7
52415: UNION
52416: PUSH
52417: LD_VAR 0 8
52421: UNION
52422: DIFF
52423: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52424: LD_ADDR_VAR 0 13
52428: PUSH
52429: LD_EXP 43
52433: PUSH
52434: LD_VAR 0 1
52438: ARRAY
52439: PPUSH
52440: LD_INT 2
52442: PUSH
52443: LD_INT 30
52445: PUSH
52446: LD_INT 32
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PUSH
52453: LD_INT 30
52455: PUSH
52456: LD_INT 31
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: PUSH
52463: EMPTY
52464: LIST
52465: LIST
52466: LIST
52467: PPUSH
52468: CALL_OW 72
52472: PUSH
52473: LD_EXP 43
52477: PUSH
52478: LD_VAR 0 1
52482: ARRAY
52483: PPUSH
52484: LD_INT 2
52486: PUSH
52487: LD_INT 30
52489: PUSH
52490: LD_INT 4
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: PUSH
52497: LD_INT 30
52499: PUSH
52500: LD_INT 5
52502: PUSH
52503: EMPTY
52504: LIST
52505: LIST
52506: PUSH
52507: EMPTY
52508: LIST
52509: LIST
52510: LIST
52511: PPUSH
52512: CALL_OW 72
52516: PUSH
52517: LD_INT 6
52519: MUL
52520: PLUS
52521: ST_TO_ADDR
// if bcount < tmp then
52522: LD_VAR 0 13
52526: PUSH
52527: LD_VAR 0 4
52531: LESS
52532: IFFALSE 52578
// for i = tmp downto bcount do
52534: LD_ADDR_VAR 0 3
52538: PUSH
52539: DOUBLE
52540: LD_VAR 0 4
52544: INC
52545: ST_TO_ADDR
52546: LD_VAR 0 13
52550: PUSH
52551: FOR_DOWNTO
52552: IFFALSE 52576
// tmp := Delete ( tmp , tmp ) ;
52554: LD_ADDR_VAR 0 4
52558: PUSH
52559: LD_VAR 0 4
52563: PPUSH
52564: LD_VAR 0 4
52568: PPUSH
52569: CALL_OW 3
52573: ST_TO_ADDR
52574: GO 52551
52576: POP
52577: POP
// result := [ tmp , 0 , 0 , p ] ;
52578: LD_ADDR_VAR 0 2
52582: PUSH
52583: LD_VAR 0 4
52587: PUSH
52588: LD_INT 0
52590: PUSH
52591: LD_INT 0
52593: PUSH
52594: LD_VAR 0 11
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
// exit ;
52605: GO 55295
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52607: LD_EXP 43
52611: PUSH
52612: LD_VAR 0 1
52616: ARRAY
52617: PPUSH
52618: LD_INT 2
52620: PUSH
52621: LD_INT 30
52623: PUSH
52624: LD_INT 6
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: PUSH
52631: LD_INT 30
52633: PUSH
52634: LD_INT 7
52636: PUSH
52637: EMPTY
52638: LIST
52639: LIST
52640: PUSH
52641: LD_INT 30
52643: PUSH
52644: LD_INT 8
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: PUSH
52651: EMPTY
52652: LIST
52653: LIST
52654: LIST
52655: LIST
52656: PPUSH
52657: CALL_OW 72
52661: NOT
52662: PUSH
52663: LD_EXP 43
52667: PUSH
52668: LD_VAR 0 1
52672: ARRAY
52673: PPUSH
52674: LD_INT 30
52676: PUSH
52677: LD_INT 3
52679: PUSH
52680: EMPTY
52681: LIST
52682: LIST
52683: PPUSH
52684: CALL_OW 72
52688: NOT
52689: AND
52690: IFFALSE 52762
// begin if eng = tmp then
52692: LD_VAR 0 6
52696: PUSH
52697: LD_VAR 0 4
52701: EQUAL
52702: IFFALSE 52706
// exit ;
52704: GO 55295
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52706: LD_ADDR_EXP 85
52710: PUSH
52711: LD_EXP 85
52715: PPUSH
52716: LD_VAR 0 1
52720: PPUSH
52721: LD_INT 1
52723: PPUSH
52724: CALL_OW 1
52728: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52729: LD_ADDR_VAR 0 2
52733: PUSH
52734: LD_INT 0
52736: PUSH
52737: LD_VAR 0 4
52741: PUSH
52742: LD_VAR 0 6
52746: DIFF
52747: PUSH
52748: LD_INT 0
52750: PUSH
52751: LD_INT 0
52753: PUSH
52754: EMPTY
52755: LIST
52756: LIST
52757: LIST
52758: LIST
52759: ST_TO_ADDR
// exit ;
52760: GO 55295
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52762: LD_EXP 70
52766: PUSH
52767: LD_EXP 69
52771: PUSH
52772: LD_VAR 0 1
52776: ARRAY
52777: ARRAY
52778: PUSH
52779: LD_EXP 43
52783: PUSH
52784: LD_VAR 0 1
52788: ARRAY
52789: PPUSH
52790: LD_INT 2
52792: PUSH
52793: LD_INT 30
52795: PUSH
52796: LD_INT 6
52798: PUSH
52799: EMPTY
52800: LIST
52801: LIST
52802: PUSH
52803: LD_INT 30
52805: PUSH
52806: LD_INT 7
52808: PUSH
52809: EMPTY
52810: LIST
52811: LIST
52812: PUSH
52813: LD_INT 30
52815: PUSH
52816: LD_INT 8
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: LIST
52827: LIST
52828: PPUSH
52829: CALL_OW 72
52833: AND
52834: PUSH
52835: LD_EXP 43
52839: PUSH
52840: LD_VAR 0 1
52844: ARRAY
52845: PPUSH
52846: LD_INT 30
52848: PUSH
52849: LD_INT 3
52851: PUSH
52852: EMPTY
52853: LIST
52854: LIST
52855: PPUSH
52856: CALL_OW 72
52860: NOT
52861: AND
52862: IFFALSE 53076
// begin if sci >= 6 then
52864: LD_VAR 0 8
52868: PUSH
52869: LD_INT 6
52871: GREATEREQUAL
52872: IFFALSE 52876
// exit ;
52874: GO 55295
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
52876: LD_ADDR_EXP 85
52880: PUSH
52881: LD_EXP 85
52885: PPUSH
52886: LD_VAR 0 1
52890: PPUSH
52891: LD_INT 2
52893: PPUSH
52894: CALL_OW 1
52898: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
52899: LD_ADDR_VAR 0 9
52903: PUSH
52904: LD_VAR 0 4
52908: PUSH
52909: LD_VAR 0 8
52913: DIFF
52914: PPUSH
52915: LD_INT 4
52917: PPUSH
52918: CALL 44346 0 2
52922: ST_TO_ADDR
// p := [ ] ;
52923: LD_ADDR_VAR 0 11
52927: PUSH
52928: EMPTY
52929: ST_TO_ADDR
// if sci < 6 and sort > 6 then
52930: LD_VAR 0 8
52934: PUSH
52935: LD_INT 6
52937: LESS
52938: PUSH
52939: LD_VAR 0 9
52943: PUSH
52944: LD_INT 6
52946: GREATER
52947: AND
52948: IFFALSE 53029
// begin for i = 1 to 6 - sci do
52950: LD_ADDR_VAR 0 3
52954: PUSH
52955: DOUBLE
52956: LD_INT 1
52958: DEC
52959: ST_TO_ADDR
52960: LD_INT 6
52962: PUSH
52963: LD_VAR 0 8
52967: MINUS
52968: PUSH
52969: FOR_TO
52970: IFFALSE 53025
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
52972: LD_ADDR_VAR 0 11
52976: PUSH
52977: LD_VAR 0 11
52981: PPUSH
52982: LD_VAR 0 11
52986: PUSH
52987: LD_INT 1
52989: PLUS
52990: PPUSH
52991: LD_VAR 0 9
52995: PUSH
52996: LD_INT 1
52998: ARRAY
52999: PPUSH
53000: CALL_OW 2
53004: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53005: LD_ADDR_VAR 0 9
53009: PUSH
53010: LD_VAR 0 9
53014: PPUSH
53015: LD_INT 1
53017: PPUSH
53018: CALL_OW 3
53022: ST_TO_ADDR
// end ;
53023: GO 52969
53025: POP
53026: POP
// end else
53027: GO 53049
// if sort then
53029: LD_VAR 0 9
53033: IFFALSE 53049
// p := sort [ 1 ] ;
53035: LD_ADDR_VAR 0 11
53039: PUSH
53040: LD_VAR 0 9
53044: PUSH
53045: LD_INT 1
53047: ARRAY
53048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53049: LD_ADDR_VAR 0 2
53053: PUSH
53054: LD_INT 0
53056: PUSH
53057: LD_INT 0
53059: PUSH
53060: LD_INT 0
53062: PUSH
53063: LD_VAR 0 11
53067: PUSH
53068: EMPTY
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: ST_TO_ADDR
// exit ;
53074: GO 55295
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53076: LD_EXP 70
53080: PUSH
53081: LD_EXP 69
53085: PUSH
53086: LD_VAR 0 1
53090: ARRAY
53091: ARRAY
53092: PUSH
53093: LD_EXP 43
53097: PUSH
53098: LD_VAR 0 1
53102: ARRAY
53103: PPUSH
53104: LD_INT 2
53106: PUSH
53107: LD_INT 30
53109: PUSH
53110: LD_INT 6
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: PUSH
53117: LD_INT 30
53119: PUSH
53120: LD_INT 7
53122: PUSH
53123: EMPTY
53124: LIST
53125: LIST
53126: PUSH
53127: LD_INT 30
53129: PUSH
53130: LD_INT 8
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: LIST
53141: LIST
53142: PPUSH
53143: CALL_OW 72
53147: AND
53148: PUSH
53149: LD_EXP 43
53153: PUSH
53154: LD_VAR 0 1
53158: ARRAY
53159: PPUSH
53160: LD_INT 30
53162: PUSH
53163: LD_INT 3
53165: PUSH
53166: EMPTY
53167: LIST
53168: LIST
53169: PPUSH
53170: CALL_OW 72
53174: AND
53175: IFFALSE 53909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53177: LD_ADDR_EXP 85
53181: PUSH
53182: LD_EXP 85
53186: PPUSH
53187: LD_VAR 0 1
53191: PPUSH
53192: LD_INT 3
53194: PPUSH
53195: CALL_OW 1
53199: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53200: LD_ADDR_VAR 0 2
53204: PUSH
53205: LD_INT 0
53207: PUSH
53208: LD_INT 0
53210: PUSH
53211: LD_INT 0
53213: PUSH
53214: LD_INT 0
53216: PUSH
53217: EMPTY
53218: LIST
53219: LIST
53220: LIST
53221: LIST
53222: ST_TO_ADDR
// if not eng then
53223: LD_VAR 0 6
53227: NOT
53228: IFFALSE 53291
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53230: LD_ADDR_VAR 0 11
53234: PUSH
53235: LD_VAR 0 4
53239: PPUSH
53240: LD_INT 2
53242: PPUSH
53243: CALL 44346 0 2
53247: PUSH
53248: LD_INT 1
53250: ARRAY
53251: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53252: LD_ADDR_VAR 0 2
53256: PUSH
53257: LD_VAR 0 2
53261: PPUSH
53262: LD_INT 2
53264: PPUSH
53265: LD_VAR 0 11
53269: PPUSH
53270: CALL_OW 1
53274: ST_TO_ADDR
// tmp := tmp diff p ;
53275: LD_ADDR_VAR 0 4
53279: PUSH
53280: LD_VAR 0 4
53284: PUSH
53285: LD_VAR 0 11
53289: DIFF
53290: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53291: LD_VAR 0 4
53295: PUSH
53296: LD_VAR 0 8
53300: PUSH
53301: LD_INT 6
53303: LESS
53304: AND
53305: IFFALSE 53493
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53307: LD_ADDR_VAR 0 9
53311: PUSH
53312: LD_VAR 0 4
53316: PUSH
53317: LD_VAR 0 8
53321: PUSH
53322: LD_VAR 0 7
53326: UNION
53327: DIFF
53328: PPUSH
53329: LD_INT 4
53331: PPUSH
53332: CALL 44346 0 2
53336: ST_TO_ADDR
// p := [ ] ;
53337: LD_ADDR_VAR 0 11
53341: PUSH
53342: EMPTY
53343: ST_TO_ADDR
// if sort then
53344: LD_VAR 0 9
53348: IFFALSE 53464
// for i = 1 to 6 - sci do
53350: LD_ADDR_VAR 0 3
53354: PUSH
53355: DOUBLE
53356: LD_INT 1
53358: DEC
53359: ST_TO_ADDR
53360: LD_INT 6
53362: PUSH
53363: LD_VAR 0 8
53367: MINUS
53368: PUSH
53369: FOR_TO
53370: IFFALSE 53462
// begin if i = sort then
53372: LD_VAR 0 3
53376: PUSH
53377: LD_VAR 0 9
53381: EQUAL
53382: IFFALSE 53386
// break ;
53384: GO 53462
// if GetClass ( i ) = 4 then
53386: LD_VAR 0 3
53390: PPUSH
53391: CALL_OW 257
53395: PUSH
53396: LD_INT 4
53398: EQUAL
53399: IFFALSE 53403
// continue ;
53401: GO 53369
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53403: LD_ADDR_VAR 0 11
53407: PUSH
53408: LD_VAR 0 11
53412: PPUSH
53413: LD_VAR 0 11
53417: PUSH
53418: LD_INT 1
53420: PLUS
53421: PPUSH
53422: LD_VAR 0 9
53426: PUSH
53427: LD_VAR 0 3
53431: ARRAY
53432: PPUSH
53433: CALL_OW 2
53437: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53438: LD_ADDR_VAR 0 4
53442: PUSH
53443: LD_VAR 0 4
53447: PUSH
53448: LD_VAR 0 9
53452: PUSH
53453: LD_VAR 0 3
53457: ARRAY
53458: DIFF
53459: ST_TO_ADDR
// end ;
53460: GO 53369
53462: POP
53463: POP
// if p then
53464: LD_VAR 0 11
53468: IFFALSE 53493
// result := Replace ( result , 4 , p ) ;
53470: LD_ADDR_VAR 0 2
53474: PUSH
53475: LD_VAR 0 2
53479: PPUSH
53480: LD_INT 4
53482: PPUSH
53483: LD_VAR 0 11
53487: PPUSH
53488: CALL_OW 1
53492: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53493: LD_VAR 0 4
53497: PUSH
53498: LD_VAR 0 7
53502: PUSH
53503: LD_INT 6
53505: LESS
53506: AND
53507: IFFALSE 53695
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53509: LD_ADDR_VAR 0 9
53513: PUSH
53514: LD_VAR 0 4
53518: PUSH
53519: LD_VAR 0 8
53523: PUSH
53524: LD_VAR 0 7
53528: UNION
53529: DIFF
53530: PPUSH
53531: LD_INT 3
53533: PPUSH
53534: CALL 44346 0 2
53538: ST_TO_ADDR
// p := [ ] ;
53539: LD_ADDR_VAR 0 11
53543: PUSH
53544: EMPTY
53545: ST_TO_ADDR
// if sort then
53546: LD_VAR 0 9
53550: IFFALSE 53666
// for i = 1 to 6 - mech do
53552: LD_ADDR_VAR 0 3
53556: PUSH
53557: DOUBLE
53558: LD_INT 1
53560: DEC
53561: ST_TO_ADDR
53562: LD_INT 6
53564: PUSH
53565: LD_VAR 0 7
53569: MINUS
53570: PUSH
53571: FOR_TO
53572: IFFALSE 53664
// begin if i = sort then
53574: LD_VAR 0 3
53578: PUSH
53579: LD_VAR 0 9
53583: EQUAL
53584: IFFALSE 53588
// break ;
53586: GO 53664
// if GetClass ( i ) = 3 then
53588: LD_VAR 0 3
53592: PPUSH
53593: CALL_OW 257
53597: PUSH
53598: LD_INT 3
53600: EQUAL
53601: IFFALSE 53605
// continue ;
53603: GO 53571
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53605: LD_ADDR_VAR 0 11
53609: PUSH
53610: LD_VAR 0 11
53614: PPUSH
53615: LD_VAR 0 11
53619: PUSH
53620: LD_INT 1
53622: PLUS
53623: PPUSH
53624: LD_VAR 0 9
53628: PUSH
53629: LD_VAR 0 3
53633: ARRAY
53634: PPUSH
53635: CALL_OW 2
53639: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53640: LD_ADDR_VAR 0 4
53644: PUSH
53645: LD_VAR 0 4
53649: PUSH
53650: LD_VAR 0 9
53654: PUSH
53655: LD_VAR 0 3
53659: ARRAY
53660: DIFF
53661: ST_TO_ADDR
// end ;
53662: GO 53571
53664: POP
53665: POP
// if p then
53666: LD_VAR 0 11
53670: IFFALSE 53695
// result := Replace ( result , 3 , p ) ;
53672: LD_ADDR_VAR 0 2
53676: PUSH
53677: LD_VAR 0 2
53681: PPUSH
53682: LD_INT 3
53684: PPUSH
53685: LD_VAR 0 11
53689: PPUSH
53690: CALL_OW 1
53694: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53695: LD_VAR 0 4
53699: PUSH
53700: LD_INT 6
53702: GREATER
53703: PUSH
53704: LD_VAR 0 6
53708: PUSH
53709: LD_INT 6
53711: LESS
53712: AND
53713: IFFALSE 53907
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53715: LD_ADDR_VAR 0 9
53719: PUSH
53720: LD_VAR 0 4
53724: PUSH
53725: LD_VAR 0 8
53729: PUSH
53730: LD_VAR 0 7
53734: UNION
53735: PUSH
53736: LD_VAR 0 6
53740: UNION
53741: DIFF
53742: PPUSH
53743: LD_INT 2
53745: PPUSH
53746: CALL 44346 0 2
53750: ST_TO_ADDR
// p := [ ] ;
53751: LD_ADDR_VAR 0 11
53755: PUSH
53756: EMPTY
53757: ST_TO_ADDR
// if sort then
53758: LD_VAR 0 9
53762: IFFALSE 53878
// for i = 1 to 6 - eng do
53764: LD_ADDR_VAR 0 3
53768: PUSH
53769: DOUBLE
53770: LD_INT 1
53772: DEC
53773: ST_TO_ADDR
53774: LD_INT 6
53776: PUSH
53777: LD_VAR 0 6
53781: MINUS
53782: PUSH
53783: FOR_TO
53784: IFFALSE 53876
// begin if i = sort then
53786: LD_VAR 0 3
53790: PUSH
53791: LD_VAR 0 9
53795: EQUAL
53796: IFFALSE 53800
// break ;
53798: GO 53876
// if GetClass ( i ) = 2 then
53800: LD_VAR 0 3
53804: PPUSH
53805: CALL_OW 257
53809: PUSH
53810: LD_INT 2
53812: EQUAL
53813: IFFALSE 53817
// continue ;
53815: GO 53783
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53817: LD_ADDR_VAR 0 11
53821: PUSH
53822: LD_VAR 0 11
53826: PPUSH
53827: LD_VAR 0 11
53831: PUSH
53832: LD_INT 1
53834: PLUS
53835: PPUSH
53836: LD_VAR 0 9
53840: PUSH
53841: LD_VAR 0 3
53845: ARRAY
53846: PPUSH
53847: CALL_OW 2
53851: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53852: LD_ADDR_VAR 0 4
53856: PUSH
53857: LD_VAR 0 4
53861: PUSH
53862: LD_VAR 0 9
53866: PUSH
53867: LD_VAR 0 3
53871: ARRAY
53872: DIFF
53873: ST_TO_ADDR
// end ;
53874: GO 53783
53876: POP
53877: POP
// if p then
53878: LD_VAR 0 11
53882: IFFALSE 53907
// result := Replace ( result , 2 , p ) ;
53884: LD_ADDR_VAR 0 2
53888: PUSH
53889: LD_VAR 0 2
53893: PPUSH
53894: LD_INT 2
53896: PPUSH
53897: LD_VAR 0 11
53901: PPUSH
53902: CALL_OW 1
53906: ST_TO_ADDR
// end ; exit ;
53907: GO 55295
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
53909: LD_EXP 70
53913: PUSH
53914: LD_EXP 69
53918: PUSH
53919: LD_VAR 0 1
53923: ARRAY
53924: ARRAY
53925: NOT
53926: PUSH
53927: LD_EXP 43
53931: PUSH
53932: LD_VAR 0 1
53936: ARRAY
53937: PPUSH
53938: LD_INT 30
53940: PUSH
53941: LD_INT 3
53943: PUSH
53944: EMPTY
53945: LIST
53946: LIST
53947: PPUSH
53948: CALL_OW 72
53952: AND
53953: PUSH
53954: LD_EXP 48
53958: PUSH
53959: LD_VAR 0 1
53963: ARRAY
53964: AND
53965: IFFALSE 54573
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
53967: LD_ADDR_EXP 85
53971: PUSH
53972: LD_EXP 85
53976: PPUSH
53977: LD_VAR 0 1
53981: PPUSH
53982: LD_INT 5
53984: PPUSH
53985: CALL_OW 1
53989: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53990: LD_ADDR_VAR 0 2
53994: PUSH
53995: LD_INT 0
53997: PUSH
53998: LD_INT 0
54000: PUSH
54001: LD_INT 0
54003: PUSH
54004: LD_INT 0
54006: PUSH
54007: EMPTY
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: ST_TO_ADDR
// if sci > 1 then
54013: LD_VAR 0 8
54017: PUSH
54018: LD_INT 1
54020: GREATER
54021: IFFALSE 54049
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54023: LD_ADDR_VAR 0 4
54027: PUSH
54028: LD_VAR 0 4
54032: PUSH
54033: LD_VAR 0 8
54037: PUSH
54038: LD_VAR 0 8
54042: PUSH
54043: LD_INT 1
54045: ARRAY
54046: DIFF
54047: DIFF
54048: ST_TO_ADDR
// if tmp and not sci then
54049: LD_VAR 0 4
54053: PUSH
54054: LD_VAR 0 8
54058: NOT
54059: AND
54060: IFFALSE 54129
// begin sort := SortBySkill ( tmp , 4 ) ;
54062: LD_ADDR_VAR 0 9
54066: PUSH
54067: LD_VAR 0 4
54071: PPUSH
54072: LD_INT 4
54074: PPUSH
54075: CALL 44346 0 2
54079: ST_TO_ADDR
// if sort then
54080: LD_VAR 0 9
54084: IFFALSE 54100
// p := sort [ 1 ] ;
54086: LD_ADDR_VAR 0 11
54090: PUSH
54091: LD_VAR 0 9
54095: PUSH
54096: LD_INT 1
54098: ARRAY
54099: ST_TO_ADDR
// if p then
54100: LD_VAR 0 11
54104: IFFALSE 54129
// result := Replace ( result , 4 , p ) ;
54106: LD_ADDR_VAR 0 2
54110: PUSH
54111: LD_VAR 0 2
54115: PPUSH
54116: LD_INT 4
54118: PPUSH
54119: LD_VAR 0 11
54123: PPUSH
54124: CALL_OW 1
54128: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54129: LD_ADDR_VAR 0 4
54133: PUSH
54134: LD_VAR 0 4
54138: PUSH
54139: LD_VAR 0 7
54143: DIFF
54144: ST_TO_ADDR
// if tmp and mech < 6 then
54145: LD_VAR 0 4
54149: PUSH
54150: LD_VAR 0 7
54154: PUSH
54155: LD_INT 6
54157: LESS
54158: AND
54159: IFFALSE 54347
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54161: LD_ADDR_VAR 0 9
54165: PUSH
54166: LD_VAR 0 4
54170: PUSH
54171: LD_VAR 0 8
54175: PUSH
54176: LD_VAR 0 7
54180: UNION
54181: DIFF
54182: PPUSH
54183: LD_INT 3
54185: PPUSH
54186: CALL 44346 0 2
54190: ST_TO_ADDR
// p := [ ] ;
54191: LD_ADDR_VAR 0 11
54195: PUSH
54196: EMPTY
54197: ST_TO_ADDR
// if sort then
54198: LD_VAR 0 9
54202: IFFALSE 54318
// for i = 1 to 6 - mech do
54204: LD_ADDR_VAR 0 3
54208: PUSH
54209: DOUBLE
54210: LD_INT 1
54212: DEC
54213: ST_TO_ADDR
54214: LD_INT 6
54216: PUSH
54217: LD_VAR 0 7
54221: MINUS
54222: PUSH
54223: FOR_TO
54224: IFFALSE 54316
// begin if i = sort then
54226: LD_VAR 0 3
54230: PUSH
54231: LD_VAR 0 9
54235: EQUAL
54236: IFFALSE 54240
// break ;
54238: GO 54316
// if GetClass ( i ) = 3 then
54240: LD_VAR 0 3
54244: PPUSH
54245: CALL_OW 257
54249: PUSH
54250: LD_INT 3
54252: EQUAL
54253: IFFALSE 54257
// continue ;
54255: GO 54223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54257: LD_ADDR_VAR 0 11
54261: PUSH
54262: LD_VAR 0 11
54266: PPUSH
54267: LD_VAR 0 11
54271: PUSH
54272: LD_INT 1
54274: PLUS
54275: PPUSH
54276: LD_VAR 0 9
54280: PUSH
54281: LD_VAR 0 3
54285: ARRAY
54286: PPUSH
54287: CALL_OW 2
54291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54292: LD_ADDR_VAR 0 4
54296: PUSH
54297: LD_VAR 0 4
54301: PUSH
54302: LD_VAR 0 9
54306: PUSH
54307: LD_VAR 0 3
54311: ARRAY
54312: DIFF
54313: ST_TO_ADDR
// end ;
54314: GO 54223
54316: POP
54317: POP
// if p then
54318: LD_VAR 0 11
54322: IFFALSE 54347
// result := Replace ( result , 3 , p ) ;
54324: LD_ADDR_VAR 0 2
54328: PUSH
54329: LD_VAR 0 2
54333: PPUSH
54334: LD_INT 3
54336: PPUSH
54337: LD_VAR 0 11
54341: PPUSH
54342: CALL_OW 1
54346: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54347: LD_ADDR_VAR 0 4
54351: PUSH
54352: LD_VAR 0 4
54356: PUSH
54357: LD_VAR 0 6
54361: DIFF
54362: ST_TO_ADDR
// if tmp and eng < 6 then
54363: LD_VAR 0 4
54367: PUSH
54368: LD_VAR 0 6
54372: PUSH
54373: LD_INT 6
54375: LESS
54376: AND
54377: IFFALSE 54571
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54379: LD_ADDR_VAR 0 9
54383: PUSH
54384: LD_VAR 0 4
54388: PUSH
54389: LD_VAR 0 8
54393: PUSH
54394: LD_VAR 0 7
54398: UNION
54399: PUSH
54400: LD_VAR 0 6
54404: UNION
54405: DIFF
54406: PPUSH
54407: LD_INT 2
54409: PPUSH
54410: CALL 44346 0 2
54414: ST_TO_ADDR
// p := [ ] ;
54415: LD_ADDR_VAR 0 11
54419: PUSH
54420: EMPTY
54421: ST_TO_ADDR
// if sort then
54422: LD_VAR 0 9
54426: IFFALSE 54542
// for i = 1 to 6 - eng do
54428: LD_ADDR_VAR 0 3
54432: PUSH
54433: DOUBLE
54434: LD_INT 1
54436: DEC
54437: ST_TO_ADDR
54438: LD_INT 6
54440: PUSH
54441: LD_VAR 0 6
54445: MINUS
54446: PUSH
54447: FOR_TO
54448: IFFALSE 54540
// begin if i = sort then
54450: LD_VAR 0 3
54454: PUSH
54455: LD_VAR 0 9
54459: EQUAL
54460: IFFALSE 54464
// break ;
54462: GO 54540
// if GetClass ( i ) = 2 then
54464: LD_VAR 0 3
54468: PPUSH
54469: CALL_OW 257
54473: PUSH
54474: LD_INT 2
54476: EQUAL
54477: IFFALSE 54481
// continue ;
54479: GO 54447
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54481: LD_ADDR_VAR 0 11
54485: PUSH
54486: LD_VAR 0 11
54490: PPUSH
54491: LD_VAR 0 11
54495: PUSH
54496: LD_INT 1
54498: PLUS
54499: PPUSH
54500: LD_VAR 0 9
54504: PUSH
54505: LD_VAR 0 3
54509: ARRAY
54510: PPUSH
54511: CALL_OW 2
54515: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54516: LD_ADDR_VAR 0 4
54520: PUSH
54521: LD_VAR 0 4
54525: PUSH
54526: LD_VAR 0 9
54530: PUSH
54531: LD_VAR 0 3
54535: ARRAY
54536: DIFF
54537: ST_TO_ADDR
// end ;
54538: GO 54447
54540: POP
54541: POP
// if p then
54542: LD_VAR 0 11
54546: IFFALSE 54571
// result := Replace ( result , 2 , p ) ;
54548: LD_ADDR_VAR 0 2
54552: PUSH
54553: LD_VAR 0 2
54557: PPUSH
54558: LD_INT 2
54560: PPUSH
54561: LD_VAR 0 11
54565: PPUSH
54566: CALL_OW 1
54570: ST_TO_ADDR
// end ; exit ;
54571: GO 55295
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54573: LD_EXP 70
54577: PUSH
54578: LD_EXP 69
54582: PUSH
54583: LD_VAR 0 1
54587: ARRAY
54588: ARRAY
54589: NOT
54590: PUSH
54591: LD_EXP 43
54595: PUSH
54596: LD_VAR 0 1
54600: ARRAY
54601: PPUSH
54602: LD_INT 30
54604: PUSH
54605: LD_INT 3
54607: PUSH
54608: EMPTY
54609: LIST
54610: LIST
54611: PPUSH
54612: CALL_OW 72
54616: AND
54617: PUSH
54618: LD_EXP 48
54622: PUSH
54623: LD_VAR 0 1
54627: ARRAY
54628: NOT
54629: AND
54630: IFFALSE 55295
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54632: LD_ADDR_EXP 85
54636: PUSH
54637: LD_EXP 85
54641: PPUSH
54642: LD_VAR 0 1
54646: PPUSH
54647: LD_INT 6
54649: PPUSH
54650: CALL_OW 1
54654: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54655: LD_ADDR_VAR 0 2
54659: PUSH
54660: LD_INT 0
54662: PUSH
54663: LD_INT 0
54665: PUSH
54666: LD_INT 0
54668: PUSH
54669: LD_INT 0
54671: PUSH
54672: EMPTY
54673: LIST
54674: LIST
54675: LIST
54676: LIST
54677: ST_TO_ADDR
// if sci >= 1 then
54678: LD_VAR 0 8
54682: PUSH
54683: LD_INT 1
54685: GREATEREQUAL
54686: IFFALSE 54708
// tmp := tmp diff sci [ 1 ] ;
54688: LD_ADDR_VAR 0 4
54692: PUSH
54693: LD_VAR 0 4
54697: PUSH
54698: LD_VAR 0 8
54702: PUSH
54703: LD_INT 1
54705: ARRAY
54706: DIFF
54707: ST_TO_ADDR
// if tmp and not sci then
54708: LD_VAR 0 4
54712: PUSH
54713: LD_VAR 0 8
54717: NOT
54718: AND
54719: IFFALSE 54788
// begin sort := SortBySkill ( tmp , 4 ) ;
54721: LD_ADDR_VAR 0 9
54725: PUSH
54726: LD_VAR 0 4
54730: PPUSH
54731: LD_INT 4
54733: PPUSH
54734: CALL 44346 0 2
54738: ST_TO_ADDR
// if sort then
54739: LD_VAR 0 9
54743: IFFALSE 54759
// p := sort [ 1 ] ;
54745: LD_ADDR_VAR 0 11
54749: PUSH
54750: LD_VAR 0 9
54754: PUSH
54755: LD_INT 1
54757: ARRAY
54758: ST_TO_ADDR
// if p then
54759: LD_VAR 0 11
54763: IFFALSE 54788
// result := Replace ( result , 4 , p ) ;
54765: LD_ADDR_VAR 0 2
54769: PUSH
54770: LD_VAR 0 2
54774: PPUSH
54775: LD_INT 4
54777: PPUSH
54778: LD_VAR 0 11
54782: PPUSH
54783: CALL_OW 1
54787: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54788: LD_ADDR_VAR 0 4
54792: PUSH
54793: LD_VAR 0 4
54797: PUSH
54798: LD_VAR 0 7
54802: DIFF
54803: ST_TO_ADDR
// if tmp and mech < 6 then
54804: LD_VAR 0 4
54808: PUSH
54809: LD_VAR 0 7
54813: PUSH
54814: LD_INT 6
54816: LESS
54817: AND
54818: IFFALSE 55000
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54820: LD_ADDR_VAR 0 9
54824: PUSH
54825: LD_VAR 0 4
54829: PUSH
54830: LD_VAR 0 7
54834: DIFF
54835: PPUSH
54836: LD_INT 3
54838: PPUSH
54839: CALL 44346 0 2
54843: ST_TO_ADDR
// p := [ ] ;
54844: LD_ADDR_VAR 0 11
54848: PUSH
54849: EMPTY
54850: ST_TO_ADDR
// if sort then
54851: LD_VAR 0 9
54855: IFFALSE 54971
// for i = 1 to 6 - mech do
54857: LD_ADDR_VAR 0 3
54861: PUSH
54862: DOUBLE
54863: LD_INT 1
54865: DEC
54866: ST_TO_ADDR
54867: LD_INT 6
54869: PUSH
54870: LD_VAR 0 7
54874: MINUS
54875: PUSH
54876: FOR_TO
54877: IFFALSE 54969
// begin if i = sort then
54879: LD_VAR 0 3
54883: PUSH
54884: LD_VAR 0 9
54888: EQUAL
54889: IFFALSE 54893
// break ;
54891: GO 54969
// if GetClass ( i ) = 3 then
54893: LD_VAR 0 3
54897: PPUSH
54898: CALL_OW 257
54902: PUSH
54903: LD_INT 3
54905: EQUAL
54906: IFFALSE 54910
// continue ;
54908: GO 54876
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54910: LD_ADDR_VAR 0 11
54914: PUSH
54915: LD_VAR 0 11
54919: PPUSH
54920: LD_VAR 0 11
54924: PUSH
54925: LD_INT 1
54927: PLUS
54928: PPUSH
54929: LD_VAR 0 9
54933: PUSH
54934: LD_VAR 0 3
54938: ARRAY
54939: PPUSH
54940: CALL_OW 2
54944: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54945: LD_ADDR_VAR 0 4
54949: PUSH
54950: LD_VAR 0 4
54954: PUSH
54955: LD_VAR 0 9
54959: PUSH
54960: LD_VAR 0 3
54964: ARRAY
54965: DIFF
54966: ST_TO_ADDR
// end ;
54967: GO 54876
54969: POP
54970: POP
// if p then
54971: LD_VAR 0 11
54975: IFFALSE 55000
// result := Replace ( result , 3 , p ) ;
54977: LD_ADDR_VAR 0 2
54981: PUSH
54982: LD_VAR 0 2
54986: PPUSH
54987: LD_INT 3
54989: PPUSH
54990: LD_VAR 0 11
54994: PPUSH
54995: CALL_OW 1
54999: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55000: LD_ADDR_VAR 0 4
55004: PUSH
55005: LD_VAR 0 4
55009: PUSH
55010: LD_VAR 0 6
55014: DIFF
55015: ST_TO_ADDR
// if tmp and eng < 4 then
55016: LD_VAR 0 4
55020: PUSH
55021: LD_VAR 0 6
55025: PUSH
55026: LD_INT 4
55028: LESS
55029: AND
55030: IFFALSE 55220
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55032: LD_ADDR_VAR 0 9
55036: PUSH
55037: LD_VAR 0 4
55041: PUSH
55042: LD_VAR 0 7
55046: PUSH
55047: LD_VAR 0 6
55051: UNION
55052: DIFF
55053: PPUSH
55054: LD_INT 2
55056: PPUSH
55057: CALL 44346 0 2
55061: ST_TO_ADDR
// p := [ ] ;
55062: LD_ADDR_VAR 0 11
55066: PUSH
55067: EMPTY
55068: ST_TO_ADDR
// if sort then
55069: LD_VAR 0 9
55073: IFFALSE 55189
// for i = 1 to 4 - eng do
55075: LD_ADDR_VAR 0 3
55079: PUSH
55080: DOUBLE
55081: LD_INT 1
55083: DEC
55084: ST_TO_ADDR
55085: LD_INT 4
55087: PUSH
55088: LD_VAR 0 6
55092: MINUS
55093: PUSH
55094: FOR_TO
55095: IFFALSE 55187
// begin if i = sort then
55097: LD_VAR 0 3
55101: PUSH
55102: LD_VAR 0 9
55106: EQUAL
55107: IFFALSE 55111
// break ;
55109: GO 55187
// if GetClass ( i ) = 2 then
55111: LD_VAR 0 3
55115: PPUSH
55116: CALL_OW 257
55120: PUSH
55121: LD_INT 2
55123: EQUAL
55124: IFFALSE 55128
// continue ;
55126: GO 55094
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55128: LD_ADDR_VAR 0 11
55132: PUSH
55133: LD_VAR 0 11
55137: PPUSH
55138: LD_VAR 0 11
55142: PUSH
55143: LD_INT 1
55145: PLUS
55146: PPUSH
55147: LD_VAR 0 9
55151: PUSH
55152: LD_VAR 0 3
55156: ARRAY
55157: PPUSH
55158: CALL_OW 2
55162: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55163: LD_ADDR_VAR 0 4
55167: PUSH
55168: LD_VAR 0 4
55172: PUSH
55173: LD_VAR 0 9
55177: PUSH
55178: LD_VAR 0 3
55182: ARRAY
55183: DIFF
55184: ST_TO_ADDR
// end ;
55185: GO 55094
55187: POP
55188: POP
// if p then
55189: LD_VAR 0 11
55193: IFFALSE 55218
// result := Replace ( result , 2 , p ) ;
55195: LD_ADDR_VAR 0 2
55199: PUSH
55200: LD_VAR 0 2
55204: PPUSH
55205: LD_INT 2
55207: PPUSH
55208: LD_VAR 0 11
55212: PPUSH
55213: CALL_OW 1
55217: ST_TO_ADDR
// end else
55218: GO 55264
// for i = eng downto 5 do
55220: LD_ADDR_VAR 0 3
55224: PUSH
55225: DOUBLE
55226: LD_VAR 0 6
55230: INC
55231: ST_TO_ADDR
55232: LD_INT 5
55234: PUSH
55235: FOR_DOWNTO
55236: IFFALSE 55262
// tmp := tmp union eng [ i ] ;
55238: LD_ADDR_VAR 0 4
55242: PUSH
55243: LD_VAR 0 4
55247: PUSH
55248: LD_VAR 0 6
55252: PUSH
55253: LD_VAR 0 3
55257: ARRAY
55258: UNION
55259: ST_TO_ADDR
55260: GO 55235
55262: POP
55263: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55264: LD_ADDR_VAR 0 2
55268: PUSH
55269: LD_VAR 0 2
55273: PPUSH
55274: LD_INT 1
55276: PPUSH
55277: LD_VAR 0 4
55281: PUSH
55282: LD_VAR 0 5
55286: DIFF
55287: PPUSH
55288: CALL_OW 1
55292: ST_TO_ADDR
// exit ;
55293: GO 55295
// end ; end ;
55295: LD_VAR 0 2
55299: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55300: LD_INT 0
55302: PPUSH
55303: PPUSH
55304: PPUSH
// if not mc_bases then
55305: LD_EXP 43
55309: NOT
55310: IFFALSE 55314
// exit ;
55312: GO 55420
// for i = 1 to mc_bases do
55314: LD_ADDR_VAR 0 2
55318: PUSH
55319: DOUBLE
55320: LD_INT 1
55322: DEC
55323: ST_TO_ADDR
55324: LD_EXP 43
55328: PUSH
55329: FOR_TO
55330: IFFALSE 55411
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55332: LD_ADDR_VAR 0 3
55336: PUSH
55337: LD_EXP 43
55341: PUSH
55342: LD_VAR 0 2
55346: ARRAY
55347: PPUSH
55348: LD_INT 21
55350: PUSH
55351: LD_INT 3
55353: PUSH
55354: EMPTY
55355: LIST
55356: LIST
55357: PUSH
55358: LD_INT 3
55360: PUSH
55361: LD_INT 24
55363: PUSH
55364: LD_INT 1000
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: PUSH
55375: EMPTY
55376: LIST
55377: LIST
55378: PPUSH
55379: CALL_OW 72
55383: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55384: LD_ADDR_EXP 44
55388: PUSH
55389: LD_EXP 44
55393: PPUSH
55394: LD_VAR 0 2
55398: PPUSH
55399: LD_VAR 0 3
55403: PPUSH
55404: CALL_OW 1
55408: ST_TO_ADDR
// end ;
55409: GO 55329
55411: POP
55412: POP
// RaiseSailEvent ( 101 ) ;
55413: LD_INT 101
55415: PPUSH
55416: CALL_OW 427
// end ;
55420: LD_VAR 0 1
55424: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55425: LD_INT 0
55427: PPUSH
55428: PPUSH
55429: PPUSH
55430: PPUSH
55431: PPUSH
55432: PPUSH
55433: PPUSH
// if not mc_bases then
55434: LD_EXP 43
55438: NOT
55439: IFFALSE 55443
// exit ;
55441: GO 56005
// for i = 1 to mc_bases do
55443: LD_ADDR_VAR 0 2
55447: PUSH
55448: DOUBLE
55449: LD_INT 1
55451: DEC
55452: ST_TO_ADDR
55453: LD_EXP 43
55457: PUSH
55458: FOR_TO
55459: IFFALSE 55996
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
55461: LD_ADDR_VAR 0 5
55465: PUSH
55466: LD_EXP 43
55470: PUSH
55471: LD_VAR 0 2
55475: ARRAY
55476: PUSH
55477: LD_EXP 72
55481: PUSH
55482: LD_VAR 0 2
55486: ARRAY
55487: UNION
55488: PPUSH
55489: LD_INT 21
55491: PUSH
55492: LD_INT 1
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: LD_INT 1
55501: PUSH
55502: LD_INT 3
55504: PUSH
55505: LD_INT 54
55507: PUSH
55508: EMPTY
55509: LIST
55510: PUSH
55511: EMPTY
55512: LIST
55513: LIST
55514: PUSH
55515: LD_INT 3
55517: PUSH
55518: LD_INT 24
55520: PUSH
55521: LD_INT 800
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: LIST
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: PPUSH
55541: CALL_OW 72
55545: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55546: LD_ADDR_VAR 0 6
55550: PUSH
55551: LD_EXP 43
55555: PUSH
55556: LD_VAR 0 2
55560: ARRAY
55561: PPUSH
55562: LD_INT 21
55564: PUSH
55565: LD_INT 1
55567: PUSH
55568: EMPTY
55569: LIST
55570: LIST
55571: PUSH
55572: LD_INT 1
55574: PUSH
55575: LD_INT 3
55577: PUSH
55578: LD_INT 54
55580: PUSH
55581: EMPTY
55582: LIST
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: PUSH
55588: LD_INT 3
55590: PUSH
55591: LD_INT 24
55593: PUSH
55594: LD_INT 250
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: PUSH
55601: EMPTY
55602: LIST
55603: LIST
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: PPUSH
55614: CALL_OW 72
55618: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55619: LD_ADDR_VAR 0 7
55623: PUSH
55624: LD_VAR 0 5
55628: PUSH
55629: LD_VAR 0 6
55633: DIFF
55634: ST_TO_ADDR
// if not need_heal_1 then
55635: LD_VAR 0 6
55639: NOT
55640: IFFALSE 55673
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55642: LD_ADDR_EXP 46
55646: PUSH
55647: LD_EXP 46
55651: PPUSH
55652: LD_VAR 0 2
55656: PUSH
55657: LD_INT 1
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: PPUSH
55664: EMPTY
55665: PPUSH
55666: CALL 14797 0 3
55670: ST_TO_ADDR
55671: GO 55743
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55673: LD_ADDR_EXP 46
55677: PUSH
55678: LD_EXP 46
55682: PPUSH
55683: LD_VAR 0 2
55687: PUSH
55688: LD_INT 1
55690: PUSH
55691: EMPTY
55692: LIST
55693: LIST
55694: PPUSH
55695: LD_EXP 46
55699: PUSH
55700: LD_VAR 0 2
55704: ARRAY
55705: PUSH
55706: LD_INT 1
55708: ARRAY
55709: PPUSH
55710: LD_INT 3
55712: PUSH
55713: LD_INT 24
55715: PUSH
55716: LD_INT 1000
55718: PUSH
55719: EMPTY
55720: LIST
55721: LIST
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: PPUSH
55727: CALL_OW 72
55731: PUSH
55732: LD_VAR 0 6
55736: UNION
55737: PPUSH
55738: CALL 14797 0 3
55742: ST_TO_ADDR
// if not need_heal_2 then
55743: LD_VAR 0 7
55747: NOT
55748: IFFALSE 55781
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55750: LD_ADDR_EXP 46
55754: PUSH
55755: LD_EXP 46
55759: PPUSH
55760: LD_VAR 0 2
55764: PUSH
55765: LD_INT 2
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: PPUSH
55772: EMPTY
55773: PPUSH
55774: CALL 14797 0 3
55778: ST_TO_ADDR
55779: GO 55813
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55781: LD_ADDR_EXP 46
55785: PUSH
55786: LD_EXP 46
55790: PPUSH
55791: LD_VAR 0 2
55795: PUSH
55796: LD_INT 2
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PPUSH
55803: LD_VAR 0 7
55807: PPUSH
55808: CALL 14797 0 3
55812: ST_TO_ADDR
// if need_heal_2 then
55813: LD_VAR 0 7
55817: IFFALSE 55978
// for j in need_heal_2 do
55819: LD_ADDR_VAR 0 3
55823: PUSH
55824: LD_VAR 0 7
55828: PUSH
55829: FOR_IN
55830: IFFALSE 55976
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55832: LD_ADDR_VAR 0 5
55836: PUSH
55837: LD_EXP 43
55841: PUSH
55842: LD_VAR 0 2
55846: ARRAY
55847: PPUSH
55848: LD_INT 2
55850: PUSH
55851: LD_INT 30
55853: PUSH
55854: LD_INT 6
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: PUSH
55861: LD_INT 30
55863: PUSH
55864: LD_INT 7
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: PUSH
55871: LD_INT 30
55873: PUSH
55874: LD_INT 8
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: PUSH
55881: LD_INT 30
55883: PUSH
55884: LD_INT 0
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: PUSH
55891: LD_INT 30
55893: PUSH
55894: LD_INT 1
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: PUSH
55901: EMPTY
55902: LIST
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: LIST
55908: PPUSH
55909: CALL_OW 72
55913: ST_TO_ADDR
// if tmp then
55914: LD_VAR 0 5
55918: IFFALSE 55974
// begin k := NearestUnitToUnit ( tmp , j ) ;
55920: LD_ADDR_VAR 0 4
55924: PUSH
55925: LD_VAR 0 5
55929: PPUSH
55930: LD_VAR 0 3
55934: PPUSH
55935: CALL_OW 74
55939: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
55940: LD_VAR 0 3
55944: PPUSH
55945: LD_VAR 0 4
55949: PPUSH
55950: CALL_OW 296
55954: PUSH
55955: LD_INT 5
55957: GREATER
55958: IFFALSE 55974
// ComMoveToNearbyEntrance ( j , k ) ;
55960: LD_VAR 0 3
55964: PPUSH
55965: LD_VAR 0 4
55969: PPUSH
55970: CALL 46663 0 2
// end ; end ;
55974: GO 55829
55976: POP
55977: POP
// if not need_heal_1 and not need_heal_2 then
55978: LD_VAR 0 6
55982: NOT
55983: PUSH
55984: LD_VAR 0 7
55988: NOT
55989: AND
55990: IFFALSE 55994
// continue ;
55992: GO 55458
// end ;
55994: GO 55458
55996: POP
55997: POP
// RaiseSailEvent ( 102 ) ;
55998: LD_INT 102
56000: PPUSH
56001: CALL_OW 427
// end ;
56005: LD_VAR 0 1
56009: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56010: LD_INT 0
56012: PPUSH
56013: PPUSH
56014: PPUSH
56015: PPUSH
56016: PPUSH
56017: PPUSH
56018: PPUSH
56019: PPUSH
// if not mc_bases then
56020: LD_EXP 43
56024: NOT
56025: IFFALSE 56029
// exit ;
56027: GO 56890
// for i = 1 to mc_bases do
56029: LD_ADDR_VAR 0 2
56033: PUSH
56034: DOUBLE
56035: LD_INT 1
56037: DEC
56038: ST_TO_ADDR
56039: LD_EXP 43
56043: PUSH
56044: FOR_TO
56045: IFFALSE 56888
// begin if not mc_building_need_repair [ i ] then
56047: LD_EXP 44
56051: PUSH
56052: LD_VAR 0 2
56056: ARRAY
56057: NOT
56058: IFFALSE 56245
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56060: LD_ADDR_VAR 0 6
56064: PUSH
56065: LD_EXP 62
56069: PUSH
56070: LD_VAR 0 2
56074: ARRAY
56075: PPUSH
56076: LD_INT 3
56078: PUSH
56079: LD_INT 24
56081: PUSH
56082: LD_INT 1000
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PUSH
56093: LD_INT 2
56095: PUSH
56096: LD_INT 34
56098: PUSH
56099: LD_INT 13
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: LD_INT 34
56108: PUSH
56109: LD_INT 52
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: PUSH
56116: LD_INT 34
56118: PUSH
56119: LD_EXP 92
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: LIST
56132: LIST
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PPUSH
56138: CALL_OW 72
56142: ST_TO_ADDR
// if cranes then
56143: LD_VAR 0 6
56147: IFFALSE 56209
// for j in cranes do
56149: LD_ADDR_VAR 0 3
56153: PUSH
56154: LD_VAR 0 6
56158: PUSH
56159: FOR_IN
56160: IFFALSE 56207
// if not IsInArea ( j , mc_parking [ i ] ) then
56162: LD_VAR 0 3
56166: PPUSH
56167: LD_EXP 67
56171: PUSH
56172: LD_VAR 0 2
56176: ARRAY
56177: PPUSH
56178: CALL_OW 308
56182: NOT
56183: IFFALSE 56205
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56185: LD_VAR 0 3
56189: PPUSH
56190: LD_EXP 67
56194: PUSH
56195: LD_VAR 0 2
56199: ARRAY
56200: PPUSH
56201: CALL_OW 113
56205: GO 56159
56207: POP
56208: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56209: LD_ADDR_EXP 45
56213: PUSH
56214: LD_EXP 45
56218: PPUSH
56219: LD_VAR 0 2
56223: PPUSH
56224: EMPTY
56225: PPUSH
56226: CALL_OW 1
56230: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56231: LD_VAR 0 2
56235: PPUSH
56236: LD_INT 101
56238: PPUSH
56239: CALL 51133 0 2
// continue ;
56243: GO 56044
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56245: LD_ADDR_EXP 49
56249: PUSH
56250: LD_EXP 49
56254: PPUSH
56255: LD_VAR 0 2
56259: PPUSH
56260: EMPTY
56261: PPUSH
56262: CALL_OW 1
56266: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56267: LD_VAR 0 2
56271: PPUSH
56272: LD_INT 103
56274: PPUSH
56275: CALL 51133 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56279: LD_ADDR_VAR 0 5
56283: PUSH
56284: LD_EXP 43
56288: PUSH
56289: LD_VAR 0 2
56293: ARRAY
56294: PUSH
56295: LD_EXP 72
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: UNION
56306: PPUSH
56307: LD_INT 2
56309: PUSH
56310: LD_INT 25
56312: PUSH
56313: LD_INT 2
56315: PUSH
56316: EMPTY
56317: LIST
56318: LIST
56319: PUSH
56320: LD_INT 25
56322: PUSH
56323: LD_INT 16
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PUSH
56330: EMPTY
56331: LIST
56332: LIST
56333: LIST
56334: PUSH
56335: EMPTY
56336: LIST
56337: PPUSH
56338: CALL_OW 72
56342: PUSH
56343: LD_EXP 46
56347: PUSH
56348: LD_VAR 0 2
56352: ARRAY
56353: PUSH
56354: LD_INT 1
56356: ARRAY
56357: PUSH
56358: LD_EXP 46
56362: PUSH
56363: LD_VAR 0 2
56367: ARRAY
56368: PUSH
56369: LD_INT 2
56371: ARRAY
56372: UNION
56373: DIFF
56374: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56375: LD_ADDR_VAR 0 6
56379: PUSH
56380: LD_EXP 62
56384: PUSH
56385: LD_VAR 0 2
56389: ARRAY
56390: PPUSH
56391: LD_INT 2
56393: PUSH
56394: LD_INT 34
56396: PUSH
56397: LD_INT 13
56399: PUSH
56400: EMPTY
56401: LIST
56402: LIST
56403: PUSH
56404: LD_INT 34
56406: PUSH
56407: LD_INT 52
56409: PUSH
56410: EMPTY
56411: LIST
56412: LIST
56413: PUSH
56414: LD_INT 34
56416: PUSH
56417: LD_EXP 92
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: LIST
56430: LIST
56431: PPUSH
56432: CALL_OW 72
56436: ST_TO_ADDR
// if cranes then
56437: LD_VAR 0 6
56441: IFFALSE 56577
// begin for j in cranes do
56443: LD_ADDR_VAR 0 3
56447: PUSH
56448: LD_VAR 0 6
56452: PUSH
56453: FOR_IN
56454: IFFALSE 56575
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56456: LD_VAR 0 3
56460: PPUSH
56461: CALL_OW 256
56465: PUSH
56466: LD_INT 1000
56468: EQUAL
56469: PUSH
56470: LD_VAR 0 3
56474: PPUSH
56475: CALL_OW 314
56479: NOT
56480: AND
56481: IFFALSE 56515
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56483: LD_VAR 0 3
56487: PPUSH
56488: LD_EXP 44
56492: PUSH
56493: LD_VAR 0 2
56497: ARRAY
56498: PPUSH
56499: LD_VAR 0 3
56503: PPUSH
56504: CALL_OW 74
56508: PPUSH
56509: CALL_OW 130
56513: GO 56573
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56515: LD_VAR 0 3
56519: PPUSH
56520: CALL_OW 256
56524: PUSH
56525: LD_INT 500
56527: LESS
56528: PUSH
56529: LD_VAR 0 3
56533: PPUSH
56534: LD_EXP 67
56538: PUSH
56539: LD_VAR 0 2
56543: ARRAY
56544: PPUSH
56545: CALL_OW 308
56549: NOT
56550: AND
56551: IFFALSE 56573
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56553: LD_VAR 0 3
56557: PPUSH
56558: LD_EXP 67
56562: PUSH
56563: LD_VAR 0 2
56567: ARRAY
56568: PPUSH
56569: CALL_OW 113
// end ;
56573: GO 56453
56575: POP
56576: POP
// end ; if tmp > 3 then
56577: LD_VAR 0 5
56581: PUSH
56582: LD_INT 3
56584: GREATER
56585: IFFALSE 56605
// tmp := ShrinkArray ( tmp , 4 ) ;
56587: LD_ADDR_VAR 0 5
56591: PUSH
56592: LD_VAR 0 5
56596: PPUSH
56597: LD_INT 4
56599: PPUSH
56600: CALL 46155 0 2
56604: ST_TO_ADDR
// if not tmp then
56605: LD_VAR 0 5
56609: NOT
56610: IFFALSE 56614
// continue ;
56612: GO 56044
// for j in tmp do
56614: LD_ADDR_VAR 0 3
56618: PUSH
56619: LD_VAR 0 5
56623: PUSH
56624: FOR_IN
56625: IFFALSE 56884
// begin if IsInUnit ( j ) then
56627: LD_VAR 0 3
56631: PPUSH
56632: CALL_OW 310
56636: IFFALSE 56647
// ComExitBuilding ( j ) ;
56638: LD_VAR 0 3
56642: PPUSH
56643: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56647: LD_VAR 0 3
56651: PUSH
56652: LD_EXP 45
56656: PUSH
56657: LD_VAR 0 2
56661: ARRAY
56662: IN
56663: NOT
56664: IFFALSE 56722
// begin SetTag ( j , 101 ) ;
56666: LD_VAR 0 3
56670: PPUSH
56671: LD_INT 101
56673: PPUSH
56674: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56678: LD_ADDR_EXP 45
56682: PUSH
56683: LD_EXP 45
56687: PPUSH
56688: LD_VAR 0 2
56692: PUSH
56693: LD_EXP 45
56697: PUSH
56698: LD_VAR 0 2
56702: ARRAY
56703: PUSH
56704: LD_INT 1
56706: PLUS
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PPUSH
56712: LD_VAR 0 3
56716: PPUSH
56717: CALL 14797 0 3
56721: ST_TO_ADDR
// end ; wait ( 1 ) ;
56722: LD_INT 1
56724: PPUSH
56725: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56729: LD_ADDR_VAR 0 7
56733: PUSH
56734: LD_EXP 44
56738: PUSH
56739: LD_VAR 0 2
56743: ARRAY
56744: ST_TO_ADDR
// if mc_scan [ i ] then
56745: LD_EXP 66
56749: PUSH
56750: LD_VAR 0 2
56754: ARRAY
56755: IFFALSE 56817
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56757: LD_ADDR_VAR 0 7
56761: PUSH
56762: LD_EXP 44
56766: PUSH
56767: LD_VAR 0 2
56771: ARRAY
56772: PPUSH
56773: LD_INT 3
56775: PUSH
56776: LD_INT 30
56778: PUSH
56779: LD_INT 32
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: PUSH
56786: LD_INT 30
56788: PUSH
56789: LD_INT 33
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: PUSH
56796: LD_INT 30
56798: PUSH
56799: LD_INT 31
56801: PUSH
56802: EMPTY
56803: LIST
56804: LIST
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: PPUSH
56812: CALL_OW 72
56816: ST_TO_ADDR
// if not to_repair_tmp then
56817: LD_VAR 0 7
56821: NOT
56822: IFFALSE 56826
// continue ;
56824: GO 56624
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56826: LD_ADDR_VAR 0 8
56830: PUSH
56831: LD_VAR 0 7
56835: PPUSH
56836: LD_VAR 0 3
56840: PPUSH
56841: CALL_OW 74
56845: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56846: LD_VAR 0 8
56850: PPUSH
56851: LD_INT 16
56853: PPUSH
56854: CALL 17390 0 2
56858: PUSH
56859: LD_INT 4
56861: ARRAY
56862: PUSH
56863: LD_INT 10
56865: LESS
56866: IFFALSE 56882
// ComRepairBuilding ( j , to_repair ) ;
56868: LD_VAR 0 3
56872: PPUSH
56873: LD_VAR 0 8
56877: PPUSH
56878: CALL_OW 130
// end ;
56882: GO 56624
56884: POP
56885: POP
// end ;
56886: GO 56044
56888: POP
56889: POP
// end ;
56890: LD_VAR 0 1
56894: RET
// export function MC_Heal ; var i , j , tmp ; begin
56895: LD_INT 0
56897: PPUSH
56898: PPUSH
56899: PPUSH
56900: PPUSH
// if not mc_bases then
56901: LD_EXP 43
56905: NOT
56906: IFFALSE 56910
// exit ;
56908: GO 57312
// for i = 1 to mc_bases do
56910: LD_ADDR_VAR 0 2
56914: PUSH
56915: DOUBLE
56916: LD_INT 1
56918: DEC
56919: ST_TO_ADDR
56920: LD_EXP 43
56924: PUSH
56925: FOR_TO
56926: IFFALSE 57310
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
56928: LD_EXP 46
56932: PUSH
56933: LD_VAR 0 2
56937: ARRAY
56938: PUSH
56939: LD_INT 1
56941: ARRAY
56942: NOT
56943: PUSH
56944: LD_EXP 46
56948: PUSH
56949: LD_VAR 0 2
56953: ARRAY
56954: PUSH
56955: LD_INT 2
56957: ARRAY
56958: NOT
56959: AND
56960: IFFALSE 56998
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
56962: LD_ADDR_EXP 47
56966: PUSH
56967: LD_EXP 47
56971: PPUSH
56972: LD_VAR 0 2
56976: PPUSH
56977: EMPTY
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
56984: LD_VAR 0 2
56988: PPUSH
56989: LD_INT 102
56991: PPUSH
56992: CALL 51133 0 2
// continue ;
56996: GO 56925
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56998: LD_ADDR_VAR 0 4
57002: PUSH
57003: LD_EXP 43
57007: PUSH
57008: LD_VAR 0 2
57012: ARRAY
57013: PPUSH
57014: LD_INT 25
57016: PUSH
57017: LD_INT 4
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: PPUSH
57024: CALL_OW 72
57028: ST_TO_ADDR
// if not tmp then
57029: LD_VAR 0 4
57033: NOT
57034: IFFALSE 57038
// continue ;
57036: GO 56925
// if mc_taming [ i ] then
57038: LD_EXP 74
57042: PUSH
57043: LD_VAR 0 2
57047: ARRAY
57048: IFFALSE 57072
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57050: LD_ADDR_EXP 74
57054: PUSH
57055: LD_EXP 74
57059: PPUSH
57060: LD_VAR 0 2
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// for j in tmp do
57072: LD_ADDR_VAR 0 3
57076: PUSH
57077: LD_VAR 0 4
57081: PUSH
57082: FOR_IN
57083: IFFALSE 57306
// begin if IsInUnit ( j ) then
57085: LD_VAR 0 3
57089: PPUSH
57090: CALL_OW 310
57094: IFFALSE 57105
// ComExitBuilding ( j ) ;
57096: LD_VAR 0 3
57100: PPUSH
57101: CALL_OW 122
// if not j in mc_healers [ i ] then
57105: LD_VAR 0 3
57109: PUSH
57110: LD_EXP 47
57114: PUSH
57115: LD_VAR 0 2
57119: ARRAY
57120: IN
57121: NOT
57122: IFFALSE 57168
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57124: LD_ADDR_EXP 47
57128: PUSH
57129: LD_EXP 47
57133: PPUSH
57134: LD_VAR 0 2
57138: PUSH
57139: LD_EXP 47
57143: PUSH
57144: LD_VAR 0 2
57148: ARRAY
57149: PUSH
57150: LD_INT 1
57152: PLUS
57153: PUSH
57154: EMPTY
57155: LIST
57156: LIST
57157: PPUSH
57158: LD_VAR 0 3
57162: PPUSH
57163: CALL 14797 0 3
57167: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57168: LD_VAR 0 3
57172: PPUSH
57173: CALL_OW 110
57177: PUSH
57178: LD_INT 102
57180: NONEQUAL
57181: IFFALSE 57195
// SetTag ( j , 102 ) ;
57183: LD_VAR 0 3
57187: PPUSH
57188: LD_INT 102
57190: PPUSH
57191: CALL_OW 109
// Wait ( 3 ) ;
57195: LD_INT 3
57197: PPUSH
57198: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57202: LD_EXP 46
57206: PUSH
57207: LD_VAR 0 2
57211: ARRAY
57212: PUSH
57213: LD_INT 1
57215: ARRAY
57216: IFFALSE 57248
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57218: LD_VAR 0 3
57222: PPUSH
57223: LD_EXP 46
57227: PUSH
57228: LD_VAR 0 2
57232: ARRAY
57233: PUSH
57234: LD_INT 1
57236: ARRAY
57237: PUSH
57238: LD_INT 1
57240: ARRAY
57241: PPUSH
57242: CALL_OW 128
57246: GO 57304
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57248: LD_VAR 0 3
57252: PPUSH
57253: CALL_OW 314
57257: NOT
57258: PUSH
57259: LD_EXP 46
57263: PUSH
57264: LD_VAR 0 2
57268: ARRAY
57269: PUSH
57270: LD_INT 2
57272: ARRAY
57273: AND
57274: IFFALSE 57304
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57276: LD_VAR 0 3
57280: PPUSH
57281: LD_EXP 46
57285: PUSH
57286: LD_VAR 0 2
57290: ARRAY
57291: PUSH
57292: LD_INT 2
57294: ARRAY
57295: PUSH
57296: LD_INT 1
57298: ARRAY
57299: PPUSH
57300: CALL_OW 128
// end ;
57304: GO 57082
57306: POP
57307: POP
// end ;
57308: GO 56925
57310: POP
57311: POP
// end ;
57312: LD_VAR 0 1
57316: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57317: LD_INT 0
57319: PPUSH
57320: PPUSH
57321: PPUSH
57322: PPUSH
57323: PPUSH
// if not mc_bases then
57324: LD_EXP 43
57328: NOT
57329: IFFALSE 57333
// exit ;
57331: GO 58476
// for i = 1 to mc_bases do
57333: LD_ADDR_VAR 0 2
57337: PUSH
57338: DOUBLE
57339: LD_INT 1
57341: DEC
57342: ST_TO_ADDR
57343: LD_EXP 43
57347: PUSH
57348: FOR_TO
57349: IFFALSE 58474
// begin if mc_scan [ i ] then
57351: LD_EXP 66
57355: PUSH
57356: LD_VAR 0 2
57360: ARRAY
57361: IFFALSE 57365
// continue ;
57363: GO 57348
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57365: LD_EXP 48
57369: PUSH
57370: LD_VAR 0 2
57374: ARRAY
57375: NOT
57376: PUSH
57377: LD_EXP 50
57381: PUSH
57382: LD_VAR 0 2
57386: ARRAY
57387: NOT
57388: AND
57389: PUSH
57390: LD_EXP 49
57394: PUSH
57395: LD_VAR 0 2
57399: ARRAY
57400: AND
57401: IFFALSE 57439
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57403: LD_ADDR_EXP 49
57407: PUSH
57408: LD_EXP 49
57412: PPUSH
57413: LD_VAR 0 2
57417: PPUSH
57418: EMPTY
57419: PPUSH
57420: CALL_OW 1
57424: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57425: LD_VAR 0 2
57429: PPUSH
57430: LD_INT 103
57432: PPUSH
57433: CALL 51133 0 2
// continue ;
57437: GO 57348
// end ; if mc_construct_list [ i ] then
57439: LD_EXP 50
57443: PUSH
57444: LD_VAR 0 2
57448: ARRAY
57449: IFFALSE 57669
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57451: LD_ADDR_VAR 0 4
57455: PUSH
57456: LD_EXP 43
57460: PUSH
57461: LD_VAR 0 2
57465: ARRAY
57466: PPUSH
57467: LD_INT 25
57469: PUSH
57470: LD_INT 2
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: PPUSH
57477: CALL_OW 72
57481: PUSH
57482: LD_EXP 45
57486: PUSH
57487: LD_VAR 0 2
57491: ARRAY
57492: DIFF
57493: ST_TO_ADDR
// if not tmp then
57494: LD_VAR 0 4
57498: NOT
57499: IFFALSE 57503
// continue ;
57501: GO 57348
// for j in tmp do
57503: LD_ADDR_VAR 0 3
57507: PUSH
57508: LD_VAR 0 4
57512: PUSH
57513: FOR_IN
57514: IFFALSE 57665
// begin if not mc_builders [ i ] then
57516: LD_EXP 49
57520: PUSH
57521: LD_VAR 0 2
57525: ARRAY
57526: NOT
57527: IFFALSE 57585
// begin SetTag ( j , 103 ) ;
57529: LD_VAR 0 3
57533: PPUSH
57534: LD_INT 103
57536: PPUSH
57537: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57541: LD_ADDR_EXP 49
57545: PUSH
57546: LD_EXP 49
57550: PPUSH
57551: LD_VAR 0 2
57555: PUSH
57556: LD_EXP 49
57560: PUSH
57561: LD_VAR 0 2
57565: ARRAY
57566: PUSH
57567: LD_INT 1
57569: PLUS
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PPUSH
57575: LD_VAR 0 3
57579: PPUSH
57580: CALL 14797 0 3
57584: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57585: LD_VAR 0 3
57589: PPUSH
57590: CALL_OW 310
57594: IFFALSE 57605
// ComExitBuilding ( j ) ;
57596: LD_VAR 0 3
57600: PPUSH
57601: CALL_OW 122
// wait ( 3 ) ;
57605: LD_INT 3
57607: PPUSH
57608: CALL_OW 67
// if not mc_construct_list [ i ] then
57612: LD_EXP 50
57616: PUSH
57617: LD_VAR 0 2
57621: ARRAY
57622: NOT
57623: IFFALSE 57627
// break ;
57625: GO 57665
// if not HasTask ( j ) then
57627: LD_VAR 0 3
57631: PPUSH
57632: CALL_OW 314
57636: NOT
57637: IFFALSE 57663
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57639: LD_VAR 0 3
57643: PPUSH
57644: LD_EXP 50
57648: PUSH
57649: LD_VAR 0 2
57653: ARRAY
57654: PUSH
57655: LD_INT 1
57657: ARRAY
57658: PPUSH
57659: CALL 17648 0 2
// end ;
57663: GO 57513
57665: POP
57666: POP
// end else
57667: GO 58472
// if mc_build_list [ i ] then
57669: LD_EXP 48
57673: PUSH
57674: LD_VAR 0 2
57678: ARRAY
57679: IFFALSE 58472
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57681: LD_ADDR_VAR 0 5
57685: PUSH
57686: LD_EXP 43
57690: PUSH
57691: LD_VAR 0 2
57695: ARRAY
57696: PPUSH
57697: LD_INT 2
57699: PUSH
57700: LD_INT 30
57702: PUSH
57703: LD_INT 0
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PUSH
57710: LD_INT 30
57712: PUSH
57713: LD_INT 1
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: LIST
57724: PPUSH
57725: CALL_OW 72
57729: ST_TO_ADDR
// if depot then
57730: LD_VAR 0 5
57734: IFFALSE 57752
// depot := depot [ 1 ] else
57736: LD_ADDR_VAR 0 5
57740: PUSH
57741: LD_VAR 0 5
57745: PUSH
57746: LD_INT 1
57748: ARRAY
57749: ST_TO_ADDR
57750: GO 57760
// depot := 0 ;
57752: LD_ADDR_VAR 0 5
57756: PUSH
57757: LD_INT 0
57759: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57760: LD_EXP 48
57764: PUSH
57765: LD_VAR 0 2
57769: ARRAY
57770: PUSH
57771: LD_INT 1
57773: ARRAY
57774: PUSH
57775: LD_INT 1
57777: ARRAY
57778: PPUSH
57779: CALL 17478 0 1
57783: PUSH
57784: LD_EXP 43
57788: PUSH
57789: LD_VAR 0 2
57793: ARRAY
57794: PPUSH
57795: LD_INT 2
57797: PUSH
57798: LD_INT 30
57800: PUSH
57801: LD_INT 2
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: LD_INT 30
57810: PUSH
57811: LD_INT 3
57813: PUSH
57814: EMPTY
57815: LIST
57816: LIST
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: LIST
57822: PPUSH
57823: CALL_OW 72
57827: NOT
57828: AND
57829: IFFALSE 57934
// begin for j = 1 to mc_build_list [ i ] do
57831: LD_ADDR_VAR 0 3
57835: PUSH
57836: DOUBLE
57837: LD_INT 1
57839: DEC
57840: ST_TO_ADDR
57841: LD_EXP 48
57845: PUSH
57846: LD_VAR 0 2
57850: ARRAY
57851: PUSH
57852: FOR_TO
57853: IFFALSE 57932
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57855: LD_EXP 48
57859: PUSH
57860: LD_VAR 0 2
57864: ARRAY
57865: PUSH
57866: LD_VAR 0 3
57870: ARRAY
57871: PUSH
57872: LD_INT 1
57874: ARRAY
57875: PUSH
57876: LD_INT 2
57878: EQUAL
57879: IFFALSE 57930
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
57881: LD_ADDR_EXP 48
57885: PUSH
57886: LD_EXP 48
57890: PPUSH
57891: LD_VAR 0 2
57895: PPUSH
57896: LD_EXP 48
57900: PUSH
57901: LD_VAR 0 2
57905: ARRAY
57906: PPUSH
57907: LD_VAR 0 3
57911: PPUSH
57912: LD_INT 1
57914: PPUSH
57915: LD_INT 0
57917: PPUSH
57918: CALL 14215 0 4
57922: PPUSH
57923: CALL_OW 1
57927: ST_TO_ADDR
// break ;
57928: GO 57932
// end ;
57930: GO 57852
57932: POP
57933: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
57934: LD_EXP 48
57938: PUSH
57939: LD_VAR 0 2
57943: ARRAY
57944: PUSH
57945: LD_INT 1
57947: ARRAY
57948: PUSH
57949: LD_INT 1
57951: ARRAY
57952: PUSH
57953: LD_INT 0
57955: EQUAL
57956: PUSH
57957: LD_VAR 0 5
57961: PUSH
57962: LD_VAR 0 5
57966: PPUSH
57967: LD_EXP 48
57971: PUSH
57972: LD_VAR 0 2
57976: ARRAY
57977: PUSH
57978: LD_INT 1
57980: ARRAY
57981: PUSH
57982: LD_INT 1
57984: ARRAY
57985: PPUSH
57986: LD_EXP 48
57990: PUSH
57991: LD_VAR 0 2
57995: ARRAY
57996: PUSH
57997: LD_INT 1
57999: ARRAY
58000: PUSH
58001: LD_INT 2
58003: ARRAY
58004: PPUSH
58005: LD_EXP 48
58009: PUSH
58010: LD_VAR 0 2
58014: ARRAY
58015: PUSH
58016: LD_INT 1
58018: ARRAY
58019: PUSH
58020: LD_INT 3
58022: ARRAY
58023: PPUSH
58024: LD_EXP 48
58028: PUSH
58029: LD_VAR 0 2
58033: ARRAY
58034: PUSH
58035: LD_INT 1
58037: ARRAY
58038: PUSH
58039: LD_INT 4
58041: ARRAY
58042: PPUSH
58043: CALL 22212 0 5
58047: AND
58048: OR
58049: IFFALSE 58330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58051: LD_ADDR_VAR 0 4
58055: PUSH
58056: LD_EXP 43
58060: PUSH
58061: LD_VAR 0 2
58065: ARRAY
58066: PPUSH
58067: LD_INT 25
58069: PUSH
58070: LD_INT 2
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: PPUSH
58077: CALL_OW 72
58081: PUSH
58082: LD_EXP 45
58086: PUSH
58087: LD_VAR 0 2
58091: ARRAY
58092: DIFF
58093: ST_TO_ADDR
// if not tmp then
58094: LD_VAR 0 4
58098: NOT
58099: IFFALSE 58103
// continue ;
58101: GO 57348
// for j in tmp do
58103: LD_ADDR_VAR 0 3
58107: PUSH
58108: LD_VAR 0 4
58112: PUSH
58113: FOR_IN
58114: IFFALSE 58326
// begin if not mc_builders [ i ] then
58116: LD_EXP 49
58120: PUSH
58121: LD_VAR 0 2
58125: ARRAY
58126: NOT
58127: IFFALSE 58185
// begin SetTag ( j , 103 ) ;
58129: LD_VAR 0 3
58133: PPUSH
58134: LD_INT 103
58136: PPUSH
58137: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58141: LD_ADDR_EXP 49
58145: PUSH
58146: LD_EXP 49
58150: PPUSH
58151: LD_VAR 0 2
58155: PUSH
58156: LD_EXP 49
58160: PUSH
58161: LD_VAR 0 2
58165: ARRAY
58166: PUSH
58167: LD_INT 1
58169: PLUS
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PPUSH
58175: LD_VAR 0 3
58179: PPUSH
58180: CALL 14797 0 3
58184: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58185: LD_VAR 0 3
58189: PPUSH
58190: CALL_OW 310
58194: IFFALSE 58205
// ComExitBuilding ( j ) ;
58196: LD_VAR 0 3
58200: PPUSH
58201: CALL_OW 122
// wait ( 3 ) ;
58205: LD_INT 3
58207: PPUSH
58208: CALL_OW 67
// if not mc_build_list [ i ] then
58212: LD_EXP 48
58216: PUSH
58217: LD_VAR 0 2
58221: ARRAY
58222: NOT
58223: IFFALSE 58227
// break ;
58225: GO 58326
// if not HasTask ( j ) then
58227: LD_VAR 0 3
58231: PPUSH
58232: CALL_OW 314
58236: NOT
58237: IFFALSE 58324
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58239: LD_VAR 0 3
58243: PPUSH
58244: LD_EXP 48
58248: PUSH
58249: LD_VAR 0 2
58253: ARRAY
58254: PUSH
58255: LD_INT 1
58257: ARRAY
58258: PUSH
58259: LD_INT 1
58261: ARRAY
58262: PPUSH
58263: LD_EXP 48
58267: PUSH
58268: LD_VAR 0 2
58272: ARRAY
58273: PUSH
58274: LD_INT 1
58276: ARRAY
58277: PUSH
58278: LD_INT 2
58280: ARRAY
58281: PPUSH
58282: LD_EXP 48
58286: PUSH
58287: LD_VAR 0 2
58291: ARRAY
58292: PUSH
58293: LD_INT 1
58295: ARRAY
58296: PUSH
58297: LD_INT 3
58299: ARRAY
58300: PPUSH
58301: LD_EXP 48
58305: PUSH
58306: LD_VAR 0 2
58310: ARRAY
58311: PUSH
58312: LD_INT 1
58314: ARRAY
58315: PUSH
58316: LD_INT 4
58318: ARRAY
58319: PPUSH
58320: CALL_OW 145
// end ;
58324: GO 58113
58326: POP
58327: POP
// end else
58328: GO 58472
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
58330: LD_EXP 43
58334: PUSH
58335: LD_VAR 0 2
58339: ARRAY
58340: PPUSH
58341: LD_EXP 48
58345: PUSH
58346: LD_VAR 0 2
58350: ARRAY
58351: PUSH
58352: LD_INT 1
58354: ARRAY
58355: PUSH
58356: LD_INT 1
58358: ARRAY
58359: PPUSH
58360: LD_EXP 48
58364: PUSH
58365: LD_VAR 0 2
58369: ARRAY
58370: PUSH
58371: LD_INT 1
58373: ARRAY
58374: PUSH
58375: LD_INT 2
58377: ARRAY
58378: PPUSH
58379: LD_EXP 48
58383: PUSH
58384: LD_VAR 0 2
58388: ARRAY
58389: PUSH
58390: LD_INT 1
58392: ARRAY
58393: PUSH
58394: LD_INT 3
58396: ARRAY
58397: PPUSH
58398: LD_EXP 48
58402: PUSH
58403: LD_VAR 0 2
58407: ARRAY
58408: PUSH
58409: LD_INT 1
58411: ARRAY
58412: PUSH
58413: LD_INT 4
58415: ARRAY
58416: PPUSH
58417: CALL 21548 0 5
58421: NOT
58422: IFFALSE 58472
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58424: LD_ADDR_EXP 48
58428: PUSH
58429: LD_EXP 48
58433: PPUSH
58434: LD_VAR 0 2
58438: PPUSH
58439: LD_EXP 48
58443: PUSH
58444: LD_VAR 0 2
58448: ARRAY
58449: PPUSH
58450: LD_INT 1
58452: PPUSH
58453: LD_INT 1
58455: NEG
58456: PPUSH
58457: LD_INT 0
58459: PPUSH
58460: CALL 14215 0 4
58464: PPUSH
58465: CALL_OW 1
58469: ST_TO_ADDR
// continue ;
58470: GO 57348
// end ; end ; end ;
58472: GO 57348
58474: POP
58475: POP
// end ;
58476: LD_VAR 0 1
58480: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58481: LD_INT 0
58483: PPUSH
58484: PPUSH
58485: PPUSH
58486: PPUSH
58487: PPUSH
58488: PPUSH
// if not mc_bases then
58489: LD_EXP 43
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58925
// for i = 1 to mc_bases do
58498: LD_ADDR_VAR 0 2
58502: PUSH
58503: DOUBLE
58504: LD_INT 1
58506: DEC
58507: ST_TO_ADDR
58508: LD_EXP 43
58512: PUSH
58513: FOR_TO
58514: IFFALSE 58923
// begin tmp := mc_build_upgrade [ i ] ;
58516: LD_ADDR_VAR 0 4
58520: PUSH
58521: LD_EXP 75
58525: PUSH
58526: LD_VAR 0 2
58530: ARRAY
58531: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58532: LD_ADDR_VAR 0 6
58536: PUSH
58537: LD_EXP 76
58541: PUSH
58542: LD_VAR 0 2
58546: ARRAY
58547: PPUSH
58548: LD_INT 2
58550: PUSH
58551: LD_INT 30
58553: PUSH
58554: LD_INT 6
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: PUSH
58561: LD_INT 30
58563: PUSH
58564: LD_INT 7
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: LIST
58575: PPUSH
58576: CALL_OW 72
58580: ST_TO_ADDR
// if not tmp and not lab then
58581: LD_VAR 0 4
58585: NOT
58586: PUSH
58587: LD_VAR 0 6
58591: NOT
58592: AND
58593: IFFALSE 58597
// continue ;
58595: GO 58513
// if tmp then
58597: LD_VAR 0 4
58601: IFFALSE 58721
// for j in tmp do
58603: LD_ADDR_VAR 0 3
58607: PUSH
58608: LD_VAR 0 4
58612: PUSH
58613: FOR_IN
58614: IFFALSE 58719
// begin if UpgradeCost ( j ) then
58616: LD_VAR 0 3
58620: PPUSH
58621: CALL 21208 0 1
58625: IFFALSE 58717
// begin ComUpgrade ( j ) ;
58627: LD_VAR 0 3
58631: PPUSH
58632: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58636: LD_ADDR_EXP 75
58640: PUSH
58641: LD_EXP 75
58645: PPUSH
58646: LD_VAR 0 2
58650: PPUSH
58651: LD_EXP 75
58655: PUSH
58656: LD_VAR 0 2
58660: ARRAY
58661: PUSH
58662: LD_VAR 0 3
58666: DIFF
58667: PPUSH
58668: CALL_OW 1
58672: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58673: LD_ADDR_EXP 50
58677: PUSH
58678: LD_EXP 50
58682: PPUSH
58683: LD_VAR 0 2
58687: PUSH
58688: LD_EXP 50
58692: PUSH
58693: LD_VAR 0 2
58697: ARRAY
58698: PUSH
58699: LD_INT 1
58701: PLUS
58702: PUSH
58703: EMPTY
58704: LIST
58705: LIST
58706: PPUSH
58707: LD_VAR 0 3
58711: PPUSH
58712: CALL 14797 0 3
58716: ST_TO_ADDR
// end ; end ;
58717: GO 58613
58719: POP
58720: POP
// if not lab or not mc_lab_upgrade [ i ] then
58721: LD_VAR 0 6
58725: NOT
58726: PUSH
58727: LD_EXP 77
58731: PUSH
58732: LD_VAR 0 2
58736: ARRAY
58737: NOT
58738: OR
58739: IFFALSE 58743
// continue ;
58741: GO 58513
// for j in lab do
58743: LD_ADDR_VAR 0 3
58747: PUSH
58748: LD_VAR 0 6
58752: PUSH
58753: FOR_IN
58754: IFFALSE 58919
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58756: LD_VAR 0 3
58760: PPUSH
58761: CALL_OW 266
58765: PUSH
58766: LD_INT 6
58768: PUSH
58769: LD_INT 7
58771: PUSH
58772: EMPTY
58773: LIST
58774: LIST
58775: IN
58776: PUSH
58777: LD_VAR 0 3
58781: PPUSH
58782: CALL_OW 461
58786: PUSH
58787: LD_INT 1
58789: NONEQUAL
58790: AND
58791: IFFALSE 58917
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58793: LD_VAR 0 3
58797: PPUSH
58798: LD_EXP 77
58802: PUSH
58803: LD_VAR 0 2
58807: ARRAY
58808: PUSH
58809: LD_INT 1
58811: ARRAY
58812: PPUSH
58813: CALL 21413 0 2
58817: IFFALSE 58917
// begin ComCancel ( j ) ;
58819: LD_VAR 0 3
58823: PPUSH
58824: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58828: LD_VAR 0 3
58832: PPUSH
58833: LD_EXP 77
58837: PUSH
58838: LD_VAR 0 2
58842: ARRAY
58843: PUSH
58844: LD_INT 1
58846: ARRAY
58847: PPUSH
58848: CALL_OW 207
// if not j in mc_construct_list [ i ] then
58852: LD_VAR 0 3
58856: PUSH
58857: LD_EXP 50
58861: PUSH
58862: LD_VAR 0 2
58866: ARRAY
58867: IN
58868: NOT
58869: IFFALSE 58915
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58871: LD_ADDR_EXP 50
58875: PUSH
58876: LD_EXP 50
58880: PPUSH
58881: LD_VAR 0 2
58885: PUSH
58886: LD_EXP 50
58890: PUSH
58891: LD_VAR 0 2
58895: ARRAY
58896: PUSH
58897: LD_INT 1
58899: PLUS
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: PPUSH
58905: LD_VAR 0 3
58909: PPUSH
58910: CALL 14797 0 3
58914: ST_TO_ADDR
// break ;
58915: GO 58919
// end ; end ; end ;
58917: GO 58753
58919: POP
58920: POP
// end ;
58921: GO 58513
58923: POP
58924: POP
// end ;
58925: LD_VAR 0 1
58929: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
58930: LD_INT 0
58932: PPUSH
58933: PPUSH
58934: PPUSH
58935: PPUSH
58936: PPUSH
58937: PPUSH
58938: PPUSH
58939: PPUSH
58940: PPUSH
// if not mc_bases then
58941: LD_EXP 43
58945: NOT
58946: IFFALSE 58950
// exit ;
58948: GO 59355
// for i = 1 to mc_bases do
58950: LD_ADDR_VAR 0 2
58954: PUSH
58955: DOUBLE
58956: LD_INT 1
58958: DEC
58959: ST_TO_ADDR
58960: LD_EXP 43
58964: PUSH
58965: FOR_TO
58966: IFFALSE 59353
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
58968: LD_EXP 51
58972: PUSH
58973: LD_VAR 0 2
58977: ARRAY
58978: NOT
58979: PUSH
58980: LD_EXP 43
58984: PUSH
58985: LD_VAR 0 2
58989: ARRAY
58990: PPUSH
58991: LD_INT 30
58993: PUSH
58994: LD_INT 3
58996: PUSH
58997: EMPTY
58998: LIST
58999: LIST
59000: PPUSH
59001: CALL_OW 72
59005: NOT
59006: OR
59007: IFFALSE 59011
// continue ;
59009: GO 58965
// busy := false ;
59011: LD_ADDR_VAR 0 8
59015: PUSH
59016: LD_INT 0
59018: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59019: LD_ADDR_VAR 0 4
59023: PUSH
59024: LD_EXP 43
59028: PUSH
59029: LD_VAR 0 2
59033: ARRAY
59034: PPUSH
59035: LD_INT 30
59037: PUSH
59038: LD_INT 3
59040: PUSH
59041: EMPTY
59042: LIST
59043: LIST
59044: PPUSH
59045: CALL_OW 72
59049: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59050: LD_ADDR_VAR 0 6
59054: PUSH
59055: LD_EXP 51
59059: PUSH
59060: LD_VAR 0 2
59064: ARRAY
59065: PPUSH
59066: LD_INT 2
59068: PUSH
59069: LD_INT 30
59071: PUSH
59072: LD_INT 32
59074: PUSH
59075: EMPTY
59076: LIST
59077: LIST
59078: PUSH
59079: LD_INT 30
59081: PUSH
59082: LD_INT 33
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: PUSH
59089: EMPTY
59090: LIST
59091: LIST
59092: LIST
59093: PPUSH
59094: CALL_OW 72
59098: ST_TO_ADDR
// if not t then
59099: LD_VAR 0 6
59103: NOT
59104: IFFALSE 59108
// continue ;
59106: GO 58965
// for j in tmp do
59108: LD_ADDR_VAR 0 3
59112: PUSH
59113: LD_VAR 0 4
59117: PUSH
59118: FOR_IN
59119: IFFALSE 59149
// if not BuildingStatus ( j ) = bs_idle then
59121: LD_VAR 0 3
59125: PPUSH
59126: CALL_OW 461
59130: PUSH
59131: LD_INT 2
59133: EQUAL
59134: NOT
59135: IFFALSE 59147
// begin busy := true ;
59137: LD_ADDR_VAR 0 8
59141: PUSH
59142: LD_INT 1
59144: ST_TO_ADDR
// break ;
59145: GO 59149
// end ;
59147: GO 59118
59149: POP
59150: POP
// if busy then
59151: LD_VAR 0 8
59155: IFFALSE 59159
// continue ;
59157: GO 58965
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59159: LD_ADDR_VAR 0 7
59163: PUSH
59164: LD_VAR 0 6
59168: PPUSH
59169: LD_INT 35
59171: PUSH
59172: LD_INT 0
59174: PUSH
59175: EMPTY
59176: LIST
59177: LIST
59178: PPUSH
59179: CALL_OW 72
59183: ST_TO_ADDR
// if tw then
59184: LD_VAR 0 7
59188: IFFALSE 59265
// begin tw := tw [ 1 ] ;
59190: LD_ADDR_VAR 0 7
59194: PUSH
59195: LD_VAR 0 7
59199: PUSH
59200: LD_INT 1
59202: ARRAY
59203: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59204: LD_ADDR_VAR 0 9
59208: PUSH
59209: LD_VAR 0 7
59213: PPUSH
59214: LD_EXP 68
59218: PUSH
59219: LD_VAR 0 2
59223: ARRAY
59224: PPUSH
59225: CALL 19767 0 2
59229: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59230: LD_EXP 82
59234: PUSH
59235: LD_VAR 0 2
59239: ARRAY
59240: IFFALSE 59263
// if not weapon in mc_allowed_tower_weapons [ i ] then
59242: LD_VAR 0 9
59246: PUSH
59247: LD_EXP 82
59251: PUSH
59252: LD_VAR 0 2
59256: ARRAY
59257: IN
59258: NOT
59259: IFFALSE 59263
// continue ;
59261: GO 58965
// end else
59263: GO 59328
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59265: LD_ADDR_VAR 0 5
59269: PUSH
59270: LD_EXP 51
59274: PUSH
59275: LD_VAR 0 2
59279: ARRAY
59280: PPUSH
59281: LD_VAR 0 4
59285: PPUSH
59286: CALL 45388 0 2
59290: ST_TO_ADDR
// if not tmp2 then
59291: LD_VAR 0 5
59295: NOT
59296: IFFALSE 59300
// continue ;
59298: GO 58965
// tw := tmp2 [ 1 ] ;
59300: LD_ADDR_VAR 0 7
59304: PUSH
59305: LD_VAR 0 5
59309: PUSH
59310: LD_INT 1
59312: ARRAY
59313: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59314: LD_ADDR_VAR 0 9
59318: PUSH
59319: LD_VAR 0 5
59323: PUSH
59324: LD_INT 2
59326: ARRAY
59327: ST_TO_ADDR
// end ; if not weapon then
59328: LD_VAR 0 9
59332: NOT
59333: IFFALSE 59337
// continue ;
59335: GO 58965
// ComPlaceWeapon ( tw , weapon ) ;
59337: LD_VAR 0 7
59341: PPUSH
59342: LD_VAR 0 9
59346: PPUSH
59347: CALL_OW 148
// end ;
59351: GO 58965
59353: POP
59354: POP
// end ;
59355: LD_VAR 0 1
59359: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
59360: LD_INT 0
59362: PPUSH
59363: PPUSH
59364: PPUSH
59365: PPUSH
59366: PPUSH
59367: PPUSH
59368: PPUSH
// if not mc_bases then
59369: LD_EXP 43
59373: NOT
59374: IFFALSE 59378
// exit ;
59376: GO 60146
// for i = 1 to mc_bases do
59378: LD_ADDR_VAR 0 2
59382: PUSH
59383: DOUBLE
59384: LD_INT 1
59386: DEC
59387: ST_TO_ADDR
59388: LD_EXP 43
59392: PUSH
59393: FOR_TO
59394: IFFALSE 60144
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59396: LD_EXP 56
59400: PUSH
59401: LD_VAR 0 2
59405: ARRAY
59406: NOT
59407: PUSH
59408: LD_EXP 56
59412: PUSH
59413: LD_VAR 0 2
59417: ARRAY
59418: PUSH
59419: LD_EXP 57
59423: PUSH
59424: LD_VAR 0 2
59428: ARRAY
59429: EQUAL
59430: OR
59431: PUSH
59432: LD_EXP 66
59436: PUSH
59437: LD_VAR 0 2
59441: ARRAY
59442: OR
59443: IFFALSE 59447
// continue ;
59445: GO 59393
// if mc_miners [ i ] then
59447: LD_EXP 57
59451: PUSH
59452: LD_VAR 0 2
59456: ARRAY
59457: IFFALSE 59831
// begin for j = mc_miners [ i ] downto 1 do
59459: LD_ADDR_VAR 0 3
59463: PUSH
59464: DOUBLE
59465: LD_EXP 57
59469: PUSH
59470: LD_VAR 0 2
59474: ARRAY
59475: INC
59476: ST_TO_ADDR
59477: LD_INT 1
59479: PUSH
59480: FOR_DOWNTO
59481: IFFALSE 59829
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59483: LD_EXP 57
59487: PUSH
59488: LD_VAR 0 2
59492: ARRAY
59493: PUSH
59494: LD_VAR 0 3
59498: ARRAY
59499: PPUSH
59500: CALL_OW 301
59504: PUSH
59505: LD_EXP 57
59509: PUSH
59510: LD_VAR 0 2
59514: ARRAY
59515: PUSH
59516: LD_VAR 0 3
59520: ARRAY
59521: PPUSH
59522: CALL_OW 257
59526: PUSH
59527: LD_INT 1
59529: NONEQUAL
59530: OR
59531: IFFALSE 59594
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59533: LD_ADDR_VAR 0 5
59537: PUSH
59538: LD_EXP 57
59542: PUSH
59543: LD_VAR 0 2
59547: ARRAY
59548: PUSH
59549: LD_EXP 57
59553: PUSH
59554: LD_VAR 0 2
59558: ARRAY
59559: PUSH
59560: LD_VAR 0 3
59564: ARRAY
59565: DIFF
59566: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59567: LD_ADDR_EXP 57
59571: PUSH
59572: LD_EXP 57
59576: PPUSH
59577: LD_VAR 0 2
59581: PPUSH
59582: LD_VAR 0 5
59586: PPUSH
59587: CALL_OW 1
59591: ST_TO_ADDR
// continue ;
59592: GO 59480
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59594: LD_EXP 57
59598: PUSH
59599: LD_VAR 0 2
59603: ARRAY
59604: PUSH
59605: LD_VAR 0 3
59609: ARRAY
59610: PPUSH
59611: CALL_OW 257
59615: PUSH
59616: LD_INT 1
59618: EQUAL
59619: PUSH
59620: LD_EXP 57
59624: PUSH
59625: LD_VAR 0 2
59629: ARRAY
59630: PUSH
59631: LD_VAR 0 3
59635: ARRAY
59636: PPUSH
59637: CALL_OW 459
59641: NOT
59642: AND
59643: PUSH
59644: LD_EXP 57
59648: PUSH
59649: LD_VAR 0 2
59653: ARRAY
59654: PUSH
59655: LD_VAR 0 3
59659: ARRAY
59660: PPUSH
59661: CALL_OW 314
59665: NOT
59666: AND
59667: IFFALSE 59827
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59669: LD_EXP 57
59673: PUSH
59674: LD_VAR 0 2
59678: ARRAY
59679: PUSH
59680: LD_VAR 0 3
59684: ARRAY
59685: PPUSH
59686: CALL_OW 310
59690: IFFALSE 59713
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59692: LD_EXP 57
59696: PUSH
59697: LD_VAR 0 2
59701: ARRAY
59702: PUSH
59703: LD_VAR 0 3
59707: ARRAY
59708: PPUSH
59709: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59713: LD_EXP 57
59717: PUSH
59718: LD_VAR 0 2
59722: ARRAY
59723: PUSH
59724: LD_VAR 0 3
59728: ARRAY
59729: PPUSH
59730: CALL_OW 314
59734: NOT
59735: IFFALSE 59827
// begin r := rand ( 1 , mc_mines [ i ] ) ;
59737: LD_ADDR_VAR 0 7
59741: PUSH
59742: LD_INT 1
59744: PPUSH
59745: LD_EXP 56
59749: PUSH
59750: LD_VAR 0 2
59754: ARRAY
59755: PPUSH
59756: CALL_OW 12
59760: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
59761: LD_EXP 57
59765: PUSH
59766: LD_VAR 0 2
59770: ARRAY
59771: PUSH
59772: LD_VAR 0 3
59776: ARRAY
59777: PPUSH
59778: LD_EXP 56
59782: PUSH
59783: LD_VAR 0 2
59787: ARRAY
59788: PUSH
59789: LD_VAR 0 7
59793: ARRAY
59794: PUSH
59795: LD_INT 1
59797: ARRAY
59798: PPUSH
59799: LD_EXP 56
59803: PUSH
59804: LD_VAR 0 2
59808: ARRAY
59809: PUSH
59810: LD_VAR 0 7
59814: ARRAY
59815: PUSH
59816: LD_INT 2
59818: ARRAY
59819: PPUSH
59820: LD_INT 0
59822: PPUSH
59823: CALL_OW 193
// end ; end ; end ;
59827: GO 59480
59829: POP
59830: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59831: LD_ADDR_VAR 0 5
59835: PUSH
59836: LD_EXP 43
59840: PUSH
59841: LD_VAR 0 2
59845: ARRAY
59846: PPUSH
59847: LD_INT 2
59849: PUSH
59850: LD_INT 30
59852: PUSH
59853: LD_INT 4
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: PUSH
59860: LD_INT 30
59862: PUSH
59863: LD_INT 5
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: PUSH
59870: LD_INT 30
59872: PUSH
59873: LD_INT 32
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: LIST
59884: LIST
59885: PPUSH
59886: CALL_OW 72
59890: ST_TO_ADDR
// if not tmp then
59891: LD_VAR 0 5
59895: NOT
59896: IFFALSE 59900
// continue ;
59898: GO 59393
// list := [ ] ;
59900: LD_ADDR_VAR 0 6
59904: PUSH
59905: EMPTY
59906: ST_TO_ADDR
// for j in tmp do
59907: LD_ADDR_VAR 0 3
59911: PUSH
59912: LD_VAR 0 5
59916: PUSH
59917: FOR_IN
59918: IFFALSE 59987
// begin for k in UnitsInside ( j ) do
59920: LD_ADDR_VAR 0 4
59924: PUSH
59925: LD_VAR 0 3
59929: PPUSH
59930: CALL_OW 313
59934: PUSH
59935: FOR_IN
59936: IFFALSE 59983
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
59938: LD_VAR 0 4
59942: PPUSH
59943: CALL_OW 257
59947: PUSH
59948: LD_INT 1
59950: EQUAL
59951: PUSH
59952: LD_VAR 0 4
59956: PPUSH
59957: CALL_OW 459
59961: NOT
59962: AND
59963: IFFALSE 59981
// list := list ^ k ;
59965: LD_ADDR_VAR 0 6
59969: PUSH
59970: LD_VAR 0 6
59974: PUSH
59975: LD_VAR 0 4
59979: ADD
59980: ST_TO_ADDR
59981: GO 59935
59983: POP
59984: POP
// end ;
59985: GO 59917
59987: POP
59988: POP
// list := list diff mc_miners [ i ] ;
59989: LD_ADDR_VAR 0 6
59993: PUSH
59994: LD_VAR 0 6
59998: PUSH
59999: LD_EXP 57
60003: PUSH
60004: LD_VAR 0 2
60008: ARRAY
60009: DIFF
60010: ST_TO_ADDR
// if not list then
60011: LD_VAR 0 6
60015: NOT
60016: IFFALSE 60020
// continue ;
60018: GO 59393
// k := mc_mines [ i ] - mc_miners [ i ] ;
60020: LD_ADDR_VAR 0 4
60024: PUSH
60025: LD_EXP 56
60029: PUSH
60030: LD_VAR 0 2
60034: ARRAY
60035: PUSH
60036: LD_EXP 57
60040: PUSH
60041: LD_VAR 0 2
60045: ARRAY
60046: MINUS
60047: ST_TO_ADDR
// if k > list then
60048: LD_VAR 0 4
60052: PUSH
60053: LD_VAR 0 6
60057: GREATER
60058: IFFALSE 60070
// k := list ;
60060: LD_ADDR_VAR 0 4
60064: PUSH
60065: LD_VAR 0 6
60069: ST_TO_ADDR
// for j = 1 to k do
60070: LD_ADDR_VAR 0 3
60074: PUSH
60075: DOUBLE
60076: LD_INT 1
60078: DEC
60079: ST_TO_ADDR
60080: LD_VAR 0 4
60084: PUSH
60085: FOR_TO
60086: IFFALSE 60140
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60088: LD_ADDR_EXP 57
60092: PUSH
60093: LD_EXP 57
60097: PPUSH
60098: LD_VAR 0 2
60102: PUSH
60103: LD_EXP 57
60107: PUSH
60108: LD_VAR 0 2
60112: ARRAY
60113: PUSH
60114: LD_INT 1
60116: PLUS
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: PPUSH
60122: LD_VAR 0 6
60126: PUSH
60127: LD_VAR 0 3
60131: ARRAY
60132: PPUSH
60133: CALL 14797 0 3
60137: ST_TO_ADDR
60138: GO 60085
60140: POP
60141: POP
// end ;
60142: GO 59393
60144: POP
60145: POP
// end ;
60146: LD_VAR 0 1
60150: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60151: LD_INT 0
60153: PPUSH
60154: PPUSH
60155: PPUSH
60156: PPUSH
60157: PPUSH
60158: PPUSH
60159: PPUSH
60160: PPUSH
60161: PPUSH
60162: PPUSH
// if not mc_bases then
60163: LD_EXP 43
60167: NOT
60168: IFFALSE 60172
// exit ;
60170: GO 61922
// for i = 1 to mc_bases do
60172: LD_ADDR_VAR 0 2
60176: PUSH
60177: DOUBLE
60178: LD_INT 1
60180: DEC
60181: ST_TO_ADDR
60182: LD_EXP 43
60186: PUSH
60187: FOR_TO
60188: IFFALSE 61920
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60190: LD_EXP 43
60194: PUSH
60195: LD_VAR 0 2
60199: ARRAY
60200: NOT
60201: PUSH
60202: LD_EXP 50
60206: PUSH
60207: LD_VAR 0 2
60211: ARRAY
60212: OR
60213: IFFALSE 60217
// continue ;
60215: GO 60187
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60217: LD_EXP 59
60221: PUSH
60222: LD_VAR 0 2
60226: ARRAY
60227: NOT
60228: PUSH
60229: LD_EXP 60
60233: PUSH
60234: LD_VAR 0 2
60238: ARRAY
60239: AND
60240: IFFALSE 60278
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60242: LD_ADDR_EXP 60
60246: PUSH
60247: LD_EXP 60
60251: PPUSH
60252: LD_VAR 0 2
60256: PPUSH
60257: EMPTY
60258: PPUSH
60259: CALL_OW 1
60263: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60264: LD_VAR 0 2
60268: PPUSH
60269: LD_INT 107
60271: PPUSH
60272: CALL 51133 0 2
// continue ;
60276: GO 60187
// end ; target := [ ] ;
60278: LD_ADDR_VAR 0 6
60282: PUSH
60283: EMPTY
60284: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60285: LD_ADDR_VAR 0 3
60289: PUSH
60290: DOUBLE
60291: LD_EXP 59
60295: PUSH
60296: LD_VAR 0 2
60300: ARRAY
60301: INC
60302: ST_TO_ADDR
60303: LD_INT 1
60305: PUSH
60306: FOR_DOWNTO
60307: IFFALSE 60567
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60309: LD_EXP 59
60313: PUSH
60314: LD_VAR 0 2
60318: ARRAY
60319: PUSH
60320: LD_VAR 0 3
60324: ARRAY
60325: PUSH
60326: LD_INT 2
60328: ARRAY
60329: PPUSH
60330: LD_EXP 59
60334: PUSH
60335: LD_VAR 0 2
60339: ARRAY
60340: PUSH
60341: LD_VAR 0 3
60345: ARRAY
60346: PUSH
60347: LD_INT 3
60349: ARRAY
60350: PPUSH
60351: CALL_OW 488
60355: PUSH
60356: LD_EXP 59
60360: PUSH
60361: LD_VAR 0 2
60365: ARRAY
60366: PUSH
60367: LD_VAR 0 3
60371: ARRAY
60372: PUSH
60373: LD_INT 2
60375: ARRAY
60376: PPUSH
60377: LD_EXP 59
60381: PUSH
60382: LD_VAR 0 2
60386: ARRAY
60387: PUSH
60388: LD_VAR 0 3
60392: ARRAY
60393: PUSH
60394: LD_INT 3
60396: ARRAY
60397: PPUSH
60398: CALL_OW 284
60402: PUSH
60403: LD_INT 0
60405: EQUAL
60406: AND
60407: IFFALSE 60462
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60409: LD_ADDR_VAR 0 5
60413: PUSH
60414: LD_EXP 59
60418: PUSH
60419: LD_VAR 0 2
60423: ARRAY
60424: PPUSH
60425: LD_VAR 0 3
60429: PPUSH
60430: CALL_OW 3
60434: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60435: LD_ADDR_EXP 59
60439: PUSH
60440: LD_EXP 59
60444: PPUSH
60445: LD_VAR 0 2
60449: PPUSH
60450: LD_VAR 0 5
60454: PPUSH
60455: CALL_OW 1
60459: ST_TO_ADDR
// continue ;
60460: GO 60306
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60462: LD_EXP 43
60466: PUSH
60467: LD_VAR 0 2
60471: ARRAY
60472: PUSH
60473: LD_INT 1
60475: ARRAY
60476: PPUSH
60477: CALL_OW 255
60481: PPUSH
60482: LD_EXP 59
60486: PUSH
60487: LD_VAR 0 2
60491: ARRAY
60492: PUSH
60493: LD_VAR 0 3
60497: ARRAY
60498: PUSH
60499: LD_INT 2
60501: ARRAY
60502: PPUSH
60503: LD_EXP 59
60507: PUSH
60508: LD_VAR 0 2
60512: ARRAY
60513: PUSH
60514: LD_VAR 0 3
60518: ARRAY
60519: PUSH
60520: LD_INT 3
60522: ARRAY
60523: PPUSH
60524: LD_INT 30
60526: PPUSH
60527: CALL 15693 0 4
60531: PUSH
60532: LD_INT 4
60534: ARRAY
60535: PUSH
60536: LD_INT 0
60538: EQUAL
60539: IFFALSE 60565
// begin target := mc_crates [ i ] [ j ] ;
60541: LD_ADDR_VAR 0 6
60545: PUSH
60546: LD_EXP 59
60550: PUSH
60551: LD_VAR 0 2
60555: ARRAY
60556: PUSH
60557: LD_VAR 0 3
60561: ARRAY
60562: ST_TO_ADDR
// break ;
60563: GO 60567
// end ; end ;
60565: GO 60306
60567: POP
60568: POP
// if not target then
60569: LD_VAR 0 6
60573: NOT
60574: IFFALSE 60578
// continue ;
60576: GO 60187
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60578: LD_ADDR_VAR 0 7
60582: PUSH
60583: LD_EXP 62
60587: PUSH
60588: LD_VAR 0 2
60592: ARRAY
60593: PPUSH
60594: LD_INT 2
60596: PUSH
60597: LD_INT 3
60599: PUSH
60600: LD_INT 58
60602: PUSH
60603: EMPTY
60604: LIST
60605: PUSH
60606: EMPTY
60607: LIST
60608: LIST
60609: PUSH
60610: LD_INT 61
60612: PUSH
60613: EMPTY
60614: LIST
60615: PUSH
60616: LD_INT 33
60618: PUSH
60619: LD_INT 5
60621: PUSH
60622: EMPTY
60623: LIST
60624: LIST
60625: PUSH
60626: LD_INT 33
60628: PUSH
60629: LD_INT 3
60631: PUSH
60632: EMPTY
60633: LIST
60634: LIST
60635: PUSH
60636: EMPTY
60637: LIST
60638: LIST
60639: LIST
60640: LIST
60641: LIST
60642: PUSH
60643: LD_INT 2
60645: PUSH
60646: LD_INT 34
60648: PUSH
60649: LD_INT 32
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: PUSH
60656: LD_INT 34
60658: PUSH
60659: LD_INT 51
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: PUSH
60666: LD_INT 34
60668: PUSH
60669: LD_INT 12
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: PUSH
60676: EMPTY
60677: LIST
60678: LIST
60679: LIST
60680: LIST
60681: PUSH
60682: EMPTY
60683: LIST
60684: LIST
60685: PPUSH
60686: CALL_OW 72
60690: ST_TO_ADDR
// if not cargo then
60691: LD_VAR 0 7
60695: NOT
60696: IFFALSE 61339
// begin if mc_crates_collector [ i ] < 5 then
60698: LD_EXP 60
60702: PUSH
60703: LD_VAR 0 2
60707: ARRAY
60708: PUSH
60709: LD_INT 5
60711: LESS
60712: IFFALSE 61078
// begin if mc_ape [ i ] then
60714: LD_EXP 72
60718: PUSH
60719: LD_VAR 0 2
60723: ARRAY
60724: IFFALSE 60771
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60726: LD_ADDR_VAR 0 5
60730: PUSH
60731: LD_EXP 72
60735: PUSH
60736: LD_VAR 0 2
60740: ARRAY
60741: PPUSH
60742: LD_INT 25
60744: PUSH
60745: LD_INT 16
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PUSH
60752: LD_INT 24
60754: PUSH
60755: LD_INT 750
60757: PUSH
60758: EMPTY
60759: LIST
60760: LIST
60761: PUSH
60762: EMPTY
60763: LIST
60764: LIST
60765: PPUSH
60766: CALL_OW 72
60770: ST_TO_ADDR
// if not tmp then
60771: LD_VAR 0 5
60775: NOT
60776: IFFALSE 60823
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60778: LD_ADDR_VAR 0 5
60782: PUSH
60783: LD_EXP 43
60787: PUSH
60788: LD_VAR 0 2
60792: ARRAY
60793: PPUSH
60794: LD_INT 25
60796: PUSH
60797: LD_INT 2
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: LD_INT 24
60806: PUSH
60807: LD_INT 750
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: PPUSH
60818: CALL_OW 72
60822: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60823: LD_EXP 72
60827: PUSH
60828: LD_VAR 0 2
60832: ARRAY
60833: PUSH
60834: LD_EXP 43
60838: PUSH
60839: LD_VAR 0 2
60843: ARRAY
60844: PPUSH
60845: LD_INT 25
60847: PUSH
60848: LD_INT 2
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PUSH
60855: LD_INT 24
60857: PUSH
60858: LD_INT 750
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PPUSH
60869: CALL_OW 72
60873: AND
60874: PUSH
60875: LD_VAR 0 5
60879: PUSH
60880: LD_INT 5
60882: LESS
60883: AND
60884: IFFALSE 60966
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
60886: LD_ADDR_VAR 0 3
60890: PUSH
60891: LD_EXP 43
60895: PUSH
60896: LD_VAR 0 2
60900: ARRAY
60901: PPUSH
60902: LD_INT 25
60904: PUSH
60905: LD_INT 2
60907: PUSH
60908: EMPTY
60909: LIST
60910: LIST
60911: PUSH
60912: LD_INT 24
60914: PUSH
60915: LD_INT 750
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: PUSH
60922: EMPTY
60923: LIST
60924: LIST
60925: PPUSH
60926: CALL_OW 72
60930: PUSH
60931: FOR_IN
60932: IFFALSE 60964
// begin tmp := tmp union j ;
60934: LD_ADDR_VAR 0 5
60938: PUSH
60939: LD_VAR 0 5
60943: PUSH
60944: LD_VAR 0 3
60948: UNION
60949: ST_TO_ADDR
// if tmp >= 5 then
60950: LD_VAR 0 5
60954: PUSH
60955: LD_INT 5
60957: GREATEREQUAL
60958: IFFALSE 60962
// break ;
60960: GO 60964
// end ;
60962: GO 60931
60964: POP
60965: POP
// end ; if not tmp then
60966: LD_VAR 0 5
60970: NOT
60971: IFFALSE 60975
// continue ;
60973: GO 60187
// for j in tmp do
60975: LD_ADDR_VAR 0 3
60979: PUSH
60980: LD_VAR 0 5
60984: PUSH
60985: FOR_IN
60986: IFFALSE 61076
// if not GetTag ( j ) then
60988: LD_VAR 0 3
60992: PPUSH
60993: CALL_OW 110
60997: NOT
60998: IFFALSE 61074
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61000: LD_ADDR_EXP 60
61004: PUSH
61005: LD_EXP 60
61009: PPUSH
61010: LD_VAR 0 2
61014: PUSH
61015: LD_EXP 60
61019: PUSH
61020: LD_VAR 0 2
61024: ARRAY
61025: PUSH
61026: LD_INT 1
61028: PLUS
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PPUSH
61034: LD_VAR 0 3
61038: PPUSH
61039: CALL 14797 0 3
61043: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61044: LD_VAR 0 3
61048: PPUSH
61049: LD_INT 107
61051: PPUSH
61052: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61056: LD_EXP 60
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: PUSH
61067: LD_INT 5
61069: GREATEREQUAL
61070: IFFALSE 61074
// break ;
61072: GO 61076
// end ;
61074: GO 60985
61076: POP
61077: POP
// end ; if mc_crates_collector [ i ] and target then
61078: LD_EXP 60
61082: PUSH
61083: LD_VAR 0 2
61087: ARRAY
61088: PUSH
61089: LD_VAR 0 6
61093: AND
61094: IFFALSE 61337
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61096: LD_EXP 60
61100: PUSH
61101: LD_VAR 0 2
61105: ARRAY
61106: PUSH
61107: LD_VAR 0 6
61111: PUSH
61112: LD_INT 1
61114: ARRAY
61115: LESS
61116: IFFALSE 61136
// tmp := mc_crates_collector [ i ] else
61118: LD_ADDR_VAR 0 5
61122: PUSH
61123: LD_EXP 60
61127: PUSH
61128: LD_VAR 0 2
61132: ARRAY
61133: ST_TO_ADDR
61134: GO 61150
// tmp := target [ 1 ] ;
61136: LD_ADDR_VAR 0 5
61140: PUSH
61141: LD_VAR 0 6
61145: PUSH
61146: LD_INT 1
61148: ARRAY
61149: ST_TO_ADDR
// k := 0 ;
61150: LD_ADDR_VAR 0 4
61154: PUSH
61155: LD_INT 0
61157: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61158: LD_ADDR_VAR 0 3
61162: PUSH
61163: LD_EXP 60
61167: PUSH
61168: LD_VAR 0 2
61172: ARRAY
61173: PUSH
61174: FOR_IN
61175: IFFALSE 61335
// begin k := k + 1 ;
61177: LD_ADDR_VAR 0 4
61181: PUSH
61182: LD_VAR 0 4
61186: PUSH
61187: LD_INT 1
61189: PLUS
61190: ST_TO_ADDR
// if k > tmp then
61191: LD_VAR 0 4
61195: PUSH
61196: LD_VAR 0 5
61200: GREATER
61201: IFFALSE 61205
// break ;
61203: GO 61335
// if not GetClass ( j ) in [ 2 , 16 ] then
61205: LD_VAR 0 3
61209: PPUSH
61210: CALL_OW 257
61214: PUSH
61215: LD_INT 2
61217: PUSH
61218: LD_INT 16
61220: PUSH
61221: EMPTY
61222: LIST
61223: LIST
61224: IN
61225: NOT
61226: IFFALSE 61279
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61228: LD_ADDR_EXP 60
61232: PUSH
61233: LD_EXP 60
61237: PPUSH
61238: LD_VAR 0 2
61242: PPUSH
61243: LD_EXP 60
61247: PUSH
61248: LD_VAR 0 2
61252: ARRAY
61253: PUSH
61254: LD_VAR 0 3
61258: DIFF
61259: PPUSH
61260: CALL_OW 1
61264: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61265: LD_VAR 0 3
61269: PPUSH
61270: LD_INT 0
61272: PPUSH
61273: CALL_OW 109
// continue ;
61277: GO 61174
// end ; if IsInUnit ( j ) then
61279: LD_VAR 0 3
61283: PPUSH
61284: CALL_OW 310
61288: IFFALSE 61299
// ComExitBuilding ( j ) ;
61290: LD_VAR 0 3
61294: PPUSH
61295: CALL_OW 122
// wait ( 3 ) ;
61299: LD_INT 3
61301: PPUSH
61302: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61306: LD_VAR 0 3
61310: PPUSH
61311: LD_VAR 0 6
61315: PUSH
61316: LD_INT 2
61318: ARRAY
61319: PPUSH
61320: LD_VAR 0 6
61324: PUSH
61325: LD_INT 3
61327: ARRAY
61328: PPUSH
61329: CALL_OW 117
// end ;
61333: GO 61174
61335: POP
61336: POP
// end ; end else
61337: GO 61918
// begin for j in cargo do
61339: LD_ADDR_VAR 0 3
61343: PUSH
61344: LD_VAR 0 7
61348: PUSH
61349: FOR_IN
61350: IFFALSE 61916
// begin if GetTag ( j ) <> 0 then
61352: LD_VAR 0 3
61356: PPUSH
61357: CALL_OW 110
61361: PUSH
61362: LD_INT 0
61364: NONEQUAL
61365: IFFALSE 61369
// continue ;
61367: GO 61349
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61369: LD_VAR 0 3
61373: PPUSH
61374: CALL_OW 256
61378: PUSH
61379: LD_INT 1000
61381: LESS
61382: PUSH
61383: LD_VAR 0 3
61387: PPUSH
61388: LD_EXP 67
61392: PUSH
61393: LD_VAR 0 2
61397: ARRAY
61398: PPUSH
61399: CALL_OW 308
61403: NOT
61404: AND
61405: IFFALSE 61427
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61407: LD_VAR 0 3
61411: PPUSH
61412: LD_EXP 67
61416: PUSH
61417: LD_VAR 0 2
61421: ARRAY
61422: PPUSH
61423: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61427: LD_VAR 0 3
61431: PPUSH
61432: CALL_OW 256
61436: PUSH
61437: LD_INT 1000
61439: LESS
61440: PUSH
61441: LD_VAR 0 3
61445: PPUSH
61446: LD_EXP 67
61450: PUSH
61451: LD_VAR 0 2
61455: ARRAY
61456: PPUSH
61457: CALL_OW 308
61461: AND
61462: IFFALSE 61466
// continue ;
61464: GO 61349
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61466: LD_VAR 0 3
61470: PPUSH
61471: CALL_OW 262
61475: PUSH
61476: LD_INT 2
61478: EQUAL
61479: PUSH
61480: LD_VAR 0 3
61484: PPUSH
61485: CALL_OW 261
61489: PUSH
61490: LD_INT 15
61492: LESS
61493: AND
61494: IFFALSE 61498
// continue ;
61496: GO 61349
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61498: LD_VAR 0 3
61502: PPUSH
61503: CALL_OW 262
61507: PUSH
61508: LD_INT 1
61510: EQUAL
61511: PUSH
61512: LD_VAR 0 3
61516: PPUSH
61517: CALL_OW 261
61521: PUSH
61522: LD_INT 10
61524: LESS
61525: AND
61526: IFFALSE 61855
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61528: LD_ADDR_VAR 0 8
61532: PUSH
61533: LD_EXP 43
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PPUSH
61544: LD_INT 2
61546: PUSH
61547: LD_INT 30
61549: PUSH
61550: LD_INT 0
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: PUSH
61557: LD_INT 30
61559: PUSH
61560: LD_INT 1
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PUSH
61567: EMPTY
61568: LIST
61569: LIST
61570: LIST
61571: PPUSH
61572: CALL_OW 72
61576: ST_TO_ADDR
// if not depot then
61577: LD_VAR 0 8
61581: NOT
61582: IFFALSE 61586
// continue ;
61584: GO 61349
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61586: LD_VAR 0 3
61590: PPUSH
61591: LD_VAR 0 8
61595: PPUSH
61596: LD_VAR 0 3
61600: PPUSH
61601: CALL_OW 74
61605: PPUSH
61606: CALL_OW 296
61610: PUSH
61611: LD_INT 6
61613: LESS
61614: IFFALSE 61630
// SetFuel ( j , 100 ) else
61616: LD_VAR 0 3
61620: PPUSH
61621: LD_INT 100
61623: PPUSH
61624: CALL_OW 240
61628: GO 61855
// if GetFuel ( j ) = 0 then
61630: LD_VAR 0 3
61634: PPUSH
61635: CALL_OW 261
61639: PUSH
61640: LD_INT 0
61642: EQUAL
61643: IFFALSE 61855
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61645: LD_ADDR_EXP 62
61649: PUSH
61650: LD_EXP 62
61654: PPUSH
61655: LD_VAR 0 2
61659: PPUSH
61660: LD_EXP 62
61664: PUSH
61665: LD_VAR 0 2
61669: ARRAY
61670: PUSH
61671: LD_VAR 0 3
61675: DIFF
61676: PPUSH
61677: CALL_OW 1
61681: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61682: LD_VAR 0 3
61686: PPUSH
61687: CALL_OW 263
61691: PUSH
61692: LD_INT 1
61694: EQUAL
61695: IFFALSE 61711
// ComExitVehicle ( IsInUnit ( j ) ) ;
61697: LD_VAR 0 3
61701: PPUSH
61702: CALL_OW 310
61706: PPUSH
61707: CALL_OW 121
// if GetControl ( j ) = control_remote then
61711: LD_VAR 0 3
61715: PPUSH
61716: CALL_OW 263
61720: PUSH
61721: LD_INT 2
61723: EQUAL
61724: IFFALSE 61735
// ComUnlink ( j ) ;
61726: LD_VAR 0 3
61730: PPUSH
61731: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61735: LD_ADDR_VAR 0 9
61739: PUSH
61740: LD_VAR 0 2
61744: PPUSH
61745: LD_INT 3
61747: PPUSH
61748: CALL 71230 0 2
61752: ST_TO_ADDR
// if fac then
61753: LD_VAR 0 9
61757: IFFALSE 61853
// begin for k in fac do
61759: LD_ADDR_VAR 0 4
61763: PUSH
61764: LD_VAR 0 9
61768: PUSH
61769: FOR_IN
61770: IFFALSE 61851
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61772: LD_ADDR_VAR 0 10
61776: PUSH
61777: LD_VAR 0 9
61781: PPUSH
61782: LD_VAR 0 3
61786: PPUSH
61787: CALL_OW 265
61791: PPUSH
61792: LD_VAR 0 3
61796: PPUSH
61797: CALL_OW 262
61801: PPUSH
61802: LD_VAR 0 3
61806: PPUSH
61807: CALL_OW 263
61811: PPUSH
61812: LD_VAR 0 3
61816: PPUSH
61817: CALL_OW 264
61821: PPUSH
61822: CALL 12329 0 5
61826: ST_TO_ADDR
// if components then
61827: LD_VAR 0 10
61831: IFFALSE 61849
// begin MC_InsertProduceList ( i , components ) ;
61833: LD_VAR 0 2
61837: PPUSH
61838: LD_VAR 0 10
61842: PPUSH
61843: CALL 70775 0 2
// break ;
61847: GO 61851
// end ; end ;
61849: GO 61769
61851: POP
61852: POP
// end ; continue ;
61853: GO 61349
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
61855: LD_VAR 0 3
61859: PPUSH
61860: LD_INT 1
61862: PPUSH
61863: CALL_OW 289
61867: PUSH
61868: LD_INT 100
61870: LESS
61871: PUSH
61872: LD_VAR 0 3
61876: PPUSH
61877: CALL_OW 314
61881: NOT
61882: AND
61883: IFFALSE 61912
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61885: LD_VAR 0 3
61889: PPUSH
61890: LD_VAR 0 6
61894: PUSH
61895: LD_INT 2
61897: ARRAY
61898: PPUSH
61899: LD_VAR 0 6
61903: PUSH
61904: LD_INT 3
61906: ARRAY
61907: PPUSH
61908: CALL_OW 117
// break ;
61912: GO 61916
// end ;
61914: GO 61349
61916: POP
61917: POP
// end ; end ;
61918: GO 60187
61920: POP
61921: POP
// end ;
61922: LD_VAR 0 1
61926: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
61927: LD_INT 0
61929: PPUSH
61930: PPUSH
61931: PPUSH
61932: PPUSH
// if not mc_bases then
61933: LD_EXP 43
61937: NOT
61938: IFFALSE 61942
// exit ;
61940: GO 62103
// for i = 1 to mc_bases do
61942: LD_ADDR_VAR 0 2
61946: PUSH
61947: DOUBLE
61948: LD_INT 1
61950: DEC
61951: ST_TO_ADDR
61952: LD_EXP 43
61956: PUSH
61957: FOR_TO
61958: IFFALSE 62101
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
61960: LD_ADDR_VAR 0 4
61964: PUSH
61965: LD_EXP 62
61969: PUSH
61970: LD_VAR 0 2
61974: ARRAY
61975: PUSH
61976: LD_EXP 65
61980: PUSH
61981: LD_VAR 0 2
61985: ARRAY
61986: UNION
61987: PPUSH
61988: LD_INT 33
61990: PUSH
61991: LD_INT 2
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PPUSH
61998: CALL_OW 72
62002: ST_TO_ADDR
// if tmp then
62003: LD_VAR 0 4
62007: IFFALSE 62099
// for j in tmp do
62009: LD_ADDR_VAR 0 3
62013: PUSH
62014: LD_VAR 0 4
62018: PUSH
62019: FOR_IN
62020: IFFALSE 62097
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62022: LD_VAR 0 3
62026: PPUSH
62027: CALL_OW 312
62031: NOT
62032: PUSH
62033: LD_VAR 0 3
62037: PPUSH
62038: CALL_OW 256
62042: PUSH
62043: LD_INT 250
62045: GREATEREQUAL
62046: AND
62047: IFFALSE 62060
// Connect ( j ) else
62049: LD_VAR 0 3
62053: PPUSH
62054: CALL 17730 0 1
62058: GO 62095
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62060: LD_VAR 0 3
62064: PPUSH
62065: CALL_OW 256
62069: PUSH
62070: LD_INT 250
62072: LESS
62073: PUSH
62074: LD_VAR 0 3
62078: PPUSH
62079: CALL_OW 312
62083: AND
62084: IFFALSE 62095
// ComUnlink ( j ) ;
62086: LD_VAR 0 3
62090: PPUSH
62091: CALL_OW 136
62095: GO 62019
62097: POP
62098: POP
// end ;
62099: GO 61957
62101: POP
62102: POP
// end ;
62103: LD_VAR 0 1
62107: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62108: LD_INT 0
62110: PPUSH
62111: PPUSH
62112: PPUSH
62113: PPUSH
62114: PPUSH
// if not mc_bases then
62115: LD_EXP 43
62119: NOT
62120: IFFALSE 62124
// exit ;
62122: GO 62569
// for i = 1 to mc_bases do
62124: LD_ADDR_VAR 0 2
62128: PUSH
62129: DOUBLE
62130: LD_INT 1
62132: DEC
62133: ST_TO_ADDR
62134: LD_EXP 43
62138: PUSH
62139: FOR_TO
62140: IFFALSE 62567
// begin if not mc_produce [ i ] then
62142: LD_EXP 64
62146: PUSH
62147: LD_VAR 0 2
62151: ARRAY
62152: NOT
62153: IFFALSE 62157
// continue ;
62155: GO 62139
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62157: LD_ADDR_VAR 0 5
62161: PUSH
62162: LD_EXP 43
62166: PUSH
62167: LD_VAR 0 2
62171: ARRAY
62172: PPUSH
62173: LD_INT 30
62175: PUSH
62176: LD_INT 3
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: PPUSH
62183: CALL_OW 72
62187: ST_TO_ADDR
// if not fac then
62188: LD_VAR 0 5
62192: NOT
62193: IFFALSE 62197
// continue ;
62195: GO 62139
// for j in fac do
62197: LD_ADDR_VAR 0 3
62201: PUSH
62202: LD_VAR 0 5
62206: PUSH
62207: FOR_IN
62208: IFFALSE 62563
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62210: LD_VAR 0 3
62214: PPUSH
62215: CALL_OW 461
62219: PUSH
62220: LD_INT 2
62222: NONEQUAL
62223: PUSH
62224: LD_VAR 0 3
62228: PPUSH
62229: LD_INT 15
62231: PPUSH
62232: CALL 17390 0 2
62236: PUSH
62237: LD_INT 4
62239: ARRAY
62240: OR
62241: IFFALSE 62245
// continue ;
62243: GO 62207
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62245: LD_VAR 0 3
62249: PPUSH
62250: LD_EXP 64
62254: PUSH
62255: LD_VAR 0 2
62259: ARRAY
62260: PUSH
62261: LD_INT 1
62263: ARRAY
62264: PUSH
62265: LD_INT 1
62267: ARRAY
62268: PPUSH
62269: LD_EXP 64
62273: PUSH
62274: LD_VAR 0 2
62278: ARRAY
62279: PUSH
62280: LD_INT 1
62282: ARRAY
62283: PUSH
62284: LD_INT 2
62286: ARRAY
62287: PPUSH
62288: LD_EXP 64
62292: PUSH
62293: LD_VAR 0 2
62297: ARRAY
62298: PUSH
62299: LD_INT 1
62301: ARRAY
62302: PUSH
62303: LD_INT 3
62305: ARRAY
62306: PPUSH
62307: LD_EXP 64
62311: PUSH
62312: LD_VAR 0 2
62316: ARRAY
62317: PUSH
62318: LD_INT 1
62320: ARRAY
62321: PUSH
62322: LD_INT 4
62324: ARRAY
62325: PPUSH
62326: CALL_OW 448
62330: PUSH
62331: LD_VAR 0 3
62335: PPUSH
62336: LD_EXP 64
62340: PUSH
62341: LD_VAR 0 2
62345: ARRAY
62346: PUSH
62347: LD_INT 1
62349: ARRAY
62350: PUSH
62351: LD_INT 1
62353: ARRAY
62354: PUSH
62355: LD_EXP 64
62359: PUSH
62360: LD_VAR 0 2
62364: ARRAY
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PUSH
62370: LD_INT 2
62372: ARRAY
62373: PUSH
62374: LD_EXP 64
62378: PUSH
62379: LD_VAR 0 2
62383: ARRAY
62384: PUSH
62385: LD_INT 1
62387: ARRAY
62388: PUSH
62389: LD_INT 3
62391: ARRAY
62392: PUSH
62393: LD_EXP 64
62397: PUSH
62398: LD_VAR 0 2
62402: ARRAY
62403: PUSH
62404: LD_INT 1
62406: ARRAY
62407: PUSH
62408: LD_INT 4
62410: ARRAY
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: LIST
62416: LIST
62417: PPUSH
62418: CALL 21061 0 2
62422: AND
62423: IFFALSE 62561
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62425: LD_VAR 0 3
62429: PPUSH
62430: LD_EXP 64
62434: PUSH
62435: LD_VAR 0 2
62439: ARRAY
62440: PUSH
62441: LD_INT 1
62443: ARRAY
62444: PUSH
62445: LD_INT 1
62447: ARRAY
62448: PPUSH
62449: LD_EXP 64
62453: PUSH
62454: LD_VAR 0 2
62458: ARRAY
62459: PUSH
62460: LD_INT 1
62462: ARRAY
62463: PUSH
62464: LD_INT 2
62466: ARRAY
62467: PPUSH
62468: LD_EXP 64
62472: PUSH
62473: LD_VAR 0 2
62477: ARRAY
62478: PUSH
62479: LD_INT 1
62481: ARRAY
62482: PUSH
62483: LD_INT 3
62485: ARRAY
62486: PPUSH
62487: LD_EXP 64
62491: PUSH
62492: LD_VAR 0 2
62496: ARRAY
62497: PUSH
62498: LD_INT 1
62500: ARRAY
62501: PUSH
62502: LD_INT 4
62504: ARRAY
62505: PPUSH
62506: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62510: LD_ADDR_VAR 0 4
62514: PUSH
62515: LD_EXP 64
62519: PUSH
62520: LD_VAR 0 2
62524: ARRAY
62525: PPUSH
62526: LD_INT 1
62528: PPUSH
62529: CALL_OW 3
62533: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62534: LD_ADDR_EXP 64
62538: PUSH
62539: LD_EXP 64
62543: PPUSH
62544: LD_VAR 0 2
62548: PPUSH
62549: LD_VAR 0 4
62553: PPUSH
62554: CALL_OW 1
62558: ST_TO_ADDR
// break ;
62559: GO 62563
// end ; end ;
62561: GO 62207
62563: POP
62564: POP
// end ;
62565: GO 62139
62567: POP
62568: POP
// end ;
62569: LD_VAR 0 1
62573: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62574: LD_INT 0
62576: PPUSH
62577: PPUSH
62578: PPUSH
// if not mc_bases then
62579: LD_EXP 43
62583: NOT
62584: IFFALSE 62588
// exit ;
62586: GO 62677
// for i = 1 to mc_bases do
62588: LD_ADDR_VAR 0 2
62592: PUSH
62593: DOUBLE
62594: LD_INT 1
62596: DEC
62597: ST_TO_ADDR
62598: LD_EXP 43
62602: PUSH
62603: FOR_TO
62604: IFFALSE 62675
// begin if mc_attack [ i ] then
62606: LD_EXP 63
62610: PUSH
62611: LD_VAR 0 2
62615: ARRAY
62616: IFFALSE 62673
// begin tmp := mc_attack [ i ] [ 1 ] ;
62618: LD_ADDR_VAR 0 3
62622: PUSH
62623: LD_EXP 63
62627: PUSH
62628: LD_VAR 0 2
62632: ARRAY
62633: PUSH
62634: LD_INT 1
62636: ARRAY
62637: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62638: LD_ADDR_EXP 63
62642: PUSH
62643: LD_EXP 63
62647: PPUSH
62648: LD_VAR 0 2
62652: PPUSH
62653: EMPTY
62654: PPUSH
62655: CALL_OW 1
62659: ST_TO_ADDR
// Attack ( tmp ) ;
62660: LD_VAR 0 3
62664: PPUSH
62665: CALL 77282 0 1
// exit ;
62669: POP
62670: POP
62671: GO 62677
// end ; end ;
62673: GO 62603
62675: POP
62676: POP
// end ;
62677: LD_VAR 0 1
62681: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62682: LD_INT 0
62684: PPUSH
62685: PPUSH
62686: PPUSH
62687: PPUSH
62688: PPUSH
62689: PPUSH
62690: PPUSH
// if not mc_bases then
62691: LD_EXP 43
62695: NOT
62696: IFFALSE 62700
// exit ;
62698: GO 63304
// for i = 1 to mc_bases do
62700: LD_ADDR_VAR 0 2
62704: PUSH
62705: DOUBLE
62706: LD_INT 1
62708: DEC
62709: ST_TO_ADDR
62710: LD_EXP 43
62714: PUSH
62715: FOR_TO
62716: IFFALSE 63302
// begin if not mc_bases [ i ] then
62718: LD_EXP 43
62722: PUSH
62723: LD_VAR 0 2
62727: ARRAY
62728: NOT
62729: IFFALSE 62733
// continue ;
62731: GO 62715
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62733: LD_ADDR_VAR 0 7
62737: PUSH
62738: LD_EXP 43
62742: PUSH
62743: LD_VAR 0 2
62747: ARRAY
62748: PUSH
62749: LD_INT 1
62751: ARRAY
62752: PPUSH
62753: CALL 11633 0 1
62757: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62758: LD_ADDR_EXP 66
62762: PUSH
62763: LD_EXP 66
62767: PPUSH
62768: LD_VAR 0 2
62772: PPUSH
62773: LD_EXP 43
62777: PUSH
62778: LD_VAR 0 2
62782: ARRAY
62783: PUSH
62784: LD_INT 1
62786: ARRAY
62787: PPUSH
62788: CALL_OW 255
62792: PPUSH
62793: LD_EXP 68
62797: PUSH
62798: LD_VAR 0 2
62802: ARRAY
62803: PPUSH
62804: CALL 11598 0 2
62808: PPUSH
62809: CALL_OW 1
62813: ST_TO_ADDR
// if not mc_scan [ i ] then
62814: LD_EXP 66
62818: PUSH
62819: LD_VAR 0 2
62823: ARRAY
62824: NOT
62825: IFFALSE 62980
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62827: LD_ADDR_VAR 0 4
62831: PUSH
62832: LD_EXP 43
62836: PUSH
62837: LD_VAR 0 2
62841: ARRAY
62842: PPUSH
62843: LD_INT 2
62845: PUSH
62846: LD_INT 25
62848: PUSH
62849: LD_INT 5
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 25
62858: PUSH
62859: LD_INT 8
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 25
62868: PUSH
62869: LD_INT 9
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: LIST
62880: LIST
62881: PPUSH
62882: CALL_OW 72
62886: ST_TO_ADDR
// if not tmp then
62887: LD_VAR 0 4
62891: NOT
62892: IFFALSE 62896
// continue ;
62894: GO 62715
// for j in tmp do
62896: LD_ADDR_VAR 0 3
62900: PUSH
62901: LD_VAR 0 4
62905: PUSH
62906: FOR_IN
62907: IFFALSE 62978
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
62909: LD_VAR 0 3
62913: PPUSH
62914: CALL_OW 310
62918: PPUSH
62919: CALL_OW 266
62923: PUSH
62924: LD_INT 5
62926: EQUAL
62927: PUSH
62928: LD_VAR 0 3
62932: PPUSH
62933: CALL_OW 257
62937: PUSH
62938: LD_INT 1
62940: EQUAL
62941: AND
62942: PUSH
62943: LD_VAR 0 3
62947: PPUSH
62948: CALL_OW 459
62952: NOT
62953: AND
62954: PUSH
62955: LD_VAR 0 7
62959: AND
62960: IFFALSE 62976
// ComChangeProfession ( j , class ) ;
62962: LD_VAR 0 3
62966: PPUSH
62967: LD_VAR 0 7
62971: PPUSH
62972: CALL_OW 123
62976: GO 62906
62978: POP
62979: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
62980: LD_EXP 66
62984: PUSH
62985: LD_VAR 0 2
62989: ARRAY
62990: PUSH
62991: LD_EXP 65
62995: PUSH
62996: LD_VAR 0 2
63000: ARRAY
63001: NOT
63002: AND
63003: PUSH
63004: LD_EXP 43
63008: PUSH
63009: LD_VAR 0 2
63013: ARRAY
63014: PPUSH
63015: LD_INT 30
63017: PUSH
63018: LD_INT 32
63020: PUSH
63021: EMPTY
63022: LIST
63023: LIST
63024: PPUSH
63025: CALL_OW 72
63029: NOT
63030: AND
63031: PUSH
63032: LD_EXP 43
63036: PUSH
63037: LD_VAR 0 2
63041: ARRAY
63042: PPUSH
63043: LD_INT 2
63045: PUSH
63046: LD_INT 30
63048: PUSH
63049: LD_INT 4
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PUSH
63056: LD_INT 30
63058: PUSH
63059: LD_INT 5
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: LIST
63070: PPUSH
63071: CALL_OW 72
63075: NOT
63076: AND
63077: IFFALSE 63209
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63079: LD_ADDR_VAR 0 4
63083: PUSH
63084: LD_EXP 43
63088: PUSH
63089: LD_VAR 0 2
63093: ARRAY
63094: PPUSH
63095: LD_INT 2
63097: PUSH
63098: LD_INT 25
63100: PUSH
63101: LD_INT 1
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 25
63110: PUSH
63111: LD_INT 5
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 25
63120: PUSH
63121: LD_INT 8
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 25
63130: PUSH
63131: LD_INT 9
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: PPUSH
63145: CALL_OW 72
63149: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63150: LD_ADDR_VAR 0 4
63154: PUSH
63155: LD_VAR 0 4
63159: PUSH
63160: LD_VAR 0 4
63164: PPUSH
63165: LD_INT 18
63167: PPUSH
63168: CALL 43358 0 2
63172: DIFF
63173: ST_TO_ADDR
// if tmp then
63174: LD_VAR 0 4
63178: IFFALSE 63209
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63180: LD_VAR 0 2
63184: PPUSH
63185: LD_VAR 0 4
63189: PPUSH
63190: LD_EXP 68
63194: PUSH
63195: LD_VAR 0 2
63199: ARRAY
63200: PPUSH
63201: CALL 81991 0 3
// exit ;
63205: POP
63206: POP
63207: GO 63304
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
63209: LD_EXP 66
63213: PUSH
63214: LD_VAR 0 2
63218: ARRAY
63219: PUSH
63220: LD_EXP 65
63224: PUSH
63225: LD_VAR 0 2
63229: ARRAY
63230: AND
63231: IFFALSE 63300
// begin tmp := mc_defender [ i ] ;
63233: LD_ADDR_VAR 0 4
63237: PUSH
63238: LD_EXP 65
63242: PUSH
63243: LD_VAR 0 2
63247: ARRAY
63248: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63249: LD_ADDR_EXP 65
63253: PUSH
63254: LD_EXP 65
63258: PPUSH
63259: LD_VAR 0 2
63263: PPUSH
63264: EMPTY
63265: PPUSH
63266: CALL_OW 1
63270: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63271: LD_VAR 0 2
63275: PPUSH
63276: LD_VAR 0 4
63280: PPUSH
63281: LD_EXP 66
63285: PUSH
63286: LD_VAR 0 2
63290: ARRAY
63291: PPUSH
63292: CALL 82552 0 3
// exit ;
63296: POP
63297: POP
63298: GO 63304
// end ; end ;
63300: GO 62715
63302: POP
63303: POP
// end ;
63304: LD_VAR 0 1
63308: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63309: LD_INT 0
63311: PPUSH
63312: PPUSH
63313: PPUSH
63314: PPUSH
63315: PPUSH
63316: PPUSH
63317: PPUSH
63318: PPUSH
63319: PPUSH
63320: PPUSH
63321: PPUSH
// if not mc_bases then
63322: LD_EXP 43
63326: NOT
63327: IFFALSE 63331
// exit ;
63329: GO 64418
// for i = 1 to mc_bases do
63331: LD_ADDR_VAR 0 2
63335: PUSH
63336: DOUBLE
63337: LD_INT 1
63339: DEC
63340: ST_TO_ADDR
63341: LD_EXP 43
63345: PUSH
63346: FOR_TO
63347: IFFALSE 64416
// begin tmp := mc_lab [ i ] ;
63349: LD_ADDR_VAR 0 6
63353: PUSH
63354: LD_EXP 76
63358: PUSH
63359: LD_VAR 0 2
63363: ARRAY
63364: ST_TO_ADDR
// if not tmp then
63365: LD_VAR 0 6
63369: NOT
63370: IFFALSE 63374
// continue ;
63372: GO 63346
// idle_lab := 0 ;
63374: LD_ADDR_VAR 0 11
63378: PUSH
63379: LD_INT 0
63381: ST_TO_ADDR
// for j in tmp do
63382: LD_ADDR_VAR 0 3
63386: PUSH
63387: LD_VAR 0 6
63391: PUSH
63392: FOR_IN
63393: IFFALSE 64412
// begin researching := false ;
63395: LD_ADDR_VAR 0 10
63399: PUSH
63400: LD_INT 0
63402: ST_TO_ADDR
// side := GetSide ( j ) ;
63403: LD_ADDR_VAR 0 4
63407: PUSH
63408: LD_VAR 0 3
63412: PPUSH
63413: CALL_OW 255
63417: ST_TO_ADDR
// if not mc_tech [ side ] then
63418: LD_EXP 70
63422: PUSH
63423: LD_VAR 0 4
63427: ARRAY
63428: NOT
63429: IFFALSE 63433
// continue ;
63431: GO 63392
// if BuildingStatus ( j ) = bs_idle then
63433: LD_VAR 0 3
63437: PPUSH
63438: CALL_OW 461
63442: PUSH
63443: LD_INT 2
63445: EQUAL
63446: IFFALSE 63634
// begin if idle_lab and UnitsInside ( j ) < 6 then
63448: LD_VAR 0 11
63452: PUSH
63453: LD_VAR 0 3
63457: PPUSH
63458: CALL_OW 313
63462: PUSH
63463: LD_INT 6
63465: LESS
63466: AND
63467: IFFALSE 63538
// begin tmp2 := UnitsInside ( idle_lab ) ;
63469: LD_ADDR_VAR 0 9
63473: PUSH
63474: LD_VAR 0 11
63478: PPUSH
63479: CALL_OW 313
63483: ST_TO_ADDR
// if tmp2 then
63484: LD_VAR 0 9
63488: IFFALSE 63530
// for x in tmp2 do
63490: LD_ADDR_VAR 0 7
63494: PUSH
63495: LD_VAR 0 9
63499: PUSH
63500: FOR_IN
63501: IFFALSE 63528
// begin ComExitBuilding ( x ) ;
63503: LD_VAR 0 7
63507: PPUSH
63508: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63512: LD_VAR 0 7
63516: PPUSH
63517: LD_VAR 0 3
63521: PPUSH
63522: CALL_OW 180
// end ;
63526: GO 63500
63528: POP
63529: POP
// idle_lab := 0 ;
63530: LD_ADDR_VAR 0 11
63534: PUSH
63535: LD_INT 0
63537: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63538: LD_ADDR_VAR 0 5
63542: PUSH
63543: LD_EXP 70
63547: PUSH
63548: LD_VAR 0 4
63552: ARRAY
63553: PUSH
63554: FOR_IN
63555: IFFALSE 63615
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63557: LD_VAR 0 3
63561: PPUSH
63562: LD_VAR 0 5
63566: PPUSH
63567: CALL_OW 430
63571: PUSH
63572: LD_VAR 0 4
63576: PPUSH
63577: LD_VAR 0 5
63581: PPUSH
63582: CALL 10703 0 2
63586: AND
63587: IFFALSE 63613
// begin researching := true ;
63589: LD_ADDR_VAR 0 10
63593: PUSH
63594: LD_INT 1
63596: ST_TO_ADDR
// ComResearch ( j , t ) ;
63597: LD_VAR 0 3
63601: PPUSH
63602: LD_VAR 0 5
63606: PPUSH
63607: CALL_OW 124
// break ;
63611: GO 63615
// end ;
63613: GO 63554
63615: POP
63616: POP
// if not researching then
63617: LD_VAR 0 10
63621: NOT
63622: IFFALSE 63634
// idle_lab := j ;
63624: LD_ADDR_VAR 0 11
63628: PUSH
63629: LD_VAR 0 3
63633: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63634: LD_VAR 0 3
63638: PPUSH
63639: CALL_OW 461
63643: PUSH
63644: LD_INT 10
63646: EQUAL
63647: IFFALSE 64235
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63649: LD_EXP 72
63653: PUSH
63654: LD_VAR 0 2
63658: ARRAY
63659: NOT
63660: PUSH
63661: LD_EXP 73
63665: PUSH
63666: LD_VAR 0 2
63670: ARRAY
63671: NOT
63672: AND
63673: PUSH
63674: LD_EXP 70
63678: PUSH
63679: LD_VAR 0 4
63683: ARRAY
63684: PUSH
63685: LD_INT 1
63687: GREATER
63688: AND
63689: IFFALSE 63820
// begin ComCancel ( j ) ;
63691: LD_VAR 0 3
63695: PPUSH
63696: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63700: LD_ADDR_EXP 70
63704: PUSH
63705: LD_EXP 70
63709: PPUSH
63710: LD_VAR 0 4
63714: PPUSH
63715: LD_EXP 70
63719: PUSH
63720: LD_VAR 0 4
63724: ARRAY
63725: PPUSH
63726: LD_EXP 70
63730: PUSH
63731: LD_VAR 0 4
63735: ARRAY
63736: PUSH
63737: LD_INT 1
63739: MINUS
63740: PPUSH
63741: LD_EXP 70
63745: PUSH
63746: LD_VAR 0 4
63750: ARRAY
63751: PPUSH
63752: LD_INT 0
63754: PPUSH
63755: CALL 14215 0 4
63759: PPUSH
63760: CALL_OW 1
63764: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
63765: LD_ADDR_EXP 70
63769: PUSH
63770: LD_EXP 70
63774: PPUSH
63775: LD_VAR 0 4
63779: PPUSH
63780: LD_EXP 70
63784: PUSH
63785: LD_VAR 0 4
63789: ARRAY
63790: PPUSH
63791: LD_EXP 70
63795: PUSH
63796: LD_VAR 0 4
63800: ARRAY
63801: PPUSH
63802: LD_INT 1
63804: PPUSH
63805: LD_INT 0
63807: PPUSH
63808: CALL 14215 0 4
63812: PPUSH
63813: CALL_OW 1
63817: ST_TO_ADDR
// continue ;
63818: GO 63392
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
63820: LD_EXP 72
63824: PUSH
63825: LD_VAR 0 2
63829: ARRAY
63830: PUSH
63831: LD_EXP 73
63835: PUSH
63836: LD_VAR 0 2
63840: ARRAY
63841: NOT
63842: AND
63843: IFFALSE 63970
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
63845: LD_ADDR_EXP 73
63849: PUSH
63850: LD_EXP 73
63854: PPUSH
63855: LD_VAR 0 2
63859: PUSH
63860: LD_EXP 73
63864: PUSH
63865: LD_VAR 0 2
63869: ARRAY
63870: PUSH
63871: LD_INT 1
63873: PLUS
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PPUSH
63879: LD_EXP 72
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PUSH
63890: LD_INT 1
63892: ARRAY
63893: PPUSH
63894: CALL 14797 0 3
63898: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
63899: LD_EXP 72
63903: PUSH
63904: LD_VAR 0 2
63908: ARRAY
63909: PUSH
63910: LD_INT 1
63912: ARRAY
63913: PPUSH
63914: LD_INT 112
63916: PPUSH
63917: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
63921: LD_ADDR_VAR 0 9
63925: PUSH
63926: LD_EXP 72
63930: PUSH
63931: LD_VAR 0 2
63935: ARRAY
63936: PPUSH
63937: LD_INT 1
63939: PPUSH
63940: CALL_OW 3
63944: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
63945: LD_ADDR_EXP 72
63949: PUSH
63950: LD_EXP 72
63954: PPUSH
63955: LD_VAR 0 2
63959: PPUSH
63960: LD_VAR 0 9
63964: PPUSH
63965: CALL_OW 1
63969: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
63970: LD_EXP 72
63974: PUSH
63975: LD_VAR 0 2
63979: ARRAY
63980: PUSH
63981: LD_EXP 73
63985: PUSH
63986: LD_VAR 0 2
63990: ARRAY
63991: AND
63992: PUSH
63993: LD_EXP 73
63997: PUSH
63998: LD_VAR 0 2
64002: ARRAY
64003: PUSH
64004: LD_INT 1
64006: ARRAY
64007: PPUSH
64008: CALL_OW 310
64012: NOT
64013: AND
64014: PUSH
64015: LD_VAR 0 3
64019: PPUSH
64020: CALL_OW 313
64024: PUSH
64025: LD_INT 6
64027: EQUAL
64028: AND
64029: IFFALSE 64085
// begin tmp2 := UnitsInside ( j ) ;
64031: LD_ADDR_VAR 0 9
64035: PUSH
64036: LD_VAR 0 3
64040: PPUSH
64041: CALL_OW 313
64045: ST_TO_ADDR
// if tmp2 = 6 then
64046: LD_VAR 0 9
64050: PUSH
64051: LD_INT 6
64053: EQUAL
64054: IFFALSE 64085
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64056: LD_VAR 0 9
64060: PUSH
64061: LD_INT 1
64063: ARRAY
64064: PPUSH
64065: LD_INT 112
64067: PPUSH
64068: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64072: LD_VAR 0 9
64076: PUSH
64077: LD_INT 1
64079: ARRAY
64080: PPUSH
64081: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64085: LD_EXP 73
64089: PUSH
64090: LD_VAR 0 2
64094: ARRAY
64095: PUSH
64096: LD_EXP 73
64100: PUSH
64101: LD_VAR 0 2
64105: ARRAY
64106: PUSH
64107: LD_INT 1
64109: ARRAY
64110: PPUSH
64111: CALL_OW 314
64115: NOT
64116: AND
64117: PUSH
64118: LD_EXP 73
64122: PUSH
64123: LD_VAR 0 2
64127: ARRAY
64128: PUSH
64129: LD_INT 1
64131: ARRAY
64132: PPUSH
64133: CALL_OW 310
64137: NOT
64138: AND
64139: IFFALSE 64165
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64141: LD_EXP 73
64145: PUSH
64146: LD_VAR 0 2
64150: ARRAY
64151: PUSH
64152: LD_INT 1
64154: ARRAY
64155: PPUSH
64156: LD_VAR 0 3
64160: PPUSH
64161: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64165: LD_EXP 73
64169: PUSH
64170: LD_VAR 0 2
64174: ARRAY
64175: PUSH
64176: LD_INT 1
64178: ARRAY
64179: PPUSH
64180: CALL_OW 310
64184: PUSH
64185: LD_EXP 73
64189: PUSH
64190: LD_VAR 0 2
64194: ARRAY
64195: PUSH
64196: LD_INT 1
64198: ARRAY
64199: PPUSH
64200: CALL_OW 310
64204: PPUSH
64205: CALL_OW 461
64209: PUSH
64210: LD_INT 3
64212: NONEQUAL
64213: AND
64214: IFFALSE 64235
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64216: LD_EXP 73
64220: PUSH
64221: LD_VAR 0 2
64225: ARRAY
64226: PUSH
64227: LD_INT 1
64229: ARRAY
64230: PPUSH
64231: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64235: LD_VAR 0 3
64239: PPUSH
64240: CALL_OW 461
64244: PUSH
64245: LD_INT 6
64247: EQUAL
64248: PUSH
64249: LD_VAR 0 6
64253: PUSH
64254: LD_INT 1
64256: GREATER
64257: AND
64258: IFFALSE 64410
// begin sci := [ ] ;
64260: LD_ADDR_VAR 0 8
64264: PUSH
64265: EMPTY
64266: ST_TO_ADDR
// for x in ( tmp diff j ) do
64267: LD_ADDR_VAR 0 7
64271: PUSH
64272: LD_VAR 0 6
64276: PUSH
64277: LD_VAR 0 3
64281: DIFF
64282: PUSH
64283: FOR_IN
64284: IFFALSE 64336
// begin if sci = 6 then
64286: LD_VAR 0 8
64290: PUSH
64291: LD_INT 6
64293: EQUAL
64294: IFFALSE 64298
// break ;
64296: GO 64336
// if BuildingStatus ( x ) = bs_idle then
64298: LD_VAR 0 7
64302: PPUSH
64303: CALL_OW 461
64307: PUSH
64308: LD_INT 2
64310: EQUAL
64311: IFFALSE 64334
// sci := sci ^ UnitsInside ( x ) ;
64313: LD_ADDR_VAR 0 8
64317: PUSH
64318: LD_VAR 0 8
64322: PUSH
64323: LD_VAR 0 7
64327: PPUSH
64328: CALL_OW 313
64332: ADD
64333: ST_TO_ADDR
// end ;
64334: GO 64283
64336: POP
64337: POP
// if not sci then
64338: LD_VAR 0 8
64342: NOT
64343: IFFALSE 64347
// continue ;
64345: GO 63392
// for x in sci do
64347: LD_ADDR_VAR 0 7
64351: PUSH
64352: LD_VAR 0 8
64356: PUSH
64357: FOR_IN
64358: IFFALSE 64408
// if IsInUnit ( x ) and not HasTask ( x ) then
64360: LD_VAR 0 7
64364: PPUSH
64365: CALL_OW 310
64369: PUSH
64370: LD_VAR 0 7
64374: PPUSH
64375: CALL_OW 314
64379: NOT
64380: AND
64381: IFFALSE 64406
// begin ComExitBuilding ( x ) ;
64383: LD_VAR 0 7
64387: PPUSH
64388: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64392: LD_VAR 0 7
64396: PPUSH
64397: LD_VAR 0 3
64401: PPUSH
64402: CALL_OW 180
// end ;
64406: GO 64357
64408: POP
64409: POP
// end ; end ;
64410: GO 63392
64412: POP
64413: POP
// end ;
64414: GO 63346
64416: POP
64417: POP
// end ;
64418: LD_VAR 0 1
64422: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64423: LD_INT 0
64425: PPUSH
64426: PPUSH
// if not mc_bases then
64427: LD_EXP 43
64431: NOT
64432: IFFALSE 64436
// exit ;
64434: GO 64517
// for i = 1 to mc_bases do
64436: LD_ADDR_VAR 0 2
64440: PUSH
64441: DOUBLE
64442: LD_INT 1
64444: DEC
64445: ST_TO_ADDR
64446: LD_EXP 43
64450: PUSH
64451: FOR_TO
64452: IFFALSE 64515
// if mc_mines [ i ] and mc_miners [ i ] then
64454: LD_EXP 56
64458: PUSH
64459: LD_VAR 0 2
64463: ARRAY
64464: PUSH
64465: LD_EXP 57
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: AND
64476: IFFALSE 64513
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64478: LD_EXP 57
64482: PUSH
64483: LD_VAR 0 2
64487: ARRAY
64488: PUSH
64489: LD_INT 1
64491: ARRAY
64492: PPUSH
64493: CALL_OW 255
64497: PPUSH
64498: LD_EXP 56
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PPUSH
64509: CALL 11786 0 2
64513: GO 64451
64515: POP
64516: POP
// end ;
64517: LD_VAR 0 1
64521: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64522: LD_INT 0
64524: PPUSH
64525: PPUSH
64526: PPUSH
64527: PPUSH
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
// if not mc_bases or not mc_parking then
64532: LD_EXP 43
64536: NOT
64537: PUSH
64538: LD_EXP 67
64542: NOT
64543: OR
64544: IFFALSE 64548
// exit ;
64546: GO 65247
// for i = 1 to mc_bases do
64548: LD_ADDR_VAR 0 2
64552: PUSH
64553: DOUBLE
64554: LD_INT 1
64556: DEC
64557: ST_TO_ADDR
64558: LD_EXP 43
64562: PUSH
64563: FOR_TO
64564: IFFALSE 65245
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64566: LD_EXP 43
64570: PUSH
64571: LD_VAR 0 2
64575: ARRAY
64576: NOT
64577: PUSH
64578: LD_EXP 67
64582: PUSH
64583: LD_VAR 0 2
64587: ARRAY
64588: NOT
64589: OR
64590: IFFALSE 64594
// continue ;
64592: GO 64563
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64594: LD_ADDR_VAR 0 5
64598: PUSH
64599: LD_EXP 43
64603: PUSH
64604: LD_VAR 0 2
64608: ARRAY
64609: PUSH
64610: LD_INT 1
64612: ARRAY
64613: PPUSH
64614: CALL_OW 255
64618: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64619: LD_ADDR_VAR 0 6
64623: PUSH
64624: LD_EXP 43
64628: PUSH
64629: LD_VAR 0 2
64633: ARRAY
64634: PPUSH
64635: LD_INT 30
64637: PUSH
64638: LD_INT 3
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PPUSH
64645: CALL_OW 72
64649: ST_TO_ADDR
// if not fac then
64650: LD_VAR 0 6
64654: NOT
64655: IFFALSE 64706
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64657: LD_ADDR_VAR 0 6
64661: PUSH
64662: LD_EXP 43
64666: PUSH
64667: LD_VAR 0 2
64671: ARRAY
64672: PPUSH
64673: LD_INT 2
64675: PUSH
64676: LD_INT 30
64678: PUSH
64679: LD_INT 0
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 30
64688: PUSH
64689: LD_INT 1
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: LIST
64700: PPUSH
64701: CALL_OW 72
64705: ST_TO_ADDR
// if not fac then
64706: LD_VAR 0 6
64710: NOT
64711: IFFALSE 64715
// continue ;
64713: GO 64563
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64715: LD_ADDR_VAR 0 7
64719: PUSH
64720: LD_EXP 67
64724: PUSH
64725: LD_VAR 0 2
64729: ARRAY
64730: PPUSH
64731: LD_INT 22
64733: PUSH
64734: LD_VAR 0 5
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 21
64745: PUSH
64746: LD_INT 2
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 3
64755: PUSH
64756: LD_INT 24
64758: PUSH
64759: LD_INT 1000
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: LIST
64774: PPUSH
64775: CALL_OW 70
64779: ST_TO_ADDR
// for j in fac do
64780: LD_ADDR_VAR 0 3
64784: PUSH
64785: LD_VAR 0 6
64789: PUSH
64790: FOR_IN
64791: IFFALSE 64872
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64793: LD_ADDR_VAR 0 7
64797: PUSH
64798: LD_VAR 0 7
64802: PUSH
64803: LD_INT 22
64805: PUSH
64806: LD_VAR 0 5
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 91
64817: PUSH
64818: LD_VAR 0 3
64822: PUSH
64823: LD_INT 15
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: LIST
64830: PUSH
64831: LD_INT 21
64833: PUSH
64834: LD_INT 2
64836: PUSH
64837: EMPTY
64838: LIST
64839: LIST
64840: PUSH
64841: LD_INT 3
64843: PUSH
64844: LD_INT 24
64846: PUSH
64847: LD_INT 1000
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: PPUSH
64864: CALL_OW 69
64868: UNION
64869: ST_TO_ADDR
64870: GO 64790
64872: POP
64873: POP
// if not vehs then
64874: LD_VAR 0 7
64878: NOT
64879: IFFALSE 64905
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64881: LD_ADDR_EXP 55
64885: PUSH
64886: LD_EXP 55
64890: PPUSH
64891: LD_VAR 0 2
64895: PPUSH
64896: EMPTY
64897: PPUSH
64898: CALL_OW 1
64902: ST_TO_ADDR
// continue ;
64903: GO 64563
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64905: LD_ADDR_VAR 0 8
64909: PUSH
64910: LD_EXP 43
64914: PUSH
64915: LD_VAR 0 2
64919: ARRAY
64920: PPUSH
64921: LD_INT 30
64923: PUSH
64924: LD_INT 3
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: PPUSH
64931: CALL_OW 72
64935: ST_TO_ADDR
// if tmp then
64936: LD_VAR 0 8
64940: IFFALSE 65043
// begin for j in tmp do
64942: LD_ADDR_VAR 0 3
64946: PUSH
64947: LD_VAR 0 8
64951: PUSH
64952: FOR_IN
64953: IFFALSE 65041
// for k in UnitsInside ( j ) do
64955: LD_ADDR_VAR 0 4
64959: PUSH
64960: LD_VAR 0 3
64964: PPUSH
64965: CALL_OW 313
64969: PUSH
64970: FOR_IN
64971: IFFALSE 65037
// if k then
64973: LD_VAR 0 4
64977: IFFALSE 65035
// if not k in mc_repair_vehicle [ i ] then
64979: LD_VAR 0 4
64983: PUSH
64984: LD_EXP 55
64988: PUSH
64989: LD_VAR 0 2
64993: ARRAY
64994: IN
64995: NOT
64996: IFFALSE 65035
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
64998: LD_ADDR_EXP 55
65002: PUSH
65003: LD_EXP 55
65007: PPUSH
65008: LD_VAR 0 2
65012: PPUSH
65013: LD_EXP 55
65017: PUSH
65018: LD_VAR 0 2
65022: ARRAY
65023: PUSH
65024: LD_VAR 0 4
65028: UNION
65029: PPUSH
65030: CALL_OW 1
65034: ST_TO_ADDR
65035: GO 64970
65037: POP
65038: POP
65039: GO 64952
65041: POP
65042: POP
// end ; if not mc_repair_vehicle [ i ] then
65043: LD_EXP 55
65047: PUSH
65048: LD_VAR 0 2
65052: ARRAY
65053: NOT
65054: IFFALSE 65058
// continue ;
65056: GO 64563
// for j in mc_repair_vehicle [ i ] do
65058: LD_ADDR_VAR 0 3
65062: PUSH
65063: LD_EXP 55
65067: PUSH
65068: LD_VAR 0 2
65072: ARRAY
65073: PUSH
65074: FOR_IN
65075: IFFALSE 65241
// begin if GetClass ( j ) <> 3 then
65077: LD_VAR 0 3
65081: PPUSH
65082: CALL_OW 257
65086: PUSH
65087: LD_INT 3
65089: NONEQUAL
65090: IFFALSE 65131
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65092: LD_ADDR_EXP 55
65096: PUSH
65097: LD_EXP 55
65101: PPUSH
65102: LD_VAR 0 2
65106: PPUSH
65107: LD_EXP 55
65111: PUSH
65112: LD_VAR 0 2
65116: ARRAY
65117: PUSH
65118: LD_VAR 0 3
65122: DIFF
65123: PPUSH
65124: CALL_OW 1
65128: ST_TO_ADDR
// continue ;
65129: GO 65074
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65131: LD_VAR 0 3
65135: PPUSH
65136: CALL_OW 311
65140: NOT
65141: PUSH
65142: LD_VAR 0 3
65146: PUSH
65147: LD_EXP 46
65151: PUSH
65152: LD_VAR 0 2
65156: ARRAY
65157: PUSH
65158: LD_INT 1
65160: ARRAY
65161: IN
65162: NOT
65163: AND
65164: PUSH
65165: LD_VAR 0 3
65169: PUSH
65170: LD_EXP 46
65174: PUSH
65175: LD_VAR 0 2
65179: ARRAY
65180: PUSH
65181: LD_INT 2
65183: ARRAY
65184: IN
65185: NOT
65186: AND
65187: IFFALSE 65239
// begin if IsInUnit ( j ) then
65189: LD_VAR 0 3
65193: PPUSH
65194: CALL_OW 310
65198: IFFALSE 65209
// ComExitBuilding ( j ) ;
65200: LD_VAR 0 3
65204: PPUSH
65205: CALL_OW 122
// if not HasTask ( j ) then
65209: LD_VAR 0 3
65213: PPUSH
65214: CALL_OW 314
65218: NOT
65219: IFFALSE 65239
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65221: LD_VAR 0 3
65225: PPUSH
65226: LD_VAR 0 7
65230: PUSH
65231: LD_INT 1
65233: ARRAY
65234: PPUSH
65235: CALL_OW 189
// end ; end ;
65239: GO 65074
65241: POP
65242: POP
// end ;
65243: GO 64563
65245: POP
65246: POP
// end ;
65247: LD_VAR 0 1
65251: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65252: LD_INT 0
65254: PPUSH
65255: PPUSH
65256: PPUSH
65257: PPUSH
65258: PPUSH
65259: PPUSH
65260: PPUSH
65261: PPUSH
65262: PPUSH
65263: PPUSH
65264: PPUSH
// if not mc_bases then
65265: LD_EXP 43
65269: NOT
65270: IFFALSE 65274
// exit ;
65272: GO 66076
// for i = 1 to mc_bases do
65274: LD_ADDR_VAR 0 2
65278: PUSH
65279: DOUBLE
65280: LD_INT 1
65282: DEC
65283: ST_TO_ADDR
65284: LD_EXP 43
65288: PUSH
65289: FOR_TO
65290: IFFALSE 66074
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65292: LD_EXP 71
65296: PUSH
65297: LD_VAR 0 2
65301: ARRAY
65302: NOT
65303: PUSH
65304: LD_EXP 46
65308: PUSH
65309: LD_VAR 0 2
65313: ARRAY
65314: PUSH
65315: LD_INT 1
65317: ARRAY
65318: OR
65319: PUSH
65320: LD_EXP 46
65324: PUSH
65325: LD_VAR 0 2
65329: ARRAY
65330: PUSH
65331: LD_INT 2
65333: ARRAY
65334: OR
65335: PUSH
65336: LD_EXP 69
65340: PUSH
65341: LD_VAR 0 2
65345: ARRAY
65346: PPUSH
65347: LD_INT 1
65349: PPUSH
65350: CALL_OW 325
65354: NOT
65355: OR
65356: PUSH
65357: LD_EXP 66
65361: PUSH
65362: LD_VAR 0 2
65366: ARRAY
65367: OR
65368: IFFALSE 65372
// continue ;
65370: GO 65289
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65372: LD_ADDR_VAR 0 8
65376: PUSH
65377: LD_EXP 43
65381: PUSH
65382: LD_VAR 0 2
65386: ARRAY
65387: PPUSH
65388: LD_INT 25
65390: PUSH
65391: LD_INT 4
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 50
65400: PUSH
65401: EMPTY
65402: LIST
65403: PUSH
65404: LD_INT 3
65406: PUSH
65407: LD_INT 60
65409: PUSH
65410: EMPTY
65411: LIST
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: LIST
65421: PPUSH
65422: CALL_OW 72
65426: PUSH
65427: LD_EXP 47
65431: PUSH
65432: LD_VAR 0 2
65436: ARRAY
65437: DIFF
65438: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65439: LD_ADDR_VAR 0 9
65443: PUSH
65444: LD_EXP 43
65448: PUSH
65449: LD_VAR 0 2
65453: ARRAY
65454: PPUSH
65455: LD_INT 2
65457: PUSH
65458: LD_INT 30
65460: PUSH
65461: LD_INT 0
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: PUSH
65468: LD_INT 30
65470: PUSH
65471: LD_INT 1
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: LIST
65482: PPUSH
65483: CALL_OW 72
65487: ST_TO_ADDR
// if not tmp or not dep then
65488: LD_VAR 0 8
65492: NOT
65493: PUSH
65494: LD_VAR 0 9
65498: NOT
65499: OR
65500: IFFALSE 65504
// continue ;
65502: GO 65289
// side := GetSide ( tmp [ 1 ] ) ;
65504: LD_ADDR_VAR 0 11
65508: PUSH
65509: LD_VAR 0 8
65513: PUSH
65514: LD_INT 1
65516: ARRAY
65517: PPUSH
65518: CALL_OW 255
65522: ST_TO_ADDR
// dep := dep [ 1 ] ;
65523: LD_ADDR_VAR 0 9
65527: PUSH
65528: LD_VAR 0 9
65532: PUSH
65533: LD_INT 1
65535: ARRAY
65536: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65537: LD_ADDR_VAR 0 7
65541: PUSH
65542: LD_EXP 71
65546: PUSH
65547: LD_VAR 0 2
65551: ARRAY
65552: PPUSH
65553: LD_INT 22
65555: PUSH
65556: LD_INT 0
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 25
65565: PUSH
65566: LD_INT 12
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PPUSH
65577: CALL_OW 70
65581: PUSH
65582: LD_INT 22
65584: PUSH
65585: LD_INT 0
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 25
65594: PUSH
65595: LD_INT 12
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 91
65604: PUSH
65605: LD_VAR 0 9
65609: PUSH
65610: LD_INT 20
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: LIST
65622: PPUSH
65623: CALL_OW 69
65627: UNION
65628: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65629: LD_ADDR_VAR 0 10
65633: PUSH
65634: LD_EXP 71
65638: PUSH
65639: LD_VAR 0 2
65643: ARRAY
65644: PPUSH
65645: LD_INT 81
65647: PUSH
65648: LD_VAR 0 11
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PPUSH
65657: CALL_OW 70
65661: ST_TO_ADDR
// if not apes or danger_at_area then
65662: LD_VAR 0 7
65666: NOT
65667: PUSH
65668: LD_VAR 0 10
65672: OR
65673: IFFALSE 65723
// begin if mc_taming [ i ] then
65675: LD_EXP 74
65679: PUSH
65680: LD_VAR 0 2
65684: ARRAY
65685: IFFALSE 65721
// begin MC_Reset ( i , 121 ) ;
65687: LD_VAR 0 2
65691: PPUSH
65692: LD_INT 121
65694: PPUSH
65695: CALL 51133 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65699: LD_ADDR_EXP 74
65703: PUSH
65704: LD_EXP 74
65708: PPUSH
65709: LD_VAR 0 2
65713: PPUSH
65714: EMPTY
65715: PPUSH
65716: CALL_OW 1
65720: ST_TO_ADDR
// end ; continue ;
65721: GO 65289
// end ; for j in tmp do
65723: LD_ADDR_VAR 0 3
65727: PUSH
65728: LD_VAR 0 8
65732: PUSH
65733: FOR_IN
65734: IFFALSE 66070
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65736: LD_VAR 0 3
65740: PUSH
65741: LD_EXP 74
65745: PUSH
65746: LD_VAR 0 2
65750: ARRAY
65751: IN
65752: NOT
65753: PUSH
65754: LD_EXP 74
65758: PUSH
65759: LD_VAR 0 2
65763: ARRAY
65764: PUSH
65765: LD_INT 3
65767: LESS
65768: AND
65769: IFFALSE 65827
// begin SetTag ( j , 121 ) ;
65771: LD_VAR 0 3
65775: PPUSH
65776: LD_INT 121
65778: PPUSH
65779: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
65783: LD_ADDR_EXP 74
65787: PUSH
65788: LD_EXP 74
65792: PPUSH
65793: LD_VAR 0 2
65797: PUSH
65798: LD_EXP 74
65802: PUSH
65803: LD_VAR 0 2
65807: ARRAY
65808: PUSH
65809: LD_INT 1
65811: PLUS
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PPUSH
65817: LD_VAR 0 3
65821: PPUSH
65822: CALL 14797 0 3
65826: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
65827: LD_VAR 0 3
65831: PUSH
65832: LD_EXP 74
65836: PUSH
65837: LD_VAR 0 2
65841: ARRAY
65842: IN
65843: IFFALSE 66068
// begin if GetClass ( j ) <> 4 then
65845: LD_VAR 0 3
65849: PPUSH
65850: CALL_OW 257
65854: PUSH
65855: LD_INT 4
65857: NONEQUAL
65858: IFFALSE 65911
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
65860: LD_ADDR_EXP 74
65864: PUSH
65865: LD_EXP 74
65869: PPUSH
65870: LD_VAR 0 2
65874: PPUSH
65875: LD_EXP 74
65879: PUSH
65880: LD_VAR 0 2
65884: ARRAY
65885: PUSH
65886: LD_VAR 0 3
65890: DIFF
65891: PPUSH
65892: CALL_OW 1
65896: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65897: LD_VAR 0 3
65901: PPUSH
65902: LD_INT 0
65904: PPUSH
65905: CALL_OW 109
// continue ;
65909: GO 65733
// end ; if IsInUnit ( j ) then
65911: LD_VAR 0 3
65915: PPUSH
65916: CALL_OW 310
65920: IFFALSE 65931
// ComExitBuilding ( j ) ;
65922: LD_VAR 0 3
65926: PPUSH
65927: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
65931: LD_ADDR_VAR 0 6
65935: PUSH
65936: LD_VAR 0 7
65940: PPUSH
65941: LD_VAR 0 3
65945: PPUSH
65946: CALL_OW 74
65950: ST_TO_ADDR
// if not ape then
65951: LD_VAR 0 6
65955: NOT
65956: IFFALSE 65960
// break ;
65958: GO 66070
// x := GetX ( ape ) ;
65960: LD_ADDR_VAR 0 4
65964: PUSH
65965: LD_VAR 0 6
65969: PPUSH
65970: CALL_OW 250
65974: ST_TO_ADDR
// y := GetY ( ape ) ;
65975: LD_ADDR_VAR 0 5
65979: PUSH
65980: LD_VAR 0 6
65984: PPUSH
65985: CALL_OW 251
65989: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65990: LD_VAR 0 4
65994: PPUSH
65995: LD_VAR 0 5
65999: PPUSH
66000: CALL_OW 488
66004: NOT
66005: PUSH
66006: LD_VAR 0 11
66010: PPUSH
66011: LD_VAR 0 4
66015: PPUSH
66016: LD_VAR 0 5
66020: PPUSH
66021: LD_INT 20
66023: PPUSH
66024: CALL 15693 0 4
66028: PUSH
66029: LD_INT 4
66031: ARRAY
66032: OR
66033: IFFALSE 66037
// break ;
66035: GO 66070
// if not HasTask ( j ) then
66037: LD_VAR 0 3
66041: PPUSH
66042: CALL_OW 314
66046: NOT
66047: IFFALSE 66068
// ComTameXY ( j , x , y ) ;
66049: LD_VAR 0 3
66053: PPUSH
66054: LD_VAR 0 4
66058: PPUSH
66059: LD_VAR 0 5
66063: PPUSH
66064: CALL_OW 131
// end ; end ;
66068: GO 65733
66070: POP
66071: POP
// end ;
66072: GO 65289
66074: POP
66075: POP
// end ;
66076: LD_VAR 0 1
66080: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66081: LD_INT 0
66083: PPUSH
66084: PPUSH
66085: PPUSH
66086: PPUSH
66087: PPUSH
66088: PPUSH
66089: PPUSH
66090: PPUSH
// if not mc_bases then
66091: LD_EXP 43
66095: NOT
66096: IFFALSE 66100
// exit ;
66098: GO 66726
// for i = 1 to mc_bases do
66100: LD_ADDR_VAR 0 2
66104: PUSH
66105: DOUBLE
66106: LD_INT 1
66108: DEC
66109: ST_TO_ADDR
66110: LD_EXP 43
66114: PUSH
66115: FOR_TO
66116: IFFALSE 66724
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66118: LD_EXP 72
66122: PUSH
66123: LD_VAR 0 2
66127: ARRAY
66128: NOT
66129: PUSH
66130: LD_EXP 72
66134: PUSH
66135: LD_VAR 0 2
66139: ARRAY
66140: PPUSH
66141: LD_INT 25
66143: PUSH
66144: LD_INT 12
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PPUSH
66151: CALL_OW 72
66155: NOT
66156: OR
66157: IFFALSE 66161
// continue ;
66159: GO 66115
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66161: LD_ADDR_VAR 0 5
66165: PUSH
66166: LD_EXP 72
66170: PUSH
66171: LD_VAR 0 2
66175: ARRAY
66176: PUSH
66177: LD_INT 1
66179: ARRAY
66180: PPUSH
66181: CALL_OW 255
66185: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66186: LD_VAR 0 5
66190: PPUSH
66191: LD_INT 2
66193: PPUSH
66194: CALL_OW 325
66198: IFFALSE 66451
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66200: LD_ADDR_VAR 0 4
66204: PUSH
66205: LD_EXP 72
66209: PUSH
66210: LD_VAR 0 2
66214: ARRAY
66215: PPUSH
66216: LD_INT 25
66218: PUSH
66219: LD_INT 16
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PPUSH
66226: CALL_OW 72
66230: ST_TO_ADDR
// if tmp < 6 then
66231: LD_VAR 0 4
66235: PUSH
66236: LD_INT 6
66238: LESS
66239: IFFALSE 66451
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66241: LD_ADDR_VAR 0 6
66245: PUSH
66246: LD_EXP 43
66250: PUSH
66251: LD_VAR 0 2
66255: ARRAY
66256: PPUSH
66257: LD_INT 2
66259: PUSH
66260: LD_INT 30
66262: PUSH
66263: LD_INT 0
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 30
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: LIST
66284: PPUSH
66285: CALL_OW 72
66289: ST_TO_ADDR
// if depot then
66290: LD_VAR 0 6
66294: IFFALSE 66451
// begin selected := 0 ;
66296: LD_ADDR_VAR 0 7
66300: PUSH
66301: LD_INT 0
66303: ST_TO_ADDR
// for j in depot do
66304: LD_ADDR_VAR 0 3
66308: PUSH
66309: LD_VAR 0 6
66313: PUSH
66314: FOR_IN
66315: IFFALSE 66346
// begin if UnitsInside ( j ) < 6 then
66317: LD_VAR 0 3
66321: PPUSH
66322: CALL_OW 313
66326: PUSH
66327: LD_INT 6
66329: LESS
66330: IFFALSE 66344
// begin selected := j ;
66332: LD_ADDR_VAR 0 7
66336: PUSH
66337: LD_VAR 0 3
66341: ST_TO_ADDR
// break ;
66342: GO 66346
// end ; end ;
66344: GO 66314
66346: POP
66347: POP
// if selected then
66348: LD_VAR 0 7
66352: IFFALSE 66451
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66354: LD_ADDR_VAR 0 3
66358: PUSH
66359: LD_EXP 72
66363: PUSH
66364: LD_VAR 0 2
66368: ARRAY
66369: PPUSH
66370: LD_INT 25
66372: PUSH
66373: LD_INT 12
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PPUSH
66380: CALL_OW 72
66384: PUSH
66385: FOR_IN
66386: IFFALSE 66449
// if not HasTask ( j ) then
66388: LD_VAR 0 3
66392: PPUSH
66393: CALL_OW 314
66397: NOT
66398: IFFALSE 66447
// begin if not IsInUnit ( j ) then
66400: LD_VAR 0 3
66404: PPUSH
66405: CALL_OW 310
66409: NOT
66410: IFFALSE 66426
// ComEnterUnit ( j , selected ) ;
66412: LD_VAR 0 3
66416: PPUSH
66417: LD_VAR 0 7
66421: PPUSH
66422: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66426: LD_VAR 0 3
66430: PPUSH
66431: LD_INT 16
66433: PPUSH
66434: CALL_OW 183
// AddComExitBuilding ( j ) ;
66438: LD_VAR 0 3
66442: PPUSH
66443: CALL_OW 182
// end ;
66447: GO 66385
66449: POP
66450: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66451: LD_VAR 0 5
66455: PPUSH
66456: LD_INT 11
66458: PPUSH
66459: CALL_OW 325
66463: IFFALSE 66722
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66465: LD_ADDR_VAR 0 4
66469: PUSH
66470: LD_EXP 72
66474: PUSH
66475: LD_VAR 0 2
66479: ARRAY
66480: PPUSH
66481: LD_INT 25
66483: PUSH
66484: LD_INT 16
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PPUSH
66491: CALL_OW 72
66495: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66496: LD_VAR 0 4
66500: PUSH
66501: LD_INT 6
66503: GREATEREQUAL
66504: PUSH
66505: LD_VAR 0 5
66509: PPUSH
66510: LD_INT 2
66512: PPUSH
66513: CALL_OW 325
66517: NOT
66518: OR
66519: IFFALSE 66722
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66521: LD_ADDR_VAR 0 8
66525: PUSH
66526: LD_EXP 43
66530: PUSH
66531: LD_VAR 0 2
66535: ARRAY
66536: PPUSH
66537: LD_INT 2
66539: PUSH
66540: LD_INT 30
66542: PUSH
66543: LD_INT 4
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 30
66552: PUSH
66553: LD_INT 5
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: LIST
66564: PPUSH
66565: CALL_OW 72
66569: ST_TO_ADDR
// if barracks then
66570: LD_VAR 0 8
66574: IFFALSE 66722
// begin selected := 0 ;
66576: LD_ADDR_VAR 0 7
66580: PUSH
66581: LD_INT 0
66583: ST_TO_ADDR
// for j in barracks do
66584: LD_ADDR_VAR 0 3
66588: PUSH
66589: LD_VAR 0 8
66593: PUSH
66594: FOR_IN
66595: IFFALSE 66626
// begin if UnitsInside ( j ) < 6 then
66597: LD_VAR 0 3
66601: PPUSH
66602: CALL_OW 313
66606: PUSH
66607: LD_INT 6
66609: LESS
66610: IFFALSE 66624
// begin selected := j ;
66612: LD_ADDR_VAR 0 7
66616: PUSH
66617: LD_VAR 0 3
66621: ST_TO_ADDR
// break ;
66622: GO 66626
// end ; end ;
66624: GO 66594
66626: POP
66627: POP
// if selected then
66628: LD_VAR 0 7
66632: IFFALSE 66722
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66634: LD_ADDR_VAR 0 3
66638: PUSH
66639: LD_EXP 72
66643: PUSH
66644: LD_VAR 0 2
66648: ARRAY
66649: PPUSH
66650: LD_INT 25
66652: PUSH
66653: LD_INT 12
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PPUSH
66660: CALL_OW 72
66664: PUSH
66665: FOR_IN
66666: IFFALSE 66720
// if not IsInUnit ( j ) and not HasTask ( j ) then
66668: LD_VAR 0 3
66672: PPUSH
66673: CALL_OW 310
66677: NOT
66678: PUSH
66679: LD_VAR 0 3
66683: PPUSH
66684: CALL_OW 314
66688: NOT
66689: AND
66690: IFFALSE 66718
// begin ComEnterUnit ( j , selected ) ;
66692: LD_VAR 0 3
66696: PPUSH
66697: LD_VAR 0 7
66701: PPUSH
66702: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66706: LD_VAR 0 3
66710: PPUSH
66711: LD_INT 15
66713: PPUSH
66714: CALL_OW 183
// end ;
66718: GO 66665
66720: POP
66721: POP
// end ; end ; end ; end ; end ;
66722: GO 66115
66724: POP
66725: POP
// end ;
66726: LD_VAR 0 1
66730: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66731: LD_INT 0
66733: PPUSH
66734: PPUSH
66735: PPUSH
66736: PPUSH
// if not mc_bases then
66737: LD_EXP 43
66741: NOT
66742: IFFALSE 66746
// exit ;
66744: GO 66924
// for i = 1 to mc_bases do
66746: LD_ADDR_VAR 0 2
66750: PUSH
66751: DOUBLE
66752: LD_INT 1
66754: DEC
66755: ST_TO_ADDR
66756: LD_EXP 43
66760: PUSH
66761: FOR_TO
66762: IFFALSE 66922
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
66764: LD_ADDR_VAR 0 4
66768: PUSH
66769: LD_EXP 43
66773: PUSH
66774: LD_VAR 0 2
66778: ARRAY
66779: PPUSH
66780: LD_INT 25
66782: PUSH
66783: LD_INT 9
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PPUSH
66790: CALL_OW 72
66794: ST_TO_ADDR
// if not tmp then
66795: LD_VAR 0 4
66799: NOT
66800: IFFALSE 66804
// continue ;
66802: GO 66761
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
66804: LD_EXP 69
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PPUSH
66815: LD_INT 29
66817: PPUSH
66818: CALL_OW 325
66822: NOT
66823: PUSH
66824: LD_EXP 69
66828: PUSH
66829: LD_VAR 0 2
66833: ARRAY
66834: PPUSH
66835: LD_INT 28
66837: PPUSH
66838: CALL_OW 325
66842: NOT
66843: AND
66844: IFFALSE 66848
// continue ;
66846: GO 66761
// for j in tmp do
66848: LD_ADDR_VAR 0 3
66852: PUSH
66853: LD_VAR 0 4
66857: PUSH
66858: FOR_IN
66859: IFFALSE 66918
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66861: LD_VAR 0 3
66865: PUSH
66866: LD_EXP 46
66870: PUSH
66871: LD_VAR 0 2
66875: ARRAY
66876: PUSH
66877: LD_INT 1
66879: ARRAY
66880: IN
66881: NOT
66882: PUSH
66883: LD_VAR 0 3
66887: PUSH
66888: LD_EXP 46
66892: PUSH
66893: LD_VAR 0 2
66897: ARRAY
66898: PUSH
66899: LD_INT 2
66901: ARRAY
66902: IN
66903: NOT
66904: AND
66905: IFFALSE 66916
// ComSpaceTimeShoot ( j ) ;
66907: LD_VAR 0 3
66911: PPUSH
66912: CALL 10794 0 1
66916: GO 66858
66918: POP
66919: POP
// end ;
66920: GO 66761
66922: POP
66923: POP
// end ;
66924: LD_VAR 0 1
66928: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
66929: LD_INT 0
66931: PPUSH
66932: PPUSH
66933: PPUSH
66934: PPUSH
66935: PPUSH
66936: PPUSH
66937: PPUSH
66938: PPUSH
66939: PPUSH
// if not mc_bases then
66940: LD_EXP 43
66944: NOT
66945: IFFALSE 66949
// exit ;
66947: GO 67571
// for i = 1 to mc_bases do
66949: LD_ADDR_VAR 0 2
66953: PUSH
66954: DOUBLE
66955: LD_INT 1
66957: DEC
66958: ST_TO_ADDR
66959: LD_EXP 43
66963: PUSH
66964: FOR_TO
66965: IFFALSE 67569
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
66967: LD_EXP 78
66971: PUSH
66972: LD_VAR 0 2
66976: ARRAY
66977: NOT
66978: PUSH
66979: LD_INT 38
66981: PPUSH
66982: LD_EXP 69
66986: PUSH
66987: LD_VAR 0 2
66991: ARRAY
66992: PPUSH
66993: CALL_OW 321
66997: PUSH
66998: LD_INT 2
67000: NONEQUAL
67001: OR
67002: IFFALSE 67006
// continue ;
67004: GO 66964
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67006: LD_ADDR_VAR 0 8
67010: PUSH
67011: LD_EXP 43
67015: PUSH
67016: LD_VAR 0 2
67020: ARRAY
67021: PPUSH
67022: LD_INT 30
67024: PUSH
67025: LD_INT 34
67027: PUSH
67028: EMPTY
67029: LIST
67030: LIST
67031: PPUSH
67032: CALL_OW 72
67036: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67037: LD_ADDR_VAR 0 9
67041: PUSH
67042: LD_EXP 43
67046: PUSH
67047: LD_VAR 0 2
67051: ARRAY
67052: PPUSH
67053: LD_INT 25
67055: PUSH
67056: LD_INT 4
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: PPUSH
67063: CALL_OW 72
67067: PPUSH
67068: LD_INT 0
67070: PPUSH
67071: CALL 43358 0 2
67075: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67076: LD_VAR 0 9
67080: NOT
67081: PUSH
67082: LD_VAR 0 8
67086: NOT
67087: OR
67088: PUSH
67089: LD_EXP 43
67093: PUSH
67094: LD_VAR 0 2
67098: ARRAY
67099: PPUSH
67100: LD_INT 124
67102: PPUSH
67103: CALL 43358 0 2
67107: OR
67108: IFFALSE 67112
// continue ;
67110: GO 66964
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67112: LD_EXP 79
67116: PUSH
67117: LD_VAR 0 2
67121: ARRAY
67122: PUSH
67123: LD_EXP 78
67127: PUSH
67128: LD_VAR 0 2
67132: ARRAY
67133: LESS
67134: PUSH
67135: LD_EXP 79
67139: PUSH
67140: LD_VAR 0 2
67144: ARRAY
67145: PUSH
67146: LD_VAR 0 8
67150: LESS
67151: AND
67152: IFFALSE 67567
// begin tmp := sci [ 1 ] ;
67154: LD_ADDR_VAR 0 7
67158: PUSH
67159: LD_VAR 0 9
67163: PUSH
67164: LD_INT 1
67166: ARRAY
67167: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67168: LD_VAR 0 7
67172: PPUSH
67173: LD_INT 124
67175: PPUSH
67176: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67180: LD_ADDR_VAR 0 3
67184: PUSH
67185: DOUBLE
67186: LD_EXP 78
67190: PUSH
67191: LD_VAR 0 2
67195: ARRAY
67196: INC
67197: ST_TO_ADDR
67198: LD_EXP 78
67202: PUSH
67203: LD_VAR 0 2
67207: ARRAY
67208: PUSH
67209: FOR_DOWNTO
67210: IFFALSE 67553
// begin if IsInUnit ( tmp ) then
67212: LD_VAR 0 7
67216: PPUSH
67217: CALL_OW 310
67221: IFFALSE 67232
// ComExitBuilding ( tmp ) ;
67223: LD_VAR 0 7
67227: PPUSH
67228: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67232: LD_INT 35
67234: PPUSH
67235: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67239: LD_VAR 0 7
67243: PPUSH
67244: CALL_OW 310
67248: NOT
67249: PUSH
67250: LD_VAR 0 7
67254: PPUSH
67255: CALL_OW 314
67259: NOT
67260: AND
67261: IFFALSE 67232
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67263: LD_ADDR_VAR 0 6
67267: PUSH
67268: LD_VAR 0 7
67272: PPUSH
67273: CALL_OW 250
67277: PUSH
67278: LD_VAR 0 7
67282: PPUSH
67283: CALL_OW 251
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67292: LD_INT 35
67294: PPUSH
67295: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67299: LD_ADDR_VAR 0 4
67303: PUSH
67304: LD_EXP 78
67308: PUSH
67309: LD_VAR 0 2
67313: ARRAY
67314: PUSH
67315: LD_VAR 0 3
67319: ARRAY
67320: PUSH
67321: LD_INT 1
67323: ARRAY
67324: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67325: LD_ADDR_VAR 0 5
67329: PUSH
67330: LD_EXP 78
67334: PUSH
67335: LD_VAR 0 2
67339: ARRAY
67340: PUSH
67341: LD_VAR 0 3
67345: ARRAY
67346: PUSH
67347: LD_INT 2
67349: ARRAY
67350: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67351: LD_VAR 0 7
67355: PPUSH
67356: LD_INT 10
67358: PPUSH
67359: CALL 17390 0 2
67363: PUSH
67364: LD_INT 4
67366: ARRAY
67367: IFFALSE 67405
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67369: LD_VAR 0 7
67373: PPUSH
67374: LD_VAR 0 6
67378: PUSH
67379: LD_INT 1
67381: ARRAY
67382: PPUSH
67383: LD_VAR 0 6
67387: PUSH
67388: LD_INT 2
67390: ARRAY
67391: PPUSH
67392: CALL_OW 111
// wait ( 0 0$10 ) ;
67396: LD_INT 350
67398: PPUSH
67399: CALL_OW 67
// end else
67403: GO 67431
// begin ComMoveXY ( tmp , x , y ) ;
67405: LD_VAR 0 7
67409: PPUSH
67410: LD_VAR 0 4
67414: PPUSH
67415: LD_VAR 0 5
67419: PPUSH
67420: CALL_OW 111
// wait ( 0 0$3 ) ;
67424: LD_INT 105
67426: PPUSH
67427: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67431: LD_VAR 0 7
67435: PPUSH
67436: LD_VAR 0 4
67440: PPUSH
67441: LD_VAR 0 5
67445: PPUSH
67446: CALL_OW 307
67450: IFFALSE 67292
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67452: LD_VAR 0 7
67456: PPUSH
67457: LD_VAR 0 4
67461: PPUSH
67462: LD_VAR 0 5
67466: PPUSH
67467: LD_VAR 0 8
67471: PUSH
67472: LD_VAR 0 3
67476: ARRAY
67477: PPUSH
67478: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67482: LD_INT 35
67484: PPUSH
67485: CALL_OW 67
// until not HasTask ( tmp ) ;
67489: LD_VAR 0 7
67493: PPUSH
67494: CALL_OW 314
67498: NOT
67499: IFFALSE 67482
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67501: LD_ADDR_EXP 79
67505: PUSH
67506: LD_EXP 79
67510: PPUSH
67511: LD_VAR 0 2
67515: PUSH
67516: LD_EXP 79
67520: PUSH
67521: LD_VAR 0 2
67525: ARRAY
67526: PUSH
67527: LD_INT 1
67529: PLUS
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: PPUSH
67535: LD_VAR 0 8
67539: PUSH
67540: LD_VAR 0 3
67544: ARRAY
67545: PPUSH
67546: CALL 14797 0 3
67550: ST_TO_ADDR
// end ;
67551: GO 67209
67553: POP
67554: POP
// MC_Reset ( i , 124 ) ;
67555: LD_VAR 0 2
67559: PPUSH
67560: LD_INT 124
67562: PPUSH
67563: CALL 51133 0 2
// end ; end ;
67567: GO 66964
67569: POP
67570: POP
// end ;
67571: LD_VAR 0 1
67575: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67576: LD_INT 0
67578: PPUSH
67579: PPUSH
67580: PPUSH
// if not mc_bases then
67581: LD_EXP 43
67585: NOT
67586: IFFALSE 67590
// exit ;
67588: GO 68196
// for i = 1 to mc_bases do
67590: LD_ADDR_VAR 0 2
67594: PUSH
67595: DOUBLE
67596: LD_INT 1
67598: DEC
67599: ST_TO_ADDR
67600: LD_EXP 43
67604: PUSH
67605: FOR_TO
67606: IFFALSE 68194
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67608: LD_ADDR_VAR 0 3
67612: PUSH
67613: LD_EXP 43
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PPUSH
67624: LD_INT 25
67626: PUSH
67627: LD_INT 4
67629: PUSH
67630: EMPTY
67631: LIST
67632: LIST
67633: PPUSH
67634: CALL_OW 72
67638: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67639: LD_VAR 0 3
67643: NOT
67644: PUSH
67645: LD_EXP 80
67649: PUSH
67650: LD_VAR 0 2
67654: ARRAY
67655: NOT
67656: OR
67657: PUSH
67658: LD_EXP 43
67662: PUSH
67663: LD_VAR 0 2
67667: ARRAY
67668: PPUSH
67669: LD_INT 2
67671: PUSH
67672: LD_INT 30
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 30
67684: PUSH
67685: LD_INT 1
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: LIST
67696: PPUSH
67697: CALL_OW 72
67701: NOT
67702: OR
67703: IFFALSE 67753
// begin if mc_deposits_finder [ i ] then
67705: LD_EXP 81
67709: PUSH
67710: LD_VAR 0 2
67714: ARRAY
67715: IFFALSE 67751
// begin MC_Reset ( i , 125 ) ;
67717: LD_VAR 0 2
67721: PPUSH
67722: LD_INT 125
67724: PPUSH
67725: CALL 51133 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67729: LD_ADDR_EXP 81
67733: PUSH
67734: LD_EXP 81
67738: PPUSH
67739: LD_VAR 0 2
67743: PPUSH
67744: EMPTY
67745: PPUSH
67746: CALL_OW 1
67750: ST_TO_ADDR
// end ; continue ;
67751: GO 67605
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
67753: LD_EXP 80
67757: PUSH
67758: LD_VAR 0 2
67762: ARRAY
67763: PUSH
67764: LD_INT 1
67766: ARRAY
67767: PUSH
67768: LD_INT 3
67770: ARRAY
67771: PUSH
67772: LD_INT 1
67774: EQUAL
67775: PUSH
67776: LD_INT 20
67778: PPUSH
67779: LD_EXP 69
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: PPUSH
67790: CALL_OW 321
67794: PUSH
67795: LD_INT 2
67797: NONEQUAL
67798: AND
67799: IFFALSE 67849
// begin if mc_deposits_finder [ i ] then
67801: LD_EXP 81
67805: PUSH
67806: LD_VAR 0 2
67810: ARRAY
67811: IFFALSE 67847
// begin MC_Reset ( i , 125 ) ;
67813: LD_VAR 0 2
67817: PPUSH
67818: LD_INT 125
67820: PPUSH
67821: CALL 51133 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67825: LD_ADDR_EXP 81
67829: PUSH
67830: LD_EXP 81
67834: PPUSH
67835: LD_VAR 0 2
67839: PPUSH
67840: EMPTY
67841: PPUSH
67842: CALL_OW 1
67846: ST_TO_ADDR
// end ; continue ;
67847: GO 67605
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
67849: LD_EXP 80
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PUSH
67860: LD_INT 1
67862: ARRAY
67863: PUSH
67864: LD_INT 1
67866: ARRAY
67867: PPUSH
67868: LD_EXP 80
67872: PUSH
67873: LD_VAR 0 2
67877: ARRAY
67878: PUSH
67879: LD_INT 1
67881: ARRAY
67882: PUSH
67883: LD_INT 2
67885: ARRAY
67886: PPUSH
67887: LD_EXP 69
67891: PUSH
67892: LD_VAR 0 2
67896: ARRAY
67897: PPUSH
67898: CALL_OW 440
67902: IFFALSE 67945
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
67904: LD_ADDR_EXP 80
67908: PUSH
67909: LD_EXP 80
67913: PPUSH
67914: LD_VAR 0 2
67918: PPUSH
67919: LD_EXP 80
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PPUSH
67930: LD_INT 1
67932: PPUSH
67933: CALL_OW 3
67937: PPUSH
67938: CALL_OW 1
67942: ST_TO_ADDR
67943: GO 68192
// begin if not mc_deposits_finder [ i ] then
67945: LD_EXP 81
67949: PUSH
67950: LD_VAR 0 2
67954: ARRAY
67955: NOT
67956: IFFALSE 68008
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
67958: LD_ADDR_EXP 81
67962: PUSH
67963: LD_EXP 81
67967: PPUSH
67968: LD_VAR 0 2
67972: PPUSH
67973: LD_VAR 0 3
67977: PUSH
67978: LD_INT 1
67980: ARRAY
67981: PUSH
67982: EMPTY
67983: LIST
67984: PPUSH
67985: CALL_OW 1
67989: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
67990: LD_VAR 0 3
67994: PUSH
67995: LD_INT 1
67997: ARRAY
67998: PPUSH
67999: LD_INT 125
68001: PPUSH
68002: CALL_OW 109
// end else
68006: GO 68192
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68008: LD_EXP 81
68012: PUSH
68013: LD_VAR 0 2
68017: ARRAY
68018: PUSH
68019: LD_INT 1
68021: ARRAY
68022: PPUSH
68023: CALL_OW 310
68027: IFFALSE 68050
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68029: LD_EXP 81
68033: PUSH
68034: LD_VAR 0 2
68038: ARRAY
68039: PUSH
68040: LD_INT 1
68042: ARRAY
68043: PPUSH
68044: CALL_OW 122
68048: GO 68192
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68050: LD_EXP 81
68054: PUSH
68055: LD_VAR 0 2
68059: ARRAY
68060: PUSH
68061: LD_INT 1
68063: ARRAY
68064: PPUSH
68065: CALL_OW 314
68069: NOT
68070: PUSH
68071: LD_EXP 81
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: PUSH
68082: LD_INT 1
68084: ARRAY
68085: PPUSH
68086: LD_EXP 80
68090: PUSH
68091: LD_VAR 0 2
68095: ARRAY
68096: PUSH
68097: LD_INT 1
68099: ARRAY
68100: PUSH
68101: LD_INT 1
68103: ARRAY
68104: PPUSH
68105: LD_EXP 80
68109: PUSH
68110: LD_VAR 0 2
68114: ARRAY
68115: PUSH
68116: LD_INT 1
68118: ARRAY
68119: PUSH
68120: LD_INT 2
68122: ARRAY
68123: PPUSH
68124: CALL_OW 297
68128: PUSH
68129: LD_INT 6
68131: GREATER
68132: AND
68133: IFFALSE 68192
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68135: LD_EXP 81
68139: PUSH
68140: LD_VAR 0 2
68144: ARRAY
68145: PUSH
68146: LD_INT 1
68148: ARRAY
68149: PPUSH
68150: LD_EXP 80
68154: PUSH
68155: LD_VAR 0 2
68159: ARRAY
68160: PUSH
68161: LD_INT 1
68163: ARRAY
68164: PUSH
68165: LD_INT 1
68167: ARRAY
68168: PPUSH
68169: LD_EXP 80
68173: PUSH
68174: LD_VAR 0 2
68178: ARRAY
68179: PUSH
68180: LD_INT 1
68182: ARRAY
68183: PUSH
68184: LD_INT 2
68186: ARRAY
68187: PPUSH
68188: CALL_OW 111
// end ; end ; end ;
68192: GO 67605
68194: POP
68195: POP
// end ;
68196: LD_VAR 0 1
68200: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68201: LD_INT 0
68203: PPUSH
68204: PPUSH
68205: PPUSH
68206: PPUSH
68207: PPUSH
68208: PPUSH
68209: PPUSH
68210: PPUSH
68211: PPUSH
68212: PPUSH
68213: PPUSH
// if not mc_bases then
68214: LD_EXP 43
68218: NOT
68219: IFFALSE 68223
// exit ;
68221: GO 69163
// for i = 1 to mc_bases do
68223: LD_ADDR_VAR 0 2
68227: PUSH
68228: DOUBLE
68229: LD_INT 1
68231: DEC
68232: ST_TO_ADDR
68233: LD_EXP 43
68237: PUSH
68238: FOR_TO
68239: IFFALSE 69161
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68241: LD_EXP 43
68245: PUSH
68246: LD_VAR 0 2
68250: ARRAY
68251: NOT
68252: PUSH
68253: LD_EXP 66
68257: PUSH
68258: LD_VAR 0 2
68262: ARRAY
68263: OR
68264: IFFALSE 68268
// continue ;
68266: GO 68238
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68268: LD_ADDR_VAR 0 7
68272: PUSH
68273: LD_EXP 43
68277: PUSH
68278: LD_VAR 0 2
68282: ARRAY
68283: PUSH
68284: LD_INT 1
68286: ARRAY
68287: PPUSH
68288: CALL_OW 248
68292: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68293: LD_VAR 0 7
68297: PUSH
68298: LD_INT 3
68300: EQUAL
68301: PUSH
68302: LD_EXP 62
68306: PUSH
68307: LD_VAR 0 2
68311: ARRAY
68312: PUSH
68313: LD_EXP 65
68317: PUSH
68318: LD_VAR 0 2
68322: ARRAY
68323: UNION
68324: PPUSH
68325: LD_INT 33
68327: PUSH
68328: LD_INT 2
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PPUSH
68335: CALL_OW 72
68339: NOT
68340: OR
68341: IFFALSE 68345
// continue ;
68343: GO 68238
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68345: LD_ADDR_VAR 0 9
68349: PUSH
68350: LD_EXP 43
68354: PUSH
68355: LD_VAR 0 2
68359: ARRAY
68360: PPUSH
68361: LD_INT 30
68363: PUSH
68364: LD_INT 36
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PPUSH
68371: CALL_OW 72
68375: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68376: LD_ADDR_VAR 0 10
68380: PUSH
68381: LD_EXP 62
68385: PUSH
68386: LD_VAR 0 2
68390: ARRAY
68391: PPUSH
68392: LD_INT 34
68394: PUSH
68395: LD_INT 31
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PPUSH
68402: CALL_OW 72
68406: ST_TO_ADDR
// if not cts and not mcts then
68407: LD_VAR 0 9
68411: NOT
68412: PUSH
68413: LD_VAR 0 10
68417: NOT
68418: AND
68419: IFFALSE 68423
// continue ;
68421: GO 68238
// x := cts ;
68423: LD_ADDR_VAR 0 11
68427: PUSH
68428: LD_VAR 0 9
68432: ST_TO_ADDR
// if not x then
68433: LD_VAR 0 11
68437: NOT
68438: IFFALSE 68450
// x := mcts ;
68440: LD_ADDR_VAR 0 11
68444: PUSH
68445: LD_VAR 0 10
68449: ST_TO_ADDR
// if not x then
68450: LD_VAR 0 11
68454: NOT
68455: IFFALSE 68459
// continue ;
68457: GO 68238
// if mc_remote_driver [ i ] then
68459: LD_EXP 83
68463: PUSH
68464: LD_VAR 0 2
68468: ARRAY
68469: IFFALSE 68856
// for j in mc_remote_driver [ i ] do
68471: LD_ADDR_VAR 0 3
68475: PUSH
68476: LD_EXP 83
68480: PUSH
68481: LD_VAR 0 2
68485: ARRAY
68486: PUSH
68487: FOR_IN
68488: IFFALSE 68854
// begin if GetClass ( j ) <> 3 then
68490: LD_VAR 0 3
68494: PPUSH
68495: CALL_OW 257
68499: PUSH
68500: LD_INT 3
68502: NONEQUAL
68503: IFFALSE 68556
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68505: LD_ADDR_EXP 83
68509: PUSH
68510: LD_EXP 83
68514: PPUSH
68515: LD_VAR 0 2
68519: PPUSH
68520: LD_EXP 83
68524: PUSH
68525: LD_VAR 0 2
68529: ARRAY
68530: PUSH
68531: LD_VAR 0 3
68535: DIFF
68536: PPUSH
68537: CALL_OW 1
68541: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68542: LD_VAR 0 3
68546: PPUSH
68547: LD_INT 0
68549: PPUSH
68550: CALL_OW 109
// continue ;
68554: GO 68487
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68556: LD_EXP 62
68560: PUSH
68561: LD_VAR 0 2
68565: ARRAY
68566: PPUSH
68567: LD_INT 34
68569: PUSH
68570: LD_INT 31
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 58
68579: PUSH
68580: EMPTY
68581: LIST
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PPUSH
68587: CALL_OW 72
68591: PUSH
68592: LD_VAR 0 3
68596: PPUSH
68597: CALL 43446 0 1
68601: NOT
68602: AND
68603: IFFALSE 68674
// begin if IsInUnit ( j ) then
68605: LD_VAR 0 3
68609: PPUSH
68610: CALL_OW 310
68614: IFFALSE 68625
// ComExitBuilding ( j ) ;
68616: LD_VAR 0 3
68620: PPUSH
68621: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68625: LD_VAR 0 3
68629: PPUSH
68630: LD_EXP 62
68634: PUSH
68635: LD_VAR 0 2
68639: ARRAY
68640: PPUSH
68641: LD_INT 34
68643: PUSH
68644: LD_INT 31
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 58
68653: PUSH
68654: EMPTY
68655: LIST
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PPUSH
68661: CALL_OW 72
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PPUSH
68670: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68674: LD_VAR 0 3
68678: PPUSH
68679: CALL_OW 310
68683: NOT
68684: PUSH
68685: LD_VAR 0 3
68689: PPUSH
68690: CALL_OW 310
68694: PPUSH
68695: CALL_OW 266
68699: PUSH
68700: LD_INT 36
68702: NONEQUAL
68703: PUSH
68704: LD_VAR 0 3
68708: PPUSH
68709: CALL 43446 0 1
68713: NOT
68714: AND
68715: OR
68716: IFFALSE 68852
// begin if IsInUnit ( j ) then
68718: LD_VAR 0 3
68722: PPUSH
68723: CALL_OW 310
68727: IFFALSE 68738
// ComExitBuilding ( j ) ;
68729: LD_VAR 0 3
68733: PPUSH
68734: CALL_OW 122
// ct := 0 ;
68738: LD_ADDR_VAR 0 8
68742: PUSH
68743: LD_INT 0
68745: ST_TO_ADDR
// for k in x do
68746: LD_ADDR_VAR 0 4
68750: PUSH
68751: LD_VAR 0 11
68755: PUSH
68756: FOR_IN
68757: IFFALSE 68830
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
68759: LD_VAR 0 4
68763: PPUSH
68764: CALL_OW 264
68768: PUSH
68769: LD_INT 31
68771: EQUAL
68772: PUSH
68773: LD_VAR 0 4
68777: PPUSH
68778: CALL_OW 311
68782: NOT
68783: AND
68784: PUSH
68785: LD_VAR 0 4
68789: PPUSH
68790: CALL_OW 266
68794: PUSH
68795: LD_INT 36
68797: EQUAL
68798: PUSH
68799: LD_VAR 0 4
68803: PPUSH
68804: CALL_OW 313
68808: PUSH
68809: LD_INT 3
68811: LESS
68812: AND
68813: OR
68814: IFFALSE 68828
// begin ct := k ;
68816: LD_ADDR_VAR 0 8
68820: PUSH
68821: LD_VAR 0 4
68825: ST_TO_ADDR
// break ;
68826: GO 68830
// end ;
68828: GO 68756
68830: POP
68831: POP
// if ct then
68832: LD_VAR 0 8
68836: IFFALSE 68852
// ComEnterUnit ( j , ct ) ;
68838: LD_VAR 0 3
68842: PPUSH
68843: LD_VAR 0 8
68847: PPUSH
68848: CALL_OW 120
// end ; end ;
68852: GO 68487
68854: POP
68855: POP
// places := 0 ;
68856: LD_ADDR_VAR 0 5
68860: PUSH
68861: LD_INT 0
68863: ST_TO_ADDR
// for j = 1 to x do
68864: LD_ADDR_VAR 0 3
68868: PUSH
68869: DOUBLE
68870: LD_INT 1
68872: DEC
68873: ST_TO_ADDR
68874: LD_VAR 0 11
68878: PUSH
68879: FOR_TO
68880: IFFALSE 68956
// if GetWeapon ( x [ j ] ) = ar_control_tower then
68882: LD_VAR 0 11
68886: PUSH
68887: LD_VAR 0 3
68891: ARRAY
68892: PPUSH
68893: CALL_OW 264
68897: PUSH
68898: LD_INT 31
68900: EQUAL
68901: IFFALSE 68919
// places := places + 1 else
68903: LD_ADDR_VAR 0 5
68907: PUSH
68908: LD_VAR 0 5
68912: PUSH
68913: LD_INT 1
68915: PLUS
68916: ST_TO_ADDR
68917: GO 68954
// if GetBType ( x [ j ] ) = b_control_tower then
68919: LD_VAR 0 11
68923: PUSH
68924: LD_VAR 0 3
68928: ARRAY
68929: PPUSH
68930: CALL_OW 266
68934: PUSH
68935: LD_INT 36
68937: EQUAL
68938: IFFALSE 68954
// places := places + 3 ;
68940: LD_ADDR_VAR 0 5
68944: PUSH
68945: LD_VAR 0 5
68949: PUSH
68950: LD_INT 3
68952: PLUS
68953: ST_TO_ADDR
68954: GO 68879
68956: POP
68957: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
68958: LD_VAR 0 5
68962: PUSH
68963: LD_INT 0
68965: EQUAL
68966: PUSH
68967: LD_VAR 0 5
68971: PUSH
68972: LD_EXP 83
68976: PUSH
68977: LD_VAR 0 2
68981: ARRAY
68982: LESSEQUAL
68983: OR
68984: IFFALSE 68988
// continue ;
68986: GO 68238
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
68988: LD_ADDR_VAR 0 6
68992: PUSH
68993: LD_EXP 43
68997: PUSH
68998: LD_VAR 0 2
69002: ARRAY
69003: PPUSH
69004: LD_INT 25
69006: PUSH
69007: LD_INT 3
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PPUSH
69014: CALL_OW 72
69018: PUSH
69019: LD_EXP 83
69023: PUSH
69024: LD_VAR 0 2
69028: ARRAY
69029: DIFF
69030: PPUSH
69031: LD_INT 3
69033: PPUSH
69034: CALL 44346 0 2
69038: ST_TO_ADDR
// for j in tmp do
69039: LD_ADDR_VAR 0 3
69043: PUSH
69044: LD_VAR 0 6
69048: PUSH
69049: FOR_IN
69050: IFFALSE 69085
// if GetTag ( j ) > 0 then
69052: LD_VAR 0 3
69056: PPUSH
69057: CALL_OW 110
69061: PUSH
69062: LD_INT 0
69064: GREATER
69065: IFFALSE 69083
// tmp := tmp diff j ;
69067: LD_ADDR_VAR 0 6
69071: PUSH
69072: LD_VAR 0 6
69076: PUSH
69077: LD_VAR 0 3
69081: DIFF
69082: ST_TO_ADDR
69083: GO 69049
69085: POP
69086: POP
// if not tmp then
69087: LD_VAR 0 6
69091: NOT
69092: IFFALSE 69096
// continue ;
69094: GO 68238
// if places then
69096: LD_VAR 0 5
69100: IFFALSE 69159
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69102: LD_ADDR_EXP 83
69106: PUSH
69107: LD_EXP 83
69111: PPUSH
69112: LD_VAR 0 2
69116: PPUSH
69117: LD_EXP 83
69121: PUSH
69122: LD_VAR 0 2
69126: ARRAY
69127: PUSH
69128: LD_VAR 0 6
69132: PUSH
69133: LD_INT 1
69135: ARRAY
69136: UNION
69137: PPUSH
69138: CALL_OW 1
69142: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69143: LD_VAR 0 6
69147: PUSH
69148: LD_INT 1
69150: ARRAY
69151: PPUSH
69152: LD_INT 126
69154: PPUSH
69155: CALL_OW 109
// end ; end ;
69159: GO 68238
69161: POP
69162: POP
// end ;
69163: LD_VAR 0 1
69167: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69168: LD_INT 0
69170: PPUSH
69171: PPUSH
69172: PPUSH
69173: PPUSH
69174: PPUSH
69175: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69176: LD_VAR 0 1
69180: NOT
69181: PUSH
69182: LD_VAR 0 2
69186: NOT
69187: OR
69188: PUSH
69189: LD_VAR 0 3
69193: NOT
69194: OR
69195: PUSH
69196: LD_VAR 0 4
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: LD_INT 2
69206: PUSH
69207: LD_INT 3
69209: PUSH
69210: LD_INT 4
69212: PUSH
69213: LD_INT 5
69215: PUSH
69216: LD_INT 8
69218: PUSH
69219: LD_INT 9
69221: PUSH
69222: LD_INT 15
69224: PUSH
69225: LD_INT 16
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: IN
69239: NOT
69240: OR
69241: IFFALSE 69245
// exit ;
69243: GO 70145
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69245: LD_ADDR_VAR 0 2
69249: PUSH
69250: LD_VAR 0 2
69254: PPUSH
69255: LD_INT 21
69257: PUSH
69258: LD_INT 3
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 24
69267: PUSH
69268: LD_INT 250
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PPUSH
69279: CALL_OW 72
69283: ST_TO_ADDR
// case class of 1 , 15 :
69284: LD_VAR 0 4
69288: PUSH
69289: LD_INT 1
69291: DOUBLE
69292: EQUAL
69293: IFTRUE 69303
69295: LD_INT 15
69297: DOUBLE
69298: EQUAL
69299: IFTRUE 69303
69301: GO 69388
69303: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69304: LD_ADDR_VAR 0 8
69308: PUSH
69309: LD_VAR 0 2
69313: PPUSH
69314: LD_INT 2
69316: PUSH
69317: LD_INT 30
69319: PUSH
69320: LD_INT 32
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 30
69329: PUSH
69330: LD_INT 31
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: LIST
69341: PPUSH
69342: CALL_OW 72
69346: PUSH
69347: LD_VAR 0 2
69351: PPUSH
69352: LD_INT 2
69354: PUSH
69355: LD_INT 30
69357: PUSH
69358: LD_INT 4
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: LD_INT 30
69367: PUSH
69368: LD_INT 5
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: LIST
69379: PPUSH
69380: CALL_OW 72
69384: ADD
69385: ST_TO_ADDR
69386: GO 69634
69388: LD_INT 2
69390: DOUBLE
69391: EQUAL
69392: IFTRUE 69402
69394: LD_INT 16
69396: DOUBLE
69397: EQUAL
69398: IFTRUE 69402
69400: GO 69448
69402: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69403: LD_ADDR_VAR 0 8
69407: PUSH
69408: LD_VAR 0 2
69412: PPUSH
69413: LD_INT 2
69415: PUSH
69416: LD_INT 30
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 30
69428: PUSH
69429: LD_INT 1
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: LIST
69440: PPUSH
69441: CALL_OW 72
69445: ST_TO_ADDR
69446: GO 69634
69448: LD_INT 3
69450: DOUBLE
69451: EQUAL
69452: IFTRUE 69456
69454: GO 69502
69456: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69457: LD_ADDR_VAR 0 8
69461: PUSH
69462: LD_VAR 0 2
69466: PPUSH
69467: LD_INT 2
69469: PUSH
69470: LD_INT 30
69472: PUSH
69473: LD_INT 2
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 30
69482: PUSH
69483: LD_INT 3
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: LIST
69494: PPUSH
69495: CALL_OW 72
69499: ST_TO_ADDR
69500: GO 69634
69502: LD_INT 4
69504: DOUBLE
69505: EQUAL
69506: IFTRUE 69510
69508: GO 69567
69510: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69511: LD_ADDR_VAR 0 8
69515: PUSH
69516: LD_VAR 0 2
69520: PPUSH
69521: LD_INT 2
69523: PUSH
69524: LD_INT 30
69526: PUSH
69527: LD_INT 6
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 30
69536: PUSH
69537: LD_INT 7
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 30
69546: PUSH
69547: LD_INT 8
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: PPUSH
69560: CALL_OW 72
69564: ST_TO_ADDR
69565: GO 69634
69567: LD_INT 5
69569: DOUBLE
69570: EQUAL
69571: IFTRUE 69587
69573: LD_INT 8
69575: DOUBLE
69576: EQUAL
69577: IFTRUE 69587
69579: LD_INT 9
69581: DOUBLE
69582: EQUAL
69583: IFTRUE 69587
69585: GO 69633
69587: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69588: LD_ADDR_VAR 0 8
69592: PUSH
69593: LD_VAR 0 2
69597: PPUSH
69598: LD_INT 2
69600: PUSH
69601: LD_INT 30
69603: PUSH
69604: LD_INT 4
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PUSH
69611: LD_INT 30
69613: PUSH
69614: LD_INT 5
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: LIST
69625: PPUSH
69626: CALL_OW 72
69630: ST_TO_ADDR
69631: GO 69634
69633: POP
// if not tmp then
69634: LD_VAR 0 8
69638: NOT
69639: IFFALSE 69643
// exit ;
69641: GO 70145
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69643: LD_VAR 0 4
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: LD_INT 15
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: IN
69658: PUSH
69659: LD_EXP 52
69663: PUSH
69664: LD_VAR 0 1
69668: ARRAY
69669: AND
69670: IFFALSE 69826
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69672: LD_ADDR_VAR 0 9
69676: PUSH
69677: LD_EXP 52
69681: PUSH
69682: LD_VAR 0 1
69686: ARRAY
69687: PUSH
69688: LD_INT 1
69690: ARRAY
69691: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69692: LD_VAR 0 9
69696: PUSH
69697: LD_EXP 53
69701: PUSH
69702: LD_VAR 0 1
69706: ARRAY
69707: IN
69708: NOT
69709: IFFALSE 69824
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69711: LD_ADDR_EXP 53
69715: PUSH
69716: LD_EXP 53
69720: PPUSH
69721: LD_VAR 0 1
69725: PUSH
69726: LD_EXP 53
69730: PUSH
69731: LD_VAR 0 1
69735: ARRAY
69736: PUSH
69737: LD_INT 1
69739: PLUS
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PPUSH
69745: LD_VAR 0 9
69749: PPUSH
69750: CALL 14797 0 3
69754: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
69755: LD_ADDR_EXP 52
69759: PUSH
69760: LD_EXP 52
69764: PPUSH
69765: LD_VAR 0 1
69769: PPUSH
69770: LD_EXP 52
69774: PUSH
69775: LD_VAR 0 1
69779: ARRAY
69780: PUSH
69781: LD_VAR 0 9
69785: DIFF
69786: PPUSH
69787: CALL_OW 1
69791: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
69792: LD_VAR 0 3
69796: PPUSH
69797: LD_EXP 53
69801: PUSH
69802: LD_VAR 0 1
69806: ARRAY
69807: PUSH
69808: LD_EXP 53
69812: PUSH
69813: LD_VAR 0 1
69817: ARRAY
69818: ARRAY
69819: PPUSH
69820: CALL_OW 120
// end ; exit ;
69824: GO 70145
// end ; if tmp > 1 then
69826: LD_VAR 0 8
69830: PUSH
69831: LD_INT 1
69833: GREATER
69834: IFFALSE 69938
// for i = 2 to tmp do
69836: LD_ADDR_VAR 0 6
69840: PUSH
69841: DOUBLE
69842: LD_INT 2
69844: DEC
69845: ST_TO_ADDR
69846: LD_VAR 0 8
69850: PUSH
69851: FOR_TO
69852: IFFALSE 69936
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
69854: LD_VAR 0 8
69858: PUSH
69859: LD_VAR 0 6
69863: ARRAY
69864: PPUSH
69865: CALL_OW 461
69869: PUSH
69870: LD_INT 6
69872: EQUAL
69873: IFFALSE 69934
// begin x := tmp [ i ] ;
69875: LD_ADDR_VAR 0 9
69879: PUSH
69880: LD_VAR 0 8
69884: PUSH
69885: LD_VAR 0 6
69889: ARRAY
69890: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
69891: LD_ADDR_VAR 0 8
69895: PUSH
69896: LD_VAR 0 8
69900: PPUSH
69901: LD_VAR 0 6
69905: PPUSH
69906: CALL_OW 3
69910: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
69911: LD_ADDR_VAR 0 8
69915: PUSH
69916: LD_VAR 0 8
69920: PPUSH
69921: LD_INT 1
69923: PPUSH
69924: LD_VAR 0 9
69928: PPUSH
69929: CALL_OW 2
69933: ST_TO_ADDR
// end ;
69934: GO 69851
69936: POP
69937: POP
// for i in tmp do
69938: LD_ADDR_VAR 0 6
69942: PUSH
69943: LD_VAR 0 8
69947: PUSH
69948: FOR_IN
69949: IFFALSE 70018
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
69951: LD_VAR 0 6
69955: PPUSH
69956: CALL_OW 313
69960: PUSH
69961: LD_INT 6
69963: LESS
69964: PUSH
69965: LD_VAR 0 6
69969: PPUSH
69970: CALL_OW 266
69974: PUSH
69975: LD_INT 31
69977: PUSH
69978: LD_INT 32
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: IN
69985: NOT
69986: AND
69987: PUSH
69988: LD_VAR 0 6
69992: PPUSH
69993: CALL_OW 313
69997: PUSH
69998: LD_INT 0
70000: EQUAL
70001: OR
70002: IFFALSE 70016
// begin j := i ;
70004: LD_ADDR_VAR 0 7
70008: PUSH
70009: LD_VAR 0 6
70013: ST_TO_ADDR
// break ;
70014: GO 70018
// end ; end ;
70016: GO 69948
70018: POP
70019: POP
// if j then
70020: LD_VAR 0 7
70024: IFFALSE 70042
// ComEnterUnit ( unit , j ) else
70026: LD_VAR 0 3
70030: PPUSH
70031: LD_VAR 0 7
70035: PPUSH
70036: CALL_OW 120
70040: GO 70145
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70042: LD_ADDR_VAR 0 10
70046: PUSH
70047: LD_VAR 0 2
70051: PPUSH
70052: LD_INT 2
70054: PUSH
70055: LD_INT 30
70057: PUSH
70058: LD_INT 0
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 30
70067: PUSH
70068: LD_INT 1
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: LIST
70079: PPUSH
70080: CALL_OW 72
70084: ST_TO_ADDR
// if depot then
70085: LD_VAR 0 10
70089: IFFALSE 70145
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70091: LD_ADDR_VAR 0 10
70095: PUSH
70096: LD_VAR 0 10
70100: PPUSH
70101: LD_VAR 0 3
70105: PPUSH
70106: CALL_OW 74
70110: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70111: LD_VAR 0 3
70115: PPUSH
70116: LD_VAR 0 10
70120: PPUSH
70121: CALL_OW 296
70125: PUSH
70126: LD_INT 10
70128: GREATER
70129: IFFALSE 70145
// ComStandNearbyBuilding ( unit , depot ) ;
70131: LD_VAR 0 3
70135: PPUSH
70136: LD_VAR 0 10
70140: PPUSH
70141: CALL 11411 0 2
// end ; end ; end ;
70145: LD_VAR 0 5
70149: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70150: LD_INT 0
70152: PPUSH
70153: PPUSH
70154: PPUSH
70155: PPUSH
// if not mc_bases then
70156: LD_EXP 43
70160: NOT
70161: IFFALSE 70165
// exit ;
70163: GO 70404
// for i = 1 to mc_bases do
70165: LD_ADDR_VAR 0 2
70169: PUSH
70170: DOUBLE
70171: LD_INT 1
70173: DEC
70174: ST_TO_ADDR
70175: LD_EXP 43
70179: PUSH
70180: FOR_TO
70181: IFFALSE 70402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70183: LD_ADDR_VAR 0 4
70187: PUSH
70188: LD_EXP 43
70192: PUSH
70193: LD_VAR 0 2
70197: ARRAY
70198: PPUSH
70199: LD_INT 21
70201: PUSH
70202: LD_INT 1
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PPUSH
70209: CALL_OW 72
70213: PUSH
70214: LD_EXP 72
70218: PUSH
70219: LD_VAR 0 2
70223: ARRAY
70224: UNION
70225: ST_TO_ADDR
// if not tmp then
70226: LD_VAR 0 4
70230: NOT
70231: IFFALSE 70235
// continue ;
70233: GO 70180
// for j in tmp do
70235: LD_ADDR_VAR 0 3
70239: PUSH
70240: LD_VAR 0 4
70244: PUSH
70245: FOR_IN
70246: IFFALSE 70398
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70248: LD_VAR 0 3
70252: PPUSH
70253: CALL_OW 110
70257: NOT
70258: PUSH
70259: LD_VAR 0 3
70263: PPUSH
70264: CALL_OW 314
70268: NOT
70269: AND
70270: PUSH
70271: LD_VAR 0 3
70275: PPUSH
70276: CALL_OW 311
70280: NOT
70281: AND
70282: PUSH
70283: LD_VAR 0 3
70287: PPUSH
70288: CALL_OW 310
70292: NOT
70293: AND
70294: PUSH
70295: LD_VAR 0 3
70299: PUSH
70300: LD_EXP 46
70304: PUSH
70305: LD_VAR 0 2
70309: ARRAY
70310: PUSH
70311: LD_INT 1
70313: ARRAY
70314: IN
70315: NOT
70316: AND
70317: PUSH
70318: LD_VAR 0 3
70322: PUSH
70323: LD_EXP 46
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PUSH
70334: LD_INT 2
70336: ARRAY
70337: IN
70338: NOT
70339: AND
70340: PUSH
70341: LD_VAR 0 3
70345: PUSH
70346: LD_EXP 55
70350: PUSH
70351: LD_VAR 0 2
70355: ARRAY
70356: IN
70357: NOT
70358: AND
70359: IFFALSE 70396
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70361: LD_VAR 0 2
70365: PPUSH
70366: LD_EXP 43
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: PPUSH
70377: LD_VAR 0 3
70381: PPUSH
70382: LD_VAR 0 3
70386: PPUSH
70387: CALL_OW 257
70391: PPUSH
70392: CALL 69168 0 4
// end ;
70396: GO 70245
70398: POP
70399: POP
// end ;
70400: GO 70180
70402: POP
70403: POP
// end ;
70404: LD_VAR 0 1
70408: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70409: LD_INT 0
70411: PPUSH
70412: PPUSH
70413: PPUSH
70414: PPUSH
70415: PPUSH
70416: PPUSH
// if not mc_bases [ base ] then
70417: LD_EXP 43
70421: PUSH
70422: LD_VAR 0 1
70426: ARRAY
70427: NOT
70428: IFFALSE 70432
// exit ;
70430: GO 70614
// tmp := [ ] ;
70432: LD_ADDR_VAR 0 6
70436: PUSH
70437: EMPTY
70438: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70439: LD_ADDR_VAR 0 7
70443: PUSH
70444: LD_VAR 0 3
70448: PPUSH
70449: LD_INT 0
70451: PPUSH
70452: CALL_OW 517
70456: ST_TO_ADDR
// if not list then
70457: LD_VAR 0 7
70461: NOT
70462: IFFALSE 70466
// exit ;
70464: GO 70614
// for i = 1 to amount do
70466: LD_ADDR_VAR 0 5
70470: PUSH
70471: DOUBLE
70472: LD_INT 1
70474: DEC
70475: ST_TO_ADDR
70476: LD_VAR 0 2
70480: PUSH
70481: FOR_TO
70482: IFFALSE 70562
// begin x := rand ( 1 , list [ 1 ] ) ;
70484: LD_ADDR_VAR 0 8
70488: PUSH
70489: LD_INT 1
70491: PPUSH
70492: LD_VAR 0 7
70496: PUSH
70497: LD_INT 1
70499: ARRAY
70500: PPUSH
70501: CALL_OW 12
70505: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70506: LD_ADDR_VAR 0 6
70510: PUSH
70511: LD_VAR 0 6
70515: PPUSH
70516: LD_VAR 0 5
70520: PPUSH
70521: LD_VAR 0 7
70525: PUSH
70526: LD_INT 1
70528: ARRAY
70529: PUSH
70530: LD_VAR 0 8
70534: ARRAY
70535: PUSH
70536: LD_VAR 0 7
70540: PUSH
70541: LD_INT 2
70543: ARRAY
70544: PUSH
70545: LD_VAR 0 8
70549: ARRAY
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PPUSH
70555: CALL_OW 1
70559: ST_TO_ADDR
// end ;
70560: GO 70481
70562: POP
70563: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70564: LD_ADDR_EXP 56
70568: PUSH
70569: LD_EXP 56
70573: PPUSH
70574: LD_VAR 0 1
70578: PPUSH
70579: LD_VAR 0 6
70583: PPUSH
70584: CALL_OW 1
70588: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70589: LD_ADDR_EXP 58
70593: PUSH
70594: LD_EXP 58
70598: PPUSH
70599: LD_VAR 0 1
70603: PPUSH
70604: LD_VAR 0 3
70608: PPUSH
70609: CALL_OW 1
70613: ST_TO_ADDR
// end ;
70614: LD_VAR 0 4
70618: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70619: LD_INT 0
70621: PPUSH
// if not mc_bases [ base ] then
70622: LD_EXP 43
70626: PUSH
70627: LD_VAR 0 1
70631: ARRAY
70632: NOT
70633: IFFALSE 70637
// exit ;
70635: GO 70662
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70637: LD_ADDR_EXP 48
70641: PUSH
70642: LD_EXP 48
70646: PPUSH
70647: LD_VAR 0 1
70651: PPUSH
70652: LD_VAR 0 2
70656: PPUSH
70657: CALL_OW 1
70661: ST_TO_ADDR
// end ;
70662: LD_VAR 0 3
70666: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70667: LD_INT 0
70669: PPUSH
// if not mc_bases [ base ] then
70670: LD_EXP 43
70674: PUSH
70675: LD_VAR 0 1
70679: ARRAY
70680: NOT
70681: IFFALSE 70685
// exit ;
70683: GO 70722
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70685: LD_ADDR_EXP 48
70689: PUSH
70690: LD_EXP 48
70694: PPUSH
70695: LD_VAR 0 1
70699: PPUSH
70700: LD_EXP 48
70704: PUSH
70705: LD_VAR 0 1
70709: ARRAY
70710: PUSH
70711: LD_VAR 0 2
70715: UNION
70716: PPUSH
70717: CALL_OW 1
70721: ST_TO_ADDR
// end ;
70722: LD_VAR 0 3
70726: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70727: LD_INT 0
70729: PPUSH
// if not mc_bases [ base ] then
70730: LD_EXP 43
70734: PUSH
70735: LD_VAR 0 1
70739: ARRAY
70740: NOT
70741: IFFALSE 70745
// exit ;
70743: GO 70770
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70745: LD_ADDR_EXP 64
70749: PUSH
70750: LD_EXP 64
70754: PPUSH
70755: LD_VAR 0 1
70759: PPUSH
70760: LD_VAR 0 2
70764: PPUSH
70765: CALL_OW 1
70769: ST_TO_ADDR
// end ;
70770: LD_VAR 0 3
70774: RET
// export function MC_InsertProduceList ( base , components ) ; begin
70775: LD_INT 0
70777: PPUSH
// if not mc_bases [ base ] then
70778: LD_EXP 43
70782: PUSH
70783: LD_VAR 0 1
70787: ARRAY
70788: NOT
70789: IFFALSE 70793
// exit ;
70791: GO 70830
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
70793: LD_ADDR_EXP 64
70797: PUSH
70798: LD_EXP 64
70802: PPUSH
70803: LD_VAR 0 1
70807: PPUSH
70808: LD_EXP 64
70812: PUSH
70813: LD_VAR 0 1
70817: ARRAY
70818: PUSH
70819: LD_VAR 0 2
70823: ADD
70824: PPUSH
70825: CALL_OW 1
70829: ST_TO_ADDR
// end ;
70830: LD_VAR 0 3
70834: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
70835: LD_INT 0
70837: PPUSH
// if not mc_bases [ base ] then
70838: LD_EXP 43
70842: PUSH
70843: LD_VAR 0 1
70847: ARRAY
70848: NOT
70849: IFFALSE 70853
// exit ;
70851: GO 70907
// mc_defender := Replace ( mc_defender , base , deflist ) ;
70853: LD_ADDR_EXP 65
70857: PUSH
70858: LD_EXP 65
70862: PPUSH
70863: LD_VAR 0 1
70867: PPUSH
70868: LD_VAR 0 2
70872: PPUSH
70873: CALL_OW 1
70877: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
70878: LD_ADDR_EXP 54
70882: PUSH
70883: LD_EXP 54
70887: PPUSH
70888: LD_VAR 0 1
70892: PPUSH
70893: LD_VAR 0 2
70897: PUSH
70898: LD_INT 0
70900: PLUS
70901: PPUSH
70902: CALL_OW 1
70906: ST_TO_ADDR
// end ;
70907: LD_VAR 0 3
70911: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
70912: LD_INT 0
70914: PPUSH
// if not mc_bases [ base ] then
70915: LD_EXP 43
70919: PUSH
70920: LD_VAR 0 1
70924: ARRAY
70925: NOT
70926: IFFALSE 70930
// exit ;
70928: GO 70955
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
70930: LD_ADDR_EXP 54
70934: PUSH
70935: LD_EXP 54
70939: PPUSH
70940: LD_VAR 0 1
70944: PPUSH
70945: LD_VAR 0 2
70949: PPUSH
70950: CALL_OW 1
70954: ST_TO_ADDR
// end ;
70955: LD_VAR 0 3
70959: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
70960: LD_INT 0
70962: PPUSH
70963: PPUSH
70964: PPUSH
70965: PPUSH
// if not mc_bases [ base ] then
70966: LD_EXP 43
70970: PUSH
70971: LD_VAR 0 1
70975: ARRAY
70976: NOT
70977: IFFALSE 70981
// exit ;
70979: GO 71046
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
70981: LD_ADDR_EXP 63
70985: PUSH
70986: LD_EXP 63
70990: PPUSH
70991: LD_VAR 0 1
70995: PUSH
70996: LD_EXP 63
71000: PUSH
71001: LD_VAR 0 1
71005: ARRAY
71006: PUSH
71007: LD_INT 1
71009: PLUS
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PPUSH
71015: LD_VAR 0 1
71019: PUSH
71020: LD_VAR 0 2
71024: PUSH
71025: LD_VAR 0 3
71029: PUSH
71030: LD_VAR 0 4
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: PPUSH
71041: CALL 14797 0 3
71045: ST_TO_ADDR
// end ;
71046: LD_VAR 0 5
71050: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71051: LD_INT 0
71053: PPUSH
// if not mc_bases [ base ] then
71054: LD_EXP 43
71058: PUSH
71059: LD_VAR 0 1
71063: ARRAY
71064: NOT
71065: IFFALSE 71069
// exit ;
71067: GO 71094
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71069: LD_ADDR_EXP 80
71073: PUSH
71074: LD_EXP 80
71078: PPUSH
71079: LD_VAR 0 1
71083: PPUSH
71084: LD_VAR 0 2
71088: PPUSH
71089: CALL_OW 1
71093: ST_TO_ADDR
// end ;
71094: LD_VAR 0 3
71098: RET
// export function MC_GetMinesField ( base ) ; begin
71099: LD_INT 0
71101: PPUSH
// result := mc_mines [ base ] ;
71102: LD_ADDR_VAR 0 2
71106: PUSH
71107: LD_EXP 56
71111: PUSH
71112: LD_VAR 0 1
71116: ARRAY
71117: ST_TO_ADDR
// end ;
71118: LD_VAR 0 2
71122: RET
// export function MC_GetProduceList ( base ) ; begin
71123: LD_INT 0
71125: PPUSH
// result := mc_produce [ base ] ;
71126: LD_ADDR_VAR 0 2
71130: PUSH
71131: LD_EXP 64
71135: PUSH
71136: LD_VAR 0 1
71140: ARRAY
71141: ST_TO_ADDR
// end ;
71142: LD_VAR 0 2
71146: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71147: LD_INT 0
71149: PPUSH
71150: PPUSH
// if not mc_bases then
71151: LD_EXP 43
71155: NOT
71156: IFFALSE 71160
// exit ;
71158: GO 71225
// if mc_bases [ base ] then
71160: LD_EXP 43
71164: PUSH
71165: LD_VAR 0 1
71169: ARRAY
71170: IFFALSE 71225
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71172: LD_ADDR_VAR 0 3
71176: PUSH
71177: LD_EXP 43
71181: PUSH
71182: LD_VAR 0 1
71186: ARRAY
71187: PPUSH
71188: LD_INT 30
71190: PUSH
71191: LD_VAR 0 2
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PPUSH
71200: CALL_OW 72
71204: ST_TO_ADDR
// if result then
71205: LD_VAR 0 3
71209: IFFALSE 71225
// result := result [ 1 ] ;
71211: LD_ADDR_VAR 0 3
71215: PUSH
71216: LD_VAR 0 3
71220: PUSH
71221: LD_INT 1
71223: ARRAY
71224: ST_TO_ADDR
// end ; end ;
71225: LD_VAR 0 3
71229: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71230: LD_INT 0
71232: PPUSH
71233: PPUSH
// if not mc_bases then
71234: LD_EXP 43
71238: NOT
71239: IFFALSE 71243
// exit ;
71241: GO 71288
// if mc_bases [ base ] then
71243: LD_EXP 43
71247: PUSH
71248: LD_VAR 0 1
71252: ARRAY
71253: IFFALSE 71288
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71255: LD_ADDR_VAR 0 3
71259: PUSH
71260: LD_EXP 43
71264: PUSH
71265: LD_VAR 0 1
71269: ARRAY
71270: PPUSH
71271: LD_INT 30
71273: PUSH
71274: LD_VAR 0 2
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PPUSH
71283: CALL_OW 72
71287: ST_TO_ADDR
// end ;
71288: LD_VAR 0 3
71292: RET
// export function MC_SetTame ( base , area ) ; begin
71293: LD_INT 0
71295: PPUSH
// if not mc_bases or not base then
71296: LD_EXP 43
71300: NOT
71301: PUSH
71302: LD_VAR 0 1
71306: NOT
71307: OR
71308: IFFALSE 71312
// exit ;
71310: GO 71337
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71312: LD_ADDR_EXP 71
71316: PUSH
71317: LD_EXP 71
71321: PPUSH
71322: LD_VAR 0 1
71326: PPUSH
71327: LD_VAR 0 2
71331: PPUSH
71332: CALL_OW 1
71336: ST_TO_ADDR
// end ;
71337: LD_VAR 0 3
71341: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71342: LD_INT 0
71344: PPUSH
71345: PPUSH
// if not mc_bases or not base then
71346: LD_EXP 43
71350: NOT
71351: PUSH
71352: LD_VAR 0 1
71356: NOT
71357: OR
71358: IFFALSE 71362
// exit ;
71360: GO 71464
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71362: LD_ADDR_VAR 0 4
71366: PUSH
71367: LD_EXP 43
71371: PUSH
71372: LD_VAR 0 1
71376: ARRAY
71377: PPUSH
71378: LD_INT 30
71380: PUSH
71381: LD_VAR 0 2
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PPUSH
71390: CALL_OW 72
71394: ST_TO_ADDR
// if not tmp then
71395: LD_VAR 0 4
71399: NOT
71400: IFFALSE 71404
// exit ;
71402: GO 71464
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71404: LD_ADDR_EXP 75
71408: PUSH
71409: LD_EXP 75
71413: PPUSH
71414: LD_VAR 0 1
71418: PPUSH
71419: LD_EXP 75
71423: PUSH
71424: LD_VAR 0 1
71428: ARRAY
71429: PPUSH
71430: LD_EXP 75
71434: PUSH
71435: LD_VAR 0 1
71439: ARRAY
71440: PUSH
71441: LD_INT 1
71443: PLUS
71444: PPUSH
71445: LD_VAR 0 4
71449: PUSH
71450: LD_INT 1
71452: ARRAY
71453: PPUSH
71454: CALL_OW 2
71458: PPUSH
71459: CALL_OW 1
71463: ST_TO_ADDR
// end ;
71464: LD_VAR 0 3
71468: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71469: LD_INT 0
71471: PPUSH
71472: PPUSH
// if not mc_bases or not base or not kinds then
71473: LD_EXP 43
71477: NOT
71478: PUSH
71479: LD_VAR 0 1
71483: NOT
71484: OR
71485: PUSH
71486: LD_VAR 0 2
71490: NOT
71491: OR
71492: IFFALSE 71496
// exit ;
71494: GO 71557
// for i in kinds do
71496: LD_ADDR_VAR 0 4
71500: PUSH
71501: LD_VAR 0 2
71505: PUSH
71506: FOR_IN
71507: IFFALSE 71555
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71509: LD_ADDR_EXP 77
71513: PUSH
71514: LD_EXP 77
71518: PPUSH
71519: LD_VAR 0 1
71523: PUSH
71524: LD_EXP 77
71528: PUSH
71529: LD_VAR 0 1
71533: ARRAY
71534: PUSH
71535: LD_INT 1
71537: PLUS
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PPUSH
71543: LD_VAR 0 4
71547: PPUSH
71548: CALL 14797 0 3
71552: ST_TO_ADDR
71553: GO 71506
71555: POP
71556: POP
// end ;
71557: LD_VAR 0 3
71561: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71562: LD_INT 0
71564: PPUSH
// if not mc_bases or not base or not areas then
71565: LD_EXP 43
71569: NOT
71570: PUSH
71571: LD_VAR 0 1
71575: NOT
71576: OR
71577: PUSH
71578: LD_VAR 0 2
71582: NOT
71583: OR
71584: IFFALSE 71588
// exit ;
71586: GO 71613
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71588: LD_ADDR_EXP 61
71592: PUSH
71593: LD_EXP 61
71597: PPUSH
71598: LD_VAR 0 1
71602: PPUSH
71603: LD_VAR 0 2
71607: PPUSH
71608: CALL_OW 1
71612: ST_TO_ADDR
// end ;
71613: LD_VAR 0 3
71617: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71618: LD_INT 0
71620: PPUSH
// if not mc_bases or not base or not teleports_exit then
71621: LD_EXP 43
71625: NOT
71626: PUSH
71627: LD_VAR 0 1
71631: NOT
71632: OR
71633: PUSH
71634: LD_VAR 0 2
71638: NOT
71639: OR
71640: IFFALSE 71644
// exit ;
71642: GO 71669
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71644: LD_ADDR_EXP 78
71648: PUSH
71649: LD_EXP 78
71653: PPUSH
71654: LD_VAR 0 1
71658: PPUSH
71659: LD_VAR 0 2
71663: PPUSH
71664: CALL_OW 1
71668: ST_TO_ADDR
// end ;
71669: LD_VAR 0 3
71673: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71674: LD_INT 0
71676: PPUSH
71677: PPUSH
71678: PPUSH
// if not mc_bases or not base or not ext_list then
71679: LD_EXP 43
71683: NOT
71684: PUSH
71685: LD_VAR 0 1
71689: NOT
71690: OR
71691: PUSH
71692: LD_VAR 0 5
71696: NOT
71697: OR
71698: IFFALSE 71702
// exit ;
71700: GO 71875
// tmp := GetFacExtXYD ( x , y , d ) ;
71702: LD_ADDR_VAR 0 8
71706: PUSH
71707: LD_VAR 0 2
71711: PPUSH
71712: LD_VAR 0 3
71716: PPUSH
71717: LD_VAR 0 4
71721: PPUSH
71722: CALL 43476 0 3
71726: ST_TO_ADDR
// if not tmp then
71727: LD_VAR 0 8
71731: NOT
71732: IFFALSE 71736
// exit ;
71734: GO 71875
// for i in tmp do
71736: LD_ADDR_VAR 0 7
71740: PUSH
71741: LD_VAR 0 8
71745: PUSH
71746: FOR_IN
71747: IFFALSE 71873
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
71749: LD_ADDR_EXP 48
71753: PUSH
71754: LD_EXP 48
71758: PPUSH
71759: LD_VAR 0 1
71763: PPUSH
71764: LD_EXP 48
71768: PUSH
71769: LD_VAR 0 1
71773: ARRAY
71774: PPUSH
71775: LD_EXP 48
71779: PUSH
71780: LD_VAR 0 1
71784: ARRAY
71785: PUSH
71786: LD_INT 1
71788: PLUS
71789: PPUSH
71790: LD_VAR 0 5
71794: PUSH
71795: LD_INT 1
71797: ARRAY
71798: PUSH
71799: LD_VAR 0 7
71803: PUSH
71804: LD_INT 1
71806: ARRAY
71807: PUSH
71808: LD_VAR 0 7
71812: PUSH
71813: LD_INT 2
71815: ARRAY
71816: PUSH
71817: LD_VAR 0 7
71821: PUSH
71822: LD_INT 3
71824: ARRAY
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: PPUSH
71832: CALL_OW 2
71836: PPUSH
71837: CALL_OW 1
71841: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
71842: LD_ADDR_VAR 0 5
71846: PUSH
71847: LD_VAR 0 5
71851: PPUSH
71852: LD_INT 1
71854: PPUSH
71855: CALL_OW 3
71859: ST_TO_ADDR
// if not ext_list then
71860: LD_VAR 0 5
71864: NOT
71865: IFFALSE 71871
// exit ;
71867: POP
71868: POP
71869: GO 71875
// end ;
71871: GO 71746
71873: POP
71874: POP
// end ;
71875: LD_VAR 0 6
71879: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
71880: LD_INT 0
71882: PPUSH
// if not mc_bases or not base or not weapon_list then
71883: LD_EXP 43
71887: NOT
71888: PUSH
71889: LD_VAR 0 1
71893: NOT
71894: OR
71895: PUSH
71896: LD_VAR 0 2
71900: NOT
71901: OR
71902: IFFALSE 71906
// exit ;
71904: GO 71931
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
71906: LD_ADDR_EXP 82
71910: PUSH
71911: LD_EXP 82
71915: PPUSH
71916: LD_VAR 0 1
71920: PPUSH
71921: LD_VAR 0 2
71925: PPUSH
71926: CALL_OW 1
71930: ST_TO_ADDR
// end ;
71931: LD_VAR 0 3
71935: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
71936: LD_INT 0
71938: PPUSH
// if not mc_bases or not base or not tech_list then
71939: LD_EXP 43
71943: NOT
71944: PUSH
71945: LD_VAR 0 1
71949: NOT
71950: OR
71951: PUSH
71952: LD_VAR 0 2
71956: NOT
71957: OR
71958: IFFALSE 71962
// exit ;
71960: GO 71987
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
71962: LD_ADDR_EXP 70
71966: PUSH
71967: LD_EXP 70
71971: PPUSH
71972: LD_VAR 0 1
71976: PPUSH
71977: LD_VAR 0 2
71981: PPUSH
71982: CALL_OW 1
71986: ST_TO_ADDR
// end ;
71987: LD_VAR 0 3
71991: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
71992: LD_INT 0
71994: PPUSH
// if not mc_bases or not parking_area or not base then
71995: LD_EXP 43
71999: NOT
72000: PUSH
72001: LD_VAR 0 2
72005: NOT
72006: OR
72007: PUSH
72008: LD_VAR 0 1
72012: NOT
72013: OR
72014: IFFALSE 72018
// exit ;
72016: GO 72043
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72018: LD_ADDR_EXP 67
72022: PUSH
72023: LD_EXP 67
72027: PPUSH
72028: LD_VAR 0 1
72032: PPUSH
72033: LD_VAR 0 2
72037: PPUSH
72038: CALL_OW 1
72042: ST_TO_ADDR
// end ;
72043: LD_VAR 0 3
72047: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72048: LD_INT 0
72050: PPUSH
// if not mc_bases or not base or not scan_area then
72051: LD_EXP 43
72055: NOT
72056: PUSH
72057: LD_VAR 0 1
72061: NOT
72062: OR
72063: PUSH
72064: LD_VAR 0 2
72068: NOT
72069: OR
72070: IFFALSE 72074
// exit ;
72072: GO 72099
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72074: LD_ADDR_EXP 68
72078: PUSH
72079: LD_EXP 68
72083: PPUSH
72084: LD_VAR 0 1
72088: PPUSH
72089: LD_VAR 0 2
72093: PPUSH
72094: CALL_OW 1
72098: ST_TO_ADDR
// end ;
72099: LD_VAR 0 3
72103: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72104: LD_INT 0
72106: PPUSH
72107: PPUSH
// if not mc_bases or not base then
72108: LD_EXP 43
72112: NOT
72113: PUSH
72114: LD_VAR 0 1
72118: NOT
72119: OR
72120: IFFALSE 72124
// exit ;
72122: GO 72188
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72124: LD_ADDR_VAR 0 3
72128: PUSH
72129: LD_INT 1
72131: PUSH
72132: LD_INT 2
72134: PUSH
72135: LD_INT 3
72137: PUSH
72138: LD_INT 4
72140: PUSH
72141: LD_INT 11
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72151: LD_ADDR_EXP 70
72155: PUSH
72156: LD_EXP 70
72160: PPUSH
72161: LD_VAR 0 1
72165: PPUSH
72166: LD_EXP 70
72170: PUSH
72171: LD_VAR 0 1
72175: ARRAY
72176: PUSH
72177: LD_VAR 0 3
72181: DIFF
72182: PPUSH
72183: CALL_OW 1
72187: ST_TO_ADDR
// end ;
72188: LD_VAR 0 2
72192: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72193: LD_INT 0
72195: PPUSH
// result := mc_vehicles [ base ] ;
72196: LD_ADDR_VAR 0 3
72200: PUSH
72201: LD_EXP 62
72205: PUSH
72206: LD_VAR 0 1
72210: ARRAY
72211: ST_TO_ADDR
// if onlyCombat then
72212: LD_VAR 0 2
72216: IFFALSE 72394
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72218: LD_ADDR_VAR 0 3
72222: PUSH
72223: LD_VAR 0 3
72227: PUSH
72228: LD_VAR 0 3
72232: PPUSH
72233: LD_INT 2
72235: PUSH
72236: LD_INT 34
72238: PUSH
72239: LD_INT 12
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 34
72248: PUSH
72249: LD_INT 51
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 34
72258: PUSH
72259: LD_EXP 87
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 34
72270: PUSH
72271: LD_INT 32
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: LD_INT 34
72280: PUSH
72281: LD_INT 13
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 34
72290: PUSH
72291: LD_INT 52
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 34
72300: PUSH
72301: LD_EXP 92
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 34
72312: PUSH
72313: LD_INT 14
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 34
72322: PUSH
72323: LD_INT 53
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 34
72332: PUSH
72333: LD_EXP 86
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 34
72344: PUSH
72345: LD_INT 31
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 34
72354: PUSH
72355: LD_INT 48
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 34
72364: PUSH
72365: LD_INT 8
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: PPUSH
72388: CALL_OW 72
72392: DIFF
72393: ST_TO_ADDR
// end ; end_of_file
72394: LD_VAR 0 3
72398: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72399: LD_INT 0
72401: PPUSH
72402: PPUSH
72403: PPUSH
// if not mc_bases or not skirmish then
72404: LD_EXP 43
72408: NOT
72409: PUSH
72410: LD_EXP 41
72414: NOT
72415: OR
72416: IFFALSE 72420
// exit ;
72418: GO 72585
// for i = 1 to mc_bases do
72420: LD_ADDR_VAR 0 4
72424: PUSH
72425: DOUBLE
72426: LD_INT 1
72428: DEC
72429: ST_TO_ADDR
72430: LD_EXP 43
72434: PUSH
72435: FOR_TO
72436: IFFALSE 72583
// begin if sci in mc_bases [ i ] then
72438: LD_VAR 0 2
72442: PUSH
72443: LD_EXP 43
72447: PUSH
72448: LD_VAR 0 4
72452: ARRAY
72453: IN
72454: IFFALSE 72581
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72456: LD_ADDR_EXP 72
72460: PUSH
72461: LD_EXP 72
72465: PPUSH
72466: LD_VAR 0 4
72470: PUSH
72471: LD_EXP 72
72475: PUSH
72476: LD_VAR 0 4
72480: ARRAY
72481: PUSH
72482: LD_INT 1
72484: PLUS
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PPUSH
72490: LD_VAR 0 1
72494: PPUSH
72495: CALL 14797 0 3
72499: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72500: LD_ADDR_VAR 0 5
72504: PUSH
72505: LD_EXP 43
72509: PUSH
72510: LD_VAR 0 4
72514: ARRAY
72515: PPUSH
72516: LD_INT 2
72518: PUSH
72519: LD_INT 30
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 30
72531: PUSH
72532: LD_INT 1
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: LIST
72543: PPUSH
72544: CALL_OW 72
72548: PPUSH
72549: LD_VAR 0 1
72553: PPUSH
72554: CALL_OW 74
72558: ST_TO_ADDR
// if tmp then
72559: LD_VAR 0 5
72563: IFFALSE 72579
// ComStandNearbyBuilding ( ape , tmp ) ;
72565: LD_VAR 0 1
72569: PPUSH
72570: LD_VAR 0 5
72574: PPUSH
72575: CALL 11411 0 2
// break ;
72579: GO 72583
// end ; end ;
72581: GO 72435
72583: POP
72584: POP
// end ;
72585: LD_VAR 0 3
72589: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72590: LD_INT 0
72592: PPUSH
72593: PPUSH
72594: PPUSH
// if not mc_bases or not skirmish then
72595: LD_EXP 43
72599: NOT
72600: PUSH
72601: LD_EXP 41
72605: NOT
72606: OR
72607: IFFALSE 72611
// exit ;
72609: GO 72700
// for i = 1 to mc_bases do
72611: LD_ADDR_VAR 0 4
72615: PUSH
72616: DOUBLE
72617: LD_INT 1
72619: DEC
72620: ST_TO_ADDR
72621: LD_EXP 43
72625: PUSH
72626: FOR_TO
72627: IFFALSE 72698
// begin if building in mc_busy_turret_list [ i ] then
72629: LD_VAR 0 1
72633: PUSH
72634: LD_EXP 53
72638: PUSH
72639: LD_VAR 0 4
72643: ARRAY
72644: IN
72645: IFFALSE 72696
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72647: LD_ADDR_VAR 0 5
72651: PUSH
72652: LD_EXP 53
72656: PUSH
72657: LD_VAR 0 4
72661: ARRAY
72662: PUSH
72663: LD_VAR 0 1
72667: DIFF
72668: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72669: LD_ADDR_EXP 53
72673: PUSH
72674: LD_EXP 53
72678: PPUSH
72679: LD_VAR 0 4
72683: PPUSH
72684: LD_VAR 0 5
72688: PPUSH
72689: CALL_OW 1
72693: ST_TO_ADDR
// break ;
72694: GO 72698
// end ; end ;
72696: GO 72626
72698: POP
72699: POP
// end ;
72700: LD_VAR 0 3
72704: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72705: LD_INT 0
72707: PPUSH
72708: PPUSH
72709: PPUSH
// if not mc_bases or not skirmish then
72710: LD_EXP 43
72714: NOT
72715: PUSH
72716: LD_EXP 41
72720: NOT
72721: OR
72722: IFFALSE 72726
// exit ;
72724: GO 72925
// for i = 1 to mc_bases do
72726: LD_ADDR_VAR 0 5
72730: PUSH
72731: DOUBLE
72732: LD_INT 1
72734: DEC
72735: ST_TO_ADDR
72736: LD_EXP 43
72740: PUSH
72741: FOR_TO
72742: IFFALSE 72923
// if building in mc_bases [ i ] then
72744: LD_VAR 0 1
72748: PUSH
72749: LD_EXP 43
72753: PUSH
72754: LD_VAR 0 5
72758: ARRAY
72759: IN
72760: IFFALSE 72921
// begin tmp := mc_bases [ i ] diff building ;
72762: LD_ADDR_VAR 0 6
72766: PUSH
72767: LD_EXP 43
72771: PUSH
72772: LD_VAR 0 5
72776: ARRAY
72777: PUSH
72778: LD_VAR 0 1
72782: DIFF
72783: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
72784: LD_ADDR_EXP 43
72788: PUSH
72789: LD_EXP 43
72793: PPUSH
72794: LD_VAR 0 5
72798: PPUSH
72799: LD_VAR 0 6
72803: PPUSH
72804: CALL_OW 1
72808: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
72809: LD_VAR 0 1
72813: PUSH
72814: LD_EXP 51
72818: PUSH
72819: LD_VAR 0 5
72823: ARRAY
72824: IN
72825: IFFALSE 72864
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
72827: LD_ADDR_EXP 51
72831: PUSH
72832: LD_EXP 51
72836: PPUSH
72837: LD_VAR 0 5
72841: PPUSH
72842: LD_EXP 51
72846: PUSH
72847: LD_VAR 0 5
72851: ARRAY
72852: PUSH
72853: LD_VAR 0 1
72857: DIFF
72858: PPUSH
72859: CALL_OW 1
72863: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
72864: LD_VAR 0 1
72868: PUSH
72869: LD_EXP 52
72873: PUSH
72874: LD_VAR 0 5
72878: ARRAY
72879: IN
72880: IFFALSE 72919
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
72882: LD_ADDR_EXP 52
72886: PUSH
72887: LD_EXP 52
72891: PPUSH
72892: LD_VAR 0 5
72896: PPUSH
72897: LD_EXP 52
72901: PUSH
72902: LD_VAR 0 5
72906: ARRAY
72907: PUSH
72908: LD_VAR 0 1
72912: DIFF
72913: PPUSH
72914: CALL_OW 1
72918: ST_TO_ADDR
// break ;
72919: GO 72923
// end ;
72921: GO 72741
72923: POP
72924: POP
// end ;
72925: LD_VAR 0 4
72929: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
72930: LD_INT 0
72932: PPUSH
72933: PPUSH
72934: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
72935: LD_EXP 43
72939: NOT
72940: PUSH
72941: LD_EXP 41
72945: NOT
72946: OR
72947: PUSH
72948: LD_VAR 0 3
72952: PUSH
72953: LD_EXP 69
72957: IN
72958: NOT
72959: OR
72960: IFFALSE 72964
// exit ;
72962: GO 73087
// for i = 1 to mc_vehicles do
72964: LD_ADDR_VAR 0 6
72968: PUSH
72969: DOUBLE
72970: LD_INT 1
72972: DEC
72973: ST_TO_ADDR
72974: LD_EXP 62
72978: PUSH
72979: FOR_TO
72980: IFFALSE 73085
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
72982: LD_VAR 0 2
72986: PUSH
72987: LD_EXP 62
72991: PUSH
72992: LD_VAR 0 6
72996: ARRAY
72997: IN
72998: PUSH
72999: LD_VAR 0 1
73003: PUSH
73004: LD_EXP 62
73008: PUSH
73009: LD_VAR 0 6
73013: ARRAY
73014: IN
73015: OR
73016: IFFALSE 73083
// begin tmp := mc_vehicles [ i ] diff old ;
73018: LD_ADDR_VAR 0 7
73022: PUSH
73023: LD_EXP 62
73027: PUSH
73028: LD_VAR 0 6
73032: ARRAY
73033: PUSH
73034: LD_VAR 0 2
73038: DIFF
73039: ST_TO_ADDR
// tmp := tmp diff new ;
73040: LD_ADDR_VAR 0 7
73044: PUSH
73045: LD_VAR 0 7
73049: PUSH
73050: LD_VAR 0 1
73054: DIFF
73055: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73056: LD_ADDR_EXP 62
73060: PUSH
73061: LD_EXP 62
73065: PPUSH
73066: LD_VAR 0 6
73070: PPUSH
73071: LD_VAR 0 7
73075: PPUSH
73076: CALL_OW 1
73080: ST_TO_ADDR
// break ;
73081: GO 73085
// end ;
73083: GO 72979
73085: POP
73086: POP
// end ;
73087: LD_VAR 0 5
73091: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73092: LD_INT 0
73094: PPUSH
73095: PPUSH
73096: PPUSH
73097: PPUSH
// if not mc_bases or not skirmish then
73098: LD_EXP 43
73102: NOT
73103: PUSH
73104: LD_EXP 41
73108: NOT
73109: OR
73110: IFFALSE 73114
// exit ;
73112: GO 73497
// side := GetSide ( vehicle ) ;
73114: LD_ADDR_VAR 0 5
73118: PUSH
73119: LD_VAR 0 1
73123: PPUSH
73124: CALL_OW 255
73128: ST_TO_ADDR
// for i = 1 to mc_bases do
73129: LD_ADDR_VAR 0 4
73133: PUSH
73134: DOUBLE
73135: LD_INT 1
73137: DEC
73138: ST_TO_ADDR
73139: LD_EXP 43
73143: PUSH
73144: FOR_TO
73145: IFFALSE 73495
// begin if factory in mc_bases [ i ] then
73147: LD_VAR 0 2
73151: PUSH
73152: LD_EXP 43
73156: PUSH
73157: LD_VAR 0 4
73161: ARRAY
73162: IN
73163: IFFALSE 73493
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73165: LD_EXP 65
73169: PUSH
73170: LD_VAR 0 4
73174: ARRAY
73175: PUSH
73176: LD_EXP 54
73180: PUSH
73181: LD_VAR 0 4
73185: ARRAY
73186: LESS
73187: PUSH
73188: LD_VAR 0 1
73192: PPUSH
73193: CALL_OW 264
73197: PUSH
73198: LD_INT 31
73200: PUSH
73201: LD_INT 32
73203: PUSH
73204: LD_INT 51
73206: PUSH
73207: LD_EXP 87
73211: PUSH
73212: LD_INT 12
73214: PUSH
73215: LD_INT 30
73217: PUSH
73218: LD_EXP 86
73222: PUSH
73223: LD_INT 11
73225: PUSH
73226: LD_INT 53
73228: PUSH
73229: LD_INT 14
73231: PUSH
73232: LD_EXP 90
73236: PUSH
73237: LD_INT 29
73239: PUSH
73240: LD_EXP 88
73244: PUSH
73245: LD_INT 13
73247: PUSH
73248: LD_INT 52
73250: PUSH
73251: LD_EXP 92
73255: PUSH
73256: LD_INT 48
73258: PUSH
73259: LD_INT 8
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: IN
73282: NOT
73283: AND
73284: IFFALSE 73332
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73286: LD_ADDR_EXP 65
73290: PUSH
73291: LD_EXP 65
73295: PPUSH
73296: LD_VAR 0 4
73300: PUSH
73301: LD_EXP 65
73305: PUSH
73306: LD_VAR 0 4
73310: ARRAY
73311: PUSH
73312: LD_INT 1
73314: PLUS
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PPUSH
73320: LD_VAR 0 1
73324: PPUSH
73325: CALL 14797 0 3
73329: ST_TO_ADDR
73330: GO 73376
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73332: LD_ADDR_EXP 62
73336: PUSH
73337: LD_EXP 62
73341: PPUSH
73342: LD_VAR 0 4
73346: PUSH
73347: LD_EXP 62
73351: PUSH
73352: LD_VAR 0 4
73356: ARRAY
73357: PUSH
73358: LD_INT 1
73360: PLUS
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PPUSH
73366: LD_VAR 0 1
73370: PPUSH
73371: CALL 14797 0 3
73375: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73376: LD_VAR 0 1
73380: PPUSH
73381: CALL_OW 263
73385: PUSH
73386: LD_INT 2
73388: EQUAL
73389: IFFALSE 73409
// begin repeat wait ( 0 0$1 ) ;
73391: LD_INT 35
73393: PPUSH
73394: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73398: LD_VAR 0 1
73402: PPUSH
73403: CALL_OW 312
73407: IFFALSE 73391
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73409: LD_VAR 0 1
73413: PPUSH
73414: LD_EXP 67
73418: PUSH
73419: LD_VAR 0 4
73423: ARRAY
73424: PPUSH
73425: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73429: LD_VAR 0 1
73433: PPUSH
73434: CALL_OW 263
73438: PUSH
73439: LD_INT 1
73441: NONEQUAL
73442: IFFALSE 73446
// break ;
73444: GO 73495
// repeat wait ( 0 0$1 ) ;
73446: LD_INT 35
73448: PPUSH
73449: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73453: LD_VAR 0 1
73457: PPUSH
73458: LD_EXP 67
73462: PUSH
73463: LD_VAR 0 4
73467: ARRAY
73468: PPUSH
73469: CALL_OW 308
73473: IFFALSE 73446
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73475: LD_VAR 0 1
73479: PPUSH
73480: CALL_OW 311
73484: PPUSH
73485: CALL_OW 121
// exit ;
73489: POP
73490: POP
73491: GO 73497
// end ; end ;
73493: GO 73144
73495: POP
73496: POP
// end ;
73497: LD_VAR 0 3
73501: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73502: LD_INT 0
73504: PPUSH
73505: PPUSH
73506: PPUSH
73507: PPUSH
// if not mc_bases or not skirmish then
73508: LD_EXP 43
73512: NOT
73513: PUSH
73514: LD_EXP 41
73518: NOT
73519: OR
73520: IFFALSE 73524
// exit ;
73522: GO 73877
// repeat wait ( 0 0$1 ) ;
73524: LD_INT 35
73526: PPUSH
73527: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73531: LD_VAR 0 2
73535: PPUSH
73536: LD_VAR 0 3
73540: PPUSH
73541: CALL_OW 284
73545: IFFALSE 73524
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73547: LD_VAR 0 2
73551: PPUSH
73552: LD_VAR 0 3
73556: PPUSH
73557: CALL_OW 283
73561: PUSH
73562: LD_INT 4
73564: EQUAL
73565: IFFALSE 73569
// exit ;
73567: GO 73877
// for i = 1 to mc_bases do
73569: LD_ADDR_VAR 0 7
73573: PUSH
73574: DOUBLE
73575: LD_INT 1
73577: DEC
73578: ST_TO_ADDR
73579: LD_EXP 43
73583: PUSH
73584: FOR_TO
73585: IFFALSE 73875
// begin if mc_crates_area [ i ] then
73587: LD_EXP 61
73591: PUSH
73592: LD_VAR 0 7
73596: ARRAY
73597: IFFALSE 73708
// for j in mc_crates_area [ i ] do
73599: LD_ADDR_VAR 0 8
73603: PUSH
73604: LD_EXP 61
73608: PUSH
73609: LD_VAR 0 7
73613: ARRAY
73614: PUSH
73615: FOR_IN
73616: IFFALSE 73706
// if InArea ( x , y , j ) then
73618: LD_VAR 0 2
73622: PPUSH
73623: LD_VAR 0 3
73627: PPUSH
73628: LD_VAR 0 8
73632: PPUSH
73633: CALL_OW 309
73637: IFFALSE 73704
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73639: LD_ADDR_EXP 59
73643: PUSH
73644: LD_EXP 59
73648: PPUSH
73649: LD_VAR 0 7
73653: PUSH
73654: LD_EXP 59
73658: PUSH
73659: LD_VAR 0 7
73663: ARRAY
73664: PUSH
73665: LD_INT 1
73667: PLUS
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PPUSH
73673: LD_VAR 0 4
73677: PUSH
73678: LD_VAR 0 2
73682: PUSH
73683: LD_VAR 0 3
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: PPUSH
73693: CALL 14797 0 3
73697: ST_TO_ADDR
// exit ;
73698: POP
73699: POP
73700: POP
73701: POP
73702: GO 73877
// end ;
73704: GO 73615
73706: POP
73707: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73708: LD_ADDR_VAR 0 9
73712: PUSH
73713: LD_EXP 43
73717: PUSH
73718: LD_VAR 0 7
73722: ARRAY
73723: PPUSH
73724: LD_INT 2
73726: PUSH
73727: LD_INT 30
73729: PUSH
73730: LD_INT 0
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: PUSH
73737: LD_INT 30
73739: PUSH
73740: LD_INT 1
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: LIST
73751: PPUSH
73752: CALL_OW 72
73756: ST_TO_ADDR
// if not depot then
73757: LD_VAR 0 9
73761: NOT
73762: IFFALSE 73766
// continue ;
73764: GO 73584
// for j in depot do
73766: LD_ADDR_VAR 0 8
73770: PUSH
73771: LD_VAR 0 9
73775: PUSH
73776: FOR_IN
73777: IFFALSE 73871
// if GetDistUnitXY ( j , x , y ) < 30 then
73779: LD_VAR 0 8
73783: PPUSH
73784: LD_VAR 0 2
73788: PPUSH
73789: LD_VAR 0 3
73793: PPUSH
73794: CALL_OW 297
73798: PUSH
73799: LD_INT 30
73801: LESS
73802: IFFALSE 73869
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73804: LD_ADDR_EXP 59
73808: PUSH
73809: LD_EXP 59
73813: PPUSH
73814: LD_VAR 0 7
73818: PUSH
73819: LD_EXP 59
73823: PUSH
73824: LD_VAR 0 7
73828: ARRAY
73829: PUSH
73830: LD_INT 1
73832: PLUS
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PPUSH
73838: LD_VAR 0 4
73842: PUSH
73843: LD_VAR 0 2
73847: PUSH
73848: LD_VAR 0 3
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: LIST
73857: PPUSH
73858: CALL 14797 0 3
73862: ST_TO_ADDR
// exit ;
73863: POP
73864: POP
73865: POP
73866: POP
73867: GO 73877
// end ;
73869: GO 73776
73871: POP
73872: POP
// end ;
73873: GO 73584
73875: POP
73876: POP
// end ;
73877: LD_VAR 0 6
73881: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
73882: LD_INT 0
73884: PPUSH
73885: PPUSH
73886: PPUSH
73887: PPUSH
// if not mc_bases or not skirmish then
73888: LD_EXP 43
73892: NOT
73893: PUSH
73894: LD_EXP 41
73898: NOT
73899: OR
73900: IFFALSE 73904
// exit ;
73902: GO 74181
// side := GetSide ( lab ) ;
73904: LD_ADDR_VAR 0 4
73908: PUSH
73909: LD_VAR 0 2
73913: PPUSH
73914: CALL_OW 255
73918: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
73919: LD_VAR 0 4
73923: PUSH
73924: LD_EXP 69
73928: IN
73929: NOT
73930: PUSH
73931: LD_EXP 70
73935: NOT
73936: OR
73937: PUSH
73938: LD_EXP 43
73942: NOT
73943: OR
73944: IFFALSE 73948
// exit ;
73946: GO 74181
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
73948: LD_ADDR_EXP 70
73952: PUSH
73953: LD_EXP 70
73957: PPUSH
73958: LD_VAR 0 4
73962: PPUSH
73963: LD_EXP 70
73967: PUSH
73968: LD_VAR 0 4
73972: ARRAY
73973: PUSH
73974: LD_VAR 0 1
73978: DIFF
73979: PPUSH
73980: CALL_OW 1
73984: ST_TO_ADDR
// for i = 1 to mc_bases do
73985: LD_ADDR_VAR 0 5
73989: PUSH
73990: DOUBLE
73991: LD_INT 1
73993: DEC
73994: ST_TO_ADDR
73995: LD_EXP 43
73999: PUSH
74000: FOR_TO
74001: IFFALSE 74179
// begin if lab in mc_bases [ i ] then
74003: LD_VAR 0 2
74007: PUSH
74008: LD_EXP 43
74012: PUSH
74013: LD_VAR 0 5
74017: ARRAY
74018: IN
74019: IFFALSE 74177
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74021: LD_VAR 0 1
74025: PUSH
74026: LD_INT 11
74028: PUSH
74029: LD_INT 4
74031: PUSH
74032: LD_INT 3
74034: PUSH
74035: LD_INT 2
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: IN
74044: PUSH
74045: LD_EXP 73
74049: PUSH
74050: LD_VAR 0 5
74054: ARRAY
74055: AND
74056: IFFALSE 74177
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74058: LD_ADDR_VAR 0 6
74062: PUSH
74063: LD_EXP 73
74067: PUSH
74068: LD_VAR 0 5
74072: ARRAY
74073: PUSH
74074: LD_INT 1
74076: ARRAY
74077: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74078: LD_ADDR_EXP 73
74082: PUSH
74083: LD_EXP 73
74087: PPUSH
74088: LD_VAR 0 5
74092: PPUSH
74093: EMPTY
74094: PPUSH
74095: CALL_OW 1
74099: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74100: LD_VAR 0 6
74104: PPUSH
74105: LD_INT 0
74107: PPUSH
74108: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74112: LD_VAR 0 6
74116: PPUSH
74117: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74121: LD_ADDR_EXP 72
74125: PUSH
74126: LD_EXP 72
74130: PPUSH
74131: LD_VAR 0 5
74135: PPUSH
74136: LD_EXP 72
74140: PUSH
74141: LD_VAR 0 5
74145: ARRAY
74146: PPUSH
74147: LD_INT 1
74149: PPUSH
74150: LD_VAR 0 6
74154: PPUSH
74155: CALL_OW 2
74159: PPUSH
74160: CALL_OW 1
74164: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74165: LD_VAR 0 5
74169: PPUSH
74170: LD_INT 112
74172: PPUSH
74173: CALL 51133 0 2
// end ; end ; end ;
74177: GO 74000
74179: POP
74180: POP
// end ;
74181: LD_VAR 0 3
74185: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74186: LD_INT 0
74188: PPUSH
74189: PPUSH
74190: PPUSH
74191: PPUSH
74192: PPUSH
74193: PPUSH
74194: PPUSH
74195: PPUSH
// if not mc_bases or not skirmish then
74196: LD_EXP 43
74200: NOT
74201: PUSH
74202: LD_EXP 41
74206: NOT
74207: OR
74208: IFFALSE 74212
// exit ;
74210: GO 75583
// for i = 1 to mc_bases do
74212: LD_ADDR_VAR 0 3
74216: PUSH
74217: DOUBLE
74218: LD_INT 1
74220: DEC
74221: ST_TO_ADDR
74222: LD_EXP 43
74226: PUSH
74227: FOR_TO
74228: IFFALSE 75581
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74230: LD_VAR 0 1
74234: PUSH
74235: LD_EXP 43
74239: PUSH
74240: LD_VAR 0 3
74244: ARRAY
74245: IN
74246: PUSH
74247: LD_VAR 0 1
74251: PUSH
74252: LD_EXP 50
74256: PUSH
74257: LD_VAR 0 3
74261: ARRAY
74262: IN
74263: OR
74264: PUSH
74265: LD_VAR 0 1
74269: PUSH
74270: LD_EXP 65
74274: PUSH
74275: LD_VAR 0 3
74279: ARRAY
74280: IN
74281: OR
74282: PUSH
74283: LD_VAR 0 1
74287: PUSH
74288: LD_EXP 62
74292: PUSH
74293: LD_VAR 0 3
74297: ARRAY
74298: IN
74299: OR
74300: PUSH
74301: LD_VAR 0 1
74305: PUSH
74306: LD_EXP 72
74310: PUSH
74311: LD_VAR 0 3
74315: ARRAY
74316: IN
74317: OR
74318: PUSH
74319: LD_VAR 0 1
74323: PUSH
74324: LD_EXP 73
74328: PUSH
74329: LD_VAR 0 3
74333: ARRAY
74334: IN
74335: OR
74336: IFFALSE 75579
// begin if un in mc_ape [ i ] then
74338: LD_VAR 0 1
74342: PUSH
74343: LD_EXP 72
74347: PUSH
74348: LD_VAR 0 3
74352: ARRAY
74353: IN
74354: IFFALSE 74393
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74356: LD_ADDR_EXP 72
74360: PUSH
74361: LD_EXP 72
74365: PPUSH
74366: LD_VAR 0 3
74370: PPUSH
74371: LD_EXP 72
74375: PUSH
74376: LD_VAR 0 3
74380: ARRAY
74381: PUSH
74382: LD_VAR 0 1
74386: DIFF
74387: PPUSH
74388: CALL_OW 1
74392: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74393: LD_VAR 0 1
74397: PUSH
74398: LD_EXP 73
74402: PUSH
74403: LD_VAR 0 3
74407: ARRAY
74408: IN
74409: IFFALSE 74433
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74411: LD_ADDR_EXP 73
74415: PUSH
74416: LD_EXP 73
74420: PPUSH
74421: LD_VAR 0 3
74425: PPUSH
74426: EMPTY
74427: PPUSH
74428: CALL_OW 1
74432: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74433: LD_VAR 0 1
74437: PPUSH
74438: CALL_OW 247
74442: PUSH
74443: LD_INT 2
74445: EQUAL
74446: PUSH
74447: LD_VAR 0 1
74451: PPUSH
74452: CALL_OW 110
74456: PUSH
74457: LD_INT 20
74459: EQUAL
74460: PUSH
74461: LD_VAR 0 1
74465: PUSH
74466: LD_EXP 65
74470: PUSH
74471: LD_VAR 0 3
74475: ARRAY
74476: IN
74477: OR
74478: PUSH
74479: LD_VAR 0 1
74483: PPUSH
74484: CALL_OW 264
74488: PUSH
74489: LD_INT 12
74491: PUSH
74492: LD_INT 51
74494: PUSH
74495: LD_EXP 87
74499: PUSH
74500: LD_INT 32
74502: PUSH
74503: LD_INT 13
74505: PUSH
74506: LD_INT 52
74508: PUSH
74509: LD_INT 31
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: IN
74521: OR
74522: AND
74523: IFFALSE 74831
// begin if un in mc_defender [ i ] then
74525: LD_VAR 0 1
74529: PUSH
74530: LD_EXP 65
74534: PUSH
74535: LD_VAR 0 3
74539: ARRAY
74540: IN
74541: IFFALSE 74580
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74543: LD_ADDR_EXP 65
74547: PUSH
74548: LD_EXP 65
74552: PPUSH
74553: LD_VAR 0 3
74557: PPUSH
74558: LD_EXP 65
74562: PUSH
74563: LD_VAR 0 3
74567: ARRAY
74568: PUSH
74569: LD_VAR 0 1
74573: DIFF
74574: PPUSH
74575: CALL_OW 1
74579: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74580: LD_ADDR_VAR 0 8
74584: PUSH
74585: LD_VAR 0 3
74589: PPUSH
74590: LD_INT 3
74592: PPUSH
74593: CALL 71230 0 2
74597: ST_TO_ADDR
// if fac then
74598: LD_VAR 0 8
74602: IFFALSE 74831
// begin for j in fac do
74604: LD_ADDR_VAR 0 4
74608: PUSH
74609: LD_VAR 0 8
74613: PUSH
74614: FOR_IN
74615: IFFALSE 74829
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74617: LD_ADDR_VAR 0 9
74621: PUSH
74622: LD_VAR 0 8
74626: PPUSH
74627: LD_VAR 0 1
74631: PPUSH
74632: CALL_OW 265
74636: PPUSH
74637: LD_VAR 0 1
74641: PPUSH
74642: CALL_OW 262
74646: PPUSH
74647: LD_VAR 0 1
74651: PPUSH
74652: CALL_OW 263
74656: PPUSH
74657: LD_VAR 0 1
74661: PPUSH
74662: CALL_OW 264
74666: PPUSH
74667: CALL 12329 0 5
74671: ST_TO_ADDR
// if components then
74672: LD_VAR 0 9
74676: IFFALSE 74827
// begin if GetWeapon ( un ) = ar_control_tower then
74678: LD_VAR 0 1
74682: PPUSH
74683: CALL_OW 264
74687: PUSH
74688: LD_INT 31
74690: EQUAL
74691: IFFALSE 74808
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74693: LD_VAR 0 1
74697: PPUSH
74698: CALL_OW 311
74702: PPUSH
74703: LD_INT 0
74705: PPUSH
74706: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74710: LD_ADDR_EXP 83
74714: PUSH
74715: LD_EXP 83
74719: PPUSH
74720: LD_VAR 0 3
74724: PPUSH
74725: LD_EXP 83
74729: PUSH
74730: LD_VAR 0 3
74734: ARRAY
74735: PUSH
74736: LD_VAR 0 1
74740: PPUSH
74741: CALL_OW 311
74745: DIFF
74746: PPUSH
74747: CALL_OW 1
74751: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
74752: LD_ADDR_VAR 0 7
74756: PUSH
74757: LD_EXP 64
74761: PUSH
74762: LD_VAR 0 3
74766: ARRAY
74767: PPUSH
74768: LD_INT 1
74770: PPUSH
74771: LD_VAR 0 9
74775: PPUSH
74776: CALL_OW 2
74780: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74781: LD_ADDR_EXP 64
74785: PUSH
74786: LD_EXP 64
74790: PPUSH
74791: LD_VAR 0 3
74795: PPUSH
74796: LD_VAR 0 7
74800: PPUSH
74801: CALL_OW 1
74805: ST_TO_ADDR
// end else
74806: GO 74825
// MC_InsertProduceList ( i , [ components ] ) ;
74808: LD_VAR 0 3
74812: PPUSH
74813: LD_VAR 0 9
74817: PUSH
74818: EMPTY
74819: LIST
74820: PPUSH
74821: CALL 70775 0 2
// break ;
74825: GO 74829
// end ; end ;
74827: GO 74614
74829: POP
74830: POP
// end ; end ; if GetType ( un ) = unit_building then
74831: LD_VAR 0 1
74835: PPUSH
74836: CALL_OW 247
74840: PUSH
74841: LD_INT 3
74843: EQUAL
74844: IFFALSE 75247
// begin btype := GetBType ( un ) ;
74846: LD_ADDR_VAR 0 5
74850: PUSH
74851: LD_VAR 0 1
74855: PPUSH
74856: CALL_OW 266
74860: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
74861: LD_VAR 0 5
74865: PUSH
74866: LD_INT 29
74868: PUSH
74869: LD_INT 30
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: IN
74876: IFFALSE 74949
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
74878: LD_VAR 0 1
74882: PPUSH
74883: CALL_OW 250
74887: PPUSH
74888: LD_VAR 0 1
74892: PPUSH
74893: CALL_OW 251
74897: PPUSH
74898: LD_VAR 0 1
74902: PPUSH
74903: CALL_OW 255
74907: PPUSH
74908: CALL_OW 440
74912: NOT
74913: IFFALSE 74949
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
74915: LD_VAR 0 1
74919: PPUSH
74920: CALL_OW 250
74924: PPUSH
74925: LD_VAR 0 1
74929: PPUSH
74930: CALL_OW 251
74934: PPUSH
74935: LD_VAR 0 1
74939: PPUSH
74940: CALL_OW 255
74944: PPUSH
74945: CALL_OW 441
// end ; if btype = b_warehouse then
74949: LD_VAR 0 5
74953: PUSH
74954: LD_INT 1
74956: EQUAL
74957: IFFALSE 74975
// begin btype := b_depot ;
74959: LD_ADDR_VAR 0 5
74963: PUSH
74964: LD_INT 0
74966: ST_TO_ADDR
// pos := 1 ;
74967: LD_ADDR_VAR 0 6
74971: PUSH
74972: LD_INT 1
74974: ST_TO_ADDR
// end ; if btype = b_factory then
74975: LD_VAR 0 5
74979: PUSH
74980: LD_INT 3
74982: EQUAL
74983: IFFALSE 75001
// begin btype := b_workshop ;
74985: LD_ADDR_VAR 0 5
74989: PUSH
74990: LD_INT 2
74992: ST_TO_ADDR
// pos := 1 ;
74993: LD_ADDR_VAR 0 6
74997: PUSH
74998: LD_INT 1
75000: ST_TO_ADDR
// end ; if btype = b_barracks then
75001: LD_VAR 0 5
75005: PUSH
75006: LD_INT 5
75008: EQUAL
75009: IFFALSE 75019
// btype := b_armoury ;
75011: LD_ADDR_VAR 0 5
75015: PUSH
75016: LD_INT 4
75018: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75019: LD_VAR 0 5
75023: PUSH
75024: LD_INT 7
75026: PUSH
75027: LD_INT 8
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: IN
75034: IFFALSE 75044
// btype := b_lab ;
75036: LD_ADDR_VAR 0 5
75040: PUSH
75041: LD_INT 6
75043: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75044: LD_ADDR_EXP 48
75048: PUSH
75049: LD_EXP 48
75053: PPUSH
75054: LD_VAR 0 3
75058: PUSH
75059: LD_EXP 48
75063: PUSH
75064: LD_VAR 0 3
75068: ARRAY
75069: PUSH
75070: LD_INT 1
75072: PLUS
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PPUSH
75078: LD_VAR 0 5
75082: PUSH
75083: LD_VAR 0 1
75087: PPUSH
75088: CALL_OW 250
75092: PUSH
75093: LD_VAR 0 1
75097: PPUSH
75098: CALL_OW 251
75102: PUSH
75103: LD_VAR 0 1
75107: PPUSH
75108: CALL_OW 254
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: PPUSH
75119: CALL 14797 0 3
75123: ST_TO_ADDR
// if pos = 1 then
75124: LD_VAR 0 6
75128: PUSH
75129: LD_INT 1
75131: EQUAL
75132: IFFALSE 75247
// begin tmp := mc_build_list [ i ] ;
75134: LD_ADDR_VAR 0 7
75138: PUSH
75139: LD_EXP 48
75143: PUSH
75144: LD_VAR 0 3
75148: ARRAY
75149: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75150: LD_VAR 0 7
75154: PPUSH
75155: LD_INT 2
75157: PUSH
75158: LD_INT 30
75160: PUSH
75161: LD_INT 0
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 30
75170: PUSH
75171: LD_INT 1
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: LIST
75182: PPUSH
75183: CALL_OW 72
75187: IFFALSE 75197
// pos := 2 ;
75189: LD_ADDR_VAR 0 6
75193: PUSH
75194: LD_INT 2
75196: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75197: LD_ADDR_VAR 0 7
75201: PUSH
75202: LD_VAR 0 7
75206: PPUSH
75207: LD_VAR 0 6
75211: PPUSH
75212: LD_VAR 0 7
75216: PPUSH
75217: CALL 15123 0 3
75221: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75222: LD_ADDR_EXP 48
75226: PUSH
75227: LD_EXP 48
75231: PPUSH
75232: LD_VAR 0 3
75236: PPUSH
75237: LD_VAR 0 7
75241: PPUSH
75242: CALL_OW 1
75246: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75247: LD_VAR 0 1
75251: PUSH
75252: LD_EXP 43
75256: PUSH
75257: LD_VAR 0 3
75261: ARRAY
75262: IN
75263: IFFALSE 75302
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75265: LD_ADDR_EXP 43
75269: PUSH
75270: LD_EXP 43
75274: PPUSH
75275: LD_VAR 0 3
75279: PPUSH
75280: LD_EXP 43
75284: PUSH
75285: LD_VAR 0 3
75289: ARRAY
75290: PUSH
75291: LD_VAR 0 1
75295: DIFF
75296: PPUSH
75297: CALL_OW 1
75301: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75302: LD_VAR 0 1
75306: PUSH
75307: LD_EXP 50
75311: PUSH
75312: LD_VAR 0 3
75316: ARRAY
75317: IN
75318: IFFALSE 75357
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75320: LD_ADDR_EXP 50
75324: PUSH
75325: LD_EXP 50
75329: PPUSH
75330: LD_VAR 0 3
75334: PPUSH
75335: LD_EXP 50
75339: PUSH
75340: LD_VAR 0 3
75344: ARRAY
75345: PUSH
75346: LD_VAR 0 1
75350: DIFF
75351: PPUSH
75352: CALL_OW 1
75356: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75357: LD_VAR 0 1
75361: PUSH
75362: LD_EXP 62
75366: PUSH
75367: LD_VAR 0 3
75371: ARRAY
75372: IN
75373: IFFALSE 75412
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75375: LD_ADDR_EXP 62
75379: PUSH
75380: LD_EXP 62
75384: PPUSH
75385: LD_VAR 0 3
75389: PPUSH
75390: LD_EXP 62
75394: PUSH
75395: LD_VAR 0 3
75399: ARRAY
75400: PUSH
75401: LD_VAR 0 1
75405: DIFF
75406: PPUSH
75407: CALL_OW 1
75411: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75412: LD_VAR 0 1
75416: PUSH
75417: LD_EXP 65
75421: PUSH
75422: LD_VAR 0 3
75426: ARRAY
75427: IN
75428: IFFALSE 75467
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75430: LD_ADDR_EXP 65
75434: PUSH
75435: LD_EXP 65
75439: PPUSH
75440: LD_VAR 0 3
75444: PPUSH
75445: LD_EXP 65
75449: PUSH
75450: LD_VAR 0 3
75454: ARRAY
75455: PUSH
75456: LD_VAR 0 1
75460: DIFF
75461: PPUSH
75462: CALL_OW 1
75466: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75467: LD_VAR 0 1
75471: PUSH
75472: LD_EXP 52
75476: PUSH
75477: LD_VAR 0 3
75481: ARRAY
75482: IN
75483: IFFALSE 75522
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75485: LD_ADDR_EXP 52
75489: PUSH
75490: LD_EXP 52
75494: PPUSH
75495: LD_VAR 0 3
75499: PPUSH
75500: LD_EXP 52
75504: PUSH
75505: LD_VAR 0 3
75509: ARRAY
75510: PUSH
75511: LD_VAR 0 1
75515: DIFF
75516: PPUSH
75517: CALL_OW 1
75521: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75522: LD_VAR 0 1
75526: PUSH
75527: LD_EXP 51
75531: PUSH
75532: LD_VAR 0 3
75536: ARRAY
75537: IN
75538: IFFALSE 75577
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75540: LD_ADDR_EXP 51
75544: PUSH
75545: LD_EXP 51
75549: PPUSH
75550: LD_VAR 0 3
75554: PPUSH
75555: LD_EXP 51
75559: PUSH
75560: LD_VAR 0 3
75564: ARRAY
75565: PUSH
75566: LD_VAR 0 1
75570: DIFF
75571: PPUSH
75572: CALL_OW 1
75576: ST_TO_ADDR
// end ; break ;
75577: GO 75581
// end ;
75579: GO 74227
75581: POP
75582: POP
// end ;
75583: LD_VAR 0 2
75587: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75588: LD_INT 0
75590: PPUSH
75591: PPUSH
75592: PPUSH
// if not mc_bases or not skirmish then
75593: LD_EXP 43
75597: NOT
75598: PUSH
75599: LD_EXP 41
75603: NOT
75604: OR
75605: IFFALSE 75609
// exit ;
75607: GO 75824
// for i = 1 to mc_bases do
75609: LD_ADDR_VAR 0 3
75613: PUSH
75614: DOUBLE
75615: LD_INT 1
75617: DEC
75618: ST_TO_ADDR
75619: LD_EXP 43
75623: PUSH
75624: FOR_TO
75625: IFFALSE 75822
// begin if building in mc_construct_list [ i ] then
75627: LD_VAR 0 1
75631: PUSH
75632: LD_EXP 50
75636: PUSH
75637: LD_VAR 0 3
75641: ARRAY
75642: IN
75643: IFFALSE 75820
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75645: LD_ADDR_EXP 50
75649: PUSH
75650: LD_EXP 50
75654: PPUSH
75655: LD_VAR 0 3
75659: PPUSH
75660: LD_EXP 50
75664: PUSH
75665: LD_VAR 0 3
75669: ARRAY
75670: PUSH
75671: LD_VAR 0 1
75675: DIFF
75676: PPUSH
75677: CALL_OW 1
75681: ST_TO_ADDR
// if building in mc_lab [ i ] then
75682: LD_VAR 0 1
75686: PUSH
75687: LD_EXP 76
75691: PUSH
75692: LD_VAR 0 3
75696: ARRAY
75697: IN
75698: IFFALSE 75753
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75700: LD_ADDR_EXP 77
75704: PUSH
75705: LD_EXP 77
75709: PPUSH
75710: LD_VAR 0 3
75714: PPUSH
75715: LD_EXP 77
75719: PUSH
75720: LD_VAR 0 3
75724: ARRAY
75725: PPUSH
75726: LD_INT 1
75728: PPUSH
75729: LD_EXP 77
75733: PUSH
75734: LD_VAR 0 3
75738: ARRAY
75739: PPUSH
75740: LD_INT 0
75742: PPUSH
75743: CALL 14215 0 4
75747: PPUSH
75748: CALL_OW 1
75752: ST_TO_ADDR
// if not building in mc_bases [ i ] then
75753: LD_VAR 0 1
75757: PUSH
75758: LD_EXP 43
75762: PUSH
75763: LD_VAR 0 3
75767: ARRAY
75768: IN
75769: NOT
75770: IFFALSE 75816
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75772: LD_ADDR_EXP 43
75776: PUSH
75777: LD_EXP 43
75781: PPUSH
75782: LD_VAR 0 3
75786: PUSH
75787: LD_EXP 43
75791: PUSH
75792: LD_VAR 0 3
75796: ARRAY
75797: PUSH
75798: LD_INT 1
75800: PLUS
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PPUSH
75806: LD_VAR 0 1
75810: PPUSH
75811: CALL 14797 0 3
75815: ST_TO_ADDR
// exit ;
75816: POP
75817: POP
75818: GO 75824
// end ; end ;
75820: GO 75624
75822: POP
75823: POP
// end ;
75824: LD_VAR 0 2
75828: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
75829: LD_INT 0
75831: PPUSH
75832: PPUSH
75833: PPUSH
75834: PPUSH
75835: PPUSH
75836: PPUSH
75837: PPUSH
// if not mc_bases or not skirmish then
75838: LD_EXP 43
75842: NOT
75843: PUSH
75844: LD_EXP 41
75848: NOT
75849: OR
75850: IFFALSE 75854
// exit ;
75852: GO 76515
// for i = 1 to mc_bases do
75854: LD_ADDR_VAR 0 3
75858: PUSH
75859: DOUBLE
75860: LD_INT 1
75862: DEC
75863: ST_TO_ADDR
75864: LD_EXP 43
75868: PUSH
75869: FOR_TO
75870: IFFALSE 76513
// begin if building in mc_construct_list [ i ] then
75872: LD_VAR 0 1
75876: PUSH
75877: LD_EXP 50
75881: PUSH
75882: LD_VAR 0 3
75886: ARRAY
75887: IN
75888: IFFALSE 76511
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75890: LD_ADDR_EXP 50
75894: PUSH
75895: LD_EXP 50
75899: PPUSH
75900: LD_VAR 0 3
75904: PPUSH
75905: LD_EXP 50
75909: PUSH
75910: LD_VAR 0 3
75914: ARRAY
75915: PUSH
75916: LD_VAR 0 1
75920: DIFF
75921: PPUSH
75922: CALL_OW 1
75926: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75927: LD_ADDR_EXP 43
75931: PUSH
75932: LD_EXP 43
75936: PPUSH
75937: LD_VAR 0 3
75941: PUSH
75942: LD_EXP 43
75946: PUSH
75947: LD_VAR 0 3
75951: ARRAY
75952: PUSH
75953: LD_INT 1
75955: PLUS
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PPUSH
75961: LD_VAR 0 1
75965: PPUSH
75966: CALL 14797 0 3
75970: ST_TO_ADDR
// btype := GetBType ( building ) ;
75971: LD_ADDR_VAR 0 5
75975: PUSH
75976: LD_VAR 0 1
75980: PPUSH
75981: CALL_OW 266
75985: ST_TO_ADDR
// side := GetSide ( building ) ;
75986: LD_ADDR_VAR 0 8
75990: PUSH
75991: LD_VAR 0 1
75995: PPUSH
75996: CALL_OW 255
76000: ST_TO_ADDR
// if btype = b_lab then
76001: LD_VAR 0 5
76005: PUSH
76006: LD_INT 6
76008: EQUAL
76009: IFFALSE 76059
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76011: LD_ADDR_EXP 76
76015: PUSH
76016: LD_EXP 76
76020: PPUSH
76021: LD_VAR 0 3
76025: PUSH
76026: LD_EXP 76
76030: PUSH
76031: LD_VAR 0 3
76035: ARRAY
76036: PUSH
76037: LD_INT 1
76039: PLUS
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PPUSH
76045: LD_VAR 0 1
76049: PPUSH
76050: CALL 14797 0 3
76054: ST_TO_ADDR
// exit ;
76055: POP
76056: POP
76057: GO 76515
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76059: LD_VAR 0 5
76063: PUSH
76064: LD_INT 0
76066: PUSH
76067: LD_INT 2
76069: PUSH
76070: LD_INT 4
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: LIST
76077: IN
76078: IFFALSE 76202
// begin if btype = b_armoury then
76080: LD_VAR 0 5
76084: PUSH
76085: LD_INT 4
76087: EQUAL
76088: IFFALSE 76098
// btype := b_barracks ;
76090: LD_ADDR_VAR 0 5
76094: PUSH
76095: LD_INT 5
76097: ST_TO_ADDR
// if btype = b_depot then
76098: LD_VAR 0 5
76102: PUSH
76103: LD_INT 0
76105: EQUAL
76106: IFFALSE 76116
// btype := b_warehouse ;
76108: LD_ADDR_VAR 0 5
76112: PUSH
76113: LD_INT 1
76115: ST_TO_ADDR
// if btype = b_workshop then
76116: LD_VAR 0 5
76120: PUSH
76121: LD_INT 2
76123: EQUAL
76124: IFFALSE 76134
// btype := b_factory ;
76126: LD_ADDR_VAR 0 5
76130: PUSH
76131: LD_INT 3
76133: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76134: LD_VAR 0 5
76138: PPUSH
76139: LD_VAR 0 8
76143: PPUSH
76144: CALL_OW 323
76148: PUSH
76149: LD_INT 1
76151: EQUAL
76152: IFFALSE 76198
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76154: LD_ADDR_EXP 75
76158: PUSH
76159: LD_EXP 75
76163: PPUSH
76164: LD_VAR 0 3
76168: PUSH
76169: LD_EXP 75
76173: PUSH
76174: LD_VAR 0 3
76178: ARRAY
76179: PUSH
76180: LD_INT 1
76182: PLUS
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PPUSH
76188: LD_VAR 0 1
76192: PPUSH
76193: CALL 14797 0 3
76197: ST_TO_ADDR
// exit ;
76198: POP
76199: POP
76200: GO 76515
// end ; if btype in [ b_bunker , b_turret ] then
76202: LD_VAR 0 5
76206: PUSH
76207: LD_INT 32
76209: PUSH
76210: LD_INT 33
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: IN
76217: IFFALSE 76507
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76219: LD_ADDR_EXP 51
76223: PUSH
76224: LD_EXP 51
76228: PPUSH
76229: LD_VAR 0 3
76233: PUSH
76234: LD_EXP 51
76238: PUSH
76239: LD_VAR 0 3
76243: ARRAY
76244: PUSH
76245: LD_INT 1
76247: PLUS
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PPUSH
76253: LD_VAR 0 1
76257: PPUSH
76258: CALL 14797 0 3
76262: ST_TO_ADDR
// if btype = b_bunker then
76263: LD_VAR 0 5
76267: PUSH
76268: LD_INT 32
76270: EQUAL
76271: IFFALSE 76507
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76273: LD_ADDR_EXP 52
76277: PUSH
76278: LD_EXP 52
76282: PPUSH
76283: LD_VAR 0 3
76287: PUSH
76288: LD_EXP 52
76292: PUSH
76293: LD_VAR 0 3
76297: ARRAY
76298: PUSH
76299: LD_INT 1
76301: PLUS
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PPUSH
76307: LD_VAR 0 1
76311: PPUSH
76312: CALL 14797 0 3
76316: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76317: LD_ADDR_VAR 0 6
76321: PUSH
76322: LD_EXP 43
76326: PUSH
76327: LD_VAR 0 3
76331: ARRAY
76332: PPUSH
76333: LD_INT 25
76335: PUSH
76336: LD_INT 1
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 3
76345: PUSH
76346: LD_INT 54
76348: PUSH
76349: EMPTY
76350: LIST
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PPUSH
76360: CALL_OW 72
76364: ST_TO_ADDR
// if tmp then
76365: LD_VAR 0 6
76369: IFFALSE 76375
// exit ;
76371: POP
76372: POP
76373: GO 76515
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76375: LD_ADDR_VAR 0 6
76379: PUSH
76380: LD_EXP 43
76384: PUSH
76385: LD_VAR 0 3
76389: ARRAY
76390: PPUSH
76391: LD_INT 2
76393: PUSH
76394: LD_INT 30
76396: PUSH
76397: LD_INT 4
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 30
76406: PUSH
76407: LD_INT 5
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: LIST
76418: PPUSH
76419: CALL_OW 72
76423: ST_TO_ADDR
// if not tmp then
76424: LD_VAR 0 6
76428: NOT
76429: IFFALSE 76435
// exit ;
76431: POP
76432: POP
76433: GO 76515
// for j in tmp do
76435: LD_ADDR_VAR 0 4
76439: PUSH
76440: LD_VAR 0 6
76444: PUSH
76445: FOR_IN
76446: IFFALSE 76505
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76448: LD_ADDR_VAR 0 7
76452: PUSH
76453: LD_VAR 0 4
76457: PPUSH
76458: CALL_OW 313
76462: PPUSH
76463: LD_INT 25
76465: PUSH
76466: LD_INT 1
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PPUSH
76473: CALL_OW 72
76477: ST_TO_ADDR
// if units then
76478: LD_VAR 0 7
76482: IFFALSE 76503
// begin ComExitBuilding ( units [ 1 ] ) ;
76484: LD_VAR 0 7
76488: PUSH
76489: LD_INT 1
76491: ARRAY
76492: PPUSH
76493: CALL_OW 122
// exit ;
76497: POP
76498: POP
76499: POP
76500: POP
76501: GO 76515
// end ; end ;
76503: GO 76445
76505: POP
76506: POP
// end ; end ; exit ;
76507: POP
76508: POP
76509: GO 76515
// end ; end ;
76511: GO 75869
76513: POP
76514: POP
// end ;
76515: LD_VAR 0 2
76519: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76520: LD_INT 0
76522: PPUSH
76523: PPUSH
76524: PPUSH
76525: PPUSH
76526: PPUSH
76527: PPUSH
76528: PPUSH
// if not mc_bases or not skirmish then
76529: LD_EXP 43
76533: NOT
76534: PUSH
76535: LD_EXP 41
76539: NOT
76540: OR
76541: IFFALSE 76545
// exit ;
76543: GO 76776
// btype := GetBType ( building ) ;
76545: LD_ADDR_VAR 0 6
76549: PUSH
76550: LD_VAR 0 1
76554: PPUSH
76555: CALL_OW 266
76559: ST_TO_ADDR
// x := GetX ( building ) ;
76560: LD_ADDR_VAR 0 7
76564: PUSH
76565: LD_VAR 0 1
76569: PPUSH
76570: CALL_OW 250
76574: ST_TO_ADDR
// y := GetY ( building ) ;
76575: LD_ADDR_VAR 0 8
76579: PUSH
76580: LD_VAR 0 1
76584: PPUSH
76585: CALL_OW 251
76589: ST_TO_ADDR
// d := GetDir ( building ) ;
76590: LD_ADDR_VAR 0 9
76594: PUSH
76595: LD_VAR 0 1
76599: PPUSH
76600: CALL_OW 254
76604: ST_TO_ADDR
// for i = 1 to mc_bases do
76605: LD_ADDR_VAR 0 4
76609: PUSH
76610: DOUBLE
76611: LD_INT 1
76613: DEC
76614: ST_TO_ADDR
76615: LD_EXP 43
76619: PUSH
76620: FOR_TO
76621: IFFALSE 76774
// begin if not mc_build_list [ i ] then
76623: LD_EXP 48
76627: PUSH
76628: LD_VAR 0 4
76632: ARRAY
76633: NOT
76634: IFFALSE 76638
// continue ;
76636: GO 76620
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
76638: LD_VAR 0 6
76642: PUSH
76643: LD_VAR 0 7
76647: PUSH
76648: LD_VAR 0 8
76652: PUSH
76653: LD_VAR 0 9
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: PPUSH
76664: LD_EXP 48
76668: PUSH
76669: LD_VAR 0 4
76673: ARRAY
76674: PUSH
76675: LD_INT 1
76677: ARRAY
76678: PPUSH
76679: CALL 20966 0 2
76683: IFFALSE 76772
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
76685: LD_ADDR_EXP 48
76689: PUSH
76690: LD_EXP 48
76694: PPUSH
76695: LD_VAR 0 4
76699: PPUSH
76700: LD_EXP 48
76704: PUSH
76705: LD_VAR 0 4
76709: ARRAY
76710: PPUSH
76711: LD_INT 1
76713: PPUSH
76714: CALL_OW 3
76718: PPUSH
76719: CALL_OW 1
76723: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
76724: LD_ADDR_EXP 50
76728: PUSH
76729: LD_EXP 50
76733: PPUSH
76734: LD_VAR 0 4
76738: PUSH
76739: LD_EXP 50
76743: PUSH
76744: LD_VAR 0 4
76748: ARRAY
76749: PUSH
76750: LD_INT 1
76752: PLUS
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PPUSH
76758: LD_VAR 0 1
76762: PPUSH
76763: CALL 14797 0 3
76767: ST_TO_ADDR
// exit ;
76768: POP
76769: POP
76770: GO 76776
// end ; end ;
76772: GO 76620
76774: POP
76775: POP
// end ;
76776: LD_VAR 0 3
76780: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
76781: LD_INT 0
76783: PPUSH
76784: PPUSH
76785: PPUSH
// if not mc_bases or not skirmish then
76786: LD_EXP 43
76790: NOT
76791: PUSH
76792: LD_EXP 41
76796: NOT
76797: OR
76798: IFFALSE 76802
// exit ;
76800: GO 76992
// for i = 1 to mc_bases do
76802: LD_ADDR_VAR 0 4
76806: PUSH
76807: DOUBLE
76808: LD_INT 1
76810: DEC
76811: ST_TO_ADDR
76812: LD_EXP 43
76816: PUSH
76817: FOR_TO
76818: IFFALSE 76905
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
76820: LD_VAR 0 1
76824: PUSH
76825: LD_EXP 51
76829: PUSH
76830: LD_VAR 0 4
76834: ARRAY
76835: IN
76836: PUSH
76837: LD_VAR 0 1
76841: PUSH
76842: LD_EXP 52
76846: PUSH
76847: LD_VAR 0 4
76851: ARRAY
76852: IN
76853: NOT
76854: AND
76855: IFFALSE 76903
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76857: LD_ADDR_EXP 52
76861: PUSH
76862: LD_EXP 52
76866: PPUSH
76867: LD_VAR 0 4
76871: PUSH
76872: LD_EXP 52
76876: PUSH
76877: LD_VAR 0 4
76881: ARRAY
76882: PUSH
76883: LD_INT 1
76885: PLUS
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PPUSH
76891: LD_VAR 0 1
76895: PPUSH
76896: CALL 14797 0 3
76900: ST_TO_ADDR
// break ;
76901: GO 76905
// end ; end ;
76903: GO 76817
76905: POP
76906: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
76907: LD_VAR 0 1
76911: PPUSH
76912: CALL_OW 257
76916: PUSH
76917: LD_EXP 69
76921: IN
76922: PUSH
76923: LD_VAR 0 1
76927: PPUSH
76928: CALL_OW 266
76932: PUSH
76933: LD_INT 5
76935: EQUAL
76936: AND
76937: PUSH
76938: LD_VAR 0 2
76942: PPUSH
76943: CALL_OW 110
76947: PUSH
76948: LD_INT 18
76950: NONEQUAL
76951: AND
76952: IFFALSE 76992
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
76954: LD_VAR 0 2
76958: PPUSH
76959: CALL_OW 257
76963: PUSH
76964: LD_INT 5
76966: PUSH
76967: LD_INT 8
76969: PUSH
76970: LD_INT 9
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: LIST
76977: IN
76978: IFFALSE 76992
// SetClass ( unit , 1 ) ;
76980: LD_VAR 0 2
76984: PPUSH
76985: LD_INT 1
76987: PPUSH
76988: CALL_OW 336
// end ;
76992: LD_VAR 0 3
76996: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
76997: LD_INT 0
76999: PPUSH
77000: PPUSH
// if not mc_bases or not skirmish then
77001: LD_EXP 43
77005: NOT
77006: PUSH
77007: LD_EXP 41
77011: NOT
77012: OR
77013: IFFALSE 77017
// exit ;
77015: GO 77133
// if GetLives ( abandoned_vehicle ) > 250 then
77017: LD_VAR 0 2
77021: PPUSH
77022: CALL_OW 256
77026: PUSH
77027: LD_INT 250
77029: GREATER
77030: IFFALSE 77034
// exit ;
77032: GO 77133
// for i = 1 to mc_bases do
77034: LD_ADDR_VAR 0 6
77038: PUSH
77039: DOUBLE
77040: LD_INT 1
77042: DEC
77043: ST_TO_ADDR
77044: LD_EXP 43
77048: PUSH
77049: FOR_TO
77050: IFFALSE 77131
// begin if driver in mc_bases [ i ] then
77052: LD_VAR 0 1
77056: PUSH
77057: LD_EXP 43
77061: PUSH
77062: LD_VAR 0 6
77066: ARRAY
77067: IN
77068: IFFALSE 77129
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77070: LD_VAR 0 1
77074: PPUSH
77075: LD_EXP 43
77079: PUSH
77080: LD_VAR 0 6
77084: ARRAY
77085: PPUSH
77086: LD_INT 2
77088: PUSH
77089: LD_INT 30
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 30
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: LIST
77113: PPUSH
77114: CALL_OW 72
77118: PUSH
77119: LD_INT 1
77121: ARRAY
77122: PPUSH
77123: CALL 46663 0 2
// break ;
77127: GO 77131
// end ; end ;
77129: GO 77049
77131: POP
77132: POP
// end ; end_of_file
77133: LD_VAR 0 5
77137: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77138: LD_INT 0
77140: PPUSH
// ar_miner := 81 ;
77141: LD_ADDR_EXP 93
77145: PUSH
77146: LD_INT 81
77148: ST_TO_ADDR
// ar_crane := 88 ;
77149: LD_ADDR_EXP 92
77153: PUSH
77154: LD_INT 88
77156: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77157: LD_ADDR_EXP 87
77161: PUSH
77162: LD_INT 89
77164: ST_TO_ADDR
// us_hack := 99 ;
77165: LD_ADDR_EXP 88
77169: PUSH
77170: LD_INT 99
77172: ST_TO_ADDR
// us_artillery := 97 ;
77173: LD_ADDR_EXP 89
77177: PUSH
77178: LD_INT 97
77180: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77181: LD_ADDR_EXP 90
77185: PUSH
77186: LD_INT 91
77188: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77189: LD_ADDR_EXP 91
77193: PUSH
77194: LD_INT 92
77196: ST_TO_ADDR
// ru_radar := 98 ;
77197: LD_ADDR_EXP 86
77201: PUSH
77202: LD_INT 98
77204: ST_TO_ADDR
// tech_Artillery := 80 ;
77205: LD_ADDR_EXP 94
77209: PUSH
77210: LD_INT 80
77212: ST_TO_ADDR
// tech_RadMat := 81 ;
77213: LD_ADDR_EXP 95
77217: PUSH
77218: LD_INT 81
77220: ST_TO_ADDR
// tech_BasicTools := 82 ;
77221: LD_ADDR_EXP 96
77225: PUSH
77226: LD_INT 82
77228: ST_TO_ADDR
// tech_Cargo := 83 ;
77229: LD_ADDR_EXP 97
77233: PUSH
77234: LD_INT 83
77236: ST_TO_ADDR
// tech_Track := 84 ;
77237: LD_ADDR_EXP 98
77241: PUSH
77242: LD_INT 84
77244: ST_TO_ADDR
// tech_Crane := 85 ;
77245: LD_ADDR_EXP 99
77249: PUSH
77250: LD_INT 85
77252: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77253: LD_ADDR_EXP 100
77257: PUSH
77258: LD_INT 86
77260: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77261: LD_ADDR_EXP 101
77265: PUSH
77266: LD_INT 87
77268: ST_TO_ADDR
// end ;
77269: LD_VAR 0 1
77273: RET
// every 1 do
77274: GO 77276
77276: DISABLE
// InitGlobalVariables ; end_of_file
77277: CALL 77138 0 0
77281: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77282: LD_INT 0
77284: PPUSH
77285: PPUSH
77286: PPUSH
77287: PPUSH
77288: PPUSH
77289: PPUSH
77290: PPUSH
77291: PPUSH
77292: PPUSH
77293: PPUSH
77294: PPUSH
77295: PPUSH
77296: PPUSH
77297: PPUSH
77298: PPUSH
77299: PPUSH
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
77304: PPUSH
77305: PPUSH
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
// if not list then
77318: LD_VAR 0 1
77322: NOT
77323: IFFALSE 77327
// exit ;
77325: GO 81986
// base := list [ 1 ] ;
77327: LD_ADDR_VAR 0 3
77331: PUSH
77332: LD_VAR 0 1
77336: PUSH
77337: LD_INT 1
77339: ARRAY
77340: ST_TO_ADDR
// group := list [ 2 ] ;
77341: LD_ADDR_VAR 0 4
77345: PUSH
77346: LD_VAR 0 1
77350: PUSH
77351: LD_INT 2
77353: ARRAY
77354: ST_TO_ADDR
// path := list [ 3 ] ;
77355: LD_ADDR_VAR 0 5
77359: PUSH
77360: LD_VAR 0 1
77364: PUSH
77365: LD_INT 3
77367: ARRAY
77368: ST_TO_ADDR
// flags := list [ 4 ] ;
77369: LD_ADDR_VAR 0 6
77373: PUSH
77374: LD_VAR 0 1
77378: PUSH
77379: LD_INT 4
77381: ARRAY
77382: ST_TO_ADDR
// mined := [ ] ;
77383: LD_ADDR_VAR 0 27
77387: PUSH
77388: EMPTY
77389: ST_TO_ADDR
// bombed := [ ] ;
77390: LD_ADDR_VAR 0 28
77394: PUSH
77395: EMPTY
77396: ST_TO_ADDR
// healers := [ ] ;
77397: LD_ADDR_VAR 0 31
77401: PUSH
77402: EMPTY
77403: ST_TO_ADDR
// to_heal := [ ] ;
77404: LD_ADDR_VAR 0 30
77408: PUSH
77409: EMPTY
77410: ST_TO_ADDR
// repairs := [ ] ;
77411: LD_ADDR_VAR 0 33
77415: PUSH
77416: EMPTY
77417: ST_TO_ADDR
// to_repair := [ ] ;
77418: LD_ADDR_VAR 0 32
77422: PUSH
77423: EMPTY
77424: ST_TO_ADDR
// if not group or not path then
77425: LD_VAR 0 4
77429: NOT
77430: PUSH
77431: LD_VAR 0 5
77435: NOT
77436: OR
77437: IFFALSE 77441
// exit ;
77439: GO 81986
// side := GetSide ( group [ 1 ] ) ;
77441: LD_ADDR_VAR 0 35
77445: PUSH
77446: LD_VAR 0 4
77450: PUSH
77451: LD_INT 1
77453: ARRAY
77454: PPUSH
77455: CALL_OW 255
77459: ST_TO_ADDR
// if flags then
77460: LD_VAR 0 6
77464: IFFALSE 77608
// begin f_ignore_area := flags [ 1 ] ;
77466: LD_ADDR_VAR 0 17
77470: PUSH
77471: LD_VAR 0 6
77475: PUSH
77476: LD_INT 1
77478: ARRAY
77479: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77480: LD_ADDR_VAR 0 18
77484: PUSH
77485: LD_VAR 0 6
77489: PUSH
77490: LD_INT 2
77492: ARRAY
77493: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77494: LD_ADDR_VAR 0 19
77498: PUSH
77499: LD_VAR 0 6
77503: PUSH
77504: LD_INT 3
77506: ARRAY
77507: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77508: LD_ADDR_VAR 0 20
77512: PUSH
77513: LD_VAR 0 6
77517: PUSH
77518: LD_INT 4
77520: ARRAY
77521: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77522: LD_ADDR_VAR 0 21
77526: PUSH
77527: LD_VAR 0 6
77531: PUSH
77532: LD_INT 5
77534: ARRAY
77535: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77536: LD_ADDR_VAR 0 22
77540: PUSH
77541: LD_VAR 0 6
77545: PUSH
77546: LD_INT 6
77548: ARRAY
77549: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77550: LD_ADDR_VAR 0 23
77554: PUSH
77555: LD_VAR 0 6
77559: PUSH
77560: LD_INT 7
77562: ARRAY
77563: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77564: LD_ADDR_VAR 0 24
77568: PUSH
77569: LD_VAR 0 6
77573: PUSH
77574: LD_INT 8
77576: ARRAY
77577: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77578: LD_ADDR_VAR 0 25
77582: PUSH
77583: LD_VAR 0 6
77587: PUSH
77588: LD_INT 9
77590: ARRAY
77591: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77592: LD_ADDR_VAR 0 26
77596: PUSH
77597: LD_VAR 0 6
77601: PUSH
77602: LD_INT 10
77604: ARRAY
77605: ST_TO_ADDR
// end else
77606: GO 77688
// begin f_ignore_area := false ;
77608: LD_ADDR_VAR 0 17
77612: PUSH
77613: LD_INT 0
77615: ST_TO_ADDR
// f_capture := false ;
77616: LD_ADDR_VAR 0 18
77620: PUSH
77621: LD_INT 0
77623: ST_TO_ADDR
// f_ignore_civ := false ;
77624: LD_ADDR_VAR 0 19
77628: PUSH
77629: LD_INT 0
77631: ST_TO_ADDR
// f_murder := false ;
77632: LD_ADDR_VAR 0 20
77636: PUSH
77637: LD_INT 0
77639: ST_TO_ADDR
// f_mines := false ;
77640: LD_ADDR_VAR 0 21
77644: PUSH
77645: LD_INT 0
77647: ST_TO_ADDR
// f_repair := false ;
77648: LD_ADDR_VAR 0 22
77652: PUSH
77653: LD_INT 0
77655: ST_TO_ADDR
// f_heal := false ;
77656: LD_ADDR_VAR 0 23
77660: PUSH
77661: LD_INT 0
77663: ST_TO_ADDR
// f_spacetime := false ;
77664: LD_ADDR_VAR 0 24
77668: PUSH
77669: LD_INT 0
77671: ST_TO_ADDR
// f_attack_depot := false ;
77672: LD_ADDR_VAR 0 25
77676: PUSH
77677: LD_INT 0
77679: ST_TO_ADDR
// f_crawl := false ;
77680: LD_ADDR_VAR 0 26
77684: PUSH
77685: LD_INT 0
77687: ST_TO_ADDR
// end ; if f_heal then
77688: LD_VAR 0 23
77692: IFFALSE 77719
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77694: LD_ADDR_VAR 0 31
77698: PUSH
77699: LD_VAR 0 4
77703: PPUSH
77704: LD_INT 25
77706: PUSH
77707: LD_INT 4
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PPUSH
77714: CALL_OW 72
77718: ST_TO_ADDR
// if f_repair then
77719: LD_VAR 0 22
77723: IFFALSE 77750
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77725: LD_ADDR_VAR 0 33
77729: PUSH
77730: LD_VAR 0 4
77734: PPUSH
77735: LD_INT 25
77737: PUSH
77738: LD_INT 3
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PPUSH
77745: CALL_OW 72
77749: ST_TO_ADDR
// units_path := [ ] ;
77750: LD_ADDR_VAR 0 16
77754: PUSH
77755: EMPTY
77756: ST_TO_ADDR
// for i = 1 to group do
77757: LD_ADDR_VAR 0 7
77761: PUSH
77762: DOUBLE
77763: LD_INT 1
77765: DEC
77766: ST_TO_ADDR
77767: LD_VAR 0 4
77771: PUSH
77772: FOR_TO
77773: IFFALSE 77802
// units_path := Replace ( units_path , i , path ) ;
77775: LD_ADDR_VAR 0 16
77779: PUSH
77780: LD_VAR 0 16
77784: PPUSH
77785: LD_VAR 0 7
77789: PPUSH
77790: LD_VAR 0 5
77794: PPUSH
77795: CALL_OW 1
77799: ST_TO_ADDR
77800: GO 77772
77802: POP
77803: POP
// repeat for i = group downto 1 do
77804: LD_ADDR_VAR 0 7
77808: PUSH
77809: DOUBLE
77810: LD_VAR 0 4
77814: INC
77815: ST_TO_ADDR
77816: LD_INT 1
77818: PUSH
77819: FOR_DOWNTO
77820: IFFALSE 81942
// begin wait ( 5 ) ;
77822: LD_INT 5
77824: PPUSH
77825: CALL_OW 67
// tmp := [ ] ;
77829: LD_ADDR_VAR 0 14
77833: PUSH
77834: EMPTY
77835: ST_TO_ADDR
// attacking := false ;
77836: LD_ADDR_VAR 0 29
77840: PUSH
77841: LD_INT 0
77843: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77844: LD_VAR 0 4
77848: PUSH
77849: LD_VAR 0 7
77853: ARRAY
77854: PPUSH
77855: CALL_OW 301
77859: PUSH
77860: LD_VAR 0 4
77864: PUSH
77865: LD_VAR 0 7
77869: ARRAY
77870: NOT
77871: OR
77872: IFFALSE 77981
// begin if GetType ( group [ i ] ) = unit_human then
77874: LD_VAR 0 4
77878: PUSH
77879: LD_VAR 0 7
77883: ARRAY
77884: PPUSH
77885: CALL_OW 247
77889: PUSH
77890: LD_INT 1
77892: EQUAL
77893: IFFALSE 77939
// begin to_heal := to_heal diff group [ i ] ;
77895: LD_ADDR_VAR 0 30
77899: PUSH
77900: LD_VAR 0 30
77904: PUSH
77905: LD_VAR 0 4
77909: PUSH
77910: LD_VAR 0 7
77914: ARRAY
77915: DIFF
77916: ST_TO_ADDR
// healers := healers diff group [ i ] ;
77917: LD_ADDR_VAR 0 31
77921: PUSH
77922: LD_VAR 0 31
77926: PUSH
77927: LD_VAR 0 4
77931: PUSH
77932: LD_VAR 0 7
77936: ARRAY
77937: DIFF
77938: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
77939: LD_ADDR_VAR 0 4
77943: PUSH
77944: LD_VAR 0 4
77948: PPUSH
77949: LD_VAR 0 7
77953: PPUSH
77954: CALL_OW 3
77958: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
77959: LD_ADDR_VAR 0 16
77963: PUSH
77964: LD_VAR 0 16
77968: PPUSH
77969: LD_VAR 0 7
77973: PPUSH
77974: CALL_OW 3
77978: ST_TO_ADDR
// continue ;
77979: GO 77819
// end ; if f_repair then
77981: LD_VAR 0 22
77985: IFFALSE 78474
// begin if GetType ( group [ i ] ) = unit_vehicle then
77987: LD_VAR 0 4
77991: PUSH
77992: LD_VAR 0 7
77996: ARRAY
77997: PPUSH
77998: CALL_OW 247
78002: PUSH
78003: LD_INT 2
78005: EQUAL
78006: IFFALSE 78196
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78008: LD_VAR 0 4
78012: PUSH
78013: LD_VAR 0 7
78017: ARRAY
78018: PPUSH
78019: CALL_OW 256
78023: PUSH
78024: LD_INT 700
78026: LESS
78027: PUSH
78028: LD_VAR 0 4
78032: PUSH
78033: LD_VAR 0 7
78037: ARRAY
78038: PUSH
78039: LD_VAR 0 32
78043: IN
78044: NOT
78045: AND
78046: IFFALSE 78070
// to_repair := to_repair union group [ i ] ;
78048: LD_ADDR_VAR 0 32
78052: PUSH
78053: LD_VAR 0 32
78057: PUSH
78058: LD_VAR 0 4
78062: PUSH
78063: LD_VAR 0 7
78067: ARRAY
78068: UNION
78069: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78070: LD_VAR 0 4
78074: PUSH
78075: LD_VAR 0 7
78079: ARRAY
78080: PPUSH
78081: CALL_OW 256
78085: PUSH
78086: LD_INT 1000
78088: EQUAL
78089: PUSH
78090: LD_VAR 0 4
78094: PUSH
78095: LD_VAR 0 7
78099: ARRAY
78100: PUSH
78101: LD_VAR 0 32
78105: IN
78106: AND
78107: IFFALSE 78131
// to_repair := to_repair diff group [ i ] ;
78109: LD_ADDR_VAR 0 32
78113: PUSH
78114: LD_VAR 0 32
78118: PUSH
78119: LD_VAR 0 4
78123: PUSH
78124: LD_VAR 0 7
78128: ARRAY
78129: DIFF
78130: ST_TO_ADDR
// if group [ i ] in to_repair then
78131: LD_VAR 0 4
78135: PUSH
78136: LD_VAR 0 7
78140: ARRAY
78141: PUSH
78142: LD_VAR 0 32
78146: IN
78147: IFFALSE 78194
// begin if not IsInArea ( group [ i ] , f_repair ) then
78149: LD_VAR 0 4
78153: PUSH
78154: LD_VAR 0 7
78158: ARRAY
78159: PPUSH
78160: LD_VAR 0 22
78164: PPUSH
78165: CALL_OW 308
78169: NOT
78170: IFFALSE 78192
// ComMoveToArea ( group [ i ] , f_repair ) ;
78172: LD_VAR 0 4
78176: PUSH
78177: LD_VAR 0 7
78181: ARRAY
78182: PPUSH
78183: LD_VAR 0 22
78187: PPUSH
78188: CALL_OW 113
// continue ;
78192: GO 77819
// end ; end else
78194: GO 78474
// if group [ i ] in repairs then
78196: LD_VAR 0 4
78200: PUSH
78201: LD_VAR 0 7
78205: ARRAY
78206: PUSH
78207: LD_VAR 0 33
78211: IN
78212: IFFALSE 78474
// begin if IsInUnit ( group [ i ] ) then
78214: LD_VAR 0 4
78218: PUSH
78219: LD_VAR 0 7
78223: ARRAY
78224: PPUSH
78225: CALL_OW 310
78229: IFFALSE 78297
// begin z := IsInUnit ( group [ i ] ) ;
78231: LD_ADDR_VAR 0 13
78235: PUSH
78236: LD_VAR 0 4
78240: PUSH
78241: LD_VAR 0 7
78245: ARRAY
78246: PPUSH
78247: CALL_OW 310
78251: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78252: LD_VAR 0 13
78256: PUSH
78257: LD_VAR 0 32
78261: IN
78262: PUSH
78263: LD_VAR 0 13
78267: PPUSH
78268: LD_VAR 0 22
78272: PPUSH
78273: CALL_OW 308
78277: AND
78278: IFFALSE 78295
// ComExitVehicle ( group [ i ] ) ;
78280: LD_VAR 0 4
78284: PUSH
78285: LD_VAR 0 7
78289: ARRAY
78290: PPUSH
78291: CALL_OW 121
// end else
78295: GO 78474
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78297: LD_ADDR_VAR 0 13
78301: PUSH
78302: LD_VAR 0 4
78306: PPUSH
78307: LD_INT 95
78309: PUSH
78310: LD_VAR 0 22
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 58
78321: PUSH
78322: EMPTY
78323: LIST
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PPUSH
78329: CALL_OW 72
78333: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78334: LD_VAR 0 4
78338: PUSH
78339: LD_VAR 0 7
78343: ARRAY
78344: PPUSH
78345: CALL_OW 314
78349: NOT
78350: IFFALSE 78472
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78352: LD_ADDR_VAR 0 10
78356: PUSH
78357: LD_VAR 0 13
78361: PPUSH
78362: LD_VAR 0 4
78366: PUSH
78367: LD_VAR 0 7
78371: ARRAY
78372: PPUSH
78373: CALL_OW 74
78377: ST_TO_ADDR
// if not x then
78378: LD_VAR 0 10
78382: NOT
78383: IFFALSE 78387
// continue ;
78385: GO 77819
// if GetLives ( x ) < 1000 then
78387: LD_VAR 0 10
78391: PPUSH
78392: CALL_OW 256
78396: PUSH
78397: LD_INT 1000
78399: LESS
78400: IFFALSE 78424
// ComRepairVehicle ( group [ i ] , x ) else
78402: LD_VAR 0 4
78406: PUSH
78407: LD_VAR 0 7
78411: ARRAY
78412: PPUSH
78413: LD_VAR 0 10
78417: PPUSH
78418: CALL_OW 129
78422: GO 78472
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78424: LD_VAR 0 23
78428: PUSH
78429: LD_VAR 0 4
78433: PUSH
78434: LD_VAR 0 7
78438: ARRAY
78439: PPUSH
78440: CALL_OW 256
78444: PUSH
78445: LD_INT 1000
78447: LESS
78448: AND
78449: NOT
78450: IFFALSE 78472
// ComEnterUnit ( group [ i ] , x ) ;
78452: LD_VAR 0 4
78456: PUSH
78457: LD_VAR 0 7
78461: ARRAY
78462: PPUSH
78463: LD_VAR 0 10
78467: PPUSH
78468: CALL_OW 120
// end ; continue ;
78472: GO 77819
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78474: LD_VAR 0 23
78478: PUSH
78479: LD_VAR 0 4
78483: PUSH
78484: LD_VAR 0 7
78488: ARRAY
78489: PPUSH
78490: CALL_OW 247
78494: PUSH
78495: LD_INT 1
78497: EQUAL
78498: AND
78499: IFFALSE 78977
// begin if group [ i ] in healers then
78501: LD_VAR 0 4
78505: PUSH
78506: LD_VAR 0 7
78510: ARRAY
78511: PUSH
78512: LD_VAR 0 31
78516: IN
78517: IFFALSE 78790
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78519: LD_VAR 0 4
78523: PUSH
78524: LD_VAR 0 7
78528: ARRAY
78529: PPUSH
78530: LD_VAR 0 23
78534: PPUSH
78535: CALL_OW 308
78539: NOT
78540: PUSH
78541: LD_VAR 0 4
78545: PUSH
78546: LD_VAR 0 7
78550: ARRAY
78551: PPUSH
78552: CALL_OW 314
78556: NOT
78557: AND
78558: IFFALSE 78582
// ComMoveToArea ( group [ i ] , f_heal ) else
78560: LD_VAR 0 4
78564: PUSH
78565: LD_VAR 0 7
78569: ARRAY
78570: PPUSH
78571: LD_VAR 0 23
78575: PPUSH
78576: CALL_OW 113
78580: GO 78788
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78582: LD_VAR 0 4
78586: PUSH
78587: LD_VAR 0 7
78591: ARRAY
78592: PPUSH
78593: CALL 43169 0 1
78597: PPUSH
78598: CALL_OW 256
78602: PUSH
78603: LD_INT 1000
78605: EQUAL
78606: IFFALSE 78625
// ComStop ( group [ i ] ) else
78608: LD_VAR 0 4
78612: PUSH
78613: LD_VAR 0 7
78617: ARRAY
78618: PPUSH
78619: CALL_OW 141
78623: GO 78788
// if not HasTask ( group [ i ] ) and to_heal then
78625: LD_VAR 0 4
78629: PUSH
78630: LD_VAR 0 7
78634: ARRAY
78635: PPUSH
78636: CALL_OW 314
78640: NOT
78641: PUSH
78642: LD_VAR 0 30
78646: AND
78647: IFFALSE 78788
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78649: LD_ADDR_VAR 0 13
78653: PUSH
78654: LD_VAR 0 30
78658: PPUSH
78659: LD_INT 3
78661: PUSH
78662: LD_INT 54
78664: PUSH
78665: EMPTY
78666: LIST
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PPUSH
78672: CALL_OW 72
78676: PPUSH
78677: LD_VAR 0 4
78681: PUSH
78682: LD_VAR 0 7
78686: ARRAY
78687: PPUSH
78688: CALL_OW 74
78692: ST_TO_ADDR
// if z then
78693: LD_VAR 0 13
78697: IFFALSE 78788
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78699: LD_INT 91
78701: PUSH
78702: LD_VAR 0 13
78706: PUSH
78707: LD_INT 10
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 81
78717: PUSH
78718: LD_VAR 0 13
78722: PPUSH
78723: CALL_OW 255
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PPUSH
78736: CALL_OW 69
78740: PUSH
78741: LD_INT 0
78743: EQUAL
78744: IFFALSE 78768
// ComHeal ( group [ i ] , z ) else
78746: LD_VAR 0 4
78750: PUSH
78751: LD_VAR 0 7
78755: ARRAY
78756: PPUSH
78757: LD_VAR 0 13
78761: PPUSH
78762: CALL_OW 128
78766: GO 78788
// ComMoveToArea ( group [ i ] , f_heal ) ;
78768: LD_VAR 0 4
78772: PUSH
78773: LD_VAR 0 7
78777: ARRAY
78778: PPUSH
78779: LD_VAR 0 23
78783: PPUSH
78784: CALL_OW 113
// end ; continue ;
78788: GO 77819
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78790: LD_VAR 0 4
78794: PUSH
78795: LD_VAR 0 7
78799: ARRAY
78800: PPUSH
78801: CALL_OW 256
78805: PUSH
78806: LD_INT 700
78808: LESS
78809: PUSH
78810: LD_VAR 0 4
78814: PUSH
78815: LD_VAR 0 7
78819: ARRAY
78820: PUSH
78821: LD_VAR 0 30
78825: IN
78826: NOT
78827: AND
78828: IFFALSE 78852
// to_heal := to_heal union group [ i ] ;
78830: LD_ADDR_VAR 0 30
78834: PUSH
78835: LD_VAR 0 30
78839: PUSH
78840: LD_VAR 0 4
78844: PUSH
78845: LD_VAR 0 7
78849: ARRAY
78850: UNION
78851: ST_TO_ADDR
// if group [ i ] in to_heal then
78852: LD_VAR 0 4
78856: PUSH
78857: LD_VAR 0 7
78861: ARRAY
78862: PUSH
78863: LD_VAR 0 30
78867: IN
78868: IFFALSE 78977
// begin if GetLives ( group [ i ] ) = 1000 then
78870: LD_VAR 0 4
78874: PUSH
78875: LD_VAR 0 7
78879: ARRAY
78880: PPUSH
78881: CALL_OW 256
78885: PUSH
78886: LD_INT 1000
78888: EQUAL
78889: IFFALSE 78915
// to_heal := to_heal diff group [ i ] else
78891: LD_ADDR_VAR 0 30
78895: PUSH
78896: LD_VAR 0 30
78900: PUSH
78901: LD_VAR 0 4
78905: PUSH
78906: LD_VAR 0 7
78910: ARRAY
78911: DIFF
78912: ST_TO_ADDR
78913: GO 78977
// begin if not IsInArea ( group [ i ] , to_heal ) then
78915: LD_VAR 0 4
78919: PUSH
78920: LD_VAR 0 7
78924: ARRAY
78925: PPUSH
78926: LD_VAR 0 30
78930: PPUSH
78931: CALL_OW 308
78935: NOT
78936: IFFALSE 78960
// ComMoveToArea ( group [ i ] , f_heal ) else
78938: LD_VAR 0 4
78942: PUSH
78943: LD_VAR 0 7
78947: ARRAY
78948: PPUSH
78949: LD_VAR 0 23
78953: PPUSH
78954: CALL_OW 113
78958: GO 78975
// ComHold ( group [ i ] ) ;
78960: LD_VAR 0 4
78964: PUSH
78965: LD_VAR 0 7
78969: ARRAY
78970: PPUSH
78971: CALL_OW 140
// continue ;
78975: GO 77819
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
78977: LD_VAR 0 4
78981: PUSH
78982: LD_VAR 0 7
78986: ARRAY
78987: PPUSH
78988: LD_INT 10
78990: PPUSH
78991: CALL 41589 0 2
78995: NOT
78996: PUSH
78997: LD_VAR 0 16
79001: PUSH
79002: LD_VAR 0 7
79006: ARRAY
79007: PUSH
79008: EMPTY
79009: EQUAL
79010: NOT
79011: AND
79012: IFFALSE 79278
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79014: LD_VAR 0 4
79018: PUSH
79019: LD_VAR 0 7
79023: ARRAY
79024: PPUSH
79025: CALL_OW 262
79029: PUSH
79030: LD_INT 1
79032: PUSH
79033: LD_INT 2
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: IN
79040: IFFALSE 79081
// if GetFuel ( group [ i ] ) < 10 then
79042: LD_VAR 0 4
79046: PUSH
79047: LD_VAR 0 7
79051: ARRAY
79052: PPUSH
79053: CALL_OW 261
79057: PUSH
79058: LD_INT 10
79060: LESS
79061: IFFALSE 79081
// SetFuel ( group [ i ] , 12 ) ;
79063: LD_VAR 0 4
79067: PUSH
79068: LD_VAR 0 7
79072: ARRAY
79073: PPUSH
79074: LD_INT 12
79076: PPUSH
79077: CALL_OW 240
// if units_path [ i ] then
79081: LD_VAR 0 16
79085: PUSH
79086: LD_VAR 0 7
79090: ARRAY
79091: IFFALSE 79276
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79093: LD_VAR 0 4
79097: PUSH
79098: LD_VAR 0 7
79102: ARRAY
79103: PPUSH
79104: LD_VAR 0 16
79108: PUSH
79109: LD_VAR 0 7
79113: ARRAY
79114: PUSH
79115: LD_INT 1
79117: ARRAY
79118: PUSH
79119: LD_INT 1
79121: ARRAY
79122: PPUSH
79123: LD_VAR 0 16
79127: PUSH
79128: LD_VAR 0 7
79132: ARRAY
79133: PUSH
79134: LD_INT 1
79136: ARRAY
79137: PUSH
79138: LD_INT 2
79140: ARRAY
79141: PPUSH
79142: CALL_OW 297
79146: PUSH
79147: LD_INT 6
79149: GREATER
79150: IFFALSE 79225
// begin if not HasTask ( group [ i ] ) then
79152: LD_VAR 0 4
79156: PUSH
79157: LD_VAR 0 7
79161: ARRAY
79162: PPUSH
79163: CALL_OW 314
79167: NOT
79168: IFFALSE 79223
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79170: LD_VAR 0 4
79174: PUSH
79175: LD_VAR 0 7
79179: ARRAY
79180: PPUSH
79181: LD_VAR 0 16
79185: PUSH
79186: LD_VAR 0 7
79190: ARRAY
79191: PUSH
79192: LD_INT 1
79194: ARRAY
79195: PUSH
79196: LD_INT 1
79198: ARRAY
79199: PPUSH
79200: LD_VAR 0 16
79204: PUSH
79205: LD_VAR 0 7
79209: ARRAY
79210: PUSH
79211: LD_INT 1
79213: ARRAY
79214: PUSH
79215: LD_INT 2
79217: ARRAY
79218: PPUSH
79219: CALL_OW 114
// end else
79223: GO 79276
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79225: LD_ADDR_VAR 0 15
79229: PUSH
79230: LD_VAR 0 16
79234: PUSH
79235: LD_VAR 0 7
79239: ARRAY
79240: PPUSH
79241: LD_INT 1
79243: PPUSH
79244: CALL_OW 3
79248: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79249: LD_ADDR_VAR 0 16
79253: PUSH
79254: LD_VAR 0 16
79258: PPUSH
79259: LD_VAR 0 7
79263: PPUSH
79264: LD_VAR 0 15
79268: PPUSH
79269: CALL_OW 1
79273: ST_TO_ADDR
// continue ;
79274: GO 77819
// end ; end ; end else
79276: GO 81940
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79278: LD_ADDR_VAR 0 14
79282: PUSH
79283: LD_INT 81
79285: PUSH
79286: LD_VAR 0 4
79290: PUSH
79291: LD_VAR 0 7
79295: ARRAY
79296: PPUSH
79297: CALL_OW 255
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PPUSH
79306: CALL_OW 69
79310: ST_TO_ADDR
// if not tmp then
79311: LD_VAR 0 14
79315: NOT
79316: IFFALSE 79320
// continue ;
79318: GO 77819
// if f_ignore_area then
79320: LD_VAR 0 17
79324: IFFALSE 79412
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79326: LD_ADDR_VAR 0 15
79330: PUSH
79331: LD_VAR 0 14
79335: PPUSH
79336: LD_INT 3
79338: PUSH
79339: LD_INT 92
79341: PUSH
79342: LD_VAR 0 17
79346: PUSH
79347: LD_INT 1
79349: ARRAY
79350: PUSH
79351: LD_VAR 0 17
79355: PUSH
79356: LD_INT 2
79358: ARRAY
79359: PUSH
79360: LD_VAR 0 17
79364: PUSH
79365: LD_INT 3
79367: ARRAY
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PPUSH
79379: CALL_OW 72
79383: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79384: LD_VAR 0 14
79388: PUSH
79389: LD_VAR 0 15
79393: DIFF
79394: IFFALSE 79412
// tmp := tmp diff tmp2 ;
79396: LD_ADDR_VAR 0 14
79400: PUSH
79401: LD_VAR 0 14
79405: PUSH
79406: LD_VAR 0 15
79410: DIFF
79411: ST_TO_ADDR
// end ; if not f_murder then
79412: LD_VAR 0 20
79416: NOT
79417: IFFALSE 79475
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79419: LD_ADDR_VAR 0 15
79423: PUSH
79424: LD_VAR 0 14
79428: PPUSH
79429: LD_INT 3
79431: PUSH
79432: LD_INT 50
79434: PUSH
79435: EMPTY
79436: LIST
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PPUSH
79442: CALL_OW 72
79446: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79447: LD_VAR 0 14
79451: PUSH
79452: LD_VAR 0 15
79456: DIFF
79457: IFFALSE 79475
// tmp := tmp diff tmp2 ;
79459: LD_ADDR_VAR 0 14
79463: PUSH
79464: LD_VAR 0 14
79468: PUSH
79469: LD_VAR 0 15
79473: DIFF
79474: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79475: LD_ADDR_VAR 0 14
79479: PUSH
79480: LD_VAR 0 4
79484: PUSH
79485: LD_VAR 0 7
79489: ARRAY
79490: PPUSH
79491: LD_VAR 0 14
79495: PPUSH
79496: LD_INT 1
79498: PPUSH
79499: LD_INT 1
79501: PPUSH
79502: CALL 15232 0 4
79506: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79507: LD_VAR 0 4
79511: PUSH
79512: LD_VAR 0 7
79516: ARRAY
79517: PPUSH
79518: CALL_OW 257
79522: PUSH
79523: LD_INT 1
79525: EQUAL
79526: IFFALSE 79974
// begin if WantPlant ( group [ i ] ) then
79528: LD_VAR 0 4
79532: PUSH
79533: LD_VAR 0 7
79537: ARRAY
79538: PPUSH
79539: CALL 14733 0 1
79543: IFFALSE 79547
// continue ;
79545: GO 77819
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79547: LD_VAR 0 18
79551: PUSH
79552: LD_VAR 0 4
79556: PUSH
79557: LD_VAR 0 7
79561: ARRAY
79562: PPUSH
79563: CALL_OW 310
79567: NOT
79568: AND
79569: PUSH
79570: LD_VAR 0 14
79574: PUSH
79575: LD_INT 1
79577: ARRAY
79578: PUSH
79579: LD_VAR 0 14
79583: PPUSH
79584: LD_INT 21
79586: PUSH
79587: LD_INT 2
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 58
79596: PUSH
79597: EMPTY
79598: LIST
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PPUSH
79604: CALL_OW 72
79608: IN
79609: AND
79610: IFFALSE 79646
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79612: LD_VAR 0 4
79616: PUSH
79617: LD_VAR 0 7
79621: ARRAY
79622: PPUSH
79623: LD_VAR 0 14
79627: PUSH
79628: LD_INT 1
79630: ARRAY
79631: PPUSH
79632: CALL_OW 120
// attacking := true ;
79636: LD_ADDR_VAR 0 29
79640: PUSH
79641: LD_INT 1
79643: ST_TO_ADDR
// continue ;
79644: GO 77819
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79646: LD_VAR 0 26
79650: PUSH
79651: LD_VAR 0 4
79655: PUSH
79656: LD_VAR 0 7
79660: ARRAY
79661: PPUSH
79662: CALL_OW 257
79666: PUSH
79667: LD_INT 1
79669: EQUAL
79670: AND
79671: PUSH
79672: LD_VAR 0 4
79676: PUSH
79677: LD_VAR 0 7
79681: ARRAY
79682: PPUSH
79683: CALL_OW 256
79687: PUSH
79688: LD_INT 800
79690: LESS
79691: AND
79692: PUSH
79693: LD_VAR 0 4
79697: PUSH
79698: LD_VAR 0 7
79702: ARRAY
79703: PPUSH
79704: CALL_OW 318
79708: NOT
79709: AND
79710: IFFALSE 79727
// ComCrawl ( group [ i ] ) ;
79712: LD_VAR 0 4
79716: PUSH
79717: LD_VAR 0 7
79721: ARRAY
79722: PPUSH
79723: CALL_OW 137
// if f_mines then
79727: LD_VAR 0 21
79731: IFFALSE 79974
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79733: LD_VAR 0 14
79737: PUSH
79738: LD_INT 1
79740: ARRAY
79741: PPUSH
79742: CALL_OW 247
79746: PUSH
79747: LD_INT 3
79749: EQUAL
79750: PUSH
79751: LD_VAR 0 14
79755: PUSH
79756: LD_INT 1
79758: ARRAY
79759: PUSH
79760: LD_VAR 0 27
79764: IN
79765: NOT
79766: AND
79767: IFFALSE 79974
// begin x := GetX ( tmp [ 1 ] ) ;
79769: LD_ADDR_VAR 0 10
79773: PUSH
79774: LD_VAR 0 14
79778: PUSH
79779: LD_INT 1
79781: ARRAY
79782: PPUSH
79783: CALL_OW 250
79787: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79788: LD_ADDR_VAR 0 11
79792: PUSH
79793: LD_VAR 0 14
79797: PUSH
79798: LD_INT 1
79800: ARRAY
79801: PPUSH
79802: CALL_OW 251
79806: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79807: LD_ADDR_VAR 0 12
79811: PUSH
79812: LD_VAR 0 4
79816: PUSH
79817: LD_VAR 0 7
79821: ARRAY
79822: PPUSH
79823: CALL 41674 0 1
79827: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79828: LD_VAR 0 4
79832: PUSH
79833: LD_VAR 0 7
79837: ARRAY
79838: PPUSH
79839: LD_VAR 0 10
79843: PPUSH
79844: LD_VAR 0 11
79848: PPUSH
79849: LD_VAR 0 14
79853: PUSH
79854: LD_INT 1
79856: ARRAY
79857: PPUSH
79858: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79862: LD_VAR 0 4
79866: PUSH
79867: LD_VAR 0 7
79871: ARRAY
79872: PPUSH
79873: LD_VAR 0 10
79877: PPUSH
79878: LD_VAR 0 12
79882: PPUSH
79883: LD_INT 7
79885: PPUSH
79886: CALL_OW 272
79890: PPUSH
79891: LD_VAR 0 11
79895: PPUSH
79896: LD_VAR 0 12
79900: PPUSH
79901: LD_INT 7
79903: PPUSH
79904: CALL_OW 273
79908: PPUSH
79909: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
79913: LD_VAR 0 4
79917: PUSH
79918: LD_VAR 0 7
79922: ARRAY
79923: PPUSH
79924: LD_INT 71
79926: PPUSH
79927: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
79931: LD_ADDR_VAR 0 27
79935: PUSH
79936: LD_VAR 0 27
79940: PPUSH
79941: LD_VAR 0 27
79945: PUSH
79946: LD_INT 1
79948: PLUS
79949: PPUSH
79950: LD_VAR 0 14
79954: PUSH
79955: LD_INT 1
79957: ARRAY
79958: PPUSH
79959: CALL_OW 1
79963: ST_TO_ADDR
// attacking := true ;
79964: LD_ADDR_VAR 0 29
79968: PUSH
79969: LD_INT 1
79971: ST_TO_ADDR
// continue ;
79972: GO 77819
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
79974: LD_VAR 0 4
79978: PUSH
79979: LD_VAR 0 7
79983: ARRAY
79984: PPUSH
79985: CALL_OW 257
79989: PUSH
79990: LD_INT 17
79992: EQUAL
79993: PUSH
79994: LD_VAR 0 4
79998: PUSH
79999: LD_VAR 0 7
80003: ARRAY
80004: PPUSH
80005: CALL_OW 110
80009: PUSH
80010: LD_INT 71
80012: EQUAL
80013: NOT
80014: AND
80015: IFFALSE 80161
// begin attacking := false ;
80017: LD_ADDR_VAR 0 29
80021: PUSH
80022: LD_INT 0
80024: ST_TO_ADDR
// k := 5 ;
80025: LD_ADDR_VAR 0 9
80029: PUSH
80030: LD_INT 5
80032: ST_TO_ADDR
// if tmp < k then
80033: LD_VAR 0 14
80037: PUSH
80038: LD_VAR 0 9
80042: LESS
80043: IFFALSE 80055
// k := tmp ;
80045: LD_ADDR_VAR 0 9
80049: PUSH
80050: LD_VAR 0 14
80054: ST_TO_ADDR
// for j = 1 to k do
80055: LD_ADDR_VAR 0 8
80059: PUSH
80060: DOUBLE
80061: LD_INT 1
80063: DEC
80064: ST_TO_ADDR
80065: LD_VAR 0 9
80069: PUSH
80070: FOR_TO
80071: IFFALSE 80159
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80073: LD_VAR 0 14
80077: PUSH
80078: LD_VAR 0 8
80082: ARRAY
80083: PUSH
80084: LD_VAR 0 14
80088: PPUSH
80089: LD_INT 58
80091: PUSH
80092: EMPTY
80093: LIST
80094: PPUSH
80095: CALL_OW 72
80099: IN
80100: NOT
80101: IFFALSE 80157
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80103: LD_VAR 0 4
80107: PUSH
80108: LD_VAR 0 7
80112: ARRAY
80113: PPUSH
80114: LD_VAR 0 14
80118: PUSH
80119: LD_VAR 0 8
80123: ARRAY
80124: PPUSH
80125: CALL_OW 115
// attacking := true ;
80129: LD_ADDR_VAR 0 29
80133: PUSH
80134: LD_INT 1
80136: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80137: LD_VAR 0 4
80141: PUSH
80142: LD_VAR 0 7
80146: ARRAY
80147: PPUSH
80148: LD_INT 71
80150: PPUSH
80151: CALL_OW 109
// continue ;
80155: GO 80070
// end ; end ;
80157: GO 80070
80159: POP
80160: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80161: LD_VAR 0 4
80165: PUSH
80166: LD_VAR 0 7
80170: ARRAY
80171: PPUSH
80172: CALL_OW 257
80176: PUSH
80177: LD_INT 8
80179: EQUAL
80180: PUSH
80181: LD_VAR 0 4
80185: PUSH
80186: LD_VAR 0 7
80190: ARRAY
80191: PPUSH
80192: CALL_OW 264
80196: PUSH
80197: LD_INT 28
80199: PUSH
80200: LD_INT 45
80202: PUSH
80203: LD_INT 7
80205: PUSH
80206: LD_INT 47
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: IN
80215: OR
80216: IFFALSE 80472
// begin attacking := false ;
80218: LD_ADDR_VAR 0 29
80222: PUSH
80223: LD_INT 0
80225: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80226: LD_VAR 0 14
80230: PUSH
80231: LD_INT 1
80233: ARRAY
80234: PPUSH
80235: CALL_OW 266
80239: PUSH
80240: LD_INT 32
80242: PUSH
80243: LD_INT 31
80245: PUSH
80246: LD_INT 33
80248: PUSH
80249: LD_INT 4
80251: PUSH
80252: LD_INT 5
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: IN
80262: IFFALSE 80448
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80264: LD_ADDR_VAR 0 9
80268: PUSH
80269: LD_VAR 0 14
80273: PUSH
80274: LD_INT 1
80276: ARRAY
80277: PPUSH
80278: CALL_OW 266
80282: PPUSH
80283: LD_VAR 0 14
80287: PUSH
80288: LD_INT 1
80290: ARRAY
80291: PPUSH
80292: CALL_OW 250
80296: PPUSH
80297: LD_VAR 0 14
80301: PUSH
80302: LD_INT 1
80304: ARRAY
80305: PPUSH
80306: CALL_OW 251
80310: PPUSH
80311: LD_VAR 0 14
80315: PUSH
80316: LD_INT 1
80318: ARRAY
80319: PPUSH
80320: CALL_OW 254
80324: PPUSH
80325: LD_VAR 0 14
80329: PUSH
80330: LD_INT 1
80332: ARRAY
80333: PPUSH
80334: CALL_OW 248
80338: PPUSH
80339: LD_INT 0
80341: PPUSH
80342: CALL 23044 0 6
80346: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80347: LD_ADDR_VAR 0 8
80351: PUSH
80352: LD_VAR 0 4
80356: PUSH
80357: LD_VAR 0 7
80361: ARRAY
80362: PPUSH
80363: LD_VAR 0 9
80367: PPUSH
80368: CALL 41714 0 2
80372: ST_TO_ADDR
// if j then
80373: LD_VAR 0 8
80377: IFFALSE 80446
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80379: LD_VAR 0 8
80383: PUSH
80384: LD_INT 1
80386: ARRAY
80387: PPUSH
80388: LD_VAR 0 8
80392: PUSH
80393: LD_INT 2
80395: ARRAY
80396: PPUSH
80397: CALL_OW 488
80401: IFFALSE 80446
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80403: LD_VAR 0 4
80407: PUSH
80408: LD_VAR 0 7
80412: ARRAY
80413: PPUSH
80414: LD_VAR 0 8
80418: PUSH
80419: LD_INT 1
80421: ARRAY
80422: PPUSH
80423: LD_VAR 0 8
80427: PUSH
80428: LD_INT 2
80430: ARRAY
80431: PPUSH
80432: CALL_OW 116
// attacking := true ;
80436: LD_ADDR_VAR 0 29
80440: PUSH
80441: LD_INT 1
80443: ST_TO_ADDR
// continue ;
80444: GO 77819
// end ; end else
80446: GO 80472
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80448: LD_VAR 0 4
80452: PUSH
80453: LD_VAR 0 7
80457: ARRAY
80458: PPUSH
80459: LD_VAR 0 14
80463: PUSH
80464: LD_INT 1
80466: ARRAY
80467: PPUSH
80468: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80472: LD_VAR 0 4
80476: PUSH
80477: LD_VAR 0 7
80481: ARRAY
80482: PPUSH
80483: CALL_OW 265
80487: PUSH
80488: LD_INT 11
80490: EQUAL
80491: IFFALSE 80769
// begin k := 10 ;
80493: LD_ADDR_VAR 0 9
80497: PUSH
80498: LD_INT 10
80500: ST_TO_ADDR
// x := 0 ;
80501: LD_ADDR_VAR 0 10
80505: PUSH
80506: LD_INT 0
80508: ST_TO_ADDR
// if tmp < k then
80509: LD_VAR 0 14
80513: PUSH
80514: LD_VAR 0 9
80518: LESS
80519: IFFALSE 80531
// k := tmp ;
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 14
80530: ST_TO_ADDR
// for j = k downto 1 do
80531: LD_ADDR_VAR 0 8
80535: PUSH
80536: DOUBLE
80537: LD_VAR 0 9
80541: INC
80542: ST_TO_ADDR
80543: LD_INT 1
80545: PUSH
80546: FOR_DOWNTO
80547: IFFALSE 80622
// begin if GetType ( tmp [ j ] ) = unit_human then
80549: LD_VAR 0 14
80553: PUSH
80554: LD_VAR 0 8
80558: ARRAY
80559: PPUSH
80560: CALL_OW 247
80564: PUSH
80565: LD_INT 1
80567: EQUAL
80568: IFFALSE 80620
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80570: LD_VAR 0 4
80574: PUSH
80575: LD_VAR 0 7
80579: ARRAY
80580: PPUSH
80581: LD_VAR 0 14
80585: PUSH
80586: LD_VAR 0 8
80590: ARRAY
80591: PPUSH
80592: CALL 41985 0 2
// x := tmp [ j ] ;
80596: LD_ADDR_VAR 0 10
80600: PUSH
80601: LD_VAR 0 14
80605: PUSH
80606: LD_VAR 0 8
80610: ARRAY
80611: ST_TO_ADDR
// attacking := true ;
80612: LD_ADDR_VAR 0 29
80616: PUSH
80617: LD_INT 1
80619: ST_TO_ADDR
// end ; end ;
80620: GO 80546
80622: POP
80623: POP
// if not x then
80624: LD_VAR 0 10
80628: NOT
80629: IFFALSE 80769
// begin attacking := true ;
80631: LD_ADDR_VAR 0 29
80635: PUSH
80636: LD_INT 1
80638: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80639: LD_VAR 0 4
80643: PUSH
80644: LD_VAR 0 7
80648: ARRAY
80649: PPUSH
80650: CALL_OW 250
80654: PPUSH
80655: LD_VAR 0 4
80659: PUSH
80660: LD_VAR 0 7
80664: ARRAY
80665: PPUSH
80666: CALL_OW 251
80670: PPUSH
80671: CALL_OW 546
80675: PUSH
80676: LD_INT 2
80678: ARRAY
80679: PUSH
80680: LD_VAR 0 14
80684: PUSH
80685: LD_INT 1
80687: ARRAY
80688: PPUSH
80689: CALL_OW 250
80693: PPUSH
80694: LD_VAR 0 14
80698: PUSH
80699: LD_INT 1
80701: ARRAY
80702: PPUSH
80703: CALL_OW 251
80707: PPUSH
80708: CALL_OW 546
80712: PUSH
80713: LD_INT 2
80715: ARRAY
80716: EQUAL
80717: IFFALSE 80745
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80719: LD_VAR 0 4
80723: PUSH
80724: LD_VAR 0 7
80728: ARRAY
80729: PPUSH
80730: LD_VAR 0 14
80734: PUSH
80735: LD_INT 1
80737: ARRAY
80738: PPUSH
80739: CALL 41985 0 2
80743: GO 80769
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80745: LD_VAR 0 4
80749: PUSH
80750: LD_VAR 0 7
80754: ARRAY
80755: PPUSH
80756: LD_VAR 0 14
80760: PUSH
80761: LD_INT 1
80763: ARRAY
80764: PPUSH
80765: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80769: LD_VAR 0 4
80773: PUSH
80774: LD_VAR 0 7
80778: ARRAY
80779: PPUSH
80780: CALL_OW 264
80784: PUSH
80785: LD_INT 29
80787: EQUAL
80788: IFFALSE 81154
// begin if WantsToAttack ( group [ i ] ) in bombed then
80790: LD_VAR 0 4
80794: PUSH
80795: LD_VAR 0 7
80799: ARRAY
80800: PPUSH
80801: CALL_OW 319
80805: PUSH
80806: LD_VAR 0 28
80810: IN
80811: IFFALSE 80815
// continue ;
80813: GO 77819
// k := 8 ;
80815: LD_ADDR_VAR 0 9
80819: PUSH
80820: LD_INT 8
80822: ST_TO_ADDR
// x := 0 ;
80823: LD_ADDR_VAR 0 10
80827: PUSH
80828: LD_INT 0
80830: ST_TO_ADDR
// if tmp < k then
80831: LD_VAR 0 14
80835: PUSH
80836: LD_VAR 0 9
80840: LESS
80841: IFFALSE 80853
// k := tmp ;
80843: LD_ADDR_VAR 0 9
80847: PUSH
80848: LD_VAR 0 14
80852: ST_TO_ADDR
// for j = 1 to k do
80853: LD_ADDR_VAR 0 8
80857: PUSH
80858: DOUBLE
80859: LD_INT 1
80861: DEC
80862: ST_TO_ADDR
80863: LD_VAR 0 9
80867: PUSH
80868: FOR_TO
80869: IFFALSE 81001
// begin if GetType ( tmp [ j ] ) = unit_building then
80871: LD_VAR 0 14
80875: PUSH
80876: LD_VAR 0 8
80880: ARRAY
80881: PPUSH
80882: CALL_OW 247
80886: PUSH
80887: LD_INT 3
80889: EQUAL
80890: IFFALSE 80999
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80892: LD_VAR 0 14
80896: PUSH
80897: LD_VAR 0 8
80901: ARRAY
80902: PUSH
80903: LD_VAR 0 28
80907: IN
80908: NOT
80909: PUSH
80910: LD_VAR 0 14
80914: PUSH
80915: LD_VAR 0 8
80919: ARRAY
80920: PPUSH
80921: CALL_OW 313
80925: AND
80926: IFFALSE 80999
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80928: LD_VAR 0 4
80932: PUSH
80933: LD_VAR 0 7
80937: ARRAY
80938: PPUSH
80939: LD_VAR 0 14
80943: PUSH
80944: LD_VAR 0 8
80948: ARRAY
80949: PPUSH
80950: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
80954: LD_ADDR_VAR 0 28
80958: PUSH
80959: LD_VAR 0 28
80963: PPUSH
80964: LD_VAR 0 28
80968: PUSH
80969: LD_INT 1
80971: PLUS
80972: PPUSH
80973: LD_VAR 0 14
80977: PUSH
80978: LD_VAR 0 8
80982: ARRAY
80983: PPUSH
80984: CALL_OW 1
80988: ST_TO_ADDR
// attacking := true ;
80989: LD_ADDR_VAR 0 29
80993: PUSH
80994: LD_INT 1
80996: ST_TO_ADDR
// break ;
80997: GO 81001
// end ; end ;
80999: GO 80868
81001: POP
81002: POP
// if not attacking and f_attack_depot then
81003: LD_VAR 0 29
81007: NOT
81008: PUSH
81009: LD_VAR 0 25
81013: AND
81014: IFFALSE 81109
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81016: LD_ADDR_VAR 0 13
81020: PUSH
81021: LD_VAR 0 14
81025: PPUSH
81026: LD_INT 2
81028: PUSH
81029: LD_INT 30
81031: PUSH
81032: LD_INT 0
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 30
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: LIST
81053: PPUSH
81054: CALL_OW 72
81058: ST_TO_ADDR
// if z then
81059: LD_VAR 0 13
81063: IFFALSE 81109
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81065: LD_VAR 0 4
81069: PUSH
81070: LD_VAR 0 7
81074: ARRAY
81075: PPUSH
81076: LD_VAR 0 13
81080: PPUSH
81081: LD_VAR 0 4
81085: PUSH
81086: LD_VAR 0 7
81090: ARRAY
81091: PPUSH
81092: CALL_OW 74
81096: PPUSH
81097: CALL_OW 115
// attacking := true ;
81101: LD_ADDR_VAR 0 29
81105: PUSH
81106: LD_INT 1
81108: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81109: LD_VAR 0 4
81113: PUSH
81114: LD_VAR 0 7
81118: ARRAY
81119: PPUSH
81120: CALL_OW 256
81124: PUSH
81125: LD_INT 500
81127: LESS
81128: IFFALSE 81154
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81130: LD_VAR 0 4
81134: PUSH
81135: LD_VAR 0 7
81139: ARRAY
81140: PPUSH
81141: LD_VAR 0 14
81145: PUSH
81146: LD_INT 1
81148: ARRAY
81149: PPUSH
81150: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81154: LD_VAR 0 4
81158: PUSH
81159: LD_VAR 0 7
81163: ARRAY
81164: PPUSH
81165: CALL_OW 264
81169: PUSH
81170: LD_INT 49
81172: EQUAL
81173: IFFALSE 81294
// begin if not HasTask ( group [ i ] ) then
81175: LD_VAR 0 4
81179: PUSH
81180: LD_VAR 0 7
81184: ARRAY
81185: PPUSH
81186: CALL_OW 314
81190: NOT
81191: IFFALSE 81294
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81193: LD_ADDR_VAR 0 9
81197: PUSH
81198: LD_INT 81
81200: PUSH
81201: LD_VAR 0 4
81205: PUSH
81206: LD_VAR 0 7
81210: ARRAY
81211: PPUSH
81212: CALL_OW 255
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PPUSH
81221: CALL_OW 69
81225: PPUSH
81226: LD_VAR 0 4
81230: PUSH
81231: LD_VAR 0 7
81235: ARRAY
81236: PPUSH
81237: CALL_OW 74
81241: ST_TO_ADDR
// if k then
81242: LD_VAR 0 9
81246: IFFALSE 81294
// if GetDistUnits ( group [ i ] , k ) > 10 then
81248: LD_VAR 0 4
81252: PUSH
81253: LD_VAR 0 7
81257: ARRAY
81258: PPUSH
81259: LD_VAR 0 9
81263: PPUSH
81264: CALL_OW 296
81268: PUSH
81269: LD_INT 10
81271: GREATER
81272: IFFALSE 81294
// ComMoveUnit ( group [ i ] , k ) ;
81274: LD_VAR 0 4
81278: PUSH
81279: LD_VAR 0 7
81283: ARRAY
81284: PPUSH
81285: LD_VAR 0 9
81289: PPUSH
81290: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81294: LD_VAR 0 4
81298: PUSH
81299: LD_VAR 0 7
81303: ARRAY
81304: PPUSH
81305: CALL_OW 256
81309: PUSH
81310: LD_INT 250
81312: LESS
81313: PUSH
81314: LD_VAR 0 4
81318: PUSH
81319: LD_VAR 0 7
81323: ARRAY
81324: PUSH
81325: LD_INT 21
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 23
81337: PUSH
81338: LD_INT 2
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PPUSH
81349: CALL_OW 69
81353: IN
81354: AND
81355: IFFALSE 81480
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81357: LD_ADDR_VAR 0 9
81361: PUSH
81362: LD_OWVAR 3
81366: PUSH
81367: LD_VAR 0 4
81371: PUSH
81372: LD_VAR 0 7
81376: ARRAY
81377: DIFF
81378: PPUSH
81379: LD_VAR 0 4
81383: PUSH
81384: LD_VAR 0 7
81388: ARRAY
81389: PPUSH
81390: CALL_OW 74
81394: ST_TO_ADDR
// if not k then
81395: LD_VAR 0 9
81399: NOT
81400: IFFALSE 81404
// continue ;
81402: GO 77819
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81404: LD_VAR 0 9
81408: PUSH
81409: LD_INT 81
81411: PUSH
81412: LD_VAR 0 4
81416: PUSH
81417: LD_VAR 0 7
81421: ARRAY
81422: PPUSH
81423: CALL_OW 255
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PPUSH
81432: CALL_OW 69
81436: IN
81437: PUSH
81438: LD_VAR 0 9
81442: PPUSH
81443: LD_VAR 0 4
81447: PUSH
81448: LD_VAR 0 7
81452: ARRAY
81453: PPUSH
81454: CALL_OW 296
81458: PUSH
81459: LD_INT 5
81461: LESS
81462: AND
81463: IFFALSE 81480
// ComAutodestruct ( group [ i ] ) ;
81465: LD_VAR 0 4
81469: PUSH
81470: LD_VAR 0 7
81474: ARRAY
81475: PPUSH
81476: CALL 41883 0 1
// end ; if f_attack_depot then
81480: LD_VAR 0 25
81484: IFFALSE 81596
// begin k := 6 ;
81486: LD_ADDR_VAR 0 9
81490: PUSH
81491: LD_INT 6
81493: ST_TO_ADDR
// if tmp < k then
81494: LD_VAR 0 14
81498: PUSH
81499: LD_VAR 0 9
81503: LESS
81504: IFFALSE 81516
// k := tmp ;
81506: LD_ADDR_VAR 0 9
81510: PUSH
81511: LD_VAR 0 14
81515: ST_TO_ADDR
// for j = 1 to k do
81516: LD_ADDR_VAR 0 8
81520: PUSH
81521: DOUBLE
81522: LD_INT 1
81524: DEC
81525: ST_TO_ADDR
81526: LD_VAR 0 9
81530: PUSH
81531: FOR_TO
81532: IFFALSE 81594
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81534: LD_VAR 0 8
81538: PPUSH
81539: CALL_OW 266
81543: PUSH
81544: LD_INT 0
81546: PUSH
81547: LD_INT 1
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: IN
81554: IFFALSE 81592
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81556: LD_VAR 0 4
81560: PUSH
81561: LD_VAR 0 7
81565: ARRAY
81566: PPUSH
81567: LD_VAR 0 14
81571: PUSH
81572: LD_VAR 0 8
81576: ARRAY
81577: PPUSH
81578: CALL_OW 115
// attacking := true ;
81582: LD_ADDR_VAR 0 29
81586: PUSH
81587: LD_INT 1
81589: ST_TO_ADDR
// break ;
81590: GO 81594
// end ;
81592: GO 81531
81594: POP
81595: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81596: LD_VAR 0 4
81600: PUSH
81601: LD_VAR 0 7
81605: ARRAY
81606: PPUSH
81607: CALL_OW 302
81611: PUSH
81612: LD_VAR 0 29
81616: NOT
81617: AND
81618: IFFALSE 81940
// begin if GetTag ( group [ i ] ) = 71 then
81620: LD_VAR 0 4
81624: PUSH
81625: LD_VAR 0 7
81629: ARRAY
81630: PPUSH
81631: CALL_OW 110
81635: PUSH
81636: LD_INT 71
81638: EQUAL
81639: IFFALSE 81680
// begin if HasTask ( group [ i ] ) then
81641: LD_VAR 0 4
81645: PUSH
81646: LD_VAR 0 7
81650: ARRAY
81651: PPUSH
81652: CALL_OW 314
81656: IFFALSE 81662
// continue else
81658: GO 77819
81660: GO 81680
// SetTag ( group [ i ] , 0 ) ;
81662: LD_VAR 0 4
81666: PUSH
81667: LD_VAR 0 7
81671: ARRAY
81672: PPUSH
81673: LD_INT 0
81675: PPUSH
81676: CALL_OW 109
// end ; k := 8 ;
81680: LD_ADDR_VAR 0 9
81684: PUSH
81685: LD_INT 8
81687: ST_TO_ADDR
// x := 0 ;
81688: LD_ADDR_VAR 0 10
81692: PUSH
81693: LD_INT 0
81695: ST_TO_ADDR
// if tmp < k then
81696: LD_VAR 0 14
81700: PUSH
81701: LD_VAR 0 9
81705: LESS
81706: IFFALSE 81718
// k := tmp ;
81708: LD_ADDR_VAR 0 9
81712: PUSH
81713: LD_VAR 0 14
81717: ST_TO_ADDR
// for j = 1 to k do
81718: LD_ADDR_VAR 0 8
81722: PUSH
81723: DOUBLE
81724: LD_INT 1
81726: DEC
81727: ST_TO_ADDR
81728: LD_VAR 0 9
81732: PUSH
81733: FOR_TO
81734: IFFALSE 81832
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81736: LD_VAR 0 14
81740: PUSH
81741: LD_VAR 0 8
81745: ARRAY
81746: PPUSH
81747: CALL_OW 247
81751: PUSH
81752: LD_INT 1
81754: EQUAL
81755: PUSH
81756: LD_VAR 0 14
81760: PUSH
81761: LD_VAR 0 8
81765: ARRAY
81766: PPUSH
81767: CALL_OW 256
81771: PUSH
81772: LD_INT 250
81774: LESS
81775: PUSH
81776: LD_VAR 0 20
81780: AND
81781: PUSH
81782: LD_VAR 0 20
81786: NOT
81787: PUSH
81788: LD_VAR 0 14
81792: PUSH
81793: LD_VAR 0 8
81797: ARRAY
81798: PPUSH
81799: CALL_OW 256
81803: PUSH
81804: LD_INT 250
81806: GREATEREQUAL
81807: AND
81808: OR
81809: AND
81810: IFFALSE 81830
// begin x := tmp [ j ] ;
81812: LD_ADDR_VAR 0 10
81816: PUSH
81817: LD_VAR 0 14
81821: PUSH
81822: LD_VAR 0 8
81826: ARRAY
81827: ST_TO_ADDR
// break ;
81828: GO 81832
// end ;
81830: GO 81733
81832: POP
81833: POP
// if x then
81834: LD_VAR 0 10
81838: IFFALSE 81862
// ComAttackUnit ( group [ i ] , x ) else
81840: LD_VAR 0 4
81844: PUSH
81845: LD_VAR 0 7
81849: ARRAY
81850: PPUSH
81851: LD_VAR 0 10
81855: PPUSH
81856: CALL_OW 115
81860: GO 81886
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81862: LD_VAR 0 4
81866: PUSH
81867: LD_VAR 0 7
81871: ARRAY
81872: PPUSH
81873: LD_VAR 0 14
81877: PUSH
81878: LD_INT 1
81880: ARRAY
81881: PPUSH
81882: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81886: LD_VAR 0 4
81890: PUSH
81891: LD_VAR 0 7
81895: ARRAY
81896: PPUSH
81897: CALL_OW 314
81901: NOT
81902: IFFALSE 81940
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81904: LD_VAR 0 4
81908: PUSH
81909: LD_VAR 0 7
81913: ARRAY
81914: PPUSH
81915: LD_VAR 0 14
81919: PPUSH
81920: LD_VAR 0 4
81924: PUSH
81925: LD_VAR 0 7
81929: ARRAY
81930: PPUSH
81931: CALL_OW 74
81935: PPUSH
81936: CALL_OW 115
// end ; end ; end ;
81940: GO 77819
81942: POP
81943: POP
// wait ( 0 0$2 ) ;
81944: LD_INT 70
81946: PPUSH
81947: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
81951: LD_VAR 0 4
81955: NOT
81956: PUSH
81957: LD_VAR 0 4
81961: PUSH
81962: EMPTY
81963: EQUAL
81964: OR
81965: PUSH
81966: LD_INT 81
81968: PUSH
81969: LD_VAR 0 35
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PPUSH
81978: CALL_OW 69
81982: NOT
81983: OR
81984: IFFALSE 77804
// end ;
81986: LD_VAR 0 2
81990: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
81991: LD_INT 0
81993: PPUSH
81994: PPUSH
81995: PPUSH
81996: PPUSH
81997: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
81998: LD_VAR 0 1
82002: NOT
82003: PUSH
82004: LD_EXP 43
82008: PUSH
82009: LD_VAR 0 1
82013: ARRAY
82014: NOT
82015: OR
82016: PUSH
82017: LD_VAR 0 2
82021: NOT
82022: OR
82023: PUSH
82024: LD_VAR 0 3
82028: NOT
82029: OR
82030: IFFALSE 82034
// exit ;
82032: GO 82547
// side := mc_sides [ base ] ;
82034: LD_ADDR_VAR 0 6
82038: PUSH
82039: LD_EXP 69
82043: PUSH
82044: LD_VAR 0 1
82048: ARRAY
82049: ST_TO_ADDR
// if not side then
82050: LD_VAR 0 6
82054: NOT
82055: IFFALSE 82059
// exit ;
82057: GO 82547
// for i in solds do
82059: LD_ADDR_VAR 0 7
82063: PUSH
82064: LD_VAR 0 2
82068: PUSH
82069: FOR_IN
82070: IFFALSE 82131
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82072: LD_VAR 0 7
82076: PPUSH
82077: CALL_OW 310
82081: PPUSH
82082: CALL_OW 266
82086: PUSH
82087: LD_INT 32
82089: PUSH
82090: LD_INT 31
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: IN
82097: IFFALSE 82117
// solds := solds diff i else
82099: LD_ADDR_VAR 0 2
82103: PUSH
82104: LD_VAR 0 2
82108: PUSH
82109: LD_VAR 0 7
82113: DIFF
82114: ST_TO_ADDR
82115: GO 82129
// SetTag ( i , 18 ) ;
82117: LD_VAR 0 7
82121: PPUSH
82122: LD_INT 18
82124: PPUSH
82125: CALL_OW 109
82129: GO 82069
82131: POP
82132: POP
// if not solds then
82133: LD_VAR 0 2
82137: NOT
82138: IFFALSE 82142
// exit ;
82140: GO 82547
// repeat wait ( 0 0$2 ) ;
82142: LD_INT 70
82144: PPUSH
82145: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82149: LD_ADDR_VAR 0 5
82153: PUSH
82154: LD_VAR 0 6
82158: PPUSH
82159: LD_VAR 0 3
82163: PPUSH
82164: CALL 11598 0 2
82168: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82169: LD_EXP 43
82173: PUSH
82174: LD_VAR 0 1
82178: ARRAY
82179: NOT
82180: PUSH
82181: LD_EXP 43
82185: PUSH
82186: LD_VAR 0 1
82190: ARRAY
82191: PUSH
82192: EMPTY
82193: EQUAL
82194: OR
82195: IFFALSE 82232
// begin for i in solds do
82197: LD_ADDR_VAR 0 7
82201: PUSH
82202: LD_VAR 0 2
82206: PUSH
82207: FOR_IN
82208: IFFALSE 82221
// ComStop ( i ) ;
82210: LD_VAR 0 7
82214: PPUSH
82215: CALL_OW 141
82219: GO 82207
82221: POP
82222: POP
// solds := [ ] ;
82223: LD_ADDR_VAR 0 2
82227: PUSH
82228: EMPTY
82229: ST_TO_ADDR
// exit ;
82230: GO 82547
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82232: LD_VAR 0 5
82236: NOT
82237: PUSH
82238: LD_VAR 0 5
82242: PUSH
82243: LD_INT 3
82245: GREATER
82246: OR
82247: PUSH
82248: LD_EXP 65
82252: PUSH
82253: LD_VAR 0 1
82257: ARRAY
82258: OR
82259: IFFALSE 82300
// begin for i in solds do
82261: LD_ADDR_VAR 0 7
82265: PUSH
82266: LD_VAR 0 2
82270: PUSH
82271: FOR_IN
82272: IFFALSE 82296
// if HasTask ( i ) then
82274: LD_VAR 0 7
82278: PPUSH
82279: CALL_OW 314
82283: IFFALSE 82294
// ComStop ( i ) ;
82285: LD_VAR 0 7
82289: PPUSH
82290: CALL_OW 141
82294: GO 82271
82296: POP
82297: POP
// break ;
82298: GO 82535
// end ; for i in solds do
82300: LD_ADDR_VAR 0 7
82304: PUSH
82305: LD_VAR 0 2
82309: PUSH
82310: FOR_IN
82311: IFFALSE 82527
// begin if IsInUnit ( i ) then
82313: LD_VAR 0 7
82317: PPUSH
82318: CALL_OW 310
82322: IFFALSE 82333
// ComExitBuilding ( i ) ;
82324: LD_VAR 0 7
82328: PPUSH
82329: CALL_OW 122
// if GetLives ( i ) > 333 then
82333: LD_VAR 0 7
82337: PPUSH
82338: CALL_OW 256
82342: PUSH
82343: LD_INT 333
82345: GREATER
82346: IFFALSE 82374
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82348: LD_VAR 0 7
82352: PPUSH
82353: LD_VAR 0 5
82357: PPUSH
82358: LD_VAR 0 7
82362: PPUSH
82363: CALL_OW 74
82367: PPUSH
82368: CALL_OW 115
82372: GO 82525
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82374: LD_ADDR_VAR 0 8
82378: PUSH
82379: LD_EXP 43
82383: PUSH
82384: LD_VAR 0 1
82388: ARRAY
82389: PPUSH
82390: LD_INT 2
82392: PUSH
82393: LD_INT 30
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 30
82405: PUSH
82406: LD_INT 1
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 30
82415: PUSH
82416: LD_INT 6
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: PPUSH
82429: CALL_OW 72
82433: PPUSH
82434: LD_VAR 0 7
82438: PPUSH
82439: CALL_OW 74
82443: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82444: LD_VAR 0 7
82448: PPUSH
82449: LD_VAR 0 8
82453: PPUSH
82454: CALL_OW 250
82458: PPUSH
82459: LD_INT 3
82461: PPUSH
82462: LD_INT 5
82464: PPUSH
82465: CALL_OW 272
82469: PPUSH
82470: LD_VAR 0 8
82474: PPUSH
82475: CALL_OW 251
82479: PPUSH
82480: LD_INT 3
82482: PPUSH
82483: LD_INT 5
82485: PPUSH
82486: CALL_OW 273
82490: PPUSH
82491: CALL_OW 111
// SetTag ( i , 0 ) ;
82495: LD_VAR 0 7
82499: PPUSH
82500: LD_INT 0
82502: PPUSH
82503: CALL_OW 109
// solds := solds diff i ;
82507: LD_ADDR_VAR 0 2
82511: PUSH
82512: LD_VAR 0 2
82516: PUSH
82517: LD_VAR 0 7
82521: DIFF
82522: ST_TO_ADDR
// continue ;
82523: GO 82310
// end ; end ;
82525: GO 82310
82527: POP
82528: POP
// until solds ;
82529: LD_VAR 0 2
82533: IFFALSE 82142
// MC_Reset ( base , 18 ) ;
82535: LD_VAR 0 1
82539: PPUSH
82540: LD_INT 18
82542: PPUSH
82543: CALL 51133 0 2
// end ;
82547: LD_VAR 0 4
82551: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82552: LD_INT 0
82554: PPUSH
82555: PPUSH
82556: PPUSH
82557: PPUSH
82558: PPUSH
82559: PPUSH
82560: PPUSH
82561: PPUSH
82562: PPUSH
82563: PPUSH
82564: PPUSH
82565: PPUSH
82566: PPUSH
82567: PPUSH
82568: PPUSH
82569: PPUSH
82570: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82571: LD_ADDR_VAR 0 13
82575: PUSH
82576: LD_EXP 43
82580: PUSH
82581: LD_VAR 0 1
82585: ARRAY
82586: PPUSH
82587: LD_INT 25
82589: PUSH
82590: LD_INT 3
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PPUSH
82597: CALL_OW 72
82601: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82602: LD_EXP 83
82606: PUSH
82607: LD_VAR 0 1
82611: ARRAY
82612: IFFALSE 82636
// mechs := mechs diff mc_remote_driver [ base ] ;
82614: LD_ADDR_VAR 0 13
82618: PUSH
82619: LD_VAR 0 13
82623: PUSH
82624: LD_EXP 83
82628: PUSH
82629: LD_VAR 0 1
82633: ARRAY
82634: DIFF
82635: ST_TO_ADDR
// for i in mechs do
82636: LD_ADDR_VAR 0 5
82640: PUSH
82641: LD_VAR 0 13
82645: PUSH
82646: FOR_IN
82647: IFFALSE 82682
// if GetTag ( i ) > 0 then
82649: LD_VAR 0 5
82653: PPUSH
82654: CALL_OW 110
82658: PUSH
82659: LD_INT 0
82661: GREATER
82662: IFFALSE 82680
// mechs := mechs diff i ;
82664: LD_ADDR_VAR 0 13
82668: PUSH
82669: LD_VAR 0 13
82673: PUSH
82674: LD_VAR 0 5
82678: DIFF
82679: ST_TO_ADDR
82680: GO 82646
82682: POP
82683: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82684: LD_ADDR_VAR 0 9
82688: PUSH
82689: LD_EXP 43
82693: PUSH
82694: LD_VAR 0 1
82698: ARRAY
82699: PPUSH
82700: LD_INT 2
82702: PUSH
82703: LD_INT 25
82705: PUSH
82706: LD_INT 1
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: LD_INT 25
82715: PUSH
82716: LD_INT 5
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: LD_INT 25
82725: PUSH
82726: LD_INT 8
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 25
82735: PUSH
82736: LD_INT 9
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: PPUSH
82750: CALL_OW 72
82754: ST_TO_ADDR
// if not defenders and not solds then
82755: LD_VAR 0 2
82759: NOT
82760: PUSH
82761: LD_VAR 0 9
82765: NOT
82766: AND
82767: IFFALSE 82771
// exit ;
82769: GO 84461
// depot_under_attack := false ;
82771: LD_ADDR_VAR 0 17
82775: PUSH
82776: LD_INT 0
82778: ST_TO_ADDR
// sold_defenders := [ ] ;
82779: LD_ADDR_VAR 0 18
82783: PUSH
82784: EMPTY
82785: ST_TO_ADDR
// if mechs then
82786: LD_VAR 0 13
82790: IFFALSE 82943
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82792: LD_ADDR_VAR 0 5
82796: PUSH
82797: LD_VAR 0 2
82801: PPUSH
82802: LD_INT 21
82804: PUSH
82805: LD_INT 2
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PPUSH
82812: CALL_OW 72
82816: PUSH
82817: FOR_IN
82818: IFFALSE 82941
// begin if GetTag ( i ) <> 20 then
82820: LD_VAR 0 5
82824: PPUSH
82825: CALL_OW 110
82829: PUSH
82830: LD_INT 20
82832: NONEQUAL
82833: IFFALSE 82847
// SetTag ( i , 20 ) ;
82835: LD_VAR 0 5
82839: PPUSH
82840: LD_INT 20
82842: PPUSH
82843: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82847: LD_VAR 0 5
82851: PPUSH
82852: CALL_OW 263
82856: PUSH
82857: LD_INT 1
82859: EQUAL
82860: PUSH
82861: LD_VAR 0 5
82865: PPUSH
82866: CALL_OW 311
82870: NOT
82871: AND
82872: IFFALSE 82939
// begin un := mechs [ 1 ] ;
82874: LD_ADDR_VAR 0 11
82878: PUSH
82879: LD_VAR 0 13
82883: PUSH
82884: LD_INT 1
82886: ARRAY
82887: ST_TO_ADDR
// ComExit ( un ) ;
82888: LD_VAR 0 11
82892: PPUSH
82893: CALL 46228 0 1
// AddComEnterUnit ( un , i ) ;
82897: LD_VAR 0 11
82901: PPUSH
82902: LD_VAR 0 5
82906: PPUSH
82907: CALL_OW 180
// SetTag ( un , 19 ) ;
82911: LD_VAR 0 11
82915: PPUSH
82916: LD_INT 19
82918: PPUSH
82919: CALL_OW 109
// mechs := mechs diff un ;
82923: LD_ADDR_VAR 0 13
82927: PUSH
82928: LD_VAR 0 13
82932: PUSH
82933: LD_VAR 0 11
82937: DIFF
82938: ST_TO_ADDR
// end ; end ;
82939: GO 82817
82941: POP
82942: POP
// if solds then
82943: LD_VAR 0 9
82947: IFFALSE 83006
// for i in solds do
82949: LD_ADDR_VAR 0 5
82953: PUSH
82954: LD_VAR 0 9
82958: PUSH
82959: FOR_IN
82960: IFFALSE 83004
// if not GetTag ( i ) then
82962: LD_VAR 0 5
82966: PPUSH
82967: CALL_OW 110
82971: NOT
82972: IFFALSE 83002
// begin defenders := defenders union i ;
82974: LD_ADDR_VAR 0 2
82978: PUSH
82979: LD_VAR 0 2
82983: PUSH
82984: LD_VAR 0 5
82988: UNION
82989: ST_TO_ADDR
// SetTag ( i , 18 ) ;
82990: LD_VAR 0 5
82994: PPUSH
82995: LD_INT 18
82997: PPUSH
82998: CALL_OW 109
// end ;
83002: GO 82959
83004: POP
83005: POP
// repeat wait ( 0 0$2 ) ;
83006: LD_INT 70
83008: PPUSH
83009: CALL_OW 67
// enemy := mc_scan [ base ] ;
83013: LD_ADDR_VAR 0 3
83017: PUSH
83018: LD_EXP 66
83022: PUSH
83023: LD_VAR 0 1
83027: ARRAY
83028: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83029: LD_EXP 43
83033: PUSH
83034: LD_VAR 0 1
83038: ARRAY
83039: NOT
83040: PUSH
83041: LD_EXP 43
83045: PUSH
83046: LD_VAR 0 1
83050: ARRAY
83051: PUSH
83052: EMPTY
83053: EQUAL
83054: OR
83055: IFFALSE 83092
// begin for i in defenders do
83057: LD_ADDR_VAR 0 5
83061: PUSH
83062: LD_VAR 0 2
83066: PUSH
83067: FOR_IN
83068: IFFALSE 83081
// ComStop ( i ) ;
83070: LD_VAR 0 5
83074: PPUSH
83075: CALL_OW 141
83079: GO 83067
83081: POP
83082: POP
// defenders := [ ] ;
83083: LD_ADDR_VAR 0 2
83087: PUSH
83088: EMPTY
83089: ST_TO_ADDR
// exit ;
83090: GO 84461
// end ; for i in defenders do
83092: LD_ADDR_VAR 0 5
83096: PUSH
83097: LD_VAR 0 2
83101: PUSH
83102: FOR_IN
83103: IFFALSE 83921
// begin e := NearestUnitToUnit ( enemy , i ) ;
83105: LD_ADDR_VAR 0 14
83109: PUSH
83110: LD_VAR 0 3
83114: PPUSH
83115: LD_VAR 0 5
83119: PPUSH
83120: CALL_OW 74
83124: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83125: LD_ADDR_VAR 0 8
83129: PUSH
83130: LD_EXP 43
83134: PUSH
83135: LD_VAR 0 1
83139: ARRAY
83140: PPUSH
83141: LD_INT 2
83143: PUSH
83144: LD_INT 30
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 30
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: LIST
83168: PPUSH
83169: CALL_OW 72
83173: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83174: LD_ADDR_VAR 0 17
83178: PUSH
83179: LD_VAR 0 8
83183: NOT
83184: PUSH
83185: LD_VAR 0 8
83189: PPUSH
83190: LD_INT 3
83192: PUSH
83193: LD_INT 24
83195: PUSH
83196: LD_INT 600
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PPUSH
83207: CALL_OW 72
83211: OR
83212: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83213: LD_VAR 0 5
83217: PPUSH
83218: CALL_OW 247
83222: PUSH
83223: LD_INT 2
83225: DOUBLE
83226: EQUAL
83227: IFTRUE 83231
83229: GO 83627
83231: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83232: LD_VAR 0 5
83236: PPUSH
83237: CALL_OW 256
83241: PUSH
83242: LD_INT 650
83244: GREATER
83245: PUSH
83246: LD_VAR 0 5
83250: PPUSH
83251: LD_VAR 0 14
83255: PPUSH
83256: CALL_OW 296
83260: PUSH
83261: LD_INT 40
83263: LESS
83264: PUSH
83265: LD_VAR 0 14
83269: PPUSH
83270: LD_EXP 68
83274: PUSH
83275: LD_VAR 0 1
83279: ARRAY
83280: PPUSH
83281: CALL_OW 308
83285: OR
83286: AND
83287: IFFALSE 83409
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83289: LD_VAR 0 5
83293: PPUSH
83294: CALL_OW 262
83298: PUSH
83299: LD_INT 1
83301: EQUAL
83302: PUSH
83303: LD_VAR 0 5
83307: PPUSH
83308: CALL_OW 261
83312: PUSH
83313: LD_INT 30
83315: LESS
83316: AND
83317: PUSH
83318: LD_VAR 0 8
83322: AND
83323: IFFALSE 83393
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83325: LD_VAR 0 5
83329: PPUSH
83330: LD_VAR 0 8
83334: PPUSH
83335: LD_VAR 0 5
83339: PPUSH
83340: CALL_OW 74
83344: PPUSH
83345: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83349: LD_VAR 0 5
83353: PPUSH
83354: LD_VAR 0 8
83358: PPUSH
83359: LD_VAR 0 5
83363: PPUSH
83364: CALL_OW 74
83368: PPUSH
83369: CALL_OW 296
83373: PUSH
83374: LD_INT 6
83376: LESS
83377: IFFALSE 83391
// SetFuel ( i , 100 ) ;
83379: LD_VAR 0 5
83383: PPUSH
83384: LD_INT 100
83386: PPUSH
83387: CALL_OW 240
// end else
83391: GO 83407
// ComAttackUnit ( i , e ) ;
83393: LD_VAR 0 5
83397: PPUSH
83398: LD_VAR 0 14
83402: PPUSH
83403: CALL_OW 115
// end else
83407: GO 83510
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83409: LD_VAR 0 14
83413: PPUSH
83414: LD_EXP 68
83418: PUSH
83419: LD_VAR 0 1
83423: ARRAY
83424: PPUSH
83425: CALL_OW 308
83429: NOT
83430: PUSH
83431: LD_VAR 0 5
83435: PPUSH
83436: LD_VAR 0 14
83440: PPUSH
83441: CALL_OW 296
83445: PUSH
83446: LD_INT 40
83448: GREATEREQUAL
83449: AND
83450: PUSH
83451: LD_VAR 0 5
83455: PPUSH
83456: CALL_OW 256
83460: PUSH
83461: LD_INT 650
83463: LESSEQUAL
83464: OR
83465: PUSH
83466: LD_VAR 0 5
83470: PPUSH
83471: LD_EXP 67
83475: PUSH
83476: LD_VAR 0 1
83480: ARRAY
83481: PPUSH
83482: CALL_OW 308
83486: NOT
83487: AND
83488: IFFALSE 83510
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83490: LD_VAR 0 5
83494: PPUSH
83495: LD_EXP 67
83499: PUSH
83500: LD_VAR 0 1
83504: ARRAY
83505: PPUSH
83506: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83510: LD_VAR 0 5
83514: PPUSH
83515: CALL_OW 256
83519: PUSH
83520: LD_INT 998
83522: LESS
83523: PUSH
83524: LD_VAR 0 5
83528: PPUSH
83529: CALL_OW 263
83533: PUSH
83534: LD_INT 1
83536: EQUAL
83537: AND
83538: PUSH
83539: LD_VAR 0 5
83543: PPUSH
83544: CALL_OW 311
83548: AND
83549: PUSH
83550: LD_VAR 0 5
83554: PPUSH
83555: LD_EXP 67
83559: PUSH
83560: LD_VAR 0 1
83564: ARRAY
83565: PPUSH
83566: CALL_OW 308
83570: AND
83571: IFFALSE 83625
// begin mech := IsDrivenBy ( i ) ;
83573: LD_ADDR_VAR 0 10
83577: PUSH
83578: LD_VAR 0 5
83582: PPUSH
83583: CALL_OW 311
83587: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83588: LD_VAR 0 10
83592: PPUSH
83593: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83597: LD_VAR 0 10
83601: PPUSH
83602: LD_VAR 0 5
83606: PPUSH
83607: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83611: LD_VAR 0 10
83615: PPUSH
83616: LD_VAR 0 5
83620: PPUSH
83621: CALL_OW 180
// end ; end ; unit_human :
83625: GO 83892
83627: LD_INT 1
83629: DOUBLE
83630: EQUAL
83631: IFTRUE 83635
83633: GO 83891
83635: POP
// begin b := IsInUnit ( i ) ;
83636: LD_ADDR_VAR 0 19
83640: PUSH
83641: LD_VAR 0 5
83645: PPUSH
83646: CALL_OW 310
83650: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83651: LD_ADDR_VAR 0 20
83655: PUSH
83656: LD_VAR 0 19
83660: NOT
83661: PUSH
83662: LD_VAR 0 19
83666: PPUSH
83667: CALL_OW 266
83671: PUSH
83672: LD_INT 32
83674: PUSH
83675: LD_INT 31
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: IN
83682: OR
83683: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83684: LD_VAR 0 17
83688: PUSH
83689: LD_VAR 0 2
83693: PPUSH
83694: LD_INT 21
83696: PUSH
83697: LD_INT 2
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PPUSH
83704: CALL_OW 72
83708: PUSH
83709: LD_INT 1
83711: LESSEQUAL
83712: OR
83713: PUSH
83714: LD_VAR 0 20
83718: AND
83719: PUSH
83720: LD_VAR 0 5
83724: PUSH
83725: LD_VAR 0 18
83729: IN
83730: NOT
83731: AND
83732: IFFALSE 83825
// begin if b then
83734: LD_VAR 0 19
83738: IFFALSE 83787
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83740: LD_VAR 0 19
83744: PPUSH
83745: LD_VAR 0 3
83749: PPUSH
83750: LD_VAR 0 19
83754: PPUSH
83755: CALL_OW 74
83759: PPUSH
83760: CALL_OW 296
83764: PUSH
83765: LD_INT 10
83767: LESS
83768: PUSH
83769: LD_VAR 0 19
83773: PPUSH
83774: CALL_OW 461
83778: PUSH
83779: LD_INT 7
83781: NONEQUAL
83782: AND
83783: IFFALSE 83787
// continue ;
83785: GO 83102
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83787: LD_ADDR_VAR 0 18
83791: PUSH
83792: LD_VAR 0 18
83796: PPUSH
83797: LD_VAR 0 18
83801: PUSH
83802: LD_INT 1
83804: PLUS
83805: PPUSH
83806: LD_VAR 0 5
83810: PPUSH
83811: CALL_OW 1
83815: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83816: LD_VAR 0 5
83820: PPUSH
83821: CALL_OW 122
// end ; if sold_defenders then
83825: LD_VAR 0 18
83829: IFFALSE 83889
// if i in sold_defenders then
83831: LD_VAR 0 5
83835: PUSH
83836: LD_VAR 0 18
83840: IN
83841: IFFALSE 83889
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83843: LD_VAR 0 5
83847: PPUSH
83848: CALL_OW 314
83852: NOT
83853: PUSH
83854: LD_VAR 0 5
83858: PPUSH
83859: LD_VAR 0 14
83863: PPUSH
83864: CALL_OW 296
83868: PUSH
83869: LD_INT 30
83871: LESS
83872: AND
83873: IFFALSE 83889
// ComAttackUnit ( i , e ) ;
83875: LD_VAR 0 5
83879: PPUSH
83880: LD_VAR 0 14
83884: PPUSH
83885: CALL_OW 115
// end ; end ; end ;
83889: GO 83892
83891: POP
// if IsDead ( i ) then
83892: LD_VAR 0 5
83896: PPUSH
83897: CALL_OW 301
83901: IFFALSE 83919
// defenders := defenders diff i ;
83903: LD_ADDR_VAR 0 2
83907: PUSH
83908: LD_VAR 0 2
83912: PUSH
83913: LD_VAR 0 5
83917: DIFF
83918: ST_TO_ADDR
// end ;
83919: GO 83102
83921: POP
83922: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83923: LD_VAR 0 3
83927: NOT
83928: PUSH
83929: LD_VAR 0 2
83933: NOT
83934: OR
83935: PUSH
83936: LD_EXP 43
83940: PUSH
83941: LD_VAR 0 1
83945: ARRAY
83946: NOT
83947: OR
83948: IFFALSE 83006
// MC_Reset ( base , 18 ) ;
83950: LD_VAR 0 1
83954: PPUSH
83955: LD_INT 18
83957: PPUSH
83958: CALL 51133 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83962: LD_ADDR_VAR 0 2
83966: PUSH
83967: LD_VAR 0 2
83971: PUSH
83972: LD_VAR 0 2
83976: PPUSH
83977: LD_INT 2
83979: PUSH
83980: LD_INT 25
83982: PUSH
83983: LD_INT 1
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 25
83992: PUSH
83993: LD_INT 5
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 25
84002: PUSH
84003: LD_INT 8
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 25
84012: PUSH
84013: LD_INT 9
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: PPUSH
84027: CALL_OW 72
84031: DIFF
84032: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84033: LD_VAR 0 3
84037: NOT
84038: PUSH
84039: LD_VAR 0 2
84043: PPUSH
84044: LD_INT 21
84046: PUSH
84047: LD_INT 2
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PPUSH
84054: CALL_OW 72
84058: AND
84059: IFFALSE 84397
// begin tmp := FilterByTag ( defenders , 19 ) ;
84061: LD_ADDR_VAR 0 12
84065: PUSH
84066: LD_VAR 0 2
84070: PPUSH
84071: LD_INT 19
84073: PPUSH
84074: CALL 43358 0 2
84078: ST_TO_ADDR
// if tmp then
84079: LD_VAR 0 12
84083: IFFALSE 84153
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84085: LD_ADDR_VAR 0 12
84089: PUSH
84090: LD_VAR 0 12
84094: PPUSH
84095: LD_INT 25
84097: PUSH
84098: LD_INT 3
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PPUSH
84105: CALL_OW 72
84109: ST_TO_ADDR
// if tmp then
84110: LD_VAR 0 12
84114: IFFALSE 84153
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84116: LD_ADDR_EXP 55
84120: PUSH
84121: LD_EXP 55
84125: PPUSH
84126: LD_VAR 0 1
84130: PPUSH
84131: LD_EXP 55
84135: PUSH
84136: LD_VAR 0 1
84140: ARRAY
84141: PUSH
84142: LD_VAR 0 12
84146: UNION
84147: PPUSH
84148: CALL_OW 1
84152: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84153: LD_VAR 0 1
84157: PPUSH
84158: LD_INT 19
84160: PPUSH
84161: CALL 51133 0 2
// repeat wait ( 0 0$1 ) ;
84165: LD_INT 35
84167: PPUSH
84168: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84172: LD_EXP 43
84176: PUSH
84177: LD_VAR 0 1
84181: ARRAY
84182: NOT
84183: PUSH
84184: LD_EXP 43
84188: PUSH
84189: LD_VAR 0 1
84193: ARRAY
84194: PUSH
84195: EMPTY
84196: EQUAL
84197: OR
84198: IFFALSE 84235
// begin for i in defenders do
84200: LD_ADDR_VAR 0 5
84204: PUSH
84205: LD_VAR 0 2
84209: PUSH
84210: FOR_IN
84211: IFFALSE 84224
// ComStop ( i ) ;
84213: LD_VAR 0 5
84217: PPUSH
84218: CALL_OW 141
84222: GO 84210
84224: POP
84225: POP
// defenders := [ ] ;
84226: LD_ADDR_VAR 0 2
84230: PUSH
84231: EMPTY
84232: ST_TO_ADDR
// exit ;
84233: GO 84461
// end ; for i in defenders do
84235: LD_ADDR_VAR 0 5
84239: PUSH
84240: LD_VAR 0 2
84244: PUSH
84245: FOR_IN
84246: IFFALSE 84335
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84248: LD_VAR 0 5
84252: PPUSH
84253: LD_EXP 67
84257: PUSH
84258: LD_VAR 0 1
84262: ARRAY
84263: PPUSH
84264: CALL_OW 308
84268: NOT
84269: IFFALSE 84293
// ComMoveToArea ( i , mc_parking [ base ] ) else
84271: LD_VAR 0 5
84275: PPUSH
84276: LD_EXP 67
84280: PUSH
84281: LD_VAR 0 1
84285: ARRAY
84286: PPUSH
84287: CALL_OW 113
84291: GO 84333
// if GetControl ( i ) = control_manual then
84293: LD_VAR 0 5
84297: PPUSH
84298: CALL_OW 263
84302: PUSH
84303: LD_INT 1
84305: EQUAL
84306: IFFALSE 84333
// if IsDrivenBy ( i ) then
84308: LD_VAR 0 5
84312: PPUSH
84313: CALL_OW 311
84317: IFFALSE 84333
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84319: LD_VAR 0 5
84323: PPUSH
84324: CALL_OW 311
84328: PPUSH
84329: CALL_OW 121
// end ;
84333: GO 84245
84335: POP
84336: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84337: LD_VAR 0 2
84341: PPUSH
84342: LD_INT 95
84344: PUSH
84345: LD_EXP 67
84349: PUSH
84350: LD_VAR 0 1
84354: ARRAY
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PPUSH
84360: CALL_OW 72
84364: PUSH
84365: LD_VAR 0 2
84369: EQUAL
84370: PUSH
84371: LD_EXP 66
84375: PUSH
84376: LD_VAR 0 1
84380: ARRAY
84381: OR
84382: PUSH
84383: LD_EXP 43
84387: PUSH
84388: LD_VAR 0 1
84392: ARRAY
84393: NOT
84394: OR
84395: IFFALSE 84165
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84397: LD_ADDR_EXP 65
84401: PUSH
84402: LD_EXP 65
84406: PPUSH
84407: LD_VAR 0 1
84411: PPUSH
84412: LD_VAR 0 2
84416: PPUSH
84417: LD_INT 21
84419: PUSH
84420: LD_INT 2
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PPUSH
84427: CALL_OW 72
84431: PPUSH
84432: CALL_OW 1
84436: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84437: LD_VAR 0 1
84441: PPUSH
84442: LD_INT 19
84444: PPUSH
84445: CALL 51133 0 2
// MC_Reset ( base , 20 ) ;
84449: LD_VAR 0 1
84453: PPUSH
84454: LD_INT 20
84456: PPUSH
84457: CALL 51133 0 2
// end ; end_of_file
84461: LD_VAR 0 4
84465: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84466: LD_INT 0
84468: PPUSH
84469: PPUSH
84470: PPUSH
84471: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84472: LD_VAR 0 1
84476: PPUSH
84477: CALL_OW 264
84481: PUSH
84482: LD_EXP 90
84486: EQUAL
84487: IFFALSE 84559
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84489: LD_INT 68
84491: PPUSH
84492: LD_VAR 0 1
84496: PPUSH
84497: CALL_OW 255
84501: PPUSH
84502: CALL_OW 321
84506: PUSH
84507: LD_INT 2
84509: EQUAL
84510: IFFALSE 84522
// eff := 70 else
84512: LD_ADDR_VAR 0 4
84516: PUSH
84517: LD_INT 70
84519: ST_TO_ADDR
84520: GO 84530
// eff := 30 ;
84522: LD_ADDR_VAR 0 4
84526: PUSH
84527: LD_INT 30
84529: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84530: LD_VAR 0 1
84534: PPUSH
84535: CALL_OW 250
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: CALL_OW 251
84549: PPUSH
84550: LD_VAR 0 4
84554: PPUSH
84555: CALL_OW 495
// end ; end ;
84559: LD_VAR 0 2
84563: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84564: LD_INT 0
84566: PPUSH
// end ;
84567: LD_VAR 0 4
84571: RET
// export function SOS_Command ( cmd ) ; begin
84572: LD_INT 0
84574: PPUSH
// end ;
84575: LD_VAR 0 2
84579: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84580: LD_INT 0
84582: PPUSH
// if cmd = 121 then
84583: LD_VAR 0 1
84587: PUSH
84588: LD_INT 121
84590: EQUAL
84591: IFFALSE 84593
// end ;
84593: LD_VAR 0 6
84597: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84598: LD_INT 0
84600: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84601: LD_VAR 0 1
84605: PUSH
84606: LD_INT 250
84608: EQUAL
84609: PUSH
84610: LD_VAR 0 2
84614: PPUSH
84615: CALL_OW 264
84619: PUSH
84620: LD_EXP 93
84624: EQUAL
84625: AND
84626: IFFALSE 84647
// MinerPlaceMine ( unit , x , y ) ;
84628: LD_VAR 0 2
84632: PPUSH
84633: LD_VAR 0 4
84637: PPUSH
84638: LD_VAR 0 5
84642: PPUSH
84643: CALL 86996 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84647: LD_VAR 0 1
84651: PUSH
84652: LD_INT 251
84654: EQUAL
84655: PUSH
84656: LD_VAR 0 2
84660: PPUSH
84661: CALL_OW 264
84665: PUSH
84666: LD_EXP 93
84670: EQUAL
84671: AND
84672: IFFALSE 84693
// MinerDetonateMine ( unit , x , y ) ;
84674: LD_VAR 0 2
84678: PPUSH
84679: LD_VAR 0 4
84683: PPUSH
84684: LD_VAR 0 5
84688: PPUSH
84689: CALL 87273 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
84693: LD_VAR 0 1
84697: PUSH
84698: LD_INT 252
84700: EQUAL
84701: PUSH
84702: LD_VAR 0 2
84706: PPUSH
84707: CALL_OW 264
84711: PUSH
84712: LD_EXP 93
84716: EQUAL
84717: AND
84718: IFFALSE 84739
// MinerCreateMinefield ( unit , x , y ) ;
84720: LD_VAR 0 2
84724: PPUSH
84725: LD_VAR 0 4
84729: PPUSH
84730: LD_VAR 0 5
84734: PPUSH
84735: CALL 87690 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
84739: LD_VAR 0 1
84743: PUSH
84744: LD_INT 253
84746: EQUAL
84747: PUSH
84748: LD_VAR 0 2
84752: PPUSH
84753: CALL_OW 257
84757: PUSH
84758: LD_INT 5
84760: EQUAL
84761: AND
84762: IFFALSE 84783
// ComBinocular ( unit , x , y ) ;
84764: LD_VAR 0 2
84768: PPUSH
84769: LD_VAR 0 4
84773: PPUSH
84774: LD_VAR 0 5
84778: PPUSH
84779: CALL 88061 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
84783: LD_VAR 0 1
84787: PUSH
84788: LD_INT 254
84790: EQUAL
84791: PUSH
84792: LD_VAR 0 2
84796: PPUSH
84797: CALL_OW 264
84801: PUSH
84802: LD_EXP 88
84806: EQUAL
84807: AND
84808: PUSH
84809: LD_VAR 0 3
84813: PPUSH
84814: CALL_OW 263
84818: PUSH
84819: LD_INT 3
84821: EQUAL
84822: AND
84823: IFFALSE 84839
// HackDestroyVehicle ( unit , selectedUnit ) ;
84825: LD_VAR 0 2
84829: PPUSH
84830: LD_VAR 0 3
84834: PPUSH
84835: CALL 86356 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
84839: LD_VAR 0 1
84843: PUSH
84844: LD_INT 255
84846: EQUAL
84847: PUSH
84848: LD_VAR 0 2
84852: PPUSH
84853: CALL_OW 264
84857: PUSH
84858: LD_INT 14
84860: PUSH
84861: LD_INT 53
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: IN
84868: AND
84869: PUSH
84870: LD_VAR 0 4
84874: PPUSH
84875: LD_VAR 0 5
84879: PPUSH
84880: CALL_OW 488
84884: AND
84885: IFFALSE 84909
// CutTreeXYR ( unit , x , y , 12 ) ;
84887: LD_VAR 0 2
84891: PPUSH
84892: LD_VAR 0 4
84896: PPUSH
84897: LD_VAR 0 5
84901: PPUSH
84902: LD_INT 12
84904: PPUSH
84905: CALL 84922 0 4
// end ;
84909: LD_VAR 0 6
84913: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
84914: LD_INT 0
84916: PPUSH
// end ;
84917: LD_VAR 0 4
84921: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
84922: LD_INT 0
84924: PPUSH
84925: PPUSH
84926: PPUSH
84927: PPUSH
84928: PPUSH
84929: PPUSH
84930: PPUSH
84931: PPUSH
84932: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
84933: LD_VAR 0 1
84937: NOT
84938: PUSH
84939: LD_VAR 0 2
84943: PPUSH
84944: LD_VAR 0 3
84948: PPUSH
84949: CALL_OW 488
84953: NOT
84954: OR
84955: PUSH
84956: LD_VAR 0 4
84960: NOT
84961: OR
84962: IFFALSE 84966
// exit ;
84964: GO 85306
// list := [ ] ;
84966: LD_ADDR_VAR 0 13
84970: PUSH
84971: EMPTY
84972: ST_TO_ADDR
// if x - r < 0 then
84973: LD_VAR 0 2
84977: PUSH
84978: LD_VAR 0 4
84982: MINUS
84983: PUSH
84984: LD_INT 0
84986: LESS
84987: IFFALSE 84999
// min_x := 0 else
84989: LD_ADDR_VAR 0 7
84993: PUSH
84994: LD_INT 0
84996: ST_TO_ADDR
84997: GO 85015
// min_x := x - r ;
84999: LD_ADDR_VAR 0 7
85003: PUSH
85004: LD_VAR 0 2
85008: PUSH
85009: LD_VAR 0 4
85013: MINUS
85014: ST_TO_ADDR
// if y - r < 0 then
85015: LD_VAR 0 3
85019: PUSH
85020: LD_VAR 0 4
85024: MINUS
85025: PUSH
85026: LD_INT 0
85028: LESS
85029: IFFALSE 85041
// min_y := 0 else
85031: LD_ADDR_VAR 0 8
85035: PUSH
85036: LD_INT 0
85038: ST_TO_ADDR
85039: GO 85057
// min_y := y - r ;
85041: LD_ADDR_VAR 0 8
85045: PUSH
85046: LD_VAR 0 3
85050: PUSH
85051: LD_VAR 0 4
85055: MINUS
85056: ST_TO_ADDR
// max_x := x + r ;
85057: LD_ADDR_VAR 0 9
85061: PUSH
85062: LD_VAR 0 2
85066: PUSH
85067: LD_VAR 0 4
85071: PLUS
85072: ST_TO_ADDR
// max_y := y + r ;
85073: LD_ADDR_VAR 0 10
85077: PUSH
85078: LD_VAR 0 3
85082: PUSH
85083: LD_VAR 0 4
85087: PLUS
85088: ST_TO_ADDR
// for _x = min_x to max_x do
85089: LD_ADDR_VAR 0 11
85093: PUSH
85094: DOUBLE
85095: LD_VAR 0 7
85099: DEC
85100: ST_TO_ADDR
85101: LD_VAR 0 9
85105: PUSH
85106: FOR_TO
85107: IFFALSE 85224
// for _y = min_y to max_y do
85109: LD_ADDR_VAR 0 12
85113: PUSH
85114: DOUBLE
85115: LD_VAR 0 8
85119: DEC
85120: ST_TO_ADDR
85121: LD_VAR 0 10
85125: PUSH
85126: FOR_TO
85127: IFFALSE 85220
// begin if not ValidHex ( _x , _y ) then
85129: LD_VAR 0 11
85133: PPUSH
85134: LD_VAR 0 12
85138: PPUSH
85139: CALL_OW 488
85143: NOT
85144: IFFALSE 85148
// continue ;
85146: GO 85126
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85148: LD_VAR 0 11
85152: PPUSH
85153: LD_VAR 0 12
85157: PPUSH
85158: CALL_OW 351
85162: PUSH
85163: LD_VAR 0 11
85167: PPUSH
85168: LD_VAR 0 12
85172: PPUSH
85173: CALL_OW 554
85177: AND
85178: IFFALSE 85218
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85180: LD_ADDR_VAR 0 13
85184: PUSH
85185: LD_VAR 0 13
85189: PPUSH
85190: LD_VAR 0 13
85194: PUSH
85195: LD_INT 1
85197: PLUS
85198: PPUSH
85199: LD_VAR 0 11
85203: PUSH
85204: LD_VAR 0 12
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PPUSH
85213: CALL_OW 2
85217: ST_TO_ADDR
// end ;
85218: GO 85126
85220: POP
85221: POP
85222: GO 85106
85224: POP
85225: POP
// if not list then
85226: LD_VAR 0 13
85230: NOT
85231: IFFALSE 85235
// exit ;
85233: GO 85306
// for i in list do
85235: LD_ADDR_VAR 0 6
85239: PUSH
85240: LD_VAR 0 13
85244: PUSH
85245: FOR_IN
85246: IFFALSE 85304
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85248: LD_VAR 0 1
85252: PPUSH
85253: LD_STRING M
85255: PUSH
85256: LD_VAR 0 6
85260: PUSH
85261: LD_INT 1
85263: ARRAY
85264: PUSH
85265: LD_VAR 0 6
85269: PUSH
85270: LD_INT 2
85272: ARRAY
85273: PUSH
85274: LD_INT 0
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: PUSH
85295: EMPTY
85296: LIST
85297: PPUSH
85298: CALL_OW 447
85302: GO 85245
85304: POP
85305: POP
// end ;
85306: LD_VAR 0 5
85310: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85311: LD_EXP 104
85315: NOT
85316: IFFALSE 85366
85318: GO 85320
85320: DISABLE
// begin initHack := true ;
85321: LD_ADDR_EXP 104
85325: PUSH
85326: LD_INT 1
85328: ST_TO_ADDR
// hackTanks := [ ] ;
85329: LD_ADDR_EXP 105
85333: PUSH
85334: EMPTY
85335: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85336: LD_ADDR_EXP 106
85340: PUSH
85341: EMPTY
85342: ST_TO_ADDR
// hackLimit := 3 ;
85343: LD_ADDR_EXP 107
85347: PUSH
85348: LD_INT 3
85350: ST_TO_ADDR
// hackDist := 12 ;
85351: LD_ADDR_EXP 108
85355: PUSH
85356: LD_INT 12
85358: ST_TO_ADDR
// hackCounter := [ ] ;
85359: LD_ADDR_EXP 109
85363: PUSH
85364: EMPTY
85365: ST_TO_ADDR
// end ;
85366: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85367: LD_EXP 104
85371: PUSH
85372: LD_INT 34
85374: PUSH
85375: LD_EXP 88
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PPUSH
85384: CALL_OW 69
85388: AND
85389: IFFALSE 85644
85391: GO 85393
85393: DISABLE
85394: LD_INT 0
85396: PPUSH
85397: PPUSH
// begin enable ;
85398: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85399: LD_ADDR_VAR 0 1
85403: PUSH
85404: LD_INT 34
85406: PUSH
85407: LD_EXP 88
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PPUSH
85416: CALL_OW 69
85420: PUSH
85421: FOR_IN
85422: IFFALSE 85642
// begin if not i in hackTanks then
85424: LD_VAR 0 1
85428: PUSH
85429: LD_EXP 105
85433: IN
85434: NOT
85435: IFFALSE 85518
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85437: LD_ADDR_EXP 105
85441: PUSH
85442: LD_EXP 105
85446: PPUSH
85447: LD_EXP 105
85451: PUSH
85452: LD_INT 1
85454: PLUS
85455: PPUSH
85456: LD_VAR 0 1
85460: PPUSH
85461: CALL_OW 1
85465: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85466: LD_ADDR_EXP 106
85470: PUSH
85471: LD_EXP 106
85475: PPUSH
85476: LD_EXP 106
85480: PUSH
85481: LD_INT 1
85483: PLUS
85484: PPUSH
85485: EMPTY
85486: PPUSH
85487: CALL_OW 1
85491: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85492: LD_ADDR_EXP 109
85496: PUSH
85497: LD_EXP 109
85501: PPUSH
85502: LD_EXP 109
85506: PUSH
85507: LD_INT 1
85509: PLUS
85510: PPUSH
85511: EMPTY
85512: PPUSH
85513: CALL_OW 1
85517: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85518: LD_VAR 0 1
85522: PPUSH
85523: CALL_OW 302
85527: NOT
85528: IFFALSE 85541
// begin HackUnlinkAll ( i ) ;
85530: LD_VAR 0 1
85534: PPUSH
85535: CALL 85647 0 1
// continue ;
85539: GO 85421
// end ; HackCheckCapturedStatus ( i ) ;
85541: LD_VAR 0 1
85545: PPUSH
85546: CALL 86090 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85550: LD_ADDR_VAR 0 2
85554: PUSH
85555: LD_INT 81
85557: PUSH
85558: LD_VAR 0 1
85562: PPUSH
85563: CALL_OW 255
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 33
85574: PUSH
85575: LD_INT 3
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 91
85584: PUSH
85585: LD_VAR 0 1
85589: PUSH
85590: LD_EXP 108
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 50
85602: PUSH
85603: EMPTY
85604: LIST
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: PPUSH
85612: CALL_OW 69
85616: ST_TO_ADDR
// if not tmp then
85617: LD_VAR 0 2
85621: NOT
85622: IFFALSE 85626
// continue ;
85624: GO 85421
// HackLink ( i , tmp ) ;
85626: LD_VAR 0 1
85630: PPUSH
85631: LD_VAR 0 2
85635: PPUSH
85636: CALL 85783 0 2
// end ;
85640: GO 85421
85642: POP
85643: POP
// end ;
85644: PPOPN 2
85646: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85647: LD_INT 0
85649: PPUSH
85650: PPUSH
85651: PPUSH
// if not hack in hackTanks then
85652: LD_VAR 0 1
85656: PUSH
85657: LD_EXP 105
85661: IN
85662: NOT
85663: IFFALSE 85667
// exit ;
85665: GO 85778
// index := GetElementIndex ( hackTanks , hack ) ;
85667: LD_ADDR_VAR 0 4
85671: PUSH
85672: LD_EXP 105
85676: PPUSH
85677: LD_VAR 0 1
85681: PPUSH
85682: CALL 14582 0 2
85686: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85687: LD_EXP 106
85691: PUSH
85692: LD_VAR 0 4
85696: ARRAY
85697: IFFALSE 85778
// begin for i in hackTanksCaptured [ index ] do
85699: LD_ADDR_VAR 0 3
85703: PUSH
85704: LD_EXP 106
85708: PUSH
85709: LD_VAR 0 4
85713: ARRAY
85714: PUSH
85715: FOR_IN
85716: IFFALSE 85742
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
85718: LD_VAR 0 3
85722: PUSH
85723: LD_INT 1
85725: ARRAY
85726: PPUSH
85727: LD_VAR 0 3
85731: PUSH
85732: LD_INT 2
85734: ARRAY
85735: PPUSH
85736: CALL_OW 235
85740: GO 85715
85742: POP
85743: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
85744: LD_ADDR_EXP 106
85748: PUSH
85749: LD_EXP 106
85753: PPUSH
85754: LD_VAR 0 4
85758: PPUSH
85759: EMPTY
85760: PPUSH
85761: CALL_OW 1
85765: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
85766: LD_VAR 0 1
85770: PPUSH
85771: LD_INT 0
85773: PPUSH
85774: CALL_OW 505
// end ; end ;
85778: LD_VAR 0 2
85782: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
85783: LD_INT 0
85785: PPUSH
85786: PPUSH
85787: PPUSH
// if not hack in hackTanks or not vehicles then
85788: LD_VAR 0 1
85792: PUSH
85793: LD_EXP 105
85797: IN
85798: NOT
85799: PUSH
85800: LD_VAR 0 2
85804: NOT
85805: OR
85806: IFFALSE 85810
// exit ;
85808: GO 86085
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
85810: LD_ADDR_VAR 0 2
85814: PUSH
85815: LD_VAR 0 1
85819: PPUSH
85820: LD_VAR 0 2
85824: PPUSH
85825: LD_INT 1
85827: PPUSH
85828: LD_INT 1
85830: PPUSH
85831: CALL 15232 0 4
85835: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
85836: LD_ADDR_VAR 0 5
85840: PUSH
85841: LD_EXP 105
85845: PPUSH
85846: LD_VAR 0 1
85850: PPUSH
85851: CALL 14582 0 2
85855: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
85856: LD_EXP 106
85860: PUSH
85861: LD_VAR 0 5
85865: ARRAY
85866: PUSH
85867: LD_EXP 107
85871: LESS
85872: IFFALSE 86061
// begin for i := 1 to vehicles do
85874: LD_ADDR_VAR 0 4
85878: PUSH
85879: DOUBLE
85880: LD_INT 1
85882: DEC
85883: ST_TO_ADDR
85884: LD_VAR 0 2
85888: PUSH
85889: FOR_TO
85890: IFFALSE 86059
// begin if hackTanksCaptured [ index ] = hackLimit then
85892: LD_EXP 106
85896: PUSH
85897: LD_VAR 0 5
85901: ARRAY
85902: PUSH
85903: LD_EXP 107
85907: EQUAL
85908: IFFALSE 85912
// break ;
85910: GO 86059
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
85912: LD_ADDR_EXP 109
85916: PUSH
85917: LD_EXP 109
85921: PPUSH
85922: LD_VAR 0 5
85926: PPUSH
85927: LD_EXP 109
85931: PUSH
85932: LD_VAR 0 5
85936: ARRAY
85937: PUSH
85938: LD_INT 1
85940: PLUS
85941: PPUSH
85942: CALL_OW 1
85946: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
85947: LD_ADDR_EXP 106
85951: PUSH
85952: LD_EXP 106
85956: PPUSH
85957: LD_VAR 0 5
85961: PUSH
85962: LD_EXP 106
85966: PUSH
85967: LD_VAR 0 5
85971: ARRAY
85972: PUSH
85973: LD_INT 1
85975: PLUS
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PPUSH
85981: LD_VAR 0 2
85985: PUSH
85986: LD_VAR 0 4
85990: ARRAY
85991: PUSH
85992: LD_VAR 0 2
85996: PUSH
85997: LD_VAR 0 4
86001: ARRAY
86002: PPUSH
86003: CALL_OW 255
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PPUSH
86012: CALL 14797 0 3
86016: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86017: LD_VAR 0 2
86021: PUSH
86022: LD_VAR 0 4
86026: ARRAY
86027: PPUSH
86028: LD_VAR 0 1
86032: PPUSH
86033: CALL_OW 255
86037: PPUSH
86038: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86042: LD_VAR 0 2
86046: PUSH
86047: LD_VAR 0 4
86051: ARRAY
86052: PPUSH
86053: CALL_OW 141
// end ;
86057: GO 85889
86059: POP
86060: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86061: LD_VAR 0 1
86065: PPUSH
86066: LD_EXP 106
86070: PUSH
86071: LD_VAR 0 5
86075: ARRAY
86076: PUSH
86077: LD_INT 0
86079: PLUS
86080: PPUSH
86081: CALL_OW 505
// end ;
86085: LD_VAR 0 3
86089: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86090: LD_INT 0
86092: PPUSH
86093: PPUSH
86094: PPUSH
86095: PPUSH
// if not hack in hackTanks then
86096: LD_VAR 0 1
86100: PUSH
86101: LD_EXP 105
86105: IN
86106: NOT
86107: IFFALSE 86111
// exit ;
86109: GO 86351
// index := GetElementIndex ( hackTanks , hack ) ;
86111: LD_ADDR_VAR 0 4
86115: PUSH
86116: LD_EXP 105
86120: PPUSH
86121: LD_VAR 0 1
86125: PPUSH
86126: CALL 14582 0 2
86130: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86131: LD_ADDR_VAR 0 3
86135: PUSH
86136: DOUBLE
86137: LD_EXP 106
86141: PUSH
86142: LD_VAR 0 4
86146: ARRAY
86147: INC
86148: ST_TO_ADDR
86149: LD_INT 1
86151: PUSH
86152: FOR_DOWNTO
86153: IFFALSE 86325
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86155: LD_ADDR_VAR 0 5
86159: PUSH
86160: LD_EXP 106
86164: PUSH
86165: LD_VAR 0 4
86169: ARRAY
86170: PUSH
86171: LD_VAR 0 3
86175: ARRAY
86176: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86177: LD_VAR 0 5
86181: PUSH
86182: LD_INT 1
86184: ARRAY
86185: PPUSH
86186: CALL_OW 302
86190: NOT
86191: PUSH
86192: LD_VAR 0 5
86196: PUSH
86197: LD_INT 1
86199: ARRAY
86200: PPUSH
86201: CALL_OW 255
86205: PUSH
86206: LD_VAR 0 1
86210: PPUSH
86211: CALL_OW 255
86215: NONEQUAL
86216: OR
86217: IFFALSE 86323
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86219: LD_VAR 0 5
86223: PUSH
86224: LD_INT 1
86226: ARRAY
86227: PPUSH
86228: CALL_OW 305
86232: PUSH
86233: LD_VAR 0 5
86237: PUSH
86238: LD_INT 1
86240: ARRAY
86241: PPUSH
86242: CALL_OW 255
86246: PUSH
86247: LD_VAR 0 1
86251: PPUSH
86252: CALL_OW 255
86256: EQUAL
86257: AND
86258: IFFALSE 86282
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86260: LD_VAR 0 5
86264: PUSH
86265: LD_INT 1
86267: ARRAY
86268: PPUSH
86269: LD_VAR 0 5
86273: PUSH
86274: LD_INT 2
86276: ARRAY
86277: PPUSH
86278: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86282: LD_ADDR_EXP 106
86286: PUSH
86287: LD_EXP 106
86291: PPUSH
86292: LD_VAR 0 4
86296: PPUSH
86297: LD_EXP 106
86301: PUSH
86302: LD_VAR 0 4
86306: ARRAY
86307: PPUSH
86308: LD_VAR 0 3
86312: PPUSH
86313: CALL_OW 3
86317: PPUSH
86318: CALL_OW 1
86322: ST_TO_ADDR
// end ; end ;
86323: GO 86152
86325: POP
86326: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86327: LD_VAR 0 1
86331: PPUSH
86332: LD_EXP 106
86336: PUSH
86337: LD_VAR 0 4
86341: ARRAY
86342: PUSH
86343: LD_INT 0
86345: PLUS
86346: PPUSH
86347: CALL_OW 505
// end ;
86351: LD_VAR 0 2
86355: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86356: LD_INT 0
86358: PPUSH
86359: PPUSH
86360: PPUSH
86361: PPUSH
// if not hack in hackTanks then
86362: LD_VAR 0 1
86366: PUSH
86367: LD_EXP 105
86371: IN
86372: NOT
86373: IFFALSE 86377
// exit ;
86375: GO 86462
// index := GetElementIndex ( hackTanks , hack ) ;
86377: LD_ADDR_VAR 0 5
86381: PUSH
86382: LD_EXP 105
86386: PPUSH
86387: LD_VAR 0 1
86391: PPUSH
86392: CALL 14582 0 2
86396: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86397: LD_ADDR_VAR 0 4
86401: PUSH
86402: DOUBLE
86403: LD_INT 1
86405: DEC
86406: ST_TO_ADDR
86407: LD_EXP 106
86411: PUSH
86412: LD_VAR 0 5
86416: ARRAY
86417: PUSH
86418: FOR_TO
86419: IFFALSE 86460
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86421: LD_EXP 106
86425: PUSH
86426: LD_VAR 0 5
86430: ARRAY
86431: PUSH
86432: LD_VAR 0 4
86436: ARRAY
86437: PUSH
86438: LD_INT 1
86440: ARRAY
86441: PUSH
86442: LD_VAR 0 2
86446: EQUAL
86447: IFFALSE 86458
// KillUnit ( vehicle ) ;
86449: LD_VAR 0 2
86453: PPUSH
86454: CALL_OW 66
86458: GO 86418
86460: POP
86461: POP
// end ;
86462: LD_VAR 0 3
86466: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86467: LD_EXP 110
86471: NOT
86472: IFFALSE 86507
86474: GO 86476
86476: DISABLE
// begin initMiner := true ;
86477: LD_ADDR_EXP 110
86481: PUSH
86482: LD_INT 1
86484: ST_TO_ADDR
// minersList := [ ] ;
86485: LD_ADDR_EXP 111
86489: PUSH
86490: EMPTY
86491: ST_TO_ADDR
// minerMinesList := [ ] ;
86492: LD_ADDR_EXP 112
86496: PUSH
86497: EMPTY
86498: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86499: LD_ADDR_EXP 113
86503: PUSH
86504: LD_INT 5
86506: ST_TO_ADDR
// end ;
86507: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86508: LD_EXP 110
86512: PUSH
86513: LD_INT 34
86515: PUSH
86516: LD_EXP 93
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PPUSH
86525: CALL_OW 69
86529: AND
86530: IFFALSE 86993
86532: GO 86534
86534: DISABLE
86535: LD_INT 0
86537: PPUSH
86538: PPUSH
86539: PPUSH
86540: PPUSH
// begin enable ;
86541: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86542: LD_ADDR_VAR 0 1
86546: PUSH
86547: LD_INT 34
86549: PUSH
86550: LD_EXP 93
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PPUSH
86559: CALL_OW 69
86563: PUSH
86564: FOR_IN
86565: IFFALSE 86637
// begin if not i in minersList then
86567: LD_VAR 0 1
86571: PUSH
86572: LD_EXP 111
86576: IN
86577: NOT
86578: IFFALSE 86635
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86580: LD_ADDR_EXP 111
86584: PUSH
86585: LD_EXP 111
86589: PPUSH
86590: LD_EXP 111
86594: PUSH
86595: LD_INT 1
86597: PLUS
86598: PPUSH
86599: LD_VAR 0 1
86603: PPUSH
86604: CALL_OW 1
86608: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86609: LD_ADDR_EXP 112
86613: PUSH
86614: LD_EXP 112
86618: PPUSH
86619: LD_EXP 112
86623: PUSH
86624: LD_INT 1
86626: PLUS
86627: PPUSH
86628: EMPTY
86629: PPUSH
86630: CALL_OW 1
86634: ST_TO_ADDR
// end end ;
86635: GO 86564
86637: POP
86638: POP
// for i := minerMinesList downto 1 do
86639: LD_ADDR_VAR 0 1
86643: PUSH
86644: DOUBLE
86645: LD_EXP 112
86649: INC
86650: ST_TO_ADDR
86651: LD_INT 1
86653: PUSH
86654: FOR_DOWNTO
86655: IFFALSE 86991
// begin if IsLive ( minersList [ i ] ) then
86657: LD_EXP 111
86661: PUSH
86662: LD_VAR 0 1
86666: ARRAY
86667: PPUSH
86668: CALL_OW 300
86672: IFFALSE 86700
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86674: LD_EXP 111
86678: PUSH
86679: LD_VAR 0 1
86683: ARRAY
86684: PPUSH
86685: LD_EXP 112
86689: PUSH
86690: LD_VAR 0 1
86694: ARRAY
86695: PPUSH
86696: CALL_OW 505
// if not minerMinesList [ i ] then
86700: LD_EXP 112
86704: PUSH
86705: LD_VAR 0 1
86709: ARRAY
86710: NOT
86711: IFFALSE 86715
// continue ;
86713: GO 86654
// for j := minerMinesList [ i ] downto 1 do
86715: LD_ADDR_VAR 0 2
86719: PUSH
86720: DOUBLE
86721: LD_EXP 112
86725: PUSH
86726: LD_VAR 0 1
86730: ARRAY
86731: INC
86732: ST_TO_ADDR
86733: LD_INT 1
86735: PUSH
86736: FOR_DOWNTO
86737: IFFALSE 86987
// begin side := GetSide ( minersList [ i ] ) ;
86739: LD_ADDR_VAR 0 3
86743: PUSH
86744: LD_EXP 111
86748: PUSH
86749: LD_VAR 0 1
86753: ARRAY
86754: PPUSH
86755: CALL_OW 255
86759: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
86760: LD_ADDR_VAR 0 4
86764: PUSH
86765: LD_EXP 112
86769: PUSH
86770: LD_VAR 0 1
86774: ARRAY
86775: PUSH
86776: LD_VAR 0 2
86780: ARRAY
86781: PUSH
86782: LD_INT 1
86784: ARRAY
86785: PPUSH
86786: LD_EXP 112
86790: PUSH
86791: LD_VAR 0 1
86795: ARRAY
86796: PUSH
86797: LD_VAR 0 2
86801: ARRAY
86802: PUSH
86803: LD_INT 2
86805: ARRAY
86806: PPUSH
86807: CALL_OW 428
86811: ST_TO_ADDR
// if not tmp then
86812: LD_VAR 0 4
86816: NOT
86817: IFFALSE 86821
// continue ;
86819: GO 86736
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
86821: LD_VAR 0 4
86825: PUSH
86826: LD_INT 81
86828: PUSH
86829: LD_VAR 0 3
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PPUSH
86838: CALL_OW 69
86842: IN
86843: PUSH
86844: LD_EXP 112
86848: PUSH
86849: LD_VAR 0 1
86853: ARRAY
86854: PUSH
86855: LD_VAR 0 2
86859: ARRAY
86860: PUSH
86861: LD_INT 1
86863: ARRAY
86864: PPUSH
86865: LD_EXP 112
86869: PUSH
86870: LD_VAR 0 1
86874: ARRAY
86875: PUSH
86876: LD_VAR 0 2
86880: ARRAY
86881: PUSH
86882: LD_INT 2
86884: ARRAY
86885: PPUSH
86886: CALL_OW 458
86890: AND
86891: IFFALSE 86985
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
86893: LD_EXP 112
86897: PUSH
86898: LD_VAR 0 1
86902: ARRAY
86903: PUSH
86904: LD_VAR 0 2
86908: ARRAY
86909: PUSH
86910: LD_INT 1
86912: ARRAY
86913: PPUSH
86914: LD_EXP 112
86918: PUSH
86919: LD_VAR 0 1
86923: ARRAY
86924: PUSH
86925: LD_VAR 0 2
86929: ARRAY
86930: PUSH
86931: LD_INT 2
86933: ARRAY
86934: PPUSH
86935: LD_VAR 0 3
86939: PPUSH
86940: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
86944: LD_ADDR_EXP 112
86948: PUSH
86949: LD_EXP 112
86953: PPUSH
86954: LD_VAR 0 1
86958: PPUSH
86959: LD_EXP 112
86963: PUSH
86964: LD_VAR 0 1
86968: ARRAY
86969: PPUSH
86970: LD_VAR 0 2
86974: PPUSH
86975: CALL_OW 3
86979: PPUSH
86980: CALL_OW 1
86984: ST_TO_ADDR
// end ; end ;
86985: GO 86736
86987: POP
86988: POP
// end ;
86989: GO 86654
86991: POP
86992: POP
// end ;
86993: PPOPN 4
86995: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
86996: LD_INT 0
86998: PPUSH
86999: PPUSH
// result := false ;
87000: LD_ADDR_VAR 0 4
87004: PUSH
87005: LD_INT 0
87007: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87008: LD_VAR 0 1
87012: PPUSH
87013: CALL_OW 264
87017: PUSH
87018: LD_EXP 93
87022: EQUAL
87023: NOT
87024: IFFALSE 87028
// exit ;
87026: GO 87268
// index := GetElementIndex ( minersList , unit ) ;
87028: LD_ADDR_VAR 0 5
87032: PUSH
87033: LD_EXP 111
87037: PPUSH
87038: LD_VAR 0 1
87042: PPUSH
87043: CALL 14582 0 2
87047: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87048: LD_EXP 112
87052: PUSH
87053: LD_VAR 0 5
87057: ARRAY
87058: PUSH
87059: LD_EXP 113
87063: GREATEREQUAL
87064: IFFALSE 87068
// exit ;
87066: GO 87268
// ComMoveXY ( unit , x , y ) ;
87068: LD_VAR 0 1
87072: PPUSH
87073: LD_VAR 0 2
87077: PPUSH
87078: LD_VAR 0 3
87082: PPUSH
87083: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87087: LD_INT 35
87089: PPUSH
87090: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87094: LD_VAR 0 1
87098: PPUSH
87099: LD_VAR 0 2
87103: PPUSH
87104: LD_VAR 0 3
87108: PPUSH
87109: CALL 44646 0 3
87113: NOT
87114: PUSH
87115: LD_VAR 0 1
87119: PPUSH
87120: CALL_OW 314
87124: AND
87125: IFFALSE 87129
// exit ;
87127: GO 87268
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87129: LD_VAR 0 2
87133: PPUSH
87134: LD_VAR 0 3
87138: PPUSH
87139: CALL_OW 428
87143: PUSH
87144: LD_VAR 0 1
87148: EQUAL
87149: PUSH
87150: LD_VAR 0 1
87154: PPUSH
87155: CALL_OW 314
87159: NOT
87160: AND
87161: IFFALSE 87087
// PlaySoundXY ( x , y , PlantMine ) ;
87163: LD_VAR 0 2
87167: PPUSH
87168: LD_VAR 0 3
87172: PPUSH
87173: LD_STRING PlantMine
87175: PPUSH
87176: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87180: LD_VAR 0 2
87184: PPUSH
87185: LD_VAR 0 3
87189: PPUSH
87190: LD_VAR 0 1
87194: PPUSH
87195: CALL_OW 255
87199: PPUSH
87200: LD_INT 0
87202: PPUSH
87203: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87207: LD_ADDR_EXP 112
87211: PUSH
87212: LD_EXP 112
87216: PPUSH
87217: LD_VAR 0 5
87221: PUSH
87222: LD_EXP 112
87226: PUSH
87227: LD_VAR 0 5
87231: ARRAY
87232: PUSH
87233: LD_INT 1
87235: PLUS
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PPUSH
87241: LD_VAR 0 2
87245: PUSH
87246: LD_VAR 0 3
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PPUSH
87255: CALL 14797 0 3
87259: ST_TO_ADDR
// result := true ;
87260: LD_ADDR_VAR 0 4
87264: PUSH
87265: LD_INT 1
87267: ST_TO_ADDR
// end ;
87268: LD_VAR 0 4
87272: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87273: LD_INT 0
87275: PPUSH
87276: PPUSH
87277: PPUSH
// if not unit in minersList then
87278: LD_VAR 0 1
87282: PUSH
87283: LD_EXP 111
87287: IN
87288: NOT
87289: IFFALSE 87293
// exit ;
87291: GO 87685
// index := GetElementIndex ( minersList , unit ) ;
87293: LD_ADDR_VAR 0 6
87297: PUSH
87298: LD_EXP 111
87302: PPUSH
87303: LD_VAR 0 1
87307: PPUSH
87308: CALL 14582 0 2
87312: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87313: LD_ADDR_VAR 0 5
87317: PUSH
87318: DOUBLE
87319: LD_EXP 112
87323: PUSH
87324: LD_VAR 0 6
87328: ARRAY
87329: INC
87330: ST_TO_ADDR
87331: LD_INT 1
87333: PUSH
87334: FOR_DOWNTO
87335: IFFALSE 87496
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87337: LD_EXP 112
87341: PUSH
87342: LD_VAR 0 6
87346: ARRAY
87347: PUSH
87348: LD_VAR 0 5
87352: ARRAY
87353: PUSH
87354: LD_INT 1
87356: ARRAY
87357: PUSH
87358: LD_VAR 0 2
87362: EQUAL
87363: PUSH
87364: LD_EXP 112
87368: PUSH
87369: LD_VAR 0 6
87373: ARRAY
87374: PUSH
87375: LD_VAR 0 5
87379: ARRAY
87380: PUSH
87381: LD_INT 2
87383: ARRAY
87384: PUSH
87385: LD_VAR 0 3
87389: EQUAL
87390: AND
87391: IFFALSE 87494
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87393: LD_EXP 112
87397: PUSH
87398: LD_VAR 0 6
87402: ARRAY
87403: PUSH
87404: LD_VAR 0 5
87408: ARRAY
87409: PUSH
87410: LD_INT 1
87412: ARRAY
87413: PPUSH
87414: LD_EXP 112
87418: PUSH
87419: LD_VAR 0 6
87423: ARRAY
87424: PUSH
87425: LD_VAR 0 5
87429: ARRAY
87430: PUSH
87431: LD_INT 2
87433: ARRAY
87434: PPUSH
87435: LD_VAR 0 1
87439: PPUSH
87440: CALL_OW 255
87444: PPUSH
87445: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87449: LD_ADDR_EXP 112
87453: PUSH
87454: LD_EXP 112
87458: PPUSH
87459: LD_VAR 0 6
87463: PPUSH
87464: LD_EXP 112
87468: PUSH
87469: LD_VAR 0 6
87473: ARRAY
87474: PPUSH
87475: LD_VAR 0 5
87479: PPUSH
87480: CALL_OW 3
87484: PPUSH
87485: CALL_OW 1
87489: ST_TO_ADDR
// exit ;
87490: POP
87491: POP
87492: GO 87685
// end ; end ;
87494: GO 87334
87496: POP
87497: POP
// for i := minerMinesList [ index ] downto 1 do
87498: LD_ADDR_VAR 0 5
87502: PUSH
87503: DOUBLE
87504: LD_EXP 112
87508: PUSH
87509: LD_VAR 0 6
87513: ARRAY
87514: INC
87515: ST_TO_ADDR
87516: LD_INT 1
87518: PUSH
87519: FOR_DOWNTO
87520: IFFALSE 87683
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87522: LD_EXP 112
87526: PUSH
87527: LD_VAR 0 6
87531: ARRAY
87532: PUSH
87533: LD_VAR 0 5
87537: ARRAY
87538: PUSH
87539: LD_INT 1
87541: ARRAY
87542: PPUSH
87543: LD_EXP 112
87547: PUSH
87548: LD_VAR 0 6
87552: ARRAY
87553: PUSH
87554: LD_VAR 0 5
87558: ARRAY
87559: PUSH
87560: LD_INT 2
87562: ARRAY
87563: PPUSH
87564: LD_VAR 0 2
87568: PPUSH
87569: LD_VAR 0 3
87573: PPUSH
87574: CALL_OW 298
87578: PUSH
87579: LD_INT 6
87581: LESS
87582: IFFALSE 87681
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87584: LD_EXP 112
87588: PUSH
87589: LD_VAR 0 6
87593: ARRAY
87594: PUSH
87595: LD_VAR 0 5
87599: ARRAY
87600: PUSH
87601: LD_INT 1
87603: ARRAY
87604: PPUSH
87605: LD_EXP 112
87609: PUSH
87610: LD_VAR 0 6
87614: ARRAY
87615: PUSH
87616: LD_VAR 0 5
87620: ARRAY
87621: PUSH
87622: LD_INT 2
87624: ARRAY
87625: PPUSH
87626: LD_VAR 0 1
87630: PPUSH
87631: CALL_OW 255
87635: PPUSH
87636: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87640: LD_ADDR_EXP 112
87644: PUSH
87645: LD_EXP 112
87649: PPUSH
87650: LD_VAR 0 6
87654: PPUSH
87655: LD_EXP 112
87659: PUSH
87660: LD_VAR 0 6
87664: ARRAY
87665: PPUSH
87666: LD_VAR 0 5
87670: PPUSH
87671: CALL_OW 3
87675: PPUSH
87676: CALL_OW 1
87680: ST_TO_ADDR
// end ; end ;
87681: GO 87519
87683: POP
87684: POP
// end ;
87685: LD_VAR 0 4
87689: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87690: LD_INT 0
87692: PPUSH
87693: PPUSH
87694: PPUSH
87695: PPUSH
87696: PPUSH
87697: PPUSH
87698: PPUSH
87699: PPUSH
87700: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
87701: LD_VAR 0 1
87705: PPUSH
87706: CALL_OW 264
87710: PUSH
87711: LD_EXP 93
87715: EQUAL
87716: NOT
87717: PUSH
87718: LD_VAR 0 1
87722: PUSH
87723: LD_EXP 111
87727: IN
87728: NOT
87729: OR
87730: IFFALSE 87734
// exit ;
87732: GO 88056
// index := GetElementIndex ( minersList , unit ) ;
87734: LD_ADDR_VAR 0 6
87738: PUSH
87739: LD_EXP 111
87743: PPUSH
87744: LD_VAR 0 1
87748: PPUSH
87749: CALL 14582 0 2
87753: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
87754: LD_ADDR_VAR 0 8
87758: PUSH
87759: LD_EXP 113
87763: PUSH
87764: LD_EXP 112
87768: PUSH
87769: LD_VAR 0 6
87773: ARRAY
87774: MINUS
87775: ST_TO_ADDR
// if not minesFreeAmount then
87776: LD_VAR 0 8
87780: NOT
87781: IFFALSE 87785
// exit ;
87783: GO 88056
// tmp := [ ] ;
87785: LD_ADDR_VAR 0 7
87789: PUSH
87790: EMPTY
87791: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
87792: LD_ADDR_VAR 0 5
87796: PUSH
87797: DOUBLE
87798: LD_INT 1
87800: DEC
87801: ST_TO_ADDR
87802: LD_VAR 0 8
87806: PUSH
87807: FOR_TO
87808: IFFALSE 88003
// begin _d := rand ( 0 , 5 ) ;
87810: LD_ADDR_VAR 0 11
87814: PUSH
87815: LD_INT 0
87817: PPUSH
87818: LD_INT 5
87820: PPUSH
87821: CALL_OW 12
87825: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
87826: LD_ADDR_VAR 0 12
87830: PUSH
87831: LD_INT 2
87833: PPUSH
87834: LD_INT 6
87836: PPUSH
87837: CALL_OW 12
87841: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
87842: LD_ADDR_VAR 0 9
87846: PUSH
87847: LD_VAR 0 2
87851: PPUSH
87852: LD_VAR 0 11
87856: PPUSH
87857: LD_VAR 0 12
87861: PPUSH
87862: CALL_OW 272
87866: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
87867: LD_ADDR_VAR 0 10
87871: PUSH
87872: LD_VAR 0 3
87876: PPUSH
87877: LD_VAR 0 11
87881: PPUSH
87882: LD_VAR 0 12
87886: PPUSH
87887: CALL_OW 273
87891: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
87892: LD_VAR 0 9
87896: PPUSH
87897: LD_VAR 0 10
87901: PPUSH
87902: CALL_OW 488
87906: PUSH
87907: LD_VAR 0 9
87911: PUSH
87912: LD_VAR 0 10
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_VAR 0 7
87925: IN
87926: NOT
87927: AND
87928: PUSH
87929: LD_VAR 0 9
87933: PPUSH
87934: LD_VAR 0 10
87938: PPUSH
87939: CALL_OW 458
87943: NOT
87944: AND
87945: IFFALSE 87987
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
87947: LD_ADDR_VAR 0 7
87951: PUSH
87952: LD_VAR 0 7
87956: PPUSH
87957: LD_VAR 0 7
87961: PUSH
87962: LD_INT 1
87964: PLUS
87965: PPUSH
87966: LD_VAR 0 9
87970: PUSH
87971: LD_VAR 0 10
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PPUSH
87980: CALL_OW 1
87984: ST_TO_ADDR
87985: GO 88001
// i := i - 1 ;
87987: LD_ADDR_VAR 0 5
87991: PUSH
87992: LD_VAR 0 5
87996: PUSH
87997: LD_INT 1
87999: MINUS
88000: ST_TO_ADDR
// end ;
88001: GO 87807
88003: POP
88004: POP
// for i in tmp do
88005: LD_ADDR_VAR 0 5
88009: PUSH
88010: LD_VAR 0 7
88014: PUSH
88015: FOR_IN
88016: IFFALSE 88054
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88018: LD_VAR 0 1
88022: PPUSH
88023: LD_VAR 0 5
88027: PUSH
88028: LD_INT 1
88030: ARRAY
88031: PPUSH
88032: LD_VAR 0 5
88036: PUSH
88037: LD_INT 2
88039: ARRAY
88040: PPUSH
88041: CALL 86996 0 3
88045: NOT
88046: IFFALSE 88052
// exit ;
88048: POP
88049: POP
88050: GO 88056
88052: GO 88015
88054: POP
88055: POP
// end ;
88056: LD_VAR 0 4
88060: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88061: LD_INT 0
88063: PPUSH
88064: PPUSH
88065: PPUSH
88066: PPUSH
88067: PPUSH
88068: PPUSH
88069: PPUSH
// if not GetClass ( unit ) = class_sniper then
88070: LD_VAR 0 1
88074: PPUSH
88075: CALL_OW 257
88079: PUSH
88080: LD_INT 5
88082: EQUAL
88083: NOT
88084: IFFALSE 88088
// exit ;
88086: GO 88476
// dist := 8 ;
88088: LD_ADDR_VAR 0 5
88092: PUSH
88093: LD_INT 8
88095: ST_TO_ADDR
// viewRange := 12 ;
88096: LD_ADDR_VAR 0 7
88100: PUSH
88101: LD_INT 12
88103: ST_TO_ADDR
// side := GetSide ( unit ) ;
88104: LD_ADDR_VAR 0 6
88108: PUSH
88109: LD_VAR 0 1
88113: PPUSH
88114: CALL_OW 255
88118: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88119: LD_INT 61
88121: PPUSH
88122: LD_VAR 0 6
88126: PPUSH
88127: CALL_OW 321
88131: PUSH
88132: LD_INT 2
88134: EQUAL
88135: IFFALSE 88145
// viewRange := 16 ;
88137: LD_ADDR_VAR 0 7
88141: PUSH
88142: LD_INT 16
88144: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88145: LD_VAR 0 1
88149: PPUSH
88150: LD_VAR 0 2
88154: PPUSH
88155: LD_VAR 0 3
88159: PPUSH
88160: CALL_OW 297
88164: PUSH
88165: LD_VAR 0 5
88169: GREATER
88170: IFFALSE 88249
// begin ComMoveXY ( unit , x , y ) ;
88172: LD_VAR 0 1
88176: PPUSH
88177: LD_VAR 0 2
88181: PPUSH
88182: LD_VAR 0 3
88186: PPUSH
88187: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88191: LD_INT 35
88193: PPUSH
88194: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88198: LD_VAR 0 1
88202: PPUSH
88203: LD_VAR 0 2
88207: PPUSH
88208: LD_VAR 0 3
88212: PPUSH
88213: CALL 44646 0 3
88217: NOT
88218: IFFALSE 88222
// exit ;
88220: GO 88476
// until GetDistUnitXY ( unit , x , y ) < dist ;
88222: LD_VAR 0 1
88226: PPUSH
88227: LD_VAR 0 2
88231: PPUSH
88232: LD_VAR 0 3
88236: PPUSH
88237: CALL_OW 297
88241: PUSH
88242: LD_VAR 0 5
88246: LESS
88247: IFFALSE 88191
// end ; ComTurnXY ( unit , x , y ) ;
88249: LD_VAR 0 1
88253: PPUSH
88254: LD_VAR 0 2
88258: PPUSH
88259: LD_VAR 0 3
88263: PPUSH
88264: CALL_OW 118
// wait ( 5 ) ;
88268: LD_INT 5
88270: PPUSH
88271: CALL_OW 67
// _d := GetDir ( unit ) ;
88275: LD_ADDR_VAR 0 10
88279: PUSH
88280: LD_VAR 0 1
88284: PPUSH
88285: CALL_OW 254
88289: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88290: LD_ADDR_VAR 0 8
88294: PUSH
88295: LD_VAR 0 1
88299: PPUSH
88300: CALL_OW 250
88304: PPUSH
88305: LD_VAR 0 10
88309: PPUSH
88310: LD_VAR 0 5
88314: PPUSH
88315: CALL_OW 272
88319: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88320: LD_ADDR_VAR 0 9
88324: PUSH
88325: LD_VAR 0 1
88329: PPUSH
88330: CALL_OW 251
88334: PPUSH
88335: LD_VAR 0 10
88339: PPUSH
88340: LD_VAR 0 5
88344: PPUSH
88345: CALL_OW 273
88349: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88350: LD_VAR 0 8
88354: PPUSH
88355: LD_VAR 0 9
88359: PPUSH
88360: CALL_OW 488
88364: NOT
88365: IFFALSE 88369
// exit ;
88367: GO 88476
// ComAnimCustom ( unit , 1 ) ;
88369: LD_VAR 0 1
88373: PPUSH
88374: LD_INT 1
88376: PPUSH
88377: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88381: LD_VAR 0 8
88385: PPUSH
88386: LD_VAR 0 9
88390: PPUSH
88391: LD_VAR 0 6
88395: PPUSH
88396: LD_VAR 0 7
88400: PPUSH
88401: CALL_OW 330
// repeat wait ( 1 ) ;
88405: LD_INT 1
88407: PPUSH
88408: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88412: LD_VAR 0 1
88416: PPUSH
88417: CALL_OW 316
88421: PUSH
88422: LD_VAR 0 1
88426: PPUSH
88427: CALL_OW 314
88431: OR
88432: PUSH
88433: LD_VAR 0 1
88437: PPUSH
88438: CALL_OW 302
88442: NOT
88443: OR
88444: PUSH
88445: LD_VAR 0 1
88449: PPUSH
88450: CALL_OW 301
88454: OR
88455: IFFALSE 88405
// RemoveSeeing ( _x , _y , side ) ;
88457: LD_VAR 0 8
88461: PPUSH
88462: LD_VAR 0 9
88466: PPUSH
88467: LD_VAR 0 6
88471: PPUSH
88472: CALL_OW 331
// end ; end_of_file
88476: LD_VAR 0 4
88480: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88481: LD_VAR 0 1
88485: PUSH
88486: LD_INT 200
88488: DOUBLE
88489: GREATEREQUAL
88490: IFFALSE 88498
88492: LD_INT 299
88494: DOUBLE
88495: LESSEQUAL
88496: IFTRUE 88500
88498: GO 88532
88500: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
88501: LD_VAR 0 1
88505: PPUSH
88506: LD_VAR 0 2
88510: PPUSH
88511: LD_VAR 0 3
88515: PPUSH
88516: LD_VAR 0 4
88520: PPUSH
88521: LD_VAR 0 5
88525: PPUSH
88526: CALL 84598 0 5
88530: GO 88533
88532: POP
// end ;
88533: PPOPN 11
88535: END
