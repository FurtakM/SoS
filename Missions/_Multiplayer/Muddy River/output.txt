// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 331 0 0
// InitMultiplayer ;
  20: CALL 592 0 0
// if debug then
  24: LD_EXP 1
  28: IFFALSE 37
// FogOff ( 1 ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL_OW 344
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  37: LD_INT 2
  39: PPUSH
  40: CALL 1868 0 1
  44: PPUSH
  45: CALL 5813 0 1
// Multiplayer_Start ;
  49: CALL 3730 0 0
// ResetFog ;
  53: CALL_OW 335
// InitMacro ;
  57: CALL 51233 0 0
// MC_Start ( ) ;
  61: CALL 53413 0 0
// game := true ;
  65: LD_ADDR_EXP 2
  69: PUSH
  70: LD_INT 1
  72: ST_TO_ADDR
// Multiplayer_End ;
  73: CALL 3846 0 0
// end ;
  77: END
// export function CustomInitMacro ; var i ; begin
  78: LD_INT 0
  80: PPUSH
  81: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
  82: LD_INT 1
  84: PPUSH
  85: LD_INT 8
  87: PUSH
  88: LD_INT 10
  90: PUSH
  91: LD_INT 12
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: PUSH
  99: LD_OWVAR 67
 103: ARRAY
 104: PPUSH
 105: LD_INT 3
 107: PPUSH
 108: CALL 75151 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 112: LD_INT 2
 114: PPUSH
 115: LD_INT 6
 117: PUSH
 118: LD_INT 8
 120: PUSH
 121: LD_INT 9
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 75151 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 6
 147: PUSH
 148: LD_INT 7
 150: PUSH
 151: LD_INT 9
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: PPUSH
 165: LD_INT 1
 167: PPUSH
 168: CALL 75151 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 172: LD_INT 4
 174: PPUSH
 175: LD_INT 6
 177: PUSH
 178: LD_INT 7
 180: PUSH
 181: LD_INT 9
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: PPUSH
 195: LD_INT 25
 197: PPUSH
 198: CALL 75151 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 202: LD_INT 5
 204: PPUSH
 205: LD_INT 4
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 6
 213: PUSH
 214: EMPTY
 215: LIST
 216: LIST
 217: LIST
 218: PUSH
 219: LD_OWVAR 67
 223: ARRAY
 224: PPUSH
 225: LD_INT 39
 227: PPUSH
 228: CALL 75151 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 232: LD_ADDR_EXP 67
 236: PUSH
 237: LD_INT 20
 239: PUSH
 240: LD_INT 21
 242: PUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 24
 248: PUSH
 249: LD_INT 20
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 259: LD_ADDR_EXP 68
 263: PUSH
 264: LD_INT 35
 266: PUSH
 267: LD_INT 34
 269: PUSH
 270: LD_INT 36
 272: PUSH
 273: LD_INT 33
 275: PUSH
 276: LD_INT 38
 278: PUSH
 279: EMPTY
 280: LIST
 281: LIST
 282: LIST
 283: LIST
 284: LIST
 285: ST_TO_ADDR
// for i = 1 to 4 do
 286: LD_ADDR_VAR 0 2
 290: PUSH
 291: DOUBLE
 292: LD_INT 1
 294: DEC
 295: ST_TO_ADDR
 296: LD_INT 4
 298: PUSH
 299: FOR_TO
 300: IFFALSE 324
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 302: LD_VAR 0 2
 306: PPUSH
 307: LD_EXP 38
 311: PUSH
 312: LD_VAR 0 2
 316: ARRAY
 317: PPUSH
 318: CALL 75577 0 2
 322: GO 299
 324: POP
 325: POP
// end ;
 326: LD_VAR 0 1
 330: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 331: LD_INT 0
 333: PPUSH
// debug := 1 ;
 334: LD_ADDR_EXP 1
 338: PUSH
 339: LD_INT 1
 341: ST_TO_ADDR
// side_bot := 2 ;
 342: LD_ADDR_EXP 3
 346: PUSH
 347: LD_INT 2
 349: ST_TO_ADDR
// artifact_get := false ;
 350: LD_ADDR_EXP 4
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 358: LD_ADDR_EXP 5
 362: PUSH
 363: LD_STRING base_a
 365: PUSH
 366: LD_STRING base_b
 368: PUSH
 369: LD_STRING base_c
 371: PUSH
 372: LD_STRING base_d
 374: PUSH
 375: LD_STRING base_e
 377: PUSH
 378: LD_STRING base_f
 380: PUSH
 381: LD_STRING base_g
 383: PUSH
 384: LD_STRING base_h
 386: PUSH
 387: LD_STRING base_i
 389: PUSH
 390: LD_STRING base_j
 392: PUSH
 393: LD_STRING base_k
 395: PUSH
 396: LD_STRING base_l
 398: PUSH
 399: LD_STRING base_m
 401: PUSH
 402: LD_STRING base_n
 404: PUSH
 405: LD_STRING base_o
 407: PUSH
 408: LD_STRING base_p
 410: PUSH
 411: LD_STRING base_r
 413: PUSH
 414: LD_STRING base_s
 416: PUSH
 417: LD_STRING base_t
 419: PUSH
 420: LD_STRING base_u
 422: PUSH
 423: LD_STRING base_w
 425: PUSH
 426: LD_STRING base_x
 428: PUSH
 429: LD_STRING base_y
 431: PUSH
 432: LD_STRING base_z
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// end ;
 461: LD_VAR 0 1
 465: RET
// every 0 0$01 trigger game and not debug_strings do
 466: LD_EXP 2
 470: PUSH
 471: LD_OWVAR 48
 475: NOT
 476: AND
 477: IFFALSE 493
 479: GO 481
 481: DISABLE
// begin enable ;
 482: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 483: LD_ADDR_OWVAR 47
 487: PUSH
 488: CALL 4547 0 0
 492: ST_TO_ADDR
// end ;
 493: END
// function Debuger ; var i ; begin
 494: LD_INT 0
 496: PPUSH
 497: PPUSH
// if not debug then
 498: LD_EXP 1
 502: NOT
 503: IFFALSE 507
// exit ;
 505: GO 579
// game_speed := 5 ;
 507: LD_ADDR_OWVAR 65
 511: PUSH
 512: LD_INT 5
 514: ST_TO_ADDR
// uc_side := 1 ;
 515: LD_ADDR_OWVAR 20
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// uc_nation := 1 ;
 523: LD_ADDR_OWVAR 21
 527: PUSH
 528: LD_INT 1
 530: ST_TO_ADDR
// for i = 1 to 10 do
 531: LD_ADDR_VAR 0 2
 535: PUSH
 536: DOUBLE
 537: LD_INT 1
 539: DEC
 540: ST_TO_ADDR
 541: LD_INT 10
 543: PUSH
 544: FOR_TO
 545: IFFALSE 577
// begin PrepareHuman ( false , 1 , 10 ) ;
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 10
 555: PPUSH
 556: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 560: CALL_OW 44
 564: PPUSH
 565: LD_INT 9
 567: PPUSH
 568: LD_INT 0
 570: PPUSH
 571: CALL_OW 49
// end ;
 575: GO 544
 577: POP
 578: POP
// end ;
 579: LD_VAR 0 1
 583: RET
// export function CustomEvent ( event ) ; begin
 584: LD_INT 0
 586: PPUSH
// end ; end_of_file
 587: LD_VAR 0 2
 591: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 592: LD_INT 0
 594: PPUSH
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
// multi_settings_counter := 6 ;
 599: LD_ADDR_EXP 18
 603: PUSH
 604: LD_INT 6
 606: ST_TO_ADDR
// if multiplayer then
 607: LD_OWVAR 4
 611: IFFALSE 791
// begin your_side := mp_player_side ;
 613: LD_ADDR_OWVAR 2
 617: PUSH
 618: LD_OWVAR 7
 622: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 623: LD_ADDR_EXP 6
 627: PUSH
 628: LD_OWVAR 6
 632: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 633: LD_ADDR_EXP 7
 637: PUSH
 638: LD_OWVAR 17
 642: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 643: LD_ADDR_EXP 8
 647: PUSH
 648: LD_OWVAR 15
 652: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 653: LD_ADDR_EXP 9
 657: PUSH
 658: LD_OWVAR 16
 662: ST_TO_ADDR
// multi_teams := [ [ ] ] ;
 663: LD_ADDR_EXP 10
 667: PUSH
 668: EMPTY
 669: PUSH
 670: EMPTY
 671: LIST
 672: ST_TO_ADDR
// for i in mp_teams do
 673: LD_ADDR_VAR 0 2
 677: PUSH
 678: LD_OWVAR 12
 682: PUSH
 683: FOR_IN
 684: IFFALSE 727
// if i then
 686: LD_VAR 0 2
 690: IFFALSE 725
// multi_teams := Replace ( multi_teams , 1 , multi_teams [ 1 ] union i ) ;
 692: LD_ADDR_EXP 10
 696: PUSH
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 1
 704: PPUSH
 705: LD_EXP 10
 709: PUSH
 710: LD_INT 1
 712: ARRAY
 713: PUSH
 714: LD_VAR 0 2
 718: UNION
 719: PPUSH
 720: CALL_OW 1
 724: ST_TO_ADDR
 725: GO 683
 727: POP
 728: POP
// for i = 1 to multi_settings_counter do
 729: LD_ADDR_VAR 0 2
 733: PUSH
 734: DOUBLE
 735: LD_INT 1
 737: DEC
 738: ST_TO_ADDR
 739: LD_EXP 18
 743: PUSH
 744: FOR_TO
 745: IFFALSE 787
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 747: LD_ADDR_EXP 17
 751: PUSH
 752: LD_EXP 17
 756: PPUSH
 757: LD_EXP 17
 761: PUSH
 762: LD_INT 1
 764: PLUS
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: CALL_OW 426
 775: PUSH
 776: LD_INT 1
 778: PLUS
 779: PPUSH
 780: CALL_OW 2
 784: ST_TO_ADDR
 785: GO 744
 787: POP
 788: POP
// end else
 789: GO 973
// begin your_side := 1 ;
 791: LD_ADDR_OWVAR 2
 795: PUSH
 796: LD_INT 1
 798: ST_TO_ADDR
// multi_gametype := 1 ;
 799: LD_ADDR_EXP 6
 803: PUSH
 804: LD_INT 1
 806: ST_TO_ADDR
// multi_sides := [ 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 807: LD_ADDR_EXP 7
 811: PUSH
 812: LD_INT 2
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 0
 820: PUSH
 821: LD_INT 0
 823: PUSH
 824: LD_INT 0
 826: PUSH
 827: LD_INT 0
 829: PUSH
 830: LD_INT 0
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: ST_TO_ADDR
// multi_side_teams := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 846: LD_ADDR_EXP 8
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 0
 859: PUSH
 860: LD_INT 0
 862: PUSH
 863: LD_INT 0
 865: PUSH
 866: LD_INT 0
 868: PUSH
 869: LD_INT 0
 871: PUSH
 872: LD_INT 0
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: ST_TO_ADDR
// multi_nations := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 885: LD_ADDR_EXP 9
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: LD_INT 0
 907: PUSH
 908: LD_INT 0
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: ST_TO_ADDR
// multi_teams := [ [ 1 , 2 ] ] ;
 924: LD_ADDR_EXP 10
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 2
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: PUSH
 939: EMPTY
 940: LIST
 941: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 942: LD_ADDR_EXP 17
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 2
 952: PUSH
 953: LD_INT 1
 955: PUSH
 956: LD_INT 3
 958: PUSH
 959: LD_INT 1
 961: PUSH
 962: LD_INT 1
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 973: LD_ADDR_EXP 11
 977: PUSH
 978: LD_INT 0
 980: PUSH
 981: LD_INT 0
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 0
 998: PUSH
 999: LD_INT 0
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1012: LD_ADDR_EXP 14
1016: PUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 0
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 0
1031: PUSH
1032: LD_INT 0
1034: PUSH
1035: LD_INT 0
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1051: LD_ADDR_EXP 25
1055: PUSH
1056: LD_INT 0
1058: PUSH
1059: LD_INT 0
1061: PUSH
1062: LD_INT 0
1064: PUSH
1065: LD_INT 0
1067: PUSH
1068: LD_INT 0
1070: PUSH
1071: LD_INT 0
1073: PUSH
1074: LD_INT 0
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: ST_TO_ADDR
// multi_teamgame := true ;
1090: LD_ADDR_EXP 15
1094: PUSH
1095: LD_INT 1
1097: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1098: LD_ADDR_EXP 13
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: EMPTY
1107: LIST
1108: ST_TO_ADDR
// multi_custom_commanders := true ;
1109: LD_ADDR_EXP 16
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// multi_commanders := [ ] ;
1117: LD_ADDR_EXP 24
1121: PUSH
1122: EMPTY
1123: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1124: LD_ADDR_EXP 27
1128: PUSH
1129: EMPTY
1130: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1131: LD_ADDR_EXP 28
1135: PUSH
1136: LD_INT 0
1138: ST_TO_ADDR
// multi_players_amount := 0 ;
1139: LD_ADDR_EXP 26
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1147: LD_ADDR_EXP 12
1151: PUSH
1152: LD_INT 9
1154: PUSH
1155: LD_INT 8
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 26
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 29
1174: PUSH
1175: LD_INT 28
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: ST_TO_ADDR
// for i = 1 to 8 do
1187: LD_ADDR_VAR 0 2
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_INT 8
1199: PUSH
1200: FOR_TO
1201: IFFALSE 1530
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1203: LD_VAR 0 2
1207: PPUSH
1208: CALL_OW 530
1212: IFFALSE 1370
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1214: LD_ADDR_EXP 11
1218: PUSH
1219: LD_EXP 11
1223: PPUSH
1224: LD_VAR 0 2
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: CALL_OW 1
1236: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1237: LD_ADDR_EXP 9
1241: PUSH
1242: LD_EXP 9
1246: PPUSH
1247: LD_VAR 0 2
1251: PPUSH
1252: LD_INT 0
1254: PPUSH
1255: CALL_OW 1
1259: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1260: LD_ADDR_EXP 7
1264: PUSH
1265: LD_EXP 7
1269: PPUSH
1270: LD_VAR 0 2
1274: PPUSH
1275: LD_INT 0
1277: PPUSH
1278: CALL_OW 1
1282: ST_TO_ADDR
// for j = 1 to multi_teams do
1283: LD_ADDR_VAR 0 3
1287: PUSH
1288: DOUBLE
1289: LD_INT 1
1291: DEC
1292: ST_TO_ADDR
1293: LD_EXP 10
1297: PUSH
1298: FOR_TO
1299: IFFALSE 1368
// begin if i in multi_teams [ j ] then
1301: LD_VAR 0 2
1305: PUSH
1306: LD_EXP 10
1310: PUSH
1311: LD_VAR 0 3
1315: ARRAY
1316: IN
1317: IFFALSE 1366
// begin tmp := multi_teams [ j ] diff i ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: LD_EXP 10
1328: PUSH
1329: LD_VAR 0 3
1333: ARRAY
1334: PUSH
1335: LD_VAR 0 2
1339: DIFF
1340: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1341: LD_ADDR_EXP 10
1345: PUSH
1346: LD_EXP 10
1350: PPUSH
1351: LD_VAR 0 3
1355: PPUSH
1356: LD_VAR 0 5
1360: PPUSH
1361: CALL_OW 1
1365: ST_TO_ADDR
// end ; end ;
1366: GO 1298
1368: POP
1369: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1370: LD_EXP 9
1374: PUSH
1375: LD_VAR 0 2
1379: ARRAY
1380: PUSH
1381: LD_EXP 9
1385: PUSH
1386: LD_VAR 0 2
1390: ARRAY
1391: PUSH
1392: LD_EXP 13
1396: IN
1397: NOT
1398: AND
1399: IFFALSE 1440
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1401: LD_ADDR_EXP 9
1405: PUSH
1406: LD_EXP 9
1410: PPUSH
1411: LD_VAR 0 2
1415: PPUSH
1416: LD_EXP 13
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_EXP 13
1428: PPUSH
1429: CALL_OW 12
1433: ARRAY
1434: PPUSH
1435: CALL_OW 1
1439: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1440: LD_EXP 9
1444: PUSH
1445: LD_VAR 0 2
1449: ARRAY
1450: NOT
1451: PUSH
1452: LD_EXP 7
1456: PUSH
1457: LD_VAR 0 2
1461: ARRAY
1462: NOT
1463: AND
1464: PUSH
1465: LD_EXP 11
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: AND
1477: IFFALSE 1502
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1479: LD_ADDR_EXP 14
1483: PUSH
1484: LD_EXP 14
1488: PPUSH
1489: LD_VAR 0 2
1493: PPUSH
1494: LD_INT 1
1496: PPUSH
1497: CALL_OW 1
1501: ST_TO_ADDR
// if multi_sides [ i ] then
1502: LD_EXP 7
1506: PUSH
1507: LD_VAR 0 2
1511: ARRAY
1512: IFFALSE 1528
// multi_players_amount := multi_players_amount + 1 ;
1514: LD_ADDR_EXP 26
1518: PUSH
1519: LD_EXP 26
1523: PUSH
1524: LD_INT 1
1526: PLUS
1527: ST_TO_ADDR
// end ;
1528: GO 1200
1530: POP
1531: POP
// for i in multi_teams do
1532: LD_ADDR_VAR 0 2
1536: PUSH
1537: LD_EXP 10
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1651
// begin for j = 2 to i do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: DOUBLE
1551: LD_INT 2
1553: DEC
1554: ST_TO_ADDR
1555: LD_VAR 0 2
1559: PUSH
1560: FOR_TO
1561: IFFALSE 1647
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1563: LD_VAR 0 2
1567: PUSH
1568: LD_VAR 0 3
1572: ARRAY
1573: PPUSH
1574: LD_VAR 0 2
1578: PUSH
1579: LD_INT 1
1581: ARRAY
1582: PPUSH
1583: CALL_OW 343
// for x = 1 to j - 1 do
1587: LD_ADDR_VAR 0 4
1591: PUSH
1592: DOUBLE
1593: LD_INT 1
1595: DEC
1596: ST_TO_ADDR
1597: LD_VAR 0 3
1601: PUSH
1602: LD_INT 1
1604: MINUS
1605: PUSH
1606: FOR_TO
1607: IFFALSE 1643
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1609: LD_VAR 0 2
1613: PUSH
1614: LD_VAR 0 3
1618: ARRAY
1619: PPUSH
1620: LD_VAR 0 2
1624: PUSH
1625: LD_VAR 0 4
1629: ARRAY
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: CALL_OW 80
1641: GO 1606
1643: POP
1644: POP
// end ;
1645: GO 1560
1647: POP
1648: POP
// end ;
1649: GO 1542
1651: POP
1652: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1653: LD_ADDR_OWVAR 67
1657: PUSH
1658: LD_INT 1
1660: PUSH
1661: LD_INT 2
1663: PUSH
1664: LD_INT 3
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_EXP 17
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: ARRAY
1681: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1682: LD_ADDR_EXP 19
1686: PUSH
1687: LD_INT 9
1689: PUSH
1690: LD_INT 12
1692: PUSH
1693: LD_INT 15
1695: PUSH
1696: LD_INT 18
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: PUSH
1705: LD_EXP 17
1709: PUSH
1710: LD_INT 2
1712: ARRAY
1713: ARRAY
1714: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1715: LD_ADDR_EXP 20
1719: PUSH
1720: LD_INT 5
1722: PUSH
1723: LD_INT 7
1725: PUSH
1726: LD_INT 9
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: PUSH
1734: LD_EXP 17
1738: PUSH
1739: LD_INT 3
1741: ARRAY
1742: ARRAY
1743: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1744: LD_ADDR_EXP 21
1748: PUSH
1749: LD_INT 6000
1751: PUSH
1752: LD_INT 1575
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 8000
1761: PUSH
1762: LD_INT 1260
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: PUSH
1769: LD_INT 10000
1771: PUSH
1772: LD_INT 770
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PUSH
1779: LD_INT 15000
1781: PUSH
1782: LD_INT 770
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: PUSH
1795: LD_EXP 17
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: ARRAY
1804: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1805: LD_ADDR_EXP 22
1809: PUSH
1810: LD_INT 6
1812: PUSH
1813: LD_INT 8
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: LIST
1823: PUSH
1824: LD_EXP 17
1828: PUSH
1829: LD_INT 5
1831: ARRAY
1832: ARRAY
1833: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1834: LD_ADDR_EXP 23
1838: PUSH
1839: LD_INT 0
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: LIST
1852: PUSH
1853: LD_EXP 17
1857: PUSH
1858: LD_INT 6
1860: ARRAY
1861: ARRAY
1862: ST_TO_ADDR
// end ;
1863: LD_VAR 0 1
1867: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1868: LD_INT 0
1870: PPUSH
1871: PPUSH
// if not multi_sides [ 2 ] then
1872: LD_EXP 7
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: NOT
1881: IFFALSE 1895
// begin result := preferSide ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: LD_VAR 0 1
1892: ST_TO_ADDR
// exit ;
1893: GO 1942
// end ; for i := 1 to 8 do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_INT 8
1907: PUSH
1908: FOR_TO
1909: IFFALSE 1940
// if not multi_sides [ i ] then
1911: LD_EXP 7
1915: PUSH
1916: LD_VAR 0 3
1920: ARRAY
1921: NOT
1922: IFFALSE 1938
// begin result := i ;
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_VAR 0 3
1933: ST_TO_ADDR
// exit ;
1934: POP
1935: POP
1936: GO 1942
// end ;
1938: GO 1908
1940: POP
1941: POP
// end ;
1942: LD_VAR 0 2
1946: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1947: LD_INT 0
1949: PPUSH
// uc_side := side ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_VAR 0 1
1959: ST_TO_ADDR
// uc_nation := 1 ;
1960: LD_ADDR_OWVAR 21
1964: PUSH
1965: LD_INT 1
1967: ST_TO_ADDR
// hc_importance := 100 ;
1968: LD_ADDR_OWVAR 32
1972: PUSH
1973: LD_INT 100
1975: ST_TO_ADDR
// hc_class := 1 ;
1976: LD_ADDR_OWVAR 28
1980: PUSH
1981: LD_INT 1
1983: ST_TO_ADDR
// if num = 1 then
1984: LD_VAR 0 2
1988: PUSH
1989: LD_INT 1
1991: EQUAL
1992: IFFALSE 2074
// begin hc_gallery := us ;
1994: LD_ADDR_OWVAR 33
1998: PUSH
1999: LD_STRING us
2001: ST_TO_ADDR
// hc_face_number := 5 ;
2002: LD_ADDR_OWVAR 34
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// hc_name := John Macmilan ;
2010: LD_ADDR_OWVAR 26
2014: PUSH
2015: LD_STRING John Macmilan
2017: ST_TO_ADDR
// hc_sex := sex_male ;
2018: LD_ADDR_OWVAR 27
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2026: LD_ADDR_OWVAR 31
2030: PUSH
2031: LD_INT 7
2033: PUSH
2034: LD_INT 2
2036: PUSH
2037: LD_INT 4
2039: PUSH
2040: LD_INT 4
2042: PUSH
2043: EMPTY
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2049: LD_ADDR_OWVAR 29
2053: PUSH
2054: LD_INT 11
2056: PUSH
2057: LD_INT 10
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: ST_TO_ADDR
// result := CreateHuman ;
2064: LD_ADDR_VAR 0 3
2068: PUSH
2069: CALL_OW 44
2073: ST_TO_ADDR
// end ; if num = 2 then
2074: LD_VAR 0 2
2078: PUSH
2079: LD_INT 2
2081: EQUAL
2082: IFFALSE 2164
// begin hc_gallery := us ;
2084: LD_ADDR_OWVAR 33
2088: PUSH
2089: LD_STRING us
2091: ST_TO_ADDR
// hc_face_number := 2 ;
2092: LD_ADDR_OWVAR 34
2096: PUSH
2097: LD_INT 2
2099: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2100: LD_ADDR_OWVAR 26
2104: PUSH
2105: LD_STRING Lucy Donaldson
2107: ST_TO_ADDR
// hc_sex := sex_female ;
2108: LD_ADDR_OWVAR 27
2112: PUSH
2113: LD_INT 2
2115: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2116: LD_ADDR_OWVAR 31
2120: PUSH
2121: LD_INT 6
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 4
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2139: LD_ADDR_OWVAR 29
2143: PUSH
2144: LD_INT 9
2146: PUSH
2147: LD_INT 12
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: ST_TO_ADDR
// result := CreateHuman ;
2154: LD_ADDR_VAR 0 3
2158: PUSH
2159: CALL_OW 44
2163: ST_TO_ADDR
// end ; if num = 3 then
2164: LD_VAR 0 2
2168: PUSH
2169: LD_INT 3
2171: EQUAL
2172: IFFALSE 2254
// begin hc_gallery := us ;
2174: LD_ADDR_OWVAR 33
2178: PUSH
2179: LD_STRING us
2181: ST_TO_ADDR
// hc_face_number := 7 ;
2182: LD_ADDR_OWVAR 34
2186: PUSH
2187: LD_INT 7
2189: ST_TO_ADDR
// hc_name := Arthur Powell ;
2190: LD_ADDR_OWVAR 26
2194: PUSH
2195: LD_STRING Arthur Powell
2197: ST_TO_ADDR
// hc_sex := sex_male ;
2198: LD_ADDR_OWVAR 27
2202: PUSH
2203: LD_INT 1
2205: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2206: LD_ADDR_OWVAR 31
2210: PUSH
2211: LD_INT 8
2213: PUSH
2214: LD_INT 2
2216: PUSH
2217: LD_INT 5
2219: PUSH
2220: LD_INT 2
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2229: LD_ADDR_OWVAR 29
2233: PUSH
2234: LD_INT 10
2236: PUSH
2237: LD_INT 11
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: ST_TO_ADDR
// result := CreateHuman ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: CALL_OW 44
2253: ST_TO_ADDR
// end ; end ;
2254: LD_VAR 0 3
2258: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
2266: PPUSH
2267: PPUSH
2268: PPUSH
2269: PPUSH
// for i = 1 to 8 do
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_INT 8
2282: PUSH
2283: FOR_TO
2284: IFFALSE 3174
// begin if not multi_sides [ i ] then
2286: LD_EXP 7
2290: PUSH
2291: LD_VAR 0 2
2295: ARRAY
2296: NOT
2297: IFFALSE 2301
// continue ;
2299: GO 2283
// if multi_custom_commanders then
2301: LD_EXP 16
2305: IFFALSE 2397
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 2
2316: PPUSH
2317: LD_EXP 7
2321: PUSH
2322: LD_VAR 0 2
2326: ARRAY
2327: PPUSH
2328: CALL 1947 0 2
2332: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2333: LD_ADDR_EXP 24
2337: PUSH
2338: LD_EXP 24
2342: PPUSH
2343: LD_EXP 24
2347: PUSH
2348: LD_INT 1
2350: PLUS
2351: PPUSH
2352: LD_VAR 0 5
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_EXP 12
2371: PUSH
2372: LD_EXP 7
2376: PUSH
2377: LD_VAR 0 2
2381: ARRAY
2382: ARRAY
2383: PUSH
2384: LD_INT 1
2386: ARRAY
2387: PPUSH
2388: LD_INT 0
2390: PPUSH
2391: CALL_OW 49
// end else
2395: GO 2608
// begin uc_side := i ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_VAR 0 2
2406: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2407: LD_ADDR_OWVAR 21
2411: PUSH
2412: LD_EXP 9
2416: PUSH
2417: LD_VAR 0 2
2421: ARRAY
2422: ST_TO_ADDR
// hc_importance := 100 ;
2423: LD_ADDR_OWVAR 32
2427: PUSH
2428: LD_INT 100
2430: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2431: LD_INT 0
2433: PPUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_EXP 20
2441: PPUSH
2442: CALL_OW 380
// if multiplayer then
2446: LD_OWVAR 4
2450: IFFALSE 2508
// begin hc_name := mp_sides_players_names [ i ] ;
2452: LD_ADDR_OWVAR 26
2456: PUSH
2457: LD_OWVAR 19
2461: PUSH
2462: LD_VAR 0 2
2466: ARRAY
2467: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING MULTIAVATARS
2475: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2476: LD_ADDR_OWVAR 34
2480: PUSH
2481: LD_VAR 0 2
2485: PPUSH
2486: CALL_OW 525
2490: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2491: LD_ADDR_OWVAR 27
2495: PUSH
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 526
2505: ST_TO_ADDR
// end else
2506: GO 2540
// begin hc_gallery :=  ;
2508: LD_ADDR_OWVAR 33
2512: PUSH
2513: LD_STRING 
2515: ST_TO_ADDR
// hc_name :=  ;
2516: LD_ADDR_OWVAR 26
2520: PUSH
2521: LD_STRING 
2523: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: ST_TO_ADDR
// end ; un := CreateHuman ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: CALL_OW 44
2549: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2550: LD_VAR 0 5
2554: PPUSH
2555: LD_EXP 12
2559: PUSH
2560: LD_EXP 7
2564: PUSH
2565: LD_VAR 0 2
2569: ARRAY
2570: ARRAY
2571: PUSH
2572: LD_INT 1
2574: ARRAY
2575: PPUSH
2576: LD_INT 0
2578: PPUSH
2579: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2583: LD_ADDR_EXP 24
2587: PUSH
2588: LD_EXP 24
2592: PPUSH
2593: LD_VAR 0 2
2597: PPUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: CALL_OW 1
2607: ST_TO_ADDR
// end ; InitHc ;
2608: CALL_OW 19
// InitUc ;
2612: CALL_OW 18
// uc_side := i ;
2616: LD_ADDR_OWVAR 20
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_EXP 9
2635: PUSH
2636: LD_VAR 0 2
2640: ARRAY
2641: ST_TO_ADDR
// hc_gallery :=  ;
2642: LD_ADDR_OWVAR 33
2646: PUSH
2647: LD_STRING 
2649: ST_TO_ADDR
// hc_name :=  ;
2650: LD_ADDR_OWVAR 26
2654: PUSH
2655: LD_STRING 
2657: ST_TO_ADDR
// hc_importance := 0 ;
2658: LD_ADDR_OWVAR 32
2662: PUSH
2663: LD_INT 0
2665: ST_TO_ADDR
// cl := 1 ;
2666: LD_ADDR_VAR 0 4
2670: PUSH
2671: LD_INT 1
2673: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2674: LD_ADDR_VAR 0 3
2678: PUSH
2679: DOUBLE
2680: LD_INT 2
2682: DEC
2683: ST_TO_ADDR
2684: LD_EXP 19
2688: PUSH
2689: FOR_TO
2690: IFFALSE 3062
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2692: LD_VAR 0 3
2696: PUSH
2697: LD_INT 1
2699: MINUS
2700: PUSH
2701: LD_EXP 19
2705: PUSH
2706: LD_INT 1
2708: MINUS
2709: PUSH
2710: LD_INT 4
2712: DIVREAL
2713: MOD
2714: PUSH
2715: LD_INT 0
2717: EQUAL
2718: IFFALSE 2734
// cl := cl + 1 ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_VAR 0 4
2729: PUSH
2730: LD_INT 1
2732: PLUS
2733: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2734: LD_INT 0
2736: PPUSH
2737: LD_VAR 0 4
2741: PPUSH
2742: LD_EXP 20
2746: PPUSH
2747: CALL_OW 380
// un := CreateHuman ;
2751: LD_ADDR_VAR 0 5
2755: PUSH
2756: CALL_OW 44
2760: ST_TO_ADDR
// if j > copy then
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 8
2770: GREATER
2771: IFFALSE 2800
// copy := Replace ( copy , j , un ) else
2773: LD_ADDR_VAR 0 8
2777: PUSH
2778: LD_VAR 0 8
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_VAR 0 5
2792: PPUSH
2793: CALL_OW 1
2797: ST_TO_ADDR
2798: GO 2882
// begin CopySkills ( copy [ j ] , un ) ;
2800: LD_VAR 0 8
2804: PUSH
2805: LD_VAR 0 3
2809: ARRAY
2810: PPUSH
2811: LD_VAR 0 5
2815: PPUSH
2816: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2820: LD_VAR 0 5
2824: PPUSH
2825: LD_INT 2
2827: PPUSH
2828: LD_VAR 0 8
2832: PUSH
2833: LD_VAR 0 3
2837: ARRAY
2838: PPUSH
2839: LD_INT 2
2841: PPUSH
2842: CALL_OW 260
2846: PPUSH
2847: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2851: LD_VAR 0 5
2855: PPUSH
2856: LD_INT 1
2858: PPUSH
2859: LD_VAR 0 8
2863: PUSH
2864: LD_VAR 0 3
2868: ARRAY
2869: PPUSH
2870: LD_INT 1
2872: PPUSH
2873: CALL_OW 260
2877: PPUSH
2878: CALL_OW 239
// end ; if multi_pos_area then
2882: LD_EXP 12
2886: IFFALSE 3060
// begin if GetClass ( un ) = 3 then
2888: LD_VAR 0 5
2892: PPUSH
2893: CALL_OW 257
2897: PUSH
2898: LD_INT 3
2900: EQUAL
2901: IFFALSE 3027
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2903: LD_INT 3
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_VAR 0 3
2917: PUSH
2918: LD_INT 2
2920: MOD
2921: PUSH
2922: LD_INT 1
2924: PLUS
2925: ARRAY
2926: PPUSH
2927: LD_INT 2
2929: PPUSH
2930: LD_INT 1
2932: PPUSH
2933: LD_INT 5
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_VAR 0 3
2951: PUSH
2952: LD_INT 3
2954: MOD
2955: PUSH
2956: LD_INT 1
2958: PLUS
2959: ARRAY
2960: PPUSH
2961: LD_INT 100
2963: PPUSH
2964: CALL 14827 0 5
// veh := CreateVehicle ;
2968: LD_ADDR_VAR 0 6
2972: PUSH
2973: CALL_OW 45
2977: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2978: LD_VAR 0 6
2982: PPUSH
2983: LD_EXP 12
2987: PUSH
2988: LD_EXP 7
2992: PUSH
2993: LD_VAR 0 2
2997: ARRAY
2998: ARRAY
2999: PUSH
3000: LD_INT 2
3002: ARRAY
3003: PPUSH
3004: LD_INT 0
3006: PPUSH
3007: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3011: LD_VAR 0 5
3015: PPUSH
3016: LD_VAR 0 6
3020: PPUSH
3021: CALL_OW 52
// continue ;
3025: GO 2689
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3027: LD_VAR 0 5
3031: PPUSH
3032: LD_EXP 12
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_VAR 0 2
3046: ARRAY
3047: ARRAY
3048: PUSH
3049: LD_INT 1
3051: ARRAY
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: CALL_OW 49
// end ; end ;
3060: GO 2689
3062: POP
3063: POP
// for j = 1 to 3 do
3064: LD_ADDR_VAR 0 3
3068: PUSH
3069: DOUBLE
3070: LD_INT 1
3072: DEC
3073: ST_TO_ADDR
3074: LD_INT 3
3076: PUSH
3077: FOR_TO
3078: IFFALSE 3170
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3080: LD_INT 2
3082: PUSH
3083: LD_INT 3
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: PUSH
3090: LD_INT 1
3092: PPUSH
3093: LD_INT 2
3095: PPUSH
3096: CALL_OW 12
3100: ARRAY
3101: PPUSH
3102: LD_INT 2
3104: PPUSH
3105: LD_INT 3
3107: PPUSH
3108: LD_INT 11
3110: PUSH
3111: LD_INT 7
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: PUSH
3122: LD_VAR 0 3
3126: ARRAY
3127: PPUSH
3128: LD_INT 100
3130: PPUSH
3131: CALL 14827 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3135: CALL_OW 45
3139: PPUSH
3140: LD_EXP 12
3144: PUSH
3145: LD_EXP 7
3149: PUSH
3150: LD_VAR 0 2
3154: ARRAY
3155: ARRAY
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3077
3170: POP
3171: POP
// end ;
3172: GO 2283
3174: POP
3175: POP
// end ;
3176: LD_VAR 0 1
3180: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3181: LD_INT 0
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
3187: PPUSH
// if not multi_support then
3188: LD_EXP 23
3192: NOT
3193: IFFALSE 3197
// exit ;
3195: GO 3725
// result := [ ] ;
3197: LD_ADDR_VAR 0 1
3201: PUSH
3202: EMPTY
3203: ST_TO_ADDR
// for i = 1 to 8 do
3204: LD_ADDR_VAR 0 2
3208: PUSH
3209: DOUBLE
3210: LD_INT 1
3212: DEC
3213: ST_TO_ADDR
3214: LD_INT 8
3216: PUSH
3217: FOR_TO
3218: IFFALSE 3723
// begin if multi_sides [ i ] then
3220: LD_EXP 7
3224: PUSH
3225: LD_VAR 0 2
3229: ARRAY
3230: IFFALSE 3721
// begin tmp := [ ] ;
3232: LD_ADDR_VAR 0 5
3236: PUSH
3237: EMPTY
3238: ST_TO_ADDR
// if multi_support = 1 then
3239: LD_EXP 23
3243: PUSH
3244: LD_INT 1
3246: EQUAL
3247: IFFALSE 3415
// begin uc_side := i ;
3249: LD_ADDR_OWVAR 20
3253: PUSH
3254: LD_VAR 0 2
3258: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3259: LD_ADDR_OWVAR 21
3263: PUSH
3264: LD_EXP 9
3268: PUSH
3269: LD_VAR 0 2
3273: ARRAY
3274: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3275: LD_INT 3
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: LD_INT 11
3286: PPUSH
3287: LD_INT 40
3289: PPUSH
3290: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3294: LD_ADDR_VAR 0 5
3298: PUSH
3299: LD_VAR 0 5
3303: PUSH
3304: CALL_OW 45
3308: ADD
3309: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3310: LD_INT 2
3312: PPUSH
3313: LD_INT 1
3315: PPUSH
3316: LD_INT 3
3318: PPUSH
3319: LD_INT 5
3321: PPUSH
3322: LD_INT 40
3324: PPUSH
3325: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3329: LD_ADDR_VAR 0 5
3333: PUSH
3334: LD_VAR 0 5
3338: PUSH
3339: CALL_OW 45
3343: ADD
3344: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3345: LD_INT 2
3347: PPUSH
3348: LD_INT 3
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 4
3356: PPUSH
3357: LD_INT 40
3359: PPUSH
3360: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: CALL_OW 45
3378: ADD
3379: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3380: LD_INT 3
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: LD_INT 3
3388: PPUSH
3389: LD_INT 9
3391: PPUSH
3392: LD_INT 40
3394: PPUSH
3395: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3399: LD_ADDR_VAR 0 5
3403: PUSH
3404: LD_VAR 0 5
3408: PUSH
3409: CALL_OW 45
3413: ADD
3414: ST_TO_ADDR
// end ; if multi_support = 2 then
3415: LD_EXP 23
3419: PUSH
3420: LD_INT 2
3422: EQUAL
3423: IFFALSE 3696
// begin uc_side := i ;
3425: LD_ADDR_OWVAR 20
3429: PUSH
3430: LD_VAR 0 2
3434: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3435: LD_ADDR_OWVAR 21
3439: PUSH
3440: LD_EXP 9
3444: PUSH
3445: LD_VAR 0 2
3449: ARRAY
3450: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 11
3462: PPUSH
3463: LD_INT 40
3465: PPUSH
3466: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3470: LD_ADDR_VAR 0 5
3474: PUSH
3475: LD_VAR 0 5
3479: PUSH
3480: CALL_OW 45
3484: ADD
3485: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3486: LD_INT 3
3488: PPUSH
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 12
3497: PPUSH
3498: LD_INT 40
3500: PPUSH
3501: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3505: LD_ADDR_VAR 0 5
3509: PUSH
3510: LD_VAR 0 5
3514: PUSH
3515: CALL_OW 45
3519: ADD
3520: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3521: LD_INT 2
3523: PPUSH
3524: LD_INT 3
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 5
3532: PPUSH
3533: LD_INT 40
3535: PPUSH
3536: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3540: LD_ADDR_VAR 0 5
3544: PUSH
3545: LD_VAR 0 5
3549: PUSH
3550: CALL_OW 45
3554: ADD
3555: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3556: LD_INT 4
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: LD_INT 6
3567: PPUSH
3568: LD_INT 40
3570: PPUSH
3571: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3575: LD_ADDR_VAR 0 5
3579: PUSH
3580: LD_VAR 0 5
3584: PUSH
3585: CALL_OW 45
3589: ADD
3590: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3591: LD_INT 2
3593: PPUSH
3594: LD_INT 3
3596: PPUSH
3597: LD_INT 3
3599: PPUSH
3600: LD_INT 9
3602: PPUSH
3603: LD_INT 40
3605: PPUSH
3606: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3610: LD_ADDR_VAR 0 5
3614: PUSH
3615: LD_VAR 0 5
3619: PUSH
3620: CALL_OW 45
3624: ADD
3625: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 3
3631: PPUSH
3632: LD_INT 3
3634: PPUSH
3635: LD_INT 9
3637: PPUSH
3638: LD_INT 40
3640: PPUSH
3641: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_VAR 0 5
3654: PUSH
3655: CALL_OW 45
3659: ADD
3660: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3661: LD_INT 4
3663: PPUSH
3664: LD_INT 1
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 6
3672: PPUSH
3673: LD_INT 40
3675: PPUSH
3676: CALL 14827 0 5
// tmp := tmp ^ CreateVehicle ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: CALL_OW 45
3694: ADD
3695: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3696: LD_ADDR_VAR 0 1
3700: PUSH
3701: LD_VAR 0 1
3705: PPUSH
3706: LD_VAR 0 2
3710: PPUSH
3711: LD_VAR 0 5
3715: PPUSH
3716: CALL_OW 2
3720: ST_TO_ADDR
// end ; end ;
3721: GO 3217
3723: POP
3724: POP
// end ;
3725: LD_VAR 0 1
3729: RET
// export function Multiplayer_Start ( ) ; begin
3730: LD_INT 0
3732: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3733: CALL 2259 0 0
// Multiplayer_InitPointSystem ( ) ;
3737: CALL 4646 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3741: LD_INT 20
3743: PPUSH
3744: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3748: LD_INT 150
3750: PPUSH
3751: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3755: LD_INT 5
3757: PPUSH
3758: CALL 4822 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3762: LD_INT 40
3764: NEG
3765: PPUSH
3766: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3770: LD_INT 200
3772: PPUSH
3773: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3777: LD_INT 2
3779: PPUSH
3780: CALL 4822 0 1
// Multiplayer_SpawnArtifact ;
3784: CALL 5262 0 0
// if multi_support then
3788: LD_EXP 23
3792: IFFALSE 3804
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3794: LD_ADDR_EXP 27
3798: PUSH
3799: CALL 3181 0 0
3803: ST_TO_ADDR
// if multi_sides [ your_side ] then
3804: LD_EXP 7
3808: PUSH
3809: LD_OWVAR 2
3813: ARRAY
3814: IFFALSE 3841
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3816: LD_INT 22
3818: PUSH
3819: LD_OWVAR 2
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: CALL_OW 87
// end ;
3841: LD_VAR 0 1
3845: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3846: LD_INT 0
3848: PPUSH
3849: PPUSH
3850: PPUSH
3851: PPUSH
3852: PPUSH
// reinforcements_arrive := 0 ;
3853: LD_ADDR_VAR 0 5
3857: PUSH
3858: LD_INT 0
3860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3861: LD_INT 35
3863: PPUSH
3864: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3868: LD_OWVAR 1
3872: PUSH
3873: LD_INT 21000
3875: GREATER
3876: PUSH
3877: LD_EXP 28
3881: NOT
3882: AND
3883: PUSH
3884: LD_EXP 23
3888: PUSH
3889: LD_INT 1
3891: EQUAL
3892: AND
3893: IFFALSE 4088
// begin multi_reinforcements_spawned := 1 ;
3895: LD_ADDR_EXP 28
3899: PUSH
3900: LD_INT 1
3902: ST_TO_ADDR
// for i = 1 to 8 do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_INT 8
3915: PUSH
3916: FOR_TO
3917: IFFALSE 4076
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3919: LD_EXP 7
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_EXP 25
3934: PUSH
3935: LD_VAR 0 2
3939: ARRAY
3940: NOT
3941: AND
3942: PUSH
3943: LD_EXP 27
3947: PUSH
3948: LD_VAR 0 2
3952: ARRAY
3953: AND
3954: IFFALSE 4074
// begin tmp := multi_reinforcements [ i ] ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_EXP 27
3965: PUSH
3966: LD_VAR 0 2
3970: ARRAY
3971: ST_TO_ADDR
// for j = 1 to 4 do
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_INT 4
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4047
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3988: LD_VAR 0 4
3992: PUSH
3993: LD_VAR 0 3
3997: ARRAY
3998: PPUSH
3999: LD_EXP 12
4003: PUSH
4004: LD_EXP 7
4008: PUSH
4009: LD_VAR 0 2
4013: ARRAY
4014: ARRAY
4015: PUSH
4016: LD_INT 2
4018: ARRAY
4019: PPUSH
4020: LD_INT 0
4022: PPUSH
4023: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_VAR 0 4
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: CALL_OW 3
4044: ST_TO_ADDR
// end ;
4045: GO 3985
4047: POP
4048: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4049: LD_ADDR_EXP 27
4053: PUSH
4054: LD_EXP 27
4058: PPUSH
4059: LD_VAR 0 2
4063: PPUSH
4064: LD_VAR 0 4
4068: PPUSH
4069: CALL_OW 1
4073: ST_TO_ADDR
// end ; end ;
4074: GO 3916
4076: POP
4077: POP
// reinforcements_arrive := tick ;
4078: LD_ADDR_VAR 0 5
4082: PUSH
4083: LD_OWVAR 1
4087: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4088: LD_VAR 0 5
4092: PUSH
4093: LD_INT 21000
4095: PLUS
4096: PUSH
4097: LD_OWVAR 1
4101: LESS
4102: PUSH
4103: LD_EXP 28
4107: PUSH
4108: LD_INT 1
4110: EQUAL
4111: AND
4112: PUSH
4113: LD_EXP 23
4117: PUSH
4118: LD_INT 2
4120: EQUAL
4121: AND
4122: IFFALSE 4307
// begin multi_reinforcements_spawned := 2 ;
4124: LD_ADDR_EXP 28
4128: PUSH
4129: LD_INT 2
4131: ST_TO_ADDR
// for i = 1 to 8 do
4132: LD_ADDR_VAR 0 2
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 8
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4305
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4148: LD_EXP 7
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PUSH
4159: LD_EXP 25
4163: PUSH
4164: LD_VAR 0 2
4168: ARRAY
4169: NOT
4170: AND
4171: PUSH
4172: LD_EXP 27
4176: PUSH
4177: LD_VAR 0 2
4181: ARRAY
4182: AND
4183: IFFALSE 4303
// begin tmp := multi_reinforcements [ i ] ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_EXP 27
4194: PUSH
4195: LD_VAR 0 2
4199: ARRAY
4200: ST_TO_ADDR
// for j = 1 to 3 do
4201: LD_ADDR_VAR 0 3
4205: PUSH
4206: DOUBLE
4207: LD_INT 1
4209: DEC
4210: ST_TO_ADDR
4211: LD_INT 3
4213: PUSH
4214: FOR_TO
4215: IFFALSE 4276
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4217: LD_VAR 0 4
4221: PUSH
4222: LD_VAR 0 3
4226: ARRAY
4227: PPUSH
4228: LD_EXP 12
4232: PUSH
4233: LD_EXP 7
4237: PUSH
4238: LD_VAR 0 2
4242: ARRAY
4243: ARRAY
4244: PUSH
4245: LD_INT 2
4247: ARRAY
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4256: LD_ADDR_VAR 0 4
4260: PUSH
4261: LD_VAR 0 4
4265: PPUSH
4266: LD_INT 1
4268: PPUSH
4269: CALL_OW 3
4273: ST_TO_ADDR
// end ;
4274: GO 4214
4276: POP
4277: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4278: LD_ADDR_EXP 27
4282: PUSH
4283: LD_EXP 27
4287: PPUSH
4288: LD_VAR 0 2
4292: PPUSH
4293: LD_VAR 0 4
4297: PPUSH
4298: CALL_OW 1
4302: ST_TO_ADDR
// end ; end ;
4303: GO 4145
4305: POP
4306: POP
// end ; if not multi_custom_commanders then
4307: LD_EXP 16
4311: NOT
4312: IFFALSE 4425
// begin for i = 1 to 8 do
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: DOUBLE
4320: LD_INT 1
4322: DEC
4323: ST_TO_ADDR
4324: LD_INT 8
4326: PUSH
4327: FOR_TO
4328: IFFALSE 4399
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4330: LD_INT 22
4332: PUSH
4333: LD_VAR 0 2
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 69
4346: PUSH
4347: LD_INT 0
4349: EQUAL
4350: PUSH
4351: LD_EXP 25
4355: PUSH
4356: LD_VAR 0 2
4360: ARRAY
4361: NOT
4362: AND
4363: IFFALSE 4397
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4365: LD_ADDR_EXP 25
4369: PUSH
4370: LD_EXP 25
4374: PPUSH
4375: LD_VAR 0 2
4379: PPUSH
4380: LD_INT 1
4382: PPUSH
4383: CALL_OW 1
4387: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL 4892 0 1
// end ; end ;
4397: GO 4327
4399: POP
4400: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4401: LD_EXP 25
4405: PPUSH
4406: CALL 11914 0 1
4410: PUSH
4411: LD_EXP 7
4415: PPUSH
4416: CALL 11914 0 1
4420: EQUAL
4421: IFFALSE 4425
// break ;
4423: GO 4460
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4425: LD_INT 22
4427: PUSH
4428: LD_EXP 3
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 69
4441: PUSH
4442: LD_INT 0
4444: EQUAL
4445: PUSH
4446: LD_EXP 2
4450: AND
4451: PUSH
4452: LD_EXP 24
4456: NOT
4457: OR
4458: IFFALSE 3861
// game := false ;
4460: LD_ADDR_EXP 2
4464: PUSH
4465: LD_INT 0
4467: ST_TO_ADDR
// for i = 1 to 8 do
4468: LD_ADDR_VAR 0 2
4472: PUSH
4473: DOUBLE
4474: LD_INT 1
4476: DEC
4477: ST_TO_ADDR
4478: LD_INT 8
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4518
// begin if multi_sides [ i ] then
4484: LD_EXP 7
4488: PUSH
4489: LD_VAR 0 2
4493: ARRAY
4494: IFFALSE 4516
// SetMultiScore ( i , multi_points [ i ] ) ;
4496: LD_VAR 0 2
4500: PPUSH
4501: LD_EXP 29
4505: PUSH
4506: LD_VAR 0 2
4510: ARRAY
4511: PPUSH
4512: CALL_OW 506
// end ;
4516: GO 4481
4518: POP
4519: POP
// if multi_loosers [ your_side ] then
4520: LD_EXP 25
4524: PUSH
4525: LD_OWVAR 2
4529: ARRAY
4530: IFFALSE 4538
// YouLostInMultiplayer else
4532: CALL_OW 107
4536: GO 4542
// YouWinInMultiplayer ;
4538: CALL_OW 106
// end ;
4542: LD_VAR 0 1
4546: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
// result := [ #tick , tick ] ;
4551: LD_ADDR_VAR 0 1
4555: PUSH
4556: LD_STRING #tick
4558: PUSH
4559: LD_OWVAR 1
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: ST_TO_ADDR
// for i = 1 to 8 do
4568: LD_ADDR_VAR 0 2
4572: PUSH
4573: DOUBLE
4574: LD_INT 1
4576: DEC
4577: ST_TO_ADDR
4578: LD_INT 8
4580: PUSH
4581: FOR_TO
4582: IFFALSE 4639
// begin if multi_sides [ i ] then
4584: LD_EXP 7
4588: PUSH
4589: LD_VAR 0 2
4593: ARRAY
4594: IFFALSE 4637
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4596: LD_ADDR_VAR 0 1
4600: PUSH
4601: LD_VAR 0 1
4605: PUSH
4606: LD_STRING #coop-points
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: LD_VAR 0 2
4618: PUSH
4619: LD_EXP 29
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: ADD
4636: ST_TO_ADDR
// end ; end ;
4637: GO 4581
4639: POP
4640: POP
// end ;
4641: LD_VAR 0 1
4645: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4646: LD_INT 0
4648: PPUSH
4649: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4650: LD_ADDR_EXP 29
4654: PUSH
4655: LD_INT 0
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 0
4666: PUSH
4667: LD_INT 0
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4689: LD_ADDR_EXP 30
4693: PUSH
4694: EMPTY
4695: ST_TO_ADDR
// end ;
4696: LD_VAR 0 1
4700: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4701: LD_INT 0
4703: PPUSH
// if not multi_points or not side or side > 8 then
4704: LD_EXP 29
4708: NOT
4709: PUSH
4710: LD_VAR 0 1
4714: NOT
4715: OR
4716: PUSH
4717: LD_VAR 0 1
4721: PUSH
4722: LD_INT 8
4724: GREATER
4725: OR
4726: IFFALSE 4730
// exit ;
4728: GO 4767
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4730: LD_ADDR_EXP 29
4734: PUSH
4735: LD_EXP 29
4739: PPUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: LD_EXP 29
4749: PUSH
4750: LD_VAR 0 1
4754: ARRAY
4755: PUSH
4756: LD_VAR 0 2
4760: PLUS
4761: PPUSH
4762: CALL_OW 1
4766: ST_TO_ADDR
// end ;
4767: LD_VAR 0 3
4771: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4772: LD_INT 0
4774: PPUSH
// if not multi_points or not side or side > 8 then
4775: LD_EXP 29
4779: NOT
4780: PUSH
4781: LD_VAR 0 1
4785: NOT
4786: OR
4787: PUSH
4788: LD_VAR 0 1
4792: PUSH
4793: LD_INT 8
4795: GREATER
4796: OR
4797: IFFALSE 4801
// exit ;
4799: GO 4817
// result := multi_points [ side ] ;
4801: LD_ADDR_VAR 0 2
4805: PUSH
4806: LD_EXP 29
4810: PUSH
4811: LD_VAR 0 1
4815: ARRAY
4816: ST_TO_ADDR
// end ;
4817: LD_VAR 0 2
4821: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4822: LD_INT 0
4824: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4825: LD_ADDR_EXP 30
4829: PUSH
4830: LD_EXP 30
4834: PPUSH
4835: LD_EXP 30
4839: PUSH
4840: LD_INT 1
4842: PLUS
4843: PPUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 2
4853: ST_TO_ADDR
// end ;
4854: LD_VAR 0 2
4858: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4859: LD_INT 0
4861: PPUSH
// if not id then
4862: LD_VAR 0 1
4866: NOT
4867: IFFALSE 4871
// exit ;
4869: GO 4887
// result := multi_points_conditions [ id ] ;
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_EXP 30
4880: PUSH
4881: LD_VAR 0 1
4885: ARRAY
4886: ST_TO_ADDR
// end ;
4887: LD_VAR 0 2
4891: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
4897: PPUSH
4898: PPUSH
// players := [ ] ;
4899: LD_ADDR_VAR 0 3
4903: PUSH
4904: EMPTY
4905: ST_TO_ADDR
// for i = 1 to 8 do
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: DOUBLE
4912: LD_INT 1
4914: DEC
4915: ST_TO_ADDR
4916: LD_INT 8
4918: PUSH
4919: FOR_TO
4920: IFFALSE 4979
// begin if i = side then
4922: LD_VAR 0 4
4926: PUSH
4927: LD_VAR 0 1
4931: EQUAL
4932: IFFALSE 4936
// continue ;
4934: GO 4919
// if multi_sides [ i ] and not multi_loosers [ i ] then
4936: LD_EXP 7
4940: PUSH
4941: LD_VAR 0 4
4945: ARRAY
4946: PUSH
4947: LD_EXP 25
4951: PUSH
4952: LD_VAR 0 4
4956: ARRAY
4957: NOT
4958: AND
4959: IFFALSE 4977
// players := players ^ i ;
4961: LD_ADDR_VAR 0 3
4965: PUSH
4966: LD_VAR 0 3
4970: PUSH
4971: LD_VAR 0 4
4975: ADD
4976: ST_TO_ADDR
// end ;
4977: GO 4919
4979: POP
4980: POP
// if not players then
4981: LD_VAR 0 3
4985: NOT
4986: IFFALSE 4990
// exit ;
4988: GO 5257
// if players = 1 then
4990: LD_VAR 0 3
4994: PUSH
4995: LD_INT 1
4997: EQUAL
4998: IFFALSE 5059
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5000: LD_ADDR_VAR 0 4
5004: PUSH
5005: LD_INT 22
5007: PUSH
5008: LD_VAR 0 1
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 51
5019: PUSH
5020: EMPTY
5021: LIST
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: CALL_OW 69
5031: PUSH
5032: FOR_IN
5033: IFFALSE 5055
// SetSide ( i , players [ 1 ] ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 3
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PPUSH
5049: CALL_OW 235
5053: GO 5032
5055: POP
5056: POP
// end else
5057: GO 5257
// begin j := 1 ;
5059: LD_ADDR_VAR 0 5
5063: PUSH
5064: LD_INT 1
5066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5067: LD_ADDR_VAR 0 4
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_VAR 0 1
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 2
5086: PUSH
5087: LD_INT 21
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 51
5099: PUSH
5100: EMPTY
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 21
5109: PUSH
5110: LD_INT 2
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: PUSH
5131: FOR_IN
5132: IFFALSE 5255
// begin SetSide ( i , players [ j ] ) ;
5134: LD_VAR 0 4
5138: PPUSH
5139: LD_VAR 0 3
5143: PUSH
5144: LD_VAR 0 5
5148: ARRAY
5149: PPUSH
5150: CALL_OW 235
// if IsDrivenBy ( i ) then
5154: LD_VAR 0 4
5158: PPUSH
5159: CALL_OW 311
5163: IFFALSE 5190
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5165: LD_VAR 0 4
5169: PPUSH
5170: CALL_OW 311
5174: PPUSH
5175: LD_VAR 0 3
5179: PUSH
5180: LD_VAR 0 5
5184: ARRAY
5185: PPUSH
5186: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5190: LD_VAR 0 4
5194: PPUSH
5195: CALL_OW 310
5199: PPUSH
5200: CALL_OW 247
5204: PUSH
5205: LD_INT 3
5207: EQUAL
5208: IFFALSE 5219
// ComExitBuilding ( i ) ;
5210: LD_VAR 0 4
5214: PPUSH
5215: CALL_OW 122
// j := j + 1 ;
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 1
5231: PLUS
5232: ST_TO_ADDR
// if j > players then
5233: LD_VAR 0 5
5237: PUSH
5238: LD_VAR 0 3
5242: GREATER
5243: IFFALSE 5253
// j := 1 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 1
5252: ST_TO_ADDR
// end ;
5253: GO 5131
5255: POP
5256: POP
// end ; end ;
5257: LD_VAR 0 2
5261: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5262: LD_INT 0
5264: PPUSH
5265: PPUSH
5266: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5267: LD_ADDR_VAR 0 3
5271: PUSH
5272: LD_INT 5
5274: PUSH
5275: LD_INT 10
5277: PUSH
5278: EMPTY
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 120
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: PUSH
5292: LD_INT 101
5294: PUSH
5295: LD_INT 8
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PUSH
5302: LD_INT 27
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_VAR 0 3
5330: PPUSH
5331: CALL_OW 12
5335: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5336: LD_INT 4
5338: PPUSH
5339: LD_INT 5
5341: PPUSH
5342: LD_VAR 0 3
5346: PUSH
5347: LD_VAR 0 2
5351: ARRAY
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_VAR 0 3
5361: PUSH
5362: LD_VAR 0 2
5366: ARRAY
5367: PUSH
5368: LD_INT 2
5370: ARRAY
5371: PPUSH
5372: LD_INT 0
5374: PPUSH
5375: CALL_OW 58
// end ;
5379: LD_VAR 0 1
5383: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5384: LD_INT 0
5386: PPUSH
// if not side or side > 8 then
5387: LD_VAR 0 1
5391: NOT
5392: PUSH
5393: LD_VAR 0 1
5397: PUSH
5398: LD_INT 8
5400: GREATER
5401: OR
5402: IFFALSE 5406
// exit ;
5404: GO 5423
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 6
5413: PPUSH
5414: CALL 4859 0 1
5418: PPUSH
5419: CALL 4701 0 2
// end ;
5423: LD_VAR 0 2
5427: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5428: LD_INT 0
5430: PPUSH
// if not side or side > 8 then
5431: LD_VAR 0 1
5435: NOT
5436: PUSH
5437: LD_VAR 0 1
5441: PUSH
5442: LD_INT 8
5444: GREATER
5445: OR
5446: IFFALSE 5450
// exit ;
5448: GO 5467
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_INT 4
5457: PPUSH
5458: CALL 4859 0 1
5462: PPUSH
5463: CALL 4701 0 2
// end ;
5467: LD_VAR 0 2
5471: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5472: LD_INT 0
5474: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5475: LD_VAR 0 1
5479: NOT
5480: PUSH
5481: LD_VAR 0 1
5485: PUSH
5486: LD_INT 8
5488: GREATER
5489: OR
5490: PUSH
5491: LD_VAR 0 2
5495: PUSH
5496: LD_INT 2
5498: PUSH
5499: LD_INT 6
5501: PUSH
5502: LD_INT 36
5504: PUSH
5505: LD_INT 0
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: IN
5514: NOT
5515: OR
5516: IFFALSE 5520
// exit ;
5518: GO 5537
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5520: LD_VAR 0 1
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: CALL 4859 0 1
5532: PPUSH
5533: CALL 4701 0 2
// end ;
5537: LD_VAR 0 3
5541: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5542: LD_INT 0
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
// if not un then
5550: LD_VAR 0 1
5554: NOT
5555: IFFALSE 5559
// exit ;
5557: GO 5783
// if not points then
5559: LD_VAR 0 2
5563: NOT
5564: IFFALSE 5581
// gained_points := Multiplayer_GetCondition ( 1 ) else
5566: LD_ADDR_VAR 0 8
5570: PUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL 4859 0 1
5578: ST_TO_ADDR
5579: GO 5591
// gained_points := points ;
5581: LD_ADDR_VAR 0 8
5585: PUSH
5586: LD_VAR 0 2
5590: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5591: LD_ADDR_VAR 0 6
5595: PUSH
5596: LD_VAR 0 1
5600: PPUSH
5601: CALL_OW 503
5605: ST_TO_ADDR
// if last_shoot > - 1 then
5606: LD_VAR 0 6
5610: PUSH
5611: LD_INT 1
5613: NEG
5614: GREATER
5615: IFFALSE 5627
// begin side := last_shoot ;
5617: LD_ADDR_VAR 0 4
5621: PUSH
5622: LD_VAR 0 6
5626: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: LD_OWVAR 3
5636: PUSH
5637: LD_INT 22
5639: PUSH
5640: LD_VAR 0 1
5644: PPUSH
5645: CALL_OW 255
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: DIFF
5659: PPUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: CALL_OW 74
5669: ST_TO_ADDR
// if nearest_unit then
5670: LD_VAR 0 7
5674: IFFALSE 5691
// side2 := GetSide ( nearest_unit ) ;
5676: LD_ADDR_VAR 0 5
5680: PUSH
5681: LD_VAR 0 7
5685: PPUSH
5686: CALL_OW 255
5690: ST_TO_ADDR
// if not side and not side2 then
5691: LD_VAR 0 4
5695: NOT
5696: PUSH
5697: LD_VAR 0 5
5701: NOT
5702: AND
5703: IFFALSE 5707
// exit ;
5705: GO 5783
// if side = side2 then
5707: LD_VAR 0 4
5711: PUSH
5712: LD_VAR 0 5
5716: EQUAL
5717: IFFALSE 5735
// Multiplayer_AddPoints ( side , gained_points ) else
5719: LD_VAR 0 4
5723: PPUSH
5724: LD_VAR 0 8
5728: PPUSH
5729: CALL 4701 0 2
5733: GO 5783
// begin if side then
5735: LD_VAR 0 4
5739: IFFALSE 5759
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5741: LD_VAR 0 4
5745: PPUSH
5746: LD_VAR 0 8
5750: PUSH
5751: LD_INT 2
5753: DIV
5754: PPUSH
5755: CALL 4701 0 2
// if side2 then
5759: LD_VAR 0 5
5763: IFFALSE 5783
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5765: LD_VAR 0 5
5769: PPUSH
5770: LD_VAR 0 8
5774: PUSH
5775: LD_INT 2
5777: DIV
5778: PPUSH
5779: CALL 4701 0 2
// end ; end ;
5783: LD_VAR 0 3
5787: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5788: LD_INT 0
5790: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5791: LD_VAR 0 1
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: CALL 4859 0 1
5803: PPUSH
5804: CALL 4701 0 2
// end ; end_of_file
5808: LD_VAR 0 2
5812: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5813: LD_INT 0
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
5823: PPUSH
// side_bot := side ;
5824: LD_ADDR_EXP 3
5828: PUSH
5829: LD_VAR 0 1
5833: ST_TO_ADDR
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5834: LD_ADDR_VAR 0 10
5838: PUSH
5839: LD_INT 11
5841: PUSH
5842: LD_INT 4
5844: PUSH
5845: LD_INT 3
5847: PUSH
5848: LD_INT 5
5850: PUSH
5851: LD_INT 66
5853: PUSH
5854: LD_INT 67
5856: PUSH
5857: LD_INT 53
5859: PUSH
5860: LD_INT 18
5862: PUSH
5863: LD_INT 40
5865: PUSH
5866: LD_INT 22
5868: PUSH
5869: LD_INT 72
5871: PUSH
5872: LD_INT 55
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: ST_TO_ADDR
// for i in techs do
5889: LD_ADDR_VAR 0 3
5893: PUSH
5894: LD_VAR 0 10
5898: PUSH
5899: FOR_IN
5900: IFFALSE 5921
// SetTech ( i , side , state_researched ) ;
5902: LD_VAR 0 3
5906: PPUSH
5907: LD_VAR 0 1
5911: PPUSH
5912: LD_INT 2
5914: PPUSH
5915: CALL_OW 322
5919: GO 5899
5921: POP
5922: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5923: LD_ADDR_VAR 0 8
5927: PUSH
5928: LD_INT 6
5930: PUSH
5931: LD_INT 7
5933: PUSH
5934: LD_INT 8
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_OWVAR 67
5946: ARRAY
5947: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5948: LD_INT 69
5950: PUSH
5951: EMPTY
5952: LIST
5953: PPUSH
5954: LD_INT 141
5956: PPUSH
5957: CALL_OW 169
// wait ( 1 ) ;
5961: LD_INT 1
5963: PPUSH
5964: CALL_OW 67
// uc_side := side ;
5968: LD_ADDR_OWVAR 20
5972: PUSH
5973: LD_VAR 0 1
5977: ST_TO_ADDR
// uc_nation := 2 ;
5978: LD_ADDR_OWVAR 21
5982: PUSH
5983: LD_INT 2
5985: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
5986: LD_ADDR_EXP 33
5990: PUSH
5991: LD_INT 94
5993: PPUSH
5994: LD_INT 35
5996: PPUSH
5997: LD_STRING dammam
5999: PPUSH
6000: LD_VAR 0 8
6004: PPUSH
6005: LD_INT 10000
6007: PUSH
6008: LD_INT 1000
6010: PUSH
6011: LD_INT 300
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: PPUSH
6019: LD_INT 12
6021: PUSH
6022: LD_INT 4
6024: PUSH
6025: LD_INT 1
6027: NEG
6028: PUSH
6029: LD_INT 4
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: PPUSH
6038: CALL 18271 0 6
6042: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6043: LD_ADDR_EXP 34
6047: PUSH
6048: LD_INT 122
6050: PPUSH
6051: LD_INT 38
6053: PPUSH
6054: LD_STRING 
6056: PPUSH
6057: LD_VAR 0 8
6061: PPUSH
6062: LD_INT 1000
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PPUSH
6076: LD_INT 12
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 0
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL 18271 0 6
6098: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6099: LD_ADDR_EXP 31
6103: PUSH
6104: LD_INT 45
6106: PPUSH
6107: LD_INT 34
6109: PPUSH
6110: LD_STRING jeddah
6112: PPUSH
6113: LD_VAR 0 8
6117: PPUSH
6118: LD_INT 700
6120: PUSH
6121: LD_INT 300
6123: PUSH
6124: LD_INT 10
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PPUSH
6132: LD_INT 12
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL 18271 0 6
6154: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6155: LD_ADDR_EXP 32
6159: PUSH
6160: LD_INT 7
6162: PPUSH
6163: LD_INT 33
6165: PPUSH
6166: LD_STRING riyadh
6168: PPUSH
6169: LD_VAR 0 8
6173: PPUSH
6174: LD_INT 500
6176: PUSH
6177: LD_INT 60
6179: PUSH
6180: LD_INT 0
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: PPUSH
6188: LD_INT 4
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: LD_INT 3
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL 18271 0 6
6210: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6211: LD_ADDR_EXP 35
6215: PUSH
6216: LD_INT 69
6218: PPUSH
6219: LD_INT 36
6221: PPUSH
6222: LD_STRING 
6224: PPUSH
6225: LD_VAR 0 8
6229: PPUSH
6230: LD_INT 500
6232: PUSH
6233: LD_INT 50
6235: PUSH
6236: LD_INT 0
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: LD_INT 11
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 3
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PPUSH
6262: CALL 18271 0 6
6266: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6267: LD_ADDR_EXP 43
6271: PUSH
6272: LD_EXP 33
6276: PUSH
6277: LD_EXP 31
6281: PUSH
6282: LD_EXP 35
6286: PUSH
6287: LD_EXP 32
6291: PUSH
6292: LD_EXP 34
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6304: LD_ADDR_OWVAR 37
6308: PUSH
6309: LD_INT 14
6311: ST_TO_ADDR
// vc_engine := engine_siberite ;
6312: LD_ADDR_OWVAR 39
6316: PUSH
6317: LD_INT 3
6319: ST_TO_ADDR
// vc_control := control_manual ;
6320: LD_ADDR_OWVAR 38
6324: PUSH
6325: LD_INT 1
6327: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6328: LD_ADDR_OWVAR 40
6332: PUSH
6333: LD_INT 31
6335: ST_TO_ADDR
// for i = 1 to 4 do
6336: LD_ADDR_VAR 0 3
6340: PUSH
6341: DOUBLE
6342: LD_INT 1
6344: DEC
6345: ST_TO_ADDR
6346: LD_INT 4
6348: PUSH
6349: FOR_TO
6350: IFFALSE 6619
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6352: LD_ADDR_VAR 0 5
6356: PUSH
6357: LD_INT 156
6359: PUSH
6360: LD_INT 15
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: LD_INT 12
6369: PUSH
6370: LD_INT 7
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_VAR 0 3
6385: PUSH
6386: LD_INT 2
6388: MOD
6389: PUSH
6390: LD_INT 1
6392: PLUS
6393: ARRAY
6394: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6395: LD_INT 0
6397: PPUSH
6398: LD_INT 3
6400: PPUSH
6401: LD_VAR 0 8
6405: PPUSH
6406: CALL_OW 380
// un := CreateVehicle ;
6410: LD_ADDR_VAR 0 6
6414: PUSH
6415: CALL_OW 45
6419: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6420: LD_VAR 0 6
6424: PPUSH
6425: LD_INT 0
6427: PPUSH
6428: LD_INT 5
6430: PPUSH
6431: CALL_OW 12
6435: PPUSH
6436: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6440: LD_VAR 0 6
6444: PPUSH
6445: LD_VAR 0 5
6449: PUSH
6450: LD_INT 1
6452: ARRAY
6453: PPUSH
6454: LD_VAR 0 5
6458: PUSH
6459: LD_INT 2
6461: ARRAY
6462: PPUSH
6463: LD_INT 6
6465: PPUSH
6466: LD_INT 0
6468: PPUSH
6469: CALL_OW 50
// un2 := CreateHuman ;
6473: LD_ADDR_VAR 0 7
6477: PUSH
6478: CALL_OW 44
6482: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6483: LD_VAR 0 7
6487: PPUSH
6488: LD_VAR 0 6
6492: PPUSH
6493: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6497: LD_ADDR_EXP 43
6501: PUSH
6502: LD_EXP 43
6506: PPUSH
6507: LD_VAR 0 3
6511: PUSH
6512: LD_INT 2
6514: MOD
6515: PUSH
6516: LD_INT 1
6518: PLUS
6519: PUSH
6520: LD_EXP 43
6524: PUSH
6525: LD_VAR 0 3
6529: PUSH
6530: LD_INT 2
6532: MOD
6533: PUSH
6534: LD_INT 1
6536: PLUS
6537: ARRAY
6538: PUSH
6539: LD_INT 1
6541: PLUS
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PPUSH
6547: LD_VAR 0 6
6551: PPUSH
6552: CALL 14949 0 3
6556: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6557: LD_ADDR_EXP 43
6561: PUSH
6562: LD_EXP 43
6566: PPUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 2
6574: MOD
6575: PUSH
6576: LD_INT 1
6578: PLUS
6579: PUSH
6580: LD_EXP 43
6584: PUSH
6585: LD_VAR 0 3
6589: PUSH
6590: LD_INT 2
6592: MOD
6593: PUSH
6594: LD_INT 1
6596: PLUS
6597: ARRAY
6598: PUSH
6599: LD_INT 1
6601: PLUS
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: LD_VAR 0 7
6611: PPUSH
6612: CALL 14949 0 3
6616: ST_TO_ADDR
// end ;
6617: GO 6349
6619: POP
6620: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_INT 22
6628: PUSH
6629: LD_EXP 3
6633: PUSH
6634: EMPTY
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 30
6640: PUSH
6641: LD_INT 31
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: LD_INT 58
6650: PUSH
6651: EMPTY
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: PPUSH
6659: CALL_OW 69
6663: PUSH
6664: FOR_IN
6665: IFFALSE 6790
// begin if GetBase ( i ) then
6667: LD_VAR 0 3
6671: PPUSH
6672: CALL_OW 274
6676: IFFALSE 6680
// continue ;
6678: GO 6664
// d := GetDir ( i ) ;
6680: LD_ADDR_VAR 0 4
6684: PUSH
6685: LD_VAR 0 3
6689: PPUSH
6690: CALL_OW 254
6694: ST_TO_ADDR
// if d < 3 then
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 3
6702: LESS
6703: IFFALSE 6721
// d := d + 3 else
6705: LD_ADDR_VAR 0 4
6709: PUSH
6710: LD_VAR 0 4
6714: PUSH
6715: LD_INT 3
6717: PLUS
6718: ST_TO_ADDR
6719: GO 6735
// d := d - 3 ;
6721: LD_ADDR_VAR 0 4
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 3
6733: MINUS
6734: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6735: LD_INT 0
6737: PPUSH
6738: LD_INT 8
6740: PPUSH
6741: LD_VAR 0 8
6745: PPUSH
6746: CALL_OW 380
// un := CreateHuman ;
6750: LD_ADDR_VAR 0 6
6754: PUSH
6755: CALL_OW 44
6759: ST_TO_ADDR
// SetDir ( un , d ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_VAR 0 4
6769: PPUSH
6770: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6774: LD_VAR 0 6
6778: PPUSH
6779: LD_VAR 0 3
6783: PPUSH
6784: CALL_OW 52
// end ;
6788: GO 6664
6790: POP
6791: POP
// ar_force_tmp := [ ] ;
6792: LD_ADDR_EXP 36
6796: PUSH
6797: EMPTY
6798: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6814: LD_ADDR_OWVAR 33
6818: PUSH
6819: LD_STRING SecondCharsGal
6821: ST_TO_ADDR
// hc_face_number := 4 ;
6822: LD_ADDR_OWVAR 34
6826: PUSH
6827: LD_INT 4
6829: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6830: LD_ADDR_EXP 36
6834: PUSH
6835: LD_EXP 36
6839: PPUSH
6840: LD_INT 1
6842: PPUSH
6843: CALL_OW 44
6847: PPUSH
6848: CALL_OW 1
6852: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6853: LD_INT 2
6855: PPUSH
6856: LD_INT 4
6858: PPUSH
6859: LD_VAR 0 8
6863: PPUSH
6864: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6868: LD_ADDR_OWVAR 33
6872: PUSH
6873: LD_STRING SecondCharsGal
6875: ST_TO_ADDR
// hc_face_number := 15 ;
6876: LD_ADDR_OWVAR 34
6880: PUSH
6881: LD_INT 15
6883: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6884: LD_ADDR_EXP 36
6888: PUSH
6889: LD_EXP 36
6893: PPUSH
6894: LD_INT 2
6896: PPUSH
6897: CALL_OW 44
6901: PPUSH
6902: CALL_OW 1
6906: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PPUSH
6913: LD_VAR 0 8
6917: PPUSH
6918: CALL_OW 380
// hc_gallery :=  ;
6922: LD_ADDR_OWVAR 33
6926: PUSH
6927: LD_STRING 
6929: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6930: LD_ADDR_EXP 36
6934: PUSH
6935: LD_EXP 36
6939: PPUSH
6940: LD_INT 3
6942: PPUSH
6943: CALL_OW 44
6947: PPUSH
6948: CALL_OW 1
6952: ST_TO_ADDR
// hc_sex := sex_male ;
6953: LD_ADDR_OWVAR 27
6957: PUSH
6958: LD_INT 1
6960: ST_TO_ADDR
// hc_class = 11 ;
6961: LD_ADDR_OWVAR 28
6965: PUSH
6966: LD_INT 11
6968: ST_TO_ADDR
// hc_gallery = sandar ;
6969: LD_ADDR_OWVAR 33
6973: PUSH
6974: LD_STRING sandar
6976: ST_TO_ADDR
// hc_face_number = 33 ;
6977: LD_ADDR_OWVAR 34
6981: PUSH
6982: LD_INT 33
6984: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
6985: LD_ADDR_OWVAR 26
6989: PUSH
6990: LD_STRING Thabit Muhair Saliba
6992: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
6993: LD_ADDR_OWVAR 31
6997: PUSH
6998: LD_INT 5
7000: PUSH
7001: LD_INT 5
7003: PUSH
7004: LD_INT 3
7006: PUSH
7007: LD_INT 3
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: ST_TO_ADDR
// Saliba = CreateHuman ;
7016: LD_ADDR_EXP 39
7020: PUSH
7021: CALL_OW 44
7025: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7026: LD_EXP 39
7030: PPUSH
7031: LD_INT 7
7033: PPUSH
7034: CALL_OW 52
// hc_name := Dietrich Gensher ;
7038: LD_ADDR_OWVAR 26
7042: PUSH
7043: LD_STRING Dietrich Gensher
7045: ST_TO_ADDR
// hc_class := 1 ;
7046: LD_ADDR_OWVAR 28
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// hc_gallery := sandar ;
7054: LD_ADDR_OWVAR 33
7058: PUSH
7059: LD_STRING sandar
7061: ST_TO_ADDR
// hc_face_number := 2 ;
7062: LD_ADDR_OWVAR 34
7066: PUSH
7067: LD_INT 2
7069: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7070: LD_ADDR_OWVAR 31
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 6
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 4
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: ST_TO_ADDR
// Gensher := CreateHuman ;
7093: LD_ADDR_EXP 40
7097: PUSH
7098: CALL_OW 44
7102: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7103: LD_EXP 40
7107: PPUSH
7108: LD_INT 94
7110: PPUSH
7111: CALL_OW 52
// InitHc ;
7115: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7119: LD_ADDR_EXP 38
7123: PUSH
7124: EMPTY
7125: PUSH
7126: EMPTY
7127: PUSH
7128: EMPTY
7129: PUSH
7130: EMPTY
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7138: LD_ADDR_VAR 0 4
7142: PUSH
7143: DOUBLE
7144: LD_INT 1
7146: DEC
7147: ST_TO_ADDR
7148: LD_INT 3
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 4
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: LD_OWVAR 67
7166: ARRAY
7167: PUSH
7168: FOR_TO
7169: IFFALSE 7387
// for i = 1 to 3 do
7171: LD_ADDR_VAR 0 3
7175: PUSH
7176: DOUBLE
7177: LD_INT 1
7179: DEC
7180: ST_TO_ADDR
7181: LD_INT 3
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7383
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7187: LD_INT 14
7189: PPUSH
7190: LD_INT 3
7192: PUSH
7193: LD_INT 2
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 1
7202: PPUSH
7203: LD_INT 2
7205: PPUSH
7206: CALL_OW 12
7210: ARRAY
7211: PPUSH
7212: LD_INT 1
7214: PUSH
7215: LD_INT 5
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 2
7227: PPUSH
7228: CALL_OW 12
7232: ARRAY
7233: PPUSH
7234: LD_INT 25
7236: PUSH
7237: LD_INT 27
7239: PUSH
7240: LD_INT 26
7242: PUSH
7243: LD_INT 28
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 1
7254: PPUSH
7255: LD_INT 4
7257: PPUSH
7258: CALL_OW 12
7262: ARRAY
7263: PPUSH
7264: LD_INT 100
7266: PPUSH
7267: CALL 14827 0 5
// un := CreateVehicle ;
7271: LD_ADDR_VAR 0 6
7275: PUSH
7276: CALL_OW 45
7280: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7281: LD_ADDR_EXP 38
7285: PUSH
7286: LD_EXP 38
7290: PPUSH
7291: LD_VAR 0 3
7295: PUSH
7296: LD_EXP 38
7300: PUSH
7301: LD_VAR 0 3
7305: ARRAY
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: LD_VAR 0 6
7319: PPUSH
7320: CALL 14949 0 3
7324: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: LD_INT 5
7335: PPUSH
7336: CALL_OW 12
7340: PPUSH
7341: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7345: LD_VAR 0 6
7349: PPUSH
7350: LD_INT 20
7352: PUSH
7353: LD_INT 21
7355: PUSH
7356: LD_INT 22
7358: PUSH
7359: LD_INT 24
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_VAR 0 3
7372: ARRAY
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 49
// end ;
7381: GO 7184
7383: POP
7384: POP
7385: GO 7168
7387: POP
7388: POP
// InitHc ;
7389: CALL_OW 19
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
7393: LD_ADDR_VAR 0 9
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 2
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: ST_TO_ADDR
// if tmp and side <> 2 then
7413: LD_VAR 0 9
7417: PUSH
7418: LD_VAR 0 1
7422: PUSH
7423: LD_INT 2
7425: NONEQUAL
7426: AND
7427: IFFALSE 7460
// begin for i in tmp do
7429: LD_ADDR_VAR 0 3
7433: PUSH
7434: LD_VAR 0 9
7438: PUSH
7439: FOR_IN
7440: IFFALSE 7458
// SetSide ( i , side ) ;
7442: LD_VAR 0 3
7446: PPUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 235
7456: GO 7439
7458: POP
7459: POP
// end ; end ;
7460: LD_VAR 0 2
7464: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7465: LD_INT 94
7467: PPUSH
7468: CALL_OW 302
7472: PUSH
7473: LD_INT 94
7475: PPUSH
7476: CALL_OW 255
7480: PUSH
7481: LD_EXP 3
7485: EQUAL
7486: AND
7487: IFFALSE 8196
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
7496: PPUSH
7497: PPUSH
7498: PPUSH
7499: PPUSH
7500: PPUSH
7501: PPUSH
7502: PPUSH
7503: PPUSH
// begin enable ;
7504: ENABLE
// base := 1 ;
7505: LD_ADDR_VAR 0 4
7509: PUSH
7510: LD_INT 1
7512: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7513: LD_ADDR_VAR 0 7
7517: PUSH
7518: LD_INT 0
7520: PUSH
7521: LD_INT 0
7523: PUSH
7524: LD_INT 0
7526: PUSH
7527: LD_INT 0
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: LD_INT 0
7538: PUSH
7539: LD_INT 0
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: LD_INT 0
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7560: LD_ADDR_VAR 0 6
7564: PUSH
7565: LD_INT 28
7567: PUSH
7568: LD_INT 14
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 107
7577: PUSH
7578: LD_INT 119
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 127
7587: PUSH
7588: LD_INT 97
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 185
7597: PUSH
7598: LD_INT 127
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: ST_TO_ADDR
// target := 0 ;
7611: LD_ADDR_VAR 0 9
7615: PUSH
7616: LD_INT 0
7618: ST_TO_ADDR
// x := 0 ;
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 0
7626: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7627: LD_ADDR_VAR 0 5
7631: PUSH
7632: LD_INT 14
7634: PUSH
7635: LD_INT 1
7637: PUSH
7638: LD_INT 2
7640: PUSH
7641: LD_INT 28
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 14
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: LD_INT 25
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 28
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 14
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 2
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: ST_TO_ADDR
// if Difficulty > 1 then
7710: LD_OWVAR 67
7714: PUSH
7715: LD_INT 1
7717: GREATER
7718: IFFALSE 7815
// for i = 1 to Difficulty + 2 do
7720: LD_ADDR_VAR 0 1
7724: PUSH
7725: DOUBLE
7726: LD_INT 1
7728: DEC
7729: ST_TO_ADDR
7730: LD_OWVAR 67
7734: PUSH
7735: LD_INT 2
7737: PLUS
7738: PUSH
7739: FOR_TO
7740: IFFALSE 7813
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7742: LD_ADDR_VAR 0 5
7746: PUSH
7747: LD_VAR 0 5
7751: PPUSH
7752: LD_VAR 0 5
7756: PUSH
7757: LD_INT 1
7759: PLUS
7760: PPUSH
7761: LD_INT 14
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: LD_INT 2
7769: PUSH
7770: LD_INT 28
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 27
7778: PUSH
7779: LD_INT 29
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 1
7790: PPUSH
7791: LD_INT 4
7793: PPUSH
7794: CALL_OW 12
7798: ARRAY
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 2
7810: ST_TO_ADDR
7811: GO 7739
7813: POP
7814: POP
// MC_SetProduceList ( base , tmp ) ;
7815: LD_VAR 0 4
7819: PPUSH
7820: LD_VAR 0 5
7824: PPUSH
7825: CALL 75469 0 2
// repeat wait ( 0 0$1 ) ;
7829: LD_INT 35
7831: PPUSH
7832: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7836: LD_VAR 0 4
7840: PPUSH
7841: CALL 75865 0 1
7845: PUSH
7846: LD_INT 0
7848: EQUAL
7849: IFFALSE 7829
// wait ( 0 0$10 ) ;
7851: LD_INT 350
7853: PPUSH
7854: CALL_OW 67
// for i = 1 to coords do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7962
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: LD_EXP 3
7885: PPUSH
7886: LD_VAR 0 6
7890: PUSH
7891: LD_VAR 0 1
7895: ARRAY
7896: PUSH
7897: LD_INT 1
7899: ARRAY
7900: PPUSH
7901: LD_VAR 0 6
7905: PUSH
7906: LD_VAR 0 1
7910: ARRAY
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: LD_INT 35
7918: PPUSH
7919: CALL 15845 0 4
7923: PUSH
7924: LD_INT 4
7926: ARRAY
7927: ST_TO_ADDR
// if t > x then
7928: LD_VAR 0 2
7932: PUSH
7933: LD_VAR 0 3
7937: GREATER
7938: IFFALSE 7960
// begin x := t ;
7940: LD_ADDR_VAR 0 3
7944: PUSH
7945: LD_VAR 0 2
7949: ST_TO_ADDR
// target := i ;
7950: LD_ADDR_VAR 0 9
7954: PUSH
7955: LD_VAR 0 1
7959: ST_TO_ADDR
// end ; end ;
7960: GO 7873
7962: POP
7963: POP
// case target of 1 :
7964: LD_VAR 0 9
7968: PUSH
7969: LD_INT 1
7971: DOUBLE
7972: EQUAL
7973: IFTRUE 7977
7975: GO 8009
7977: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7978: LD_ADDR_VAR 0 10
7982: PUSH
7983: LD_INT 60
7985: PUSH
7986: LD_INT 8
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 28
7995: PUSH
7996: LD_INT 15
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: ST_TO_ADDR
8007: GO 8130
8009: LD_INT 2
8011: DOUBLE
8012: EQUAL
8013: IFTRUE 8017
8015: GO 8049
8017: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8018: LD_ADDR_VAR 0 10
8022: PUSH
8023: LD_INT 52
8025: PUSH
8026: LD_INT 11
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 76
8035: PUSH
8036: LD_INT 90
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: ST_TO_ADDR
8047: GO 8130
8049: LD_INT 3
8051: DOUBLE
8052: EQUAL
8053: IFTRUE 8057
8055: GO 8089
8057: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8058: LD_ADDR_VAR 0 10
8062: PUSH
8063: LD_INT 129
8065: PUSH
8066: LD_INT 66
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 130
8075: PUSH
8076: LD_INT 97
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: ST_TO_ADDR
8087: GO 8130
8089: LD_INT 4
8091: DOUBLE
8092: EQUAL
8093: IFTRUE 8097
8095: GO 8129
8097: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8098: LD_ADDR_VAR 0 10
8102: PUSH
8103: LD_INT 156
8105: PUSH
8106: LD_INT 87
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 183
8115: PUSH
8116: LD_INT 127
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: ST_TO_ADDR
8127: GO 8130
8129: POP
// if not _target then
8130: LD_VAR 0 10
8134: NOT
8135: IFFALSE 8166
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 52
8144: PUSH
8145: LD_INT 11
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 76
8154: PUSH
8155: LD_INT 90
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8166: LD_VAR 0 4
8170: PPUSH
8171: LD_EXP 62
8175: PUSH
8176: LD_VAR 0 4
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 10
8186: PPUSH
8187: LD_VAR 0 7
8191: PPUSH
8192: CALL 75702 0 4
// end ;
8196: PPOPN 10
8198: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8199: LD_INT 45
8201: PPUSH
8202: CALL_OW 302
8206: PUSH
8207: LD_INT 45
8209: PPUSH
8210: CALL_OW 255
8214: PUSH
8215: LD_EXP 3
8219: EQUAL
8220: AND
8221: PUSH
8222: LD_EXP 26
8226: PUSH
8227: LD_INT 3
8229: EQUAL
8230: PUSH
8231: LD_INT 94
8233: PPUSH
8234: CALL_OW 301
8238: OR
8239: PUSH
8240: LD_INT 94
8242: PPUSH
8243: CALL_OW 255
8247: PUSH
8248: LD_EXP 3
8252: NONEQUAL
8253: OR
8254: AND
8255: IFFALSE 8841
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
// begin enable ;
8272: ENABLE
// base := 2 ;
8273: LD_ADDR_VAR 0 4
8277: PUSH
8278: LD_INT 2
8280: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8281: LD_ADDR_VAR 0 7
8285: PUSH
8286: LD_INT 0
8288: PUSH
8289: LD_INT 0
8291: PUSH
8292: LD_INT 0
8294: PUSH
8295: LD_INT 0
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: LD_INT 0
8303: PUSH
8304: LD_INT 0
8306: PUSH
8307: LD_INT 0
8309: PUSH
8310: LD_INT 1
8312: PUSH
8313: LD_INT 0
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8328: LD_ADDR_VAR 0 6
8332: PUSH
8333: LD_INT 101
8335: PUSH
8336: LD_INT 110
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 100
8345: PUSH
8346: LD_INT 21
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: ST_TO_ADDR
// target := 0 ;
8357: LD_ADDR_VAR 0 9
8361: PUSH
8362: LD_INT 0
8364: ST_TO_ADDR
// x := 0 ;
8365: LD_ADDR_VAR 0 3
8369: PUSH
8370: LD_INT 0
8372: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8373: LD_ADDR_VAR 0 5
8377: PUSH
8378: LD_INT 14
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: LD_INT 2
8386: PUSH
8387: LD_INT 28
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 14
8398: PUSH
8399: LD_INT 1
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_INT 25
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 14
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 28
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: ST_TO_ADDR
// if Difficulty > 1 then
8437: LD_OWVAR 67
8441: PUSH
8442: LD_INT 1
8444: GREATER
8445: IFFALSE 8540
// for i = 1 to Difficulty + 1 do
8447: LD_ADDR_VAR 0 1
8451: PUSH
8452: DOUBLE
8453: LD_INT 1
8455: DEC
8456: ST_TO_ADDR
8457: LD_OWVAR 67
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: PUSH
8466: FOR_TO
8467: IFFALSE 8538
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_VAR 0 5
8478: PPUSH
8479: LD_VAR 0 5
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: PPUSH
8488: LD_INT 14
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 2
8496: PUSH
8497: LD_INT 28
8499: PUSH
8500: LD_INT 27
8502: PUSH
8503: LD_INT 27
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: LIST
8510: PUSH
8511: LD_VAR 0 1
8515: PUSH
8516: LD_INT 2
8518: MOD
8519: PUSH
8520: LD_INT 1
8522: PLUS
8523: ARRAY
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 2
8535: ST_TO_ADDR
8536: GO 8466
8538: POP
8539: POP
// MC_SetProduceList ( base , tmp ) ;
8540: LD_VAR 0 4
8544: PPUSH
8545: LD_VAR 0 5
8549: PPUSH
8550: CALL 75469 0 2
// repeat wait ( 0 0$1 ) ;
8554: LD_INT 35
8556: PPUSH
8557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8561: LD_VAR 0 4
8565: PPUSH
8566: CALL 75865 0 1
8570: PUSH
8571: LD_INT 0
8573: EQUAL
8574: IFFALSE 8554
// wait ( 0 0$10 ) ;
8576: LD_INT 350
8578: PPUSH
8579: CALL_OW 67
// for i = 1 to coords do
8583: LD_ADDR_VAR 0 1
8587: PUSH
8588: DOUBLE
8589: LD_INT 1
8591: DEC
8592: ST_TO_ADDR
8593: LD_VAR 0 6
8597: PUSH
8598: FOR_TO
8599: IFFALSE 8687
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8601: LD_ADDR_VAR 0 2
8605: PUSH
8606: LD_EXP 3
8610: PPUSH
8611: LD_VAR 0 6
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: LD_VAR 0 6
8630: PUSH
8631: LD_VAR 0 1
8635: ARRAY
8636: PUSH
8637: LD_INT 2
8639: ARRAY
8640: PPUSH
8641: LD_INT 35
8643: PPUSH
8644: CALL 15845 0 4
8648: PUSH
8649: LD_INT 4
8651: ARRAY
8652: ST_TO_ADDR
// if t > x then
8653: LD_VAR 0 2
8657: PUSH
8658: LD_VAR 0 3
8662: GREATER
8663: IFFALSE 8685
// begin x := t ;
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: LD_VAR 0 2
8674: ST_TO_ADDR
// target := i ;
8675: LD_ADDR_VAR 0 9
8679: PUSH
8680: LD_VAR 0 1
8684: ST_TO_ADDR
// end ; end ;
8685: GO 8598
8687: POP
8688: POP
// case target of 1 :
8689: LD_VAR 0 9
8693: PUSH
8694: LD_INT 1
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 8734
8702: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8703: LD_ADDR_VAR 0 10
8707: PUSH
8708: LD_INT 49
8710: PUSH
8711: LD_INT 35
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PUSH
8718: LD_INT 76
8720: PUSH
8721: LD_INT 90
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: ST_TO_ADDR
8732: GO 8775
8734: LD_INT 2
8736: DOUBLE
8737: EQUAL
8738: IFTRUE 8742
8740: GO 8774
8742: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8743: LD_ADDR_VAR 0 10
8747: PUSH
8748: LD_INT 79
8750: PUSH
8751: LD_INT 13
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: PUSH
8758: LD_INT 100
8760: PUSH
8761: LD_INT 22
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: ST_TO_ADDR
8772: GO 8775
8774: POP
// if not _target then
8775: LD_VAR 0 10
8779: NOT
8780: IFFALSE 8811
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 49
8789: PUSH
8790: LD_INT 35
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 76
8799: PUSH
8800: LD_INT 90
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8811: LD_VAR 0 4
8815: PPUSH
8816: LD_EXP 62
8820: PUSH
8821: LD_VAR 0 4
8825: ARRAY
8826: PPUSH
8827: LD_VAR 0 10
8831: PPUSH
8832: LD_VAR 0 7
8836: PPUSH
8837: CALL 75702 0 4
// end ; end_of_file
8841: PPOPN 10
8843: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8844: LD_INT 0
8846: PPUSH
8847: PPUSH
// begin if artifact_get then
8848: LD_EXP 4
8852: IFFALSE 8856
// exit ;
8854: GO 8878
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 255
8865: PPUSH
8866: CALL 5788 0 1
// artifact_get := true ;
8870: LD_ADDR_EXP 4
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// end ;
8878: PPOPN 4
8880: END
// on UnitDestroyed ( un ) do var i , side ;
8881: LD_INT 0
8883: PPUSH
8884: PPUSH
// begin side := GetSide ( un ) ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_VAR 0 1
8894: PPUSH
8895: CALL_OW 255
8899: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8900: LD_VAR 0 3
8904: PUSH
8905: LD_EXP 69
8909: IN
8910: NOT
8911: PUSH
8912: LD_EXP 7
8916: PUSH
8917: LD_VAR 0 3
8921: ARRAY
8922: AND
8923: IFFALSE 8949
// if GetType ( un ) = unit_human then
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 247
8934: PUSH
8935: LD_INT 1
8937: EQUAL
8938: IFFALSE 8949
// MultiplayerEvent_HumanLost ( side ) ;
8940: LD_VAR 0 3
8944: PPUSH
8945: CALL 5428 0 1
// if side in mc_sides then
8949: LD_VAR 0 3
8953: PUSH
8954: LD_EXP 69
8958: IN
8959: IFFALSE 9004
// if un <> Gensher then
8961: LD_VAR 0 1
8965: PUSH
8966: LD_EXP 40
8970: NONEQUAL
8971: IFFALSE 8987
// MultiplayerEvent_UnitKilled ( un , false ) else
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 0
8980: PPUSH
8981: CALL 5542 0 2
8985: GO 9004
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8987: LD_VAR 0 1
8991: PPUSH
8992: LD_INT 5
8994: PPUSH
8995: CALL 4859 0 1
8999: PPUSH
9000: CALL 5542 0 2
// if multi_commanders and multi_custom_commanders then
9004: LD_EXP 24
9008: PUSH
9009: LD_EXP 16
9013: AND
9014: IFFALSE 9076
// if un in multi_commanders then
9016: LD_VAR 0 1
9020: PUSH
9021: LD_EXP 24
9025: IN
9026: IFFALSE 9076
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9028: LD_ADDR_EXP 25
9032: PUSH
9033: LD_EXP 25
9037: PPUSH
9038: LD_VAR 0 3
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 1
9050: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9051: LD_ADDR_EXP 24
9055: PUSH
9056: LD_EXP 24
9060: PUSH
9061: LD_VAR 0 1
9065: DIFF
9066: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL 4892 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: CALL 78959 0 1
// end ;
9085: PPOPN 3
9087: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9088: LD_VAR 0 1
9092: PPUSH
9093: LD_VAR 0 2
9097: PPUSH
9098: CALL 81291 0 2
// end ;
9102: PPOPN 2
9104: END
// on BuildingComplete ( building ) do var i , j ;
9105: LD_INT 0
9107: PPUSH
9108: PPUSH
// begin if GetSide ( building ) in mc_sides then
9109: LD_VAR 0 1
9113: PPUSH
9114: CALL_OW 255
9118: PUSH
9119: LD_EXP 69
9123: IN
9124: IFFALSE 9150
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9126: LD_VAR 0 1
9130: PPUSH
9131: CALL_OW 255
9135: PPUSH
9136: LD_VAR 0 1
9140: PPUSH
9141: CALL_OW 266
9145: PPUSH
9146: CALL 5472 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9150: LD_VAR 0 1
9154: PPUSH
9155: CALL_OW 266
9159: PUSH
9160: LD_INT 0
9162: EQUAL
9163: PUSH
9164: LD_VAR 0 1
9168: PPUSH
9169: CALL_OW 255
9173: PUSH
9174: LD_EXP 69
9178: IN
9179: NOT
9180: AND
9181: PUSH
9182: LD_EXP 5
9186: AND
9187: IFFALSE 9225
// begin SetBName ( building , base_names [ 1 ] ) ;
9189: LD_VAR 0 1
9193: PPUSH
9194: LD_EXP 5
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9207: LD_ADDR_EXP 5
9211: PUSH
9212: LD_EXP 5
9216: PPUSH
9217: LD_INT 1
9219: PPUSH
9220: CALL_OW 3
9224: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9225: LD_VAR 0 1
9229: PPUSH
9230: CALL 80600 0 1
// end ;
9234: PPOPN 3
9236: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9237: LD_VAR 0 1
9241: PPUSH
9242: LD_VAR 0 2
9246: PPUSH
9247: CALL 78655 0 2
// end ;
9251: PPOPN 2
9253: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9254: LD_VAR 0 1
9258: PPUSH
9259: LD_VAR 0 2
9263: PPUSH
9264: LD_VAR 0 3
9268: PPUSH
9269: LD_VAR 0 4
9273: PPUSH
9274: LD_VAR 0 5
9278: PPUSH
9279: CALL 78275 0 5
// end ;
9283: PPOPN 5
9285: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
9290: PPUSH
// begin side := GetSide ( vehicle ) ;
9291: LD_ADDR_VAR 0 4
9295: PUSH
9296: LD_VAR 0 1
9300: PPUSH
9301: CALL_OW 255
9305: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9306: LD_VAR 0 4
9310: PUSH
9311: LD_EXP 69
9315: IN
9316: NOT
9317: PUSH
9318: LD_EXP 7
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: AND
9329: IFFALSE 9340
// MultiplayerEvent_Produced ( side ) ;
9331: LD_VAR 0 4
9335: PPUSH
9336: CALL 5384 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9340: LD_VAR 0 1
9344: PPUSH
9345: LD_VAR 0 2
9349: PPUSH
9350: CALL 77828 0 2
// end ;
9354: PPOPN 5
9356: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9357: LD_VAR 0 1
9361: PPUSH
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_VAR 0 3
9371: PPUSH
9372: LD_VAR 0 4
9376: PPUSH
9377: CALL 77666 0 4
// end ;
9381: PPOPN 4
9383: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9384: LD_VAR 0 1
9388: PPUSH
9389: LD_VAR 0 2
9393: PPUSH
9394: LD_VAR 0 3
9398: PPUSH
9399: CALL 77441 0 3
// end ;
9403: PPOPN 3
9405: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9406: LD_VAR 0 1
9410: PPUSH
9411: LD_VAR 0 2
9415: PPUSH
9416: CALL 77326 0 2
// end ;
9420: PPOPN 2
9422: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: CALL 81586 0 2
// end ;
9437: PPOPN 2
9439: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: LD_VAR 0 2
9449: PPUSH
9450: LD_VAR 0 3
9454: PPUSH
9455: LD_VAR 0 4
9459: PPUSH
9460: CALL 81802 0 4
// end ; end_of_file
9464: PPOPN 4
9466: END
// every 0 0$20 trigger game do
9467: LD_EXP 2
9471: IFFALSE 9516
9473: GO 9475
9475: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9476: LD_INT 7
9478: PUSH
9479: LD_INT 6
9481: PUSH
9482: LD_INT 4
9484: PUSH
9485: LD_INT 6
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: PPUSH
9494: LD_EXP 21
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: LD_EXP 21
9507: PUSH
9508: LD_INT 1
9510: ARRAY
9511: PPUSH
9512: CALL 9517 0 3
9516: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9517: LD_INT 0
9519: PPUSH
9520: PPUSH
9521: PPUSH
9522: PPUSH
// if not areas then
9523: LD_VAR 0 1
9527: NOT
9528: IFFALSE 9532
// exit ;
9530: GO 9807
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9532: LD_ADDR_VAR 0 7
9536: PUSH
9537: LD_INT 31
9539: PUSH
9540: LD_INT 32
9542: PUSH
9543: LD_INT 30
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: ST_TO_ADDR
// repeat wait ( time ) ;
9551: LD_VAR 0 2
9555: PPUSH
9556: CALL_OW 67
// x := 5 ;
9560: LD_ADDR_VAR 0 6
9564: PUSH
9565: LD_INT 5
9567: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9568: LD_OWVAR 1
9572: PUSH
9573: LD_INT 42000
9575: PUSH
9576: LD_INT 37800
9578: PUSH
9579: LD_INT 29400
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: LD_OWVAR 67
9591: ARRAY
9592: LESS
9593: IFFALSE 9665
// begin for i = 1 to multi_sides do
9595: LD_ADDR_VAR 0 5
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_EXP 7
9609: PUSH
9610: FOR_TO
9611: IFFALSE 9656
// if multi_sides [ i ] then
9613: LD_EXP 7
9617: PUSH
9618: LD_VAR 0 5
9622: ARRAY
9623: IFFALSE 9654
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9625: LD_VAR 0 6
9629: PPUSH
9630: LD_VAR 0 7
9634: PUSH
9635: LD_EXP 7
9639: PUSH
9640: LD_VAR 0 5
9644: ARRAY
9645: ARRAY
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: CALL_OW 55
9654: GO 9610
9656: POP
9657: POP
// wait ( 0 0$6 ) ;
9658: LD_INT 210
9660: PPUSH
9661: CALL_OW 67
// end ; for i in areas do
9665: LD_ADDR_VAR 0 5
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: FOR_IN
9676: IFFALSE 9704
// begin wait ( 0 0$6 ) ;
9678: LD_INT 210
9680: PPUSH
9681: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: LD_INT 1
9697: PPUSH
9698: CALL_OW 55
// end ;
9702: GO 9675
9704: POP
9705: POP
// time := time + 0 0$2 ;
9706: LD_ADDR_VAR 0 2
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 70
9718: PLUS
9719: ST_TO_ADDR
// amount := amount - x * 10 ;
9720: LD_ADDR_VAR 0 3
9724: PUSH
9725: LD_VAR 0 3
9729: PUSH
9730: LD_VAR 0 6
9734: PUSH
9735: LD_INT 10
9737: MUL
9738: MINUS
9739: ST_TO_ADDR
// x := x - 1 ;
9740: LD_ADDR_VAR 0 6
9744: PUSH
9745: LD_VAR 0 6
9749: PUSH
9750: LD_INT 1
9752: MINUS
9753: ST_TO_ADDR
// if x = 0 then
9754: LD_VAR 0 6
9758: PUSH
9759: LD_INT 0
9761: EQUAL
9762: IFFALSE 9772
// x := 5 ;
9764: LD_ADDR_VAR 0 6
9768: PUSH
9769: LD_INT 5
9771: ST_TO_ADDR
// if time > 4 4$00 then
9772: LD_VAR 0 2
9776: PUSH
9777: LD_INT 8400
9779: GREATER
9780: IFFALSE 9790
// time := 0 0$40 ;
9782: LD_ADDR_VAR 0 2
9786: PUSH
9787: LD_INT 1400
9789: ST_TO_ADDR
// until not game or amount <= 0 ;
9790: LD_EXP 2
9794: NOT
9795: PUSH
9796: LD_VAR 0 3
9800: PUSH
9801: LD_INT 0
9803: LESSEQUAL
9804: OR
9805: IFFALSE 9551
// end ; end_of_file
9807: LD_VAR 0 4
9811: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9812: LD_INT 0
9814: PPUSH
9815: PPUSH
// if exist_mode then
9816: LD_VAR 0 2
9820: IFFALSE 9845
// unit := CreateCharacter ( prefix & ident ) else
9822: LD_ADDR_VAR 0 5
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_VAR 0 1
9836: STR
9837: PPUSH
9838: CALL_OW 34
9842: ST_TO_ADDR
9843: GO 9860
// unit := NewCharacter ( ident ) ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 25
9859: ST_TO_ADDR
// result := unit ;
9860: LD_ADDR_VAR 0 4
9864: PUSH
9865: LD_VAR 0 5
9869: ST_TO_ADDR
// end ;
9870: LD_VAR 0 4
9874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9875: LD_INT 0
9877: PPUSH
9878: PPUSH
// if not side or not nation then
9879: LD_VAR 0 1
9883: NOT
9884: PUSH
9885: LD_VAR 0 2
9889: NOT
9890: OR
9891: IFFALSE 9895
// exit ;
9893: GO 10663
// case nation of nation_american :
9895: LD_VAR 0 2
9899: PUSH
9900: LD_INT 1
9902: DOUBLE
9903: EQUAL
9904: IFTRUE 9908
9906: GO 10122
9908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9909: LD_ADDR_VAR 0 4
9913: PUSH
9914: LD_INT 35
9916: PUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 46
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: LD_INT 82
9928: PUSH
9929: LD_INT 83
9931: PUSH
9932: LD_INT 84
9934: PUSH
9935: LD_INT 85
9937: PUSH
9938: LD_INT 86
9940: PUSH
9941: LD_INT 1
9943: PUSH
9944: LD_INT 2
9946: PUSH
9947: LD_INT 6
9949: PUSH
9950: LD_INT 15
9952: PUSH
9953: LD_INT 16
9955: PUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 12
9961: PUSH
9962: LD_INT 13
9964: PUSH
9965: LD_INT 10
9967: PUSH
9968: LD_INT 14
9970: PUSH
9971: LD_INT 20
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 22
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 32
9985: PUSH
9986: LD_INT 27
9988: PUSH
9989: LD_INT 36
9991: PUSH
9992: LD_INT 69
9994: PUSH
9995: LD_INT 39
9997: PUSH
9998: LD_INT 34
10000: PUSH
10001: LD_INT 40
10003: PUSH
10004: LD_INT 48
10006: PUSH
10007: LD_INT 49
10009: PUSH
10010: LD_INT 50
10012: PUSH
10013: LD_INT 51
10015: PUSH
10016: LD_INT 52
10018: PUSH
10019: LD_INT 53
10021: PUSH
10022: LD_INT 54
10024: PUSH
10025: LD_INT 55
10027: PUSH
10028: LD_INT 56
10030: PUSH
10031: LD_INT 57
10033: PUSH
10034: LD_INT 58
10036: PUSH
10037: LD_INT 59
10039: PUSH
10040: LD_INT 60
10042: PUSH
10043: LD_INT 61
10045: PUSH
10046: LD_INT 62
10048: PUSH
10049: LD_INT 80
10051: PUSH
10052: LD_INT 82
10054: PUSH
10055: LD_INT 83
10057: PUSH
10058: LD_INT 84
10060: PUSH
10061: LD_INT 85
10063: PUSH
10064: LD_INT 86
10066: PUSH
10067: EMPTY
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: ST_TO_ADDR
10120: GO 10587
10122: LD_INT 2
10124: DOUBLE
10125: EQUAL
10126: IFTRUE 10130
10128: GO 10356
10130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10131: LD_ADDR_VAR 0 4
10135: PUSH
10136: LD_INT 35
10138: PUSH
10139: LD_INT 45
10141: PUSH
10142: LD_INT 46
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: LD_INT 82
10150: PUSH
10151: LD_INT 83
10153: PUSH
10154: LD_INT 84
10156: PUSH
10157: LD_INT 85
10159: PUSH
10160: LD_INT 87
10162: PUSH
10163: LD_INT 70
10165: PUSH
10166: LD_INT 1
10168: PUSH
10169: LD_INT 11
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 4
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: LD_INT 6
10183: PUSH
10184: LD_INT 15
10186: PUSH
10187: LD_INT 18
10189: PUSH
10190: LD_INT 7
10192: PUSH
10193: LD_INT 17
10195: PUSH
10196: LD_INT 8
10198: PUSH
10199: LD_INT 20
10201: PUSH
10202: LD_INT 21
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 72
10210: PUSH
10211: LD_INT 26
10213: PUSH
10214: LD_INT 69
10216: PUSH
10217: LD_INT 39
10219: PUSH
10220: LD_INT 40
10222: PUSH
10223: LD_INT 41
10225: PUSH
10226: LD_INT 42
10228: PUSH
10229: LD_INT 43
10231: PUSH
10232: LD_INT 48
10234: PUSH
10235: LD_INT 49
10237: PUSH
10238: LD_INT 50
10240: PUSH
10241: LD_INT 51
10243: PUSH
10244: LD_INT 52
10246: PUSH
10247: LD_INT 53
10249: PUSH
10250: LD_INT 54
10252: PUSH
10253: LD_INT 55
10255: PUSH
10256: LD_INT 56
10258: PUSH
10259: LD_INT 60
10261: PUSH
10262: LD_INT 61
10264: PUSH
10265: LD_INT 62
10267: PUSH
10268: LD_INT 66
10270: PUSH
10271: LD_INT 67
10273: PUSH
10274: LD_INT 68
10276: PUSH
10277: LD_INT 81
10279: PUSH
10280: LD_INT 82
10282: PUSH
10283: LD_INT 83
10285: PUSH
10286: LD_INT 84
10288: PUSH
10289: LD_INT 85
10291: PUSH
10292: LD_INT 87
10294: PUSH
10295: LD_INT 88
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: ST_TO_ADDR
10354: GO 10587
10356: LD_INT 3
10358: DOUBLE
10359: EQUAL
10360: IFTRUE 10364
10362: GO 10586
10364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10365: LD_ADDR_VAR 0 4
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: LD_INT 47
10375: PUSH
10376: LD_INT 1
10378: PUSH
10379: LD_INT 2
10381: PUSH
10382: LD_INT 82
10384: PUSH
10385: LD_INT 83
10387: PUSH
10388: LD_INT 84
10390: PUSH
10391: LD_INT 85
10393: PUSH
10394: LD_INT 86
10396: PUSH
10397: LD_INT 11
10399: PUSH
10400: LD_INT 9
10402: PUSH
10403: LD_INT 20
10405: PUSH
10406: LD_INT 19
10408: PUSH
10409: LD_INT 21
10411: PUSH
10412: LD_INT 24
10414: PUSH
10415: LD_INT 22
10417: PUSH
10418: LD_INT 25
10420: PUSH
10421: LD_INT 28
10423: PUSH
10424: LD_INT 29
10426: PUSH
10427: LD_INT 30
10429: PUSH
10430: LD_INT 31
10432: PUSH
10433: LD_INT 37
10435: PUSH
10436: LD_INT 38
10438: PUSH
10439: LD_INT 32
10441: PUSH
10442: LD_INT 27
10444: PUSH
10445: LD_INT 33
10447: PUSH
10448: LD_INT 69
10450: PUSH
10451: LD_INT 39
10453: PUSH
10454: LD_INT 34
10456: PUSH
10457: LD_INT 40
10459: PUSH
10460: LD_INT 71
10462: PUSH
10463: LD_INT 23
10465: PUSH
10466: LD_INT 44
10468: PUSH
10469: LD_INT 48
10471: PUSH
10472: LD_INT 49
10474: PUSH
10475: LD_INT 50
10477: PUSH
10478: LD_INT 51
10480: PUSH
10481: LD_INT 52
10483: PUSH
10484: LD_INT 53
10486: PUSH
10487: LD_INT 54
10489: PUSH
10490: LD_INT 55
10492: PUSH
10493: LD_INT 56
10495: PUSH
10496: LD_INT 57
10498: PUSH
10499: LD_INT 58
10501: PUSH
10502: LD_INT 59
10504: PUSH
10505: LD_INT 63
10507: PUSH
10508: LD_INT 64
10510: PUSH
10511: LD_INT 65
10513: PUSH
10514: LD_INT 82
10516: PUSH
10517: LD_INT 83
10519: PUSH
10520: LD_INT 84
10522: PUSH
10523: LD_INT 85
10525: PUSH
10526: LD_INT 86
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: ST_TO_ADDR
10584: GO 10587
10586: POP
// if state > - 1 and state < 3 then
10587: LD_VAR 0 3
10591: PUSH
10592: LD_INT 1
10594: NEG
10595: GREATER
10596: PUSH
10597: LD_VAR 0 3
10601: PUSH
10602: LD_INT 3
10604: LESS
10605: AND
10606: IFFALSE 10663
// for i in result do
10608: LD_ADDR_VAR 0 5
10612: PUSH
10613: LD_VAR 0 4
10617: PUSH
10618: FOR_IN
10619: IFFALSE 10661
// if GetTech ( i , side ) <> state then
10621: LD_VAR 0 5
10625: PPUSH
10626: LD_VAR 0 1
10630: PPUSH
10631: CALL_OW 321
10635: PUSH
10636: LD_VAR 0 3
10640: NONEQUAL
10641: IFFALSE 10659
// result := result diff i ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: LD_VAR 0 5
10657: DIFF
10658: ST_TO_ADDR
10659: GO 10618
10661: POP
10662: POP
// end ;
10663: LD_VAR 0 4
10667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10668: LD_INT 0
10670: PPUSH
10671: PPUSH
10672: PPUSH
// result := true ;
10673: LD_ADDR_VAR 0 3
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10681: LD_ADDR_VAR 0 5
10685: PUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 480
10695: ST_TO_ADDR
// if not tmp then
10696: LD_VAR 0 5
10700: NOT
10701: IFFALSE 10705
// exit ;
10703: GO 10754
// for i in tmp do
10705: LD_ADDR_VAR 0 4
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: FOR_IN
10716: IFFALSE 10752
// if GetTech ( i , side ) <> state_researched then
10718: LD_VAR 0 4
10722: PPUSH
10723: LD_VAR 0 1
10727: PPUSH
10728: CALL_OW 321
10732: PUSH
10733: LD_INT 2
10735: NONEQUAL
10736: IFFALSE 10750
// begin result := false ;
10738: LD_ADDR_VAR 0 3
10742: PUSH
10743: LD_INT 0
10745: ST_TO_ADDR
// exit ;
10746: POP
10747: POP
10748: GO 10754
// end ;
10750: GO 10715
10752: POP
10753: POP
// end ;
10754: LD_VAR 0 3
10758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10759: LD_INT 0
10761: PPUSH
10762: PPUSH
10763: PPUSH
10764: PPUSH
10765: PPUSH
10766: PPUSH
10767: PPUSH
10768: PPUSH
10769: PPUSH
10770: PPUSH
10771: PPUSH
10772: PPUSH
10773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10774: LD_VAR 0 1
10778: NOT
10779: PUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 257
10789: PUSH
10790: LD_INT 9
10792: NONEQUAL
10793: OR
10794: IFFALSE 10798
// exit ;
10796: GO 11371
// side := GetSide ( unit ) ;
10798: LD_ADDR_VAR 0 9
10802: PUSH
10803: LD_VAR 0 1
10807: PPUSH
10808: CALL_OW 255
10812: ST_TO_ADDR
// tech_space := tech_spacanom ;
10813: LD_ADDR_VAR 0 12
10817: PUSH
10818: LD_INT 29
10820: ST_TO_ADDR
// tech_time := tech_taurad ;
10821: LD_ADDR_VAR 0 13
10825: PUSH
10826: LD_INT 28
10828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10829: LD_ADDR_VAR 0 11
10833: PUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 310
10843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10844: LD_VAR 0 11
10848: PPUSH
10849: CALL_OW 247
10853: PUSH
10854: LD_INT 2
10856: EQUAL
10857: IFFALSE 10861
// exit ;
10859: GO 11371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10861: LD_ADDR_VAR 0 8
10865: PUSH
10866: LD_INT 81
10868: PUSH
10869: LD_VAR 0 9
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 3
10880: PUSH
10881: LD_INT 21
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: ST_TO_ADDR
// if not tmp then
10904: LD_VAR 0 8
10908: NOT
10909: IFFALSE 10913
// exit ;
10911: GO 11371
// if in_unit then
10913: LD_VAR 0 11
10917: IFFALSE 10941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10919: LD_ADDR_VAR 0 10
10923: PUSH
10924: LD_VAR 0 8
10928: PPUSH
10929: LD_VAR 0 11
10933: PPUSH
10934: CALL_OW 74
10938: ST_TO_ADDR
10939: GO 10961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10941: LD_ADDR_VAR 0 10
10945: PUSH
10946: LD_VAR 0 8
10950: PPUSH
10951: LD_VAR 0 1
10955: PPUSH
10956: CALL_OW 74
10960: ST_TO_ADDR
// if not enemy then
10961: LD_VAR 0 10
10965: NOT
10966: IFFALSE 10970
// exit ;
10968: GO 11371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10970: LD_VAR 0 11
10974: PUSH
10975: LD_VAR 0 11
10979: PPUSH
10980: LD_VAR 0 10
10984: PPUSH
10985: CALL_OW 296
10989: PUSH
10990: LD_INT 13
10992: GREATER
10993: AND
10994: PUSH
10995: LD_VAR 0 1
10999: PPUSH
11000: LD_VAR 0 10
11004: PPUSH
11005: CALL_OW 296
11009: PUSH
11010: LD_INT 12
11012: GREATER
11013: OR
11014: IFFALSE 11018
// exit ;
11016: GO 11371
// missile := [ 1 ] ;
11018: LD_ADDR_VAR 0 14
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11029: LD_VAR 0 9
11033: PPUSH
11034: LD_VAR 0 12
11038: PPUSH
11039: CALL_OW 325
11043: IFFALSE 11072
// missile := Replace ( missile , missile + 1 , 2 ) ;
11045: LD_ADDR_VAR 0 14
11049: PUSH
11050: LD_VAR 0 14
11054: PPUSH
11055: LD_VAR 0 14
11059: PUSH
11060: LD_INT 1
11062: PLUS
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: CALL_OW 1
11071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11072: LD_VAR 0 9
11076: PPUSH
11077: LD_VAR 0 13
11081: PPUSH
11082: CALL_OW 325
11086: PUSH
11087: LD_VAR 0 10
11091: PPUSH
11092: CALL_OW 255
11096: PPUSH
11097: LD_VAR 0 13
11101: PPUSH
11102: CALL_OW 325
11106: NOT
11107: AND
11108: IFFALSE 11137
// missile := Replace ( missile , missile + 1 , 3 ) ;
11110: LD_ADDR_VAR 0 14
11114: PUSH
11115: LD_VAR 0 14
11119: PPUSH
11120: LD_VAR 0 14
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: PPUSH
11129: LD_INT 3
11131: PPUSH
11132: CALL_OW 1
11136: ST_TO_ADDR
// if missile < 2 then
11137: LD_VAR 0 14
11141: PUSH
11142: LD_INT 2
11144: LESS
11145: IFFALSE 11149
// exit ;
11147: GO 11371
// x := GetX ( enemy ) ;
11149: LD_ADDR_VAR 0 4
11153: PUSH
11154: LD_VAR 0 10
11158: PPUSH
11159: CALL_OW 250
11163: ST_TO_ADDR
// y := GetY ( enemy ) ;
11164: LD_ADDR_VAR 0 5
11168: PUSH
11169: LD_VAR 0 10
11173: PPUSH
11174: CALL_OW 251
11178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11179: LD_ADDR_VAR 0 6
11183: PUSH
11184: LD_VAR 0 4
11188: PUSH
11189: LD_INT 1
11191: NEG
11192: PPUSH
11193: LD_INT 1
11195: PPUSH
11196: CALL_OW 12
11200: PLUS
11201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11202: LD_ADDR_VAR 0 7
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: LD_INT 1
11214: NEG
11215: PPUSH
11216: LD_INT 1
11218: PPUSH
11219: CALL_OW 12
11223: PLUS
11224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11225: LD_VAR 0 6
11229: PPUSH
11230: LD_VAR 0 7
11234: PPUSH
11235: CALL_OW 488
11239: NOT
11240: IFFALSE 11262
// begin _x := x ;
11242: LD_ADDR_VAR 0 6
11246: PUSH
11247: LD_VAR 0 4
11251: ST_TO_ADDR
// _y := y ;
11252: LD_ADDR_VAR 0 7
11256: PUSH
11257: LD_VAR 0 5
11261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: LD_INT 1
11269: PPUSH
11270: LD_VAR 0 14
11274: PPUSH
11275: CALL_OW 12
11279: ST_TO_ADDR
// case i of 1 :
11280: LD_VAR 0 3
11284: PUSH
11285: LD_INT 1
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11310
11293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11294: LD_VAR 0 1
11298: PPUSH
11299: LD_VAR 0 10
11303: PPUSH
11304: CALL_OW 115
11308: GO 11371
11310: LD_INT 2
11312: DOUBLE
11313: EQUAL
11314: IFTRUE 11318
11316: GO 11340
11318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_VAR 0 6
11328: PPUSH
11329: LD_VAR 0 7
11333: PPUSH
11334: CALL_OW 153
11338: GO 11371
11340: LD_INT 3
11342: DOUBLE
11343: EQUAL
11344: IFTRUE 11348
11346: GO 11370
11348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11349: LD_VAR 0 1
11353: PPUSH
11354: LD_VAR 0 6
11358: PPUSH
11359: LD_VAR 0 7
11363: PPUSH
11364: CALL_OW 154
11368: GO 11371
11370: POP
// end ;
11371: LD_VAR 0 2
11375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11376: LD_INT 0
11378: PPUSH
11379: PPUSH
11380: PPUSH
11381: PPUSH
11382: PPUSH
11383: PPUSH
// if not unit or not building then
11384: LD_VAR 0 1
11388: NOT
11389: PUSH
11390: LD_VAR 0 2
11394: NOT
11395: OR
11396: IFFALSE 11400
// exit ;
11398: GO 11558
// x := GetX ( building ) ;
11400: LD_ADDR_VAR 0 5
11404: PUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL_OW 250
11414: ST_TO_ADDR
// y := GetY ( building ) ;
11415: LD_ADDR_VAR 0 6
11419: PUSH
11420: LD_VAR 0 2
11424: PPUSH
11425: CALL_OW 251
11429: ST_TO_ADDR
// for i = 0 to 5 do
11430: LD_ADDR_VAR 0 4
11434: PUSH
11435: DOUBLE
11436: LD_INT 0
11438: DEC
11439: ST_TO_ADDR
11440: LD_INT 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11556
// begin _x := ShiftX ( x , i , 3 ) ;
11446: LD_ADDR_VAR 0 7
11450: PUSH
11451: LD_VAR 0 5
11455: PPUSH
11456: LD_VAR 0 4
11460: PPUSH
11461: LD_INT 3
11463: PPUSH
11464: CALL_OW 272
11468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11469: LD_ADDR_VAR 0 8
11473: PUSH
11474: LD_VAR 0 6
11478: PPUSH
11479: LD_VAR 0 4
11483: PPUSH
11484: LD_INT 3
11486: PPUSH
11487: CALL_OW 273
11491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11492: LD_VAR 0 7
11496: PPUSH
11497: LD_VAR 0 8
11501: PPUSH
11502: CALL_OW 488
11506: NOT
11507: IFFALSE 11511
// continue ;
11509: GO 11443
// if HexInfo ( _x , _y ) = 0 then
11511: LD_VAR 0 7
11515: PPUSH
11516: LD_VAR 0 8
11520: PPUSH
11521: CALL_OW 428
11525: PUSH
11526: LD_INT 0
11528: EQUAL
11529: IFFALSE 11554
// begin ComMoveXY ( unit , _x , _y ) ;
11531: LD_VAR 0 1
11535: PPUSH
11536: LD_VAR 0 7
11540: PPUSH
11541: LD_VAR 0 8
11545: PPUSH
11546: CALL_OW 111
// exit ;
11550: POP
11551: POP
11552: GO 11558
// end ; end ;
11554: GO 11443
11556: POP
11557: POP
// end ;
11558: LD_VAR 0 3
11562: RET
// export function ScanBase ( side , base_area ) ; begin
11563: LD_INT 0
11565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11566: LD_ADDR_VAR 0 3
11570: PUSH
11571: LD_VAR 0 2
11575: PPUSH
11576: LD_INT 81
11578: PUSH
11579: LD_VAR 0 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 70
11592: ST_TO_ADDR
// end ;
11593: LD_VAR 0 3
11597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
// result := false ;
11604: LD_ADDR_VAR 0 2
11608: PUSH
11609: LD_INT 0
11611: ST_TO_ADDR
// side := GetSide ( unit ) ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 1
11621: PPUSH
11622: CALL_OW 255
11626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11627: LD_ADDR_VAR 0 4
11631: PUSH
11632: LD_VAR 0 1
11636: PPUSH
11637: CALL_OW 248
11641: ST_TO_ADDR
// case nat of 1 :
11642: LD_VAR 0 4
11646: PUSH
11647: LD_INT 1
11649: DOUBLE
11650: EQUAL
11651: IFTRUE 11655
11653: GO 11666
11655: POP
// tech := tech_lassight ; 2 :
11656: LD_ADDR_VAR 0 5
11660: PUSH
11661: LD_INT 12
11663: ST_TO_ADDR
11664: GO 11705
11666: LD_INT 2
11668: DOUBLE
11669: EQUAL
11670: IFTRUE 11674
11672: GO 11685
11674: POP
// tech := tech_mortar ; 3 :
11675: LD_ADDR_VAR 0 5
11679: PUSH
11680: LD_INT 41
11682: ST_TO_ADDR
11683: GO 11705
11685: LD_INT 3
11687: DOUBLE
11688: EQUAL
11689: IFTRUE 11693
11691: GO 11704
11693: POP
// tech := tech_bazooka ; end ;
11694: LD_ADDR_VAR 0 5
11698: PUSH
11699: LD_INT 44
11701: ST_TO_ADDR
11702: GO 11705
11704: POP
// if Researched ( side , tech ) then
11705: LD_VAR 0 3
11709: PPUSH
11710: LD_VAR 0 5
11714: PPUSH
11715: CALL_OW 325
11719: IFFALSE 11746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11721: LD_ADDR_VAR 0 2
11725: PUSH
11726: LD_INT 5
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: LD_INT 9
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: LIST
11739: PUSH
11740: LD_VAR 0 4
11744: ARRAY
11745: ST_TO_ADDR
// end ;
11746: LD_VAR 0 2
11750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11751: LD_INT 0
11753: PPUSH
11754: PPUSH
11755: PPUSH
// if not mines then
11756: LD_VAR 0 2
11760: NOT
11761: IFFALSE 11765
// exit ;
11763: GO 11909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 81
11772: PUSH
11773: LD_VAR 0 1
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_INT 3
11784: PUSH
11785: LD_INT 21
11787: PUSH
11788: LD_INT 3
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PPUSH
11803: CALL_OW 69
11807: ST_TO_ADDR
// for i in mines do
11808: LD_ADDR_VAR 0 4
11812: PUSH
11813: LD_VAR 0 2
11817: PUSH
11818: FOR_IN
11819: IFFALSE 11907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11821: LD_VAR 0 4
11825: PUSH
11826: LD_INT 1
11828: ARRAY
11829: PPUSH
11830: LD_VAR 0 4
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: CALL_OW 458
11843: NOT
11844: IFFALSE 11848
// continue ;
11846: GO 11818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11848: LD_VAR 0 4
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_VAR 0 4
11861: PUSH
11862: LD_INT 2
11864: ARRAY
11865: PPUSH
11866: CALL_OW 428
11870: PUSH
11871: LD_VAR 0 5
11875: IN
11876: IFFALSE 11905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11878: LD_VAR 0 4
11882: PUSH
11883: LD_INT 1
11885: ARRAY
11886: PPUSH
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 2
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 1
11900: PPUSH
11901: CALL_OW 456
// end ;
11905: GO 11818
11907: POP
11908: POP
// end ;
11909: LD_VAR 0 3
11913: RET
// export function Count ( array ) ; var i ; begin
11914: LD_INT 0
11916: PPUSH
11917: PPUSH
// result := 0 ;
11918: LD_ADDR_VAR 0 2
11922: PUSH
11923: LD_INT 0
11925: ST_TO_ADDR
// for i in array do
11926: LD_ADDR_VAR 0 3
11930: PUSH
11931: LD_VAR 0 1
11935: PUSH
11936: FOR_IN
11937: IFFALSE 11961
// if i then
11939: LD_VAR 0 3
11943: IFFALSE 11959
// result := result + 1 ;
11945: LD_ADDR_VAR 0 2
11949: PUSH
11950: LD_VAR 0 2
11954: PUSH
11955: LD_INT 1
11957: PLUS
11958: ST_TO_ADDR
11959: GO 11936
11961: POP
11962: POP
// end ;
11963: LD_VAR 0 2
11967: RET
// export function IsEmpty ( building ) ; begin
11968: LD_INT 0
11970: PPUSH
// if not building then
11971: LD_VAR 0 1
11975: NOT
11976: IFFALSE 11980
// exit ;
11978: GO 12023
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11980: LD_ADDR_VAR 0 2
11984: PUSH
11985: LD_VAR 0 1
11989: PUSH
11990: LD_INT 22
11992: PUSH
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 255
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: LD_INT 58
12009: PUSH
12010: EMPTY
12011: LIST
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: PPUSH
12017: CALL_OW 69
12021: IN
12022: ST_TO_ADDR
// end ;
12023: LD_VAR 0 2
12027: RET
// export function IsNotFull ( building ) ; var places ; begin
12028: LD_INT 0
12030: PPUSH
12031: PPUSH
// if not building then
12032: LD_VAR 0 1
12036: NOT
12037: IFFALSE 12041
// exit ;
12039: GO 12212
// result := false ;
12041: LD_ADDR_VAR 0 2
12045: PUSH
12046: LD_INT 0
12048: ST_TO_ADDR
// places := 0 ;
12049: LD_ADDR_VAR 0 3
12053: PUSH
12054: LD_INT 0
12056: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12057: LD_VAR 0 1
12061: PPUSH
12062: CALL_OW 266
12066: PUSH
12067: LD_INT 0
12069: DOUBLE
12070: EQUAL
12071: IFTRUE 12129
12073: LD_INT 1
12075: DOUBLE
12076: EQUAL
12077: IFTRUE 12129
12079: LD_INT 6
12081: DOUBLE
12082: EQUAL
12083: IFTRUE 12129
12085: LD_INT 7
12087: DOUBLE
12088: EQUAL
12089: IFTRUE 12129
12091: LD_INT 8
12093: DOUBLE
12094: EQUAL
12095: IFTRUE 12129
12097: LD_INT 4
12099: DOUBLE
12100: EQUAL
12101: IFTRUE 12129
12103: LD_INT 5
12105: DOUBLE
12106: EQUAL
12107: IFTRUE 12129
12109: LD_INT 2
12111: DOUBLE
12112: EQUAL
12113: IFTRUE 12129
12115: LD_INT 3
12117: DOUBLE
12118: EQUAL
12119: IFTRUE 12129
12121: LD_INT 35
12123: DOUBLE
12124: EQUAL
12125: IFTRUE 12129
12127: GO 12140
12129: POP
// places := 6 ; b_bunker , b_breastwork :
12130: LD_ADDR_VAR 0 3
12134: PUSH
12135: LD_INT 6
12137: ST_TO_ADDR
12138: GO 12185
12140: LD_INT 32
12142: DOUBLE
12143: EQUAL
12144: IFTRUE 12154
12146: LD_INT 31
12148: DOUBLE
12149: EQUAL
12150: IFTRUE 12154
12152: GO 12165
12154: POP
// places := 1 ; b_control_tower :
12155: LD_ADDR_VAR 0 3
12159: PUSH
12160: LD_INT 1
12162: ST_TO_ADDR
12163: GO 12185
12165: LD_INT 36
12167: DOUBLE
12168: EQUAL
12169: IFTRUE 12173
12171: GO 12184
12173: POP
// places := 3 ; end ;
12174: LD_ADDR_VAR 0 3
12178: PUSH
12179: LD_INT 3
12181: ST_TO_ADDR
12182: GO 12185
12184: POP
// if places then
12185: LD_VAR 0 3
12189: IFFALSE 12212
// result := UnitsInside ( building ) < places ;
12191: LD_ADDR_VAR 0 2
12195: PUSH
12196: LD_VAR 0 1
12200: PPUSH
12201: CALL_OW 313
12205: PUSH
12206: LD_VAR 0 3
12210: LESS
12211: ST_TO_ADDR
// end ;
12212: LD_VAR 0 2
12216: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12217: LD_INT 0
12219: PPUSH
12220: PPUSH
12221: PPUSH
12222: PPUSH
// tmp := [ ] ;
12223: LD_ADDR_VAR 0 3
12227: PUSH
12228: EMPTY
12229: ST_TO_ADDR
// list := [ ] ;
12230: LD_ADDR_VAR 0 5
12234: PUSH
12235: EMPTY
12236: ST_TO_ADDR
// for i = 16 to 25 do
12237: LD_ADDR_VAR 0 4
12241: PUSH
12242: DOUBLE
12243: LD_INT 16
12245: DEC
12246: ST_TO_ADDR
12247: LD_INT 25
12249: PUSH
12250: FOR_TO
12251: IFFALSE 12324
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12253: LD_ADDR_VAR 0 3
12257: PUSH
12258: LD_VAR 0 3
12262: PUSH
12263: LD_INT 22
12265: PUSH
12266: LD_VAR 0 1
12270: PPUSH
12271: CALL_OW 255
12275: PUSH
12276: EMPTY
12277: LIST
12278: LIST
12279: PUSH
12280: LD_INT 91
12282: PUSH
12283: LD_VAR 0 1
12287: PUSH
12288: LD_INT 6
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: LIST
12295: PUSH
12296: LD_INT 30
12298: PUSH
12299: LD_VAR 0 4
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: PUSH
12313: EMPTY
12314: LIST
12315: PPUSH
12316: CALL_OW 69
12320: ADD
12321: ST_TO_ADDR
12322: GO 12250
12324: POP
12325: POP
// for i = 1 to tmp do
12326: LD_ADDR_VAR 0 4
12330: PUSH
12331: DOUBLE
12332: LD_INT 1
12334: DEC
12335: ST_TO_ADDR
12336: LD_VAR 0 3
12340: PUSH
12341: FOR_TO
12342: IFFALSE 12430
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12344: LD_ADDR_VAR 0 5
12348: PUSH
12349: LD_VAR 0 5
12353: PUSH
12354: LD_VAR 0 3
12358: PUSH
12359: LD_VAR 0 4
12363: ARRAY
12364: PPUSH
12365: CALL_OW 266
12369: PUSH
12370: LD_VAR 0 3
12374: PUSH
12375: LD_VAR 0 4
12379: ARRAY
12380: PPUSH
12381: CALL_OW 250
12385: PUSH
12386: LD_VAR 0 3
12390: PUSH
12391: LD_VAR 0 4
12395: ARRAY
12396: PPUSH
12397: CALL_OW 251
12401: PUSH
12402: LD_VAR 0 3
12406: PUSH
12407: LD_VAR 0 4
12411: ARRAY
12412: PPUSH
12413: CALL_OW 254
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: PUSH
12424: EMPTY
12425: LIST
12426: ADD
12427: ST_TO_ADDR
12428: GO 12341
12430: POP
12431: POP
// result := list ;
12432: LD_ADDR_VAR 0 2
12436: PUSH
12437: LD_VAR 0 5
12441: ST_TO_ADDR
// end ;
12442: LD_VAR 0 2
12446: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12447: LD_INT 0
12449: PPUSH
12450: PPUSH
12451: PPUSH
12452: PPUSH
12453: PPUSH
12454: PPUSH
12455: PPUSH
// if not factory then
12456: LD_VAR 0 1
12460: NOT
12461: IFFALSE 12465
// exit ;
12463: GO 13058
// if control = control_apeman then
12465: LD_VAR 0 4
12469: PUSH
12470: LD_INT 5
12472: EQUAL
12473: IFFALSE 12582
// begin tmp := UnitsInside ( factory ) ;
12475: LD_ADDR_VAR 0 8
12479: PUSH
12480: LD_VAR 0 1
12484: PPUSH
12485: CALL_OW 313
12489: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12490: LD_VAR 0 8
12494: PPUSH
12495: LD_INT 25
12497: PUSH
12498: LD_INT 12
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PPUSH
12505: CALL_OW 72
12509: NOT
12510: IFFALSE 12520
// control := control_manual ;
12512: LD_ADDR_VAR 0 4
12516: PUSH
12517: LD_INT 1
12519: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12520: LD_ADDR_VAR 0 8
12524: PUSH
12525: LD_VAR 0 1
12529: PPUSH
12530: CALL 12217 0 1
12534: ST_TO_ADDR
// if tmp then
12535: LD_VAR 0 8
12539: IFFALSE 12582
// begin for i in tmp do
12541: LD_ADDR_VAR 0 7
12545: PUSH
12546: LD_VAR 0 8
12550: PUSH
12551: FOR_IN
12552: IFFALSE 12580
// if i [ 1 ] = b_ext_radio then
12554: LD_VAR 0 7
12558: PUSH
12559: LD_INT 1
12561: ARRAY
12562: PUSH
12563: LD_INT 22
12565: EQUAL
12566: IFFALSE 12578
// begin control := control_remote ;
12568: LD_ADDR_VAR 0 4
12572: PUSH
12573: LD_INT 2
12575: ST_TO_ADDR
// break ;
12576: GO 12580
// end ;
12578: GO 12551
12580: POP
12581: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12582: LD_VAR 0 1
12586: PPUSH
12587: LD_VAR 0 2
12591: PPUSH
12592: LD_VAR 0 3
12596: PPUSH
12597: LD_VAR 0 4
12601: PPUSH
12602: LD_VAR 0 5
12606: PPUSH
12607: CALL_OW 448
12611: IFFALSE 12646
// begin result := [ chassis , engine , control , weapon ] ;
12613: LD_ADDR_VAR 0 6
12617: PUSH
12618: LD_VAR 0 2
12622: PUSH
12623: LD_VAR 0 3
12627: PUSH
12628: LD_VAR 0 4
12632: PUSH
12633: LD_VAR 0 5
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: ST_TO_ADDR
// exit ;
12644: GO 13058
// end ; _chassis := AvailableChassisList ( factory ) ;
12646: LD_ADDR_VAR 0 9
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: CALL_OW 475
12660: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12661: LD_ADDR_VAR 0 11
12665: PUSH
12666: LD_VAR 0 1
12670: PPUSH
12671: CALL_OW 476
12675: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12676: LD_ADDR_VAR 0 12
12680: PUSH
12681: LD_VAR 0 1
12685: PPUSH
12686: CALL_OW 477
12690: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12691: LD_ADDR_VAR 0 10
12695: PUSH
12696: LD_VAR 0 1
12700: PPUSH
12701: CALL_OW 478
12705: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12706: LD_VAR 0 9
12710: NOT
12711: PUSH
12712: LD_VAR 0 11
12716: NOT
12717: OR
12718: PUSH
12719: LD_VAR 0 12
12723: NOT
12724: OR
12725: PUSH
12726: LD_VAR 0 10
12730: NOT
12731: OR
12732: IFFALSE 12767
// begin result := [ chassis , engine , control , weapon ] ;
12734: LD_ADDR_VAR 0 6
12738: PUSH
12739: LD_VAR 0 2
12743: PUSH
12744: LD_VAR 0 3
12748: PUSH
12749: LD_VAR 0 4
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: ST_TO_ADDR
// exit ;
12765: GO 13058
// end ; if not chassis in _chassis then
12767: LD_VAR 0 2
12771: PUSH
12772: LD_VAR 0 9
12776: IN
12777: NOT
12778: IFFALSE 12804
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12780: LD_ADDR_VAR 0 2
12784: PUSH
12785: LD_VAR 0 9
12789: PUSH
12790: LD_INT 1
12792: PPUSH
12793: LD_VAR 0 9
12797: PPUSH
12798: CALL_OW 12
12802: ARRAY
12803: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12804: LD_VAR 0 2
12808: PPUSH
12809: LD_VAR 0 3
12813: PPUSH
12814: CALL 13063 0 2
12818: NOT
12819: IFFALSE 12878
// repeat engine := _engine [ 1 ] ;
12821: LD_ADDR_VAR 0 3
12825: PUSH
12826: LD_VAR 0 11
12830: PUSH
12831: LD_INT 1
12833: ARRAY
12834: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12835: LD_ADDR_VAR 0 11
12839: PUSH
12840: LD_VAR 0 11
12844: PPUSH
12845: LD_INT 1
12847: PPUSH
12848: CALL_OW 3
12852: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12853: LD_VAR 0 2
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL 13063 0 2
12867: PUSH
12868: LD_VAR 0 11
12872: PUSH
12873: EMPTY
12874: EQUAL
12875: OR
12876: IFFALSE 12821
// if not control in _control then
12878: LD_VAR 0 4
12882: PUSH
12883: LD_VAR 0 12
12887: IN
12888: NOT
12889: IFFALSE 12915
// control := _control [ rand ( 1 , _control ) ] ;
12891: LD_ADDR_VAR 0 4
12895: PUSH
12896: LD_VAR 0 12
12900: PUSH
12901: LD_INT 1
12903: PPUSH
12904: LD_VAR 0 12
12908: PPUSH
12909: CALL_OW 12
12913: ARRAY
12914: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12915: LD_VAR 0 2
12919: PPUSH
12920: LD_VAR 0 5
12924: PPUSH
12925: CALL 13283 0 2
12929: NOT
12930: IFFALSE 12989
// repeat weapon := _weapon [ 1 ] ;
12932: LD_ADDR_VAR 0 5
12936: PUSH
12937: LD_VAR 0 10
12941: PUSH
12942: LD_INT 1
12944: ARRAY
12945: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12946: LD_ADDR_VAR 0 10
12950: PUSH
12951: LD_VAR 0 10
12955: PPUSH
12956: LD_INT 1
12958: PPUSH
12959: CALL_OW 3
12963: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12964: LD_VAR 0 2
12968: PPUSH
12969: LD_VAR 0 5
12973: PPUSH
12974: CALL 13283 0 2
12978: PUSH
12979: LD_VAR 0 10
12983: PUSH
12984: EMPTY
12985: EQUAL
12986: OR
12987: IFFALSE 12932
// result := [ ] ;
12989: LD_ADDR_VAR 0 6
12993: PUSH
12994: EMPTY
12995: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12996: LD_VAR 0 1
13000: PPUSH
13001: LD_VAR 0 2
13005: PPUSH
13006: LD_VAR 0 3
13010: PPUSH
13011: LD_VAR 0 4
13015: PPUSH
13016: LD_VAR 0 5
13020: PPUSH
13021: CALL_OW 448
13025: IFFALSE 13058
// result := [ chassis , engine , control , weapon ] ;
13027: LD_ADDR_VAR 0 6
13031: PUSH
13032: LD_VAR 0 2
13036: PUSH
13037: LD_VAR 0 3
13041: PUSH
13042: LD_VAR 0 4
13046: PUSH
13047: LD_VAR 0 5
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: ST_TO_ADDR
// end ;
13058: LD_VAR 0 6
13062: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13063: LD_INT 0
13065: PPUSH
// if not chassis or not engine then
13066: LD_VAR 0 1
13070: NOT
13071: PUSH
13072: LD_VAR 0 2
13076: NOT
13077: OR
13078: IFFALSE 13082
// exit ;
13080: GO 13278
// case engine of engine_solar :
13082: LD_VAR 0 2
13086: PUSH
13087: LD_INT 2
13089: DOUBLE
13090: EQUAL
13091: IFTRUE 13095
13093: GO 13133
13095: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13096: LD_ADDR_VAR 0 3
13100: PUSH
13101: LD_INT 11
13103: PUSH
13104: LD_INT 12
13106: PUSH
13107: LD_INT 13
13109: PUSH
13110: LD_INT 14
13112: PUSH
13113: LD_INT 1
13115: PUSH
13116: LD_INT 2
13118: PUSH
13119: LD_INT 3
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: ST_TO_ADDR
13131: GO 13262
13133: LD_INT 1
13135: DOUBLE
13136: EQUAL
13137: IFTRUE 13141
13139: GO 13203
13141: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13142: LD_ADDR_VAR 0 3
13146: PUSH
13147: LD_INT 11
13149: PUSH
13150: LD_INT 12
13152: PUSH
13153: LD_INT 13
13155: PUSH
13156: LD_INT 14
13158: PUSH
13159: LD_INT 1
13161: PUSH
13162: LD_INT 2
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: LD_INT 4
13170: PUSH
13171: LD_INT 5
13173: PUSH
13174: LD_INT 21
13176: PUSH
13177: LD_INT 23
13179: PUSH
13180: LD_INT 22
13182: PUSH
13183: LD_INT 24
13185: PUSH
13186: EMPTY
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: ST_TO_ADDR
13201: GO 13262
13203: LD_INT 3
13205: DOUBLE
13206: EQUAL
13207: IFTRUE 13211
13209: GO 13261
13211: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13212: LD_ADDR_VAR 0 3
13216: PUSH
13217: LD_INT 13
13219: PUSH
13220: LD_INT 14
13222: PUSH
13223: LD_INT 2
13225: PUSH
13226: LD_INT 3
13228: PUSH
13229: LD_INT 4
13231: PUSH
13232: LD_INT 5
13234: PUSH
13235: LD_INT 21
13237: PUSH
13238: LD_INT 22
13240: PUSH
13241: LD_INT 23
13243: PUSH
13244: LD_INT 24
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: ST_TO_ADDR
13259: GO 13262
13261: POP
// result := ( chassis in result ) ;
13262: LD_ADDR_VAR 0 3
13266: PUSH
13267: LD_VAR 0 1
13271: PUSH
13272: LD_VAR 0 3
13276: IN
13277: ST_TO_ADDR
// end ;
13278: LD_VAR 0 3
13282: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13283: LD_INT 0
13285: PPUSH
// if not chassis or not weapon then
13286: LD_VAR 0 1
13290: NOT
13291: PUSH
13292: LD_VAR 0 2
13296: NOT
13297: OR
13298: IFFALSE 13302
// exit ;
13300: GO 14362
// case weapon of us_machine_gun :
13302: LD_VAR 0 2
13306: PUSH
13307: LD_INT 2
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13345
13315: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_INT 1
13323: PUSH
13324: LD_INT 2
13326: PUSH
13327: LD_INT 3
13329: PUSH
13330: LD_INT 4
13332: PUSH
13333: LD_INT 5
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: ST_TO_ADDR
13343: GO 14346
13345: LD_INT 3
13347: DOUBLE
13348: EQUAL
13349: IFTRUE 13353
13351: GO 13383
13353: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13354: LD_ADDR_VAR 0 3
13358: PUSH
13359: LD_INT 1
13361: PUSH
13362: LD_INT 2
13364: PUSH
13365: LD_INT 3
13367: PUSH
13368: LD_INT 4
13370: PUSH
13371: LD_INT 5
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: ST_TO_ADDR
13381: GO 14346
13383: LD_INT 11
13385: DOUBLE
13386: EQUAL
13387: IFTRUE 13391
13389: GO 13421
13391: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13392: LD_ADDR_VAR 0 3
13396: PUSH
13397: LD_INT 1
13399: PUSH
13400: LD_INT 2
13402: PUSH
13403: LD_INT 3
13405: PUSH
13406: LD_INT 4
13408: PUSH
13409: LD_INT 5
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: ST_TO_ADDR
13419: GO 14346
13421: LD_INT 4
13423: DOUBLE
13424: EQUAL
13425: IFTRUE 13429
13427: GO 13455
13429: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13430: LD_ADDR_VAR 0 3
13434: PUSH
13435: LD_INT 2
13437: PUSH
13438: LD_INT 3
13440: PUSH
13441: LD_INT 4
13443: PUSH
13444: LD_INT 5
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: ST_TO_ADDR
13453: GO 14346
13455: LD_INT 5
13457: DOUBLE
13458: EQUAL
13459: IFTRUE 13463
13461: GO 13489
13463: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13464: LD_ADDR_VAR 0 3
13468: PUSH
13469: LD_INT 2
13471: PUSH
13472: LD_INT 3
13474: PUSH
13475: LD_INT 4
13477: PUSH
13478: LD_INT 5
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: ST_TO_ADDR
13487: GO 14346
13489: LD_INT 9
13491: DOUBLE
13492: EQUAL
13493: IFTRUE 13497
13495: GO 13523
13497: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13498: LD_ADDR_VAR 0 3
13502: PUSH
13503: LD_INT 2
13505: PUSH
13506: LD_INT 3
13508: PUSH
13509: LD_INT 4
13511: PUSH
13512: LD_INT 5
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: ST_TO_ADDR
13521: GO 14346
13523: LD_INT 7
13525: DOUBLE
13526: EQUAL
13527: IFTRUE 13531
13529: GO 13557
13531: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13532: LD_ADDR_VAR 0 3
13536: PUSH
13537: LD_INT 2
13539: PUSH
13540: LD_INT 3
13542: PUSH
13543: LD_INT 4
13545: PUSH
13546: LD_INT 5
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: ST_TO_ADDR
13555: GO 14346
13557: LD_INT 12
13559: DOUBLE
13560: EQUAL
13561: IFTRUE 13565
13563: GO 13591
13565: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13566: LD_ADDR_VAR 0 3
13570: PUSH
13571: LD_INT 2
13573: PUSH
13574: LD_INT 3
13576: PUSH
13577: LD_INT 4
13579: PUSH
13580: LD_INT 5
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: ST_TO_ADDR
13589: GO 14346
13591: LD_INT 13
13593: DOUBLE
13594: EQUAL
13595: IFTRUE 13599
13597: GO 13625
13599: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13600: LD_ADDR_VAR 0 3
13604: PUSH
13605: LD_INT 2
13607: PUSH
13608: LD_INT 3
13610: PUSH
13611: LD_INT 4
13613: PUSH
13614: LD_INT 5
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: ST_TO_ADDR
13623: GO 14346
13625: LD_INT 14
13627: DOUBLE
13628: EQUAL
13629: IFTRUE 13633
13631: GO 13651
13633: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13634: LD_ADDR_VAR 0 3
13638: PUSH
13639: LD_INT 4
13641: PUSH
13642: LD_INT 5
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: ST_TO_ADDR
13649: GO 14346
13651: LD_INT 6
13653: DOUBLE
13654: EQUAL
13655: IFTRUE 13659
13657: GO 13677
13659: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13660: LD_ADDR_VAR 0 3
13664: PUSH
13665: LD_INT 4
13667: PUSH
13668: LD_INT 5
13670: PUSH
13671: EMPTY
13672: LIST
13673: LIST
13674: ST_TO_ADDR
13675: GO 14346
13677: LD_INT 10
13679: DOUBLE
13680: EQUAL
13681: IFTRUE 13685
13683: GO 13703
13685: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13686: LD_ADDR_VAR 0 3
13690: PUSH
13691: LD_INT 4
13693: PUSH
13694: LD_INT 5
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: ST_TO_ADDR
13701: GO 14346
13703: LD_INT 22
13705: DOUBLE
13706: EQUAL
13707: IFTRUE 13711
13709: GO 13737
13711: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13712: LD_ADDR_VAR 0 3
13716: PUSH
13717: LD_INT 11
13719: PUSH
13720: LD_INT 12
13722: PUSH
13723: LD_INT 13
13725: PUSH
13726: LD_INT 14
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: ST_TO_ADDR
13735: GO 14346
13737: LD_INT 23
13739: DOUBLE
13740: EQUAL
13741: IFTRUE 13745
13743: GO 13771
13745: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13746: LD_ADDR_VAR 0 3
13750: PUSH
13751: LD_INT 11
13753: PUSH
13754: LD_INT 12
13756: PUSH
13757: LD_INT 13
13759: PUSH
13760: LD_INT 14
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: ST_TO_ADDR
13769: GO 14346
13771: LD_INT 24
13773: DOUBLE
13774: EQUAL
13775: IFTRUE 13779
13777: GO 13805
13779: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13780: LD_ADDR_VAR 0 3
13784: PUSH
13785: LD_INT 11
13787: PUSH
13788: LD_INT 12
13790: PUSH
13791: LD_INT 13
13793: PUSH
13794: LD_INT 14
13796: PUSH
13797: EMPTY
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: ST_TO_ADDR
13803: GO 14346
13805: LD_INT 30
13807: DOUBLE
13808: EQUAL
13809: IFTRUE 13813
13811: GO 13839
13813: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13814: LD_ADDR_VAR 0 3
13818: PUSH
13819: LD_INT 11
13821: PUSH
13822: LD_INT 12
13824: PUSH
13825: LD_INT 13
13827: PUSH
13828: LD_INT 14
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: LIST
13835: LIST
13836: ST_TO_ADDR
13837: GO 14346
13839: LD_INT 25
13841: DOUBLE
13842: EQUAL
13843: IFTRUE 13847
13845: GO 13865
13847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13848: LD_ADDR_VAR 0 3
13852: PUSH
13853: LD_INT 13
13855: PUSH
13856: LD_INT 14
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: ST_TO_ADDR
13863: GO 14346
13865: LD_INT 27
13867: DOUBLE
13868: EQUAL
13869: IFTRUE 13873
13871: GO 13891
13873: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13874: LD_ADDR_VAR 0 3
13878: PUSH
13879: LD_INT 13
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: ST_TO_ADDR
13889: GO 14346
13891: LD_INT 92
13893: DOUBLE
13894: EQUAL
13895: IFTRUE 13899
13897: GO 13925
13899: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13900: LD_ADDR_VAR 0 3
13904: PUSH
13905: LD_INT 11
13907: PUSH
13908: LD_INT 12
13910: PUSH
13911: LD_INT 13
13913: PUSH
13914: LD_INT 14
13916: PUSH
13917: EMPTY
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: ST_TO_ADDR
13923: GO 14346
13925: LD_INT 28
13927: DOUBLE
13928: EQUAL
13929: IFTRUE 13933
13931: GO 13951
13933: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13934: LD_ADDR_VAR 0 3
13938: PUSH
13939: LD_INT 13
13941: PUSH
13942: LD_INT 14
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: ST_TO_ADDR
13949: GO 14346
13951: LD_INT 29
13953: DOUBLE
13954: EQUAL
13955: IFTRUE 13959
13957: GO 13977
13959: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13960: LD_ADDR_VAR 0 3
13964: PUSH
13965: LD_INT 13
13967: PUSH
13968: LD_INT 14
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: ST_TO_ADDR
13975: GO 14346
13977: LD_INT 31
13979: DOUBLE
13980: EQUAL
13981: IFTRUE 13985
13983: GO 14003
13985: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13986: LD_ADDR_VAR 0 3
13990: PUSH
13991: LD_INT 13
13993: PUSH
13994: LD_INT 14
13996: PUSH
13997: EMPTY
13998: LIST
13999: LIST
14000: ST_TO_ADDR
14001: GO 14346
14003: LD_INT 26
14005: DOUBLE
14006: EQUAL
14007: IFTRUE 14011
14009: GO 14029
14011: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14012: LD_ADDR_VAR 0 3
14016: PUSH
14017: LD_INT 13
14019: PUSH
14020: LD_INT 14
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: ST_TO_ADDR
14027: GO 14346
14029: LD_INT 42
14031: DOUBLE
14032: EQUAL
14033: IFTRUE 14037
14035: GO 14063
14037: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14038: LD_ADDR_VAR 0 3
14042: PUSH
14043: LD_INT 21
14045: PUSH
14046: LD_INT 22
14048: PUSH
14049: LD_INT 23
14051: PUSH
14052: LD_INT 24
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: ST_TO_ADDR
14061: GO 14346
14063: LD_INT 43
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14097
14071: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14072: LD_ADDR_VAR 0 3
14076: PUSH
14077: LD_INT 21
14079: PUSH
14080: LD_INT 22
14082: PUSH
14083: LD_INT 23
14085: PUSH
14086: LD_INT 24
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: ST_TO_ADDR
14095: GO 14346
14097: LD_INT 44
14099: DOUBLE
14100: EQUAL
14101: IFTRUE 14105
14103: GO 14131
14105: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_INT 21
14113: PUSH
14114: LD_INT 22
14116: PUSH
14117: LD_INT 23
14119: PUSH
14120: LD_INT 24
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: ST_TO_ADDR
14129: GO 14346
14131: LD_INT 45
14133: DOUBLE
14134: EQUAL
14135: IFTRUE 14139
14137: GO 14165
14139: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14140: LD_ADDR_VAR 0 3
14144: PUSH
14145: LD_INT 21
14147: PUSH
14148: LD_INT 22
14150: PUSH
14151: LD_INT 23
14153: PUSH
14154: LD_INT 24
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: ST_TO_ADDR
14163: GO 14346
14165: LD_INT 49
14167: DOUBLE
14168: EQUAL
14169: IFTRUE 14173
14171: GO 14199
14173: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14174: LD_ADDR_VAR 0 3
14178: PUSH
14179: LD_INT 21
14181: PUSH
14182: LD_INT 22
14184: PUSH
14185: LD_INT 23
14187: PUSH
14188: LD_INT 24
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: ST_TO_ADDR
14197: GO 14346
14199: LD_INT 51
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14233
14207: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14208: LD_ADDR_VAR 0 3
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 22
14218: PUSH
14219: LD_INT 23
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14346
14233: LD_INT 52
14235: DOUBLE
14236: EQUAL
14237: IFTRUE 14241
14239: GO 14267
14241: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14242: LD_ADDR_VAR 0 3
14246: PUSH
14247: LD_INT 21
14249: PUSH
14250: LD_INT 22
14252: PUSH
14253: LD_INT 23
14255: PUSH
14256: LD_INT 24
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: ST_TO_ADDR
14265: GO 14346
14267: LD_INT 53
14269: DOUBLE
14270: EQUAL
14271: IFTRUE 14275
14273: GO 14293
14275: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14276: LD_ADDR_VAR 0 3
14280: PUSH
14281: LD_INT 23
14283: PUSH
14284: LD_INT 24
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: ST_TO_ADDR
14291: GO 14346
14293: LD_INT 46
14295: DOUBLE
14296: EQUAL
14297: IFTRUE 14301
14299: GO 14319
14301: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14302: LD_ADDR_VAR 0 3
14306: PUSH
14307: LD_INT 23
14309: PUSH
14310: LD_INT 24
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: ST_TO_ADDR
14317: GO 14346
14319: LD_INT 47
14321: DOUBLE
14322: EQUAL
14323: IFTRUE 14327
14325: GO 14345
14327: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14328: LD_ADDR_VAR 0 3
14332: PUSH
14333: LD_INT 23
14335: PUSH
14336: LD_INT 24
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: ST_TO_ADDR
14343: GO 14346
14345: POP
// result := ( chassis in result ) ;
14346: LD_ADDR_VAR 0 3
14350: PUSH
14351: LD_VAR 0 1
14355: PUSH
14356: LD_VAR 0 3
14360: IN
14361: ST_TO_ADDR
// end ;
14362: LD_VAR 0 3
14366: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14367: LD_INT 0
14369: PPUSH
14370: PPUSH
14371: PPUSH
14372: PPUSH
14373: PPUSH
14374: PPUSH
14375: PPUSH
// result := array ;
14376: LD_ADDR_VAR 0 5
14380: PUSH
14381: LD_VAR 0 1
14385: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14386: LD_VAR 0 1
14390: NOT
14391: PUSH
14392: LD_VAR 0 2
14396: NOT
14397: OR
14398: PUSH
14399: LD_VAR 0 3
14403: NOT
14404: OR
14405: PUSH
14406: LD_VAR 0 2
14410: PUSH
14411: LD_VAR 0 1
14415: GREATER
14416: OR
14417: PUSH
14418: LD_VAR 0 3
14422: PUSH
14423: LD_VAR 0 1
14427: GREATER
14428: OR
14429: IFFALSE 14433
// exit ;
14431: GO 14729
// if direction then
14433: LD_VAR 0 4
14437: IFFALSE 14501
// begin d := 1 ;
14439: LD_ADDR_VAR 0 9
14443: PUSH
14444: LD_INT 1
14446: ST_TO_ADDR
// if i_from > i_to then
14447: LD_VAR 0 2
14451: PUSH
14452: LD_VAR 0 3
14456: GREATER
14457: IFFALSE 14483
// length := ( array - i_from ) + i_to else
14459: LD_ADDR_VAR 0 11
14463: PUSH
14464: LD_VAR 0 1
14468: PUSH
14469: LD_VAR 0 2
14473: MINUS
14474: PUSH
14475: LD_VAR 0 3
14479: PLUS
14480: ST_TO_ADDR
14481: GO 14499
// length := i_to - i_from ;
14483: LD_ADDR_VAR 0 11
14487: PUSH
14488: LD_VAR 0 3
14492: PUSH
14493: LD_VAR 0 2
14497: MINUS
14498: ST_TO_ADDR
// end else
14499: GO 14562
// begin d := - 1 ;
14501: LD_ADDR_VAR 0 9
14505: PUSH
14506: LD_INT 1
14508: NEG
14509: ST_TO_ADDR
// if i_from > i_to then
14510: LD_VAR 0 2
14514: PUSH
14515: LD_VAR 0 3
14519: GREATER
14520: IFFALSE 14540
// length := i_from - i_to else
14522: LD_ADDR_VAR 0 11
14526: PUSH
14527: LD_VAR 0 2
14531: PUSH
14532: LD_VAR 0 3
14536: MINUS
14537: ST_TO_ADDR
14538: GO 14562
// length := ( array - i_to ) + i_from ;
14540: LD_ADDR_VAR 0 11
14544: PUSH
14545: LD_VAR 0 1
14549: PUSH
14550: LD_VAR 0 3
14554: MINUS
14555: PUSH
14556: LD_VAR 0 2
14560: PLUS
14561: ST_TO_ADDR
// end ; if not length then
14562: LD_VAR 0 11
14566: NOT
14567: IFFALSE 14571
// exit ;
14569: GO 14729
// tmp := array ;
14571: LD_ADDR_VAR 0 10
14575: PUSH
14576: LD_VAR 0 1
14580: ST_TO_ADDR
// for i = 1 to length do
14581: LD_ADDR_VAR 0 6
14585: PUSH
14586: DOUBLE
14587: LD_INT 1
14589: DEC
14590: ST_TO_ADDR
14591: LD_VAR 0 11
14595: PUSH
14596: FOR_TO
14597: IFFALSE 14717
// begin for j = 1 to array do
14599: LD_ADDR_VAR 0 7
14603: PUSH
14604: DOUBLE
14605: LD_INT 1
14607: DEC
14608: ST_TO_ADDR
14609: LD_VAR 0 1
14613: PUSH
14614: FOR_TO
14615: IFFALSE 14703
// begin k := j + d ;
14617: LD_ADDR_VAR 0 8
14621: PUSH
14622: LD_VAR 0 7
14626: PUSH
14627: LD_VAR 0 9
14631: PLUS
14632: ST_TO_ADDR
// if k > array then
14633: LD_VAR 0 8
14637: PUSH
14638: LD_VAR 0 1
14642: GREATER
14643: IFFALSE 14653
// k := 1 ;
14645: LD_ADDR_VAR 0 8
14649: PUSH
14650: LD_INT 1
14652: ST_TO_ADDR
// if not k then
14653: LD_VAR 0 8
14657: NOT
14658: IFFALSE 14670
// k := array ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_VAR 0 1
14669: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14670: LD_ADDR_VAR 0 10
14674: PUSH
14675: LD_VAR 0 10
14679: PPUSH
14680: LD_VAR 0 8
14684: PPUSH
14685: LD_VAR 0 1
14689: PUSH
14690: LD_VAR 0 7
14694: ARRAY
14695: PPUSH
14696: CALL_OW 1
14700: ST_TO_ADDR
// end ;
14701: GO 14614
14703: POP
14704: POP
// array := tmp ;
14705: LD_ADDR_VAR 0 1
14709: PUSH
14710: LD_VAR 0 10
14714: ST_TO_ADDR
// end ;
14715: GO 14596
14717: POP
14718: POP
// result := array ;
14719: LD_ADDR_VAR 0 5
14723: PUSH
14724: LD_VAR 0 1
14728: ST_TO_ADDR
// end ;
14729: LD_VAR 0 5
14733: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14734: LD_INT 0
14736: PPUSH
14737: PPUSH
// result := 0 ;
14738: LD_ADDR_VAR 0 3
14742: PUSH
14743: LD_INT 0
14745: ST_TO_ADDR
// if not array or not value in array then
14746: LD_VAR 0 1
14750: NOT
14751: PUSH
14752: LD_VAR 0 2
14756: PUSH
14757: LD_VAR 0 1
14761: IN
14762: NOT
14763: OR
14764: IFFALSE 14768
// exit ;
14766: GO 14822
// for i = 1 to array do
14768: LD_ADDR_VAR 0 4
14772: PUSH
14773: DOUBLE
14774: LD_INT 1
14776: DEC
14777: ST_TO_ADDR
14778: LD_VAR 0 1
14782: PUSH
14783: FOR_TO
14784: IFFALSE 14820
// if value = array [ i ] then
14786: LD_VAR 0 2
14790: PUSH
14791: LD_VAR 0 1
14795: PUSH
14796: LD_VAR 0 4
14800: ARRAY
14801: EQUAL
14802: IFFALSE 14818
// begin result := i ;
14804: LD_ADDR_VAR 0 3
14808: PUSH
14809: LD_VAR 0 4
14813: ST_TO_ADDR
// exit ;
14814: POP
14815: POP
14816: GO 14822
// end ;
14818: GO 14783
14820: POP
14821: POP
// end ;
14822: LD_VAR 0 3
14826: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14827: LD_INT 0
14829: PPUSH
// vc_chassis := chassis ;
14830: LD_ADDR_OWVAR 37
14834: PUSH
14835: LD_VAR 0 1
14839: ST_TO_ADDR
// vc_engine := engine ;
14840: LD_ADDR_OWVAR 39
14844: PUSH
14845: LD_VAR 0 2
14849: ST_TO_ADDR
// vc_control := control ;
14850: LD_ADDR_OWVAR 38
14854: PUSH
14855: LD_VAR 0 3
14859: ST_TO_ADDR
// vc_weapon := weapon ;
14860: LD_ADDR_OWVAR 40
14864: PUSH
14865: LD_VAR 0 4
14869: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14870: LD_ADDR_OWVAR 41
14874: PUSH
14875: LD_VAR 0 5
14879: ST_TO_ADDR
// end ;
14880: LD_VAR 0 6
14884: RET
// export function WantPlant ( unit ) ; var task ; begin
14885: LD_INT 0
14887: PPUSH
14888: PPUSH
// result := false ;
14889: LD_ADDR_VAR 0 2
14893: PUSH
14894: LD_INT 0
14896: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14897: LD_ADDR_VAR 0 3
14901: PUSH
14902: LD_VAR 0 1
14906: PPUSH
14907: CALL_OW 437
14911: ST_TO_ADDR
// if task then
14912: LD_VAR 0 3
14916: IFFALSE 14944
// if task [ 1 ] [ 1 ] = p then
14918: LD_VAR 0 3
14922: PUSH
14923: LD_INT 1
14925: ARRAY
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: PUSH
14931: LD_STRING p
14933: EQUAL
14934: IFFALSE 14944
// result := true ;
14936: LD_ADDR_VAR 0 2
14940: PUSH
14941: LD_INT 1
14943: ST_TO_ADDR
// end ;
14944: LD_VAR 0 2
14948: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14949: LD_INT 0
14951: PPUSH
14952: PPUSH
14953: PPUSH
14954: PPUSH
// if pos < 1 then
14955: LD_VAR 0 2
14959: PUSH
14960: LD_INT 1
14962: LESS
14963: IFFALSE 14967
// exit ;
14965: GO 15270
// if pos = 1 then
14967: LD_VAR 0 2
14971: PUSH
14972: LD_INT 1
14974: EQUAL
14975: IFFALSE 15008
// result := Replace ( arr , pos [ 1 ] , value ) else
14977: LD_ADDR_VAR 0 4
14981: PUSH
14982: LD_VAR 0 1
14986: PPUSH
14987: LD_VAR 0 2
14991: PUSH
14992: LD_INT 1
14994: ARRAY
14995: PPUSH
14996: LD_VAR 0 3
15000: PPUSH
15001: CALL_OW 1
15005: ST_TO_ADDR
15006: GO 15270
// begin tmp := arr ;
15008: LD_ADDR_VAR 0 6
15012: PUSH
15013: LD_VAR 0 1
15017: ST_TO_ADDR
// s_arr := [ tmp ] ;
15018: LD_ADDR_VAR 0 7
15022: PUSH
15023: LD_VAR 0 6
15027: PUSH
15028: EMPTY
15029: LIST
15030: ST_TO_ADDR
// for i = 1 to pos - 1 do
15031: LD_ADDR_VAR 0 5
15035: PUSH
15036: DOUBLE
15037: LD_INT 1
15039: DEC
15040: ST_TO_ADDR
15041: LD_VAR 0 2
15045: PUSH
15046: LD_INT 1
15048: MINUS
15049: PUSH
15050: FOR_TO
15051: IFFALSE 15096
// begin tmp := tmp [ pos [ i ] ] ;
15053: LD_ADDR_VAR 0 6
15057: PUSH
15058: LD_VAR 0 6
15062: PUSH
15063: LD_VAR 0 2
15067: PUSH
15068: LD_VAR 0 5
15072: ARRAY
15073: ARRAY
15074: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15075: LD_ADDR_VAR 0 7
15079: PUSH
15080: LD_VAR 0 7
15084: PUSH
15085: LD_VAR 0 6
15089: PUSH
15090: EMPTY
15091: LIST
15092: ADD
15093: ST_TO_ADDR
// end ;
15094: GO 15050
15096: POP
15097: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15098: LD_ADDR_VAR 0 6
15102: PUSH
15103: LD_VAR 0 6
15107: PPUSH
15108: LD_VAR 0 2
15112: PUSH
15113: LD_VAR 0 2
15117: ARRAY
15118: PPUSH
15119: LD_VAR 0 3
15123: PPUSH
15124: CALL_OW 1
15128: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15129: LD_ADDR_VAR 0 7
15133: PUSH
15134: LD_VAR 0 7
15138: PPUSH
15139: LD_VAR 0 7
15143: PPUSH
15144: LD_VAR 0 6
15148: PPUSH
15149: CALL_OW 1
15153: ST_TO_ADDR
// for i = s_arr downto 2 do
15154: LD_ADDR_VAR 0 5
15158: PUSH
15159: DOUBLE
15160: LD_VAR 0 7
15164: INC
15165: ST_TO_ADDR
15166: LD_INT 2
15168: PUSH
15169: FOR_DOWNTO
15170: IFFALSE 15254
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15172: LD_ADDR_VAR 0 6
15176: PUSH
15177: LD_VAR 0 7
15181: PUSH
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 1
15189: MINUS
15190: ARRAY
15191: PPUSH
15192: LD_VAR 0 2
15196: PUSH
15197: LD_VAR 0 5
15201: PUSH
15202: LD_INT 1
15204: MINUS
15205: ARRAY
15206: PPUSH
15207: LD_VAR 0 7
15211: PUSH
15212: LD_VAR 0 5
15216: ARRAY
15217: PPUSH
15218: CALL_OW 1
15222: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15223: LD_ADDR_VAR 0 7
15227: PUSH
15228: LD_VAR 0 7
15232: PPUSH
15233: LD_VAR 0 5
15237: PUSH
15238: LD_INT 1
15240: MINUS
15241: PPUSH
15242: LD_VAR 0 6
15246: PPUSH
15247: CALL_OW 1
15251: ST_TO_ADDR
// end ;
15252: GO 15169
15254: POP
15255: POP
// result := s_arr [ 1 ] ;
15256: LD_ADDR_VAR 0 4
15260: PUSH
15261: LD_VAR 0 7
15265: PUSH
15266: LD_INT 1
15268: ARRAY
15269: ST_TO_ADDR
// end ; end ;
15270: LD_VAR 0 4
15274: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15275: LD_INT 0
15277: PPUSH
15278: PPUSH
// if not list then
15279: LD_VAR 0 1
15283: NOT
15284: IFFALSE 15288
// exit ;
15286: GO 15379
// i := list [ pos1 ] ;
15288: LD_ADDR_VAR 0 5
15292: PUSH
15293: LD_VAR 0 1
15297: PUSH
15298: LD_VAR 0 2
15302: ARRAY
15303: ST_TO_ADDR
// if not i then
15304: LD_VAR 0 5
15308: NOT
15309: IFFALSE 15313
// exit ;
15311: GO 15379
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15313: LD_ADDR_VAR 0 1
15317: PUSH
15318: LD_VAR 0 1
15322: PPUSH
15323: LD_VAR 0 2
15327: PPUSH
15328: LD_VAR 0 1
15332: PUSH
15333: LD_VAR 0 3
15337: ARRAY
15338: PPUSH
15339: CALL_OW 1
15343: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15344: LD_ADDR_VAR 0 1
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: LD_VAR 0 3
15358: PPUSH
15359: LD_VAR 0 5
15363: PPUSH
15364: CALL_OW 1
15368: ST_TO_ADDR
// result := list ;
15369: LD_ADDR_VAR 0 4
15373: PUSH
15374: LD_VAR 0 1
15378: ST_TO_ADDR
// end ;
15379: LD_VAR 0 4
15383: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15384: LD_INT 0
15386: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15387: LD_ADDR_VAR 0 5
15391: PUSH
15392: LD_VAR 0 1
15396: PPUSH
15397: CALL_OW 250
15401: PPUSH
15402: LD_VAR 0 1
15406: PPUSH
15407: CALL_OW 251
15411: PPUSH
15412: LD_VAR 0 2
15416: PPUSH
15417: LD_VAR 0 3
15421: PPUSH
15422: LD_VAR 0 4
15426: PPUSH
15427: CALL 15437 0 5
15431: ST_TO_ADDR
// end ;
15432: LD_VAR 0 5
15436: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15437: LD_INT 0
15439: PPUSH
15440: PPUSH
15441: PPUSH
15442: PPUSH
// if not list then
15443: LD_VAR 0 3
15447: NOT
15448: IFFALSE 15452
// exit ;
15450: GO 15840
// result := [ ] ;
15452: LD_ADDR_VAR 0 6
15456: PUSH
15457: EMPTY
15458: ST_TO_ADDR
// for i in list do
15459: LD_ADDR_VAR 0 7
15463: PUSH
15464: LD_VAR 0 3
15468: PUSH
15469: FOR_IN
15470: IFFALSE 15672
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15472: LD_ADDR_VAR 0 9
15476: PUSH
15477: LD_VAR 0 7
15481: PPUSH
15482: LD_VAR 0 1
15486: PPUSH
15487: LD_VAR 0 2
15491: PPUSH
15492: CALL_OW 297
15496: ST_TO_ADDR
// if not result then
15497: LD_VAR 0 6
15501: NOT
15502: IFFALSE 15528
// result := [ [ i , tmp ] ] else
15504: LD_ADDR_VAR 0 6
15508: PUSH
15509: LD_VAR 0 7
15513: PUSH
15514: LD_VAR 0 9
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: PUSH
15523: EMPTY
15524: LIST
15525: ST_TO_ADDR
15526: GO 15670
// begin if result [ result ] [ 2 ] < tmp then
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 6
15537: ARRAY
15538: PUSH
15539: LD_INT 2
15541: ARRAY
15542: PUSH
15543: LD_VAR 0 9
15547: LESS
15548: IFFALSE 15590
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15550: LD_ADDR_VAR 0 6
15554: PUSH
15555: LD_VAR 0 6
15559: PPUSH
15560: LD_VAR 0 6
15564: PUSH
15565: LD_INT 1
15567: PLUS
15568: PPUSH
15569: LD_VAR 0 7
15573: PUSH
15574: LD_VAR 0 9
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PPUSH
15583: CALL_OW 2
15587: ST_TO_ADDR
15588: GO 15670
// for j = 1 to result do
15590: LD_ADDR_VAR 0 8
15594: PUSH
15595: DOUBLE
15596: LD_INT 1
15598: DEC
15599: ST_TO_ADDR
15600: LD_VAR 0 6
15604: PUSH
15605: FOR_TO
15606: IFFALSE 15668
// begin if tmp < result [ j ] [ 2 ] then
15608: LD_VAR 0 9
15612: PUSH
15613: LD_VAR 0 6
15617: PUSH
15618: LD_VAR 0 8
15622: ARRAY
15623: PUSH
15624: LD_INT 2
15626: ARRAY
15627: LESS
15628: IFFALSE 15666
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15630: LD_ADDR_VAR 0 6
15634: PUSH
15635: LD_VAR 0 6
15639: PPUSH
15640: LD_VAR 0 8
15644: PPUSH
15645: LD_VAR 0 7
15649: PUSH
15650: LD_VAR 0 9
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 2
15663: ST_TO_ADDR
// break ;
15664: GO 15668
// end ; end ;
15666: GO 15605
15668: POP
15669: POP
// end ; end ;
15670: GO 15469
15672: POP
15673: POP
// if result and not asc then
15674: LD_VAR 0 6
15678: PUSH
15679: LD_VAR 0 4
15683: NOT
15684: AND
15685: IFFALSE 15760
// begin tmp := result ;
15687: LD_ADDR_VAR 0 9
15691: PUSH
15692: LD_VAR 0 6
15696: ST_TO_ADDR
// for i = tmp downto 1 do
15697: LD_ADDR_VAR 0 7
15701: PUSH
15702: DOUBLE
15703: LD_VAR 0 9
15707: INC
15708: ST_TO_ADDR
15709: LD_INT 1
15711: PUSH
15712: FOR_DOWNTO
15713: IFFALSE 15758
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15715: LD_ADDR_VAR 0 6
15719: PUSH
15720: LD_VAR 0 6
15724: PPUSH
15725: LD_VAR 0 9
15729: PUSH
15730: LD_VAR 0 7
15734: MINUS
15735: PUSH
15736: LD_INT 1
15738: PLUS
15739: PPUSH
15740: LD_VAR 0 9
15744: PUSH
15745: LD_VAR 0 7
15749: ARRAY
15750: PPUSH
15751: CALL_OW 1
15755: ST_TO_ADDR
15756: GO 15712
15758: POP
15759: POP
// end ; tmp := [ ] ;
15760: LD_ADDR_VAR 0 9
15764: PUSH
15765: EMPTY
15766: ST_TO_ADDR
// if mode then
15767: LD_VAR 0 5
15771: IFFALSE 15840
// begin for i = 1 to result do
15773: LD_ADDR_VAR 0 7
15777: PUSH
15778: DOUBLE
15779: LD_INT 1
15781: DEC
15782: ST_TO_ADDR
15783: LD_VAR 0 6
15787: PUSH
15788: FOR_TO
15789: IFFALSE 15828
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15791: LD_ADDR_VAR 0 9
15795: PUSH
15796: LD_VAR 0 9
15800: PPUSH
15801: LD_VAR 0 7
15805: PPUSH
15806: LD_VAR 0 6
15810: PUSH
15811: LD_VAR 0 7
15815: ARRAY
15816: PUSH
15817: LD_INT 1
15819: ARRAY
15820: PPUSH
15821: CALL_OW 1
15825: ST_TO_ADDR
15826: GO 15788
15828: POP
15829: POP
// result := tmp ;
15830: LD_ADDR_VAR 0 6
15834: PUSH
15835: LD_VAR 0 9
15839: ST_TO_ADDR
// end ; end ;
15840: LD_VAR 0 6
15844: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15845: LD_INT 0
15847: PPUSH
15848: PPUSH
15849: PPUSH
15850: PPUSH
15851: PPUSH
15852: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15853: LD_ADDR_VAR 0 5
15857: PUSH
15858: LD_INT 0
15860: PUSH
15861: LD_INT 0
15863: PUSH
15864: LD_INT 0
15866: PUSH
15867: EMPTY
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: LIST
15873: LIST
15874: ST_TO_ADDR
// if not x or not y then
15875: LD_VAR 0 2
15879: NOT
15880: PUSH
15881: LD_VAR 0 3
15885: NOT
15886: OR
15887: IFFALSE 15891
// exit ;
15889: GO 17541
// if not range then
15891: LD_VAR 0 4
15895: NOT
15896: IFFALSE 15906
// range := 10 ;
15898: LD_ADDR_VAR 0 4
15902: PUSH
15903: LD_INT 10
15905: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15906: LD_ADDR_VAR 0 8
15910: PUSH
15911: LD_INT 81
15913: PUSH
15914: LD_VAR 0 1
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: PUSH
15923: LD_INT 92
15925: PUSH
15926: LD_VAR 0 2
15930: PUSH
15931: LD_VAR 0 3
15935: PUSH
15936: LD_VAR 0 4
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_INT 3
15949: PUSH
15950: LD_INT 21
15952: PUSH
15953: LD_INT 3
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: PPUSH
15969: CALL_OW 69
15973: ST_TO_ADDR
// if not tmp then
15974: LD_VAR 0 8
15978: NOT
15979: IFFALSE 15983
// exit ;
15981: GO 17541
// for i in tmp do
15983: LD_ADDR_VAR 0 6
15987: PUSH
15988: LD_VAR 0 8
15992: PUSH
15993: FOR_IN
15994: IFFALSE 17516
// begin points := [ 0 , 0 , 0 ] ;
15996: LD_ADDR_VAR 0 9
16000: PUSH
16001: LD_INT 0
16003: PUSH
16004: LD_INT 0
16006: PUSH
16007: LD_INT 0
16009: PUSH
16010: EMPTY
16011: LIST
16012: LIST
16013: LIST
16014: ST_TO_ADDR
// bpoints := 1 ;
16015: LD_ADDR_VAR 0 10
16019: PUSH
16020: LD_INT 1
16022: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16023: LD_VAR 0 6
16027: PPUSH
16028: CALL_OW 247
16032: PUSH
16033: LD_INT 1
16035: DOUBLE
16036: EQUAL
16037: IFTRUE 16041
16039: GO 16619
16041: POP
// begin if GetClass ( i ) = 1 then
16042: LD_VAR 0 6
16046: PPUSH
16047: CALL_OW 257
16051: PUSH
16052: LD_INT 1
16054: EQUAL
16055: IFFALSE 16076
// points := [ 10 , 5 , 3 ] ;
16057: LD_ADDR_VAR 0 9
16061: PUSH
16062: LD_INT 10
16064: PUSH
16065: LD_INT 5
16067: PUSH
16068: LD_INT 3
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: LIST
16075: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16076: LD_VAR 0 6
16080: PPUSH
16081: CALL_OW 257
16085: PUSH
16086: LD_INT 2
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: LD_INT 4
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: LIST
16099: IN
16100: IFFALSE 16121
// points := [ 3 , 2 , 1 ] ;
16102: LD_ADDR_VAR 0 9
16106: PUSH
16107: LD_INT 3
16109: PUSH
16110: LD_INT 2
16112: PUSH
16113: LD_INT 1
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: LIST
16120: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16121: LD_VAR 0 6
16125: PPUSH
16126: CALL_OW 257
16130: PUSH
16131: LD_INT 5
16133: EQUAL
16134: IFFALSE 16155
// points := [ 130 , 5 , 2 ] ;
16136: LD_ADDR_VAR 0 9
16140: PUSH
16141: LD_INT 130
16143: PUSH
16144: LD_INT 5
16146: PUSH
16147: LD_INT 2
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 257
16164: PUSH
16165: LD_INT 8
16167: EQUAL
16168: IFFALSE 16189
// points := [ 35 , 35 , 30 ] ;
16170: LD_ADDR_VAR 0 9
16174: PUSH
16175: LD_INT 35
16177: PUSH
16178: LD_INT 35
16180: PUSH
16181: LD_INT 30
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL_OW 257
16198: PUSH
16199: LD_INT 9
16201: EQUAL
16202: IFFALSE 16223
// points := [ 20 , 55 , 40 ] ;
16204: LD_ADDR_VAR 0 9
16208: PUSH
16209: LD_INT 20
16211: PUSH
16212: LD_INT 55
16214: PUSH
16215: LD_INT 40
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: LIST
16222: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16223: LD_VAR 0 6
16227: PPUSH
16228: CALL_OW 257
16232: PUSH
16233: LD_INT 12
16235: PUSH
16236: LD_INT 16
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: IN
16243: IFFALSE 16264
// points := [ 5 , 3 , 2 ] ;
16245: LD_ADDR_VAR 0 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 3
16255: PUSH
16256: LD_INT 2
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: LIST
16263: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16264: LD_VAR 0 6
16268: PPUSH
16269: CALL_OW 257
16273: PUSH
16274: LD_INT 17
16276: EQUAL
16277: IFFALSE 16298
// points := [ 100 , 50 , 75 ] ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_INT 100
16286: PUSH
16287: LD_INT 50
16289: PUSH
16290: LD_INT 75
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: LIST
16297: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16298: LD_VAR 0 6
16302: PPUSH
16303: CALL_OW 257
16307: PUSH
16308: LD_INT 15
16310: EQUAL
16311: IFFALSE 16332
// points := [ 10 , 5 , 3 ] ;
16313: LD_ADDR_VAR 0 9
16317: PUSH
16318: LD_INT 10
16320: PUSH
16321: LD_INT 5
16323: PUSH
16324: LD_INT 3
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: LIST
16331: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16332: LD_VAR 0 6
16336: PPUSH
16337: CALL_OW 257
16341: PUSH
16342: LD_INT 14
16344: EQUAL
16345: IFFALSE 16366
// points := [ 10 , 0 , 0 ] ;
16347: LD_ADDR_VAR 0 9
16351: PUSH
16352: LD_INT 10
16354: PUSH
16355: LD_INT 0
16357: PUSH
16358: LD_INT 0
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: LIST
16365: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16366: LD_VAR 0 6
16370: PPUSH
16371: CALL_OW 257
16375: PUSH
16376: LD_INT 11
16378: EQUAL
16379: IFFALSE 16400
// points := [ 30 , 10 , 5 ] ;
16381: LD_ADDR_VAR 0 9
16385: PUSH
16386: LD_INT 30
16388: PUSH
16389: LD_INT 10
16391: PUSH
16392: LD_INT 5
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: LIST
16399: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 5
16407: PPUSH
16408: CALL_OW 321
16412: PUSH
16413: LD_INT 2
16415: EQUAL
16416: IFFALSE 16433
// bpoints := bpoints * 1.8 ;
16418: LD_ADDR_VAR 0 10
16422: PUSH
16423: LD_VAR 0 10
16427: PUSH
16428: LD_REAL  1.80000000000000E+0000
16431: MUL
16432: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16433: LD_VAR 0 6
16437: PPUSH
16438: CALL_OW 257
16442: PUSH
16443: LD_INT 1
16445: PUSH
16446: LD_INT 2
16448: PUSH
16449: LD_INT 3
16451: PUSH
16452: LD_INT 4
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: LIST
16459: LIST
16460: IN
16461: PUSH
16462: LD_VAR 0 1
16466: PPUSH
16467: LD_INT 51
16469: PPUSH
16470: CALL_OW 321
16474: PUSH
16475: LD_INT 2
16477: EQUAL
16478: AND
16479: IFFALSE 16496
// bpoints := bpoints * 1.2 ;
16481: LD_ADDR_VAR 0 10
16485: PUSH
16486: LD_VAR 0 10
16490: PUSH
16491: LD_REAL  1.20000000000000E+0000
16494: MUL
16495: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16496: LD_VAR 0 6
16500: PPUSH
16501: CALL_OW 257
16505: PUSH
16506: LD_INT 5
16508: PUSH
16509: LD_INT 7
16511: PUSH
16512: LD_INT 9
16514: PUSH
16515: EMPTY
16516: LIST
16517: LIST
16518: LIST
16519: IN
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: LD_INT 52
16528: PPUSH
16529: CALL_OW 321
16533: PUSH
16534: LD_INT 2
16536: EQUAL
16537: AND
16538: IFFALSE 16555
// bpoints := bpoints * 1.5 ;
16540: LD_ADDR_VAR 0 10
16544: PUSH
16545: LD_VAR 0 10
16549: PUSH
16550: LD_REAL  1.50000000000000E+0000
16553: MUL
16554: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16555: LD_VAR 0 1
16559: PPUSH
16560: LD_INT 66
16562: PPUSH
16563: CALL_OW 321
16567: PUSH
16568: LD_INT 2
16570: EQUAL
16571: IFFALSE 16588
// bpoints := bpoints * 1.1 ;
16573: LD_ADDR_VAR 0 10
16577: PUSH
16578: LD_VAR 0 10
16582: PUSH
16583: LD_REAL  1.10000000000000E+0000
16586: MUL
16587: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16588: LD_ADDR_VAR 0 10
16592: PUSH
16593: LD_VAR 0 10
16597: PUSH
16598: LD_VAR 0 6
16602: PPUSH
16603: LD_INT 1
16605: PPUSH
16606: CALL_OW 259
16610: PUSH
16611: LD_REAL  1.15000000000000E+0000
16614: MUL
16615: MUL
16616: ST_TO_ADDR
// end ; unit_vehicle :
16617: GO 17445
16619: LD_INT 2
16621: DOUBLE
16622: EQUAL
16623: IFTRUE 16627
16625: GO 17433
16627: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16628: LD_VAR 0 6
16632: PPUSH
16633: CALL_OW 264
16637: PUSH
16638: LD_INT 2
16640: PUSH
16641: LD_INT 42
16643: PUSH
16644: LD_INT 24
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: IN
16652: IFFALSE 16673
// points := [ 25 , 5 , 3 ] ;
16654: LD_ADDR_VAR 0 9
16658: PUSH
16659: LD_INT 25
16661: PUSH
16662: LD_INT 5
16664: PUSH
16665: LD_INT 3
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16673: LD_VAR 0 6
16677: PPUSH
16678: CALL_OW 264
16682: PUSH
16683: LD_INT 4
16685: PUSH
16686: LD_INT 43
16688: PUSH
16689: LD_INT 25
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: LIST
16696: IN
16697: IFFALSE 16718
// points := [ 40 , 15 , 5 ] ;
16699: LD_ADDR_VAR 0 9
16703: PUSH
16704: LD_INT 40
16706: PUSH
16707: LD_INT 15
16709: PUSH
16710: LD_INT 5
16712: PUSH
16713: EMPTY
16714: LIST
16715: LIST
16716: LIST
16717: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16718: LD_VAR 0 6
16722: PPUSH
16723: CALL_OW 264
16727: PUSH
16728: LD_INT 3
16730: PUSH
16731: LD_INT 23
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: IN
16738: IFFALSE 16759
// points := [ 7 , 25 , 8 ] ;
16740: LD_ADDR_VAR 0 9
16744: PUSH
16745: LD_INT 7
16747: PUSH
16748: LD_INT 25
16750: PUSH
16751: LD_INT 8
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: LIST
16758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16759: LD_VAR 0 6
16763: PPUSH
16764: CALL_OW 264
16768: PUSH
16769: LD_INT 5
16771: PUSH
16772: LD_INT 27
16774: PUSH
16775: LD_INT 44
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: IN
16783: IFFALSE 16804
// points := [ 14 , 50 , 16 ] ;
16785: LD_ADDR_VAR 0 9
16789: PUSH
16790: LD_INT 14
16792: PUSH
16793: LD_INT 50
16795: PUSH
16796: LD_INT 16
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16804: LD_VAR 0 6
16808: PPUSH
16809: CALL_OW 264
16813: PUSH
16814: LD_INT 6
16816: PUSH
16817: LD_INT 46
16819: PUSH
16820: EMPTY
16821: LIST
16822: LIST
16823: IN
16824: IFFALSE 16845
// points := [ 32 , 120 , 70 ] ;
16826: LD_ADDR_VAR 0 9
16830: PUSH
16831: LD_INT 32
16833: PUSH
16834: LD_INT 120
16836: PUSH
16837: LD_INT 70
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16845: LD_VAR 0 6
16849: PPUSH
16850: CALL_OW 264
16854: PUSH
16855: LD_INT 7
16857: PUSH
16858: LD_INT 28
16860: PUSH
16861: LD_INT 45
16863: PUSH
16864: LD_INT 92
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: LIST
16872: IN
16873: IFFALSE 16894
// points := [ 35 , 20 , 45 ] ;
16875: LD_ADDR_VAR 0 9
16879: PUSH
16880: LD_INT 35
16882: PUSH
16883: LD_INT 20
16885: PUSH
16886: LD_INT 45
16888: PUSH
16889: EMPTY
16890: LIST
16891: LIST
16892: LIST
16893: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16894: LD_VAR 0 6
16898: PPUSH
16899: CALL_OW 264
16903: PUSH
16904: LD_INT 47
16906: PUSH
16907: EMPTY
16908: LIST
16909: IN
16910: IFFALSE 16931
// points := [ 67 , 45 , 75 ] ;
16912: LD_ADDR_VAR 0 9
16916: PUSH
16917: LD_INT 67
16919: PUSH
16920: LD_INT 45
16922: PUSH
16923: LD_INT 75
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: LIST
16930: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16931: LD_VAR 0 6
16935: PPUSH
16936: CALL_OW 264
16940: PUSH
16941: LD_INT 26
16943: PUSH
16944: EMPTY
16945: LIST
16946: IN
16947: IFFALSE 16968
// points := [ 120 , 30 , 80 ] ;
16949: LD_ADDR_VAR 0 9
16953: PUSH
16954: LD_INT 120
16956: PUSH
16957: LD_INT 30
16959: PUSH
16960: LD_INT 80
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: LIST
16967: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16968: LD_VAR 0 6
16972: PPUSH
16973: CALL_OW 264
16977: PUSH
16978: LD_INT 22
16980: PUSH
16981: EMPTY
16982: LIST
16983: IN
16984: IFFALSE 17005
// points := [ 40 , 1 , 1 ] ;
16986: LD_ADDR_VAR 0 9
16990: PUSH
16991: LD_INT 40
16993: PUSH
16994: LD_INT 1
16996: PUSH
16997: LD_INT 1
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: LIST
17004: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17005: LD_VAR 0 6
17009: PPUSH
17010: CALL_OW 264
17014: PUSH
17015: LD_INT 29
17017: PUSH
17018: EMPTY
17019: LIST
17020: IN
17021: IFFALSE 17042
// points := [ 70 , 200 , 400 ] ;
17023: LD_ADDR_VAR 0 9
17027: PUSH
17028: LD_INT 70
17030: PUSH
17031: LD_INT 200
17033: PUSH
17034: LD_INT 400
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: LIST
17041: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17042: LD_VAR 0 6
17046: PPUSH
17047: CALL_OW 264
17051: PUSH
17052: LD_INT 14
17054: PUSH
17055: LD_INT 53
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: IN
17062: IFFALSE 17083
// points := [ 40 , 10 , 20 ] ;
17064: LD_ADDR_VAR 0 9
17068: PUSH
17069: LD_INT 40
17071: PUSH
17072: LD_INT 10
17074: PUSH
17075: LD_INT 20
17077: PUSH
17078: EMPTY
17079: LIST
17080: LIST
17081: LIST
17082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 264
17092: PUSH
17093: LD_INT 9
17095: PUSH
17096: EMPTY
17097: LIST
17098: IN
17099: IFFALSE 17120
// points := [ 5 , 70 , 20 ] ;
17101: LD_ADDR_VAR 0 9
17105: PUSH
17106: LD_INT 5
17108: PUSH
17109: LD_INT 70
17111: PUSH
17112: LD_INT 20
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: LIST
17119: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17120: LD_VAR 0 6
17124: PPUSH
17125: CALL_OW 264
17129: PUSH
17130: LD_INT 10
17132: PUSH
17133: EMPTY
17134: LIST
17135: IN
17136: IFFALSE 17157
// points := [ 35 , 110 , 70 ] ;
17138: LD_ADDR_VAR 0 9
17142: PUSH
17143: LD_INT 35
17145: PUSH
17146: LD_INT 110
17148: PUSH
17149: LD_INT 70
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17157: LD_VAR 0 6
17161: PPUSH
17162: CALL_OW 265
17166: PUSH
17167: LD_INT 25
17169: EQUAL
17170: IFFALSE 17191
// points := [ 80 , 65 , 100 ] ;
17172: LD_ADDR_VAR 0 9
17176: PUSH
17177: LD_INT 80
17179: PUSH
17180: LD_INT 65
17182: PUSH
17183: LD_INT 100
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: LIST
17190: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17191: LD_VAR 0 6
17195: PPUSH
17196: CALL_OW 263
17200: PUSH
17201: LD_INT 1
17203: EQUAL
17204: IFFALSE 17239
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17206: LD_ADDR_VAR 0 10
17210: PUSH
17211: LD_VAR 0 10
17215: PUSH
17216: LD_VAR 0 6
17220: PPUSH
17221: CALL_OW 311
17225: PPUSH
17226: LD_INT 3
17228: PPUSH
17229: CALL_OW 259
17233: PUSH
17234: LD_INT 4
17236: MUL
17237: MUL
17238: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17239: LD_VAR 0 6
17243: PPUSH
17244: CALL_OW 263
17248: PUSH
17249: LD_INT 2
17251: EQUAL
17252: IFFALSE 17303
// begin j := IsControledBy ( i ) ;
17254: LD_ADDR_VAR 0 7
17258: PUSH
17259: LD_VAR 0 6
17263: PPUSH
17264: CALL_OW 312
17268: ST_TO_ADDR
// if j then
17269: LD_VAR 0 7
17273: IFFALSE 17303
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17275: LD_ADDR_VAR 0 10
17279: PUSH
17280: LD_VAR 0 10
17284: PUSH
17285: LD_VAR 0 7
17289: PPUSH
17290: LD_INT 3
17292: PPUSH
17293: CALL_OW 259
17297: PUSH
17298: LD_INT 3
17300: MUL
17301: MUL
17302: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17303: LD_VAR 0 6
17307: PPUSH
17308: CALL_OW 264
17312: PUSH
17313: LD_INT 5
17315: PUSH
17316: LD_INT 6
17318: PUSH
17319: LD_INT 46
17321: PUSH
17322: LD_INT 44
17324: PUSH
17325: LD_INT 47
17327: PUSH
17328: LD_INT 45
17330: PUSH
17331: LD_INT 28
17333: PUSH
17334: LD_INT 7
17336: PUSH
17337: LD_INT 27
17339: PUSH
17340: LD_INT 29
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: LIST
17350: LIST
17351: LIST
17352: LIST
17353: LIST
17354: IN
17355: PUSH
17356: LD_VAR 0 1
17360: PPUSH
17361: LD_INT 52
17363: PPUSH
17364: CALL_OW 321
17368: PUSH
17369: LD_INT 2
17371: EQUAL
17372: AND
17373: IFFALSE 17390
// bpoints := bpoints * 1.2 ;
17375: LD_ADDR_VAR 0 10
17379: PUSH
17380: LD_VAR 0 10
17384: PUSH
17385: LD_REAL  1.20000000000000E+0000
17388: MUL
17389: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17390: LD_VAR 0 6
17394: PPUSH
17395: CALL_OW 264
17399: PUSH
17400: LD_INT 6
17402: PUSH
17403: LD_INT 46
17405: PUSH
17406: LD_INT 47
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: LIST
17413: IN
17414: IFFALSE 17431
// bpoints := bpoints * 1.2 ;
17416: LD_ADDR_VAR 0 10
17420: PUSH
17421: LD_VAR 0 10
17425: PUSH
17426: LD_REAL  1.20000000000000E+0000
17429: MUL
17430: ST_TO_ADDR
// end ; unit_building :
17431: GO 17445
17433: LD_INT 3
17435: DOUBLE
17436: EQUAL
17437: IFTRUE 17441
17439: GO 17444
17441: POP
// ; end ;
17442: GO 17445
17444: POP
// for j = 1 to 3 do
17445: LD_ADDR_VAR 0 7
17449: PUSH
17450: DOUBLE
17451: LD_INT 1
17453: DEC
17454: ST_TO_ADDR
17455: LD_INT 3
17457: PUSH
17458: FOR_TO
17459: IFFALSE 17512
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17461: LD_ADDR_VAR 0 5
17465: PUSH
17466: LD_VAR 0 5
17470: PPUSH
17471: LD_VAR 0 7
17475: PPUSH
17476: LD_VAR 0 5
17480: PUSH
17481: LD_VAR 0 7
17485: ARRAY
17486: PUSH
17487: LD_VAR 0 9
17491: PUSH
17492: LD_VAR 0 7
17496: ARRAY
17497: PUSH
17498: LD_VAR 0 10
17502: MUL
17503: PLUS
17504: PPUSH
17505: CALL_OW 1
17509: ST_TO_ADDR
17510: GO 17458
17512: POP
17513: POP
// end ;
17514: GO 15993
17516: POP
17517: POP
// result := Replace ( result , 4 , tmp ) ;
17518: LD_ADDR_VAR 0 5
17522: PUSH
17523: LD_VAR 0 5
17527: PPUSH
17528: LD_INT 4
17530: PPUSH
17531: LD_VAR 0 8
17535: PPUSH
17536: CALL_OW 1
17540: ST_TO_ADDR
// end ;
17541: LD_VAR 0 5
17545: RET
// export function DangerAtRange ( unit , range ) ; begin
17546: LD_INT 0
17548: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17549: LD_ADDR_VAR 0 3
17553: PUSH
17554: LD_VAR 0 1
17558: PPUSH
17559: CALL_OW 255
17563: PPUSH
17564: LD_VAR 0 1
17568: PPUSH
17569: CALL_OW 250
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 251
17583: PPUSH
17584: LD_VAR 0 2
17588: PPUSH
17589: CALL 15845 0 4
17593: ST_TO_ADDR
// end ;
17594: LD_VAR 0 3
17598: RET
// export function DangerInArea ( side , area ) ; begin
17599: LD_INT 0
17601: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17602: LD_ADDR_VAR 0 3
17606: PUSH
17607: LD_VAR 0 2
17611: PPUSH
17612: LD_INT 81
17614: PUSH
17615: LD_VAR 0 1
17619: PUSH
17620: EMPTY
17621: LIST
17622: LIST
17623: PPUSH
17624: CALL_OW 70
17628: ST_TO_ADDR
// end ;
17629: LD_VAR 0 3
17633: RET
// export function IsExtension ( b ) ; begin
17634: LD_INT 0
17636: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17637: LD_ADDR_VAR 0 2
17641: PUSH
17642: LD_VAR 0 1
17646: PUSH
17647: LD_INT 23
17649: PUSH
17650: LD_INT 20
17652: PUSH
17653: LD_INT 22
17655: PUSH
17656: LD_INT 17
17658: PUSH
17659: LD_INT 24
17661: PUSH
17662: LD_INT 21
17664: PUSH
17665: LD_INT 19
17667: PUSH
17668: LD_INT 16
17670: PUSH
17671: LD_INT 25
17673: PUSH
17674: LD_INT 18
17676: PUSH
17677: EMPTY
17678: LIST
17679: LIST
17680: LIST
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: LIST
17686: LIST
17687: LIST
17688: IN
17689: ST_TO_ADDR
// end ;
17690: LD_VAR 0 2
17694: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17695: LD_INT 0
17697: PPUSH
17698: PPUSH
17699: PPUSH
// result := [ ] ;
17700: LD_ADDR_VAR 0 4
17704: PUSH
17705: EMPTY
17706: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17707: LD_ADDR_VAR 0 5
17711: PUSH
17712: LD_VAR 0 2
17716: PPUSH
17717: LD_INT 21
17719: PUSH
17720: LD_INT 3
17722: PUSH
17723: EMPTY
17724: LIST
17725: LIST
17726: PPUSH
17727: CALL_OW 70
17731: ST_TO_ADDR
// if not tmp then
17732: LD_VAR 0 5
17736: NOT
17737: IFFALSE 17741
// exit ;
17739: GO 17805
// if checkLink then
17741: LD_VAR 0 3
17745: IFFALSE 17795
// begin for i in tmp do
17747: LD_ADDR_VAR 0 6
17751: PUSH
17752: LD_VAR 0 5
17756: PUSH
17757: FOR_IN
17758: IFFALSE 17793
// if GetBase ( i ) <> base then
17760: LD_VAR 0 6
17764: PPUSH
17765: CALL_OW 274
17769: PUSH
17770: LD_VAR 0 1
17774: NONEQUAL
17775: IFFALSE 17791
// ComLinkToBase ( base , i ) ;
17777: LD_VAR 0 1
17781: PPUSH
17782: LD_VAR 0 6
17786: PPUSH
17787: CALL_OW 169
17791: GO 17757
17793: POP
17794: POP
// end ; result := tmp ;
17795: LD_ADDR_VAR 0 4
17799: PUSH
17800: LD_VAR 0 5
17804: ST_TO_ADDR
// end ;
17805: LD_VAR 0 4
17809: RET
// export function ComComplete ( units , b ) ; var i ; begin
17810: LD_INT 0
17812: PPUSH
17813: PPUSH
// if not units then
17814: LD_VAR 0 1
17818: NOT
17819: IFFALSE 17823
// exit ;
17821: GO 17913
// for i in units do
17823: LD_ADDR_VAR 0 4
17827: PUSH
17828: LD_VAR 0 1
17832: PUSH
17833: FOR_IN
17834: IFFALSE 17911
// if BuildingStatus ( b ) = bs_build then
17836: LD_VAR 0 2
17840: PPUSH
17841: CALL_OW 461
17845: PUSH
17846: LD_INT 1
17848: EQUAL
17849: IFFALSE 17909
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17851: LD_VAR 0 4
17855: PPUSH
17856: LD_STRING h
17858: PUSH
17859: LD_VAR 0 2
17863: PPUSH
17864: CALL_OW 250
17868: PUSH
17869: LD_VAR 0 2
17873: PPUSH
17874: CALL_OW 251
17878: PUSH
17879: LD_VAR 0 2
17883: PUSH
17884: LD_INT 0
17886: PUSH
17887: LD_INT 0
17889: PUSH
17890: LD_INT 0
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: PUSH
17902: EMPTY
17903: LIST
17904: PPUSH
17905: CALL_OW 446
17909: GO 17833
17911: POP
17912: POP
// end ;
17913: LD_VAR 0 3
17917: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17918: LD_INT 0
17920: PPUSH
17921: PPUSH
17922: PPUSH
17923: PPUSH
17924: PPUSH
17925: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17926: LD_VAR 0 1
17930: NOT
17931: PUSH
17932: LD_VAR 0 1
17936: PPUSH
17937: CALL_OW 263
17941: PUSH
17942: LD_INT 2
17944: NONEQUAL
17945: OR
17946: IFFALSE 17950
// exit ;
17948: GO 18266
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17950: LD_ADDR_VAR 0 6
17954: PUSH
17955: LD_INT 22
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL_OW 255
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PUSH
17972: LD_INT 2
17974: PUSH
17975: LD_INT 30
17977: PUSH
17978: LD_INT 36
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 34
17987: PUSH
17988: LD_INT 31
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: PUSH
18000: EMPTY
18001: LIST
18002: LIST
18003: PPUSH
18004: CALL_OW 69
18008: ST_TO_ADDR
// if not tmp then
18009: LD_VAR 0 6
18013: NOT
18014: IFFALSE 18018
// exit ;
18016: GO 18266
// result := [ ] ;
18018: LD_ADDR_VAR 0 2
18022: PUSH
18023: EMPTY
18024: ST_TO_ADDR
// for i in tmp do
18025: LD_ADDR_VAR 0 3
18029: PUSH
18030: LD_VAR 0 6
18034: PUSH
18035: FOR_IN
18036: IFFALSE 18107
// begin t := UnitsInside ( i ) ;
18038: LD_ADDR_VAR 0 4
18042: PUSH
18043: LD_VAR 0 3
18047: PPUSH
18048: CALL_OW 313
18052: ST_TO_ADDR
// if t then
18053: LD_VAR 0 4
18057: IFFALSE 18105
// for j in t do
18059: LD_ADDR_VAR 0 7
18063: PUSH
18064: LD_VAR 0 4
18068: PUSH
18069: FOR_IN
18070: IFFALSE 18103
// result := Replace ( result , result + 1 , j ) ;
18072: LD_ADDR_VAR 0 2
18076: PUSH
18077: LD_VAR 0 2
18081: PPUSH
18082: LD_VAR 0 2
18086: PUSH
18087: LD_INT 1
18089: PLUS
18090: PPUSH
18091: LD_VAR 0 7
18095: PPUSH
18096: CALL_OW 1
18100: ST_TO_ADDR
18101: GO 18069
18103: POP
18104: POP
// end ;
18105: GO 18035
18107: POP
18108: POP
// if not result then
18109: LD_VAR 0 2
18113: NOT
18114: IFFALSE 18118
// exit ;
18116: GO 18266
// mech := result [ 1 ] ;
18118: LD_ADDR_VAR 0 5
18122: PUSH
18123: LD_VAR 0 2
18127: PUSH
18128: LD_INT 1
18130: ARRAY
18131: ST_TO_ADDR
// if result > 1 then
18132: LD_VAR 0 2
18136: PUSH
18137: LD_INT 1
18139: GREATER
18140: IFFALSE 18252
// begin for i = 2 to result do
18142: LD_ADDR_VAR 0 3
18146: PUSH
18147: DOUBLE
18148: LD_INT 2
18150: DEC
18151: ST_TO_ADDR
18152: LD_VAR 0 2
18156: PUSH
18157: FOR_TO
18158: IFFALSE 18250
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18160: LD_ADDR_VAR 0 4
18164: PUSH
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 3
18174: ARRAY
18175: PPUSH
18176: LD_INT 3
18178: PPUSH
18179: CALL_OW 259
18183: PUSH
18184: LD_VAR 0 2
18188: PUSH
18189: LD_VAR 0 3
18193: ARRAY
18194: PPUSH
18195: CALL_OW 432
18199: MINUS
18200: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18201: LD_VAR 0 4
18205: PUSH
18206: LD_VAR 0 5
18210: PPUSH
18211: LD_INT 3
18213: PPUSH
18214: CALL_OW 259
18218: PUSH
18219: LD_VAR 0 5
18223: PPUSH
18224: CALL_OW 432
18228: MINUS
18229: GREATEREQUAL
18230: IFFALSE 18248
// mech := result [ i ] ;
18232: LD_ADDR_VAR 0 5
18236: PUSH
18237: LD_VAR 0 2
18241: PUSH
18242: LD_VAR 0 3
18246: ARRAY
18247: ST_TO_ADDR
// end ;
18248: GO 18157
18250: POP
18251: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18252: LD_VAR 0 1
18256: PPUSH
18257: LD_VAR 0 5
18261: PPUSH
18262: CALL_OW 135
// end ;
18266: LD_VAR 0 2
18270: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
18276: PPUSH
18277: PPUSH
18278: PPUSH
18279: PPUSH
18280: PPUSH
18281: PPUSH
18282: PPUSH
18283: PPUSH
18284: PPUSH
18285: PPUSH
// result := [ ] ;
18286: LD_ADDR_VAR 0 7
18290: PUSH
18291: EMPTY
18292: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18293: LD_VAR 0 1
18297: PPUSH
18298: CALL_OW 266
18302: PUSH
18303: LD_INT 0
18305: PUSH
18306: LD_INT 1
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: IN
18313: NOT
18314: IFFALSE 18318
// exit ;
18316: GO 19952
// if name then
18318: LD_VAR 0 3
18322: IFFALSE 18338
// SetBName ( base_dep , name ) ;
18324: LD_VAR 0 1
18328: PPUSH
18329: LD_VAR 0 3
18333: PPUSH
18334: CALL_OW 500
// base := GetBase ( base_dep ) ;
18338: LD_ADDR_VAR 0 15
18342: PUSH
18343: LD_VAR 0 1
18347: PPUSH
18348: CALL_OW 274
18352: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18353: LD_ADDR_VAR 0 16
18357: PUSH
18358: LD_VAR 0 1
18362: PPUSH
18363: CALL_OW 255
18367: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18368: LD_ADDR_VAR 0 17
18372: PUSH
18373: LD_VAR 0 1
18377: PPUSH
18378: CALL_OW 248
18382: ST_TO_ADDR
// if sources then
18383: LD_VAR 0 5
18387: IFFALSE 18434
// for i = 1 to 3 do
18389: LD_ADDR_VAR 0 8
18393: PUSH
18394: DOUBLE
18395: LD_INT 1
18397: DEC
18398: ST_TO_ADDR
18399: LD_INT 3
18401: PUSH
18402: FOR_TO
18403: IFFALSE 18432
// AddResourceType ( base , i , sources [ i ] ) ;
18405: LD_VAR 0 15
18409: PPUSH
18410: LD_VAR 0 8
18414: PPUSH
18415: LD_VAR 0 5
18419: PUSH
18420: LD_VAR 0 8
18424: ARRAY
18425: PPUSH
18426: CALL_OW 276
18430: GO 18402
18432: POP
18433: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18434: LD_ADDR_VAR 0 18
18438: PUSH
18439: LD_VAR 0 15
18443: PPUSH
18444: LD_VAR 0 2
18448: PPUSH
18449: LD_INT 1
18451: PPUSH
18452: CALL 17695 0 3
18456: ST_TO_ADDR
// InitHc ;
18457: CALL_OW 19
// InitUc ;
18461: CALL_OW 18
// uc_side := side ;
18465: LD_ADDR_OWVAR 20
18469: PUSH
18470: LD_VAR 0 16
18474: ST_TO_ADDR
// uc_nation := nation ;
18475: LD_ADDR_OWVAR 21
18479: PUSH
18480: LD_VAR 0 17
18484: ST_TO_ADDR
// if buildings then
18485: LD_VAR 0 18
18489: IFFALSE 19811
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18491: LD_ADDR_VAR 0 19
18495: PUSH
18496: LD_VAR 0 18
18500: PPUSH
18501: LD_INT 2
18503: PUSH
18504: LD_INT 30
18506: PUSH
18507: LD_INT 29
18509: PUSH
18510: EMPTY
18511: LIST
18512: LIST
18513: PUSH
18514: LD_INT 30
18516: PUSH
18517: LD_INT 30
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: EMPTY
18525: LIST
18526: LIST
18527: LIST
18528: PPUSH
18529: CALL_OW 72
18533: ST_TO_ADDR
// if tmp then
18534: LD_VAR 0 19
18538: IFFALSE 18586
// for i in tmp do
18540: LD_ADDR_VAR 0 8
18544: PUSH
18545: LD_VAR 0 19
18549: PUSH
18550: FOR_IN
18551: IFFALSE 18584
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18553: LD_VAR 0 8
18557: PPUSH
18558: CALL_OW 250
18562: PPUSH
18563: LD_VAR 0 8
18567: PPUSH
18568: CALL_OW 251
18572: PPUSH
18573: LD_VAR 0 16
18577: PPUSH
18578: CALL_OW 441
18582: GO 18550
18584: POP
18585: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18586: LD_VAR 0 18
18590: PPUSH
18591: LD_INT 2
18593: PUSH
18594: LD_INT 30
18596: PUSH
18597: LD_INT 32
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 30
18606: PUSH
18607: LD_INT 33
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: LIST
18618: PPUSH
18619: CALL_OW 72
18623: IFFALSE 18711
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18625: LD_ADDR_VAR 0 8
18629: PUSH
18630: LD_VAR 0 18
18634: PPUSH
18635: LD_INT 2
18637: PUSH
18638: LD_INT 30
18640: PUSH
18641: LD_INT 32
18643: PUSH
18644: EMPTY
18645: LIST
18646: LIST
18647: PUSH
18648: LD_INT 30
18650: PUSH
18651: LD_INT 33
18653: PUSH
18654: EMPTY
18655: LIST
18656: LIST
18657: PUSH
18658: EMPTY
18659: LIST
18660: LIST
18661: LIST
18662: PPUSH
18663: CALL_OW 72
18667: PUSH
18668: FOR_IN
18669: IFFALSE 18709
// begin if not GetBWeapon ( i ) then
18671: LD_VAR 0 8
18675: PPUSH
18676: CALL_OW 269
18680: NOT
18681: IFFALSE 18707
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18683: LD_VAR 0 8
18687: PPUSH
18688: LD_VAR 0 8
18692: PPUSH
18693: LD_VAR 0 2
18697: PPUSH
18698: CALL 19957 0 2
18702: PPUSH
18703: CALL_OW 431
// end ;
18707: GO 18668
18709: POP
18710: POP
// end ; for i = 1 to personel do
18711: LD_ADDR_VAR 0 8
18715: PUSH
18716: DOUBLE
18717: LD_INT 1
18719: DEC
18720: ST_TO_ADDR
18721: LD_VAR 0 6
18725: PUSH
18726: FOR_TO
18727: IFFALSE 19791
// begin if i > 4 then
18729: LD_VAR 0 8
18733: PUSH
18734: LD_INT 4
18736: GREATER
18737: IFFALSE 18741
// break ;
18739: GO 19791
// case i of 1 :
18741: LD_VAR 0 8
18745: PUSH
18746: LD_INT 1
18748: DOUBLE
18749: EQUAL
18750: IFTRUE 18754
18752: GO 18834
18754: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18755: LD_ADDR_VAR 0 12
18759: PUSH
18760: LD_VAR 0 18
18764: PPUSH
18765: LD_INT 22
18767: PUSH
18768: LD_VAR 0 16
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 58
18779: PUSH
18780: EMPTY
18781: LIST
18782: PUSH
18783: LD_INT 2
18785: PUSH
18786: LD_INT 30
18788: PUSH
18789: LD_INT 32
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: PUSH
18796: LD_INT 30
18798: PUSH
18799: LD_INT 4
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: PUSH
18806: LD_INT 30
18808: PUSH
18809: LD_INT 5
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: PUSH
18822: EMPTY
18823: LIST
18824: LIST
18825: LIST
18826: PPUSH
18827: CALL_OW 72
18831: ST_TO_ADDR
18832: GO 19056
18834: LD_INT 2
18836: DOUBLE
18837: EQUAL
18838: IFTRUE 18842
18840: GO 18904
18842: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18843: LD_ADDR_VAR 0 12
18847: PUSH
18848: LD_VAR 0 18
18852: PPUSH
18853: LD_INT 22
18855: PUSH
18856: LD_VAR 0 16
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: LD_INT 2
18867: PUSH
18868: LD_INT 30
18870: PUSH
18871: LD_INT 0
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: PUSH
18878: LD_INT 30
18880: PUSH
18881: LD_INT 1
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: PUSH
18893: EMPTY
18894: LIST
18895: LIST
18896: PPUSH
18897: CALL_OW 72
18901: ST_TO_ADDR
18902: GO 19056
18904: LD_INT 3
18906: DOUBLE
18907: EQUAL
18908: IFTRUE 18912
18910: GO 18974
18912: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18913: LD_ADDR_VAR 0 12
18917: PUSH
18918: LD_VAR 0 18
18922: PPUSH
18923: LD_INT 22
18925: PUSH
18926: LD_VAR 0 16
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PUSH
18935: LD_INT 2
18937: PUSH
18938: LD_INT 30
18940: PUSH
18941: LD_INT 2
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: PUSH
18948: LD_INT 30
18950: PUSH
18951: LD_INT 3
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: LIST
18962: PUSH
18963: EMPTY
18964: LIST
18965: LIST
18966: PPUSH
18967: CALL_OW 72
18971: ST_TO_ADDR
18972: GO 19056
18974: LD_INT 4
18976: DOUBLE
18977: EQUAL
18978: IFTRUE 18982
18980: GO 19055
18982: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18983: LD_ADDR_VAR 0 12
18987: PUSH
18988: LD_VAR 0 18
18992: PPUSH
18993: LD_INT 22
18995: PUSH
18996: LD_VAR 0 16
19000: PUSH
19001: EMPTY
19002: LIST
19003: LIST
19004: PUSH
19005: LD_INT 2
19007: PUSH
19008: LD_INT 30
19010: PUSH
19011: LD_INT 6
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 7
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 30
19030: PUSH
19031: LD_INT 8
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: LIST
19043: PUSH
19044: EMPTY
19045: LIST
19046: LIST
19047: PPUSH
19048: CALL_OW 72
19052: ST_TO_ADDR
19053: GO 19056
19055: POP
// if i = 1 then
19056: LD_VAR 0 8
19060: PUSH
19061: LD_INT 1
19063: EQUAL
19064: IFFALSE 19175
// begin tmp := [ ] ;
19066: LD_ADDR_VAR 0 19
19070: PUSH
19071: EMPTY
19072: ST_TO_ADDR
// for j in f do
19073: LD_ADDR_VAR 0 9
19077: PUSH
19078: LD_VAR 0 12
19082: PUSH
19083: FOR_IN
19084: IFFALSE 19157
// if GetBType ( j ) = b_bunker then
19086: LD_VAR 0 9
19090: PPUSH
19091: CALL_OW 266
19095: PUSH
19096: LD_INT 32
19098: EQUAL
19099: IFFALSE 19126
// tmp := Insert ( tmp , 1 , j ) else
19101: LD_ADDR_VAR 0 19
19105: PUSH
19106: LD_VAR 0 19
19110: PPUSH
19111: LD_INT 1
19113: PPUSH
19114: LD_VAR 0 9
19118: PPUSH
19119: CALL_OW 2
19123: ST_TO_ADDR
19124: GO 19155
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19126: LD_ADDR_VAR 0 19
19130: PUSH
19131: LD_VAR 0 19
19135: PPUSH
19136: LD_VAR 0 19
19140: PUSH
19141: LD_INT 1
19143: PLUS
19144: PPUSH
19145: LD_VAR 0 9
19149: PPUSH
19150: CALL_OW 2
19154: ST_TO_ADDR
19155: GO 19083
19157: POP
19158: POP
// if tmp then
19159: LD_VAR 0 19
19163: IFFALSE 19175
// f := tmp ;
19165: LD_ADDR_VAR 0 12
19169: PUSH
19170: LD_VAR 0 19
19174: ST_TO_ADDR
// end ; x := personel [ i ] ;
19175: LD_ADDR_VAR 0 13
19179: PUSH
19180: LD_VAR 0 6
19184: PUSH
19185: LD_VAR 0 8
19189: ARRAY
19190: ST_TO_ADDR
// if x = - 1 then
19191: LD_VAR 0 13
19195: PUSH
19196: LD_INT 1
19198: NEG
19199: EQUAL
19200: IFFALSE 19409
// begin for j in f do
19202: LD_ADDR_VAR 0 9
19206: PUSH
19207: LD_VAR 0 12
19211: PUSH
19212: FOR_IN
19213: IFFALSE 19405
// repeat InitHc ;
19215: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19219: LD_VAR 0 9
19223: PPUSH
19224: CALL_OW 266
19228: PUSH
19229: LD_INT 5
19231: EQUAL
19232: IFFALSE 19302
// begin if UnitsInside ( j ) < 3 then
19234: LD_VAR 0 9
19238: PPUSH
19239: CALL_OW 313
19243: PUSH
19244: LD_INT 3
19246: LESS
19247: IFFALSE 19283
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19249: LD_INT 0
19251: PPUSH
19252: LD_INT 5
19254: PUSH
19255: LD_INT 8
19257: PUSH
19258: LD_INT 9
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: LIST
19265: PUSH
19266: LD_VAR 0 17
19270: ARRAY
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: CALL_OW 380
19281: GO 19300
// PrepareHuman ( false , i , skill ) ;
19283: LD_INT 0
19285: PPUSH
19286: LD_VAR 0 8
19290: PPUSH
19291: LD_VAR 0 4
19295: PPUSH
19296: CALL_OW 380
// end else
19300: GO 19319
// PrepareHuman ( false , i , skill ) ;
19302: LD_INT 0
19304: PPUSH
19305: LD_VAR 0 8
19309: PPUSH
19310: LD_VAR 0 4
19314: PPUSH
19315: CALL_OW 380
// un := CreateHuman ;
19319: LD_ADDR_VAR 0 14
19323: PUSH
19324: CALL_OW 44
19328: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19329: LD_ADDR_VAR 0 7
19333: PUSH
19334: LD_VAR 0 7
19338: PPUSH
19339: LD_INT 1
19341: PPUSH
19342: LD_VAR 0 14
19346: PPUSH
19347: CALL_OW 2
19351: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19352: LD_VAR 0 14
19356: PPUSH
19357: LD_VAR 0 9
19361: PPUSH
19362: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19366: LD_VAR 0 9
19370: PPUSH
19371: CALL_OW 313
19375: PUSH
19376: LD_INT 6
19378: EQUAL
19379: PUSH
19380: LD_VAR 0 9
19384: PPUSH
19385: CALL_OW 266
19389: PUSH
19390: LD_INT 32
19392: PUSH
19393: LD_INT 31
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: IN
19400: OR
19401: IFFALSE 19215
19403: GO 19212
19405: POP
19406: POP
// end else
19407: GO 19789
// for j = 1 to x do
19409: LD_ADDR_VAR 0 9
19413: PUSH
19414: DOUBLE
19415: LD_INT 1
19417: DEC
19418: ST_TO_ADDR
19419: LD_VAR 0 13
19423: PUSH
19424: FOR_TO
19425: IFFALSE 19787
// begin InitHc ;
19427: CALL_OW 19
// if not f then
19431: LD_VAR 0 12
19435: NOT
19436: IFFALSE 19525
// begin PrepareHuman ( false , i , skill ) ;
19438: LD_INT 0
19440: PPUSH
19441: LD_VAR 0 8
19445: PPUSH
19446: LD_VAR 0 4
19450: PPUSH
19451: CALL_OW 380
// un := CreateHuman ;
19455: LD_ADDR_VAR 0 14
19459: PUSH
19460: CALL_OW 44
19464: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19465: LD_ADDR_VAR 0 7
19469: PUSH
19470: LD_VAR 0 7
19474: PPUSH
19475: LD_INT 1
19477: PPUSH
19478: LD_VAR 0 14
19482: PPUSH
19483: CALL_OW 2
19487: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19488: LD_VAR 0 14
19492: PPUSH
19493: LD_VAR 0 1
19497: PPUSH
19498: CALL_OW 250
19502: PPUSH
19503: LD_VAR 0 1
19507: PPUSH
19508: CALL_OW 251
19512: PPUSH
19513: LD_INT 10
19515: PPUSH
19516: LD_INT 0
19518: PPUSH
19519: CALL_OW 50
// continue ;
19523: GO 19424
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19525: LD_VAR 0 12
19529: PUSH
19530: LD_INT 1
19532: ARRAY
19533: PPUSH
19534: CALL_OW 313
19538: PUSH
19539: LD_VAR 0 12
19543: PUSH
19544: LD_INT 1
19546: ARRAY
19547: PPUSH
19548: CALL_OW 266
19552: PUSH
19553: LD_INT 32
19555: PUSH
19556: LD_INT 31
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: IN
19563: AND
19564: PUSH
19565: LD_VAR 0 12
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PPUSH
19574: CALL_OW 313
19578: PUSH
19579: LD_INT 6
19581: EQUAL
19582: OR
19583: IFFALSE 19603
// f := Delete ( f , 1 ) ;
19585: LD_ADDR_VAR 0 12
19589: PUSH
19590: LD_VAR 0 12
19594: PPUSH
19595: LD_INT 1
19597: PPUSH
19598: CALL_OW 3
19602: ST_TO_ADDR
// if not f then
19603: LD_VAR 0 12
19607: NOT
19608: IFFALSE 19626
// begin x := x + 2 ;
19610: LD_ADDR_VAR 0 13
19614: PUSH
19615: LD_VAR 0 13
19619: PUSH
19620: LD_INT 2
19622: PLUS
19623: ST_TO_ADDR
// continue ;
19624: GO 19424
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19626: LD_VAR 0 12
19630: PUSH
19631: LD_INT 1
19633: ARRAY
19634: PPUSH
19635: CALL_OW 266
19639: PUSH
19640: LD_INT 5
19642: EQUAL
19643: IFFALSE 19717
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19645: LD_VAR 0 12
19649: PUSH
19650: LD_INT 1
19652: ARRAY
19653: PPUSH
19654: CALL_OW 313
19658: PUSH
19659: LD_INT 3
19661: LESS
19662: IFFALSE 19698
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19664: LD_INT 0
19666: PPUSH
19667: LD_INT 5
19669: PUSH
19670: LD_INT 8
19672: PUSH
19673: LD_INT 9
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: LIST
19680: PUSH
19681: LD_VAR 0 17
19685: ARRAY
19686: PPUSH
19687: LD_VAR 0 4
19691: PPUSH
19692: CALL_OW 380
19696: GO 19715
// PrepareHuman ( false , i , skill ) ;
19698: LD_INT 0
19700: PPUSH
19701: LD_VAR 0 8
19705: PPUSH
19706: LD_VAR 0 4
19710: PPUSH
19711: CALL_OW 380
// end else
19715: GO 19734
// PrepareHuman ( false , i , skill ) ;
19717: LD_INT 0
19719: PPUSH
19720: LD_VAR 0 8
19724: PPUSH
19725: LD_VAR 0 4
19729: PPUSH
19730: CALL_OW 380
// un := CreateHuman ;
19734: LD_ADDR_VAR 0 14
19738: PUSH
19739: CALL_OW 44
19743: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19744: LD_ADDR_VAR 0 7
19748: PUSH
19749: LD_VAR 0 7
19753: PPUSH
19754: LD_INT 1
19756: PPUSH
19757: LD_VAR 0 14
19761: PPUSH
19762: CALL_OW 2
19766: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19767: LD_VAR 0 14
19771: PPUSH
19772: LD_VAR 0 12
19776: PUSH
19777: LD_INT 1
19779: ARRAY
19780: PPUSH
19781: CALL_OW 52
// end ;
19785: GO 19424
19787: POP
19788: POP
// end ;
19789: GO 18726
19791: POP
19792: POP
// result := result ^ buildings ;
19793: LD_ADDR_VAR 0 7
19797: PUSH
19798: LD_VAR 0 7
19802: PUSH
19803: LD_VAR 0 18
19807: ADD
19808: ST_TO_ADDR
// end else
19809: GO 19952
// begin for i = 1 to personel do
19811: LD_ADDR_VAR 0 8
19815: PUSH
19816: DOUBLE
19817: LD_INT 1
19819: DEC
19820: ST_TO_ADDR
19821: LD_VAR 0 6
19825: PUSH
19826: FOR_TO
19827: IFFALSE 19950
// begin if i > 4 then
19829: LD_VAR 0 8
19833: PUSH
19834: LD_INT 4
19836: GREATER
19837: IFFALSE 19841
// break ;
19839: GO 19950
// x := personel [ i ] ;
19841: LD_ADDR_VAR 0 13
19845: PUSH
19846: LD_VAR 0 6
19850: PUSH
19851: LD_VAR 0 8
19855: ARRAY
19856: ST_TO_ADDR
// if x = - 1 then
19857: LD_VAR 0 13
19861: PUSH
19862: LD_INT 1
19864: NEG
19865: EQUAL
19866: IFFALSE 19870
// continue ;
19868: GO 19826
// PrepareHuman ( false , i , skill ) ;
19870: LD_INT 0
19872: PPUSH
19873: LD_VAR 0 8
19877: PPUSH
19878: LD_VAR 0 4
19882: PPUSH
19883: CALL_OW 380
// un := CreateHuman ;
19887: LD_ADDR_VAR 0 14
19891: PUSH
19892: CALL_OW 44
19896: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19897: LD_VAR 0 14
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: CALL_OW 250
19911: PPUSH
19912: LD_VAR 0 1
19916: PPUSH
19917: CALL_OW 251
19921: PPUSH
19922: LD_INT 10
19924: PPUSH
19925: LD_INT 0
19927: PPUSH
19928: CALL_OW 50
// result := result ^ un ;
19932: LD_ADDR_VAR 0 7
19936: PUSH
19937: LD_VAR 0 7
19941: PUSH
19942: LD_VAR 0 14
19946: ADD
19947: ST_TO_ADDR
// end ;
19948: GO 19826
19950: POP
19951: POP
// end ; end ;
19952: LD_VAR 0 7
19956: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19957: LD_INT 0
19959: PPUSH
19960: PPUSH
19961: PPUSH
19962: PPUSH
19963: PPUSH
19964: PPUSH
19965: PPUSH
19966: PPUSH
19967: PPUSH
19968: PPUSH
19969: PPUSH
19970: PPUSH
19971: PPUSH
19972: PPUSH
19973: PPUSH
19974: PPUSH
// result := false ;
19975: LD_ADDR_VAR 0 3
19979: PUSH
19980: LD_INT 0
19982: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19983: LD_VAR 0 1
19987: NOT
19988: PUSH
19989: LD_VAR 0 1
19993: PPUSH
19994: CALL_OW 266
19998: PUSH
19999: LD_INT 32
20001: PUSH
20002: LD_INT 33
20004: PUSH
20005: EMPTY
20006: LIST
20007: LIST
20008: IN
20009: NOT
20010: OR
20011: IFFALSE 20015
// exit ;
20013: GO 21124
// nat := GetNation ( tower ) ;
20015: LD_ADDR_VAR 0 12
20019: PUSH
20020: LD_VAR 0 1
20024: PPUSH
20025: CALL_OW 248
20029: ST_TO_ADDR
// side := GetSide ( tower ) ;
20030: LD_ADDR_VAR 0 16
20034: PUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 255
20044: ST_TO_ADDR
// x := GetX ( tower ) ;
20045: LD_ADDR_VAR 0 10
20049: PUSH
20050: LD_VAR 0 1
20054: PPUSH
20055: CALL_OW 250
20059: ST_TO_ADDR
// y := GetY ( tower ) ;
20060: LD_ADDR_VAR 0 11
20064: PUSH
20065: LD_VAR 0 1
20069: PPUSH
20070: CALL_OW 251
20074: ST_TO_ADDR
// if not x or not y then
20075: LD_VAR 0 10
20079: NOT
20080: PUSH
20081: LD_VAR 0 11
20085: NOT
20086: OR
20087: IFFALSE 20091
// exit ;
20089: GO 21124
// weapon := 0 ;
20091: LD_ADDR_VAR 0 18
20095: PUSH
20096: LD_INT 0
20098: ST_TO_ADDR
// fac_list := [ ] ;
20099: LD_ADDR_VAR 0 17
20103: PUSH
20104: EMPTY
20105: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20106: LD_ADDR_VAR 0 6
20110: PUSH
20111: LD_VAR 0 1
20115: PPUSH
20116: CALL_OW 274
20120: PPUSH
20121: LD_VAR 0 2
20125: PPUSH
20126: LD_INT 0
20128: PPUSH
20129: CALL 17695 0 3
20133: PPUSH
20134: LD_INT 30
20136: PUSH
20137: LD_INT 3
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PPUSH
20144: CALL_OW 72
20148: ST_TO_ADDR
// if not factories then
20149: LD_VAR 0 6
20153: NOT
20154: IFFALSE 20158
// exit ;
20156: GO 21124
// for i in factories do
20158: LD_ADDR_VAR 0 8
20162: PUSH
20163: LD_VAR 0 6
20167: PUSH
20168: FOR_IN
20169: IFFALSE 20194
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20171: LD_ADDR_VAR 0 17
20175: PUSH
20176: LD_VAR 0 17
20180: PUSH
20181: LD_VAR 0 8
20185: PPUSH
20186: CALL_OW 478
20190: UNION
20191: ST_TO_ADDR
20192: GO 20168
20194: POP
20195: POP
// if not fac_list then
20196: LD_VAR 0 17
20200: NOT
20201: IFFALSE 20205
// exit ;
20203: GO 21124
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20205: LD_ADDR_VAR 0 5
20209: PUSH
20210: LD_INT 4
20212: PUSH
20213: LD_INT 5
20215: PUSH
20216: LD_INT 9
20218: PUSH
20219: LD_INT 10
20221: PUSH
20222: LD_INT 6
20224: PUSH
20225: LD_INT 7
20227: PUSH
20228: LD_INT 11
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: LIST
20235: LIST
20236: LIST
20237: LIST
20238: LIST
20239: PUSH
20240: LD_INT 27
20242: PUSH
20243: LD_INT 28
20245: PUSH
20246: LD_INT 26
20248: PUSH
20249: LD_INT 30
20251: PUSH
20252: EMPTY
20253: LIST
20254: LIST
20255: LIST
20256: LIST
20257: PUSH
20258: LD_INT 43
20260: PUSH
20261: LD_INT 44
20263: PUSH
20264: LD_INT 46
20266: PUSH
20267: LD_INT 45
20269: PUSH
20270: LD_INT 47
20272: PUSH
20273: LD_INT 49
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: LIST
20283: PUSH
20284: EMPTY
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_VAR 0 12
20293: ARRAY
20294: ST_TO_ADDR
// list := list isect fac_list ;
20295: LD_ADDR_VAR 0 5
20299: PUSH
20300: LD_VAR 0 5
20304: PUSH
20305: LD_VAR 0 17
20309: ISECT
20310: ST_TO_ADDR
// if not list then
20311: LD_VAR 0 5
20315: NOT
20316: IFFALSE 20320
// exit ;
20318: GO 21124
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20320: LD_VAR 0 12
20324: PUSH
20325: LD_INT 3
20327: EQUAL
20328: PUSH
20329: LD_INT 49
20331: PUSH
20332: LD_VAR 0 5
20336: IN
20337: AND
20338: PUSH
20339: LD_INT 31
20341: PPUSH
20342: LD_VAR 0 16
20346: PPUSH
20347: CALL_OW 321
20351: PUSH
20352: LD_INT 2
20354: EQUAL
20355: AND
20356: IFFALSE 20416
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20358: LD_INT 22
20360: PUSH
20361: LD_VAR 0 16
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 35
20372: PUSH
20373: LD_INT 49
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 91
20382: PUSH
20383: LD_VAR 0 1
20387: PUSH
20388: LD_INT 10
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: LIST
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: LIST
20400: PPUSH
20401: CALL_OW 69
20405: NOT
20406: IFFALSE 20416
// weapon := ru_time_lapser ;
20408: LD_ADDR_VAR 0 18
20412: PUSH
20413: LD_INT 49
20415: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20416: LD_VAR 0 12
20420: PUSH
20421: LD_INT 1
20423: PUSH
20424: LD_INT 2
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: IN
20431: PUSH
20432: LD_INT 11
20434: PUSH
20435: LD_VAR 0 5
20439: IN
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_VAR 0 5
20448: IN
20449: OR
20450: AND
20451: PUSH
20452: LD_INT 6
20454: PPUSH
20455: LD_VAR 0 16
20459: PPUSH
20460: CALL_OW 321
20464: PUSH
20465: LD_INT 2
20467: EQUAL
20468: AND
20469: IFFALSE 20634
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20471: LD_INT 22
20473: PUSH
20474: LD_VAR 0 16
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: PUSH
20483: LD_INT 2
20485: PUSH
20486: LD_INT 35
20488: PUSH
20489: LD_INT 11
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PUSH
20496: LD_INT 35
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: LIST
20510: PUSH
20511: LD_INT 91
20513: PUSH
20514: LD_VAR 0 1
20518: PUSH
20519: LD_INT 18
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: LIST
20526: PUSH
20527: EMPTY
20528: LIST
20529: LIST
20530: LIST
20531: PPUSH
20532: CALL_OW 69
20536: NOT
20537: PUSH
20538: LD_INT 22
20540: PUSH
20541: LD_VAR 0 16
20545: PUSH
20546: EMPTY
20547: LIST
20548: LIST
20549: PUSH
20550: LD_INT 2
20552: PUSH
20553: LD_INT 30
20555: PUSH
20556: LD_INT 32
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: LD_INT 30
20565: PUSH
20566: LD_INT 33
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: LIST
20577: PUSH
20578: LD_INT 91
20580: PUSH
20581: LD_VAR 0 1
20585: PUSH
20586: LD_INT 12
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: LIST
20598: PUSH
20599: EMPTY
20600: LIST
20601: PPUSH
20602: CALL_OW 69
20606: PUSH
20607: LD_INT 2
20609: GREATER
20610: AND
20611: IFFALSE 20634
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20613: LD_ADDR_VAR 0 18
20617: PUSH
20618: LD_INT 11
20620: PUSH
20621: LD_INT 30
20623: PUSH
20624: EMPTY
20625: LIST
20626: LIST
20627: PUSH
20628: LD_VAR 0 12
20632: ARRAY
20633: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20634: LD_VAR 0 18
20638: NOT
20639: PUSH
20640: LD_INT 40
20642: PPUSH
20643: LD_VAR 0 16
20647: PPUSH
20648: CALL_OW 321
20652: PUSH
20653: LD_INT 2
20655: EQUAL
20656: AND
20657: PUSH
20658: LD_INT 7
20660: PUSH
20661: LD_VAR 0 5
20665: IN
20666: PUSH
20667: LD_INT 28
20669: PUSH
20670: LD_VAR 0 5
20674: IN
20675: OR
20676: PUSH
20677: LD_INT 45
20679: PUSH
20680: LD_VAR 0 5
20684: IN
20685: OR
20686: AND
20687: IFFALSE 20941
// begin hex := GetHexInfo ( x , y ) ;
20689: LD_ADDR_VAR 0 4
20693: PUSH
20694: LD_VAR 0 10
20698: PPUSH
20699: LD_VAR 0 11
20703: PPUSH
20704: CALL_OW 546
20708: ST_TO_ADDR
// if hex [ 1 ] then
20709: LD_VAR 0 4
20713: PUSH
20714: LD_INT 1
20716: ARRAY
20717: IFFALSE 20721
// exit ;
20719: GO 21124
// height := hex [ 2 ] ;
20721: LD_ADDR_VAR 0 15
20725: PUSH
20726: LD_VAR 0 4
20730: PUSH
20731: LD_INT 2
20733: ARRAY
20734: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20735: LD_ADDR_VAR 0 14
20739: PUSH
20740: LD_INT 0
20742: PUSH
20743: LD_INT 2
20745: PUSH
20746: LD_INT 3
20748: PUSH
20749: LD_INT 5
20751: PUSH
20752: EMPTY
20753: LIST
20754: LIST
20755: LIST
20756: LIST
20757: ST_TO_ADDR
// for i in tmp do
20758: LD_ADDR_VAR 0 8
20762: PUSH
20763: LD_VAR 0 14
20767: PUSH
20768: FOR_IN
20769: IFFALSE 20939
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20771: LD_ADDR_VAR 0 9
20775: PUSH
20776: LD_VAR 0 10
20780: PPUSH
20781: LD_VAR 0 8
20785: PPUSH
20786: LD_INT 5
20788: PPUSH
20789: CALL_OW 272
20793: PUSH
20794: LD_VAR 0 11
20798: PPUSH
20799: LD_VAR 0 8
20803: PPUSH
20804: LD_INT 5
20806: PPUSH
20807: CALL_OW 273
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20816: LD_VAR 0 9
20820: PUSH
20821: LD_INT 1
20823: ARRAY
20824: PPUSH
20825: LD_VAR 0 9
20829: PUSH
20830: LD_INT 2
20832: ARRAY
20833: PPUSH
20834: CALL_OW 488
20838: IFFALSE 20937
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20840: LD_ADDR_VAR 0 4
20844: PUSH
20845: LD_VAR 0 9
20849: PUSH
20850: LD_INT 1
20852: ARRAY
20853: PPUSH
20854: LD_VAR 0 9
20858: PUSH
20859: LD_INT 2
20861: ARRAY
20862: PPUSH
20863: CALL_OW 546
20867: ST_TO_ADDR
// if hex [ 1 ] then
20868: LD_VAR 0 4
20872: PUSH
20873: LD_INT 1
20875: ARRAY
20876: IFFALSE 20880
// continue ;
20878: GO 20768
// h := hex [ 2 ] ;
20880: LD_ADDR_VAR 0 13
20884: PUSH
20885: LD_VAR 0 4
20889: PUSH
20890: LD_INT 2
20892: ARRAY
20893: ST_TO_ADDR
// if h + 7 < height then
20894: LD_VAR 0 13
20898: PUSH
20899: LD_INT 7
20901: PLUS
20902: PUSH
20903: LD_VAR 0 15
20907: LESS
20908: IFFALSE 20937
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20910: LD_ADDR_VAR 0 18
20914: PUSH
20915: LD_INT 7
20917: PUSH
20918: LD_INT 28
20920: PUSH
20921: LD_INT 45
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: LIST
20928: PUSH
20929: LD_VAR 0 12
20933: ARRAY
20934: ST_TO_ADDR
// break ;
20935: GO 20939
// end ; end ; end ;
20937: GO 20768
20939: POP
20940: POP
// end ; if not weapon then
20941: LD_VAR 0 18
20945: NOT
20946: IFFALSE 21006
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20948: LD_ADDR_VAR 0 5
20952: PUSH
20953: LD_VAR 0 5
20957: PUSH
20958: LD_INT 11
20960: PUSH
20961: LD_INT 30
20963: PUSH
20964: LD_INT 49
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: LIST
20971: DIFF
20972: ST_TO_ADDR
// if not list then
20973: LD_VAR 0 5
20977: NOT
20978: IFFALSE 20982
// exit ;
20980: GO 21124
// weapon := list [ rand ( 1 , list ) ] ;
20982: LD_ADDR_VAR 0 18
20986: PUSH
20987: LD_VAR 0 5
20991: PUSH
20992: LD_INT 1
20994: PPUSH
20995: LD_VAR 0 5
20999: PPUSH
21000: CALL_OW 12
21004: ARRAY
21005: ST_TO_ADDR
// end ; if weapon then
21006: LD_VAR 0 18
21010: IFFALSE 21124
// begin tmp := CostOfWeapon ( weapon ) ;
21012: LD_ADDR_VAR 0 14
21016: PUSH
21017: LD_VAR 0 18
21021: PPUSH
21022: CALL_OW 451
21026: ST_TO_ADDR
// j := GetBase ( tower ) ;
21027: LD_ADDR_VAR 0 9
21031: PUSH
21032: LD_VAR 0 1
21036: PPUSH
21037: CALL_OW 274
21041: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21042: LD_VAR 0 9
21046: PPUSH
21047: LD_INT 1
21049: PPUSH
21050: CALL_OW 275
21054: PUSH
21055: LD_VAR 0 14
21059: PUSH
21060: LD_INT 1
21062: ARRAY
21063: GREATEREQUAL
21064: PUSH
21065: LD_VAR 0 9
21069: PPUSH
21070: LD_INT 2
21072: PPUSH
21073: CALL_OW 275
21077: PUSH
21078: LD_VAR 0 14
21082: PUSH
21083: LD_INT 2
21085: ARRAY
21086: GREATEREQUAL
21087: AND
21088: PUSH
21089: LD_VAR 0 9
21093: PPUSH
21094: LD_INT 3
21096: PPUSH
21097: CALL_OW 275
21101: PUSH
21102: LD_VAR 0 14
21106: PUSH
21107: LD_INT 3
21109: ARRAY
21110: GREATEREQUAL
21111: AND
21112: IFFALSE 21124
// result := weapon ;
21114: LD_ADDR_VAR 0 3
21118: PUSH
21119: LD_VAR 0 18
21123: ST_TO_ADDR
// end ; end ;
21124: LD_VAR 0 3
21128: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21129: LD_INT 0
21131: PPUSH
21132: PPUSH
// result := true ;
21133: LD_ADDR_VAR 0 3
21137: PUSH
21138: LD_INT 1
21140: ST_TO_ADDR
// if array1 = array2 then
21141: LD_VAR 0 1
21145: PUSH
21146: LD_VAR 0 2
21150: EQUAL
21151: IFFALSE 21211
// begin for i = 1 to array1 do
21153: LD_ADDR_VAR 0 4
21157: PUSH
21158: DOUBLE
21159: LD_INT 1
21161: DEC
21162: ST_TO_ADDR
21163: LD_VAR 0 1
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21207
// if array1 [ i ] <> array2 [ i ] then
21171: LD_VAR 0 1
21175: PUSH
21176: LD_VAR 0 4
21180: ARRAY
21181: PUSH
21182: LD_VAR 0 2
21186: PUSH
21187: LD_VAR 0 4
21191: ARRAY
21192: NONEQUAL
21193: IFFALSE 21205
// begin result := false ;
21195: LD_ADDR_VAR 0 3
21199: PUSH
21200: LD_INT 0
21202: ST_TO_ADDR
// break ;
21203: GO 21207
// end ;
21205: GO 21168
21207: POP
21208: POP
// end else
21209: GO 21219
// result := false ;
21211: LD_ADDR_VAR 0 3
21215: PUSH
21216: LD_INT 0
21218: ST_TO_ADDR
// end ;
21219: LD_VAR 0 3
21223: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21224: LD_INT 0
21226: PPUSH
21227: PPUSH
// if not array1 or not array2 then
21228: LD_VAR 0 1
21232: NOT
21233: PUSH
21234: LD_VAR 0 2
21238: NOT
21239: OR
21240: IFFALSE 21244
// exit ;
21242: GO 21308
// result := true ;
21244: LD_ADDR_VAR 0 3
21248: PUSH
21249: LD_INT 1
21251: ST_TO_ADDR
// for i = 1 to array1 do
21252: LD_ADDR_VAR 0 4
21256: PUSH
21257: DOUBLE
21258: LD_INT 1
21260: DEC
21261: ST_TO_ADDR
21262: LD_VAR 0 1
21266: PUSH
21267: FOR_TO
21268: IFFALSE 21306
// if array1 [ i ] <> array2 [ i ] then
21270: LD_VAR 0 1
21274: PUSH
21275: LD_VAR 0 4
21279: ARRAY
21280: PUSH
21281: LD_VAR 0 2
21285: PUSH
21286: LD_VAR 0 4
21290: ARRAY
21291: NONEQUAL
21292: IFFALSE 21304
// begin result := false ;
21294: LD_ADDR_VAR 0 3
21298: PUSH
21299: LD_INT 0
21301: ST_TO_ADDR
// break ;
21302: GO 21306
// end ;
21304: GO 21267
21306: POP
21307: POP
// end ;
21308: LD_VAR 0 3
21312: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21313: LD_INT 0
21315: PPUSH
21316: PPUSH
21317: PPUSH
// pom := GetBase ( fac ) ;
21318: LD_ADDR_VAR 0 5
21322: PUSH
21323: LD_VAR 0 1
21327: PPUSH
21328: CALL_OW 274
21332: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21333: LD_ADDR_VAR 0 4
21337: PUSH
21338: LD_VAR 0 2
21342: PUSH
21343: LD_INT 1
21345: ARRAY
21346: PPUSH
21347: LD_VAR 0 2
21351: PUSH
21352: LD_INT 2
21354: ARRAY
21355: PPUSH
21356: LD_VAR 0 2
21360: PUSH
21361: LD_INT 3
21363: ARRAY
21364: PPUSH
21365: LD_VAR 0 2
21369: PUSH
21370: LD_INT 4
21372: ARRAY
21373: PPUSH
21374: CALL_OW 449
21378: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21379: LD_ADDR_VAR 0 3
21383: PUSH
21384: LD_VAR 0 5
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: CALL_OW 275
21396: PUSH
21397: LD_VAR 0 4
21401: PUSH
21402: LD_INT 1
21404: ARRAY
21405: GREATEREQUAL
21406: PUSH
21407: LD_VAR 0 5
21411: PPUSH
21412: LD_INT 2
21414: PPUSH
21415: CALL_OW 275
21419: PUSH
21420: LD_VAR 0 4
21424: PUSH
21425: LD_INT 2
21427: ARRAY
21428: GREATEREQUAL
21429: AND
21430: PUSH
21431: LD_VAR 0 5
21435: PPUSH
21436: LD_INT 3
21438: PPUSH
21439: CALL_OW 275
21443: PUSH
21444: LD_VAR 0 4
21448: PUSH
21449: LD_INT 3
21451: ARRAY
21452: GREATEREQUAL
21453: AND
21454: ST_TO_ADDR
// end ;
21455: LD_VAR 0 3
21459: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21460: LD_INT 0
21462: PPUSH
21463: PPUSH
21464: PPUSH
21465: PPUSH
// pom := GetBase ( building ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_VAR 0 1
21475: PPUSH
21476: CALL_OW 274
21480: ST_TO_ADDR
// if not pom then
21481: LD_VAR 0 3
21485: NOT
21486: IFFALSE 21490
// exit ;
21488: GO 21660
// btype := GetBType ( building ) ;
21490: LD_ADDR_VAR 0 5
21494: PUSH
21495: LD_VAR 0 1
21499: PPUSH
21500: CALL_OW 266
21504: ST_TO_ADDR
// if btype = b_armoury then
21505: LD_VAR 0 5
21509: PUSH
21510: LD_INT 4
21512: EQUAL
21513: IFFALSE 21523
// btype := b_barracks ;
21515: LD_ADDR_VAR 0 5
21519: PUSH
21520: LD_INT 5
21522: ST_TO_ADDR
// if btype = b_depot then
21523: LD_VAR 0 5
21527: PUSH
21528: LD_INT 0
21530: EQUAL
21531: IFFALSE 21541
// btype := b_warehouse ;
21533: LD_ADDR_VAR 0 5
21537: PUSH
21538: LD_INT 1
21540: ST_TO_ADDR
// if btype = b_workshop then
21541: LD_VAR 0 5
21545: PUSH
21546: LD_INT 2
21548: EQUAL
21549: IFFALSE 21559
// btype := b_factory ;
21551: LD_ADDR_VAR 0 5
21555: PUSH
21556: LD_INT 3
21558: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21559: LD_ADDR_VAR 0 4
21563: PUSH
21564: LD_VAR 0 5
21568: PPUSH
21569: LD_VAR 0 1
21573: PPUSH
21574: CALL_OW 248
21578: PPUSH
21579: CALL_OW 450
21583: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21584: LD_ADDR_VAR 0 2
21588: PUSH
21589: LD_VAR 0 3
21593: PPUSH
21594: LD_INT 1
21596: PPUSH
21597: CALL_OW 275
21601: PUSH
21602: LD_VAR 0 4
21606: PUSH
21607: LD_INT 1
21609: ARRAY
21610: GREATEREQUAL
21611: PUSH
21612: LD_VAR 0 3
21616: PPUSH
21617: LD_INT 2
21619: PPUSH
21620: CALL_OW 275
21624: PUSH
21625: LD_VAR 0 4
21629: PUSH
21630: LD_INT 2
21632: ARRAY
21633: GREATEREQUAL
21634: AND
21635: PUSH
21636: LD_VAR 0 3
21640: PPUSH
21641: LD_INT 3
21643: PPUSH
21644: CALL_OW 275
21648: PUSH
21649: LD_VAR 0 4
21653: PUSH
21654: LD_INT 3
21656: ARRAY
21657: GREATEREQUAL
21658: AND
21659: ST_TO_ADDR
// end ;
21660: LD_VAR 0 2
21664: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21665: LD_INT 0
21667: PPUSH
21668: PPUSH
21669: PPUSH
// pom := GetBase ( building ) ;
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_VAR 0 1
21679: PPUSH
21680: CALL_OW 274
21684: ST_TO_ADDR
// if not pom then
21685: LD_VAR 0 4
21689: NOT
21690: IFFALSE 21694
// exit ;
21692: GO 21795
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21694: LD_ADDR_VAR 0 5
21698: PUSH
21699: LD_VAR 0 2
21703: PPUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: PPUSH
21714: CALL_OW 450
21718: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21719: LD_ADDR_VAR 0 3
21723: PUSH
21724: LD_VAR 0 4
21728: PPUSH
21729: LD_INT 1
21731: PPUSH
21732: CALL_OW 275
21736: PUSH
21737: LD_VAR 0 5
21741: PUSH
21742: LD_INT 1
21744: ARRAY
21745: GREATEREQUAL
21746: PUSH
21747: LD_VAR 0 4
21751: PPUSH
21752: LD_INT 2
21754: PPUSH
21755: CALL_OW 275
21759: PUSH
21760: LD_VAR 0 5
21764: PUSH
21765: LD_INT 2
21767: ARRAY
21768: GREATEREQUAL
21769: AND
21770: PUSH
21771: LD_VAR 0 4
21775: PPUSH
21776: LD_INT 3
21778: PPUSH
21779: CALL_OW 275
21783: PUSH
21784: LD_VAR 0 5
21788: PUSH
21789: LD_INT 3
21791: ARRAY
21792: GREATEREQUAL
21793: AND
21794: ST_TO_ADDR
// end ;
21795: LD_VAR 0 3
21799: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21800: LD_INT 0
21802: PPUSH
21803: PPUSH
21804: PPUSH
21805: PPUSH
21806: PPUSH
21807: PPUSH
21808: PPUSH
21809: PPUSH
21810: PPUSH
21811: PPUSH
21812: PPUSH
// result := false ;
21813: LD_ADDR_VAR 0 8
21817: PUSH
21818: LD_INT 0
21820: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21821: LD_VAR 0 5
21825: NOT
21826: PUSH
21827: LD_VAR 0 1
21831: NOT
21832: OR
21833: PUSH
21834: LD_VAR 0 2
21838: NOT
21839: OR
21840: PUSH
21841: LD_VAR 0 3
21845: NOT
21846: OR
21847: IFFALSE 21851
// exit ;
21849: GO 22665
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21851: LD_ADDR_VAR 0 14
21855: PUSH
21856: LD_VAR 0 1
21860: PPUSH
21861: LD_VAR 0 2
21865: PPUSH
21866: LD_VAR 0 3
21870: PPUSH
21871: LD_VAR 0 4
21875: PPUSH
21876: LD_VAR 0 5
21880: PUSH
21881: LD_INT 1
21883: ARRAY
21884: PPUSH
21885: CALL_OW 248
21889: PPUSH
21890: LD_INT 0
21892: PPUSH
21893: CALL 23898 0 6
21897: ST_TO_ADDR
// if not hexes then
21898: LD_VAR 0 14
21902: NOT
21903: IFFALSE 21907
// exit ;
21905: GO 22665
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21907: LD_ADDR_VAR 0 17
21911: PUSH
21912: LD_VAR 0 5
21916: PPUSH
21917: LD_INT 22
21919: PUSH
21920: LD_VAR 0 13
21924: PPUSH
21925: CALL_OW 255
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PUSH
21934: LD_INT 2
21936: PUSH
21937: LD_INT 30
21939: PUSH
21940: LD_INT 0
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: PUSH
21947: LD_INT 30
21949: PUSH
21950: LD_INT 1
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: PUSH
21957: EMPTY
21958: LIST
21959: LIST
21960: LIST
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: PPUSH
21966: CALL_OW 72
21970: ST_TO_ADDR
// for i = 1 to hexes do
21971: LD_ADDR_VAR 0 9
21975: PUSH
21976: DOUBLE
21977: LD_INT 1
21979: DEC
21980: ST_TO_ADDR
21981: LD_VAR 0 14
21985: PUSH
21986: FOR_TO
21987: IFFALSE 22663
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21989: LD_ADDR_VAR 0 13
21993: PUSH
21994: LD_VAR 0 14
21998: PUSH
21999: LD_VAR 0 9
22003: ARRAY
22004: PUSH
22005: LD_INT 1
22007: ARRAY
22008: PPUSH
22009: LD_VAR 0 14
22013: PUSH
22014: LD_VAR 0 9
22018: ARRAY
22019: PUSH
22020: LD_INT 2
22022: ARRAY
22023: PPUSH
22024: CALL_OW 428
22028: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22029: LD_VAR 0 14
22033: PUSH
22034: LD_VAR 0 9
22038: ARRAY
22039: PUSH
22040: LD_INT 1
22042: ARRAY
22043: PPUSH
22044: LD_VAR 0 14
22048: PUSH
22049: LD_VAR 0 9
22053: ARRAY
22054: PUSH
22055: LD_INT 2
22057: ARRAY
22058: PPUSH
22059: CALL_OW 351
22063: PUSH
22064: LD_VAR 0 14
22068: PUSH
22069: LD_VAR 0 9
22073: ARRAY
22074: PUSH
22075: LD_INT 1
22077: ARRAY
22078: PPUSH
22079: LD_VAR 0 14
22083: PUSH
22084: LD_VAR 0 9
22088: ARRAY
22089: PUSH
22090: LD_INT 2
22092: ARRAY
22093: PPUSH
22094: CALL_OW 488
22098: NOT
22099: OR
22100: PUSH
22101: LD_VAR 0 13
22105: PPUSH
22106: CALL_OW 247
22110: PUSH
22111: LD_INT 3
22113: EQUAL
22114: OR
22115: IFFALSE 22121
// exit ;
22117: POP
22118: POP
22119: GO 22665
// if not tmp then
22121: LD_VAR 0 13
22125: NOT
22126: IFFALSE 22130
// continue ;
22128: GO 21986
// result := true ;
22130: LD_ADDR_VAR 0 8
22134: PUSH
22135: LD_INT 1
22137: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22138: LD_VAR 0 6
22142: PUSH
22143: LD_VAR 0 13
22147: PPUSH
22148: CALL_OW 247
22152: PUSH
22153: LD_INT 2
22155: EQUAL
22156: AND
22157: PUSH
22158: LD_VAR 0 13
22162: PPUSH
22163: CALL_OW 263
22167: PUSH
22168: LD_INT 1
22170: EQUAL
22171: AND
22172: IFFALSE 22336
// begin if IsDrivenBy ( tmp ) then
22174: LD_VAR 0 13
22178: PPUSH
22179: CALL_OW 311
22183: IFFALSE 22187
// continue ;
22185: GO 21986
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22187: LD_VAR 0 6
22191: PPUSH
22192: LD_INT 3
22194: PUSH
22195: LD_INT 60
22197: PUSH
22198: EMPTY
22199: LIST
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: LD_INT 55
22210: PUSH
22211: EMPTY
22212: LIST
22213: PUSH
22214: EMPTY
22215: LIST
22216: LIST
22217: PUSH
22218: EMPTY
22219: LIST
22220: LIST
22221: PPUSH
22222: CALL_OW 72
22226: IFFALSE 22334
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22228: LD_ADDR_VAR 0 18
22232: PUSH
22233: LD_VAR 0 6
22237: PPUSH
22238: LD_INT 3
22240: PUSH
22241: LD_INT 60
22243: PUSH
22244: EMPTY
22245: LIST
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: LD_INT 3
22253: PUSH
22254: LD_INT 55
22256: PUSH
22257: EMPTY
22258: LIST
22259: PUSH
22260: EMPTY
22261: LIST
22262: LIST
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: PPUSH
22268: CALL_OW 72
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: ST_TO_ADDR
// if IsInUnit ( driver ) then
22277: LD_VAR 0 18
22281: PPUSH
22282: CALL_OW 310
22286: IFFALSE 22297
// ComExit ( driver ) ;
22288: LD_VAR 0 18
22292: PPUSH
22293: CALL 47678 0 1
// AddComEnterUnit ( driver , tmp ) ;
22297: LD_VAR 0 18
22301: PPUSH
22302: LD_VAR 0 13
22306: PPUSH
22307: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22311: LD_VAR 0 18
22315: PPUSH
22316: LD_VAR 0 7
22320: PPUSH
22321: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22325: LD_VAR 0 18
22329: PPUSH
22330: CALL_OW 181
// end ; continue ;
22334: GO 21986
// end ; if not cleaners or not tmp in cleaners then
22336: LD_VAR 0 6
22340: NOT
22341: PUSH
22342: LD_VAR 0 13
22346: PUSH
22347: LD_VAR 0 6
22351: IN
22352: NOT
22353: OR
22354: IFFALSE 22661
// begin if dep then
22356: LD_VAR 0 17
22360: IFFALSE 22496
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22362: LD_ADDR_VAR 0 16
22366: PUSH
22367: LD_VAR 0 17
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 250
22380: PPUSH
22381: LD_VAR 0 17
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PPUSH
22390: CALL_OW 254
22394: PPUSH
22395: LD_INT 5
22397: PPUSH
22398: CALL_OW 272
22402: PUSH
22403: LD_VAR 0 17
22407: PUSH
22408: LD_INT 1
22410: ARRAY
22411: PPUSH
22412: CALL_OW 251
22416: PPUSH
22417: LD_VAR 0 17
22421: PUSH
22422: LD_INT 1
22424: ARRAY
22425: PPUSH
22426: CALL_OW 254
22430: PPUSH
22431: LD_INT 5
22433: PPUSH
22434: CALL_OW 273
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22443: LD_VAR 0 16
22447: PUSH
22448: LD_INT 1
22450: ARRAY
22451: PPUSH
22452: LD_VAR 0 16
22456: PUSH
22457: LD_INT 2
22459: ARRAY
22460: PPUSH
22461: CALL_OW 488
22465: IFFALSE 22496
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22467: LD_VAR 0 13
22471: PPUSH
22472: LD_VAR 0 16
22476: PUSH
22477: LD_INT 1
22479: ARRAY
22480: PPUSH
22481: LD_VAR 0 16
22485: PUSH
22486: LD_INT 2
22488: ARRAY
22489: PPUSH
22490: CALL_OW 111
// continue ;
22494: GO 21986
// end ; end ; r := GetDir ( tmp ) ;
22496: LD_ADDR_VAR 0 15
22500: PUSH
22501: LD_VAR 0 13
22505: PPUSH
22506: CALL_OW 254
22510: ST_TO_ADDR
// if r = 5 then
22511: LD_VAR 0 15
22515: PUSH
22516: LD_INT 5
22518: EQUAL
22519: IFFALSE 22529
// r := 0 ;
22521: LD_ADDR_VAR 0 15
22525: PUSH
22526: LD_INT 0
22528: ST_TO_ADDR
// for j = r to 5 do
22529: LD_ADDR_VAR 0 10
22533: PUSH
22534: DOUBLE
22535: LD_VAR 0 15
22539: DEC
22540: ST_TO_ADDR
22541: LD_INT 5
22543: PUSH
22544: FOR_TO
22545: IFFALSE 22659
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22547: LD_ADDR_VAR 0 11
22551: PUSH
22552: LD_VAR 0 13
22556: PPUSH
22557: CALL_OW 250
22561: PPUSH
22562: LD_VAR 0 10
22566: PPUSH
22567: LD_INT 2
22569: PPUSH
22570: CALL_OW 272
22574: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22575: LD_ADDR_VAR 0 12
22579: PUSH
22580: LD_VAR 0 13
22584: PPUSH
22585: CALL_OW 251
22589: PPUSH
22590: LD_VAR 0 10
22594: PPUSH
22595: LD_INT 2
22597: PPUSH
22598: CALL_OW 273
22602: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22603: LD_VAR 0 11
22607: PPUSH
22608: LD_VAR 0 12
22612: PPUSH
22613: CALL_OW 488
22617: PUSH
22618: LD_VAR 0 11
22622: PPUSH
22623: LD_VAR 0 12
22627: PPUSH
22628: CALL_OW 428
22632: NOT
22633: AND
22634: IFFALSE 22657
// begin ComMoveXY ( tmp , _x , _y ) ;
22636: LD_VAR 0 13
22640: PPUSH
22641: LD_VAR 0 11
22645: PPUSH
22646: LD_VAR 0 12
22650: PPUSH
22651: CALL_OW 111
// break ;
22655: GO 22659
// end ; end ;
22657: GO 22544
22659: POP
22660: POP
// end ; end ;
22661: GO 21986
22663: POP
22664: POP
// end ;
22665: LD_VAR 0 8
22669: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22670: LD_INT 0
22672: PPUSH
// result := true ;
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: LD_INT 1
22680: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22681: LD_VAR 0 2
22685: PUSH
22686: LD_INT 24
22688: DOUBLE
22689: EQUAL
22690: IFTRUE 22700
22692: LD_INT 33
22694: DOUBLE
22695: EQUAL
22696: IFTRUE 22700
22698: GO 22725
22700: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22701: LD_ADDR_VAR 0 3
22705: PUSH
22706: LD_INT 32
22708: PPUSH
22709: LD_VAR 0 1
22713: PPUSH
22714: CALL_OW 321
22718: PUSH
22719: LD_INT 2
22721: EQUAL
22722: ST_TO_ADDR
22723: GO 23041
22725: LD_INT 20
22727: DOUBLE
22728: EQUAL
22729: IFTRUE 22733
22731: GO 22758
22733: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22734: LD_ADDR_VAR 0 3
22738: PUSH
22739: LD_INT 6
22741: PPUSH
22742: LD_VAR 0 1
22746: PPUSH
22747: CALL_OW 321
22751: PUSH
22752: LD_INT 2
22754: EQUAL
22755: ST_TO_ADDR
22756: GO 23041
22758: LD_INT 22
22760: DOUBLE
22761: EQUAL
22762: IFTRUE 22772
22764: LD_INT 36
22766: DOUBLE
22767: EQUAL
22768: IFTRUE 22772
22770: GO 22797
22772: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22773: LD_ADDR_VAR 0 3
22777: PUSH
22778: LD_INT 15
22780: PPUSH
22781: LD_VAR 0 1
22785: PPUSH
22786: CALL_OW 321
22790: PUSH
22791: LD_INT 2
22793: EQUAL
22794: ST_TO_ADDR
22795: GO 23041
22797: LD_INT 30
22799: DOUBLE
22800: EQUAL
22801: IFTRUE 22805
22803: GO 22830
22805: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22806: LD_ADDR_VAR 0 3
22810: PUSH
22811: LD_INT 20
22813: PPUSH
22814: LD_VAR 0 1
22818: PPUSH
22819: CALL_OW 321
22823: PUSH
22824: LD_INT 2
22826: EQUAL
22827: ST_TO_ADDR
22828: GO 23041
22830: LD_INT 28
22832: DOUBLE
22833: EQUAL
22834: IFTRUE 22844
22836: LD_INT 21
22838: DOUBLE
22839: EQUAL
22840: IFTRUE 22844
22842: GO 22869
22844: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22845: LD_ADDR_VAR 0 3
22849: PUSH
22850: LD_INT 21
22852: PPUSH
22853: LD_VAR 0 1
22857: PPUSH
22858: CALL_OW 321
22862: PUSH
22863: LD_INT 2
22865: EQUAL
22866: ST_TO_ADDR
22867: GO 23041
22869: LD_INT 16
22871: DOUBLE
22872: EQUAL
22873: IFTRUE 22877
22875: GO 22902
22877: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_INT 84
22885: PPUSH
22886: LD_VAR 0 1
22890: PPUSH
22891: CALL_OW 321
22895: PUSH
22896: LD_INT 2
22898: EQUAL
22899: ST_TO_ADDR
22900: GO 23041
22902: LD_INT 19
22904: DOUBLE
22905: EQUAL
22906: IFTRUE 22916
22908: LD_INT 23
22910: DOUBLE
22911: EQUAL
22912: IFTRUE 22916
22914: GO 22941
22916: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_INT 83
22924: PPUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 321
22934: PUSH
22935: LD_INT 2
22937: EQUAL
22938: ST_TO_ADDR
22939: GO 23041
22941: LD_INT 17
22943: DOUBLE
22944: EQUAL
22945: IFTRUE 22949
22947: GO 22974
22949: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22950: LD_ADDR_VAR 0 3
22954: PUSH
22955: LD_INT 39
22957: PPUSH
22958: LD_VAR 0 1
22962: PPUSH
22963: CALL_OW 321
22967: PUSH
22968: LD_INT 2
22970: EQUAL
22971: ST_TO_ADDR
22972: GO 23041
22974: LD_INT 18
22976: DOUBLE
22977: EQUAL
22978: IFTRUE 22982
22980: GO 23007
22982: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22983: LD_ADDR_VAR 0 3
22987: PUSH
22988: LD_INT 40
22990: PPUSH
22991: LD_VAR 0 1
22995: PPUSH
22996: CALL_OW 321
23000: PUSH
23001: LD_INT 2
23003: EQUAL
23004: ST_TO_ADDR
23005: GO 23041
23007: LD_INT 27
23009: DOUBLE
23010: EQUAL
23011: IFTRUE 23015
23013: GO 23040
23015: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23016: LD_ADDR_VAR 0 3
23020: PUSH
23021: LD_INT 35
23023: PPUSH
23024: LD_VAR 0 1
23028: PPUSH
23029: CALL_OW 321
23033: PUSH
23034: LD_INT 2
23036: EQUAL
23037: ST_TO_ADDR
23038: GO 23041
23040: POP
// end ;
23041: LD_VAR 0 3
23045: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23046: LD_INT 0
23048: PPUSH
23049: PPUSH
23050: PPUSH
23051: PPUSH
23052: PPUSH
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
// result := false ;
23059: LD_ADDR_VAR 0 6
23063: PUSH
23064: LD_INT 0
23066: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23067: LD_VAR 0 1
23071: NOT
23072: PUSH
23073: LD_VAR 0 1
23077: PPUSH
23078: CALL_OW 266
23082: PUSH
23083: LD_INT 0
23085: PUSH
23086: LD_INT 1
23088: PUSH
23089: EMPTY
23090: LIST
23091: LIST
23092: IN
23093: NOT
23094: OR
23095: PUSH
23096: LD_VAR 0 2
23100: NOT
23101: OR
23102: PUSH
23103: LD_VAR 0 5
23107: PUSH
23108: LD_INT 0
23110: PUSH
23111: LD_INT 1
23113: PUSH
23114: LD_INT 2
23116: PUSH
23117: LD_INT 3
23119: PUSH
23120: LD_INT 4
23122: PUSH
23123: LD_INT 5
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: LIST
23130: LIST
23131: LIST
23132: LIST
23133: IN
23134: NOT
23135: OR
23136: PUSH
23137: LD_VAR 0 3
23141: PPUSH
23142: LD_VAR 0 4
23146: PPUSH
23147: CALL_OW 488
23151: NOT
23152: OR
23153: IFFALSE 23157
// exit ;
23155: GO 23893
// side := GetSide ( depot ) ;
23157: LD_ADDR_VAR 0 9
23161: PUSH
23162: LD_VAR 0 1
23166: PPUSH
23167: CALL_OW 255
23171: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23172: LD_VAR 0 9
23176: PPUSH
23177: LD_VAR 0 2
23181: PPUSH
23182: CALL 22670 0 2
23186: NOT
23187: IFFALSE 23191
// exit ;
23189: GO 23893
// pom := GetBase ( depot ) ;
23191: LD_ADDR_VAR 0 10
23195: PUSH
23196: LD_VAR 0 1
23200: PPUSH
23201: CALL_OW 274
23205: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23206: LD_ADDR_VAR 0 11
23210: PUSH
23211: LD_VAR 0 2
23215: PPUSH
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 248
23225: PPUSH
23226: CALL_OW 450
23230: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23231: LD_VAR 0 10
23235: PPUSH
23236: LD_INT 1
23238: PPUSH
23239: CALL_OW 275
23243: PUSH
23244: LD_VAR 0 11
23248: PUSH
23249: LD_INT 1
23251: ARRAY
23252: GREATEREQUAL
23253: PUSH
23254: LD_VAR 0 10
23258: PPUSH
23259: LD_INT 2
23261: PPUSH
23262: CALL_OW 275
23266: PUSH
23267: LD_VAR 0 11
23271: PUSH
23272: LD_INT 2
23274: ARRAY
23275: GREATEREQUAL
23276: AND
23277: PUSH
23278: LD_VAR 0 10
23282: PPUSH
23283: LD_INT 3
23285: PPUSH
23286: CALL_OW 275
23290: PUSH
23291: LD_VAR 0 11
23295: PUSH
23296: LD_INT 3
23298: ARRAY
23299: GREATEREQUAL
23300: AND
23301: NOT
23302: IFFALSE 23306
// exit ;
23304: GO 23893
// if GetBType ( depot ) = b_depot then
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 266
23315: PUSH
23316: LD_INT 0
23318: EQUAL
23319: IFFALSE 23331
// dist := 28 else
23321: LD_ADDR_VAR 0 14
23325: PUSH
23326: LD_INT 28
23328: ST_TO_ADDR
23329: GO 23339
// dist := 36 ;
23331: LD_ADDR_VAR 0 14
23335: PUSH
23336: LD_INT 36
23338: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23339: LD_VAR 0 1
23343: PPUSH
23344: LD_VAR 0 3
23348: PPUSH
23349: LD_VAR 0 4
23353: PPUSH
23354: CALL_OW 297
23358: PUSH
23359: LD_VAR 0 14
23363: GREATER
23364: IFFALSE 23368
// exit ;
23366: GO 23893
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23368: LD_ADDR_VAR 0 12
23372: PUSH
23373: LD_VAR 0 2
23377: PPUSH
23378: LD_VAR 0 3
23382: PPUSH
23383: LD_VAR 0 4
23387: PPUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 1
23397: PPUSH
23398: CALL_OW 248
23402: PPUSH
23403: LD_INT 0
23405: PPUSH
23406: CALL 23898 0 6
23410: ST_TO_ADDR
// if not hexes then
23411: LD_VAR 0 12
23415: NOT
23416: IFFALSE 23420
// exit ;
23418: GO 23893
// hex := GetHexInfo ( x , y ) ;
23420: LD_ADDR_VAR 0 15
23424: PUSH
23425: LD_VAR 0 3
23429: PPUSH
23430: LD_VAR 0 4
23434: PPUSH
23435: CALL_OW 546
23439: ST_TO_ADDR
// if hex [ 1 ] then
23440: LD_VAR 0 15
23444: PUSH
23445: LD_INT 1
23447: ARRAY
23448: IFFALSE 23452
// exit ;
23450: GO 23893
// height := hex [ 2 ] ;
23452: LD_ADDR_VAR 0 13
23456: PUSH
23457: LD_VAR 0 15
23461: PUSH
23462: LD_INT 2
23464: ARRAY
23465: ST_TO_ADDR
// for i = 1 to hexes do
23466: LD_ADDR_VAR 0 7
23470: PUSH
23471: DOUBLE
23472: LD_INT 1
23474: DEC
23475: ST_TO_ADDR
23476: LD_VAR 0 12
23480: PUSH
23481: FOR_TO
23482: IFFALSE 23812
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23484: LD_VAR 0 12
23488: PUSH
23489: LD_VAR 0 7
23493: ARRAY
23494: PUSH
23495: LD_INT 1
23497: ARRAY
23498: PPUSH
23499: LD_VAR 0 12
23503: PUSH
23504: LD_VAR 0 7
23508: ARRAY
23509: PUSH
23510: LD_INT 2
23512: ARRAY
23513: PPUSH
23514: CALL_OW 488
23518: NOT
23519: PUSH
23520: LD_VAR 0 12
23524: PUSH
23525: LD_VAR 0 7
23529: ARRAY
23530: PUSH
23531: LD_INT 1
23533: ARRAY
23534: PPUSH
23535: LD_VAR 0 12
23539: PUSH
23540: LD_VAR 0 7
23544: ARRAY
23545: PUSH
23546: LD_INT 2
23548: ARRAY
23549: PPUSH
23550: CALL_OW 428
23554: PUSH
23555: LD_INT 0
23557: GREATER
23558: OR
23559: PUSH
23560: LD_VAR 0 12
23564: PUSH
23565: LD_VAR 0 7
23569: ARRAY
23570: PUSH
23571: LD_INT 1
23573: ARRAY
23574: PPUSH
23575: LD_VAR 0 12
23579: PUSH
23580: LD_VAR 0 7
23584: ARRAY
23585: PUSH
23586: LD_INT 2
23588: ARRAY
23589: PPUSH
23590: CALL_OW 351
23594: OR
23595: IFFALSE 23601
// exit ;
23597: POP
23598: POP
23599: GO 23893
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23601: LD_ADDR_VAR 0 8
23605: PUSH
23606: LD_VAR 0 12
23610: PUSH
23611: LD_VAR 0 7
23615: ARRAY
23616: PUSH
23617: LD_INT 1
23619: ARRAY
23620: PPUSH
23621: LD_VAR 0 12
23625: PUSH
23626: LD_VAR 0 7
23630: ARRAY
23631: PUSH
23632: LD_INT 2
23634: ARRAY
23635: PPUSH
23636: CALL_OW 546
23640: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23641: LD_VAR 0 8
23645: PUSH
23646: LD_INT 1
23648: ARRAY
23649: PUSH
23650: LD_VAR 0 8
23654: PUSH
23655: LD_INT 2
23657: ARRAY
23658: PUSH
23659: LD_VAR 0 13
23663: PUSH
23664: LD_INT 2
23666: PLUS
23667: GREATER
23668: OR
23669: PUSH
23670: LD_VAR 0 8
23674: PUSH
23675: LD_INT 2
23677: ARRAY
23678: PUSH
23679: LD_VAR 0 13
23683: PUSH
23684: LD_INT 2
23686: MINUS
23687: LESS
23688: OR
23689: PUSH
23690: LD_VAR 0 8
23694: PUSH
23695: LD_INT 3
23697: ARRAY
23698: PUSH
23699: LD_INT 0
23701: PUSH
23702: LD_INT 8
23704: PUSH
23705: LD_INT 9
23707: PUSH
23708: LD_INT 10
23710: PUSH
23711: LD_INT 11
23713: PUSH
23714: LD_INT 12
23716: PUSH
23717: LD_INT 13
23719: PUSH
23720: LD_INT 16
23722: PUSH
23723: LD_INT 17
23725: PUSH
23726: LD_INT 18
23728: PUSH
23729: LD_INT 19
23731: PUSH
23732: LD_INT 20
23734: PUSH
23735: LD_INT 21
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: LIST
23744: LIST
23745: LIST
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: LIST
23752: IN
23753: NOT
23754: OR
23755: PUSH
23756: LD_VAR 0 8
23760: PUSH
23761: LD_INT 5
23763: ARRAY
23764: NOT
23765: OR
23766: PUSH
23767: LD_VAR 0 8
23771: PUSH
23772: LD_INT 6
23774: ARRAY
23775: PUSH
23776: LD_INT 1
23778: PUSH
23779: LD_INT 2
23781: PUSH
23782: LD_INT 7
23784: PUSH
23785: LD_INT 9
23787: PUSH
23788: LD_INT 10
23790: PUSH
23791: LD_INT 11
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: LIST
23798: LIST
23799: LIST
23800: LIST
23801: IN
23802: NOT
23803: OR
23804: IFFALSE 23810
// exit ;
23806: POP
23807: POP
23808: GO 23893
// end ;
23810: GO 23481
23812: POP
23813: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23814: LD_VAR 0 9
23818: PPUSH
23819: LD_VAR 0 3
23823: PPUSH
23824: LD_VAR 0 4
23828: PPUSH
23829: LD_INT 20
23831: PPUSH
23832: CALL 15845 0 4
23836: PUSH
23837: LD_INT 4
23839: ARRAY
23840: IFFALSE 23844
// exit ;
23842: GO 23893
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23844: LD_VAR 0 2
23848: PUSH
23849: LD_INT 29
23851: PUSH
23852: LD_INT 30
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: IN
23859: PUSH
23860: LD_VAR 0 3
23864: PPUSH
23865: LD_VAR 0 4
23869: PPUSH
23870: LD_VAR 0 9
23874: PPUSH
23875: CALL_OW 440
23879: NOT
23880: AND
23881: IFFALSE 23885
// exit ;
23883: GO 23893
// result := true ;
23885: LD_ADDR_VAR 0 6
23889: PUSH
23890: LD_INT 1
23892: ST_TO_ADDR
// end ;
23893: LD_VAR 0 6
23897: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23898: LD_INT 0
23900: PPUSH
23901: PPUSH
23902: PPUSH
23903: PPUSH
23904: PPUSH
23905: PPUSH
23906: PPUSH
23907: PPUSH
23908: PPUSH
23909: PPUSH
23910: PPUSH
23911: PPUSH
23912: PPUSH
23913: PPUSH
23914: PPUSH
23915: PPUSH
23916: PPUSH
23917: PPUSH
23918: PPUSH
23919: PPUSH
23920: PPUSH
23921: PPUSH
23922: PPUSH
23923: PPUSH
23924: PPUSH
23925: PPUSH
23926: PPUSH
23927: PPUSH
23928: PPUSH
23929: PPUSH
23930: PPUSH
23931: PPUSH
23932: PPUSH
23933: PPUSH
23934: PPUSH
23935: PPUSH
23936: PPUSH
23937: PPUSH
23938: PPUSH
23939: PPUSH
23940: PPUSH
23941: PPUSH
23942: PPUSH
23943: PPUSH
23944: PPUSH
23945: PPUSH
23946: PPUSH
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
// result = [ ] ;
23958: LD_ADDR_VAR 0 7
23962: PUSH
23963: EMPTY
23964: ST_TO_ADDR
// temp_list = [ ] ;
23965: LD_ADDR_VAR 0 9
23969: PUSH
23970: EMPTY
23971: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23972: LD_VAR 0 4
23976: PUSH
23977: LD_INT 0
23979: PUSH
23980: LD_INT 1
23982: PUSH
23983: LD_INT 2
23985: PUSH
23986: LD_INT 3
23988: PUSH
23989: LD_INT 4
23991: PUSH
23992: LD_INT 5
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: LIST
23999: LIST
24000: LIST
24001: LIST
24002: IN
24003: NOT
24004: PUSH
24005: LD_VAR 0 1
24009: PUSH
24010: LD_INT 0
24012: PUSH
24013: LD_INT 1
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: IN
24020: PUSH
24021: LD_VAR 0 5
24025: PUSH
24026: LD_INT 1
24028: PUSH
24029: LD_INT 2
24031: PUSH
24032: LD_INT 3
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: LIST
24039: IN
24040: NOT
24041: AND
24042: OR
24043: IFFALSE 24047
// exit ;
24045: GO 42438
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24047: LD_VAR 0 1
24051: PUSH
24052: LD_INT 6
24054: PUSH
24055: LD_INT 7
24057: PUSH
24058: LD_INT 8
24060: PUSH
24061: LD_INT 13
24063: PUSH
24064: LD_INT 12
24066: PUSH
24067: LD_INT 15
24069: PUSH
24070: LD_INT 11
24072: PUSH
24073: LD_INT 14
24075: PUSH
24076: LD_INT 10
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: IN
24090: IFFALSE 24100
// btype = b_lab ;
24092: LD_ADDR_VAR 0 1
24096: PUSH
24097: LD_INT 6
24099: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24100: LD_VAR 0 6
24104: PUSH
24105: LD_INT 0
24107: PUSH
24108: LD_INT 1
24110: PUSH
24111: LD_INT 2
24113: PUSH
24114: EMPTY
24115: LIST
24116: LIST
24117: LIST
24118: IN
24119: NOT
24120: PUSH
24121: LD_VAR 0 1
24125: PUSH
24126: LD_INT 0
24128: PUSH
24129: LD_INT 1
24131: PUSH
24132: LD_INT 2
24134: PUSH
24135: LD_INT 3
24137: PUSH
24138: LD_INT 6
24140: PUSH
24141: LD_INT 36
24143: PUSH
24144: LD_INT 4
24146: PUSH
24147: LD_INT 5
24149: PUSH
24150: LD_INT 31
24152: PUSH
24153: LD_INT 32
24155: PUSH
24156: LD_INT 33
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: LIST
24171: IN
24172: NOT
24173: PUSH
24174: LD_VAR 0 6
24178: PUSH
24179: LD_INT 1
24181: EQUAL
24182: AND
24183: OR
24184: PUSH
24185: LD_VAR 0 1
24189: PUSH
24190: LD_INT 2
24192: PUSH
24193: LD_INT 3
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: IN
24200: NOT
24201: PUSH
24202: LD_VAR 0 6
24206: PUSH
24207: LD_INT 2
24209: EQUAL
24210: AND
24211: OR
24212: IFFALSE 24222
// mode = 0 ;
24214: LD_ADDR_VAR 0 6
24218: PUSH
24219: LD_INT 0
24221: ST_TO_ADDR
// case mode of 0 :
24222: LD_VAR 0 6
24226: PUSH
24227: LD_INT 0
24229: DOUBLE
24230: EQUAL
24231: IFTRUE 24235
24233: GO 35688
24235: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24236: LD_ADDR_VAR 0 11
24240: PUSH
24241: LD_INT 0
24243: PUSH
24244: LD_INT 0
24246: PUSH
24247: EMPTY
24248: LIST
24249: LIST
24250: PUSH
24251: LD_INT 0
24253: PUSH
24254: LD_INT 1
24256: NEG
24257: PUSH
24258: EMPTY
24259: LIST
24260: LIST
24261: PUSH
24262: LD_INT 1
24264: PUSH
24265: LD_INT 0
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: PUSH
24272: LD_INT 1
24274: PUSH
24275: LD_INT 1
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 0
24284: PUSH
24285: LD_INT 1
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: LD_INT 1
24294: NEG
24295: PUSH
24296: LD_INT 0
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PUSH
24303: LD_INT 1
24305: NEG
24306: PUSH
24307: LD_INT 1
24309: NEG
24310: PUSH
24311: EMPTY
24312: LIST
24313: LIST
24314: PUSH
24315: LD_INT 1
24317: NEG
24318: PUSH
24319: LD_INT 2
24321: NEG
24322: PUSH
24323: EMPTY
24324: LIST
24325: LIST
24326: PUSH
24327: LD_INT 0
24329: PUSH
24330: LD_INT 2
24332: NEG
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 1
24340: PUSH
24341: LD_INT 1
24343: NEG
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 1
24351: PUSH
24352: LD_INT 2
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 0
24361: PUSH
24362: LD_INT 2
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 1
24371: NEG
24372: PUSH
24373: LD_INT 1
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: PUSH
24380: LD_INT 1
24382: PUSH
24383: LD_INT 3
24385: PUSH
24386: EMPTY
24387: LIST
24388: LIST
24389: PUSH
24390: LD_INT 0
24392: PUSH
24393: LD_INT 3
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 1
24402: NEG
24403: PUSH
24404: LD_INT 2
24406: PUSH
24407: EMPTY
24408: LIST
24409: LIST
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: LIST
24415: LIST
24416: LIST
24417: LIST
24418: LIST
24419: LIST
24420: LIST
24421: LIST
24422: LIST
24423: LIST
24424: LIST
24425: LIST
24426: LIST
24427: LIST
24428: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24429: LD_ADDR_VAR 0 12
24433: PUSH
24434: LD_INT 0
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 0
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 1
24457: PUSH
24458: LD_INT 0
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 1
24467: PUSH
24468: LD_INT 1
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 0
24477: PUSH
24478: LD_INT 1
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 1
24487: NEG
24488: PUSH
24489: LD_INT 0
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PUSH
24496: LD_INT 1
24498: NEG
24499: PUSH
24500: LD_INT 1
24502: NEG
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: PUSH
24508: LD_INT 1
24510: PUSH
24511: LD_INT 1
24513: NEG
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PUSH
24519: LD_INT 2
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: LD_INT 2
24531: PUSH
24532: LD_INT 1
24534: PUSH
24535: EMPTY
24536: LIST
24537: LIST
24538: PUSH
24539: LD_INT 1
24541: NEG
24542: PUSH
24543: LD_INT 1
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: PUSH
24550: LD_INT 2
24552: NEG
24553: PUSH
24554: LD_INT 0
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 2
24563: NEG
24564: PUSH
24565: LD_INT 1
24567: NEG
24568: PUSH
24569: EMPTY
24570: LIST
24571: LIST
24572: PUSH
24573: LD_INT 2
24575: NEG
24576: PUSH
24577: LD_INT 1
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: LD_INT 3
24586: NEG
24587: PUSH
24588: LD_INT 0
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: PUSH
24595: LD_INT 3
24597: NEG
24598: PUSH
24599: LD_INT 1
24601: NEG
24602: PUSH
24603: EMPTY
24604: LIST
24605: LIST
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: LIST
24613: LIST
24614: LIST
24615: LIST
24616: LIST
24617: LIST
24618: LIST
24619: LIST
24620: LIST
24621: LIST
24622: LIST
24623: LIST
24624: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24625: LD_ADDR_VAR 0 13
24629: PUSH
24630: LD_INT 0
24632: PUSH
24633: LD_INT 0
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 0
24642: PUSH
24643: LD_INT 1
24645: NEG
24646: PUSH
24647: EMPTY
24648: LIST
24649: LIST
24650: PUSH
24651: LD_INT 1
24653: PUSH
24654: LD_INT 0
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 1
24663: PUSH
24664: LD_INT 1
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: LD_INT 0
24673: PUSH
24674: LD_INT 1
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: PUSH
24681: LD_INT 1
24683: NEG
24684: PUSH
24685: LD_INT 0
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: PUSH
24692: LD_INT 1
24694: NEG
24695: PUSH
24696: LD_INT 1
24698: NEG
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 1
24706: NEG
24707: PUSH
24708: LD_INT 2
24710: NEG
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: LD_INT 2
24718: PUSH
24719: LD_INT 1
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PUSH
24726: LD_INT 2
24728: PUSH
24729: LD_INT 2
24731: PUSH
24732: EMPTY
24733: LIST
24734: LIST
24735: PUSH
24736: LD_INT 1
24738: PUSH
24739: LD_INT 2
24741: PUSH
24742: EMPTY
24743: LIST
24744: LIST
24745: PUSH
24746: LD_INT 2
24748: NEG
24749: PUSH
24750: LD_INT 1
24752: NEG
24753: PUSH
24754: EMPTY
24755: LIST
24756: LIST
24757: PUSH
24758: LD_INT 2
24760: NEG
24761: PUSH
24762: LD_INT 2
24764: NEG
24765: PUSH
24766: EMPTY
24767: LIST
24768: LIST
24769: PUSH
24770: LD_INT 2
24772: NEG
24773: PUSH
24774: LD_INT 3
24776: NEG
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: PUSH
24782: LD_INT 3
24784: NEG
24785: PUSH
24786: LD_INT 2
24788: NEG
24789: PUSH
24790: EMPTY
24791: LIST
24792: LIST
24793: PUSH
24794: LD_INT 3
24796: NEG
24797: PUSH
24798: LD_INT 3
24800: NEG
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: LIST
24810: LIST
24811: LIST
24812: LIST
24813: LIST
24814: LIST
24815: LIST
24816: LIST
24817: LIST
24818: LIST
24819: LIST
24820: LIST
24821: LIST
24822: LIST
24823: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24824: LD_ADDR_VAR 0 14
24828: PUSH
24829: LD_INT 0
24831: PUSH
24832: LD_INT 0
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PUSH
24839: LD_INT 0
24841: PUSH
24842: LD_INT 1
24844: NEG
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: LD_INT 1
24852: PUSH
24853: LD_INT 0
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: PUSH
24860: LD_INT 1
24862: PUSH
24863: LD_INT 1
24865: PUSH
24866: EMPTY
24867: LIST
24868: LIST
24869: PUSH
24870: LD_INT 0
24872: PUSH
24873: LD_INT 1
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 1
24882: NEG
24883: PUSH
24884: LD_INT 0
24886: PUSH
24887: EMPTY
24888: LIST
24889: LIST
24890: PUSH
24891: LD_INT 1
24893: NEG
24894: PUSH
24895: LD_INT 1
24897: NEG
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 1
24905: NEG
24906: PUSH
24907: LD_INT 2
24909: NEG
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: LD_INT 0
24917: PUSH
24918: LD_INT 2
24920: NEG
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 1
24928: PUSH
24929: LD_INT 1
24931: NEG
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: LD_INT 1
24939: PUSH
24940: LD_INT 2
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PUSH
24947: LD_INT 0
24949: PUSH
24950: LD_INT 2
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 1
24959: NEG
24960: PUSH
24961: LD_INT 1
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 1
24970: NEG
24971: PUSH
24972: LD_INT 3
24974: NEG
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 0
24982: PUSH
24983: LD_INT 3
24985: NEG
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 1
24993: PUSH
24994: LD_INT 2
24996: NEG
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PUSH
25002: EMPTY
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: LIST
25011: LIST
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: LIST
25019: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25020: LD_ADDR_VAR 0 15
25024: PUSH
25025: LD_INT 0
25027: PUSH
25028: LD_INT 0
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: LD_INT 0
25037: PUSH
25038: LD_INT 1
25040: NEG
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: LD_INT 1
25048: PUSH
25049: LD_INT 0
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 1
25058: PUSH
25059: LD_INT 1
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: LD_INT 0
25068: PUSH
25069: LD_INT 1
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: LD_INT 1
25078: NEG
25079: PUSH
25080: LD_INT 0
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: PUSH
25087: LD_INT 1
25089: NEG
25090: PUSH
25091: LD_INT 1
25093: NEG
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: PUSH
25099: LD_INT 1
25101: PUSH
25102: LD_INT 1
25104: NEG
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 2
25112: PUSH
25113: LD_INT 0
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 2
25122: PUSH
25123: LD_INT 1
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 1
25132: NEG
25133: PUSH
25134: LD_INT 1
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: LD_INT 2
25143: NEG
25144: PUSH
25145: LD_INT 0
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: PUSH
25152: LD_INT 2
25154: NEG
25155: PUSH
25156: LD_INT 1
25158: NEG
25159: PUSH
25160: EMPTY
25161: LIST
25162: LIST
25163: PUSH
25164: LD_INT 2
25166: PUSH
25167: LD_INT 1
25169: NEG
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PUSH
25175: LD_INT 3
25177: PUSH
25178: LD_INT 0
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: LD_INT 3
25187: PUSH
25188: LD_INT 1
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: EMPTY
25196: LIST
25197: LIST
25198: LIST
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25213: LD_ADDR_VAR 0 16
25217: PUSH
25218: LD_INT 0
25220: PUSH
25221: LD_INT 0
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 0
25230: PUSH
25231: LD_INT 1
25233: NEG
25234: PUSH
25235: EMPTY
25236: LIST
25237: LIST
25238: PUSH
25239: LD_INT 1
25241: PUSH
25242: LD_INT 0
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: PUSH
25249: LD_INT 1
25251: PUSH
25252: LD_INT 1
25254: PUSH
25255: EMPTY
25256: LIST
25257: LIST
25258: PUSH
25259: LD_INT 0
25261: PUSH
25262: LD_INT 1
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: LD_INT 1
25271: NEG
25272: PUSH
25273: LD_INT 0
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 1
25282: NEG
25283: PUSH
25284: LD_INT 1
25286: NEG
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PUSH
25292: LD_INT 1
25294: NEG
25295: PUSH
25296: LD_INT 2
25298: NEG
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: PUSH
25304: LD_INT 2
25306: PUSH
25307: LD_INT 1
25309: PUSH
25310: EMPTY
25311: LIST
25312: LIST
25313: PUSH
25314: LD_INT 2
25316: PUSH
25317: LD_INT 2
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: LD_INT 1
25326: PUSH
25327: LD_INT 2
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 2
25336: NEG
25337: PUSH
25338: LD_INT 1
25340: NEG
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 2
25348: NEG
25349: PUSH
25350: LD_INT 2
25352: NEG
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 3
25360: PUSH
25361: LD_INT 2
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: PUSH
25368: LD_INT 3
25370: PUSH
25371: LD_INT 3
25373: PUSH
25374: EMPTY
25375: LIST
25376: LIST
25377: PUSH
25378: LD_INT 2
25380: PUSH
25381: LD_INT 3
25383: PUSH
25384: EMPTY
25385: LIST
25386: LIST
25387: PUSH
25388: EMPTY
25389: LIST
25390: LIST
25391: LIST
25392: LIST
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: LIST
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: LIST
25405: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25406: LD_ADDR_VAR 0 17
25410: PUSH
25411: LD_INT 0
25413: PUSH
25414: LD_INT 0
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PUSH
25421: LD_INT 0
25423: PUSH
25424: LD_INT 1
25426: NEG
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: PUSH
25432: LD_INT 1
25434: PUSH
25435: LD_INT 0
25437: PUSH
25438: EMPTY
25439: LIST
25440: LIST
25441: PUSH
25442: LD_INT 1
25444: PUSH
25445: LD_INT 1
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: PUSH
25452: LD_INT 0
25454: PUSH
25455: LD_INT 1
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: PUSH
25462: LD_INT 1
25464: NEG
25465: PUSH
25466: LD_INT 0
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 1
25475: NEG
25476: PUSH
25477: LD_INT 1
25479: NEG
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 1
25487: NEG
25488: PUSH
25489: LD_INT 2
25491: NEG
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 0
25499: PUSH
25500: LD_INT 2
25502: NEG
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 1
25510: PUSH
25511: LD_INT 1
25513: NEG
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 2
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: EMPTY
25526: LIST
25527: LIST
25528: PUSH
25529: LD_INT 2
25531: PUSH
25532: LD_INT 1
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: LD_INT 2
25544: PUSH
25545: EMPTY
25546: LIST
25547: LIST
25548: PUSH
25549: LD_INT 1
25551: PUSH
25552: LD_INT 2
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: LD_INT 0
25561: PUSH
25562: LD_INT 2
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: LD_INT 1
25571: NEG
25572: PUSH
25573: LD_INT 1
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 2
25582: NEG
25583: PUSH
25584: LD_INT 0
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: LD_INT 2
25593: NEG
25594: PUSH
25595: LD_INT 1
25597: NEG
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 2
25605: NEG
25606: PUSH
25607: LD_INT 2
25609: NEG
25610: PUSH
25611: EMPTY
25612: LIST
25613: LIST
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25636: LD_ADDR_VAR 0 18
25640: PUSH
25641: LD_INT 0
25643: PUSH
25644: LD_INT 0
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: LD_INT 1
25656: NEG
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: LD_INT 1
25664: PUSH
25665: LD_INT 0
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 1
25674: PUSH
25675: LD_INT 1
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 1
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: PUSH
25692: LD_INT 1
25694: NEG
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 1
25705: NEG
25706: PUSH
25707: LD_INT 1
25709: NEG
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 1
25717: NEG
25718: PUSH
25719: LD_INT 2
25721: NEG
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: LD_INT 0
25729: PUSH
25730: LD_INT 2
25732: NEG
25733: PUSH
25734: EMPTY
25735: LIST
25736: LIST
25737: PUSH
25738: LD_INT 1
25740: PUSH
25741: LD_INT 1
25743: NEG
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_INT 2
25751: PUSH
25752: LD_INT 0
25754: PUSH
25755: EMPTY
25756: LIST
25757: LIST
25758: PUSH
25759: LD_INT 2
25761: PUSH
25762: LD_INT 1
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PUSH
25769: LD_INT 2
25771: PUSH
25772: LD_INT 2
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: LD_INT 1
25781: PUSH
25782: LD_INT 2
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: LD_INT 2
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: LD_INT 1
25801: NEG
25802: PUSH
25803: LD_INT 1
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 2
25812: NEG
25813: PUSH
25814: LD_INT 0
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: PUSH
25821: LD_INT 2
25823: NEG
25824: PUSH
25825: LD_INT 1
25827: NEG
25828: PUSH
25829: EMPTY
25830: LIST
25831: LIST
25832: PUSH
25833: LD_INT 2
25835: NEG
25836: PUSH
25837: LD_INT 2
25839: NEG
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: LIST
25849: LIST
25850: LIST
25851: LIST
25852: LIST
25853: LIST
25854: LIST
25855: LIST
25856: LIST
25857: LIST
25858: LIST
25859: LIST
25860: LIST
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25866: LD_ADDR_VAR 0 19
25870: PUSH
25871: LD_INT 0
25873: PUSH
25874: LD_INT 0
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: LD_INT 0
25883: PUSH
25884: LD_INT 1
25886: NEG
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: LD_INT 1
25894: PUSH
25895: LD_INT 0
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: PUSH
25902: LD_INT 1
25904: PUSH
25905: LD_INT 1
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: LD_INT 0
25914: PUSH
25915: LD_INT 1
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 1
25924: NEG
25925: PUSH
25926: LD_INT 0
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 1
25935: NEG
25936: PUSH
25937: LD_INT 1
25939: NEG
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: PUSH
25945: LD_INT 1
25947: NEG
25948: PUSH
25949: LD_INT 2
25951: NEG
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: PUSH
25957: LD_INT 0
25959: PUSH
25960: LD_INT 2
25962: NEG
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: PUSH
25968: LD_INT 1
25970: PUSH
25971: LD_INT 1
25973: NEG
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: PUSH
25979: LD_INT 2
25981: PUSH
25982: LD_INT 0
25984: PUSH
25985: EMPTY
25986: LIST
25987: LIST
25988: PUSH
25989: LD_INT 2
25991: PUSH
25992: LD_INT 1
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: PUSH
25999: LD_INT 2
26001: PUSH
26002: LD_INT 2
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: PUSH
26009: LD_INT 1
26011: PUSH
26012: LD_INT 2
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 0
26021: PUSH
26022: LD_INT 2
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 1
26031: NEG
26032: PUSH
26033: LD_INT 1
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: PUSH
26040: LD_INT 2
26042: NEG
26043: PUSH
26044: LD_INT 0
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: LD_INT 2
26053: NEG
26054: PUSH
26055: LD_INT 1
26057: NEG
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 2
26065: NEG
26066: PUSH
26067: LD_INT 2
26069: NEG
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: LIST
26079: LIST
26080: LIST
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: LIST
26089: LIST
26090: LIST
26091: LIST
26092: LIST
26093: LIST
26094: LIST
26095: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26096: LD_ADDR_VAR 0 20
26100: PUSH
26101: LD_INT 0
26103: PUSH
26104: LD_INT 0
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: PUSH
26111: LD_INT 0
26113: PUSH
26114: LD_INT 1
26116: NEG
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: LD_INT 1
26124: PUSH
26125: LD_INT 0
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: PUSH
26132: LD_INT 1
26134: PUSH
26135: LD_INT 1
26137: PUSH
26138: EMPTY
26139: LIST
26140: LIST
26141: PUSH
26142: LD_INT 0
26144: PUSH
26145: LD_INT 1
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 1
26154: NEG
26155: PUSH
26156: LD_INT 0
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: LD_INT 1
26165: NEG
26166: PUSH
26167: LD_INT 1
26169: NEG
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 1
26177: NEG
26178: PUSH
26179: LD_INT 2
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 0
26189: PUSH
26190: LD_INT 2
26192: NEG
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 1
26200: PUSH
26201: LD_INT 1
26203: NEG
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: PUSH
26209: LD_INT 2
26211: PUSH
26212: LD_INT 0
26214: PUSH
26215: EMPTY
26216: LIST
26217: LIST
26218: PUSH
26219: LD_INT 2
26221: PUSH
26222: LD_INT 1
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: LD_INT 2
26231: PUSH
26232: LD_INT 2
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: PUSH
26239: LD_INT 1
26241: PUSH
26242: LD_INT 2
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: LD_INT 2
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 1
26261: NEG
26262: PUSH
26263: LD_INT 1
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: LD_INT 2
26272: NEG
26273: PUSH
26274: LD_INT 0
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: LD_INT 2
26283: NEG
26284: PUSH
26285: LD_INT 1
26287: NEG
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: PUSH
26293: LD_INT 2
26295: NEG
26296: PUSH
26297: LD_INT 2
26299: NEG
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: LIST
26322: LIST
26323: LIST
26324: LIST
26325: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26326: LD_ADDR_VAR 0 21
26330: PUSH
26331: LD_INT 0
26333: PUSH
26334: LD_INT 0
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: LD_INT 0
26343: PUSH
26344: LD_INT 1
26346: NEG
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: LD_INT 1
26354: PUSH
26355: LD_INT 0
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 1
26364: PUSH
26365: LD_INT 1
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 0
26374: PUSH
26375: LD_INT 1
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 1
26384: NEG
26385: PUSH
26386: LD_INT 0
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 1
26395: NEG
26396: PUSH
26397: LD_INT 1
26399: NEG
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 1
26407: NEG
26408: PUSH
26409: LD_INT 2
26411: NEG
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 0
26419: PUSH
26420: LD_INT 2
26422: NEG
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: PUSH
26431: LD_INT 1
26433: NEG
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: PUSH
26439: LD_INT 2
26441: PUSH
26442: LD_INT 0
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PUSH
26449: LD_INT 2
26451: PUSH
26452: LD_INT 1
26454: PUSH
26455: EMPTY
26456: LIST
26457: LIST
26458: PUSH
26459: LD_INT 2
26461: PUSH
26462: LD_INT 2
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: PUSH
26469: LD_INT 1
26471: PUSH
26472: LD_INT 2
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 0
26481: PUSH
26482: LD_INT 2
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: NEG
26492: PUSH
26493: LD_INT 1
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: LD_INT 2
26502: NEG
26503: PUSH
26504: LD_INT 0
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PUSH
26511: LD_INT 2
26513: NEG
26514: PUSH
26515: LD_INT 1
26517: NEG
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: PUSH
26523: LD_INT 2
26525: NEG
26526: PUSH
26527: LD_INT 2
26529: NEG
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: LIST
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26556: LD_ADDR_VAR 0 22
26560: PUSH
26561: LD_INT 0
26563: PUSH
26564: LD_INT 0
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 0
26573: PUSH
26574: LD_INT 1
26576: NEG
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 1
26584: PUSH
26585: LD_INT 0
26587: PUSH
26588: EMPTY
26589: LIST
26590: LIST
26591: PUSH
26592: LD_INT 1
26594: PUSH
26595: LD_INT 1
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: LD_INT 1
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 0
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 1
26625: NEG
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 1
26637: NEG
26638: PUSH
26639: LD_INT 2
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 0
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 1
26660: PUSH
26661: LD_INT 1
26663: NEG
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 2
26671: PUSH
26672: LD_INT 0
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PUSH
26679: LD_INT 2
26681: PUSH
26682: LD_INT 1
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PUSH
26689: LD_INT 2
26691: PUSH
26692: LD_INT 2
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: PUSH
26699: LD_INT 1
26701: PUSH
26702: LD_INT 2
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 0
26711: PUSH
26712: LD_INT 2
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: NEG
26722: PUSH
26723: LD_INT 1
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 2
26732: NEG
26733: PUSH
26734: LD_INT 0
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 2
26743: NEG
26744: PUSH
26745: LD_INT 1
26747: NEG
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: PUSH
26753: LD_INT 2
26755: NEG
26756: PUSH
26757: LD_INT 2
26759: NEG
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: LIST
26771: LIST
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26786: LD_ADDR_VAR 0 23
26790: PUSH
26791: LD_INT 0
26793: PUSH
26794: LD_INT 0
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 0
26803: PUSH
26804: LD_INT 1
26806: NEG
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 1
26814: PUSH
26815: LD_INT 0
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PUSH
26822: LD_INT 1
26824: PUSH
26825: LD_INT 1
26827: PUSH
26828: EMPTY
26829: LIST
26830: LIST
26831: PUSH
26832: LD_INT 0
26834: PUSH
26835: LD_INT 1
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 1
26844: NEG
26845: PUSH
26846: LD_INT 0
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 1
26855: NEG
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: NEG
26868: PUSH
26869: LD_INT 2
26871: NEG
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 0
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: LD_INT 1
26893: NEG
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 2
26901: PUSH
26902: LD_INT 0
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: LD_INT 2
26911: PUSH
26912: LD_INT 1
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: LD_INT 2
26921: PUSH
26922: LD_INT 2
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: LD_INT 1
26931: PUSH
26932: LD_INT 2
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 0
26941: PUSH
26942: LD_INT 2
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: NEG
26952: PUSH
26953: LD_INT 1
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 2
26962: NEG
26963: PUSH
26964: LD_INT 0
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 2
26973: NEG
26974: PUSH
26975: LD_INT 1
26977: NEG
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: PUSH
26983: LD_INT 2
26985: NEG
26986: PUSH
26987: LD_INT 2
26989: NEG
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 2
26997: NEG
26998: PUSH
26999: LD_INT 3
27001: NEG
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PUSH
27007: LD_INT 1
27009: NEG
27010: PUSH
27011: LD_INT 3
27013: NEG
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: PUSH
27019: LD_INT 1
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 2
27032: PUSH
27033: LD_INT 1
27035: NEG
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: LIST
27046: LIST
27047: LIST
27048: LIST
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: LIST
27054: LIST
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27066: LD_ADDR_VAR 0 24
27070: PUSH
27071: LD_INT 0
27073: PUSH
27074: LD_INT 0
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: PUSH
27081: LD_INT 0
27083: PUSH
27084: LD_INT 1
27086: NEG
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 1
27094: PUSH
27095: LD_INT 0
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 1
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 0
27114: PUSH
27115: LD_INT 1
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: LD_INT 1
27124: NEG
27125: PUSH
27126: LD_INT 0
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 1
27135: NEG
27136: PUSH
27137: LD_INT 1
27139: NEG
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 1
27147: NEG
27148: PUSH
27149: LD_INT 2
27151: NEG
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 0
27159: PUSH
27160: LD_INT 2
27162: NEG
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: PUSH
27171: LD_INT 1
27173: NEG
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 2
27181: PUSH
27182: LD_INT 0
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 2
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: LD_INT 2
27201: PUSH
27202: LD_INT 2
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PUSH
27209: LD_INT 1
27211: PUSH
27212: LD_INT 2
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PUSH
27219: LD_INT 0
27221: PUSH
27222: LD_INT 2
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: PUSH
27229: LD_INT 1
27231: NEG
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 2
27242: NEG
27243: PUSH
27244: LD_INT 0
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 2
27253: NEG
27254: PUSH
27255: LD_INT 1
27257: NEG
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: LD_INT 2
27265: NEG
27266: PUSH
27267: LD_INT 2
27269: NEG
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PUSH
27275: LD_INT 1
27277: PUSH
27278: LD_INT 2
27280: NEG
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 2
27288: PUSH
27289: LD_INT 1
27291: NEG
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 3
27299: PUSH
27300: LD_INT 1
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: LD_INT 2
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: LIST
27326: LIST
27327: LIST
27328: LIST
27329: LIST
27330: LIST
27331: LIST
27332: LIST
27333: LIST
27334: LIST
27335: LIST
27336: LIST
27337: LIST
27338: LIST
27339: LIST
27340: LIST
27341: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27342: LD_ADDR_VAR 0 25
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: LD_INT 0
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 0
27359: PUSH
27360: LD_INT 1
27362: NEG
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 1
27370: PUSH
27371: LD_INT 0
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 1
27380: PUSH
27381: LD_INT 1
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 1
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 1
27400: NEG
27401: PUSH
27402: LD_INT 0
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: NEG
27412: PUSH
27413: LD_INT 1
27415: NEG
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 1
27423: NEG
27424: PUSH
27425: LD_INT 2
27427: NEG
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: LD_INT 2
27438: NEG
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: PUSH
27444: LD_INT 1
27446: PUSH
27447: LD_INT 1
27449: NEG
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 2
27457: PUSH
27458: LD_INT 0
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: LD_INT 1
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 2
27477: PUSH
27478: LD_INT 2
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: LD_INT 2
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: LD_INT 2
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 1
27507: NEG
27508: PUSH
27509: LD_INT 1
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 2
27518: NEG
27519: PUSH
27520: LD_INT 0
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PUSH
27527: LD_INT 2
27529: NEG
27530: PUSH
27531: LD_INT 1
27533: NEG
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 2
27541: NEG
27542: PUSH
27543: LD_INT 2
27545: NEG
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PUSH
27551: LD_INT 3
27553: PUSH
27554: LD_INT 1
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: LD_INT 3
27563: PUSH
27564: LD_INT 2
27566: PUSH
27567: EMPTY
27568: LIST
27569: LIST
27570: PUSH
27571: LD_INT 2
27573: PUSH
27574: LD_INT 3
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: PUSH
27581: LD_INT 1
27583: PUSH
27584: LD_INT 3
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27616: LD_ADDR_VAR 0 26
27620: PUSH
27621: LD_INT 0
27623: PUSH
27624: LD_INT 0
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 1
27636: NEG
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: PUSH
27642: LD_INT 1
27644: PUSH
27645: LD_INT 0
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: LD_INT 1
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 0
27664: PUSH
27665: LD_INT 1
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 1
27674: NEG
27675: PUSH
27676: LD_INT 0
27678: PUSH
27679: EMPTY
27680: LIST
27681: LIST
27682: PUSH
27683: LD_INT 1
27685: NEG
27686: PUSH
27687: LD_INT 1
27689: NEG
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 1
27697: NEG
27698: PUSH
27699: LD_INT 2
27701: NEG
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: LD_INT 2
27712: NEG
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 1
27720: PUSH
27721: LD_INT 1
27723: NEG
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: LD_INT 2
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: LD_INT 1
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: LD_INT 2
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 1
27761: PUSH
27762: LD_INT 2
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 0
27771: PUSH
27772: LD_INT 2
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: LD_INT 1
27781: NEG
27782: PUSH
27783: LD_INT 1
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 2
27792: NEG
27793: PUSH
27794: LD_INT 0
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 2
27803: NEG
27804: PUSH
27805: LD_INT 1
27807: NEG
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PUSH
27813: LD_INT 2
27815: NEG
27816: PUSH
27817: LD_INT 2
27819: NEG
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 2
27827: PUSH
27828: LD_INT 3
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 1
27837: PUSH
27838: LD_INT 3
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 1
27847: NEG
27848: PUSH
27849: LD_INT 2
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 2
27858: NEG
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: EMPTY
27868: LIST
27869: LIST
27870: LIST
27871: LIST
27872: LIST
27873: LIST
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: LIST
27886: LIST
27887: LIST
27888: LIST
27889: LIST
27890: LIST
27891: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27892: LD_ADDR_VAR 0 27
27896: PUSH
27897: LD_INT 0
27899: PUSH
27900: LD_INT 0
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 0
27909: PUSH
27910: LD_INT 1
27912: NEG
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 1
27920: PUSH
27921: LD_INT 0
27923: PUSH
27924: EMPTY
27925: LIST
27926: LIST
27927: PUSH
27928: LD_INT 1
27930: PUSH
27931: LD_INT 1
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_INT 1
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: EMPTY
27956: LIST
27957: LIST
27958: PUSH
27959: LD_INT 1
27961: NEG
27962: PUSH
27963: LD_INT 1
27965: NEG
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 1
27973: NEG
27974: PUSH
27975: LD_INT 2
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 0
27985: PUSH
27986: LD_INT 2
27988: NEG
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 1
27999: NEG
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PUSH
28005: LD_INT 2
28007: PUSH
28008: LD_INT 0
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: PUSH
28015: LD_INT 2
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 2
28027: PUSH
28028: LD_INT 2
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 1
28037: PUSH
28038: LD_INT 2
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 0
28047: PUSH
28048: LD_INT 2
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PUSH
28055: LD_INT 1
28057: NEG
28058: PUSH
28059: LD_INT 1
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 2
28068: NEG
28069: PUSH
28070: LD_INT 0
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 2
28079: NEG
28080: PUSH
28081: LD_INT 1
28083: NEG
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 2
28091: NEG
28092: PUSH
28093: LD_INT 2
28095: NEG
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 1
28103: NEG
28104: PUSH
28105: LD_INT 2
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 2
28114: NEG
28115: PUSH
28116: LD_INT 1
28118: PUSH
28119: EMPTY
28120: LIST
28121: LIST
28122: PUSH
28123: LD_INT 3
28125: NEG
28126: PUSH
28127: LD_INT 1
28129: NEG
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: PUSH
28135: LD_INT 3
28137: NEG
28138: PUSH
28139: LD_INT 2
28141: NEG
28142: PUSH
28143: EMPTY
28144: LIST
28145: LIST
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: LIST
28156: LIST
28157: LIST
28158: LIST
28159: LIST
28160: LIST
28161: LIST
28162: LIST
28163: LIST
28164: LIST
28165: LIST
28166: LIST
28167: LIST
28168: LIST
28169: LIST
28170: LIST
28171: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28172: LD_ADDR_VAR 0 28
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: LD_INT 0
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 0
28189: PUSH
28190: LD_INT 1
28192: NEG
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 1
28200: PUSH
28201: LD_INT 0
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 1
28210: PUSH
28211: LD_INT 1
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 0
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: LD_INT 1
28230: NEG
28231: PUSH
28232: LD_INT 0
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PUSH
28239: LD_INT 1
28241: NEG
28242: PUSH
28243: LD_INT 1
28245: NEG
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 1
28253: NEG
28254: PUSH
28255: LD_INT 2
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 0
28265: PUSH
28266: LD_INT 2
28268: NEG
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 1
28276: PUSH
28277: LD_INT 1
28279: NEG
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 2
28287: PUSH
28288: LD_INT 0
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: PUSH
28295: LD_INT 2
28297: PUSH
28298: LD_INT 1
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: PUSH
28305: LD_INT 2
28307: PUSH
28308: LD_INT 2
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 2
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 0
28327: PUSH
28328: LD_INT 2
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 1
28337: NEG
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 2
28348: NEG
28349: PUSH
28350: LD_INT 0
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 1
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 2
28371: NEG
28372: PUSH
28373: LD_INT 2
28375: NEG
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 2
28383: NEG
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: LD_INT 1
28395: NEG
28396: PUSH
28397: LD_INT 3
28399: NEG
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 3
28407: NEG
28408: PUSH
28409: LD_INT 1
28411: NEG
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 3
28419: NEG
28420: PUSH
28421: LD_INT 2
28423: NEG
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: EMPTY
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: LIST
28443: LIST
28444: LIST
28445: LIST
28446: LIST
28447: LIST
28448: LIST
28449: LIST
28450: LIST
28451: LIST
28452: LIST
28453: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28454: LD_ADDR_VAR 0 29
28458: PUSH
28459: LD_INT 0
28461: PUSH
28462: LD_INT 0
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 0
28471: PUSH
28472: LD_INT 1
28474: NEG
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 1
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: PUSH
28493: LD_INT 1
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 0
28502: PUSH
28503: LD_INT 1
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: LD_INT 0
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 1
28523: NEG
28524: PUSH
28525: LD_INT 1
28527: NEG
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 1
28535: NEG
28536: PUSH
28537: LD_INT 2
28539: NEG
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 0
28547: PUSH
28548: LD_INT 2
28550: NEG
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: LD_INT 1
28561: NEG
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 2
28569: PUSH
28570: LD_INT 0
28572: PUSH
28573: EMPTY
28574: LIST
28575: LIST
28576: PUSH
28577: LD_INT 2
28579: PUSH
28580: LD_INT 1
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: PUSH
28587: LD_INT 1
28589: PUSH
28590: LD_INT 2
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: LD_INT 0
28599: PUSH
28600: LD_INT 2
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PUSH
28607: LD_INT 1
28609: NEG
28610: PUSH
28611: LD_INT 1
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: NEG
28621: PUSH
28622: LD_INT 1
28624: NEG
28625: PUSH
28626: EMPTY
28627: LIST
28628: LIST
28629: PUSH
28630: LD_INT 2
28632: NEG
28633: PUSH
28634: LD_INT 2
28636: NEG
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 2
28644: NEG
28645: PUSH
28646: LD_INT 3
28648: NEG
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: LD_INT 2
28656: PUSH
28657: LD_INT 1
28659: NEG
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 3
28667: PUSH
28668: LD_INT 1
28670: PUSH
28671: EMPTY
28672: LIST
28673: LIST
28674: PUSH
28675: LD_INT 1
28677: PUSH
28678: LD_INT 3
28680: PUSH
28681: EMPTY
28682: LIST
28683: LIST
28684: PUSH
28685: LD_INT 1
28687: NEG
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 3
28698: NEG
28699: PUSH
28700: LD_INT 2
28702: NEG
28703: PUSH
28704: EMPTY
28705: LIST
28706: LIST
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: LIST
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28733: LD_ADDR_VAR 0 30
28737: PUSH
28738: LD_INT 0
28740: PUSH
28741: LD_INT 0
28743: PUSH
28744: EMPTY
28745: LIST
28746: LIST
28747: PUSH
28748: LD_INT 0
28750: PUSH
28751: LD_INT 1
28753: NEG
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 1
28761: PUSH
28762: LD_INT 0
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 1
28771: PUSH
28772: LD_INT 1
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: LD_INT 1
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 1
28791: NEG
28792: PUSH
28793: LD_INT 0
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 1
28802: NEG
28803: PUSH
28804: LD_INT 1
28806: NEG
28807: PUSH
28808: EMPTY
28809: LIST
28810: LIST
28811: PUSH
28812: LD_INT 1
28814: NEG
28815: PUSH
28816: LD_INT 2
28818: NEG
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 0
28826: PUSH
28827: LD_INT 2
28829: NEG
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 1
28837: PUSH
28838: LD_INT 1
28840: NEG
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 2
28848: PUSH
28849: LD_INT 0
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 2
28858: PUSH
28859: LD_INT 1
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: LD_INT 2
28868: PUSH
28869: LD_INT 2
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: LD_INT 2
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 1
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: PUSH
28897: LD_INT 2
28899: NEG
28900: PUSH
28901: LD_INT 0
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 2
28910: NEG
28911: PUSH
28912: LD_INT 1
28914: NEG
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 1
28922: NEG
28923: PUSH
28924: LD_INT 3
28926: NEG
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 1
28934: PUSH
28935: LD_INT 2
28937: NEG
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 3
28945: PUSH
28946: LD_INT 2
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: LD_INT 3
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: LD_INT 2
28965: NEG
28966: PUSH
28967: LD_INT 1
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: LD_INT 3
28976: NEG
28977: PUSH
28978: LD_INT 1
28980: NEG
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29011: LD_ADDR_VAR 0 31
29015: PUSH
29016: LD_INT 0
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: EMPTY
29023: LIST
29024: LIST
29025: PUSH
29026: LD_INT 0
29028: PUSH
29029: LD_INT 1
29031: NEG
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: LD_INT 0
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 1
29049: PUSH
29050: LD_INT 1
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 0
29059: PUSH
29060: LD_INT 1
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: LD_INT 1
29069: NEG
29070: PUSH
29071: LD_INT 0
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: LD_INT 1
29084: NEG
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 1
29092: NEG
29093: PUSH
29094: LD_INT 2
29096: NEG
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: PUSH
29105: LD_INT 1
29107: NEG
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: PUSH
29116: LD_INT 0
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: PUSH
29123: LD_INT 2
29125: PUSH
29126: LD_INT 1
29128: PUSH
29129: EMPTY
29130: LIST
29131: LIST
29132: PUSH
29133: LD_INT 2
29135: PUSH
29136: LD_INT 2
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: LD_INT 2
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 0
29155: PUSH
29156: LD_INT 2
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 1
29165: NEG
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: NEG
29177: PUSH
29178: LD_INT 1
29180: NEG
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 2
29188: NEG
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 2
29200: NEG
29201: PUSH
29202: LD_INT 3
29204: NEG
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 2
29212: PUSH
29213: LD_INT 1
29215: NEG
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 3
29223: PUSH
29224: LD_INT 1
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: LD_INT 3
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: LD_INT 2
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 3
29254: NEG
29255: PUSH
29256: LD_INT 2
29258: NEG
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29289: LD_ADDR_VAR 0 32
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 0
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: LD_INT 1
29309: NEG
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: LD_INT 1
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: NEG
29348: PUSH
29349: LD_INT 0
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: NEG
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: LD_INT 2
29374: NEG
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: LD_INT 2
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 1
29396: NEG
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 2
29404: PUSH
29405: LD_INT 1
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 2
29414: PUSH
29415: LD_INT 2
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 1
29424: PUSH
29425: LD_INT 2
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: LD_INT 2
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: LD_INT 1
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 2
29455: NEG
29456: PUSH
29457: LD_INT 0
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 2
29466: NEG
29467: PUSH
29468: LD_INT 1
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: NEG
29479: PUSH
29480: LD_INT 3
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: PUSH
29491: LD_INT 2
29493: NEG
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 3
29501: PUSH
29502: LD_INT 2
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 2
29511: PUSH
29512: LD_INT 3
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 2
29521: NEG
29522: PUSH
29523: LD_INT 1
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 3
29532: NEG
29533: PUSH
29534: LD_INT 1
29536: NEG
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: LIST
29563: LIST
29564: LIST
29565: LIST
29566: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29567: LD_ADDR_VAR 0 33
29571: PUSH
29572: LD_INT 0
29574: PUSH
29575: LD_INT 0
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: LD_INT 0
29584: PUSH
29585: LD_INT 1
29587: NEG
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 1
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 1
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: NEG
29637: PUSH
29638: LD_INT 1
29640: NEG
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PUSH
29646: LD_INT 1
29648: NEG
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: LD_INT 1
29663: NEG
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 1
29691: PUSH
29692: LD_INT 2
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 0
29701: PUSH
29702: LD_INT 2
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: NEG
29712: PUSH
29713: LD_INT 1
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 2
29722: NEG
29723: PUSH
29724: LD_INT 0
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 2
29733: NEG
29734: PUSH
29735: LD_INT 1
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 2
29745: NEG
29746: PUSH
29747: LD_INT 2
29749: NEG
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 2
29757: NEG
29758: PUSH
29759: LD_INT 3
29761: NEG
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 1
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 3
29780: PUSH
29781: LD_INT 1
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 1
29790: PUSH
29791: LD_INT 3
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: LD_INT 2
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: LD_INT 3
29811: NEG
29812: PUSH
29813: LD_INT 2
29815: NEG
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: LIST
29829: LIST
29830: LIST
29831: LIST
29832: LIST
29833: LIST
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: LIST
29844: LIST
29845: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29846: LD_ADDR_VAR 0 34
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: LD_INT 0
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 1
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: LD_INT 1
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 1
29904: NEG
29905: PUSH
29906: LD_INT 0
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 1
29915: NEG
29916: PUSH
29917: LD_INT 1
29919: NEG
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 1
29927: NEG
29928: PUSH
29929: LD_INT 2
29931: NEG
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 0
29939: PUSH
29940: LD_INT 2
29942: NEG
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: LD_INT 1
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 2
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 2
29971: PUSH
29972: LD_INT 2
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: LD_INT 1
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: NEG
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 2
30013: NEG
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 2
30025: NEG
30026: PUSH
30027: LD_INT 2
30029: NEG
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 3
30041: NEG
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 3
30060: PUSH
30061: LD_INT 2
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 3
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: LD_INT 2
30080: NEG
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 3
30091: NEG
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: LIST
30110: LIST
30111: LIST
30112: LIST
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: LIST
30125: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30126: LD_ADDR_VAR 0 35
30130: PUSH
30131: LD_INT 0
30133: PUSH
30134: LD_INT 0
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: LD_INT 1
30146: NEG
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: LD_INT 0
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 1
30184: NEG
30185: PUSH
30186: LD_INT 0
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 1
30195: NEG
30196: PUSH
30197: LD_INT 1
30199: NEG
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 2
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: LIST
30237: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30238: LD_ADDR_VAR 0 36
30242: PUSH
30243: LD_INT 0
30245: PUSH
30246: LD_INT 0
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PUSH
30253: LD_INT 0
30255: PUSH
30256: LD_INT 1
30258: NEG
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 1
30266: PUSH
30267: LD_INT 0
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 1
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 1
30296: NEG
30297: PUSH
30298: LD_INT 0
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: LD_INT 1
30311: NEG
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 1
30319: NEG
30320: PUSH
30321: LD_INT 2
30323: NEG
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: LD_INT 2
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30350: LD_ADDR_VAR 0 37
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: LD_INT 0
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: LD_INT 1
30370: NEG
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: LD_INT 0
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 1
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 1
30408: NEG
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 1
30419: NEG
30420: PUSH
30421: LD_INT 1
30423: NEG
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: PUSH
30432: LD_INT 1
30434: NEG
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 1
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30462: LD_ADDR_VAR 0 38
30466: PUSH
30467: LD_INT 0
30469: PUSH
30470: LD_INT 0
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 1
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: PUSH
30501: LD_INT 1
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 1
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 1
30520: NEG
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: NEG
30532: PUSH
30533: LD_INT 1
30535: NEG
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 2
30543: PUSH
30544: LD_INT 1
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 2
30553: NEG
30554: PUSH
30555: LD_INT 1
30557: NEG
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30574: LD_ADDR_VAR 0 39
30578: PUSH
30579: LD_INT 0
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 0
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 1
30602: PUSH
30603: LD_INT 0
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: PUSH
30613: LD_INT 1
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 0
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 0
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 1
30643: NEG
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: NEG
30656: PUSH
30657: LD_INT 2
30659: NEG
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: PUSH
30668: LD_INT 2
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30686: LD_ADDR_VAR 0 40
30690: PUSH
30691: LD_INT 0
30693: PUSH
30694: LD_INT 0
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: LD_INT 1
30706: NEG
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: LD_INT 0
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 1
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: LD_INT 1
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 1
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: LIST
30791: LIST
30792: LIST
30793: LIST
30794: LIST
30795: LIST
30796: LIST
30797: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30798: LD_ADDR_VAR 0 41
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 0
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 1
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 0
30846: PUSH
30847: LD_INT 1
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: NEG
30857: PUSH
30858: LD_INT 0
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: NEG
30868: PUSH
30869: LD_INT 1
30871: NEG
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 1
30879: NEG
30880: PUSH
30881: LD_INT 2
30883: NEG
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: PUSH
30889: LD_INT 1
30891: PUSH
30892: LD_INT 1
30894: NEG
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 2
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 2
30912: PUSH
30913: LD_INT 1
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 2
30922: PUSH
30923: LD_INT 2
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: LD_INT 2
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: LD_INT 1
30946: PUSH
30947: EMPTY
30948: LIST
30949: LIST
30950: PUSH
30951: LD_INT 2
30953: NEG
30954: PUSH
30955: LD_INT 0
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 2
30964: NEG
30965: PUSH
30966: LD_INT 1
30968: NEG
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: LD_INT 2
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: NEG
30989: PUSH
30990: LD_INT 3
30992: NEG
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 3
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 3
31021: PUSH
31022: LD_INT 1
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 3
31031: PUSH
31032: LD_INT 2
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 3
31041: PUSH
31042: LD_INT 3
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 2
31051: PUSH
31052: LD_INT 3
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: NEG
31062: PUSH
31063: LD_INT 1
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 3
31072: NEG
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 3
31083: NEG
31084: PUSH
31085: LD_INT 1
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 3
31095: NEG
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 3
31107: NEG
31108: PUSH
31109: LD_INT 3
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: LIST
31124: LIST
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31148: LD_ADDR_VAR 0 42
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 0
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 1
31176: PUSH
31177: LD_INT 0
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 1
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 0
31196: PUSH
31197: LD_INT 1
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 1
31206: NEG
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: NEG
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: LD_INT 2
31233: NEG
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: LD_INT 2
31244: NEG
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: LD_INT 1
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 2
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 2
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: PUSH
31284: LD_INT 2
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: LD_INT 2
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: NEG
31315: PUSH
31316: LD_INT 1
31318: NEG
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: LD_INT 2
31326: NEG
31327: PUSH
31328: LD_INT 2
31330: NEG
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: NEG
31339: PUSH
31340: LD_INT 3
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 3
31354: NEG
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: LD_INT 3
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 2
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 3
31384: PUSH
31385: LD_INT 2
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 3
31394: PUSH
31395: LD_INT 3
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: LD_INT 3
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 3
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 3
31445: NEG
31446: PUSH
31447: LD_INT 2
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 3
31457: NEG
31458: PUSH
31459: LD_INT 3
31461: NEG
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: LIST
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31498: LD_ADDR_VAR 0 43
31502: PUSH
31503: LD_INT 0
31505: PUSH
31506: LD_INT 0
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 0
31515: PUSH
31516: LD_INT 1
31518: NEG
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 1
31526: PUSH
31527: LD_INT 0
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: LD_INT 1
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: LD_INT 0
31546: PUSH
31547: LD_INT 1
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 1
31556: NEG
31557: PUSH
31558: LD_INT 0
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 1
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: LD_INT 2
31583: NEG
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 0
31591: PUSH
31592: LD_INT 2
31594: NEG
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 1
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: PUSH
31614: LD_INT 0
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 2
31623: PUSH
31624: LD_INT 1
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: PUSH
31634: LD_INT 2
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 0
31643: PUSH
31644: LD_INT 2
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 1
31653: NEG
31654: PUSH
31655: LD_INT 1
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 2
31664: NEG
31665: PUSH
31666: LD_INT 0
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: LD_INT 2
31675: NEG
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: LD_INT 3
31691: NEG
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: LD_INT 3
31702: NEG
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 2
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 3
31732: PUSH
31733: LD_INT 0
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 3
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 1
31752: PUSH
31753: LD_INT 3
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: LD_INT 3
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: LD_INT 2
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 2
31783: NEG
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 3
31794: NEG
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 3
31805: NEG
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: LIST
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31846: LD_ADDR_VAR 0 44
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 0
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: NEG
31905: PUSH
31906: LD_INT 0
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 1
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 2
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: PUSH
31961: LD_INT 1
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: LD_INT 2
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: LD_INT 2
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: NEG
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 2
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 2
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 2
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 2
32036: NEG
32037: PUSH
32038: LD_INT 3
32040: NEG
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 3
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 3
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 3
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 3
32089: PUSH
32090: LD_INT 3
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 2
32099: PUSH
32100: LD_INT 3
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: NEG
32110: PUSH
32111: LD_INT 1
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 3
32120: NEG
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 3
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 3
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 3
32155: NEG
32156: PUSH
32157: LD_INT 3
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32196: LD_ADDR_VAR 0 45
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 0
32213: PUSH
32214: LD_INT 1
32216: NEG
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 1
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 2
32292: NEG
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 1
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 2
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 2
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 1
32331: PUSH
32332: LD_INT 2
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: LD_INT 2
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 1
32351: NEG
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 2
32362: NEG
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 2
32374: NEG
32375: PUSH
32376: LD_INT 2
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: NEG
32387: PUSH
32388: LD_INT 3
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: LD_INT 3
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 0
32410: PUSH
32411: LD_INT 3
32413: NEG
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 1
32421: PUSH
32422: LD_INT 2
32424: NEG
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 3
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 3
32442: PUSH
32443: LD_INT 3
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: LD_INT 3
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 1
32462: PUSH
32463: LD_INT 3
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 0
32472: PUSH
32473: LD_INT 3
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: NEG
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 3
32493: NEG
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 3
32505: NEG
32506: PUSH
32507: LD_INT 3
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32546: LD_ADDR_VAR 0 46
32550: PUSH
32551: LD_INT 0
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: PUSH
32575: LD_INT 0
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 1
32584: PUSH
32585: LD_INT 1
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 0
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 1
32604: NEG
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 1
32615: NEG
32616: PUSH
32617: LD_INT 1
32619: NEG
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: LD_INT 2
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 0
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: LD_INT 2
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 0
32691: PUSH
32692: LD_INT 2
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 1
32701: NEG
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: NEG
32713: PUSH
32714: LD_INT 0
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 2
32723: NEG
32724: PUSH
32725: LD_INT 1
32727: NEG
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: PUSH
32733: LD_INT 1
32735: NEG
32736: PUSH
32737: LD_INT 3
32739: NEG
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: LD_INT 3
32750: NEG
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 2
32769: PUSH
32770: LD_INT 1
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 3
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 3
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 1
32800: PUSH
32801: LD_INT 3
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 0
32810: PUSH
32811: LD_INT 3
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: NEG
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 2
32831: NEG
32832: PUSH
32833: LD_INT 1
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 3
32842: NEG
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 3
32853: NEG
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32894: LD_ADDR_VAR 0 47
32898: PUSH
32899: LD_INT 0
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 0
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 1
32932: PUSH
32933: LD_INT 1
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 0
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 1
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: LD_INT 2
32990: NEG
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 1
32998: PUSH
32999: LD_INT 1
33001: NEG
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 2
33009: NEG
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 2
33021: NEG
33022: PUSH
33023: LD_INT 2
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33045: LD_ADDR_VAR 0 48
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: LD_INT 0
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: LD_INT 1
33073: PUSH
33074: LD_INT 0
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: LD_INT 1
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: NEG
33115: PUSH
33116: LD_INT 1
33118: NEG
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: LD_INT 2
33130: NEG
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 0
33138: PUSH
33139: LD_INT 2
33141: NEG
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 1
33149: PUSH
33150: LD_INT 1
33152: NEG
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 2
33160: PUSH
33161: LD_INT 0
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 2
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: LIST
33188: LIST
33189: LIST
33190: LIST
33191: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33192: LD_ADDR_VAR 0 49
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 0
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: LD_INT 1
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: LD_INT 1
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 1
33261: NEG
33262: PUSH
33263: LD_INT 1
33265: NEG
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 1
33273: PUSH
33274: LD_INT 1
33276: NEG
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 2
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 2
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 2
33304: PUSH
33305: LD_INT 2
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: LD_INT 2
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33336: LD_ADDR_VAR 0 50
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 0
33353: PUSH
33354: LD_INT 1
33356: NEG
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 1
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 1
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: LD_INT 1
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: LD_INT 0
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 1
33405: NEG
33406: PUSH
33407: LD_INT 1
33409: NEG
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 2
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 2
33427: PUSH
33428: LD_INT 2
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 0
33447: PUSH
33448: LD_INT 2
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: NEG
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33480: LD_ADDR_VAR 0 51
33484: PUSH
33485: LD_INT 0
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: LD_INT 1
33500: NEG
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: PUSH
33509: LD_INT 0
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 1
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 1
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: LD_INT 2
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 2
33592: NEG
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 2
33603: NEG
33604: PUSH
33605: LD_INT 1
33607: NEG
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33627: LD_ADDR_VAR 0 52
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 0
33644: PUSH
33645: LD_INT 1
33647: NEG
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: LD_INT 1
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 1
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: NEG
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: LD_INT 2
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: NEG
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 2
33731: NEG
33732: PUSH
33733: LD_INT 0
33735: PUSH
33736: EMPTY
33737: LIST
33738: LIST
33739: PUSH
33740: LD_INT 2
33742: NEG
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 2
33754: NEG
33755: PUSH
33756: LD_INT 2
33758: NEG
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33778: LD_ADDR_VAR 0 53
33782: PUSH
33783: LD_INT 0
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 0
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 1
33806: PUSH
33807: LD_INT 0
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 1
33816: PUSH
33817: LD_INT 1
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 0
33826: PUSH
33827: LD_INT 1
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: LD_INT 0
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: NEG
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 1
33859: NEG
33860: PUSH
33861: LD_INT 2
33863: NEG
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 0
33871: PUSH
33872: LD_INT 2
33874: NEG
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: PUSH
33887: EMPTY
33888: LIST
33889: LIST
33890: PUSH
33891: LD_INT 2
33893: PUSH
33894: LD_INT 0
33896: PUSH
33897: EMPTY
33898: LIST
33899: LIST
33900: PUSH
33901: LD_INT 2
33903: PUSH
33904: LD_INT 1
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 2
33913: PUSH
33914: LD_INT 2
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: PUSH
33924: LD_INT 2
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: LD_INT 2
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: NEG
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 2
33954: NEG
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 2
33965: NEG
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: LD_INT 2
33981: NEG
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34008: LD_ADDR_VAR 0 54
34012: PUSH
34013: LD_INT 0
34015: PUSH
34016: LD_INT 0
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 0
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 1
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: NEG
34067: PUSH
34068: LD_INT 0
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: NEG
34078: PUSH
34079: LD_INT 1
34081: NEG
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 1
34089: NEG
34090: PUSH
34091: LD_INT 2
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: LD_INT 2
34104: NEG
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: LD_INT 1
34115: NEG
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 2
34123: PUSH
34124: LD_INT 0
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: LD_INT 1
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: LD_INT 2
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: PUSH
34154: LD_INT 2
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: LD_INT 2
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 0
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 2
34195: NEG
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: NEG
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34238: LD_ADDR_VAR 0 55
34242: PUSH
34243: LD_INT 0
34245: PUSH
34246: LD_INT 0
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 0
34255: PUSH
34256: LD_INT 1
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: LD_INT 1
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 1
34296: NEG
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: LD_INT 1
34311: NEG
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 1
34319: NEG
34320: PUSH
34321: LD_INT 2
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 2
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 1
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: LD_INT 2
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: LD_INT 2
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: LD_INT 2
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: LD_INT 1
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: LD_INT 2
34414: NEG
34415: PUSH
34416: LD_INT 0
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 2
34425: NEG
34426: PUSH
34427: LD_INT 1
34429: NEG
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 2
34437: NEG
34438: PUSH
34439: LD_INT 2
34441: NEG
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34468: LD_ADDR_VAR 0 56
34472: PUSH
34473: LD_INT 0
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: LD_INT 0
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: PUSH
34507: LD_INT 1
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 1
34526: NEG
34527: PUSH
34528: LD_INT 0
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 1
34537: NEG
34538: PUSH
34539: LD_INT 1
34541: NEG
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 2
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 0
34561: PUSH
34562: LD_INT 2
34564: NEG
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: PUSH
34573: LD_INT 1
34575: NEG
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 0
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 2
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: PUSH
34614: LD_INT 2
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: LD_INT 2
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 1
34633: NEG
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 2
34644: NEG
34645: PUSH
34646: LD_INT 0
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 2
34655: NEG
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 2
34667: NEG
34668: PUSH
34669: LD_INT 2
34671: NEG
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34698: LD_ADDR_VAR 0 57
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: LD_INT 0
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 0
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 0
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: NEG
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: LD_INT 2
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 2
34794: NEG
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 1
34802: PUSH
34803: LD_INT 1
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: LD_INT 0
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 2
34823: PUSH
34824: LD_INT 1
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 2
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: LD_INT 2
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: LD_INT 2
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: NEG
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 2
34874: NEG
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 2
34885: NEG
34886: PUSH
34887: LD_INT 1
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: LIST
34915: LIST
34916: LIST
34917: LIST
34918: LIST
34919: LIST
34920: LIST
34921: LIST
34922: LIST
34923: LIST
34924: LIST
34925: LIST
34926: LIST
34927: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34928: LD_ADDR_VAR 0 58
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 0
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 1
34956: PUSH
34957: LD_INT 0
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 1
34966: PUSH
34967: LD_INT 1
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 0
34976: PUSH
34977: LD_INT 1
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 1
34986: NEG
34987: PUSH
34988: LD_INT 0
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 1
34997: NEG
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 2
35043: PUSH
35044: LD_INT 0
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 2
35053: PUSH
35054: LD_INT 1
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: LD_INT 2
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: LD_INT 2
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 2
35104: NEG
35105: PUSH
35106: LD_INT 0
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 2
35115: NEG
35116: PUSH
35117: LD_INT 1
35119: NEG
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 2
35127: NEG
35128: PUSH
35129: LD_INT 2
35131: NEG
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35158: LD_ADDR_VAR 0 59
35162: PUSH
35163: LD_INT 0
35165: PUSH
35166: LD_INT 0
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 1
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: LD_INT 0
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: LD_INT 1
35196: PUSH
35197: LD_INT 1
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: LD_INT 1
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: LD_INT 0
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 1
35227: NEG
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35246: LD_ADDR_VAR 0 60
35250: PUSH
35251: LD_INT 0
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 1
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 1
35304: NEG
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 1
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35334: LD_ADDR_VAR 0 61
35338: PUSH
35339: LD_INT 0
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: PUSH
35373: LD_INT 1
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 0
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: NEG
35404: PUSH
35405: LD_INT 1
35407: NEG
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35422: LD_ADDR_VAR 0 62
35426: PUSH
35427: LD_INT 0
35429: PUSH
35430: LD_INT 0
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: LD_INT 0
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: PUSH
35461: LD_INT 1
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 0
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35510: LD_ADDR_VAR 0 63
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 0
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: LD_INT 0
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 1
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 1
35568: NEG
35569: PUSH
35570: LD_INT 0
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: LD_INT 1
35583: NEG
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: LIST
35593: LIST
35594: LIST
35595: LIST
35596: LIST
35597: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35598: LD_ADDR_VAR 0 64
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: LD_INT 0
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 0
35646: PUSH
35647: LD_INT 1
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 1
35667: NEG
35668: PUSH
35669: LD_INT 1
35671: NEG
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: ST_TO_ADDR
// end ; 1 :
35686: GO 41583
35688: LD_INT 1
35690: DOUBLE
35691: EQUAL
35692: IFTRUE 35696
35694: GO 38319
35696: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35697: LD_ADDR_VAR 0 11
35701: PUSH
35702: LD_INT 1
35704: NEG
35705: PUSH
35706: LD_INT 3
35708: NEG
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 0
35716: PUSH
35717: LD_INT 3
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 2
35730: NEG
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: LIST
35740: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35741: LD_ADDR_VAR 0 12
35745: PUSH
35746: LD_INT 2
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 3
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 3
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: LIST
35781: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35782: LD_ADDR_VAR 0 13
35786: PUSH
35787: LD_INT 3
35789: PUSH
35790: LD_INT 2
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 3
35799: PUSH
35800: LD_INT 3
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 2
35809: PUSH
35810: LD_INT 3
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: LIST
35821: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35822: LD_ADDR_VAR 0 14
35826: PUSH
35827: LD_INT 1
35829: PUSH
35830: LD_INT 3
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 3
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: LD_INT 2
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: LIST
35862: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35863: LD_ADDR_VAR 0 15
35867: PUSH
35868: LD_INT 2
35870: NEG
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 3
35881: NEG
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 3
35892: NEG
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: LIST
35906: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35907: LD_ADDR_VAR 0 16
35911: PUSH
35912: LD_INT 2
35914: NEG
35915: PUSH
35916: LD_INT 3
35918: NEG
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 3
35926: NEG
35927: PUSH
35928: LD_INT 2
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: NEG
35939: PUSH
35940: LD_INT 3
35942: NEG
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: LIST
35952: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35953: LD_ADDR_VAR 0 17
35957: PUSH
35958: LD_INT 1
35960: NEG
35961: PUSH
35962: LD_INT 3
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 0
35972: PUSH
35973: LD_INT 3
35975: NEG
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: LIST
35996: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35997: LD_ADDR_VAR 0 18
36001: PUSH
36002: LD_INT 2
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 3
36015: PUSH
36016: LD_INT 0
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 3
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: LIST
36037: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36038: LD_ADDR_VAR 0 19
36042: PUSH
36043: LD_INT 3
36045: PUSH
36046: LD_INT 2
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 3
36055: PUSH
36056: LD_INT 3
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 2
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: LIST
36077: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36078: LD_ADDR_VAR 0 20
36082: PUSH
36083: LD_INT 1
36085: PUSH
36086: LD_INT 3
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 0
36095: PUSH
36096: LD_INT 3
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 1
36105: NEG
36106: PUSH
36107: LD_INT 2
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: LIST
36118: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36119: LD_ADDR_VAR 0 21
36123: PUSH
36124: LD_INT 2
36126: NEG
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 3
36137: NEG
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 3
36148: NEG
36149: PUSH
36150: LD_INT 1
36152: NEG
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: LIST
36162: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36163: LD_ADDR_VAR 0 22
36167: PUSH
36168: LD_INT 2
36170: NEG
36171: PUSH
36172: LD_INT 3
36174: NEG
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 3
36182: NEG
36183: PUSH
36184: LD_INT 2
36186: NEG
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: LD_INT 3
36194: NEG
36195: PUSH
36196: LD_INT 3
36198: NEG
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: LIST
36208: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36209: LD_ADDR_VAR 0 23
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 3
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: NEG
36228: PUSH
36229: LD_INT 4
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 1
36239: PUSH
36240: LD_INT 3
36242: NEG
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: LIST
36252: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36253: LD_ADDR_VAR 0 24
36257: PUSH
36258: LD_INT 3
36260: PUSH
36261: LD_INT 0
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 3
36270: PUSH
36271: LD_INT 1
36273: NEG
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 4
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: LIST
36293: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36294: LD_ADDR_VAR 0 25
36298: PUSH
36299: LD_INT 3
36301: PUSH
36302: LD_INT 3
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 4
36311: PUSH
36312: LD_INT 3
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 3
36321: PUSH
36322: LD_INT 4
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: LIST
36333: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36334: LD_ADDR_VAR 0 26
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 3
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: LD_INT 4
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: NEG
36362: PUSH
36363: LD_INT 3
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: LIST
36374: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36375: LD_ADDR_VAR 0 27
36379: PUSH
36380: LD_INT 3
36382: NEG
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 3
36393: NEG
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 4
36404: NEG
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: LIST
36418: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36419: LD_ADDR_VAR 0 28
36423: PUSH
36424: LD_INT 3
36426: NEG
36427: PUSH
36428: LD_INT 3
36430: NEG
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 3
36438: NEG
36439: PUSH
36440: LD_INT 4
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 4
36450: NEG
36451: PUSH
36452: LD_INT 3
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36465: LD_ADDR_VAR 0 29
36469: PUSH
36470: LD_INT 1
36472: NEG
36473: PUSH
36474: LD_INT 3
36476: NEG
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: LD_INT 3
36487: NEG
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 1
36495: PUSH
36496: LD_INT 2
36498: NEG
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: LD_INT 4
36510: NEG
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 0
36518: PUSH
36519: LD_INT 4
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: LD_INT 3
36532: NEG
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: NEG
36541: PUSH
36542: LD_INT 5
36544: NEG
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 0
36552: PUSH
36553: LD_INT 5
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: LD_INT 4
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: LD_INT 6
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: LD_INT 6
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 1
36597: PUSH
36598: LD_INT 5
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36620: LD_ADDR_VAR 0 30
36624: PUSH
36625: LD_INT 2
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 3
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 3
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 3
36658: PUSH
36659: LD_INT 1
36661: NEG
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 4
36669: PUSH
36670: LD_INT 0
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 4
36679: PUSH
36680: LD_INT 1
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 4
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 5
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 5
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 5
36720: PUSH
36721: LD_INT 1
36723: NEG
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 6
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 6
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: LIST
36762: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36763: LD_ADDR_VAR 0 31
36767: PUSH
36768: LD_INT 3
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 3
36780: PUSH
36781: LD_INT 3
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 3
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 4
36800: PUSH
36801: LD_INT 3
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 4
36810: PUSH
36811: LD_INT 4
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: LD_INT 4
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 5
36830: PUSH
36831: LD_INT 4
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 5
36840: PUSH
36841: LD_INT 5
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 4
36850: PUSH
36851: LD_INT 5
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 6
36860: PUSH
36861: LD_INT 5
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 6
36870: PUSH
36871: LD_INT 6
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 5
36880: PUSH
36881: LD_INT 6
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36902: LD_ADDR_VAR 0 32
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: LD_INT 3
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: NEG
36930: PUSH
36931: LD_INT 2
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: PUSH
36941: LD_INT 4
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 0
36950: PUSH
36951: LD_INT 4
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 1
36960: NEG
36961: PUSH
36962: LD_INT 3
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 1
36971: PUSH
36972: LD_INT 5
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: LD_INT 5
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 1
36991: NEG
36992: PUSH
36993: LD_INT 4
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 1
37002: PUSH
37003: LD_INT 6
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: LD_INT 6
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: NEG
37023: PUSH
37024: LD_INT 5
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37045: LD_ADDR_VAR 0 33
37049: PUSH
37050: LD_INT 2
37052: NEG
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 3
37063: NEG
37064: PUSH
37065: LD_INT 0
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 3
37074: NEG
37075: PUSH
37076: LD_INT 1
37078: NEG
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 3
37086: NEG
37087: PUSH
37088: LD_INT 1
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 4
37097: NEG
37098: PUSH
37099: LD_INT 0
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 4
37108: NEG
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 4
37120: NEG
37121: PUSH
37122: LD_INT 1
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 5
37131: NEG
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 5
37142: NEG
37143: PUSH
37144: LD_INT 1
37146: NEG
37147: PUSH
37148: EMPTY
37149: LIST
37150: LIST
37151: PUSH
37152: LD_INT 5
37154: NEG
37155: PUSH
37156: LD_INT 1
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 6
37165: NEG
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 6
37176: NEG
37177: PUSH
37178: LD_INT 1
37180: NEG
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: LIST
37199: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37200: LD_ADDR_VAR 0 34
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: LD_INT 3
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 3
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 3
37231: NEG
37232: PUSH
37233: LD_INT 3
37235: NEG
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 3
37243: NEG
37244: PUSH
37245: LD_INT 4
37247: NEG
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 4
37255: NEG
37256: PUSH
37257: LD_INT 3
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 4
37267: NEG
37268: PUSH
37269: LD_INT 4
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 4
37279: NEG
37280: PUSH
37281: LD_INT 5
37283: NEG
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 5
37291: NEG
37292: PUSH
37293: LD_INT 4
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 5
37303: NEG
37304: PUSH
37305: LD_INT 5
37307: NEG
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 5
37315: NEG
37316: PUSH
37317: LD_INT 6
37319: NEG
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 6
37327: NEG
37328: PUSH
37329: LD_INT 5
37331: NEG
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: LD_INT 6
37339: NEG
37340: PUSH
37341: LD_INT 6
37343: NEG
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37363: LD_ADDR_VAR 0 41
37367: PUSH
37368: LD_INT 0
37370: PUSH
37371: LD_INT 2
37373: NEG
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 1
37381: NEG
37382: PUSH
37383: LD_INT 3
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 2
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: LIST
37406: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37407: LD_ADDR_VAR 0 42
37411: PUSH
37412: LD_INT 2
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 2
37424: PUSH
37425: LD_INT 1
37427: NEG
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 3
37435: PUSH
37436: LD_INT 1
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: LIST
37447: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37448: LD_ADDR_VAR 0 43
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 2
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: LD_INT 2
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 2
37475: PUSH
37476: LD_INT 3
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: LIST
37487: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37488: LD_ADDR_VAR 0 44
37492: PUSH
37493: LD_INT 0
37495: PUSH
37496: LD_INT 2
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 1
37505: PUSH
37506: LD_INT 3
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: LIST
37528: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37529: LD_ADDR_VAR 0 45
37533: PUSH
37534: LD_INT 2
37536: NEG
37537: PUSH
37538: LD_INT 0
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 2
37547: NEG
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 3
37558: NEG
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: LIST
37572: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37573: LD_ADDR_VAR 0 46
37577: PUSH
37578: LD_INT 2
37580: NEG
37581: PUSH
37582: LD_INT 2
37584: NEG
37585: PUSH
37586: EMPTY
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 2
37592: NEG
37593: PUSH
37594: LD_INT 3
37596: NEG
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 3
37604: NEG
37605: PUSH
37606: LD_INT 2
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: LIST
37618: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37619: LD_ADDR_VAR 0 47
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: LD_INT 3
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 1
37638: NEG
37639: PUSH
37640: LD_INT 3
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37652: LD_ADDR_VAR 0 48
37656: PUSH
37657: LD_INT 1
37659: PUSH
37660: LD_INT 2
37662: NEG
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 2
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37683: LD_ADDR_VAR 0 49
37687: PUSH
37688: LD_INT 3
37690: PUSH
37691: LD_INT 1
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 3
37700: PUSH
37701: LD_INT 2
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37712: LD_ADDR_VAR 0 50
37716: PUSH
37717: LD_INT 2
37719: PUSH
37720: LD_INT 3
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 3
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37741: LD_ADDR_VAR 0 51
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: LD_INT 2
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 2
37759: NEG
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37772: LD_ADDR_VAR 0 52
37776: PUSH
37777: LD_INT 3
37779: NEG
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 3
37791: NEG
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37805: LD_ADDR_VAR 0 53
37809: PUSH
37810: LD_INT 1
37812: NEG
37813: PUSH
37814: LD_INT 3
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: LD_INT 3
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: LD_INT 2
37838: NEG
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: LIST
37848: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37849: LD_ADDR_VAR 0 54
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 0
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 3
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: LIST
37889: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37890: LD_ADDR_VAR 0 55
37894: PUSH
37895: LD_INT 3
37897: PUSH
37898: LD_INT 2
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 3
37907: PUSH
37908: LD_INT 3
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 2
37917: PUSH
37918: LD_INT 3
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: LIST
37929: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37930: LD_ADDR_VAR 0 56
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: LD_INT 3
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: LD_INT 3
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: LD_INT 2
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: LIST
37970: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37971: LD_ADDR_VAR 0 57
37975: PUSH
37976: LD_INT 2
37978: NEG
37979: PUSH
37980: LD_INT 1
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 3
37989: NEG
37990: PUSH
37991: LD_INT 0
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 3
38000: NEG
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: LIST
38014: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38015: LD_ADDR_VAR 0 58
38019: PUSH
38020: LD_INT 2
38022: NEG
38023: PUSH
38024: LD_INT 3
38026: NEG
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 3
38034: NEG
38035: PUSH
38036: LD_INT 2
38038: NEG
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 3
38046: NEG
38047: PUSH
38048: LD_INT 3
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: LIST
38060: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38061: LD_ADDR_VAR 0 59
38065: PUSH
38066: LD_INT 1
38068: NEG
38069: PUSH
38070: LD_INT 2
38072: NEG
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: LD_INT 2
38083: NEG
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 1
38091: PUSH
38092: LD_INT 1
38094: NEG
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: LIST
38104: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38105: LD_ADDR_VAR 0 60
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 2
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 2
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: LIST
38145: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38146: LD_ADDR_VAR 0 61
38150: PUSH
38151: LD_INT 2
38153: PUSH
38154: LD_INT 1
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: PUSH
38164: LD_INT 2
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 2
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: LIST
38185: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38186: LD_ADDR_VAR 0 62
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: LD_INT 2
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: LD_INT 2
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 1
38213: NEG
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38227: LD_ADDR_VAR 0 63
38231: PUSH
38232: LD_INT 1
38234: NEG
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 2
38245: NEG
38246: PUSH
38247: LD_INT 0
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38271: LD_ADDR_VAR 0 64
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 2
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 2
38290: NEG
38291: PUSH
38292: LD_INT 1
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 2
38302: NEG
38303: PUSH
38304: LD_INT 2
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: LIST
38316: ST_TO_ADDR
// end ; 2 :
38317: GO 41583
38319: LD_INT 2
38321: DOUBLE
38322: EQUAL
38323: IFTRUE 38327
38325: GO 41582
38327: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38328: LD_ADDR_VAR 0 29
38332: PUSH
38333: LD_INT 4
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 4
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 5
38356: PUSH
38357: LD_INT 0
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 5
38366: PUSH
38367: LD_INT 1
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 4
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 3
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 3
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 3
38407: PUSH
38408: LD_INT 2
38410: NEG
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 5
38418: PUSH
38419: LD_INT 2
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 3
38428: PUSH
38429: LD_INT 3
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 3
38438: PUSH
38439: LD_INT 2
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 4
38448: PUSH
38449: LD_INT 3
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 4
38458: PUSH
38459: LD_INT 4
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 3
38468: PUSH
38469: LD_INT 4
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 3
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 2
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 4
38498: PUSH
38499: LD_INT 2
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 2
38508: PUSH
38509: LD_INT 4
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 0
38518: PUSH
38519: LD_INT 4
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 0
38528: PUSH
38529: LD_INT 3
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 1
38538: PUSH
38539: LD_INT 4
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: LD_INT 5
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 0
38558: PUSH
38559: LD_INT 5
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: NEG
38569: PUSH
38570: LD_INT 4
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: LD_INT 3
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 2
38590: PUSH
38591: LD_INT 5
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: LD_INT 3
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 3
38611: NEG
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 3
38622: NEG
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 2
38634: NEG
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 2
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 3
38656: NEG
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 4
38667: NEG
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 4
38678: NEG
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 4
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 4
38713: NEG
38714: PUSH
38715: LD_INT 4
38717: NEG
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 4
38725: NEG
38726: PUSH
38727: LD_INT 5
38729: NEG
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 3
38737: NEG
38738: PUSH
38739: LD_INT 4
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: LD_INT 3
38753: NEG
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 4
38761: NEG
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 5
38773: NEG
38774: PUSH
38775: LD_INT 4
38777: NEG
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 5
38785: NEG
38786: PUSH
38787: LD_INT 5
38789: NEG
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 3
38797: NEG
38798: PUSH
38799: LD_INT 5
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 5
38809: NEG
38810: PUSH
38811: LD_INT 3
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: LIST
38839: LIST
38840: LIST
38841: LIST
38842: LIST
38843: LIST
38844: LIST
38845: LIST
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38866: LD_ADDR_VAR 0 30
38870: PUSH
38871: LD_INT 4
38873: PUSH
38874: LD_INT 4
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 4
38883: PUSH
38884: LD_INT 3
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 5
38893: PUSH
38894: LD_INT 4
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 5
38903: PUSH
38904: LD_INT 5
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 4
38913: PUSH
38914: LD_INT 5
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: PUSH
38921: LD_INT 3
38923: PUSH
38924: LD_INT 4
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 3
38933: PUSH
38934: LD_INT 3
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 5
38943: PUSH
38944: LD_INT 3
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 3
38953: PUSH
38954: LD_INT 5
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 3
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 0
38973: PUSH
38974: LD_INT 2
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: LD_INT 3
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: LD_INT 4
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 0
39003: PUSH
39004: LD_INT 4
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 1
39013: NEG
39014: PUSH
39015: LD_INT 3
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: LD_INT 2
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 2
39035: PUSH
39036: LD_INT 4
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 2
39045: NEG
39046: PUSH
39047: LD_INT 2
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 4
39056: NEG
39057: PUSH
39058: LD_INT 0
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 4
39067: NEG
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 3
39079: NEG
39080: PUSH
39081: LD_INT 0
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 3
39090: NEG
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 4
39101: NEG
39102: PUSH
39103: LD_INT 1
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 5
39112: NEG
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 5
39123: NEG
39124: PUSH
39125: LD_INT 1
39127: NEG
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 5
39135: NEG
39136: PUSH
39137: LD_INT 2
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 3
39147: NEG
39148: PUSH
39149: LD_INT 2
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 3
39158: NEG
39159: PUSH
39160: LD_INT 3
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 3
39170: NEG
39171: PUSH
39172: LD_INT 4
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 2
39182: NEG
39183: PUSH
39184: LD_INT 3
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 2
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 3
39206: NEG
39207: PUSH
39208: LD_INT 2
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 4
39218: NEG
39219: PUSH
39220: LD_INT 3
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 4
39230: NEG
39231: PUSH
39232: LD_INT 4
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: LD_INT 4
39246: NEG
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 4
39254: NEG
39255: PUSH
39256: LD_INT 2
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: LD_INT 4
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 5
39280: NEG
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: LD_INT 4
39291: NEG
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 1
39299: PUSH
39300: LD_INT 3
39302: NEG
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 0
39310: PUSH
39311: LD_INT 3
39313: NEG
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 1
39321: NEG
39322: PUSH
39323: LD_INT 4
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 1
39333: NEG
39334: PUSH
39335: LD_INT 5
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 2
39345: PUSH
39346: LD_INT 3
39348: NEG
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 2
39356: NEG
39357: PUSH
39358: LD_INT 5
39360: NEG
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39413: LD_ADDR_VAR 0 31
39417: PUSH
39418: LD_INT 0
39420: PUSH
39421: LD_INT 4
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 0
39430: PUSH
39431: LD_INT 3
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 1
39440: PUSH
39441: LD_INT 4
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 1
39450: PUSH
39451: LD_INT 5
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 0
39460: PUSH
39461: LD_INT 5
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 1
39470: NEG
39471: PUSH
39472: LD_INT 4
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 2
39492: PUSH
39493: LD_INT 5
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: LD_INT 3
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: LD_INT 0
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 3
39524: NEG
39525: PUSH
39526: LD_INT 1
39528: NEG
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 2
39536: NEG
39537: PUSH
39538: LD_INT 0
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 2
39547: NEG
39548: PUSH
39549: LD_INT 1
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 3
39558: NEG
39559: PUSH
39560: LD_INT 1
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 4
39569: NEG
39570: PUSH
39571: LD_INT 0
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 4
39580: NEG
39581: PUSH
39582: LD_INT 1
39584: NEG
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: PUSH
39590: LD_INT 4
39592: NEG
39593: PUSH
39594: LD_INT 2
39596: NEG
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 2
39604: NEG
39605: PUSH
39606: LD_INT 2
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 4
39615: NEG
39616: PUSH
39617: LD_INT 4
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 4
39627: NEG
39628: PUSH
39629: LD_INT 5
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 3
39639: NEG
39640: PUSH
39641: LD_INT 4
39643: NEG
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 3
39651: NEG
39652: PUSH
39653: LD_INT 3
39655: NEG
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 4
39663: NEG
39664: PUSH
39665: LD_INT 3
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 5
39675: NEG
39676: PUSH
39677: LD_INT 4
39679: NEG
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 5
39687: NEG
39688: PUSH
39689: LD_INT 5
39691: NEG
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: LD_INT 5
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 5
39711: NEG
39712: PUSH
39713: LD_INT 3
39715: NEG
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: LD_INT 3
39726: NEG
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 0
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: LD_INT 3
39748: NEG
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: LD_INT 2
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 0
39767: PUSH
39768: LD_INT 2
39770: NEG
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 1
39778: NEG
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: NEG
39791: PUSH
39792: LD_INT 4
39794: NEG
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 2
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 2
39813: NEG
39814: PUSH
39815: LD_INT 4
39817: NEG
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 4
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 4
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 5
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 5
39856: PUSH
39857: LD_INT 1
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 4
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 3
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 3
39886: PUSH
39887: LD_INT 1
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 3
39897: PUSH
39898: LD_INT 2
39900: NEG
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 5
39908: PUSH
39909: LD_INT 2
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39963: LD_ADDR_VAR 0 32
39967: PUSH
39968: LD_INT 4
39970: NEG
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 4
39981: NEG
39982: PUSH
39983: LD_INT 1
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 3
39993: NEG
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 3
40004: NEG
40005: PUSH
40006: LD_INT 1
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 4
40015: NEG
40016: PUSH
40017: LD_INT 1
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 5
40026: NEG
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 5
40037: NEG
40038: PUSH
40039: LD_INT 1
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 5
40049: NEG
40050: PUSH
40051: LD_INT 2
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 3
40061: NEG
40062: PUSH
40063: LD_INT 2
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 3
40072: NEG
40073: PUSH
40074: LD_INT 3
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 3
40084: NEG
40085: PUSH
40086: LD_INT 4
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 2
40096: NEG
40097: PUSH
40098: LD_INT 3
40100: NEG
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 2
40108: NEG
40109: PUSH
40110: LD_INT 2
40112: NEG
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 3
40120: NEG
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 4
40132: NEG
40133: PUSH
40134: LD_INT 3
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 4
40144: NEG
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 2
40156: NEG
40157: PUSH
40158: LD_INT 4
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 4
40168: NEG
40169: PUSH
40170: LD_INT 2
40172: NEG
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: LD_INT 4
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: LD_INT 5
40194: NEG
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: LD_INT 4
40205: NEG
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: LD_INT 3
40216: NEG
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: LD_INT 3
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: LD_INT 4
40239: NEG
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 1
40247: NEG
40248: PUSH
40249: LD_INT 5
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 2
40259: PUSH
40260: LD_INT 3
40262: NEG
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 2
40270: NEG
40271: PUSH
40272: LD_INT 5
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 3
40282: PUSH
40283: LD_INT 0
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 3
40292: PUSH
40293: LD_INT 1
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 4
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 4
40313: PUSH
40314: LD_INT 1
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 3
40323: PUSH
40324: LD_INT 1
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 2
40333: PUSH
40334: LD_INT 0
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 2
40343: PUSH
40344: LD_INT 1
40346: NEG
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 2
40354: PUSH
40355: LD_INT 2
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 4
40365: PUSH
40366: LD_INT 2
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 4
40375: PUSH
40376: LD_INT 4
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 4
40385: PUSH
40386: LD_INT 3
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 5
40395: PUSH
40396: LD_INT 4
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 5
40405: PUSH
40406: LD_INT 5
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 4
40415: PUSH
40416: LD_INT 5
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 3
40425: PUSH
40426: LD_INT 4
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 3
40435: PUSH
40436: LD_INT 3
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 5
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: PUSH
40456: LD_INT 5
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40510: LD_ADDR_VAR 0 33
40514: PUSH
40515: LD_INT 4
40517: NEG
40518: PUSH
40519: LD_INT 4
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 4
40529: NEG
40530: PUSH
40531: LD_INT 5
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 3
40541: NEG
40542: PUSH
40543: LD_INT 4
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 3
40553: NEG
40554: PUSH
40555: LD_INT 3
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 4
40565: NEG
40566: PUSH
40567: LD_INT 3
40569: NEG
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 5
40577: NEG
40578: PUSH
40579: LD_INT 4
40581: NEG
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 5
40589: NEG
40590: PUSH
40591: LD_INT 5
40593: NEG
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 3
40601: NEG
40602: PUSH
40603: LD_INT 5
40605: NEG
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 5
40613: NEG
40614: PUSH
40615: LD_INT 3
40617: NEG
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: LD_INT 3
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 0
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 3
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 1
40658: PUSH
40659: LD_INT 2
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 0
40669: PUSH
40670: LD_INT 2
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: NEG
40681: PUSH
40682: LD_INT 3
40684: NEG
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 1
40692: NEG
40693: PUSH
40694: LD_INT 4
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 2
40704: PUSH
40705: LD_INT 2
40707: NEG
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 2
40715: NEG
40716: PUSH
40717: LD_INT 4
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 4
40727: PUSH
40728: LD_INT 0
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 4
40737: PUSH
40738: LD_INT 1
40740: NEG
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 5
40748: PUSH
40749: LD_INT 0
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 5
40758: PUSH
40759: LD_INT 1
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 4
40768: PUSH
40769: LD_INT 1
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 3
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 3
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 3
40799: PUSH
40800: LD_INT 2
40802: NEG
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 5
40810: PUSH
40811: LD_INT 2
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 3
40820: PUSH
40821: LD_INT 3
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 3
40830: PUSH
40831: LD_INT 2
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 4
40840: PUSH
40841: LD_INT 3
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 4
40850: PUSH
40851: LD_INT 4
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 3
40860: PUSH
40861: LD_INT 4
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 2
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: LD_INT 2
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 4
40890: PUSH
40891: LD_INT 2
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 4
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: LD_INT 4
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 1
40930: PUSH
40931: LD_INT 4
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: LD_INT 1
40940: PUSH
40941: LD_INT 5
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: LD_INT 0
40950: PUSH
40951: LD_INT 5
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 1
40960: NEG
40961: PUSH
40962: LD_INT 4
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: NEG
40972: PUSH
40973: LD_INT 3
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 2
40982: PUSH
40983: LD_INT 5
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 2
40992: NEG
40993: PUSH
40994: LD_INT 3
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41048: LD_ADDR_VAR 0 34
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: LD_INT 4
41058: NEG
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 0
41066: PUSH
41067: LD_INT 5
41069: NEG
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: LD_INT 4
41080: NEG
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: LD_INT 3
41091: NEG
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 0
41099: PUSH
41100: LD_INT 3
41102: NEG
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 1
41110: NEG
41111: PUSH
41112: LD_INT 4
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: NEG
41123: PUSH
41124: LD_INT 5
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: PUSH
41135: LD_INT 3
41137: NEG
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 2
41145: NEG
41146: PUSH
41147: LD_INT 5
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 3
41157: PUSH
41158: LD_INT 0
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: PUSH
41168: LD_INT 1
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 4
41178: PUSH
41179: LD_INT 0
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: PUSH
41189: LD_INT 1
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 3
41198: PUSH
41199: LD_INT 1
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 2
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: LD_INT 1
41221: NEG
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 2
41229: PUSH
41230: LD_INT 2
41232: NEG
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 4
41240: PUSH
41241: LD_INT 2
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 4
41250: PUSH
41251: LD_INT 4
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 4
41260: PUSH
41261: LD_INT 3
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 5
41270: PUSH
41271: LD_INT 4
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 5
41280: PUSH
41281: LD_INT 5
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 4
41290: PUSH
41291: LD_INT 5
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: LD_INT 3
41300: PUSH
41301: LD_INT 4
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: LD_INT 3
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 5
41320: PUSH
41321: LD_INT 3
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 3
41330: PUSH
41331: LD_INT 5
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 0
41340: PUSH
41341: LD_INT 3
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: LD_INT 2
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: LD_INT 3
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: LD_INT 4
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: LD_INT 4
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: LD_INT 3
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PUSH
41403: LD_INT 2
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 2
41412: PUSH
41413: LD_INT 4
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 2
41422: NEG
41423: PUSH
41424: LD_INT 2
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 4
41433: NEG
41434: PUSH
41435: LD_INT 0
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 4
41444: NEG
41445: PUSH
41446: LD_INT 1
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 3
41456: NEG
41457: PUSH
41458: LD_INT 0
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PUSH
41465: LD_INT 3
41467: NEG
41468: PUSH
41469: LD_INT 1
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 4
41478: NEG
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 5
41489: NEG
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 5
41500: NEG
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 5
41512: NEG
41513: PUSH
41514: LD_INT 2
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 3
41524: NEG
41525: PUSH
41526: LD_INT 2
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: ST_TO_ADDR
// end ; end ;
41580: GO 41583
41582: POP
// case btype of b_depot , b_warehouse :
41583: LD_VAR 0 1
41587: PUSH
41588: LD_INT 0
41590: DOUBLE
41591: EQUAL
41592: IFTRUE 41602
41594: LD_INT 1
41596: DOUBLE
41597: EQUAL
41598: IFTRUE 41602
41600: GO 41803
41602: POP
// case nation of nation_american :
41603: LD_VAR 0 5
41607: PUSH
41608: LD_INT 1
41610: DOUBLE
41611: EQUAL
41612: IFTRUE 41616
41614: GO 41672
41616: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41617: LD_ADDR_VAR 0 9
41621: PUSH
41622: LD_VAR 0 11
41626: PUSH
41627: LD_VAR 0 12
41631: PUSH
41632: LD_VAR 0 13
41636: PUSH
41637: LD_VAR 0 14
41641: PUSH
41642: LD_VAR 0 15
41646: PUSH
41647: LD_VAR 0 16
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: PUSH
41660: LD_VAR 0 4
41664: PUSH
41665: LD_INT 1
41667: PLUS
41668: ARRAY
41669: ST_TO_ADDR
41670: GO 41801
41672: LD_INT 2
41674: DOUBLE
41675: EQUAL
41676: IFTRUE 41680
41678: GO 41736
41680: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41681: LD_ADDR_VAR 0 9
41685: PUSH
41686: LD_VAR 0 17
41690: PUSH
41691: LD_VAR 0 18
41695: PUSH
41696: LD_VAR 0 19
41700: PUSH
41701: LD_VAR 0 20
41705: PUSH
41706: LD_VAR 0 21
41710: PUSH
41711: LD_VAR 0 22
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: PUSH
41724: LD_VAR 0 4
41728: PUSH
41729: LD_INT 1
41731: PLUS
41732: ARRAY
41733: ST_TO_ADDR
41734: GO 41801
41736: LD_INT 3
41738: DOUBLE
41739: EQUAL
41740: IFTRUE 41744
41742: GO 41800
41744: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41745: LD_ADDR_VAR 0 9
41749: PUSH
41750: LD_VAR 0 23
41754: PUSH
41755: LD_VAR 0 24
41759: PUSH
41760: LD_VAR 0 25
41764: PUSH
41765: LD_VAR 0 26
41769: PUSH
41770: LD_VAR 0 27
41774: PUSH
41775: LD_VAR 0 28
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: PUSH
41788: LD_VAR 0 4
41792: PUSH
41793: LD_INT 1
41795: PLUS
41796: ARRAY
41797: ST_TO_ADDR
41798: GO 41801
41800: POP
41801: GO 42356
41803: LD_INT 2
41805: DOUBLE
41806: EQUAL
41807: IFTRUE 41817
41809: LD_INT 3
41811: DOUBLE
41812: EQUAL
41813: IFTRUE 41817
41815: GO 41873
41817: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41818: LD_ADDR_VAR 0 9
41822: PUSH
41823: LD_VAR 0 29
41827: PUSH
41828: LD_VAR 0 30
41832: PUSH
41833: LD_VAR 0 31
41837: PUSH
41838: LD_VAR 0 32
41842: PUSH
41843: LD_VAR 0 33
41847: PUSH
41848: LD_VAR 0 34
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: LIST
41858: LIST
41859: LIST
41860: PUSH
41861: LD_VAR 0 4
41865: PUSH
41866: LD_INT 1
41868: PLUS
41869: ARRAY
41870: ST_TO_ADDR
41871: GO 42356
41873: LD_INT 16
41875: DOUBLE
41876: EQUAL
41877: IFTRUE 41935
41879: LD_INT 17
41881: DOUBLE
41882: EQUAL
41883: IFTRUE 41935
41885: LD_INT 18
41887: DOUBLE
41888: EQUAL
41889: IFTRUE 41935
41891: LD_INT 19
41893: DOUBLE
41894: EQUAL
41895: IFTRUE 41935
41897: LD_INT 22
41899: DOUBLE
41900: EQUAL
41901: IFTRUE 41935
41903: LD_INT 20
41905: DOUBLE
41906: EQUAL
41907: IFTRUE 41935
41909: LD_INT 21
41911: DOUBLE
41912: EQUAL
41913: IFTRUE 41935
41915: LD_INT 23
41917: DOUBLE
41918: EQUAL
41919: IFTRUE 41935
41921: LD_INT 24
41923: DOUBLE
41924: EQUAL
41925: IFTRUE 41935
41927: LD_INT 25
41929: DOUBLE
41930: EQUAL
41931: IFTRUE 41935
41933: GO 41991
41935: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41936: LD_ADDR_VAR 0 9
41940: PUSH
41941: LD_VAR 0 35
41945: PUSH
41946: LD_VAR 0 36
41950: PUSH
41951: LD_VAR 0 37
41955: PUSH
41956: LD_VAR 0 38
41960: PUSH
41961: LD_VAR 0 39
41965: PUSH
41966: LD_VAR 0 40
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: LIST
41975: LIST
41976: LIST
41977: LIST
41978: PUSH
41979: LD_VAR 0 4
41983: PUSH
41984: LD_INT 1
41986: PLUS
41987: ARRAY
41988: ST_TO_ADDR
41989: GO 42356
41991: LD_INT 6
41993: DOUBLE
41994: EQUAL
41995: IFTRUE 42047
41997: LD_INT 7
41999: DOUBLE
42000: EQUAL
42001: IFTRUE 42047
42003: LD_INT 8
42005: DOUBLE
42006: EQUAL
42007: IFTRUE 42047
42009: LD_INT 13
42011: DOUBLE
42012: EQUAL
42013: IFTRUE 42047
42015: LD_INT 12
42017: DOUBLE
42018: EQUAL
42019: IFTRUE 42047
42021: LD_INT 15
42023: DOUBLE
42024: EQUAL
42025: IFTRUE 42047
42027: LD_INT 11
42029: DOUBLE
42030: EQUAL
42031: IFTRUE 42047
42033: LD_INT 14
42035: DOUBLE
42036: EQUAL
42037: IFTRUE 42047
42039: LD_INT 10
42041: DOUBLE
42042: EQUAL
42043: IFTRUE 42047
42045: GO 42103
42047: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42048: LD_ADDR_VAR 0 9
42052: PUSH
42053: LD_VAR 0 41
42057: PUSH
42058: LD_VAR 0 42
42062: PUSH
42063: LD_VAR 0 43
42067: PUSH
42068: LD_VAR 0 44
42072: PUSH
42073: LD_VAR 0 45
42077: PUSH
42078: LD_VAR 0 46
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: PUSH
42091: LD_VAR 0 4
42095: PUSH
42096: LD_INT 1
42098: PLUS
42099: ARRAY
42100: ST_TO_ADDR
42101: GO 42356
42103: LD_INT 36
42105: DOUBLE
42106: EQUAL
42107: IFTRUE 42111
42109: GO 42167
42111: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42112: LD_ADDR_VAR 0 9
42116: PUSH
42117: LD_VAR 0 47
42121: PUSH
42122: LD_VAR 0 48
42126: PUSH
42127: LD_VAR 0 49
42131: PUSH
42132: LD_VAR 0 50
42136: PUSH
42137: LD_VAR 0 51
42141: PUSH
42142: LD_VAR 0 52
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: PUSH
42155: LD_VAR 0 4
42159: PUSH
42160: LD_INT 1
42162: PLUS
42163: ARRAY
42164: ST_TO_ADDR
42165: GO 42356
42167: LD_INT 4
42169: DOUBLE
42170: EQUAL
42171: IFTRUE 42193
42173: LD_INT 5
42175: DOUBLE
42176: EQUAL
42177: IFTRUE 42193
42179: LD_INT 34
42181: DOUBLE
42182: EQUAL
42183: IFTRUE 42193
42185: LD_INT 37
42187: DOUBLE
42188: EQUAL
42189: IFTRUE 42193
42191: GO 42249
42193: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42194: LD_ADDR_VAR 0 9
42198: PUSH
42199: LD_VAR 0 53
42203: PUSH
42204: LD_VAR 0 54
42208: PUSH
42209: LD_VAR 0 55
42213: PUSH
42214: LD_VAR 0 56
42218: PUSH
42219: LD_VAR 0 57
42223: PUSH
42224: LD_VAR 0 58
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: PUSH
42237: LD_VAR 0 4
42241: PUSH
42242: LD_INT 1
42244: PLUS
42245: ARRAY
42246: ST_TO_ADDR
42247: GO 42356
42249: LD_INT 31
42251: DOUBLE
42252: EQUAL
42253: IFTRUE 42299
42255: LD_INT 32
42257: DOUBLE
42258: EQUAL
42259: IFTRUE 42299
42261: LD_INT 33
42263: DOUBLE
42264: EQUAL
42265: IFTRUE 42299
42267: LD_INT 27
42269: DOUBLE
42270: EQUAL
42271: IFTRUE 42299
42273: LD_INT 26
42275: DOUBLE
42276: EQUAL
42277: IFTRUE 42299
42279: LD_INT 28
42281: DOUBLE
42282: EQUAL
42283: IFTRUE 42299
42285: LD_INT 29
42287: DOUBLE
42288: EQUAL
42289: IFTRUE 42299
42291: LD_INT 30
42293: DOUBLE
42294: EQUAL
42295: IFTRUE 42299
42297: GO 42355
42299: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42300: LD_ADDR_VAR 0 9
42304: PUSH
42305: LD_VAR 0 59
42309: PUSH
42310: LD_VAR 0 60
42314: PUSH
42315: LD_VAR 0 61
42319: PUSH
42320: LD_VAR 0 62
42324: PUSH
42325: LD_VAR 0 63
42329: PUSH
42330: LD_VAR 0 64
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: LIST
42339: LIST
42340: LIST
42341: LIST
42342: PUSH
42343: LD_VAR 0 4
42347: PUSH
42348: LD_INT 1
42350: PLUS
42351: ARRAY
42352: ST_TO_ADDR
42353: GO 42356
42355: POP
// temp_list2 = [ ] ;
42356: LD_ADDR_VAR 0 10
42360: PUSH
42361: EMPTY
42362: ST_TO_ADDR
// for i in temp_list do
42363: LD_ADDR_VAR 0 8
42367: PUSH
42368: LD_VAR 0 9
42372: PUSH
42373: FOR_IN
42374: IFFALSE 42426
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42376: LD_ADDR_VAR 0 10
42380: PUSH
42381: LD_VAR 0 10
42385: PUSH
42386: LD_VAR 0 8
42390: PUSH
42391: LD_INT 1
42393: ARRAY
42394: PUSH
42395: LD_VAR 0 2
42399: PLUS
42400: PUSH
42401: LD_VAR 0 8
42405: PUSH
42406: LD_INT 2
42408: ARRAY
42409: PUSH
42410: LD_VAR 0 3
42414: PLUS
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: EMPTY
42421: LIST
42422: ADD
42423: ST_TO_ADDR
42424: GO 42373
42426: POP
42427: POP
// result = temp_list2 ;
42428: LD_ADDR_VAR 0 7
42432: PUSH
42433: LD_VAR 0 10
42437: ST_TO_ADDR
// end ;
42438: LD_VAR 0 7
42442: RET
// export function EnemyInRange ( unit , dist ) ; begin
42443: LD_INT 0
42445: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42446: LD_ADDR_VAR 0 3
42450: PUSH
42451: LD_VAR 0 1
42455: PPUSH
42456: CALL_OW 255
42460: PPUSH
42461: LD_VAR 0 1
42465: PPUSH
42466: CALL_OW 250
42470: PPUSH
42471: LD_VAR 0 1
42475: PPUSH
42476: CALL_OW 251
42480: PPUSH
42481: LD_VAR 0 2
42485: PPUSH
42486: CALL 15845 0 4
42490: PUSH
42491: LD_INT 4
42493: ARRAY
42494: ST_TO_ADDR
// end ;
42495: LD_VAR 0 3
42499: RET
// export function PlayerSeeMe ( unit ) ; begin
42500: LD_INT 0
42502: PPUSH
// result := See ( your_side , unit ) ;
42503: LD_ADDR_VAR 0 2
42507: PUSH
42508: LD_OWVAR 2
42512: PPUSH
42513: LD_VAR 0 1
42517: PPUSH
42518: CALL_OW 292
42522: ST_TO_ADDR
// end ;
42523: LD_VAR 0 2
42527: RET
// export function ReverseDir ( unit ) ; begin
42528: LD_INT 0
42530: PPUSH
// if not unit then
42531: LD_VAR 0 1
42535: NOT
42536: IFFALSE 42540
// exit ;
42538: GO 42563
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42540: LD_ADDR_VAR 0 2
42544: PUSH
42545: LD_VAR 0 1
42549: PPUSH
42550: CALL_OW 254
42554: PUSH
42555: LD_INT 3
42557: PLUS
42558: PUSH
42559: LD_INT 6
42561: MOD
42562: ST_TO_ADDR
// end ;
42563: LD_VAR 0 2
42567: RET
// export function ReverseArray ( array ) ; var i ; begin
42568: LD_INT 0
42570: PPUSH
42571: PPUSH
// if not array then
42572: LD_VAR 0 1
42576: NOT
42577: IFFALSE 42581
// exit ;
42579: GO 42636
// result := [ ] ;
42581: LD_ADDR_VAR 0 2
42585: PUSH
42586: EMPTY
42587: ST_TO_ADDR
// for i := array downto 1 do
42588: LD_ADDR_VAR 0 3
42592: PUSH
42593: DOUBLE
42594: LD_VAR 0 1
42598: INC
42599: ST_TO_ADDR
42600: LD_INT 1
42602: PUSH
42603: FOR_DOWNTO
42604: IFFALSE 42634
// result := Join ( result , array [ i ] ) ;
42606: LD_ADDR_VAR 0 2
42610: PUSH
42611: LD_VAR 0 2
42615: PPUSH
42616: LD_VAR 0 1
42620: PUSH
42621: LD_VAR 0 3
42625: ARRAY
42626: PPUSH
42627: CALL 47280 0 2
42631: ST_TO_ADDR
42632: GO 42603
42634: POP
42635: POP
// end ;
42636: LD_VAR 0 2
42640: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42641: LD_INT 0
42643: PPUSH
42644: PPUSH
42645: PPUSH
42646: PPUSH
42647: PPUSH
42648: PPUSH
// if not unit or not hexes then
42649: LD_VAR 0 1
42653: NOT
42654: PUSH
42655: LD_VAR 0 2
42659: NOT
42660: OR
42661: IFFALSE 42665
// exit ;
42663: GO 42788
// dist := 9999 ;
42665: LD_ADDR_VAR 0 5
42669: PUSH
42670: LD_INT 9999
42672: ST_TO_ADDR
// for i = 1 to hexes do
42673: LD_ADDR_VAR 0 4
42677: PUSH
42678: DOUBLE
42679: LD_INT 1
42681: DEC
42682: ST_TO_ADDR
42683: LD_VAR 0 2
42687: PUSH
42688: FOR_TO
42689: IFFALSE 42776
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42691: LD_ADDR_VAR 0 6
42695: PUSH
42696: LD_VAR 0 1
42700: PPUSH
42701: LD_VAR 0 2
42705: PUSH
42706: LD_VAR 0 4
42710: ARRAY
42711: PUSH
42712: LD_INT 1
42714: ARRAY
42715: PPUSH
42716: LD_VAR 0 2
42720: PUSH
42721: LD_VAR 0 4
42725: ARRAY
42726: PUSH
42727: LD_INT 2
42729: ARRAY
42730: PPUSH
42731: CALL_OW 297
42735: ST_TO_ADDR
// if tdist < dist then
42736: LD_VAR 0 6
42740: PUSH
42741: LD_VAR 0 5
42745: LESS
42746: IFFALSE 42774
// begin hex := hexes [ i ] ;
42748: LD_ADDR_VAR 0 8
42752: PUSH
42753: LD_VAR 0 2
42757: PUSH
42758: LD_VAR 0 4
42762: ARRAY
42763: ST_TO_ADDR
// dist := tdist ;
42764: LD_ADDR_VAR 0 5
42768: PUSH
42769: LD_VAR 0 6
42773: ST_TO_ADDR
// end ; end ;
42774: GO 42688
42776: POP
42777: POP
// result := hex ;
42778: LD_ADDR_VAR 0 3
42782: PUSH
42783: LD_VAR 0 8
42787: ST_TO_ADDR
// end ;
42788: LD_VAR 0 3
42792: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42793: LD_INT 0
42795: PPUSH
42796: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42797: LD_VAR 0 1
42801: NOT
42802: PUSH
42803: LD_VAR 0 1
42807: PUSH
42808: LD_INT 21
42810: PUSH
42811: LD_INT 2
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 23
42820: PUSH
42821: LD_INT 2
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PPUSH
42832: CALL_OW 69
42836: IN
42837: NOT
42838: OR
42839: IFFALSE 42843
// exit ;
42841: GO 42890
// for i = 1 to 3 do
42843: LD_ADDR_VAR 0 3
42847: PUSH
42848: DOUBLE
42849: LD_INT 1
42851: DEC
42852: ST_TO_ADDR
42853: LD_INT 3
42855: PUSH
42856: FOR_TO
42857: IFFALSE 42888
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42859: LD_VAR 0 1
42863: PPUSH
42864: CALL_OW 250
42868: PPUSH
42869: LD_VAR 0 1
42873: PPUSH
42874: CALL_OW 251
42878: PPUSH
42879: LD_INT 1
42881: PPUSH
42882: CALL_OW 453
42886: GO 42856
42888: POP
42889: POP
// end ;
42890: LD_VAR 0 2
42894: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42895: LD_INT 0
42897: PPUSH
42898: PPUSH
42899: PPUSH
42900: PPUSH
42901: PPUSH
42902: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42903: LD_VAR 0 1
42907: NOT
42908: PUSH
42909: LD_VAR 0 2
42913: NOT
42914: OR
42915: PUSH
42916: LD_VAR 0 1
42920: PPUSH
42921: CALL_OW 314
42925: OR
42926: IFFALSE 42930
// exit ;
42928: GO 43397
// if GetLives ( i ) < 250 then
42930: LD_VAR 0 4
42934: PPUSH
42935: CALL_OW 256
42939: PUSH
42940: LD_INT 250
42942: LESS
42943: IFFALSE 42956
// begin ComAutodestruct ( i ) ;
42945: LD_VAR 0 4
42949: PPUSH
42950: CALL 42793 0 1
// exit ;
42954: GO 43397
// end ; x := GetX ( enemy_unit ) ;
42956: LD_ADDR_VAR 0 7
42960: PUSH
42961: LD_VAR 0 2
42965: PPUSH
42966: CALL_OW 250
42970: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42971: LD_ADDR_VAR 0 8
42975: PUSH
42976: LD_VAR 0 2
42980: PPUSH
42981: CALL_OW 251
42985: ST_TO_ADDR
// if not x or not y then
42986: LD_VAR 0 7
42990: NOT
42991: PUSH
42992: LD_VAR 0 8
42996: NOT
42997: OR
42998: IFFALSE 43002
// exit ;
43000: GO 43397
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43002: LD_ADDR_VAR 0 6
43006: PUSH
43007: LD_VAR 0 7
43011: PPUSH
43012: LD_INT 0
43014: PPUSH
43015: LD_INT 4
43017: PPUSH
43018: CALL_OW 272
43022: PUSH
43023: LD_VAR 0 8
43027: PPUSH
43028: LD_INT 0
43030: PPUSH
43031: LD_INT 4
43033: PPUSH
43034: CALL_OW 273
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_VAR 0 7
43047: PPUSH
43048: LD_INT 1
43050: PPUSH
43051: LD_INT 4
43053: PPUSH
43054: CALL_OW 272
43058: PUSH
43059: LD_VAR 0 8
43063: PPUSH
43064: LD_INT 1
43066: PPUSH
43067: LD_INT 4
43069: PPUSH
43070: CALL_OW 273
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_VAR 0 7
43083: PPUSH
43084: LD_INT 2
43086: PPUSH
43087: LD_INT 4
43089: PPUSH
43090: CALL_OW 272
43094: PUSH
43095: LD_VAR 0 8
43099: PPUSH
43100: LD_INT 2
43102: PPUSH
43103: LD_INT 4
43105: PPUSH
43106: CALL_OW 273
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_VAR 0 7
43119: PPUSH
43120: LD_INT 3
43122: PPUSH
43123: LD_INT 4
43125: PPUSH
43126: CALL_OW 272
43130: PUSH
43131: LD_VAR 0 8
43135: PPUSH
43136: LD_INT 3
43138: PPUSH
43139: LD_INT 4
43141: PPUSH
43142: CALL_OW 273
43146: PUSH
43147: EMPTY
43148: LIST
43149: LIST
43150: PUSH
43151: LD_VAR 0 7
43155: PPUSH
43156: LD_INT 4
43158: PPUSH
43159: LD_INT 4
43161: PPUSH
43162: CALL_OW 272
43166: PUSH
43167: LD_VAR 0 8
43171: PPUSH
43172: LD_INT 4
43174: PPUSH
43175: LD_INT 4
43177: PPUSH
43178: CALL_OW 273
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_VAR 0 7
43191: PPUSH
43192: LD_INT 5
43194: PPUSH
43195: LD_INT 4
43197: PPUSH
43198: CALL_OW 272
43202: PUSH
43203: LD_VAR 0 8
43207: PPUSH
43208: LD_INT 5
43210: PPUSH
43211: LD_INT 4
43213: PPUSH
43214: CALL_OW 273
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: ST_TO_ADDR
// for i = tmp downto 1 do
43231: LD_ADDR_VAR 0 4
43235: PUSH
43236: DOUBLE
43237: LD_VAR 0 6
43241: INC
43242: ST_TO_ADDR
43243: LD_INT 1
43245: PUSH
43246: FOR_DOWNTO
43247: IFFALSE 43348
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43249: LD_VAR 0 6
43253: PUSH
43254: LD_VAR 0 4
43258: ARRAY
43259: PUSH
43260: LD_INT 1
43262: ARRAY
43263: PPUSH
43264: LD_VAR 0 6
43268: PUSH
43269: LD_VAR 0 4
43273: ARRAY
43274: PUSH
43275: LD_INT 2
43277: ARRAY
43278: PPUSH
43279: CALL_OW 488
43283: NOT
43284: PUSH
43285: LD_VAR 0 6
43289: PUSH
43290: LD_VAR 0 4
43294: ARRAY
43295: PUSH
43296: LD_INT 1
43298: ARRAY
43299: PPUSH
43300: LD_VAR 0 6
43304: PUSH
43305: LD_VAR 0 4
43309: ARRAY
43310: PUSH
43311: LD_INT 2
43313: ARRAY
43314: PPUSH
43315: CALL_OW 428
43319: PUSH
43320: LD_INT 0
43322: NONEQUAL
43323: OR
43324: IFFALSE 43346
// tmp := Delete ( tmp , i ) ;
43326: LD_ADDR_VAR 0 6
43330: PUSH
43331: LD_VAR 0 6
43335: PPUSH
43336: LD_VAR 0 4
43340: PPUSH
43341: CALL_OW 3
43345: ST_TO_ADDR
43346: GO 43246
43348: POP
43349: POP
// j := GetClosestHex ( unit , tmp ) ;
43350: LD_ADDR_VAR 0 5
43354: PUSH
43355: LD_VAR 0 1
43359: PPUSH
43360: LD_VAR 0 6
43364: PPUSH
43365: CALL 42641 0 2
43369: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43370: LD_VAR 0 1
43374: PPUSH
43375: LD_VAR 0 5
43379: PUSH
43380: LD_INT 1
43382: ARRAY
43383: PPUSH
43384: LD_VAR 0 5
43388: PUSH
43389: LD_INT 2
43391: ARRAY
43392: PPUSH
43393: CALL_OW 111
// end ;
43397: LD_VAR 0 3
43401: RET
// export function PrepareApemanSoldier ( ) ; begin
43402: LD_INT 0
43404: PPUSH
// uc_nation := 0 ;
43405: LD_ADDR_OWVAR 21
43409: PUSH
43410: LD_INT 0
43412: ST_TO_ADDR
// hc_sex := sex_male ;
43413: LD_ADDR_OWVAR 27
43417: PUSH
43418: LD_INT 1
43420: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43421: LD_ADDR_OWVAR 28
43425: PUSH
43426: LD_INT 15
43428: ST_TO_ADDR
// hc_gallery :=  ;
43429: LD_ADDR_OWVAR 33
43433: PUSH
43434: LD_STRING 
43436: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43437: LD_ADDR_OWVAR 31
43441: PUSH
43442: LD_INT 0
43444: PPUSH
43445: LD_INT 3
43447: PPUSH
43448: CALL_OW 12
43452: PUSH
43453: LD_INT 0
43455: PPUSH
43456: LD_INT 3
43458: PPUSH
43459: CALL_OW 12
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: LD_INT 0
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: LIST
43474: LIST
43475: ST_TO_ADDR
// end ;
43476: LD_VAR 0 1
43480: RET
// export function PrepareApemanEngineer ( ) ; begin
43481: LD_INT 0
43483: PPUSH
// uc_nation := 0 ;
43484: LD_ADDR_OWVAR 21
43488: PUSH
43489: LD_INT 0
43491: ST_TO_ADDR
// hc_sex := sex_male ;
43492: LD_ADDR_OWVAR 27
43496: PUSH
43497: LD_INT 1
43499: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43500: LD_ADDR_OWVAR 28
43504: PUSH
43505: LD_INT 16
43507: ST_TO_ADDR
// hc_gallery :=  ;
43508: LD_ADDR_OWVAR 33
43512: PUSH
43513: LD_STRING 
43515: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43516: LD_ADDR_OWVAR 31
43520: PUSH
43521: LD_INT 0
43523: PPUSH
43524: LD_INT 3
43526: PPUSH
43527: CALL_OW 12
43531: PUSH
43532: LD_INT 0
43534: PPUSH
43535: LD_INT 3
43537: PPUSH
43538: CALL_OW 12
43542: PUSH
43543: LD_INT 0
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: ST_TO_ADDR
// end ;
43555: LD_VAR 0 1
43559: RET
// export function PrepareApeman ( agressivity ) ; begin
43560: LD_INT 0
43562: PPUSH
// uc_side := 0 ;
43563: LD_ADDR_OWVAR 20
43567: PUSH
43568: LD_INT 0
43570: ST_TO_ADDR
// uc_nation := 0 ;
43571: LD_ADDR_OWVAR 21
43575: PUSH
43576: LD_INT 0
43578: ST_TO_ADDR
// hc_sex := sex_male ;
43579: LD_ADDR_OWVAR 27
43583: PUSH
43584: LD_INT 1
43586: ST_TO_ADDR
// hc_class := class_apeman ;
43587: LD_ADDR_OWVAR 28
43591: PUSH
43592: LD_INT 12
43594: ST_TO_ADDR
// hc_gallery :=  ;
43595: LD_ADDR_OWVAR 33
43599: PUSH
43600: LD_STRING 
43602: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43603: LD_ADDR_OWVAR 35
43607: PUSH
43608: LD_VAR 0 1
43612: NEG
43613: PPUSH
43614: LD_VAR 0 1
43618: PPUSH
43619: CALL_OW 12
43623: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43624: LD_ADDR_OWVAR 31
43628: PUSH
43629: LD_INT 0
43631: PPUSH
43632: LD_INT 3
43634: PPUSH
43635: CALL_OW 12
43639: PUSH
43640: LD_INT 0
43642: PPUSH
43643: LD_INT 3
43645: PPUSH
43646: CALL_OW 12
43650: PUSH
43651: LD_INT 0
43653: PUSH
43654: LD_INT 0
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: LIST
43661: LIST
43662: ST_TO_ADDR
// end ;
43663: LD_VAR 0 2
43667: RET
// export function PrepareTiger ( agressivity ) ; begin
43668: LD_INT 0
43670: PPUSH
// uc_side := 0 ;
43671: LD_ADDR_OWVAR 20
43675: PUSH
43676: LD_INT 0
43678: ST_TO_ADDR
// uc_nation := 0 ;
43679: LD_ADDR_OWVAR 21
43683: PUSH
43684: LD_INT 0
43686: ST_TO_ADDR
// hc_class := class_tiger ;
43687: LD_ADDR_OWVAR 28
43691: PUSH
43692: LD_INT 14
43694: ST_TO_ADDR
// hc_gallery :=  ;
43695: LD_ADDR_OWVAR 33
43699: PUSH
43700: LD_STRING 
43702: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43703: LD_ADDR_OWVAR 35
43707: PUSH
43708: LD_VAR 0 1
43712: NEG
43713: PPUSH
43714: LD_VAR 0 1
43718: PPUSH
43719: CALL_OW 12
43723: ST_TO_ADDR
// end ;
43724: LD_VAR 0 2
43728: RET
// export function PrepareEnchidna ( ) ; begin
43729: LD_INT 0
43731: PPUSH
// uc_side := 0 ;
43732: LD_ADDR_OWVAR 20
43736: PUSH
43737: LD_INT 0
43739: ST_TO_ADDR
// uc_nation := 0 ;
43740: LD_ADDR_OWVAR 21
43744: PUSH
43745: LD_INT 0
43747: ST_TO_ADDR
// hc_class := class_baggie ;
43748: LD_ADDR_OWVAR 28
43752: PUSH
43753: LD_INT 13
43755: ST_TO_ADDR
// hc_gallery :=  ;
43756: LD_ADDR_OWVAR 33
43760: PUSH
43761: LD_STRING 
43763: ST_TO_ADDR
// end ;
43764: LD_VAR 0 1
43768: RET
// export function PrepareFrog ( ) ; begin
43769: LD_INT 0
43771: PPUSH
// uc_side := 0 ;
43772: LD_ADDR_OWVAR 20
43776: PUSH
43777: LD_INT 0
43779: ST_TO_ADDR
// uc_nation := 0 ;
43780: LD_ADDR_OWVAR 21
43784: PUSH
43785: LD_INT 0
43787: ST_TO_ADDR
// hc_class := class_frog ;
43788: LD_ADDR_OWVAR 28
43792: PUSH
43793: LD_INT 19
43795: ST_TO_ADDR
// hc_gallery :=  ;
43796: LD_ADDR_OWVAR 33
43800: PUSH
43801: LD_STRING 
43803: ST_TO_ADDR
// end ;
43804: LD_VAR 0 1
43808: RET
// export function PrepareFish ( ) ; begin
43809: LD_INT 0
43811: PPUSH
// uc_side := 0 ;
43812: LD_ADDR_OWVAR 20
43816: PUSH
43817: LD_INT 0
43819: ST_TO_ADDR
// uc_nation := 0 ;
43820: LD_ADDR_OWVAR 21
43824: PUSH
43825: LD_INT 0
43827: ST_TO_ADDR
// hc_class := class_fish ;
43828: LD_ADDR_OWVAR 28
43832: PUSH
43833: LD_INT 20
43835: ST_TO_ADDR
// hc_gallery :=  ;
43836: LD_ADDR_OWVAR 33
43840: PUSH
43841: LD_STRING 
43843: ST_TO_ADDR
// end ;
43844: LD_VAR 0 1
43848: RET
// export function PrepareBird ( ) ; begin
43849: LD_INT 0
43851: PPUSH
// uc_side := 0 ;
43852: LD_ADDR_OWVAR 20
43856: PUSH
43857: LD_INT 0
43859: ST_TO_ADDR
// uc_nation := 0 ;
43860: LD_ADDR_OWVAR 21
43864: PUSH
43865: LD_INT 0
43867: ST_TO_ADDR
// hc_class := class_phororhacos ;
43868: LD_ADDR_OWVAR 28
43872: PUSH
43873: LD_INT 18
43875: ST_TO_ADDR
// hc_gallery :=  ;
43876: LD_ADDR_OWVAR 33
43880: PUSH
43881: LD_STRING 
43883: ST_TO_ADDR
// end ;
43884: LD_VAR 0 1
43888: RET
// export function PrepareHorse ( ) ; begin
43889: LD_INT 0
43891: PPUSH
// uc_side := 0 ;
43892: LD_ADDR_OWVAR 20
43896: PUSH
43897: LD_INT 0
43899: ST_TO_ADDR
// uc_nation := 0 ;
43900: LD_ADDR_OWVAR 21
43904: PUSH
43905: LD_INT 0
43907: ST_TO_ADDR
// hc_class := class_horse ;
43908: LD_ADDR_OWVAR 28
43912: PUSH
43913: LD_INT 21
43915: ST_TO_ADDR
// hc_gallery :=  ;
43916: LD_ADDR_OWVAR 33
43920: PUSH
43921: LD_STRING 
43923: ST_TO_ADDR
// end ;
43924: LD_VAR 0 1
43928: RET
// export function PrepareMastodont ( ) ; begin
43929: LD_INT 0
43931: PPUSH
// uc_side := 0 ;
43932: LD_ADDR_OWVAR 20
43936: PUSH
43937: LD_INT 0
43939: ST_TO_ADDR
// uc_nation := 0 ;
43940: LD_ADDR_OWVAR 21
43944: PUSH
43945: LD_INT 0
43947: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43948: LD_ADDR_OWVAR 37
43952: PUSH
43953: LD_INT 31
43955: ST_TO_ADDR
// vc_control := control_rider ;
43956: LD_ADDR_OWVAR 38
43960: PUSH
43961: LD_INT 4
43963: ST_TO_ADDR
// end ;
43964: LD_VAR 0 1
43968: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43969: LD_INT 0
43971: PPUSH
43972: PPUSH
43973: PPUSH
// uc_side = 0 ;
43974: LD_ADDR_OWVAR 20
43978: PUSH
43979: LD_INT 0
43981: ST_TO_ADDR
// uc_nation = 0 ;
43982: LD_ADDR_OWVAR 21
43986: PUSH
43987: LD_INT 0
43989: ST_TO_ADDR
// InitHc_All ( ) ;
43990: CALL_OW 584
// InitVc ;
43994: CALL_OW 20
// if mastodonts then
43998: LD_VAR 0 6
44002: IFFALSE 44069
// for i = 1 to mastodonts do
44004: LD_ADDR_VAR 0 11
44008: PUSH
44009: DOUBLE
44010: LD_INT 1
44012: DEC
44013: ST_TO_ADDR
44014: LD_VAR 0 6
44018: PUSH
44019: FOR_TO
44020: IFFALSE 44067
// begin vc_chassis := 31 ;
44022: LD_ADDR_OWVAR 37
44026: PUSH
44027: LD_INT 31
44029: ST_TO_ADDR
// vc_control := control_rider ;
44030: LD_ADDR_OWVAR 38
44034: PUSH
44035: LD_INT 4
44037: ST_TO_ADDR
// animal := CreateVehicle ;
44038: LD_ADDR_VAR 0 12
44042: PUSH
44043: CALL_OW 45
44047: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44048: LD_VAR 0 12
44052: PPUSH
44053: LD_VAR 0 8
44057: PPUSH
44058: LD_INT 0
44060: PPUSH
44061: CALL 46197 0 3
// end ;
44065: GO 44019
44067: POP
44068: POP
// if horses then
44069: LD_VAR 0 5
44073: IFFALSE 44140
// for i = 1 to horses do
44075: LD_ADDR_VAR 0 11
44079: PUSH
44080: DOUBLE
44081: LD_INT 1
44083: DEC
44084: ST_TO_ADDR
44085: LD_VAR 0 5
44089: PUSH
44090: FOR_TO
44091: IFFALSE 44138
// begin hc_class := 21 ;
44093: LD_ADDR_OWVAR 28
44097: PUSH
44098: LD_INT 21
44100: ST_TO_ADDR
// hc_gallery :=  ;
44101: LD_ADDR_OWVAR 33
44105: PUSH
44106: LD_STRING 
44108: ST_TO_ADDR
// animal := CreateHuman ;
44109: LD_ADDR_VAR 0 12
44113: PUSH
44114: CALL_OW 44
44118: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44119: LD_VAR 0 12
44123: PPUSH
44124: LD_VAR 0 8
44128: PPUSH
44129: LD_INT 0
44131: PPUSH
44132: CALL 46197 0 3
// end ;
44136: GO 44090
44138: POP
44139: POP
// if birds then
44140: LD_VAR 0 1
44144: IFFALSE 44211
// for i = 1 to birds do
44146: LD_ADDR_VAR 0 11
44150: PUSH
44151: DOUBLE
44152: LD_INT 1
44154: DEC
44155: ST_TO_ADDR
44156: LD_VAR 0 1
44160: PUSH
44161: FOR_TO
44162: IFFALSE 44209
// begin hc_class = 18 ;
44164: LD_ADDR_OWVAR 28
44168: PUSH
44169: LD_INT 18
44171: ST_TO_ADDR
// hc_gallery =  ;
44172: LD_ADDR_OWVAR 33
44176: PUSH
44177: LD_STRING 
44179: ST_TO_ADDR
// animal := CreateHuman ;
44180: LD_ADDR_VAR 0 12
44184: PUSH
44185: CALL_OW 44
44189: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44190: LD_VAR 0 12
44194: PPUSH
44195: LD_VAR 0 8
44199: PPUSH
44200: LD_INT 0
44202: PPUSH
44203: CALL 46197 0 3
// end ;
44207: GO 44161
44209: POP
44210: POP
// if tigers then
44211: LD_VAR 0 2
44215: IFFALSE 44299
// for i = 1 to tigers do
44217: LD_ADDR_VAR 0 11
44221: PUSH
44222: DOUBLE
44223: LD_INT 1
44225: DEC
44226: ST_TO_ADDR
44227: LD_VAR 0 2
44231: PUSH
44232: FOR_TO
44233: IFFALSE 44297
// begin hc_class = class_tiger ;
44235: LD_ADDR_OWVAR 28
44239: PUSH
44240: LD_INT 14
44242: ST_TO_ADDR
// hc_gallery =  ;
44243: LD_ADDR_OWVAR 33
44247: PUSH
44248: LD_STRING 
44250: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44251: LD_ADDR_OWVAR 35
44255: PUSH
44256: LD_INT 7
44258: NEG
44259: PPUSH
44260: LD_INT 7
44262: PPUSH
44263: CALL_OW 12
44267: ST_TO_ADDR
// animal := CreateHuman ;
44268: LD_ADDR_VAR 0 12
44272: PUSH
44273: CALL_OW 44
44277: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44278: LD_VAR 0 12
44282: PPUSH
44283: LD_VAR 0 8
44287: PPUSH
44288: LD_INT 0
44290: PPUSH
44291: CALL 46197 0 3
// end ;
44295: GO 44232
44297: POP
44298: POP
// if apemans then
44299: LD_VAR 0 3
44303: IFFALSE 44426
// for i = 1 to apemans do
44305: LD_ADDR_VAR 0 11
44309: PUSH
44310: DOUBLE
44311: LD_INT 1
44313: DEC
44314: ST_TO_ADDR
44315: LD_VAR 0 3
44319: PUSH
44320: FOR_TO
44321: IFFALSE 44424
// begin hc_class = class_apeman ;
44323: LD_ADDR_OWVAR 28
44327: PUSH
44328: LD_INT 12
44330: ST_TO_ADDR
// hc_gallery =  ;
44331: LD_ADDR_OWVAR 33
44335: PUSH
44336: LD_STRING 
44338: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44339: LD_ADDR_OWVAR 35
44343: PUSH
44344: LD_INT 2
44346: NEG
44347: PPUSH
44348: LD_INT 2
44350: PPUSH
44351: CALL_OW 12
44355: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44356: LD_ADDR_OWVAR 31
44360: PUSH
44361: LD_INT 1
44363: PPUSH
44364: LD_INT 3
44366: PPUSH
44367: CALL_OW 12
44371: PUSH
44372: LD_INT 1
44374: PPUSH
44375: LD_INT 3
44377: PPUSH
44378: CALL_OW 12
44382: PUSH
44383: LD_INT 0
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: ST_TO_ADDR
// animal := CreateHuman ;
44395: LD_ADDR_VAR 0 12
44399: PUSH
44400: CALL_OW 44
44404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44405: LD_VAR 0 12
44409: PPUSH
44410: LD_VAR 0 8
44414: PPUSH
44415: LD_INT 0
44417: PPUSH
44418: CALL 46197 0 3
// end ;
44422: GO 44320
44424: POP
44425: POP
// if enchidnas then
44426: LD_VAR 0 4
44430: IFFALSE 44497
// for i = 1 to enchidnas do
44432: LD_ADDR_VAR 0 11
44436: PUSH
44437: DOUBLE
44438: LD_INT 1
44440: DEC
44441: ST_TO_ADDR
44442: LD_VAR 0 4
44446: PUSH
44447: FOR_TO
44448: IFFALSE 44495
// begin hc_class = 13 ;
44450: LD_ADDR_OWVAR 28
44454: PUSH
44455: LD_INT 13
44457: ST_TO_ADDR
// hc_gallery =  ;
44458: LD_ADDR_OWVAR 33
44462: PUSH
44463: LD_STRING 
44465: ST_TO_ADDR
// animal := CreateHuman ;
44466: LD_ADDR_VAR 0 12
44470: PUSH
44471: CALL_OW 44
44475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44476: LD_VAR 0 12
44480: PPUSH
44481: LD_VAR 0 8
44485: PPUSH
44486: LD_INT 0
44488: PPUSH
44489: CALL 46197 0 3
// end ;
44493: GO 44447
44495: POP
44496: POP
// if fishes then
44497: LD_VAR 0 7
44501: IFFALSE 44568
// for i = 1 to fishes do
44503: LD_ADDR_VAR 0 11
44507: PUSH
44508: DOUBLE
44509: LD_INT 1
44511: DEC
44512: ST_TO_ADDR
44513: LD_VAR 0 7
44517: PUSH
44518: FOR_TO
44519: IFFALSE 44566
// begin hc_class = 20 ;
44521: LD_ADDR_OWVAR 28
44525: PUSH
44526: LD_INT 20
44528: ST_TO_ADDR
// hc_gallery =  ;
44529: LD_ADDR_OWVAR 33
44533: PUSH
44534: LD_STRING 
44536: ST_TO_ADDR
// animal := CreateHuman ;
44537: LD_ADDR_VAR 0 12
44541: PUSH
44542: CALL_OW 44
44546: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44547: LD_VAR 0 12
44551: PPUSH
44552: LD_VAR 0 9
44556: PPUSH
44557: LD_INT 0
44559: PPUSH
44560: CALL 46197 0 3
// end ;
44564: GO 44518
44566: POP
44567: POP
// end ;
44568: LD_VAR 0 10
44572: RET
// export function WantHeal ( sci , unit ) ; begin
44573: LD_INT 0
44575: PPUSH
// if GetTaskList ( sci ) > 0 then
44576: LD_VAR 0 1
44580: PPUSH
44581: CALL_OW 437
44585: PUSH
44586: LD_INT 0
44588: GREATER
44589: IFFALSE 44659
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44591: LD_VAR 0 1
44595: PPUSH
44596: CALL_OW 437
44600: PUSH
44601: LD_INT 1
44603: ARRAY
44604: PUSH
44605: LD_INT 1
44607: ARRAY
44608: PUSH
44609: LD_STRING l
44611: EQUAL
44612: PUSH
44613: LD_VAR 0 1
44617: PPUSH
44618: CALL_OW 437
44622: PUSH
44623: LD_INT 1
44625: ARRAY
44626: PUSH
44627: LD_INT 4
44629: ARRAY
44630: PUSH
44631: LD_VAR 0 2
44635: EQUAL
44636: AND
44637: IFFALSE 44649
// result := true else
44639: LD_ADDR_VAR 0 3
44643: PUSH
44644: LD_INT 1
44646: ST_TO_ADDR
44647: GO 44657
// result := false ;
44649: LD_ADDR_VAR 0 3
44653: PUSH
44654: LD_INT 0
44656: ST_TO_ADDR
// end else
44657: GO 44667
// result := false ;
44659: LD_ADDR_VAR 0 3
44663: PUSH
44664: LD_INT 0
44666: ST_TO_ADDR
// end ;
44667: LD_VAR 0 3
44671: RET
// export function HealTarget ( sci ) ; begin
44672: LD_INT 0
44674: PPUSH
// if not sci then
44675: LD_VAR 0 1
44679: NOT
44680: IFFALSE 44684
// exit ;
44682: GO 44749
// result := 0 ;
44684: LD_ADDR_VAR 0 2
44688: PUSH
44689: LD_INT 0
44691: ST_TO_ADDR
// if GetTaskList ( sci ) then
44692: LD_VAR 0 1
44696: PPUSH
44697: CALL_OW 437
44701: IFFALSE 44749
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44703: LD_VAR 0 1
44707: PPUSH
44708: CALL_OW 437
44712: PUSH
44713: LD_INT 1
44715: ARRAY
44716: PUSH
44717: LD_INT 1
44719: ARRAY
44720: PUSH
44721: LD_STRING l
44723: EQUAL
44724: IFFALSE 44749
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44726: LD_ADDR_VAR 0 2
44730: PUSH
44731: LD_VAR 0 1
44735: PPUSH
44736: CALL_OW 437
44740: PUSH
44741: LD_INT 1
44743: ARRAY
44744: PUSH
44745: LD_INT 4
44747: ARRAY
44748: ST_TO_ADDR
// end ;
44749: LD_VAR 0 2
44753: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44754: LD_INT 0
44756: PPUSH
44757: PPUSH
44758: PPUSH
44759: PPUSH
// if not base_units then
44760: LD_VAR 0 1
44764: NOT
44765: IFFALSE 44769
// exit ;
44767: GO 44856
// result := false ;
44769: LD_ADDR_VAR 0 2
44773: PUSH
44774: LD_INT 0
44776: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44777: LD_ADDR_VAR 0 5
44781: PUSH
44782: LD_VAR 0 1
44786: PPUSH
44787: LD_INT 21
44789: PUSH
44790: LD_INT 3
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PPUSH
44797: CALL_OW 72
44801: ST_TO_ADDR
// if not tmp then
44802: LD_VAR 0 5
44806: NOT
44807: IFFALSE 44811
// exit ;
44809: GO 44856
// for i in tmp do
44811: LD_ADDR_VAR 0 3
44815: PUSH
44816: LD_VAR 0 5
44820: PUSH
44821: FOR_IN
44822: IFFALSE 44854
// begin result := EnemyInRange ( i , 22 ) ;
44824: LD_ADDR_VAR 0 2
44828: PUSH
44829: LD_VAR 0 3
44833: PPUSH
44834: LD_INT 22
44836: PPUSH
44837: CALL 42443 0 2
44841: ST_TO_ADDR
// if result then
44842: LD_VAR 0 2
44846: IFFALSE 44852
// exit ;
44848: POP
44849: POP
44850: GO 44856
// end ;
44852: GO 44821
44854: POP
44855: POP
// end ;
44856: LD_VAR 0 2
44860: RET
// export function FilterByTag ( units , tag ) ; begin
44861: LD_INT 0
44863: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44864: LD_ADDR_VAR 0 3
44868: PUSH
44869: LD_VAR 0 1
44873: PPUSH
44874: LD_INT 120
44876: PUSH
44877: LD_VAR 0 2
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PPUSH
44886: CALL_OW 72
44890: ST_TO_ADDR
// end ;
44891: LD_VAR 0 3
44895: RET
// export function IsDriver ( un ) ; begin
44896: LD_INT 0
44898: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44899: LD_ADDR_VAR 0 2
44903: PUSH
44904: LD_VAR 0 1
44908: PUSH
44909: LD_INT 55
44911: PUSH
44912: EMPTY
44913: LIST
44914: PPUSH
44915: CALL_OW 69
44919: IN
44920: ST_TO_ADDR
// end ;
44921: LD_VAR 0 2
44925: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44926: LD_INT 0
44928: PPUSH
44929: PPUSH
// list := [ ] ;
44930: LD_ADDR_VAR 0 5
44934: PUSH
44935: EMPTY
44936: ST_TO_ADDR
// case d of 0 :
44937: LD_VAR 0 3
44941: PUSH
44942: LD_INT 0
44944: DOUBLE
44945: EQUAL
44946: IFTRUE 44950
44948: GO 45083
44950: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44951: LD_ADDR_VAR 0 5
44955: PUSH
44956: LD_VAR 0 1
44960: PUSH
44961: LD_INT 4
44963: MINUS
44964: PUSH
44965: LD_VAR 0 2
44969: PUSH
44970: LD_INT 4
44972: MINUS
44973: PUSH
44974: LD_INT 2
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: LIST
44981: PUSH
44982: LD_VAR 0 1
44986: PUSH
44987: LD_INT 3
44989: MINUS
44990: PUSH
44991: LD_VAR 0 2
44995: PUSH
44996: LD_INT 1
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: LIST
45003: PUSH
45004: LD_VAR 0 1
45008: PUSH
45009: LD_INT 4
45011: PLUS
45012: PUSH
45013: LD_VAR 0 2
45017: PUSH
45018: LD_INT 4
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: LIST
45025: PUSH
45026: LD_VAR 0 1
45030: PUSH
45031: LD_INT 3
45033: PLUS
45034: PUSH
45035: LD_VAR 0 2
45039: PUSH
45040: LD_INT 3
45042: PLUS
45043: PUSH
45044: LD_INT 5
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: LIST
45051: PUSH
45052: LD_VAR 0 1
45056: PUSH
45057: LD_VAR 0 2
45061: PUSH
45062: LD_INT 4
45064: PLUS
45065: PUSH
45066: LD_INT 0
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: LIST
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: ST_TO_ADDR
// end ; 1 :
45081: GO 45781
45083: LD_INT 1
45085: DOUBLE
45086: EQUAL
45087: IFTRUE 45091
45089: GO 45224
45091: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45092: LD_ADDR_VAR 0 5
45096: PUSH
45097: LD_VAR 0 1
45101: PUSH
45102: LD_VAR 0 2
45106: PUSH
45107: LD_INT 4
45109: MINUS
45110: PUSH
45111: LD_INT 3
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: LIST
45118: PUSH
45119: LD_VAR 0 1
45123: PUSH
45124: LD_INT 3
45126: MINUS
45127: PUSH
45128: LD_VAR 0 2
45132: PUSH
45133: LD_INT 3
45135: MINUS
45136: PUSH
45137: LD_INT 2
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: LIST
45144: PUSH
45145: LD_VAR 0 1
45149: PUSH
45150: LD_INT 4
45152: MINUS
45153: PUSH
45154: LD_VAR 0 2
45158: PUSH
45159: LD_INT 1
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: LIST
45166: PUSH
45167: LD_VAR 0 1
45171: PUSH
45172: LD_VAR 0 2
45176: PUSH
45177: LD_INT 3
45179: PLUS
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: LIST
45188: PUSH
45189: LD_VAR 0 1
45193: PUSH
45194: LD_INT 4
45196: PLUS
45197: PUSH
45198: LD_VAR 0 2
45202: PUSH
45203: LD_INT 4
45205: PLUS
45206: PUSH
45207: LD_INT 5
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: ST_TO_ADDR
// end ; 2 :
45222: GO 45781
45224: LD_INT 2
45226: DOUBLE
45227: EQUAL
45228: IFTRUE 45232
45230: GO 45361
45232: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45233: LD_ADDR_VAR 0 5
45237: PUSH
45238: LD_VAR 0 1
45242: PUSH
45243: LD_VAR 0 2
45247: PUSH
45248: LD_INT 3
45250: MINUS
45251: PUSH
45252: LD_INT 3
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: LIST
45259: PUSH
45260: LD_VAR 0 1
45264: PUSH
45265: LD_INT 4
45267: PLUS
45268: PUSH
45269: LD_VAR 0 2
45273: PUSH
45274: LD_INT 4
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: LIST
45281: PUSH
45282: LD_VAR 0 1
45286: PUSH
45287: LD_VAR 0 2
45291: PUSH
45292: LD_INT 4
45294: PLUS
45295: PUSH
45296: LD_INT 0
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: LIST
45303: PUSH
45304: LD_VAR 0 1
45308: PUSH
45309: LD_INT 3
45311: MINUS
45312: PUSH
45313: LD_VAR 0 2
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: LIST
45325: PUSH
45326: LD_VAR 0 1
45330: PUSH
45331: LD_INT 4
45333: MINUS
45334: PUSH
45335: LD_VAR 0 2
45339: PUSH
45340: LD_INT 4
45342: MINUS
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: LIST
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: ST_TO_ADDR
// end ; 3 :
45359: GO 45781
45361: LD_INT 3
45363: DOUBLE
45364: EQUAL
45365: IFTRUE 45369
45367: GO 45502
45369: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45370: LD_ADDR_VAR 0 5
45374: PUSH
45375: LD_VAR 0 1
45379: PUSH
45380: LD_INT 3
45382: PLUS
45383: PUSH
45384: LD_VAR 0 2
45388: PUSH
45389: LD_INT 4
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: LIST
45396: PUSH
45397: LD_VAR 0 1
45401: PUSH
45402: LD_INT 4
45404: PLUS
45405: PUSH
45406: LD_VAR 0 2
45410: PUSH
45411: LD_INT 4
45413: PLUS
45414: PUSH
45415: LD_INT 5
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: LIST
45422: PUSH
45423: LD_VAR 0 1
45427: PUSH
45428: LD_INT 4
45430: MINUS
45431: PUSH
45432: LD_VAR 0 2
45436: PUSH
45437: LD_INT 1
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: PUSH
45445: LD_VAR 0 1
45449: PUSH
45450: LD_VAR 0 2
45454: PUSH
45455: LD_INT 4
45457: MINUS
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: LIST
45466: PUSH
45467: LD_VAR 0 1
45471: PUSH
45472: LD_INT 3
45474: MINUS
45475: PUSH
45476: LD_VAR 0 2
45480: PUSH
45481: LD_INT 3
45483: MINUS
45484: PUSH
45485: LD_INT 2
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: ST_TO_ADDR
// end ; 4 :
45500: GO 45781
45502: LD_INT 4
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45510
45508: GO 45643
45510: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45511: LD_ADDR_VAR 0 5
45515: PUSH
45516: LD_VAR 0 1
45520: PUSH
45521: LD_VAR 0 2
45525: PUSH
45526: LD_INT 4
45528: PLUS
45529: PUSH
45530: LD_INT 0
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: LIST
45537: PUSH
45538: LD_VAR 0 1
45542: PUSH
45543: LD_INT 3
45545: PLUS
45546: PUSH
45547: LD_VAR 0 2
45551: PUSH
45552: LD_INT 3
45554: PLUS
45555: PUSH
45556: LD_INT 5
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: LIST
45563: PUSH
45564: LD_VAR 0 1
45568: PUSH
45569: LD_INT 4
45571: PLUS
45572: PUSH
45573: LD_VAR 0 2
45577: PUSH
45578: LD_INT 4
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: LIST
45585: PUSH
45586: LD_VAR 0 1
45590: PUSH
45591: LD_VAR 0 2
45595: PUSH
45596: LD_INT 3
45598: MINUS
45599: PUSH
45600: LD_INT 3
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: LIST
45607: PUSH
45608: LD_VAR 0 1
45612: PUSH
45613: LD_INT 4
45615: MINUS
45616: PUSH
45617: LD_VAR 0 2
45621: PUSH
45622: LD_INT 4
45624: MINUS
45625: PUSH
45626: LD_INT 2
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: LIST
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: ST_TO_ADDR
// end ; 5 :
45641: GO 45781
45643: LD_INT 5
45645: DOUBLE
45646: EQUAL
45647: IFTRUE 45651
45649: GO 45780
45651: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45652: LD_ADDR_VAR 0 5
45656: PUSH
45657: LD_VAR 0 1
45661: PUSH
45662: LD_INT 4
45664: MINUS
45665: PUSH
45666: LD_VAR 0 2
45670: PUSH
45671: LD_INT 1
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: LIST
45678: PUSH
45679: LD_VAR 0 1
45683: PUSH
45684: LD_VAR 0 2
45688: PUSH
45689: LD_INT 4
45691: MINUS
45692: PUSH
45693: LD_INT 3
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: LIST
45700: PUSH
45701: LD_VAR 0 1
45705: PUSH
45706: LD_INT 4
45708: PLUS
45709: PUSH
45710: LD_VAR 0 2
45714: PUSH
45715: LD_INT 4
45717: PLUS
45718: PUSH
45719: LD_INT 5
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: LIST
45726: PUSH
45727: LD_VAR 0 1
45731: PUSH
45732: LD_INT 3
45734: PLUS
45735: PUSH
45736: LD_VAR 0 2
45740: PUSH
45741: LD_INT 4
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: LIST
45748: PUSH
45749: LD_VAR 0 1
45753: PUSH
45754: LD_VAR 0 2
45758: PUSH
45759: LD_INT 3
45761: PLUS
45762: PUSH
45763: LD_INT 0
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: LIST
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: ST_TO_ADDR
// end ; end ;
45778: GO 45781
45780: POP
// result := list ;
45781: LD_ADDR_VAR 0 4
45785: PUSH
45786: LD_VAR 0 5
45790: ST_TO_ADDR
// end ;
45791: LD_VAR 0 4
45795: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45796: LD_INT 0
45798: PPUSH
45799: PPUSH
45800: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45801: LD_VAR 0 1
45805: NOT
45806: PUSH
45807: LD_VAR 0 2
45811: PUSH
45812: LD_INT 1
45814: PUSH
45815: LD_INT 2
45817: PUSH
45818: LD_INT 3
45820: PUSH
45821: LD_INT 4
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: IN
45830: NOT
45831: OR
45832: IFFALSE 45836
// exit ;
45834: GO 45919
// tmp := [ ] ;
45836: LD_ADDR_VAR 0 5
45840: PUSH
45841: EMPTY
45842: ST_TO_ADDR
// for i in units do
45843: LD_ADDR_VAR 0 4
45847: PUSH
45848: LD_VAR 0 1
45852: PUSH
45853: FOR_IN
45854: IFFALSE 45888
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
45856: LD_ADDR_VAR 0 5
45860: PUSH
45861: LD_VAR 0 5
45865: PPUSH
45866: LD_VAR 0 4
45870: PPUSH
45871: LD_VAR 0 2
45875: PPUSH
45876: CALL_OW 259
45880: PPUSH
45881: CALL 47280 0 2
45885: ST_TO_ADDR
45886: GO 45853
45888: POP
45889: POP
// if not tmp then
45890: LD_VAR 0 5
45894: NOT
45895: IFFALSE 45899
// exit ;
45897: GO 45919
// result := SortListByListDesc ( units , tmp ) ;
45899: LD_ADDR_VAR 0 3
45903: PUSH
45904: LD_VAR 0 1
45908: PPUSH
45909: LD_VAR 0 5
45913: PPUSH
45914: CALL_OW 77
45918: ST_TO_ADDR
// end ;
45919: LD_VAR 0 3
45923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45924: LD_INT 0
45926: PPUSH
45927: PPUSH
45928: PPUSH
// result := false ;
45929: LD_ADDR_VAR 0 3
45933: PUSH
45934: LD_INT 0
45936: ST_TO_ADDR
// if not building then
45937: LD_VAR 0 2
45941: NOT
45942: IFFALSE 45946
// exit ;
45944: GO 46084
// x := GetX ( building ) ;
45946: LD_ADDR_VAR 0 4
45950: PUSH
45951: LD_VAR 0 2
45955: PPUSH
45956: CALL_OW 250
45960: ST_TO_ADDR
// y := GetY ( building ) ;
45961: LD_ADDR_VAR 0 5
45965: PUSH
45966: LD_VAR 0 2
45970: PPUSH
45971: CALL_OW 251
45975: ST_TO_ADDR
// if not x or not y then
45976: LD_VAR 0 4
45980: NOT
45981: PUSH
45982: LD_VAR 0 5
45986: NOT
45987: OR
45988: IFFALSE 45992
// exit ;
45990: GO 46084
// if GetTaskList ( unit ) then
45992: LD_VAR 0 1
45996: PPUSH
45997: CALL_OW 437
46001: IFFALSE 46084
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46003: LD_STRING e
46005: PUSH
46006: LD_VAR 0 1
46010: PPUSH
46011: CALL_OW 437
46015: PUSH
46016: LD_INT 1
46018: ARRAY
46019: PUSH
46020: LD_INT 1
46022: ARRAY
46023: EQUAL
46024: PUSH
46025: LD_VAR 0 4
46029: PUSH
46030: LD_VAR 0 1
46034: PPUSH
46035: CALL_OW 437
46039: PUSH
46040: LD_INT 1
46042: ARRAY
46043: PUSH
46044: LD_INT 2
46046: ARRAY
46047: EQUAL
46048: AND
46049: PUSH
46050: LD_VAR 0 5
46054: PUSH
46055: LD_VAR 0 1
46059: PPUSH
46060: CALL_OW 437
46064: PUSH
46065: LD_INT 1
46067: ARRAY
46068: PUSH
46069: LD_INT 3
46071: ARRAY
46072: EQUAL
46073: AND
46074: IFFALSE 46084
// result := true end ;
46076: LD_ADDR_VAR 0 3
46080: PUSH
46081: LD_INT 1
46083: ST_TO_ADDR
// end ;
46084: LD_VAR 0 3
46088: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46089: LD_INT 0
46091: PPUSH
// result := false ;
46092: LD_ADDR_VAR 0 4
46096: PUSH
46097: LD_INT 0
46099: ST_TO_ADDR
// if GetTaskList ( unit ) then
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 437
46109: IFFALSE 46192
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46111: LD_STRING M
46113: PUSH
46114: LD_VAR 0 1
46118: PPUSH
46119: CALL_OW 437
46123: PUSH
46124: LD_INT 1
46126: ARRAY
46127: PUSH
46128: LD_INT 1
46130: ARRAY
46131: EQUAL
46132: PUSH
46133: LD_VAR 0 2
46137: PUSH
46138: LD_VAR 0 1
46142: PPUSH
46143: CALL_OW 437
46147: PUSH
46148: LD_INT 1
46150: ARRAY
46151: PUSH
46152: LD_INT 2
46154: ARRAY
46155: EQUAL
46156: AND
46157: PUSH
46158: LD_VAR 0 3
46162: PUSH
46163: LD_VAR 0 1
46167: PPUSH
46168: CALL_OW 437
46172: PUSH
46173: LD_INT 1
46175: ARRAY
46176: PUSH
46177: LD_INT 3
46179: ARRAY
46180: EQUAL
46181: AND
46182: IFFALSE 46192
// result := true ;
46184: LD_ADDR_VAR 0 4
46188: PUSH
46189: LD_INT 1
46191: ST_TO_ADDR
// end ; end ;
46192: LD_VAR 0 4
46196: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46197: LD_INT 0
46199: PPUSH
46200: PPUSH
46201: PPUSH
46202: PPUSH
// if not unit or not area then
46203: LD_VAR 0 1
46207: NOT
46208: PUSH
46209: LD_VAR 0 2
46213: NOT
46214: OR
46215: IFFALSE 46219
// exit ;
46217: GO 46383
// tmp := AreaToList ( area , i ) ;
46219: LD_ADDR_VAR 0 6
46223: PUSH
46224: LD_VAR 0 2
46228: PPUSH
46229: LD_VAR 0 5
46233: PPUSH
46234: CALL_OW 517
46238: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46239: LD_ADDR_VAR 0 5
46243: PUSH
46244: DOUBLE
46245: LD_INT 1
46247: DEC
46248: ST_TO_ADDR
46249: LD_VAR 0 6
46253: PUSH
46254: LD_INT 1
46256: ARRAY
46257: PUSH
46258: FOR_TO
46259: IFFALSE 46381
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46261: LD_ADDR_VAR 0 7
46265: PUSH
46266: LD_VAR 0 6
46270: PUSH
46271: LD_INT 1
46273: ARRAY
46274: PUSH
46275: LD_VAR 0 5
46279: ARRAY
46280: PUSH
46281: LD_VAR 0 6
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PUSH
46290: LD_VAR 0 5
46294: ARRAY
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46300: LD_VAR 0 7
46304: PUSH
46305: LD_INT 1
46307: ARRAY
46308: PPUSH
46309: LD_VAR 0 7
46313: PUSH
46314: LD_INT 2
46316: ARRAY
46317: PPUSH
46318: CALL_OW 428
46322: PUSH
46323: LD_INT 0
46325: EQUAL
46326: IFFALSE 46379
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46328: LD_VAR 0 1
46332: PPUSH
46333: LD_VAR 0 7
46337: PUSH
46338: LD_INT 1
46340: ARRAY
46341: PPUSH
46342: LD_VAR 0 7
46346: PUSH
46347: LD_INT 2
46349: ARRAY
46350: PPUSH
46351: LD_VAR 0 3
46355: PPUSH
46356: CALL_OW 48
// result := IsPlaced ( unit ) ;
46360: LD_ADDR_VAR 0 4
46364: PUSH
46365: LD_VAR 0 1
46369: PPUSH
46370: CALL_OW 305
46374: ST_TO_ADDR
// exit ;
46375: POP
46376: POP
46377: GO 46383
// end ; end ;
46379: GO 46258
46381: POP
46382: POP
// end ;
46383: LD_VAR 0 4
46387: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46388: LD_INT 0
46390: PPUSH
46391: PPUSH
46392: PPUSH
// if not side or side > 8 then
46393: LD_VAR 0 1
46397: NOT
46398: PUSH
46399: LD_VAR 0 1
46403: PUSH
46404: LD_INT 8
46406: GREATER
46407: OR
46408: IFFALSE 46412
// exit ;
46410: GO 46599
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46412: LD_ADDR_VAR 0 4
46416: PUSH
46417: LD_INT 22
46419: PUSH
46420: LD_VAR 0 1
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 21
46431: PUSH
46432: LD_INT 3
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PPUSH
46443: CALL_OW 69
46447: ST_TO_ADDR
// if not tmp then
46448: LD_VAR 0 4
46452: NOT
46453: IFFALSE 46457
// exit ;
46455: GO 46599
// enable_addtolog := true ;
46457: LD_ADDR_OWVAR 81
46461: PUSH
46462: LD_INT 1
46464: ST_TO_ADDR
// AddToLog ( [ ) ;
46465: LD_STRING [
46467: PPUSH
46468: CALL_OW 561
// for i in tmp do
46472: LD_ADDR_VAR 0 3
46476: PUSH
46477: LD_VAR 0 4
46481: PUSH
46482: FOR_IN
46483: IFFALSE 46590
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46485: LD_STRING [
46487: PUSH
46488: LD_VAR 0 3
46492: PPUSH
46493: CALL_OW 266
46497: STR
46498: PUSH
46499: LD_STRING , 
46501: STR
46502: PUSH
46503: LD_VAR 0 3
46507: PPUSH
46508: CALL_OW 250
46512: STR
46513: PUSH
46514: LD_STRING , 
46516: STR
46517: PUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: CALL_OW 251
46527: STR
46528: PUSH
46529: LD_STRING , 
46531: STR
46532: PUSH
46533: LD_VAR 0 3
46537: PPUSH
46538: CALL_OW 254
46542: STR
46543: PUSH
46544: LD_STRING , 
46546: STR
46547: PUSH
46548: LD_VAR 0 3
46552: PPUSH
46553: LD_INT 1
46555: PPUSH
46556: CALL_OW 268
46560: STR
46561: PUSH
46562: LD_STRING , 
46564: STR
46565: PUSH
46566: LD_VAR 0 3
46570: PPUSH
46571: LD_INT 2
46573: PPUSH
46574: CALL_OW 268
46578: STR
46579: PUSH
46580: LD_STRING ],
46582: STR
46583: PPUSH
46584: CALL_OW 561
// end ;
46588: GO 46482
46590: POP
46591: POP
// AddToLog ( ]; ) ;
46592: LD_STRING ];
46594: PPUSH
46595: CALL_OW 561
// end ;
46599: LD_VAR 0 2
46603: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46604: LD_INT 0
46606: PPUSH
46607: PPUSH
46608: PPUSH
46609: PPUSH
46610: PPUSH
// if not area or not rate or not max then
46611: LD_VAR 0 1
46615: NOT
46616: PUSH
46617: LD_VAR 0 2
46621: NOT
46622: OR
46623: PUSH
46624: LD_VAR 0 4
46628: NOT
46629: OR
46630: IFFALSE 46634
// exit ;
46632: GO 46823
// while 1 do
46634: LD_INT 1
46636: IFFALSE 46823
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46638: LD_ADDR_VAR 0 9
46642: PUSH
46643: LD_VAR 0 1
46647: PPUSH
46648: LD_INT 1
46650: PPUSH
46651: CALL_OW 287
46655: PUSH
46656: LD_INT 10
46658: MUL
46659: ST_TO_ADDR
// r := rate / 10 ;
46660: LD_ADDR_VAR 0 7
46664: PUSH
46665: LD_VAR 0 2
46669: PUSH
46670: LD_INT 10
46672: DIVREAL
46673: ST_TO_ADDR
// time := 1 1$00 ;
46674: LD_ADDR_VAR 0 8
46678: PUSH
46679: LD_INT 2100
46681: ST_TO_ADDR
// if amount < min then
46682: LD_VAR 0 9
46686: PUSH
46687: LD_VAR 0 3
46691: LESS
46692: IFFALSE 46710
// r := r * 2 else
46694: LD_ADDR_VAR 0 7
46698: PUSH
46699: LD_VAR 0 7
46703: PUSH
46704: LD_INT 2
46706: MUL
46707: ST_TO_ADDR
46708: GO 46736
// if amount > max then
46710: LD_VAR 0 9
46714: PUSH
46715: LD_VAR 0 4
46719: GREATER
46720: IFFALSE 46736
// r := r / 2 ;
46722: LD_ADDR_VAR 0 7
46726: PUSH
46727: LD_VAR 0 7
46731: PUSH
46732: LD_INT 2
46734: DIVREAL
46735: ST_TO_ADDR
// time := time / r ;
46736: LD_ADDR_VAR 0 8
46740: PUSH
46741: LD_VAR 0 8
46745: PUSH
46746: LD_VAR 0 7
46750: DIVREAL
46751: ST_TO_ADDR
// if time < 0 then
46752: LD_VAR 0 8
46756: PUSH
46757: LD_INT 0
46759: LESS
46760: IFFALSE 46777
// time := time * - 1 ;
46762: LD_ADDR_VAR 0 8
46766: PUSH
46767: LD_VAR 0 8
46771: PUSH
46772: LD_INT 1
46774: NEG
46775: MUL
46776: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46777: LD_VAR 0 8
46781: PUSH
46782: LD_INT 35
46784: PPUSH
46785: LD_INT 875
46787: PPUSH
46788: CALL_OW 12
46792: PLUS
46793: PPUSH
46794: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46798: LD_INT 1
46800: PPUSH
46801: LD_INT 5
46803: PPUSH
46804: CALL_OW 12
46808: PPUSH
46809: LD_VAR 0 1
46813: PPUSH
46814: LD_INT 1
46816: PPUSH
46817: CALL_OW 55
// end ;
46821: GO 46634
// end ;
46823: LD_VAR 0 5
46827: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46828: LD_INT 0
46830: PPUSH
46831: PPUSH
46832: PPUSH
46833: PPUSH
46834: PPUSH
46835: PPUSH
46836: PPUSH
46837: PPUSH
// if not turrets or not factories then
46838: LD_VAR 0 1
46842: NOT
46843: PUSH
46844: LD_VAR 0 2
46848: NOT
46849: OR
46850: IFFALSE 46854
// exit ;
46852: GO 47161
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46854: LD_ADDR_VAR 0 10
46858: PUSH
46859: LD_INT 5
46861: PUSH
46862: LD_INT 6
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 2
46871: PUSH
46872: LD_INT 4
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: LD_INT 3
46881: PUSH
46882: LD_INT 5
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 24
46896: PUSH
46897: LD_INT 25
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 23
46906: PUSH
46907: LD_INT 27
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 42
46920: PUSH
46921: LD_INT 43
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: LD_INT 44
46930: PUSH
46931: LD_INT 46
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PUSH
46938: LD_INT 45
46940: PUSH
46941: LD_INT 47
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: LIST
46957: ST_TO_ADDR
// result := [ ] ;
46958: LD_ADDR_VAR 0 3
46962: PUSH
46963: EMPTY
46964: ST_TO_ADDR
// for i in turrets do
46965: LD_ADDR_VAR 0 4
46969: PUSH
46970: LD_VAR 0 1
46974: PUSH
46975: FOR_IN
46976: IFFALSE 47159
// begin nat := GetNation ( i ) ;
46978: LD_ADDR_VAR 0 7
46982: PUSH
46983: LD_VAR 0 4
46987: PPUSH
46988: CALL_OW 248
46992: ST_TO_ADDR
// weapon := 0 ;
46993: LD_ADDR_VAR 0 8
46997: PUSH
46998: LD_INT 0
47000: ST_TO_ADDR
// if not nat then
47001: LD_VAR 0 7
47005: NOT
47006: IFFALSE 47010
// continue ;
47008: GO 46975
// for j in list [ nat ] do
47010: LD_ADDR_VAR 0 5
47014: PUSH
47015: LD_VAR 0 10
47019: PUSH
47020: LD_VAR 0 7
47024: ARRAY
47025: PUSH
47026: FOR_IN
47027: IFFALSE 47068
// if GetBWeapon ( i ) = j [ 1 ] then
47029: LD_VAR 0 4
47033: PPUSH
47034: CALL_OW 269
47038: PUSH
47039: LD_VAR 0 5
47043: PUSH
47044: LD_INT 1
47046: ARRAY
47047: EQUAL
47048: IFFALSE 47066
// begin weapon := j [ 2 ] ;
47050: LD_ADDR_VAR 0 8
47054: PUSH
47055: LD_VAR 0 5
47059: PUSH
47060: LD_INT 2
47062: ARRAY
47063: ST_TO_ADDR
// break ;
47064: GO 47068
// end ;
47066: GO 47026
47068: POP
47069: POP
// if not weapon then
47070: LD_VAR 0 8
47074: NOT
47075: IFFALSE 47079
// continue ;
47077: GO 46975
// for k in factories do
47079: LD_ADDR_VAR 0 6
47083: PUSH
47084: LD_VAR 0 2
47088: PUSH
47089: FOR_IN
47090: IFFALSE 47155
// begin weapons := AvailableWeaponList ( k ) ;
47092: LD_ADDR_VAR 0 9
47096: PUSH
47097: LD_VAR 0 6
47101: PPUSH
47102: CALL_OW 478
47106: ST_TO_ADDR
// if not weapons then
47107: LD_VAR 0 9
47111: NOT
47112: IFFALSE 47116
// continue ;
47114: GO 47089
// if weapon in weapons then
47116: LD_VAR 0 8
47120: PUSH
47121: LD_VAR 0 9
47125: IN
47126: IFFALSE 47153
// begin result := [ i , weapon ] ;
47128: LD_ADDR_VAR 0 3
47132: PUSH
47133: LD_VAR 0 4
47137: PUSH
47138: LD_VAR 0 8
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: ST_TO_ADDR
// exit ;
47147: POP
47148: POP
47149: POP
47150: POP
47151: GO 47161
// end ; end ;
47153: GO 47089
47155: POP
47156: POP
// end ;
47157: GO 46975
47159: POP
47160: POP
// end ;
47161: LD_VAR 0 3
47165: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47166: LD_INT 0
47168: PPUSH
// if not side or side > 8 then
47169: LD_VAR 0 3
47173: NOT
47174: PUSH
47175: LD_VAR 0 3
47179: PUSH
47180: LD_INT 8
47182: GREATER
47183: OR
47184: IFFALSE 47188
// exit ;
47186: GO 47247
// if not range then
47188: LD_VAR 0 4
47192: NOT
47193: IFFALSE 47204
// range := - 12 ;
47195: LD_ADDR_VAR 0 4
47199: PUSH
47200: LD_INT 12
47202: NEG
47203: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47204: LD_VAR 0 1
47208: PPUSH
47209: LD_VAR 0 2
47213: PPUSH
47214: LD_VAR 0 3
47218: PPUSH
47219: LD_VAR 0 4
47223: PPUSH
47224: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47228: LD_VAR 0 1
47232: PPUSH
47233: LD_VAR 0 2
47237: PPUSH
47238: LD_VAR 0 3
47242: PPUSH
47243: CALL_OW 331
// end ;
47247: LD_VAR 0 5
47251: RET
// export function Video ( mode ) ; begin
47252: LD_INT 0
47254: PPUSH
// ingame_video = mode ;
47255: LD_ADDR_OWVAR 52
47259: PUSH
47260: LD_VAR 0 1
47264: ST_TO_ADDR
// interface_hidden = mode ;
47265: LD_ADDR_OWVAR 54
47269: PUSH
47270: LD_VAR 0 1
47274: ST_TO_ADDR
// end ;
47275: LD_VAR 0 2
47279: RET
// export function Join ( array , element ) ; begin
47280: LD_INT 0
47282: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47283: LD_ADDR_VAR 0 3
47287: PUSH
47288: LD_VAR 0 1
47292: PPUSH
47293: LD_VAR 0 1
47297: PUSH
47298: LD_INT 1
47300: PLUS
47301: PPUSH
47302: LD_VAR 0 2
47306: PPUSH
47307: CALL_OW 1
47311: ST_TO_ADDR
// end ;
47312: LD_VAR 0 3
47316: RET
// export function JoinUnion ( array , element ) ; begin
47317: LD_INT 0
47319: PPUSH
// result := array union element ;
47320: LD_ADDR_VAR 0 3
47324: PUSH
47325: LD_VAR 0 1
47329: PUSH
47330: LD_VAR 0 2
47334: UNION
47335: ST_TO_ADDR
// end ;
47336: LD_VAR 0 3
47340: RET
// export function GetBehemoths ( side ) ; begin
47341: LD_INT 0
47343: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47344: LD_ADDR_VAR 0 2
47348: PUSH
47349: LD_INT 22
47351: PUSH
47352: LD_VAR 0 1
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 31
47363: PUSH
47364: LD_INT 25
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PPUSH
47375: CALL_OW 69
47379: ST_TO_ADDR
// end ;
47380: LD_VAR 0 2
47384: RET
// export function Shuffle ( array ) ; var i , index ; begin
47385: LD_INT 0
47387: PPUSH
47388: PPUSH
47389: PPUSH
// result := [ ] ;
47390: LD_ADDR_VAR 0 2
47394: PUSH
47395: EMPTY
47396: ST_TO_ADDR
// if not array then
47397: LD_VAR 0 1
47401: NOT
47402: IFFALSE 47406
// exit ;
47404: GO 47505
// Randomize ;
47406: CALL_OW 10
// for i = array downto 1 do
47410: LD_ADDR_VAR 0 3
47414: PUSH
47415: DOUBLE
47416: LD_VAR 0 1
47420: INC
47421: ST_TO_ADDR
47422: LD_INT 1
47424: PUSH
47425: FOR_DOWNTO
47426: IFFALSE 47503
// begin index := rand ( 1 , array ) ;
47428: LD_ADDR_VAR 0 4
47432: PUSH
47433: LD_INT 1
47435: PPUSH
47436: LD_VAR 0 1
47440: PPUSH
47441: CALL_OW 12
47445: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47446: LD_ADDR_VAR 0 2
47450: PUSH
47451: LD_VAR 0 2
47455: PPUSH
47456: LD_VAR 0 2
47460: PUSH
47461: LD_INT 1
47463: PLUS
47464: PPUSH
47465: LD_VAR 0 1
47469: PUSH
47470: LD_VAR 0 4
47474: ARRAY
47475: PPUSH
47476: CALL_OW 2
47480: ST_TO_ADDR
// array := Delete ( array , index ) ;
47481: LD_ADDR_VAR 0 1
47485: PUSH
47486: LD_VAR 0 1
47490: PPUSH
47491: LD_VAR 0 4
47495: PPUSH
47496: CALL_OW 3
47500: ST_TO_ADDR
// end ;
47501: GO 47425
47503: POP
47504: POP
// end ;
47505: LD_VAR 0 2
47509: RET
// export function GetBaseMaterials ( base ) ; begin
47510: LD_INT 0
47512: PPUSH
// result := [ 0 , 0 , 0 ] ;
47513: LD_ADDR_VAR 0 2
47517: PUSH
47518: LD_INT 0
47520: PUSH
47521: LD_INT 0
47523: PUSH
47524: LD_INT 0
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: LIST
47531: ST_TO_ADDR
// if not base then
47532: LD_VAR 0 1
47536: NOT
47537: IFFALSE 47541
// exit ;
47539: GO 47590
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47541: LD_ADDR_VAR 0 2
47545: PUSH
47546: LD_VAR 0 1
47550: PPUSH
47551: LD_INT 1
47553: PPUSH
47554: CALL_OW 275
47558: PUSH
47559: LD_VAR 0 1
47563: PPUSH
47564: LD_INT 2
47566: PPUSH
47567: CALL_OW 275
47571: PUSH
47572: LD_VAR 0 1
47576: PPUSH
47577: LD_INT 3
47579: PPUSH
47580: CALL_OW 275
47584: PUSH
47585: EMPTY
47586: LIST
47587: LIST
47588: LIST
47589: ST_TO_ADDR
// end ;
47590: LD_VAR 0 2
47594: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47595: LD_INT 0
47597: PPUSH
47598: PPUSH
// result := array ;
47599: LD_ADDR_VAR 0 3
47603: PUSH
47604: LD_VAR 0 1
47608: ST_TO_ADDR
// if size >= result then
47609: LD_VAR 0 2
47613: PUSH
47614: LD_VAR 0 3
47618: GREATEREQUAL
47619: IFFALSE 47623
// exit ;
47621: GO 47673
// if size then
47623: LD_VAR 0 2
47627: IFFALSE 47673
// for i := array downto size do
47629: LD_ADDR_VAR 0 4
47633: PUSH
47634: DOUBLE
47635: LD_VAR 0 1
47639: INC
47640: ST_TO_ADDR
47641: LD_VAR 0 2
47645: PUSH
47646: FOR_DOWNTO
47647: IFFALSE 47671
// result := Delete ( result , result ) ;
47649: LD_ADDR_VAR 0 3
47653: PUSH
47654: LD_VAR 0 3
47658: PPUSH
47659: LD_VAR 0 3
47663: PPUSH
47664: CALL_OW 3
47668: ST_TO_ADDR
47669: GO 47646
47671: POP
47672: POP
// end ;
47673: LD_VAR 0 3
47677: RET
// export function ComExit ( unit ) ; var tmp ; begin
47678: LD_INT 0
47680: PPUSH
47681: PPUSH
// if not IsInUnit ( unit ) then
47682: LD_VAR 0 1
47686: PPUSH
47687: CALL_OW 310
47691: NOT
47692: IFFALSE 47696
// exit ;
47694: GO 47756
// tmp := IsInUnit ( unit ) ;
47696: LD_ADDR_VAR 0 3
47700: PUSH
47701: LD_VAR 0 1
47705: PPUSH
47706: CALL_OW 310
47710: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47711: LD_VAR 0 3
47715: PPUSH
47716: CALL_OW 247
47720: PUSH
47721: LD_INT 2
47723: EQUAL
47724: IFFALSE 47737
// ComExitVehicle ( unit ) else
47726: LD_VAR 0 1
47730: PPUSH
47731: CALL_OW 121
47735: GO 47746
// ComExitBuilding ( unit ) ;
47737: LD_VAR 0 1
47741: PPUSH
47742: CALL_OW 122
// result := tmp ;
47746: LD_ADDR_VAR 0 2
47750: PUSH
47751: LD_VAR 0 3
47755: ST_TO_ADDR
// end ;
47756: LD_VAR 0 2
47760: RET
// export function ComExitAll ( units ) ; var i ; begin
47761: LD_INT 0
47763: PPUSH
47764: PPUSH
// if not units then
47765: LD_VAR 0 1
47769: NOT
47770: IFFALSE 47774
// exit ;
47772: GO 47800
// for i in units do
47774: LD_ADDR_VAR 0 3
47778: PUSH
47779: LD_VAR 0 1
47783: PUSH
47784: FOR_IN
47785: IFFALSE 47798
// ComExit ( i ) ;
47787: LD_VAR 0 3
47791: PPUSH
47792: CALL 47678 0 1
47796: GO 47784
47798: POP
47799: POP
// end ;
47800: LD_VAR 0 2
47804: RET
// export function ResetHc ; begin
47805: LD_INT 0
47807: PPUSH
// InitHc ;
47808: CALL_OW 19
// hc_importance := 0 ;
47812: LD_ADDR_OWVAR 32
47816: PUSH
47817: LD_INT 0
47819: ST_TO_ADDR
// end ;
47820: LD_VAR 0 1
47824: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47825: LD_INT 0
47827: PPUSH
47828: PPUSH
47829: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47830: LD_ADDR_VAR 0 6
47834: PUSH
47835: LD_VAR 0 1
47839: PUSH
47840: LD_VAR 0 3
47844: PLUS
47845: PUSH
47846: LD_INT 2
47848: DIV
47849: ST_TO_ADDR
// if _x < 0 then
47850: LD_VAR 0 6
47854: PUSH
47855: LD_INT 0
47857: LESS
47858: IFFALSE 47875
// _x := _x * - 1 ;
47860: LD_ADDR_VAR 0 6
47864: PUSH
47865: LD_VAR 0 6
47869: PUSH
47870: LD_INT 1
47872: NEG
47873: MUL
47874: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47875: LD_ADDR_VAR 0 7
47879: PUSH
47880: LD_VAR 0 2
47884: PUSH
47885: LD_VAR 0 4
47889: PLUS
47890: PUSH
47891: LD_INT 2
47893: DIV
47894: ST_TO_ADDR
// if _y < 0 then
47895: LD_VAR 0 7
47899: PUSH
47900: LD_INT 0
47902: LESS
47903: IFFALSE 47920
// _y := _y * - 1 ;
47905: LD_ADDR_VAR 0 7
47909: PUSH
47910: LD_VAR 0 7
47914: PUSH
47915: LD_INT 1
47917: NEG
47918: MUL
47919: ST_TO_ADDR
// result := [ _x , _y ] ;
47920: LD_ADDR_VAR 0 5
47924: PUSH
47925: LD_VAR 0 6
47929: PUSH
47930: LD_VAR 0 7
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: ST_TO_ADDR
// end ;
47939: LD_VAR 0 5
47943: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47944: LD_INT 0
47946: PPUSH
47947: PPUSH
47948: PPUSH
47949: PPUSH
// task := GetTaskList ( unit ) ;
47950: LD_ADDR_VAR 0 7
47954: PUSH
47955: LD_VAR 0 1
47959: PPUSH
47960: CALL_OW 437
47964: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47965: LD_VAR 0 7
47969: NOT
47970: PUSH
47971: LD_VAR 0 1
47975: PPUSH
47976: LD_VAR 0 2
47980: PPUSH
47981: CALL_OW 308
47985: NOT
47986: AND
47987: IFFALSE 47991
// exit ;
47989: GO 48109
// if IsInArea ( unit , area ) then
47991: LD_VAR 0 1
47995: PPUSH
47996: LD_VAR 0 2
48000: PPUSH
48001: CALL_OW 308
48005: IFFALSE 48023
// begin ComMoveToArea ( unit , goAway ) ;
48007: LD_VAR 0 1
48011: PPUSH
48012: LD_VAR 0 3
48016: PPUSH
48017: CALL_OW 113
// exit ;
48021: GO 48109
// end ; if task [ 1 ] [ 1 ] <> M then
48023: LD_VAR 0 7
48027: PUSH
48028: LD_INT 1
48030: ARRAY
48031: PUSH
48032: LD_INT 1
48034: ARRAY
48035: PUSH
48036: LD_STRING M
48038: NONEQUAL
48039: IFFALSE 48043
// exit ;
48041: GO 48109
// x := task [ 1 ] [ 2 ] ;
48043: LD_ADDR_VAR 0 5
48047: PUSH
48048: LD_VAR 0 7
48052: PUSH
48053: LD_INT 1
48055: ARRAY
48056: PUSH
48057: LD_INT 2
48059: ARRAY
48060: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48061: LD_ADDR_VAR 0 6
48065: PUSH
48066: LD_VAR 0 7
48070: PUSH
48071: LD_INT 1
48073: ARRAY
48074: PUSH
48075: LD_INT 3
48077: ARRAY
48078: ST_TO_ADDR
// if InArea ( x , y , area ) then
48079: LD_VAR 0 5
48083: PPUSH
48084: LD_VAR 0 6
48088: PPUSH
48089: LD_VAR 0 2
48093: PPUSH
48094: CALL_OW 309
48098: IFFALSE 48109
// ComStop ( unit ) ;
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL_OW 141
// end ;
48109: LD_VAR 0 4
48113: RET
// export function Abs ( value ) ; begin
48114: LD_INT 0
48116: PPUSH
// result := value ;
48117: LD_ADDR_VAR 0 2
48121: PUSH
48122: LD_VAR 0 1
48126: ST_TO_ADDR
// if value < 0 then
48127: LD_VAR 0 1
48131: PUSH
48132: LD_INT 0
48134: LESS
48135: IFFALSE 48152
// result := value * - 1 ;
48137: LD_ADDR_VAR 0 2
48141: PUSH
48142: LD_VAR 0 1
48146: PUSH
48147: LD_INT 1
48149: NEG
48150: MUL
48151: ST_TO_ADDR
// end ;
48152: LD_VAR 0 2
48156: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48157: LD_INT 0
48159: PPUSH
48160: PPUSH
48161: PPUSH
48162: PPUSH
48163: PPUSH
48164: PPUSH
48165: PPUSH
48166: PPUSH
// if not unit or not building then
48167: LD_VAR 0 1
48171: NOT
48172: PUSH
48173: LD_VAR 0 2
48177: NOT
48178: OR
48179: IFFALSE 48183
// exit ;
48181: GO 48409
// x := GetX ( building ) ;
48183: LD_ADDR_VAR 0 4
48187: PUSH
48188: LD_VAR 0 2
48192: PPUSH
48193: CALL_OW 250
48197: ST_TO_ADDR
// y := GetY ( building ) ;
48198: LD_ADDR_VAR 0 6
48202: PUSH
48203: LD_VAR 0 2
48207: PPUSH
48208: CALL_OW 251
48212: ST_TO_ADDR
// d := GetDir ( building ) ;
48213: LD_ADDR_VAR 0 8
48217: PUSH
48218: LD_VAR 0 2
48222: PPUSH
48223: CALL_OW 254
48227: ST_TO_ADDR
// r := 4 ;
48228: LD_ADDR_VAR 0 9
48232: PUSH
48233: LD_INT 4
48235: ST_TO_ADDR
// for i := 1 to 5 do
48236: LD_ADDR_VAR 0 10
48240: PUSH
48241: DOUBLE
48242: LD_INT 1
48244: DEC
48245: ST_TO_ADDR
48246: LD_INT 5
48248: PUSH
48249: FOR_TO
48250: IFFALSE 48407
// begin _x := ShiftX ( x , d , r + i ) ;
48252: LD_ADDR_VAR 0 5
48256: PUSH
48257: LD_VAR 0 4
48261: PPUSH
48262: LD_VAR 0 8
48266: PPUSH
48267: LD_VAR 0 9
48271: PUSH
48272: LD_VAR 0 10
48276: PLUS
48277: PPUSH
48278: CALL_OW 272
48282: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48283: LD_ADDR_VAR 0 7
48287: PUSH
48288: LD_VAR 0 6
48292: PPUSH
48293: LD_VAR 0 8
48297: PPUSH
48298: LD_VAR 0 9
48302: PUSH
48303: LD_VAR 0 10
48307: PLUS
48308: PPUSH
48309: CALL_OW 273
48313: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48314: LD_VAR 0 5
48318: PPUSH
48319: LD_VAR 0 7
48323: PPUSH
48324: CALL_OW 488
48328: PUSH
48329: LD_VAR 0 5
48333: PPUSH
48334: LD_VAR 0 7
48338: PPUSH
48339: CALL_OW 428
48343: PPUSH
48344: CALL_OW 247
48348: PUSH
48349: LD_INT 3
48351: PUSH
48352: LD_INT 2
48354: PUSH
48355: EMPTY
48356: LIST
48357: LIST
48358: IN
48359: NOT
48360: AND
48361: IFFALSE 48405
// begin ComMoveXY ( unit , _x , _y ) ;
48363: LD_VAR 0 1
48367: PPUSH
48368: LD_VAR 0 5
48372: PPUSH
48373: LD_VAR 0 7
48377: PPUSH
48378: CALL_OW 111
// result := [ _x , _y ] ;
48382: LD_ADDR_VAR 0 3
48386: PUSH
48387: LD_VAR 0 5
48391: PUSH
48392: LD_VAR 0 7
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: ST_TO_ADDR
// exit ;
48401: POP
48402: POP
48403: GO 48409
// end ; end ;
48405: GO 48249
48407: POP
48408: POP
// end ;
48409: LD_VAR 0 3
48413: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48414: LD_INT 0
48416: PPUSH
48417: PPUSH
48418: PPUSH
// result := 0 ;
48419: LD_ADDR_VAR 0 3
48423: PUSH
48424: LD_INT 0
48426: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48427: LD_VAR 0 1
48431: PUSH
48432: LD_INT 0
48434: LESS
48435: PUSH
48436: LD_VAR 0 1
48440: PUSH
48441: LD_INT 8
48443: GREATER
48444: OR
48445: PUSH
48446: LD_VAR 0 2
48450: PUSH
48451: LD_INT 0
48453: LESS
48454: OR
48455: PUSH
48456: LD_VAR 0 2
48460: PUSH
48461: LD_INT 8
48463: GREATER
48464: OR
48465: IFFALSE 48469
// exit ;
48467: GO 48544
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48469: LD_ADDR_VAR 0 4
48473: PUSH
48474: LD_INT 22
48476: PUSH
48477: LD_VAR 0 2
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PPUSH
48486: CALL_OW 69
48490: PUSH
48491: FOR_IN
48492: IFFALSE 48542
// begin un := UnitShoot ( i ) ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 4
48503: PPUSH
48504: CALL_OW 504
48508: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48509: LD_VAR 0 5
48513: PPUSH
48514: CALL_OW 255
48518: PUSH
48519: LD_VAR 0 1
48523: EQUAL
48524: IFFALSE 48540
// begin result := un ;
48526: LD_ADDR_VAR 0 3
48530: PUSH
48531: LD_VAR 0 5
48535: ST_TO_ADDR
// exit ;
48536: POP
48537: POP
48538: GO 48544
// end ; end ;
48540: GO 48491
48542: POP
48543: POP
// end ;
48544: LD_VAR 0 3
48548: RET
// export function GetCargoBay ( units ) ; begin
48549: LD_INT 0
48551: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48552: LD_ADDR_VAR 0 2
48556: PUSH
48557: LD_VAR 0 1
48561: PPUSH
48562: LD_INT 2
48564: PUSH
48565: LD_INT 34
48567: PUSH
48568: LD_INT 12
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 34
48577: PUSH
48578: LD_INT 51
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PUSH
48585: LD_INT 34
48587: PUSH
48588: LD_INT 32
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: PUSH
48595: LD_INT 34
48597: PUSH
48598: LD_INT 89
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: PUSH
48605: EMPTY
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: PPUSH
48612: CALL_OW 72
48616: ST_TO_ADDR
// end ;
48617: LD_VAR 0 2
48621: RET
// export function Negate ( value ) ; begin
48622: LD_INT 0
48624: PPUSH
// result := not value ;
48625: LD_ADDR_VAR 0 2
48629: PUSH
48630: LD_VAR 0 1
48634: NOT
48635: ST_TO_ADDR
// end ;
48636: LD_VAR 0 2
48640: RET
// export function Inc ( value ) ; begin
48641: LD_INT 0
48643: PPUSH
// result := value + 1 ;
48644: LD_ADDR_VAR 0 2
48648: PUSH
48649: LD_VAR 0 1
48653: PUSH
48654: LD_INT 1
48656: PLUS
48657: ST_TO_ADDR
// end ;
48658: LD_VAR 0 2
48662: RET
// export function Dec ( value ) ; begin
48663: LD_INT 0
48665: PPUSH
// result := value - 1 ;
48666: LD_ADDR_VAR 0 2
48670: PUSH
48671: LD_VAR 0 1
48675: PUSH
48676: LD_INT 1
48678: MINUS
48679: ST_TO_ADDR
// end ;
48680: LD_VAR 0 2
48684: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48685: LD_INT 0
48687: PPUSH
48688: PPUSH
48689: PPUSH
48690: PPUSH
48691: PPUSH
48692: PPUSH
48693: PPUSH
48694: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48695: LD_VAR 0 1
48699: PPUSH
48700: LD_VAR 0 2
48704: PPUSH
48705: CALL_OW 488
48709: NOT
48710: PUSH
48711: LD_VAR 0 3
48715: PPUSH
48716: LD_VAR 0 4
48720: PPUSH
48721: CALL_OW 488
48725: NOT
48726: OR
48727: IFFALSE 48740
// begin result := - 1 ;
48729: LD_ADDR_VAR 0 5
48733: PUSH
48734: LD_INT 1
48736: NEG
48737: ST_TO_ADDR
// exit ;
48738: GO 48975
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48740: LD_ADDR_VAR 0 12
48744: PUSH
48745: LD_VAR 0 1
48749: PPUSH
48750: LD_VAR 0 2
48754: PPUSH
48755: LD_VAR 0 3
48759: PPUSH
48760: LD_VAR 0 4
48764: PPUSH
48765: CALL 47825 0 4
48769: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48770: LD_ADDR_VAR 0 11
48774: PUSH
48775: LD_VAR 0 1
48779: PPUSH
48780: LD_VAR 0 2
48784: PPUSH
48785: LD_VAR 0 12
48789: PUSH
48790: LD_INT 1
48792: ARRAY
48793: PPUSH
48794: LD_VAR 0 12
48798: PUSH
48799: LD_INT 2
48801: ARRAY
48802: PPUSH
48803: CALL_OW 298
48807: ST_TO_ADDR
// distance := 9999 ;
48808: LD_ADDR_VAR 0 10
48812: PUSH
48813: LD_INT 9999
48815: ST_TO_ADDR
// for i := 0 to 5 do
48816: LD_ADDR_VAR 0 6
48820: PUSH
48821: DOUBLE
48822: LD_INT 0
48824: DEC
48825: ST_TO_ADDR
48826: LD_INT 5
48828: PUSH
48829: FOR_TO
48830: IFFALSE 48973
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48832: LD_ADDR_VAR 0 7
48836: PUSH
48837: LD_VAR 0 1
48841: PPUSH
48842: LD_VAR 0 6
48846: PPUSH
48847: LD_VAR 0 11
48851: PPUSH
48852: CALL_OW 272
48856: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48857: LD_ADDR_VAR 0 8
48861: PUSH
48862: LD_VAR 0 2
48866: PPUSH
48867: LD_VAR 0 6
48871: PPUSH
48872: LD_VAR 0 11
48876: PPUSH
48877: CALL_OW 273
48881: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48882: LD_VAR 0 7
48886: PPUSH
48887: LD_VAR 0 8
48891: PPUSH
48892: CALL_OW 488
48896: NOT
48897: IFFALSE 48901
// continue ;
48899: GO 48829
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48901: LD_ADDR_VAR 0 9
48905: PUSH
48906: LD_VAR 0 12
48910: PUSH
48911: LD_INT 1
48913: ARRAY
48914: PPUSH
48915: LD_VAR 0 12
48919: PUSH
48920: LD_INT 2
48922: ARRAY
48923: PPUSH
48924: LD_VAR 0 7
48928: PPUSH
48929: LD_VAR 0 8
48933: PPUSH
48934: CALL_OW 298
48938: ST_TO_ADDR
// if tmp < distance then
48939: LD_VAR 0 9
48943: PUSH
48944: LD_VAR 0 10
48948: LESS
48949: IFFALSE 48971
// begin result := i ;
48951: LD_ADDR_VAR 0 5
48955: PUSH
48956: LD_VAR 0 6
48960: ST_TO_ADDR
// distance := tmp ;
48961: LD_ADDR_VAR 0 10
48965: PUSH
48966: LD_VAR 0 9
48970: ST_TO_ADDR
// end ; end ;
48971: GO 48829
48973: POP
48974: POP
// end ;
48975: LD_VAR 0 5
48979: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48980: LD_INT 0
48982: PPUSH
48983: PPUSH
// if not driver or not IsInUnit ( driver ) then
48984: LD_VAR 0 1
48988: NOT
48989: PUSH
48990: LD_VAR 0 1
48994: PPUSH
48995: CALL_OW 310
48999: NOT
49000: OR
49001: IFFALSE 49005
// exit ;
49003: GO 49095
// vehicle := IsInUnit ( driver ) ;
49005: LD_ADDR_VAR 0 3
49009: PUSH
49010: LD_VAR 0 1
49014: PPUSH
49015: CALL_OW 310
49019: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49020: LD_VAR 0 1
49024: PPUSH
49025: LD_STRING \
49027: PUSH
49028: LD_INT 0
49030: PUSH
49031: LD_INT 0
49033: PUSH
49034: LD_INT 0
49036: PUSH
49037: LD_INT 0
49039: PUSH
49040: LD_INT 0
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: EMPTY
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: LIST
49054: PUSH
49055: LD_STRING E
49057: PUSH
49058: LD_INT 0
49060: PUSH
49061: LD_INT 0
49063: PUSH
49064: LD_VAR 0 3
49068: PUSH
49069: LD_INT 0
49071: PUSH
49072: LD_INT 0
49074: PUSH
49075: LD_INT 0
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: PUSH
49087: EMPTY
49088: LIST
49089: LIST
49090: PPUSH
49091: CALL_OW 446
// end ;
49095: LD_VAR 0 2
49099: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49100: LD_INT 0
49102: PPUSH
49103: PPUSH
// if not driver or not IsInUnit ( driver ) then
49104: LD_VAR 0 1
49108: NOT
49109: PUSH
49110: LD_VAR 0 1
49114: PPUSH
49115: CALL_OW 310
49119: NOT
49120: OR
49121: IFFALSE 49125
// exit ;
49123: GO 49215
// vehicle := IsInUnit ( driver ) ;
49125: LD_ADDR_VAR 0 3
49129: PUSH
49130: LD_VAR 0 1
49134: PPUSH
49135: CALL_OW 310
49139: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49140: LD_VAR 0 1
49144: PPUSH
49145: LD_STRING \
49147: PUSH
49148: LD_INT 0
49150: PUSH
49151: LD_INT 0
49153: PUSH
49154: LD_INT 0
49156: PUSH
49157: LD_INT 0
49159: PUSH
49160: LD_INT 0
49162: PUSH
49163: LD_INT 0
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: PUSH
49175: LD_STRING E
49177: PUSH
49178: LD_INT 0
49180: PUSH
49181: LD_INT 0
49183: PUSH
49184: LD_VAR 0 3
49188: PUSH
49189: LD_INT 0
49191: PUSH
49192: LD_INT 0
49194: PUSH
49195: LD_INT 0
49197: PUSH
49198: EMPTY
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: PUSH
49207: EMPTY
49208: LIST
49209: LIST
49210: PPUSH
49211: CALL_OW 447
// end ;
49215: LD_VAR 0 2
49219: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49220: LD_INT 0
49222: PPUSH
49223: PPUSH
49224: PPUSH
// tmp := [ ] ;
49225: LD_ADDR_VAR 0 5
49229: PUSH
49230: EMPTY
49231: ST_TO_ADDR
// for i in units do
49232: LD_ADDR_VAR 0 4
49236: PUSH
49237: LD_VAR 0 1
49241: PUSH
49242: FOR_IN
49243: IFFALSE 49281
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49245: LD_ADDR_VAR 0 5
49249: PUSH
49250: LD_VAR 0 5
49254: PPUSH
49255: LD_VAR 0 5
49259: PUSH
49260: LD_INT 1
49262: PLUS
49263: PPUSH
49264: LD_VAR 0 4
49268: PPUSH
49269: CALL_OW 256
49273: PPUSH
49274: CALL_OW 2
49278: ST_TO_ADDR
49279: GO 49242
49281: POP
49282: POP
// if not tmp then
49283: LD_VAR 0 5
49287: NOT
49288: IFFALSE 49292
// exit ;
49290: GO 49340
// if asc then
49292: LD_VAR 0 2
49296: IFFALSE 49320
// result := SortListByListAsc ( units , tmp ) else
49298: LD_ADDR_VAR 0 3
49302: PUSH
49303: LD_VAR 0 1
49307: PPUSH
49308: LD_VAR 0 5
49312: PPUSH
49313: CALL_OW 76
49317: ST_TO_ADDR
49318: GO 49340
// result := SortListByListDesc ( units , tmp ) ;
49320: LD_ADDR_VAR 0 3
49324: PUSH
49325: LD_VAR 0 1
49329: PPUSH
49330: LD_VAR 0 5
49334: PPUSH
49335: CALL_OW 77
49339: ST_TO_ADDR
// end ;
49340: LD_VAR 0 3
49344: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49345: LD_INT 0
49347: PPUSH
49348: PPUSH
// task := GetTaskList ( mech ) ;
49349: LD_ADDR_VAR 0 4
49353: PUSH
49354: LD_VAR 0 1
49358: PPUSH
49359: CALL_OW 437
49363: ST_TO_ADDR
// if not task then
49364: LD_VAR 0 4
49368: NOT
49369: IFFALSE 49373
// exit ;
49371: GO 49415
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49373: LD_ADDR_VAR 0 3
49377: PUSH
49378: LD_VAR 0 4
49382: PUSH
49383: LD_INT 1
49385: ARRAY
49386: PUSH
49387: LD_INT 1
49389: ARRAY
49390: PUSH
49391: LD_STRING r
49393: EQUAL
49394: PUSH
49395: LD_VAR 0 4
49399: PUSH
49400: LD_INT 1
49402: ARRAY
49403: PUSH
49404: LD_INT 4
49406: ARRAY
49407: PUSH
49408: LD_VAR 0 2
49412: EQUAL
49413: AND
49414: ST_TO_ADDR
// end ;
49415: LD_VAR 0 3
49419: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49420: LD_INT 0
49422: PPUSH
// SetDir ( unit , d ) ;
49423: LD_VAR 0 1
49427: PPUSH
49428: LD_VAR 0 4
49432: PPUSH
49433: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49437: LD_VAR 0 1
49441: PPUSH
49442: LD_VAR 0 2
49446: PPUSH
49447: LD_VAR 0 3
49451: PPUSH
49452: LD_VAR 0 5
49456: PPUSH
49457: CALL_OW 48
// end ;
49461: LD_VAR 0 6
49465: RET
// export function ToNaturalNumber ( number ) ; begin
49466: LD_INT 0
49468: PPUSH
// result := number div 1 ;
49469: LD_ADDR_VAR 0 2
49473: PUSH
49474: LD_VAR 0 1
49478: PUSH
49479: LD_INT 1
49481: DIV
49482: ST_TO_ADDR
// if number < 0 then
49483: LD_VAR 0 1
49487: PUSH
49488: LD_INT 0
49490: LESS
49491: IFFALSE 49501
// result := 0 ;
49493: LD_ADDR_VAR 0 2
49497: PUSH
49498: LD_INT 0
49500: ST_TO_ADDR
// end ;
49501: LD_VAR 0 2
49505: RET
// export function SortByClass ( units , class ) ; var un ; begin
49506: LD_INT 0
49508: PPUSH
49509: PPUSH
// if not units or not class then
49510: LD_VAR 0 1
49514: NOT
49515: PUSH
49516: LD_VAR 0 2
49520: NOT
49521: OR
49522: IFFALSE 49526
// exit ;
49524: GO 49621
// result := [ ] ;
49526: LD_ADDR_VAR 0 3
49530: PUSH
49531: EMPTY
49532: ST_TO_ADDR
// for un in units do
49533: LD_ADDR_VAR 0 4
49537: PUSH
49538: LD_VAR 0 1
49542: PUSH
49543: FOR_IN
49544: IFFALSE 49619
// if GetClass ( un ) = class then
49546: LD_VAR 0 4
49550: PPUSH
49551: CALL_OW 257
49555: PUSH
49556: LD_VAR 0 2
49560: EQUAL
49561: IFFALSE 49588
// result := Insert ( result , 1 , un ) else
49563: LD_ADDR_VAR 0 3
49567: PUSH
49568: LD_VAR 0 3
49572: PPUSH
49573: LD_INT 1
49575: PPUSH
49576: LD_VAR 0 4
49580: PPUSH
49581: CALL_OW 2
49585: ST_TO_ADDR
49586: GO 49617
// result := Replace ( result , result + 1 , un ) ;
49588: LD_ADDR_VAR 0 3
49592: PUSH
49593: LD_VAR 0 3
49597: PPUSH
49598: LD_VAR 0 3
49602: PUSH
49603: LD_INT 1
49605: PLUS
49606: PPUSH
49607: LD_VAR 0 4
49611: PPUSH
49612: CALL_OW 1
49616: ST_TO_ADDR
49617: GO 49543
49619: POP
49620: POP
// end ;
49621: LD_VAR 0 3
49625: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49626: LD_INT 0
49628: PPUSH
49629: PPUSH
49630: PPUSH
49631: PPUSH
49632: PPUSH
49633: PPUSH
49634: PPUSH
// result := [ ] ;
49635: LD_ADDR_VAR 0 4
49639: PUSH
49640: EMPTY
49641: ST_TO_ADDR
// if x - r < 0 then
49642: LD_VAR 0 1
49646: PUSH
49647: LD_VAR 0 3
49651: MINUS
49652: PUSH
49653: LD_INT 0
49655: LESS
49656: IFFALSE 49668
// min_x := 0 else
49658: LD_ADDR_VAR 0 8
49662: PUSH
49663: LD_INT 0
49665: ST_TO_ADDR
49666: GO 49684
// min_x := x - r ;
49668: LD_ADDR_VAR 0 8
49672: PUSH
49673: LD_VAR 0 1
49677: PUSH
49678: LD_VAR 0 3
49682: MINUS
49683: ST_TO_ADDR
// if y - r < 0 then
49684: LD_VAR 0 2
49688: PUSH
49689: LD_VAR 0 3
49693: MINUS
49694: PUSH
49695: LD_INT 0
49697: LESS
49698: IFFALSE 49710
// min_y := 0 else
49700: LD_ADDR_VAR 0 7
49704: PUSH
49705: LD_INT 0
49707: ST_TO_ADDR
49708: GO 49726
// min_y := y - r ;
49710: LD_ADDR_VAR 0 7
49714: PUSH
49715: LD_VAR 0 2
49719: PUSH
49720: LD_VAR 0 3
49724: MINUS
49725: ST_TO_ADDR
// max_x := x + r ;
49726: LD_ADDR_VAR 0 9
49730: PUSH
49731: LD_VAR 0 1
49735: PUSH
49736: LD_VAR 0 3
49740: PLUS
49741: ST_TO_ADDR
// max_y := y + r ;
49742: LD_ADDR_VAR 0 10
49746: PUSH
49747: LD_VAR 0 2
49751: PUSH
49752: LD_VAR 0 3
49756: PLUS
49757: ST_TO_ADDR
// for _x = min_x to max_x do
49758: LD_ADDR_VAR 0 5
49762: PUSH
49763: DOUBLE
49764: LD_VAR 0 8
49768: DEC
49769: ST_TO_ADDR
49770: LD_VAR 0 9
49774: PUSH
49775: FOR_TO
49776: IFFALSE 49877
// for _y = min_y to max_y do
49778: LD_ADDR_VAR 0 6
49782: PUSH
49783: DOUBLE
49784: LD_VAR 0 7
49788: DEC
49789: ST_TO_ADDR
49790: LD_VAR 0 10
49794: PUSH
49795: FOR_TO
49796: IFFALSE 49873
// begin if not ValidHex ( _x , _y ) then
49798: LD_VAR 0 5
49802: PPUSH
49803: LD_VAR 0 6
49807: PPUSH
49808: CALL_OW 488
49812: NOT
49813: IFFALSE 49817
// continue ;
49815: GO 49795
// if GetResourceTypeXY ( _x , _y ) then
49817: LD_VAR 0 5
49821: PPUSH
49822: LD_VAR 0 6
49826: PPUSH
49827: CALL_OW 283
49831: IFFALSE 49871
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49833: LD_ADDR_VAR 0 4
49837: PUSH
49838: LD_VAR 0 4
49842: PPUSH
49843: LD_VAR 0 4
49847: PUSH
49848: LD_INT 1
49850: PLUS
49851: PPUSH
49852: LD_VAR 0 5
49856: PUSH
49857: LD_VAR 0 6
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PPUSH
49866: CALL_OW 1
49870: ST_TO_ADDR
// end ;
49871: GO 49795
49873: POP
49874: POP
49875: GO 49775
49877: POP
49878: POP
// end ;
49879: LD_VAR 0 4
49883: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49884: LD_INT 0
49886: PPUSH
49887: PPUSH
49888: PPUSH
49889: PPUSH
49890: PPUSH
49891: PPUSH
49892: PPUSH
49893: PPUSH
// if not units then
49894: LD_VAR 0 1
49898: NOT
49899: IFFALSE 49903
// exit ;
49901: GO 50427
// result := UnitFilter ( units , [ f_ok ] ) ;
49903: LD_ADDR_VAR 0 3
49907: PUSH
49908: LD_VAR 0 1
49912: PPUSH
49913: LD_INT 50
49915: PUSH
49916: EMPTY
49917: LIST
49918: PPUSH
49919: CALL_OW 72
49923: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49924: LD_ADDR_VAR 0 8
49928: PUSH
49929: LD_VAR 0 1
49933: PUSH
49934: LD_INT 1
49936: ARRAY
49937: PPUSH
49938: CALL_OW 255
49942: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49943: LD_ADDR_VAR 0 10
49947: PUSH
49948: LD_INT 29
49950: PUSH
49951: LD_INT 91
49953: PUSH
49954: LD_INT 49
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: LIST
49961: ST_TO_ADDR
// if not result then
49962: LD_VAR 0 3
49966: NOT
49967: IFFALSE 49971
// exit ;
49969: GO 50427
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49971: LD_ADDR_VAR 0 5
49975: PUSH
49976: LD_INT 81
49978: PUSH
49979: LD_VAR 0 8
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PPUSH
49988: CALL_OW 69
49992: ST_TO_ADDR
// for i in result do
49993: LD_ADDR_VAR 0 4
49997: PUSH
49998: LD_VAR 0 3
50002: PUSH
50003: FOR_IN
50004: IFFALSE 50425
// begin tag := GetTag ( i ) + 1 ;
50006: LD_ADDR_VAR 0 9
50010: PUSH
50011: LD_VAR 0 4
50015: PPUSH
50016: CALL_OW 110
50020: PUSH
50021: LD_INT 1
50023: PLUS
50024: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50025: LD_ADDR_VAR 0 7
50029: PUSH
50030: LD_VAR 0 4
50034: PPUSH
50035: CALL_OW 250
50039: PPUSH
50040: LD_VAR 0 4
50044: PPUSH
50045: CALL_OW 251
50049: PPUSH
50050: LD_INT 6
50052: PPUSH
50053: CALL 49626 0 3
50057: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50058: LD_VAR 0 4
50062: PPUSH
50063: CALL_OW 247
50067: PUSH
50068: LD_INT 2
50070: EQUAL
50071: PUSH
50072: LD_VAR 0 7
50076: AND
50077: PUSH
50078: LD_VAR 0 4
50082: PPUSH
50083: CALL_OW 264
50087: PUSH
50088: LD_VAR 0 10
50092: IN
50093: NOT
50094: AND
50095: IFFALSE 50134
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50097: LD_VAR 0 4
50101: PPUSH
50102: LD_VAR 0 7
50106: PUSH
50107: LD_INT 1
50109: ARRAY
50110: PUSH
50111: LD_INT 1
50113: ARRAY
50114: PPUSH
50115: LD_VAR 0 7
50119: PUSH
50120: LD_INT 1
50122: ARRAY
50123: PUSH
50124: LD_INT 2
50126: ARRAY
50127: PPUSH
50128: CALL_OW 116
50132: GO 50423
// if path > tag then
50134: LD_VAR 0 2
50138: PUSH
50139: LD_VAR 0 9
50143: GREATER
50144: IFFALSE 50352
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50146: LD_ADDR_VAR 0 6
50150: PUSH
50151: LD_VAR 0 5
50155: PPUSH
50156: LD_INT 91
50158: PUSH
50159: LD_VAR 0 4
50163: PUSH
50164: LD_INT 8
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: LIST
50171: PPUSH
50172: CALL_OW 72
50176: ST_TO_ADDR
// if nearEnemy then
50177: LD_VAR 0 6
50181: IFFALSE 50250
// begin if GetWeapon ( i ) = ru_time_lapser then
50183: LD_VAR 0 4
50187: PPUSH
50188: CALL_OW 264
50192: PUSH
50193: LD_INT 49
50195: EQUAL
50196: IFFALSE 50224
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50198: LD_VAR 0 4
50202: PPUSH
50203: LD_VAR 0 6
50207: PPUSH
50208: LD_VAR 0 4
50212: PPUSH
50213: CALL_OW 74
50217: PPUSH
50218: CALL_OW 112
50222: GO 50248
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50224: LD_VAR 0 4
50228: PPUSH
50229: LD_VAR 0 6
50233: PPUSH
50234: LD_VAR 0 4
50238: PPUSH
50239: CALL_OW 74
50243: PPUSH
50244: CALL_OW 115
// end else
50248: GO 50350
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50250: LD_VAR 0 4
50254: PPUSH
50255: LD_VAR 0 2
50259: PUSH
50260: LD_VAR 0 9
50264: ARRAY
50265: PUSH
50266: LD_INT 1
50268: ARRAY
50269: PPUSH
50270: LD_VAR 0 2
50274: PUSH
50275: LD_VAR 0 9
50279: ARRAY
50280: PUSH
50281: LD_INT 2
50283: ARRAY
50284: PPUSH
50285: CALL_OW 297
50289: PUSH
50290: LD_INT 6
50292: GREATER
50293: IFFALSE 50336
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50295: LD_VAR 0 4
50299: PPUSH
50300: LD_VAR 0 2
50304: PUSH
50305: LD_VAR 0 9
50309: ARRAY
50310: PUSH
50311: LD_INT 1
50313: ARRAY
50314: PPUSH
50315: LD_VAR 0 2
50319: PUSH
50320: LD_VAR 0 9
50324: ARRAY
50325: PUSH
50326: LD_INT 2
50328: ARRAY
50329: PPUSH
50330: CALL_OW 114
50334: GO 50350
// SetTag ( i , tag ) ;
50336: LD_VAR 0 4
50340: PPUSH
50341: LD_VAR 0 9
50345: PPUSH
50346: CALL_OW 109
// end else
50350: GO 50423
// if enemy then
50352: LD_VAR 0 5
50356: IFFALSE 50423
// begin if GetWeapon ( i ) = ru_time_lapser then
50358: LD_VAR 0 4
50362: PPUSH
50363: CALL_OW 264
50367: PUSH
50368: LD_INT 49
50370: EQUAL
50371: IFFALSE 50399
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50373: LD_VAR 0 4
50377: PPUSH
50378: LD_VAR 0 5
50382: PPUSH
50383: LD_VAR 0 4
50387: PPUSH
50388: CALL_OW 74
50392: PPUSH
50393: CALL_OW 112
50397: GO 50423
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50399: LD_VAR 0 4
50403: PPUSH
50404: LD_VAR 0 5
50408: PPUSH
50409: LD_VAR 0 4
50413: PPUSH
50414: CALL_OW 74
50418: PPUSH
50419: CALL_OW 115
// end ; end ;
50423: GO 50003
50425: POP
50426: POP
// end ;
50427: LD_VAR 0 3
50431: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50432: LD_INT 0
50434: PPUSH
50435: PPUSH
50436: PPUSH
// if not unit or IsInUnit ( unit ) then
50437: LD_VAR 0 1
50441: NOT
50442: PUSH
50443: LD_VAR 0 1
50447: PPUSH
50448: CALL_OW 310
50452: OR
50453: IFFALSE 50457
// exit ;
50455: GO 50548
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50457: LD_ADDR_VAR 0 4
50461: PUSH
50462: LD_VAR 0 1
50466: PPUSH
50467: CALL_OW 250
50471: PPUSH
50472: LD_VAR 0 2
50476: PPUSH
50477: LD_INT 1
50479: PPUSH
50480: CALL_OW 272
50484: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50485: LD_ADDR_VAR 0 5
50489: PUSH
50490: LD_VAR 0 1
50494: PPUSH
50495: CALL_OW 251
50499: PPUSH
50500: LD_VAR 0 2
50504: PPUSH
50505: LD_INT 1
50507: PPUSH
50508: CALL_OW 273
50512: ST_TO_ADDR
// if ValidHex ( x , y ) then
50513: LD_VAR 0 4
50517: PPUSH
50518: LD_VAR 0 5
50522: PPUSH
50523: CALL_OW 488
50527: IFFALSE 50548
// ComTurnXY ( unit , x , y ) ;
50529: LD_VAR 0 1
50533: PPUSH
50534: LD_VAR 0 4
50538: PPUSH
50539: LD_VAR 0 5
50543: PPUSH
50544: CALL_OW 118
// end ;
50548: LD_VAR 0 3
50552: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50553: LD_INT 0
50555: PPUSH
50556: PPUSH
// result := false ;
50557: LD_ADDR_VAR 0 3
50561: PUSH
50562: LD_INT 0
50564: ST_TO_ADDR
// if not units then
50565: LD_VAR 0 2
50569: NOT
50570: IFFALSE 50574
// exit ;
50572: GO 50619
// for i in units do
50574: LD_ADDR_VAR 0 4
50578: PUSH
50579: LD_VAR 0 2
50583: PUSH
50584: FOR_IN
50585: IFFALSE 50617
// if See ( side , i ) then
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 4
50596: PPUSH
50597: CALL_OW 292
50601: IFFALSE 50615
// begin result := true ;
50603: LD_ADDR_VAR 0 3
50607: PUSH
50608: LD_INT 1
50610: ST_TO_ADDR
// exit ;
50611: POP
50612: POP
50613: GO 50619
// end ;
50615: GO 50584
50617: POP
50618: POP
// end ;
50619: LD_VAR 0 3
50623: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50624: LD_INT 0
50626: PPUSH
50627: PPUSH
50628: PPUSH
50629: PPUSH
// if not unit or not points then
50630: LD_VAR 0 1
50634: NOT
50635: PUSH
50636: LD_VAR 0 2
50640: NOT
50641: OR
50642: IFFALSE 50646
// exit ;
50644: GO 50736
// dist := 99999 ;
50646: LD_ADDR_VAR 0 5
50650: PUSH
50651: LD_INT 99999
50653: ST_TO_ADDR
// for i in points do
50654: LD_ADDR_VAR 0 4
50658: PUSH
50659: LD_VAR 0 2
50663: PUSH
50664: FOR_IN
50665: IFFALSE 50734
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50667: LD_ADDR_VAR 0 6
50671: PUSH
50672: LD_VAR 0 1
50676: PPUSH
50677: LD_VAR 0 4
50681: PUSH
50682: LD_INT 1
50684: ARRAY
50685: PPUSH
50686: LD_VAR 0 4
50690: PUSH
50691: LD_INT 2
50693: ARRAY
50694: PPUSH
50695: CALL_OW 297
50699: ST_TO_ADDR
// if tmpDist < dist then
50700: LD_VAR 0 6
50704: PUSH
50705: LD_VAR 0 5
50709: LESS
50710: IFFALSE 50732
// begin result := i ;
50712: LD_ADDR_VAR 0 3
50716: PUSH
50717: LD_VAR 0 4
50721: ST_TO_ADDR
// dist := tmpDist ;
50722: LD_ADDR_VAR 0 5
50726: PUSH
50727: LD_VAR 0 6
50731: ST_TO_ADDR
// end ; end ;
50732: GO 50664
50734: POP
50735: POP
// end ;
50736: LD_VAR 0 3
50740: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50741: LD_INT 0
50743: PPUSH
// uc_side := side ;
50744: LD_ADDR_OWVAR 20
50748: PUSH
50749: LD_VAR 0 1
50753: ST_TO_ADDR
// uc_nation := 3 ;
50754: LD_ADDR_OWVAR 21
50758: PUSH
50759: LD_INT 3
50761: ST_TO_ADDR
// vc_chassis := 25 ;
50762: LD_ADDR_OWVAR 37
50766: PUSH
50767: LD_INT 25
50769: ST_TO_ADDR
// vc_engine := engine_siberite ;
50770: LD_ADDR_OWVAR 39
50774: PUSH
50775: LD_INT 3
50777: ST_TO_ADDR
// vc_control := control_computer ;
50778: LD_ADDR_OWVAR 38
50782: PUSH
50783: LD_INT 3
50785: ST_TO_ADDR
// vc_weapon := 59 ;
50786: LD_ADDR_OWVAR 40
50790: PUSH
50791: LD_INT 59
50793: ST_TO_ADDR
// result := CreateVehicle ;
50794: LD_ADDR_VAR 0 5
50798: PUSH
50799: CALL_OW 45
50803: ST_TO_ADDR
// SetDir ( result , d ) ;
50804: LD_VAR 0 5
50808: PPUSH
50809: LD_VAR 0 4
50813: PPUSH
50814: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
50818: LD_VAR 0 5
50822: PPUSH
50823: LD_VAR 0 2
50827: PPUSH
50828: LD_VAR 0 3
50832: PPUSH
50833: LD_INT 0
50835: PPUSH
50836: CALL_OW 48
// end ;
50840: LD_VAR 0 5
50844: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50845: LD_INT 0
50847: PPUSH
50848: PPUSH
50849: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50850: LD_ADDR_VAR 0 2
50854: PUSH
50855: LD_INT 0
50857: PUSH
50858: LD_INT 0
50860: PUSH
50861: LD_INT 0
50863: PUSH
50864: LD_INT 0
50866: PUSH
50867: EMPTY
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50873: LD_VAR 0 1
50877: NOT
50878: PUSH
50879: LD_VAR 0 1
50883: PPUSH
50884: CALL_OW 264
50888: PUSH
50889: LD_INT 12
50891: PUSH
50892: LD_INT 51
50894: PUSH
50895: LD_INT 32
50897: PUSH
50898: LD_INT 89
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: LIST
50905: LIST
50906: IN
50907: NOT
50908: OR
50909: IFFALSE 50913
// exit ;
50911: GO 51011
// for i := 1 to 3 do
50913: LD_ADDR_VAR 0 3
50917: PUSH
50918: DOUBLE
50919: LD_INT 1
50921: DEC
50922: ST_TO_ADDR
50923: LD_INT 3
50925: PUSH
50926: FOR_TO
50927: IFFALSE 51009
// begin tmp := GetCargo ( cargo , i ) ;
50929: LD_ADDR_VAR 0 4
50933: PUSH
50934: LD_VAR 0 1
50938: PPUSH
50939: LD_VAR 0 3
50943: PPUSH
50944: CALL_OW 289
50948: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50949: LD_ADDR_VAR 0 2
50953: PUSH
50954: LD_VAR 0 2
50958: PPUSH
50959: LD_VAR 0 3
50963: PPUSH
50964: LD_VAR 0 4
50968: PPUSH
50969: CALL_OW 1
50973: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
50974: LD_ADDR_VAR 0 2
50978: PUSH
50979: LD_VAR 0 2
50983: PPUSH
50984: LD_INT 4
50986: PPUSH
50987: LD_VAR 0 2
50991: PUSH
50992: LD_INT 4
50994: ARRAY
50995: PUSH
50996: LD_VAR 0 4
51000: PLUS
51001: PPUSH
51002: CALL_OW 1
51006: ST_TO_ADDR
// end ;
51007: GO 50926
51009: POP
51010: POP
// end ;
51011: LD_VAR 0 2
51015: RET
// export function Length ( array ) ; begin
51016: LD_INT 0
51018: PPUSH
// result := array + 0 ;
51019: LD_ADDR_VAR 0 2
51023: PUSH
51024: LD_VAR 0 1
51028: PUSH
51029: LD_INT 0
51031: PLUS
51032: ST_TO_ADDR
// end ;
51033: LD_VAR 0 2
51037: RET
// export function PrepareArray ( array ) ; begin
51038: LD_INT 0
51040: PPUSH
// result := array diff 0 ;
51041: LD_ADDR_VAR 0 2
51045: PUSH
51046: LD_VAR 0 1
51050: PUSH
51051: LD_INT 0
51053: DIFF
51054: ST_TO_ADDR
// if not result [ 1 ] then
51055: LD_VAR 0 2
51059: PUSH
51060: LD_INT 1
51062: ARRAY
51063: NOT
51064: IFFALSE 51084
// result := Delete ( result , 1 ) ;
51066: LD_ADDR_VAR 0 2
51070: PUSH
51071: LD_VAR 0 2
51075: PPUSH
51076: LD_INT 1
51078: PPUSH
51079: CALL_OW 3
51083: ST_TO_ADDR
// end ;
51084: LD_VAR 0 2
51088: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
51089: LD_INT 0
51091: PPUSH
51092: PPUSH
51093: PPUSH
51094: PPUSH
// sibRocketRange := 25 ;
51095: LD_ADDR_VAR 0 6
51099: PUSH
51100: LD_INT 25
51102: ST_TO_ADDR
// result := false ;
51103: LD_ADDR_VAR 0 4
51107: PUSH
51108: LD_INT 0
51110: ST_TO_ADDR
// for i := 0 to 5 do
51111: LD_ADDR_VAR 0 5
51115: PUSH
51116: DOUBLE
51117: LD_INT 0
51119: DEC
51120: ST_TO_ADDR
51121: LD_INT 5
51123: PUSH
51124: FOR_TO
51125: IFFALSE 51192
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
51127: LD_VAR 0 1
51131: PPUSH
51132: LD_VAR 0 5
51136: PPUSH
51137: LD_VAR 0 6
51141: PPUSH
51142: CALL_OW 272
51146: PPUSH
51147: LD_VAR 0 2
51151: PPUSH
51152: LD_VAR 0 5
51156: PPUSH
51157: LD_VAR 0 6
51161: PPUSH
51162: CALL_OW 273
51166: PPUSH
51167: LD_VAR 0 3
51171: PPUSH
51172: CALL_OW 309
51176: IFFALSE 51190
// begin result := true ;
51178: LD_ADDR_VAR 0 4
51182: PUSH
51183: LD_INT 1
51185: ST_TO_ADDR
// exit ;
51186: POP
51187: POP
51188: GO 51194
// end ;
51190: GO 51124
51192: POP
51193: POP
// end ;
51194: LD_VAR 0 4
51198: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51199: LD_INT 0
51201: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51202: LD_VAR 0 1
51206: PPUSH
51207: LD_VAR 0 2
51211: PPUSH
51212: LD_INT 0
51214: PPUSH
51215: LD_INT 0
51217: PPUSH
51218: LD_INT 1
51220: PPUSH
51221: LD_INT 0
51223: PPUSH
51224: CALL_OW 587
// end ; end_of_file
51228: LD_VAR 0 3
51232: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
51233: LD_INT 0
51235: PPUSH
51236: PPUSH
// skirmish := false ;
51237: LD_ADDR_EXP 41
51241: PUSH
51242: LD_INT 0
51244: ST_TO_ADDR
// debug_mc := false ;
51245: LD_ADDR_EXP 42
51249: PUSH
51250: LD_INT 0
51252: ST_TO_ADDR
// mc_bases := [ ] ;
51253: LD_ADDR_EXP 43
51257: PUSH
51258: EMPTY
51259: ST_TO_ADDR
// mc_sides := [ ] ;
51260: LD_ADDR_EXP 69
51264: PUSH
51265: EMPTY
51266: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51267: LD_ADDR_EXP 44
51271: PUSH
51272: EMPTY
51273: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51274: LD_ADDR_EXP 45
51278: PUSH
51279: EMPTY
51280: ST_TO_ADDR
// mc_need_heal := [ ] ;
51281: LD_ADDR_EXP 46
51285: PUSH
51286: EMPTY
51287: ST_TO_ADDR
// mc_healers := [ ] ;
51288: LD_ADDR_EXP 47
51292: PUSH
51293: EMPTY
51294: ST_TO_ADDR
// mc_build_list := [ ] ;
51295: LD_ADDR_EXP 48
51299: PUSH
51300: EMPTY
51301: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51302: LD_ADDR_EXP 75
51306: PUSH
51307: EMPTY
51308: ST_TO_ADDR
// mc_builders := [ ] ;
51309: LD_ADDR_EXP 49
51313: PUSH
51314: EMPTY
51315: ST_TO_ADDR
// mc_construct_list := [ ] ;
51316: LD_ADDR_EXP 50
51320: PUSH
51321: EMPTY
51322: ST_TO_ADDR
// mc_turret_list := [ ] ;
51323: LD_ADDR_EXP 51
51327: PUSH
51328: EMPTY
51329: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51330: LD_ADDR_EXP 52
51334: PUSH
51335: EMPTY
51336: ST_TO_ADDR
// mc_miners := [ ] ;
51337: LD_ADDR_EXP 57
51341: PUSH
51342: EMPTY
51343: ST_TO_ADDR
// mc_mines := [ ] ;
51344: LD_ADDR_EXP 56
51348: PUSH
51349: EMPTY
51350: ST_TO_ADDR
// mc_minefields := [ ] ;
51351: LD_ADDR_EXP 58
51355: PUSH
51356: EMPTY
51357: ST_TO_ADDR
// mc_crates := [ ] ;
51358: LD_ADDR_EXP 59
51362: PUSH
51363: EMPTY
51364: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51365: LD_ADDR_EXP 60
51369: PUSH
51370: EMPTY
51371: ST_TO_ADDR
// mc_crates_area := [ ] ;
51372: LD_ADDR_EXP 61
51376: PUSH
51377: EMPTY
51378: ST_TO_ADDR
// mc_vehicles := [ ] ;
51379: LD_ADDR_EXP 62
51383: PUSH
51384: EMPTY
51385: ST_TO_ADDR
// mc_attack := [ ] ;
51386: LD_ADDR_EXP 63
51390: PUSH
51391: EMPTY
51392: ST_TO_ADDR
// mc_produce := [ ] ;
51393: LD_ADDR_EXP 64
51397: PUSH
51398: EMPTY
51399: ST_TO_ADDR
// mc_defender := [ ] ;
51400: LD_ADDR_EXP 65
51404: PUSH
51405: EMPTY
51406: ST_TO_ADDR
// mc_parking := [ ] ;
51407: LD_ADDR_EXP 67
51411: PUSH
51412: EMPTY
51413: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51414: LD_ADDR_EXP 53
51418: PUSH
51419: EMPTY
51420: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51421: LD_ADDR_EXP 55
51425: PUSH
51426: EMPTY
51427: ST_TO_ADDR
// mc_scan := [ ] ;
51428: LD_ADDR_EXP 66
51432: PUSH
51433: EMPTY
51434: ST_TO_ADDR
// mc_scan_area := [ ] ;
51435: LD_ADDR_EXP 68
51439: PUSH
51440: EMPTY
51441: ST_TO_ADDR
// mc_tech := [ ] ;
51442: LD_ADDR_EXP 70
51446: PUSH
51447: EMPTY
51448: ST_TO_ADDR
// mc_class := [ ] ;
51449: LD_ADDR_EXP 84
51453: PUSH
51454: EMPTY
51455: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51456: LD_ADDR_EXP 85
51460: PUSH
51461: EMPTY
51462: ST_TO_ADDR
// mc_is_defending := [ ] ;
51463: LD_ADDR_EXP 86
51467: PUSH
51468: EMPTY
51469: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51470: LD_ADDR_EXP 77
51474: PUSH
51475: EMPTY
51476: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
51477: LD_ADDR_EXP 87
51481: PUSH
51482: LD_INT 0
51484: ST_TO_ADDR
// end ;
51485: LD_VAR 0 1
51489: RET
// export function MC_Kill ( base ) ; begin
51490: LD_INT 0
51492: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51493: LD_ADDR_EXP 43
51497: PUSH
51498: LD_EXP 43
51502: PPUSH
51503: LD_VAR 0 1
51507: PPUSH
51508: EMPTY
51509: PPUSH
51510: CALL_OW 1
51514: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51515: LD_ADDR_EXP 44
51519: PUSH
51520: LD_EXP 44
51524: PPUSH
51525: LD_VAR 0 1
51529: PPUSH
51530: EMPTY
51531: PPUSH
51532: CALL_OW 1
51536: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51537: LD_ADDR_EXP 45
51541: PUSH
51542: LD_EXP 45
51546: PPUSH
51547: LD_VAR 0 1
51551: PPUSH
51552: EMPTY
51553: PPUSH
51554: CALL_OW 1
51558: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51559: LD_ADDR_EXP 46
51563: PUSH
51564: LD_EXP 46
51568: PPUSH
51569: LD_VAR 0 1
51573: PPUSH
51574: EMPTY
51575: PPUSH
51576: CALL_OW 1
51580: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51581: LD_ADDR_EXP 47
51585: PUSH
51586: LD_EXP 47
51590: PPUSH
51591: LD_VAR 0 1
51595: PPUSH
51596: EMPTY
51597: PPUSH
51598: CALL_OW 1
51602: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51603: LD_ADDR_EXP 48
51607: PUSH
51608: LD_EXP 48
51612: PPUSH
51613: LD_VAR 0 1
51617: PPUSH
51618: EMPTY
51619: PPUSH
51620: CALL_OW 1
51624: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51625: LD_ADDR_EXP 49
51629: PUSH
51630: LD_EXP 49
51634: PPUSH
51635: LD_VAR 0 1
51639: PPUSH
51640: EMPTY
51641: PPUSH
51642: CALL_OW 1
51646: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51647: LD_ADDR_EXP 50
51651: PUSH
51652: LD_EXP 50
51656: PPUSH
51657: LD_VAR 0 1
51661: PPUSH
51662: EMPTY
51663: PPUSH
51664: CALL_OW 1
51668: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51669: LD_ADDR_EXP 51
51673: PUSH
51674: LD_EXP 51
51678: PPUSH
51679: LD_VAR 0 1
51683: PPUSH
51684: EMPTY
51685: PPUSH
51686: CALL_OW 1
51690: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51691: LD_ADDR_EXP 52
51695: PUSH
51696: LD_EXP 52
51700: PPUSH
51701: LD_VAR 0 1
51705: PPUSH
51706: EMPTY
51707: PPUSH
51708: CALL_OW 1
51712: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51713: LD_ADDR_EXP 53
51717: PUSH
51718: LD_EXP 53
51722: PPUSH
51723: LD_VAR 0 1
51727: PPUSH
51728: EMPTY
51729: PPUSH
51730: CALL_OW 1
51734: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51735: LD_ADDR_EXP 54
51739: PUSH
51740: LD_EXP 54
51744: PPUSH
51745: LD_VAR 0 1
51749: PPUSH
51750: LD_INT 0
51752: PPUSH
51753: CALL_OW 1
51757: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51758: LD_ADDR_EXP 55
51762: PUSH
51763: LD_EXP 55
51767: PPUSH
51768: LD_VAR 0 1
51772: PPUSH
51773: EMPTY
51774: PPUSH
51775: CALL_OW 1
51779: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51780: LD_ADDR_EXP 56
51784: PUSH
51785: LD_EXP 56
51789: PPUSH
51790: LD_VAR 0 1
51794: PPUSH
51795: EMPTY
51796: PPUSH
51797: CALL_OW 1
51801: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51802: LD_ADDR_EXP 57
51806: PUSH
51807: LD_EXP 57
51811: PPUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: EMPTY
51818: PPUSH
51819: CALL_OW 1
51823: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51824: LD_ADDR_EXP 58
51828: PUSH
51829: LD_EXP 58
51833: PPUSH
51834: LD_VAR 0 1
51838: PPUSH
51839: EMPTY
51840: PPUSH
51841: CALL_OW 1
51845: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51846: LD_ADDR_EXP 59
51850: PUSH
51851: LD_EXP 59
51855: PPUSH
51856: LD_VAR 0 1
51860: PPUSH
51861: EMPTY
51862: PPUSH
51863: CALL_OW 1
51867: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51868: LD_ADDR_EXP 60
51872: PUSH
51873: LD_EXP 60
51877: PPUSH
51878: LD_VAR 0 1
51882: PPUSH
51883: EMPTY
51884: PPUSH
51885: CALL_OW 1
51889: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51890: LD_ADDR_EXP 61
51894: PUSH
51895: LD_EXP 61
51899: PPUSH
51900: LD_VAR 0 1
51904: PPUSH
51905: EMPTY
51906: PPUSH
51907: CALL_OW 1
51911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51912: LD_ADDR_EXP 62
51916: PUSH
51917: LD_EXP 62
51921: PPUSH
51922: LD_VAR 0 1
51926: PPUSH
51927: EMPTY
51928: PPUSH
51929: CALL_OW 1
51933: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51934: LD_ADDR_EXP 63
51938: PUSH
51939: LD_EXP 63
51943: PPUSH
51944: LD_VAR 0 1
51948: PPUSH
51949: EMPTY
51950: PPUSH
51951: CALL_OW 1
51955: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51956: LD_ADDR_EXP 64
51960: PUSH
51961: LD_EXP 64
51965: PPUSH
51966: LD_VAR 0 1
51970: PPUSH
51971: EMPTY
51972: PPUSH
51973: CALL_OW 1
51977: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51978: LD_ADDR_EXP 65
51982: PUSH
51983: LD_EXP 65
51987: PPUSH
51988: LD_VAR 0 1
51992: PPUSH
51993: EMPTY
51994: PPUSH
51995: CALL_OW 1
51999: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52000: LD_ADDR_EXP 66
52004: PUSH
52005: LD_EXP 66
52009: PPUSH
52010: LD_VAR 0 1
52014: PPUSH
52015: EMPTY
52016: PPUSH
52017: CALL_OW 1
52021: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52022: LD_ADDR_EXP 67
52026: PUSH
52027: LD_EXP 67
52031: PPUSH
52032: LD_VAR 0 1
52036: PPUSH
52037: EMPTY
52038: PPUSH
52039: CALL_OW 1
52043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52044: LD_ADDR_EXP 68
52048: PUSH
52049: LD_EXP 68
52053: PPUSH
52054: LD_VAR 0 1
52058: PPUSH
52059: EMPTY
52060: PPUSH
52061: CALL_OW 1
52065: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52066: LD_ADDR_EXP 70
52070: PUSH
52071: LD_EXP 70
52075: PPUSH
52076: LD_VAR 0 1
52080: PPUSH
52081: EMPTY
52082: PPUSH
52083: CALL_OW 1
52087: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52088: LD_ADDR_EXP 72
52092: PUSH
52093: LD_EXP 72
52097: PPUSH
52098: LD_VAR 0 1
52102: PPUSH
52103: EMPTY
52104: PPUSH
52105: CALL_OW 1
52109: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52110: LD_ADDR_EXP 73
52114: PUSH
52115: LD_EXP 73
52119: PPUSH
52120: LD_VAR 0 1
52124: PPUSH
52125: EMPTY
52126: PPUSH
52127: CALL_OW 1
52131: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52132: LD_ADDR_EXP 74
52136: PUSH
52137: LD_EXP 74
52141: PPUSH
52142: LD_VAR 0 1
52146: PPUSH
52147: EMPTY
52148: PPUSH
52149: CALL_OW 1
52153: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52154: LD_ADDR_EXP 75
52158: PUSH
52159: LD_EXP 75
52163: PPUSH
52164: LD_VAR 0 1
52168: PPUSH
52169: EMPTY
52170: PPUSH
52171: CALL_OW 1
52175: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52176: LD_ADDR_EXP 76
52180: PUSH
52181: LD_EXP 76
52185: PPUSH
52186: LD_VAR 0 1
52190: PPUSH
52191: EMPTY
52192: PPUSH
52193: CALL_OW 1
52197: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52198: LD_ADDR_EXP 77
52202: PUSH
52203: LD_EXP 77
52207: PPUSH
52208: LD_VAR 0 1
52212: PPUSH
52213: EMPTY
52214: PPUSH
52215: CALL_OW 1
52219: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52220: LD_ADDR_EXP 78
52224: PUSH
52225: LD_EXP 78
52229: PPUSH
52230: LD_VAR 0 1
52234: PPUSH
52235: EMPTY
52236: PPUSH
52237: CALL_OW 1
52241: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52242: LD_ADDR_EXP 79
52246: PUSH
52247: LD_EXP 79
52251: PPUSH
52252: LD_VAR 0 1
52256: PPUSH
52257: EMPTY
52258: PPUSH
52259: CALL_OW 1
52263: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52264: LD_ADDR_EXP 80
52268: PUSH
52269: LD_EXP 80
52273: PPUSH
52274: LD_VAR 0 1
52278: PPUSH
52279: EMPTY
52280: PPUSH
52281: CALL_OW 1
52285: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52286: LD_ADDR_EXP 81
52290: PUSH
52291: LD_EXP 81
52295: PPUSH
52296: LD_VAR 0 1
52300: PPUSH
52301: EMPTY
52302: PPUSH
52303: CALL_OW 1
52307: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52308: LD_ADDR_EXP 82
52312: PUSH
52313: LD_EXP 82
52317: PPUSH
52318: LD_VAR 0 1
52322: PPUSH
52323: EMPTY
52324: PPUSH
52325: CALL_OW 1
52329: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52330: LD_ADDR_EXP 83
52334: PUSH
52335: LD_EXP 83
52339: PPUSH
52340: LD_VAR 0 1
52344: PPUSH
52345: EMPTY
52346: PPUSH
52347: CALL_OW 1
52351: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52352: LD_ADDR_EXP 84
52356: PUSH
52357: LD_EXP 84
52361: PPUSH
52362: LD_VAR 0 1
52366: PPUSH
52367: EMPTY
52368: PPUSH
52369: CALL_OW 1
52373: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52374: LD_ADDR_EXP 85
52378: PUSH
52379: LD_EXP 85
52383: PPUSH
52384: LD_VAR 0 1
52388: PPUSH
52389: LD_INT 0
52391: PPUSH
52392: CALL_OW 1
52396: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52397: LD_ADDR_EXP 86
52401: PUSH
52402: LD_EXP 86
52406: PPUSH
52407: LD_VAR 0 1
52411: PPUSH
52412: LD_INT 0
52414: PPUSH
52415: CALL_OW 1
52419: ST_TO_ADDR
// end ;
52420: LD_VAR 0 2
52424: RET
// export function MC_Add ( side , units ) ; var base ; begin
52425: LD_INT 0
52427: PPUSH
52428: PPUSH
// base := mc_bases + 1 ;
52429: LD_ADDR_VAR 0 4
52433: PUSH
52434: LD_EXP 43
52438: PUSH
52439: LD_INT 1
52441: PLUS
52442: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52443: LD_ADDR_EXP 69
52447: PUSH
52448: LD_EXP 69
52452: PPUSH
52453: LD_VAR 0 4
52457: PPUSH
52458: LD_VAR 0 1
52462: PPUSH
52463: CALL_OW 1
52467: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52468: LD_ADDR_EXP 43
52472: PUSH
52473: LD_EXP 43
52477: PPUSH
52478: LD_VAR 0 4
52482: PPUSH
52483: LD_VAR 0 2
52487: PPUSH
52488: CALL_OW 1
52492: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52493: LD_ADDR_EXP 44
52497: PUSH
52498: LD_EXP 44
52502: PPUSH
52503: LD_VAR 0 4
52507: PPUSH
52508: EMPTY
52509: PPUSH
52510: CALL_OW 1
52514: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52515: LD_ADDR_EXP 45
52519: PUSH
52520: LD_EXP 45
52524: PPUSH
52525: LD_VAR 0 4
52529: PPUSH
52530: EMPTY
52531: PPUSH
52532: CALL_OW 1
52536: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52537: LD_ADDR_EXP 46
52541: PUSH
52542: LD_EXP 46
52546: PPUSH
52547: LD_VAR 0 4
52551: PPUSH
52552: EMPTY
52553: PPUSH
52554: CALL_OW 1
52558: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52559: LD_ADDR_EXP 47
52563: PUSH
52564: LD_EXP 47
52568: PPUSH
52569: LD_VAR 0 4
52573: PPUSH
52574: EMPTY
52575: PPUSH
52576: CALL_OW 1
52580: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52581: LD_ADDR_EXP 48
52585: PUSH
52586: LD_EXP 48
52590: PPUSH
52591: LD_VAR 0 4
52595: PPUSH
52596: EMPTY
52597: PPUSH
52598: CALL_OW 1
52602: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52603: LD_ADDR_EXP 49
52607: PUSH
52608: LD_EXP 49
52612: PPUSH
52613: LD_VAR 0 4
52617: PPUSH
52618: EMPTY
52619: PPUSH
52620: CALL_OW 1
52624: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52625: LD_ADDR_EXP 50
52629: PUSH
52630: LD_EXP 50
52634: PPUSH
52635: LD_VAR 0 4
52639: PPUSH
52640: EMPTY
52641: PPUSH
52642: CALL_OW 1
52646: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52647: LD_ADDR_EXP 51
52651: PUSH
52652: LD_EXP 51
52656: PPUSH
52657: LD_VAR 0 4
52661: PPUSH
52662: EMPTY
52663: PPUSH
52664: CALL_OW 1
52668: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52669: LD_ADDR_EXP 52
52673: PUSH
52674: LD_EXP 52
52678: PPUSH
52679: LD_VAR 0 4
52683: PPUSH
52684: EMPTY
52685: PPUSH
52686: CALL_OW 1
52690: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52691: LD_ADDR_EXP 53
52695: PUSH
52696: LD_EXP 53
52700: PPUSH
52701: LD_VAR 0 4
52705: PPUSH
52706: EMPTY
52707: PPUSH
52708: CALL_OW 1
52712: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52713: LD_ADDR_EXP 54
52717: PUSH
52718: LD_EXP 54
52722: PPUSH
52723: LD_VAR 0 4
52727: PPUSH
52728: LD_INT 0
52730: PPUSH
52731: CALL_OW 1
52735: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52736: LD_ADDR_EXP 55
52740: PUSH
52741: LD_EXP 55
52745: PPUSH
52746: LD_VAR 0 4
52750: PPUSH
52751: EMPTY
52752: PPUSH
52753: CALL_OW 1
52757: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52758: LD_ADDR_EXP 56
52762: PUSH
52763: LD_EXP 56
52767: PPUSH
52768: LD_VAR 0 4
52772: PPUSH
52773: EMPTY
52774: PPUSH
52775: CALL_OW 1
52779: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52780: LD_ADDR_EXP 57
52784: PUSH
52785: LD_EXP 57
52789: PPUSH
52790: LD_VAR 0 4
52794: PPUSH
52795: EMPTY
52796: PPUSH
52797: CALL_OW 1
52801: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52802: LD_ADDR_EXP 58
52806: PUSH
52807: LD_EXP 58
52811: PPUSH
52812: LD_VAR 0 4
52816: PPUSH
52817: EMPTY
52818: PPUSH
52819: CALL_OW 1
52823: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52824: LD_ADDR_EXP 59
52828: PUSH
52829: LD_EXP 59
52833: PPUSH
52834: LD_VAR 0 4
52838: PPUSH
52839: EMPTY
52840: PPUSH
52841: CALL_OW 1
52845: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52846: LD_ADDR_EXP 60
52850: PUSH
52851: LD_EXP 60
52855: PPUSH
52856: LD_VAR 0 4
52860: PPUSH
52861: EMPTY
52862: PPUSH
52863: CALL_OW 1
52867: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52868: LD_ADDR_EXP 61
52872: PUSH
52873: LD_EXP 61
52877: PPUSH
52878: LD_VAR 0 4
52882: PPUSH
52883: EMPTY
52884: PPUSH
52885: CALL_OW 1
52889: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52890: LD_ADDR_EXP 62
52894: PUSH
52895: LD_EXP 62
52899: PPUSH
52900: LD_VAR 0 4
52904: PPUSH
52905: EMPTY
52906: PPUSH
52907: CALL_OW 1
52911: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52912: LD_ADDR_EXP 63
52916: PUSH
52917: LD_EXP 63
52921: PPUSH
52922: LD_VAR 0 4
52926: PPUSH
52927: EMPTY
52928: PPUSH
52929: CALL_OW 1
52933: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52934: LD_ADDR_EXP 64
52938: PUSH
52939: LD_EXP 64
52943: PPUSH
52944: LD_VAR 0 4
52948: PPUSH
52949: EMPTY
52950: PPUSH
52951: CALL_OW 1
52955: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52956: LD_ADDR_EXP 65
52960: PUSH
52961: LD_EXP 65
52965: PPUSH
52966: LD_VAR 0 4
52970: PPUSH
52971: EMPTY
52972: PPUSH
52973: CALL_OW 1
52977: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52978: LD_ADDR_EXP 66
52982: PUSH
52983: LD_EXP 66
52987: PPUSH
52988: LD_VAR 0 4
52992: PPUSH
52993: EMPTY
52994: PPUSH
52995: CALL_OW 1
52999: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53000: LD_ADDR_EXP 67
53004: PUSH
53005: LD_EXP 67
53009: PPUSH
53010: LD_VAR 0 4
53014: PPUSH
53015: EMPTY
53016: PPUSH
53017: CALL_OW 1
53021: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53022: LD_ADDR_EXP 68
53026: PUSH
53027: LD_EXP 68
53031: PPUSH
53032: LD_VAR 0 4
53036: PPUSH
53037: EMPTY
53038: PPUSH
53039: CALL_OW 1
53043: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53044: LD_ADDR_EXP 70
53048: PUSH
53049: LD_EXP 70
53053: PPUSH
53054: LD_VAR 0 4
53058: PPUSH
53059: EMPTY
53060: PPUSH
53061: CALL_OW 1
53065: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53066: LD_ADDR_EXP 72
53070: PUSH
53071: LD_EXP 72
53075: PPUSH
53076: LD_VAR 0 4
53080: PPUSH
53081: EMPTY
53082: PPUSH
53083: CALL_OW 1
53087: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53088: LD_ADDR_EXP 73
53092: PUSH
53093: LD_EXP 73
53097: PPUSH
53098: LD_VAR 0 4
53102: PPUSH
53103: EMPTY
53104: PPUSH
53105: CALL_OW 1
53109: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53110: LD_ADDR_EXP 74
53114: PUSH
53115: LD_EXP 74
53119: PPUSH
53120: LD_VAR 0 4
53124: PPUSH
53125: EMPTY
53126: PPUSH
53127: CALL_OW 1
53131: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53132: LD_ADDR_EXP 75
53136: PUSH
53137: LD_EXP 75
53141: PPUSH
53142: LD_VAR 0 4
53146: PPUSH
53147: EMPTY
53148: PPUSH
53149: CALL_OW 1
53153: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53154: LD_ADDR_EXP 76
53158: PUSH
53159: LD_EXP 76
53163: PPUSH
53164: LD_VAR 0 4
53168: PPUSH
53169: EMPTY
53170: PPUSH
53171: CALL_OW 1
53175: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53176: LD_ADDR_EXP 77
53180: PUSH
53181: LD_EXP 77
53185: PPUSH
53186: LD_VAR 0 4
53190: PPUSH
53191: EMPTY
53192: PPUSH
53193: CALL_OW 1
53197: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53198: LD_ADDR_EXP 78
53202: PUSH
53203: LD_EXP 78
53207: PPUSH
53208: LD_VAR 0 4
53212: PPUSH
53213: EMPTY
53214: PPUSH
53215: CALL_OW 1
53219: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53220: LD_ADDR_EXP 79
53224: PUSH
53225: LD_EXP 79
53229: PPUSH
53230: LD_VAR 0 4
53234: PPUSH
53235: EMPTY
53236: PPUSH
53237: CALL_OW 1
53241: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53242: LD_ADDR_EXP 80
53246: PUSH
53247: LD_EXP 80
53251: PPUSH
53252: LD_VAR 0 4
53256: PPUSH
53257: EMPTY
53258: PPUSH
53259: CALL_OW 1
53263: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53264: LD_ADDR_EXP 81
53268: PUSH
53269: LD_EXP 81
53273: PPUSH
53274: LD_VAR 0 4
53278: PPUSH
53279: EMPTY
53280: PPUSH
53281: CALL_OW 1
53285: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53286: LD_ADDR_EXP 82
53290: PUSH
53291: LD_EXP 82
53295: PPUSH
53296: LD_VAR 0 4
53300: PPUSH
53301: EMPTY
53302: PPUSH
53303: CALL_OW 1
53307: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53308: LD_ADDR_EXP 83
53312: PUSH
53313: LD_EXP 83
53317: PPUSH
53318: LD_VAR 0 4
53322: PPUSH
53323: EMPTY
53324: PPUSH
53325: CALL_OW 1
53329: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53330: LD_ADDR_EXP 84
53334: PUSH
53335: LD_EXP 84
53339: PPUSH
53340: LD_VAR 0 4
53344: PPUSH
53345: EMPTY
53346: PPUSH
53347: CALL_OW 1
53351: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53352: LD_ADDR_EXP 85
53356: PUSH
53357: LD_EXP 85
53361: PPUSH
53362: LD_VAR 0 4
53366: PPUSH
53367: LD_INT 0
53369: PPUSH
53370: CALL_OW 1
53374: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53375: LD_ADDR_EXP 86
53379: PUSH
53380: LD_EXP 86
53384: PPUSH
53385: LD_VAR 0 4
53389: PPUSH
53390: LD_INT 0
53392: PPUSH
53393: CALL_OW 1
53397: ST_TO_ADDR
// result := base ;
53398: LD_ADDR_VAR 0 3
53402: PUSH
53403: LD_VAR 0 4
53407: ST_TO_ADDR
// end ;
53408: LD_VAR 0 3
53412: RET
// export function MC_Start ( ) ; var i ; begin
53413: LD_INT 0
53415: PPUSH
53416: PPUSH
// for i = 1 to mc_bases do
53417: LD_ADDR_VAR 0 2
53421: PUSH
53422: DOUBLE
53423: LD_INT 1
53425: DEC
53426: ST_TO_ADDR
53427: LD_EXP 43
53431: PUSH
53432: FOR_TO
53433: IFFALSE 54533
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53435: LD_ADDR_EXP 43
53439: PUSH
53440: LD_EXP 43
53444: PPUSH
53445: LD_VAR 0 2
53449: PPUSH
53450: LD_EXP 43
53454: PUSH
53455: LD_VAR 0 2
53459: ARRAY
53460: PUSH
53461: LD_INT 0
53463: DIFF
53464: PPUSH
53465: CALL_OW 1
53469: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53470: LD_ADDR_EXP 44
53474: PUSH
53475: LD_EXP 44
53479: PPUSH
53480: LD_VAR 0 2
53484: PPUSH
53485: EMPTY
53486: PPUSH
53487: CALL_OW 1
53491: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53492: LD_ADDR_EXP 45
53496: PUSH
53497: LD_EXP 45
53501: PPUSH
53502: LD_VAR 0 2
53506: PPUSH
53507: EMPTY
53508: PPUSH
53509: CALL_OW 1
53513: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53514: LD_ADDR_EXP 46
53518: PUSH
53519: LD_EXP 46
53523: PPUSH
53524: LD_VAR 0 2
53528: PPUSH
53529: EMPTY
53530: PPUSH
53531: CALL_OW 1
53535: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53536: LD_ADDR_EXP 47
53540: PUSH
53541: LD_EXP 47
53545: PPUSH
53546: LD_VAR 0 2
53550: PPUSH
53551: EMPTY
53552: PUSH
53553: EMPTY
53554: PUSH
53555: EMPTY
53556: LIST
53557: LIST
53558: PPUSH
53559: CALL_OW 1
53563: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53564: LD_ADDR_EXP 48
53568: PUSH
53569: LD_EXP 48
53573: PPUSH
53574: LD_VAR 0 2
53578: PPUSH
53579: EMPTY
53580: PPUSH
53581: CALL_OW 1
53585: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53586: LD_ADDR_EXP 75
53590: PUSH
53591: LD_EXP 75
53595: PPUSH
53596: LD_VAR 0 2
53600: PPUSH
53601: EMPTY
53602: PPUSH
53603: CALL_OW 1
53607: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53608: LD_ADDR_EXP 49
53612: PUSH
53613: LD_EXP 49
53617: PPUSH
53618: LD_VAR 0 2
53622: PPUSH
53623: EMPTY
53624: PPUSH
53625: CALL_OW 1
53629: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53630: LD_ADDR_EXP 50
53634: PUSH
53635: LD_EXP 50
53639: PPUSH
53640: LD_VAR 0 2
53644: PPUSH
53645: EMPTY
53646: PPUSH
53647: CALL_OW 1
53651: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53652: LD_ADDR_EXP 51
53656: PUSH
53657: LD_EXP 51
53661: PPUSH
53662: LD_VAR 0 2
53666: PPUSH
53667: LD_EXP 43
53671: PUSH
53672: LD_VAR 0 2
53676: ARRAY
53677: PPUSH
53678: LD_INT 2
53680: PUSH
53681: LD_INT 30
53683: PUSH
53684: LD_INT 32
53686: PUSH
53687: EMPTY
53688: LIST
53689: LIST
53690: PUSH
53691: LD_INT 30
53693: PUSH
53694: LD_INT 33
53696: PUSH
53697: EMPTY
53698: LIST
53699: LIST
53700: PUSH
53701: EMPTY
53702: LIST
53703: LIST
53704: LIST
53705: PPUSH
53706: CALL_OW 72
53710: PPUSH
53711: CALL_OW 1
53715: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53716: LD_ADDR_EXP 52
53720: PUSH
53721: LD_EXP 52
53725: PPUSH
53726: LD_VAR 0 2
53730: PPUSH
53731: LD_EXP 43
53735: PUSH
53736: LD_VAR 0 2
53740: ARRAY
53741: PPUSH
53742: LD_INT 2
53744: PUSH
53745: LD_INT 30
53747: PUSH
53748: LD_INT 32
53750: PUSH
53751: EMPTY
53752: LIST
53753: LIST
53754: PUSH
53755: LD_INT 30
53757: PUSH
53758: LD_INT 31
53760: PUSH
53761: EMPTY
53762: LIST
53763: LIST
53764: PUSH
53765: EMPTY
53766: LIST
53767: LIST
53768: LIST
53769: PUSH
53770: LD_INT 58
53772: PUSH
53773: EMPTY
53774: LIST
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PPUSH
53780: CALL_OW 72
53784: PPUSH
53785: CALL_OW 1
53789: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53790: LD_ADDR_EXP 53
53794: PUSH
53795: LD_EXP 53
53799: PPUSH
53800: LD_VAR 0 2
53804: PPUSH
53805: EMPTY
53806: PPUSH
53807: CALL_OW 1
53811: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53812: LD_ADDR_EXP 57
53816: PUSH
53817: LD_EXP 57
53821: PPUSH
53822: LD_VAR 0 2
53826: PPUSH
53827: EMPTY
53828: PPUSH
53829: CALL_OW 1
53833: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53834: LD_ADDR_EXP 56
53838: PUSH
53839: LD_EXP 56
53843: PPUSH
53844: LD_VAR 0 2
53848: PPUSH
53849: EMPTY
53850: PPUSH
53851: CALL_OW 1
53855: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53856: LD_ADDR_EXP 58
53860: PUSH
53861: LD_EXP 58
53865: PPUSH
53866: LD_VAR 0 2
53870: PPUSH
53871: EMPTY
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53878: LD_ADDR_EXP 59
53882: PUSH
53883: LD_EXP 59
53887: PPUSH
53888: LD_VAR 0 2
53892: PPUSH
53893: EMPTY
53894: PPUSH
53895: CALL_OW 1
53899: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53900: LD_ADDR_EXP 60
53904: PUSH
53905: LD_EXP 60
53909: PPUSH
53910: LD_VAR 0 2
53914: PPUSH
53915: EMPTY
53916: PPUSH
53917: CALL_OW 1
53921: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53922: LD_ADDR_EXP 61
53926: PUSH
53927: LD_EXP 61
53931: PPUSH
53932: LD_VAR 0 2
53936: PPUSH
53937: EMPTY
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53944: LD_ADDR_EXP 62
53948: PUSH
53949: LD_EXP 62
53953: PPUSH
53954: LD_VAR 0 2
53958: PPUSH
53959: EMPTY
53960: PPUSH
53961: CALL_OW 1
53965: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53966: LD_ADDR_EXP 63
53970: PUSH
53971: LD_EXP 63
53975: PPUSH
53976: LD_VAR 0 2
53980: PPUSH
53981: EMPTY
53982: PPUSH
53983: CALL_OW 1
53987: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53988: LD_ADDR_EXP 64
53992: PUSH
53993: LD_EXP 64
53997: PPUSH
53998: LD_VAR 0 2
54002: PPUSH
54003: EMPTY
54004: PPUSH
54005: CALL_OW 1
54009: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54010: LD_ADDR_EXP 65
54014: PUSH
54015: LD_EXP 65
54019: PPUSH
54020: LD_VAR 0 2
54024: PPUSH
54025: EMPTY
54026: PPUSH
54027: CALL_OW 1
54031: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54032: LD_ADDR_EXP 54
54036: PUSH
54037: LD_EXP 54
54041: PPUSH
54042: LD_VAR 0 2
54046: PPUSH
54047: LD_INT 0
54049: PPUSH
54050: CALL_OW 1
54054: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54055: LD_ADDR_EXP 67
54059: PUSH
54060: LD_EXP 67
54064: PPUSH
54065: LD_VAR 0 2
54069: PPUSH
54070: LD_INT 0
54072: PPUSH
54073: CALL_OW 1
54077: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54078: LD_ADDR_EXP 55
54082: PUSH
54083: LD_EXP 55
54087: PPUSH
54088: LD_VAR 0 2
54092: PPUSH
54093: EMPTY
54094: PPUSH
54095: CALL_OW 1
54099: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54100: LD_ADDR_EXP 66
54104: PUSH
54105: LD_EXP 66
54109: PPUSH
54110: LD_VAR 0 2
54114: PPUSH
54115: LD_INT 0
54117: PPUSH
54118: CALL_OW 1
54122: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54123: LD_ADDR_EXP 68
54127: PUSH
54128: LD_EXP 68
54132: PPUSH
54133: LD_VAR 0 2
54137: PPUSH
54138: EMPTY
54139: PPUSH
54140: CALL_OW 1
54144: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54145: LD_ADDR_EXP 71
54149: PUSH
54150: LD_EXP 71
54154: PPUSH
54155: LD_VAR 0 2
54159: PPUSH
54160: LD_INT 0
54162: PPUSH
54163: CALL_OW 1
54167: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54168: LD_ADDR_EXP 72
54172: PUSH
54173: LD_EXP 72
54177: PPUSH
54178: LD_VAR 0 2
54182: PPUSH
54183: EMPTY
54184: PPUSH
54185: CALL_OW 1
54189: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54190: LD_ADDR_EXP 73
54194: PUSH
54195: LD_EXP 73
54199: PPUSH
54200: LD_VAR 0 2
54204: PPUSH
54205: EMPTY
54206: PPUSH
54207: CALL_OW 1
54211: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54212: LD_ADDR_EXP 74
54216: PUSH
54217: LD_EXP 74
54221: PPUSH
54222: LD_VAR 0 2
54226: PPUSH
54227: EMPTY
54228: PPUSH
54229: CALL_OW 1
54233: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54234: LD_ADDR_EXP 76
54238: PUSH
54239: LD_EXP 76
54243: PPUSH
54244: LD_VAR 0 2
54248: PPUSH
54249: LD_EXP 43
54253: PUSH
54254: LD_VAR 0 2
54258: ARRAY
54259: PPUSH
54260: LD_INT 2
54262: PUSH
54263: LD_INT 30
54265: PUSH
54266: LD_INT 6
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: PUSH
54273: LD_INT 30
54275: PUSH
54276: LD_INT 7
54278: PUSH
54279: EMPTY
54280: LIST
54281: LIST
54282: PUSH
54283: LD_INT 30
54285: PUSH
54286: LD_INT 8
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: LIST
54298: PPUSH
54299: CALL_OW 72
54303: PPUSH
54304: CALL_OW 1
54308: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54309: LD_ADDR_EXP 77
54313: PUSH
54314: LD_EXP 77
54318: PPUSH
54319: LD_VAR 0 2
54323: PPUSH
54324: EMPTY
54325: PPUSH
54326: CALL_OW 1
54330: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54331: LD_ADDR_EXP 78
54335: PUSH
54336: LD_EXP 78
54340: PPUSH
54341: LD_VAR 0 2
54345: PPUSH
54346: EMPTY
54347: PPUSH
54348: CALL_OW 1
54352: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54353: LD_ADDR_EXP 79
54357: PUSH
54358: LD_EXP 79
54362: PPUSH
54363: LD_VAR 0 2
54367: PPUSH
54368: EMPTY
54369: PPUSH
54370: CALL_OW 1
54374: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54375: LD_ADDR_EXP 80
54379: PUSH
54380: LD_EXP 80
54384: PPUSH
54385: LD_VAR 0 2
54389: PPUSH
54390: EMPTY
54391: PPUSH
54392: CALL_OW 1
54396: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54397: LD_ADDR_EXP 81
54401: PUSH
54402: LD_EXP 81
54406: PPUSH
54407: LD_VAR 0 2
54411: PPUSH
54412: EMPTY
54413: PPUSH
54414: CALL_OW 1
54418: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54419: LD_ADDR_EXP 82
54423: PUSH
54424: LD_EXP 82
54428: PPUSH
54429: LD_VAR 0 2
54433: PPUSH
54434: EMPTY
54435: PPUSH
54436: CALL_OW 1
54440: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54441: LD_ADDR_EXP 83
54445: PUSH
54446: LD_EXP 83
54450: PPUSH
54451: LD_VAR 0 2
54455: PPUSH
54456: EMPTY
54457: PPUSH
54458: CALL_OW 1
54462: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54463: LD_ADDR_EXP 84
54467: PUSH
54468: LD_EXP 84
54472: PPUSH
54473: LD_VAR 0 2
54477: PPUSH
54478: EMPTY
54479: PPUSH
54480: CALL_OW 1
54484: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54485: LD_ADDR_EXP 85
54489: PUSH
54490: LD_EXP 85
54494: PPUSH
54495: LD_VAR 0 2
54499: PPUSH
54500: LD_INT 0
54502: PPUSH
54503: CALL_OW 1
54507: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54508: LD_ADDR_EXP 86
54512: PUSH
54513: LD_EXP 86
54517: PPUSH
54518: LD_VAR 0 2
54522: PPUSH
54523: LD_INT 0
54525: PPUSH
54526: CALL_OW 1
54530: ST_TO_ADDR
// end ;
54531: GO 53432
54533: POP
54534: POP
// MC_InitSides ( ) ;
54535: CALL 54821 0 0
// MC_InitResearch ( ) ;
54539: CALL 54560 0 0
// CustomInitMacro ( ) ;
54543: CALL 78 0 0
// skirmish := true ;
54547: LD_ADDR_EXP 41
54551: PUSH
54552: LD_INT 1
54554: ST_TO_ADDR
// end ;
54555: LD_VAR 0 1
54559: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54560: LD_INT 0
54562: PPUSH
54563: PPUSH
54564: PPUSH
54565: PPUSH
54566: PPUSH
54567: PPUSH
// if not mc_bases then
54568: LD_EXP 43
54572: NOT
54573: IFFALSE 54577
// exit ;
54575: GO 54816
// for i = 1 to 8 do
54577: LD_ADDR_VAR 0 2
54581: PUSH
54582: DOUBLE
54583: LD_INT 1
54585: DEC
54586: ST_TO_ADDR
54587: LD_INT 8
54589: PUSH
54590: FOR_TO
54591: IFFALSE 54617
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54593: LD_ADDR_EXP 70
54597: PUSH
54598: LD_EXP 70
54602: PPUSH
54603: LD_VAR 0 2
54607: PPUSH
54608: EMPTY
54609: PPUSH
54610: CALL_OW 1
54614: ST_TO_ADDR
54615: GO 54590
54617: POP
54618: POP
// tmp := [ ] ;
54619: LD_ADDR_VAR 0 5
54623: PUSH
54624: EMPTY
54625: ST_TO_ADDR
// for i = 1 to mc_sides do
54626: LD_ADDR_VAR 0 2
54630: PUSH
54631: DOUBLE
54632: LD_INT 1
54634: DEC
54635: ST_TO_ADDR
54636: LD_EXP 69
54640: PUSH
54641: FOR_TO
54642: IFFALSE 54700
// if not mc_sides [ i ] in tmp then
54644: LD_EXP 69
54648: PUSH
54649: LD_VAR 0 2
54653: ARRAY
54654: PUSH
54655: LD_VAR 0 5
54659: IN
54660: NOT
54661: IFFALSE 54698
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54663: LD_ADDR_VAR 0 5
54667: PUSH
54668: LD_VAR 0 5
54672: PPUSH
54673: LD_VAR 0 5
54677: PUSH
54678: LD_INT 1
54680: PLUS
54681: PPUSH
54682: LD_EXP 69
54686: PUSH
54687: LD_VAR 0 2
54691: ARRAY
54692: PPUSH
54693: CALL_OW 2
54697: ST_TO_ADDR
54698: GO 54641
54700: POP
54701: POP
// if not tmp then
54702: LD_VAR 0 5
54706: NOT
54707: IFFALSE 54711
// exit ;
54709: GO 54816
// for j in tmp do
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_VAR 0 5
54720: PUSH
54721: FOR_IN
54722: IFFALSE 54814
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54724: LD_ADDR_VAR 0 6
54728: PUSH
54729: LD_INT 22
54731: PUSH
54732: LD_VAR 0 3
54736: PUSH
54737: EMPTY
54738: LIST
54739: LIST
54740: PPUSH
54741: CALL_OW 69
54745: ST_TO_ADDR
// if not un then
54746: LD_VAR 0 6
54750: NOT
54751: IFFALSE 54755
// continue ;
54753: GO 54721
// nation := GetNation ( un [ 1 ] ) ;
54755: LD_ADDR_VAR 0 4
54759: PUSH
54760: LD_VAR 0 6
54764: PUSH
54765: LD_INT 1
54767: ARRAY
54768: PPUSH
54769: CALL_OW 248
54773: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54774: LD_ADDR_EXP 70
54778: PUSH
54779: LD_EXP 70
54783: PPUSH
54784: LD_VAR 0 3
54788: PPUSH
54789: LD_VAR 0 3
54793: PPUSH
54794: LD_VAR 0 4
54798: PPUSH
54799: LD_INT 1
54801: PPUSH
54802: CALL 9875 0 3
54806: PPUSH
54807: CALL_OW 1
54811: ST_TO_ADDR
// end ;
54812: GO 54721
54814: POP
54815: POP
// end ;
54816: LD_VAR 0 1
54820: RET
// export function MC_InitSides ( ) ; var i ; begin
54821: LD_INT 0
54823: PPUSH
54824: PPUSH
// if not mc_bases then
54825: LD_EXP 43
54829: NOT
54830: IFFALSE 54834
// exit ;
54832: GO 54908
// for i = 1 to mc_bases do
54834: LD_ADDR_VAR 0 2
54838: PUSH
54839: DOUBLE
54840: LD_INT 1
54842: DEC
54843: ST_TO_ADDR
54844: LD_EXP 43
54848: PUSH
54849: FOR_TO
54850: IFFALSE 54906
// if mc_bases [ i ] then
54852: LD_EXP 43
54856: PUSH
54857: LD_VAR 0 2
54861: ARRAY
54862: IFFALSE 54904
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54864: LD_ADDR_EXP 69
54868: PUSH
54869: LD_EXP 69
54873: PPUSH
54874: LD_VAR 0 2
54878: PPUSH
54879: LD_EXP 43
54883: PUSH
54884: LD_VAR 0 2
54888: ARRAY
54889: PUSH
54890: LD_INT 1
54892: ARRAY
54893: PPUSH
54894: CALL_OW 255
54898: PPUSH
54899: CALL_OW 1
54903: ST_TO_ADDR
54904: GO 54849
54906: POP
54907: POP
// end ;
54908: LD_VAR 0 1
54912: RET
// every 0 0$03 trigger skirmish do
54913: LD_EXP 41
54917: IFFALSE 55071
54919: GO 54921
54921: DISABLE
// begin enable ;
54922: ENABLE
// MC_CheckBuildings ( ) ;
54923: CALL 59569 0 0
// MC_CheckPeopleLife ( ) ;
54927: CALL 59730 0 0
// RaiseSailEvent ( 100 ) ;
54931: LD_INT 100
54933: PPUSH
54934: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54938: LD_INT 103
54940: PPUSH
54941: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54945: LD_INT 104
54947: PPUSH
54948: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54952: LD_INT 105
54954: PPUSH
54955: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54959: LD_INT 106
54961: PPUSH
54962: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54966: LD_INT 107
54968: PPUSH
54969: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54973: LD_INT 108
54975: PPUSH
54976: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54980: LD_INT 109
54982: PPUSH
54983: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54987: LD_INT 110
54989: PPUSH
54990: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54994: LD_INT 111
54996: PPUSH
54997: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55001: LD_INT 112
55003: PPUSH
55004: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55008: LD_INT 113
55010: PPUSH
55011: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55015: LD_INT 120
55017: PPUSH
55018: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55022: LD_INT 121
55024: PPUSH
55025: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55029: LD_INT 122
55031: PPUSH
55032: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55036: LD_INT 123
55038: PPUSH
55039: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55043: LD_INT 124
55045: PPUSH
55046: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55050: LD_INT 125
55052: PPUSH
55053: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55057: LD_INT 126
55059: PPUSH
55060: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55064: LD_INT 200
55066: PPUSH
55067: CALL_OW 427
// end ;
55071: END
// on SailEvent ( event ) do begin if event < 100 then
55072: LD_VAR 0 1
55076: PUSH
55077: LD_INT 100
55079: LESS
55080: IFFALSE 55091
// CustomEvent ( event ) ;
55082: LD_VAR 0 1
55086: PPUSH
55087: CALL 584 0 1
// if event = 100 then
55091: LD_VAR 0 1
55095: PUSH
55096: LD_INT 100
55098: EQUAL
55099: IFFALSE 55105
// MC_ClassManager ( ) ;
55101: CALL 55497 0 0
// if event = 101 then
55105: LD_VAR 0 1
55109: PUSH
55110: LD_INT 101
55112: EQUAL
55113: IFFALSE 55119
// MC_RepairBuildings ( ) ;
55115: CALL 60315 0 0
// if event = 102 then
55119: LD_VAR 0 1
55123: PUSH
55124: LD_INT 102
55126: EQUAL
55127: IFFALSE 55133
// MC_Heal ( ) ;
55129: CALL 61250 0 0
// if event = 103 then
55133: LD_VAR 0 1
55137: PUSH
55138: LD_INT 103
55140: EQUAL
55141: IFFALSE 55147
// MC_Build ( ) ;
55143: CALL 61672 0 0
// if event = 104 then
55147: LD_VAR 0 1
55151: PUSH
55152: LD_INT 104
55154: EQUAL
55155: IFFALSE 55161
// MC_TurretWeapon ( ) ;
55157: CALL 63306 0 0
// if event = 105 then
55161: LD_VAR 0 1
55165: PUSH
55166: LD_INT 105
55168: EQUAL
55169: IFFALSE 55175
// MC_BuildUpgrade ( ) ;
55171: CALL 62857 0 0
// if event = 106 then
55175: LD_VAR 0 1
55179: PUSH
55180: LD_INT 106
55182: EQUAL
55183: IFFALSE 55189
// MC_PlantMines ( ) ;
55185: CALL 63736 0 0
// if event = 107 then
55189: LD_VAR 0 1
55193: PUSH
55194: LD_INT 107
55196: EQUAL
55197: IFFALSE 55203
// MC_CollectCrates ( ) ;
55199: CALL 64527 0 0
// if event = 108 then
55203: LD_VAR 0 1
55207: PUSH
55208: LD_INT 108
55210: EQUAL
55211: IFFALSE 55217
// MC_LinkRemoteControl ( ) ;
55213: CALL 66377 0 0
// if event = 109 then
55217: LD_VAR 0 1
55221: PUSH
55222: LD_INT 109
55224: EQUAL
55225: IFFALSE 55231
// MC_ProduceVehicle ( ) ;
55227: CALL 66558 0 0
// if event = 110 then
55231: LD_VAR 0 1
55235: PUSH
55236: LD_INT 110
55238: EQUAL
55239: IFFALSE 55245
// MC_SendAttack ( ) ;
55241: CALL 67024 0 0
// if event = 111 then
55245: LD_VAR 0 1
55249: PUSH
55250: LD_INT 111
55252: EQUAL
55253: IFFALSE 55259
// MC_Defend ( ) ;
55255: CALL 67132 0 0
// if event = 112 then
55259: LD_VAR 0 1
55263: PUSH
55264: LD_INT 112
55266: EQUAL
55267: IFFALSE 55273
// MC_Research ( ) ;
55269: CALL 68012 0 0
// if event = 113 then
55273: LD_VAR 0 1
55277: PUSH
55278: LD_INT 113
55280: EQUAL
55281: IFFALSE 55287
// MC_MinesTrigger ( ) ;
55283: CALL 69126 0 0
// if event = 120 then
55287: LD_VAR 0 1
55291: PUSH
55292: LD_INT 120
55294: EQUAL
55295: IFFALSE 55301
// MC_RepairVehicle ( ) ;
55297: CALL 69225 0 0
// if event = 121 then
55301: LD_VAR 0 1
55305: PUSH
55306: LD_INT 121
55308: EQUAL
55309: IFFALSE 55315
// MC_TameApe ( ) ;
55311: CALL 69994 0 0
// if event = 122 then
55315: LD_VAR 0 1
55319: PUSH
55320: LD_INT 122
55322: EQUAL
55323: IFFALSE 55329
// MC_ChangeApeClass ( ) ;
55325: CALL 70823 0 0
// if event = 123 then
55329: LD_VAR 0 1
55333: PUSH
55334: LD_INT 123
55336: EQUAL
55337: IFFALSE 55343
// MC_Bazooka ( ) ;
55339: CALL 71473 0 0
// if event = 124 then
55343: LD_VAR 0 1
55347: PUSH
55348: LD_INT 124
55350: EQUAL
55351: IFFALSE 55357
// MC_TeleportExit ( ) ;
55353: CALL 71671 0 0
// if event = 125 then
55357: LD_VAR 0 1
55361: PUSH
55362: LD_INT 125
55364: EQUAL
55365: IFFALSE 55371
// MC_Deposits ( ) ;
55367: CALL 72318 0 0
// if event = 126 then
55371: LD_VAR 0 1
55375: PUSH
55376: LD_INT 126
55378: EQUAL
55379: IFFALSE 55385
// MC_RemoteDriver ( ) ;
55381: CALL 72943 0 0
// if event = 200 then
55385: LD_VAR 0 1
55389: PUSH
55390: LD_INT 200
55392: EQUAL
55393: IFFALSE 55399
// MC_Idle ( ) ;
55395: CALL 74892 0 0
// end ;
55399: PPOPN 1
55401: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55402: LD_INT 0
55404: PPUSH
55405: PPUSH
// if not mc_bases [ base ] or not tag then
55406: LD_EXP 43
55410: PUSH
55411: LD_VAR 0 1
55415: ARRAY
55416: NOT
55417: PUSH
55418: LD_VAR 0 2
55422: NOT
55423: OR
55424: IFFALSE 55428
// exit ;
55426: GO 55492
// for i in mc_bases [ base ] union mc_ape [ base ] do
55428: LD_ADDR_VAR 0 4
55432: PUSH
55433: LD_EXP 43
55437: PUSH
55438: LD_VAR 0 1
55442: ARRAY
55443: PUSH
55444: LD_EXP 72
55448: PUSH
55449: LD_VAR 0 1
55453: ARRAY
55454: UNION
55455: PUSH
55456: FOR_IN
55457: IFFALSE 55490
// if GetTag ( i ) = tag then
55459: LD_VAR 0 4
55463: PPUSH
55464: CALL_OW 110
55468: PUSH
55469: LD_VAR 0 2
55473: EQUAL
55474: IFFALSE 55488
// SetTag ( i , 0 ) ;
55476: LD_VAR 0 4
55480: PPUSH
55481: LD_INT 0
55483: PPUSH
55484: CALL_OW 109
55488: GO 55456
55490: POP
55491: POP
// end ;
55492: LD_VAR 0 3
55496: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55497: LD_INT 0
55499: PPUSH
55500: PPUSH
55501: PPUSH
55502: PPUSH
55503: PPUSH
55504: PPUSH
55505: PPUSH
55506: PPUSH
// if not mc_bases then
55507: LD_EXP 43
55511: NOT
55512: IFFALSE 55516
// exit ;
55514: GO 55974
// for i = 1 to mc_bases do
55516: LD_ADDR_VAR 0 2
55520: PUSH
55521: DOUBLE
55522: LD_INT 1
55524: DEC
55525: ST_TO_ADDR
55526: LD_EXP 43
55530: PUSH
55531: FOR_TO
55532: IFFALSE 55972
// begin tmp := MC_ClassCheckReq ( i ) ;
55534: LD_ADDR_VAR 0 4
55538: PUSH
55539: LD_VAR 0 2
55543: PPUSH
55544: CALL 55979 0 1
55548: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55549: LD_ADDR_EXP 84
55553: PUSH
55554: LD_EXP 84
55558: PPUSH
55559: LD_VAR 0 2
55563: PPUSH
55564: LD_VAR 0 4
55568: PPUSH
55569: CALL_OW 1
55573: ST_TO_ADDR
// if not tmp then
55574: LD_VAR 0 4
55578: NOT
55579: IFFALSE 55583
// continue ;
55581: GO 55531
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55583: LD_ADDR_VAR 0 6
55587: PUSH
55588: LD_EXP 43
55592: PUSH
55593: LD_VAR 0 2
55597: ARRAY
55598: PPUSH
55599: LD_INT 2
55601: PUSH
55602: LD_INT 30
55604: PUSH
55605: LD_INT 4
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: PUSH
55612: LD_INT 30
55614: PUSH
55615: LD_INT 5
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: LIST
55626: PPUSH
55627: CALL_OW 72
55631: PUSH
55632: LD_EXP 43
55636: PUSH
55637: LD_VAR 0 2
55641: ARRAY
55642: PPUSH
55643: LD_INT 2
55645: PUSH
55646: LD_INT 30
55648: PUSH
55649: LD_INT 0
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: PUSH
55656: LD_INT 30
55658: PUSH
55659: LD_INT 1
55661: PUSH
55662: EMPTY
55663: LIST
55664: LIST
55665: PUSH
55666: EMPTY
55667: LIST
55668: LIST
55669: LIST
55670: PPUSH
55671: CALL_OW 72
55675: PUSH
55676: LD_EXP 43
55680: PUSH
55681: LD_VAR 0 2
55685: ARRAY
55686: PPUSH
55687: LD_INT 30
55689: PUSH
55690: LD_INT 3
55692: PUSH
55693: EMPTY
55694: LIST
55695: LIST
55696: PPUSH
55697: CALL_OW 72
55701: PUSH
55702: LD_EXP 43
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: PPUSH
55713: LD_INT 2
55715: PUSH
55716: LD_INT 30
55718: PUSH
55719: LD_INT 6
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: PUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 7
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PUSH
55736: LD_INT 30
55738: PUSH
55739: LD_INT 8
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: LIST
55751: PPUSH
55752: CALL_OW 72
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: LIST
55761: LIST
55762: ST_TO_ADDR
// for j = 1 to 4 do
55763: LD_ADDR_VAR 0 3
55767: PUSH
55768: DOUBLE
55769: LD_INT 1
55771: DEC
55772: ST_TO_ADDR
55773: LD_INT 4
55775: PUSH
55776: FOR_TO
55777: IFFALSE 55968
// begin if not tmp [ j ] then
55779: LD_VAR 0 4
55783: PUSH
55784: LD_VAR 0 3
55788: ARRAY
55789: NOT
55790: IFFALSE 55794
// continue ;
55792: GO 55776
// for p in tmp [ j ] do
55794: LD_ADDR_VAR 0 5
55798: PUSH
55799: LD_VAR 0 4
55803: PUSH
55804: LD_VAR 0 3
55808: ARRAY
55809: PUSH
55810: FOR_IN
55811: IFFALSE 55964
// begin if not b [ j ] then
55813: LD_VAR 0 6
55817: PUSH
55818: LD_VAR 0 3
55822: ARRAY
55823: NOT
55824: IFFALSE 55828
// break ;
55826: GO 55964
// e := 0 ;
55828: LD_ADDR_VAR 0 7
55832: PUSH
55833: LD_INT 0
55835: ST_TO_ADDR
// for k in b [ j ] do
55836: LD_ADDR_VAR 0 8
55840: PUSH
55841: LD_VAR 0 6
55845: PUSH
55846: LD_VAR 0 3
55850: ARRAY
55851: PUSH
55852: FOR_IN
55853: IFFALSE 55880
// if IsNotFull ( k ) then
55855: LD_VAR 0 8
55859: PPUSH
55860: CALL 12028 0 1
55864: IFFALSE 55878
// begin e := k ;
55866: LD_ADDR_VAR 0 7
55870: PUSH
55871: LD_VAR 0 8
55875: ST_TO_ADDR
// break ;
55876: GO 55880
// end ;
55878: GO 55852
55880: POP
55881: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55882: LD_VAR 0 7
55886: PUSH
55887: LD_VAR 0 5
55891: PPUSH
55892: LD_VAR 0 7
55896: PPUSH
55897: CALL 45924 0 2
55901: NOT
55902: AND
55903: IFFALSE 55962
// begin if IsInUnit ( p ) then
55905: LD_VAR 0 5
55909: PPUSH
55910: CALL_OW 310
55914: IFFALSE 55925
// ComExitBuilding ( p ) ;
55916: LD_VAR 0 5
55920: PPUSH
55921: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55925: LD_VAR 0 5
55929: PPUSH
55930: LD_VAR 0 7
55934: PPUSH
55935: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55939: LD_VAR 0 5
55943: PPUSH
55944: LD_VAR 0 3
55948: PPUSH
55949: CALL_OW 183
// AddComExitBuilding ( p ) ;
55953: LD_VAR 0 5
55957: PPUSH
55958: CALL_OW 182
// end ; end ;
55962: GO 55810
55964: POP
55965: POP
// end ;
55966: GO 55776
55968: POP
55969: POP
// end ;
55970: GO 55531
55972: POP
55973: POP
// end ;
55974: LD_VAR 0 1
55978: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55979: LD_INT 0
55981: PPUSH
55982: PPUSH
55983: PPUSH
55984: PPUSH
55985: PPUSH
55986: PPUSH
55987: PPUSH
55988: PPUSH
55989: PPUSH
55990: PPUSH
55991: PPUSH
55992: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55993: LD_VAR 0 1
55997: NOT
55998: PUSH
55999: LD_EXP 43
56003: PUSH
56004: LD_VAR 0 1
56008: ARRAY
56009: NOT
56010: OR
56011: PUSH
56012: LD_EXP 43
56016: PUSH
56017: LD_VAR 0 1
56021: ARRAY
56022: PPUSH
56023: LD_INT 2
56025: PUSH
56026: LD_INT 30
56028: PUSH
56029: LD_INT 0
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PUSH
56036: LD_INT 30
56038: PUSH
56039: LD_INT 1
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: PUSH
56046: EMPTY
56047: LIST
56048: LIST
56049: LIST
56050: PPUSH
56051: CALL_OW 72
56055: NOT
56056: OR
56057: IFFALSE 56061
// exit ;
56059: GO 59564
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56061: LD_ADDR_VAR 0 4
56065: PUSH
56066: LD_EXP 43
56070: PUSH
56071: LD_VAR 0 1
56075: ARRAY
56076: PPUSH
56077: LD_INT 2
56079: PUSH
56080: LD_INT 25
56082: PUSH
56083: LD_INT 1
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: PUSH
56090: LD_INT 25
56092: PUSH
56093: LD_INT 2
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: LD_INT 25
56102: PUSH
56103: LD_INT 3
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: LD_INT 25
56112: PUSH
56113: LD_INT 4
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 25
56122: PUSH
56123: LD_INT 5
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: LD_INT 25
56132: PUSH
56133: LD_INT 8
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: PUSH
56140: LD_INT 25
56142: PUSH
56143: LD_INT 9
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: LIST
56158: LIST
56159: PPUSH
56160: CALL_OW 72
56164: ST_TO_ADDR
// if not tmp then
56165: LD_VAR 0 4
56169: NOT
56170: IFFALSE 56174
// exit ;
56172: GO 59564
// for i in tmp do
56174: LD_ADDR_VAR 0 3
56178: PUSH
56179: LD_VAR 0 4
56183: PUSH
56184: FOR_IN
56185: IFFALSE 56216
// if GetTag ( i ) then
56187: LD_VAR 0 3
56191: PPUSH
56192: CALL_OW 110
56196: IFFALSE 56214
// tmp := tmp diff i ;
56198: LD_ADDR_VAR 0 4
56202: PUSH
56203: LD_VAR 0 4
56207: PUSH
56208: LD_VAR 0 3
56212: DIFF
56213: ST_TO_ADDR
56214: GO 56184
56216: POP
56217: POP
// if not tmp then
56218: LD_VAR 0 4
56222: NOT
56223: IFFALSE 56227
// exit ;
56225: GO 59564
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56227: LD_ADDR_VAR 0 5
56231: PUSH
56232: LD_EXP 43
56236: PUSH
56237: LD_VAR 0 1
56241: ARRAY
56242: PPUSH
56243: LD_INT 2
56245: PUSH
56246: LD_INT 25
56248: PUSH
56249: LD_INT 1
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: PUSH
56256: LD_INT 25
56258: PUSH
56259: LD_INT 5
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: LD_INT 25
56268: PUSH
56269: LD_INT 8
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: PUSH
56276: LD_INT 25
56278: PUSH
56279: LD_INT 9
56281: PUSH
56282: EMPTY
56283: LIST
56284: LIST
56285: PUSH
56286: EMPTY
56287: LIST
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: PPUSH
56293: CALL_OW 72
56297: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56298: LD_ADDR_VAR 0 6
56302: PUSH
56303: LD_EXP 43
56307: PUSH
56308: LD_VAR 0 1
56312: ARRAY
56313: PPUSH
56314: LD_INT 25
56316: PUSH
56317: LD_INT 2
56319: PUSH
56320: EMPTY
56321: LIST
56322: LIST
56323: PPUSH
56324: CALL_OW 72
56328: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56329: LD_ADDR_VAR 0 7
56333: PUSH
56334: LD_EXP 43
56338: PUSH
56339: LD_VAR 0 1
56343: ARRAY
56344: PPUSH
56345: LD_INT 25
56347: PUSH
56348: LD_INT 3
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: PPUSH
56355: CALL_OW 72
56359: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56360: LD_ADDR_VAR 0 8
56364: PUSH
56365: LD_EXP 43
56369: PUSH
56370: LD_VAR 0 1
56374: ARRAY
56375: PPUSH
56376: LD_INT 25
56378: PUSH
56379: LD_INT 4
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PUSH
56386: LD_INT 24
56388: PUSH
56389: LD_INT 251
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: EMPTY
56397: LIST
56398: LIST
56399: PPUSH
56400: CALL_OW 72
56404: ST_TO_ADDR
// if mc_is_defending [ base ] then
56405: LD_EXP 86
56409: PUSH
56410: LD_VAR 0 1
56414: ARRAY
56415: IFFALSE 56876
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56417: LD_ADDR_EXP 85
56421: PUSH
56422: LD_EXP 85
56426: PPUSH
56427: LD_VAR 0 1
56431: PPUSH
56432: LD_INT 4
56434: PPUSH
56435: CALL_OW 1
56439: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56440: LD_ADDR_VAR 0 12
56444: PUSH
56445: LD_EXP 43
56449: PUSH
56450: LD_VAR 0 1
56454: ARRAY
56455: PPUSH
56456: LD_INT 2
56458: PUSH
56459: LD_INT 30
56461: PUSH
56462: LD_INT 4
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: PUSH
56469: LD_INT 30
56471: PUSH
56472: LD_INT 5
56474: PUSH
56475: EMPTY
56476: LIST
56477: LIST
56478: PUSH
56479: EMPTY
56480: LIST
56481: LIST
56482: LIST
56483: PPUSH
56484: CALL_OW 72
56488: ST_TO_ADDR
// if not b then
56489: LD_VAR 0 12
56493: NOT
56494: IFFALSE 56498
// exit ;
56496: GO 59564
// p := [ ] ;
56498: LD_ADDR_VAR 0 11
56502: PUSH
56503: EMPTY
56504: ST_TO_ADDR
// if sci >= 2 then
56505: LD_VAR 0 8
56509: PUSH
56510: LD_INT 2
56512: GREATEREQUAL
56513: IFFALSE 56544
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56515: LD_ADDR_VAR 0 8
56519: PUSH
56520: LD_VAR 0 8
56524: PUSH
56525: LD_INT 1
56527: ARRAY
56528: PUSH
56529: LD_VAR 0 8
56533: PUSH
56534: LD_INT 2
56536: ARRAY
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: ST_TO_ADDR
56542: GO 56605
// if sci = 1 then
56544: LD_VAR 0 8
56548: PUSH
56549: LD_INT 1
56551: EQUAL
56552: IFFALSE 56573
// sci := [ sci [ 1 ] ] else
56554: LD_ADDR_VAR 0 8
56558: PUSH
56559: LD_VAR 0 8
56563: PUSH
56564: LD_INT 1
56566: ARRAY
56567: PUSH
56568: EMPTY
56569: LIST
56570: ST_TO_ADDR
56571: GO 56605
// if sci = 0 then
56573: LD_VAR 0 8
56577: PUSH
56578: LD_INT 0
56580: EQUAL
56581: IFFALSE 56605
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56583: LD_ADDR_VAR 0 11
56587: PUSH
56588: LD_VAR 0 4
56592: PPUSH
56593: LD_INT 4
56595: PPUSH
56596: CALL 45796 0 2
56600: PUSH
56601: LD_INT 1
56603: ARRAY
56604: ST_TO_ADDR
// if eng > 4 then
56605: LD_VAR 0 6
56609: PUSH
56610: LD_INT 4
56612: GREATER
56613: IFFALSE 56659
// for i = eng downto 4 do
56615: LD_ADDR_VAR 0 3
56619: PUSH
56620: DOUBLE
56621: LD_VAR 0 6
56625: INC
56626: ST_TO_ADDR
56627: LD_INT 4
56629: PUSH
56630: FOR_DOWNTO
56631: IFFALSE 56657
// eng := eng diff eng [ i ] ;
56633: LD_ADDR_VAR 0 6
56637: PUSH
56638: LD_VAR 0 6
56642: PUSH
56643: LD_VAR 0 6
56647: PUSH
56648: LD_VAR 0 3
56652: ARRAY
56653: DIFF
56654: ST_TO_ADDR
56655: GO 56630
56657: POP
56658: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56659: LD_ADDR_VAR 0 4
56663: PUSH
56664: LD_VAR 0 4
56668: PUSH
56669: LD_VAR 0 5
56673: PUSH
56674: LD_VAR 0 6
56678: UNION
56679: PUSH
56680: LD_VAR 0 7
56684: UNION
56685: PUSH
56686: LD_VAR 0 8
56690: UNION
56691: DIFF
56692: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56693: LD_ADDR_VAR 0 13
56697: PUSH
56698: LD_EXP 43
56702: PUSH
56703: LD_VAR 0 1
56707: ARRAY
56708: PPUSH
56709: LD_INT 2
56711: PUSH
56712: LD_INT 30
56714: PUSH
56715: LD_INT 32
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: PUSH
56722: LD_INT 30
56724: PUSH
56725: LD_INT 31
56727: PUSH
56728: EMPTY
56729: LIST
56730: LIST
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: LIST
56736: PPUSH
56737: CALL_OW 72
56741: PUSH
56742: LD_EXP 43
56746: PUSH
56747: LD_VAR 0 1
56751: ARRAY
56752: PPUSH
56753: LD_INT 2
56755: PUSH
56756: LD_INT 30
56758: PUSH
56759: LD_INT 4
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: PUSH
56766: LD_INT 30
56768: PUSH
56769: LD_INT 5
56771: PUSH
56772: EMPTY
56773: LIST
56774: LIST
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: LIST
56780: PPUSH
56781: CALL_OW 72
56785: PUSH
56786: LD_INT 6
56788: MUL
56789: PLUS
56790: ST_TO_ADDR
// if bcount < tmp then
56791: LD_VAR 0 13
56795: PUSH
56796: LD_VAR 0 4
56800: LESS
56801: IFFALSE 56847
// for i = tmp downto bcount do
56803: LD_ADDR_VAR 0 3
56807: PUSH
56808: DOUBLE
56809: LD_VAR 0 4
56813: INC
56814: ST_TO_ADDR
56815: LD_VAR 0 13
56819: PUSH
56820: FOR_DOWNTO
56821: IFFALSE 56845
// tmp := Delete ( tmp , tmp ) ;
56823: LD_ADDR_VAR 0 4
56827: PUSH
56828: LD_VAR 0 4
56832: PPUSH
56833: LD_VAR 0 4
56837: PPUSH
56838: CALL_OW 3
56842: ST_TO_ADDR
56843: GO 56820
56845: POP
56846: POP
// result := [ tmp , 0 , 0 , p ] ;
56847: LD_ADDR_VAR 0 2
56851: PUSH
56852: LD_VAR 0 4
56856: PUSH
56857: LD_INT 0
56859: PUSH
56860: LD_INT 0
56862: PUSH
56863: LD_VAR 0 11
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: LIST
56872: LIST
56873: ST_TO_ADDR
// exit ;
56874: GO 59564
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56876: LD_EXP 43
56880: PUSH
56881: LD_VAR 0 1
56885: ARRAY
56886: PPUSH
56887: LD_INT 2
56889: PUSH
56890: LD_INT 30
56892: PUSH
56893: LD_INT 6
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: PUSH
56900: LD_INT 30
56902: PUSH
56903: LD_INT 7
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: PUSH
56910: LD_INT 30
56912: PUSH
56913: LD_INT 8
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: LIST
56924: LIST
56925: PPUSH
56926: CALL_OW 72
56930: NOT
56931: PUSH
56932: LD_EXP 43
56936: PUSH
56937: LD_VAR 0 1
56941: ARRAY
56942: PPUSH
56943: LD_INT 30
56945: PUSH
56946: LD_INT 3
56948: PUSH
56949: EMPTY
56950: LIST
56951: LIST
56952: PPUSH
56953: CALL_OW 72
56957: NOT
56958: AND
56959: IFFALSE 57031
// begin if eng = tmp then
56961: LD_VAR 0 6
56965: PUSH
56966: LD_VAR 0 4
56970: EQUAL
56971: IFFALSE 56975
// exit ;
56973: GO 59564
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56975: LD_ADDR_EXP 85
56979: PUSH
56980: LD_EXP 85
56984: PPUSH
56985: LD_VAR 0 1
56989: PPUSH
56990: LD_INT 1
56992: PPUSH
56993: CALL_OW 1
56997: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56998: LD_ADDR_VAR 0 2
57002: PUSH
57003: LD_INT 0
57005: PUSH
57006: LD_VAR 0 4
57010: PUSH
57011: LD_VAR 0 6
57015: DIFF
57016: PUSH
57017: LD_INT 0
57019: PUSH
57020: LD_INT 0
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: LIST
57027: LIST
57028: ST_TO_ADDR
// exit ;
57029: GO 59564
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57031: LD_EXP 70
57035: PUSH
57036: LD_EXP 69
57040: PUSH
57041: LD_VAR 0 1
57045: ARRAY
57046: ARRAY
57047: PUSH
57048: LD_EXP 43
57052: PUSH
57053: LD_VAR 0 1
57057: ARRAY
57058: PPUSH
57059: LD_INT 2
57061: PUSH
57062: LD_INT 30
57064: PUSH
57065: LD_INT 6
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: PUSH
57072: LD_INT 30
57074: PUSH
57075: LD_INT 7
57077: PUSH
57078: EMPTY
57079: LIST
57080: LIST
57081: PUSH
57082: LD_INT 30
57084: PUSH
57085: LD_INT 8
57087: PUSH
57088: EMPTY
57089: LIST
57090: LIST
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: LIST
57096: LIST
57097: PPUSH
57098: CALL_OW 72
57102: AND
57103: PUSH
57104: LD_EXP 43
57108: PUSH
57109: LD_VAR 0 1
57113: ARRAY
57114: PPUSH
57115: LD_INT 30
57117: PUSH
57118: LD_INT 3
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: PPUSH
57125: CALL_OW 72
57129: NOT
57130: AND
57131: IFFALSE 57345
// begin if sci >= 6 then
57133: LD_VAR 0 8
57137: PUSH
57138: LD_INT 6
57140: GREATEREQUAL
57141: IFFALSE 57145
// exit ;
57143: GO 59564
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57145: LD_ADDR_EXP 85
57149: PUSH
57150: LD_EXP 85
57154: PPUSH
57155: LD_VAR 0 1
57159: PPUSH
57160: LD_INT 2
57162: PPUSH
57163: CALL_OW 1
57167: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57168: LD_ADDR_VAR 0 9
57172: PUSH
57173: LD_VAR 0 4
57177: PUSH
57178: LD_VAR 0 8
57182: DIFF
57183: PPUSH
57184: LD_INT 4
57186: PPUSH
57187: CALL 45796 0 2
57191: ST_TO_ADDR
// p := [ ] ;
57192: LD_ADDR_VAR 0 11
57196: PUSH
57197: EMPTY
57198: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57199: LD_VAR 0 8
57203: PUSH
57204: LD_INT 6
57206: LESS
57207: PUSH
57208: LD_VAR 0 9
57212: PUSH
57213: LD_INT 6
57215: GREATER
57216: AND
57217: IFFALSE 57298
// begin for i = 1 to 6 - sci do
57219: LD_ADDR_VAR 0 3
57223: PUSH
57224: DOUBLE
57225: LD_INT 1
57227: DEC
57228: ST_TO_ADDR
57229: LD_INT 6
57231: PUSH
57232: LD_VAR 0 8
57236: MINUS
57237: PUSH
57238: FOR_TO
57239: IFFALSE 57294
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57241: LD_ADDR_VAR 0 11
57245: PUSH
57246: LD_VAR 0 11
57250: PPUSH
57251: LD_VAR 0 11
57255: PUSH
57256: LD_INT 1
57258: PLUS
57259: PPUSH
57260: LD_VAR 0 9
57264: PUSH
57265: LD_INT 1
57267: ARRAY
57268: PPUSH
57269: CALL_OW 2
57273: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57274: LD_ADDR_VAR 0 9
57278: PUSH
57279: LD_VAR 0 9
57283: PPUSH
57284: LD_INT 1
57286: PPUSH
57287: CALL_OW 3
57291: ST_TO_ADDR
// end ;
57292: GO 57238
57294: POP
57295: POP
// end else
57296: GO 57318
// if sort then
57298: LD_VAR 0 9
57302: IFFALSE 57318
// p := sort [ 1 ] ;
57304: LD_ADDR_VAR 0 11
57308: PUSH
57309: LD_VAR 0 9
57313: PUSH
57314: LD_INT 1
57316: ARRAY
57317: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57318: LD_ADDR_VAR 0 2
57322: PUSH
57323: LD_INT 0
57325: PUSH
57326: LD_INT 0
57328: PUSH
57329: LD_INT 0
57331: PUSH
57332: LD_VAR 0 11
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: LIST
57341: LIST
57342: ST_TO_ADDR
// exit ;
57343: GO 59564
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57345: LD_EXP 70
57349: PUSH
57350: LD_EXP 69
57354: PUSH
57355: LD_VAR 0 1
57359: ARRAY
57360: ARRAY
57361: PUSH
57362: LD_EXP 43
57366: PUSH
57367: LD_VAR 0 1
57371: ARRAY
57372: PPUSH
57373: LD_INT 2
57375: PUSH
57376: LD_INT 30
57378: PUSH
57379: LD_INT 6
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 30
57388: PUSH
57389: LD_INT 7
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: LD_INT 30
57398: PUSH
57399: LD_INT 8
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: LIST
57410: LIST
57411: PPUSH
57412: CALL_OW 72
57416: AND
57417: PUSH
57418: LD_EXP 43
57422: PUSH
57423: LD_VAR 0 1
57427: ARRAY
57428: PPUSH
57429: LD_INT 30
57431: PUSH
57432: LD_INT 3
57434: PUSH
57435: EMPTY
57436: LIST
57437: LIST
57438: PPUSH
57439: CALL_OW 72
57443: AND
57444: IFFALSE 58178
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57446: LD_ADDR_EXP 85
57450: PUSH
57451: LD_EXP 85
57455: PPUSH
57456: LD_VAR 0 1
57460: PPUSH
57461: LD_INT 3
57463: PPUSH
57464: CALL_OW 1
57468: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57469: LD_ADDR_VAR 0 2
57473: PUSH
57474: LD_INT 0
57476: PUSH
57477: LD_INT 0
57479: PUSH
57480: LD_INT 0
57482: PUSH
57483: LD_INT 0
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: LIST
57490: LIST
57491: ST_TO_ADDR
// if not eng then
57492: LD_VAR 0 6
57496: NOT
57497: IFFALSE 57560
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57499: LD_ADDR_VAR 0 11
57503: PUSH
57504: LD_VAR 0 4
57508: PPUSH
57509: LD_INT 2
57511: PPUSH
57512: CALL 45796 0 2
57516: PUSH
57517: LD_INT 1
57519: ARRAY
57520: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57521: LD_ADDR_VAR 0 2
57525: PUSH
57526: LD_VAR 0 2
57530: PPUSH
57531: LD_INT 2
57533: PPUSH
57534: LD_VAR 0 11
57538: PPUSH
57539: CALL_OW 1
57543: ST_TO_ADDR
// tmp := tmp diff p ;
57544: LD_ADDR_VAR 0 4
57548: PUSH
57549: LD_VAR 0 4
57553: PUSH
57554: LD_VAR 0 11
57558: DIFF
57559: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57560: LD_VAR 0 4
57564: PUSH
57565: LD_VAR 0 8
57569: PUSH
57570: LD_INT 6
57572: LESS
57573: AND
57574: IFFALSE 57762
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57576: LD_ADDR_VAR 0 9
57580: PUSH
57581: LD_VAR 0 4
57585: PUSH
57586: LD_VAR 0 8
57590: PUSH
57591: LD_VAR 0 7
57595: UNION
57596: DIFF
57597: PPUSH
57598: LD_INT 4
57600: PPUSH
57601: CALL 45796 0 2
57605: ST_TO_ADDR
// p := [ ] ;
57606: LD_ADDR_VAR 0 11
57610: PUSH
57611: EMPTY
57612: ST_TO_ADDR
// if sort then
57613: LD_VAR 0 9
57617: IFFALSE 57733
// for i = 1 to 6 - sci do
57619: LD_ADDR_VAR 0 3
57623: PUSH
57624: DOUBLE
57625: LD_INT 1
57627: DEC
57628: ST_TO_ADDR
57629: LD_INT 6
57631: PUSH
57632: LD_VAR 0 8
57636: MINUS
57637: PUSH
57638: FOR_TO
57639: IFFALSE 57731
// begin if i = sort then
57641: LD_VAR 0 3
57645: PUSH
57646: LD_VAR 0 9
57650: EQUAL
57651: IFFALSE 57655
// break ;
57653: GO 57731
// if GetClass ( i ) = 4 then
57655: LD_VAR 0 3
57659: PPUSH
57660: CALL_OW 257
57664: PUSH
57665: LD_INT 4
57667: EQUAL
57668: IFFALSE 57672
// continue ;
57670: GO 57638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57672: LD_ADDR_VAR 0 11
57676: PUSH
57677: LD_VAR 0 11
57681: PPUSH
57682: LD_VAR 0 11
57686: PUSH
57687: LD_INT 1
57689: PLUS
57690: PPUSH
57691: LD_VAR 0 9
57695: PUSH
57696: LD_VAR 0 3
57700: ARRAY
57701: PPUSH
57702: CALL_OW 2
57706: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57707: LD_ADDR_VAR 0 4
57711: PUSH
57712: LD_VAR 0 4
57716: PUSH
57717: LD_VAR 0 9
57721: PUSH
57722: LD_VAR 0 3
57726: ARRAY
57727: DIFF
57728: ST_TO_ADDR
// end ;
57729: GO 57638
57731: POP
57732: POP
// if p then
57733: LD_VAR 0 11
57737: IFFALSE 57762
// result := Replace ( result , 4 , p ) ;
57739: LD_ADDR_VAR 0 2
57743: PUSH
57744: LD_VAR 0 2
57748: PPUSH
57749: LD_INT 4
57751: PPUSH
57752: LD_VAR 0 11
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57762: LD_VAR 0 4
57766: PUSH
57767: LD_VAR 0 7
57771: PUSH
57772: LD_INT 6
57774: LESS
57775: AND
57776: IFFALSE 57964
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57778: LD_ADDR_VAR 0 9
57782: PUSH
57783: LD_VAR 0 4
57787: PUSH
57788: LD_VAR 0 8
57792: PUSH
57793: LD_VAR 0 7
57797: UNION
57798: DIFF
57799: PPUSH
57800: LD_INT 3
57802: PPUSH
57803: CALL 45796 0 2
57807: ST_TO_ADDR
// p := [ ] ;
57808: LD_ADDR_VAR 0 11
57812: PUSH
57813: EMPTY
57814: ST_TO_ADDR
// if sort then
57815: LD_VAR 0 9
57819: IFFALSE 57935
// for i = 1 to 6 - mech do
57821: LD_ADDR_VAR 0 3
57825: PUSH
57826: DOUBLE
57827: LD_INT 1
57829: DEC
57830: ST_TO_ADDR
57831: LD_INT 6
57833: PUSH
57834: LD_VAR 0 7
57838: MINUS
57839: PUSH
57840: FOR_TO
57841: IFFALSE 57933
// begin if i = sort then
57843: LD_VAR 0 3
57847: PUSH
57848: LD_VAR 0 9
57852: EQUAL
57853: IFFALSE 57857
// break ;
57855: GO 57933
// if GetClass ( i ) = 3 then
57857: LD_VAR 0 3
57861: PPUSH
57862: CALL_OW 257
57866: PUSH
57867: LD_INT 3
57869: EQUAL
57870: IFFALSE 57874
// continue ;
57872: GO 57840
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57874: LD_ADDR_VAR 0 11
57878: PUSH
57879: LD_VAR 0 11
57883: PPUSH
57884: LD_VAR 0 11
57888: PUSH
57889: LD_INT 1
57891: PLUS
57892: PPUSH
57893: LD_VAR 0 9
57897: PUSH
57898: LD_VAR 0 3
57902: ARRAY
57903: PPUSH
57904: CALL_OW 2
57908: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57909: LD_ADDR_VAR 0 4
57913: PUSH
57914: LD_VAR 0 4
57918: PUSH
57919: LD_VAR 0 9
57923: PUSH
57924: LD_VAR 0 3
57928: ARRAY
57929: DIFF
57930: ST_TO_ADDR
// end ;
57931: GO 57840
57933: POP
57934: POP
// if p then
57935: LD_VAR 0 11
57939: IFFALSE 57964
// result := Replace ( result , 3 , p ) ;
57941: LD_ADDR_VAR 0 2
57945: PUSH
57946: LD_VAR 0 2
57950: PPUSH
57951: LD_INT 3
57953: PPUSH
57954: LD_VAR 0 11
57958: PPUSH
57959: CALL_OW 1
57963: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57964: LD_VAR 0 4
57968: PUSH
57969: LD_INT 6
57971: GREATER
57972: PUSH
57973: LD_VAR 0 6
57977: PUSH
57978: LD_INT 6
57980: LESS
57981: AND
57982: IFFALSE 58176
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57984: LD_ADDR_VAR 0 9
57988: PUSH
57989: LD_VAR 0 4
57993: PUSH
57994: LD_VAR 0 8
57998: PUSH
57999: LD_VAR 0 7
58003: UNION
58004: PUSH
58005: LD_VAR 0 6
58009: UNION
58010: DIFF
58011: PPUSH
58012: LD_INT 2
58014: PPUSH
58015: CALL 45796 0 2
58019: ST_TO_ADDR
// p := [ ] ;
58020: LD_ADDR_VAR 0 11
58024: PUSH
58025: EMPTY
58026: ST_TO_ADDR
// if sort then
58027: LD_VAR 0 9
58031: IFFALSE 58147
// for i = 1 to 6 - eng do
58033: LD_ADDR_VAR 0 3
58037: PUSH
58038: DOUBLE
58039: LD_INT 1
58041: DEC
58042: ST_TO_ADDR
58043: LD_INT 6
58045: PUSH
58046: LD_VAR 0 6
58050: MINUS
58051: PUSH
58052: FOR_TO
58053: IFFALSE 58145
// begin if i = sort then
58055: LD_VAR 0 3
58059: PUSH
58060: LD_VAR 0 9
58064: EQUAL
58065: IFFALSE 58069
// break ;
58067: GO 58145
// if GetClass ( i ) = 2 then
58069: LD_VAR 0 3
58073: PPUSH
58074: CALL_OW 257
58078: PUSH
58079: LD_INT 2
58081: EQUAL
58082: IFFALSE 58086
// continue ;
58084: GO 58052
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58086: LD_ADDR_VAR 0 11
58090: PUSH
58091: LD_VAR 0 11
58095: PPUSH
58096: LD_VAR 0 11
58100: PUSH
58101: LD_INT 1
58103: PLUS
58104: PPUSH
58105: LD_VAR 0 9
58109: PUSH
58110: LD_VAR 0 3
58114: ARRAY
58115: PPUSH
58116: CALL_OW 2
58120: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58121: LD_ADDR_VAR 0 4
58125: PUSH
58126: LD_VAR 0 4
58130: PUSH
58131: LD_VAR 0 9
58135: PUSH
58136: LD_VAR 0 3
58140: ARRAY
58141: DIFF
58142: ST_TO_ADDR
// end ;
58143: GO 58052
58145: POP
58146: POP
// if p then
58147: LD_VAR 0 11
58151: IFFALSE 58176
// result := Replace ( result , 2 , p ) ;
58153: LD_ADDR_VAR 0 2
58157: PUSH
58158: LD_VAR 0 2
58162: PPUSH
58163: LD_INT 2
58165: PPUSH
58166: LD_VAR 0 11
58170: PPUSH
58171: CALL_OW 1
58175: ST_TO_ADDR
// end ; exit ;
58176: GO 59564
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58178: LD_EXP 70
58182: PUSH
58183: LD_EXP 69
58187: PUSH
58188: LD_VAR 0 1
58192: ARRAY
58193: ARRAY
58194: NOT
58195: PUSH
58196: LD_EXP 43
58200: PUSH
58201: LD_VAR 0 1
58205: ARRAY
58206: PPUSH
58207: LD_INT 30
58209: PUSH
58210: LD_INT 3
58212: PUSH
58213: EMPTY
58214: LIST
58215: LIST
58216: PPUSH
58217: CALL_OW 72
58221: AND
58222: PUSH
58223: LD_EXP 48
58227: PUSH
58228: LD_VAR 0 1
58232: ARRAY
58233: AND
58234: IFFALSE 58842
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58236: LD_ADDR_EXP 85
58240: PUSH
58241: LD_EXP 85
58245: PPUSH
58246: LD_VAR 0 1
58250: PPUSH
58251: LD_INT 5
58253: PPUSH
58254: CALL_OW 1
58258: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58259: LD_ADDR_VAR 0 2
58263: PUSH
58264: LD_INT 0
58266: PUSH
58267: LD_INT 0
58269: PUSH
58270: LD_INT 0
58272: PUSH
58273: LD_INT 0
58275: PUSH
58276: EMPTY
58277: LIST
58278: LIST
58279: LIST
58280: LIST
58281: ST_TO_ADDR
// if sci > 1 then
58282: LD_VAR 0 8
58286: PUSH
58287: LD_INT 1
58289: GREATER
58290: IFFALSE 58318
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58292: LD_ADDR_VAR 0 4
58296: PUSH
58297: LD_VAR 0 4
58301: PUSH
58302: LD_VAR 0 8
58306: PUSH
58307: LD_VAR 0 8
58311: PUSH
58312: LD_INT 1
58314: ARRAY
58315: DIFF
58316: DIFF
58317: ST_TO_ADDR
// if tmp and not sci then
58318: LD_VAR 0 4
58322: PUSH
58323: LD_VAR 0 8
58327: NOT
58328: AND
58329: IFFALSE 58398
// begin sort := SortBySkill ( tmp , 4 ) ;
58331: LD_ADDR_VAR 0 9
58335: PUSH
58336: LD_VAR 0 4
58340: PPUSH
58341: LD_INT 4
58343: PPUSH
58344: CALL 45796 0 2
58348: ST_TO_ADDR
// if sort then
58349: LD_VAR 0 9
58353: IFFALSE 58369
// p := sort [ 1 ] ;
58355: LD_ADDR_VAR 0 11
58359: PUSH
58360: LD_VAR 0 9
58364: PUSH
58365: LD_INT 1
58367: ARRAY
58368: ST_TO_ADDR
// if p then
58369: LD_VAR 0 11
58373: IFFALSE 58398
// result := Replace ( result , 4 , p ) ;
58375: LD_ADDR_VAR 0 2
58379: PUSH
58380: LD_VAR 0 2
58384: PPUSH
58385: LD_INT 4
58387: PPUSH
58388: LD_VAR 0 11
58392: PPUSH
58393: CALL_OW 1
58397: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58398: LD_ADDR_VAR 0 4
58402: PUSH
58403: LD_VAR 0 4
58407: PUSH
58408: LD_VAR 0 7
58412: DIFF
58413: ST_TO_ADDR
// if tmp and mech < 6 then
58414: LD_VAR 0 4
58418: PUSH
58419: LD_VAR 0 7
58423: PUSH
58424: LD_INT 6
58426: LESS
58427: AND
58428: IFFALSE 58616
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58430: LD_ADDR_VAR 0 9
58434: PUSH
58435: LD_VAR 0 4
58439: PUSH
58440: LD_VAR 0 8
58444: PUSH
58445: LD_VAR 0 7
58449: UNION
58450: DIFF
58451: PPUSH
58452: LD_INT 3
58454: PPUSH
58455: CALL 45796 0 2
58459: ST_TO_ADDR
// p := [ ] ;
58460: LD_ADDR_VAR 0 11
58464: PUSH
58465: EMPTY
58466: ST_TO_ADDR
// if sort then
58467: LD_VAR 0 9
58471: IFFALSE 58587
// for i = 1 to 6 - mech do
58473: LD_ADDR_VAR 0 3
58477: PUSH
58478: DOUBLE
58479: LD_INT 1
58481: DEC
58482: ST_TO_ADDR
58483: LD_INT 6
58485: PUSH
58486: LD_VAR 0 7
58490: MINUS
58491: PUSH
58492: FOR_TO
58493: IFFALSE 58585
// begin if i = sort then
58495: LD_VAR 0 3
58499: PUSH
58500: LD_VAR 0 9
58504: EQUAL
58505: IFFALSE 58509
// break ;
58507: GO 58585
// if GetClass ( i ) = 3 then
58509: LD_VAR 0 3
58513: PPUSH
58514: CALL_OW 257
58518: PUSH
58519: LD_INT 3
58521: EQUAL
58522: IFFALSE 58526
// continue ;
58524: GO 58492
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58526: LD_ADDR_VAR 0 11
58530: PUSH
58531: LD_VAR 0 11
58535: PPUSH
58536: LD_VAR 0 11
58540: PUSH
58541: LD_INT 1
58543: PLUS
58544: PPUSH
58545: LD_VAR 0 9
58549: PUSH
58550: LD_VAR 0 3
58554: ARRAY
58555: PPUSH
58556: CALL_OW 2
58560: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58561: LD_ADDR_VAR 0 4
58565: PUSH
58566: LD_VAR 0 4
58570: PUSH
58571: LD_VAR 0 9
58575: PUSH
58576: LD_VAR 0 3
58580: ARRAY
58581: DIFF
58582: ST_TO_ADDR
// end ;
58583: GO 58492
58585: POP
58586: POP
// if p then
58587: LD_VAR 0 11
58591: IFFALSE 58616
// result := Replace ( result , 3 , p ) ;
58593: LD_ADDR_VAR 0 2
58597: PUSH
58598: LD_VAR 0 2
58602: PPUSH
58603: LD_INT 3
58605: PPUSH
58606: LD_VAR 0 11
58610: PPUSH
58611: CALL_OW 1
58615: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58616: LD_ADDR_VAR 0 4
58620: PUSH
58621: LD_VAR 0 4
58625: PUSH
58626: LD_VAR 0 6
58630: DIFF
58631: ST_TO_ADDR
// if tmp and eng < 6 then
58632: LD_VAR 0 4
58636: PUSH
58637: LD_VAR 0 6
58641: PUSH
58642: LD_INT 6
58644: LESS
58645: AND
58646: IFFALSE 58840
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58648: LD_ADDR_VAR 0 9
58652: PUSH
58653: LD_VAR 0 4
58657: PUSH
58658: LD_VAR 0 8
58662: PUSH
58663: LD_VAR 0 7
58667: UNION
58668: PUSH
58669: LD_VAR 0 6
58673: UNION
58674: DIFF
58675: PPUSH
58676: LD_INT 2
58678: PPUSH
58679: CALL 45796 0 2
58683: ST_TO_ADDR
// p := [ ] ;
58684: LD_ADDR_VAR 0 11
58688: PUSH
58689: EMPTY
58690: ST_TO_ADDR
// if sort then
58691: LD_VAR 0 9
58695: IFFALSE 58811
// for i = 1 to 6 - eng do
58697: LD_ADDR_VAR 0 3
58701: PUSH
58702: DOUBLE
58703: LD_INT 1
58705: DEC
58706: ST_TO_ADDR
58707: LD_INT 6
58709: PUSH
58710: LD_VAR 0 6
58714: MINUS
58715: PUSH
58716: FOR_TO
58717: IFFALSE 58809
// begin if i = sort then
58719: LD_VAR 0 3
58723: PUSH
58724: LD_VAR 0 9
58728: EQUAL
58729: IFFALSE 58733
// break ;
58731: GO 58809
// if GetClass ( i ) = 2 then
58733: LD_VAR 0 3
58737: PPUSH
58738: CALL_OW 257
58742: PUSH
58743: LD_INT 2
58745: EQUAL
58746: IFFALSE 58750
// continue ;
58748: GO 58716
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58750: LD_ADDR_VAR 0 11
58754: PUSH
58755: LD_VAR 0 11
58759: PPUSH
58760: LD_VAR 0 11
58764: PUSH
58765: LD_INT 1
58767: PLUS
58768: PPUSH
58769: LD_VAR 0 9
58773: PUSH
58774: LD_VAR 0 3
58778: ARRAY
58779: PPUSH
58780: CALL_OW 2
58784: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58785: LD_ADDR_VAR 0 4
58789: PUSH
58790: LD_VAR 0 4
58794: PUSH
58795: LD_VAR 0 9
58799: PUSH
58800: LD_VAR 0 3
58804: ARRAY
58805: DIFF
58806: ST_TO_ADDR
// end ;
58807: GO 58716
58809: POP
58810: POP
// if p then
58811: LD_VAR 0 11
58815: IFFALSE 58840
// result := Replace ( result , 2 , p ) ;
58817: LD_ADDR_VAR 0 2
58821: PUSH
58822: LD_VAR 0 2
58826: PPUSH
58827: LD_INT 2
58829: PPUSH
58830: LD_VAR 0 11
58834: PPUSH
58835: CALL_OW 1
58839: ST_TO_ADDR
// end ; exit ;
58840: GO 59564
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58842: LD_EXP 70
58846: PUSH
58847: LD_EXP 69
58851: PUSH
58852: LD_VAR 0 1
58856: ARRAY
58857: ARRAY
58858: NOT
58859: PUSH
58860: LD_EXP 43
58864: PUSH
58865: LD_VAR 0 1
58869: ARRAY
58870: PPUSH
58871: LD_INT 30
58873: PUSH
58874: LD_INT 3
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PPUSH
58881: CALL_OW 72
58885: AND
58886: PUSH
58887: LD_EXP 48
58891: PUSH
58892: LD_VAR 0 1
58896: ARRAY
58897: NOT
58898: AND
58899: IFFALSE 59564
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58901: LD_ADDR_EXP 85
58905: PUSH
58906: LD_EXP 85
58910: PPUSH
58911: LD_VAR 0 1
58915: PPUSH
58916: LD_INT 6
58918: PPUSH
58919: CALL_OW 1
58923: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58924: LD_ADDR_VAR 0 2
58928: PUSH
58929: LD_INT 0
58931: PUSH
58932: LD_INT 0
58934: PUSH
58935: LD_INT 0
58937: PUSH
58938: LD_INT 0
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: LIST
58945: LIST
58946: ST_TO_ADDR
// if sci >= 1 then
58947: LD_VAR 0 8
58951: PUSH
58952: LD_INT 1
58954: GREATEREQUAL
58955: IFFALSE 58977
// tmp := tmp diff sci [ 1 ] ;
58957: LD_ADDR_VAR 0 4
58961: PUSH
58962: LD_VAR 0 4
58966: PUSH
58967: LD_VAR 0 8
58971: PUSH
58972: LD_INT 1
58974: ARRAY
58975: DIFF
58976: ST_TO_ADDR
// if tmp and not sci then
58977: LD_VAR 0 4
58981: PUSH
58982: LD_VAR 0 8
58986: NOT
58987: AND
58988: IFFALSE 59057
// begin sort := SortBySkill ( tmp , 4 ) ;
58990: LD_ADDR_VAR 0 9
58994: PUSH
58995: LD_VAR 0 4
58999: PPUSH
59000: LD_INT 4
59002: PPUSH
59003: CALL 45796 0 2
59007: ST_TO_ADDR
// if sort then
59008: LD_VAR 0 9
59012: IFFALSE 59028
// p := sort [ 1 ] ;
59014: LD_ADDR_VAR 0 11
59018: PUSH
59019: LD_VAR 0 9
59023: PUSH
59024: LD_INT 1
59026: ARRAY
59027: ST_TO_ADDR
// if p then
59028: LD_VAR 0 11
59032: IFFALSE 59057
// result := Replace ( result , 4 , p ) ;
59034: LD_ADDR_VAR 0 2
59038: PUSH
59039: LD_VAR 0 2
59043: PPUSH
59044: LD_INT 4
59046: PPUSH
59047: LD_VAR 0 11
59051: PPUSH
59052: CALL_OW 1
59056: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59057: LD_ADDR_VAR 0 4
59061: PUSH
59062: LD_VAR 0 4
59066: PUSH
59067: LD_VAR 0 7
59071: DIFF
59072: ST_TO_ADDR
// if tmp and mech < 6 then
59073: LD_VAR 0 4
59077: PUSH
59078: LD_VAR 0 7
59082: PUSH
59083: LD_INT 6
59085: LESS
59086: AND
59087: IFFALSE 59269
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59089: LD_ADDR_VAR 0 9
59093: PUSH
59094: LD_VAR 0 4
59098: PUSH
59099: LD_VAR 0 7
59103: DIFF
59104: PPUSH
59105: LD_INT 3
59107: PPUSH
59108: CALL 45796 0 2
59112: ST_TO_ADDR
// p := [ ] ;
59113: LD_ADDR_VAR 0 11
59117: PUSH
59118: EMPTY
59119: ST_TO_ADDR
// if sort then
59120: LD_VAR 0 9
59124: IFFALSE 59240
// for i = 1 to 6 - mech do
59126: LD_ADDR_VAR 0 3
59130: PUSH
59131: DOUBLE
59132: LD_INT 1
59134: DEC
59135: ST_TO_ADDR
59136: LD_INT 6
59138: PUSH
59139: LD_VAR 0 7
59143: MINUS
59144: PUSH
59145: FOR_TO
59146: IFFALSE 59238
// begin if i = sort then
59148: LD_VAR 0 3
59152: PUSH
59153: LD_VAR 0 9
59157: EQUAL
59158: IFFALSE 59162
// break ;
59160: GO 59238
// if GetClass ( i ) = 3 then
59162: LD_VAR 0 3
59166: PPUSH
59167: CALL_OW 257
59171: PUSH
59172: LD_INT 3
59174: EQUAL
59175: IFFALSE 59179
// continue ;
59177: GO 59145
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59179: LD_ADDR_VAR 0 11
59183: PUSH
59184: LD_VAR 0 11
59188: PPUSH
59189: LD_VAR 0 11
59193: PUSH
59194: LD_INT 1
59196: PLUS
59197: PPUSH
59198: LD_VAR 0 9
59202: PUSH
59203: LD_VAR 0 3
59207: ARRAY
59208: PPUSH
59209: CALL_OW 2
59213: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59214: LD_ADDR_VAR 0 4
59218: PUSH
59219: LD_VAR 0 4
59223: PUSH
59224: LD_VAR 0 9
59228: PUSH
59229: LD_VAR 0 3
59233: ARRAY
59234: DIFF
59235: ST_TO_ADDR
// end ;
59236: GO 59145
59238: POP
59239: POP
// if p then
59240: LD_VAR 0 11
59244: IFFALSE 59269
// result := Replace ( result , 3 , p ) ;
59246: LD_ADDR_VAR 0 2
59250: PUSH
59251: LD_VAR 0 2
59255: PPUSH
59256: LD_INT 3
59258: PPUSH
59259: LD_VAR 0 11
59263: PPUSH
59264: CALL_OW 1
59268: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59269: LD_ADDR_VAR 0 4
59273: PUSH
59274: LD_VAR 0 4
59278: PUSH
59279: LD_VAR 0 6
59283: DIFF
59284: ST_TO_ADDR
// if tmp and eng < 4 then
59285: LD_VAR 0 4
59289: PUSH
59290: LD_VAR 0 6
59294: PUSH
59295: LD_INT 4
59297: LESS
59298: AND
59299: IFFALSE 59489
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59301: LD_ADDR_VAR 0 9
59305: PUSH
59306: LD_VAR 0 4
59310: PUSH
59311: LD_VAR 0 7
59315: PUSH
59316: LD_VAR 0 6
59320: UNION
59321: DIFF
59322: PPUSH
59323: LD_INT 2
59325: PPUSH
59326: CALL 45796 0 2
59330: ST_TO_ADDR
// p := [ ] ;
59331: LD_ADDR_VAR 0 11
59335: PUSH
59336: EMPTY
59337: ST_TO_ADDR
// if sort then
59338: LD_VAR 0 9
59342: IFFALSE 59458
// for i = 1 to 4 - eng do
59344: LD_ADDR_VAR 0 3
59348: PUSH
59349: DOUBLE
59350: LD_INT 1
59352: DEC
59353: ST_TO_ADDR
59354: LD_INT 4
59356: PUSH
59357: LD_VAR 0 6
59361: MINUS
59362: PUSH
59363: FOR_TO
59364: IFFALSE 59456
// begin if i = sort then
59366: LD_VAR 0 3
59370: PUSH
59371: LD_VAR 0 9
59375: EQUAL
59376: IFFALSE 59380
// break ;
59378: GO 59456
// if GetClass ( i ) = 2 then
59380: LD_VAR 0 3
59384: PPUSH
59385: CALL_OW 257
59389: PUSH
59390: LD_INT 2
59392: EQUAL
59393: IFFALSE 59397
// continue ;
59395: GO 59363
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59397: LD_ADDR_VAR 0 11
59401: PUSH
59402: LD_VAR 0 11
59406: PPUSH
59407: LD_VAR 0 11
59411: PUSH
59412: LD_INT 1
59414: PLUS
59415: PPUSH
59416: LD_VAR 0 9
59420: PUSH
59421: LD_VAR 0 3
59425: ARRAY
59426: PPUSH
59427: CALL_OW 2
59431: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59432: LD_ADDR_VAR 0 4
59436: PUSH
59437: LD_VAR 0 4
59441: PUSH
59442: LD_VAR 0 9
59446: PUSH
59447: LD_VAR 0 3
59451: ARRAY
59452: DIFF
59453: ST_TO_ADDR
// end ;
59454: GO 59363
59456: POP
59457: POP
// if p then
59458: LD_VAR 0 11
59462: IFFALSE 59487
// result := Replace ( result , 2 , p ) ;
59464: LD_ADDR_VAR 0 2
59468: PUSH
59469: LD_VAR 0 2
59473: PPUSH
59474: LD_INT 2
59476: PPUSH
59477: LD_VAR 0 11
59481: PPUSH
59482: CALL_OW 1
59486: ST_TO_ADDR
// end else
59487: GO 59533
// for i = eng downto 5 do
59489: LD_ADDR_VAR 0 3
59493: PUSH
59494: DOUBLE
59495: LD_VAR 0 6
59499: INC
59500: ST_TO_ADDR
59501: LD_INT 5
59503: PUSH
59504: FOR_DOWNTO
59505: IFFALSE 59531
// tmp := tmp union eng [ i ] ;
59507: LD_ADDR_VAR 0 4
59511: PUSH
59512: LD_VAR 0 4
59516: PUSH
59517: LD_VAR 0 6
59521: PUSH
59522: LD_VAR 0 3
59526: ARRAY
59527: UNION
59528: ST_TO_ADDR
59529: GO 59504
59531: POP
59532: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59533: LD_ADDR_VAR 0 2
59537: PUSH
59538: LD_VAR 0 2
59542: PPUSH
59543: LD_INT 1
59545: PPUSH
59546: LD_VAR 0 4
59550: PUSH
59551: LD_VAR 0 5
59555: DIFF
59556: PPUSH
59557: CALL_OW 1
59561: ST_TO_ADDR
// exit ;
59562: GO 59564
// end ; end ;
59564: LD_VAR 0 2
59568: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59569: LD_INT 0
59571: PPUSH
59572: PPUSH
59573: PPUSH
// if not mc_bases then
59574: LD_EXP 43
59578: NOT
59579: IFFALSE 59583
// exit ;
59581: GO 59725
// for i = 1 to mc_bases do
59583: LD_ADDR_VAR 0 2
59587: PUSH
59588: DOUBLE
59589: LD_INT 1
59591: DEC
59592: ST_TO_ADDR
59593: LD_EXP 43
59597: PUSH
59598: FOR_TO
59599: IFFALSE 59716
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59601: LD_ADDR_VAR 0 3
59605: PUSH
59606: LD_EXP 43
59610: PUSH
59611: LD_VAR 0 2
59615: ARRAY
59616: PPUSH
59617: LD_INT 21
59619: PUSH
59620: LD_INT 3
59622: PUSH
59623: EMPTY
59624: LIST
59625: LIST
59626: PUSH
59627: LD_INT 3
59629: PUSH
59630: LD_INT 2
59632: PUSH
59633: LD_INT 30
59635: PUSH
59636: LD_INT 29
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 30
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: LIST
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: PUSH
59662: LD_INT 3
59664: PUSH
59665: LD_INT 24
59667: PUSH
59668: LD_INT 1000
59670: PUSH
59671: EMPTY
59672: LIST
59673: LIST
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: LIST
59683: PPUSH
59684: CALL_OW 72
59688: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59689: LD_ADDR_EXP 44
59693: PUSH
59694: LD_EXP 44
59698: PPUSH
59699: LD_VAR 0 2
59703: PPUSH
59704: LD_VAR 0 3
59708: PPUSH
59709: CALL_OW 1
59713: ST_TO_ADDR
// end ;
59714: GO 59598
59716: POP
59717: POP
// RaiseSailEvent ( 101 ) ;
59718: LD_INT 101
59720: PPUSH
59721: CALL_OW 427
// end ;
59725: LD_VAR 0 1
59729: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59730: LD_INT 0
59732: PPUSH
59733: PPUSH
59734: PPUSH
59735: PPUSH
59736: PPUSH
59737: PPUSH
59738: PPUSH
// if not mc_bases then
59739: LD_EXP 43
59743: NOT
59744: IFFALSE 59748
// exit ;
59746: GO 60310
// for i = 1 to mc_bases do
59748: LD_ADDR_VAR 0 2
59752: PUSH
59753: DOUBLE
59754: LD_INT 1
59756: DEC
59757: ST_TO_ADDR
59758: LD_EXP 43
59762: PUSH
59763: FOR_TO
59764: IFFALSE 60301
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59766: LD_ADDR_VAR 0 5
59770: PUSH
59771: LD_EXP 43
59775: PUSH
59776: LD_VAR 0 2
59780: ARRAY
59781: PUSH
59782: LD_EXP 72
59786: PUSH
59787: LD_VAR 0 2
59791: ARRAY
59792: UNION
59793: PPUSH
59794: LD_INT 21
59796: PUSH
59797: LD_INT 1
59799: PUSH
59800: EMPTY
59801: LIST
59802: LIST
59803: PUSH
59804: LD_INT 1
59806: PUSH
59807: LD_INT 3
59809: PUSH
59810: LD_INT 54
59812: PUSH
59813: EMPTY
59814: LIST
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: LD_INT 3
59822: PUSH
59823: LD_INT 24
59825: PUSH
59826: LD_INT 1000
59828: PUSH
59829: EMPTY
59830: LIST
59831: LIST
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: LIST
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PPUSH
59846: CALL_OW 72
59850: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59851: LD_ADDR_VAR 0 6
59855: PUSH
59856: LD_EXP 43
59860: PUSH
59861: LD_VAR 0 2
59865: ARRAY
59866: PPUSH
59867: LD_INT 21
59869: PUSH
59870: LD_INT 1
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PUSH
59877: LD_INT 1
59879: PUSH
59880: LD_INT 3
59882: PUSH
59883: LD_INT 54
59885: PUSH
59886: EMPTY
59887: LIST
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: PUSH
59893: LD_INT 3
59895: PUSH
59896: LD_INT 24
59898: PUSH
59899: LD_INT 250
59901: PUSH
59902: EMPTY
59903: LIST
59904: LIST
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: LIST
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PPUSH
59919: CALL_OW 72
59923: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59924: LD_ADDR_VAR 0 7
59928: PUSH
59929: LD_VAR 0 5
59933: PUSH
59934: LD_VAR 0 6
59938: DIFF
59939: ST_TO_ADDR
// if not need_heal_1 then
59940: LD_VAR 0 6
59944: NOT
59945: IFFALSE 59978
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59947: LD_ADDR_EXP 46
59951: PUSH
59952: LD_EXP 46
59956: PPUSH
59957: LD_VAR 0 2
59961: PUSH
59962: LD_INT 1
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: PPUSH
59969: EMPTY
59970: PPUSH
59971: CALL 14949 0 3
59975: ST_TO_ADDR
59976: GO 60048
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59978: LD_ADDR_EXP 46
59982: PUSH
59983: LD_EXP 46
59987: PPUSH
59988: LD_VAR 0 2
59992: PUSH
59993: LD_INT 1
59995: PUSH
59996: EMPTY
59997: LIST
59998: LIST
59999: PPUSH
60000: LD_EXP 46
60004: PUSH
60005: LD_VAR 0 2
60009: ARRAY
60010: PUSH
60011: LD_INT 1
60013: ARRAY
60014: PPUSH
60015: LD_INT 3
60017: PUSH
60018: LD_INT 24
60020: PUSH
60021: LD_INT 1000
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PPUSH
60032: CALL_OW 72
60036: PUSH
60037: LD_VAR 0 6
60041: UNION
60042: PPUSH
60043: CALL 14949 0 3
60047: ST_TO_ADDR
// if not need_heal_2 then
60048: LD_VAR 0 7
60052: NOT
60053: IFFALSE 60086
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60055: LD_ADDR_EXP 46
60059: PUSH
60060: LD_EXP 46
60064: PPUSH
60065: LD_VAR 0 2
60069: PUSH
60070: LD_INT 2
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: PPUSH
60077: EMPTY
60078: PPUSH
60079: CALL 14949 0 3
60083: ST_TO_ADDR
60084: GO 60118
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60086: LD_ADDR_EXP 46
60090: PUSH
60091: LD_EXP 46
60095: PPUSH
60096: LD_VAR 0 2
60100: PUSH
60101: LD_INT 2
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: PPUSH
60108: LD_VAR 0 7
60112: PPUSH
60113: CALL 14949 0 3
60117: ST_TO_ADDR
// if need_heal_2 then
60118: LD_VAR 0 7
60122: IFFALSE 60283
// for j in need_heal_2 do
60124: LD_ADDR_VAR 0 3
60128: PUSH
60129: LD_VAR 0 7
60133: PUSH
60134: FOR_IN
60135: IFFALSE 60281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60137: LD_ADDR_VAR 0 5
60141: PUSH
60142: LD_EXP 43
60146: PUSH
60147: LD_VAR 0 2
60151: ARRAY
60152: PPUSH
60153: LD_INT 2
60155: PUSH
60156: LD_INT 30
60158: PUSH
60159: LD_INT 6
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: PUSH
60166: LD_INT 30
60168: PUSH
60169: LD_INT 7
60171: PUSH
60172: EMPTY
60173: LIST
60174: LIST
60175: PUSH
60176: LD_INT 30
60178: PUSH
60179: LD_INT 8
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: LD_INT 30
60188: PUSH
60189: LD_INT 0
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: LD_INT 30
60198: PUSH
60199: LD_INT 1
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: PUSH
60206: EMPTY
60207: LIST
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: LIST
60213: PPUSH
60214: CALL_OW 72
60218: ST_TO_ADDR
// if tmp then
60219: LD_VAR 0 5
60223: IFFALSE 60279
// begin k := NearestUnitToUnit ( tmp , j ) ;
60225: LD_ADDR_VAR 0 4
60229: PUSH
60230: LD_VAR 0 5
60234: PPUSH
60235: LD_VAR 0 3
60239: PPUSH
60240: CALL_OW 74
60244: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60245: LD_VAR 0 3
60249: PPUSH
60250: LD_VAR 0 4
60254: PPUSH
60255: CALL_OW 296
60259: PUSH
60260: LD_INT 5
60262: GREATER
60263: IFFALSE 60279
// ComMoveToNearbyEntrance ( j , k ) ;
60265: LD_VAR 0 3
60269: PPUSH
60270: LD_VAR 0 4
60274: PPUSH
60275: CALL 48157 0 2
// end ; end ;
60279: GO 60134
60281: POP
60282: POP
// if not need_heal_1 and not need_heal_2 then
60283: LD_VAR 0 6
60287: NOT
60288: PUSH
60289: LD_VAR 0 7
60293: NOT
60294: AND
60295: IFFALSE 60299
// continue ;
60297: GO 59763
// end ;
60299: GO 59763
60301: POP
60302: POP
// RaiseSailEvent ( 102 ) ;
60303: LD_INT 102
60305: PPUSH
60306: CALL_OW 427
// end ;
60310: LD_VAR 0 1
60314: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60315: LD_INT 0
60317: PPUSH
60318: PPUSH
60319: PPUSH
60320: PPUSH
60321: PPUSH
60322: PPUSH
60323: PPUSH
60324: PPUSH
// if not mc_bases then
60325: LD_EXP 43
60329: NOT
60330: IFFALSE 60334
// exit ;
60332: GO 61245
// for i = 1 to mc_bases do
60334: LD_ADDR_VAR 0 2
60338: PUSH
60339: DOUBLE
60340: LD_INT 1
60342: DEC
60343: ST_TO_ADDR
60344: LD_EXP 43
60348: PUSH
60349: FOR_TO
60350: IFFALSE 61243
// begin if not mc_building_need_repair [ i ] then
60352: LD_EXP 44
60356: PUSH
60357: LD_VAR 0 2
60361: ARRAY
60362: NOT
60363: IFFALSE 60548
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60365: LD_ADDR_VAR 0 6
60369: PUSH
60370: LD_EXP 62
60374: PUSH
60375: LD_VAR 0 2
60379: ARRAY
60380: PPUSH
60381: LD_INT 3
60383: PUSH
60384: LD_INT 24
60386: PUSH
60387: LD_INT 1000
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: EMPTY
60395: LIST
60396: LIST
60397: PUSH
60398: LD_INT 2
60400: PUSH
60401: LD_INT 34
60403: PUSH
60404: LD_INT 13
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: PUSH
60411: LD_INT 34
60413: PUSH
60414: LD_INT 52
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: PUSH
60421: LD_INT 34
60423: PUSH
60424: LD_INT 88
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: PUSH
60431: EMPTY
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: PUSH
60437: EMPTY
60438: LIST
60439: LIST
60440: PPUSH
60441: CALL_OW 72
60445: ST_TO_ADDR
// if cranes then
60446: LD_VAR 0 6
60450: IFFALSE 60512
// for j in cranes do
60452: LD_ADDR_VAR 0 3
60456: PUSH
60457: LD_VAR 0 6
60461: PUSH
60462: FOR_IN
60463: IFFALSE 60510
// if not IsInArea ( j , mc_parking [ i ] ) then
60465: LD_VAR 0 3
60469: PPUSH
60470: LD_EXP 67
60474: PUSH
60475: LD_VAR 0 2
60479: ARRAY
60480: PPUSH
60481: CALL_OW 308
60485: NOT
60486: IFFALSE 60508
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60488: LD_VAR 0 3
60492: PPUSH
60493: LD_EXP 67
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PPUSH
60504: CALL_OW 113
60508: GO 60462
60510: POP
60511: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60512: LD_ADDR_EXP 45
60516: PUSH
60517: LD_EXP 45
60521: PPUSH
60522: LD_VAR 0 2
60526: PPUSH
60527: EMPTY
60528: PPUSH
60529: CALL_OW 1
60533: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60534: LD_VAR 0 2
60538: PPUSH
60539: LD_INT 101
60541: PPUSH
60542: CALL 55402 0 2
// continue ;
60546: GO 60349
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60548: LD_ADDR_EXP 49
60552: PUSH
60553: LD_EXP 49
60557: PPUSH
60558: LD_VAR 0 2
60562: PPUSH
60563: EMPTY
60564: PPUSH
60565: CALL_OW 1
60569: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60570: LD_VAR 0 2
60574: PPUSH
60575: LD_INT 103
60577: PPUSH
60578: CALL 55402 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60582: LD_ADDR_VAR 0 5
60586: PUSH
60587: LD_EXP 43
60591: PUSH
60592: LD_VAR 0 2
60596: ARRAY
60597: PUSH
60598: LD_EXP 72
60602: PUSH
60603: LD_VAR 0 2
60607: ARRAY
60608: UNION
60609: PPUSH
60610: LD_INT 2
60612: PUSH
60613: LD_INT 25
60615: PUSH
60616: LD_INT 2
60618: PUSH
60619: EMPTY
60620: LIST
60621: LIST
60622: PUSH
60623: LD_INT 25
60625: PUSH
60626: LD_INT 16
60628: PUSH
60629: EMPTY
60630: LIST
60631: LIST
60632: PUSH
60633: EMPTY
60634: LIST
60635: LIST
60636: LIST
60637: PUSH
60638: EMPTY
60639: LIST
60640: PPUSH
60641: CALL_OW 72
60645: ST_TO_ADDR
// if mc_need_heal [ i ] then
60646: LD_EXP 46
60650: PUSH
60651: LD_VAR 0 2
60655: ARRAY
60656: IFFALSE 60700
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60658: LD_ADDR_VAR 0 5
60662: PUSH
60663: LD_VAR 0 5
60667: PUSH
60668: LD_EXP 46
60672: PUSH
60673: LD_VAR 0 2
60677: ARRAY
60678: PUSH
60679: LD_INT 1
60681: ARRAY
60682: PUSH
60683: LD_EXP 46
60687: PUSH
60688: LD_VAR 0 2
60692: ARRAY
60693: PUSH
60694: LD_INT 2
60696: ARRAY
60697: UNION
60698: DIFF
60699: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60700: LD_ADDR_VAR 0 6
60704: PUSH
60705: LD_EXP 62
60709: PUSH
60710: LD_VAR 0 2
60714: ARRAY
60715: PPUSH
60716: LD_INT 2
60718: PUSH
60719: LD_INT 34
60721: PUSH
60722: LD_INT 13
60724: PUSH
60725: EMPTY
60726: LIST
60727: LIST
60728: PUSH
60729: LD_INT 34
60731: PUSH
60732: LD_INT 52
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: LD_INT 34
60741: PUSH
60742: LD_INT 88
60744: PUSH
60745: EMPTY
60746: LIST
60747: LIST
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: LIST
60753: LIST
60754: PPUSH
60755: CALL_OW 72
60759: ST_TO_ADDR
// if cranes then
60760: LD_VAR 0 6
60764: IFFALSE 60932
// begin for j in cranes do
60766: LD_ADDR_VAR 0 3
60770: PUSH
60771: LD_VAR 0 6
60775: PUSH
60776: FOR_IN
60777: IFFALSE 60930
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60779: LD_VAR 0 3
60783: PPUSH
60784: CALL_OW 256
60788: PUSH
60789: LD_INT 1000
60791: EQUAL
60792: PUSH
60793: LD_VAR 0 3
60797: PPUSH
60798: CALL_OW 314
60802: NOT
60803: AND
60804: IFFALSE 60870
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
60806: LD_ADDR_VAR 0 8
60810: PUSH
60811: LD_EXP 44
60815: PUSH
60816: LD_VAR 0 2
60820: ARRAY
60821: PPUSH
60822: LD_VAR 0 3
60826: PPUSH
60827: CALL_OW 74
60831: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60832: LD_VAR 0 8
60836: PPUSH
60837: LD_INT 16
60839: PPUSH
60840: CALL 17546 0 2
60844: PUSH
60845: LD_INT 4
60847: ARRAY
60848: PUSH
60849: LD_INT 10
60851: LESS
60852: IFFALSE 60868
// ComRepairBuilding ( j , to_repair ) ;
60854: LD_VAR 0 3
60858: PPUSH
60859: LD_VAR 0 8
60863: PPUSH
60864: CALL_OW 130
// end else
60868: GO 60928
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60870: LD_VAR 0 3
60874: PPUSH
60875: CALL_OW 256
60879: PUSH
60880: LD_INT 500
60882: LESS
60883: PUSH
60884: LD_VAR 0 3
60888: PPUSH
60889: LD_EXP 67
60893: PUSH
60894: LD_VAR 0 2
60898: ARRAY
60899: PPUSH
60900: CALL_OW 308
60904: NOT
60905: AND
60906: IFFALSE 60928
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60908: LD_VAR 0 3
60912: PPUSH
60913: LD_EXP 67
60917: PUSH
60918: LD_VAR 0 2
60922: ARRAY
60923: PPUSH
60924: CALL_OW 113
// end ;
60928: GO 60776
60930: POP
60931: POP
// end ; if tmp > 3 then
60932: LD_VAR 0 5
60936: PUSH
60937: LD_INT 3
60939: GREATER
60940: IFFALSE 60960
// tmp := ShrinkArray ( tmp , 4 ) ;
60942: LD_ADDR_VAR 0 5
60946: PUSH
60947: LD_VAR 0 5
60951: PPUSH
60952: LD_INT 4
60954: PPUSH
60955: CALL 47595 0 2
60959: ST_TO_ADDR
// if not tmp then
60960: LD_VAR 0 5
60964: NOT
60965: IFFALSE 60969
// continue ;
60967: GO 60349
// for j in tmp do
60969: LD_ADDR_VAR 0 3
60973: PUSH
60974: LD_VAR 0 5
60978: PUSH
60979: FOR_IN
60980: IFFALSE 61239
// begin if IsInUnit ( j ) then
60982: LD_VAR 0 3
60986: PPUSH
60987: CALL_OW 310
60991: IFFALSE 61002
// ComExitBuilding ( j ) ;
60993: LD_VAR 0 3
60997: PPUSH
60998: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61002: LD_VAR 0 3
61006: PUSH
61007: LD_EXP 45
61011: PUSH
61012: LD_VAR 0 2
61016: ARRAY
61017: IN
61018: NOT
61019: IFFALSE 61077
// begin SetTag ( j , 101 ) ;
61021: LD_VAR 0 3
61025: PPUSH
61026: LD_INT 101
61028: PPUSH
61029: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61033: LD_ADDR_EXP 45
61037: PUSH
61038: LD_EXP 45
61042: PPUSH
61043: LD_VAR 0 2
61047: PUSH
61048: LD_EXP 45
61052: PUSH
61053: LD_VAR 0 2
61057: ARRAY
61058: PUSH
61059: LD_INT 1
61061: PLUS
61062: PUSH
61063: EMPTY
61064: LIST
61065: LIST
61066: PPUSH
61067: LD_VAR 0 3
61071: PPUSH
61072: CALL 14949 0 3
61076: ST_TO_ADDR
// end ; wait ( 1 ) ;
61077: LD_INT 1
61079: PPUSH
61080: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61084: LD_ADDR_VAR 0 7
61088: PUSH
61089: LD_EXP 44
61093: PUSH
61094: LD_VAR 0 2
61098: ARRAY
61099: ST_TO_ADDR
// if mc_scan [ i ] then
61100: LD_EXP 66
61104: PUSH
61105: LD_VAR 0 2
61109: ARRAY
61110: IFFALSE 61172
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61112: LD_ADDR_VAR 0 7
61116: PUSH
61117: LD_EXP 44
61121: PUSH
61122: LD_VAR 0 2
61126: ARRAY
61127: PPUSH
61128: LD_INT 3
61130: PUSH
61131: LD_INT 30
61133: PUSH
61134: LD_INT 32
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: PUSH
61141: LD_INT 30
61143: PUSH
61144: LD_INT 33
61146: PUSH
61147: EMPTY
61148: LIST
61149: LIST
61150: PUSH
61151: LD_INT 30
61153: PUSH
61154: LD_INT 31
61156: PUSH
61157: EMPTY
61158: LIST
61159: LIST
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: LIST
61165: LIST
61166: PPUSH
61167: CALL_OW 72
61171: ST_TO_ADDR
// if not to_repair_tmp then
61172: LD_VAR 0 7
61176: NOT
61177: IFFALSE 61181
// continue ;
61179: GO 60979
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61181: LD_ADDR_VAR 0 8
61185: PUSH
61186: LD_VAR 0 7
61190: PPUSH
61191: LD_VAR 0 3
61195: PPUSH
61196: CALL_OW 74
61200: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61201: LD_VAR 0 8
61205: PPUSH
61206: LD_INT 16
61208: PPUSH
61209: CALL 17546 0 2
61213: PUSH
61214: LD_INT 4
61216: ARRAY
61217: PUSH
61218: LD_INT 14
61220: LESS
61221: IFFALSE 61237
// ComRepairBuilding ( j , to_repair ) ;
61223: LD_VAR 0 3
61227: PPUSH
61228: LD_VAR 0 8
61232: PPUSH
61233: CALL_OW 130
// end ;
61237: GO 60979
61239: POP
61240: POP
// end ;
61241: GO 60349
61243: POP
61244: POP
// end ;
61245: LD_VAR 0 1
61249: RET
// export function MC_Heal ; var i , j , tmp ; begin
61250: LD_INT 0
61252: PPUSH
61253: PPUSH
61254: PPUSH
61255: PPUSH
// if not mc_bases then
61256: LD_EXP 43
61260: NOT
61261: IFFALSE 61265
// exit ;
61263: GO 61667
// for i = 1 to mc_bases do
61265: LD_ADDR_VAR 0 2
61269: PUSH
61270: DOUBLE
61271: LD_INT 1
61273: DEC
61274: ST_TO_ADDR
61275: LD_EXP 43
61279: PUSH
61280: FOR_TO
61281: IFFALSE 61665
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61283: LD_EXP 46
61287: PUSH
61288: LD_VAR 0 2
61292: ARRAY
61293: PUSH
61294: LD_INT 1
61296: ARRAY
61297: NOT
61298: PUSH
61299: LD_EXP 46
61303: PUSH
61304: LD_VAR 0 2
61308: ARRAY
61309: PUSH
61310: LD_INT 2
61312: ARRAY
61313: NOT
61314: AND
61315: IFFALSE 61353
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61317: LD_ADDR_EXP 47
61321: PUSH
61322: LD_EXP 47
61326: PPUSH
61327: LD_VAR 0 2
61331: PPUSH
61332: EMPTY
61333: PPUSH
61334: CALL_OW 1
61338: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61339: LD_VAR 0 2
61343: PPUSH
61344: LD_INT 102
61346: PPUSH
61347: CALL 55402 0 2
// continue ;
61351: GO 61280
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61353: LD_ADDR_VAR 0 4
61357: PUSH
61358: LD_EXP 43
61362: PUSH
61363: LD_VAR 0 2
61367: ARRAY
61368: PPUSH
61369: LD_INT 25
61371: PUSH
61372: LD_INT 4
61374: PUSH
61375: EMPTY
61376: LIST
61377: LIST
61378: PPUSH
61379: CALL_OW 72
61383: ST_TO_ADDR
// if not tmp then
61384: LD_VAR 0 4
61388: NOT
61389: IFFALSE 61393
// continue ;
61391: GO 61280
// if mc_taming [ i ] then
61393: LD_EXP 74
61397: PUSH
61398: LD_VAR 0 2
61402: ARRAY
61403: IFFALSE 61427
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61405: LD_ADDR_EXP 74
61409: PUSH
61410: LD_EXP 74
61414: PPUSH
61415: LD_VAR 0 2
61419: PPUSH
61420: EMPTY
61421: PPUSH
61422: CALL_OW 1
61426: ST_TO_ADDR
// for j in tmp do
61427: LD_ADDR_VAR 0 3
61431: PUSH
61432: LD_VAR 0 4
61436: PUSH
61437: FOR_IN
61438: IFFALSE 61661
// begin if IsInUnit ( j ) then
61440: LD_VAR 0 3
61444: PPUSH
61445: CALL_OW 310
61449: IFFALSE 61460
// ComExitBuilding ( j ) ;
61451: LD_VAR 0 3
61455: PPUSH
61456: CALL_OW 122
// if not j in mc_healers [ i ] then
61460: LD_VAR 0 3
61464: PUSH
61465: LD_EXP 47
61469: PUSH
61470: LD_VAR 0 2
61474: ARRAY
61475: IN
61476: NOT
61477: IFFALSE 61523
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61479: LD_ADDR_EXP 47
61483: PUSH
61484: LD_EXP 47
61488: PPUSH
61489: LD_VAR 0 2
61493: PUSH
61494: LD_EXP 47
61498: PUSH
61499: LD_VAR 0 2
61503: ARRAY
61504: PUSH
61505: LD_INT 1
61507: PLUS
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PPUSH
61513: LD_VAR 0 3
61517: PPUSH
61518: CALL 14949 0 3
61522: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61523: LD_VAR 0 3
61527: PPUSH
61528: CALL_OW 110
61532: PUSH
61533: LD_INT 102
61535: NONEQUAL
61536: IFFALSE 61550
// SetTag ( j , 102 ) ;
61538: LD_VAR 0 3
61542: PPUSH
61543: LD_INT 102
61545: PPUSH
61546: CALL_OW 109
// Wait ( 3 ) ;
61550: LD_INT 3
61552: PPUSH
61553: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61557: LD_EXP 46
61561: PUSH
61562: LD_VAR 0 2
61566: ARRAY
61567: PUSH
61568: LD_INT 1
61570: ARRAY
61571: IFFALSE 61603
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61573: LD_VAR 0 3
61577: PPUSH
61578: LD_EXP 46
61582: PUSH
61583: LD_VAR 0 2
61587: ARRAY
61588: PUSH
61589: LD_INT 1
61591: ARRAY
61592: PUSH
61593: LD_INT 1
61595: ARRAY
61596: PPUSH
61597: CALL_OW 128
61601: GO 61659
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61603: LD_VAR 0 3
61607: PPUSH
61608: CALL_OW 314
61612: NOT
61613: PUSH
61614: LD_EXP 46
61618: PUSH
61619: LD_VAR 0 2
61623: ARRAY
61624: PUSH
61625: LD_INT 2
61627: ARRAY
61628: AND
61629: IFFALSE 61659
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61631: LD_VAR 0 3
61635: PPUSH
61636: LD_EXP 46
61640: PUSH
61641: LD_VAR 0 2
61645: ARRAY
61646: PUSH
61647: LD_INT 2
61649: ARRAY
61650: PUSH
61651: LD_INT 1
61653: ARRAY
61654: PPUSH
61655: CALL_OW 128
// end ;
61659: GO 61437
61661: POP
61662: POP
// end ;
61663: GO 61280
61665: POP
61666: POP
// end ;
61667: LD_VAR 0 1
61671: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
61672: LD_INT 0
61674: PPUSH
61675: PPUSH
61676: PPUSH
61677: PPUSH
61678: PPUSH
61679: PPUSH
// if not mc_bases then
61680: LD_EXP 43
61684: NOT
61685: IFFALSE 61689
// exit ;
61687: GO 62852
// for i = 1 to mc_bases do
61689: LD_ADDR_VAR 0 2
61693: PUSH
61694: DOUBLE
61695: LD_INT 1
61697: DEC
61698: ST_TO_ADDR
61699: LD_EXP 43
61703: PUSH
61704: FOR_TO
61705: IFFALSE 62850
// begin if mc_scan [ i ] then
61707: LD_EXP 66
61711: PUSH
61712: LD_VAR 0 2
61716: ARRAY
61717: IFFALSE 61721
// continue ;
61719: GO 61704
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61721: LD_EXP 48
61725: PUSH
61726: LD_VAR 0 2
61730: ARRAY
61731: NOT
61732: PUSH
61733: LD_EXP 50
61737: PUSH
61738: LD_VAR 0 2
61742: ARRAY
61743: NOT
61744: AND
61745: PUSH
61746: LD_EXP 49
61750: PUSH
61751: LD_VAR 0 2
61755: ARRAY
61756: AND
61757: IFFALSE 61795
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61759: LD_ADDR_EXP 49
61763: PUSH
61764: LD_EXP 49
61768: PPUSH
61769: LD_VAR 0 2
61773: PPUSH
61774: EMPTY
61775: PPUSH
61776: CALL_OW 1
61780: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61781: LD_VAR 0 2
61785: PPUSH
61786: LD_INT 103
61788: PPUSH
61789: CALL 55402 0 2
// continue ;
61793: GO 61704
// end ; if mc_construct_list [ i ] then
61795: LD_EXP 50
61799: PUSH
61800: LD_VAR 0 2
61804: ARRAY
61805: IFFALSE 62025
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61807: LD_ADDR_VAR 0 5
61811: PUSH
61812: LD_EXP 43
61816: PUSH
61817: LD_VAR 0 2
61821: ARRAY
61822: PPUSH
61823: LD_INT 25
61825: PUSH
61826: LD_INT 2
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: PPUSH
61833: CALL_OW 72
61837: PUSH
61838: LD_EXP 45
61842: PUSH
61843: LD_VAR 0 2
61847: ARRAY
61848: DIFF
61849: ST_TO_ADDR
// if not tmp then
61850: LD_VAR 0 5
61854: NOT
61855: IFFALSE 61859
// continue ;
61857: GO 61704
// for j in tmp do
61859: LD_ADDR_VAR 0 3
61863: PUSH
61864: LD_VAR 0 5
61868: PUSH
61869: FOR_IN
61870: IFFALSE 62021
// begin if not mc_builders [ i ] then
61872: LD_EXP 49
61876: PUSH
61877: LD_VAR 0 2
61881: ARRAY
61882: NOT
61883: IFFALSE 61941
// begin SetTag ( j , 103 ) ;
61885: LD_VAR 0 3
61889: PPUSH
61890: LD_INT 103
61892: PPUSH
61893: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61897: LD_ADDR_EXP 49
61901: PUSH
61902: LD_EXP 49
61906: PPUSH
61907: LD_VAR 0 2
61911: PUSH
61912: LD_EXP 49
61916: PUSH
61917: LD_VAR 0 2
61921: ARRAY
61922: PUSH
61923: LD_INT 1
61925: PLUS
61926: PUSH
61927: EMPTY
61928: LIST
61929: LIST
61930: PPUSH
61931: LD_VAR 0 3
61935: PPUSH
61936: CALL 14949 0 3
61940: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61941: LD_VAR 0 3
61945: PPUSH
61946: CALL_OW 310
61950: IFFALSE 61961
// ComExitBuilding ( j ) ;
61952: LD_VAR 0 3
61956: PPUSH
61957: CALL_OW 122
// wait ( 3 ) ;
61961: LD_INT 3
61963: PPUSH
61964: CALL_OW 67
// if not mc_construct_list [ i ] then
61968: LD_EXP 50
61972: PUSH
61973: LD_VAR 0 2
61977: ARRAY
61978: NOT
61979: IFFALSE 61983
// break ;
61981: GO 62021
// if not HasTask ( j ) then
61983: LD_VAR 0 3
61987: PPUSH
61988: CALL_OW 314
61992: NOT
61993: IFFALSE 62019
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61995: LD_VAR 0 3
61999: PPUSH
62000: LD_EXP 50
62004: PUSH
62005: LD_VAR 0 2
62009: ARRAY
62010: PUSH
62011: LD_INT 1
62013: ARRAY
62014: PPUSH
62015: CALL 17810 0 2
// end ;
62019: GO 61869
62021: POP
62022: POP
// end else
62023: GO 62848
// if mc_build_list [ i ] then
62025: LD_EXP 48
62029: PUSH
62030: LD_VAR 0 2
62034: ARRAY
62035: IFFALSE 62848
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62037: LD_EXP 48
62041: PUSH
62042: LD_VAR 0 2
62046: ARRAY
62047: PUSH
62048: LD_INT 1
62050: ARRAY
62051: PUSH
62052: LD_INT 1
62054: ARRAY
62055: PPUSH
62056: CALL 17634 0 1
62060: PUSH
62061: LD_EXP 43
62065: PUSH
62066: LD_VAR 0 2
62070: ARRAY
62071: PPUSH
62072: LD_INT 2
62074: PUSH
62075: LD_INT 30
62077: PUSH
62078: LD_INT 2
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: PUSH
62085: LD_INT 30
62087: PUSH
62088: LD_INT 3
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: LIST
62099: PPUSH
62100: CALL_OW 72
62104: NOT
62105: AND
62106: IFFALSE 62211
// begin for j = 1 to mc_build_list [ i ] do
62108: LD_ADDR_VAR 0 3
62112: PUSH
62113: DOUBLE
62114: LD_INT 1
62116: DEC
62117: ST_TO_ADDR
62118: LD_EXP 48
62122: PUSH
62123: LD_VAR 0 2
62127: ARRAY
62128: PUSH
62129: FOR_TO
62130: IFFALSE 62209
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62132: LD_EXP 48
62136: PUSH
62137: LD_VAR 0 2
62141: ARRAY
62142: PUSH
62143: LD_VAR 0 3
62147: ARRAY
62148: PUSH
62149: LD_INT 1
62151: ARRAY
62152: PUSH
62153: LD_INT 2
62155: EQUAL
62156: IFFALSE 62207
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62158: LD_ADDR_EXP 48
62162: PUSH
62163: LD_EXP 48
62167: PPUSH
62168: LD_VAR 0 2
62172: PPUSH
62173: LD_EXP 48
62177: PUSH
62178: LD_VAR 0 2
62182: ARRAY
62183: PPUSH
62184: LD_VAR 0 3
62188: PPUSH
62189: LD_INT 1
62191: PPUSH
62192: LD_INT 0
62194: PPUSH
62195: CALL 14367 0 4
62199: PPUSH
62200: CALL_OW 1
62204: ST_TO_ADDR
// break ;
62205: GO 62209
// end ;
62207: GO 62129
62209: POP
62210: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62211: LD_ADDR_VAR 0 6
62215: PUSH
62216: LD_EXP 43
62220: PUSH
62221: LD_VAR 0 2
62225: ARRAY
62226: PPUSH
62227: LD_INT 2
62229: PUSH
62230: LD_INT 30
62232: PUSH
62233: LD_INT 0
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: LD_INT 30
62242: PUSH
62243: LD_INT 1
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: PUSH
62250: EMPTY
62251: LIST
62252: LIST
62253: LIST
62254: PPUSH
62255: CALL_OW 72
62259: ST_TO_ADDR
// for k := 1 to depot do
62260: LD_ADDR_VAR 0 4
62264: PUSH
62265: DOUBLE
62266: LD_INT 1
62268: DEC
62269: ST_TO_ADDR
62270: LD_VAR 0 6
62274: PUSH
62275: FOR_TO
62276: IFFALSE 62846
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62278: LD_EXP 48
62282: PUSH
62283: LD_VAR 0 2
62287: ARRAY
62288: PUSH
62289: LD_INT 1
62291: ARRAY
62292: PUSH
62293: LD_INT 1
62295: ARRAY
62296: PUSH
62297: LD_INT 0
62299: EQUAL
62300: PUSH
62301: LD_VAR 0 6
62305: PUSH
62306: LD_VAR 0 4
62310: ARRAY
62311: PPUSH
62312: LD_EXP 48
62316: PUSH
62317: LD_VAR 0 2
62321: ARRAY
62322: PUSH
62323: LD_INT 1
62325: ARRAY
62326: PUSH
62327: LD_INT 1
62329: ARRAY
62330: PPUSH
62331: LD_EXP 48
62335: PUSH
62336: LD_VAR 0 2
62340: ARRAY
62341: PUSH
62342: LD_INT 1
62344: ARRAY
62345: PUSH
62346: LD_INT 2
62348: ARRAY
62349: PPUSH
62350: LD_EXP 48
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: ARRAY
62364: PUSH
62365: LD_INT 3
62367: ARRAY
62368: PPUSH
62369: LD_EXP 48
62373: PUSH
62374: LD_VAR 0 2
62378: ARRAY
62379: PUSH
62380: LD_INT 1
62382: ARRAY
62383: PUSH
62384: LD_INT 4
62386: ARRAY
62387: PPUSH
62388: CALL 23046 0 5
62392: OR
62393: IFFALSE 62674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62395: LD_ADDR_VAR 0 5
62399: PUSH
62400: LD_EXP 43
62404: PUSH
62405: LD_VAR 0 2
62409: ARRAY
62410: PPUSH
62411: LD_INT 25
62413: PUSH
62414: LD_INT 2
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PPUSH
62421: CALL_OW 72
62425: PUSH
62426: LD_EXP 45
62430: PUSH
62431: LD_VAR 0 2
62435: ARRAY
62436: DIFF
62437: ST_TO_ADDR
// if not tmp then
62438: LD_VAR 0 5
62442: NOT
62443: IFFALSE 62447
// continue ;
62445: GO 62275
// for j in tmp do
62447: LD_ADDR_VAR 0 3
62451: PUSH
62452: LD_VAR 0 5
62456: PUSH
62457: FOR_IN
62458: IFFALSE 62670
// begin if not mc_builders [ i ] then
62460: LD_EXP 49
62464: PUSH
62465: LD_VAR 0 2
62469: ARRAY
62470: NOT
62471: IFFALSE 62529
// begin SetTag ( j , 103 ) ;
62473: LD_VAR 0 3
62477: PPUSH
62478: LD_INT 103
62480: PPUSH
62481: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62485: LD_ADDR_EXP 49
62489: PUSH
62490: LD_EXP 49
62494: PPUSH
62495: LD_VAR 0 2
62499: PUSH
62500: LD_EXP 49
62504: PUSH
62505: LD_VAR 0 2
62509: ARRAY
62510: PUSH
62511: LD_INT 1
62513: PLUS
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PPUSH
62519: LD_VAR 0 3
62523: PPUSH
62524: CALL 14949 0 3
62528: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62529: LD_VAR 0 3
62533: PPUSH
62534: CALL_OW 310
62538: IFFALSE 62549
// ComExitBuilding ( j ) ;
62540: LD_VAR 0 3
62544: PPUSH
62545: CALL_OW 122
// wait ( 3 ) ;
62549: LD_INT 3
62551: PPUSH
62552: CALL_OW 67
// if not mc_build_list [ i ] then
62556: LD_EXP 48
62560: PUSH
62561: LD_VAR 0 2
62565: ARRAY
62566: NOT
62567: IFFALSE 62571
// break ;
62569: GO 62670
// if not HasTask ( j ) then
62571: LD_VAR 0 3
62575: PPUSH
62576: CALL_OW 314
62580: NOT
62581: IFFALSE 62668
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62583: LD_VAR 0 3
62587: PPUSH
62588: LD_EXP 48
62592: PUSH
62593: LD_VAR 0 2
62597: ARRAY
62598: PUSH
62599: LD_INT 1
62601: ARRAY
62602: PUSH
62603: LD_INT 1
62605: ARRAY
62606: PPUSH
62607: LD_EXP 48
62611: PUSH
62612: LD_VAR 0 2
62616: ARRAY
62617: PUSH
62618: LD_INT 1
62620: ARRAY
62621: PUSH
62622: LD_INT 2
62624: ARRAY
62625: PPUSH
62626: LD_EXP 48
62630: PUSH
62631: LD_VAR 0 2
62635: ARRAY
62636: PUSH
62637: LD_INT 1
62639: ARRAY
62640: PUSH
62641: LD_INT 3
62643: ARRAY
62644: PPUSH
62645: LD_EXP 48
62649: PUSH
62650: LD_VAR 0 2
62654: ARRAY
62655: PUSH
62656: LD_INT 1
62658: ARRAY
62659: PUSH
62660: LD_INT 4
62662: ARRAY
62663: PPUSH
62664: CALL_OW 145
// end ;
62668: GO 62457
62670: POP
62671: POP
// end else
62672: GO 62844
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62674: LD_EXP 43
62678: PUSH
62679: LD_VAR 0 2
62683: ARRAY
62684: PPUSH
62685: LD_EXP 48
62689: PUSH
62690: LD_VAR 0 2
62694: ARRAY
62695: PUSH
62696: LD_INT 1
62698: ARRAY
62699: PUSH
62700: LD_INT 1
62702: ARRAY
62703: PPUSH
62704: LD_EXP 48
62708: PUSH
62709: LD_VAR 0 2
62713: ARRAY
62714: PUSH
62715: LD_INT 1
62717: ARRAY
62718: PUSH
62719: LD_INT 2
62721: ARRAY
62722: PPUSH
62723: LD_EXP 48
62727: PUSH
62728: LD_VAR 0 2
62732: ARRAY
62733: PUSH
62734: LD_INT 1
62736: ARRAY
62737: PUSH
62738: LD_INT 3
62740: ARRAY
62741: PPUSH
62742: LD_EXP 48
62746: PUSH
62747: LD_VAR 0 2
62751: ARRAY
62752: PUSH
62753: LD_INT 1
62755: ARRAY
62756: PUSH
62757: LD_INT 4
62759: ARRAY
62760: PPUSH
62761: LD_EXP 43
62765: PUSH
62766: LD_VAR 0 2
62770: ARRAY
62771: PPUSH
62772: LD_INT 21
62774: PUSH
62775: LD_INT 3
62777: PUSH
62778: EMPTY
62779: LIST
62780: LIST
62781: PPUSH
62782: CALL_OW 72
62786: PPUSH
62787: EMPTY
62788: PPUSH
62789: CALL 21800 0 7
62793: NOT
62794: IFFALSE 62844
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62796: LD_ADDR_EXP 48
62800: PUSH
62801: LD_EXP 48
62805: PPUSH
62806: LD_VAR 0 2
62810: PPUSH
62811: LD_EXP 48
62815: PUSH
62816: LD_VAR 0 2
62820: ARRAY
62821: PPUSH
62822: LD_INT 1
62824: PPUSH
62825: LD_INT 1
62827: NEG
62828: PPUSH
62829: LD_INT 0
62831: PPUSH
62832: CALL 14367 0 4
62836: PPUSH
62837: CALL_OW 1
62841: ST_TO_ADDR
// continue ;
62842: GO 62275
// end ; end ;
62844: GO 62275
62846: POP
62847: POP
// end ; end ;
62848: GO 61704
62850: POP
62851: POP
// end ;
62852: LD_VAR 0 1
62856: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62857: LD_INT 0
62859: PPUSH
62860: PPUSH
62861: PPUSH
62862: PPUSH
62863: PPUSH
62864: PPUSH
// if not mc_bases then
62865: LD_EXP 43
62869: NOT
62870: IFFALSE 62874
// exit ;
62872: GO 63301
// for i = 1 to mc_bases do
62874: LD_ADDR_VAR 0 2
62878: PUSH
62879: DOUBLE
62880: LD_INT 1
62882: DEC
62883: ST_TO_ADDR
62884: LD_EXP 43
62888: PUSH
62889: FOR_TO
62890: IFFALSE 63299
// begin tmp := mc_build_upgrade [ i ] ;
62892: LD_ADDR_VAR 0 4
62896: PUSH
62897: LD_EXP 75
62901: PUSH
62902: LD_VAR 0 2
62906: ARRAY
62907: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62908: LD_ADDR_VAR 0 6
62912: PUSH
62913: LD_EXP 76
62917: PUSH
62918: LD_VAR 0 2
62922: ARRAY
62923: PPUSH
62924: LD_INT 2
62926: PUSH
62927: LD_INT 30
62929: PUSH
62930: LD_INT 6
62932: PUSH
62933: EMPTY
62934: LIST
62935: LIST
62936: PUSH
62937: LD_INT 30
62939: PUSH
62940: LD_INT 7
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: LIST
62951: PPUSH
62952: CALL_OW 72
62956: ST_TO_ADDR
// if not tmp and not lab then
62957: LD_VAR 0 4
62961: NOT
62962: PUSH
62963: LD_VAR 0 6
62967: NOT
62968: AND
62969: IFFALSE 62973
// continue ;
62971: GO 62889
// if tmp then
62973: LD_VAR 0 4
62977: IFFALSE 63097
// for j in tmp do
62979: LD_ADDR_VAR 0 3
62983: PUSH
62984: LD_VAR 0 4
62988: PUSH
62989: FOR_IN
62990: IFFALSE 63095
// begin if UpgradeCost ( j ) then
62992: LD_VAR 0 3
62996: PPUSH
62997: CALL 21460 0 1
63001: IFFALSE 63093
// begin ComUpgrade ( j ) ;
63003: LD_VAR 0 3
63007: PPUSH
63008: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63012: LD_ADDR_EXP 75
63016: PUSH
63017: LD_EXP 75
63021: PPUSH
63022: LD_VAR 0 2
63026: PPUSH
63027: LD_EXP 75
63031: PUSH
63032: LD_VAR 0 2
63036: ARRAY
63037: PUSH
63038: LD_VAR 0 3
63042: DIFF
63043: PPUSH
63044: CALL_OW 1
63048: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63049: LD_ADDR_EXP 50
63053: PUSH
63054: LD_EXP 50
63058: PPUSH
63059: LD_VAR 0 2
63063: PUSH
63064: LD_EXP 50
63068: PUSH
63069: LD_VAR 0 2
63073: ARRAY
63074: PUSH
63075: LD_INT 1
63077: PLUS
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: PPUSH
63083: LD_VAR 0 3
63087: PPUSH
63088: CALL 14949 0 3
63092: ST_TO_ADDR
// end ; end ;
63093: GO 62989
63095: POP
63096: POP
// if not lab or not mc_lab_upgrade [ i ] then
63097: LD_VAR 0 6
63101: NOT
63102: PUSH
63103: LD_EXP 77
63107: PUSH
63108: LD_VAR 0 2
63112: ARRAY
63113: NOT
63114: OR
63115: IFFALSE 63119
// continue ;
63117: GO 62889
// for j in lab do
63119: LD_ADDR_VAR 0 3
63123: PUSH
63124: LD_VAR 0 6
63128: PUSH
63129: FOR_IN
63130: IFFALSE 63295
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63132: LD_VAR 0 3
63136: PPUSH
63137: CALL_OW 266
63141: PUSH
63142: LD_INT 6
63144: PUSH
63145: LD_INT 7
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: IN
63152: PUSH
63153: LD_VAR 0 3
63157: PPUSH
63158: CALL_OW 461
63162: PUSH
63163: LD_INT 1
63165: NONEQUAL
63166: AND
63167: IFFALSE 63293
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63169: LD_VAR 0 3
63173: PPUSH
63174: LD_EXP 77
63178: PUSH
63179: LD_VAR 0 2
63183: ARRAY
63184: PUSH
63185: LD_INT 1
63187: ARRAY
63188: PPUSH
63189: CALL 21665 0 2
63193: IFFALSE 63293
// begin ComCancel ( j ) ;
63195: LD_VAR 0 3
63199: PPUSH
63200: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63204: LD_VAR 0 3
63208: PPUSH
63209: LD_EXP 77
63213: PUSH
63214: LD_VAR 0 2
63218: ARRAY
63219: PUSH
63220: LD_INT 1
63222: ARRAY
63223: PPUSH
63224: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63228: LD_VAR 0 3
63232: PUSH
63233: LD_EXP 50
63237: PUSH
63238: LD_VAR 0 2
63242: ARRAY
63243: IN
63244: NOT
63245: IFFALSE 63291
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63247: LD_ADDR_EXP 50
63251: PUSH
63252: LD_EXP 50
63256: PPUSH
63257: LD_VAR 0 2
63261: PUSH
63262: LD_EXP 50
63266: PUSH
63267: LD_VAR 0 2
63271: ARRAY
63272: PUSH
63273: LD_INT 1
63275: PLUS
63276: PUSH
63277: EMPTY
63278: LIST
63279: LIST
63280: PPUSH
63281: LD_VAR 0 3
63285: PPUSH
63286: CALL 14949 0 3
63290: ST_TO_ADDR
// break ;
63291: GO 63295
// end ; end ; end ;
63293: GO 63129
63295: POP
63296: POP
// end ;
63297: GO 62889
63299: POP
63300: POP
// end ;
63301: LD_VAR 0 1
63305: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63306: LD_INT 0
63308: PPUSH
63309: PPUSH
63310: PPUSH
63311: PPUSH
63312: PPUSH
63313: PPUSH
63314: PPUSH
63315: PPUSH
63316: PPUSH
// if not mc_bases then
63317: LD_EXP 43
63321: NOT
63322: IFFALSE 63326
// exit ;
63324: GO 63731
// for i = 1 to mc_bases do
63326: LD_ADDR_VAR 0 2
63330: PUSH
63331: DOUBLE
63332: LD_INT 1
63334: DEC
63335: ST_TO_ADDR
63336: LD_EXP 43
63340: PUSH
63341: FOR_TO
63342: IFFALSE 63729
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63344: LD_EXP 51
63348: PUSH
63349: LD_VAR 0 2
63353: ARRAY
63354: NOT
63355: PUSH
63356: LD_EXP 43
63360: PUSH
63361: LD_VAR 0 2
63365: ARRAY
63366: PPUSH
63367: LD_INT 30
63369: PUSH
63370: LD_INT 3
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PPUSH
63377: CALL_OW 72
63381: NOT
63382: OR
63383: IFFALSE 63387
// continue ;
63385: GO 63341
// busy := false ;
63387: LD_ADDR_VAR 0 8
63391: PUSH
63392: LD_INT 0
63394: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63395: LD_ADDR_VAR 0 4
63399: PUSH
63400: LD_EXP 43
63404: PUSH
63405: LD_VAR 0 2
63409: ARRAY
63410: PPUSH
63411: LD_INT 30
63413: PUSH
63414: LD_INT 3
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PPUSH
63421: CALL_OW 72
63425: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63426: LD_ADDR_VAR 0 6
63430: PUSH
63431: LD_EXP 51
63435: PUSH
63436: LD_VAR 0 2
63440: ARRAY
63441: PPUSH
63442: LD_INT 2
63444: PUSH
63445: LD_INT 30
63447: PUSH
63448: LD_INT 32
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 30
63457: PUSH
63458: LD_INT 33
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: LIST
63469: PPUSH
63470: CALL_OW 72
63474: ST_TO_ADDR
// if not t then
63475: LD_VAR 0 6
63479: NOT
63480: IFFALSE 63484
// continue ;
63482: GO 63341
// for j in tmp do
63484: LD_ADDR_VAR 0 3
63488: PUSH
63489: LD_VAR 0 4
63493: PUSH
63494: FOR_IN
63495: IFFALSE 63525
// if not BuildingStatus ( j ) = bs_idle then
63497: LD_VAR 0 3
63501: PPUSH
63502: CALL_OW 461
63506: PUSH
63507: LD_INT 2
63509: EQUAL
63510: NOT
63511: IFFALSE 63523
// begin busy := true ;
63513: LD_ADDR_VAR 0 8
63517: PUSH
63518: LD_INT 1
63520: ST_TO_ADDR
// break ;
63521: GO 63525
// end ;
63523: GO 63494
63525: POP
63526: POP
// if busy then
63527: LD_VAR 0 8
63531: IFFALSE 63535
// continue ;
63533: GO 63341
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63535: LD_ADDR_VAR 0 7
63539: PUSH
63540: LD_VAR 0 6
63544: PPUSH
63545: LD_INT 35
63547: PUSH
63548: LD_INT 0
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PPUSH
63555: CALL_OW 72
63559: ST_TO_ADDR
// if tw then
63560: LD_VAR 0 7
63564: IFFALSE 63641
// begin tw := tw [ 1 ] ;
63566: LD_ADDR_VAR 0 7
63570: PUSH
63571: LD_VAR 0 7
63575: PUSH
63576: LD_INT 1
63578: ARRAY
63579: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63580: LD_ADDR_VAR 0 9
63584: PUSH
63585: LD_VAR 0 7
63589: PPUSH
63590: LD_EXP 68
63594: PUSH
63595: LD_VAR 0 2
63599: ARRAY
63600: PPUSH
63601: CALL 19957 0 2
63605: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63606: LD_EXP 82
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: IFFALSE 63639
// if not weapon in mc_allowed_tower_weapons [ i ] then
63618: LD_VAR 0 9
63622: PUSH
63623: LD_EXP 82
63627: PUSH
63628: LD_VAR 0 2
63632: ARRAY
63633: IN
63634: NOT
63635: IFFALSE 63639
// continue ;
63637: GO 63341
// end else
63639: GO 63704
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63641: LD_ADDR_VAR 0 5
63645: PUSH
63646: LD_EXP 51
63650: PUSH
63651: LD_VAR 0 2
63655: ARRAY
63656: PPUSH
63657: LD_VAR 0 4
63661: PPUSH
63662: CALL 46828 0 2
63666: ST_TO_ADDR
// if not tmp2 then
63667: LD_VAR 0 5
63671: NOT
63672: IFFALSE 63676
// continue ;
63674: GO 63341
// tw := tmp2 [ 1 ] ;
63676: LD_ADDR_VAR 0 7
63680: PUSH
63681: LD_VAR 0 5
63685: PUSH
63686: LD_INT 1
63688: ARRAY
63689: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63690: LD_ADDR_VAR 0 9
63694: PUSH
63695: LD_VAR 0 5
63699: PUSH
63700: LD_INT 2
63702: ARRAY
63703: ST_TO_ADDR
// end ; if not weapon then
63704: LD_VAR 0 9
63708: NOT
63709: IFFALSE 63713
// continue ;
63711: GO 63341
// ComPlaceWeapon ( tw , weapon ) ;
63713: LD_VAR 0 7
63717: PPUSH
63718: LD_VAR 0 9
63722: PPUSH
63723: CALL_OW 148
// end ;
63727: GO 63341
63729: POP
63730: POP
// end ;
63731: LD_VAR 0 1
63735: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63736: LD_INT 0
63738: PPUSH
63739: PPUSH
63740: PPUSH
63741: PPUSH
63742: PPUSH
63743: PPUSH
63744: PPUSH
// if not mc_bases then
63745: LD_EXP 43
63749: NOT
63750: IFFALSE 63754
// exit ;
63752: GO 64522
// for i = 1 to mc_bases do
63754: LD_ADDR_VAR 0 2
63758: PUSH
63759: DOUBLE
63760: LD_INT 1
63762: DEC
63763: ST_TO_ADDR
63764: LD_EXP 43
63768: PUSH
63769: FOR_TO
63770: IFFALSE 64520
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63772: LD_EXP 56
63776: PUSH
63777: LD_VAR 0 2
63781: ARRAY
63782: NOT
63783: PUSH
63784: LD_EXP 56
63788: PUSH
63789: LD_VAR 0 2
63793: ARRAY
63794: PUSH
63795: LD_EXP 57
63799: PUSH
63800: LD_VAR 0 2
63804: ARRAY
63805: EQUAL
63806: OR
63807: PUSH
63808: LD_EXP 66
63812: PUSH
63813: LD_VAR 0 2
63817: ARRAY
63818: OR
63819: IFFALSE 63823
// continue ;
63821: GO 63769
// if mc_miners [ i ] then
63823: LD_EXP 57
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: IFFALSE 64207
// begin for j = mc_miners [ i ] downto 1 do
63835: LD_ADDR_VAR 0 3
63839: PUSH
63840: DOUBLE
63841: LD_EXP 57
63845: PUSH
63846: LD_VAR 0 2
63850: ARRAY
63851: INC
63852: ST_TO_ADDR
63853: LD_INT 1
63855: PUSH
63856: FOR_DOWNTO
63857: IFFALSE 64205
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63859: LD_EXP 57
63863: PUSH
63864: LD_VAR 0 2
63868: ARRAY
63869: PUSH
63870: LD_VAR 0 3
63874: ARRAY
63875: PPUSH
63876: CALL_OW 301
63880: PUSH
63881: LD_EXP 57
63885: PUSH
63886: LD_VAR 0 2
63890: ARRAY
63891: PUSH
63892: LD_VAR 0 3
63896: ARRAY
63897: PPUSH
63898: CALL_OW 257
63902: PUSH
63903: LD_INT 1
63905: NONEQUAL
63906: OR
63907: IFFALSE 63970
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63909: LD_ADDR_VAR 0 5
63913: PUSH
63914: LD_EXP 57
63918: PUSH
63919: LD_VAR 0 2
63923: ARRAY
63924: PUSH
63925: LD_EXP 57
63929: PUSH
63930: LD_VAR 0 2
63934: ARRAY
63935: PUSH
63936: LD_VAR 0 3
63940: ARRAY
63941: DIFF
63942: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63943: LD_ADDR_EXP 57
63947: PUSH
63948: LD_EXP 57
63952: PPUSH
63953: LD_VAR 0 2
63957: PPUSH
63958: LD_VAR 0 5
63962: PPUSH
63963: CALL_OW 1
63967: ST_TO_ADDR
// continue ;
63968: GO 63856
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63970: LD_EXP 57
63974: PUSH
63975: LD_VAR 0 2
63979: ARRAY
63980: PUSH
63981: LD_VAR 0 3
63985: ARRAY
63986: PPUSH
63987: CALL_OW 257
63991: PUSH
63992: LD_INT 1
63994: EQUAL
63995: PUSH
63996: LD_EXP 57
64000: PUSH
64001: LD_VAR 0 2
64005: ARRAY
64006: PUSH
64007: LD_VAR 0 3
64011: ARRAY
64012: PPUSH
64013: CALL_OW 459
64017: NOT
64018: AND
64019: PUSH
64020: LD_EXP 57
64024: PUSH
64025: LD_VAR 0 2
64029: ARRAY
64030: PUSH
64031: LD_VAR 0 3
64035: ARRAY
64036: PPUSH
64037: CALL_OW 314
64041: NOT
64042: AND
64043: IFFALSE 64203
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64045: LD_EXP 57
64049: PUSH
64050: LD_VAR 0 2
64054: ARRAY
64055: PUSH
64056: LD_VAR 0 3
64060: ARRAY
64061: PPUSH
64062: CALL_OW 310
64066: IFFALSE 64089
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64068: LD_EXP 57
64072: PUSH
64073: LD_VAR 0 2
64077: ARRAY
64078: PUSH
64079: LD_VAR 0 3
64083: ARRAY
64084: PPUSH
64085: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64089: LD_EXP 57
64093: PUSH
64094: LD_VAR 0 2
64098: ARRAY
64099: PUSH
64100: LD_VAR 0 3
64104: ARRAY
64105: PPUSH
64106: CALL_OW 314
64110: NOT
64111: IFFALSE 64203
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64113: LD_ADDR_VAR 0 7
64117: PUSH
64118: LD_INT 1
64120: PPUSH
64121: LD_EXP 56
64125: PUSH
64126: LD_VAR 0 2
64130: ARRAY
64131: PPUSH
64132: CALL_OW 12
64136: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64137: LD_EXP 57
64141: PUSH
64142: LD_VAR 0 2
64146: ARRAY
64147: PUSH
64148: LD_VAR 0 3
64152: ARRAY
64153: PPUSH
64154: LD_EXP 56
64158: PUSH
64159: LD_VAR 0 2
64163: ARRAY
64164: PUSH
64165: LD_VAR 0 7
64169: ARRAY
64170: PUSH
64171: LD_INT 1
64173: ARRAY
64174: PPUSH
64175: LD_EXP 56
64179: PUSH
64180: LD_VAR 0 2
64184: ARRAY
64185: PUSH
64186: LD_VAR 0 7
64190: ARRAY
64191: PUSH
64192: LD_INT 2
64194: ARRAY
64195: PPUSH
64196: LD_INT 0
64198: PPUSH
64199: CALL_OW 193
// end ; end ; end ;
64203: GO 63856
64205: POP
64206: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64207: LD_ADDR_VAR 0 5
64211: PUSH
64212: LD_EXP 43
64216: PUSH
64217: LD_VAR 0 2
64221: ARRAY
64222: PPUSH
64223: LD_INT 2
64225: PUSH
64226: LD_INT 30
64228: PUSH
64229: LD_INT 4
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 30
64238: PUSH
64239: LD_INT 5
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 30
64248: PUSH
64249: LD_INT 32
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: LIST
64260: LIST
64261: PPUSH
64262: CALL_OW 72
64266: ST_TO_ADDR
// if not tmp then
64267: LD_VAR 0 5
64271: NOT
64272: IFFALSE 64276
// continue ;
64274: GO 63769
// list := [ ] ;
64276: LD_ADDR_VAR 0 6
64280: PUSH
64281: EMPTY
64282: ST_TO_ADDR
// for j in tmp do
64283: LD_ADDR_VAR 0 3
64287: PUSH
64288: LD_VAR 0 5
64292: PUSH
64293: FOR_IN
64294: IFFALSE 64363
// begin for k in UnitsInside ( j ) do
64296: LD_ADDR_VAR 0 4
64300: PUSH
64301: LD_VAR 0 3
64305: PPUSH
64306: CALL_OW 313
64310: PUSH
64311: FOR_IN
64312: IFFALSE 64359
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64314: LD_VAR 0 4
64318: PPUSH
64319: CALL_OW 257
64323: PUSH
64324: LD_INT 1
64326: EQUAL
64327: PUSH
64328: LD_VAR 0 4
64332: PPUSH
64333: CALL_OW 459
64337: NOT
64338: AND
64339: IFFALSE 64357
// list := list ^ k ;
64341: LD_ADDR_VAR 0 6
64345: PUSH
64346: LD_VAR 0 6
64350: PUSH
64351: LD_VAR 0 4
64355: ADD
64356: ST_TO_ADDR
64357: GO 64311
64359: POP
64360: POP
// end ;
64361: GO 64293
64363: POP
64364: POP
// list := list diff mc_miners [ i ] ;
64365: LD_ADDR_VAR 0 6
64369: PUSH
64370: LD_VAR 0 6
64374: PUSH
64375: LD_EXP 57
64379: PUSH
64380: LD_VAR 0 2
64384: ARRAY
64385: DIFF
64386: ST_TO_ADDR
// if not list then
64387: LD_VAR 0 6
64391: NOT
64392: IFFALSE 64396
// continue ;
64394: GO 63769
// k := mc_mines [ i ] - mc_miners [ i ] ;
64396: LD_ADDR_VAR 0 4
64400: PUSH
64401: LD_EXP 56
64405: PUSH
64406: LD_VAR 0 2
64410: ARRAY
64411: PUSH
64412: LD_EXP 57
64416: PUSH
64417: LD_VAR 0 2
64421: ARRAY
64422: MINUS
64423: ST_TO_ADDR
// if k > list then
64424: LD_VAR 0 4
64428: PUSH
64429: LD_VAR 0 6
64433: GREATER
64434: IFFALSE 64446
// k := list ;
64436: LD_ADDR_VAR 0 4
64440: PUSH
64441: LD_VAR 0 6
64445: ST_TO_ADDR
// for j = 1 to k do
64446: LD_ADDR_VAR 0 3
64450: PUSH
64451: DOUBLE
64452: LD_INT 1
64454: DEC
64455: ST_TO_ADDR
64456: LD_VAR 0 4
64460: PUSH
64461: FOR_TO
64462: IFFALSE 64516
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64464: LD_ADDR_EXP 57
64468: PUSH
64469: LD_EXP 57
64473: PPUSH
64474: LD_VAR 0 2
64478: PUSH
64479: LD_EXP 57
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: PUSH
64490: LD_INT 1
64492: PLUS
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PPUSH
64498: LD_VAR 0 6
64502: PUSH
64503: LD_VAR 0 3
64507: ARRAY
64508: PPUSH
64509: CALL 14949 0 3
64513: ST_TO_ADDR
64514: GO 64461
64516: POP
64517: POP
// end ;
64518: GO 63769
64520: POP
64521: POP
// end ;
64522: LD_VAR 0 1
64526: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64527: LD_INT 0
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
64536: PPUSH
64537: PPUSH
64538: PPUSH
64539: PPUSH
// if not mc_bases then
64540: LD_EXP 43
64544: NOT
64545: IFFALSE 64549
// exit ;
64547: GO 66372
// for i = 1 to mc_bases do
64549: LD_ADDR_VAR 0 2
64553: PUSH
64554: DOUBLE
64555: LD_INT 1
64557: DEC
64558: ST_TO_ADDR
64559: LD_EXP 43
64563: PUSH
64564: FOR_TO
64565: IFFALSE 66370
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64567: LD_EXP 43
64571: PUSH
64572: LD_VAR 0 2
64576: ARRAY
64577: NOT
64578: PUSH
64579: LD_EXP 50
64583: PUSH
64584: LD_VAR 0 2
64588: ARRAY
64589: OR
64590: IFFALSE 64594
// continue ;
64592: GO 64564
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64594: LD_EXP 59
64598: PUSH
64599: LD_VAR 0 2
64603: ARRAY
64604: NOT
64605: PUSH
64606: LD_EXP 60
64610: PUSH
64611: LD_VAR 0 2
64615: ARRAY
64616: AND
64617: IFFALSE 64655
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64619: LD_ADDR_EXP 60
64623: PUSH
64624: LD_EXP 60
64628: PPUSH
64629: LD_VAR 0 2
64633: PPUSH
64634: EMPTY
64635: PPUSH
64636: CALL_OW 1
64640: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64641: LD_VAR 0 2
64645: PPUSH
64646: LD_INT 107
64648: PPUSH
64649: CALL 55402 0 2
// continue ;
64653: GO 64564
// end ; target := [ ] ;
64655: LD_ADDR_VAR 0 7
64659: PUSH
64660: EMPTY
64661: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64662: LD_ADDR_VAR 0 6
64666: PUSH
64667: LD_EXP 43
64671: PUSH
64672: LD_VAR 0 2
64676: ARRAY
64677: PUSH
64678: LD_INT 1
64680: ARRAY
64681: PPUSH
64682: CALL_OW 255
64686: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64687: LD_ADDR_VAR 0 9
64691: PUSH
64692: LD_EXP 43
64696: PUSH
64697: LD_VAR 0 2
64701: ARRAY
64702: PPUSH
64703: LD_INT 2
64705: PUSH
64706: LD_INT 30
64708: PUSH
64709: LD_INT 0
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 30
64718: PUSH
64719: LD_INT 1
64721: PUSH
64722: EMPTY
64723: LIST
64724: LIST
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: LIST
64730: PPUSH
64731: CALL_OW 72
64735: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64736: LD_ADDR_VAR 0 3
64740: PUSH
64741: DOUBLE
64742: LD_EXP 59
64746: PUSH
64747: LD_VAR 0 2
64751: ARRAY
64752: INC
64753: ST_TO_ADDR
64754: LD_INT 1
64756: PUSH
64757: FOR_DOWNTO
64758: IFFALSE 65003
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64760: LD_EXP 59
64764: PUSH
64765: LD_VAR 0 2
64769: ARRAY
64770: PUSH
64771: LD_VAR 0 3
64775: ARRAY
64776: PUSH
64777: LD_INT 2
64779: ARRAY
64780: PPUSH
64781: LD_EXP 59
64785: PUSH
64786: LD_VAR 0 2
64790: ARRAY
64791: PUSH
64792: LD_VAR 0 3
64796: ARRAY
64797: PUSH
64798: LD_INT 3
64800: ARRAY
64801: PPUSH
64802: CALL_OW 488
64806: PUSH
64807: LD_EXP 59
64811: PUSH
64812: LD_VAR 0 2
64816: ARRAY
64817: PUSH
64818: LD_VAR 0 3
64822: ARRAY
64823: PUSH
64824: LD_INT 2
64826: ARRAY
64827: PPUSH
64828: LD_EXP 59
64832: PUSH
64833: LD_VAR 0 2
64837: ARRAY
64838: PUSH
64839: LD_VAR 0 3
64843: ARRAY
64844: PUSH
64845: LD_INT 3
64847: ARRAY
64848: PPUSH
64849: CALL_OW 284
64853: PUSH
64854: LD_INT 0
64856: EQUAL
64857: AND
64858: IFFALSE 64913
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64860: LD_ADDR_VAR 0 5
64864: PUSH
64865: LD_EXP 59
64869: PUSH
64870: LD_VAR 0 2
64874: ARRAY
64875: PPUSH
64876: LD_VAR 0 3
64880: PPUSH
64881: CALL_OW 3
64885: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64886: LD_ADDR_EXP 59
64890: PUSH
64891: LD_EXP 59
64895: PPUSH
64896: LD_VAR 0 2
64900: PPUSH
64901: LD_VAR 0 5
64905: PPUSH
64906: CALL_OW 1
64910: ST_TO_ADDR
// continue ;
64911: GO 64757
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64913: LD_VAR 0 6
64917: PPUSH
64918: LD_EXP 59
64922: PUSH
64923: LD_VAR 0 2
64927: ARRAY
64928: PUSH
64929: LD_VAR 0 3
64933: ARRAY
64934: PUSH
64935: LD_INT 2
64937: ARRAY
64938: PPUSH
64939: LD_EXP 59
64943: PUSH
64944: LD_VAR 0 2
64948: ARRAY
64949: PUSH
64950: LD_VAR 0 3
64954: ARRAY
64955: PUSH
64956: LD_INT 3
64958: ARRAY
64959: PPUSH
64960: LD_INT 30
64962: PPUSH
64963: CALL 15845 0 4
64967: PUSH
64968: LD_INT 4
64970: ARRAY
64971: PUSH
64972: LD_INT 0
64974: EQUAL
64975: IFFALSE 65001
// begin target := mc_crates [ i ] [ j ] ;
64977: LD_ADDR_VAR 0 7
64981: PUSH
64982: LD_EXP 59
64986: PUSH
64987: LD_VAR 0 2
64991: ARRAY
64992: PUSH
64993: LD_VAR 0 3
64997: ARRAY
64998: ST_TO_ADDR
// break ;
64999: GO 65003
// end ; end ;
65001: GO 64757
65003: POP
65004: POP
// if not target then
65005: LD_VAR 0 7
65009: NOT
65010: IFFALSE 65014
// continue ;
65012: GO 64564
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65014: LD_ADDR_VAR 0 8
65018: PUSH
65019: LD_EXP 62
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PPUSH
65030: LD_INT 2
65032: PUSH
65033: LD_INT 3
65035: PUSH
65036: LD_INT 58
65038: PUSH
65039: EMPTY
65040: LIST
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 61
65048: PUSH
65049: EMPTY
65050: LIST
65051: PUSH
65052: LD_INT 33
65054: PUSH
65055: LD_INT 5
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 33
65064: PUSH
65065: LD_INT 3
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: LIST
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 2
65081: PUSH
65082: LD_INT 34
65084: PUSH
65085: LD_INT 32
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 34
65094: PUSH
65095: LD_INT 51
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: LD_INT 34
65104: PUSH
65105: LD_INT 12
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: LIST
65116: LIST
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PPUSH
65122: CALL_OW 72
65126: ST_TO_ADDR
// if not cargo then
65127: LD_VAR 0 8
65131: NOT
65132: IFFALSE 65838
// begin if mc_crates_collector [ i ] < 5 then
65134: LD_EXP 60
65138: PUSH
65139: LD_VAR 0 2
65143: ARRAY
65144: PUSH
65145: LD_INT 5
65147: LESS
65148: IFFALSE 65514
// begin if mc_ape [ i ] then
65150: LD_EXP 72
65154: PUSH
65155: LD_VAR 0 2
65159: ARRAY
65160: IFFALSE 65207
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65162: LD_ADDR_VAR 0 5
65166: PUSH
65167: LD_EXP 72
65171: PUSH
65172: LD_VAR 0 2
65176: ARRAY
65177: PPUSH
65178: LD_INT 25
65180: PUSH
65181: LD_INT 16
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 24
65190: PUSH
65191: LD_INT 750
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PPUSH
65202: CALL_OW 72
65206: ST_TO_ADDR
// if not tmp then
65207: LD_VAR 0 5
65211: NOT
65212: IFFALSE 65259
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65214: LD_ADDR_VAR 0 5
65218: PUSH
65219: LD_EXP 43
65223: PUSH
65224: LD_VAR 0 2
65228: ARRAY
65229: PPUSH
65230: LD_INT 25
65232: PUSH
65233: LD_INT 2
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 24
65242: PUSH
65243: LD_INT 750
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PPUSH
65254: CALL_OW 72
65258: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65259: LD_EXP 72
65263: PUSH
65264: LD_VAR 0 2
65268: ARRAY
65269: PUSH
65270: LD_EXP 43
65274: PUSH
65275: LD_VAR 0 2
65279: ARRAY
65280: PPUSH
65281: LD_INT 25
65283: PUSH
65284: LD_INT 2
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 24
65293: PUSH
65294: LD_INT 750
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PPUSH
65305: CALL_OW 72
65309: AND
65310: PUSH
65311: LD_VAR 0 5
65315: PUSH
65316: LD_INT 5
65318: LESS
65319: AND
65320: IFFALSE 65402
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65322: LD_ADDR_VAR 0 3
65326: PUSH
65327: LD_EXP 43
65331: PUSH
65332: LD_VAR 0 2
65336: ARRAY
65337: PPUSH
65338: LD_INT 25
65340: PUSH
65341: LD_INT 2
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 24
65350: PUSH
65351: LD_INT 750
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PPUSH
65362: CALL_OW 72
65366: PUSH
65367: FOR_IN
65368: IFFALSE 65400
// begin tmp := tmp union j ;
65370: LD_ADDR_VAR 0 5
65374: PUSH
65375: LD_VAR 0 5
65379: PUSH
65380: LD_VAR 0 3
65384: UNION
65385: ST_TO_ADDR
// if tmp >= 5 then
65386: LD_VAR 0 5
65390: PUSH
65391: LD_INT 5
65393: GREATEREQUAL
65394: IFFALSE 65398
// break ;
65396: GO 65400
// end ;
65398: GO 65367
65400: POP
65401: POP
// end ; if not tmp then
65402: LD_VAR 0 5
65406: NOT
65407: IFFALSE 65411
// continue ;
65409: GO 64564
// for j in tmp do
65411: LD_ADDR_VAR 0 3
65415: PUSH
65416: LD_VAR 0 5
65420: PUSH
65421: FOR_IN
65422: IFFALSE 65512
// if not GetTag ( j ) then
65424: LD_VAR 0 3
65428: PPUSH
65429: CALL_OW 110
65433: NOT
65434: IFFALSE 65510
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65436: LD_ADDR_EXP 60
65440: PUSH
65441: LD_EXP 60
65445: PPUSH
65446: LD_VAR 0 2
65450: PUSH
65451: LD_EXP 60
65455: PUSH
65456: LD_VAR 0 2
65460: ARRAY
65461: PUSH
65462: LD_INT 1
65464: PLUS
65465: PUSH
65466: EMPTY
65467: LIST
65468: LIST
65469: PPUSH
65470: LD_VAR 0 3
65474: PPUSH
65475: CALL 14949 0 3
65479: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65480: LD_VAR 0 3
65484: PPUSH
65485: LD_INT 107
65487: PPUSH
65488: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65492: LD_EXP 60
65496: PUSH
65497: LD_VAR 0 2
65501: ARRAY
65502: PUSH
65503: LD_INT 5
65505: GREATEREQUAL
65506: IFFALSE 65510
// break ;
65508: GO 65512
// end ;
65510: GO 65421
65512: POP
65513: POP
// end ; if mc_crates_collector [ i ] and target then
65514: LD_EXP 60
65518: PUSH
65519: LD_VAR 0 2
65523: ARRAY
65524: PUSH
65525: LD_VAR 0 7
65529: AND
65530: IFFALSE 65836
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65532: LD_EXP 60
65536: PUSH
65537: LD_VAR 0 2
65541: ARRAY
65542: PUSH
65543: LD_VAR 0 7
65547: PUSH
65548: LD_INT 1
65550: ARRAY
65551: LESS
65552: IFFALSE 65572
// tmp := mc_crates_collector [ i ] else
65554: LD_ADDR_VAR 0 5
65558: PUSH
65559: LD_EXP 60
65563: PUSH
65564: LD_VAR 0 2
65568: ARRAY
65569: ST_TO_ADDR
65570: GO 65586
// tmp := target [ 1 ] ;
65572: LD_ADDR_VAR 0 5
65576: PUSH
65577: LD_VAR 0 7
65581: PUSH
65582: LD_INT 1
65584: ARRAY
65585: ST_TO_ADDR
// k := 0 ;
65586: LD_ADDR_VAR 0 4
65590: PUSH
65591: LD_INT 0
65593: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65594: LD_ADDR_VAR 0 3
65598: PUSH
65599: LD_EXP 60
65603: PUSH
65604: LD_VAR 0 2
65608: ARRAY
65609: PUSH
65610: FOR_IN
65611: IFFALSE 65834
// begin k := k + 1 ;
65613: LD_ADDR_VAR 0 4
65617: PUSH
65618: LD_VAR 0 4
65622: PUSH
65623: LD_INT 1
65625: PLUS
65626: ST_TO_ADDR
// if k > tmp then
65627: LD_VAR 0 4
65631: PUSH
65632: LD_VAR 0 5
65636: GREATER
65637: IFFALSE 65641
// break ;
65639: GO 65834
// if not GetClass ( j ) in [ 2 , 16 ] then
65641: LD_VAR 0 3
65645: PPUSH
65646: CALL_OW 257
65650: PUSH
65651: LD_INT 2
65653: PUSH
65654: LD_INT 16
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: IN
65661: NOT
65662: IFFALSE 65715
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65664: LD_ADDR_EXP 60
65668: PUSH
65669: LD_EXP 60
65673: PPUSH
65674: LD_VAR 0 2
65678: PPUSH
65679: LD_EXP 60
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: PUSH
65690: LD_VAR 0 3
65694: DIFF
65695: PPUSH
65696: CALL_OW 1
65700: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65701: LD_VAR 0 3
65705: PPUSH
65706: LD_INT 0
65708: PPUSH
65709: CALL_OW 109
// continue ;
65713: GO 65610
// end ; if IsInUnit ( j ) then
65715: LD_VAR 0 3
65719: PPUSH
65720: CALL_OW 310
65724: IFFALSE 65735
// ComExitBuilding ( j ) ;
65726: LD_VAR 0 3
65730: PPUSH
65731: CALL_OW 122
// wait ( 3 ) ;
65735: LD_INT 3
65737: PPUSH
65738: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65742: LD_VAR 0 3
65746: PPUSH
65747: CALL_OW 314
65751: PUSH
65752: LD_VAR 0 6
65756: PPUSH
65757: LD_VAR 0 7
65761: PUSH
65762: LD_INT 2
65764: ARRAY
65765: PPUSH
65766: LD_VAR 0 7
65770: PUSH
65771: LD_INT 3
65773: ARRAY
65774: PPUSH
65775: LD_INT 30
65777: PPUSH
65778: CALL 15845 0 4
65782: PUSH
65783: LD_INT 4
65785: ARRAY
65786: AND
65787: IFFALSE 65805
// ComStandNearbyBuilding ( j , depot ) else
65789: LD_VAR 0 3
65793: PPUSH
65794: LD_VAR 0 9
65798: PPUSH
65799: CALL 11376 0 2
65803: GO 65832
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65805: LD_VAR 0 3
65809: PPUSH
65810: LD_VAR 0 7
65814: PUSH
65815: LD_INT 2
65817: ARRAY
65818: PPUSH
65819: LD_VAR 0 7
65823: PUSH
65824: LD_INT 3
65826: ARRAY
65827: PPUSH
65828: CALL_OW 117
// end ;
65832: GO 65610
65834: POP
65835: POP
// end ; end else
65836: GO 66368
// begin for j in cargo do
65838: LD_ADDR_VAR 0 3
65842: PUSH
65843: LD_VAR 0 8
65847: PUSH
65848: FOR_IN
65849: IFFALSE 66366
// begin if GetTag ( j ) <> 0 then
65851: LD_VAR 0 3
65855: PPUSH
65856: CALL_OW 110
65860: PUSH
65861: LD_INT 0
65863: NONEQUAL
65864: IFFALSE 65868
// continue ;
65866: GO 65848
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65868: LD_VAR 0 3
65872: PPUSH
65873: CALL_OW 256
65877: PUSH
65878: LD_INT 1000
65880: LESS
65881: PUSH
65882: LD_VAR 0 3
65886: PPUSH
65887: LD_EXP 67
65891: PUSH
65892: LD_VAR 0 2
65896: ARRAY
65897: PPUSH
65898: CALL_OW 308
65902: NOT
65903: AND
65904: IFFALSE 65926
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65906: LD_VAR 0 3
65910: PPUSH
65911: LD_EXP 67
65915: PUSH
65916: LD_VAR 0 2
65920: ARRAY
65921: PPUSH
65922: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65926: LD_VAR 0 3
65930: PPUSH
65931: CALL_OW 256
65935: PUSH
65936: LD_INT 1000
65938: LESS
65939: PUSH
65940: LD_VAR 0 3
65944: PPUSH
65945: LD_EXP 67
65949: PUSH
65950: LD_VAR 0 2
65954: ARRAY
65955: PPUSH
65956: CALL_OW 308
65960: AND
65961: IFFALSE 65965
// continue ;
65963: GO 65848
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65965: LD_VAR 0 3
65969: PPUSH
65970: CALL_OW 262
65974: PUSH
65975: LD_INT 2
65977: EQUAL
65978: PUSH
65979: LD_VAR 0 3
65983: PPUSH
65984: CALL_OW 261
65988: PUSH
65989: LD_INT 15
65991: LESS
65992: AND
65993: IFFALSE 65997
// continue ;
65995: GO 65848
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65997: LD_VAR 0 3
66001: PPUSH
66002: CALL_OW 262
66006: PUSH
66007: LD_INT 1
66009: EQUAL
66010: PUSH
66011: LD_VAR 0 3
66015: PPUSH
66016: CALL_OW 261
66020: PUSH
66021: LD_INT 10
66023: LESS
66024: AND
66025: IFFALSE 66305
// begin if not depot then
66027: LD_VAR 0 9
66031: NOT
66032: IFFALSE 66036
// continue ;
66034: GO 65848
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66036: LD_VAR 0 3
66040: PPUSH
66041: LD_VAR 0 9
66045: PPUSH
66046: LD_VAR 0 3
66050: PPUSH
66051: CALL_OW 74
66055: PPUSH
66056: CALL_OW 296
66060: PUSH
66061: LD_INT 6
66063: LESS
66064: IFFALSE 66080
// SetFuel ( j , 100 ) else
66066: LD_VAR 0 3
66070: PPUSH
66071: LD_INT 100
66073: PPUSH
66074: CALL_OW 240
66078: GO 66305
// if GetFuel ( j ) = 0 then
66080: LD_VAR 0 3
66084: PPUSH
66085: CALL_OW 261
66089: PUSH
66090: LD_INT 0
66092: EQUAL
66093: IFFALSE 66305
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66095: LD_ADDR_EXP 62
66099: PUSH
66100: LD_EXP 62
66104: PPUSH
66105: LD_VAR 0 2
66109: PPUSH
66110: LD_EXP 62
66114: PUSH
66115: LD_VAR 0 2
66119: ARRAY
66120: PUSH
66121: LD_VAR 0 3
66125: DIFF
66126: PPUSH
66127: CALL_OW 1
66131: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66132: LD_VAR 0 3
66136: PPUSH
66137: CALL_OW 263
66141: PUSH
66142: LD_INT 1
66144: EQUAL
66145: IFFALSE 66161
// ComExitVehicle ( IsInUnit ( j ) ) ;
66147: LD_VAR 0 3
66151: PPUSH
66152: CALL_OW 310
66156: PPUSH
66157: CALL_OW 121
// if GetControl ( j ) = control_remote then
66161: LD_VAR 0 3
66165: PPUSH
66166: CALL_OW 263
66170: PUSH
66171: LD_INT 2
66173: EQUAL
66174: IFFALSE 66185
// ComUnlink ( j ) ;
66176: LD_VAR 0 3
66180: PPUSH
66181: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66185: LD_ADDR_VAR 0 10
66189: PUSH
66190: LD_VAR 0 2
66194: PPUSH
66195: LD_INT 3
66197: PPUSH
66198: CALL 75972 0 2
66202: ST_TO_ADDR
// if fac then
66203: LD_VAR 0 10
66207: IFFALSE 66303
// begin for k in fac do
66209: LD_ADDR_VAR 0 4
66213: PUSH
66214: LD_VAR 0 10
66218: PUSH
66219: FOR_IN
66220: IFFALSE 66301
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66222: LD_ADDR_VAR 0 11
66226: PUSH
66227: LD_VAR 0 10
66231: PPUSH
66232: LD_VAR 0 3
66236: PPUSH
66237: CALL_OW 265
66241: PPUSH
66242: LD_VAR 0 3
66246: PPUSH
66247: CALL_OW 262
66251: PPUSH
66252: LD_VAR 0 3
66256: PPUSH
66257: CALL_OW 263
66261: PPUSH
66262: LD_VAR 0 3
66266: PPUSH
66267: CALL_OW 264
66271: PPUSH
66272: CALL 12447 0 5
66276: ST_TO_ADDR
// if components then
66277: LD_VAR 0 11
66281: IFFALSE 66299
// begin MC_InsertProduceList ( i , components ) ;
66283: LD_VAR 0 2
66287: PPUSH
66288: LD_VAR 0 11
66292: PPUSH
66293: CALL 75517 0 2
// break ;
66297: GO 66301
// end ; end ;
66299: GO 66219
66301: POP
66302: POP
// end ; continue ;
66303: GO 65848
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66305: LD_VAR 0 3
66309: PPUSH
66310: LD_INT 1
66312: PPUSH
66313: CALL_OW 289
66317: PUSH
66318: LD_INT 100
66320: LESS
66321: PUSH
66322: LD_VAR 0 3
66326: PPUSH
66327: CALL_OW 314
66331: NOT
66332: AND
66333: IFFALSE 66362
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66335: LD_VAR 0 3
66339: PPUSH
66340: LD_VAR 0 7
66344: PUSH
66345: LD_INT 2
66347: ARRAY
66348: PPUSH
66349: LD_VAR 0 7
66353: PUSH
66354: LD_INT 3
66356: ARRAY
66357: PPUSH
66358: CALL_OW 117
// break ;
66362: GO 66366
// end ;
66364: GO 65848
66366: POP
66367: POP
// end ; end ;
66368: GO 64564
66370: POP
66371: POP
// end ;
66372: LD_VAR 0 1
66376: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66377: LD_INT 0
66379: PPUSH
66380: PPUSH
66381: PPUSH
66382: PPUSH
// if not mc_bases then
66383: LD_EXP 43
66387: NOT
66388: IFFALSE 66392
// exit ;
66390: GO 66553
// for i = 1 to mc_bases do
66392: LD_ADDR_VAR 0 2
66396: PUSH
66397: DOUBLE
66398: LD_INT 1
66400: DEC
66401: ST_TO_ADDR
66402: LD_EXP 43
66406: PUSH
66407: FOR_TO
66408: IFFALSE 66551
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66410: LD_ADDR_VAR 0 4
66414: PUSH
66415: LD_EXP 62
66419: PUSH
66420: LD_VAR 0 2
66424: ARRAY
66425: PUSH
66426: LD_EXP 65
66430: PUSH
66431: LD_VAR 0 2
66435: ARRAY
66436: UNION
66437: PPUSH
66438: LD_INT 33
66440: PUSH
66441: LD_INT 2
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PPUSH
66448: CALL_OW 72
66452: ST_TO_ADDR
// if tmp then
66453: LD_VAR 0 4
66457: IFFALSE 66549
// for j in tmp do
66459: LD_ADDR_VAR 0 3
66463: PUSH
66464: LD_VAR 0 4
66468: PUSH
66469: FOR_IN
66470: IFFALSE 66547
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66472: LD_VAR 0 3
66476: PPUSH
66477: CALL_OW 312
66481: NOT
66482: PUSH
66483: LD_VAR 0 3
66487: PPUSH
66488: CALL_OW 256
66492: PUSH
66493: LD_INT 250
66495: GREATEREQUAL
66496: AND
66497: IFFALSE 66510
// Connect ( j ) else
66499: LD_VAR 0 3
66503: PPUSH
66504: CALL 17918 0 1
66508: GO 66545
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66510: LD_VAR 0 3
66514: PPUSH
66515: CALL_OW 256
66519: PUSH
66520: LD_INT 250
66522: LESS
66523: PUSH
66524: LD_VAR 0 3
66528: PPUSH
66529: CALL_OW 312
66533: AND
66534: IFFALSE 66545
// ComUnlink ( j ) ;
66536: LD_VAR 0 3
66540: PPUSH
66541: CALL_OW 136
66545: GO 66469
66547: POP
66548: POP
// end ;
66549: GO 66407
66551: POP
66552: POP
// end ;
66553: LD_VAR 0 1
66557: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66558: LD_INT 0
66560: PPUSH
66561: PPUSH
66562: PPUSH
66563: PPUSH
66564: PPUSH
// if not mc_bases then
66565: LD_EXP 43
66569: NOT
66570: IFFALSE 66574
// exit ;
66572: GO 67019
// for i = 1 to mc_bases do
66574: LD_ADDR_VAR 0 2
66578: PUSH
66579: DOUBLE
66580: LD_INT 1
66582: DEC
66583: ST_TO_ADDR
66584: LD_EXP 43
66588: PUSH
66589: FOR_TO
66590: IFFALSE 67017
// begin if not mc_produce [ i ] then
66592: LD_EXP 64
66596: PUSH
66597: LD_VAR 0 2
66601: ARRAY
66602: NOT
66603: IFFALSE 66607
// continue ;
66605: GO 66589
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66607: LD_ADDR_VAR 0 5
66611: PUSH
66612: LD_EXP 43
66616: PUSH
66617: LD_VAR 0 2
66621: ARRAY
66622: PPUSH
66623: LD_INT 30
66625: PUSH
66626: LD_INT 3
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PPUSH
66633: CALL_OW 72
66637: ST_TO_ADDR
// if not fac then
66638: LD_VAR 0 5
66642: NOT
66643: IFFALSE 66647
// continue ;
66645: GO 66589
// for j in fac do
66647: LD_ADDR_VAR 0 3
66651: PUSH
66652: LD_VAR 0 5
66656: PUSH
66657: FOR_IN
66658: IFFALSE 67013
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66660: LD_VAR 0 3
66664: PPUSH
66665: CALL_OW 461
66669: PUSH
66670: LD_INT 2
66672: NONEQUAL
66673: PUSH
66674: LD_VAR 0 3
66678: PPUSH
66679: LD_INT 15
66681: PPUSH
66682: CALL 17546 0 2
66686: PUSH
66687: LD_INT 4
66689: ARRAY
66690: OR
66691: IFFALSE 66695
// continue ;
66693: GO 66657
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66695: LD_VAR 0 3
66699: PPUSH
66700: LD_EXP 64
66704: PUSH
66705: LD_VAR 0 2
66709: ARRAY
66710: PUSH
66711: LD_INT 1
66713: ARRAY
66714: PUSH
66715: LD_INT 1
66717: ARRAY
66718: PPUSH
66719: LD_EXP 64
66723: PUSH
66724: LD_VAR 0 2
66728: ARRAY
66729: PUSH
66730: LD_INT 1
66732: ARRAY
66733: PUSH
66734: LD_INT 2
66736: ARRAY
66737: PPUSH
66738: LD_EXP 64
66742: PUSH
66743: LD_VAR 0 2
66747: ARRAY
66748: PUSH
66749: LD_INT 1
66751: ARRAY
66752: PUSH
66753: LD_INT 3
66755: ARRAY
66756: PPUSH
66757: LD_EXP 64
66761: PUSH
66762: LD_VAR 0 2
66766: ARRAY
66767: PUSH
66768: LD_INT 1
66770: ARRAY
66771: PUSH
66772: LD_INT 4
66774: ARRAY
66775: PPUSH
66776: CALL_OW 448
66780: PUSH
66781: LD_VAR 0 3
66785: PPUSH
66786: LD_EXP 64
66790: PUSH
66791: LD_VAR 0 2
66795: ARRAY
66796: PUSH
66797: LD_INT 1
66799: ARRAY
66800: PUSH
66801: LD_INT 1
66803: ARRAY
66804: PUSH
66805: LD_EXP 64
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: PUSH
66816: LD_INT 1
66818: ARRAY
66819: PUSH
66820: LD_INT 2
66822: ARRAY
66823: PUSH
66824: LD_EXP 64
66828: PUSH
66829: LD_VAR 0 2
66833: ARRAY
66834: PUSH
66835: LD_INT 1
66837: ARRAY
66838: PUSH
66839: LD_INT 3
66841: ARRAY
66842: PUSH
66843: LD_EXP 64
66847: PUSH
66848: LD_VAR 0 2
66852: ARRAY
66853: PUSH
66854: LD_INT 1
66856: ARRAY
66857: PUSH
66858: LD_INT 4
66860: ARRAY
66861: PUSH
66862: EMPTY
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: PPUSH
66868: CALL 21313 0 2
66872: AND
66873: IFFALSE 67011
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66875: LD_VAR 0 3
66879: PPUSH
66880: LD_EXP 64
66884: PUSH
66885: LD_VAR 0 2
66889: ARRAY
66890: PUSH
66891: LD_INT 1
66893: ARRAY
66894: PUSH
66895: LD_INT 1
66897: ARRAY
66898: PPUSH
66899: LD_EXP 64
66903: PUSH
66904: LD_VAR 0 2
66908: ARRAY
66909: PUSH
66910: LD_INT 1
66912: ARRAY
66913: PUSH
66914: LD_INT 2
66916: ARRAY
66917: PPUSH
66918: LD_EXP 64
66922: PUSH
66923: LD_VAR 0 2
66927: ARRAY
66928: PUSH
66929: LD_INT 1
66931: ARRAY
66932: PUSH
66933: LD_INT 3
66935: ARRAY
66936: PPUSH
66937: LD_EXP 64
66941: PUSH
66942: LD_VAR 0 2
66946: ARRAY
66947: PUSH
66948: LD_INT 1
66950: ARRAY
66951: PUSH
66952: LD_INT 4
66954: ARRAY
66955: PPUSH
66956: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66960: LD_ADDR_VAR 0 4
66964: PUSH
66965: LD_EXP 64
66969: PUSH
66970: LD_VAR 0 2
66974: ARRAY
66975: PPUSH
66976: LD_INT 1
66978: PPUSH
66979: CALL_OW 3
66983: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66984: LD_ADDR_EXP 64
66988: PUSH
66989: LD_EXP 64
66993: PPUSH
66994: LD_VAR 0 2
66998: PPUSH
66999: LD_VAR 0 4
67003: PPUSH
67004: CALL_OW 1
67008: ST_TO_ADDR
// break ;
67009: GO 67013
// end ; end ;
67011: GO 66657
67013: POP
67014: POP
// end ;
67015: GO 66589
67017: POP
67018: POP
// end ;
67019: LD_VAR 0 1
67023: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67024: LD_INT 0
67026: PPUSH
67027: PPUSH
67028: PPUSH
// if not mc_bases then
67029: LD_EXP 43
67033: NOT
67034: IFFALSE 67038
// exit ;
67036: GO 67127
// for i = 1 to mc_bases do
67038: LD_ADDR_VAR 0 2
67042: PUSH
67043: DOUBLE
67044: LD_INT 1
67046: DEC
67047: ST_TO_ADDR
67048: LD_EXP 43
67052: PUSH
67053: FOR_TO
67054: IFFALSE 67125
// begin if mc_attack [ i ] then
67056: LD_EXP 63
67060: PUSH
67061: LD_VAR 0 2
67065: ARRAY
67066: IFFALSE 67123
// begin tmp := mc_attack [ i ] [ 1 ] ;
67068: LD_ADDR_VAR 0 3
67072: PUSH
67073: LD_EXP 63
67077: PUSH
67078: LD_VAR 0 2
67082: ARRAY
67083: PUSH
67084: LD_INT 1
67086: ARRAY
67087: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67088: LD_ADDR_EXP 63
67092: PUSH
67093: LD_EXP 63
67097: PPUSH
67098: LD_VAR 0 2
67102: PPUSH
67103: EMPTY
67104: PPUSH
67105: CALL_OW 1
67109: ST_TO_ADDR
// Attack ( tmp ) ;
67110: LD_VAR 0 3
67114: PPUSH
67115: CALL 81943 0 1
// exit ;
67119: POP
67120: POP
67121: GO 67127
// end ; end ;
67123: GO 67053
67125: POP
67126: POP
// end ;
67127: LD_VAR 0 1
67131: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67132: LD_INT 0
67134: PPUSH
67135: PPUSH
67136: PPUSH
67137: PPUSH
67138: PPUSH
67139: PPUSH
67140: PPUSH
// if not mc_bases then
67141: LD_EXP 43
67145: NOT
67146: IFFALSE 67150
// exit ;
67148: GO 68007
// for i = 1 to mc_bases do
67150: LD_ADDR_VAR 0 2
67154: PUSH
67155: DOUBLE
67156: LD_INT 1
67158: DEC
67159: ST_TO_ADDR
67160: LD_EXP 43
67164: PUSH
67165: FOR_TO
67166: IFFALSE 68005
// begin if not mc_bases [ i ] then
67168: LD_EXP 43
67172: PUSH
67173: LD_VAR 0 2
67177: ARRAY
67178: NOT
67179: IFFALSE 67183
// continue ;
67181: GO 67165
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67183: LD_ADDR_VAR 0 7
67187: PUSH
67188: LD_EXP 43
67192: PUSH
67193: LD_VAR 0 2
67197: ARRAY
67198: PUSH
67199: LD_INT 1
67201: ARRAY
67202: PPUSH
67203: CALL 11598 0 1
67207: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67208: LD_ADDR_EXP 66
67212: PUSH
67213: LD_EXP 66
67217: PPUSH
67218: LD_VAR 0 2
67222: PPUSH
67223: LD_EXP 43
67227: PUSH
67228: LD_VAR 0 2
67232: ARRAY
67233: PUSH
67234: LD_INT 1
67236: ARRAY
67237: PPUSH
67238: CALL_OW 255
67242: PPUSH
67243: LD_EXP 68
67247: PUSH
67248: LD_VAR 0 2
67252: ARRAY
67253: PPUSH
67254: CALL 11563 0 2
67258: PPUSH
67259: CALL_OW 1
67263: ST_TO_ADDR
// if not mc_scan [ i ] then
67264: LD_EXP 66
67268: PUSH
67269: LD_VAR 0 2
67273: ARRAY
67274: NOT
67275: IFFALSE 67453
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67277: LD_ADDR_EXP 86
67281: PUSH
67282: LD_EXP 86
67286: PPUSH
67287: LD_VAR 0 2
67291: PPUSH
67292: LD_INT 0
67294: PPUSH
67295: CALL_OW 1
67299: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67300: LD_ADDR_VAR 0 4
67304: PUSH
67305: LD_EXP 43
67309: PUSH
67310: LD_VAR 0 2
67314: ARRAY
67315: PPUSH
67316: LD_INT 2
67318: PUSH
67319: LD_INT 25
67321: PUSH
67322: LD_INT 5
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: LD_INT 25
67331: PUSH
67332: LD_INT 8
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 25
67341: PUSH
67342: LD_INT 9
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: PPUSH
67355: CALL_OW 72
67359: ST_TO_ADDR
// if not tmp then
67360: LD_VAR 0 4
67364: NOT
67365: IFFALSE 67369
// continue ;
67367: GO 67165
// for j in tmp do
67369: LD_ADDR_VAR 0 3
67373: PUSH
67374: LD_VAR 0 4
67378: PUSH
67379: FOR_IN
67380: IFFALSE 67451
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67382: LD_VAR 0 3
67386: PPUSH
67387: CALL_OW 310
67391: PPUSH
67392: CALL_OW 266
67396: PUSH
67397: LD_INT 5
67399: EQUAL
67400: PUSH
67401: LD_VAR 0 3
67405: PPUSH
67406: CALL_OW 257
67410: PUSH
67411: LD_INT 1
67413: EQUAL
67414: AND
67415: PUSH
67416: LD_VAR 0 3
67420: PPUSH
67421: CALL_OW 459
67425: NOT
67426: AND
67427: PUSH
67428: LD_VAR 0 7
67432: AND
67433: IFFALSE 67449
// ComChangeProfession ( j , class ) ;
67435: LD_VAR 0 3
67439: PPUSH
67440: LD_VAR 0 7
67444: PPUSH
67445: CALL_OW 123
67449: GO 67379
67451: POP
67452: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67453: LD_EXP 66
67457: PUSH
67458: LD_VAR 0 2
67462: ARRAY
67463: PUSH
67464: LD_EXP 86
67468: PUSH
67469: LD_VAR 0 2
67473: ARRAY
67474: NOT
67475: AND
67476: PUSH
67477: LD_EXP 65
67481: PUSH
67482: LD_VAR 0 2
67486: ARRAY
67487: NOT
67488: AND
67489: PUSH
67490: LD_EXP 43
67494: PUSH
67495: LD_VAR 0 2
67499: ARRAY
67500: PPUSH
67501: LD_INT 50
67503: PUSH
67504: EMPTY
67505: LIST
67506: PUSH
67507: LD_INT 2
67509: PUSH
67510: LD_INT 30
67512: PUSH
67513: LD_INT 32
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 30
67522: PUSH
67523: LD_INT 33
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 30
67532: PUSH
67533: LD_INT 4
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 30
67542: PUSH
67543: LD_INT 5
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PPUSH
67561: CALL_OW 72
67565: PUSH
67566: LD_INT 4
67568: LESS
67569: PUSH
67570: LD_EXP 43
67574: PUSH
67575: LD_VAR 0 2
67579: ARRAY
67580: PPUSH
67581: LD_INT 3
67583: PUSH
67584: LD_INT 24
67586: PUSH
67587: LD_INT 1000
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: LD_INT 30
67603: PUSH
67604: LD_INT 0
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 30
67613: PUSH
67614: LD_INT 1
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: LIST
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PPUSH
67630: CALL_OW 72
67634: OR
67635: AND
67636: IFFALSE 67887
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67638: LD_ADDR_EXP 86
67642: PUSH
67643: LD_EXP 86
67647: PPUSH
67648: LD_VAR 0 2
67652: PPUSH
67653: LD_INT 1
67655: PPUSH
67656: CALL_OW 1
67660: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67661: LD_ADDR_VAR 0 4
67665: PUSH
67666: LD_EXP 43
67670: PUSH
67671: LD_VAR 0 2
67675: ARRAY
67676: PPUSH
67677: LD_INT 2
67679: PUSH
67680: LD_INT 25
67682: PUSH
67683: LD_INT 1
67685: PUSH
67686: EMPTY
67687: LIST
67688: LIST
67689: PUSH
67690: LD_INT 25
67692: PUSH
67693: LD_INT 5
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 25
67702: PUSH
67703: LD_INT 8
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: PUSH
67710: LD_INT 25
67712: PUSH
67713: LD_INT 9
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: PPUSH
67727: CALL_OW 72
67731: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67732: LD_ADDR_VAR 0 4
67736: PUSH
67737: LD_VAR 0 4
67741: PUSH
67742: LD_VAR 0 4
67746: PPUSH
67747: LD_INT 18
67749: PPUSH
67750: CALL 44861 0 2
67754: DIFF
67755: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67756: LD_VAR 0 4
67760: NOT
67761: PUSH
67762: LD_EXP 43
67766: PUSH
67767: LD_VAR 0 2
67771: ARRAY
67772: PPUSH
67773: LD_INT 2
67775: PUSH
67776: LD_INT 30
67778: PUSH
67779: LD_INT 4
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 30
67788: PUSH
67789: LD_INT 5
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: LIST
67800: PPUSH
67801: CALL_OW 72
67805: NOT
67806: AND
67807: IFFALSE 67869
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67809: LD_ADDR_VAR 0 4
67813: PUSH
67814: LD_EXP 43
67818: PUSH
67819: LD_VAR 0 2
67823: ARRAY
67824: PPUSH
67825: LD_INT 2
67827: PUSH
67828: LD_INT 25
67830: PUSH
67831: LD_INT 2
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 25
67840: PUSH
67841: LD_INT 3
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 25
67850: PUSH
67851: LD_INT 4
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: PPUSH
67864: CALL_OW 72
67868: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67869: LD_VAR 0 2
67873: PPUSH
67874: LD_VAR 0 4
67878: PPUSH
67879: CALL 86652 0 2
// exit ;
67883: POP
67884: POP
67885: GO 68007
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67887: LD_EXP 66
67891: PUSH
67892: LD_VAR 0 2
67896: ARRAY
67897: PUSH
67898: LD_EXP 86
67902: PUSH
67903: LD_VAR 0 2
67907: ARRAY
67908: NOT
67909: AND
67910: PUSH
67911: LD_EXP 65
67915: PUSH
67916: LD_VAR 0 2
67920: ARRAY
67921: AND
67922: IFFALSE 68003
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67924: LD_ADDR_EXP 86
67928: PUSH
67929: LD_EXP 86
67933: PPUSH
67934: LD_VAR 0 2
67938: PPUSH
67939: LD_INT 1
67941: PPUSH
67942: CALL_OW 1
67946: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67947: LD_ADDR_VAR 0 4
67951: PUSH
67952: LD_EXP 65
67956: PUSH
67957: LD_VAR 0 2
67961: ARRAY
67962: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67963: LD_ADDR_EXP 65
67967: PUSH
67968: LD_EXP 65
67972: PPUSH
67973: LD_VAR 0 2
67977: PPUSH
67978: EMPTY
67979: PPUSH
67980: CALL_OW 1
67984: ST_TO_ADDR
// Defend ( i , tmp ) ;
67985: LD_VAR 0 2
67989: PPUSH
67990: LD_VAR 0 4
67994: PPUSH
67995: CALL 87248 0 2
// exit ;
67999: POP
68000: POP
68001: GO 68007
// end ; end ;
68003: GO 67165
68005: POP
68006: POP
// end ;
68007: LD_VAR 0 1
68011: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68012: LD_INT 0
68014: PPUSH
68015: PPUSH
68016: PPUSH
68017: PPUSH
68018: PPUSH
68019: PPUSH
68020: PPUSH
68021: PPUSH
68022: PPUSH
68023: PPUSH
68024: PPUSH
// if not mc_bases then
68025: LD_EXP 43
68029: NOT
68030: IFFALSE 68034
// exit ;
68032: GO 69121
// for i = 1 to mc_bases do
68034: LD_ADDR_VAR 0 2
68038: PUSH
68039: DOUBLE
68040: LD_INT 1
68042: DEC
68043: ST_TO_ADDR
68044: LD_EXP 43
68048: PUSH
68049: FOR_TO
68050: IFFALSE 69119
// begin tmp := mc_lab [ i ] ;
68052: LD_ADDR_VAR 0 6
68056: PUSH
68057: LD_EXP 76
68061: PUSH
68062: LD_VAR 0 2
68066: ARRAY
68067: ST_TO_ADDR
// if not tmp then
68068: LD_VAR 0 6
68072: NOT
68073: IFFALSE 68077
// continue ;
68075: GO 68049
// idle_lab := 0 ;
68077: LD_ADDR_VAR 0 11
68081: PUSH
68082: LD_INT 0
68084: ST_TO_ADDR
// for j in tmp do
68085: LD_ADDR_VAR 0 3
68089: PUSH
68090: LD_VAR 0 6
68094: PUSH
68095: FOR_IN
68096: IFFALSE 69115
// begin researching := false ;
68098: LD_ADDR_VAR 0 10
68102: PUSH
68103: LD_INT 0
68105: ST_TO_ADDR
// side := GetSide ( j ) ;
68106: LD_ADDR_VAR 0 4
68110: PUSH
68111: LD_VAR 0 3
68115: PPUSH
68116: CALL_OW 255
68120: ST_TO_ADDR
// if not mc_tech [ side ] then
68121: LD_EXP 70
68125: PUSH
68126: LD_VAR 0 4
68130: ARRAY
68131: NOT
68132: IFFALSE 68136
// continue ;
68134: GO 68095
// if BuildingStatus ( j ) = bs_idle then
68136: LD_VAR 0 3
68140: PPUSH
68141: CALL_OW 461
68145: PUSH
68146: LD_INT 2
68148: EQUAL
68149: IFFALSE 68337
// begin if idle_lab and UnitsInside ( j ) < 6 then
68151: LD_VAR 0 11
68155: PUSH
68156: LD_VAR 0 3
68160: PPUSH
68161: CALL_OW 313
68165: PUSH
68166: LD_INT 6
68168: LESS
68169: AND
68170: IFFALSE 68241
// begin tmp2 := UnitsInside ( idle_lab ) ;
68172: LD_ADDR_VAR 0 9
68176: PUSH
68177: LD_VAR 0 11
68181: PPUSH
68182: CALL_OW 313
68186: ST_TO_ADDR
// if tmp2 then
68187: LD_VAR 0 9
68191: IFFALSE 68233
// for x in tmp2 do
68193: LD_ADDR_VAR 0 7
68197: PUSH
68198: LD_VAR 0 9
68202: PUSH
68203: FOR_IN
68204: IFFALSE 68231
// begin ComExitBuilding ( x ) ;
68206: LD_VAR 0 7
68210: PPUSH
68211: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68215: LD_VAR 0 7
68219: PPUSH
68220: LD_VAR 0 3
68224: PPUSH
68225: CALL_OW 180
// end ;
68229: GO 68203
68231: POP
68232: POP
// idle_lab := 0 ;
68233: LD_ADDR_VAR 0 11
68237: PUSH
68238: LD_INT 0
68240: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68241: LD_ADDR_VAR 0 5
68245: PUSH
68246: LD_EXP 70
68250: PUSH
68251: LD_VAR 0 4
68255: ARRAY
68256: PUSH
68257: FOR_IN
68258: IFFALSE 68318
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68260: LD_VAR 0 3
68264: PPUSH
68265: LD_VAR 0 5
68269: PPUSH
68270: CALL_OW 430
68274: PUSH
68275: LD_VAR 0 4
68279: PPUSH
68280: LD_VAR 0 5
68284: PPUSH
68285: CALL 10668 0 2
68289: AND
68290: IFFALSE 68316
// begin researching := true ;
68292: LD_ADDR_VAR 0 10
68296: PUSH
68297: LD_INT 1
68299: ST_TO_ADDR
// ComResearch ( j , t ) ;
68300: LD_VAR 0 3
68304: PPUSH
68305: LD_VAR 0 5
68309: PPUSH
68310: CALL_OW 124
// break ;
68314: GO 68318
// end ;
68316: GO 68257
68318: POP
68319: POP
// if not researching then
68320: LD_VAR 0 10
68324: NOT
68325: IFFALSE 68337
// idle_lab := j ;
68327: LD_ADDR_VAR 0 11
68331: PUSH
68332: LD_VAR 0 3
68336: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68337: LD_VAR 0 3
68341: PPUSH
68342: CALL_OW 461
68346: PUSH
68347: LD_INT 10
68349: EQUAL
68350: IFFALSE 68938
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68352: LD_EXP 72
68356: PUSH
68357: LD_VAR 0 2
68361: ARRAY
68362: NOT
68363: PUSH
68364: LD_EXP 73
68368: PUSH
68369: LD_VAR 0 2
68373: ARRAY
68374: NOT
68375: AND
68376: PUSH
68377: LD_EXP 70
68381: PUSH
68382: LD_VAR 0 4
68386: ARRAY
68387: PUSH
68388: LD_INT 1
68390: GREATER
68391: AND
68392: IFFALSE 68523
// begin ComCancel ( j ) ;
68394: LD_VAR 0 3
68398: PPUSH
68399: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68403: LD_ADDR_EXP 70
68407: PUSH
68408: LD_EXP 70
68412: PPUSH
68413: LD_VAR 0 4
68417: PPUSH
68418: LD_EXP 70
68422: PUSH
68423: LD_VAR 0 4
68427: ARRAY
68428: PPUSH
68429: LD_EXP 70
68433: PUSH
68434: LD_VAR 0 4
68438: ARRAY
68439: PUSH
68440: LD_INT 1
68442: MINUS
68443: PPUSH
68444: LD_EXP 70
68448: PUSH
68449: LD_VAR 0 4
68453: ARRAY
68454: PPUSH
68455: LD_INT 0
68457: PPUSH
68458: CALL 14367 0 4
68462: PPUSH
68463: CALL_OW 1
68467: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68468: LD_ADDR_EXP 70
68472: PUSH
68473: LD_EXP 70
68477: PPUSH
68478: LD_VAR 0 4
68482: PPUSH
68483: LD_EXP 70
68487: PUSH
68488: LD_VAR 0 4
68492: ARRAY
68493: PPUSH
68494: LD_EXP 70
68498: PUSH
68499: LD_VAR 0 4
68503: ARRAY
68504: PPUSH
68505: LD_INT 1
68507: PPUSH
68508: LD_INT 0
68510: PPUSH
68511: CALL 14367 0 4
68515: PPUSH
68516: CALL_OW 1
68520: ST_TO_ADDR
// continue ;
68521: GO 68095
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68523: LD_EXP 72
68527: PUSH
68528: LD_VAR 0 2
68532: ARRAY
68533: PUSH
68534: LD_EXP 73
68538: PUSH
68539: LD_VAR 0 2
68543: ARRAY
68544: NOT
68545: AND
68546: IFFALSE 68673
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68548: LD_ADDR_EXP 73
68552: PUSH
68553: LD_EXP 73
68557: PPUSH
68558: LD_VAR 0 2
68562: PUSH
68563: LD_EXP 73
68567: PUSH
68568: LD_VAR 0 2
68572: ARRAY
68573: PUSH
68574: LD_INT 1
68576: PLUS
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PPUSH
68582: LD_EXP 72
68586: PUSH
68587: LD_VAR 0 2
68591: ARRAY
68592: PUSH
68593: LD_INT 1
68595: ARRAY
68596: PPUSH
68597: CALL 14949 0 3
68601: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68602: LD_EXP 72
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: PUSH
68613: LD_INT 1
68615: ARRAY
68616: PPUSH
68617: LD_INT 112
68619: PPUSH
68620: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68624: LD_ADDR_VAR 0 9
68628: PUSH
68629: LD_EXP 72
68633: PUSH
68634: LD_VAR 0 2
68638: ARRAY
68639: PPUSH
68640: LD_INT 1
68642: PPUSH
68643: CALL_OW 3
68647: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68648: LD_ADDR_EXP 72
68652: PUSH
68653: LD_EXP 72
68657: PPUSH
68658: LD_VAR 0 2
68662: PPUSH
68663: LD_VAR 0 9
68667: PPUSH
68668: CALL_OW 1
68672: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68673: LD_EXP 72
68677: PUSH
68678: LD_VAR 0 2
68682: ARRAY
68683: PUSH
68684: LD_EXP 73
68688: PUSH
68689: LD_VAR 0 2
68693: ARRAY
68694: AND
68695: PUSH
68696: LD_EXP 73
68700: PUSH
68701: LD_VAR 0 2
68705: ARRAY
68706: PUSH
68707: LD_INT 1
68709: ARRAY
68710: PPUSH
68711: CALL_OW 310
68715: NOT
68716: AND
68717: PUSH
68718: LD_VAR 0 3
68722: PPUSH
68723: CALL_OW 313
68727: PUSH
68728: LD_INT 6
68730: EQUAL
68731: AND
68732: IFFALSE 68788
// begin tmp2 := UnitsInside ( j ) ;
68734: LD_ADDR_VAR 0 9
68738: PUSH
68739: LD_VAR 0 3
68743: PPUSH
68744: CALL_OW 313
68748: ST_TO_ADDR
// if tmp2 = 6 then
68749: LD_VAR 0 9
68753: PUSH
68754: LD_INT 6
68756: EQUAL
68757: IFFALSE 68788
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68759: LD_VAR 0 9
68763: PUSH
68764: LD_INT 1
68766: ARRAY
68767: PPUSH
68768: LD_INT 112
68770: PPUSH
68771: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68775: LD_VAR 0 9
68779: PUSH
68780: LD_INT 1
68782: ARRAY
68783: PPUSH
68784: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68788: LD_EXP 73
68792: PUSH
68793: LD_VAR 0 2
68797: ARRAY
68798: PUSH
68799: LD_EXP 73
68803: PUSH
68804: LD_VAR 0 2
68808: ARRAY
68809: PUSH
68810: LD_INT 1
68812: ARRAY
68813: PPUSH
68814: CALL_OW 314
68818: NOT
68819: AND
68820: PUSH
68821: LD_EXP 73
68825: PUSH
68826: LD_VAR 0 2
68830: ARRAY
68831: PUSH
68832: LD_INT 1
68834: ARRAY
68835: PPUSH
68836: CALL_OW 310
68840: NOT
68841: AND
68842: IFFALSE 68868
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68844: LD_EXP 73
68848: PUSH
68849: LD_VAR 0 2
68853: ARRAY
68854: PUSH
68855: LD_INT 1
68857: ARRAY
68858: PPUSH
68859: LD_VAR 0 3
68863: PPUSH
68864: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68868: LD_EXP 73
68872: PUSH
68873: LD_VAR 0 2
68877: ARRAY
68878: PUSH
68879: LD_INT 1
68881: ARRAY
68882: PPUSH
68883: CALL_OW 310
68887: PUSH
68888: LD_EXP 73
68892: PUSH
68893: LD_VAR 0 2
68897: ARRAY
68898: PUSH
68899: LD_INT 1
68901: ARRAY
68902: PPUSH
68903: CALL_OW 310
68907: PPUSH
68908: CALL_OW 461
68912: PUSH
68913: LD_INT 3
68915: NONEQUAL
68916: AND
68917: IFFALSE 68938
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68919: LD_EXP 73
68923: PUSH
68924: LD_VAR 0 2
68928: ARRAY
68929: PUSH
68930: LD_INT 1
68932: ARRAY
68933: PPUSH
68934: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68938: LD_VAR 0 3
68942: PPUSH
68943: CALL_OW 461
68947: PUSH
68948: LD_INT 6
68950: EQUAL
68951: PUSH
68952: LD_VAR 0 6
68956: PUSH
68957: LD_INT 1
68959: GREATER
68960: AND
68961: IFFALSE 69113
// begin sci := [ ] ;
68963: LD_ADDR_VAR 0 8
68967: PUSH
68968: EMPTY
68969: ST_TO_ADDR
// for x in ( tmp diff j ) do
68970: LD_ADDR_VAR 0 7
68974: PUSH
68975: LD_VAR 0 6
68979: PUSH
68980: LD_VAR 0 3
68984: DIFF
68985: PUSH
68986: FOR_IN
68987: IFFALSE 69039
// begin if sci = 6 then
68989: LD_VAR 0 8
68993: PUSH
68994: LD_INT 6
68996: EQUAL
68997: IFFALSE 69001
// break ;
68999: GO 69039
// if BuildingStatus ( x ) = bs_idle then
69001: LD_VAR 0 7
69005: PPUSH
69006: CALL_OW 461
69010: PUSH
69011: LD_INT 2
69013: EQUAL
69014: IFFALSE 69037
// sci := sci ^ UnitsInside ( x ) ;
69016: LD_ADDR_VAR 0 8
69020: PUSH
69021: LD_VAR 0 8
69025: PUSH
69026: LD_VAR 0 7
69030: PPUSH
69031: CALL_OW 313
69035: ADD
69036: ST_TO_ADDR
// end ;
69037: GO 68986
69039: POP
69040: POP
// if not sci then
69041: LD_VAR 0 8
69045: NOT
69046: IFFALSE 69050
// continue ;
69048: GO 68095
// for x in sci do
69050: LD_ADDR_VAR 0 7
69054: PUSH
69055: LD_VAR 0 8
69059: PUSH
69060: FOR_IN
69061: IFFALSE 69111
// if IsInUnit ( x ) and not HasTask ( x ) then
69063: LD_VAR 0 7
69067: PPUSH
69068: CALL_OW 310
69072: PUSH
69073: LD_VAR 0 7
69077: PPUSH
69078: CALL_OW 314
69082: NOT
69083: AND
69084: IFFALSE 69109
// begin ComExitBuilding ( x ) ;
69086: LD_VAR 0 7
69090: PPUSH
69091: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69095: LD_VAR 0 7
69099: PPUSH
69100: LD_VAR 0 3
69104: PPUSH
69105: CALL_OW 180
// end ;
69109: GO 69060
69111: POP
69112: POP
// end ; end ;
69113: GO 68095
69115: POP
69116: POP
// end ;
69117: GO 68049
69119: POP
69120: POP
// end ;
69121: LD_VAR 0 1
69125: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69126: LD_INT 0
69128: PPUSH
69129: PPUSH
// if not mc_bases then
69130: LD_EXP 43
69134: NOT
69135: IFFALSE 69139
// exit ;
69137: GO 69220
// for i = 1 to mc_bases do
69139: LD_ADDR_VAR 0 2
69143: PUSH
69144: DOUBLE
69145: LD_INT 1
69147: DEC
69148: ST_TO_ADDR
69149: LD_EXP 43
69153: PUSH
69154: FOR_TO
69155: IFFALSE 69218
// if mc_mines [ i ] and mc_miners [ i ] then
69157: LD_EXP 56
69161: PUSH
69162: LD_VAR 0 2
69166: ARRAY
69167: PUSH
69168: LD_EXP 57
69172: PUSH
69173: LD_VAR 0 2
69177: ARRAY
69178: AND
69179: IFFALSE 69216
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69181: LD_EXP 57
69185: PUSH
69186: LD_VAR 0 2
69190: ARRAY
69191: PUSH
69192: LD_INT 1
69194: ARRAY
69195: PPUSH
69196: CALL_OW 255
69200: PPUSH
69201: LD_EXP 56
69205: PUSH
69206: LD_VAR 0 2
69210: ARRAY
69211: PPUSH
69212: CALL 11751 0 2
69216: GO 69154
69218: POP
69219: POP
// end ;
69220: LD_VAR 0 1
69224: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69225: LD_INT 0
69227: PPUSH
69228: PPUSH
69229: PPUSH
69230: PPUSH
69231: PPUSH
69232: PPUSH
69233: PPUSH
69234: PPUSH
// if not mc_bases or not mc_parking then
69235: LD_EXP 43
69239: NOT
69240: PUSH
69241: LD_EXP 67
69245: NOT
69246: OR
69247: IFFALSE 69251
// exit ;
69249: GO 69989
// for i = 1 to mc_bases do
69251: LD_ADDR_VAR 0 2
69255: PUSH
69256: DOUBLE
69257: LD_INT 1
69259: DEC
69260: ST_TO_ADDR
69261: LD_EXP 43
69265: PUSH
69266: FOR_TO
69267: IFFALSE 69987
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69269: LD_EXP 43
69273: PUSH
69274: LD_VAR 0 2
69278: ARRAY
69279: NOT
69280: PUSH
69281: LD_EXP 67
69285: PUSH
69286: LD_VAR 0 2
69290: ARRAY
69291: NOT
69292: OR
69293: IFFALSE 69297
// continue ;
69295: GO 69266
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69297: LD_ADDR_VAR 0 5
69301: PUSH
69302: LD_EXP 43
69306: PUSH
69307: LD_VAR 0 2
69311: ARRAY
69312: PUSH
69313: LD_INT 1
69315: ARRAY
69316: PPUSH
69317: CALL_OW 255
69321: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69322: LD_ADDR_VAR 0 6
69326: PUSH
69327: LD_EXP 43
69331: PUSH
69332: LD_VAR 0 2
69336: ARRAY
69337: PPUSH
69338: LD_INT 30
69340: PUSH
69341: LD_INT 3
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PPUSH
69348: CALL_OW 72
69352: ST_TO_ADDR
// if not fac then
69353: LD_VAR 0 6
69357: NOT
69358: IFFALSE 69409
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69360: LD_ADDR_VAR 0 6
69364: PUSH
69365: LD_EXP 43
69369: PUSH
69370: LD_VAR 0 2
69374: ARRAY
69375: PPUSH
69376: LD_INT 2
69378: PUSH
69379: LD_INT 30
69381: PUSH
69382: LD_INT 0
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 30
69391: PUSH
69392: LD_INT 1
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: LIST
69403: PPUSH
69404: CALL_OW 72
69408: ST_TO_ADDR
// if not fac then
69409: LD_VAR 0 6
69413: NOT
69414: IFFALSE 69418
// continue ;
69416: GO 69266
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69418: LD_ADDR_VAR 0 7
69422: PUSH
69423: LD_EXP 67
69427: PUSH
69428: LD_VAR 0 2
69432: ARRAY
69433: PPUSH
69434: LD_INT 22
69436: PUSH
69437: LD_VAR 0 5
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 21
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 3
69458: PUSH
69459: LD_INT 60
69461: PUSH
69462: EMPTY
69463: LIST
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 3
69471: PUSH
69472: LD_INT 24
69474: PUSH
69475: LD_INT 1000
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: PPUSH
69492: CALL_OW 70
69496: ST_TO_ADDR
// for j in fac do
69497: LD_ADDR_VAR 0 3
69501: PUSH
69502: LD_VAR 0 6
69506: PUSH
69507: FOR_IN
69508: IFFALSE 69603
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69510: LD_ADDR_VAR 0 7
69514: PUSH
69515: LD_VAR 0 7
69519: PUSH
69520: LD_INT 22
69522: PUSH
69523: LD_VAR 0 5
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 91
69534: PUSH
69535: LD_VAR 0 3
69539: PUSH
69540: LD_INT 15
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 21
69550: PUSH
69551: LD_INT 2
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 3
69560: PUSH
69561: LD_INT 60
69563: PUSH
69564: EMPTY
69565: LIST
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 3
69573: PUSH
69574: LD_INT 24
69576: PUSH
69577: LD_INT 1000
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: PPUSH
69595: CALL_OW 69
69599: UNION
69600: ST_TO_ADDR
69601: GO 69507
69603: POP
69604: POP
// if not vehs then
69605: LD_VAR 0 7
69609: NOT
69610: IFFALSE 69636
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69612: LD_ADDR_EXP 55
69616: PUSH
69617: LD_EXP 55
69621: PPUSH
69622: LD_VAR 0 2
69626: PPUSH
69627: EMPTY
69628: PPUSH
69629: CALL_OW 1
69633: ST_TO_ADDR
// continue ;
69634: GO 69266
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69636: LD_ADDR_VAR 0 8
69640: PUSH
69641: LD_EXP 43
69645: PUSH
69646: LD_VAR 0 2
69650: ARRAY
69651: PPUSH
69652: LD_INT 30
69654: PUSH
69655: LD_INT 3
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PPUSH
69662: CALL_OW 72
69666: ST_TO_ADDR
// if tmp then
69667: LD_VAR 0 8
69671: IFFALSE 69774
// begin for j in tmp do
69673: LD_ADDR_VAR 0 3
69677: PUSH
69678: LD_VAR 0 8
69682: PUSH
69683: FOR_IN
69684: IFFALSE 69772
// for k in UnitsInside ( j ) do
69686: LD_ADDR_VAR 0 4
69690: PUSH
69691: LD_VAR 0 3
69695: PPUSH
69696: CALL_OW 313
69700: PUSH
69701: FOR_IN
69702: IFFALSE 69768
// if k then
69704: LD_VAR 0 4
69708: IFFALSE 69766
// if not k in mc_repair_vehicle [ i ] then
69710: LD_VAR 0 4
69714: PUSH
69715: LD_EXP 55
69719: PUSH
69720: LD_VAR 0 2
69724: ARRAY
69725: IN
69726: NOT
69727: IFFALSE 69766
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69729: LD_ADDR_EXP 55
69733: PUSH
69734: LD_EXP 55
69738: PPUSH
69739: LD_VAR 0 2
69743: PPUSH
69744: LD_EXP 55
69748: PUSH
69749: LD_VAR 0 2
69753: ARRAY
69754: PUSH
69755: LD_VAR 0 4
69759: UNION
69760: PPUSH
69761: CALL_OW 1
69765: ST_TO_ADDR
69766: GO 69701
69768: POP
69769: POP
69770: GO 69683
69772: POP
69773: POP
// end ; if not mc_repair_vehicle [ i ] then
69774: LD_EXP 55
69778: PUSH
69779: LD_VAR 0 2
69783: ARRAY
69784: NOT
69785: IFFALSE 69789
// continue ;
69787: GO 69266
// for j in mc_repair_vehicle [ i ] do
69789: LD_ADDR_VAR 0 3
69793: PUSH
69794: LD_EXP 55
69798: PUSH
69799: LD_VAR 0 2
69803: ARRAY
69804: PUSH
69805: FOR_IN
69806: IFFALSE 69983
// begin if GetClass ( j ) <> 3 then
69808: LD_VAR 0 3
69812: PPUSH
69813: CALL_OW 257
69817: PUSH
69818: LD_INT 3
69820: NONEQUAL
69821: IFFALSE 69862
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69823: LD_ADDR_EXP 55
69827: PUSH
69828: LD_EXP 55
69832: PPUSH
69833: LD_VAR 0 2
69837: PPUSH
69838: LD_EXP 55
69842: PUSH
69843: LD_VAR 0 2
69847: ARRAY
69848: PUSH
69849: LD_VAR 0 3
69853: DIFF
69854: PPUSH
69855: CALL_OW 1
69859: ST_TO_ADDR
// continue ;
69860: GO 69805
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69862: LD_VAR 0 3
69866: PPUSH
69867: CALL_OW 311
69871: NOT
69872: PUSH
69873: LD_VAR 0 3
69877: PUSH
69878: LD_EXP 46
69882: PUSH
69883: LD_VAR 0 2
69887: ARRAY
69888: PUSH
69889: LD_INT 1
69891: ARRAY
69892: IN
69893: NOT
69894: AND
69895: PUSH
69896: LD_VAR 0 3
69900: PUSH
69901: LD_EXP 46
69905: PUSH
69906: LD_VAR 0 2
69910: ARRAY
69911: PUSH
69912: LD_INT 2
69914: ARRAY
69915: IN
69916: NOT
69917: AND
69918: IFFALSE 69981
// begin if IsInUnit ( j ) then
69920: LD_VAR 0 3
69924: PPUSH
69925: CALL_OW 310
69929: IFFALSE 69942
// ComExitBuilding ( j ) else
69931: LD_VAR 0 3
69935: PPUSH
69936: CALL_OW 122
69940: GO 69981
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69942: LD_VAR 0 3
69946: PPUSH
69947: LD_VAR 0 7
69951: PUSH
69952: LD_INT 1
69954: ARRAY
69955: PPUSH
69956: CALL 49345 0 2
69960: NOT
69961: IFFALSE 69981
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69963: LD_VAR 0 3
69967: PPUSH
69968: LD_VAR 0 7
69972: PUSH
69973: LD_INT 1
69975: ARRAY
69976: PPUSH
69977: CALL_OW 129
// end ; end ;
69981: GO 69805
69983: POP
69984: POP
// end ;
69985: GO 69266
69987: POP
69988: POP
// end ;
69989: LD_VAR 0 1
69993: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69994: LD_INT 0
69996: PPUSH
69997: PPUSH
69998: PPUSH
69999: PPUSH
70000: PPUSH
70001: PPUSH
70002: PPUSH
70003: PPUSH
70004: PPUSH
70005: PPUSH
70006: PPUSH
// if not mc_bases then
70007: LD_EXP 43
70011: NOT
70012: IFFALSE 70016
// exit ;
70014: GO 70818
// for i = 1 to mc_bases do
70016: LD_ADDR_VAR 0 2
70020: PUSH
70021: DOUBLE
70022: LD_INT 1
70024: DEC
70025: ST_TO_ADDR
70026: LD_EXP 43
70030: PUSH
70031: FOR_TO
70032: IFFALSE 70816
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70034: LD_EXP 71
70038: PUSH
70039: LD_VAR 0 2
70043: ARRAY
70044: NOT
70045: PUSH
70046: LD_EXP 46
70050: PUSH
70051: LD_VAR 0 2
70055: ARRAY
70056: PUSH
70057: LD_INT 1
70059: ARRAY
70060: OR
70061: PUSH
70062: LD_EXP 46
70066: PUSH
70067: LD_VAR 0 2
70071: ARRAY
70072: PUSH
70073: LD_INT 2
70075: ARRAY
70076: OR
70077: PUSH
70078: LD_EXP 69
70082: PUSH
70083: LD_VAR 0 2
70087: ARRAY
70088: PPUSH
70089: LD_INT 1
70091: PPUSH
70092: CALL_OW 325
70096: NOT
70097: OR
70098: PUSH
70099: LD_EXP 66
70103: PUSH
70104: LD_VAR 0 2
70108: ARRAY
70109: OR
70110: IFFALSE 70114
// continue ;
70112: GO 70031
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70114: LD_ADDR_VAR 0 8
70118: PUSH
70119: LD_EXP 43
70123: PUSH
70124: LD_VAR 0 2
70128: ARRAY
70129: PPUSH
70130: LD_INT 25
70132: PUSH
70133: LD_INT 4
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 50
70142: PUSH
70143: EMPTY
70144: LIST
70145: PUSH
70146: LD_INT 3
70148: PUSH
70149: LD_INT 60
70151: PUSH
70152: EMPTY
70153: LIST
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: LIST
70163: PPUSH
70164: CALL_OW 72
70168: PUSH
70169: LD_EXP 47
70173: PUSH
70174: LD_VAR 0 2
70178: ARRAY
70179: DIFF
70180: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70181: LD_ADDR_VAR 0 9
70185: PUSH
70186: LD_EXP 43
70190: PUSH
70191: LD_VAR 0 2
70195: ARRAY
70196: PPUSH
70197: LD_INT 2
70199: PUSH
70200: LD_INT 30
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 30
70212: PUSH
70213: LD_INT 1
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: LIST
70224: PPUSH
70225: CALL_OW 72
70229: ST_TO_ADDR
// if not tmp or not dep then
70230: LD_VAR 0 8
70234: NOT
70235: PUSH
70236: LD_VAR 0 9
70240: NOT
70241: OR
70242: IFFALSE 70246
// continue ;
70244: GO 70031
// side := GetSide ( tmp [ 1 ] ) ;
70246: LD_ADDR_VAR 0 11
70250: PUSH
70251: LD_VAR 0 8
70255: PUSH
70256: LD_INT 1
70258: ARRAY
70259: PPUSH
70260: CALL_OW 255
70264: ST_TO_ADDR
// dep := dep [ 1 ] ;
70265: LD_ADDR_VAR 0 9
70269: PUSH
70270: LD_VAR 0 9
70274: PUSH
70275: LD_INT 1
70277: ARRAY
70278: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70279: LD_ADDR_VAR 0 7
70283: PUSH
70284: LD_EXP 71
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: PPUSH
70295: LD_INT 22
70297: PUSH
70298: LD_INT 0
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 25
70307: PUSH
70308: LD_INT 12
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PPUSH
70319: CALL_OW 70
70323: PUSH
70324: LD_INT 22
70326: PUSH
70327: LD_INT 0
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 25
70336: PUSH
70337: LD_INT 12
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 91
70346: PUSH
70347: LD_VAR 0 9
70351: PUSH
70352: LD_INT 20
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: LIST
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: LIST
70364: PPUSH
70365: CALL_OW 69
70369: UNION
70370: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70371: LD_ADDR_VAR 0 10
70375: PUSH
70376: LD_EXP 71
70380: PUSH
70381: LD_VAR 0 2
70385: ARRAY
70386: PPUSH
70387: LD_INT 81
70389: PUSH
70390: LD_VAR 0 11
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PPUSH
70399: CALL_OW 70
70403: ST_TO_ADDR
// if not apes or danger_at_area then
70404: LD_VAR 0 7
70408: NOT
70409: PUSH
70410: LD_VAR 0 10
70414: OR
70415: IFFALSE 70465
// begin if mc_taming [ i ] then
70417: LD_EXP 74
70421: PUSH
70422: LD_VAR 0 2
70426: ARRAY
70427: IFFALSE 70463
// begin MC_Reset ( i , 121 ) ;
70429: LD_VAR 0 2
70433: PPUSH
70434: LD_INT 121
70436: PPUSH
70437: CALL 55402 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70441: LD_ADDR_EXP 74
70445: PUSH
70446: LD_EXP 74
70450: PPUSH
70451: LD_VAR 0 2
70455: PPUSH
70456: EMPTY
70457: PPUSH
70458: CALL_OW 1
70462: ST_TO_ADDR
// end ; continue ;
70463: GO 70031
// end ; for j in tmp do
70465: LD_ADDR_VAR 0 3
70469: PUSH
70470: LD_VAR 0 8
70474: PUSH
70475: FOR_IN
70476: IFFALSE 70812
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70478: LD_VAR 0 3
70482: PUSH
70483: LD_EXP 74
70487: PUSH
70488: LD_VAR 0 2
70492: ARRAY
70493: IN
70494: NOT
70495: PUSH
70496: LD_EXP 74
70500: PUSH
70501: LD_VAR 0 2
70505: ARRAY
70506: PUSH
70507: LD_INT 3
70509: LESS
70510: AND
70511: IFFALSE 70569
// begin SetTag ( j , 121 ) ;
70513: LD_VAR 0 3
70517: PPUSH
70518: LD_INT 121
70520: PPUSH
70521: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70525: LD_ADDR_EXP 74
70529: PUSH
70530: LD_EXP 74
70534: PPUSH
70535: LD_VAR 0 2
70539: PUSH
70540: LD_EXP 74
70544: PUSH
70545: LD_VAR 0 2
70549: ARRAY
70550: PUSH
70551: LD_INT 1
70553: PLUS
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PPUSH
70559: LD_VAR 0 3
70563: PPUSH
70564: CALL 14949 0 3
70568: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70569: LD_VAR 0 3
70573: PUSH
70574: LD_EXP 74
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: IN
70585: IFFALSE 70810
// begin if GetClass ( j ) <> 4 then
70587: LD_VAR 0 3
70591: PPUSH
70592: CALL_OW 257
70596: PUSH
70597: LD_INT 4
70599: NONEQUAL
70600: IFFALSE 70653
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70602: LD_ADDR_EXP 74
70606: PUSH
70607: LD_EXP 74
70611: PPUSH
70612: LD_VAR 0 2
70616: PPUSH
70617: LD_EXP 74
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PUSH
70628: LD_VAR 0 3
70632: DIFF
70633: PPUSH
70634: CALL_OW 1
70638: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70639: LD_VAR 0 3
70643: PPUSH
70644: LD_INT 0
70646: PPUSH
70647: CALL_OW 109
// continue ;
70651: GO 70475
// end ; if IsInUnit ( j ) then
70653: LD_VAR 0 3
70657: PPUSH
70658: CALL_OW 310
70662: IFFALSE 70673
// ComExitBuilding ( j ) ;
70664: LD_VAR 0 3
70668: PPUSH
70669: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70673: LD_ADDR_VAR 0 6
70677: PUSH
70678: LD_VAR 0 7
70682: PPUSH
70683: LD_VAR 0 3
70687: PPUSH
70688: CALL_OW 74
70692: ST_TO_ADDR
// if not ape then
70693: LD_VAR 0 6
70697: NOT
70698: IFFALSE 70702
// break ;
70700: GO 70812
// x := GetX ( ape ) ;
70702: LD_ADDR_VAR 0 4
70706: PUSH
70707: LD_VAR 0 6
70711: PPUSH
70712: CALL_OW 250
70716: ST_TO_ADDR
// y := GetY ( ape ) ;
70717: LD_ADDR_VAR 0 5
70721: PUSH
70722: LD_VAR 0 6
70726: PPUSH
70727: CALL_OW 251
70731: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70732: LD_VAR 0 4
70736: PPUSH
70737: LD_VAR 0 5
70741: PPUSH
70742: CALL_OW 488
70746: NOT
70747: PUSH
70748: LD_VAR 0 11
70752: PPUSH
70753: LD_VAR 0 4
70757: PPUSH
70758: LD_VAR 0 5
70762: PPUSH
70763: LD_INT 20
70765: PPUSH
70766: CALL 15845 0 4
70770: PUSH
70771: LD_INT 4
70773: ARRAY
70774: OR
70775: IFFALSE 70779
// break ;
70777: GO 70812
// if not HasTask ( j ) then
70779: LD_VAR 0 3
70783: PPUSH
70784: CALL_OW 314
70788: NOT
70789: IFFALSE 70810
// ComTameXY ( j , x , y ) ;
70791: LD_VAR 0 3
70795: PPUSH
70796: LD_VAR 0 4
70800: PPUSH
70801: LD_VAR 0 5
70805: PPUSH
70806: CALL_OW 131
// end ; end ;
70810: GO 70475
70812: POP
70813: POP
// end ;
70814: GO 70031
70816: POP
70817: POP
// end ;
70818: LD_VAR 0 1
70822: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70823: LD_INT 0
70825: PPUSH
70826: PPUSH
70827: PPUSH
70828: PPUSH
70829: PPUSH
70830: PPUSH
70831: PPUSH
70832: PPUSH
// if not mc_bases then
70833: LD_EXP 43
70837: NOT
70838: IFFALSE 70842
// exit ;
70840: GO 71468
// for i = 1 to mc_bases do
70842: LD_ADDR_VAR 0 2
70846: PUSH
70847: DOUBLE
70848: LD_INT 1
70850: DEC
70851: ST_TO_ADDR
70852: LD_EXP 43
70856: PUSH
70857: FOR_TO
70858: IFFALSE 71466
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70860: LD_EXP 72
70864: PUSH
70865: LD_VAR 0 2
70869: ARRAY
70870: NOT
70871: PUSH
70872: LD_EXP 72
70876: PUSH
70877: LD_VAR 0 2
70881: ARRAY
70882: PPUSH
70883: LD_INT 25
70885: PUSH
70886: LD_INT 12
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PPUSH
70893: CALL_OW 72
70897: NOT
70898: OR
70899: IFFALSE 70903
// continue ;
70901: GO 70857
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70903: LD_ADDR_VAR 0 5
70907: PUSH
70908: LD_EXP 72
70912: PUSH
70913: LD_VAR 0 2
70917: ARRAY
70918: PUSH
70919: LD_INT 1
70921: ARRAY
70922: PPUSH
70923: CALL_OW 255
70927: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70928: LD_VAR 0 5
70932: PPUSH
70933: LD_INT 2
70935: PPUSH
70936: CALL_OW 325
70940: IFFALSE 71193
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70942: LD_ADDR_VAR 0 4
70946: PUSH
70947: LD_EXP 72
70951: PUSH
70952: LD_VAR 0 2
70956: ARRAY
70957: PPUSH
70958: LD_INT 25
70960: PUSH
70961: LD_INT 16
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PPUSH
70968: CALL_OW 72
70972: ST_TO_ADDR
// if tmp < 6 then
70973: LD_VAR 0 4
70977: PUSH
70978: LD_INT 6
70980: LESS
70981: IFFALSE 71193
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70983: LD_ADDR_VAR 0 6
70987: PUSH
70988: LD_EXP 43
70992: PUSH
70993: LD_VAR 0 2
70997: ARRAY
70998: PPUSH
70999: LD_INT 2
71001: PUSH
71002: LD_INT 30
71004: PUSH
71005: LD_INT 0
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 30
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: LIST
71026: PPUSH
71027: CALL_OW 72
71031: ST_TO_ADDR
// if depot then
71032: LD_VAR 0 6
71036: IFFALSE 71193
// begin selected := 0 ;
71038: LD_ADDR_VAR 0 7
71042: PUSH
71043: LD_INT 0
71045: ST_TO_ADDR
// for j in depot do
71046: LD_ADDR_VAR 0 3
71050: PUSH
71051: LD_VAR 0 6
71055: PUSH
71056: FOR_IN
71057: IFFALSE 71088
// begin if UnitsInside ( j ) < 6 then
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL_OW 313
71068: PUSH
71069: LD_INT 6
71071: LESS
71072: IFFALSE 71086
// begin selected := j ;
71074: LD_ADDR_VAR 0 7
71078: PUSH
71079: LD_VAR 0 3
71083: ST_TO_ADDR
// break ;
71084: GO 71088
// end ; end ;
71086: GO 71056
71088: POP
71089: POP
// if selected then
71090: LD_VAR 0 7
71094: IFFALSE 71193
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71096: LD_ADDR_VAR 0 3
71100: PUSH
71101: LD_EXP 72
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: PPUSH
71112: LD_INT 25
71114: PUSH
71115: LD_INT 12
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PPUSH
71122: CALL_OW 72
71126: PUSH
71127: FOR_IN
71128: IFFALSE 71191
// if not HasTask ( j ) then
71130: LD_VAR 0 3
71134: PPUSH
71135: CALL_OW 314
71139: NOT
71140: IFFALSE 71189
// begin if not IsInUnit ( j ) then
71142: LD_VAR 0 3
71146: PPUSH
71147: CALL_OW 310
71151: NOT
71152: IFFALSE 71168
// ComEnterUnit ( j , selected ) ;
71154: LD_VAR 0 3
71158: PPUSH
71159: LD_VAR 0 7
71163: PPUSH
71164: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71168: LD_VAR 0 3
71172: PPUSH
71173: LD_INT 16
71175: PPUSH
71176: CALL_OW 183
// AddComExitBuilding ( j ) ;
71180: LD_VAR 0 3
71184: PPUSH
71185: CALL_OW 182
// end ;
71189: GO 71127
71191: POP
71192: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71193: LD_VAR 0 5
71197: PPUSH
71198: LD_INT 11
71200: PPUSH
71201: CALL_OW 325
71205: IFFALSE 71464
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71207: LD_ADDR_VAR 0 4
71211: PUSH
71212: LD_EXP 72
71216: PUSH
71217: LD_VAR 0 2
71221: ARRAY
71222: PPUSH
71223: LD_INT 25
71225: PUSH
71226: LD_INT 16
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PPUSH
71233: CALL_OW 72
71237: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71238: LD_VAR 0 4
71242: PUSH
71243: LD_INT 6
71245: GREATEREQUAL
71246: PUSH
71247: LD_VAR 0 5
71251: PPUSH
71252: LD_INT 2
71254: PPUSH
71255: CALL_OW 325
71259: NOT
71260: OR
71261: IFFALSE 71464
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71263: LD_ADDR_VAR 0 8
71267: PUSH
71268: LD_EXP 43
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PPUSH
71279: LD_INT 2
71281: PUSH
71282: LD_INT 30
71284: PUSH
71285: LD_INT 4
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 30
71294: PUSH
71295: LD_INT 5
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: LIST
71306: PPUSH
71307: CALL_OW 72
71311: ST_TO_ADDR
// if barracks then
71312: LD_VAR 0 8
71316: IFFALSE 71464
// begin selected := 0 ;
71318: LD_ADDR_VAR 0 7
71322: PUSH
71323: LD_INT 0
71325: ST_TO_ADDR
// for j in barracks do
71326: LD_ADDR_VAR 0 3
71330: PUSH
71331: LD_VAR 0 8
71335: PUSH
71336: FOR_IN
71337: IFFALSE 71368
// begin if UnitsInside ( j ) < 6 then
71339: LD_VAR 0 3
71343: PPUSH
71344: CALL_OW 313
71348: PUSH
71349: LD_INT 6
71351: LESS
71352: IFFALSE 71366
// begin selected := j ;
71354: LD_ADDR_VAR 0 7
71358: PUSH
71359: LD_VAR 0 3
71363: ST_TO_ADDR
// break ;
71364: GO 71368
// end ; end ;
71366: GO 71336
71368: POP
71369: POP
// if selected then
71370: LD_VAR 0 7
71374: IFFALSE 71464
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71376: LD_ADDR_VAR 0 3
71380: PUSH
71381: LD_EXP 72
71385: PUSH
71386: LD_VAR 0 2
71390: ARRAY
71391: PPUSH
71392: LD_INT 25
71394: PUSH
71395: LD_INT 12
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PPUSH
71402: CALL_OW 72
71406: PUSH
71407: FOR_IN
71408: IFFALSE 71462
// if not IsInUnit ( j ) and not HasTask ( j ) then
71410: LD_VAR 0 3
71414: PPUSH
71415: CALL_OW 310
71419: NOT
71420: PUSH
71421: LD_VAR 0 3
71425: PPUSH
71426: CALL_OW 314
71430: NOT
71431: AND
71432: IFFALSE 71460
// begin ComEnterUnit ( j , selected ) ;
71434: LD_VAR 0 3
71438: PPUSH
71439: LD_VAR 0 7
71443: PPUSH
71444: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71448: LD_VAR 0 3
71452: PPUSH
71453: LD_INT 15
71455: PPUSH
71456: CALL_OW 183
// end ;
71460: GO 71407
71462: POP
71463: POP
// end ; end ; end ; end ; end ;
71464: GO 70857
71466: POP
71467: POP
// end ;
71468: LD_VAR 0 1
71472: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71473: LD_INT 0
71475: PPUSH
71476: PPUSH
71477: PPUSH
71478: PPUSH
// if not mc_bases then
71479: LD_EXP 43
71483: NOT
71484: IFFALSE 71488
// exit ;
71486: GO 71666
// for i = 1 to mc_bases do
71488: LD_ADDR_VAR 0 2
71492: PUSH
71493: DOUBLE
71494: LD_INT 1
71496: DEC
71497: ST_TO_ADDR
71498: LD_EXP 43
71502: PUSH
71503: FOR_TO
71504: IFFALSE 71664
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71506: LD_ADDR_VAR 0 4
71510: PUSH
71511: LD_EXP 43
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PPUSH
71522: LD_INT 25
71524: PUSH
71525: LD_INT 9
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PPUSH
71532: CALL_OW 72
71536: ST_TO_ADDR
// if not tmp then
71537: LD_VAR 0 4
71541: NOT
71542: IFFALSE 71546
// continue ;
71544: GO 71503
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71546: LD_EXP 69
71550: PUSH
71551: LD_VAR 0 2
71555: ARRAY
71556: PPUSH
71557: LD_INT 29
71559: PPUSH
71560: CALL_OW 325
71564: NOT
71565: PUSH
71566: LD_EXP 69
71570: PUSH
71571: LD_VAR 0 2
71575: ARRAY
71576: PPUSH
71577: LD_INT 28
71579: PPUSH
71580: CALL_OW 325
71584: NOT
71585: AND
71586: IFFALSE 71590
// continue ;
71588: GO 71503
// for j in tmp do
71590: LD_ADDR_VAR 0 3
71594: PUSH
71595: LD_VAR 0 4
71599: PUSH
71600: FOR_IN
71601: IFFALSE 71660
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71603: LD_VAR 0 3
71607: PUSH
71608: LD_EXP 46
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: PUSH
71619: LD_INT 1
71621: ARRAY
71622: IN
71623: NOT
71624: PUSH
71625: LD_VAR 0 3
71629: PUSH
71630: LD_EXP 46
71634: PUSH
71635: LD_VAR 0 2
71639: ARRAY
71640: PUSH
71641: LD_INT 2
71643: ARRAY
71644: IN
71645: NOT
71646: AND
71647: IFFALSE 71658
// ComSpaceTimeShoot ( j ) ;
71649: LD_VAR 0 3
71653: PPUSH
71654: CALL 10759 0 1
71658: GO 71600
71660: POP
71661: POP
// end ;
71662: GO 71503
71664: POP
71665: POP
// end ;
71666: LD_VAR 0 1
71670: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71671: LD_INT 0
71673: PPUSH
71674: PPUSH
71675: PPUSH
71676: PPUSH
71677: PPUSH
71678: PPUSH
71679: PPUSH
71680: PPUSH
71681: PPUSH
// if not mc_bases then
71682: LD_EXP 43
71686: NOT
71687: IFFALSE 71691
// exit ;
71689: GO 72313
// for i = 1 to mc_bases do
71691: LD_ADDR_VAR 0 2
71695: PUSH
71696: DOUBLE
71697: LD_INT 1
71699: DEC
71700: ST_TO_ADDR
71701: LD_EXP 43
71705: PUSH
71706: FOR_TO
71707: IFFALSE 72311
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71709: LD_EXP 78
71713: PUSH
71714: LD_VAR 0 2
71718: ARRAY
71719: NOT
71720: PUSH
71721: LD_INT 38
71723: PPUSH
71724: LD_EXP 69
71728: PUSH
71729: LD_VAR 0 2
71733: ARRAY
71734: PPUSH
71735: CALL_OW 321
71739: PUSH
71740: LD_INT 2
71742: NONEQUAL
71743: OR
71744: IFFALSE 71748
// continue ;
71746: GO 71706
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71748: LD_ADDR_VAR 0 8
71752: PUSH
71753: LD_EXP 43
71757: PUSH
71758: LD_VAR 0 2
71762: ARRAY
71763: PPUSH
71764: LD_INT 30
71766: PUSH
71767: LD_INT 34
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PPUSH
71774: CALL_OW 72
71778: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71779: LD_ADDR_VAR 0 9
71783: PUSH
71784: LD_EXP 43
71788: PUSH
71789: LD_VAR 0 2
71793: ARRAY
71794: PPUSH
71795: LD_INT 25
71797: PUSH
71798: LD_INT 4
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PPUSH
71805: CALL_OW 72
71809: PPUSH
71810: LD_INT 0
71812: PPUSH
71813: CALL 44861 0 2
71817: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71818: LD_VAR 0 9
71822: NOT
71823: PUSH
71824: LD_VAR 0 8
71828: NOT
71829: OR
71830: PUSH
71831: LD_EXP 43
71835: PUSH
71836: LD_VAR 0 2
71840: ARRAY
71841: PPUSH
71842: LD_INT 124
71844: PPUSH
71845: CALL 44861 0 2
71849: OR
71850: IFFALSE 71854
// continue ;
71852: GO 71706
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71854: LD_EXP 79
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: PUSH
71865: LD_EXP 78
71869: PUSH
71870: LD_VAR 0 2
71874: ARRAY
71875: LESS
71876: PUSH
71877: LD_EXP 79
71881: PUSH
71882: LD_VAR 0 2
71886: ARRAY
71887: PUSH
71888: LD_VAR 0 8
71892: LESS
71893: AND
71894: IFFALSE 72309
// begin tmp := sci [ 1 ] ;
71896: LD_ADDR_VAR 0 7
71900: PUSH
71901: LD_VAR 0 9
71905: PUSH
71906: LD_INT 1
71908: ARRAY
71909: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71910: LD_VAR 0 7
71914: PPUSH
71915: LD_INT 124
71917: PPUSH
71918: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71922: LD_ADDR_VAR 0 3
71926: PUSH
71927: DOUBLE
71928: LD_EXP 78
71932: PUSH
71933: LD_VAR 0 2
71937: ARRAY
71938: INC
71939: ST_TO_ADDR
71940: LD_EXP 78
71944: PUSH
71945: LD_VAR 0 2
71949: ARRAY
71950: PUSH
71951: FOR_DOWNTO
71952: IFFALSE 72295
// begin if IsInUnit ( tmp ) then
71954: LD_VAR 0 7
71958: PPUSH
71959: CALL_OW 310
71963: IFFALSE 71974
// ComExitBuilding ( tmp ) ;
71965: LD_VAR 0 7
71969: PPUSH
71970: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71974: LD_INT 35
71976: PPUSH
71977: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71981: LD_VAR 0 7
71985: PPUSH
71986: CALL_OW 310
71990: NOT
71991: PUSH
71992: LD_VAR 0 7
71996: PPUSH
71997: CALL_OW 314
72001: NOT
72002: AND
72003: IFFALSE 71974
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72005: LD_ADDR_VAR 0 6
72009: PUSH
72010: LD_VAR 0 7
72014: PPUSH
72015: CALL_OW 250
72019: PUSH
72020: LD_VAR 0 7
72024: PPUSH
72025: CALL_OW 251
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72034: LD_INT 35
72036: PPUSH
72037: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72041: LD_ADDR_VAR 0 4
72045: PUSH
72046: LD_EXP 78
72050: PUSH
72051: LD_VAR 0 2
72055: ARRAY
72056: PUSH
72057: LD_VAR 0 3
72061: ARRAY
72062: PUSH
72063: LD_INT 1
72065: ARRAY
72066: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72067: LD_ADDR_VAR 0 5
72071: PUSH
72072: LD_EXP 78
72076: PUSH
72077: LD_VAR 0 2
72081: ARRAY
72082: PUSH
72083: LD_VAR 0 3
72087: ARRAY
72088: PUSH
72089: LD_INT 2
72091: ARRAY
72092: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72093: LD_VAR 0 7
72097: PPUSH
72098: LD_INT 10
72100: PPUSH
72101: CALL 17546 0 2
72105: PUSH
72106: LD_INT 4
72108: ARRAY
72109: IFFALSE 72147
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72111: LD_VAR 0 7
72115: PPUSH
72116: LD_VAR 0 6
72120: PUSH
72121: LD_INT 1
72123: ARRAY
72124: PPUSH
72125: LD_VAR 0 6
72129: PUSH
72130: LD_INT 2
72132: ARRAY
72133: PPUSH
72134: CALL_OW 111
// wait ( 0 0$10 ) ;
72138: LD_INT 350
72140: PPUSH
72141: CALL_OW 67
// end else
72145: GO 72173
// begin ComMoveXY ( tmp , x , y ) ;
72147: LD_VAR 0 7
72151: PPUSH
72152: LD_VAR 0 4
72156: PPUSH
72157: LD_VAR 0 5
72161: PPUSH
72162: CALL_OW 111
// wait ( 0 0$3 ) ;
72166: LD_INT 105
72168: PPUSH
72169: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72173: LD_VAR 0 7
72177: PPUSH
72178: LD_VAR 0 4
72182: PPUSH
72183: LD_VAR 0 5
72187: PPUSH
72188: CALL_OW 307
72192: IFFALSE 72034
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72194: LD_VAR 0 7
72198: PPUSH
72199: LD_VAR 0 4
72203: PPUSH
72204: LD_VAR 0 5
72208: PPUSH
72209: LD_VAR 0 8
72213: PUSH
72214: LD_VAR 0 3
72218: ARRAY
72219: PPUSH
72220: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72224: LD_INT 35
72226: PPUSH
72227: CALL_OW 67
// until not HasTask ( tmp ) ;
72231: LD_VAR 0 7
72235: PPUSH
72236: CALL_OW 314
72240: NOT
72241: IFFALSE 72224
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72243: LD_ADDR_EXP 79
72247: PUSH
72248: LD_EXP 79
72252: PPUSH
72253: LD_VAR 0 2
72257: PUSH
72258: LD_EXP 79
72262: PUSH
72263: LD_VAR 0 2
72267: ARRAY
72268: PUSH
72269: LD_INT 1
72271: PLUS
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PPUSH
72277: LD_VAR 0 8
72281: PUSH
72282: LD_VAR 0 3
72286: ARRAY
72287: PPUSH
72288: CALL 14949 0 3
72292: ST_TO_ADDR
// end ;
72293: GO 71951
72295: POP
72296: POP
// MC_Reset ( i , 124 ) ;
72297: LD_VAR 0 2
72301: PPUSH
72302: LD_INT 124
72304: PPUSH
72305: CALL 55402 0 2
// end ; end ;
72309: GO 71706
72311: POP
72312: POP
// end ;
72313: LD_VAR 0 1
72317: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72318: LD_INT 0
72320: PPUSH
72321: PPUSH
72322: PPUSH
// if not mc_bases then
72323: LD_EXP 43
72327: NOT
72328: IFFALSE 72332
// exit ;
72330: GO 72938
// for i = 1 to mc_bases do
72332: LD_ADDR_VAR 0 2
72336: PUSH
72337: DOUBLE
72338: LD_INT 1
72340: DEC
72341: ST_TO_ADDR
72342: LD_EXP 43
72346: PUSH
72347: FOR_TO
72348: IFFALSE 72936
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72350: LD_ADDR_VAR 0 3
72354: PUSH
72355: LD_EXP 43
72359: PUSH
72360: LD_VAR 0 2
72364: ARRAY
72365: PPUSH
72366: LD_INT 25
72368: PUSH
72369: LD_INT 4
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PPUSH
72376: CALL_OW 72
72380: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72381: LD_VAR 0 3
72385: NOT
72386: PUSH
72387: LD_EXP 80
72391: PUSH
72392: LD_VAR 0 2
72396: ARRAY
72397: NOT
72398: OR
72399: PUSH
72400: LD_EXP 43
72404: PUSH
72405: LD_VAR 0 2
72409: ARRAY
72410: PPUSH
72411: LD_INT 2
72413: PUSH
72414: LD_INT 30
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 30
72426: PUSH
72427: LD_INT 1
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: LIST
72438: PPUSH
72439: CALL_OW 72
72443: NOT
72444: OR
72445: IFFALSE 72495
// begin if mc_deposits_finder [ i ] then
72447: LD_EXP 81
72451: PUSH
72452: LD_VAR 0 2
72456: ARRAY
72457: IFFALSE 72493
// begin MC_Reset ( i , 125 ) ;
72459: LD_VAR 0 2
72463: PPUSH
72464: LD_INT 125
72466: PPUSH
72467: CALL 55402 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72471: LD_ADDR_EXP 81
72475: PUSH
72476: LD_EXP 81
72480: PPUSH
72481: LD_VAR 0 2
72485: PPUSH
72486: EMPTY
72487: PPUSH
72488: CALL_OW 1
72492: ST_TO_ADDR
// end ; continue ;
72493: GO 72347
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72495: LD_EXP 80
72499: PUSH
72500: LD_VAR 0 2
72504: ARRAY
72505: PUSH
72506: LD_INT 1
72508: ARRAY
72509: PUSH
72510: LD_INT 3
72512: ARRAY
72513: PUSH
72514: LD_INT 1
72516: EQUAL
72517: PUSH
72518: LD_INT 20
72520: PPUSH
72521: LD_EXP 69
72525: PUSH
72526: LD_VAR 0 2
72530: ARRAY
72531: PPUSH
72532: CALL_OW 321
72536: PUSH
72537: LD_INT 2
72539: NONEQUAL
72540: AND
72541: IFFALSE 72591
// begin if mc_deposits_finder [ i ] then
72543: LD_EXP 81
72547: PUSH
72548: LD_VAR 0 2
72552: ARRAY
72553: IFFALSE 72589
// begin MC_Reset ( i , 125 ) ;
72555: LD_VAR 0 2
72559: PPUSH
72560: LD_INT 125
72562: PPUSH
72563: CALL 55402 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72567: LD_ADDR_EXP 81
72571: PUSH
72572: LD_EXP 81
72576: PPUSH
72577: LD_VAR 0 2
72581: PPUSH
72582: EMPTY
72583: PPUSH
72584: CALL_OW 1
72588: ST_TO_ADDR
// end ; continue ;
72589: GO 72347
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72591: LD_EXP 80
72595: PUSH
72596: LD_VAR 0 2
72600: ARRAY
72601: PUSH
72602: LD_INT 1
72604: ARRAY
72605: PUSH
72606: LD_INT 1
72608: ARRAY
72609: PPUSH
72610: LD_EXP 80
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: PUSH
72625: LD_INT 2
72627: ARRAY
72628: PPUSH
72629: LD_EXP 69
72633: PUSH
72634: LD_VAR 0 2
72638: ARRAY
72639: PPUSH
72640: CALL_OW 440
72644: IFFALSE 72687
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72646: LD_ADDR_EXP 80
72650: PUSH
72651: LD_EXP 80
72655: PPUSH
72656: LD_VAR 0 2
72660: PPUSH
72661: LD_EXP 80
72665: PUSH
72666: LD_VAR 0 2
72670: ARRAY
72671: PPUSH
72672: LD_INT 1
72674: PPUSH
72675: CALL_OW 3
72679: PPUSH
72680: CALL_OW 1
72684: ST_TO_ADDR
72685: GO 72934
// begin if not mc_deposits_finder [ i ] then
72687: LD_EXP 81
72691: PUSH
72692: LD_VAR 0 2
72696: ARRAY
72697: NOT
72698: IFFALSE 72750
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72700: LD_ADDR_EXP 81
72704: PUSH
72705: LD_EXP 81
72709: PPUSH
72710: LD_VAR 0 2
72714: PPUSH
72715: LD_VAR 0 3
72719: PUSH
72720: LD_INT 1
72722: ARRAY
72723: PUSH
72724: EMPTY
72725: LIST
72726: PPUSH
72727: CALL_OW 1
72731: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72732: LD_VAR 0 3
72736: PUSH
72737: LD_INT 1
72739: ARRAY
72740: PPUSH
72741: LD_INT 125
72743: PPUSH
72744: CALL_OW 109
// end else
72748: GO 72934
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72750: LD_EXP 81
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PUSH
72761: LD_INT 1
72763: ARRAY
72764: PPUSH
72765: CALL_OW 310
72769: IFFALSE 72792
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72771: LD_EXP 81
72775: PUSH
72776: LD_VAR 0 2
72780: ARRAY
72781: PUSH
72782: LD_INT 1
72784: ARRAY
72785: PPUSH
72786: CALL_OW 122
72790: GO 72934
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72792: LD_EXP 81
72796: PUSH
72797: LD_VAR 0 2
72801: ARRAY
72802: PUSH
72803: LD_INT 1
72805: ARRAY
72806: PPUSH
72807: CALL_OW 314
72811: NOT
72812: PUSH
72813: LD_EXP 81
72817: PUSH
72818: LD_VAR 0 2
72822: ARRAY
72823: PUSH
72824: LD_INT 1
72826: ARRAY
72827: PPUSH
72828: LD_EXP 80
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: PUSH
72839: LD_INT 1
72841: ARRAY
72842: PUSH
72843: LD_INT 1
72845: ARRAY
72846: PPUSH
72847: LD_EXP 80
72851: PUSH
72852: LD_VAR 0 2
72856: ARRAY
72857: PUSH
72858: LD_INT 1
72860: ARRAY
72861: PUSH
72862: LD_INT 2
72864: ARRAY
72865: PPUSH
72866: CALL_OW 297
72870: PUSH
72871: LD_INT 6
72873: GREATER
72874: AND
72875: IFFALSE 72934
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72877: LD_EXP 81
72881: PUSH
72882: LD_VAR 0 2
72886: ARRAY
72887: PUSH
72888: LD_INT 1
72890: ARRAY
72891: PPUSH
72892: LD_EXP 80
72896: PUSH
72897: LD_VAR 0 2
72901: ARRAY
72902: PUSH
72903: LD_INT 1
72905: ARRAY
72906: PUSH
72907: LD_INT 1
72909: ARRAY
72910: PPUSH
72911: LD_EXP 80
72915: PUSH
72916: LD_VAR 0 2
72920: ARRAY
72921: PUSH
72922: LD_INT 1
72924: ARRAY
72925: PUSH
72926: LD_INT 2
72928: ARRAY
72929: PPUSH
72930: CALL_OW 111
// end ; end ; end ;
72934: GO 72347
72936: POP
72937: POP
// end ;
72938: LD_VAR 0 1
72942: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72943: LD_INT 0
72945: PPUSH
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
72950: PPUSH
72951: PPUSH
72952: PPUSH
72953: PPUSH
72954: PPUSH
72955: PPUSH
// if not mc_bases then
72956: LD_EXP 43
72960: NOT
72961: IFFALSE 72965
// exit ;
72963: GO 73905
// for i = 1 to mc_bases do
72965: LD_ADDR_VAR 0 2
72969: PUSH
72970: DOUBLE
72971: LD_INT 1
72973: DEC
72974: ST_TO_ADDR
72975: LD_EXP 43
72979: PUSH
72980: FOR_TO
72981: IFFALSE 73903
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72983: LD_EXP 43
72987: PUSH
72988: LD_VAR 0 2
72992: ARRAY
72993: NOT
72994: PUSH
72995: LD_EXP 66
72999: PUSH
73000: LD_VAR 0 2
73004: ARRAY
73005: OR
73006: IFFALSE 73010
// continue ;
73008: GO 72980
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73010: LD_ADDR_VAR 0 7
73014: PUSH
73015: LD_EXP 43
73019: PUSH
73020: LD_VAR 0 2
73024: ARRAY
73025: PUSH
73026: LD_INT 1
73028: ARRAY
73029: PPUSH
73030: CALL_OW 248
73034: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73035: LD_VAR 0 7
73039: PUSH
73040: LD_INT 3
73042: EQUAL
73043: PUSH
73044: LD_EXP 62
73048: PUSH
73049: LD_VAR 0 2
73053: ARRAY
73054: PUSH
73055: LD_EXP 65
73059: PUSH
73060: LD_VAR 0 2
73064: ARRAY
73065: UNION
73066: PPUSH
73067: LD_INT 33
73069: PUSH
73070: LD_INT 2
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PPUSH
73077: CALL_OW 72
73081: NOT
73082: OR
73083: IFFALSE 73087
// continue ;
73085: GO 72980
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73087: LD_ADDR_VAR 0 9
73091: PUSH
73092: LD_EXP 43
73096: PUSH
73097: LD_VAR 0 2
73101: ARRAY
73102: PPUSH
73103: LD_INT 30
73105: PUSH
73106: LD_INT 36
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PPUSH
73113: CALL_OW 72
73117: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73118: LD_ADDR_VAR 0 10
73122: PUSH
73123: LD_EXP 62
73127: PUSH
73128: LD_VAR 0 2
73132: ARRAY
73133: PPUSH
73134: LD_INT 34
73136: PUSH
73137: LD_INT 31
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PPUSH
73144: CALL_OW 72
73148: ST_TO_ADDR
// if not cts and not mcts then
73149: LD_VAR 0 9
73153: NOT
73154: PUSH
73155: LD_VAR 0 10
73159: NOT
73160: AND
73161: IFFALSE 73165
// continue ;
73163: GO 72980
// x := cts ;
73165: LD_ADDR_VAR 0 11
73169: PUSH
73170: LD_VAR 0 9
73174: ST_TO_ADDR
// if not x then
73175: LD_VAR 0 11
73179: NOT
73180: IFFALSE 73192
// x := mcts ;
73182: LD_ADDR_VAR 0 11
73186: PUSH
73187: LD_VAR 0 10
73191: ST_TO_ADDR
// if not x then
73192: LD_VAR 0 11
73196: NOT
73197: IFFALSE 73201
// continue ;
73199: GO 72980
// if mc_remote_driver [ i ] then
73201: LD_EXP 83
73205: PUSH
73206: LD_VAR 0 2
73210: ARRAY
73211: IFFALSE 73598
// for j in mc_remote_driver [ i ] do
73213: LD_ADDR_VAR 0 3
73217: PUSH
73218: LD_EXP 83
73222: PUSH
73223: LD_VAR 0 2
73227: ARRAY
73228: PUSH
73229: FOR_IN
73230: IFFALSE 73596
// begin if GetClass ( j ) <> 3 then
73232: LD_VAR 0 3
73236: PPUSH
73237: CALL_OW 257
73241: PUSH
73242: LD_INT 3
73244: NONEQUAL
73245: IFFALSE 73298
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73247: LD_ADDR_EXP 83
73251: PUSH
73252: LD_EXP 83
73256: PPUSH
73257: LD_VAR 0 2
73261: PPUSH
73262: LD_EXP 83
73266: PUSH
73267: LD_VAR 0 2
73271: ARRAY
73272: PUSH
73273: LD_VAR 0 3
73277: DIFF
73278: PPUSH
73279: CALL_OW 1
73283: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73284: LD_VAR 0 3
73288: PPUSH
73289: LD_INT 0
73291: PPUSH
73292: CALL_OW 109
// continue ;
73296: GO 73229
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73298: LD_EXP 62
73302: PUSH
73303: LD_VAR 0 2
73307: ARRAY
73308: PPUSH
73309: LD_INT 34
73311: PUSH
73312: LD_INT 31
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 58
73321: PUSH
73322: EMPTY
73323: LIST
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PPUSH
73329: CALL_OW 72
73333: PUSH
73334: LD_VAR 0 3
73338: PPUSH
73339: CALL 44896 0 1
73343: NOT
73344: AND
73345: IFFALSE 73416
// begin if IsInUnit ( j ) then
73347: LD_VAR 0 3
73351: PPUSH
73352: CALL_OW 310
73356: IFFALSE 73367
// ComExitBuilding ( j ) ;
73358: LD_VAR 0 3
73362: PPUSH
73363: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73367: LD_VAR 0 3
73371: PPUSH
73372: LD_EXP 62
73376: PUSH
73377: LD_VAR 0 2
73381: ARRAY
73382: PPUSH
73383: LD_INT 34
73385: PUSH
73386: LD_INT 31
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 58
73395: PUSH
73396: EMPTY
73397: LIST
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PPUSH
73403: CALL_OW 72
73407: PUSH
73408: LD_INT 1
73410: ARRAY
73411: PPUSH
73412: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73416: LD_VAR 0 3
73420: PPUSH
73421: CALL_OW 310
73425: NOT
73426: PUSH
73427: LD_VAR 0 3
73431: PPUSH
73432: CALL_OW 310
73436: PPUSH
73437: CALL_OW 266
73441: PUSH
73442: LD_INT 36
73444: NONEQUAL
73445: PUSH
73446: LD_VAR 0 3
73450: PPUSH
73451: CALL 44896 0 1
73455: NOT
73456: AND
73457: OR
73458: IFFALSE 73594
// begin if IsInUnit ( j ) then
73460: LD_VAR 0 3
73464: PPUSH
73465: CALL_OW 310
73469: IFFALSE 73480
// ComExitBuilding ( j ) ;
73471: LD_VAR 0 3
73475: PPUSH
73476: CALL_OW 122
// ct := 0 ;
73480: LD_ADDR_VAR 0 8
73484: PUSH
73485: LD_INT 0
73487: ST_TO_ADDR
// for k in x do
73488: LD_ADDR_VAR 0 4
73492: PUSH
73493: LD_VAR 0 11
73497: PUSH
73498: FOR_IN
73499: IFFALSE 73572
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73501: LD_VAR 0 4
73505: PPUSH
73506: CALL_OW 264
73510: PUSH
73511: LD_INT 31
73513: EQUAL
73514: PUSH
73515: LD_VAR 0 4
73519: PPUSH
73520: CALL_OW 311
73524: NOT
73525: AND
73526: PUSH
73527: LD_VAR 0 4
73531: PPUSH
73532: CALL_OW 266
73536: PUSH
73537: LD_INT 36
73539: EQUAL
73540: PUSH
73541: LD_VAR 0 4
73545: PPUSH
73546: CALL_OW 313
73550: PUSH
73551: LD_INT 3
73553: LESS
73554: AND
73555: OR
73556: IFFALSE 73570
// begin ct := k ;
73558: LD_ADDR_VAR 0 8
73562: PUSH
73563: LD_VAR 0 4
73567: ST_TO_ADDR
// break ;
73568: GO 73572
// end ;
73570: GO 73498
73572: POP
73573: POP
// if ct then
73574: LD_VAR 0 8
73578: IFFALSE 73594
// ComEnterUnit ( j , ct ) ;
73580: LD_VAR 0 3
73584: PPUSH
73585: LD_VAR 0 8
73589: PPUSH
73590: CALL_OW 120
// end ; end ;
73594: GO 73229
73596: POP
73597: POP
// places := 0 ;
73598: LD_ADDR_VAR 0 5
73602: PUSH
73603: LD_INT 0
73605: ST_TO_ADDR
// for j = 1 to x do
73606: LD_ADDR_VAR 0 3
73610: PUSH
73611: DOUBLE
73612: LD_INT 1
73614: DEC
73615: ST_TO_ADDR
73616: LD_VAR 0 11
73620: PUSH
73621: FOR_TO
73622: IFFALSE 73698
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73624: LD_VAR 0 11
73628: PUSH
73629: LD_VAR 0 3
73633: ARRAY
73634: PPUSH
73635: CALL_OW 264
73639: PUSH
73640: LD_INT 31
73642: EQUAL
73643: IFFALSE 73661
// places := places + 1 else
73645: LD_ADDR_VAR 0 5
73649: PUSH
73650: LD_VAR 0 5
73654: PUSH
73655: LD_INT 1
73657: PLUS
73658: ST_TO_ADDR
73659: GO 73696
// if GetBType ( x [ j ] ) = b_control_tower then
73661: LD_VAR 0 11
73665: PUSH
73666: LD_VAR 0 3
73670: ARRAY
73671: PPUSH
73672: CALL_OW 266
73676: PUSH
73677: LD_INT 36
73679: EQUAL
73680: IFFALSE 73696
// places := places + 3 ;
73682: LD_ADDR_VAR 0 5
73686: PUSH
73687: LD_VAR 0 5
73691: PUSH
73692: LD_INT 3
73694: PLUS
73695: ST_TO_ADDR
73696: GO 73621
73698: POP
73699: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73700: LD_VAR 0 5
73704: PUSH
73705: LD_INT 0
73707: EQUAL
73708: PUSH
73709: LD_VAR 0 5
73713: PUSH
73714: LD_EXP 83
73718: PUSH
73719: LD_VAR 0 2
73723: ARRAY
73724: LESSEQUAL
73725: OR
73726: IFFALSE 73730
// continue ;
73728: GO 72980
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73730: LD_ADDR_VAR 0 6
73734: PUSH
73735: LD_EXP 43
73739: PUSH
73740: LD_VAR 0 2
73744: ARRAY
73745: PPUSH
73746: LD_INT 25
73748: PUSH
73749: LD_INT 3
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PPUSH
73756: CALL_OW 72
73760: PUSH
73761: LD_EXP 83
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: DIFF
73772: PPUSH
73773: LD_INT 3
73775: PPUSH
73776: CALL 45796 0 2
73780: ST_TO_ADDR
// for j in tmp do
73781: LD_ADDR_VAR 0 3
73785: PUSH
73786: LD_VAR 0 6
73790: PUSH
73791: FOR_IN
73792: IFFALSE 73827
// if GetTag ( j ) > 0 then
73794: LD_VAR 0 3
73798: PPUSH
73799: CALL_OW 110
73803: PUSH
73804: LD_INT 0
73806: GREATER
73807: IFFALSE 73825
// tmp := tmp diff j ;
73809: LD_ADDR_VAR 0 6
73813: PUSH
73814: LD_VAR 0 6
73818: PUSH
73819: LD_VAR 0 3
73823: DIFF
73824: ST_TO_ADDR
73825: GO 73791
73827: POP
73828: POP
// if not tmp then
73829: LD_VAR 0 6
73833: NOT
73834: IFFALSE 73838
// continue ;
73836: GO 72980
// if places then
73838: LD_VAR 0 5
73842: IFFALSE 73901
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73844: LD_ADDR_EXP 83
73848: PUSH
73849: LD_EXP 83
73853: PPUSH
73854: LD_VAR 0 2
73858: PPUSH
73859: LD_EXP 83
73863: PUSH
73864: LD_VAR 0 2
73868: ARRAY
73869: PUSH
73870: LD_VAR 0 6
73874: PUSH
73875: LD_INT 1
73877: ARRAY
73878: UNION
73879: PPUSH
73880: CALL_OW 1
73884: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73885: LD_VAR 0 6
73889: PUSH
73890: LD_INT 1
73892: ARRAY
73893: PPUSH
73894: LD_INT 126
73896: PPUSH
73897: CALL_OW 109
// end ; end ;
73901: GO 72980
73903: POP
73904: POP
// end ;
73905: LD_VAR 0 1
73909: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73910: LD_INT 0
73912: PPUSH
73913: PPUSH
73914: PPUSH
73915: PPUSH
73916: PPUSH
73917: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73918: LD_VAR 0 1
73922: NOT
73923: PUSH
73924: LD_VAR 0 2
73928: NOT
73929: OR
73930: PUSH
73931: LD_VAR 0 3
73935: NOT
73936: OR
73937: PUSH
73938: LD_VAR 0 4
73942: PUSH
73943: LD_INT 1
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: LD_INT 3
73951: PUSH
73952: LD_INT 4
73954: PUSH
73955: LD_INT 5
73957: PUSH
73958: LD_INT 8
73960: PUSH
73961: LD_INT 9
73963: PUSH
73964: LD_INT 15
73966: PUSH
73967: LD_INT 16
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: IN
73981: NOT
73982: OR
73983: IFFALSE 73987
// exit ;
73985: GO 74887
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73987: LD_ADDR_VAR 0 2
73991: PUSH
73992: LD_VAR 0 2
73996: PPUSH
73997: LD_INT 21
73999: PUSH
74000: LD_INT 3
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 24
74009: PUSH
74010: LD_INT 250
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PPUSH
74021: CALL_OW 72
74025: ST_TO_ADDR
// case class of 1 , 15 :
74026: LD_VAR 0 4
74030: PUSH
74031: LD_INT 1
74033: DOUBLE
74034: EQUAL
74035: IFTRUE 74045
74037: LD_INT 15
74039: DOUBLE
74040: EQUAL
74041: IFTRUE 74045
74043: GO 74130
74045: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74046: LD_ADDR_VAR 0 8
74050: PUSH
74051: LD_VAR 0 2
74055: PPUSH
74056: LD_INT 2
74058: PUSH
74059: LD_INT 30
74061: PUSH
74062: LD_INT 32
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 30
74071: PUSH
74072: LD_INT 31
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: LIST
74083: PPUSH
74084: CALL_OW 72
74088: PUSH
74089: LD_VAR 0 2
74093: PPUSH
74094: LD_INT 2
74096: PUSH
74097: LD_INT 30
74099: PUSH
74100: LD_INT 4
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 30
74109: PUSH
74110: LD_INT 5
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: LIST
74121: PPUSH
74122: CALL_OW 72
74126: ADD
74127: ST_TO_ADDR
74128: GO 74376
74130: LD_INT 2
74132: DOUBLE
74133: EQUAL
74134: IFTRUE 74144
74136: LD_INT 16
74138: DOUBLE
74139: EQUAL
74140: IFTRUE 74144
74142: GO 74190
74144: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74145: LD_ADDR_VAR 0 8
74149: PUSH
74150: LD_VAR 0 2
74154: PPUSH
74155: LD_INT 2
74157: PUSH
74158: LD_INT 30
74160: PUSH
74161: LD_INT 0
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 30
74170: PUSH
74171: LD_INT 1
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: LIST
74182: PPUSH
74183: CALL_OW 72
74187: ST_TO_ADDR
74188: GO 74376
74190: LD_INT 3
74192: DOUBLE
74193: EQUAL
74194: IFTRUE 74198
74196: GO 74244
74198: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74199: LD_ADDR_VAR 0 8
74203: PUSH
74204: LD_VAR 0 2
74208: PPUSH
74209: LD_INT 2
74211: PUSH
74212: LD_INT 30
74214: PUSH
74215: LD_INT 2
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 30
74224: PUSH
74225: LD_INT 3
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: LIST
74236: PPUSH
74237: CALL_OW 72
74241: ST_TO_ADDR
74242: GO 74376
74244: LD_INT 4
74246: DOUBLE
74247: EQUAL
74248: IFTRUE 74252
74250: GO 74309
74252: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74253: LD_ADDR_VAR 0 8
74257: PUSH
74258: LD_VAR 0 2
74262: PPUSH
74263: LD_INT 2
74265: PUSH
74266: LD_INT 30
74268: PUSH
74269: LD_INT 6
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 30
74278: PUSH
74279: LD_INT 7
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 30
74288: PUSH
74289: LD_INT 8
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: PPUSH
74302: CALL_OW 72
74306: ST_TO_ADDR
74307: GO 74376
74309: LD_INT 5
74311: DOUBLE
74312: EQUAL
74313: IFTRUE 74329
74315: LD_INT 8
74317: DOUBLE
74318: EQUAL
74319: IFTRUE 74329
74321: LD_INT 9
74323: DOUBLE
74324: EQUAL
74325: IFTRUE 74329
74327: GO 74375
74329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74330: LD_ADDR_VAR 0 8
74334: PUSH
74335: LD_VAR 0 2
74339: PPUSH
74340: LD_INT 2
74342: PUSH
74343: LD_INT 30
74345: PUSH
74346: LD_INT 4
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 30
74355: PUSH
74356: LD_INT 5
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: LIST
74367: PPUSH
74368: CALL_OW 72
74372: ST_TO_ADDR
74373: GO 74376
74375: POP
// if not tmp then
74376: LD_VAR 0 8
74380: NOT
74381: IFFALSE 74385
// exit ;
74383: GO 74887
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74385: LD_VAR 0 4
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 15
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: IN
74400: PUSH
74401: LD_EXP 52
74405: PUSH
74406: LD_VAR 0 1
74410: ARRAY
74411: AND
74412: IFFALSE 74568
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74414: LD_ADDR_VAR 0 9
74418: PUSH
74419: LD_EXP 52
74423: PUSH
74424: LD_VAR 0 1
74428: ARRAY
74429: PUSH
74430: LD_INT 1
74432: ARRAY
74433: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74434: LD_VAR 0 9
74438: PUSH
74439: LD_EXP 53
74443: PUSH
74444: LD_VAR 0 1
74448: ARRAY
74449: IN
74450: NOT
74451: IFFALSE 74566
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74453: LD_ADDR_EXP 53
74457: PUSH
74458: LD_EXP 53
74462: PPUSH
74463: LD_VAR 0 1
74467: PUSH
74468: LD_EXP 53
74472: PUSH
74473: LD_VAR 0 1
74477: ARRAY
74478: PUSH
74479: LD_INT 1
74481: PLUS
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PPUSH
74487: LD_VAR 0 9
74491: PPUSH
74492: CALL 14949 0 3
74496: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74497: LD_ADDR_EXP 52
74501: PUSH
74502: LD_EXP 52
74506: PPUSH
74507: LD_VAR 0 1
74511: PPUSH
74512: LD_EXP 52
74516: PUSH
74517: LD_VAR 0 1
74521: ARRAY
74522: PUSH
74523: LD_VAR 0 9
74527: DIFF
74528: PPUSH
74529: CALL_OW 1
74533: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74534: LD_VAR 0 3
74538: PPUSH
74539: LD_EXP 53
74543: PUSH
74544: LD_VAR 0 1
74548: ARRAY
74549: PUSH
74550: LD_EXP 53
74554: PUSH
74555: LD_VAR 0 1
74559: ARRAY
74560: ARRAY
74561: PPUSH
74562: CALL_OW 120
// end ; exit ;
74566: GO 74887
// end ; if tmp > 1 then
74568: LD_VAR 0 8
74572: PUSH
74573: LD_INT 1
74575: GREATER
74576: IFFALSE 74680
// for i = 2 to tmp do
74578: LD_ADDR_VAR 0 6
74582: PUSH
74583: DOUBLE
74584: LD_INT 2
74586: DEC
74587: ST_TO_ADDR
74588: LD_VAR 0 8
74592: PUSH
74593: FOR_TO
74594: IFFALSE 74678
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74596: LD_VAR 0 8
74600: PUSH
74601: LD_VAR 0 6
74605: ARRAY
74606: PPUSH
74607: CALL_OW 461
74611: PUSH
74612: LD_INT 6
74614: EQUAL
74615: IFFALSE 74676
// begin x := tmp [ i ] ;
74617: LD_ADDR_VAR 0 9
74621: PUSH
74622: LD_VAR 0 8
74626: PUSH
74627: LD_VAR 0 6
74631: ARRAY
74632: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74633: LD_ADDR_VAR 0 8
74637: PUSH
74638: LD_VAR 0 8
74642: PPUSH
74643: LD_VAR 0 6
74647: PPUSH
74648: CALL_OW 3
74652: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74653: LD_ADDR_VAR 0 8
74657: PUSH
74658: LD_VAR 0 8
74662: PPUSH
74663: LD_INT 1
74665: PPUSH
74666: LD_VAR 0 9
74670: PPUSH
74671: CALL_OW 2
74675: ST_TO_ADDR
// end ;
74676: GO 74593
74678: POP
74679: POP
// for i in tmp do
74680: LD_ADDR_VAR 0 6
74684: PUSH
74685: LD_VAR 0 8
74689: PUSH
74690: FOR_IN
74691: IFFALSE 74760
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74693: LD_VAR 0 6
74697: PPUSH
74698: CALL_OW 313
74702: PUSH
74703: LD_INT 6
74705: LESS
74706: PUSH
74707: LD_VAR 0 6
74711: PPUSH
74712: CALL_OW 266
74716: PUSH
74717: LD_INT 31
74719: PUSH
74720: LD_INT 32
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: IN
74727: NOT
74728: AND
74729: PUSH
74730: LD_VAR 0 6
74734: PPUSH
74735: CALL_OW 313
74739: PUSH
74740: LD_INT 0
74742: EQUAL
74743: OR
74744: IFFALSE 74758
// begin j := i ;
74746: LD_ADDR_VAR 0 7
74750: PUSH
74751: LD_VAR 0 6
74755: ST_TO_ADDR
// break ;
74756: GO 74760
// end ; end ;
74758: GO 74690
74760: POP
74761: POP
// if j then
74762: LD_VAR 0 7
74766: IFFALSE 74784
// ComEnterUnit ( unit , j ) else
74768: LD_VAR 0 3
74772: PPUSH
74773: LD_VAR 0 7
74777: PPUSH
74778: CALL_OW 120
74782: GO 74887
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74784: LD_ADDR_VAR 0 10
74788: PUSH
74789: LD_VAR 0 2
74793: PPUSH
74794: LD_INT 2
74796: PUSH
74797: LD_INT 30
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 30
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: LIST
74821: PPUSH
74822: CALL_OW 72
74826: ST_TO_ADDR
// if depot then
74827: LD_VAR 0 10
74831: IFFALSE 74887
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74833: LD_ADDR_VAR 0 10
74837: PUSH
74838: LD_VAR 0 10
74842: PPUSH
74843: LD_VAR 0 3
74847: PPUSH
74848: CALL_OW 74
74852: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74853: LD_VAR 0 3
74857: PPUSH
74858: LD_VAR 0 10
74862: PPUSH
74863: CALL_OW 296
74867: PUSH
74868: LD_INT 10
74870: GREATER
74871: IFFALSE 74887
// ComStandNearbyBuilding ( unit , depot ) ;
74873: LD_VAR 0 3
74877: PPUSH
74878: LD_VAR 0 10
74882: PPUSH
74883: CALL 11376 0 2
// end ; end ; end ;
74887: LD_VAR 0 5
74891: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74892: LD_INT 0
74894: PPUSH
74895: PPUSH
74896: PPUSH
74897: PPUSH
// if not mc_bases then
74898: LD_EXP 43
74902: NOT
74903: IFFALSE 74907
// exit ;
74905: GO 75146
// for i = 1 to mc_bases do
74907: LD_ADDR_VAR 0 2
74911: PUSH
74912: DOUBLE
74913: LD_INT 1
74915: DEC
74916: ST_TO_ADDR
74917: LD_EXP 43
74921: PUSH
74922: FOR_TO
74923: IFFALSE 75144
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74925: LD_ADDR_VAR 0 4
74929: PUSH
74930: LD_EXP 43
74934: PUSH
74935: LD_VAR 0 2
74939: ARRAY
74940: PPUSH
74941: LD_INT 21
74943: PUSH
74944: LD_INT 1
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PPUSH
74951: CALL_OW 72
74955: PUSH
74956: LD_EXP 72
74960: PUSH
74961: LD_VAR 0 2
74965: ARRAY
74966: UNION
74967: ST_TO_ADDR
// if not tmp then
74968: LD_VAR 0 4
74972: NOT
74973: IFFALSE 74977
// continue ;
74975: GO 74922
// for j in tmp do
74977: LD_ADDR_VAR 0 3
74981: PUSH
74982: LD_VAR 0 4
74986: PUSH
74987: FOR_IN
74988: IFFALSE 75140
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74990: LD_VAR 0 3
74994: PPUSH
74995: CALL_OW 110
74999: NOT
75000: PUSH
75001: LD_VAR 0 3
75005: PPUSH
75006: CALL_OW 314
75010: NOT
75011: AND
75012: PUSH
75013: LD_VAR 0 3
75017: PPUSH
75018: CALL_OW 311
75022: NOT
75023: AND
75024: PUSH
75025: LD_VAR 0 3
75029: PPUSH
75030: CALL_OW 310
75034: NOT
75035: AND
75036: PUSH
75037: LD_VAR 0 3
75041: PUSH
75042: LD_EXP 46
75046: PUSH
75047: LD_VAR 0 2
75051: ARRAY
75052: PUSH
75053: LD_INT 1
75055: ARRAY
75056: IN
75057: NOT
75058: AND
75059: PUSH
75060: LD_VAR 0 3
75064: PUSH
75065: LD_EXP 46
75069: PUSH
75070: LD_VAR 0 2
75074: ARRAY
75075: PUSH
75076: LD_INT 2
75078: ARRAY
75079: IN
75080: NOT
75081: AND
75082: PUSH
75083: LD_VAR 0 3
75087: PUSH
75088: LD_EXP 55
75092: PUSH
75093: LD_VAR 0 2
75097: ARRAY
75098: IN
75099: NOT
75100: AND
75101: IFFALSE 75138
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75103: LD_VAR 0 2
75107: PPUSH
75108: LD_EXP 43
75112: PUSH
75113: LD_VAR 0 2
75117: ARRAY
75118: PPUSH
75119: LD_VAR 0 3
75123: PPUSH
75124: LD_VAR 0 3
75128: PPUSH
75129: CALL_OW 257
75133: PPUSH
75134: CALL 73910 0 4
// end ;
75138: GO 74987
75140: POP
75141: POP
// end ;
75142: GO 74922
75144: POP
75145: POP
// end ;
75146: LD_VAR 0 1
75150: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75151: LD_INT 0
75153: PPUSH
75154: PPUSH
75155: PPUSH
75156: PPUSH
75157: PPUSH
75158: PPUSH
// if not mc_bases [ base ] then
75159: LD_EXP 43
75163: PUSH
75164: LD_VAR 0 1
75168: ARRAY
75169: NOT
75170: IFFALSE 75174
// exit ;
75172: GO 75356
// tmp := [ ] ;
75174: LD_ADDR_VAR 0 6
75178: PUSH
75179: EMPTY
75180: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75181: LD_ADDR_VAR 0 7
75185: PUSH
75186: LD_VAR 0 3
75190: PPUSH
75191: LD_INT 0
75193: PPUSH
75194: CALL_OW 517
75198: ST_TO_ADDR
// if not list then
75199: LD_VAR 0 7
75203: NOT
75204: IFFALSE 75208
// exit ;
75206: GO 75356
// for i = 1 to amount do
75208: LD_ADDR_VAR 0 5
75212: PUSH
75213: DOUBLE
75214: LD_INT 1
75216: DEC
75217: ST_TO_ADDR
75218: LD_VAR 0 2
75222: PUSH
75223: FOR_TO
75224: IFFALSE 75304
// begin x := rand ( 1 , list [ 1 ] ) ;
75226: LD_ADDR_VAR 0 8
75230: PUSH
75231: LD_INT 1
75233: PPUSH
75234: LD_VAR 0 7
75238: PUSH
75239: LD_INT 1
75241: ARRAY
75242: PPUSH
75243: CALL_OW 12
75247: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75248: LD_ADDR_VAR 0 6
75252: PUSH
75253: LD_VAR 0 6
75257: PPUSH
75258: LD_VAR 0 5
75262: PPUSH
75263: LD_VAR 0 7
75267: PUSH
75268: LD_INT 1
75270: ARRAY
75271: PUSH
75272: LD_VAR 0 8
75276: ARRAY
75277: PUSH
75278: LD_VAR 0 7
75282: PUSH
75283: LD_INT 2
75285: ARRAY
75286: PUSH
75287: LD_VAR 0 8
75291: ARRAY
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PPUSH
75297: CALL_OW 1
75301: ST_TO_ADDR
// end ;
75302: GO 75223
75304: POP
75305: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75306: LD_ADDR_EXP 56
75310: PUSH
75311: LD_EXP 56
75315: PPUSH
75316: LD_VAR 0 1
75320: PPUSH
75321: LD_VAR 0 6
75325: PPUSH
75326: CALL_OW 1
75330: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75331: LD_ADDR_EXP 58
75335: PUSH
75336: LD_EXP 58
75340: PPUSH
75341: LD_VAR 0 1
75345: PPUSH
75346: LD_VAR 0 3
75350: PPUSH
75351: CALL_OW 1
75355: ST_TO_ADDR
// end ;
75356: LD_VAR 0 4
75360: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75361: LD_INT 0
75363: PPUSH
// if not mc_bases [ base ] then
75364: LD_EXP 43
75368: PUSH
75369: LD_VAR 0 1
75373: ARRAY
75374: NOT
75375: IFFALSE 75379
// exit ;
75377: GO 75404
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75379: LD_ADDR_EXP 48
75383: PUSH
75384: LD_EXP 48
75388: PPUSH
75389: LD_VAR 0 1
75393: PPUSH
75394: LD_VAR 0 2
75398: PPUSH
75399: CALL_OW 1
75403: ST_TO_ADDR
// end ;
75404: LD_VAR 0 3
75408: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75409: LD_INT 0
75411: PPUSH
// if not mc_bases [ base ] then
75412: LD_EXP 43
75416: PUSH
75417: LD_VAR 0 1
75421: ARRAY
75422: NOT
75423: IFFALSE 75427
// exit ;
75425: GO 75464
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75427: LD_ADDR_EXP 48
75431: PUSH
75432: LD_EXP 48
75436: PPUSH
75437: LD_VAR 0 1
75441: PPUSH
75442: LD_EXP 48
75446: PUSH
75447: LD_VAR 0 1
75451: ARRAY
75452: PUSH
75453: LD_VAR 0 2
75457: UNION
75458: PPUSH
75459: CALL_OW 1
75463: ST_TO_ADDR
// end ;
75464: LD_VAR 0 3
75468: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75469: LD_INT 0
75471: PPUSH
// if not mc_bases [ base ] then
75472: LD_EXP 43
75476: PUSH
75477: LD_VAR 0 1
75481: ARRAY
75482: NOT
75483: IFFALSE 75487
// exit ;
75485: GO 75512
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75487: LD_ADDR_EXP 64
75491: PUSH
75492: LD_EXP 64
75496: PPUSH
75497: LD_VAR 0 1
75501: PPUSH
75502: LD_VAR 0 2
75506: PPUSH
75507: CALL_OW 1
75511: ST_TO_ADDR
// end ;
75512: LD_VAR 0 3
75516: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75517: LD_INT 0
75519: PPUSH
// if not mc_bases [ base ] then
75520: LD_EXP 43
75524: PUSH
75525: LD_VAR 0 1
75529: ARRAY
75530: NOT
75531: IFFALSE 75535
// exit ;
75533: GO 75572
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75535: LD_ADDR_EXP 64
75539: PUSH
75540: LD_EXP 64
75544: PPUSH
75545: LD_VAR 0 1
75549: PPUSH
75550: LD_EXP 64
75554: PUSH
75555: LD_VAR 0 1
75559: ARRAY
75560: PUSH
75561: LD_VAR 0 2
75565: ADD
75566: PPUSH
75567: CALL_OW 1
75571: ST_TO_ADDR
// end ;
75572: LD_VAR 0 3
75576: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75577: LD_INT 0
75579: PPUSH
// if not mc_bases [ base ] then
75580: LD_EXP 43
75584: PUSH
75585: LD_VAR 0 1
75589: ARRAY
75590: NOT
75591: IFFALSE 75595
// exit ;
75593: GO 75649
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75595: LD_ADDR_EXP 65
75599: PUSH
75600: LD_EXP 65
75604: PPUSH
75605: LD_VAR 0 1
75609: PPUSH
75610: LD_VAR 0 2
75614: PPUSH
75615: CALL_OW 1
75619: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75620: LD_ADDR_EXP 54
75624: PUSH
75625: LD_EXP 54
75629: PPUSH
75630: LD_VAR 0 1
75634: PPUSH
75635: LD_VAR 0 2
75639: PUSH
75640: LD_INT 0
75642: PLUS
75643: PPUSH
75644: CALL_OW 1
75648: ST_TO_ADDR
// end ;
75649: LD_VAR 0 3
75653: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75654: LD_INT 0
75656: PPUSH
// if not mc_bases [ base ] then
75657: LD_EXP 43
75661: PUSH
75662: LD_VAR 0 1
75666: ARRAY
75667: NOT
75668: IFFALSE 75672
// exit ;
75670: GO 75697
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75672: LD_ADDR_EXP 54
75676: PUSH
75677: LD_EXP 54
75681: PPUSH
75682: LD_VAR 0 1
75686: PPUSH
75687: LD_VAR 0 2
75691: PPUSH
75692: CALL_OW 1
75696: ST_TO_ADDR
// end ;
75697: LD_VAR 0 3
75701: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75702: LD_INT 0
75704: PPUSH
75705: PPUSH
75706: PPUSH
75707: PPUSH
// if not mc_bases [ base ] then
75708: LD_EXP 43
75712: PUSH
75713: LD_VAR 0 1
75717: ARRAY
75718: NOT
75719: IFFALSE 75723
// exit ;
75721: GO 75788
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75723: LD_ADDR_EXP 63
75727: PUSH
75728: LD_EXP 63
75732: PPUSH
75733: LD_VAR 0 1
75737: PUSH
75738: LD_EXP 63
75742: PUSH
75743: LD_VAR 0 1
75747: ARRAY
75748: PUSH
75749: LD_INT 1
75751: PLUS
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PPUSH
75757: LD_VAR 0 1
75761: PUSH
75762: LD_VAR 0 2
75766: PUSH
75767: LD_VAR 0 3
75771: PUSH
75772: LD_VAR 0 4
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: LIST
75781: LIST
75782: PPUSH
75783: CALL 14949 0 3
75787: ST_TO_ADDR
// end ;
75788: LD_VAR 0 5
75792: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75793: LD_INT 0
75795: PPUSH
// if not mc_bases [ base ] then
75796: LD_EXP 43
75800: PUSH
75801: LD_VAR 0 1
75805: ARRAY
75806: NOT
75807: IFFALSE 75811
// exit ;
75809: GO 75836
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75811: LD_ADDR_EXP 80
75815: PUSH
75816: LD_EXP 80
75820: PPUSH
75821: LD_VAR 0 1
75825: PPUSH
75826: LD_VAR 0 2
75830: PPUSH
75831: CALL_OW 1
75835: ST_TO_ADDR
// end ;
75836: LD_VAR 0 3
75840: RET
// export function MC_GetMinesField ( base ) ; begin
75841: LD_INT 0
75843: PPUSH
// result := mc_mines [ base ] ;
75844: LD_ADDR_VAR 0 2
75848: PUSH
75849: LD_EXP 56
75853: PUSH
75854: LD_VAR 0 1
75858: ARRAY
75859: ST_TO_ADDR
// end ;
75860: LD_VAR 0 2
75864: RET
// export function MC_GetProduceList ( base ) ; begin
75865: LD_INT 0
75867: PPUSH
// result := mc_produce [ base ] ;
75868: LD_ADDR_VAR 0 2
75872: PUSH
75873: LD_EXP 64
75877: PUSH
75878: LD_VAR 0 1
75882: ARRAY
75883: ST_TO_ADDR
// end ;
75884: LD_VAR 0 2
75888: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75889: LD_INT 0
75891: PPUSH
75892: PPUSH
// if not mc_bases then
75893: LD_EXP 43
75897: NOT
75898: IFFALSE 75902
// exit ;
75900: GO 75967
// if mc_bases [ base ] then
75902: LD_EXP 43
75906: PUSH
75907: LD_VAR 0 1
75911: ARRAY
75912: IFFALSE 75967
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75914: LD_ADDR_VAR 0 3
75918: PUSH
75919: LD_EXP 43
75923: PUSH
75924: LD_VAR 0 1
75928: ARRAY
75929: PPUSH
75930: LD_INT 30
75932: PUSH
75933: LD_VAR 0 2
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PPUSH
75942: CALL_OW 72
75946: ST_TO_ADDR
// if result then
75947: LD_VAR 0 3
75951: IFFALSE 75967
// result := result [ 1 ] ;
75953: LD_ADDR_VAR 0 3
75957: PUSH
75958: LD_VAR 0 3
75962: PUSH
75963: LD_INT 1
75965: ARRAY
75966: ST_TO_ADDR
// end ; end ;
75967: LD_VAR 0 3
75971: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75972: LD_INT 0
75974: PPUSH
75975: PPUSH
// if not mc_bases then
75976: LD_EXP 43
75980: NOT
75981: IFFALSE 75985
// exit ;
75983: GO 76030
// if mc_bases [ base ] then
75985: LD_EXP 43
75989: PUSH
75990: LD_VAR 0 1
75994: ARRAY
75995: IFFALSE 76030
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75997: LD_ADDR_VAR 0 3
76001: PUSH
76002: LD_EXP 43
76006: PUSH
76007: LD_VAR 0 1
76011: ARRAY
76012: PPUSH
76013: LD_INT 30
76015: PUSH
76016: LD_VAR 0 2
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PPUSH
76025: CALL_OW 72
76029: ST_TO_ADDR
// end ;
76030: LD_VAR 0 3
76034: RET
// export function MC_SetTame ( base , area ) ; begin
76035: LD_INT 0
76037: PPUSH
// if not mc_bases or not base then
76038: LD_EXP 43
76042: NOT
76043: PUSH
76044: LD_VAR 0 1
76048: NOT
76049: OR
76050: IFFALSE 76054
// exit ;
76052: GO 76079
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76054: LD_ADDR_EXP 71
76058: PUSH
76059: LD_EXP 71
76063: PPUSH
76064: LD_VAR 0 1
76068: PPUSH
76069: LD_VAR 0 2
76073: PPUSH
76074: CALL_OW 1
76078: ST_TO_ADDR
// end ;
76079: LD_VAR 0 3
76083: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76084: LD_INT 0
76086: PPUSH
76087: PPUSH
// if not mc_bases or not base then
76088: LD_EXP 43
76092: NOT
76093: PUSH
76094: LD_VAR 0 1
76098: NOT
76099: OR
76100: IFFALSE 76104
// exit ;
76102: GO 76206
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76104: LD_ADDR_VAR 0 4
76108: PUSH
76109: LD_EXP 43
76113: PUSH
76114: LD_VAR 0 1
76118: ARRAY
76119: PPUSH
76120: LD_INT 30
76122: PUSH
76123: LD_VAR 0 2
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PPUSH
76132: CALL_OW 72
76136: ST_TO_ADDR
// if not tmp then
76137: LD_VAR 0 4
76141: NOT
76142: IFFALSE 76146
// exit ;
76144: GO 76206
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76146: LD_ADDR_EXP 75
76150: PUSH
76151: LD_EXP 75
76155: PPUSH
76156: LD_VAR 0 1
76160: PPUSH
76161: LD_EXP 75
76165: PUSH
76166: LD_VAR 0 1
76170: ARRAY
76171: PPUSH
76172: LD_EXP 75
76176: PUSH
76177: LD_VAR 0 1
76181: ARRAY
76182: PUSH
76183: LD_INT 1
76185: PLUS
76186: PPUSH
76187: LD_VAR 0 4
76191: PUSH
76192: LD_INT 1
76194: ARRAY
76195: PPUSH
76196: CALL_OW 2
76200: PPUSH
76201: CALL_OW 1
76205: ST_TO_ADDR
// end ;
76206: LD_VAR 0 3
76210: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76211: LD_INT 0
76213: PPUSH
76214: PPUSH
// if not mc_bases or not base or not kinds then
76215: LD_EXP 43
76219: NOT
76220: PUSH
76221: LD_VAR 0 1
76225: NOT
76226: OR
76227: PUSH
76228: LD_VAR 0 2
76232: NOT
76233: OR
76234: IFFALSE 76238
// exit ;
76236: GO 76299
// for i in kinds do
76238: LD_ADDR_VAR 0 4
76242: PUSH
76243: LD_VAR 0 2
76247: PUSH
76248: FOR_IN
76249: IFFALSE 76297
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76251: LD_ADDR_EXP 77
76255: PUSH
76256: LD_EXP 77
76260: PPUSH
76261: LD_VAR 0 1
76265: PUSH
76266: LD_EXP 77
76270: PUSH
76271: LD_VAR 0 1
76275: ARRAY
76276: PUSH
76277: LD_INT 1
76279: PLUS
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PPUSH
76285: LD_VAR 0 4
76289: PPUSH
76290: CALL 14949 0 3
76294: ST_TO_ADDR
76295: GO 76248
76297: POP
76298: POP
// end ;
76299: LD_VAR 0 3
76303: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76304: LD_INT 0
76306: PPUSH
// if not mc_bases or not base or not areas then
76307: LD_EXP 43
76311: NOT
76312: PUSH
76313: LD_VAR 0 1
76317: NOT
76318: OR
76319: PUSH
76320: LD_VAR 0 2
76324: NOT
76325: OR
76326: IFFALSE 76330
// exit ;
76328: GO 76355
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76330: LD_ADDR_EXP 61
76334: PUSH
76335: LD_EXP 61
76339: PPUSH
76340: LD_VAR 0 1
76344: PPUSH
76345: LD_VAR 0 2
76349: PPUSH
76350: CALL_OW 1
76354: ST_TO_ADDR
// end ;
76355: LD_VAR 0 3
76359: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76360: LD_INT 0
76362: PPUSH
// if not mc_bases or not base or not teleports_exit then
76363: LD_EXP 43
76367: NOT
76368: PUSH
76369: LD_VAR 0 1
76373: NOT
76374: OR
76375: PUSH
76376: LD_VAR 0 2
76380: NOT
76381: OR
76382: IFFALSE 76386
// exit ;
76384: GO 76411
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76386: LD_ADDR_EXP 78
76390: PUSH
76391: LD_EXP 78
76395: PPUSH
76396: LD_VAR 0 1
76400: PPUSH
76401: LD_VAR 0 2
76405: PPUSH
76406: CALL_OW 1
76410: ST_TO_ADDR
// end ;
76411: LD_VAR 0 3
76415: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76416: LD_INT 0
76418: PPUSH
76419: PPUSH
76420: PPUSH
// if not mc_bases or not base or not ext_list then
76421: LD_EXP 43
76425: NOT
76426: PUSH
76427: LD_VAR 0 1
76431: NOT
76432: OR
76433: PUSH
76434: LD_VAR 0 5
76438: NOT
76439: OR
76440: IFFALSE 76444
// exit ;
76442: GO 76617
// tmp := GetFacExtXYD ( x , y , d ) ;
76444: LD_ADDR_VAR 0 8
76448: PUSH
76449: LD_VAR 0 2
76453: PPUSH
76454: LD_VAR 0 3
76458: PPUSH
76459: LD_VAR 0 4
76463: PPUSH
76464: CALL 44926 0 3
76468: ST_TO_ADDR
// if not tmp then
76469: LD_VAR 0 8
76473: NOT
76474: IFFALSE 76478
// exit ;
76476: GO 76617
// for i in tmp do
76478: LD_ADDR_VAR 0 7
76482: PUSH
76483: LD_VAR 0 8
76487: PUSH
76488: FOR_IN
76489: IFFALSE 76615
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76491: LD_ADDR_EXP 48
76495: PUSH
76496: LD_EXP 48
76500: PPUSH
76501: LD_VAR 0 1
76505: PPUSH
76506: LD_EXP 48
76510: PUSH
76511: LD_VAR 0 1
76515: ARRAY
76516: PPUSH
76517: LD_EXP 48
76521: PUSH
76522: LD_VAR 0 1
76526: ARRAY
76527: PUSH
76528: LD_INT 1
76530: PLUS
76531: PPUSH
76532: LD_VAR 0 5
76536: PUSH
76537: LD_INT 1
76539: ARRAY
76540: PUSH
76541: LD_VAR 0 7
76545: PUSH
76546: LD_INT 1
76548: ARRAY
76549: PUSH
76550: LD_VAR 0 7
76554: PUSH
76555: LD_INT 2
76557: ARRAY
76558: PUSH
76559: LD_VAR 0 7
76563: PUSH
76564: LD_INT 3
76566: ARRAY
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: PPUSH
76574: CALL_OW 2
76578: PPUSH
76579: CALL_OW 1
76583: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76584: LD_ADDR_VAR 0 5
76588: PUSH
76589: LD_VAR 0 5
76593: PPUSH
76594: LD_INT 1
76596: PPUSH
76597: CALL_OW 3
76601: ST_TO_ADDR
// if not ext_list then
76602: LD_VAR 0 5
76606: NOT
76607: IFFALSE 76613
// exit ;
76609: POP
76610: POP
76611: GO 76617
// end ;
76613: GO 76488
76615: POP
76616: POP
// end ;
76617: LD_VAR 0 6
76621: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76622: LD_INT 0
76624: PPUSH
// if not mc_bases or not base or not weapon_list then
76625: LD_EXP 43
76629: NOT
76630: PUSH
76631: LD_VAR 0 1
76635: NOT
76636: OR
76637: PUSH
76638: LD_VAR 0 2
76642: NOT
76643: OR
76644: IFFALSE 76648
// exit ;
76646: GO 76673
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76648: LD_ADDR_EXP 82
76652: PUSH
76653: LD_EXP 82
76657: PPUSH
76658: LD_VAR 0 1
76662: PPUSH
76663: LD_VAR 0 2
76667: PPUSH
76668: CALL_OW 1
76672: ST_TO_ADDR
// end ;
76673: LD_VAR 0 3
76677: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76678: LD_INT 0
76680: PPUSH
// if not mc_bases or not base or not tech_list then
76681: LD_EXP 43
76685: NOT
76686: PUSH
76687: LD_VAR 0 1
76691: NOT
76692: OR
76693: PUSH
76694: LD_VAR 0 2
76698: NOT
76699: OR
76700: IFFALSE 76704
// exit ;
76702: GO 76729
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76704: LD_ADDR_EXP 70
76708: PUSH
76709: LD_EXP 70
76713: PPUSH
76714: LD_VAR 0 1
76718: PPUSH
76719: LD_VAR 0 2
76723: PPUSH
76724: CALL_OW 1
76728: ST_TO_ADDR
// end ;
76729: LD_VAR 0 3
76733: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76734: LD_INT 0
76736: PPUSH
// if not mc_bases or not parking_area or not base then
76737: LD_EXP 43
76741: NOT
76742: PUSH
76743: LD_VAR 0 2
76747: NOT
76748: OR
76749: PUSH
76750: LD_VAR 0 1
76754: NOT
76755: OR
76756: IFFALSE 76760
// exit ;
76758: GO 76785
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76760: LD_ADDR_EXP 67
76764: PUSH
76765: LD_EXP 67
76769: PPUSH
76770: LD_VAR 0 1
76774: PPUSH
76775: LD_VAR 0 2
76779: PPUSH
76780: CALL_OW 1
76784: ST_TO_ADDR
// end ;
76785: LD_VAR 0 3
76789: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76790: LD_INT 0
76792: PPUSH
// if not mc_bases or not base or not scan_area then
76793: LD_EXP 43
76797: NOT
76798: PUSH
76799: LD_VAR 0 1
76803: NOT
76804: OR
76805: PUSH
76806: LD_VAR 0 2
76810: NOT
76811: OR
76812: IFFALSE 76816
// exit ;
76814: GO 76841
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76816: LD_ADDR_EXP 68
76820: PUSH
76821: LD_EXP 68
76825: PPUSH
76826: LD_VAR 0 1
76830: PPUSH
76831: LD_VAR 0 2
76835: PPUSH
76836: CALL_OW 1
76840: ST_TO_ADDR
// end ;
76841: LD_VAR 0 3
76845: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76846: LD_INT 0
76848: PPUSH
76849: PPUSH
// if not mc_bases or not base then
76850: LD_EXP 43
76854: NOT
76855: PUSH
76856: LD_VAR 0 1
76860: NOT
76861: OR
76862: IFFALSE 76866
// exit ;
76864: GO 76930
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76866: LD_ADDR_VAR 0 3
76870: PUSH
76871: LD_INT 1
76873: PUSH
76874: LD_INT 2
76876: PUSH
76877: LD_INT 3
76879: PUSH
76880: LD_INT 4
76882: PUSH
76883: LD_INT 11
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76893: LD_ADDR_EXP 70
76897: PUSH
76898: LD_EXP 70
76902: PPUSH
76903: LD_VAR 0 1
76907: PPUSH
76908: LD_EXP 70
76912: PUSH
76913: LD_VAR 0 1
76917: ARRAY
76918: PUSH
76919: LD_VAR 0 3
76923: DIFF
76924: PPUSH
76925: CALL_OW 1
76929: ST_TO_ADDR
// end ;
76930: LD_VAR 0 2
76934: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76935: LD_INT 0
76937: PPUSH
// result := mc_vehicles [ base ] ;
76938: LD_ADDR_VAR 0 3
76942: PUSH
76943: LD_EXP 62
76947: PUSH
76948: LD_VAR 0 1
76952: ARRAY
76953: ST_TO_ADDR
// if onlyCombat then
76954: LD_VAR 0 2
76958: IFFALSE 77130
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76960: LD_ADDR_VAR 0 3
76964: PUSH
76965: LD_VAR 0 3
76969: PUSH
76970: LD_VAR 0 3
76974: PPUSH
76975: LD_INT 2
76977: PUSH
76978: LD_INT 34
76980: PUSH
76981: LD_INT 12
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 34
76990: PUSH
76991: LD_INT 51
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: LD_INT 34
77000: PUSH
77001: LD_INT 89
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: PUSH
77008: LD_INT 34
77010: PUSH
77011: LD_INT 32
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 34
77020: PUSH
77021: LD_INT 13
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 34
77030: PUSH
77031: LD_INT 52
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 34
77040: PUSH
77041: LD_INT 88
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 34
77050: PUSH
77051: LD_INT 14
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 34
77060: PUSH
77061: LD_INT 53
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 34
77070: PUSH
77071: LD_INT 98
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 34
77080: PUSH
77081: LD_INT 31
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 34
77090: PUSH
77091: LD_INT 48
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 34
77100: PUSH
77101: LD_INT 8
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: PPUSH
77124: CALL_OW 72
77128: DIFF
77129: ST_TO_ADDR
// end ; end_of_file
77130: LD_VAR 0 3
77134: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77135: LD_INT 0
77137: PPUSH
77138: PPUSH
77139: PPUSH
// if not mc_bases or not skirmish then
77140: LD_EXP 43
77144: NOT
77145: PUSH
77146: LD_EXP 41
77150: NOT
77151: OR
77152: IFFALSE 77156
// exit ;
77154: GO 77321
// for i = 1 to mc_bases do
77156: LD_ADDR_VAR 0 4
77160: PUSH
77161: DOUBLE
77162: LD_INT 1
77164: DEC
77165: ST_TO_ADDR
77166: LD_EXP 43
77170: PUSH
77171: FOR_TO
77172: IFFALSE 77319
// begin if sci in mc_bases [ i ] then
77174: LD_VAR 0 2
77178: PUSH
77179: LD_EXP 43
77183: PUSH
77184: LD_VAR 0 4
77188: ARRAY
77189: IN
77190: IFFALSE 77317
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77192: LD_ADDR_EXP 72
77196: PUSH
77197: LD_EXP 72
77201: PPUSH
77202: LD_VAR 0 4
77206: PUSH
77207: LD_EXP 72
77211: PUSH
77212: LD_VAR 0 4
77216: ARRAY
77217: PUSH
77218: LD_INT 1
77220: PLUS
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PPUSH
77226: LD_VAR 0 1
77230: PPUSH
77231: CALL 14949 0 3
77235: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77236: LD_ADDR_VAR 0 5
77240: PUSH
77241: LD_EXP 43
77245: PUSH
77246: LD_VAR 0 4
77250: ARRAY
77251: PPUSH
77252: LD_INT 2
77254: PUSH
77255: LD_INT 30
77257: PUSH
77258: LD_INT 0
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 30
77267: PUSH
77268: LD_INT 1
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: LIST
77279: PPUSH
77280: CALL_OW 72
77284: PPUSH
77285: LD_VAR 0 1
77289: PPUSH
77290: CALL_OW 74
77294: ST_TO_ADDR
// if tmp then
77295: LD_VAR 0 5
77299: IFFALSE 77315
// ComStandNearbyBuilding ( ape , tmp ) ;
77301: LD_VAR 0 1
77305: PPUSH
77306: LD_VAR 0 5
77310: PPUSH
77311: CALL 11376 0 2
// break ;
77315: GO 77319
// end ; end ;
77317: GO 77171
77319: POP
77320: POP
// end ;
77321: LD_VAR 0 3
77325: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77326: LD_INT 0
77328: PPUSH
77329: PPUSH
77330: PPUSH
// if not mc_bases or not skirmish then
77331: LD_EXP 43
77335: NOT
77336: PUSH
77337: LD_EXP 41
77341: NOT
77342: OR
77343: IFFALSE 77347
// exit ;
77345: GO 77436
// for i = 1 to mc_bases do
77347: LD_ADDR_VAR 0 4
77351: PUSH
77352: DOUBLE
77353: LD_INT 1
77355: DEC
77356: ST_TO_ADDR
77357: LD_EXP 43
77361: PUSH
77362: FOR_TO
77363: IFFALSE 77434
// begin if building in mc_busy_turret_list [ i ] then
77365: LD_VAR 0 1
77369: PUSH
77370: LD_EXP 53
77374: PUSH
77375: LD_VAR 0 4
77379: ARRAY
77380: IN
77381: IFFALSE 77432
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77383: LD_ADDR_VAR 0 5
77387: PUSH
77388: LD_EXP 53
77392: PUSH
77393: LD_VAR 0 4
77397: ARRAY
77398: PUSH
77399: LD_VAR 0 1
77403: DIFF
77404: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77405: LD_ADDR_EXP 53
77409: PUSH
77410: LD_EXP 53
77414: PPUSH
77415: LD_VAR 0 4
77419: PPUSH
77420: LD_VAR 0 5
77424: PPUSH
77425: CALL_OW 1
77429: ST_TO_ADDR
// break ;
77430: GO 77434
// end ; end ;
77432: GO 77362
77434: POP
77435: POP
// end ;
77436: LD_VAR 0 3
77440: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77441: LD_INT 0
77443: PPUSH
77444: PPUSH
77445: PPUSH
// if not mc_bases or not skirmish then
77446: LD_EXP 43
77450: NOT
77451: PUSH
77452: LD_EXP 41
77456: NOT
77457: OR
77458: IFFALSE 77462
// exit ;
77460: GO 77661
// for i = 1 to mc_bases do
77462: LD_ADDR_VAR 0 5
77466: PUSH
77467: DOUBLE
77468: LD_INT 1
77470: DEC
77471: ST_TO_ADDR
77472: LD_EXP 43
77476: PUSH
77477: FOR_TO
77478: IFFALSE 77659
// if building in mc_bases [ i ] then
77480: LD_VAR 0 1
77484: PUSH
77485: LD_EXP 43
77489: PUSH
77490: LD_VAR 0 5
77494: ARRAY
77495: IN
77496: IFFALSE 77657
// begin tmp := mc_bases [ i ] diff building ;
77498: LD_ADDR_VAR 0 6
77502: PUSH
77503: LD_EXP 43
77507: PUSH
77508: LD_VAR 0 5
77512: ARRAY
77513: PUSH
77514: LD_VAR 0 1
77518: DIFF
77519: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77520: LD_ADDR_EXP 43
77524: PUSH
77525: LD_EXP 43
77529: PPUSH
77530: LD_VAR 0 5
77534: PPUSH
77535: LD_VAR 0 6
77539: PPUSH
77540: CALL_OW 1
77544: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77545: LD_VAR 0 1
77549: PUSH
77550: LD_EXP 51
77554: PUSH
77555: LD_VAR 0 5
77559: ARRAY
77560: IN
77561: IFFALSE 77600
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77563: LD_ADDR_EXP 51
77567: PUSH
77568: LD_EXP 51
77572: PPUSH
77573: LD_VAR 0 5
77577: PPUSH
77578: LD_EXP 51
77582: PUSH
77583: LD_VAR 0 5
77587: ARRAY
77588: PUSH
77589: LD_VAR 0 1
77593: DIFF
77594: PPUSH
77595: CALL_OW 1
77599: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77600: LD_VAR 0 1
77604: PUSH
77605: LD_EXP 52
77609: PUSH
77610: LD_VAR 0 5
77614: ARRAY
77615: IN
77616: IFFALSE 77655
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77618: LD_ADDR_EXP 52
77622: PUSH
77623: LD_EXP 52
77627: PPUSH
77628: LD_VAR 0 5
77632: PPUSH
77633: LD_EXP 52
77637: PUSH
77638: LD_VAR 0 5
77642: ARRAY
77643: PUSH
77644: LD_VAR 0 1
77648: DIFF
77649: PPUSH
77650: CALL_OW 1
77654: ST_TO_ADDR
// break ;
77655: GO 77659
// end ;
77657: GO 77477
77659: POP
77660: POP
// end ;
77661: LD_VAR 0 4
77665: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77666: LD_INT 0
77668: PPUSH
77669: PPUSH
77670: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77671: LD_EXP 43
77675: NOT
77676: PUSH
77677: LD_EXP 41
77681: NOT
77682: OR
77683: PUSH
77684: LD_VAR 0 3
77688: PUSH
77689: LD_EXP 69
77693: IN
77694: NOT
77695: OR
77696: IFFALSE 77700
// exit ;
77698: GO 77823
// for i = 1 to mc_vehicles do
77700: LD_ADDR_VAR 0 6
77704: PUSH
77705: DOUBLE
77706: LD_INT 1
77708: DEC
77709: ST_TO_ADDR
77710: LD_EXP 62
77714: PUSH
77715: FOR_TO
77716: IFFALSE 77821
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77718: LD_VAR 0 2
77722: PUSH
77723: LD_EXP 62
77727: PUSH
77728: LD_VAR 0 6
77732: ARRAY
77733: IN
77734: PUSH
77735: LD_VAR 0 1
77739: PUSH
77740: LD_EXP 62
77744: PUSH
77745: LD_VAR 0 6
77749: ARRAY
77750: IN
77751: OR
77752: IFFALSE 77819
// begin tmp := mc_vehicles [ i ] diff old ;
77754: LD_ADDR_VAR 0 7
77758: PUSH
77759: LD_EXP 62
77763: PUSH
77764: LD_VAR 0 6
77768: ARRAY
77769: PUSH
77770: LD_VAR 0 2
77774: DIFF
77775: ST_TO_ADDR
// tmp := tmp diff new ;
77776: LD_ADDR_VAR 0 7
77780: PUSH
77781: LD_VAR 0 7
77785: PUSH
77786: LD_VAR 0 1
77790: DIFF
77791: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77792: LD_ADDR_EXP 62
77796: PUSH
77797: LD_EXP 62
77801: PPUSH
77802: LD_VAR 0 6
77806: PPUSH
77807: LD_VAR 0 7
77811: PPUSH
77812: CALL_OW 1
77816: ST_TO_ADDR
// break ;
77817: GO 77821
// end ;
77819: GO 77715
77821: POP
77822: POP
// end ;
77823: LD_VAR 0 5
77827: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77828: LD_INT 0
77830: PPUSH
77831: PPUSH
77832: PPUSH
77833: PPUSH
// if not mc_bases or not skirmish then
77834: LD_EXP 43
77838: NOT
77839: PUSH
77840: LD_EXP 41
77844: NOT
77845: OR
77846: IFFALSE 77850
// exit ;
77848: GO 78270
// repeat wait ( 0 0$1 ) ;
77850: LD_INT 35
77852: PPUSH
77853: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
77857: LD_EXP 87
77861: NOT
77862: IFFALSE 77850
// mc_block_vehicle_constructed_thread := true ;
77864: LD_ADDR_EXP 87
77868: PUSH
77869: LD_INT 1
77871: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
77872: LD_ADDR_VAR 0 5
77876: PUSH
77877: LD_VAR 0 1
77881: PPUSH
77882: CALL_OW 255
77886: ST_TO_ADDR
// for i = 1 to mc_bases do
77887: LD_ADDR_VAR 0 4
77891: PUSH
77892: DOUBLE
77893: LD_INT 1
77895: DEC
77896: ST_TO_ADDR
77897: LD_EXP 43
77901: PUSH
77902: FOR_TO
77903: IFFALSE 78260
// begin if factory in mc_bases [ i ] then
77905: LD_VAR 0 2
77909: PUSH
77910: LD_EXP 43
77914: PUSH
77915: LD_VAR 0 4
77919: ARRAY
77920: IN
77921: IFFALSE 78258
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77923: LD_EXP 65
77927: PUSH
77928: LD_VAR 0 4
77932: ARRAY
77933: PUSH
77934: LD_EXP 54
77938: PUSH
77939: LD_VAR 0 4
77943: ARRAY
77944: LESS
77945: PUSH
77946: LD_VAR 0 1
77950: PPUSH
77951: CALL_OW 264
77955: PUSH
77956: LD_INT 31
77958: PUSH
77959: LD_INT 32
77961: PUSH
77962: LD_INT 51
77964: PUSH
77965: LD_INT 89
77967: PUSH
77968: LD_INT 12
77970: PUSH
77971: LD_INT 30
77973: PUSH
77974: LD_INT 98
77976: PUSH
77977: LD_INT 11
77979: PUSH
77980: LD_INT 53
77982: PUSH
77983: LD_INT 14
77985: PUSH
77986: LD_INT 91
77988: PUSH
77989: LD_INT 29
77991: PUSH
77992: LD_INT 99
77994: PUSH
77995: LD_INT 13
77997: PUSH
77998: LD_INT 52
78000: PUSH
78001: LD_INT 88
78003: PUSH
78004: LD_INT 48
78006: PUSH
78007: LD_INT 8
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: IN
78030: NOT
78031: AND
78032: IFFALSE 78080
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78034: LD_ADDR_EXP 65
78038: PUSH
78039: LD_EXP 65
78043: PPUSH
78044: LD_VAR 0 4
78048: PUSH
78049: LD_EXP 65
78053: PUSH
78054: LD_VAR 0 4
78058: ARRAY
78059: PUSH
78060: LD_INT 1
78062: PLUS
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PPUSH
78068: LD_VAR 0 1
78072: PPUSH
78073: CALL 14949 0 3
78077: ST_TO_ADDR
78078: GO 78124
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78080: LD_ADDR_EXP 62
78084: PUSH
78085: LD_EXP 62
78089: PPUSH
78090: LD_VAR 0 4
78094: PUSH
78095: LD_EXP 62
78099: PUSH
78100: LD_VAR 0 4
78104: ARRAY
78105: PUSH
78106: LD_INT 1
78108: PLUS
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: PPUSH
78114: LD_VAR 0 1
78118: PPUSH
78119: CALL 14949 0 3
78123: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
78124: LD_ADDR_EXP 87
78128: PUSH
78129: LD_INT 0
78131: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78132: LD_VAR 0 1
78136: PPUSH
78137: CALL_OW 263
78141: PUSH
78142: LD_INT 2
78144: EQUAL
78145: IFFALSE 78174
// begin repeat wait ( 0 0$3 ) ;
78147: LD_INT 105
78149: PPUSH
78150: CALL_OW 67
// Connect ( vehicle ) ;
78154: LD_VAR 0 1
78158: PPUSH
78159: CALL 17918 0 1
// until IsControledBy ( vehicle ) ;
78163: LD_VAR 0 1
78167: PPUSH
78168: CALL_OW 312
78172: IFFALSE 78147
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78174: LD_VAR 0 1
78178: PPUSH
78179: LD_EXP 67
78183: PUSH
78184: LD_VAR 0 4
78188: ARRAY
78189: PPUSH
78190: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78194: LD_VAR 0 1
78198: PPUSH
78199: CALL_OW 263
78203: PUSH
78204: LD_INT 1
78206: NONEQUAL
78207: IFFALSE 78211
// break ;
78209: GO 78260
// repeat wait ( 0 0$1 ) ;
78211: LD_INT 35
78213: PPUSH
78214: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78218: LD_VAR 0 1
78222: PPUSH
78223: LD_EXP 67
78227: PUSH
78228: LD_VAR 0 4
78232: ARRAY
78233: PPUSH
78234: CALL_OW 308
78238: IFFALSE 78211
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78240: LD_VAR 0 1
78244: PPUSH
78245: CALL_OW 311
78249: PPUSH
78250: CALL_OW 121
// exit ;
78254: POP
78255: POP
78256: GO 78270
// end ; end ;
78258: GO 77902
78260: POP
78261: POP
// mc_block_vehicle_constructed_thread := false ;
78262: LD_ADDR_EXP 87
78266: PUSH
78267: LD_INT 0
78269: ST_TO_ADDR
// end ;
78270: LD_VAR 0 3
78274: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78275: LD_INT 0
78277: PPUSH
78278: PPUSH
78279: PPUSH
78280: PPUSH
// if not mc_bases or not skirmish then
78281: LD_EXP 43
78285: NOT
78286: PUSH
78287: LD_EXP 41
78291: NOT
78292: OR
78293: IFFALSE 78297
// exit ;
78295: GO 78650
// repeat wait ( 0 0$1 ) ;
78297: LD_INT 35
78299: PPUSH
78300: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78304: LD_VAR 0 2
78308: PPUSH
78309: LD_VAR 0 3
78313: PPUSH
78314: CALL_OW 284
78318: IFFALSE 78297
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78320: LD_VAR 0 2
78324: PPUSH
78325: LD_VAR 0 3
78329: PPUSH
78330: CALL_OW 283
78334: PUSH
78335: LD_INT 4
78337: EQUAL
78338: IFFALSE 78342
// exit ;
78340: GO 78650
// for i = 1 to mc_bases do
78342: LD_ADDR_VAR 0 7
78346: PUSH
78347: DOUBLE
78348: LD_INT 1
78350: DEC
78351: ST_TO_ADDR
78352: LD_EXP 43
78356: PUSH
78357: FOR_TO
78358: IFFALSE 78648
// begin if mc_crates_area [ i ] then
78360: LD_EXP 61
78364: PUSH
78365: LD_VAR 0 7
78369: ARRAY
78370: IFFALSE 78481
// for j in mc_crates_area [ i ] do
78372: LD_ADDR_VAR 0 8
78376: PUSH
78377: LD_EXP 61
78381: PUSH
78382: LD_VAR 0 7
78386: ARRAY
78387: PUSH
78388: FOR_IN
78389: IFFALSE 78479
// if InArea ( x , y , j ) then
78391: LD_VAR 0 2
78395: PPUSH
78396: LD_VAR 0 3
78400: PPUSH
78401: LD_VAR 0 8
78405: PPUSH
78406: CALL_OW 309
78410: IFFALSE 78477
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78412: LD_ADDR_EXP 59
78416: PUSH
78417: LD_EXP 59
78421: PPUSH
78422: LD_VAR 0 7
78426: PUSH
78427: LD_EXP 59
78431: PUSH
78432: LD_VAR 0 7
78436: ARRAY
78437: PUSH
78438: LD_INT 1
78440: PLUS
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PPUSH
78446: LD_VAR 0 4
78450: PUSH
78451: LD_VAR 0 2
78455: PUSH
78456: LD_VAR 0 3
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: LIST
78465: PPUSH
78466: CALL 14949 0 3
78470: ST_TO_ADDR
// exit ;
78471: POP
78472: POP
78473: POP
78474: POP
78475: GO 78650
// end ;
78477: GO 78388
78479: POP
78480: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78481: LD_ADDR_VAR 0 9
78485: PUSH
78486: LD_EXP 43
78490: PUSH
78491: LD_VAR 0 7
78495: ARRAY
78496: PPUSH
78497: LD_INT 2
78499: PUSH
78500: LD_INT 30
78502: PUSH
78503: LD_INT 0
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 30
78512: PUSH
78513: LD_INT 1
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: LIST
78524: PPUSH
78525: CALL_OW 72
78529: ST_TO_ADDR
// if not depot then
78530: LD_VAR 0 9
78534: NOT
78535: IFFALSE 78539
// continue ;
78537: GO 78357
// for j in depot do
78539: LD_ADDR_VAR 0 8
78543: PUSH
78544: LD_VAR 0 9
78548: PUSH
78549: FOR_IN
78550: IFFALSE 78644
// if GetDistUnitXY ( j , x , y ) < 30 then
78552: LD_VAR 0 8
78556: PPUSH
78557: LD_VAR 0 2
78561: PPUSH
78562: LD_VAR 0 3
78566: PPUSH
78567: CALL_OW 297
78571: PUSH
78572: LD_INT 30
78574: LESS
78575: IFFALSE 78642
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78577: LD_ADDR_EXP 59
78581: PUSH
78582: LD_EXP 59
78586: PPUSH
78587: LD_VAR 0 7
78591: PUSH
78592: LD_EXP 59
78596: PUSH
78597: LD_VAR 0 7
78601: ARRAY
78602: PUSH
78603: LD_INT 1
78605: PLUS
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PPUSH
78611: LD_VAR 0 4
78615: PUSH
78616: LD_VAR 0 2
78620: PUSH
78621: LD_VAR 0 3
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: LIST
78630: PPUSH
78631: CALL 14949 0 3
78635: ST_TO_ADDR
// exit ;
78636: POP
78637: POP
78638: POP
78639: POP
78640: GO 78650
// end ;
78642: GO 78549
78644: POP
78645: POP
// end ;
78646: GO 78357
78648: POP
78649: POP
// end ;
78650: LD_VAR 0 6
78654: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78655: LD_INT 0
78657: PPUSH
78658: PPUSH
78659: PPUSH
78660: PPUSH
// if not mc_bases or not skirmish then
78661: LD_EXP 43
78665: NOT
78666: PUSH
78667: LD_EXP 41
78671: NOT
78672: OR
78673: IFFALSE 78677
// exit ;
78675: GO 78954
// side := GetSide ( lab ) ;
78677: LD_ADDR_VAR 0 4
78681: PUSH
78682: LD_VAR 0 2
78686: PPUSH
78687: CALL_OW 255
78691: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78692: LD_VAR 0 4
78696: PUSH
78697: LD_EXP 69
78701: IN
78702: NOT
78703: PUSH
78704: LD_EXP 70
78708: NOT
78709: OR
78710: PUSH
78711: LD_EXP 43
78715: NOT
78716: OR
78717: IFFALSE 78721
// exit ;
78719: GO 78954
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78721: LD_ADDR_EXP 70
78725: PUSH
78726: LD_EXP 70
78730: PPUSH
78731: LD_VAR 0 4
78735: PPUSH
78736: LD_EXP 70
78740: PUSH
78741: LD_VAR 0 4
78745: ARRAY
78746: PUSH
78747: LD_VAR 0 1
78751: DIFF
78752: PPUSH
78753: CALL_OW 1
78757: ST_TO_ADDR
// for i = 1 to mc_bases do
78758: LD_ADDR_VAR 0 5
78762: PUSH
78763: DOUBLE
78764: LD_INT 1
78766: DEC
78767: ST_TO_ADDR
78768: LD_EXP 43
78772: PUSH
78773: FOR_TO
78774: IFFALSE 78952
// begin if lab in mc_bases [ i ] then
78776: LD_VAR 0 2
78780: PUSH
78781: LD_EXP 43
78785: PUSH
78786: LD_VAR 0 5
78790: ARRAY
78791: IN
78792: IFFALSE 78950
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78794: LD_VAR 0 1
78798: PUSH
78799: LD_INT 11
78801: PUSH
78802: LD_INT 4
78804: PUSH
78805: LD_INT 3
78807: PUSH
78808: LD_INT 2
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: IN
78817: PUSH
78818: LD_EXP 73
78822: PUSH
78823: LD_VAR 0 5
78827: ARRAY
78828: AND
78829: IFFALSE 78950
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78831: LD_ADDR_VAR 0 6
78835: PUSH
78836: LD_EXP 73
78840: PUSH
78841: LD_VAR 0 5
78845: ARRAY
78846: PUSH
78847: LD_INT 1
78849: ARRAY
78850: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78851: LD_ADDR_EXP 73
78855: PUSH
78856: LD_EXP 73
78860: PPUSH
78861: LD_VAR 0 5
78865: PPUSH
78866: EMPTY
78867: PPUSH
78868: CALL_OW 1
78872: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78873: LD_VAR 0 6
78877: PPUSH
78878: LD_INT 0
78880: PPUSH
78881: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78885: LD_VAR 0 6
78889: PPUSH
78890: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78894: LD_ADDR_EXP 72
78898: PUSH
78899: LD_EXP 72
78903: PPUSH
78904: LD_VAR 0 5
78908: PPUSH
78909: LD_EXP 72
78913: PUSH
78914: LD_VAR 0 5
78918: ARRAY
78919: PPUSH
78920: LD_INT 1
78922: PPUSH
78923: LD_VAR 0 6
78927: PPUSH
78928: CALL_OW 2
78932: PPUSH
78933: CALL_OW 1
78937: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78938: LD_VAR 0 5
78942: PPUSH
78943: LD_INT 112
78945: PPUSH
78946: CALL 55402 0 2
// end ; end ; end ;
78950: GO 78773
78952: POP
78953: POP
// end ;
78954: LD_VAR 0 3
78958: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78959: LD_INT 0
78961: PPUSH
78962: PPUSH
78963: PPUSH
78964: PPUSH
78965: PPUSH
78966: PPUSH
78967: PPUSH
78968: PPUSH
// if not mc_bases or not skirmish then
78969: LD_EXP 43
78973: NOT
78974: PUSH
78975: LD_EXP 41
78979: NOT
78980: OR
78981: IFFALSE 78985
// exit ;
78983: GO 80354
// for i = 1 to mc_bases do
78985: LD_ADDR_VAR 0 3
78989: PUSH
78990: DOUBLE
78991: LD_INT 1
78993: DEC
78994: ST_TO_ADDR
78995: LD_EXP 43
78999: PUSH
79000: FOR_TO
79001: IFFALSE 80352
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79003: LD_VAR 0 1
79007: PUSH
79008: LD_EXP 43
79012: PUSH
79013: LD_VAR 0 3
79017: ARRAY
79018: IN
79019: PUSH
79020: LD_VAR 0 1
79024: PUSH
79025: LD_EXP 50
79029: PUSH
79030: LD_VAR 0 3
79034: ARRAY
79035: IN
79036: OR
79037: PUSH
79038: LD_VAR 0 1
79042: PUSH
79043: LD_EXP 65
79047: PUSH
79048: LD_VAR 0 3
79052: ARRAY
79053: IN
79054: OR
79055: PUSH
79056: LD_VAR 0 1
79060: PUSH
79061: LD_EXP 62
79065: PUSH
79066: LD_VAR 0 3
79070: ARRAY
79071: IN
79072: OR
79073: PUSH
79074: LD_VAR 0 1
79078: PUSH
79079: LD_EXP 72
79083: PUSH
79084: LD_VAR 0 3
79088: ARRAY
79089: IN
79090: OR
79091: PUSH
79092: LD_VAR 0 1
79096: PUSH
79097: LD_EXP 73
79101: PUSH
79102: LD_VAR 0 3
79106: ARRAY
79107: IN
79108: OR
79109: IFFALSE 80350
// begin if un in mc_ape [ i ] then
79111: LD_VAR 0 1
79115: PUSH
79116: LD_EXP 72
79120: PUSH
79121: LD_VAR 0 3
79125: ARRAY
79126: IN
79127: IFFALSE 79166
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79129: LD_ADDR_EXP 72
79133: PUSH
79134: LD_EXP 72
79138: PPUSH
79139: LD_VAR 0 3
79143: PPUSH
79144: LD_EXP 72
79148: PUSH
79149: LD_VAR 0 3
79153: ARRAY
79154: PUSH
79155: LD_VAR 0 1
79159: DIFF
79160: PPUSH
79161: CALL_OW 1
79165: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79166: LD_VAR 0 1
79170: PUSH
79171: LD_EXP 73
79175: PUSH
79176: LD_VAR 0 3
79180: ARRAY
79181: IN
79182: IFFALSE 79206
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79184: LD_ADDR_EXP 73
79188: PUSH
79189: LD_EXP 73
79193: PPUSH
79194: LD_VAR 0 3
79198: PPUSH
79199: EMPTY
79200: PPUSH
79201: CALL_OW 1
79205: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79206: LD_VAR 0 1
79210: PPUSH
79211: CALL_OW 247
79215: PUSH
79216: LD_INT 2
79218: EQUAL
79219: PUSH
79220: LD_VAR 0 1
79224: PPUSH
79225: CALL_OW 110
79229: PUSH
79230: LD_INT 20
79232: EQUAL
79233: PUSH
79234: LD_VAR 0 1
79238: PUSH
79239: LD_EXP 65
79243: PUSH
79244: LD_VAR 0 3
79248: ARRAY
79249: IN
79250: OR
79251: PUSH
79252: LD_VAR 0 1
79256: PPUSH
79257: CALL_OW 264
79261: PUSH
79262: LD_INT 12
79264: PUSH
79265: LD_INT 51
79267: PUSH
79268: LD_INT 89
79270: PUSH
79271: LD_INT 32
79273: PUSH
79274: LD_INT 13
79276: PUSH
79277: LD_INT 52
79279: PUSH
79280: LD_INT 31
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: IN
79292: OR
79293: AND
79294: IFFALSE 79602
// begin if un in mc_defender [ i ] then
79296: LD_VAR 0 1
79300: PUSH
79301: LD_EXP 65
79305: PUSH
79306: LD_VAR 0 3
79310: ARRAY
79311: IN
79312: IFFALSE 79351
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79314: LD_ADDR_EXP 65
79318: PUSH
79319: LD_EXP 65
79323: PPUSH
79324: LD_VAR 0 3
79328: PPUSH
79329: LD_EXP 65
79333: PUSH
79334: LD_VAR 0 3
79338: ARRAY
79339: PUSH
79340: LD_VAR 0 1
79344: DIFF
79345: PPUSH
79346: CALL_OW 1
79350: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79351: LD_ADDR_VAR 0 8
79355: PUSH
79356: LD_VAR 0 3
79360: PPUSH
79361: LD_INT 3
79363: PPUSH
79364: CALL 75972 0 2
79368: ST_TO_ADDR
// if fac then
79369: LD_VAR 0 8
79373: IFFALSE 79602
// begin for j in fac do
79375: LD_ADDR_VAR 0 4
79379: PUSH
79380: LD_VAR 0 8
79384: PUSH
79385: FOR_IN
79386: IFFALSE 79600
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79388: LD_ADDR_VAR 0 9
79392: PUSH
79393: LD_VAR 0 8
79397: PPUSH
79398: LD_VAR 0 1
79402: PPUSH
79403: CALL_OW 265
79407: PPUSH
79408: LD_VAR 0 1
79412: PPUSH
79413: CALL_OW 262
79417: PPUSH
79418: LD_VAR 0 1
79422: PPUSH
79423: CALL_OW 263
79427: PPUSH
79428: LD_VAR 0 1
79432: PPUSH
79433: CALL_OW 264
79437: PPUSH
79438: CALL 12447 0 5
79442: ST_TO_ADDR
// if components then
79443: LD_VAR 0 9
79447: IFFALSE 79598
// begin if GetWeapon ( un ) = ar_control_tower then
79449: LD_VAR 0 1
79453: PPUSH
79454: CALL_OW 264
79458: PUSH
79459: LD_INT 31
79461: EQUAL
79462: IFFALSE 79579
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79464: LD_VAR 0 1
79468: PPUSH
79469: CALL_OW 311
79473: PPUSH
79474: LD_INT 0
79476: PPUSH
79477: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79481: LD_ADDR_EXP 83
79485: PUSH
79486: LD_EXP 83
79490: PPUSH
79491: LD_VAR 0 3
79495: PPUSH
79496: LD_EXP 83
79500: PUSH
79501: LD_VAR 0 3
79505: ARRAY
79506: PUSH
79507: LD_VAR 0 1
79511: PPUSH
79512: CALL_OW 311
79516: DIFF
79517: PPUSH
79518: CALL_OW 1
79522: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79523: LD_ADDR_VAR 0 7
79527: PUSH
79528: LD_EXP 64
79532: PUSH
79533: LD_VAR 0 3
79537: ARRAY
79538: PPUSH
79539: LD_INT 1
79541: PPUSH
79542: LD_VAR 0 9
79546: PPUSH
79547: CALL_OW 2
79551: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79552: LD_ADDR_EXP 64
79556: PUSH
79557: LD_EXP 64
79561: PPUSH
79562: LD_VAR 0 3
79566: PPUSH
79567: LD_VAR 0 7
79571: PPUSH
79572: CALL_OW 1
79576: ST_TO_ADDR
// end else
79577: GO 79596
// MC_InsertProduceList ( i , [ components ] ) ;
79579: LD_VAR 0 3
79583: PPUSH
79584: LD_VAR 0 9
79588: PUSH
79589: EMPTY
79590: LIST
79591: PPUSH
79592: CALL 75517 0 2
// break ;
79596: GO 79600
// end ; end ;
79598: GO 79385
79600: POP
79601: POP
// end ; end ; if GetType ( un ) = unit_building then
79602: LD_VAR 0 1
79606: PPUSH
79607: CALL_OW 247
79611: PUSH
79612: LD_INT 3
79614: EQUAL
79615: IFFALSE 80018
// begin btype := GetBType ( un ) ;
79617: LD_ADDR_VAR 0 5
79621: PUSH
79622: LD_VAR 0 1
79626: PPUSH
79627: CALL_OW 266
79631: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79632: LD_VAR 0 5
79636: PUSH
79637: LD_INT 29
79639: PUSH
79640: LD_INT 30
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: IN
79647: IFFALSE 79720
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79649: LD_VAR 0 1
79653: PPUSH
79654: CALL_OW 250
79658: PPUSH
79659: LD_VAR 0 1
79663: PPUSH
79664: CALL_OW 251
79668: PPUSH
79669: LD_VAR 0 1
79673: PPUSH
79674: CALL_OW 255
79678: PPUSH
79679: CALL_OW 440
79683: NOT
79684: IFFALSE 79720
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79686: LD_VAR 0 1
79690: PPUSH
79691: CALL_OW 250
79695: PPUSH
79696: LD_VAR 0 1
79700: PPUSH
79701: CALL_OW 251
79705: PPUSH
79706: LD_VAR 0 1
79710: PPUSH
79711: CALL_OW 255
79715: PPUSH
79716: CALL_OW 441
// end ; if btype = b_warehouse then
79720: LD_VAR 0 5
79724: PUSH
79725: LD_INT 1
79727: EQUAL
79728: IFFALSE 79746
// begin btype := b_depot ;
79730: LD_ADDR_VAR 0 5
79734: PUSH
79735: LD_INT 0
79737: ST_TO_ADDR
// pos := 1 ;
79738: LD_ADDR_VAR 0 6
79742: PUSH
79743: LD_INT 1
79745: ST_TO_ADDR
// end ; if btype = b_factory then
79746: LD_VAR 0 5
79750: PUSH
79751: LD_INT 3
79753: EQUAL
79754: IFFALSE 79772
// begin btype := b_workshop ;
79756: LD_ADDR_VAR 0 5
79760: PUSH
79761: LD_INT 2
79763: ST_TO_ADDR
// pos := 1 ;
79764: LD_ADDR_VAR 0 6
79768: PUSH
79769: LD_INT 1
79771: ST_TO_ADDR
// end ; if btype = b_barracks then
79772: LD_VAR 0 5
79776: PUSH
79777: LD_INT 5
79779: EQUAL
79780: IFFALSE 79790
// btype := b_armoury ;
79782: LD_ADDR_VAR 0 5
79786: PUSH
79787: LD_INT 4
79789: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79790: LD_VAR 0 5
79794: PUSH
79795: LD_INT 7
79797: PUSH
79798: LD_INT 8
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: IN
79805: IFFALSE 79815
// btype := b_lab ;
79807: LD_ADDR_VAR 0 5
79811: PUSH
79812: LD_INT 6
79814: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79815: LD_ADDR_EXP 48
79819: PUSH
79820: LD_EXP 48
79824: PPUSH
79825: LD_VAR 0 3
79829: PUSH
79830: LD_EXP 48
79834: PUSH
79835: LD_VAR 0 3
79839: ARRAY
79840: PUSH
79841: LD_INT 1
79843: PLUS
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PPUSH
79849: LD_VAR 0 5
79853: PUSH
79854: LD_VAR 0 1
79858: PPUSH
79859: CALL_OW 250
79863: PUSH
79864: LD_VAR 0 1
79868: PPUSH
79869: CALL_OW 251
79873: PUSH
79874: LD_VAR 0 1
79878: PPUSH
79879: CALL_OW 254
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: PPUSH
79890: CALL 14949 0 3
79894: ST_TO_ADDR
// if pos = 1 then
79895: LD_VAR 0 6
79899: PUSH
79900: LD_INT 1
79902: EQUAL
79903: IFFALSE 80018
// begin tmp := mc_build_list [ i ] ;
79905: LD_ADDR_VAR 0 7
79909: PUSH
79910: LD_EXP 48
79914: PUSH
79915: LD_VAR 0 3
79919: ARRAY
79920: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79921: LD_VAR 0 7
79925: PPUSH
79926: LD_INT 2
79928: PUSH
79929: LD_INT 30
79931: PUSH
79932: LD_INT 0
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 30
79941: PUSH
79942: LD_INT 1
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: LIST
79953: PPUSH
79954: CALL_OW 72
79958: IFFALSE 79968
// pos := 2 ;
79960: LD_ADDR_VAR 0 6
79964: PUSH
79965: LD_INT 2
79967: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79968: LD_ADDR_VAR 0 7
79972: PUSH
79973: LD_VAR 0 7
79977: PPUSH
79978: LD_VAR 0 6
79982: PPUSH
79983: LD_VAR 0 7
79987: PPUSH
79988: CALL 15275 0 3
79992: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79993: LD_ADDR_EXP 48
79997: PUSH
79998: LD_EXP 48
80002: PPUSH
80003: LD_VAR 0 3
80007: PPUSH
80008: LD_VAR 0 7
80012: PPUSH
80013: CALL_OW 1
80017: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80018: LD_VAR 0 1
80022: PUSH
80023: LD_EXP 43
80027: PUSH
80028: LD_VAR 0 3
80032: ARRAY
80033: IN
80034: IFFALSE 80073
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80036: LD_ADDR_EXP 43
80040: PUSH
80041: LD_EXP 43
80045: PPUSH
80046: LD_VAR 0 3
80050: PPUSH
80051: LD_EXP 43
80055: PUSH
80056: LD_VAR 0 3
80060: ARRAY
80061: PUSH
80062: LD_VAR 0 1
80066: DIFF
80067: PPUSH
80068: CALL_OW 1
80072: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80073: LD_VAR 0 1
80077: PUSH
80078: LD_EXP 50
80082: PUSH
80083: LD_VAR 0 3
80087: ARRAY
80088: IN
80089: IFFALSE 80128
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80091: LD_ADDR_EXP 50
80095: PUSH
80096: LD_EXP 50
80100: PPUSH
80101: LD_VAR 0 3
80105: PPUSH
80106: LD_EXP 50
80110: PUSH
80111: LD_VAR 0 3
80115: ARRAY
80116: PUSH
80117: LD_VAR 0 1
80121: DIFF
80122: PPUSH
80123: CALL_OW 1
80127: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80128: LD_VAR 0 1
80132: PUSH
80133: LD_EXP 62
80137: PUSH
80138: LD_VAR 0 3
80142: ARRAY
80143: IN
80144: IFFALSE 80183
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80146: LD_ADDR_EXP 62
80150: PUSH
80151: LD_EXP 62
80155: PPUSH
80156: LD_VAR 0 3
80160: PPUSH
80161: LD_EXP 62
80165: PUSH
80166: LD_VAR 0 3
80170: ARRAY
80171: PUSH
80172: LD_VAR 0 1
80176: DIFF
80177: PPUSH
80178: CALL_OW 1
80182: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80183: LD_VAR 0 1
80187: PUSH
80188: LD_EXP 65
80192: PUSH
80193: LD_VAR 0 3
80197: ARRAY
80198: IN
80199: IFFALSE 80238
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80201: LD_ADDR_EXP 65
80205: PUSH
80206: LD_EXP 65
80210: PPUSH
80211: LD_VAR 0 3
80215: PPUSH
80216: LD_EXP 65
80220: PUSH
80221: LD_VAR 0 3
80225: ARRAY
80226: PUSH
80227: LD_VAR 0 1
80231: DIFF
80232: PPUSH
80233: CALL_OW 1
80237: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80238: LD_VAR 0 1
80242: PUSH
80243: LD_EXP 52
80247: PUSH
80248: LD_VAR 0 3
80252: ARRAY
80253: IN
80254: IFFALSE 80293
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80256: LD_ADDR_EXP 52
80260: PUSH
80261: LD_EXP 52
80265: PPUSH
80266: LD_VAR 0 3
80270: PPUSH
80271: LD_EXP 52
80275: PUSH
80276: LD_VAR 0 3
80280: ARRAY
80281: PUSH
80282: LD_VAR 0 1
80286: DIFF
80287: PPUSH
80288: CALL_OW 1
80292: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80293: LD_VAR 0 1
80297: PUSH
80298: LD_EXP 51
80302: PUSH
80303: LD_VAR 0 3
80307: ARRAY
80308: IN
80309: IFFALSE 80348
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80311: LD_ADDR_EXP 51
80315: PUSH
80316: LD_EXP 51
80320: PPUSH
80321: LD_VAR 0 3
80325: PPUSH
80326: LD_EXP 51
80330: PUSH
80331: LD_VAR 0 3
80335: ARRAY
80336: PUSH
80337: LD_VAR 0 1
80341: DIFF
80342: PPUSH
80343: CALL_OW 1
80347: ST_TO_ADDR
// end ; break ;
80348: GO 80352
// end ;
80350: GO 79000
80352: POP
80353: POP
// end ;
80354: LD_VAR 0 2
80358: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80359: LD_INT 0
80361: PPUSH
80362: PPUSH
80363: PPUSH
// if not mc_bases or not skirmish then
80364: LD_EXP 43
80368: NOT
80369: PUSH
80370: LD_EXP 41
80374: NOT
80375: OR
80376: IFFALSE 80380
// exit ;
80378: GO 80595
// for i = 1 to mc_bases do
80380: LD_ADDR_VAR 0 3
80384: PUSH
80385: DOUBLE
80386: LD_INT 1
80388: DEC
80389: ST_TO_ADDR
80390: LD_EXP 43
80394: PUSH
80395: FOR_TO
80396: IFFALSE 80593
// begin if building in mc_construct_list [ i ] then
80398: LD_VAR 0 1
80402: PUSH
80403: LD_EXP 50
80407: PUSH
80408: LD_VAR 0 3
80412: ARRAY
80413: IN
80414: IFFALSE 80591
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80416: LD_ADDR_EXP 50
80420: PUSH
80421: LD_EXP 50
80425: PPUSH
80426: LD_VAR 0 3
80430: PPUSH
80431: LD_EXP 50
80435: PUSH
80436: LD_VAR 0 3
80440: ARRAY
80441: PUSH
80442: LD_VAR 0 1
80446: DIFF
80447: PPUSH
80448: CALL_OW 1
80452: ST_TO_ADDR
// if building in mc_lab [ i ] then
80453: LD_VAR 0 1
80457: PUSH
80458: LD_EXP 76
80462: PUSH
80463: LD_VAR 0 3
80467: ARRAY
80468: IN
80469: IFFALSE 80524
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80471: LD_ADDR_EXP 77
80475: PUSH
80476: LD_EXP 77
80480: PPUSH
80481: LD_VAR 0 3
80485: PPUSH
80486: LD_EXP 77
80490: PUSH
80491: LD_VAR 0 3
80495: ARRAY
80496: PPUSH
80497: LD_INT 1
80499: PPUSH
80500: LD_EXP 77
80504: PUSH
80505: LD_VAR 0 3
80509: ARRAY
80510: PPUSH
80511: LD_INT 0
80513: PPUSH
80514: CALL 14367 0 4
80518: PPUSH
80519: CALL_OW 1
80523: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80524: LD_VAR 0 1
80528: PUSH
80529: LD_EXP 43
80533: PUSH
80534: LD_VAR 0 3
80538: ARRAY
80539: IN
80540: NOT
80541: IFFALSE 80587
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80543: LD_ADDR_EXP 43
80547: PUSH
80548: LD_EXP 43
80552: PPUSH
80553: LD_VAR 0 3
80557: PUSH
80558: LD_EXP 43
80562: PUSH
80563: LD_VAR 0 3
80567: ARRAY
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PPUSH
80577: LD_VAR 0 1
80581: PPUSH
80582: CALL 14949 0 3
80586: ST_TO_ADDR
// exit ;
80587: POP
80588: POP
80589: GO 80595
// end ; end ;
80591: GO 80395
80593: POP
80594: POP
// end ;
80595: LD_VAR 0 2
80599: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80600: LD_INT 0
80602: PPUSH
80603: PPUSH
80604: PPUSH
80605: PPUSH
80606: PPUSH
80607: PPUSH
80608: PPUSH
// if not mc_bases or not skirmish then
80609: LD_EXP 43
80613: NOT
80614: PUSH
80615: LD_EXP 41
80619: NOT
80620: OR
80621: IFFALSE 80625
// exit ;
80623: GO 81286
// for i = 1 to mc_bases do
80625: LD_ADDR_VAR 0 3
80629: PUSH
80630: DOUBLE
80631: LD_INT 1
80633: DEC
80634: ST_TO_ADDR
80635: LD_EXP 43
80639: PUSH
80640: FOR_TO
80641: IFFALSE 81284
// begin if building in mc_construct_list [ i ] then
80643: LD_VAR 0 1
80647: PUSH
80648: LD_EXP 50
80652: PUSH
80653: LD_VAR 0 3
80657: ARRAY
80658: IN
80659: IFFALSE 81282
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80661: LD_ADDR_EXP 50
80665: PUSH
80666: LD_EXP 50
80670: PPUSH
80671: LD_VAR 0 3
80675: PPUSH
80676: LD_EXP 50
80680: PUSH
80681: LD_VAR 0 3
80685: ARRAY
80686: PUSH
80687: LD_VAR 0 1
80691: DIFF
80692: PPUSH
80693: CALL_OW 1
80697: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80698: LD_ADDR_EXP 43
80702: PUSH
80703: LD_EXP 43
80707: PPUSH
80708: LD_VAR 0 3
80712: PUSH
80713: LD_EXP 43
80717: PUSH
80718: LD_VAR 0 3
80722: ARRAY
80723: PUSH
80724: LD_INT 1
80726: PLUS
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PPUSH
80732: LD_VAR 0 1
80736: PPUSH
80737: CALL 14949 0 3
80741: ST_TO_ADDR
// btype := GetBType ( building ) ;
80742: LD_ADDR_VAR 0 5
80746: PUSH
80747: LD_VAR 0 1
80751: PPUSH
80752: CALL_OW 266
80756: ST_TO_ADDR
// side := GetSide ( building ) ;
80757: LD_ADDR_VAR 0 8
80761: PUSH
80762: LD_VAR 0 1
80766: PPUSH
80767: CALL_OW 255
80771: ST_TO_ADDR
// if btype = b_lab then
80772: LD_VAR 0 5
80776: PUSH
80777: LD_INT 6
80779: EQUAL
80780: IFFALSE 80830
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80782: LD_ADDR_EXP 76
80786: PUSH
80787: LD_EXP 76
80791: PPUSH
80792: LD_VAR 0 3
80796: PUSH
80797: LD_EXP 76
80801: PUSH
80802: LD_VAR 0 3
80806: ARRAY
80807: PUSH
80808: LD_INT 1
80810: PLUS
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PPUSH
80816: LD_VAR 0 1
80820: PPUSH
80821: CALL 14949 0 3
80825: ST_TO_ADDR
// exit ;
80826: POP
80827: POP
80828: GO 81286
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80830: LD_VAR 0 5
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 4
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: LIST
80848: IN
80849: IFFALSE 80973
// begin if btype = b_armoury then
80851: LD_VAR 0 5
80855: PUSH
80856: LD_INT 4
80858: EQUAL
80859: IFFALSE 80869
// btype := b_barracks ;
80861: LD_ADDR_VAR 0 5
80865: PUSH
80866: LD_INT 5
80868: ST_TO_ADDR
// if btype = b_depot then
80869: LD_VAR 0 5
80873: PUSH
80874: LD_INT 0
80876: EQUAL
80877: IFFALSE 80887
// btype := b_warehouse ;
80879: LD_ADDR_VAR 0 5
80883: PUSH
80884: LD_INT 1
80886: ST_TO_ADDR
// if btype = b_workshop then
80887: LD_VAR 0 5
80891: PUSH
80892: LD_INT 2
80894: EQUAL
80895: IFFALSE 80905
// btype := b_factory ;
80897: LD_ADDR_VAR 0 5
80901: PUSH
80902: LD_INT 3
80904: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80905: LD_VAR 0 5
80909: PPUSH
80910: LD_VAR 0 8
80914: PPUSH
80915: CALL_OW 323
80919: PUSH
80920: LD_INT 1
80922: EQUAL
80923: IFFALSE 80969
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80925: LD_ADDR_EXP 75
80929: PUSH
80930: LD_EXP 75
80934: PPUSH
80935: LD_VAR 0 3
80939: PUSH
80940: LD_EXP 75
80944: PUSH
80945: LD_VAR 0 3
80949: ARRAY
80950: PUSH
80951: LD_INT 1
80953: PLUS
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PPUSH
80959: LD_VAR 0 1
80963: PPUSH
80964: CALL 14949 0 3
80968: ST_TO_ADDR
// exit ;
80969: POP
80970: POP
80971: GO 81286
// end ; if btype in [ b_bunker , b_turret ] then
80973: LD_VAR 0 5
80977: PUSH
80978: LD_INT 32
80980: PUSH
80981: LD_INT 33
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: IN
80988: IFFALSE 81278
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80990: LD_ADDR_EXP 51
80994: PUSH
80995: LD_EXP 51
80999: PPUSH
81000: LD_VAR 0 3
81004: PUSH
81005: LD_EXP 51
81009: PUSH
81010: LD_VAR 0 3
81014: ARRAY
81015: PUSH
81016: LD_INT 1
81018: PLUS
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PPUSH
81024: LD_VAR 0 1
81028: PPUSH
81029: CALL 14949 0 3
81033: ST_TO_ADDR
// if btype = b_bunker then
81034: LD_VAR 0 5
81038: PUSH
81039: LD_INT 32
81041: EQUAL
81042: IFFALSE 81278
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81044: LD_ADDR_EXP 52
81048: PUSH
81049: LD_EXP 52
81053: PPUSH
81054: LD_VAR 0 3
81058: PUSH
81059: LD_EXP 52
81063: PUSH
81064: LD_VAR 0 3
81068: ARRAY
81069: PUSH
81070: LD_INT 1
81072: PLUS
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PPUSH
81078: LD_VAR 0 1
81082: PPUSH
81083: CALL 14949 0 3
81087: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81088: LD_ADDR_VAR 0 6
81092: PUSH
81093: LD_EXP 43
81097: PUSH
81098: LD_VAR 0 3
81102: ARRAY
81103: PPUSH
81104: LD_INT 25
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 3
81116: PUSH
81117: LD_INT 54
81119: PUSH
81120: EMPTY
81121: LIST
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PPUSH
81131: CALL_OW 72
81135: ST_TO_ADDR
// if tmp then
81136: LD_VAR 0 6
81140: IFFALSE 81146
// exit ;
81142: POP
81143: POP
81144: GO 81286
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81146: LD_ADDR_VAR 0 6
81150: PUSH
81151: LD_EXP 43
81155: PUSH
81156: LD_VAR 0 3
81160: ARRAY
81161: PPUSH
81162: LD_INT 2
81164: PUSH
81165: LD_INT 30
81167: PUSH
81168: LD_INT 4
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 30
81177: PUSH
81178: LD_INT 5
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: LIST
81189: PPUSH
81190: CALL_OW 72
81194: ST_TO_ADDR
// if not tmp then
81195: LD_VAR 0 6
81199: NOT
81200: IFFALSE 81206
// exit ;
81202: POP
81203: POP
81204: GO 81286
// for j in tmp do
81206: LD_ADDR_VAR 0 4
81210: PUSH
81211: LD_VAR 0 6
81215: PUSH
81216: FOR_IN
81217: IFFALSE 81276
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81219: LD_ADDR_VAR 0 7
81223: PUSH
81224: LD_VAR 0 4
81228: PPUSH
81229: CALL_OW 313
81233: PPUSH
81234: LD_INT 25
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PPUSH
81244: CALL_OW 72
81248: ST_TO_ADDR
// if units then
81249: LD_VAR 0 7
81253: IFFALSE 81274
// begin ComExitBuilding ( units [ 1 ] ) ;
81255: LD_VAR 0 7
81259: PUSH
81260: LD_INT 1
81262: ARRAY
81263: PPUSH
81264: CALL_OW 122
// exit ;
81268: POP
81269: POP
81270: POP
81271: POP
81272: GO 81286
// end ; end ;
81274: GO 81216
81276: POP
81277: POP
// end ; end ; exit ;
81278: POP
81279: POP
81280: GO 81286
// end ; end ;
81282: GO 80640
81284: POP
81285: POP
// end ;
81286: LD_VAR 0 2
81290: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81291: LD_INT 0
81293: PPUSH
81294: PPUSH
81295: PPUSH
81296: PPUSH
81297: PPUSH
81298: PPUSH
81299: PPUSH
// if not mc_bases or not skirmish then
81300: LD_EXP 43
81304: NOT
81305: PUSH
81306: LD_EXP 41
81310: NOT
81311: OR
81312: IFFALSE 81316
// exit ;
81314: GO 81581
// btype := GetBType ( building ) ;
81316: LD_ADDR_VAR 0 6
81320: PUSH
81321: LD_VAR 0 1
81325: PPUSH
81326: CALL_OW 266
81330: ST_TO_ADDR
// x := GetX ( building ) ;
81331: LD_ADDR_VAR 0 7
81335: PUSH
81336: LD_VAR 0 1
81340: PPUSH
81341: CALL_OW 250
81345: ST_TO_ADDR
// y := GetY ( building ) ;
81346: LD_ADDR_VAR 0 8
81350: PUSH
81351: LD_VAR 0 1
81355: PPUSH
81356: CALL_OW 251
81360: ST_TO_ADDR
// d := GetDir ( building ) ;
81361: LD_ADDR_VAR 0 9
81365: PUSH
81366: LD_VAR 0 1
81370: PPUSH
81371: CALL_OW 254
81375: ST_TO_ADDR
// for i = 1 to mc_bases do
81376: LD_ADDR_VAR 0 4
81380: PUSH
81381: DOUBLE
81382: LD_INT 1
81384: DEC
81385: ST_TO_ADDR
81386: LD_EXP 43
81390: PUSH
81391: FOR_TO
81392: IFFALSE 81579
// begin if not mc_build_list [ i ] then
81394: LD_EXP 48
81398: PUSH
81399: LD_VAR 0 4
81403: ARRAY
81404: NOT
81405: IFFALSE 81409
// continue ;
81407: GO 81391
// for j := 1 to mc_build_list [ i ] do
81409: LD_ADDR_VAR 0 5
81413: PUSH
81414: DOUBLE
81415: LD_INT 1
81417: DEC
81418: ST_TO_ADDR
81419: LD_EXP 48
81423: PUSH
81424: LD_VAR 0 4
81428: ARRAY
81429: PUSH
81430: FOR_TO
81431: IFFALSE 81575
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81433: LD_VAR 0 6
81437: PUSH
81438: LD_VAR 0 7
81442: PUSH
81443: LD_VAR 0 8
81447: PUSH
81448: LD_VAR 0 9
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: PPUSH
81459: LD_EXP 48
81463: PUSH
81464: LD_VAR 0 4
81468: ARRAY
81469: PUSH
81470: LD_VAR 0 5
81474: ARRAY
81475: PPUSH
81476: CALL 21129 0 2
81480: IFFALSE 81573
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81482: LD_ADDR_EXP 48
81486: PUSH
81487: LD_EXP 48
81491: PPUSH
81492: LD_VAR 0 4
81496: PPUSH
81497: LD_EXP 48
81501: PUSH
81502: LD_VAR 0 4
81506: ARRAY
81507: PPUSH
81508: LD_VAR 0 5
81512: PPUSH
81513: CALL_OW 3
81517: PPUSH
81518: CALL_OW 1
81522: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81523: LD_ADDR_EXP 50
81527: PUSH
81528: LD_EXP 50
81532: PPUSH
81533: LD_VAR 0 4
81537: PUSH
81538: LD_EXP 50
81542: PUSH
81543: LD_VAR 0 4
81547: ARRAY
81548: PUSH
81549: LD_INT 1
81551: PLUS
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PPUSH
81557: LD_VAR 0 1
81561: PPUSH
81562: CALL 14949 0 3
81566: ST_TO_ADDR
// exit ;
81567: POP
81568: POP
81569: POP
81570: POP
81571: GO 81581
// end ;
81573: GO 81430
81575: POP
81576: POP
// end ;
81577: GO 81391
81579: POP
81580: POP
// end ;
81581: LD_VAR 0 3
81585: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81586: LD_INT 0
81588: PPUSH
81589: PPUSH
81590: PPUSH
// if not mc_bases or not skirmish then
81591: LD_EXP 43
81595: NOT
81596: PUSH
81597: LD_EXP 41
81601: NOT
81602: OR
81603: IFFALSE 81607
// exit ;
81605: GO 81797
// for i = 1 to mc_bases do
81607: LD_ADDR_VAR 0 4
81611: PUSH
81612: DOUBLE
81613: LD_INT 1
81615: DEC
81616: ST_TO_ADDR
81617: LD_EXP 43
81621: PUSH
81622: FOR_TO
81623: IFFALSE 81710
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81625: LD_VAR 0 1
81629: PUSH
81630: LD_EXP 51
81634: PUSH
81635: LD_VAR 0 4
81639: ARRAY
81640: IN
81641: PUSH
81642: LD_VAR 0 1
81646: PUSH
81647: LD_EXP 52
81651: PUSH
81652: LD_VAR 0 4
81656: ARRAY
81657: IN
81658: NOT
81659: AND
81660: IFFALSE 81708
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81662: LD_ADDR_EXP 52
81666: PUSH
81667: LD_EXP 52
81671: PPUSH
81672: LD_VAR 0 4
81676: PUSH
81677: LD_EXP 52
81681: PUSH
81682: LD_VAR 0 4
81686: ARRAY
81687: PUSH
81688: LD_INT 1
81690: PLUS
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PPUSH
81696: LD_VAR 0 1
81700: PPUSH
81701: CALL 14949 0 3
81705: ST_TO_ADDR
// break ;
81706: GO 81710
// end ; end ;
81708: GO 81622
81710: POP
81711: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81712: LD_VAR 0 1
81716: PPUSH
81717: CALL_OW 257
81721: PUSH
81722: LD_EXP 69
81726: IN
81727: PUSH
81728: LD_VAR 0 1
81732: PPUSH
81733: CALL_OW 266
81737: PUSH
81738: LD_INT 5
81740: EQUAL
81741: AND
81742: PUSH
81743: LD_VAR 0 2
81747: PPUSH
81748: CALL_OW 110
81752: PUSH
81753: LD_INT 18
81755: NONEQUAL
81756: AND
81757: IFFALSE 81797
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81759: LD_VAR 0 2
81763: PPUSH
81764: CALL_OW 257
81768: PUSH
81769: LD_INT 5
81771: PUSH
81772: LD_INT 8
81774: PUSH
81775: LD_INT 9
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: LIST
81782: IN
81783: IFFALSE 81797
// SetClass ( unit , 1 ) ;
81785: LD_VAR 0 2
81789: PPUSH
81790: LD_INT 1
81792: PPUSH
81793: CALL_OW 336
// end ;
81797: LD_VAR 0 3
81801: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81802: LD_INT 0
81804: PPUSH
81805: PPUSH
// if not mc_bases or not skirmish then
81806: LD_EXP 43
81810: NOT
81811: PUSH
81812: LD_EXP 41
81816: NOT
81817: OR
81818: IFFALSE 81822
// exit ;
81820: GO 81938
// if GetLives ( abandoned_vehicle ) > 250 then
81822: LD_VAR 0 2
81826: PPUSH
81827: CALL_OW 256
81831: PUSH
81832: LD_INT 250
81834: GREATER
81835: IFFALSE 81839
// exit ;
81837: GO 81938
// for i = 1 to mc_bases do
81839: LD_ADDR_VAR 0 6
81843: PUSH
81844: DOUBLE
81845: LD_INT 1
81847: DEC
81848: ST_TO_ADDR
81849: LD_EXP 43
81853: PUSH
81854: FOR_TO
81855: IFFALSE 81936
// begin if driver in mc_bases [ i ] then
81857: LD_VAR 0 1
81861: PUSH
81862: LD_EXP 43
81866: PUSH
81867: LD_VAR 0 6
81871: ARRAY
81872: IN
81873: IFFALSE 81934
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81875: LD_VAR 0 1
81879: PPUSH
81880: LD_EXP 43
81884: PUSH
81885: LD_VAR 0 6
81889: ARRAY
81890: PPUSH
81891: LD_INT 2
81893: PUSH
81894: LD_INT 30
81896: PUSH
81897: LD_INT 0
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 30
81906: PUSH
81907: LD_INT 1
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: LIST
81918: PPUSH
81919: CALL_OW 72
81923: PUSH
81924: LD_INT 1
81926: ARRAY
81927: PPUSH
81928: CALL 48157 0 2
// break ;
81932: GO 81936
// end ; end ;
81934: GO 81854
81936: POP
81937: POP
// end ; end_of_file
81938: LD_VAR 0 5
81942: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81943: LD_INT 0
81945: PPUSH
81946: PPUSH
81947: PPUSH
81948: PPUSH
81949: PPUSH
81950: PPUSH
81951: PPUSH
81952: PPUSH
81953: PPUSH
81954: PPUSH
81955: PPUSH
81956: PPUSH
81957: PPUSH
81958: PPUSH
81959: PPUSH
81960: PPUSH
81961: PPUSH
81962: PPUSH
81963: PPUSH
81964: PPUSH
81965: PPUSH
81966: PPUSH
81967: PPUSH
81968: PPUSH
81969: PPUSH
81970: PPUSH
81971: PPUSH
81972: PPUSH
81973: PPUSH
81974: PPUSH
81975: PPUSH
81976: PPUSH
81977: PPUSH
81978: PPUSH
// if not list then
81979: LD_VAR 0 1
81983: NOT
81984: IFFALSE 81988
// exit ;
81986: GO 86647
// base := list [ 1 ] ;
81988: LD_ADDR_VAR 0 3
81992: PUSH
81993: LD_VAR 0 1
81997: PUSH
81998: LD_INT 1
82000: ARRAY
82001: ST_TO_ADDR
// group := list [ 2 ] ;
82002: LD_ADDR_VAR 0 4
82006: PUSH
82007: LD_VAR 0 1
82011: PUSH
82012: LD_INT 2
82014: ARRAY
82015: ST_TO_ADDR
// path := list [ 3 ] ;
82016: LD_ADDR_VAR 0 5
82020: PUSH
82021: LD_VAR 0 1
82025: PUSH
82026: LD_INT 3
82028: ARRAY
82029: ST_TO_ADDR
// flags := list [ 4 ] ;
82030: LD_ADDR_VAR 0 6
82034: PUSH
82035: LD_VAR 0 1
82039: PUSH
82040: LD_INT 4
82042: ARRAY
82043: ST_TO_ADDR
// mined := [ ] ;
82044: LD_ADDR_VAR 0 27
82048: PUSH
82049: EMPTY
82050: ST_TO_ADDR
// bombed := [ ] ;
82051: LD_ADDR_VAR 0 28
82055: PUSH
82056: EMPTY
82057: ST_TO_ADDR
// healers := [ ] ;
82058: LD_ADDR_VAR 0 31
82062: PUSH
82063: EMPTY
82064: ST_TO_ADDR
// to_heal := [ ] ;
82065: LD_ADDR_VAR 0 30
82069: PUSH
82070: EMPTY
82071: ST_TO_ADDR
// repairs := [ ] ;
82072: LD_ADDR_VAR 0 33
82076: PUSH
82077: EMPTY
82078: ST_TO_ADDR
// to_repair := [ ] ;
82079: LD_ADDR_VAR 0 32
82083: PUSH
82084: EMPTY
82085: ST_TO_ADDR
// if not group or not path then
82086: LD_VAR 0 4
82090: NOT
82091: PUSH
82092: LD_VAR 0 5
82096: NOT
82097: OR
82098: IFFALSE 82102
// exit ;
82100: GO 86647
// side := GetSide ( group [ 1 ] ) ;
82102: LD_ADDR_VAR 0 35
82106: PUSH
82107: LD_VAR 0 4
82111: PUSH
82112: LD_INT 1
82114: ARRAY
82115: PPUSH
82116: CALL_OW 255
82120: ST_TO_ADDR
// if flags then
82121: LD_VAR 0 6
82125: IFFALSE 82269
// begin f_ignore_area := flags [ 1 ] ;
82127: LD_ADDR_VAR 0 17
82131: PUSH
82132: LD_VAR 0 6
82136: PUSH
82137: LD_INT 1
82139: ARRAY
82140: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82141: LD_ADDR_VAR 0 18
82145: PUSH
82146: LD_VAR 0 6
82150: PUSH
82151: LD_INT 2
82153: ARRAY
82154: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82155: LD_ADDR_VAR 0 19
82159: PUSH
82160: LD_VAR 0 6
82164: PUSH
82165: LD_INT 3
82167: ARRAY
82168: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82169: LD_ADDR_VAR 0 20
82173: PUSH
82174: LD_VAR 0 6
82178: PUSH
82179: LD_INT 4
82181: ARRAY
82182: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82183: LD_ADDR_VAR 0 21
82187: PUSH
82188: LD_VAR 0 6
82192: PUSH
82193: LD_INT 5
82195: ARRAY
82196: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82197: LD_ADDR_VAR 0 22
82201: PUSH
82202: LD_VAR 0 6
82206: PUSH
82207: LD_INT 6
82209: ARRAY
82210: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82211: LD_ADDR_VAR 0 23
82215: PUSH
82216: LD_VAR 0 6
82220: PUSH
82221: LD_INT 7
82223: ARRAY
82224: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82225: LD_ADDR_VAR 0 24
82229: PUSH
82230: LD_VAR 0 6
82234: PUSH
82235: LD_INT 8
82237: ARRAY
82238: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82239: LD_ADDR_VAR 0 25
82243: PUSH
82244: LD_VAR 0 6
82248: PUSH
82249: LD_INT 9
82251: ARRAY
82252: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82253: LD_ADDR_VAR 0 26
82257: PUSH
82258: LD_VAR 0 6
82262: PUSH
82263: LD_INT 10
82265: ARRAY
82266: ST_TO_ADDR
// end else
82267: GO 82349
// begin f_ignore_area := false ;
82269: LD_ADDR_VAR 0 17
82273: PUSH
82274: LD_INT 0
82276: ST_TO_ADDR
// f_capture := false ;
82277: LD_ADDR_VAR 0 18
82281: PUSH
82282: LD_INT 0
82284: ST_TO_ADDR
// f_ignore_civ := false ;
82285: LD_ADDR_VAR 0 19
82289: PUSH
82290: LD_INT 0
82292: ST_TO_ADDR
// f_murder := false ;
82293: LD_ADDR_VAR 0 20
82297: PUSH
82298: LD_INT 0
82300: ST_TO_ADDR
// f_mines := false ;
82301: LD_ADDR_VAR 0 21
82305: PUSH
82306: LD_INT 0
82308: ST_TO_ADDR
// f_repair := false ;
82309: LD_ADDR_VAR 0 22
82313: PUSH
82314: LD_INT 0
82316: ST_TO_ADDR
// f_heal := false ;
82317: LD_ADDR_VAR 0 23
82321: PUSH
82322: LD_INT 0
82324: ST_TO_ADDR
// f_spacetime := false ;
82325: LD_ADDR_VAR 0 24
82329: PUSH
82330: LD_INT 0
82332: ST_TO_ADDR
// f_attack_depot := false ;
82333: LD_ADDR_VAR 0 25
82337: PUSH
82338: LD_INT 0
82340: ST_TO_ADDR
// f_crawl := false ;
82341: LD_ADDR_VAR 0 26
82345: PUSH
82346: LD_INT 0
82348: ST_TO_ADDR
// end ; if f_heal then
82349: LD_VAR 0 23
82353: IFFALSE 82380
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82355: LD_ADDR_VAR 0 31
82359: PUSH
82360: LD_VAR 0 4
82364: PPUSH
82365: LD_INT 25
82367: PUSH
82368: LD_INT 4
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PPUSH
82375: CALL_OW 72
82379: ST_TO_ADDR
// if f_repair then
82380: LD_VAR 0 22
82384: IFFALSE 82411
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82386: LD_ADDR_VAR 0 33
82390: PUSH
82391: LD_VAR 0 4
82395: PPUSH
82396: LD_INT 25
82398: PUSH
82399: LD_INT 3
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PPUSH
82406: CALL_OW 72
82410: ST_TO_ADDR
// units_path := [ ] ;
82411: LD_ADDR_VAR 0 16
82415: PUSH
82416: EMPTY
82417: ST_TO_ADDR
// for i = 1 to group do
82418: LD_ADDR_VAR 0 7
82422: PUSH
82423: DOUBLE
82424: LD_INT 1
82426: DEC
82427: ST_TO_ADDR
82428: LD_VAR 0 4
82432: PUSH
82433: FOR_TO
82434: IFFALSE 82463
// units_path := Replace ( units_path , i , path ) ;
82436: LD_ADDR_VAR 0 16
82440: PUSH
82441: LD_VAR 0 16
82445: PPUSH
82446: LD_VAR 0 7
82450: PPUSH
82451: LD_VAR 0 5
82455: PPUSH
82456: CALL_OW 1
82460: ST_TO_ADDR
82461: GO 82433
82463: POP
82464: POP
// repeat for i = group downto 1 do
82465: LD_ADDR_VAR 0 7
82469: PUSH
82470: DOUBLE
82471: LD_VAR 0 4
82475: INC
82476: ST_TO_ADDR
82477: LD_INT 1
82479: PUSH
82480: FOR_DOWNTO
82481: IFFALSE 86603
// begin wait ( 5 ) ;
82483: LD_INT 5
82485: PPUSH
82486: CALL_OW 67
// tmp := [ ] ;
82490: LD_ADDR_VAR 0 14
82494: PUSH
82495: EMPTY
82496: ST_TO_ADDR
// attacking := false ;
82497: LD_ADDR_VAR 0 29
82501: PUSH
82502: LD_INT 0
82504: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82505: LD_VAR 0 4
82509: PUSH
82510: LD_VAR 0 7
82514: ARRAY
82515: PPUSH
82516: CALL_OW 301
82520: PUSH
82521: LD_VAR 0 4
82525: PUSH
82526: LD_VAR 0 7
82530: ARRAY
82531: NOT
82532: OR
82533: IFFALSE 82642
// begin if GetType ( group [ i ] ) = unit_human then
82535: LD_VAR 0 4
82539: PUSH
82540: LD_VAR 0 7
82544: ARRAY
82545: PPUSH
82546: CALL_OW 247
82550: PUSH
82551: LD_INT 1
82553: EQUAL
82554: IFFALSE 82600
// begin to_heal := to_heal diff group [ i ] ;
82556: LD_ADDR_VAR 0 30
82560: PUSH
82561: LD_VAR 0 30
82565: PUSH
82566: LD_VAR 0 4
82570: PUSH
82571: LD_VAR 0 7
82575: ARRAY
82576: DIFF
82577: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82578: LD_ADDR_VAR 0 31
82582: PUSH
82583: LD_VAR 0 31
82587: PUSH
82588: LD_VAR 0 4
82592: PUSH
82593: LD_VAR 0 7
82597: ARRAY
82598: DIFF
82599: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82600: LD_ADDR_VAR 0 4
82604: PUSH
82605: LD_VAR 0 4
82609: PPUSH
82610: LD_VAR 0 7
82614: PPUSH
82615: CALL_OW 3
82619: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82620: LD_ADDR_VAR 0 16
82624: PUSH
82625: LD_VAR 0 16
82629: PPUSH
82630: LD_VAR 0 7
82634: PPUSH
82635: CALL_OW 3
82639: ST_TO_ADDR
// continue ;
82640: GO 82480
// end ; if f_repair then
82642: LD_VAR 0 22
82646: IFFALSE 83135
// begin if GetType ( group [ i ] ) = unit_vehicle then
82648: LD_VAR 0 4
82652: PUSH
82653: LD_VAR 0 7
82657: ARRAY
82658: PPUSH
82659: CALL_OW 247
82663: PUSH
82664: LD_INT 2
82666: EQUAL
82667: IFFALSE 82857
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82669: LD_VAR 0 4
82673: PUSH
82674: LD_VAR 0 7
82678: ARRAY
82679: PPUSH
82680: CALL_OW 256
82684: PUSH
82685: LD_INT 700
82687: LESS
82688: PUSH
82689: LD_VAR 0 4
82693: PUSH
82694: LD_VAR 0 7
82698: ARRAY
82699: PUSH
82700: LD_VAR 0 32
82704: IN
82705: NOT
82706: AND
82707: IFFALSE 82731
// to_repair := to_repair union group [ i ] ;
82709: LD_ADDR_VAR 0 32
82713: PUSH
82714: LD_VAR 0 32
82718: PUSH
82719: LD_VAR 0 4
82723: PUSH
82724: LD_VAR 0 7
82728: ARRAY
82729: UNION
82730: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82731: LD_VAR 0 4
82735: PUSH
82736: LD_VAR 0 7
82740: ARRAY
82741: PPUSH
82742: CALL_OW 256
82746: PUSH
82747: LD_INT 1000
82749: EQUAL
82750: PUSH
82751: LD_VAR 0 4
82755: PUSH
82756: LD_VAR 0 7
82760: ARRAY
82761: PUSH
82762: LD_VAR 0 32
82766: IN
82767: AND
82768: IFFALSE 82792
// to_repair := to_repair diff group [ i ] ;
82770: LD_ADDR_VAR 0 32
82774: PUSH
82775: LD_VAR 0 32
82779: PUSH
82780: LD_VAR 0 4
82784: PUSH
82785: LD_VAR 0 7
82789: ARRAY
82790: DIFF
82791: ST_TO_ADDR
// if group [ i ] in to_repair then
82792: LD_VAR 0 4
82796: PUSH
82797: LD_VAR 0 7
82801: ARRAY
82802: PUSH
82803: LD_VAR 0 32
82807: IN
82808: IFFALSE 82855
// begin if not IsInArea ( group [ i ] , f_repair ) then
82810: LD_VAR 0 4
82814: PUSH
82815: LD_VAR 0 7
82819: ARRAY
82820: PPUSH
82821: LD_VAR 0 22
82825: PPUSH
82826: CALL_OW 308
82830: NOT
82831: IFFALSE 82853
// ComMoveToArea ( group [ i ] , f_repair ) ;
82833: LD_VAR 0 4
82837: PUSH
82838: LD_VAR 0 7
82842: ARRAY
82843: PPUSH
82844: LD_VAR 0 22
82848: PPUSH
82849: CALL_OW 113
// continue ;
82853: GO 82480
// end ; end else
82855: GO 83135
// if group [ i ] in repairs then
82857: LD_VAR 0 4
82861: PUSH
82862: LD_VAR 0 7
82866: ARRAY
82867: PUSH
82868: LD_VAR 0 33
82872: IN
82873: IFFALSE 83135
// begin if IsInUnit ( group [ i ] ) then
82875: LD_VAR 0 4
82879: PUSH
82880: LD_VAR 0 7
82884: ARRAY
82885: PPUSH
82886: CALL_OW 310
82890: IFFALSE 82958
// begin z := IsInUnit ( group [ i ] ) ;
82892: LD_ADDR_VAR 0 13
82896: PUSH
82897: LD_VAR 0 4
82901: PUSH
82902: LD_VAR 0 7
82906: ARRAY
82907: PPUSH
82908: CALL_OW 310
82912: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82913: LD_VAR 0 13
82917: PUSH
82918: LD_VAR 0 32
82922: IN
82923: PUSH
82924: LD_VAR 0 13
82928: PPUSH
82929: LD_VAR 0 22
82933: PPUSH
82934: CALL_OW 308
82938: AND
82939: IFFALSE 82956
// ComExitVehicle ( group [ i ] ) ;
82941: LD_VAR 0 4
82945: PUSH
82946: LD_VAR 0 7
82950: ARRAY
82951: PPUSH
82952: CALL_OW 121
// end else
82956: GO 83135
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82958: LD_ADDR_VAR 0 13
82962: PUSH
82963: LD_VAR 0 4
82967: PPUSH
82968: LD_INT 95
82970: PUSH
82971: LD_VAR 0 22
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 58
82982: PUSH
82983: EMPTY
82984: LIST
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PPUSH
82990: CALL_OW 72
82994: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82995: LD_VAR 0 4
82999: PUSH
83000: LD_VAR 0 7
83004: ARRAY
83005: PPUSH
83006: CALL_OW 314
83010: NOT
83011: IFFALSE 83133
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83013: LD_ADDR_VAR 0 10
83017: PUSH
83018: LD_VAR 0 13
83022: PPUSH
83023: LD_VAR 0 4
83027: PUSH
83028: LD_VAR 0 7
83032: ARRAY
83033: PPUSH
83034: CALL_OW 74
83038: ST_TO_ADDR
// if not x then
83039: LD_VAR 0 10
83043: NOT
83044: IFFALSE 83048
// continue ;
83046: GO 82480
// if GetLives ( x ) < 1000 then
83048: LD_VAR 0 10
83052: PPUSH
83053: CALL_OW 256
83057: PUSH
83058: LD_INT 1000
83060: LESS
83061: IFFALSE 83085
// ComRepairVehicle ( group [ i ] , x ) else
83063: LD_VAR 0 4
83067: PUSH
83068: LD_VAR 0 7
83072: ARRAY
83073: PPUSH
83074: LD_VAR 0 10
83078: PPUSH
83079: CALL_OW 129
83083: GO 83133
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83085: LD_VAR 0 23
83089: PUSH
83090: LD_VAR 0 4
83094: PUSH
83095: LD_VAR 0 7
83099: ARRAY
83100: PPUSH
83101: CALL_OW 256
83105: PUSH
83106: LD_INT 1000
83108: LESS
83109: AND
83110: NOT
83111: IFFALSE 83133
// ComEnterUnit ( group [ i ] , x ) ;
83113: LD_VAR 0 4
83117: PUSH
83118: LD_VAR 0 7
83122: ARRAY
83123: PPUSH
83124: LD_VAR 0 10
83128: PPUSH
83129: CALL_OW 120
// end ; continue ;
83133: GO 82480
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83135: LD_VAR 0 23
83139: PUSH
83140: LD_VAR 0 4
83144: PUSH
83145: LD_VAR 0 7
83149: ARRAY
83150: PPUSH
83151: CALL_OW 247
83155: PUSH
83156: LD_INT 1
83158: EQUAL
83159: AND
83160: IFFALSE 83638
// begin if group [ i ] in healers then
83162: LD_VAR 0 4
83166: PUSH
83167: LD_VAR 0 7
83171: ARRAY
83172: PUSH
83173: LD_VAR 0 31
83177: IN
83178: IFFALSE 83451
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83180: LD_VAR 0 4
83184: PUSH
83185: LD_VAR 0 7
83189: ARRAY
83190: PPUSH
83191: LD_VAR 0 23
83195: PPUSH
83196: CALL_OW 308
83200: NOT
83201: PUSH
83202: LD_VAR 0 4
83206: PUSH
83207: LD_VAR 0 7
83211: ARRAY
83212: PPUSH
83213: CALL_OW 314
83217: NOT
83218: AND
83219: IFFALSE 83243
// ComMoveToArea ( group [ i ] , f_heal ) else
83221: LD_VAR 0 4
83225: PUSH
83226: LD_VAR 0 7
83230: ARRAY
83231: PPUSH
83232: LD_VAR 0 23
83236: PPUSH
83237: CALL_OW 113
83241: GO 83449
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83243: LD_VAR 0 4
83247: PUSH
83248: LD_VAR 0 7
83252: ARRAY
83253: PPUSH
83254: CALL 44672 0 1
83258: PPUSH
83259: CALL_OW 256
83263: PUSH
83264: LD_INT 1000
83266: EQUAL
83267: IFFALSE 83286
// ComStop ( group [ i ] ) else
83269: LD_VAR 0 4
83273: PUSH
83274: LD_VAR 0 7
83278: ARRAY
83279: PPUSH
83280: CALL_OW 141
83284: GO 83449
// if not HasTask ( group [ i ] ) and to_heal then
83286: LD_VAR 0 4
83290: PUSH
83291: LD_VAR 0 7
83295: ARRAY
83296: PPUSH
83297: CALL_OW 314
83301: NOT
83302: PUSH
83303: LD_VAR 0 30
83307: AND
83308: IFFALSE 83449
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83310: LD_ADDR_VAR 0 13
83314: PUSH
83315: LD_VAR 0 30
83319: PPUSH
83320: LD_INT 3
83322: PUSH
83323: LD_INT 54
83325: PUSH
83326: EMPTY
83327: LIST
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PPUSH
83333: CALL_OW 72
83337: PPUSH
83338: LD_VAR 0 4
83342: PUSH
83343: LD_VAR 0 7
83347: ARRAY
83348: PPUSH
83349: CALL_OW 74
83353: ST_TO_ADDR
// if z then
83354: LD_VAR 0 13
83358: IFFALSE 83449
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83360: LD_INT 91
83362: PUSH
83363: LD_VAR 0 13
83367: PUSH
83368: LD_INT 10
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 81
83378: PUSH
83379: LD_VAR 0 13
83383: PPUSH
83384: CALL_OW 255
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PPUSH
83397: CALL_OW 69
83401: PUSH
83402: LD_INT 0
83404: EQUAL
83405: IFFALSE 83429
// ComHeal ( group [ i ] , z ) else
83407: LD_VAR 0 4
83411: PUSH
83412: LD_VAR 0 7
83416: ARRAY
83417: PPUSH
83418: LD_VAR 0 13
83422: PPUSH
83423: CALL_OW 128
83427: GO 83449
// ComMoveToArea ( group [ i ] , f_heal ) ;
83429: LD_VAR 0 4
83433: PUSH
83434: LD_VAR 0 7
83438: ARRAY
83439: PPUSH
83440: LD_VAR 0 23
83444: PPUSH
83445: CALL_OW 113
// end ; continue ;
83449: GO 82480
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83451: LD_VAR 0 4
83455: PUSH
83456: LD_VAR 0 7
83460: ARRAY
83461: PPUSH
83462: CALL_OW 256
83466: PUSH
83467: LD_INT 700
83469: LESS
83470: PUSH
83471: LD_VAR 0 4
83475: PUSH
83476: LD_VAR 0 7
83480: ARRAY
83481: PUSH
83482: LD_VAR 0 30
83486: IN
83487: NOT
83488: AND
83489: IFFALSE 83513
// to_heal := to_heal union group [ i ] ;
83491: LD_ADDR_VAR 0 30
83495: PUSH
83496: LD_VAR 0 30
83500: PUSH
83501: LD_VAR 0 4
83505: PUSH
83506: LD_VAR 0 7
83510: ARRAY
83511: UNION
83512: ST_TO_ADDR
// if group [ i ] in to_heal then
83513: LD_VAR 0 4
83517: PUSH
83518: LD_VAR 0 7
83522: ARRAY
83523: PUSH
83524: LD_VAR 0 30
83528: IN
83529: IFFALSE 83638
// begin if GetLives ( group [ i ] ) = 1000 then
83531: LD_VAR 0 4
83535: PUSH
83536: LD_VAR 0 7
83540: ARRAY
83541: PPUSH
83542: CALL_OW 256
83546: PUSH
83547: LD_INT 1000
83549: EQUAL
83550: IFFALSE 83576
// to_heal := to_heal diff group [ i ] else
83552: LD_ADDR_VAR 0 30
83556: PUSH
83557: LD_VAR 0 30
83561: PUSH
83562: LD_VAR 0 4
83566: PUSH
83567: LD_VAR 0 7
83571: ARRAY
83572: DIFF
83573: ST_TO_ADDR
83574: GO 83638
// begin if not IsInArea ( group [ i ] , to_heal ) then
83576: LD_VAR 0 4
83580: PUSH
83581: LD_VAR 0 7
83585: ARRAY
83586: PPUSH
83587: LD_VAR 0 30
83591: PPUSH
83592: CALL_OW 308
83596: NOT
83597: IFFALSE 83621
// ComMoveToArea ( group [ i ] , f_heal ) else
83599: LD_VAR 0 4
83603: PUSH
83604: LD_VAR 0 7
83608: ARRAY
83609: PPUSH
83610: LD_VAR 0 23
83614: PPUSH
83615: CALL_OW 113
83619: GO 83636
// ComHold ( group [ i ] ) ;
83621: LD_VAR 0 4
83625: PUSH
83626: LD_VAR 0 7
83630: ARRAY
83631: PPUSH
83632: CALL_OW 140
// continue ;
83636: GO 82480
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83638: LD_VAR 0 4
83642: PUSH
83643: LD_VAR 0 7
83647: ARRAY
83648: PPUSH
83649: LD_INT 10
83651: PPUSH
83652: CALL 42443 0 2
83656: NOT
83657: PUSH
83658: LD_VAR 0 16
83662: PUSH
83663: LD_VAR 0 7
83667: ARRAY
83668: PUSH
83669: EMPTY
83670: EQUAL
83671: NOT
83672: AND
83673: IFFALSE 83939
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83675: LD_VAR 0 4
83679: PUSH
83680: LD_VAR 0 7
83684: ARRAY
83685: PPUSH
83686: CALL_OW 262
83690: PUSH
83691: LD_INT 1
83693: PUSH
83694: LD_INT 2
83696: PUSH
83697: EMPTY
83698: LIST
83699: LIST
83700: IN
83701: IFFALSE 83742
// if GetFuel ( group [ i ] ) < 10 then
83703: LD_VAR 0 4
83707: PUSH
83708: LD_VAR 0 7
83712: ARRAY
83713: PPUSH
83714: CALL_OW 261
83718: PUSH
83719: LD_INT 10
83721: LESS
83722: IFFALSE 83742
// SetFuel ( group [ i ] , 12 ) ;
83724: LD_VAR 0 4
83728: PUSH
83729: LD_VAR 0 7
83733: ARRAY
83734: PPUSH
83735: LD_INT 12
83737: PPUSH
83738: CALL_OW 240
// if units_path [ i ] then
83742: LD_VAR 0 16
83746: PUSH
83747: LD_VAR 0 7
83751: ARRAY
83752: IFFALSE 83937
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83754: LD_VAR 0 4
83758: PUSH
83759: LD_VAR 0 7
83763: ARRAY
83764: PPUSH
83765: LD_VAR 0 16
83769: PUSH
83770: LD_VAR 0 7
83774: ARRAY
83775: PUSH
83776: LD_INT 1
83778: ARRAY
83779: PUSH
83780: LD_INT 1
83782: ARRAY
83783: PPUSH
83784: LD_VAR 0 16
83788: PUSH
83789: LD_VAR 0 7
83793: ARRAY
83794: PUSH
83795: LD_INT 1
83797: ARRAY
83798: PUSH
83799: LD_INT 2
83801: ARRAY
83802: PPUSH
83803: CALL_OW 297
83807: PUSH
83808: LD_INT 6
83810: GREATER
83811: IFFALSE 83886
// begin if not HasTask ( group [ i ] ) then
83813: LD_VAR 0 4
83817: PUSH
83818: LD_VAR 0 7
83822: ARRAY
83823: PPUSH
83824: CALL_OW 314
83828: NOT
83829: IFFALSE 83884
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83831: LD_VAR 0 4
83835: PUSH
83836: LD_VAR 0 7
83840: ARRAY
83841: PPUSH
83842: LD_VAR 0 16
83846: PUSH
83847: LD_VAR 0 7
83851: ARRAY
83852: PUSH
83853: LD_INT 1
83855: ARRAY
83856: PUSH
83857: LD_INT 1
83859: ARRAY
83860: PPUSH
83861: LD_VAR 0 16
83865: PUSH
83866: LD_VAR 0 7
83870: ARRAY
83871: PUSH
83872: LD_INT 1
83874: ARRAY
83875: PUSH
83876: LD_INT 2
83878: ARRAY
83879: PPUSH
83880: CALL_OW 114
// end else
83884: GO 83937
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83886: LD_ADDR_VAR 0 15
83890: PUSH
83891: LD_VAR 0 16
83895: PUSH
83896: LD_VAR 0 7
83900: ARRAY
83901: PPUSH
83902: LD_INT 1
83904: PPUSH
83905: CALL_OW 3
83909: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83910: LD_ADDR_VAR 0 16
83914: PUSH
83915: LD_VAR 0 16
83919: PPUSH
83920: LD_VAR 0 7
83924: PPUSH
83925: LD_VAR 0 15
83929: PPUSH
83930: CALL_OW 1
83934: ST_TO_ADDR
// continue ;
83935: GO 82480
// end ; end ; end else
83937: GO 86601
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83939: LD_ADDR_VAR 0 14
83943: PUSH
83944: LD_INT 81
83946: PUSH
83947: LD_VAR 0 4
83951: PUSH
83952: LD_VAR 0 7
83956: ARRAY
83957: PPUSH
83958: CALL_OW 255
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PPUSH
83967: CALL_OW 69
83971: ST_TO_ADDR
// if not tmp then
83972: LD_VAR 0 14
83976: NOT
83977: IFFALSE 83981
// continue ;
83979: GO 82480
// if f_ignore_area then
83981: LD_VAR 0 17
83985: IFFALSE 84073
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83987: LD_ADDR_VAR 0 15
83991: PUSH
83992: LD_VAR 0 14
83996: PPUSH
83997: LD_INT 3
83999: PUSH
84000: LD_INT 92
84002: PUSH
84003: LD_VAR 0 17
84007: PUSH
84008: LD_INT 1
84010: ARRAY
84011: PUSH
84012: LD_VAR 0 17
84016: PUSH
84017: LD_INT 2
84019: ARRAY
84020: PUSH
84021: LD_VAR 0 17
84025: PUSH
84026: LD_INT 3
84028: ARRAY
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PPUSH
84040: CALL_OW 72
84044: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84045: LD_VAR 0 14
84049: PUSH
84050: LD_VAR 0 15
84054: DIFF
84055: IFFALSE 84073
// tmp := tmp diff tmp2 ;
84057: LD_ADDR_VAR 0 14
84061: PUSH
84062: LD_VAR 0 14
84066: PUSH
84067: LD_VAR 0 15
84071: DIFF
84072: ST_TO_ADDR
// end ; if not f_murder then
84073: LD_VAR 0 20
84077: NOT
84078: IFFALSE 84136
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84080: LD_ADDR_VAR 0 15
84084: PUSH
84085: LD_VAR 0 14
84089: PPUSH
84090: LD_INT 3
84092: PUSH
84093: LD_INT 50
84095: PUSH
84096: EMPTY
84097: LIST
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PPUSH
84103: CALL_OW 72
84107: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84108: LD_VAR 0 14
84112: PUSH
84113: LD_VAR 0 15
84117: DIFF
84118: IFFALSE 84136
// tmp := tmp diff tmp2 ;
84120: LD_ADDR_VAR 0 14
84124: PUSH
84125: LD_VAR 0 14
84129: PUSH
84130: LD_VAR 0 15
84134: DIFF
84135: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84136: LD_ADDR_VAR 0 14
84140: PUSH
84141: LD_VAR 0 4
84145: PUSH
84146: LD_VAR 0 7
84150: ARRAY
84151: PPUSH
84152: LD_VAR 0 14
84156: PPUSH
84157: LD_INT 1
84159: PPUSH
84160: LD_INT 1
84162: PPUSH
84163: CALL 15384 0 4
84167: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84168: LD_VAR 0 4
84172: PUSH
84173: LD_VAR 0 7
84177: ARRAY
84178: PPUSH
84179: CALL_OW 257
84183: PUSH
84184: LD_INT 1
84186: EQUAL
84187: IFFALSE 84635
// begin if WantPlant ( group [ i ] ) then
84189: LD_VAR 0 4
84193: PUSH
84194: LD_VAR 0 7
84198: ARRAY
84199: PPUSH
84200: CALL 14885 0 1
84204: IFFALSE 84208
// continue ;
84206: GO 82480
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84208: LD_VAR 0 18
84212: PUSH
84213: LD_VAR 0 4
84217: PUSH
84218: LD_VAR 0 7
84222: ARRAY
84223: PPUSH
84224: CALL_OW 310
84228: NOT
84229: AND
84230: PUSH
84231: LD_VAR 0 14
84235: PUSH
84236: LD_INT 1
84238: ARRAY
84239: PUSH
84240: LD_VAR 0 14
84244: PPUSH
84245: LD_INT 21
84247: PUSH
84248: LD_INT 2
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 58
84257: PUSH
84258: EMPTY
84259: LIST
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PPUSH
84265: CALL_OW 72
84269: IN
84270: AND
84271: IFFALSE 84307
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84273: LD_VAR 0 4
84277: PUSH
84278: LD_VAR 0 7
84282: ARRAY
84283: PPUSH
84284: LD_VAR 0 14
84288: PUSH
84289: LD_INT 1
84291: ARRAY
84292: PPUSH
84293: CALL_OW 120
// attacking := true ;
84297: LD_ADDR_VAR 0 29
84301: PUSH
84302: LD_INT 1
84304: ST_TO_ADDR
// continue ;
84305: GO 82480
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84307: LD_VAR 0 26
84311: PUSH
84312: LD_VAR 0 4
84316: PUSH
84317: LD_VAR 0 7
84321: ARRAY
84322: PPUSH
84323: CALL_OW 257
84327: PUSH
84328: LD_INT 1
84330: EQUAL
84331: AND
84332: PUSH
84333: LD_VAR 0 4
84337: PUSH
84338: LD_VAR 0 7
84342: ARRAY
84343: PPUSH
84344: CALL_OW 256
84348: PUSH
84349: LD_INT 800
84351: LESS
84352: AND
84353: PUSH
84354: LD_VAR 0 4
84358: PUSH
84359: LD_VAR 0 7
84363: ARRAY
84364: PPUSH
84365: CALL_OW 318
84369: NOT
84370: AND
84371: IFFALSE 84388
// ComCrawl ( group [ i ] ) ;
84373: LD_VAR 0 4
84377: PUSH
84378: LD_VAR 0 7
84382: ARRAY
84383: PPUSH
84384: CALL_OW 137
// if f_mines then
84388: LD_VAR 0 21
84392: IFFALSE 84635
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84394: LD_VAR 0 14
84398: PUSH
84399: LD_INT 1
84401: ARRAY
84402: PPUSH
84403: CALL_OW 247
84407: PUSH
84408: LD_INT 3
84410: EQUAL
84411: PUSH
84412: LD_VAR 0 14
84416: PUSH
84417: LD_INT 1
84419: ARRAY
84420: PUSH
84421: LD_VAR 0 27
84425: IN
84426: NOT
84427: AND
84428: IFFALSE 84635
// begin x := GetX ( tmp [ 1 ] ) ;
84430: LD_ADDR_VAR 0 10
84434: PUSH
84435: LD_VAR 0 14
84439: PUSH
84440: LD_INT 1
84442: ARRAY
84443: PPUSH
84444: CALL_OW 250
84448: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84449: LD_ADDR_VAR 0 11
84453: PUSH
84454: LD_VAR 0 14
84458: PUSH
84459: LD_INT 1
84461: ARRAY
84462: PPUSH
84463: CALL_OW 251
84467: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84468: LD_ADDR_VAR 0 12
84472: PUSH
84473: LD_VAR 0 4
84477: PUSH
84478: LD_VAR 0 7
84482: ARRAY
84483: PPUSH
84484: CALL 42528 0 1
84488: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84489: LD_VAR 0 4
84493: PUSH
84494: LD_VAR 0 7
84498: ARRAY
84499: PPUSH
84500: LD_VAR 0 10
84504: PPUSH
84505: LD_VAR 0 11
84509: PPUSH
84510: LD_VAR 0 14
84514: PUSH
84515: LD_INT 1
84517: ARRAY
84518: PPUSH
84519: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84523: LD_VAR 0 4
84527: PUSH
84528: LD_VAR 0 7
84532: ARRAY
84533: PPUSH
84534: LD_VAR 0 10
84538: PPUSH
84539: LD_VAR 0 12
84543: PPUSH
84544: LD_INT 7
84546: PPUSH
84547: CALL_OW 272
84551: PPUSH
84552: LD_VAR 0 11
84556: PPUSH
84557: LD_VAR 0 12
84561: PPUSH
84562: LD_INT 7
84564: PPUSH
84565: CALL_OW 273
84569: PPUSH
84570: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84574: LD_VAR 0 4
84578: PUSH
84579: LD_VAR 0 7
84583: ARRAY
84584: PPUSH
84585: LD_INT 71
84587: PPUSH
84588: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84592: LD_ADDR_VAR 0 27
84596: PUSH
84597: LD_VAR 0 27
84601: PPUSH
84602: LD_VAR 0 27
84606: PUSH
84607: LD_INT 1
84609: PLUS
84610: PPUSH
84611: LD_VAR 0 14
84615: PUSH
84616: LD_INT 1
84618: ARRAY
84619: PPUSH
84620: CALL_OW 1
84624: ST_TO_ADDR
// attacking := true ;
84625: LD_ADDR_VAR 0 29
84629: PUSH
84630: LD_INT 1
84632: ST_TO_ADDR
// continue ;
84633: GO 82480
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84635: LD_VAR 0 4
84639: PUSH
84640: LD_VAR 0 7
84644: ARRAY
84645: PPUSH
84646: CALL_OW 257
84650: PUSH
84651: LD_INT 17
84653: EQUAL
84654: PUSH
84655: LD_VAR 0 4
84659: PUSH
84660: LD_VAR 0 7
84664: ARRAY
84665: PPUSH
84666: CALL_OW 110
84670: PUSH
84671: LD_INT 71
84673: EQUAL
84674: NOT
84675: AND
84676: IFFALSE 84822
// begin attacking := false ;
84678: LD_ADDR_VAR 0 29
84682: PUSH
84683: LD_INT 0
84685: ST_TO_ADDR
// k := 5 ;
84686: LD_ADDR_VAR 0 9
84690: PUSH
84691: LD_INT 5
84693: ST_TO_ADDR
// if tmp < k then
84694: LD_VAR 0 14
84698: PUSH
84699: LD_VAR 0 9
84703: LESS
84704: IFFALSE 84716
// k := tmp ;
84706: LD_ADDR_VAR 0 9
84710: PUSH
84711: LD_VAR 0 14
84715: ST_TO_ADDR
// for j = 1 to k do
84716: LD_ADDR_VAR 0 8
84720: PUSH
84721: DOUBLE
84722: LD_INT 1
84724: DEC
84725: ST_TO_ADDR
84726: LD_VAR 0 9
84730: PUSH
84731: FOR_TO
84732: IFFALSE 84820
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84734: LD_VAR 0 14
84738: PUSH
84739: LD_VAR 0 8
84743: ARRAY
84744: PUSH
84745: LD_VAR 0 14
84749: PPUSH
84750: LD_INT 58
84752: PUSH
84753: EMPTY
84754: LIST
84755: PPUSH
84756: CALL_OW 72
84760: IN
84761: NOT
84762: IFFALSE 84818
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84764: LD_VAR 0 4
84768: PUSH
84769: LD_VAR 0 7
84773: ARRAY
84774: PPUSH
84775: LD_VAR 0 14
84779: PUSH
84780: LD_VAR 0 8
84784: ARRAY
84785: PPUSH
84786: CALL_OW 115
// attacking := true ;
84790: LD_ADDR_VAR 0 29
84794: PUSH
84795: LD_INT 1
84797: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84798: LD_VAR 0 4
84802: PUSH
84803: LD_VAR 0 7
84807: ARRAY
84808: PPUSH
84809: LD_INT 71
84811: PPUSH
84812: CALL_OW 109
// continue ;
84816: GO 84731
// end ; end ;
84818: GO 84731
84820: POP
84821: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84822: LD_VAR 0 4
84826: PUSH
84827: LD_VAR 0 7
84831: ARRAY
84832: PPUSH
84833: CALL_OW 257
84837: PUSH
84838: LD_INT 8
84840: EQUAL
84841: PUSH
84842: LD_VAR 0 4
84846: PUSH
84847: LD_VAR 0 7
84851: ARRAY
84852: PPUSH
84853: CALL_OW 264
84857: PUSH
84858: LD_INT 28
84860: PUSH
84861: LD_INT 45
84863: PUSH
84864: LD_INT 7
84866: PUSH
84867: LD_INT 47
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: IN
84876: OR
84877: IFFALSE 85133
// begin attacking := false ;
84879: LD_ADDR_VAR 0 29
84883: PUSH
84884: LD_INT 0
84886: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84887: LD_VAR 0 14
84891: PUSH
84892: LD_INT 1
84894: ARRAY
84895: PPUSH
84896: CALL_OW 266
84900: PUSH
84901: LD_INT 32
84903: PUSH
84904: LD_INT 31
84906: PUSH
84907: LD_INT 33
84909: PUSH
84910: LD_INT 4
84912: PUSH
84913: LD_INT 5
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: IN
84923: IFFALSE 85109
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84925: LD_ADDR_VAR 0 9
84929: PUSH
84930: LD_VAR 0 14
84934: PUSH
84935: LD_INT 1
84937: ARRAY
84938: PPUSH
84939: CALL_OW 266
84943: PPUSH
84944: LD_VAR 0 14
84948: PUSH
84949: LD_INT 1
84951: ARRAY
84952: PPUSH
84953: CALL_OW 250
84957: PPUSH
84958: LD_VAR 0 14
84962: PUSH
84963: LD_INT 1
84965: ARRAY
84966: PPUSH
84967: CALL_OW 251
84971: PPUSH
84972: LD_VAR 0 14
84976: PUSH
84977: LD_INT 1
84979: ARRAY
84980: PPUSH
84981: CALL_OW 254
84985: PPUSH
84986: LD_VAR 0 14
84990: PUSH
84991: LD_INT 1
84993: ARRAY
84994: PPUSH
84995: CALL_OW 248
84999: PPUSH
85000: LD_INT 0
85002: PPUSH
85003: CALL 23898 0 6
85007: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85008: LD_ADDR_VAR 0 8
85012: PUSH
85013: LD_VAR 0 4
85017: PUSH
85018: LD_VAR 0 7
85022: ARRAY
85023: PPUSH
85024: LD_VAR 0 9
85028: PPUSH
85029: CALL 42641 0 2
85033: ST_TO_ADDR
// if j then
85034: LD_VAR 0 8
85038: IFFALSE 85107
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85040: LD_VAR 0 8
85044: PUSH
85045: LD_INT 1
85047: ARRAY
85048: PPUSH
85049: LD_VAR 0 8
85053: PUSH
85054: LD_INT 2
85056: ARRAY
85057: PPUSH
85058: CALL_OW 488
85062: IFFALSE 85107
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85064: LD_VAR 0 4
85068: PUSH
85069: LD_VAR 0 7
85073: ARRAY
85074: PPUSH
85075: LD_VAR 0 8
85079: PUSH
85080: LD_INT 1
85082: ARRAY
85083: PPUSH
85084: LD_VAR 0 8
85088: PUSH
85089: LD_INT 2
85091: ARRAY
85092: PPUSH
85093: CALL_OW 116
// attacking := true ;
85097: LD_ADDR_VAR 0 29
85101: PUSH
85102: LD_INT 1
85104: ST_TO_ADDR
// continue ;
85105: GO 82480
// end ; end else
85107: GO 85133
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85109: LD_VAR 0 4
85113: PUSH
85114: LD_VAR 0 7
85118: ARRAY
85119: PPUSH
85120: LD_VAR 0 14
85124: PUSH
85125: LD_INT 1
85127: ARRAY
85128: PPUSH
85129: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85133: LD_VAR 0 4
85137: PUSH
85138: LD_VAR 0 7
85142: ARRAY
85143: PPUSH
85144: CALL_OW 265
85148: PUSH
85149: LD_INT 11
85151: EQUAL
85152: IFFALSE 85430
// begin k := 10 ;
85154: LD_ADDR_VAR 0 9
85158: PUSH
85159: LD_INT 10
85161: ST_TO_ADDR
// x := 0 ;
85162: LD_ADDR_VAR 0 10
85166: PUSH
85167: LD_INT 0
85169: ST_TO_ADDR
// if tmp < k then
85170: LD_VAR 0 14
85174: PUSH
85175: LD_VAR 0 9
85179: LESS
85180: IFFALSE 85192
// k := tmp ;
85182: LD_ADDR_VAR 0 9
85186: PUSH
85187: LD_VAR 0 14
85191: ST_TO_ADDR
// for j = k downto 1 do
85192: LD_ADDR_VAR 0 8
85196: PUSH
85197: DOUBLE
85198: LD_VAR 0 9
85202: INC
85203: ST_TO_ADDR
85204: LD_INT 1
85206: PUSH
85207: FOR_DOWNTO
85208: IFFALSE 85283
// begin if GetType ( tmp [ j ] ) = unit_human then
85210: LD_VAR 0 14
85214: PUSH
85215: LD_VAR 0 8
85219: ARRAY
85220: PPUSH
85221: CALL_OW 247
85225: PUSH
85226: LD_INT 1
85228: EQUAL
85229: IFFALSE 85281
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85231: LD_VAR 0 4
85235: PUSH
85236: LD_VAR 0 7
85240: ARRAY
85241: PPUSH
85242: LD_VAR 0 14
85246: PUSH
85247: LD_VAR 0 8
85251: ARRAY
85252: PPUSH
85253: CALL 42895 0 2
// x := tmp [ j ] ;
85257: LD_ADDR_VAR 0 10
85261: PUSH
85262: LD_VAR 0 14
85266: PUSH
85267: LD_VAR 0 8
85271: ARRAY
85272: ST_TO_ADDR
// attacking := true ;
85273: LD_ADDR_VAR 0 29
85277: PUSH
85278: LD_INT 1
85280: ST_TO_ADDR
// end ; end ;
85281: GO 85207
85283: POP
85284: POP
// if not x then
85285: LD_VAR 0 10
85289: NOT
85290: IFFALSE 85430
// begin attacking := true ;
85292: LD_ADDR_VAR 0 29
85296: PUSH
85297: LD_INT 1
85299: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85300: LD_VAR 0 4
85304: PUSH
85305: LD_VAR 0 7
85309: ARRAY
85310: PPUSH
85311: CALL_OW 250
85315: PPUSH
85316: LD_VAR 0 4
85320: PUSH
85321: LD_VAR 0 7
85325: ARRAY
85326: PPUSH
85327: CALL_OW 251
85331: PPUSH
85332: CALL_OW 546
85336: PUSH
85337: LD_INT 2
85339: ARRAY
85340: PUSH
85341: LD_VAR 0 14
85345: PUSH
85346: LD_INT 1
85348: ARRAY
85349: PPUSH
85350: CALL_OW 250
85354: PPUSH
85355: LD_VAR 0 14
85359: PUSH
85360: LD_INT 1
85362: ARRAY
85363: PPUSH
85364: CALL_OW 251
85368: PPUSH
85369: CALL_OW 546
85373: PUSH
85374: LD_INT 2
85376: ARRAY
85377: EQUAL
85378: IFFALSE 85406
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85380: LD_VAR 0 4
85384: PUSH
85385: LD_VAR 0 7
85389: ARRAY
85390: PPUSH
85391: LD_VAR 0 14
85395: PUSH
85396: LD_INT 1
85398: ARRAY
85399: PPUSH
85400: CALL 42895 0 2
85404: GO 85430
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85406: LD_VAR 0 4
85410: PUSH
85411: LD_VAR 0 7
85415: ARRAY
85416: PPUSH
85417: LD_VAR 0 14
85421: PUSH
85422: LD_INT 1
85424: ARRAY
85425: PPUSH
85426: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85430: LD_VAR 0 4
85434: PUSH
85435: LD_VAR 0 7
85439: ARRAY
85440: PPUSH
85441: CALL_OW 264
85445: PUSH
85446: LD_INT 29
85448: EQUAL
85449: IFFALSE 85815
// begin if WantsToAttack ( group [ i ] ) in bombed then
85451: LD_VAR 0 4
85455: PUSH
85456: LD_VAR 0 7
85460: ARRAY
85461: PPUSH
85462: CALL_OW 319
85466: PUSH
85467: LD_VAR 0 28
85471: IN
85472: IFFALSE 85476
// continue ;
85474: GO 82480
// k := 8 ;
85476: LD_ADDR_VAR 0 9
85480: PUSH
85481: LD_INT 8
85483: ST_TO_ADDR
// x := 0 ;
85484: LD_ADDR_VAR 0 10
85488: PUSH
85489: LD_INT 0
85491: ST_TO_ADDR
// if tmp < k then
85492: LD_VAR 0 14
85496: PUSH
85497: LD_VAR 0 9
85501: LESS
85502: IFFALSE 85514
// k := tmp ;
85504: LD_ADDR_VAR 0 9
85508: PUSH
85509: LD_VAR 0 14
85513: ST_TO_ADDR
// for j = 1 to k do
85514: LD_ADDR_VAR 0 8
85518: PUSH
85519: DOUBLE
85520: LD_INT 1
85522: DEC
85523: ST_TO_ADDR
85524: LD_VAR 0 9
85528: PUSH
85529: FOR_TO
85530: IFFALSE 85662
// begin if GetType ( tmp [ j ] ) = unit_building then
85532: LD_VAR 0 14
85536: PUSH
85537: LD_VAR 0 8
85541: ARRAY
85542: PPUSH
85543: CALL_OW 247
85547: PUSH
85548: LD_INT 3
85550: EQUAL
85551: IFFALSE 85660
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85553: LD_VAR 0 14
85557: PUSH
85558: LD_VAR 0 8
85562: ARRAY
85563: PUSH
85564: LD_VAR 0 28
85568: IN
85569: NOT
85570: PUSH
85571: LD_VAR 0 14
85575: PUSH
85576: LD_VAR 0 8
85580: ARRAY
85581: PPUSH
85582: CALL_OW 313
85586: AND
85587: IFFALSE 85660
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85589: LD_VAR 0 4
85593: PUSH
85594: LD_VAR 0 7
85598: ARRAY
85599: PPUSH
85600: LD_VAR 0 14
85604: PUSH
85605: LD_VAR 0 8
85609: ARRAY
85610: PPUSH
85611: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85615: LD_ADDR_VAR 0 28
85619: PUSH
85620: LD_VAR 0 28
85624: PPUSH
85625: LD_VAR 0 28
85629: PUSH
85630: LD_INT 1
85632: PLUS
85633: PPUSH
85634: LD_VAR 0 14
85638: PUSH
85639: LD_VAR 0 8
85643: ARRAY
85644: PPUSH
85645: CALL_OW 1
85649: ST_TO_ADDR
// attacking := true ;
85650: LD_ADDR_VAR 0 29
85654: PUSH
85655: LD_INT 1
85657: ST_TO_ADDR
// break ;
85658: GO 85662
// end ; end ;
85660: GO 85529
85662: POP
85663: POP
// if not attacking and f_attack_depot then
85664: LD_VAR 0 29
85668: NOT
85669: PUSH
85670: LD_VAR 0 25
85674: AND
85675: IFFALSE 85770
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85677: LD_ADDR_VAR 0 13
85681: PUSH
85682: LD_VAR 0 14
85686: PPUSH
85687: LD_INT 2
85689: PUSH
85690: LD_INT 30
85692: PUSH
85693: LD_INT 0
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 30
85702: PUSH
85703: LD_INT 1
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: LIST
85714: PPUSH
85715: CALL_OW 72
85719: ST_TO_ADDR
// if z then
85720: LD_VAR 0 13
85724: IFFALSE 85770
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85726: LD_VAR 0 4
85730: PUSH
85731: LD_VAR 0 7
85735: ARRAY
85736: PPUSH
85737: LD_VAR 0 13
85741: PPUSH
85742: LD_VAR 0 4
85746: PUSH
85747: LD_VAR 0 7
85751: ARRAY
85752: PPUSH
85753: CALL_OW 74
85757: PPUSH
85758: CALL_OW 115
// attacking := true ;
85762: LD_ADDR_VAR 0 29
85766: PUSH
85767: LD_INT 1
85769: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85770: LD_VAR 0 4
85774: PUSH
85775: LD_VAR 0 7
85779: ARRAY
85780: PPUSH
85781: CALL_OW 256
85785: PUSH
85786: LD_INT 500
85788: LESS
85789: IFFALSE 85815
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85791: LD_VAR 0 4
85795: PUSH
85796: LD_VAR 0 7
85800: ARRAY
85801: PPUSH
85802: LD_VAR 0 14
85806: PUSH
85807: LD_INT 1
85809: ARRAY
85810: PPUSH
85811: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85815: LD_VAR 0 4
85819: PUSH
85820: LD_VAR 0 7
85824: ARRAY
85825: PPUSH
85826: CALL_OW 264
85830: PUSH
85831: LD_INT 49
85833: EQUAL
85834: IFFALSE 85955
// begin if not HasTask ( group [ i ] ) then
85836: LD_VAR 0 4
85840: PUSH
85841: LD_VAR 0 7
85845: ARRAY
85846: PPUSH
85847: CALL_OW 314
85851: NOT
85852: IFFALSE 85955
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85854: LD_ADDR_VAR 0 9
85858: PUSH
85859: LD_INT 81
85861: PUSH
85862: LD_VAR 0 4
85866: PUSH
85867: LD_VAR 0 7
85871: ARRAY
85872: PPUSH
85873: CALL_OW 255
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PPUSH
85882: CALL_OW 69
85886: PPUSH
85887: LD_VAR 0 4
85891: PUSH
85892: LD_VAR 0 7
85896: ARRAY
85897: PPUSH
85898: CALL_OW 74
85902: ST_TO_ADDR
// if k then
85903: LD_VAR 0 9
85907: IFFALSE 85955
// if GetDistUnits ( group [ i ] , k ) > 10 then
85909: LD_VAR 0 4
85913: PUSH
85914: LD_VAR 0 7
85918: ARRAY
85919: PPUSH
85920: LD_VAR 0 9
85924: PPUSH
85925: CALL_OW 296
85929: PUSH
85930: LD_INT 10
85932: GREATER
85933: IFFALSE 85955
// ComMoveUnit ( group [ i ] , k ) ;
85935: LD_VAR 0 4
85939: PUSH
85940: LD_VAR 0 7
85944: ARRAY
85945: PPUSH
85946: LD_VAR 0 9
85950: PPUSH
85951: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85955: LD_VAR 0 4
85959: PUSH
85960: LD_VAR 0 7
85964: ARRAY
85965: PPUSH
85966: CALL_OW 256
85970: PUSH
85971: LD_INT 250
85973: LESS
85974: PUSH
85975: LD_VAR 0 4
85979: PUSH
85980: LD_VAR 0 7
85984: ARRAY
85985: PUSH
85986: LD_INT 21
85988: PUSH
85989: LD_INT 2
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 23
85998: PUSH
85999: LD_INT 2
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PPUSH
86010: CALL_OW 69
86014: IN
86015: AND
86016: IFFALSE 86141
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86018: LD_ADDR_VAR 0 9
86022: PUSH
86023: LD_OWVAR 3
86027: PUSH
86028: LD_VAR 0 4
86032: PUSH
86033: LD_VAR 0 7
86037: ARRAY
86038: DIFF
86039: PPUSH
86040: LD_VAR 0 4
86044: PUSH
86045: LD_VAR 0 7
86049: ARRAY
86050: PPUSH
86051: CALL_OW 74
86055: ST_TO_ADDR
// if not k then
86056: LD_VAR 0 9
86060: NOT
86061: IFFALSE 86065
// continue ;
86063: GO 82480
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86065: LD_VAR 0 9
86069: PUSH
86070: LD_INT 81
86072: PUSH
86073: LD_VAR 0 4
86077: PUSH
86078: LD_VAR 0 7
86082: ARRAY
86083: PPUSH
86084: CALL_OW 255
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PPUSH
86093: CALL_OW 69
86097: IN
86098: PUSH
86099: LD_VAR 0 9
86103: PPUSH
86104: LD_VAR 0 4
86108: PUSH
86109: LD_VAR 0 7
86113: ARRAY
86114: PPUSH
86115: CALL_OW 296
86119: PUSH
86120: LD_INT 5
86122: LESS
86123: AND
86124: IFFALSE 86141
// ComAutodestruct ( group [ i ] ) ;
86126: LD_VAR 0 4
86130: PUSH
86131: LD_VAR 0 7
86135: ARRAY
86136: PPUSH
86137: CALL 42793 0 1
// end ; if f_attack_depot then
86141: LD_VAR 0 25
86145: IFFALSE 86257
// begin k := 6 ;
86147: LD_ADDR_VAR 0 9
86151: PUSH
86152: LD_INT 6
86154: ST_TO_ADDR
// if tmp < k then
86155: LD_VAR 0 14
86159: PUSH
86160: LD_VAR 0 9
86164: LESS
86165: IFFALSE 86177
// k := tmp ;
86167: LD_ADDR_VAR 0 9
86171: PUSH
86172: LD_VAR 0 14
86176: ST_TO_ADDR
// for j = 1 to k do
86177: LD_ADDR_VAR 0 8
86181: PUSH
86182: DOUBLE
86183: LD_INT 1
86185: DEC
86186: ST_TO_ADDR
86187: LD_VAR 0 9
86191: PUSH
86192: FOR_TO
86193: IFFALSE 86255
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86195: LD_VAR 0 8
86199: PPUSH
86200: CALL_OW 266
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: LD_INT 1
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: IN
86215: IFFALSE 86253
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86217: LD_VAR 0 4
86221: PUSH
86222: LD_VAR 0 7
86226: ARRAY
86227: PPUSH
86228: LD_VAR 0 14
86232: PUSH
86233: LD_VAR 0 8
86237: ARRAY
86238: PPUSH
86239: CALL_OW 115
// attacking := true ;
86243: LD_ADDR_VAR 0 29
86247: PUSH
86248: LD_INT 1
86250: ST_TO_ADDR
// break ;
86251: GO 86255
// end ;
86253: GO 86192
86255: POP
86256: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86257: LD_VAR 0 4
86261: PUSH
86262: LD_VAR 0 7
86266: ARRAY
86267: PPUSH
86268: CALL_OW 302
86272: PUSH
86273: LD_VAR 0 29
86277: NOT
86278: AND
86279: IFFALSE 86601
// begin if GetTag ( group [ i ] ) = 71 then
86281: LD_VAR 0 4
86285: PUSH
86286: LD_VAR 0 7
86290: ARRAY
86291: PPUSH
86292: CALL_OW 110
86296: PUSH
86297: LD_INT 71
86299: EQUAL
86300: IFFALSE 86341
// begin if HasTask ( group [ i ] ) then
86302: LD_VAR 0 4
86306: PUSH
86307: LD_VAR 0 7
86311: ARRAY
86312: PPUSH
86313: CALL_OW 314
86317: IFFALSE 86323
// continue else
86319: GO 82480
86321: GO 86341
// SetTag ( group [ i ] , 0 ) ;
86323: LD_VAR 0 4
86327: PUSH
86328: LD_VAR 0 7
86332: ARRAY
86333: PPUSH
86334: LD_INT 0
86336: PPUSH
86337: CALL_OW 109
// end ; k := 8 ;
86341: LD_ADDR_VAR 0 9
86345: PUSH
86346: LD_INT 8
86348: ST_TO_ADDR
// x := 0 ;
86349: LD_ADDR_VAR 0 10
86353: PUSH
86354: LD_INT 0
86356: ST_TO_ADDR
// if tmp < k then
86357: LD_VAR 0 14
86361: PUSH
86362: LD_VAR 0 9
86366: LESS
86367: IFFALSE 86379
// k := tmp ;
86369: LD_ADDR_VAR 0 9
86373: PUSH
86374: LD_VAR 0 14
86378: ST_TO_ADDR
// for j = 1 to k do
86379: LD_ADDR_VAR 0 8
86383: PUSH
86384: DOUBLE
86385: LD_INT 1
86387: DEC
86388: ST_TO_ADDR
86389: LD_VAR 0 9
86393: PUSH
86394: FOR_TO
86395: IFFALSE 86493
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86397: LD_VAR 0 14
86401: PUSH
86402: LD_VAR 0 8
86406: ARRAY
86407: PPUSH
86408: CALL_OW 247
86412: PUSH
86413: LD_INT 1
86415: EQUAL
86416: PUSH
86417: LD_VAR 0 14
86421: PUSH
86422: LD_VAR 0 8
86426: ARRAY
86427: PPUSH
86428: CALL_OW 256
86432: PUSH
86433: LD_INT 250
86435: LESS
86436: PUSH
86437: LD_VAR 0 20
86441: AND
86442: PUSH
86443: LD_VAR 0 20
86447: NOT
86448: PUSH
86449: LD_VAR 0 14
86453: PUSH
86454: LD_VAR 0 8
86458: ARRAY
86459: PPUSH
86460: CALL_OW 256
86464: PUSH
86465: LD_INT 250
86467: GREATEREQUAL
86468: AND
86469: OR
86470: AND
86471: IFFALSE 86491
// begin x := tmp [ j ] ;
86473: LD_ADDR_VAR 0 10
86477: PUSH
86478: LD_VAR 0 14
86482: PUSH
86483: LD_VAR 0 8
86487: ARRAY
86488: ST_TO_ADDR
// break ;
86489: GO 86493
// end ;
86491: GO 86394
86493: POP
86494: POP
// if x then
86495: LD_VAR 0 10
86499: IFFALSE 86523
// ComAttackUnit ( group [ i ] , x ) else
86501: LD_VAR 0 4
86505: PUSH
86506: LD_VAR 0 7
86510: ARRAY
86511: PPUSH
86512: LD_VAR 0 10
86516: PPUSH
86517: CALL_OW 115
86521: GO 86547
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86523: LD_VAR 0 4
86527: PUSH
86528: LD_VAR 0 7
86532: ARRAY
86533: PPUSH
86534: LD_VAR 0 14
86538: PUSH
86539: LD_INT 1
86541: ARRAY
86542: PPUSH
86543: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86547: LD_VAR 0 4
86551: PUSH
86552: LD_VAR 0 7
86556: ARRAY
86557: PPUSH
86558: CALL_OW 314
86562: NOT
86563: IFFALSE 86601
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86565: LD_VAR 0 4
86569: PUSH
86570: LD_VAR 0 7
86574: ARRAY
86575: PPUSH
86576: LD_VAR 0 14
86580: PPUSH
86581: LD_VAR 0 4
86585: PUSH
86586: LD_VAR 0 7
86590: ARRAY
86591: PPUSH
86592: CALL_OW 74
86596: PPUSH
86597: CALL_OW 115
// end ; end ; end ;
86601: GO 82480
86603: POP
86604: POP
// wait ( 0 0$2 ) ;
86605: LD_INT 70
86607: PPUSH
86608: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86612: LD_VAR 0 4
86616: NOT
86617: PUSH
86618: LD_VAR 0 4
86622: PUSH
86623: EMPTY
86624: EQUAL
86625: OR
86626: PUSH
86627: LD_INT 81
86629: PUSH
86630: LD_VAR 0 35
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PPUSH
86639: CALL_OW 69
86643: NOT
86644: OR
86645: IFFALSE 82465
// end ;
86647: LD_VAR 0 2
86651: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86652: LD_INT 0
86654: PPUSH
86655: PPUSH
86656: PPUSH
86657: PPUSH
86658: PPUSH
86659: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86660: LD_VAR 0 1
86664: NOT
86665: PUSH
86666: LD_EXP 43
86670: PUSH
86671: LD_VAR 0 1
86675: ARRAY
86676: NOT
86677: OR
86678: PUSH
86679: LD_VAR 0 2
86683: NOT
86684: OR
86685: IFFALSE 86689
// exit ;
86687: GO 87243
// side := mc_sides [ base ] ;
86689: LD_ADDR_VAR 0 6
86693: PUSH
86694: LD_EXP 69
86698: PUSH
86699: LD_VAR 0 1
86703: ARRAY
86704: ST_TO_ADDR
// if not side then
86705: LD_VAR 0 6
86709: NOT
86710: IFFALSE 86714
// exit ;
86712: GO 87243
// for i in solds do
86714: LD_ADDR_VAR 0 7
86718: PUSH
86719: LD_VAR 0 2
86723: PUSH
86724: FOR_IN
86725: IFFALSE 86786
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86727: LD_VAR 0 7
86731: PPUSH
86732: CALL_OW 310
86736: PPUSH
86737: CALL_OW 266
86741: PUSH
86742: LD_INT 32
86744: PUSH
86745: LD_INT 31
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: IN
86752: IFFALSE 86772
// solds := solds diff i else
86754: LD_ADDR_VAR 0 2
86758: PUSH
86759: LD_VAR 0 2
86763: PUSH
86764: LD_VAR 0 7
86768: DIFF
86769: ST_TO_ADDR
86770: GO 86784
// SetTag ( i , 18 ) ;
86772: LD_VAR 0 7
86776: PPUSH
86777: LD_INT 18
86779: PPUSH
86780: CALL_OW 109
86784: GO 86724
86786: POP
86787: POP
// if not solds then
86788: LD_VAR 0 2
86792: NOT
86793: IFFALSE 86797
// exit ;
86795: GO 87243
// repeat wait ( 0 0$2 ) ;
86797: LD_INT 70
86799: PPUSH
86800: CALL_OW 67
// enemy := mc_scan [ base ] ;
86804: LD_ADDR_VAR 0 4
86808: PUSH
86809: LD_EXP 66
86813: PUSH
86814: LD_VAR 0 1
86818: ARRAY
86819: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86820: LD_EXP 43
86824: PUSH
86825: LD_VAR 0 1
86829: ARRAY
86830: NOT
86831: PUSH
86832: LD_EXP 43
86836: PUSH
86837: LD_VAR 0 1
86841: ARRAY
86842: PUSH
86843: EMPTY
86844: EQUAL
86845: OR
86846: IFFALSE 86883
// begin for i in solds do
86848: LD_ADDR_VAR 0 7
86852: PUSH
86853: LD_VAR 0 2
86857: PUSH
86858: FOR_IN
86859: IFFALSE 86872
// ComStop ( i ) ;
86861: LD_VAR 0 7
86865: PPUSH
86866: CALL_OW 141
86870: GO 86858
86872: POP
86873: POP
// solds := [ ] ;
86874: LD_ADDR_VAR 0 2
86878: PUSH
86879: EMPTY
86880: ST_TO_ADDR
// exit ;
86881: GO 87243
// end ; for i in solds do
86883: LD_ADDR_VAR 0 7
86887: PUSH
86888: LD_VAR 0 2
86892: PUSH
86893: FOR_IN
86894: IFFALSE 87215
// begin if IsInUnit ( i ) then
86896: LD_VAR 0 7
86900: PPUSH
86901: CALL_OW 310
86905: IFFALSE 86916
// ComExitBuilding ( i ) ;
86907: LD_VAR 0 7
86911: PPUSH
86912: CALL_OW 122
// if GetLives ( i ) > 500 then
86916: LD_VAR 0 7
86920: PPUSH
86921: CALL_OW 256
86925: PUSH
86926: LD_INT 500
86928: GREATER
86929: IFFALSE 86982
// begin e := NearestUnitToUnit ( enemy , i ) ;
86931: LD_ADDR_VAR 0 5
86935: PUSH
86936: LD_VAR 0 4
86940: PPUSH
86941: LD_VAR 0 7
86945: PPUSH
86946: CALL_OW 74
86950: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86951: LD_VAR 0 7
86955: PPUSH
86956: LD_VAR 0 5
86960: PPUSH
86961: CALL_OW 250
86965: PPUSH
86966: LD_VAR 0 5
86970: PPUSH
86971: CALL_OW 251
86975: PPUSH
86976: CALL_OW 114
// end else
86980: GO 87213
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86982: LD_VAR 0 7
86986: PPUSH
86987: LD_EXP 43
86991: PUSH
86992: LD_VAR 0 1
86996: ARRAY
86997: PPUSH
86998: LD_INT 2
87000: PUSH
87001: LD_INT 30
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 30
87013: PUSH
87014: LD_INT 1
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 30
87023: PUSH
87024: LD_INT 6
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: PPUSH
87037: CALL_OW 72
87041: PPUSH
87042: LD_VAR 0 7
87046: PPUSH
87047: CALL_OW 74
87051: PPUSH
87052: CALL_OW 296
87056: PUSH
87057: LD_INT 10
87059: GREATER
87060: IFFALSE 87213
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87062: LD_ADDR_VAR 0 8
87066: PUSH
87067: LD_EXP 43
87071: PUSH
87072: LD_VAR 0 1
87076: ARRAY
87077: PPUSH
87078: LD_INT 2
87080: PUSH
87081: LD_INT 30
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 30
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 30
87103: PUSH
87104: LD_INT 6
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: PPUSH
87117: CALL_OW 72
87121: PPUSH
87122: LD_VAR 0 7
87126: PPUSH
87127: CALL_OW 74
87131: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87132: LD_VAR 0 7
87136: PPUSH
87137: LD_VAR 0 8
87141: PPUSH
87142: CALL_OW 250
87146: PPUSH
87147: LD_INT 3
87149: PPUSH
87150: LD_INT 5
87152: PPUSH
87153: CALL_OW 272
87157: PPUSH
87158: LD_VAR 0 8
87162: PPUSH
87163: CALL_OW 251
87167: PPUSH
87168: LD_INT 3
87170: PPUSH
87171: LD_INT 5
87173: PPUSH
87174: CALL_OW 273
87178: PPUSH
87179: CALL_OW 111
// SetTag ( i , 0 ) ;
87183: LD_VAR 0 7
87187: PPUSH
87188: LD_INT 0
87190: PPUSH
87191: CALL_OW 109
// solds := solds diff i ;
87195: LD_ADDR_VAR 0 2
87199: PUSH
87200: LD_VAR 0 2
87204: PUSH
87205: LD_VAR 0 7
87209: DIFF
87210: ST_TO_ADDR
// continue ;
87211: GO 86893
// end ; end ;
87213: GO 86893
87215: POP
87216: POP
// until not solds or not enemy ;
87217: LD_VAR 0 2
87221: NOT
87222: PUSH
87223: LD_VAR 0 4
87227: NOT
87228: OR
87229: IFFALSE 86797
// MC_Reset ( base , 18 ) ;
87231: LD_VAR 0 1
87235: PPUSH
87236: LD_INT 18
87238: PPUSH
87239: CALL 55402 0 2
// end ;
87243: LD_VAR 0 3
87247: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87248: LD_INT 0
87250: PPUSH
87251: PPUSH
87252: PPUSH
87253: PPUSH
87254: PPUSH
87255: PPUSH
87256: PPUSH
87257: PPUSH
87258: PPUSH
87259: PPUSH
87260: PPUSH
87261: PPUSH
87262: PPUSH
87263: PPUSH
87264: PPUSH
87265: PPUSH
87266: PPUSH
87267: PPUSH
87268: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87269: LD_ADDR_VAR 0 12
87273: PUSH
87274: LD_EXP 43
87278: PUSH
87279: LD_VAR 0 1
87283: ARRAY
87284: PPUSH
87285: LD_INT 25
87287: PUSH
87288: LD_INT 3
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PPUSH
87295: CALL_OW 72
87299: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87300: LD_EXP 83
87304: PUSH
87305: LD_VAR 0 1
87309: ARRAY
87310: IFFALSE 87334
// mechs := mechs diff mc_remote_driver [ base ] ;
87312: LD_ADDR_VAR 0 12
87316: PUSH
87317: LD_VAR 0 12
87321: PUSH
87322: LD_EXP 83
87326: PUSH
87327: LD_VAR 0 1
87331: ARRAY
87332: DIFF
87333: ST_TO_ADDR
// for i in mechs do
87334: LD_ADDR_VAR 0 4
87338: PUSH
87339: LD_VAR 0 12
87343: PUSH
87344: FOR_IN
87345: IFFALSE 87380
// if GetTag ( i ) > 0 then
87347: LD_VAR 0 4
87351: PPUSH
87352: CALL_OW 110
87356: PUSH
87357: LD_INT 0
87359: GREATER
87360: IFFALSE 87378
// mechs := mechs diff i ;
87362: LD_ADDR_VAR 0 12
87366: PUSH
87367: LD_VAR 0 12
87371: PUSH
87372: LD_VAR 0 4
87376: DIFF
87377: ST_TO_ADDR
87378: GO 87344
87380: POP
87381: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87382: LD_ADDR_VAR 0 8
87386: PUSH
87387: LD_EXP 43
87391: PUSH
87392: LD_VAR 0 1
87396: ARRAY
87397: PPUSH
87398: LD_INT 2
87400: PUSH
87401: LD_INT 25
87403: PUSH
87404: LD_INT 1
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 25
87413: PUSH
87414: LD_INT 5
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 25
87423: PUSH
87424: LD_INT 8
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 25
87433: PUSH
87434: LD_INT 9
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: PPUSH
87448: CALL_OW 72
87452: ST_TO_ADDR
// if not defenders and not solds then
87453: LD_VAR 0 2
87457: NOT
87458: PUSH
87459: LD_VAR 0 8
87463: NOT
87464: AND
87465: IFFALSE 87469
// exit ;
87467: GO 89239
// depot_under_attack := false ;
87469: LD_ADDR_VAR 0 16
87473: PUSH
87474: LD_INT 0
87476: ST_TO_ADDR
// sold_defenders := [ ] ;
87477: LD_ADDR_VAR 0 17
87481: PUSH
87482: EMPTY
87483: ST_TO_ADDR
// if mechs then
87484: LD_VAR 0 12
87488: IFFALSE 87641
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87490: LD_ADDR_VAR 0 4
87494: PUSH
87495: LD_VAR 0 2
87499: PPUSH
87500: LD_INT 21
87502: PUSH
87503: LD_INT 2
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PPUSH
87510: CALL_OW 72
87514: PUSH
87515: FOR_IN
87516: IFFALSE 87639
// begin if GetTag ( i ) <> 20 then
87518: LD_VAR 0 4
87522: PPUSH
87523: CALL_OW 110
87527: PUSH
87528: LD_INT 20
87530: NONEQUAL
87531: IFFALSE 87545
// SetTag ( i , 20 ) ;
87533: LD_VAR 0 4
87537: PPUSH
87538: LD_INT 20
87540: PPUSH
87541: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87545: LD_VAR 0 4
87549: PPUSH
87550: CALL_OW 263
87554: PUSH
87555: LD_INT 1
87557: EQUAL
87558: PUSH
87559: LD_VAR 0 4
87563: PPUSH
87564: CALL_OW 311
87568: NOT
87569: AND
87570: IFFALSE 87637
// begin un := mechs [ 1 ] ;
87572: LD_ADDR_VAR 0 10
87576: PUSH
87577: LD_VAR 0 12
87581: PUSH
87582: LD_INT 1
87584: ARRAY
87585: ST_TO_ADDR
// ComExit ( un ) ;
87586: LD_VAR 0 10
87590: PPUSH
87591: CALL 47678 0 1
// AddComEnterUnit ( un , i ) ;
87595: LD_VAR 0 10
87599: PPUSH
87600: LD_VAR 0 4
87604: PPUSH
87605: CALL_OW 180
// SetTag ( un , 19 ) ;
87609: LD_VAR 0 10
87613: PPUSH
87614: LD_INT 19
87616: PPUSH
87617: CALL_OW 109
// mechs := mechs diff un ;
87621: LD_ADDR_VAR 0 12
87625: PUSH
87626: LD_VAR 0 12
87630: PUSH
87631: LD_VAR 0 10
87635: DIFF
87636: ST_TO_ADDR
// end ; end ;
87637: GO 87515
87639: POP
87640: POP
// if solds then
87641: LD_VAR 0 8
87645: IFFALSE 87704
// for i in solds do
87647: LD_ADDR_VAR 0 4
87651: PUSH
87652: LD_VAR 0 8
87656: PUSH
87657: FOR_IN
87658: IFFALSE 87702
// if not GetTag ( i ) then
87660: LD_VAR 0 4
87664: PPUSH
87665: CALL_OW 110
87669: NOT
87670: IFFALSE 87700
// begin defenders := defenders union i ;
87672: LD_ADDR_VAR 0 2
87676: PUSH
87677: LD_VAR 0 2
87681: PUSH
87682: LD_VAR 0 4
87686: UNION
87687: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87688: LD_VAR 0 4
87692: PPUSH
87693: LD_INT 18
87695: PPUSH
87696: CALL_OW 109
// end ;
87700: GO 87657
87702: POP
87703: POP
// repeat wait ( 0 0$2 ) ;
87704: LD_INT 70
87706: PPUSH
87707: CALL_OW 67
// enemy := mc_scan [ base ] ;
87711: LD_ADDR_VAR 0 21
87715: PUSH
87716: LD_EXP 66
87720: PUSH
87721: LD_VAR 0 1
87725: ARRAY
87726: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87727: LD_EXP 43
87731: PUSH
87732: LD_VAR 0 1
87736: ARRAY
87737: NOT
87738: PUSH
87739: LD_EXP 43
87743: PUSH
87744: LD_VAR 0 1
87748: ARRAY
87749: PUSH
87750: EMPTY
87751: EQUAL
87752: OR
87753: IFFALSE 87790
// begin for i in defenders do
87755: LD_ADDR_VAR 0 4
87759: PUSH
87760: LD_VAR 0 2
87764: PUSH
87765: FOR_IN
87766: IFFALSE 87779
// ComStop ( i ) ;
87768: LD_VAR 0 4
87772: PPUSH
87773: CALL_OW 141
87777: GO 87765
87779: POP
87780: POP
// defenders := [ ] ;
87781: LD_ADDR_VAR 0 2
87785: PUSH
87786: EMPTY
87787: ST_TO_ADDR
// exit ;
87788: GO 89239
// end ; for i in defenders do
87790: LD_ADDR_VAR 0 4
87794: PUSH
87795: LD_VAR 0 2
87799: PUSH
87800: FOR_IN
87801: IFFALSE 88699
// begin e := NearestUnitToUnit ( enemy , i ) ;
87803: LD_ADDR_VAR 0 13
87807: PUSH
87808: LD_VAR 0 21
87812: PPUSH
87813: LD_VAR 0 4
87817: PPUSH
87818: CALL_OW 74
87822: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87823: LD_ADDR_VAR 0 7
87827: PUSH
87828: LD_EXP 43
87832: PUSH
87833: LD_VAR 0 1
87837: ARRAY
87838: PPUSH
87839: LD_INT 2
87841: PUSH
87842: LD_INT 30
87844: PUSH
87845: LD_INT 0
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 30
87854: PUSH
87855: LD_INT 1
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: LIST
87866: PPUSH
87867: CALL_OW 72
87871: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87872: LD_ADDR_VAR 0 16
87876: PUSH
87877: LD_VAR 0 7
87881: NOT
87882: PUSH
87883: LD_VAR 0 7
87887: PPUSH
87888: LD_INT 3
87890: PUSH
87891: LD_INT 24
87893: PUSH
87894: LD_INT 600
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PPUSH
87905: CALL_OW 72
87909: OR
87910: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87911: LD_VAR 0 4
87915: PPUSH
87916: CALL_OW 247
87920: PUSH
87921: LD_INT 2
87923: DOUBLE
87924: EQUAL
87925: IFTRUE 87929
87927: GO 88325
87929: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87930: LD_VAR 0 4
87934: PPUSH
87935: CALL_OW 256
87939: PUSH
87940: LD_INT 1000
87942: EQUAL
87943: PUSH
87944: LD_VAR 0 4
87948: PPUSH
87949: LD_VAR 0 13
87953: PPUSH
87954: CALL_OW 296
87958: PUSH
87959: LD_INT 40
87961: LESS
87962: PUSH
87963: LD_VAR 0 13
87967: PPUSH
87968: LD_EXP 68
87972: PUSH
87973: LD_VAR 0 1
87977: ARRAY
87978: PPUSH
87979: CALL_OW 308
87983: OR
87984: AND
87985: IFFALSE 88107
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87987: LD_VAR 0 4
87991: PPUSH
87992: CALL_OW 262
87996: PUSH
87997: LD_INT 1
87999: EQUAL
88000: PUSH
88001: LD_VAR 0 4
88005: PPUSH
88006: CALL_OW 261
88010: PUSH
88011: LD_INT 30
88013: LESS
88014: AND
88015: PUSH
88016: LD_VAR 0 7
88020: AND
88021: IFFALSE 88091
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88023: LD_VAR 0 4
88027: PPUSH
88028: LD_VAR 0 7
88032: PPUSH
88033: LD_VAR 0 4
88037: PPUSH
88038: CALL_OW 74
88042: PPUSH
88043: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88047: LD_VAR 0 4
88051: PPUSH
88052: LD_VAR 0 7
88056: PPUSH
88057: LD_VAR 0 4
88061: PPUSH
88062: CALL_OW 74
88066: PPUSH
88067: CALL_OW 296
88071: PUSH
88072: LD_INT 6
88074: LESS
88075: IFFALSE 88089
// SetFuel ( i , 100 ) ;
88077: LD_VAR 0 4
88081: PPUSH
88082: LD_INT 100
88084: PPUSH
88085: CALL_OW 240
// end else
88089: GO 88105
// ComAttackUnit ( i , e ) ;
88091: LD_VAR 0 4
88095: PPUSH
88096: LD_VAR 0 13
88100: PPUSH
88101: CALL_OW 115
// end else
88105: GO 88208
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88107: LD_VAR 0 13
88111: PPUSH
88112: LD_EXP 68
88116: PUSH
88117: LD_VAR 0 1
88121: ARRAY
88122: PPUSH
88123: CALL_OW 308
88127: NOT
88128: PUSH
88129: LD_VAR 0 4
88133: PPUSH
88134: LD_VAR 0 13
88138: PPUSH
88139: CALL_OW 296
88143: PUSH
88144: LD_INT 40
88146: GREATEREQUAL
88147: AND
88148: PUSH
88149: LD_VAR 0 4
88153: PPUSH
88154: CALL_OW 256
88158: PUSH
88159: LD_INT 650
88161: LESSEQUAL
88162: OR
88163: PUSH
88164: LD_VAR 0 4
88168: PPUSH
88169: LD_EXP 67
88173: PUSH
88174: LD_VAR 0 1
88178: ARRAY
88179: PPUSH
88180: CALL_OW 308
88184: NOT
88185: AND
88186: IFFALSE 88208
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88188: LD_VAR 0 4
88192: PPUSH
88193: LD_EXP 67
88197: PUSH
88198: LD_VAR 0 1
88202: ARRAY
88203: PPUSH
88204: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88208: LD_VAR 0 4
88212: PPUSH
88213: CALL_OW 256
88217: PUSH
88218: LD_INT 1000
88220: LESS
88221: PUSH
88222: LD_VAR 0 4
88226: PPUSH
88227: CALL_OW 263
88231: PUSH
88232: LD_INT 1
88234: EQUAL
88235: AND
88236: PUSH
88237: LD_VAR 0 4
88241: PPUSH
88242: CALL_OW 311
88246: AND
88247: PUSH
88248: LD_VAR 0 4
88252: PPUSH
88253: LD_EXP 67
88257: PUSH
88258: LD_VAR 0 1
88262: ARRAY
88263: PPUSH
88264: CALL_OW 308
88268: AND
88269: IFFALSE 88323
// begin mech := IsDrivenBy ( i ) ;
88271: LD_ADDR_VAR 0 9
88275: PUSH
88276: LD_VAR 0 4
88280: PPUSH
88281: CALL_OW 311
88285: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88286: LD_VAR 0 9
88290: PPUSH
88291: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88295: LD_VAR 0 9
88299: PPUSH
88300: LD_VAR 0 4
88304: PPUSH
88305: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88309: LD_VAR 0 9
88313: PPUSH
88314: LD_VAR 0 4
88318: PPUSH
88319: CALL_OW 180
// end ; end ; unit_human :
88323: GO 88670
88325: LD_INT 1
88327: DOUBLE
88328: EQUAL
88329: IFTRUE 88333
88331: GO 88669
88333: POP
// begin b := IsInUnit ( i ) ;
88334: LD_ADDR_VAR 0 18
88338: PUSH
88339: LD_VAR 0 4
88343: PPUSH
88344: CALL_OW 310
88348: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88349: LD_ADDR_VAR 0 19
88353: PUSH
88354: LD_VAR 0 18
88358: NOT
88359: PUSH
88360: LD_VAR 0 18
88364: PPUSH
88365: CALL_OW 266
88369: PUSH
88370: LD_INT 32
88372: PUSH
88373: LD_INT 31
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: IN
88380: OR
88381: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88382: LD_VAR 0 18
88386: PPUSH
88387: CALL_OW 266
88391: PUSH
88392: LD_INT 5
88394: EQUAL
88395: PUSH
88396: LD_VAR 0 4
88400: PPUSH
88401: CALL_OW 257
88405: PUSH
88406: LD_INT 1
88408: PUSH
88409: LD_INT 2
88411: PUSH
88412: LD_INT 3
88414: PUSH
88415: LD_INT 4
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: IN
88424: AND
88425: IFFALSE 88462
// begin class := AllowSpecClass ( i ) ;
88427: LD_ADDR_VAR 0 20
88431: PUSH
88432: LD_VAR 0 4
88436: PPUSH
88437: CALL 11598 0 1
88441: ST_TO_ADDR
// if class then
88442: LD_VAR 0 20
88446: IFFALSE 88462
// ComChangeProfession ( i , class ) ;
88448: LD_VAR 0 4
88452: PPUSH
88453: LD_VAR 0 20
88457: PPUSH
88458: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88462: LD_VAR 0 16
88466: PUSH
88467: LD_VAR 0 2
88471: PPUSH
88472: LD_INT 21
88474: PUSH
88475: LD_INT 2
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PPUSH
88482: CALL_OW 72
88486: PUSH
88487: LD_INT 1
88489: LESSEQUAL
88490: OR
88491: PUSH
88492: LD_VAR 0 19
88496: AND
88497: PUSH
88498: LD_VAR 0 4
88502: PUSH
88503: LD_VAR 0 17
88507: IN
88508: NOT
88509: AND
88510: IFFALSE 88603
// begin if b then
88512: LD_VAR 0 18
88516: IFFALSE 88565
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88518: LD_VAR 0 18
88522: PPUSH
88523: LD_VAR 0 21
88527: PPUSH
88528: LD_VAR 0 18
88532: PPUSH
88533: CALL_OW 74
88537: PPUSH
88538: CALL_OW 296
88542: PUSH
88543: LD_INT 10
88545: LESS
88546: PUSH
88547: LD_VAR 0 18
88551: PPUSH
88552: CALL_OW 461
88556: PUSH
88557: LD_INT 7
88559: NONEQUAL
88560: AND
88561: IFFALSE 88565
// continue ;
88563: GO 87800
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88565: LD_ADDR_VAR 0 17
88569: PUSH
88570: LD_VAR 0 17
88574: PPUSH
88575: LD_VAR 0 17
88579: PUSH
88580: LD_INT 1
88582: PLUS
88583: PPUSH
88584: LD_VAR 0 4
88588: PPUSH
88589: CALL_OW 1
88593: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88594: LD_VAR 0 4
88598: PPUSH
88599: CALL_OW 122
// end ; if sold_defenders then
88603: LD_VAR 0 17
88607: IFFALSE 88667
// if i in sold_defenders then
88609: LD_VAR 0 4
88613: PUSH
88614: LD_VAR 0 17
88618: IN
88619: IFFALSE 88667
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88621: LD_VAR 0 4
88625: PPUSH
88626: CALL_OW 314
88630: NOT
88631: PUSH
88632: LD_VAR 0 4
88636: PPUSH
88637: LD_VAR 0 13
88641: PPUSH
88642: CALL_OW 296
88646: PUSH
88647: LD_INT 30
88649: LESS
88650: AND
88651: IFFALSE 88667
// ComAttackUnit ( i , e ) ;
88653: LD_VAR 0 4
88657: PPUSH
88658: LD_VAR 0 13
88662: PPUSH
88663: CALL_OW 115
// end ; end ; end ;
88667: GO 88670
88669: POP
// if IsDead ( i ) then
88670: LD_VAR 0 4
88674: PPUSH
88675: CALL_OW 301
88679: IFFALSE 88697
// defenders := defenders diff i ;
88681: LD_ADDR_VAR 0 2
88685: PUSH
88686: LD_VAR 0 2
88690: PUSH
88691: LD_VAR 0 4
88695: DIFF
88696: ST_TO_ADDR
// end ;
88697: GO 87800
88699: POP
88700: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88701: LD_VAR 0 21
88705: NOT
88706: PUSH
88707: LD_VAR 0 2
88711: NOT
88712: OR
88713: PUSH
88714: LD_EXP 43
88718: PUSH
88719: LD_VAR 0 1
88723: ARRAY
88724: NOT
88725: OR
88726: IFFALSE 87704
// MC_Reset ( base , 18 ) ;
88728: LD_VAR 0 1
88732: PPUSH
88733: LD_INT 18
88735: PPUSH
88736: CALL 55402 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88740: LD_ADDR_VAR 0 2
88744: PUSH
88745: LD_VAR 0 2
88749: PUSH
88750: LD_VAR 0 2
88754: PPUSH
88755: LD_INT 2
88757: PUSH
88758: LD_INT 25
88760: PUSH
88761: LD_INT 1
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 25
88770: PUSH
88771: LD_INT 5
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 25
88780: PUSH
88781: LD_INT 8
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 25
88790: PUSH
88791: LD_INT 9
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: PPUSH
88805: CALL_OW 72
88809: DIFF
88810: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88811: LD_VAR 0 21
88815: NOT
88816: PUSH
88817: LD_VAR 0 2
88821: PPUSH
88822: LD_INT 21
88824: PUSH
88825: LD_INT 2
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PPUSH
88832: CALL_OW 72
88836: AND
88837: IFFALSE 89175
// begin tmp := FilterByTag ( defenders , 19 ) ;
88839: LD_ADDR_VAR 0 11
88843: PUSH
88844: LD_VAR 0 2
88848: PPUSH
88849: LD_INT 19
88851: PPUSH
88852: CALL 44861 0 2
88856: ST_TO_ADDR
// if tmp then
88857: LD_VAR 0 11
88861: IFFALSE 88931
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88863: LD_ADDR_VAR 0 11
88867: PUSH
88868: LD_VAR 0 11
88872: PPUSH
88873: LD_INT 25
88875: PUSH
88876: LD_INT 3
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PPUSH
88883: CALL_OW 72
88887: ST_TO_ADDR
// if tmp then
88888: LD_VAR 0 11
88892: IFFALSE 88931
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88894: LD_ADDR_EXP 55
88898: PUSH
88899: LD_EXP 55
88903: PPUSH
88904: LD_VAR 0 1
88908: PPUSH
88909: LD_EXP 55
88913: PUSH
88914: LD_VAR 0 1
88918: ARRAY
88919: PUSH
88920: LD_VAR 0 11
88924: UNION
88925: PPUSH
88926: CALL_OW 1
88930: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88931: LD_VAR 0 1
88935: PPUSH
88936: LD_INT 19
88938: PPUSH
88939: CALL 55402 0 2
// repeat wait ( 0 0$1 ) ;
88943: LD_INT 35
88945: PPUSH
88946: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88950: LD_EXP 43
88954: PUSH
88955: LD_VAR 0 1
88959: ARRAY
88960: NOT
88961: PUSH
88962: LD_EXP 43
88966: PUSH
88967: LD_VAR 0 1
88971: ARRAY
88972: PUSH
88973: EMPTY
88974: EQUAL
88975: OR
88976: IFFALSE 89013
// begin for i in defenders do
88978: LD_ADDR_VAR 0 4
88982: PUSH
88983: LD_VAR 0 2
88987: PUSH
88988: FOR_IN
88989: IFFALSE 89002
// ComStop ( i ) ;
88991: LD_VAR 0 4
88995: PPUSH
88996: CALL_OW 141
89000: GO 88988
89002: POP
89003: POP
// defenders := [ ] ;
89004: LD_ADDR_VAR 0 2
89008: PUSH
89009: EMPTY
89010: ST_TO_ADDR
// exit ;
89011: GO 89239
// end ; for i in defenders do
89013: LD_ADDR_VAR 0 4
89017: PUSH
89018: LD_VAR 0 2
89022: PUSH
89023: FOR_IN
89024: IFFALSE 89113
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89026: LD_VAR 0 4
89030: PPUSH
89031: LD_EXP 67
89035: PUSH
89036: LD_VAR 0 1
89040: ARRAY
89041: PPUSH
89042: CALL_OW 308
89046: NOT
89047: IFFALSE 89071
// ComMoveToArea ( i , mc_parking [ base ] ) else
89049: LD_VAR 0 4
89053: PPUSH
89054: LD_EXP 67
89058: PUSH
89059: LD_VAR 0 1
89063: ARRAY
89064: PPUSH
89065: CALL_OW 113
89069: GO 89111
// if GetControl ( i ) = control_manual then
89071: LD_VAR 0 4
89075: PPUSH
89076: CALL_OW 263
89080: PUSH
89081: LD_INT 1
89083: EQUAL
89084: IFFALSE 89111
// if IsDrivenBy ( i ) then
89086: LD_VAR 0 4
89090: PPUSH
89091: CALL_OW 311
89095: IFFALSE 89111
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89097: LD_VAR 0 4
89101: PPUSH
89102: CALL_OW 311
89106: PPUSH
89107: CALL_OW 121
// end ;
89111: GO 89023
89113: POP
89114: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89115: LD_VAR 0 2
89119: PPUSH
89120: LD_INT 95
89122: PUSH
89123: LD_EXP 67
89127: PUSH
89128: LD_VAR 0 1
89132: ARRAY
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PPUSH
89138: CALL_OW 72
89142: PUSH
89143: LD_VAR 0 2
89147: EQUAL
89148: PUSH
89149: LD_EXP 66
89153: PUSH
89154: LD_VAR 0 1
89158: ARRAY
89159: OR
89160: PUSH
89161: LD_EXP 43
89165: PUSH
89166: LD_VAR 0 1
89170: ARRAY
89171: NOT
89172: OR
89173: IFFALSE 88943
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89175: LD_ADDR_EXP 65
89179: PUSH
89180: LD_EXP 65
89184: PPUSH
89185: LD_VAR 0 1
89189: PPUSH
89190: LD_VAR 0 2
89194: PPUSH
89195: LD_INT 21
89197: PUSH
89198: LD_INT 2
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: PPUSH
89205: CALL_OW 72
89209: PPUSH
89210: CALL_OW 1
89214: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89215: LD_VAR 0 1
89219: PPUSH
89220: LD_INT 19
89222: PPUSH
89223: CALL 55402 0 2
// MC_Reset ( base , 20 ) ;
89227: LD_VAR 0 1
89231: PPUSH
89232: LD_INT 20
89234: PPUSH
89235: CALL 55402 0 2
// end ; end_of_file
89239: LD_VAR 0 3
89243: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89244: LD_INT 0
89246: PPUSH
89247: PPUSH
89248: PPUSH
89249: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89250: LD_VAR 0 1
89254: PPUSH
89255: CALL_OW 264
89259: PUSH
89260: LD_INT 91
89262: EQUAL
89263: IFFALSE 89335
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89265: LD_INT 68
89267: PPUSH
89268: LD_VAR 0 1
89272: PPUSH
89273: CALL_OW 255
89277: PPUSH
89278: CALL_OW 321
89282: PUSH
89283: LD_INT 2
89285: EQUAL
89286: IFFALSE 89298
// eff := 70 else
89288: LD_ADDR_VAR 0 4
89292: PUSH
89293: LD_INT 70
89295: ST_TO_ADDR
89296: GO 89306
// eff := 30 ;
89298: LD_ADDR_VAR 0 4
89302: PUSH
89303: LD_INT 30
89305: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89306: LD_VAR 0 1
89310: PPUSH
89311: CALL_OW 250
89315: PPUSH
89316: LD_VAR 0 1
89320: PPUSH
89321: CALL_OW 251
89325: PPUSH
89326: LD_VAR 0 4
89330: PPUSH
89331: CALL_OW 495
// end ; end ;
89335: LD_VAR 0 2
89339: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89340: LD_INT 0
89342: PPUSH
// end ;
89343: LD_VAR 0 4
89347: RET
// export function SOS_Command ( cmd ) ; begin
89348: LD_INT 0
89350: PPUSH
// end ;
89351: LD_VAR 0 2
89355: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89356: LD_INT 0
89358: PPUSH
// end ;
89359: LD_VAR 0 6
89363: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89364: LD_INT 0
89366: PPUSH
89367: PPUSH
// if not vehicle or not factory then
89368: LD_VAR 0 1
89372: NOT
89373: PUSH
89374: LD_VAR 0 2
89378: NOT
89379: OR
89380: IFFALSE 89384
// exit ;
89382: GO 89615
// if factoryWaypoints >= factory then
89384: LD_EXP 157
89388: PUSH
89389: LD_VAR 0 2
89393: GREATEREQUAL
89394: IFFALSE 89615
// if factoryWaypoints [ factory ] then
89396: LD_EXP 157
89400: PUSH
89401: LD_VAR 0 2
89405: ARRAY
89406: IFFALSE 89615
// begin if GetControl ( vehicle ) = control_manual then
89408: LD_VAR 0 1
89412: PPUSH
89413: CALL_OW 263
89417: PUSH
89418: LD_INT 1
89420: EQUAL
89421: IFFALSE 89502
// begin driver := IsDrivenBy ( vehicle ) ;
89423: LD_ADDR_VAR 0 4
89427: PUSH
89428: LD_VAR 0 1
89432: PPUSH
89433: CALL_OW 311
89437: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89438: LD_VAR 0 4
89442: PPUSH
89443: LD_EXP 157
89447: PUSH
89448: LD_VAR 0 2
89452: ARRAY
89453: PUSH
89454: LD_INT 3
89456: ARRAY
89457: PPUSH
89458: LD_EXP 157
89462: PUSH
89463: LD_VAR 0 2
89467: ARRAY
89468: PUSH
89469: LD_INT 4
89471: ARRAY
89472: PPUSH
89473: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89477: LD_VAR 0 4
89481: PPUSH
89482: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89486: LD_VAR 0 4
89490: PPUSH
89491: LD_VAR 0 2
89495: PPUSH
89496: CALL_OW 180
// end else
89500: GO 89615
// if GetControl ( vehicle ) = control_remote then
89502: LD_VAR 0 1
89506: PPUSH
89507: CALL_OW 263
89511: PUSH
89512: LD_INT 2
89514: EQUAL
89515: IFFALSE 89576
// begin wait ( 0 0$2 ) ;
89517: LD_INT 70
89519: PPUSH
89520: CALL_OW 67
// if Connect ( vehicle ) then
89524: LD_VAR 0 1
89528: PPUSH
89529: CALL 17918 0 1
89533: IFFALSE 89574
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89535: LD_VAR 0 1
89539: PPUSH
89540: LD_EXP 157
89544: PUSH
89545: LD_VAR 0 2
89549: ARRAY
89550: PUSH
89551: LD_INT 3
89553: ARRAY
89554: PPUSH
89555: LD_EXP 157
89559: PUSH
89560: LD_VAR 0 2
89564: ARRAY
89565: PUSH
89566: LD_INT 4
89568: ARRAY
89569: PPUSH
89570: CALL_OW 171
// end else
89574: GO 89615
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89576: LD_VAR 0 1
89580: PPUSH
89581: LD_EXP 157
89585: PUSH
89586: LD_VAR 0 2
89590: ARRAY
89591: PUSH
89592: LD_INT 3
89594: ARRAY
89595: PPUSH
89596: LD_EXP 157
89600: PUSH
89601: LD_VAR 0 2
89605: ARRAY
89606: PUSH
89607: LD_INT 4
89609: ARRAY
89610: PPUSH
89611: CALL_OW 171
// end ; end ;
89615: LD_VAR 0 3
89619: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89620: LD_INT 0
89622: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89623: LD_VAR 0 1
89627: PUSH
89628: LD_INT 250
89630: EQUAL
89631: PUSH
89632: LD_VAR 0 2
89636: PPUSH
89637: CALL_OW 264
89641: PUSH
89642: LD_INT 81
89644: EQUAL
89645: AND
89646: IFFALSE 89667
// MinerPlaceMine ( unit , x , y ) ;
89648: LD_VAR 0 2
89652: PPUSH
89653: LD_VAR 0 4
89657: PPUSH
89658: LD_VAR 0 5
89662: PPUSH
89663: CALL 92052 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89667: LD_VAR 0 1
89671: PUSH
89672: LD_INT 251
89674: EQUAL
89675: PUSH
89676: LD_VAR 0 2
89680: PPUSH
89681: CALL_OW 264
89685: PUSH
89686: LD_INT 81
89688: EQUAL
89689: AND
89690: IFFALSE 89711
// MinerDetonateMine ( unit , x , y ) ;
89692: LD_VAR 0 2
89696: PPUSH
89697: LD_VAR 0 4
89701: PPUSH
89702: LD_VAR 0 5
89706: PPUSH
89707: CALL 92327 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89711: LD_VAR 0 1
89715: PUSH
89716: LD_INT 252
89718: EQUAL
89719: PUSH
89720: LD_VAR 0 2
89724: PPUSH
89725: CALL_OW 264
89729: PUSH
89730: LD_INT 81
89732: EQUAL
89733: AND
89734: IFFALSE 89755
// MinerCreateMinefield ( unit , x , y ) ;
89736: LD_VAR 0 2
89740: PPUSH
89741: LD_VAR 0 4
89745: PPUSH
89746: LD_VAR 0 5
89750: PPUSH
89751: CALL 92744 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89755: LD_VAR 0 1
89759: PUSH
89760: LD_INT 253
89762: EQUAL
89763: PUSH
89764: LD_VAR 0 2
89768: PPUSH
89769: CALL_OW 257
89773: PUSH
89774: LD_INT 5
89776: EQUAL
89777: AND
89778: IFFALSE 89799
// ComBinocular ( unit , x , y ) ;
89780: LD_VAR 0 2
89784: PPUSH
89785: LD_VAR 0 4
89789: PPUSH
89790: LD_VAR 0 5
89794: PPUSH
89795: CALL 93113 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89799: LD_VAR 0 1
89803: PUSH
89804: LD_INT 254
89806: EQUAL
89807: PUSH
89808: LD_VAR 0 2
89812: PPUSH
89813: CALL_OW 264
89817: PUSH
89818: LD_INT 99
89820: EQUAL
89821: AND
89822: PUSH
89823: LD_VAR 0 3
89827: PPUSH
89828: CALL_OW 263
89832: PUSH
89833: LD_INT 3
89835: EQUAL
89836: AND
89837: IFFALSE 89853
// HackDestroyVehicle ( unit , selectedUnit ) ;
89839: LD_VAR 0 2
89843: PPUSH
89844: LD_VAR 0 3
89848: PPUSH
89849: CALL 91416 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89853: LD_VAR 0 1
89857: PUSH
89858: LD_INT 255
89860: EQUAL
89861: PUSH
89862: LD_VAR 0 2
89866: PPUSH
89867: CALL_OW 264
89871: PUSH
89872: LD_INT 14
89874: PUSH
89875: LD_INT 53
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: IN
89882: AND
89883: PUSH
89884: LD_VAR 0 4
89888: PPUSH
89889: LD_VAR 0 5
89893: PPUSH
89894: CALL_OW 488
89898: AND
89899: IFFALSE 89923
// CutTreeXYR ( unit , x , y , 12 ) ;
89901: LD_VAR 0 2
89905: PPUSH
89906: LD_VAR 0 4
89910: PPUSH
89911: LD_VAR 0 5
89915: PPUSH
89916: LD_INT 12
89918: PPUSH
89919: CALL 89986 0 4
// if cmd = 256 then
89923: LD_VAR 0 1
89927: PUSH
89928: LD_INT 256
89930: EQUAL
89931: IFFALSE 89952
// SetFactoryWaypoint ( unit , x , y ) ;
89933: LD_VAR 0 2
89937: PPUSH
89938: LD_VAR 0 4
89942: PPUSH
89943: LD_VAR 0 5
89947: PPUSH
89948: CALL 108179 0 3
// if cmd = 257 then
89952: LD_VAR 0 1
89956: PUSH
89957: LD_INT 257
89959: EQUAL
89960: IFFALSE 89981
// SetWarehouseGatheringPoint ( unit , x , y ) ;
89962: LD_VAR 0 2
89966: PPUSH
89967: LD_VAR 0 4
89971: PPUSH
89972: LD_VAR 0 5
89976: PPUSH
89977: CALL 108541 0 3
// end ;
89981: LD_VAR 0 6
89985: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89986: LD_INT 0
89988: PPUSH
89989: PPUSH
89990: PPUSH
89991: PPUSH
89992: PPUSH
89993: PPUSH
89994: PPUSH
89995: PPUSH
89996: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89997: LD_VAR 0 1
90001: NOT
90002: PUSH
90003: LD_VAR 0 2
90007: PPUSH
90008: LD_VAR 0 3
90012: PPUSH
90013: CALL_OW 488
90017: NOT
90018: OR
90019: PUSH
90020: LD_VAR 0 4
90024: NOT
90025: OR
90026: IFFALSE 90030
// exit ;
90028: GO 90370
// list := [ ] ;
90030: LD_ADDR_VAR 0 13
90034: PUSH
90035: EMPTY
90036: ST_TO_ADDR
// if x - r < 0 then
90037: LD_VAR 0 2
90041: PUSH
90042: LD_VAR 0 4
90046: MINUS
90047: PUSH
90048: LD_INT 0
90050: LESS
90051: IFFALSE 90063
// min_x := 0 else
90053: LD_ADDR_VAR 0 7
90057: PUSH
90058: LD_INT 0
90060: ST_TO_ADDR
90061: GO 90079
// min_x := x - r ;
90063: LD_ADDR_VAR 0 7
90067: PUSH
90068: LD_VAR 0 2
90072: PUSH
90073: LD_VAR 0 4
90077: MINUS
90078: ST_TO_ADDR
// if y - r < 0 then
90079: LD_VAR 0 3
90083: PUSH
90084: LD_VAR 0 4
90088: MINUS
90089: PUSH
90090: LD_INT 0
90092: LESS
90093: IFFALSE 90105
// min_y := 0 else
90095: LD_ADDR_VAR 0 8
90099: PUSH
90100: LD_INT 0
90102: ST_TO_ADDR
90103: GO 90121
// min_y := y - r ;
90105: LD_ADDR_VAR 0 8
90109: PUSH
90110: LD_VAR 0 3
90114: PUSH
90115: LD_VAR 0 4
90119: MINUS
90120: ST_TO_ADDR
// max_x := x + r ;
90121: LD_ADDR_VAR 0 9
90125: PUSH
90126: LD_VAR 0 2
90130: PUSH
90131: LD_VAR 0 4
90135: PLUS
90136: ST_TO_ADDR
// max_y := y + r ;
90137: LD_ADDR_VAR 0 10
90141: PUSH
90142: LD_VAR 0 3
90146: PUSH
90147: LD_VAR 0 4
90151: PLUS
90152: ST_TO_ADDR
// for _x = min_x to max_x do
90153: LD_ADDR_VAR 0 11
90157: PUSH
90158: DOUBLE
90159: LD_VAR 0 7
90163: DEC
90164: ST_TO_ADDR
90165: LD_VAR 0 9
90169: PUSH
90170: FOR_TO
90171: IFFALSE 90288
// for _y = min_y to max_y do
90173: LD_ADDR_VAR 0 12
90177: PUSH
90178: DOUBLE
90179: LD_VAR 0 8
90183: DEC
90184: ST_TO_ADDR
90185: LD_VAR 0 10
90189: PUSH
90190: FOR_TO
90191: IFFALSE 90284
// begin if not ValidHex ( _x , _y ) then
90193: LD_VAR 0 11
90197: PPUSH
90198: LD_VAR 0 12
90202: PPUSH
90203: CALL_OW 488
90207: NOT
90208: IFFALSE 90212
// continue ;
90210: GO 90190
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90212: LD_VAR 0 11
90216: PPUSH
90217: LD_VAR 0 12
90221: PPUSH
90222: CALL_OW 351
90226: PUSH
90227: LD_VAR 0 11
90231: PPUSH
90232: LD_VAR 0 12
90236: PPUSH
90237: CALL_OW 554
90241: AND
90242: IFFALSE 90282
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90244: LD_ADDR_VAR 0 13
90248: PUSH
90249: LD_VAR 0 13
90253: PPUSH
90254: LD_VAR 0 13
90258: PUSH
90259: LD_INT 1
90261: PLUS
90262: PPUSH
90263: LD_VAR 0 11
90267: PUSH
90268: LD_VAR 0 12
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PPUSH
90277: CALL_OW 2
90281: ST_TO_ADDR
// end ;
90282: GO 90190
90284: POP
90285: POP
90286: GO 90170
90288: POP
90289: POP
// if not list then
90290: LD_VAR 0 13
90294: NOT
90295: IFFALSE 90299
// exit ;
90297: GO 90370
// for i in list do
90299: LD_ADDR_VAR 0 6
90303: PUSH
90304: LD_VAR 0 13
90308: PUSH
90309: FOR_IN
90310: IFFALSE 90368
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90312: LD_VAR 0 1
90316: PPUSH
90317: LD_STRING M
90319: PUSH
90320: LD_VAR 0 6
90324: PUSH
90325: LD_INT 1
90327: ARRAY
90328: PUSH
90329: LD_VAR 0 6
90333: PUSH
90334: LD_INT 2
90336: ARRAY
90337: PUSH
90338: LD_INT 0
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: PUSH
90359: EMPTY
90360: LIST
90361: PPUSH
90362: CALL_OW 447
90366: GO 90309
90368: POP
90369: POP
// end ;
90370: LD_VAR 0 5
90374: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90375: LD_EXP 88
90379: NOT
90380: IFFALSE 90430
90382: GO 90384
90384: DISABLE
// begin initHack := true ;
90385: LD_ADDR_EXP 88
90389: PUSH
90390: LD_INT 1
90392: ST_TO_ADDR
// hackTanks := [ ] ;
90393: LD_ADDR_EXP 89
90397: PUSH
90398: EMPTY
90399: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90400: LD_ADDR_EXP 90
90404: PUSH
90405: EMPTY
90406: ST_TO_ADDR
// hackLimit := 3 ;
90407: LD_ADDR_EXP 91
90411: PUSH
90412: LD_INT 3
90414: ST_TO_ADDR
// hackDist := 12 ;
90415: LD_ADDR_EXP 92
90419: PUSH
90420: LD_INT 12
90422: ST_TO_ADDR
// hackCounter := [ ] ;
90423: LD_ADDR_EXP 93
90427: PUSH
90428: EMPTY
90429: ST_TO_ADDR
// end ;
90430: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90431: LD_EXP 88
90435: PUSH
90436: LD_INT 34
90438: PUSH
90439: LD_INT 99
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PPUSH
90446: CALL_OW 69
90450: AND
90451: IFFALSE 90704
90453: GO 90455
90455: DISABLE
90456: LD_INT 0
90458: PPUSH
90459: PPUSH
// begin enable ;
90460: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90461: LD_ADDR_VAR 0 1
90465: PUSH
90466: LD_INT 34
90468: PUSH
90469: LD_INT 99
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PPUSH
90476: CALL_OW 69
90480: PUSH
90481: FOR_IN
90482: IFFALSE 90702
// begin if not i in hackTanks then
90484: LD_VAR 0 1
90488: PUSH
90489: LD_EXP 89
90493: IN
90494: NOT
90495: IFFALSE 90578
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90497: LD_ADDR_EXP 89
90501: PUSH
90502: LD_EXP 89
90506: PPUSH
90507: LD_EXP 89
90511: PUSH
90512: LD_INT 1
90514: PLUS
90515: PPUSH
90516: LD_VAR 0 1
90520: PPUSH
90521: CALL_OW 1
90525: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90526: LD_ADDR_EXP 90
90530: PUSH
90531: LD_EXP 90
90535: PPUSH
90536: LD_EXP 90
90540: PUSH
90541: LD_INT 1
90543: PLUS
90544: PPUSH
90545: EMPTY
90546: PPUSH
90547: CALL_OW 1
90551: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90552: LD_ADDR_EXP 93
90556: PUSH
90557: LD_EXP 93
90561: PPUSH
90562: LD_EXP 93
90566: PUSH
90567: LD_INT 1
90569: PLUS
90570: PPUSH
90571: EMPTY
90572: PPUSH
90573: CALL_OW 1
90577: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90578: LD_VAR 0 1
90582: PPUSH
90583: CALL_OW 302
90587: NOT
90588: IFFALSE 90601
// begin HackUnlinkAll ( i ) ;
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL 90707 0 1
// continue ;
90599: GO 90481
// end ; HackCheckCapturedStatus ( i ) ;
90601: LD_VAR 0 1
90605: PPUSH
90606: CALL 91150 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90610: LD_ADDR_VAR 0 2
90614: PUSH
90615: LD_INT 81
90617: PUSH
90618: LD_VAR 0 1
90622: PPUSH
90623: CALL_OW 255
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 33
90634: PUSH
90635: LD_INT 3
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 91
90644: PUSH
90645: LD_VAR 0 1
90649: PUSH
90650: LD_EXP 92
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 50
90662: PUSH
90663: EMPTY
90664: LIST
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: PPUSH
90672: CALL_OW 69
90676: ST_TO_ADDR
// if not tmp then
90677: LD_VAR 0 2
90681: NOT
90682: IFFALSE 90686
// continue ;
90684: GO 90481
// HackLink ( i , tmp ) ;
90686: LD_VAR 0 1
90690: PPUSH
90691: LD_VAR 0 2
90695: PPUSH
90696: CALL 90843 0 2
// end ;
90700: GO 90481
90702: POP
90703: POP
// end ;
90704: PPOPN 2
90706: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90707: LD_INT 0
90709: PPUSH
90710: PPUSH
90711: PPUSH
// if not hack in hackTanks then
90712: LD_VAR 0 1
90716: PUSH
90717: LD_EXP 89
90721: IN
90722: NOT
90723: IFFALSE 90727
// exit ;
90725: GO 90838
// index := GetElementIndex ( hackTanks , hack ) ;
90727: LD_ADDR_VAR 0 4
90731: PUSH
90732: LD_EXP 89
90736: PPUSH
90737: LD_VAR 0 1
90741: PPUSH
90742: CALL 14734 0 2
90746: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90747: LD_EXP 90
90751: PUSH
90752: LD_VAR 0 4
90756: ARRAY
90757: IFFALSE 90838
// begin for i in hackTanksCaptured [ index ] do
90759: LD_ADDR_VAR 0 3
90763: PUSH
90764: LD_EXP 90
90768: PUSH
90769: LD_VAR 0 4
90773: ARRAY
90774: PUSH
90775: FOR_IN
90776: IFFALSE 90802
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90778: LD_VAR 0 3
90782: PUSH
90783: LD_INT 1
90785: ARRAY
90786: PPUSH
90787: LD_VAR 0 3
90791: PUSH
90792: LD_INT 2
90794: ARRAY
90795: PPUSH
90796: CALL_OW 235
90800: GO 90775
90802: POP
90803: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90804: LD_ADDR_EXP 90
90808: PUSH
90809: LD_EXP 90
90813: PPUSH
90814: LD_VAR 0 4
90818: PPUSH
90819: EMPTY
90820: PPUSH
90821: CALL_OW 1
90825: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90826: LD_VAR 0 1
90830: PPUSH
90831: LD_INT 0
90833: PPUSH
90834: CALL_OW 505
// end ; end ;
90838: LD_VAR 0 2
90842: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90843: LD_INT 0
90845: PPUSH
90846: PPUSH
90847: PPUSH
// if not hack in hackTanks or not vehicles then
90848: LD_VAR 0 1
90852: PUSH
90853: LD_EXP 89
90857: IN
90858: NOT
90859: PUSH
90860: LD_VAR 0 2
90864: NOT
90865: OR
90866: IFFALSE 90870
// exit ;
90868: GO 91145
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90870: LD_ADDR_VAR 0 2
90874: PUSH
90875: LD_VAR 0 1
90879: PPUSH
90880: LD_VAR 0 2
90884: PPUSH
90885: LD_INT 1
90887: PPUSH
90888: LD_INT 1
90890: PPUSH
90891: CALL 15384 0 4
90895: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90896: LD_ADDR_VAR 0 5
90900: PUSH
90901: LD_EXP 89
90905: PPUSH
90906: LD_VAR 0 1
90910: PPUSH
90911: CALL 14734 0 2
90915: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90916: LD_EXP 90
90920: PUSH
90921: LD_VAR 0 5
90925: ARRAY
90926: PUSH
90927: LD_EXP 91
90931: LESS
90932: IFFALSE 91121
// begin for i := 1 to vehicles do
90934: LD_ADDR_VAR 0 4
90938: PUSH
90939: DOUBLE
90940: LD_INT 1
90942: DEC
90943: ST_TO_ADDR
90944: LD_VAR 0 2
90948: PUSH
90949: FOR_TO
90950: IFFALSE 91119
// begin if hackTanksCaptured [ index ] = hackLimit then
90952: LD_EXP 90
90956: PUSH
90957: LD_VAR 0 5
90961: ARRAY
90962: PUSH
90963: LD_EXP 91
90967: EQUAL
90968: IFFALSE 90972
// break ;
90970: GO 91119
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90972: LD_ADDR_EXP 93
90976: PUSH
90977: LD_EXP 93
90981: PPUSH
90982: LD_VAR 0 5
90986: PPUSH
90987: LD_EXP 93
90991: PUSH
90992: LD_VAR 0 5
90996: ARRAY
90997: PUSH
90998: LD_INT 1
91000: PLUS
91001: PPUSH
91002: CALL_OW 1
91006: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91007: LD_ADDR_EXP 90
91011: PUSH
91012: LD_EXP 90
91016: PPUSH
91017: LD_VAR 0 5
91021: PUSH
91022: LD_EXP 90
91026: PUSH
91027: LD_VAR 0 5
91031: ARRAY
91032: PUSH
91033: LD_INT 1
91035: PLUS
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PPUSH
91041: LD_VAR 0 2
91045: PUSH
91046: LD_VAR 0 4
91050: ARRAY
91051: PUSH
91052: LD_VAR 0 2
91056: PUSH
91057: LD_VAR 0 4
91061: ARRAY
91062: PPUSH
91063: CALL_OW 255
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PPUSH
91072: CALL 14949 0 3
91076: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91077: LD_VAR 0 2
91081: PUSH
91082: LD_VAR 0 4
91086: ARRAY
91087: PPUSH
91088: LD_VAR 0 1
91092: PPUSH
91093: CALL_OW 255
91097: PPUSH
91098: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91102: LD_VAR 0 2
91106: PUSH
91107: LD_VAR 0 4
91111: ARRAY
91112: PPUSH
91113: CALL_OW 141
// end ;
91117: GO 90949
91119: POP
91120: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91121: LD_VAR 0 1
91125: PPUSH
91126: LD_EXP 90
91130: PUSH
91131: LD_VAR 0 5
91135: ARRAY
91136: PUSH
91137: LD_INT 0
91139: PLUS
91140: PPUSH
91141: CALL_OW 505
// end ;
91145: LD_VAR 0 3
91149: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91150: LD_INT 0
91152: PPUSH
91153: PPUSH
91154: PPUSH
91155: PPUSH
// if not hack in hackTanks then
91156: LD_VAR 0 1
91160: PUSH
91161: LD_EXP 89
91165: IN
91166: NOT
91167: IFFALSE 91171
// exit ;
91169: GO 91411
// index := GetElementIndex ( hackTanks , hack ) ;
91171: LD_ADDR_VAR 0 4
91175: PUSH
91176: LD_EXP 89
91180: PPUSH
91181: LD_VAR 0 1
91185: PPUSH
91186: CALL 14734 0 2
91190: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91191: LD_ADDR_VAR 0 3
91195: PUSH
91196: DOUBLE
91197: LD_EXP 90
91201: PUSH
91202: LD_VAR 0 4
91206: ARRAY
91207: INC
91208: ST_TO_ADDR
91209: LD_INT 1
91211: PUSH
91212: FOR_DOWNTO
91213: IFFALSE 91385
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91215: LD_ADDR_VAR 0 5
91219: PUSH
91220: LD_EXP 90
91224: PUSH
91225: LD_VAR 0 4
91229: ARRAY
91230: PUSH
91231: LD_VAR 0 3
91235: ARRAY
91236: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91237: LD_VAR 0 5
91241: PUSH
91242: LD_INT 1
91244: ARRAY
91245: PPUSH
91246: CALL_OW 302
91250: NOT
91251: PUSH
91252: LD_VAR 0 5
91256: PUSH
91257: LD_INT 1
91259: ARRAY
91260: PPUSH
91261: CALL_OW 255
91265: PUSH
91266: LD_VAR 0 1
91270: PPUSH
91271: CALL_OW 255
91275: NONEQUAL
91276: OR
91277: IFFALSE 91383
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91279: LD_VAR 0 5
91283: PUSH
91284: LD_INT 1
91286: ARRAY
91287: PPUSH
91288: CALL_OW 305
91292: PUSH
91293: LD_VAR 0 5
91297: PUSH
91298: LD_INT 1
91300: ARRAY
91301: PPUSH
91302: CALL_OW 255
91306: PUSH
91307: LD_VAR 0 1
91311: PPUSH
91312: CALL_OW 255
91316: EQUAL
91317: AND
91318: IFFALSE 91342
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91320: LD_VAR 0 5
91324: PUSH
91325: LD_INT 1
91327: ARRAY
91328: PPUSH
91329: LD_VAR 0 5
91333: PUSH
91334: LD_INT 2
91336: ARRAY
91337: PPUSH
91338: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91342: LD_ADDR_EXP 90
91346: PUSH
91347: LD_EXP 90
91351: PPUSH
91352: LD_VAR 0 4
91356: PPUSH
91357: LD_EXP 90
91361: PUSH
91362: LD_VAR 0 4
91366: ARRAY
91367: PPUSH
91368: LD_VAR 0 3
91372: PPUSH
91373: CALL_OW 3
91377: PPUSH
91378: CALL_OW 1
91382: ST_TO_ADDR
// end ; end ;
91383: GO 91212
91385: POP
91386: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91387: LD_VAR 0 1
91391: PPUSH
91392: LD_EXP 90
91396: PUSH
91397: LD_VAR 0 4
91401: ARRAY
91402: PUSH
91403: LD_INT 0
91405: PLUS
91406: PPUSH
91407: CALL_OW 505
// end ;
91411: LD_VAR 0 2
91415: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91416: LD_INT 0
91418: PPUSH
91419: PPUSH
91420: PPUSH
91421: PPUSH
// if not hack in hackTanks then
91422: LD_VAR 0 1
91426: PUSH
91427: LD_EXP 89
91431: IN
91432: NOT
91433: IFFALSE 91437
// exit ;
91435: GO 91522
// index := GetElementIndex ( hackTanks , hack ) ;
91437: LD_ADDR_VAR 0 5
91441: PUSH
91442: LD_EXP 89
91446: PPUSH
91447: LD_VAR 0 1
91451: PPUSH
91452: CALL 14734 0 2
91456: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91457: LD_ADDR_VAR 0 4
91461: PUSH
91462: DOUBLE
91463: LD_INT 1
91465: DEC
91466: ST_TO_ADDR
91467: LD_EXP 90
91471: PUSH
91472: LD_VAR 0 5
91476: ARRAY
91477: PUSH
91478: FOR_TO
91479: IFFALSE 91520
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91481: LD_EXP 90
91485: PUSH
91486: LD_VAR 0 5
91490: ARRAY
91491: PUSH
91492: LD_VAR 0 4
91496: ARRAY
91497: PUSH
91498: LD_INT 1
91500: ARRAY
91501: PUSH
91502: LD_VAR 0 2
91506: EQUAL
91507: IFFALSE 91518
// KillUnit ( vehicle ) ;
91509: LD_VAR 0 2
91513: PPUSH
91514: CALL_OW 66
91518: GO 91478
91520: POP
91521: POP
// end ;
91522: LD_VAR 0 3
91526: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91527: LD_EXP 94
91531: NOT
91532: IFFALSE 91567
91534: GO 91536
91536: DISABLE
// begin initMiner := true ;
91537: LD_ADDR_EXP 94
91541: PUSH
91542: LD_INT 1
91544: ST_TO_ADDR
// minersList := [ ] ;
91545: LD_ADDR_EXP 95
91549: PUSH
91550: EMPTY
91551: ST_TO_ADDR
// minerMinesList := [ ] ;
91552: LD_ADDR_EXP 96
91556: PUSH
91557: EMPTY
91558: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91559: LD_ADDR_EXP 97
91563: PUSH
91564: LD_INT 5
91566: ST_TO_ADDR
// end ;
91567: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91568: LD_EXP 94
91572: PUSH
91573: LD_INT 34
91575: PUSH
91576: LD_INT 81
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PPUSH
91583: CALL_OW 69
91587: AND
91588: IFFALSE 92049
91590: GO 91592
91592: DISABLE
91593: LD_INT 0
91595: PPUSH
91596: PPUSH
91597: PPUSH
91598: PPUSH
// begin enable ;
91599: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91600: LD_ADDR_VAR 0 1
91604: PUSH
91605: LD_INT 34
91607: PUSH
91608: LD_INT 81
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PPUSH
91615: CALL_OW 69
91619: PUSH
91620: FOR_IN
91621: IFFALSE 91693
// begin if not i in minersList then
91623: LD_VAR 0 1
91627: PUSH
91628: LD_EXP 95
91632: IN
91633: NOT
91634: IFFALSE 91691
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91636: LD_ADDR_EXP 95
91640: PUSH
91641: LD_EXP 95
91645: PPUSH
91646: LD_EXP 95
91650: PUSH
91651: LD_INT 1
91653: PLUS
91654: PPUSH
91655: LD_VAR 0 1
91659: PPUSH
91660: CALL_OW 1
91664: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91665: LD_ADDR_EXP 96
91669: PUSH
91670: LD_EXP 96
91674: PPUSH
91675: LD_EXP 96
91679: PUSH
91680: LD_INT 1
91682: PLUS
91683: PPUSH
91684: EMPTY
91685: PPUSH
91686: CALL_OW 1
91690: ST_TO_ADDR
// end end ;
91691: GO 91620
91693: POP
91694: POP
// for i := minerMinesList downto 1 do
91695: LD_ADDR_VAR 0 1
91699: PUSH
91700: DOUBLE
91701: LD_EXP 96
91705: INC
91706: ST_TO_ADDR
91707: LD_INT 1
91709: PUSH
91710: FOR_DOWNTO
91711: IFFALSE 92047
// begin if IsLive ( minersList [ i ] ) then
91713: LD_EXP 95
91717: PUSH
91718: LD_VAR 0 1
91722: ARRAY
91723: PPUSH
91724: CALL_OW 300
91728: IFFALSE 91756
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91730: LD_EXP 95
91734: PUSH
91735: LD_VAR 0 1
91739: ARRAY
91740: PPUSH
91741: LD_EXP 96
91745: PUSH
91746: LD_VAR 0 1
91750: ARRAY
91751: PPUSH
91752: CALL_OW 505
// if not minerMinesList [ i ] then
91756: LD_EXP 96
91760: PUSH
91761: LD_VAR 0 1
91765: ARRAY
91766: NOT
91767: IFFALSE 91771
// continue ;
91769: GO 91710
// for j := minerMinesList [ i ] downto 1 do
91771: LD_ADDR_VAR 0 2
91775: PUSH
91776: DOUBLE
91777: LD_EXP 96
91781: PUSH
91782: LD_VAR 0 1
91786: ARRAY
91787: INC
91788: ST_TO_ADDR
91789: LD_INT 1
91791: PUSH
91792: FOR_DOWNTO
91793: IFFALSE 92043
// begin side := GetSide ( minersList [ i ] ) ;
91795: LD_ADDR_VAR 0 3
91799: PUSH
91800: LD_EXP 95
91804: PUSH
91805: LD_VAR 0 1
91809: ARRAY
91810: PPUSH
91811: CALL_OW 255
91815: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91816: LD_ADDR_VAR 0 4
91820: PUSH
91821: LD_EXP 96
91825: PUSH
91826: LD_VAR 0 1
91830: ARRAY
91831: PUSH
91832: LD_VAR 0 2
91836: ARRAY
91837: PUSH
91838: LD_INT 1
91840: ARRAY
91841: PPUSH
91842: LD_EXP 96
91846: PUSH
91847: LD_VAR 0 1
91851: ARRAY
91852: PUSH
91853: LD_VAR 0 2
91857: ARRAY
91858: PUSH
91859: LD_INT 2
91861: ARRAY
91862: PPUSH
91863: CALL_OW 428
91867: ST_TO_ADDR
// if not tmp then
91868: LD_VAR 0 4
91872: NOT
91873: IFFALSE 91877
// continue ;
91875: GO 91792
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91877: LD_VAR 0 4
91881: PUSH
91882: LD_INT 81
91884: PUSH
91885: LD_VAR 0 3
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PPUSH
91894: CALL_OW 69
91898: IN
91899: PUSH
91900: LD_EXP 96
91904: PUSH
91905: LD_VAR 0 1
91909: ARRAY
91910: PUSH
91911: LD_VAR 0 2
91915: ARRAY
91916: PUSH
91917: LD_INT 1
91919: ARRAY
91920: PPUSH
91921: LD_EXP 96
91925: PUSH
91926: LD_VAR 0 1
91930: ARRAY
91931: PUSH
91932: LD_VAR 0 2
91936: ARRAY
91937: PUSH
91938: LD_INT 2
91940: ARRAY
91941: PPUSH
91942: CALL_OW 458
91946: AND
91947: IFFALSE 92041
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91949: LD_EXP 96
91953: PUSH
91954: LD_VAR 0 1
91958: ARRAY
91959: PUSH
91960: LD_VAR 0 2
91964: ARRAY
91965: PUSH
91966: LD_INT 1
91968: ARRAY
91969: PPUSH
91970: LD_EXP 96
91974: PUSH
91975: LD_VAR 0 1
91979: ARRAY
91980: PUSH
91981: LD_VAR 0 2
91985: ARRAY
91986: PUSH
91987: LD_INT 2
91989: ARRAY
91990: PPUSH
91991: LD_VAR 0 3
91995: PPUSH
91996: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92000: LD_ADDR_EXP 96
92004: PUSH
92005: LD_EXP 96
92009: PPUSH
92010: LD_VAR 0 1
92014: PPUSH
92015: LD_EXP 96
92019: PUSH
92020: LD_VAR 0 1
92024: ARRAY
92025: PPUSH
92026: LD_VAR 0 2
92030: PPUSH
92031: CALL_OW 3
92035: PPUSH
92036: CALL_OW 1
92040: ST_TO_ADDR
// end ; end ;
92041: GO 91792
92043: POP
92044: POP
// end ;
92045: GO 91710
92047: POP
92048: POP
// end ;
92049: PPOPN 4
92051: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92052: LD_INT 0
92054: PPUSH
92055: PPUSH
// result := false ;
92056: LD_ADDR_VAR 0 4
92060: PUSH
92061: LD_INT 0
92063: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92064: LD_VAR 0 1
92068: PPUSH
92069: CALL_OW 264
92073: PUSH
92074: LD_INT 81
92076: EQUAL
92077: NOT
92078: IFFALSE 92082
// exit ;
92080: GO 92322
// index := GetElementIndex ( minersList , unit ) ;
92082: LD_ADDR_VAR 0 5
92086: PUSH
92087: LD_EXP 95
92091: PPUSH
92092: LD_VAR 0 1
92096: PPUSH
92097: CALL 14734 0 2
92101: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92102: LD_EXP 96
92106: PUSH
92107: LD_VAR 0 5
92111: ARRAY
92112: PUSH
92113: LD_EXP 97
92117: GREATEREQUAL
92118: IFFALSE 92122
// exit ;
92120: GO 92322
// ComMoveXY ( unit , x , y ) ;
92122: LD_VAR 0 1
92126: PPUSH
92127: LD_VAR 0 2
92131: PPUSH
92132: LD_VAR 0 3
92136: PPUSH
92137: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92141: LD_INT 35
92143: PPUSH
92144: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92148: LD_VAR 0 1
92152: PPUSH
92153: LD_VAR 0 2
92157: PPUSH
92158: LD_VAR 0 3
92162: PPUSH
92163: CALL 46089 0 3
92167: NOT
92168: PUSH
92169: LD_VAR 0 1
92173: PPUSH
92174: CALL_OW 314
92178: AND
92179: IFFALSE 92183
// exit ;
92181: GO 92322
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92183: LD_VAR 0 2
92187: PPUSH
92188: LD_VAR 0 3
92192: PPUSH
92193: CALL_OW 428
92197: PUSH
92198: LD_VAR 0 1
92202: EQUAL
92203: PUSH
92204: LD_VAR 0 1
92208: PPUSH
92209: CALL_OW 314
92213: NOT
92214: AND
92215: IFFALSE 92141
// PlaySoundXY ( x , y , PlantMine ) ;
92217: LD_VAR 0 2
92221: PPUSH
92222: LD_VAR 0 3
92226: PPUSH
92227: LD_STRING PlantMine
92229: PPUSH
92230: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92234: LD_VAR 0 2
92238: PPUSH
92239: LD_VAR 0 3
92243: PPUSH
92244: LD_VAR 0 1
92248: PPUSH
92249: CALL_OW 255
92253: PPUSH
92254: LD_INT 0
92256: PPUSH
92257: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92261: LD_ADDR_EXP 96
92265: PUSH
92266: LD_EXP 96
92270: PPUSH
92271: LD_VAR 0 5
92275: PUSH
92276: LD_EXP 96
92280: PUSH
92281: LD_VAR 0 5
92285: ARRAY
92286: PUSH
92287: LD_INT 1
92289: PLUS
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PPUSH
92295: LD_VAR 0 2
92299: PUSH
92300: LD_VAR 0 3
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PPUSH
92309: CALL 14949 0 3
92313: ST_TO_ADDR
// result := true ;
92314: LD_ADDR_VAR 0 4
92318: PUSH
92319: LD_INT 1
92321: ST_TO_ADDR
// end ;
92322: LD_VAR 0 4
92326: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92327: LD_INT 0
92329: PPUSH
92330: PPUSH
92331: PPUSH
// if not unit in minersList then
92332: LD_VAR 0 1
92336: PUSH
92337: LD_EXP 95
92341: IN
92342: NOT
92343: IFFALSE 92347
// exit ;
92345: GO 92739
// index := GetElementIndex ( minersList , unit ) ;
92347: LD_ADDR_VAR 0 6
92351: PUSH
92352: LD_EXP 95
92356: PPUSH
92357: LD_VAR 0 1
92361: PPUSH
92362: CALL 14734 0 2
92366: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92367: LD_ADDR_VAR 0 5
92371: PUSH
92372: DOUBLE
92373: LD_EXP 96
92377: PUSH
92378: LD_VAR 0 6
92382: ARRAY
92383: INC
92384: ST_TO_ADDR
92385: LD_INT 1
92387: PUSH
92388: FOR_DOWNTO
92389: IFFALSE 92550
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92391: LD_EXP 96
92395: PUSH
92396: LD_VAR 0 6
92400: ARRAY
92401: PUSH
92402: LD_VAR 0 5
92406: ARRAY
92407: PUSH
92408: LD_INT 1
92410: ARRAY
92411: PUSH
92412: LD_VAR 0 2
92416: EQUAL
92417: PUSH
92418: LD_EXP 96
92422: PUSH
92423: LD_VAR 0 6
92427: ARRAY
92428: PUSH
92429: LD_VAR 0 5
92433: ARRAY
92434: PUSH
92435: LD_INT 2
92437: ARRAY
92438: PUSH
92439: LD_VAR 0 3
92443: EQUAL
92444: AND
92445: IFFALSE 92548
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92447: LD_EXP 96
92451: PUSH
92452: LD_VAR 0 6
92456: ARRAY
92457: PUSH
92458: LD_VAR 0 5
92462: ARRAY
92463: PUSH
92464: LD_INT 1
92466: ARRAY
92467: PPUSH
92468: LD_EXP 96
92472: PUSH
92473: LD_VAR 0 6
92477: ARRAY
92478: PUSH
92479: LD_VAR 0 5
92483: ARRAY
92484: PUSH
92485: LD_INT 2
92487: ARRAY
92488: PPUSH
92489: LD_VAR 0 1
92493: PPUSH
92494: CALL_OW 255
92498: PPUSH
92499: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92503: LD_ADDR_EXP 96
92507: PUSH
92508: LD_EXP 96
92512: PPUSH
92513: LD_VAR 0 6
92517: PPUSH
92518: LD_EXP 96
92522: PUSH
92523: LD_VAR 0 6
92527: ARRAY
92528: PPUSH
92529: LD_VAR 0 5
92533: PPUSH
92534: CALL_OW 3
92538: PPUSH
92539: CALL_OW 1
92543: ST_TO_ADDR
// exit ;
92544: POP
92545: POP
92546: GO 92739
// end ; end ;
92548: GO 92388
92550: POP
92551: POP
// for i := minerMinesList [ index ] downto 1 do
92552: LD_ADDR_VAR 0 5
92556: PUSH
92557: DOUBLE
92558: LD_EXP 96
92562: PUSH
92563: LD_VAR 0 6
92567: ARRAY
92568: INC
92569: ST_TO_ADDR
92570: LD_INT 1
92572: PUSH
92573: FOR_DOWNTO
92574: IFFALSE 92737
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92576: LD_EXP 96
92580: PUSH
92581: LD_VAR 0 6
92585: ARRAY
92586: PUSH
92587: LD_VAR 0 5
92591: ARRAY
92592: PUSH
92593: LD_INT 1
92595: ARRAY
92596: PPUSH
92597: LD_EXP 96
92601: PUSH
92602: LD_VAR 0 6
92606: ARRAY
92607: PUSH
92608: LD_VAR 0 5
92612: ARRAY
92613: PUSH
92614: LD_INT 2
92616: ARRAY
92617: PPUSH
92618: LD_VAR 0 2
92622: PPUSH
92623: LD_VAR 0 3
92627: PPUSH
92628: CALL_OW 298
92632: PUSH
92633: LD_INT 6
92635: LESS
92636: IFFALSE 92735
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92638: LD_EXP 96
92642: PUSH
92643: LD_VAR 0 6
92647: ARRAY
92648: PUSH
92649: LD_VAR 0 5
92653: ARRAY
92654: PUSH
92655: LD_INT 1
92657: ARRAY
92658: PPUSH
92659: LD_EXP 96
92663: PUSH
92664: LD_VAR 0 6
92668: ARRAY
92669: PUSH
92670: LD_VAR 0 5
92674: ARRAY
92675: PUSH
92676: LD_INT 2
92678: ARRAY
92679: PPUSH
92680: LD_VAR 0 1
92684: PPUSH
92685: CALL_OW 255
92689: PPUSH
92690: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92694: LD_ADDR_EXP 96
92698: PUSH
92699: LD_EXP 96
92703: PPUSH
92704: LD_VAR 0 6
92708: PPUSH
92709: LD_EXP 96
92713: PUSH
92714: LD_VAR 0 6
92718: ARRAY
92719: PPUSH
92720: LD_VAR 0 5
92724: PPUSH
92725: CALL_OW 3
92729: PPUSH
92730: CALL_OW 1
92734: ST_TO_ADDR
// end ; end ;
92735: GO 92573
92737: POP
92738: POP
// end ;
92739: LD_VAR 0 4
92743: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92744: LD_INT 0
92746: PPUSH
92747: PPUSH
92748: PPUSH
92749: PPUSH
92750: PPUSH
92751: PPUSH
92752: PPUSH
92753: PPUSH
92754: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92755: LD_VAR 0 1
92759: PPUSH
92760: CALL_OW 264
92764: PUSH
92765: LD_INT 81
92767: EQUAL
92768: NOT
92769: PUSH
92770: LD_VAR 0 1
92774: PUSH
92775: LD_EXP 95
92779: IN
92780: NOT
92781: OR
92782: IFFALSE 92786
// exit ;
92784: GO 93108
// index := GetElementIndex ( minersList , unit ) ;
92786: LD_ADDR_VAR 0 6
92790: PUSH
92791: LD_EXP 95
92795: PPUSH
92796: LD_VAR 0 1
92800: PPUSH
92801: CALL 14734 0 2
92805: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92806: LD_ADDR_VAR 0 8
92810: PUSH
92811: LD_EXP 97
92815: PUSH
92816: LD_EXP 96
92820: PUSH
92821: LD_VAR 0 6
92825: ARRAY
92826: MINUS
92827: ST_TO_ADDR
// if not minesFreeAmount then
92828: LD_VAR 0 8
92832: NOT
92833: IFFALSE 92837
// exit ;
92835: GO 93108
// tmp := [ ] ;
92837: LD_ADDR_VAR 0 7
92841: PUSH
92842: EMPTY
92843: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92844: LD_ADDR_VAR 0 5
92848: PUSH
92849: DOUBLE
92850: LD_INT 1
92852: DEC
92853: ST_TO_ADDR
92854: LD_VAR 0 8
92858: PUSH
92859: FOR_TO
92860: IFFALSE 93055
// begin _d := rand ( 0 , 5 ) ;
92862: LD_ADDR_VAR 0 11
92866: PUSH
92867: LD_INT 0
92869: PPUSH
92870: LD_INT 5
92872: PPUSH
92873: CALL_OW 12
92877: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92878: LD_ADDR_VAR 0 12
92882: PUSH
92883: LD_INT 2
92885: PPUSH
92886: LD_INT 6
92888: PPUSH
92889: CALL_OW 12
92893: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92894: LD_ADDR_VAR 0 9
92898: PUSH
92899: LD_VAR 0 2
92903: PPUSH
92904: LD_VAR 0 11
92908: PPUSH
92909: LD_VAR 0 12
92913: PPUSH
92914: CALL_OW 272
92918: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92919: LD_ADDR_VAR 0 10
92923: PUSH
92924: LD_VAR 0 3
92928: PPUSH
92929: LD_VAR 0 11
92933: PPUSH
92934: LD_VAR 0 12
92938: PPUSH
92939: CALL_OW 273
92943: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92944: LD_VAR 0 9
92948: PPUSH
92949: LD_VAR 0 10
92953: PPUSH
92954: CALL_OW 488
92958: PUSH
92959: LD_VAR 0 9
92963: PUSH
92964: LD_VAR 0 10
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_VAR 0 7
92977: IN
92978: NOT
92979: AND
92980: PUSH
92981: LD_VAR 0 9
92985: PPUSH
92986: LD_VAR 0 10
92990: PPUSH
92991: CALL_OW 458
92995: NOT
92996: AND
92997: IFFALSE 93039
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92999: LD_ADDR_VAR 0 7
93003: PUSH
93004: LD_VAR 0 7
93008: PPUSH
93009: LD_VAR 0 7
93013: PUSH
93014: LD_INT 1
93016: PLUS
93017: PPUSH
93018: LD_VAR 0 9
93022: PUSH
93023: LD_VAR 0 10
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PPUSH
93032: CALL_OW 1
93036: ST_TO_ADDR
93037: GO 93053
// i := i - 1 ;
93039: LD_ADDR_VAR 0 5
93043: PUSH
93044: LD_VAR 0 5
93048: PUSH
93049: LD_INT 1
93051: MINUS
93052: ST_TO_ADDR
// end ;
93053: GO 92859
93055: POP
93056: POP
// for i in tmp do
93057: LD_ADDR_VAR 0 5
93061: PUSH
93062: LD_VAR 0 7
93066: PUSH
93067: FOR_IN
93068: IFFALSE 93106
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93070: LD_VAR 0 1
93074: PPUSH
93075: LD_VAR 0 5
93079: PUSH
93080: LD_INT 1
93082: ARRAY
93083: PPUSH
93084: LD_VAR 0 5
93088: PUSH
93089: LD_INT 2
93091: ARRAY
93092: PPUSH
93093: CALL 92052 0 3
93097: NOT
93098: IFFALSE 93104
// exit ;
93100: POP
93101: POP
93102: GO 93108
93104: GO 93067
93106: POP
93107: POP
// end ;
93108: LD_VAR 0 4
93112: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93113: LD_INT 0
93115: PPUSH
93116: PPUSH
93117: PPUSH
93118: PPUSH
93119: PPUSH
93120: PPUSH
93121: PPUSH
// if not GetClass ( unit ) = class_sniper then
93122: LD_VAR 0 1
93126: PPUSH
93127: CALL_OW 257
93131: PUSH
93132: LD_INT 5
93134: EQUAL
93135: NOT
93136: IFFALSE 93140
// exit ;
93138: GO 93528
// dist := 8 ;
93140: LD_ADDR_VAR 0 5
93144: PUSH
93145: LD_INT 8
93147: ST_TO_ADDR
// viewRange := 12 ;
93148: LD_ADDR_VAR 0 7
93152: PUSH
93153: LD_INT 12
93155: ST_TO_ADDR
// side := GetSide ( unit ) ;
93156: LD_ADDR_VAR 0 6
93160: PUSH
93161: LD_VAR 0 1
93165: PPUSH
93166: CALL_OW 255
93170: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93171: LD_INT 61
93173: PPUSH
93174: LD_VAR 0 6
93178: PPUSH
93179: CALL_OW 321
93183: PUSH
93184: LD_INT 2
93186: EQUAL
93187: IFFALSE 93197
// viewRange := 16 ;
93189: LD_ADDR_VAR 0 7
93193: PUSH
93194: LD_INT 16
93196: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93197: LD_VAR 0 1
93201: PPUSH
93202: LD_VAR 0 2
93206: PPUSH
93207: LD_VAR 0 3
93211: PPUSH
93212: CALL_OW 297
93216: PUSH
93217: LD_VAR 0 5
93221: GREATER
93222: IFFALSE 93301
// begin ComMoveXY ( unit , x , y ) ;
93224: LD_VAR 0 1
93228: PPUSH
93229: LD_VAR 0 2
93233: PPUSH
93234: LD_VAR 0 3
93238: PPUSH
93239: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93243: LD_INT 35
93245: PPUSH
93246: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93250: LD_VAR 0 1
93254: PPUSH
93255: LD_VAR 0 2
93259: PPUSH
93260: LD_VAR 0 3
93264: PPUSH
93265: CALL 46089 0 3
93269: NOT
93270: IFFALSE 93274
// exit ;
93272: GO 93528
// until GetDistUnitXY ( unit , x , y ) < dist ;
93274: LD_VAR 0 1
93278: PPUSH
93279: LD_VAR 0 2
93283: PPUSH
93284: LD_VAR 0 3
93288: PPUSH
93289: CALL_OW 297
93293: PUSH
93294: LD_VAR 0 5
93298: LESS
93299: IFFALSE 93243
// end ; ComTurnXY ( unit , x , y ) ;
93301: LD_VAR 0 1
93305: PPUSH
93306: LD_VAR 0 2
93310: PPUSH
93311: LD_VAR 0 3
93315: PPUSH
93316: CALL_OW 118
// wait ( 5 ) ;
93320: LD_INT 5
93322: PPUSH
93323: CALL_OW 67
// _d := GetDir ( unit ) ;
93327: LD_ADDR_VAR 0 10
93331: PUSH
93332: LD_VAR 0 1
93336: PPUSH
93337: CALL_OW 254
93341: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93342: LD_ADDR_VAR 0 8
93346: PUSH
93347: LD_VAR 0 1
93351: PPUSH
93352: CALL_OW 250
93356: PPUSH
93357: LD_VAR 0 10
93361: PPUSH
93362: LD_VAR 0 5
93366: PPUSH
93367: CALL_OW 272
93371: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93372: LD_ADDR_VAR 0 9
93376: PUSH
93377: LD_VAR 0 1
93381: PPUSH
93382: CALL_OW 251
93386: PPUSH
93387: LD_VAR 0 10
93391: PPUSH
93392: LD_VAR 0 5
93396: PPUSH
93397: CALL_OW 273
93401: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93402: LD_VAR 0 8
93406: PPUSH
93407: LD_VAR 0 9
93411: PPUSH
93412: CALL_OW 488
93416: NOT
93417: IFFALSE 93421
// exit ;
93419: GO 93528
// ComAnimCustom ( unit , 1 ) ;
93421: LD_VAR 0 1
93425: PPUSH
93426: LD_INT 1
93428: PPUSH
93429: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93433: LD_VAR 0 8
93437: PPUSH
93438: LD_VAR 0 9
93442: PPUSH
93443: LD_VAR 0 6
93447: PPUSH
93448: LD_VAR 0 7
93452: PPUSH
93453: CALL_OW 330
// repeat wait ( 1 ) ;
93457: LD_INT 1
93459: PPUSH
93460: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93464: LD_VAR 0 1
93468: PPUSH
93469: CALL_OW 316
93473: PUSH
93474: LD_VAR 0 1
93478: PPUSH
93479: CALL_OW 314
93483: OR
93484: PUSH
93485: LD_VAR 0 1
93489: PPUSH
93490: CALL_OW 302
93494: NOT
93495: OR
93496: PUSH
93497: LD_VAR 0 1
93501: PPUSH
93502: CALL_OW 301
93506: OR
93507: IFFALSE 93457
// RemoveSeeing ( _x , _y , side ) ;
93509: LD_VAR 0 8
93513: PPUSH
93514: LD_VAR 0 9
93518: PPUSH
93519: LD_VAR 0 6
93523: PPUSH
93524: CALL_OW 331
// end ; end_of_file
93528: LD_VAR 0 4
93532: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93533: LD_VAR 0 1
93537: PUSH
93538: LD_INT 200
93540: DOUBLE
93541: GREATEREQUAL
93542: IFFALSE 93550
93544: LD_INT 299
93546: DOUBLE
93547: LESSEQUAL
93548: IFTRUE 93552
93550: GO 93584
93552: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93553: LD_VAR 0 1
93557: PPUSH
93558: LD_VAR 0 2
93562: PPUSH
93563: LD_VAR 0 3
93567: PPUSH
93568: LD_VAR 0 4
93572: PPUSH
93573: LD_VAR 0 5
93577: PPUSH
93578: CALL 89620 0 5
93582: GO 93661
93584: LD_INT 300
93586: DOUBLE
93587: GREATEREQUAL
93588: IFFALSE 93596
93590: LD_INT 399
93592: DOUBLE
93593: LESSEQUAL
93594: IFTRUE 93598
93596: GO 93660
93598: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93599: LD_VAR 0 1
93603: PPUSH
93604: LD_VAR 0 2
93608: PPUSH
93609: LD_VAR 0 3
93613: PPUSH
93614: LD_VAR 0 4
93618: PPUSH
93619: LD_VAR 0 5
93623: PPUSH
93624: LD_VAR 0 6
93628: PPUSH
93629: LD_VAR 0 7
93633: PPUSH
93634: LD_VAR 0 8
93638: PPUSH
93639: LD_VAR 0 9
93643: PPUSH
93644: LD_VAR 0 10
93648: PPUSH
93649: LD_VAR 0 11
93653: PPUSH
93654: CALL 106199 0 11
93658: GO 93661
93660: POP
// end ;
93661: PPOPN 11
93663: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93664: LD_VAR 0 1
93668: PPUSH
93669: LD_VAR 0 2
93673: PPUSH
93674: LD_VAR 0 3
93678: PPUSH
93679: LD_VAR 0 4
93683: PPUSH
93684: LD_VAR 0 5
93688: PPUSH
93689: CALL 89356 0 5
// end ; end_of_file
93693: PPOPN 5
93695: END
// export globalGameSaveCounter ; every 0 0$1 do
93696: GO 93698
93698: DISABLE
// begin enable ;
93699: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93700: LD_STRING updateTimer(
93702: PUSH
93703: LD_OWVAR 1
93707: STR
93708: PUSH
93709: LD_STRING );
93711: STR
93712: PPUSH
93713: CALL_OW 559
// end ;
93717: END
// every 0 0$1 do
93718: GO 93720
93720: DISABLE
// begin globalGameSaveCounter := 0 ;
93721: LD_ADDR_EXP 98
93725: PUSH
93726: LD_INT 0
93728: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93729: LD_STRING setGameSaveCounter(0)
93731: PPUSH
93732: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93736: LD_STRING initStreamRollete();
93738: PPUSH
93739: CALL_OW 559
// InitStreamMode ;
93743: CALL 95069 0 0
// DefineStreamItems ( false ) ;
93747: LD_INT 0
93749: PPUSH
93750: CALL 95533 0 1
// end ;
93754: END
// export function SOS_MapStart ( ) ; begin
93755: LD_INT 0
93757: PPUSH
// if streamModeActive then
93758: LD_EXP 99
93762: IFFALSE 93771
// DefineStreamItems ( true ) ;
93764: LD_INT 1
93766: PPUSH
93767: CALL 95533 0 1
// UpdateLuaVariables ( ) ;
93771: CALL 93788 0 0
// UpdateFactoryWaypoints ( ) ;
93775: CALL 108394 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93779: CALL 108651 0 0
// end ;
93783: LD_VAR 0 1
93787: RET
// function UpdateLuaVariables ( ) ; begin
93788: LD_INT 0
93790: PPUSH
// if globalGameSaveCounter then
93791: LD_EXP 98
93795: IFFALSE 93829
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93797: LD_ADDR_EXP 98
93801: PUSH
93802: LD_EXP 98
93806: PPUSH
93807: CALL 48641 0 1
93811: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93812: LD_STRING setGameSaveCounter(
93814: PUSH
93815: LD_EXP 98
93819: STR
93820: PUSH
93821: LD_STRING )
93823: STR
93824: PPUSH
93825: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93829: LD_STRING setGameDifficulty(
93831: PUSH
93832: LD_OWVAR 67
93836: STR
93837: PUSH
93838: LD_STRING )
93840: STR
93841: PPUSH
93842: CALL_OW 559
// end ;
93846: LD_VAR 0 1
93850: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93851: LD_INT 0
93853: PPUSH
// if p2 = stream_mode then
93854: LD_VAR 0 2
93858: PUSH
93859: LD_INT 100
93861: EQUAL
93862: IFFALSE 94865
// begin if not StreamModeActive then
93864: LD_EXP 99
93868: NOT
93869: IFFALSE 93879
// StreamModeActive := true ;
93871: LD_ADDR_EXP 99
93875: PUSH
93876: LD_INT 1
93878: ST_TO_ADDR
// if p3 = 0 then
93879: LD_VAR 0 3
93883: PUSH
93884: LD_INT 0
93886: EQUAL
93887: IFFALSE 93893
// InitStreamMode ;
93889: CALL 95069 0 0
// if p3 = 1 then
93893: LD_VAR 0 3
93897: PUSH
93898: LD_INT 1
93900: EQUAL
93901: IFFALSE 93911
// sRocket := true ;
93903: LD_ADDR_EXP 104
93907: PUSH
93908: LD_INT 1
93910: ST_TO_ADDR
// if p3 = 2 then
93911: LD_VAR 0 3
93915: PUSH
93916: LD_INT 2
93918: EQUAL
93919: IFFALSE 93929
// sSpeed := true ;
93921: LD_ADDR_EXP 103
93925: PUSH
93926: LD_INT 1
93928: ST_TO_ADDR
// if p3 = 3 then
93929: LD_VAR 0 3
93933: PUSH
93934: LD_INT 3
93936: EQUAL
93937: IFFALSE 93947
// sEngine := true ;
93939: LD_ADDR_EXP 105
93943: PUSH
93944: LD_INT 1
93946: ST_TO_ADDR
// if p3 = 4 then
93947: LD_VAR 0 3
93951: PUSH
93952: LD_INT 4
93954: EQUAL
93955: IFFALSE 93965
// sSpec := true ;
93957: LD_ADDR_EXP 102
93961: PUSH
93962: LD_INT 1
93964: ST_TO_ADDR
// if p3 = 5 then
93965: LD_VAR 0 3
93969: PUSH
93970: LD_INT 5
93972: EQUAL
93973: IFFALSE 93983
// sLevel := true ;
93975: LD_ADDR_EXP 106
93979: PUSH
93980: LD_INT 1
93982: ST_TO_ADDR
// if p3 = 6 then
93983: LD_VAR 0 3
93987: PUSH
93988: LD_INT 6
93990: EQUAL
93991: IFFALSE 94001
// sArmoury := true ;
93993: LD_ADDR_EXP 107
93997: PUSH
93998: LD_INT 1
94000: ST_TO_ADDR
// if p3 = 7 then
94001: LD_VAR 0 3
94005: PUSH
94006: LD_INT 7
94008: EQUAL
94009: IFFALSE 94019
// sRadar := true ;
94011: LD_ADDR_EXP 108
94015: PUSH
94016: LD_INT 1
94018: ST_TO_ADDR
// if p3 = 8 then
94019: LD_VAR 0 3
94023: PUSH
94024: LD_INT 8
94026: EQUAL
94027: IFFALSE 94037
// sBunker := true ;
94029: LD_ADDR_EXP 109
94033: PUSH
94034: LD_INT 1
94036: ST_TO_ADDR
// if p3 = 9 then
94037: LD_VAR 0 3
94041: PUSH
94042: LD_INT 9
94044: EQUAL
94045: IFFALSE 94055
// sHack := true ;
94047: LD_ADDR_EXP 110
94051: PUSH
94052: LD_INT 1
94054: ST_TO_ADDR
// if p3 = 10 then
94055: LD_VAR 0 3
94059: PUSH
94060: LD_INT 10
94062: EQUAL
94063: IFFALSE 94073
// sFire := true ;
94065: LD_ADDR_EXP 111
94069: PUSH
94070: LD_INT 1
94072: ST_TO_ADDR
// if p3 = 11 then
94073: LD_VAR 0 3
94077: PUSH
94078: LD_INT 11
94080: EQUAL
94081: IFFALSE 94091
// sRefresh := true ;
94083: LD_ADDR_EXP 112
94087: PUSH
94088: LD_INT 1
94090: ST_TO_ADDR
// if p3 = 12 then
94091: LD_VAR 0 3
94095: PUSH
94096: LD_INT 12
94098: EQUAL
94099: IFFALSE 94109
// sExp := true ;
94101: LD_ADDR_EXP 113
94105: PUSH
94106: LD_INT 1
94108: ST_TO_ADDR
// if p3 = 13 then
94109: LD_VAR 0 3
94113: PUSH
94114: LD_INT 13
94116: EQUAL
94117: IFFALSE 94127
// sDepot := true ;
94119: LD_ADDR_EXP 114
94123: PUSH
94124: LD_INT 1
94126: ST_TO_ADDR
// if p3 = 14 then
94127: LD_VAR 0 3
94131: PUSH
94132: LD_INT 14
94134: EQUAL
94135: IFFALSE 94145
// sFlag := true ;
94137: LD_ADDR_EXP 115
94141: PUSH
94142: LD_INT 1
94144: ST_TO_ADDR
// if p3 = 15 then
94145: LD_VAR 0 3
94149: PUSH
94150: LD_INT 15
94152: EQUAL
94153: IFFALSE 94163
// sKamikadze := true ;
94155: LD_ADDR_EXP 123
94159: PUSH
94160: LD_INT 1
94162: ST_TO_ADDR
// if p3 = 16 then
94163: LD_VAR 0 3
94167: PUSH
94168: LD_INT 16
94170: EQUAL
94171: IFFALSE 94181
// sTroll := true ;
94173: LD_ADDR_EXP 124
94177: PUSH
94178: LD_INT 1
94180: ST_TO_ADDR
// if p3 = 17 then
94181: LD_VAR 0 3
94185: PUSH
94186: LD_INT 17
94188: EQUAL
94189: IFFALSE 94199
// sSlow := true ;
94191: LD_ADDR_EXP 125
94195: PUSH
94196: LD_INT 1
94198: ST_TO_ADDR
// if p3 = 18 then
94199: LD_VAR 0 3
94203: PUSH
94204: LD_INT 18
94206: EQUAL
94207: IFFALSE 94217
// sLack := true ;
94209: LD_ADDR_EXP 126
94213: PUSH
94214: LD_INT 1
94216: ST_TO_ADDR
// if p3 = 19 then
94217: LD_VAR 0 3
94221: PUSH
94222: LD_INT 19
94224: EQUAL
94225: IFFALSE 94235
// sTank := true ;
94227: LD_ADDR_EXP 128
94231: PUSH
94232: LD_INT 1
94234: ST_TO_ADDR
// if p3 = 20 then
94235: LD_VAR 0 3
94239: PUSH
94240: LD_INT 20
94242: EQUAL
94243: IFFALSE 94253
// sRemote := true ;
94245: LD_ADDR_EXP 129
94249: PUSH
94250: LD_INT 1
94252: ST_TO_ADDR
// if p3 = 21 then
94253: LD_VAR 0 3
94257: PUSH
94258: LD_INT 21
94260: EQUAL
94261: IFFALSE 94271
// sPowell := true ;
94263: LD_ADDR_EXP 130
94267: PUSH
94268: LD_INT 1
94270: ST_TO_ADDR
// if p3 = 22 then
94271: LD_VAR 0 3
94275: PUSH
94276: LD_INT 22
94278: EQUAL
94279: IFFALSE 94289
// sTeleport := true ;
94281: LD_ADDR_EXP 133
94285: PUSH
94286: LD_INT 1
94288: ST_TO_ADDR
// if p3 = 23 then
94289: LD_VAR 0 3
94293: PUSH
94294: LD_INT 23
94296: EQUAL
94297: IFFALSE 94307
// sOilTower := true ;
94299: LD_ADDR_EXP 135
94303: PUSH
94304: LD_INT 1
94306: ST_TO_ADDR
// if p3 = 24 then
94307: LD_VAR 0 3
94311: PUSH
94312: LD_INT 24
94314: EQUAL
94315: IFFALSE 94325
// sShovel := true ;
94317: LD_ADDR_EXP 136
94321: PUSH
94322: LD_INT 1
94324: ST_TO_ADDR
// if p3 = 25 then
94325: LD_VAR 0 3
94329: PUSH
94330: LD_INT 25
94332: EQUAL
94333: IFFALSE 94343
// sSheik := true ;
94335: LD_ADDR_EXP 137
94339: PUSH
94340: LD_INT 1
94342: ST_TO_ADDR
// if p3 = 26 then
94343: LD_VAR 0 3
94347: PUSH
94348: LD_INT 26
94350: EQUAL
94351: IFFALSE 94361
// sEarthquake := true ;
94353: LD_ADDR_EXP 139
94357: PUSH
94358: LD_INT 1
94360: ST_TO_ADDR
// if p3 = 27 then
94361: LD_VAR 0 3
94365: PUSH
94366: LD_INT 27
94368: EQUAL
94369: IFFALSE 94379
// sAI := true ;
94371: LD_ADDR_EXP 140
94375: PUSH
94376: LD_INT 1
94378: ST_TO_ADDR
// if p3 = 28 then
94379: LD_VAR 0 3
94383: PUSH
94384: LD_INT 28
94386: EQUAL
94387: IFFALSE 94397
// sCargo := true ;
94389: LD_ADDR_EXP 143
94393: PUSH
94394: LD_INT 1
94396: ST_TO_ADDR
// if p3 = 29 then
94397: LD_VAR 0 3
94401: PUSH
94402: LD_INT 29
94404: EQUAL
94405: IFFALSE 94415
// sDLaser := true ;
94407: LD_ADDR_EXP 144
94411: PUSH
94412: LD_INT 1
94414: ST_TO_ADDR
// if p3 = 30 then
94415: LD_VAR 0 3
94419: PUSH
94420: LD_INT 30
94422: EQUAL
94423: IFFALSE 94433
// sExchange := true ;
94425: LD_ADDR_EXP 145
94429: PUSH
94430: LD_INT 1
94432: ST_TO_ADDR
// if p3 = 31 then
94433: LD_VAR 0 3
94437: PUSH
94438: LD_INT 31
94440: EQUAL
94441: IFFALSE 94451
// sFac := true ;
94443: LD_ADDR_EXP 146
94447: PUSH
94448: LD_INT 1
94450: ST_TO_ADDR
// if p3 = 32 then
94451: LD_VAR 0 3
94455: PUSH
94456: LD_INT 32
94458: EQUAL
94459: IFFALSE 94469
// sPower := true ;
94461: LD_ADDR_EXP 147
94465: PUSH
94466: LD_INT 1
94468: ST_TO_ADDR
// if p3 = 33 then
94469: LD_VAR 0 3
94473: PUSH
94474: LD_INT 33
94476: EQUAL
94477: IFFALSE 94487
// sRandom := true ;
94479: LD_ADDR_EXP 148
94483: PUSH
94484: LD_INT 1
94486: ST_TO_ADDR
// if p3 = 34 then
94487: LD_VAR 0 3
94491: PUSH
94492: LD_INT 34
94494: EQUAL
94495: IFFALSE 94505
// sShield := true ;
94497: LD_ADDR_EXP 149
94501: PUSH
94502: LD_INT 1
94504: ST_TO_ADDR
// if p3 = 35 then
94505: LD_VAR 0 3
94509: PUSH
94510: LD_INT 35
94512: EQUAL
94513: IFFALSE 94523
// sTime := true ;
94515: LD_ADDR_EXP 150
94519: PUSH
94520: LD_INT 1
94522: ST_TO_ADDR
// if p3 = 36 then
94523: LD_VAR 0 3
94527: PUSH
94528: LD_INT 36
94530: EQUAL
94531: IFFALSE 94541
// sTools := true ;
94533: LD_ADDR_EXP 151
94537: PUSH
94538: LD_INT 1
94540: ST_TO_ADDR
// if p3 = 101 then
94541: LD_VAR 0 3
94545: PUSH
94546: LD_INT 101
94548: EQUAL
94549: IFFALSE 94559
// sSold := true ;
94551: LD_ADDR_EXP 116
94555: PUSH
94556: LD_INT 1
94558: ST_TO_ADDR
// if p3 = 102 then
94559: LD_VAR 0 3
94563: PUSH
94564: LD_INT 102
94566: EQUAL
94567: IFFALSE 94577
// sDiff := true ;
94569: LD_ADDR_EXP 117
94573: PUSH
94574: LD_INT 1
94576: ST_TO_ADDR
// if p3 = 103 then
94577: LD_VAR 0 3
94581: PUSH
94582: LD_INT 103
94584: EQUAL
94585: IFFALSE 94595
// sFog := true ;
94587: LD_ADDR_EXP 120
94591: PUSH
94592: LD_INT 1
94594: ST_TO_ADDR
// if p3 = 104 then
94595: LD_VAR 0 3
94599: PUSH
94600: LD_INT 104
94602: EQUAL
94603: IFFALSE 94613
// sReset := true ;
94605: LD_ADDR_EXP 121
94609: PUSH
94610: LD_INT 1
94612: ST_TO_ADDR
// if p3 = 105 then
94613: LD_VAR 0 3
94617: PUSH
94618: LD_INT 105
94620: EQUAL
94621: IFFALSE 94631
// sSun := true ;
94623: LD_ADDR_EXP 122
94627: PUSH
94628: LD_INT 1
94630: ST_TO_ADDR
// if p3 = 106 then
94631: LD_VAR 0 3
94635: PUSH
94636: LD_INT 106
94638: EQUAL
94639: IFFALSE 94649
// sTiger := true ;
94641: LD_ADDR_EXP 118
94645: PUSH
94646: LD_INT 1
94648: ST_TO_ADDR
// if p3 = 107 then
94649: LD_VAR 0 3
94653: PUSH
94654: LD_INT 107
94656: EQUAL
94657: IFFALSE 94667
// sBomb := true ;
94659: LD_ADDR_EXP 119
94663: PUSH
94664: LD_INT 1
94666: ST_TO_ADDR
// if p3 = 108 then
94667: LD_VAR 0 3
94671: PUSH
94672: LD_INT 108
94674: EQUAL
94675: IFFALSE 94685
// sWound := true ;
94677: LD_ADDR_EXP 127
94681: PUSH
94682: LD_INT 1
94684: ST_TO_ADDR
// if p3 = 109 then
94685: LD_VAR 0 3
94689: PUSH
94690: LD_INT 109
94692: EQUAL
94693: IFFALSE 94703
// sBetray := true ;
94695: LD_ADDR_EXP 131
94699: PUSH
94700: LD_INT 1
94702: ST_TO_ADDR
// if p3 = 110 then
94703: LD_VAR 0 3
94707: PUSH
94708: LD_INT 110
94710: EQUAL
94711: IFFALSE 94721
// sContamin := true ;
94713: LD_ADDR_EXP 132
94717: PUSH
94718: LD_INT 1
94720: ST_TO_ADDR
// if p3 = 111 then
94721: LD_VAR 0 3
94725: PUSH
94726: LD_INT 111
94728: EQUAL
94729: IFFALSE 94739
// sOil := true ;
94731: LD_ADDR_EXP 134
94735: PUSH
94736: LD_INT 1
94738: ST_TO_ADDR
// if p3 = 112 then
94739: LD_VAR 0 3
94743: PUSH
94744: LD_INT 112
94746: EQUAL
94747: IFFALSE 94757
// sStu := true ;
94749: LD_ADDR_EXP 138
94753: PUSH
94754: LD_INT 1
94756: ST_TO_ADDR
// if p3 = 113 then
94757: LD_VAR 0 3
94761: PUSH
94762: LD_INT 113
94764: EQUAL
94765: IFFALSE 94775
// sBazooka := true ;
94767: LD_ADDR_EXP 141
94771: PUSH
94772: LD_INT 1
94774: ST_TO_ADDR
// if p3 = 114 then
94775: LD_VAR 0 3
94779: PUSH
94780: LD_INT 114
94782: EQUAL
94783: IFFALSE 94793
// sMortar := true ;
94785: LD_ADDR_EXP 142
94789: PUSH
94790: LD_INT 1
94792: ST_TO_ADDR
// if p3 = 115 then
94793: LD_VAR 0 3
94797: PUSH
94798: LD_INT 115
94800: EQUAL
94801: IFFALSE 94811
// sRanger := true ;
94803: LD_ADDR_EXP 152
94807: PUSH
94808: LD_INT 1
94810: ST_TO_ADDR
// if p3 = 116 then
94811: LD_VAR 0 3
94815: PUSH
94816: LD_INT 116
94818: EQUAL
94819: IFFALSE 94829
// sComputer := true ;
94821: LD_ADDR_EXP 153
94825: PUSH
94826: LD_INT 1
94828: ST_TO_ADDR
// if p3 = 117 then
94829: LD_VAR 0 3
94833: PUSH
94834: LD_INT 117
94836: EQUAL
94837: IFFALSE 94847
// s30 := true ;
94839: LD_ADDR_EXP 154
94843: PUSH
94844: LD_INT 1
94846: ST_TO_ADDR
// if p3 = 118 then
94847: LD_VAR 0 3
94851: PUSH
94852: LD_INT 118
94854: EQUAL
94855: IFFALSE 94865
// s60 := true ;
94857: LD_ADDR_EXP 155
94861: PUSH
94862: LD_INT 1
94864: ST_TO_ADDR
// end ; if p2 = hack_mode then
94865: LD_VAR 0 2
94869: PUSH
94870: LD_INT 101
94872: EQUAL
94873: IFFALSE 95001
// begin case p3 of 1 :
94875: LD_VAR 0 3
94879: PUSH
94880: LD_INT 1
94882: DOUBLE
94883: EQUAL
94884: IFTRUE 94888
94886: GO 94895
94888: POP
// hHackUnlimitedResources ; 2 :
94889: CALL 107140 0 0
94893: GO 95001
94895: LD_INT 2
94897: DOUBLE
94898: EQUAL
94899: IFTRUE 94903
94901: GO 94910
94903: POP
// hHackSetLevel10 ; 3 :
94904: CALL 107273 0 0
94908: GO 95001
94910: LD_INT 3
94912: DOUBLE
94913: EQUAL
94914: IFTRUE 94918
94916: GO 94925
94918: POP
// hHackSetLevel10YourUnits ; 4 :
94919: CALL 107358 0 0
94923: GO 95001
94925: LD_INT 4
94927: DOUBLE
94928: EQUAL
94929: IFTRUE 94933
94931: GO 94940
94933: POP
// hHackInvincible ; 5 :
94934: CALL 107806 0 0
94938: GO 95001
94940: LD_INT 5
94942: DOUBLE
94943: EQUAL
94944: IFTRUE 94948
94946: GO 94955
94948: POP
// hHackInvisible ; 6 :
94949: CALL 107917 0 0
94953: GO 95001
94955: LD_INT 6
94957: DOUBLE
94958: EQUAL
94959: IFTRUE 94963
94961: GO 94970
94963: POP
// hHackChangeYourSide ; 7 :
94964: CALL 107974 0 0
94968: GO 95001
94970: LD_INT 7
94972: DOUBLE
94973: EQUAL
94974: IFTRUE 94978
94976: GO 94985
94978: POP
// hHackChangeUnitSide ; 8 :
94979: CALL 108016 0 0
94983: GO 95001
94985: LD_INT 8
94987: DOUBLE
94988: EQUAL
94989: IFTRUE 94993
94991: GO 95000
94993: POP
// hHackFog ; end ;
94994: CALL 108117 0 0
94998: GO 95001
95000: POP
// end ; if p2 = game_save_mode then
95001: LD_VAR 0 2
95005: PUSH
95006: LD_INT 102
95008: EQUAL
95009: IFFALSE 95064
// begin if p3 = 1 then
95011: LD_VAR 0 3
95015: PUSH
95016: LD_INT 1
95018: EQUAL
95019: IFFALSE 95031
// globalGameSaveCounter := p4 ;
95021: LD_ADDR_EXP 98
95025: PUSH
95026: LD_VAR 0 4
95030: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95031: LD_VAR 0 3
95035: PUSH
95036: LD_INT 2
95038: EQUAL
95039: PUSH
95040: LD_EXP 98
95044: AND
95045: IFFALSE 95064
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95047: LD_STRING setGameSaveCounter(
95049: PUSH
95050: LD_EXP 98
95054: STR
95055: PUSH
95056: LD_STRING )
95058: STR
95059: PPUSH
95060: CALL_OW 559
// end ; end ;
95064: LD_VAR 0 7
95068: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95069: LD_INT 0
95071: PPUSH
// streamModeActive := false ;
95072: LD_ADDR_EXP 99
95076: PUSH
95077: LD_INT 0
95079: ST_TO_ADDR
// normalCounter := 36 ;
95080: LD_ADDR_EXP 100
95084: PUSH
95085: LD_INT 36
95087: ST_TO_ADDR
// hardcoreCounter := 18 ;
95088: LD_ADDR_EXP 101
95092: PUSH
95093: LD_INT 18
95095: ST_TO_ADDR
// sRocket := false ;
95096: LD_ADDR_EXP 104
95100: PUSH
95101: LD_INT 0
95103: ST_TO_ADDR
// sSpeed := false ;
95104: LD_ADDR_EXP 103
95108: PUSH
95109: LD_INT 0
95111: ST_TO_ADDR
// sEngine := false ;
95112: LD_ADDR_EXP 105
95116: PUSH
95117: LD_INT 0
95119: ST_TO_ADDR
// sSpec := false ;
95120: LD_ADDR_EXP 102
95124: PUSH
95125: LD_INT 0
95127: ST_TO_ADDR
// sLevel := false ;
95128: LD_ADDR_EXP 106
95132: PUSH
95133: LD_INT 0
95135: ST_TO_ADDR
// sArmoury := false ;
95136: LD_ADDR_EXP 107
95140: PUSH
95141: LD_INT 0
95143: ST_TO_ADDR
// sRadar := false ;
95144: LD_ADDR_EXP 108
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// sBunker := false ;
95152: LD_ADDR_EXP 109
95156: PUSH
95157: LD_INT 0
95159: ST_TO_ADDR
// sHack := false ;
95160: LD_ADDR_EXP 110
95164: PUSH
95165: LD_INT 0
95167: ST_TO_ADDR
// sFire := false ;
95168: LD_ADDR_EXP 111
95172: PUSH
95173: LD_INT 0
95175: ST_TO_ADDR
// sRefresh := false ;
95176: LD_ADDR_EXP 112
95180: PUSH
95181: LD_INT 0
95183: ST_TO_ADDR
// sExp := false ;
95184: LD_ADDR_EXP 113
95188: PUSH
95189: LD_INT 0
95191: ST_TO_ADDR
// sDepot := false ;
95192: LD_ADDR_EXP 114
95196: PUSH
95197: LD_INT 0
95199: ST_TO_ADDR
// sFlag := false ;
95200: LD_ADDR_EXP 115
95204: PUSH
95205: LD_INT 0
95207: ST_TO_ADDR
// sKamikadze := false ;
95208: LD_ADDR_EXP 123
95212: PUSH
95213: LD_INT 0
95215: ST_TO_ADDR
// sTroll := false ;
95216: LD_ADDR_EXP 124
95220: PUSH
95221: LD_INT 0
95223: ST_TO_ADDR
// sSlow := false ;
95224: LD_ADDR_EXP 125
95228: PUSH
95229: LD_INT 0
95231: ST_TO_ADDR
// sLack := false ;
95232: LD_ADDR_EXP 126
95236: PUSH
95237: LD_INT 0
95239: ST_TO_ADDR
// sTank := false ;
95240: LD_ADDR_EXP 128
95244: PUSH
95245: LD_INT 0
95247: ST_TO_ADDR
// sRemote := false ;
95248: LD_ADDR_EXP 129
95252: PUSH
95253: LD_INT 0
95255: ST_TO_ADDR
// sPowell := false ;
95256: LD_ADDR_EXP 130
95260: PUSH
95261: LD_INT 0
95263: ST_TO_ADDR
// sTeleport := false ;
95264: LD_ADDR_EXP 133
95268: PUSH
95269: LD_INT 0
95271: ST_TO_ADDR
// sOilTower := false ;
95272: LD_ADDR_EXP 135
95276: PUSH
95277: LD_INT 0
95279: ST_TO_ADDR
// sShovel := false ;
95280: LD_ADDR_EXP 136
95284: PUSH
95285: LD_INT 0
95287: ST_TO_ADDR
// sSheik := false ;
95288: LD_ADDR_EXP 137
95292: PUSH
95293: LD_INT 0
95295: ST_TO_ADDR
// sEarthquake := false ;
95296: LD_ADDR_EXP 139
95300: PUSH
95301: LD_INT 0
95303: ST_TO_ADDR
// sAI := false ;
95304: LD_ADDR_EXP 140
95308: PUSH
95309: LD_INT 0
95311: ST_TO_ADDR
// sCargo := false ;
95312: LD_ADDR_EXP 143
95316: PUSH
95317: LD_INT 0
95319: ST_TO_ADDR
// sDLaser := false ;
95320: LD_ADDR_EXP 144
95324: PUSH
95325: LD_INT 0
95327: ST_TO_ADDR
// sExchange := false ;
95328: LD_ADDR_EXP 145
95332: PUSH
95333: LD_INT 0
95335: ST_TO_ADDR
// sFac := false ;
95336: LD_ADDR_EXP 146
95340: PUSH
95341: LD_INT 0
95343: ST_TO_ADDR
// sPower := false ;
95344: LD_ADDR_EXP 147
95348: PUSH
95349: LD_INT 0
95351: ST_TO_ADDR
// sRandom := false ;
95352: LD_ADDR_EXP 148
95356: PUSH
95357: LD_INT 0
95359: ST_TO_ADDR
// sShield := false ;
95360: LD_ADDR_EXP 149
95364: PUSH
95365: LD_INT 0
95367: ST_TO_ADDR
// sTime := false ;
95368: LD_ADDR_EXP 150
95372: PUSH
95373: LD_INT 0
95375: ST_TO_ADDR
// sTools := false ;
95376: LD_ADDR_EXP 151
95380: PUSH
95381: LD_INT 0
95383: ST_TO_ADDR
// sSold := false ;
95384: LD_ADDR_EXP 116
95388: PUSH
95389: LD_INT 0
95391: ST_TO_ADDR
// sDiff := false ;
95392: LD_ADDR_EXP 117
95396: PUSH
95397: LD_INT 0
95399: ST_TO_ADDR
// sFog := false ;
95400: LD_ADDR_EXP 120
95404: PUSH
95405: LD_INT 0
95407: ST_TO_ADDR
// sReset := false ;
95408: LD_ADDR_EXP 121
95412: PUSH
95413: LD_INT 0
95415: ST_TO_ADDR
// sSun := false ;
95416: LD_ADDR_EXP 122
95420: PUSH
95421: LD_INT 0
95423: ST_TO_ADDR
// sTiger := false ;
95424: LD_ADDR_EXP 118
95428: PUSH
95429: LD_INT 0
95431: ST_TO_ADDR
// sBomb := false ;
95432: LD_ADDR_EXP 119
95436: PUSH
95437: LD_INT 0
95439: ST_TO_ADDR
// sWound := false ;
95440: LD_ADDR_EXP 127
95444: PUSH
95445: LD_INT 0
95447: ST_TO_ADDR
// sBetray := false ;
95448: LD_ADDR_EXP 131
95452: PUSH
95453: LD_INT 0
95455: ST_TO_ADDR
// sContamin := false ;
95456: LD_ADDR_EXP 132
95460: PUSH
95461: LD_INT 0
95463: ST_TO_ADDR
// sOil := false ;
95464: LD_ADDR_EXP 134
95468: PUSH
95469: LD_INT 0
95471: ST_TO_ADDR
// sStu := false ;
95472: LD_ADDR_EXP 138
95476: PUSH
95477: LD_INT 0
95479: ST_TO_ADDR
// sBazooka := false ;
95480: LD_ADDR_EXP 141
95484: PUSH
95485: LD_INT 0
95487: ST_TO_ADDR
// sMortar := false ;
95488: LD_ADDR_EXP 142
95492: PUSH
95493: LD_INT 0
95495: ST_TO_ADDR
// sRanger := false ;
95496: LD_ADDR_EXP 152
95500: PUSH
95501: LD_INT 0
95503: ST_TO_ADDR
// sComputer := false ;
95504: LD_ADDR_EXP 153
95508: PUSH
95509: LD_INT 0
95511: ST_TO_ADDR
// s30 := false ;
95512: LD_ADDR_EXP 154
95516: PUSH
95517: LD_INT 0
95519: ST_TO_ADDR
// s60 := false ;
95520: LD_ADDR_EXP 155
95524: PUSH
95525: LD_INT 0
95527: ST_TO_ADDR
// end ;
95528: LD_VAR 0 1
95532: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95533: LD_INT 0
95535: PPUSH
95536: PPUSH
95537: PPUSH
95538: PPUSH
95539: PPUSH
95540: PPUSH
95541: PPUSH
// result := [ ] ;
95542: LD_ADDR_VAR 0 2
95546: PUSH
95547: EMPTY
95548: ST_TO_ADDR
// if campaign_id = 1 then
95549: LD_OWVAR 69
95553: PUSH
95554: LD_INT 1
95556: EQUAL
95557: IFFALSE 98723
// begin case mission_number of 1 :
95559: LD_OWVAR 70
95563: PUSH
95564: LD_INT 1
95566: DOUBLE
95567: EQUAL
95568: IFTRUE 95572
95570: GO 95648
95572: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95573: LD_ADDR_VAR 0 2
95577: PUSH
95578: LD_INT 2
95580: PUSH
95581: LD_INT 4
95583: PUSH
95584: LD_INT 11
95586: PUSH
95587: LD_INT 12
95589: PUSH
95590: LD_INT 15
95592: PUSH
95593: LD_INT 16
95595: PUSH
95596: LD_INT 22
95598: PUSH
95599: LD_INT 23
95601: PUSH
95602: LD_INT 26
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 101
95618: PUSH
95619: LD_INT 102
95621: PUSH
95622: LD_INT 106
95624: PUSH
95625: LD_INT 116
95627: PUSH
95628: LD_INT 117
95630: PUSH
95631: LD_INT 118
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: ST_TO_ADDR
95646: GO 98721
95648: LD_INT 2
95650: DOUBLE
95651: EQUAL
95652: IFTRUE 95656
95654: GO 95740
95656: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95657: LD_ADDR_VAR 0 2
95661: PUSH
95662: LD_INT 2
95664: PUSH
95665: LD_INT 4
95667: PUSH
95668: LD_INT 11
95670: PUSH
95671: LD_INT 12
95673: PUSH
95674: LD_INT 15
95676: PUSH
95677: LD_INT 16
95679: PUSH
95680: LD_INT 22
95682: PUSH
95683: LD_INT 23
95685: PUSH
95686: LD_INT 26
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 101
95702: PUSH
95703: LD_INT 102
95705: PUSH
95706: LD_INT 105
95708: PUSH
95709: LD_INT 106
95711: PUSH
95712: LD_INT 108
95714: PUSH
95715: LD_INT 116
95717: PUSH
95718: LD_INT 117
95720: PUSH
95721: LD_INT 118
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: ST_TO_ADDR
95738: GO 98721
95740: LD_INT 3
95742: DOUBLE
95743: EQUAL
95744: IFTRUE 95748
95746: GO 95836
95748: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95749: LD_ADDR_VAR 0 2
95753: PUSH
95754: LD_INT 2
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: LD_INT 5
95762: PUSH
95763: LD_INT 11
95765: PUSH
95766: LD_INT 12
95768: PUSH
95769: LD_INT 15
95771: PUSH
95772: LD_INT 16
95774: PUSH
95775: LD_INT 22
95777: PUSH
95778: LD_INT 26
95780: PUSH
95781: LD_INT 36
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 101
95798: PUSH
95799: LD_INT 102
95801: PUSH
95802: LD_INT 105
95804: PUSH
95805: LD_INT 106
95807: PUSH
95808: LD_INT 108
95810: PUSH
95811: LD_INT 116
95813: PUSH
95814: LD_INT 117
95816: PUSH
95817: LD_INT 118
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: ST_TO_ADDR
95834: GO 98721
95836: LD_INT 4
95838: DOUBLE
95839: EQUAL
95840: IFTRUE 95844
95842: GO 95940
95844: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95845: LD_ADDR_VAR 0 2
95849: PUSH
95850: LD_INT 2
95852: PUSH
95853: LD_INT 4
95855: PUSH
95856: LD_INT 5
95858: PUSH
95859: LD_INT 8
95861: PUSH
95862: LD_INT 11
95864: PUSH
95865: LD_INT 12
95867: PUSH
95868: LD_INT 15
95870: PUSH
95871: LD_INT 16
95873: PUSH
95874: LD_INT 22
95876: PUSH
95877: LD_INT 23
95879: PUSH
95880: LD_INT 26
95882: PUSH
95883: LD_INT 36
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: PUSH
95900: LD_INT 101
95902: PUSH
95903: LD_INT 102
95905: PUSH
95906: LD_INT 105
95908: PUSH
95909: LD_INT 106
95911: PUSH
95912: LD_INT 108
95914: PUSH
95915: LD_INT 116
95917: PUSH
95918: LD_INT 117
95920: PUSH
95921: LD_INT 118
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: ST_TO_ADDR
95938: GO 98721
95940: LD_INT 5
95942: DOUBLE
95943: EQUAL
95944: IFTRUE 95948
95946: GO 96060
95948: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95949: LD_ADDR_VAR 0 2
95953: PUSH
95954: LD_INT 2
95956: PUSH
95957: LD_INT 4
95959: PUSH
95960: LD_INT 5
95962: PUSH
95963: LD_INT 6
95965: PUSH
95966: LD_INT 8
95968: PUSH
95969: LD_INT 11
95971: PUSH
95972: LD_INT 12
95974: PUSH
95975: LD_INT 15
95977: PUSH
95978: LD_INT 16
95980: PUSH
95981: LD_INT 22
95983: PUSH
95984: LD_INT 23
95986: PUSH
95987: LD_INT 25
95989: PUSH
95990: LD_INT 26
95992: PUSH
95993: LD_INT 36
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 101
96014: PUSH
96015: LD_INT 102
96017: PUSH
96018: LD_INT 105
96020: PUSH
96021: LD_INT 106
96023: PUSH
96024: LD_INT 108
96026: PUSH
96027: LD_INT 109
96029: PUSH
96030: LD_INT 112
96032: PUSH
96033: LD_INT 116
96035: PUSH
96036: LD_INT 117
96038: PUSH
96039: LD_INT 118
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: ST_TO_ADDR
96058: GO 98721
96060: LD_INT 6
96062: DOUBLE
96063: EQUAL
96064: IFTRUE 96068
96066: GO 96200
96068: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96069: LD_ADDR_VAR 0 2
96073: PUSH
96074: LD_INT 2
96076: PUSH
96077: LD_INT 4
96079: PUSH
96080: LD_INT 5
96082: PUSH
96083: LD_INT 6
96085: PUSH
96086: LD_INT 8
96088: PUSH
96089: LD_INT 11
96091: PUSH
96092: LD_INT 12
96094: PUSH
96095: LD_INT 15
96097: PUSH
96098: LD_INT 16
96100: PUSH
96101: LD_INT 20
96103: PUSH
96104: LD_INT 21
96106: PUSH
96107: LD_INT 22
96109: PUSH
96110: LD_INT 23
96112: PUSH
96113: LD_INT 25
96115: PUSH
96116: LD_INT 26
96118: PUSH
96119: LD_INT 30
96121: PUSH
96122: LD_INT 31
96124: PUSH
96125: LD_INT 32
96127: PUSH
96128: LD_INT 36
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 101
96154: PUSH
96155: LD_INT 102
96157: PUSH
96158: LD_INT 105
96160: PUSH
96161: LD_INT 106
96163: PUSH
96164: LD_INT 108
96166: PUSH
96167: LD_INT 109
96169: PUSH
96170: LD_INT 112
96172: PUSH
96173: LD_INT 116
96175: PUSH
96176: LD_INT 117
96178: PUSH
96179: LD_INT 118
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: ST_TO_ADDR
96198: GO 98721
96200: LD_INT 7
96202: DOUBLE
96203: EQUAL
96204: IFTRUE 96208
96206: GO 96320
96208: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96209: LD_ADDR_VAR 0 2
96213: PUSH
96214: LD_INT 2
96216: PUSH
96217: LD_INT 4
96219: PUSH
96220: LD_INT 5
96222: PUSH
96223: LD_INT 7
96225: PUSH
96226: LD_INT 11
96228: PUSH
96229: LD_INT 12
96231: PUSH
96232: LD_INT 15
96234: PUSH
96235: LD_INT 16
96237: PUSH
96238: LD_INT 20
96240: PUSH
96241: LD_INT 21
96243: PUSH
96244: LD_INT 22
96246: PUSH
96247: LD_INT 23
96249: PUSH
96250: LD_INT 25
96252: PUSH
96253: LD_INT 26
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 101
96274: PUSH
96275: LD_INT 102
96277: PUSH
96278: LD_INT 103
96280: PUSH
96281: LD_INT 105
96283: PUSH
96284: LD_INT 106
96286: PUSH
96287: LD_INT 108
96289: PUSH
96290: LD_INT 112
96292: PUSH
96293: LD_INT 116
96295: PUSH
96296: LD_INT 117
96298: PUSH
96299: LD_INT 118
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: ST_TO_ADDR
96318: GO 98721
96320: LD_INT 8
96322: DOUBLE
96323: EQUAL
96324: IFTRUE 96328
96326: GO 96468
96328: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96329: LD_ADDR_VAR 0 2
96333: PUSH
96334: LD_INT 2
96336: PUSH
96337: LD_INT 4
96339: PUSH
96340: LD_INT 5
96342: PUSH
96343: LD_INT 6
96345: PUSH
96346: LD_INT 7
96348: PUSH
96349: LD_INT 8
96351: PUSH
96352: LD_INT 11
96354: PUSH
96355: LD_INT 12
96357: PUSH
96358: LD_INT 15
96360: PUSH
96361: LD_INT 16
96363: PUSH
96364: LD_INT 20
96366: PUSH
96367: LD_INT 21
96369: PUSH
96370: LD_INT 22
96372: PUSH
96373: LD_INT 23
96375: PUSH
96376: LD_INT 25
96378: PUSH
96379: LD_INT 26
96381: PUSH
96382: LD_INT 30
96384: PUSH
96385: LD_INT 31
96387: PUSH
96388: LD_INT 32
96390: PUSH
96391: LD_INT 36
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 101
96418: PUSH
96419: LD_INT 102
96421: PUSH
96422: LD_INT 103
96424: PUSH
96425: LD_INT 105
96427: PUSH
96428: LD_INT 106
96430: PUSH
96431: LD_INT 108
96433: PUSH
96434: LD_INT 109
96436: PUSH
96437: LD_INT 112
96439: PUSH
96440: LD_INT 116
96442: PUSH
96443: LD_INT 117
96445: PUSH
96446: LD_INT 118
96448: PUSH
96449: EMPTY
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: ST_TO_ADDR
96466: GO 98721
96468: LD_INT 9
96470: DOUBLE
96471: EQUAL
96472: IFTRUE 96476
96474: GO 96624
96476: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96477: LD_ADDR_VAR 0 2
96481: PUSH
96482: LD_INT 2
96484: PUSH
96485: LD_INT 4
96487: PUSH
96488: LD_INT 5
96490: PUSH
96491: LD_INT 6
96493: PUSH
96494: LD_INT 7
96496: PUSH
96497: LD_INT 8
96499: PUSH
96500: LD_INT 11
96502: PUSH
96503: LD_INT 12
96505: PUSH
96506: LD_INT 15
96508: PUSH
96509: LD_INT 16
96511: PUSH
96512: LD_INT 20
96514: PUSH
96515: LD_INT 21
96517: PUSH
96518: LD_INT 22
96520: PUSH
96521: LD_INT 23
96523: PUSH
96524: LD_INT 25
96526: PUSH
96527: LD_INT 26
96529: PUSH
96530: LD_INT 28
96532: PUSH
96533: LD_INT 30
96535: PUSH
96536: LD_INT 31
96538: PUSH
96539: LD_INT 32
96541: PUSH
96542: LD_INT 36
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: PUSH
96568: LD_INT 101
96570: PUSH
96571: LD_INT 102
96573: PUSH
96574: LD_INT 103
96576: PUSH
96577: LD_INT 105
96579: PUSH
96580: LD_INT 106
96582: PUSH
96583: LD_INT 108
96585: PUSH
96586: LD_INT 109
96588: PUSH
96589: LD_INT 112
96591: PUSH
96592: LD_INT 114
96594: PUSH
96595: LD_INT 116
96597: PUSH
96598: LD_INT 117
96600: PUSH
96601: LD_INT 118
96603: PUSH
96604: EMPTY
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: ST_TO_ADDR
96622: GO 98721
96624: LD_INT 10
96626: DOUBLE
96627: EQUAL
96628: IFTRUE 96632
96630: GO 96828
96632: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96633: LD_ADDR_VAR 0 2
96637: PUSH
96638: LD_INT 2
96640: PUSH
96641: LD_INT 4
96643: PUSH
96644: LD_INT 5
96646: PUSH
96647: LD_INT 6
96649: PUSH
96650: LD_INT 7
96652: PUSH
96653: LD_INT 8
96655: PUSH
96656: LD_INT 9
96658: PUSH
96659: LD_INT 10
96661: PUSH
96662: LD_INT 11
96664: PUSH
96665: LD_INT 12
96667: PUSH
96668: LD_INT 13
96670: PUSH
96671: LD_INT 14
96673: PUSH
96674: LD_INT 15
96676: PUSH
96677: LD_INT 16
96679: PUSH
96680: LD_INT 17
96682: PUSH
96683: LD_INT 18
96685: PUSH
96686: LD_INT 19
96688: PUSH
96689: LD_INT 20
96691: PUSH
96692: LD_INT 21
96694: PUSH
96695: LD_INT 22
96697: PUSH
96698: LD_INT 23
96700: PUSH
96701: LD_INT 24
96703: PUSH
96704: LD_INT 25
96706: PUSH
96707: LD_INT 26
96709: PUSH
96710: LD_INT 28
96712: PUSH
96713: LD_INT 30
96715: PUSH
96716: LD_INT 31
96718: PUSH
96719: LD_INT 32
96721: PUSH
96722: LD_INT 36
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 101
96758: PUSH
96759: LD_INT 102
96761: PUSH
96762: LD_INT 103
96764: PUSH
96765: LD_INT 104
96767: PUSH
96768: LD_INT 105
96770: PUSH
96771: LD_INT 106
96773: PUSH
96774: LD_INT 107
96776: PUSH
96777: LD_INT 108
96779: PUSH
96780: LD_INT 109
96782: PUSH
96783: LD_INT 110
96785: PUSH
96786: LD_INT 111
96788: PUSH
96789: LD_INT 112
96791: PUSH
96792: LD_INT 114
96794: PUSH
96795: LD_INT 116
96797: PUSH
96798: LD_INT 117
96800: PUSH
96801: LD_INT 118
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: ST_TO_ADDR
96826: GO 98721
96828: LD_INT 11
96830: DOUBLE
96831: EQUAL
96832: IFTRUE 96836
96834: GO 97040
96836: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96837: LD_ADDR_VAR 0 2
96841: PUSH
96842: LD_INT 2
96844: PUSH
96845: LD_INT 3
96847: PUSH
96848: LD_INT 4
96850: PUSH
96851: LD_INT 5
96853: PUSH
96854: LD_INT 6
96856: PUSH
96857: LD_INT 7
96859: PUSH
96860: LD_INT 8
96862: PUSH
96863: LD_INT 9
96865: PUSH
96866: LD_INT 10
96868: PUSH
96869: LD_INT 11
96871: PUSH
96872: LD_INT 12
96874: PUSH
96875: LD_INT 13
96877: PUSH
96878: LD_INT 14
96880: PUSH
96881: LD_INT 15
96883: PUSH
96884: LD_INT 16
96886: PUSH
96887: LD_INT 17
96889: PUSH
96890: LD_INT 18
96892: PUSH
96893: LD_INT 19
96895: PUSH
96896: LD_INT 20
96898: PUSH
96899: LD_INT 21
96901: PUSH
96902: LD_INT 22
96904: PUSH
96905: LD_INT 23
96907: PUSH
96908: LD_INT 24
96910: PUSH
96911: LD_INT 25
96913: PUSH
96914: LD_INT 26
96916: PUSH
96917: LD_INT 28
96919: PUSH
96920: LD_INT 30
96922: PUSH
96923: LD_INT 31
96925: PUSH
96926: LD_INT 32
96928: PUSH
96929: LD_INT 34
96931: PUSH
96932: LD_INT 36
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: PUSH
96968: LD_INT 101
96970: PUSH
96971: LD_INT 102
96973: PUSH
96974: LD_INT 103
96976: PUSH
96977: LD_INT 104
96979: PUSH
96980: LD_INT 105
96982: PUSH
96983: LD_INT 106
96985: PUSH
96986: LD_INT 107
96988: PUSH
96989: LD_INT 108
96991: PUSH
96992: LD_INT 109
96994: PUSH
96995: LD_INT 110
96997: PUSH
96998: LD_INT 111
97000: PUSH
97001: LD_INT 112
97003: PUSH
97004: LD_INT 114
97006: PUSH
97007: LD_INT 116
97009: PUSH
97010: LD_INT 117
97012: PUSH
97013: LD_INT 118
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: ST_TO_ADDR
97038: GO 98721
97040: LD_INT 12
97042: DOUBLE
97043: EQUAL
97044: IFTRUE 97048
97046: GO 97268
97048: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97049: LD_ADDR_VAR 0 2
97053: PUSH
97054: LD_INT 1
97056: PUSH
97057: LD_INT 2
97059: PUSH
97060: LD_INT 3
97062: PUSH
97063: LD_INT 4
97065: PUSH
97066: LD_INT 5
97068: PUSH
97069: LD_INT 6
97071: PUSH
97072: LD_INT 7
97074: PUSH
97075: LD_INT 8
97077: PUSH
97078: LD_INT 9
97080: PUSH
97081: LD_INT 10
97083: PUSH
97084: LD_INT 11
97086: PUSH
97087: LD_INT 12
97089: PUSH
97090: LD_INT 13
97092: PUSH
97093: LD_INT 14
97095: PUSH
97096: LD_INT 15
97098: PUSH
97099: LD_INT 16
97101: PUSH
97102: LD_INT 17
97104: PUSH
97105: LD_INT 18
97107: PUSH
97108: LD_INT 19
97110: PUSH
97111: LD_INT 20
97113: PUSH
97114: LD_INT 21
97116: PUSH
97117: LD_INT 22
97119: PUSH
97120: LD_INT 23
97122: PUSH
97123: LD_INT 24
97125: PUSH
97126: LD_INT 25
97128: PUSH
97129: LD_INT 26
97131: PUSH
97132: LD_INT 27
97134: PUSH
97135: LD_INT 28
97137: PUSH
97138: LD_INT 30
97140: PUSH
97141: LD_INT 31
97143: PUSH
97144: LD_INT 32
97146: PUSH
97147: LD_INT 33
97149: PUSH
97150: LD_INT 34
97152: PUSH
97153: LD_INT 36
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 101
97194: PUSH
97195: LD_INT 102
97197: PUSH
97198: LD_INT 103
97200: PUSH
97201: LD_INT 104
97203: PUSH
97204: LD_INT 105
97206: PUSH
97207: LD_INT 106
97209: PUSH
97210: LD_INT 107
97212: PUSH
97213: LD_INT 108
97215: PUSH
97216: LD_INT 109
97218: PUSH
97219: LD_INT 110
97221: PUSH
97222: LD_INT 111
97224: PUSH
97225: LD_INT 112
97227: PUSH
97228: LD_INT 113
97230: PUSH
97231: LD_INT 114
97233: PUSH
97234: LD_INT 116
97236: PUSH
97237: LD_INT 117
97239: PUSH
97240: LD_INT 118
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: ST_TO_ADDR
97266: GO 98721
97268: LD_INT 13
97270: DOUBLE
97271: EQUAL
97272: IFTRUE 97276
97274: GO 97484
97276: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97277: LD_ADDR_VAR 0 2
97281: PUSH
97282: LD_INT 1
97284: PUSH
97285: LD_INT 2
97287: PUSH
97288: LD_INT 3
97290: PUSH
97291: LD_INT 4
97293: PUSH
97294: LD_INT 5
97296: PUSH
97297: LD_INT 8
97299: PUSH
97300: LD_INT 9
97302: PUSH
97303: LD_INT 10
97305: PUSH
97306: LD_INT 11
97308: PUSH
97309: LD_INT 12
97311: PUSH
97312: LD_INT 14
97314: PUSH
97315: LD_INT 15
97317: PUSH
97318: LD_INT 16
97320: PUSH
97321: LD_INT 17
97323: PUSH
97324: LD_INT 18
97326: PUSH
97327: LD_INT 19
97329: PUSH
97330: LD_INT 20
97332: PUSH
97333: LD_INT 21
97335: PUSH
97336: LD_INT 22
97338: PUSH
97339: LD_INT 23
97341: PUSH
97342: LD_INT 24
97344: PUSH
97345: LD_INT 25
97347: PUSH
97348: LD_INT 26
97350: PUSH
97351: LD_INT 27
97353: PUSH
97354: LD_INT 28
97356: PUSH
97357: LD_INT 30
97359: PUSH
97360: LD_INT 31
97362: PUSH
97363: LD_INT 32
97365: PUSH
97366: LD_INT 33
97368: PUSH
97369: LD_INT 34
97371: PUSH
97372: LD_INT 36
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 101
97410: PUSH
97411: LD_INT 102
97413: PUSH
97414: LD_INT 103
97416: PUSH
97417: LD_INT 104
97419: PUSH
97420: LD_INT 105
97422: PUSH
97423: LD_INT 106
97425: PUSH
97426: LD_INT 107
97428: PUSH
97429: LD_INT 108
97431: PUSH
97432: LD_INT 109
97434: PUSH
97435: LD_INT 110
97437: PUSH
97438: LD_INT 111
97440: PUSH
97441: LD_INT 112
97443: PUSH
97444: LD_INT 113
97446: PUSH
97447: LD_INT 114
97449: PUSH
97450: LD_INT 116
97452: PUSH
97453: LD_INT 117
97455: PUSH
97456: LD_INT 118
97458: PUSH
97459: EMPTY
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: ST_TO_ADDR
97482: GO 98721
97484: LD_INT 14
97486: DOUBLE
97487: EQUAL
97488: IFTRUE 97492
97490: GO 97716
97492: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97493: LD_ADDR_VAR 0 2
97497: PUSH
97498: LD_INT 1
97500: PUSH
97501: LD_INT 2
97503: PUSH
97504: LD_INT 3
97506: PUSH
97507: LD_INT 4
97509: PUSH
97510: LD_INT 5
97512: PUSH
97513: LD_INT 6
97515: PUSH
97516: LD_INT 7
97518: PUSH
97519: LD_INT 8
97521: PUSH
97522: LD_INT 9
97524: PUSH
97525: LD_INT 10
97527: PUSH
97528: LD_INT 11
97530: PUSH
97531: LD_INT 12
97533: PUSH
97534: LD_INT 13
97536: PUSH
97537: LD_INT 14
97539: PUSH
97540: LD_INT 15
97542: PUSH
97543: LD_INT 16
97545: PUSH
97546: LD_INT 17
97548: PUSH
97549: LD_INT 18
97551: PUSH
97552: LD_INT 19
97554: PUSH
97555: LD_INT 20
97557: PUSH
97558: LD_INT 21
97560: PUSH
97561: LD_INT 22
97563: PUSH
97564: LD_INT 23
97566: PUSH
97567: LD_INT 24
97569: PUSH
97570: LD_INT 25
97572: PUSH
97573: LD_INT 26
97575: PUSH
97576: LD_INT 27
97578: PUSH
97579: LD_INT 28
97581: PUSH
97582: LD_INT 29
97584: PUSH
97585: LD_INT 30
97587: PUSH
97588: LD_INT 31
97590: PUSH
97591: LD_INT 32
97593: PUSH
97594: LD_INT 33
97596: PUSH
97597: LD_INT 34
97599: PUSH
97600: LD_INT 36
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: LIST
97617: LIST
97618: LIST
97619: LIST
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 101
97642: PUSH
97643: LD_INT 102
97645: PUSH
97646: LD_INT 103
97648: PUSH
97649: LD_INT 104
97651: PUSH
97652: LD_INT 105
97654: PUSH
97655: LD_INT 106
97657: PUSH
97658: LD_INT 107
97660: PUSH
97661: LD_INT 108
97663: PUSH
97664: LD_INT 109
97666: PUSH
97667: LD_INT 110
97669: PUSH
97670: LD_INT 111
97672: PUSH
97673: LD_INT 112
97675: PUSH
97676: LD_INT 113
97678: PUSH
97679: LD_INT 114
97681: PUSH
97682: LD_INT 116
97684: PUSH
97685: LD_INT 117
97687: PUSH
97688: LD_INT 118
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: ST_TO_ADDR
97714: GO 98721
97716: LD_INT 15
97718: DOUBLE
97719: EQUAL
97720: IFTRUE 97724
97722: GO 97948
97724: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97725: LD_ADDR_VAR 0 2
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: LD_INT 2
97735: PUSH
97736: LD_INT 3
97738: PUSH
97739: LD_INT 4
97741: PUSH
97742: LD_INT 5
97744: PUSH
97745: LD_INT 6
97747: PUSH
97748: LD_INT 7
97750: PUSH
97751: LD_INT 8
97753: PUSH
97754: LD_INT 9
97756: PUSH
97757: LD_INT 10
97759: PUSH
97760: LD_INT 11
97762: PUSH
97763: LD_INT 12
97765: PUSH
97766: LD_INT 13
97768: PUSH
97769: LD_INT 14
97771: PUSH
97772: LD_INT 15
97774: PUSH
97775: LD_INT 16
97777: PUSH
97778: LD_INT 17
97780: PUSH
97781: LD_INT 18
97783: PUSH
97784: LD_INT 19
97786: PUSH
97787: LD_INT 20
97789: PUSH
97790: LD_INT 21
97792: PUSH
97793: LD_INT 22
97795: PUSH
97796: LD_INT 23
97798: PUSH
97799: LD_INT 24
97801: PUSH
97802: LD_INT 25
97804: PUSH
97805: LD_INT 26
97807: PUSH
97808: LD_INT 27
97810: PUSH
97811: LD_INT 28
97813: PUSH
97814: LD_INT 29
97816: PUSH
97817: LD_INT 30
97819: PUSH
97820: LD_INT 31
97822: PUSH
97823: LD_INT 32
97825: PUSH
97826: LD_INT 33
97828: PUSH
97829: LD_INT 34
97831: PUSH
97832: LD_INT 36
97834: PUSH
97835: EMPTY
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: PUSH
97872: LD_INT 101
97874: PUSH
97875: LD_INT 102
97877: PUSH
97878: LD_INT 103
97880: PUSH
97881: LD_INT 104
97883: PUSH
97884: LD_INT 105
97886: PUSH
97887: LD_INT 106
97889: PUSH
97890: LD_INT 107
97892: PUSH
97893: LD_INT 108
97895: PUSH
97896: LD_INT 109
97898: PUSH
97899: LD_INT 110
97901: PUSH
97902: LD_INT 111
97904: PUSH
97905: LD_INT 112
97907: PUSH
97908: LD_INT 113
97910: PUSH
97911: LD_INT 114
97913: PUSH
97914: LD_INT 116
97916: PUSH
97917: LD_INT 117
97919: PUSH
97920: LD_INT 118
97922: PUSH
97923: EMPTY
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: ST_TO_ADDR
97946: GO 98721
97948: LD_INT 16
97950: DOUBLE
97951: EQUAL
97952: IFTRUE 97956
97954: GO 98092
97956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97957: LD_ADDR_VAR 0 2
97961: PUSH
97962: LD_INT 2
97964: PUSH
97965: LD_INT 4
97967: PUSH
97968: LD_INT 5
97970: PUSH
97971: LD_INT 7
97973: PUSH
97974: LD_INT 11
97976: PUSH
97977: LD_INT 12
97979: PUSH
97980: LD_INT 15
97982: PUSH
97983: LD_INT 16
97985: PUSH
97986: LD_INT 20
97988: PUSH
97989: LD_INT 21
97991: PUSH
97992: LD_INT 22
97994: PUSH
97995: LD_INT 23
97997: PUSH
97998: LD_INT 25
98000: PUSH
98001: LD_INT 26
98003: PUSH
98004: LD_INT 30
98006: PUSH
98007: LD_INT 31
98009: PUSH
98010: LD_INT 32
98012: PUSH
98013: LD_INT 33
98015: PUSH
98016: LD_INT 34
98018: PUSH
98019: EMPTY
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: PUSH
98040: LD_INT 101
98042: PUSH
98043: LD_INT 102
98045: PUSH
98046: LD_INT 103
98048: PUSH
98049: LD_INT 106
98051: PUSH
98052: LD_INT 108
98054: PUSH
98055: LD_INT 112
98057: PUSH
98058: LD_INT 113
98060: PUSH
98061: LD_INT 114
98063: PUSH
98064: LD_INT 116
98066: PUSH
98067: LD_INT 117
98069: PUSH
98070: LD_INT 118
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: PUSH
98086: EMPTY
98087: LIST
98088: LIST
98089: ST_TO_ADDR
98090: GO 98721
98092: LD_INT 17
98094: DOUBLE
98095: EQUAL
98096: IFTRUE 98100
98098: GO 98324
98100: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98101: LD_ADDR_VAR 0 2
98105: PUSH
98106: LD_INT 1
98108: PUSH
98109: LD_INT 2
98111: PUSH
98112: LD_INT 3
98114: PUSH
98115: LD_INT 4
98117: PUSH
98118: LD_INT 5
98120: PUSH
98121: LD_INT 6
98123: PUSH
98124: LD_INT 7
98126: PUSH
98127: LD_INT 8
98129: PUSH
98130: LD_INT 9
98132: PUSH
98133: LD_INT 10
98135: PUSH
98136: LD_INT 11
98138: PUSH
98139: LD_INT 12
98141: PUSH
98142: LD_INT 13
98144: PUSH
98145: LD_INT 14
98147: PUSH
98148: LD_INT 15
98150: PUSH
98151: LD_INT 16
98153: PUSH
98154: LD_INT 17
98156: PUSH
98157: LD_INT 18
98159: PUSH
98160: LD_INT 19
98162: PUSH
98163: LD_INT 20
98165: PUSH
98166: LD_INT 21
98168: PUSH
98169: LD_INT 22
98171: PUSH
98172: LD_INT 23
98174: PUSH
98175: LD_INT 24
98177: PUSH
98178: LD_INT 25
98180: PUSH
98181: LD_INT 26
98183: PUSH
98184: LD_INT 27
98186: PUSH
98187: LD_INT 28
98189: PUSH
98190: LD_INT 29
98192: PUSH
98193: LD_INT 30
98195: PUSH
98196: LD_INT 31
98198: PUSH
98199: LD_INT 32
98201: PUSH
98202: LD_INT 33
98204: PUSH
98205: LD_INT 34
98207: PUSH
98208: LD_INT 36
98210: PUSH
98211: EMPTY
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: PUSH
98248: LD_INT 101
98250: PUSH
98251: LD_INT 102
98253: PUSH
98254: LD_INT 103
98256: PUSH
98257: LD_INT 104
98259: PUSH
98260: LD_INT 105
98262: PUSH
98263: LD_INT 106
98265: PUSH
98266: LD_INT 107
98268: PUSH
98269: LD_INT 108
98271: PUSH
98272: LD_INT 109
98274: PUSH
98275: LD_INT 110
98277: PUSH
98278: LD_INT 111
98280: PUSH
98281: LD_INT 112
98283: PUSH
98284: LD_INT 113
98286: PUSH
98287: LD_INT 114
98289: PUSH
98290: LD_INT 116
98292: PUSH
98293: LD_INT 117
98295: PUSH
98296: LD_INT 118
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: PUSH
98318: EMPTY
98319: LIST
98320: LIST
98321: ST_TO_ADDR
98322: GO 98721
98324: LD_INT 18
98326: DOUBLE
98327: EQUAL
98328: IFTRUE 98332
98330: GO 98480
98332: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98333: LD_ADDR_VAR 0 2
98337: PUSH
98338: LD_INT 2
98340: PUSH
98341: LD_INT 4
98343: PUSH
98344: LD_INT 5
98346: PUSH
98347: LD_INT 7
98349: PUSH
98350: LD_INT 11
98352: PUSH
98353: LD_INT 12
98355: PUSH
98356: LD_INT 15
98358: PUSH
98359: LD_INT 16
98361: PUSH
98362: LD_INT 20
98364: PUSH
98365: LD_INT 21
98367: PUSH
98368: LD_INT 22
98370: PUSH
98371: LD_INT 23
98373: PUSH
98374: LD_INT 25
98376: PUSH
98377: LD_INT 26
98379: PUSH
98380: LD_INT 30
98382: PUSH
98383: LD_INT 31
98385: PUSH
98386: LD_INT 32
98388: PUSH
98389: LD_INT 33
98391: PUSH
98392: LD_INT 34
98394: PUSH
98395: LD_INT 35
98397: PUSH
98398: LD_INT 36
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: PUSH
98424: LD_INT 101
98426: PUSH
98427: LD_INT 102
98429: PUSH
98430: LD_INT 103
98432: PUSH
98433: LD_INT 106
98435: PUSH
98436: LD_INT 108
98438: PUSH
98439: LD_INT 112
98441: PUSH
98442: LD_INT 113
98444: PUSH
98445: LD_INT 114
98447: PUSH
98448: LD_INT 115
98450: PUSH
98451: LD_INT 116
98453: PUSH
98454: LD_INT 117
98456: PUSH
98457: LD_INT 118
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: PUSH
98474: EMPTY
98475: LIST
98476: LIST
98477: ST_TO_ADDR
98478: GO 98721
98480: LD_INT 19
98482: DOUBLE
98483: EQUAL
98484: IFTRUE 98488
98486: GO 98720
98488: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98489: LD_ADDR_VAR 0 2
98493: PUSH
98494: LD_INT 1
98496: PUSH
98497: LD_INT 2
98499: PUSH
98500: LD_INT 3
98502: PUSH
98503: LD_INT 4
98505: PUSH
98506: LD_INT 5
98508: PUSH
98509: LD_INT 6
98511: PUSH
98512: LD_INT 7
98514: PUSH
98515: LD_INT 8
98517: PUSH
98518: LD_INT 9
98520: PUSH
98521: LD_INT 10
98523: PUSH
98524: LD_INT 11
98526: PUSH
98527: LD_INT 12
98529: PUSH
98530: LD_INT 13
98532: PUSH
98533: LD_INT 14
98535: PUSH
98536: LD_INT 15
98538: PUSH
98539: LD_INT 16
98541: PUSH
98542: LD_INT 17
98544: PUSH
98545: LD_INT 18
98547: PUSH
98548: LD_INT 19
98550: PUSH
98551: LD_INT 20
98553: PUSH
98554: LD_INT 21
98556: PUSH
98557: LD_INT 22
98559: PUSH
98560: LD_INT 23
98562: PUSH
98563: LD_INT 24
98565: PUSH
98566: LD_INT 25
98568: PUSH
98569: LD_INT 26
98571: PUSH
98572: LD_INT 27
98574: PUSH
98575: LD_INT 28
98577: PUSH
98578: LD_INT 29
98580: PUSH
98581: LD_INT 30
98583: PUSH
98584: LD_INT 31
98586: PUSH
98587: LD_INT 32
98589: PUSH
98590: LD_INT 33
98592: PUSH
98593: LD_INT 34
98595: PUSH
98596: LD_INT 35
98598: PUSH
98599: LD_INT 36
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: LIST
98610: LIST
98611: LIST
98612: LIST
98613: LIST
98614: LIST
98615: LIST
98616: LIST
98617: LIST
98618: LIST
98619: LIST
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: PUSH
98640: LD_INT 101
98642: PUSH
98643: LD_INT 102
98645: PUSH
98646: LD_INT 103
98648: PUSH
98649: LD_INT 104
98651: PUSH
98652: LD_INT 105
98654: PUSH
98655: LD_INT 106
98657: PUSH
98658: LD_INT 107
98660: PUSH
98661: LD_INT 108
98663: PUSH
98664: LD_INT 109
98666: PUSH
98667: LD_INT 110
98669: PUSH
98670: LD_INT 111
98672: PUSH
98673: LD_INT 112
98675: PUSH
98676: LD_INT 113
98678: PUSH
98679: LD_INT 114
98681: PUSH
98682: LD_INT 115
98684: PUSH
98685: LD_INT 116
98687: PUSH
98688: LD_INT 117
98690: PUSH
98691: LD_INT 118
98693: PUSH
98694: EMPTY
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: ST_TO_ADDR
98718: GO 98721
98720: POP
// end else
98721: GO 98952
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98723: LD_ADDR_VAR 0 2
98727: PUSH
98728: LD_INT 1
98730: PUSH
98731: LD_INT 2
98733: PUSH
98734: LD_INT 3
98736: PUSH
98737: LD_INT 4
98739: PUSH
98740: LD_INT 5
98742: PUSH
98743: LD_INT 6
98745: PUSH
98746: LD_INT 7
98748: PUSH
98749: LD_INT 8
98751: PUSH
98752: LD_INT 9
98754: PUSH
98755: LD_INT 10
98757: PUSH
98758: LD_INT 11
98760: PUSH
98761: LD_INT 12
98763: PUSH
98764: LD_INT 13
98766: PUSH
98767: LD_INT 14
98769: PUSH
98770: LD_INT 15
98772: PUSH
98773: LD_INT 16
98775: PUSH
98776: LD_INT 17
98778: PUSH
98779: LD_INT 18
98781: PUSH
98782: LD_INT 19
98784: PUSH
98785: LD_INT 20
98787: PUSH
98788: LD_INT 21
98790: PUSH
98791: LD_INT 22
98793: PUSH
98794: LD_INT 23
98796: PUSH
98797: LD_INT 24
98799: PUSH
98800: LD_INT 25
98802: PUSH
98803: LD_INT 26
98805: PUSH
98806: LD_INT 27
98808: PUSH
98809: LD_INT 28
98811: PUSH
98812: LD_INT 29
98814: PUSH
98815: LD_INT 30
98817: PUSH
98818: LD_INT 31
98820: PUSH
98821: LD_INT 32
98823: PUSH
98824: LD_INT 33
98826: PUSH
98827: LD_INT 34
98829: PUSH
98830: LD_INT 35
98832: PUSH
98833: LD_INT 36
98835: PUSH
98836: EMPTY
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: PUSH
98874: LD_INT 101
98876: PUSH
98877: LD_INT 102
98879: PUSH
98880: LD_INT 103
98882: PUSH
98883: LD_INT 104
98885: PUSH
98886: LD_INT 105
98888: PUSH
98889: LD_INT 106
98891: PUSH
98892: LD_INT 107
98894: PUSH
98895: LD_INT 108
98897: PUSH
98898: LD_INT 109
98900: PUSH
98901: LD_INT 110
98903: PUSH
98904: LD_INT 111
98906: PUSH
98907: LD_INT 112
98909: PUSH
98910: LD_INT 113
98912: PUSH
98913: LD_INT 114
98915: PUSH
98916: LD_INT 115
98918: PUSH
98919: LD_INT 116
98921: PUSH
98922: LD_INT 117
98924: PUSH
98925: LD_INT 118
98927: PUSH
98928: EMPTY
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: ST_TO_ADDR
// if result then
98952: LD_VAR 0 2
98956: IFFALSE 99742
// begin normal :=  ;
98958: LD_ADDR_VAR 0 5
98962: PUSH
98963: LD_STRING 
98965: ST_TO_ADDR
// hardcore :=  ;
98966: LD_ADDR_VAR 0 6
98970: PUSH
98971: LD_STRING 
98973: ST_TO_ADDR
// active :=  ;
98974: LD_ADDR_VAR 0 7
98978: PUSH
98979: LD_STRING 
98981: ST_TO_ADDR
// for i = 1 to normalCounter do
98982: LD_ADDR_VAR 0 8
98986: PUSH
98987: DOUBLE
98988: LD_INT 1
98990: DEC
98991: ST_TO_ADDR
98992: LD_EXP 100
98996: PUSH
98997: FOR_TO
98998: IFFALSE 99099
// begin tmp := 0 ;
99000: LD_ADDR_VAR 0 3
99004: PUSH
99005: LD_STRING 0
99007: ST_TO_ADDR
// if result [ 1 ] then
99008: LD_VAR 0 2
99012: PUSH
99013: LD_INT 1
99015: ARRAY
99016: IFFALSE 99081
// if result [ 1 ] [ 1 ] = i then
99018: LD_VAR 0 2
99022: PUSH
99023: LD_INT 1
99025: ARRAY
99026: PUSH
99027: LD_INT 1
99029: ARRAY
99030: PUSH
99031: LD_VAR 0 8
99035: EQUAL
99036: IFFALSE 99081
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99038: LD_ADDR_VAR 0 2
99042: PUSH
99043: LD_VAR 0 2
99047: PPUSH
99048: LD_INT 1
99050: PPUSH
99051: LD_VAR 0 2
99055: PUSH
99056: LD_INT 1
99058: ARRAY
99059: PPUSH
99060: LD_INT 1
99062: PPUSH
99063: CALL_OW 3
99067: PPUSH
99068: CALL_OW 1
99072: ST_TO_ADDR
// tmp := 1 ;
99073: LD_ADDR_VAR 0 3
99077: PUSH
99078: LD_STRING 1
99080: ST_TO_ADDR
// end ; normal := normal & tmp ;
99081: LD_ADDR_VAR 0 5
99085: PUSH
99086: LD_VAR 0 5
99090: PUSH
99091: LD_VAR 0 3
99095: STR
99096: ST_TO_ADDR
// end ;
99097: GO 98997
99099: POP
99100: POP
// for i = 1 to hardcoreCounter do
99101: LD_ADDR_VAR 0 8
99105: PUSH
99106: DOUBLE
99107: LD_INT 1
99109: DEC
99110: ST_TO_ADDR
99111: LD_EXP 101
99115: PUSH
99116: FOR_TO
99117: IFFALSE 99222
// begin tmp := 0 ;
99119: LD_ADDR_VAR 0 3
99123: PUSH
99124: LD_STRING 0
99126: ST_TO_ADDR
// if result [ 2 ] then
99127: LD_VAR 0 2
99131: PUSH
99132: LD_INT 2
99134: ARRAY
99135: IFFALSE 99204
// if result [ 2 ] [ 1 ] = 100 + i then
99137: LD_VAR 0 2
99141: PUSH
99142: LD_INT 2
99144: ARRAY
99145: PUSH
99146: LD_INT 1
99148: ARRAY
99149: PUSH
99150: LD_INT 100
99152: PUSH
99153: LD_VAR 0 8
99157: PLUS
99158: EQUAL
99159: IFFALSE 99204
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99161: LD_ADDR_VAR 0 2
99165: PUSH
99166: LD_VAR 0 2
99170: PPUSH
99171: LD_INT 2
99173: PPUSH
99174: LD_VAR 0 2
99178: PUSH
99179: LD_INT 2
99181: ARRAY
99182: PPUSH
99183: LD_INT 1
99185: PPUSH
99186: CALL_OW 3
99190: PPUSH
99191: CALL_OW 1
99195: ST_TO_ADDR
// tmp := 1 ;
99196: LD_ADDR_VAR 0 3
99200: PUSH
99201: LD_STRING 1
99203: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99204: LD_ADDR_VAR 0 6
99208: PUSH
99209: LD_VAR 0 6
99213: PUSH
99214: LD_VAR 0 3
99218: STR
99219: ST_TO_ADDR
// end ;
99220: GO 99116
99222: POP
99223: POP
// if isGameLoad then
99224: LD_VAR 0 1
99228: IFFALSE 99703
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99230: LD_ADDR_VAR 0 4
99234: PUSH
99235: LD_EXP 104
99239: PUSH
99240: LD_EXP 103
99244: PUSH
99245: LD_EXP 105
99249: PUSH
99250: LD_EXP 102
99254: PUSH
99255: LD_EXP 106
99259: PUSH
99260: LD_EXP 107
99264: PUSH
99265: LD_EXP 108
99269: PUSH
99270: LD_EXP 109
99274: PUSH
99275: LD_EXP 110
99279: PUSH
99280: LD_EXP 111
99284: PUSH
99285: LD_EXP 112
99289: PUSH
99290: LD_EXP 113
99294: PUSH
99295: LD_EXP 114
99299: PUSH
99300: LD_EXP 115
99304: PUSH
99305: LD_EXP 123
99309: PUSH
99310: LD_EXP 124
99314: PUSH
99315: LD_EXP 125
99319: PUSH
99320: LD_EXP 126
99324: PUSH
99325: LD_EXP 128
99329: PUSH
99330: LD_EXP 129
99334: PUSH
99335: LD_EXP 130
99339: PUSH
99340: LD_EXP 133
99344: PUSH
99345: LD_EXP 135
99349: PUSH
99350: LD_EXP 136
99354: PUSH
99355: LD_EXP 137
99359: PUSH
99360: LD_EXP 139
99364: PUSH
99365: LD_EXP 140
99369: PUSH
99370: LD_EXP 143
99374: PUSH
99375: LD_EXP 144
99379: PUSH
99380: LD_EXP 145
99384: PUSH
99385: LD_EXP 146
99389: PUSH
99390: LD_EXP 147
99394: PUSH
99395: LD_EXP 148
99399: PUSH
99400: LD_EXP 149
99404: PUSH
99405: LD_EXP 150
99409: PUSH
99410: LD_EXP 151
99414: PUSH
99415: LD_EXP 116
99419: PUSH
99420: LD_EXP 117
99424: PUSH
99425: LD_EXP 120
99429: PUSH
99430: LD_EXP 121
99434: PUSH
99435: LD_EXP 122
99439: PUSH
99440: LD_EXP 118
99444: PUSH
99445: LD_EXP 119
99449: PUSH
99450: LD_EXP 127
99454: PUSH
99455: LD_EXP 131
99459: PUSH
99460: LD_EXP 132
99464: PUSH
99465: LD_EXP 134
99469: PUSH
99470: LD_EXP 138
99474: PUSH
99475: LD_EXP 141
99479: PUSH
99480: LD_EXP 142
99484: PUSH
99485: LD_EXP 152
99489: PUSH
99490: LD_EXP 153
99494: PUSH
99495: LD_EXP 154
99499: PUSH
99500: LD_EXP 155
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: ST_TO_ADDR
// tmp :=  ;
99561: LD_ADDR_VAR 0 3
99565: PUSH
99566: LD_STRING 
99568: ST_TO_ADDR
// for i = 1 to normalCounter do
99569: LD_ADDR_VAR 0 8
99573: PUSH
99574: DOUBLE
99575: LD_INT 1
99577: DEC
99578: ST_TO_ADDR
99579: LD_EXP 100
99583: PUSH
99584: FOR_TO
99585: IFFALSE 99621
// begin if flags [ i ] then
99587: LD_VAR 0 4
99591: PUSH
99592: LD_VAR 0 8
99596: ARRAY
99597: IFFALSE 99619
// tmp := tmp & i & ; ;
99599: LD_ADDR_VAR 0 3
99603: PUSH
99604: LD_VAR 0 3
99608: PUSH
99609: LD_VAR 0 8
99613: STR
99614: PUSH
99615: LD_STRING ;
99617: STR
99618: ST_TO_ADDR
// end ;
99619: GO 99584
99621: POP
99622: POP
// for i = 1 to hardcoreCounter do
99623: LD_ADDR_VAR 0 8
99627: PUSH
99628: DOUBLE
99629: LD_INT 1
99631: DEC
99632: ST_TO_ADDR
99633: LD_EXP 101
99637: PUSH
99638: FOR_TO
99639: IFFALSE 99685
// begin if flags [ normalCounter + i ] then
99641: LD_VAR 0 4
99645: PUSH
99646: LD_EXP 100
99650: PUSH
99651: LD_VAR 0 8
99655: PLUS
99656: ARRAY
99657: IFFALSE 99683
// tmp := tmp & ( 100 + i ) & ; ;
99659: LD_ADDR_VAR 0 3
99663: PUSH
99664: LD_VAR 0 3
99668: PUSH
99669: LD_INT 100
99671: PUSH
99672: LD_VAR 0 8
99676: PLUS
99677: STR
99678: PUSH
99679: LD_STRING ;
99681: STR
99682: ST_TO_ADDR
// end ;
99683: GO 99638
99685: POP
99686: POP
// if tmp then
99687: LD_VAR 0 3
99691: IFFALSE 99703
// active := tmp ;
99693: LD_ADDR_VAR 0 7
99697: PUSH
99698: LD_VAR 0 3
99702: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99703: LD_STRING getStreamItemsFromMission("
99705: PUSH
99706: LD_VAR 0 5
99710: STR
99711: PUSH
99712: LD_STRING ","
99714: STR
99715: PUSH
99716: LD_VAR 0 6
99720: STR
99721: PUSH
99722: LD_STRING ","
99724: STR
99725: PUSH
99726: LD_VAR 0 7
99730: STR
99731: PUSH
99732: LD_STRING ")
99734: STR
99735: PPUSH
99736: CALL_OW 559
// end else
99740: GO 99749
// ToLua ( getStreamItemsFromMission("","","") ) ;
99742: LD_STRING getStreamItemsFromMission("","","")
99744: PPUSH
99745: CALL_OW 559
// end ;
99749: LD_VAR 0 2
99753: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99754: LD_EXP 99
99758: PUSH
99759: LD_EXP 104
99763: AND
99764: IFFALSE 99888
99766: GO 99768
99768: DISABLE
99769: LD_INT 0
99771: PPUSH
99772: PPUSH
// begin enable ;
99773: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99774: LD_ADDR_VAR 0 2
99778: PUSH
99779: LD_INT 22
99781: PUSH
99782: LD_OWVAR 2
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 2
99793: PUSH
99794: LD_INT 34
99796: PUSH
99797: LD_INT 7
99799: PUSH
99800: EMPTY
99801: LIST
99802: LIST
99803: PUSH
99804: LD_INT 34
99806: PUSH
99807: LD_INT 45
99809: PUSH
99810: EMPTY
99811: LIST
99812: LIST
99813: PUSH
99814: LD_INT 34
99816: PUSH
99817: LD_INT 28
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PUSH
99824: LD_INT 34
99826: PUSH
99827: LD_INT 47
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PPUSH
99845: CALL_OW 69
99849: ST_TO_ADDR
// if not tmp then
99850: LD_VAR 0 2
99854: NOT
99855: IFFALSE 99859
// exit ;
99857: GO 99888
// for i in tmp do
99859: LD_ADDR_VAR 0 1
99863: PUSH
99864: LD_VAR 0 2
99868: PUSH
99869: FOR_IN
99870: IFFALSE 99886
// begin SetLives ( i , 0 ) ;
99872: LD_VAR 0 1
99876: PPUSH
99877: LD_INT 0
99879: PPUSH
99880: CALL_OW 234
// end ;
99884: GO 99869
99886: POP
99887: POP
// end ;
99888: PPOPN 2
99890: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99891: LD_EXP 99
99895: PUSH
99896: LD_EXP 105
99900: AND
99901: IFFALSE 99985
99903: GO 99905
99905: DISABLE
99906: LD_INT 0
99908: PPUSH
99909: PPUSH
// begin enable ;
99910: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99911: LD_ADDR_VAR 0 2
99915: PUSH
99916: LD_INT 22
99918: PUSH
99919: LD_OWVAR 2
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PUSH
99928: LD_INT 32
99930: PUSH
99931: LD_INT 3
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: PUSH
99938: EMPTY
99939: LIST
99940: LIST
99941: PPUSH
99942: CALL_OW 69
99946: ST_TO_ADDR
// if not tmp then
99947: LD_VAR 0 2
99951: NOT
99952: IFFALSE 99956
// exit ;
99954: GO 99985
// for i in tmp do
99956: LD_ADDR_VAR 0 1
99960: PUSH
99961: LD_VAR 0 2
99965: PUSH
99966: FOR_IN
99967: IFFALSE 99983
// begin SetLives ( i , 0 ) ;
99969: LD_VAR 0 1
99973: PPUSH
99974: LD_INT 0
99976: PPUSH
99977: CALL_OW 234
// end ;
99981: GO 99966
99983: POP
99984: POP
// end ;
99985: PPOPN 2
99987: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99988: LD_EXP 99
99992: PUSH
99993: LD_EXP 102
99997: AND
99998: IFFALSE 100091
100000: GO 100002
100002: DISABLE
100003: LD_INT 0
100005: PPUSH
// begin enable ;
100006: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100007: LD_ADDR_VAR 0 1
100011: PUSH
100012: LD_INT 22
100014: PUSH
100015: LD_OWVAR 2
100019: PUSH
100020: EMPTY
100021: LIST
100022: LIST
100023: PUSH
100024: LD_INT 2
100026: PUSH
100027: LD_INT 25
100029: PUSH
100030: LD_INT 5
100032: PUSH
100033: EMPTY
100034: LIST
100035: LIST
100036: PUSH
100037: LD_INT 25
100039: PUSH
100040: LD_INT 9
100042: PUSH
100043: EMPTY
100044: LIST
100045: LIST
100046: PUSH
100047: LD_INT 25
100049: PUSH
100050: LD_INT 8
100052: PUSH
100053: EMPTY
100054: LIST
100055: LIST
100056: PUSH
100057: EMPTY
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PPUSH
100067: CALL_OW 69
100071: PUSH
100072: FOR_IN
100073: IFFALSE 100089
// begin SetClass ( i , 1 ) ;
100075: LD_VAR 0 1
100079: PPUSH
100080: LD_INT 1
100082: PPUSH
100083: CALL_OW 336
// end ;
100087: GO 100072
100089: POP
100090: POP
// end ;
100091: PPOPN 1
100093: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100094: LD_EXP 99
100098: PUSH
100099: LD_EXP 103
100103: AND
100104: PUSH
100105: LD_OWVAR 65
100109: PUSH
100110: LD_INT 7
100112: LESS
100113: AND
100114: IFFALSE 100128
100116: GO 100118
100118: DISABLE
// begin enable ;
100119: ENABLE
// game_speed := 7 ;
100120: LD_ADDR_OWVAR 65
100124: PUSH
100125: LD_INT 7
100127: ST_TO_ADDR
// end ;
100128: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100129: LD_EXP 99
100133: PUSH
100134: LD_EXP 106
100138: AND
100139: IFFALSE 100341
100141: GO 100143
100143: DISABLE
100144: LD_INT 0
100146: PPUSH
100147: PPUSH
100148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100149: LD_ADDR_VAR 0 3
100153: PUSH
100154: LD_INT 81
100156: PUSH
100157: LD_OWVAR 2
100161: PUSH
100162: EMPTY
100163: LIST
100164: LIST
100165: PUSH
100166: LD_INT 21
100168: PUSH
100169: LD_INT 1
100171: PUSH
100172: EMPTY
100173: LIST
100174: LIST
100175: PUSH
100176: EMPTY
100177: LIST
100178: LIST
100179: PPUSH
100180: CALL_OW 69
100184: ST_TO_ADDR
// if not tmp then
100185: LD_VAR 0 3
100189: NOT
100190: IFFALSE 100194
// exit ;
100192: GO 100341
// if tmp > 5 then
100194: LD_VAR 0 3
100198: PUSH
100199: LD_INT 5
100201: GREATER
100202: IFFALSE 100214
// k := 5 else
100204: LD_ADDR_VAR 0 2
100208: PUSH
100209: LD_INT 5
100211: ST_TO_ADDR
100212: GO 100224
// k := tmp ;
100214: LD_ADDR_VAR 0 2
100218: PUSH
100219: LD_VAR 0 3
100223: ST_TO_ADDR
// for i := 1 to k do
100224: LD_ADDR_VAR 0 1
100228: PUSH
100229: DOUBLE
100230: LD_INT 1
100232: DEC
100233: ST_TO_ADDR
100234: LD_VAR 0 2
100238: PUSH
100239: FOR_TO
100240: IFFALSE 100339
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100242: LD_VAR 0 3
100246: PUSH
100247: LD_VAR 0 1
100251: ARRAY
100252: PPUSH
100253: LD_VAR 0 1
100257: PUSH
100258: LD_INT 4
100260: MOD
100261: PUSH
100262: LD_INT 1
100264: PLUS
100265: PPUSH
100266: CALL_OW 259
100270: PUSH
100271: LD_INT 10
100273: LESS
100274: IFFALSE 100337
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100276: LD_VAR 0 3
100280: PUSH
100281: LD_VAR 0 1
100285: ARRAY
100286: PPUSH
100287: LD_VAR 0 1
100291: PUSH
100292: LD_INT 4
100294: MOD
100295: PUSH
100296: LD_INT 1
100298: PLUS
100299: PPUSH
100300: LD_VAR 0 3
100304: PUSH
100305: LD_VAR 0 1
100309: ARRAY
100310: PPUSH
100311: LD_VAR 0 1
100315: PUSH
100316: LD_INT 4
100318: MOD
100319: PUSH
100320: LD_INT 1
100322: PLUS
100323: PPUSH
100324: CALL_OW 259
100328: PUSH
100329: LD_INT 1
100331: PLUS
100332: PPUSH
100333: CALL_OW 237
100337: GO 100239
100339: POP
100340: POP
// end ;
100341: PPOPN 3
100343: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100344: LD_EXP 99
100348: PUSH
100349: LD_EXP 107
100353: AND
100354: IFFALSE 100374
100356: GO 100358
100358: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100359: LD_INT 4
100361: PPUSH
100362: LD_OWVAR 2
100366: PPUSH
100367: LD_INT 0
100369: PPUSH
100370: CALL_OW 324
100374: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100375: LD_EXP 99
100379: PUSH
100380: LD_EXP 136
100384: AND
100385: IFFALSE 100405
100387: GO 100389
100389: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100390: LD_INT 19
100392: PPUSH
100393: LD_OWVAR 2
100397: PPUSH
100398: LD_INT 0
100400: PPUSH
100401: CALL_OW 324
100405: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100406: LD_EXP 99
100410: PUSH
100411: LD_EXP 108
100415: AND
100416: IFFALSE 100518
100418: GO 100420
100420: DISABLE
100421: LD_INT 0
100423: PPUSH
100424: PPUSH
// begin enable ;
100425: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100426: LD_ADDR_VAR 0 2
100430: PUSH
100431: LD_INT 22
100433: PUSH
100434: LD_OWVAR 2
100438: PUSH
100439: EMPTY
100440: LIST
100441: LIST
100442: PUSH
100443: LD_INT 2
100445: PUSH
100446: LD_INT 34
100448: PUSH
100449: LD_INT 11
100451: PUSH
100452: EMPTY
100453: LIST
100454: LIST
100455: PUSH
100456: LD_INT 34
100458: PUSH
100459: LD_INT 30
100461: PUSH
100462: EMPTY
100463: LIST
100464: LIST
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: LIST
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: PPUSH
100475: CALL_OW 69
100479: ST_TO_ADDR
// if not tmp then
100480: LD_VAR 0 2
100484: NOT
100485: IFFALSE 100489
// exit ;
100487: GO 100518
// for i in tmp do
100489: LD_ADDR_VAR 0 1
100493: PUSH
100494: LD_VAR 0 2
100498: PUSH
100499: FOR_IN
100500: IFFALSE 100516
// begin SetLives ( i , 0 ) ;
100502: LD_VAR 0 1
100506: PPUSH
100507: LD_INT 0
100509: PPUSH
100510: CALL_OW 234
// end ;
100514: GO 100499
100516: POP
100517: POP
// end ;
100518: PPOPN 2
100520: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100521: LD_EXP 99
100525: PUSH
100526: LD_EXP 109
100530: AND
100531: IFFALSE 100551
100533: GO 100535
100535: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100536: LD_INT 32
100538: PPUSH
100539: LD_OWVAR 2
100543: PPUSH
100544: LD_INT 0
100546: PPUSH
100547: CALL_OW 324
100551: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100552: LD_EXP 99
100556: PUSH
100557: LD_EXP 110
100561: AND
100562: IFFALSE 100743
100564: GO 100566
100566: DISABLE
100567: LD_INT 0
100569: PPUSH
100570: PPUSH
100571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100572: LD_ADDR_VAR 0 2
100576: PUSH
100577: LD_INT 22
100579: PUSH
100580: LD_OWVAR 2
100584: PUSH
100585: EMPTY
100586: LIST
100587: LIST
100588: PUSH
100589: LD_INT 33
100591: PUSH
100592: LD_INT 3
100594: PUSH
100595: EMPTY
100596: LIST
100597: LIST
100598: PUSH
100599: EMPTY
100600: LIST
100601: LIST
100602: PPUSH
100603: CALL_OW 69
100607: ST_TO_ADDR
// if not tmp then
100608: LD_VAR 0 2
100612: NOT
100613: IFFALSE 100617
// exit ;
100615: GO 100743
// side := 0 ;
100617: LD_ADDR_VAR 0 3
100621: PUSH
100622: LD_INT 0
100624: ST_TO_ADDR
// for i := 1 to 8 do
100625: LD_ADDR_VAR 0 1
100629: PUSH
100630: DOUBLE
100631: LD_INT 1
100633: DEC
100634: ST_TO_ADDR
100635: LD_INT 8
100637: PUSH
100638: FOR_TO
100639: IFFALSE 100687
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100641: LD_OWVAR 2
100645: PUSH
100646: LD_VAR 0 1
100650: NONEQUAL
100651: PUSH
100652: LD_OWVAR 2
100656: PPUSH
100657: LD_VAR 0 1
100661: PPUSH
100662: CALL_OW 81
100666: PUSH
100667: LD_INT 2
100669: EQUAL
100670: AND
100671: IFFALSE 100685
// begin side := i ;
100673: LD_ADDR_VAR 0 3
100677: PUSH
100678: LD_VAR 0 1
100682: ST_TO_ADDR
// break ;
100683: GO 100687
// end ;
100685: GO 100638
100687: POP
100688: POP
// if not side then
100689: LD_VAR 0 3
100693: NOT
100694: IFFALSE 100698
// exit ;
100696: GO 100743
// for i := 1 to tmp do
100698: LD_ADDR_VAR 0 1
100702: PUSH
100703: DOUBLE
100704: LD_INT 1
100706: DEC
100707: ST_TO_ADDR
100708: LD_VAR 0 2
100712: PUSH
100713: FOR_TO
100714: IFFALSE 100741
// if Prob ( 60 ) then
100716: LD_INT 60
100718: PPUSH
100719: CALL_OW 13
100723: IFFALSE 100739
// SetSide ( i , side ) ;
100725: LD_VAR 0 1
100729: PPUSH
100730: LD_VAR 0 3
100734: PPUSH
100735: CALL_OW 235
100739: GO 100713
100741: POP
100742: POP
// end ;
100743: PPOPN 3
100745: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100746: LD_EXP 99
100750: PUSH
100751: LD_EXP 112
100755: AND
100756: IFFALSE 100875
100758: GO 100760
100760: DISABLE
100761: LD_INT 0
100763: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100764: LD_ADDR_VAR 0 1
100768: PUSH
100769: LD_INT 22
100771: PUSH
100772: LD_OWVAR 2
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: PUSH
100781: LD_INT 21
100783: PUSH
100784: LD_INT 1
100786: PUSH
100787: EMPTY
100788: LIST
100789: LIST
100790: PUSH
100791: LD_INT 3
100793: PUSH
100794: LD_INT 23
100796: PUSH
100797: LD_INT 0
100799: PUSH
100800: EMPTY
100801: LIST
100802: LIST
100803: PUSH
100804: EMPTY
100805: LIST
100806: LIST
100807: PUSH
100808: EMPTY
100809: LIST
100810: LIST
100811: LIST
100812: PPUSH
100813: CALL_OW 69
100817: PUSH
100818: FOR_IN
100819: IFFALSE 100873
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100821: LD_VAR 0 1
100825: PPUSH
100826: CALL_OW 257
100830: PUSH
100831: LD_INT 1
100833: PUSH
100834: LD_INT 2
100836: PUSH
100837: LD_INT 3
100839: PUSH
100840: LD_INT 4
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: LIST
100847: LIST
100848: IN
100849: IFFALSE 100871
// SetClass ( un , rand ( 1 , 4 ) ) ;
100851: LD_VAR 0 1
100855: PPUSH
100856: LD_INT 1
100858: PPUSH
100859: LD_INT 4
100861: PPUSH
100862: CALL_OW 12
100866: PPUSH
100867: CALL_OW 336
100871: GO 100818
100873: POP
100874: POP
// end ;
100875: PPOPN 1
100877: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100878: LD_EXP 99
100882: PUSH
100883: LD_EXP 111
100887: AND
100888: IFFALSE 100967
100890: GO 100892
100892: DISABLE
100893: LD_INT 0
100895: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100896: LD_ADDR_VAR 0 1
100900: PUSH
100901: LD_INT 22
100903: PUSH
100904: LD_OWVAR 2
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 21
100915: PUSH
100916: LD_INT 3
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PPUSH
100927: CALL_OW 69
100931: ST_TO_ADDR
// if not tmp then
100932: LD_VAR 0 1
100936: NOT
100937: IFFALSE 100941
// exit ;
100939: GO 100967
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100941: LD_VAR 0 1
100945: PUSH
100946: LD_INT 1
100948: PPUSH
100949: LD_VAR 0 1
100953: PPUSH
100954: CALL_OW 12
100958: ARRAY
100959: PPUSH
100960: LD_INT 100
100962: PPUSH
100963: CALL_OW 234
// end ;
100967: PPOPN 1
100969: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100970: LD_EXP 99
100974: PUSH
100975: LD_EXP 113
100979: AND
100980: IFFALSE 101078
100982: GO 100984
100984: DISABLE
100985: LD_INT 0
100987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100988: LD_ADDR_VAR 0 1
100992: PUSH
100993: LD_INT 22
100995: PUSH
100996: LD_OWVAR 2
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: PUSH
101005: LD_INT 21
101007: PUSH
101008: LD_INT 1
101010: PUSH
101011: EMPTY
101012: LIST
101013: LIST
101014: PUSH
101015: EMPTY
101016: LIST
101017: LIST
101018: PPUSH
101019: CALL_OW 69
101023: ST_TO_ADDR
// if not tmp then
101024: LD_VAR 0 1
101028: NOT
101029: IFFALSE 101033
// exit ;
101031: GO 101078
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101033: LD_VAR 0 1
101037: PUSH
101038: LD_INT 1
101040: PPUSH
101041: LD_VAR 0 1
101045: PPUSH
101046: CALL_OW 12
101050: ARRAY
101051: PPUSH
101052: LD_INT 1
101054: PPUSH
101055: LD_INT 4
101057: PPUSH
101058: CALL_OW 12
101062: PPUSH
101063: LD_INT 3000
101065: PPUSH
101066: LD_INT 9000
101068: PPUSH
101069: CALL_OW 12
101073: PPUSH
101074: CALL_OW 492
// end ;
101078: PPOPN 1
101080: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101081: LD_EXP 99
101085: PUSH
101086: LD_EXP 114
101090: AND
101091: IFFALSE 101111
101093: GO 101095
101095: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101096: LD_INT 1
101098: PPUSH
101099: LD_OWVAR 2
101103: PPUSH
101104: LD_INT 0
101106: PPUSH
101107: CALL_OW 324
101111: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101112: LD_EXP 99
101116: PUSH
101117: LD_EXP 115
101121: AND
101122: IFFALSE 101205
101124: GO 101126
101126: DISABLE
101127: LD_INT 0
101129: PPUSH
101130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101131: LD_ADDR_VAR 0 2
101135: PUSH
101136: LD_INT 22
101138: PUSH
101139: LD_OWVAR 2
101143: PUSH
101144: EMPTY
101145: LIST
101146: LIST
101147: PUSH
101148: LD_INT 21
101150: PUSH
101151: LD_INT 3
101153: PUSH
101154: EMPTY
101155: LIST
101156: LIST
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PPUSH
101162: CALL_OW 69
101166: ST_TO_ADDR
// if not tmp then
101167: LD_VAR 0 2
101171: NOT
101172: IFFALSE 101176
// exit ;
101174: GO 101205
// for i in tmp do
101176: LD_ADDR_VAR 0 1
101180: PUSH
101181: LD_VAR 0 2
101185: PUSH
101186: FOR_IN
101187: IFFALSE 101203
// SetBLevel ( i , 10 ) ;
101189: LD_VAR 0 1
101193: PPUSH
101194: LD_INT 10
101196: PPUSH
101197: CALL_OW 241
101201: GO 101186
101203: POP
101204: POP
// end ;
101205: PPOPN 2
101207: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101208: LD_EXP 99
101212: PUSH
101213: LD_EXP 116
101217: AND
101218: IFFALSE 101329
101220: GO 101222
101222: DISABLE
101223: LD_INT 0
101225: PPUSH
101226: PPUSH
101227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101228: LD_ADDR_VAR 0 3
101232: PUSH
101233: LD_INT 22
101235: PUSH
101236: LD_OWVAR 2
101240: PUSH
101241: EMPTY
101242: LIST
101243: LIST
101244: PUSH
101245: LD_INT 25
101247: PUSH
101248: LD_INT 1
101250: PUSH
101251: EMPTY
101252: LIST
101253: LIST
101254: PUSH
101255: EMPTY
101256: LIST
101257: LIST
101258: PPUSH
101259: CALL_OW 69
101263: ST_TO_ADDR
// if not tmp then
101264: LD_VAR 0 3
101268: NOT
101269: IFFALSE 101273
// exit ;
101271: GO 101329
// un := tmp [ rand ( 1 , tmp ) ] ;
101273: LD_ADDR_VAR 0 2
101277: PUSH
101278: LD_VAR 0 3
101282: PUSH
101283: LD_INT 1
101285: PPUSH
101286: LD_VAR 0 3
101290: PPUSH
101291: CALL_OW 12
101295: ARRAY
101296: ST_TO_ADDR
// if Crawls ( un ) then
101297: LD_VAR 0 2
101301: PPUSH
101302: CALL_OW 318
101306: IFFALSE 101317
// ComWalk ( un ) ;
101308: LD_VAR 0 2
101312: PPUSH
101313: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101317: LD_VAR 0 2
101321: PPUSH
101322: LD_INT 5
101324: PPUSH
101325: CALL_OW 336
// end ;
101329: PPOPN 3
101331: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101332: LD_EXP 99
101336: PUSH
101337: LD_EXP 117
101341: AND
101342: PUSH
101343: LD_OWVAR 67
101347: PUSH
101348: LD_INT 4
101350: LESS
101351: AND
101352: IFFALSE 101371
101354: GO 101356
101356: DISABLE
// begin Difficulty := Difficulty + 1 ;
101357: LD_ADDR_OWVAR 67
101361: PUSH
101362: LD_OWVAR 67
101366: PUSH
101367: LD_INT 1
101369: PLUS
101370: ST_TO_ADDR
// end ;
101371: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101372: LD_EXP 99
101376: PUSH
101377: LD_EXP 118
101381: AND
101382: IFFALSE 101485
101384: GO 101386
101386: DISABLE
101387: LD_INT 0
101389: PPUSH
// begin for i := 1 to 5 do
101390: LD_ADDR_VAR 0 1
101394: PUSH
101395: DOUBLE
101396: LD_INT 1
101398: DEC
101399: ST_TO_ADDR
101400: LD_INT 5
101402: PUSH
101403: FOR_TO
101404: IFFALSE 101483
// begin uc_nation := nation_nature ;
101406: LD_ADDR_OWVAR 21
101410: PUSH
101411: LD_INT 0
101413: ST_TO_ADDR
// uc_side := 0 ;
101414: LD_ADDR_OWVAR 20
101418: PUSH
101419: LD_INT 0
101421: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101422: LD_ADDR_OWVAR 29
101426: PUSH
101427: LD_INT 12
101429: PUSH
101430: LD_INT 12
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: ST_TO_ADDR
// hc_agressivity := 20 ;
101437: LD_ADDR_OWVAR 35
101441: PUSH
101442: LD_INT 20
101444: ST_TO_ADDR
// hc_class := class_tiger ;
101445: LD_ADDR_OWVAR 28
101449: PUSH
101450: LD_INT 14
101452: ST_TO_ADDR
// hc_gallery :=  ;
101453: LD_ADDR_OWVAR 33
101457: PUSH
101458: LD_STRING 
101460: ST_TO_ADDR
// hc_name :=  ;
101461: LD_ADDR_OWVAR 26
101465: PUSH
101466: LD_STRING 
101468: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101469: CALL_OW 44
101473: PPUSH
101474: LD_INT 0
101476: PPUSH
101477: CALL_OW 51
// end ;
101481: GO 101403
101483: POP
101484: POP
// end ;
101485: PPOPN 1
101487: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101488: LD_EXP 99
101492: PUSH
101493: LD_EXP 119
101497: AND
101498: IFFALSE 101507
101500: GO 101502
101502: DISABLE
// StreamSibBomb ;
101503: CALL 101508 0 0
101507: END
// export function StreamSibBomb ; var i , x , y ; begin
101508: LD_INT 0
101510: PPUSH
101511: PPUSH
101512: PPUSH
101513: PPUSH
// result := false ;
101514: LD_ADDR_VAR 0 1
101518: PUSH
101519: LD_INT 0
101521: ST_TO_ADDR
// for i := 1 to 16 do
101522: LD_ADDR_VAR 0 2
101526: PUSH
101527: DOUBLE
101528: LD_INT 1
101530: DEC
101531: ST_TO_ADDR
101532: LD_INT 16
101534: PUSH
101535: FOR_TO
101536: IFFALSE 101735
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101538: LD_ADDR_VAR 0 3
101542: PUSH
101543: LD_INT 10
101545: PUSH
101546: LD_INT 20
101548: PUSH
101549: LD_INT 30
101551: PUSH
101552: LD_INT 40
101554: PUSH
101555: LD_INT 50
101557: PUSH
101558: LD_INT 60
101560: PUSH
101561: LD_INT 70
101563: PUSH
101564: LD_INT 80
101566: PUSH
101567: LD_INT 90
101569: PUSH
101570: LD_INT 100
101572: PUSH
101573: LD_INT 110
101575: PUSH
101576: LD_INT 120
101578: PUSH
101579: LD_INT 130
101581: PUSH
101582: LD_INT 140
101584: PUSH
101585: LD_INT 150
101587: PUSH
101588: EMPTY
101589: LIST
101590: LIST
101591: LIST
101592: LIST
101593: LIST
101594: LIST
101595: LIST
101596: LIST
101597: LIST
101598: LIST
101599: LIST
101600: LIST
101601: LIST
101602: LIST
101603: LIST
101604: PUSH
101605: LD_INT 1
101607: PPUSH
101608: LD_INT 15
101610: PPUSH
101611: CALL_OW 12
101615: ARRAY
101616: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101617: LD_ADDR_VAR 0 4
101621: PUSH
101622: LD_INT 10
101624: PUSH
101625: LD_INT 20
101627: PUSH
101628: LD_INT 30
101630: PUSH
101631: LD_INT 40
101633: PUSH
101634: LD_INT 50
101636: PUSH
101637: LD_INT 60
101639: PUSH
101640: LD_INT 70
101642: PUSH
101643: LD_INT 80
101645: PUSH
101646: LD_INT 90
101648: PUSH
101649: LD_INT 100
101651: PUSH
101652: LD_INT 110
101654: PUSH
101655: LD_INT 120
101657: PUSH
101658: LD_INT 130
101660: PUSH
101661: LD_INT 140
101663: PUSH
101664: LD_INT 150
101666: PUSH
101667: EMPTY
101668: LIST
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: LIST
101674: LIST
101675: LIST
101676: LIST
101677: LIST
101678: LIST
101679: LIST
101680: LIST
101681: LIST
101682: LIST
101683: PUSH
101684: LD_INT 1
101686: PPUSH
101687: LD_INT 15
101689: PPUSH
101690: CALL_OW 12
101694: ARRAY
101695: ST_TO_ADDR
// if ValidHex ( x , y ) then
101696: LD_VAR 0 3
101700: PPUSH
101701: LD_VAR 0 4
101705: PPUSH
101706: CALL_OW 488
101710: IFFALSE 101733
// begin result := [ x , y ] ;
101712: LD_ADDR_VAR 0 1
101716: PUSH
101717: LD_VAR 0 3
101721: PUSH
101722: LD_VAR 0 4
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: ST_TO_ADDR
// break ;
101731: GO 101735
// end ; end ;
101733: GO 101535
101735: POP
101736: POP
// if result then
101737: LD_VAR 0 1
101741: IFFALSE 101801
// begin ToLua ( playSibBomb() ) ;
101743: LD_STRING playSibBomb()
101745: PPUSH
101746: CALL_OW 559
// wait ( 0 0$14 ) ;
101750: LD_INT 490
101752: PPUSH
101753: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101757: LD_VAR 0 1
101761: PUSH
101762: LD_INT 1
101764: ARRAY
101765: PPUSH
101766: LD_VAR 0 1
101770: PUSH
101771: LD_INT 2
101773: ARRAY
101774: PPUSH
101775: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101779: LD_VAR 0 1
101783: PUSH
101784: LD_INT 1
101786: ARRAY
101787: PPUSH
101788: LD_VAR 0 1
101792: PUSH
101793: LD_INT 2
101795: ARRAY
101796: PPUSH
101797: CALL_OW 429
// end ; end ;
101801: LD_VAR 0 1
101805: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101806: LD_EXP 99
101810: PUSH
101811: LD_EXP 121
101815: AND
101816: IFFALSE 101828
101818: GO 101820
101820: DISABLE
// YouLost (  ) ;
101821: LD_STRING 
101823: PPUSH
101824: CALL_OW 104
101828: END
// every 0 0$1 trigger StreamModeActive and sFog do
101829: LD_EXP 99
101833: PUSH
101834: LD_EXP 120
101838: AND
101839: IFFALSE 101853
101841: GO 101843
101843: DISABLE
// FogOff ( your_side ) ;
101844: LD_OWVAR 2
101848: PPUSH
101849: CALL_OW 344
101853: END
// every 0 0$1 trigger StreamModeActive and sSun do
101854: LD_EXP 99
101858: PUSH
101859: LD_EXP 122
101863: AND
101864: IFFALSE 101892
101866: GO 101868
101868: DISABLE
// begin solar_recharge_percent := 0 ;
101869: LD_ADDR_OWVAR 79
101873: PUSH
101874: LD_INT 0
101876: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101877: LD_INT 10500
101879: PPUSH
101880: CALL_OW 67
// solar_recharge_percent := 100 ;
101884: LD_ADDR_OWVAR 79
101888: PUSH
101889: LD_INT 100
101891: ST_TO_ADDR
// end ;
101892: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101893: LD_EXP 99
101897: PUSH
101898: LD_EXP 123
101902: AND
101903: IFFALSE 102142
101905: GO 101907
101907: DISABLE
101908: LD_INT 0
101910: PPUSH
101911: PPUSH
101912: PPUSH
// begin tmp := [ ] ;
101913: LD_ADDR_VAR 0 3
101917: PUSH
101918: EMPTY
101919: ST_TO_ADDR
// for i := 1 to 6 do
101920: LD_ADDR_VAR 0 1
101924: PUSH
101925: DOUBLE
101926: LD_INT 1
101928: DEC
101929: ST_TO_ADDR
101930: LD_INT 6
101932: PUSH
101933: FOR_TO
101934: IFFALSE 102039
// begin uc_nation := nation_nature ;
101936: LD_ADDR_OWVAR 21
101940: PUSH
101941: LD_INT 0
101943: ST_TO_ADDR
// uc_side := 0 ;
101944: LD_ADDR_OWVAR 20
101948: PUSH
101949: LD_INT 0
101951: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101952: LD_ADDR_OWVAR 29
101956: PUSH
101957: LD_INT 12
101959: PUSH
101960: LD_INT 12
101962: PUSH
101963: EMPTY
101964: LIST
101965: LIST
101966: ST_TO_ADDR
// hc_agressivity := 20 ;
101967: LD_ADDR_OWVAR 35
101971: PUSH
101972: LD_INT 20
101974: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101975: LD_ADDR_OWVAR 28
101979: PUSH
101980: LD_INT 17
101982: ST_TO_ADDR
// hc_gallery :=  ;
101983: LD_ADDR_OWVAR 33
101987: PUSH
101988: LD_STRING 
101990: ST_TO_ADDR
// hc_name :=  ;
101991: LD_ADDR_OWVAR 26
101995: PUSH
101996: LD_STRING 
101998: ST_TO_ADDR
// un := CreateHuman ;
101999: LD_ADDR_VAR 0 2
102003: PUSH
102004: CALL_OW 44
102008: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102009: LD_VAR 0 2
102013: PPUSH
102014: LD_INT 1
102016: PPUSH
102017: CALL_OW 51
// tmp := tmp ^ un ;
102021: LD_ADDR_VAR 0 3
102025: PUSH
102026: LD_VAR 0 3
102030: PUSH
102031: LD_VAR 0 2
102035: ADD
102036: ST_TO_ADDR
// end ;
102037: GO 101933
102039: POP
102040: POP
// repeat wait ( 0 0$1 ) ;
102041: LD_INT 35
102043: PPUSH
102044: CALL_OW 67
// for un in tmp do
102048: LD_ADDR_VAR 0 2
102052: PUSH
102053: LD_VAR 0 3
102057: PUSH
102058: FOR_IN
102059: IFFALSE 102133
// begin if IsDead ( un ) then
102061: LD_VAR 0 2
102065: PPUSH
102066: CALL_OW 301
102070: IFFALSE 102090
// begin tmp := tmp diff un ;
102072: LD_ADDR_VAR 0 3
102076: PUSH
102077: LD_VAR 0 3
102081: PUSH
102082: LD_VAR 0 2
102086: DIFF
102087: ST_TO_ADDR
// continue ;
102088: GO 102058
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102090: LD_VAR 0 2
102094: PPUSH
102095: LD_INT 3
102097: PUSH
102098: LD_INT 22
102100: PUSH
102101: LD_INT 0
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: PPUSH
102112: CALL_OW 69
102116: PPUSH
102117: LD_VAR 0 2
102121: PPUSH
102122: CALL_OW 74
102126: PPUSH
102127: CALL_OW 115
// end ;
102131: GO 102058
102133: POP
102134: POP
// until not tmp ;
102135: LD_VAR 0 3
102139: NOT
102140: IFFALSE 102041
// end ;
102142: PPOPN 3
102144: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102145: LD_EXP 99
102149: PUSH
102150: LD_EXP 124
102154: AND
102155: IFFALSE 102209
102157: GO 102159
102159: DISABLE
// begin ToLua ( displayTroll(); ) ;
102160: LD_STRING displayTroll();
102162: PPUSH
102163: CALL_OW 559
// wait ( 3 3$00 ) ;
102167: LD_INT 6300
102169: PPUSH
102170: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102174: LD_STRING hideTroll();
102176: PPUSH
102177: CALL_OW 559
// wait ( 1 1$00 ) ;
102181: LD_INT 2100
102183: PPUSH
102184: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102188: LD_STRING displayTroll();
102190: PPUSH
102191: CALL_OW 559
// wait ( 1 1$00 ) ;
102195: LD_INT 2100
102197: PPUSH
102198: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102202: LD_STRING hideTroll();
102204: PPUSH
102205: CALL_OW 559
// end ;
102209: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102210: LD_EXP 99
102214: PUSH
102215: LD_EXP 125
102219: AND
102220: IFFALSE 102283
102222: GO 102224
102224: DISABLE
102225: LD_INT 0
102227: PPUSH
// begin p := 0 ;
102228: LD_ADDR_VAR 0 1
102232: PUSH
102233: LD_INT 0
102235: ST_TO_ADDR
// repeat game_speed := 1 ;
102236: LD_ADDR_OWVAR 65
102240: PUSH
102241: LD_INT 1
102243: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102244: LD_INT 35
102246: PPUSH
102247: CALL_OW 67
// p := p + 1 ;
102251: LD_ADDR_VAR 0 1
102255: PUSH
102256: LD_VAR 0 1
102260: PUSH
102261: LD_INT 1
102263: PLUS
102264: ST_TO_ADDR
// until p >= 60 ;
102265: LD_VAR 0 1
102269: PUSH
102270: LD_INT 60
102272: GREATEREQUAL
102273: IFFALSE 102236
// game_speed := 4 ;
102275: LD_ADDR_OWVAR 65
102279: PUSH
102280: LD_INT 4
102282: ST_TO_ADDR
// end ;
102283: PPOPN 1
102285: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102286: LD_EXP 99
102290: PUSH
102291: LD_EXP 126
102295: AND
102296: IFFALSE 102442
102298: GO 102300
102300: DISABLE
102301: LD_INT 0
102303: PPUSH
102304: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102305: LD_ADDR_VAR 0 1
102309: PUSH
102310: LD_INT 22
102312: PUSH
102313: LD_OWVAR 2
102317: PUSH
102318: EMPTY
102319: LIST
102320: LIST
102321: PUSH
102322: LD_INT 2
102324: PUSH
102325: LD_INT 30
102327: PUSH
102328: LD_INT 0
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: PUSH
102335: LD_INT 30
102337: PUSH
102338: LD_INT 1
102340: PUSH
102341: EMPTY
102342: LIST
102343: LIST
102344: PUSH
102345: EMPTY
102346: LIST
102347: LIST
102348: LIST
102349: PUSH
102350: EMPTY
102351: LIST
102352: LIST
102353: PPUSH
102354: CALL_OW 69
102358: ST_TO_ADDR
// if not depot then
102359: LD_VAR 0 1
102363: NOT
102364: IFFALSE 102368
// exit ;
102366: GO 102442
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102368: LD_ADDR_VAR 0 2
102372: PUSH
102373: LD_VAR 0 1
102377: PUSH
102378: LD_INT 1
102380: PPUSH
102381: LD_VAR 0 1
102385: PPUSH
102386: CALL_OW 12
102390: ARRAY
102391: PPUSH
102392: CALL_OW 274
102396: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102397: LD_VAR 0 2
102401: PPUSH
102402: LD_INT 1
102404: PPUSH
102405: LD_INT 0
102407: PPUSH
102408: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102412: LD_VAR 0 2
102416: PPUSH
102417: LD_INT 2
102419: PPUSH
102420: LD_INT 0
102422: PPUSH
102423: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102427: LD_VAR 0 2
102431: PPUSH
102432: LD_INT 3
102434: PPUSH
102435: LD_INT 0
102437: PPUSH
102438: CALL_OW 277
// end ;
102442: PPOPN 2
102444: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102445: LD_EXP 99
102449: PUSH
102450: LD_EXP 127
102454: AND
102455: IFFALSE 102552
102457: GO 102459
102459: DISABLE
102460: LD_INT 0
102462: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102463: LD_ADDR_VAR 0 1
102467: PUSH
102468: LD_INT 22
102470: PUSH
102471: LD_OWVAR 2
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: LD_INT 21
102482: PUSH
102483: LD_INT 1
102485: PUSH
102486: EMPTY
102487: LIST
102488: LIST
102489: PUSH
102490: LD_INT 3
102492: PUSH
102493: LD_INT 23
102495: PUSH
102496: LD_INT 0
102498: PUSH
102499: EMPTY
102500: LIST
102501: LIST
102502: PUSH
102503: EMPTY
102504: LIST
102505: LIST
102506: PUSH
102507: EMPTY
102508: LIST
102509: LIST
102510: LIST
102511: PPUSH
102512: CALL_OW 69
102516: ST_TO_ADDR
// if not tmp then
102517: LD_VAR 0 1
102521: NOT
102522: IFFALSE 102526
// exit ;
102524: GO 102552
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102526: LD_VAR 0 1
102530: PUSH
102531: LD_INT 1
102533: PPUSH
102534: LD_VAR 0 1
102538: PPUSH
102539: CALL_OW 12
102543: ARRAY
102544: PPUSH
102545: LD_INT 200
102547: PPUSH
102548: CALL_OW 234
// end ;
102552: PPOPN 1
102554: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102555: LD_EXP 99
102559: PUSH
102560: LD_EXP 128
102564: AND
102565: IFFALSE 102644
102567: GO 102569
102569: DISABLE
102570: LD_INT 0
102572: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102573: LD_ADDR_VAR 0 1
102577: PUSH
102578: LD_INT 22
102580: PUSH
102581: LD_OWVAR 2
102585: PUSH
102586: EMPTY
102587: LIST
102588: LIST
102589: PUSH
102590: LD_INT 21
102592: PUSH
102593: LD_INT 2
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: PUSH
102600: EMPTY
102601: LIST
102602: LIST
102603: PPUSH
102604: CALL_OW 69
102608: ST_TO_ADDR
// if not tmp then
102609: LD_VAR 0 1
102613: NOT
102614: IFFALSE 102618
// exit ;
102616: GO 102644
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102618: LD_VAR 0 1
102622: PUSH
102623: LD_INT 1
102625: PPUSH
102626: LD_VAR 0 1
102630: PPUSH
102631: CALL_OW 12
102635: ARRAY
102636: PPUSH
102637: LD_INT 60
102639: PPUSH
102640: CALL_OW 234
// end ;
102644: PPOPN 1
102646: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102647: LD_EXP 99
102651: PUSH
102652: LD_EXP 129
102656: AND
102657: IFFALSE 102756
102659: GO 102661
102661: DISABLE
102662: LD_INT 0
102664: PPUSH
102665: PPUSH
// begin enable ;
102666: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102667: LD_ADDR_VAR 0 1
102671: PUSH
102672: LD_INT 22
102674: PUSH
102675: LD_OWVAR 2
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: PUSH
102684: LD_INT 61
102686: PUSH
102687: EMPTY
102688: LIST
102689: PUSH
102690: LD_INT 33
102692: PUSH
102693: LD_INT 2
102695: PUSH
102696: EMPTY
102697: LIST
102698: LIST
102699: PUSH
102700: EMPTY
102701: LIST
102702: LIST
102703: LIST
102704: PPUSH
102705: CALL_OW 69
102709: ST_TO_ADDR
// if not tmp then
102710: LD_VAR 0 1
102714: NOT
102715: IFFALSE 102719
// exit ;
102717: GO 102756
// for i in tmp do
102719: LD_ADDR_VAR 0 2
102723: PUSH
102724: LD_VAR 0 1
102728: PUSH
102729: FOR_IN
102730: IFFALSE 102754
// if IsControledBy ( i ) then
102732: LD_VAR 0 2
102736: PPUSH
102737: CALL_OW 312
102741: IFFALSE 102752
// ComUnlink ( i ) ;
102743: LD_VAR 0 2
102747: PPUSH
102748: CALL_OW 136
102752: GO 102729
102754: POP
102755: POP
// end ;
102756: PPOPN 2
102758: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102759: LD_EXP 99
102763: PUSH
102764: LD_EXP 130
102768: AND
102769: IFFALSE 102909
102771: GO 102773
102773: DISABLE
102774: LD_INT 0
102776: PPUSH
102777: PPUSH
// begin ToLua ( displayPowell(); ) ;
102778: LD_STRING displayPowell();
102780: PPUSH
102781: CALL_OW 559
// uc_side := 0 ;
102785: LD_ADDR_OWVAR 20
102789: PUSH
102790: LD_INT 0
102792: ST_TO_ADDR
// uc_nation := 2 ;
102793: LD_ADDR_OWVAR 21
102797: PUSH
102798: LD_INT 2
102800: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102801: LD_ADDR_OWVAR 37
102805: PUSH
102806: LD_INT 14
102808: ST_TO_ADDR
// vc_engine := engine_siberite ;
102809: LD_ADDR_OWVAR 39
102813: PUSH
102814: LD_INT 3
102816: ST_TO_ADDR
// vc_control := control_apeman ;
102817: LD_ADDR_OWVAR 38
102821: PUSH
102822: LD_INT 5
102824: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102825: LD_ADDR_OWVAR 40
102829: PUSH
102830: LD_INT 29
102832: ST_TO_ADDR
// un := CreateVehicle ;
102833: LD_ADDR_VAR 0 2
102837: PUSH
102838: CALL_OW 45
102842: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102843: LD_VAR 0 2
102847: PPUSH
102848: LD_INT 1
102850: PPUSH
102851: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102855: LD_INT 35
102857: PPUSH
102858: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102862: LD_VAR 0 2
102866: PPUSH
102867: LD_INT 22
102869: PUSH
102870: LD_OWVAR 2
102874: PUSH
102875: EMPTY
102876: LIST
102877: LIST
102878: PPUSH
102879: CALL_OW 69
102883: PPUSH
102884: LD_VAR 0 2
102888: PPUSH
102889: CALL_OW 74
102893: PPUSH
102894: CALL_OW 115
// until IsDead ( un ) ;
102898: LD_VAR 0 2
102902: PPUSH
102903: CALL_OW 301
102907: IFFALSE 102855
// end ;
102909: PPOPN 2
102911: END
// every 0 0$1 trigger StreamModeActive and sStu do
102912: LD_EXP 99
102916: PUSH
102917: LD_EXP 138
102921: AND
102922: IFFALSE 102938
102924: GO 102926
102926: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102927: LD_STRING displayStucuk();
102929: PPUSH
102930: CALL_OW 559
// ResetFog ;
102934: CALL_OW 335
// end ;
102938: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102939: LD_EXP 99
102943: PUSH
102944: LD_EXP 131
102948: AND
102949: IFFALSE 103090
102951: GO 102953
102953: DISABLE
102954: LD_INT 0
102956: PPUSH
102957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102958: LD_ADDR_VAR 0 2
102962: PUSH
102963: LD_INT 22
102965: PUSH
102966: LD_OWVAR 2
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: PUSH
102975: LD_INT 21
102977: PUSH
102978: LD_INT 1
102980: PUSH
102981: EMPTY
102982: LIST
102983: LIST
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: PPUSH
102989: CALL_OW 69
102993: ST_TO_ADDR
// if not tmp then
102994: LD_VAR 0 2
102998: NOT
102999: IFFALSE 103003
// exit ;
103001: GO 103090
// un := tmp [ rand ( 1 , tmp ) ] ;
103003: LD_ADDR_VAR 0 1
103007: PUSH
103008: LD_VAR 0 2
103012: PUSH
103013: LD_INT 1
103015: PPUSH
103016: LD_VAR 0 2
103020: PPUSH
103021: CALL_OW 12
103025: ARRAY
103026: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103027: LD_VAR 0 1
103031: PPUSH
103032: LD_INT 0
103034: PPUSH
103035: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103039: LD_VAR 0 1
103043: PPUSH
103044: LD_OWVAR 3
103048: PUSH
103049: LD_VAR 0 1
103053: DIFF
103054: PPUSH
103055: LD_VAR 0 1
103059: PPUSH
103060: CALL_OW 74
103064: PPUSH
103065: CALL_OW 115
// wait ( 0 0$20 ) ;
103069: LD_INT 700
103071: PPUSH
103072: CALL_OW 67
// SetSide ( un , your_side ) ;
103076: LD_VAR 0 1
103080: PPUSH
103081: LD_OWVAR 2
103085: PPUSH
103086: CALL_OW 235
// end ;
103090: PPOPN 2
103092: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103093: LD_EXP 99
103097: PUSH
103098: LD_EXP 132
103102: AND
103103: IFFALSE 103209
103105: GO 103107
103107: DISABLE
103108: LD_INT 0
103110: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103111: LD_ADDR_VAR 0 1
103115: PUSH
103116: LD_INT 22
103118: PUSH
103119: LD_OWVAR 2
103123: PUSH
103124: EMPTY
103125: LIST
103126: LIST
103127: PUSH
103128: LD_INT 2
103130: PUSH
103131: LD_INT 30
103133: PUSH
103134: LD_INT 0
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: PUSH
103141: LD_INT 30
103143: PUSH
103144: LD_INT 1
103146: PUSH
103147: EMPTY
103148: LIST
103149: LIST
103150: PUSH
103151: EMPTY
103152: LIST
103153: LIST
103154: LIST
103155: PUSH
103156: EMPTY
103157: LIST
103158: LIST
103159: PPUSH
103160: CALL_OW 69
103164: ST_TO_ADDR
// if not depot then
103165: LD_VAR 0 1
103169: NOT
103170: IFFALSE 103174
// exit ;
103172: GO 103209
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103174: LD_VAR 0 1
103178: PUSH
103179: LD_INT 1
103181: ARRAY
103182: PPUSH
103183: CALL_OW 250
103187: PPUSH
103188: LD_VAR 0 1
103192: PUSH
103193: LD_INT 1
103195: ARRAY
103196: PPUSH
103197: CALL_OW 251
103201: PPUSH
103202: LD_INT 70
103204: PPUSH
103205: CALL_OW 495
// end ;
103209: PPOPN 1
103211: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103212: LD_EXP 99
103216: PUSH
103217: LD_EXP 133
103221: AND
103222: IFFALSE 103433
103224: GO 103226
103226: DISABLE
103227: LD_INT 0
103229: PPUSH
103230: PPUSH
103231: PPUSH
103232: PPUSH
103233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103234: LD_ADDR_VAR 0 5
103238: PUSH
103239: LD_INT 22
103241: PUSH
103242: LD_OWVAR 2
103246: PUSH
103247: EMPTY
103248: LIST
103249: LIST
103250: PUSH
103251: LD_INT 21
103253: PUSH
103254: LD_INT 1
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: PUSH
103261: EMPTY
103262: LIST
103263: LIST
103264: PPUSH
103265: CALL_OW 69
103269: ST_TO_ADDR
// if not tmp then
103270: LD_VAR 0 5
103274: NOT
103275: IFFALSE 103279
// exit ;
103277: GO 103433
// for i in tmp do
103279: LD_ADDR_VAR 0 1
103283: PUSH
103284: LD_VAR 0 5
103288: PUSH
103289: FOR_IN
103290: IFFALSE 103431
// begin d := rand ( 0 , 5 ) ;
103292: LD_ADDR_VAR 0 4
103296: PUSH
103297: LD_INT 0
103299: PPUSH
103300: LD_INT 5
103302: PPUSH
103303: CALL_OW 12
103307: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103308: LD_ADDR_VAR 0 2
103312: PUSH
103313: LD_VAR 0 1
103317: PPUSH
103318: CALL_OW 250
103322: PPUSH
103323: LD_VAR 0 4
103327: PPUSH
103328: LD_INT 3
103330: PPUSH
103331: LD_INT 12
103333: PPUSH
103334: CALL_OW 12
103338: PPUSH
103339: CALL_OW 272
103343: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103344: LD_ADDR_VAR 0 3
103348: PUSH
103349: LD_VAR 0 1
103353: PPUSH
103354: CALL_OW 251
103358: PPUSH
103359: LD_VAR 0 4
103363: PPUSH
103364: LD_INT 3
103366: PPUSH
103367: LD_INT 12
103369: PPUSH
103370: CALL_OW 12
103374: PPUSH
103375: CALL_OW 273
103379: ST_TO_ADDR
// if ValidHex ( x , y ) then
103380: LD_VAR 0 2
103384: PPUSH
103385: LD_VAR 0 3
103389: PPUSH
103390: CALL_OW 488
103394: IFFALSE 103429
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103396: LD_VAR 0 1
103400: PPUSH
103401: LD_VAR 0 2
103405: PPUSH
103406: LD_VAR 0 3
103410: PPUSH
103411: LD_INT 3
103413: PPUSH
103414: LD_INT 6
103416: PPUSH
103417: CALL_OW 12
103421: PPUSH
103422: LD_INT 1
103424: PPUSH
103425: CALL_OW 483
// end ;
103429: GO 103289
103431: POP
103432: POP
// end ;
103433: PPOPN 5
103435: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103436: LD_EXP 99
103440: PUSH
103441: LD_EXP 134
103445: AND
103446: IFFALSE 103540
103448: GO 103450
103450: DISABLE
103451: LD_INT 0
103453: PPUSH
103454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103455: LD_ADDR_VAR 0 2
103459: PUSH
103460: LD_INT 22
103462: PUSH
103463: LD_OWVAR 2
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PUSH
103472: LD_INT 32
103474: PUSH
103475: LD_INT 1
103477: PUSH
103478: EMPTY
103479: LIST
103480: LIST
103481: PUSH
103482: LD_INT 21
103484: PUSH
103485: LD_INT 2
103487: PUSH
103488: EMPTY
103489: LIST
103490: LIST
103491: PUSH
103492: EMPTY
103493: LIST
103494: LIST
103495: LIST
103496: PPUSH
103497: CALL_OW 69
103501: ST_TO_ADDR
// if not tmp then
103502: LD_VAR 0 2
103506: NOT
103507: IFFALSE 103511
// exit ;
103509: GO 103540
// for i in tmp do
103511: LD_ADDR_VAR 0 1
103515: PUSH
103516: LD_VAR 0 2
103520: PUSH
103521: FOR_IN
103522: IFFALSE 103538
// SetFuel ( i , 0 ) ;
103524: LD_VAR 0 1
103528: PPUSH
103529: LD_INT 0
103531: PPUSH
103532: CALL_OW 240
103536: GO 103521
103538: POP
103539: POP
// end ;
103540: PPOPN 2
103542: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103543: LD_EXP 99
103547: PUSH
103548: LD_EXP 135
103552: AND
103553: IFFALSE 103619
103555: GO 103557
103557: DISABLE
103558: LD_INT 0
103560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103561: LD_ADDR_VAR 0 1
103565: PUSH
103566: LD_INT 22
103568: PUSH
103569: LD_OWVAR 2
103573: PUSH
103574: EMPTY
103575: LIST
103576: LIST
103577: PUSH
103578: LD_INT 30
103580: PUSH
103581: LD_INT 29
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: PUSH
103588: EMPTY
103589: LIST
103590: LIST
103591: PPUSH
103592: CALL_OW 69
103596: ST_TO_ADDR
// if not tmp then
103597: LD_VAR 0 1
103601: NOT
103602: IFFALSE 103606
// exit ;
103604: GO 103619
// DestroyUnit ( tmp [ 1 ] ) ;
103606: LD_VAR 0 1
103610: PUSH
103611: LD_INT 1
103613: ARRAY
103614: PPUSH
103615: CALL_OW 65
// end ;
103619: PPOPN 1
103621: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103622: LD_EXP 99
103626: PUSH
103627: LD_EXP 137
103631: AND
103632: IFFALSE 103761
103634: GO 103636
103636: DISABLE
103637: LD_INT 0
103639: PPUSH
// begin uc_side := 0 ;
103640: LD_ADDR_OWVAR 20
103644: PUSH
103645: LD_INT 0
103647: ST_TO_ADDR
// uc_nation := nation_arabian ;
103648: LD_ADDR_OWVAR 21
103652: PUSH
103653: LD_INT 2
103655: ST_TO_ADDR
// hc_gallery :=  ;
103656: LD_ADDR_OWVAR 33
103660: PUSH
103661: LD_STRING 
103663: ST_TO_ADDR
// hc_name :=  ;
103664: LD_ADDR_OWVAR 26
103668: PUSH
103669: LD_STRING 
103671: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103672: LD_INT 1
103674: PPUSH
103675: LD_INT 11
103677: PPUSH
103678: LD_INT 10
103680: PPUSH
103681: CALL_OW 380
// un := CreateHuman ;
103685: LD_ADDR_VAR 0 1
103689: PUSH
103690: CALL_OW 44
103694: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103695: LD_VAR 0 1
103699: PPUSH
103700: LD_INT 1
103702: PPUSH
103703: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103707: LD_INT 35
103709: PPUSH
103710: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103714: LD_VAR 0 1
103718: PPUSH
103719: LD_INT 22
103721: PUSH
103722: LD_OWVAR 2
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: PPUSH
103731: CALL_OW 69
103735: PPUSH
103736: LD_VAR 0 1
103740: PPUSH
103741: CALL_OW 74
103745: PPUSH
103746: CALL_OW 115
// until IsDead ( un ) ;
103750: LD_VAR 0 1
103754: PPUSH
103755: CALL_OW 301
103759: IFFALSE 103707
// end ;
103761: PPOPN 1
103763: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103764: LD_EXP 99
103768: PUSH
103769: LD_EXP 139
103773: AND
103774: IFFALSE 103786
103776: GO 103778
103778: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103779: LD_STRING earthquake(getX(game), 0, 32)
103781: PPUSH
103782: CALL_OW 559
103786: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103787: LD_EXP 99
103791: PUSH
103792: LD_EXP 140
103796: AND
103797: IFFALSE 103888
103799: GO 103801
103801: DISABLE
103802: LD_INT 0
103804: PPUSH
// begin enable ;
103805: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103806: LD_ADDR_VAR 0 1
103810: PUSH
103811: LD_INT 22
103813: PUSH
103814: LD_OWVAR 2
103818: PUSH
103819: EMPTY
103820: LIST
103821: LIST
103822: PUSH
103823: LD_INT 21
103825: PUSH
103826: LD_INT 2
103828: PUSH
103829: EMPTY
103830: LIST
103831: LIST
103832: PUSH
103833: LD_INT 33
103835: PUSH
103836: LD_INT 3
103838: PUSH
103839: EMPTY
103840: LIST
103841: LIST
103842: PUSH
103843: EMPTY
103844: LIST
103845: LIST
103846: LIST
103847: PPUSH
103848: CALL_OW 69
103852: ST_TO_ADDR
// if not tmp then
103853: LD_VAR 0 1
103857: NOT
103858: IFFALSE 103862
// exit ;
103860: GO 103888
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103862: LD_VAR 0 1
103866: PUSH
103867: LD_INT 1
103869: PPUSH
103870: LD_VAR 0 1
103874: PPUSH
103875: CALL_OW 12
103879: ARRAY
103880: PPUSH
103881: LD_INT 1
103883: PPUSH
103884: CALL_OW 234
// end ;
103888: PPOPN 1
103890: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103891: LD_EXP 99
103895: PUSH
103896: LD_EXP 141
103900: AND
103901: IFFALSE 104042
103903: GO 103905
103905: DISABLE
103906: LD_INT 0
103908: PPUSH
103909: PPUSH
103910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103911: LD_ADDR_VAR 0 3
103915: PUSH
103916: LD_INT 22
103918: PUSH
103919: LD_OWVAR 2
103923: PUSH
103924: EMPTY
103925: LIST
103926: LIST
103927: PUSH
103928: LD_INT 25
103930: PUSH
103931: LD_INT 1
103933: PUSH
103934: EMPTY
103935: LIST
103936: LIST
103937: PUSH
103938: EMPTY
103939: LIST
103940: LIST
103941: PPUSH
103942: CALL_OW 69
103946: ST_TO_ADDR
// if not tmp then
103947: LD_VAR 0 3
103951: NOT
103952: IFFALSE 103956
// exit ;
103954: GO 104042
// un := tmp [ rand ( 1 , tmp ) ] ;
103956: LD_ADDR_VAR 0 2
103960: PUSH
103961: LD_VAR 0 3
103965: PUSH
103966: LD_INT 1
103968: PPUSH
103969: LD_VAR 0 3
103973: PPUSH
103974: CALL_OW 12
103978: ARRAY
103979: ST_TO_ADDR
// if Crawls ( un ) then
103980: LD_VAR 0 2
103984: PPUSH
103985: CALL_OW 318
103989: IFFALSE 104000
// ComWalk ( un ) ;
103991: LD_VAR 0 2
103995: PPUSH
103996: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104000: LD_VAR 0 2
104004: PPUSH
104005: LD_INT 9
104007: PPUSH
104008: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104012: LD_INT 28
104014: PPUSH
104015: LD_OWVAR 2
104019: PPUSH
104020: LD_INT 2
104022: PPUSH
104023: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104027: LD_INT 29
104029: PPUSH
104030: LD_OWVAR 2
104034: PPUSH
104035: LD_INT 2
104037: PPUSH
104038: CALL_OW 322
// end ;
104042: PPOPN 3
104044: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104045: LD_EXP 99
104049: PUSH
104050: LD_EXP 142
104054: AND
104055: IFFALSE 104166
104057: GO 104059
104059: DISABLE
104060: LD_INT 0
104062: PPUSH
104063: PPUSH
104064: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104065: LD_ADDR_VAR 0 3
104069: PUSH
104070: LD_INT 22
104072: PUSH
104073: LD_OWVAR 2
104077: PUSH
104078: EMPTY
104079: LIST
104080: LIST
104081: PUSH
104082: LD_INT 25
104084: PUSH
104085: LD_INT 1
104087: PUSH
104088: EMPTY
104089: LIST
104090: LIST
104091: PUSH
104092: EMPTY
104093: LIST
104094: LIST
104095: PPUSH
104096: CALL_OW 69
104100: ST_TO_ADDR
// if not tmp then
104101: LD_VAR 0 3
104105: NOT
104106: IFFALSE 104110
// exit ;
104108: GO 104166
// un := tmp [ rand ( 1 , tmp ) ] ;
104110: LD_ADDR_VAR 0 2
104114: PUSH
104115: LD_VAR 0 3
104119: PUSH
104120: LD_INT 1
104122: PPUSH
104123: LD_VAR 0 3
104127: PPUSH
104128: CALL_OW 12
104132: ARRAY
104133: ST_TO_ADDR
// if Crawls ( un ) then
104134: LD_VAR 0 2
104138: PPUSH
104139: CALL_OW 318
104143: IFFALSE 104154
// ComWalk ( un ) ;
104145: LD_VAR 0 2
104149: PPUSH
104150: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104154: LD_VAR 0 2
104158: PPUSH
104159: LD_INT 8
104161: PPUSH
104162: CALL_OW 336
// end ;
104166: PPOPN 3
104168: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104169: LD_EXP 99
104173: PUSH
104174: LD_EXP 143
104178: AND
104179: IFFALSE 104323
104181: GO 104183
104183: DISABLE
104184: LD_INT 0
104186: PPUSH
104187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104188: LD_ADDR_VAR 0 2
104192: PUSH
104193: LD_INT 22
104195: PUSH
104196: LD_OWVAR 2
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PUSH
104205: LD_INT 21
104207: PUSH
104208: LD_INT 2
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: PUSH
104215: LD_INT 2
104217: PUSH
104218: LD_INT 34
104220: PUSH
104221: LD_INT 12
104223: PUSH
104224: EMPTY
104225: LIST
104226: LIST
104227: PUSH
104228: LD_INT 34
104230: PUSH
104231: LD_INT 51
104233: PUSH
104234: EMPTY
104235: LIST
104236: LIST
104237: PUSH
104238: LD_INT 34
104240: PUSH
104241: LD_INT 32
104243: PUSH
104244: EMPTY
104245: LIST
104246: LIST
104247: PUSH
104248: EMPTY
104249: LIST
104250: LIST
104251: LIST
104252: LIST
104253: PUSH
104254: EMPTY
104255: LIST
104256: LIST
104257: LIST
104258: PPUSH
104259: CALL_OW 69
104263: ST_TO_ADDR
// if not tmp then
104264: LD_VAR 0 2
104268: NOT
104269: IFFALSE 104273
// exit ;
104271: GO 104323
// for i in tmp do
104273: LD_ADDR_VAR 0 1
104277: PUSH
104278: LD_VAR 0 2
104282: PUSH
104283: FOR_IN
104284: IFFALSE 104321
// if GetCargo ( i , mat_artifact ) = 0 then
104286: LD_VAR 0 1
104290: PPUSH
104291: LD_INT 4
104293: PPUSH
104294: CALL_OW 289
104298: PUSH
104299: LD_INT 0
104301: EQUAL
104302: IFFALSE 104319
// SetCargo ( i , mat_siberit , 100 ) ;
104304: LD_VAR 0 1
104308: PPUSH
104309: LD_INT 3
104311: PPUSH
104312: LD_INT 100
104314: PPUSH
104315: CALL_OW 290
104319: GO 104283
104321: POP
104322: POP
// end ;
104323: PPOPN 2
104325: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104326: LD_EXP 99
104330: PUSH
104331: LD_EXP 144
104335: AND
104336: IFFALSE 104519
104338: GO 104340
104340: DISABLE
104341: LD_INT 0
104343: PPUSH
104344: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104345: LD_ADDR_VAR 0 2
104349: PUSH
104350: LD_INT 22
104352: PUSH
104353: LD_OWVAR 2
104357: PUSH
104358: EMPTY
104359: LIST
104360: LIST
104361: PPUSH
104362: CALL_OW 69
104366: ST_TO_ADDR
// if not tmp then
104367: LD_VAR 0 2
104371: NOT
104372: IFFALSE 104376
// exit ;
104374: GO 104519
// for i := 1 to 2 do
104376: LD_ADDR_VAR 0 1
104380: PUSH
104381: DOUBLE
104382: LD_INT 1
104384: DEC
104385: ST_TO_ADDR
104386: LD_INT 2
104388: PUSH
104389: FOR_TO
104390: IFFALSE 104517
// begin uc_side := your_side ;
104392: LD_ADDR_OWVAR 20
104396: PUSH
104397: LD_OWVAR 2
104401: ST_TO_ADDR
// uc_nation := nation_american ;
104402: LD_ADDR_OWVAR 21
104406: PUSH
104407: LD_INT 1
104409: ST_TO_ADDR
// vc_chassis := us_morphling ;
104410: LD_ADDR_OWVAR 37
104414: PUSH
104415: LD_INT 5
104417: ST_TO_ADDR
// vc_engine := engine_siberite ;
104418: LD_ADDR_OWVAR 39
104422: PUSH
104423: LD_INT 3
104425: ST_TO_ADDR
// vc_control := control_computer ;
104426: LD_ADDR_OWVAR 38
104430: PUSH
104431: LD_INT 3
104433: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104434: LD_ADDR_OWVAR 40
104438: PUSH
104439: LD_INT 10
104441: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104442: LD_VAR 0 2
104446: PUSH
104447: LD_INT 1
104449: ARRAY
104450: PPUSH
104451: CALL_OW 310
104455: NOT
104456: IFFALSE 104503
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104458: CALL_OW 45
104462: PPUSH
104463: LD_VAR 0 2
104467: PUSH
104468: LD_INT 1
104470: ARRAY
104471: PPUSH
104472: CALL_OW 250
104476: PPUSH
104477: LD_VAR 0 2
104481: PUSH
104482: LD_INT 1
104484: ARRAY
104485: PPUSH
104486: CALL_OW 251
104490: PPUSH
104491: LD_INT 12
104493: PPUSH
104494: LD_INT 1
104496: PPUSH
104497: CALL_OW 50
104501: GO 104515
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104503: CALL_OW 45
104507: PPUSH
104508: LD_INT 1
104510: PPUSH
104511: CALL_OW 51
// end ;
104515: GO 104389
104517: POP
104518: POP
// end ;
104519: PPOPN 2
104521: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104522: LD_EXP 99
104526: PUSH
104527: LD_EXP 145
104531: AND
104532: IFFALSE 104754
104534: GO 104536
104536: DISABLE
104537: LD_INT 0
104539: PPUSH
104540: PPUSH
104541: PPUSH
104542: PPUSH
104543: PPUSH
104544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104545: LD_ADDR_VAR 0 6
104549: PUSH
104550: LD_INT 22
104552: PUSH
104553: LD_OWVAR 2
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: PUSH
104562: LD_INT 21
104564: PUSH
104565: LD_INT 1
104567: PUSH
104568: EMPTY
104569: LIST
104570: LIST
104571: PUSH
104572: LD_INT 3
104574: PUSH
104575: LD_INT 23
104577: PUSH
104578: LD_INT 0
104580: PUSH
104581: EMPTY
104582: LIST
104583: LIST
104584: PUSH
104585: EMPTY
104586: LIST
104587: LIST
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: LIST
104593: PPUSH
104594: CALL_OW 69
104598: ST_TO_ADDR
// if not tmp then
104599: LD_VAR 0 6
104603: NOT
104604: IFFALSE 104608
// exit ;
104606: GO 104754
// s1 := rand ( 1 , 4 ) ;
104608: LD_ADDR_VAR 0 2
104612: PUSH
104613: LD_INT 1
104615: PPUSH
104616: LD_INT 4
104618: PPUSH
104619: CALL_OW 12
104623: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104624: LD_ADDR_VAR 0 4
104628: PUSH
104629: LD_VAR 0 6
104633: PUSH
104634: LD_INT 1
104636: ARRAY
104637: PPUSH
104638: LD_VAR 0 2
104642: PPUSH
104643: CALL_OW 259
104647: ST_TO_ADDR
// if s1 = 1 then
104648: LD_VAR 0 2
104652: PUSH
104653: LD_INT 1
104655: EQUAL
104656: IFFALSE 104676
// s2 := rand ( 2 , 4 ) else
104658: LD_ADDR_VAR 0 3
104662: PUSH
104663: LD_INT 2
104665: PPUSH
104666: LD_INT 4
104668: PPUSH
104669: CALL_OW 12
104673: ST_TO_ADDR
104674: GO 104684
// s2 := 1 ;
104676: LD_ADDR_VAR 0 3
104680: PUSH
104681: LD_INT 1
104683: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104684: LD_ADDR_VAR 0 5
104688: PUSH
104689: LD_VAR 0 6
104693: PUSH
104694: LD_INT 1
104696: ARRAY
104697: PPUSH
104698: LD_VAR 0 3
104702: PPUSH
104703: CALL_OW 259
104707: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104708: LD_VAR 0 6
104712: PUSH
104713: LD_INT 1
104715: ARRAY
104716: PPUSH
104717: LD_VAR 0 2
104721: PPUSH
104722: LD_VAR 0 5
104726: PPUSH
104727: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104731: LD_VAR 0 6
104735: PUSH
104736: LD_INT 1
104738: ARRAY
104739: PPUSH
104740: LD_VAR 0 3
104744: PPUSH
104745: LD_VAR 0 4
104749: PPUSH
104750: CALL_OW 237
// end ;
104754: PPOPN 6
104756: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104757: LD_EXP 99
104761: PUSH
104762: LD_EXP 146
104766: AND
104767: IFFALSE 104846
104769: GO 104771
104771: DISABLE
104772: LD_INT 0
104774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104775: LD_ADDR_VAR 0 1
104779: PUSH
104780: LD_INT 22
104782: PUSH
104783: LD_OWVAR 2
104787: PUSH
104788: EMPTY
104789: LIST
104790: LIST
104791: PUSH
104792: LD_INT 30
104794: PUSH
104795: LD_INT 3
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: PUSH
104802: EMPTY
104803: LIST
104804: LIST
104805: PPUSH
104806: CALL_OW 69
104810: ST_TO_ADDR
// if not tmp then
104811: LD_VAR 0 1
104815: NOT
104816: IFFALSE 104820
// exit ;
104818: GO 104846
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104820: LD_VAR 0 1
104824: PUSH
104825: LD_INT 1
104827: PPUSH
104828: LD_VAR 0 1
104832: PPUSH
104833: CALL_OW 12
104837: ARRAY
104838: PPUSH
104839: LD_INT 1
104841: PPUSH
104842: CALL_OW 234
// end ;
104846: PPOPN 1
104848: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104849: LD_EXP 99
104853: PUSH
104854: LD_EXP 147
104858: AND
104859: IFFALSE 104971
104861: GO 104863
104863: DISABLE
104864: LD_INT 0
104866: PPUSH
104867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104868: LD_ADDR_VAR 0 2
104872: PUSH
104873: LD_INT 22
104875: PUSH
104876: LD_OWVAR 2
104880: PUSH
104881: EMPTY
104882: LIST
104883: LIST
104884: PUSH
104885: LD_INT 2
104887: PUSH
104888: LD_INT 30
104890: PUSH
104891: LD_INT 27
104893: PUSH
104894: EMPTY
104895: LIST
104896: LIST
104897: PUSH
104898: LD_INT 30
104900: PUSH
104901: LD_INT 26
104903: PUSH
104904: EMPTY
104905: LIST
104906: LIST
104907: PUSH
104908: LD_INT 30
104910: PUSH
104911: LD_INT 28
104913: PUSH
104914: EMPTY
104915: LIST
104916: LIST
104917: PUSH
104918: EMPTY
104919: LIST
104920: LIST
104921: LIST
104922: LIST
104923: PUSH
104924: EMPTY
104925: LIST
104926: LIST
104927: PPUSH
104928: CALL_OW 69
104932: ST_TO_ADDR
// if not tmp then
104933: LD_VAR 0 2
104937: NOT
104938: IFFALSE 104942
// exit ;
104940: GO 104971
// for i in tmp do
104942: LD_ADDR_VAR 0 1
104946: PUSH
104947: LD_VAR 0 2
104951: PUSH
104952: FOR_IN
104953: IFFALSE 104969
// SetLives ( i , 1 ) ;
104955: LD_VAR 0 1
104959: PPUSH
104960: LD_INT 1
104962: PPUSH
104963: CALL_OW 234
104967: GO 104952
104969: POP
104970: POP
// end ;
104971: PPOPN 2
104973: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104974: LD_EXP 99
104978: PUSH
104979: LD_EXP 148
104983: AND
104984: IFFALSE 105271
104986: GO 104988
104988: DISABLE
104989: LD_INT 0
104991: PPUSH
104992: PPUSH
104993: PPUSH
// begin i := rand ( 1 , 7 ) ;
104994: LD_ADDR_VAR 0 1
104998: PUSH
104999: LD_INT 1
105001: PPUSH
105002: LD_INT 7
105004: PPUSH
105005: CALL_OW 12
105009: ST_TO_ADDR
// case i of 1 :
105010: LD_VAR 0 1
105014: PUSH
105015: LD_INT 1
105017: DOUBLE
105018: EQUAL
105019: IFTRUE 105023
105021: GO 105033
105023: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105024: LD_STRING earthquake(getX(game), 0, 32)
105026: PPUSH
105027: CALL_OW 559
105031: GO 105271
105033: LD_INT 2
105035: DOUBLE
105036: EQUAL
105037: IFTRUE 105041
105039: GO 105055
105041: POP
// begin ToLua ( displayStucuk(); ) ;
105042: LD_STRING displayStucuk();
105044: PPUSH
105045: CALL_OW 559
// ResetFog ;
105049: CALL_OW 335
// end ; 3 :
105053: GO 105271
105055: LD_INT 3
105057: DOUBLE
105058: EQUAL
105059: IFTRUE 105063
105061: GO 105167
105063: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105064: LD_ADDR_VAR 0 2
105068: PUSH
105069: LD_INT 22
105071: PUSH
105072: LD_OWVAR 2
105076: PUSH
105077: EMPTY
105078: LIST
105079: LIST
105080: PUSH
105081: LD_INT 25
105083: PUSH
105084: LD_INT 1
105086: PUSH
105087: EMPTY
105088: LIST
105089: LIST
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: PPUSH
105095: CALL_OW 69
105099: ST_TO_ADDR
// if not tmp then
105100: LD_VAR 0 2
105104: NOT
105105: IFFALSE 105109
// exit ;
105107: GO 105271
// un := tmp [ rand ( 1 , tmp ) ] ;
105109: LD_ADDR_VAR 0 3
105113: PUSH
105114: LD_VAR 0 2
105118: PUSH
105119: LD_INT 1
105121: PPUSH
105122: LD_VAR 0 2
105126: PPUSH
105127: CALL_OW 12
105131: ARRAY
105132: ST_TO_ADDR
// if Crawls ( un ) then
105133: LD_VAR 0 3
105137: PPUSH
105138: CALL_OW 318
105142: IFFALSE 105153
// ComWalk ( un ) ;
105144: LD_VAR 0 3
105148: PPUSH
105149: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105153: LD_VAR 0 3
105157: PPUSH
105158: LD_INT 8
105160: PPUSH
105161: CALL_OW 336
// end ; 4 :
105165: GO 105271
105167: LD_INT 4
105169: DOUBLE
105170: EQUAL
105171: IFTRUE 105175
105173: GO 105249
105175: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105176: LD_ADDR_VAR 0 2
105180: PUSH
105181: LD_INT 22
105183: PUSH
105184: LD_OWVAR 2
105188: PUSH
105189: EMPTY
105190: LIST
105191: LIST
105192: PUSH
105193: LD_INT 30
105195: PUSH
105196: LD_INT 29
105198: PUSH
105199: EMPTY
105200: LIST
105201: LIST
105202: PUSH
105203: EMPTY
105204: LIST
105205: LIST
105206: PPUSH
105207: CALL_OW 69
105211: ST_TO_ADDR
// if not tmp then
105212: LD_VAR 0 2
105216: NOT
105217: IFFALSE 105221
// exit ;
105219: GO 105271
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105221: LD_VAR 0 2
105225: PUSH
105226: LD_INT 1
105228: ARRAY
105229: PPUSH
105230: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105234: LD_VAR 0 2
105238: PUSH
105239: LD_INT 1
105241: ARRAY
105242: PPUSH
105243: CALL_OW 65
// end ; 5 .. 7 :
105247: GO 105271
105249: LD_INT 5
105251: DOUBLE
105252: GREATEREQUAL
105253: IFFALSE 105261
105255: LD_INT 7
105257: DOUBLE
105258: LESSEQUAL
105259: IFTRUE 105263
105261: GO 105270
105263: POP
// StreamSibBomb ; end ;
105264: CALL 101508 0 0
105268: GO 105271
105270: POP
// end ;
105271: PPOPN 3
105273: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105274: LD_EXP 99
105278: PUSH
105279: LD_EXP 149
105283: AND
105284: IFFALSE 105440
105286: GO 105288
105288: DISABLE
105289: LD_INT 0
105291: PPUSH
105292: PPUSH
105293: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105294: LD_ADDR_VAR 0 2
105298: PUSH
105299: LD_INT 81
105301: PUSH
105302: LD_OWVAR 2
105306: PUSH
105307: EMPTY
105308: LIST
105309: LIST
105310: PUSH
105311: LD_INT 2
105313: PUSH
105314: LD_INT 21
105316: PUSH
105317: LD_INT 1
105319: PUSH
105320: EMPTY
105321: LIST
105322: LIST
105323: PUSH
105324: LD_INT 21
105326: PUSH
105327: LD_INT 2
105329: PUSH
105330: EMPTY
105331: LIST
105332: LIST
105333: PUSH
105334: EMPTY
105335: LIST
105336: LIST
105337: LIST
105338: PUSH
105339: EMPTY
105340: LIST
105341: LIST
105342: PPUSH
105343: CALL_OW 69
105347: ST_TO_ADDR
// if not tmp then
105348: LD_VAR 0 2
105352: NOT
105353: IFFALSE 105357
// exit ;
105355: GO 105440
// p := 0 ;
105357: LD_ADDR_VAR 0 3
105361: PUSH
105362: LD_INT 0
105364: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105365: LD_INT 35
105367: PPUSH
105368: CALL_OW 67
// p := p + 1 ;
105372: LD_ADDR_VAR 0 3
105376: PUSH
105377: LD_VAR 0 3
105381: PUSH
105382: LD_INT 1
105384: PLUS
105385: ST_TO_ADDR
// for i in tmp do
105386: LD_ADDR_VAR 0 1
105390: PUSH
105391: LD_VAR 0 2
105395: PUSH
105396: FOR_IN
105397: IFFALSE 105428
// if GetLives ( i ) < 1000 then
105399: LD_VAR 0 1
105403: PPUSH
105404: CALL_OW 256
105408: PUSH
105409: LD_INT 1000
105411: LESS
105412: IFFALSE 105426
// SetLives ( i , 1000 ) ;
105414: LD_VAR 0 1
105418: PPUSH
105419: LD_INT 1000
105421: PPUSH
105422: CALL_OW 234
105426: GO 105396
105428: POP
105429: POP
// until p > 20 ;
105430: LD_VAR 0 3
105434: PUSH
105435: LD_INT 20
105437: GREATER
105438: IFFALSE 105365
// end ;
105440: PPOPN 3
105442: END
// every 0 0$1 trigger StreamModeActive and sTime do
105443: LD_EXP 99
105447: PUSH
105448: LD_EXP 150
105452: AND
105453: IFFALSE 105488
105455: GO 105457
105457: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105458: LD_INT 28
105460: PPUSH
105461: LD_OWVAR 2
105465: PPUSH
105466: LD_INT 2
105468: PPUSH
105469: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105473: LD_INT 30
105475: PPUSH
105476: LD_OWVAR 2
105480: PPUSH
105481: LD_INT 2
105483: PPUSH
105484: CALL_OW 322
// end ;
105488: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105489: LD_EXP 99
105493: PUSH
105494: LD_EXP 151
105498: AND
105499: IFFALSE 105620
105501: GO 105503
105503: DISABLE
105504: LD_INT 0
105506: PPUSH
105507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105508: LD_ADDR_VAR 0 2
105512: PUSH
105513: LD_INT 22
105515: PUSH
105516: LD_OWVAR 2
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PUSH
105525: LD_INT 21
105527: PUSH
105528: LD_INT 1
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: PUSH
105535: LD_INT 3
105537: PUSH
105538: LD_INT 23
105540: PUSH
105541: LD_INT 0
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PUSH
105548: EMPTY
105549: LIST
105550: LIST
105551: PUSH
105552: EMPTY
105553: LIST
105554: LIST
105555: LIST
105556: PPUSH
105557: CALL_OW 69
105561: ST_TO_ADDR
// if not tmp then
105562: LD_VAR 0 2
105566: NOT
105567: IFFALSE 105571
// exit ;
105569: GO 105620
// for i in tmp do
105571: LD_ADDR_VAR 0 1
105575: PUSH
105576: LD_VAR 0 2
105580: PUSH
105581: FOR_IN
105582: IFFALSE 105618
// begin if Crawls ( i ) then
105584: LD_VAR 0 1
105588: PPUSH
105589: CALL_OW 318
105593: IFFALSE 105604
// ComWalk ( i ) ;
105595: LD_VAR 0 1
105599: PPUSH
105600: CALL_OW 138
// SetClass ( i , 2 ) ;
105604: LD_VAR 0 1
105608: PPUSH
105609: LD_INT 2
105611: PPUSH
105612: CALL_OW 336
// end ;
105616: GO 105581
105618: POP
105619: POP
// end ;
105620: PPOPN 2
105622: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105623: LD_EXP 99
105627: PUSH
105628: LD_EXP 152
105632: AND
105633: IFFALSE 105921
105635: GO 105637
105637: DISABLE
105638: LD_INT 0
105640: PPUSH
105641: PPUSH
105642: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105643: LD_OWVAR 2
105647: PPUSH
105648: LD_INT 9
105650: PPUSH
105651: LD_INT 1
105653: PPUSH
105654: LD_INT 1
105656: PPUSH
105657: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105661: LD_INT 9
105663: PPUSH
105664: LD_OWVAR 2
105668: PPUSH
105669: CALL_OW 343
// uc_side := 9 ;
105673: LD_ADDR_OWVAR 20
105677: PUSH
105678: LD_INT 9
105680: ST_TO_ADDR
// uc_nation := 2 ;
105681: LD_ADDR_OWVAR 21
105685: PUSH
105686: LD_INT 2
105688: ST_TO_ADDR
// hc_name := Dark Warrior ;
105689: LD_ADDR_OWVAR 26
105693: PUSH
105694: LD_STRING Dark Warrior
105696: ST_TO_ADDR
// hc_gallery :=  ;
105697: LD_ADDR_OWVAR 33
105701: PUSH
105702: LD_STRING 
105704: ST_TO_ADDR
// hc_noskilllimit := true ;
105705: LD_ADDR_OWVAR 76
105709: PUSH
105710: LD_INT 1
105712: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105713: LD_ADDR_OWVAR 31
105717: PUSH
105718: LD_INT 30
105720: PUSH
105721: LD_INT 30
105723: PUSH
105724: LD_INT 30
105726: PUSH
105727: LD_INT 30
105729: PUSH
105730: EMPTY
105731: LIST
105732: LIST
105733: LIST
105734: LIST
105735: ST_TO_ADDR
// un := CreateHuman ;
105736: LD_ADDR_VAR 0 3
105740: PUSH
105741: CALL_OW 44
105745: ST_TO_ADDR
// hc_noskilllimit := false ;
105746: LD_ADDR_OWVAR 76
105750: PUSH
105751: LD_INT 0
105753: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105754: LD_VAR 0 3
105758: PPUSH
105759: LD_INT 1
105761: PPUSH
105762: CALL_OW 51
// ToLua ( playRanger() ) ;
105766: LD_STRING playRanger()
105768: PPUSH
105769: CALL_OW 559
// p := 0 ;
105773: LD_ADDR_VAR 0 2
105777: PUSH
105778: LD_INT 0
105780: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105781: LD_INT 35
105783: PPUSH
105784: CALL_OW 67
// p := p + 1 ;
105788: LD_ADDR_VAR 0 2
105792: PUSH
105793: LD_VAR 0 2
105797: PUSH
105798: LD_INT 1
105800: PLUS
105801: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105802: LD_VAR 0 3
105806: PPUSH
105807: CALL_OW 256
105811: PUSH
105812: LD_INT 1000
105814: LESS
105815: IFFALSE 105829
// SetLives ( un , 1000 ) ;
105817: LD_VAR 0 3
105821: PPUSH
105822: LD_INT 1000
105824: PPUSH
105825: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105829: LD_VAR 0 3
105833: PPUSH
105834: LD_INT 81
105836: PUSH
105837: LD_OWVAR 2
105841: PUSH
105842: EMPTY
105843: LIST
105844: LIST
105845: PUSH
105846: LD_INT 91
105848: PUSH
105849: LD_VAR 0 3
105853: PUSH
105854: LD_INT 30
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: LIST
105861: PUSH
105862: EMPTY
105863: LIST
105864: LIST
105865: PPUSH
105866: CALL_OW 69
105870: PPUSH
105871: LD_VAR 0 3
105875: PPUSH
105876: CALL_OW 74
105880: PPUSH
105881: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105885: LD_VAR 0 2
105889: PUSH
105890: LD_INT 80
105892: GREATER
105893: PUSH
105894: LD_VAR 0 3
105898: PPUSH
105899: CALL_OW 301
105903: OR
105904: IFFALSE 105781
// if un then
105906: LD_VAR 0 3
105910: IFFALSE 105921
// RemoveUnit ( un ) ;
105912: LD_VAR 0 3
105916: PPUSH
105917: CALL_OW 64
// end ;
105921: PPOPN 3
105923: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105924: LD_EXP 153
105928: IFFALSE 106044
105930: GO 105932
105932: DISABLE
105933: LD_INT 0
105935: PPUSH
105936: PPUSH
105937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105938: LD_ADDR_VAR 0 2
105942: PUSH
105943: LD_INT 81
105945: PUSH
105946: LD_OWVAR 2
105950: PUSH
105951: EMPTY
105952: LIST
105953: LIST
105954: PUSH
105955: LD_INT 21
105957: PUSH
105958: LD_INT 1
105960: PUSH
105961: EMPTY
105962: LIST
105963: LIST
105964: PUSH
105965: EMPTY
105966: LIST
105967: LIST
105968: PPUSH
105969: CALL_OW 69
105973: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105974: LD_STRING playComputer()
105976: PPUSH
105977: CALL_OW 559
// if not tmp then
105981: LD_VAR 0 2
105985: NOT
105986: IFFALSE 105990
// exit ;
105988: GO 106044
// for i in tmp do
105990: LD_ADDR_VAR 0 1
105994: PUSH
105995: LD_VAR 0 2
105999: PUSH
106000: FOR_IN
106001: IFFALSE 106042
// for j := 1 to 4 do
106003: LD_ADDR_VAR 0 3
106007: PUSH
106008: DOUBLE
106009: LD_INT 1
106011: DEC
106012: ST_TO_ADDR
106013: LD_INT 4
106015: PUSH
106016: FOR_TO
106017: IFFALSE 106038
// SetSkill ( i , j , 10 ) ;
106019: LD_VAR 0 1
106023: PPUSH
106024: LD_VAR 0 3
106028: PPUSH
106029: LD_INT 10
106031: PPUSH
106032: CALL_OW 237
106036: GO 106016
106038: POP
106039: POP
106040: GO 106000
106042: POP
106043: POP
// end ;
106044: PPOPN 3
106046: END
// every 0 0$1 trigger s30 do var i , tmp ;
106047: LD_EXP 154
106051: IFFALSE 106120
106053: GO 106055
106055: DISABLE
106056: LD_INT 0
106058: PPUSH
106059: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106060: LD_ADDR_VAR 0 2
106064: PUSH
106065: LD_INT 22
106067: PUSH
106068: LD_OWVAR 2
106072: PUSH
106073: EMPTY
106074: LIST
106075: LIST
106076: PPUSH
106077: CALL_OW 69
106081: ST_TO_ADDR
// if not tmp then
106082: LD_VAR 0 2
106086: NOT
106087: IFFALSE 106091
// exit ;
106089: GO 106120
// for i in tmp do
106091: LD_ADDR_VAR 0 1
106095: PUSH
106096: LD_VAR 0 2
106100: PUSH
106101: FOR_IN
106102: IFFALSE 106118
// SetLives ( i , 300 ) ;
106104: LD_VAR 0 1
106108: PPUSH
106109: LD_INT 300
106111: PPUSH
106112: CALL_OW 234
106116: GO 106101
106118: POP
106119: POP
// end ;
106120: PPOPN 2
106122: END
// every 0 0$1 trigger s60 do var i , tmp ;
106123: LD_EXP 155
106127: IFFALSE 106196
106129: GO 106131
106131: DISABLE
106132: LD_INT 0
106134: PPUSH
106135: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106136: LD_ADDR_VAR 0 2
106140: PUSH
106141: LD_INT 22
106143: PUSH
106144: LD_OWVAR 2
106148: PUSH
106149: EMPTY
106150: LIST
106151: LIST
106152: PPUSH
106153: CALL_OW 69
106157: ST_TO_ADDR
// if not tmp then
106158: LD_VAR 0 2
106162: NOT
106163: IFFALSE 106167
// exit ;
106165: GO 106196
// for i in tmp do
106167: LD_ADDR_VAR 0 1
106171: PUSH
106172: LD_VAR 0 2
106176: PUSH
106177: FOR_IN
106178: IFFALSE 106194
// SetLives ( i , 600 ) ;
106180: LD_VAR 0 1
106184: PPUSH
106185: LD_INT 600
106187: PPUSH
106188: CALL_OW 234
106192: GO 106177
106194: POP
106195: POP
// end ;
106196: PPOPN 2
106198: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106199: LD_INT 0
106201: PPUSH
// case cmd of 301 :
106202: LD_VAR 0 1
106206: PUSH
106207: LD_INT 301
106209: DOUBLE
106210: EQUAL
106211: IFTRUE 106215
106213: GO 106247
106215: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106216: LD_VAR 0 6
106220: PPUSH
106221: LD_VAR 0 7
106225: PPUSH
106226: LD_VAR 0 8
106230: PPUSH
106231: LD_VAR 0 4
106235: PPUSH
106236: LD_VAR 0 5
106240: PPUSH
106241: CALL 107448 0 5
106245: GO 106368
106247: LD_INT 302
106249: DOUBLE
106250: EQUAL
106251: IFTRUE 106255
106253: GO 106292
106255: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106256: LD_VAR 0 6
106260: PPUSH
106261: LD_VAR 0 7
106265: PPUSH
106266: LD_VAR 0 8
106270: PPUSH
106271: LD_VAR 0 9
106275: PPUSH
106276: LD_VAR 0 4
106280: PPUSH
106281: LD_VAR 0 5
106285: PPUSH
106286: CALL 107539 0 6
106290: GO 106368
106292: LD_INT 303
106294: DOUBLE
106295: EQUAL
106296: IFTRUE 106300
106298: GO 106337
106300: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106301: LD_VAR 0 6
106305: PPUSH
106306: LD_VAR 0 7
106310: PPUSH
106311: LD_VAR 0 8
106315: PPUSH
106316: LD_VAR 0 9
106320: PPUSH
106321: LD_VAR 0 4
106325: PPUSH
106326: LD_VAR 0 5
106330: PPUSH
106331: CALL 106373 0 6
106335: GO 106368
106337: LD_INT 304
106339: DOUBLE
106340: EQUAL
106341: IFTRUE 106345
106343: GO 106367
106345: POP
// hHackTeleport ( unit , x , y ) ; end ;
106346: LD_VAR 0 2
106350: PPUSH
106351: LD_VAR 0 4
106355: PPUSH
106356: LD_VAR 0 5
106360: PPUSH
106361: CALL 108132 0 3
106365: GO 106368
106367: POP
// end ;
106368: LD_VAR 0 12
106372: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106373: LD_INT 0
106375: PPUSH
106376: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106377: LD_VAR 0 1
106381: PUSH
106382: LD_INT 1
106384: LESS
106385: PUSH
106386: LD_VAR 0 1
106390: PUSH
106391: LD_INT 3
106393: GREATER
106394: OR
106395: PUSH
106396: LD_VAR 0 5
106400: PPUSH
106401: LD_VAR 0 6
106405: PPUSH
106406: CALL_OW 428
106410: OR
106411: IFFALSE 106415
// exit ;
106413: GO 107135
// uc_side := your_side ;
106415: LD_ADDR_OWVAR 20
106419: PUSH
106420: LD_OWVAR 2
106424: ST_TO_ADDR
// uc_nation := nation ;
106425: LD_ADDR_OWVAR 21
106429: PUSH
106430: LD_VAR 0 1
106434: ST_TO_ADDR
// bc_level = 1 ;
106435: LD_ADDR_OWVAR 43
106439: PUSH
106440: LD_INT 1
106442: ST_TO_ADDR
// case btype of 1 :
106443: LD_VAR 0 2
106447: PUSH
106448: LD_INT 1
106450: DOUBLE
106451: EQUAL
106452: IFTRUE 106456
106454: GO 106467
106456: POP
// bc_type := b_depot ; 2 :
106457: LD_ADDR_OWVAR 42
106461: PUSH
106462: LD_INT 0
106464: ST_TO_ADDR
106465: GO 107079
106467: LD_INT 2
106469: DOUBLE
106470: EQUAL
106471: IFTRUE 106475
106473: GO 106486
106475: POP
// bc_type := b_warehouse ; 3 :
106476: LD_ADDR_OWVAR 42
106480: PUSH
106481: LD_INT 1
106483: ST_TO_ADDR
106484: GO 107079
106486: LD_INT 3
106488: DOUBLE
106489: EQUAL
106490: IFTRUE 106494
106492: GO 106505
106494: POP
// bc_type := b_lab ; 4 .. 9 :
106495: LD_ADDR_OWVAR 42
106499: PUSH
106500: LD_INT 6
106502: ST_TO_ADDR
106503: GO 107079
106505: LD_INT 4
106507: DOUBLE
106508: GREATEREQUAL
106509: IFFALSE 106517
106511: LD_INT 9
106513: DOUBLE
106514: LESSEQUAL
106515: IFTRUE 106519
106517: GO 106571
106519: POP
// begin bc_type := b_lab_half ;
106520: LD_ADDR_OWVAR 42
106524: PUSH
106525: LD_INT 7
106527: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106528: LD_ADDR_OWVAR 44
106532: PUSH
106533: LD_INT 10
106535: PUSH
106536: LD_INT 11
106538: PUSH
106539: LD_INT 12
106541: PUSH
106542: LD_INT 15
106544: PUSH
106545: LD_INT 14
106547: PUSH
106548: LD_INT 13
106550: PUSH
106551: EMPTY
106552: LIST
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: LIST
106558: PUSH
106559: LD_VAR 0 2
106563: PUSH
106564: LD_INT 3
106566: MINUS
106567: ARRAY
106568: ST_TO_ADDR
// end ; 10 .. 13 :
106569: GO 107079
106571: LD_INT 10
106573: DOUBLE
106574: GREATEREQUAL
106575: IFFALSE 106583
106577: LD_INT 13
106579: DOUBLE
106580: LESSEQUAL
106581: IFTRUE 106585
106583: GO 106662
106585: POP
// begin bc_type := b_lab_full ;
106586: LD_ADDR_OWVAR 42
106590: PUSH
106591: LD_INT 8
106593: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106594: LD_ADDR_OWVAR 44
106598: PUSH
106599: LD_INT 10
106601: PUSH
106602: LD_INT 12
106604: PUSH
106605: LD_INT 14
106607: PUSH
106608: LD_INT 13
106610: PUSH
106611: EMPTY
106612: LIST
106613: LIST
106614: LIST
106615: LIST
106616: PUSH
106617: LD_VAR 0 2
106621: PUSH
106622: LD_INT 9
106624: MINUS
106625: ARRAY
106626: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106627: LD_ADDR_OWVAR 45
106631: PUSH
106632: LD_INT 11
106634: PUSH
106635: LD_INT 15
106637: PUSH
106638: LD_INT 12
106640: PUSH
106641: LD_INT 15
106643: PUSH
106644: EMPTY
106645: LIST
106646: LIST
106647: LIST
106648: LIST
106649: PUSH
106650: LD_VAR 0 2
106654: PUSH
106655: LD_INT 9
106657: MINUS
106658: ARRAY
106659: ST_TO_ADDR
// end ; 14 :
106660: GO 107079
106662: LD_INT 14
106664: DOUBLE
106665: EQUAL
106666: IFTRUE 106670
106668: GO 106681
106670: POP
// bc_type := b_workshop ; 15 :
106671: LD_ADDR_OWVAR 42
106675: PUSH
106676: LD_INT 2
106678: ST_TO_ADDR
106679: GO 107079
106681: LD_INT 15
106683: DOUBLE
106684: EQUAL
106685: IFTRUE 106689
106687: GO 106700
106689: POP
// bc_type := b_factory ; 16 :
106690: LD_ADDR_OWVAR 42
106694: PUSH
106695: LD_INT 3
106697: ST_TO_ADDR
106698: GO 107079
106700: LD_INT 16
106702: DOUBLE
106703: EQUAL
106704: IFTRUE 106708
106706: GO 106719
106708: POP
// bc_type := b_ext_gun ; 17 :
106709: LD_ADDR_OWVAR 42
106713: PUSH
106714: LD_INT 17
106716: ST_TO_ADDR
106717: GO 107079
106719: LD_INT 17
106721: DOUBLE
106722: EQUAL
106723: IFTRUE 106727
106725: GO 106755
106727: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106728: LD_ADDR_OWVAR 42
106732: PUSH
106733: LD_INT 19
106735: PUSH
106736: LD_INT 23
106738: PUSH
106739: LD_INT 19
106741: PUSH
106742: EMPTY
106743: LIST
106744: LIST
106745: LIST
106746: PUSH
106747: LD_VAR 0 1
106751: ARRAY
106752: ST_TO_ADDR
106753: GO 107079
106755: LD_INT 18
106757: DOUBLE
106758: EQUAL
106759: IFTRUE 106763
106761: GO 106774
106763: POP
// bc_type := b_ext_radar ; 19 :
106764: LD_ADDR_OWVAR 42
106768: PUSH
106769: LD_INT 20
106771: ST_TO_ADDR
106772: GO 107079
106774: LD_INT 19
106776: DOUBLE
106777: EQUAL
106778: IFTRUE 106782
106780: GO 106793
106782: POP
// bc_type := b_ext_radio ; 20 :
106783: LD_ADDR_OWVAR 42
106787: PUSH
106788: LD_INT 22
106790: ST_TO_ADDR
106791: GO 107079
106793: LD_INT 20
106795: DOUBLE
106796: EQUAL
106797: IFTRUE 106801
106799: GO 106812
106801: POP
// bc_type := b_ext_siberium ; 21 :
106802: LD_ADDR_OWVAR 42
106806: PUSH
106807: LD_INT 21
106809: ST_TO_ADDR
106810: GO 107079
106812: LD_INT 21
106814: DOUBLE
106815: EQUAL
106816: IFTRUE 106820
106818: GO 106831
106820: POP
// bc_type := b_ext_computer ; 22 :
106821: LD_ADDR_OWVAR 42
106825: PUSH
106826: LD_INT 24
106828: ST_TO_ADDR
106829: GO 107079
106831: LD_INT 22
106833: DOUBLE
106834: EQUAL
106835: IFTRUE 106839
106837: GO 106850
106839: POP
// bc_type := b_ext_track ; 23 :
106840: LD_ADDR_OWVAR 42
106844: PUSH
106845: LD_INT 16
106847: ST_TO_ADDR
106848: GO 107079
106850: LD_INT 23
106852: DOUBLE
106853: EQUAL
106854: IFTRUE 106858
106856: GO 106869
106858: POP
// bc_type := b_ext_laser ; 24 :
106859: LD_ADDR_OWVAR 42
106863: PUSH
106864: LD_INT 25
106866: ST_TO_ADDR
106867: GO 107079
106869: LD_INT 24
106871: DOUBLE
106872: EQUAL
106873: IFTRUE 106877
106875: GO 106888
106877: POP
// bc_type := b_control_tower ; 25 :
106878: LD_ADDR_OWVAR 42
106882: PUSH
106883: LD_INT 36
106885: ST_TO_ADDR
106886: GO 107079
106888: LD_INT 25
106890: DOUBLE
106891: EQUAL
106892: IFTRUE 106896
106894: GO 106907
106896: POP
// bc_type := b_breastwork ; 26 :
106897: LD_ADDR_OWVAR 42
106901: PUSH
106902: LD_INT 31
106904: ST_TO_ADDR
106905: GO 107079
106907: LD_INT 26
106909: DOUBLE
106910: EQUAL
106911: IFTRUE 106915
106913: GO 106926
106915: POP
// bc_type := b_bunker ; 27 :
106916: LD_ADDR_OWVAR 42
106920: PUSH
106921: LD_INT 32
106923: ST_TO_ADDR
106924: GO 107079
106926: LD_INT 27
106928: DOUBLE
106929: EQUAL
106930: IFTRUE 106934
106932: GO 106945
106934: POP
// bc_type := b_turret ; 28 :
106935: LD_ADDR_OWVAR 42
106939: PUSH
106940: LD_INT 33
106942: ST_TO_ADDR
106943: GO 107079
106945: LD_INT 28
106947: DOUBLE
106948: EQUAL
106949: IFTRUE 106953
106951: GO 106964
106953: POP
// bc_type := b_armoury ; 29 :
106954: LD_ADDR_OWVAR 42
106958: PUSH
106959: LD_INT 4
106961: ST_TO_ADDR
106962: GO 107079
106964: LD_INT 29
106966: DOUBLE
106967: EQUAL
106968: IFTRUE 106972
106970: GO 106983
106972: POP
// bc_type := b_barracks ; 30 :
106973: LD_ADDR_OWVAR 42
106977: PUSH
106978: LD_INT 5
106980: ST_TO_ADDR
106981: GO 107079
106983: LD_INT 30
106985: DOUBLE
106986: EQUAL
106987: IFTRUE 106991
106989: GO 107002
106991: POP
// bc_type := b_solar_power ; 31 :
106992: LD_ADDR_OWVAR 42
106996: PUSH
106997: LD_INT 27
106999: ST_TO_ADDR
107000: GO 107079
107002: LD_INT 31
107004: DOUBLE
107005: EQUAL
107006: IFTRUE 107010
107008: GO 107021
107010: POP
// bc_type := b_oil_power ; 32 :
107011: LD_ADDR_OWVAR 42
107015: PUSH
107016: LD_INT 26
107018: ST_TO_ADDR
107019: GO 107079
107021: LD_INT 32
107023: DOUBLE
107024: EQUAL
107025: IFTRUE 107029
107027: GO 107040
107029: POP
// bc_type := b_siberite_power ; 33 :
107030: LD_ADDR_OWVAR 42
107034: PUSH
107035: LD_INT 28
107037: ST_TO_ADDR
107038: GO 107079
107040: LD_INT 33
107042: DOUBLE
107043: EQUAL
107044: IFTRUE 107048
107046: GO 107059
107048: POP
// bc_type := b_oil_mine ; 34 :
107049: LD_ADDR_OWVAR 42
107053: PUSH
107054: LD_INT 29
107056: ST_TO_ADDR
107057: GO 107079
107059: LD_INT 34
107061: DOUBLE
107062: EQUAL
107063: IFTRUE 107067
107065: GO 107078
107067: POP
// bc_type := b_siberite_mine ; end ;
107068: LD_ADDR_OWVAR 42
107072: PUSH
107073: LD_INT 30
107075: ST_TO_ADDR
107076: GO 107079
107078: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107079: LD_ADDR_VAR 0 8
107083: PUSH
107084: LD_VAR 0 5
107088: PPUSH
107089: LD_VAR 0 6
107093: PPUSH
107094: LD_VAR 0 3
107098: PPUSH
107099: CALL_OW 47
107103: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107104: LD_OWVAR 42
107108: PUSH
107109: LD_INT 32
107111: PUSH
107112: LD_INT 33
107114: PUSH
107115: EMPTY
107116: LIST
107117: LIST
107118: IN
107119: IFFALSE 107135
// PlaceWeaponTurret ( b , weapon ) ;
107121: LD_VAR 0 8
107125: PPUSH
107126: LD_VAR 0 4
107130: PPUSH
107131: CALL_OW 431
// end ;
107135: LD_VAR 0 7
107139: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107140: LD_INT 0
107142: PPUSH
107143: PPUSH
107144: PPUSH
107145: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107146: LD_ADDR_VAR 0 4
107150: PUSH
107151: LD_INT 22
107153: PUSH
107154: LD_OWVAR 2
107158: PUSH
107159: EMPTY
107160: LIST
107161: LIST
107162: PUSH
107163: LD_INT 2
107165: PUSH
107166: LD_INT 30
107168: PUSH
107169: LD_INT 0
107171: PUSH
107172: EMPTY
107173: LIST
107174: LIST
107175: PUSH
107176: LD_INT 30
107178: PUSH
107179: LD_INT 1
107181: PUSH
107182: EMPTY
107183: LIST
107184: LIST
107185: PUSH
107186: EMPTY
107187: LIST
107188: LIST
107189: LIST
107190: PUSH
107191: EMPTY
107192: LIST
107193: LIST
107194: PPUSH
107195: CALL_OW 69
107199: ST_TO_ADDR
// if not tmp then
107200: LD_VAR 0 4
107204: NOT
107205: IFFALSE 107209
// exit ;
107207: GO 107268
// for i in tmp do
107209: LD_ADDR_VAR 0 2
107213: PUSH
107214: LD_VAR 0 4
107218: PUSH
107219: FOR_IN
107220: IFFALSE 107266
// for j = 1 to 3 do
107222: LD_ADDR_VAR 0 3
107226: PUSH
107227: DOUBLE
107228: LD_INT 1
107230: DEC
107231: ST_TO_ADDR
107232: LD_INT 3
107234: PUSH
107235: FOR_TO
107236: IFFALSE 107262
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107238: LD_VAR 0 2
107242: PPUSH
107243: CALL_OW 274
107247: PPUSH
107248: LD_VAR 0 3
107252: PPUSH
107253: LD_INT 99999
107255: PPUSH
107256: CALL_OW 277
107260: GO 107235
107262: POP
107263: POP
107264: GO 107219
107266: POP
107267: POP
// end ;
107268: LD_VAR 0 1
107272: RET
// export function hHackSetLevel10 ; var i , j ; begin
107273: LD_INT 0
107275: PPUSH
107276: PPUSH
107277: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107278: LD_ADDR_VAR 0 2
107282: PUSH
107283: LD_INT 21
107285: PUSH
107286: LD_INT 1
107288: PUSH
107289: EMPTY
107290: LIST
107291: LIST
107292: PPUSH
107293: CALL_OW 69
107297: PUSH
107298: FOR_IN
107299: IFFALSE 107351
// if IsSelected ( i ) then
107301: LD_VAR 0 2
107305: PPUSH
107306: CALL_OW 306
107310: IFFALSE 107349
// begin for j := 1 to 4 do
107312: LD_ADDR_VAR 0 3
107316: PUSH
107317: DOUBLE
107318: LD_INT 1
107320: DEC
107321: ST_TO_ADDR
107322: LD_INT 4
107324: PUSH
107325: FOR_TO
107326: IFFALSE 107347
// SetSkill ( i , j , 10 ) ;
107328: LD_VAR 0 2
107332: PPUSH
107333: LD_VAR 0 3
107337: PPUSH
107338: LD_INT 10
107340: PPUSH
107341: CALL_OW 237
107345: GO 107325
107347: POP
107348: POP
// end ;
107349: GO 107298
107351: POP
107352: POP
// end ;
107353: LD_VAR 0 1
107357: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107358: LD_INT 0
107360: PPUSH
107361: PPUSH
107362: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107363: LD_ADDR_VAR 0 2
107367: PUSH
107368: LD_INT 22
107370: PUSH
107371: LD_OWVAR 2
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: PUSH
107380: LD_INT 21
107382: PUSH
107383: LD_INT 1
107385: PUSH
107386: EMPTY
107387: LIST
107388: LIST
107389: PUSH
107390: EMPTY
107391: LIST
107392: LIST
107393: PPUSH
107394: CALL_OW 69
107398: PUSH
107399: FOR_IN
107400: IFFALSE 107441
// begin for j := 1 to 4 do
107402: LD_ADDR_VAR 0 3
107406: PUSH
107407: DOUBLE
107408: LD_INT 1
107410: DEC
107411: ST_TO_ADDR
107412: LD_INT 4
107414: PUSH
107415: FOR_TO
107416: IFFALSE 107437
// SetSkill ( i , j , 10 ) ;
107418: LD_VAR 0 2
107422: PPUSH
107423: LD_VAR 0 3
107427: PPUSH
107428: LD_INT 10
107430: PPUSH
107431: CALL_OW 237
107435: GO 107415
107437: POP
107438: POP
// end ;
107439: GO 107399
107441: POP
107442: POP
// end ;
107443: LD_VAR 0 1
107447: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107448: LD_INT 0
107450: PPUSH
// uc_side := your_side ;
107451: LD_ADDR_OWVAR 20
107455: PUSH
107456: LD_OWVAR 2
107460: ST_TO_ADDR
// uc_nation := nation ;
107461: LD_ADDR_OWVAR 21
107465: PUSH
107466: LD_VAR 0 1
107470: ST_TO_ADDR
// InitHc ;
107471: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107475: LD_INT 0
107477: PPUSH
107478: LD_VAR 0 2
107482: PPUSH
107483: LD_VAR 0 3
107487: PPUSH
107488: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107492: LD_VAR 0 4
107496: PPUSH
107497: LD_VAR 0 5
107501: PPUSH
107502: CALL_OW 428
107506: PUSH
107507: LD_INT 0
107509: EQUAL
107510: IFFALSE 107534
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107512: CALL_OW 44
107516: PPUSH
107517: LD_VAR 0 4
107521: PPUSH
107522: LD_VAR 0 5
107526: PPUSH
107527: LD_INT 1
107529: PPUSH
107530: CALL_OW 48
// end ;
107534: LD_VAR 0 6
107538: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107539: LD_INT 0
107541: PPUSH
107542: PPUSH
// uc_side := your_side ;
107543: LD_ADDR_OWVAR 20
107547: PUSH
107548: LD_OWVAR 2
107552: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107553: LD_VAR 0 1
107557: PUSH
107558: LD_INT 1
107560: PUSH
107561: LD_INT 2
107563: PUSH
107564: LD_INT 3
107566: PUSH
107567: LD_INT 4
107569: PUSH
107570: LD_INT 5
107572: PUSH
107573: EMPTY
107574: LIST
107575: LIST
107576: LIST
107577: LIST
107578: LIST
107579: IN
107580: IFFALSE 107592
// uc_nation := nation_american else
107582: LD_ADDR_OWVAR 21
107586: PUSH
107587: LD_INT 1
107589: ST_TO_ADDR
107590: GO 107635
// if chassis in [ 11 , 12 , 13 , 14 ] then
107592: LD_VAR 0 1
107596: PUSH
107597: LD_INT 11
107599: PUSH
107600: LD_INT 12
107602: PUSH
107603: LD_INT 13
107605: PUSH
107606: LD_INT 14
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: LIST
107613: LIST
107614: IN
107615: IFFALSE 107627
// uc_nation := nation_arabian else
107617: LD_ADDR_OWVAR 21
107621: PUSH
107622: LD_INT 2
107624: ST_TO_ADDR
107625: GO 107635
// uc_nation := nation_russian ;
107627: LD_ADDR_OWVAR 21
107631: PUSH
107632: LD_INT 3
107634: ST_TO_ADDR
// vc_chassis := chassis ;
107635: LD_ADDR_OWVAR 37
107639: PUSH
107640: LD_VAR 0 1
107644: ST_TO_ADDR
// vc_engine := engine ;
107645: LD_ADDR_OWVAR 39
107649: PUSH
107650: LD_VAR 0 2
107654: ST_TO_ADDR
// vc_control := control ;
107655: LD_ADDR_OWVAR 38
107659: PUSH
107660: LD_VAR 0 3
107664: ST_TO_ADDR
// vc_weapon := weapon ;
107665: LD_ADDR_OWVAR 40
107669: PUSH
107670: LD_VAR 0 4
107674: ST_TO_ADDR
// un := CreateVehicle ;
107675: LD_ADDR_VAR 0 8
107679: PUSH
107680: CALL_OW 45
107684: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107685: LD_VAR 0 8
107689: PPUSH
107690: LD_INT 0
107692: PPUSH
107693: LD_INT 5
107695: PPUSH
107696: CALL_OW 12
107700: PPUSH
107701: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107705: LD_VAR 0 8
107709: PPUSH
107710: LD_VAR 0 5
107714: PPUSH
107715: LD_VAR 0 6
107719: PPUSH
107720: LD_INT 1
107722: PPUSH
107723: CALL_OW 48
// end ;
107727: LD_VAR 0 7
107731: RET
// export hInvincible ; every 1 do
107732: GO 107734
107734: DISABLE
// hInvincible := [ ] ;
107735: LD_ADDR_EXP 156
107739: PUSH
107740: EMPTY
107741: ST_TO_ADDR
107742: END
// every 10 do var i ;
107743: GO 107745
107745: DISABLE
107746: LD_INT 0
107748: PPUSH
// begin enable ;
107749: ENABLE
// if not hInvincible then
107750: LD_EXP 156
107754: NOT
107755: IFFALSE 107759
// exit ;
107757: GO 107803
// for i in hInvincible do
107759: LD_ADDR_VAR 0 1
107763: PUSH
107764: LD_EXP 156
107768: PUSH
107769: FOR_IN
107770: IFFALSE 107801
// if GetLives ( i ) < 1000 then
107772: LD_VAR 0 1
107776: PPUSH
107777: CALL_OW 256
107781: PUSH
107782: LD_INT 1000
107784: LESS
107785: IFFALSE 107799
// SetLives ( i , 1000 ) ;
107787: LD_VAR 0 1
107791: PPUSH
107792: LD_INT 1000
107794: PPUSH
107795: CALL_OW 234
107799: GO 107769
107801: POP
107802: POP
// end ;
107803: PPOPN 1
107805: END
// export function hHackInvincible ; var i ; begin
107806: LD_INT 0
107808: PPUSH
107809: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107810: LD_ADDR_VAR 0 2
107814: PUSH
107815: LD_INT 2
107817: PUSH
107818: LD_INT 21
107820: PUSH
107821: LD_INT 1
107823: PUSH
107824: EMPTY
107825: LIST
107826: LIST
107827: PUSH
107828: LD_INT 21
107830: PUSH
107831: LD_INT 2
107833: PUSH
107834: EMPTY
107835: LIST
107836: LIST
107837: PUSH
107838: EMPTY
107839: LIST
107840: LIST
107841: LIST
107842: PPUSH
107843: CALL_OW 69
107847: PUSH
107848: FOR_IN
107849: IFFALSE 107910
// if IsSelected ( i ) then
107851: LD_VAR 0 2
107855: PPUSH
107856: CALL_OW 306
107860: IFFALSE 107908
// begin if i in hInvincible then
107862: LD_VAR 0 2
107866: PUSH
107867: LD_EXP 156
107871: IN
107872: IFFALSE 107892
// hInvincible := hInvincible diff i else
107874: LD_ADDR_EXP 156
107878: PUSH
107879: LD_EXP 156
107883: PUSH
107884: LD_VAR 0 2
107888: DIFF
107889: ST_TO_ADDR
107890: GO 107908
// hInvincible := hInvincible union i ;
107892: LD_ADDR_EXP 156
107896: PUSH
107897: LD_EXP 156
107901: PUSH
107902: LD_VAR 0 2
107906: UNION
107907: ST_TO_ADDR
// end ;
107908: GO 107848
107910: POP
107911: POP
// end ;
107912: LD_VAR 0 1
107916: RET
// export function hHackInvisible ; var i , j ; begin
107917: LD_INT 0
107919: PPUSH
107920: PPUSH
107921: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107922: LD_ADDR_VAR 0 2
107926: PUSH
107927: LD_INT 21
107929: PUSH
107930: LD_INT 1
107932: PUSH
107933: EMPTY
107934: LIST
107935: LIST
107936: PPUSH
107937: CALL_OW 69
107941: PUSH
107942: FOR_IN
107943: IFFALSE 107967
// if IsSelected ( i ) then
107945: LD_VAR 0 2
107949: PPUSH
107950: CALL_OW 306
107954: IFFALSE 107965
// ComForceInvisible ( i ) ;
107956: LD_VAR 0 2
107960: PPUSH
107961: CALL_OW 496
107965: GO 107942
107967: POP
107968: POP
// end ;
107969: LD_VAR 0 1
107973: RET
// export function hHackChangeYourSide ; begin
107974: LD_INT 0
107976: PPUSH
// if your_side = 8 then
107977: LD_OWVAR 2
107981: PUSH
107982: LD_INT 8
107984: EQUAL
107985: IFFALSE 107997
// your_side := 0 else
107987: LD_ADDR_OWVAR 2
107991: PUSH
107992: LD_INT 0
107994: ST_TO_ADDR
107995: GO 108011
// your_side := your_side + 1 ;
107997: LD_ADDR_OWVAR 2
108001: PUSH
108002: LD_OWVAR 2
108006: PUSH
108007: LD_INT 1
108009: PLUS
108010: ST_TO_ADDR
// end ;
108011: LD_VAR 0 1
108015: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108016: LD_INT 0
108018: PPUSH
108019: PPUSH
108020: PPUSH
// for i in all_units do
108021: LD_ADDR_VAR 0 2
108025: PUSH
108026: LD_OWVAR 3
108030: PUSH
108031: FOR_IN
108032: IFFALSE 108110
// if IsSelected ( i ) then
108034: LD_VAR 0 2
108038: PPUSH
108039: CALL_OW 306
108043: IFFALSE 108108
// begin j := GetSide ( i ) ;
108045: LD_ADDR_VAR 0 3
108049: PUSH
108050: LD_VAR 0 2
108054: PPUSH
108055: CALL_OW 255
108059: ST_TO_ADDR
// if j = 8 then
108060: LD_VAR 0 3
108064: PUSH
108065: LD_INT 8
108067: EQUAL
108068: IFFALSE 108080
// j := 0 else
108070: LD_ADDR_VAR 0 3
108074: PUSH
108075: LD_INT 0
108077: ST_TO_ADDR
108078: GO 108094
// j := j + 1 ;
108080: LD_ADDR_VAR 0 3
108084: PUSH
108085: LD_VAR 0 3
108089: PUSH
108090: LD_INT 1
108092: PLUS
108093: ST_TO_ADDR
// SetSide ( i , j ) ;
108094: LD_VAR 0 2
108098: PPUSH
108099: LD_VAR 0 3
108103: PPUSH
108104: CALL_OW 235
// end ;
108108: GO 108031
108110: POP
108111: POP
// end ;
108112: LD_VAR 0 1
108116: RET
// export function hHackFog ; begin
108117: LD_INT 0
108119: PPUSH
// FogOff ( true ) ;
108120: LD_INT 1
108122: PPUSH
108123: CALL_OW 344
// end ;
108127: LD_VAR 0 1
108131: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108132: LD_INT 0
108134: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108135: LD_VAR 0 1
108139: PPUSH
108140: LD_VAR 0 2
108144: PPUSH
108145: LD_VAR 0 3
108149: PPUSH
108150: LD_INT 1
108152: PPUSH
108153: LD_INT 1
108155: PPUSH
108156: CALL_OW 483
// CenterOnXY ( x , y ) ;
108160: LD_VAR 0 2
108164: PPUSH
108165: LD_VAR 0 3
108169: PPUSH
108170: CALL_OW 84
// end ;
108174: LD_VAR 0 4
108178: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108179: LD_INT 0
108181: PPUSH
108182: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108183: LD_VAR 0 1
108187: NOT
108188: PUSH
108189: LD_VAR 0 2
108193: PPUSH
108194: LD_VAR 0 3
108198: PPUSH
108199: CALL_OW 488
108203: NOT
108204: OR
108205: PUSH
108206: LD_VAR 0 1
108210: PPUSH
108211: CALL_OW 266
108215: PUSH
108216: LD_INT 3
108218: NONEQUAL
108219: PUSH
108220: LD_VAR 0 1
108224: PPUSH
108225: CALL_OW 247
108229: PUSH
108230: LD_INT 1
108232: EQUAL
108233: NOT
108234: AND
108235: OR
108236: IFFALSE 108240
// exit ;
108238: GO 108389
// if GetType ( factory ) = unit_human then
108240: LD_VAR 0 1
108244: PPUSH
108245: CALL_OW 247
108249: PUSH
108250: LD_INT 1
108252: EQUAL
108253: IFFALSE 108270
// factory := IsInUnit ( factory ) ;
108255: LD_ADDR_VAR 0 1
108259: PUSH
108260: LD_VAR 0 1
108264: PPUSH
108265: CALL_OW 310
108269: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108270: LD_VAR 0 1
108274: PPUSH
108275: CALL_OW 266
108279: PUSH
108280: LD_INT 3
108282: NONEQUAL
108283: IFFALSE 108287
// exit ;
108285: GO 108389
// if HexInfo ( x , y ) = factory then
108287: LD_VAR 0 2
108291: PPUSH
108292: LD_VAR 0 3
108296: PPUSH
108297: CALL_OW 428
108301: PUSH
108302: LD_VAR 0 1
108306: EQUAL
108307: IFFALSE 108334
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108309: LD_ADDR_EXP 157
108313: PUSH
108314: LD_EXP 157
108318: PPUSH
108319: LD_VAR 0 1
108323: PPUSH
108324: LD_INT 0
108326: PPUSH
108327: CALL_OW 1
108331: ST_TO_ADDR
108332: GO 108385
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108334: LD_ADDR_EXP 157
108338: PUSH
108339: LD_EXP 157
108343: PPUSH
108344: LD_VAR 0 1
108348: PPUSH
108349: LD_VAR 0 1
108353: PPUSH
108354: CALL_OW 255
108358: PUSH
108359: LD_VAR 0 1
108363: PUSH
108364: LD_VAR 0 2
108368: PUSH
108369: LD_VAR 0 3
108373: PUSH
108374: EMPTY
108375: LIST
108376: LIST
108377: LIST
108378: LIST
108379: PPUSH
108380: CALL_OW 1
108384: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108385: CALL 108394 0 0
// end ;
108389: LD_VAR 0 4
108393: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108394: LD_INT 0
108396: PPUSH
108397: PPUSH
108398: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108399: LD_STRING resetFactoryWaypoint();
108401: PPUSH
108402: CALL_OW 559
// if factoryWaypoints then
108406: LD_EXP 157
108410: IFFALSE 108536
// begin list := PrepareArray ( factoryWaypoints ) ;
108412: LD_ADDR_VAR 0 3
108416: PUSH
108417: LD_EXP 157
108421: PPUSH
108422: CALL 51038 0 1
108426: ST_TO_ADDR
// for i := 1 to list do
108427: LD_ADDR_VAR 0 2
108431: PUSH
108432: DOUBLE
108433: LD_INT 1
108435: DEC
108436: ST_TO_ADDR
108437: LD_VAR 0 3
108441: PUSH
108442: FOR_TO
108443: IFFALSE 108534
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108445: LD_STRING setFactoryWaypointXY(
108447: PUSH
108448: LD_VAR 0 3
108452: PUSH
108453: LD_VAR 0 2
108457: ARRAY
108458: PUSH
108459: LD_INT 1
108461: ARRAY
108462: STR
108463: PUSH
108464: LD_STRING ,
108466: STR
108467: PUSH
108468: LD_VAR 0 3
108472: PUSH
108473: LD_VAR 0 2
108477: ARRAY
108478: PUSH
108479: LD_INT 2
108481: ARRAY
108482: STR
108483: PUSH
108484: LD_STRING ,
108486: STR
108487: PUSH
108488: LD_VAR 0 3
108492: PUSH
108493: LD_VAR 0 2
108497: ARRAY
108498: PUSH
108499: LD_INT 3
108501: ARRAY
108502: STR
108503: PUSH
108504: LD_STRING ,
108506: STR
108507: PUSH
108508: LD_VAR 0 3
108512: PUSH
108513: LD_VAR 0 2
108517: ARRAY
108518: PUSH
108519: LD_INT 4
108521: ARRAY
108522: STR
108523: PUSH
108524: LD_STRING )
108526: STR
108527: PPUSH
108528: CALL_OW 559
108532: GO 108442
108534: POP
108535: POP
// end ; end ;
108536: LD_VAR 0 1
108540: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108541: LD_INT 0
108543: PPUSH
// if HexInfo ( x , y ) = warehouse then
108544: LD_VAR 0 2
108548: PPUSH
108549: LD_VAR 0 3
108553: PPUSH
108554: CALL_OW 428
108558: PUSH
108559: LD_VAR 0 1
108563: EQUAL
108564: IFFALSE 108591
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108566: LD_ADDR_EXP 158
108570: PUSH
108571: LD_EXP 158
108575: PPUSH
108576: LD_VAR 0 1
108580: PPUSH
108581: LD_INT 0
108583: PPUSH
108584: CALL_OW 1
108588: ST_TO_ADDR
108589: GO 108642
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108591: LD_ADDR_EXP 158
108595: PUSH
108596: LD_EXP 158
108600: PPUSH
108601: LD_VAR 0 1
108605: PPUSH
108606: LD_VAR 0 1
108610: PPUSH
108611: CALL_OW 255
108615: PUSH
108616: LD_VAR 0 1
108620: PUSH
108621: LD_VAR 0 2
108625: PUSH
108626: LD_VAR 0 3
108630: PUSH
108631: EMPTY
108632: LIST
108633: LIST
108634: LIST
108635: LIST
108636: PPUSH
108637: CALL_OW 1
108641: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108642: CALL 108651 0 0
// end ;
108646: LD_VAR 0 4
108650: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108651: LD_INT 0
108653: PPUSH
108654: PPUSH
108655: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108656: LD_STRING resetWarehouseGatheringPoints();
108658: PPUSH
108659: CALL_OW 559
// if warehouseGatheringPoints then
108663: LD_EXP 158
108667: IFFALSE 108793
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108669: LD_ADDR_VAR 0 3
108673: PUSH
108674: LD_EXP 158
108678: PPUSH
108679: CALL 51038 0 1
108683: ST_TO_ADDR
// for i := 1 to list do
108684: LD_ADDR_VAR 0 2
108688: PUSH
108689: DOUBLE
108690: LD_INT 1
108692: DEC
108693: ST_TO_ADDR
108694: LD_VAR 0 3
108698: PUSH
108699: FOR_TO
108700: IFFALSE 108791
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108702: LD_STRING setWarehouseGatheringPointXY(
108704: PUSH
108705: LD_VAR 0 3
108709: PUSH
108710: LD_VAR 0 2
108714: ARRAY
108715: PUSH
108716: LD_INT 1
108718: ARRAY
108719: STR
108720: PUSH
108721: LD_STRING ,
108723: STR
108724: PUSH
108725: LD_VAR 0 3
108729: PUSH
108730: LD_VAR 0 2
108734: ARRAY
108735: PUSH
108736: LD_INT 2
108738: ARRAY
108739: STR
108740: PUSH
108741: LD_STRING ,
108743: STR
108744: PUSH
108745: LD_VAR 0 3
108749: PUSH
108750: LD_VAR 0 2
108754: ARRAY
108755: PUSH
108756: LD_INT 3
108758: ARRAY
108759: STR
108760: PUSH
108761: LD_STRING ,
108763: STR
108764: PUSH
108765: LD_VAR 0 3
108769: PUSH
108770: LD_VAR 0 2
108774: ARRAY
108775: PUSH
108776: LD_INT 4
108778: ARRAY
108779: STR
108780: PUSH
108781: LD_STRING )
108783: STR
108784: PPUSH
108785: CALL_OW 559
108789: GO 108699
108791: POP
108792: POP
// end ; end ;
108793: LD_VAR 0 1
108797: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108798: LD_EXP 158
108802: IFFALSE 109487
108804: GO 108806
108806: DISABLE
108807: LD_INT 0
108809: PPUSH
108810: PPUSH
108811: PPUSH
108812: PPUSH
108813: PPUSH
108814: PPUSH
108815: PPUSH
108816: PPUSH
108817: PPUSH
// begin enable ;
108818: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108819: LD_ADDR_VAR 0 3
108823: PUSH
108824: LD_EXP 158
108828: PPUSH
108829: CALL 51038 0 1
108833: ST_TO_ADDR
// if not list then
108834: LD_VAR 0 3
108838: NOT
108839: IFFALSE 108843
// exit ;
108841: GO 109487
// for i := 1 to list do
108843: LD_ADDR_VAR 0 1
108847: PUSH
108848: DOUBLE
108849: LD_INT 1
108851: DEC
108852: ST_TO_ADDR
108853: LD_VAR 0 3
108857: PUSH
108858: FOR_TO
108859: IFFALSE 109485
// begin depot := list [ i ] [ 2 ] ;
108861: LD_ADDR_VAR 0 8
108865: PUSH
108866: LD_VAR 0 3
108870: PUSH
108871: LD_VAR 0 1
108875: ARRAY
108876: PUSH
108877: LD_INT 2
108879: ARRAY
108880: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108881: LD_ADDR_VAR 0 5
108885: PUSH
108886: LD_VAR 0 3
108890: PUSH
108891: LD_VAR 0 1
108895: ARRAY
108896: PUSH
108897: LD_INT 1
108899: ARRAY
108900: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108901: LD_VAR 0 8
108905: PPUSH
108906: CALL_OW 301
108910: PUSH
108911: LD_VAR 0 5
108915: PUSH
108916: LD_VAR 0 8
108920: PPUSH
108921: CALL_OW 255
108925: NONEQUAL
108926: OR
108927: IFFALSE 108956
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108929: LD_ADDR_EXP 158
108933: PUSH
108934: LD_EXP 158
108938: PPUSH
108939: LD_VAR 0 8
108943: PPUSH
108944: LD_INT 0
108946: PPUSH
108947: CALL_OW 1
108951: ST_TO_ADDR
// exit ;
108952: POP
108953: POP
108954: GO 109487
// end ; x := list [ i ] [ 3 ] ;
108956: LD_ADDR_VAR 0 6
108960: PUSH
108961: LD_VAR 0 3
108965: PUSH
108966: LD_VAR 0 1
108970: ARRAY
108971: PUSH
108972: LD_INT 3
108974: ARRAY
108975: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108976: LD_ADDR_VAR 0 7
108980: PUSH
108981: LD_VAR 0 3
108985: PUSH
108986: LD_VAR 0 1
108990: ARRAY
108991: PUSH
108992: LD_INT 4
108994: ARRAY
108995: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108996: LD_ADDR_VAR 0 9
109000: PUSH
109001: LD_VAR 0 6
109005: PPUSH
109006: LD_VAR 0 7
109010: PPUSH
109011: LD_INT 16
109013: PPUSH
109014: CALL 49626 0 3
109018: ST_TO_ADDR
// if not cratesNearbyPoint then
109019: LD_VAR 0 9
109023: NOT
109024: IFFALSE 109030
// exit ;
109026: POP
109027: POP
109028: GO 109487
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109030: LD_ADDR_VAR 0 4
109034: PUSH
109035: LD_INT 22
109037: PUSH
109038: LD_VAR 0 5
109042: PUSH
109043: EMPTY
109044: LIST
109045: LIST
109046: PUSH
109047: LD_INT 3
109049: PUSH
109050: LD_INT 60
109052: PUSH
109053: EMPTY
109054: LIST
109055: PUSH
109056: EMPTY
109057: LIST
109058: LIST
109059: PUSH
109060: LD_INT 91
109062: PUSH
109063: LD_VAR 0 8
109067: PUSH
109068: LD_INT 6
109070: PUSH
109071: EMPTY
109072: LIST
109073: LIST
109074: LIST
109075: PUSH
109076: LD_INT 2
109078: PUSH
109079: LD_INT 25
109081: PUSH
109082: LD_INT 2
109084: PUSH
109085: EMPTY
109086: LIST
109087: LIST
109088: PUSH
109089: LD_INT 25
109091: PUSH
109092: LD_INT 16
109094: PUSH
109095: EMPTY
109096: LIST
109097: LIST
109098: PUSH
109099: EMPTY
109100: LIST
109101: LIST
109102: LIST
109103: PUSH
109104: EMPTY
109105: LIST
109106: LIST
109107: LIST
109108: LIST
109109: PPUSH
109110: CALL_OW 69
109114: PUSH
109115: LD_VAR 0 8
109119: PPUSH
109120: CALL_OW 313
109124: PPUSH
109125: LD_INT 3
109127: PUSH
109128: LD_INT 60
109130: PUSH
109131: EMPTY
109132: LIST
109133: PUSH
109134: EMPTY
109135: LIST
109136: LIST
109137: PUSH
109138: LD_INT 2
109140: PUSH
109141: LD_INT 25
109143: PUSH
109144: LD_INT 2
109146: PUSH
109147: EMPTY
109148: LIST
109149: LIST
109150: PUSH
109151: LD_INT 25
109153: PUSH
109154: LD_INT 16
109156: PUSH
109157: EMPTY
109158: LIST
109159: LIST
109160: PUSH
109161: EMPTY
109162: LIST
109163: LIST
109164: LIST
109165: PUSH
109166: EMPTY
109167: LIST
109168: LIST
109169: PPUSH
109170: CALL_OW 72
109174: UNION
109175: ST_TO_ADDR
// if tmp then
109176: LD_VAR 0 4
109180: IFFALSE 109260
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109182: LD_ADDR_VAR 0 4
109186: PUSH
109187: LD_VAR 0 4
109191: PPUSH
109192: LD_INT 3
109194: PPUSH
109195: CALL 47595 0 2
109199: ST_TO_ADDR
// for j in tmp do
109200: LD_ADDR_VAR 0 2
109204: PUSH
109205: LD_VAR 0 4
109209: PUSH
109210: FOR_IN
109211: IFFALSE 109254
// begin if IsInUnit ( j ) then
109213: LD_VAR 0 2
109217: PPUSH
109218: CALL_OW 310
109222: IFFALSE 109233
// ComExit ( j ) ;
109224: LD_VAR 0 2
109228: PPUSH
109229: CALL 47678 0 1
// AddComCollect ( j , x , y ) ;
109233: LD_VAR 0 2
109237: PPUSH
109238: LD_VAR 0 6
109242: PPUSH
109243: LD_VAR 0 7
109247: PPUSH
109248: CALL_OW 177
// end ;
109252: GO 109210
109254: POP
109255: POP
// exit ;
109256: POP
109257: POP
109258: GO 109487
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109260: LD_ADDR_VAR 0 4
109264: PUSH
109265: LD_INT 22
109267: PUSH
109268: LD_VAR 0 5
109272: PUSH
109273: EMPTY
109274: LIST
109275: LIST
109276: PUSH
109277: LD_INT 91
109279: PUSH
109280: LD_VAR 0 8
109284: PUSH
109285: LD_INT 8
109287: PUSH
109288: EMPTY
109289: LIST
109290: LIST
109291: LIST
109292: PUSH
109293: LD_INT 2
109295: PUSH
109296: LD_INT 34
109298: PUSH
109299: LD_INT 12
109301: PUSH
109302: EMPTY
109303: LIST
109304: LIST
109305: PUSH
109306: LD_INT 34
109308: PUSH
109309: LD_INT 51
109311: PUSH
109312: EMPTY
109313: LIST
109314: LIST
109315: PUSH
109316: LD_INT 34
109318: PUSH
109319: LD_INT 32
109321: PUSH
109322: EMPTY
109323: LIST
109324: LIST
109325: PUSH
109326: LD_INT 34
109328: PUSH
109329: LD_INT 89
109331: PUSH
109332: EMPTY
109333: LIST
109334: LIST
109335: PUSH
109336: EMPTY
109337: LIST
109338: LIST
109339: LIST
109340: LIST
109341: LIST
109342: PUSH
109343: EMPTY
109344: LIST
109345: LIST
109346: LIST
109347: PPUSH
109348: CALL_OW 69
109352: ST_TO_ADDR
// if tmp then
109353: LD_VAR 0 4
109357: IFFALSE 109483
// begin for j in tmp do
109359: LD_ADDR_VAR 0 2
109363: PUSH
109364: LD_VAR 0 4
109368: PUSH
109369: FOR_IN
109370: IFFALSE 109481
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109372: LD_VAR 0 2
109376: PPUSH
109377: CALL_OW 262
109381: PUSH
109382: LD_INT 3
109384: EQUAL
109385: PUSH
109386: LD_VAR 0 2
109390: PPUSH
109391: CALL_OW 261
109395: PUSH
109396: LD_INT 20
109398: GREATER
109399: OR
109400: PUSH
109401: LD_VAR 0 2
109405: PPUSH
109406: CALL_OW 314
109410: NOT
109411: AND
109412: PUSH
109413: LD_VAR 0 2
109417: PPUSH
109418: CALL_OW 263
109422: PUSH
109423: LD_INT 1
109425: NONEQUAL
109426: PUSH
109427: LD_VAR 0 2
109431: PPUSH
109432: CALL_OW 311
109436: OR
109437: AND
109438: IFFALSE 109479
// begin ComCollect ( j , x , y ) ;
109440: LD_VAR 0 2
109444: PPUSH
109445: LD_VAR 0 6
109449: PPUSH
109450: LD_VAR 0 7
109454: PPUSH
109455: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109459: LD_VAR 0 2
109463: PPUSH
109464: LD_VAR 0 8
109468: PPUSH
109469: CALL_OW 172
// exit ;
109473: POP
109474: POP
109475: POP
109476: POP
109477: GO 109487
// end ;
109479: GO 109369
109481: POP
109482: POP
// end ; end ;
109483: GO 108858
109485: POP
109486: POP
// end ;
109487: PPOPN 9
109489: END
