// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 350 0 0
// InitMultiplayer ;
  20: CALL 611 0 0
// InitMacro ;
  24: CALL 51272 0 0
// if debug then
  28: LD_EXP 1
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: CALL 44008 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: CALL 1893 0 1
  79: PPUSH
  80: CALL 5848 0 1
// Multiplayer_Start ;
  84: CALL 3757 0 0
// MC_Start ( ) ;
  88: CALL 53444 0 0
// Multiplayer_End ;
  92: CALL 3881 0 0
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: CALL 75182 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: LD_OWVAR 67
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: CALL 75182 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_OWVAR 67
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: CALL 75182 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: CALL 75182 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: LD_OWVAR 67
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: CALL 75182 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: LD_ADDR_EXP 67
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: LD_ADDR_EXP 68
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_EXP 38
 330: PUSH
 331: LD_VAR 0 2
 335: ARRAY
 336: PPUSH
 337: CALL 75608 0 2
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: LD_ADDR_EXP 1
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: LD_ADDR_EXP 4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: LD_ADDR_EXP 5
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: LD_EXP 2
 489: PUSH
 490: LD_OWVAR 48
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: CALL 4582 0 0
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: LD_EXP 1
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: LD_ADDR_VAR 0 2
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: CALL_OW 44
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: LD_ADDR_EXP 18
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: LD_OWVAR 4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: LD_OWVAR 7
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: LD_ADDR_EXP 6
 646: PUSH
 647: LD_OWVAR 6
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: LD_ADDR_EXP 7
 656: PUSH
 657: LD_OWVAR 17
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: LD_ADDR_EXP 8
 666: PUSH
 667: LD_OWVAR 15
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: LD_ADDR_EXP 9
 676: PUSH
 677: LD_OWVAR 16
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: LD_ADDR_EXP 10
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: LD_OWVAR 12
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: LD_ADDR_EXP 10
 706: PUSH
 707: LD_EXP 10
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: LD_EXP 10
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: CALL 14988 0 3
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: LD_ADDR_VAR 0 2
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_EXP 18
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: LD_ADDR_EXP 17
 772: PUSH
 773: LD_EXP 17
 777: PPUSH
 778: LD_EXP 17
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 426
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: CALL_OW 2
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: LD_ADDR_EXP 6
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: LD_ADDR_EXP 7
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: LD_ADDR_EXP 8
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: LD_ADDR_EXP 10
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: LD_ADDR_EXP 17
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: LD_ADDR_EXP 11
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: LD_ADDR_EXP 25
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: LD_ADDR_EXP 15
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: LD_ADDR_EXP 13
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: LD_ADDR_EXP 16
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: LD_ADDR_EXP 24
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: LD_ADDR_EXP 27
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: LD_ADDR_EXP 26
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: LD_ADDR_EXP 12
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: LD_VAR 0 2
1232: PPUSH
1233: CALL_OW 530
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: LD_ADDR_EXP 11
1243: PUSH
1244: LD_EXP 11
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: CALL_OW 1
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: LD_ADDR_EXP 9
1266: PUSH
1267: LD_EXP 9
1271: PPUSH
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 1
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_EXP 7
1294: PPUSH
1295: LD_VAR 0 2
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: CALL_OW 1
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_EXP 10
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: LD_VAR 0 2
1330: PUSH
1331: LD_EXP 10
1335: PUSH
1336: LD_VAR 0 3
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: LD_ADDR_VAR 0 5
1348: PUSH
1349: LD_EXP 10
1353: PUSH
1354: LD_VAR 0 3
1358: ARRAY
1359: PUSH
1360: LD_VAR 0 2
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: LD_ADDR_EXP 10
1370: PUSH
1371: LD_EXP 10
1375: PPUSH
1376: LD_VAR 0 3
1380: PPUSH
1381: LD_VAR 0 5
1385: PPUSH
1386: CALL_OW 1
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: LD_EXP 9
1399: PUSH
1400: LD_VAR 0 2
1404: ARRAY
1405: PUSH
1406: LD_EXP 9
1410: PUSH
1411: LD_VAR 0 2
1415: ARRAY
1416: PUSH
1417: LD_EXP 13
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: LD_ADDR_EXP 9
1430: PUSH
1431: LD_EXP 9
1435: PPUSH
1436: LD_VAR 0 2
1440: PPUSH
1441: LD_EXP 13
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: LD_EXP 13
1453: PPUSH
1454: CALL_OW 12
1458: ARRAY
1459: PPUSH
1460: CALL_OW 1
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: LD_EXP 9
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: PUSH
1477: LD_EXP 7
1481: PUSH
1482: LD_VAR 0 2
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: LD_EXP 11
1494: PUSH
1495: LD_VAR 0 2
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: LD_ADDR_EXP 14
1508: PUSH
1509: LD_EXP 14
1513: PPUSH
1514: LD_VAR 0 2
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: CALL_OW 1
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: LD_EXP 7
1531: PUSH
1532: LD_VAR 0 2
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: LD_ADDR_EXP 26
1543: PUSH
1544: LD_EXP 26
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_EXP 10
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: LD_VAR 0 2
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 3
1597: ARRAY
1598: PPUSH
1599: LD_VAR 0 2
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: CALL_OW 343
// for x = 1 to j - 1 do
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: LD_VAR 0 3
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: LD_VAR 0 2
1638: PUSH
1639: LD_VAR 0 3
1643: ARRAY
1644: PPUSH
1645: LD_VAR 0 2
1649: PUSH
1650: LD_VAR 0 4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 80
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_EXP 17
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: LD_ADDR_EXP 20
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: LD_ADDR_EXP 21
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: LD_ADDR_EXP 22
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_EXP 17
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: LD_ADDR_EXP 23
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: LD_EXP 17
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: LD_VAR 0 1
1901: PUSH
1902: LD_EXP 7
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: LD_ADDR_VAR 0 2
1914: PUSH
1915: LD_VAR 0 1
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: LD_ADDR_VAR 0 3
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: LD_EXP 7
1942: PUSH
1943: LD_VAR 0 3
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: LD_VAR 0 3
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_VAR 0 1
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: LD_ADDR_VAR 0 3
2095: PUSH
2096: CALL_OW 44
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: LD_VAR 0 2
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: CALL_OW 44
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: LD_VAR 0 2
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: CALL_OW 44
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: LD_EXP 7
2317: PUSH
2318: LD_VAR 0 2
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: LD_EXP 16
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 2
2343: PPUSH
2344: LD_EXP 7
2348: PUSH
2349: LD_VAR 0 2
2353: ARRAY
2354: PPUSH
2355: CALL 1974 0 2
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: LD_ADDR_EXP 24
2364: PUSH
2365: LD_EXP 24
2369: PPUSH
2370: LD_EXP 24
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: CALL_OW 2
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: LD_VAR 0 5
2393: PPUSH
2394: LD_EXP 12
2398: PUSH
2399: LD_EXP 7
2403: PUSH
2404: LD_VAR 0 2
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 49
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_VAR 0 2
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: LD_EXP 9
2443: PUSH
2444: LD_VAR 0 2
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: LD_EXP 20
2468: PPUSH
2469: CALL_OW 380
// if multiplayer then
2473: LD_OWVAR 4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: LD_OWVAR 19
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: LD_VAR 0 2
2512: PPUSH
2513: CALL_OW 525
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: LD_VAR 0 2
2527: PPUSH
2528: CALL_OW 526
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: CALL_OW 12
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: LD_VAR 0 5
2581: PPUSH
2582: LD_EXP 12
2586: PUSH
2587: LD_EXP 7
2591: PUSH
2592: LD_VAR 0 2
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: LD_ADDR_EXP 24
2614: PUSH
2615: LD_EXP 24
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: LD_VAR 0 5
2629: PPUSH
2630: CALL_OW 1
2634: ST_TO_ADDR
// end ; InitHc ;
2635: CALL_OW 19
// InitUc ;
2639: CALL_OW 18
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: LD_EXP 9
2662: PUSH
2663: LD_VAR 0 2
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: LD_ADDR_VAR 0 3
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: LD_EXP 19
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: LD_EXP 19
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_EXP 20
2773: PPUSH
2774: CALL_OW 380
// un := CreateHuman ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: CALL_OW 44
2787: ST_TO_ADDR
// if j > copy then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_VAR 0 8
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: LD_ADDR_VAR 0 8
2804: PUSH
2805: LD_VAR 0 8
2809: PPUSH
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 1
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: LD_VAR 0 8
2831: PUSH
2832: LD_VAR 0 3
2836: ARRAY
2837: PPUSH
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: LD_VAR 0 5
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: LD_VAR 0 8
2859: PUSH
2860: LD_VAR 0 3
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: CALL_OW 260
2873: PPUSH
2874: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: LD_VAR 0 5
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 8
2890: PUSH
2891: LD_VAR 0 3
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: CALL_OW 260
2904: PPUSH
2905: CALL_OW 239
// end ; if multi_pos_area then
2909: LD_EXP 12
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: LD_VAR 0 5
2919: PPUSH
2920: CALL_OW 257
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_VAR 0 3
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_VAR 0 3
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: CALL 14866 0 5
// veh := CreateVehicle ;
2995: LD_ADDR_VAR 0 6
2999: PUSH
3000: CALL_OW 45
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_EXP 12
3014: PUSH
3015: LD_EXP 7
3019: PUSH
3020: LD_VAR 0 2
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3038: LD_VAR 0 5
3042: PPUSH
3043: LD_VAR 0 6
3047: PPUSH
3048: CALL_OW 52
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_EXP 12
3063: PUSH
3064: LD_EXP 7
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 49
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: LD_ADDR_VAR 0 3
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: CALL_OW 12
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_VAR 0 3
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: CALL 14866 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: CALL_OW 45
3166: PPUSH
3167: LD_EXP 12
3171: PUSH
3172: LD_EXP 7
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: CALL_OW 49
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: LD_EXP 23
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: LD_ADDR_VAR 0 1
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: LD_EXP 7
3251: PUSH
3252: LD_VAR 0 2
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: LD_ADDR_VAR 0 5
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: LD_EXP 23
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: LD_VAR 0 2
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: LD_EXP 9
3295: PUSH
3296: LD_VAR 0 2
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3321: LD_ADDR_VAR 0 5
3325: PUSH
3326: LD_VAR 0 5
3330: PUSH
3331: CALL_OW 45
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: LD_VAR 0 5
3365: PUSH
3366: CALL_OW 45
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: LD_VAR 0 5
3400: PUSH
3401: CALL_OW 45
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_VAR 0 5
3435: PUSH
3436: CALL_OW 45
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: LD_EXP 23
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: LD_VAR 0 2
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: LD_EXP 9
3471: PUSH
3472: LD_VAR 0 2
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3497: LD_ADDR_VAR 0 5
3501: PUSH
3502: LD_VAR 0 5
3506: PUSH
3507: CALL_OW 45
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3532: LD_ADDR_VAR 0 5
3536: PUSH
3537: LD_VAR 0 5
3541: PUSH
3542: CALL_OW 45
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3567: LD_ADDR_VAR 0 5
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: CALL_OW 45
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_VAR 0 5
3611: PUSH
3612: CALL_OW 45
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3637: LD_ADDR_VAR 0 5
3641: PUSH
3642: LD_VAR 0 5
3646: PUSH
3647: CALL_OW 45
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: CALL_OW 45
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3707: LD_ADDR_VAR 0 5
3711: PUSH
3712: LD_VAR 0 5
3716: PUSH
3717: CALL_OW 45
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: LD_ADDR_VAR 0 1
3727: PUSH
3728: LD_VAR 0 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_VAR 0 5
3742: PPUSH
3743: CALL_OW 2
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: CALL 2286 0 0
// Multiplayer_InitPointSystem ( ) ;
3764: CALL 4681 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: CALL 4857 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: CALL 4857 0 1
// Multiplayer_SpawnArtifact ;
3811: CALL 5297 0 0
// if multi_support then
3815: LD_EXP 23
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: LD_ADDR_EXP 27
3825: PUSH
3826: CALL 3208 0 0
3830: ST_TO_ADDR
// game := true ;
3831: LD_ADDR_EXP 2
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: LD_EXP 7
3843: PUSH
3844: LD_OWVAR 2
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: LD_OWVAR 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: CALL_OW 69
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: CALL_OW 87
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: LD_ADDR_VAR 0 5
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: LD_OWVAR 1
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: LD_EXP 28
3916: NOT
3917: AND
3918: PUSH
3919: LD_EXP 23
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: LD_ADDR_EXP 28
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: LD_ADDR_VAR 0 2
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: LD_EXP 7
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PUSH
3965: LD_EXP 25
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: LD_EXP 27
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: LD_EXP 27
4000: PUSH
4001: LD_VAR 0 2
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: LD_ADDR_VAR 0 3
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 3
4032: ARRAY
4033: PPUSH
4034: LD_EXP 12
4038: PUSH
4039: LD_EXP 7
4043: PUSH
4044: LD_VAR 0 2
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 3
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: LD_ADDR_EXP 27
4088: PUSH
4089: LD_EXP 27
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 1
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: LD_OWVAR 1
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: LD_OWVAR 1
4136: LESS
4137: PUSH
4138: LD_EXP 28
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: LD_EXP 23
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: LD_ADDR_EXP 28
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: LD_ADDR_VAR 0 2
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: LD_EXP 7
4187: PUSH
4188: LD_VAR 0 2
4192: ARRAY
4193: PUSH
4194: LD_EXP 25
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: LD_EXP 27
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_EXP 27
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: LD_ADDR_VAR 0 3
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: LD_VAR 0 4
4256: PUSH
4257: LD_VAR 0 3
4261: ARRAY
4262: PPUSH
4263: LD_EXP 12
4267: PUSH
4268: LD_EXP 7
4272: PUSH
4273: LD_VAR 0 2
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: CALL_OW 3
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: LD_ADDR_EXP 27
4317: PUSH
4318: LD_EXP 27
4322: PPUSH
4323: LD_VAR 0 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PPUSH
4333: CALL_OW 1
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: LD_EXP 16
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: LD_ADDR_VAR 0 2
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 69
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_VAR 0 2
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: LD_ADDR_EXP 25
4404: PUSH
4405: LD_EXP 25
4409: PPUSH
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: CALL_OW 1
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: CALL 4927 0 1
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: LD_EXP 25
4440: PPUSH
4441: CALL 11953 0 1
4445: PUSH
4446: LD_EXP 7
4450: PPUSH
4451: CALL 11953 0 1
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: LD_EXP 3
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: LD_EXP 2
4485: AND
4486: PUSH
4487: LD_EXP 24
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: LD_ADDR_EXP 2
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: LD_ADDR_VAR 0 2
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: LD_EXP 7
4523: PUSH
4524: LD_VAR 0 2
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_EXP 29
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: CALL_OW 506
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: LD_EXP 25
4559: PUSH
4560: LD_OWVAR 2
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: CALL_OW 107
4571: GO 4577
// YouWinInMultiplayer ;
4573: CALL_OW 106
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: LD_ADDR_VAR 0 1
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: LD_OWVAR 1
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: LD_EXP 7
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: LD_ADDR_VAR 0 1
4635: PUSH
4636: LD_VAR 0 1
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_VAR 0 2
4653: PUSH
4654: LD_EXP 29
4658: PUSH
4659: LD_VAR 0 2
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: LD_ADDR_EXP 29
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: LD_ADDR_EXP 30
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: LD_EXP 29
4743: NOT
4744: PUSH
4745: LD_VAR 0 1
4749: NOT
4750: OR
4751: PUSH
4752: LD_VAR 0 1
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: LD_ADDR_EXP 29
4769: PUSH
4770: LD_EXP 29
4774: PPUSH
4775: LD_VAR 0 1
4779: PPUSH
4780: LD_EXP 29
4784: PUSH
4785: LD_VAR 0 1
4789: ARRAY
4790: PUSH
4791: LD_VAR 0 2
4795: PLUS
4796: PPUSH
4797: CALL_OW 1
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: LD_EXP 29
4814: NOT
4815: PUSH
4816: LD_VAR 0 1
4820: NOT
4821: OR
4822: PUSH
4823: LD_VAR 0 1
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: LD_EXP 29
4845: PUSH
4846: LD_VAR 0 1
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: LD_ADDR_EXP 30
4864: PUSH
4865: LD_EXP 30
4869: PPUSH
4870: LD_EXP 30
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: LD_VAR 0 1
4883: PPUSH
4884: CALL_OW 2
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: LD_VAR 0 1
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: LD_EXP 30
4915: PUSH
4916: LD_VAR 0 1
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: LD_ADDR_VAR 0 3
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: LD_ADDR_VAR 0 4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: LD_VAR 0 4
4961: PUSH
4962: LD_VAR 0 1
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: LD_EXP 7
4975: PUSH
4976: LD_VAR 0 4
4980: ARRAY
4981: PUSH
4982: LD_EXP 25
4986: PUSH
4987: LD_VAR 0 4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_VAR 0 4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: LD_VAR 0 3
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: LD_ADDR_VAR 0 4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_VAR 0 1
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL_OW 69
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: LD_VAR 0 4
5074: PPUSH
5075: LD_VAR 0 3
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: CALL_OW 235
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: LD_ADDR_VAR 0 5
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: LD_VAR 0 1
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: LD_VAR 0 4
5173: PPUSH
5174: LD_VAR 0 3
5178: PUSH
5179: LD_VAR 0 5
5183: ARRAY
5184: PPUSH
5185: CALL_OW 235
// if IsDrivenBy ( i ) then
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 311
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: LD_VAR 0 3
5214: PUSH
5215: LD_VAR 0 5
5219: ARRAY
5220: PPUSH
5221: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 310
5234: PPUSH
5235: CALL_OW 247
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: LD_VAR 0 4
5249: PPUSH
5250: CALL_OW 122
// j := j + 1 ;
5254: LD_ADDR_VAR 0 5
5258: PUSH
5259: LD_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: LD_VAR 0 5
5272: PUSH
5273: LD_VAR 0 3
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: LD_ADDR_VAR 0 5
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PPUSH
5366: CALL_OW 12
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: LD_VAR 0 3
5381: PUSH
5382: LD_VAR 0 2
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: LD_VAR 0 3
5396: PUSH
5397: LD_VAR 0 2
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 58
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: LD_VAR 0 1
5426: NOT
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: CALL 4894 0 1
5453: PPUSH
5454: CALL 4736 0 2
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: LD_VAR 0 1
5470: NOT
5471: PUSH
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: CALL 4894 0 1
5497: PPUSH
5498: CALL 4736 0 2
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: LD_VAR 0 1
5514: NOT
5515: PUSH
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: LD_VAR 0 2
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL 4894 0 1
5567: PPUSH
5568: CALL 4736 0 2
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: LD_VAR 0 1
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: LD_VAR 0 2
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: LD_ADDR_VAR 0 8
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: CALL 4894 0 1
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: LD_ADDR_VAR 0 8
5620: PUSH
5621: LD_VAR 0 2
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: LD_ADDR_VAR 0 6
5630: PUSH
5631: LD_VAR 0 1
5635: PPUSH
5636: CALL_OW 503
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: LD_VAR 0 6
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: LD_ADDR_VAR 0 4
5656: PUSH
5657: LD_VAR 0 6
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: LD_ADDR_VAR 0 7
5666: PUSH
5667: LD_OWVAR 3
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: DIFF
5694: PPUSH
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 74
5704: ST_TO_ADDR
// if nearest_unit then
5705: LD_VAR 0 7
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_VAR 0 7
5720: PPUSH
5721: CALL_OW 255
5725: ST_TO_ADDR
// if not side and not side2 then
5726: LD_VAR 0 4
5730: NOT
5731: PUSH
5732: LD_VAR 0 5
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 5
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: LD_VAR 0 4
5758: PPUSH
5759: LD_VAR 0 8
5763: PPUSH
5764: CALL 4736 0 2
5768: GO 5818
// begin if side then
5770: LD_VAR 0 4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: LD_VAR 0 4
5780: PPUSH
5781: LD_VAR 0 8
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: CALL 4736 0 2
// if side2 then
5794: LD_VAR 0 5
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: LD_VAR 0 5
5804: PPUSH
5805: LD_VAR 0 8
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: CALL 4736 0 2
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 4894 0 1
5838: PPUSH
5839: CALL 4736 0 2
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: LD_ADDR_VAR 0 9
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: CALL_OW 69
5878: ST_TO_ADDR
// side_bot := side ;
5879: LD_ADDR_EXP 3
5883: PUSH
5884: LD_VAR 0 1
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: LD_VAR 0 9
5893: PUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_VAR 0 9
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: LD_VAR 0 3
5922: PPUSH
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 235
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: LD_ADDR_VAR 0 10
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 10
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: LD_VAR 0 3
6012: PPUSH
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 322
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: LD_ADDR_VAR 0 8
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_OWVAR 67
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: CALL_OW 169
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: CALL_OW 67
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: LD_VAR 0 1
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: LD_ADDR_EXP 33
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: LD_VAR 0 8
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: CALL 18310 0 6
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: LD_ADDR_EXP 34
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: LD_VAR 0 8
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL 18310 0 6
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: LD_ADDR_EXP 31
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: LD_VAR 0 8
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL 18310 0 6
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: LD_ADDR_EXP 32
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: LD_VAR 0 8
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL 18310 0 6
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: LD_ADDR_EXP 35
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: LD_VAR 0 8
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: CALL 18310 0 6
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: LD_ADDR_EXP 43
6377: PUSH
6378: LD_EXP 33
6382: PUSH
6383: LD_EXP 31
6387: PUSH
6388: LD_EXP 35
6392: PUSH
6393: LD_EXP 32
6397: PUSH
6398: LD_EXP 34
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: LD_ADDR_VAR 0 5
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: LD_VAR 0 3
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: LD_VAR 0 8
6511: PPUSH
6512: CALL_OW 380
// un := CreateVehicle ;
6516: LD_ADDR_VAR 0 6
6520: PUSH
6521: CALL_OW 45
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: PPUSH
6542: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: LD_VAR 0 5
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: CALL_OW 50
// un2 := CreateHuman ;
6579: LD_ADDR_VAR 0 7
6583: PUSH
6584: CALL_OW 44
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: LD_VAR 0 7
6593: PPUSH
6594: LD_VAR 0 6
6598: PPUSH
6599: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: LD_ADDR_EXP 43
6607: PUSH
6608: LD_EXP 43
6612: PPUSH
6613: LD_VAR 0 3
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: LD_EXP 43
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: LD_VAR 0 6
6657: PPUSH
6658: CALL 14988 0 3
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: LD_ADDR_EXP 43
6667: PUSH
6668: LD_EXP 43
6672: PPUSH
6673: LD_VAR 0 3
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: LD_EXP 43
6690: PUSH
6691: LD_VAR 0 3
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: LD_VAR 0 7
6717: PPUSH
6718: CALL 14988 0 3
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: LD_EXP 3
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: LD_VAR 0 3
6777: PPUSH
6778: CALL_OW 274
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: LD_ADDR_VAR 0 4
6790: PUSH
6791: LD_VAR 0 3
6795: PPUSH
6796: CALL_OW 254
6800: ST_TO_ADDR
// if d < 3 then
6801: LD_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: LD_ADDR_VAR 0 4
6815: PUSH
6816: LD_VAR 0 4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: LD_ADDR_VAR 0 4
6831: PUSH
6832: LD_VAR 0 4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: LD_VAR 0 8
6851: PPUSH
6852: CALL_OW 380
// un := CreateHuman ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: CALL_OW 44
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: LD_VAR 0 6
6870: PPUSH
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6880: LD_VAR 0 6
6884: PPUSH
6885: LD_VAR 0 3
6889: PPUSH
6890: CALL_OW 52
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: LD_ADDR_EXP 36
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_VAR 0 8
6915: PPUSH
6916: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: LD_ADDR_EXP 36
6940: PUSH
6941: LD_EXP 36
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: CALL_OW 44
6953: PPUSH
6954: CALL_OW 1
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: LD_VAR 0 8
6969: PPUSH
6970: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: LD_ADDR_EXP 36
6994: PUSH
6995: LD_EXP 36
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: CALL_OW 44
7007: PPUSH
7008: CALL_OW 1
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: LD_VAR 0 8
7023: PPUSH
7024: CALL_OW 380
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: LD_ADDR_EXP 36
7040: PUSH
7041: LD_EXP 36
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 44
7053: PPUSH
7054: CALL_OW 1
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: LD_ADDR_EXP 39
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: LD_EXP 39
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: CALL_OW 52
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: LD_ADDR_EXP 40
7203: PUSH
7204: CALL_OW 44
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: LD_EXP 40
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: CALL_OW 52
// InitHc ;
7221: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: LD_ADDR_EXP 38
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: LD_ADDR_VAR 0 4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: LD_OWVAR 67
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: LD_ADDR_VAR 0 3
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 12
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: CALL 14866 0 5
// un := CreateVehicle ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: CALL_OW 45
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: LD_ADDR_EXP 38
7391: PUSH
7392: LD_EXP 38
7396: PPUSH
7397: LD_VAR 0 3
7401: PUSH
7402: LD_EXP 38
7406: PUSH
7407: LD_VAR 0 3
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: LD_VAR 0 6
7425: PPUSH
7426: CALL 14988 0 3
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: LD_VAR 0 6
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: CALL_OW 12
7446: PPUSH
7447: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: LD_VAR 0 6
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_VAR 0 3
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: CALL_OW 19
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: CALL_OW 302
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: CALL_OW 255
7519: PUSH
7520: LD_EXP 3
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: LD_ADDR_VAR 0 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: LD_ADDR_VAR 0 7
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: LD_ADDR_VAR 0 6
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: LD_ADDR_VAR 0 9
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: LD_ADDR_VAR 0 5
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: LD_OWVAR 67
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: LD_ADDR_VAR 0 1
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_OWVAR 67
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_VAR 0 5
7790: PPUSH
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: CALL_OW 12
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 2
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: LD_VAR 0 4
7858: PPUSH
7859: LD_VAR 0 5
7863: PPUSH
7864: CALL 75500 0 2
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7875: LD_VAR 0 4
7879: PPUSH
7880: CALL 75896 0 1
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: CALL_OW 67
// for i = 1 to coords do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: LD_VAR 0 6
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: LD_EXP 3
7924: PPUSH
7925: LD_VAR 0 6
7929: PUSH
7930: LD_VAR 0 1
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: LD_VAR 0 6
7944: PUSH
7945: LD_VAR 0 1
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: CALL 15884 0 4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: LD_VAR 0 2
7971: PUSH
7972: LD_VAR 0 3
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 2
7988: ST_TO_ADDR
// target := i ;
7989: LD_ADDR_VAR 0 9
7993: PUSH
7994: LD_VAR 0 1
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: LD_VAR 0 9
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: LD_ADDR_VAR 0 10
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: LD_ADDR_VAR 0 10
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: LD_VAR 0 10
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: LD_ADDR_VAR 0 10
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: LD_VAR 0 4
8209: PPUSH
8210: LD_EXP 62
8214: PUSH
8215: LD_VAR 0 4
8219: ARRAY
8220: PPUSH
8221: LD_VAR 0 10
8225: PPUSH
8226: LD_VAR 0 7
8230: PPUSH
8231: CALL 75733 0 4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: CALL_OW 302
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: CALL_OW 255
8253: PUSH
8254: LD_EXP 3
8258: EQUAL
8259: AND
8260: PUSH
8261: LD_EXP 26
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: CALL_OW 301
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: CALL_OW 255
8286: PUSH
8287: LD_EXP 3
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: LD_ADDR_VAR 0 7
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: LD_ADDR_VAR 0 9
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: LD_ADDR_VAR 0 5
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: LD_OWVAR 67
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: LD_ADDR_VAR 0 1
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: LD_OWVAR 67
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: LD_ADDR_VAR 0 5
8512: PUSH
8513: LD_VAR 0 5
8517: PPUSH
8518: LD_VAR 0 5
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 1
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 2
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 5
8588: PPUSH
8589: CALL 75500 0 2
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL 75896 0 1
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: CALL_OW 67
// for i = 1 to coords do
8622: LD_ADDR_VAR 0 1
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: LD_VAR 0 6
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_EXP 3
8649: PPUSH
8650: LD_VAR 0 6
8654: PUSH
8655: LD_VAR 0 1
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_VAR 0 6
8669: PUSH
8670: LD_VAR 0 1
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: CALL 15884 0 4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_VAR 0 3
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_VAR 0 2
8713: ST_TO_ADDR
// target := i ;
8714: LD_ADDR_VAR 0 9
8718: PUSH
8719: LD_VAR 0 1
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: LD_VAR 0 9
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: LD_ADDR_VAR 0 10
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: LD_VAR 0 10
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: LD_ADDR_VAR 0 10
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_EXP 62
8859: PUSH
8860: LD_VAR 0 4
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 10
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL 75733 0 4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: LD_EXP 4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 255
8904: PPUSH
8905: CALL 5823 0 1
// artifact_get := true ;
8909: LD_ADDR_EXP 4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: LD_ADDR_VAR 0 3
8928: PUSH
8929: LD_VAR 0 1
8933: PPUSH
8934: CALL_OW 255
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_EXP 69
8948: IN
8949: NOT
8950: PUSH
8951: LD_EXP 7
8955: PUSH
8956: LD_VAR 0 3
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: LD_VAR 0 1
8968: PPUSH
8969: CALL_OW 247
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: LD_VAR 0 3
8983: PPUSH
8984: CALL 5463 0 1
// if side in mc_sides then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_EXP 69
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: LD_VAR 0 1
9004: PUSH
9005: LD_EXP 40
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: CALL 5577 0 2
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: CALL 4894 0 1
9038: PPUSH
9039: CALL 5577 0 2
// if multi_commanders and multi_custom_commanders then
9043: LD_EXP 24
9047: PUSH
9048: LD_EXP 16
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: LD_VAR 0 1
9059: PUSH
9060: LD_EXP 24
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: LD_ADDR_EXP 25
9071: PUSH
9072: LD_EXP 25
9076: PPUSH
9077: LD_VAR 0 3
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: CALL_OW 1
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: LD_ADDR_EXP 24
9094: PUSH
9095: LD_EXP 24
9099: PUSH
9100: LD_VAR 0 1
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: CALL 4927 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL 78952 0 1
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL 81284 0 2
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: LD_VAR 0 1
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_EXP 69
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: LD_VAR 0 1
9169: PPUSH
9170: CALL_OW 255
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 266
9184: PPUSH
9185: CALL 5507 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: LD_VAR 0 1
9193: PPUSH
9194: CALL_OW 266
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_EXP 69
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: LD_EXP 5
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: LD_VAR 0 1
9232: PPUSH
9233: LD_EXP 5
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9246: LD_ADDR_EXP 5
9250: PUSH
9251: LD_EXP 5
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: CALL_OW 3
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: CALL 80593 0 1
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL 78648 0 2
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: LD_VAR 0 1
9297: PPUSH
9298: LD_VAR 0 2
9302: PPUSH
9303: LD_VAR 0 3
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: LD_VAR 0 5
9317: PPUSH
9318: CALL 78268 0 5
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 255
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: LD_VAR 0 4
9349: PUSH
9350: LD_EXP 69
9354: IN
9355: NOT
9356: PUSH
9357: LD_EXP 7
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: LD_VAR 0 4
9374: PPUSH
9375: CALL 5419 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_VAR 0 2
9388: PPUSH
9389: CALL 77859 0 2
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: LD_VAR 0 1
9400: PPUSH
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 3
9410: PPUSH
9411: LD_VAR 0 4
9415: PPUSH
9416: CALL 77697 0 4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: LD_VAR 0 3
9437: PPUSH
9438: CALL 77472 0 3
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_VAR 0 2
9454: PPUSH
9455: CALL 77357 0 2
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: LD_VAR 0 1
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: CALL 81579 0 2
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PPUSH
9489: LD_VAR 0 3
9493: PPUSH
9494: LD_VAR 0 4
9498: PPUSH
9499: CALL 81795 0 4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: LD_EXP 2
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: LD_EXP 21
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: LD_EXP 21
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: CALL 9556 0 3
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: LD_VAR 0 1
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 67
// x := 5 ;
9599: LD_ADDR_VAR 0 6
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: LD_OWVAR 1
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: LD_OWVAR 67
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: LD_ADDR_VAR 0 5
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_EXP 7
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: LD_EXP 7
9656: PUSH
9657: LD_VAR 0 5
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: LD_VAR 0 6
9668: PPUSH
9669: LD_VAR 0 7
9673: PUSH
9674: LD_EXP 7
9678: PUSH
9679: LD_VAR 0 5
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 55
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: CALL_OW 67
// end ; for i in areas do
9704: LD_ADDR_VAR 0 5
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9724: LD_VAR 0 6
9728: PPUSH
9729: LD_VAR 0 5
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL_OW 55
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_VAR 0 2
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: LD_ADDR_VAR 0 3
9763: PUSH
9764: LD_VAR 0 3
9768: PUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: LD_ADDR_VAR 0 6
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: LD_ADDR_VAR 0 6
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: LD_EXP 2
9833: NOT
9834: PUSH
9835: LD_VAR 0 3
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: LD_VAR 0 2
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: LD_ADDR_VAR 0 5
9865: PUSH
9866: LD_VAR 0 3
9870: PUSH
9871: LD_VAR 0 1
9875: STR
9876: PPUSH
9877: CALL_OW 34
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: LD_ADDR_VAR 0 5
9888: PUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 25
9898: ST_TO_ADDR
// result := unit ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_VAR 0 5
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: LD_VAR 0 1
9922: NOT
9923: PUSH
9924: LD_VAR 0 2
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: LD_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: LD_ADDR_VAR 0 4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: LD_ADDR_VAR 0 4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: LD_ADDR_VAR 0 4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: LD_VAR 0 3
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: LD_VAR 0 3
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: LD_ADDR_VAR 0 5
10651: PUSH
10652: LD_VAR 0 4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: LD_VAR 0 5
10664: PPUSH
10665: LD_VAR 0 1
10669: PPUSH
10670: CALL_OW 321
10674: PUSH
10675: LD_VAR 0 3
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: LD_ADDR_VAR 0 4
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: LD_VAR 0 5
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: LD_ADDR_VAR 0 3
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: LD_ADDR_VAR 0 5
10724: PUSH
10725: LD_VAR 0 2
10729: PPUSH
10730: CALL_OW 480
10734: ST_TO_ADDR
// if not tmp then
10735: LD_VAR 0 5
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: LD_ADDR_VAR 0 4
10748: PUSH
10749: LD_VAR 0 5
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: LD_VAR 0 4
10761: PPUSH
10762: LD_VAR 0 1
10766: PPUSH
10767: CALL_OW 321
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: LD_ADDR_VAR 0 3
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: LD_VAR 0 1
10817: NOT
10818: PUSH
10819: LD_VAR 0 1
10823: PPUSH
10824: CALL_OW 257
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: LD_ADDR_VAR 0 9
10841: PUSH
10842: LD_VAR 0 1
10846: PPUSH
10847: CALL_OW 255
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: LD_ADDR_VAR 0 12
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: LD_ADDR_VAR 0 13
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: LD_ADDR_VAR 0 11
10872: PUSH
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL_OW 310
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: LD_VAR 0 11
10887: PPUSH
10888: CALL_OW 247
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: LD_ADDR_VAR 0 8
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: LD_VAR 0 9
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: CALL_OW 69
10942: ST_TO_ADDR
// if not tmp then
10943: LD_VAR 0 8
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: LD_VAR 0 11
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: LD_ADDR_VAR 0 10
10962: PUSH
10963: LD_VAR 0 8
10967: PPUSH
10968: LD_VAR 0 11
10972: PPUSH
10973: CALL_OW 74
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: LD_ADDR_VAR 0 10
10984: PUSH
10985: LD_VAR 0 8
10989: PPUSH
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 74
10999: ST_TO_ADDR
// if not enemy then
11000: LD_VAR 0 10
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: LD_VAR 0 11
11013: PUSH
11014: LD_VAR 0 11
11018: PPUSH
11019: LD_VAR 0 10
11023: PPUSH
11024: CALL_OW 296
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: LD_VAR 0 1
11038: PPUSH
11039: LD_VAR 0 10
11043: PPUSH
11044: CALL_OW 296
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: LD_ADDR_VAR 0 14
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: LD_VAR 0 9
11072: PPUSH
11073: LD_VAR 0 12
11077: PPUSH
11078: CALL_OW 325
11082: IFFALSE 11111
// missile := Replace ( missile , missile + 1 , 2 ) ;
11084: LD_ADDR_VAR 0 14
11088: PUSH
11089: LD_VAR 0 14
11093: PPUSH
11094: LD_VAR 0 14
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: CALL_OW 1
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: LD_VAR 0 9
11115: PPUSH
11116: LD_VAR 0 13
11120: PPUSH
11121: CALL_OW 325
11125: PUSH
11126: LD_VAR 0 10
11130: PPUSH
11131: CALL_OW 255
11135: PPUSH
11136: LD_VAR 0 13
11140: PPUSH
11141: CALL_OW 325
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Replace ( missile , missile + 1 , 3 ) ;
11149: LD_ADDR_VAR 0 14
11153: PUSH
11154: LD_VAR 0 14
11158: PPUSH
11159: LD_VAR 0 14
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: CALL_OW 1
11175: ST_TO_ADDR
// if missile < 2 then
11176: LD_VAR 0 14
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: LD_ADDR_VAR 0 4
11192: PUSH
11193: LD_VAR 0 10
11197: PPUSH
11198: CALL_OW 250
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: LD_ADDR_VAR 0 5
11207: PUSH
11208: LD_VAR 0 10
11212: PPUSH
11213: CALL_OW 251
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: LD_ADDR_VAR 0 6
11222: PUSH
11223: LD_VAR 0 4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: CALL_OW 12
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: LD_ADDR_VAR 0 7
11245: PUSH
11246: LD_VAR 0 5
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 12
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: LD_VAR 0 6
11268: PPUSH
11269: LD_VAR 0 7
11273: PPUSH
11274: CALL_OW 488
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: LD_ADDR_VAR 0 6
11285: PUSH
11286: LD_VAR 0 4
11290: ST_TO_ADDR
// _y := y ;
11291: LD_ADDR_VAR 0 7
11295: PUSH
11296: LD_VAR 0 5
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: LD_ADDR_VAR 0 3
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: LD_VAR 0 14
11313: PPUSH
11314: CALL_OW 12
11318: ST_TO_ADDR
// case i of 1 :
11319: LD_VAR 0 3
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: LD_VAR 0 1
11337: PPUSH
11338: LD_VAR 0 10
11342: PPUSH
11343: CALL_OW 115
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: LD_VAR 0 1
11362: PPUSH
11363: LD_VAR 0 6
11367: PPUSH
11368: LD_VAR 0 7
11372: PPUSH
11373: CALL_OW 153
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: LD_VAR 0 1
11392: PPUSH
11393: LD_VAR 0 6
11397: PPUSH
11398: LD_VAR 0 7
11402: PPUSH
11403: CALL_OW 154
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: LD_VAR 0 1
11427: NOT
11428: PUSH
11429: LD_VAR 0 2
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: LD_ADDR_VAR 0 5
11443: PUSH
11444: LD_VAR 0 2
11448: PPUSH
11449: CALL_OW 250
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: LD_ADDR_VAR 0 6
11458: PUSH
11459: LD_VAR 0 2
11463: PPUSH
11464: CALL_OW 251
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: LD_ADDR_VAR 0 4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: LD_ADDR_VAR 0 7
11489: PUSH
11490: LD_VAR 0 5
11494: PPUSH
11495: LD_VAR 0 4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: CALL_OW 272
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: LD_ADDR_VAR 0 8
11512: PUSH
11513: LD_VAR 0 6
11517: PPUSH
11518: LD_VAR 0 4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: CALL_OW 273
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: LD_VAR 0 7
11535: PPUSH
11536: LD_VAR 0 8
11540: PPUSH
11541: CALL_OW 488
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: LD_VAR 0 7
11554: PPUSH
11555: LD_VAR 0 8
11559: PPUSH
11560: CALL_OW 428
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: LD_VAR 0 1
11574: PPUSH
11575: LD_VAR 0 7
11579: PPUSH
11580: LD_VAR 0 8
11584: PPUSH
11585: CALL_OW 111
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_VAR 0 2
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: LD_VAR 0 1
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: CALL_OW 70
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: LD_ADDR_VAR 0 2
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: LD_ADDR_VAR 0 3
11655: PUSH
11656: LD_VAR 0 1
11660: PPUSH
11661: CALL_OW 255
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: LD_ADDR_VAR 0 4
11670: PUSH
11671: LD_VAR 0 1
11675: PPUSH
11676: CALL_OW 248
11680: ST_TO_ADDR
// case nat of 1 :
11681: LD_VAR 0 4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: LD_ADDR_VAR 0 5
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: LD_ADDR_VAR 0 5
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: LD_ADDR_VAR 0 5
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: LD_VAR 0 3
11748: PPUSH
11749: LD_VAR 0 5
11753: PPUSH
11754: CALL_OW 325
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: LD_ADDR_VAR 0 2
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: LD_VAR 0 4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: LD_VAR 0 2
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: LD_ADDR_VAR 0 5
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: LD_VAR 0 1
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: CALL_OW 69
11846: ST_TO_ADDR
// for i in mines do
11847: LD_ADDR_VAR 0 4
11851: PUSH
11852: LD_VAR 0 2
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: LD_VAR 0 4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: LD_VAR 0 4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: CALL_OW 458
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: CALL_OW 428
11909: PUSH
11910: LD_VAR 0 5
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: LD_VAR 0 4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: LD_VAR 0 4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: LD_VAR 0 1
11939: PPUSH
11940: CALL_OW 456
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: LD_ADDR_VAR 0 2
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: LD_ADDR_VAR 0 3
11969: PUSH
11970: LD_VAR 0 1
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: LD_VAR 0 3
11982: IFFALSE 11998
// result := result + 1 ;
11984: LD_ADDR_VAR 0 2
11988: PUSH
11989: LD_VAR 0 2
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: LD_VAR 0 1
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: LD_ADDR_VAR 0 2
12023: PUSH
12024: LD_VAR 0 1
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: LD_VAR 0 1
12036: PPUSH
12037: CALL_OW 255
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: CALL_OW 69
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; var places ; begin
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// if not building then
12071: LD_VAR 0 1
12075: NOT
12076: IFFALSE 12080
// exit ;
12078: GO 12251
// result := false ;
12080: LD_ADDR_VAR 0 2
12084: PUSH
12085: LD_INT 0
12087: ST_TO_ADDR
// places := 0 ;
12088: LD_ADDR_VAR 0 3
12092: PUSH
12093: LD_INT 0
12095: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12096: LD_VAR 0 1
12100: PPUSH
12101: CALL_OW 266
12105: PUSH
12106: LD_INT 0
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12168
12112: LD_INT 1
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12168
12118: LD_INT 6
12120: DOUBLE
12121: EQUAL
12122: IFTRUE 12168
12124: LD_INT 7
12126: DOUBLE
12127: EQUAL
12128: IFTRUE 12168
12130: LD_INT 8
12132: DOUBLE
12133: EQUAL
12134: IFTRUE 12168
12136: LD_INT 4
12138: DOUBLE
12139: EQUAL
12140: IFTRUE 12168
12142: LD_INT 5
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12168
12148: LD_INT 2
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12168
12154: LD_INT 3
12156: DOUBLE
12157: EQUAL
12158: IFTRUE 12168
12160: LD_INT 35
12162: DOUBLE
12163: EQUAL
12164: IFTRUE 12168
12166: GO 12179
12168: POP
// places := 6 ; b_bunker , b_breastwork :
12169: LD_ADDR_VAR 0 3
12173: PUSH
12174: LD_INT 6
12176: ST_TO_ADDR
12177: GO 12224
12179: LD_INT 32
12181: DOUBLE
12182: EQUAL
12183: IFTRUE 12193
12185: LD_INT 31
12187: DOUBLE
12188: EQUAL
12189: IFTRUE 12193
12191: GO 12204
12193: POP
// places := 1 ; b_control_tower :
12194: LD_ADDR_VAR 0 3
12198: PUSH
12199: LD_INT 1
12201: ST_TO_ADDR
12202: GO 12224
12204: LD_INT 36
12206: DOUBLE
12207: EQUAL
12208: IFTRUE 12212
12210: GO 12223
12212: POP
// places := 3 ; end ;
12213: LD_ADDR_VAR 0 3
12217: PUSH
12218: LD_INT 3
12220: ST_TO_ADDR
12221: GO 12224
12223: POP
// if places then
12224: LD_VAR 0 3
12228: IFFALSE 12251
// result := UnitsInside ( building ) < places ;
12230: LD_ADDR_VAR 0 2
12234: PUSH
12235: LD_VAR 0 1
12239: PPUSH
12240: CALL_OW 313
12244: PUSH
12245: LD_VAR 0 3
12249: LESS
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 2
12255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
12261: PPUSH
// tmp := [ ] ;
12262: LD_ADDR_VAR 0 3
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// list := [ ] ;
12269: LD_ADDR_VAR 0 5
12273: PUSH
12274: EMPTY
12275: ST_TO_ADDR
// for i = 16 to 25 do
12276: LD_ADDR_VAR 0 4
12280: PUSH
12281: DOUBLE
12282: LD_INT 16
12284: DEC
12285: ST_TO_ADDR
12286: LD_INT 25
12288: PUSH
12289: FOR_TO
12290: IFFALSE 12363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12292: LD_ADDR_VAR 0 3
12296: PUSH
12297: LD_VAR 0 3
12301: PUSH
12302: LD_INT 22
12304: PUSH
12305: LD_VAR 0 1
12309: PPUSH
12310: CALL_OW 255
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 91
12321: PUSH
12322: LD_VAR 0 1
12326: PUSH
12327: LD_INT 6
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 30
12337: PUSH
12338: LD_VAR 0 4
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: LIST
12351: PUSH
12352: EMPTY
12353: LIST
12354: PPUSH
12355: CALL_OW 69
12359: ADD
12360: ST_TO_ADDR
12361: GO 12289
12363: POP
12364: POP
// for i = 1 to tmp do
12365: LD_ADDR_VAR 0 4
12369: PUSH
12370: DOUBLE
12371: LD_INT 1
12373: DEC
12374: ST_TO_ADDR
12375: LD_VAR 0 3
12379: PUSH
12380: FOR_TO
12381: IFFALSE 12469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12383: LD_ADDR_VAR 0 5
12387: PUSH
12388: LD_VAR 0 5
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: LD_VAR 0 4
12402: ARRAY
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_VAR 0 3
12413: PUSH
12414: LD_VAR 0 4
12418: ARRAY
12419: PPUSH
12420: CALL_OW 250
12424: PUSH
12425: LD_VAR 0 3
12429: PUSH
12430: LD_VAR 0 4
12434: ARRAY
12435: PPUSH
12436: CALL_OW 251
12440: PUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 4
12450: ARRAY
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: PUSH
12463: EMPTY
12464: LIST
12465: ADD
12466: ST_TO_ADDR
12467: GO 12380
12469: POP
12470: POP
// result := list ;
12471: LD_ADDR_VAR 0 2
12475: PUSH
12476: LD_VAR 0 5
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 2
12485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
12491: PPUSH
12492: PPUSH
12493: PPUSH
12494: PPUSH
// if not factory then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 13097
// if control = control_apeman then
12504: LD_VAR 0 4
12508: PUSH
12509: LD_INT 5
12511: EQUAL
12512: IFFALSE 12621
// begin tmp := UnitsInside ( factory ) ;
12514: LD_ADDR_VAR 0 8
12518: PUSH
12519: LD_VAR 0 1
12523: PPUSH
12524: CALL_OW 313
12528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12529: LD_VAR 0 8
12533: PPUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 12
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PPUSH
12544: CALL_OW 72
12548: NOT
12549: IFFALSE 12559
// control := control_manual ;
12551: LD_ADDR_VAR 0 4
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12559: LD_ADDR_VAR 0 8
12563: PUSH
12564: LD_VAR 0 1
12568: PPUSH
12569: CALL 12256 0 1
12573: ST_TO_ADDR
// if tmp then
12574: LD_VAR 0 8
12578: IFFALSE 12621
// begin for i in tmp do
12580: LD_ADDR_VAR 0 7
12584: PUSH
12585: LD_VAR 0 8
12589: PUSH
12590: FOR_IN
12591: IFFALSE 12619
// if i [ 1 ] = b_ext_radio then
12593: LD_VAR 0 7
12597: PUSH
12598: LD_INT 1
12600: ARRAY
12601: PUSH
12602: LD_INT 22
12604: EQUAL
12605: IFFALSE 12617
// begin control := control_remote ;
12607: LD_ADDR_VAR 0 4
12611: PUSH
12612: LD_INT 2
12614: ST_TO_ADDR
// break ;
12615: GO 12619
// end ;
12617: GO 12590
12619: POP
12620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PPUSH
12636: LD_VAR 0 4
12640: PPUSH
12641: LD_VAR 0 5
12645: PPUSH
12646: CALL_OW 448
12650: IFFALSE 12685
// begin result := [ chassis , engine , control , weapon ] ;
12652: LD_ADDR_VAR 0 6
12656: PUSH
12657: LD_VAR 0 2
12661: PUSH
12662: LD_VAR 0 3
12666: PUSH
12667: LD_VAR 0 4
12671: PUSH
12672: LD_VAR 0 5
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: ST_TO_ADDR
// exit ;
12683: GO 13097
// end ; _chassis := AvailableChassisList ( factory ) ;
12685: LD_ADDR_VAR 0 9
12689: PUSH
12690: LD_VAR 0 1
12694: PPUSH
12695: CALL_OW 475
12699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12700: LD_ADDR_VAR 0 11
12704: PUSH
12705: LD_VAR 0 1
12709: PPUSH
12710: CALL_OW 476
12714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12715: LD_ADDR_VAR 0 12
12719: PUSH
12720: LD_VAR 0 1
12724: PPUSH
12725: CALL_OW 477
12729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12730: LD_ADDR_VAR 0 10
12734: PUSH
12735: LD_VAR 0 1
12739: PPUSH
12740: CALL_OW 478
12744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12745: LD_VAR 0 9
12749: NOT
12750: PUSH
12751: LD_VAR 0 11
12755: NOT
12756: OR
12757: PUSH
12758: LD_VAR 0 12
12762: NOT
12763: OR
12764: PUSH
12765: LD_VAR 0 10
12769: NOT
12770: OR
12771: IFFALSE 12806
// begin result := [ chassis , engine , control , weapon ] ;
12773: LD_ADDR_VAR 0 6
12777: PUSH
12778: LD_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: LD_VAR 0 4
12792: PUSH
12793: LD_VAR 0 5
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// exit ;
12804: GO 13097
// end ; if not chassis in _chassis then
12806: LD_VAR 0 2
12810: PUSH
12811: LD_VAR 0 9
12815: IN
12816: NOT
12817: IFFALSE 12843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12819: LD_ADDR_VAR 0 2
12823: PUSH
12824: LD_VAR 0 9
12828: PUSH
12829: LD_INT 1
12831: PPUSH
12832: LD_VAR 0 9
12836: PPUSH
12837: CALL_OW 12
12841: ARRAY
12842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12843: LD_VAR 0 2
12847: PPUSH
12848: LD_VAR 0 3
12852: PPUSH
12853: CALL 13102 0 2
12857: NOT
12858: IFFALSE 12917
// repeat engine := _engine [ 1 ] ;
12860: LD_ADDR_VAR 0 3
12864: PUSH
12865: LD_VAR 0 11
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12874: LD_ADDR_VAR 0 11
12878: PUSH
12879: LD_VAR 0 11
12883: PPUSH
12884: LD_INT 1
12886: PPUSH
12887: CALL_OW 3
12891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12892: LD_VAR 0 2
12896: PPUSH
12897: LD_VAR 0 3
12901: PPUSH
12902: CALL 13102 0 2
12906: PUSH
12907: LD_VAR 0 11
12911: PUSH
12912: EMPTY
12913: EQUAL
12914: OR
12915: IFFALSE 12860
// if not control in _control then
12917: LD_VAR 0 4
12921: PUSH
12922: LD_VAR 0 12
12926: IN
12927: NOT
12928: IFFALSE 12954
// control := _control [ rand ( 1 , _control ) ] ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 12
12939: PUSH
12940: LD_INT 1
12942: PPUSH
12943: LD_VAR 0 12
12947: PPUSH
12948: CALL_OW 12
12952: ARRAY
12953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12954: LD_VAR 0 2
12958: PPUSH
12959: LD_VAR 0 5
12963: PPUSH
12964: CALL 13322 0 2
12968: NOT
12969: IFFALSE 13028
// repeat weapon := _weapon [ 1 ] ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_VAR 0 10
12980: PUSH
12981: LD_INT 1
12983: ARRAY
12984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12985: LD_ADDR_VAR 0 10
12989: PUSH
12990: LD_VAR 0 10
12994: PPUSH
12995: LD_INT 1
12997: PPUSH
12998: CALL_OW 3
13002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
13003: LD_VAR 0 2
13007: PPUSH
13008: LD_VAR 0 5
13012: PPUSH
13013: CALL 13322 0 2
13017: PUSH
13018: LD_VAR 0 10
13022: PUSH
13023: EMPTY
13024: EQUAL
13025: OR
13026: IFFALSE 12971
// result := [ ] ;
13028: LD_ADDR_VAR 0 6
13032: PUSH
13033: EMPTY
13034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13035: LD_VAR 0 1
13039: PPUSH
13040: LD_VAR 0 2
13044: PPUSH
13045: LD_VAR 0 3
13049: PPUSH
13050: LD_VAR 0 4
13054: PPUSH
13055: LD_VAR 0 5
13059: PPUSH
13060: CALL_OW 448
13064: IFFALSE 13097
// result := [ chassis , engine , control , weapon ] ;
13066: LD_ADDR_VAR 0 6
13070: PUSH
13071: LD_VAR 0 2
13075: PUSH
13076: LD_VAR 0 3
13080: PUSH
13081: LD_VAR 0 4
13085: PUSH
13086: LD_VAR 0 5
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: ST_TO_ADDR
// end ;
13097: LD_VAR 0 6
13101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13102: LD_INT 0
13104: PPUSH
// if not chassis or not engine then
13105: LD_VAR 0 1
13109: NOT
13110: PUSH
13111: LD_VAR 0 2
13115: NOT
13116: OR
13117: IFFALSE 13121
// exit ;
13119: GO 13317
// case engine of engine_solar :
13121: LD_VAR 0 2
13125: PUSH
13126: LD_INT 2
13128: DOUBLE
13129: EQUAL
13130: IFTRUE 13134
13132: GO 13172
13134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 11
13142: PUSH
13143: LD_INT 12
13145: PUSH
13146: LD_INT 13
13148: PUSH
13149: LD_INT 14
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: LD_INT 2
13157: PUSH
13158: LD_INT 3
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13301
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13242
13180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13181: LD_ADDR_VAR 0 3
13185: PUSH
13186: LD_INT 11
13188: PUSH
13189: LD_INT 12
13191: PUSH
13192: LD_INT 13
13194: PUSH
13195: LD_INT 14
13197: PUSH
13198: LD_INT 1
13200: PUSH
13201: LD_INT 2
13203: PUSH
13204: LD_INT 3
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: LD_INT 5
13212: PUSH
13213: LD_INT 21
13215: PUSH
13216: LD_INT 23
13218: PUSH
13219: LD_INT 22
13221: PUSH
13222: LD_INT 24
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: ST_TO_ADDR
13240: GO 13301
13242: LD_INT 3
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13300
13250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13251: LD_ADDR_VAR 0 3
13255: PUSH
13256: LD_INT 13
13258: PUSH
13259: LD_INT 14
13261: PUSH
13262: LD_INT 2
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: LD_INT 4
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 21
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 23
13282: PUSH
13283: LD_INT 24
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: ST_TO_ADDR
13298: GO 13301
13300: POP
// result := ( chassis in result ) ;
13301: LD_ADDR_VAR 0 3
13305: PUSH
13306: LD_VAR 0 1
13310: PUSH
13311: LD_VAR 0 3
13315: IN
13316: ST_TO_ADDR
// end ;
13317: LD_VAR 0 3
13321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13322: LD_INT 0
13324: PPUSH
// if not chassis or not weapon then
13325: LD_VAR 0 1
13329: NOT
13330: PUSH
13331: LD_VAR 0 2
13335: NOT
13336: OR
13337: IFFALSE 13341
// exit ;
13339: GO 14401
// case weapon of us_machine_gun :
13341: LD_VAR 0 2
13345: PUSH
13346: LD_INT 2
13348: DOUBLE
13349: EQUAL
13350: IFTRUE 13354
13352: GO 13384
13354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13355: LD_ADDR_VAR 0 3
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: LD_INT 2
13365: PUSH
13366: LD_INT 3
13368: PUSH
13369: LD_INT 4
13371: PUSH
13372: LD_INT 5
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: ST_TO_ADDR
13382: GO 14385
13384: LD_INT 3
13386: DOUBLE
13387: EQUAL
13388: IFTRUE 13392
13390: GO 13422
13392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13393: LD_ADDR_VAR 0 3
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: LD_INT 2
13403: PUSH
13404: LD_INT 3
13406: PUSH
13407: LD_INT 4
13409: PUSH
13410: LD_INT 5
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: ST_TO_ADDR
13420: GO 14385
13422: LD_INT 11
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13460
13430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13431: LD_ADDR_VAR 0 3
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 2
13441: PUSH
13442: LD_INT 3
13444: PUSH
13445: LD_INT 4
13447: PUSH
13448: LD_INT 5
13450: PUSH
13451: EMPTY
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: ST_TO_ADDR
13458: GO 14385
13460: LD_INT 4
13462: DOUBLE
13463: EQUAL
13464: IFTRUE 13468
13466: GO 13494
13468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13469: LD_ADDR_VAR 0 3
13473: PUSH
13474: LD_INT 2
13476: PUSH
13477: LD_INT 3
13479: PUSH
13480: LD_INT 4
13482: PUSH
13483: LD_INT 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: ST_TO_ADDR
13492: GO 14385
13494: LD_INT 5
13496: DOUBLE
13497: EQUAL
13498: IFTRUE 13502
13500: GO 13528
13502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13503: LD_ADDR_VAR 0 3
13507: PUSH
13508: LD_INT 2
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: LD_INT 4
13516: PUSH
13517: LD_INT 5
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14385
13528: LD_INT 9
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13537: LD_ADDR_VAR 0 3
13541: PUSH
13542: LD_INT 2
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: LD_INT 5
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14385
13562: LD_INT 7
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13571: LD_ADDR_VAR 0 3
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: LD_INT 3
13581: PUSH
13582: LD_INT 4
13584: PUSH
13585: LD_INT 5
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14385
13596: LD_INT 12
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13605: LD_ADDR_VAR 0 3
13609: PUSH
13610: LD_INT 2
13612: PUSH
13613: LD_INT 3
13615: PUSH
13616: LD_INT 4
13618: PUSH
13619: LD_INT 5
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14385
13630: LD_INT 13
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13639: LD_ADDR_VAR 0 3
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: LD_INT 3
13649: PUSH
13650: LD_INT 4
13652: PUSH
13653: LD_INT 5
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14385
13664: LD_INT 14
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13673: LD_ADDR_VAR 0 3
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: LD_INT 5
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14385
13690: LD_INT 6
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 4
13706: PUSH
13707: LD_INT 5
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14385
13716: LD_INT 10
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13742
13724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13725: LD_ADDR_VAR 0 3
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: LD_INT 5
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: ST_TO_ADDR
13740: GO 14385
13742: LD_INT 22
13744: DOUBLE
13745: EQUAL
13746: IFTRUE 13750
13748: GO 13776
13750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: LD_INT 11
13758: PUSH
13759: LD_INT 12
13761: PUSH
13762: LD_INT 13
13764: PUSH
13765: LD_INT 14
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14385
13776: LD_INT 23
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13810
13784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13785: LD_ADDR_VAR 0 3
13789: PUSH
13790: LD_INT 11
13792: PUSH
13793: LD_INT 12
13795: PUSH
13796: LD_INT 13
13798: PUSH
13799: LD_INT 14
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: ST_TO_ADDR
13808: GO 14385
13810: LD_INT 24
13812: DOUBLE
13813: EQUAL
13814: IFTRUE 13818
13816: GO 13844
13818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13819: LD_ADDR_VAR 0 3
13823: PUSH
13824: LD_INT 11
13826: PUSH
13827: LD_INT 12
13829: PUSH
13830: LD_INT 13
13832: PUSH
13833: LD_INT 14
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: ST_TO_ADDR
13842: GO 14385
13844: LD_INT 30
13846: DOUBLE
13847: EQUAL
13848: IFTRUE 13852
13850: GO 13878
13852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13853: LD_ADDR_VAR 0 3
13857: PUSH
13858: LD_INT 11
13860: PUSH
13861: LD_INT 12
13863: PUSH
13864: LD_INT 13
13866: PUSH
13867: LD_INT 14
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: ST_TO_ADDR
13876: GO 14385
13878: LD_INT 25
13880: DOUBLE
13881: EQUAL
13882: IFTRUE 13886
13884: GO 13904
13886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13887: LD_ADDR_VAR 0 3
13891: PUSH
13892: LD_INT 13
13894: PUSH
13895: LD_INT 14
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: ST_TO_ADDR
13902: GO 14385
13904: LD_INT 27
13906: DOUBLE
13907: EQUAL
13908: IFTRUE 13912
13910: GO 13930
13912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13913: LD_ADDR_VAR 0 3
13917: PUSH
13918: LD_INT 13
13920: PUSH
13921: LD_INT 14
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: ST_TO_ADDR
13928: GO 14385
13930: LD_INT 92
13932: DOUBLE
13933: EQUAL
13934: IFTRUE 13938
13936: GO 13964
13938: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13939: LD_ADDR_VAR 0 3
13943: PUSH
13944: LD_INT 11
13946: PUSH
13947: LD_INT 12
13949: PUSH
13950: LD_INT 13
13952: PUSH
13953: LD_INT 14
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: ST_TO_ADDR
13962: GO 14385
13964: LD_INT 28
13966: DOUBLE
13967: EQUAL
13968: IFTRUE 13972
13970: GO 13990
13972: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13973: LD_ADDR_VAR 0 3
13977: PUSH
13978: LD_INT 13
13980: PUSH
13981: LD_INT 14
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: ST_TO_ADDR
13988: GO 14385
13990: LD_INT 29
13992: DOUBLE
13993: EQUAL
13994: IFTRUE 13998
13996: GO 14016
13998: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13999: LD_ADDR_VAR 0 3
14003: PUSH
14004: LD_INT 13
14006: PUSH
14007: LD_INT 14
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: ST_TO_ADDR
14014: GO 14385
14016: LD_INT 31
14018: DOUBLE
14019: EQUAL
14020: IFTRUE 14024
14022: GO 14042
14024: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14025: LD_ADDR_VAR 0 3
14029: PUSH
14030: LD_INT 13
14032: PUSH
14033: LD_INT 14
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: ST_TO_ADDR
14040: GO 14385
14042: LD_INT 26
14044: DOUBLE
14045: EQUAL
14046: IFTRUE 14050
14048: GO 14068
14050: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14051: LD_ADDR_VAR 0 3
14055: PUSH
14056: LD_INT 13
14058: PUSH
14059: LD_INT 14
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: ST_TO_ADDR
14066: GO 14385
14068: LD_INT 42
14070: DOUBLE
14071: EQUAL
14072: IFTRUE 14076
14074: GO 14102
14076: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: LD_INT 21
14084: PUSH
14085: LD_INT 22
14087: PUSH
14088: LD_INT 23
14090: PUSH
14091: LD_INT 24
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: ST_TO_ADDR
14100: GO 14385
14102: LD_INT 43
14104: DOUBLE
14105: EQUAL
14106: IFTRUE 14110
14108: GO 14136
14110: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14111: LD_ADDR_VAR 0 3
14115: PUSH
14116: LD_INT 21
14118: PUSH
14119: LD_INT 22
14121: PUSH
14122: LD_INT 23
14124: PUSH
14125: LD_INT 24
14127: PUSH
14128: EMPTY
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: ST_TO_ADDR
14134: GO 14385
14136: LD_INT 44
14138: DOUBLE
14139: EQUAL
14140: IFTRUE 14144
14142: GO 14170
14144: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14145: LD_ADDR_VAR 0 3
14149: PUSH
14150: LD_INT 21
14152: PUSH
14153: LD_INT 22
14155: PUSH
14156: LD_INT 23
14158: PUSH
14159: LD_INT 24
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: ST_TO_ADDR
14168: GO 14385
14170: LD_INT 45
14172: DOUBLE
14173: EQUAL
14174: IFTRUE 14178
14176: GO 14204
14178: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14179: LD_ADDR_VAR 0 3
14183: PUSH
14184: LD_INT 21
14186: PUSH
14187: LD_INT 22
14189: PUSH
14190: LD_INT 23
14192: PUSH
14193: LD_INT 24
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: ST_TO_ADDR
14202: GO 14385
14204: LD_INT 49
14206: DOUBLE
14207: EQUAL
14208: IFTRUE 14212
14210: GO 14238
14212: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: LD_INT 21
14220: PUSH
14221: LD_INT 22
14223: PUSH
14224: LD_INT 23
14226: PUSH
14227: LD_INT 24
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: ST_TO_ADDR
14236: GO 14385
14238: LD_INT 51
14240: DOUBLE
14241: EQUAL
14242: IFTRUE 14246
14244: GO 14272
14246: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14247: LD_ADDR_VAR 0 3
14251: PUSH
14252: LD_INT 21
14254: PUSH
14255: LD_INT 22
14257: PUSH
14258: LD_INT 23
14260: PUSH
14261: LD_INT 24
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: ST_TO_ADDR
14270: GO 14385
14272: LD_INT 52
14274: DOUBLE
14275: EQUAL
14276: IFTRUE 14280
14278: GO 14306
14280: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14281: LD_ADDR_VAR 0 3
14285: PUSH
14286: LD_INT 21
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 23
14294: PUSH
14295: LD_INT 24
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: ST_TO_ADDR
14304: GO 14385
14306: LD_INT 53
14308: DOUBLE
14309: EQUAL
14310: IFTRUE 14314
14312: GO 14332
14314: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14315: LD_ADDR_VAR 0 3
14319: PUSH
14320: LD_INT 23
14322: PUSH
14323: LD_INT 24
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: ST_TO_ADDR
14330: GO 14385
14332: LD_INT 46
14334: DOUBLE
14335: EQUAL
14336: IFTRUE 14340
14338: GO 14358
14340: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14341: LD_ADDR_VAR 0 3
14345: PUSH
14346: LD_INT 23
14348: PUSH
14349: LD_INT 24
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: ST_TO_ADDR
14356: GO 14385
14358: LD_INT 47
14360: DOUBLE
14361: EQUAL
14362: IFTRUE 14366
14364: GO 14384
14366: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14367: LD_ADDR_VAR 0 3
14371: PUSH
14372: LD_INT 23
14374: PUSH
14375: LD_INT 24
14377: PUSH
14378: EMPTY
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 14385
14384: POP
// result := ( chassis in result ) ;
14385: LD_ADDR_VAR 0 3
14389: PUSH
14390: LD_VAR 0 1
14394: PUSH
14395: LD_VAR 0 3
14399: IN
14400: ST_TO_ADDR
// end ;
14401: LD_VAR 0 3
14405: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14406: LD_INT 0
14408: PPUSH
14409: PPUSH
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
// result := array ;
14415: LD_ADDR_VAR 0 5
14419: PUSH
14420: LD_VAR 0 1
14424: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14425: LD_VAR 0 1
14429: NOT
14430: PUSH
14431: LD_VAR 0 2
14435: NOT
14436: OR
14437: PUSH
14438: LD_VAR 0 3
14442: NOT
14443: OR
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_VAR 0 1
14454: GREATER
14455: OR
14456: PUSH
14457: LD_VAR 0 3
14461: PUSH
14462: LD_VAR 0 1
14466: GREATER
14467: OR
14468: IFFALSE 14472
// exit ;
14470: GO 14768
// if direction then
14472: LD_VAR 0 4
14476: IFFALSE 14540
// begin d := 1 ;
14478: LD_ADDR_VAR 0 9
14482: PUSH
14483: LD_INT 1
14485: ST_TO_ADDR
// if i_from > i_to then
14486: LD_VAR 0 2
14490: PUSH
14491: LD_VAR 0 3
14495: GREATER
14496: IFFALSE 14522
// length := ( array - i_from ) + i_to else
14498: LD_ADDR_VAR 0 11
14502: PUSH
14503: LD_VAR 0 1
14507: PUSH
14508: LD_VAR 0 2
14512: MINUS
14513: PUSH
14514: LD_VAR 0 3
14518: PLUS
14519: ST_TO_ADDR
14520: GO 14538
// length := i_to - i_from ;
14522: LD_ADDR_VAR 0 11
14526: PUSH
14527: LD_VAR 0 3
14531: PUSH
14532: LD_VAR 0 2
14536: MINUS
14537: ST_TO_ADDR
// end else
14538: GO 14601
// begin d := - 1 ;
14540: LD_ADDR_VAR 0 9
14544: PUSH
14545: LD_INT 1
14547: NEG
14548: ST_TO_ADDR
// if i_from > i_to then
14549: LD_VAR 0 2
14553: PUSH
14554: LD_VAR 0 3
14558: GREATER
14559: IFFALSE 14579
// length := i_from - i_to else
14561: LD_ADDR_VAR 0 11
14565: PUSH
14566: LD_VAR 0 2
14570: PUSH
14571: LD_VAR 0 3
14575: MINUS
14576: ST_TO_ADDR
14577: GO 14601
// length := ( array - i_to ) + i_from ;
14579: LD_ADDR_VAR 0 11
14583: PUSH
14584: LD_VAR 0 1
14588: PUSH
14589: LD_VAR 0 3
14593: MINUS
14594: PUSH
14595: LD_VAR 0 2
14599: PLUS
14600: ST_TO_ADDR
// end ; if not length then
14601: LD_VAR 0 11
14605: NOT
14606: IFFALSE 14610
// exit ;
14608: GO 14768
// tmp := array ;
14610: LD_ADDR_VAR 0 10
14614: PUSH
14615: LD_VAR 0 1
14619: ST_TO_ADDR
// for i = 1 to length do
14620: LD_ADDR_VAR 0 6
14624: PUSH
14625: DOUBLE
14626: LD_INT 1
14628: DEC
14629: ST_TO_ADDR
14630: LD_VAR 0 11
14634: PUSH
14635: FOR_TO
14636: IFFALSE 14756
// begin for j = 1 to array do
14638: LD_ADDR_VAR 0 7
14642: PUSH
14643: DOUBLE
14644: LD_INT 1
14646: DEC
14647: ST_TO_ADDR
14648: LD_VAR 0 1
14652: PUSH
14653: FOR_TO
14654: IFFALSE 14742
// begin k := j + d ;
14656: LD_ADDR_VAR 0 8
14660: PUSH
14661: LD_VAR 0 7
14665: PUSH
14666: LD_VAR 0 9
14670: PLUS
14671: ST_TO_ADDR
// if k > array then
14672: LD_VAR 0 8
14676: PUSH
14677: LD_VAR 0 1
14681: GREATER
14682: IFFALSE 14692
// k := 1 ;
14684: LD_ADDR_VAR 0 8
14688: PUSH
14689: LD_INT 1
14691: ST_TO_ADDR
// if not k then
14692: LD_VAR 0 8
14696: NOT
14697: IFFALSE 14709
// k := array ;
14699: LD_ADDR_VAR 0 8
14703: PUSH
14704: LD_VAR 0 1
14708: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14709: LD_ADDR_VAR 0 10
14713: PUSH
14714: LD_VAR 0 10
14718: PPUSH
14719: LD_VAR 0 8
14723: PPUSH
14724: LD_VAR 0 1
14728: PUSH
14729: LD_VAR 0 7
14733: ARRAY
14734: PPUSH
14735: CALL_OW 1
14739: ST_TO_ADDR
// end ;
14740: GO 14653
14742: POP
14743: POP
// array := tmp ;
14744: LD_ADDR_VAR 0 1
14748: PUSH
14749: LD_VAR 0 10
14753: ST_TO_ADDR
// end ;
14754: GO 14635
14756: POP
14757: POP
// result := array ;
14758: LD_ADDR_VAR 0 5
14762: PUSH
14763: LD_VAR 0 1
14767: ST_TO_ADDR
// end ;
14768: LD_VAR 0 5
14772: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
// result := 0 ;
14777: LD_ADDR_VAR 0 3
14781: PUSH
14782: LD_INT 0
14784: ST_TO_ADDR
// if not array or not value in array then
14785: LD_VAR 0 1
14789: NOT
14790: PUSH
14791: LD_VAR 0 2
14795: PUSH
14796: LD_VAR 0 1
14800: IN
14801: NOT
14802: OR
14803: IFFALSE 14807
// exit ;
14805: GO 14861
// for i = 1 to array do
14807: LD_ADDR_VAR 0 4
14811: PUSH
14812: DOUBLE
14813: LD_INT 1
14815: DEC
14816: ST_TO_ADDR
14817: LD_VAR 0 1
14821: PUSH
14822: FOR_TO
14823: IFFALSE 14859
// if value = array [ i ] then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_VAR 0 1
14834: PUSH
14835: LD_VAR 0 4
14839: ARRAY
14840: EQUAL
14841: IFFALSE 14857
// begin result := i ;
14843: LD_ADDR_VAR 0 3
14847: PUSH
14848: LD_VAR 0 4
14852: ST_TO_ADDR
// exit ;
14853: POP
14854: POP
14855: GO 14861
// end ;
14857: GO 14822
14859: POP
14860: POP
// end ;
14861: LD_VAR 0 3
14865: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14866: LD_INT 0
14868: PPUSH
// vc_chassis := chassis ;
14869: LD_ADDR_OWVAR 37
14873: PUSH
14874: LD_VAR 0 1
14878: ST_TO_ADDR
// vc_engine := engine ;
14879: LD_ADDR_OWVAR 39
14883: PUSH
14884: LD_VAR 0 2
14888: ST_TO_ADDR
// vc_control := control ;
14889: LD_ADDR_OWVAR 38
14893: PUSH
14894: LD_VAR 0 3
14898: ST_TO_ADDR
// vc_weapon := weapon ;
14899: LD_ADDR_OWVAR 40
14903: PUSH
14904: LD_VAR 0 4
14908: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14909: LD_ADDR_OWVAR 41
14913: PUSH
14914: LD_VAR 0 5
14918: ST_TO_ADDR
// end ;
14919: LD_VAR 0 6
14923: RET
// export function WantPlant ( unit ) ; var task ; begin
14924: LD_INT 0
14926: PPUSH
14927: PPUSH
// result := false ;
14928: LD_ADDR_VAR 0 2
14932: PUSH
14933: LD_INT 0
14935: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14936: LD_ADDR_VAR 0 3
14940: PUSH
14941: LD_VAR 0 1
14945: PPUSH
14946: CALL_OW 437
14950: ST_TO_ADDR
// if task then
14951: LD_VAR 0 3
14955: IFFALSE 14983
// if task [ 1 ] [ 1 ] = p then
14957: LD_VAR 0 3
14961: PUSH
14962: LD_INT 1
14964: ARRAY
14965: PUSH
14966: LD_INT 1
14968: ARRAY
14969: PUSH
14970: LD_STRING p
14972: EQUAL
14973: IFFALSE 14983
// result := true ;
14975: LD_ADDR_VAR 0 2
14979: PUSH
14980: LD_INT 1
14982: ST_TO_ADDR
// end ;
14983: LD_VAR 0 2
14987: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14988: LD_INT 0
14990: PPUSH
14991: PPUSH
14992: PPUSH
14993: PPUSH
// if pos < 1 then
14994: LD_VAR 0 2
14998: PUSH
14999: LD_INT 1
15001: LESS
15002: IFFALSE 15006
// exit ;
15004: GO 15309
// if pos = 1 then
15006: LD_VAR 0 2
15010: PUSH
15011: LD_INT 1
15013: EQUAL
15014: IFFALSE 15047
// result := Replace ( arr , pos [ 1 ] , value ) else
15016: LD_ADDR_VAR 0 4
15020: PUSH
15021: LD_VAR 0 1
15025: PPUSH
15026: LD_VAR 0 2
15030: PUSH
15031: LD_INT 1
15033: ARRAY
15034: PPUSH
15035: LD_VAR 0 3
15039: PPUSH
15040: CALL_OW 1
15044: ST_TO_ADDR
15045: GO 15309
// begin tmp := arr ;
15047: LD_ADDR_VAR 0 6
15051: PUSH
15052: LD_VAR 0 1
15056: ST_TO_ADDR
// s_arr := [ tmp ] ;
15057: LD_ADDR_VAR 0 7
15061: PUSH
15062: LD_VAR 0 6
15066: PUSH
15067: EMPTY
15068: LIST
15069: ST_TO_ADDR
// for i = 1 to pos - 1 do
15070: LD_ADDR_VAR 0 5
15074: PUSH
15075: DOUBLE
15076: LD_INT 1
15078: DEC
15079: ST_TO_ADDR
15080: LD_VAR 0 2
15084: PUSH
15085: LD_INT 1
15087: MINUS
15088: PUSH
15089: FOR_TO
15090: IFFALSE 15135
// begin tmp := tmp [ pos [ i ] ] ;
15092: LD_ADDR_VAR 0 6
15096: PUSH
15097: LD_VAR 0 6
15101: PUSH
15102: LD_VAR 0 2
15106: PUSH
15107: LD_VAR 0 5
15111: ARRAY
15112: ARRAY
15113: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15114: LD_ADDR_VAR 0 7
15118: PUSH
15119: LD_VAR 0 7
15123: PUSH
15124: LD_VAR 0 6
15128: PUSH
15129: EMPTY
15130: LIST
15131: ADD
15132: ST_TO_ADDR
// end ;
15133: GO 15089
15135: POP
15136: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15137: LD_ADDR_VAR 0 6
15141: PUSH
15142: LD_VAR 0 6
15146: PPUSH
15147: LD_VAR 0 2
15151: PUSH
15152: LD_VAR 0 2
15156: ARRAY
15157: PPUSH
15158: LD_VAR 0 3
15162: PPUSH
15163: CALL_OW 1
15167: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15168: LD_ADDR_VAR 0 7
15172: PUSH
15173: LD_VAR 0 7
15177: PPUSH
15178: LD_VAR 0 7
15182: PPUSH
15183: LD_VAR 0 6
15187: PPUSH
15188: CALL_OW 1
15192: ST_TO_ADDR
// for i = s_arr downto 2 do
15193: LD_ADDR_VAR 0 5
15197: PUSH
15198: DOUBLE
15199: LD_VAR 0 7
15203: INC
15204: ST_TO_ADDR
15205: LD_INT 2
15207: PUSH
15208: FOR_DOWNTO
15209: IFFALSE 15293
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15211: LD_ADDR_VAR 0 6
15215: PUSH
15216: LD_VAR 0 7
15220: PUSH
15221: LD_VAR 0 5
15225: PUSH
15226: LD_INT 1
15228: MINUS
15229: ARRAY
15230: PPUSH
15231: LD_VAR 0 2
15235: PUSH
15236: LD_VAR 0 5
15240: PUSH
15241: LD_INT 1
15243: MINUS
15244: ARRAY
15245: PPUSH
15246: LD_VAR 0 7
15250: PUSH
15251: LD_VAR 0 5
15255: ARRAY
15256: PPUSH
15257: CALL_OW 1
15261: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15262: LD_ADDR_VAR 0 7
15266: PUSH
15267: LD_VAR 0 7
15271: PPUSH
15272: LD_VAR 0 5
15276: PUSH
15277: LD_INT 1
15279: MINUS
15280: PPUSH
15281: LD_VAR 0 6
15285: PPUSH
15286: CALL_OW 1
15290: ST_TO_ADDR
// end ;
15291: GO 15208
15293: POP
15294: POP
// result := s_arr [ 1 ] ;
15295: LD_ADDR_VAR 0 4
15299: PUSH
15300: LD_VAR 0 7
15304: PUSH
15305: LD_INT 1
15307: ARRAY
15308: ST_TO_ADDR
// end ; end ;
15309: LD_VAR 0 4
15313: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15314: LD_INT 0
15316: PPUSH
15317: PPUSH
// if not list then
15318: LD_VAR 0 1
15322: NOT
15323: IFFALSE 15327
// exit ;
15325: GO 15418
// i := list [ pos1 ] ;
15327: LD_ADDR_VAR 0 5
15331: PUSH
15332: LD_VAR 0 1
15336: PUSH
15337: LD_VAR 0 2
15341: ARRAY
15342: ST_TO_ADDR
// if not i then
15343: LD_VAR 0 5
15347: NOT
15348: IFFALSE 15352
// exit ;
15350: GO 15418
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15352: LD_ADDR_VAR 0 1
15356: PUSH
15357: LD_VAR 0 1
15361: PPUSH
15362: LD_VAR 0 2
15366: PPUSH
15367: LD_VAR 0 1
15371: PUSH
15372: LD_VAR 0 3
15376: ARRAY
15377: PPUSH
15378: CALL_OW 1
15382: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15383: LD_ADDR_VAR 0 1
15387: PUSH
15388: LD_VAR 0 1
15392: PPUSH
15393: LD_VAR 0 3
15397: PPUSH
15398: LD_VAR 0 5
15402: PPUSH
15403: CALL_OW 1
15407: ST_TO_ADDR
// result := list ;
15408: LD_ADDR_VAR 0 4
15412: PUSH
15413: LD_VAR 0 1
15417: ST_TO_ADDR
// end ;
15418: LD_VAR 0 4
15422: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15423: LD_INT 0
15425: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15426: LD_ADDR_VAR 0 5
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 250
15440: PPUSH
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL_OW 251
15450: PPUSH
15451: LD_VAR 0 2
15455: PPUSH
15456: LD_VAR 0 3
15460: PPUSH
15461: LD_VAR 0 4
15465: PPUSH
15466: CALL 15476 0 5
15470: ST_TO_ADDR
// end ;
15471: LD_VAR 0 5
15475: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15476: LD_INT 0
15478: PPUSH
15479: PPUSH
15480: PPUSH
15481: PPUSH
// if not list then
15482: LD_VAR 0 3
15486: NOT
15487: IFFALSE 15491
// exit ;
15489: GO 15879
// result := [ ] ;
15491: LD_ADDR_VAR 0 6
15495: PUSH
15496: EMPTY
15497: ST_TO_ADDR
// for i in list do
15498: LD_ADDR_VAR 0 7
15502: PUSH
15503: LD_VAR 0 3
15507: PUSH
15508: FOR_IN
15509: IFFALSE 15711
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15511: LD_ADDR_VAR 0 9
15515: PUSH
15516: LD_VAR 0 7
15520: PPUSH
15521: LD_VAR 0 1
15525: PPUSH
15526: LD_VAR 0 2
15530: PPUSH
15531: CALL_OW 297
15535: ST_TO_ADDR
// if not result then
15536: LD_VAR 0 6
15540: NOT
15541: IFFALSE 15567
// result := [ [ i , tmp ] ] else
15543: LD_ADDR_VAR 0 6
15547: PUSH
15548: LD_VAR 0 7
15552: PUSH
15553: LD_VAR 0 9
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: EMPTY
15563: LIST
15564: ST_TO_ADDR
15565: GO 15709
// begin if result [ result ] [ 2 ] < tmp then
15567: LD_VAR 0 6
15571: PUSH
15572: LD_VAR 0 6
15576: ARRAY
15577: PUSH
15578: LD_INT 2
15580: ARRAY
15581: PUSH
15582: LD_VAR 0 9
15586: LESS
15587: IFFALSE 15629
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15589: LD_ADDR_VAR 0 6
15593: PUSH
15594: LD_VAR 0 6
15598: PPUSH
15599: LD_VAR 0 6
15603: PUSH
15604: LD_INT 1
15606: PLUS
15607: PPUSH
15608: LD_VAR 0 7
15612: PUSH
15613: LD_VAR 0 9
15617: PUSH
15618: EMPTY
15619: LIST
15620: LIST
15621: PPUSH
15622: CALL_OW 2
15626: ST_TO_ADDR
15627: GO 15709
// for j = 1 to result do
15629: LD_ADDR_VAR 0 8
15633: PUSH
15634: DOUBLE
15635: LD_INT 1
15637: DEC
15638: ST_TO_ADDR
15639: LD_VAR 0 6
15643: PUSH
15644: FOR_TO
15645: IFFALSE 15707
// begin if tmp < result [ j ] [ 2 ] then
15647: LD_VAR 0 9
15651: PUSH
15652: LD_VAR 0 6
15656: PUSH
15657: LD_VAR 0 8
15661: ARRAY
15662: PUSH
15663: LD_INT 2
15665: ARRAY
15666: LESS
15667: IFFALSE 15705
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15669: LD_ADDR_VAR 0 6
15673: PUSH
15674: LD_VAR 0 6
15678: PPUSH
15679: LD_VAR 0 8
15683: PPUSH
15684: LD_VAR 0 7
15688: PUSH
15689: LD_VAR 0 9
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PPUSH
15698: CALL_OW 2
15702: ST_TO_ADDR
// break ;
15703: GO 15707
// end ; end ;
15705: GO 15644
15707: POP
15708: POP
// end ; end ;
15709: GO 15508
15711: POP
15712: POP
// if result and not asc then
15713: LD_VAR 0 6
15717: PUSH
15718: LD_VAR 0 4
15722: NOT
15723: AND
15724: IFFALSE 15799
// begin tmp := result ;
15726: LD_ADDR_VAR 0 9
15730: PUSH
15731: LD_VAR 0 6
15735: ST_TO_ADDR
// for i = tmp downto 1 do
15736: LD_ADDR_VAR 0 7
15740: PUSH
15741: DOUBLE
15742: LD_VAR 0 9
15746: INC
15747: ST_TO_ADDR
15748: LD_INT 1
15750: PUSH
15751: FOR_DOWNTO
15752: IFFALSE 15797
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15754: LD_ADDR_VAR 0 6
15758: PUSH
15759: LD_VAR 0 6
15763: PPUSH
15764: LD_VAR 0 9
15768: PUSH
15769: LD_VAR 0 7
15773: MINUS
15774: PUSH
15775: LD_INT 1
15777: PLUS
15778: PPUSH
15779: LD_VAR 0 9
15783: PUSH
15784: LD_VAR 0 7
15788: ARRAY
15789: PPUSH
15790: CALL_OW 1
15794: ST_TO_ADDR
15795: GO 15751
15797: POP
15798: POP
// end ; tmp := [ ] ;
15799: LD_ADDR_VAR 0 9
15803: PUSH
15804: EMPTY
15805: ST_TO_ADDR
// if mode then
15806: LD_VAR 0 5
15810: IFFALSE 15879
// begin for i = 1 to result do
15812: LD_ADDR_VAR 0 7
15816: PUSH
15817: DOUBLE
15818: LD_INT 1
15820: DEC
15821: ST_TO_ADDR
15822: LD_VAR 0 6
15826: PUSH
15827: FOR_TO
15828: IFFALSE 15867
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15830: LD_ADDR_VAR 0 9
15834: PUSH
15835: LD_VAR 0 9
15839: PPUSH
15840: LD_VAR 0 7
15844: PPUSH
15845: LD_VAR 0 6
15849: PUSH
15850: LD_VAR 0 7
15854: ARRAY
15855: PUSH
15856: LD_INT 1
15858: ARRAY
15859: PPUSH
15860: CALL_OW 1
15864: ST_TO_ADDR
15865: GO 15827
15867: POP
15868: POP
// result := tmp ;
15869: LD_ADDR_VAR 0 6
15873: PUSH
15874: LD_VAR 0 9
15878: ST_TO_ADDR
// end ; end ;
15879: LD_VAR 0 6
15883: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15884: LD_INT 0
15886: PPUSH
15887: PPUSH
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15892: LD_ADDR_VAR 0 5
15896: PUSH
15897: LD_INT 0
15899: PUSH
15900: LD_INT 0
15902: PUSH
15903: LD_INT 0
15905: PUSH
15906: EMPTY
15907: PUSH
15908: EMPTY
15909: LIST
15910: LIST
15911: LIST
15912: LIST
15913: ST_TO_ADDR
// if not x or not y then
15914: LD_VAR 0 2
15918: NOT
15919: PUSH
15920: LD_VAR 0 3
15924: NOT
15925: OR
15926: IFFALSE 15930
// exit ;
15928: GO 17580
// if not range then
15930: LD_VAR 0 4
15934: NOT
15935: IFFALSE 15945
// range := 10 ;
15937: LD_ADDR_VAR 0 4
15941: PUSH
15942: LD_INT 10
15944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_INT 81
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: EMPTY
15959: LIST
15960: LIST
15961: PUSH
15962: LD_INT 92
15964: PUSH
15965: LD_VAR 0 2
15969: PUSH
15970: LD_VAR 0 3
15974: PUSH
15975: LD_VAR 0 4
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 3
15988: PUSH
15989: LD_INT 21
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PUSH
16003: EMPTY
16004: LIST
16005: LIST
16006: LIST
16007: PPUSH
16008: CALL_OW 69
16012: ST_TO_ADDR
// if not tmp then
16013: LD_VAR 0 8
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 17580
// for i in tmp do
16022: LD_ADDR_VAR 0 6
16026: PUSH
16027: LD_VAR 0 8
16031: PUSH
16032: FOR_IN
16033: IFFALSE 17555
// begin points := [ 0 , 0 , 0 ] ;
16035: LD_ADDR_VAR 0 9
16039: PUSH
16040: LD_INT 0
16042: PUSH
16043: LD_INT 0
16045: PUSH
16046: LD_INT 0
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: LIST
16053: ST_TO_ADDR
// bpoints := 1 ;
16054: LD_ADDR_VAR 0 10
16058: PUSH
16059: LD_INT 1
16061: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16062: LD_VAR 0 6
16066: PPUSH
16067: CALL_OW 247
16071: PUSH
16072: LD_INT 1
16074: DOUBLE
16075: EQUAL
16076: IFTRUE 16080
16078: GO 16658
16080: POP
// begin if GetClass ( i ) = 1 then
16081: LD_VAR 0 6
16085: PPUSH
16086: CALL_OW 257
16090: PUSH
16091: LD_INT 1
16093: EQUAL
16094: IFFALSE 16115
// points := [ 10 , 5 , 3 ] ;
16096: LD_ADDR_VAR 0 9
16100: PUSH
16101: LD_INT 10
16103: PUSH
16104: LD_INT 5
16106: PUSH
16107: LD_INT 3
16109: PUSH
16110: EMPTY
16111: LIST
16112: LIST
16113: LIST
16114: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16115: LD_VAR 0 6
16119: PPUSH
16120: CALL_OW 257
16124: PUSH
16125: LD_INT 2
16127: PUSH
16128: LD_INT 3
16130: PUSH
16131: LD_INT 4
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: LIST
16138: IN
16139: IFFALSE 16160
// points := [ 3 , 2 , 1 ] ;
16141: LD_ADDR_VAR 0 9
16145: PUSH
16146: LD_INT 3
16148: PUSH
16149: LD_INT 2
16151: PUSH
16152: LD_INT 1
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: LIST
16159: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16160: LD_VAR 0 6
16164: PPUSH
16165: CALL_OW 257
16169: PUSH
16170: LD_INT 5
16172: EQUAL
16173: IFFALSE 16194
// points := [ 130 , 5 , 2 ] ;
16175: LD_ADDR_VAR 0 9
16179: PUSH
16180: LD_INT 130
16182: PUSH
16183: LD_INT 5
16185: PUSH
16186: LD_INT 2
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: LIST
16193: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16194: LD_VAR 0 6
16198: PPUSH
16199: CALL_OW 257
16203: PUSH
16204: LD_INT 8
16206: EQUAL
16207: IFFALSE 16228
// points := [ 35 , 35 , 30 ] ;
16209: LD_ADDR_VAR 0 9
16213: PUSH
16214: LD_INT 35
16216: PUSH
16217: LD_INT 35
16219: PUSH
16220: LD_INT 30
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: LIST
16227: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16228: LD_VAR 0 6
16232: PPUSH
16233: CALL_OW 257
16237: PUSH
16238: LD_INT 9
16240: EQUAL
16241: IFFALSE 16262
// points := [ 20 , 55 , 40 ] ;
16243: LD_ADDR_VAR 0 9
16247: PUSH
16248: LD_INT 20
16250: PUSH
16251: LD_INT 55
16253: PUSH
16254: LD_INT 40
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: LIST
16261: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16262: LD_VAR 0 6
16266: PPUSH
16267: CALL_OW 257
16271: PUSH
16272: LD_INT 12
16274: PUSH
16275: LD_INT 16
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: IN
16282: IFFALSE 16303
// points := [ 5 , 3 , 2 ] ;
16284: LD_ADDR_VAR 0 9
16288: PUSH
16289: LD_INT 5
16291: PUSH
16292: LD_INT 3
16294: PUSH
16295: LD_INT 2
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: LIST
16302: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16303: LD_VAR 0 6
16307: PPUSH
16308: CALL_OW 257
16312: PUSH
16313: LD_INT 17
16315: EQUAL
16316: IFFALSE 16337
// points := [ 100 , 50 , 75 ] ;
16318: LD_ADDR_VAR 0 9
16322: PUSH
16323: LD_INT 100
16325: PUSH
16326: LD_INT 50
16328: PUSH
16329: LD_INT 75
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: LIST
16336: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16337: LD_VAR 0 6
16341: PPUSH
16342: CALL_OW 257
16346: PUSH
16347: LD_INT 15
16349: EQUAL
16350: IFFALSE 16371
// points := [ 10 , 5 , 3 ] ;
16352: LD_ADDR_VAR 0 9
16356: PUSH
16357: LD_INT 10
16359: PUSH
16360: LD_INT 5
16362: PUSH
16363: LD_INT 3
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: LIST
16370: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16371: LD_VAR 0 6
16375: PPUSH
16376: CALL_OW 257
16380: PUSH
16381: LD_INT 14
16383: EQUAL
16384: IFFALSE 16405
// points := [ 10 , 0 , 0 ] ;
16386: LD_ADDR_VAR 0 9
16390: PUSH
16391: LD_INT 10
16393: PUSH
16394: LD_INT 0
16396: PUSH
16397: LD_INT 0
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16405: LD_VAR 0 6
16409: PPUSH
16410: CALL_OW 257
16414: PUSH
16415: LD_INT 11
16417: EQUAL
16418: IFFALSE 16439
// points := [ 30 , 10 , 5 ] ;
16420: LD_ADDR_VAR 0 9
16424: PUSH
16425: LD_INT 30
16427: PUSH
16428: LD_INT 10
16430: PUSH
16431: LD_INT 5
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: LIST
16438: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16439: LD_VAR 0 1
16443: PPUSH
16444: LD_INT 5
16446: PPUSH
16447: CALL_OW 321
16451: PUSH
16452: LD_INT 2
16454: EQUAL
16455: IFFALSE 16472
// bpoints := bpoints * 1.8 ;
16457: LD_ADDR_VAR 0 10
16461: PUSH
16462: LD_VAR 0 10
16466: PUSH
16467: LD_REAL  1.80000000000000E+0000
16470: MUL
16471: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16472: LD_VAR 0 6
16476: PPUSH
16477: CALL_OW 257
16481: PUSH
16482: LD_INT 1
16484: PUSH
16485: LD_INT 2
16487: PUSH
16488: LD_INT 3
16490: PUSH
16491: LD_INT 4
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: PUSH
16501: LD_VAR 0 1
16505: PPUSH
16506: LD_INT 51
16508: PPUSH
16509: CALL_OW 321
16513: PUSH
16514: LD_INT 2
16516: EQUAL
16517: AND
16518: IFFALSE 16535
// bpoints := bpoints * 1.2 ;
16520: LD_ADDR_VAR 0 10
16524: PUSH
16525: LD_VAR 0 10
16529: PUSH
16530: LD_REAL  1.20000000000000E+0000
16533: MUL
16534: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16535: LD_VAR 0 6
16539: PPUSH
16540: CALL_OW 257
16544: PUSH
16545: LD_INT 5
16547: PUSH
16548: LD_INT 7
16550: PUSH
16551: LD_INT 9
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: LIST
16558: IN
16559: PUSH
16560: LD_VAR 0 1
16564: PPUSH
16565: LD_INT 52
16567: PPUSH
16568: CALL_OW 321
16572: PUSH
16573: LD_INT 2
16575: EQUAL
16576: AND
16577: IFFALSE 16594
// bpoints := bpoints * 1.5 ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PUSH
16589: LD_REAL  1.50000000000000E+0000
16592: MUL
16593: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16594: LD_VAR 0 1
16598: PPUSH
16599: LD_INT 66
16601: PPUSH
16602: CALL_OW 321
16606: PUSH
16607: LD_INT 2
16609: EQUAL
16610: IFFALSE 16627
// bpoints := bpoints * 1.1 ;
16612: LD_ADDR_VAR 0 10
16616: PUSH
16617: LD_VAR 0 10
16621: PUSH
16622: LD_REAL  1.10000000000000E+0000
16625: MUL
16626: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16627: LD_ADDR_VAR 0 10
16631: PUSH
16632: LD_VAR 0 10
16636: PUSH
16637: LD_VAR 0 6
16641: PPUSH
16642: LD_INT 1
16644: PPUSH
16645: CALL_OW 259
16649: PUSH
16650: LD_REAL  1.15000000000000E+0000
16653: MUL
16654: MUL
16655: ST_TO_ADDR
// end ; unit_vehicle :
16656: GO 17484
16658: LD_INT 2
16660: DOUBLE
16661: EQUAL
16662: IFTRUE 16666
16664: GO 17472
16666: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16667: LD_VAR 0 6
16671: PPUSH
16672: CALL_OW 264
16676: PUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 42
16682: PUSH
16683: LD_INT 24
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: LIST
16690: IN
16691: IFFALSE 16712
// points := [ 25 , 5 , 3 ] ;
16693: LD_ADDR_VAR 0 9
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 5
16703: PUSH
16704: LD_INT 3
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16712: LD_VAR 0 6
16716: PPUSH
16717: CALL_OW 264
16721: PUSH
16722: LD_INT 4
16724: PUSH
16725: LD_INT 43
16727: PUSH
16728: LD_INT 25
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: LIST
16735: IN
16736: IFFALSE 16757
// points := [ 40 , 15 , 5 ] ;
16738: LD_ADDR_VAR 0 9
16742: PUSH
16743: LD_INT 40
16745: PUSH
16746: LD_INT 15
16748: PUSH
16749: LD_INT 5
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: LIST
16756: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16757: LD_VAR 0 6
16761: PPUSH
16762: CALL_OW 264
16766: PUSH
16767: LD_INT 3
16769: PUSH
16770: LD_INT 23
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: IN
16777: IFFALSE 16798
// points := [ 7 , 25 , 8 ] ;
16779: LD_ADDR_VAR 0 9
16783: PUSH
16784: LD_INT 7
16786: PUSH
16787: LD_INT 25
16789: PUSH
16790: LD_INT 8
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: LIST
16797: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16798: LD_VAR 0 6
16802: PPUSH
16803: CALL_OW 264
16807: PUSH
16808: LD_INT 5
16810: PUSH
16811: LD_INT 27
16813: PUSH
16814: LD_INT 44
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: LIST
16821: IN
16822: IFFALSE 16843
// points := [ 14 , 50 , 16 ] ;
16824: LD_ADDR_VAR 0 9
16828: PUSH
16829: LD_INT 14
16831: PUSH
16832: LD_INT 50
16834: PUSH
16835: LD_INT 16
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16843: LD_VAR 0 6
16847: PPUSH
16848: CALL_OW 264
16852: PUSH
16853: LD_INT 6
16855: PUSH
16856: LD_INT 46
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: IN
16863: IFFALSE 16884
// points := [ 32 , 120 , 70 ] ;
16865: LD_ADDR_VAR 0 9
16869: PUSH
16870: LD_INT 32
16872: PUSH
16873: LD_INT 120
16875: PUSH
16876: LD_INT 70
16878: PUSH
16879: EMPTY
16880: LIST
16881: LIST
16882: LIST
16883: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16884: LD_VAR 0 6
16888: PPUSH
16889: CALL_OW 264
16893: PUSH
16894: LD_INT 7
16896: PUSH
16897: LD_INT 28
16899: PUSH
16900: LD_INT 45
16902: PUSH
16903: LD_INT 92
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: IN
16912: IFFALSE 16933
// points := [ 35 , 20 , 45 ] ;
16914: LD_ADDR_VAR 0 9
16918: PUSH
16919: LD_INT 35
16921: PUSH
16922: LD_INT 20
16924: PUSH
16925: LD_INT 45
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: LIST
16932: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16933: LD_VAR 0 6
16937: PPUSH
16938: CALL_OW 264
16942: PUSH
16943: LD_INT 47
16945: PUSH
16946: EMPTY
16947: LIST
16948: IN
16949: IFFALSE 16970
// points := [ 67 , 45 , 75 ] ;
16951: LD_ADDR_VAR 0 9
16955: PUSH
16956: LD_INT 67
16958: PUSH
16959: LD_INT 45
16961: PUSH
16962: LD_INT 75
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: LIST
16969: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16970: LD_VAR 0 6
16974: PPUSH
16975: CALL_OW 264
16979: PUSH
16980: LD_INT 26
16982: PUSH
16983: EMPTY
16984: LIST
16985: IN
16986: IFFALSE 17007
// points := [ 120 , 30 , 80 ] ;
16988: LD_ADDR_VAR 0 9
16992: PUSH
16993: LD_INT 120
16995: PUSH
16996: LD_INT 30
16998: PUSH
16999: LD_INT 80
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: LIST
17006: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17007: LD_VAR 0 6
17011: PPUSH
17012: CALL_OW 264
17016: PUSH
17017: LD_INT 22
17019: PUSH
17020: EMPTY
17021: LIST
17022: IN
17023: IFFALSE 17044
// points := [ 40 , 1 , 1 ] ;
17025: LD_ADDR_VAR 0 9
17029: PUSH
17030: LD_INT 40
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: LIST
17043: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17044: LD_VAR 0 6
17048: PPUSH
17049: CALL_OW 264
17053: PUSH
17054: LD_INT 29
17056: PUSH
17057: EMPTY
17058: LIST
17059: IN
17060: IFFALSE 17081
// points := [ 70 , 200 , 400 ] ;
17062: LD_ADDR_VAR 0 9
17066: PUSH
17067: LD_INT 70
17069: PUSH
17070: LD_INT 200
17072: PUSH
17073: LD_INT 400
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17081: LD_VAR 0 6
17085: PPUSH
17086: CALL_OW 264
17090: PUSH
17091: LD_INT 14
17093: PUSH
17094: LD_INT 53
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: IN
17101: IFFALSE 17122
// points := [ 40 , 10 , 20 ] ;
17103: LD_ADDR_VAR 0 9
17107: PUSH
17108: LD_INT 40
17110: PUSH
17111: LD_INT 10
17113: PUSH
17114: LD_INT 20
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: LIST
17121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17122: LD_VAR 0 6
17126: PPUSH
17127: CALL_OW 264
17131: PUSH
17132: LD_INT 9
17134: PUSH
17135: EMPTY
17136: LIST
17137: IN
17138: IFFALSE 17159
// points := [ 5 , 70 , 20 ] ;
17140: LD_ADDR_VAR 0 9
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: LD_INT 70
17150: PUSH
17151: LD_INT 20
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: LIST
17158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 264
17168: PUSH
17169: LD_INT 10
17171: PUSH
17172: EMPTY
17173: LIST
17174: IN
17175: IFFALSE 17196
// points := [ 35 , 110 , 70 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 35
17184: PUSH
17185: LD_INT 110
17187: PUSH
17188: LD_INT 70
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 265
17205: PUSH
17206: LD_INT 25
17208: EQUAL
17209: IFFALSE 17230
// points := [ 80 , 65 , 100 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 80
17218: PUSH
17219: LD_INT 65
17221: PUSH
17222: LD_INT 100
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 263
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: IFFALSE 17278
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17245: LD_ADDR_VAR 0 10
17249: PUSH
17250: LD_VAR 0 10
17254: PUSH
17255: LD_VAR 0 6
17259: PPUSH
17260: CALL_OW 311
17264: PPUSH
17265: LD_INT 3
17267: PPUSH
17268: CALL_OW 259
17272: PUSH
17273: LD_INT 4
17275: MUL
17276: MUL
17277: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17278: LD_VAR 0 6
17282: PPUSH
17283: CALL_OW 263
17287: PUSH
17288: LD_INT 2
17290: EQUAL
17291: IFFALSE 17342
// begin j := IsControledBy ( i ) ;
17293: LD_ADDR_VAR 0 7
17297: PUSH
17298: LD_VAR 0 6
17302: PPUSH
17303: CALL_OW 312
17307: ST_TO_ADDR
// if j then
17308: LD_VAR 0 7
17312: IFFALSE 17342
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17314: LD_ADDR_VAR 0 10
17318: PUSH
17319: LD_VAR 0 10
17323: PUSH
17324: LD_VAR 0 7
17328: PPUSH
17329: LD_INT 3
17331: PPUSH
17332: CALL_OW 259
17336: PUSH
17337: LD_INT 3
17339: MUL
17340: MUL
17341: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17342: LD_VAR 0 6
17346: PPUSH
17347: CALL_OW 264
17351: PUSH
17352: LD_INT 5
17354: PUSH
17355: LD_INT 6
17357: PUSH
17358: LD_INT 46
17360: PUSH
17361: LD_INT 44
17363: PUSH
17364: LD_INT 47
17366: PUSH
17367: LD_INT 45
17369: PUSH
17370: LD_INT 28
17372: PUSH
17373: LD_INT 7
17375: PUSH
17376: LD_INT 27
17378: PUSH
17379: LD_INT 29
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: IN
17394: PUSH
17395: LD_VAR 0 1
17399: PPUSH
17400: LD_INT 52
17402: PPUSH
17403: CALL_OW 321
17407: PUSH
17408: LD_INT 2
17410: EQUAL
17411: AND
17412: IFFALSE 17429
// bpoints := bpoints * 1.2 ;
17414: LD_ADDR_VAR 0 10
17418: PUSH
17419: LD_VAR 0 10
17423: PUSH
17424: LD_REAL  1.20000000000000E+0000
17427: MUL
17428: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17429: LD_VAR 0 6
17433: PPUSH
17434: CALL_OW 264
17438: PUSH
17439: LD_INT 6
17441: PUSH
17442: LD_INT 46
17444: PUSH
17445: LD_INT 47
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: IN
17453: IFFALSE 17470
// bpoints := bpoints * 1.2 ;
17455: LD_ADDR_VAR 0 10
17459: PUSH
17460: LD_VAR 0 10
17464: PUSH
17465: LD_REAL  1.20000000000000E+0000
17468: MUL
17469: ST_TO_ADDR
// end ; unit_building :
17470: GO 17484
17472: LD_INT 3
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17483
17480: POP
// ; end ;
17481: GO 17484
17483: POP
// for j = 1 to 3 do
17484: LD_ADDR_VAR 0 7
17488: PUSH
17489: DOUBLE
17490: LD_INT 1
17492: DEC
17493: ST_TO_ADDR
17494: LD_INT 3
17496: PUSH
17497: FOR_TO
17498: IFFALSE 17551
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17500: LD_ADDR_VAR 0 5
17504: PUSH
17505: LD_VAR 0 5
17509: PPUSH
17510: LD_VAR 0 7
17514: PPUSH
17515: LD_VAR 0 5
17519: PUSH
17520: LD_VAR 0 7
17524: ARRAY
17525: PUSH
17526: LD_VAR 0 9
17530: PUSH
17531: LD_VAR 0 7
17535: ARRAY
17536: PUSH
17537: LD_VAR 0 10
17541: MUL
17542: PLUS
17543: PPUSH
17544: CALL_OW 1
17548: ST_TO_ADDR
17549: GO 17497
17551: POP
17552: POP
// end ;
17553: GO 16032
17555: POP
17556: POP
// result := Replace ( result , 4 , tmp ) ;
17557: LD_ADDR_VAR 0 5
17561: PUSH
17562: LD_VAR 0 5
17566: PPUSH
17567: LD_INT 4
17569: PPUSH
17570: LD_VAR 0 8
17574: PPUSH
17575: CALL_OW 1
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 5
17584: RET
// export function DangerAtRange ( unit , range ) ; begin
17585: LD_INT 0
17587: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17588: LD_ADDR_VAR 0 3
17592: PUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: CALL_OW 255
17602: PPUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 250
17612: PPUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL_OW 251
17622: PPUSH
17623: LD_VAR 0 2
17627: PPUSH
17628: CALL 15884 0 4
17632: ST_TO_ADDR
// end ;
17633: LD_VAR 0 3
17637: RET
// export function DangerInArea ( side , area ) ; begin
17638: LD_INT 0
17640: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17641: LD_ADDR_VAR 0 3
17645: PUSH
17646: LD_VAR 0 2
17650: PPUSH
17651: LD_INT 81
17653: PUSH
17654: LD_VAR 0 1
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: PPUSH
17663: CALL_OW 70
17667: ST_TO_ADDR
// end ;
17668: LD_VAR 0 3
17672: RET
// export function IsExtension ( b ) ; begin
17673: LD_INT 0
17675: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17676: LD_ADDR_VAR 0 2
17680: PUSH
17681: LD_VAR 0 1
17685: PUSH
17686: LD_INT 23
17688: PUSH
17689: LD_INT 20
17691: PUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 17
17697: PUSH
17698: LD_INT 24
17700: PUSH
17701: LD_INT 21
17703: PUSH
17704: LD_INT 19
17706: PUSH
17707: LD_INT 16
17709: PUSH
17710: LD_INT 25
17712: PUSH
17713: LD_INT 18
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: IN
17728: ST_TO_ADDR
// end ;
17729: LD_VAR 0 2
17733: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17734: LD_INT 0
17736: PPUSH
17737: PPUSH
17738: PPUSH
// result := [ ] ;
17739: LD_ADDR_VAR 0 4
17743: PUSH
17744: EMPTY
17745: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17746: LD_ADDR_VAR 0 5
17750: PUSH
17751: LD_VAR 0 2
17755: PPUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 3
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PPUSH
17766: CALL_OW 70
17770: ST_TO_ADDR
// if not tmp then
17771: LD_VAR 0 5
17775: NOT
17776: IFFALSE 17780
// exit ;
17778: GO 17844
// if checkLink then
17780: LD_VAR 0 3
17784: IFFALSE 17834
// begin for i in tmp do
17786: LD_ADDR_VAR 0 6
17790: PUSH
17791: LD_VAR 0 5
17795: PUSH
17796: FOR_IN
17797: IFFALSE 17832
// if GetBase ( i ) <> base then
17799: LD_VAR 0 6
17803: PPUSH
17804: CALL_OW 274
17808: PUSH
17809: LD_VAR 0 1
17813: NONEQUAL
17814: IFFALSE 17830
// ComLinkToBase ( base , i ) ;
17816: LD_VAR 0 1
17820: PPUSH
17821: LD_VAR 0 6
17825: PPUSH
17826: CALL_OW 169
17830: GO 17796
17832: POP
17833: POP
// end ; result := tmp ;
17834: LD_ADDR_VAR 0 4
17838: PUSH
17839: LD_VAR 0 5
17843: ST_TO_ADDR
// end ;
17844: LD_VAR 0 4
17848: RET
// export function ComComplete ( units , b ) ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// if not units then
17853: LD_VAR 0 1
17857: NOT
17858: IFFALSE 17862
// exit ;
17860: GO 17952
// for i in units do
17862: LD_ADDR_VAR 0 4
17866: PUSH
17867: LD_VAR 0 1
17871: PUSH
17872: FOR_IN
17873: IFFALSE 17950
// if BuildingStatus ( b ) = bs_build then
17875: LD_VAR 0 2
17879: PPUSH
17880: CALL_OW 461
17884: PUSH
17885: LD_INT 1
17887: EQUAL
17888: IFFALSE 17948
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17890: LD_VAR 0 4
17894: PPUSH
17895: LD_STRING h
17897: PUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: CALL_OW 250
17907: PUSH
17908: LD_VAR 0 2
17912: PPUSH
17913: CALL_OW 251
17917: PUSH
17918: LD_VAR 0 2
17922: PUSH
17923: LD_INT 0
17925: PUSH
17926: LD_INT 0
17928: PUSH
17929: LD_INT 0
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: PUSH
17941: EMPTY
17942: LIST
17943: PPUSH
17944: CALL_OW 446
17948: GO 17872
17950: POP
17951: POP
// end ;
17952: LD_VAR 0 3
17956: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17957: LD_INT 0
17959: PPUSH
17960: PPUSH
17961: PPUSH
17962: PPUSH
17963: PPUSH
17964: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17965: LD_VAR 0 1
17969: NOT
17970: PUSH
17971: LD_VAR 0 1
17975: PPUSH
17976: CALL_OW 263
17980: PUSH
17981: LD_INT 2
17983: NONEQUAL
17984: OR
17985: IFFALSE 17989
// exit ;
17987: GO 18305
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17989: LD_ADDR_VAR 0 6
17993: PUSH
17994: LD_INT 22
17996: PUSH
17997: LD_VAR 0 1
18001: PPUSH
18002: CALL_OW 255
18006: PUSH
18007: EMPTY
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 2
18013: PUSH
18014: LD_INT 30
18016: PUSH
18017: LD_INT 36
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: PUSH
18024: LD_INT 34
18026: PUSH
18027: LD_INT 31
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: PPUSH
18043: CALL_OW 69
18047: ST_TO_ADDR
// if not tmp then
18048: LD_VAR 0 6
18052: NOT
18053: IFFALSE 18057
// exit ;
18055: GO 18305
// result := [ ] ;
18057: LD_ADDR_VAR 0 2
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// for i in tmp do
18064: LD_ADDR_VAR 0 3
18068: PUSH
18069: LD_VAR 0 6
18073: PUSH
18074: FOR_IN
18075: IFFALSE 18146
// begin t := UnitsInside ( i ) ;
18077: LD_ADDR_VAR 0 4
18081: PUSH
18082: LD_VAR 0 3
18086: PPUSH
18087: CALL_OW 313
18091: ST_TO_ADDR
// if t then
18092: LD_VAR 0 4
18096: IFFALSE 18144
// for j in t do
18098: LD_ADDR_VAR 0 7
18102: PUSH
18103: LD_VAR 0 4
18107: PUSH
18108: FOR_IN
18109: IFFALSE 18142
// result := Replace ( result , result + 1 , j ) ;
18111: LD_ADDR_VAR 0 2
18115: PUSH
18116: LD_VAR 0 2
18120: PPUSH
18121: LD_VAR 0 2
18125: PUSH
18126: LD_INT 1
18128: PLUS
18129: PPUSH
18130: LD_VAR 0 7
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
18140: GO 18108
18142: POP
18143: POP
// end ;
18144: GO 18074
18146: POP
18147: POP
// if not result then
18148: LD_VAR 0 2
18152: NOT
18153: IFFALSE 18157
// exit ;
18155: GO 18305
// mech := result [ 1 ] ;
18157: LD_ADDR_VAR 0 5
18161: PUSH
18162: LD_VAR 0 2
18166: PUSH
18167: LD_INT 1
18169: ARRAY
18170: ST_TO_ADDR
// if result > 1 then
18171: LD_VAR 0 2
18175: PUSH
18176: LD_INT 1
18178: GREATER
18179: IFFALSE 18291
// begin for i = 2 to result do
18181: LD_ADDR_VAR 0 3
18185: PUSH
18186: DOUBLE
18187: LD_INT 2
18189: DEC
18190: ST_TO_ADDR
18191: LD_VAR 0 2
18195: PUSH
18196: FOR_TO
18197: IFFALSE 18289
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18199: LD_ADDR_VAR 0 4
18203: PUSH
18204: LD_VAR 0 2
18208: PUSH
18209: LD_VAR 0 3
18213: ARRAY
18214: PPUSH
18215: LD_INT 3
18217: PPUSH
18218: CALL_OW 259
18222: PUSH
18223: LD_VAR 0 2
18227: PUSH
18228: LD_VAR 0 3
18232: ARRAY
18233: PPUSH
18234: CALL_OW 432
18238: MINUS
18239: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18240: LD_VAR 0 4
18244: PUSH
18245: LD_VAR 0 5
18249: PPUSH
18250: LD_INT 3
18252: PPUSH
18253: CALL_OW 259
18257: PUSH
18258: LD_VAR 0 5
18262: PPUSH
18263: CALL_OW 432
18267: MINUS
18268: GREATEREQUAL
18269: IFFALSE 18287
// mech := result [ i ] ;
18271: LD_ADDR_VAR 0 5
18275: PUSH
18276: LD_VAR 0 2
18280: PUSH
18281: LD_VAR 0 3
18285: ARRAY
18286: ST_TO_ADDR
// end ;
18287: GO 18196
18289: POP
18290: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18291: LD_VAR 0 1
18295: PPUSH
18296: LD_VAR 0 5
18300: PPUSH
18301: CALL_OW 135
// end ;
18305: LD_VAR 0 2
18309: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18310: LD_INT 0
18312: PPUSH
18313: PPUSH
18314: PPUSH
18315: PPUSH
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
// result := [ ] ;
18325: LD_ADDR_VAR 0 7
18329: PUSH
18330: EMPTY
18331: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18332: LD_VAR 0 1
18336: PPUSH
18337: CALL_OW 266
18341: PUSH
18342: LD_INT 0
18344: PUSH
18345: LD_INT 1
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: IN
18352: NOT
18353: IFFALSE 18357
// exit ;
18355: GO 19991
// if name then
18357: LD_VAR 0 3
18361: IFFALSE 18377
// SetBName ( base_dep , name ) ;
18363: LD_VAR 0 1
18367: PPUSH
18368: LD_VAR 0 3
18372: PPUSH
18373: CALL_OW 500
// base := GetBase ( base_dep ) ;
18377: LD_ADDR_VAR 0 15
18381: PUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 274
18391: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18392: LD_ADDR_VAR 0 16
18396: PUSH
18397: LD_VAR 0 1
18401: PPUSH
18402: CALL_OW 255
18406: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18407: LD_ADDR_VAR 0 17
18411: PUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: CALL_OW 248
18421: ST_TO_ADDR
// if sources then
18422: LD_VAR 0 5
18426: IFFALSE 18473
// for i = 1 to 3 do
18428: LD_ADDR_VAR 0 8
18432: PUSH
18433: DOUBLE
18434: LD_INT 1
18436: DEC
18437: ST_TO_ADDR
18438: LD_INT 3
18440: PUSH
18441: FOR_TO
18442: IFFALSE 18471
// AddResourceType ( base , i , sources [ i ] ) ;
18444: LD_VAR 0 15
18448: PPUSH
18449: LD_VAR 0 8
18453: PPUSH
18454: LD_VAR 0 5
18458: PUSH
18459: LD_VAR 0 8
18463: ARRAY
18464: PPUSH
18465: CALL_OW 276
18469: GO 18441
18471: POP
18472: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18473: LD_ADDR_VAR 0 18
18477: PUSH
18478: LD_VAR 0 15
18482: PPUSH
18483: LD_VAR 0 2
18487: PPUSH
18488: LD_INT 1
18490: PPUSH
18491: CALL 17734 0 3
18495: ST_TO_ADDR
// InitHc ;
18496: CALL_OW 19
// InitUc ;
18500: CALL_OW 18
// uc_side := side ;
18504: LD_ADDR_OWVAR 20
18508: PUSH
18509: LD_VAR 0 16
18513: ST_TO_ADDR
// uc_nation := nation ;
18514: LD_ADDR_OWVAR 21
18518: PUSH
18519: LD_VAR 0 17
18523: ST_TO_ADDR
// if buildings then
18524: LD_VAR 0 18
18528: IFFALSE 19850
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18530: LD_ADDR_VAR 0 19
18534: PUSH
18535: LD_VAR 0 18
18539: PPUSH
18540: LD_INT 2
18542: PUSH
18543: LD_INT 30
18545: PUSH
18546: LD_INT 29
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: LD_INT 30
18555: PUSH
18556: LD_INT 30
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: LIST
18567: PPUSH
18568: CALL_OW 72
18572: ST_TO_ADDR
// if tmp then
18573: LD_VAR 0 19
18577: IFFALSE 18625
// for i in tmp do
18579: LD_ADDR_VAR 0 8
18583: PUSH
18584: LD_VAR 0 19
18588: PUSH
18589: FOR_IN
18590: IFFALSE 18623
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18592: LD_VAR 0 8
18596: PPUSH
18597: CALL_OW 250
18601: PPUSH
18602: LD_VAR 0 8
18606: PPUSH
18607: CALL_OW 251
18611: PPUSH
18612: LD_VAR 0 16
18616: PPUSH
18617: CALL_OW 441
18621: GO 18589
18623: POP
18624: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18625: LD_VAR 0 18
18629: PPUSH
18630: LD_INT 2
18632: PUSH
18633: LD_INT 30
18635: PUSH
18636: LD_INT 32
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: PUSH
18643: LD_INT 30
18645: PUSH
18646: LD_INT 33
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: PPUSH
18658: CALL_OW 72
18662: IFFALSE 18750
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18664: LD_ADDR_VAR 0 8
18668: PUSH
18669: LD_VAR 0 18
18673: PPUSH
18674: LD_INT 2
18676: PUSH
18677: LD_INT 30
18679: PUSH
18680: LD_INT 32
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: LD_INT 30
18689: PUSH
18690: LD_INT 33
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: LIST
18701: PPUSH
18702: CALL_OW 72
18706: PUSH
18707: FOR_IN
18708: IFFALSE 18748
// begin if not GetBWeapon ( i ) then
18710: LD_VAR 0 8
18714: PPUSH
18715: CALL_OW 269
18719: NOT
18720: IFFALSE 18746
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18722: LD_VAR 0 8
18726: PPUSH
18727: LD_VAR 0 8
18731: PPUSH
18732: LD_VAR 0 2
18736: PPUSH
18737: CALL 19996 0 2
18741: PPUSH
18742: CALL_OW 431
// end ;
18746: GO 18707
18748: POP
18749: POP
// end ; for i = 1 to personel do
18750: LD_ADDR_VAR 0 8
18754: PUSH
18755: DOUBLE
18756: LD_INT 1
18758: DEC
18759: ST_TO_ADDR
18760: LD_VAR 0 6
18764: PUSH
18765: FOR_TO
18766: IFFALSE 19830
// begin if i > 4 then
18768: LD_VAR 0 8
18772: PUSH
18773: LD_INT 4
18775: GREATER
18776: IFFALSE 18780
// break ;
18778: GO 19830
// case i of 1 :
18780: LD_VAR 0 8
18784: PUSH
18785: LD_INT 1
18787: DOUBLE
18788: EQUAL
18789: IFTRUE 18793
18791: GO 18873
18793: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18794: LD_ADDR_VAR 0 12
18798: PUSH
18799: LD_VAR 0 18
18803: PPUSH
18804: LD_INT 22
18806: PUSH
18807: LD_VAR 0 16
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: PUSH
18816: LD_INT 58
18818: PUSH
18819: EMPTY
18820: LIST
18821: PUSH
18822: LD_INT 2
18824: PUSH
18825: LD_INT 30
18827: PUSH
18828: LD_INT 32
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 30
18837: PUSH
18838: LD_INT 4
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 30
18847: PUSH
18848: LD_INT 5
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: LIST
18865: PPUSH
18866: CALL_OW 72
18870: ST_TO_ADDR
18871: GO 19095
18873: LD_INT 2
18875: DOUBLE
18876: EQUAL
18877: IFTRUE 18881
18879: GO 18943
18881: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18882: LD_ADDR_VAR 0 12
18886: PUSH
18887: LD_VAR 0 18
18891: PPUSH
18892: LD_INT 22
18894: PUSH
18895: LD_VAR 0 16
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 2
18906: PUSH
18907: LD_INT 30
18909: PUSH
18910: LD_INT 0
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 30
18919: PUSH
18920: LD_INT 1
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: LIST
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PPUSH
18936: CALL_OW 72
18940: ST_TO_ADDR
18941: GO 19095
18943: LD_INT 3
18945: DOUBLE
18946: EQUAL
18947: IFTRUE 18951
18949: GO 19013
18951: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18952: LD_ADDR_VAR 0 12
18956: PUSH
18957: LD_VAR 0 18
18961: PPUSH
18962: LD_INT 22
18964: PUSH
18965: LD_VAR 0 16
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PUSH
18974: LD_INT 2
18976: PUSH
18977: LD_INT 30
18979: PUSH
18980: LD_INT 2
18982: PUSH
18983: EMPTY
18984: LIST
18985: LIST
18986: PUSH
18987: LD_INT 30
18989: PUSH
18990: LD_INT 3
18992: PUSH
18993: EMPTY
18994: LIST
18995: LIST
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 72
19010: ST_TO_ADDR
19011: GO 19095
19013: LD_INT 4
19015: DOUBLE
19016: EQUAL
19017: IFTRUE 19021
19019: GO 19094
19021: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19022: LD_ADDR_VAR 0 12
19026: PUSH
19027: LD_VAR 0 18
19031: PPUSH
19032: LD_INT 22
19034: PUSH
19035: LD_VAR 0 16
19039: PUSH
19040: EMPTY
19041: LIST
19042: LIST
19043: PUSH
19044: LD_INT 2
19046: PUSH
19047: LD_INT 30
19049: PUSH
19050: LD_INT 6
19052: PUSH
19053: EMPTY
19054: LIST
19055: LIST
19056: PUSH
19057: LD_INT 30
19059: PUSH
19060: LD_INT 7
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: PUSH
19067: LD_INT 30
19069: PUSH
19070: LD_INT 8
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: LIST
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PPUSH
19087: CALL_OW 72
19091: ST_TO_ADDR
19092: GO 19095
19094: POP
// if i = 1 then
19095: LD_VAR 0 8
19099: PUSH
19100: LD_INT 1
19102: EQUAL
19103: IFFALSE 19214
// begin tmp := [ ] ;
19105: LD_ADDR_VAR 0 19
19109: PUSH
19110: EMPTY
19111: ST_TO_ADDR
// for j in f do
19112: LD_ADDR_VAR 0 9
19116: PUSH
19117: LD_VAR 0 12
19121: PUSH
19122: FOR_IN
19123: IFFALSE 19196
// if GetBType ( j ) = b_bunker then
19125: LD_VAR 0 9
19129: PPUSH
19130: CALL_OW 266
19134: PUSH
19135: LD_INT 32
19137: EQUAL
19138: IFFALSE 19165
// tmp := Insert ( tmp , 1 , j ) else
19140: LD_ADDR_VAR 0 19
19144: PUSH
19145: LD_VAR 0 19
19149: PPUSH
19150: LD_INT 1
19152: PPUSH
19153: LD_VAR 0 9
19157: PPUSH
19158: CALL_OW 2
19162: ST_TO_ADDR
19163: GO 19194
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19165: LD_ADDR_VAR 0 19
19169: PUSH
19170: LD_VAR 0 19
19174: PPUSH
19175: LD_VAR 0 19
19179: PUSH
19180: LD_INT 1
19182: PLUS
19183: PPUSH
19184: LD_VAR 0 9
19188: PPUSH
19189: CALL_OW 2
19193: ST_TO_ADDR
19194: GO 19122
19196: POP
19197: POP
// if tmp then
19198: LD_VAR 0 19
19202: IFFALSE 19214
// f := tmp ;
19204: LD_ADDR_VAR 0 12
19208: PUSH
19209: LD_VAR 0 19
19213: ST_TO_ADDR
// end ; x := personel [ i ] ;
19214: LD_ADDR_VAR 0 13
19218: PUSH
19219: LD_VAR 0 6
19223: PUSH
19224: LD_VAR 0 8
19228: ARRAY
19229: ST_TO_ADDR
// if x = - 1 then
19230: LD_VAR 0 13
19234: PUSH
19235: LD_INT 1
19237: NEG
19238: EQUAL
19239: IFFALSE 19448
// begin for j in f do
19241: LD_ADDR_VAR 0 9
19245: PUSH
19246: LD_VAR 0 12
19250: PUSH
19251: FOR_IN
19252: IFFALSE 19444
// repeat InitHc ;
19254: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19258: LD_VAR 0 9
19262: PPUSH
19263: CALL_OW 266
19267: PUSH
19268: LD_INT 5
19270: EQUAL
19271: IFFALSE 19341
// begin if UnitsInside ( j ) < 3 then
19273: LD_VAR 0 9
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: LD_INT 3
19285: LESS
19286: IFFALSE 19322
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19288: LD_INT 0
19290: PPUSH
19291: LD_INT 5
19293: PUSH
19294: LD_INT 8
19296: PUSH
19297: LD_INT 9
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: LIST
19304: PUSH
19305: LD_VAR 0 17
19309: ARRAY
19310: PPUSH
19311: LD_VAR 0 4
19315: PPUSH
19316: CALL_OW 380
19320: GO 19339
// PrepareHuman ( false , i , skill ) ;
19322: LD_INT 0
19324: PPUSH
19325: LD_VAR 0 8
19329: PPUSH
19330: LD_VAR 0 4
19334: PPUSH
19335: CALL_OW 380
// end else
19339: GO 19358
// PrepareHuman ( false , i , skill ) ;
19341: LD_INT 0
19343: PPUSH
19344: LD_VAR 0 8
19348: PPUSH
19349: LD_VAR 0 4
19353: PPUSH
19354: CALL_OW 380
// un := CreateHuman ;
19358: LD_ADDR_VAR 0 14
19362: PUSH
19363: CALL_OW 44
19367: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19368: LD_ADDR_VAR 0 7
19372: PUSH
19373: LD_VAR 0 7
19377: PPUSH
19378: LD_INT 1
19380: PPUSH
19381: LD_VAR 0 14
19385: PPUSH
19386: CALL_OW 2
19390: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19391: LD_VAR 0 14
19395: PPUSH
19396: LD_VAR 0 9
19400: PPUSH
19401: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19405: LD_VAR 0 9
19409: PPUSH
19410: CALL_OW 313
19414: PUSH
19415: LD_INT 6
19417: EQUAL
19418: PUSH
19419: LD_VAR 0 9
19423: PPUSH
19424: CALL_OW 266
19428: PUSH
19429: LD_INT 32
19431: PUSH
19432: LD_INT 31
19434: PUSH
19435: EMPTY
19436: LIST
19437: LIST
19438: IN
19439: OR
19440: IFFALSE 19254
19442: GO 19251
19444: POP
19445: POP
// end else
19446: GO 19828
// for j = 1 to x do
19448: LD_ADDR_VAR 0 9
19452: PUSH
19453: DOUBLE
19454: LD_INT 1
19456: DEC
19457: ST_TO_ADDR
19458: LD_VAR 0 13
19462: PUSH
19463: FOR_TO
19464: IFFALSE 19826
// begin InitHc ;
19466: CALL_OW 19
// if not f then
19470: LD_VAR 0 12
19474: NOT
19475: IFFALSE 19564
// begin PrepareHuman ( false , i , skill ) ;
19477: LD_INT 0
19479: PPUSH
19480: LD_VAR 0 8
19484: PPUSH
19485: LD_VAR 0 4
19489: PPUSH
19490: CALL_OW 380
// un := CreateHuman ;
19494: LD_ADDR_VAR 0 14
19498: PUSH
19499: CALL_OW 44
19503: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19504: LD_ADDR_VAR 0 7
19508: PUSH
19509: LD_VAR 0 7
19513: PPUSH
19514: LD_INT 1
19516: PPUSH
19517: LD_VAR 0 14
19521: PPUSH
19522: CALL_OW 2
19526: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19527: LD_VAR 0 14
19531: PPUSH
19532: LD_VAR 0 1
19536: PPUSH
19537: CALL_OW 250
19541: PPUSH
19542: LD_VAR 0 1
19546: PPUSH
19547: CALL_OW 251
19551: PPUSH
19552: LD_INT 10
19554: PPUSH
19555: LD_INT 0
19557: PPUSH
19558: CALL_OW 50
// continue ;
19562: GO 19463
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19564: LD_VAR 0 12
19568: PUSH
19569: LD_INT 1
19571: ARRAY
19572: PPUSH
19573: CALL_OW 313
19577: PUSH
19578: LD_VAR 0 12
19582: PUSH
19583: LD_INT 1
19585: ARRAY
19586: PPUSH
19587: CALL_OW 266
19591: PUSH
19592: LD_INT 32
19594: PUSH
19595: LD_INT 31
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: IN
19602: AND
19603: PUSH
19604: LD_VAR 0 12
19608: PUSH
19609: LD_INT 1
19611: ARRAY
19612: PPUSH
19613: CALL_OW 313
19617: PUSH
19618: LD_INT 6
19620: EQUAL
19621: OR
19622: IFFALSE 19642
// f := Delete ( f , 1 ) ;
19624: LD_ADDR_VAR 0 12
19628: PUSH
19629: LD_VAR 0 12
19633: PPUSH
19634: LD_INT 1
19636: PPUSH
19637: CALL_OW 3
19641: ST_TO_ADDR
// if not f then
19642: LD_VAR 0 12
19646: NOT
19647: IFFALSE 19665
// begin x := x + 2 ;
19649: LD_ADDR_VAR 0 13
19653: PUSH
19654: LD_VAR 0 13
19658: PUSH
19659: LD_INT 2
19661: PLUS
19662: ST_TO_ADDR
// continue ;
19663: GO 19463
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19665: LD_VAR 0 12
19669: PUSH
19670: LD_INT 1
19672: ARRAY
19673: PPUSH
19674: CALL_OW 266
19678: PUSH
19679: LD_INT 5
19681: EQUAL
19682: IFFALSE 19756
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19684: LD_VAR 0 12
19688: PUSH
19689: LD_INT 1
19691: ARRAY
19692: PPUSH
19693: CALL_OW 313
19697: PUSH
19698: LD_INT 3
19700: LESS
19701: IFFALSE 19737
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19703: LD_INT 0
19705: PPUSH
19706: LD_INT 5
19708: PUSH
19709: LD_INT 8
19711: PUSH
19712: LD_INT 9
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: PUSH
19720: LD_VAR 0 17
19724: ARRAY
19725: PPUSH
19726: LD_VAR 0 4
19730: PPUSH
19731: CALL_OW 380
19735: GO 19754
// PrepareHuman ( false , i , skill ) ;
19737: LD_INT 0
19739: PPUSH
19740: LD_VAR 0 8
19744: PPUSH
19745: LD_VAR 0 4
19749: PPUSH
19750: CALL_OW 380
// end else
19754: GO 19773
// PrepareHuman ( false , i , skill ) ;
19756: LD_INT 0
19758: PPUSH
19759: LD_VAR 0 8
19763: PPUSH
19764: LD_VAR 0 4
19768: PPUSH
19769: CALL_OW 380
// un := CreateHuman ;
19773: LD_ADDR_VAR 0 14
19777: PUSH
19778: CALL_OW 44
19782: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19783: LD_ADDR_VAR 0 7
19787: PUSH
19788: LD_VAR 0 7
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: LD_VAR 0 14
19800: PPUSH
19801: CALL_OW 2
19805: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19806: LD_VAR 0 14
19810: PPUSH
19811: LD_VAR 0 12
19815: PUSH
19816: LD_INT 1
19818: ARRAY
19819: PPUSH
19820: CALL_OW 52
// end ;
19824: GO 19463
19826: POP
19827: POP
// end ;
19828: GO 18765
19830: POP
19831: POP
// result := result ^ buildings ;
19832: LD_ADDR_VAR 0 7
19836: PUSH
19837: LD_VAR 0 7
19841: PUSH
19842: LD_VAR 0 18
19846: ADD
19847: ST_TO_ADDR
// end else
19848: GO 19991
// begin for i = 1 to personel do
19850: LD_ADDR_VAR 0 8
19854: PUSH
19855: DOUBLE
19856: LD_INT 1
19858: DEC
19859: ST_TO_ADDR
19860: LD_VAR 0 6
19864: PUSH
19865: FOR_TO
19866: IFFALSE 19989
// begin if i > 4 then
19868: LD_VAR 0 8
19872: PUSH
19873: LD_INT 4
19875: GREATER
19876: IFFALSE 19880
// break ;
19878: GO 19989
// x := personel [ i ] ;
19880: LD_ADDR_VAR 0 13
19884: PUSH
19885: LD_VAR 0 6
19889: PUSH
19890: LD_VAR 0 8
19894: ARRAY
19895: ST_TO_ADDR
// if x = - 1 then
19896: LD_VAR 0 13
19900: PUSH
19901: LD_INT 1
19903: NEG
19904: EQUAL
19905: IFFALSE 19909
// continue ;
19907: GO 19865
// PrepareHuman ( false , i , skill ) ;
19909: LD_INT 0
19911: PPUSH
19912: LD_VAR 0 8
19916: PPUSH
19917: LD_VAR 0 4
19921: PPUSH
19922: CALL_OW 380
// un := CreateHuman ;
19926: LD_ADDR_VAR 0 14
19930: PUSH
19931: CALL_OW 44
19935: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19936: LD_VAR 0 14
19940: PPUSH
19941: LD_VAR 0 1
19945: PPUSH
19946: CALL_OW 250
19950: PPUSH
19951: LD_VAR 0 1
19955: PPUSH
19956: CALL_OW 251
19960: PPUSH
19961: LD_INT 10
19963: PPUSH
19964: LD_INT 0
19966: PPUSH
19967: CALL_OW 50
// result := result ^ un ;
19971: LD_ADDR_VAR 0 7
19975: PUSH
19976: LD_VAR 0 7
19980: PUSH
19981: LD_VAR 0 14
19985: ADD
19986: ST_TO_ADDR
// end ;
19987: GO 19865
19989: POP
19990: POP
// end ; end ;
19991: LD_VAR 0 7
19995: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19996: LD_INT 0
19998: PPUSH
19999: PPUSH
20000: PPUSH
20001: PPUSH
20002: PPUSH
20003: PPUSH
20004: PPUSH
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
20012: PPUSH
20013: PPUSH
// result := false ;
20014: LD_ADDR_VAR 0 3
20018: PUSH
20019: LD_INT 0
20021: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20022: LD_VAR 0 1
20026: NOT
20027: PUSH
20028: LD_VAR 0 1
20032: PPUSH
20033: CALL_OW 266
20037: PUSH
20038: LD_INT 32
20040: PUSH
20041: LD_INT 33
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: IN
20048: NOT
20049: OR
20050: IFFALSE 20054
// exit ;
20052: GO 21163
// nat := GetNation ( tower ) ;
20054: LD_ADDR_VAR 0 12
20058: PUSH
20059: LD_VAR 0 1
20063: PPUSH
20064: CALL_OW 248
20068: ST_TO_ADDR
// side := GetSide ( tower ) ;
20069: LD_ADDR_VAR 0 16
20073: PUSH
20074: LD_VAR 0 1
20078: PPUSH
20079: CALL_OW 255
20083: ST_TO_ADDR
// x := GetX ( tower ) ;
20084: LD_ADDR_VAR 0 10
20088: PUSH
20089: LD_VAR 0 1
20093: PPUSH
20094: CALL_OW 250
20098: ST_TO_ADDR
// y := GetY ( tower ) ;
20099: LD_ADDR_VAR 0 11
20103: PUSH
20104: LD_VAR 0 1
20108: PPUSH
20109: CALL_OW 251
20113: ST_TO_ADDR
// if not x or not y then
20114: LD_VAR 0 10
20118: NOT
20119: PUSH
20120: LD_VAR 0 11
20124: NOT
20125: OR
20126: IFFALSE 20130
// exit ;
20128: GO 21163
// weapon := 0 ;
20130: LD_ADDR_VAR 0 18
20134: PUSH
20135: LD_INT 0
20137: ST_TO_ADDR
// fac_list := [ ] ;
20138: LD_ADDR_VAR 0 17
20142: PUSH
20143: EMPTY
20144: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20145: LD_ADDR_VAR 0 6
20149: PUSH
20150: LD_VAR 0 1
20154: PPUSH
20155: CALL_OW 274
20159: PPUSH
20160: LD_VAR 0 2
20164: PPUSH
20165: LD_INT 0
20167: PPUSH
20168: CALL 17734 0 3
20172: PPUSH
20173: LD_INT 30
20175: PUSH
20176: LD_INT 3
20178: PUSH
20179: EMPTY
20180: LIST
20181: LIST
20182: PPUSH
20183: CALL_OW 72
20187: ST_TO_ADDR
// if not factories then
20188: LD_VAR 0 6
20192: NOT
20193: IFFALSE 20197
// exit ;
20195: GO 21163
// for i in factories do
20197: LD_ADDR_VAR 0 8
20201: PUSH
20202: LD_VAR 0 6
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20233
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20210: LD_ADDR_VAR 0 17
20214: PUSH
20215: LD_VAR 0 17
20219: PUSH
20220: LD_VAR 0 8
20224: PPUSH
20225: CALL_OW 478
20229: UNION
20230: ST_TO_ADDR
20231: GO 20207
20233: POP
20234: POP
// if not fac_list then
20235: LD_VAR 0 17
20239: NOT
20240: IFFALSE 20244
// exit ;
20242: GO 21163
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20244: LD_ADDR_VAR 0 5
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 5
20254: PUSH
20255: LD_INT 9
20257: PUSH
20258: LD_INT 10
20260: PUSH
20261: LD_INT 6
20263: PUSH
20264: LD_INT 7
20266: PUSH
20267: LD_INT 11
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: PUSH
20279: LD_INT 27
20281: PUSH
20282: LD_INT 28
20284: PUSH
20285: LD_INT 26
20287: PUSH
20288: LD_INT 30
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: PUSH
20297: LD_INT 43
20299: PUSH
20300: LD_INT 44
20302: PUSH
20303: LD_INT 46
20305: PUSH
20306: LD_INT 45
20308: PUSH
20309: LD_INT 47
20311: PUSH
20312: LD_INT 49
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: LIST
20327: PUSH
20328: LD_VAR 0 12
20332: ARRAY
20333: ST_TO_ADDR
// list := list isect fac_list ;
20334: LD_ADDR_VAR 0 5
20338: PUSH
20339: LD_VAR 0 5
20343: PUSH
20344: LD_VAR 0 17
20348: ISECT
20349: ST_TO_ADDR
// if not list then
20350: LD_VAR 0 5
20354: NOT
20355: IFFALSE 20359
// exit ;
20357: GO 21163
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20359: LD_VAR 0 12
20363: PUSH
20364: LD_INT 3
20366: EQUAL
20367: PUSH
20368: LD_INT 49
20370: PUSH
20371: LD_VAR 0 5
20375: IN
20376: AND
20377: PUSH
20378: LD_INT 31
20380: PPUSH
20381: LD_VAR 0 16
20385: PPUSH
20386: CALL_OW 321
20390: PUSH
20391: LD_INT 2
20393: EQUAL
20394: AND
20395: IFFALSE 20455
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20397: LD_INT 22
20399: PUSH
20400: LD_VAR 0 16
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 35
20411: PUSH
20412: LD_INT 49
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 91
20421: PUSH
20422: LD_VAR 0 1
20426: PUSH
20427: LD_INT 10
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL_OW 69
20444: NOT
20445: IFFALSE 20455
// weapon := ru_time_lapser ;
20447: LD_ADDR_VAR 0 18
20451: PUSH
20452: LD_INT 49
20454: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20455: LD_VAR 0 12
20459: PUSH
20460: LD_INT 1
20462: PUSH
20463: LD_INT 2
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: IN
20470: PUSH
20471: LD_INT 11
20473: PUSH
20474: LD_VAR 0 5
20478: IN
20479: PUSH
20480: LD_INT 30
20482: PUSH
20483: LD_VAR 0 5
20487: IN
20488: OR
20489: AND
20490: PUSH
20491: LD_INT 6
20493: PPUSH
20494: LD_VAR 0 16
20498: PPUSH
20499: CALL_OW 321
20503: PUSH
20504: LD_INT 2
20506: EQUAL
20507: AND
20508: IFFALSE 20673
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20510: LD_INT 22
20512: PUSH
20513: LD_VAR 0 16
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 2
20524: PUSH
20525: LD_INT 35
20527: PUSH
20528: LD_INT 11
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 35
20537: PUSH
20538: LD_INT 30
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: LIST
20549: PUSH
20550: LD_INT 91
20552: PUSH
20553: LD_VAR 0 1
20557: PUSH
20558: LD_INT 18
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: LIST
20570: PPUSH
20571: CALL_OW 69
20575: NOT
20576: PUSH
20577: LD_INT 22
20579: PUSH
20580: LD_VAR 0 16
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: PUSH
20589: LD_INT 2
20591: PUSH
20592: LD_INT 30
20594: PUSH
20595: LD_INT 32
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: PUSH
20602: LD_INT 30
20604: PUSH
20605: LD_INT 33
20607: PUSH
20608: EMPTY
20609: LIST
20610: LIST
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: LIST
20616: PUSH
20617: LD_INT 91
20619: PUSH
20620: LD_VAR 0 1
20624: PUSH
20625: LD_INT 12
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: LIST
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: LIST
20637: PUSH
20638: EMPTY
20639: LIST
20640: PPUSH
20641: CALL_OW 69
20645: PUSH
20646: LD_INT 2
20648: GREATER
20649: AND
20650: IFFALSE 20673
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20652: LD_ADDR_VAR 0 18
20656: PUSH
20657: LD_INT 11
20659: PUSH
20660: LD_INT 30
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: PUSH
20667: LD_VAR 0 12
20671: ARRAY
20672: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20673: LD_VAR 0 18
20677: NOT
20678: PUSH
20679: LD_INT 40
20681: PPUSH
20682: LD_VAR 0 16
20686: PPUSH
20687: CALL_OW 321
20691: PUSH
20692: LD_INT 2
20694: EQUAL
20695: AND
20696: PUSH
20697: LD_INT 7
20699: PUSH
20700: LD_VAR 0 5
20704: IN
20705: PUSH
20706: LD_INT 28
20708: PUSH
20709: LD_VAR 0 5
20713: IN
20714: OR
20715: PUSH
20716: LD_INT 45
20718: PUSH
20719: LD_VAR 0 5
20723: IN
20724: OR
20725: AND
20726: IFFALSE 20980
// begin hex := GetHexInfo ( x , y ) ;
20728: LD_ADDR_VAR 0 4
20732: PUSH
20733: LD_VAR 0 10
20737: PPUSH
20738: LD_VAR 0 11
20742: PPUSH
20743: CALL_OW 546
20747: ST_TO_ADDR
// if hex [ 1 ] then
20748: LD_VAR 0 4
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: IFFALSE 20760
// exit ;
20758: GO 21163
// height := hex [ 2 ] ;
20760: LD_ADDR_VAR 0 15
20764: PUSH
20765: LD_VAR 0 4
20769: PUSH
20770: LD_INT 2
20772: ARRAY
20773: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20774: LD_ADDR_VAR 0 14
20778: PUSH
20779: LD_INT 0
20781: PUSH
20782: LD_INT 2
20784: PUSH
20785: LD_INT 3
20787: PUSH
20788: LD_INT 5
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: ST_TO_ADDR
// for i in tmp do
20797: LD_ADDR_VAR 0 8
20801: PUSH
20802: LD_VAR 0 14
20806: PUSH
20807: FOR_IN
20808: IFFALSE 20978
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20810: LD_ADDR_VAR 0 9
20814: PUSH
20815: LD_VAR 0 10
20819: PPUSH
20820: LD_VAR 0 8
20824: PPUSH
20825: LD_INT 5
20827: PPUSH
20828: CALL_OW 272
20832: PUSH
20833: LD_VAR 0 11
20837: PPUSH
20838: LD_VAR 0 8
20842: PPUSH
20843: LD_INT 5
20845: PPUSH
20846: CALL_OW 273
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20855: LD_VAR 0 9
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: LD_VAR 0 9
20868: PUSH
20869: LD_INT 2
20871: ARRAY
20872: PPUSH
20873: CALL_OW 488
20877: IFFALSE 20976
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20879: LD_ADDR_VAR 0 4
20883: PUSH
20884: LD_VAR 0 9
20888: PUSH
20889: LD_INT 1
20891: ARRAY
20892: PPUSH
20893: LD_VAR 0 9
20897: PUSH
20898: LD_INT 2
20900: ARRAY
20901: PPUSH
20902: CALL_OW 546
20906: ST_TO_ADDR
// if hex [ 1 ] then
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: ARRAY
20915: IFFALSE 20919
// continue ;
20917: GO 20807
// h := hex [ 2 ] ;
20919: LD_ADDR_VAR 0 13
20923: PUSH
20924: LD_VAR 0 4
20928: PUSH
20929: LD_INT 2
20931: ARRAY
20932: ST_TO_ADDR
// if h + 7 < height then
20933: LD_VAR 0 13
20937: PUSH
20938: LD_INT 7
20940: PLUS
20941: PUSH
20942: LD_VAR 0 15
20946: LESS
20947: IFFALSE 20976
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20949: LD_ADDR_VAR 0 18
20953: PUSH
20954: LD_INT 7
20956: PUSH
20957: LD_INT 28
20959: PUSH
20960: LD_INT 45
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: LIST
20967: PUSH
20968: LD_VAR 0 12
20972: ARRAY
20973: ST_TO_ADDR
// break ;
20974: GO 20978
// end ; end ; end ;
20976: GO 20807
20978: POP
20979: POP
// end ; if not weapon then
20980: LD_VAR 0 18
20984: NOT
20985: IFFALSE 21045
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20987: LD_ADDR_VAR 0 5
20991: PUSH
20992: LD_VAR 0 5
20996: PUSH
20997: LD_INT 11
20999: PUSH
21000: LD_INT 30
21002: PUSH
21003: LD_INT 49
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: LIST
21010: DIFF
21011: ST_TO_ADDR
// if not list then
21012: LD_VAR 0 5
21016: NOT
21017: IFFALSE 21021
// exit ;
21019: GO 21163
// weapon := list [ rand ( 1 , list ) ] ;
21021: LD_ADDR_VAR 0 18
21025: PUSH
21026: LD_VAR 0 5
21030: PUSH
21031: LD_INT 1
21033: PPUSH
21034: LD_VAR 0 5
21038: PPUSH
21039: CALL_OW 12
21043: ARRAY
21044: ST_TO_ADDR
// end ; if weapon then
21045: LD_VAR 0 18
21049: IFFALSE 21163
// begin tmp := CostOfWeapon ( weapon ) ;
21051: LD_ADDR_VAR 0 14
21055: PUSH
21056: LD_VAR 0 18
21060: PPUSH
21061: CALL_OW 451
21065: ST_TO_ADDR
// j := GetBase ( tower ) ;
21066: LD_ADDR_VAR 0 9
21070: PUSH
21071: LD_VAR 0 1
21075: PPUSH
21076: CALL_OW 274
21080: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21081: LD_VAR 0 9
21085: PPUSH
21086: LD_INT 1
21088: PPUSH
21089: CALL_OW 275
21093: PUSH
21094: LD_VAR 0 14
21098: PUSH
21099: LD_INT 1
21101: ARRAY
21102: GREATEREQUAL
21103: PUSH
21104: LD_VAR 0 9
21108: PPUSH
21109: LD_INT 2
21111: PPUSH
21112: CALL_OW 275
21116: PUSH
21117: LD_VAR 0 14
21121: PUSH
21122: LD_INT 2
21124: ARRAY
21125: GREATEREQUAL
21126: AND
21127: PUSH
21128: LD_VAR 0 9
21132: PPUSH
21133: LD_INT 3
21135: PPUSH
21136: CALL_OW 275
21140: PUSH
21141: LD_VAR 0 14
21145: PUSH
21146: LD_INT 3
21148: ARRAY
21149: GREATEREQUAL
21150: AND
21151: IFFALSE 21163
// result := weapon ;
21153: LD_ADDR_VAR 0 3
21157: PUSH
21158: LD_VAR 0 18
21162: ST_TO_ADDR
// end ; end ;
21163: LD_VAR 0 3
21167: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21168: LD_INT 0
21170: PPUSH
21171: PPUSH
// result := true ;
21172: LD_ADDR_VAR 0 3
21176: PUSH
21177: LD_INT 1
21179: ST_TO_ADDR
// if array1 = array2 then
21180: LD_VAR 0 1
21184: PUSH
21185: LD_VAR 0 2
21189: EQUAL
21190: IFFALSE 21250
// begin for i = 1 to array1 do
21192: LD_ADDR_VAR 0 4
21196: PUSH
21197: DOUBLE
21198: LD_INT 1
21200: DEC
21201: ST_TO_ADDR
21202: LD_VAR 0 1
21206: PUSH
21207: FOR_TO
21208: IFFALSE 21246
// if array1 [ i ] <> array2 [ i ] then
21210: LD_VAR 0 1
21214: PUSH
21215: LD_VAR 0 4
21219: ARRAY
21220: PUSH
21221: LD_VAR 0 2
21225: PUSH
21226: LD_VAR 0 4
21230: ARRAY
21231: NONEQUAL
21232: IFFALSE 21244
// begin result := false ;
21234: LD_ADDR_VAR 0 3
21238: PUSH
21239: LD_INT 0
21241: ST_TO_ADDR
// break ;
21242: GO 21246
// end ;
21244: GO 21207
21246: POP
21247: POP
// end else
21248: GO 21258
// result := false ;
21250: LD_ADDR_VAR 0 3
21254: PUSH
21255: LD_INT 0
21257: ST_TO_ADDR
// end ;
21258: LD_VAR 0 3
21262: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21263: LD_INT 0
21265: PPUSH
21266: PPUSH
// if not array1 or not array2 then
21267: LD_VAR 0 1
21271: NOT
21272: PUSH
21273: LD_VAR 0 2
21277: NOT
21278: OR
21279: IFFALSE 21283
// exit ;
21281: GO 21347
// result := true ;
21283: LD_ADDR_VAR 0 3
21287: PUSH
21288: LD_INT 1
21290: ST_TO_ADDR
// for i = 1 to array1 do
21291: LD_ADDR_VAR 0 4
21295: PUSH
21296: DOUBLE
21297: LD_INT 1
21299: DEC
21300: ST_TO_ADDR
21301: LD_VAR 0 1
21305: PUSH
21306: FOR_TO
21307: IFFALSE 21345
// if array1 [ i ] <> array2 [ i ] then
21309: LD_VAR 0 1
21313: PUSH
21314: LD_VAR 0 4
21318: ARRAY
21319: PUSH
21320: LD_VAR 0 2
21324: PUSH
21325: LD_VAR 0 4
21329: ARRAY
21330: NONEQUAL
21331: IFFALSE 21343
// begin result := false ;
21333: LD_ADDR_VAR 0 3
21337: PUSH
21338: LD_INT 0
21340: ST_TO_ADDR
// break ;
21341: GO 21345
// end ;
21343: GO 21306
21345: POP
21346: POP
// end ;
21347: LD_VAR 0 3
21351: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21352: LD_INT 0
21354: PPUSH
21355: PPUSH
21356: PPUSH
// pom := GetBase ( fac ) ;
21357: LD_ADDR_VAR 0 5
21361: PUSH
21362: LD_VAR 0 1
21366: PPUSH
21367: CALL_OW 274
21371: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21372: LD_ADDR_VAR 0 4
21376: PUSH
21377: LD_VAR 0 2
21381: PUSH
21382: LD_INT 1
21384: ARRAY
21385: PPUSH
21386: LD_VAR 0 2
21390: PUSH
21391: LD_INT 2
21393: ARRAY
21394: PPUSH
21395: LD_VAR 0 2
21399: PUSH
21400: LD_INT 3
21402: ARRAY
21403: PPUSH
21404: LD_VAR 0 2
21408: PUSH
21409: LD_INT 4
21411: ARRAY
21412: PPUSH
21413: CALL_OW 449
21417: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21418: LD_ADDR_VAR 0 3
21422: PUSH
21423: LD_VAR 0 5
21427: PPUSH
21428: LD_INT 1
21430: PPUSH
21431: CALL_OW 275
21435: PUSH
21436: LD_VAR 0 4
21440: PUSH
21441: LD_INT 1
21443: ARRAY
21444: GREATEREQUAL
21445: PUSH
21446: LD_VAR 0 5
21450: PPUSH
21451: LD_INT 2
21453: PPUSH
21454: CALL_OW 275
21458: PUSH
21459: LD_VAR 0 4
21463: PUSH
21464: LD_INT 2
21466: ARRAY
21467: GREATEREQUAL
21468: AND
21469: PUSH
21470: LD_VAR 0 5
21474: PPUSH
21475: LD_INT 3
21477: PPUSH
21478: CALL_OW 275
21482: PUSH
21483: LD_VAR 0 4
21487: PUSH
21488: LD_INT 3
21490: ARRAY
21491: GREATEREQUAL
21492: AND
21493: ST_TO_ADDR
// end ;
21494: LD_VAR 0 3
21498: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21499: LD_INT 0
21501: PPUSH
21502: PPUSH
21503: PPUSH
21504: PPUSH
// pom := GetBase ( building ) ;
21505: LD_ADDR_VAR 0 3
21509: PUSH
21510: LD_VAR 0 1
21514: PPUSH
21515: CALL_OW 274
21519: ST_TO_ADDR
// if not pom then
21520: LD_VAR 0 3
21524: NOT
21525: IFFALSE 21529
// exit ;
21527: GO 21699
// btype := GetBType ( building ) ;
21529: LD_ADDR_VAR 0 5
21533: PUSH
21534: LD_VAR 0 1
21538: PPUSH
21539: CALL_OW 266
21543: ST_TO_ADDR
// if btype = b_armoury then
21544: LD_VAR 0 5
21548: PUSH
21549: LD_INT 4
21551: EQUAL
21552: IFFALSE 21562
// btype := b_barracks ;
21554: LD_ADDR_VAR 0 5
21558: PUSH
21559: LD_INT 5
21561: ST_TO_ADDR
// if btype = b_depot then
21562: LD_VAR 0 5
21566: PUSH
21567: LD_INT 0
21569: EQUAL
21570: IFFALSE 21580
// btype := b_warehouse ;
21572: LD_ADDR_VAR 0 5
21576: PUSH
21577: LD_INT 1
21579: ST_TO_ADDR
// if btype = b_workshop then
21580: LD_VAR 0 5
21584: PUSH
21585: LD_INT 2
21587: EQUAL
21588: IFFALSE 21598
// btype := b_factory ;
21590: LD_ADDR_VAR 0 5
21594: PUSH
21595: LD_INT 3
21597: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21598: LD_ADDR_VAR 0 4
21602: PUSH
21603: LD_VAR 0 5
21607: PPUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 248
21617: PPUSH
21618: CALL_OW 450
21622: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21623: LD_ADDR_VAR 0 2
21627: PUSH
21628: LD_VAR 0 3
21632: PPUSH
21633: LD_INT 1
21635: PPUSH
21636: CALL_OW 275
21640: PUSH
21641: LD_VAR 0 4
21645: PUSH
21646: LD_INT 1
21648: ARRAY
21649: GREATEREQUAL
21650: PUSH
21651: LD_VAR 0 3
21655: PPUSH
21656: LD_INT 2
21658: PPUSH
21659: CALL_OW 275
21663: PUSH
21664: LD_VAR 0 4
21668: PUSH
21669: LD_INT 2
21671: ARRAY
21672: GREATEREQUAL
21673: AND
21674: PUSH
21675: LD_VAR 0 3
21679: PPUSH
21680: LD_INT 3
21682: PPUSH
21683: CALL_OW 275
21687: PUSH
21688: LD_VAR 0 4
21692: PUSH
21693: LD_INT 3
21695: ARRAY
21696: GREATEREQUAL
21697: AND
21698: ST_TO_ADDR
// end ;
21699: LD_VAR 0 2
21703: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21704: LD_INT 0
21706: PPUSH
21707: PPUSH
21708: PPUSH
// pom := GetBase ( building ) ;
21709: LD_ADDR_VAR 0 4
21713: PUSH
21714: LD_VAR 0 1
21718: PPUSH
21719: CALL_OW 274
21723: ST_TO_ADDR
// if not pom then
21724: LD_VAR 0 4
21728: NOT
21729: IFFALSE 21733
// exit ;
21731: GO 21834
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21733: LD_ADDR_VAR 0 5
21737: PUSH
21738: LD_VAR 0 2
21742: PPUSH
21743: LD_VAR 0 1
21747: PPUSH
21748: CALL_OW 248
21752: PPUSH
21753: CALL_OW 450
21757: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_VAR 0 4
21767: PPUSH
21768: LD_INT 1
21770: PPUSH
21771: CALL_OW 275
21775: PUSH
21776: LD_VAR 0 5
21780: PUSH
21781: LD_INT 1
21783: ARRAY
21784: GREATEREQUAL
21785: PUSH
21786: LD_VAR 0 4
21790: PPUSH
21791: LD_INT 2
21793: PPUSH
21794: CALL_OW 275
21798: PUSH
21799: LD_VAR 0 5
21803: PUSH
21804: LD_INT 2
21806: ARRAY
21807: GREATEREQUAL
21808: AND
21809: PUSH
21810: LD_VAR 0 4
21814: PPUSH
21815: LD_INT 3
21817: PPUSH
21818: CALL_OW 275
21822: PUSH
21823: LD_VAR 0 5
21827: PUSH
21828: LD_INT 3
21830: ARRAY
21831: GREATEREQUAL
21832: AND
21833: ST_TO_ADDR
// end ;
21834: LD_VAR 0 3
21838: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21839: LD_INT 0
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
21850: PPUSH
21851: PPUSH
// result := false ;
21852: LD_ADDR_VAR 0 8
21856: PUSH
21857: LD_INT 0
21859: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21860: LD_VAR 0 5
21864: NOT
21865: PUSH
21866: LD_VAR 0 1
21870: NOT
21871: OR
21872: PUSH
21873: LD_VAR 0 2
21877: NOT
21878: OR
21879: PUSH
21880: LD_VAR 0 3
21884: NOT
21885: OR
21886: IFFALSE 21890
// exit ;
21888: GO 22704
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21890: LD_ADDR_VAR 0 14
21894: PUSH
21895: LD_VAR 0 1
21899: PPUSH
21900: LD_VAR 0 2
21904: PPUSH
21905: LD_VAR 0 3
21909: PPUSH
21910: LD_VAR 0 4
21914: PPUSH
21915: LD_VAR 0 5
21919: PUSH
21920: LD_INT 1
21922: ARRAY
21923: PPUSH
21924: CALL_OW 248
21928: PPUSH
21929: LD_INT 0
21931: PPUSH
21932: CALL 23937 0 6
21936: ST_TO_ADDR
// if not hexes then
21937: LD_VAR 0 14
21941: NOT
21942: IFFALSE 21946
// exit ;
21944: GO 22704
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21946: LD_ADDR_VAR 0 17
21950: PUSH
21951: LD_VAR 0 5
21955: PPUSH
21956: LD_INT 22
21958: PUSH
21959: LD_VAR 0 13
21963: PPUSH
21964: CALL_OW 255
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 2
21975: PUSH
21976: LD_INT 30
21978: PUSH
21979: LD_INT 0
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: PUSH
21986: LD_INT 30
21988: PUSH
21989: LD_INT 1
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: PUSH
22001: EMPTY
22002: LIST
22003: LIST
22004: PPUSH
22005: CALL_OW 72
22009: ST_TO_ADDR
// for i = 1 to hexes do
22010: LD_ADDR_VAR 0 9
22014: PUSH
22015: DOUBLE
22016: LD_INT 1
22018: DEC
22019: ST_TO_ADDR
22020: LD_VAR 0 14
22024: PUSH
22025: FOR_TO
22026: IFFALSE 22702
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: LD_VAR 0 14
22037: PUSH
22038: LD_VAR 0 9
22042: ARRAY
22043: PUSH
22044: LD_INT 1
22046: ARRAY
22047: PPUSH
22048: LD_VAR 0 14
22052: PUSH
22053: LD_VAR 0 9
22057: ARRAY
22058: PUSH
22059: LD_INT 2
22061: ARRAY
22062: PPUSH
22063: CALL_OW 428
22067: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22068: LD_VAR 0 14
22072: PUSH
22073: LD_VAR 0 9
22077: ARRAY
22078: PUSH
22079: LD_INT 1
22081: ARRAY
22082: PPUSH
22083: LD_VAR 0 14
22087: PUSH
22088: LD_VAR 0 9
22092: ARRAY
22093: PUSH
22094: LD_INT 2
22096: ARRAY
22097: PPUSH
22098: CALL_OW 351
22102: PUSH
22103: LD_VAR 0 14
22107: PUSH
22108: LD_VAR 0 9
22112: ARRAY
22113: PUSH
22114: LD_INT 1
22116: ARRAY
22117: PPUSH
22118: LD_VAR 0 14
22122: PUSH
22123: LD_VAR 0 9
22127: ARRAY
22128: PUSH
22129: LD_INT 2
22131: ARRAY
22132: PPUSH
22133: CALL_OW 488
22137: NOT
22138: OR
22139: PUSH
22140: LD_VAR 0 13
22144: PPUSH
22145: CALL_OW 247
22149: PUSH
22150: LD_INT 3
22152: EQUAL
22153: OR
22154: IFFALSE 22160
// exit ;
22156: POP
22157: POP
22158: GO 22704
// if not tmp then
22160: LD_VAR 0 13
22164: NOT
22165: IFFALSE 22169
// continue ;
22167: GO 22025
// result := true ;
22169: LD_ADDR_VAR 0 8
22173: PUSH
22174: LD_INT 1
22176: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22177: LD_VAR 0 6
22181: PUSH
22182: LD_VAR 0 13
22186: PPUSH
22187: CALL_OW 247
22191: PUSH
22192: LD_INT 2
22194: EQUAL
22195: AND
22196: PUSH
22197: LD_VAR 0 13
22201: PPUSH
22202: CALL_OW 263
22206: PUSH
22207: LD_INT 1
22209: EQUAL
22210: AND
22211: IFFALSE 22375
// begin if IsDrivenBy ( tmp ) then
22213: LD_VAR 0 13
22217: PPUSH
22218: CALL_OW 311
22222: IFFALSE 22226
// continue ;
22224: GO 22025
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22226: LD_VAR 0 6
22230: PPUSH
22231: LD_INT 3
22233: PUSH
22234: LD_INT 60
22236: PUSH
22237: EMPTY
22238: LIST
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 3
22246: PUSH
22247: LD_INT 55
22249: PUSH
22250: EMPTY
22251: LIST
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: PPUSH
22261: CALL_OW 72
22265: IFFALSE 22373
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22267: LD_ADDR_VAR 0 18
22271: PUSH
22272: LD_VAR 0 6
22276: PPUSH
22277: LD_INT 3
22279: PUSH
22280: LD_INT 60
22282: PUSH
22283: EMPTY
22284: LIST
22285: PUSH
22286: EMPTY
22287: LIST
22288: LIST
22289: PUSH
22290: LD_INT 3
22292: PUSH
22293: LD_INT 55
22295: PUSH
22296: EMPTY
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PPUSH
22307: CALL_OW 72
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: ST_TO_ADDR
// if IsInUnit ( driver ) then
22316: LD_VAR 0 18
22320: PPUSH
22321: CALL_OW 310
22325: IFFALSE 22336
// ComExit ( driver ) ;
22327: LD_VAR 0 18
22331: PPUSH
22332: CALL 47717 0 1
// AddComEnterUnit ( driver , tmp ) ;
22336: LD_VAR 0 18
22340: PPUSH
22341: LD_VAR 0 13
22345: PPUSH
22346: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22350: LD_VAR 0 18
22354: PPUSH
22355: LD_VAR 0 7
22359: PPUSH
22360: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22364: LD_VAR 0 18
22368: PPUSH
22369: CALL_OW 181
// end ; continue ;
22373: GO 22025
// end ; if not cleaners or not tmp in cleaners then
22375: LD_VAR 0 6
22379: NOT
22380: PUSH
22381: LD_VAR 0 13
22385: PUSH
22386: LD_VAR 0 6
22390: IN
22391: NOT
22392: OR
22393: IFFALSE 22700
// begin if dep then
22395: LD_VAR 0 17
22399: IFFALSE 22535
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22401: LD_ADDR_VAR 0 16
22405: PUSH
22406: LD_VAR 0 17
22410: PUSH
22411: LD_INT 1
22413: ARRAY
22414: PPUSH
22415: CALL_OW 250
22419: PPUSH
22420: LD_VAR 0 17
22424: PUSH
22425: LD_INT 1
22427: ARRAY
22428: PPUSH
22429: CALL_OW 254
22433: PPUSH
22434: LD_INT 5
22436: PPUSH
22437: CALL_OW 272
22441: PUSH
22442: LD_VAR 0 17
22446: PUSH
22447: LD_INT 1
22449: ARRAY
22450: PPUSH
22451: CALL_OW 251
22455: PPUSH
22456: LD_VAR 0 17
22460: PUSH
22461: LD_INT 1
22463: ARRAY
22464: PPUSH
22465: CALL_OW 254
22469: PPUSH
22470: LD_INT 5
22472: PPUSH
22473: CALL_OW 273
22477: PUSH
22478: EMPTY
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22482: LD_VAR 0 16
22486: PUSH
22487: LD_INT 1
22489: ARRAY
22490: PPUSH
22491: LD_VAR 0 16
22495: PUSH
22496: LD_INT 2
22498: ARRAY
22499: PPUSH
22500: CALL_OW 488
22504: IFFALSE 22535
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22506: LD_VAR 0 13
22510: PPUSH
22511: LD_VAR 0 16
22515: PUSH
22516: LD_INT 1
22518: ARRAY
22519: PPUSH
22520: LD_VAR 0 16
22524: PUSH
22525: LD_INT 2
22527: ARRAY
22528: PPUSH
22529: CALL_OW 111
// continue ;
22533: GO 22025
// end ; end ; r := GetDir ( tmp ) ;
22535: LD_ADDR_VAR 0 15
22539: PUSH
22540: LD_VAR 0 13
22544: PPUSH
22545: CALL_OW 254
22549: ST_TO_ADDR
// if r = 5 then
22550: LD_VAR 0 15
22554: PUSH
22555: LD_INT 5
22557: EQUAL
22558: IFFALSE 22568
// r := 0 ;
22560: LD_ADDR_VAR 0 15
22564: PUSH
22565: LD_INT 0
22567: ST_TO_ADDR
// for j = r to 5 do
22568: LD_ADDR_VAR 0 10
22572: PUSH
22573: DOUBLE
22574: LD_VAR 0 15
22578: DEC
22579: ST_TO_ADDR
22580: LD_INT 5
22582: PUSH
22583: FOR_TO
22584: IFFALSE 22698
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22586: LD_ADDR_VAR 0 11
22590: PUSH
22591: LD_VAR 0 13
22595: PPUSH
22596: CALL_OW 250
22600: PPUSH
22601: LD_VAR 0 10
22605: PPUSH
22606: LD_INT 2
22608: PPUSH
22609: CALL_OW 272
22613: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22614: LD_ADDR_VAR 0 12
22618: PUSH
22619: LD_VAR 0 13
22623: PPUSH
22624: CALL_OW 251
22628: PPUSH
22629: LD_VAR 0 10
22633: PPUSH
22634: LD_INT 2
22636: PPUSH
22637: CALL_OW 273
22641: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22642: LD_VAR 0 11
22646: PPUSH
22647: LD_VAR 0 12
22651: PPUSH
22652: CALL_OW 488
22656: PUSH
22657: LD_VAR 0 11
22661: PPUSH
22662: LD_VAR 0 12
22666: PPUSH
22667: CALL_OW 428
22671: NOT
22672: AND
22673: IFFALSE 22696
// begin ComMoveXY ( tmp , _x , _y ) ;
22675: LD_VAR 0 13
22679: PPUSH
22680: LD_VAR 0 11
22684: PPUSH
22685: LD_VAR 0 12
22689: PPUSH
22690: CALL_OW 111
// break ;
22694: GO 22698
// end ; end ;
22696: GO 22583
22698: POP
22699: POP
// end ; end ;
22700: GO 22025
22702: POP
22703: POP
// end ;
22704: LD_VAR 0 8
22708: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22709: LD_INT 0
22711: PPUSH
// result := true ;
22712: LD_ADDR_VAR 0 3
22716: PUSH
22717: LD_INT 1
22719: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22720: LD_VAR 0 2
22724: PUSH
22725: LD_INT 24
22727: DOUBLE
22728: EQUAL
22729: IFTRUE 22739
22731: LD_INT 33
22733: DOUBLE
22734: EQUAL
22735: IFTRUE 22739
22737: GO 22764
22739: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22740: LD_ADDR_VAR 0 3
22744: PUSH
22745: LD_INT 32
22747: PPUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: CALL_OW 321
22757: PUSH
22758: LD_INT 2
22760: EQUAL
22761: ST_TO_ADDR
22762: GO 23080
22764: LD_INT 20
22766: DOUBLE
22767: EQUAL
22768: IFTRUE 22772
22770: GO 22797
22772: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22773: LD_ADDR_VAR 0 3
22777: PUSH
22778: LD_INT 6
22780: PPUSH
22781: LD_VAR 0 1
22785: PPUSH
22786: CALL_OW 321
22790: PUSH
22791: LD_INT 2
22793: EQUAL
22794: ST_TO_ADDR
22795: GO 23080
22797: LD_INT 22
22799: DOUBLE
22800: EQUAL
22801: IFTRUE 22811
22803: LD_INT 36
22805: DOUBLE
22806: EQUAL
22807: IFTRUE 22811
22809: GO 22836
22811: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22812: LD_ADDR_VAR 0 3
22816: PUSH
22817: LD_INT 15
22819: PPUSH
22820: LD_VAR 0 1
22824: PPUSH
22825: CALL_OW 321
22829: PUSH
22830: LD_INT 2
22832: EQUAL
22833: ST_TO_ADDR
22834: GO 23080
22836: LD_INT 30
22838: DOUBLE
22839: EQUAL
22840: IFTRUE 22844
22842: GO 22869
22844: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22845: LD_ADDR_VAR 0 3
22849: PUSH
22850: LD_INT 20
22852: PPUSH
22853: LD_VAR 0 1
22857: PPUSH
22858: CALL_OW 321
22862: PUSH
22863: LD_INT 2
22865: EQUAL
22866: ST_TO_ADDR
22867: GO 23080
22869: LD_INT 28
22871: DOUBLE
22872: EQUAL
22873: IFTRUE 22883
22875: LD_INT 21
22877: DOUBLE
22878: EQUAL
22879: IFTRUE 22883
22881: GO 22908
22883: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22884: LD_ADDR_VAR 0 3
22888: PUSH
22889: LD_INT 21
22891: PPUSH
22892: LD_VAR 0 1
22896: PPUSH
22897: CALL_OW 321
22901: PUSH
22902: LD_INT 2
22904: EQUAL
22905: ST_TO_ADDR
22906: GO 23080
22908: LD_INT 16
22910: DOUBLE
22911: EQUAL
22912: IFTRUE 22916
22914: GO 22941
22916: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_INT 84
22924: PPUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 321
22934: PUSH
22935: LD_INT 2
22937: EQUAL
22938: ST_TO_ADDR
22939: GO 23080
22941: LD_INT 19
22943: DOUBLE
22944: EQUAL
22945: IFTRUE 22955
22947: LD_INT 23
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22980
22955: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22956: LD_ADDR_VAR 0 3
22960: PUSH
22961: LD_INT 83
22963: PPUSH
22964: LD_VAR 0 1
22968: PPUSH
22969: CALL_OW 321
22973: PUSH
22974: LD_INT 2
22976: EQUAL
22977: ST_TO_ADDR
22978: GO 23080
22980: LD_INT 17
22982: DOUBLE
22983: EQUAL
22984: IFTRUE 22988
22986: GO 23013
22988: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22989: LD_ADDR_VAR 0 3
22993: PUSH
22994: LD_INT 39
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 321
23006: PUSH
23007: LD_INT 2
23009: EQUAL
23010: ST_TO_ADDR
23011: GO 23080
23013: LD_INT 18
23015: DOUBLE
23016: EQUAL
23017: IFTRUE 23021
23019: GO 23046
23021: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_INT 40
23029: PPUSH
23030: LD_VAR 0 1
23034: PPUSH
23035: CALL_OW 321
23039: PUSH
23040: LD_INT 2
23042: EQUAL
23043: ST_TO_ADDR
23044: GO 23080
23046: LD_INT 27
23048: DOUBLE
23049: EQUAL
23050: IFTRUE 23054
23052: GO 23079
23054: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23055: LD_ADDR_VAR 0 3
23059: PUSH
23060: LD_INT 35
23062: PPUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: CALL_OW 321
23072: PUSH
23073: LD_INT 2
23075: EQUAL
23076: ST_TO_ADDR
23077: GO 23080
23079: POP
// end ;
23080: LD_VAR 0 3
23084: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23085: LD_INT 0
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
// result := false ;
23098: LD_ADDR_VAR 0 6
23102: PUSH
23103: LD_INT 0
23105: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23106: LD_VAR 0 1
23110: NOT
23111: PUSH
23112: LD_VAR 0 1
23116: PPUSH
23117: CALL_OW 266
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: LD_INT 1
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: IN
23132: NOT
23133: OR
23134: PUSH
23135: LD_VAR 0 2
23139: NOT
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PUSH
23147: LD_INT 0
23149: PUSH
23150: LD_INT 1
23152: PUSH
23153: LD_INT 2
23155: PUSH
23156: LD_INT 3
23158: PUSH
23159: LD_INT 4
23161: PUSH
23162: LD_INT 5
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: LIST
23171: LIST
23172: IN
23173: NOT
23174: OR
23175: PUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: LD_VAR 0 4
23185: PPUSH
23186: CALL_OW 488
23190: NOT
23191: OR
23192: IFFALSE 23196
// exit ;
23194: GO 23932
// side := GetSide ( depot ) ;
23196: LD_ADDR_VAR 0 9
23200: PUSH
23201: LD_VAR 0 1
23205: PPUSH
23206: CALL_OW 255
23210: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23211: LD_VAR 0 9
23215: PPUSH
23216: LD_VAR 0 2
23220: PPUSH
23221: CALL 22709 0 2
23225: NOT
23226: IFFALSE 23230
// exit ;
23228: GO 23932
// pom := GetBase ( depot ) ;
23230: LD_ADDR_VAR 0 10
23234: PUSH
23235: LD_VAR 0 1
23239: PPUSH
23240: CALL_OW 274
23244: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23245: LD_ADDR_VAR 0 11
23249: PUSH
23250: LD_VAR 0 2
23254: PPUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 248
23264: PPUSH
23265: CALL_OW 450
23269: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23270: LD_VAR 0 10
23274: PPUSH
23275: LD_INT 1
23277: PPUSH
23278: CALL_OW 275
23282: PUSH
23283: LD_VAR 0 11
23287: PUSH
23288: LD_INT 1
23290: ARRAY
23291: GREATEREQUAL
23292: PUSH
23293: LD_VAR 0 10
23297: PPUSH
23298: LD_INT 2
23300: PPUSH
23301: CALL_OW 275
23305: PUSH
23306: LD_VAR 0 11
23310: PUSH
23311: LD_INT 2
23313: ARRAY
23314: GREATEREQUAL
23315: AND
23316: PUSH
23317: LD_VAR 0 10
23321: PPUSH
23322: LD_INT 3
23324: PPUSH
23325: CALL_OW 275
23329: PUSH
23330: LD_VAR 0 11
23334: PUSH
23335: LD_INT 3
23337: ARRAY
23338: GREATEREQUAL
23339: AND
23340: NOT
23341: IFFALSE 23345
// exit ;
23343: GO 23932
// if GetBType ( depot ) = b_depot then
23345: LD_VAR 0 1
23349: PPUSH
23350: CALL_OW 266
23354: PUSH
23355: LD_INT 0
23357: EQUAL
23358: IFFALSE 23370
// dist := 28 else
23360: LD_ADDR_VAR 0 14
23364: PUSH
23365: LD_INT 28
23367: ST_TO_ADDR
23368: GO 23378
// dist := 36 ;
23370: LD_ADDR_VAR 0 14
23374: PUSH
23375: LD_INT 36
23377: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23378: LD_VAR 0 1
23382: PPUSH
23383: LD_VAR 0 3
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: CALL_OW 297
23397: PUSH
23398: LD_VAR 0 14
23402: GREATER
23403: IFFALSE 23407
// exit ;
23405: GO 23932
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23407: LD_ADDR_VAR 0 12
23411: PUSH
23412: LD_VAR 0 2
23416: PPUSH
23417: LD_VAR 0 3
23421: PPUSH
23422: LD_VAR 0 4
23426: PPUSH
23427: LD_VAR 0 5
23431: PPUSH
23432: LD_VAR 0 1
23436: PPUSH
23437: CALL_OW 248
23441: PPUSH
23442: LD_INT 0
23444: PPUSH
23445: CALL 23937 0 6
23449: ST_TO_ADDR
// if not hexes then
23450: LD_VAR 0 12
23454: NOT
23455: IFFALSE 23459
// exit ;
23457: GO 23932
// hex := GetHexInfo ( x , y ) ;
23459: LD_ADDR_VAR 0 15
23463: PUSH
23464: LD_VAR 0 3
23468: PPUSH
23469: LD_VAR 0 4
23473: PPUSH
23474: CALL_OW 546
23478: ST_TO_ADDR
// if hex [ 1 ] then
23479: LD_VAR 0 15
23483: PUSH
23484: LD_INT 1
23486: ARRAY
23487: IFFALSE 23491
// exit ;
23489: GO 23932
// height := hex [ 2 ] ;
23491: LD_ADDR_VAR 0 13
23495: PUSH
23496: LD_VAR 0 15
23500: PUSH
23501: LD_INT 2
23503: ARRAY
23504: ST_TO_ADDR
// for i = 1 to hexes do
23505: LD_ADDR_VAR 0 7
23509: PUSH
23510: DOUBLE
23511: LD_INT 1
23513: DEC
23514: ST_TO_ADDR
23515: LD_VAR 0 12
23519: PUSH
23520: FOR_TO
23521: IFFALSE 23851
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23523: LD_VAR 0 12
23527: PUSH
23528: LD_VAR 0 7
23532: ARRAY
23533: PUSH
23534: LD_INT 1
23536: ARRAY
23537: PPUSH
23538: LD_VAR 0 12
23542: PUSH
23543: LD_VAR 0 7
23547: ARRAY
23548: PUSH
23549: LD_INT 2
23551: ARRAY
23552: PPUSH
23553: CALL_OW 488
23557: NOT
23558: PUSH
23559: LD_VAR 0 12
23563: PUSH
23564: LD_VAR 0 7
23568: ARRAY
23569: PUSH
23570: LD_INT 1
23572: ARRAY
23573: PPUSH
23574: LD_VAR 0 12
23578: PUSH
23579: LD_VAR 0 7
23583: ARRAY
23584: PUSH
23585: LD_INT 2
23587: ARRAY
23588: PPUSH
23589: CALL_OW 428
23593: PUSH
23594: LD_INT 0
23596: GREATER
23597: OR
23598: PUSH
23599: LD_VAR 0 12
23603: PUSH
23604: LD_VAR 0 7
23608: ARRAY
23609: PUSH
23610: LD_INT 1
23612: ARRAY
23613: PPUSH
23614: LD_VAR 0 12
23618: PUSH
23619: LD_VAR 0 7
23623: ARRAY
23624: PUSH
23625: LD_INT 2
23627: ARRAY
23628: PPUSH
23629: CALL_OW 351
23633: OR
23634: IFFALSE 23640
// exit ;
23636: POP
23637: POP
23638: GO 23932
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23640: LD_ADDR_VAR 0 8
23644: PUSH
23645: LD_VAR 0 12
23649: PUSH
23650: LD_VAR 0 7
23654: ARRAY
23655: PUSH
23656: LD_INT 1
23658: ARRAY
23659: PPUSH
23660: LD_VAR 0 12
23664: PUSH
23665: LD_VAR 0 7
23669: ARRAY
23670: PUSH
23671: LD_INT 2
23673: ARRAY
23674: PPUSH
23675: CALL_OW 546
23679: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23680: LD_VAR 0 8
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PUSH
23689: LD_VAR 0 8
23693: PUSH
23694: LD_INT 2
23696: ARRAY
23697: PUSH
23698: LD_VAR 0 13
23702: PUSH
23703: LD_INT 2
23705: PLUS
23706: GREATER
23707: OR
23708: PUSH
23709: LD_VAR 0 8
23713: PUSH
23714: LD_INT 2
23716: ARRAY
23717: PUSH
23718: LD_VAR 0 13
23722: PUSH
23723: LD_INT 2
23725: MINUS
23726: LESS
23727: OR
23728: PUSH
23729: LD_VAR 0 8
23733: PUSH
23734: LD_INT 3
23736: ARRAY
23737: PUSH
23738: LD_INT 0
23740: PUSH
23741: LD_INT 8
23743: PUSH
23744: LD_INT 9
23746: PUSH
23747: LD_INT 10
23749: PUSH
23750: LD_INT 11
23752: PUSH
23753: LD_INT 12
23755: PUSH
23756: LD_INT 13
23758: PUSH
23759: LD_INT 16
23761: PUSH
23762: LD_INT 17
23764: PUSH
23765: LD_INT 18
23767: PUSH
23768: LD_INT 19
23770: PUSH
23771: LD_INT 20
23773: PUSH
23774: LD_INT 21
23776: PUSH
23777: EMPTY
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: IN
23792: NOT
23793: OR
23794: PUSH
23795: LD_VAR 0 8
23799: PUSH
23800: LD_INT 5
23802: ARRAY
23803: NOT
23804: OR
23805: PUSH
23806: LD_VAR 0 8
23810: PUSH
23811: LD_INT 6
23813: ARRAY
23814: PUSH
23815: LD_INT 1
23817: PUSH
23818: LD_INT 2
23820: PUSH
23821: LD_INT 7
23823: PUSH
23824: LD_INT 9
23826: PUSH
23827: LD_INT 10
23829: PUSH
23830: LD_INT 11
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: IN
23841: NOT
23842: OR
23843: IFFALSE 23849
// exit ;
23845: POP
23846: POP
23847: GO 23932
// end ;
23849: GO 23520
23851: POP
23852: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23853: LD_VAR 0 9
23857: PPUSH
23858: LD_VAR 0 3
23862: PPUSH
23863: LD_VAR 0 4
23867: PPUSH
23868: LD_INT 20
23870: PPUSH
23871: CALL 15884 0 4
23875: PUSH
23876: LD_INT 4
23878: ARRAY
23879: IFFALSE 23883
// exit ;
23881: GO 23932
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23883: LD_VAR 0 2
23887: PUSH
23888: LD_INT 29
23890: PUSH
23891: LD_INT 30
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: IN
23898: PUSH
23899: LD_VAR 0 3
23903: PPUSH
23904: LD_VAR 0 4
23908: PPUSH
23909: LD_VAR 0 9
23913: PPUSH
23914: CALL_OW 440
23918: NOT
23919: AND
23920: IFFALSE 23924
// exit ;
23922: GO 23932
// result := true ;
23924: LD_ADDR_VAR 0 6
23928: PUSH
23929: LD_INT 1
23931: ST_TO_ADDR
// end ;
23932: LD_VAR 0 6
23936: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23937: LD_INT 0
23939: PPUSH
23940: PPUSH
23941: PPUSH
23942: PPUSH
23943: PPUSH
23944: PPUSH
23945: PPUSH
23946: PPUSH
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
23976: PPUSH
23977: PPUSH
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
// result = [ ] ;
23997: LD_ADDR_VAR 0 7
24001: PUSH
24002: EMPTY
24003: ST_TO_ADDR
// temp_list = [ ] ;
24004: LD_ADDR_VAR 0 9
24008: PUSH
24009: EMPTY
24010: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24011: LD_VAR 0 4
24015: PUSH
24016: LD_INT 0
24018: PUSH
24019: LD_INT 1
24021: PUSH
24022: LD_INT 2
24024: PUSH
24025: LD_INT 3
24027: PUSH
24028: LD_INT 4
24030: PUSH
24031: LD_INT 5
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: IN
24042: NOT
24043: PUSH
24044: LD_VAR 0 1
24048: PUSH
24049: LD_INT 0
24051: PUSH
24052: LD_INT 1
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: IN
24059: PUSH
24060: LD_VAR 0 5
24064: PUSH
24065: LD_INT 1
24067: PUSH
24068: LD_INT 2
24070: PUSH
24071: LD_INT 3
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: LIST
24078: IN
24079: NOT
24080: AND
24081: OR
24082: IFFALSE 24086
// exit ;
24084: GO 42477
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24086: LD_VAR 0 1
24090: PUSH
24091: LD_INT 6
24093: PUSH
24094: LD_INT 7
24096: PUSH
24097: LD_INT 8
24099: PUSH
24100: LD_INT 13
24102: PUSH
24103: LD_INT 12
24105: PUSH
24106: LD_INT 15
24108: PUSH
24109: LD_INT 11
24111: PUSH
24112: LD_INT 14
24114: PUSH
24115: LD_INT 10
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: IN
24129: IFFALSE 24139
// btype = b_lab ;
24131: LD_ADDR_VAR 0 1
24135: PUSH
24136: LD_INT 6
24138: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_INT 0
24146: PUSH
24147: LD_INT 1
24149: PUSH
24150: LD_INT 2
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: IN
24158: NOT
24159: PUSH
24160: LD_VAR 0 1
24164: PUSH
24165: LD_INT 0
24167: PUSH
24168: LD_INT 1
24170: PUSH
24171: LD_INT 2
24173: PUSH
24174: LD_INT 3
24176: PUSH
24177: LD_INT 6
24179: PUSH
24180: LD_INT 36
24182: PUSH
24183: LD_INT 4
24185: PUSH
24186: LD_INT 5
24188: PUSH
24189: LD_INT 31
24191: PUSH
24192: LD_INT 32
24194: PUSH
24195: LD_INT 33
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: IN
24211: NOT
24212: PUSH
24213: LD_VAR 0 6
24217: PUSH
24218: LD_INT 1
24220: EQUAL
24221: AND
24222: OR
24223: PUSH
24224: LD_VAR 0 1
24228: PUSH
24229: LD_INT 2
24231: PUSH
24232: LD_INT 3
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: IN
24239: NOT
24240: PUSH
24241: LD_VAR 0 6
24245: PUSH
24246: LD_INT 2
24248: EQUAL
24249: AND
24250: OR
24251: IFFALSE 24261
// mode = 0 ;
24253: LD_ADDR_VAR 0 6
24257: PUSH
24258: LD_INT 0
24260: ST_TO_ADDR
// case mode of 0 :
24261: LD_VAR 0 6
24265: PUSH
24266: LD_INT 0
24268: DOUBLE
24269: EQUAL
24270: IFTRUE 24274
24272: GO 35727
24274: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24275: LD_ADDR_VAR 0 11
24279: PUSH
24280: LD_INT 0
24282: PUSH
24283: LD_INT 0
24285: PUSH
24286: EMPTY
24287: LIST
24288: LIST
24289: PUSH
24290: LD_INT 0
24292: PUSH
24293: LD_INT 1
24295: NEG
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: LD_INT 1
24303: PUSH
24304: LD_INT 0
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 1
24313: PUSH
24314: LD_INT 1
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: LD_INT 0
24323: PUSH
24324: LD_INT 1
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PUSH
24331: LD_INT 1
24333: NEG
24334: PUSH
24335: LD_INT 0
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: LD_INT 1
24344: NEG
24345: PUSH
24346: LD_INT 1
24348: NEG
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PUSH
24354: LD_INT 1
24356: NEG
24357: PUSH
24358: LD_INT 2
24360: NEG
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 0
24368: PUSH
24369: LD_INT 2
24371: NEG
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PUSH
24377: LD_INT 1
24379: PUSH
24380: LD_INT 1
24382: NEG
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 1
24390: PUSH
24391: LD_INT 2
24393: PUSH
24394: EMPTY
24395: LIST
24396: LIST
24397: PUSH
24398: LD_INT 0
24400: PUSH
24401: LD_INT 2
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: PUSH
24408: LD_INT 1
24410: NEG
24411: PUSH
24412: LD_INT 1
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: PUSH
24419: LD_INT 1
24421: PUSH
24422: LD_INT 3
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 0
24431: PUSH
24432: LD_INT 3
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PUSH
24439: LD_INT 1
24441: NEG
24442: PUSH
24443: LD_INT 2
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24468: LD_ADDR_VAR 0 12
24472: PUSH
24473: LD_INT 0
24475: PUSH
24476: LD_INT 0
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: PUSH
24483: LD_INT 0
24485: PUSH
24486: LD_INT 1
24488: NEG
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: LD_INT 1
24496: PUSH
24497: LD_INT 0
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 1
24506: PUSH
24507: LD_INT 1
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 0
24516: PUSH
24517: LD_INT 1
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 1
24526: NEG
24527: PUSH
24528: LD_INT 0
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 1
24537: NEG
24538: PUSH
24539: LD_INT 1
24541: NEG
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: PUSH
24547: LD_INT 1
24549: PUSH
24550: LD_INT 1
24552: NEG
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 2
24560: PUSH
24561: LD_INT 0
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PUSH
24568: LD_INT 2
24570: PUSH
24571: LD_INT 1
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: PUSH
24582: LD_INT 1
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 2
24591: NEG
24592: PUSH
24593: LD_INT 0
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 2
24602: NEG
24603: PUSH
24604: LD_INT 1
24606: NEG
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 2
24614: NEG
24615: PUSH
24616: LD_INT 1
24618: PUSH
24619: EMPTY
24620: LIST
24621: LIST
24622: PUSH
24623: LD_INT 3
24625: NEG
24626: PUSH
24627: LD_INT 0
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PUSH
24634: LD_INT 3
24636: NEG
24637: PUSH
24638: LD_INT 1
24640: NEG
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24664: LD_ADDR_VAR 0 13
24668: PUSH
24669: LD_INT 0
24671: PUSH
24672: LD_INT 0
24674: PUSH
24675: EMPTY
24676: LIST
24677: LIST
24678: PUSH
24679: LD_INT 0
24681: PUSH
24682: LD_INT 1
24684: NEG
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: LD_INT 0
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: LD_INT 1
24705: PUSH
24706: EMPTY
24707: LIST
24708: LIST
24709: PUSH
24710: LD_INT 0
24712: PUSH
24713: LD_INT 1
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: PUSH
24720: LD_INT 1
24722: NEG
24723: PUSH
24724: LD_INT 0
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PUSH
24731: LD_INT 1
24733: NEG
24734: PUSH
24735: LD_INT 1
24737: NEG
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PUSH
24743: LD_INT 1
24745: NEG
24746: PUSH
24747: LD_INT 2
24749: NEG
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 2
24757: PUSH
24758: LD_INT 1
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: LD_INT 2
24767: PUSH
24768: LD_INT 2
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 1
24777: PUSH
24778: LD_INT 2
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 2
24787: NEG
24788: PUSH
24789: LD_INT 1
24791: NEG
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 2
24799: NEG
24800: PUSH
24801: LD_INT 2
24803: NEG
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 2
24811: NEG
24812: PUSH
24813: LD_INT 3
24815: NEG
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 3
24823: NEG
24824: PUSH
24825: LD_INT 2
24827: NEG
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 3
24835: NEG
24836: PUSH
24837: LD_INT 3
24839: NEG
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24863: LD_ADDR_VAR 0 14
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: LD_INT 0
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 0
24880: PUSH
24881: LD_INT 1
24883: NEG
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: PUSH
24889: LD_INT 1
24891: PUSH
24892: LD_INT 0
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: PUSH
24899: LD_INT 1
24901: PUSH
24902: LD_INT 1
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 0
24911: PUSH
24912: LD_INT 1
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 1
24921: NEG
24922: PUSH
24923: LD_INT 0
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 1
24932: NEG
24933: PUSH
24934: LD_INT 1
24936: NEG
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: LD_INT 2
24948: NEG
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: PUSH
24954: LD_INT 0
24956: PUSH
24957: LD_INT 2
24959: NEG
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: LD_INT 1
24967: PUSH
24968: LD_INT 1
24970: NEG
24971: PUSH
24972: EMPTY
24973: LIST
24974: LIST
24975: PUSH
24976: LD_INT 1
24978: PUSH
24979: LD_INT 2
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: LD_INT 0
24988: PUSH
24989: LD_INT 2
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PUSH
24996: LD_INT 1
24998: NEG
24999: PUSH
25000: LD_INT 1
25002: PUSH
25003: EMPTY
25004: LIST
25005: LIST
25006: PUSH
25007: LD_INT 1
25009: NEG
25010: PUSH
25011: LD_INT 3
25013: NEG
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 0
25021: PUSH
25022: LD_INT 3
25024: NEG
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: LD_INT 1
25032: PUSH
25033: LD_INT 2
25035: NEG
25036: PUSH
25037: EMPTY
25038: LIST
25039: LIST
25040: PUSH
25041: EMPTY
25042: LIST
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25059: LD_ADDR_VAR 0 15
25063: PUSH
25064: LD_INT 0
25066: PUSH
25067: LD_INT 0
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 0
25076: PUSH
25077: LD_INT 1
25079: NEG
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: PUSH
25085: LD_INT 1
25087: PUSH
25088: LD_INT 0
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 1
25097: PUSH
25098: LD_INT 1
25100: PUSH
25101: EMPTY
25102: LIST
25103: LIST
25104: PUSH
25105: LD_INT 0
25107: PUSH
25108: LD_INT 1
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: PUSH
25115: LD_INT 1
25117: NEG
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: LD_INT 1
25128: NEG
25129: PUSH
25130: LD_INT 1
25132: NEG
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 1
25140: PUSH
25141: LD_INT 1
25143: NEG
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: PUSH
25149: LD_INT 2
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: LD_INT 2
25161: PUSH
25162: LD_INT 1
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 1
25171: NEG
25172: PUSH
25173: LD_INT 1
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 2
25182: NEG
25183: PUSH
25184: LD_INT 0
25186: PUSH
25187: EMPTY
25188: LIST
25189: LIST
25190: PUSH
25191: LD_INT 2
25193: NEG
25194: PUSH
25195: LD_INT 1
25197: NEG
25198: PUSH
25199: EMPTY
25200: LIST
25201: LIST
25202: PUSH
25203: LD_INT 2
25205: PUSH
25206: LD_INT 1
25208: NEG
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: LD_INT 0
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: PUSH
25224: LD_INT 3
25226: PUSH
25227: LD_INT 1
25229: PUSH
25230: EMPTY
25231: LIST
25232: LIST
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25252: LD_ADDR_VAR 0 16
25256: PUSH
25257: LD_INT 0
25259: PUSH
25260: LD_INT 0
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: LD_INT 0
25269: PUSH
25270: LD_INT 1
25272: NEG
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: PUSH
25281: LD_INT 0
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: LD_INT 1
25290: PUSH
25291: LD_INT 1
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 1
25310: NEG
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: NEG
25322: PUSH
25323: LD_INT 1
25325: NEG
25326: PUSH
25327: EMPTY
25328: LIST
25329: LIST
25330: PUSH
25331: LD_INT 1
25333: NEG
25334: PUSH
25335: LD_INT 2
25337: NEG
25338: PUSH
25339: EMPTY
25340: LIST
25341: LIST
25342: PUSH
25343: LD_INT 2
25345: PUSH
25346: LD_INT 1
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: PUSH
25353: LD_INT 2
25355: PUSH
25356: LD_INT 2
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: LD_INT 1
25365: PUSH
25366: LD_INT 2
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 2
25375: NEG
25376: PUSH
25377: LD_INT 1
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 2
25387: NEG
25388: PUSH
25389: LD_INT 2
25391: NEG
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 3
25399: PUSH
25400: LD_INT 2
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 3
25409: PUSH
25410: LD_INT 3
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 2
25419: PUSH
25420: LD_INT 3
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25445: LD_ADDR_VAR 0 17
25449: PUSH
25450: LD_INT 0
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: EMPTY
25457: LIST
25458: LIST
25459: PUSH
25460: LD_INT 0
25462: PUSH
25463: LD_INT 1
25465: NEG
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 1
25473: PUSH
25474: LD_INT 0
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: LD_INT 1
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 1
25503: NEG
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: NEG
25515: PUSH
25516: LD_INT 1
25518: NEG
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: PUSH
25524: LD_INT 1
25526: NEG
25527: PUSH
25528: LD_INT 2
25530: NEG
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 2
25541: NEG
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 1
25549: PUSH
25550: LD_INT 1
25552: NEG
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 2
25560: PUSH
25561: LD_INT 0
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 2
25570: PUSH
25571: LD_INT 1
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: LD_INT 2
25580: PUSH
25581: LD_INT 2
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 1
25590: PUSH
25591: LD_INT 2
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 0
25600: PUSH
25601: LD_INT 2
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 1
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 2
25621: NEG
25622: PUSH
25623: LD_INT 0
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 2
25632: NEG
25633: PUSH
25634: LD_INT 1
25636: NEG
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 2
25644: NEG
25645: PUSH
25646: LD_INT 2
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25675: LD_ADDR_VAR 0 18
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 0
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 1
25703: PUSH
25704: LD_INT 0
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: LD_INT 1
25716: PUSH
25717: EMPTY
25718: LIST
25719: LIST
25720: PUSH
25721: LD_INT 0
25723: PUSH
25724: LD_INT 1
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 1
25733: NEG
25734: PUSH
25735: LD_INT 0
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 1
25744: NEG
25745: PUSH
25746: LD_INT 1
25748: NEG
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 1
25756: NEG
25757: PUSH
25758: LD_INT 2
25760: NEG
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: LD_INT 2
25771: NEG
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PUSH
25777: LD_INT 1
25779: PUSH
25780: LD_INT 1
25782: NEG
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 2
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 2
25800: PUSH
25801: LD_INT 1
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 2
25810: PUSH
25811: LD_INT 2
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: LD_INT 1
25820: PUSH
25821: LD_INT 2
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 0
25830: PUSH
25831: LD_INT 2
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 1
25840: NEG
25841: PUSH
25842: LD_INT 1
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 2
25851: NEG
25852: PUSH
25853: LD_INT 0
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: NEG
25863: PUSH
25864: LD_INT 1
25866: NEG
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 2
25874: NEG
25875: PUSH
25876: LD_INT 2
25878: NEG
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25905: LD_ADDR_VAR 0 19
25909: PUSH
25910: LD_INT 0
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: PUSH
25920: LD_INT 0
25922: PUSH
25923: LD_INT 1
25925: NEG
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PUSH
25931: LD_INT 1
25933: PUSH
25934: LD_INT 0
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: LD_INT 1
25943: PUSH
25944: LD_INT 1
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PUSH
25951: LD_INT 0
25953: PUSH
25954: LD_INT 1
25956: PUSH
25957: EMPTY
25958: LIST
25959: LIST
25960: PUSH
25961: LD_INT 1
25963: NEG
25964: PUSH
25965: LD_INT 0
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PUSH
25972: LD_INT 1
25974: NEG
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: NEG
25987: PUSH
25988: LD_INT 2
25990: NEG
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 0
25998: PUSH
25999: LD_INT 2
26001: NEG
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 1
26009: PUSH
26010: LD_INT 1
26012: NEG
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 2
26020: PUSH
26021: LD_INT 0
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 2
26030: PUSH
26031: LD_INT 1
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 2
26040: PUSH
26041: LD_INT 2
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: LD_INT 1
26050: PUSH
26051: LD_INT 2
26053: PUSH
26054: EMPTY
26055: LIST
26056: LIST
26057: PUSH
26058: LD_INT 0
26060: PUSH
26061: LD_INT 2
26063: PUSH
26064: EMPTY
26065: LIST
26066: LIST
26067: PUSH
26068: LD_INT 1
26070: NEG
26071: PUSH
26072: LD_INT 1
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 2
26081: NEG
26082: PUSH
26083: LD_INT 0
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: PUSH
26090: LD_INT 2
26092: NEG
26093: PUSH
26094: LD_INT 1
26096: NEG
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 2
26104: NEG
26105: PUSH
26106: LD_INT 2
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26135: LD_ADDR_VAR 0 20
26139: PUSH
26140: LD_INT 0
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 0
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: LD_INT 1
26163: PUSH
26164: LD_INT 0
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 1
26173: PUSH
26174: LD_INT 1
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: PUSH
26181: LD_INT 0
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PUSH
26191: LD_INT 1
26193: NEG
26194: PUSH
26195: LD_INT 0
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: PUSH
26202: LD_INT 1
26204: NEG
26205: PUSH
26206: LD_INT 1
26208: NEG
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: LD_INT 2
26220: NEG
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 0
26228: PUSH
26229: LD_INT 2
26231: NEG
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 1
26239: PUSH
26240: LD_INT 1
26242: NEG
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 2
26250: PUSH
26251: LD_INT 0
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 2
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 2
26270: PUSH
26271: LD_INT 2
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 1
26280: PUSH
26281: LD_INT 2
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: LD_INT 0
26290: PUSH
26291: LD_INT 2
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 1
26300: NEG
26301: PUSH
26302: LD_INT 1
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 2
26311: NEG
26312: PUSH
26313: LD_INT 0
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 2
26322: NEG
26323: PUSH
26324: LD_INT 1
26326: NEG
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 2
26334: NEG
26335: PUSH
26336: LD_INT 2
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: LIST
26348: LIST
26349: LIST
26350: LIST
26351: LIST
26352: LIST
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26365: LD_ADDR_VAR 0 21
26369: PUSH
26370: LD_INT 0
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 0
26382: PUSH
26383: LD_INT 1
26385: NEG
26386: PUSH
26387: EMPTY
26388: LIST
26389: LIST
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: LD_INT 0
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: LD_INT 1
26406: PUSH
26407: EMPTY
26408: LIST
26409: LIST
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_INT 1
26416: PUSH
26417: EMPTY
26418: LIST
26419: LIST
26420: PUSH
26421: LD_INT 1
26423: NEG
26424: PUSH
26425: LD_INT 0
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 1
26434: NEG
26435: PUSH
26436: LD_INT 1
26438: NEG
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 1
26446: NEG
26447: PUSH
26448: LD_INT 2
26450: NEG
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 0
26458: PUSH
26459: LD_INT 2
26461: NEG
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PUSH
26467: LD_INT 1
26469: PUSH
26470: LD_INT 1
26472: NEG
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 2
26480: PUSH
26481: LD_INT 0
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 2
26490: PUSH
26491: LD_INT 1
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: LD_INT 2
26500: PUSH
26501: LD_INT 2
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: LD_INT 1
26510: PUSH
26511: LD_INT 2
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: LD_INT 0
26520: PUSH
26521: LD_INT 2
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 1
26530: NEG
26531: PUSH
26532: LD_INT 1
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 2
26541: NEG
26542: PUSH
26543: LD_INT 0
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 2
26552: NEG
26553: PUSH
26554: LD_INT 1
26556: NEG
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: PUSH
26562: LD_INT 2
26564: NEG
26565: PUSH
26566: LD_INT 2
26568: NEG
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: LIST
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26595: LD_ADDR_VAR 0 22
26599: PUSH
26600: LD_INT 0
26602: PUSH
26603: LD_INT 0
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: PUSH
26610: LD_INT 0
26612: PUSH
26613: LD_INT 1
26615: NEG
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 1
26623: PUSH
26624: LD_INT 0
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: LD_INT 1
26633: PUSH
26634: LD_INT 1
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 0
26643: PUSH
26644: LD_INT 1
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 1
26653: NEG
26654: PUSH
26655: LD_INT 0
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: LD_INT 1
26664: NEG
26665: PUSH
26666: LD_INT 1
26668: NEG
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: LD_INT 1
26676: NEG
26677: PUSH
26678: LD_INT 2
26680: NEG
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 0
26688: PUSH
26689: LD_INT 2
26691: NEG
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 1
26699: PUSH
26700: LD_INT 1
26702: NEG
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 2
26710: PUSH
26711: LD_INT 0
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 2
26720: PUSH
26721: LD_INT 1
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: LD_INT 2
26730: PUSH
26731: LD_INT 2
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: LD_INT 1
26740: PUSH
26741: LD_INT 2
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: LD_INT 0
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: NEG
26761: PUSH
26762: LD_INT 1
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 2
26771: NEG
26772: PUSH
26773: LD_INT 0
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: LD_INT 2
26782: NEG
26783: PUSH
26784: LD_INT 1
26786: NEG
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: PUSH
26792: LD_INT 2
26794: NEG
26795: PUSH
26796: LD_INT 2
26798: NEG
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26825: LD_ADDR_VAR 0 23
26829: PUSH
26830: LD_INT 0
26832: PUSH
26833: LD_INT 0
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 0
26842: PUSH
26843: LD_INT 1
26845: NEG
26846: PUSH
26847: EMPTY
26848: LIST
26849: LIST
26850: PUSH
26851: LD_INT 1
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 1
26863: PUSH
26864: LD_INT 1
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 0
26873: PUSH
26874: LD_INT 1
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 1
26883: NEG
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: LD_INT 1
26898: NEG
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PUSH
26904: LD_INT 1
26906: NEG
26907: PUSH
26908: LD_INT 2
26910: NEG
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 0
26918: PUSH
26919: LD_INT 2
26921: NEG
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 1
26929: PUSH
26930: LD_INT 1
26932: NEG
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: PUSH
26938: LD_INT 2
26940: PUSH
26941: LD_INT 0
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: PUSH
26948: LD_INT 2
26950: PUSH
26951: LD_INT 1
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: PUSH
26958: LD_INT 2
26960: PUSH
26961: LD_INT 2
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 1
26970: PUSH
26971: LD_INT 2
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 0
26980: PUSH
26981: LD_INT 2
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: LD_INT 1
26990: NEG
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 2
27001: NEG
27002: PUSH
27003: LD_INT 0
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 2
27012: NEG
27013: PUSH
27014: LD_INT 1
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: LD_INT 2
27028: NEG
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 2
27036: NEG
27037: PUSH
27038: LD_INT 3
27040: NEG
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 1
27048: NEG
27049: PUSH
27050: LD_INT 3
27052: NEG
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 1
27060: PUSH
27061: LD_INT 2
27063: NEG
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: LD_INT 1
27074: NEG
27075: PUSH
27076: EMPTY
27077: LIST
27078: LIST
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27105: LD_ADDR_VAR 0 24
27109: PUSH
27110: LD_INT 0
27112: PUSH
27113: LD_INT 0
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PUSH
27120: LD_INT 0
27122: PUSH
27123: LD_INT 1
27125: NEG
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 1
27133: PUSH
27134: LD_INT 0
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 1
27143: PUSH
27144: LD_INT 1
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: LD_INT 1
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: LD_INT 0
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: LD_INT 1
27174: NEG
27175: PUSH
27176: LD_INT 1
27178: NEG
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PUSH
27184: LD_INT 1
27186: NEG
27187: PUSH
27188: LD_INT 2
27190: NEG
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: LD_INT 0
27198: PUSH
27199: LD_INT 2
27201: NEG
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 1
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 2
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 2
27230: PUSH
27231: LD_INT 1
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: LD_INT 2
27240: PUSH
27241: LD_INT 2
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 1
27250: PUSH
27251: LD_INT 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 0
27260: PUSH
27261: LD_INT 2
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 1
27270: NEG
27271: PUSH
27272: LD_INT 1
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 2
27281: NEG
27282: PUSH
27283: LD_INT 0
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PUSH
27290: LD_INT 2
27292: NEG
27293: PUSH
27294: LD_INT 1
27296: NEG
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: PUSH
27302: LD_INT 2
27304: NEG
27305: PUSH
27306: LD_INT 2
27308: NEG
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 2
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 3
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 3
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27381: LD_ADDR_VAR 0 25
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: LD_INT 0
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 0
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: LD_INT 1
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 0
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: EMPTY
27434: LIST
27435: LIST
27436: PUSH
27437: LD_INT 1
27439: NEG
27440: PUSH
27441: LD_INT 0
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 1
27450: NEG
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: LD_INT 2
27466: NEG
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 0
27474: PUSH
27475: LD_INT 2
27477: NEG
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: PUSH
27483: LD_INT 1
27485: PUSH
27486: LD_INT 1
27488: NEG
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 2
27496: PUSH
27497: LD_INT 0
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 1
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: PUSH
27517: LD_INT 2
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 1
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 0
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 1
27546: NEG
27547: PUSH
27548: LD_INT 1
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: PUSH
27555: LD_INT 2
27557: NEG
27558: PUSH
27559: LD_INT 0
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 2
27568: NEG
27569: PUSH
27570: LD_INT 1
27572: NEG
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 2
27580: NEG
27581: PUSH
27582: LD_INT 2
27584: NEG
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 3
27592: PUSH
27593: LD_INT 1
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 3
27602: PUSH
27603: LD_INT 2
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 2
27612: PUSH
27613: LD_INT 3
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: PUSH
27623: LD_INT 3
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27655: LD_ADDR_VAR 0 26
27659: PUSH
27660: LD_INT 0
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 0
27672: PUSH
27673: LD_INT 1
27675: NEG
27676: PUSH
27677: EMPTY
27678: LIST
27679: LIST
27680: PUSH
27681: LD_INT 1
27683: PUSH
27684: LD_INT 0
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 1
27693: PUSH
27694: LD_INT 1
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: PUSH
27701: LD_INT 0
27703: PUSH
27704: LD_INT 1
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: LD_INT 1
27713: NEG
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 1
27724: NEG
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: LD_INT 2
27740: NEG
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 0
27748: PUSH
27749: LD_INT 2
27751: NEG
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 1
27759: PUSH
27760: LD_INT 1
27762: NEG
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 2
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: LD_INT 2
27780: PUSH
27781: LD_INT 1
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 2
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 1
27800: PUSH
27801: LD_INT 2
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 0
27810: PUSH
27811: LD_INT 2
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: LD_INT 2
27831: NEG
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 2
27842: NEG
27843: PUSH
27844: LD_INT 1
27846: NEG
27847: PUSH
27848: EMPTY
27849: LIST
27850: LIST
27851: PUSH
27852: LD_INT 2
27854: NEG
27855: PUSH
27856: LD_INT 2
27858: NEG
27859: PUSH
27860: EMPTY
27861: LIST
27862: LIST
27863: PUSH
27864: LD_INT 2
27866: PUSH
27867: LD_INT 3
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: LD_INT 3
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 1
27886: NEG
27887: PUSH
27888: LD_INT 2
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PUSH
27895: LD_INT 2
27897: NEG
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27931: LD_ADDR_VAR 0 27
27935: PUSH
27936: LD_INT 0
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 1
27951: NEG
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PUSH
27957: LD_INT 1
27959: PUSH
27960: LD_INT 0
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 1
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 1
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 0
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: LD_INT 1
28000: NEG
28001: PUSH
28002: LD_INT 1
28004: NEG
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 1
28012: NEG
28013: PUSH
28014: LD_INT 2
28016: NEG
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: LD_INT 2
28027: NEG
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 1
28035: PUSH
28036: LD_INT 1
28038: NEG
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 0
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 2
28056: PUSH
28057: LD_INT 1
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 2
28066: PUSH
28067: LD_INT 2
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: LD_INT 1
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 0
28086: PUSH
28087: LD_INT 2
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: PUSH
28094: LD_INT 1
28096: NEG
28097: PUSH
28098: LD_INT 1
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 2
28107: NEG
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: NEG
28119: PUSH
28120: LD_INT 1
28122: NEG
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: NEG
28131: PUSH
28132: LD_INT 2
28134: NEG
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PUSH
28140: LD_INT 1
28142: NEG
28143: PUSH
28144: LD_INT 2
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 2
28153: NEG
28154: PUSH
28155: LD_INT 1
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 3
28164: NEG
28165: PUSH
28166: LD_INT 1
28168: NEG
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 3
28176: NEG
28177: PUSH
28178: LD_INT 2
28180: NEG
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28211: LD_ADDR_VAR 0 28
28215: PUSH
28216: LD_INT 0
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 0
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 1
28239: PUSH
28240: LD_INT 0
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 1
28249: PUSH
28250: LD_INT 1
28252: PUSH
28253: EMPTY
28254: LIST
28255: LIST
28256: PUSH
28257: LD_INT 0
28259: PUSH
28260: LD_INT 1
28262: PUSH
28263: EMPTY
28264: LIST
28265: LIST
28266: PUSH
28267: LD_INT 1
28269: NEG
28270: PUSH
28271: LD_INT 0
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 1
28280: NEG
28281: PUSH
28282: LD_INT 1
28284: NEG
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: LD_INT 2
28296: NEG
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: PUSH
28302: LD_INT 0
28304: PUSH
28305: LD_INT 2
28307: NEG
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 1
28315: PUSH
28316: LD_INT 1
28318: NEG
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PUSH
28324: LD_INT 2
28326: PUSH
28327: LD_INT 0
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 2
28336: PUSH
28337: LD_INT 1
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 2
28346: PUSH
28347: LD_INT 2
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 1
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 0
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: PUSH
28385: LD_INT 2
28387: NEG
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PUSH
28396: LD_INT 2
28398: NEG
28399: PUSH
28400: LD_INT 1
28402: NEG
28403: PUSH
28404: EMPTY
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 2
28410: NEG
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: LD_INT 3
28426: NEG
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: NEG
28435: PUSH
28436: LD_INT 3
28438: NEG
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 3
28446: NEG
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 3
28458: NEG
28459: PUSH
28460: LD_INT 2
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28493: LD_ADDR_VAR 0 29
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: LD_INT 0
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 0
28510: PUSH
28511: LD_INT 1
28513: NEG
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: LD_INT 1
28521: PUSH
28522: LD_INT 0
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 0
28541: PUSH
28542: LD_INT 1
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: NEG
28552: PUSH
28553: LD_INT 0
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 1
28562: NEG
28563: PUSH
28564: LD_INT 1
28566: NEG
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 1
28574: NEG
28575: PUSH
28576: LD_INT 2
28578: NEG
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PUSH
28584: LD_INT 0
28586: PUSH
28587: LD_INT 2
28589: NEG
28590: PUSH
28591: EMPTY
28592: LIST
28593: LIST
28594: PUSH
28595: LD_INT 1
28597: PUSH
28598: LD_INT 1
28600: NEG
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 2
28608: PUSH
28609: LD_INT 0
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 2
28618: PUSH
28619: LD_INT 1
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: LD_INT 2
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 2
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: NEG
28649: PUSH
28650: LD_INT 1
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 2
28659: NEG
28660: PUSH
28661: LD_INT 1
28663: NEG
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 2
28671: NEG
28672: PUSH
28673: LD_INT 2
28675: NEG
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: LD_INT 3
28687: NEG
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 2
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 3
28706: PUSH
28707: LD_INT 1
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: LD_INT 3
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 3
28737: NEG
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28772: LD_ADDR_VAR 0 30
28776: PUSH
28777: LD_INT 0
28779: PUSH
28780: LD_INT 0
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 1
28792: NEG
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 1
28800: PUSH
28801: LD_INT 0
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: PUSH
28811: LD_INT 1
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 1
28830: NEG
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 1
28841: NEG
28842: PUSH
28843: LD_INT 1
28845: NEG
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: PUSH
28851: LD_INT 1
28853: NEG
28854: PUSH
28855: LD_INT 2
28857: NEG
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 2
28868: NEG
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: LD_INT 1
28879: NEG
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 2
28887: PUSH
28888: LD_INT 0
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 2
28897: PUSH
28898: LD_INT 1
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: LD_INT 2
28907: PUSH
28908: LD_INT 2
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: LD_INT 2
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: LD_INT 1
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 2
28938: NEG
28939: PUSH
28940: LD_INT 0
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 2
28949: NEG
28950: PUSH
28951: LD_INT 1
28953: NEG
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 1
28961: NEG
28962: PUSH
28963: LD_INT 3
28965: NEG
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 1
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 2
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 2
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 2
29004: NEG
29005: PUSH
29006: LD_INT 1
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 3
29015: NEG
29016: PUSH
29017: LD_INT 1
29019: NEG
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29050: LD_ADDR_VAR 0 31
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: LD_INT 0
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: LD_INT 1
29070: NEG
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: LD_INT 0
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: LD_INT 1
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 0
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: NEG
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: LD_INT 1
29123: NEG
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 1
29131: NEG
29132: PUSH
29133: LD_INT 2
29135: NEG
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 1
29143: PUSH
29144: LD_INT 1
29146: NEG
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: PUSH
29165: LD_INT 1
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 2
29174: PUSH
29175: LD_INT 2
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 1
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 0
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 1
29204: NEG
29205: PUSH
29206: LD_INT 1
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 2
29215: NEG
29216: PUSH
29217: LD_INT 1
29219: NEG
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: LD_INT 2
29231: NEG
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 2
29239: NEG
29240: PUSH
29241: LD_INT 3
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 2
29251: PUSH
29252: LD_INT 1
29254: NEG
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: LD_INT 3
29262: PUSH
29263: LD_INT 1
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 1
29272: PUSH
29273: LD_INT 3
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 2
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 3
29293: NEG
29294: PUSH
29295: LD_INT 2
29297: NEG
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29328: LD_ADDR_VAR 0 32
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 0
29345: PUSH
29346: LD_INT 1
29348: NEG
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 1
29356: PUSH
29357: LD_INT 0
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: LD_INT 1
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: LD_INT 0
29376: PUSH
29377: LD_INT 1
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 1
29386: NEG
29387: PUSH
29388: LD_INT 0
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 1
29397: NEG
29398: PUSH
29399: LD_INT 1
29401: NEG
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 1
29409: NEG
29410: PUSH
29411: LD_INT 2
29413: NEG
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 0
29421: PUSH
29422: LD_INT 2
29424: NEG
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: PUSH
29433: LD_INT 1
29435: NEG
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 2
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: LD_INT 2
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 2
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 2
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 1
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 2
29494: NEG
29495: PUSH
29496: LD_INT 0
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 2
29505: NEG
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: LD_INT 3
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 3
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 2
29550: PUSH
29551: LD_INT 3
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 2
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 3
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29606: LD_ADDR_VAR 0 33
29610: PUSH
29611: LD_INT 0
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: LD_INT 1
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 1
29634: PUSH
29635: LD_INT 0
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 0
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 1
29664: NEG
29665: PUSH
29666: LD_INT 0
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 2
29710: PUSH
29711: LD_INT 0
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 2
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 1
29730: PUSH
29731: LD_INT 2
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 0
29740: PUSH
29741: LD_INT 2
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 1
29750: NEG
29751: PUSH
29752: LD_INT 1
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 2
29761: NEG
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 2
29772: NEG
29773: PUSH
29774: LD_INT 1
29776: NEG
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 2
29784: NEG
29785: PUSH
29786: LD_INT 2
29788: NEG
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 2
29796: NEG
29797: PUSH
29798: LD_INT 3
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: NEG
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 3
29819: PUSH
29820: LD_INT 1
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 1
29829: PUSH
29830: LD_INT 3
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 1
29839: NEG
29840: PUSH
29841: LD_INT 2
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: LD_INT 3
29850: NEG
29851: PUSH
29852: LD_INT 2
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29885: LD_ADDR_VAR 0 34
29889: PUSH
29890: LD_INT 0
29892: PUSH
29893: LD_INT 0
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 0
29902: PUSH
29903: LD_INT 1
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 1
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 0
29933: PUSH
29934: LD_INT 1
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: NEG
29944: PUSH
29945: LD_INT 0
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 1
29954: NEG
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 2
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 2
29981: NEG
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 1
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 2
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 2
30010: PUSH
30011: LD_INT 2
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: LD_INT 2
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: LD_INT 1
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: LD_INT 1
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 2
30064: NEG
30065: PUSH
30066: LD_INT 2
30068: NEG
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 1
30076: NEG
30077: PUSH
30078: LD_INT 3
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: LD_INT 2
30091: NEG
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 3
30099: PUSH
30100: LD_INT 2
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: LD_INT 3
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 2
30119: NEG
30120: PUSH
30121: LD_INT 1
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 3
30130: NEG
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30165: LD_ADDR_VAR 0 35
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: LD_INT 1
30185: NEG
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 0
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: NEG
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: LD_INT 1
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 2
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 2
30256: NEG
30257: PUSH
30258: LD_INT 1
30260: NEG
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30277: LD_ADDR_VAR 0 36
30281: PUSH
30282: LD_INT 0
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: LD_INT 0
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: LD_INT 2
30362: NEG
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30389: LD_ADDR_VAR 0 37
30393: PUSH
30394: LD_INT 0
30396: PUSH
30397: LD_INT 0
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 0
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: LD_INT 0
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 1
30458: NEG
30459: PUSH
30460: LD_INT 1
30462: NEG
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: PUSH
30471: LD_INT 1
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: LD_INT 1
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30501: LD_ADDR_VAR 0 38
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: LD_INT 0
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 1
30529: PUSH
30530: LD_INT 0
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 1
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: LD_INT 1
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 1
30559: NEG
30560: PUSH
30561: LD_INT 0
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: NEG
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: NEG
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30613: LD_ADDR_VAR 0 39
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 0
30630: PUSH
30631: LD_INT 1
30633: NEG
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 1
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 1
30671: NEG
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 1
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: NEG
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 1
30694: NEG
30695: PUSH
30696: LD_INT 2
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30725: LD_ADDR_VAR 0 40
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: NEG
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: NEG
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: NEG
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30837: LD_ADDR_VAR 0 41
30841: PUSH
30842: LD_INT 0
30844: PUSH
30845: LD_INT 0
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 0
30854: PUSH
30855: LD_INT 1
30857: NEG
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 1
30875: PUSH
30876: LD_INT 1
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 0
30885: PUSH
30886: LD_INT 1
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: NEG
30896: PUSH
30897: LD_INT 0
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 1
30906: NEG
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: LD_INT 2
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: LD_INT 1
30933: NEG
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 2
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: PUSH
30962: LD_INT 2
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: LD_INT 2
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: LD_INT 1
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: NEG
30993: PUSH
30994: LD_INT 0
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 2
31003: NEG
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 2
31015: NEG
31016: PUSH
31017: LD_INT 2
31019: NEG
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 2
31027: NEG
31028: PUSH
31029: LD_INT 3
31031: NEG
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 2
31039: PUSH
31040: LD_INT 1
31042: NEG
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PUSH
31048: LD_INT 3
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 3
31060: PUSH
31061: LD_INT 1
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 3
31070: PUSH
31071: LD_INT 2
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 3
31080: PUSH
31081: LD_INT 3
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 2
31090: PUSH
31091: LD_INT 3
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 2
31100: NEG
31101: PUSH
31102: LD_INT 1
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 3
31111: NEG
31112: PUSH
31113: LD_INT 0
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 3
31122: NEG
31123: PUSH
31124: LD_INT 1
31126: NEG
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 3
31134: NEG
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 3
31146: NEG
31147: PUSH
31148: LD_INT 3
31150: NEG
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31187: LD_ADDR_VAR 0 42
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: LD_INT 0
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: LD_INT 2
31272: NEG
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 0
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 2
31302: PUSH
31303: LD_INT 1
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 2
31312: PUSH
31313: LD_INT 2
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 2
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 2
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 2
31377: NEG
31378: PUSH
31379: LD_INT 3
31381: NEG
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: NEG
31390: PUSH
31391: LD_INT 3
31393: NEG
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: LD_INT 3
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: LD_INT 2
31415: NEG
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 3
31423: PUSH
31424: LD_INT 2
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 3
31433: PUSH
31434: LD_INT 3
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 2
31443: PUSH
31444: LD_INT 3
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 3
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 0
31463: PUSH
31464: LD_INT 3
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 3
31484: NEG
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 3
31496: NEG
31497: PUSH
31498: LD_INT 3
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31537: LD_ADDR_VAR 0 43
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: LD_INT 1
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 2
31703: NEG
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 1
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: LD_INT 3
31730: NEG
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 0
31738: PUSH
31739: LD_INT 3
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 2
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 3
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 3
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: LD_INT 3
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 0
31801: PUSH
31802: LD_INT 3
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 1
31811: NEG
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 3
31833: NEG
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 3
31844: NEG
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31885: LD_ADDR_VAR 0 44
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 1
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 0
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 1
31943: NEG
31944: PUSH
31945: LD_INT 0
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 2
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 2
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 1
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: LD_INT 1
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 2
32040: NEG
32041: PUSH
32042: LD_INT 0
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 2
32051: NEG
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: NEG
32064: PUSH
32065: LD_INT 2
32067: NEG
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: LD_INT 3
32079: NEG
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 2
32087: PUSH
32088: LD_INT 1
32090: NEG
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 3
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 3
32108: PUSH
32109: LD_INT 1
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 3
32118: PUSH
32119: LD_INT 2
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 3
32128: PUSH
32129: LD_INT 3
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 2
32138: PUSH
32139: LD_INT 3
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 2
32148: NEG
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 3
32159: NEG
32160: PUSH
32161: LD_INT 0
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 3
32170: NEG
32171: PUSH
32172: LD_INT 1
32174: NEG
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 3
32182: NEG
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 3
32194: NEG
32195: PUSH
32196: LD_INT 3
32198: NEG
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32235: LD_ADDR_VAR 0 45
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: LD_INT 0
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 1
32255: NEG
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 1
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 1
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: PUSH
32281: LD_INT 0
32283: PUSH
32284: LD_INT 1
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: LD_INT 1
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: NEG
32317: PUSH
32318: LD_INT 2
32320: NEG
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: LD_INT 2
32331: NEG
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: LD_INT 1
32342: NEG
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 2
32350: PUSH
32351: LD_INT 1
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 2
32360: PUSH
32361: LD_INT 2
32363: PUSH
32364: EMPTY
32365: LIST
32366: LIST
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: LD_INT 2
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 1
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: LD_INT 1
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 2
32413: NEG
32414: PUSH
32415: LD_INT 2
32417: NEG
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: LD_INT 3
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 1
32437: NEG
32438: PUSH
32439: LD_INT 3
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: LD_INT 3
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 3
32471: PUSH
32472: LD_INT 2
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 3
32481: PUSH
32482: LD_INT 3
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 2
32491: PUSH
32492: LD_INT 3
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: PUSH
32502: LD_INT 3
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 3
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: NEG
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 3
32544: NEG
32545: PUSH
32546: LD_INT 3
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32585: LD_ADDR_VAR 0 46
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: LD_INT 0
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: LD_INT 1
32605: NEG
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 1
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: NEG
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: LD_INT 2
32670: NEG
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 0
32678: PUSH
32679: LD_INT 2
32681: NEG
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 1
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 2
32700: PUSH
32701: LD_INT 0
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PUSH
32708: LD_INT 2
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 2
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: LD_INT 2
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 1
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 2
32751: NEG
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 2
32762: NEG
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: LD_INT 3
32778: NEG
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: LD_INT 3
32789: NEG
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: LD_INT 2
32800: NEG
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: LD_INT 1
32811: NEG
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 3
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 3
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: LD_INT 3
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: LD_INT 3
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 1
32859: NEG
32860: PUSH
32861: LD_INT 2
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: LD_INT 1
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 3
32881: NEG
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 3
32892: NEG
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32933: LD_ADDR_VAR 0 47
32937: PUSH
32938: LD_INT 0
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: LD_INT 1
32953: NEG
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 1
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: PUSH
32972: LD_INT 1
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: LD_INT 1
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 1
32991: NEG
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: LD_INT 1
33006: NEG
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 0
33026: PUSH
33027: LD_INT 2
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: PUSH
33038: LD_INT 1
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 1
33052: NEG
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 2
33060: NEG
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33084: LD_ADDR_VAR 0 48
33088: PUSH
33089: LD_INT 0
33091: PUSH
33092: LD_INT 0
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: LD_INT 1
33104: NEG
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: LD_INT 0
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: PUSH
33123: LD_INT 1
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: NEG
33143: PUSH
33144: LD_INT 0
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 1
33153: NEG
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 2
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 0
33177: PUSH
33178: LD_INT 2
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 2
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33231: LD_ADDR_VAR 0 49
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 0
33248: PUSH
33249: LD_INT 1
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: PUSH
33260: LD_INT 0
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 1
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 1
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 2
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 2
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: LD_INT 2
33343: PUSH
33344: LD_INT 2
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33375: LD_ADDR_VAR 0 50
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: PUSH
33457: LD_INT 1
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 2
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 1
33476: PUSH
33477: LD_INT 2
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 0
33486: PUSH
33487: LD_INT 2
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33519: LD_ADDR_VAR 0 51
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 0
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 1
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 1
33557: PUSH
33558: LD_INT 1
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 0
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: NEG
33578: PUSH
33579: LD_INT 0
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 1
33588: NEG
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 1
33600: PUSH
33601: LD_INT 2
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 2
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 2
33631: NEG
33632: PUSH
33633: LD_INT 0
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: NEG
33643: PUSH
33644: LD_INT 1
33646: NEG
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33666: LD_ADDR_VAR 0 52
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 0
33683: PUSH
33684: LD_INT 1
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 0
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: NEG
33725: PUSH
33726: LD_INT 0
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: NEG
33736: PUSH
33737: LD_INT 1
33739: NEG
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 2
33751: NEG
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: NEG
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 0
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 2
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: LIST
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33817: LD_ADDR_VAR 0 53
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 0
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: LD_INT 0
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: LD_INT 1
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 0
33865: PUSH
33866: LD_INT 1
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 1
33886: NEG
33887: PUSH
33888: LD_INT 1
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 0
33910: PUSH
33911: LD_INT 2
33913: NEG
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 2
33942: PUSH
33943: LD_INT 1
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 2
33952: PUSH
33953: LD_INT 2
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: LD_INT 2
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: LD_INT 2
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: LD_INT 1
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 2
33993: NEG
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 2
34004: NEG
34005: PUSH
34006: LD_INT 1
34008: NEG
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 2
34016: NEG
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34047: LD_ADDR_VAR 0 54
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 1
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 0
34095: PUSH
34096: LD_INT 1
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 1
34105: NEG
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 1
34116: NEG
34117: PUSH
34118: LD_INT 1
34120: NEG
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: LD_INT 2
34132: NEG
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 2
34143: NEG
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 1
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 2
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 2
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 0
34202: PUSH
34203: LD_INT 2
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 1
34212: NEG
34213: PUSH
34214: LD_INT 1
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 2
34223: NEG
34224: PUSH
34225: LD_INT 0
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 2
34234: NEG
34235: PUSH
34236: LD_INT 1
34238: NEG
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: LD_INT 2
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34277: LD_ADDR_VAR 0 55
34281: PUSH
34282: LD_INT 0
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 1
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: LD_INT 1
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: LD_INT 2
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: LD_INT 2
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 2
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 2
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 2
34412: PUSH
34413: LD_INT 2
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: LD_INT 2
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: LD_INT 2
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: NEG
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 2
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 2
34476: NEG
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34507: LD_ADDR_VAR 0 56
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: LD_INT 0
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 2
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 2
34632: PUSH
34633: LD_INT 1
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: LD_INT 2
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: LD_INT 2
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: LD_INT 1
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 2
34683: NEG
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: NEG
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: NEG
34707: PUSH
34708: LD_INT 2
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 57
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 2
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: NEG
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34967: LD_ADDR_VAR 0 58
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: LD_INT 2
35052: NEG
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 2
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 1
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 0
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 1
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: PUSH
35103: LD_INT 2
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: LD_INT 1
35112: PUSH
35113: LD_INT 2
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: LD_INT 0
35122: PUSH
35123: LD_INT 2
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 2
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 2
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35197: LD_ADDR_VAR 0 59
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 1
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35285: LD_ADDR_VAR 0 60
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35373: LD_ADDR_VAR 0 61
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 0
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 1
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: LD_INT 1
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 1
35431: NEG
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: LD_INT 1
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35461: LD_ADDR_VAR 0 62
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: LD_INT 0
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 1
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 1
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 1
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35549: LD_ADDR_VAR 0 63
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: LD_INT 0
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35637: LD_ADDR_VAR 0 64
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 0
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 1
35665: PUSH
35666: LD_INT 0
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 1
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: ST_TO_ADDR
// end ; 1 :
35725: GO 41622
35727: LD_INT 1
35729: DOUBLE
35730: EQUAL
35731: IFTRUE 35735
35733: GO 38358
35735: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35736: LD_ADDR_VAR 0 11
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 3
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 3
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: LIST
35779: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35780: LD_ADDR_VAR 0 12
35784: PUSH
35785: LD_INT 2
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 3
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 3
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: LIST
35820: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35821: LD_ADDR_VAR 0 13
35825: PUSH
35826: LD_INT 3
35828: PUSH
35829: LD_INT 2
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 3
35838: PUSH
35839: LD_INT 3
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: LD_INT 2
35848: PUSH
35849: LD_INT 3
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: LIST
35860: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35861: LD_ADDR_VAR 0 14
35865: PUSH
35866: LD_INT 1
35868: PUSH
35869: LD_INT 3
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 0
35878: PUSH
35879: LD_INT 3
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: NEG
35889: PUSH
35890: LD_INT 2
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: LIST
35901: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35902: LD_ADDR_VAR 0 15
35906: PUSH
35907: LD_INT 2
35909: NEG
35910: PUSH
35911: LD_INT 1
35913: PUSH
35914: EMPTY
35915: LIST
35916: LIST
35917: PUSH
35918: LD_INT 3
35920: NEG
35921: PUSH
35922: LD_INT 0
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 3
35931: NEG
35932: PUSH
35933: LD_INT 1
35935: NEG
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: LIST
35945: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35946: LD_ADDR_VAR 0 16
35950: PUSH
35951: LD_INT 2
35953: NEG
35954: PUSH
35955: LD_INT 3
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: LD_INT 2
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: LD_INT 3
35981: NEG
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: LIST
35991: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35992: LD_ADDR_VAR 0 17
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 3
36003: NEG
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 3
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 1
36022: PUSH
36023: LD_INT 2
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: LIST
36035: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36036: LD_ADDR_VAR 0 18
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: LD_INT 0
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 3
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: LIST
36076: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36077: LD_ADDR_VAR 0 19
36081: PUSH
36082: LD_INT 3
36084: PUSH
36085: LD_INT 2
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 3
36094: PUSH
36095: LD_INT 3
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 2
36104: PUSH
36105: LD_INT 3
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: LIST
36116: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36117: LD_ADDR_VAR 0 20
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: LD_INT 3
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: LD_INT 3
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: LD_INT 2
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36158: LD_ADDR_VAR 0 21
36162: PUSH
36163: LD_INT 2
36165: NEG
36166: PUSH
36167: LD_INT 1
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 3
36176: NEG
36177: PUSH
36178: LD_INT 0
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 3
36187: NEG
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: LIST
36201: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36202: LD_ADDR_VAR 0 22
36206: PUSH
36207: LD_INT 2
36209: NEG
36210: PUSH
36211: LD_INT 3
36213: NEG
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: LD_INT 2
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 3
36233: NEG
36234: PUSH
36235: LD_INT 3
36237: NEG
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: LIST
36247: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36248: LD_ADDR_VAR 0 23
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: LD_INT 3
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 4
36270: NEG
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: PUSH
36279: LD_INT 3
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: LIST
36291: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36292: LD_ADDR_VAR 0 24
36296: PUSH
36297: LD_INT 3
36299: PUSH
36300: LD_INT 0
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 3
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 4
36320: PUSH
36321: LD_INT 1
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36333: LD_ADDR_VAR 0 25
36337: PUSH
36338: LD_INT 3
36340: PUSH
36341: LD_INT 3
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 4
36350: PUSH
36351: LD_INT 3
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 3
36360: PUSH
36361: LD_INT 4
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: LIST
36372: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36373: LD_ADDR_VAR 0 26
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 3
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: PUSH
36391: LD_INT 4
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: LD_INT 3
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: LIST
36413: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36414: LD_ADDR_VAR 0 27
36418: PUSH
36419: LD_INT 3
36421: NEG
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 3
36432: NEG
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 4
36443: NEG
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: LIST
36457: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36458: LD_ADDR_VAR 0 28
36462: PUSH
36463: LD_INT 3
36465: NEG
36466: PUSH
36467: LD_INT 3
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 3
36477: NEG
36478: PUSH
36479: LD_INT 4
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 4
36489: NEG
36490: PUSH
36491: LD_INT 3
36493: NEG
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: LIST
36503: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36504: LD_ADDR_VAR 0 29
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 3
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 3
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: PUSH
36535: LD_INT 2
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: NEG
36546: PUSH
36547: LD_INT 4
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: LD_INT 4
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 3
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: LD_INT 5
36583: NEG
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 0
36591: PUSH
36592: LD_INT 5
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: LD_INT 4
36605: NEG
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: LD_INT 6
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 0
36625: PUSH
36626: LD_INT 6
36628: NEG
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 5
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36659: LD_ADDR_VAR 0 30
36663: PUSH
36664: LD_INT 2
36666: PUSH
36667: LD_INT 1
36669: NEG
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 3
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 3
36687: PUSH
36688: LD_INT 1
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 3
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 4
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 4
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 4
36728: PUSH
36729: LD_INT 1
36731: NEG
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 5
36739: PUSH
36740: LD_INT 0
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 5
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 5
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 6
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 6
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36802: LD_ADDR_VAR 0 31
36806: PUSH
36807: LD_INT 3
36809: PUSH
36810: LD_INT 2
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 3
36819: PUSH
36820: LD_INT 3
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: LD_INT 3
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 4
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 4
36849: PUSH
36850: LD_INT 4
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: LD_INT 4
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 5
36869: PUSH
36870: LD_INT 4
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 5
36879: PUSH
36880: LD_INT 5
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 4
36889: PUSH
36890: LD_INT 5
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 6
36899: PUSH
36900: LD_INT 5
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 6
36909: PUSH
36910: LD_INT 6
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 5
36919: PUSH
36920: LD_INT 6
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36941: LD_ADDR_VAR 0 32
36945: PUSH
36946: LD_INT 1
36948: PUSH
36949: LD_INT 3
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: LD_INT 0
36958: PUSH
36959: LD_INT 3
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: LD_INT 1
36979: PUSH
36980: LD_INT 4
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: LD_INT 4
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: LD_INT 5
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 0
37020: PUSH
37021: LD_INT 5
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: NEG
37031: PUSH
37032: LD_INT 4
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 1
37041: PUSH
37042: LD_INT 6
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 6
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: LD_INT 5
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37084: LD_ADDR_VAR 0 33
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: NEG
37103: PUSH
37104: LD_INT 0
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 4
37136: NEG
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 4
37147: NEG
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 4
37159: NEG
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 5
37170: NEG
37171: PUSH
37172: LD_INT 0
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 5
37181: NEG
37182: PUSH
37183: LD_INT 1
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 5
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 6
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 6
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37239: LD_ADDR_VAR 0 34
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: LD_INT 3
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: LD_INT 2
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 3
37270: NEG
37271: PUSH
37272: LD_INT 3
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 3
37282: NEG
37283: PUSH
37284: LD_INT 4
37286: NEG
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 4
37294: NEG
37295: PUSH
37296: LD_INT 3
37298: NEG
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 4
37306: NEG
37307: PUSH
37308: LD_INT 4
37310: NEG
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 4
37318: NEG
37319: PUSH
37320: LD_INT 5
37322: NEG
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 5
37330: NEG
37331: PUSH
37332: LD_INT 4
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 5
37342: NEG
37343: PUSH
37344: LD_INT 5
37346: NEG
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 5
37354: NEG
37355: PUSH
37356: LD_INT 6
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 6
37366: NEG
37367: PUSH
37368: LD_INT 5
37370: NEG
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 6
37378: NEG
37379: PUSH
37380: LD_INT 6
37382: NEG
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37402: LD_ADDR_VAR 0 41
37406: PUSH
37407: LD_INT 0
37409: PUSH
37410: LD_INT 2
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 1
37420: NEG
37421: PUSH
37422: LD_INT 3
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: LD_INT 2
37435: NEG
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: LIST
37445: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37446: LD_ADDR_VAR 0 42
37450: PUSH
37451: LD_INT 2
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 2
37463: PUSH
37464: LD_INT 1
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 3
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: LIST
37486: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37487: LD_ADDR_VAR 0 43
37491: PUSH
37492: LD_INT 2
37494: PUSH
37495: LD_INT 2
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 3
37504: PUSH
37505: LD_INT 2
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 2
37514: PUSH
37515: LD_INT 3
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: LIST
37526: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37527: LD_ADDR_VAR 0 44
37531: PUSH
37532: LD_INT 0
37534: PUSH
37535: LD_INT 2
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 1
37544: PUSH
37545: LD_INT 3
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: NEG
37555: PUSH
37556: LD_INT 2
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: LIST
37567: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37568: LD_ADDR_VAR 0 45
37572: PUSH
37573: LD_INT 2
37575: NEG
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 2
37586: NEG
37587: PUSH
37588: LD_INT 1
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 3
37597: NEG
37598: PUSH
37599: LD_INT 1
37601: NEG
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: LIST
37611: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37612: LD_ADDR_VAR 0 46
37616: PUSH
37617: LD_INT 2
37619: NEG
37620: PUSH
37621: LD_INT 2
37623: NEG
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 2
37631: NEG
37632: PUSH
37633: LD_INT 3
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: LD_INT 2
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37658: LD_ADDR_VAR 0 47
37662: PUSH
37663: LD_INT 2
37665: NEG
37666: PUSH
37667: LD_INT 3
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: LD_INT 3
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37691: LD_ADDR_VAR 0 48
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37722: LD_ADDR_VAR 0 49
37726: PUSH
37727: LD_INT 3
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 3
37739: PUSH
37740: LD_INT 2
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37751: LD_ADDR_VAR 0 50
37755: PUSH
37756: LD_INT 2
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 1
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37780: LD_ADDR_VAR 0 51
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 2
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37811: LD_ADDR_VAR 0 52
37815: PUSH
37816: LD_INT 3
37818: NEG
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 3
37830: NEG
37831: PUSH
37832: LD_INT 2
37834: NEG
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37844: LD_ADDR_VAR 0 53
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 3
37855: NEG
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: LD_INT 3
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 2
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: LIST
37887: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37888: LD_ADDR_VAR 0 54
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 3
37906: PUSH
37907: LD_INT 0
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: PUSH
37914: LD_INT 3
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: LIST
37928: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37929: LD_ADDR_VAR 0 55
37933: PUSH
37934: LD_INT 3
37936: PUSH
37937: LD_INT 2
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 3
37946: PUSH
37947: LD_INT 3
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 2
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: LIST
37968: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37969: LD_ADDR_VAR 0 56
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 0
37986: PUSH
37987: LD_INT 3
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 1
37996: NEG
37997: PUSH
37998: LD_INT 2
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: LIST
38009: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38010: LD_ADDR_VAR 0 57
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 3
38028: NEG
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: LD_INT 3
38039: NEG
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38054: LD_ADDR_VAR 0 58
38058: PUSH
38059: LD_INT 2
38061: NEG
38062: PUSH
38063: LD_INT 3
38065: NEG
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 3
38073: NEG
38074: PUSH
38075: LD_INT 2
38077: NEG
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: LD_INT 3
38085: NEG
38086: PUSH
38087: LD_INT 3
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: LIST
38099: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38100: LD_ADDR_VAR 0 59
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 2
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 1
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: LIST
38143: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38144: LD_ADDR_VAR 0 60
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 2
38172: PUSH
38173: LD_INT 1
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: LIST
38184: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38185: LD_ADDR_VAR 0 61
38189: PUSH
38190: LD_INT 2
38192: PUSH
38193: LD_INT 1
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: LIST
38224: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38225: LD_ADDR_VAR 0 62
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 2
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 2
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: LIST
38265: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38266: LD_ADDR_VAR 0 63
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: LD_INT 1
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 2
38284: NEG
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 2
38295: NEG
38296: PUSH
38297: LD_INT 1
38299: NEG
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: LIST
38309: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38310: LD_ADDR_VAR 0 64
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: LD_INT 2
38321: NEG
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 2
38341: NEG
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: LIST
38355: ST_TO_ADDR
// end ; 2 :
38356: GO 41622
38358: LD_INT 2
38360: DOUBLE
38361: EQUAL
38362: IFTRUE 38366
38364: GO 41621
38366: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38367: LD_ADDR_VAR 0 29
38371: PUSH
38372: LD_INT 4
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 4
38384: PUSH
38385: LD_INT 1
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 5
38395: PUSH
38396: LD_INT 0
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 5
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 4
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 3
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 3
38446: PUSH
38447: LD_INT 2
38449: NEG
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 5
38457: PUSH
38458: LD_INT 2
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 3
38467: PUSH
38468: LD_INT 3
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 3
38477: PUSH
38478: LD_INT 2
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 4
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 4
38497: PUSH
38498: LD_INT 4
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 3
38507: PUSH
38508: LD_INT 4
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: LD_INT 3
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: LD_INT 2
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 4
38537: PUSH
38538: LD_INT 2
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 4
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 4
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 3
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: LD_INT 4
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 1
38587: PUSH
38588: LD_INT 5
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 0
38597: PUSH
38598: LD_INT 5
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 4
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 1
38618: NEG
38619: PUSH
38620: LD_INT 3
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 2
38629: PUSH
38630: LD_INT 5
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 3
38661: NEG
38662: PUSH
38663: LD_INT 1
38665: NEG
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 0
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 2
38684: NEG
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 3
38695: NEG
38696: PUSH
38697: LD_INT 1
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 4
38706: NEG
38707: PUSH
38708: LD_INT 0
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 4
38717: NEG
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 4
38729: NEG
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: LD_INT 2
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 4
38752: NEG
38753: PUSH
38754: LD_INT 4
38756: NEG
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 4
38764: NEG
38765: PUSH
38766: LD_INT 5
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 3
38776: NEG
38777: PUSH
38778: LD_INT 4
38780: NEG
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 3
38788: NEG
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 4
38800: NEG
38801: PUSH
38802: LD_INT 3
38804: NEG
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 5
38812: NEG
38813: PUSH
38814: LD_INT 4
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 5
38824: NEG
38825: PUSH
38826: LD_INT 5
38828: NEG
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 3
38836: NEG
38837: PUSH
38838: LD_INT 5
38840: NEG
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 5
38848: NEG
38849: PUSH
38850: LD_INT 3
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38905: LD_ADDR_VAR 0 30
38909: PUSH
38910: LD_INT 4
38912: PUSH
38913: LD_INT 4
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 4
38922: PUSH
38923: LD_INT 3
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 5
38932: PUSH
38933: LD_INT 4
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 5
38942: PUSH
38943: LD_INT 5
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 4
38952: PUSH
38953: LD_INT 5
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 3
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: LD_INT 3
38972: PUSH
38973: LD_INT 3
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 5
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: PUSH
38993: LD_INT 5
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 0
39002: PUSH
39003: LD_INT 3
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 0
39012: PUSH
39013: LD_INT 2
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: LD_INT 3
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 4
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: LD_INT 4
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: LD_INT 3
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: LD_INT 2
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: LD_INT 4
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 2
39084: NEG
39085: PUSH
39086: LD_INT 2
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 4
39095: NEG
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 4
39106: NEG
39107: PUSH
39108: LD_INT 1
39110: NEG
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 3
39118: NEG
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 3
39129: NEG
39130: PUSH
39131: LD_INT 1
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 4
39140: NEG
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 5
39151: NEG
39152: PUSH
39153: LD_INT 0
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 5
39162: NEG
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: LD_INT 2
39178: NEG
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 3
39186: NEG
39187: PUSH
39188: LD_INT 2
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 3
39197: NEG
39198: PUSH
39199: LD_INT 3
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 3
39209: NEG
39210: PUSH
39211: LD_INT 4
39213: NEG
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: NEG
39222: PUSH
39223: LD_INT 3
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: LD_INT 2
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 3
39245: NEG
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 4
39257: NEG
39258: PUSH
39259: LD_INT 3
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 4
39269: NEG
39270: PUSH
39271: LD_INT 4
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 2
39281: NEG
39282: PUSH
39283: LD_INT 4
39285: NEG
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 4
39293: NEG
39294: PUSH
39295: LD_INT 2
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: LD_INT 4
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 5
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 4
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: LD_INT 3
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 3
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: NEG
39361: PUSH
39362: LD_INT 4
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: LD_INT 5
39376: NEG
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 2
39384: PUSH
39385: LD_INT 3
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: LD_INT 5
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39452: LD_ADDR_VAR 0 31
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 4
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: LD_INT 4
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: LD_INT 1
39489: PUSH
39490: LD_INT 5
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: LD_INT 5
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 1
39509: NEG
39510: PUSH
39511: LD_INT 4
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 1
39520: NEG
39521: PUSH
39522: LD_INT 3
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 2
39531: PUSH
39532: LD_INT 5
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 2
39541: NEG
39542: PUSH
39543: LD_INT 3
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 3
39552: NEG
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: LD_INT 1
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: LD_INT 0
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 2
39586: NEG
39587: PUSH
39588: LD_INT 1
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 3
39597: NEG
39598: PUSH
39599: LD_INT 1
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 4
39608: NEG
39609: PUSH
39610: LD_INT 0
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 4
39619: NEG
39620: PUSH
39621: LD_INT 1
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: NEG
39644: PUSH
39645: LD_INT 2
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 4
39654: NEG
39655: PUSH
39656: LD_INT 4
39658: NEG
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 4
39666: NEG
39667: PUSH
39668: LD_INT 5
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 3
39678: NEG
39679: PUSH
39680: LD_INT 4
39682: NEG
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 3
39690: NEG
39691: PUSH
39692: LD_INT 3
39694: NEG
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 4
39702: NEG
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 5
39714: NEG
39715: PUSH
39716: LD_INT 4
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 5
39726: NEG
39727: PUSH
39728: LD_INT 5
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 3
39738: NEG
39739: PUSH
39740: LD_INT 5
39742: NEG
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 5
39750: NEG
39751: PUSH
39752: LD_INT 3
39754: NEG
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: PUSH
39760: LD_INT 0
39762: PUSH
39763: LD_INT 3
39765: NEG
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 4
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: LD_INT 3
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 1
39795: PUSH
39796: LD_INT 2
39798: NEG
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: LD_INT 2
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 3
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: LD_INT 4
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 2
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: LD_INT 4
39856: NEG
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 4
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 4
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 5
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 5
39895: PUSH
39896: LD_INT 1
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 4
39905: PUSH
39906: LD_INT 1
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: PUSH
39916: LD_INT 0
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 3
39925: PUSH
39926: LD_INT 1
39928: NEG
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 3
39936: PUSH
39937: LD_INT 2
39939: NEG
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 5
39947: PUSH
39948: LD_INT 2
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40002: LD_ADDR_VAR 0 32
40006: PUSH
40007: LD_INT 4
40009: NEG
40010: PUSH
40011: LD_INT 0
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 4
40020: NEG
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 3
40032: NEG
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 3
40043: NEG
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: LD_INT 1
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 5
40065: NEG
40066: PUSH
40067: LD_INT 0
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 5
40076: NEG
40077: PUSH
40078: LD_INT 1
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 3
40100: NEG
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 3
40111: NEG
40112: PUSH
40113: LD_INT 3
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 3
40123: NEG
40124: PUSH
40125: LD_INT 4
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 2
40135: NEG
40136: PUSH
40137: LD_INT 3
40139: NEG
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 2
40147: NEG
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 3
40159: NEG
40160: PUSH
40161: LD_INT 2
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 4
40171: NEG
40172: PUSH
40173: LD_INT 3
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 4
40183: NEG
40184: PUSH
40185: LD_INT 4
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 2
40195: NEG
40196: PUSH
40197: LD_INT 4
40199: NEG
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: LD_INT 2
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: LD_INT 4
40222: NEG
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: LD_INT 5
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: LD_INT 4
40244: NEG
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: PUSH
40253: LD_INT 3
40255: NEG
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 3
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 1
40274: NEG
40275: PUSH
40276: LD_INT 4
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: NEG
40287: PUSH
40288: LD_INT 5
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 2
40298: PUSH
40299: LD_INT 3
40301: NEG
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 2
40309: NEG
40310: PUSH
40311: LD_INT 5
40313: NEG
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 3
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 4
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 4
40352: PUSH
40353: LD_INT 1
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: PUSH
40363: LD_INT 1
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 2
40382: PUSH
40383: LD_INT 1
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: LD_INT 2
40396: NEG
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 4
40404: PUSH
40405: LD_INT 2
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 4
40414: PUSH
40415: LD_INT 4
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 4
40424: PUSH
40425: LD_INT 3
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 5
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 5
40444: PUSH
40445: LD_INT 5
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 4
40454: PUSH
40455: LD_INT 5
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: LD_INT 4
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 3
40474: PUSH
40475: LD_INT 3
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 5
40484: PUSH
40485: LD_INT 3
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 3
40494: PUSH
40495: LD_INT 5
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40549: LD_ADDR_VAR 0 33
40553: PUSH
40554: LD_INT 4
40556: NEG
40557: PUSH
40558: LD_INT 4
40560: NEG
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 4
40568: NEG
40569: PUSH
40570: LD_INT 5
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 3
40580: NEG
40581: PUSH
40582: LD_INT 4
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 3
40592: NEG
40593: PUSH
40594: LD_INT 3
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 4
40604: NEG
40605: PUSH
40606: LD_INT 3
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 5
40616: NEG
40617: PUSH
40618: LD_INT 4
40620: NEG
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 5
40628: NEG
40629: PUSH
40630: LD_INT 5
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 3
40640: NEG
40641: PUSH
40642: LD_INT 5
40644: NEG
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 5
40652: NEG
40653: PUSH
40654: LD_INT 3
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 0
40664: PUSH
40665: LD_INT 3
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: LD_INT 4
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 3
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: LD_INT 2
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: LD_INT 2
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: LD_INT 3
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: LD_INT 4
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 2
40743: PUSH
40744: LD_INT 2
40746: NEG
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: LD_INT 4
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 4
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: PUSH
40777: LD_INT 1
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: PUSH
40788: LD_INT 0
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 5
40797: PUSH
40798: LD_INT 1
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: LD_INT 1
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 3
40827: PUSH
40828: LD_INT 1
40830: NEG
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: LD_INT 2
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 5
40849: PUSH
40850: LD_INT 2
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 3
40869: PUSH
40870: LD_INT 2
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 4
40879: PUSH
40880: LD_INT 3
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 4
40889: PUSH
40890: LD_INT 4
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 3
40899: PUSH
40900: LD_INT 4
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 2
40909: PUSH
40910: LD_INT 3
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 2
40919: PUSH
40920: LD_INT 2
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 4
40929: PUSH
40930: LD_INT 2
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 2
40939: PUSH
40940: LD_INT 4
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: LD_INT 4
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 0
40959: PUSH
40960: LD_INT 3
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: LD_INT 4
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 5
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: LD_INT 5
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 4
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: LD_INT 3
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 2
41021: PUSH
41022: LD_INT 5
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 2
41031: NEG
41032: PUSH
41033: LD_INT 3
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41087: LD_ADDR_VAR 0 34
41091: PUSH
41092: LD_INT 0
41094: PUSH
41095: LD_INT 4
41097: NEG
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: LD_INT 5
41108: NEG
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 1
41116: PUSH
41117: LD_INT 4
41119: NEG
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 1
41127: PUSH
41128: LD_INT 3
41130: NEG
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 3
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: LD_INT 4
41153: NEG
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 1
41161: NEG
41162: PUSH
41163: LD_INT 5
41165: NEG
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 2
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 2
41184: NEG
41185: PUSH
41186: LD_INT 5
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 3
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 4
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 4
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 3
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: LD_INT 0
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: PUSH
41269: LD_INT 2
41271: NEG
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 4
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 4
41289: PUSH
41290: LD_INT 4
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 4
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 5
41309: PUSH
41310: LD_INT 4
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 5
41319: PUSH
41320: LD_INT 5
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 4
41329: PUSH
41330: LD_INT 5
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 4
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 3
41349: PUSH
41350: LD_INT 3
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 5
41359: PUSH
41360: LD_INT 3
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: LD_INT 5
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 0
41379: PUSH
41380: LD_INT 3
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 0
41389: PUSH
41390: LD_INT 2
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 1
41399: PUSH
41400: LD_INT 3
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 1
41429: NEG
41430: PUSH
41431: LD_INT 3
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 1
41440: NEG
41441: PUSH
41442: LD_INT 2
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: LD_INT 4
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: LD_INT 2
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 4
41472: NEG
41473: PUSH
41474: LD_INT 0
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: LD_INT 4
41483: NEG
41484: PUSH
41485: LD_INT 1
41487: NEG
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: NEG
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 3
41506: NEG
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 4
41517: NEG
41518: PUSH
41519: LD_INT 1
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 5
41528: NEG
41529: PUSH
41530: LD_INT 0
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 5
41539: NEG
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: LD_INT 2
41555: NEG
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: NEG
41564: PUSH
41565: LD_INT 2
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: ST_TO_ADDR
// end ; end ;
41619: GO 41622
41621: POP
// case btype of b_depot , b_warehouse :
41622: LD_VAR 0 1
41626: PUSH
41627: LD_INT 0
41629: DOUBLE
41630: EQUAL
41631: IFTRUE 41641
41633: LD_INT 1
41635: DOUBLE
41636: EQUAL
41637: IFTRUE 41641
41639: GO 41842
41641: POP
// case nation of nation_american :
41642: LD_VAR 0 5
41646: PUSH
41647: LD_INT 1
41649: DOUBLE
41650: EQUAL
41651: IFTRUE 41655
41653: GO 41711
41655: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41656: LD_ADDR_VAR 0 9
41660: PUSH
41661: LD_VAR 0 11
41665: PUSH
41666: LD_VAR 0 12
41670: PUSH
41671: LD_VAR 0 13
41675: PUSH
41676: LD_VAR 0 14
41680: PUSH
41681: LD_VAR 0 15
41685: PUSH
41686: LD_VAR 0 16
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: PUSH
41699: LD_VAR 0 4
41703: PUSH
41704: LD_INT 1
41706: PLUS
41707: ARRAY
41708: ST_TO_ADDR
41709: GO 41840
41711: LD_INT 2
41713: DOUBLE
41714: EQUAL
41715: IFTRUE 41719
41717: GO 41775
41719: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41720: LD_ADDR_VAR 0 9
41724: PUSH
41725: LD_VAR 0 17
41729: PUSH
41730: LD_VAR 0 18
41734: PUSH
41735: LD_VAR 0 19
41739: PUSH
41740: LD_VAR 0 20
41744: PUSH
41745: LD_VAR 0 21
41749: PUSH
41750: LD_VAR 0 22
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: PUSH
41763: LD_VAR 0 4
41767: PUSH
41768: LD_INT 1
41770: PLUS
41771: ARRAY
41772: ST_TO_ADDR
41773: GO 41840
41775: LD_INT 3
41777: DOUBLE
41778: EQUAL
41779: IFTRUE 41783
41781: GO 41839
41783: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41784: LD_ADDR_VAR 0 9
41788: PUSH
41789: LD_VAR 0 23
41793: PUSH
41794: LD_VAR 0 24
41798: PUSH
41799: LD_VAR 0 25
41803: PUSH
41804: LD_VAR 0 26
41808: PUSH
41809: LD_VAR 0 27
41813: PUSH
41814: LD_VAR 0 28
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: PUSH
41827: LD_VAR 0 4
41831: PUSH
41832: LD_INT 1
41834: PLUS
41835: ARRAY
41836: ST_TO_ADDR
41837: GO 41840
41839: POP
41840: GO 42395
41842: LD_INT 2
41844: DOUBLE
41845: EQUAL
41846: IFTRUE 41856
41848: LD_INT 3
41850: DOUBLE
41851: EQUAL
41852: IFTRUE 41856
41854: GO 41912
41856: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41857: LD_ADDR_VAR 0 9
41861: PUSH
41862: LD_VAR 0 29
41866: PUSH
41867: LD_VAR 0 30
41871: PUSH
41872: LD_VAR 0 31
41876: PUSH
41877: LD_VAR 0 32
41881: PUSH
41882: LD_VAR 0 33
41886: PUSH
41887: LD_VAR 0 34
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: PUSH
41900: LD_VAR 0 4
41904: PUSH
41905: LD_INT 1
41907: PLUS
41908: ARRAY
41909: ST_TO_ADDR
41910: GO 42395
41912: LD_INT 16
41914: DOUBLE
41915: EQUAL
41916: IFTRUE 41974
41918: LD_INT 17
41920: DOUBLE
41921: EQUAL
41922: IFTRUE 41974
41924: LD_INT 18
41926: DOUBLE
41927: EQUAL
41928: IFTRUE 41974
41930: LD_INT 19
41932: DOUBLE
41933: EQUAL
41934: IFTRUE 41974
41936: LD_INT 22
41938: DOUBLE
41939: EQUAL
41940: IFTRUE 41974
41942: LD_INT 20
41944: DOUBLE
41945: EQUAL
41946: IFTRUE 41974
41948: LD_INT 21
41950: DOUBLE
41951: EQUAL
41952: IFTRUE 41974
41954: LD_INT 23
41956: DOUBLE
41957: EQUAL
41958: IFTRUE 41974
41960: LD_INT 24
41962: DOUBLE
41963: EQUAL
41964: IFTRUE 41974
41966: LD_INT 25
41968: DOUBLE
41969: EQUAL
41970: IFTRUE 41974
41972: GO 42030
41974: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41975: LD_ADDR_VAR 0 9
41979: PUSH
41980: LD_VAR 0 35
41984: PUSH
41985: LD_VAR 0 36
41989: PUSH
41990: LD_VAR 0 37
41994: PUSH
41995: LD_VAR 0 38
41999: PUSH
42000: LD_VAR 0 39
42004: PUSH
42005: LD_VAR 0 40
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: PUSH
42018: LD_VAR 0 4
42022: PUSH
42023: LD_INT 1
42025: PLUS
42026: ARRAY
42027: ST_TO_ADDR
42028: GO 42395
42030: LD_INT 6
42032: DOUBLE
42033: EQUAL
42034: IFTRUE 42086
42036: LD_INT 7
42038: DOUBLE
42039: EQUAL
42040: IFTRUE 42086
42042: LD_INT 8
42044: DOUBLE
42045: EQUAL
42046: IFTRUE 42086
42048: LD_INT 13
42050: DOUBLE
42051: EQUAL
42052: IFTRUE 42086
42054: LD_INT 12
42056: DOUBLE
42057: EQUAL
42058: IFTRUE 42086
42060: LD_INT 15
42062: DOUBLE
42063: EQUAL
42064: IFTRUE 42086
42066: LD_INT 11
42068: DOUBLE
42069: EQUAL
42070: IFTRUE 42086
42072: LD_INT 14
42074: DOUBLE
42075: EQUAL
42076: IFTRUE 42086
42078: LD_INT 10
42080: DOUBLE
42081: EQUAL
42082: IFTRUE 42086
42084: GO 42142
42086: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42087: LD_ADDR_VAR 0 9
42091: PUSH
42092: LD_VAR 0 41
42096: PUSH
42097: LD_VAR 0 42
42101: PUSH
42102: LD_VAR 0 43
42106: PUSH
42107: LD_VAR 0 44
42111: PUSH
42112: LD_VAR 0 45
42116: PUSH
42117: LD_VAR 0 46
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: PUSH
42130: LD_VAR 0 4
42134: PUSH
42135: LD_INT 1
42137: PLUS
42138: ARRAY
42139: ST_TO_ADDR
42140: GO 42395
42142: LD_INT 36
42144: DOUBLE
42145: EQUAL
42146: IFTRUE 42150
42148: GO 42206
42150: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42151: LD_ADDR_VAR 0 9
42155: PUSH
42156: LD_VAR 0 47
42160: PUSH
42161: LD_VAR 0 48
42165: PUSH
42166: LD_VAR 0 49
42170: PUSH
42171: LD_VAR 0 50
42175: PUSH
42176: LD_VAR 0 51
42180: PUSH
42181: LD_VAR 0 52
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: PUSH
42194: LD_VAR 0 4
42198: PUSH
42199: LD_INT 1
42201: PLUS
42202: ARRAY
42203: ST_TO_ADDR
42204: GO 42395
42206: LD_INT 4
42208: DOUBLE
42209: EQUAL
42210: IFTRUE 42232
42212: LD_INT 5
42214: DOUBLE
42215: EQUAL
42216: IFTRUE 42232
42218: LD_INT 34
42220: DOUBLE
42221: EQUAL
42222: IFTRUE 42232
42224: LD_INT 37
42226: DOUBLE
42227: EQUAL
42228: IFTRUE 42232
42230: GO 42288
42232: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42233: LD_ADDR_VAR 0 9
42237: PUSH
42238: LD_VAR 0 53
42242: PUSH
42243: LD_VAR 0 54
42247: PUSH
42248: LD_VAR 0 55
42252: PUSH
42253: LD_VAR 0 56
42257: PUSH
42258: LD_VAR 0 57
42262: PUSH
42263: LD_VAR 0 58
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: PUSH
42276: LD_VAR 0 4
42280: PUSH
42281: LD_INT 1
42283: PLUS
42284: ARRAY
42285: ST_TO_ADDR
42286: GO 42395
42288: LD_INT 31
42290: DOUBLE
42291: EQUAL
42292: IFTRUE 42338
42294: LD_INT 32
42296: DOUBLE
42297: EQUAL
42298: IFTRUE 42338
42300: LD_INT 33
42302: DOUBLE
42303: EQUAL
42304: IFTRUE 42338
42306: LD_INT 27
42308: DOUBLE
42309: EQUAL
42310: IFTRUE 42338
42312: LD_INT 26
42314: DOUBLE
42315: EQUAL
42316: IFTRUE 42338
42318: LD_INT 28
42320: DOUBLE
42321: EQUAL
42322: IFTRUE 42338
42324: LD_INT 29
42326: DOUBLE
42327: EQUAL
42328: IFTRUE 42338
42330: LD_INT 30
42332: DOUBLE
42333: EQUAL
42334: IFTRUE 42338
42336: GO 42394
42338: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42339: LD_ADDR_VAR 0 9
42343: PUSH
42344: LD_VAR 0 59
42348: PUSH
42349: LD_VAR 0 60
42353: PUSH
42354: LD_VAR 0 61
42358: PUSH
42359: LD_VAR 0 62
42363: PUSH
42364: LD_VAR 0 63
42368: PUSH
42369: LD_VAR 0 64
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: PUSH
42382: LD_VAR 0 4
42386: PUSH
42387: LD_INT 1
42389: PLUS
42390: ARRAY
42391: ST_TO_ADDR
42392: GO 42395
42394: POP
// temp_list2 = [ ] ;
42395: LD_ADDR_VAR 0 10
42399: PUSH
42400: EMPTY
42401: ST_TO_ADDR
// for i in temp_list do
42402: LD_ADDR_VAR 0 8
42406: PUSH
42407: LD_VAR 0 9
42411: PUSH
42412: FOR_IN
42413: IFFALSE 42465
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42415: LD_ADDR_VAR 0 10
42419: PUSH
42420: LD_VAR 0 10
42424: PUSH
42425: LD_VAR 0 8
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 2
42438: PLUS
42439: PUSH
42440: LD_VAR 0 8
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 3
42453: PLUS
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: EMPTY
42460: LIST
42461: ADD
42462: ST_TO_ADDR
42463: GO 42412
42465: POP
42466: POP
// result = temp_list2 ;
42467: LD_ADDR_VAR 0 7
42471: PUSH
42472: LD_VAR 0 10
42476: ST_TO_ADDR
// end ;
42477: LD_VAR 0 7
42481: RET
// export function EnemyInRange ( unit , dist ) ; begin
42482: LD_INT 0
42484: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42485: LD_ADDR_VAR 0 3
42489: PUSH
42490: LD_VAR 0 1
42494: PPUSH
42495: CALL_OW 255
42499: PPUSH
42500: LD_VAR 0 1
42504: PPUSH
42505: CALL_OW 250
42509: PPUSH
42510: LD_VAR 0 1
42514: PPUSH
42515: CALL_OW 251
42519: PPUSH
42520: LD_VAR 0 2
42524: PPUSH
42525: CALL 15884 0 4
42529: PUSH
42530: LD_INT 4
42532: ARRAY
42533: ST_TO_ADDR
// end ;
42534: LD_VAR 0 3
42538: RET
// export function PlayerSeeMe ( unit ) ; begin
42539: LD_INT 0
42541: PPUSH
// result := See ( your_side , unit ) ;
42542: LD_ADDR_VAR 0 2
42546: PUSH
42547: LD_OWVAR 2
42551: PPUSH
42552: LD_VAR 0 1
42556: PPUSH
42557: CALL_OW 292
42561: ST_TO_ADDR
// end ;
42562: LD_VAR 0 2
42566: RET
// export function ReverseDir ( unit ) ; begin
42567: LD_INT 0
42569: PPUSH
// if not unit then
42570: LD_VAR 0 1
42574: NOT
42575: IFFALSE 42579
// exit ;
42577: GO 42602
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42579: LD_ADDR_VAR 0 2
42583: PUSH
42584: LD_VAR 0 1
42588: PPUSH
42589: CALL_OW 254
42593: PUSH
42594: LD_INT 3
42596: PLUS
42597: PUSH
42598: LD_INT 6
42600: MOD
42601: ST_TO_ADDR
// end ;
42602: LD_VAR 0 2
42606: RET
// export function ReverseArray ( array ) ; var i ; begin
42607: LD_INT 0
42609: PPUSH
42610: PPUSH
// if not array then
42611: LD_VAR 0 1
42615: NOT
42616: IFFALSE 42620
// exit ;
42618: GO 42675
// result := [ ] ;
42620: LD_ADDR_VAR 0 2
42624: PUSH
42625: EMPTY
42626: ST_TO_ADDR
// for i := array downto 1 do
42627: LD_ADDR_VAR 0 3
42631: PUSH
42632: DOUBLE
42633: LD_VAR 0 1
42637: INC
42638: ST_TO_ADDR
42639: LD_INT 1
42641: PUSH
42642: FOR_DOWNTO
42643: IFFALSE 42673
// result := Join ( result , array [ i ] ) ;
42645: LD_ADDR_VAR 0 2
42649: PUSH
42650: LD_VAR 0 2
42654: PPUSH
42655: LD_VAR 0 1
42659: PUSH
42660: LD_VAR 0 3
42664: ARRAY
42665: PPUSH
42666: CALL 47319 0 2
42670: ST_TO_ADDR
42671: GO 42642
42673: POP
42674: POP
// end ;
42675: LD_VAR 0 2
42679: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42680: LD_INT 0
42682: PPUSH
42683: PPUSH
42684: PPUSH
42685: PPUSH
42686: PPUSH
42687: PPUSH
// if not unit or not hexes then
42688: LD_VAR 0 1
42692: NOT
42693: PUSH
42694: LD_VAR 0 2
42698: NOT
42699: OR
42700: IFFALSE 42704
// exit ;
42702: GO 42827
// dist := 9999 ;
42704: LD_ADDR_VAR 0 5
42708: PUSH
42709: LD_INT 9999
42711: ST_TO_ADDR
// for i = 1 to hexes do
42712: LD_ADDR_VAR 0 4
42716: PUSH
42717: DOUBLE
42718: LD_INT 1
42720: DEC
42721: ST_TO_ADDR
42722: LD_VAR 0 2
42726: PUSH
42727: FOR_TO
42728: IFFALSE 42815
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42730: LD_ADDR_VAR 0 6
42734: PUSH
42735: LD_VAR 0 1
42739: PPUSH
42740: LD_VAR 0 2
42744: PUSH
42745: LD_VAR 0 4
42749: ARRAY
42750: PUSH
42751: LD_INT 1
42753: ARRAY
42754: PPUSH
42755: LD_VAR 0 2
42759: PUSH
42760: LD_VAR 0 4
42764: ARRAY
42765: PUSH
42766: LD_INT 2
42768: ARRAY
42769: PPUSH
42770: CALL_OW 297
42774: ST_TO_ADDR
// if tdist < dist then
42775: LD_VAR 0 6
42779: PUSH
42780: LD_VAR 0 5
42784: LESS
42785: IFFALSE 42813
// begin hex := hexes [ i ] ;
42787: LD_ADDR_VAR 0 8
42791: PUSH
42792: LD_VAR 0 2
42796: PUSH
42797: LD_VAR 0 4
42801: ARRAY
42802: ST_TO_ADDR
// dist := tdist ;
42803: LD_ADDR_VAR 0 5
42807: PUSH
42808: LD_VAR 0 6
42812: ST_TO_ADDR
// end ; end ;
42813: GO 42727
42815: POP
42816: POP
// result := hex ;
42817: LD_ADDR_VAR 0 3
42821: PUSH
42822: LD_VAR 0 8
42826: ST_TO_ADDR
// end ;
42827: LD_VAR 0 3
42831: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42832: LD_INT 0
42834: PPUSH
42835: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42836: LD_VAR 0 1
42840: NOT
42841: PUSH
42842: LD_VAR 0 1
42846: PUSH
42847: LD_INT 21
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 23
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PPUSH
42871: CALL_OW 69
42875: IN
42876: NOT
42877: OR
42878: IFFALSE 42882
// exit ;
42880: GO 42929
// for i = 1 to 3 do
42882: LD_ADDR_VAR 0 3
42886: PUSH
42887: DOUBLE
42888: LD_INT 1
42890: DEC
42891: ST_TO_ADDR
42892: LD_INT 3
42894: PUSH
42895: FOR_TO
42896: IFFALSE 42927
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42898: LD_VAR 0 1
42902: PPUSH
42903: CALL_OW 250
42907: PPUSH
42908: LD_VAR 0 1
42912: PPUSH
42913: CALL_OW 251
42917: PPUSH
42918: LD_INT 1
42920: PPUSH
42921: CALL_OW 453
42925: GO 42895
42927: POP
42928: POP
// end ;
42929: LD_VAR 0 2
42933: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42934: LD_INT 0
42936: PPUSH
42937: PPUSH
42938: PPUSH
42939: PPUSH
42940: PPUSH
42941: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42942: LD_VAR 0 1
42946: NOT
42947: PUSH
42948: LD_VAR 0 2
42952: NOT
42953: OR
42954: PUSH
42955: LD_VAR 0 1
42959: PPUSH
42960: CALL_OW 314
42964: OR
42965: IFFALSE 42969
// exit ;
42967: GO 43436
// if GetLives ( i ) < 250 then
42969: LD_VAR 0 4
42973: PPUSH
42974: CALL_OW 256
42978: PUSH
42979: LD_INT 250
42981: LESS
42982: IFFALSE 42995
// begin ComAutodestruct ( i ) ;
42984: LD_VAR 0 4
42988: PPUSH
42989: CALL 42832 0 1
// exit ;
42993: GO 43436
// end ; x := GetX ( enemy_unit ) ;
42995: LD_ADDR_VAR 0 7
42999: PUSH
43000: LD_VAR 0 2
43004: PPUSH
43005: CALL_OW 250
43009: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43010: LD_ADDR_VAR 0 8
43014: PUSH
43015: LD_VAR 0 2
43019: PPUSH
43020: CALL_OW 251
43024: ST_TO_ADDR
// if not x or not y then
43025: LD_VAR 0 7
43029: NOT
43030: PUSH
43031: LD_VAR 0 8
43035: NOT
43036: OR
43037: IFFALSE 43041
// exit ;
43039: GO 43436
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43041: LD_ADDR_VAR 0 6
43045: PUSH
43046: LD_VAR 0 7
43050: PPUSH
43051: LD_INT 0
43053: PPUSH
43054: LD_INT 4
43056: PPUSH
43057: CALL_OW 272
43061: PUSH
43062: LD_VAR 0 8
43066: PPUSH
43067: LD_INT 0
43069: PPUSH
43070: LD_INT 4
43072: PPUSH
43073: CALL_OW 273
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_VAR 0 7
43086: PPUSH
43087: LD_INT 1
43089: PPUSH
43090: LD_INT 4
43092: PPUSH
43093: CALL_OW 272
43097: PUSH
43098: LD_VAR 0 8
43102: PPUSH
43103: LD_INT 1
43105: PPUSH
43106: LD_INT 4
43108: PPUSH
43109: CALL_OW 273
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_VAR 0 7
43122: PPUSH
43123: LD_INT 2
43125: PPUSH
43126: LD_INT 4
43128: PPUSH
43129: CALL_OW 272
43133: PUSH
43134: LD_VAR 0 8
43138: PPUSH
43139: LD_INT 2
43141: PPUSH
43142: LD_INT 4
43144: PPUSH
43145: CALL_OW 273
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_VAR 0 7
43158: PPUSH
43159: LD_INT 3
43161: PPUSH
43162: LD_INT 4
43164: PPUSH
43165: CALL_OW 272
43169: PUSH
43170: LD_VAR 0 8
43174: PPUSH
43175: LD_INT 3
43177: PPUSH
43178: LD_INT 4
43180: PPUSH
43181: CALL_OW 273
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_VAR 0 7
43194: PPUSH
43195: LD_INT 4
43197: PPUSH
43198: LD_INT 4
43200: PPUSH
43201: CALL_OW 272
43205: PUSH
43206: LD_VAR 0 8
43210: PPUSH
43211: LD_INT 4
43213: PPUSH
43214: LD_INT 4
43216: PPUSH
43217: CALL_OW 273
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_VAR 0 7
43230: PPUSH
43231: LD_INT 5
43233: PPUSH
43234: LD_INT 4
43236: PPUSH
43237: CALL_OW 272
43241: PUSH
43242: LD_VAR 0 8
43246: PPUSH
43247: LD_INT 5
43249: PPUSH
43250: LD_INT 4
43252: PPUSH
43253: CALL_OW 273
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: ST_TO_ADDR
// for i = tmp downto 1 do
43270: LD_ADDR_VAR 0 4
43274: PUSH
43275: DOUBLE
43276: LD_VAR 0 6
43280: INC
43281: ST_TO_ADDR
43282: LD_INT 1
43284: PUSH
43285: FOR_DOWNTO
43286: IFFALSE 43387
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43288: LD_VAR 0 6
43292: PUSH
43293: LD_VAR 0 4
43297: ARRAY
43298: PUSH
43299: LD_INT 1
43301: ARRAY
43302: PPUSH
43303: LD_VAR 0 6
43307: PUSH
43308: LD_VAR 0 4
43312: ARRAY
43313: PUSH
43314: LD_INT 2
43316: ARRAY
43317: PPUSH
43318: CALL_OW 488
43322: NOT
43323: PUSH
43324: LD_VAR 0 6
43328: PUSH
43329: LD_VAR 0 4
43333: ARRAY
43334: PUSH
43335: LD_INT 1
43337: ARRAY
43338: PPUSH
43339: LD_VAR 0 6
43343: PUSH
43344: LD_VAR 0 4
43348: ARRAY
43349: PUSH
43350: LD_INT 2
43352: ARRAY
43353: PPUSH
43354: CALL_OW 428
43358: PUSH
43359: LD_INT 0
43361: NONEQUAL
43362: OR
43363: IFFALSE 43385
// tmp := Delete ( tmp , i ) ;
43365: LD_ADDR_VAR 0 6
43369: PUSH
43370: LD_VAR 0 6
43374: PPUSH
43375: LD_VAR 0 4
43379: PPUSH
43380: CALL_OW 3
43384: ST_TO_ADDR
43385: GO 43285
43387: POP
43388: POP
// j := GetClosestHex ( unit , tmp ) ;
43389: LD_ADDR_VAR 0 5
43393: PUSH
43394: LD_VAR 0 1
43398: PPUSH
43399: LD_VAR 0 6
43403: PPUSH
43404: CALL 42680 0 2
43408: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43409: LD_VAR 0 1
43413: PPUSH
43414: LD_VAR 0 5
43418: PUSH
43419: LD_INT 1
43421: ARRAY
43422: PPUSH
43423: LD_VAR 0 5
43427: PUSH
43428: LD_INT 2
43430: ARRAY
43431: PPUSH
43432: CALL_OW 111
// end ;
43436: LD_VAR 0 3
43440: RET
// export function PrepareApemanSoldier ( ) ; begin
43441: LD_INT 0
43443: PPUSH
// uc_nation := 0 ;
43444: LD_ADDR_OWVAR 21
43448: PUSH
43449: LD_INT 0
43451: ST_TO_ADDR
// hc_sex := sex_male ;
43452: LD_ADDR_OWVAR 27
43456: PUSH
43457: LD_INT 1
43459: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43460: LD_ADDR_OWVAR 28
43464: PUSH
43465: LD_INT 15
43467: ST_TO_ADDR
// hc_gallery :=  ;
43468: LD_ADDR_OWVAR 33
43472: PUSH
43473: LD_STRING 
43475: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43476: LD_ADDR_OWVAR 31
43480: PUSH
43481: LD_INT 0
43483: PPUSH
43484: LD_INT 3
43486: PPUSH
43487: CALL_OW 12
43491: PUSH
43492: LD_INT 0
43494: PPUSH
43495: LD_INT 3
43497: PPUSH
43498: CALL_OW 12
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: LD_INT 0
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: ST_TO_ADDR
// end ;
43515: LD_VAR 0 1
43519: RET
// export function PrepareApemanEngineer ( ) ; begin
43520: LD_INT 0
43522: PPUSH
// uc_nation := 0 ;
43523: LD_ADDR_OWVAR 21
43527: PUSH
43528: LD_INT 0
43530: ST_TO_ADDR
// hc_sex := sex_male ;
43531: LD_ADDR_OWVAR 27
43535: PUSH
43536: LD_INT 1
43538: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43539: LD_ADDR_OWVAR 28
43543: PUSH
43544: LD_INT 16
43546: ST_TO_ADDR
// hc_gallery :=  ;
43547: LD_ADDR_OWVAR 33
43551: PUSH
43552: LD_STRING 
43554: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43555: LD_ADDR_OWVAR 31
43559: PUSH
43560: LD_INT 0
43562: PPUSH
43563: LD_INT 3
43565: PPUSH
43566: CALL_OW 12
43570: PUSH
43571: LD_INT 0
43573: PPUSH
43574: LD_INT 3
43576: PPUSH
43577: CALL_OW 12
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: LD_INT 0
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: ST_TO_ADDR
// end ;
43594: LD_VAR 0 1
43598: RET
// export function PrepareApeman ( agressivity ) ; begin
43599: LD_INT 0
43601: PPUSH
// uc_side := 0 ;
43602: LD_ADDR_OWVAR 20
43606: PUSH
43607: LD_INT 0
43609: ST_TO_ADDR
// uc_nation := 0 ;
43610: LD_ADDR_OWVAR 21
43614: PUSH
43615: LD_INT 0
43617: ST_TO_ADDR
// hc_sex := sex_male ;
43618: LD_ADDR_OWVAR 27
43622: PUSH
43623: LD_INT 1
43625: ST_TO_ADDR
// hc_class := class_apeman ;
43626: LD_ADDR_OWVAR 28
43630: PUSH
43631: LD_INT 12
43633: ST_TO_ADDR
// hc_gallery :=  ;
43634: LD_ADDR_OWVAR 33
43638: PUSH
43639: LD_STRING 
43641: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43642: LD_ADDR_OWVAR 35
43646: PUSH
43647: LD_VAR 0 1
43651: NEG
43652: PPUSH
43653: LD_VAR 0 1
43657: PPUSH
43658: CALL_OW 12
43662: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43663: LD_ADDR_OWVAR 31
43667: PUSH
43668: LD_INT 0
43670: PPUSH
43671: LD_INT 3
43673: PPUSH
43674: CALL_OW 12
43678: PUSH
43679: LD_INT 0
43681: PPUSH
43682: LD_INT 3
43684: PPUSH
43685: CALL_OW 12
43689: PUSH
43690: LD_INT 0
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: ST_TO_ADDR
// end ;
43702: LD_VAR 0 2
43706: RET
// export function PrepareTiger ( agressivity ) ; begin
43707: LD_INT 0
43709: PPUSH
// uc_side := 0 ;
43710: LD_ADDR_OWVAR 20
43714: PUSH
43715: LD_INT 0
43717: ST_TO_ADDR
// uc_nation := 0 ;
43718: LD_ADDR_OWVAR 21
43722: PUSH
43723: LD_INT 0
43725: ST_TO_ADDR
// hc_class := class_tiger ;
43726: LD_ADDR_OWVAR 28
43730: PUSH
43731: LD_INT 14
43733: ST_TO_ADDR
// hc_gallery :=  ;
43734: LD_ADDR_OWVAR 33
43738: PUSH
43739: LD_STRING 
43741: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43742: LD_ADDR_OWVAR 35
43746: PUSH
43747: LD_VAR 0 1
43751: NEG
43752: PPUSH
43753: LD_VAR 0 1
43757: PPUSH
43758: CALL_OW 12
43762: ST_TO_ADDR
// end ;
43763: LD_VAR 0 2
43767: RET
// export function PrepareEnchidna ( ) ; begin
43768: LD_INT 0
43770: PPUSH
// uc_side := 0 ;
43771: LD_ADDR_OWVAR 20
43775: PUSH
43776: LD_INT 0
43778: ST_TO_ADDR
// uc_nation := 0 ;
43779: LD_ADDR_OWVAR 21
43783: PUSH
43784: LD_INT 0
43786: ST_TO_ADDR
// hc_class := class_baggie ;
43787: LD_ADDR_OWVAR 28
43791: PUSH
43792: LD_INT 13
43794: ST_TO_ADDR
// hc_gallery :=  ;
43795: LD_ADDR_OWVAR 33
43799: PUSH
43800: LD_STRING 
43802: ST_TO_ADDR
// end ;
43803: LD_VAR 0 1
43807: RET
// export function PrepareFrog ( ) ; begin
43808: LD_INT 0
43810: PPUSH
// uc_side := 0 ;
43811: LD_ADDR_OWVAR 20
43815: PUSH
43816: LD_INT 0
43818: ST_TO_ADDR
// uc_nation := 0 ;
43819: LD_ADDR_OWVAR 21
43823: PUSH
43824: LD_INT 0
43826: ST_TO_ADDR
// hc_class := class_frog ;
43827: LD_ADDR_OWVAR 28
43831: PUSH
43832: LD_INT 19
43834: ST_TO_ADDR
// hc_gallery :=  ;
43835: LD_ADDR_OWVAR 33
43839: PUSH
43840: LD_STRING 
43842: ST_TO_ADDR
// end ;
43843: LD_VAR 0 1
43847: RET
// export function PrepareFish ( ) ; begin
43848: LD_INT 0
43850: PPUSH
// uc_side := 0 ;
43851: LD_ADDR_OWVAR 20
43855: PUSH
43856: LD_INT 0
43858: ST_TO_ADDR
// uc_nation := 0 ;
43859: LD_ADDR_OWVAR 21
43863: PUSH
43864: LD_INT 0
43866: ST_TO_ADDR
// hc_class := class_fish ;
43867: LD_ADDR_OWVAR 28
43871: PUSH
43872: LD_INT 20
43874: ST_TO_ADDR
// hc_gallery :=  ;
43875: LD_ADDR_OWVAR 33
43879: PUSH
43880: LD_STRING 
43882: ST_TO_ADDR
// end ;
43883: LD_VAR 0 1
43887: RET
// export function PrepareBird ( ) ; begin
43888: LD_INT 0
43890: PPUSH
// uc_side := 0 ;
43891: LD_ADDR_OWVAR 20
43895: PUSH
43896: LD_INT 0
43898: ST_TO_ADDR
// uc_nation := 0 ;
43899: LD_ADDR_OWVAR 21
43903: PUSH
43904: LD_INT 0
43906: ST_TO_ADDR
// hc_class := class_phororhacos ;
43907: LD_ADDR_OWVAR 28
43911: PUSH
43912: LD_INT 18
43914: ST_TO_ADDR
// hc_gallery :=  ;
43915: LD_ADDR_OWVAR 33
43919: PUSH
43920: LD_STRING 
43922: ST_TO_ADDR
// end ;
43923: LD_VAR 0 1
43927: RET
// export function PrepareHorse ( ) ; begin
43928: LD_INT 0
43930: PPUSH
// uc_side := 0 ;
43931: LD_ADDR_OWVAR 20
43935: PUSH
43936: LD_INT 0
43938: ST_TO_ADDR
// uc_nation := 0 ;
43939: LD_ADDR_OWVAR 21
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// hc_class := class_horse ;
43947: LD_ADDR_OWVAR 28
43951: PUSH
43952: LD_INT 21
43954: ST_TO_ADDR
// hc_gallery :=  ;
43955: LD_ADDR_OWVAR 33
43959: PUSH
43960: LD_STRING 
43962: ST_TO_ADDR
// end ;
43963: LD_VAR 0 1
43967: RET
// export function PrepareMastodont ( ) ; begin
43968: LD_INT 0
43970: PPUSH
// uc_side := 0 ;
43971: LD_ADDR_OWVAR 20
43975: PUSH
43976: LD_INT 0
43978: ST_TO_ADDR
// uc_nation := 0 ;
43979: LD_ADDR_OWVAR 21
43983: PUSH
43984: LD_INT 0
43986: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43987: LD_ADDR_OWVAR 37
43991: PUSH
43992: LD_INT 31
43994: ST_TO_ADDR
// vc_control := control_rider ;
43995: LD_ADDR_OWVAR 38
43999: PUSH
44000: LD_INT 4
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 1
44007: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
44012: PPUSH
// uc_side = 0 ;
44013: LD_ADDR_OWVAR 20
44017: PUSH
44018: LD_INT 0
44020: ST_TO_ADDR
// uc_nation = 0 ;
44021: LD_ADDR_OWVAR 21
44025: PUSH
44026: LD_INT 0
44028: ST_TO_ADDR
// InitHc_All ( ) ;
44029: CALL_OW 584
// InitVc ;
44033: CALL_OW 20
// if mastodonts then
44037: LD_VAR 0 6
44041: IFFALSE 44108
// for i = 1 to mastodonts do
44043: LD_ADDR_VAR 0 11
44047: PUSH
44048: DOUBLE
44049: LD_INT 1
44051: DEC
44052: ST_TO_ADDR
44053: LD_VAR 0 6
44057: PUSH
44058: FOR_TO
44059: IFFALSE 44106
// begin vc_chassis := 31 ;
44061: LD_ADDR_OWVAR 37
44065: PUSH
44066: LD_INT 31
44068: ST_TO_ADDR
// vc_control := control_rider ;
44069: LD_ADDR_OWVAR 38
44073: PUSH
44074: LD_INT 4
44076: ST_TO_ADDR
// animal := CreateVehicle ;
44077: LD_ADDR_VAR 0 12
44081: PUSH
44082: CALL_OW 45
44086: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44087: LD_VAR 0 12
44091: PPUSH
44092: LD_VAR 0 8
44096: PPUSH
44097: LD_INT 0
44099: PPUSH
44100: CALL 46236 0 3
// end ;
44104: GO 44058
44106: POP
44107: POP
// if horses then
44108: LD_VAR 0 5
44112: IFFALSE 44179
// for i = 1 to horses do
44114: LD_ADDR_VAR 0 11
44118: PUSH
44119: DOUBLE
44120: LD_INT 1
44122: DEC
44123: ST_TO_ADDR
44124: LD_VAR 0 5
44128: PUSH
44129: FOR_TO
44130: IFFALSE 44177
// begin hc_class := 21 ;
44132: LD_ADDR_OWVAR 28
44136: PUSH
44137: LD_INT 21
44139: ST_TO_ADDR
// hc_gallery :=  ;
44140: LD_ADDR_OWVAR 33
44144: PUSH
44145: LD_STRING 
44147: ST_TO_ADDR
// animal := CreateHuman ;
44148: LD_ADDR_VAR 0 12
44152: PUSH
44153: CALL_OW 44
44157: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44158: LD_VAR 0 12
44162: PPUSH
44163: LD_VAR 0 8
44167: PPUSH
44168: LD_INT 0
44170: PPUSH
44171: CALL 46236 0 3
// end ;
44175: GO 44129
44177: POP
44178: POP
// if birds then
44179: LD_VAR 0 1
44183: IFFALSE 44250
// for i = 1 to birds do
44185: LD_ADDR_VAR 0 11
44189: PUSH
44190: DOUBLE
44191: LD_INT 1
44193: DEC
44194: ST_TO_ADDR
44195: LD_VAR 0 1
44199: PUSH
44200: FOR_TO
44201: IFFALSE 44248
// begin hc_class = 18 ;
44203: LD_ADDR_OWVAR 28
44207: PUSH
44208: LD_INT 18
44210: ST_TO_ADDR
// hc_gallery =  ;
44211: LD_ADDR_OWVAR 33
44215: PUSH
44216: LD_STRING 
44218: ST_TO_ADDR
// animal := CreateHuman ;
44219: LD_ADDR_VAR 0 12
44223: PUSH
44224: CALL_OW 44
44228: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44229: LD_VAR 0 12
44233: PPUSH
44234: LD_VAR 0 8
44238: PPUSH
44239: LD_INT 0
44241: PPUSH
44242: CALL 46236 0 3
// end ;
44246: GO 44200
44248: POP
44249: POP
// if tigers then
44250: LD_VAR 0 2
44254: IFFALSE 44338
// for i = 1 to tigers do
44256: LD_ADDR_VAR 0 11
44260: PUSH
44261: DOUBLE
44262: LD_INT 1
44264: DEC
44265: ST_TO_ADDR
44266: LD_VAR 0 2
44270: PUSH
44271: FOR_TO
44272: IFFALSE 44336
// begin hc_class = class_tiger ;
44274: LD_ADDR_OWVAR 28
44278: PUSH
44279: LD_INT 14
44281: ST_TO_ADDR
// hc_gallery =  ;
44282: LD_ADDR_OWVAR 33
44286: PUSH
44287: LD_STRING 
44289: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44290: LD_ADDR_OWVAR 35
44294: PUSH
44295: LD_INT 7
44297: NEG
44298: PPUSH
44299: LD_INT 7
44301: PPUSH
44302: CALL_OW 12
44306: ST_TO_ADDR
// animal := CreateHuman ;
44307: LD_ADDR_VAR 0 12
44311: PUSH
44312: CALL_OW 44
44316: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44317: LD_VAR 0 12
44321: PPUSH
44322: LD_VAR 0 8
44326: PPUSH
44327: LD_INT 0
44329: PPUSH
44330: CALL 46236 0 3
// end ;
44334: GO 44271
44336: POP
44337: POP
// if apemans then
44338: LD_VAR 0 3
44342: IFFALSE 44465
// for i = 1 to apemans do
44344: LD_ADDR_VAR 0 11
44348: PUSH
44349: DOUBLE
44350: LD_INT 1
44352: DEC
44353: ST_TO_ADDR
44354: LD_VAR 0 3
44358: PUSH
44359: FOR_TO
44360: IFFALSE 44463
// begin hc_class = class_apeman ;
44362: LD_ADDR_OWVAR 28
44366: PUSH
44367: LD_INT 12
44369: ST_TO_ADDR
// hc_gallery =  ;
44370: LD_ADDR_OWVAR 33
44374: PUSH
44375: LD_STRING 
44377: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44378: LD_ADDR_OWVAR 35
44382: PUSH
44383: LD_INT 2
44385: NEG
44386: PPUSH
44387: LD_INT 2
44389: PPUSH
44390: CALL_OW 12
44394: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44395: LD_ADDR_OWVAR 31
44399: PUSH
44400: LD_INT 1
44402: PPUSH
44403: LD_INT 3
44405: PPUSH
44406: CALL_OW 12
44410: PUSH
44411: LD_INT 1
44413: PPUSH
44414: LD_INT 3
44416: PPUSH
44417: CALL_OW 12
44421: PUSH
44422: LD_INT 0
44424: PUSH
44425: LD_INT 0
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: ST_TO_ADDR
// animal := CreateHuman ;
44434: LD_ADDR_VAR 0 12
44438: PUSH
44439: CALL_OW 44
44443: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44444: LD_VAR 0 12
44448: PPUSH
44449: LD_VAR 0 8
44453: PPUSH
44454: LD_INT 0
44456: PPUSH
44457: CALL 46236 0 3
// end ;
44461: GO 44359
44463: POP
44464: POP
// if enchidnas then
44465: LD_VAR 0 4
44469: IFFALSE 44536
// for i = 1 to enchidnas do
44471: LD_ADDR_VAR 0 11
44475: PUSH
44476: DOUBLE
44477: LD_INT 1
44479: DEC
44480: ST_TO_ADDR
44481: LD_VAR 0 4
44485: PUSH
44486: FOR_TO
44487: IFFALSE 44534
// begin hc_class = 13 ;
44489: LD_ADDR_OWVAR 28
44493: PUSH
44494: LD_INT 13
44496: ST_TO_ADDR
// hc_gallery =  ;
44497: LD_ADDR_OWVAR 33
44501: PUSH
44502: LD_STRING 
44504: ST_TO_ADDR
// animal := CreateHuman ;
44505: LD_ADDR_VAR 0 12
44509: PUSH
44510: CALL_OW 44
44514: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44515: LD_VAR 0 12
44519: PPUSH
44520: LD_VAR 0 8
44524: PPUSH
44525: LD_INT 0
44527: PPUSH
44528: CALL 46236 0 3
// end ;
44532: GO 44486
44534: POP
44535: POP
// if fishes then
44536: LD_VAR 0 7
44540: IFFALSE 44607
// for i = 1 to fishes do
44542: LD_ADDR_VAR 0 11
44546: PUSH
44547: DOUBLE
44548: LD_INT 1
44550: DEC
44551: ST_TO_ADDR
44552: LD_VAR 0 7
44556: PUSH
44557: FOR_TO
44558: IFFALSE 44605
// begin hc_class = 20 ;
44560: LD_ADDR_OWVAR 28
44564: PUSH
44565: LD_INT 20
44567: ST_TO_ADDR
// hc_gallery =  ;
44568: LD_ADDR_OWVAR 33
44572: PUSH
44573: LD_STRING 
44575: ST_TO_ADDR
// animal := CreateHuman ;
44576: LD_ADDR_VAR 0 12
44580: PUSH
44581: CALL_OW 44
44585: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44586: LD_VAR 0 12
44590: PPUSH
44591: LD_VAR 0 9
44595: PPUSH
44596: LD_INT 0
44598: PPUSH
44599: CALL 46236 0 3
// end ;
44603: GO 44557
44605: POP
44606: POP
// end ;
44607: LD_VAR 0 10
44611: RET
// export function WantHeal ( sci , unit ) ; begin
44612: LD_INT 0
44614: PPUSH
// if GetTaskList ( sci ) > 0 then
44615: LD_VAR 0 1
44619: PPUSH
44620: CALL_OW 437
44624: PUSH
44625: LD_INT 0
44627: GREATER
44628: IFFALSE 44698
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44630: LD_VAR 0 1
44634: PPUSH
44635: CALL_OW 437
44639: PUSH
44640: LD_INT 1
44642: ARRAY
44643: PUSH
44644: LD_INT 1
44646: ARRAY
44647: PUSH
44648: LD_STRING l
44650: EQUAL
44651: PUSH
44652: LD_VAR 0 1
44656: PPUSH
44657: CALL_OW 437
44661: PUSH
44662: LD_INT 1
44664: ARRAY
44665: PUSH
44666: LD_INT 4
44668: ARRAY
44669: PUSH
44670: LD_VAR 0 2
44674: EQUAL
44675: AND
44676: IFFALSE 44688
// result := true else
44678: LD_ADDR_VAR 0 3
44682: PUSH
44683: LD_INT 1
44685: ST_TO_ADDR
44686: GO 44696
// result := false ;
44688: LD_ADDR_VAR 0 3
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// end else
44696: GO 44706
// result := false ;
44698: LD_ADDR_VAR 0 3
44702: PUSH
44703: LD_INT 0
44705: ST_TO_ADDR
// end ;
44706: LD_VAR 0 3
44710: RET
// export function HealTarget ( sci ) ; begin
44711: LD_INT 0
44713: PPUSH
// if not sci then
44714: LD_VAR 0 1
44718: NOT
44719: IFFALSE 44723
// exit ;
44721: GO 44788
// result := 0 ;
44723: LD_ADDR_VAR 0 2
44727: PUSH
44728: LD_INT 0
44730: ST_TO_ADDR
// if GetTaskList ( sci ) then
44731: LD_VAR 0 1
44735: PPUSH
44736: CALL_OW 437
44740: IFFALSE 44788
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44742: LD_VAR 0 1
44746: PPUSH
44747: CALL_OW 437
44751: PUSH
44752: LD_INT 1
44754: ARRAY
44755: PUSH
44756: LD_INT 1
44758: ARRAY
44759: PUSH
44760: LD_STRING l
44762: EQUAL
44763: IFFALSE 44788
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44765: LD_ADDR_VAR 0 2
44769: PUSH
44770: LD_VAR 0 1
44774: PPUSH
44775: CALL_OW 437
44779: PUSH
44780: LD_INT 1
44782: ARRAY
44783: PUSH
44784: LD_INT 4
44786: ARRAY
44787: ST_TO_ADDR
// end ;
44788: LD_VAR 0 2
44792: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44793: LD_INT 0
44795: PPUSH
44796: PPUSH
44797: PPUSH
44798: PPUSH
// if not base_units then
44799: LD_VAR 0 1
44803: NOT
44804: IFFALSE 44808
// exit ;
44806: GO 44895
// result := false ;
44808: LD_ADDR_VAR 0 2
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44816: LD_ADDR_VAR 0 5
44820: PUSH
44821: LD_VAR 0 1
44825: PPUSH
44826: LD_INT 21
44828: PUSH
44829: LD_INT 3
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PPUSH
44836: CALL_OW 72
44840: ST_TO_ADDR
// if not tmp then
44841: LD_VAR 0 5
44845: NOT
44846: IFFALSE 44850
// exit ;
44848: GO 44895
// for i in tmp do
44850: LD_ADDR_VAR 0 3
44854: PUSH
44855: LD_VAR 0 5
44859: PUSH
44860: FOR_IN
44861: IFFALSE 44893
// begin result := EnemyInRange ( i , 22 ) ;
44863: LD_ADDR_VAR 0 2
44867: PUSH
44868: LD_VAR 0 3
44872: PPUSH
44873: LD_INT 22
44875: PPUSH
44876: CALL 42482 0 2
44880: ST_TO_ADDR
// if result then
44881: LD_VAR 0 2
44885: IFFALSE 44891
// exit ;
44887: POP
44888: POP
44889: GO 44895
// end ;
44891: GO 44860
44893: POP
44894: POP
// end ;
44895: LD_VAR 0 2
44899: RET
// export function FilterByTag ( units , tag ) ; begin
44900: LD_INT 0
44902: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44903: LD_ADDR_VAR 0 3
44907: PUSH
44908: LD_VAR 0 1
44912: PPUSH
44913: LD_INT 120
44915: PUSH
44916: LD_VAR 0 2
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PPUSH
44925: CALL_OW 72
44929: ST_TO_ADDR
// end ;
44930: LD_VAR 0 3
44934: RET
// export function IsDriver ( un ) ; begin
44935: LD_INT 0
44937: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44938: LD_ADDR_VAR 0 2
44942: PUSH
44943: LD_VAR 0 1
44947: PUSH
44948: LD_INT 55
44950: PUSH
44951: EMPTY
44952: LIST
44953: PPUSH
44954: CALL_OW 69
44958: IN
44959: ST_TO_ADDR
// end ;
44960: LD_VAR 0 2
44964: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44965: LD_INT 0
44967: PPUSH
44968: PPUSH
// list := [ ] ;
44969: LD_ADDR_VAR 0 5
44973: PUSH
44974: EMPTY
44975: ST_TO_ADDR
// case d of 0 :
44976: LD_VAR 0 3
44980: PUSH
44981: LD_INT 0
44983: DOUBLE
44984: EQUAL
44985: IFTRUE 44989
44987: GO 45122
44989: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44990: LD_ADDR_VAR 0 5
44994: PUSH
44995: LD_VAR 0 1
44999: PUSH
45000: LD_INT 4
45002: MINUS
45003: PUSH
45004: LD_VAR 0 2
45008: PUSH
45009: LD_INT 4
45011: MINUS
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: LIST
45020: PUSH
45021: LD_VAR 0 1
45025: PUSH
45026: LD_INT 3
45028: MINUS
45029: PUSH
45030: LD_VAR 0 2
45034: PUSH
45035: LD_INT 1
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: LIST
45042: PUSH
45043: LD_VAR 0 1
45047: PUSH
45048: LD_INT 4
45050: PLUS
45051: PUSH
45052: LD_VAR 0 2
45056: PUSH
45057: LD_INT 4
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: LIST
45064: PUSH
45065: LD_VAR 0 1
45069: PUSH
45070: LD_INT 3
45072: PLUS
45073: PUSH
45074: LD_VAR 0 2
45078: PUSH
45079: LD_INT 3
45081: PLUS
45082: PUSH
45083: LD_INT 5
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: LIST
45090: PUSH
45091: LD_VAR 0 1
45095: PUSH
45096: LD_VAR 0 2
45100: PUSH
45101: LD_INT 4
45103: PLUS
45104: PUSH
45105: LD_INT 0
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: LIST
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: ST_TO_ADDR
// end ; 1 :
45120: GO 45820
45122: LD_INT 1
45124: DOUBLE
45125: EQUAL
45126: IFTRUE 45130
45128: GO 45263
45130: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45131: LD_ADDR_VAR 0 5
45135: PUSH
45136: LD_VAR 0 1
45140: PUSH
45141: LD_VAR 0 2
45145: PUSH
45146: LD_INT 4
45148: MINUS
45149: PUSH
45150: LD_INT 3
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: LIST
45157: PUSH
45158: LD_VAR 0 1
45162: PUSH
45163: LD_INT 3
45165: MINUS
45166: PUSH
45167: LD_VAR 0 2
45171: PUSH
45172: LD_INT 3
45174: MINUS
45175: PUSH
45176: LD_INT 2
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: LIST
45183: PUSH
45184: LD_VAR 0 1
45188: PUSH
45189: LD_INT 4
45191: MINUS
45192: PUSH
45193: LD_VAR 0 2
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: PUSH
45206: LD_VAR 0 1
45210: PUSH
45211: LD_VAR 0 2
45215: PUSH
45216: LD_INT 3
45218: PLUS
45219: PUSH
45220: LD_INT 0
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: LIST
45227: PUSH
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 4
45235: PLUS
45236: PUSH
45237: LD_VAR 0 2
45241: PUSH
45242: LD_INT 4
45244: PLUS
45245: PUSH
45246: LD_INT 5
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: LIST
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: ST_TO_ADDR
// end ; 2 :
45261: GO 45820
45263: LD_INT 2
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45271
45269: GO 45400
45271: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45272: LD_ADDR_VAR 0 5
45276: PUSH
45277: LD_VAR 0 1
45281: PUSH
45282: LD_VAR 0 2
45286: PUSH
45287: LD_INT 3
45289: MINUS
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: LIST
45298: PUSH
45299: LD_VAR 0 1
45303: PUSH
45304: LD_INT 4
45306: PLUS
45307: PUSH
45308: LD_VAR 0 2
45312: PUSH
45313: LD_INT 4
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: LIST
45320: PUSH
45321: LD_VAR 0 1
45325: PUSH
45326: LD_VAR 0 2
45330: PUSH
45331: LD_INT 4
45333: PLUS
45334: PUSH
45335: LD_INT 0
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: LIST
45342: PUSH
45343: LD_VAR 0 1
45347: PUSH
45348: LD_INT 3
45350: MINUS
45351: PUSH
45352: LD_VAR 0 2
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: PUSH
45365: LD_VAR 0 1
45369: PUSH
45370: LD_INT 4
45372: MINUS
45373: PUSH
45374: LD_VAR 0 2
45378: PUSH
45379: LD_INT 4
45381: MINUS
45382: PUSH
45383: LD_INT 2
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: LIST
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: ST_TO_ADDR
// end ; 3 :
45398: GO 45820
45400: LD_INT 3
45402: DOUBLE
45403: EQUAL
45404: IFTRUE 45408
45406: GO 45541
45408: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45409: LD_ADDR_VAR 0 5
45413: PUSH
45414: LD_VAR 0 1
45418: PUSH
45419: LD_INT 3
45421: PLUS
45422: PUSH
45423: LD_VAR 0 2
45427: PUSH
45428: LD_INT 4
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: LIST
45435: PUSH
45436: LD_VAR 0 1
45440: PUSH
45441: LD_INT 4
45443: PLUS
45444: PUSH
45445: LD_VAR 0 2
45449: PUSH
45450: LD_INT 4
45452: PLUS
45453: PUSH
45454: LD_INT 5
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: LIST
45461: PUSH
45462: LD_VAR 0 1
45466: PUSH
45467: LD_INT 4
45469: MINUS
45470: PUSH
45471: LD_VAR 0 2
45475: PUSH
45476: LD_INT 1
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: LIST
45483: PUSH
45484: LD_VAR 0 1
45488: PUSH
45489: LD_VAR 0 2
45493: PUSH
45494: LD_INT 4
45496: MINUS
45497: PUSH
45498: LD_INT 3
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 1
45510: PUSH
45511: LD_INT 3
45513: MINUS
45514: PUSH
45515: LD_VAR 0 2
45519: PUSH
45520: LD_INT 3
45522: MINUS
45523: PUSH
45524: LD_INT 2
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: LIST
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: ST_TO_ADDR
// end ; 4 :
45539: GO 45820
45541: LD_INT 4
45543: DOUBLE
45544: EQUAL
45545: IFTRUE 45549
45547: GO 45682
45549: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45550: LD_ADDR_VAR 0 5
45554: PUSH
45555: LD_VAR 0 1
45559: PUSH
45560: LD_VAR 0 2
45564: PUSH
45565: LD_INT 4
45567: PLUS
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: LIST
45576: PUSH
45577: LD_VAR 0 1
45581: PUSH
45582: LD_INT 3
45584: PLUS
45585: PUSH
45586: LD_VAR 0 2
45590: PUSH
45591: LD_INT 3
45593: PLUS
45594: PUSH
45595: LD_INT 5
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: LIST
45602: PUSH
45603: LD_VAR 0 1
45607: PUSH
45608: LD_INT 4
45610: PLUS
45611: PUSH
45612: LD_VAR 0 2
45616: PUSH
45617: LD_INT 4
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: LIST
45624: PUSH
45625: LD_VAR 0 1
45629: PUSH
45630: LD_VAR 0 2
45634: PUSH
45635: LD_INT 3
45637: MINUS
45638: PUSH
45639: LD_INT 3
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: LIST
45646: PUSH
45647: LD_VAR 0 1
45651: PUSH
45652: LD_INT 4
45654: MINUS
45655: PUSH
45656: LD_VAR 0 2
45660: PUSH
45661: LD_INT 4
45663: MINUS
45664: PUSH
45665: LD_INT 2
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: ST_TO_ADDR
// end ; 5 :
45680: GO 45820
45682: LD_INT 5
45684: DOUBLE
45685: EQUAL
45686: IFTRUE 45690
45688: GO 45819
45690: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45691: LD_ADDR_VAR 0 5
45695: PUSH
45696: LD_VAR 0 1
45700: PUSH
45701: LD_INT 4
45703: MINUS
45704: PUSH
45705: LD_VAR 0 2
45709: PUSH
45710: LD_INT 1
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: LIST
45717: PUSH
45718: LD_VAR 0 1
45722: PUSH
45723: LD_VAR 0 2
45727: PUSH
45728: LD_INT 4
45730: MINUS
45731: PUSH
45732: LD_INT 3
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: LIST
45739: PUSH
45740: LD_VAR 0 1
45744: PUSH
45745: LD_INT 4
45747: PLUS
45748: PUSH
45749: LD_VAR 0 2
45753: PUSH
45754: LD_INT 4
45756: PLUS
45757: PUSH
45758: LD_INT 5
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: LIST
45765: PUSH
45766: LD_VAR 0 1
45770: PUSH
45771: LD_INT 3
45773: PLUS
45774: PUSH
45775: LD_VAR 0 2
45779: PUSH
45780: LD_INT 4
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: LIST
45787: PUSH
45788: LD_VAR 0 1
45792: PUSH
45793: LD_VAR 0 2
45797: PUSH
45798: LD_INT 3
45800: PLUS
45801: PUSH
45802: LD_INT 0
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: LIST
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: ST_TO_ADDR
// end ; end ;
45817: GO 45820
45819: POP
// result := list ;
45820: LD_ADDR_VAR 0 4
45824: PUSH
45825: LD_VAR 0 5
45829: ST_TO_ADDR
// end ;
45830: LD_VAR 0 4
45834: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45835: LD_INT 0
45837: PPUSH
45838: PPUSH
45839: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45840: LD_VAR 0 1
45844: NOT
45845: PUSH
45846: LD_VAR 0 2
45850: PUSH
45851: LD_INT 1
45853: PUSH
45854: LD_INT 2
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: LD_INT 4
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: IN
45869: NOT
45870: OR
45871: IFFALSE 45875
// exit ;
45873: GO 45958
// tmp := [ ] ;
45875: LD_ADDR_VAR 0 5
45879: PUSH
45880: EMPTY
45881: ST_TO_ADDR
// for i in units do
45882: LD_ADDR_VAR 0 4
45886: PUSH
45887: LD_VAR 0 1
45891: PUSH
45892: FOR_IN
45893: IFFALSE 45927
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
45895: LD_ADDR_VAR 0 5
45899: PUSH
45900: LD_VAR 0 5
45904: PPUSH
45905: LD_VAR 0 4
45909: PPUSH
45910: LD_VAR 0 2
45914: PPUSH
45915: CALL_OW 259
45919: PPUSH
45920: CALL 47319 0 2
45924: ST_TO_ADDR
45925: GO 45892
45927: POP
45928: POP
// if not tmp then
45929: LD_VAR 0 5
45933: NOT
45934: IFFALSE 45938
// exit ;
45936: GO 45958
// result := SortListByListDesc ( units , tmp ) ;
45938: LD_ADDR_VAR 0 3
45942: PUSH
45943: LD_VAR 0 1
45947: PPUSH
45948: LD_VAR 0 5
45952: PPUSH
45953: CALL_OW 77
45957: ST_TO_ADDR
// end ;
45958: LD_VAR 0 3
45962: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45963: LD_INT 0
45965: PPUSH
45966: PPUSH
45967: PPUSH
// result := false ;
45968: LD_ADDR_VAR 0 3
45972: PUSH
45973: LD_INT 0
45975: ST_TO_ADDR
// if not building then
45976: LD_VAR 0 2
45980: NOT
45981: IFFALSE 45985
// exit ;
45983: GO 46123
// x := GetX ( building ) ;
45985: LD_ADDR_VAR 0 4
45989: PUSH
45990: LD_VAR 0 2
45994: PPUSH
45995: CALL_OW 250
45999: ST_TO_ADDR
// y := GetY ( building ) ;
46000: LD_ADDR_VAR 0 5
46004: PUSH
46005: LD_VAR 0 2
46009: PPUSH
46010: CALL_OW 251
46014: ST_TO_ADDR
// if not x or not y then
46015: LD_VAR 0 4
46019: NOT
46020: PUSH
46021: LD_VAR 0 5
46025: NOT
46026: OR
46027: IFFALSE 46031
// exit ;
46029: GO 46123
// if GetTaskList ( unit ) then
46031: LD_VAR 0 1
46035: PPUSH
46036: CALL_OW 437
46040: IFFALSE 46123
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46042: LD_STRING e
46044: PUSH
46045: LD_VAR 0 1
46049: PPUSH
46050: CALL_OW 437
46054: PUSH
46055: LD_INT 1
46057: ARRAY
46058: PUSH
46059: LD_INT 1
46061: ARRAY
46062: EQUAL
46063: PUSH
46064: LD_VAR 0 4
46068: PUSH
46069: LD_VAR 0 1
46073: PPUSH
46074: CALL_OW 437
46078: PUSH
46079: LD_INT 1
46081: ARRAY
46082: PUSH
46083: LD_INT 2
46085: ARRAY
46086: EQUAL
46087: AND
46088: PUSH
46089: LD_VAR 0 5
46093: PUSH
46094: LD_VAR 0 1
46098: PPUSH
46099: CALL_OW 437
46103: PUSH
46104: LD_INT 1
46106: ARRAY
46107: PUSH
46108: LD_INT 3
46110: ARRAY
46111: EQUAL
46112: AND
46113: IFFALSE 46123
// result := true end ;
46115: LD_ADDR_VAR 0 3
46119: PUSH
46120: LD_INT 1
46122: ST_TO_ADDR
// end ;
46123: LD_VAR 0 3
46127: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46128: LD_INT 0
46130: PPUSH
// result := false ;
46131: LD_ADDR_VAR 0 4
46135: PUSH
46136: LD_INT 0
46138: ST_TO_ADDR
// if GetTaskList ( unit ) then
46139: LD_VAR 0 1
46143: PPUSH
46144: CALL_OW 437
46148: IFFALSE 46231
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46150: LD_STRING M
46152: PUSH
46153: LD_VAR 0 1
46157: PPUSH
46158: CALL_OW 437
46162: PUSH
46163: LD_INT 1
46165: ARRAY
46166: PUSH
46167: LD_INT 1
46169: ARRAY
46170: EQUAL
46171: PUSH
46172: LD_VAR 0 2
46176: PUSH
46177: LD_VAR 0 1
46181: PPUSH
46182: CALL_OW 437
46186: PUSH
46187: LD_INT 1
46189: ARRAY
46190: PUSH
46191: LD_INT 2
46193: ARRAY
46194: EQUAL
46195: AND
46196: PUSH
46197: LD_VAR 0 3
46201: PUSH
46202: LD_VAR 0 1
46206: PPUSH
46207: CALL_OW 437
46211: PUSH
46212: LD_INT 1
46214: ARRAY
46215: PUSH
46216: LD_INT 3
46218: ARRAY
46219: EQUAL
46220: AND
46221: IFFALSE 46231
// result := true ;
46223: LD_ADDR_VAR 0 4
46227: PUSH
46228: LD_INT 1
46230: ST_TO_ADDR
// end ; end ;
46231: LD_VAR 0 4
46235: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46236: LD_INT 0
46238: PPUSH
46239: PPUSH
46240: PPUSH
46241: PPUSH
// if not unit or not area then
46242: LD_VAR 0 1
46246: NOT
46247: PUSH
46248: LD_VAR 0 2
46252: NOT
46253: OR
46254: IFFALSE 46258
// exit ;
46256: GO 46422
// tmp := AreaToList ( area , i ) ;
46258: LD_ADDR_VAR 0 6
46262: PUSH
46263: LD_VAR 0 2
46267: PPUSH
46268: LD_VAR 0 5
46272: PPUSH
46273: CALL_OW 517
46277: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46278: LD_ADDR_VAR 0 5
46282: PUSH
46283: DOUBLE
46284: LD_INT 1
46286: DEC
46287: ST_TO_ADDR
46288: LD_VAR 0 6
46292: PUSH
46293: LD_INT 1
46295: ARRAY
46296: PUSH
46297: FOR_TO
46298: IFFALSE 46420
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46300: LD_ADDR_VAR 0 7
46304: PUSH
46305: LD_VAR 0 6
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: PUSH
46314: LD_VAR 0 5
46318: ARRAY
46319: PUSH
46320: LD_VAR 0 6
46324: PUSH
46325: LD_INT 2
46327: ARRAY
46328: PUSH
46329: LD_VAR 0 5
46333: ARRAY
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46339: LD_VAR 0 7
46343: PUSH
46344: LD_INT 1
46346: ARRAY
46347: PPUSH
46348: LD_VAR 0 7
46352: PUSH
46353: LD_INT 2
46355: ARRAY
46356: PPUSH
46357: CALL_OW 428
46361: PUSH
46362: LD_INT 0
46364: EQUAL
46365: IFFALSE 46418
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46367: LD_VAR 0 1
46371: PPUSH
46372: LD_VAR 0 7
46376: PUSH
46377: LD_INT 1
46379: ARRAY
46380: PPUSH
46381: LD_VAR 0 7
46385: PUSH
46386: LD_INT 2
46388: ARRAY
46389: PPUSH
46390: LD_VAR 0 3
46394: PPUSH
46395: CALL_OW 48
// result := IsPlaced ( unit ) ;
46399: LD_ADDR_VAR 0 4
46403: PUSH
46404: LD_VAR 0 1
46408: PPUSH
46409: CALL_OW 305
46413: ST_TO_ADDR
// exit ;
46414: POP
46415: POP
46416: GO 46422
// end ; end ;
46418: GO 46297
46420: POP
46421: POP
// end ;
46422: LD_VAR 0 4
46426: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46427: LD_INT 0
46429: PPUSH
46430: PPUSH
46431: PPUSH
// if not side or side > 8 then
46432: LD_VAR 0 1
46436: NOT
46437: PUSH
46438: LD_VAR 0 1
46442: PUSH
46443: LD_INT 8
46445: GREATER
46446: OR
46447: IFFALSE 46451
// exit ;
46449: GO 46638
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46451: LD_ADDR_VAR 0 4
46455: PUSH
46456: LD_INT 22
46458: PUSH
46459: LD_VAR 0 1
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 21
46470: PUSH
46471: LD_INT 3
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PPUSH
46482: CALL_OW 69
46486: ST_TO_ADDR
// if not tmp then
46487: LD_VAR 0 4
46491: NOT
46492: IFFALSE 46496
// exit ;
46494: GO 46638
// enable_addtolog := true ;
46496: LD_ADDR_OWVAR 81
46500: PUSH
46501: LD_INT 1
46503: ST_TO_ADDR
// AddToLog ( [ ) ;
46504: LD_STRING [
46506: PPUSH
46507: CALL_OW 561
// for i in tmp do
46511: LD_ADDR_VAR 0 3
46515: PUSH
46516: LD_VAR 0 4
46520: PUSH
46521: FOR_IN
46522: IFFALSE 46629
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46524: LD_STRING [
46526: PUSH
46527: LD_VAR 0 3
46531: PPUSH
46532: CALL_OW 266
46536: STR
46537: PUSH
46538: LD_STRING , 
46540: STR
46541: PUSH
46542: LD_VAR 0 3
46546: PPUSH
46547: CALL_OW 250
46551: STR
46552: PUSH
46553: LD_STRING , 
46555: STR
46556: PUSH
46557: LD_VAR 0 3
46561: PPUSH
46562: CALL_OW 251
46566: STR
46567: PUSH
46568: LD_STRING , 
46570: STR
46571: PUSH
46572: LD_VAR 0 3
46576: PPUSH
46577: CALL_OW 254
46581: STR
46582: PUSH
46583: LD_STRING , 
46585: STR
46586: PUSH
46587: LD_VAR 0 3
46591: PPUSH
46592: LD_INT 1
46594: PPUSH
46595: CALL_OW 268
46599: STR
46600: PUSH
46601: LD_STRING , 
46603: STR
46604: PUSH
46605: LD_VAR 0 3
46609: PPUSH
46610: LD_INT 2
46612: PPUSH
46613: CALL_OW 268
46617: STR
46618: PUSH
46619: LD_STRING ],
46621: STR
46622: PPUSH
46623: CALL_OW 561
// end ;
46627: GO 46521
46629: POP
46630: POP
// AddToLog ( ]; ) ;
46631: LD_STRING ];
46633: PPUSH
46634: CALL_OW 561
// end ;
46638: LD_VAR 0 2
46642: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46643: LD_INT 0
46645: PPUSH
46646: PPUSH
46647: PPUSH
46648: PPUSH
46649: PPUSH
// if not area or not rate or not max then
46650: LD_VAR 0 1
46654: NOT
46655: PUSH
46656: LD_VAR 0 2
46660: NOT
46661: OR
46662: PUSH
46663: LD_VAR 0 4
46667: NOT
46668: OR
46669: IFFALSE 46673
// exit ;
46671: GO 46862
// while 1 do
46673: LD_INT 1
46675: IFFALSE 46862
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 1
46686: PPUSH
46687: LD_INT 1
46689: PPUSH
46690: CALL_OW 287
46694: PUSH
46695: LD_INT 10
46697: MUL
46698: ST_TO_ADDR
// r := rate / 10 ;
46699: LD_ADDR_VAR 0 7
46703: PUSH
46704: LD_VAR 0 2
46708: PUSH
46709: LD_INT 10
46711: DIVREAL
46712: ST_TO_ADDR
// time := 1 1$00 ;
46713: LD_ADDR_VAR 0 8
46717: PUSH
46718: LD_INT 2100
46720: ST_TO_ADDR
// if amount < min then
46721: LD_VAR 0 9
46725: PUSH
46726: LD_VAR 0 3
46730: LESS
46731: IFFALSE 46749
// r := r * 2 else
46733: LD_ADDR_VAR 0 7
46737: PUSH
46738: LD_VAR 0 7
46742: PUSH
46743: LD_INT 2
46745: MUL
46746: ST_TO_ADDR
46747: GO 46775
// if amount > max then
46749: LD_VAR 0 9
46753: PUSH
46754: LD_VAR 0 4
46758: GREATER
46759: IFFALSE 46775
// r := r / 2 ;
46761: LD_ADDR_VAR 0 7
46765: PUSH
46766: LD_VAR 0 7
46770: PUSH
46771: LD_INT 2
46773: DIVREAL
46774: ST_TO_ADDR
// time := time / r ;
46775: LD_ADDR_VAR 0 8
46779: PUSH
46780: LD_VAR 0 8
46784: PUSH
46785: LD_VAR 0 7
46789: DIVREAL
46790: ST_TO_ADDR
// if time < 0 then
46791: LD_VAR 0 8
46795: PUSH
46796: LD_INT 0
46798: LESS
46799: IFFALSE 46816
// time := time * - 1 ;
46801: LD_ADDR_VAR 0 8
46805: PUSH
46806: LD_VAR 0 8
46810: PUSH
46811: LD_INT 1
46813: NEG
46814: MUL
46815: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46816: LD_VAR 0 8
46820: PUSH
46821: LD_INT 35
46823: PPUSH
46824: LD_INT 875
46826: PPUSH
46827: CALL_OW 12
46831: PLUS
46832: PPUSH
46833: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46837: LD_INT 1
46839: PPUSH
46840: LD_INT 5
46842: PPUSH
46843: CALL_OW 12
46847: PPUSH
46848: LD_VAR 0 1
46852: PPUSH
46853: LD_INT 1
46855: PPUSH
46856: CALL_OW 55
// end ;
46860: GO 46673
// end ;
46862: LD_VAR 0 5
46866: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46867: LD_INT 0
46869: PPUSH
46870: PPUSH
46871: PPUSH
46872: PPUSH
46873: PPUSH
46874: PPUSH
46875: PPUSH
46876: PPUSH
// if not turrets or not factories then
46877: LD_VAR 0 1
46881: NOT
46882: PUSH
46883: LD_VAR 0 2
46887: NOT
46888: OR
46889: IFFALSE 46893
// exit ;
46891: GO 47200
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46893: LD_ADDR_VAR 0 10
46897: PUSH
46898: LD_INT 5
46900: PUSH
46901: LD_INT 6
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: LD_INT 4
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: LD_INT 5
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 24
46935: PUSH
46936: LD_INT 25
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 23
46945: PUSH
46946: LD_INT 27
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 42
46959: PUSH
46960: LD_INT 43
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 44
46969: PUSH
46970: LD_INT 46
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PUSH
46977: LD_INT 45
46979: PUSH
46980: LD_INT 47
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: LIST
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: LIST
46996: ST_TO_ADDR
// result := [ ] ;
46997: LD_ADDR_VAR 0 3
47001: PUSH
47002: EMPTY
47003: ST_TO_ADDR
// for i in turrets do
47004: LD_ADDR_VAR 0 4
47008: PUSH
47009: LD_VAR 0 1
47013: PUSH
47014: FOR_IN
47015: IFFALSE 47198
// begin nat := GetNation ( i ) ;
47017: LD_ADDR_VAR 0 7
47021: PUSH
47022: LD_VAR 0 4
47026: PPUSH
47027: CALL_OW 248
47031: ST_TO_ADDR
// weapon := 0 ;
47032: LD_ADDR_VAR 0 8
47036: PUSH
47037: LD_INT 0
47039: ST_TO_ADDR
// if not nat then
47040: LD_VAR 0 7
47044: NOT
47045: IFFALSE 47049
// continue ;
47047: GO 47014
// for j in list [ nat ] do
47049: LD_ADDR_VAR 0 5
47053: PUSH
47054: LD_VAR 0 10
47058: PUSH
47059: LD_VAR 0 7
47063: ARRAY
47064: PUSH
47065: FOR_IN
47066: IFFALSE 47107
// if GetBWeapon ( i ) = j [ 1 ] then
47068: LD_VAR 0 4
47072: PPUSH
47073: CALL_OW 269
47077: PUSH
47078: LD_VAR 0 5
47082: PUSH
47083: LD_INT 1
47085: ARRAY
47086: EQUAL
47087: IFFALSE 47105
// begin weapon := j [ 2 ] ;
47089: LD_ADDR_VAR 0 8
47093: PUSH
47094: LD_VAR 0 5
47098: PUSH
47099: LD_INT 2
47101: ARRAY
47102: ST_TO_ADDR
// break ;
47103: GO 47107
// end ;
47105: GO 47065
47107: POP
47108: POP
// if not weapon then
47109: LD_VAR 0 8
47113: NOT
47114: IFFALSE 47118
// continue ;
47116: GO 47014
// for k in factories do
47118: LD_ADDR_VAR 0 6
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: FOR_IN
47129: IFFALSE 47194
// begin weapons := AvailableWeaponList ( k ) ;
47131: LD_ADDR_VAR 0 9
47135: PUSH
47136: LD_VAR 0 6
47140: PPUSH
47141: CALL_OW 478
47145: ST_TO_ADDR
// if not weapons then
47146: LD_VAR 0 9
47150: NOT
47151: IFFALSE 47155
// continue ;
47153: GO 47128
// if weapon in weapons then
47155: LD_VAR 0 8
47159: PUSH
47160: LD_VAR 0 9
47164: IN
47165: IFFALSE 47192
// begin result := [ i , weapon ] ;
47167: LD_ADDR_VAR 0 3
47171: PUSH
47172: LD_VAR 0 4
47176: PUSH
47177: LD_VAR 0 8
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: ST_TO_ADDR
// exit ;
47186: POP
47187: POP
47188: POP
47189: POP
47190: GO 47200
// end ; end ;
47192: GO 47128
47194: POP
47195: POP
// end ;
47196: GO 47014
47198: POP
47199: POP
// end ;
47200: LD_VAR 0 3
47204: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47205: LD_INT 0
47207: PPUSH
// if not side or side > 8 then
47208: LD_VAR 0 3
47212: NOT
47213: PUSH
47214: LD_VAR 0 3
47218: PUSH
47219: LD_INT 8
47221: GREATER
47222: OR
47223: IFFALSE 47227
// exit ;
47225: GO 47286
// if not range then
47227: LD_VAR 0 4
47231: NOT
47232: IFFALSE 47243
// range := - 12 ;
47234: LD_ADDR_VAR 0 4
47238: PUSH
47239: LD_INT 12
47241: NEG
47242: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47243: LD_VAR 0 1
47247: PPUSH
47248: LD_VAR 0 2
47252: PPUSH
47253: LD_VAR 0 3
47257: PPUSH
47258: LD_VAR 0 4
47262: PPUSH
47263: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47267: LD_VAR 0 1
47271: PPUSH
47272: LD_VAR 0 2
47276: PPUSH
47277: LD_VAR 0 3
47281: PPUSH
47282: CALL_OW 331
// end ;
47286: LD_VAR 0 5
47290: RET
// export function Video ( mode ) ; begin
47291: LD_INT 0
47293: PPUSH
// ingame_video = mode ;
47294: LD_ADDR_OWVAR 52
47298: PUSH
47299: LD_VAR 0 1
47303: ST_TO_ADDR
// interface_hidden = mode ;
47304: LD_ADDR_OWVAR 54
47308: PUSH
47309: LD_VAR 0 1
47313: ST_TO_ADDR
// end ;
47314: LD_VAR 0 2
47318: RET
// export function Join ( array , element ) ; begin
47319: LD_INT 0
47321: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47322: LD_ADDR_VAR 0 3
47326: PUSH
47327: LD_VAR 0 1
47331: PPUSH
47332: LD_VAR 0 1
47336: PUSH
47337: LD_INT 1
47339: PLUS
47340: PPUSH
47341: LD_VAR 0 2
47345: PPUSH
47346: CALL_OW 1
47350: ST_TO_ADDR
// end ;
47351: LD_VAR 0 3
47355: RET
// export function JoinUnion ( array , element ) ; begin
47356: LD_INT 0
47358: PPUSH
// result := array union element ;
47359: LD_ADDR_VAR 0 3
47363: PUSH
47364: LD_VAR 0 1
47368: PUSH
47369: LD_VAR 0 2
47373: UNION
47374: ST_TO_ADDR
// end ;
47375: LD_VAR 0 3
47379: RET
// export function GetBehemoths ( side ) ; begin
47380: LD_INT 0
47382: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47383: LD_ADDR_VAR 0 2
47387: PUSH
47388: LD_INT 22
47390: PUSH
47391: LD_VAR 0 1
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 31
47402: PUSH
47403: LD_INT 25
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PPUSH
47414: CALL_OW 69
47418: ST_TO_ADDR
// end ;
47419: LD_VAR 0 2
47423: RET
// export function Shuffle ( array ) ; var i , index ; begin
47424: LD_INT 0
47426: PPUSH
47427: PPUSH
47428: PPUSH
// result := [ ] ;
47429: LD_ADDR_VAR 0 2
47433: PUSH
47434: EMPTY
47435: ST_TO_ADDR
// if not array then
47436: LD_VAR 0 1
47440: NOT
47441: IFFALSE 47445
// exit ;
47443: GO 47544
// Randomize ;
47445: CALL_OW 10
// for i = array downto 1 do
47449: LD_ADDR_VAR 0 3
47453: PUSH
47454: DOUBLE
47455: LD_VAR 0 1
47459: INC
47460: ST_TO_ADDR
47461: LD_INT 1
47463: PUSH
47464: FOR_DOWNTO
47465: IFFALSE 47542
// begin index := rand ( 1 , array ) ;
47467: LD_ADDR_VAR 0 4
47471: PUSH
47472: LD_INT 1
47474: PPUSH
47475: LD_VAR 0 1
47479: PPUSH
47480: CALL_OW 12
47484: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47485: LD_ADDR_VAR 0 2
47489: PUSH
47490: LD_VAR 0 2
47494: PPUSH
47495: LD_VAR 0 2
47499: PUSH
47500: LD_INT 1
47502: PLUS
47503: PPUSH
47504: LD_VAR 0 1
47508: PUSH
47509: LD_VAR 0 4
47513: ARRAY
47514: PPUSH
47515: CALL_OW 2
47519: ST_TO_ADDR
// array := Delete ( array , index ) ;
47520: LD_ADDR_VAR 0 1
47524: PUSH
47525: LD_VAR 0 1
47529: PPUSH
47530: LD_VAR 0 4
47534: PPUSH
47535: CALL_OW 3
47539: ST_TO_ADDR
// end ;
47540: GO 47464
47542: POP
47543: POP
// end ;
47544: LD_VAR 0 2
47548: RET
// export function GetBaseMaterials ( base ) ; begin
47549: LD_INT 0
47551: PPUSH
// result := [ 0 , 0 , 0 ] ;
47552: LD_ADDR_VAR 0 2
47556: PUSH
47557: LD_INT 0
47559: PUSH
47560: LD_INT 0
47562: PUSH
47563: LD_INT 0
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: LIST
47570: ST_TO_ADDR
// if not base then
47571: LD_VAR 0 1
47575: NOT
47576: IFFALSE 47580
// exit ;
47578: GO 47629
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47580: LD_ADDR_VAR 0 2
47584: PUSH
47585: LD_VAR 0 1
47589: PPUSH
47590: LD_INT 1
47592: PPUSH
47593: CALL_OW 275
47597: PUSH
47598: LD_VAR 0 1
47602: PPUSH
47603: LD_INT 2
47605: PPUSH
47606: CALL_OW 275
47610: PUSH
47611: LD_VAR 0 1
47615: PPUSH
47616: LD_INT 3
47618: PPUSH
47619: CALL_OW 275
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: LIST
47628: ST_TO_ADDR
// end ;
47629: LD_VAR 0 2
47633: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47634: LD_INT 0
47636: PPUSH
47637: PPUSH
// result := array ;
47638: LD_ADDR_VAR 0 3
47642: PUSH
47643: LD_VAR 0 1
47647: ST_TO_ADDR
// if size >= result then
47648: LD_VAR 0 2
47652: PUSH
47653: LD_VAR 0 3
47657: GREATEREQUAL
47658: IFFALSE 47662
// exit ;
47660: GO 47712
// if size then
47662: LD_VAR 0 2
47666: IFFALSE 47712
// for i := array downto size do
47668: LD_ADDR_VAR 0 4
47672: PUSH
47673: DOUBLE
47674: LD_VAR 0 1
47678: INC
47679: ST_TO_ADDR
47680: LD_VAR 0 2
47684: PUSH
47685: FOR_DOWNTO
47686: IFFALSE 47710
// result := Delete ( result , result ) ;
47688: LD_ADDR_VAR 0 3
47692: PUSH
47693: LD_VAR 0 3
47697: PPUSH
47698: LD_VAR 0 3
47702: PPUSH
47703: CALL_OW 3
47707: ST_TO_ADDR
47708: GO 47685
47710: POP
47711: POP
// end ;
47712: LD_VAR 0 3
47716: RET
// export function ComExit ( unit ) ; var tmp ; begin
47717: LD_INT 0
47719: PPUSH
47720: PPUSH
// if not IsInUnit ( unit ) then
47721: LD_VAR 0 1
47725: PPUSH
47726: CALL_OW 310
47730: NOT
47731: IFFALSE 47735
// exit ;
47733: GO 47795
// tmp := IsInUnit ( unit ) ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_VAR 0 1
47744: PPUSH
47745: CALL_OW 310
47749: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47750: LD_VAR 0 3
47754: PPUSH
47755: CALL_OW 247
47759: PUSH
47760: LD_INT 2
47762: EQUAL
47763: IFFALSE 47776
// ComExitVehicle ( unit ) else
47765: LD_VAR 0 1
47769: PPUSH
47770: CALL_OW 121
47774: GO 47785
// ComExitBuilding ( unit ) ;
47776: LD_VAR 0 1
47780: PPUSH
47781: CALL_OW 122
// result := tmp ;
47785: LD_ADDR_VAR 0 2
47789: PUSH
47790: LD_VAR 0 3
47794: ST_TO_ADDR
// end ;
47795: LD_VAR 0 2
47799: RET
// export function ComExitAll ( units ) ; var i ; begin
47800: LD_INT 0
47802: PPUSH
47803: PPUSH
// if not units then
47804: LD_VAR 0 1
47808: NOT
47809: IFFALSE 47813
// exit ;
47811: GO 47839
// for i in units do
47813: LD_ADDR_VAR 0 3
47817: PUSH
47818: LD_VAR 0 1
47822: PUSH
47823: FOR_IN
47824: IFFALSE 47837
// ComExit ( i ) ;
47826: LD_VAR 0 3
47830: PPUSH
47831: CALL 47717 0 1
47835: GO 47823
47837: POP
47838: POP
// end ;
47839: LD_VAR 0 2
47843: RET
// export function ResetHc ; begin
47844: LD_INT 0
47846: PPUSH
// InitHc ;
47847: CALL_OW 19
// hc_importance := 0 ;
47851: LD_ADDR_OWVAR 32
47855: PUSH
47856: LD_INT 0
47858: ST_TO_ADDR
// end ;
47859: LD_VAR 0 1
47863: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47864: LD_INT 0
47866: PPUSH
47867: PPUSH
47868: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47869: LD_ADDR_VAR 0 6
47873: PUSH
47874: LD_VAR 0 1
47878: PUSH
47879: LD_VAR 0 3
47883: PLUS
47884: PUSH
47885: LD_INT 2
47887: DIV
47888: ST_TO_ADDR
// if _x < 0 then
47889: LD_VAR 0 6
47893: PUSH
47894: LD_INT 0
47896: LESS
47897: IFFALSE 47914
// _x := _x * - 1 ;
47899: LD_ADDR_VAR 0 6
47903: PUSH
47904: LD_VAR 0 6
47908: PUSH
47909: LD_INT 1
47911: NEG
47912: MUL
47913: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47914: LD_ADDR_VAR 0 7
47918: PUSH
47919: LD_VAR 0 2
47923: PUSH
47924: LD_VAR 0 4
47928: PLUS
47929: PUSH
47930: LD_INT 2
47932: DIV
47933: ST_TO_ADDR
// if _y < 0 then
47934: LD_VAR 0 7
47938: PUSH
47939: LD_INT 0
47941: LESS
47942: IFFALSE 47959
// _y := _y * - 1 ;
47944: LD_ADDR_VAR 0 7
47948: PUSH
47949: LD_VAR 0 7
47953: PUSH
47954: LD_INT 1
47956: NEG
47957: MUL
47958: ST_TO_ADDR
// result := [ _x , _y ] ;
47959: LD_ADDR_VAR 0 5
47963: PUSH
47964: LD_VAR 0 6
47968: PUSH
47969: LD_VAR 0 7
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: ST_TO_ADDR
// end ;
47978: LD_VAR 0 5
47982: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47983: LD_INT 0
47985: PPUSH
47986: PPUSH
47987: PPUSH
47988: PPUSH
// task := GetTaskList ( unit ) ;
47989: LD_ADDR_VAR 0 7
47993: PUSH
47994: LD_VAR 0 1
47998: PPUSH
47999: CALL_OW 437
48003: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48004: LD_VAR 0 7
48008: NOT
48009: PUSH
48010: LD_VAR 0 1
48014: PPUSH
48015: LD_VAR 0 2
48019: PPUSH
48020: CALL_OW 308
48024: NOT
48025: AND
48026: IFFALSE 48030
// exit ;
48028: GO 48148
// if IsInArea ( unit , area ) then
48030: LD_VAR 0 1
48034: PPUSH
48035: LD_VAR 0 2
48039: PPUSH
48040: CALL_OW 308
48044: IFFALSE 48062
// begin ComMoveToArea ( unit , goAway ) ;
48046: LD_VAR 0 1
48050: PPUSH
48051: LD_VAR 0 3
48055: PPUSH
48056: CALL_OW 113
// exit ;
48060: GO 48148
// end ; if task [ 1 ] [ 1 ] <> M then
48062: LD_VAR 0 7
48066: PUSH
48067: LD_INT 1
48069: ARRAY
48070: PUSH
48071: LD_INT 1
48073: ARRAY
48074: PUSH
48075: LD_STRING M
48077: NONEQUAL
48078: IFFALSE 48082
// exit ;
48080: GO 48148
// x := task [ 1 ] [ 2 ] ;
48082: LD_ADDR_VAR 0 5
48086: PUSH
48087: LD_VAR 0 7
48091: PUSH
48092: LD_INT 1
48094: ARRAY
48095: PUSH
48096: LD_INT 2
48098: ARRAY
48099: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48100: LD_ADDR_VAR 0 6
48104: PUSH
48105: LD_VAR 0 7
48109: PUSH
48110: LD_INT 1
48112: ARRAY
48113: PUSH
48114: LD_INT 3
48116: ARRAY
48117: ST_TO_ADDR
// if InArea ( x , y , area ) then
48118: LD_VAR 0 5
48122: PPUSH
48123: LD_VAR 0 6
48127: PPUSH
48128: LD_VAR 0 2
48132: PPUSH
48133: CALL_OW 309
48137: IFFALSE 48148
// ComStop ( unit ) ;
48139: LD_VAR 0 1
48143: PPUSH
48144: CALL_OW 141
// end ;
48148: LD_VAR 0 4
48152: RET
// export function Abs ( value ) ; begin
48153: LD_INT 0
48155: PPUSH
// result := value ;
48156: LD_ADDR_VAR 0 2
48160: PUSH
48161: LD_VAR 0 1
48165: ST_TO_ADDR
// if value < 0 then
48166: LD_VAR 0 1
48170: PUSH
48171: LD_INT 0
48173: LESS
48174: IFFALSE 48191
// result := value * - 1 ;
48176: LD_ADDR_VAR 0 2
48180: PUSH
48181: LD_VAR 0 1
48185: PUSH
48186: LD_INT 1
48188: NEG
48189: MUL
48190: ST_TO_ADDR
// end ;
48191: LD_VAR 0 2
48195: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48196: LD_INT 0
48198: PPUSH
48199: PPUSH
48200: PPUSH
48201: PPUSH
48202: PPUSH
48203: PPUSH
48204: PPUSH
48205: PPUSH
// if not unit or not building then
48206: LD_VAR 0 1
48210: NOT
48211: PUSH
48212: LD_VAR 0 2
48216: NOT
48217: OR
48218: IFFALSE 48222
// exit ;
48220: GO 48448
// x := GetX ( building ) ;
48222: LD_ADDR_VAR 0 4
48226: PUSH
48227: LD_VAR 0 2
48231: PPUSH
48232: CALL_OW 250
48236: ST_TO_ADDR
// y := GetY ( building ) ;
48237: LD_ADDR_VAR 0 6
48241: PUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: CALL_OW 251
48251: ST_TO_ADDR
// d := GetDir ( building ) ;
48252: LD_ADDR_VAR 0 8
48256: PUSH
48257: LD_VAR 0 2
48261: PPUSH
48262: CALL_OW 254
48266: ST_TO_ADDR
// r := 4 ;
48267: LD_ADDR_VAR 0 9
48271: PUSH
48272: LD_INT 4
48274: ST_TO_ADDR
// for i := 1 to 5 do
48275: LD_ADDR_VAR 0 10
48279: PUSH
48280: DOUBLE
48281: LD_INT 1
48283: DEC
48284: ST_TO_ADDR
48285: LD_INT 5
48287: PUSH
48288: FOR_TO
48289: IFFALSE 48446
// begin _x := ShiftX ( x , d , r + i ) ;
48291: LD_ADDR_VAR 0 5
48295: PUSH
48296: LD_VAR 0 4
48300: PPUSH
48301: LD_VAR 0 8
48305: PPUSH
48306: LD_VAR 0 9
48310: PUSH
48311: LD_VAR 0 10
48315: PLUS
48316: PPUSH
48317: CALL_OW 272
48321: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48322: LD_ADDR_VAR 0 7
48326: PUSH
48327: LD_VAR 0 6
48331: PPUSH
48332: LD_VAR 0 8
48336: PPUSH
48337: LD_VAR 0 9
48341: PUSH
48342: LD_VAR 0 10
48346: PLUS
48347: PPUSH
48348: CALL_OW 273
48352: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48353: LD_VAR 0 5
48357: PPUSH
48358: LD_VAR 0 7
48362: PPUSH
48363: CALL_OW 488
48367: PUSH
48368: LD_VAR 0 5
48372: PPUSH
48373: LD_VAR 0 7
48377: PPUSH
48378: CALL_OW 428
48382: PPUSH
48383: CALL_OW 247
48387: PUSH
48388: LD_INT 3
48390: PUSH
48391: LD_INT 2
48393: PUSH
48394: EMPTY
48395: LIST
48396: LIST
48397: IN
48398: NOT
48399: AND
48400: IFFALSE 48444
// begin ComMoveXY ( unit , _x , _y ) ;
48402: LD_VAR 0 1
48406: PPUSH
48407: LD_VAR 0 5
48411: PPUSH
48412: LD_VAR 0 7
48416: PPUSH
48417: CALL_OW 111
// result := [ _x , _y ] ;
48421: LD_ADDR_VAR 0 3
48425: PUSH
48426: LD_VAR 0 5
48430: PUSH
48431: LD_VAR 0 7
48435: PUSH
48436: EMPTY
48437: LIST
48438: LIST
48439: ST_TO_ADDR
// exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 48288
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 3
48452: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
// result := 0 ;
48458: LD_ADDR_VAR 0 3
48462: PUSH
48463: LD_INT 0
48465: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48466: LD_VAR 0 1
48470: PUSH
48471: LD_INT 0
48473: LESS
48474: PUSH
48475: LD_VAR 0 1
48479: PUSH
48480: LD_INT 8
48482: GREATER
48483: OR
48484: PUSH
48485: LD_VAR 0 2
48489: PUSH
48490: LD_INT 0
48492: LESS
48493: OR
48494: PUSH
48495: LD_VAR 0 2
48499: PUSH
48500: LD_INT 8
48502: GREATER
48503: OR
48504: IFFALSE 48508
// exit ;
48506: GO 48583
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48508: LD_ADDR_VAR 0 4
48512: PUSH
48513: LD_INT 22
48515: PUSH
48516: LD_VAR 0 2
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: PPUSH
48525: CALL_OW 69
48529: PUSH
48530: FOR_IN
48531: IFFALSE 48581
// begin un := UnitShoot ( i ) ;
48533: LD_ADDR_VAR 0 5
48537: PUSH
48538: LD_VAR 0 4
48542: PPUSH
48543: CALL_OW 504
48547: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48548: LD_VAR 0 5
48552: PPUSH
48553: CALL_OW 255
48557: PUSH
48558: LD_VAR 0 1
48562: EQUAL
48563: IFFALSE 48579
// begin result := un ;
48565: LD_ADDR_VAR 0 3
48569: PUSH
48570: LD_VAR 0 5
48574: ST_TO_ADDR
// exit ;
48575: POP
48576: POP
48577: GO 48583
// end ; end ;
48579: GO 48530
48581: POP
48582: POP
// end ;
48583: LD_VAR 0 3
48587: RET
// export function GetCargoBay ( units ) ; begin
48588: LD_INT 0
48590: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48591: LD_ADDR_VAR 0 2
48595: PUSH
48596: LD_VAR 0 1
48600: PPUSH
48601: LD_INT 2
48603: PUSH
48604: LD_INT 34
48606: PUSH
48607: LD_INT 12
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: LD_INT 34
48616: PUSH
48617: LD_INT 51
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 34
48626: PUSH
48627: LD_INT 32
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: LD_INT 34
48636: PUSH
48637: LD_INT 89
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: PPUSH
48651: CALL_OW 72
48655: ST_TO_ADDR
// end ;
48656: LD_VAR 0 2
48660: RET
// export function Negate ( value ) ; begin
48661: LD_INT 0
48663: PPUSH
// result := not value ;
48664: LD_ADDR_VAR 0 2
48668: PUSH
48669: LD_VAR 0 1
48673: NOT
48674: ST_TO_ADDR
// end ;
48675: LD_VAR 0 2
48679: RET
// export function Inc ( value ) ; begin
48680: LD_INT 0
48682: PPUSH
// result := value + 1 ;
48683: LD_ADDR_VAR 0 2
48687: PUSH
48688: LD_VAR 0 1
48692: PUSH
48693: LD_INT 1
48695: PLUS
48696: ST_TO_ADDR
// end ;
48697: LD_VAR 0 2
48701: RET
// export function Dec ( value ) ; begin
48702: LD_INT 0
48704: PPUSH
// result := value - 1 ;
48705: LD_ADDR_VAR 0 2
48709: PUSH
48710: LD_VAR 0 1
48714: PUSH
48715: LD_INT 1
48717: MINUS
48718: ST_TO_ADDR
// end ;
48719: LD_VAR 0 2
48723: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48724: LD_INT 0
48726: PPUSH
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48734: LD_VAR 0 1
48738: PPUSH
48739: LD_VAR 0 2
48743: PPUSH
48744: CALL_OW 488
48748: NOT
48749: PUSH
48750: LD_VAR 0 3
48754: PPUSH
48755: LD_VAR 0 4
48759: PPUSH
48760: CALL_OW 488
48764: NOT
48765: OR
48766: IFFALSE 48779
// begin result := - 1 ;
48768: LD_ADDR_VAR 0 5
48772: PUSH
48773: LD_INT 1
48775: NEG
48776: ST_TO_ADDR
// exit ;
48777: GO 49014
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48779: LD_ADDR_VAR 0 12
48783: PUSH
48784: LD_VAR 0 1
48788: PPUSH
48789: LD_VAR 0 2
48793: PPUSH
48794: LD_VAR 0 3
48798: PPUSH
48799: LD_VAR 0 4
48803: PPUSH
48804: CALL 47864 0 4
48808: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48809: LD_ADDR_VAR 0 11
48813: PUSH
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 2
48823: PPUSH
48824: LD_VAR 0 12
48828: PUSH
48829: LD_INT 1
48831: ARRAY
48832: PPUSH
48833: LD_VAR 0 12
48837: PUSH
48838: LD_INT 2
48840: ARRAY
48841: PPUSH
48842: CALL_OW 298
48846: ST_TO_ADDR
// distance := 9999 ;
48847: LD_ADDR_VAR 0 10
48851: PUSH
48852: LD_INT 9999
48854: ST_TO_ADDR
// for i := 0 to 5 do
48855: LD_ADDR_VAR 0 6
48859: PUSH
48860: DOUBLE
48861: LD_INT 0
48863: DEC
48864: ST_TO_ADDR
48865: LD_INT 5
48867: PUSH
48868: FOR_TO
48869: IFFALSE 49012
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48871: LD_ADDR_VAR 0 7
48875: PUSH
48876: LD_VAR 0 1
48880: PPUSH
48881: LD_VAR 0 6
48885: PPUSH
48886: LD_VAR 0 11
48890: PPUSH
48891: CALL_OW 272
48895: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48896: LD_ADDR_VAR 0 8
48900: PUSH
48901: LD_VAR 0 2
48905: PPUSH
48906: LD_VAR 0 6
48910: PPUSH
48911: LD_VAR 0 11
48915: PPUSH
48916: CALL_OW 273
48920: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48921: LD_VAR 0 7
48925: PPUSH
48926: LD_VAR 0 8
48930: PPUSH
48931: CALL_OW 488
48935: NOT
48936: IFFALSE 48940
// continue ;
48938: GO 48868
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48940: LD_ADDR_VAR 0 9
48944: PUSH
48945: LD_VAR 0 12
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PPUSH
48954: LD_VAR 0 12
48958: PUSH
48959: LD_INT 2
48961: ARRAY
48962: PPUSH
48963: LD_VAR 0 7
48967: PPUSH
48968: LD_VAR 0 8
48972: PPUSH
48973: CALL_OW 298
48977: ST_TO_ADDR
// if tmp < distance then
48978: LD_VAR 0 9
48982: PUSH
48983: LD_VAR 0 10
48987: LESS
48988: IFFALSE 49010
// begin result := i ;
48990: LD_ADDR_VAR 0 5
48994: PUSH
48995: LD_VAR 0 6
48999: ST_TO_ADDR
// distance := tmp ;
49000: LD_ADDR_VAR 0 10
49004: PUSH
49005: LD_VAR 0 9
49009: ST_TO_ADDR
// end ; end ;
49010: GO 48868
49012: POP
49013: POP
// end ;
49014: LD_VAR 0 5
49018: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49019: LD_INT 0
49021: PPUSH
49022: PPUSH
// if not driver or not IsInUnit ( driver ) then
49023: LD_VAR 0 1
49027: NOT
49028: PUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 310
49038: NOT
49039: OR
49040: IFFALSE 49044
// exit ;
49042: GO 49134
// vehicle := IsInUnit ( driver ) ;
49044: LD_ADDR_VAR 0 3
49048: PUSH
49049: LD_VAR 0 1
49053: PPUSH
49054: CALL_OW 310
49058: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49059: LD_VAR 0 1
49063: PPUSH
49064: LD_STRING \
49066: PUSH
49067: LD_INT 0
49069: PUSH
49070: LD_INT 0
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 0
49078: PUSH
49079: LD_INT 0
49081: PUSH
49082: LD_INT 0
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: PUSH
49094: LD_STRING E
49096: PUSH
49097: LD_INT 0
49099: PUSH
49100: LD_INT 0
49102: PUSH
49103: LD_VAR 0 3
49107: PUSH
49108: LD_INT 0
49110: PUSH
49111: LD_INT 0
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PPUSH
49130: CALL_OW 446
// end ;
49134: LD_VAR 0 2
49138: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49139: LD_INT 0
49141: PPUSH
49142: PPUSH
// if not driver or not IsInUnit ( driver ) then
49143: LD_VAR 0 1
49147: NOT
49148: PUSH
49149: LD_VAR 0 1
49153: PPUSH
49154: CALL_OW 310
49158: NOT
49159: OR
49160: IFFALSE 49164
// exit ;
49162: GO 49254
// vehicle := IsInUnit ( driver ) ;
49164: LD_ADDR_VAR 0 3
49168: PUSH
49169: LD_VAR 0 1
49173: PPUSH
49174: CALL_OW 310
49178: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49179: LD_VAR 0 1
49183: PPUSH
49184: LD_STRING \
49186: PUSH
49187: LD_INT 0
49189: PUSH
49190: LD_INT 0
49192: PUSH
49193: LD_INT 0
49195: PUSH
49196: LD_INT 0
49198: PUSH
49199: LD_INT 0
49201: PUSH
49202: LD_INT 0
49204: PUSH
49205: EMPTY
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: PUSH
49214: LD_STRING E
49216: PUSH
49217: LD_INT 0
49219: PUSH
49220: LD_INT 0
49222: PUSH
49223: LD_VAR 0 3
49227: PUSH
49228: LD_INT 0
49230: PUSH
49231: LD_INT 0
49233: PUSH
49234: LD_INT 0
49236: PUSH
49237: EMPTY
49238: LIST
49239: LIST
49240: LIST
49241: LIST
49242: LIST
49243: LIST
49244: LIST
49245: PUSH
49246: EMPTY
49247: LIST
49248: LIST
49249: PPUSH
49250: CALL_OW 447
// end ;
49254: LD_VAR 0 2
49258: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49259: LD_INT 0
49261: PPUSH
49262: PPUSH
49263: PPUSH
// tmp := [ ] ;
49264: LD_ADDR_VAR 0 5
49268: PUSH
49269: EMPTY
49270: ST_TO_ADDR
// for i in units do
49271: LD_ADDR_VAR 0 4
49275: PUSH
49276: LD_VAR 0 1
49280: PUSH
49281: FOR_IN
49282: IFFALSE 49320
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49284: LD_ADDR_VAR 0 5
49288: PUSH
49289: LD_VAR 0 5
49293: PPUSH
49294: LD_VAR 0 5
49298: PUSH
49299: LD_INT 1
49301: PLUS
49302: PPUSH
49303: LD_VAR 0 4
49307: PPUSH
49308: CALL_OW 256
49312: PPUSH
49313: CALL_OW 2
49317: ST_TO_ADDR
49318: GO 49281
49320: POP
49321: POP
// if not tmp then
49322: LD_VAR 0 5
49326: NOT
49327: IFFALSE 49331
// exit ;
49329: GO 49379
// if asc then
49331: LD_VAR 0 2
49335: IFFALSE 49359
// result := SortListByListAsc ( units , tmp ) else
49337: LD_ADDR_VAR 0 3
49341: PUSH
49342: LD_VAR 0 1
49346: PPUSH
49347: LD_VAR 0 5
49351: PPUSH
49352: CALL_OW 76
49356: ST_TO_ADDR
49357: GO 49379
// result := SortListByListDesc ( units , tmp ) ;
49359: LD_ADDR_VAR 0 3
49363: PUSH
49364: LD_VAR 0 1
49368: PPUSH
49369: LD_VAR 0 5
49373: PPUSH
49374: CALL_OW 77
49378: ST_TO_ADDR
// end ;
49379: LD_VAR 0 3
49383: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49384: LD_INT 0
49386: PPUSH
49387: PPUSH
// task := GetTaskList ( mech ) ;
49388: LD_ADDR_VAR 0 4
49392: PUSH
49393: LD_VAR 0 1
49397: PPUSH
49398: CALL_OW 437
49402: ST_TO_ADDR
// if not task then
49403: LD_VAR 0 4
49407: NOT
49408: IFFALSE 49412
// exit ;
49410: GO 49454
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49412: LD_ADDR_VAR 0 3
49416: PUSH
49417: LD_VAR 0 4
49421: PUSH
49422: LD_INT 1
49424: ARRAY
49425: PUSH
49426: LD_INT 1
49428: ARRAY
49429: PUSH
49430: LD_STRING r
49432: EQUAL
49433: PUSH
49434: LD_VAR 0 4
49438: PUSH
49439: LD_INT 1
49441: ARRAY
49442: PUSH
49443: LD_INT 4
49445: ARRAY
49446: PUSH
49447: LD_VAR 0 2
49451: EQUAL
49452: AND
49453: ST_TO_ADDR
// end ;
49454: LD_VAR 0 3
49458: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49459: LD_INT 0
49461: PPUSH
// SetDir ( unit , d ) ;
49462: LD_VAR 0 1
49466: PPUSH
49467: LD_VAR 0 4
49471: PPUSH
49472: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49476: LD_VAR 0 1
49480: PPUSH
49481: LD_VAR 0 2
49485: PPUSH
49486: LD_VAR 0 3
49490: PPUSH
49491: LD_VAR 0 5
49495: PPUSH
49496: CALL_OW 48
// end ;
49500: LD_VAR 0 6
49504: RET
// export function ToNaturalNumber ( number ) ; begin
49505: LD_INT 0
49507: PPUSH
// result := number div 1 ;
49508: LD_ADDR_VAR 0 2
49512: PUSH
49513: LD_VAR 0 1
49517: PUSH
49518: LD_INT 1
49520: DIV
49521: ST_TO_ADDR
// if number < 0 then
49522: LD_VAR 0 1
49526: PUSH
49527: LD_INT 0
49529: LESS
49530: IFFALSE 49540
// result := 0 ;
49532: LD_ADDR_VAR 0 2
49536: PUSH
49537: LD_INT 0
49539: ST_TO_ADDR
// end ;
49540: LD_VAR 0 2
49544: RET
// export function SortByClass ( units , class ) ; var un ; begin
49545: LD_INT 0
49547: PPUSH
49548: PPUSH
// if not units or not class then
49549: LD_VAR 0 1
49553: NOT
49554: PUSH
49555: LD_VAR 0 2
49559: NOT
49560: OR
49561: IFFALSE 49565
// exit ;
49563: GO 49660
// result := [ ] ;
49565: LD_ADDR_VAR 0 3
49569: PUSH
49570: EMPTY
49571: ST_TO_ADDR
// for un in units do
49572: LD_ADDR_VAR 0 4
49576: PUSH
49577: LD_VAR 0 1
49581: PUSH
49582: FOR_IN
49583: IFFALSE 49658
// if GetClass ( un ) = class then
49585: LD_VAR 0 4
49589: PPUSH
49590: CALL_OW 257
49594: PUSH
49595: LD_VAR 0 2
49599: EQUAL
49600: IFFALSE 49627
// result := Insert ( result , 1 , un ) else
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: LD_VAR 0 3
49611: PPUSH
49612: LD_INT 1
49614: PPUSH
49615: LD_VAR 0 4
49619: PPUSH
49620: CALL_OW 2
49624: ST_TO_ADDR
49625: GO 49656
// result := Replace ( result , result + 1 , un ) ;
49627: LD_ADDR_VAR 0 3
49631: PUSH
49632: LD_VAR 0 3
49636: PPUSH
49637: LD_VAR 0 3
49641: PUSH
49642: LD_INT 1
49644: PLUS
49645: PPUSH
49646: LD_VAR 0 4
49650: PPUSH
49651: CALL_OW 1
49655: ST_TO_ADDR
49656: GO 49582
49658: POP
49659: POP
// end ;
49660: LD_VAR 0 3
49664: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49665: LD_INT 0
49667: PPUSH
49668: PPUSH
49669: PPUSH
49670: PPUSH
49671: PPUSH
49672: PPUSH
49673: PPUSH
// result := [ ] ;
49674: LD_ADDR_VAR 0 4
49678: PUSH
49679: EMPTY
49680: ST_TO_ADDR
// if x - r < 0 then
49681: LD_VAR 0 1
49685: PUSH
49686: LD_VAR 0 3
49690: MINUS
49691: PUSH
49692: LD_INT 0
49694: LESS
49695: IFFALSE 49707
// min_x := 0 else
49697: LD_ADDR_VAR 0 8
49701: PUSH
49702: LD_INT 0
49704: ST_TO_ADDR
49705: GO 49723
// min_x := x - r ;
49707: LD_ADDR_VAR 0 8
49711: PUSH
49712: LD_VAR 0 1
49716: PUSH
49717: LD_VAR 0 3
49721: MINUS
49722: ST_TO_ADDR
// if y - r < 0 then
49723: LD_VAR 0 2
49727: PUSH
49728: LD_VAR 0 3
49732: MINUS
49733: PUSH
49734: LD_INT 0
49736: LESS
49737: IFFALSE 49749
// min_y := 0 else
49739: LD_ADDR_VAR 0 7
49743: PUSH
49744: LD_INT 0
49746: ST_TO_ADDR
49747: GO 49765
// min_y := y - r ;
49749: LD_ADDR_VAR 0 7
49753: PUSH
49754: LD_VAR 0 2
49758: PUSH
49759: LD_VAR 0 3
49763: MINUS
49764: ST_TO_ADDR
// max_x := x + r ;
49765: LD_ADDR_VAR 0 9
49769: PUSH
49770: LD_VAR 0 1
49774: PUSH
49775: LD_VAR 0 3
49779: PLUS
49780: ST_TO_ADDR
// max_y := y + r ;
49781: LD_ADDR_VAR 0 10
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: LD_VAR 0 3
49795: PLUS
49796: ST_TO_ADDR
// for _x = min_x to max_x do
49797: LD_ADDR_VAR 0 5
49801: PUSH
49802: DOUBLE
49803: LD_VAR 0 8
49807: DEC
49808: ST_TO_ADDR
49809: LD_VAR 0 9
49813: PUSH
49814: FOR_TO
49815: IFFALSE 49916
// for _y = min_y to max_y do
49817: LD_ADDR_VAR 0 6
49821: PUSH
49822: DOUBLE
49823: LD_VAR 0 7
49827: DEC
49828: ST_TO_ADDR
49829: LD_VAR 0 10
49833: PUSH
49834: FOR_TO
49835: IFFALSE 49912
// begin if not ValidHex ( _x , _y ) then
49837: LD_VAR 0 5
49841: PPUSH
49842: LD_VAR 0 6
49846: PPUSH
49847: CALL_OW 488
49851: NOT
49852: IFFALSE 49856
// continue ;
49854: GO 49834
// if GetResourceTypeXY ( _x , _y ) then
49856: LD_VAR 0 5
49860: PPUSH
49861: LD_VAR 0 6
49865: PPUSH
49866: CALL_OW 283
49870: IFFALSE 49910
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49872: LD_ADDR_VAR 0 4
49876: PUSH
49877: LD_VAR 0 4
49881: PPUSH
49882: LD_VAR 0 4
49886: PUSH
49887: LD_INT 1
49889: PLUS
49890: PPUSH
49891: LD_VAR 0 5
49895: PUSH
49896: LD_VAR 0 6
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PPUSH
49905: CALL_OW 1
49909: ST_TO_ADDR
// end ;
49910: GO 49834
49912: POP
49913: POP
49914: GO 49814
49916: POP
49917: POP
// end ;
49918: LD_VAR 0 4
49922: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49923: LD_INT 0
49925: PPUSH
49926: PPUSH
49927: PPUSH
49928: PPUSH
49929: PPUSH
49930: PPUSH
49931: PPUSH
49932: PPUSH
// if not units then
49933: LD_VAR 0 1
49937: NOT
49938: IFFALSE 49942
// exit ;
49940: GO 50466
// result := UnitFilter ( units , [ f_ok ] ) ;
49942: LD_ADDR_VAR 0 3
49946: PUSH
49947: LD_VAR 0 1
49951: PPUSH
49952: LD_INT 50
49954: PUSH
49955: EMPTY
49956: LIST
49957: PPUSH
49958: CALL_OW 72
49962: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49963: LD_ADDR_VAR 0 8
49967: PUSH
49968: LD_VAR 0 1
49972: PUSH
49973: LD_INT 1
49975: ARRAY
49976: PPUSH
49977: CALL_OW 255
49981: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49982: LD_ADDR_VAR 0 10
49986: PUSH
49987: LD_INT 29
49989: PUSH
49990: LD_INT 91
49992: PUSH
49993: LD_INT 49
49995: PUSH
49996: EMPTY
49997: LIST
49998: LIST
49999: LIST
50000: ST_TO_ADDR
// if not result then
50001: LD_VAR 0 3
50005: NOT
50006: IFFALSE 50010
// exit ;
50008: GO 50466
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50010: LD_ADDR_VAR 0 5
50014: PUSH
50015: LD_INT 81
50017: PUSH
50018: LD_VAR 0 8
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PPUSH
50027: CALL_OW 69
50031: ST_TO_ADDR
// for i in result do
50032: LD_ADDR_VAR 0 4
50036: PUSH
50037: LD_VAR 0 3
50041: PUSH
50042: FOR_IN
50043: IFFALSE 50464
// begin tag := GetTag ( i ) + 1 ;
50045: LD_ADDR_VAR 0 9
50049: PUSH
50050: LD_VAR 0 4
50054: PPUSH
50055: CALL_OW 110
50059: PUSH
50060: LD_INT 1
50062: PLUS
50063: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50064: LD_ADDR_VAR 0 7
50068: PUSH
50069: LD_VAR 0 4
50073: PPUSH
50074: CALL_OW 250
50078: PPUSH
50079: LD_VAR 0 4
50083: PPUSH
50084: CALL_OW 251
50088: PPUSH
50089: LD_INT 6
50091: PPUSH
50092: CALL 49665 0 3
50096: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50097: LD_VAR 0 4
50101: PPUSH
50102: CALL_OW 247
50106: PUSH
50107: LD_INT 2
50109: EQUAL
50110: PUSH
50111: LD_VAR 0 7
50115: AND
50116: PUSH
50117: LD_VAR 0 4
50121: PPUSH
50122: CALL_OW 264
50126: PUSH
50127: LD_VAR 0 10
50131: IN
50132: NOT
50133: AND
50134: IFFALSE 50173
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50136: LD_VAR 0 4
50140: PPUSH
50141: LD_VAR 0 7
50145: PUSH
50146: LD_INT 1
50148: ARRAY
50149: PUSH
50150: LD_INT 1
50152: ARRAY
50153: PPUSH
50154: LD_VAR 0 7
50158: PUSH
50159: LD_INT 1
50161: ARRAY
50162: PUSH
50163: LD_INT 2
50165: ARRAY
50166: PPUSH
50167: CALL_OW 116
50171: GO 50462
// if path > tag then
50173: LD_VAR 0 2
50177: PUSH
50178: LD_VAR 0 9
50182: GREATER
50183: IFFALSE 50391
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50185: LD_ADDR_VAR 0 6
50189: PUSH
50190: LD_VAR 0 5
50194: PPUSH
50195: LD_INT 91
50197: PUSH
50198: LD_VAR 0 4
50202: PUSH
50203: LD_INT 8
50205: PUSH
50206: EMPTY
50207: LIST
50208: LIST
50209: LIST
50210: PPUSH
50211: CALL_OW 72
50215: ST_TO_ADDR
// if nearEnemy then
50216: LD_VAR 0 6
50220: IFFALSE 50289
// begin if GetWeapon ( i ) = ru_time_lapser then
50222: LD_VAR 0 4
50226: PPUSH
50227: CALL_OW 264
50231: PUSH
50232: LD_INT 49
50234: EQUAL
50235: IFFALSE 50263
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50237: LD_VAR 0 4
50241: PPUSH
50242: LD_VAR 0 6
50246: PPUSH
50247: LD_VAR 0 4
50251: PPUSH
50252: CALL_OW 74
50256: PPUSH
50257: CALL_OW 112
50261: GO 50287
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50263: LD_VAR 0 4
50267: PPUSH
50268: LD_VAR 0 6
50272: PPUSH
50273: LD_VAR 0 4
50277: PPUSH
50278: CALL_OW 74
50282: PPUSH
50283: CALL_OW 115
// end else
50287: GO 50389
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50289: LD_VAR 0 4
50293: PPUSH
50294: LD_VAR 0 2
50298: PUSH
50299: LD_VAR 0 9
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PPUSH
50309: LD_VAR 0 2
50313: PUSH
50314: LD_VAR 0 9
50318: ARRAY
50319: PUSH
50320: LD_INT 2
50322: ARRAY
50323: PPUSH
50324: CALL_OW 297
50328: PUSH
50329: LD_INT 6
50331: GREATER
50332: IFFALSE 50375
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50334: LD_VAR 0 4
50338: PPUSH
50339: LD_VAR 0 2
50343: PUSH
50344: LD_VAR 0 9
50348: ARRAY
50349: PUSH
50350: LD_INT 1
50352: ARRAY
50353: PPUSH
50354: LD_VAR 0 2
50358: PUSH
50359: LD_VAR 0 9
50363: ARRAY
50364: PUSH
50365: LD_INT 2
50367: ARRAY
50368: PPUSH
50369: CALL_OW 114
50373: GO 50389
// SetTag ( i , tag ) ;
50375: LD_VAR 0 4
50379: PPUSH
50380: LD_VAR 0 9
50384: PPUSH
50385: CALL_OW 109
// end else
50389: GO 50462
// if enemy then
50391: LD_VAR 0 5
50395: IFFALSE 50462
// begin if GetWeapon ( i ) = ru_time_lapser then
50397: LD_VAR 0 4
50401: PPUSH
50402: CALL_OW 264
50406: PUSH
50407: LD_INT 49
50409: EQUAL
50410: IFFALSE 50438
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50412: LD_VAR 0 4
50416: PPUSH
50417: LD_VAR 0 5
50421: PPUSH
50422: LD_VAR 0 4
50426: PPUSH
50427: CALL_OW 74
50431: PPUSH
50432: CALL_OW 112
50436: GO 50462
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50438: LD_VAR 0 4
50442: PPUSH
50443: LD_VAR 0 5
50447: PPUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: CALL_OW 74
50457: PPUSH
50458: CALL_OW 115
// end ; end ;
50462: GO 50042
50464: POP
50465: POP
// end ;
50466: LD_VAR 0 3
50470: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50471: LD_INT 0
50473: PPUSH
50474: PPUSH
50475: PPUSH
// if not unit or IsInUnit ( unit ) then
50476: LD_VAR 0 1
50480: NOT
50481: PUSH
50482: LD_VAR 0 1
50486: PPUSH
50487: CALL_OW 310
50491: OR
50492: IFFALSE 50496
// exit ;
50494: GO 50587
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50496: LD_ADDR_VAR 0 4
50500: PUSH
50501: LD_VAR 0 1
50505: PPUSH
50506: CALL_OW 250
50510: PPUSH
50511: LD_VAR 0 2
50515: PPUSH
50516: LD_INT 1
50518: PPUSH
50519: CALL_OW 272
50523: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50524: LD_ADDR_VAR 0 5
50528: PUSH
50529: LD_VAR 0 1
50533: PPUSH
50534: CALL_OW 251
50538: PPUSH
50539: LD_VAR 0 2
50543: PPUSH
50544: LD_INT 1
50546: PPUSH
50547: CALL_OW 273
50551: ST_TO_ADDR
// if ValidHex ( x , y ) then
50552: LD_VAR 0 4
50556: PPUSH
50557: LD_VAR 0 5
50561: PPUSH
50562: CALL_OW 488
50566: IFFALSE 50587
// ComTurnXY ( unit , x , y ) ;
50568: LD_VAR 0 1
50572: PPUSH
50573: LD_VAR 0 4
50577: PPUSH
50578: LD_VAR 0 5
50582: PPUSH
50583: CALL_OW 118
// end ;
50587: LD_VAR 0 3
50591: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50592: LD_INT 0
50594: PPUSH
50595: PPUSH
// result := false ;
50596: LD_ADDR_VAR 0 3
50600: PUSH
50601: LD_INT 0
50603: ST_TO_ADDR
// if not units then
50604: LD_VAR 0 2
50608: NOT
50609: IFFALSE 50613
// exit ;
50611: GO 50658
// for i in units do
50613: LD_ADDR_VAR 0 4
50617: PUSH
50618: LD_VAR 0 2
50622: PUSH
50623: FOR_IN
50624: IFFALSE 50656
// if See ( side , i ) then
50626: LD_VAR 0 1
50630: PPUSH
50631: LD_VAR 0 4
50635: PPUSH
50636: CALL_OW 292
50640: IFFALSE 50654
// begin result := true ;
50642: LD_ADDR_VAR 0 3
50646: PUSH
50647: LD_INT 1
50649: ST_TO_ADDR
// exit ;
50650: POP
50651: POP
50652: GO 50658
// end ;
50654: GO 50623
50656: POP
50657: POP
// end ;
50658: LD_VAR 0 3
50662: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50663: LD_INT 0
50665: PPUSH
50666: PPUSH
50667: PPUSH
50668: PPUSH
// if not unit or not points then
50669: LD_VAR 0 1
50673: NOT
50674: PUSH
50675: LD_VAR 0 2
50679: NOT
50680: OR
50681: IFFALSE 50685
// exit ;
50683: GO 50775
// dist := 99999 ;
50685: LD_ADDR_VAR 0 5
50689: PUSH
50690: LD_INT 99999
50692: ST_TO_ADDR
// for i in points do
50693: LD_ADDR_VAR 0 4
50697: PUSH
50698: LD_VAR 0 2
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50773
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50706: LD_ADDR_VAR 0 6
50710: PUSH
50711: LD_VAR 0 1
50715: PPUSH
50716: LD_VAR 0 4
50720: PUSH
50721: LD_INT 1
50723: ARRAY
50724: PPUSH
50725: LD_VAR 0 4
50729: PUSH
50730: LD_INT 2
50732: ARRAY
50733: PPUSH
50734: CALL_OW 297
50738: ST_TO_ADDR
// if tmpDist < dist then
50739: LD_VAR 0 6
50743: PUSH
50744: LD_VAR 0 5
50748: LESS
50749: IFFALSE 50771
// begin result := i ;
50751: LD_ADDR_VAR 0 3
50755: PUSH
50756: LD_VAR 0 4
50760: ST_TO_ADDR
// dist := tmpDist ;
50761: LD_ADDR_VAR 0 5
50765: PUSH
50766: LD_VAR 0 6
50770: ST_TO_ADDR
// end ; end ;
50771: GO 50703
50773: POP
50774: POP
// end ;
50775: LD_VAR 0 3
50779: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50780: LD_INT 0
50782: PPUSH
// uc_side := side ;
50783: LD_ADDR_OWVAR 20
50787: PUSH
50788: LD_VAR 0 1
50792: ST_TO_ADDR
// uc_nation := 3 ;
50793: LD_ADDR_OWVAR 21
50797: PUSH
50798: LD_INT 3
50800: ST_TO_ADDR
// vc_chassis := 25 ;
50801: LD_ADDR_OWVAR 37
50805: PUSH
50806: LD_INT 25
50808: ST_TO_ADDR
// vc_engine := engine_siberite ;
50809: LD_ADDR_OWVAR 39
50813: PUSH
50814: LD_INT 3
50816: ST_TO_ADDR
// vc_control := control_computer ;
50817: LD_ADDR_OWVAR 38
50821: PUSH
50822: LD_INT 3
50824: ST_TO_ADDR
// vc_weapon := 59 ;
50825: LD_ADDR_OWVAR 40
50829: PUSH
50830: LD_INT 59
50832: ST_TO_ADDR
// result := CreateVehicle ;
50833: LD_ADDR_VAR 0 5
50837: PUSH
50838: CALL_OW 45
50842: ST_TO_ADDR
// SetDir ( result , d ) ;
50843: LD_VAR 0 5
50847: PPUSH
50848: LD_VAR 0 4
50852: PPUSH
50853: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
50857: LD_VAR 0 5
50861: PPUSH
50862: LD_VAR 0 2
50866: PPUSH
50867: LD_VAR 0 3
50871: PPUSH
50872: LD_INT 0
50874: PPUSH
50875: CALL_OW 48
// end ;
50879: LD_VAR 0 5
50883: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50884: LD_INT 0
50886: PPUSH
50887: PPUSH
50888: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50889: LD_ADDR_VAR 0 2
50893: PUSH
50894: LD_INT 0
50896: PUSH
50897: LD_INT 0
50899: PUSH
50900: LD_INT 0
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: LIST
50910: LIST
50911: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50912: LD_VAR 0 1
50916: NOT
50917: PUSH
50918: LD_VAR 0 1
50922: PPUSH
50923: CALL_OW 264
50927: PUSH
50928: LD_INT 12
50930: PUSH
50931: LD_INT 51
50933: PUSH
50934: LD_INT 32
50936: PUSH
50937: LD_INT 89
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: IN
50946: NOT
50947: OR
50948: IFFALSE 50952
// exit ;
50950: GO 51050
// for i := 1 to 3 do
50952: LD_ADDR_VAR 0 3
50956: PUSH
50957: DOUBLE
50958: LD_INT 1
50960: DEC
50961: ST_TO_ADDR
50962: LD_INT 3
50964: PUSH
50965: FOR_TO
50966: IFFALSE 51048
// begin tmp := GetCargo ( cargo , i ) ;
50968: LD_ADDR_VAR 0 4
50972: PUSH
50973: LD_VAR 0 1
50977: PPUSH
50978: LD_VAR 0 3
50982: PPUSH
50983: CALL_OW 289
50987: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50988: LD_ADDR_VAR 0 2
50992: PUSH
50993: LD_VAR 0 2
50997: PPUSH
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 4
51007: PPUSH
51008: CALL_OW 1
51012: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
51013: LD_ADDR_VAR 0 2
51017: PUSH
51018: LD_VAR 0 2
51022: PPUSH
51023: LD_INT 4
51025: PPUSH
51026: LD_VAR 0 2
51030: PUSH
51031: LD_INT 4
51033: ARRAY
51034: PUSH
51035: LD_VAR 0 4
51039: PLUS
51040: PPUSH
51041: CALL_OW 1
51045: ST_TO_ADDR
// end ;
51046: GO 50965
51048: POP
51049: POP
// end ;
51050: LD_VAR 0 2
51054: RET
// export function Length ( array ) ; begin
51055: LD_INT 0
51057: PPUSH
// result := array + 0 ;
51058: LD_ADDR_VAR 0 2
51062: PUSH
51063: LD_VAR 0 1
51067: PUSH
51068: LD_INT 0
51070: PLUS
51071: ST_TO_ADDR
// end ;
51072: LD_VAR 0 2
51076: RET
// export function PrepareArray ( array ) ; begin
51077: LD_INT 0
51079: PPUSH
// result := array diff 0 ;
51080: LD_ADDR_VAR 0 2
51084: PUSH
51085: LD_VAR 0 1
51089: PUSH
51090: LD_INT 0
51092: DIFF
51093: ST_TO_ADDR
// if not result [ 1 ] then
51094: LD_VAR 0 2
51098: PUSH
51099: LD_INT 1
51101: ARRAY
51102: NOT
51103: IFFALSE 51123
// result := Delete ( result , 1 ) ;
51105: LD_ADDR_VAR 0 2
51109: PUSH
51110: LD_VAR 0 2
51114: PPUSH
51115: LD_INT 1
51117: PPUSH
51118: CALL_OW 3
51122: ST_TO_ADDR
// end ;
51123: LD_VAR 0 2
51127: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
51128: LD_INT 0
51130: PPUSH
51131: PPUSH
51132: PPUSH
51133: PPUSH
// sibRocketRange := 25 ;
51134: LD_ADDR_VAR 0 6
51138: PUSH
51139: LD_INT 25
51141: ST_TO_ADDR
// result := false ;
51142: LD_ADDR_VAR 0 4
51146: PUSH
51147: LD_INT 0
51149: ST_TO_ADDR
// for i := 0 to 5 do
51150: LD_ADDR_VAR 0 5
51154: PUSH
51155: DOUBLE
51156: LD_INT 0
51158: DEC
51159: ST_TO_ADDR
51160: LD_INT 5
51162: PUSH
51163: FOR_TO
51164: IFFALSE 51231
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
51166: LD_VAR 0 1
51170: PPUSH
51171: LD_VAR 0 5
51175: PPUSH
51176: LD_VAR 0 6
51180: PPUSH
51181: CALL_OW 272
51185: PPUSH
51186: LD_VAR 0 2
51190: PPUSH
51191: LD_VAR 0 5
51195: PPUSH
51196: LD_VAR 0 6
51200: PPUSH
51201: CALL_OW 273
51205: PPUSH
51206: LD_VAR 0 3
51210: PPUSH
51211: CALL_OW 309
51215: IFFALSE 51229
// begin result := true ;
51217: LD_ADDR_VAR 0 4
51221: PUSH
51222: LD_INT 1
51224: ST_TO_ADDR
// exit ;
51225: POP
51226: POP
51227: GO 51233
// end ;
51229: GO 51163
51231: POP
51232: POP
// end ;
51233: LD_VAR 0 4
51237: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51238: LD_INT 0
51240: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51241: LD_VAR 0 1
51245: PPUSH
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_INT 0
51253: PPUSH
51254: LD_INT 0
51256: PPUSH
51257: LD_INT 1
51259: PPUSH
51260: LD_INT 0
51262: PPUSH
51263: CALL_OW 587
// end ; end_of_file
51267: LD_VAR 0 3
51271: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51272: LD_INT 0
51274: PPUSH
51275: PPUSH
// skirmish := false ;
51276: LD_ADDR_EXP 41
51280: PUSH
51281: LD_INT 0
51283: ST_TO_ADDR
// debug_mc := false ;
51284: LD_ADDR_EXP 42
51288: PUSH
51289: LD_INT 0
51291: ST_TO_ADDR
// mc_bases := [ ] ;
51292: LD_ADDR_EXP 43
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// mc_sides := [ ] ;
51299: LD_ADDR_EXP 69
51303: PUSH
51304: EMPTY
51305: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51306: LD_ADDR_EXP 44
51310: PUSH
51311: EMPTY
51312: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51313: LD_ADDR_EXP 45
51317: PUSH
51318: EMPTY
51319: ST_TO_ADDR
// mc_need_heal := [ ] ;
51320: LD_ADDR_EXP 46
51324: PUSH
51325: EMPTY
51326: ST_TO_ADDR
// mc_healers := [ ] ;
51327: LD_ADDR_EXP 47
51331: PUSH
51332: EMPTY
51333: ST_TO_ADDR
// mc_build_list := [ ] ;
51334: LD_ADDR_EXP 48
51338: PUSH
51339: EMPTY
51340: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51341: LD_ADDR_EXP 75
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// mc_builders := [ ] ;
51348: LD_ADDR_EXP 49
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// mc_construct_list := [ ] ;
51355: LD_ADDR_EXP 50
51359: PUSH
51360: EMPTY
51361: ST_TO_ADDR
// mc_turret_list := [ ] ;
51362: LD_ADDR_EXP 51
51366: PUSH
51367: EMPTY
51368: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51369: LD_ADDR_EXP 52
51373: PUSH
51374: EMPTY
51375: ST_TO_ADDR
// mc_miners := [ ] ;
51376: LD_ADDR_EXP 57
51380: PUSH
51381: EMPTY
51382: ST_TO_ADDR
// mc_mines := [ ] ;
51383: LD_ADDR_EXP 56
51387: PUSH
51388: EMPTY
51389: ST_TO_ADDR
// mc_minefields := [ ] ;
51390: LD_ADDR_EXP 58
51394: PUSH
51395: EMPTY
51396: ST_TO_ADDR
// mc_crates := [ ] ;
51397: LD_ADDR_EXP 59
51401: PUSH
51402: EMPTY
51403: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51404: LD_ADDR_EXP 60
51408: PUSH
51409: EMPTY
51410: ST_TO_ADDR
// mc_crates_area := [ ] ;
51411: LD_ADDR_EXP 61
51415: PUSH
51416: EMPTY
51417: ST_TO_ADDR
// mc_vehicles := [ ] ;
51418: LD_ADDR_EXP 62
51422: PUSH
51423: EMPTY
51424: ST_TO_ADDR
// mc_attack := [ ] ;
51425: LD_ADDR_EXP 63
51429: PUSH
51430: EMPTY
51431: ST_TO_ADDR
// mc_produce := [ ] ;
51432: LD_ADDR_EXP 64
51436: PUSH
51437: EMPTY
51438: ST_TO_ADDR
// mc_defender := [ ] ;
51439: LD_ADDR_EXP 65
51443: PUSH
51444: EMPTY
51445: ST_TO_ADDR
// mc_parking := [ ] ;
51446: LD_ADDR_EXP 67
51450: PUSH
51451: EMPTY
51452: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51453: LD_ADDR_EXP 53
51457: PUSH
51458: EMPTY
51459: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51460: LD_ADDR_EXP 55
51464: PUSH
51465: EMPTY
51466: ST_TO_ADDR
// mc_scan := [ ] ;
51467: LD_ADDR_EXP 66
51471: PUSH
51472: EMPTY
51473: ST_TO_ADDR
// mc_scan_area := [ ] ;
51474: LD_ADDR_EXP 68
51478: PUSH
51479: EMPTY
51480: ST_TO_ADDR
// mc_tech := [ ] ;
51481: LD_ADDR_EXP 70
51485: PUSH
51486: EMPTY
51487: ST_TO_ADDR
// mc_class := [ ] ;
51488: LD_ADDR_EXP 84
51492: PUSH
51493: EMPTY
51494: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51495: LD_ADDR_EXP 85
51499: PUSH
51500: EMPTY
51501: ST_TO_ADDR
// mc_is_defending := [ ] ;
51502: LD_ADDR_EXP 86
51506: PUSH
51507: EMPTY
51508: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51509: LD_ADDR_EXP 77
51513: PUSH
51514: EMPTY
51515: ST_TO_ADDR
// end ;
51516: LD_VAR 0 1
51520: RET
// export function MC_Kill ( base ) ; begin
51521: LD_INT 0
51523: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51524: LD_ADDR_EXP 43
51528: PUSH
51529: LD_EXP 43
51533: PPUSH
51534: LD_VAR 0 1
51538: PPUSH
51539: EMPTY
51540: PPUSH
51541: CALL_OW 1
51545: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51546: LD_ADDR_EXP 44
51550: PUSH
51551: LD_EXP 44
51555: PPUSH
51556: LD_VAR 0 1
51560: PPUSH
51561: EMPTY
51562: PPUSH
51563: CALL_OW 1
51567: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51568: LD_ADDR_EXP 45
51572: PUSH
51573: LD_EXP 45
51577: PPUSH
51578: LD_VAR 0 1
51582: PPUSH
51583: EMPTY
51584: PPUSH
51585: CALL_OW 1
51589: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51590: LD_ADDR_EXP 46
51594: PUSH
51595: LD_EXP 46
51599: PPUSH
51600: LD_VAR 0 1
51604: PPUSH
51605: EMPTY
51606: PPUSH
51607: CALL_OW 1
51611: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51612: LD_ADDR_EXP 47
51616: PUSH
51617: LD_EXP 47
51621: PPUSH
51622: LD_VAR 0 1
51626: PPUSH
51627: EMPTY
51628: PPUSH
51629: CALL_OW 1
51633: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51634: LD_ADDR_EXP 48
51638: PUSH
51639: LD_EXP 48
51643: PPUSH
51644: LD_VAR 0 1
51648: PPUSH
51649: EMPTY
51650: PPUSH
51651: CALL_OW 1
51655: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51656: LD_ADDR_EXP 49
51660: PUSH
51661: LD_EXP 49
51665: PPUSH
51666: LD_VAR 0 1
51670: PPUSH
51671: EMPTY
51672: PPUSH
51673: CALL_OW 1
51677: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51678: LD_ADDR_EXP 50
51682: PUSH
51683: LD_EXP 50
51687: PPUSH
51688: LD_VAR 0 1
51692: PPUSH
51693: EMPTY
51694: PPUSH
51695: CALL_OW 1
51699: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51700: LD_ADDR_EXP 51
51704: PUSH
51705: LD_EXP 51
51709: PPUSH
51710: LD_VAR 0 1
51714: PPUSH
51715: EMPTY
51716: PPUSH
51717: CALL_OW 1
51721: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51722: LD_ADDR_EXP 52
51726: PUSH
51727: LD_EXP 52
51731: PPUSH
51732: LD_VAR 0 1
51736: PPUSH
51737: EMPTY
51738: PPUSH
51739: CALL_OW 1
51743: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51744: LD_ADDR_EXP 53
51748: PUSH
51749: LD_EXP 53
51753: PPUSH
51754: LD_VAR 0 1
51758: PPUSH
51759: EMPTY
51760: PPUSH
51761: CALL_OW 1
51765: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51766: LD_ADDR_EXP 54
51770: PUSH
51771: LD_EXP 54
51775: PPUSH
51776: LD_VAR 0 1
51780: PPUSH
51781: LD_INT 0
51783: PPUSH
51784: CALL_OW 1
51788: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51789: LD_ADDR_EXP 55
51793: PUSH
51794: LD_EXP 55
51798: PPUSH
51799: LD_VAR 0 1
51803: PPUSH
51804: EMPTY
51805: PPUSH
51806: CALL_OW 1
51810: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51811: LD_ADDR_EXP 56
51815: PUSH
51816: LD_EXP 56
51820: PPUSH
51821: LD_VAR 0 1
51825: PPUSH
51826: EMPTY
51827: PPUSH
51828: CALL_OW 1
51832: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51833: LD_ADDR_EXP 57
51837: PUSH
51838: LD_EXP 57
51842: PPUSH
51843: LD_VAR 0 1
51847: PPUSH
51848: EMPTY
51849: PPUSH
51850: CALL_OW 1
51854: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51855: LD_ADDR_EXP 58
51859: PUSH
51860: LD_EXP 58
51864: PPUSH
51865: LD_VAR 0 1
51869: PPUSH
51870: EMPTY
51871: PPUSH
51872: CALL_OW 1
51876: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51877: LD_ADDR_EXP 59
51881: PUSH
51882: LD_EXP 59
51886: PPUSH
51887: LD_VAR 0 1
51891: PPUSH
51892: EMPTY
51893: PPUSH
51894: CALL_OW 1
51898: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51899: LD_ADDR_EXP 60
51903: PUSH
51904: LD_EXP 60
51908: PPUSH
51909: LD_VAR 0 1
51913: PPUSH
51914: EMPTY
51915: PPUSH
51916: CALL_OW 1
51920: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51921: LD_ADDR_EXP 61
51925: PUSH
51926: LD_EXP 61
51930: PPUSH
51931: LD_VAR 0 1
51935: PPUSH
51936: EMPTY
51937: PPUSH
51938: CALL_OW 1
51942: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51943: LD_ADDR_EXP 62
51947: PUSH
51948: LD_EXP 62
51952: PPUSH
51953: LD_VAR 0 1
51957: PPUSH
51958: EMPTY
51959: PPUSH
51960: CALL_OW 1
51964: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51965: LD_ADDR_EXP 63
51969: PUSH
51970: LD_EXP 63
51974: PPUSH
51975: LD_VAR 0 1
51979: PPUSH
51980: EMPTY
51981: PPUSH
51982: CALL_OW 1
51986: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51987: LD_ADDR_EXP 64
51991: PUSH
51992: LD_EXP 64
51996: PPUSH
51997: LD_VAR 0 1
52001: PPUSH
52002: EMPTY
52003: PPUSH
52004: CALL_OW 1
52008: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52009: LD_ADDR_EXP 65
52013: PUSH
52014: LD_EXP 65
52018: PPUSH
52019: LD_VAR 0 1
52023: PPUSH
52024: EMPTY
52025: PPUSH
52026: CALL_OW 1
52030: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52031: LD_ADDR_EXP 66
52035: PUSH
52036: LD_EXP 66
52040: PPUSH
52041: LD_VAR 0 1
52045: PPUSH
52046: EMPTY
52047: PPUSH
52048: CALL_OW 1
52052: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52053: LD_ADDR_EXP 67
52057: PUSH
52058: LD_EXP 67
52062: PPUSH
52063: LD_VAR 0 1
52067: PPUSH
52068: EMPTY
52069: PPUSH
52070: CALL_OW 1
52074: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52075: LD_ADDR_EXP 68
52079: PUSH
52080: LD_EXP 68
52084: PPUSH
52085: LD_VAR 0 1
52089: PPUSH
52090: EMPTY
52091: PPUSH
52092: CALL_OW 1
52096: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52097: LD_ADDR_EXP 70
52101: PUSH
52102: LD_EXP 70
52106: PPUSH
52107: LD_VAR 0 1
52111: PPUSH
52112: EMPTY
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52119: LD_ADDR_EXP 72
52123: PUSH
52124: LD_EXP 72
52128: PPUSH
52129: LD_VAR 0 1
52133: PPUSH
52134: EMPTY
52135: PPUSH
52136: CALL_OW 1
52140: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52141: LD_ADDR_EXP 73
52145: PUSH
52146: LD_EXP 73
52150: PPUSH
52151: LD_VAR 0 1
52155: PPUSH
52156: EMPTY
52157: PPUSH
52158: CALL_OW 1
52162: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52163: LD_ADDR_EXP 74
52167: PUSH
52168: LD_EXP 74
52172: PPUSH
52173: LD_VAR 0 1
52177: PPUSH
52178: EMPTY
52179: PPUSH
52180: CALL_OW 1
52184: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52185: LD_ADDR_EXP 75
52189: PUSH
52190: LD_EXP 75
52194: PPUSH
52195: LD_VAR 0 1
52199: PPUSH
52200: EMPTY
52201: PPUSH
52202: CALL_OW 1
52206: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52207: LD_ADDR_EXP 76
52211: PUSH
52212: LD_EXP 76
52216: PPUSH
52217: LD_VAR 0 1
52221: PPUSH
52222: EMPTY
52223: PPUSH
52224: CALL_OW 1
52228: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52229: LD_ADDR_EXP 77
52233: PUSH
52234: LD_EXP 77
52238: PPUSH
52239: LD_VAR 0 1
52243: PPUSH
52244: EMPTY
52245: PPUSH
52246: CALL_OW 1
52250: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52251: LD_ADDR_EXP 78
52255: PUSH
52256: LD_EXP 78
52260: PPUSH
52261: LD_VAR 0 1
52265: PPUSH
52266: EMPTY
52267: PPUSH
52268: CALL_OW 1
52272: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52273: LD_ADDR_EXP 79
52277: PUSH
52278: LD_EXP 79
52282: PPUSH
52283: LD_VAR 0 1
52287: PPUSH
52288: EMPTY
52289: PPUSH
52290: CALL_OW 1
52294: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52295: LD_ADDR_EXP 80
52299: PUSH
52300: LD_EXP 80
52304: PPUSH
52305: LD_VAR 0 1
52309: PPUSH
52310: EMPTY
52311: PPUSH
52312: CALL_OW 1
52316: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52317: LD_ADDR_EXP 81
52321: PUSH
52322: LD_EXP 81
52326: PPUSH
52327: LD_VAR 0 1
52331: PPUSH
52332: EMPTY
52333: PPUSH
52334: CALL_OW 1
52338: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52339: LD_ADDR_EXP 82
52343: PUSH
52344: LD_EXP 82
52348: PPUSH
52349: LD_VAR 0 1
52353: PPUSH
52354: EMPTY
52355: PPUSH
52356: CALL_OW 1
52360: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52361: LD_ADDR_EXP 83
52365: PUSH
52366: LD_EXP 83
52370: PPUSH
52371: LD_VAR 0 1
52375: PPUSH
52376: EMPTY
52377: PPUSH
52378: CALL_OW 1
52382: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52383: LD_ADDR_EXP 84
52387: PUSH
52388: LD_EXP 84
52392: PPUSH
52393: LD_VAR 0 1
52397: PPUSH
52398: EMPTY
52399: PPUSH
52400: CALL_OW 1
52404: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52405: LD_ADDR_EXP 85
52409: PUSH
52410: LD_EXP 85
52414: PPUSH
52415: LD_VAR 0 1
52419: PPUSH
52420: LD_INT 0
52422: PPUSH
52423: CALL_OW 1
52427: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52428: LD_ADDR_EXP 86
52432: PUSH
52433: LD_EXP 86
52437: PPUSH
52438: LD_VAR 0 1
52442: PPUSH
52443: LD_INT 0
52445: PPUSH
52446: CALL_OW 1
52450: ST_TO_ADDR
// end ;
52451: LD_VAR 0 2
52455: RET
// export function MC_Add ( side , units ) ; var base ; begin
52456: LD_INT 0
52458: PPUSH
52459: PPUSH
// base := mc_bases + 1 ;
52460: LD_ADDR_VAR 0 4
52464: PUSH
52465: LD_EXP 43
52469: PUSH
52470: LD_INT 1
52472: PLUS
52473: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52474: LD_ADDR_EXP 69
52478: PUSH
52479: LD_EXP 69
52483: PPUSH
52484: LD_VAR 0 4
52488: PPUSH
52489: LD_VAR 0 1
52493: PPUSH
52494: CALL_OW 1
52498: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52499: LD_ADDR_EXP 43
52503: PUSH
52504: LD_EXP 43
52508: PPUSH
52509: LD_VAR 0 4
52513: PPUSH
52514: LD_VAR 0 2
52518: PPUSH
52519: CALL_OW 1
52523: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52524: LD_ADDR_EXP 44
52528: PUSH
52529: LD_EXP 44
52533: PPUSH
52534: LD_VAR 0 4
52538: PPUSH
52539: EMPTY
52540: PPUSH
52541: CALL_OW 1
52545: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52546: LD_ADDR_EXP 45
52550: PUSH
52551: LD_EXP 45
52555: PPUSH
52556: LD_VAR 0 4
52560: PPUSH
52561: EMPTY
52562: PPUSH
52563: CALL_OW 1
52567: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52568: LD_ADDR_EXP 46
52572: PUSH
52573: LD_EXP 46
52577: PPUSH
52578: LD_VAR 0 4
52582: PPUSH
52583: EMPTY
52584: PPUSH
52585: CALL_OW 1
52589: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52590: LD_ADDR_EXP 47
52594: PUSH
52595: LD_EXP 47
52599: PPUSH
52600: LD_VAR 0 4
52604: PPUSH
52605: EMPTY
52606: PPUSH
52607: CALL_OW 1
52611: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52612: LD_ADDR_EXP 48
52616: PUSH
52617: LD_EXP 48
52621: PPUSH
52622: LD_VAR 0 4
52626: PPUSH
52627: EMPTY
52628: PPUSH
52629: CALL_OW 1
52633: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52634: LD_ADDR_EXP 49
52638: PUSH
52639: LD_EXP 49
52643: PPUSH
52644: LD_VAR 0 4
52648: PPUSH
52649: EMPTY
52650: PPUSH
52651: CALL_OW 1
52655: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52656: LD_ADDR_EXP 50
52660: PUSH
52661: LD_EXP 50
52665: PPUSH
52666: LD_VAR 0 4
52670: PPUSH
52671: EMPTY
52672: PPUSH
52673: CALL_OW 1
52677: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52678: LD_ADDR_EXP 51
52682: PUSH
52683: LD_EXP 51
52687: PPUSH
52688: LD_VAR 0 4
52692: PPUSH
52693: EMPTY
52694: PPUSH
52695: CALL_OW 1
52699: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52700: LD_ADDR_EXP 52
52704: PUSH
52705: LD_EXP 52
52709: PPUSH
52710: LD_VAR 0 4
52714: PPUSH
52715: EMPTY
52716: PPUSH
52717: CALL_OW 1
52721: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52722: LD_ADDR_EXP 53
52726: PUSH
52727: LD_EXP 53
52731: PPUSH
52732: LD_VAR 0 4
52736: PPUSH
52737: EMPTY
52738: PPUSH
52739: CALL_OW 1
52743: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52744: LD_ADDR_EXP 54
52748: PUSH
52749: LD_EXP 54
52753: PPUSH
52754: LD_VAR 0 4
52758: PPUSH
52759: LD_INT 0
52761: PPUSH
52762: CALL_OW 1
52766: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52767: LD_ADDR_EXP 55
52771: PUSH
52772: LD_EXP 55
52776: PPUSH
52777: LD_VAR 0 4
52781: PPUSH
52782: EMPTY
52783: PPUSH
52784: CALL_OW 1
52788: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52789: LD_ADDR_EXP 56
52793: PUSH
52794: LD_EXP 56
52798: PPUSH
52799: LD_VAR 0 4
52803: PPUSH
52804: EMPTY
52805: PPUSH
52806: CALL_OW 1
52810: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52811: LD_ADDR_EXP 57
52815: PUSH
52816: LD_EXP 57
52820: PPUSH
52821: LD_VAR 0 4
52825: PPUSH
52826: EMPTY
52827: PPUSH
52828: CALL_OW 1
52832: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52833: LD_ADDR_EXP 58
52837: PUSH
52838: LD_EXP 58
52842: PPUSH
52843: LD_VAR 0 4
52847: PPUSH
52848: EMPTY
52849: PPUSH
52850: CALL_OW 1
52854: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52855: LD_ADDR_EXP 59
52859: PUSH
52860: LD_EXP 59
52864: PPUSH
52865: LD_VAR 0 4
52869: PPUSH
52870: EMPTY
52871: PPUSH
52872: CALL_OW 1
52876: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52877: LD_ADDR_EXP 60
52881: PUSH
52882: LD_EXP 60
52886: PPUSH
52887: LD_VAR 0 4
52891: PPUSH
52892: EMPTY
52893: PPUSH
52894: CALL_OW 1
52898: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52899: LD_ADDR_EXP 61
52903: PUSH
52904: LD_EXP 61
52908: PPUSH
52909: LD_VAR 0 4
52913: PPUSH
52914: EMPTY
52915: PPUSH
52916: CALL_OW 1
52920: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52921: LD_ADDR_EXP 62
52925: PUSH
52926: LD_EXP 62
52930: PPUSH
52931: LD_VAR 0 4
52935: PPUSH
52936: EMPTY
52937: PPUSH
52938: CALL_OW 1
52942: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52943: LD_ADDR_EXP 63
52947: PUSH
52948: LD_EXP 63
52952: PPUSH
52953: LD_VAR 0 4
52957: PPUSH
52958: EMPTY
52959: PPUSH
52960: CALL_OW 1
52964: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52965: LD_ADDR_EXP 64
52969: PUSH
52970: LD_EXP 64
52974: PPUSH
52975: LD_VAR 0 4
52979: PPUSH
52980: EMPTY
52981: PPUSH
52982: CALL_OW 1
52986: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52987: LD_ADDR_EXP 65
52991: PUSH
52992: LD_EXP 65
52996: PPUSH
52997: LD_VAR 0 4
53001: PPUSH
53002: EMPTY
53003: PPUSH
53004: CALL_OW 1
53008: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53009: LD_ADDR_EXP 66
53013: PUSH
53014: LD_EXP 66
53018: PPUSH
53019: LD_VAR 0 4
53023: PPUSH
53024: EMPTY
53025: PPUSH
53026: CALL_OW 1
53030: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53031: LD_ADDR_EXP 67
53035: PUSH
53036: LD_EXP 67
53040: PPUSH
53041: LD_VAR 0 4
53045: PPUSH
53046: EMPTY
53047: PPUSH
53048: CALL_OW 1
53052: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53053: LD_ADDR_EXP 68
53057: PUSH
53058: LD_EXP 68
53062: PPUSH
53063: LD_VAR 0 4
53067: PPUSH
53068: EMPTY
53069: PPUSH
53070: CALL_OW 1
53074: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53075: LD_ADDR_EXP 70
53079: PUSH
53080: LD_EXP 70
53084: PPUSH
53085: LD_VAR 0 4
53089: PPUSH
53090: EMPTY
53091: PPUSH
53092: CALL_OW 1
53096: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53097: LD_ADDR_EXP 72
53101: PUSH
53102: LD_EXP 72
53106: PPUSH
53107: LD_VAR 0 4
53111: PPUSH
53112: EMPTY
53113: PPUSH
53114: CALL_OW 1
53118: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53119: LD_ADDR_EXP 73
53123: PUSH
53124: LD_EXP 73
53128: PPUSH
53129: LD_VAR 0 4
53133: PPUSH
53134: EMPTY
53135: PPUSH
53136: CALL_OW 1
53140: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53141: LD_ADDR_EXP 74
53145: PUSH
53146: LD_EXP 74
53150: PPUSH
53151: LD_VAR 0 4
53155: PPUSH
53156: EMPTY
53157: PPUSH
53158: CALL_OW 1
53162: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53163: LD_ADDR_EXP 75
53167: PUSH
53168: LD_EXP 75
53172: PPUSH
53173: LD_VAR 0 4
53177: PPUSH
53178: EMPTY
53179: PPUSH
53180: CALL_OW 1
53184: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53185: LD_ADDR_EXP 76
53189: PUSH
53190: LD_EXP 76
53194: PPUSH
53195: LD_VAR 0 4
53199: PPUSH
53200: EMPTY
53201: PPUSH
53202: CALL_OW 1
53206: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53207: LD_ADDR_EXP 77
53211: PUSH
53212: LD_EXP 77
53216: PPUSH
53217: LD_VAR 0 4
53221: PPUSH
53222: EMPTY
53223: PPUSH
53224: CALL_OW 1
53228: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53229: LD_ADDR_EXP 78
53233: PUSH
53234: LD_EXP 78
53238: PPUSH
53239: LD_VAR 0 4
53243: PPUSH
53244: EMPTY
53245: PPUSH
53246: CALL_OW 1
53250: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53251: LD_ADDR_EXP 79
53255: PUSH
53256: LD_EXP 79
53260: PPUSH
53261: LD_VAR 0 4
53265: PPUSH
53266: EMPTY
53267: PPUSH
53268: CALL_OW 1
53272: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53273: LD_ADDR_EXP 80
53277: PUSH
53278: LD_EXP 80
53282: PPUSH
53283: LD_VAR 0 4
53287: PPUSH
53288: EMPTY
53289: PPUSH
53290: CALL_OW 1
53294: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53295: LD_ADDR_EXP 81
53299: PUSH
53300: LD_EXP 81
53304: PPUSH
53305: LD_VAR 0 4
53309: PPUSH
53310: EMPTY
53311: PPUSH
53312: CALL_OW 1
53316: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53317: LD_ADDR_EXP 82
53321: PUSH
53322: LD_EXP 82
53326: PPUSH
53327: LD_VAR 0 4
53331: PPUSH
53332: EMPTY
53333: PPUSH
53334: CALL_OW 1
53338: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53339: LD_ADDR_EXP 83
53343: PUSH
53344: LD_EXP 83
53348: PPUSH
53349: LD_VAR 0 4
53353: PPUSH
53354: EMPTY
53355: PPUSH
53356: CALL_OW 1
53360: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53361: LD_ADDR_EXP 84
53365: PUSH
53366: LD_EXP 84
53370: PPUSH
53371: LD_VAR 0 4
53375: PPUSH
53376: EMPTY
53377: PPUSH
53378: CALL_OW 1
53382: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53383: LD_ADDR_EXP 85
53387: PUSH
53388: LD_EXP 85
53392: PPUSH
53393: LD_VAR 0 4
53397: PPUSH
53398: LD_INT 0
53400: PPUSH
53401: CALL_OW 1
53405: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53406: LD_ADDR_EXP 86
53410: PUSH
53411: LD_EXP 86
53415: PPUSH
53416: LD_VAR 0 4
53420: PPUSH
53421: LD_INT 0
53423: PPUSH
53424: CALL_OW 1
53428: ST_TO_ADDR
// result := base ;
53429: LD_ADDR_VAR 0 3
53433: PUSH
53434: LD_VAR 0 4
53438: ST_TO_ADDR
// end ;
53439: LD_VAR 0 3
53443: RET
// export function MC_Start ( ) ; var i ; begin
53444: LD_INT 0
53446: PPUSH
53447: PPUSH
// for i = 1 to mc_bases do
53448: LD_ADDR_VAR 0 2
53452: PUSH
53453: DOUBLE
53454: LD_INT 1
53456: DEC
53457: ST_TO_ADDR
53458: LD_EXP 43
53462: PUSH
53463: FOR_TO
53464: IFFALSE 54564
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53466: LD_ADDR_EXP 43
53470: PUSH
53471: LD_EXP 43
53475: PPUSH
53476: LD_VAR 0 2
53480: PPUSH
53481: LD_EXP 43
53485: PUSH
53486: LD_VAR 0 2
53490: ARRAY
53491: PUSH
53492: LD_INT 0
53494: DIFF
53495: PPUSH
53496: CALL_OW 1
53500: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53501: LD_ADDR_EXP 44
53505: PUSH
53506: LD_EXP 44
53510: PPUSH
53511: LD_VAR 0 2
53515: PPUSH
53516: EMPTY
53517: PPUSH
53518: CALL_OW 1
53522: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53523: LD_ADDR_EXP 45
53527: PUSH
53528: LD_EXP 45
53532: PPUSH
53533: LD_VAR 0 2
53537: PPUSH
53538: EMPTY
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53545: LD_ADDR_EXP 46
53549: PUSH
53550: LD_EXP 46
53554: PPUSH
53555: LD_VAR 0 2
53559: PPUSH
53560: EMPTY
53561: PPUSH
53562: CALL_OW 1
53566: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53567: LD_ADDR_EXP 47
53571: PUSH
53572: LD_EXP 47
53576: PPUSH
53577: LD_VAR 0 2
53581: PPUSH
53582: EMPTY
53583: PUSH
53584: EMPTY
53585: PUSH
53586: EMPTY
53587: LIST
53588: LIST
53589: PPUSH
53590: CALL_OW 1
53594: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53595: LD_ADDR_EXP 48
53599: PUSH
53600: LD_EXP 48
53604: PPUSH
53605: LD_VAR 0 2
53609: PPUSH
53610: EMPTY
53611: PPUSH
53612: CALL_OW 1
53616: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53617: LD_ADDR_EXP 75
53621: PUSH
53622: LD_EXP 75
53626: PPUSH
53627: LD_VAR 0 2
53631: PPUSH
53632: EMPTY
53633: PPUSH
53634: CALL_OW 1
53638: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53639: LD_ADDR_EXP 49
53643: PUSH
53644: LD_EXP 49
53648: PPUSH
53649: LD_VAR 0 2
53653: PPUSH
53654: EMPTY
53655: PPUSH
53656: CALL_OW 1
53660: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53661: LD_ADDR_EXP 50
53665: PUSH
53666: LD_EXP 50
53670: PPUSH
53671: LD_VAR 0 2
53675: PPUSH
53676: EMPTY
53677: PPUSH
53678: CALL_OW 1
53682: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53683: LD_ADDR_EXP 51
53687: PUSH
53688: LD_EXP 51
53692: PPUSH
53693: LD_VAR 0 2
53697: PPUSH
53698: LD_EXP 43
53702: PUSH
53703: LD_VAR 0 2
53707: ARRAY
53708: PPUSH
53709: LD_INT 2
53711: PUSH
53712: LD_INT 30
53714: PUSH
53715: LD_INT 32
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: PUSH
53722: LD_INT 30
53724: PUSH
53725: LD_INT 33
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: LIST
53736: PPUSH
53737: CALL_OW 72
53741: PPUSH
53742: CALL_OW 1
53746: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53747: LD_ADDR_EXP 52
53751: PUSH
53752: LD_EXP 52
53756: PPUSH
53757: LD_VAR 0 2
53761: PPUSH
53762: LD_EXP 43
53766: PUSH
53767: LD_VAR 0 2
53771: ARRAY
53772: PPUSH
53773: LD_INT 2
53775: PUSH
53776: LD_INT 30
53778: PUSH
53779: LD_INT 32
53781: PUSH
53782: EMPTY
53783: LIST
53784: LIST
53785: PUSH
53786: LD_INT 30
53788: PUSH
53789: LD_INT 31
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PUSH
53796: EMPTY
53797: LIST
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 58
53803: PUSH
53804: EMPTY
53805: LIST
53806: PUSH
53807: EMPTY
53808: LIST
53809: LIST
53810: PPUSH
53811: CALL_OW 72
53815: PPUSH
53816: CALL_OW 1
53820: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53821: LD_ADDR_EXP 53
53825: PUSH
53826: LD_EXP 53
53830: PPUSH
53831: LD_VAR 0 2
53835: PPUSH
53836: EMPTY
53837: PPUSH
53838: CALL_OW 1
53842: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53843: LD_ADDR_EXP 57
53847: PUSH
53848: LD_EXP 57
53852: PPUSH
53853: LD_VAR 0 2
53857: PPUSH
53858: EMPTY
53859: PPUSH
53860: CALL_OW 1
53864: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53865: LD_ADDR_EXP 56
53869: PUSH
53870: LD_EXP 56
53874: PPUSH
53875: LD_VAR 0 2
53879: PPUSH
53880: EMPTY
53881: PPUSH
53882: CALL_OW 1
53886: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53887: LD_ADDR_EXP 58
53891: PUSH
53892: LD_EXP 58
53896: PPUSH
53897: LD_VAR 0 2
53901: PPUSH
53902: EMPTY
53903: PPUSH
53904: CALL_OW 1
53908: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53909: LD_ADDR_EXP 59
53913: PUSH
53914: LD_EXP 59
53918: PPUSH
53919: LD_VAR 0 2
53923: PPUSH
53924: EMPTY
53925: PPUSH
53926: CALL_OW 1
53930: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53931: LD_ADDR_EXP 60
53935: PUSH
53936: LD_EXP 60
53940: PPUSH
53941: LD_VAR 0 2
53945: PPUSH
53946: EMPTY
53947: PPUSH
53948: CALL_OW 1
53952: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53953: LD_ADDR_EXP 61
53957: PUSH
53958: LD_EXP 61
53962: PPUSH
53963: LD_VAR 0 2
53967: PPUSH
53968: EMPTY
53969: PPUSH
53970: CALL_OW 1
53974: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53975: LD_ADDR_EXP 62
53979: PUSH
53980: LD_EXP 62
53984: PPUSH
53985: LD_VAR 0 2
53989: PPUSH
53990: EMPTY
53991: PPUSH
53992: CALL_OW 1
53996: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53997: LD_ADDR_EXP 63
54001: PUSH
54002: LD_EXP 63
54006: PPUSH
54007: LD_VAR 0 2
54011: PPUSH
54012: EMPTY
54013: PPUSH
54014: CALL_OW 1
54018: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54019: LD_ADDR_EXP 64
54023: PUSH
54024: LD_EXP 64
54028: PPUSH
54029: LD_VAR 0 2
54033: PPUSH
54034: EMPTY
54035: PPUSH
54036: CALL_OW 1
54040: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54041: LD_ADDR_EXP 65
54045: PUSH
54046: LD_EXP 65
54050: PPUSH
54051: LD_VAR 0 2
54055: PPUSH
54056: EMPTY
54057: PPUSH
54058: CALL_OW 1
54062: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54063: LD_ADDR_EXP 54
54067: PUSH
54068: LD_EXP 54
54072: PPUSH
54073: LD_VAR 0 2
54077: PPUSH
54078: LD_INT 0
54080: PPUSH
54081: CALL_OW 1
54085: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54086: LD_ADDR_EXP 67
54090: PUSH
54091: LD_EXP 67
54095: PPUSH
54096: LD_VAR 0 2
54100: PPUSH
54101: LD_INT 0
54103: PPUSH
54104: CALL_OW 1
54108: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54109: LD_ADDR_EXP 55
54113: PUSH
54114: LD_EXP 55
54118: PPUSH
54119: LD_VAR 0 2
54123: PPUSH
54124: EMPTY
54125: PPUSH
54126: CALL_OW 1
54130: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54131: LD_ADDR_EXP 66
54135: PUSH
54136: LD_EXP 66
54140: PPUSH
54141: LD_VAR 0 2
54145: PPUSH
54146: LD_INT 0
54148: PPUSH
54149: CALL_OW 1
54153: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54154: LD_ADDR_EXP 68
54158: PUSH
54159: LD_EXP 68
54163: PPUSH
54164: LD_VAR 0 2
54168: PPUSH
54169: EMPTY
54170: PPUSH
54171: CALL_OW 1
54175: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54176: LD_ADDR_EXP 71
54180: PUSH
54181: LD_EXP 71
54185: PPUSH
54186: LD_VAR 0 2
54190: PPUSH
54191: LD_INT 0
54193: PPUSH
54194: CALL_OW 1
54198: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54199: LD_ADDR_EXP 72
54203: PUSH
54204: LD_EXP 72
54208: PPUSH
54209: LD_VAR 0 2
54213: PPUSH
54214: EMPTY
54215: PPUSH
54216: CALL_OW 1
54220: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54221: LD_ADDR_EXP 73
54225: PUSH
54226: LD_EXP 73
54230: PPUSH
54231: LD_VAR 0 2
54235: PPUSH
54236: EMPTY
54237: PPUSH
54238: CALL_OW 1
54242: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54243: LD_ADDR_EXP 74
54247: PUSH
54248: LD_EXP 74
54252: PPUSH
54253: LD_VAR 0 2
54257: PPUSH
54258: EMPTY
54259: PPUSH
54260: CALL_OW 1
54264: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54265: LD_ADDR_EXP 76
54269: PUSH
54270: LD_EXP 76
54274: PPUSH
54275: LD_VAR 0 2
54279: PPUSH
54280: LD_EXP 43
54284: PUSH
54285: LD_VAR 0 2
54289: ARRAY
54290: PPUSH
54291: LD_INT 2
54293: PUSH
54294: LD_INT 30
54296: PUSH
54297: LD_INT 6
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: PUSH
54304: LD_INT 30
54306: PUSH
54307: LD_INT 7
54309: PUSH
54310: EMPTY
54311: LIST
54312: LIST
54313: PUSH
54314: LD_INT 30
54316: PUSH
54317: LD_INT 8
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: LIST
54328: LIST
54329: PPUSH
54330: CALL_OW 72
54334: PPUSH
54335: CALL_OW 1
54339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54340: LD_ADDR_EXP 77
54344: PUSH
54345: LD_EXP 77
54349: PPUSH
54350: LD_VAR 0 2
54354: PPUSH
54355: EMPTY
54356: PPUSH
54357: CALL_OW 1
54361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54362: LD_ADDR_EXP 78
54366: PUSH
54367: LD_EXP 78
54371: PPUSH
54372: LD_VAR 0 2
54376: PPUSH
54377: EMPTY
54378: PPUSH
54379: CALL_OW 1
54383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54384: LD_ADDR_EXP 79
54388: PUSH
54389: LD_EXP 79
54393: PPUSH
54394: LD_VAR 0 2
54398: PPUSH
54399: EMPTY
54400: PPUSH
54401: CALL_OW 1
54405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54406: LD_ADDR_EXP 80
54410: PUSH
54411: LD_EXP 80
54415: PPUSH
54416: LD_VAR 0 2
54420: PPUSH
54421: EMPTY
54422: PPUSH
54423: CALL_OW 1
54427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54428: LD_ADDR_EXP 81
54432: PUSH
54433: LD_EXP 81
54437: PPUSH
54438: LD_VAR 0 2
54442: PPUSH
54443: EMPTY
54444: PPUSH
54445: CALL_OW 1
54449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54450: LD_ADDR_EXP 82
54454: PUSH
54455: LD_EXP 82
54459: PPUSH
54460: LD_VAR 0 2
54464: PPUSH
54465: EMPTY
54466: PPUSH
54467: CALL_OW 1
54471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54472: LD_ADDR_EXP 83
54476: PUSH
54477: LD_EXP 83
54481: PPUSH
54482: LD_VAR 0 2
54486: PPUSH
54487: EMPTY
54488: PPUSH
54489: CALL_OW 1
54493: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54494: LD_ADDR_EXP 84
54498: PUSH
54499: LD_EXP 84
54503: PPUSH
54504: LD_VAR 0 2
54508: PPUSH
54509: EMPTY
54510: PPUSH
54511: CALL_OW 1
54515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54516: LD_ADDR_EXP 85
54520: PUSH
54521: LD_EXP 85
54525: PPUSH
54526: LD_VAR 0 2
54530: PPUSH
54531: LD_INT 0
54533: PPUSH
54534: CALL_OW 1
54538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54539: LD_ADDR_EXP 86
54543: PUSH
54544: LD_EXP 86
54548: PPUSH
54549: LD_VAR 0 2
54553: PPUSH
54554: LD_INT 0
54556: PPUSH
54557: CALL_OW 1
54561: ST_TO_ADDR
// end ;
54562: GO 53463
54564: POP
54565: POP
// MC_InitSides ( ) ;
54566: CALL 54852 0 0
// MC_InitResearch ( ) ;
54570: CALL 54591 0 0
// CustomInitMacro ( ) ;
54574: CALL 97 0 0
// skirmish := true ;
54578: LD_ADDR_EXP 41
54582: PUSH
54583: LD_INT 1
54585: ST_TO_ADDR
// end ;
54586: LD_VAR 0 1
54590: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54591: LD_INT 0
54593: PPUSH
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
54598: PPUSH
// if not mc_bases then
54599: LD_EXP 43
54603: NOT
54604: IFFALSE 54608
// exit ;
54606: GO 54847
// for i = 1 to 8 do
54608: LD_ADDR_VAR 0 2
54612: PUSH
54613: DOUBLE
54614: LD_INT 1
54616: DEC
54617: ST_TO_ADDR
54618: LD_INT 8
54620: PUSH
54621: FOR_TO
54622: IFFALSE 54648
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54624: LD_ADDR_EXP 70
54628: PUSH
54629: LD_EXP 70
54633: PPUSH
54634: LD_VAR 0 2
54638: PPUSH
54639: EMPTY
54640: PPUSH
54641: CALL_OW 1
54645: ST_TO_ADDR
54646: GO 54621
54648: POP
54649: POP
// tmp := [ ] ;
54650: LD_ADDR_VAR 0 5
54654: PUSH
54655: EMPTY
54656: ST_TO_ADDR
// for i = 1 to mc_sides do
54657: LD_ADDR_VAR 0 2
54661: PUSH
54662: DOUBLE
54663: LD_INT 1
54665: DEC
54666: ST_TO_ADDR
54667: LD_EXP 69
54671: PUSH
54672: FOR_TO
54673: IFFALSE 54731
// if not mc_sides [ i ] in tmp then
54675: LD_EXP 69
54679: PUSH
54680: LD_VAR 0 2
54684: ARRAY
54685: PUSH
54686: LD_VAR 0 5
54690: IN
54691: NOT
54692: IFFALSE 54729
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54694: LD_ADDR_VAR 0 5
54698: PUSH
54699: LD_VAR 0 5
54703: PPUSH
54704: LD_VAR 0 5
54708: PUSH
54709: LD_INT 1
54711: PLUS
54712: PPUSH
54713: LD_EXP 69
54717: PUSH
54718: LD_VAR 0 2
54722: ARRAY
54723: PPUSH
54724: CALL_OW 2
54728: ST_TO_ADDR
54729: GO 54672
54731: POP
54732: POP
// if not tmp then
54733: LD_VAR 0 5
54737: NOT
54738: IFFALSE 54742
// exit ;
54740: GO 54847
// for j in tmp do
54742: LD_ADDR_VAR 0 3
54746: PUSH
54747: LD_VAR 0 5
54751: PUSH
54752: FOR_IN
54753: IFFALSE 54845
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54755: LD_ADDR_VAR 0 6
54759: PUSH
54760: LD_INT 22
54762: PUSH
54763: LD_VAR 0 3
54767: PUSH
54768: EMPTY
54769: LIST
54770: LIST
54771: PPUSH
54772: CALL_OW 69
54776: ST_TO_ADDR
// if not un then
54777: LD_VAR 0 6
54781: NOT
54782: IFFALSE 54786
// continue ;
54784: GO 54752
// nation := GetNation ( un [ 1 ] ) ;
54786: LD_ADDR_VAR 0 4
54790: PUSH
54791: LD_VAR 0 6
54795: PUSH
54796: LD_INT 1
54798: ARRAY
54799: PPUSH
54800: CALL_OW 248
54804: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54805: LD_ADDR_EXP 70
54809: PUSH
54810: LD_EXP 70
54814: PPUSH
54815: LD_VAR 0 3
54819: PPUSH
54820: LD_VAR 0 3
54824: PPUSH
54825: LD_VAR 0 4
54829: PPUSH
54830: LD_INT 1
54832: PPUSH
54833: CALL 9914 0 3
54837: PPUSH
54838: CALL_OW 1
54842: ST_TO_ADDR
// end ;
54843: GO 54752
54845: POP
54846: POP
// end ;
54847: LD_VAR 0 1
54851: RET
// export function MC_InitSides ( ) ; var i ; begin
54852: LD_INT 0
54854: PPUSH
54855: PPUSH
// if not mc_bases then
54856: LD_EXP 43
54860: NOT
54861: IFFALSE 54865
// exit ;
54863: GO 54939
// for i = 1 to mc_bases do
54865: LD_ADDR_VAR 0 2
54869: PUSH
54870: DOUBLE
54871: LD_INT 1
54873: DEC
54874: ST_TO_ADDR
54875: LD_EXP 43
54879: PUSH
54880: FOR_TO
54881: IFFALSE 54937
// if mc_bases [ i ] then
54883: LD_EXP 43
54887: PUSH
54888: LD_VAR 0 2
54892: ARRAY
54893: IFFALSE 54935
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54895: LD_ADDR_EXP 69
54899: PUSH
54900: LD_EXP 69
54904: PPUSH
54905: LD_VAR 0 2
54909: PPUSH
54910: LD_EXP 43
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PUSH
54921: LD_INT 1
54923: ARRAY
54924: PPUSH
54925: CALL_OW 255
54929: PPUSH
54930: CALL_OW 1
54934: ST_TO_ADDR
54935: GO 54880
54937: POP
54938: POP
// end ;
54939: LD_VAR 0 1
54943: RET
// every 0 0$03 trigger skirmish do
54944: LD_EXP 41
54948: IFFALSE 55102
54950: GO 54952
54952: DISABLE
// begin enable ;
54953: ENABLE
// MC_CheckBuildings ( ) ;
54954: CALL 59600 0 0
// MC_CheckPeopleLife ( ) ;
54958: CALL 59761 0 0
// RaiseSailEvent ( 100 ) ;
54962: LD_INT 100
54964: PPUSH
54965: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54969: LD_INT 103
54971: PPUSH
54972: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54976: LD_INT 104
54978: PPUSH
54979: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54983: LD_INT 105
54985: PPUSH
54986: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54990: LD_INT 106
54992: PPUSH
54993: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54997: LD_INT 107
54999: PPUSH
55000: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55004: LD_INT 108
55006: PPUSH
55007: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55011: LD_INT 109
55013: PPUSH
55014: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55018: LD_INT 110
55020: PPUSH
55021: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55025: LD_INT 111
55027: PPUSH
55028: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55032: LD_INT 112
55034: PPUSH
55035: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55039: LD_INT 113
55041: PPUSH
55042: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55046: LD_INT 120
55048: PPUSH
55049: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55053: LD_INT 121
55055: PPUSH
55056: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55060: LD_INT 122
55062: PPUSH
55063: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55067: LD_INT 123
55069: PPUSH
55070: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55074: LD_INT 124
55076: PPUSH
55077: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55081: LD_INT 125
55083: PPUSH
55084: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55088: LD_INT 126
55090: PPUSH
55091: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55095: LD_INT 200
55097: PPUSH
55098: CALL_OW 427
// end ;
55102: END
// on SailEvent ( event ) do begin if event < 100 then
55103: LD_VAR 0 1
55107: PUSH
55108: LD_INT 100
55110: LESS
55111: IFFALSE 55122
// CustomEvent ( event ) ;
55113: LD_VAR 0 1
55117: PPUSH
55118: CALL 603 0 1
// if event = 100 then
55122: LD_VAR 0 1
55126: PUSH
55127: LD_INT 100
55129: EQUAL
55130: IFFALSE 55136
// MC_ClassManager ( ) ;
55132: CALL 55528 0 0
// if event = 101 then
55136: LD_VAR 0 1
55140: PUSH
55141: LD_INT 101
55143: EQUAL
55144: IFFALSE 55150
// MC_RepairBuildings ( ) ;
55146: CALL 60346 0 0
// if event = 102 then
55150: LD_VAR 0 1
55154: PUSH
55155: LD_INT 102
55157: EQUAL
55158: IFFALSE 55164
// MC_Heal ( ) ;
55160: CALL 61281 0 0
// if event = 103 then
55164: LD_VAR 0 1
55168: PUSH
55169: LD_INT 103
55171: EQUAL
55172: IFFALSE 55178
// MC_Build ( ) ;
55174: CALL 61703 0 0
// if event = 104 then
55178: LD_VAR 0 1
55182: PUSH
55183: LD_INT 104
55185: EQUAL
55186: IFFALSE 55192
// MC_TurretWeapon ( ) ;
55188: CALL 63337 0 0
// if event = 105 then
55192: LD_VAR 0 1
55196: PUSH
55197: LD_INT 105
55199: EQUAL
55200: IFFALSE 55206
// MC_BuildUpgrade ( ) ;
55202: CALL 62888 0 0
// if event = 106 then
55206: LD_VAR 0 1
55210: PUSH
55211: LD_INT 106
55213: EQUAL
55214: IFFALSE 55220
// MC_PlantMines ( ) ;
55216: CALL 63767 0 0
// if event = 107 then
55220: LD_VAR 0 1
55224: PUSH
55225: LD_INT 107
55227: EQUAL
55228: IFFALSE 55234
// MC_CollectCrates ( ) ;
55230: CALL 64558 0 0
// if event = 108 then
55234: LD_VAR 0 1
55238: PUSH
55239: LD_INT 108
55241: EQUAL
55242: IFFALSE 55248
// MC_LinkRemoteControl ( ) ;
55244: CALL 66408 0 0
// if event = 109 then
55248: LD_VAR 0 1
55252: PUSH
55253: LD_INT 109
55255: EQUAL
55256: IFFALSE 55262
// MC_ProduceVehicle ( ) ;
55258: CALL 66589 0 0
// if event = 110 then
55262: LD_VAR 0 1
55266: PUSH
55267: LD_INT 110
55269: EQUAL
55270: IFFALSE 55276
// MC_SendAttack ( ) ;
55272: CALL 67055 0 0
// if event = 111 then
55276: LD_VAR 0 1
55280: PUSH
55281: LD_INT 111
55283: EQUAL
55284: IFFALSE 55290
// MC_Defend ( ) ;
55286: CALL 67163 0 0
// if event = 112 then
55290: LD_VAR 0 1
55294: PUSH
55295: LD_INT 112
55297: EQUAL
55298: IFFALSE 55304
// MC_Research ( ) ;
55300: CALL 68043 0 0
// if event = 113 then
55304: LD_VAR 0 1
55308: PUSH
55309: LD_INT 113
55311: EQUAL
55312: IFFALSE 55318
// MC_MinesTrigger ( ) ;
55314: CALL 69157 0 0
// if event = 120 then
55318: LD_VAR 0 1
55322: PUSH
55323: LD_INT 120
55325: EQUAL
55326: IFFALSE 55332
// MC_RepairVehicle ( ) ;
55328: CALL 69256 0 0
// if event = 121 then
55332: LD_VAR 0 1
55336: PUSH
55337: LD_INT 121
55339: EQUAL
55340: IFFALSE 55346
// MC_TameApe ( ) ;
55342: CALL 70025 0 0
// if event = 122 then
55346: LD_VAR 0 1
55350: PUSH
55351: LD_INT 122
55353: EQUAL
55354: IFFALSE 55360
// MC_ChangeApeClass ( ) ;
55356: CALL 70854 0 0
// if event = 123 then
55360: LD_VAR 0 1
55364: PUSH
55365: LD_INT 123
55367: EQUAL
55368: IFFALSE 55374
// MC_Bazooka ( ) ;
55370: CALL 71504 0 0
// if event = 124 then
55374: LD_VAR 0 1
55378: PUSH
55379: LD_INT 124
55381: EQUAL
55382: IFFALSE 55388
// MC_TeleportExit ( ) ;
55384: CALL 71702 0 0
// if event = 125 then
55388: LD_VAR 0 1
55392: PUSH
55393: LD_INT 125
55395: EQUAL
55396: IFFALSE 55402
// MC_Deposits ( ) ;
55398: CALL 72349 0 0
// if event = 126 then
55402: LD_VAR 0 1
55406: PUSH
55407: LD_INT 126
55409: EQUAL
55410: IFFALSE 55416
// MC_RemoteDriver ( ) ;
55412: CALL 72974 0 0
// if event = 200 then
55416: LD_VAR 0 1
55420: PUSH
55421: LD_INT 200
55423: EQUAL
55424: IFFALSE 55430
// MC_Idle ( ) ;
55426: CALL 74923 0 0
// end ;
55430: PPOPN 1
55432: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55433: LD_INT 0
55435: PPUSH
55436: PPUSH
// if not mc_bases [ base ] or not tag then
55437: LD_EXP 43
55441: PUSH
55442: LD_VAR 0 1
55446: ARRAY
55447: NOT
55448: PUSH
55449: LD_VAR 0 2
55453: NOT
55454: OR
55455: IFFALSE 55459
// exit ;
55457: GO 55523
// for i in mc_bases [ base ] union mc_ape [ base ] do
55459: LD_ADDR_VAR 0 4
55463: PUSH
55464: LD_EXP 43
55468: PUSH
55469: LD_VAR 0 1
55473: ARRAY
55474: PUSH
55475: LD_EXP 72
55479: PUSH
55480: LD_VAR 0 1
55484: ARRAY
55485: UNION
55486: PUSH
55487: FOR_IN
55488: IFFALSE 55521
// if GetTag ( i ) = tag then
55490: LD_VAR 0 4
55494: PPUSH
55495: CALL_OW 110
55499: PUSH
55500: LD_VAR 0 2
55504: EQUAL
55505: IFFALSE 55519
// SetTag ( i , 0 ) ;
55507: LD_VAR 0 4
55511: PPUSH
55512: LD_INT 0
55514: PPUSH
55515: CALL_OW 109
55519: GO 55487
55521: POP
55522: POP
// end ;
55523: LD_VAR 0 3
55527: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55528: LD_INT 0
55530: PPUSH
55531: PPUSH
55532: PPUSH
55533: PPUSH
55534: PPUSH
55535: PPUSH
55536: PPUSH
55537: PPUSH
// if not mc_bases then
55538: LD_EXP 43
55542: NOT
55543: IFFALSE 55547
// exit ;
55545: GO 56005
// for i = 1 to mc_bases do
55547: LD_ADDR_VAR 0 2
55551: PUSH
55552: DOUBLE
55553: LD_INT 1
55555: DEC
55556: ST_TO_ADDR
55557: LD_EXP 43
55561: PUSH
55562: FOR_TO
55563: IFFALSE 56003
// begin tmp := MC_ClassCheckReq ( i ) ;
55565: LD_ADDR_VAR 0 4
55569: PUSH
55570: LD_VAR 0 2
55574: PPUSH
55575: CALL 56010 0 1
55579: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55580: LD_ADDR_EXP 84
55584: PUSH
55585: LD_EXP 84
55589: PPUSH
55590: LD_VAR 0 2
55594: PPUSH
55595: LD_VAR 0 4
55599: PPUSH
55600: CALL_OW 1
55604: ST_TO_ADDR
// if not tmp then
55605: LD_VAR 0 4
55609: NOT
55610: IFFALSE 55614
// continue ;
55612: GO 55562
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55614: LD_ADDR_VAR 0 6
55618: PUSH
55619: LD_EXP 43
55623: PUSH
55624: LD_VAR 0 2
55628: ARRAY
55629: PPUSH
55630: LD_INT 2
55632: PUSH
55633: LD_INT 30
55635: PUSH
55636: LD_INT 4
55638: PUSH
55639: EMPTY
55640: LIST
55641: LIST
55642: PUSH
55643: LD_INT 30
55645: PUSH
55646: LD_INT 5
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: LIST
55657: PPUSH
55658: CALL_OW 72
55662: PUSH
55663: LD_EXP 43
55667: PUSH
55668: LD_VAR 0 2
55672: ARRAY
55673: PPUSH
55674: LD_INT 2
55676: PUSH
55677: LD_INT 30
55679: PUSH
55680: LD_INT 0
55682: PUSH
55683: EMPTY
55684: LIST
55685: LIST
55686: PUSH
55687: LD_INT 30
55689: PUSH
55690: LD_INT 1
55692: PUSH
55693: EMPTY
55694: LIST
55695: LIST
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: LIST
55701: PPUSH
55702: CALL_OW 72
55706: PUSH
55707: LD_EXP 43
55711: PUSH
55712: LD_VAR 0 2
55716: ARRAY
55717: PPUSH
55718: LD_INT 30
55720: PUSH
55721: LD_INT 3
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PPUSH
55728: CALL_OW 72
55732: PUSH
55733: LD_EXP 43
55737: PUSH
55738: LD_VAR 0 2
55742: ARRAY
55743: PPUSH
55744: LD_INT 2
55746: PUSH
55747: LD_INT 30
55749: PUSH
55750: LD_INT 6
55752: PUSH
55753: EMPTY
55754: LIST
55755: LIST
55756: PUSH
55757: LD_INT 30
55759: PUSH
55760: LD_INT 7
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PUSH
55767: LD_INT 30
55769: PUSH
55770: LD_INT 8
55772: PUSH
55773: EMPTY
55774: LIST
55775: LIST
55776: PUSH
55777: EMPTY
55778: LIST
55779: LIST
55780: LIST
55781: LIST
55782: PPUSH
55783: CALL_OW 72
55787: PUSH
55788: EMPTY
55789: LIST
55790: LIST
55791: LIST
55792: LIST
55793: ST_TO_ADDR
// for j = 1 to 4 do
55794: LD_ADDR_VAR 0 3
55798: PUSH
55799: DOUBLE
55800: LD_INT 1
55802: DEC
55803: ST_TO_ADDR
55804: LD_INT 4
55806: PUSH
55807: FOR_TO
55808: IFFALSE 55999
// begin if not tmp [ j ] then
55810: LD_VAR 0 4
55814: PUSH
55815: LD_VAR 0 3
55819: ARRAY
55820: NOT
55821: IFFALSE 55825
// continue ;
55823: GO 55807
// for p in tmp [ j ] do
55825: LD_ADDR_VAR 0 5
55829: PUSH
55830: LD_VAR 0 4
55834: PUSH
55835: LD_VAR 0 3
55839: ARRAY
55840: PUSH
55841: FOR_IN
55842: IFFALSE 55995
// begin if not b [ j ] then
55844: LD_VAR 0 6
55848: PUSH
55849: LD_VAR 0 3
55853: ARRAY
55854: NOT
55855: IFFALSE 55859
// break ;
55857: GO 55995
// e := 0 ;
55859: LD_ADDR_VAR 0 7
55863: PUSH
55864: LD_INT 0
55866: ST_TO_ADDR
// for k in b [ j ] do
55867: LD_ADDR_VAR 0 8
55871: PUSH
55872: LD_VAR 0 6
55876: PUSH
55877: LD_VAR 0 3
55881: ARRAY
55882: PUSH
55883: FOR_IN
55884: IFFALSE 55911
// if IsNotFull ( k ) then
55886: LD_VAR 0 8
55890: PPUSH
55891: CALL 12067 0 1
55895: IFFALSE 55909
// begin e := k ;
55897: LD_ADDR_VAR 0 7
55901: PUSH
55902: LD_VAR 0 8
55906: ST_TO_ADDR
// break ;
55907: GO 55911
// end ;
55909: GO 55883
55911: POP
55912: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55913: LD_VAR 0 7
55917: PUSH
55918: LD_VAR 0 5
55922: PPUSH
55923: LD_VAR 0 7
55927: PPUSH
55928: CALL 45963 0 2
55932: NOT
55933: AND
55934: IFFALSE 55993
// begin if IsInUnit ( p ) then
55936: LD_VAR 0 5
55940: PPUSH
55941: CALL_OW 310
55945: IFFALSE 55956
// ComExitBuilding ( p ) ;
55947: LD_VAR 0 5
55951: PPUSH
55952: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55956: LD_VAR 0 5
55960: PPUSH
55961: LD_VAR 0 7
55965: PPUSH
55966: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55970: LD_VAR 0 5
55974: PPUSH
55975: LD_VAR 0 3
55979: PPUSH
55980: CALL_OW 183
// AddComExitBuilding ( p ) ;
55984: LD_VAR 0 5
55988: PPUSH
55989: CALL_OW 182
// end ; end ;
55993: GO 55841
55995: POP
55996: POP
// end ;
55997: GO 55807
55999: POP
56000: POP
// end ;
56001: GO 55562
56003: POP
56004: POP
// end ;
56005: LD_VAR 0 1
56009: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56010: LD_INT 0
56012: PPUSH
56013: PPUSH
56014: PPUSH
56015: PPUSH
56016: PPUSH
56017: PPUSH
56018: PPUSH
56019: PPUSH
56020: PPUSH
56021: PPUSH
56022: PPUSH
56023: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56024: LD_VAR 0 1
56028: NOT
56029: PUSH
56030: LD_EXP 43
56034: PUSH
56035: LD_VAR 0 1
56039: ARRAY
56040: NOT
56041: OR
56042: PUSH
56043: LD_EXP 43
56047: PUSH
56048: LD_VAR 0 1
56052: ARRAY
56053: PPUSH
56054: LD_INT 2
56056: PUSH
56057: LD_INT 30
56059: PUSH
56060: LD_INT 0
56062: PUSH
56063: EMPTY
56064: LIST
56065: LIST
56066: PUSH
56067: LD_INT 30
56069: PUSH
56070: LD_INT 1
56072: PUSH
56073: EMPTY
56074: LIST
56075: LIST
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: LIST
56081: PPUSH
56082: CALL_OW 72
56086: NOT
56087: OR
56088: IFFALSE 56092
// exit ;
56090: GO 59595
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56092: LD_ADDR_VAR 0 4
56096: PUSH
56097: LD_EXP 43
56101: PUSH
56102: LD_VAR 0 1
56106: ARRAY
56107: PPUSH
56108: LD_INT 2
56110: PUSH
56111: LD_INT 25
56113: PUSH
56114: LD_INT 1
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: PUSH
56121: LD_INT 25
56123: PUSH
56124: LD_INT 2
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: PUSH
56131: LD_INT 25
56133: PUSH
56134: LD_INT 3
56136: PUSH
56137: EMPTY
56138: LIST
56139: LIST
56140: PUSH
56141: LD_INT 25
56143: PUSH
56144: LD_INT 4
56146: PUSH
56147: EMPTY
56148: LIST
56149: LIST
56150: PUSH
56151: LD_INT 25
56153: PUSH
56154: LD_INT 5
56156: PUSH
56157: EMPTY
56158: LIST
56159: LIST
56160: PUSH
56161: LD_INT 25
56163: PUSH
56164: LD_INT 8
56166: PUSH
56167: EMPTY
56168: LIST
56169: LIST
56170: PUSH
56171: LD_INT 25
56173: PUSH
56174: LD_INT 9
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: PUSH
56181: EMPTY
56182: LIST
56183: LIST
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: PPUSH
56191: CALL_OW 72
56195: ST_TO_ADDR
// if not tmp then
56196: LD_VAR 0 4
56200: NOT
56201: IFFALSE 56205
// exit ;
56203: GO 59595
// for i in tmp do
56205: LD_ADDR_VAR 0 3
56209: PUSH
56210: LD_VAR 0 4
56214: PUSH
56215: FOR_IN
56216: IFFALSE 56247
// if GetTag ( i ) then
56218: LD_VAR 0 3
56222: PPUSH
56223: CALL_OW 110
56227: IFFALSE 56245
// tmp := tmp diff i ;
56229: LD_ADDR_VAR 0 4
56233: PUSH
56234: LD_VAR 0 4
56238: PUSH
56239: LD_VAR 0 3
56243: DIFF
56244: ST_TO_ADDR
56245: GO 56215
56247: POP
56248: POP
// if not tmp then
56249: LD_VAR 0 4
56253: NOT
56254: IFFALSE 56258
// exit ;
56256: GO 59595
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56258: LD_ADDR_VAR 0 5
56262: PUSH
56263: LD_EXP 43
56267: PUSH
56268: LD_VAR 0 1
56272: ARRAY
56273: PPUSH
56274: LD_INT 2
56276: PUSH
56277: LD_INT 25
56279: PUSH
56280: LD_INT 1
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: PUSH
56287: LD_INT 25
56289: PUSH
56290: LD_INT 5
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: PUSH
56297: LD_INT 25
56299: PUSH
56300: LD_INT 8
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PUSH
56307: LD_INT 25
56309: PUSH
56310: LD_INT 9
56312: PUSH
56313: EMPTY
56314: LIST
56315: LIST
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: LIST
56321: LIST
56322: LIST
56323: PPUSH
56324: CALL_OW 72
56328: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56329: LD_ADDR_VAR 0 6
56333: PUSH
56334: LD_EXP 43
56338: PUSH
56339: LD_VAR 0 1
56343: ARRAY
56344: PPUSH
56345: LD_INT 25
56347: PUSH
56348: LD_INT 2
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: PPUSH
56355: CALL_OW 72
56359: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56360: LD_ADDR_VAR 0 7
56364: PUSH
56365: LD_EXP 43
56369: PUSH
56370: LD_VAR 0 1
56374: ARRAY
56375: PPUSH
56376: LD_INT 25
56378: PUSH
56379: LD_INT 3
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PPUSH
56386: CALL_OW 72
56390: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56391: LD_ADDR_VAR 0 8
56395: PUSH
56396: LD_EXP 43
56400: PUSH
56401: LD_VAR 0 1
56405: ARRAY
56406: PPUSH
56407: LD_INT 25
56409: PUSH
56410: LD_INT 4
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PUSH
56417: LD_INT 24
56419: PUSH
56420: LD_INT 251
56422: PUSH
56423: EMPTY
56424: LIST
56425: LIST
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: PPUSH
56431: CALL_OW 72
56435: ST_TO_ADDR
// if mc_is_defending [ base ] then
56436: LD_EXP 86
56440: PUSH
56441: LD_VAR 0 1
56445: ARRAY
56446: IFFALSE 56907
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56448: LD_ADDR_EXP 85
56452: PUSH
56453: LD_EXP 85
56457: PPUSH
56458: LD_VAR 0 1
56462: PPUSH
56463: LD_INT 4
56465: PPUSH
56466: CALL_OW 1
56470: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56471: LD_ADDR_VAR 0 12
56475: PUSH
56476: LD_EXP 43
56480: PUSH
56481: LD_VAR 0 1
56485: ARRAY
56486: PPUSH
56487: LD_INT 2
56489: PUSH
56490: LD_INT 30
56492: PUSH
56493: LD_INT 4
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: PUSH
56500: LD_INT 30
56502: PUSH
56503: LD_INT 5
56505: PUSH
56506: EMPTY
56507: LIST
56508: LIST
56509: PUSH
56510: EMPTY
56511: LIST
56512: LIST
56513: LIST
56514: PPUSH
56515: CALL_OW 72
56519: ST_TO_ADDR
// if not b then
56520: LD_VAR 0 12
56524: NOT
56525: IFFALSE 56529
// exit ;
56527: GO 59595
// p := [ ] ;
56529: LD_ADDR_VAR 0 11
56533: PUSH
56534: EMPTY
56535: ST_TO_ADDR
// if sci >= 2 then
56536: LD_VAR 0 8
56540: PUSH
56541: LD_INT 2
56543: GREATEREQUAL
56544: IFFALSE 56575
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56546: LD_ADDR_VAR 0 8
56550: PUSH
56551: LD_VAR 0 8
56555: PUSH
56556: LD_INT 1
56558: ARRAY
56559: PUSH
56560: LD_VAR 0 8
56564: PUSH
56565: LD_INT 2
56567: ARRAY
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: ST_TO_ADDR
56573: GO 56636
// if sci = 1 then
56575: LD_VAR 0 8
56579: PUSH
56580: LD_INT 1
56582: EQUAL
56583: IFFALSE 56604
// sci := [ sci [ 1 ] ] else
56585: LD_ADDR_VAR 0 8
56589: PUSH
56590: LD_VAR 0 8
56594: PUSH
56595: LD_INT 1
56597: ARRAY
56598: PUSH
56599: EMPTY
56600: LIST
56601: ST_TO_ADDR
56602: GO 56636
// if sci = 0 then
56604: LD_VAR 0 8
56608: PUSH
56609: LD_INT 0
56611: EQUAL
56612: IFFALSE 56636
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56614: LD_ADDR_VAR 0 11
56618: PUSH
56619: LD_VAR 0 4
56623: PPUSH
56624: LD_INT 4
56626: PPUSH
56627: CALL 45835 0 2
56631: PUSH
56632: LD_INT 1
56634: ARRAY
56635: ST_TO_ADDR
// if eng > 4 then
56636: LD_VAR 0 6
56640: PUSH
56641: LD_INT 4
56643: GREATER
56644: IFFALSE 56690
// for i = eng downto 4 do
56646: LD_ADDR_VAR 0 3
56650: PUSH
56651: DOUBLE
56652: LD_VAR 0 6
56656: INC
56657: ST_TO_ADDR
56658: LD_INT 4
56660: PUSH
56661: FOR_DOWNTO
56662: IFFALSE 56688
// eng := eng diff eng [ i ] ;
56664: LD_ADDR_VAR 0 6
56668: PUSH
56669: LD_VAR 0 6
56673: PUSH
56674: LD_VAR 0 6
56678: PUSH
56679: LD_VAR 0 3
56683: ARRAY
56684: DIFF
56685: ST_TO_ADDR
56686: GO 56661
56688: POP
56689: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56690: LD_ADDR_VAR 0 4
56694: PUSH
56695: LD_VAR 0 4
56699: PUSH
56700: LD_VAR 0 5
56704: PUSH
56705: LD_VAR 0 6
56709: UNION
56710: PUSH
56711: LD_VAR 0 7
56715: UNION
56716: PUSH
56717: LD_VAR 0 8
56721: UNION
56722: DIFF
56723: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56724: LD_ADDR_VAR 0 13
56728: PUSH
56729: LD_EXP 43
56733: PUSH
56734: LD_VAR 0 1
56738: ARRAY
56739: PPUSH
56740: LD_INT 2
56742: PUSH
56743: LD_INT 30
56745: PUSH
56746: LD_INT 32
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PUSH
56753: LD_INT 30
56755: PUSH
56756: LD_INT 31
56758: PUSH
56759: EMPTY
56760: LIST
56761: LIST
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: LIST
56767: PPUSH
56768: CALL_OW 72
56772: PUSH
56773: LD_EXP 43
56777: PUSH
56778: LD_VAR 0 1
56782: ARRAY
56783: PPUSH
56784: LD_INT 2
56786: PUSH
56787: LD_INT 30
56789: PUSH
56790: LD_INT 4
56792: PUSH
56793: EMPTY
56794: LIST
56795: LIST
56796: PUSH
56797: LD_INT 30
56799: PUSH
56800: LD_INT 5
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: PUSH
56807: EMPTY
56808: LIST
56809: LIST
56810: LIST
56811: PPUSH
56812: CALL_OW 72
56816: PUSH
56817: LD_INT 6
56819: MUL
56820: PLUS
56821: ST_TO_ADDR
// if bcount < tmp then
56822: LD_VAR 0 13
56826: PUSH
56827: LD_VAR 0 4
56831: LESS
56832: IFFALSE 56878
// for i = tmp downto bcount do
56834: LD_ADDR_VAR 0 3
56838: PUSH
56839: DOUBLE
56840: LD_VAR 0 4
56844: INC
56845: ST_TO_ADDR
56846: LD_VAR 0 13
56850: PUSH
56851: FOR_DOWNTO
56852: IFFALSE 56876
// tmp := Delete ( tmp , tmp ) ;
56854: LD_ADDR_VAR 0 4
56858: PUSH
56859: LD_VAR 0 4
56863: PPUSH
56864: LD_VAR 0 4
56868: PPUSH
56869: CALL_OW 3
56873: ST_TO_ADDR
56874: GO 56851
56876: POP
56877: POP
// result := [ tmp , 0 , 0 , p ] ;
56878: LD_ADDR_VAR 0 2
56882: PUSH
56883: LD_VAR 0 4
56887: PUSH
56888: LD_INT 0
56890: PUSH
56891: LD_INT 0
56893: PUSH
56894: LD_VAR 0 11
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: ST_TO_ADDR
// exit ;
56905: GO 59595
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56907: LD_EXP 43
56911: PUSH
56912: LD_VAR 0 1
56916: ARRAY
56917: PPUSH
56918: LD_INT 2
56920: PUSH
56921: LD_INT 30
56923: PUSH
56924: LD_INT 6
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: PUSH
56931: LD_INT 30
56933: PUSH
56934: LD_INT 7
56936: PUSH
56937: EMPTY
56938: LIST
56939: LIST
56940: PUSH
56941: LD_INT 30
56943: PUSH
56944: LD_INT 8
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: PUSH
56951: EMPTY
56952: LIST
56953: LIST
56954: LIST
56955: LIST
56956: PPUSH
56957: CALL_OW 72
56961: NOT
56962: PUSH
56963: LD_EXP 43
56967: PUSH
56968: LD_VAR 0 1
56972: ARRAY
56973: PPUSH
56974: LD_INT 30
56976: PUSH
56977: LD_INT 3
56979: PUSH
56980: EMPTY
56981: LIST
56982: LIST
56983: PPUSH
56984: CALL_OW 72
56988: NOT
56989: AND
56990: IFFALSE 57062
// begin if eng = tmp then
56992: LD_VAR 0 6
56996: PUSH
56997: LD_VAR 0 4
57001: EQUAL
57002: IFFALSE 57006
// exit ;
57004: GO 59595
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57006: LD_ADDR_EXP 85
57010: PUSH
57011: LD_EXP 85
57015: PPUSH
57016: LD_VAR 0 1
57020: PPUSH
57021: LD_INT 1
57023: PPUSH
57024: CALL_OW 1
57028: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57029: LD_ADDR_VAR 0 2
57033: PUSH
57034: LD_INT 0
57036: PUSH
57037: LD_VAR 0 4
57041: PUSH
57042: LD_VAR 0 6
57046: DIFF
57047: PUSH
57048: LD_INT 0
57050: PUSH
57051: LD_INT 0
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: LIST
57058: LIST
57059: ST_TO_ADDR
// exit ;
57060: GO 59595
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57062: LD_EXP 70
57066: PUSH
57067: LD_EXP 69
57071: PUSH
57072: LD_VAR 0 1
57076: ARRAY
57077: ARRAY
57078: PUSH
57079: LD_EXP 43
57083: PUSH
57084: LD_VAR 0 1
57088: ARRAY
57089: PPUSH
57090: LD_INT 2
57092: PUSH
57093: LD_INT 30
57095: PUSH
57096: LD_INT 6
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: PUSH
57103: LD_INT 30
57105: PUSH
57106: LD_INT 7
57108: PUSH
57109: EMPTY
57110: LIST
57111: LIST
57112: PUSH
57113: LD_INT 30
57115: PUSH
57116: LD_INT 8
57118: PUSH
57119: EMPTY
57120: LIST
57121: LIST
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: LIST
57127: LIST
57128: PPUSH
57129: CALL_OW 72
57133: AND
57134: PUSH
57135: LD_EXP 43
57139: PUSH
57140: LD_VAR 0 1
57144: ARRAY
57145: PPUSH
57146: LD_INT 30
57148: PUSH
57149: LD_INT 3
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PPUSH
57156: CALL_OW 72
57160: NOT
57161: AND
57162: IFFALSE 57376
// begin if sci >= 6 then
57164: LD_VAR 0 8
57168: PUSH
57169: LD_INT 6
57171: GREATEREQUAL
57172: IFFALSE 57176
// exit ;
57174: GO 59595
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57176: LD_ADDR_EXP 85
57180: PUSH
57181: LD_EXP 85
57185: PPUSH
57186: LD_VAR 0 1
57190: PPUSH
57191: LD_INT 2
57193: PPUSH
57194: CALL_OW 1
57198: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57199: LD_ADDR_VAR 0 9
57203: PUSH
57204: LD_VAR 0 4
57208: PUSH
57209: LD_VAR 0 8
57213: DIFF
57214: PPUSH
57215: LD_INT 4
57217: PPUSH
57218: CALL 45835 0 2
57222: ST_TO_ADDR
// p := [ ] ;
57223: LD_ADDR_VAR 0 11
57227: PUSH
57228: EMPTY
57229: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57230: LD_VAR 0 8
57234: PUSH
57235: LD_INT 6
57237: LESS
57238: PUSH
57239: LD_VAR 0 9
57243: PUSH
57244: LD_INT 6
57246: GREATER
57247: AND
57248: IFFALSE 57329
// begin for i = 1 to 6 - sci do
57250: LD_ADDR_VAR 0 3
57254: PUSH
57255: DOUBLE
57256: LD_INT 1
57258: DEC
57259: ST_TO_ADDR
57260: LD_INT 6
57262: PUSH
57263: LD_VAR 0 8
57267: MINUS
57268: PUSH
57269: FOR_TO
57270: IFFALSE 57325
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57272: LD_ADDR_VAR 0 11
57276: PUSH
57277: LD_VAR 0 11
57281: PPUSH
57282: LD_VAR 0 11
57286: PUSH
57287: LD_INT 1
57289: PLUS
57290: PPUSH
57291: LD_VAR 0 9
57295: PUSH
57296: LD_INT 1
57298: ARRAY
57299: PPUSH
57300: CALL_OW 2
57304: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57305: LD_ADDR_VAR 0 9
57309: PUSH
57310: LD_VAR 0 9
57314: PPUSH
57315: LD_INT 1
57317: PPUSH
57318: CALL_OW 3
57322: ST_TO_ADDR
// end ;
57323: GO 57269
57325: POP
57326: POP
// end else
57327: GO 57349
// if sort then
57329: LD_VAR 0 9
57333: IFFALSE 57349
// p := sort [ 1 ] ;
57335: LD_ADDR_VAR 0 11
57339: PUSH
57340: LD_VAR 0 9
57344: PUSH
57345: LD_INT 1
57347: ARRAY
57348: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57349: LD_ADDR_VAR 0 2
57353: PUSH
57354: LD_INT 0
57356: PUSH
57357: LD_INT 0
57359: PUSH
57360: LD_INT 0
57362: PUSH
57363: LD_VAR 0 11
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: LIST
57372: LIST
57373: ST_TO_ADDR
// exit ;
57374: GO 59595
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57376: LD_EXP 70
57380: PUSH
57381: LD_EXP 69
57385: PUSH
57386: LD_VAR 0 1
57390: ARRAY
57391: ARRAY
57392: PUSH
57393: LD_EXP 43
57397: PUSH
57398: LD_VAR 0 1
57402: ARRAY
57403: PPUSH
57404: LD_INT 2
57406: PUSH
57407: LD_INT 30
57409: PUSH
57410: LD_INT 6
57412: PUSH
57413: EMPTY
57414: LIST
57415: LIST
57416: PUSH
57417: LD_INT 30
57419: PUSH
57420: LD_INT 7
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 30
57429: PUSH
57430: LD_INT 8
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: LIST
57441: LIST
57442: PPUSH
57443: CALL_OW 72
57447: AND
57448: PUSH
57449: LD_EXP 43
57453: PUSH
57454: LD_VAR 0 1
57458: ARRAY
57459: PPUSH
57460: LD_INT 30
57462: PUSH
57463: LD_INT 3
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: PPUSH
57470: CALL_OW 72
57474: AND
57475: IFFALSE 58209
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57477: LD_ADDR_EXP 85
57481: PUSH
57482: LD_EXP 85
57486: PPUSH
57487: LD_VAR 0 1
57491: PPUSH
57492: LD_INT 3
57494: PPUSH
57495: CALL_OW 1
57499: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57500: LD_ADDR_VAR 0 2
57504: PUSH
57505: LD_INT 0
57507: PUSH
57508: LD_INT 0
57510: PUSH
57511: LD_INT 0
57513: PUSH
57514: LD_INT 0
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: LIST
57521: LIST
57522: ST_TO_ADDR
// if not eng then
57523: LD_VAR 0 6
57527: NOT
57528: IFFALSE 57591
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57530: LD_ADDR_VAR 0 11
57534: PUSH
57535: LD_VAR 0 4
57539: PPUSH
57540: LD_INT 2
57542: PPUSH
57543: CALL 45835 0 2
57547: PUSH
57548: LD_INT 1
57550: ARRAY
57551: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57552: LD_ADDR_VAR 0 2
57556: PUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: LD_INT 2
57564: PPUSH
57565: LD_VAR 0 11
57569: PPUSH
57570: CALL_OW 1
57574: ST_TO_ADDR
// tmp := tmp diff p ;
57575: LD_ADDR_VAR 0 4
57579: PUSH
57580: LD_VAR 0 4
57584: PUSH
57585: LD_VAR 0 11
57589: DIFF
57590: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57591: LD_VAR 0 4
57595: PUSH
57596: LD_VAR 0 8
57600: PUSH
57601: LD_INT 6
57603: LESS
57604: AND
57605: IFFALSE 57793
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57607: LD_ADDR_VAR 0 9
57611: PUSH
57612: LD_VAR 0 4
57616: PUSH
57617: LD_VAR 0 8
57621: PUSH
57622: LD_VAR 0 7
57626: UNION
57627: DIFF
57628: PPUSH
57629: LD_INT 4
57631: PPUSH
57632: CALL 45835 0 2
57636: ST_TO_ADDR
// p := [ ] ;
57637: LD_ADDR_VAR 0 11
57641: PUSH
57642: EMPTY
57643: ST_TO_ADDR
// if sort then
57644: LD_VAR 0 9
57648: IFFALSE 57764
// for i = 1 to 6 - sci do
57650: LD_ADDR_VAR 0 3
57654: PUSH
57655: DOUBLE
57656: LD_INT 1
57658: DEC
57659: ST_TO_ADDR
57660: LD_INT 6
57662: PUSH
57663: LD_VAR 0 8
57667: MINUS
57668: PUSH
57669: FOR_TO
57670: IFFALSE 57762
// begin if i = sort then
57672: LD_VAR 0 3
57676: PUSH
57677: LD_VAR 0 9
57681: EQUAL
57682: IFFALSE 57686
// break ;
57684: GO 57762
// if GetClass ( i ) = 4 then
57686: LD_VAR 0 3
57690: PPUSH
57691: CALL_OW 257
57695: PUSH
57696: LD_INT 4
57698: EQUAL
57699: IFFALSE 57703
// continue ;
57701: GO 57669
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57703: LD_ADDR_VAR 0 11
57707: PUSH
57708: LD_VAR 0 11
57712: PPUSH
57713: LD_VAR 0 11
57717: PUSH
57718: LD_INT 1
57720: PLUS
57721: PPUSH
57722: LD_VAR 0 9
57726: PUSH
57727: LD_VAR 0 3
57731: ARRAY
57732: PPUSH
57733: CALL_OW 2
57737: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57738: LD_ADDR_VAR 0 4
57742: PUSH
57743: LD_VAR 0 4
57747: PUSH
57748: LD_VAR 0 9
57752: PUSH
57753: LD_VAR 0 3
57757: ARRAY
57758: DIFF
57759: ST_TO_ADDR
// end ;
57760: GO 57669
57762: POP
57763: POP
// if p then
57764: LD_VAR 0 11
57768: IFFALSE 57793
// result := Replace ( result , 4 , p ) ;
57770: LD_ADDR_VAR 0 2
57774: PUSH
57775: LD_VAR 0 2
57779: PPUSH
57780: LD_INT 4
57782: PPUSH
57783: LD_VAR 0 11
57787: PPUSH
57788: CALL_OW 1
57792: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57793: LD_VAR 0 4
57797: PUSH
57798: LD_VAR 0 7
57802: PUSH
57803: LD_INT 6
57805: LESS
57806: AND
57807: IFFALSE 57995
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57809: LD_ADDR_VAR 0 9
57813: PUSH
57814: LD_VAR 0 4
57818: PUSH
57819: LD_VAR 0 8
57823: PUSH
57824: LD_VAR 0 7
57828: UNION
57829: DIFF
57830: PPUSH
57831: LD_INT 3
57833: PPUSH
57834: CALL 45835 0 2
57838: ST_TO_ADDR
// p := [ ] ;
57839: LD_ADDR_VAR 0 11
57843: PUSH
57844: EMPTY
57845: ST_TO_ADDR
// if sort then
57846: LD_VAR 0 9
57850: IFFALSE 57966
// for i = 1 to 6 - mech do
57852: LD_ADDR_VAR 0 3
57856: PUSH
57857: DOUBLE
57858: LD_INT 1
57860: DEC
57861: ST_TO_ADDR
57862: LD_INT 6
57864: PUSH
57865: LD_VAR 0 7
57869: MINUS
57870: PUSH
57871: FOR_TO
57872: IFFALSE 57964
// begin if i = sort then
57874: LD_VAR 0 3
57878: PUSH
57879: LD_VAR 0 9
57883: EQUAL
57884: IFFALSE 57888
// break ;
57886: GO 57964
// if GetClass ( i ) = 3 then
57888: LD_VAR 0 3
57892: PPUSH
57893: CALL_OW 257
57897: PUSH
57898: LD_INT 3
57900: EQUAL
57901: IFFALSE 57905
// continue ;
57903: GO 57871
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57905: LD_ADDR_VAR 0 11
57909: PUSH
57910: LD_VAR 0 11
57914: PPUSH
57915: LD_VAR 0 11
57919: PUSH
57920: LD_INT 1
57922: PLUS
57923: PPUSH
57924: LD_VAR 0 9
57928: PUSH
57929: LD_VAR 0 3
57933: ARRAY
57934: PPUSH
57935: CALL_OW 2
57939: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57940: LD_ADDR_VAR 0 4
57944: PUSH
57945: LD_VAR 0 4
57949: PUSH
57950: LD_VAR 0 9
57954: PUSH
57955: LD_VAR 0 3
57959: ARRAY
57960: DIFF
57961: ST_TO_ADDR
// end ;
57962: GO 57871
57964: POP
57965: POP
// if p then
57966: LD_VAR 0 11
57970: IFFALSE 57995
// result := Replace ( result , 3 , p ) ;
57972: LD_ADDR_VAR 0 2
57976: PUSH
57977: LD_VAR 0 2
57981: PPUSH
57982: LD_INT 3
57984: PPUSH
57985: LD_VAR 0 11
57989: PPUSH
57990: CALL_OW 1
57994: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57995: LD_VAR 0 4
57999: PUSH
58000: LD_INT 6
58002: GREATER
58003: PUSH
58004: LD_VAR 0 6
58008: PUSH
58009: LD_INT 6
58011: LESS
58012: AND
58013: IFFALSE 58207
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58015: LD_ADDR_VAR 0 9
58019: PUSH
58020: LD_VAR 0 4
58024: PUSH
58025: LD_VAR 0 8
58029: PUSH
58030: LD_VAR 0 7
58034: UNION
58035: PUSH
58036: LD_VAR 0 6
58040: UNION
58041: DIFF
58042: PPUSH
58043: LD_INT 2
58045: PPUSH
58046: CALL 45835 0 2
58050: ST_TO_ADDR
// p := [ ] ;
58051: LD_ADDR_VAR 0 11
58055: PUSH
58056: EMPTY
58057: ST_TO_ADDR
// if sort then
58058: LD_VAR 0 9
58062: IFFALSE 58178
// for i = 1 to 6 - eng do
58064: LD_ADDR_VAR 0 3
58068: PUSH
58069: DOUBLE
58070: LD_INT 1
58072: DEC
58073: ST_TO_ADDR
58074: LD_INT 6
58076: PUSH
58077: LD_VAR 0 6
58081: MINUS
58082: PUSH
58083: FOR_TO
58084: IFFALSE 58176
// begin if i = sort then
58086: LD_VAR 0 3
58090: PUSH
58091: LD_VAR 0 9
58095: EQUAL
58096: IFFALSE 58100
// break ;
58098: GO 58176
// if GetClass ( i ) = 2 then
58100: LD_VAR 0 3
58104: PPUSH
58105: CALL_OW 257
58109: PUSH
58110: LD_INT 2
58112: EQUAL
58113: IFFALSE 58117
// continue ;
58115: GO 58083
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58117: LD_ADDR_VAR 0 11
58121: PUSH
58122: LD_VAR 0 11
58126: PPUSH
58127: LD_VAR 0 11
58131: PUSH
58132: LD_INT 1
58134: PLUS
58135: PPUSH
58136: LD_VAR 0 9
58140: PUSH
58141: LD_VAR 0 3
58145: ARRAY
58146: PPUSH
58147: CALL_OW 2
58151: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58152: LD_ADDR_VAR 0 4
58156: PUSH
58157: LD_VAR 0 4
58161: PUSH
58162: LD_VAR 0 9
58166: PUSH
58167: LD_VAR 0 3
58171: ARRAY
58172: DIFF
58173: ST_TO_ADDR
// end ;
58174: GO 58083
58176: POP
58177: POP
// if p then
58178: LD_VAR 0 11
58182: IFFALSE 58207
// result := Replace ( result , 2 , p ) ;
58184: LD_ADDR_VAR 0 2
58188: PUSH
58189: LD_VAR 0 2
58193: PPUSH
58194: LD_INT 2
58196: PPUSH
58197: LD_VAR 0 11
58201: PPUSH
58202: CALL_OW 1
58206: ST_TO_ADDR
// end ; exit ;
58207: GO 59595
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58209: LD_EXP 70
58213: PUSH
58214: LD_EXP 69
58218: PUSH
58219: LD_VAR 0 1
58223: ARRAY
58224: ARRAY
58225: NOT
58226: PUSH
58227: LD_EXP 43
58231: PUSH
58232: LD_VAR 0 1
58236: ARRAY
58237: PPUSH
58238: LD_INT 30
58240: PUSH
58241: LD_INT 3
58243: PUSH
58244: EMPTY
58245: LIST
58246: LIST
58247: PPUSH
58248: CALL_OW 72
58252: AND
58253: PUSH
58254: LD_EXP 48
58258: PUSH
58259: LD_VAR 0 1
58263: ARRAY
58264: AND
58265: IFFALSE 58873
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58267: LD_ADDR_EXP 85
58271: PUSH
58272: LD_EXP 85
58276: PPUSH
58277: LD_VAR 0 1
58281: PPUSH
58282: LD_INT 5
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58290: LD_ADDR_VAR 0 2
58294: PUSH
58295: LD_INT 0
58297: PUSH
58298: LD_INT 0
58300: PUSH
58301: LD_INT 0
58303: PUSH
58304: LD_INT 0
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: LIST
58311: LIST
58312: ST_TO_ADDR
// if sci > 1 then
58313: LD_VAR 0 8
58317: PUSH
58318: LD_INT 1
58320: GREATER
58321: IFFALSE 58349
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58323: LD_ADDR_VAR 0 4
58327: PUSH
58328: LD_VAR 0 4
58332: PUSH
58333: LD_VAR 0 8
58337: PUSH
58338: LD_VAR 0 8
58342: PUSH
58343: LD_INT 1
58345: ARRAY
58346: DIFF
58347: DIFF
58348: ST_TO_ADDR
// if tmp and not sci then
58349: LD_VAR 0 4
58353: PUSH
58354: LD_VAR 0 8
58358: NOT
58359: AND
58360: IFFALSE 58429
// begin sort := SortBySkill ( tmp , 4 ) ;
58362: LD_ADDR_VAR 0 9
58366: PUSH
58367: LD_VAR 0 4
58371: PPUSH
58372: LD_INT 4
58374: PPUSH
58375: CALL 45835 0 2
58379: ST_TO_ADDR
// if sort then
58380: LD_VAR 0 9
58384: IFFALSE 58400
// p := sort [ 1 ] ;
58386: LD_ADDR_VAR 0 11
58390: PUSH
58391: LD_VAR 0 9
58395: PUSH
58396: LD_INT 1
58398: ARRAY
58399: ST_TO_ADDR
// if p then
58400: LD_VAR 0 11
58404: IFFALSE 58429
// result := Replace ( result , 4 , p ) ;
58406: LD_ADDR_VAR 0 2
58410: PUSH
58411: LD_VAR 0 2
58415: PPUSH
58416: LD_INT 4
58418: PPUSH
58419: LD_VAR 0 11
58423: PPUSH
58424: CALL_OW 1
58428: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58429: LD_ADDR_VAR 0 4
58433: PUSH
58434: LD_VAR 0 4
58438: PUSH
58439: LD_VAR 0 7
58443: DIFF
58444: ST_TO_ADDR
// if tmp and mech < 6 then
58445: LD_VAR 0 4
58449: PUSH
58450: LD_VAR 0 7
58454: PUSH
58455: LD_INT 6
58457: LESS
58458: AND
58459: IFFALSE 58647
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58461: LD_ADDR_VAR 0 9
58465: PUSH
58466: LD_VAR 0 4
58470: PUSH
58471: LD_VAR 0 8
58475: PUSH
58476: LD_VAR 0 7
58480: UNION
58481: DIFF
58482: PPUSH
58483: LD_INT 3
58485: PPUSH
58486: CALL 45835 0 2
58490: ST_TO_ADDR
// p := [ ] ;
58491: LD_ADDR_VAR 0 11
58495: PUSH
58496: EMPTY
58497: ST_TO_ADDR
// if sort then
58498: LD_VAR 0 9
58502: IFFALSE 58618
// for i = 1 to 6 - mech do
58504: LD_ADDR_VAR 0 3
58508: PUSH
58509: DOUBLE
58510: LD_INT 1
58512: DEC
58513: ST_TO_ADDR
58514: LD_INT 6
58516: PUSH
58517: LD_VAR 0 7
58521: MINUS
58522: PUSH
58523: FOR_TO
58524: IFFALSE 58616
// begin if i = sort then
58526: LD_VAR 0 3
58530: PUSH
58531: LD_VAR 0 9
58535: EQUAL
58536: IFFALSE 58540
// break ;
58538: GO 58616
// if GetClass ( i ) = 3 then
58540: LD_VAR 0 3
58544: PPUSH
58545: CALL_OW 257
58549: PUSH
58550: LD_INT 3
58552: EQUAL
58553: IFFALSE 58557
// continue ;
58555: GO 58523
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58557: LD_ADDR_VAR 0 11
58561: PUSH
58562: LD_VAR 0 11
58566: PPUSH
58567: LD_VAR 0 11
58571: PUSH
58572: LD_INT 1
58574: PLUS
58575: PPUSH
58576: LD_VAR 0 9
58580: PUSH
58581: LD_VAR 0 3
58585: ARRAY
58586: PPUSH
58587: CALL_OW 2
58591: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58592: LD_ADDR_VAR 0 4
58596: PUSH
58597: LD_VAR 0 4
58601: PUSH
58602: LD_VAR 0 9
58606: PUSH
58607: LD_VAR 0 3
58611: ARRAY
58612: DIFF
58613: ST_TO_ADDR
// end ;
58614: GO 58523
58616: POP
58617: POP
// if p then
58618: LD_VAR 0 11
58622: IFFALSE 58647
// result := Replace ( result , 3 , p ) ;
58624: LD_ADDR_VAR 0 2
58628: PUSH
58629: LD_VAR 0 2
58633: PPUSH
58634: LD_INT 3
58636: PPUSH
58637: LD_VAR 0 11
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58647: LD_ADDR_VAR 0 4
58651: PUSH
58652: LD_VAR 0 4
58656: PUSH
58657: LD_VAR 0 6
58661: DIFF
58662: ST_TO_ADDR
// if tmp and eng < 6 then
58663: LD_VAR 0 4
58667: PUSH
58668: LD_VAR 0 6
58672: PUSH
58673: LD_INT 6
58675: LESS
58676: AND
58677: IFFALSE 58871
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58679: LD_ADDR_VAR 0 9
58683: PUSH
58684: LD_VAR 0 4
58688: PUSH
58689: LD_VAR 0 8
58693: PUSH
58694: LD_VAR 0 7
58698: UNION
58699: PUSH
58700: LD_VAR 0 6
58704: UNION
58705: DIFF
58706: PPUSH
58707: LD_INT 2
58709: PPUSH
58710: CALL 45835 0 2
58714: ST_TO_ADDR
// p := [ ] ;
58715: LD_ADDR_VAR 0 11
58719: PUSH
58720: EMPTY
58721: ST_TO_ADDR
// if sort then
58722: LD_VAR 0 9
58726: IFFALSE 58842
// for i = 1 to 6 - eng do
58728: LD_ADDR_VAR 0 3
58732: PUSH
58733: DOUBLE
58734: LD_INT 1
58736: DEC
58737: ST_TO_ADDR
58738: LD_INT 6
58740: PUSH
58741: LD_VAR 0 6
58745: MINUS
58746: PUSH
58747: FOR_TO
58748: IFFALSE 58840
// begin if i = sort then
58750: LD_VAR 0 3
58754: PUSH
58755: LD_VAR 0 9
58759: EQUAL
58760: IFFALSE 58764
// break ;
58762: GO 58840
// if GetClass ( i ) = 2 then
58764: LD_VAR 0 3
58768: PPUSH
58769: CALL_OW 257
58773: PUSH
58774: LD_INT 2
58776: EQUAL
58777: IFFALSE 58781
// continue ;
58779: GO 58747
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58781: LD_ADDR_VAR 0 11
58785: PUSH
58786: LD_VAR 0 11
58790: PPUSH
58791: LD_VAR 0 11
58795: PUSH
58796: LD_INT 1
58798: PLUS
58799: PPUSH
58800: LD_VAR 0 9
58804: PUSH
58805: LD_VAR 0 3
58809: ARRAY
58810: PPUSH
58811: CALL_OW 2
58815: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58816: LD_ADDR_VAR 0 4
58820: PUSH
58821: LD_VAR 0 4
58825: PUSH
58826: LD_VAR 0 9
58830: PUSH
58831: LD_VAR 0 3
58835: ARRAY
58836: DIFF
58837: ST_TO_ADDR
// end ;
58838: GO 58747
58840: POP
58841: POP
// if p then
58842: LD_VAR 0 11
58846: IFFALSE 58871
// result := Replace ( result , 2 , p ) ;
58848: LD_ADDR_VAR 0 2
58852: PUSH
58853: LD_VAR 0 2
58857: PPUSH
58858: LD_INT 2
58860: PPUSH
58861: LD_VAR 0 11
58865: PPUSH
58866: CALL_OW 1
58870: ST_TO_ADDR
// end ; exit ;
58871: GO 59595
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58873: LD_EXP 70
58877: PUSH
58878: LD_EXP 69
58882: PUSH
58883: LD_VAR 0 1
58887: ARRAY
58888: ARRAY
58889: NOT
58890: PUSH
58891: LD_EXP 43
58895: PUSH
58896: LD_VAR 0 1
58900: ARRAY
58901: PPUSH
58902: LD_INT 30
58904: PUSH
58905: LD_INT 3
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PPUSH
58912: CALL_OW 72
58916: AND
58917: PUSH
58918: LD_EXP 48
58922: PUSH
58923: LD_VAR 0 1
58927: ARRAY
58928: NOT
58929: AND
58930: IFFALSE 59595
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58932: LD_ADDR_EXP 85
58936: PUSH
58937: LD_EXP 85
58941: PPUSH
58942: LD_VAR 0 1
58946: PPUSH
58947: LD_INT 6
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58955: LD_ADDR_VAR 0 2
58959: PUSH
58960: LD_INT 0
58962: PUSH
58963: LD_INT 0
58965: PUSH
58966: LD_INT 0
58968: PUSH
58969: LD_INT 0
58971: PUSH
58972: EMPTY
58973: LIST
58974: LIST
58975: LIST
58976: LIST
58977: ST_TO_ADDR
// if sci >= 1 then
58978: LD_VAR 0 8
58982: PUSH
58983: LD_INT 1
58985: GREATEREQUAL
58986: IFFALSE 59008
// tmp := tmp diff sci [ 1 ] ;
58988: LD_ADDR_VAR 0 4
58992: PUSH
58993: LD_VAR 0 4
58997: PUSH
58998: LD_VAR 0 8
59002: PUSH
59003: LD_INT 1
59005: ARRAY
59006: DIFF
59007: ST_TO_ADDR
// if tmp and not sci then
59008: LD_VAR 0 4
59012: PUSH
59013: LD_VAR 0 8
59017: NOT
59018: AND
59019: IFFALSE 59088
// begin sort := SortBySkill ( tmp , 4 ) ;
59021: LD_ADDR_VAR 0 9
59025: PUSH
59026: LD_VAR 0 4
59030: PPUSH
59031: LD_INT 4
59033: PPUSH
59034: CALL 45835 0 2
59038: ST_TO_ADDR
// if sort then
59039: LD_VAR 0 9
59043: IFFALSE 59059
// p := sort [ 1 ] ;
59045: LD_ADDR_VAR 0 11
59049: PUSH
59050: LD_VAR 0 9
59054: PUSH
59055: LD_INT 1
59057: ARRAY
59058: ST_TO_ADDR
// if p then
59059: LD_VAR 0 11
59063: IFFALSE 59088
// result := Replace ( result , 4 , p ) ;
59065: LD_ADDR_VAR 0 2
59069: PUSH
59070: LD_VAR 0 2
59074: PPUSH
59075: LD_INT 4
59077: PPUSH
59078: LD_VAR 0 11
59082: PPUSH
59083: CALL_OW 1
59087: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59088: LD_ADDR_VAR 0 4
59092: PUSH
59093: LD_VAR 0 4
59097: PUSH
59098: LD_VAR 0 7
59102: DIFF
59103: ST_TO_ADDR
// if tmp and mech < 6 then
59104: LD_VAR 0 4
59108: PUSH
59109: LD_VAR 0 7
59113: PUSH
59114: LD_INT 6
59116: LESS
59117: AND
59118: IFFALSE 59300
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59120: LD_ADDR_VAR 0 9
59124: PUSH
59125: LD_VAR 0 4
59129: PUSH
59130: LD_VAR 0 7
59134: DIFF
59135: PPUSH
59136: LD_INT 3
59138: PPUSH
59139: CALL 45835 0 2
59143: ST_TO_ADDR
// p := [ ] ;
59144: LD_ADDR_VAR 0 11
59148: PUSH
59149: EMPTY
59150: ST_TO_ADDR
// if sort then
59151: LD_VAR 0 9
59155: IFFALSE 59271
// for i = 1 to 6 - mech do
59157: LD_ADDR_VAR 0 3
59161: PUSH
59162: DOUBLE
59163: LD_INT 1
59165: DEC
59166: ST_TO_ADDR
59167: LD_INT 6
59169: PUSH
59170: LD_VAR 0 7
59174: MINUS
59175: PUSH
59176: FOR_TO
59177: IFFALSE 59269
// begin if i = sort then
59179: LD_VAR 0 3
59183: PUSH
59184: LD_VAR 0 9
59188: EQUAL
59189: IFFALSE 59193
// break ;
59191: GO 59269
// if GetClass ( i ) = 3 then
59193: LD_VAR 0 3
59197: PPUSH
59198: CALL_OW 257
59202: PUSH
59203: LD_INT 3
59205: EQUAL
59206: IFFALSE 59210
// continue ;
59208: GO 59176
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59210: LD_ADDR_VAR 0 11
59214: PUSH
59215: LD_VAR 0 11
59219: PPUSH
59220: LD_VAR 0 11
59224: PUSH
59225: LD_INT 1
59227: PLUS
59228: PPUSH
59229: LD_VAR 0 9
59233: PUSH
59234: LD_VAR 0 3
59238: ARRAY
59239: PPUSH
59240: CALL_OW 2
59244: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 4
59254: PUSH
59255: LD_VAR 0 9
59259: PUSH
59260: LD_VAR 0 3
59264: ARRAY
59265: DIFF
59266: ST_TO_ADDR
// end ;
59267: GO 59176
59269: POP
59270: POP
// if p then
59271: LD_VAR 0 11
59275: IFFALSE 59300
// result := Replace ( result , 3 , p ) ;
59277: LD_ADDR_VAR 0 2
59281: PUSH
59282: LD_VAR 0 2
59286: PPUSH
59287: LD_INT 3
59289: PPUSH
59290: LD_VAR 0 11
59294: PPUSH
59295: CALL_OW 1
59299: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59300: LD_ADDR_VAR 0 4
59304: PUSH
59305: LD_VAR 0 4
59309: PUSH
59310: LD_VAR 0 6
59314: DIFF
59315: ST_TO_ADDR
// if tmp and eng < 4 then
59316: LD_VAR 0 4
59320: PUSH
59321: LD_VAR 0 6
59325: PUSH
59326: LD_INT 4
59328: LESS
59329: AND
59330: IFFALSE 59520
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59332: LD_ADDR_VAR 0 9
59336: PUSH
59337: LD_VAR 0 4
59341: PUSH
59342: LD_VAR 0 7
59346: PUSH
59347: LD_VAR 0 6
59351: UNION
59352: DIFF
59353: PPUSH
59354: LD_INT 2
59356: PPUSH
59357: CALL 45835 0 2
59361: ST_TO_ADDR
// p := [ ] ;
59362: LD_ADDR_VAR 0 11
59366: PUSH
59367: EMPTY
59368: ST_TO_ADDR
// if sort then
59369: LD_VAR 0 9
59373: IFFALSE 59489
// for i = 1 to 4 - eng do
59375: LD_ADDR_VAR 0 3
59379: PUSH
59380: DOUBLE
59381: LD_INT 1
59383: DEC
59384: ST_TO_ADDR
59385: LD_INT 4
59387: PUSH
59388: LD_VAR 0 6
59392: MINUS
59393: PUSH
59394: FOR_TO
59395: IFFALSE 59487
// begin if i = sort then
59397: LD_VAR 0 3
59401: PUSH
59402: LD_VAR 0 9
59406: EQUAL
59407: IFFALSE 59411
// break ;
59409: GO 59487
// if GetClass ( i ) = 2 then
59411: LD_VAR 0 3
59415: PPUSH
59416: CALL_OW 257
59420: PUSH
59421: LD_INT 2
59423: EQUAL
59424: IFFALSE 59428
// continue ;
59426: GO 59394
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59428: LD_ADDR_VAR 0 11
59432: PUSH
59433: LD_VAR 0 11
59437: PPUSH
59438: LD_VAR 0 11
59442: PUSH
59443: LD_INT 1
59445: PLUS
59446: PPUSH
59447: LD_VAR 0 9
59451: PUSH
59452: LD_VAR 0 3
59456: ARRAY
59457: PPUSH
59458: CALL_OW 2
59462: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59463: LD_ADDR_VAR 0 4
59467: PUSH
59468: LD_VAR 0 4
59472: PUSH
59473: LD_VAR 0 9
59477: PUSH
59478: LD_VAR 0 3
59482: ARRAY
59483: DIFF
59484: ST_TO_ADDR
// end ;
59485: GO 59394
59487: POP
59488: POP
// if p then
59489: LD_VAR 0 11
59493: IFFALSE 59518
// result := Replace ( result , 2 , p ) ;
59495: LD_ADDR_VAR 0 2
59499: PUSH
59500: LD_VAR 0 2
59504: PPUSH
59505: LD_INT 2
59507: PPUSH
59508: LD_VAR 0 11
59512: PPUSH
59513: CALL_OW 1
59517: ST_TO_ADDR
// end else
59518: GO 59564
// for i = eng downto 5 do
59520: LD_ADDR_VAR 0 3
59524: PUSH
59525: DOUBLE
59526: LD_VAR 0 6
59530: INC
59531: ST_TO_ADDR
59532: LD_INT 5
59534: PUSH
59535: FOR_DOWNTO
59536: IFFALSE 59562
// tmp := tmp union eng [ i ] ;
59538: LD_ADDR_VAR 0 4
59542: PUSH
59543: LD_VAR 0 4
59547: PUSH
59548: LD_VAR 0 6
59552: PUSH
59553: LD_VAR 0 3
59557: ARRAY
59558: UNION
59559: ST_TO_ADDR
59560: GO 59535
59562: POP
59563: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59564: LD_ADDR_VAR 0 2
59568: PUSH
59569: LD_VAR 0 2
59573: PPUSH
59574: LD_INT 1
59576: PPUSH
59577: LD_VAR 0 4
59581: PUSH
59582: LD_VAR 0 5
59586: DIFF
59587: PPUSH
59588: CALL_OW 1
59592: ST_TO_ADDR
// exit ;
59593: GO 59595
// end ; end ;
59595: LD_VAR 0 2
59599: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59600: LD_INT 0
59602: PPUSH
59603: PPUSH
59604: PPUSH
// if not mc_bases then
59605: LD_EXP 43
59609: NOT
59610: IFFALSE 59614
// exit ;
59612: GO 59756
// for i = 1 to mc_bases do
59614: LD_ADDR_VAR 0 2
59618: PUSH
59619: DOUBLE
59620: LD_INT 1
59622: DEC
59623: ST_TO_ADDR
59624: LD_EXP 43
59628: PUSH
59629: FOR_TO
59630: IFFALSE 59747
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59632: LD_ADDR_VAR 0 3
59636: PUSH
59637: LD_EXP 43
59641: PUSH
59642: LD_VAR 0 2
59646: ARRAY
59647: PPUSH
59648: LD_INT 21
59650: PUSH
59651: LD_INT 3
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: LD_INT 3
59660: PUSH
59661: LD_INT 2
59663: PUSH
59664: LD_INT 30
59666: PUSH
59667: LD_INT 29
59669: PUSH
59670: EMPTY
59671: LIST
59672: LIST
59673: PUSH
59674: LD_INT 30
59676: PUSH
59677: LD_INT 30
59679: PUSH
59680: EMPTY
59681: LIST
59682: LIST
59683: PUSH
59684: EMPTY
59685: LIST
59686: LIST
59687: LIST
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PUSH
59693: LD_INT 3
59695: PUSH
59696: LD_INT 24
59698: PUSH
59699: LD_INT 1000
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: LIST
59714: PPUSH
59715: CALL_OW 72
59719: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59720: LD_ADDR_EXP 44
59724: PUSH
59725: LD_EXP 44
59729: PPUSH
59730: LD_VAR 0 2
59734: PPUSH
59735: LD_VAR 0 3
59739: PPUSH
59740: CALL_OW 1
59744: ST_TO_ADDR
// end ;
59745: GO 59629
59747: POP
59748: POP
// RaiseSailEvent ( 101 ) ;
59749: LD_INT 101
59751: PPUSH
59752: CALL_OW 427
// end ;
59756: LD_VAR 0 1
59760: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59761: LD_INT 0
59763: PPUSH
59764: PPUSH
59765: PPUSH
59766: PPUSH
59767: PPUSH
59768: PPUSH
59769: PPUSH
// if not mc_bases then
59770: LD_EXP 43
59774: NOT
59775: IFFALSE 59779
// exit ;
59777: GO 60341
// for i = 1 to mc_bases do
59779: LD_ADDR_VAR 0 2
59783: PUSH
59784: DOUBLE
59785: LD_INT 1
59787: DEC
59788: ST_TO_ADDR
59789: LD_EXP 43
59793: PUSH
59794: FOR_TO
59795: IFFALSE 60332
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59797: LD_ADDR_VAR 0 5
59801: PUSH
59802: LD_EXP 43
59806: PUSH
59807: LD_VAR 0 2
59811: ARRAY
59812: PUSH
59813: LD_EXP 72
59817: PUSH
59818: LD_VAR 0 2
59822: ARRAY
59823: UNION
59824: PPUSH
59825: LD_INT 21
59827: PUSH
59828: LD_INT 1
59830: PUSH
59831: EMPTY
59832: LIST
59833: LIST
59834: PUSH
59835: LD_INT 1
59837: PUSH
59838: LD_INT 3
59840: PUSH
59841: LD_INT 54
59843: PUSH
59844: EMPTY
59845: LIST
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PUSH
59851: LD_INT 3
59853: PUSH
59854: LD_INT 24
59856: PUSH
59857: LD_INT 1000
59859: PUSH
59860: EMPTY
59861: LIST
59862: LIST
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: LIST
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PPUSH
59877: CALL_OW 72
59881: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59882: LD_ADDR_VAR 0 6
59886: PUSH
59887: LD_EXP 43
59891: PUSH
59892: LD_VAR 0 2
59896: ARRAY
59897: PPUSH
59898: LD_INT 21
59900: PUSH
59901: LD_INT 1
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: PUSH
59908: LD_INT 1
59910: PUSH
59911: LD_INT 3
59913: PUSH
59914: LD_INT 54
59916: PUSH
59917: EMPTY
59918: LIST
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PUSH
59924: LD_INT 3
59926: PUSH
59927: LD_INT 24
59929: PUSH
59930: LD_INT 250
59932: PUSH
59933: EMPTY
59934: LIST
59935: LIST
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: LIST
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PPUSH
59950: CALL_OW 72
59954: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59955: LD_ADDR_VAR 0 7
59959: PUSH
59960: LD_VAR 0 5
59964: PUSH
59965: LD_VAR 0 6
59969: DIFF
59970: ST_TO_ADDR
// if not need_heal_1 then
59971: LD_VAR 0 6
59975: NOT
59976: IFFALSE 60009
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59978: LD_ADDR_EXP 46
59982: PUSH
59983: LD_EXP 46
59987: PPUSH
59988: LD_VAR 0 2
59992: PUSH
59993: LD_INT 1
59995: PUSH
59996: EMPTY
59997: LIST
59998: LIST
59999: PPUSH
60000: EMPTY
60001: PPUSH
60002: CALL 14988 0 3
60006: ST_TO_ADDR
60007: GO 60079
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60009: LD_ADDR_EXP 46
60013: PUSH
60014: LD_EXP 46
60018: PPUSH
60019: LD_VAR 0 2
60023: PUSH
60024: LD_INT 1
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PPUSH
60031: LD_EXP 46
60035: PUSH
60036: LD_VAR 0 2
60040: ARRAY
60041: PUSH
60042: LD_INT 1
60044: ARRAY
60045: PPUSH
60046: LD_INT 3
60048: PUSH
60049: LD_INT 24
60051: PUSH
60052: LD_INT 1000
60054: PUSH
60055: EMPTY
60056: LIST
60057: LIST
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PPUSH
60063: CALL_OW 72
60067: PUSH
60068: LD_VAR 0 6
60072: UNION
60073: PPUSH
60074: CALL 14988 0 3
60078: ST_TO_ADDR
// if not need_heal_2 then
60079: LD_VAR 0 7
60083: NOT
60084: IFFALSE 60117
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60086: LD_ADDR_EXP 46
60090: PUSH
60091: LD_EXP 46
60095: PPUSH
60096: LD_VAR 0 2
60100: PUSH
60101: LD_INT 2
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: PPUSH
60108: EMPTY
60109: PPUSH
60110: CALL 14988 0 3
60114: ST_TO_ADDR
60115: GO 60149
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60117: LD_ADDR_EXP 46
60121: PUSH
60122: LD_EXP 46
60126: PPUSH
60127: LD_VAR 0 2
60131: PUSH
60132: LD_INT 2
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PPUSH
60139: LD_VAR 0 7
60143: PPUSH
60144: CALL 14988 0 3
60148: ST_TO_ADDR
// if need_heal_2 then
60149: LD_VAR 0 7
60153: IFFALSE 60314
// for j in need_heal_2 do
60155: LD_ADDR_VAR 0 3
60159: PUSH
60160: LD_VAR 0 7
60164: PUSH
60165: FOR_IN
60166: IFFALSE 60312
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60168: LD_ADDR_VAR 0 5
60172: PUSH
60173: LD_EXP 43
60177: PUSH
60178: LD_VAR 0 2
60182: ARRAY
60183: PPUSH
60184: LD_INT 2
60186: PUSH
60187: LD_INT 30
60189: PUSH
60190: LD_INT 6
60192: PUSH
60193: EMPTY
60194: LIST
60195: LIST
60196: PUSH
60197: LD_INT 30
60199: PUSH
60200: LD_INT 7
60202: PUSH
60203: EMPTY
60204: LIST
60205: LIST
60206: PUSH
60207: LD_INT 30
60209: PUSH
60210: LD_INT 8
60212: PUSH
60213: EMPTY
60214: LIST
60215: LIST
60216: PUSH
60217: LD_INT 30
60219: PUSH
60220: LD_INT 0
60222: PUSH
60223: EMPTY
60224: LIST
60225: LIST
60226: PUSH
60227: LD_INT 30
60229: PUSH
60230: LD_INT 1
60232: PUSH
60233: EMPTY
60234: LIST
60235: LIST
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: LIST
60241: LIST
60242: LIST
60243: LIST
60244: PPUSH
60245: CALL_OW 72
60249: ST_TO_ADDR
// if tmp then
60250: LD_VAR 0 5
60254: IFFALSE 60310
// begin k := NearestUnitToUnit ( tmp , j ) ;
60256: LD_ADDR_VAR 0 4
60260: PUSH
60261: LD_VAR 0 5
60265: PPUSH
60266: LD_VAR 0 3
60270: PPUSH
60271: CALL_OW 74
60275: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60276: LD_VAR 0 3
60280: PPUSH
60281: LD_VAR 0 4
60285: PPUSH
60286: CALL_OW 296
60290: PUSH
60291: LD_INT 5
60293: GREATER
60294: IFFALSE 60310
// ComMoveToNearbyEntrance ( j , k ) ;
60296: LD_VAR 0 3
60300: PPUSH
60301: LD_VAR 0 4
60305: PPUSH
60306: CALL 48196 0 2
// end ; end ;
60310: GO 60165
60312: POP
60313: POP
// if not need_heal_1 and not need_heal_2 then
60314: LD_VAR 0 6
60318: NOT
60319: PUSH
60320: LD_VAR 0 7
60324: NOT
60325: AND
60326: IFFALSE 60330
// continue ;
60328: GO 59794
// end ;
60330: GO 59794
60332: POP
60333: POP
// RaiseSailEvent ( 102 ) ;
60334: LD_INT 102
60336: PPUSH
60337: CALL_OW 427
// end ;
60341: LD_VAR 0 1
60345: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60346: LD_INT 0
60348: PPUSH
60349: PPUSH
60350: PPUSH
60351: PPUSH
60352: PPUSH
60353: PPUSH
60354: PPUSH
60355: PPUSH
// if not mc_bases then
60356: LD_EXP 43
60360: NOT
60361: IFFALSE 60365
// exit ;
60363: GO 61276
// for i = 1 to mc_bases do
60365: LD_ADDR_VAR 0 2
60369: PUSH
60370: DOUBLE
60371: LD_INT 1
60373: DEC
60374: ST_TO_ADDR
60375: LD_EXP 43
60379: PUSH
60380: FOR_TO
60381: IFFALSE 61274
// begin if not mc_building_need_repair [ i ] then
60383: LD_EXP 44
60387: PUSH
60388: LD_VAR 0 2
60392: ARRAY
60393: NOT
60394: IFFALSE 60579
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60396: LD_ADDR_VAR 0 6
60400: PUSH
60401: LD_EXP 62
60405: PUSH
60406: LD_VAR 0 2
60410: ARRAY
60411: PPUSH
60412: LD_INT 3
60414: PUSH
60415: LD_INT 24
60417: PUSH
60418: LD_INT 1000
60420: PUSH
60421: EMPTY
60422: LIST
60423: LIST
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: PUSH
60429: LD_INT 2
60431: PUSH
60432: LD_INT 34
60434: PUSH
60435: LD_INT 13
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: PUSH
60442: LD_INT 34
60444: PUSH
60445: LD_INT 52
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: PUSH
60452: LD_INT 34
60454: PUSH
60455: LD_INT 88
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: LIST
60466: LIST
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PPUSH
60472: CALL_OW 72
60476: ST_TO_ADDR
// if cranes then
60477: LD_VAR 0 6
60481: IFFALSE 60543
// for j in cranes do
60483: LD_ADDR_VAR 0 3
60487: PUSH
60488: LD_VAR 0 6
60492: PUSH
60493: FOR_IN
60494: IFFALSE 60541
// if not IsInArea ( j , mc_parking [ i ] ) then
60496: LD_VAR 0 3
60500: PPUSH
60501: LD_EXP 67
60505: PUSH
60506: LD_VAR 0 2
60510: ARRAY
60511: PPUSH
60512: CALL_OW 308
60516: NOT
60517: IFFALSE 60539
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60519: LD_VAR 0 3
60523: PPUSH
60524: LD_EXP 67
60528: PUSH
60529: LD_VAR 0 2
60533: ARRAY
60534: PPUSH
60535: CALL_OW 113
60539: GO 60493
60541: POP
60542: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60543: LD_ADDR_EXP 45
60547: PUSH
60548: LD_EXP 45
60552: PPUSH
60553: LD_VAR 0 2
60557: PPUSH
60558: EMPTY
60559: PPUSH
60560: CALL_OW 1
60564: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60565: LD_VAR 0 2
60569: PPUSH
60570: LD_INT 101
60572: PPUSH
60573: CALL 55433 0 2
// continue ;
60577: GO 60380
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60579: LD_ADDR_EXP 49
60583: PUSH
60584: LD_EXP 49
60588: PPUSH
60589: LD_VAR 0 2
60593: PPUSH
60594: EMPTY
60595: PPUSH
60596: CALL_OW 1
60600: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60601: LD_VAR 0 2
60605: PPUSH
60606: LD_INT 103
60608: PPUSH
60609: CALL 55433 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60613: LD_ADDR_VAR 0 5
60617: PUSH
60618: LD_EXP 43
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PUSH
60629: LD_EXP 72
60633: PUSH
60634: LD_VAR 0 2
60638: ARRAY
60639: UNION
60640: PPUSH
60641: LD_INT 2
60643: PUSH
60644: LD_INT 25
60646: PUSH
60647: LD_INT 2
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: PUSH
60654: LD_INT 25
60656: PUSH
60657: LD_INT 16
60659: PUSH
60660: EMPTY
60661: LIST
60662: LIST
60663: PUSH
60664: EMPTY
60665: LIST
60666: LIST
60667: LIST
60668: PUSH
60669: EMPTY
60670: LIST
60671: PPUSH
60672: CALL_OW 72
60676: ST_TO_ADDR
// if mc_need_heal [ i ] then
60677: LD_EXP 46
60681: PUSH
60682: LD_VAR 0 2
60686: ARRAY
60687: IFFALSE 60731
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60689: LD_ADDR_VAR 0 5
60693: PUSH
60694: LD_VAR 0 5
60698: PUSH
60699: LD_EXP 46
60703: PUSH
60704: LD_VAR 0 2
60708: ARRAY
60709: PUSH
60710: LD_INT 1
60712: ARRAY
60713: PUSH
60714: LD_EXP 46
60718: PUSH
60719: LD_VAR 0 2
60723: ARRAY
60724: PUSH
60725: LD_INT 2
60727: ARRAY
60728: UNION
60729: DIFF
60730: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60731: LD_ADDR_VAR 0 6
60735: PUSH
60736: LD_EXP 62
60740: PUSH
60741: LD_VAR 0 2
60745: ARRAY
60746: PPUSH
60747: LD_INT 2
60749: PUSH
60750: LD_INT 34
60752: PUSH
60753: LD_INT 13
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PUSH
60760: LD_INT 34
60762: PUSH
60763: LD_INT 52
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: PUSH
60770: LD_INT 34
60772: PUSH
60773: LD_INT 88
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: PPUSH
60786: CALL_OW 72
60790: ST_TO_ADDR
// if cranes then
60791: LD_VAR 0 6
60795: IFFALSE 60963
// begin for j in cranes do
60797: LD_ADDR_VAR 0 3
60801: PUSH
60802: LD_VAR 0 6
60806: PUSH
60807: FOR_IN
60808: IFFALSE 60961
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60810: LD_VAR 0 3
60814: PPUSH
60815: CALL_OW 256
60819: PUSH
60820: LD_INT 1000
60822: EQUAL
60823: PUSH
60824: LD_VAR 0 3
60828: PPUSH
60829: CALL_OW 314
60833: NOT
60834: AND
60835: IFFALSE 60901
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
60837: LD_ADDR_VAR 0 8
60841: PUSH
60842: LD_EXP 44
60846: PUSH
60847: LD_VAR 0 2
60851: ARRAY
60852: PPUSH
60853: LD_VAR 0 3
60857: PPUSH
60858: CALL_OW 74
60862: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60863: LD_VAR 0 8
60867: PPUSH
60868: LD_INT 16
60870: PPUSH
60871: CALL 17585 0 2
60875: PUSH
60876: LD_INT 4
60878: ARRAY
60879: PUSH
60880: LD_INT 10
60882: LESS
60883: IFFALSE 60899
// ComRepairBuilding ( j , to_repair ) ;
60885: LD_VAR 0 3
60889: PPUSH
60890: LD_VAR 0 8
60894: PPUSH
60895: CALL_OW 130
// end else
60899: GO 60959
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60901: LD_VAR 0 3
60905: PPUSH
60906: CALL_OW 256
60910: PUSH
60911: LD_INT 500
60913: LESS
60914: PUSH
60915: LD_VAR 0 3
60919: PPUSH
60920: LD_EXP 67
60924: PUSH
60925: LD_VAR 0 2
60929: ARRAY
60930: PPUSH
60931: CALL_OW 308
60935: NOT
60936: AND
60937: IFFALSE 60959
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60939: LD_VAR 0 3
60943: PPUSH
60944: LD_EXP 67
60948: PUSH
60949: LD_VAR 0 2
60953: ARRAY
60954: PPUSH
60955: CALL_OW 113
// end ;
60959: GO 60807
60961: POP
60962: POP
// end ; if tmp > 3 then
60963: LD_VAR 0 5
60967: PUSH
60968: LD_INT 3
60970: GREATER
60971: IFFALSE 60991
// tmp := ShrinkArray ( tmp , 4 ) ;
60973: LD_ADDR_VAR 0 5
60977: PUSH
60978: LD_VAR 0 5
60982: PPUSH
60983: LD_INT 4
60985: PPUSH
60986: CALL 47634 0 2
60990: ST_TO_ADDR
// if not tmp then
60991: LD_VAR 0 5
60995: NOT
60996: IFFALSE 61000
// continue ;
60998: GO 60380
// for j in tmp do
61000: LD_ADDR_VAR 0 3
61004: PUSH
61005: LD_VAR 0 5
61009: PUSH
61010: FOR_IN
61011: IFFALSE 61270
// begin if IsInUnit ( j ) then
61013: LD_VAR 0 3
61017: PPUSH
61018: CALL_OW 310
61022: IFFALSE 61033
// ComExitBuilding ( j ) ;
61024: LD_VAR 0 3
61028: PPUSH
61029: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61033: LD_VAR 0 3
61037: PUSH
61038: LD_EXP 45
61042: PUSH
61043: LD_VAR 0 2
61047: ARRAY
61048: IN
61049: NOT
61050: IFFALSE 61108
// begin SetTag ( j , 101 ) ;
61052: LD_VAR 0 3
61056: PPUSH
61057: LD_INT 101
61059: PPUSH
61060: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61064: LD_ADDR_EXP 45
61068: PUSH
61069: LD_EXP 45
61073: PPUSH
61074: LD_VAR 0 2
61078: PUSH
61079: LD_EXP 45
61083: PUSH
61084: LD_VAR 0 2
61088: ARRAY
61089: PUSH
61090: LD_INT 1
61092: PLUS
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PPUSH
61098: LD_VAR 0 3
61102: PPUSH
61103: CALL 14988 0 3
61107: ST_TO_ADDR
// end ; wait ( 1 ) ;
61108: LD_INT 1
61110: PPUSH
61111: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61115: LD_ADDR_VAR 0 7
61119: PUSH
61120: LD_EXP 44
61124: PUSH
61125: LD_VAR 0 2
61129: ARRAY
61130: ST_TO_ADDR
// if mc_scan [ i ] then
61131: LD_EXP 66
61135: PUSH
61136: LD_VAR 0 2
61140: ARRAY
61141: IFFALSE 61203
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61143: LD_ADDR_VAR 0 7
61147: PUSH
61148: LD_EXP 44
61152: PUSH
61153: LD_VAR 0 2
61157: ARRAY
61158: PPUSH
61159: LD_INT 3
61161: PUSH
61162: LD_INT 30
61164: PUSH
61165: LD_INT 32
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: PUSH
61172: LD_INT 30
61174: PUSH
61175: LD_INT 33
61177: PUSH
61178: EMPTY
61179: LIST
61180: LIST
61181: PUSH
61182: LD_INT 30
61184: PUSH
61185: LD_INT 31
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: LIST
61196: LIST
61197: PPUSH
61198: CALL_OW 72
61202: ST_TO_ADDR
// if not to_repair_tmp then
61203: LD_VAR 0 7
61207: NOT
61208: IFFALSE 61212
// continue ;
61210: GO 61010
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61212: LD_ADDR_VAR 0 8
61216: PUSH
61217: LD_VAR 0 7
61221: PPUSH
61222: LD_VAR 0 3
61226: PPUSH
61227: CALL_OW 74
61231: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61232: LD_VAR 0 8
61236: PPUSH
61237: LD_INT 16
61239: PPUSH
61240: CALL 17585 0 2
61244: PUSH
61245: LD_INT 4
61247: ARRAY
61248: PUSH
61249: LD_INT 14
61251: LESS
61252: IFFALSE 61268
// ComRepairBuilding ( j , to_repair ) ;
61254: LD_VAR 0 3
61258: PPUSH
61259: LD_VAR 0 8
61263: PPUSH
61264: CALL_OW 130
// end ;
61268: GO 61010
61270: POP
61271: POP
// end ;
61272: GO 60380
61274: POP
61275: POP
// end ;
61276: LD_VAR 0 1
61280: RET
// export function MC_Heal ; var i , j , tmp ; begin
61281: LD_INT 0
61283: PPUSH
61284: PPUSH
61285: PPUSH
61286: PPUSH
// if not mc_bases then
61287: LD_EXP 43
61291: NOT
61292: IFFALSE 61296
// exit ;
61294: GO 61698
// for i = 1 to mc_bases do
61296: LD_ADDR_VAR 0 2
61300: PUSH
61301: DOUBLE
61302: LD_INT 1
61304: DEC
61305: ST_TO_ADDR
61306: LD_EXP 43
61310: PUSH
61311: FOR_TO
61312: IFFALSE 61696
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61314: LD_EXP 46
61318: PUSH
61319: LD_VAR 0 2
61323: ARRAY
61324: PUSH
61325: LD_INT 1
61327: ARRAY
61328: NOT
61329: PUSH
61330: LD_EXP 46
61334: PUSH
61335: LD_VAR 0 2
61339: ARRAY
61340: PUSH
61341: LD_INT 2
61343: ARRAY
61344: NOT
61345: AND
61346: IFFALSE 61384
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61348: LD_ADDR_EXP 47
61352: PUSH
61353: LD_EXP 47
61357: PPUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: EMPTY
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61370: LD_VAR 0 2
61374: PPUSH
61375: LD_INT 102
61377: PPUSH
61378: CALL 55433 0 2
// continue ;
61382: GO 61311
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61384: LD_ADDR_VAR 0 4
61388: PUSH
61389: LD_EXP 43
61393: PUSH
61394: LD_VAR 0 2
61398: ARRAY
61399: PPUSH
61400: LD_INT 25
61402: PUSH
61403: LD_INT 4
61405: PUSH
61406: EMPTY
61407: LIST
61408: LIST
61409: PPUSH
61410: CALL_OW 72
61414: ST_TO_ADDR
// if not tmp then
61415: LD_VAR 0 4
61419: NOT
61420: IFFALSE 61424
// continue ;
61422: GO 61311
// if mc_taming [ i ] then
61424: LD_EXP 74
61428: PUSH
61429: LD_VAR 0 2
61433: ARRAY
61434: IFFALSE 61458
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61436: LD_ADDR_EXP 74
61440: PUSH
61441: LD_EXP 74
61445: PPUSH
61446: LD_VAR 0 2
61450: PPUSH
61451: EMPTY
61452: PPUSH
61453: CALL_OW 1
61457: ST_TO_ADDR
// for j in tmp do
61458: LD_ADDR_VAR 0 3
61462: PUSH
61463: LD_VAR 0 4
61467: PUSH
61468: FOR_IN
61469: IFFALSE 61692
// begin if IsInUnit ( j ) then
61471: LD_VAR 0 3
61475: PPUSH
61476: CALL_OW 310
61480: IFFALSE 61491
// ComExitBuilding ( j ) ;
61482: LD_VAR 0 3
61486: PPUSH
61487: CALL_OW 122
// if not j in mc_healers [ i ] then
61491: LD_VAR 0 3
61495: PUSH
61496: LD_EXP 47
61500: PUSH
61501: LD_VAR 0 2
61505: ARRAY
61506: IN
61507: NOT
61508: IFFALSE 61554
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61510: LD_ADDR_EXP 47
61514: PUSH
61515: LD_EXP 47
61519: PPUSH
61520: LD_VAR 0 2
61524: PUSH
61525: LD_EXP 47
61529: PUSH
61530: LD_VAR 0 2
61534: ARRAY
61535: PUSH
61536: LD_INT 1
61538: PLUS
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: PPUSH
61544: LD_VAR 0 3
61548: PPUSH
61549: CALL 14988 0 3
61553: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61554: LD_VAR 0 3
61558: PPUSH
61559: CALL_OW 110
61563: PUSH
61564: LD_INT 102
61566: NONEQUAL
61567: IFFALSE 61581
// SetTag ( j , 102 ) ;
61569: LD_VAR 0 3
61573: PPUSH
61574: LD_INT 102
61576: PPUSH
61577: CALL_OW 109
// Wait ( 3 ) ;
61581: LD_INT 3
61583: PPUSH
61584: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61588: LD_EXP 46
61592: PUSH
61593: LD_VAR 0 2
61597: ARRAY
61598: PUSH
61599: LD_INT 1
61601: ARRAY
61602: IFFALSE 61634
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61604: LD_VAR 0 3
61608: PPUSH
61609: LD_EXP 46
61613: PUSH
61614: LD_VAR 0 2
61618: ARRAY
61619: PUSH
61620: LD_INT 1
61622: ARRAY
61623: PUSH
61624: LD_INT 1
61626: ARRAY
61627: PPUSH
61628: CALL_OW 128
61632: GO 61690
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61634: LD_VAR 0 3
61638: PPUSH
61639: CALL_OW 314
61643: NOT
61644: PUSH
61645: LD_EXP 46
61649: PUSH
61650: LD_VAR 0 2
61654: ARRAY
61655: PUSH
61656: LD_INT 2
61658: ARRAY
61659: AND
61660: IFFALSE 61690
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61662: LD_VAR 0 3
61666: PPUSH
61667: LD_EXP 46
61671: PUSH
61672: LD_VAR 0 2
61676: ARRAY
61677: PUSH
61678: LD_INT 2
61680: ARRAY
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: PPUSH
61686: CALL_OW 128
// end ;
61690: GO 61468
61692: POP
61693: POP
// end ;
61694: GO 61311
61696: POP
61697: POP
// end ;
61698: LD_VAR 0 1
61702: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
61703: LD_INT 0
61705: PPUSH
61706: PPUSH
61707: PPUSH
61708: PPUSH
61709: PPUSH
61710: PPUSH
// if not mc_bases then
61711: LD_EXP 43
61715: NOT
61716: IFFALSE 61720
// exit ;
61718: GO 62883
// for i = 1 to mc_bases do
61720: LD_ADDR_VAR 0 2
61724: PUSH
61725: DOUBLE
61726: LD_INT 1
61728: DEC
61729: ST_TO_ADDR
61730: LD_EXP 43
61734: PUSH
61735: FOR_TO
61736: IFFALSE 62881
// begin if mc_scan [ i ] then
61738: LD_EXP 66
61742: PUSH
61743: LD_VAR 0 2
61747: ARRAY
61748: IFFALSE 61752
// continue ;
61750: GO 61735
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61752: LD_EXP 48
61756: PUSH
61757: LD_VAR 0 2
61761: ARRAY
61762: NOT
61763: PUSH
61764: LD_EXP 50
61768: PUSH
61769: LD_VAR 0 2
61773: ARRAY
61774: NOT
61775: AND
61776: PUSH
61777: LD_EXP 49
61781: PUSH
61782: LD_VAR 0 2
61786: ARRAY
61787: AND
61788: IFFALSE 61826
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61790: LD_ADDR_EXP 49
61794: PUSH
61795: LD_EXP 49
61799: PPUSH
61800: LD_VAR 0 2
61804: PPUSH
61805: EMPTY
61806: PPUSH
61807: CALL_OW 1
61811: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61812: LD_VAR 0 2
61816: PPUSH
61817: LD_INT 103
61819: PPUSH
61820: CALL 55433 0 2
// continue ;
61824: GO 61735
// end ; if mc_construct_list [ i ] then
61826: LD_EXP 50
61830: PUSH
61831: LD_VAR 0 2
61835: ARRAY
61836: IFFALSE 62056
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61838: LD_ADDR_VAR 0 5
61842: PUSH
61843: LD_EXP 43
61847: PUSH
61848: LD_VAR 0 2
61852: ARRAY
61853: PPUSH
61854: LD_INT 25
61856: PUSH
61857: LD_INT 2
61859: PUSH
61860: EMPTY
61861: LIST
61862: LIST
61863: PPUSH
61864: CALL_OW 72
61868: PUSH
61869: LD_EXP 45
61873: PUSH
61874: LD_VAR 0 2
61878: ARRAY
61879: DIFF
61880: ST_TO_ADDR
// if not tmp then
61881: LD_VAR 0 5
61885: NOT
61886: IFFALSE 61890
// continue ;
61888: GO 61735
// for j in tmp do
61890: LD_ADDR_VAR 0 3
61894: PUSH
61895: LD_VAR 0 5
61899: PUSH
61900: FOR_IN
61901: IFFALSE 62052
// begin if not mc_builders [ i ] then
61903: LD_EXP 49
61907: PUSH
61908: LD_VAR 0 2
61912: ARRAY
61913: NOT
61914: IFFALSE 61972
// begin SetTag ( j , 103 ) ;
61916: LD_VAR 0 3
61920: PPUSH
61921: LD_INT 103
61923: PPUSH
61924: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61928: LD_ADDR_EXP 49
61932: PUSH
61933: LD_EXP 49
61937: PPUSH
61938: LD_VAR 0 2
61942: PUSH
61943: LD_EXP 49
61947: PUSH
61948: LD_VAR 0 2
61952: ARRAY
61953: PUSH
61954: LD_INT 1
61956: PLUS
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: LD_VAR 0 3
61966: PPUSH
61967: CALL 14988 0 3
61971: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61972: LD_VAR 0 3
61976: PPUSH
61977: CALL_OW 310
61981: IFFALSE 61992
// ComExitBuilding ( j ) ;
61983: LD_VAR 0 3
61987: PPUSH
61988: CALL_OW 122
// wait ( 3 ) ;
61992: LD_INT 3
61994: PPUSH
61995: CALL_OW 67
// if not mc_construct_list [ i ] then
61999: LD_EXP 50
62003: PUSH
62004: LD_VAR 0 2
62008: ARRAY
62009: NOT
62010: IFFALSE 62014
// break ;
62012: GO 62052
// if not HasTask ( j ) then
62014: LD_VAR 0 3
62018: PPUSH
62019: CALL_OW 314
62023: NOT
62024: IFFALSE 62050
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62026: LD_VAR 0 3
62030: PPUSH
62031: LD_EXP 50
62035: PUSH
62036: LD_VAR 0 2
62040: ARRAY
62041: PUSH
62042: LD_INT 1
62044: ARRAY
62045: PPUSH
62046: CALL 17849 0 2
// end ;
62050: GO 61900
62052: POP
62053: POP
// end else
62054: GO 62879
// if mc_build_list [ i ] then
62056: LD_EXP 48
62060: PUSH
62061: LD_VAR 0 2
62065: ARRAY
62066: IFFALSE 62879
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62068: LD_EXP 48
62072: PUSH
62073: LD_VAR 0 2
62077: ARRAY
62078: PUSH
62079: LD_INT 1
62081: ARRAY
62082: PUSH
62083: LD_INT 1
62085: ARRAY
62086: PPUSH
62087: CALL 17673 0 1
62091: PUSH
62092: LD_EXP 43
62096: PUSH
62097: LD_VAR 0 2
62101: ARRAY
62102: PPUSH
62103: LD_INT 2
62105: PUSH
62106: LD_INT 30
62108: PUSH
62109: LD_INT 2
62111: PUSH
62112: EMPTY
62113: LIST
62114: LIST
62115: PUSH
62116: LD_INT 30
62118: PUSH
62119: LD_INT 3
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: PUSH
62126: EMPTY
62127: LIST
62128: LIST
62129: LIST
62130: PPUSH
62131: CALL_OW 72
62135: NOT
62136: AND
62137: IFFALSE 62242
// begin for j = 1 to mc_build_list [ i ] do
62139: LD_ADDR_VAR 0 3
62143: PUSH
62144: DOUBLE
62145: LD_INT 1
62147: DEC
62148: ST_TO_ADDR
62149: LD_EXP 48
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: PUSH
62160: FOR_TO
62161: IFFALSE 62240
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62163: LD_EXP 48
62167: PUSH
62168: LD_VAR 0 2
62172: ARRAY
62173: PUSH
62174: LD_VAR 0 3
62178: ARRAY
62179: PUSH
62180: LD_INT 1
62182: ARRAY
62183: PUSH
62184: LD_INT 2
62186: EQUAL
62187: IFFALSE 62238
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62189: LD_ADDR_EXP 48
62193: PUSH
62194: LD_EXP 48
62198: PPUSH
62199: LD_VAR 0 2
62203: PPUSH
62204: LD_EXP 48
62208: PUSH
62209: LD_VAR 0 2
62213: ARRAY
62214: PPUSH
62215: LD_VAR 0 3
62219: PPUSH
62220: LD_INT 1
62222: PPUSH
62223: LD_INT 0
62225: PPUSH
62226: CALL 14406 0 4
62230: PPUSH
62231: CALL_OW 1
62235: ST_TO_ADDR
// break ;
62236: GO 62240
// end ;
62238: GO 62160
62240: POP
62241: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62242: LD_ADDR_VAR 0 6
62246: PUSH
62247: LD_EXP 43
62251: PUSH
62252: LD_VAR 0 2
62256: ARRAY
62257: PPUSH
62258: LD_INT 2
62260: PUSH
62261: LD_INT 30
62263: PUSH
62264: LD_INT 0
62266: PUSH
62267: EMPTY
62268: LIST
62269: LIST
62270: PUSH
62271: LD_INT 30
62273: PUSH
62274: LD_INT 1
62276: PUSH
62277: EMPTY
62278: LIST
62279: LIST
62280: PUSH
62281: EMPTY
62282: LIST
62283: LIST
62284: LIST
62285: PPUSH
62286: CALL_OW 72
62290: ST_TO_ADDR
// for k := 1 to depot do
62291: LD_ADDR_VAR 0 4
62295: PUSH
62296: DOUBLE
62297: LD_INT 1
62299: DEC
62300: ST_TO_ADDR
62301: LD_VAR 0 6
62305: PUSH
62306: FOR_TO
62307: IFFALSE 62877
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62309: LD_EXP 48
62313: PUSH
62314: LD_VAR 0 2
62318: ARRAY
62319: PUSH
62320: LD_INT 1
62322: ARRAY
62323: PUSH
62324: LD_INT 1
62326: ARRAY
62327: PUSH
62328: LD_INT 0
62330: EQUAL
62331: PUSH
62332: LD_VAR 0 6
62336: PUSH
62337: LD_VAR 0 4
62341: ARRAY
62342: PPUSH
62343: LD_EXP 48
62347: PUSH
62348: LD_VAR 0 2
62352: ARRAY
62353: PUSH
62354: LD_INT 1
62356: ARRAY
62357: PUSH
62358: LD_INT 1
62360: ARRAY
62361: PPUSH
62362: LD_EXP 48
62366: PUSH
62367: LD_VAR 0 2
62371: ARRAY
62372: PUSH
62373: LD_INT 1
62375: ARRAY
62376: PUSH
62377: LD_INT 2
62379: ARRAY
62380: PPUSH
62381: LD_EXP 48
62385: PUSH
62386: LD_VAR 0 2
62390: ARRAY
62391: PUSH
62392: LD_INT 1
62394: ARRAY
62395: PUSH
62396: LD_INT 3
62398: ARRAY
62399: PPUSH
62400: LD_EXP 48
62404: PUSH
62405: LD_VAR 0 2
62409: ARRAY
62410: PUSH
62411: LD_INT 1
62413: ARRAY
62414: PUSH
62415: LD_INT 4
62417: ARRAY
62418: PPUSH
62419: CALL 23085 0 5
62423: OR
62424: IFFALSE 62705
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62426: LD_ADDR_VAR 0 5
62430: PUSH
62431: LD_EXP 43
62435: PUSH
62436: LD_VAR 0 2
62440: ARRAY
62441: PPUSH
62442: LD_INT 25
62444: PUSH
62445: LD_INT 2
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: PPUSH
62452: CALL_OW 72
62456: PUSH
62457: LD_EXP 45
62461: PUSH
62462: LD_VAR 0 2
62466: ARRAY
62467: DIFF
62468: ST_TO_ADDR
// if not tmp then
62469: LD_VAR 0 5
62473: NOT
62474: IFFALSE 62478
// continue ;
62476: GO 62306
// for j in tmp do
62478: LD_ADDR_VAR 0 3
62482: PUSH
62483: LD_VAR 0 5
62487: PUSH
62488: FOR_IN
62489: IFFALSE 62701
// begin if not mc_builders [ i ] then
62491: LD_EXP 49
62495: PUSH
62496: LD_VAR 0 2
62500: ARRAY
62501: NOT
62502: IFFALSE 62560
// begin SetTag ( j , 103 ) ;
62504: LD_VAR 0 3
62508: PPUSH
62509: LD_INT 103
62511: PPUSH
62512: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62516: LD_ADDR_EXP 49
62520: PUSH
62521: LD_EXP 49
62525: PPUSH
62526: LD_VAR 0 2
62530: PUSH
62531: LD_EXP 49
62535: PUSH
62536: LD_VAR 0 2
62540: ARRAY
62541: PUSH
62542: LD_INT 1
62544: PLUS
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: PPUSH
62550: LD_VAR 0 3
62554: PPUSH
62555: CALL 14988 0 3
62559: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62560: LD_VAR 0 3
62564: PPUSH
62565: CALL_OW 310
62569: IFFALSE 62580
// ComExitBuilding ( j ) ;
62571: LD_VAR 0 3
62575: PPUSH
62576: CALL_OW 122
// wait ( 3 ) ;
62580: LD_INT 3
62582: PPUSH
62583: CALL_OW 67
// if not mc_build_list [ i ] then
62587: LD_EXP 48
62591: PUSH
62592: LD_VAR 0 2
62596: ARRAY
62597: NOT
62598: IFFALSE 62602
// break ;
62600: GO 62701
// if not HasTask ( j ) then
62602: LD_VAR 0 3
62606: PPUSH
62607: CALL_OW 314
62611: NOT
62612: IFFALSE 62699
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62614: LD_VAR 0 3
62618: PPUSH
62619: LD_EXP 48
62623: PUSH
62624: LD_VAR 0 2
62628: ARRAY
62629: PUSH
62630: LD_INT 1
62632: ARRAY
62633: PUSH
62634: LD_INT 1
62636: ARRAY
62637: PPUSH
62638: LD_EXP 48
62642: PUSH
62643: LD_VAR 0 2
62647: ARRAY
62648: PUSH
62649: LD_INT 1
62651: ARRAY
62652: PUSH
62653: LD_INT 2
62655: ARRAY
62656: PPUSH
62657: LD_EXP 48
62661: PUSH
62662: LD_VAR 0 2
62666: ARRAY
62667: PUSH
62668: LD_INT 1
62670: ARRAY
62671: PUSH
62672: LD_INT 3
62674: ARRAY
62675: PPUSH
62676: LD_EXP 48
62680: PUSH
62681: LD_VAR 0 2
62685: ARRAY
62686: PUSH
62687: LD_INT 1
62689: ARRAY
62690: PUSH
62691: LD_INT 4
62693: ARRAY
62694: PPUSH
62695: CALL_OW 145
// end ;
62699: GO 62488
62701: POP
62702: POP
// end else
62703: GO 62875
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62705: LD_EXP 43
62709: PUSH
62710: LD_VAR 0 2
62714: ARRAY
62715: PPUSH
62716: LD_EXP 48
62720: PUSH
62721: LD_VAR 0 2
62725: ARRAY
62726: PUSH
62727: LD_INT 1
62729: ARRAY
62730: PUSH
62731: LD_INT 1
62733: ARRAY
62734: PPUSH
62735: LD_EXP 48
62739: PUSH
62740: LD_VAR 0 2
62744: ARRAY
62745: PUSH
62746: LD_INT 1
62748: ARRAY
62749: PUSH
62750: LD_INT 2
62752: ARRAY
62753: PPUSH
62754: LD_EXP 48
62758: PUSH
62759: LD_VAR 0 2
62763: ARRAY
62764: PUSH
62765: LD_INT 1
62767: ARRAY
62768: PUSH
62769: LD_INT 3
62771: ARRAY
62772: PPUSH
62773: LD_EXP 48
62777: PUSH
62778: LD_VAR 0 2
62782: ARRAY
62783: PUSH
62784: LD_INT 1
62786: ARRAY
62787: PUSH
62788: LD_INT 4
62790: ARRAY
62791: PPUSH
62792: LD_EXP 43
62796: PUSH
62797: LD_VAR 0 2
62801: ARRAY
62802: PPUSH
62803: LD_INT 21
62805: PUSH
62806: LD_INT 3
62808: PUSH
62809: EMPTY
62810: LIST
62811: LIST
62812: PPUSH
62813: CALL_OW 72
62817: PPUSH
62818: EMPTY
62819: PPUSH
62820: CALL 21839 0 7
62824: NOT
62825: IFFALSE 62875
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62827: LD_ADDR_EXP 48
62831: PUSH
62832: LD_EXP 48
62836: PPUSH
62837: LD_VAR 0 2
62841: PPUSH
62842: LD_EXP 48
62846: PUSH
62847: LD_VAR 0 2
62851: ARRAY
62852: PPUSH
62853: LD_INT 1
62855: PPUSH
62856: LD_INT 1
62858: NEG
62859: PPUSH
62860: LD_INT 0
62862: PPUSH
62863: CALL 14406 0 4
62867: PPUSH
62868: CALL_OW 1
62872: ST_TO_ADDR
// continue ;
62873: GO 62306
// end ; end ;
62875: GO 62306
62877: POP
62878: POP
// end ; end ;
62879: GO 61735
62881: POP
62882: POP
// end ;
62883: LD_VAR 0 1
62887: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62888: LD_INT 0
62890: PPUSH
62891: PPUSH
62892: PPUSH
62893: PPUSH
62894: PPUSH
62895: PPUSH
// if not mc_bases then
62896: LD_EXP 43
62900: NOT
62901: IFFALSE 62905
// exit ;
62903: GO 63332
// for i = 1 to mc_bases do
62905: LD_ADDR_VAR 0 2
62909: PUSH
62910: DOUBLE
62911: LD_INT 1
62913: DEC
62914: ST_TO_ADDR
62915: LD_EXP 43
62919: PUSH
62920: FOR_TO
62921: IFFALSE 63330
// begin tmp := mc_build_upgrade [ i ] ;
62923: LD_ADDR_VAR 0 4
62927: PUSH
62928: LD_EXP 75
62932: PUSH
62933: LD_VAR 0 2
62937: ARRAY
62938: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62939: LD_ADDR_VAR 0 6
62943: PUSH
62944: LD_EXP 76
62948: PUSH
62949: LD_VAR 0 2
62953: ARRAY
62954: PPUSH
62955: LD_INT 2
62957: PUSH
62958: LD_INT 30
62960: PUSH
62961: LD_INT 6
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: PUSH
62968: LD_INT 30
62970: PUSH
62971: LD_INT 7
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: LIST
62982: PPUSH
62983: CALL_OW 72
62987: ST_TO_ADDR
// if not tmp and not lab then
62988: LD_VAR 0 4
62992: NOT
62993: PUSH
62994: LD_VAR 0 6
62998: NOT
62999: AND
63000: IFFALSE 63004
// continue ;
63002: GO 62920
// if tmp then
63004: LD_VAR 0 4
63008: IFFALSE 63128
// for j in tmp do
63010: LD_ADDR_VAR 0 3
63014: PUSH
63015: LD_VAR 0 4
63019: PUSH
63020: FOR_IN
63021: IFFALSE 63126
// begin if UpgradeCost ( j ) then
63023: LD_VAR 0 3
63027: PPUSH
63028: CALL 21499 0 1
63032: IFFALSE 63124
// begin ComUpgrade ( j ) ;
63034: LD_VAR 0 3
63038: PPUSH
63039: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63043: LD_ADDR_EXP 75
63047: PUSH
63048: LD_EXP 75
63052: PPUSH
63053: LD_VAR 0 2
63057: PPUSH
63058: LD_EXP 75
63062: PUSH
63063: LD_VAR 0 2
63067: ARRAY
63068: PUSH
63069: LD_VAR 0 3
63073: DIFF
63074: PPUSH
63075: CALL_OW 1
63079: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63080: LD_ADDR_EXP 50
63084: PUSH
63085: LD_EXP 50
63089: PPUSH
63090: LD_VAR 0 2
63094: PUSH
63095: LD_EXP 50
63099: PUSH
63100: LD_VAR 0 2
63104: ARRAY
63105: PUSH
63106: LD_INT 1
63108: PLUS
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PPUSH
63114: LD_VAR 0 3
63118: PPUSH
63119: CALL 14988 0 3
63123: ST_TO_ADDR
// end ; end ;
63124: GO 63020
63126: POP
63127: POP
// if not lab or not mc_lab_upgrade [ i ] then
63128: LD_VAR 0 6
63132: NOT
63133: PUSH
63134: LD_EXP 77
63138: PUSH
63139: LD_VAR 0 2
63143: ARRAY
63144: NOT
63145: OR
63146: IFFALSE 63150
// continue ;
63148: GO 62920
// for j in lab do
63150: LD_ADDR_VAR 0 3
63154: PUSH
63155: LD_VAR 0 6
63159: PUSH
63160: FOR_IN
63161: IFFALSE 63326
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63163: LD_VAR 0 3
63167: PPUSH
63168: CALL_OW 266
63172: PUSH
63173: LD_INT 6
63175: PUSH
63176: LD_INT 7
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: IN
63183: PUSH
63184: LD_VAR 0 3
63188: PPUSH
63189: CALL_OW 461
63193: PUSH
63194: LD_INT 1
63196: NONEQUAL
63197: AND
63198: IFFALSE 63324
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63200: LD_VAR 0 3
63204: PPUSH
63205: LD_EXP 77
63209: PUSH
63210: LD_VAR 0 2
63214: ARRAY
63215: PUSH
63216: LD_INT 1
63218: ARRAY
63219: PPUSH
63220: CALL 21704 0 2
63224: IFFALSE 63324
// begin ComCancel ( j ) ;
63226: LD_VAR 0 3
63230: PPUSH
63231: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63235: LD_VAR 0 3
63239: PPUSH
63240: LD_EXP 77
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PUSH
63251: LD_INT 1
63253: ARRAY
63254: PPUSH
63255: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63259: LD_VAR 0 3
63263: PUSH
63264: LD_EXP 50
63268: PUSH
63269: LD_VAR 0 2
63273: ARRAY
63274: IN
63275: NOT
63276: IFFALSE 63322
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63278: LD_ADDR_EXP 50
63282: PUSH
63283: LD_EXP 50
63287: PPUSH
63288: LD_VAR 0 2
63292: PUSH
63293: LD_EXP 50
63297: PUSH
63298: LD_VAR 0 2
63302: ARRAY
63303: PUSH
63304: LD_INT 1
63306: PLUS
63307: PUSH
63308: EMPTY
63309: LIST
63310: LIST
63311: PPUSH
63312: LD_VAR 0 3
63316: PPUSH
63317: CALL 14988 0 3
63321: ST_TO_ADDR
// break ;
63322: GO 63326
// end ; end ; end ;
63324: GO 63160
63326: POP
63327: POP
// end ;
63328: GO 62920
63330: POP
63331: POP
// end ;
63332: LD_VAR 0 1
63336: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63337: LD_INT 0
63339: PPUSH
63340: PPUSH
63341: PPUSH
63342: PPUSH
63343: PPUSH
63344: PPUSH
63345: PPUSH
63346: PPUSH
63347: PPUSH
// if not mc_bases then
63348: LD_EXP 43
63352: NOT
63353: IFFALSE 63357
// exit ;
63355: GO 63762
// for i = 1 to mc_bases do
63357: LD_ADDR_VAR 0 2
63361: PUSH
63362: DOUBLE
63363: LD_INT 1
63365: DEC
63366: ST_TO_ADDR
63367: LD_EXP 43
63371: PUSH
63372: FOR_TO
63373: IFFALSE 63760
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63375: LD_EXP 51
63379: PUSH
63380: LD_VAR 0 2
63384: ARRAY
63385: NOT
63386: PUSH
63387: LD_EXP 43
63391: PUSH
63392: LD_VAR 0 2
63396: ARRAY
63397: PPUSH
63398: LD_INT 30
63400: PUSH
63401: LD_INT 3
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: PPUSH
63408: CALL_OW 72
63412: NOT
63413: OR
63414: IFFALSE 63418
// continue ;
63416: GO 63372
// busy := false ;
63418: LD_ADDR_VAR 0 8
63422: PUSH
63423: LD_INT 0
63425: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63426: LD_ADDR_VAR 0 4
63430: PUSH
63431: LD_EXP 43
63435: PUSH
63436: LD_VAR 0 2
63440: ARRAY
63441: PPUSH
63442: LD_INT 30
63444: PUSH
63445: LD_INT 3
63447: PUSH
63448: EMPTY
63449: LIST
63450: LIST
63451: PPUSH
63452: CALL_OW 72
63456: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63457: LD_ADDR_VAR 0 6
63461: PUSH
63462: LD_EXP 51
63466: PUSH
63467: LD_VAR 0 2
63471: ARRAY
63472: PPUSH
63473: LD_INT 2
63475: PUSH
63476: LD_INT 30
63478: PUSH
63479: LD_INT 32
63481: PUSH
63482: EMPTY
63483: LIST
63484: LIST
63485: PUSH
63486: LD_INT 30
63488: PUSH
63489: LD_INT 33
63491: PUSH
63492: EMPTY
63493: LIST
63494: LIST
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: LIST
63500: PPUSH
63501: CALL_OW 72
63505: ST_TO_ADDR
// if not t then
63506: LD_VAR 0 6
63510: NOT
63511: IFFALSE 63515
// continue ;
63513: GO 63372
// for j in tmp do
63515: LD_ADDR_VAR 0 3
63519: PUSH
63520: LD_VAR 0 4
63524: PUSH
63525: FOR_IN
63526: IFFALSE 63556
// if not BuildingStatus ( j ) = bs_idle then
63528: LD_VAR 0 3
63532: PPUSH
63533: CALL_OW 461
63537: PUSH
63538: LD_INT 2
63540: EQUAL
63541: NOT
63542: IFFALSE 63554
// begin busy := true ;
63544: LD_ADDR_VAR 0 8
63548: PUSH
63549: LD_INT 1
63551: ST_TO_ADDR
// break ;
63552: GO 63556
// end ;
63554: GO 63525
63556: POP
63557: POP
// if busy then
63558: LD_VAR 0 8
63562: IFFALSE 63566
// continue ;
63564: GO 63372
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63566: LD_ADDR_VAR 0 7
63570: PUSH
63571: LD_VAR 0 6
63575: PPUSH
63576: LD_INT 35
63578: PUSH
63579: LD_INT 0
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PPUSH
63586: CALL_OW 72
63590: ST_TO_ADDR
// if tw then
63591: LD_VAR 0 7
63595: IFFALSE 63672
// begin tw := tw [ 1 ] ;
63597: LD_ADDR_VAR 0 7
63601: PUSH
63602: LD_VAR 0 7
63606: PUSH
63607: LD_INT 1
63609: ARRAY
63610: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63611: LD_ADDR_VAR 0 9
63615: PUSH
63616: LD_VAR 0 7
63620: PPUSH
63621: LD_EXP 68
63625: PUSH
63626: LD_VAR 0 2
63630: ARRAY
63631: PPUSH
63632: CALL 19996 0 2
63636: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63637: LD_EXP 82
63641: PUSH
63642: LD_VAR 0 2
63646: ARRAY
63647: IFFALSE 63670
// if not weapon in mc_allowed_tower_weapons [ i ] then
63649: LD_VAR 0 9
63653: PUSH
63654: LD_EXP 82
63658: PUSH
63659: LD_VAR 0 2
63663: ARRAY
63664: IN
63665: NOT
63666: IFFALSE 63670
// continue ;
63668: GO 63372
// end else
63670: GO 63735
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63672: LD_ADDR_VAR 0 5
63676: PUSH
63677: LD_EXP 51
63681: PUSH
63682: LD_VAR 0 2
63686: ARRAY
63687: PPUSH
63688: LD_VAR 0 4
63692: PPUSH
63693: CALL 46867 0 2
63697: ST_TO_ADDR
// if not tmp2 then
63698: LD_VAR 0 5
63702: NOT
63703: IFFALSE 63707
// continue ;
63705: GO 63372
// tw := tmp2 [ 1 ] ;
63707: LD_ADDR_VAR 0 7
63711: PUSH
63712: LD_VAR 0 5
63716: PUSH
63717: LD_INT 1
63719: ARRAY
63720: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63721: LD_ADDR_VAR 0 9
63725: PUSH
63726: LD_VAR 0 5
63730: PUSH
63731: LD_INT 2
63733: ARRAY
63734: ST_TO_ADDR
// end ; if not weapon then
63735: LD_VAR 0 9
63739: NOT
63740: IFFALSE 63744
// continue ;
63742: GO 63372
// ComPlaceWeapon ( tw , weapon ) ;
63744: LD_VAR 0 7
63748: PPUSH
63749: LD_VAR 0 9
63753: PPUSH
63754: CALL_OW 148
// end ;
63758: GO 63372
63760: POP
63761: POP
// end ;
63762: LD_VAR 0 1
63766: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63767: LD_INT 0
63769: PPUSH
63770: PPUSH
63771: PPUSH
63772: PPUSH
63773: PPUSH
63774: PPUSH
63775: PPUSH
// if not mc_bases then
63776: LD_EXP 43
63780: NOT
63781: IFFALSE 63785
// exit ;
63783: GO 64553
// for i = 1 to mc_bases do
63785: LD_ADDR_VAR 0 2
63789: PUSH
63790: DOUBLE
63791: LD_INT 1
63793: DEC
63794: ST_TO_ADDR
63795: LD_EXP 43
63799: PUSH
63800: FOR_TO
63801: IFFALSE 64551
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63803: LD_EXP 56
63807: PUSH
63808: LD_VAR 0 2
63812: ARRAY
63813: NOT
63814: PUSH
63815: LD_EXP 56
63819: PUSH
63820: LD_VAR 0 2
63824: ARRAY
63825: PUSH
63826: LD_EXP 57
63830: PUSH
63831: LD_VAR 0 2
63835: ARRAY
63836: EQUAL
63837: OR
63838: PUSH
63839: LD_EXP 66
63843: PUSH
63844: LD_VAR 0 2
63848: ARRAY
63849: OR
63850: IFFALSE 63854
// continue ;
63852: GO 63800
// if mc_miners [ i ] then
63854: LD_EXP 57
63858: PUSH
63859: LD_VAR 0 2
63863: ARRAY
63864: IFFALSE 64238
// begin for j = mc_miners [ i ] downto 1 do
63866: LD_ADDR_VAR 0 3
63870: PUSH
63871: DOUBLE
63872: LD_EXP 57
63876: PUSH
63877: LD_VAR 0 2
63881: ARRAY
63882: INC
63883: ST_TO_ADDR
63884: LD_INT 1
63886: PUSH
63887: FOR_DOWNTO
63888: IFFALSE 64236
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63890: LD_EXP 57
63894: PUSH
63895: LD_VAR 0 2
63899: ARRAY
63900: PUSH
63901: LD_VAR 0 3
63905: ARRAY
63906: PPUSH
63907: CALL_OW 301
63911: PUSH
63912: LD_EXP 57
63916: PUSH
63917: LD_VAR 0 2
63921: ARRAY
63922: PUSH
63923: LD_VAR 0 3
63927: ARRAY
63928: PPUSH
63929: CALL_OW 257
63933: PUSH
63934: LD_INT 1
63936: NONEQUAL
63937: OR
63938: IFFALSE 64001
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63940: LD_ADDR_VAR 0 5
63944: PUSH
63945: LD_EXP 57
63949: PUSH
63950: LD_VAR 0 2
63954: ARRAY
63955: PUSH
63956: LD_EXP 57
63960: PUSH
63961: LD_VAR 0 2
63965: ARRAY
63966: PUSH
63967: LD_VAR 0 3
63971: ARRAY
63972: DIFF
63973: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63974: LD_ADDR_EXP 57
63978: PUSH
63979: LD_EXP 57
63983: PPUSH
63984: LD_VAR 0 2
63988: PPUSH
63989: LD_VAR 0 5
63993: PPUSH
63994: CALL_OW 1
63998: ST_TO_ADDR
// continue ;
63999: GO 63887
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64001: LD_EXP 57
64005: PUSH
64006: LD_VAR 0 2
64010: ARRAY
64011: PUSH
64012: LD_VAR 0 3
64016: ARRAY
64017: PPUSH
64018: CALL_OW 257
64022: PUSH
64023: LD_INT 1
64025: EQUAL
64026: PUSH
64027: LD_EXP 57
64031: PUSH
64032: LD_VAR 0 2
64036: ARRAY
64037: PUSH
64038: LD_VAR 0 3
64042: ARRAY
64043: PPUSH
64044: CALL_OW 459
64048: NOT
64049: AND
64050: PUSH
64051: LD_EXP 57
64055: PUSH
64056: LD_VAR 0 2
64060: ARRAY
64061: PUSH
64062: LD_VAR 0 3
64066: ARRAY
64067: PPUSH
64068: CALL_OW 314
64072: NOT
64073: AND
64074: IFFALSE 64234
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64076: LD_EXP 57
64080: PUSH
64081: LD_VAR 0 2
64085: ARRAY
64086: PUSH
64087: LD_VAR 0 3
64091: ARRAY
64092: PPUSH
64093: CALL_OW 310
64097: IFFALSE 64120
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64099: LD_EXP 57
64103: PUSH
64104: LD_VAR 0 2
64108: ARRAY
64109: PUSH
64110: LD_VAR 0 3
64114: ARRAY
64115: PPUSH
64116: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64120: LD_EXP 57
64124: PUSH
64125: LD_VAR 0 2
64129: ARRAY
64130: PUSH
64131: LD_VAR 0 3
64135: ARRAY
64136: PPUSH
64137: CALL_OW 314
64141: NOT
64142: IFFALSE 64234
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64144: LD_ADDR_VAR 0 7
64148: PUSH
64149: LD_INT 1
64151: PPUSH
64152: LD_EXP 56
64156: PUSH
64157: LD_VAR 0 2
64161: ARRAY
64162: PPUSH
64163: CALL_OW 12
64167: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64168: LD_EXP 57
64172: PUSH
64173: LD_VAR 0 2
64177: ARRAY
64178: PUSH
64179: LD_VAR 0 3
64183: ARRAY
64184: PPUSH
64185: LD_EXP 56
64189: PUSH
64190: LD_VAR 0 2
64194: ARRAY
64195: PUSH
64196: LD_VAR 0 7
64200: ARRAY
64201: PUSH
64202: LD_INT 1
64204: ARRAY
64205: PPUSH
64206: LD_EXP 56
64210: PUSH
64211: LD_VAR 0 2
64215: ARRAY
64216: PUSH
64217: LD_VAR 0 7
64221: ARRAY
64222: PUSH
64223: LD_INT 2
64225: ARRAY
64226: PPUSH
64227: LD_INT 0
64229: PPUSH
64230: CALL_OW 193
// end ; end ; end ;
64234: GO 63887
64236: POP
64237: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64238: LD_ADDR_VAR 0 5
64242: PUSH
64243: LD_EXP 43
64247: PUSH
64248: LD_VAR 0 2
64252: ARRAY
64253: PPUSH
64254: LD_INT 2
64256: PUSH
64257: LD_INT 30
64259: PUSH
64260: LD_INT 4
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 30
64269: PUSH
64270: LD_INT 5
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 30
64279: PUSH
64280: LD_INT 32
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: PPUSH
64293: CALL_OW 72
64297: ST_TO_ADDR
// if not tmp then
64298: LD_VAR 0 5
64302: NOT
64303: IFFALSE 64307
// continue ;
64305: GO 63800
// list := [ ] ;
64307: LD_ADDR_VAR 0 6
64311: PUSH
64312: EMPTY
64313: ST_TO_ADDR
// for j in tmp do
64314: LD_ADDR_VAR 0 3
64318: PUSH
64319: LD_VAR 0 5
64323: PUSH
64324: FOR_IN
64325: IFFALSE 64394
// begin for k in UnitsInside ( j ) do
64327: LD_ADDR_VAR 0 4
64331: PUSH
64332: LD_VAR 0 3
64336: PPUSH
64337: CALL_OW 313
64341: PUSH
64342: FOR_IN
64343: IFFALSE 64390
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64345: LD_VAR 0 4
64349: PPUSH
64350: CALL_OW 257
64354: PUSH
64355: LD_INT 1
64357: EQUAL
64358: PUSH
64359: LD_VAR 0 4
64363: PPUSH
64364: CALL_OW 459
64368: NOT
64369: AND
64370: IFFALSE 64388
// list := list ^ k ;
64372: LD_ADDR_VAR 0 6
64376: PUSH
64377: LD_VAR 0 6
64381: PUSH
64382: LD_VAR 0 4
64386: ADD
64387: ST_TO_ADDR
64388: GO 64342
64390: POP
64391: POP
// end ;
64392: GO 64324
64394: POP
64395: POP
// list := list diff mc_miners [ i ] ;
64396: LD_ADDR_VAR 0 6
64400: PUSH
64401: LD_VAR 0 6
64405: PUSH
64406: LD_EXP 57
64410: PUSH
64411: LD_VAR 0 2
64415: ARRAY
64416: DIFF
64417: ST_TO_ADDR
// if not list then
64418: LD_VAR 0 6
64422: NOT
64423: IFFALSE 64427
// continue ;
64425: GO 63800
// k := mc_mines [ i ] - mc_miners [ i ] ;
64427: LD_ADDR_VAR 0 4
64431: PUSH
64432: LD_EXP 56
64436: PUSH
64437: LD_VAR 0 2
64441: ARRAY
64442: PUSH
64443: LD_EXP 57
64447: PUSH
64448: LD_VAR 0 2
64452: ARRAY
64453: MINUS
64454: ST_TO_ADDR
// if k > list then
64455: LD_VAR 0 4
64459: PUSH
64460: LD_VAR 0 6
64464: GREATER
64465: IFFALSE 64477
// k := list ;
64467: LD_ADDR_VAR 0 4
64471: PUSH
64472: LD_VAR 0 6
64476: ST_TO_ADDR
// for j = 1 to k do
64477: LD_ADDR_VAR 0 3
64481: PUSH
64482: DOUBLE
64483: LD_INT 1
64485: DEC
64486: ST_TO_ADDR
64487: LD_VAR 0 4
64491: PUSH
64492: FOR_TO
64493: IFFALSE 64547
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64495: LD_ADDR_EXP 57
64499: PUSH
64500: LD_EXP 57
64504: PPUSH
64505: LD_VAR 0 2
64509: PUSH
64510: LD_EXP 57
64514: PUSH
64515: LD_VAR 0 2
64519: ARRAY
64520: PUSH
64521: LD_INT 1
64523: PLUS
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PPUSH
64529: LD_VAR 0 6
64533: PUSH
64534: LD_VAR 0 3
64538: ARRAY
64539: PPUSH
64540: CALL 14988 0 3
64544: ST_TO_ADDR
64545: GO 64492
64547: POP
64548: POP
// end ;
64549: GO 63800
64551: POP
64552: POP
// end ;
64553: LD_VAR 0 1
64557: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64558: LD_INT 0
64560: PPUSH
64561: PPUSH
64562: PPUSH
64563: PPUSH
64564: PPUSH
64565: PPUSH
64566: PPUSH
64567: PPUSH
64568: PPUSH
64569: PPUSH
64570: PPUSH
// if not mc_bases then
64571: LD_EXP 43
64575: NOT
64576: IFFALSE 64580
// exit ;
64578: GO 66403
// for i = 1 to mc_bases do
64580: LD_ADDR_VAR 0 2
64584: PUSH
64585: DOUBLE
64586: LD_INT 1
64588: DEC
64589: ST_TO_ADDR
64590: LD_EXP 43
64594: PUSH
64595: FOR_TO
64596: IFFALSE 66401
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64598: LD_EXP 43
64602: PUSH
64603: LD_VAR 0 2
64607: ARRAY
64608: NOT
64609: PUSH
64610: LD_EXP 50
64614: PUSH
64615: LD_VAR 0 2
64619: ARRAY
64620: OR
64621: IFFALSE 64625
// continue ;
64623: GO 64595
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64625: LD_EXP 59
64629: PUSH
64630: LD_VAR 0 2
64634: ARRAY
64635: NOT
64636: PUSH
64637: LD_EXP 60
64641: PUSH
64642: LD_VAR 0 2
64646: ARRAY
64647: AND
64648: IFFALSE 64686
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64650: LD_ADDR_EXP 60
64654: PUSH
64655: LD_EXP 60
64659: PPUSH
64660: LD_VAR 0 2
64664: PPUSH
64665: EMPTY
64666: PPUSH
64667: CALL_OW 1
64671: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64672: LD_VAR 0 2
64676: PPUSH
64677: LD_INT 107
64679: PPUSH
64680: CALL 55433 0 2
// continue ;
64684: GO 64595
// end ; target := [ ] ;
64686: LD_ADDR_VAR 0 7
64690: PUSH
64691: EMPTY
64692: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64693: LD_ADDR_VAR 0 6
64697: PUSH
64698: LD_EXP 43
64702: PUSH
64703: LD_VAR 0 2
64707: ARRAY
64708: PUSH
64709: LD_INT 1
64711: ARRAY
64712: PPUSH
64713: CALL_OW 255
64717: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64718: LD_ADDR_VAR 0 9
64722: PUSH
64723: LD_EXP 43
64727: PUSH
64728: LD_VAR 0 2
64732: ARRAY
64733: PPUSH
64734: LD_INT 2
64736: PUSH
64737: LD_INT 30
64739: PUSH
64740: LD_INT 0
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: LD_INT 30
64749: PUSH
64750: LD_INT 1
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: LIST
64761: PPUSH
64762: CALL_OW 72
64766: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64767: LD_ADDR_VAR 0 3
64771: PUSH
64772: DOUBLE
64773: LD_EXP 59
64777: PUSH
64778: LD_VAR 0 2
64782: ARRAY
64783: INC
64784: ST_TO_ADDR
64785: LD_INT 1
64787: PUSH
64788: FOR_DOWNTO
64789: IFFALSE 65034
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64791: LD_EXP 59
64795: PUSH
64796: LD_VAR 0 2
64800: ARRAY
64801: PUSH
64802: LD_VAR 0 3
64806: ARRAY
64807: PUSH
64808: LD_INT 2
64810: ARRAY
64811: PPUSH
64812: LD_EXP 59
64816: PUSH
64817: LD_VAR 0 2
64821: ARRAY
64822: PUSH
64823: LD_VAR 0 3
64827: ARRAY
64828: PUSH
64829: LD_INT 3
64831: ARRAY
64832: PPUSH
64833: CALL_OW 488
64837: PUSH
64838: LD_EXP 59
64842: PUSH
64843: LD_VAR 0 2
64847: ARRAY
64848: PUSH
64849: LD_VAR 0 3
64853: ARRAY
64854: PUSH
64855: LD_INT 2
64857: ARRAY
64858: PPUSH
64859: LD_EXP 59
64863: PUSH
64864: LD_VAR 0 2
64868: ARRAY
64869: PUSH
64870: LD_VAR 0 3
64874: ARRAY
64875: PUSH
64876: LD_INT 3
64878: ARRAY
64879: PPUSH
64880: CALL_OW 284
64884: PUSH
64885: LD_INT 0
64887: EQUAL
64888: AND
64889: IFFALSE 64944
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64891: LD_ADDR_VAR 0 5
64895: PUSH
64896: LD_EXP 59
64900: PUSH
64901: LD_VAR 0 2
64905: ARRAY
64906: PPUSH
64907: LD_VAR 0 3
64911: PPUSH
64912: CALL_OW 3
64916: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64917: LD_ADDR_EXP 59
64921: PUSH
64922: LD_EXP 59
64926: PPUSH
64927: LD_VAR 0 2
64931: PPUSH
64932: LD_VAR 0 5
64936: PPUSH
64937: CALL_OW 1
64941: ST_TO_ADDR
// continue ;
64942: GO 64788
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64944: LD_VAR 0 6
64948: PPUSH
64949: LD_EXP 59
64953: PUSH
64954: LD_VAR 0 2
64958: ARRAY
64959: PUSH
64960: LD_VAR 0 3
64964: ARRAY
64965: PUSH
64966: LD_INT 2
64968: ARRAY
64969: PPUSH
64970: LD_EXP 59
64974: PUSH
64975: LD_VAR 0 2
64979: ARRAY
64980: PUSH
64981: LD_VAR 0 3
64985: ARRAY
64986: PUSH
64987: LD_INT 3
64989: ARRAY
64990: PPUSH
64991: LD_INT 30
64993: PPUSH
64994: CALL 15884 0 4
64998: PUSH
64999: LD_INT 4
65001: ARRAY
65002: PUSH
65003: LD_INT 0
65005: EQUAL
65006: IFFALSE 65032
// begin target := mc_crates [ i ] [ j ] ;
65008: LD_ADDR_VAR 0 7
65012: PUSH
65013: LD_EXP 59
65017: PUSH
65018: LD_VAR 0 2
65022: ARRAY
65023: PUSH
65024: LD_VAR 0 3
65028: ARRAY
65029: ST_TO_ADDR
// break ;
65030: GO 65034
// end ; end ;
65032: GO 64788
65034: POP
65035: POP
// if not target then
65036: LD_VAR 0 7
65040: NOT
65041: IFFALSE 65045
// continue ;
65043: GO 64595
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65045: LD_ADDR_VAR 0 8
65049: PUSH
65050: LD_EXP 62
65054: PUSH
65055: LD_VAR 0 2
65059: ARRAY
65060: PPUSH
65061: LD_INT 2
65063: PUSH
65064: LD_INT 3
65066: PUSH
65067: LD_INT 58
65069: PUSH
65070: EMPTY
65071: LIST
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 61
65079: PUSH
65080: EMPTY
65081: LIST
65082: PUSH
65083: LD_INT 33
65085: PUSH
65086: LD_INT 5
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: PUSH
65093: LD_INT 33
65095: PUSH
65096: LD_INT 3
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 2
65112: PUSH
65113: LD_INT 34
65115: PUSH
65116: LD_INT 32
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: PUSH
65123: LD_INT 34
65125: PUSH
65126: LD_INT 51
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 34
65135: PUSH
65136: LD_INT 12
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PPUSH
65153: CALL_OW 72
65157: ST_TO_ADDR
// if not cargo then
65158: LD_VAR 0 8
65162: NOT
65163: IFFALSE 65869
// begin if mc_crates_collector [ i ] < 5 then
65165: LD_EXP 60
65169: PUSH
65170: LD_VAR 0 2
65174: ARRAY
65175: PUSH
65176: LD_INT 5
65178: LESS
65179: IFFALSE 65545
// begin if mc_ape [ i ] then
65181: LD_EXP 72
65185: PUSH
65186: LD_VAR 0 2
65190: ARRAY
65191: IFFALSE 65238
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65193: LD_ADDR_VAR 0 5
65197: PUSH
65198: LD_EXP 72
65202: PUSH
65203: LD_VAR 0 2
65207: ARRAY
65208: PPUSH
65209: LD_INT 25
65211: PUSH
65212: LD_INT 16
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: PUSH
65219: LD_INT 24
65221: PUSH
65222: LD_INT 750
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PPUSH
65233: CALL_OW 72
65237: ST_TO_ADDR
// if not tmp then
65238: LD_VAR 0 5
65242: NOT
65243: IFFALSE 65290
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65245: LD_ADDR_VAR 0 5
65249: PUSH
65250: LD_EXP 43
65254: PUSH
65255: LD_VAR 0 2
65259: ARRAY
65260: PPUSH
65261: LD_INT 25
65263: PUSH
65264: LD_INT 2
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: PUSH
65271: LD_INT 24
65273: PUSH
65274: LD_INT 750
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PPUSH
65285: CALL_OW 72
65289: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65290: LD_EXP 72
65294: PUSH
65295: LD_VAR 0 2
65299: ARRAY
65300: PUSH
65301: LD_EXP 43
65305: PUSH
65306: LD_VAR 0 2
65310: ARRAY
65311: PPUSH
65312: LD_INT 25
65314: PUSH
65315: LD_INT 2
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 24
65324: PUSH
65325: LD_INT 750
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PPUSH
65336: CALL_OW 72
65340: AND
65341: PUSH
65342: LD_VAR 0 5
65346: PUSH
65347: LD_INT 5
65349: LESS
65350: AND
65351: IFFALSE 65433
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65353: LD_ADDR_VAR 0 3
65357: PUSH
65358: LD_EXP 43
65362: PUSH
65363: LD_VAR 0 2
65367: ARRAY
65368: PPUSH
65369: LD_INT 25
65371: PUSH
65372: LD_INT 2
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: PUSH
65379: LD_INT 24
65381: PUSH
65382: LD_INT 750
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PPUSH
65393: CALL_OW 72
65397: PUSH
65398: FOR_IN
65399: IFFALSE 65431
// begin tmp := tmp union j ;
65401: LD_ADDR_VAR 0 5
65405: PUSH
65406: LD_VAR 0 5
65410: PUSH
65411: LD_VAR 0 3
65415: UNION
65416: ST_TO_ADDR
// if tmp >= 5 then
65417: LD_VAR 0 5
65421: PUSH
65422: LD_INT 5
65424: GREATEREQUAL
65425: IFFALSE 65429
// break ;
65427: GO 65431
// end ;
65429: GO 65398
65431: POP
65432: POP
// end ; if not tmp then
65433: LD_VAR 0 5
65437: NOT
65438: IFFALSE 65442
// continue ;
65440: GO 64595
// for j in tmp do
65442: LD_ADDR_VAR 0 3
65446: PUSH
65447: LD_VAR 0 5
65451: PUSH
65452: FOR_IN
65453: IFFALSE 65543
// if not GetTag ( j ) then
65455: LD_VAR 0 3
65459: PPUSH
65460: CALL_OW 110
65464: NOT
65465: IFFALSE 65541
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65467: LD_ADDR_EXP 60
65471: PUSH
65472: LD_EXP 60
65476: PPUSH
65477: LD_VAR 0 2
65481: PUSH
65482: LD_EXP 60
65486: PUSH
65487: LD_VAR 0 2
65491: ARRAY
65492: PUSH
65493: LD_INT 1
65495: PLUS
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PPUSH
65501: LD_VAR 0 3
65505: PPUSH
65506: CALL 14988 0 3
65510: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65511: LD_VAR 0 3
65515: PPUSH
65516: LD_INT 107
65518: PPUSH
65519: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65523: LD_EXP 60
65527: PUSH
65528: LD_VAR 0 2
65532: ARRAY
65533: PUSH
65534: LD_INT 5
65536: GREATEREQUAL
65537: IFFALSE 65541
// break ;
65539: GO 65543
// end ;
65541: GO 65452
65543: POP
65544: POP
// end ; if mc_crates_collector [ i ] and target then
65545: LD_EXP 60
65549: PUSH
65550: LD_VAR 0 2
65554: ARRAY
65555: PUSH
65556: LD_VAR 0 7
65560: AND
65561: IFFALSE 65867
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65563: LD_EXP 60
65567: PUSH
65568: LD_VAR 0 2
65572: ARRAY
65573: PUSH
65574: LD_VAR 0 7
65578: PUSH
65579: LD_INT 1
65581: ARRAY
65582: LESS
65583: IFFALSE 65603
// tmp := mc_crates_collector [ i ] else
65585: LD_ADDR_VAR 0 5
65589: PUSH
65590: LD_EXP 60
65594: PUSH
65595: LD_VAR 0 2
65599: ARRAY
65600: ST_TO_ADDR
65601: GO 65617
// tmp := target [ 1 ] ;
65603: LD_ADDR_VAR 0 5
65607: PUSH
65608: LD_VAR 0 7
65612: PUSH
65613: LD_INT 1
65615: ARRAY
65616: ST_TO_ADDR
// k := 0 ;
65617: LD_ADDR_VAR 0 4
65621: PUSH
65622: LD_INT 0
65624: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65625: LD_ADDR_VAR 0 3
65629: PUSH
65630: LD_EXP 60
65634: PUSH
65635: LD_VAR 0 2
65639: ARRAY
65640: PUSH
65641: FOR_IN
65642: IFFALSE 65865
// begin k := k + 1 ;
65644: LD_ADDR_VAR 0 4
65648: PUSH
65649: LD_VAR 0 4
65653: PUSH
65654: LD_INT 1
65656: PLUS
65657: ST_TO_ADDR
// if k > tmp then
65658: LD_VAR 0 4
65662: PUSH
65663: LD_VAR 0 5
65667: GREATER
65668: IFFALSE 65672
// break ;
65670: GO 65865
// if not GetClass ( j ) in [ 2 , 16 ] then
65672: LD_VAR 0 3
65676: PPUSH
65677: CALL_OW 257
65681: PUSH
65682: LD_INT 2
65684: PUSH
65685: LD_INT 16
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: IN
65692: NOT
65693: IFFALSE 65746
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65695: LD_ADDR_EXP 60
65699: PUSH
65700: LD_EXP 60
65704: PPUSH
65705: LD_VAR 0 2
65709: PPUSH
65710: LD_EXP 60
65714: PUSH
65715: LD_VAR 0 2
65719: ARRAY
65720: PUSH
65721: LD_VAR 0 3
65725: DIFF
65726: PPUSH
65727: CALL_OW 1
65731: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65732: LD_VAR 0 3
65736: PPUSH
65737: LD_INT 0
65739: PPUSH
65740: CALL_OW 109
// continue ;
65744: GO 65641
// end ; if IsInUnit ( j ) then
65746: LD_VAR 0 3
65750: PPUSH
65751: CALL_OW 310
65755: IFFALSE 65766
// ComExitBuilding ( j ) ;
65757: LD_VAR 0 3
65761: PPUSH
65762: CALL_OW 122
// wait ( 3 ) ;
65766: LD_INT 3
65768: PPUSH
65769: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65773: LD_VAR 0 3
65777: PPUSH
65778: CALL_OW 314
65782: PUSH
65783: LD_VAR 0 6
65787: PPUSH
65788: LD_VAR 0 7
65792: PUSH
65793: LD_INT 2
65795: ARRAY
65796: PPUSH
65797: LD_VAR 0 7
65801: PUSH
65802: LD_INT 3
65804: ARRAY
65805: PPUSH
65806: LD_INT 30
65808: PPUSH
65809: CALL 15884 0 4
65813: PUSH
65814: LD_INT 4
65816: ARRAY
65817: AND
65818: IFFALSE 65836
// ComStandNearbyBuilding ( j , depot ) else
65820: LD_VAR 0 3
65824: PPUSH
65825: LD_VAR 0 9
65829: PPUSH
65830: CALL 11415 0 2
65834: GO 65863
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65836: LD_VAR 0 3
65840: PPUSH
65841: LD_VAR 0 7
65845: PUSH
65846: LD_INT 2
65848: ARRAY
65849: PPUSH
65850: LD_VAR 0 7
65854: PUSH
65855: LD_INT 3
65857: ARRAY
65858: PPUSH
65859: CALL_OW 117
// end ;
65863: GO 65641
65865: POP
65866: POP
// end ; end else
65867: GO 66399
// begin for j in cargo do
65869: LD_ADDR_VAR 0 3
65873: PUSH
65874: LD_VAR 0 8
65878: PUSH
65879: FOR_IN
65880: IFFALSE 66397
// begin if GetTag ( j ) <> 0 then
65882: LD_VAR 0 3
65886: PPUSH
65887: CALL_OW 110
65891: PUSH
65892: LD_INT 0
65894: NONEQUAL
65895: IFFALSE 65899
// continue ;
65897: GO 65879
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65899: LD_VAR 0 3
65903: PPUSH
65904: CALL_OW 256
65908: PUSH
65909: LD_INT 1000
65911: LESS
65912: PUSH
65913: LD_VAR 0 3
65917: PPUSH
65918: LD_EXP 67
65922: PUSH
65923: LD_VAR 0 2
65927: ARRAY
65928: PPUSH
65929: CALL_OW 308
65933: NOT
65934: AND
65935: IFFALSE 65957
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65937: LD_VAR 0 3
65941: PPUSH
65942: LD_EXP 67
65946: PUSH
65947: LD_VAR 0 2
65951: ARRAY
65952: PPUSH
65953: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65957: LD_VAR 0 3
65961: PPUSH
65962: CALL_OW 256
65966: PUSH
65967: LD_INT 1000
65969: LESS
65970: PUSH
65971: LD_VAR 0 3
65975: PPUSH
65976: LD_EXP 67
65980: PUSH
65981: LD_VAR 0 2
65985: ARRAY
65986: PPUSH
65987: CALL_OW 308
65991: AND
65992: IFFALSE 65996
// continue ;
65994: GO 65879
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65996: LD_VAR 0 3
66000: PPUSH
66001: CALL_OW 262
66005: PUSH
66006: LD_INT 2
66008: EQUAL
66009: PUSH
66010: LD_VAR 0 3
66014: PPUSH
66015: CALL_OW 261
66019: PUSH
66020: LD_INT 15
66022: LESS
66023: AND
66024: IFFALSE 66028
// continue ;
66026: GO 65879
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66028: LD_VAR 0 3
66032: PPUSH
66033: CALL_OW 262
66037: PUSH
66038: LD_INT 1
66040: EQUAL
66041: PUSH
66042: LD_VAR 0 3
66046: PPUSH
66047: CALL_OW 261
66051: PUSH
66052: LD_INT 10
66054: LESS
66055: AND
66056: IFFALSE 66336
// begin if not depot then
66058: LD_VAR 0 9
66062: NOT
66063: IFFALSE 66067
// continue ;
66065: GO 65879
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66067: LD_VAR 0 3
66071: PPUSH
66072: LD_VAR 0 9
66076: PPUSH
66077: LD_VAR 0 3
66081: PPUSH
66082: CALL_OW 74
66086: PPUSH
66087: CALL_OW 296
66091: PUSH
66092: LD_INT 6
66094: LESS
66095: IFFALSE 66111
// SetFuel ( j , 100 ) else
66097: LD_VAR 0 3
66101: PPUSH
66102: LD_INT 100
66104: PPUSH
66105: CALL_OW 240
66109: GO 66336
// if GetFuel ( j ) = 0 then
66111: LD_VAR 0 3
66115: PPUSH
66116: CALL_OW 261
66120: PUSH
66121: LD_INT 0
66123: EQUAL
66124: IFFALSE 66336
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66126: LD_ADDR_EXP 62
66130: PUSH
66131: LD_EXP 62
66135: PPUSH
66136: LD_VAR 0 2
66140: PPUSH
66141: LD_EXP 62
66145: PUSH
66146: LD_VAR 0 2
66150: ARRAY
66151: PUSH
66152: LD_VAR 0 3
66156: DIFF
66157: PPUSH
66158: CALL_OW 1
66162: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66163: LD_VAR 0 3
66167: PPUSH
66168: CALL_OW 263
66172: PUSH
66173: LD_INT 1
66175: EQUAL
66176: IFFALSE 66192
// ComExitVehicle ( IsInUnit ( j ) ) ;
66178: LD_VAR 0 3
66182: PPUSH
66183: CALL_OW 310
66187: PPUSH
66188: CALL_OW 121
// if GetControl ( j ) = control_remote then
66192: LD_VAR 0 3
66196: PPUSH
66197: CALL_OW 263
66201: PUSH
66202: LD_INT 2
66204: EQUAL
66205: IFFALSE 66216
// ComUnlink ( j ) ;
66207: LD_VAR 0 3
66211: PPUSH
66212: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66216: LD_ADDR_VAR 0 10
66220: PUSH
66221: LD_VAR 0 2
66225: PPUSH
66226: LD_INT 3
66228: PPUSH
66229: CALL 76003 0 2
66233: ST_TO_ADDR
// if fac then
66234: LD_VAR 0 10
66238: IFFALSE 66334
// begin for k in fac do
66240: LD_ADDR_VAR 0 4
66244: PUSH
66245: LD_VAR 0 10
66249: PUSH
66250: FOR_IN
66251: IFFALSE 66332
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66253: LD_ADDR_VAR 0 11
66257: PUSH
66258: LD_VAR 0 10
66262: PPUSH
66263: LD_VAR 0 3
66267: PPUSH
66268: CALL_OW 265
66272: PPUSH
66273: LD_VAR 0 3
66277: PPUSH
66278: CALL_OW 262
66282: PPUSH
66283: LD_VAR 0 3
66287: PPUSH
66288: CALL_OW 263
66292: PPUSH
66293: LD_VAR 0 3
66297: PPUSH
66298: CALL_OW 264
66302: PPUSH
66303: CALL 12486 0 5
66307: ST_TO_ADDR
// if components then
66308: LD_VAR 0 11
66312: IFFALSE 66330
// begin MC_InsertProduceList ( i , components ) ;
66314: LD_VAR 0 2
66318: PPUSH
66319: LD_VAR 0 11
66323: PPUSH
66324: CALL 75548 0 2
// break ;
66328: GO 66332
// end ; end ;
66330: GO 66250
66332: POP
66333: POP
// end ; continue ;
66334: GO 65879
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66336: LD_VAR 0 3
66340: PPUSH
66341: LD_INT 1
66343: PPUSH
66344: CALL_OW 289
66348: PUSH
66349: LD_INT 100
66351: LESS
66352: PUSH
66353: LD_VAR 0 3
66357: PPUSH
66358: CALL_OW 314
66362: NOT
66363: AND
66364: IFFALSE 66393
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66366: LD_VAR 0 3
66370: PPUSH
66371: LD_VAR 0 7
66375: PUSH
66376: LD_INT 2
66378: ARRAY
66379: PPUSH
66380: LD_VAR 0 7
66384: PUSH
66385: LD_INT 3
66387: ARRAY
66388: PPUSH
66389: CALL_OW 117
// break ;
66393: GO 66397
// end ;
66395: GO 65879
66397: POP
66398: POP
// end ; end ;
66399: GO 64595
66401: POP
66402: POP
// end ;
66403: LD_VAR 0 1
66407: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66408: LD_INT 0
66410: PPUSH
66411: PPUSH
66412: PPUSH
66413: PPUSH
// if not mc_bases then
66414: LD_EXP 43
66418: NOT
66419: IFFALSE 66423
// exit ;
66421: GO 66584
// for i = 1 to mc_bases do
66423: LD_ADDR_VAR 0 2
66427: PUSH
66428: DOUBLE
66429: LD_INT 1
66431: DEC
66432: ST_TO_ADDR
66433: LD_EXP 43
66437: PUSH
66438: FOR_TO
66439: IFFALSE 66582
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66441: LD_ADDR_VAR 0 4
66445: PUSH
66446: LD_EXP 62
66450: PUSH
66451: LD_VAR 0 2
66455: ARRAY
66456: PUSH
66457: LD_EXP 65
66461: PUSH
66462: LD_VAR 0 2
66466: ARRAY
66467: UNION
66468: PPUSH
66469: LD_INT 33
66471: PUSH
66472: LD_INT 2
66474: PUSH
66475: EMPTY
66476: LIST
66477: LIST
66478: PPUSH
66479: CALL_OW 72
66483: ST_TO_ADDR
// if tmp then
66484: LD_VAR 0 4
66488: IFFALSE 66580
// for j in tmp do
66490: LD_ADDR_VAR 0 3
66494: PUSH
66495: LD_VAR 0 4
66499: PUSH
66500: FOR_IN
66501: IFFALSE 66578
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66503: LD_VAR 0 3
66507: PPUSH
66508: CALL_OW 312
66512: NOT
66513: PUSH
66514: LD_VAR 0 3
66518: PPUSH
66519: CALL_OW 256
66523: PUSH
66524: LD_INT 250
66526: GREATEREQUAL
66527: AND
66528: IFFALSE 66541
// Connect ( j ) else
66530: LD_VAR 0 3
66534: PPUSH
66535: CALL 17957 0 1
66539: GO 66576
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66541: LD_VAR 0 3
66545: PPUSH
66546: CALL_OW 256
66550: PUSH
66551: LD_INT 250
66553: LESS
66554: PUSH
66555: LD_VAR 0 3
66559: PPUSH
66560: CALL_OW 312
66564: AND
66565: IFFALSE 66576
// ComUnlink ( j ) ;
66567: LD_VAR 0 3
66571: PPUSH
66572: CALL_OW 136
66576: GO 66500
66578: POP
66579: POP
// end ;
66580: GO 66438
66582: POP
66583: POP
// end ;
66584: LD_VAR 0 1
66588: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66589: LD_INT 0
66591: PPUSH
66592: PPUSH
66593: PPUSH
66594: PPUSH
66595: PPUSH
// if not mc_bases then
66596: LD_EXP 43
66600: NOT
66601: IFFALSE 66605
// exit ;
66603: GO 67050
// for i = 1 to mc_bases do
66605: LD_ADDR_VAR 0 2
66609: PUSH
66610: DOUBLE
66611: LD_INT 1
66613: DEC
66614: ST_TO_ADDR
66615: LD_EXP 43
66619: PUSH
66620: FOR_TO
66621: IFFALSE 67048
// begin if not mc_produce [ i ] then
66623: LD_EXP 64
66627: PUSH
66628: LD_VAR 0 2
66632: ARRAY
66633: NOT
66634: IFFALSE 66638
// continue ;
66636: GO 66620
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66638: LD_ADDR_VAR 0 5
66642: PUSH
66643: LD_EXP 43
66647: PUSH
66648: LD_VAR 0 2
66652: ARRAY
66653: PPUSH
66654: LD_INT 30
66656: PUSH
66657: LD_INT 3
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PPUSH
66664: CALL_OW 72
66668: ST_TO_ADDR
// if not fac then
66669: LD_VAR 0 5
66673: NOT
66674: IFFALSE 66678
// continue ;
66676: GO 66620
// for j in fac do
66678: LD_ADDR_VAR 0 3
66682: PUSH
66683: LD_VAR 0 5
66687: PUSH
66688: FOR_IN
66689: IFFALSE 67044
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66691: LD_VAR 0 3
66695: PPUSH
66696: CALL_OW 461
66700: PUSH
66701: LD_INT 2
66703: NONEQUAL
66704: PUSH
66705: LD_VAR 0 3
66709: PPUSH
66710: LD_INT 15
66712: PPUSH
66713: CALL 17585 0 2
66717: PUSH
66718: LD_INT 4
66720: ARRAY
66721: OR
66722: IFFALSE 66726
// continue ;
66724: GO 66688
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66726: LD_VAR 0 3
66730: PPUSH
66731: LD_EXP 64
66735: PUSH
66736: LD_VAR 0 2
66740: ARRAY
66741: PUSH
66742: LD_INT 1
66744: ARRAY
66745: PUSH
66746: LD_INT 1
66748: ARRAY
66749: PPUSH
66750: LD_EXP 64
66754: PUSH
66755: LD_VAR 0 2
66759: ARRAY
66760: PUSH
66761: LD_INT 1
66763: ARRAY
66764: PUSH
66765: LD_INT 2
66767: ARRAY
66768: PPUSH
66769: LD_EXP 64
66773: PUSH
66774: LD_VAR 0 2
66778: ARRAY
66779: PUSH
66780: LD_INT 1
66782: ARRAY
66783: PUSH
66784: LD_INT 3
66786: ARRAY
66787: PPUSH
66788: LD_EXP 64
66792: PUSH
66793: LD_VAR 0 2
66797: ARRAY
66798: PUSH
66799: LD_INT 1
66801: ARRAY
66802: PUSH
66803: LD_INT 4
66805: ARRAY
66806: PPUSH
66807: CALL_OW 448
66811: PUSH
66812: LD_VAR 0 3
66816: PPUSH
66817: LD_EXP 64
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: PUSH
66828: LD_INT 1
66830: ARRAY
66831: PUSH
66832: LD_INT 1
66834: ARRAY
66835: PUSH
66836: LD_EXP 64
66840: PUSH
66841: LD_VAR 0 2
66845: ARRAY
66846: PUSH
66847: LD_INT 1
66849: ARRAY
66850: PUSH
66851: LD_INT 2
66853: ARRAY
66854: PUSH
66855: LD_EXP 64
66859: PUSH
66860: LD_VAR 0 2
66864: ARRAY
66865: PUSH
66866: LD_INT 1
66868: ARRAY
66869: PUSH
66870: LD_INT 3
66872: ARRAY
66873: PUSH
66874: LD_EXP 64
66878: PUSH
66879: LD_VAR 0 2
66883: ARRAY
66884: PUSH
66885: LD_INT 1
66887: ARRAY
66888: PUSH
66889: LD_INT 4
66891: ARRAY
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: PPUSH
66899: CALL 21352 0 2
66903: AND
66904: IFFALSE 67042
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66906: LD_VAR 0 3
66910: PPUSH
66911: LD_EXP 64
66915: PUSH
66916: LD_VAR 0 2
66920: ARRAY
66921: PUSH
66922: LD_INT 1
66924: ARRAY
66925: PUSH
66926: LD_INT 1
66928: ARRAY
66929: PPUSH
66930: LD_EXP 64
66934: PUSH
66935: LD_VAR 0 2
66939: ARRAY
66940: PUSH
66941: LD_INT 1
66943: ARRAY
66944: PUSH
66945: LD_INT 2
66947: ARRAY
66948: PPUSH
66949: LD_EXP 64
66953: PUSH
66954: LD_VAR 0 2
66958: ARRAY
66959: PUSH
66960: LD_INT 1
66962: ARRAY
66963: PUSH
66964: LD_INT 3
66966: ARRAY
66967: PPUSH
66968: LD_EXP 64
66972: PUSH
66973: LD_VAR 0 2
66977: ARRAY
66978: PUSH
66979: LD_INT 1
66981: ARRAY
66982: PUSH
66983: LD_INT 4
66985: ARRAY
66986: PPUSH
66987: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66991: LD_ADDR_VAR 0 4
66995: PUSH
66996: LD_EXP 64
67000: PUSH
67001: LD_VAR 0 2
67005: ARRAY
67006: PPUSH
67007: LD_INT 1
67009: PPUSH
67010: CALL_OW 3
67014: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67015: LD_ADDR_EXP 64
67019: PUSH
67020: LD_EXP 64
67024: PPUSH
67025: LD_VAR 0 2
67029: PPUSH
67030: LD_VAR 0 4
67034: PPUSH
67035: CALL_OW 1
67039: ST_TO_ADDR
// break ;
67040: GO 67044
// end ; end ;
67042: GO 66688
67044: POP
67045: POP
// end ;
67046: GO 66620
67048: POP
67049: POP
// end ;
67050: LD_VAR 0 1
67054: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67055: LD_INT 0
67057: PPUSH
67058: PPUSH
67059: PPUSH
// if not mc_bases then
67060: LD_EXP 43
67064: NOT
67065: IFFALSE 67069
// exit ;
67067: GO 67158
// for i = 1 to mc_bases do
67069: LD_ADDR_VAR 0 2
67073: PUSH
67074: DOUBLE
67075: LD_INT 1
67077: DEC
67078: ST_TO_ADDR
67079: LD_EXP 43
67083: PUSH
67084: FOR_TO
67085: IFFALSE 67156
// begin if mc_attack [ i ] then
67087: LD_EXP 63
67091: PUSH
67092: LD_VAR 0 2
67096: ARRAY
67097: IFFALSE 67154
// begin tmp := mc_attack [ i ] [ 1 ] ;
67099: LD_ADDR_VAR 0 3
67103: PUSH
67104: LD_EXP 63
67108: PUSH
67109: LD_VAR 0 2
67113: ARRAY
67114: PUSH
67115: LD_INT 1
67117: ARRAY
67118: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67119: LD_ADDR_EXP 63
67123: PUSH
67124: LD_EXP 63
67128: PPUSH
67129: LD_VAR 0 2
67133: PPUSH
67134: EMPTY
67135: PPUSH
67136: CALL_OW 1
67140: ST_TO_ADDR
// Attack ( tmp ) ;
67141: LD_VAR 0 3
67145: PPUSH
67146: CALL 81936 0 1
// exit ;
67150: POP
67151: POP
67152: GO 67158
// end ; end ;
67154: GO 67084
67156: POP
67157: POP
// end ;
67158: LD_VAR 0 1
67162: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67163: LD_INT 0
67165: PPUSH
67166: PPUSH
67167: PPUSH
67168: PPUSH
67169: PPUSH
67170: PPUSH
67171: PPUSH
// if not mc_bases then
67172: LD_EXP 43
67176: NOT
67177: IFFALSE 67181
// exit ;
67179: GO 68038
// for i = 1 to mc_bases do
67181: LD_ADDR_VAR 0 2
67185: PUSH
67186: DOUBLE
67187: LD_INT 1
67189: DEC
67190: ST_TO_ADDR
67191: LD_EXP 43
67195: PUSH
67196: FOR_TO
67197: IFFALSE 68036
// begin if not mc_bases [ i ] then
67199: LD_EXP 43
67203: PUSH
67204: LD_VAR 0 2
67208: ARRAY
67209: NOT
67210: IFFALSE 67214
// continue ;
67212: GO 67196
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67214: LD_ADDR_VAR 0 7
67218: PUSH
67219: LD_EXP 43
67223: PUSH
67224: LD_VAR 0 2
67228: ARRAY
67229: PUSH
67230: LD_INT 1
67232: ARRAY
67233: PPUSH
67234: CALL 11637 0 1
67238: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67239: LD_ADDR_EXP 66
67243: PUSH
67244: LD_EXP 66
67248: PPUSH
67249: LD_VAR 0 2
67253: PPUSH
67254: LD_EXP 43
67258: PUSH
67259: LD_VAR 0 2
67263: ARRAY
67264: PUSH
67265: LD_INT 1
67267: ARRAY
67268: PPUSH
67269: CALL_OW 255
67273: PPUSH
67274: LD_EXP 68
67278: PUSH
67279: LD_VAR 0 2
67283: ARRAY
67284: PPUSH
67285: CALL 11602 0 2
67289: PPUSH
67290: CALL_OW 1
67294: ST_TO_ADDR
// if not mc_scan [ i ] then
67295: LD_EXP 66
67299: PUSH
67300: LD_VAR 0 2
67304: ARRAY
67305: NOT
67306: IFFALSE 67484
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67308: LD_ADDR_EXP 86
67312: PUSH
67313: LD_EXP 86
67317: PPUSH
67318: LD_VAR 0 2
67322: PPUSH
67323: LD_INT 0
67325: PPUSH
67326: CALL_OW 1
67330: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67331: LD_ADDR_VAR 0 4
67335: PUSH
67336: LD_EXP 43
67340: PUSH
67341: LD_VAR 0 2
67345: ARRAY
67346: PPUSH
67347: LD_INT 2
67349: PUSH
67350: LD_INT 25
67352: PUSH
67353: LD_INT 5
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 25
67362: PUSH
67363: LD_INT 8
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 25
67372: PUSH
67373: LD_INT 9
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: PPUSH
67386: CALL_OW 72
67390: ST_TO_ADDR
// if not tmp then
67391: LD_VAR 0 4
67395: NOT
67396: IFFALSE 67400
// continue ;
67398: GO 67196
// for j in tmp do
67400: LD_ADDR_VAR 0 3
67404: PUSH
67405: LD_VAR 0 4
67409: PUSH
67410: FOR_IN
67411: IFFALSE 67482
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67413: LD_VAR 0 3
67417: PPUSH
67418: CALL_OW 310
67422: PPUSH
67423: CALL_OW 266
67427: PUSH
67428: LD_INT 5
67430: EQUAL
67431: PUSH
67432: LD_VAR 0 3
67436: PPUSH
67437: CALL_OW 257
67441: PUSH
67442: LD_INT 1
67444: EQUAL
67445: AND
67446: PUSH
67447: LD_VAR 0 3
67451: PPUSH
67452: CALL_OW 459
67456: NOT
67457: AND
67458: PUSH
67459: LD_VAR 0 7
67463: AND
67464: IFFALSE 67480
// ComChangeProfession ( j , class ) ;
67466: LD_VAR 0 3
67470: PPUSH
67471: LD_VAR 0 7
67475: PPUSH
67476: CALL_OW 123
67480: GO 67410
67482: POP
67483: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67484: LD_EXP 66
67488: PUSH
67489: LD_VAR 0 2
67493: ARRAY
67494: PUSH
67495: LD_EXP 86
67499: PUSH
67500: LD_VAR 0 2
67504: ARRAY
67505: NOT
67506: AND
67507: PUSH
67508: LD_EXP 65
67512: PUSH
67513: LD_VAR 0 2
67517: ARRAY
67518: NOT
67519: AND
67520: PUSH
67521: LD_EXP 43
67525: PUSH
67526: LD_VAR 0 2
67530: ARRAY
67531: PPUSH
67532: LD_INT 50
67534: PUSH
67535: EMPTY
67536: LIST
67537: PUSH
67538: LD_INT 2
67540: PUSH
67541: LD_INT 30
67543: PUSH
67544: LD_INT 32
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 30
67553: PUSH
67554: LD_INT 33
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 30
67563: PUSH
67564: LD_INT 4
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 30
67573: PUSH
67574: LD_INT 5
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PPUSH
67592: CALL_OW 72
67596: PUSH
67597: LD_INT 4
67599: LESS
67600: PUSH
67601: LD_EXP 43
67605: PUSH
67606: LD_VAR 0 2
67610: ARRAY
67611: PPUSH
67612: LD_INT 3
67614: PUSH
67615: LD_INT 24
67617: PUSH
67618: LD_INT 1000
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 2
67631: PUSH
67632: LD_INT 30
67634: PUSH
67635: LD_INT 0
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 30
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: LIST
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PPUSH
67661: CALL_OW 72
67665: OR
67666: AND
67667: IFFALSE 67918
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67669: LD_ADDR_EXP 86
67673: PUSH
67674: LD_EXP 86
67678: PPUSH
67679: LD_VAR 0 2
67683: PPUSH
67684: LD_INT 1
67686: PPUSH
67687: CALL_OW 1
67691: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67692: LD_ADDR_VAR 0 4
67696: PUSH
67697: LD_EXP 43
67701: PUSH
67702: LD_VAR 0 2
67706: ARRAY
67707: PPUSH
67708: LD_INT 2
67710: PUSH
67711: LD_INT 25
67713: PUSH
67714: LD_INT 1
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: LD_INT 25
67723: PUSH
67724: LD_INT 5
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 25
67733: PUSH
67734: LD_INT 8
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 25
67743: PUSH
67744: LD_INT 9
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: PPUSH
67758: CALL_OW 72
67762: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67763: LD_ADDR_VAR 0 4
67767: PUSH
67768: LD_VAR 0 4
67772: PUSH
67773: LD_VAR 0 4
67777: PPUSH
67778: LD_INT 18
67780: PPUSH
67781: CALL 44900 0 2
67785: DIFF
67786: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67787: LD_VAR 0 4
67791: NOT
67792: PUSH
67793: LD_EXP 43
67797: PUSH
67798: LD_VAR 0 2
67802: ARRAY
67803: PPUSH
67804: LD_INT 2
67806: PUSH
67807: LD_INT 30
67809: PUSH
67810: LD_INT 4
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 30
67819: PUSH
67820: LD_INT 5
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: PPUSH
67832: CALL_OW 72
67836: NOT
67837: AND
67838: IFFALSE 67900
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67840: LD_ADDR_VAR 0 4
67844: PUSH
67845: LD_EXP 43
67849: PUSH
67850: LD_VAR 0 2
67854: ARRAY
67855: PPUSH
67856: LD_INT 2
67858: PUSH
67859: LD_INT 25
67861: PUSH
67862: LD_INT 2
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 25
67871: PUSH
67872: LD_INT 3
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 25
67881: PUSH
67882: LD_INT 4
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: PPUSH
67895: CALL_OW 72
67899: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67900: LD_VAR 0 2
67904: PPUSH
67905: LD_VAR 0 4
67909: PPUSH
67910: CALL 86645 0 2
// exit ;
67914: POP
67915: POP
67916: GO 68038
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67918: LD_EXP 66
67922: PUSH
67923: LD_VAR 0 2
67927: ARRAY
67928: PUSH
67929: LD_EXP 86
67933: PUSH
67934: LD_VAR 0 2
67938: ARRAY
67939: NOT
67940: AND
67941: PUSH
67942: LD_EXP 65
67946: PUSH
67947: LD_VAR 0 2
67951: ARRAY
67952: AND
67953: IFFALSE 68034
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67955: LD_ADDR_EXP 86
67959: PUSH
67960: LD_EXP 86
67964: PPUSH
67965: LD_VAR 0 2
67969: PPUSH
67970: LD_INT 1
67972: PPUSH
67973: CALL_OW 1
67977: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67978: LD_ADDR_VAR 0 4
67982: PUSH
67983: LD_EXP 65
67987: PUSH
67988: LD_VAR 0 2
67992: ARRAY
67993: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67994: LD_ADDR_EXP 65
67998: PUSH
67999: LD_EXP 65
68003: PPUSH
68004: LD_VAR 0 2
68008: PPUSH
68009: EMPTY
68010: PPUSH
68011: CALL_OW 1
68015: ST_TO_ADDR
// Defend ( i , tmp ) ;
68016: LD_VAR 0 2
68020: PPUSH
68021: LD_VAR 0 4
68025: PPUSH
68026: CALL 87241 0 2
// exit ;
68030: POP
68031: POP
68032: GO 68038
// end ; end ;
68034: GO 67196
68036: POP
68037: POP
// end ;
68038: LD_VAR 0 1
68042: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68043: LD_INT 0
68045: PPUSH
68046: PPUSH
68047: PPUSH
68048: PPUSH
68049: PPUSH
68050: PPUSH
68051: PPUSH
68052: PPUSH
68053: PPUSH
68054: PPUSH
68055: PPUSH
// if not mc_bases then
68056: LD_EXP 43
68060: NOT
68061: IFFALSE 68065
// exit ;
68063: GO 69152
// for i = 1 to mc_bases do
68065: LD_ADDR_VAR 0 2
68069: PUSH
68070: DOUBLE
68071: LD_INT 1
68073: DEC
68074: ST_TO_ADDR
68075: LD_EXP 43
68079: PUSH
68080: FOR_TO
68081: IFFALSE 69150
// begin tmp := mc_lab [ i ] ;
68083: LD_ADDR_VAR 0 6
68087: PUSH
68088: LD_EXP 76
68092: PUSH
68093: LD_VAR 0 2
68097: ARRAY
68098: ST_TO_ADDR
// if not tmp then
68099: LD_VAR 0 6
68103: NOT
68104: IFFALSE 68108
// continue ;
68106: GO 68080
// idle_lab := 0 ;
68108: LD_ADDR_VAR 0 11
68112: PUSH
68113: LD_INT 0
68115: ST_TO_ADDR
// for j in tmp do
68116: LD_ADDR_VAR 0 3
68120: PUSH
68121: LD_VAR 0 6
68125: PUSH
68126: FOR_IN
68127: IFFALSE 69146
// begin researching := false ;
68129: LD_ADDR_VAR 0 10
68133: PUSH
68134: LD_INT 0
68136: ST_TO_ADDR
// side := GetSide ( j ) ;
68137: LD_ADDR_VAR 0 4
68141: PUSH
68142: LD_VAR 0 3
68146: PPUSH
68147: CALL_OW 255
68151: ST_TO_ADDR
// if not mc_tech [ side ] then
68152: LD_EXP 70
68156: PUSH
68157: LD_VAR 0 4
68161: ARRAY
68162: NOT
68163: IFFALSE 68167
// continue ;
68165: GO 68126
// if BuildingStatus ( j ) = bs_idle then
68167: LD_VAR 0 3
68171: PPUSH
68172: CALL_OW 461
68176: PUSH
68177: LD_INT 2
68179: EQUAL
68180: IFFALSE 68368
// begin if idle_lab and UnitsInside ( j ) < 6 then
68182: LD_VAR 0 11
68186: PUSH
68187: LD_VAR 0 3
68191: PPUSH
68192: CALL_OW 313
68196: PUSH
68197: LD_INT 6
68199: LESS
68200: AND
68201: IFFALSE 68272
// begin tmp2 := UnitsInside ( idle_lab ) ;
68203: LD_ADDR_VAR 0 9
68207: PUSH
68208: LD_VAR 0 11
68212: PPUSH
68213: CALL_OW 313
68217: ST_TO_ADDR
// if tmp2 then
68218: LD_VAR 0 9
68222: IFFALSE 68264
// for x in tmp2 do
68224: LD_ADDR_VAR 0 7
68228: PUSH
68229: LD_VAR 0 9
68233: PUSH
68234: FOR_IN
68235: IFFALSE 68262
// begin ComExitBuilding ( x ) ;
68237: LD_VAR 0 7
68241: PPUSH
68242: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68246: LD_VAR 0 7
68250: PPUSH
68251: LD_VAR 0 3
68255: PPUSH
68256: CALL_OW 180
// end ;
68260: GO 68234
68262: POP
68263: POP
// idle_lab := 0 ;
68264: LD_ADDR_VAR 0 11
68268: PUSH
68269: LD_INT 0
68271: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68272: LD_ADDR_VAR 0 5
68276: PUSH
68277: LD_EXP 70
68281: PUSH
68282: LD_VAR 0 4
68286: ARRAY
68287: PUSH
68288: FOR_IN
68289: IFFALSE 68349
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68291: LD_VAR 0 3
68295: PPUSH
68296: LD_VAR 0 5
68300: PPUSH
68301: CALL_OW 430
68305: PUSH
68306: LD_VAR 0 4
68310: PPUSH
68311: LD_VAR 0 5
68315: PPUSH
68316: CALL 10707 0 2
68320: AND
68321: IFFALSE 68347
// begin researching := true ;
68323: LD_ADDR_VAR 0 10
68327: PUSH
68328: LD_INT 1
68330: ST_TO_ADDR
// ComResearch ( j , t ) ;
68331: LD_VAR 0 3
68335: PPUSH
68336: LD_VAR 0 5
68340: PPUSH
68341: CALL_OW 124
// break ;
68345: GO 68349
// end ;
68347: GO 68288
68349: POP
68350: POP
// if not researching then
68351: LD_VAR 0 10
68355: NOT
68356: IFFALSE 68368
// idle_lab := j ;
68358: LD_ADDR_VAR 0 11
68362: PUSH
68363: LD_VAR 0 3
68367: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68368: LD_VAR 0 3
68372: PPUSH
68373: CALL_OW 461
68377: PUSH
68378: LD_INT 10
68380: EQUAL
68381: IFFALSE 68969
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68383: LD_EXP 72
68387: PUSH
68388: LD_VAR 0 2
68392: ARRAY
68393: NOT
68394: PUSH
68395: LD_EXP 73
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: NOT
68406: AND
68407: PUSH
68408: LD_EXP 70
68412: PUSH
68413: LD_VAR 0 4
68417: ARRAY
68418: PUSH
68419: LD_INT 1
68421: GREATER
68422: AND
68423: IFFALSE 68554
// begin ComCancel ( j ) ;
68425: LD_VAR 0 3
68429: PPUSH
68430: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68434: LD_ADDR_EXP 70
68438: PUSH
68439: LD_EXP 70
68443: PPUSH
68444: LD_VAR 0 4
68448: PPUSH
68449: LD_EXP 70
68453: PUSH
68454: LD_VAR 0 4
68458: ARRAY
68459: PPUSH
68460: LD_EXP 70
68464: PUSH
68465: LD_VAR 0 4
68469: ARRAY
68470: PUSH
68471: LD_INT 1
68473: MINUS
68474: PPUSH
68475: LD_EXP 70
68479: PUSH
68480: LD_VAR 0 4
68484: ARRAY
68485: PPUSH
68486: LD_INT 0
68488: PPUSH
68489: CALL 14406 0 4
68493: PPUSH
68494: CALL_OW 1
68498: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68499: LD_ADDR_EXP 70
68503: PUSH
68504: LD_EXP 70
68508: PPUSH
68509: LD_VAR 0 4
68513: PPUSH
68514: LD_EXP 70
68518: PUSH
68519: LD_VAR 0 4
68523: ARRAY
68524: PPUSH
68525: LD_EXP 70
68529: PUSH
68530: LD_VAR 0 4
68534: ARRAY
68535: PPUSH
68536: LD_INT 1
68538: PPUSH
68539: LD_INT 0
68541: PPUSH
68542: CALL 14406 0 4
68546: PPUSH
68547: CALL_OW 1
68551: ST_TO_ADDR
// continue ;
68552: GO 68126
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68554: LD_EXP 72
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PUSH
68565: LD_EXP 73
68569: PUSH
68570: LD_VAR 0 2
68574: ARRAY
68575: NOT
68576: AND
68577: IFFALSE 68704
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68579: LD_ADDR_EXP 73
68583: PUSH
68584: LD_EXP 73
68588: PPUSH
68589: LD_VAR 0 2
68593: PUSH
68594: LD_EXP 73
68598: PUSH
68599: LD_VAR 0 2
68603: ARRAY
68604: PUSH
68605: LD_INT 1
68607: PLUS
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PPUSH
68613: LD_EXP 72
68617: PUSH
68618: LD_VAR 0 2
68622: ARRAY
68623: PUSH
68624: LD_INT 1
68626: ARRAY
68627: PPUSH
68628: CALL 14988 0 3
68632: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68633: LD_EXP 72
68637: PUSH
68638: LD_VAR 0 2
68642: ARRAY
68643: PUSH
68644: LD_INT 1
68646: ARRAY
68647: PPUSH
68648: LD_INT 112
68650: PPUSH
68651: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68655: LD_ADDR_VAR 0 9
68659: PUSH
68660: LD_EXP 72
68664: PUSH
68665: LD_VAR 0 2
68669: ARRAY
68670: PPUSH
68671: LD_INT 1
68673: PPUSH
68674: CALL_OW 3
68678: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68679: LD_ADDR_EXP 72
68683: PUSH
68684: LD_EXP 72
68688: PPUSH
68689: LD_VAR 0 2
68693: PPUSH
68694: LD_VAR 0 9
68698: PPUSH
68699: CALL_OW 1
68703: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68704: LD_EXP 72
68708: PUSH
68709: LD_VAR 0 2
68713: ARRAY
68714: PUSH
68715: LD_EXP 73
68719: PUSH
68720: LD_VAR 0 2
68724: ARRAY
68725: AND
68726: PUSH
68727: LD_EXP 73
68731: PUSH
68732: LD_VAR 0 2
68736: ARRAY
68737: PUSH
68738: LD_INT 1
68740: ARRAY
68741: PPUSH
68742: CALL_OW 310
68746: NOT
68747: AND
68748: PUSH
68749: LD_VAR 0 3
68753: PPUSH
68754: CALL_OW 313
68758: PUSH
68759: LD_INT 6
68761: EQUAL
68762: AND
68763: IFFALSE 68819
// begin tmp2 := UnitsInside ( j ) ;
68765: LD_ADDR_VAR 0 9
68769: PUSH
68770: LD_VAR 0 3
68774: PPUSH
68775: CALL_OW 313
68779: ST_TO_ADDR
// if tmp2 = 6 then
68780: LD_VAR 0 9
68784: PUSH
68785: LD_INT 6
68787: EQUAL
68788: IFFALSE 68819
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68790: LD_VAR 0 9
68794: PUSH
68795: LD_INT 1
68797: ARRAY
68798: PPUSH
68799: LD_INT 112
68801: PPUSH
68802: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68806: LD_VAR 0 9
68810: PUSH
68811: LD_INT 1
68813: ARRAY
68814: PPUSH
68815: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68819: LD_EXP 73
68823: PUSH
68824: LD_VAR 0 2
68828: ARRAY
68829: PUSH
68830: LD_EXP 73
68834: PUSH
68835: LD_VAR 0 2
68839: ARRAY
68840: PUSH
68841: LD_INT 1
68843: ARRAY
68844: PPUSH
68845: CALL_OW 314
68849: NOT
68850: AND
68851: PUSH
68852: LD_EXP 73
68856: PUSH
68857: LD_VAR 0 2
68861: ARRAY
68862: PUSH
68863: LD_INT 1
68865: ARRAY
68866: PPUSH
68867: CALL_OW 310
68871: NOT
68872: AND
68873: IFFALSE 68899
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68875: LD_EXP 73
68879: PUSH
68880: LD_VAR 0 2
68884: ARRAY
68885: PUSH
68886: LD_INT 1
68888: ARRAY
68889: PPUSH
68890: LD_VAR 0 3
68894: PPUSH
68895: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68899: LD_EXP 73
68903: PUSH
68904: LD_VAR 0 2
68908: ARRAY
68909: PUSH
68910: LD_INT 1
68912: ARRAY
68913: PPUSH
68914: CALL_OW 310
68918: PUSH
68919: LD_EXP 73
68923: PUSH
68924: LD_VAR 0 2
68928: ARRAY
68929: PUSH
68930: LD_INT 1
68932: ARRAY
68933: PPUSH
68934: CALL_OW 310
68938: PPUSH
68939: CALL_OW 461
68943: PUSH
68944: LD_INT 3
68946: NONEQUAL
68947: AND
68948: IFFALSE 68969
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68950: LD_EXP 73
68954: PUSH
68955: LD_VAR 0 2
68959: ARRAY
68960: PUSH
68961: LD_INT 1
68963: ARRAY
68964: PPUSH
68965: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 461
68978: PUSH
68979: LD_INT 6
68981: EQUAL
68982: PUSH
68983: LD_VAR 0 6
68987: PUSH
68988: LD_INT 1
68990: GREATER
68991: AND
68992: IFFALSE 69144
// begin sci := [ ] ;
68994: LD_ADDR_VAR 0 8
68998: PUSH
68999: EMPTY
69000: ST_TO_ADDR
// for x in ( tmp diff j ) do
69001: LD_ADDR_VAR 0 7
69005: PUSH
69006: LD_VAR 0 6
69010: PUSH
69011: LD_VAR 0 3
69015: DIFF
69016: PUSH
69017: FOR_IN
69018: IFFALSE 69070
// begin if sci = 6 then
69020: LD_VAR 0 8
69024: PUSH
69025: LD_INT 6
69027: EQUAL
69028: IFFALSE 69032
// break ;
69030: GO 69070
// if BuildingStatus ( x ) = bs_idle then
69032: LD_VAR 0 7
69036: PPUSH
69037: CALL_OW 461
69041: PUSH
69042: LD_INT 2
69044: EQUAL
69045: IFFALSE 69068
// sci := sci ^ UnitsInside ( x ) ;
69047: LD_ADDR_VAR 0 8
69051: PUSH
69052: LD_VAR 0 8
69056: PUSH
69057: LD_VAR 0 7
69061: PPUSH
69062: CALL_OW 313
69066: ADD
69067: ST_TO_ADDR
// end ;
69068: GO 69017
69070: POP
69071: POP
// if not sci then
69072: LD_VAR 0 8
69076: NOT
69077: IFFALSE 69081
// continue ;
69079: GO 68126
// for x in sci do
69081: LD_ADDR_VAR 0 7
69085: PUSH
69086: LD_VAR 0 8
69090: PUSH
69091: FOR_IN
69092: IFFALSE 69142
// if IsInUnit ( x ) and not HasTask ( x ) then
69094: LD_VAR 0 7
69098: PPUSH
69099: CALL_OW 310
69103: PUSH
69104: LD_VAR 0 7
69108: PPUSH
69109: CALL_OW 314
69113: NOT
69114: AND
69115: IFFALSE 69140
// begin ComExitBuilding ( x ) ;
69117: LD_VAR 0 7
69121: PPUSH
69122: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69126: LD_VAR 0 7
69130: PPUSH
69131: LD_VAR 0 3
69135: PPUSH
69136: CALL_OW 180
// end ;
69140: GO 69091
69142: POP
69143: POP
// end ; end ;
69144: GO 68126
69146: POP
69147: POP
// end ;
69148: GO 68080
69150: POP
69151: POP
// end ;
69152: LD_VAR 0 1
69156: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69157: LD_INT 0
69159: PPUSH
69160: PPUSH
// if not mc_bases then
69161: LD_EXP 43
69165: NOT
69166: IFFALSE 69170
// exit ;
69168: GO 69251
// for i = 1 to mc_bases do
69170: LD_ADDR_VAR 0 2
69174: PUSH
69175: DOUBLE
69176: LD_INT 1
69178: DEC
69179: ST_TO_ADDR
69180: LD_EXP 43
69184: PUSH
69185: FOR_TO
69186: IFFALSE 69249
// if mc_mines [ i ] and mc_miners [ i ] then
69188: LD_EXP 56
69192: PUSH
69193: LD_VAR 0 2
69197: ARRAY
69198: PUSH
69199: LD_EXP 57
69203: PUSH
69204: LD_VAR 0 2
69208: ARRAY
69209: AND
69210: IFFALSE 69247
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69212: LD_EXP 57
69216: PUSH
69217: LD_VAR 0 2
69221: ARRAY
69222: PUSH
69223: LD_INT 1
69225: ARRAY
69226: PPUSH
69227: CALL_OW 255
69231: PPUSH
69232: LD_EXP 56
69236: PUSH
69237: LD_VAR 0 2
69241: ARRAY
69242: PPUSH
69243: CALL 11790 0 2
69247: GO 69185
69249: POP
69250: POP
// end ;
69251: LD_VAR 0 1
69255: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69256: LD_INT 0
69258: PPUSH
69259: PPUSH
69260: PPUSH
69261: PPUSH
69262: PPUSH
69263: PPUSH
69264: PPUSH
69265: PPUSH
// if not mc_bases or not mc_parking then
69266: LD_EXP 43
69270: NOT
69271: PUSH
69272: LD_EXP 67
69276: NOT
69277: OR
69278: IFFALSE 69282
// exit ;
69280: GO 70020
// for i = 1 to mc_bases do
69282: LD_ADDR_VAR 0 2
69286: PUSH
69287: DOUBLE
69288: LD_INT 1
69290: DEC
69291: ST_TO_ADDR
69292: LD_EXP 43
69296: PUSH
69297: FOR_TO
69298: IFFALSE 70018
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69300: LD_EXP 43
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: NOT
69311: PUSH
69312: LD_EXP 67
69316: PUSH
69317: LD_VAR 0 2
69321: ARRAY
69322: NOT
69323: OR
69324: IFFALSE 69328
// continue ;
69326: GO 69297
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69328: LD_ADDR_VAR 0 5
69332: PUSH
69333: LD_EXP 43
69337: PUSH
69338: LD_VAR 0 2
69342: ARRAY
69343: PUSH
69344: LD_INT 1
69346: ARRAY
69347: PPUSH
69348: CALL_OW 255
69352: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69353: LD_ADDR_VAR 0 6
69357: PUSH
69358: LD_EXP 43
69362: PUSH
69363: LD_VAR 0 2
69367: ARRAY
69368: PPUSH
69369: LD_INT 30
69371: PUSH
69372: LD_INT 3
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PPUSH
69379: CALL_OW 72
69383: ST_TO_ADDR
// if not fac then
69384: LD_VAR 0 6
69388: NOT
69389: IFFALSE 69440
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69391: LD_ADDR_VAR 0 6
69395: PUSH
69396: LD_EXP 43
69400: PUSH
69401: LD_VAR 0 2
69405: ARRAY
69406: PPUSH
69407: LD_INT 2
69409: PUSH
69410: LD_INT 30
69412: PUSH
69413: LD_INT 0
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: PUSH
69420: LD_INT 30
69422: PUSH
69423: LD_INT 1
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: LIST
69434: PPUSH
69435: CALL_OW 72
69439: ST_TO_ADDR
// if not fac then
69440: LD_VAR 0 6
69444: NOT
69445: IFFALSE 69449
// continue ;
69447: GO 69297
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69449: LD_ADDR_VAR 0 7
69453: PUSH
69454: LD_EXP 67
69458: PUSH
69459: LD_VAR 0 2
69463: ARRAY
69464: PPUSH
69465: LD_INT 22
69467: PUSH
69468: LD_VAR 0 5
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 21
69479: PUSH
69480: LD_INT 2
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 3
69489: PUSH
69490: LD_INT 60
69492: PUSH
69493: EMPTY
69494: LIST
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 3
69502: PUSH
69503: LD_INT 24
69505: PUSH
69506: LD_INT 1000
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: PPUSH
69523: CALL_OW 70
69527: ST_TO_ADDR
// for j in fac do
69528: LD_ADDR_VAR 0 3
69532: PUSH
69533: LD_VAR 0 6
69537: PUSH
69538: FOR_IN
69539: IFFALSE 69634
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69541: LD_ADDR_VAR 0 7
69545: PUSH
69546: LD_VAR 0 7
69550: PUSH
69551: LD_INT 22
69553: PUSH
69554: LD_VAR 0 5
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 91
69565: PUSH
69566: LD_VAR 0 3
69570: PUSH
69571: LD_INT 15
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 21
69581: PUSH
69582: LD_INT 2
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 3
69591: PUSH
69592: LD_INT 60
69594: PUSH
69595: EMPTY
69596: LIST
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 3
69604: PUSH
69605: LD_INT 24
69607: PUSH
69608: LD_INT 1000
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: PPUSH
69626: CALL_OW 69
69630: UNION
69631: ST_TO_ADDR
69632: GO 69538
69634: POP
69635: POP
// if not vehs then
69636: LD_VAR 0 7
69640: NOT
69641: IFFALSE 69667
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69643: LD_ADDR_EXP 55
69647: PUSH
69648: LD_EXP 55
69652: PPUSH
69653: LD_VAR 0 2
69657: PPUSH
69658: EMPTY
69659: PPUSH
69660: CALL_OW 1
69664: ST_TO_ADDR
// continue ;
69665: GO 69297
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69667: LD_ADDR_VAR 0 8
69671: PUSH
69672: LD_EXP 43
69676: PUSH
69677: LD_VAR 0 2
69681: ARRAY
69682: PPUSH
69683: LD_INT 30
69685: PUSH
69686: LD_INT 3
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PPUSH
69693: CALL_OW 72
69697: ST_TO_ADDR
// if tmp then
69698: LD_VAR 0 8
69702: IFFALSE 69805
// begin for j in tmp do
69704: LD_ADDR_VAR 0 3
69708: PUSH
69709: LD_VAR 0 8
69713: PUSH
69714: FOR_IN
69715: IFFALSE 69803
// for k in UnitsInside ( j ) do
69717: LD_ADDR_VAR 0 4
69721: PUSH
69722: LD_VAR 0 3
69726: PPUSH
69727: CALL_OW 313
69731: PUSH
69732: FOR_IN
69733: IFFALSE 69799
// if k then
69735: LD_VAR 0 4
69739: IFFALSE 69797
// if not k in mc_repair_vehicle [ i ] then
69741: LD_VAR 0 4
69745: PUSH
69746: LD_EXP 55
69750: PUSH
69751: LD_VAR 0 2
69755: ARRAY
69756: IN
69757: NOT
69758: IFFALSE 69797
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69760: LD_ADDR_EXP 55
69764: PUSH
69765: LD_EXP 55
69769: PPUSH
69770: LD_VAR 0 2
69774: PPUSH
69775: LD_EXP 55
69779: PUSH
69780: LD_VAR 0 2
69784: ARRAY
69785: PUSH
69786: LD_VAR 0 4
69790: UNION
69791: PPUSH
69792: CALL_OW 1
69796: ST_TO_ADDR
69797: GO 69732
69799: POP
69800: POP
69801: GO 69714
69803: POP
69804: POP
// end ; if not mc_repair_vehicle [ i ] then
69805: LD_EXP 55
69809: PUSH
69810: LD_VAR 0 2
69814: ARRAY
69815: NOT
69816: IFFALSE 69820
// continue ;
69818: GO 69297
// for j in mc_repair_vehicle [ i ] do
69820: LD_ADDR_VAR 0 3
69824: PUSH
69825: LD_EXP 55
69829: PUSH
69830: LD_VAR 0 2
69834: ARRAY
69835: PUSH
69836: FOR_IN
69837: IFFALSE 70014
// begin if GetClass ( j ) <> 3 then
69839: LD_VAR 0 3
69843: PPUSH
69844: CALL_OW 257
69848: PUSH
69849: LD_INT 3
69851: NONEQUAL
69852: IFFALSE 69893
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69854: LD_ADDR_EXP 55
69858: PUSH
69859: LD_EXP 55
69863: PPUSH
69864: LD_VAR 0 2
69868: PPUSH
69869: LD_EXP 55
69873: PUSH
69874: LD_VAR 0 2
69878: ARRAY
69879: PUSH
69880: LD_VAR 0 3
69884: DIFF
69885: PPUSH
69886: CALL_OW 1
69890: ST_TO_ADDR
// continue ;
69891: GO 69836
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69893: LD_VAR 0 3
69897: PPUSH
69898: CALL_OW 311
69902: NOT
69903: PUSH
69904: LD_VAR 0 3
69908: PUSH
69909: LD_EXP 46
69913: PUSH
69914: LD_VAR 0 2
69918: ARRAY
69919: PUSH
69920: LD_INT 1
69922: ARRAY
69923: IN
69924: NOT
69925: AND
69926: PUSH
69927: LD_VAR 0 3
69931: PUSH
69932: LD_EXP 46
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: PUSH
69943: LD_INT 2
69945: ARRAY
69946: IN
69947: NOT
69948: AND
69949: IFFALSE 70012
// begin if IsInUnit ( j ) then
69951: LD_VAR 0 3
69955: PPUSH
69956: CALL_OW 310
69960: IFFALSE 69973
// ComExitBuilding ( j ) else
69962: LD_VAR 0 3
69966: PPUSH
69967: CALL_OW 122
69971: GO 70012
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69973: LD_VAR 0 3
69977: PPUSH
69978: LD_VAR 0 7
69982: PUSH
69983: LD_INT 1
69985: ARRAY
69986: PPUSH
69987: CALL 49384 0 2
69991: NOT
69992: IFFALSE 70012
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69994: LD_VAR 0 3
69998: PPUSH
69999: LD_VAR 0 7
70003: PUSH
70004: LD_INT 1
70006: ARRAY
70007: PPUSH
70008: CALL_OW 129
// end ; end ;
70012: GO 69836
70014: POP
70015: POP
// end ;
70016: GO 69297
70018: POP
70019: POP
// end ;
70020: LD_VAR 0 1
70024: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70025: LD_INT 0
70027: PPUSH
70028: PPUSH
70029: PPUSH
70030: PPUSH
70031: PPUSH
70032: PPUSH
70033: PPUSH
70034: PPUSH
70035: PPUSH
70036: PPUSH
70037: PPUSH
// if not mc_bases then
70038: LD_EXP 43
70042: NOT
70043: IFFALSE 70047
// exit ;
70045: GO 70849
// for i = 1 to mc_bases do
70047: LD_ADDR_VAR 0 2
70051: PUSH
70052: DOUBLE
70053: LD_INT 1
70055: DEC
70056: ST_TO_ADDR
70057: LD_EXP 43
70061: PUSH
70062: FOR_TO
70063: IFFALSE 70847
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70065: LD_EXP 71
70069: PUSH
70070: LD_VAR 0 2
70074: ARRAY
70075: NOT
70076: PUSH
70077: LD_EXP 46
70081: PUSH
70082: LD_VAR 0 2
70086: ARRAY
70087: PUSH
70088: LD_INT 1
70090: ARRAY
70091: OR
70092: PUSH
70093: LD_EXP 46
70097: PUSH
70098: LD_VAR 0 2
70102: ARRAY
70103: PUSH
70104: LD_INT 2
70106: ARRAY
70107: OR
70108: PUSH
70109: LD_EXP 69
70113: PUSH
70114: LD_VAR 0 2
70118: ARRAY
70119: PPUSH
70120: LD_INT 1
70122: PPUSH
70123: CALL_OW 325
70127: NOT
70128: OR
70129: PUSH
70130: LD_EXP 66
70134: PUSH
70135: LD_VAR 0 2
70139: ARRAY
70140: OR
70141: IFFALSE 70145
// continue ;
70143: GO 70062
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70145: LD_ADDR_VAR 0 8
70149: PUSH
70150: LD_EXP 43
70154: PUSH
70155: LD_VAR 0 2
70159: ARRAY
70160: PPUSH
70161: LD_INT 25
70163: PUSH
70164: LD_INT 4
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 50
70173: PUSH
70174: EMPTY
70175: LIST
70176: PUSH
70177: LD_INT 3
70179: PUSH
70180: LD_INT 60
70182: PUSH
70183: EMPTY
70184: LIST
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: LIST
70194: PPUSH
70195: CALL_OW 72
70199: PUSH
70200: LD_EXP 47
70204: PUSH
70205: LD_VAR 0 2
70209: ARRAY
70210: DIFF
70211: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70212: LD_ADDR_VAR 0 9
70216: PUSH
70217: LD_EXP 43
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: PPUSH
70228: LD_INT 2
70230: PUSH
70231: LD_INT 30
70233: PUSH
70234: LD_INT 0
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 30
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: LIST
70255: PPUSH
70256: CALL_OW 72
70260: ST_TO_ADDR
// if not tmp or not dep then
70261: LD_VAR 0 8
70265: NOT
70266: PUSH
70267: LD_VAR 0 9
70271: NOT
70272: OR
70273: IFFALSE 70277
// continue ;
70275: GO 70062
// side := GetSide ( tmp [ 1 ] ) ;
70277: LD_ADDR_VAR 0 11
70281: PUSH
70282: LD_VAR 0 8
70286: PUSH
70287: LD_INT 1
70289: ARRAY
70290: PPUSH
70291: CALL_OW 255
70295: ST_TO_ADDR
// dep := dep [ 1 ] ;
70296: LD_ADDR_VAR 0 9
70300: PUSH
70301: LD_VAR 0 9
70305: PUSH
70306: LD_INT 1
70308: ARRAY
70309: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70310: LD_ADDR_VAR 0 7
70314: PUSH
70315: LD_EXP 71
70319: PUSH
70320: LD_VAR 0 2
70324: ARRAY
70325: PPUSH
70326: LD_INT 22
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 25
70338: PUSH
70339: LD_INT 12
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PPUSH
70350: CALL_OW 70
70354: PUSH
70355: LD_INT 22
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PUSH
70365: LD_INT 25
70367: PUSH
70368: LD_INT 12
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: PUSH
70375: LD_INT 91
70377: PUSH
70378: LD_VAR 0 9
70382: PUSH
70383: LD_INT 20
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: LIST
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: LIST
70395: PPUSH
70396: CALL_OW 69
70400: UNION
70401: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70402: LD_ADDR_VAR 0 10
70406: PUSH
70407: LD_EXP 71
70411: PUSH
70412: LD_VAR 0 2
70416: ARRAY
70417: PPUSH
70418: LD_INT 81
70420: PUSH
70421: LD_VAR 0 11
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PPUSH
70430: CALL_OW 70
70434: ST_TO_ADDR
// if not apes or danger_at_area then
70435: LD_VAR 0 7
70439: NOT
70440: PUSH
70441: LD_VAR 0 10
70445: OR
70446: IFFALSE 70496
// begin if mc_taming [ i ] then
70448: LD_EXP 74
70452: PUSH
70453: LD_VAR 0 2
70457: ARRAY
70458: IFFALSE 70494
// begin MC_Reset ( i , 121 ) ;
70460: LD_VAR 0 2
70464: PPUSH
70465: LD_INT 121
70467: PPUSH
70468: CALL 55433 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70472: LD_ADDR_EXP 74
70476: PUSH
70477: LD_EXP 74
70481: PPUSH
70482: LD_VAR 0 2
70486: PPUSH
70487: EMPTY
70488: PPUSH
70489: CALL_OW 1
70493: ST_TO_ADDR
// end ; continue ;
70494: GO 70062
// end ; for j in tmp do
70496: LD_ADDR_VAR 0 3
70500: PUSH
70501: LD_VAR 0 8
70505: PUSH
70506: FOR_IN
70507: IFFALSE 70843
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70509: LD_VAR 0 3
70513: PUSH
70514: LD_EXP 74
70518: PUSH
70519: LD_VAR 0 2
70523: ARRAY
70524: IN
70525: NOT
70526: PUSH
70527: LD_EXP 74
70531: PUSH
70532: LD_VAR 0 2
70536: ARRAY
70537: PUSH
70538: LD_INT 3
70540: LESS
70541: AND
70542: IFFALSE 70600
// begin SetTag ( j , 121 ) ;
70544: LD_VAR 0 3
70548: PPUSH
70549: LD_INT 121
70551: PPUSH
70552: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70556: LD_ADDR_EXP 74
70560: PUSH
70561: LD_EXP 74
70565: PPUSH
70566: LD_VAR 0 2
70570: PUSH
70571: LD_EXP 74
70575: PUSH
70576: LD_VAR 0 2
70580: ARRAY
70581: PUSH
70582: LD_INT 1
70584: PLUS
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PPUSH
70590: LD_VAR 0 3
70594: PPUSH
70595: CALL 14988 0 3
70599: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70600: LD_VAR 0 3
70604: PUSH
70605: LD_EXP 74
70609: PUSH
70610: LD_VAR 0 2
70614: ARRAY
70615: IN
70616: IFFALSE 70841
// begin if GetClass ( j ) <> 4 then
70618: LD_VAR 0 3
70622: PPUSH
70623: CALL_OW 257
70627: PUSH
70628: LD_INT 4
70630: NONEQUAL
70631: IFFALSE 70684
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70633: LD_ADDR_EXP 74
70637: PUSH
70638: LD_EXP 74
70642: PPUSH
70643: LD_VAR 0 2
70647: PPUSH
70648: LD_EXP 74
70652: PUSH
70653: LD_VAR 0 2
70657: ARRAY
70658: PUSH
70659: LD_VAR 0 3
70663: DIFF
70664: PPUSH
70665: CALL_OW 1
70669: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70670: LD_VAR 0 3
70674: PPUSH
70675: LD_INT 0
70677: PPUSH
70678: CALL_OW 109
// continue ;
70682: GO 70506
// end ; if IsInUnit ( j ) then
70684: LD_VAR 0 3
70688: PPUSH
70689: CALL_OW 310
70693: IFFALSE 70704
// ComExitBuilding ( j ) ;
70695: LD_VAR 0 3
70699: PPUSH
70700: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70704: LD_ADDR_VAR 0 6
70708: PUSH
70709: LD_VAR 0 7
70713: PPUSH
70714: LD_VAR 0 3
70718: PPUSH
70719: CALL_OW 74
70723: ST_TO_ADDR
// if not ape then
70724: LD_VAR 0 6
70728: NOT
70729: IFFALSE 70733
// break ;
70731: GO 70843
// x := GetX ( ape ) ;
70733: LD_ADDR_VAR 0 4
70737: PUSH
70738: LD_VAR 0 6
70742: PPUSH
70743: CALL_OW 250
70747: ST_TO_ADDR
// y := GetY ( ape ) ;
70748: LD_ADDR_VAR 0 5
70752: PUSH
70753: LD_VAR 0 6
70757: PPUSH
70758: CALL_OW 251
70762: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70763: LD_VAR 0 4
70767: PPUSH
70768: LD_VAR 0 5
70772: PPUSH
70773: CALL_OW 488
70777: NOT
70778: PUSH
70779: LD_VAR 0 11
70783: PPUSH
70784: LD_VAR 0 4
70788: PPUSH
70789: LD_VAR 0 5
70793: PPUSH
70794: LD_INT 20
70796: PPUSH
70797: CALL 15884 0 4
70801: PUSH
70802: LD_INT 4
70804: ARRAY
70805: OR
70806: IFFALSE 70810
// break ;
70808: GO 70843
// if not HasTask ( j ) then
70810: LD_VAR 0 3
70814: PPUSH
70815: CALL_OW 314
70819: NOT
70820: IFFALSE 70841
// ComTameXY ( j , x , y ) ;
70822: LD_VAR 0 3
70826: PPUSH
70827: LD_VAR 0 4
70831: PPUSH
70832: LD_VAR 0 5
70836: PPUSH
70837: CALL_OW 131
// end ; end ;
70841: GO 70506
70843: POP
70844: POP
// end ;
70845: GO 70062
70847: POP
70848: POP
// end ;
70849: LD_VAR 0 1
70853: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70854: LD_INT 0
70856: PPUSH
70857: PPUSH
70858: PPUSH
70859: PPUSH
70860: PPUSH
70861: PPUSH
70862: PPUSH
70863: PPUSH
// if not mc_bases then
70864: LD_EXP 43
70868: NOT
70869: IFFALSE 70873
// exit ;
70871: GO 71499
// for i = 1 to mc_bases do
70873: LD_ADDR_VAR 0 2
70877: PUSH
70878: DOUBLE
70879: LD_INT 1
70881: DEC
70882: ST_TO_ADDR
70883: LD_EXP 43
70887: PUSH
70888: FOR_TO
70889: IFFALSE 71497
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70891: LD_EXP 72
70895: PUSH
70896: LD_VAR 0 2
70900: ARRAY
70901: NOT
70902: PUSH
70903: LD_EXP 72
70907: PUSH
70908: LD_VAR 0 2
70912: ARRAY
70913: PPUSH
70914: LD_INT 25
70916: PUSH
70917: LD_INT 12
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PPUSH
70924: CALL_OW 72
70928: NOT
70929: OR
70930: IFFALSE 70934
// continue ;
70932: GO 70888
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70934: LD_ADDR_VAR 0 5
70938: PUSH
70939: LD_EXP 72
70943: PUSH
70944: LD_VAR 0 2
70948: ARRAY
70949: PUSH
70950: LD_INT 1
70952: ARRAY
70953: PPUSH
70954: CALL_OW 255
70958: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70959: LD_VAR 0 5
70963: PPUSH
70964: LD_INT 2
70966: PPUSH
70967: CALL_OW 325
70971: IFFALSE 71224
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70973: LD_ADDR_VAR 0 4
70977: PUSH
70978: LD_EXP 72
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PPUSH
70989: LD_INT 25
70991: PUSH
70992: LD_INT 16
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PPUSH
70999: CALL_OW 72
71003: ST_TO_ADDR
// if tmp < 6 then
71004: LD_VAR 0 4
71008: PUSH
71009: LD_INT 6
71011: LESS
71012: IFFALSE 71224
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71014: LD_ADDR_VAR 0 6
71018: PUSH
71019: LD_EXP 43
71023: PUSH
71024: LD_VAR 0 2
71028: ARRAY
71029: PPUSH
71030: LD_INT 2
71032: PUSH
71033: LD_INT 30
71035: PUSH
71036: LD_INT 0
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 30
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: LIST
71057: PPUSH
71058: CALL_OW 72
71062: ST_TO_ADDR
// if depot then
71063: LD_VAR 0 6
71067: IFFALSE 71224
// begin selected := 0 ;
71069: LD_ADDR_VAR 0 7
71073: PUSH
71074: LD_INT 0
71076: ST_TO_ADDR
// for j in depot do
71077: LD_ADDR_VAR 0 3
71081: PUSH
71082: LD_VAR 0 6
71086: PUSH
71087: FOR_IN
71088: IFFALSE 71119
// begin if UnitsInside ( j ) < 6 then
71090: LD_VAR 0 3
71094: PPUSH
71095: CALL_OW 313
71099: PUSH
71100: LD_INT 6
71102: LESS
71103: IFFALSE 71117
// begin selected := j ;
71105: LD_ADDR_VAR 0 7
71109: PUSH
71110: LD_VAR 0 3
71114: ST_TO_ADDR
// break ;
71115: GO 71119
// end ; end ;
71117: GO 71087
71119: POP
71120: POP
// if selected then
71121: LD_VAR 0 7
71125: IFFALSE 71224
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71127: LD_ADDR_VAR 0 3
71131: PUSH
71132: LD_EXP 72
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PPUSH
71143: LD_INT 25
71145: PUSH
71146: LD_INT 12
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PPUSH
71153: CALL_OW 72
71157: PUSH
71158: FOR_IN
71159: IFFALSE 71222
// if not HasTask ( j ) then
71161: LD_VAR 0 3
71165: PPUSH
71166: CALL_OW 314
71170: NOT
71171: IFFALSE 71220
// begin if not IsInUnit ( j ) then
71173: LD_VAR 0 3
71177: PPUSH
71178: CALL_OW 310
71182: NOT
71183: IFFALSE 71199
// ComEnterUnit ( j , selected ) ;
71185: LD_VAR 0 3
71189: PPUSH
71190: LD_VAR 0 7
71194: PPUSH
71195: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71199: LD_VAR 0 3
71203: PPUSH
71204: LD_INT 16
71206: PPUSH
71207: CALL_OW 183
// AddComExitBuilding ( j ) ;
71211: LD_VAR 0 3
71215: PPUSH
71216: CALL_OW 182
// end ;
71220: GO 71158
71222: POP
71223: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71224: LD_VAR 0 5
71228: PPUSH
71229: LD_INT 11
71231: PPUSH
71232: CALL_OW 325
71236: IFFALSE 71495
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71238: LD_ADDR_VAR 0 4
71242: PUSH
71243: LD_EXP 72
71247: PUSH
71248: LD_VAR 0 2
71252: ARRAY
71253: PPUSH
71254: LD_INT 25
71256: PUSH
71257: LD_INT 16
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: PPUSH
71264: CALL_OW 72
71268: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71269: LD_VAR 0 4
71273: PUSH
71274: LD_INT 6
71276: GREATEREQUAL
71277: PUSH
71278: LD_VAR 0 5
71282: PPUSH
71283: LD_INT 2
71285: PPUSH
71286: CALL_OW 325
71290: NOT
71291: OR
71292: IFFALSE 71495
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71294: LD_ADDR_VAR 0 8
71298: PUSH
71299: LD_EXP 43
71303: PUSH
71304: LD_VAR 0 2
71308: ARRAY
71309: PPUSH
71310: LD_INT 2
71312: PUSH
71313: LD_INT 30
71315: PUSH
71316: LD_INT 4
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 30
71325: PUSH
71326: LD_INT 5
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: LIST
71337: PPUSH
71338: CALL_OW 72
71342: ST_TO_ADDR
// if barracks then
71343: LD_VAR 0 8
71347: IFFALSE 71495
// begin selected := 0 ;
71349: LD_ADDR_VAR 0 7
71353: PUSH
71354: LD_INT 0
71356: ST_TO_ADDR
// for j in barracks do
71357: LD_ADDR_VAR 0 3
71361: PUSH
71362: LD_VAR 0 8
71366: PUSH
71367: FOR_IN
71368: IFFALSE 71399
// begin if UnitsInside ( j ) < 6 then
71370: LD_VAR 0 3
71374: PPUSH
71375: CALL_OW 313
71379: PUSH
71380: LD_INT 6
71382: LESS
71383: IFFALSE 71397
// begin selected := j ;
71385: LD_ADDR_VAR 0 7
71389: PUSH
71390: LD_VAR 0 3
71394: ST_TO_ADDR
// break ;
71395: GO 71399
// end ; end ;
71397: GO 71367
71399: POP
71400: POP
// if selected then
71401: LD_VAR 0 7
71405: IFFALSE 71495
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71407: LD_ADDR_VAR 0 3
71411: PUSH
71412: LD_EXP 72
71416: PUSH
71417: LD_VAR 0 2
71421: ARRAY
71422: PPUSH
71423: LD_INT 25
71425: PUSH
71426: LD_INT 12
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PPUSH
71433: CALL_OW 72
71437: PUSH
71438: FOR_IN
71439: IFFALSE 71493
// if not IsInUnit ( j ) and not HasTask ( j ) then
71441: LD_VAR 0 3
71445: PPUSH
71446: CALL_OW 310
71450: NOT
71451: PUSH
71452: LD_VAR 0 3
71456: PPUSH
71457: CALL_OW 314
71461: NOT
71462: AND
71463: IFFALSE 71491
// begin ComEnterUnit ( j , selected ) ;
71465: LD_VAR 0 3
71469: PPUSH
71470: LD_VAR 0 7
71474: PPUSH
71475: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71479: LD_VAR 0 3
71483: PPUSH
71484: LD_INT 15
71486: PPUSH
71487: CALL_OW 183
// end ;
71491: GO 71438
71493: POP
71494: POP
// end ; end ; end ; end ; end ;
71495: GO 70888
71497: POP
71498: POP
// end ;
71499: LD_VAR 0 1
71503: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71504: LD_INT 0
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
// if not mc_bases then
71510: LD_EXP 43
71514: NOT
71515: IFFALSE 71519
// exit ;
71517: GO 71697
// for i = 1 to mc_bases do
71519: LD_ADDR_VAR 0 2
71523: PUSH
71524: DOUBLE
71525: LD_INT 1
71527: DEC
71528: ST_TO_ADDR
71529: LD_EXP 43
71533: PUSH
71534: FOR_TO
71535: IFFALSE 71695
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71537: LD_ADDR_VAR 0 4
71541: PUSH
71542: LD_EXP 43
71546: PUSH
71547: LD_VAR 0 2
71551: ARRAY
71552: PPUSH
71553: LD_INT 25
71555: PUSH
71556: LD_INT 9
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PPUSH
71563: CALL_OW 72
71567: ST_TO_ADDR
// if not tmp then
71568: LD_VAR 0 4
71572: NOT
71573: IFFALSE 71577
// continue ;
71575: GO 71534
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71577: LD_EXP 69
71581: PUSH
71582: LD_VAR 0 2
71586: ARRAY
71587: PPUSH
71588: LD_INT 29
71590: PPUSH
71591: CALL_OW 325
71595: NOT
71596: PUSH
71597: LD_EXP 69
71601: PUSH
71602: LD_VAR 0 2
71606: ARRAY
71607: PPUSH
71608: LD_INT 28
71610: PPUSH
71611: CALL_OW 325
71615: NOT
71616: AND
71617: IFFALSE 71621
// continue ;
71619: GO 71534
// for j in tmp do
71621: LD_ADDR_VAR 0 3
71625: PUSH
71626: LD_VAR 0 4
71630: PUSH
71631: FOR_IN
71632: IFFALSE 71691
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71634: LD_VAR 0 3
71638: PUSH
71639: LD_EXP 46
71643: PUSH
71644: LD_VAR 0 2
71648: ARRAY
71649: PUSH
71650: LD_INT 1
71652: ARRAY
71653: IN
71654: NOT
71655: PUSH
71656: LD_VAR 0 3
71660: PUSH
71661: LD_EXP 46
71665: PUSH
71666: LD_VAR 0 2
71670: ARRAY
71671: PUSH
71672: LD_INT 2
71674: ARRAY
71675: IN
71676: NOT
71677: AND
71678: IFFALSE 71689
// ComSpaceTimeShoot ( j ) ;
71680: LD_VAR 0 3
71684: PPUSH
71685: CALL 10798 0 1
71689: GO 71631
71691: POP
71692: POP
// end ;
71693: GO 71534
71695: POP
71696: POP
// end ;
71697: LD_VAR 0 1
71701: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71702: LD_INT 0
71704: PPUSH
71705: PPUSH
71706: PPUSH
71707: PPUSH
71708: PPUSH
71709: PPUSH
71710: PPUSH
71711: PPUSH
71712: PPUSH
// if not mc_bases then
71713: LD_EXP 43
71717: NOT
71718: IFFALSE 71722
// exit ;
71720: GO 72344
// for i = 1 to mc_bases do
71722: LD_ADDR_VAR 0 2
71726: PUSH
71727: DOUBLE
71728: LD_INT 1
71730: DEC
71731: ST_TO_ADDR
71732: LD_EXP 43
71736: PUSH
71737: FOR_TO
71738: IFFALSE 72342
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71740: LD_EXP 78
71744: PUSH
71745: LD_VAR 0 2
71749: ARRAY
71750: NOT
71751: PUSH
71752: LD_INT 38
71754: PPUSH
71755: LD_EXP 69
71759: PUSH
71760: LD_VAR 0 2
71764: ARRAY
71765: PPUSH
71766: CALL_OW 321
71770: PUSH
71771: LD_INT 2
71773: NONEQUAL
71774: OR
71775: IFFALSE 71779
// continue ;
71777: GO 71737
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71779: LD_ADDR_VAR 0 8
71783: PUSH
71784: LD_EXP 43
71788: PUSH
71789: LD_VAR 0 2
71793: ARRAY
71794: PPUSH
71795: LD_INT 30
71797: PUSH
71798: LD_INT 34
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PPUSH
71805: CALL_OW 72
71809: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71810: LD_ADDR_VAR 0 9
71814: PUSH
71815: LD_EXP 43
71819: PUSH
71820: LD_VAR 0 2
71824: ARRAY
71825: PPUSH
71826: LD_INT 25
71828: PUSH
71829: LD_INT 4
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PPUSH
71836: CALL_OW 72
71840: PPUSH
71841: LD_INT 0
71843: PPUSH
71844: CALL 44900 0 2
71848: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71849: LD_VAR 0 9
71853: NOT
71854: PUSH
71855: LD_VAR 0 8
71859: NOT
71860: OR
71861: PUSH
71862: LD_EXP 43
71866: PUSH
71867: LD_VAR 0 2
71871: ARRAY
71872: PPUSH
71873: LD_INT 124
71875: PPUSH
71876: CALL 44900 0 2
71880: OR
71881: IFFALSE 71885
// continue ;
71883: GO 71737
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71885: LD_EXP 79
71889: PUSH
71890: LD_VAR 0 2
71894: ARRAY
71895: PUSH
71896: LD_EXP 78
71900: PUSH
71901: LD_VAR 0 2
71905: ARRAY
71906: LESS
71907: PUSH
71908: LD_EXP 79
71912: PUSH
71913: LD_VAR 0 2
71917: ARRAY
71918: PUSH
71919: LD_VAR 0 8
71923: LESS
71924: AND
71925: IFFALSE 72340
// begin tmp := sci [ 1 ] ;
71927: LD_ADDR_VAR 0 7
71931: PUSH
71932: LD_VAR 0 9
71936: PUSH
71937: LD_INT 1
71939: ARRAY
71940: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71941: LD_VAR 0 7
71945: PPUSH
71946: LD_INT 124
71948: PPUSH
71949: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71953: LD_ADDR_VAR 0 3
71957: PUSH
71958: DOUBLE
71959: LD_EXP 78
71963: PUSH
71964: LD_VAR 0 2
71968: ARRAY
71969: INC
71970: ST_TO_ADDR
71971: LD_EXP 78
71975: PUSH
71976: LD_VAR 0 2
71980: ARRAY
71981: PUSH
71982: FOR_DOWNTO
71983: IFFALSE 72326
// begin if IsInUnit ( tmp ) then
71985: LD_VAR 0 7
71989: PPUSH
71990: CALL_OW 310
71994: IFFALSE 72005
// ComExitBuilding ( tmp ) ;
71996: LD_VAR 0 7
72000: PPUSH
72001: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72005: LD_INT 35
72007: PPUSH
72008: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72012: LD_VAR 0 7
72016: PPUSH
72017: CALL_OW 310
72021: NOT
72022: PUSH
72023: LD_VAR 0 7
72027: PPUSH
72028: CALL_OW 314
72032: NOT
72033: AND
72034: IFFALSE 72005
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72036: LD_ADDR_VAR 0 6
72040: PUSH
72041: LD_VAR 0 7
72045: PPUSH
72046: CALL_OW 250
72050: PUSH
72051: LD_VAR 0 7
72055: PPUSH
72056: CALL_OW 251
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72065: LD_INT 35
72067: PPUSH
72068: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72072: LD_ADDR_VAR 0 4
72076: PUSH
72077: LD_EXP 78
72081: PUSH
72082: LD_VAR 0 2
72086: ARRAY
72087: PUSH
72088: LD_VAR 0 3
72092: ARRAY
72093: PUSH
72094: LD_INT 1
72096: ARRAY
72097: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72098: LD_ADDR_VAR 0 5
72102: PUSH
72103: LD_EXP 78
72107: PUSH
72108: LD_VAR 0 2
72112: ARRAY
72113: PUSH
72114: LD_VAR 0 3
72118: ARRAY
72119: PUSH
72120: LD_INT 2
72122: ARRAY
72123: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72124: LD_VAR 0 7
72128: PPUSH
72129: LD_INT 10
72131: PPUSH
72132: CALL 17585 0 2
72136: PUSH
72137: LD_INT 4
72139: ARRAY
72140: IFFALSE 72178
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72142: LD_VAR 0 7
72146: PPUSH
72147: LD_VAR 0 6
72151: PUSH
72152: LD_INT 1
72154: ARRAY
72155: PPUSH
72156: LD_VAR 0 6
72160: PUSH
72161: LD_INT 2
72163: ARRAY
72164: PPUSH
72165: CALL_OW 111
// wait ( 0 0$10 ) ;
72169: LD_INT 350
72171: PPUSH
72172: CALL_OW 67
// end else
72176: GO 72204
// begin ComMoveXY ( tmp , x , y ) ;
72178: LD_VAR 0 7
72182: PPUSH
72183: LD_VAR 0 4
72187: PPUSH
72188: LD_VAR 0 5
72192: PPUSH
72193: CALL_OW 111
// wait ( 0 0$3 ) ;
72197: LD_INT 105
72199: PPUSH
72200: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72204: LD_VAR 0 7
72208: PPUSH
72209: LD_VAR 0 4
72213: PPUSH
72214: LD_VAR 0 5
72218: PPUSH
72219: CALL_OW 307
72223: IFFALSE 72065
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72225: LD_VAR 0 7
72229: PPUSH
72230: LD_VAR 0 4
72234: PPUSH
72235: LD_VAR 0 5
72239: PPUSH
72240: LD_VAR 0 8
72244: PUSH
72245: LD_VAR 0 3
72249: ARRAY
72250: PPUSH
72251: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72255: LD_INT 35
72257: PPUSH
72258: CALL_OW 67
// until not HasTask ( tmp ) ;
72262: LD_VAR 0 7
72266: PPUSH
72267: CALL_OW 314
72271: NOT
72272: IFFALSE 72255
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72274: LD_ADDR_EXP 79
72278: PUSH
72279: LD_EXP 79
72283: PPUSH
72284: LD_VAR 0 2
72288: PUSH
72289: LD_EXP 79
72293: PUSH
72294: LD_VAR 0 2
72298: ARRAY
72299: PUSH
72300: LD_INT 1
72302: PLUS
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PPUSH
72308: LD_VAR 0 8
72312: PUSH
72313: LD_VAR 0 3
72317: ARRAY
72318: PPUSH
72319: CALL 14988 0 3
72323: ST_TO_ADDR
// end ;
72324: GO 71982
72326: POP
72327: POP
// MC_Reset ( i , 124 ) ;
72328: LD_VAR 0 2
72332: PPUSH
72333: LD_INT 124
72335: PPUSH
72336: CALL 55433 0 2
// end ; end ;
72340: GO 71737
72342: POP
72343: POP
// end ;
72344: LD_VAR 0 1
72348: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72349: LD_INT 0
72351: PPUSH
72352: PPUSH
72353: PPUSH
// if not mc_bases then
72354: LD_EXP 43
72358: NOT
72359: IFFALSE 72363
// exit ;
72361: GO 72969
// for i = 1 to mc_bases do
72363: LD_ADDR_VAR 0 2
72367: PUSH
72368: DOUBLE
72369: LD_INT 1
72371: DEC
72372: ST_TO_ADDR
72373: LD_EXP 43
72377: PUSH
72378: FOR_TO
72379: IFFALSE 72967
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72381: LD_ADDR_VAR 0 3
72385: PUSH
72386: LD_EXP 43
72390: PUSH
72391: LD_VAR 0 2
72395: ARRAY
72396: PPUSH
72397: LD_INT 25
72399: PUSH
72400: LD_INT 4
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PPUSH
72407: CALL_OW 72
72411: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72412: LD_VAR 0 3
72416: NOT
72417: PUSH
72418: LD_EXP 80
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: NOT
72429: OR
72430: PUSH
72431: LD_EXP 43
72435: PUSH
72436: LD_VAR 0 2
72440: ARRAY
72441: PPUSH
72442: LD_INT 2
72444: PUSH
72445: LD_INT 30
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 30
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: LIST
72469: PPUSH
72470: CALL_OW 72
72474: NOT
72475: OR
72476: IFFALSE 72526
// begin if mc_deposits_finder [ i ] then
72478: LD_EXP 81
72482: PUSH
72483: LD_VAR 0 2
72487: ARRAY
72488: IFFALSE 72524
// begin MC_Reset ( i , 125 ) ;
72490: LD_VAR 0 2
72494: PPUSH
72495: LD_INT 125
72497: PPUSH
72498: CALL 55433 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72502: LD_ADDR_EXP 81
72506: PUSH
72507: LD_EXP 81
72511: PPUSH
72512: LD_VAR 0 2
72516: PPUSH
72517: EMPTY
72518: PPUSH
72519: CALL_OW 1
72523: ST_TO_ADDR
// end ; continue ;
72524: GO 72378
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72526: LD_EXP 80
72530: PUSH
72531: LD_VAR 0 2
72535: ARRAY
72536: PUSH
72537: LD_INT 1
72539: ARRAY
72540: PUSH
72541: LD_INT 3
72543: ARRAY
72544: PUSH
72545: LD_INT 1
72547: EQUAL
72548: PUSH
72549: LD_INT 20
72551: PPUSH
72552: LD_EXP 69
72556: PUSH
72557: LD_VAR 0 2
72561: ARRAY
72562: PPUSH
72563: CALL_OW 321
72567: PUSH
72568: LD_INT 2
72570: NONEQUAL
72571: AND
72572: IFFALSE 72622
// begin if mc_deposits_finder [ i ] then
72574: LD_EXP 81
72578: PUSH
72579: LD_VAR 0 2
72583: ARRAY
72584: IFFALSE 72620
// begin MC_Reset ( i , 125 ) ;
72586: LD_VAR 0 2
72590: PPUSH
72591: LD_INT 125
72593: PPUSH
72594: CALL 55433 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72598: LD_ADDR_EXP 81
72602: PUSH
72603: LD_EXP 81
72607: PPUSH
72608: LD_VAR 0 2
72612: PPUSH
72613: EMPTY
72614: PPUSH
72615: CALL_OW 1
72619: ST_TO_ADDR
// end ; continue ;
72620: GO 72378
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72622: LD_EXP 80
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PUSH
72633: LD_INT 1
72635: ARRAY
72636: PUSH
72637: LD_INT 1
72639: ARRAY
72640: PPUSH
72641: LD_EXP 80
72645: PUSH
72646: LD_VAR 0 2
72650: ARRAY
72651: PUSH
72652: LD_INT 1
72654: ARRAY
72655: PUSH
72656: LD_INT 2
72658: ARRAY
72659: PPUSH
72660: LD_EXP 69
72664: PUSH
72665: LD_VAR 0 2
72669: ARRAY
72670: PPUSH
72671: CALL_OW 440
72675: IFFALSE 72718
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72677: LD_ADDR_EXP 80
72681: PUSH
72682: LD_EXP 80
72686: PPUSH
72687: LD_VAR 0 2
72691: PPUSH
72692: LD_EXP 80
72696: PUSH
72697: LD_VAR 0 2
72701: ARRAY
72702: PPUSH
72703: LD_INT 1
72705: PPUSH
72706: CALL_OW 3
72710: PPUSH
72711: CALL_OW 1
72715: ST_TO_ADDR
72716: GO 72965
// begin if not mc_deposits_finder [ i ] then
72718: LD_EXP 81
72722: PUSH
72723: LD_VAR 0 2
72727: ARRAY
72728: NOT
72729: IFFALSE 72781
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72731: LD_ADDR_EXP 81
72735: PUSH
72736: LD_EXP 81
72740: PPUSH
72741: LD_VAR 0 2
72745: PPUSH
72746: LD_VAR 0 3
72750: PUSH
72751: LD_INT 1
72753: ARRAY
72754: PUSH
72755: EMPTY
72756: LIST
72757: PPUSH
72758: CALL_OW 1
72762: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72763: LD_VAR 0 3
72767: PUSH
72768: LD_INT 1
72770: ARRAY
72771: PPUSH
72772: LD_INT 125
72774: PPUSH
72775: CALL_OW 109
// end else
72779: GO 72965
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72781: LD_EXP 81
72785: PUSH
72786: LD_VAR 0 2
72790: ARRAY
72791: PUSH
72792: LD_INT 1
72794: ARRAY
72795: PPUSH
72796: CALL_OW 310
72800: IFFALSE 72823
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72802: LD_EXP 81
72806: PUSH
72807: LD_VAR 0 2
72811: ARRAY
72812: PUSH
72813: LD_INT 1
72815: ARRAY
72816: PPUSH
72817: CALL_OW 122
72821: GO 72965
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72823: LD_EXP 81
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: PUSH
72834: LD_INT 1
72836: ARRAY
72837: PPUSH
72838: CALL_OW 314
72842: NOT
72843: PUSH
72844: LD_EXP 81
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: PUSH
72855: LD_INT 1
72857: ARRAY
72858: PPUSH
72859: LD_EXP 80
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: PUSH
72870: LD_INT 1
72872: ARRAY
72873: PUSH
72874: LD_INT 1
72876: ARRAY
72877: PPUSH
72878: LD_EXP 80
72882: PUSH
72883: LD_VAR 0 2
72887: ARRAY
72888: PUSH
72889: LD_INT 1
72891: ARRAY
72892: PUSH
72893: LD_INT 2
72895: ARRAY
72896: PPUSH
72897: CALL_OW 297
72901: PUSH
72902: LD_INT 6
72904: GREATER
72905: AND
72906: IFFALSE 72965
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72908: LD_EXP 81
72912: PUSH
72913: LD_VAR 0 2
72917: ARRAY
72918: PUSH
72919: LD_INT 1
72921: ARRAY
72922: PPUSH
72923: LD_EXP 80
72927: PUSH
72928: LD_VAR 0 2
72932: ARRAY
72933: PUSH
72934: LD_INT 1
72936: ARRAY
72937: PUSH
72938: LD_INT 1
72940: ARRAY
72941: PPUSH
72942: LD_EXP 80
72946: PUSH
72947: LD_VAR 0 2
72951: ARRAY
72952: PUSH
72953: LD_INT 1
72955: ARRAY
72956: PUSH
72957: LD_INT 2
72959: ARRAY
72960: PPUSH
72961: CALL_OW 111
// end ; end ; end ;
72965: GO 72378
72967: POP
72968: POP
// end ;
72969: LD_VAR 0 1
72973: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72974: LD_INT 0
72976: PPUSH
72977: PPUSH
72978: PPUSH
72979: PPUSH
72980: PPUSH
72981: PPUSH
72982: PPUSH
72983: PPUSH
72984: PPUSH
72985: PPUSH
72986: PPUSH
// if not mc_bases then
72987: LD_EXP 43
72991: NOT
72992: IFFALSE 72996
// exit ;
72994: GO 73936
// for i = 1 to mc_bases do
72996: LD_ADDR_VAR 0 2
73000: PUSH
73001: DOUBLE
73002: LD_INT 1
73004: DEC
73005: ST_TO_ADDR
73006: LD_EXP 43
73010: PUSH
73011: FOR_TO
73012: IFFALSE 73934
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73014: LD_EXP 43
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: NOT
73025: PUSH
73026: LD_EXP 66
73030: PUSH
73031: LD_VAR 0 2
73035: ARRAY
73036: OR
73037: IFFALSE 73041
// continue ;
73039: GO 73011
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73041: LD_ADDR_VAR 0 7
73045: PUSH
73046: LD_EXP 43
73050: PUSH
73051: LD_VAR 0 2
73055: ARRAY
73056: PUSH
73057: LD_INT 1
73059: ARRAY
73060: PPUSH
73061: CALL_OW 248
73065: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73066: LD_VAR 0 7
73070: PUSH
73071: LD_INT 3
73073: EQUAL
73074: PUSH
73075: LD_EXP 62
73079: PUSH
73080: LD_VAR 0 2
73084: ARRAY
73085: PUSH
73086: LD_EXP 65
73090: PUSH
73091: LD_VAR 0 2
73095: ARRAY
73096: UNION
73097: PPUSH
73098: LD_INT 33
73100: PUSH
73101: LD_INT 2
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PPUSH
73108: CALL_OW 72
73112: NOT
73113: OR
73114: IFFALSE 73118
// continue ;
73116: GO 73011
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73118: LD_ADDR_VAR 0 9
73122: PUSH
73123: LD_EXP 43
73127: PUSH
73128: LD_VAR 0 2
73132: ARRAY
73133: PPUSH
73134: LD_INT 30
73136: PUSH
73137: LD_INT 36
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PPUSH
73144: CALL_OW 72
73148: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73149: LD_ADDR_VAR 0 10
73153: PUSH
73154: LD_EXP 62
73158: PUSH
73159: LD_VAR 0 2
73163: ARRAY
73164: PPUSH
73165: LD_INT 34
73167: PUSH
73168: LD_INT 31
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PPUSH
73175: CALL_OW 72
73179: ST_TO_ADDR
// if not cts and not mcts then
73180: LD_VAR 0 9
73184: NOT
73185: PUSH
73186: LD_VAR 0 10
73190: NOT
73191: AND
73192: IFFALSE 73196
// continue ;
73194: GO 73011
// x := cts ;
73196: LD_ADDR_VAR 0 11
73200: PUSH
73201: LD_VAR 0 9
73205: ST_TO_ADDR
// if not x then
73206: LD_VAR 0 11
73210: NOT
73211: IFFALSE 73223
// x := mcts ;
73213: LD_ADDR_VAR 0 11
73217: PUSH
73218: LD_VAR 0 10
73222: ST_TO_ADDR
// if not x then
73223: LD_VAR 0 11
73227: NOT
73228: IFFALSE 73232
// continue ;
73230: GO 73011
// if mc_remote_driver [ i ] then
73232: LD_EXP 83
73236: PUSH
73237: LD_VAR 0 2
73241: ARRAY
73242: IFFALSE 73629
// for j in mc_remote_driver [ i ] do
73244: LD_ADDR_VAR 0 3
73248: PUSH
73249: LD_EXP 83
73253: PUSH
73254: LD_VAR 0 2
73258: ARRAY
73259: PUSH
73260: FOR_IN
73261: IFFALSE 73627
// begin if GetClass ( j ) <> 3 then
73263: LD_VAR 0 3
73267: PPUSH
73268: CALL_OW 257
73272: PUSH
73273: LD_INT 3
73275: NONEQUAL
73276: IFFALSE 73329
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73278: LD_ADDR_EXP 83
73282: PUSH
73283: LD_EXP 83
73287: PPUSH
73288: LD_VAR 0 2
73292: PPUSH
73293: LD_EXP 83
73297: PUSH
73298: LD_VAR 0 2
73302: ARRAY
73303: PUSH
73304: LD_VAR 0 3
73308: DIFF
73309: PPUSH
73310: CALL_OW 1
73314: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73315: LD_VAR 0 3
73319: PPUSH
73320: LD_INT 0
73322: PPUSH
73323: CALL_OW 109
// continue ;
73327: GO 73260
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73329: LD_EXP 62
73333: PUSH
73334: LD_VAR 0 2
73338: ARRAY
73339: PPUSH
73340: LD_INT 34
73342: PUSH
73343: LD_INT 31
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 58
73352: PUSH
73353: EMPTY
73354: LIST
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PPUSH
73360: CALL_OW 72
73364: PUSH
73365: LD_VAR 0 3
73369: PPUSH
73370: CALL 44935 0 1
73374: NOT
73375: AND
73376: IFFALSE 73447
// begin if IsInUnit ( j ) then
73378: LD_VAR 0 3
73382: PPUSH
73383: CALL_OW 310
73387: IFFALSE 73398
// ComExitBuilding ( j ) ;
73389: LD_VAR 0 3
73393: PPUSH
73394: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73398: LD_VAR 0 3
73402: PPUSH
73403: LD_EXP 62
73407: PUSH
73408: LD_VAR 0 2
73412: ARRAY
73413: PPUSH
73414: LD_INT 34
73416: PUSH
73417: LD_INT 31
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 58
73426: PUSH
73427: EMPTY
73428: LIST
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PPUSH
73434: CALL_OW 72
73438: PUSH
73439: LD_INT 1
73441: ARRAY
73442: PPUSH
73443: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73447: LD_VAR 0 3
73451: PPUSH
73452: CALL_OW 310
73456: NOT
73457: PUSH
73458: LD_VAR 0 3
73462: PPUSH
73463: CALL_OW 310
73467: PPUSH
73468: CALL_OW 266
73472: PUSH
73473: LD_INT 36
73475: NONEQUAL
73476: PUSH
73477: LD_VAR 0 3
73481: PPUSH
73482: CALL 44935 0 1
73486: NOT
73487: AND
73488: OR
73489: IFFALSE 73625
// begin if IsInUnit ( j ) then
73491: LD_VAR 0 3
73495: PPUSH
73496: CALL_OW 310
73500: IFFALSE 73511
// ComExitBuilding ( j ) ;
73502: LD_VAR 0 3
73506: PPUSH
73507: CALL_OW 122
// ct := 0 ;
73511: LD_ADDR_VAR 0 8
73515: PUSH
73516: LD_INT 0
73518: ST_TO_ADDR
// for k in x do
73519: LD_ADDR_VAR 0 4
73523: PUSH
73524: LD_VAR 0 11
73528: PUSH
73529: FOR_IN
73530: IFFALSE 73603
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73532: LD_VAR 0 4
73536: PPUSH
73537: CALL_OW 264
73541: PUSH
73542: LD_INT 31
73544: EQUAL
73545: PUSH
73546: LD_VAR 0 4
73550: PPUSH
73551: CALL_OW 311
73555: NOT
73556: AND
73557: PUSH
73558: LD_VAR 0 4
73562: PPUSH
73563: CALL_OW 266
73567: PUSH
73568: LD_INT 36
73570: EQUAL
73571: PUSH
73572: LD_VAR 0 4
73576: PPUSH
73577: CALL_OW 313
73581: PUSH
73582: LD_INT 3
73584: LESS
73585: AND
73586: OR
73587: IFFALSE 73601
// begin ct := k ;
73589: LD_ADDR_VAR 0 8
73593: PUSH
73594: LD_VAR 0 4
73598: ST_TO_ADDR
// break ;
73599: GO 73603
// end ;
73601: GO 73529
73603: POP
73604: POP
// if ct then
73605: LD_VAR 0 8
73609: IFFALSE 73625
// ComEnterUnit ( j , ct ) ;
73611: LD_VAR 0 3
73615: PPUSH
73616: LD_VAR 0 8
73620: PPUSH
73621: CALL_OW 120
// end ; end ;
73625: GO 73260
73627: POP
73628: POP
// places := 0 ;
73629: LD_ADDR_VAR 0 5
73633: PUSH
73634: LD_INT 0
73636: ST_TO_ADDR
// for j = 1 to x do
73637: LD_ADDR_VAR 0 3
73641: PUSH
73642: DOUBLE
73643: LD_INT 1
73645: DEC
73646: ST_TO_ADDR
73647: LD_VAR 0 11
73651: PUSH
73652: FOR_TO
73653: IFFALSE 73729
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73655: LD_VAR 0 11
73659: PUSH
73660: LD_VAR 0 3
73664: ARRAY
73665: PPUSH
73666: CALL_OW 264
73670: PUSH
73671: LD_INT 31
73673: EQUAL
73674: IFFALSE 73692
// places := places + 1 else
73676: LD_ADDR_VAR 0 5
73680: PUSH
73681: LD_VAR 0 5
73685: PUSH
73686: LD_INT 1
73688: PLUS
73689: ST_TO_ADDR
73690: GO 73727
// if GetBType ( x [ j ] ) = b_control_tower then
73692: LD_VAR 0 11
73696: PUSH
73697: LD_VAR 0 3
73701: ARRAY
73702: PPUSH
73703: CALL_OW 266
73707: PUSH
73708: LD_INT 36
73710: EQUAL
73711: IFFALSE 73727
// places := places + 3 ;
73713: LD_ADDR_VAR 0 5
73717: PUSH
73718: LD_VAR 0 5
73722: PUSH
73723: LD_INT 3
73725: PLUS
73726: ST_TO_ADDR
73727: GO 73652
73729: POP
73730: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73731: LD_VAR 0 5
73735: PUSH
73736: LD_INT 0
73738: EQUAL
73739: PUSH
73740: LD_VAR 0 5
73744: PUSH
73745: LD_EXP 83
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: LESSEQUAL
73756: OR
73757: IFFALSE 73761
// continue ;
73759: GO 73011
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73761: LD_ADDR_VAR 0 6
73765: PUSH
73766: LD_EXP 43
73770: PUSH
73771: LD_VAR 0 2
73775: ARRAY
73776: PPUSH
73777: LD_INT 25
73779: PUSH
73780: LD_INT 3
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PPUSH
73787: CALL_OW 72
73791: PUSH
73792: LD_EXP 83
73796: PUSH
73797: LD_VAR 0 2
73801: ARRAY
73802: DIFF
73803: PPUSH
73804: LD_INT 3
73806: PPUSH
73807: CALL 45835 0 2
73811: ST_TO_ADDR
// for j in tmp do
73812: LD_ADDR_VAR 0 3
73816: PUSH
73817: LD_VAR 0 6
73821: PUSH
73822: FOR_IN
73823: IFFALSE 73858
// if GetTag ( j ) > 0 then
73825: LD_VAR 0 3
73829: PPUSH
73830: CALL_OW 110
73834: PUSH
73835: LD_INT 0
73837: GREATER
73838: IFFALSE 73856
// tmp := tmp diff j ;
73840: LD_ADDR_VAR 0 6
73844: PUSH
73845: LD_VAR 0 6
73849: PUSH
73850: LD_VAR 0 3
73854: DIFF
73855: ST_TO_ADDR
73856: GO 73822
73858: POP
73859: POP
// if not tmp then
73860: LD_VAR 0 6
73864: NOT
73865: IFFALSE 73869
// continue ;
73867: GO 73011
// if places then
73869: LD_VAR 0 5
73873: IFFALSE 73932
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73875: LD_ADDR_EXP 83
73879: PUSH
73880: LD_EXP 83
73884: PPUSH
73885: LD_VAR 0 2
73889: PPUSH
73890: LD_EXP 83
73894: PUSH
73895: LD_VAR 0 2
73899: ARRAY
73900: PUSH
73901: LD_VAR 0 6
73905: PUSH
73906: LD_INT 1
73908: ARRAY
73909: UNION
73910: PPUSH
73911: CALL_OW 1
73915: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73916: LD_VAR 0 6
73920: PUSH
73921: LD_INT 1
73923: ARRAY
73924: PPUSH
73925: LD_INT 126
73927: PPUSH
73928: CALL_OW 109
// end ; end ;
73932: GO 73011
73934: POP
73935: POP
// end ;
73936: LD_VAR 0 1
73940: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73941: LD_INT 0
73943: PPUSH
73944: PPUSH
73945: PPUSH
73946: PPUSH
73947: PPUSH
73948: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73949: LD_VAR 0 1
73953: NOT
73954: PUSH
73955: LD_VAR 0 2
73959: NOT
73960: OR
73961: PUSH
73962: LD_VAR 0 3
73966: NOT
73967: OR
73968: PUSH
73969: LD_VAR 0 4
73973: PUSH
73974: LD_INT 1
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: LD_INT 3
73982: PUSH
73983: LD_INT 4
73985: PUSH
73986: LD_INT 5
73988: PUSH
73989: LD_INT 8
73991: PUSH
73992: LD_INT 9
73994: PUSH
73995: LD_INT 15
73997: PUSH
73998: LD_INT 16
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: IN
74012: NOT
74013: OR
74014: IFFALSE 74018
// exit ;
74016: GO 74918
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74018: LD_ADDR_VAR 0 2
74022: PUSH
74023: LD_VAR 0 2
74027: PPUSH
74028: LD_INT 21
74030: PUSH
74031: LD_INT 3
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PUSH
74038: LD_INT 24
74040: PUSH
74041: LD_INT 250
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PPUSH
74052: CALL_OW 72
74056: ST_TO_ADDR
// case class of 1 , 15 :
74057: LD_VAR 0 4
74061: PUSH
74062: LD_INT 1
74064: DOUBLE
74065: EQUAL
74066: IFTRUE 74076
74068: LD_INT 15
74070: DOUBLE
74071: EQUAL
74072: IFTRUE 74076
74074: GO 74161
74076: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74077: LD_ADDR_VAR 0 8
74081: PUSH
74082: LD_VAR 0 2
74086: PPUSH
74087: LD_INT 2
74089: PUSH
74090: LD_INT 30
74092: PUSH
74093: LD_INT 32
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 30
74102: PUSH
74103: LD_INT 31
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: LIST
74114: PPUSH
74115: CALL_OW 72
74119: PUSH
74120: LD_VAR 0 2
74124: PPUSH
74125: LD_INT 2
74127: PUSH
74128: LD_INT 30
74130: PUSH
74131: LD_INT 4
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 30
74140: PUSH
74141: LD_INT 5
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: LIST
74152: PPUSH
74153: CALL_OW 72
74157: ADD
74158: ST_TO_ADDR
74159: GO 74407
74161: LD_INT 2
74163: DOUBLE
74164: EQUAL
74165: IFTRUE 74175
74167: LD_INT 16
74169: DOUBLE
74170: EQUAL
74171: IFTRUE 74175
74173: GO 74221
74175: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74176: LD_ADDR_VAR 0 8
74180: PUSH
74181: LD_VAR 0 2
74185: PPUSH
74186: LD_INT 2
74188: PUSH
74189: LD_INT 30
74191: PUSH
74192: LD_INT 0
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: LD_INT 30
74201: PUSH
74202: LD_INT 1
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: LIST
74213: PPUSH
74214: CALL_OW 72
74218: ST_TO_ADDR
74219: GO 74407
74221: LD_INT 3
74223: DOUBLE
74224: EQUAL
74225: IFTRUE 74229
74227: GO 74275
74229: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74230: LD_ADDR_VAR 0 8
74234: PUSH
74235: LD_VAR 0 2
74239: PPUSH
74240: LD_INT 2
74242: PUSH
74243: LD_INT 30
74245: PUSH
74246: LD_INT 2
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 30
74255: PUSH
74256: LD_INT 3
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: LIST
74267: PPUSH
74268: CALL_OW 72
74272: ST_TO_ADDR
74273: GO 74407
74275: LD_INT 4
74277: DOUBLE
74278: EQUAL
74279: IFTRUE 74283
74281: GO 74340
74283: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74284: LD_ADDR_VAR 0 8
74288: PUSH
74289: LD_VAR 0 2
74293: PPUSH
74294: LD_INT 2
74296: PUSH
74297: LD_INT 30
74299: PUSH
74300: LD_INT 6
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 30
74309: PUSH
74310: LD_INT 7
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 30
74319: PUSH
74320: LD_INT 8
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: PPUSH
74333: CALL_OW 72
74337: ST_TO_ADDR
74338: GO 74407
74340: LD_INT 5
74342: DOUBLE
74343: EQUAL
74344: IFTRUE 74360
74346: LD_INT 8
74348: DOUBLE
74349: EQUAL
74350: IFTRUE 74360
74352: LD_INT 9
74354: DOUBLE
74355: EQUAL
74356: IFTRUE 74360
74358: GO 74406
74360: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74361: LD_ADDR_VAR 0 8
74365: PUSH
74366: LD_VAR 0 2
74370: PPUSH
74371: LD_INT 2
74373: PUSH
74374: LD_INT 30
74376: PUSH
74377: LD_INT 4
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 30
74386: PUSH
74387: LD_INT 5
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: LIST
74398: PPUSH
74399: CALL_OW 72
74403: ST_TO_ADDR
74404: GO 74407
74406: POP
// if not tmp then
74407: LD_VAR 0 8
74411: NOT
74412: IFFALSE 74416
// exit ;
74414: GO 74918
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74416: LD_VAR 0 4
74420: PUSH
74421: LD_INT 1
74423: PUSH
74424: LD_INT 15
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: IN
74431: PUSH
74432: LD_EXP 52
74436: PUSH
74437: LD_VAR 0 1
74441: ARRAY
74442: AND
74443: IFFALSE 74599
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74445: LD_ADDR_VAR 0 9
74449: PUSH
74450: LD_EXP 52
74454: PUSH
74455: LD_VAR 0 1
74459: ARRAY
74460: PUSH
74461: LD_INT 1
74463: ARRAY
74464: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74465: LD_VAR 0 9
74469: PUSH
74470: LD_EXP 53
74474: PUSH
74475: LD_VAR 0 1
74479: ARRAY
74480: IN
74481: NOT
74482: IFFALSE 74597
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74484: LD_ADDR_EXP 53
74488: PUSH
74489: LD_EXP 53
74493: PPUSH
74494: LD_VAR 0 1
74498: PUSH
74499: LD_EXP 53
74503: PUSH
74504: LD_VAR 0 1
74508: ARRAY
74509: PUSH
74510: LD_INT 1
74512: PLUS
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PPUSH
74518: LD_VAR 0 9
74522: PPUSH
74523: CALL 14988 0 3
74527: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74528: LD_ADDR_EXP 52
74532: PUSH
74533: LD_EXP 52
74537: PPUSH
74538: LD_VAR 0 1
74542: PPUSH
74543: LD_EXP 52
74547: PUSH
74548: LD_VAR 0 1
74552: ARRAY
74553: PUSH
74554: LD_VAR 0 9
74558: DIFF
74559: PPUSH
74560: CALL_OW 1
74564: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74565: LD_VAR 0 3
74569: PPUSH
74570: LD_EXP 53
74574: PUSH
74575: LD_VAR 0 1
74579: ARRAY
74580: PUSH
74581: LD_EXP 53
74585: PUSH
74586: LD_VAR 0 1
74590: ARRAY
74591: ARRAY
74592: PPUSH
74593: CALL_OW 120
// end ; exit ;
74597: GO 74918
// end ; if tmp > 1 then
74599: LD_VAR 0 8
74603: PUSH
74604: LD_INT 1
74606: GREATER
74607: IFFALSE 74711
// for i = 2 to tmp do
74609: LD_ADDR_VAR 0 6
74613: PUSH
74614: DOUBLE
74615: LD_INT 2
74617: DEC
74618: ST_TO_ADDR
74619: LD_VAR 0 8
74623: PUSH
74624: FOR_TO
74625: IFFALSE 74709
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74627: LD_VAR 0 8
74631: PUSH
74632: LD_VAR 0 6
74636: ARRAY
74637: PPUSH
74638: CALL_OW 461
74642: PUSH
74643: LD_INT 6
74645: EQUAL
74646: IFFALSE 74707
// begin x := tmp [ i ] ;
74648: LD_ADDR_VAR 0 9
74652: PUSH
74653: LD_VAR 0 8
74657: PUSH
74658: LD_VAR 0 6
74662: ARRAY
74663: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74664: LD_ADDR_VAR 0 8
74668: PUSH
74669: LD_VAR 0 8
74673: PPUSH
74674: LD_VAR 0 6
74678: PPUSH
74679: CALL_OW 3
74683: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74684: LD_ADDR_VAR 0 8
74688: PUSH
74689: LD_VAR 0 8
74693: PPUSH
74694: LD_INT 1
74696: PPUSH
74697: LD_VAR 0 9
74701: PPUSH
74702: CALL_OW 2
74706: ST_TO_ADDR
// end ;
74707: GO 74624
74709: POP
74710: POP
// for i in tmp do
74711: LD_ADDR_VAR 0 6
74715: PUSH
74716: LD_VAR 0 8
74720: PUSH
74721: FOR_IN
74722: IFFALSE 74791
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74724: LD_VAR 0 6
74728: PPUSH
74729: CALL_OW 313
74733: PUSH
74734: LD_INT 6
74736: LESS
74737: PUSH
74738: LD_VAR 0 6
74742: PPUSH
74743: CALL_OW 266
74747: PUSH
74748: LD_INT 31
74750: PUSH
74751: LD_INT 32
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: IN
74758: NOT
74759: AND
74760: PUSH
74761: LD_VAR 0 6
74765: PPUSH
74766: CALL_OW 313
74770: PUSH
74771: LD_INT 0
74773: EQUAL
74774: OR
74775: IFFALSE 74789
// begin j := i ;
74777: LD_ADDR_VAR 0 7
74781: PUSH
74782: LD_VAR 0 6
74786: ST_TO_ADDR
// break ;
74787: GO 74791
// end ; end ;
74789: GO 74721
74791: POP
74792: POP
// if j then
74793: LD_VAR 0 7
74797: IFFALSE 74815
// ComEnterUnit ( unit , j ) else
74799: LD_VAR 0 3
74803: PPUSH
74804: LD_VAR 0 7
74808: PPUSH
74809: CALL_OW 120
74813: GO 74918
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74815: LD_ADDR_VAR 0 10
74819: PUSH
74820: LD_VAR 0 2
74824: PPUSH
74825: LD_INT 2
74827: PUSH
74828: LD_INT 30
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 30
74840: PUSH
74841: LD_INT 1
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: LIST
74852: PPUSH
74853: CALL_OW 72
74857: ST_TO_ADDR
// if depot then
74858: LD_VAR 0 10
74862: IFFALSE 74918
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74864: LD_ADDR_VAR 0 10
74868: PUSH
74869: LD_VAR 0 10
74873: PPUSH
74874: LD_VAR 0 3
74878: PPUSH
74879: CALL_OW 74
74883: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74884: LD_VAR 0 3
74888: PPUSH
74889: LD_VAR 0 10
74893: PPUSH
74894: CALL_OW 296
74898: PUSH
74899: LD_INT 10
74901: GREATER
74902: IFFALSE 74918
// ComStandNearbyBuilding ( unit , depot ) ;
74904: LD_VAR 0 3
74908: PPUSH
74909: LD_VAR 0 10
74913: PPUSH
74914: CALL 11415 0 2
// end ; end ; end ;
74918: LD_VAR 0 5
74922: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74923: LD_INT 0
74925: PPUSH
74926: PPUSH
74927: PPUSH
74928: PPUSH
// if not mc_bases then
74929: LD_EXP 43
74933: NOT
74934: IFFALSE 74938
// exit ;
74936: GO 75177
// for i = 1 to mc_bases do
74938: LD_ADDR_VAR 0 2
74942: PUSH
74943: DOUBLE
74944: LD_INT 1
74946: DEC
74947: ST_TO_ADDR
74948: LD_EXP 43
74952: PUSH
74953: FOR_TO
74954: IFFALSE 75175
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74956: LD_ADDR_VAR 0 4
74960: PUSH
74961: LD_EXP 43
74965: PUSH
74966: LD_VAR 0 2
74970: ARRAY
74971: PPUSH
74972: LD_INT 21
74974: PUSH
74975: LD_INT 1
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PPUSH
74982: CALL_OW 72
74986: PUSH
74987: LD_EXP 72
74991: PUSH
74992: LD_VAR 0 2
74996: ARRAY
74997: UNION
74998: ST_TO_ADDR
// if not tmp then
74999: LD_VAR 0 4
75003: NOT
75004: IFFALSE 75008
// continue ;
75006: GO 74953
// for j in tmp do
75008: LD_ADDR_VAR 0 3
75012: PUSH
75013: LD_VAR 0 4
75017: PUSH
75018: FOR_IN
75019: IFFALSE 75171
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75021: LD_VAR 0 3
75025: PPUSH
75026: CALL_OW 110
75030: NOT
75031: PUSH
75032: LD_VAR 0 3
75036: PPUSH
75037: CALL_OW 314
75041: NOT
75042: AND
75043: PUSH
75044: LD_VAR 0 3
75048: PPUSH
75049: CALL_OW 311
75053: NOT
75054: AND
75055: PUSH
75056: LD_VAR 0 3
75060: PPUSH
75061: CALL_OW 310
75065: NOT
75066: AND
75067: PUSH
75068: LD_VAR 0 3
75072: PUSH
75073: LD_EXP 46
75077: PUSH
75078: LD_VAR 0 2
75082: ARRAY
75083: PUSH
75084: LD_INT 1
75086: ARRAY
75087: IN
75088: NOT
75089: AND
75090: PUSH
75091: LD_VAR 0 3
75095: PUSH
75096: LD_EXP 46
75100: PUSH
75101: LD_VAR 0 2
75105: ARRAY
75106: PUSH
75107: LD_INT 2
75109: ARRAY
75110: IN
75111: NOT
75112: AND
75113: PUSH
75114: LD_VAR 0 3
75118: PUSH
75119: LD_EXP 55
75123: PUSH
75124: LD_VAR 0 2
75128: ARRAY
75129: IN
75130: NOT
75131: AND
75132: IFFALSE 75169
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75134: LD_VAR 0 2
75138: PPUSH
75139: LD_EXP 43
75143: PUSH
75144: LD_VAR 0 2
75148: ARRAY
75149: PPUSH
75150: LD_VAR 0 3
75154: PPUSH
75155: LD_VAR 0 3
75159: PPUSH
75160: CALL_OW 257
75164: PPUSH
75165: CALL 73941 0 4
// end ;
75169: GO 75018
75171: POP
75172: POP
// end ;
75173: GO 74953
75175: POP
75176: POP
// end ;
75177: LD_VAR 0 1
75181: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75182: LD_INT 0
75184: PPUSH
75185: PPUSH
75186: PPUSH
75187: PPUSH
75188: PPUSH
75189: PPUSH
// if not mc_bases [ base ] then
75190: LD_EXP 43
75194: PUSH
75195: LD_VAR 0 1
75199: ARRAY
75200: NOT
75201: IFFALSE 75205
// exit ;
75203: GO 75387
// tmp := [ ] ;
75205: LD_ADDR_VAR 0 6
75209: PUSH
75210: EMPTY
75211: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75212: LD_ADDR_VAR 0 7
75216: PUSH
75217: LD_VAR 0 3
75221: PPUSH
75222: LD_INT 0
75224: PPUSH
75225: CALL_OW 517
75229: ST_TO_ADDR
// if not list then
75230: LD_VAR 0 7
75234: NOT
75235: IFFALSE 75239
// exit ;
75237: GO 75387
// for i = 1 to amount do
75239: LD_ADDR_VAR 0 5
75243: PUSH
75244: DOUBLE
75245: LD_INT 1
75247: DEC
75248: ST_TO_ADDR
75249: LD_VAR 0 2
75253: PUSH
75254: FOR_TO
75255: IFFALSE 75335
// begin x := rand ( 1 , list [ 1 ] ) ;
75257: LD_ADDR_VAR 0 8
75261: PUSH
75262: LD_INT 1
75264: PPUSH
75265: LD_VAR 0 7
75269: PUSH
75270: LD_INT 1
75272: ARRAY
75273: PPUSH
75274: CALL_OW 12
75278: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75279: LD_ADDR_VAR 0 6
75283: PUSH
75284: LD_VAR 0 6
75288: PPUSH
75289: LD_VAR 0 5
75293: PPUSH
75294: LD_VAR 0 7
75298: PUSH
75299: LD_INT 1
75301: ARRAY
75302: PUSH
75303: LD_VAR 0 8
75307: ARRAY
75308: PUSH
75309: LD_VAR 0 7
75313: PUSH
75314: LD_INT 2
75316: ARRAY
75317: PUSH
75318: LD_VAR 0 8
75322: ARRAY
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PPUSH
75328: CALL_OW 1
75332: ST_TO_ADDR
// end ;
75333: GO 75254
75335: POP
75336: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75337: LD_ADDR_EXP 56
75341: PUSH
75342: LD_EXP 56
75346: PPUSH
75347: LD_VAR 0 1
75351: PPUSH
75352: LD_VAR 0 6
75356: PPUSH
75357: CALL_OW 1
75361: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75362: LD_ADDR_EXP 58
75366: PUSH
75367: LD_EXP 58
75371: PPUSH
75372: LD_VAR 0 1
75376: PPUSH
75377: LD_VAR 0 3
75381: PPUSH
75382: CALL_OW 1
75386: ST_TO_ADDR
// end ;
75387: LD_VAR 0 4
75391: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75392: LD_INT 0
75394: PPUSH
// if not mc_bases [ base ] then
75395: LD_EXP 43
75399: PUSH
75400: LD_VAR 0 1
75404: ARRAY
75405: NOT
75406: IFFALSE 75410
// exit ;
75408: GO 75435
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75410: LD_ADDR_EXP 48
75414: PUSH
75415: LD_EXP 48
75419: PPUSH
75420: LD_VAR 0 1
75424: PPUSH
75425: LD_VAR 0 2
75429: PPUSH
75430: CALL_OW 1
75434: ST_TO_ADDR
// end ;
75435: LD_VAR 0 3
75439: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75440: LD_INT 0
75442: PPUSH
// if not mc_bases [ base ] then
75443: LD_EXP 43
75447: PUSH
75448: LD_VAR 0 1
75452: ARRAY
75453: NOT
75454: IFFALSE 75458
// exit ;
75456: GO 75495
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75458: LD_ADDR_EXP 48
75462: PUSH
75463: LD_EXP 48
75467: PPUSH
75468: LD_VAR 0 1
75472: PPUSH
75473: LD_EXP 48
75477: PUSH
75478: LD_VAR 0 1
75482: ARRAY
75483: PUSH
75484: LD_VAR 0 2
75488: UNION
75489: PPUSH
75490: CALL_OW 1
75494: ST_TO_ADDR
// end ;
75495: LD_VAR 0 3
75499: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75500: LD_INT 0
75502: PPUSH
// if not mc_bases [ base ] then
75503: LD_EXP 43
75507: PUSH
75508: LD_VAR 0 1
75512: ARRAY
75513: NOT
75514: IFFALSE 75518
// exit ;
75516: GO 75543
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75518: LD_ADDR_EXP 64
75522: PUSH
75523: LD_EXP 64
75527: PPUSH
75528: LD_VAR 0 1
75532: PPUSH
75533: LD_VAR 0 2
75537: PPUSH
75538: CALL_OW 1
75542: ST_TO_ADDR
// end ;
75543: LD_VAR 0 3
75547: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75548: LD_INT 0
75550: PPUSH
// if not mc_bases [ base ] then
75551: LD_EXP 43
75555: PUSH
75556: LD_VAR 0 1
75560: ARRAY
75561: NOT
75562: IFFALSE 75566
// exit ;
75564: GO 75603
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75566: LD_ADDR_EXP 64
75570: PUSH
75571: LD_EXP 64
75575: PPUSH
75576: LD_VAR 0 1
75580: PPUSH
75581: LD_EXP 64
75585: PUSH
75586: LD_VAR 0 1
75590: ARRAY
75591: PUSH
75592: LD_VAR 0 2
75596: ADD
75597: PPUSH
75598: CALL_OW 1
75602: ST_TO_ADDR
// end ;
75603: LD_VAR 0 3
75607: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75608: LD_INT 0
75610: PPUSH
// if not mc_bases [ base ] then
75611: LD_EXP 43
75615: PUSH
75616: LD_VAR 0 1
75620: ARRAY
75621: NOT
75622: IFFALSE 75626
// exit ;
75624: GO 75680
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75626: LD_ADDR_EXP 65
75630: PUSH
75631: LD_EXP 65
75635: PPUSH
75636: LD_VAR 0 1
75640: PPUSH
75641: LD_VAR 0 2
75645: PPUSH
75646: CALL_OW 1
75650: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75651: LD_ADDR_EXP 54
75655: PUSH
75656: LD_EXP 54
75660: PPUSH
75661: LD_VAR 0 1
75665: PPUSH
75666: LD_VAR 0 2
75670: PUSH
75671: LD_INT 0
75673: PLUS
75674: PPUSH
75675: CALL_OW 1
75679: ST_TO_ADDR
// end ;
75680: LD_VAR 0 3
75684: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75685: LD_INT 0
75687: PPUSH
// if not mc_bases [ base ] then
75688: LD_EXP 43
75692: PUSH
75693: LD_VAR 0 1
75697: ARRAY
75698: NOT
75699: IFFALSE 75703
// exit ;
75701: GO 75728
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75703: LD_ADDR_EXP 54
75707: PUSH
75708: LD_EXP 54
75712: PPUSH
75713: LD_VAR 0 1
75717: PPUSH
75718: LD_VAR 0 2
75722: PPUSH
75723: CALL_OW 1
75727: ST_TO_ADDR
// end ;
75728: LD_VAR 0 3
75732: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75733: LD_INT 0
75735: PPUSH
75736: PPUSH
75737: PPUSH
75738: PPUSH
// if not mc_bases [ base ] then
75739: LD_EXP 43
75743: PUSH
75744: LD_VAR 0 1
75748: ARRAY
75749: NOT
75750: IFFALSE 75754
// exit ;
75752: GO 75819
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75754: LD_ADDR_EXP 63
75758: PUSH
75759: LD_EXP 63
75763: PPUSH
75764: LD_VAR 0 1
75768: PUSH
75769: LD_EXP 63
75773: PUSH
75774: LD_VAR 0 1
75778: ARRAY
75779: PUSH
75780: LD_INT 1
75782: PLUS
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PPUSH
75788: LD_VAR 0 1
75792: PUSH
75793: LD_VAR 0 2
75797: PUSH
75798: LD_VAR 0 3
75802: PUSH
75803: LD_VAR 0 4
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: PPUSH
75814: CALL 14988 0 3
75818: ST_TO_ADDR
// end ;
75819: LD_VAR 0 5
75823: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75824: LD_INT 0
75826: PPUSH
// if not mc_bases [ base ] then
75827: LD_EXP 43
75831: PUSH
75832: LD_VAR 0 1
75836: ARRAY
75837: NOT
75838: IFFALSE 75842
// exit ;
75840: GO 75867
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75842: LD_ADDR_EXP 80
75846: PUSH
75847: LD_EXP 80
75851: PPUSH
75852: LD_VAR 0 1
75856: PPUSH
75857: LD_VAR 0 2
75861: PPUSH
75862: CALL_OW 1
75866: ST_TO_ADDR
// end ;
75867: LD_VAR 0 3
75871: RET
// export function MC_GetMinesField ( base ) ; begin
75872: LD_INT 0
75874: PPUSH
// result := mc_mines [ base ] ;
75875: LD_ADDR_VAR 0 2
75879: PUSH
75880: LD_EXP 56
75884: PUSH
75885: LD_VAR 0 1
75889: ARRAY
75890: ST_TO_ADDR
// end ;
75891: LD_VAR 0 2
75895: RET
// export function MC_GetProduceList ( base ) ; begin
75896: LD_INT 0
75898: PPUSH
// result := mc_produce [ base ] ;
75899: LD_ADDR_VAR 0 2
75903: PUSH
75904: LD_EXP 64
75908: PUSH
75909: LD_VAR 0 1
75913: ARRAY
75914: ST_TO_ADDR
// end ;
75915: LD_VAR 0 2
75919: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75920: LD_INT 0
75922: PPUSH
75923: PPUSH
// if not mc_bases then
75924: LD_EXP 43
75928: NOT
75929: IFFALSE 75933
// exit ;
75931: GO 75998
// if mc_bases [ base ] then
75933: LD_EXP 43
75937: PUSH
75938: LD_VAR 0 1
75942: ARRAY
75943: IFFALSE 75998
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75945: LD_ADDR_VAR 0 3
75949: PUSH
75950: LD_EXP 43
75954: PUSH
75955: LD_VAR 0 1
75959: ARRAY
75960: PPUSH
75961: LD_INT 30
75963: PUSH
75964: LD_VAR 0 2
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PPUSH
75973: CALL_OW 72
75977: ST_TO_ADDR
// if result then
75978: LD_VAR 0 3
75982: IFFALSE 75998
// result := result [ 1 ] ;
75984: LD_ADDR_VAR 0 3
75988: PUSH
75989: LD_VAR 0 3
75993: PUSH
75994: LD_INT 1
75996: ARRAY
75997: ST_TO_ADDR
// end ; end ;
75998: LD_VAR 0 3
76002: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76003: LD_INT 0
76005: PPUSH
76006: PPUSH
// if not mc_bases then
76007: LD_EXP 43
76011: NOT
76012: IFFALSE 76016
// exit ;
76014: GO 76061
// if mc_bases [ base ] then
76016: LD_EXP 43
76020: PUSH
76021: LD_VAR 0 1
76025: ARRAY
76026: IFFALSE 76061
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76028: LD_ADDR_VAR 0 3
76032: PUSH
76033: LD_EXP 43
76037: PUSH
76038: LD_VAR 0 1
76042: ARRAY
76043: PPUSH
76044: LD_INT 30
76046: PUSH
76047: LD_VAR 0 2
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PPUSH
76056: CALL_OW 72
76060: ST_TO_ADDR
// end ;
76061: LD_VAR 0 3
76065: RET
// export function MC_SetTame ( base , area ) ; begin
76066: LD_INT 0
76068: PPUSH
// if not mc_bases or not base then
76069: LD_EXP 43
76073: NOT
76074: PUSH
76075: LD_VAR 0 1
76079: NOT
76080: OR
76081: IFFALSE 76085
// exit ;
76083: GO 76110
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76085: LD_ADDR_EXP 71
76089: PUSH
76090: LD_EXP 71
76094: PPUSH
76095: LD_VAR 0 1
76099: PPUSH
76100: LD_VAR 0 2
76104: PPUSH
76105: CALL_OW 1
76109: ST_TO_ADDR
// end ;
76110: LD_VAR 0 3
76114: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76115: LD_INT 0
76117: PPUSH
76118: PPUSH
// if not mc_bases or not base then
76119: LD_EXP 43
76123: NOT
76124: PUSH
76125: LD_VAR 0 1
76129: NOT
76130: OR
76131: IFFALSE 76135
// exit ;
76133: GO 76237
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76135: LD_ADDR_VAR 0 4
76139: PUSH
76140: LD_EXP 43
76144: PUSH
76145: LD_VAR 0 1
76149: ARRAY
76150: PPUSH
76151: LD_INT 30
76153: PUSH
76154: LD_VAR 0 2
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PPUSH
76163: CALL_OW 72
76167: ST_TO_ADDR
// if not tmp then
76168: LD_VAR 0 4
76172: NOT
76173: IFFALSE 76177
// exit ;
76175: GO 76237
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76177: LD_ADDR_EXP 75
76181: PUSH
76182: LD_EXP 75
76186: PPUSH
76187: LD_VAR 0 1
76191: PPUSH
76192: LD_EXP 75
76196: PUSH
76197: LD_VAR 0 1
76201: ARRAY
76202: PPUSH
76203: LD_EXP 75
76207: PUSH
76208: LD_VAR 0 1
76212: ARRAY
76213: PUSH
76214: LD_INT 1
76216: PLUS
76217: PPUSH
76218: LD_VAR 0 4
76222: PUSH
76223: LD_INT 1
76225: ARRAY
76226: PPUSH
76227: CALL_OW 2
76231: PPUSH
76232: CALL_OW 1
76236: ST_TO_ADDR
// end ;
76237: LD_VAR 0 3
76241: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76242: LD_INT 0
76244: PPUSH
76245: PPUSH
// if not mc_bases or not base or not kinds then
76246: LD_EXP 43
76250: NOT
76251: PUSH
76252: LD_VAR 0 1
76256: NOT
76257: OR
76258: PUSH
76259: LD_VAR 0 2
76263: NOT
76264: OR
76265: IFFALSE 76269
// exit ;
76267: GO 76330
// for i in kinds do
76269: LD_ADDR_VAR 0 4
76273: PUSH
76274: LD_VAR 0 2
76278: PUSH
76279: FOR_IN
76280: IFFALSE 76328
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76282: LD_ADDR_EXP 77
76286: PUSH
76287: LD_EXP 77
76291: PPUSH
76292: LD_VAR 0 1
76296: PUSH
76297: LD_EXP 77
76301: PUSH
76302: LD_VAR 0 1
76306: ARRAY
76307: PUSH
76308: LD_INT 1
76310: PLUS
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PPUSH
76316: LD_VAR 0 4
76320: PPUSH
76321: CALL 14988 0 3
76325: ST_TO_ADDR
76326: GO 76279
76328: POP
76329: POP
// end ;
76330: LD_VAR 0 3
76334: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76335: LD_INT 0
76337: PPUSH
// if not mc_bases or not base or not areas then
76338: LD_EXP 43
76342: NOT
76343: PUSH
76344: LD_VAR 0 1
76348: NOT
76349: OR
76350: PUSH
76351: LD_VAR 0 2
76355: NOT
76356: OR
76357: IFFALSE 76361
// exit ;
76359: GO 76386
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76361: LD_ADDR_EXP 61
76365: PUSH
76366: LD_EXP 61
76370: PPUSH
76371: LD_VAR 0 1
76375: PPUSH
76376: LD_VAR 0 2
76380: PPUSH
76381: CALL_OW 1
76385: ST_TO_ADDR
// end ;
76386: LD_VAR 0 3
76390: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76391: LD_INT 0
76393: PPUSH
// if not mc_bases or not base or not teleports_exit then
76394: LD_EXP 43
76398: NOT
76399: PUSH
76400: LD_VAR 0 1
76404: NOT
76405: OR
76406: PUSH
76407: LD_VAR 0 2
76411: NOT
76412: OR
76413: IFFALSE 76417
// exit ;
76415: GO 76442
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76417: LD_ADDR_EXP 78
76421: PUSH
76422: LD_EXP 78
76426: PPUSH
76427: LD_VAR 0 1
76431: PPUSH
76432: LD_VAR 0 2
76436: PPUSH
76437: CALL_OW 1
76441: ST_TO_ADDR
// end ;
76442: LD_VAR 0 3
76446: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76447: LD_INT 0
76449: PPUSH
76450: PPUSH
76451: PPUSH
// if not mc_bases or not base or not ext_list then
76452: LD_EXP 43
76456: NOT
76457: PUSH
76458: LD_VAR 0 1
76462: NOT
76463: OR
76464: PUSH
76465: LD_VAR 0 5
76469: NOT
76470: OR
76471: IFFALSE 76475
// exit ;
76473: GO 76648
// tmp := GetFacExtXYD ( x , y , d ) ;
76475: LD_ADDR_VAR 0 8
76479: PUSH
76480: LD_VAR 0 2
76484: PPUSH
76485: LD_VAR 0 3
76489: PPUSH
76490: LD_VAR 0 4
76494: PPUSH
76495: CALL 44965 0 3
76499: ST_TO_ADDR
// if not tmp then
76500: LD_VAR 0 8
76504: NOT
76505: IFFALSE 76509
// exit ;
76507: GO 76648
// for i in tmp do
76509: LD_ADDR_VAR 0 7
76513: PUSH
76514: LD_VAR 0 8
76518: PUSH
76519: FOR_IN
76520: IFFALSE 76646
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76522: LD_ADDR_EXP 48
76526: PUSH
76527: LD_EXP 48
76531: PPUSH
76532: LD_VAR 0 1
76536: PPUSH
76537: LD_EXP 48
76541: PUSH
76542: LD_VAR 0 1
76546: ARRAY
76547: PPUSH
76548: LD_EXP 48
76552: PUSH
76553: LD_VAR 0 1
76557: ARRAY
76558: PUSH
76559: LD_INT 1
76561: PLUS
76562: PPUSH
76563: LD_VAR 0 5
76567: PUSH
76568: LD_INT 1
76570: ARRAY
76571: PUSH
76572: LD_VAR 0 7
76576: PUSH
76577: LD_INT 1
76579: ARRAY
76580: PUSH
76581: LD_VAR 0 7
76585: PUSH
76586: LD_INT 2
76588: ARRAY
76589: PUSH
76590: LD_VAR 0 7
76594: PUSH
76595: LD_INT 3
76597: ARRAY
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: PPUSH
76605: CALL_OW 2
76609: PPUSH
76610: CALL_OW 1
76614: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76615: LD_ADDR_VAR 0 5
76619: PUSH
76620: LD_VAR 0 5
76624: PPUSH
76625: LD_INT 1
76627: PPUSH
76628: CALL_OW 3
76632: ST_TO_ADDR
// if not ext_list then
76633: LD_VAR 0 5
76637: NOT
76638: IFFALSE 76644
// exit ;
76640: POP
76641: POP
76642: GO 76648
// end ;
76644: GO 76519
76646: POP
76647: POP
// end ;
76648: LD_VAR 0 6
76652: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76653: LD_INT 0
76655: PPUSH
// if not mc_bases or not base or not weapon_list then
76656: LD_EXP 43
76660: NOT
76661: PUSH
76662: LD_VAR 0 1
76666: NOT
76667: OR
76668: PUSH
76669: LD_VAR 0 2
76673: NOT
76674: OR
76675: IFFALSE 76679
// exit ;
76677: GO 76704
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76679: LD_ADDR_EXP 82
76683: PUSH
76684: LD_EXP 82
76688: PPUSH
76689: LD_VAR 0 1
76693: PPUSH
76694: LD_VAR 0 2
76698: PPUSH
76699: CALL_OW 1
76703: ST_TO_ADDR
// end ;
76704: LD_VAR 0 3
76708: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76709: LD_INT 0
76711: PPUSH
// if not mc_bases or not base or not tech_list then
76712: LD_EXP 43
76716: NOT
76717: PUSH
76718: LD_VAR 0 1
76722: NOT
76723: OR
76724: PUSH
76725: LD_VAR 0 2
76729: NOT
76730: OR
76731: IFFALSE 76735
// exit ;
76733: GO 76760
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76735: LD_ADDR_EXP 70
76739: PUSH
76740: LD_EXP 70
76744: PPUSH
76745: LD_VAR 0 1
76749: PPUSH
76750: LD_VAR 0 2
76754: PPUSH
76755: CALL_OW 1
76759: ST_TO_ADDR
// end ;
76760: LD_VAR 0 3
76764: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76765: LD_INT 0
76767: PPUSH
// if not mc_bases or not parking_area or not base then
76768: LD_EXP 43
76772: NOT
76773: PUSH
76774: LD_VAR 0 2
76778: NOT
76779: OR
76780: PUSH
76781: LD_VAR 0 1
76785: NOT
76786: OR
76787: IFFALSE 76791
// exit ;
76789: GO 76816
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76791: LD_ADDR_EXP 67
76795: PUSH
76796: LD_EXP 67
76800: PPUSH
76801: LD_VAR 0 1
76805: PPUSH
76806: LD_VAR 0 2
76810: PPUSH
76811: CALL_OW 1
76815: ST_TO_ADDR
// end ;
76816: LD_VAR 0 3
76820: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76821: LD_INT 0
76823: PPUSH
// if not mc_bases or not base or not scan_area then
76824: LD_EXP 43
76828: NOT
76829: PUSH
76830: LD_VAR 0 1
76834: NOT
76835: OR
76836: PUSH
76837: LD_VAR 0 2
76841: NOT
76842: OR
76843: IFFALSE 76847
// exit ;
76845: GO 76872
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76847: LD_ADDR_EXP 68
76851: PUSH
76852: LD_EXP 68
76856: PPUSH
76857: LD_VAR 0 1
76861: PPUSH
76862: LD_VAR 0 2
76866: PPUSH
76867: CALL_OW 1
76871: ST_TO_ADDR
// end ;
76872: LD_VAR 0 3
76876: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76877: LD_INT 0
76879: PPUSH
76880: PPUSH
// if not mc_bases or not base then
76881: LD_EXP 43
76885: NOT
76886: PUSH
76887: LD_VAR 0 1
76891: NOT
76892: OR
76893: IFFALSE 76897
// exit ;
76895: GO 76961
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76897: LD_ADDR_VAR 0 3
76901: PUSH
76902: LD_INT 1
76904: PUSH
76905: LD_INT 2
76907: PUSH
76908: LD_INT 3
76910: PUSH
76911: LD_INT 4
76913: PUSH
76914: LD_INT 11
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76924: LD_ADDR_EXP 70
76928: PUSH
76929: LD_EXP 70
76933: PPUSH
76934: LD_VAR 0 1
76938: PPUSH
76939: LD_EXP 70
76943: PUSH
76944: LD_VAR 0 1
76948: ARRAY
76949: PUSH
76950: LD_VAR 0 3
76954: DIFF
76955: PPUSH
76956: CALL_OW 1
76960: ST_TO_ADDR
// end ;
76961: LD_VAR 0 2
76965: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76966: LD_INT 0
76968: PPUSH
// result := mc_vehicles [ base ] ;
76969: LD_ADDR_VAR 0 3
76973: PUSH
76974: LD_EXP 62
76978: PUSH
76979: LD_VAR 0 1
76983: ARRAY
76984: ST_TO_ADDR
// if onlyCombat then
76985: LD_VAR 0 2
76989: IFFALSE 77161
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76991: LD_ADDR_VAR 0 3
76995: PUSH
76996: LD_VAR 0 3
77000: PUSH
77001: LD_VAR 0 3
77005: PPUSH
77006: LD_INT 2
77008: PUSH
77009: LD_INT 34
77011: PUSH
77012: LD_INT 12
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 34
77021: PUSH
77022: LD_INT 51
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 34
77031: PUSH
77032: LD_INT 89
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 34
77041: PUSH
77042: LD_INT 32
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 34
77051: PUSH
77052: LD_INT 13
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 34
77061: PUSH
77062: LD_INT 52
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 34
77071: PUSH
77072: LD_INT 88
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 34
77081: PUSH
77082: LD_INT 14
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 34
77091: PUSH
77092: LD_INT 53
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 34
77101: PUSH
77102: LD_INT 98
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 34
77111: PUSH
77112: LD_INT 31
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: LD_INT 34
77121: PUSH
77122: LD_INT 48
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 34
77131: PUSH
77132: LD_INT 8
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: PPUSH
77155: CALL_OW 72
77159: DIFF
77160: ST_TO_ADDR
// end ; end_of_file
77161: LD_VAR 0 3
77165: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77166: LD_INT 0
77168: PPUSH
77169: PPUSH
77170: PPUSH
// if not mc_bases or not skirmish then
77171: LD_EXP 43
77175: NOT
77176: PUSH
77177: LD_EXP 41
77181: NOT
77182: OR
77183: IFFALSE 77187
// exit ;
77185: GO 77352
// for i = 1 to mc_bases do
77187: LD_ADDR_VAR 0 4
77191: PUSH
77192: DOUBLE
77193: LD_INT 1
77195: DEC
77196: ST_TO_ADDR
77197: LD_EXP 43
77201: PUSH
77202: FOR_TO
77203: IFFALSE 77350
// begin if sci in mc_bases [ i ] then
77205: LD_VAR 0 2
77209: PUSH
77210: LD_EXP 43
77214: PUSH
77215: LD_VAR 0 4
77219: ARRAY
77220: IN
77221: IFFALSE 77348
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77223: LD_ADDR_EXP 72
77227: PUSH
77228: LD_EXP 72
77232: PPUSH
77233: LD_VAR 0 4
77237: PUSH
77238: LD_EXP 72
77242: PUSH
77243: LD_VAR 0 4
77247: ARRAY
77248: PUSH
77249: LD_INT 1
77251: PLUS
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PPUSH
77257: LD_VAR 0 1
77261: PPUSH
77262: CALL 14988 0 3
77266: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77267: LD_ADDR_VAR 0 5
77271: PUSH
77272: LD_EXP 43
77276: PUSH
77277: LD_VAR 0 4
77281: ARRAY
77282: PPUSH
77283: LD_INT 2
77285: PUSH
77286: LD_INT 30
77288: PUSH
77289: LD_INT 0
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 30
77298: PUSH
77299: LD_INT 1
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: LIST
77310: PPUSH
77311: CALL_OW 72
77315: PPUSH
77316: LD_VAR 0 1
77320: PPUSH
77321: CALL_OW 74
77325: ST_TO_ADDR
// if tmp then
77326: LD_VAR 0 5
77330: IFFALSE 77346
// ComStandNearbyBuilding ( ape , tmp ) ;
77332: LD_VAR 0 1
77336: PPUSH
77337: LD_VAR 0 5
77341: PPUSH
77342: CALL 11415 0 2
// break ;
77346: GO 77350
// end ; end ;
77348: GO 77202
77350: POP
77351: POP
// end ;
77352: LD_VAR 0 3
77356: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77357: LD_INT 0
77359: PPUSH
77360: PPUSH
77361: PPUSH
// if not mc_bases or not skirmish then
77362: LD_EXP 43
77366: NOT
77367: PUSH
77368: LD_EXP 41
77372: NOT
77373: OR
77374: IFFALSE 77378
// exit ;
77376: GO 77467
// for i = 1 to mc_bases do
77378: LD_ADDR_VAR 0 4
77382: PUSH
77383: DOUBLE
77384: LD_INT 1
77386: DEC
77387: ST_TO_ADDR
77388: LD_EXP 43
77392: PUSH
77393: FOR_TO
77394: IFFALSE 77465
// begin if building in mc_busy_turret_list [ i ] then
77396: LD_VAR 0 1
77400: PUSH
77401: LD_EXP 53
77405: PUSH
77406: LD_VAR 0 4
77410: ARRAY
77411: IN
77412: IFFALSE 77463
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77414: LD_ADDR_VAR 0 5
77418: PUSH
77419: LD_EXP 53
77423: PUSH
77424: LD_VAR 0 4
77428: ARRAY
77429: PUSH
77430: LD_VAR 0 1
77434: DIFF
77435: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77436: LD_ADDR_EXP 53
77440: PUSH
77441: LD_EXP 53
77445: PPUSH
77446: LD_VAR 0 4
77450: PPUSH
77451: LD_VAR 0 5
77455: PPUSH
77456: CALL_OW 1
77460: ST_TO_ADDR
// break ;
77461: GO 77465
// end ; end ;
77463: GO 77393
77465: POP
77466: POP
// end ;
77467: LD_VAR 0 3
77471: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77472: LD_INT 0
77474: PPUSH
77475: PPUSH
77476: PPUSH
// if not mc_bases or not skirmish then
77477: LD_EXP 43
77481: NOT
77482: PUSH
77483: LD_EXP 41
77487: NOT
77488: OR
77489: IFFALSE 77493
// exit ;
77491: GO 77692
// for i = 1 to mc_bases do
77493: LD_ADDR_VAR 0 5
77497: PUSH
77498: DOUBLE
77499: LD_INT 1
77501: DEC
77502: ST_TO_ADDR
77503: LD_EXP 43
77507: PUSH
77508: FOR_TO
77509: IFFALSE 77690
// if building in mc_bases [ i ] then
77511: LD_VAR 0 1
77515: PUSH
77516: LD_EXP 43
77520: PUSH
77521: LD_VAR 0 5
77525: ARRAY
77526: IN
77527: IFFALSE 77688
// begin tmp := mc_bases [ i ] diff building ;
77529: LD_ADDR_VAR 0 6
77533: PUSH
77534: LD_EXP 43
77538: PUSH
77539: LD_VAR 0 5
77543: ARRAY
77544: PUSH
77545: LD_VAR 0 1
77549: DIFF
77550: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77551: LD_ADDR_EXP 43
77555: PUSH
77556: LD_EXP 43
77560: PPUSH
77561: LD_VAR 0 5
77565: PPUSH
77566: LD_VAR 0 6
77570: PPUSH
77571: CALL_OW 1
77575: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77576: LD_VAR 0 1
77580: PUSH
77581: LD_EXP 51
77585: PUSH
77586: LD_VAR 0 5
77590: ARRAY
77591: IN
77592: IFFALSE 77631
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77594: LD_ADDR_EXP 51
77598: PUSH
77599: LD_EXP 51
77603: PPUSH
77604: LD_VAR 0 5
77608: PPUSH
77609: LD_EXP 51
77613: PUSH
77614: LD_VAR 0 5
77618: ARRAY
77619: PUSH
77620: LD_VAR 0 1
77624: DIFF
77625: PPUSH
77626: CALL_OW 1
77630: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77631: LD_VAR 0 1
77635: PUSH
77636: LD_EXP 52
77640: PUSH
77641: LD_VAR 0 5
77645: ARRAY
77646: IN
77647: IFFALSE 77686
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77649: LD_ADDR_EXP 52
77653: PUSH
77654: LD_EXP 52
77658: PPUSH
77659: LD_VAR 0 5
77663: PPUSH
77664: LD_EXP 52
77668: PUSH
77669: LD_VAR 0 5
77673: ARRAY
77674: PUSH
77675: LD_VAR 0 1
77679: DIFF
77680: PPUSH
77681: CALL_OW 1
77685: ST_TO_ADDR
// break ;
77686: GO 77690
// end ;
77688: GO 77508
77690: POP
77691: POP
// end ;
77692: LD_VAR 0 4
77696: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77697: LD_INT 0
77699: PPUSH
77700: PPUSH
77701: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77702: LD_EXP 43
77706: NOT
77707: PUSH
77708: LD_EXP 41
77712: NOT
77713: OR
77714: PUSH
77715: LD_VAR 0 3
77719: PUSH
77720: LD_EXP 69
77724: IN
77725: NOT
77726: OR
77727: IFFALSE 77731
// exit ;
77729: GO 77854
// for i = 1 to mc_vehicles do
77731: LD_ADDR_VAR 0 6
77735: PUSH
77736: DOUBLE
77737: LD_INT 1
77739: DEC
77740: ST_TO_ADDR
77741: LD_EXP 62
77745: PUSH
77746: FOR_TO
77747: IFFALSE 77852
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77749: LD_VAR 0 2
77753: PUSH
77754: LD_EXP 62
77758: PUSH
77759: LD_VAR 0 6
77763: ARRAY
77764: IN
77765: PUSH
77766: LD_VAR 0 1
77770: PUSH
77771: LD_EXP 62
77775: PUSH
77776: LD_VAR 0 6
77780: ARRAY
77781: IN
77782: OR
77783: IFFALSE 77850
// begin tmp := mc_vehicles [ i ] diff old ;
77785: LD_ADDR_VAR 0 7
77789: PUSH
77790: LD_EXP 62
77794: PUSH
77795: LD_VAR 0 6
77799: ARRAY
77800: PUSH
77801: LD_VAR 0 2
77805: DIFF
77806: ST_TO_ADDR
// tmp := tmp diff new ;
77807: LD_ADDR_VAR 0 7
77811: PUSH
77812: LD_VAR 0 7
77816: PUSH
77817: LD_VAR 0 1
77821: DIFF
77822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77823: LD_ADDR_EXP 62
77827: PUSH
77828: LD_EXP 62
77832: PPUSH
77833: LD_VAR 0 6
77837: PPUSH
77838: LD_VAR 0 7
77842: PPUSH
77843: CALL_OW 1
77847: ST_TO_ADDR
// break ;
77848: GO 77852
// end ;
77850: GO 77746
77852: POP
77853: POP
// end ;
77854: LD_VAR 0 5
77858: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77859: LD_INT 0
77861: PPUSH
77862: PPUSH
77863: PPUSH
77864: PPUSH
// if not mc_bases or not skirmish then
77865: LD_EXP 43
77869: NOT
77870: PUSH
77871: LD_EXP 41
77875: NOT
77876: OR
77877: IFFALSE 77881
// exit ;
77879: GO 78263
// side := GetSide ( vehicle ) ;
77881: LD_ADDR_VAR 0 5
77885: PUSH
77886: LD_VAR 0 1
77890: PPUSH
77891: CALL_OW 255
77895: ST_TO_ADDR
// for i = 1 to mc_bases do
77896: LD_ADDR_VAR 0 4
77900: PUSH
77901: DOUBLE
77902: LD_INT 1
77904: DEC
77905: ST_TO_ADDR
77906: LD_EXP 43
77910: PUSH
77911: FOR_TO
77912: IFFALSE 78261
// begin if factory in mc_bases [ i ] then
77914: LD_VAR 0 2
77918: PUSH
77919: LD_EXP 43
77923: PUSH
77924: LD_VAR 0 4
77928: ARRAY
77929: IN
77930: IFFALSE 78259
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77932: LD_EXP 65
77936: PUSH
77937: LD_VAR 0 4
77941: ARRAY
77942: PUSH
77943: LD_EXP 54
77947: PUSH
77948: LD_VAR 0 4
77952: ARRAY
77953: LESS
77954: PUSH
77955: LD_VAR 0 1
77959: PPUSH
77960: CALL_OW 264
77964: PUSH
77965: LD_INT 31
77967: PUSH
77968: LD_INT 32
77970: PUSH
77971: LD_INT 51
77973: PUSH
77974: LD_INT 89
77976: PUSH
77977: LD_INT 12
77979: PUSH
77980: LD_INT 30
77982: PUSH
77983: LD_INT 98
77985: PUSH
77986: LD_INT 11
77988: PUSH
77989: LD_INT 53
77991: PUSH
77992: LD_INT 14
77994: PUSH
77995: LD_INT 91
77997: PUSH
77998: LD_INT 29
78000: PUSH
78001: LD_INT 99
78003: PUSH
78004: LD_INT 13
78006: PUSH
78007: LD_INT 52
78009: PUSH
78010: LD_INT 88
78012: PUSH
78013: LD_INT 48
78015: PUSH
78016: LD_INT 8
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: IN
78039: NOT
78040: AND
78041: IFFALSE 78089
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78043: LD_ADDR_EXP 65
78047: PUSH
78048: LD_EXP 65
78052: PPUSH
78053: LD_VAR 0 4
78057: PUSH
78058: LD_EXP 65
78062: PUSH
78063: LD_VAR 0 4
78067: ARRAY
78068: PUSH
78069: LD_INT 1
78071: PLUS
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PPUSH
78077: LD_VAR 0 1
78081: PPUSH
78082: CALL 14988 0 3
78086: ST_TO_ADDR
78087: GO 78133
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78089: LD_ADDR_EXP 62
78093: PUSH
78094: LD_EXP 62
78098: PPUSH
78099: LD_VAR 0 4
78103: PUSH
78104: LD_EXP 62
78108: PUSH
78109: LD_VAR 0 4
78113: ARRAY
78114: PUSH
78115: LD_INT 1
78117: PLUS
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PPUSH
78123: LD_VAR 0 1
78127: PPUSH
78128: CALL 14988 0 3
78132: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78133: LD_VAR 0 1
78137: PPUSH
78138: CALL_OW 263
78142: PUSH
78143: LD_INT 2
78145: EQUAL
78146: IFFALSE 78175
// begin repeat wait ( 0 0$3 ) ;
78148: LD_INT 105
78150: PPUSH
78151: CALL_OW 67
// Connect ( vehicle ) ;
78155: LD_VAR 0 1
78159: PPUSH
78160: CALL 17957 0 1
// until IsControledBy ( vehicle ) ;
78164: LD_VAR 0 1
78168: PPUSH
78169: CALL_OW 312
78173: IFFALSE 78148
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78175: LD_VAR 0 1
78179: PPUSH
78180: LD_EXP 67
78184: PUSH
78185: LD_VAR 0 4
78189: ARRAY
78190: PPUSH
78191: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78195: LD_VAR 0 1
78199: PPUSH
78200: CALL_OW 263
78204: PUSH
78205: LD_INT 1
78207: NONEQUAL
78208: IFFALSE 78212
// break ;
78210: GO 78261
// repeat wait ( 0 0$1 ) ;
78212: LD_INT 35
78214: PPUSH
78215: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78219: LD_VAR 0 1
78223: PPUSH
78224: LD_EXP 67
78228: PUSH
78229: LD_VAR 0 4
78233: ARRAY
78234: PPUSH
78235: CALL_OW 308
78239: IFFALSE 78212
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78241: LD_VAR 0 1
78245: PPUSH
78246: CALL_OW 311
78250: PPUSH
78251: CALL_OW 121
// exit ;
78255: POP
78256: POP
78257: GO 78263
// end ; end ;
78259: GO 77911
78261: POP
78262: POP
// end ;
78263: LD_VAR 0 3
78267: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78268: LD_INT 0
78270: PPUSH
78271: PPUSH
78272: PPUSH
78273: PPUSH
// if not mc_bases or not skirmish then
78274: LD_EXP 43
78278: NOT
78279: PUSH
78280: LD_EXP 41
78284: NOT
78285: OR
78286: IFFALSE 78290
// exit ;
78288: GO 78643
// repeat wait ( 0 0$1 ) ;
78290: LD_INT 35
78292: PPUSH
78293: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78297: LD_VAR 0 2
78301: PPUSH
78302: LD_VAR 0 3
78306: PPUSH
78307: CALL_OW 284
78311: IFFALSE 78290
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78313: LD_VAR 0 2
78317: PPUSH
78318: LD_VAR 0 3
78322: PPUSH
78323: CALL_OW 283
78327: PUSH
78328: LD_INT 4
78330: EQUAL
78331: IFFALSE 78335
// exit ;
78333: GO 78643
// for i = 1 to mc_bases do
78335: LD_ADDR_VAR 0 7
78339: PUSH
78340: DOUBLE
78341: LD_INT 1
78343: DEC
78344: ST_TO_ADDR
78345: LD_EXP 43
78349: PUSH
78350: FOR_TO
78351: IFFALSE 78641
// begin if mc_crates_area [ i ] then
78353: LD_EXP 61
78357: PUSH
78358: LD_VAR 0 7
78362: ARRAY
78363: IFFALSE 78474
// for j in mc_crates_area [ i ] do
78365: LD_ADDR_VAR 0 8
78369: PUSH
78370: LD_EXP 61
78374: PUSH
78375: LD_VAR 0 7
78379: ARRAY
78380: PUSH
78381: FOR_IN
78382: IFFALSE 78472
// if InArea ( x , y , j ) then
78384: LD_VAR 0 2
78388: PPUSH
78389: LD_VAR 0 3
78393: PPUSH
78394: LD_VAR 0 8
78398: PPUSH
78399: CALL_OW 309
78403: IFFALSE 78470
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78405: LD_ADDR_EXP 59
78409: PUSH
78410: LD_EXP 59
78414: PPUSH
78415: LD_VAR 0 7
78419: PUSH
78420: LD_EXP 59
78424: PUSH
78425: LD_VAR 0 7
78429: ARRAY
78430: PUSH
78431: LD_INT 1
78433: PLUS
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PPUSH
78439: LD_VAR 0 4
78443: PUSH
78444: LD_VAR 0 2
78448: PUSH
78449: LD_VAR 0 3
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: LIST
78458: PPUSH
78459: CALL 14988 0 3
78463: ST_TO_ADDR
// exit ;
78464: POP
78465: POP
78466: POP
78467: POP
78468: GO 78643
// end ;
78470: GO 78381
78472: POP
78473: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78474: LD_ADDR_VAR 0 9
78478: PUSH
78479: LD_EXP 43
78483: PUSH
78484: LD_VAR 0 7
78488: ARRAY
78489: PPUSH
78490: LD_INT 2
78492: PUSH
78493: LD_INT 30
78495: PUSH
78496: LD_INT 0
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: LD_INT 30
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: LIST
78517: PPUSH
78518: CALL_OW 72
78522: ST_TO_ADDR
// if not depot then
78523: LD_VAR 0 9
78527: NOT
78528: IFFALSE 78532
// continue ;
78530: GO 78350
// for j in depot do
78532: LD_ADDR_VAR 0 8
78536: PUSH
78537: LD_VAR 0 9
78541: PUSH
78542: FOR_IN
78543: IFFALSE 78637
// if GetDistUnitXY ( j , x , y ) < 30 then
78545: LD_VAR 0 8
78549: PPUSH
78550: LD_VAR 0 2
78554: PPUSH
78555: LD_VAR 0 3
78559: PPUSH
78560: CALL_OW 297
78564: PUSH
78565: LD_INT 30
78567: LESS
78568: IFFALSE 78635
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78570: LD_ADDR_EXP 59
78574: PUSH
78575: LD_EXP 59
78579: PPUSH
78580: LD_VAR 0 7
78584: PUSH
78585: LD_EXP 59
78589: PUSH
78590: LD_VAR 0 7
78594: ARRAY
78595: PUSH
78596: LD_INT 1
78598: PLUS
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PPUSH
78604: LD_VAR 0 4
78608: PUSH
78609: LD_VAR 0 2
78613: PUSH
78614: LD_VAR 0 3
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: LIST
78623: PPUSH
78624: CALL 14988 0 3
78628: ST_TO_ADDR
// exit ;
78629: POP
78630: POP
78631: POP
78632: POP
78633: GO 78643
// end ;
78635: GO 78542
78637: POP
78638: POP
// end ;
78639: GO 78350
78641: POP
78642: POP
// end ;
78643: LD_VAR 0 6
78647: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78648: LD_INT 0
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
// if not mc_bases or not skirmish then
78654: LD_EXP 43
78658: NOT
78659: PUSH
78660: LD_EXP 41
78664: NOT
78665: OR
78666: IFFALSE 78670
// exit ;
78668: GO 78947
// side := GetSide ( lab ) ;
78670: LD_ADDR_VAR 0 4
78674: PUSH
78675: LD_VAR 0 2
78679: PPUSH
78680: CALL_OW 255
78684: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78685: LD_VAR 0 4
78689: PUSH
78690: LD_EXP 69
78694: IN
78695: NOT
78696: PUSH
78697: LD_EXP 70
78701: NOT
78702: OR
78703: PUSH
78704: LD_EXP 43
78708: NOT
78709: OR
78710: IFFALSE 78714
// exit ;
78712: GO 78947
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78714: LD_ADDR_EXP 70
78718: PUSH
78719: LD_EXP 70
78723: PPUSH
78724: LD_VAR 0 4
78728: PPUSH
78729: LD_EXP 70
78733: PUSH
78734: LD_VAR 0 4
78738: ARRAY
78739: PUSH
78740: LD_VAR 0 1
78744: DIFF
78745: PPUSH
78746: CALL_OW 1
78750: ST_TO_ADDR
// for i = 1 to mc_bases do
78751: LD_ADDR_VAR 0 5
78755: PUSH
78756: DOUBLE
78757: LD_INT 1
78759: DEC
78760: ST_TO_ADDR
78761: LD_EXP 43
78765: PUSH
78766: FOR_TO
78767: IFFALSE 78945
// begin if lab in mc_bases [ i ] then
78769: LD_VAR 0 2
78773: PUSH
78774: LD_EXP 43
78778: PUSH
78779: LD_VAR 0 5
78783: ARRAY
78784: IN
78785: IFFALSE 78943
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78787: LD_VAR 0 1
78791: PUSH
78792: LD_INT 11
78794: PUSH
78795: LD_INT 4
78797: PUSH
78798: LD_INT 3
78800: PUSH
78801: LD_INT 2
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: IN
78810: PUSH
78811: LD_EXP 73
78815: PUSH
78816: LD_VAR 0 5
78820: ARRAY
78821: AND
78822: IFFALSE 78943
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78824: LD_ADDR_VAR 0 6
78828: PUSH
78829: LD_EXP 73
78833: PUSH
78834: LD_VAR 0 5
78838: ARRAY
78839: PUSH
78840: LD_INT 1
78842: ARRAY
78843: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78844: LD_ADDR_EXP 73
78848: PUSH
78849: LD_EXP 73
78853: PPUSH
78854: LD_VAR 0 5
78858: PPUSH
78859: EMPTY
78860: PPUSH
78861: CALL_OW 1
78865: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78866: LD_VAR 0 6
78870: PPUSH
78871: LD_INT 0
78873: PPUSH
78874: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78878: LD_VAR 0 6
78882: PPUSH
78883: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78887: LD_ADDR_EXP 72
78891: PUSH
78892: LD_EXP 72
78896: PPUSH
78897: LD_VAR 0 5
78901: PPUSH
78902: LD_EXP 72
78906: PUSH
78907: LD_VAR 0 5
78911: ARRAY
78912: PPUSH
78913: LD_INT 1
78915: PPUSH
78916: LD_VAR 0 6
78920: PPUSH
78921: CALL_OW 2
78925: PPUSH
78926: CALL_OW 1
78930: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78931: LD_VAR 0 5
78935: PPUSH
78936: LD_INT 112
78938: PPUSH
78939: CALL 55433 0 2
// end ; end ; end ;
78943: GO 78766
78945: POP
78946: POP
// end ;
78947: LD_VAR 0 3
78951: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78952: LD_INT 0
78954: PPUSH
78955: PPUSH
78956: PPUSH
78957: PPUSH
78958: PPUSH
78959: PPUSH
78960: PPUSH
78961: PPUSH
// if not mc_bases or not skirmish then
78962: LD_EXP 43
78966: NOT
78967: PUSH
78968: LD_EXP 41
78972: NOT
78973: OR
78974: IFFALSE 78978
// exit ;
78976: GO 80347
// for i = 1 to mc_bases do
78978: LD_ADDR_VAR 0 3
78982: PUSH
78983: DOUBLE
78984: LD_INT 1
78986: DEC
78987: ST_TO_ADDR
78988: LD_EXP 43
78992: PUSH
78993: FOR_TO
78994: IFFALSE 80345
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78996: LD_VAR 0 1
79000: PUSH
79001: LD_EXP 43
79005: PUSH
79006: LD_VAR 0 3
79010: ARRAY
79011: IN
79012: PUSH
79013: LD_VAR 0 1
79017: PUSH
79018: LD_EXP 50
79022: PUSH
79023: LD_VAR 0 3
79027: ARRAY
79028: IN
79029: OR
79030: PUSH
79031: LD_VAR 0 1
79035: PUSH
79036: LD_EXP 65
79040: PUSH
79041: LD_VAR 0 3
79045: ARRAY
79046: IN
79047: OR
79048: PUSH
79049: LD_VAR 0 1
79053: PUSH
79054: LD_EXP 62
79058: PUSH
79059: LD_VAR 0 3
79063: ARRAY
79064: IN
79065: OR
79066: PUSH
79067: LD_VAR 0 1
79071: PUSH
79072: LD_EXP 72
79076: PUSH
79077: LD_VAR 0 3
79081: ARRAY
79082: IN
79083: OR
79084: PUSH
79085: LD_VAR 0 1
79089: PUSH
79090: LD_EXP 73
79094: PUSH
79095: LD_VAR 0 3
79099: ARRAY
79100: IN
79101: OR
79102: IFFALSE 80343
// begin if un in mc_ape [ i ] then
79104: LD_VAR 0 1
79108: PUSH
79109: LD_EXP 72
79113: PUSH
79114: LD_VAR 0 3
79118: ARRAY
79119: IN
79120: IFFALSE 79159
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79122: LD_ADDR_EXP 72
79126: PUSH
79127: LD_EXP 72
79131: PPUSH
79132: LD_VAR 0 3
79136: PPUSH
79137: LD_EXP 72
79141: PUSH
79142: LD_VAR 0 3
79146: ARRAY
79147: PUSH
79148: LD_VAR 0 1
79152: DIFF
79153: PPUSH
79154: CALL_OW 1
79158: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79159: LD_VAR 0 1
79163: PUSH
79164: LD_EXP 73
79168: PUSH
79169: LD_VAR 0 3
79173: ARRAY
79174: IN
79175: IFFALSE 79199
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79177: LD_ADDR_EXP 73
79181: PUSH
79182: LD_EXP 73
79186: PPUSH
79187: LD_VAR 0 3
79191: PPUSH
79192: EMPTY
79193: PPUSH
79194: CALL_OW 1
79198: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79199: LD_VAR 0 1
79203: PPUSH
79204: CALL_OW 247
79208: PUSH
79209: LD_INT 2
79211: EQUAL
79212: PUSH
79213: LD_VAR 0 1
79217: PPUSH
79218: CALL_OW 110
79222: PUSH
79223: LD_INT 20
79225: EQUAL
79226: PUSH
79227: LD_VAR 0 1
79231: PUSH
79232: LD_EXP 65
79236: PUSH
79237: LD_VAR 0 3
79241: ARRAY
79242: IN
79243: OR
79244: PUSH
79245: LD_VAR 0 1
79249: PPUSH
79250: CALL_OW 264
79254: PUSH
79255: LD_INT 12
79257: PUSH
79258: LD_INT 51
79260: PUSH
79261: LD_INT 89
79263: PUSH
79264: LD_INT 32
79266: PUSH
79267: LD_INT 13
79269: PUSH
79270: LD_INT 52
79272: PUSH
79273: LD_INT 31
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: IN
79285: OR
79286: AND
79287: IFFALSE 79595
// begin if un in mc_defender [ i ] then
79289: LD_VAR 0 1
79293: PUSH
79294: LD_EXP 65
79298: PUSH
79299: LD_VAR 0 3
79303: ARRAY
79304: IN
79305: IFFALSE 79344
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79307: LD_ADDR_EXP 65
79311: PUSH
79312: LD_EXP 65
79316: PPUSH
79317: LD_VAR 0 3
79321: PPUSH
79322: LD_EXP 65
79326: PUSH
79327: LD_VAR 0 3
79331: ARRAY
79332: PUSH
79333: LD_VAR 0 1
79337: DIFF
79338: PPUSH
79339: CALL_OW 1
79343: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79344: LD_ADDR_VAR 0 8
79348: PUSH
79349: LD_VAR 0 3
79353: PPUSH
79354: LD_INT 3
79356: PPUSH
79357: CALL 76003 0 2
79361: ST_TO_ADDR
// if fac then
79362: LD_VAR 0 8
79366: IFFALSE 79595
// begin for j in fac do
79368: LD_ADDR_VAR 0 4
79372: PUSH
79373: LD_VAR 0 8
79377: PUSH
79378: FOR_IN
79379: IFFALSE 79593
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79381: LD_ADDR_VAR 0 9
79385: PUSH
79386: LD_VAR 0 8
79390: PPUSH
79391: LD_VAR 0 1
79395: PPUSH
79396: CALL_OW 265
79400: PPUSH
79401: LD_VAR 0 1
79405: PPUSH
79406: CALL_OW 262
79410: PPUSH
79411: LD_VAR 0 1
79415: PPUSH
79416: CALL_OW 263
79420: PPUSH
79421: LD_VAR 0 1
79425: PPUSH
79426: CALL_OW 264
79430: PPUSH
79431: CALL 12486 0 5
79435: ST_TO_ADDR
// if components then
79436: LD_VAR 0 9
79440: IFFALSE 79591
// begin if GetWeapon ( un ) = ar_control_tower then
79442: LD_VAR 0 1
79446: PPUSH
79447: CALL_OW 264
79451: PUSH
79452: LD_INT 31
79454: EQUAL
79455: IFFALSE 79572
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79457: LD_VAR 0 1
79461: PPUSH
79462: CALL_OW 311
79466: PPUSH
79467: LD_INT 0
79469: PPUSH
79470: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79474: LD_ADDR_EXP 83
79478: PUSH
79479: LD_EXP 83
79483: PPUSH
79484: LD_VAR 0 3
79488: PPUSH
79489: LD_EXP 83
79493: PUSH
79494: LD_VAR 0 3
79498: ARRAY
79499: PUSH
79500: LD_VAR 0 1
79504: PPUSH
79505: CALL_OW 311
79509: DIFF
79510: PPUSH
79511: CALL_OW 1
79515: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79516: LD_ADDR_VAR 0 7
79520: PUSH
79521: LD_EXP 64
79525: PUSH
79526: LD_VAR 0 3
79530: ARRAY
79531: PPUSH
79532: LD_INT 1
79534: PPUSH
79535: LD_VAR 0 9
79539: PPUSH
79540: CALL_OW 2
79544: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79545: LD_ADDR_EXP 64
79549: PUSH
79550: LD_EXP 64
79554: PPUSH
79555: LD_VAR 0 3
79559: PPUSH
79560: LD_VAR 0 7
79564: PPUSH
79565: CALL_OW 1
79569: ST_TO_ADDR
// end else
79570: GO 79589
// MC_InsertProduceList ( i , [ components ] ) ;
79572: LD_VAR 0 3
79576: PPUSH
79577: LD_VAR 0 9
79581: PUSH
79582: EMPTY
79583: LIST
79584: PPUSH
79585: CALL 75548 0 2
// break ;
79589: GO 79593
// end ; end ;
79591: GO 79378
79593: POP
79594: POP
// end ; end ; if GetType ( un ) = unit_building then
79595: LD_VAR 0 1
79599: PPUSH
79600: CALL_OW 247
79604: PUSH
79605: LD_INT 3
79607: EQUAL
79608: IFFALSE 80011
// begin btype := GetBType ( un ) ;
79610: LD_ADDR_VAR 0 5
79614: PUSH
79615: LD_VAR 0 1
79619: PPUSH
79620: CALL_OW 266
79624: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79625: LD_VAR 0 5
79629: PUSH
79630: LD_INT 29
79632: PUSH
79633: LD_INT 30
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: IN
79640: IFFALSE 79713
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79642: LD_VAR 0 1
79646: PPUSH
79647: CALL_OW 250
79651: PPUSH
79652: LD_VAR 0 1
79656: PPUSH
79657: CALL_OW 251
79661: PPUSH
79662: LD_VAR 0 1
79666: PPUSH
79667: CALL_OW 255
79671: PPUSH
79672: CALL_OW 440
79676: NOT
79677: IFFALSE 79713
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79679: LD_VAR 0 1
79683: PPUSH
79684: CALL_OW 250
79688: PPUSH
79689: LD_VAR 0 1
79693: PPUSH
79694: CALL_OW 251
79698: PPUSH
79699: LD_VAR 0 1
79703: PPUSH
79704: CALL_OW 255
79708: PPUSH
79709: CALL_OW 441
// end ; if btype = b_warehouse then
79713: LD_VAR 0 5
79717: PUSH
79718: LD_INT 1
79720: EQUAL
79721: IFFALSE 79739
// begin btype := b_depot ;
79723: LD_ADDR_VAR 0 5
79727: PUSH
79728: LD_INT 0
79730: ST_TO_ADDR
// pos := 1 ;
79731: LD_ADDR_VAR 0 6
79735: PUSH
79736: LD_INT 1
79738: ST_TO_ADDR
// end ; if btype = b_factory then
79739: LD_VAR 0 5
79743: PUSH
79744: LD_INT 3
79746: EQUAL
79747: IFFALSE 79765
// begin btype := b_workshop ;
79749: LD_ADDR_VAR 0 5
79753: PUSH
79754: LD_INT 2
79756: ST_TO_ADDR
// pos := 1 ;
79757: LD_ADDR_VAR 0 6
79761: PUSH
79762: LD_INT 1
79764: ST_TO_ADDR
// end ; if btype = b_barracks then
79765: LD_VAR 0 5
79769: PUSH
79770: LD_INT 5
79772: EQUAL
79773: IFFALSE 79783
// btype := b_armoury ;
79775: LD_ADDR_VAR 0 5
79779: PUSH
79780: LD_INT 4
79782: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79783: LD_VAR 0 5
79787: PUSH
79788: LD_INT 7
79790: PUSH
79791: LD_INT 8
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: IN
79798: IFFALSE 79808
// btype := b_lab ;
79800: LD_ADDR_VAR 0 5
79804: PUSH
79805: LD_INT 6
79807: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79808: LD_ADDR_EXP 48
79812: PUSH
79813: LD_EXP 48
79817: PPUSH
79818: LD_VAR 0 3
79822: PUSH
79823: LD_EXP 48
79827: PUSH
79828: LD_VAR 0 3
79832: ARRAY
79833: PUSH
79834: LD_INT 1
79836: PLUS
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PPUSH
79842: LD_VAR 0 5
79846: PUSH
79847: LD_VAR 0 1
79851: PPUSH
79852: CALL_OW 250
79856: PUSH
79857: LD_VAR 0 1
79861: PPUSH
79862: CALL_OW 251
79866: PUSH
79867: LD_VAR 0 1
79871: PPUSH
79872: CALL_OW 254
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: PPUSH
79883: CALL 14988 0 3
79887: ST_TO_ADDR
// if pos = 1 then
79888: LD_VAR 0 6
79892: PUSH
79893: LD_INT 1
79895: EQUAL
79896: IFFALSE 80011
// begin tmp := mc_build_list [ i ] ;
79898: LD_ADDR_VAR 0 7
79902: PUSH
79903: LD_EXP 48
79907: PUSH
79908: LD_VAR 0 3
79912: ARRAY
79913: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79914: LD_VAR 0 7
79918: PPUSH
79919: LD_INT 2
79921: PUSH
79922: LD_INT 30
79924: PUSH
79925: LD_INT 0
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 30
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: LIST
79946: PPUSH
79947: CALL_OW 72
79951: IFFALSE 79961
// pos := 2 ;
79953: LD_ADDR_VAR 0 6
79957: PUSH
79958: LD_INT 2
79960: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79961: LD_ADDR_VAR 0 7
79965: PUSH
79966: LD_VAR 0 7
79970: PPUSH
79971: LD_VAR 0 6
79975: PPUSH
79976: LD_VAR 0 7
79980: PPUSH
79981: CALL 15314 0 3
79985: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79986: LD_ADDR_EXP 48
79990: PUSH
79991: LD_EXP 48
79995: PPUSH
79996: LD_VAR 0 3
80000: PPUSH
80001: LD_VAR 0 7
80005: PPUSH
80006: CALL_OW 1
80010: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80011: LD_VAR 0 1
80015: PUSH
80016: LD_EXP 43
80020: PUSH
80021: LD_VAR 0 3
80025: ARRAY
80026: IN
80027: IFFALSE 80066
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80029: LD_ADDR_EXP 43
80033: PUSH
80034: LD_EXP 43
80038: PPUSH
80039: LD_VAR 0 3
80043: PPUSH
80044: LD_EXP 43
80048: PUSH
80049: LD_VAR 0 3
80053: ARRAY
80054: PUSH
80055: LD_VAR 0 1
80059: DIFF
80060: PPUSH
80061: CALL_OW 1
80065: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80066: LD_VAR 0 1
80070: PUSH
80071: LD_EXP 50
80075: PUSH
80076: LD_VAR 0 3
80080: ARRAY
80081: IN
80082: IFFALSE 80121
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80084: LD_ADDR_EXP 50
80088: PUSH
80089: LD_EXP 50
80093: PPUSH
80094: LD_VAR 0 3
80098: PPUSH
80099: LD_EXP 50
80103: PUSH
80104: LD_VAR 0 3
80108: ARRAY
80109: PUSH
80110: LD_VAR 0 1
80114: DIFF
80115: PPUSH
80116: CALL_OW 1
80120: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80121: LD_VAR 0 1
80125: PUSH
80126: LD_EXP 62
80130: PUSH
80131: LD_VAR 0 3
80135: ARRAY
80136: IN
80137: IFFALSE 80176
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80139: LD_ADDR_EXP 62
80143: PUSH
80144: LD_EXP 62
80148: PPUSH
80149: LD_VAR 0 3
80153: PPUSH
80154: LD_EXP 62
80158: PUSH
80159: LD_VAR 0 3
80163: ARRAY
80164: PUSH
80165: LD_VAR 0 1
80169: DIFF
80170: PPUSH
80171: CALL_OW 1
80175: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80176: LD_VAR 0 1
80180: PUSH
80181: LD_EXP 65
80185: PUSH
80186: LD_VAR 0 3
80190: ARRAY
80191: IN
80192: IFFALSE 80231
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80194: LD_ADDR_EXP 65
80198: PUSH
80199: LD_EXP 65
80203: PPUSH
80204: LD_VAR 0 3
80208: PPUSH
80209: LD_EXP 65
80213: PUSH
80214: LD_VAR 0 3
80218: ARRAY
80219: PUSH
80220: LD_VAR 0 1
80224: DIFF
80225: PPUSH
80226: CALL_OW 1
80230: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80231: LD_VAR 0 1
80235: PUSH
80236: LD_EXP 52
80240: PUSH
80241: LD_VAR 0 3
80245: ARRAY
80246: IN
80247: IFFALSE 80286
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80249: LD_ADDR_EXP 52
80253: PUSH
80254: LD_EXP 52
80258: PPUSH
80259: LD_VAR 0 3
80263: PPUSH
80264: LD_EXP 52
80268: PUSH
80269: LD_VAR 0 3
80273: ARRAY
80274: PUSH
80275: LD_VAR 0 1
80279: DIFF
80280: PPUSH
80281: CALL_OW 1
80285: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80286: LD_VAR 0 1
80290: PUSH
80291: LD_EXP 51
80295: PUSH
80296: LD_VAR 0 3
80300: ARRAY
80301: IN
80302: IFFALSE 80341
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80304: LD_ADDR_EXP 51
80308: PUSH
80309: LD_EXP 51
80313: PPUSH
80314: LD_VAR 0 3
80318: PPUSH
80319: LD_EXP 51
80323: PUSH
80324: LD_VAR 0 3
80328: ARRAY
80329: PUSH
80330: LD_VAR 0 1
80334: DIFF
80335: PPUSH
80336: CALL_OW 1
80340: ST_TO_ADDR
// end ; break ;
80341: GO 80345
// end ;
80343: GO 78993
80345: POP
80346: POP
// end ;
80347: LD_VAR 0 2
80351: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80352: LD_INT 0
80354: PPUSH
80355: PPUSH
80356: PPUSH
// if not mc_bases or not skirmish then
80357: LD_EXP 43
80361: NOT
80362: PUSH
80363: LD_EXP 41
80367: NOT
80368: OR
80369: IFFALSE 80373
// exit ;
80371: GO 80588
// for i = 1 to mc_bases do
80373: LD_ADDR_VAR 0 3
80377: PUSH
80378: DOUBLE
80379: LD_INT 1
80381: DEC
80382: ST_TO_ADDR
80383: LD_EXP 43
80387: PUSH
80388: FOR_TO
80389: IFFALSE 80586
// begin if building in mc_construct_list [ i ] then
80391: LD_VAR 0 1
80395: PUSH
80396: LD_EXP 50
80400: PUSH
80401: LD_VAR 0 3
80405: ARRAY
80406: IN
80407: IFFALSE 80584
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80409: LD_ADDR_EXP 50
80413: PUSH
80414: LD_EXP 50
80418: PPUSH
80419: LD_VAR 0 3
80423: PPUSH
80424: LD_EXP 50
80428: PUSH
80429: LD_VAR 0 3
80433: ARRAY
80434: PUSH
80435: LD_VAR 0 1
80439: DIFF
80440: PPUSH
80441: CALL_OW 1
80445: ST_TO_ADDR
// if building in mc_lab [ i ] then
80446: LD_VAR 0 1
80450: PUSH
80451: LD_EXP 76
80455: PUSH
80456: LD_VAR 0 3
80460: ARRAY
80461: IN
80462: IFFALSE 80517
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80464: LD_ADDR_EXP 77
80468: PUSH
80469: LD_EXP 77
80473: PPUSH
80474: LD_VAR 0 3
80478: PPUSH
80479: LD_EXP 77
80483: PUSH
80484: LD_VAR 0 3
80488: ARRAY
80489: PPUSH
80490: LD_INT 1
80492: PPUSH
80493: LD_EXP 77
80497: PUSH
80498: LD_VAR 0 3
80502: ARRAY
80503: PPUSH
80504: LD_INT 0
80506: PPUSH
80507: CALL 14406 0 4
80511: PPUSH
80512: CALL_OW 1
80516: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80517: LD_VAR 0 1
80521: PUSH
80522: LD_EXP 43
80526: PUSH
80527: LD_VAR 0 3
80531: ARRAY
80532: IN
80533: NOT
80534: IFFALSE 80580
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80536: LD_ADDR_EXP 43
80540: PUSH
80541: LD_EXP 43
80545: PPUSH
80546: LD_VAR 0 3
80550: PUSH
80551: LD_EXP 43
80555: PUSH
80556: LD_VAR 0 3
80560: ARRAY
80561: PUSH
80562: LD_INT 1
80564: PLUS
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PPUSH
80570: LD_VAR 0 1
80574: PPUSH
80575: CALL 14988 0 3
80579: ST_TO_ADDR
// exit ;
80580: POP
80581: POP
80582: GO 80588
// end ; end ;
80584: GO 80388
80586: POP
80587: POP
// end ;
80588: LD_VAR 0 2
80592: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80593: LD_INT 0
80595: PPUSH
80596: PPUSH
80597: PPUSH
80598: PPUSH
80599: PPUSH
80600: PPUSH
80601: PPUSH
// if not mc_bases or not skirmish then
80602: LD_EXP 43
80606: NOT
80607: PUSH
80608: LD_EXP 41
80612: NOT
80613: OR
80614: IFFALSE 80618
// exit ;
80616: GO 81279
// for i = 1 to mc_bases do
80618: LD_ADDR_VAR 0 3
80622: PUSH
80623: DOUBLE
80624: LD_INT 1
80626: DEC
80627: ST_TO_ADDR
80628: LD_EXP 43
80632: PUSH
80633: FOR_TO
80634: IFFALSE 81277
// begin if building in mc_construct_list [ i ] then
80636: LD_VAR 0 1
80640: PUSH
80641: LD_EXP 50
80645: PUSH
80646: LD_VAR 0 3
80650: ARRAY
80651: IN
80652: IFFALSE 81275
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80654: LD_ADDR_EXP 50
80658: PUSH
80659: LD_EXP 50
80663: PPUSH
80664: LD_VAR 0 3
80668: PPUSH
80669: LD_EXP 50
80673: PUSH
80674: LD_VAR 0 3
80678: ARRAY
80679: PUSH
80680: LD_VAR 0 1
80684: DIFF
80685: PPUSH
80686: CALL_OW 1
80690: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80691: LD_ADDR_EXP 43
80695: PUSH
80696: LD_EXP 43
80700: PPUSH
80701: LD_VAR 0 3
80705: PUSH
80706: LD_EXP 43
80710: PUSH
80711: LD_VAR 0 3
80715: ARRAY
80716: PUSH
80717: LD_INT 1
80719: PLUS
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PPUSH
80725: LD_VAR 0 1
80729: PPUSH
80730: CALL 14988 0 3
80734: ST_TO_ADDR
// btype := GetBType ( building ) ;
80735: LD_ADDR_VAR 0 5
80739: PUSH
80740: LD_VAR 0 1
80744: PPUSH
80745: CALL_OW 266
80749: ST_TO_ADDR
// side := GetSide ( building ) ;
80750: LD_ADDR_VAR 0 8
80754: PUSH
80755: LD_VAR 0 1
80759: PPUSH
80760: CALL_OW 255
80764: ST_TO_ADDR
// if btype = b_lab then
80765: LD_VAR 0 5
80769: PUSH
80770: LD_INT 6
80772: EQUAL
80773: IFFALSE 80823
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80775: LD_ADDR_EXP 76
80779: PUSH
80780: LD_EXP 76
80784: PPUSH
80785: LD_VAR 0 3
80789: PUSH
80790: LD_EXP 76
80794: PUSH
80795: LD_VAR 0 3
80799: ARRAY
80800: PUSH
80801: LD_INT 1
80803: PLUS
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PPUSH
80809: LD_VAR 0 1
80813: PPUSH
80814: CALL 14988 0 3
80818: ST_TO_ADDR
// exit ;
80819: POP
80820: POP
80821: GO 81279
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80823: LD_VAR 0 5
80827: PUSH
80828: LD_INT 0
80830: PUSH
80831: LD_INT 2
80833: PUSH
80834: LD_INT 4
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: LIST
80841: IN
80842: IFFALSE 80966
// begin if btype = b_armoury then
80844: LD_VAR 0 5
80848: PUSH
80849: LD_INT 4
80851: EQUAL
80852: IFFALSE 80862
// btype := b_barracks ;
80854: LD_ADDR_VAR 0 5
80858: PUSH
80859: LD_INT 5
80861: ST_TO_ADDR
// if btype = b_depot then
80862: LD_VAR 0 5
80866: PUSH
80867: LD_INT 0
80869: EQUAL
80870: IFFALSE 80880
// btype := b_warehouse ;
80872: LD_ADDR_VAR 0 5
80876: PUSH
80877: LD_INT 1
80879: ST_TO_ADDR
// if btype = b_workshop then
80880: LD_VAR 0 5
80884: PUSH
80885: LD_INT 2
80887: EQUAL
80888: IFFALSE 80898
// btype := b_factory ;
80890: LD_ADDR_VAR 0 5
80894: PUSH
80895: LD_INT 3
80897: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80898: LD_VAR 0 5
80902: PPUSH
80903: LD_VAR 0 8
80907: PPUSH
80908: CALL_OW 323
80912: PUSH
80913: LD_INT 1
80915: EQUAL
80916: IFFALSE 80962
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80918: LD_ADDR_EXP 75
80922: PUSH
80923: LD_EXP 75
80927: PPUSH
80928: LD_VAR 0 3
80932: PUSH
80933: LD_EXP 75
80937: PUSH
80938: LD_VAR 0 3
80942: ARRAY
80943: PUSH
80944: LD_INT 1
80946: PLUS
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PPUSH
80952: LD_VAR 0 1
80956: PPUSH
80957: CALL 14988 0 3
80961: ST_TO_ADDR
// exit ;
80962: POP
80963: POP
80964: GO 81279
// end ; if btype in [ b_bunker , b_turret ] then
80966: LD_VAR 0 5
80970: PUSH
80971: LD_INT 32
80973: PUSH
80974: LD_INT 33
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: IN
80981: IFFALSE 81271
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80983: LD_ADDR_EXP 51
80987: PUSH
80988: LD_EXP 51
80992: PPUSH
80993: LD_VAR 0 3
80997: PUSH
80998: LD_EXP 51
81002: PUSH
81003: LD_VAR 0 3
81007: ARRAY
81008: PUSH
81009: LD_INT 1
81011: PLUS
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PPUSH
81017: LD_VAR 0 1
81021: PPUSH
81022: CALL 14988 0 3
81026: ST_TO_ADDR
// if btype = b_bunker then
81027: LD_VAR 0 5
81031: PUSH
81032: LD_INT 32
81034: EQUAL
81035: IFFALSE 81271
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81037: LD_ADDR_EXP 52
81041: PUSH
81042: LD_EXP 52
81046: PPUSH
81047: LD_VAR 0 3
81051: PUSH
81052: LD_EXP 52
81056: PUSH
81057: LD_VAR 0 3
81061: ARRAY
81062: PUSH
81063: LD_INT 1
81065: PLUS
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PPUSH
81071: LD_VAR 0 1
81075: PPUSH
81076: CALL 14988 0 3
81080: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81081: LD_ADDR_VAR 0 6
81085: PUSH
81086: LD_EXP 43
81090: PUSH
81091: LD_VAR 0 3
81095: ARRAY
81096: PPUSH
81097: LD_INT 25
81099: PUSH
81100: LD_INT 1
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 3
81109: PUSH
81110: LD_INT 54
81112: PUSH
81113: EMPTY
81114: LIST
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PPUSH
81124: CALL_OW 72
81128: ST_TO_ADDR
// if tmp then
81129: LD_VAR 0 6
81133: IFFALSE 81139
// exit ;
81135: POP
81136: POP
81137: GO 81279
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81139: LD_ADDR_VAR 0 6
81143: PUSH
81144: LD_EXP 43
81148: PUSH
81149: LD_VAR 0 3
81153: ARRAY
81154: PPUSH
81155: LD_INT 2
81157: PUSH
81158: LD_INT 30
81160: PUSH
81161: LD_INT 4
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 30
81170: PUSH
81171: LD_INT 5
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: LIST
81182: PPUSH
81183: CALL_OW 72
81187: ST_TO_ADDR
// if not tmp then
81188: LD_VAR 0 6
81192: NOT
81193: IFFALSE 81199
// exit ;
81195: POP
81196: POP
81197: GO 81279
// for j in tmp do
81199: LD_ADDR_VAR 0 4
81203: PUSH
81204: LD_VAR 0 6
81208: PUSH
81209: FOR_IN
81210: IFFALSE 81269
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81212: LD_ADDR_VAR 0 7
81216: PUSH
81217: LD_VAR 0 4
81221: PPUSH
81222: CALL_OW 313
81226: PPUSH
81227: LD_INT 25
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PPUSH
81237: CALL_OW 72
81241: ST_TO_ADDR
// if units then
81242: LD_VAR 0 7
81246: IFFALSE 81267
// begin ComExitBuilding ( units [ 1 ] ) ;
81248: LD_VAR 0 7
81252: PUSH
81253: LD_INT 1
81255: ARRAY
81256: PPUSH
81257: CALL_OW 122
// exit ;
81261: POP
81262: POP
81263: POP
81264: POP
81265: GO 81279
// end ; end ;
81267: GO 81209
81269: POP
81270: POP
// end ; end ; exit ;
81271: POP
81272: POP
81273: GO 81279
// end ; end ;
81275: GO 80633
81277: POP
81278: POP
// end ;
81279: LD_VAR 0 2
81283: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81284: LD_INT 0
81286: PPUSH
81287: PPUSH
81288: PPUSH
81289: PPUSH
81290: PPUSH
81291: PPUSH
81292: PPUSH
// if not mc_bases or not skirmish then
81293: LD_EXP 43
81297: NOT
81298: PUSH
81299: LD_EXP 41
81303: NOT
81304: OR
81305: IFFALSE 81309
// exit ;
81307: GO 81574
// btype := GetBType ( building ) ;
81309: LD_ADDR_VAR 0 6
81313: PUSH
81314: LD_VAR 0 1
81318: PPUSH
81319: CALL_OW 266
81323: ST_TO_ADDR
// x := GetX ( building ) ;
81324: LD_ADDR_VAR 0 7
81328: PUSH
81329: LD_VAR 0 1
81333: PPUSH
81334: CALL_OW 250
81338: ST_TO_ADDR
// y := GetY ( building ) ;
81339: LD_ADDR_VAR 0 8
81343: PUSH
81344: LD_VAR 0 1
81348: PPUSH
81349: CALL_OW 251
81353: ST_TO_ADDR
// d := GetDir ( building ) ;
81354: LD_ADDR_VAR 0 9
81358: PUSH
81359: LD_VAR 0 1
81363: PPUSH
81364: CALL_OW 254
81368: ST_TO_ADDR
// for i = 1 to mc_bases do
81369: LD_ADDR_VAR 0 4
81373: PUSH
81374: DOUBLE
81375: LD_INT 1
81377: DEC
81378: ST_TO_ADDR
81379: LD_EXP 43
81383: PUSH
81384: FOR_TO
81385: IFFALSE 81572
// begin if not mc_build_list [ i ] then
81387: LD_EXP 48
81391: PUSH
81392: LD_VAR 0 4
81396: ARRAY
81397: NOT
81398: IFFALSE 81402
// continue ;
81400: GO 81384
// for j := 1 to mc_build_list [ i ] do
81402: LD_ADDR_VAR 0 5
81406: PUSH
81407: DOUBLE
81408: LD_INT 1
81410: DEC
81411: ST_TO_ADDR
81412: LD_EXP 48
81416: PUSH
81417: LD_VAR 0 4
81421: ARRAY
81422: PUSH
81423: FOR_TO
81424: IFFALSE 81568
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81426: LD_VAR 0 6
81430: PUSH
81431: LD_VAR 0 7
81435: PUSH
81436: LD_VAR 0 8
81440: PUSH
81441: LD_VAR 0 9
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: PPUSH
81452: LD_EXP 48
81456: PUSH
81457: LD_VAR 0 4
81461: ARRAY
81462: PUSH
81463: LD_VAR 0 5
81467: ARRAY
81468: PPUSH
81469: CALL 21168 0 2
81473: IFFALSE 81566
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81475: LD_ADDR_EXP 48
81479: PUSH
81480: LD_EXP 48
81484: PPUSH
81485: LD_VAR 0 4
81489: PPUSH
81490: LD_EXP 48
81494: PUSH
81495: LD_VAR 0 4
81499: ARRAY
81500: PPUSH
81501: LD_VAR 0 5
81505: PPUSH
81506: CALL_OW 3
81510: PPUSH
81511: CALL_OW 1
81515: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81516: LD_ADDR_EXP 50
81520: PUSH
81521: LD_EXP 50
81525: PPUSH
81526: LD_VAR 0 4
81530: PUSH
81531: LD_EXP 50
81535: PUSH
81536: LD_VAR 0 4
81540: ARRAY
81541: PUSH
81542: LD_INT 1
81544: PLUS
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PPUSH
81550: LD_VAR 0 1
81554: PPUSH
81555: CALL 14988 0 3
81559: ST_TO_ADDR
// exit ;
81560: POP
81561: POP
81562: POP
81563: POP
81564: GO 81574
// end ;
81566: GO 81423
81568: POP
81569: POP
// end ;
81570: GO 81384
81572: POP
81573: POP
// end ;
81574: LD_VAR 0 3
81578: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81579: LD_INT 0
81581: PPUSH
81582: PPUSH
81583: PPUSH
// if not mc_bases or not skirmish then
81584: LD_EXP 43
81588: NOT
81589: PUSH
81590: LD_EXP 41
81594: NOT
81595: OR
81596: IFFALSE 81600
// exit ;
81598: GO 81790
// for i = 1 to mc_bases do
81600: LD_ADDR_VAR 0 4
81604: PUSH
81605: DOUBLE
81606: LD_INT 1
81608: DEC
81609: ST_TO_ADDR
81610: LD_EXP 43
81614: PUSH
81615: FOR_TO
81616: IFFALSE 81703
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81618: LD_VAR 0 1
81622: PUSH
81623: LD_EXP 51
81627: PUSH
81628: LD_VAR 0 4
81632: ARRAY
81633: IN
81634: PUSH
81635: LD_VAR 0 1
81639: PUSH
81640: LD_EXP 52
81644: PUSH
81645: LD_VAR 0 4
81649: ARRAY
81650: IN
81651: NOT
81652: AND
81653: IFFALSE 81701
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81655: LD_ADDR_EXP 52
81659: PUSH
81660: LD_EXP 52
81664: PPUSH
81665: LD_VAR 0 4
81669: PUSH
81670: LD_EXP 52
81674: PUSH
81675: LD_VAR 0 4
81679: ARRAY
81680: PUSH
81681: LD_INT 1
81683: PLUS
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PPUSH
81689: LD_VAR 0 1
81693: PPUSH
81694: CALL 14988 0 3
81698: ST_TO_ADDR
// break ;
81699: GO 81703
// end ; end ;
81701: GO 81615
81703: POP
81704: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81705: LD_VAR 0 1
81709: PPUSH
81710: CALL_OW 257
81714: PUSH
81715: LD_EXP 69
81719: IN
81720: PUSH
81721: LD_VAR 0 1
81725: PPUSH
81726: CALL_OW 266
81730: PUSH
81731: LD_INT 5
81733: EQUAL
81734: AND
81735: PUSH
81736: LD_VAR 0 2
81740: PPUSH
81741: CALL_OW 110
81745: PUSH
81746: LD_INT 18
81748: NONEQUAL
81749: AND
81750: IFFALSE 81790
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81752: LD_VAR 0 2
81756: PPUSH
81757: CALL_OW 257
81761: PUSH
81762: LD_INT 5
81764: PUSH
81765: LD_INT 8
81767: PUSH
81768: LD_INT 9
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: LIST
81775: IN
81776: IFFALSE 81790
// SetClass ( unit , 1 ) ;
81778: LD_VAR 0 2
81782: PPUSH
81783: LD_INT 1
81785: PPUSH
81786: CALL_OW 336
// end ;
81790: LD_VAR 0 3
81794: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81795: LD_INT 0
81797: PPUSH
81798: PPUSH
// if not mc_bases or not skirmish then
81799: LD_EXP 43
81803: NOT
81804: PUSH
81805: LD_EXP 41
81809: NOT
81810: OR
81811: IFFALSE 81815
// exit ;
81813: GO 81931
// if GetLives ( abandoned_vehicle ) > 250 then
81815: LD_VAR 0 2
81819: PPUSH
81820: CALL_OW 256
81824: PUSH
81825: LD_INT 250
81827: GREATER
81828: IFFALSE 81832
// exit ;
81830: GO 81931
// for i = 1 to mc_bases do
81832: LD_ADDR_VAR 0 6
81836: PUSH
81837: DOUBLE
81838: LD_INT 1
81840: DEC
81841: ST_TO_ADDR
81842: LD_EXP 43
81846: PUSH
81847: FOR_TO
81848: IFFALSE 81929
// begin if driver in mc_bases [ i ] then
81850: LD_VAR 0 1
81854: PUSH
81855: LD_EXP 43
81859: PUSH
81860: LD_VAR 0 6
81864: ARRAY
81865: IN
81866: IFFALSE 81927
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81868: LD_VAR 0 1
81872: PPUSH
81873: LD_EXP 43
81877: PUSH
81878: LD_VAR 0 6
81882: ARRAY
81883: PPUSH
81884: LD_INT 2
81886: PUSH
81887: LD_INT 30
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 30
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: LIST
81911: PPUSH
81912: CALL_OW 72
81916: PUSH
81917: LD_INT 1
81919: ARRAY
81920: PPUSH
81921: CALL 48196 0 2
// break ;
81925: GO 81929
// end ; end ;
81927: GO 81847
81929: POP
81930: POP
// end ; end_of_file
81931: LD_VAR 0 5
81935: RET
// export ru_radar export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81936: LD_INT 0
81938: PPUSH
81939: PPUSH
81940: PPUSH
81941: PPUSH
81942: PPUSH
81943: PPUSH
81944: PPUSH
81945: PPUSH
81946: PPUSH
81947: PPUSH
81948: PPUSH
81949: PPUSH
81950: PPUSH
81951: PPUSH
81952: PPUSH
81953: PPUSH
81954: PPUSH
81955: PPUSH
81956: PPUSH
81957: PPUSH
81958: PPUSH
81959: PPUSH
81960: PPUSH
81961: PPUSH
81962: PPUSH
81963: PPUSH
81964: PPUSH
81965: PPUSH
81966: PPUSH
81967: PPUSH
81968: PPUSH
81969: PPUSH
81970: PPUSH
81971: PPUSH
// if not list then
81972: LD_VAR 0 1
81976: NOT
81977: IFFALSE 81981
// exit ;
81979: GO 86640
// base := list [ 1 ] ;
81981: LD_ADDR_VAR 0 3
81985: PUSH
81986: LD_VAR 0 1
81990: PUSH
81991: LD_INT 1
81993: ARRAY
81994: ST_TO_ADDR
// group := list [ 2 ] ;
81995: LD_ADDR_VAR 0 4
81999: PUSH
82000: LD_VAR 0 1
82004: PUSH
82005: LD_INT 2
82007: ARRAY
82008: ST_TO_ADDR
// path := list [ 3 ] ;
82009: LD_ADDR_VAR 0 5
82013: PUSH
82014: LD_VAR 0 1
82018: PUSH
82019: LD_INT 3
82021: ARRAY
82022: ST_TO_ADDR
// flags := list [ 4 ] ;
82023: LD_ADDR_VAR 0 6
82027: PUSH
82028: LD_VAR 0 1
82032: PUSH
82033: LD_INT 4
82035: ARRAY
82036: ST_TO_ADDR
// mined := [ ] ;
82037: LD_ADDR_VAR 0 27
82041: PUSH
82042: EMPTY
82043: ST_TO_ADDR
// bombed := [ ] ;
82044: LD_ADDR_VAR 0 28
82048: PUSH
82049: EMPTY
82050: ST_TO_ADDR
// healers := [ ] ;
82051: LD_ADDR_VAR 0 31
82055: PUSH
82056: EMPTY
82057: ST_TO_ADDR
// to_heal := [ ] ;
82058: LD_ADDR_VAR 0 30
82062: PUSH
82063: EMPTY
82064: ST_TO_ADDR
// repairs := [ ] ;
82065: LD_ADDR_VAR 0 33
82069: PUSH
82070: EMPTY
82071: ST_TO_ADDR
// to_repair := [ ] ;
82072: LD_ADDR_VAR 0 32
82076: PUSH
82077: EMPTY
82078: ST_TO_ADDR
// if not group or not path then
82079: LD_VAR 0 4
82083: NOT
82084: PUSH
82085: LD_VAR 0 5
82089: NOT
82090: OR
82091: IFFALSE 82095
// exit ;
82093: GO 86640
// side := GetSide ( group [ 1 ] ) ;
82095: LD_ADDR_VAR 0 35
82099: PUSH
82100: LD_VAR 0 4
82104: PUSH
82105: LD_INT 1
82107: ARRAY
82108: PPUSH
82109: CALL_OW 255
82113: ST_TO_ADDR
// if flags then
82114: LD_VAR 0 6
82118: IFFALSE 82262
// begin f_ignore_area := flags [ 1 ] ;
82120: LD_ADDR_VAR 0 17
82124: PUSH
82125: LD_VAR 0 6
82129: PUSH
82130: LD_INT 1
82132: ARRAY
82133: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82134: LD_ADDR_VAR 0 18
82138: PUSH
82139: LD_VAR 0 6
82143: PUSH
82144: LD_INT 2
82146: ARRAY
82147: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82148: LD_ADDR_VAR 0 19
82152: PUSH
82153: LD_VAR 0 6
82157: PUSH
82158: LD_INT 3
82160: ARRAY
82161: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82162: LD_ADDR_VAR 0 20
82166: PUSH
82167: LD_VAR 0 6
82171: PUSH
82172: LD_INT 4
82174: ARRAY
82175: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82176: LD_ADDR_VAR 0 21
82180: PUSH
82181: LD_VAR 0 6
82185: PUSH
82186: LD_INT 5
82188: ARRAY
82189: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82190: LD_ADDR_VAR 0 22
82194: PUSH
82195: LD_VAR 0 6
82199: PUSH
82200: LD_INT 6
82202: ARRAY
82203: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82204: LD_ADDR_VAR 0 23
82208: PUSH
82209: LD_VAR 0 6
82213: PUSH
82214: LD_INT 7
82216: ARRAY
82217: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82218: LD_ADDR_VAR 0 24
82222: PUSH
82223: LD_VAR 0 6
82227: PUSH
82228: LD_INT 8
82230: ARRAY
82231: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82232: LD_ADDR_VAR 0 25
82236: PUSH
82237: LD_VAR 0 6
82241: PUSH
82242: LD_INT 9
82244: ARRAY
82245: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82246: LD_ADDR_VAR 0 26
82250: PUSH
82251: LD_VAR 0 6
82255: PUSH
82256: LD_INT 10
82258: ARRAY
82259: ST_TO_ADDR
// end else
82260: GO 82342
// begin f_ignore_area := false ;
82262: LD_ADDR_VAR 0 17
82266: PUSH
82267: LD_INT 0
82269: ST_TO_ADDR
// f_capture := false ;
82270: LD_ADDR_VAR 0 18
82274: PUSH
82275: LD_INT 0
82277: ST_TO_ADDR
// f_ignore_civ := false ;
82278: LD_ADDR_VAR 0 19
82282: PUSH
82283: LD_INT 0
82285: ST_TO_ADDR
// f_murder := false ;
82286: LD_ADDR_VAR 0 20
82290: PUSH
82291: LD_INT 0
82293: ST_TO_ADDR
// f_mines := false ;
82294: LD_ADDR_VAR 0 21
82298: PUSH
82299: LD_INT 0
82301: ST_TO_ADDR
// f_repair := false ;
82302: LD_ADDR_VAR 0 22
82306: PUSH
82307: LD_INT 0
82309: ST_TO_ADDR
// f_heal := false ;
82310: LD_ADDR_VAR 0 23
82314: PUSH
82315: LD_INT 0
82317: ST_TO_ADDR
// f_spacetime := false ;
82318: LD_ADDR_VAR 0 24
82322: PUSH
82323: LD_INT 0
82325: ST_TO_ADDR
// f_attack_depot := false ;
82326: LD_ADDR_VAR 0 25
82330: PUSH
82331: LD_INT 0
82333: ST_TO_ADDR
// f_crawl := false ;
82334: LD_ADDR_VAR 0 26
82338: PUSH
82339: LD_INT 0
82341: ST_TO_ADDR
// end ; if f_heal then
82342: LD_VAR 0 23
82346: IFFALSE 82373
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82348: LD_ADDR_VAR 0 31
82352: PUSH
82353: LD_VAR 0 4
82357: PPUSH
82358: LD_INT 25
82360: PUSH
82361: LD_INT 4
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PPUSH
82368: CALL_OW 72
82372: ST_TO_ADDR
// if f_repair then
82373: LD_VAR 0 22
82377: IFFALSE 82404
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82379: LD_ADDR_VAR 0 33
82383: PUSH
82384: LD_VAR 0 4
82388: PPUSH
82389: LD_INT 25
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PPUSH
82399: CALL_OW 72
82403: ST_TO_ADDR
// units_path := [ ] ;
82404: LD_ADDR_VAR 0 16
82408: PUSH
82409: EMPTY
82410: ST_TO_ADDR
// for i = 1 to group do
82411: LD_ADDR_VAR 0 7
82415: PUSH
82416: DOUBLE
82417: LD_INT 1
82419: DEC
82420: ST_TO_ADDR
82421: LD_VAR 0 4
82425: PUSH
82426: FOR_TO
82427: IFFALSE 82456
// units_path := Replace ( units_path , i , path ) ;
82429: LD_ADDR_VAR 0 16
82433: PUSH
82434: LD_VAR 0 16
82438: PPUSH
82439: LD_VAR 0 7
82443: PPUSH
82444: LD_VAR 0 5
82448: PPUSH
82449: CALL_OW 1
82453: ST_TO_ADDR
82454: GO 82426
82456: POP
82457: POP
// repeat for i = group downto 1 do
82458: LD_ADDR_VAR 0 7
82462: PUSH
82463: DOUBLE
82464: LD_VAR 0 4
82468: INC
82469: ST_TO_ADDR
82470: LD_INT 1
82472: PUSH
82473: FOR_DOWNTO
82474: IFFALSE 86596
// begin wait ( 5 ) ;
82476: LD_INT 5
82478: PPUSH
82479: CALL_OW 67
// tmp := [ ] ;
82483: LD_ADDR_VAR 0 14
82487: PUSH
82488: EMPTY
82489: ST_TO_ADDR
// attacking := false ;
82490: LD_ADDR_VAR 0 29
82494: PUSH
82495: LD_INT 0
82497: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82498: LD_VAR 0 4
82502: PUSH
82503: LD_VAR 0 7
82507: ARRAY
82508: PPUSH
82509: CALL_OW 301
82513: PUSH
82514: LD_VAR 0 4
82518: PUSH
82519: LD_VAR 0 7
82523: ARRAY
82524: NOT
82525: OR
82526: IFFALSE 82635
// begin if GetType ( group [ i ] ) = unit_human then
82528: LD_VAR 0 4
82532: PUSH
82533: LD_VAR 0 7
82537: ARRAY
82538: PPUSH
82539: CALL_OW 247
82543: PUSH
82544: LD_INT 1
82546: EQUAL
82547: IFFALSE 82593
// begin to_heal := to_heal diff group [ i ] ;
82549: LD_ADDR_VAR 0 30
82553: PUSH
82554: LD_VAR 0 30
82558: PUSH
82559: LD_VAR 0 4
82563: PUSH
82564: LD_VAR 0 7
82568: ARRAY
82569: DIFF
82570: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82571: LD_ADDR_VAR 0 31
82575: PUSH
82576: LD_VAR 0 31
82580: PUSH
82581: LD_VAR 0 4
82585: PUSH
82586: LD_VAR 0 7
82590: ARRAY
82591: DIFF
82592: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82593: LD_ADDR_VAR 0 4
82597: PUSH
82598: LD_VAR 0 4
82602: PPUSH
82603: LD_VAR 0 7
82607: PPUSH
82608: CALL_OW 3
82612: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82613: LD_ADDR_VAR 0 16
82617: PUSH
82618: LD_VAR 0 16
82622: PPUSH
82623: LD_VAR 0 7
82627: PPUSH
82628: CALL_OW 3
82632: ST_TO_ADDR
// continue ;
82633: GO 82473
// end ; if f_repair then
82635: LD_VAR 0 22
82639: IFFALSE 83128
// begin if GetType ( group [ i ] ) = unit_vehicle then
82641: LD_VAR 0 4
82645: PUSH
82646: LD_VAR 0 7
82650: ARRAY
82651: PPUSH
82652: CALL_OW 247
82656: PUSH
82657: LD_INT 2
82659: EQUAL
82660: IFFALSE 82850
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82662: LD_VAR 0 4
82666: PUSH
82667: LD_VAR 0 7
82671: ARRAY
82672: PPUSH
82673: CALL_OW 256
82677: PUSH
82678: LD_INT 700
82680: LESS
82681: PUSH
82682: LD_VAR 0 4
82686: PUSH
82687: LD_VAR 0 7
82691: ARRAY
82692: PUSH
82693: LD_VAR 0 32
82697: IN
82698: NOT
82699: AND
82700: IFFALSE 82724
// to_repair := to_repair union group [ i ] ;
82702: LD_ADDR_VAR 0 32
82706: PUSH
82707: LD_VAR 0 32
82711: PUSH
82712: LD_VAR 0 4
82716: PUSH
82717: LD_VAR 0 7
82721: ARRAY
82722: UNION
82723: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82724: LD_VAR 0 4
82728: PUSH
82729: LD_VAR 0 7
82733: ARRAY
82734: PPUSH
82735: CALL_OW 256
82739: PUSH
82740: LD_INT 1000
82742: EQUAL
82743: PUSH
82744: LD_VAR 0 4
82748: PUSH
82749: LD_VAR 0 7
82753: ARRAY
82754: PUSH
82755: LD_VAR 0 32
82759: IN
82760: AND
82761: IFFALSE 82785
// to_repair := to_repair diff group [ i ] ;
82763: LD_ADDR_VAR 0 32
82767: PUSH
82768: LD_VAR 0 32
82772: PUSH
82773: LD_VAR 0 4
82777: PUSH
82778: LD_VAR 0 7
82782: ARRAY
82783: DIFF
82784: ST_TO_ADDR
// if group [ i ] in to_repair then
82785: LD_VAR 0 4
82789: PUSH
82790: LD_VAR 0 7
82794: ARRAY
82795: PUSH
82796: LD_VAR 0 32
82800: IN
82801: IFFALSE 82848
// begin if not IsInArea ( group [ i ] , f_repair ) then
82803: LD_VAR 0 4
82807: PUSH
82808: LD_VAR 0 7
82812: ARRAY
82813: PPUSH
82814: LD_VAR 0 22
82818: PPUSH
82819: CALL_OW 308
82823: NOT
82824: IFFALSE 82846
// ComMoveToArea ( group [ i ] , f_repair ) ;
82826: LD_VAR 0 4
82830: PUSH
82831: LD_VAR 0 7
82835: ARRAY
82836: PPUSH
82837: LD_VAR 0 22
82841: PPUSH
82842: CALL_OW 113
// continue ;
82846: GO 82473
// end ; end else
82848: GO 83128
// if group [ i ] in repairs then
82850: LD_VAR 0 4
82854: PUSH
82855: LD_VAR 0 7
82859: ARRAY
82860: PUSH
82861: LD_VAR 0 33
82865: IN
82866: IFFALSE 83128
// begin if IsInUnit ( group [ i ] ) then
82868: LD_VAR 0 4
82872: PUSH
82873: LD_VAR 0 7
82877: ARRAY
82878: PPUSH
82879: CALL_OW 310
82883: IFFALSE 82951
// begin z := IsInUnit ( group [ i ] ) ;
82885: LD_ADDR_VAR 0 13
82889: PUSH
82890: LD_VAR 0 4
82894: PUSH
82895: LD_VAR 0 7
82899: ARRAY
82900: PPUSH
82901: CALL_OW 310
82905: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82906: LD_VAR 0 13
82910: PUSH
82911: LD_VAR 0 32
82915: IN
82916: PUSH
82917: LD_VAR 0 13
82921: PPUSH
82922: LD_VAR 0 22
82926: PPUSH
82927: CALL_OW 308
82931: AND
82932: IFFALSE 82949
// ComExitVehicle ( group [ i ] ) ;
82934: LD_VAR 0 4
82938: PUSH
82939: LD_VAR 0 7
82943: ARRAY
82944: PPUSH
82945: CALL_OW 121
// end else
82949: GO 83128
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82951: LD_ADDR_VAR 0 13
82955: PUSH
82956: LD_VAR 0 4
82960: PPUSH
82961: LD_INT 95
82963: PUSH
82964: LD_VAR 0 22
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 58
82975: PUSH
82976: EMPTY
82977: LIST
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PPUSH
82983: CALL_OW 72
82987: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82988: LD_VAR 0 4
82992: PUSH
82993: LD_VAR 0 7
82997: ARRAY
82998: PPUSH
82999: CALL_OW 314
83003: NOT
83004: IFFALSE 83126
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83006: LD_ADDR_VAR 0 10
83010: PUSH
83011: LD_VAR 0 13
83015: PPUSH
83016: LD_VAR 0 4
83020: PUSH
83021: LD_VAR 0 7
83025: ARRAY
83026: PPUSH
83027: CALL_OW 74
83031: ST_TO_ADDR
// if not x then
83032: LD_VAR 0 10
83036: NOT
83037: IFFALSE 83041
// continue ;
83039: GO 82473
// if GetLives ( x ) < 1000 then
83041: LD_VAR 0 10
83045: PPUSH
83046: CALL_OW 256
83050: PUSH
83051: LD_INT 1000
83053: LESS
83054: IFFALSE 83078
// ComRepairVehicle ( group [ i ] , x ) else
83056: LD_VAR 0 4
83060: PUSH
83061: LD_VAR 0 7
83065: ARRAY
83066: PPUSH
83067: LD_VAR 0 10
83071: PPUSH
83072: CALL_OW 129
83076: GO 83126
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83078: LD_VAR 0 23
83082: PUSH
83083: LD_VAR 0 4
83087: PUSH
83088: LD_VAR 0 7
83092: ARRAY
83093: PPUSH
83094: CALL_OW 256
83098: PUSH
83099: LD_INT 1000
83101: LESS
83102: AND
83103: NOT
83104: IFFALSE 83126
// ComEnterUnit ( group [ i ] , x ) ;
83106: LD_VAR 0 4
83110: PUSH
83111: LD_VAR 0 7
83115: ARRAY
83116: PPUSH
83117: LD_VAR 0 10
83121: PPUSH
83122: CALL_OW 120
// end ; continue ;
83126: GO 82473
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83128: LD_VAR 0 23
83132: PUSH
83133: LD_VAR 0 4
83137: PUSH
83138: LD_VAR 0 7
83142: ARRAY
83143: PPUSH
83144: CALL_OW 247
83148: PUSH
83149: LD_INT 1
83151: EQUAL
83152: AND
83153: IFFALSE 83631
// begin if group [ i ] in healers then
83155: LD_VAR 0 4
83159: PUSH
83160: LD_VAR 0 7
83164: ARRAY
83165: PUSH
83166: LD_VAR 0 31
83170: IN
83171: IFFALSE 83444
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83173: LD_VAR 0 4
83177: PUSH
83178: LD_VAR 0 7
83182: ARRAY
83183: PPUSH
83184: LD_VAR 0 23
83188: PPUSH
83189: CALL_OW 308
83193: NOT
83194: PUSH
83195: LD_VAR 0 4
83199: PUSH
83200: LD_VAR 0 7
83204: ARRAY
83205: PPUSH
83206: CALL_OW 314
83210: NOT
83211: AND
83212: IFFALSE 83236
// ComMoveToArea ( group [ i ] , f_heal ) else
83214: LD_VAR 0 4
83218: PUSH
83219: LD_VAR 0 7
83223: ARRAY
83224: PPUSH
83225: LD_VAR 0 23
83229: PPUSH
83230: CALL_OW 113
83234: GO 83442
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83236: LD_VAR 0 4
83240: PUSH
83241: LD_VAR 0 7
83245: ARRAY
83246: PPUSH
83247: CALL 44711 0 1
83251: PPUSH
83252: CALL_OW 256
83256: PUSH
83257: LD_INT 1000
83259: EQUAL
83260: IFFALSE 83279
// ComStop ( group [ i ] ) else
83262: LD_VAR 0 4
83266: PUSH
83267: LD_VAR 0 7
83271: ARRAY
83272: PPUSH
83273: CALL_OW 141
83277: GO 83442
// if not HasTask ( group [ i ] ) and to_heal then
83279: LD_VAR 0 4
83283: PUSH
83284: LD_VAR 0 7
83288: ARRAY
83289: PPUSH
83290: CALL_OW 314
83294: NOT
83295: PUSH
83296: LD_VAR 0 30
83300: AND
83301: IFFALSE 83442
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83303: LD_ADDR_VAR 0 13
83307: PUSH
83308: LD_VAR 0 30
83312: PPUSH
83313: LD_INT 3
83315: PUSH
83316: LD_INT 54
83318: PUSH
83319: EMPTY
83320: LIST
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PPUSH
83326: CALL_OW 72
83330: PPUSH
83331: LD_VAR 0 4
83335: PUSH
83336: LD_VAR 0 7
83340: ARRAY
83341: PPUSH
83342: CALL_OW 74
83346: ST_TO_ADDR
// if z then
83347: LD_VAR 0 13
83351: IFFALSE 83442
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83353: LD_INT 91
83355: PUSH
83356: LD_VAR 0 13
83360: PUSH
83361: LD_INT 10
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 81
83371: PUSH
83372: LD_VAR 0 13
83376: PPUSH
83377: CALL_OW 255
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PPUSH
83390: CALL_OW 69
83394: PUSH
83395: LD_INT 0
83397: EQUAL
83398: IFFALSE 83422
// ComHeal ( group [ i ] , z ) else
83400: LD_VAR 0 4
83404: PUSH
83405: LD_VAR 0 7
83409: ARRAY
83410: PPUSH
83411: LD_VAR 0 13
83415: PPUSH
83416: CALL_OW 128
83420: GO 83442
// ComMoveToArea ( group [ i ] , f_heal ) ;
83422: LD_VAR 0 4
83426: PUSH
83427: LD_VAR 0 7
83431: ARRAY
83432: PPUSH
83433: LD_VAR 0 23
83437: PPUSH
83438: CALL_OW 113
// end ; continue ;
83442: GO 82473
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83444: LD_VAR 0 4
83448: PUSH
83449: LD_VAR 0 7
83453: ARRAY
83454: PPUSH
83455: CALL_OW 256
83459: PUSH
83460: LD_INT 700
83462: LESS
83463: PUSH
83464: LD_VAR 0 4
83468: PUSH
83469: LD_VAR 0 7
83473: ARRAY
83474: PUSH
83475: LD_VAR 0 30
83479: IN
83480: NOT
83481: AND
83482: IFFALSE 83506
// to_heal := to_heal union group [ i ] ;
83484: LD_ADDR_VAR 0 30
83488: PUSH
83489: LD_VAR 0 30
83493: PUSH
83494: LD_VAR 0 4
83498: PUSH
83499: LD_VAR 0 7
83503: ARRAY
83504: UNION
83505: ST_TO_ADDR
// if group [ i ] in to_heal then
83506: LD_VAR 0 4
83510: PUSH
83511: LD_VAR 0 7
83515: ARRAY
83516: PUSH
83517: LD_VAR 0 30
83521: IN
83522: IFFALSE 83631
// begin if GetLives ( group [ i ] ) = 1000 then
83524: LD_VAR 0 4
83528: PUSH
83529: LD_VAR 0 7
83533: ARRAY
83534: PPUSH
83535: CALL_OW 256
83539: PUSH
83540: LD_INT 1000
83542: EQUAL
83543: IFFALSE 83569
// to_heal := to_heal diff group [ i ] else
83545: LD_ADDR_VAR 0 30
83549: PUSH
83550: LD_VAR 0 30
83554: PUSH
83555: LD_VAR 0 4
83559: PUSH
83560: LD_VAR 0 7
83564: ARRAY
83565: DIFF
83566: ST_TO_ADDR
83567: GO 83631
// begin if not IsInArea ( group [ i ] , to_heal ) then
83569: LD_VAR 0 4
83573: PUSH
83574: LD_VAR 0 7
83578: ARRAY
83579: PPUSH
83580: LD_VAR 0 30
83584: PPUSH
83585: CALL_OW 308
83589: NOT
83590: IFFALSE 83614
// ComMoveToArea ( group [ i ] , f_heal ) else
83592: LD_VAR 0 4
83596: PUSH
83597: LD_VAR 0 7
83601: ARRAY
83602: PPUSH
83603: LD_VAR 0 23
83607: PPUSH
83608: CALL_OW 113
83612: GO 83629
// ComHold ( group [ i ] ) ;
83614: LD_VAR 0 4
83618: PUSH
83619: LD_VAR 0 7
83623: ARRAY
83624: PPUSH
83625: CALL_OW 140
// continue ;
83629: GO 82473
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83631: LD_VAR 0 4
83635: PUSH
83636: LD_VAR 0 7
83640: ARRAY
83641: PPUSH
83642: LD_INT 10
83644: PPUSH
83645: CALL 42482 0 2
83649: NOT
83650: PUSH
83651: LD_VAR 0 16
83655: PUSH
83656: LD_VAR 0 7
83660: ARRAY
83661: PUSH
83662: EMPTY
83663: EQUAL
83664: NOT
83665: AND
83666: IFFALSE 83932
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83668: LD_VAR 0 4
83672: PUSH
83673: LD_VAR 0 7
83677: ARRAY
83678: PPUSH
83679: CALL_OW 262
83683: PUSH
83684: LD_INT 1
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: IN
83694: IFFALSE 83735
// if GetFuel ( group [ i ] ) < 10 then
83696: LD_VAR 0 4
83700: PUSH
83701: LD_VAR 0 7
83705: ARRAY
83706: PPUSH
83707: CALL_OW 261
83711: PUSH
83712: LD_INT 10
83714: LESS
83715: IFFALSE 83735
// SetFuel ( group [ i ] , 12 ) ;
83717: LD_VAR 0 4
83721: PUSH
83722: LD_VAR 0 7
83726: ARRAY
83727: PPUSH
83728: LD_INT 12
83730: PPUSH
83731: CALL_OW 240
// if units_path [ i ] then
83735: LD_VAR 0 16
83739: PUSH
83740: LD_VAR 0 7
83744: ARRAY
83745: IFFALSE 83930
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83747: LD_VAR 0 4
83751: PUSH
83752: LD_VAR 0 7
83756: ARRAY
83757: PPUSH
83758: LD_VAR 0 16
83762: PUSH
83763: LD_VAR 0 7
83767: ARRAY
83768: PUSH
83769: LD_INT 1
83771: ARRAY
83772: PUSH
83773: LD_INT 1
83775: ARRAY
83776: PPUSH
83777: LD_VAR 0 16
83781: PUSH
83782: LD_VAR 0 7
83786: ARRAY
83787: PUSH
83788: LD_INT 1
83790: ARRAY
83791: PUSH
83792: LD_INT 2
83794: ARRAY
83795: PPUSH
83796: CALL_OW 297
83800: PUSH
83801: LD_INT 6
83803: GREATER
83804: IFFALSE 83879
// begin if not HasTask ( group [ i ] ) then
83806: LD_VAR 0 4
83810: PUSH
83811: LD_VAR 0 7
83815: ARRAY
83816: PPUSH
83817: CALL_OW 314
83821: NOT
83822: IFFALSE 83877
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83824: LD_VAR 0 4
83828: PUSH
83829: LD_VAR 0 7
83833: ARRAY
83834: PPUSH
83835: LD_VAR 0 16
83839: PUSH
83840: LD_VAR 0 7
83844: ARRAY
83845: PUSH
83846: LD_INT 1
83848: ARRAY
83849: PUSH
83850: LD_INT 1
83852: ARRAY
83853: PPUSH
83854: LD_VAR 0 16
83858: PUSH
83859: LD_VAR 0 7
83863: ARRAY
83864: PUSH
83865: LD_INT 1
83867: ARRAY
83868: PUSH
83869: LD_INT 2
83871: ARRAY
83872: PPUSH
83873: CALL_OW 114
// end else
83877: GO 83930
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83879: LD_ADDR_VAR 0 15
83883: PUSH
83884: LD_VAR 0 16
83888: PUSH
83889: LD_VAR 0 7
83893: ARRAY
83894: PPUSH
83895: LD_INT 1
83897: PPUSH
83898: CALL_OW 3
83902: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83903: LD_ADDR_VAR 0 16
83907: PUSH
83908: LD_VAR 0 16
83912: PPUSH
83913: LD_VAR 0 7
83917: PPUSH
83918: LD_VAR 0 15
83922: PPUSH
83923: CALL_OW 1
83927: ST_TO_ADDR
// continue ;
83928: GO 82473
// end ; end ; end else
83930: GO 86594
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83932: LD_ADDR_VAR 0 14
83936: PUSH
83937: LD_INT 81
83939: PUSH
83940: LD_VAR 0 4
83944: PUSH
83945: LD_VAR 0 7
83949: ARRAY
83950: PPUSH
83951: CALL_OW 255
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PPUSH
83960: CALL_OW 69
83964: ST_TO_ADDR
// if not tmp then
83965: LD_VAR 0 14
83969: NOT
83970: IFFALSE 83974
// continue ;
83972: GO 82473
// if f_ignore_area then
83974: LD_VAR 0 17
83978: IFFALSE 84066
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83980: LD_ADDR_VAR 0 15
83984: PUSH
83985: LD_VAR 0 14
83989: PPUSH
83990: LD_INT 3
83992: PUSH
83993: LD_INT 92
83995: PUSH
83996: LD_VAR 0 17
84000: PUSH
84001: LD_INT 1
84003: ARRAY
84004: PUSH
84005: LD_VAR 0 17
84009: PUSH
84010: LD_INT 2
84012: ARRAY
84013: PUSH
84014: LD_VAR 0 17
84018: PUSH
84019: LD_INT 3
84021: ARRAY
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PPUSH
84033: CALL_OW 72
84037: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84038: LD_VAR 0 14
84042: PUSH
84043: LD_VAR 0 15
84047: DIFF
84048: IFFALSE 84066
// tmp := tmp diff tmp2 ;
84050: LD_ADDR_VAR 0 14
84054: PUSH
84055: LD_VAR 0 14
84059: PUSH
84060: LD_VAR 0 15
84064: DIFF
84065: ST_TO_ADDR
// end ; if not f_murder then
84066: LD_VAR 0 20
84070: NOT
84071: IFFALSE 84129
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84073: LD_ADDR_VAR 0 15
84077: PUSH
84078: LD_VAR 0 14
84082: PPUSH
84083: LD_INT 3
84085: PUSH
84086: LD_INT 50
84088: PUSH
84089: EMPTY
84090: LIST
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PPUSH
84096: CALL_OW 72
84100: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84101: LD_VAR 0 14
84105: PUSH
84106: LD_VAR 0 15
84110: DIFF
84111: IFFALSE 84129
// tmp := tmp diff tmp2 ;
84113: LD_ADDR_VAR 0 14
84117: PUSH
84118: LD_VAR 0 14
84122: PUSH
84123: LD_VAR 0 15
84127: DIFF
84128: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84129: LD_ADDR_VAR 0 14
84133: PUSH
84134: LD_VAR 0 4
84138: PUSH
84139: LD_VAR 0 7
84143: ARRAY
84144: PPUSH
84145: LD_VAR 0 14
84149: PPUSH
84150: LD_INT 1
84152: PPUSH
84153: LD_INT 1
84155: PPUSH
84156: CALL 15423 0 4
84160: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84161: LD_VAR 0 4
84165: PUSH
84166: LD_VAR 0 7
84170: ARRAY
84171: PPUSH
84172: CALL_OW 257
84176: PUSH
84177: LD_INT 1
84179: EQUAL
84180: IFFALSE 84628
// begin if WantPlant ( group [ i ] ) then
84182: LD_VAR 0 4
84186: PUSH
84187: LD_VAR 0 7
84191: ARRAY
84192: PPUSH
84193: CALL 14924 0 1
84197: IFFALSE 84201
// continue ;
84199: GO 82473
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84201: LD_VAR 0 18
84205: PUSH
84206: LD_VAR 0 4
84210: PUSH
84211: LD_VAR 0 7
84215: ARRAY
84216: PPUSH
84217: CALL_OW 310
84221: NOT
84222: AND
84223: PUSH
84224: LD_VAR 0 14
84228: PUSH
84229: LD_INT 1
84231: ARRAY
84232: PUSH
84233: LD_VAR 0 14
84237: PPUSH
84238: LD_INT 21
84240: PUSH
84241: LD_INT 2
84243: PUSH
84244: EMPTY
84245: LIST
84246: LIST
84247: PUSH
84248: LD_INT 58
84250: PUSH
84251: EMPTY
84252: LIST
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PPUSH
84258: CALL_OW 72
84262: IN
84263: AND
84264: IFFALSE 84300
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84266: LD_VAR 0 4
84270: PUSH
84271: LD_VAR 0 7
84275: ARRAY
84276: PPUSH
84277: LD_VAR 0 14
84281: PUSH
84282: LD_INT 1
84284: ARRAY
84285: PPUSH
84286: CALL_OW 120
// attacking := true ;
84290: LD_ADDR_VAR 0 29
84294: PUSH
84295: LD_INT 1
84297: ST_TO_ADDR
// continue ;
84298: GO 82473
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84300: LD_VAR 0 26
84304: PUSH
84305: LD_VAR 0 4
84309: PUSH
84310: LD_VAR 0 7
84314: ARRAY
84315: PPUSH
84316: CALL_OW 257
84320: PUSH
84321: LD_INT 1
84323: EQUAL
84324: AND
84325: PUSH
84326: LD_VAR 0 4
84330: PUSH
84331: LD_VAR 0 7
84335: ARRAY
84336: PPUSH
84337: CALL_OW 256
84341: PUSH
84342: LD_INT 800
84344: LESS
84345: AND
84346: PUSH
84347: LD_VAR 0 4
84351: PUSH
84352: LD_VAR 0 7
84356: ARRAY
84357: PPUSH
84358: CALL_OW 318
84362: NOT
84363: AND
84364: IFFALSE 84381
// ComCrawl ( group [ i ] ) ;
84366: LD_VAR 0 4
84370: PUSH
84371: LD_VAR 0 7
84375: ARRAY
84376: PPUSH
84377: CALL_OW 137
// if f_mines then
84381: LD_VAR 0 21
84385: IFFALSE 84628
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84387: LD_VAR 0 14
84391: PUSH
84392: LD_INT 1
84394: ARRAY
84395: PPUSH
84396: CALL_OW 247
84400: PUSH
84401: LD_INT 3
84403: EQUAL
84404: PUSH
84405: LD_VAR 0 14
84409: PUSH
84410: LD_INT 1
84412: ARRAY
84413: PUSH
84414: LD_VAR 0 27
84418: IN
84419: NOT
84420: AND
84421: IFFALSE 84628
// begin x := GetX ( tmp [ 1 ] ) ;
84423: LD_ADDR_VAR 0 10
84427: PUSH
84428: LD_VAR 0 14
84432: PUSH
84433: LD_INT 1
84435: ARRAY
84436: PPUSH
84437: CALL_OW 250
84441: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84442: LD_ADDR_VAR 0 11
84446: PUSH
84447: LD_VAR 0 14
84451: PUSH
84452: LD_INT 1
84454: ARRAY
84455: PPUSH
84456: CALL_OW 251
84460: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84461: LD_ADDR_VAR 0 12
84465: PUSH
84466: LD_VAR 0 4
84470: PUSH
84471: LD_VAR 0 7
84475: ARRAY
84476: PPUSH
84477: CALL 42567 0 1
84481: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84482: LD_VAR 0 4
84486: PUSH
84487: LD_VAR 0 7
84491: ARRAY
84492: PPUSH
84493: LD_VAR 0 10
84497: PPUSH
84498: LD_VAR 0 11
84502: PPUSH
84503: LD_VAR 0 14
84507: PUSH
84508: LD_INT 1
84510: ARRAY
84511: PPUSH
84512: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84516: LD_VAR 0 4
84520: PUSH
84521: LD_VAR 0 7
84525: ARRAY
84526: PPUSH
84527: LD_VAR 0 10
84531: PPUSH
84532: LD_VAR 0 12
84536: PPUSH
84537: LD_INT 7
84539: PPUSH
84540: CALL_OW 272
84544: PPUSH
84545: LD_VAR 0 11
84549: PPUSH
84550: LD_VAR 0 12
84554: PPUSH
84555: LD_INT 7
84557: PPUSH
84558: CALL_OW 273
84562: PPUSH
84563: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84567: LD_VAR 0 4
84571: PUSH
84572: LD_VAR 0 7
84576: ARRAY
84577: PPUSH
84578: LD_INT 71
84580: PPUSH
84581: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84585: LD_ADDR_VAR 0 27
84589: PUSH
84590: LD_VAR 0 27
84594: PPUSH
84595: LD_VAR 0 27
84599: PUSH
84600: LD_INT 1
84602: PLUS
84603: PPUSH
84604: LD_VAR 0 14
84608: PUSH
84609: LD_INT 1
84611: ARRAY
84612: PPUSH
84613: CALL_OW 1
84617: ST_TO_ADDR
// attacking := true ;
84618: LD_ADDR_VAR 0 29
84622: PUSH
84623: LD_INT 1
84625: ST_TO_ADDR
// continue ;
84626: GO 82473
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84628: LD_VAR 0 4
84632: PUSH
84633: LD_VAR 0 7
84637: ARRAY
84638: PPUSH
84639: CALL_OW 257
84643: PUSH
84644: LD_INT 17
84646: EQUAL
84647: PUSH
84648: LD_VAR 0 4
84652: PUSH
84653: LD_VAR 0 7
84657: ARRAY
84658: PPUSH
84659: CALL_OW 110
84663: PUSH
84664: LD_INT 71
84666: EQUAL
84667: NOT
84668: AND
84669: IFFALSE 84815
// begin attacking := false ;
84671: LD_ADDR_VAR 0 29
84675: PUSH
84676: LD_INT 0
84678: ST_TO_ADDR
// k := 5 ;
84679: LD_ADDR_VAR 0 9
84683: PUSH
84684: LD_INT 5
84686: ST_TO_ADDR
// if tmp < k then
84687: LD_VAR 0 14
84691: PUSH
84692: LD_VAR 0 9
84696: LESS
84697: IFFALSE 84709
// k := tmp ;
84699: LD_ADDR_VAR 0 9
84703: PUSH
84704: LD_VAR 0 14
84708: ST_TO_ADDR
// for j = 1 to k do
84709: LD_ADDR_VAR 0 8
84713: PUSH
84714: DOUBLE
84715: LD_INT 1
84717: DEC
84718: ST_TO_ADDR
84719: LD_VAR 0 9
84723: PUSH
84724: FOR_TO
84725: IFFALSE 84813
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84727: LD_VAR 0 14
84731: PUSH
84732: LD_VAR 0 8
84736: ARRAY
84737: PUSH
84738: LD_VAR 0 14
84742: PPUSH
84743: LD_INT 58
84745: PUSH
84746: EMPTY
84747: LIST
84748: PPUSH
84749: CALL_OW 72
84753: IN
84754: NOT
84755: IFFALSE 84811
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84757: LD_VAR 0 4
84761: PUSH
84762: LD_VAR 0 7
84766: ARRAY
84767: PPUSH
84768: LD_VAR 0 14
84772: PUSH
84773: LD_VAR 0 8
84777: ARRAY
84778: PPUSH
84779: CALL_OW 115
// attacking := true ;
84783: LD_ADDR_VAR 0 29
84787: PUSH
84788: LD_INT 1
84790: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84791: LD_VAR 0 4
84795: PUSH
84796: LD_VAR 0 7
84800: ARRAY
84801: PPUSH
84802: LD_INT 71
84804: PPUSH
84805: CALL_OW 109
// continue ;
84809: GO 84724
// end ; end ;
84811: GO 84724
84813: POP
84814: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84815: LD_VAR 0 4
84819: PUSH
84820: LD_VAR 0 7
84824: ARRAY
84825: PPUSH
84826: CALL_OW 257
84830: PUSH
84831: LD_INT 8
84833: EQUAL
84834: PUSH
84835: LD_VAR 0 4
84839: PUSH
84840: LD_VAR 0 7
84844: ARRAY
84845: PPUSH
84846: CALL_OW 264
84850: PUSH
84851: LD_INT 28
84853: PUSH
84854: LD_INT 45
84856: PUSH
84857: LD_INT 7
84859: PUSH
84860: LD_INT 47
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: IN
84869: OR
84870: IFFALSE 85126
// begin attacking := false ;
84872: LD_ADDR_VAR 0 29
84876: PUSH
84877: LD_INT 0
84879: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84880: LD_VAR 0 14
84884: PUSH
84885: LD_INT 1
84887: ARRAY
84888: PPUSH
84889: CALL_OW 266
84893: PUSH
84894: LD_INT 32
84896: PUSH
84897: LD_INT 31
84899: PUSH
84900: LD_INT 33
84902: PUSH
84903: LD_INT 4
84905: PUSH
84906: LD_INT 5
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: IN
84916: IFFALSE 85102
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84918: LD_ADDR_VAR 0 9
84922: PUSH
84923: LD_VAR 0 14
84927: PUSH
84928: LD_INT 1
84930: ARRAY
84931: PPUSH
84932: CALL_OW 266
84936: PPUSH
84937: LD_VAR 0 14
84941: PUSH
84942: LD_INT 1
84944: ARRAY
84945: PPUSH
84946: CALL_OW 250
84950: PPUSH
84951: LD_VAR 0 14
84955: PUSH
84956: LD_INT 1
84958: ARRAY
84959: PPUSH
84960: CALL_OW 251
84964: PPUSH
84965: LD_VAR 0 14
84969: PUSH
84970: LD_INT 1
84972: ARRAY
84973: PPUSH
84974: CALL_OW 254
84978: PPUSH
84979: LD_VAR 0 14
84983: PUSH
84984: LD_INT 1
84986: ARRAY
84987: PPUSH
84988: CALL_OW 248
84992: PPUSH
84993: LD_INT 0
84995: PPUSH
84996: CALL 23937 0 6
85000: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85001: LD_ADDR_VAR 0 8
85005: PUSH
85006: LD_VAR 0 4
85010: PUSH
85011: LD_VAR 0 7
85015: ARRAY
85016: PPUSH
85017: LD_VAR 0 9
85021: PPUSH
85022: CALL 42680 0 2
85026: ST_TO_ADDR
// if j then
85027: LD_VAR 0 8
85031: IFFALSE 85100
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85033: LD_VAR 0 8
85037: PUSH
85038: LD_INT 1
85040: ARRAY
85041: PPUSH
85042: LD_VAR 0 8
85046: PUSH
85047: LD_INT 2
85049: ARRAY
85050: PPUSH
85051: CALL_OW 488
85055: IFFALSE 85100
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85057: LD_VAR 0 4
85061: PUSH
85062: LD_VAR 0 7
85066: ARRAY
85067: PPUSH
85068: LD_VAR 0 8
85072: PUSH
85073: LD_INT 1
85075: ARRAY
85076: PPUSH
85077: LD_VAR 0 8
85081: PUSH
85082: LD_INT 2
85084: ARRAY
85085: PPUSH
85086: CALL_OW 116
// attacking := true ;
85090: LD_ADDR_VAR 0 29
85094: PUSH
85095: LD_INT 1
85097: ST_TO_ADDR
// continue ;
85098: GO 82473
// end ; end else
85100: GO 85126
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85102: LD_VAR 0 4
85106: PUSH
85107: LD_VAR 0 7
85111: ARRAY
85112: PPUSH
85113: LD_VAR 0 14
85117: PUSH
85118: LD_INT 1
85120: ARRAY
85121: PPUSH
85122: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85126: LD_VAR 0 4
85130: PUSH
85131: LD_VAR 0 7
85135: ARRAY
85136: PPUSH
85137: CALL_OW 265
85141: PUSH
85142: LD_INT 11
85144: EQUAL
85145: IFFALSE 85423
// begin k := 10 ;
85147: LD_ADDR_VAR 0 9
85151: PUSH
85152: LD_INT 10
85154: ST_TO_ADDR
// x := 0 ;
85155: LD_ADDR_VAR 0 10
85159: PUSH
85160: LD_INT 0
85162: ST_TO_ADDR
// if tmp < k then
85163: LD_VAR 0 14
85167: PUSH
85168: LD_VAR 0 9
85172: LESS
85173: IFFALSE 85185
// k := tmp ;
85175: LD_ADDR_VAR 0 9
85179: PUSH
85180: LD_VAR 0 14
85184: ST_TO_ADDR
// for j = k downto 1 do
85185: LD_ADDR_VAR 0 8
85189: PUSH
85190: DOUBLE
85191: LD_VAR 0 9
85195: INC
85196: ST_TO_ADDR
85197: LD_INT 1
85199: PUSH
85200: FOR_DOWNTO
85201: IFFALSE 85276
// begin if GetType ( tmp [ j ] ) = unit_human then
85203: LD_VAR 0 14
85207: PUSH
85208: LD_VAR 0 8
85212: ARRAY
85213: PPUSH
85214: CALL_OW 247
85218: PUSH
85219: LD_INT 1
85221: EQUAL
85222: IFFALSE 85274
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85224: LD_VAR 0 4
85228: PUSH
85229: LD_VAR 0 7
85233: ARRAY
85234: PPUSH
85235: LD_VAR 0 14
85239: PUSH
85240: LD_VAR 0 8
85244: ARRAY
85245: PPUSH
85246: CALL 42934 0 2
// x := tmp [ j ] ;
85250: LD_ADDR_VAR 0 10
85254: PUSH
85255: LD_VAR 0 14
85259: PUSH
85260: LD_VAR 0 8
85264: ARRAY
85265: ST_TO_ADDR
// attacking := true ;
85266: LD_ADDR_VAR 0 29
85270: PUSH
85271: LD_INT 1
85273: ST_TO_ADDR
// end ; end ;
85274: GO 85200
85276: POP
85277: POP
// if not x then
85278: LD_VAR 0 10
85282: NOT
85283: IFFALSE 85423
// begin attacking := true ;
85285: LD_ADDR_VAR 0 29
85289: PUSH
85290: LD_INT 1
85292: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85293: LD_VAR 0 4
85297: PUSH
85298: LD_VAR 0 7
85302: ARRAY
85303: PPUSH
85304: CALL_OW 250
85308: PPUSH
85309: LD_VAR 0 4
85313: PUSH
85314: LD_VAR 0 7
85318: ARRAY
85319: PPUSH
85320: CALL_OW 251
85324: PPUSH
85325: CALL_OW 546
85329: PUSH
85330: LD_INT 2
85332: ARRAY
85333: PUSH
85334: LD_VAR 0 14
85338: PUSH
85339: LD_INT 1
85341: ARRAY
85342: PPUSH
85343: CALL_OW 250
85347: PPUSH
85348: LD_VAR 0 14
85352: PUSH
85353: LD_INT 1
85355: ARRAY
85356: PPUSH
85357: CALL_OW 251
85361: PPUSH
85362: CALL_OW 546
85366: PUSH
85367: LD_INT 2
85369: ARRAY
85370: EQUAL
85371: IFFALSE 85399
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85373: LD_VAR 0 4
85377: PUSH
85378: LD_VAR 0 7
85382: ARRAY
85383: PPUSH
85384: LD_VAR 0 14
85388: PUSH
85389: LD_INT 1
85391: ARRAY
85392: PPUSH
85393: CALL 42934 0 2
85397: GO 85423
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85399: LD_VAR 0 4
85403: PUSH
85404: LD_VAR 0 7
85408: ARRAY
85409: PPUSH
85410: LD_VAR 0 14
85414: PUSH
85415: LD_INT 1
85417: ARRAY
85418: PPUSH
85419: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85423: LD_VAR 0 4
85427: PUSH
85428: LD_VAR 0 7
85432: ARRAY
85433: PPUSH
85434: CALL_OW 264
85438: PUSH
85439: LD_INT 29
85441: EQUAL
85442: IFFALSE 85808
// begin if WantsToAttack ( group [ i ] ) in bombed then
85444: LD_VAR 0 4
85448: PUSH
85449: LD_VAR 0 7
85453: ARRAY
85454: PPUSH
85455: CALL_OW 319
85459: PUSH
85460: LD_VAR 0 28
85464: IN
85465: IFFALSE 85469
// continue ;
85467: GO 82473
// k := 8 ;
85469: LD_ADDR_VAR 0 9
85473: PUSH
85474: LD_INT 8
85476: ST_TO_ADDR
// x := 0 ;
85477: LD_ADDR_VAR 0 10
85481: PUSH
85482: LD_INT 0
85484: ST_TO_ADDR
// if tmp < k then
85485: LD_VAR 0 14
85489: PUSH
85490: LD_VAR 0 9
85494: LESS
85495: IFFALSE 85507
// k := tmp ;
85497: LD_ADDR_VAR 0 9
85501: PUSH
85502: LD_VAR 0 14
85506: ST_TO_ADDR
// for j = 1 to k do
85507: LD_ADDR_VAR 0 8
85511: PUSH
85512: DOUBLE
85513: LD_INT 1
85515: DEC
85516: ST_TO_ADDR
85517: LD_VAR 0 9
85521: PUSH
85522: FOR_TO
85523: IFFALSE 85655
// begin if GetType ( tmp [ j ] ) = unit_building then
85525: LD_VAR 0 14
85529: PUSH
85530: LD_VAR 0 8
85534: ARRAY
85535: PPUSH
85536: CALL_OW 247
85540: PUSH
85541: LD_INT 3
85543: EQUAL
85544: IFFALSE 85653
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85546: LD_VAR 0 14
85550: PUSH
85551: LD_VAR 0 8
85555: ARRAY
85556: PUSH
85557: LD_VAR 0 28
85561: IN
85562: NOT
85563: PUSH
85564: LD_VAR 0 14
85568: PUSH
85569: LD_VAR 0 8
85573: ARRAY
85574: PPUSH
85575: CALL_OW 313
85579: AND
85580: IFFALSE 85653
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85582: LD_VAR 0 4
85586: PUSH
85587: LD_VAR 0 7
85591: ARRAY
85592: PPUSH
85593: LD_VAR 0 14
85597: PUSH
85598: LD_VAR 0 8
85602: ARRAY
85603: PPUSH
85604: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85608: LD_ADDR_VAR 0 28
85612: PUSH
85613: LD_VAR 0 28
85617: PPUSH
85618: LD_VAR 0 28
85622: PUSH
85623: LD_INT 1
85625: PLUS
85626: PPUSH
85627: LD_VAR 0 14
85631: PUSH
85632: LD_VAR 0 8
85636: ARRAY
85637: PPUSH
85638: CALL_OW 1
85642: ST_TO_ADDR
// attacking := true ;
85643: LD_ADDR_VAR 0 29
85647: PUSH
85648: LD_INT 1
85650: ST_TO_ADDR
// break ;
85651: GO 85655
// end ; end ;
85653: GO 85522
85655: POP
85656: POP
// if not attacking and f_attack_depot then
85657: LD_VAR 0 29
85661: NOT
85662: PUSH
85663: LD_VAR 0 25
85667: AND
85668: IFFALSE 85763
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85670: LD_ADDR_VAR 0 13
85674: PUSH
85675: LD_VAR 0 14
85679: PPUSH
85680: LD_INT 2
85682: PUSH
85683: LD_INT 30
85685: PUSH
85686: LD_INT 0
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 30
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: LIST
85707: PPUSH
85708: CALL_OW 72
85712: ST_TO_ADDR
// if z then
85713: LD_VAR 0 13
85717: IFFALSE 85763
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85719: LD_VAR 0 4
85723: PUSH
85724: LD_VAR 0 7
85728: ARRAY
85729: PPUSH
85730: LD_VAR 0 13
85734: PPUSH
85735: LD_VAR 0 4
85739: PUSH
85740: LD_VAR 0 7
85744: ARRAY
85745: PPUSH
85746: CALL_OW 74
85750: PPUSH
85751: CALL_OW 115
// attacking := true ;
85755: LD_ADDR_VAR 0 29
85759: PUSH
85760: LD_INT 1
85762: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85763: LD_VAR 0 4
85767: PUSH
85768: LD_VAR 0 7
85772: ARRAY
85773: PPUSH
85774: CALL_OW 256
85778: PUSH
85779: LD_INT 500
85781: LESS
85782: IFFALSE 85808
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85784: LD_VAR 0 4
85788: PUSH
85789: LD_VAR 0 7
85793: ARRAY
85794: PPUSH
85795: LD_VAR 0 14
85799: PUSH
85800: LD_INT 1
85802: ARRAY
85803: PPUSH
85804: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85808: LD_VAR 0 4
85812: PUSH
85813: LD_VAR 0 7
85817: ARRAY
85818: PPUSH
85819: CALL_OW 264
85823: PUSH
85824: LD_INT 49
85826: EQUAL
85827: IFFALSE 85948
// begin if not HasTask ( group [ i ] ) then
85829: LD_VAR 0 4
85833: PUSH
85834: LD_VAR 0 7
85838: ARRAY
85839: PPUSH
85840: CALL_OW 314
85844: NOT
85845: IFFALSE 85948
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85847: LD_ADDR_VAR 0 9
85851: PUSH
85852: LD_INT 81
85854: PUSH
85855: LD_VAR 0 4
85859: PUSH
85860: LD_VAR 0 7
85864: ARRAY
85865: PPUSH
85866: CALL_OW 255
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PPUSH
85875: CALL_OW 69
85879: PPUSH
85880: LD_VAR 0 4
85884: PUSH
85885: LD_VAR 0 7
85889: ARRAY
85890: PPUSH
85891: CALL_OW 74
85895: ST_TO_ADDR
// if k then
85896: LD_VAR 0 9
85900: IFFALSE 85948
// if GetDistUnits ( group [ i ] , k ) > 10 then
85902: LD_VAR 0 4
85906: PUSH
85907: LD_VAR 0 7
85911: ARRAY
85912: PPUSH
85913: LD_VAR 0 9
85917: PPUSH
85918: CALL_OW 296
85922: PUSH
85923: LD_INT 10
85925: GREATER
85926: IFFALSE 85948
// ComMoveUnit ( group [ i ] , k ) ;
85928: LD_VAR 0 4
85932: PUSH
85933: LD_VAR 0 7
85937: ARRAY
85938: PPUSH
85939: LD_VAR 0 9
85943: PPUSH
85944: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85948: LD_VAR 0 4
85952: PUSH
85953: LD_VAR 0 7
85957: ARRAY
85958: PPUSH
85959: CALL_OW 256
85963: PUSH
85964: LD_INT 250
85966: LESS
85967: PUSH
85968: LD_VAR 0 4
85972: PUSH
85973: LD_VAR 0 7
85977: ARRAY
85978: PUSH
85979: LD_INT 21
85981: PUSH
85982: LD_INT 2
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 23
85991: PUSH
85992: LD_INT 2
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PPUSH
86003: CALL_OW 69
86007: IN
86008: AND
86009: IFFALSE 86134
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86011: LD_ADDR_VAR 0 9
86015: PUSH
86016: LD_OWVAR 3
86020: PUSH
86021: LD_VAR 0 4
86025: PUSH
86026: LD_VAR 0 7
86030: ARRAY
86031: DIFF
86032: PPUSH
86033: LD_VAR 0 4
86037: PUSH
86038: LD_VAR 0 7
86042: ARRAY
86043: PPUSH
86044: CALL_OW 74
86048: ST_TO_ADDR
// if not k then
86049: LD_VAR 0 9
86053: NOT
86054: IFFALSE 86058
// continue ;
86056: GO 82473
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86058: LD_VAR 0 9
86062: PUSH
86063: LD_INT 81
86065: PUSH
86066: LD_VAR 0 4
86070: PUSH
86071: LD_VAR 0 7
86075: ARRAY
86076: PPUSH
86077: CALL_OW 255
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PPUSH
86086: CALL_OW 69
86090: IN
86091: PUSH
86092: LD_VAR 0 9
86096: PPUSH
86097: LD_VAR 0 4
86101: PUSH
86102: LD_VAR 0 7
86106: ARRAY
86107: PPUSH
86108: CALL_OW 296
86112: PUSH
86113: LD_INT 5
86115: LESS
86116: AND
86117: IFFALSE 86134
// ComAutodestruct ( group [ i ] ) ;
86119: LD_VAR 0 4
86123: PUSH
86124: LD_VAR 0 7
86128: ARRAY
86129: PPUSH
86130: CALL 42832 0 1
// end ; if f_attack_depot then
86134: LD_VAR 0 25
86138: IFFALSE 86250
// begin k := 6 ;
86140: LD_ADDR_VAR 0 9
86144: PUSH
86145: LD_INT 6
86147: ST_TO_ADDR
// if tmp < k then
86148: LD_VAR 0 14
86152: PUSH
86153: LD_VAR 0 9
86157: LESS
86158: IFFALSE 86170
// k := tmp ;
86160: LD_ADDR_VAR 0 9
86164: PUSH
86165: LD_VAR 0 14
86169: ST_TO_ADDR
// for j = 1 to k do
86170: LD_ADDR_VAR 0 8
86174: PUSH
86175: DOUBLE
86176: LD_INT 1
86178: DEC
86179: ST_TO_ADDR
86180: LD_VAR 0 9
86184: PUSH
86185: FOR_TO
86186: IFFALSE 86248
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86188: LD_VAR 0 8
86192: PPUSH
86193: CALL_OW 266
86197: PUSH
86198: LD_INT 0
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: IN
86208: IFFALSE 86246
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86210: LD_VAR 0 4
86214: PUSH
86215: LD_VAR 0 7
86219: ARRAY
86220: PPUSH
86221: LD_VAR 0 14
86225: PUSH
86226: LD_VAR 0 8
86230: ARRAY
86231: PPUSH
86232: CALL_OW 115
// attacking := true ;
86236: LD_ADDR_VAR 0 29
86240: PUSH
86241: LD_INT 1
86243: ST_TO_ADDR
// break ;
86244: GO 86248
// end ;
86246: GO 86185
86248: POP
86249: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86250: LD_VAR 0 4
86254: PUSH
86255: LD_VAR 0 7
86259: ARRAY
86260: PPUSH
86261: CALL_OW 302
86265: PUSH
86266: LD_VAR 0 29
86270: NOT
86271: AND
86272: IFFALSE 86594
// begin if GetTag ( group [ i ] ) = 71 then
86274: LD_VAR 0 4
86278: PUSH
86279: LD_VAR 0 7
86283: ARRAY
86284: PPUSH
86285: CALL_OW 110
86289: PUSH
86290: LD_INT 71
86292: EQUAL
86293: IFFALSE 86334
// begin if HasTask ( group [ i ] ) then
86295: LD_VAR 0 4
86299: PUSH
86300: LD_VAR 0 7
86304: ARRAY
86305: PPUSH
86306: CALL_OW 314
86310: IFFALSE 86316
// continue else
86312: GO 82473
86314: GO 86334
// SetTag ( group [ i ] , 0 ) ;
86316: LD_VAR 0 4
86320: PUSH
86321: LD_VAR 0 7
86325: ARRAY
86326: PPUSH
86327: LD_INT 0
86329: PPUSH
86330: CALL_OW 109
// end ; k := 8 ;
86334: LD_ADDR_VAR 0 9
86338: PUSH
86339: LD_INT 8
86341: ST_TO_ADDR
// x := 0 ;
86342: LD_ADDR_VAR 0 10
86346: PUSH
86347: LD_INT 0
86349: ST_TO_ADDR
// if tmp < k then
86350: LD_VAR 0 14
86354: PUSH
86355: LD_VAR 0 9
86359: LESS
86360: IFFALSE 86372
// k := tmp ;
86362: LD_ADDR_VAR 0 9
86366: PUSH
86367: LD_VAR 0 14
86371: ST_TO_ADDR
// for j = 1 to k do
86372: LD_ADDR_VAR 0 8
86376: PUSH
86377: DOUBLE
86378: LD_INT 1
86380: DEC
86381: ST_TO_ADDR
86382: LD_VAR 0 9
86386: PUSH
86387: FOR_TO
86388: IFFALSE 86486
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86390: LD_VAR 0 14
86394: PUSH
86395: LD_VAR 0 8
86399: ARRAY
86400: PPUSH
86401: CALL_OW 247
86405: PUSH
86406: LD_INT 1
86408: EQUAL
86409: PUSH
86410: LD_VAR 0 14
86414: PUSH
86415: LD_VAR 0 8
86419: ARRAY
86420: PPUSH
86421: CALL_OW 256
86425: PUSH
86426: LD_INT 250
86428: LESS
86429: PUSH
86430: LD_VAR 0 20
86434: AND
86435: PUSH
86436: LD_VAR 0 20
86440: NOT
86441: PUSH
86442: LD_VAR 0 14
86446: PUSH
86447: LD_VAR 0 8
86451: ARRAY
86452: PPUSH
86453: CALL_OW 256
86457: PUSH
86458: LD_INT 250
86460: GREATEREQUAL
86461: AND
86462: OR
86463: AND
86464: IFFALSE 86484
// begin x := tmp [ j ] ;
86466: LD_ADDR_VAR 0 10
86470: PUSH
86471: LD_VAR 0 14
86475: PUSH
86476: LD_VAR 0 8
86480: ARRAY
86481: ST_TO_ADDR
// break ;
86482: GO 86486
// end ;
86484: GO 86387
86486: POP
86487: POP
// if x then
86488: LD_VAR 0 10
86492: IFFALSE 86516
// ComAttackUnit ( group [ i ] , x ) else
86494: LD_VAR 0 4
86498: PUSH
86499: LD_VAR 0 7
86503: ARRAY
86504: PPUSH
86505: LD_VAR 0 10
86509: PPUSH
86510: CALL_OW 115
86514: GO 86540
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86516: LD_VAR 0 4
86520: PUSH
86521: LD_VAR 0 7
86525: ARRAY
86526: PPUSH
86527: LD_VAR 0 14
86531: PUSH
86532: LD_INT 1
86534: ARRAY
86535: PPUSH
86536: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86540: LD_VAR 0 4
86544: PUSH
86545: LD_VAR 0 7
86549: ARRAY
86550: PPUSH
86551: CALL_OW 314
86555: NOT
86556: IFFALSE 86594
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86558: LD_VAR 0 4
86562: PUSH
86563: LD_VAR 0 7
86567: ARRAY
86568: PPUSH
86569: LD_VAR 0 14
86573: PPUSH
86574: LD_VAR 0 4
86578: PUSH
86579: LD_VAR 0 7
86583: ARRAY
86584: PPUSH
86585: CALL_OW 74
86589: PPUSH
86590: CALL_OW 115
// end ; end ; end ;
86594: GO 82473
86596: POP
86597: POP
// wait ( 0 0$2 ) ;
86598: LD_INT 70
86600: PPUSH
86601: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86605: LD_VAR 0 4
86609: NOT
86610: PUSH
86611: LD_VAR 0 4
86615: PUSH
86616: EMPTY
86617: EQUAL
86618: OR
86619: PUSH
86620: LD_INT 81
86622: PUSH
86623: LD_VAR 0 35
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PPUSH
86632: CALL_OW 69
86636: NOT
86637: OR
86638: IFFALSE 82458
// end ;
86640: LD_VAR 0 2
86644: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86645: LD_INT 0
86647: PPUSH
86648: PPUSH
86649: PPUSH
86650: PPUSH
86651: PPUSH
86652: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86653: LD_VAR 0 1
86657: NOT
86658: PUSH
86659: LD_EXP 43
86663: PUSH
86664: LD_VAR 0 1
86668: ARRAY
86669: NOT
86670: OR
86671: PUSH
86672: LD_VAR 0 2
86676: NOT
86677: OR
86678: IFFALSE 86682
// exit ;
86680: GO 87236
// side := mc_sides [ base ] ;
86682: LD_ADDR_VAR 0 6
86686: PUSH
86687: LD_EXP 69
86691: PUSH
86692: LD_VAR 0 1
86696: ARRAY
86697: ST_TO_ADDR
// if not side then
86698: LD_VAR 0 6
86702: NOT
86703: IFFALSE 86707
// exit ;
86705: GO 87236
// for i in solds do
86707: LD_ADDR_VAR 0 7
86711: PUSH
86712: LD_VAR 0 2
86716: PUSH
86717: FOR_IN
86718: IFFALSE 86779
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86720: LD_VAR 0 7
86724: PPUSH
86725: CALL_OW 310
86729: PPUSH
86730: CALL_OW 266
86734: PUSH
86735: LD_INT 32
86737: PUSH
86738: LD_INT 31
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: IN
86745: IFFALSE 86765
// solds := solds diff i else
86747: LD_ADDR_VAR 0 2
86751: PUSH
86752: LD_VAR 0 2
86756: PUSH
86757: LD_VAR 0 7
86761: DIFF
86762: ST_TO_ADDR
86763: GO 86777
// SetTag ( i , 18 ) ;
86765: LD_VAR 0 7
86769: PPUSH
86770: LD_INT 18
86772: PPUSH
86773: CALL_OW 109
86777: GO 86717
86779: POP
86780: POP
// if not solds then
86781: LD_VAR 0 2
86785: NOT
86786: IFFALSE 86790
// exit ;
86788: GO 87236
// repeat wait ( 0 0$2 ) ;
86790: LD_INT 70
86792: PPUSH
86793: CALL_OW 67
// enemy := mc_scan [ base ] ;
86797: LD_ADDR_VAR 0 4
86801: PUSH
86802: LD_EXP 66
86806: PUSH
86807: LD_VAR 0 1
86811: ARRAY
86812: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86813: LD_EXP 43
86817: PUSH
86818: LD_VAR 0 1
86822: ARRAY
86823: NOT
86824: PUSH
86825: LD_EXP 43
86829: PUSH
86830: LD_VAR 0 1
86834: ARRAY
86835: PUSH
86836: EMPTY
86837: EQUAL
86838: OR
86839: IFFALSE 86876
// begin for i in solds do
86841: LD_ADDR_VAR 0 7
86845: PUSH
86846: LD_VAR 0 2
86850: PUSH
86851: FOR_IN
86852: IFFALSE 86865
// ComStop ( i ) ;
86854: LD_VAR 0 7
86858: PPUSH
86859: CALL_OW 141
86863: GO 86851
86865: POP
86866: POP
// solds := [ ] ;
86867: LD_ADDR_VAR 0 2
86871: PUSH
86872: EMPTY
86873: ST_TO_ADDR
// exit ;
86874: GO 87236
// end ; for i in solds do
86876: LD_ADDR_VAR 0 7
86880: PUSH
86881: LD_VAR 0 2
86885: PUSH
86886: FOR_IN
86887: IFFALSE 87208
// begin if IsInUnit ( i ) then
86889: LD_VAR 0 7
86893: PPUSH
86894: CALL_OW 310
86898: IFFALSE 86909
// ComExitBuilding ( i ) ;
86900: LD_VAR 0 7
86904: PPUSH
86905: CALL_OW 122
// if GetLives ( i ) > 500 then
86909: LD_VAR 0 7
86913: PPUSH
86914: CALL_OW 256
86918: PUSH
86919: LD_INT 500
86921: GREATER
86922: IFFALSE 86975
// begin e := NearestUnitToUnit ( enemy , i ) ;
86924: LD_ADDR_VAR 0 5
86928: PUSH
86929: LD_VAR 0 4
86933: PPUSH
86934: LD_VAR 0 7
86938: PPUSH
86939: CALL_OW 74
86943: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86944: LD_VAR 0 7
86948: PPUSH
86949: LD_VAR 0 5
86953: PPUSH
86954: CALL_OW 250
86958: PPUSH
86959: LD_VAR 0 5
86963: PPUSH
86964: CALL_OW 251
86968: PPUSH
86969: CALL_OW 114
// end else
86973: GO 87206
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86975: LD_VAR 0 7
86979: PPUSH
86980: LD_EXP 43
86984: PUSH
86985: LD_VAR 0 1
86989: ARRAY
86990: PPUSH
86991: LD_INT 2
86993: PUSH
86994: LD_INT 30
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 30
87006: PUSH
87007: LD_INT 1
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 30
87016: PUSH
87017: LD_INT 6
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: PPUSH
87030: CALL_OW 72
87034: PPUSH
87035: LD_VAR 0 7
87039: PPUSH
87040: CALL_OW 74
87044: PPUSH
87045: CALL_OW 296
87049: PUSH
87050: LD_INT 10
87052: GREATER
87053: IFFALSE 87206
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87055: LD_ADDR_VAR 0 8
87059: PUSH
87060: LD_EXP 43
87064: PUSH
87065: LD_VAR 0 1
87069: ARRAY
87070: PPUSH
87071: LD_INT 2
87073: PUSH
87074: LD_INT 30
87076: PUSH
87077: LD_INT 0
87079: PUSH
87080: EMPTY
87081: LIST
87082: LIST
87083: PUSH
87084: LD_INT 30
87086: PUSH
87087: LD_INT 1
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 30
87096: PUSH
87097: LD_INT 6
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: PPUSH
87110: CALL_OW 72
87114: PPUSH
87115: LD_VAR 0 7
87119: PPUSH
87120: CALL_OW 74
87124: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87125: LD_VAR 0 7
87129: PPUSH
87130: LD_VAR 0 8
87134: PPUSH
87135: CALL_OW 250
87139: PPUSH
87140: LD_INT 3
87142: PPUSH
87143: LD_INT 5
87145: PPUSH
87146: CALL_OW 272
87150: PPUSH
87151: LD_VAR 0 8
87155: PPUSH
87156: CALL_OW 251
87160: PPUSH
87161: LD_INT 3
87163: PPUSH
87164: LD_INT 5
87166: PPUSH
87167: CALL_OW 273
87171: PPUSH
87172: CALL_OW 111
// SetTag ( i , 0 ) ;
87176: LD_VAR 0 7
87180: PPUSH
87181: LD_INT 0
87183: PPUSH
87184: CALL_OW 109
// solds := solds diff i ;
87188: LD_ADDR_VAR 0 2
87192: PUSH
87193: LD_VAR 0 2
87197: PUSH
87198: LD_VAR 0 7
87202: DIFF
87203: ST_TO_ADDR
// continue ;
87204: GO 86886
// end ; end ;
87206: GO 86886
87208: POP
87209: POP
// until not solds or not enemy ;
87210: LD_VAR 0 2
87214: NOT
87215: PUSH
87216: LD_VAR 0 4
87220: NOT
87221: OR
87222: IFFALSE 86790
// MC_Reset ( base , 18 ) ;
87224: LD_VAR 0 1
87228: PPUSH
87229: LD_INT 18
87231: PPUSH
87232: CALL 55433 0 2
// end ;
87236: LD_VAR 0 3
87240: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87241: LD_INT 0
87243: PPUSH
87244: PPUSH
87245: PPUSH
87246: PPUSH
87247: PPUSH
87248: PPUSH
87249: PPUSH
87250: PPUSH
87251: PPUSH
87252: PPUSH
87253: PPUSH
87254: PPUSH
87255: PPUSH
87256: PPUSH
87257: PPUSH
87258: PPUSH
87259: PPUSH
87260: PPUSH
87261: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87262: LD_ADDR_VAR 0 12
87266: PUSH
87267: LD_EXP 43
87271: PUSH
87272: LD_VAR 0 1
87276: ARRAY
87277: PPUSH
87278: LD_INT 25
87280: PUSH
87281: LD_INT 3
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PPUSH
87288: CALL_OW 72
87292: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87293: LD_EXP 83
87297: PUSH
87298: LD_VAR 0 1
87302: ARRAY
87303: IFFALSE 87327
// mechs := mechs diff mc_remote_driver [ base ] ;
87305: LD_ADDR_VAR 0 12
87309: PUSH
87310: LD_VAR 0 12
87314: PUSH
87315: LD_EXP 83
87319: PUSH
87320: LD_VAR 0 1
87324: ARRAY
87325: DIFF
87326: ST_TO_ADDR
// for i in mechs do
87327: LD_ADDR_VAR 0 4
87331: PUSH
87332: LD_VAR 0 12
87336: PUSH
87337: FOR_IN
87338: IFFALSE 87373
// if GetTag ( i ) > 0 then
87340: LD_VAR 0 4
87344: PPUSH
87345: CALL_OW 110
87349: PUSH
87350: LD_INT 0
87352: GREATER
87353: IFFALSE 87371
// mechs := mechs diff i ;
87355: LD_ADDR_VAR 0 12
87359: PUSH
87360: LD_VAR 0 12
87364: PUSH
87365: LD_VAR 0 4
87369: DIFF
87370: ST_TO_ADDR
87371: GO 87337
87373: POP
87374: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87375: LD_ADDR_VAR 0 8
87379: PUSH
87380: LD_EXP 43
87384: PUSH
87385: LD_VAR 0 1
87389: ARRAY
87390: PPUSH
87391: LD_INT 2
87393: PUSH
87394: LD_INT 25
87396: PUSH
87397: LD_INT 1
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 25
87406: PUSH
87407: LD_INT 5
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 25
87416: PUSH
87417: LD_INT 8
87419: PUSH
87420: EMPTY
87421: LIST
87422: LIST
87423: PUSH
87424: LD_INT 25
87426: PUSH
87427: LD_INT 9
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: PPUSH
87441: CALL_OW 72
87445: ST_TO_ADDR
// if not defenders and not solds then
87446: LD_VAR 0 2
87450: NOT
87451: PUSH
87452: LD_VAR 0 8
87456: NOT
87457: AND
87458: IFFALSE 87462
// exit ;
87460: GO 89232
// depot_under_attack := false ;
87462: LD_ADDR_VAR 0 16
87466: PUSH
87467: LD_INT 0
87469: ST_TO_ADDR
// sold_defenders := [ ] ;
87470: LD_ADDR_VAR 0 17
87474: PUSH
87475: EMPTY
87476: ST_TO_ADDR
// if mechs then
87477: LD_VAR 0 12
87481: IFFALSE 87634
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87483: LD_ADDR_VAR 0 4
87487: PUSH
87488: LD_VAR 0 2
87492: PPUSH
87493: LD_INT 21
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PPUSH
87503: CALL_OW 72
87507: PUSH
87508: FOR_IN
87509: IFFALSE 87632
// begin if GetTag ( i ) <> 20 then
87511: LD_VAR 0 4
87515: PPUSH
87516: CALL_OW 110
87520: PUSH
87521: LD_INT 20
87523: NONEQUAL
87524: IFFALSE 87538
// SetTag ( i , 20 ) ;
87526: LD_VAR 0 4
87530: PPUSH
87531: LD_INT 20
87533: PPUSH
87534: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87538: LD_VAR 0 4
87542: PPUSH
87543: CALL_OW 263
87547: PUSH
87548: LD_INT 1
87550: EQUAL
87551: PUSH
87552: LD_VAR 0 4
87556: PPUSH
87557: CALL_OW 311
87561: NOT
87562: AND
87563: IFFALSE 87630
// begin un := mechs [ 1 ] ;
87565: LD_ADDR_VAR 0 10
87569: PUSH
87570: LD_VAR 0 12
87574: PUSH
87575: LD_INT 1
87577: ARRAY
87578: ST_TO_ADDR
// ComExit ( un ) ;
87579: LD_VAR 0 10
87583: PPUSH
87584: CALL 47717 0 1
// AddComEnterUnit ( un , i ) ;
87588: LD_VAR 0 10
87592: PPUSH
87593: LD_VAR 0 4
87597: PPUSH
87598: CALL_OW 180
// SetTag ( un , 19 ) ;
87602: LD_VAR 0 10
87606: PPUSH
87607: LD_INT 19
87609: PPUSH
87610: CALL_OW 109
// mechs := mechs diff un ;
87614: LD_ADDR_VAR 0 12
87618: PUSH
87619: LD_VAR 0 12
87623: PUSH
87624: LD_VAR 0 10
87628: DIFF
87629: ST_TO_ADDR
// end ; end ;
87630: GO 87508
87632: POP
87633: POP
// if solds then
87634: LD_VAR 0 8
87638: IFFALSE 87697
// for i in solds do
87640: LD_ADDR_VAR 0 4
87644: PUSH
87645: LD_VAR 0 8
87649: PUSH
87650: FOR_IN
87651: IFFALSE 87695
// if not GetTag ( i ) then
87653: LD_VAR 0 4
87657: PPUSH
87658: CALL_OW 110
87662: NOT
87663: IFFALSE 87693
// begin defenders := defenders union i ;
87665: LD_ADDR_VAR 0 2
87669: PUSH
87670: LD_VAR 0 2
87674: PUSH
87675: LD_VAR 0 4
87679: UNION
87680: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87681: LD_VAR 0 4
87685: PPUSH
87686: LD_INT 18
87688: PPUSH
87689: CALL_OW 109
// end ;
87693: GO 87650
87695: POP
87696: POP
// repeat wait ( 0 0$2 ) ;
87697: LD_INT 70
87699: PPUSH
87700: CALL_OW 67
// enemy := mc_scan [ base ] ;
87704: LD_ADDR_VAR 0 21
87708: PUSH
87709: LD_EXP 66
87713: PUSH
87714: LD_VAR 0 1
87718: ARRAY
87719: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87720: LD_EXP 43
87724: PUSH
87725: LD_VAR 0 1
87729: ARRAY
87730: NOT
87731: PUSH
87732: LD_EXP 43
87736: PUSH
87737: LD_VAR 0 1
87741: ARRAY
87742: PUSH
87743: EMPTY
87744: EQUAL
87745: OR
87746: IFFALSE 87783
// begin for i in defenders do
87748: LD_ADDR_VAR 0 4
87752: PUSH
87753: LD_VAR 0 2
87757: PUSH
87758: FOR_IN
87759: IFFALSE 87772
// ComStop ( i ) ;
87761: LD_VAR 0 4
87765: PPUSH
87766: CALL_OW 141
87770: GO 87758
87772: POP
87773: POP
// defenders := [ ] ;
87774: LD_ADDR_VAR 0 2
87778: PUSH
87779: EMPTY
87780: ST_TO_ADDR
// exit ;
87781: GO 89232
// end ; for i in defenders do
87783: LD_ADDR_VAR 0 4
87787: PUSH
87788: LD_VAR 0 2
87792: PUSH
87793: FOR_IN
87794: IFFALSE 88692
// begin e := NearestUnitToUnit ( enemy , i ) ;
87796: LD_ADDR_VAR 0 13
87800: PUSH
87801: LD_VAR 0 21
87805: PPUSH
87806: LD_VAR 0 4
87810: PPUSH
87811: CALL_OW 74
87815: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87816: LD_ADDR_VAR 0 7
87820: PUSH
87821: LD_EXP 43
87825: PUSH
87826: LD_VAR 0 1
87830: ARRAY
87831: PPUSH
87832: LD_INT 2
87834: PUSH
87835: LD_INT 30
87837: PUSH
87838: LD_INT 0
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 30
87847: PUSH
87848: LD_INT 1
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: LIST
87859: PPUSH
87860: CALL_OW 72
87864: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87865: LD_ADDR_VAR 0 16
87869: PUSH
87870: LD_VAR 0 7
87874: NOT
87875: PUSH
87876: LD_VAR 0 7
87880: PPUSH
87881: LD_INT 3
87883: PUSH
87884: LD_INT 24
87886: PUSH
87887: LD_INT 600
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PPUSH
87898: CALL_OW 72
87902: OR
87903: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87904: LD_VAR 0 4
87908: PPUSH
87909: CALL_OW 247
87913: PUSH
87914: LD_INT 2
87916: DOUBLE
87917: EQUAL
87918: IFTRUE 87922
87920: GO 88318
87922: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87923: LD_VAR 0 4
87927: PPUSH
87928: CALL_OW 256
87932: PUSH
87933: LD_INT 1000
87935: EQUAL
87936: PUSH
87937: LD_VAR 0 4
87941: PPUSH
87942: LD_VAR 0 13
87946: PPUSH
87947: CALL_OW 296
87951: PUSH
87952: LD_INT 40
87954: LESS
87955: PUSH
87956: LD_VAR 0 13
87960: PPUSH
87961: LD_EXP 68
87965: PUSH
87966: LD_VAR 0 1
87970: ARRAY
87971: PPUSH
87972: CALL_OW 308
87976: OR
87977: AND
87978: IFFALSE 88100
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87980: LD_VAR 0 4
87984: PPUSH
87985: CALL_OW 262
87989: PUSH
87990: LD_INT 1
87992: EQUAL
87993: PUSH
87994: LD_VAR 0 4
87998: PPUSH
87999: CALL_OW 261
88003: PUSH
88004: LD_INT 30
88006: LESS
88007: AND
88008: PUSH
88009: LD_VAR 0 7
88013: AND
88014: IFFALSE 88084
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88016: LD_VAR 0 4
88020: PPUSH
88021: LD_VAR 0 7
88025: PPUSH
88026: LD_VAR 0 4
88030: PPUSH
88031: CALL_OW 74
88035: PPUSH
88036: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88040: LD_VAR 0 4
88044: PPUSH
88045: LD_VAR 0 7
88049: PPUSH
88050: LD_VAR 0 4
88054: PPUSH
88055: CALL_OW 74
88059: PPUSH
88060: CALL_OW 296
88064: PUSH
88065: LD_INT 6
88067: LESS
88068: IFFALSE 88082
// SetFuel ( i , 100 ) ;
88070: LD_VAR 0 4
88074: PPUSH
88075: LD_INT 100
88077: PPUSH
88078: CALL_OW 240
// end else
88082: GO 88098
// ComAttackUnit ( i , e ) ;
88084: LD_VAR 0 4
88088: PPUSH
88089: LD_VAR 0 13
88093: PPUSH
88094: CALL_OW 115
// end else
88098: GO 88201
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88100: LD_VAR 0 13
88104: PPUSH
88105: LD_EXP 68
88109: PUSH
88110: LD_VAR 0 1
88114: ARRAY
88115: PPUSH
88116: CALL_OW 308
88120: NOT
88121: PUSH
88122: LD_VAR 0 4
88126: PPUSH
88127: LD_VAR 0 13
88131: PPUSH
88132: CALL_OW 296
88136: PUSH
88137: LD_INT 40
88139: GREATEREQUAL
88140: AND
88141: PUSH
88142: LD_VAR 0 4
88146: PPUSH
88147: CALL_OW 256
88151: PUSH
88152: LD_INT 650
88154: LESSEQUAL
88155: OR
88156: PUSH
88157: LD_VAR 0 4
88161: PPUSH
88162: LD_EXP 67
88166: PUSH
88167: LD_VAR 0 1
88171: ARRAY
88172: PPUSH
88173: CALL_OW 308
88177: NOT
88178: AND
88179: IFFALSE 88201
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88181: LD_VAR 0 4
88185: PPUSH
88186: LD_EXP 67
88190: PUSH
88191: LD_VAR 0 1
88195: ARRAY
88196: PPUSH
88197: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88201: LD_VAR 0 4
88205: PPUSH
88206: CALL_OW 256
88210: PUSH
88211: LD_INT 1000
88213: LESS
88214: PUSH
88215: LD_VAR 0 4
88219: PPUSH
88220: CALL_OW 263
88224: PUSH
88225: LD_INT 1
88227: EQUAL
88228: AND
88229: PUSH
88230: LD_VAR 0 4
88234: PPUSH
88235: CALL_OW 311
88239: AND
88240: PUSH
88241: LD_VAR 0 4
88245: PPUSH
88246: LD_EXP 67
88250: PUSH
88251: LD_VAR 0 1
88255: ARRAY
88256: PPUSH
88257: CALL_OW 308
88261: AND
88262: IFFALSE 88316
// begin mech := IsDrivenBy ( i ) ;
88264: LD_ADDR_VAR 0 9
88268: PUSH
88269: LD_VAR 0 4
88273: PPUSH
88274: CALL_OW 311
88278: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88279: LD_VAR 0 9
88283: PPUSH
88284: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88288: LD_VAR 0 9
88292: PPUSH
88293: LD_VAR 0 4
88297: PPUSH
88298: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88302: LD_VAR 0 9
88306: PPUSH
88307: LD_VAR 0 4
88311: PPUSH
88312: CALL_OW 180
// end ; end ; unit_human :
88316: GO 88663
88318: LD_INT 1
88320: DOUBLE
88321: EQUAL
88322: IFTRUE 88326
88324: GO 88662
88326: POP
// begin b := IsInUnit ( i ) ;
88327: LD_ADDR_VAR 0 18
88331: PUSH
88332: LD_VAR 0 4
88336: PPUSH
88337: CALL_OW 310
88341: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88342: LD_ADDR_VAR 0 19
88346: PUSH
88347: LD_VAR 0 18
88351: NOT
88352: PUSH
88353: LD_VAR 0 18
88357: PPUSH
88358: CALL_OW 266
88362: PUSH
88363: LD_INT 32
88365: PUSH
88366: LD_INT 31
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: IN
88373: OR
88374: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88375: LD_VAR 0 18
88379: PPUSH
88380: CALL_OW 266
88384: PUSH
88385: LD_INT 5
88387: EQUAL
88388: PUSH
88389: LD_VAR 0 4
88393: PPUSH
88394: CALL_OW 257
88398: PUSH
88399: LD_INT 1
88401: PUSH
88402: LD_INT 2
88404: PUSH
88405: LD_INT 3
88407: PUSH
88408: LD_INT 4
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: IN
88417: AND
88418: IFFALSE 88455
// begin class := AllowSpecClass ( i ) ;
88420: LD_ADDR_VAR 0 20
88424: PUSH
88425: LD_VAR 0 4
88429: PPUSH
88430: CALL 11637 0 1
88434: ST_TO_ADDR
// if class then
88435: LD_VAR 0 20
88439: IFFALSE 88455
// ComChangeProfession ( i , class ) ;
88441: LD_VAR 0 4
88445: PPUSH
88446: LD_VAR 0 20
88450: PPUSH
88451: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88455: LD_VAR 0 16
88459: PUSH
88460: LD_VAR 0 2
88464: PPUSH
88465: LD_INT 21
88467: PUSH
88468: LD_INT 2
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PPUSH
88475: CALL_OW 72
88479: PUSH
88480: LD_INT 1
88482: LESSEQUAL
88483: OR
88484: PUSH
88485: LD_VAR 0 19
88489: AND
88490: PUSH
88491: LD_VAR 0 4
88495: PUSH
88496: LD_VAR 0 17
88500: IN
88501: NOT
88502: AND
88503: IFFALSE 88596
// begin if b then
88505: LD_VAR 0 18
88509: IFFALSE 88558
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88511: LD_VAR 0 18
88515: PPUSH
88516: LD_VAR 0 21
88520: PPUSH
88521: LD_VAR 0 18
88525: PPUSH
88526: CALL_OW 74
88530: PPUSH
88531: CALL_OW 296
88535: PUSH
88536: LD_INT 10
88538: LESS
88539: PUSH
88540: LD_VAR 0 18
88544: PPUSH
88545: CALL_OW 461
88549: PUSH
88550: LD_INT 7
88552: NONEQUAL
88553: AND
88554: IFFALSE 88558
// continue ;
88556: GO 87793
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88558: LD_ADDR_VAR 0 17
88562: PUSH
88563: LD_VAR 0 17
88567: PPUSH
88568: LD_VAR 0 17
88572: PUSH
88573: LD_INT 1
88575: PLUS
88576: PPUSH
88577: LD_VAR 0 4
88581: PPUSH
88582: CALL_OW 1
88586: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88587: LD_VAR 0 4
88591: PPUSH
88592: CALL_OW 122
// end ; if sold_defenders then
88596: LD_VAR 0 17
88600: IFFALSE 88660
// if i in sold_defenders then
88602: LD_VAR 0 4
88606: PUSH
88607: LD_VAR 0 17
88611: IN
88612: IFFALSE 88660
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88614: LD_VAR 0 4
88618: PPUSH
88619: CALL_OW 314
88623: NOT
88624: PUSH
88625: LD_VAR 0 4
88629: PPUSH
88630: LD_VAR 0 13
88634: PPUSH
88635: CALL_OW 296
88639: PUSH
88640: LD_INT 30
88642: LESS
88643: AND
88644: IFFALSE 88660
// ComAttackUnit ( i , e ) ;
88646: LD_VAR 0 4
88650: PPUSH
88651: LD_VAR 0 13
88655: PPUSH
88656: CALL_OW 115
// end ; end ; end ;
88660: GO 88663
88662: POP
// if IsDead ( i ) then
88663: LD_VAR 0 4
88667: PPUSH
88668: CALL_OW 301
88672: IFFALSE 88690
// defenders := defenders diff i ;
88674: LD_ADDR_VAR 0 2
88678: PUSH
88679: LD_VAR 0 2
88683: PUSH
88684: LD_VAR 0 4
88688: DIFF
88689: ST_TO_ADDR
// end ;
88690: GO 87793
88692: POP
88693: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88694: LD_VAR 0 21
88698: NOT
88699: PUSH
88700: LD_VAR 0 2
88704: NOT
88705: OR
88706: PUSH
88707: LD_EXP 43
88711: PUSH
88712: LD_VAR 0 1
88716: ARRAY
88717: NOT
88718: OR
88719: IFFALSE 87697
// MC_Reset ( base , 18 ) ;
88721: LD_VAR 0 1
88725: PPUSH
88726: LD_INT 18
88728: PPUSH
88729: CALL 55433 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88733: LD_ADDR_VAR 0 2
88737: PUSH
88738: LD_VAR 0 2
88742: PUSH
88743: LD_VAR 0 2
88747: PPUSH
88748: LD_INT 2
88750: PUSH
88751: LD_INT 25
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 25
88763: PUSH
88764: LD_INT 5
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 25
88773: PUSH
88774: LD_INT 8
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 25
88783: PUSH
88784: LD_INT 9
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: PPUSH
88798: CALL_OW 72
88802: DIFF
88803: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88804: LD_VAR 0 21
88808: NOT
88809: PUSH
88810: LD_VAR 0 2
88814: PPUSH
88815: LD_INT 21
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PPUSH
88825: CALL_OW 72
88829: AND
88830: IFFALSE 89168
// begin tmp := FilterByTag ( defenders , 19 ) ;
88832: LD_ADDR_VAR 0 11
88836: PUSH
88837: LD_VAR 0 2
88841: PPUSH
88842: LD_INT 19
88844: PPUSH
88845: CALL 44900 0 2
88849: ST_TO_ADDR
// if tmp then
88850: LD_VAR 0 11
88854: IFFALSE 88924
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88856: LD_ADDR_VAR 0 11
88860: PUSH
88861: LD_VAR 0 11
88865: PPUSH
88866: LD_INT 25
88868: PUSH
88869: LD_INT 3
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PPUSH
88876: CALL_OW 72
88880: ST_TO_ADDR
// if tmp then
88881: LD_VAR 0 11
88885: IFFALSE 88924
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88887: LD_ADDR_EXP 55
88891: PUSH
88892: LD_EXP 55
88896: PPUSH
88897: LD_VAR 0 1
88901: PPUSH
88902: LD_EXP 55
88906: PUSH
88907: LD_VAR 0 1
88911: ARRAY
88912: PUSH
88913: LD_VAR 0 11
88917: UNION
88918: PPUSH
88919: CALL_OW 1
88923: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88924: LD_VAR 0 1
88928: PPUSH
88929: LD_INT 19
88931: PPUSH
88932: CALL 55433 0 2
// repeat wait ( 0 0$1 ) ;
88936: LD_INT 35
88938: PPUSH
88939: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88943: LD_EXP 43
88947: PUSH
88948: LD_VAR 0 1
88952: ARRAY
88953: NOT
88954: PUSH
88955: LD_EXP 43
88959: PUSH
88960: LD_VAR 0 1
88964: ARRAY
88965: PUSH
88966: EMPTY
88967: EQUAL
88968: OR
88969: IFFALSE 89006
// begin for i in defenders do
88971: LD_ADDR_VAR 0 4
88975: PUSH
88976: LD_VAR 0 2
88980: PUSH
88981: FOR_IN
88982: IFFALSE 88995
// ComStop ( i ) ;
88984: LD_VAR 0 4
88988: PPUSH
88989: CALL_OW 141
88993: GO 88981
88995: POP
88996: POP
// defenders := [ ] ;
88997: LD_ADDR_VAR 0 2
89001: PUSH
89002: EMPTY
89003: ST_TO_ADDR
// exit ;
89004: GO 89232
// end ; for i in defenders do
89006: LD_ADDR_VAR 0 4
89010: PUSH
89011: LD_VAR 0 2
89015: PUSH
89016: FOR_IN
89017: IFFALSE 89106
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89019: LD_VAR 0 4
89023: PPUSH
89024: LD_EXP 67
89028: PUSH
89029: LD_VAR 0 1
89033: ARRAY
89034: PPUSH
89035: CALL_OW 308
89039: NOT
89040: IFFALSE 89064
// ComMoveToArea ( i , mc_parking [ base ] ) else
89042: LD_VAR 0 4
89046: PPUSH
89047: LD_EXP 67
89051: PUSH
89052: LD_VAR 0 1
89056: ARRAY
89057: PPUSH
89058: CALL_OW 113
89062: GO 89104
// if GetControl ( i ) = control_manual then
89064: LD_VAR 0 4
89068: PPUSH
89069: CALL_OW 263
89073: PUSH
89074: LD_INT 1
89076: EQUAL
89077: IFFALSE 89104
// if IsDrivenBy ( i ) then
89079: LD_VAR 0 4
89083: PPUSH
89084: CALL_OW 311
89088: IFFALSE 89104
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89090: LD_VAR 0 4
89094: PPUSH
89095: CALL_OW 311
89099: PPUSH
89100: CALL_OW 121
// end ;
89104: GO 89016
89106: POP
89107: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89108: LD_VAR 0 2
89112: PPUSH
89113: LD_INT 95
89115: PUSH
89116: LD_EXP 67
89120: PUSH
89121: LD_VAR 0 1
89125: ARRAY
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PPUSH
89131: CALL_OW 72
89135: PUSH
89136: LD_VAR 0 2
89140: EQUAL
89141: PUSH
89142: LD_EXP 66
89146: PUSH
89147: LD_VAR 0 1
89151: ARRAY
89152: OR
89153: PUSH
89154: LD_EXP 43
89158: PUSH
89159: LD_VAR 0 1
89163: ARRAY
89164: NOT
89165: OR
89166: IFFALSE 88936
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89168: LD_ADDR_EXP 65
89172: PUSH
89173: LD_EXP 65
89177: PPUSH
89178: LD_VAR 0 1
89182: PPUSH
89183: LD_VAR 0 2
89187: PPUSH
89188: LD_INT 21
89190: PUSH
89191: LD_INT 2
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PPUSH
89198: CALL_OW 72
89202: PPUSH
89203: CALL_OW 1
89207: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89208: LD_VAR 0 1
89212: PPUSH
89213: LD_INT 19
89215: PPUSH
89216: CALL 55433 0 2
// MC_Reset ( base , 20 ) ;
89220: LD_VAR 0 1
89224: PPUSH
89225: LD_INT 20
89227: PPUSH
89228: CALL 55433 0 2
// end ; end_of_file
89232: LD_VAR 0 3
89236: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89237: LD_INT 0
89239: PPUSH
89240: PPUSH
89241: PPUSH
89242: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89243: LD_VAR 0 1
89247: PPUSH
89248: CALL_OW 264
89252: PUSH
89253: LD_INT 91
89255: EQUAL
89256: IFFALSE 89328
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89258: LD_INT 68
89260: PPUSH
89261: LD_VAR 0 1
89265: PPUSH
89266: CALL_OW 255
89270: PPUSH
89271: CALL_OW 321
89275: PUSH
89276: LD_INT 2
89278: EQUAL
89279: IFFALSE 89291
// eff := 70 else
89281: LD_ADDR_VAR 0 4
89285: PUSH
89286: LD_INT 70
89288: ST_TO_ADDR
89289: GO 89299
// eff := 30 ;
89291: LD_ADDR_VAR 0 4
89295: PUSH
89296: LD_INT 30
89298: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89299: LD_VAR 0 1
89303: PPUSH
89304: CALL_OW 250
89308: PPUSH
89309: LD_VAR 0 1
89313: PPUSH
89314: CALL_OW 251
89318: PPUSH
89319: LD_VAR 0 4
89323: PPUSH
89324: CALL_OW 495
// end ; end ;
89328: LD_VAR 0 2
89332: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89333: LD_INT 0
89335: PPUSH
// end ;
89336: LD_VAR 0 4
89340: RET
// export function SOS_Command ( cmd ) ; begin
89341: LD_INT 0
89343: PPUSH
// end ;
89344: LD_VAR 0 2
89348: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89349: LD_INT 0
89351: PPUSH
// end ;
89352: LD_VAR 0 6
89356: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89357: LD_INT 0
89359: PPUSH
89360: PPUSH
// if not vehicle or not factory then
89361: LD_VAR 0 1
89365: NOT
89366: PUSH
89367: LD_VAR 0 2
89371: NOT
89372: OR
89373: IFFALSE 89377
// exit ;
89375: GO 89608
// if factoryWaypoints >= factory then
89377: NOP4
89381: PUSH
89382: LD_VAR 0 2
89386: GREATEREQUAL
89387: IFFALSE 89608
// if factoryWaypoints [ factory ] then
89389: NOP4
89393: PUSH
89394: LD_VAR 0 2
89398: ARRAY
89399: IFFALSE 89608
// begin if GetControl ( vehicle ) = control_manual then
89401: LD_VAR 0 1
89405: PPUSH
89406: CALL_OW 263
89410: PUSH
89411: LD_INT 1
89413: EQUAL
89414: IFFALSE 89495
// begin driver := IsDrivenBy ( vehicle ) ;
89416: LD_ADDR_VAR 0 4
89420: PUSH
89421: LD_VAR 0 1
89425: PPUSH
89426: CALL_OW 311
89430: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89431: LD_VAR 0 4
89435: PPUSH
89436: NOP4
89440: PUSH
89441: LD_VAR 0 2
89445: ARRAY
89446: PUSH
89447: LD_INT 3
89449: ARRAY
89450: PPUSH
89451: NOP4
89455: PUSH
89456: LD_VAR 0 2
89460: ARRAY
89461: PUSH
89462: LD_INT 4
89464: ARRAY
89465: PPUSH
89466: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89470: LD_VAR 0 4
89474: PPUSH
89475: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89479: LD_VAR 0 4
89483: PPUSH
89484: LD_VAR 0 2
89488: PPUSH
89489: CALL_OW 180
// end else
89493: GO 89608
// if GetControl ( vehicle ) = control_remote then
89495: LD_VAR 0 1
89499: PPUSH
89500: CALL_OW 263
89504: PUSH
89505: LD_INT 2
89507: EQUAL
89508: IFFALSE 89569
// begin wait ( 0 0$2 ) ;
89510: LD_INT 70
89512: PPUSH
89513: CALL_OW 67
// if Connect ( vehicle ) then
89517: LD_VAR 0 1
89521: PPUSH
89522: CALL 17957 0 1
89526: IFFALSE 89567
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89528: LD_VAR 0 1
89532: PPUSH
89533: NOP4
89537: PUSH
89538: LD_VAR 0 2
89542: ARRAY
89543: PUSH
89544: LD_INT 3
89546: ARRAY
89547: PPUSH
89548: NOP4
89552: PUSH
89553: LD_VAR 0 2
89557: ARRAY
89558: PUSH
89559: LD_INT 4
89561: ARRAY
89562: PPUSH
89563: CALL_OW 171
// end else
89567: GO 89608
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89569: LD_VAR 0 1
89573: PPUSH
89574: NOP4
89578: PUSH
89579: LD_VAR 0 2
89583: ARRAY
89584: PUSH
89585: LD_INT 3
89587: ARRAY
89588: PPUSH
89589: NOP4
89593: PUSH
89594: LD_VAR 0 2
89598: ARRAY
89599: PUSH
89600: LD_INT 4
89602: ARRAY
89603: PPUSH
89604: CALL_OW 171
// end ; end ;
89608: LD_VAR 0 3
89612: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89613: LD_INT 0
89615: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89616: LD_VAR 0 1
89620: PUSH
89621: LD_INT 250
89623: EQUAL
89624: PUSH
89625: LD_VAR 0 2
89629: PPUSH
89630: CALL_OW 264
89634: PUSH
89635: LD_INT 81
89637: EQUAL
89638: AND
89639: IFFALSE 89660
// MinerPlaceMine ( unit , x , y ) ;
89641: LD_VAR 0 2
89645: PPUSH
89646: LD_VAR 0 4
89650: PPUSH
89651: LD_VAR 0 5
89655: PPUSH
89656: CALL 92045 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89660: LD_VAR 0 1
89664: PUSH
89665: LD_INT 251
89667: EQUAL
89668: PUSH
89669: LD_VAR 0 2
89673: PPUSH
89674: CALL_OW 264
89678: PUSH
89679: LD_INT 81
89681: EQUAL
89682: AND
89683: IFFALSE 89704
// MinerDetonateMine ( unit , x , y ) ;
89685: LD_VAR 0 2
89689: PPUSH
89690: LD_VAR 0 4
89694: PPUSH
89695: LD_VAR 0 5
89699: PPUSH
89700: CALL 92320 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89704: LD_VAR 0 1
89708: PUSH
89709: LD_INT 252
89711: EQUAL
89712: PUSH
89713: LD_VAR 0 2
89717: PPUSH
89718: CALL_OW 264
89722: PUSH
89723: LD_INT 81
89725: EQUAL
89726: AND
89727: IFFALSE 89748
// MinerCreateMinefield ( unit , x , y ) ;
89729: LD_VAR 0 2
89733: PPUSH
89734: LD_VAR 0 4
89738: PPUSH
89739: LD_VAR 0 5
89743: PPUSH
89744: CALL 92737 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89748: LD_VAR 0 1
89752: PUSH
89753: LD_INT 253
89755: EQUAL
89756: PUSH
89757: LD_VAR 0 2
89761: PPUSH
89762: CALL_OW 257
89766: PUSH
89767: LD_INT 5
89769: EQUAL
89770: AND
89771: IFFALSE 89792
// ComBinocular ( unit , x , y ) ;
89773: LD_VAR 0 2
89777: PPUSH
89778: LD_VAR 0 4
89782: PPUSH
89783: LD_VAR 0 5
89787: PPUSH
89788: CALL 93106 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89792: LD_VAR 0 1
89796: PUSH
89797: LD_INT 254
89799: EQUAL
89800: PUSH
89801: LD_VAR 0 2
89805: PPUSH
89806: CALL_OW 264
89810: PUSH
89811: LD_INT 99
89813: EQUAL
89814: AND
89815: PUSH
89816: LD_VAR 0 3
89820: PPUSH
89821: CALL_OW 263
89825: PUSH
89826: LD_INT 3
89828: EQUAL
89829: AND
89830: IFFALSE 89846
// HackDestroyVehicle ( unit , selectedUnit ) ;
89832: LD_VAR 0 2
89836: PPUSH
89837: LD_VAR 0 3
89841: PPUSH
89842: CALL 91409 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89846: LD_VAR 0 1
89850: PUSH
89851: LD_INT 255
89853: EQUAL
89854: PUSH
89855: LD_VAR 0 2
89859: PPUSH
89860: CALL_OW 264
89864: PUSH
89865: LD_INT 14
89867: PUSH
89868: LD_INT 53
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: IN
89875: AND
89876: PUSH
89877: LD_VAR 0 4
89881: PPUSH
89882: LD_VAR 0 5
89886: PPUSH
89887: CALL_OW 488
89891: AND
89892: IFFALSE 89916
// CutTreeXYR ( unit , x , y , 12 ) ;
89894: LD_VAR 0 2
89898: PPUSH
89899: LD_VAR 0 4
89903: PPUSH
89904: LD_VAR 0 5
89908: PPUSH
89909: LD_INT 12
89911: PPUSH
89912: CALL 89979 0 4
// if cmd = 256 then
89916: LD_VAR 0 1
89920: PUSH
89921: LD_INT 256
89923: EQUAL
89924: IFFALSE 89945
// SetFactoryWaypoint ( unit , x , y ) ;
89926: LD_VAR 0 2
89930: PPUSH
89931: LD_VAR 0 4
89935: PPUSH
89936: LD_VAR 0 5
89940: PPUSH
89941: NOP4
// if cmd = 257 then
89945: LD_VAR 0 1
89949: PUSH
89950: LD_INT 257
89952: EQUAL
89953: IFFALSE 89974
// SetWarehouseGatheringPoint ( unit , x , y ) ;
89955: LD_VAR 0 2
89959: PPUSH
89960: LD_VAR 0 4
89964: PPUSH
89965: LD_VAR 0 5
89969: PPUSH
89970: NOP4
// end ;
89974: LD_VAR 0 6
89978: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89979: LD_INT 0
89981: PPUSH
89982: PPUSH
89983: PPUSH
89984: PPUSH
89985: PPUSH
89986: PPUSH
89987: PPUSH
89988: PPUSH
89989: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89990: LD_VAR 0 1
89994: NOT
89995: PUSH
89996: LD_VAR 0 2
90000: PPUSH
90001: LD_VAR 0 3
90005: PPUSH
90006: CALL_OW 488
90010: NOT
90011: OR
90012: PUSH
90013: LD_VAR 0 4
90017: NOT
90018: OR
90019: IFFALSE 90023
// exit ;
90021: GO 90363
// list := [ ] ;
90023: LD_ADDR_VAR 0 13
90027: PUSH
90028: EMPTY
90029: ST_TO_ADDR
// if x - r < 0 then
90030: LD_VAR 0 2
90034: PUSH
90035: LD_VAR 0 4
90039: MINUS
90040: PUSH
90041: LD_INT 0
90043: LESS
90044: IFFALSE 90056
// min_x := 0 else
90046: LD_ADDR_VAR 0 7
90050: PUSH
90051: LD_INT 0
90053: ST_TO_ADDR
90054: GO 90072
// min_x := x - r ;
90056: LD_ADDR_VAR 0 7
90060: PUSH
90061: LD_VAR 0 2
90065: PUSH
90066: LD_VAR 0 4
90070: MINUS
90071: ST_TO_ADDR
// if y - r < 0 then
90072: LD_VAR 0 3
90076: PUSH
90077: LD_VAR 0 4
90081: MINUS
90082: PUSH
90083: LD_INT 0
90085: LESS
90086: IFFALSE 90098
// min_y := 0 else
90088: LD_ADDR_VAR 0 8
90092: PUSH
90093: LD_INT 0
90095: ST_TO_ADDR
90096: GO 90114
// min_y := y - r ;
90098: LD_ADDR_VAR 0 8
90102: PUSH
90103: LD_VAR 0 3
90107: PUSH
90108: LD_VAR 0 4
90112: MINUS
90113: ST_TO_ADDR
// max_x := x + r ;
90114: LD_ADDR_VAR 0 9
90118: PUSH
90119: LD_VAR 0 2
90123: PUSH
90124: LD_VAR 0 4
90128: PLUS
90129: ST_TO_ADDR
// max_y := y + r ;
90130: LD_ADDR_VAR 0 10
90134: PUSH
90135: LD_VAR 0 3
90139: PUSH
90140: LD_VAR 0 4
90144: PLUS
90145: ST_TO_ADDR
// for _x = min_x to max_x do
90146: LD_ADDR_VAR 0 11
90150: PUSH
90151: DOUBLE
90152: LD_VAR 0 7
90156: DEC
90157: ST_TO_ADDR
90158: LD_VAR 0 9
90162: PUSH
90163: FOR_TO
90164: IFFALSE 90281
// for _y = min_y to max_y do
90166: LD_ADDR_VAR 0 12
90170: PUSH
90171: DOUBLE
90172: LD_VAR 0 8
90176: DEC
90177: ST_TO_ADDR
90178: LD_VAR 0 10
90182: PUSH
90183: FOR_TO
90184: IFFALSE 90277
// begin if not ValidHex ( _x , _y ) then
90186: LD_VAR 0 11
90190: PPUSH
90191: LD_VAR 0 12
90195: PPUSH
90196: CALL_OW 488
90200: NOT
90201: IFFALSE 90205
// continue ;
90203: GO 90183
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90205: LD_VAR 0 11
90209: PPUSH
90210: LD_VAR 0 12
90214: PPUSH
90215: CALL_OW 351
90219: PUSH
90220: LD_VAR 0 11
90224: PPUSH
90225: LD_VAR 0 12
90229: PPUSH
90230: CALL_OW 554
90234: AND
90235: IFFALSE 90275
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90237: LD_ADDR_VAR 0 13
90241: PUSH
90242: LD_VAR 0 13
90246: PPUSH
90247: LD_VAR 0 13
90251: PUSH
90252: LD_INT 1
90254: PLUS
90255: PPUSH
90256: LD_VAR 0 11
90260: PUSH
90261: LD_VAR 0 12
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PPUSH
90270: CALL_OW 2
90274: ST_TO_ADDR
// end ;
90275: GO 90183
90277: POP
90278: POP
90279: GO 90163
90281: POP
90282: POP
// if not list then
90283: LD_VAR 0 13
90287: NOT
90288: IFFALSE 90292
// exit ;
90290: GO 90363
// for i in list do
90292: LD_ADDR_VAR 0 6
90296: PUSH
90297: LD_VAR 0 13
90301: PUSH
90302: FOR_IN
90303: IFFALSE 90361
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90305: LD_VAR 0 1
90309: PPUSH
90310: LD_STRING M
90312: PUSH
90313: LD_VAR 0 6
90317: PUSH
90318: LD_INT 1
90320: ARRAY
90321: PUSH
90322: LD_VAR 0 6
90326: PUSH
90327: LD_INT 2
90329: ARRAY
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 0
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: LD_INT 0
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: PUSH
90352: EMPTY
90353: LIST
90354: PPUSH
90355: CALL_OW 447
90359: GO 90302
90361: POP
90362: POP
// end ;
90363: LD_VAR 0 5
90367: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90368: LD_EXP 87
90372: NOT
90373: IFFALSE 90423
90375: GO 90377
90377: DISABLE
// begin initHack := true ;
90378: LD_ADDR_EXP 87
90382: PUSH
90383: LD_INT 1
90385: ST_TO_ADDR
// hackTanks := [ ] ;
90386: LD_ADDR_EXP 88
90390: PUSH
90391: EMPTY
90392: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90393: LD_ADDR_EXP 89
90397: PUSH
90398: EMPTY
90399: ST_TO_ADDR
// hackLimit := 3 ;
90400: LD_ADDR_EXP 90
90404: PUSH
90405: LD_INT 3
90407: ST_TO_ADDR
// hackDist := 12 ;
90408: LD_ADDR_EXP 91
90412: PUSH
90413: LD_INT 12
90415: ST_TO_ADDR
// hackCounter := [ ] ;
90416: LD_ADDR_EXP 92
90420: PUSH
90421: EMPTY
90422: ST_TO_ADDR
// end ;
90423: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90424: LD_EXP 87
90428: PUSH
90429: LD_INT 34
90431: PUSH
90432: LD_INT 99
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PPUSH
90439: CALL_OW 69
90443: AND
90444: IFFALSE 90697
90446: GO 90448
90448: DISABLE
90449: LD_INT 0
90451: PPUSH
90452: PPUSH
// begin enable ;
90453: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90454: LD_ADDR_VAR 0 1
90458: PUSH
90459: LD_INT 34
90461: PUSH
90462: LD_INT 99
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PPUSH
90469: CALL_OW 69
90473: PUSH
90474: FOR_IN
90475: IFFALSE 90695
// begin if not i in hackTanks then
90477: LD_VAR 0 1
90481: PUSH
90482: LD_EXP 88
90486: IN
90487: NOT
90488: IFFALSE 90571
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90490: LD_ADDR_EXP 88
90494: PUSH
90495: LD_EXP 88
90499: PPUSH
90500: LD_EXP 88
90504: PUSH
90505: LD_INT 1
90507: PLUS
90508: PPUSH
90509: LD_VAR 0 1
90513: PPUSH
90514: CALL_OW 1
90518: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90519: LD_ADDR_EXP 89
90523: PUSH
90524: LD_EXP 89
90528: PPUSH
90529: LD_EXP 89
90533: PUSH
90534: LD_INT 1
90536: PLUS
90537: PPUSH
90538: EMPTY
90539: PPUSH
90540: CALL_OW 1
90544: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90545: LD_ADDR_EXP 92
90549: PUSH
90550: LD_EXP 92
90554: PPUSH
90555: LD_EXP 92
90559: PUSH
90560: LD_INT 1
90562: PLUS
90563: PPUSH
90564: EMPTY
90565: PPUSH
90566: CALL_OW 1
90570: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90571: LD_VAR 0 1
90575: PPUSH
90576: CALL_OW 302
90580: NOT
90581: IFFALSE 90594
// begin HackUnlinkAll ( i ) ;
90583: LD_VAR 0 1
90587: PPUSH
90588: CALL 90700 0 1
// continue ;
90592: GO 90474
// end ; HackCheckCapturedStatus ( i ) ;
90594: LD_VAR 0 1
90598: PPUSH
90599: CALL 91143 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90603: LD_ADDR_VAR 0 2
90607: PUSH
90608: LD_INT 81
90610: PUSH
90611: LD_VAR 0 1
90615: PPUSH
90616: CALL_OW 255
90620: PUSH
90621: EMPTY
90622: LIST
90623: LIST
90624: PUSH
90625: LD_INT 33
90627: PUSH
90628: LD_INT 3
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 91
90637: PUSH
90638: LD_VAR 0 1
90642: PUSH
90643: LD_EXP 91
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 50
90655: PUSH
90656: EMPTY
90657: LIST
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: PPUSH
90665: CALL_OW 69
90669: ST_TO_ADDR
// if not tmp then
90670: LD_VAR 0 2
90674: NOT
90675: IFFALSE 90679
// continue ;
90677: GO 90474
// HackLink ( i , tmp ) ;
90679: LD_VAR 0 1
90683: PPUSH
90684: LD_VAR 0 2
90688: PPUSH
90689: CALL 90836 0 2
// end ;
90693: GO 90474
90695: POP
90696: POP
// end ;
90697: PPOPN 2
90699: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90700: LD_INT 0
90702: PPUSH
90703: PPUSH
90704: PPUSH
// if not hack in hackTanks then
90705: LD_VAR 0 1
90709: PUSH
90710: LD_EXP 88
90714: IN
90715: NOT
90716: IFFALSE 90720
// exit ;
90718: GO 90831
// index := GetElementIndex ( hackTanks , hack ) ;
90720: LD_ADDR_VAR 0 4
90724: PUSH
90725: LD_EXP 88
90729: PPUSH
90730: LD_VAR 0 1
90734: PPUSH
90735: CALL 14773 0 2
90739: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90740: LD_EXP 89
90744: PUSH
90745: LD_VAR 0 4
90749: ARRAY
90750: IFFALSE 90831
// begin for i in hackTanksCaptured [ index ] do
90752: LD_ADDR_VAR 0 3
90756: PUSH
90757: LD_EXP 89
90761: PUSH
90762: LD_VAR 0 4
90766: ARRAY
90767: PUSH
90768: FOR_IN
90769: IFFALSE 90795
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90771: LD_VAR 0 3
90775: PUSH
90776: LD_INT 1
90778: ARRAY
90779: PPUSH
90780: LD_VAR 0 3
90784: PUSH
90785: LD_INT 2
90787: ARRAY
90788: PPUSH
90789: CALL_OW 235
90793: GO 90768
90795: POP
90796: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90797: LD_ADDR_EXP 89
90801: PUSH
90802: LD_EXP 89
90806: PPUSH
90807: LD_VAR 0 4
90811: PPUSH
90812: EMPTY
90813: PPUSH
90814: CALL_OW 1
90818: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90819: LD_VAR 0 1
90823: PPUSH
90824: LD_INT 0
90826: PPUSH
90827: CALL_OW 505
// end ; end ;
90831: LD_VAR 0 2
90835: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90836: LD_INT 0
90838: PPUSH
90839: PPUSH
90840: PPUSH
// if not hack in hackTanks or not vehicles then
90841: LD_VAR 0 1
90845: PUSH
90846: LD_EXP 88
90850: IN
90851: NOT
90852: PUSH
90853: LD_VAR 0 2
90857: NOT
90858: OR
90859: IFFALSE 90863
// exit ;
90861: GO 91138
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90863: LD_ADDR_VAR 0 2
90867: PUSH
90868: LD_VAR 0 1
90872: PPUSH
90873: LD_VAR 0 2
90877: PPUSH
90878: LD_INT 1
90880: PPUSH
90881: LD_INT 1
90883: PPUSH
90884: CALL 15423 0 4
90888: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90889: LD_ADDR_VAR 0 5
90893: PUSH
90894: LD_EXP 88
90898: PPUSH
90899: LD_VAR 0 1
90903: PPUSH
90904: CALL 14773 0 2
90908: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90909: LD_EXP 89
90913: PUSH
90914: LD_VAR 0 5
90918: ARRAY
90919: PUSH
90920: LD_EXP 90
90924: LESS
90925: IFFALSE 91114
// begin for i := 1 to vehicles do
90927: LD_ADDR_VAR 0 4
90931: PUSH
90932: DOUBLE
90933: LD_INT 1
90935: DEC
90936: ST_TO_ADDR
90937: LD_VAR 0 2
90941: PUSH
90942: FOR_TO
90943: IFFALSE 91112
// begin if hackTanksCaptured [ index ] = hackLimit then
90945: LD_EXP 89
90949: PUSH
90950: LD_VAR 0 5
90954: ARRAY
90955: PUSH
90956: LD_EXP 90
90960: EQUAL
90961: IFFALSE 90965
// break ;
90963: GO 91112
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90965: LD_ADDR_EXP 92
90969: PUSH
90970: LD_EXP 92
90974: PPUSH
90975: LD_VAR 0 5
90979: PPUSH
90980: LD_EXP 92
90984: PUSH
90985: LD_VAR 0 5
90989: ARRAY
90990: PUSH
90991: LD_INT 1
90993: PLUS
90994: PPUSH
90995: CALL_OW 1
90999: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91000: LD_ADDR_EXP 89
91004: PUSH
91005: LD_EXP 89
91009: PPUSH
91010: LD_VAR 0 5
91014: PUSH
91015: LD_EXP 89
91019: PUSH
91020: LD_VAR 0 5
91024: ARRAY
91025: PUSH
91026: LD_INT 1
91028: PLUS
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PPUSH
91034: LD_VAR 0 2
91038: PUSH
91039: LD_VAR 0 4
91043: ARRAY
91044: PUSH
91045: LD_VAR 0 2
91049: PUSH
91050: LD_VAR 0 4
91054: ARRAY
91055: PPUSH
91056: CALL_OW 255
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PPUSH
91065: CALL 14988 0 3
91069: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91070: LD_VAR 0 2
91074: PUSH
91075: LD_VAR 0 4
91079: ARRAY
91080: PPUSH
91081: LD_VAR 0 1
91085: PPUSH
91086: CALL_OW 255
91090: PPUSH
91091: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91095: LD_VAR 0 2
91099: PUSH
91100: LD_VAR 0 4
91104: ARRAY
91105: PPUSH
91106: CALL_OW 141
// end ;
91110: GO 90942
91112: POP
91113: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91114: LD_VAR 0 1
91118: PPUSH
91119: LD_EXP 89
91123: PUSH
91124: LD_VAR 0 5
91128: ARRAY
91129: PUSH
91130: LD_INT 0
91132: PLUS
91133: PPUSH
91134: CALL_OW 505
// end ;
91138: LD_VAR 0 3
91142: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91143: LD_INT 0
91145: PPUSH
91146: PPUSH
91147: PPUSH
91148: PPUSH
// if not hack in hackTanks then
91149: LD_VAR 0 1
91153: PUSH
91154: LD_EXP 88
91158: IN
91159: NOT
91160: IFFALSE 91164
// exit ;
91162: GO 91404
// index := GetElementIndex ( hackTanks , hack ) ;
91164: LD_ADDR_VAR 0 4
91168: PUSH
91169: LD_EXP 88
91173: PPUSH
91174: LD_VAR 0 1
91178: PPUSH
91179: CALL 14773 0 2
91183: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91184: LD_ADDR_VAR 0 3
91188: PUSH
91189: DOUBLE
91190: LD_EXP 89
91194: PUSH
91195: LD_VAR 0 4
91199: ARRAY
91200: INC
91201: ST_TO_ADDR
91202: LD_INT 1
91204: PUSH
91205: FOR_DOWNTO
91206: IFFALSE 91378
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91208: LD_ADDR_VAR 0 5
91212: PUSH
91213: LD_EXP 89
91217: PUSH
91218: LD_VAR 0 4
91222: ARRAY
91223: PUSH
91224: LD_VAR 0 3
91228: ARRAY
91229: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91230: LD_VAR 0 5
91234: PUSH
91235: LD_INT 1
91237: ARRAY
91238: PPUSH
91239: CALL_OW 302
91243: NOT
91244: PUSH
91245: LD_VAR 0 5
91249: PUSH
91250: LD_INT 1
91252: ARRAY
91253: PPUSH
91254: CALL_OW 255
91258: PUSH
91259: LD_VAR 0 1
91263: PPUSH
91264: CALL_OW 255
91268: NONEQUAL
91269: OR
91270: IFFALSE 91376
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91272: LD_VAR 0 5
91276: PUSH
91277: LD_INT 1
91279: ARRAY
91280: PPUSH
91281: CALL_OW 305
91285: PUSH
91286: LD_VAR 0 5
91290: PUSH
91291: LD_INT 1
91293: ARRAY
91294: PPUSH
91295: CALL_OW 255
91299: PUSH
91300: LD_VAR 0 1
91304: PPUSH
91305: CALL_OW 255
91309: EQUAL
91310: AND
91311: IFFALSE 91335
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91313: LD_VAR 0 5
91317: PUSH
91318: LD_INT 1
91320: ARRAY
91321: PPUSH
91322: LD_VAR 0 5
91326: PUSH
91327: LD_INT 2
91329: ARRAY
91330: PPUSH
91331: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91335: LD_ADDR_EXP 89
91339: PUSH
91340: LD_EXP 89
91344: PPUSH
91345: LD_VAR 0 4
91349: PPUSH
91350: LD_EXP 89
91354: PUSH
91355: LD_VAR 0 4
91359: ARRAY
91360: PPUSH
91361: LD_VAR 0 3
91365: PPUSH
91366: CALL_OW 3
91370: PPUSH
91371: CALL_OW 1
91375: ST_TO_ADDR
// end ; end ;
91376: GO 91205
91378: POP
91379: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91380: LD_VAR 0 1
91384: PPUSH
91385: LD_EXP 89
91389: PUSH
91390: LD_VAR 0 4
91394: ARRAY
91395: PUSH
91396: LD_INT 0
91398: PLUS
91399: PPUSH
91400: CALL_OW 505
// end ;
91404: LD_VAR 0 2
91408: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91409: LD_INT 0
91411: PPUSH
91412: PPUSH
91413: PPUSH
91414: PPUSH
// if not hack in hackTanks then
91415: LD_VAR 0 1
91419: PUSH
91420: LD_EXP 88
91424: IN
91425: NOT
91426: IFFALSE 91430
// exit ;
91428: GO 91515
// index := GetElementIndex ( hackTanks , hack ) ;
91430: LD_ADDR_VAR 0 5
91434: PUSH
91435: LD_EXP 88
91439: PPUSH
91440: LD_VAR 0 1
91444: PPUSH
91445: CALL 14773 0 2
91449: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91450: LD_ADDR_VAR 0 4
91454: PUSH
91455: DOUBLE
91456: LD_INT 1
91458: DEC
91459: ST_TO_ADDR
91460: LD_EXP 89
91464: PUSH
91465: LD_VAR 0 5
91469: ARRAY
91470: PUSH
91471: FOR_TO
91472: IFFALSE 91513
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91474: LD_EXP 89
91478: PUSH
91479: LD_VAR 0 5
91483: ARRAY
91484: PUSH
91485: LD_VAR 0 4
91489: ARRAY
91490: PUSH
91491: LD_INT 1
91493: ARRAY
91494: PUSH
91495: LD_VAR 0 2
91499: EQUAL
91500: IFFALSE 91511
// KillUnit ( vehicle ) ;
91502: LD_VAR 0 2
91506: PPUSH
91507: CALL_OW 66
91511: GO 91471
91513: POP
91514: POP
// end ;
91515: LD_VAR 0 3
91519: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91520: LD_EXP 93
91524: NOT
91525: IFFALSE 91560
91527: GO 91529
91529: DISABLE
// begin initMiner := true ;
91530: LD_ADDR_EXP 93
91534: PUSH
91535: LD_INT 1
91537: ST_TO_ADDR
// minersList := [ ] ;
91538: LD_ADDR_EXP 94
91542: PUSH
91543: EMPTY
91544: ST_TO_ADDR
// minerMinesList := [ ] ;
91545: LD_ADDR_EXP 95
91549: PUSH
91550: EMPTY
91551: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91552: LD_ADDR_EXP 96
91556: PUSH
91557: LD_INT 5
91559: ST_TO_ADDR
// end ;
91560: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91561: LD_EXP 93
91565: PUSH
91566: LD_INT 34
91568: PUSH
91569: LD_INT 81
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PPUSH
91576: CALL_OW 69
91580: AND
91581: IFFALSE 92042
91583: GO 91585
91585: DISABLE
91586: LD_INT 0
91588: PPUSH
91589: PPUSH
91590: PPUSH
91591: PPUSH
// begin enable ;
91592: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91593: LD_ADDR_VAR 0 1
91597: PUSH
91598: LD_INT 34
91600: PUSH
91601: LD_INT 81
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PPUSH
91608: CALL_OW 69
91612: PUSH
91613: FOR_IN
91614: IFFALSE 91686
// begin if not i in minersList then
91616: LD_VAR 0 1
91620: PUSH
91621: LD_EXP 94
91625: IN
91626: NOT
91627: IFFALSE 91684
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91629: LD_ADDR_EXP 94
91633: PUSH
91634: LD_EXP 94
91638: PPUSH
91639: LD_EXP 94
91643: PUSH
91644: LD_INT 1
91646: PLUS
91647: PPUSH
91648: LD_VAR 0 1
91652: PPUSH
91653: CALL_OW 1
91657: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91658: LD_ADDR_EXP 95
91662: PUSH
91663: LD_EXP 95
91667: PPUSH
91668: LD_EXP 95
91672: PUSH
91673: LD_INT 1
91675: PLUS
91676: PPUSH
91677: EMPTY
91678: PPUSH
91679: CALL_OW 1
91683: ST_TO_ADDR
// end end ;
91684: GO 91613
91686: POP
91687: POP
// for i := minerMinesList downto 1 do
91688: LD_ADDR_VAR 0 1
91692: PUSH
91693: DOUBLE
91694: LD_EXP 95
91698: INC
91699: ST_TO_ADDR
91700: LD_INT 1
91702: PUSH
91703: FOR_DOWNTO
91704: IFFALSE 92040
// begin if IsLive ( minersList [ i ] ) then
91706: LD_EXP 94
91710: PUSH
91711: LD_VAR 0 1
91715: ARRAY
91716: PPUSH
91717: CALL_OW 300
91721: IFFALSE 91749
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91723: LD_EXP 94
91727: PUSH
91728: LD_VAR 0 1
91732: ARRAY
91733: PPUSH
91734: LD_EXP 95
91738: PUSH
91739: LD_VAR 0 1
91743: ARRAY
91744: PPUSH
91745: CALL_OW 505
// if not minerMinesList [ i ] then
91749: LD_EXP 95
91753: PUSH
91754: LD_VAR 0 1
91758: ARRAY
91759: NOT
91760: IFFALSE 91764
// continue ;
91762: GO 91703
// for j := minerMinesList [ i ] downto 1 do
91764: LD_ADDR_VAR 0 2
91768: PUSH
91769: DOUBLE
91770: LD_EXP 95
91774: PUSH
91775: LD_VAR 0 1
91779: ARRAY
91780: INC
91781: ST_TO_ADDR
91782: LD_INT 1
91784: PUSH
91785: FOR_DOWNTO
91786: IFFALSE 92036
// begin side := GetSide ( minersList [ i ] ) ;
91788: LD_ADDR_VAR 0 3
91792: PUSH
91793: LD_EXP 94
91797: PUSH
91798: LD_VAR 0 1
91802: ARRAY
91803: PPUSH
91804: CALL_OW 255
91808: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91809: LD_ADDR_VAR 0 4
91813: PUSH
91814: LD_EXP 95
91818: PUSH
91819: LD_VAR 0 1
91823: ARRAY
91824: PUSH
91825: LD_VAR 0 2
91829: ARRAY
91830: PUSH
91831: LD_INT 1
91833: ARRAY
91834: PPUSH
91835: LD_EXP 95
91839: PUSH
91840: LD_VAR 0 1
91844: ARRAY
91845: PUSH
91846: LD_VAR 0 2
91850: ARRAY
91851: PUSH
91852: LD_INT 2
91854: ARRAY
91855: PPUSH
91856: CALL_OW 428
91860: ST_TO_ADDR
// if not tmp then
91861: LD_VAR 0 4
91865: NOT
91866: IFFALSE 91870
// continue ;
91868: GO 91785
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91870: LD_VAR 0 4
91874: PUSH
91875: LD_INT 81
91877: PUSH
91878: LD_VAR 0 3
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PPUSH
91887: CALL_OW 69
91891: IN
91892: PUSH
91893: LD_EXP 95
91897: PUSH
91898: LD_VAR 0 1
91902: ARRAY
91903: PUSH
91904: LD_VAR 0 2
91908: ARRAY
91909: PUSH
91910: LD_INT 1
91912: ARRAY
91913: PPUSH
91914: LD_EXP 95
91918: PUSH
91919: LD_VAR 0 1
91923: ARRAY
91924: PUSH
91925: LD_VAR 0 2
91929: ARRAY
91930: PUSH
91931: LD_INT 2
91933: ARRAY
91934: PPUSH
91935: CALL_OW 458
91939: AND
91940: IFFALSE 92034
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91942: LD_EXP 95
91946: PUSH
91947: LD_VAR 0 1
91951: ARRAY
91952: PUSH
91953: LD_VAR 0 2
91957: ARRAY
91958: PUSH
91959: LD_INT 1
91961: ARRAY
91962: PPUSH
91963: LD_EXP 95
91967: PUSH
91968: LD_VAR 0 1
91972: ARRAY
91973: PUSH
91974: LD_VAR 0 2
91978: ARRAY
91979: PUSH
91980: LD_INT 2
91982: ARRAY
91983: PPUSH
91984: LD_VAR 0 3
91988: PPUSH
91989: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91993: LD_ADDR_EXP 95
91997: PUSH
91998: LD_EXP 95
92002: PPUSH
92003: LD_VAR 0 1
92007: PPUSH
92008: LD_EXP 95
92012: PUSH
92013: LD_VAR 0 1
92017: ARRAY
92018: PPUSH
92019: LD_VAR 0 2
92023: PPUSH
92024: CALL_OW 3
92028: PPUSH
92029: CALL_OW 1
92033: ST_TO_ADDR
// end ; end ;
92034: GO 91785
92036: POP
92037: POP
// end ;
92038: GO 91703
92040: POP
92041: POP
// end ;
92042: PPOPN 4
92044: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92045: LD_INT 0
92047: PPUSH
92048: PPUSH
// result := false ;
92049: LD_ADDR_VAR 0 4
92053: PUSH
92054: LD_INT 0
92056: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92057: LD_VAR 0 1
92061: PPUSH
92062: CALL_OW 264
92066: PUSH
92067: LD_INT 81
92069: EQUAL
92070: NOT
92071: IFFALSE 92075
// exit ;
92073: GO 92315
// index := GetElementIndex ( minersList , unit ) ;
92075: LD_ADDR_VAR 0 5
92079: PUSH
92080: LD_EXP 94
92084: PPUSH
92085: LD_VAR 0 1
92089: PPUSH
92090: CALL 14773 0 2
92094: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92095: LD_EXP 95
92099: PUSH
92100: LD_VAR 0 5
92104: ARRAY
92105: PUSH
92106: LD_EXP 96
92110: GREATEREQUAL
92111: IFFALSE 92115
// exit ;
92113: GO 92315
// ComMoveXY ( unit , x , y ) ;
92115: LD_VAR 0 1
92119: PPUSH
92120: LD_VAR 0 2
92124: PPUSH
92125: LD_VAR 0 3
92129: PPUSH
92130: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92134: LD_INT 35
92136: PPUSH
92137: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92141: LD_VAR 0 1
92145: PPUSH
92146: LD_VAR 0 2
92150: PPUSH
92151: LD_VAR 0 3
92155: PPUSH
92156: CALL 46128 0 3
92160: NOT
92161: PUSH
92162: LD_VAR 0 1
92166: PPUSH
92167: CALL_OW 314
92171: AND
92172: IFFALSE 92176
// exit ;
92174: GO 92315
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92176: LD_VAR 0 2
92180: PPUSH
92181: LD_VAR 0 3
92185: PPUSH
92186: CALL_OW 428
92190: PUSH
92191: LD_VAR 0 1
92195: EQUAL
92196: PUSH
92197: LD_VAR 0 1
92201: PPUSH
92202: CALL_OW 314
92206: NOT
92207: AND
92208: IFFALSE 92134
// PlaySoundXY ( x , y , PlantMine ) ;
92210: LD_VAR 0 2
92214: PPUSH
92215: LD_VAR 0 3
92219: PPUSH
92220: LD_STRING PlantMine
92222: PPUSH
92223: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92227: LD_VAR 0 2
92231: PPUSH
92232: LD_VAR 0 3
92236: PPUSH
92237: LD_VAR 0 1
92241: PPUSH
92242: CALL_OW 255
92246: PPUSH
92247: LD_INT 0
92249: PPUSH
92250: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92254: LD_ADDR_EXP 95
92258: PUSH
92259: LD_EXP 95
92263: PPUSH
92264: LD_VAR 0 5
92268: PUSH
92269: LD_EXP 95
92273: PUSH
92274: LD_VAR 0 5
92278: ARRAY
92279: PUSH
92280: LD_INT 1
92282: PLUS
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PPUSH
92288: LD_VAR 0 2
92292: PUSH
92293: LD_VAR 0 3
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PPUSH
92302: CALL 14988 0 3
92306: ST_TO_ADDR
// result := true ;
92307: LD_ADDR_VAR 0 4
92311: PUSH
92312: LD_INT 1
92314: ST_TO_ADDR
// end ;
92315: LD_VAR 0 4
92319: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92320: LD_INT 0
92322: PPUSH
92323: PPUSH
92324: PPUSH
// if not unit in minersList then
92325: LD_VAR 0 1
92329: PUSH
92330: LD_EXP 94
92334: IN
92335: NOT
92336: IFFALSE 92340
// exit ;
92338: GO 92732
// index := GetElementIndex ( minersList , unit ) ;
92340: LD_ADDR_VAR 0 6
92344: PUSH
92345: LD_EXP 94
92349: PPUSH
92350: LD_VAR 0 1
92354: PPUSH
92355: CALL 14773 0 2
92359: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92360: LD_ADDR_VAR 0 5
92364: PUSH
92365: DOUBLE
92366: LD_EXP 95
92370: PUSH
92371: LD_VAR 0 6
92375: ARRAY
92376: INC
92377: ST_TO_ADDR
92378: LD_INT 1
92380: PUSH
92381: FOR_DOWNTO
92382: IFFALSE 92543
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92384: LD_EXP 95
92388: PUSH
92389: LD_VAR 0 6
92393: ARRAY
92394: PUSH
92395: LD_VAR 0 5
92399: ARRAY
92400: PUSH
92401: LD_INT 1
92403: ARRAY
92404: PUSH
92405: LD_VAR 0 2
92409: EQUAL
92410: PUSH
92411: LD_EXP 95
92415: PUSH
92416: LD_VAR 0 6
92420: ARRAY
92421: PUSH
92422: LD_VAR 0 5
92426: ARRAY
92427: PUSH
92428: LD_INT 2
92430: ARRAY
92431: PUSH
92432: LD_VAR 0 3
92436: EQUAL
92437: AND
92438: IFFALSE 92541
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92440: LD_EXP 95
92444: PUSH
92445: LD_VAR 0 6
92449: ARRAY
92450: PUSH
92451: LD_VAR 0 5
92455: ARRAY
92456: PUSH
92457: LD_INT 1
92459: ARRAY
92460: PPUSH
92461: LD_EXP 95
92465: PUSH
92466: LD_VAR 0 6
92470: ARRAY
92471: PUSH
92472: LD_VAR 0 5
92476: ARRAY
92477: PUSH
92478: LD_INT 2
92480: ARRAY
92481: PPUSH
92482: LD_VAR 0 1
92486: PPUSH
92487: CALL_OW 255
92491: PPUSH
92492: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92496: LD_ADDR_EXP 95
92500: PUSH
92501: LD_EXP 95
92505: PPUSH
92506: LD_VAR 0 6
92510: PPUSH
92511: LD_EXP 95
92515: PUSH
92516: LD_VAR 0 6
92520: ARRAY
92521: PPUSH
92522: LD_VAR 0 5
92526: PPUSH
92527: CALL_OW 3
92531: PPUSH
92532: CALL_OW 1
92536: ST_TO_ADDR
// exit ;
92537: POP
92538: POP
92539: GO 92732
// end ; end ;
92541: GO 92381
92543: POP
92544: POP
// for i := minerMinesList [ index ] downto 1 do
92545: LD_ADDR_VAR 0 5
92549: PUSH
92550: DOUBLE
92551: LD_EXP 95
92555: PUSH
92556: LD_VAR 0 6
92560: ARRAY
92561: INC
92562: ST_TO_ADDR
92563: LD_INT 1
92565: PUSH
92566: FOR_DOWNTO
92567: IFFALSE 92730
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92569: LD_EXP 95
92573: PUSH
92574: LD_VAR 0 6
92578: ARRAY
92579: PUSH
92580: LD_VAR 0 5
92584: ARRAY
92585: PUSH
92586: LD_INT 1
92588: ARRAY
92589: PPUSH
92590: LD_EXP 95
92594: PUSH
92595: LD_VAR 0 6
92599: ARRAY
92600: PUSH
92601: LD_VAR 0 5
92605: ARRAY
92606: PUSH
92607: LD_INT 2
92609: ARRAY
92610: PPUSH
92611: LD_VAR 0 2
92615: PPUSH
92616: LD_VAR 0 3
92620: PPUSH
92621: CALL_OW 298
92625: PUSH
92626: LD_INT 6
92628: LESS
92629: IFFALSE 92728
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92631: LD_EXP 95
92635: PUSH
92636: LD_VAR 0 6
92640: ARRAY
92641: PUSH
92642: LD_VAR 0 5
92646: ARRAY
92647: PUSH
92648: LD_INT 1
92650: ARRAY
92651: PPUSH
92652: LD_EXP 95
92656: PUSH
92657: LD_VAR 0 6
92661: ARRAY
92662: PUSH
92663: LD_VAR 0 5
92667: ARRAY
92668: PUSH
92669: LD_INT 2
92671: ARRAY
92672: PPUSH
92673: LD_VAR 0 1
92677: PPUSH
92678: CALL_OW 255
92682: PPUSH
92683: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92687: LD_ADDR_EXP 95
92691: PUSH
92692: LD_EXP 95
92696: PPUSH
92697: LD_VAR 0 6
92701: PPUSH
92702: LD_EXP 95
92706: PUSH
92707: LD_VAR 0 6
92711: ARRAY
92712: PPUSH
92713: LD_VAR 0 5
92717: PPUSH
92718: CALL_OW 3
92722: PPUSH
92723: CALL_OW 1
92727: ST_TO_ADDR
// end ; end ;
92728: GO 92566
92730: POP
92731: POP
// end ;
92732: LD_VAR 0 4
92736: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92737: LD_INT 0
92739: PPUSH
92740: PPUSH
92741: PPUSH
92742: PPUSH
92743: PPUSH
92744: PPUSH
92745: PPUSH
92746: PPUSH
92747: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92748: LD_VAR 0 1
92752: PPUSH
92753: CALL_OW 264
92757: PUSH
92758: LD_INT 81
92760: EQUAL
92761: NOT
92762: PUSH
92763: LD_VAR 0 1
92767: PUSH
92768: LD_EXP 94
92772: IN
92773: NOT
92774: OR
92775: IFFALSE 92779
// exit ;
92777: GO 93101
// index := GetElementIndex ( minersList , unit ) ;
92779: LD_ADDR_VAR 0 6
92783: PUSH
92784: LD_EXP 94
92788: PPUSH
92789: LD_VAR 0 1
92793: PPUSH
92794: CALL 14773 0 2
92798: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92799: LD_ADDR_VAR 0 8
92803: PUSH
92804: LD_EXP 96
92808: PUSH
92809: LD_EXP 95
92813: PUSH
92814: LD_VAR 0 6
92818: ARRAY
92819: MINUS
92820: ST_TO_ADDR
// if not minesFreeAmount then
92821: LD_VAR 0 8
92825: NOT
92826: IFFALSE 92830
// exit ;
92828: GO 93101
// tmp := [ ] ;
92830: LD_ADDR_VAR 0 7
92834: PUSH
92835: EMPTY
92836: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92837: LD_ADDR_VAR 0 5
92841: PUSH
92842: DOUBLE
92843: LD_INT 1
92845: DEC
92846: ST_TO_ADDR
92847: LD_VAR 0 8
92851: PUSH
92852: FOR_TO
92853: IFFALSE 93048
// begin _d := rand ( 0 , 5 ) ;
92855: LD_ADDR_VAR 0 11
92859: PUSH
92860: LD_INT 0
92862: PPUSH
92863: LD_INT 5
92865: PPUSH
92866: CALL_OW 12
92870: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92871: LD_ADDR_VAR 0 12
92875: PUSH
92876: LD_INT 2
92878: PPUSH
92879: LD_INT 6
92881: PPUSH
92882: CALL_OW 12
92886: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92887: LD_ADDR_VAR 0 9
92891: PUSH
92892: LD_VAR 0 2
92896: PPUSH
92897: LD_VAR 0 11
92901: PPUSH
92902: LD_VAR 0 12
92906: PPUSH
92907: CALL_OW 272
92911: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92912: LD_ADDR_VAR 0 10
92916: PUSH
92917: LD_VAR 0 3
92921: PPUSH
92922: LD_VAR 0 11
92926: PPUSH
92927: LD_VAR 0 12
92931: PPUSH
92932: CALL_OW 273
92936: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92937: LD_VAR 0 9
92941: PPUSH
92942: LD_VAR 0 10
92946: PPUSH
92947: CALL_OW 488
92951: PUSH
92952: LD_VAR 0 9
92956: PUSH
92957: LD_VAR 0 10
92961: PUSH
92962: EMPTY
92963: LIST
92964: LIST
92965: PUSH
92966: LD_VAR 0 7
92970: IN
92971: NOT
92972: AND
92973: PUSH
92974: LD_VAR 0 9
92978: PPUSH
92979: LD_VAR 0 10
92983: PPUSH
92984: CALL_OW 458
92988: NOT
92989: AND
92990: IFFALSE 93032
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92992: LD_ADDR_VAR 0 7
92996: PUSH
92997: LD_VAR 0 7
93001: PPUSH
93002: LD_VAR 0 7
93006: PUSH
93007: LD_INT 1
93009: PLUS
93010: PPUSH
93011: LD_VAR 0 9
93015: PUSH
93016: LD_VAR 0 10
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PPUSH
93025: CALL_OW 1
93029: ST_TO_ADDR
93030: GO 93046
// i := i - 1 ;
93032: LD_ADDR_VAR 0 5
93036: PUSH
93037: LD_VAR 0 5
93041: PUSH
93042: LD_INT 1
93044: MINUS
93045: ST_TO_ADDR
// end ;
93046: GO 92852
93048: POP
93049: POP
// for i in tmp do
93050: LD_ADDR_VAR 0 5
93054: PUSH
93055: LD_VAR 0 7
93059: PUSH
93060: FOR_IN
93061: IFFALSE 93099
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93063: LD_VAR 0 1
93067: PPUSH
93068: LD_VAR 0 5
93072: PUSH
93073: LD_INT 1
93075: ARRAY
93076: PPUSH
93077: LD_VAR 0 5
93081: PUSH
93082: LD_INT 2
93084: ARRAY
93085: PPUSH
93086: CALL 92045 0 3
93090: NOT
93091: IFFALSE 93097
// exit ;
93093: POP
93094: POP
93095: GO 93101
93097: GO 93060
93099: POP
93100: POP
// end ;
93101: LD_VAR 0 4
93105: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93106: LD_INT 0
93108: PPUSH
93109: PPUSH
93110: PPUSH
93111: PPUSH
93112: PPUSH
93113: PPUSH
93114: PPUSH
// if not GetClass ( unit ) = class_sniper then
93115: LD_VAR 0 1
93119: PPUSH
93120: CALL_OW 257
93124: PUSH
93125: LD_INT 5
93127: EQUAL
93128: NOT
93129: IFFALSE 93133
// exit ;
93131: GO 93521
// dist := 8 ;
93133: LD_ADDR_VAR 0 5
93137: PUSH
93138: LD_INT 8
93140: ST_TO_ADDR
// viewRange := 12 ;
93141: LD_ADDR_VAR 0 7
93145: PUSH
93146: LD_INT 12
93148: ST_TO_ADDR
// side := GetSide ( unit ) ;
93149: LD_ADDR_VAR 0 6
93153: PUSH
93154: LD_VAR 0 1
93158: PPUSH
93159: CALL_OW 255
93163: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93164: LD_INT 61
93166: PPUSH
93167: LD_VAR 0 6
93171: PPUSH
93172: CALL_OW 321
93176: PUSH
93177: LD_INT 2
93179: EQUAL
93180: IFFALSE 93190
// viewRange := 16 ;
93182: LD_ADDR_VAR 0 7
93186: PUSH
93187: LD_INT 16
93189: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93190: LD_VAR 0 1
93194: PPUSH
93195: LD_VAR 0 2
93199: PPUSH
93200: LD_VAR 0 3
93204: PPUSH
93205: CALL_OW 297
93209: PUSH
93210: LD_VAR 0 5
93214: GREATER
93215: IFFALSE 93294
// begin ComMoveXY ( unit , x , y ) ;
93217: LD_VAR 0 1
93221: PPUSH
93222: LD_VAR 0 2
93226: PPUSH
93227: LD_VAR 0 3
93231: PPUSH
93232: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93236: LD_INT 35
93238: PPUSH
93239: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93243: LD_VAR 0 1
93247: PPUSH
93248: LD_VAR 0 2
93252: PPUSH
93253: LD_VAR 0 3
93257: PPUSH
93258: CALL 46128 0 3
93262: NOT
93263: IFFALSE 93267
// exit ;
93265: GO 93521
// until GetDistUnitXY ( unit , x , y ) < dist ;
93267: LD_VAR 0 1
93271: PPUSH
93272: LD_VAR 0 2
93276: PPUSH
93277: LD_VAR 0 3
93281: PPUSH
93282: CALL_OW 297
93286: PUSH
93287: LD_VAR 0 5
93291: LESS
93292: IFFALSE 93236
// end ; ComTurnXY ( unit , x , y ) ;
93294: LD_VAR 0 1
93298: PPUSH
93299: LD_VAR 0 2
93303: PPUSH
93304: LD_VAR 0 3
93308: PPUSH
93309: CALL_OW 118
// wait ( 5 ) ;
93313: LD_INT 5
93315: PPUSH
93316: CALL_OW 67
// _d := GetDir ( unit ) ;
93320: LD_ADDR_VAR 0 10
93324: PUSH
93325: LD_VAR 0 1
93329: PPUSH
93330: CALL_OW 254
93334: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93335: LD_ADDR_VAR 0 8
93339: PUSH
93340: LD_VAR 0 1
93344: PPUSH
93345: CALL_OW 250
93349: PPUSH
93350: LD_VAR 0 10
93354: PPUSH
93355: LD_VAR 0 5
93359: PPUSH
93360: CALL_OW 272
93364: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93365: LD_ADDR_VAR 0 9
93369: PUSH
93370: LD_VAR 0 1
93374: PPUSH
93375: CALL_OW 251
93379: PPUSH
93380: LD_VAR 0 10
93384: PPUSH
93385: LD_VAR 0 5
93389: PPUSH
93390: CALL_OW 273
93394: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93395: LD_VAR 0 8
93399: PPUSH
93400: LD_VAR 0 9
93404: PPUSH
93405: CALL_OW 488
93409: NOT
93410: IFFALSE 93414
// exit ;
93412: GO 93521
// ComAnimCustom ( unit , 1 ) ;
93414: LD_VAR 0 1
93418: PPUSH
93419: LD_INT 1
93421: PPUSH
93422: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93426: LD_VAR 0 8
93430: PPUSH
93431: LD_VAR 0 9
93435: PPUSH
93436: LD_VAR 0 6
93440: PPUSH
93441: LD_VAR 0 7
93445: PPUSH
93446: CALL_OW 330
// repeat wait ( 1 ) ;
93450: LD_INT 1
93452: PPUSH
93453: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93457: LD_VAR 0 1
93461: PPUSH
93462: CALL_OW 316
93466: PUSH
93467: LD_VAR 0 1
93471: PPUSH
93472: CALL_OW 314
93476: OR
93477: PUSH
93478: LD_VAR 0 1
93482: PPUSH
93483: CALL_OW 302
93487: NOT
93488: OR
93489: PUSH
93490: LD_VAR 0 1
93494: PPUSH
93495: CALL_OW 301
93499: OR
93500: IFFALSE 93450
// RemoveSeeing ( _x , _y , side ) ;
93502: LD_VAR 0 8
93506: PPUSH
93507: LD_VAR 0 9
93511: PPUSH
93512: LD_VAR 0 6
93516: PPUSH
93517: CALL_OW 331
// end ; end_of_file
93521: LD_VAR 0 4
93525: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93526: LD_VAR 0 1
93530: PUSH
93531: LD_INT 200
93533: DOUBLE
93534: GREATEREQUAL
93535: IFFALSE 93543
93537: LD_INT 299
93539: DOUBLE
93540: LESSEQUAL
93541: IFTRUE 93545
93543: GO 93577
93545: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93546: LD_VAR 0 1
93550: PPUSH
93551: LD_VAR 0 2
93555: PPUSH
93556: LD_VAR 0 3
93560: PPUSH
93561: LD_VAR 0 4
93565: PPUSH
93566: LD_VAR 0 5
93570: PPUSH
93571: CALL 89613 0 5
93575: GO 93654
93577: LD_INT 300
93579: DOUBLE
93580: GREATEREQUAL
93581: IFFALSE 93589
93583: LD_INT 399
93585: DOUBLE
93586: LESSEQUAL
93587: IFTRUE 93591
93589: GO 93653
93591: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93592: LD_VAR 0 1
93596: PPUSH
93597: LD_VAR 0 2
93601: PPUSH
93602: LD_VAR 0 3
93606: PPUSH
93607: LD_VAR 0 4
93611: PPUSH
93612: LD_VAR 0 5
93616: PPUSH
93617: LD_VAR 0 6
93621: PPUSH
93622: LD_VAR 0 7
93626: PPUSH
93627: LD_VAR 0 8
93631: PPUSH
93632: LD_VAR 0 9
93636: PPUSH
93637: LD_VAR 0 10
93641: PPUSH
93642: LD_VAR 0 11
93646: PPUSH
93647: NOP4
93651: GO 93654
93653: POP
// end ;
93654: PPOPN 11
93656: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93657: LD_VAR 0 1
93661: PPUSH
93662: LD_VAR 0 2
93666: PPUSH
93667: LD_VAR 0 3
93671: PPUSH
93672: LD_VAR 0 4
93676: PPUSH
93677: LD_VAR 0 5
93681: PPUSH
93682: CALL 89349 0 5
// end ;
93686: PPOPN 5
93688: END
