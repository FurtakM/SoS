// starting var tab ; begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitHc ;
   8: CALL_OW 19
// InitUc ;
  12: CALL_OW 18
// InitBc ;
  16: CALL_OW 21
// InitVariables ;
  20: CALL 318 0 0
// InitMultiplayer ;
  24: CALL 579 0 0
// InitMacro ;
  28: CALL 47008 0 0
// if debug then
  32: LD_EXP 1
  36: IFFALSE 45
// FogOff ( 1 ) ;
  38: LD_INT 1
  40: PPUSH
  41: CALL_OW 344
// PrepareNature ( 3 , 3 , 9 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  45: LD_INT 3
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 9
  53: PPUSH
  54: LD_INT 2
  56: PPUSH
  57: LD_INT 2
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 5
  65: PPUSH
  66: LD_INT 18
  68: PPUSH
  69: LD_INT 19
  71: PPUSH
  72: CALL 42419 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  76: LD_INT 2
  78: PPUSH
  79: CALL 1803 0 1
  83: PPUSH
  84: CALL 5771 0 1
// Multiplayer_Start ;
  88: CALL 3680 0 0
// MC_Start ( ) ;
  92: CALL 49120 0 0
// Multiplayer_End ;
  96: CALL 3804 0 0
// end ;
 100: END
// export function CustomInitMacro ; var i ; begin
 101: LD_INT 0
 103: PPUSH
 104: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 105: LD_INT 1
 107: PPUSH
 108: LD_INT 8
 110: PUSH
 111: LD_INT 10
 113: PUSH
 114: LD_INT 12
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: LIST
 121: PUSH
 122: LD_OWVAR 67
 126: ARRAY
 127: PPUSH
 128: LD_INT 3
 130: PPUSH
 131: CALL 70369 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 135: LD_INT 2
 137: PPUSH
 138: LD_INT 6
 140: PUSH
 141: LD_INT 8
 143: PUSH
 144: LD_INT 9
 146: PUSH
 147: EMPTY
 148: LIST
 149: LIST
 150: LIST
 151: PUSH
 152: LD_OWVAR 67
 156: ARRAY
 157: PPUSH
 158: LD_INT 2
 160: PPUSH
 161: CALL 70369 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 165: LD_INT 3
 167: PPUSH
 168: LD_INT 6
 170: PUSH
 171: LD_INT 7
 173: PUSH
 174: LD_INT 9
 176: PUSH
 177: EMPTY
 178: LIST
 179: LIST
 180: LIST
 181: PUSH
 182: LD_OWVAR 67
 186: ARRAY
 187: PPUSH
 188: LD_INT 1
 190: PPUSH
 191: CALL 70369 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 195: LD_INT 4
 197: PPUSH
 198: LD_INT 6
 200: PUSH
 201: LD_INT 7
 203: PUSH
 204: LD_INT 9
 206: PUSH
 207: EMPTY
 208: LIST
 209: LIST
 210: LIST
 211: PUSH
 212: LD_OWVAR 67
 216: ARRAY
 217: PPUSH
 218: LD_INT 25
 220: PPUSH
 221: CALL 70369 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south ] ;
 225: LD_ADDR_EXP 66
 229: PUSH
 230: LD_INT 20
 232: PUSH
 233: LD_INT 21
 235: PUSH
 236: LD_INT 22
 238: PUSH
 239: LD_INT 24
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: LIST
 247: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south ] ;
 248: LD_ADDR_EXP 67
 252: PUSH
 253: LD_INT 35
 255: PUSH
 256: LD_INT 34
 258: PUSH
 259: LD_INT 36
 261: PUSH
 262: LD_INT 33
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: LIST
 269: LIST
 270: ST_TO_ADDR
// for i = 1 to mc_bases do
 271: LD_ADDR_VAR 0 2
 275: PUSH
 276: DOUBLE
 277: LD_INT 1
 279: DEC
 280: ST_TO_ADDR
 281: LD_EXP 42
 285: PUSH
 286: FOR_TO
 287: IFFALSE 311
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 289: LD_VAR 0 2
 293: PPUSH
 294: LD_EXP 37
 298: PUSH
 299: LD_VAR 0 2
 303: ARRAY
 304: PPUSH
 305: CALL 70795 0 2
 309: GO 286
 311: POP
 312: POP
// end ;
 313: LD_VAR 0 1
 317: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 318: LD_INT 0
 320: PPUSH
// debug := false ;
 321: LD_ADDR_EXP 1
 325: PUSH
 326: LD_INT 0
 328: ST_TO_ADDR
// side_bot := 2 ;
 329: LD_ADDR_EXP 3
 333: PUSH
 334: LD_INT 2
 336: ST_TO_ADDR
// artifact_get := false ;
 337: LD_ADDR_EXP 4
 341: PUSH
 342: LD_INT 0
 344: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 345: LD_ADDR_EXP 5
 349: PUSH
 350: LD_STRING base_a
 352: PUSH
 353: LD_STRING base_b
 355: PUSH
 356: LD_STRING base_c
 358: PUSH
 359: LD_STRING base_d
 361: PUSH
 362: LD_STRING base_e
 364: PUSH
 365: LD_STRING base_f
 367: PUSH
 368: LD_STRING base_g
 370: PUSH
 371: LD_STRING base_h
 373: PUSH
 374: LD_STRING base_i
 376: PUSH
 377: LD_STRING base_j
 379: PUSH
 380: LD_STRING base_k
 382: PUSH
 383: LD_STRING base_l
 385: PUSH
 386: LD_STRING base_m
 388: PUSH
 389: LD_STRING base_n
 391: PUSH
 392: LD_STRING base_o
 394: PUSH
 395: LD_STRING base_p
 397: PUSH
 398: LD_STRING base_r
 400: PUSH
 401: LD_STRING base_s
 403: PUSH
 404: LD_STRING base_t
 406: PUSH
 407: LD_STRING base_u
 409: PUSH
 410: LD_STRING base_w
 412: PUSH
 413: LD_STRING base_x
 415: PUSH
 416: LD_STRING base_y
 418: PUSH
 419: LD_STRING base_z
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// end ;
 448: LD_VAR 0 1
 452: RET
// every 0 0$01 trigger game and not debug_strings do
 453: LD_EXP 2
 457: PUSH
 458: LD_OWVAR 48
 462: NOT
 463: AND
 464: IFFALSE 480
 466: GO 468
 468: DISABLE
// begin enable ;
 469: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 470: LD_ADDR_OWVAR 47
 474: PUSH
 475: CALL 4505 0 0
 479: ST_TO_ADDR
// end ;
 480: END
// function Debuger ; var i ; begin
 481: LD_INT 0
 483: PPUSH
 484: PPUSH
// if not debug then
 485: LD_EXP 1
 489: NOT
 490: IFFALSE 494
// exit ;
 492: GO 566
// game_speed := 5 ;
 494: LD_ADDR_OWVAR 65
 498: PUSH
 499: LD_INT 5
 501: ST_TO_ADDR
// uc_side := 1 ;
 502: LD_ADDR_OWVAR 20
 506: PUSH
 507: LD_INT 1
 509: ST_TO_ADDR
// uc_nation := 1 ;
 510: LD_ADDR_OWVAR 21
 514: PUSH
 515: LD_INT 1
 517: ST_TO_ADDR
// for i = 1 to 10 do
 518: LD_ADDR_VAR 0 2
 522: PUSH
 523: DOUBLE
 524: LD_INT 1
 526: DEC
 527: ST_TO_ADDR
 528: LD_INT 10
 530: PUSH
 531: FOR_TO
 532: IFFALSE 564
// begin PrepareHuman ( false , 1 , 10 ) ;
 534: LD_INT 0
 536: PPUSH
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 10
 542: PPUSH
 543: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 547: CALL_OW 44
 551: PPUSH
 552: LD_INT 9
 554: PPUSH
 555: LD_INT 0
 557: PPUSH
 558: CALL_OW 49
// end ;
 562: GO 531
 564: POP
 565: POP
// end ;
 566: LD_VAR 0 1
 570: RET
// export function CustomEvent ( event ) ; begin
 571: LD_INT 0
 573: PPUSH
// end ; end_of_file
 574: LD_VAR 0 2
 578: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 579: LD_INT 0
 581: PPUSH
 582: PPUSH
 583: PPUSH
 584: PPUSH
 585: PPUSH
// multi_settings_counter := 6 ;
 586: LD_ADDR_EXP 18
 590: PUSH
 591: LD_INT 6
 593: ST_TO_ADDR
// if multiplayer then
 594: LD_OWVAR 4
 598: IFFALSE 722
// begin your_side := mp_player_side ;
 600: LD_ADDR_OWVAR 2
 604: PUSH
 605: LD_OWVAR 7
 609: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 610: LD_ADDR_EXP 6
 614: PUSH
 615: LD_OWVAR 6
 619: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 620: LD_ADDR_EXP 7
 624: PUSH
 625: LD_OWVAR 17
 629: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 630: LD_ADDR_EXP 8
 634: PUSH
 635: LD_OWVAR 15
 639: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 640: LD_ADDR_EXP 9
 644: PUSH
 645: LD_OWVAR 16
 649: ST_TO_ADDR
// multi_teams := mp_teams ;
 650: LD_ADDR_EXP 10
 654: PUSH
 655: LD_OWVAR 12
 659: ST_TO_ADDR
// for i = 1 to multi_settings_counter do
 660: LD_ADDR_VAR 0 2
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_EXP 18
 674: PUSH
 675: FOR_TO
 676: IFFALSE 718
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 678: LD_ADDR_EXP 17
 682: PUSH
 683: LD_EXP 17
 687: PPUSH
 688: LD_EXP 17
 692: PUSH
 693: LD_INT 1
 695: PLUS
 696: PPUSH
 697: LD_VAR 0 2
 701: PPUSH
 702: CALL_OW 426
 706: PUSH
 707: LD_INT 1
 709: PLUS
 710: PPUSH
 711: CALL_OW 2
 715: ST_TO_ADDR
 716: GO 675
 718: POP
 719: POP
// end else
 720: GO 908
// begin your_side := 1 ;
 722: LD_ADDR_OWVAR 2
 726: PUSH
 727: LD_INT 1
 729: ST_TO_ADDR
// multi_gametype := 1 ;
 730: LD_ADDR_EXP 6
 734: PUSH
 735: LD_INT 1
 737: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 738: LD_ADDR_EXP 7
 742: PUSH
 743: LD_INT 2
 745: PUSH
 746: LD_INT 0
 748: PUSH
 749: LD_INT 0
 751: PUSH
 752: LD_INT 3
 754: PUSH
 755: LD_INT 0
 757: PUSH
 758: LD_INT 0
 760: PUSH
 761: LD_INT 1
 763: PUSH
 764: LD_INT 0
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 777: LD_ADDR_EXP 8
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: LD_INT 0
 787: PUSH
 788: LD_INT 0
 790: PUSH
 791: LD_INT 1
 793: PUSH
 794: LD_INT 0
 796: PUSH
 797: LD_INT 0
 799: PUSH
 800: LD_INT 1
 802: PUSH
 803: LD_INT 0
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: LIST
 814: LIST
 815: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 816: LD_ADDR_EXP 9
 820: PUSH
 821: LD_INT 1
 823: PUSH
 824: LD_INT 0
 826: PUSH
 827: LD_INT 0
 829: PUSH
 830: LD_INT 1
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 1
 841: PUSH
 842: LD_INT 0
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 855: LD_ADDR_EXP 10
 859: PUSH
 860: LD_INT 1
 862: PUSH
 863: LD_INT 4
 865: PUSH
 866: LD_INT 7
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: EMPTY
 875: LIST
 876: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 877: LD_ADDR_EXP 17
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: LD_INT 2
 887: PUSH
 888: LD_INT 1
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 908: LD_ADDR_EXP 11
 912: PUSH
 913: LD_INT 0
 915: PUSH
 916: LD_INT 0
 918: PUSH
 919: LD_INT 0
 921: PUSH
 922: LD_INT 0
 924: PUSH
 925: LD_INT 0
 927: PUSH
 928: LD_INT 0
 930: PUSH
 931: LD_INT 0
 933: PUSH
 934: LD_INT 0
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: LIST
 946: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 947: LD_ADDR_EXP 14
 951: PUSH
 952: LD_INT 0
 954: PUSH
 955: LD_INT 0
 957: PUSH
 958: LD_INT 0
 960: PUSH
 961: LD_INT 0
 963: PUSH
 964: LD_INT 0
 966: PUSH
 967: LD_INT 0
 969: PUSH
 970: LD_INT 0
 972: PUSH
 973: LD_INT 0
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: LIST
 985: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 986: LD_ADDR_EXP 25
 990: PUSH
 991: LD_INT 0
 993: PUSH
 994: LD_INT 0
 996: PUSH
 997: LD_INT 0
 999: PUSH
1000: LD_INT 0
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: ST_TO_ADDR
// multi_teamgame := true ;
1025: LD_ADDR_EXP 15
1029: PUSH
1030: LD_INT 1
1032: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1033: LD_ADDR_EXP 13
1037: PUSH
1038: LD_INT 1
1040: PUSH
1041: EMPTY
1042: LIST
1043: ST_TO_ADDR
// multi_custom_commanders := true ;
1044: LD_ADDR_EXP 16
1048: PUSH
1049: LD_INT 1
1051: ST_TO_ADDR
// multi_commanders := [ ] ;
1052: LD_ADDR_EXP 24
1056: PUSH
1057: EMPTY
1058: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1059: LD_ADDR_EXP 27
1063: PUSH
1064: EMPTY
1065: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1066: LD_ADDR_EXP 28
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// multi_players_amount := 0 ;
1074: LD_ADDR_EXP 26
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1082: LD_ADDR_EXP 12
1086: PUSH
1087: LD_INT 9
1089: PUSH
1090: LD_INT 8
1092: PUSH
1093: EMPTY
1094: LIST
1095: LIST
1096: PUSH
1097: LD_INT 27
1099: PUSH
1100: LD_INT 26
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: PUSH
1107: LD_INT 29
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: PUSH
1117: EMPTY
1118: LIST
1119: LIST
1120: LIST
1121: ST_TO_ADDR
// for i = 1 to 8 do
1122: LD_ADDR_VAR 0 2
1126: PUSH
1127: DOUBLE
1128: LD_INT 1
1130: DEC
1131: ST_TO_ADDR
1132: LD_INT 8
1134: PUSH
1135: FOR_TO
1136: IFFALSE 1465
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1138: LD_VAR 0 2
1142: PPUSH
1143: CALL_OW 530
1147: IFFALSE 1305
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1149: LD_ADDR_EXP 11
1153: PUSH
1154: LD_EXP 11
1158: PPUSH
1159: LD_VAR 0 2
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: CALL_OW 1
1171: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1172: LD_ADDR_EXP 9
1176: PUSH
1177: LD_EXP 9
1181: PPUSH
1182: LD_VAR 0 2
1186: PPUSH
1187: LD_INT 0
1189: PPUSH
1190: CALL_OW 1
1194: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1195: LD_ADDR_EXP 7
1199: PUSH
1200: LD_EXP 7
1204: PPUSH
1205: LD_VAR 0 2
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 1
1217: ST_TO_ADDR
// for j = 1 to multi_teams do
1218: LD_ADDR_VAR 0 3
1222: PUSH
1223: DOUBLE
1224: LD_INT 1
1226: DEC
1227: ST_TO_ADDR
1228: LD_EXP 10
1232: PUSH
1233: FOR_TO
1234: IFFALSE 1303
// begin if i in multi_teams [ j ] then
1236: LD_VAR 0 2
1240: PUSH
1241: LD_EXP 10
1245: PUSH
1246: LD_VAR 0 3
1250: ARRAY
1251: IN
1252: IFFALSE 1301
// begin tmp := multi_teams [ j ] diff i ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: LD_EXP 10
1263: PUSH
1264: LD_VAR 0 3
1268: ARRAY
1269: PUSH
1270: LD_VAR 0 2
1274: DIFF
1275: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1276: LD_ADDR_EXP 10
1280: PUSH
1281: LD_EXP 10
1285: PPUSH
1286: LD_VAR 0 3
1290: PPUSH
1291: LD_VAR 0 5
1295: PPUSH
1296: CALL_OW 1
1300: ST_TO_ADDR
// end ; end ;
1301: GO 1233
1303: POP
1304: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1305: LD_EXP 9
1309: PUSH
1310: LD_VAR 0 2
1314: ARRAY
1315: PUSH
1316: LD_EXP 9
1320: PUSH
1321: LD_VAR 0 2
1325: ARRAY
1326: PUSH
1327: LD_EXP 13
1331: IN
1332: NOT
1333: AND
1334: IFFALSE 1375
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1336: LD_ADDR_EXP 9
1340: PUSH
1341: LD_EXP 9
1345: PPUSH
1346: LD_VAR 0 2
1350: PPUSH
1351: LD_EXP 13
1355: PUSH
1356: LD_INT 1
1358: PPUSH
1359: LD_EXP 13
1363: PPUSH
1364: CALL_OW 12
1368: ARRAY
1369: PPUSH
1370: CALL_OW 1
1374: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1375: LD_EXP 9
1379: PUSH
1380: LD_VAR 0 2
1384: ARRAY
1385: NOT
1386: PUSH
1387: LD_EXP 7
1391: PUSH
1392: LD_VAR 0 2
1396: ARRAY
1397: NOT
1398: AND
1399: PUSH
1400: LD_EXP 11
1404: PUSH
1405: LD_VAR 0 2
1409: ARRAY
1410: NOT
1411: AND
1412: IFFALSE 1437
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1414: LD_ADDR_EXP 14
1418: PUSH
1419: LD_EXP 14
1423: PPUSH
1424: LD_VAR 0 2
1428: PPUSH
1429: LD_INT 1
1431: PPUSH
1432: CALL_OW 1
1436: ST_TO_ADDR
// if multi_sides [ i ] then
1437: LD_EXP 7
1441: PUSH
1442: LD_VAR 0 2
1446: ARRAY
1447: IFFALSE 1463
// multi_players_amount := multi_players_amount + 1 ;
1449: LD_ADDR_EXP 26
1453: PUSH
1454: LD_EXP 26
1458: PUSH
1459: LD_INT 1
1461: PLUS
1462: ST_TO_ADDR
// end ;
1463: GO 1135
1465: POP
1466: POP
// for i in multi_teams do
1467: LD_ADDR_VAR 0 2
1471: PUSH
1472: LD_EXP 10
1476: PUSH
1477: FOR_IN
1478: IFFALSE 1586
// begin for j = 2 to i do
1480: LD_ADDR_VAR 0 3
1484: PUSH
1485: DOUBLE
1486: LD_INT 2
1488: DEC
1489: ST_TO_ADDR
1490: LD_VAR 0 2
1494: PUSH
1495: FOR_TO
1496: IFFALSE 1582
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1498: LD_VAR 0 2
1502: PUSH
1503: LD_VAR 0 3
1507: ARRAY
1508: PPUSH
1509: LD_VAR 0 2
1513: PUSH
1514: LD_INT 1
1516: ARRAY
1517: PPUSH
1518: CALL_OW 343
// for x = 1 to j - 1 do
1522: LD_ADDR_VAR 0 4
1526: PUSH
1527: DOUBLE
1528: LD_INT 1
1530: DEC
1531: ST_TO_ADDR
1532: LD_VAR 0 3
1536: PUSH
1537: LD_INT 1
1539: MINUS
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1578
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1544: LD_VAR 0 2
1548: PUSH
1549: LD_VAR 0 3
1553: ARRAY
1554: PPUSH
1555: LD_VAR 0 2
1559: PUSH
1560: LD_VAR 0 4
1564: ARRAY
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 1
1571: PPUSH
1572: CALL_OW 80
1576: GO 1541
1578: POP
1579: POP
// end ;
1580: GO 1495
1582: POP
1583: POP
// end ;
1584: GO 1477
1586: POP
1587: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1588: LD_ADDR_OWVAR 67
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: LD_INT 2
1598: PUSH
1599: LD_INT 3
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: LIST
1606: PUSH
1607: LD_EXP 17
1611: PUSH
1612: LD_INT 1
1614: ARRAY
1615: ARRAY
1616: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1617: LD_ADDR_EXP 19
1621: PUSH
1622: LD_INT 9
1624: PUSH
1625: LD_INT 12
1627: PUSH
1628: LD_INT 15
1630: PUSH
1631: LD_INT 18
1633: PUSH
1634: EMPTY
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: PUSH
1640: LD_EXP 17
1644: PUSH
1645: LD_INT 2
1647: ARRAY
1648: ARRAY
1649: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1650: LD_ADDR_EXP 20
1654: PUSH
1655: LD_INT 5
1657: PUSH
1658: LD_INT 7
1660: PUSH
1661: LD_INT 9
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: LD_EXP 17
1673: PUSH
1674: LD_INT 3
1676: ARRAY
1677: ARRAY
1678: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1679: LD_ADDR_EXP 21
1683: PUSH
1684: LD_INT 6000
1686: PUSH
1687: LD_INT 1575
1689: PUSH
1690: EMPTY
1691: LIST
1692: LIST
1693: PUSH
1694: LD_INT 8000
1696: PUSH
1697: LD_INT 1260
1699: PUSH
1700: EMPTY
1701: LIST
1702: LIST
1703: PUSH
1704: LD_INT 10000
1706: PUSH
1707: LD_INT 770
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: PUSH
1714: LD_INT 15000
1716: PUSH
1717: LD_INT 770
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 4
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1740: LD_ADDR_EXP 22
1744: PUSH
1745: LD_INT 6
1747: PUSH
1748: LD_INT 8
1750: PUSH
1751: LD_INT 10
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 5
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1769: LD_ADDR_EXP 23
1773: PUSH
1774: LD_INT 0
1776: PUSH
1777: LD_INT 1
1779: PUSH
1780: LD_INT 2
1782: PUSH
1783: EMPTY
1784: LIST
1785: LIST
1786: LIST
1787: PUSH
1788: LD_EXP 17
1792: PUSH
1793: LD_INT 6
1795: ARRAY
1796: ARRAY
1797: ST_TO_ADDR
// end ;
1798: LD_VAR 0 1
1802: RET
// export function Multiplayer_SetBotSide ( prefer_side ) ; var i ; begin
1803: LD_INT 0
1805: PPUSH
1806: PPUSH
// ResetFog ;
1807: CALL_OW 335
// if not multi_bots then
1811: LD_EXP 14
1815: NOT
1816: IFFALSE 1820
// exit ;
1818: GO 1892
// if multi_bots [ prefer_side ] then
1820: LD_EXP 14
1824: PUSH
1825: LD_VAR 0 1
1829: ARRAY
1830: IFFALSE 1844
// begin result := prefer_side ;
1832: LD_ADDR_VAR 0 2
1836: PUSH
1837: LD_VAR 0 1
1841: ST_TO_ADDR
// exit ;
1842: GO 1892
// end ; for i = 1 to multi_bots do
1844: LD_ADDR_VAR 0 3
1848: PUSH
1849: DOUBLE
1850: LD_INT 1
1852: DEC
1853: ST_TO_ADDR
1854: LD_EXP 14
1858: PUSH
1859: FOR_TO
1860: IFFALSE 1890
// if multi_bots [ i ] then
1862: LD_EXP 14
1866: PUSH
1867: LD_VAR 0 3
1871: ARRAY
1872: IFFALSE 1888
// begin result := i ;
1874: LD_ADDR_VAR 0 2
1878: PUSH
1879: LD_VAR 0 3
1883: ST_TO_ADDR
// exit ;
1884: POP
1885: POP
1886: GO 1892
// end ;
1888: GO 1859
1890: POP
1891: POP
// end ;
1892: LD_VAR 0 2
1896: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1897: LD_INT 0
1899: PPUSH
// uc_side := side ;
1900: LD_ADDR_OWVAR 20
1904: PUSH
1905: LD_VAR 0 1
1909: ST_TO_ADDR
// uc_nation := 1 ;
1910: LD_ADDR_OWVAR 21
1914: PUSH
1915: LD_INT 1
1917: ST_TO_ADDR
// hc_importance := 100 ;
1918: LD_ADDR_OWVAR 32
1922: PUSH
1923: LD_INT 100
1925: ST_TO_ADDR
// hc_class := 1 ;
1926: LD_ADDR_OWVAR 28
1930: PUSH
1931: LD_INT 1
1933: ST_TO_ADDR
// if num = 1 then
1934: LD_VAR 0 2
1938: PUSH
1939: LD_INT 1
1941: EQUAL
1942: IFFALSE 2024
// begin hc_gallery := us ;
1944: LD_ADDR_OWVAR 33
1948: PUSH
1949: LD_STRING us
1951: ST_TO_ADDR
// hc_face_number := 5 ;
1952: LD_ADDR_OWVAR 34
1956: PUSH
1957: LD_INT 5
1959: ST_TO_ADDR
// hc_name := John Macmilan ;
1960: LD_ADDR_OWVAR 26
1964: PUSH
1965: LD_STRING John Macmilan
1967: ST_TO_ADDR
// hc_sex := sex_male ;
1968: LD_ADDR_OWVAR 27
1972: PUSH
1973: LD_INT 1
1975: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
1976: LD_ADDR_OWVAR 31
1980: PUSH
1981: LD_INT 7
1983: PUSH
1984: LD_INT 2
1986: PUSH
1987: LD_INT 4
1989: PUSH
1990: LD_INT 4
1992: PUSH
1993: EMPTY
1994: LIST
1995: LIST
1996: LIST
1997: LIST
1998: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
1999: LD_ADDR_OWVAR 29
2003: PUSH
2004: LD_INT 11
2006: PUSH
2007: LD_INT 10
2009: PUSH
2010: EMPTY
2011: LIST
2012: LIST
2013: ST_TO_ADDR
// result := CreateHuman ;
2014: LD_ADDR_VAR 0 3
2018: PUSH
2019: CALL_OW 44
2023: ST_TO_ADDR
// end ; if num = 2 then
2024: LD_VAR 0 2
2028: PUSH
2029: LD_INT 2
2031: EQUAL
2032: IFFALSE 2114
// begin hc_gallery := us ;
2034: LD_ADDR_OWVAR 33
2038: PUSH
2039: LD_STRING us
2041: ST_TO_ADDR
// hc_face_number := 2 ;
2042: LD_ADDR_OWVAR 34
2046: PUSH
2047: LD_INT 2
2049: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2050: LD_ADDR_OWVAR 26
2054: PUSH
2055: LD_STRING Lucy Donaldson
2057: ST_TO_ADDR
// hc_sex := sex_female ;
2058: LD_ADDR_OWVAR 27
2062: PUSH
2063: LD_INT 2
2065: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2066: LD_ADDR_OWVAR 31
2070: PUSH
2071: LD_INT 6
2073: PUSH
2074: LD_INT 3
2076: PUSH
2077: LD_INT 4
2079: PUSH
2080: LD_INT 3
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: LIST
2087: LIST
2088: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2089: LD_ADDR_OWVAR 29
2093: PUSH
2094: LD_INT 9
2096: PUSH
2097: LD_INT 12
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: ST_TO_ADDR
// result := CreateHuman ;
2104: LD_ADDR_VAR 0 3
2108: PUSH
2109: CALL_OW 44
2113: ST_TO_ADDR
// end ; if num = 3 then
2114: LD_VAR 0 2
2118: PUSH
2119: LD_INT 3
2121: EQUAL
2122: IFFALSE 2204
// begin hc_gallery := us ;
2124: LD_ADDR_OWVAR 33
2128: PUSH
2129: LD_STRING us
2131: ST_TO_ADDR
// hc_face_number := 16 ;
2132: LD_ADDR_OWVAR 34
2136: PUSH
2137: LD_INT 16
2139: ST_TO_ADDR
// hc_name := Peter van Houten ;
2140: LD_ADDR_OWVAR 26
2144: PUSH
2145: LD_STRING Peter van Houten
2147: ST_TO_ADDR
// hc_sex := sex_male ;
2148: LD_ADDR_OWVAR 27
2152: PUSH
2153: LD_INT 1
2155: ST_TO_ADDR
// hc_skills := [ 8 , 1 , 3 , 2 ] ;
2156: LD_ADDR_OWVAR 31
2160: PUSH
2161: LD_INT 8
2163: PUSH
2164: LD_INT 1
2166: PUSH
2167: LD_INT 3
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2179: LD_ADDR_OWVAR 29
2183: PUSH
2184: LD_INT 10
2186: PUSH
2187: LD_INT 11
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: ST_TO_ADDR
// result := CreateHuman ;
2194: LD_ADDR_VAR 0 3
2198: PUSH
2199: CALL_OW 44
2203: ST_TO_ADDR
// end ; end ;
2204: LD_VAR 0 3
2208: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2209: LD_INT 0
2211: PPUSH
2212: PPUSH
2213: PPUSH
2214: PPUSH
2215: PPUSH
2216: PPUSH
2217: PPUSH
2218: PPUSH
2219: PPUSH
// for i = 1 to 8 do
2220: LD_ADDR_VAR 0 2
2224: PUSH
2225: DOUBLE
2226: LD_INT 1
2228: DEC
2229: ST_TO_ADDR
2230: LD_INT 8
2232: PUSH
2233: FOR_TO
2234: IFFALSE 3124
// begin if not multi_sides [ i ] then
2236: LD_EXP 7
2240: PUSH
2241: LD_VAR 0 2
2245: ARRAY
2246: NOT
2247: IFFALSE 2251
// continue ;
2249: GO 2233
// if multi_custom_commanders then
2251: LD_EXP 16
2255: IFFALSE 2347
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2257: LD_ADDR_VAR 0 5
2261: PUSH
2262: LD_VAR 0 2
2266: PPUSH
2267: LD_EXP 7
2271: PUSH
2272: LD_VAR 0 2
2276: ARRAY
2277: PPUSH
2278: CALL 1897 0 2
2282: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2283: LD_ADDR_EXP 24
2287: PUSH
2288: LD_EXP 24
2292: PPUSH
2293: LD_EXP 24
2297: PUSH
2298: LD_INT 1
2300: PLUS
2301: PPUSH
2302: LD_VAR 0 5
2306: PPUSH
2307: CALL_OW 2
2311: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2312: LD_VAR 0 5
2316: PPUSH
2317: LD_EXP 12
2321: PUSH
2322: LD_EXP 7
2326: PUSH
2327: LD_VAR 0 2
2331: ARRAY
2332: ARRAY
2333: PUSH
2334: LD_INT 1
2336: ARRAY
2337: PPUSH
2338: LD_INT 0
2340: PPUSH
2341: CALL_OW 49
// end else
2345: GO 2558
// begin uc_side := i ;
2347: LD_ADDR_OWVAR 20
2351: PUSH
2352: LD_VAR 0 2
2356: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2357: LD_ADDR_OWVAR 21
2361: PUSH
2362: LD_EXP 9
2366: PUSH
2367: LD_VAR 0 2
2371: ARRAY
2372: ST_TO_ADDR
// hc_importance := 100 ;
2373: LD_ADDR_OWVAR 32
2377: PUSH
2378: LD_INT 100
2380: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2381: LD_INT 0
2383: PPUSH
2384: LD_INT 1
2386: PPUSH
2387: LD_EXP 20
2391: PPUSH
2392: CALL_OW 380
// if multiplayer then
2396: LD_OWVAR 4
2400: IFFALSE 2458
// begin hc_name := mp_sides_players_names [ i ] ;
2402: LD_ADDR_OWVAR 26
2406: PUSH
2407: LD_OWVAR 19
2411: PUSH
2412: LD_VAR 0 2
2416: ARRAY
2417: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2418: LD_ADDR_OWVAR 33
2422: PUSH
2423: LD_STRING MULTIAVATARS
2425: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2426: LD_ADDR_OWVAR 34
2430: PUSH
2431: LD_VAR 0 2
2435: PPUSH
2436: CALL_OW 525
2440: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2441: LD_ADDR_OWVAR 27
2445: PUSH
2446: LD_VAR 0 2
2450: PPUSH
2451: CALL_OW 526
2455: ST_TO_ADDR
// end else
2456: GO 2490
// begin hc_gallery :=  ;
2458: LD_ADDR_OWVAR 33
2462: PUSH
2463: LD_STRING 
2465: ST_TO_ADDR
// hc_name :=  ;
2466: LD_ADDR_OWVAR 26
2470: PUSH
2471: LD_STRING 
2473: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2474: LD_ADDR_OWVAR 27
2478: PUSH
2479: LD_INT 1
2481: PPUSH
2482: LD_INT 2
2484: PPUSH
2485: CALL_OW 12
2489: ST_TO_ADDR
// end ; un := CreateHuman ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: CALL_OW 44
2499: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2500: LD_VAR 0 5
2504: PPUSH
2505: LD_EXP 12
2509: PUSH
2510: LD_EXP 7
2514: PUSH
2515: LD_VAR 0 2
2519: ARRAY
2520: ARRAY
2521: PUSH
2522: LD_INT 1
2524: ARRAY
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2533: LD_ADDR_EXP 24
2537: PUSH
2538: LD_EXP 24
2542: PPUSH
2543: LD_VAR 0 2
2547: PPUSH
2548: LD_VAR 0 5
2552: PPUSH
2553: CALL_OW 1
2557: ST_TO_ADDR
// end ; InitHc ;
2558: CALL_OW 19
// InitUc ;
2562: CALL_OW 18
// uc_side := i ;
2566: LD_ADDR_OWVAR 20
2570: PUSH
2571: LD_VAR 0 2
2575: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2576: LD_ADDR_OWVAR 21
2580: PUSH
2581: LD_EXP 9
2585: PUSH
2586: LD_VAR 0 2
2590: ARRAY
2591: ST_TO_ADDR
// hc_gallery :=  ;
2592: LD_ADDR_OWVAR 33
2596: PUSH
2597: LD_STRING 
2599: ST_TO_ADDR
// hc_name :=  ;
2600: LD_ADDR_OWVAR 26
2604: PUSH
2605: LD_STRING 
2607: ST_TO_ADDR
// hc_importance := 0 ;
2608: LD_ADDR_OWVAR 32
2612: PUSH
2613: LD_INT 0
2615: ST_TO_ADDR
// cl := 1 ;
2616: LD_ADDR_VAR 0 4
2620: PUSH
2621: LD_INT 1
2623: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: DOUBLE
2630: LD_INT 2
2632: DEC
2633: ST_TO_ADDR
2634: LD_EXP 19
2638: PUSH
2639: FOR_TO
2640: IFFALSE 3012
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2642: LD_VAR 0 3
2646: PUSH
2647: LD_INT 1
2649: MINUS
2650: PUSH
2651: LD_EXP 19
2655: PUSH
2656: LD_INT 1
2658: MINUS
2659: PUSH
2660: LD_INT 4
2662: DIVREAL
2663: MOD
2664: PUSH
2665: LD_INT 0
2667: EQUAL
2668: IFFALSE 2684
// cl := cl + 1 ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: LD_VAR 0 4
2679: PUSH
2680: LD_INT 1
2682: PLUS
2683: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2684: LD_INT 0
2686: PPUSH
2687: LD_VAR 0 4
2691: PPUSH
2692: LD_EXP 20
2696: PPUSH
2697: CALL_OW 380
// un := CreateHuman ;
2701: LD_ADDR_VAR 0 5
2705: PUSH
2706: CALL_OW 44
2710: ST_TO_ADDR
// if j > copy then
2711: LD_VAR 0 3
2715: PUSH
2716: LD_VAR 0 8
2720: GREATER
2721: IFFALSE 2750
// copy := Replace ( copy , j , un ) else
2723: LD_ADDR_VAR 0 8
2727: PUSH
2728: LD_VAR 0 8
2732: PPUSH
2733: LD_VAR 0 3
2737: PPUSH
2738: LD_VAR 0 5
2742: PPUSH
2743: CALL_OW 1
2747: ST_TO_ADDR
2748: GO 2832
// begin CopySkills ( copy [ j ] , un ) ;
2750: LD_VAR 0 8
2754: PUSH
2755: LD_VAR 0 3
2759: ARRAY
2760: PPUSH
2761: LD_VAR 0 5
2765: PPUSH
2766: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2770: LD_VAR 0 5
2774: PPUSH
2775: LD_INT 2
2777: PPUSH
2778: LD_VAR 0 8
2782: PUSH
2783: LD_VAR 0 3
2787: ARRAY
2788: PPUSH
2789: LD_INT 2
2791: PPUSH
2792: CALL_OW 260
2796: PPUSH
2797: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2801: LD_VAR 0 5
2805: PPUSH
2806: LD_INT 1
2808: PPUSH
2809: LD_VAR 0 8
2813: PUSH
2814: LD_VAR 0 3
2818: ARRAY
2819: PPUSH
2820: LD_INT 1
2822: PPUSH
2823: CALL_OW 260
2827: PPUSH
2828: CALL_OW 239
// end ; if multi_pos_area then
2832: LD_EXP 12
2836: IFFALSE 3010
// begin if GetClass ( un ) = 3 then
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 257
2847: PUSH
2848: LD_INT 3
2850: EQUAL
2851: IFFALSE 2977
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2853: LD_INT 3
2855: PUSH
2856: LD_INT 2
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: PUSH
2863: LD_VAR 0 3
2867: PUSH
2868: LD_INT 2
2870: MOD
2871: PUSH
2872: LD_INT 1
2874: PLUS
2875: ARRAY
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: LD_INT 1
2882: PPUSH
2883: LD_INT 5
2885: PUSH
2886: LD_INT 4
2888: PUSH
2889: LD_INT 3
2891: PUSH
2892: EMPTY
2893: LIST
2894: LIST
2895: LIST
2896: PUSH
2897: LD_VAR 0 3
2901: PUSH
2902: LD_INT 3
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: ARRAY
2910: PPUSH
2911: LD_INT 100
2913: PPUSH
2914: CALL 14628 0 5
// veh := CreateVehicle ;
2918: LD_ADDR_VAR 0 6
2922: PUSH
2923: CALL_OW 45
2927: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2928: LD_VAR 0 6
2932: PPUSH
2933: LD_EXP 12
2937: PUSH
2938: LD_EXP 7
2942: PUSH
2943: LD_VAR 0 2
2947: ARRAY
2948: ARRAY
2949: PUSH
2950: LD_INT 2
2952: ARRAY
2953: PPUSH
2954: LD_INT 0
2956: PPUSH
2957: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
2961: LD_VAR 0 5
2965: PPUSH
2966: LD_VAR 0 6
2970: PPUSH
2971: CALL_OW 52
// continue ;
2975: GO 2639
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2977: LD_VAR 0 5
2981: PPUSH
2982: LD_EXP 12
2986: PUSH
2987: LD_EXP 7
2991: PUSH
2992: LD_VAR 0 2
2996: ARRAY
2997: ARRAY
2998: PUSH
2999: LD_INT 1
3001: ARRAY
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 49
// end ; end ;
3010: GO 2639
3012: POP
3013: POP
// for j = 1 to 3 do
3014: LD_ADDR_VAR 0 3
3018: PUSH
3019: DOUBLE
3020: LD_INT 1
3022: DEC
3023: ST_TO_ADDR
3024: LD_INT 3
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3120
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3030: LD_INT 2
3032: PUSH
3033: LD_INT 3
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PUSH
3040: LD_INT 1
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: CALL_OW 12
3050: ARRAY
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: LD_INT 3
3057: PPUSH
3058: LD_INT 11
3060: PUSH
3061: LD_INT 7
3063: PUSH
3064: LD_INT 4
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: PUSH
3072: LD_VAR 0 3
3076: ARRAY
3077: PPUSH
3078: LD_INT 100
3080: PPUSH
3081: CALL 14628 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3085: CALL_OW 45
3089: PPUSH
3090: LD_EXP 12
3094: PUSH
3095: LD_EXP 7
3099: PUSH
3100: LD_VAR 0 2
3104: ARRAY
3105: ARRAY
3106: PUSH
3107: LD_INT 1
3109: ARRAY
3110: PPUSH
3111: LD_INT 0
3113: PPUSH
3114: CALL_OW 49
// end ;
3118: GO 3027
3120: POP
3121: POP
// end ;
3122: GO 2233
3124: POP
3125: POP
// end ;
3126: LD_VAR 0 1
3130: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3131: LD_INT 0
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
3137: PPUSH
// if not multi_support then
3138: LD_EXP 23
3142: NOT
3143: IFFALSE 3147
// exit ;
3145: GO 3675
// result := [ ] ;
3147: LD_ADDR_VAR 0 1
3151: PUSH
3152: EMPTY
3153: ST_TO_ADDR
// for i = 1 to 8 do
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: DOUBLE
3160: LD_INT 1
3162: DEC
3163: ST_TO_ADDR
3164: LD_INT 8
3166: PUSH
3167: FOR_TO
3168: IFFALSE 3673
// begin if multi_sides [ i ] then
3170: LD_EXP 7
3174: PUSH
3175: LD_VAR 0 2
3179: ARRAY
3180: IFFALSE 3671
// begin tmp := [ ] ;
3182: LD_ADDR_VAR 0 5
3186: PUSH
3187: EMPTY
3188: ST_TO_ADDR
// if multi_support = 1 then
3189: LD_EXP 23
3193: PUSH
3194: LD_INT 1
3196: EQUAL
3197: IFFALSE 3365
// begin uc_side := i ;
3199: LD_ADDR_OWVAR 20
3203: PUSH
3204: LD_VAR 0 2
3208: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3209: LD_ADDR_OWVAR 21
3213: PUSH
3214: LD_EXP 9
3218: PUSH
3219: LD_VAR 0 2
3223: ARRAY
3224: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3225: LD_INT 3
3227: PPUSH
3228: LD_INT 1
3230: PPUSH
3231: LD_INT 3
3233: PPUSH
3234: LD_INT 11
3236: PPUSH
3237: LD_INT 40
3239: PPUSH
3240: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3244: LD_ADDR_VAR 0 5
3248: PUSH
3249: LD_VAR 0 5
3253: PUSH
3254: CALL_OW 45
3258: ADD
3259: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3260: LD_INT 2
3262: PPUSH
3263: LD_INT 1
3265: PPUSH
3266: LD_INT 3
3268: PPUSH
3269: LD_INT 5
3271: PPUSH
3272: LD_INT 40
3274: PPUSH
3275: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3279: LD_ADDR_VAR 0 5
3283: PUSH
3284: LD_VAR 0 5
3288: PUSH
3289: CALL_OW 45
3293: ADD
3294: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3295: LD_INT 2
3297: PPUSH
3298: LD_INT 3
3300: PPUSH
3301: LD_INT 3
3303: PPUSH
3304: LD_INT 4
3306: PPUSH
3307: LD_INT 40
3309: PPUSH
3310: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3314: LD_ADDR_VAR 0 5
3318: PUSH
3319: LD_VAR 0 5
3323: PUSH
3324: CALL_OW 45
3328: ADD
3329: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3330: LD_INT 3
3332: PPUSH
3333: LD_INT 2
3335: PPUSH
3336: LD_INT 3
3338: PPUSH
3339: LD_INT 9
3341: PPUSH
3342: LD_INT 40
3344: PPUSH
3345: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3349: LD_ADDR_VAR 0 5
3353: PUSH
3354: LD_VAR 0 5
3358: PUSH
3359: CALL_OW 45
3363: ADD
3364: ST_TO_ADDR
// end ; if multi_support = 2 then
3365: LD_EXP 23
3369: PUSH
3370: LD_INT 2
3372: EQUAL
3373: IFFALSE 3646
// begin uc_side := i ;
3375: LD_ADDR_OWVAR 20
3379: PUSH
3380: LD_VAR 0 2
3384: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_EXP 9
3394: PUSH
3395: LD_VAR 0 2
3399: ARRAY
3400: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3401: LD_INT 3
3403: PPUSH
3404: LD_INT 1
3406: PPUSH
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 11
3412: PPUSH
3413: LD_INT 40
3415: PPUSH
3416: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3420: LD_ADDR_VAR 0 5
3424: PUSH
3425: LD_VAR 0 5
3429: PUSH
3430: CALL_OW 45
3434: ADD
3435: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3436: LD_INT 3
3438: PPUSH
3439: LD_INT 3
3441: PPUSH
3442: LD_INT 3
3444: PPUSH
3445: LD_INT 12
3447: PPUSH
3448: LD_INT 40
3450: PPUSH
3451: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3455: LD_ADDR_VAR 0 5
3459: PUSH
3460: LD_VAR 0 5
3464: PUSH
3465: CALL_OW 45
3469: ADD
3470: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3471: LD_INT 2
3473: PPUSH
3474: LD_INT 3
3476: PPUSH
3477: LD_INT 3
3479: PPUSH
3480: LD_INT 5
3482: PPUSH
3483: LD_INT 40
3485: PPUSH
3486: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3490: LD_ADDR_VAR 0 5
3494: PUSH
3495: LD_VAR 0 5
3499: PUSH
3500: CALL_OW 45
3504: ADD
3505: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3506: LD_INT 4
3508: PPUSH
3509: LD_INT 1
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_INT 6
3517: PPUSH
3518: LD_INT 40
3520: PPUSH
3521: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3525: LD_ADDR_VAR 0 5
3529: PUSH
3530: LD_VAR 0 5
3534: PUSH
3535: CALL_OW 45
3539: ADD
3540: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3541: LD_INT 2
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 40
3555: PPUSH
3556: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3560: LD_ADDR_VAR 0 5
3564: PUSH
3565: LD_VAR 0 5
3569: PUSH
3570: CALL_OW 45
3574: ADD
3575: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3576: LD_INT 2
3578: PPUSH
3579: LD_INT 3
3581: PPUSH
3582: LD_INT 3
3584: PPUSH
3585: LD_INT 9
3587: PPUSH
3588: LD_INT 40
3590: PPUSH
3591: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3595: LD_ADDR_VAR 0 5
3599: PUSH
3600: LD_VAR 0 5
3604: PUSH
3605: CALL_OW 45
3609: ADD
3610: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3611: LD_INT 4
3613: PPUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: LD_INT 6
3622: PPUSH
3623: LD_INT 40
3625: PPUSH
3626: CALL 14628 0 5
// tmp := tmp ^ CreateVehicle ;
3630: LD_ADDR_VAR 0 5
3634: PUSH
3635: LD_VAR 0 5
3639: PUSH
3640: CALL_OW 45
3644: ADD
3645: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3646: LD_ADDR_VAR 0 1
3650: PUSH
3651: LD_VAR 0 1
3655: PPUSH
3656: LD_VAR 0 2
3660: PPUSH
3661: LD_VAR 0 5
3665: PPUSH
3666: CALL_OW 2
3670: ST_TO_ADDR
// end ; end ;
3671: GO 3167
3673: POP
3674: POP
// end ;
3675: LD_VAR 0 1
3679: RET
// export function Multiplayer_Start ( ) ; begin
3680: LD_INT 0
3682: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3683: CALL 2209 0 0
// Multiplayer_InitPointSystem ( ) ;
3687: CALL 4604 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3691: LD_INT 20
3693: PPUSH
3694: CALL 4780 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3698: LD_INT 150
3700: PPUSH
3701: CALL 4780 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3705: LD_INT 5
3707: PPUSH
3708: CALL 4780 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3712: LD_INT 40
3714: NEG
3715: PPUSH
3716: CALL 4780 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3720: LD_INT 200
3722: PPUSH
3723: CALL 4780 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3727: LD_INT 2
3729: PPUSH
3730: CALL 4780 0 1
// Multiplayer_SpawnArtifact ;
3734: CALL 5220 0 0
// if multi_support then
3738: LD_EXP 23
3742: IFFALSE 3754
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3744: LD_ADDR_EXP 27
3748: PUSH
3749: CALL 3131 0 0
3753: ST_TO_ADDR
// game := true ;
3754: LD_ADDR_EXP 2
3758: PUSH
3759: LD_INT 1
3761: ST_TO_ADDR
// if multi_sides [ your_side ] then
3762: LD_EXP 7
3766: PUSH
3767: LD_OWVAR 2
3771: ARRAY
3772: IFFALSE 3799
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3774: LD_INT 22
3776: PUSH
3777: LD_OWVAR 2
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: CALL_OW 87
// end ;
3799: LD_VAR 0 1
3803: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3804: LD_INT 0
3806: PPUSH
3807: PPUSH
3808: PPUSH
3809: PPUSH
3810: PPUSH
// reinforcements_arrive := 0 ;
3811: LD_ADDR_VAR 0 5
3815: PUSH
3816: LD_INT 0
3818: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3819: LD_INT 35
3821: PPUSH
3822: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3826: LD_OWVAR 1
3830: PUSH
3831: LD_INT 21000
3833: GREATER
3834: PUSH
3835: LD_EXP 28
3839: NOT
3840: AND
3841: PUSH
3842: LD_EXP 23
3846: PUSH
3847: LD_INT 1
3849: EQUAL
3850: AND
3851: IFFALSE 4046
// begin multi_reinforcements_spawned := 1 ;
3853: LD_ADDR_EXP 28
3857: PUSH
3858: LD_INT 1
3860: ST_TO_ADDR
// for i = 1 to 8 do
3861: LD_ADDR_VAR 0 2
3865: PUSH
3866: DOUBLE
3867: LD_INT 1
3869: DEC
3870: ST_TO_ADDR
3871: LD_INT 8
3873: PUSH
3874: FOR_TO
3875: IFFALSE 4034
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3877: LD_EXP 7
3881: PUSH
3882: LD_VAR 0 2
3886: ARRAY
3887: PUSH
3888: LD_EXP 25
3892: PUSH
3893: LD_VAR 0 2
3897: ARRAY
3898: NOT
3899: AND
3900: PUSH
3901: LD_EXP 27
3905: PUSH
3906: LD_VAR 0 2
3910: ARRAY
3911: AND
3912: IFFALSE 4032
// begin tmp := multi_reinforcements [ i ] ;
3914: LD_ADDR_VAR 0 4
3918: PUSH
3919: LD_EXP 27
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: ST_TO_ADDR
// for j = 1 to 4 do
3930: LD_ADDR_VAR 0 3
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 4
3942: PUSH
3943: FOR_TO
3944: IFFALSE 4005
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3946: LD_VAR 0 4
3950: PUSH
3951: LD_VAR 0 3
3955: ARRAY
3956: PPUSH
3957: LD_EXP 12
3961: PUSH
3962: LD_EXP 7
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ARRAY
3973: PUSH
3974: LD_INT 2
3976: ARRAY
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
3985: LD_ADDR_VAR 0 4
3989: PUSH
3990: LD_VAR 0 4
3994: PPUSH
3995: LD_INT 1
3997: PPUSH
3998: CALL_OW 3
4002: ST_TO_ADDR
// end ;
4003: GO 3943
4005: POP
4006: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4007: LD_ADDR_EXP 27
4011: PUSH
4012: LD_EXP 27
4016: PPUSH
4017: LD_VAR 0 2
4021: PPUSH
4022: LD_VAR 0 4
4026: PPUSH
4027: CALL_OW 1
4031: ST_TO_ADDR
// end ; end ;
4032: GO 3874
4034: POP
4035: POP
// reinforcements_arrive := tick ;
4036: LD_ADDR_VAR 0 5
4040: PUSH
4041: LD_OWVAR 1
4045: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4046: LD_VAR 0 5
4050: PUSH
4051: LD_INT 21000
4053: PLUS
4054: PUSH
4055: LD_OWVAR 1
4059: LESS
4060: PUSH
4061: LD_EXP 28
4065: PUSH
4066: LD_INT 1
4068: EQUAL
4069: AND
4070: PUSH
4071: LD_EXP 23
4075: PUSH
4076: LD_INT 2
4078: EQUAL
4079: AND
4080: IFFALSE 4265
// begin multi_reinforcements_spawned := 2 ;
4082: LD_ADDR_EXP 28
4086: PUSH
4087: LD_INT 2
4089: ST_TO_ADDR
// for i = 1 to 8 do
4090: LD_ADDR_VAR 0 2
4094: PUSH
4095: DOUBLE
4096: LD_INT 1
4098: DEC
4099: ST_TO_ADDR
4100: LD_INT 8
4102: PUSH
4103: FOR_TO
4104: IFFALSE 4263
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4106: LD_EXP 7
4110: PUSH
4111: LD_VAR 0 2
4115: ARRAY
4116: PUSH
4117: LD_EXP 25
4121: PUSH
4122: LD_VAR 0 2
4126: ARRAY
4127: NOT
4128: AND
4129: PUSH
4130: LD_EXP 27
4134: PUSH
4135: LD_VAR 0 2
4139: ARRAY
4140: AND
4141: IFFALSE 4261
// begin tmp := multi_reinforcements [ i ] ;
4143: LD_ADDR_VAR 0 4
4147: PUSH
4148: LD_EXP 27
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: ST_TO_ADDR
// for j = 1 to 3 do
4159: LD_ADDR_VAR 0 3
4163: PUSH
4164: DOUBLE
4165: LD_INT 1
4167: DEC
4168: ST_TO_ADDR
4169: LD_INT 3
4171: PUSH
4172: FOR_TO
4173: IFFALSE 4234
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4175: LD_VAR 0 4
4179: PUSH
4180: LD_VAR 0 3
4184: ARRAY
4185: PPUSH
4186: LD_EXP 12
4190: PUSH
4191: LD_EXP 7
4195: PUSH
4196: LD_VAR 0 2
4200: ARRAY
4201: ARRAY
4202: PUSH
4203: LD_INT 2
4205: ARRAY
4206: PPUSH
4207: LD_INT 0
4209: PPUSH
4210: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4214: LD_ADDR_VAR 0 4
4218: PUSH
4219: LD_VAR 0 4
4223: PPUSH
4224: LD_INT 1
4226: PPUSH
4227: CALL_OW 3
4231: ST_TO_ADDR
// end ;
4232: GO 4172
4234: POP
4235: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4236: LD_ADDR_EXP 27
4240: PUSH
4241: LD_EXP 27
4245: PPUSH
4246: LD_VAR 0 2
4250: PPUSH
4251: LD_VAR 0 4
4255: PPUSH
4256: CALL_OW 1
4260: ST_TO_ADDR
// end ; end ;
4261: GO 4103
4263: POP
4264: POP
// end ; if not multi_custom_commanders then
4265: LD_EXP 16
4269: NOT
4270: IFFALSE 4383
// begin for i = 1 to 8 do
4272: LD_ADDR_VAR 0 2
4276: PUSH
4277: DOUBLE
4278: LD_INT 1
4280: DEC
4281: ST_TO_ADDR
4282: LD_INT 8
4284: PUSH
4285: FOR_TO
4286: IFFALSE 4357
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4288: LD_INT 22
4290: PUSH
4291: LD_VAR 0 2
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: PPUSH
4300: CALL_OW 69
4304: PUSH
4305: LD_INT 0
4307: EQUAL
4308: PUSH
4309: LD_EXP 25
4313: PUSH
4314: LD_VAR 0 2
4318: ARRAY
4319: NOT
4320: AND
4321: IFFALSE 4355
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4323: LD_ADDR_EXP 25
4327: PUSH
4328: LD_EXP 25
4332: PPUSH
4333: LD_VAR 0 2
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: CALL_OW 1
4345: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: CALL 4850 0 1
// end ; end ;
4355: GO 4285
4357: POP
4358: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4359: LD_EXP 25
4363: PPUSH
4364: CALL 11902 0 1
4368: PUSH
4369: LD_EXP 7
4373: PPUSH
4374: CALL 11902 0 1
4378: EQUAL
4379: IFFALSE 4383
// break ;
4381: GO 4418
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4383: LD_INT 22
4385: PUSH
4386: LD_EXP 3
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PPUSH
4395: CALL_OW 69
4399: PUSH
4400: LD_INT 0
4402: EQUAL
4403: PUSH
4404: LD_EXP 2
4408: AND
4409: PUSH
4410: LD_EXP 24
4414: NOT
4415: OR
4416: IFFALSE 3819
// game := false ;
4418: LD_ADDR_EXP 2
4422: PUSH
4423: LD_INT 0
4425: ST_TO_ADDR
// for i = 1 to 8 do
4426: LD_ADDR_VAR 0 2
4430: PUSH
4431: DOUBLE
4432: LD_INT 1
4434: DEC
4435: ST_TO_ADDR
4436: LD_INT 8
4438: PUSH
4439: FOR_TO
4440: IFFALSE 4476
// begin if multi_sides [ i ] then
4442: LD_EXP 7
4446: PUSH
4447: LD_VAR 0 2
4451: ARRAY
4452: IFFALSE 4474
// SetMultiScore ( i , multi_points [ i ] ) ;
4454: LD_VAR 0 2
4458: PPUSH
4459: LD_EXP 29
4463: PUSH
4464: LD_VAR 0 2
4468: ARRAY
4469: PPUSH
4470: CALL_OW 506
// end ;
4474: GO 4439
4476: POP
4477: POP
// if multi_loosers [ your_side ] then
4478: LD_EXP 25
4482: PUSH
4483: LD_OWVAR 2
4487: ARRAY
4488: IFFALSE 4496
// YouLostInMultiplayer else
4490: CALL_OW 107
4494: GO 4500
// YouWinInMultiplayer ;
4496: CALL_OW 106
// end ;
4500: LD_VAR 0 1
4504: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4505: LD_INT 0
4507: PPUSH
4508: PPUSH
// result := [ #tick , tick ] ;
4509: LD_ADDR_VAR 0 1
4513: PUSH
4514: LD_STRING #tick
4516: PUSH
4517: LD_OWVAR 1
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: ST_TO_ADDR
// for i = 1 to 8 do
4526: LD_ADDR_VAR 0 2
4530: PUSH
4531: DOUBLE
4532: LD_INT 1
4534: DEC
4535: ST_TO_ADDR
4536: LD_INT 8
4538: PUSH
4539: FOR_TO
4540: IFFALSE 4597
// begin if multi_sides [ i ] then
4542: LD_EXP 7
4546: PUSH
4547: LD_VAR 0 2
4551: ARRAY
4552: IFFALSE 4595
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4554: LD_ADDR_VAR 0 1
4558: PUSH
4559: LD_VAR 0 1
4563: PUSH
4564: LD_STRING #coop-points
4566: PUSH
4567: LD_VAR 0 2
4571: PUSH
4572: LD_VAR 0 2
4576: PUSH
4577: LD_EXP 29
4581: PUSH
4582: LD_VAR 0 2
4586: ARRAY
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: LIST
4592: LIST
4593: ADD
4594: ST_TO_ADDR
// end ; end ;
4595: GO 4539
4597: POP
4598: POP
// end ;
4599: LD_VAR 0 1
4603: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4604: LD_INT 0
4606: PPUSH
4607: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4608: LD_ADDR_EXP 29
4612: PUSH
4613: LD_INT 0
4615: PUSH
4616: LD_INT 0
4618: PUSH
4619: LD_INT 0
4621: PUSH
4622: LD_INT 0
4624: PUSH
4625: LD_INT 0
4627: PUSH
4628: LD_INT 0
4630: PUSH
4631: LD_INT 0
4633: PUSH
4634: LD_INT 0
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: LIST
4646: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4647: LD_ADDR_EXP 30
4651: PUSH
4652: EMPTY
4653: ST_TO_ADDR
// end ;
4654: LD_VAR 0 1
4658: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4659: LD_INT 0
4661: PPUSH
// if not multi_points or not side or side > 8 then
4662: LD_EXP 29
4666: NOT
4667: PUSH
4668: LD_VAR 0 1
4672: NOT
4673: OR
4674: PUSH
4675: LD_VAR 0 1
4679: PUSH
4680: LD_INT 8
4682: GREATER
4683: OR
4684: IFFALSE 4688
// exit ;
4686: GO 4725
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4688: LD_ADDR_EXP 29
4692: PUSH
4693: LD_EXP 29
4697: PPUSH
4698: LD_VAR 0 1
4702: PPUSH
4703: LD_EXP 29
4707: PUSH
4708: LD_VAR 0 1
4712: ARRAY
4713: PUSH
4714: LD_VAR 0 2
4718: PLUS
4719: PPUSH
4720: CALL_OW 1
4724: ST_TO_ADDR
// end ;
4725: LD_VAR 0 3
4729: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4730: LD_INT 0
4732: PPUSH
// if not multi_points or not side or side > 8 then
4733: LD_EXP 29
4737: NOT
4738: PUSH
4739: LD_VAR 0 1
4743: NOT
4744: OR
4745: PUSH
4746: LD_VAR 0 1
4750: PUSH
4751: LD_INT 8
4753: GREATER
4754: OR
4755: IFFALSE 4759
// exit ;
4757: GO 4775
// result := multi_points [ side ] ;
4759: LD_ADDR_VAR 0 2
4763: PUSH
4764: LD_EXP 29
4768: PUSH
4769: LD_VAR 0 1
4773: ARRAY
4774: ST_TO_ADDR
// end ;
4775: LD_VAR 0 2
4779: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4780: LD_INT 0
4782: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4783: LD_ADDR_EXP 30
4787: PUSH
4788: LD_EXP 30
4792: PPUSH
4793: LD_EXP 30
4797: PUSH
4798: LD_INT 1
4800: PLUS
4801: PPUSH
4802: LD_VAR 0 1
4806: PPUSH
4807: CALL_OW 2
4811: ST_TO_ADDR
// end ;
4812: LD_VAR 0 2
4816: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4817: LD_INT 0
4819: PPUSH
// if not id then
4820: LD_VAR 0 1
4824: NOT
4825: IFFALSE 4829
// exit ;
4827: GO 4845
// result := multi_points_conditions [ id ] ;
4829: LD_ADDR_VAR 0 2
4833: PUSH
4834: LD_EXP 30
4838: PUSH
4839: LD_VAR 0 1
4843: ARRAY
4844: ST_TO_ADDR
// end ;
4845: LD_VAR 0 2
4849: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4850: LD_INT 0
4852: PPUSH
4853: PPUSH
4854: PPUSH
4855: PPUSH
4856: PPUSH
// players := [ ] ;
4857: LD_ADDR_VAR 0 3
4861: PUSH
4862: EMPTY
4863: ST_TO_ADDR
// for i = 1 to 8 do
4864: LD_ADDR_VAR 0 4
4868: PUSH
4869: DOUBLE
4870: LD_INT 1
4872: DEC
4873: ST_TO_ADDR
4874: LD_INT 8
4876: PUSH
4877: FOR_TO
4878: IFFALSE 4937
// begin if i = side then
4880: LD_VAR 0 4
4884: PUSH
4885: LD_VAR 0 1
4889: EQUAL
4890: IFFALSE 4894
// continue ;
4892: GO 4877
// if multi_sides [ i ] and not multi_loosers [ i ] then
4894: LD_EXP 7
4898: PUSH
4899: LD_VAR 0 4
4903: ARRAY
4904: PUSH
4905: LD_EXP 25
4909: PUSH
4910: LD_VAR 0 4
4914: ARRAY
4915: NOT
4916: AND
4917: IFFALSE 4935
// players := players ^ i ;
4919: LD_ADDR_VAR 0 3
4923: PUSH
4924: LD_VAR 0 3
4928: PUSH
4929: LD_VAR 0 4
4933: ADD
4934: ST_TO_ADDR
// end ;
4935: GO 4877
4937: POP
4938: POP
// if not players then
4939: LD_VAR 0 3
4943: NOT
4944: IFFALSE 4948
// exit ;
4946: GO 5215
// if players = 1 then
4948: LD_VAR 0 3
4952: PUSH
4953: LD_INT 1
4955: EQUAL
4956: IFFALSE 5017
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
4958: LD_ADDR_VAR 0 4
4962: PUSH
4963: LD_INT 22
4965: PUSH
4966: LD_VAR 0 1
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 51
4977: PUSH
4978: EMPTY
4979: LIST
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PPUSH
4985: CALL_OW 69
4989: PUSH
4990: FOR_IN
4991: IFFALSE 5013
// SetSide ( i , players [ 1 ] ) ;
4993: LD_VAR 0 4
4997: PPUSH
4998: LD_VAR 0 3
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: CALL_OW 235
5011: GO 4990
5013: POP
5014: POP
// end else
5015: GO 5215
// begin j := 1 ;
5017: LD_ADDR_VAR 0 5
5021: PUSH
5022: LD_INT 1
5024: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: LD_INT 22
5032: PUSH
5033: LD_VAR 0 1
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PUSH
5042: LD_INT 2
5044: PUSH
5045: LD_INT 21
5047: PUSH
5048: LD_INT 1
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 51
5057: PUSH
5058: EMPTY
5059: LIST
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 2
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PPUSH
5084: CALL_OW 69
5088: PUSH
5089: FOR_IN
5090: IFFALSE 5213
// begin SetSide ( i , players [ j ] ) ;
5092: LD_VAR 0 4
5096: PPUSH
5097: LD_VAR 0 3
5101: PUSH
5102: LD_VAR 0 5
5106: ARRAY
5107: PPUSH
5108: CALL_OW 235
// if IsDrivenBy ( i ) then
5112: LD_VAR 0 4
5116: PPUSH
5117: CALL_OW 311
5121: IFFALSE 5148
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5123: LD_VAR 0 4
5127: PPUSH
5128: CALL_OW 311
5132: PPUSH
5133: LD_VAR 0 3
5137: PUSH
5138: LD_VAR 0 5
5142: ARRAY
5143: PPUSH
5144: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5148: LD_VAR 0 4
5152: PPUSH
5153: CALL_OW 310
5157: PPUSH
5158: CALL_OW 247
5162: PUSH
5163: LD_INT 3
5165: EQUAL
5166: IFFALSE 5177
// ComExitBuilding ( i ) ;
5168: LD_VAR 0 4
5172: PPUSH
5173: CALL_OW 122
// j := j + 1 ;
5177: LD_ADDR_VAR 0 5
5181: PUSH
5182: LD_VAR 0 5
5186: PUSH
5187: LD_INT 1
5189: PLUS
5190: ST_TO_ADDR
// if j > players then
5191: LD_VAR 0 5
5195: PUSH
5196: LD_VAR 0 3
5200: GREATER
5201: IFFALSE 5211
// j := 1 ;
5203: LD_ADDR_VAR 0 5
5207: PUSH
5208: LD_INT 1
5210: ST_TO_ADDR
// end ;
5211: GO 5089
5213: POP
5214: POP
// end ; end ;
5215: LD_VAR 0 2
5219: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5220: LD_INT 0
5222: PPUSH
5223: PPUSH
5224: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5225: LD_ADDR_VAR 0 3
5229: PUSH
5230: LD_INT 5
5232: PUSH
5233: LD_INT 10
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 120
5242: PUSH
5243: LD_INT 2
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: LD_INT 101
5252: PUSH
5253: LD_INT 8
5255: PUSH
5256: EMPTY
5257: LIST
5258: LIST
5259: PUSH
5260: LD_INT 27
5262: PUSH
5263: LD_INT 4
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5276: LD_ADDR_VAR 0 2
5280: PUSH
5281: LD_INT 1
5283: PPUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: CALL_OW 12
5293: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5294: LD_INT 4
5296: PPUSH
5297: LD_INT 5
5299: PPUSH
5300: LD_VAR 0 3
5304: PUSH
5305: LD_VAR 0 2
5309: ARRAY
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PPUSH
5315: LD_VAR 0 3
5319: PUSH
5320: LD_VAR 0 2
5324: ARRAY
5325: PUSH
5326: LD_INT 2
5328: ARRAY
5329: PPUSH
5330: LD_INT 0
5332: PPUSH
5333: CALL_OW 58
// end ;
5337: LD_VAR 0 1
5341: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5342: LD_INT 0
5344: PPUSH
// if not side or side > 8 then
5345: LD_VAR 0 1
5349: NOT
5350: PUSH
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 8
5358: GREATER
5359: OR
5360: IFFALSE 5364
// exit ;
5362: GO 5381
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5364: LD_VAR 0 1
5368: PPUSH
5369: LD_INT 6
5371: PPUSH
5372: CALL 4817 0 1
5376: PPUSH
5377: CALL 4659 0 2
// end ;
5381: LD_VAR 0 2
5385: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5386: LD_INT 0
5388: PPUSH
// if not side or side > 8 then
5389: LD_VAR 0 1
5393: NOT
5394: PUSH
5395: LD_VAR 0 1
5399: PUSH
5400: LD_INT 8
5402: GREATER
5403: OR
5404: IFFALSE 5408
// exit ;
5406: GO 5425
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5408: LD_VAR 0 1
5412: PPUSH
5413: LD_INT 4
5415: PPUSH
5416: CALL 4817 0 1
5420: PPUSH
5421: CALL 4659 0 2
// end ;
5425: LD_VAR 0 2
5429: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5430: LD_INT 0
5432: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5433: LD_VAR 0 1
5437: NOT
5438: PUSH
5439: LD_VAR 0 1
5443: PUSH
5444: LD_INT 8
5446: GREATER
5447: OR
5448: PUSH
5449: LD_VAR 0 2
5453: PUSH
5454: LD_INT 2
5456: PUSH
5457: LD_INT 6
5459: PUSH
5460: LD_INT 36
5462: PUSH
5463: LD_INT 0
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: IN
5472: NOT
5473: OR
5474: IFFALSE 5478
// exit ;
5476: GO 5495
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5478: LD_VAR 0 1
5482: PPUSH
5483: LD_INT 3
5485: PPUSH
5486: CALL 4817 0 1
5490: PPUSH
5491: CALL 4659 0 2
// end ;
5495: LD_VAR 0 3
5499: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5500: LD_INT 0
5502: PPUSH
5503: PPUSH
5504: PPUSH
5505: PPUSH
5506: PPUSH
5507: PPUSH
// if not un then
5508: LD_VAR 0 1
5512: NOT
5513: IFFALSE 5517
// exit ;
5515: GO 5741
// if not points then
5517: LD_VAR 0 2
5521: NOT
5522: IFFALSE 5539
// gained_points := Multiplayer_GetCondition ( 1 ) else
5524: LD_ADDR_VAR 0 8
5528: PUSH
5529: LD_INT 1
5531: PPUSH
5532: CALL 4817 0 1
5536: ST_TO_ADDR
5537: GO 5549
// gained_points := points ;
5539: LD_ADDR_VAR 0 8
5543: PUSH
5544: LD_VAR 0 2
5548: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5549: LD_ADDR_VAR 0 6
5553: PUSH
5554: LD_VAR 0 1
5558: PPUSH
5559: CALL_OW 503
5563: ST_TO_ADDR
// if last_shoot > - 1 then
5564: LD_VAR 0 6
5568: PUSH
5569: LD_INT 1
5571: NEG
5572: GREATER
5573: IFFALSE 5585
// begin side := last_shoot ;
5575: LD_ADDR_VAR 0 4
5579: PUSH
5580: LD_VAR 0 6
5584: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5585: LD_ADDR_VAR 0 7
5589: PUSH
5590: LD_OWVAR 3
5594: PUSH
5595: LD_INT 22
5597: PUSH
5598: LD_VAR 0 1
5602: PPUSH
5603: CALL_OW 255
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: PPUSH
5612: CALL_OW 69
5616: DIFF
5617: PPUSH
5618: LD_VAR 0 1
5622: PPUSH
5623: CALL_OW 74
5627: ST_TO_ADDR
// if nearest_unit then
5628: LD_VAR 0 7
5632: IFFALSE 5649
// side2 := GetSide ( nearest_unit ) ;
5634: LD_ADDR_VAR 0 5
5638: PUSH
5639: LD_VAR 0 7
5643: PPUSH
5644: CALL_OW 255
5648: ST_TO_ADDR
// if not side and not side2 then
5649: LD_VAR 0 4
5653: NOT
5654: PUSH
5655: LD_VAR 0 5
5659: NOT
5660: AND
5661: IFFALSE 5665
// exit ;
5663: GO 5741
// if side = side2 then
5665: LD_VAR 0 4
5669: PUSH
5670: LD_VAR 0 5
5674: EQUAL
5675: IFFALSE 5693
// Multiplayer_AddPoints ( side , gained_points ) else
5677: LD_VAR 0 4
5681: PPUSH
5682: LD_VAR 0 8
5686: PPUSH
5687: CALL 4659 0 2
5691: GO 5741
// begin if side then
5693: LD_VAR 0 4
5697: IFFALSE 5717
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5699: LD_VAR 0 4
5703: PPUSH
5704: LD_VAR 0 8
5708: PUSH
5709: LD_INT 2
5711: DIV
5712: PPUSH
5713: CALL 4659 0 2
// if side2 then
5717: LD_VAR 0 5
5721: IFFALSE 5741
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5723: LD_VAR 0 5
5727: PPUSH
5728: LD_VAR 0 8
5732: PUSH
5733: LD_INT 2
5735: DIV
5736: PPUSH
5737: CALL 4659 0 2
// end ; end ;
5741: LD_VAR 0 3
5745: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5746: LD_INT 0
5748: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5749: LD_VAR 0 1
5753: PPUSH
5754: LD_INT 2
5756: PPUSH
5757: CALL 4817 0 1
5761: PPUSH
5762: CALL 4659 0 2
// end ; end_of_file
5766: LD_VAR 0 2
5770: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5771: LD_INT 0
5773: PPUSH
5774: PPUSH
5775: PPUSH
5776: PPUSH
5777: PPUSH
5778: PPUSH
5779: PPUSH
5780: PPUSH
5781: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5782: LD_ADDR_VAR 0 9
5786: PUSH
5787: LD_INT 22
5789: PUSH
5790: LD_INT 2
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: PPUSH
5797: CALL_OW 69
5801: ST_TO_ADDR
// side_bot := side ;
5802: LD_ADDR_EXP 3
5806: PUSH
5807: LD_VAR 0 1
5811: ST_TO_ADDR
// if tmp and side <> 2 then
5812: LD_VAR 0 9
5816: PUSH
5817: LD_VAR 0 1
5821: PUSH
5822: LD_INT 2
5824: NONEQUAL
5825: AND
5826: IFFALSE 5859
// for i in tmp do
5828: LD_ADDR_VAR 0 3
5832: PUSH
5833: LD_VAR 0 9
5837: PUSH
5838: FOR_IN
5839: IFFALSE 5857
// SetSide ( i , side ) ;
5841: LD_VAR 0 3
5845: PPUSH
5846: LD_VAR 0 1
5850: PPUSH
5851: CALL_OW 235
5855: GO 5838
5857: POP
5858: POP
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5859: LD_ADDR_VAR 0 10
5863: PUSH
5864: LD_INT 11
5866: PUSH
5867: LD_INT 4
5869: PUSH
5870: LD_INT 3
5872: PUSH
5873: LD_INT 5
5875: PUSH
5876: LD_INT 66
5878: PUSH
5879: LD_INT 67
5881: PUSH
5882: LD_INT 53
5884: PUSH
5885: LD_INT 18
5887: PUSH
5888: LD_INT 40
5890: PUSH
5891: LD_INT 22
5893: PUSH
5894: LD_INT 72
5896: PUSH
5897: LD_INT 55
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: ST_TO_ADDR
// for i in techs do
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_VAR 0 10
5923: PUSH
5924: FOR_IN
5925: IFFALSE 5946
// SetTech ( i , side , state_researched ) ;
5927: LD_VAR 0 3
5931: PPUSH
5932: LD_VAR 0 1
5936: PPUSH
5937: LD_INT 2
5939: PPUSH
5940: CALL_OW 322
5944: GO 5924
5946: POP
5947: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5948: LD_ADDR_VAR 0 8
5952: PUSH
5953: LD_INT 6
5955: PUSH
5956: LD_INT 7
5958: PUSH
5959: LD_INT 8
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: PUSH
5967: LD_OWVAR 67
5971: ARRAY
5972: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5973: LD_INT 69
5975: PUSH
5976: EMPTY
5977: LIST
5978: PPUSH
5979: LD_INT 141
5981: PPUSH
5982: CALL_OW 169
// Wait ( 1 ) ;
5986: LD_INT 1
5988: PPUSH
5989: CALL_OW 67
// uc_side := side ;
5993: LD_ADDR_OWVAR 20
5997: PUSH
5998: LD_VAR 0 1
6002: ST_TO_ADDR
// uc_nation := 2 ;
6003: LD_ADDR_OWVAR 21
6007: PUSH
6008: LD_INT 2
6010: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
6011: LD_ADDR_EXP 33
6015: PUSH
6016: LD_INT 94
6018: PPUSH
6019: LD_INT 35
6021: PPUSH
6022: LD_STRING dammam
6024: PPUSH
6025: LD_VAR 0 8
6029: PPUSH
6030: LD_INT 10000
6032: PUSH
6033: LD_INT 1000
6035: PUSH
6036: LD_INT 300
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: PPUSH
6044: LD_INT 12
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 3
6052: PUSH
6053: LD_INT 4
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: LIST
6060: PUSH
6061: LD_OWVAR 67
6065: ARRAY
6066: PUSH
6067: LD_INT 1
6069: NEG
6070: PUSH
6071: LD_INT 4
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: PPUSH
6080: CALL 18037 0 6
6084: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , area_base_north ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
6085: LD_ADDR_EXP 33
6089: PUSH
6090: LD_EXP 33
6094: PUSH
6095: LD_INT 122
6097: PPUSH
6098: LD_INT 35
6100: PPUSH
6101: LD_STRING 
6103: PPUSH
6104: LD_VAR 0 8
6108: PPUSH
6109: LD_INT 500
6111: PUSH
6112: LD_INT 60
6114: PUSH
6115: LD_INT 0
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: LIST
6122: PPUSH
6123: LD_INT 8
6125: PUSH
6126: LD_INT 2
6128: PUSH
6129: LD_INT 3
6131: PUSH
6132: LD_INT 4
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PUSH
6140: LD_OWVAR 67
6144: ARRAY
6145: PUSH
6146: LD_INT 2
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: PPUSH
6158: CALL 18037 0 6
6162: UNION
6163: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
6164: LD_ADDR_EXP 31
6168: PUSH
6169: LD_INT 45
6171: PPUSH
6172: LD_INT 34
6174: PPUSH
6175: LD_STRING jeddah
6177: PPUSH
6178: LD_VAR 0 8
6182: PPUSH
6183: LD_INT 700
6185: PUSH
6186: LD_INT 300
6188: PUSH
6189: LD_INT 10
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: LIST
6196: PPUSH
6197: LD_INT 10
6199: PUSH
6200: LD_INT 4
6202: PUSH
6203: LD_INT 3
6205: PUSH
6206: LD_INT 2
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PPUSH
6215: CALL 18037 0 6
6219: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6220: LD_ADDR_EXP 32
6224: PUSH
6225: LD_INT 7
6227: PPUSH
6228: LD_INT 33
6230: PPUSH
6231: LD_STRING riyadh
6233: PPUSH
6234: LD_VAR 0 8
6238: PPUSH
6239: LD_INT 500
6241: PUSH
6242: LD_INT 60
6244: PUSH
6245: LD_INT 0
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: LIST
6252: PPUSH
6253: LD_INT 4
6255: PUSH
6256: LD_INT 2
6258: PUSH
6259: LD_INT 3
6261: PUSH
6262: LD_INT 1
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PPUSH
6271: CALL 18037 0 6
6275: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
6276: LD_ADDR_EXP 34
6280: PUSH
6281: LD_INT 69
6283: PPUSH
6284: LD_INT 36
6286: PPUSH
6287: LD_STRING 
6289: PPUSH
6290: LD_VAR 0 8
6294: PPUSH
6295: LD_INT 500
6297: PUSH
6298: LD_INT 50
6300: PUSH
6301: LD_INT 0
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: LIST
6308: PPUSH
6309: LD_INT 10
6311: PUSH
6312: LD_INT 2
6314: PUSH
6315: LD_INT 3
6317: PUSH
6318: LD_INT 1
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: PPUSH
6327: CALL 18037 0 6
6331: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south ] ;
6332: LD_ADDR_EXP 42
6336: PUSH
6337: LD_EXP 33
6341: PUSH
6342: LD_EXP 31
6346: PUSH
6347: LD_EXP 34
6351: PUSH
6352: LD_EXP 32
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6363: LD_ADDR_OWVAR 37
6367: PUSH
6368: LD_INT 14
6370: ST_TO_ADDR
// vc_engine := engine_siberite ;
6371: LD_ADDR_OWVAR 39
6375: PUSH
6376: LD_INT 3
6378: ST_TO_ADDR
// vc_control := control_manual ;
6379: LD_ADDR_OWVAR 38
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6387: LD_ADDR_OWVAR 40
6391: PUSH
6392: LD_INT 31
6394: ST_TO_ADDR
// for i = 1 to 5 do
6395: LD_ADDR_VAR 0 3
6399: PUSH
6400: DOUBLE
6401: LD_INT 1
6403: DEC
6404: ST_TO_ADDR
6405: LD_INT 5
6407: PUSH
6408: FOR_TO
6409: IFFALSE 6678
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6411: LD_ADDR_VAR 0 5
6415: PUSH
6416: LD_INT 156
6418: PUSH
6419: LD_INT 15
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PUSH
6426: LD_INT 12
6428: PUSH
6429: LD_INT 7
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_VAR 0 3
6444: PUSH
6445: LD_INT 2
6447: MOD
6448: PUSH
6449: LD_INT 1
6451: PLUS
6452: ARRAY
6453: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6454: LD_INT 0
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: LD_VAR 0 8
6464: PPUSH
6465: CALL_OW 380
// un := CreateVehicle ;
6469: LD_ADDR_VAR 0 6
6473: PUSH
6474: CALL_OW 45
6478: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6479: LD_VAR 0 6
6483: PPUSH
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 5
6489: PPUSH
6490: CALL_OW 12
6494: PPUSH
6495: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6499: LD_VAR 0 6
6503: PPUSH
6504: LD_VAR 0 5
6508: PUSH
6509: LD_INT 1
6511: ARRAY
6512: PPUSH
6513: LD_VAR 0 5
6517: PUSH
6518: LD_INT 2
6520: ARRAY
6521: PPUSH
6522: LD_INT 6
6524: PPUSH
6525: LD_INT 0
6527: PPUSH
6528: CALL_OW 50
// un2 := CreateHuman ;
6532: LD_ADDR_VAR 0 7
6536: PUSH
6537: CALL_OW 44
6541: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6542: LD_VAR 0 7
6546: PPUSH
6547: LD_VAR 0 6
6551: PPUSH
6552: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6556: LD_ADDR_EXP 42
6560: PUSH
6561: LD_EXP 42
6565: PPUSH
6566: LD_VAR 0 3
6570: PUSH
6571: LD_INT 2
6573: MOD
6574: PUSH
6575: LD_INT 1
6577: PLUS
6578: PUSH
6579: LD_EXP 42
6583: PUSH
6584: LD_VAR 0 3
6588: PUSH
6589: LD_INT 2
6591: MOD
6592: PUSH
6593: LD_INT 1
6595: PLUS
6596: ARRAY
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PPUSH
6606: LD_VAR 0 6
6610: PPUSH
6611: CALL 14750 0 3
6615: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6616: LD_ADDR_EXP 42
6620: PUSH
6621: LD_EXP 42
6625: PPUSH
6626: LD_VAR 0 3
6630: PUSH
6631: LD_INT 2
6633: MOD
6634: PUSH
6635: LD_INT 1
6637: PLUS
6638: PUSH
6639: LD_EXP 42
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_INT 2
6651: MOD
6652: PUSH
6653: LD_INT 1
6655: PLUS
6656: ARRAY
6657: PUSH
6658: LD_INT 1
6660: PLUS
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PPUSH
6666: LD_VAR 0 7
6670: PPUSH
6671: CALL 14750 0 3
6675: ST_TO_ADDR
// end ;
6676: GO 6408
6678: POP
6679: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6680: LD_ADDR_VAR 0 3
6684: PUSH
6685: LD_INT 22
6687: PUSH
6688: LD_EXP 3
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: LD_INT 30
6699: PUSH
6700: LD_INT 31
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: LD_INT 58
6709: PUSH
6710: EMPTY
6711: LIST
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: PPUSH
6718: CALL_OW 69
6722: PUSH
6723: FOR_IN
6724: IFFALSE 6849
// begin if GetBase ( i ) then
6726: LD_VAR 0 3
6730: PPUSH
6731: CALL_OW 274
6735: IFFALSE 6739
// continue ;
6737: GO 6723
// d := GetDir ( i ) ;
6739: LD_ADDR_VAR 0 4
6743: PUSH
6744: LD_VAR 0 3
6748: PPUSH
6749: CALL_OW 254
6753: ST_TO_ADDR
// if d < 3 then
6754: LD_VAR 0 4
6758: PUSH
6759: LD_INT 3
6761: LESS
6762: IFFALSE 6780
// d := d + 3 else
6764: LD_ADDR_VAR 0 4
6768: PUSH
6769: LD_VAR 0 4
6773: PUSH
6774: LD_INT 3
6776: PLUS
6777: ST_TO_ADDR
6778: GO 6794
// d := d - 3 ;
6780: LD_ADDR_VAR 0 4
6784: PUSH
6785: LD_VAR 0 4
6789: PUSH
6790: LD_INT 3
6792: MINUS
6793: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6794: LD_INT 0
6796: PPUSH
6797: LD_INT 8
6799: PPUSH
6800: LD_VAR 0 8
6804: PPUSH
6805: CALL_OW 380
// un := CreateHuman ;
6809: LD_ADDR_VAR 0 6
6813: PUSH
6814: CALL_OW 44
6818: ST_TO_ADDR
// SetDir ( un , d ) ;
6819: LD_VAR 0 6
6823: PPUSH
6824: LD_VAR 0 4
6828: PPUSH
6829: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6833: LD_VAR 0 6
6837: PPUSH
6838: LD_VAR 0 3
6842: PPUSH
6843: CALL_OW 52
// end ;
6847: GO 6723
6849: POP
6850: POP
// ar_force_tmp := [ ] ;
6851: LD_ADDR_EXP 35
6855: PUSH
6856: EMPTY
6857: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6858: LD_INT 1
6860: PPUSH
6861: LD_INT 1
6863: PPUSH
6864: LD_VAR 0 8
6868: PPUSH
6869: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6873: LD_ADDR_OWVAR 33
6877: PUSH
6878: LD_STRING SecondCharsGal
6880: ST_TO_ADDR
// hc_face_number := 4 ;
6881: LD_ADDR_OWVAR 34
6885: PUSH
6886: LD_INT 4
6888: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6889: LD_ADDR_EXP 35
6893: PUSH
6894: LD_EXP 35
6898: PPUSH
6899: LD_INT 1
6901: PPUSH
6902: CALL_OW 44
6906: PPUSH
6907: CALL_OW 1
6911: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6912: LD_INT 2
6914: PPUSH
6915: LD_INT 4
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6927: LD_ADDR_OWVAR 33
6931: PUSH
6932: LD_STRING SecondCharsGal
6934: ST_TO_ADDR
// hc_face_number := 15 ;
6935: LD_ADDR_OWVAR 34
6939: PUSH
6940: LD_INT 15
6942: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6943: LD_ADDR_EXP 35
6947: PUSH
6948: LD_EXP 35
6952: PPUSH
6953: LD_INT 2
6955: PPUSH
6956: CALL_OW 44
6960: PPUSH
6961: CALL_OW 1
6965: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6966: LD_INT 2
6968: PPUSH
6969: LD_INT 4
6971: PPUSH
6972: LD_VAR 0 8
6976: PPUSH
6977: CALL_OW 380
// hc_gallery :=  ;
6981: LD_ADDR_OWVAR 33
6985: PUSH
6986: LD_STRING 
6988: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6989: LD_ADDR_EXP 35
6993: PUSH
6994: LD_EXP 35
6998: PPUSH
6999: LD_INT 3
7001: PPUSH
7002: CALL_OW 44
7006: PPUSH
7007: CALL_OW 1
7011: ST_TO_ADDR
// hc_sex := sex_male ;
7012: LD_ADDR_OWVAR 27
7016: PUSH
7017: LD_INT 1
7019: ST_TO_ADDR
// hc_class = 11 ;
7020: LD_ADDR_OWVAR 28
7024: PUSH
7025: LD_INT 11
7027: ST_TO_ADDR
// hc_gallery = sandar ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING sandar
7035: ST_TO_ADDR
// hc_face_number = 33 ;
7036: LD_ADDR_OWVAR 34
7040: PUSH
7041: LD_INT 33
7043: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7044: LD_ADDR_OWVAR 26
7048: PUSH
7049: LD_STRING Thabit Muhair Saliba
7051: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7052: LD_ADDR_OWVAR 31
7056: PUSH
7057: LD_INT 5
7059: PUSH
7060: LD_INT 5
7062: PUSH
7063: LD_INT 3
7065: PUSH
7066: LD_INT 3
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: LIST
7073: LIST
7074: ST_TO_ADDR
// Saliba = CreateHuman ;
7075: LD_ADDR_EXP 38
7079: PUSH
7080: CALL_OW 44
7084: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7085: LD_EXP 38
7089: PPUSH
7090: LD_INT 7
7092: PPUSH
7093: CALL_OW 52
// hc_name := Dietrich Gensher ;
7097: LD_ADDR_OWVAR 26
7101: PUSH
7102: LD_STRING Dietrich Gensher
7104: ST_TO_ADDR
// hc_class := 1 ;
7105: LD_ADDR_OWVAR 28
7109: PUSH
7110: LD_INT 1
7112: ST_TO_ADDR
// hc_gallery := sandar ;
7113: LD_ADDR_OWVAR 33
7117: PUSH
7118: LD_STRING sandar
7120: ST_TO_ADDR
// hc_face_number := 2 ;
7121: LD_ADDR_OWVAR 34
7125: PUSH
7126: LD_INT 2
7128: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7129: LD_ADDR_OWVAR 31
7133: PUSH
7134: LD_INT 10
7136: PUSH
7137: LD_INT 6
7139: PUSH
7140: LD_INT 5
7142: PUSH
7143: LD_INT 4
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: ST_TO_ADDR
// Gensher := CreateHuman ;
7152: LD_ADDR_EXP 39
7156: PUSH
7157: CALL_OW 44
7161: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7162: LD_EXP 39
7166: PPUSH
7167: LD_INT 94
7169: PPUSH
7170: CALL_OW 52
// InitHc ;
7174: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7178: LD_ADDR_EXP 37
7182: PUSH
7183: EMPTY
7184: PUSH
7185: EMPTY
7186: PUSH
7187: EMPTY
7188: PUSH
7189: EMPTY
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: LIST
7196: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7197: LD_ADDR_VAR 0 4
7201: PUSH
7202: DOUBLE
7203: LD_INT 1
7205: DEC
7206: ST_TO_ADDR
7207: LD_INT 3
7209: PUSH
7210: LD_INT 3
7212: PUSH
7213: LD_INT 4
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: LIST
7220: PUSH
7221: LD_OWVAR 67
7225: ARRAY
7226: PUSH
7227: FOR_TO
7228: IFFALSE 7446
// for i = 1 to 4 do
7230: LD_ADDR_VAR 0 3
7234: PUSH
7235: DOUBLE
7236: LD_INT 1
7238: DEC
7239: ST_TO_ADDR
7240: LD_INT 4
7242: PUSH
7243: FOR_TO
7244: IFFALSE 7442
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7246: LD_INT 14
7248: PPUSH
7249: LD_INT 3
7251: PUSH
7252: LD_INT 2
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: LD_INT 1
7261: PPUSH
7262: LD_INT 2
7264: PPUSH
7265: CALL_OW 12
7269: ARRAY
7270: PPUSH
7271: LD_INT 1
7273: PUSH
7274: LD_INT 5
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: LD_INT 1
7283: PPUSH
7284: LD_INT 2
7286: PPUSH
7287: CALL_OW 12
7291: ARRAY
7292: PPUSH
7293: LD_INT 25
7295: PUSH
7296: LD_INT 27
7298: PUSH
7299: LD_INT 26
7301: PUSH
7302: LD_INT 28
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: LIST
7309: LIST
7310: PUSH
7311: LD_INT 1
7313: PPUSH
7314: LD_INT 4
7316: PPUSH
7317: CALL_OW 12
7321: ARRAY
7322: PPUSH
7323: LD_INT 100
7325: PPUSH
7326: CALL 14628 0 5
// un := CreateVehicle ;
7330: LD_ADDR_VAR 0 6
7334: PUSH
7335: CALL_OW 45
7339: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7340: LD_ADDR_EXP 37
7344: PUSH
7345: LD_EXP 37
7349: PPUSH
7350: LD_VAR 0 3
7354: PUSH
7355: LD_EXP 37
7359: PUSH
7360: LD_VAR 0 3
7364: ARRAY
7365: PUSH
7366: LD_INT 1
7368: PLUS
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PPUSH
7374: LD_VAR 0 6
7378: PPUSH
7379: CALL 14750 0 3
7383: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7384: LD_VAR 0 6
7388: PPUSH
7389: LD_INT 0
7391: PPUSH
7392: LD_INT 5
7394: PPUSH
7395: CALL_OW 12
7399: PPUSH
7400: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7404: LD_VAR 0 6
7408: PPUSH
7409: LD_INT 20
7411: PUSH
7412: LD_INT 21
7414: PUSH
7415: LD_INT 22
7417: PUSH
7418: LD_INT 24
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: PUSH
7427: LD_VAR 0 3
7431: ARRAY
7432: PPUSH
7433: LD_INT 0
7435: PPUSH
7436: CALL_OW 49
// end ;
7440: GO 7243
7442: POP
7443: POP
7444: GO 7227
7446: POP
7447: POP
// InitHc ;
7448: CALL_OW 19
// end ;
7452: LD_VAR 0 2
7456: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7457: LD_INT 94
7459: PPUSH
7460: CALL_OW 302
7464: PUSH
7465: LD_INT 94
7467: PPUSH
7468: CALL_OW 255
7472: PUSH
7473: LD_EXP 3
7477: EQUAL
7478: AND
7479: IFFALSE 8188
7481: GO 7483
7483: DISABLE
7484: LD_INT 0
7486: PPUSH
7487: PPUSH
7488: PPUSH
7489: PPUSH
7490: PPUSH
7491: PPUSH
7492: PPUSH
7493: PPUSH
7494: PPUSH
7495: PPUSH
// begin enable ;
7496: ENABLE
// base := 1 ;
7497: LD_ADDR_VAR 0 4
7501: PUSH
7502: LD_INT 1
7504: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_INT 0
7512: PUSH
7513: LD_INT 0
7515: PUSH
7516: LD_INT 0
7518: PUSH
7519: LD_INT 0
7521: PUSH
7522: LD_INT 1
7524: PUSH
7525: LD_INT 0
7527: PUSH
7528: LD_INT 0
7530: PUSH
7531: LD_INT 0
7533: PUSH
7534: LD_INT 1
7536: PUSH
7537: LD_INT 0
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: LIST
7550: LIST
7551: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7552: LD_ADDR_VAR 0 6
7556: PUSH
7557: LD_INT 28
7559: PUSH
7560: LD_INT 14
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 107
7569: PUSH
7570: LD_INT 119
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: LD_INT 127
7579: PUSH
7580: LD_INT 97
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PUSH
7587: LD_INT 185
7589: PUSH
7590: LD_INT 127
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: LIST
7602: ST_TO_ADDR
// target := 0 ;
7603: LD_ADDR_VAR 0 9
7607: PUSH
7608: LD_INT 0
7610: ST_TO_ADDR
// x := 0 ;
7611: LD_ADDR_VAR 0 3
7615: PUSH
7616: LD_INT 0
7618: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7619: LD_ADDR_VAR 0 5
7623: PUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 28
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 14
7644: PUSH
7645: LD_INT 1
7647: PUSH
7648: LD_INT 2
7650: PUSH
7651: LD_INT 25
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 14
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: LD_INT 2
7668: PUSH
7669: LD_INT 28
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 14
7680: PUSH
7681: LD_INT 1
7683: PUSH
7684: LD_INT 2
7686: PUSH
7687: LD_INT 29
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
// if Difficulty > 1 then
7702: LD_OWVAR 67
7706: PUSH
7707: LD_INT 1
7709: GREATER
7710: IFFALSE 7807
// for i = 1 to Difficulty + 2 do
7712: LD_ADDR_VAR 0 1
7716: PUSH
7717: DOUBLE
7718: LD_INT 1
7720: DEC
7721: ST_TO_ADDR
7722: LD_OWVAR 67
7726: PUSH
7727: LD_INT 2
7729: PLUS
7730: PUSH
7731: FOR_TO
7732: IFFALSE 7805
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7734: LD_ADDR_VAR 0 5
7738: PUSH
7739: LD_VAR 0 5
7743: PPUSH
7744: LD_VAR 0 5
7748: PUSH
7749: LD_INT 1
7751: PLUS
7752: PPUSH
7753: LD_INT 14
7755: PUSH
7756: LD_INT 1
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 28
7764: PUSH
7765: LD_INT 27
7767: PUSH
7768: LD_INT 27
7770: PUSH
7771: LD_INT 29
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 1
7782: PPUSH
7783: LD_INT 4
7785: PPUSH
7786: CALL_OW 12
7790: ARRAY
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PPUSH
7798: CALL_OW 2
7802: ST_TO_ADDR
7803: GO 7731
7805: POP
7806: POP
// MC_SetProduceList ( base , tmp ) ;
7807: LD_VAR 0 4
7811: PPUSH
7812: LD_VAR 0 5
7816: PPUSH
7817: CALL 70687 0 2
// repeat wait ( 0 0$1 ) ;
7821: LD_INT 35
7823: PPUSH
7824: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7828: LD_VAR 0 4
7832: PPUSH
7833: CALL 71083 0 1
7837: PUSH
7838: LD_INT 0
7840: EQUAL
7841: IFFALSE 7821
// wait ( 0 0$10 ) ;
7843: LD_INT 350
7845: PPUSH
7846: CALL_OW 67
// for i = 1 to coords do
7850: LD_ADDR_VAR 0 1
7854: PUSH
7855: DOUBLE
7856: LD_INT 1
7858: DEC
7859: ST_TO_ADDR
7860: LD_VAR 0 6
7864: PUSH
7865: FOR_TO
7866: IFFALSE 7954
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7868: LD_ADDR_VAR 0 2
7872: PUSH
7873: LD_EXP 3
7877: PPUSH
7878: LD_VAR 0 6
7882: PUSH
7883: LD_VAR 0 1
7887: ARRAY
7888: PUSH
7889: LD_INT 1
7891: ARRAY
7892: PPUSH
7893: LD_VAR 0 6
7897: PUSH
7898: LD_VAR 0 1
7902: ARRAY
7903: PUSH
7904: LD_INT 2
7906: ARRAY
7907: PPUSH
7908: LD_INT 35
7910: PPUSH
7911: CALL 15646 0 4
7915: PUSH
7916: LD_INT 4
7918: ARRAY
7919: ST_TO_ADDR
// if t > x then
7920: LD_VAR 0 2
7924: PUSH
7925: LD_VAR 0 3
7929: GREATER
7930: IFFALSE 7952
// begin x := t ;
7932: LD_ADDR_VAR 0 3
7936: PUSH
7937: LD_VAR 0 2
7941: ST_TO_ADDR
// target := i ;
7942: LD_ADDR_VAR 0 9
7946: PUSH
7947: LD_VAR 0 1
7951: ST_TO_ADDR
// end ; end ;
7952: GO 7865
7954: POP
7955: POP
// case target of 1 :
7956: LD_VAR 0 9
7960: PUSH
7961: LD_INT 1
7963: DOUBLE
7964: EQUAL
7965: IFTRUE 7969
7967: GO 8001
7969: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7970: LD_ADDR_VAR 0 10
7974: PUSH
7975: LD_INT 60
7977: PUSH
7978: LD_INT 8
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PUSH
7985: LD_INT 28
7987: PUSH
7988: LD_INT 15
7990: PUSH
7991: EMPTY
7992: LIST
7993: LIST
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: ST_TO_ADDR
7999: GO 8122
8001: LD_INT 2
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8041
8009: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8010: LD_ADDR_VAR 0 10
8014: PUSH
8015: LD_INT 52
8017: PUSH
8018: LD_INT 11
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 76
8027: PUSH
8028: LD_INT 90
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: ST_TO_ADDR
8039: GO 8122
8041: LD_INT 3
8043: DOUBLE
8044: EQUAL
8045: IFTRUE 8049
8047: GO 8081
8049: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8050: LD_ADDR_VAR 0 10
8054: PUSH
8055: LD_INT 129
8057: PUSH
8058: LD_INT 66
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 130
8067: PUSH
8068: LD_INT 97
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: ST_TO_ADDR
8079: GO 8122
8081: LD_INT 4
8083: DOUBLE
8084: EQUAL
8085: IFTRUE 8089
8087: GO 8121
8089: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8090: LD_ADDR_VAR 0 10
8094: PUSH
8095: LD_INT 156
8097: PUSH
8098: LD_INT 87
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: PUSH
8105: LD_INT 183
8107: PUSH
8108: LD_INT 127
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: ST_TO_ADDR
8119: GO 8122
8121: POP
// if not _target then
8122: LD_VAR 0 10
8126: NOT
8127: IFFALSE 8158
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8129: LD_ADDR_VAR 0 10
8133: PUSH
8134: LD_INT 52
8136: PUSH
8137: LD_INT 11
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: LD_INT 76
8146: PUSH
8147: LD_INT 90
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8158: LD_VAR 0 4
8162: PPUSH
8163: LD_EXP 61
8167: PUSH
8168: LD_VAR 0 4
8172: ARRAY
8173: PPUSH
8174: LD_VAR 0 10
8178: PPUSH
8179: LD_VAR 0 7
8183: PPUSH
8184: CALL 70920 0 4
// end ;
8188: PPOPN 10
8190: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8191: LD_INT 45
8193: PPUSH
8194: CALL_OW 302
8198: PUSH
8199: LD_INT 45
8201: PPUSH
8202: CALL_OW 255
8206: PUSH
8207: LD_EXP 3
8211: EQUAL
8212: AND
8213: PUSH
8214: LD_EXP 26
8218: PUSH
8219: LD_INT 3
8221: EQUAL
8222: PUSH
8223: LD_INT 94
8225: PPUSH
8226: CALL_OW 301
8230: OR
8231: PUSH
8232: LD_INT 94
8234: PPUSH
8235: CALL_OW 255
8239: PUSH
8240: LD_EXP 3
8244: NONEQUAL
8245: OR
8246: AND
8247: IFFALSE 8833
8249: GO 8251
8251: DISABLE
8252: LD_INT 0
8254: PPUSH
8255: PPUSH
8256: PPUSH
8257: PPUSH
8258: PPUSH
8259: PPUSH
8260: PPUSH
8261: PPUSH
8262: PPUSH
8263: PPUSH
// begin enable ;
8264: ENABLE
// base := 2 ;
8265: LD_ADDR_VAR 0 4
8269: PUSH
8270: LD_INT 2
8272: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8273: LD_ADDR_VAR 0 7
8277: PUSH
8278: LD_INT 0
8280: PUSH
8281: LD_INT 0
8283: PUSH
8284: LD_INT 0
8286: PUSH
8287: LD_INT 0
8289: PUSH
8290: LD_INT 1
8292: PUSH
8293: LD_INT 0
8295: PUSH
8296: LD_INT 0
8298: PUSH
8299: LD_INT 0
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 0
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: LIST
8318: LIST
8319: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8320: LD_ADDR_VAR 0 6
8324: PUSH
8325: LD_INT 101
8327: PUSH
8328: LD_INT 110
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PUSH
8335: LD_INT 100
8337: PUSH
8338: LD_INT 21
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: ST_TO_ADDR
// target := 0 ;
8349: LD_ADDR_VAR 0 9
8353: PUSH
8354: LD_INT 0
8356: ST_TO_ADDR
// x := 0 ;
8357: LD_ADDR_VAR 0 3
8361: PUSH
8362: LD_INT 0
8364: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8365: LD_ADDR_VAR 0 5
8369: PUSH
8370: LD_INT 14
8372: PUSH
8373: LD_INT 1
8375: PUSH
8376: LD_INT 2
8378: PUSH
8379: LD_INT 28
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 14
8390: PUSH
8391: LD_INT 1
8393: PUSH
8394: LD_INT 2
8396: PUSH
8397: LD_INT 25
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: PUSH
8406: LD_INT 14
8408: PUSH
8409: LD_INT 1
8411: PUSH
8412: LD_INT 2
8414: PUSH
8415: LD_INT 28
8417: PUSH
8418: EMPTY
8419: LIST
8420: LIST
8421: LIST
8422: LIST
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: LIST
8428: ST_TO_ADDR
// if Difficulty > 1 then
8429: LD_OWVAR 67
8433: PUSH
8434: LD_INT 1
8436: GREATER
8437: IFFALSE 8532
// for i = 1 to Difficulty + 1 do
8439: LD_ADDR_VAR 0 1
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_OWVAR 67
8453: PUSH
8454: LD_INT 1
8456: PLUS
8457: PUSH
8458: FOR_TO
8459: IFFALSE 8530
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8461: LD_ADDR_VAR 0 5
8465: PUSH
8466: LD_VAR 0 5
8470: PPUSH
8471: LD_VAR 0 5
8475: PUSH
8476: LD_INT 1
8478: PLUS
8479: PPUSH
8480: LD_INT 14
8482: PUSH
8483: LD_INT 1
8485: PUSH
8486: LD_INT 2
8488: PUSH
8489: LD_INT 28
8491: PUSH
8492: LD_INT 27
8494: PUSH
8495: LD_INT 27
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_VAR 0 1
8507: PUSH
8508: LD_INT 2
8510: MOD
8511: PUSH
8512: LD_INT 1
8514: PLUS
8515: ARRAY
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 2
8527: ST_TO_ADDR
8528: GO 8458
8530: POP
8531: POP
// MC_SetProduceList ( base , tmp ) ;
8532: LD_VAR 0 4
8536: PPUSH
8537: LD_VAR 0 5
8541: PPUSH
8542: CALL 70687 0 2
// repeat wait ( 0 0$1 ) ;
8546: LD_INT 35
8548: PPUSH
8549: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL 71083 0 1
8562: PUSH
8563: LD_INT 0
8565: EQUAL
8566: IFFALSE 8546
// wait ( 0 0$10 ) ;
8568: LD_INT 350
8570: PPUSH
8571: CALL_OW 67
// for i = 1 to coords do
8575: LD_ADDR_VAR 0 1
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 6
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8679
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8593: LD_ADDR_VAR 0 2
8597: PUSH
8598: LD_EXP 3
8602: PPUSH
8603: LD_VAR 0 6
8607: PUSH
8608: LD_VAR 0 1
8612: ARRAY
8613: PUSH
8614: LD_INT 1
8616: ARRAY
8617: PPUSH
8618: LD_VAR 0 6
8622: PUSH
8623: LD_VAR 0 1
8627: ARRAY
8628: PUSH
8629: LD_INT 2
8631: ARRAY
8632: PPUSH
8633: LD_INT 35
8635: PPUSH
8636: CALL 15646 0 4
8640: PUSH
8641: LD_INT 4
8643: ARRAY
8644: ST_TO_ADDR
// if t > x then
8645: LD_VAR 0 2
8649: PUSH
8650: LD_VAR 0 3
8654: GREATER
8655: IFFALSE 8677
// begin x := t ;
8657: LD_ADDR_VAR 0 3
8661: PUSH
8662: LD_VAR 0 2
8666: ST_TO_ADDR
// target := i ;
8667: LD_ADDR_VAR 0 9
8671: PUSH
8672: LD_VAR 0 1
8676: ST_TO_ADDR
// end ; end ;
8677: GO 8590
8679: POP
8680: POP
// case target of 1 :
8681: LD_VAR 0 9
8685: PUSH
8686: LD_INT 1
8688: DOUBLE
8689: EQUAL
8690: IFTRUE 8694
8692: GO 8726
8694: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8695: LD_ADDR_VAR 0 10
8699: PUSH
8700: LD_INT 49
8702: PUSH
8703: LD_INT 35
8705: PUSH
8706: EMPTY
8707: LIST
8708: LIST
8709: PUSH
8710: LD_INT 76
8712: PUSH
8713: LD_INT 90
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: ST_TO_ADDR
8724: GO 8767
8726: LD_INT 2
8728: DOUBLE
8729: EQUAL
8730: IFTRUE 8734
8732: GO 8766
8734: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8735: LD_ADDR_VAR 0 10
8739: PUSH
8740: LD_INT 79
8742: PUSH
8743: LD_INT 13
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PUSH
8750: LD_INT 100
8752: PUSH
8753: LD_INT 22
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: ST_TO_ADDR
8764: GO 8767
8766: POP
// if not _target then
8767: LD_VAR 0 10
8771: NOT
8772: IFFALSE 8803
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8774: LD_ADDR_VAR 0 10
8778: PUSH
8779: LD_INT 49
8781: PUSH
8782: LD_INT 35
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PUSH
8789: LD_INT 76
8791: PUSH
8792: LD_INT 90
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8803: LD_VAR 0 4
8807: PPUSH
8808: LD_EXP 61
8812: PUSH
8813: LD_VAR 0 4
8817: ARRAY
8818: PPUSH
8819: LD_VAR 0 10
8823: PPUSH
8824: LD_VAR 0 7
8828: PPUSH
8829: CALL 70920 0 4
// end ; end_of_file
8833: PPOPN 10
8835: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8836: LD_INT 0
8838: PPUSH
8839: PPUSH
// begin if artifact_get then
8840: LD_EXP 4
8844: IFFALSE 8848
// exit ;
8846: GO 8870
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8848: LD_VAR 0 1
8852: PPUSH
8853: CALL_OW 255
8857: PPUSH
8858: CALL 5746 0 1
// artifact_get := true ;
8862: LD_ADDR_EXP 4
8866: PUSH
8867: LD_INT 1
8869: ST_TO_ADDR
// end ;
8870: PPOPN 4
8872: END
// on UnitDestroyed ( un ) do var i , side ;
8873: LD_INT 0
8875: PPUSH
8876: PPUSH
// begin side := GetSide ( un ) ;
8877: LD_ADDR_VAR 0 3
8881: PUSH
8882: LD_VAR 0 1
8886: PPUSH
8887: CALL_OW 255
8891: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8892: LD_VAR 0 3
8896: PUSH
8897: LD_EXP 68
8901: IN
8902: NOT
8903: PUSH
8904: LD_EXP 7
8908: PUSH
8909: LD_VAR 0 3
8913: ARRAY
8914: AND
8915: IFFALSE 8941
// if GetType ( un ) = unit_human then
8917: LD_VAR 0 1
8921: PPUSH
8922: CALL_OW 247
8926: PUSH
8927: LD_INT 1
8929: EQUAL
8930: IFFALSE 8941
// MultiplayerEvent_HumanLost ( side ) ;
8932: LD_VAR 0 3
8936: PPUSH
8937: CALL 5386 0 1
// if side in mc_sides then
8941: LD_VAR 0 3
8945: PUSH
8946: LD_EXP 68
8950: IN
8951: IFFALSE 8996
// if un <> Gensher then
8953: LD_VAR 0 1
8957: PUSH
8958: LD_EXP 39
8962: NONEQUAL
8963: IFFALSE 8979
// MultiplayerEvent_UnitKilled ( un , false ) else
8965: LD_VAR 0 1
8969: PPUSH
8970: LD_INT 0
8972: PPUSH
8973: CALL 5500 0 2
8977: GO 8996
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8979: LD_VAR 0 1
8983: PPUSH
8984: LD_INT 5
8986: PPUSH
8987: CALL 4817 0 1
8991: PPUSH
8992: CALL 5500 0 2
// if multi_commanders and multi_custom_commanders then
8996: LD_EXP 24
9000: PUSH
9001: LD_EXP 16
9005: AND
9006: IFFALSE 9068
// if un in multi_commanders then
9008: LD_VAR 0 1
9012: PUSH
9013: LD_EXP 24
9017: IN
9018: IFFALSE 9068
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9020: LD_ADDR_EXP 25
9024: PUSH
9025: LD_EXP 25
9029: PPUSH
9030: LD_VAR 0 3
9034: PPUSH
9035: LD_INT 1
9037: PPUSH
9038: CALL_OW 1
9042: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9043: LD_ADDR_EXP 24
9047: PUSH
9048: LD_EXP 24
9052: PUSH
9053: LD_VAR 0 1
9057: DIFF
9058: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9059: LD_VAR 0 3
9063: PPUSH
9064: CALL 4850 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9068: LD_VAR 0 1
9072: PPUSH
9073: CALL 74146 0 1
// end ;
9077: PPOPN 3
9079: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9080: LD_VAR 0 1
9084: PPUSH
9085: LD_VAR 0 2
9089: PPUSH
9090: CALL 76480 0 2
// end ;
9094: PPOPN 2
9096: END
// on BuildingComplete ( building ) do var i , j ;
9097: LD_INT 0
9099: PPUSH
9100: PPUSH
// begin if GetSide ( building ) in mc_sides then
9101: LD_VAR 0 1
9105: PPUSH
9106: CALL_OW 255
9110: PUSH
9111: LD_EXP 68
9115: IN
9116: IFFALSE 9142
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: CALL_OW 255
9127: PPUSH
9128: LD_VAR 0 1
9132: PPUSH
9133: CALL_OW 266
9137: PPUSH
9138: CALL 5430 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9142: LD_VAR 0 1
9146: PPUSH
9147: CALL_OW 266
9151: PUSH
9152: LD_INT 0
9154: EQUAL
9155: PUSH
9156: LD_VAR 0 1
9160: PPUSH
9161: CALL_OW 255
9165: PUSH
9166: LD_EXP 68
9170: IN
9171: NOT
9172: AND
9173: PUSH
9174: LD_EXP 5
9178: AND
9179: IFFALSE 9217
// begin SetBName ( building , base_names [ 1 ] ) ;
9181: LD_VAR 0 1
9185: PPUSH
9186: LD_EXP 5
9190: PUSH
9191: LD_INT 1
9193: ARRAY
9194: PPUSH
9195: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9199: LD_ADDR_EXP 5
9203: PUSH
9204: LD_EXP 5
9208: PPUSH
9209: LD_INT 1
9211: PPUSH
9212: CALL_OW 3
9216: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9217: LD_VAR 0 1
9221: PPUSH
9222: CALL 75789 0 1
// end ;
9226: PPOPN 3
9228: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9229: LD_VAR 0 1
9233: PPUSH
9234: LD_VAR 0 2
9238: PPUSH
9239: CALL 73842 0 2
// end ;
9243: PPOPN 2
9245: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9246: LD_VAR 0 1
9250: PPUSH
9251: LD_VAR 0 2
9255: PPUSH
9256: LD_VAR 0 3
9260: PPUSH
9261: LD_VAR 0 4
9265: PPUSH
9266: LD_VAR 0 5
9270: PPUSH
9271: CALL 73462 0 5
// end ;
9275: PPOPN 5
9277: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9278: LD_INT 0
9280: PPUSH
9281: PPUSH
9282: PPUSH
// begin side := GetSide ( vehicle ) ;
9283: LD_ADDR_VAR 0 4
9287: PUSH
9288: LD_VAR 0 1
9292: PPUSH
9293: CALL_OW 255
9297: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9298: LD_VAR 0 4
9302: PUSH
9303: LD_EXP 68
9307: IN
9308: NOT
9309: PUSH
9310: LD_EXP 7
9314: PUSH
9315: LD_VAR 0 4
9319: ARRAY
9320: AND
9321: IFFALSE 9332
// MultiplayerEvent_Produced ( side ) ;
9323: LD_VAR 0 4
9327: PPUSH
9328: CALL 5342 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9332: LD_VAR 0 1
9336: PPUSH
9337: LD_VAR 0 2
9341: PPUSH
9342: CALL 73052 0 2
// end ;
9346: PPOPN 5
9348: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9349: LD_VAR 0 1
9353: PPUSH
9354: LD_VAR 0 2
9358: PPUSH
9359: LD_VAR 0 3
9363: PPUSH
9364: LD_VAR 0 4
9368: PPUSH
9369: CALL 72890 0 4
// end ;
9373: PPOPN 4
9375: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9376: LD_VAR 0 1
9380: PPUSH
9381: LD_VAR 0 2
9385: PPUSH
9386: LD_VAR 0 3
9390: PPUSH
9391: CALL 72665 0 3
// end ;
9395: PPOPN 3
9397: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9398: LD_VAR 0 1
9402: PPUSH
9403: LD_VAR 0 2
9407: PPUSH
9408: CALL 72550 0 2
// end ;
9412: PPOPN 2
9414: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9415: LD_VAR 0 1
9419: PPUSH
9420: LD_VAR 0 2
9424: PPUSH
9425: CALL 76741 0 2
// end ;
9429: PPOPN 2
9431: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9432: LD_VAR 0 1
9436: PPUSH
9437: LD_VAR 0 2
9441: PPUSH
9442: LD_VAR 0 3
9446: PPUSH
9447: LD_VAR 0 4
9451: PPUSH
9452: CALL 76957 0 4
// end ; end_of_file
9456: PPOPN 4
9458: END
// every 0 0$1 trigger game do
9459: LD_EXP 2
9463: IFFALSE 9508
9465: GO 9467
9467: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9468: LD_INT 7
9470: PUSH
9471: LD_INT 6
9473: PUSH
9474: LD_INT 4
9476: PUSH
9477: LD_INT 6
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PPUSH
9486: LD_EXP 21
9490: PUSH
9491: LD_INT 2
9493: ARRAY
9494: PPUSH
9495: LD_EXP 21
9499: PUSH
9500: LD_INT 1
9502: ARRAY
9503: PPUSH
9504: CALL 9509 0 3
9508: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9509: LD_INT 0
9511: PPUSH
9512: PPUSH
9513: PPUSH
9514: PPUSH
// if not areas then
9515: LD_VAR 0 1
9519: NOT
9520: IFFALSE 9524
// exit ;
9522: GO 9799
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9524: LD_ADDR_VAR 0 7
9528: PUSH
9529: LD_INT 31
9531: PUSH
9532: LD_INT 32
9534: PUSH
9535: LD_INT 30
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: ST_TO_ADDR
// repeat wait ( time ) ;
9543: LD_VAR 0 2
9547: PPUSH
9548: CALL_OW 67
// x := 5 ;
9552: LD_ADDR_VAR 0 6
9556: PUSH
9557: LD_INT 5
9559: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9560: LD_OWVAR 1
9564: PUSH
9565: LD_INT 42000
9567: PUSH
9568: LD_INT 37800
9570: PUSH
9571: LD_INT 29400
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: PUSH
9579: LD_OWVAR 67
9583: ARRAY
9584: LESS
9585: IFFALSE 9657
// begin for i = 1 to multi_sides do
9587: LD_ADDR_VAR 0 5
9591: PUSH
9592: DOUBLE
9593: LD_INT 1
9595: DEC
9596: ST_TO_ADDR
9597: LD_EXP 7
9601: PUSH
9602: FOR_TO
9603: IFFALSE 9648
// if multi_sides [ i ] then
9605: LD_EXP 7
9609: PUSH
9610: LD_VAR 0 5
9614: ARRAY
9615: IFFALSE 9646
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9617: LD_VAR 0 6
9621: PPUSH
9622: LD_VAR 0 7
9626: PUSH
9627: LD_EXP 7
9631: PUSH
9632: LD_VAR 0 5
9636: ARRAY
9637: ARRAY
9638: PPUSH
9639: LD_INT 1
9641: PPUSH
9642: CALL_OW 55
9646: GO 9602
9648: POP
9649: POP
// wait ( 0 0$6 ) ;
9650: LD_INT 210
9652: PPUSH
9653: CALL_OW 67
// end ; for i in areas do
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: FOR_IN
9668: IFFALSE 9696
// begin wait ( 0 0$6 ) ;
9670: LD_INT 210
9672: PPUSH
9673: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9677: LD_VAR 0 6
9681: PPUSH
9682: LD_VAR 0 5
9686: PPUSH
9687: LD_INT 1
9689: PPUSH
9690: CALL_OW 55
// end ;
9694: GO 9667
9696: POP
9697: POP
// time := time + 0 0$2 ;
9698: LD_ADDR_VAR 0 2
9702: PUSH
9703: LD_VAR 0 2
9707: PUSH
9708: LD_INT 70
9710: PLUS
9711: ST_TO_ADDR
// amount := amount - x * 10 ;
9712: LD_ADDR_VAR 0 3
9716: PUSH
9717: LD_VAR 0 3
9721: PUSH
9722: LD_VAR 0 6
9726: PUSH
9727: LD_INT 10
9729: MUL
9730: MINUS
9731: ST_TO_ADDR
// x := x - 1 ;
9732: LD_ADDR_VAR 0 6
9736: PUSH
9737: LD_VAR 0 6
9741: PUSH
9742: LD_INT 1
9744: MINUS
9745: ST_TO_ADDR
// if x = 0 then
9746: LD_VAR 0 6
9750: PUSH
9751: LD_INT 0
9753: EQUAL
9754: IFFALSE 9764
// x := 5 ;
9756: LD_ADDR_VAR 0 6
9760: PUSH
9761: LD_INT 5
9763: ST_TO_ADDR
// if time > 4 4$00 then
9764: LD_VAR 0 2
9768: PUSH
9769: LD_INT 8400
9771: GREATER
9772: IFFALSE 9782
// time := 0 0$40 ;
9774: LD_ADDR_VAR 0 2
9778: PUSH
9779: LD_INT 1400
9781: ST_TO_ADDR
// until not game or amount <= 0 ;
9782: LD_EXP 2
9786: NOT
9787: PUSH
9788: LD_VAR 0 3
9792: PUSH
9793: LD_INT 0
9795: LESSEQUAL
9796: OR
9797: IFFALSE 9543
// end ; end_of_file
9799: LD_VAR 0 4
9803: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9804: LD_INT 0
9806: PPUSH
9807: PPUSH
// if exist_mode then
9808: LD_VAR 0 2
9812: IFFALSE 9837
// unit := CreateCharacter ( prefix & ident ) else
9814: LD_ADDR_VAR 0 5
9818: PUSH
9819: LD_VAR 0 3
9823: PUSH
9824: LD_VAR 0 1
9828: STR
9829: PPUSH
9830: CALL_OW 34
9834: ST_TO_ADDR
9835: GO 9852
// unit := NewCharacter ( ident ) ;
9837: LD_ADDR_VAR 0 5
9841: PUSH
9842: LD_VAR 0 1
9846: PPUSH
9847: CALL_OW 25
9851: ST_TO_ADDR
// result := unit ;
9852: LD_ADDR_VAR 0 4
9856: PUSH
9857: LD_VAR 0 5
9861: ST_TO_ADDR
// end ;
9862: LD_VAR 0 4
9866: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9867: LD_INT 0
9869: PPUSH
9870: PPUSH
// if not side or not nation then
9871: LD_VAR 0 1
9875: NOT
9876: PUSH
9877: LD_VAR 0 2
9881: NOT
9882: OR
9883: IFFALSE 9887
// exit ;
9885: GO 10651
// case nation of nation_american :
9887: LD_VAR 0 2
9891: PUSH
9892: LD_INT 1
9894: DOUBLE
9895: EQUAL
9896: IFTRUE 9900
9898: GO 10114
9900: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9901: LD_ADDR_VAR 0 4
9905: PUSH
9906: LD_INT 35
9908: PUSH
9909: LD_INT 45
9911: PUSH
9912: LD_INT 46
9914: PUSH
9915: LD_INT 47
9917: PUSH
9918: LD_INT 82
9920: PUSH
9921: LD_INT 83
9923: PUSH
9924: LD_INT 84
9926: PUSH
9927: LD_INT 85
9929: PUSH
9930: LD_INT 86
9932: PUSH
9933: LD_INT 1
9935: PUSH
9936: LD_INT 2
9938: PUSH
9939: LD_INT 6
9941: PUSH
9942: LD_INT 15
9944: PUSH
9945: LD_INT 16
9947: PUSH
9948: LD_INT 7
9950: PUSH
9951: LD_INT 12
9953: PUSH
9954: LD_INT 13
9956: PUSH
9957: LD_INT 10
9959: PUSH
9960: LD_INT 14
9962: PUSH
9963: LD_INT 20
9965: PUSH
9966: LD_INT 21
9968: PUSH
9969: LD_INT 22
9971: PUSH
9972: LD_INT 25
9974: PUSH
9975: LD_INT 32
9977: PUSH
9978: LD_INT 27
9980: PUSH
9981: LD_INT 36
9983: PUSH
9984: LD_INT 69
9986: PUSH
9987: LD_INT 39
9989: PUSH
9990: LD_INT 34
9992: PUSH
9993: LD_INT 40
9995: PUSH
9996: LD_INT 48
9998: PUSH
9999: LD_INT 49
10001: PUSH
10002: LD_INT 50
10004: PUSH
10005: LD_INT 51
10007: PUSH
10008: LD_INT 52
10010: PUSH
10011: LD_INT 53
10013: PUSH
10014: LD_INT 54
10016: PUSH
10017: LD_INT 55
10019: PUSH
10020: LD_INT 56
10022: PUSH
10023: LD_INT 57
10025: PUSH
10026: LD_INT 58
10028: PUSH
10029: LD_INT 59
10031: PUSH
10032: LD_INT 60
10034: PUSH
10035: LD_INT 61
10037: PUSH
10038: LD_INT 62
10040: PUSH
10041: LD_INT 80
10043: PUSH
10044: LD_INT 82
10046: PUSH
10047: LD_INT 83
10049: PUSH
10050: LD_INT 84
10052: PUSH
10053: LD_INT 85
10055: PUSH
10056: LD_INT 86
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: ST_TO_ADDR
10112: GO 10575
10114: LD_INT 2
10116: DOUBLE
10117: EQUAL
10118: IFTRUE 10122
10120: GO 10344
10122: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10123: LD_ADDR_VAR 0 4
10127: PUSH
10128: LD_INT 35
10130: PUSH
10131: LD_INT 45
10133: PUSH
10134: LD_INT 46
10136: PUSH
10137: LD_INT 47
10139: PUSH
10140: LD_INT 82
10142: PUSH
10143: LD_INT 83
10145: PUSH
10146: LD_INT 84
10148: PUSH
10149: LD_INT 85
10151: PUSH
10152: LD_INT 87
10154: PUSH
10155: LD_INT 70
10157: PUSH
10158: LD_INT 1
10160: PUSH
10161: LD_INT 11
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: LD_INT 4
10169: PUSH
10170: LD_INT 5
10172: PUSH
10173: LD_INT 6
10175: PUSH
10176: LD_INT 15
10178: PUSH
10179: LD_INT 18
10181: PUSH
10182: LD_INT 7
10184: PUSH
10185: LD_INT 17
10187: PUSH
10188: LD_INT 8
10190: PUSH
10191: LD_INT 20
10193: PUSH
10194: LD_INT 21
10196: PUSH
10197: LD_INT 22
10199: PUSH
10200: LD_INT 72
10202: PUSH
10203: LD_INT 26
10205: PUSH
10206: LD_INT 69
10208: PUSH
10209: LD_INT 39
10211: PUSH
10212: LD_INT 40
10214: PUSH
10215: LD_INT 41
10217: PUSH
10218: LD_INT 42
10220: PUSH
10221: LD_INT 43
10223: PUSH
10224: LD_INT 48
10226: PUSH
10227: LD_INT 49
10229: PUSH
10230: LD_INT 50
10232: PUSH
10233: LD_INT 51
10235: PUSH
10236: LD_INT 52
10238: PUSH
10239: LD_INT 53
10241: PUSH
10242: LD_INT 54
10244: PUSH
10245: LD_INT 55
10247: PUSH
10248: LD_INT 56
10250: PUSH
10251: LD_INT 60
10253: PUSH
10254: LD_INT 61
10256: PUSH
10257: LD_INT 62
10259: PUSH
10260: LD_INT 66
10262: PUSH
10263: LD_INT 67
10265: PUSH
10266: LD_INT 68
10268: PUSH
10269: LD_INT 81
10271: PUSH
10272: LD_INT 82
10274: PUSH
10275: LD_INT 83
10277: PUSH
10278: LD_INT 84
10280: PUSH
10281: LD_INT 85
10283: PUSH
10284: LD_INT 87
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: ST_TO_ADDR
10342: GO 10575
10344: LD_INT 3
10346: DOUBLE
10347: EQUAL
10348: IFTRUE 10352
10350: GO 10574
10352: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10353: LD_ADDR_VAR 0 4
10357: PUSH
10358: LD_INT 46
10360: PUSH
10361: LD_INT 47
10363: PUSH
10364: LD_INT 1
10366: PUSH
10367: LD_INT 2
10369: PUSH
10370: LD_INT 82
10372: PUSH
10373: LD_INT 83
10375: PUSH
10376: LD_INT 84
10378: PUSH
10379: LD_INT 85
10381: PUSH
10382: LD_INT 86
10384: PUSH
10385: LD_INT 11
10387: PUSH
10388: LD_INT 9
10390: PUSH
10391: LD_INT 20
10393: PUSH
10394: LD_INT 19
10396: PUSH
10397: LD_INT 21
10399: PUSH
10400: LD_INT 24
10402: PUSH
10403: LD_INT 22
10405: PUSH
10406: LD_INT 25
10408: PUSH
10409: LD_INT 28
10411: PUSH
10412: LD_INT 29
10414: PUSH
10415: LD_INT 30
10417: PUSH
10418: LD_INT 31
10420: PUSH
10421: LD_INT 37
10423: PUSH
10424: LD_INT 38
10426: PUSH
10427: LD_INT 32
10429: PUSH
10430: LD_INT 27
10432: PUSH
10433: LD_INT 33
10435: PUSH
10436: LD_INT 69
10438: PUSH
10439: LD_INT 39
10441: PUSH
10442: LD_INT 34
10444: PUSH
10445: LD_INT 40
10447: PUSH
10448: LD_INT 71
10450: PUSH
10451: LD_INT 23
10453: PUSH
10454: LD_INT 44
10456: PUSH
10457: LD_INT 48
10459: PUSH
10460: LD_INT 49
10462: PUSH
10463: LD_INT 50
10465: PUSH
10466: LD_INT 51
10468: PUSH
10469: LD_INT 52
10471: PUSH
10472: LD_INT 53
10474: PUSH
10475: LD_INT 54
10477: PUSH
10478: LD_INT 55
10480: PUSH
10481: LD_INT 56
10483: PUSH
10484: LD_INT 57
10486: PUSH
10487: LD_INT 58
10489: PUSH
10490: LD_INT 59
10492: PUSH
10493: LD_INT 63
10495: PUSH
10496: LD_INT 64
10498: PUSH
10499: LD_INT 65
10501: PUSH
10502: LD_INT 82
10504: PUSH
10505: LD_INT 83
10507: PUSH
10508: LD_INT 84
10510: PUSH
10511: LD_INT 85
10513: PUSH
10514: LD_INT 86
10516: PUSH
10517: EMPTY
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: ST_TO_ADDR
10572: GO 10575
10574: POP
// if state > - 1 and state < 3 then
10575: LD_VAR 0 3
10579: PUSH
10580: LD_INT 1
10582: NEG
10583: GREATER
10584: PUSH
10585: LD_VAR 0 3
10589: PUSH
10590: LD_INT 3
10592: LESS
10593: AND
10594: IFFALSE 10651
// for i in result do
10596: LD_ADDR_VAR 0 5
10600: PUSH
10601: LD_VAR 0 4
10605: PUSH
10606: FOR_IN
10607: IFFALSE 10649
// if GetTech ( i , side ) <> state then
10609: LD_VAR 0 5
10613: PPUSH
10614: LD_VAR 0 1
10618: PPUSH
10619: CALL_OW 321
10623: PUSH
10624: LD_VAR 0 3
10628: NONEQUAL
10629: IFFALSE 10647
// result := result diff i ;
10631: LD_ADDR_VAR 0 4
10635: PUSH
10636: LD_VAR 0 4
10640: PUSH
10641: LD_VAR 0 5
10645: DIFF
10646: ST_TO_ADDR
10647: GO 10606
10649: POP
10650: POP
// end ;
10651: LD_VAR 0 4
10655: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10656: LD_INT 0
10658: PPUSH
10659: PPUSH
10660: PPUSH
// result := true ;
10661: LD_ADDR_VAR 0 3
10665: PUSH
10666: LD_INT 1
10668: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10669: LD_ADDR_VAR 0 5
10673: PUSH
10674: LD_VAR 0 2
10678: PPUSH
10679: CALL_OW 480
10683: ST_TO_ADDR
// if not tmp then
10684: LD_VAR 0 5
10688: NOT
10689: IFFALSE 10693
// exit ;
10691: GO 10742
// for i in tmp do
10693: LD_ADDR_VAR 0 4
10697: PUSH
10698: LD_VAR 0 5
10702: PUSH
10703: FOR_IN
10704: IFFALSE 10740
// if GetTech ( i , side ) <> state_researched then
10706: LD_VAR 0 4
10710: PPUSH
10711: LD_VAR 0 1
10715: PPUSH
10716: CALL_OW 321
10720: PUSH
10721: LD_INT 2
10723: NONEQUAL
10724: IFFALSE 10738
// begin result := false ;
10726: LD_ADDR_VAR 0 3
10730: PUSH
10731: LD_INT 0
10733: ST_TO_ADDR
// exit ;
10734: POP
10735: POP
10736: GO 10742
// end ;
10738: GO 10703
10740: POP
10741: POP
// end ;
10742: LD_VAR 0 3
10746: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10747: LD_INT 0
10749: PPUSH
10750: PPUSH
10751: PPUSH
10752: PPUSH
10753: PPUSH
10754: PPUSH
10755: PPUSH
10756: PPUSH
10757: PPUSH
10758: PPUSH
10759: PPUSH
10760: PPUSH
10761: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10762: LD_VAR 0 1
10766: NOT
10767: PUSH
10768: LD_VAR 0 1
10772: PPUSH
10773: CALL_OW 257
10777: PUSH
10778: LD_INT 9
10780: NONEQUAL
10781: OR
10782: IFFALSE 10786
// exit ;
10784: GO 11359
// side := GetSide ( unit ) ;
10786: LD_ADDR_VAR 0 9
10790: PUSH
10791: LD_VAR 0 1
10795: PPUSH
10796: CALL_OW 255
10800: ST_TO_ADDR
// tech_space := tech_spacanom ;
10801: LD_ADDR_VAR 0 12
10805: PUSH
10806: LD_INT 29
10808: ST_TO_ADDR
// tech_time := tech_taurad ;
10809: LD_ADDR_VAR 0 13
10813: PUSH
10814: LD_INT 28
10816: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10817: LD_ADDR_VAR 0 11
10821: PUSH
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 310
10831: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10832: LD_VAR 0 11
10836: PPUSH
10837: CALL_OW 247
10841: PUSH
10842: LD_INT 2
10844: EQUAL
10845: IFFALSE 10849
// exit ;
10847: GO 11359
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10849: LD_ADDR_VAR 0 8
10853: PUSH
10854: LD_INT 81
10856: PUSH
10857: LD_VAR 0 9
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PUSH
10866: LD_INT 3
10868: PUSH
10869: LD_INT 21
10871: PUSH
10872: LD_INT 3
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL_OW 69
10891: ST_TO_ADDR
// if not tmp then
10892: LD_VAR 0 8
10896: NOT
10897: IFFALSE 10901
// exit ;
10899: GO 11359
// if in_unit then
10901: LD_VAR 0 11
10905: IFFALSE 10929
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10907: LD_ADDR_VAR 0 10
10911: PUSH
10912: LD_VAR 0 8
10916: PPUSH
10917: LD_VAR 0 11
10921: PPUSH
10922: CALL_OW 74
10926: ST_TO_ADDR
10927: GO 10949
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10929: LD_ADDR_VAR 0 10
10933: PUSH
10934: LD_VAR 0 8
10938: PPUSH
10939: LD_VAR 0 1
10943: PPUSH
10944: CALL_OW 74
10948: ST_TO_ADDR
// if not enemy then
10949: LD_VAR 0 10
10953: NOT
10954: IFFALSE 10958
// exit ;
10956: GO 11359
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10958: LD_VAR 0 11
10962: PUSH
10963: LD_VAR 0 11
10967: PPUSH
10968: LD_VAR 0 10
10972: PPUSH
10973: CALL_OW 296
10977: PUSH
10978: LD_INT 13
10980: GREATER
10981: AND
10982: PUSH
10983: LD_VAR 0 1
10987: PPUSH
10988: LD_VAR 0 10
10992: PPUSH
10993: CALL_OW 296
10997: PUSH
10998: LD_INT 12
11000: GREATER
11001: OR
11002: IFFALSE 11006
// exit ;
11004: GO 11359
// missile := [ 1 ] ;
11006: LD_ADDR_VAR 0 14
11010: PUSH
11011: LD_INT 1
11013: PUSH
11014: EMPTY
11015: LIST
11016: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11017: LD_VAR 0 9
11021: PPUSH
11022: LD_VAR 0 12
11026: PPUSH
11027: CALL_OW 325
11031: IFFALSE 11060
// missile := Insert ( missile , missile + 1 , 2 ) ;
11033: LD_ADDR_VAR 0 14
11037: PUSH
11038: LD_VAR 0 14
11042: PPUSH
11043: LD_VAR 0 14
11047: PUSH
11048: LD_INT 1
11050: PLUS
11051: PPUSH
11052: LD_INT 2
11054: PPUSH
11055: CALL_OW 2
11059: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11060: LD_VAR 0 9
11064: PPUSH
11065: LD_VAR 0 13
11069: PPUSH
11070: CALL_OW 325
11074: PUSH
11075: LD_VAR 0 10
11079: PPUSH
11080: CALL_OW 255
11084: PPUSH
11085: LD_VAR 0 13
11089: PPUSH
11090: CALL_OW 325
11094: NOT
11095: AND
11096: IFFALSE 11125
// missile := Insert ( missile , missile + 1 , 3 ) ;
11098: LD_ADDR_VAR 0 14
11102: PUSH
11103: LD_VAR 0 14
11107: PPUSH
11108: LD_VAR 0 14
11112: PUSH
11113: LD_INT 1
11115: PLUS
11116: PPUSH
11117: LD_INT 3
11119: PPUSH
11120: CALL_OW 2
11124: ST_TO_ADDR
// if missile < 2 then
11125: LD_VAR 0 14
11129: PUSH
11130: LD_INT 2
11132: LESS
11133: IFFALSE 11137
// exit ;
11135: GO 11359
// x := GetX ( enemy ) ;
11137: LD_ADDR_VAR 0 4
11141: PUSH
11142: LD_VAR 0 10
11146: PPUSH
11147: CALL_OW 250
11151: ST_TO_ADDR
// y := GetY ( enemy ) ;
11152: LD_ADDR_VAR 0 5
11156: PUSH
11157: LD_VAR 0 10
11161: PPUSH
11162: CALL_OW 251
11166: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11167: LD_ADDR_VAR 0 6
11171: PUSH
11172: LD_VAR 0 4
11176: PUSH
11177: LD_INT 1
11179: NEG
11180: PPUSH
11181: LD_INT 1
11183: PPUSH
11184: CALL_OW 12
11188: PLUS
11189: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11190: LD_ADDR_VAR 0 7
11194: PUSH
11195: LD_VAR 0 5
11199: PUSH
11200: LD_INT 1
11202: NEG
11203: PPUSH
11204: LD_INT 1
11206: PPUSH
11207: CALL_OW 12
11211: PLUS
11212: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11213: LD_VAR 0 6
11217: PPUSH
11218: LD_VAR 0 7
11222: PPUSH
11223: CALL_OW 488
11227: NOT
11228: IFFALSE 11250
// begin _x := x ;
11230: LD_ADDR_VAR 0 6
11234: PUSH
11235: LD_VAR 0 4
11239: ST_TO_ADDR
// _y := y ;
11240: LD_ADDR_VAR 0 7
11244: PUSH
11245: LD_VAR 0 5
11249: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11250: LD_ADDR_VAR 0 3
11254: PUSH
11255: LD_INT 1
11257: PPUSH
11258: LD_VAR 0 14
11262: PPUSH
11263: CALL_OW 12
11267: ST_TO_ADDR
// case i of 1 :
11268: LD_VAR 0 3
11272: PUSH
11273: LD_INT 1
11275: DOUBLE
11276: EQUAL
11277: IFTRUE 11281
11279: GO 11298
11281: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11282: LD_VAR 0 1
11286: PPUSH
11287: LD_VAR 0 10
11291: PPUSH
11292: CALL_OW 115
11296: GO 11359
11298: LD_INT 2
11300: DOUBLE
11301: EQUAL
11302: IFTRUE 11306
11304: GO 11328
11306: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11307: LD_VAR 0 1
11311: PPUSH
11312: LD_VAR 0 6
11316: PPUSH
11317: LD_VAR 0 7
11321: PPUSH
11322: CALL_OW 153
11326: GO 11359
11328: LD_INT 3
11330: DOUBLE
11331: EQUAL
11332: IFTRUE 11336
11334: GO 11358
11336: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11337: LD_VAR 0 1
11341: PPUSH
11342: LD_VAR 0 6
11346: PPUSH
11347: LD_VAR 0 7
11351: PPUSH
11352: CALL_OW 154
11356: GO 11359
11358: POP
// end ;
11359: LD_VAR 0 2
11363: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11364: LD_INT 0
11366: PPUSH
11367: PPUSH
11368: PPUSH
11369: PPUSH
11370: PPUSH
11371: PPUSH
// if not unit or not building then
11372: LD_VAR 0 1
11376: NOT
11377: PUSH
11378: LD_VAR 0 2
11382: NOT
11383: OR
11384: IFFALSE 11388
// exit ;
11386: GO 11546
// x := GetX ( building ) ;
11388: LD_ADDR_VAR 0 5
11392: PUSH
11393: LD_VAR 0 2
11397: PPUSH
11398: CALL_OW 250
11402: ST_TO_ADDR
// y := GetY ( building ) ;
11403: LD_ADDR_VAR 0 6
11407: PUSH
11408: LD_VAR 0 2
11412: PPUSH
11413: CALL_OW 251
11417: ST_TO_ADDR
// for i = 0 to 5 do
11418: LD_ADDR_VAR 0 4
11422: PUSH
11423: DOUBLE
11424: LD_INT 0
11426: DEC
11427: ST_TO_ADDR
11428: LD_INT 5
11430: PUSH
11431: FOR_TO
11432: IFFALSE 11544
// begin _x := ShiftX ( x , i , 3 ) ;
11434: LD_ADDR_VAR 0 7
11438: PUSH
11439: LD_VAR 0 5
11443: PPUSH
11444: LD_VAR 0 4
11448: PPUSH
11449: LD_INT 3
11451: PPUSH
11452: CALL_OW 272
11456: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11457: LD_ADDR_VAR 0 8
11461: PUSH
11462: LD_VAR 0 6
11466: PPUSH
11467: LD_VAR 0 4
11471: PPUSH
11472: LD_INT 3
11474: PPUSH
11475: CALL_OW 273
11479: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11480: LD_VAR 0 7
11484: PPUSH
11485: LD_VAR 0 8
11489: PPUSH
11490: CALL_OW 488
11494: NOT
11495: IFFALSE 11499
// continue ;
11497: GO 11431
// if HexInfo ( _x , _y ) = 0 then
11499: LD_VAR 0 7
11503: PPUSH
11504: LD_VAR 0 8
11508: PPUSH
11509: CALL_OW 428
11513: PUSH
11514: LD_INT 0
11516: EQUAL
11517: IFFALSE 11542
// begin ComMoveXY ( unit , _x , _y ) ;
11519: LD_VAR 0 1
11523: PPUSH
11524: LD_VAR 0 7
11528: PPUSH
11529: LD_VAR 0 8
11533: PPUSH
11534: CALL_OW 111
// exit ;
11538: POP
11539: POP
11540: GO 11546
// end ; end ;
11542: GO 11431
11544: POP
11545: POP
// end ;
11546: LD_VAR 0 3
11550: RET
// export function ScanBase ( side , base_area ) ; begin
11551: LD_INT 0
11553: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11554: LD_ADDR_VAR 0 3
11558: PUSH
11559: LD_VAR 0 2
11563: PPUSH
11564: LD_INT 81
11566: PUSH
11567: LD_VAR 0 1
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PPUSH
11576: CALL_OW 70
11580: ST_TO_ADDR
// end ;
11581: LD_VAR 0 3
11585: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11586: LD_INT 0
11588: PPUSH
11589: PPUSH
11590: PPUSH
11591: PPUSH
// result := false ;
11592: LD_ADDR_VAR 0 2
11596: PUSH
11597: LD_INT 0
11599: ST_TO_ADDR
// side := GetSide ( unit ) ;
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: LD_VAR 0 1
11609: PPUSH
11610: CALL_OW 255
11614: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11615: LD_ADDR_VAR 0 4
11619: PUSH
11620: LD_VAR 0 1
11624: PPUSH
11625: CALL_OW 248
11629: ST_TO_ADDR
// case nat of 1 :
11630: LD_VAR 0 4
11634: PUSH
11635: LD_INT 1
11637: DOUBLE
11638: EQUAL
11639: IFTRUE 11643
11641: GO 11654
11643: POP
// tech := tech_lassight ; 2 :
11644: LD_ADDR_VAR 0 5
11648: PUSH
11649: LD_INT 12
11651: ST_TO_ADDR
11652: GO 11693
11654: LD_INT 2
11656: DOUBLE
11657: EQUAL
11658: IFTRUE 11662
11660: GO 11673
11662: POP
// tech := tech_mortar ; 3 :
11663: LD_ADDR_VAR 0 5
11667: PUSH
11668: LD_INT 41
11670: ST_TO_ADDR
11671: GO 11693
11673: LD_INT 3
11675: DOUBLE
11676: EQUAL
11677: IFTRUE 11681
11679: GO 11692
11681: POP
// tech := tech_bazooka ; end ;
11682: LD_ADDR_VAR 0 5
11686: PUSH
11687: LD_INT 44
11689: ST_TO_ADDR
11690: GO 11693
11692: POP
// if Researched ( side , tech ) then
11693: LD_VAR 0 3
11697: PPUSH
11698: LD_VAR 0 5
11702: PPUSH
11703: CALL_OW 325
11707: IFFALSE 11734
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 5
11716: PUSH
11717: LD_INT 8
11719: PUSH
11720: LD_INT 9
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: LIST
11727: PUSH
11728: LD_VAR 0 4
11732: ARRAY
11733: ST_TO_ADDR
// end ;
11734: LD_VAR 0 2
11738: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11739: LD_INT 0
11741: PPUSH
11742: PPUSH
11743: PPUSH
// if not mines then
11744: LD_VAR 0 2
11748: NOT
11749: IFFALSE 11753
// exit ;
11751: GO 11897
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11753: LD_ADDR_VAR 0 5
11757: PUSH
11758: LD_INT 81
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: LD_INT 21
11775: PUSH
11776: LD_INT 3
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PPUSH
11791: CALL_OW 69
11795: ST_TO_ADDR
// for i in mines do
11796: LD_ADDR_VAR 0 4
11800: PUSH
11801: LD_VAR 0 2
11805: PUSH
11806: FOR_IN
11807: IFFALSE 11895
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11809: LD_VAR 0 4
11813: PUSH
11814: LD_INT 1
11816: ARRAY
11817: PPUSH
11818: LD_VAR 0 4
11822: PUSH
11823: LD_INT 2
11825: ARRAY
11826: PPUSH
11827: CALL_OW 458
11831: NOT
11832: IFFALSE 11836
// continue ;
11834: GO 11806
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11836: LD_VAR 0 4
11840: PUSH
11841: LD_INT 1
11843: ARRAY
11844: PPUSH
11845: LD_VAR 0 4
11849: PUSH
11850: LD_INT 2
11852: ARRAY
11853: PPUSH
11854: CALL_OW 428
11858: PUSH
11859: LD_VAR 0 5
11863: IN
11864: IFFALSE 11893
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11866: LD_VAR 0 4
11870: PUSH
11871: LD_INT 1
11873: ARRAY
11874: PPUSH
11875: LD_VAR 0 4
11879: PUSH
11880: LD_INT 2
11882: ARRAY
11883: PPUSH
11884: LD_VAR 0 1
11888: PPUSH
11889: CALL_OW 456
// end ;
11893: GO 11806
11895: POP
11896: POP
// end ;
11897: LD_VAR 0 3
11901: RET
// export function Count ( array ) ; var i ; begin
11902: LD_INT 0
11904: PPUSH
11905: PPUSH
// result := 0 ;
11906: LD_ADDR_VAR 0 2
11910: PUSH
11911: LD_INT 0
11913: ST_TO_ADDR
// for i in array do
11914: LD_ADDR_VAR 0 3
11918: PUSH
11919: LD_VAR 0 1
11923: PUSH
11924: FOR_IN
11925: IFFALSE 11949
// if i then
11927: LD_VAR 0 3
11931: IFFALSE 11947
// result := result + 1 ;
11933: LD_ADDR_VAR 0 2
11937: PUSH
11938: LD_VAR 0 2
11942: PUSH
11943: LD_INT 1
11945: PLUS
11946: ST_TO_ADDR
11947: GO 11924
11949: POP
11950: POP
// end ;
11951: LD_VAR 0 2
11955: RET
// export function IsEmpty ( building ) ; begin
11956: LD_INT 0
11958: PPUSH
// if not building then
11959: LD_VAR 0 1
11963: NOT
11964: IFFALSE 11968
// exit ;
11966: GO 12011
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11968: LD_ADDR_VAR 0 2
11972: PUSH
11973: LD_VAR 0 1
11977: PUSH
11978: LD_INT 22
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: CALL_OW 255
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: PUSH
11995: LD_INT 58
11997: PUSH
11998: EMPTY
11999: LIST
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: IN
12010: ST_TO_ADDR
// end ;
12011: LD_VAR 0 2
12015: RET
// export function IsNotFull ( building ) ; begin
12016: LD_INT 0
12018: PPUSH
// if not building then
12019: LD_VAR 0 1
12023: NOT
12024: IFFALSE 12028
// exit ;
12026: GO 12047
// result := UnitsInside ( building ) < 6 ;
12028: LD_ADDR_VAR 0 2
12032: PUSH
12033: LD_VAR 0 1
12037: PPUSH
12038: CALL_OW 313
12042: PUSH
12043: LD_INT 6
12045: LESS
12046: ST_TO_ADDR
// end ;
12047: LD_VAR 0 2
12051: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12052: LD_INT 0
12054: PPUSH
12055: PPUSH
12056: PPUSH
12057: PPUSH
// tmp := [ ] ;
12058: LD_ADDR_VAR 0 3
12062: PUSH
12063: EMPTY
12064: ST_TO_ADDR
// list := [ ] ;
12065: LD_ADDR_VAR 0 5
12069: PUSH
12070: EMPTY
12071: ST_TO_ADDR
// for i = 16 to 25 do
12072: LD_ADDR_VAR 0 4
12076: PUSH
12077: DOUBLE
12078: LD_INT 16
12080: DEC
12081: ST_TO_ADDR
12082: LD_INT 25
12084: PUSH
12085: FOR_TO
12086: IFFALSE 12159
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12088: LD_ADDR_VAR 0 3
12092: PUSH
12093: LD_VAR 0 3
12097: PUSH
12098: LD_INT 22
12100: PUSH
12101: LD_VAR 0 1
12105: PPUSH
12106: CALL_OW 255
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: LD_INT 91
12117: PUSH
12118: LD_VAR 0 1
12122: PUSH
12123: LD_INT 6
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: PUSH
12131: LD_INT 30
12133: PUSH
12134: LD_VAR 0 4
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: PUSH
12148: EMPTY
12149: LIST
12150: PPUSH
12151: CALL_OW 69
12155: ADD
12156: ST_TO_ADDR
12157: GO 12085
12159: POP
12160: POP
// for i = 1 to tmp do
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: DOUBLE
12167: LD_INT 1
12169: DEC
12170: ST_TO_ADDR
12171: LD_VAR 0 3
12175: PUSH
12176: FOR_TO
12177: IFFALSE 12265
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12179: LD_ADDR_VAR 0 5
12183: PUSH
12184: LD_VAR 0 5
12188: PUSH
12189: LD_VAR 0 3
12193: PUSH
12194: LD_VAR 0 4
12198: ARRAY
12199: PPUSH
12200: CALL_OW 266
12204: PUSH
12205: LD_VAR 0 3
12209: PUSH
12210: LD_VAR 0 4
12214: ARRAY
12215: PPUSH
12216: CALL_OW 250
12220: PUSH
12221: LD_VAR 0 3
12225: PUSH
12226: LD_VAR 0 4
12230: ARRAY
12231: PPUSH
12232: CALL_OW 251
12236: PUSH
12237: LD_VAR 0 3
12241: PUSH
12242: LD_VAR 0 4
12246: ARRAY
12247: PPUSH
12248: CALL_OW 254
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PUSH
12259: EMPTY
12260: LIST
12261: ADD
12262: ST_TO_ADDR
12263: GO 12176
12265: POP
12266: POP
// result := list ;
12267: LD_ADDR_VAR 0 2
12271: PUSH
12272: LD_VAR 0 5
12276: ST_TO_ADDR
// end ;
12277: LD_VAR 0 2
12281: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12282: LD_INT 0
12284: PPUSH
12285: PPUSH
12286: PPUSH
12287: PPUSH
12288: PPUSH
12289: PPUSH
12290: PPUSH
// if not factory then
12291: LD_VAR 0 1
12295: NOT
12296: IFFALSE 12300
// exit ;
12298: GO 12893
// if control = control_apeman then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_INT 5
12307: EQUAL
12308: IFFALSE 12417
// begin tmp := UnitsInside ( factory ) ;
12310: LD_ADDR_VAR 0 8
12314: PUSH
12315: LD_VAR 0 1
12319: PPUSH
12320: CALL_OW 313
12324: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12325: LD_VAR 0 8
12329: PPUSH
12330: LD_INT 25
12332: PUSH
12333: LD_INT 12
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PPUSH
12340: CALL_OW 72
12344: NOT
12345: IFFALSE 12355
// control := control_manual ;
12347: LD_ADDR_VAR 0 4
12351: PUSH
12352: LD_INT 1
12354: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12355: LD_ADDR_VAR 0 8
12359: PUSH
12360: LD_VAR 0 1
12364: PPUSH
12365: CALL 12052 0 1
12369: ST_TO_ADDR
// if tmp then
12370: LD_VAR 0 8
12374: IFFALSE 12417
// begin for i in tmp do
12376: LD_ADDR_VAR 0 7
12380: PUSH
12381: LD_VAR 0 8
12385: PUSH
12386: FOR_IN
12387: IFFALSE 12415
// if i [ 1 ] = b_ext_radio then
12389: LD_VAR 0 7
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PUSH
12398: LD_INT 22
12400: EQUAL
12401: IFFALSE 12413
// begin control := control_remote ;
12403: LD_ADDR_VAR 0 4
12407: PUSH
12408: LD_INT 2
12410: ST_TO_ADDR
// break ;
12411: GO 12415
// end ;
12413: GO 12386
12415: POP
12416: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12417: LD_VAR 0 1
12421: PPUSH
12422: LD_VAR 0 2
12426: PPUSH
12427: LD_VAR 0 3
12431: PPUSH
12432: LD_VAR 0 4
12436: PPUSH
12437: LD_VAR 0 5
12441: PPUSH
12442: CALL_OW 448
12446: IFFALSE 12481
// begin result := [ chassis , engine , control , weapon ] ;
12448: LD_ADDR_VAR 0 6
12452: PUSH
12453: LD_VAR 0 2
12457: PUSH
12458: LD_VAR 0 3
12462: PUSH
12463: LD_VAR 0 4
12467: PUSH
12468: LD_VAR 0 5
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: LIST
12477: LIST
12478: ST_TO_ADDR
// exit ;
12479: GO 12893
// end ; _chassis := AvailableChassisList ( factory ) ;
12481: LD_ADDR_VAR 0 9
12485: PUSH
12486: LD_VAR 0 1
12490: PPUSH
12491: CALL_OW 475
12495: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12496: LD_ADDR_VAR 0 11
12500: PUSH
12501: LD_VAR 0 1
12505: PPUSH
12506: CALL_OW 476
12510: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12511: LD_ADDR_VAR 0 12
12515: PUSH
12516: LD_VAR 0 1
12520: PPUSH
12521: CALL_OW 477
12525: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12526: LD_ADDR_VAR 0 10
12530: PUSH
12531: LD_VAR 0 1
12535: PPUSH
12536: CALL_OW 478
12540: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12541: LD_VAR 0 9
12545: NOT
12546: PUSH
12547: LD_VAR 0 11
12551: NOT
12552: OR
12553: PUSH
12554: LD_VAR 0 12
12558: NOT
12559: OR
12560: PUSH
12561: LD_VAR 0 10
12565: NOT
12566: OR
12567: IFFALSE 12602
// begin result := [ chassis , engine , control , weapon ] ;
12569: LD_ADDR_VAR 0 6
12573: PUSH
12574: LD_VAR 0 2
12578: PUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 4
12588: PUSH
12589: LD_VAR 0 5
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: ST_TO_ADDR
// exit ;
12600: GO 12893
// end ; if not chassis in _chassis then
12602: LD_VAR 0 2
12606: PUSH
12607: LD_VAR 0 9
12611: IN
12612: NOT
12613: IFFALSE 12639
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12615: LD_ADDR_VAR 0 2
12619: PUSH
12620: LD_VAR 0 9
12624: PUSH
12625: LD_INT 1
12627: PPUSH
12628: LD_VAR 0 9
12632: PPUSH
12633: CALL_OW 12
12637: ARRAY
12638: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12639: LD_VAR 0 2
12643: PPUSH
12644: LD_VAR 0 3
12648: PPUSH
12649: CALL 12898 0 2
12653: NOT
12654: IFFALSE 12713
// repeat engine := _engine [ 1 ] ;
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: LD_VAR 0 11
12665: PUSH
12666: LD_INT 1
12668: ARRAY
12669: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12670: LD_ADDR_VAR 0 11
12674: PUSH
12675: LD_VAR 0 11
12679: PPUSH
12680: LD_INT 1
12682: PPUSH
12683: CALL_OW 3
12687: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12688: LD_VAR 0 2
12692: PPUSH
12693: LD_VAR 0 3
12697: PPUSH
12698: CALL 12898 0 2
12702: PUSH
12703: LD_VAR 0 11
12707: PUSH
12708: EMPTY
12709: EQUAL
12710: OR
12711: IFFALSE 12656
// if not control in _control then
12713: LD_VAR 0 4
12717: PUSH
12718: LD_VAR 0 12
12722: IN
12723: NOT
12724: IFFALSE 12750
// control := _control [ rand ( 1 , _control ) ] ;
12726: LD_ADDR_VAR 0 4
12730: PUSH
12731: LD_VAR 0 12
12735: PUSH
12736: LD_INT 1
12738: PPUSH
12739: LD_VAR 0 12
12743: PPUSH
12744: CALL_OW 12
12748: ARRAY
12749: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12750: LD_VAR 0 2
12754: PPUSH
12755: LD_VAR 0 5
12759: PPUSH
12760: CALL 13118 0 2
12764: NOT
12765: IFFALSE 12824
// repeat weapon := _weapon [ 1 ] ;
12767: LD_ADDR_VAR 0 5
12771: PUSH
12772: LD_VAR 0 10
12776: PUSH
12777: LD_INT 1
12779: ARRAY
12780: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12781: LD_ADDR_VAR 0 10
12785: PUSH
12786: LD_VAR 0 10
12790: PPUSH
12791: LD_INT 1
12793: PPUSH
12794: CALL_OW 3
12798: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12799: LD_VAR 0 2
12803: PPUSH
12804: LD_VAR 0 5
12808: PPUSH
12809: CALL 13118 0 2
12813: PUSH
12814: LD_VAR 0 10
12818: PUSH
12819: EMPTY
12820: EQUAL
12821: OR
12822: IFFALSE 12767
// result := [ ] ;
12824: LD_ADDR_VAR 0 6
12828: PUSH
12829: EMPTY
12830: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12831: LD_VAR 0 1
12835: PPUSH
12836: LD_VAR 0 2
12840: PPUSH
12841: LD_VAR 0 3
12845: PPUSH
12846: LD_VAR 0 4
12850: PPUSH
12851: LD_VAR 0 5
12855: PPUSH
12856: CALL_OW 448
12860: IFFALSE 12893
// result := [ chassis , engine , control , weapon ] ;
12862: LD_ADDR_VAR 0 6
12866: PUSH
12867: LD_VAR 0 2
12871: PUSH
12872: LD_VAR 0 3
12876: PUSH
12877: LD_VAR 0 4
12881: PUSH
12882: LD_VAR 0 5
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: ST_TO_ADDR
// end ;
12893: LD_VAR 0 6
12897: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12898: LD_INT 0
12900: PPUSH
// if not chassis or not engine then
12901: LD_VAR 0 1
12905: NOT
12906: PUSH
12907: LD_VAR 0 2
12911: NOT
12912: OR
12913: IFFALSE 12917
// exit ;
12915: GO 13113
// case engine of engine_solar :
12917: LD_VAR 0 2
12921: PUSH
12922: LD_INT 2
12924: DOUBLE
12925: EQUAL
12926: IFTRUE 12930
12928: GO 12968
12930: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12931: LD_ADDR_VAR 0 3
12935: PUSH
12936: LD_INT 11
12938: PUSH
12939: LD_INT 12
12941: PUSH
12942: LD_INT 13
12944: PUSH
12945: LD_INT 14
12947: PUSH
12948: LD_INT 1
12950: PUSH
12951: LD_INT 2
12953: PUSH
12954: LD_INT 3
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: ST_TO_ADDR
12966: GO 13097
12968: LD_INT 1
12970: DOUBLE
12971: EQUAL
12972: IFTRUE 12976
12974: GO 13038
12976: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12977: LD_ADDR_VAR 0 3
12981: PUSH
12982: LD_INT 11
12984: PUSH
12985: LD_INT 12
12987: PUSH
12988: LD_INT 13
12990: PUSH
12991: LD_INT 14
12993: PUSH
12994: LD_INT 1
12996: PUSH
12997: LD_INT 2
12999: PUSH
13000: LD_INT 3
13002: PUSH
13003: LD_INT 4
13005: PUSH
13006: LD_INT 5
13008: PUSH
13009: LD_INT 21
13011: PUSH
13012: LD_INT 23
13014: PUSH
13015: LD_INT 22
13017: PUSH
13018: LD_INT 24
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: ST_TO_ADDR
13036: GO 13097
13038: LD_INT 3
13040: DOUBLE
13041: EQUAL
13042: IFTRUE 13046
13044: GO 13096
13046: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13047: LD_ADDR_VAR 0 3
13051: PUSH
13052: LD_INT 13
13054: PUSH
13055: LD_INT 14
13057: PUSH
13058: LD_INT 2
13060: PUSH
13061: LD_INT 3
13063: PUSH
13064: LD_INT 4
13066: PUSH
13067: LD_INT 5
13069: PUSH
13070: LD_INT 21
13072: PUSH
13073: LD_INT 22
13075: PUSH
13076: LD_INT 23
13078: PUSH
13079: LD_INT 24
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: ST_TO_ADDR
13094: GO 13097
13096: POP
// result := ( chassis in result ) ;
13097: LD_ADDR_VAR 0 3
13101: PUSH
13102: LD_VAR 0 1
13106: PUSH
13107: LD_VAR 0 3
13111: IN
13112: ST_TO_ADDR
// end ;
13113: LD_VAR 0 3
13117: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13118: LD_INT 0
13120: PPUSH
// if not chassis or not weapon then
13121: LD_VAR 0 1
13125: NOT
13126: PUSH
13127: LD_VAR 0 2
13131: NOT
13132: OR
13133: IFFALSE 13137
// exit ;
13135: GO 14163
// case weapon of us_machine_gun :
13137: LD_VAR 0 2
13141: PUSH
13142: LD_INT 2
13144: DOUBLE
13145: EQUAL
13146: IFTRUE 13150
13148: GO 13180
13150: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13151: LD_ADDR_VAR 0 3
13155: PUSH
13156: LD_INT 1
13158: PUSH
13159: LD_INT 2
13161: PUSH
13162: LD_INT 3
13164: PUSH
13165: LD_INT 4
13167: PUSH
13168: LD_INT 5
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: ST_TO_ADDR
13178: GO 14147
13180: LD_INT 3
13182: DOUBLE
13183: EQUAL
13184: IFTRUE 13188
13186: GO 13218
13188: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13189: LD_ADDR_VAR 0 3
13193: PUSH
13194: LD_INT 1
13196: PUSH
13197: LD_INT 2
13199: PUSH
13200: LD_INT 3
13202: PUSH
13203: LD_INT 4
13205: PUSH
13206: LD_INT 5
13208: PUSH
13209: EMPTY
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: ST_TO_ADDR
13216: GO 14147
13218: LD_INT 11
13220: DOUBLE
13221: EQUAL
13222: IFTRUE 13226
13224: GO 13256
13226: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_INT 1
13234: PUSH
13235: LD_INT 2
13237: PUSH
13238: LD_INT 3
13240: PUSH
13241: LD_INT 4
13243: PUSH
13244: LD_INT 5
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: ST_TO_ADDR
13254: GO 14147
13256: LD_INT 4
13258: DOUBLE
13259: EQUAL
13260: IFTRUE 13264
13262: GO 13290
13264: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13265: LD_ADDR_VAR 0 3
13269: PUSH
13270: LD_INT 2
13272: PUSH
13273: LD_INT 3
13275: PUSH
13276: LD_INT 4
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: ST_TO_ADDR
13288: GO 14147
13290: LD_INT 5
13292: DOUBLE
13293: EQUAL
13294: IFTRUE 13298
13296: GO 13324
13298: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13299: LD_ADDR_VAR 0 3
13303: PUSH
13304: LD_INT 2
13306: PUSH
13307: LD_INT 3
13309: PUSH
13310: LD_INT 4
13312: PUSH
13313: LD_INT 5
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: LIST
13320: LIST
13321: ST_TO_ADDR
13322: GO 14147
13324: LD_INT 9
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13358
13332: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13333: LD_ADDR_VAR 0 3
13337: PUSH
13338: LD_INT 2
13340: PUSH
13341: LD_INT 3
13343: PUSH
13344: LD_INT 4
13346: PUSH
13347: LD_INT 5
13349: PUSH
13350: EMPTY
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: ST_TO_ADDR
13356: GO 14147
13358: LD_INT 7
13360: DOUBLE
13361: EQUAL
13362: IFTRUE 13366
13364: GO 13392
13366: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13367: LD_ADDR_VAR 0 3
13371: PUSH
13372: LD_INT 2
13374: PUSH
13375: LD_INT 3
13377: PUSH
13378: LD_INT 4
13380: PUSH
13381: LD_INT 5
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: ST_TO_ADDR
13390: GO 14147
13392: LD_INT 12
13394: DOUBLE
13395: EQUAL
13396: IFTRUE 13400
13398: GO 13426
13400: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13401: LD_ADDR_VAR 0 3
13405: PUSH
13406: LD_INT 2
13408: PUSH
13409: LD_INT 3
13411: PUSH
13412: LD_INT 4
13414: PUSH
13415: LD_INT 5
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: ST_TO_ADDR
13424: GO 14147
13426: LD_INT 13
13428: DOUBLE
13429: EQUAL
13430: IFTRUE 13434
13432: GO 13460
13434: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13435: LD_ADDR_VAR 0 3
13439: PUSH
13440: LD_INT 2
13442: PUSH
13443: LD_INT 3
13445: PUSH
13446: LD_INT 4
13448: PUSH
13449: LD_INT 5
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: ST_TO_ADDR
13458: GO 14147
13460: LD_INT 14
13462: DOUBLE
13463: EQUAL
13464: IFTRUE 13468
13466: GO 13486
13468: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13469: LD_ADDR_VAR 0 3
13473: PUSH
13474: LD_INT 4
13476: PUSH
13477: LD_INT 5
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: ST_TO_ADDR
13484: GO 14147
13486: LD_INT 6
13488: DOUBLE
13489: EQUAL
13490: IFTRUE 13494
13492: GO 13512
13494: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13495: LD_ADDR_VAR 0 3
13499: PUSH
13500: LD_INT 4
13502: PUSH
13503: LD_INT 5
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: ST_TO_ADDR
13510: GO 14147
13512: LD_INT 10
13514: DOUBLE
13515: EQUAL
13516: IFTRUE 13520
13518: GO 13538
13520: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13521: LD_ADDR_VAR 0 3
13525: PUSH
13526: LD_INT 4
13528: PUSH
13529: LD_INT 5
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: ST_TO_ADDR
13536: GO 14147
13538: LD_INT 22
13540: DOUBLE
13541: EQUAL
13542: IFTRUE 13546
13544: GO 13572
13546: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13547: LD_ADDR_VAR 0 3
13551: PUSH
13552: LD_INT 11
13554: PUSH
13555: LD_INT 12
13557: PUSH
13558: LD_INT 13
13560: PUSH
13561: LD_INT 14
13563: PUSH
13564: EMPTY
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: ST_TO_ADDR
13570: GO 14147
13572: LD_INT 23
13574: DOUBLE
13575: EQUAL
13576: IFTRUE 13580
13578: GO 13606
13580: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13581: LD_ADDR_VAR 0 3
13585: PUSH
13586: LD_INT 11
13588: PUSH
13589: LD_INT 12
13591: PUSH
13592: LD_INT 13
13594: PUSH
13595: LD_INT 14
13597: PUSH
13598: EMPTY
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: ST_TO_ADDR
13604: GO 14147
13606: LD_INT 24
13608: DOUBLE
13609: EQUAL
13610: IFTRUE 13614
13612: GO 13640
13614: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13615: LD_ADDR_VAR 0 3
13619: PUSH
13620: LD_INT 11
13622: PUSH
13623: LD_INT 12
13625: PUSH
13626: LD_INT 13
13628: PUSH
13629: LD_INT 14
13631: PUSH
13632: EMPTY
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: ST_TO_ADDR
13638: GO 14147
13640: LD_INT 30
13642: DOUBLE
13643: EQUAL
13644: IFTRUE 13648
13646: GO 13674
13648: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13649: LD_ADDR_VAR 0 3
13653: PUSH
13654: LD_INT 11
13656: PUSH
13657: LD_INT 12
13659: PUSH
13660: LD_INT 13
13662: PUSH
13663: LD_INT 14
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: LIST
13670: LIST
13671: ST_TO_ADDR
13672: GO 14147
13674: LD_INT 25
13676: DOUBLE
13677: EQUAL
13678: IFTRUE 13682
13680: GO 13700
13682: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13683: LD_ADDR_VAR 0 3
13687: PUSH
13688: LD_INT 13
13690: PUSH
13691: LD_INT 14
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: ST_TO_ADDR
13698: GO 14147
13700: LD_INT 27
13702: DOUBLE
13703: EQUAL
13704: IFTRUE 13708
13706: GO 13726
13708: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13709: LD_ADDR_VAR 0 3
13713: PUSH
13714: LD_INT 13
13716: PUSH
13717: LD_INT 14
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: ST_TO_ADDR
13724: GO 14147
13726: LD_INT 28
13728: DOUBLE
13729: EQUAL
13730: IFTRUE 13734
13732: GO 13752
13734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: LD_INT 13
13742: PUSH
13743: LD_INT 14
13745: PUSH
13746: EMPTY
13747: LIST
13748: LIST
13749: ST_TO_ADDR
13750: GO 14147
13752: LD_INT 29
13754: DOUBLE
13755: EQUAL
13756: IFTRUE 13760
13758: GO 13778
13760: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13761: LD_ADDR_VAR 0 3
13765: PUSH
13766: LD_INT 13
13768: PUSH
13769: LD_INT 14
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: ST_TO_ADDR
13776: GO 14147
13778: LD_INT 31
13780: DOUBLE
13781: EQUAL
13782: IFTRUE 13786
13784: GO 13804
13786: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13787: LD_ADDR_VAR 0 3
13791: PUSH
13792: LD_INT 13
13794: PUSH
13795: LD_INT 14
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: ST_TO_ADDR
13802: GO 14147
13804: LD_INT 26
13806: DOUBLE
13807: EQUAL
13808: IFTRUE 13812
13810: GO 13830
13812: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13813: LD_ADDR_VAR 0 3
13817: PUSH
13818: LD_INT 13
13820: PUSH
13821: LD_INT 14
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: ST_TO_ADDR
13828: GO 14147
13830: LD_INT 42
13832: DOUBLE
13833: EQUAL
13834: IFTRUE 13838
13836: GO 13864
13838: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13839: LD_ADDR_VAR 0 3
13843: PUSH
13844: LD_INT 21
13846: PUSH
13847: LD_INT 22
13849: PUSH
13850: LD_INT 23
13852: PUSH
13853: LD_INT 24
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: ST_TO_ADDR
13862: GO 14147
13864: LD_INT 43
13866: DOUBLE
13867: EQUAL
13868: IFTRUE 13872
13870: GO 13898
13872: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13873: LD_ADDR_VAR 0 3
13877: PUSH
13878: LD_INT 21
13880: PUSH
13881: LD_INT 22
13883: PUSH
13884: LD_INT 23
13886: PUSH
13887: LD_INT 24
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: ST_TO_ADDR
13896: GO 14147
13898: LD_INT 44
13900: DOUBLE
13901: EQUAL
13902: IFTRUE 13906
13904: GO 13932
13906: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13907: LD_ADDR_VAR 0 3
13911: PUSH
13912: LD_INT 21
13914: PUSH
13915: LD_INT 22
13917: PUSH
13918: LD_INT 23
13920: PUSH
13921: LD_INT 24
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: ST_TO_ADDR
13930: GO 14147
13932: LD_INT 45
13934: DOUBLE
13935: EQUAL
13936: IFTRUE 13940
13938: GO 13966
13940: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13941: LD_ADDR_VAR 0 3
13945: PUSH
13946: LD_INT 21
13948: PUSH
13949: LD_INT 22
13951: PUSH
13952: LD_INT 23
13954: PUSH
13955: LD_INT 24
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: ST_TO_ADDR
13964: GO 14147
13966: LD_INT 49
13968: DOUBLE
13969: EQUAL
13970: IFTRUE 13974
13972: GO 14000
13974: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13975: LD_ADDR_VAR 0 3
13979: PUSH
13980: LD_INT 21
13982: PUSH
13983: LD_INT 22
13985: PUSH
13986: LD_INT 23
13988: PUSH
13989: LD_INT 24
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: ST_TO_ADDR
13998: GO 14147
14000: LD_INT 51
14002: DOUBLE
14003: EQUAL
14004: IFTRUE 14008
14006: GO 14034
14008: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14009: LD_ADDR_VAR 0 3
14013: PUSH
14014: LD_INT 21
14016: PUSH
14017: LD_INT 22
14019: PUSH
14020: LD_INT 23
14022: PUSH
14023: LD_INT 24
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: ST_TO_ADDR
14032: GO 14147
14034: LD_INT 52
14036: DOUBLE
14037: EQUAL
14038: IFTRUE 14042
14040: GO 14068
14042: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14043: LD_ADDR_VAR 0 3
14047: PUSH
14048: LD_INT 21
14050: PUSH
14051: LD_INT 22
14053: PUSH
14054: LD_INT 23
14056: PUSH
14057: LD_INT 24
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: ST_TO_ADDR
14066: GO 14147
14068: LD_INT 53
14070: DOUBLE
14071: EQUAL
14072: IFTRUE 14076
14074: GO 14094
14076: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: LD_INT 23
14084: PUSH
14085: LD_INT 24
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: ST_TO_ADDR
14092: GO 14147
14094: LD_INT 46
14096: DOUBLE
14097: EQUAL
14098: IFTRUE 14102
14100: GO 14120
14102: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14103: LD_ADDR_VAR 0 3
14107: PUSH
14108: LD_INT 23
14110: PUSH
14111: LD_INT 24
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: ST_TO_ADDR
14118: GO 14147
14120: LD_INT 47
14122: DOUBLE
14123: EQUAL
14124: IFTRUE 14128
14126: GO 14146
14128: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14129: LD_ADDR_VAR 0 3
14133: PUSH
14134: LD_INT 23
14136: PUSH
14137: LD_INT 24
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: ST_TO_ADDR
14144: GO 14147
14146: POP
// result := ( chassis in result ) ;
14147: LD_ADDR_VAR 0 3
14151: PUSH
14152: LD_VAR 0 1
14156: PUSH
14157: LD_VAR 0 3
14161: IN
14162: ST_TO_ADDR
// end ;
14163: LD_VAR 0 3
14167: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14168: LD_INT 0
14170: PPUSH
14171: PPUSH
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// result := array ;
14177: LD_ADDR_VAR 0 5
14181: PUSH
14182: LD_VAR 0 1
14186: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14187: LD_VAR 0 1
14191: NOT
14192: PUSH
14193: LD_VAR 0 2
14197: NOT
14198: OR
14199: PUSH
14200: LD_VAR 0 3
14204: NOT
14205: OR
14206: PUSH
14207: LD_VAR 0 2
14211: PUSH
14212: LD_VAR 0 1
14216: GREATER
14217: OR
14218: PUSH
14219: LD_VAR 0 3
14223: PUSH
14224: LD_VAR 0 1
14228: GREATER
14229: OR
14230: IFFALSE 14234
// exit ;
14232: GO 14530
// if direction then
14234: LD_VAR 0 4
14238: IFFALSE 14302
// begin d := 1 ;
14240: LD_ADDR_VAR 0 9
14244: PUSH
14245: LD_INT 1
14247: ST_TO_ADDR
// if i_from > i_to then
14248: LD_VAR 0 2
14252: PUSH
14253: LD_VAR 0 3
14257: GREATER
14258: IFFALSE 14284
// length := ( array - i_from ) + i_to else
14260: LD_ADDR_VAR 0 11
14264: PUSH
14265: LD_VAR 0 1
14269: PUSH
14270: LD_VAR 0 2
14274: MINUS
14275: PUSH
14276: LD_VAR 0 3
14280: PLUS
14281: ST_TO_ADDR
14282: GO 14300
// length := i_to - i_from ;
14284: LD_ADDR_VAR 0 11
14288: PUSH
14289: LD_VAR 0 3
14293: PUSH
14294: LD_VAR 0 2
14298: MINUS
14299: ST_TO_ADDR
// end else
14300: GO 14363
// begin d := - 1 ;
14302: LD_ADDR_VAR 0 9
14306: PUSH
14307: LD_INT 1
14309: NEG
14310: ST_TO_ADDR
// if i_from > i_to then
14311: LD_VAR 0 2
14315: PUSH
14316: LD_VAR 0 3
14320: GREATER
14321: IFFALSE 14341
// length := i_from - i_to else
14323: LD_ADDR_VAR 0 11
14327: PUSH
14328: LD_VAR 0 2
14332: PUSH
14333: LD_VAR 0 3
14337: MINUS
14338: ST_TO_ADDR
14339: GO 14363
// length := ( array - i_to ) + i_from ;
14341: LD_ADDR_VAR 0 11
14345: PUSH
14346: LD_VAR 0 1
14350: PUSH
14351: LD_VAR 0 3
14355: MINUS
14356: PUSH
14357: LD_VAR 0 2
14361: PLUS
14362: ST_TO_ADDR
// end ; if not length then
14363: LD_VAR 0 11
14367: NOT
14368: IFFALSE 14372
// exit ;
14370: GO 14530
// tmp := array ;
14372: LD_ADDR_VAR 0 10
14376: PUSH
14377: LD_VAR 0 1
14381: ST_TO_ADDR
// for i = 1 to length do
14382: LD_ADDR_VAR 0 6
14386: PUSH
14387: DOUBLE
14388: LD_INT 1
14390: DEC
14391: ST_TO_ADDR
14392: LD_VAR 0 11
14396: PUSH
14397: FOR_TO
14398: IFFALSE 14518
// begin for j = 1 to array do
14400: LD_ADDR_VAR 0 7
14404: PUSH
14405: DOUBLE
14406: LD_INT 1
14408: DEC
14409: ST_TO_ADDR
14410: LD_VAR 0 1
14414: PUSH
14415: FOR_TO
14416: IFFALSE 14504
// begin k := j + d ;
14418: LD_ADDR_VAR 0 8
14422: PUSH
14423: LD_VAR 0 7
14427: PUSH
14428: LD_VAR 0 9
14432: PLUS
14433: ST_TO_ADDR
// if k > array then
14434: LD_VAR 0 8
14438: PUSH
14439: LD_VAR 0 1
14443: GREATER
14444: IFFALSE 14454
// k := 1 ;
14446: LD_ADDR_VAR 0 8
14450: PUSH
14451: LD_INT 1
14453: ST_TO_ADDR
// if not k then
14454: LD_VAR 0 8
14458: NOT
14459: IFFALSE 14471
// k := array ;
14461: LD_ADDR_VAR 0 8
14465: PUSH
14466: LD_VAR 0 1
14470: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14471: LD_ADDR_VAR 0 10
14475: PUSH
14476: LD_VAR 0 10
14480: PPUSH
14481: LD_VAR 0 8
14485: PPUSH
14486: LD_VAR 0 1
14490: PUSH
14491: LD_VAR 0 7
14495: ARRAY
14496: PPUSH
14497: CALL_OW 1
14501: ST_TO_ADDR
// end ;
14502: GO 14415
14504: POP
14505: POP
// array := tmp ;
14506: LD_ADDR_VAR 0 1
14510: PUSH
14511: LD_VAR 0 10
14515: ST_TO_ADDR
// end ;
14516: GO 14397
14518: POP
14519: POP
// result := array ;
14520: LD_ADDR_VAR 0 5
14524: PUSH
14525: LD_VAR 0 1
14529: ST_TO_ADDR
// end ;
14530: LD_VAR 0 5
14534: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14535: LD_INT 0
14537: PPUSH
14538: PPUSH
// result := 0 ;
14539: LD_ADDR_VAR 0 3
14543: PUSH
14544: LD_INT 0
14546: ST_TO_ADDR
// if not array or not value in array then
14547: LD_VAR 0 1
14551: NOT
14552: PUSH
14553: LD_VAR 0 2
14557: PUSH
14558: LD_VAR 0 1
14562: IN
14563: NOT
14564: OR
14565: IFFALSE 14569
// exit ;
14567: GO 14623
// for i = 1 to array do
14569: LD_ADDR_VAR 0 4
14573: PUSH
14574: DOUBLE
14575: LD_INT 1
14577: DEC
14578: ST_TO_ADDR
14579: LD_VAR 0 1
14583: PUSH
14584: FOR_TO
14585: IFFALSE 14621
// if value = array [ i ] then
14587: LD_VAR 0 2
14591: PUSH
14592: LD_VAR 0 1
14596: PUSH
14597: LD_VAR 0 4
14601: ARRAY
14602: EQUAL
14603: IFFALSE 14619
// begin result := i ;
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_VAR 0 4
14614: ST_TO_ADDR
// exit ;
14615: POP
14616: POP
14617: GO 14623
// end ;
14619: GO 14584
14621: POP
14622: POP
// end ;
14623: LD_VAR 0 3
14627: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14628: LD_INT 0
14630: PPUSH
// vc_chassis := chassis ;
14631: LD_ADDR_OWVAR 37
14635: PUSH
14636: LD_VAR 0 1
14640: ST_TO_ADDR
// vc_engine := engine ;
14641: LD_ADDR_OWVAR 39
14645: PUSH
14646: LD_VAR 0 2
14650: ST_TO_ADDR
// vc_control := control ;
14651: LD_ADDR_OWVAR 38
14655: PUSH
14656: LD_VAR 0 3
14660: ST_TO_ADDR
// vc_weapon := weapon ;
14661: LD_ADDR_OWVAR 40
14665: PUSH
14666: LD_VAR 0 4
14670: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14671: LD_ADDR_OWVAR 41
14675: PUSH
14676: LD_VAR 0 5
14680: ST_TO_ADDR
// end ;
14681: LD_VAR 0 6
14685: RET
// export function WantPlant ( unit ) ; var task ; begin
14686: LD_INT 0
14688: PPUSH
14689: PPUSH
// result := false ;
14690: LD_ADDR_VAR 0 2
14694: PUSH
14695: LD_INT 0
14697: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_VAR 0 1
14707: PPUSH
14708: CALL_OW 437
14712: ST_TO_ADDR
// if task then
14713: LD_VAR 0 3
14717: IFFALSE 14745
// if task [ 1 ] [ 1 ] = p then
14719: LD_VAR 0 3
14723: PUSH
14724: LD_INT 1
14726: ARRAY
14727: PUSH
14728: LD_INT 1
14730: ARRAY
14731: PUSH
14732: LD_STRING p
14734: EQUAL
14735: IFFALSE 14745
// result := true ;
14737: LD_ADDR_VAR 0 2
14741: PUSH
14742: LD_INT 1
14744: ST_TO_ADDR
// end ;
14745: LD_VAR 0 2
14749: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14750: LD_INT 0
14752: PPUSH
14753: PPUSH
14754: PPUSH
14755: PPUSH
// if pos < 1 then
14756: LD_VAR 0 2
14760: PUSH
14761: LD_INT 1
14763: LESS
14764: IFFALSE 14768
// exit ;
14766: GO 15071
// if pos = 1 then
14768: LD_VAR 0 2
14772: PUSH
14773: LD_INT 1
14775: EQUAL
14776: IFFALSE 14809
// result := Replace ( arr , pos [ 1 ] , value ) else
14778: LD_ADDR_VAR 0 4
14782: PUSH
14783: LD_VAR 0 1
14787: PPUSH
14788: LD_VAR 0 2
14792: PUSH
14793: LD_INT 1
14795: ARRAY
14796: PPUSH
14797: LD_VAR 0 3
14801: PPUSH
14802: CALL_OW 1
14806: ST_TO_ADDR
14807: GO 15071
// begin tmp := arr ;
14809: LD_ADDR_VAR 0 6
14813: PUSH
14814: LD_VAR 0 1
14818: ST_TO_ADDR
// s_arr := [ tmp ] ;
14819: LD_ADDR_VAR 0 7
14823: PUSH
14824: LD_VAR 0 6
14828: PUSH
14829: EMPTY
14830: LIST
14831: ST_TO_ADDR
// for i = 1 to pos - 1 do
14832: LD_ADDR_VAR 0 5
14836: PUSH
14837: DOUBLE
14838: LD_INT 1
14840: DEC
14841: ST_TO_ADDR
14842: LD_VAR 0 2
14846: PUSH
14847: LD_INT 1
14849: MINUS
14850: PUSH
14851: FOR_TO
14852: IFFALSE 14897
// begin tmp := tmp [ pos [ i ] ] ;
14854: LD_ADDR_VAR 0 6
14858: PUSH
14859: LD_VAR 0 6
14863: PUSH
14864: LD_VAR 0 2
14868: PUSH
14869: LD_VAR 0 5
14873: ARRAY
14874: ARRAY
14875: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14876: LD_ADDR_VAR 0 7
14880: PUSH
14881: LD_VAR 0 7
14885: PUSH
14886: LD_VAR 0 6
14890: PUSH
14891: EMPTY
14892: LIST
14893: ADD
14894: ST_TO_ADDR
// end ;
14895: GO 14851
14897: POP
14898: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14899: LD_ADDR_VAR 0 6
14903: PUSH
14904: LD_VAR 0 6
14908: PPUSH
14909: LD_VAR 0 2
14913: PUSH
14914: LD_VAR 0 2
14918: ARRAY
14919: PPUSH
14920: LD_VAR 0 3
14924: PPUSH
14925: CALL_OW 1
14929: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14930: LD_ADDR_VAR 0 7
14934: PUSH
14935: LD_VAR 0 7
14939: PPUSH
14940: LD_VAR 0 7
14944: PPUSH
14945: LD_VAR 0 6
14949: PPUSH
14950: CALL_OW 1
14954: ST_TO_ADDR
// for i = s_arr downto 2 do
14955: LD_ADDR_VAR 0 5
14959: PUSH
14960: DOUBLE
14961: LD_VAR 0 7
14965: INC
14966: ST_TO_ADDR
14967: LD_INT 2
14969: PUSH
14970: FOR_DOWNTO
14971: IFFALSE 15055
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14973: LD_ADDR_VAR 0 6
14977: PUSH
14978: LD_VAR 0 7
14982: PUSH
14983: LD_VAR 0 5
14987: PUSH
14988: LD_INT 1
14990: MINUS
14991: ARRAY
14992: PPUSH
14993: LD_VAR 0 2
14997: PUSH
14998: LD_VAR 0 5
15002: PUSH
15003: LD_INT 1
15005: MINUS
15006: ARRAY
15007: PPUSH
15008: LD_VAR 0 7
15012: PUSH
15013: LD_VAR 0 5
15017: ARRAY
15018: PPUSH
15019: CALL_OW 1
15023: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15024: LD_ADDR_VAR 0 7
15028: PUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: LD_VAR 0 5
15038: PUSH
15039: LD_INT 1
15041: MINUS
15042: PPUSH
15043: LD_VAR 0 6
15047: PPUSH
15048: CALL_OW 1
15052: ST_TO_ADDR
// end ;
15053: GO 14970
15055: POP
15056: POP
// result := s_arr [ 1 ] ;
15057: LD_ADDR_VAR 0 4
15061: PUSH
15062: LD_VAR 0 7
15066: PUSH
15067: LD_INT 1
15069: ARRAY
15070: ST_TO_ADDR
// end ; end ;
15071: LD_VAR 0 4
15075: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15076: LD_INT 0
15078: PPUSH
15079: PPUSH
// if not list then
15080: LD_VAR 0 1
15084: NOT
15085: IFFALSE 15089
// exit ;
15087: GO 15180
// i := list [ pos1 ] ;
15089: LD_ADDR_VAR 0 5
15093: PUSH
15094: LD_VAR 0 1
15098: PUSH
15099: LD_VAR 0 2
15103: ARRAY
15104: ST_TO_ADDR
// if not i then
15105: LD_VAR 0 5
15109: NOT
15110: IFFALSE 15114
// exit ;
15112: GO 15180
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15114: LD_ADDR_VAR 0 1
15118: PUSH
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_VAR 0 2
15128: PPUSH
15129: LD_VAR 0 1
15133: PUSH
15134: LD_VAR 0 3
15138: ARRAY
15139: PPUSH
15140: CALL_OW 1
15144: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15145: LD_ADDR_VAR 0 1
15149: PUSH
15150: LD_VAR 0 1
15154: PPUSH
15155: LD_VAR 0 3
15159: PPUSH
15160: LD_VAR 0 5
15164: PPUSH
15165: CALL_OW 1
15169: ST_TO_ADDR
// result := list ;
15170: LD_ADDR_VAR 0 4
15174: PUSH
15175: LD_VAR 0 1
15179: ST_TO_ADDR
// end ;
15180: LD_VAR 0 4
15184: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15185: LD_INT 0
15187: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15188: LD_ADDR_VAR 0 5
15192: PUSH
15193: LD_VAR 0 1
15197: PPUSH
15198: CALL_OW 250
15202: PPUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: CALL_OW 251
15212: PPUSH
15213: LD_VAR 0 2
15217: PPUSH
15218: LD_VAR 0 3
15222: PPUSH
15223: LD_VAR 0 4
15227: PPUSH
15228: CALL 15238 0 5
15232: ST_TO_ADDR
// end ;
15233: LD_VAR 0 5
15237: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15238: LD_INT 0
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
// if not list then
15244: LD_VAR 0 3
15248: NOT
15249: IFFALSE 15253
// exit ;
15251: GO 15641
// result := [ ] ;
15253: LD_ADDR_VAR 0 6
15257: PUSH
15258: EMPTY
15259: ST_TO_ADDR
// for i in list do
15260: LD_ADDR_VAR 0 7
15264: PUSH
15265: LD_VAR 0 3
15269: PUSH
15270: FOR_IN
15271: IFFALSE 15473
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15273: LD_ADDR_VAR 0 9
15277: PUSH
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_VAR 0 2
15292: PPUSH
15293: CALL_OW 297
15297: ST_TO_ADDR
// if not result then
15298: LD_VAR 0 6
15302: NOT
15303: IFFALSE 15329
// result := [ [ i , tmp ] ] else
15305: LD_ADDR_VAR 0 6
15309: PUSH
15310: LD_VAR 0 7
15314: PUSH
15315: LD_VAR 0 9
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: ST_TO_ADDR
15327: GO 15471
// begin if result [ result ] [ 2 ] < tmp then
15329: LD_VAR 0 6
15333: PUSH
15334: LD_VAR 0 6
15338: ARRAY
15339: PUSH
15340: LD_INT 2
15342: ARRAY
15343: PUSH
15344: LD_VAR 0 9
15348: LESS
15349: IFFALSE 15391
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15351: LD_ADDR_VAR 0 6
15355: PUSH
15356: LD_VAR 0 6
15360: PPUSH
15361: LD_VAR 0 6
15365: PUSH
15366: LD_INT 1
15368: PLUS
15369: PPUSH
15370: LD_VAR 0 7
15374: PUSH
15375: LD_VAR 0 9
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: PPUSH
15384: CALL_OW 2
15388: ST_TO_ADDR
15389: GO 15471
// for j = 1 to result do
15391: LD_ADDR_VAR 0 8
15395: PUSH
15396: DOUBLE
15397: LD_INT 1
15399: DEC
15400: ST_TO_ADDR
15401: LD_VAR 0 6
15405: PUSH
15406: FOR_TO
15407: IFFALSE 15469
// begin if tmp < result [ j ] [ 2 ] then
15409: LD_VAR 0 9
15413: PUSH
15414: LD_VAR 0 6
15418: PUSH
15419: LD_VAR 0 8
15423: ARRAY
15424: PUSH
15425: LD_INT 2
15427: ARRAY
15428: LESS
15429: IFFALSE 15467
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15431: LD_ADDR_VAR 0 6
15435: PUSH
15436: LD_VAR 0 6
15440: PPUSH
15441: LD_VAR 0 8
15445: PPUSH
15446: LD_VAR 0 7
15450: PUSH
15451: LD_VAR 0 9
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 2
15464: ST_TO_ADDR
// break ;
15465: GO 15469
// end ; end ;
15467: GO 15406
15469: POP
15470: POP
// end ; end ;
15471: GO 15270
15473: POP
15474: POP
// if result and not asc then
15475: LD_VAR 0 6
15479: PUSH
15480: LD_VAR 0 4
15484: NOT
15485: AND
15486: IFFALSE 15561
// begin tmp := result ;
15488: LD_ADDR_VAR 0 9
15492: PUSH
15493: LD_VAR 0 6
15497: ST_TO_ADDR
// for i = tmp downto 1 do
15498: LD_ADDR_VAR 0 7
15502: PUSH
15503: DOUBLE
15504: LD_VAR 0 9
15508: INC
15509: ST_TO_ADDR
15510: LD_INT 1
15512: PUSH
15513: FOR_DOWNTO
15514: IFFALSE 15559
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15516: LD_ADDR_VAR 0 6
15520: PUSH
15521: LD_VAR 0 6
15525: PPUSH
15526: LD_VAR 0 9
15530: PUSH
15531: LD_VAR 0 7
15535: MINUS
15536: PUSH
15537: LD_INT 1
15539: PLUS
15540: PPUSH
15541: LD_VAR 0 9
15545: PUSH
15546: LD_VAR 0 7
15550: ARRAY
15551: PPUSH
15552: CALL_OW 1
15556: ST_TO_ADDR
15557: GO 15513
15559: POP
15560: POP
// end ; tmp := [ ] ;
15561: LD_ADDR_VAR 0 9
15565: PUSH
15566: EMPTY
15567: ST_TO_ADDR
// if mode then
15568: LD_VAR 0 5
15572: IFFALSE 15641
// begin for i = 1 to result do
15574: LD_ADDR_VAR 0 7
15578: PUSH
15579: DOUBLE
15580: LD_INT 1
15582: DEC
15583: ST_TO_ADDR
15584: LD_VAR 0 6
15588: PUSH
15589: FOR_TO
15590: IFFALSE 15629
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15592: LD_ADDR_VAR 0 9
15596: PUSH
15597: LD_VAR 0 9
15601: PPUSH
15602: LD_VAR 0 7
15606: PPUSH
15607: LD_VAR 0 6
15611: PUSH
15612: LD_VAR 0 7
15616: ARRAY
15617: PUSH
15618: LD_INT 1
15620: ARRAY
15621: PPUSH
15622: CALL_OW 1
15626: ST_TO_ADDR
15627: GO 15589
15629: POP
15630: POP
// result := tmp ;
15631: LD_ADDR_VAR 0 6
15635: PUSH
15636: LD_VAR 0 9
15640: ST_TO_ADDR
// end ; end ;
15641: LD_VAR 0 6
15645: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15646: LD_INT 0
15648: PPUSH
15649: PPUSH
15650: PPUSH
15651: PPUSH
15652: PPUSH
15653: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_INT 0
15661: PUSH
15662: LD_INT 0
15664: PUSH
15665: LD_INT 0
15667: PUSH
15668: EMPTY
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: ST_TO_ADDR
// if not x or not y then
15676: LD_VAR 0 2
15680: NOT
15681: PUSH
15682: LD_VAR 0 3
15686: NOT
15687: OR
15688: IFFALSE 15692
// exit ;
15690: GO 17338
// if not range then
15692: LD_VAR 0 4
15696: NOT
15697: IFFALSE 15707
// range := 10 ;
15699: LD_ADDR_VAR 0 4
15703: PUSH
15704: LD_INT 10
15706: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15707: LD_ADDR_VAR 0 8
15711: PUSH
15712: LD_INT 81
15714: PUSH
15715: LD_VAR 0 1
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 92
15726: PUSH
15727: LD_VAR 0 2
15731: PUSH
15732: LD_VAR 0 3
15736: PUSH
15737: LD_VAR 0 4
15741: PUSH
15742: EMPTY
15743: LIST
15744: LIST
15745: LIST
15746: LIST
15747: PUSH
15748: LD_INT 3
15750: PUSH
15751: LD_INT 21
15753: PUSH
15754: LD_INT 3
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: LIST
15769: PPUSH
15770: CALL_OW 69
15774: ST_TO_ADDR
// if not tmp then
15775: LD_VAR 0 8
15779: NOT
15780: IFFALSE 15784
// exit ;
15782: GO 17338
// for i in tmp do
15784: LD_ADDR_VAR 0 6
15788: PUSH
15789: LD_VAR 0 8
15793: PUSH
15794: FOR_IN
15795: IFFALSE 17313
// begin points := [ 0 , 0 , 0 ] ;
15797: LD_ADDR_VAR 0 9
15801: PUSH
15802: LD_INT 0
15804: PUSH
15805: LD_INT 0
15807: PUSH
15808: LD_INT 0
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: LIST
15815: ST_TO_ADDR
// bpoints := 1 ;
15816: LD_ADDR_VAR 0 10
15820: PUSH
15821: LD_INT 1
15823: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15824: LD_VAR 0 6
15828: PPUSH
15829: CALL_OW 247
15833: PUSH
15834: LD_INT 1
15836: DOUBLE
15837: EQUAL
15838: IFTRUE 15842
15840: GO 16420
15842: POP
// begin if GetClass ( i ) = 1 then
15843: LD_VAR 0 6
15847: PPUSH
15848: CALL_OW 257
15852: PUSH
15853: LD_INT 1
15855: EQUAL
15856: IFFALSE 15877
// points := [ 10 , 5 , 3 ] ;
15858: LD_ADDR_VAR 0 9
15862: PUSH
15863: LD_INT 10
15865: PUSH
15866: LD_INT 5
15868: PUSH
15869: LD_INT 3
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: LIST
15876: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15877: LD_VAR 0 6
15881: PPUSH
15882: CALL_OW 257
15886: PUSH
15887: LD_INT 2
15889: PUSH
15890: LD_INT 3
15892: PUSH
15893: LD_INT 4
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: LIST
15900: IN
15901: IFFALSE 15922
// points := [ 3 , 2 , 1 ] ;
15903: LD_ADDR_VAR 0 9
15907: PUSH
15908: LD_INT 3
15910: PUSH
15911: LD_INT 2
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15922: LD_VAR 0 6
15926: PPUSH
15927: CALL_OW 257
15931: PUSH
15932: LD_INT 5
15934: EQUAL
15935: IFFALSE 15956
// points := [ 130 , 5 , 2 ] ;
15937: LD_ADDR_VAR 0 9
15941: PUSH
15942: LD_INT 130
15944: PUSH
15945: LD_INT 5
15947: PUSH
15948: LD_INT 2
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: LIST
15955: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15956: LD_VAR 0 6
15960: PPUSH
15961: CALL_OW 257
15965: PUSH
15966: LD_INT 8
15968: EQUAL
15969: IFFALSE 15990
// points := [ 35 , 35 , 30 ] ;
15971: LD_ADDR_VAR 0 9
15975: PUSH
15976: LD_INT 35
15978: PUSH
15979: LD_INT 35
15981: PUSH
15982: LD_INT 30
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: LIST
15989: ST_TO_ADDR
// if GetClass ( i ) = 9 then
15990: LD_VAR 0 6
15994: PPUSH
15995: CALL_OW 257
15999: PUSH
16000: LD_INT 9
16002: EQUAL
16003: IFFALSE 16024
// points := [ 20 , 55 , 40 ] ;
16005: LD_ADDR_VAR 0 9
16009: PUSH
16010: LD_INT 20
16012: PUSH
16013: LD_INT 55
16015: PUSH
16016: LD_INT 40
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: LIST
16023: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16024: LD_VAR 0 6
16028: PPUSH
16029: CALL_OW 257
16033: PUSH
16034: LD_INT 12
16036: PUSH
16037: LD_INT 16
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: IN
16044: IFFALSE 16065
// points := [ 5 , 3 , 2 ] ;
16046: LD_ADDR_VAR 0 9
16050: PUSH
16051: LD_INT 5
16053: PUSH
16054: LD_INT 3
16056: PUSH
16057: LD_INT 2
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: LIST
16064: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16065: LD_VAR 0 6
16069: PPUSH
16070: CALL_OW 257
16074: PUSH
16075: LD_INT 17
16077: EQUAL
16078: IFFALSE 16099
// points := [ 100 , 50 , 75 ] ;
16080: LD_ADDR_VAR 0 9
16084: PUSH
16085: LD_INT 100
16087: PUSH
16088: LD_INT 50
16090: PUSH
16091: LD_INT 75
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: LIST
16098: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16099: LD_VAR 0 6
16103: PPUSH
16104: CALL_OW 257
16108: PUSH
16109: LD_INT 15
16111: EQUAL
16112: IFFALSE 16133
// points := [ 10 , 5 , 3 ] ;
16114: LD_ADDR_VAR 0 9
16118: PUSH
16119: LD_INT 10
16121: PUSH
16122: LD_INT 5
16124: PUSH
16125: LD_INT 3
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: LIST
16132: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16133: LD_VAR 0 6
16137: PPUSH
16138: CALL_OW 257
16142: PUSH
16143: LD_INT 14
16145: EQUAL
16146: IFFALSE 16167
// points := [ 10 , 0 , 0 ] ;
16148: LD_ADDR_VAR 0 9
16152: PUSH
16153: LD_INT 10
16155: PUSH
16156: LD_INT 0
16158: PUSH
16159: LD_INT 0
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: LIST
16166: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16167: LD_VAR 0 6
16171: PPUSH
16172: CALL_OW 257
16176: PUSH
16177: LD_INT 11
16179: EQUAL
16180: IFFALSE 16201
// points := [ 30 , 10 , 5 ] ;
16182: LD_ADDR_VAR 0 9
16186: PUSH
16187: LD_INT 30
16189: PUSH
16190: LD_INT 10
16192: PUSH
16193: LD_INT 5
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: LIST
16200: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16201: LD_VAR 0 1
16205: PPUSH
16206: LD_INT 5
16208: PPUSH
16209: CALL_OW 321
16213: PUSH
16214: LD_INT 2
16216: EQUAL
16217: IFFALSE 16234
// bpoints := bpoints * 1.8 ;
16219: LD_ADDR_VAR 0 10
16223: PUSH
16224: LD_VAR 0 10
16228: PUSH
16229: LD_REAL  1.80000000000000E+0000
16232: MUL
16233: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16234: LD_VAR 0 6
16238: PPUSH
16239: CALL_OW 257
16243: PUSH
16244: LD_INT 1
16246: PUSH
16247: LD_INT 2
16249: PUSH
16250: LD_INT 3
16252: PUSH
16253: LD_INT 4
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: IN
16262: PUSH
16263: LD_VAR 0 1
16267: PPUSH
16268: LD_INT 51
16270: PPUSH
16271: CALL_OW 321
16275: PUSH
16276: LD_INT 2
16278: EQUAL
16279: AND
16280: IFFALSE 16297
// bpoints := bpoints * 1.2 ;
16282: LD_ADDR_VAR 0 10
16286: PUSH
16287: LD_VAR 0 10
16291: PUSH
16292: LD_REAL  1.20000000000000E+0000
16295: MUL
16296: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16297: LD_VAR 0 6
16301: PPUSH
16302: CALL_OW 257
16306: PUSH
16307: LD_INT 5
16309: PUSH
16310: LD_INT 7
16312: PUSH
16313: LD_INT 9
16315: PUSH
16316: EMPTY
16317: LIST
16318: LIST
16319: LIST
16320: IN
16321: PUSH
16322: LD_VAR 0 1
16326: PPUSH
16327: LD_INT 52
16329: PPUSH
16330: CALL_OW 321
16334: PUSH
16335: LD_INT 2
16337: EQUAL
16338: AND
16339: IFFALSE 16356
// bpoints := bpoints * 1.5 ;
16341: LD_ADDR_VAR 0 10
16345: PUSH
16346: LD_VAR 0 10
16350: PUSH
16351: LD_REAL  1.50000000000000E+0000
16354: MUL
16355: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16356: LD_VAR 0 1
16360: PPUSH
16361: LD_INT 66
16363: PPUSH
16364: CALL_OW 321
16368: PUSH
16369: LD_INT 2
16371: EQUAL
16372: IFFALSE 16389
// bpoints := bpoints * 1.1 ;
16374: LD_ADDR_VAR 0 10
16378: PUSH
16379: LD_VAR 0 10
16383: PUSH
16384: LD_REAL  1.10000000000000E+0000
16387: MUL
16388: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16389: LD_ADDR_VAR 0 10
16393: PUSH
16394: LD_VAR 0 10
16398: PUSH
16399: LD_VAR 0 6
16403: PPUSH
16404: LD_INT 1
16406: PPUSH
16407: CALL_OW 259
16411: PUSH
16412: LD_REAL  1.15000000000000E+0000
16415: MUL
16416: MUL
16417: ST_TO_ADDR
// end ; unit_vehicle :
16418: GO 17242
16420: LD_INT 2
16422: DOUBLE
16423: EQUAL
16424: IFTRUE 16428
16426: GO 17230
16428: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16429: LD_VAR 0 6
16433: PPUSH
16434: CALL_OW 264
16438: PUSH
16439: LD_INT 2
16441: PUSH
16442: LD_INT 42
16444: PUSH
16445: LD_INT 24
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: IN
16453: IFFALSE 16474
// points := [ 25 , 5 , 3 ] ;
16455: LD_ADDR_VAR 0 9
16459: PUSH
16460: LD_INT 25
16462: PUSH
16463: LD_INT 5
16465: PUSH
16466: LD_INT 3
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: LIST
16473: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16474: LD_VAR 0 6
16478: PPUSH
16479: CALL_OW 264
16483: PUSH
16484: LD_INT 4
16486: PUSH
16487: LD_INT 43
16489: PUSH
16490: LD_INT 25
16492: PUSH
16493: EMPTY
16494: LIST
16495: LIST
16496: LIST
16497: IN
16498: IFFALSE 16519
// points := [ 40 , 15 , 5 ] ;
16500: LD_ADDR_VAR 0 9
16504: PUSH
16505: LD_INT 40
16507: PUSH
16508: LD_INT 15
16510: PUSH
16511: LD_INT 5
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: LIST
16518: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16519: LD_VAR 0 6
16523: PPUSH
16524: CALL_OW 264
16528: PUSH
16529: LD_INT 3
16531: PUSH
16532: LD_INT 23
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: IN
16539: IFFALSE 16560
// points := [ 7 , 25 , 8 ] ;
16541: LD_ADDR_VAR 0 9
16545: PUSH
16546: LD_INT 7
16548: PUSH
16549: LD_INT 25
16551: PUSH
16552: LD_INT 8
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: LIST
16559: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16560: LD_VAR 0 6
16564: PPUSH
16565: CALL_OW 264
16569: PUSH
16570: LD_INT 5
16572: PUSH
16573: LD_INT 27
16575: PUSH
16576: LD_INT 44
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: LIST
16583: IN
16584: IFFALSE 16605
// points := [ 14 , 50 , 16 ] ;
16586: LD_ADDR_VAR 0 9
16590: PUSH
16591: LD_INT 14
16593: PUSH
16594: LD_INT 50
16596: PUSH
16597: LD_INT 16
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: LIST
16604: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16605: LD_VAR 0 6
16609: PPUSH
16610: CALL_OW 264
16614: PUSH
16615: LD_INT 6
16617: PUSH
16618: LD_INT 46
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: IN
16625: IFFALSE 16646
// points := [ 32 , 120 , 70 ] ;
16627: LD_ADDR_VAR 0 9
16631: PUSH
16632: LD_INT 32
16634: PUSH
16635: LD_INT 120
16637: PUSH
16638: LD_INT 70
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: LIST
16645: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16646: LD_VAR 0 6
16650: PPUSH
16651: CALL_OW 264
16655: PUSH
16656: LD_INT 7
16658: PUSH
16659: LD_INT 28
16661: PUSH
16662: LD_INT 45
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: IN
16670: IFFALSE 16691
// points := [ 35 , 20 , 45 ] ;
16672: LD_ADDR_VAR 0 9
16676: PUSH
16677: LD_INT 35
16679: PUSH
16680: LD_INT 20
16682: PUSH
16683: LD_INT 45
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: LIST
16690: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16691: LD_VAR 0 6
16695: PPUSH
16696: CALL_OW 264
16700: PUSH
16701: LD_INT 47
16703: PUSH
16704: EMPTY
16705: LIST
16706: IN
16707: IFFALSE 16728
// points := [ 67 , 45 , 75 ] ;
16709: LD_ADDR_VAR 0 9
16713: PUSH
16714: LD_INT 67
16716: PUSH
16717: LD_INT 45
16719: PUSH
16720: LD_INT 75
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: LIST
16727: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16728: LD_VAR 0 6
16732: PPUSH
16733: CALL_OW 264
16737: PUSH
16738: LD_INT 26
16740: PUSH
16741: EMPTY
16742: LIST
16743: IN
16744: IFFALSE 16765
// points := [ 120 , 30 , 80 ] ;
16746: LD_ADDR_VAR 0 9
16750: PUSH
16751: LD_INT 120
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 80
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: LIST
16764: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16765: LD_VAR 0 6
16769: PPUSH
16770: CALL_OW 264
16774: PUSH
16775: LD_INT 22
16777: PUSH
16778: EMPTY
16779: LIST
16780: IN
16781: IFFALSE 16802
// points := [ 40 , 1 , 1 ] ;
16783: LD_ADDR_VAR 0 9
16787: PUSH
16788: LD_INT 40
16790: PUSH
16791: LD_INT 1
16793: PUSH
16794: LD_INT 1
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: LIST
16801: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16802: LD_VAR 0 6
16806: PPUSH
16807: CALL_OW 264
16811: PUSH
16812: LD_INT 29
16814: PUSH
16815: EMPTY
16816: LIST
16817: IN
16818: IFFALSE 16839
// points := [ 70 , 200 , 400 ] ;
16820: LD_ADDR_VAR 0 9
16824: PUSH
16825: LD_INT 70
16827: PUSH
16828: LD_INT 200
16830: PUSH
16831: LD_INT 400
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: LIST
16838: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16839: LD_VAR 0 6
16843: PPUSH
16844: CALL_OW 264
16848: PUSH
16849: LD_INT 14
16851: PUSH
16852: LD_INT 53
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: IN
16859: IFFALSE 16880
// points := [ 40 , 10 , 20 ] ;
16861: LD_ADDR_VAR 0 9
16865: PUSH
16866: LD_INT 40
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: LD_INT 20
16874: PUSH
16875: EMPTY
16876: LIST
16877: LIST
16878: LIST
16879: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16880: LD_VAR 0 6
16884: PPUSH
16885: CALL_OW 264
16889: PUSH
16890: LD_INT 9
16892: PUSH
16893: EMPTY
16894: LIST
16895: IN
16896: IFFALSE 16917
// points := [ 5 , 70 , 20 ] ;
16898: LD_ADDR_VAR 0 9
16902: PUSH
16903: LD_INT 5
16905: PUSH
16906: LD_INT 70
16908: PUSH
16909: LD_INT 20
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16917: LD_VAR 0 6
16921: PPUSH
16922: CALL_OW 264
16926: PUSH
16927: LD_INT 10
16929: PUSH
16930: EMPTY
16931: LIST
16932: IN
16933: IFFALSE 16954
// points := [ 35 , 110 , 70 ] ;
16935: LD_ADDR_VAR 0 9
16939: PUSH
16940: LD_INT 35
16942: PUSH
16943: LD_INT 110
16945: PUSH
16946: LD_INT 70
16948: PUSH
16949: EMPTY
16950: LIST
16951: LIST
16952: LIST
16953: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16954: LD_VAR 0 6
16958: PPUSH
16959: CALL_OW 265
16963: PUSH
16964: LD_INT 25
16966: EQUAL
16967: IFFALSE 16988
// points := [ 80 , 65 , 100 ] ;
16969: LD_ADDR_VAR 0 9
16973: PUSH
16974: LD_INT 80
16976: PUSH
16977: LD_INT 65
16979: PUSH
16980: LD_INT 100
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: LIST
16987: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
16988: LD_VAR 0 6
16992: PPUSH
16993: CALL_OW 263
16997: PUSH
16998: LD_INT 1
17000: EQUAL
17001: IFFALSE 17036
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17003: LD_ADDR_VAR 0 10
17007: PUSH
17008: LD_VAR 0 10
17012: PUSH
17013: LD_VAR 0 6
17017: PPUSH
17018: CALL_OW 311
17022: PPUSH
17023: LD_INT 3
17025: PPUSH
17026: CALL_OW 259
17030: PUSH
17031: LD_INT 4
17033: MUL
17034: MUL
17035: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17036: LD_VAR 0 6
17040: PPUSH
17041: CALL_OW 263
17045: PUSH
17046: LD_INT 2
17048: EQUAL
17049: IFFALSE 17100
// begin j := IsControledBy ( i ) ;
17051: LD_ADDR_VAR 0 7
17055: PUSH
17056: LD_VAR 0 6
17060: PPUSH
17061: CALL_OW 312
17065: ST_TO_ADDR
// if j then
17066: LD_VAR 0 7
17070: IFFALSE 17100
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17072: LD_ADDR_VAR 0 10
17076: PUSH
17077: LD_VAR 0 10
17081: PUSH
17082: LD_VAR 0 7
17086: PPUSH
17087: LD_INT 3
17089: PPUSH
17090: CALL_OW 259
17094: PUSH
17095: LD_INT 3
17097: MUL
17098: MUL
17099: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17100: LD_VAR 0 6
17104: PPUSH
17105: CALL_OW 264
17109: PUSH
17110: LD_INT 5
17112: PUSH
17113: LD_INT 6
17115: PUSH
17116: LD_INT 46
17118: PUSH
17119: LD_INT 44
17121: PUSH
17122: LD_INT 47
17124: PUSH
17125: LD_INT 45
17127: PUSH
17128: LD_INT 28
17130: PUSH
17131: LD_INT 7
17133: PUSH
17134: LD_INT 27
17136: PUSH
17137: LD_INT 29
17139: PUSH
17140: EMPTY
17141: LIST
17142: LIST
17143: LIST
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: LIST
17149: LIST
17150: LIST
17151: IN
17152: PUSH
17153: LD_VAR 0 1
17157: PPUSH
17158: LD_INT 52
17160: PPUSH
17161: CALL_OW 321
17165: PUSH
17166: LD_INT 2
17168: EQUAL
17169: AND
17170: IFFALSE 17187
// bpoints := bpoints * 1.2 ;
17172: LD_ADDR_VAR 0 10
17176: PUSH
17177: LD_VAR 0 10
17181: PUSH
17182: LD_REAL  1.20000000000000E+0000
17185: MUL
17186: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17187: LD_VAR 0 6
17191: PPUSH
17192: CALL_OW 264
17196: PUSH
17197: LD_INT 6
17199: PUSH
17200: LD_INT 46
17202: PUSH
17203: LD_INT 47
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: IN
17211: IFFALSE 17228
// bpoints := bpoints * 1.2 ;
17213: LD_ADDR_VAR 0 10
17217: PUSH
17218: LD_VAR 0 10
17222: PUSH
17223: LD_REAL  1.20000000000000E+0000
17226: MUL
17227: ST_TO_ADDR
// end ; unit_building :
17228: GO 17242
17230: LD_INT 3
17232: DOUBLE
17233: EQUAL
17234: IFTRUE 17238
17236: GO 17241
17238: POP
// ; end ;
17239: GO 17242
17241: POP
// for j = 1 to 3 do
17242: LD_ADDR_VAR 0 7
17246: PUSH
17247: DOUBLE
17248: LD_INT 1
17250: DEC
17251: ST_TO_ADDR
17252: LD_INT 3
17254: PUSH
17255: FOR_TO
17256: IFFALSE 17309
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17258: LD_ADDR_VAR 0 5
17262: PUSH
17263: LD_VAR 0 5
17267: PPUSH
17268: LD_VAR 0 7
17272: PPUSH
17273: LD_VAR 0 5
17277: PUSH
17278: LD_VAR 0 7
17282: ARRAY
17283: PUSH
17284: LD_VAR 0 9
17288: PUSH
17289: LD_VAR 0 7
17293: ARRAY
17294: PUSH
17295: LD_VAR 0 10
17299: MUL
17300: PLUS
17301: PPUSH
17302: CALL_OW 1
17306: ST_TO_ADDR
17307: GO 17255
17309: POP
17310: POP
// end ;
17311: GO 15794
17313: POP
17314: POP
// result := Replace ( result , 4 , tmp ) ;
17315: LD_ADDR_VAR 0 5
17319: PUSH
17320: LD_VAR 0 5
17324: PPUSH
17325: LD_INT 4
17327: PPUSH
17328: LD_VAR 0 8
17332: PPUSH
17333: CALL_OW 1
17337: ST_TO_ADDR
// end ;
17338: LD_VAR 0 5
17342: RET
// export function DangerAtRange ( unit , range ) ; begin
17343: LD_INT 0
17345: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17346: LD_ADDR_VAR 0 3
17350: PUSH
17351: LD_VAR 0 1
17355: PPUSH
17356: CALL_OW 255
17360: PPUSH
17361: LD_VAR 0 1
17365: PPUSH
17366: CALL_OW 250
17370: PPUSH
17371: LD_VAR 0 1
17375: PPUSH
17376: CALL_OW 251
17380: PPUSH
17381: LD_VAR 0 2
17385: PPUSH
17386: CALL 15646 0 4
17390: ST_TO_ADDR
// end ;
17391: LD_VAR 0 3
17395: RET
// export function DangerInArea ( side , area ) ; begin
17396: LD_INT 0
17398: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17399: LD_ADDR_VAR 0 3
17403: PUSH
17404: LD_VAR 0 2
17408: PPUSH
17409: LD_INT 81
17411: PUSH
17412: LD_VAR 0 1
17416: PUSH
17417: EMPTY
17418: LIST
17419: LIST
17420: PPUSH
17421: CALL_OW 70
17425: ST_TO_ADDR
// end ;
17426: LD_VAR 0 3
17430: RET
// export function IsExtension ( b ) ; begin
17431: LD_INT 0
17433: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17434: LD_ADDR_VAR 0 2
17438: PUSH
17439: LD_VAR 0 1
17443: PUSH
17444: LD_INT 23
17446: PUSH
17447: LD_INT 20
17449: PUSH
17450: LD_INT 22
17452: PUSH
17453: LD_INT 17
17455: PUSH
17456: LD_INT 24
17458: PUSH
17459: LD_INT 21
17461: PUSH
17462: LD_INT 19
17464: PUSH
17465: LD_INT 16
17467: PUSH
17468: LD_INT 25
17470: PUSH
17471: LD_INT 18
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: LIST
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: IN
17486: ST_TO_ADDR
// end ;
17487: LD_VAR 0 2
17491: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
17492: LD_INT 0
17494: PPUSH
17495: PPUSH
17496: PPUSH
// result := [ ] ;
17497: LD_ADDR_VAR 0 3
17501: PUSH
17502: EMPTY
17503: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17504: LD_ADDR_VAR 0 4
17508: PUSH
17509: LD_VAR 0 2
17513: PPUSH
17514: LD_INT 21
17516: PUSH
17517: LD_INT 3
17519: PUSH
17520: EMPTY
17521: LIST
17522: LIST
17523: PPUSH
17524: CALL_OW 70
17528: ST_TO_ADDR
// if not tmp then
17529: LD_VAR 0 4
17533: NOT
17534: IFFALSE 17538
// exit ;
17536: GO 17596
// for i in tmp do
17538: LD_ADDR_VAR 0 5
17542: PUSH
17543: LD_VAR 0 4
17547: PUSH
17548: FOR_IN
17549: IFFALSE 17584
// if GetBase ( i ) <> base then
17551: LD_VAR 0 5
17555: PPUSH
17556: CALL_OW 274
17560: PUSH
17561: LD_VAR 0 1
17565: NONEQUAL
17566: IFFALSE 17582
// ComLinkToBase ( base , i ) ;
17568: LD_VAR 0 1
17572: PPUSH
17573: LD_VAR 0 5
17577: PPUSH
17578: CALL_OW 169
17582: GO 17548
17584: POP
17585: POP
// result := tmp ;
17586: LD_ADDR_VAR 0 3
17590: PUSH
17591: LD_VAR 0 4
17595: ST_TO_ADDR
// end ;
17596: LD_VAR 0 3
17600: RET
// export function ComComplete ( unit , b ) ; var i ; begin
17601: LD_INT 0
17603: PPUSH
17604: PPUSH
// if BuildingStatus ( b ) = bs_build then
17605: LD_VAR 0 2
17609: PPUSH
17610: CALL_OW 461
17614: PUSH
17615: LD_INT 1
17617: EQUAL
17618: IFFALSE 17678
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17620: LD_VAR 0 1
17624: PPUSH
17625: LD_STRING h
17627: PUSH
17628: LD_VAR 0 2
17632: PPUSH
17633: CALL_OW 250
17637: PUSH
17638: LD_VAR 0 2
17642: PPUSH
17643: CALL_OW 251
17647: PUSH
17648: LD_VAR 0 2
17652: PUSH
17653: LD_INT 0
17655: PUSH
17656: LD_INT 0
17658: PUSH
17659: LD_INT 0
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: LIST
17666: LIST
17667: LIST
17668: LIST
17669: LIST
17670: PUSH
17671: EMPTY
17672: LIST
17673: PPUSH
17674: CALL_OW 446
// end ;
17678: LD_VAR 0 3
17682: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17683: LD_INT 0
17685: PPUSH
17686: PPUSH
17687: PPUSH
17688: PPUSH
17689: PPUSH
17690: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17691: LD_VAR 0 1
17695: NOT
17696: PUSH
17697: LD_VAR 0 1
17701: PPUSH
17702: CALL_OW 263
17706: PUSH
17707: LD_INT 2
17709: EQUAL
17710: NOT
17711: OR
17712: IFFALSE 17716
// exit ;
17714: GO 18032
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17716: LD_ADDR_VAR 0 6
17720: PUSH
17721: LD_INT 22
17723: PUSH
17724: LD_VAR 0 1
17728: PPUSH
17729: CALL_OW 255
17733: PUSH
17734: EMPTY
17735: LIST
17736: LIST
17737: PUSH
17738: LD_INT 2
17740: PUSH
17741: LD_INT 30
17743: PUSH
17744: LD_INT 36
17746: PUSH
17747: EMPTY
17748: LIST
17749: LIST
17750: PUSH
17751: LD_INT 34
17753: PUSH
17754: LD_INT 31
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: LIST
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PPUSH
17770: CALL_OW 69
17774: ST_TO_ADDR
// if not tmp then
17775: LD_VAR 0 6
17779: NOT
17780: IFFALSE 17784
// exit ;
17782: GO 18032
// result := [ ] ;
17784: LD_ADDR_VAR 0 2
17788: PUSH
17789: EMPTY
17790: ST_TO_ADDR
// for i in tmp do
17791: LD_ADDR_VAR 0 3
17795: PUSH
17796: LD_VAR 0 6
17800: PUSH
17801: FOR_IN
17802: IFFALSE 17873
// begin t := UnitsInside ( i ) ;
17804: LD_ADDR_VAR 0 4
17808: PUSH
17809: LD_VAR 0 3
17813: PPUSH
17814: CALL_OW 313
17818: ST_TO_ADDR
// if t then
17819: LD_VAR 0 4
17823: IFFALSE 17871
// for j in t do
17825: LD_ADDR_VAR 0 7
17829: PUSH
17830: LD_VAR 0 4
17834: PUSH
17835: FOR_IN
17836: IFFALSE 17869
// result := Insert ( result , result + 1 , j ) ;
17838: LD_ADDR_VAR 0 2
17842: PUSH
17843: LD_VAR 0 2
17847: PPUSH
17848: LD_VAR 0 2
17852: PUSH
17853: LD_INT 1
17855: PLUS
17856: PPUSH
17857: LD_VAR 0 7
17861: PPUSH
17862: CALL_OW 2
17866: ST_TO_ADDR
17867: GO 17835
17869: POP
17870: POP
// end ;
17871: GO 17801
17873: POP
17874: POP
// if not result then
17875: LD_VAR 0 2
17879: NOT
17880: IFFALSE 17884
// exit ;
17882: GO 18032
// mech := result [ 1 ] ;
17884: LD_ADDR_VAR 0 5
17888: PUSH
17889: LD_VAR 0 2
17893: PUSH
17894: LD_INT 1
17896: ARRAY
17897: ST_TO_ADDR
// if result > 1 then
17898: LD_VAR 0 2
17902: PUSH
17903: LD_INT 1
17905: GREATER
17906: IFFALSE 18018
// for i = 2 to result do
17908: LD_ADDR_VAR 0 3
17912: PUSH
17913: DOUBLE
17914: LD_INT 2
17916: DEC
17917: ST_TO_ADDR
17918: LD_VAR 0 2
17922: PUSH
17923: FOR_TO
17924: IFFALSE 18016
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17926: LD_ADDR_VAR 0 4
17930: PUSH
17931: LD_VAR 0 2
17935: PUSH
17936: LD_VAR 0 3
17940: ARRAY
17941: PPUSH
17942: LD_INT 3
17944: PPUSH
17945: CALL_OW 259
17949: PUSH
17950: LD_VAR 0 2
17954: PUSH
17955: LD_VAR 0 3
17959: ARRAY
17960: PPUSH
17961: CALL_OW 432
17965: MINUS
17966: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
17967: LD_VAR 0 4
17971: PUSH
17972: LD_VAR 0 5
17976: PPUSH
17977: LD_INT 3
17979: PPUSH
17980: CALL_OW 259
17984: PUSH
17985: LD_VAR 0 5
17989: PPUSH
17990: CALL_OW 432
17994: MINUS
17995: GREATEREQUAL
17996: IFFALSE 18014
// mech := result [ i ] ;
17998: LD_ADDR_VAR 0 5
18002: PUSH
18003: LD_VAR 0 2
18007: PUSH
18008: LD_VAR 0 3
18012: ARRAY
18013: ST_TO_ADDR
// end ;
18014: GO 17923
18016: POP
18017: POP
// ComLinkTo ( vehicle , mech ) ;
18018: LD_VAR 0 1
18022: PPUSH
18023: LD_VAR 0 5
18027: PPUSH
18028: CALL_OW 135
// end ;
18032: LD_VAR 0 2
18036: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18037: LD_INT 0
18039: PPUSH
18040: PPUSH
18041: PPUSH
18042: PPUSH
18043: PPUSH
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
18048: PPUSH
18049: PPUSH
18050: PPUSH
18051: PPUSH
// result := [ ] ;
18052: LD_ADDR_VAR 0 7
18056: PUSH
18057: EMPTY
18058: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18059: LD_VAR 0 1
18063: PPUSH
18064: CALL_OW 266
18068: PUSH
18069: LD_INT 0
18071: PUSH
18072: LD_INT 1
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: IN
18079: NOT
18080: IFFALSE 18084
// exit ;
18082: GO 19715
// if name then
18084: LD_VAR 0 3
18088: IFFALSE 18104
// SetBName ( base_dep , name ) ;
18090: LD_VAR 0 1
18094: PPUSH
18095: LD_VAR 0 3
18099: PPUSH
18100: CALL_OW 500
// base := GetBase ( base_dep ) ;
18104: LD_ADDR_VAR 0 15
18108: PUSH
18109: LD_VAR 0 1
18113: PPUSH
18114: CALL_OW 274
18118: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18119: LD_ADDR_VAR 0 16
18123: PUSH
18124: LD_VAR 0 1
18128: PPUSH
18129: CALL_OW 255
18133: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18134: LD_ADDR_VAR 0 17
18138: PUSH
18139: LD_VAR 0 1
18143: PPUSH
18144: CALL_OW 248
18148: ST_TO_ADDR
// if sources then
18149: LD_VAR 0 5
18153: IFFALSE 18200
// for i = 1 to 3 do
18155: LD_ADDR_VAR 0 8
18159: PUSH
18160: DOUBLE
18161: LD_INT 1
18163: DEC
18164: ST_TO_ADDR
18165: LD_INT 3
18167: PUSH
18168: FOR_TO
18169: IFFALSE 18198
// AddResourceType ( base , i , sources [ i ] ) ;
18171: LD_VAR 0 15
18175: PPUSH
18176: LD_VAR 0 8
18180: PPUSH
18181: LD_VAR 0 5
18185: PUSH
18186: LD_VAR 0 8
18190: ARRAY
18191: PPUSH
18192: CALL_OW 276
18196: GO 18168
18198: POP
18199: POP
// buildings := GetBaseBuildings ( base , area ) ;
18200: LD_ADDR_VAR 0 18
18204: PUSH
18205: LD_VAR 0 15
18209: PPUSH
18210: LD_VAR 0 2
18214: PPUSH
18215: CALL 17492 0 2
18219: ST_TO_ADDR
// InitHc ;
18220: CALL_OW 19
// InitUc ;
18224: CALL_OW 18
// uc_side := side ;
18228: LD_ADDR_OWVAR 20
18232: PUSH
18233: LD_VAR 0 16
18237: ST_TO_ADDR
// uc_nation := nation ;
18238: LD_ADDR_OWVAR 21
18242: PUSH
18243: LD_VAR 0 17
18247: ST_TO_ADDR
// if buildings then
18248: LD_VAR 0 18
18252: IFFALSE 19574
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18254: LD_ADDR_VAR 0 19
18258: PUSH
18259: LD_VAR 0 18
18263: PPUSH
18264: LD_INT 2
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 29
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: LD_INT 30
18279: PUSH
18280: LD_INT 30
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: LIST
18291: PPUSH
18292: CALL_OW 72
18296: ST_TO_ADDR
// if tmp then
18297: LD_VAR 0 19
18301: IFFALSE 18349
// for i in tmp do
18303: LD_ADDR_VAR 0 8
18307: PUSH
18308: LD_VAR 0 19
18312: PUSH
18313: FOR_IN
18314: IFFALSE 18347
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18316: LD_VAR 0 8
18320: PPUSH
18321: CALL_OW 250
18325: PPUSH
18326: LD_VAR 0 8
18330: PPUSH
18331: CALL_OW 251
18335: PPUSH
18336: LD_VAR 0 16
18340: PPUSH
18341: CALL_OW 441
18345: GO 18313
18347: POP
18348: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18349: LD_VAR 0 18
18353: PPUSH
18354: LD_INT 2
18356: PUSH
18357: LD_INT 30
18359: PUSH
18360: LD_INT 32
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: PUSH
18367: LD_INT 30
18369: PUSH
18370: LD_INT 33
18372: PUSH
18373: EMPTY
18374: LIST
18375: LIST
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: LIST
18381: PPUSH
18382: CALL_OW 72
18386: IFFALSE 18474
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18388: LD_ADDR_VAR 0 8
18392: PUSH
18393: LD_VAR 0 18
18397: PPUSH
18398: LD_INT 2
18400: PUSH
18401: LD_INT 30
18403: PUSH
18404: LD_INT 32
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: PUSH
18411: LD_INT 30
18413: PUSH
18414: LD_INT 33
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: LIST
18425: PPUSH
18426: CALL_OW 72
18430: PUSH
18431: FOR_IN
18432: IFFALSE 18472
// begin if not GetBWeapon ( i ) then
18434: LD_VAR 0 8
18438: PPUSH
18439: CALL_OW 269
18443: NOT
18444: IFFALSE 18470
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18446: LD_VAR 0 8
18450: PPUSH
18451: LD_VAR 0 8
18455: PPUSH
18456: LD_VAR 0 2
18460: PPUSH
18461: CALL 19720 0 2
18465: PPUSH
18466: CALL_OW 431
// end ;
18470: GO 18431
18472: POP
18473: POP
// end ; for i = 1 to personel do
18474: LD_ADDR_VAR 0 8
18478: PUSH
18479: DOUBLE
18480: LD_INT 1
18482: DEC
18483: ST_TO_ADDR
18484: LD_VAR 0 6
18488: PUSH
18489: FOR_TO
18490: IFFALSE 19554
// begin if i > 4 then
18492: LD_VAR 0 8
18496: PUSH
18497: LD_INT 4
18499: GREATER
18500: IFFALSE 18504
// break ;
18502: GO 19554
// case i of 1 :
18504: LD_VAR 0 8
18508: PUSH
18509: LD_INT 1
18511: DOUBLE
18512: EQUAL
18513: IFTRUE 18517
18515: GO 18597
18517: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18518: LD_ADDR_VAR 0 12
18522: PUSH
18523: LD_VAR 0 18
18527: PPUSH
18528: LD_INT 22
18530: PUSH
18531: LD_VAR 0 16
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: PUSH
18540: LD_INT 58
18542: PUSH
18543: EMPTY
18544: LIST
18545: PUSH
18546: LD_INT 2
18548: PUSH
18549: LD_INT 30
18551: PUSH
18552: LD_INT 32
18554: PUSH
18555: EMPTY
18556: LIST
18557: LIST
18558: PUSH
18559: LD_INT 30
18561: PUSH
18562: LD_INT 4
18564: PUSH
18565: EMPTY
18566: LIST
18567: LIST
18568: PUSH
18569: LD_INT 30
18571: PUSH
18572: LD_INT 5
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: EMPTY
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: LIST
18589: PPUSH
18590: CALL_OW 72
18594: ST_TO_ADDR
18595: GO 18819
18597: LD_INT 2
18599: DOUBLE
18600: EQUAL
18601: IFTRUE 18605
18603: GO 18667
18605: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18606: LD_ADDR_VAR 0 12
18610: PUSH
18611: LD_VAR 0 18
18615: PPUSH
18616: LD_INT 22
18618: PUSH
18619: LD_VAR 0 16
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 30
18633: PUSH
18634: LD_INT 0
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 30
18643: PUSH
18644: LD_INT 1
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: LIST
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 72
18664: ST_TO_ADDR
18665: GO 18819
18667: LD_INT 3
18669: DOUBLE
18670: EQUAL
18671: IFTRUE 18675
18673: GO 18737
18675: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18676: LD_ADDR_VAR 0 12
18680: PUSH
18681: LD_VAR 0 18
18685: PPUSH
18686: LD_INT 22
18688: PUSH
18689: LD_VAR 0 16
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: PUSH
18698: LD_INT 2
18700: PUSH
18701: LD_INT 30
18703: PUSH
18704: LD_INT 2
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PUSH
18711: LD_INT 30
18713: PUSH
18714: LD_INT 3
18716: PUSH
18717: EMPTY
18718: LIST
18719: LIST
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: PPUSH
18730: CALL_OW 72
18734: ST_TO_ADDR
18735: GO 18819
18737: LD_INT 4
18739: DOUBLE
18740: EQUAL
18741: IFTRUE 18745
18743: GO 18818
18745: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18746: LD_ADDR_VAR 0 12
18750: PUSH
18751: LD_VAR 0 18
18755: PPUSH
18756: LD_INT 22
18758: PUSH
18759: LD_VAR 0 16
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 2
18770: PUSH
18771: LD_INT 30
18773: PUSH
18774: LD_INT 6
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 30
18783: PUSH
18784: LD_INT 7
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: LD_INT 30
18793: PUSH
18794: LD_INT 8
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PUSH
18801: EMPTY
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PPUSH
18811: CALL_OW 72
18815: ST_TO_ADDR
18816: GO 18819
18818: POP
// if i = 1 then
18819: LD_VAR 0 8
18823: PUSH
18824: LD_INT 1
18826: EQUAL
18827: IFFALSE 18938
// begin tmp := [ ] ;
18829: LD_ADDR_VAR 0 19
18833: PUSH
18834: EMPTY
18835: ST_TO_ADDR
// for j in f do
18836: LD_ADDR_VAR 0 9
18840: PUSH
18841: LD_VAR 0 12
18845: PUSH
18846: FOR_IN
18847: IFFALSE 18920
// if GetBType ( j ) = b_bunker then
18849: LD_VAR 0 9
18853: PPUSH
18854: CALL_OW 266
18858: PUSH
18859: LD_INT 32
18861: EQUAL
18862: IFFALSE 18889
// tmp := Insert ( tmp , 1 , j ) else
18864: LD_ADDR_VAR 0 19
18868: PUSH
18869: LD_VAR 0 19
18873: PPUSH
18874: LD_INT 1
18876: PPUSH
18877: LD_VAR 0 9
18881: PPUSH
18882: CALL_OW 2
18886: ST_TO_ADDR
18887: GO 18918
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18889: LD_ADDR_VAR 0 19
18893: PUSH
18894: LD_VAR 0 19
18898: PPUSH
18899: LD_VAR 0 19
18903: PUSH
18904: LD_INT 1
18906: PLUS
18907: PPUSH
18908: LD_VAR 0 9
18912: PPUSH
18913: CALL_OW 2
18917: ST_TO_ADDR
18918: GO 18846
18920: POP
18921: POP
// if tmp then
18922: LD_VAR 0 19
18926: IFFALSE 18938
// f := tmp ;
18928: LD_ADDR_VAR 0 12
18932: PUSH
18933: LD_VAR 0 19
18937: ST_TO_ADDR
// end ; x := personel [ i ] ;
18938: LD_ADDR_VAR 0 13
18942: PUSH
18943: LD_VAR 0 6
18947: PUSH
18948: LD_VAR 0 8
18952: ARRAY
18953: ST_TO_ADDR
// if x = - 1 then
18954: LD_VAR 0 13
18958: PUSH
18959: LD_INT 1
18961: NEG
18962: EQUAL
18963: IFFALSE 19172
// begin for j in f do
18965: LD_ADDR_VAR 0 9
18969: PUSH
18970: LD_VAR 0 12
18974: PUSH
18975: FOR_IN
18976: IFFALSE 19168
// repeat InitHc ;
18978: CALL_OW 19
// if GetBType ( j ) = b_barracks then
18982: LD_VAR 0 9
18986: PPUSH
18987: CALL_OW 266
18991: PUSH
18992: LD_INT 5
18994: EQUAL
18995: IFFALSE 19065
// begin if UnitsInside ( j ) < 3 then
18997: LD_VAR 0 9
19001: PPUSH
19002: CALL_OW 313
19006: PUSH
19007: LD_INT 3
19009: LESS
19010: IFFALSE 19046
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19012: LD_INT 0
19014: PPUSH
19015: LD_INT 5
19017: PUSH
19018: LD_INT 8
19020: PUSH
19021: LD_INT 9
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: PUSH
19029: LD_VAR 0 17
19033: ARRAY
19034: PPUSH
19035: LD_VAR 0 4
19039: PPUSH
19040: CALL_OW 380
19044: GO 19063
// PrepareHuman ( false , i , skill ) ;
19046: LD_INT 0
19048: PPUSH
19049: LD_VAR 0 8
19053: PPUSH
19054: LD_VAR 0 4
19058: PPUSH
19059: CALL_OW 380
// end else
19063: GO 19082
// PrepareHuman ( false , i , skill ) ;
19065: LD_INT 0
19067: PPUSH
19068: LD_VAR 0 8
19072: PPUSH
19073: LD_VAR 0 4
19077: PPUSH
19078: CALL_OW 380
// un := CreateHuman ;
19082: LD_ADDR_VAR 0 14
19086: PUSH
19087: CALL_OW 44
19091: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19092: LD_ADDR_VAR 0 7
19096: PUSH
19097: LD_VAR 0 7
19101: PPUSH
19102: LD_INT 1
19104: PPUSH
19105: LD_VAR 0 14
19109: PPUSH
19110: CALL_OW 2
19114: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19115: LD_VAR 0 14
19119: PPUSH
19120: LD_VAR 0 9
19124: PPUSH
19125: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19129: LD_VAR 0 9
19133: PPUSH
19134: CALL_OW 313
19138: PUSH
19139: LD_INT 6
19141: EQUAL
19142: PUSH
19143: LD_VAR 0 9
19147: PPUSH
19148: CALL_OW 266
19152: PUSH
19153: LD_INT 32
19155: PUSH
19156: LD_INT 31
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: IN
19163: OR
19164: IFFALSE 18978
19166: GO 18975
19168: POP
19169: POP
// end else
19170: GO 19552
// for j = 1 to x do
19172: LD_ADDR_VAR 0 9
19176: PUSH
19177: DOUBLE
19178: LD_INT 1
19180: DEC
19181: ST_TO_ADDR
19182: LD_VAR 0 13
19186: PUSH
19187: FOR_TO
19188: IFFALSE 19550
// begin InitHc ;
19190: CALL_OW 19
// if not f then
19194: LD_VAR 0 12
19198: NOT
19199: IFFALSE 19288
// begin PrepareHuman ( false , i , skill ) ;
19201: LD_INT 0
19203: PPUSH
19204: LD_VAR 0 8
19208: PPUSH
19209: LD_VAR 0 4
19213: PPUSH
19214: CALL_OW 380
// un := CreateHuman ;
19218: LD_ADDR_VAR 0 14
19222: PUSH
19223: CALL_OW 44
19227: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19228: LD_ADDR_VAR 0 7
19232: PUSH
19233: LD_VAR 0 7
19237: PPUSH
19238: LD_INT 1
19240: PPUSH
19241: LD_VAR 0 14
19245: PPUSH
19246: CALL_OW 2
19250: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19251: LD_VAR 0 14
19255: PPUSH
19256: LD_VAR 0 1
19260: PPUSH
19261: CALL_OW 250
19265: PPUSH
19266: LD_VAR 0 1
19270: PPUSH
19271: CALL_OW 251
19275: PPUSH
19276: LD_INT 10
19278: PPUSH
19279: LD_INT 0
19281: PPUSH
19282: CALL_OW 50
// continue ;
19286: GO 19187
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19288: LD_VAR 0 12
19292: PUSH
19293: LD_INT 1
19295: ARRAY
19296: PPUSH
19297: CALL_OW 313
19301: PUSH
19302: LD_VAR 0 12
19306: PUSH
19307: LD_INT 1
19309: ARRAY
19310: PPUSH
19311: CALL_OW 266
19315: PUSH
19316: LD_INT 32
19318: PUSH
19319: LD_INT 31
19321: PUSH
19322: EMPTY
19323: LIST
19324: LIST
19325: IN
19326: AND
19327: PUSH
19328: LD_VAR 0 12
19332: PUSH
19333: LD_INT 1
19335: ARRAY
19336: PPUSH
19337: CALL_OW 313
19341: PUSH
19342: LD_INT 6
19344: EQUAL
19345: OR
19346: IFFALSE 19366
// f := Delete ( f , 1 ) ;
19348: LD_ADDR_VAR 0 12
19352: PUSH
19353: LD_VAR 0 12
19357: PPUSH
19358: LD_INT 1
19360: PPUSH
19361: CALL_OW 3
19365: ST_TO_ADDR
// if not f then
19366: LD_VAR 0 12
19370: NOT
19371: IFFALSE 19389
// begin x := x + 2 ;
19373: LD_ADDR_VAR 0 13
19377: PUSH
19378: LD_VAR 0 13
19382: PUSH
19383: LD_INT 2
19385: PLUS
19386: ST_TO_ADDR
// continue ;
19387: GO 19187
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19389: LD_VAR 0 12
19393: PUSH
19394: LD_INT 1
19396: ARRAY
19397: PPUSH
19398: CALL_OW 266
19402: PUSH
19403: LD_INT 5
19405: EQUAL
19406: IFFALSE 19480
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19408: LD_VAR 0 12
19412: PUSH
19413: LD_INT 1
19415: ARRAY
19416: PPUSH
19417: CALL_OW 313
19421: PUSH
19422: LD_INT 3
19424: LESS
19425: IFFALSE 19461
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19427: LD_INT 0
19429: PPUSH
19430: LD_INT 5
19432: PUSH
19433: LD_INT 8
19435: PUSH
19436: LD_INT 9
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: LIST
19443: PUSH
19444: LD_VAR 0 17
19448: ARRAY
19449: PPUSH
19450: LD_VAR 0 4
19454: PPUSH
19455: CALL_OW 380
19459: GO 19478
// PrepareHuman ( false , i , skill ) ;
19461: LD_INT 0
19463: PPUSH
19464: LD_VAR 0 8
19468: PPUSH
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 380
// end else
19478: GO 19497
// PrepareHuman ( false , i , skill ) ;
19480: LD_INT 0
19482: PPUSH
19483: LD_VAR 0 8
19487: PPUSH
19488: LD_VAR 0 4
19492: PPUSH
19493: CALL_OW 380
// un := CreateHuman ;
19497: LD_ADDR_VAR 0 14
19501: PUSH
19502: CALL_OW 44
19506: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19507: LD_ADDR_VAR 0 7
19511: PUSH
19512: LD_VAR 0 7
19516: PPUSH
19517: LD_INT 1
19519: PPUSH
19520: LD_VAR 0 14
19524: PPUSH
19525: CALL_OW 2
19529: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19530: LD_VAR 0 14
19534: PPUSH
19535: LD_VAR 0 12
19539: PUSH
19540: LD_INT 1
19542: ARRAY
19543: PPUSH
19544: CALL_OW 52
// end ;
19548: GO 19187
19550: POP
19551: POP
// end ;
19552: GO 18489
19554: POP
19555: POP
// result := result ^ buildings ;
19556: LD_ADDR_VAR 0 7
19560: PUSH
19561: LD_VAR 0 7
19565: PUSH
19566: LD_VAR 0 18
19570: ADD
19571: ST_TO_ADDR
// end else
19572: GO 19715
// begin for i = 1 to personel do
19574: LD_ADDR_VAR 0 8
19578: PUSH
19579: DOUBLE
19580: LD_INT 1
19582: DEC
19583: ST_TO_ADDR
19584: LD_VAR 0 6
19588: PUSH
19589: FOR_TO
19590: IFFALSE 19713
// begin if i > 4 then
19592: LD_VAR 0 8
19596: PUSH
19597: LD_INT 4
19599: GREATER
19600: IFFALSE 19604
// break ;
19602: GO 19713
// x := personel [ i ] ;
19604: LD_ADDR_VAR 0 13
19608: PUSH
19609: LD_VAR 0 6
19613: PUSH
19614: LD_VAR 0 8
19618: ARRAY
19619: ST_TO_ADDR
// if x = - 1 then
19620: LD_VAR 0 13
19624: PUSH
19625: LD_INT 1
19627: NEG
19628: EQUAL
19629: IFFALSE 19633
// continue ;
19631: GO 19589
// PrepareHuman ( false , i , skill ) ;
19633: LD_INT 0
19635: PPUSH
19636: LD_VAR 0 8
19640: PPUSH
19641: LD_VAR 0 4
19645: PPUSH
19646: CALL_OW 380
// un := CreateHuman ;
19650: LD_ADDR_VAR 0 14
19654: PUSH
19655: CALL_OW 44
19659: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19660: LD_VAR 0 14
19664: PPUSH
19665: LD_VAR 0 1
19669: PPUSH
19670: CALL_OW 250
19674: PPUSH
19675: LD_VAR 0 1
19679: PPUSH
19680: CALL_OW 251
19684: PPUSH
19685: LD_INT 10
19687: PPUSH
19688: LD_INT 0
19690: PPUSH
19691: CALL_OW 50
// result := result ^ un ;
19695: LD_ADDR_VAR 0 7
19699: PUSH
19700: LD_VAR 0 7
19704: PUSH
19705: LD_VAR 0 14
19709: ADD
19710: ST_TO_ADDR
// end ;
19711: GO 19589
19713: POP
19714: POP
// end ; end ;
19715: LD_VAR 0 7
19719: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19720: LD_INT 0
19722: PPUSH
19723: PPUSH
19724: PPUSH
19725: PPUSH
19726: PPUSH
19727: PPUSH
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
19732: PPUSH
19733: PPUSH
19734: PPUSH
19735: PPUSH
19736: PPUSH
19737: PPUSH
// result := false ;
19738: LD_ADDR_VAR 0 3
19742: PUSH
19743: LD_INT 0
19745: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19746: LD_VAR 0 1
19750: NOT
19751: PUSH
19752: LD_VAR 0 1
19756: PPUSH
19757: CALL_OW 266
19761: PUSH
19762: LD_INT 32
19764: PUSH
19765: LD_INT 33
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: IN
19772: NOT
19773: OR
19774: IFFALSE 19778
// exit ;
19776: GO 20914
// nat := GetNation ( tower ) ;
19778: LD_ADDR_VAR 0 12
19782: PUSH
19783: LD_VAR 0 1
19787: PPUSH
19788: CALL_OW 248
19792: ST_TO_ADDR
// side := GetSide ( tower ) ;
19793: LD_ADDR_VAR 0 16
19797: PUSH
19798: LD_VAR 0 1
19802: PPUSH
19803: CALL_OW 255
19807: ST_TO_ADDR
// x := GetX ( tower ) ;
19808: LD_ADDR_VAR 0 10
19812: PUSH
19813: LD_VAR 0 1
19817: PPUSH
19818: CALL_OW 250
19822: ST_TO_ADDR
// y := GetY ( tower ) ;
19823: LD_ADDR_VAR 0 11
19827: PUSH
19828: LD_VAR 0 1
19832: PPUSH
19833: CALL_OW 251
19837: ST_TO_ADDR
// if not x or not y then
19838: LD_VAR 0 10
19842: NOT
19843: PUSH
19844: LD_VAR 0 11
19848: NOT
19849: OR
19850: IFFALSE 19854
// exit ;
19852: GO 20914
// weapon := 0 ;
19854: LD_ADDR_VAR 0 18
19858: PUSH
19859: LD_INT 0
19861: ST_TO_ADDR
// fac_list := [ ] ;
19862: LD_ADDR_VAR 0 17
19866: PUSH
19867: EMPTY
19868: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
19869: LD_ADDR_VAR 0 6
19873: PUSH
19874: LD_VAR 0 1
19878: PPUSH
19879: CALL_OW 274
19883: PPUSH
19884: LD_VAR 0 2
19888: PPUSH
19889: CALL 17492 0 2
19893: PPUSH
19894: LD_INT 30
19896: PUSH
19897: LD_INT 3
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: PPUSH
19904: CALL_OW 72
19908: ST_TO_ADDR
// if not factories then
19909: LD_VAR 0 6
19913: NOT
19914: IFFALSE 19918
// exit ;
19916: GO 20914
// for i in factories do
19918: LD_ADDR_VAR 0 8
19922: PUSH
19923: LD_VAR 0 6
19927: PUSH
19928: FOR_IN
19929: IFFALSE 19954
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19931: LD_ADDR_VAR 0 17
19935: PUSH
19936: LD_VAR 0 17
19940: PUSH
19941: LD_VAR 0 8
19945: PPUSH
19946: CALL_OW 478
19950: UNION
19951: ST_TO_ADDR
19952: GO 19928
19954: POP
19955: POP
// if not fac_list then
19956: LD_VAR 0 17
19960: NOT
19961: IFFALSE 19965
// exit ;
19963: GO 20914
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
19965: LD_ADDR_VAR 0 5
19969: PUSH
19970: LD_INT 4
19972: PUSH
19973: LD_INT 5
19975: PUSH
19976: LD_INT 9
19978: PUSH
19979: LD_INT 10
19981: PUSH
19982: LD_INT 6
19984: PUSH
19985: LD_INT 7
19987: PUSH
19988: LD_INT 11
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: PUSH
20000: LD_INT 27
20002: PUSH
20003: LD_INT 28
20005: PUSH
20006: LD_INT 26
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: EMPTY
20013: LIST
20014: LIST
20015: LIST
20016: LIST
20017: PUSH
20018: LD_INT 43
20020: PUSH
20021: LD_INT 44
20023: PUSH
20024: LD_INT 46
20026: PUSH
20027: LD_INT 45
20029: PUSH
20030: LD_INT 47
20032: PUSH
20033: LD_INT 49
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: LIST
20041: LIST
20042: LIST
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: LIST
20048: PUSH
20049: LD_VAR 0 12
20053: ARRAY
20054: ST_TO_ADDR
// for i in list do
20055: LD_ADDR_VAR 0 8
20059: PUSH
20060: LD_VAR 0 5
20064: PUSH
20065: FOR_IN
20066: IFFALSE 20099
// if not i in fac_list then
20068: LD_VAR 0 8
20072: PUSH
20073: LD_VAR 0 17
20077: IN
20078: NOT
20079: IFFALSE 20097
// list := list diff i ;
20081: LD_ADDR_VAR 0 5
20085: PUSH
20086: LD_VAR 0 5
20090: PUSH
20091: LD_VAR 0 8
20095: DIFF
20096: ST_TO_ADDR
20097: GO 20065
20099: POP
20100: POP
// if not list then
20101: LD_VAR 0 5
20105: NOT
20106: IFFALSE 20110
// exit ;
20108: GO 20914
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20110: LD_VAR 0 12
20114: PUSH
20115: LD_INT 3
20117: EQUAL
20118: PUSH
20119: LD_INT 49
20121: PUSH
20122: LD_VAR 0 5
20126: IN
20127: AND
20128: PUSH
20129: LD_INT 31
20131: PPUSH
20132: LD_VAR 0 16
20136: PPUSH
20137: CALL_OW 321
20141: PUSH
20142: LD_INT 2
20144: EQUAL
20145: AND
20146: IFFALSE 20206
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20148: LD_INT 22
20150: PUSH
20151: LD_VAR 0 16
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 35
20162: PUSH
20163: LD_INT 49
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: PUSH
20170: LD_INT 91
20172: PUSH
20173: LD_VAR 0 1
20177: PUSH
20178: LD_INT 10
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: LIST
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: LIST
20190: PPUSH
20191: CALL_OW 69
20195: NOT
20196: IFFALSE 20206
// weapon := ru_time_lapser ;
20198: LD_ADDR_VAR 0 18
20202: PUSH
20203: LD_INT 49
20205: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20206: LD_VAR 0 12
20210: PUSH
20211: LD_INT 1
20213: PUSH
20214: LD_INT 2
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: IN
20221: PUSH
20222: LD_INT 11
20224: PUSH
20225: LD_VAR 0 5
20229: IN
20230: PUSH
20231: LD_INT 30
20233: PUSH
20234: LD_VAR 0 5
20238: IN
20239: OR
20240: AND
20241: PUSH
20242: LD_INT 6
20244: PPUSH
20245: LD_VAR 0 16
20249: PPUSH
20250: CALL_OW 321
20254: PUSH
20255: LD_INT 2
20257: EQUAL
20258: AND
20259: IFFALSE 20424
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20261: LD_INT 22
20263: PUSH
20264: LD_VAR 0 16
20268: PUSH
20269: EMPTY
20270: LIST
20271: LIST
20272: PUSH
20273: LD_INT 2
20275: PUSH
20276: LD_INT 35
20278: PUSH
20279: LD_INT 11
20281: PUSH
20282: EMPTY
20283: LIST
20284: LIST
20285: PUSH
20286: LD_INT 35
20288: PUSH
20289: LD_INT 30
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 91
20303: PUSH
20304: LD_VAR 0 1
20308: PUSH
20309: LD_INT 18
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: LIST
20321: PPUSH
20322: CALL_OW 69
20326: NOT
20327: PUSH
20328: LD_INT 22
20330: PUSH
20331: LD_VAR 0 16
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: LD_INT 2
20342: PUSH
20343: LD_INT 30
20345: PUSH
20346: LD_INT 32
20348: PUSH
20349: EMPTY
20350: LIST
20351: LIST
20352: PUSH
20353: LD_INT 30
20355: PUSH
20356: LD_INT 33
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: LIST
20367: PUSH
20368: LD_INT 91
20370: PUSH
20371: LD_VAR 0 1
20375: PUSH
20376: LD_INT 12
20378: PUSH
20379: EMPTY
20380: LIST
20381: LIST
20382: LIST
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: PUSH
20389: EMPTY
20390: LIST
20391: PPUSH
20392: CALL_OW 69
20396: PUSH
20397: LD_INT 2
20399: GREATER
20400: AND
20401: IFFALSE 20424
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20403: LD_ADDR_VAR 0 18
20407: PUSH
20408: LD_INT 11
20410: PUSH
20411: LD_INT 30
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: PUSH
20418: LD_VAR 0 12
20422: ARRAY
20423: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20424: LD_VAR 0 18
20428: NOT
20429: PUSH
20430: LD_INT 40
20432: PPUSH
20433: LD_VAR 0 16
20437: PPUSH
20438: CALL_OW 321
20442: PUSH
20443: LD_INT 2
20445: EQUAL
20446: AND
20447: PUSH
20448: LD_INT 7
20450: PUSH
20451: LD_VAR 0 5
20455: IN
20456: PUSH
20457: LD_INT 28
20459: PUSH
20460: LD_VAR 0 5
20464: IN
20465: OR
20466: PUSH
20467: LD_INT 45
20469: PUSH
20470: LD_VAR 0 5
20474: IN
20475: OR
20476: AND
20477: IFFALSE 20731
// begin hex := GetHexInfo ( x , y ) ;
20479: LD_ADDR_VAR 0 4
20483: PUSH
20484: LD_VAR 0 10
20488: PPUSH
20489: LD_VAR 0 11
20493: PPUSH
20494: CALL_OW 546
20498: ST_TO_ADDR
// if hex [ 1 ] then
20499: LD_VAR 0 4
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: IFFALSE 20511
// exit ;
20509: GO 20914
// height := hex [ 2 ] ;
20511: LD_ADDR_VAR 0 15
20515: PUSH
20516: LD_VAR 0 4
20520: PUSH
20521: LD_INT 2
20523: ARRAY
20524: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20525: LD_ADDR_VAR 0 14
20529: PUSH
20530: LD_INT 0
20532: PUSH
20533: LD_INT 2
20535: PUSH
20536: LD_INT 3
20538: PUSH
20539: LD_INT 5
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: ST_TO_ADDR
// for i in tmp do
20548: LD_ADDR_VAR 0 8
20552: PUSH
20553: LD_VAR 0 14
20557: PUSH
20558: FOR_IN
20559: IFFALSE 20729
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20561: LD_ADDR_VAR 0 9
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: LD_VAR 0 8
20575: PPUSH
20576: LD_INT 5
20578: PPUSH
20579: CALL_OW 272
20583: PUSH
20584: LD_VAR 0 11
20588: PPUSH
20589: LD_VAR 0 8
20593: PPUSH
20594: LD_INT 5
20596: PPUSH
20597: CALL_OW 273
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20606: LD_VAR 0 9
20610: PUSH
20611: LD_INT 1
20613: ARRAY
20614: PPUSH
20615: LD_VAR 0 9
20619: PUSH
20620: LD_INT 2
20622: ARRAY
20623: PPUSH
20624: CALL_OW 488
20628: IFFALSE 20727
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20630: LD_ADDR_VAR 0 4
20634: PUSH
20635: LD_VAR 0 9
20639: PUSH
20640: LD_INT 1
20642: ARRAY
20643: PPUSH
20644: LD_VAR 0 9
20648: PUSH
20649: LD_INT 2
20651: ARRAY
20652: PPUSH
20653: CALL_OW 546
20657: ST_TO_ADDR
// if hex [ 1 ] then
20658: LD_VAR 0 4
20662: PUSH
20663: LD_INT 1
20665: ARRAY
20666: IFFALSE 20670
// continue ;
20668: GO 20558
// h := hex [ 2 ] ;
20670: LD_ADDR_VAR 0 13
20674: PUSH
20675: LD_VAR 0 4
20679: PUSH
20680: LD_INT 2
20682: ARRAY
20683: ST_TO_ADDR
// if h + 7 < height then
20684: LD_VAR 0 13
20688: PUSH
20689: LD_INT 7
20691: PLUS
20692: PUSH
20693: LD_VAR 0 15
20697: LESS
20698: IFFALSE 20727
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20700: LD_ADDR_VAR 0 18
20704: PUSH
20705: LD_INT 7
20707: PUSH
20708: LD_INT 28
20710: PUSH
20711: LD_INT 45
20713: PUSH
20714: EMPTY
20715: LIST
20716: LIST
20717: LIST
20718: PUSH
20719: LD_VAR 0 12
20723: ARRAY
20724: ST_TO_ADDR
// break ;
20725: GO 20729
// end ; end ; end ;
20727: GO 20558
20729: POP
20730: POP
// end ; if not weapon then
20731: LD_VAR 0 18
20735: NOT
20736: IFFALSE 20796
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20738: LD_ADDR_VAR 0 5
20742: PUSH
20743: LD_VAR 0 5
20747: PUSH
20748: LD_INT 11
20750: PUSH
20751: LD_INT 30
20753: PUSH
20754: LD_INT 49
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: LIST
20761: DIFF
20762: ST_TO_ADDR
// if not list then
20763: LD_VAR 0 5
20767: NOT
20768: IFFALSE 20772
// exit ;
20770: GO 20914
// weapon := list [ rand ( 1 , list ) ] ;
20772: LD_ADDR_VAR 0 18
20776: PUSH
20777: LD_VAR 0 5
20781: PUSH
20782: LD_INT 1
20784: PPUSH
20785: LD_VAR 0 5
20789: PPUSH
20790: CALL_OW 12
20794: ARRAY
20795: ST_TO_ADDR
// end ; if weapon then
20796: LD_VAR 0 18
20800: IFFALSE 20914
// begin tmp := CostOfWeapon ( weapon ) ;
20802: LD_ADDR_VAR 0 14
20806: PUSH
20807: LD_VAR 0 18
20811: PPUSH
20812: CALL_OW 451
20816: ST_TO_ADDR
// j := GetBase ( tower ) ;
20817: LD_ADDR_VAR 0 9
20821: PUSH
20822: LD_VAR 0 1
20826: PPUSH
20827: CALL_OW 274
20831: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20832: LD_VAR 0 9
20836: PPUSH
20837: LD_INT 1
20839: PPUSH
20840: CALL_OW 275
20844: PUSH
20845: LD_VAR 0 14
20849: PUSH
20850: LD_INT 1
20852: ARRAY
20853: GREATEREQUAL
20854: PUSH
20855: LD_VAR 0 9
20859: PPUSH
20860: LD_INT 2
20862: PPUSH
20863: CALL_OW 275
20867: PUSH
20868: LD_VAR 0 14
20872: PUSH
20873: LD_INT 2
20875: ARRAY
20876: GREATEREQUAL
20877: AND
20878: PUSH
20879: LD_VAR 0 9
20883: PPUSH
20884: LD_INT 3
20886: PPUSH
20887: CALL_OW 275
20891: PUSH
20892: LD_VAR 0 14
20896: PUSH
20897: LD_INT 3
20899: ARRAY
20900: GREATEREQUAL
20901: AND
20902: IFFALSE 20914
// result := weapon ;
20904: LD_ADDR_VAR 0 3
20908: PUSH
20909: LD_VAR 0 18
20913: ST_TO_ADDR
// end ; end ;
20914: LD_VAR 0 3
20918: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20919: LD_INT 0
20921: PPUSH
20922: PPUSH
// result := true ;
20923: LD_ADDR_VAR 0 3
20927: PUSH
20928: LD_INT 1
20930: ST_TO_ADDR
// if array1 = array2 then
20931: LD_VAR 0 1
20935: PUSH
20936: LD_VAR 0 2
20940: EQUAL
20941: IFFALSE 21001
// begin for i = 1 to array1 do
20943: LD_ADDR_VAR 0 4
20947: PUSH
20948: DOUBLE
20949: LD_INT 1
20951: DEC
20952: ST_TO_ADDR
20953: LD_VAR 0 1
20957: PUSH
20958: FOR_TO
20959: IFFALSE 20997
// if array1 [ i ] <> array2 [ i ] then
20961: LD_VAR 0 1
20965: PUSH
20966: LD_VAR 0 4
20970: ARRAY
20971: PUSH
20972: LD_VAR 0 2
20976: PUSH
20977: LD_VAR 0 4
20981: ARRAY
20982: NONEQUAL
20983: IFFALSE 20995
// begin result := false ;
20985: LD_ADDR_VAR 0 3
20989: PUSH
20990: LD_INT 0
20992: ST_TO_ADDR
// break ;
20993: GO 20997
// end ;
20995: GO 20958
20997: POP
20998: POP
// end else
20999: GO 21009
// result := false ;
21001: LD_ADDR_VAR 0 3
21005: PUSH
21006: LD_INT 0
21008: ST_TO_ADDR
// end ;
21009: LD_VAR 0 3
21013: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21014: LD_INT 0
21016: PPUSH
21017: PPUSH
21018: PPUSH
// pom := GetBase ( fac ) ;
21019: LD_ADDR_VAR 0 5
21023: PUSH
21024: LD_VAR 0 1
21028: PPUSH
21029: CALL_OW 274
21033: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21034: LD_ADDR_VAR 0 4
21038: PUSH
21039: LD_VAR 0 2
21043: PUSH
21044: LD_INT 1
21046: ARRAY
21047: PPUSH
21048: LD_VAR 0 2
21052: PUSH
21053: LD_INT 2
21055: ARRAY
21056: PPUSH
21057: LD_VAR 0 2
21061: PUSH
21062: LD_INT 3
21064: ARRAY
21065: PPUSH
21066: LD_VAR 0 2
21070: PUSH
21071: LD_INT 4
21073: ARRAY
21074: PPUSH
21075: CALL_OW 449
21079: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21080: LD_ADDR_VAR 0 3
21084: PUSH
21085: LD_VAR 0 5
21089: PPUSH
21090: LD_INT 1
21092: PPUSH
21093: CALL_OW 275
21097: PUSH
21098: LD_VAR 0 4
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: GREATEREQUAL
21107: PUSH
21108: LD_VAR 0 5
21112: PPUSH
21113: LD_INT 2
21115: PPUSH
21116: CALL_OW 275
21120: PUSH
21121: LD_VAR 0 4
21125: PUSH
21126: LD_INT 2
21128: ARRAY
21129: GREATEREQUAL
21130: AND
21131: PUSH
21132: LD_VAR 0 5
21136: PPUSH
21137: LD_INT 3
21139: PPUSH
21140: CALL_OW 275
21144: PUSH
21145: LD_VAR 0 4
21149: PUSH
21150: LD_INT 3
21152: ARRAY
21153: GREATEREQUAL
21154: AND
21155: ST_TO_ADDR
// end ;
21156: LD_VAR 0 3
21160: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21161: LD_INT 0
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
// pom := GetBase ( building ) ;
21167: LD_ADDR_VAR 0 3
21171: PUSH
21172: LD_VAR 0 1
21176: PPUSH
21177: CALL_OW 274
21181: ST_TO_ADDR
// if not pom then
21182: LD_VAR 0 3
21186: NOT
21187: IFFALSE 21191
// exit ;
21189: GO 21361
// btype := GetBType ( building ) ;
21191: LD_ADDR_VAR 0 5
21195: PUSH
21196: LD_VAR 0 1
21200: PPUSH
21201: CALL_OW 266
21205: ST_TO_ADDR
// if btype = b_armoury then
21206: LD_VAR 0 5
21210: PUSH
21211: LD_INT 4
21213: EQUAL
21214: IFFALSE 21224
// btype := b_barracks ;
21216: LD_ADDR_VAR 0 5
21220: PUSH
21221: LD_INT 5
21223: ST_TO_ADDR
// if btype = b_depot then
21224: LD_VAR 0 5
21228: PUSH
21229: LD_INT 0
21231: EQUAL
21232: IFFALSE 21242
// btype := b_warehouse ;
21234: LD_ADDR_VAR 0 5
21238: PUSH
21239: LD_INT 1
21241: ST_TO_ADDR
// if btype = b_workshop then
21242: LD_VAR 0 5
21246: PUSH
21247: LD_INT 2
21249: EQUAL
21250: IFFALSE 21260
// btype := b_factory ;
21252: LD_ADDR_VAR 0 5
21256: PUSH
21257: LD_INT 3
21259: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21260: LD_ADDR_VAR 0 4
21264: PUSH
21265: LD_VAR 0 5
21269: PPUSH
21270: LD_VAR 0 1
21274: PPUSH
21275: CALL_OW 248
21279: PPUSH
21280: CALL_OW 450
21284: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21285: LD_ADDR_VAR 0 2
21289: PUSH
21290: LD_VAR 0 3
21294: PPUSH
21295: LD_INT 1
21297: PPUSH
21298: CALL_OW 275
21302: PUSH
21303: LD_VAR 0 4
21307: PUSH
21308: LD_INT 1
21310: ARRAY
21311: GREATEREQUAL
21312: PUSH
21313: LD_VAR 0 3
21317: PPUSH
21318: LD_INT 2
21320: PPUSH
21321: CALL_OW 275
21325: PUSH
21326: LD_VAR 0 4
21330: PUSH
21331: LD_INT 2
21333: ARRAY
21334: GREATEREQUAL
21335: AND
21336: PUSH
21337: LD_VAR 0 3
21341: PPUSH
21342: LD_INT 3
21344: PPUSH
21345: CALL_OW 275
21349: PUSH
21350: LD_VAR 0 4
21354: PUSH
21355: LD_INT 3
21357: ARRAY
21358: GREATEREQUAL
21359: AND
21360: ST_TO_ADDR
// end ;
21361: LD_VAR 0 2
21365: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21366: LD_INT 0
21368: PPUSH
21369: PPUSH
21370: PPUSH
// pom := GetBase ( building ) ;
21371: LD_ADDR_VAR 0 4
21375: PUSH
21376: LD_VAR 0 1
21380: PPUSH
21381: CALL_OW 274
21385: ST_TO_ADDR
// if not pom then
21386: LD_VAR 0 4
21390: NOT
21391: IFFALSE 21395
// exit ;
21393: GO 21496
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21395: LD_ADDR_VAR 0 5
21399: PUSH
21400: LD_VAR 0 2
21404: PPUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 248
21414: PPUSH
21415: CALL_OW 450
21419: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21420: LD_ADDR_VAR 0 3
21424: PUSH
21425: LD_VAR 0 4
21429: PPUSH
21430: LD_INT 1
21432: PPUSH
21433: CALL_OW 275
21437: PUSH
21438: LD_VAR 0 5
21442: PUSH
21443: LD_INT 1
21445: ARRAY
21446: GREATEREQUAL
21447: PUSH
21448: LD_VAR 0 4
21452: PPUSH
21453: LD_INT 2
21455: PPUSH
21456: CALL_OW 275
21460: PUSH
21461: LD_VAR 0 5
21465: PUSH
21466: LD_INT 2
21468: ARRAY
21469: GREATEREQUAL
21470: AND
21471: PUSH
21472: LD_VAR 0 4
21476: PPUSH
21477: LD_INT 3
21479: PPUSH
21480: CALL_OW 275
21484: PUSH
21485: LD_VAR 0 5
21489: PUSH
21490: LD_INT 3
21492: ARRAY
21493: GREATEREQUAL
21494: AND
21495: ST_TO_ADDR
// end ;
21496: LD_VAR 0 3
21500: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
21501: LD_INT 0
21503: PPUSH
21504: PPUSH
21505: PPUSH
21506: PPUSH
21507: PPUSH
21508: PPUSH
21509: PPUSH
21510: PPUSH
21511: PPUSH
21512: PPUSH
// result := false ;
21513: LD_ADDR_VAR 0 6
21517: PUSH
21518: LD_INT 0
21520: ST_TO_ADDR
// if not base or not btype or not x or not y then
21521: LD_VAR 0 1
21525: NOT
21526: PUSH
21527: LD_VAR 0 2
21531: NOT
21532: OR
21533: PUSH
21534: LD_VAR 0 3
21538: NOT
21539: OR
21540: PUSH
21541: LD_VAR 0 4
21545: NOT
21546: OR
21547: IFFALSE 21551
// exit ;
21549: GO 22160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
21551: LD_ADDR_VAR 0 12
21555: PUSH
21556: LD_VAR 0 2
21560: PPUSH
21561: LD_VAR 0 3
21565: PPUSH
21566: LD_VAR 0 4
21570: PPUSH
21571: LD_VAR 0 5
21575: PPUSH
21576: LD_VAR 0 1
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PPUSH
21585: CALL_OW 248
21589: PPUSH
21590: LD_INT 0
21592: PPUSH
21593: CALL 22997 0 6
21597: ST_TO_ADDR
// if not hexes then
21598: LD_VAR 0 12
21602: NOT
21603: IFFALSE 21607
// exit ;
21605: GO 22160
// for i = 1 to hexes do
21607: LD_ADDR_VAR 0 7
21611: PUSH
21612: DOUBLE
21613: LD_INT 1
21615: DEC
21616: ST_TO_ADDR
21617: LD_VAR 0 12
21621: PUSH
21622: FOR_TO
21623: IFFALSE 22158
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21625: LD_ADDR_VAR 0 11
21629: PUSH
21630: LD_VAR 0 12
21634: PUSH
21635: LD_VAR 0 7
21639: ARRAY
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 12
21649: PUSH
21650: LD_VAR 0 7
21654: ARRAY
21655: PUSH
21656: LD_INT 2
21658: ARRAY
21659: PPUSH
21660: CALL_OW 428
21664: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21665: LD_VAR 0 12
21669: PUSH
21670: LD_VAR 0 7
21674: ARRAY
21675: PUSH
21676: LD_INT 1
21678: ARRAY
21679: PPUSH
21680: LD_VAR 0 12
21684: PUSH
21685: LD_VAR 0 7
21689: ARRAY
21690: PUSH
21691: LD_INT 2
21693: ARRAY
21694: PPUSH
21695: CALL_OW 351
21699: PUSH
21700: LD_VAR 0 12
21704: PUSH
21705: LD_VAR 0 7
21709: ARRAY
21710: PUSH
21711: LD_INT 1
21713: ARRAY
21714: PPUSH
21715: LD_VAR 0 12
21719: PUSH
21720: LD_VAR 0 7
21724: ARRAY
21725: PUSH
21726: LD_INT 2
21728: ARRAY
21729: PPUSH
21730: CALL_OW 488
21734: NOT
21735: OR
21736: PUSH
21737: LD_VAR 0 11
21741: PPUSH
21742: CALL_OW 247
21746: PUSH
21747: LD_INT 3
21749: EQUAL
21750: OR
21751: IFFALSE 21757
// exit ;
21753: POP
21754: POP
21755: GO 22160
// if not tmp or not tmp in base then
21757: LD_VAR 0 11
21761: NOT
21762: PUSH
21763: LD_VAR 0 11
21767: PUSH
21768: LD_VAR 0 1
21772: IN
21773: NOT
21774: OR
21775: IFFALSE 21779
// continue ;
21777: GO 21622
// result := true ;
21779: LD_ADDR_VAR 0 6
21783: PUSH
21784: LD_INT 1
21786: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21787: LD_ADDR_VAR 0 15
21791: PUSH
21792: LD_VAR 0 1
21796: PPUSH
21797: LD_INT 22
21799: PUSH
21800: LD_VAR 0 11
21804: PPUSH
21805: CALL_OW 255
21809: PUSH
21810: EMPTY
21811: LIST
21812: LIST
21813: PUSH
21814: LD_INT 2
21816: PUSH
21817: LD_INT 30
21819: PUSH
21820: LD_INT 0
21822: PUSH
21823: EMPTY
21824: LIST
21825: LIST
21826: PUSH
21827: LD_INT 30
21829: PUSH
21830: LD_INT 1
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: LIST
21841: PUSH
21842: EMPTY
21843: LIST
21844: LIST
21845: PPUSH
21846: CALL_OW 72
21850: ST_TO_ADDR
// if dep then
21851: LD_VAR 0 15
21855: IFFALSE 21991
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21857: LD_ADDR_VAR 0 14
21861: PUSH
21862: LD_VAR 0 15
21866: PUSH
21867: LD_INT 1
21869: ARRAY
21870: PPUSH
21871: CALL_OW 250
21875: PPUSH
21876: LD_VAR 0 15
21880: PUSH
21881: LD_INT 1
21883: ARRAY
21884: PPUSH
21885: CALL_OW 254
21889: PPUSH
21890: LD_INT 5
21892: PPUSH
21893: CALL_OW 272
21897: PUSH
21898: LD_VAR 0 15
21902: PUSH
21903: LD_INT 1
21905: ARRAY
21906: PPUSH
21907: CALL_OW 251
21911: PPUSH
21912: LD_VAR 0 15
21916: PUSH
21917: LD_INT 1
21919: ARRAY
21920: PPUSH
21921: CALL_OW 254
21925: PPUSH
21926: LD_INT 5
21928: PPUSH
21929: CALL_OW 273
21933: PUSH
21934: EMPTY
21935: LIST
21936: LIST
21937: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21938: LD_VAR 0 14
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: LD_VAR 0 14
21951: PUSH
21952: LD_INT 2
21954: ARRAY
21955: PPUSH
21956: CALL_OW 488
21960: IFFALSE 21991
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
21962: LD_VAR 0 11
21966: PPUSH
21967: LD_VAR 0 14
21971: PUSH
21972: LD_INT 1
21974: ARRAY
21975: PPUSH
21976: LD_VAR 0 14
21980: PUSH
21981: LD_INT 2
21983: ARRAY
21984: PPUSH
21985: CALL_OW 111
// continue ;
21989: GO 21622
// end ; end ; r := GetDir ( tmp ) ;
21991: LD_ADDR_VAR 0 13
21995: PUSH
21996: LD_VAR 0 11
22000: PPUSH
22001: CALL_OW 254
22005: ST_TO_ADDR
// if r = 5 then
22006: LD_VAR 0 13
22010: PUSH
22011: LD_INT 5
22013: EQUAL
22014: IFFALSE 22024
// r := 0 ;
22016: LD_ADDR_VAR 0 13
22020: PUSH
22021: LD_INT 0
22023: ST_TO_ADDR
// for j = r to 5 do
22024: LD_ADDR_VAR 0 8
22028: PUSH
22029: DOUBLE
22030: LD_VAR 0 13
22034: DEC
22035: ST_TO_ADDR
22036: LD_INT 5
22038: PUSH
22039: FOR_TO
22040: IFFALSE 22154
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22042: LD_ADDR_VAR 0 9
22046: PUSH
22047: LD_VAR 0 11
22051: PPUSH
22052: CALL_OW 250
22056: PPUSH
22057: LD_VAR 0 8
22061: PPUSH
22062: LD_INT 2
22064: PPUSH
22065: CALL_OW 272
22069: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22070: LD_ADDR_VAR 0 10
22074: PUSH
22075: LD_VAR 0 11
22079: PPUSH
22080: CALL_OW 251
22084: PPUSH
22085: LD_VAR 0 8
22089: PPUSH
22090: LD_INT 2
22092: PPUSH
22093: CALL_OW 273
22097: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22098: LD_VAR 0 9
22102: PPUSH
22103: LD_VAR 0 10
22107: PPUSH
22108: CALL_OW 488
22112: PUSH
22113: LD_VAR 0 9
22117: PPUSH
22118: LD_VAR 0 10
22122: PPUSH
22123: CALL_OW 428
22127: NOT
22128: AND
22129: IFFALSE 22152
// begin ComMoveXY ( tmp , _x , _y ) ;
22131: LD_VAR 0 11
22135: PPUSH
22136: LD_VAR 0 9
22140: PPUSH
22141: LD_VAR 0 10
22145: PPUSH
22146: CALL_OW 111
// break ;
22150: GO 22154
// end ; end ;
22152: GO 22039
22154: POP
22155: POP
// end ;
22156: GO 21622
22158: POP
22159: POP
// end ;
22160: LD_VAR 0 6
22164: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22165: LD_INT 0
22167: PPUSH
22168: PPUSH
22169: PPUSH
22170: PPUSH
22171: PPUSH
22172: PPUSH
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
// result := false ;
22177: LD_ADDR_VAR 0 6
22181: PUSH
22182: LD_INT 0
22184: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22185: LD_VAR 0 1
22189: NOT
22190: PUSH
22191: LD_VAR 0 1
22195: PPUSH
22196: CALL_OW 266
22200: PUSH
22201: LD_INT 0
22203: PUSH
22204: LD_INT 1
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: IN
22211: NOT
22212: OR
22213: PUSH
22214: LD_VAR 0 2
22218: NOT
22219: OR
22220: PUSH
22221: LD_VAR 0 5
22225: PUSH
22226: LD_INT 0
22228: PUSH
22229: LD_INT 1
22231: PUSH
22232: LD_INT 2
22234: PUSH
22235: LD_INT 3
22237: PUSH
22238: LD_INT 4
22240: PUSH
22241: LD_INT 5
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: IN
22252: NOT
22253: OR
22254: PUSH
22255: LD_VAR 0 3
22259: PPUSH
22260: LD_VAR 0 4
22264: PPUSH
22265: CALL_OW 488
22269: NOT
22270: OR
22271: IFFALSE 22275
// exit ;
22273: GO 22992
// pom := GetBase ( depot ) ;
22275: LD_ADDR_VAR 0 10
22279: PUSH
22280: LD_VAR 0 1
22284: PPUSH
22285: CALL_OW 274
22289: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22290: LD_ADDR_VAR 0 11
22294: PUSH
22295: LD_VAR 0 2
22299: PPUSH
22300: LD_VAR 0 1
22304: PPUSH
22305: CALL_OW 248
22309: PPUSH
22310: CALL_OW 450
22314: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22315: LD_VAR 0 10
22319: PPUSH
22320: LD_INT 1
22322: PPUSH
22323: CALL_OW 275
22327: PUSH
22328: LD_VAR 0 11
22332: PUSH
22333: LD_INT 1
22335: ARRAY
22336: GREATEREQUAL
22337: PUSH
22338: LD_VAR 0 10
22342: PPUSH
22343: LD_INT 2
22345: PPUSH
22346: CALL_OW 275
22350: PUSH
22351: LD_VAR 0 11
22355: PUSH
22356: LD_INT 2
22358: ARRAY
22359: GREATEREQUAL
22360: AND
22361: PUSH
22362: LD_VAR 0 10
22366: PPUSH
22367: LD_INT 3
22369: PPUSH
22370: CALL_OW 275
22374: PUSH
22375: LD_VAR 0 11
22379: PUSH
22380: LD_INT 3
22382: ARRAY
22383: GREATEREQUAL
22384: AND
22385: NOT
22386: IFFALSE 22390
// exit ;
22388: GO 22992
// if GetBType ( depot ) = b_depot then
22390: LD_VAR 0 1
22394: PPUSH
22395: CALL_OW 266
22399: PUSH
22400: LD_INT 0
22402: EQUAL
22403: IFFALSE 22415
// dist := 28 else
22405: LD_ADDR_VAR 0 14
22409: PUSH
22410: LD_INT 28
22412: ST_TO_ADDR
22413: GO 22423
// dist := 36 ;
22415: LD_ADDR_VAR 0 14
22419: PUSH
22420: LD_INT 36
22422: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22423: LD_VAR 0 1
22427: PPUSH
22428: LD_VAR 0 3
22432: PPUSH
22433: LD_VAR 0 4
22437: PPUSH
22438: CALL_OW 297
22442: PUSH
22443: LD_VAR 0 14
22447: GREATER
22448: IFFALSE 22452
// exit ;
22450: GO 22992
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22452: LD_ADDR_VAR 0 12
22456: PUSH
22457: LD_VAR 0 2
22461: PPUSH
22462: LD_VAR 0 3
22466: PPUSH
22467: LD_VAR 0 4
22471: PPUSH
22472: LD_VAR 0 5
22476: PPUSH
22477: LD_VAR 0 1
22481: PPUSH
22482: CALL_OW 248
22486: PPUSH
22487: LD_INT 0
22489: PPUSH
22490: CALL 22997 0 6
22494: ST_TO_ADDR
// if not hexes then
22495: LD_VAR 0 12
22499: NOT
22500: IFFALSE 22504
// exit ;
22502: GO 22992
// hex := GetHexInfo ( x , y ) ;
22504: LD_ADDR_VAR 0 15
22508: PUSH
22509: LD_VAR 0 3
22513: PPUSH
22514: LD_VAR 0 4
22518: PPUSH
22519: CALL_OW 546
22523: ST_TO_ADDR
// if hex [ 1 ] then
22524: LD_VAR 0 15
22528: PUSH
22529: LD_INT 1
22531: ARRAY
22532: IFFALSE 22536
// exit ;
22534: GO 22992
// height := hex [ 2 ] ;
22536: LD_ADDR_VAR 0 13
22540: PUSH
22541: LD_VAR 0 15
22545: PUSH
22546: LD_INT 2
22548: ARRAY
22549: ST_TO_ADDR
// for i = 1 to hexes do
22550: LD_ADDR_VAR 0 7
22554: PUSH
22555: DOUBLE
22556: LD_INT 1
22558: DEC
22559: ST_TO_ADDR
22560: LD_VAR 0 12
22564: PUSH
22565: FOR_TO
22566: IFFALSE 22896
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22568: LD_VAR 0 12
22572: PUSH
22573: LD_VAR 0 7
22577: ARRAY
22578: PUSH
22579: LD_INT 1
22581: ARRAY
22582: PPUSH
22583: LD_VAR 0 12
22587: PUSH
22588: LD_VAR 0 7
22592: ARRAY
22593: PUSH
22594: LD_INT 2
22596: ARRAY
22597: PPUSH
22598: CALL_OW 488
22602: NOT
22603: PUSH
22604: LD_VAR 0 12
22608: PUSH
22609: LD_VAR 0 7
22613: ARRAY
22614: PUSH
22615: LD_INT 1
22617: ARRAY
22618: PPUSH
22619: LD_VAR 0 12
22623: PUSH
22624: LD_VAR 0 7
22628: ARRAY
22629: PUSH
22630: LD_INT 2
22632: ARRAY
22633: PPUSH
22634: CALL_OW 428
22638: PUSH
22639: LD_INT 0
22641: GREATER
22642: OR
22643: PUSH
22644: LD_VAR 0 12
22648: PUSH
22649: LD_VAR 0 7
22653: ARRAY
22654: PUSH
22655: LD_INT 1
22657: ARRAY
22658: PPUSH
22659: LD_VAR 0 12
22663: PUSH
22664: LD_VAR 0 7
22668: ARRAY
22669: PUSH
22670: LD_INT 2
22672: ARRAY
22673: PPUSH
22674: CALL_OW 351
22678: OR
22679: IFFALSE 22685
// exit ;
22681: POP
22682: POP
22683: GO 22992
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22685: LD_ADDR_VAR 0 8
22689: PUSH
22690: LD_VAR 0 12
22694: PUSH
22695: LD_VAR 0 7
22699: ARRAY
22700: PUSH
22701: LD_INT 1
22703: ARRAY
22704: PPUSH
22705: LD_VAR 0 12
22709: PUSH
22710: LD_VAR 0 7
22714: ARRAY
22715: PUSH
22716: LD_INT 2
22718: ARRAY
22719: PPUSH
22720: CALL_OW 546
22724: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22725: LD_VAR 0 8
22729: PUSH
22730: LD_INT 1
22732: ARRAY
22733: PUSH
22734: LD_VAR 0 8
22738: PUSH
22739: LD_INT 2
22741: ARRAY
22742: PUSH
22743: LD_VAR 0 13
22747: PUSH
22748: LD_INT 2
22750: PLUS
22751: GREATER
22752: OR
22753: PUSH
22754: LD_VAR 0 8
22758: PUSH
22759: LD_INT 2
22761: ARRAY
22762: PUSH
22763: LD_VAR 0 13
22767: PUSH
22768: LD_INT 2
22770: MINUS
22771: LESS
22772: OR
22773: PUSH
22774: LD_VAR 0 8
22778: PUSH
22779: LD_INT 3
22781: ARRAY
22782: PUSH
22783: LD_INT 0
22785: PUSH
22786: LD_INT 8
22788: PUSH
22789: LD_INT 9
22791: PUSH
22792: LD_INT 10
22794: PUSH
22795: LD_INT 11
22797: PUSH
22798: LD_INT 12
22800: PUSH
22801: LD_INT 13
22803: PUSH
22804: LD_INT 16
22806: PUSH
22807: LD_INT 17
22809: PUSH
22810: LD_INT 18
22812: PUSH
22813: LD_INT 19
22815: PUSH
22816: LD_INT 20
22818: PUSH
22819: LD_INT 21
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: IN
22837: NOT
22838: OR
22839: PUSH
22840: LD_VAR 0 8
22844: PUSH
22845: LD_INT 5
22847: ARRAY
22848: NOT
22849: OR
22850: PUSH
22851: LD_VAR 0 8
22855: PUSH
22856: LD_INT 6
22858: ARRAY
22859: PUSH
22860: LD_INT 1
22862: PUSH
22863: LD_INT 2
22865: PUSH
22866: LD_INT 7
22868: PUSH
22869: LD_INT 9
22871: PUSH
22872: LD_INT 10
22874: PUSH
22875: LD_INT 11
22877: PUSH
22878: EMPTY
22879: LIST
22880: LIST
22881: LIST
22882: LIST
22883: LIST
22884: LIST
22885: IN
22886: NOT
22887: OR
22888: IFFALSE 22894
// exit ;
22890: POP
22891: POP
22892: GO 22992
// end ;
22894: GO 22565
22896: POP
22897: POP
// side := GetSide ( depot ) ;
22898: LD_ADDR_VAR 0 9
22902: PUSH
22903: LD_VAR 0 1
22907: PPUSH
22908: CALL_OW 255
22912: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22913: LD_VAR 0 9
22917: PPUSH
22918: LD_VAR 0 3
22922: PPUSH
22923: LD_VAR 0 4
22927: PPUSH
22928: LD_INT 20
22930: PPUSH
22931: CALL 15646 0 4
22935: PUSH
22936: LD_INT 4
22938: ARRAY
22939: IFFALSE 22943
// exit ;
22941: GO 22992
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22943: LD_VAR 0 2
22947: PUSH
22948: LD_INT 29
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: IN
22958: PUSH
22959: LD_VAR 0 3
22963: PPUSH
22964: LD_VAR 0 4
22968: PPUSH
22969: LD_VAR 0 9
22973: PPUSH
22974: CALL_OW 440
22978: NOT
22979: AND
22980: IFFALSE 22984
// exit ;
22982: GO 22992
// result := true ;
22984: LD_ADDR_VAR 0 6
22988: PUSH
22989: LD_INT 1
22991: ST_TO_ADDR
// end ;
22992: LD_VAR 0 6
22996: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
22997: LD_INT 0
22999: PPUSH
23000: PPUSH
23001: PPUSH
23002: PPUSH
23003: PPUSH
23004: PPUSH
23005: PPUSH
23006: PPUSH
23007: PPUSH
23008: PPUSH
23009: PPUSH
23010: PPUSH
23011: PPUSH
23012: PPUSH
23013: PPUSH
23014: PPUSH
23015: PPUSH
23016: PPUSH
23017: PPUSH
23018: PPUSH
23019: PPUSH
23020: PPUSH
23021: PPUSH
23022: PPUSH
23023: PPUSH
23024: PPUSH
23025: PPUSH
23026: PPUSH
23027: PPUSH
23028: PPUSH
23029: PPUSH
23030: PPUSH
23031: PPUSH
23032: PPUSH
23033: PPUSH
23034: PPUSH
23035: PPUSH
23036: PPUSH
23037: PPUSH
23038: PPUSH
23039: PPUSH
23040: PPUSH
23041: PPUSH
23042: PPUSH
23043: PPUSH
23044: PPUSH
23045: PPUSH
23046: PPUSH
23047: PPUSH
23048: PPUSH
23049: PPUSH
23050: PPUSH
23051: PPUSH
23052: PPUSH
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
// result = [ ] ;
23057: LD_ADDR_VAR 0 7
23061: PUSH
23062: EMPTY
23063: ST_TO_ADDR
// temp_list = [ ] ;
23064: LD_ADDR_VAR 0 9
23068: PUSH
23069: EMPTY
23070: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23071: LD_VAR 0 4
23075: PUSH
23076: LD_INT 0
23078: PUSH
23079: LD_INT 1
23081: PUSH
23082: LD_INT 2
23084: PUSH
23085: LD_INT 3
23087: PUSH
23088: LD_INT 4
23090: PUSH
23091: LD_INT 5
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: IN
23102: NOT
23103: PUSH
23104: LD_VAR 0 1
23108: PUSH
23109: LD_INT 0
23111: PUSH
23112: LD_INT 1
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: IN
23119: PUSH
23120: LD_VAR 0 5
23124: PUSH
23125: LD_INT 1
23127: PUSH
23128: LD_INT 2
23130: PUSH
23131: LD_INT 3
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: LIST
23138: IN
23139: NOT
23140: AND
23141: OR
23142: IFFALSE 23146
// exit ;
23144: GO 41537
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23146: LD_VAR 0 1
23150: PUSH
23151: LD_INT 6
23153: PUSH
23154: LD_INT 7
23156: PUSH
23157: LD_INT 8
23159: PUSH
23160: LD_INT 13
23162: PUSH
23163: LD_INT 12
23165: PUSH
23166: LD_INT 15
23168: PUSH
23169: LD_INT 11
23171: PUSH
23172: LD_INT 14
23174: PUSH
23175: LD_INT 10
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: IN
23189: IFFALSE 23199
// btype = b_lab ;
23191: LD_ADDR_VAR 0 1
23195: PUSH
23196: LD_INT 6
23198: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23199: LD_VAR 0 6
23203: PUSH
23204: LD_INT 0
23206: PUSH
23207: LD_INT 1
23209: PUSH
23210: LD_INT 2
23212: PUSH
23213: EMPTY
23214: LIST
23215: LIST
23216: LIST
23217: IN
23218: NOT
23219: PUSH
23220: LD_VAR 0 1
23224: PUSH
23225: LD_INT 0
23227: PUSH
23228: LD_INT 1
23230: PUSH
23231: LD_INT 2
23233: PUSH
23234: LD_INT 3
23236: PUSH
23237: LD_INT 6
23239: PUSH
23240: LD_INT 36
23242: PUSH
23243: LD_INT 4
23245: PUSH
23246: LD_INT 5
23248: PUSH
23249: LD_INT 31
23251: PUSH
23252: LD_INT 32
23254: PUSH
23255: LD_INT 33
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: IN
23271: NOT
23272: PUSH
23273: LD_VAR 0 6
23277: PUSH
23278: LD_INT 1
23280: EQUAL
23281: AND
23282: OR
23283: PUSH
23284: LD_VAR 0 1
23288: PUSH
23289: LD_INT 2
23291: PUSH
23292: LD_INT 3
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: IN
23299: NOT
23300: PUSH
23301: LD_VAR 0 6
23305: PUSH
23306: LD_INT 2
23308: EQUAL
23309: AND
23310: OR
23311: IFFALSE 23321
// mode = 0 ;
23313: LD_ADDR_VAR 0 6
23317: PUSH
23318: LD_INT 0
23320: ST_TO_ADDR
// case mode of 0 :
23321: LD_VAR 0 6
23325: PUSH
23326: LD_INT 0
23328: DOUBLE
23329: EQUAL
23330: IFTRUE 23334
23332: GO 34787
23334: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23335: LD_ADDR_VAR 0 11
23339: PUSH
23340: LD_INT 0
23342: PUSH
23343: LD_INT 0
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 0
23352: PUSH
23353: LD_INT 1
23355: NEG
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 1
23363: PUSH
23364: LD_INT 0
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: PUSH
23371: LD_INT 1
23373: PUSH
23374: LD_INT 1
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: PUSH
23381: LD_INT 0
23383: PUSH
23384: LD_INT 1
23386: PUSH
23387: EMPTY
23388: LIST
23389: LIST
23390: PUSH
23391: LD_INT 1
23393: NEG
23394: PUSH
23395: LD_INT 0
23397: PUSH
23398: EMPTY
23399: LIST
23400: LIST
23401: PUSH
23402: LD_INT 1
23404: NEG
23405: PUSH
23406: LD_INT 1
23408: NEG
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: PUSH
23414: LD_INT 1
23416: NEG
23417: PUSH
23418: LD_INT 2
23420: NEG
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: PUSH
23426: LD_INT 0
23428: PUSH
23429: LD_INT 2
23431: NEG
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: LD_INT 1
23439: PUSH
23440: LD_INT 1
23442: NEG
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: PUSH
23448: LD_INT 1
23450: PUSH
23451: LD_INT 2
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 0
23460: PUSH
23461: LD_INT 2
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: LD_INT 1
23470: NEG
23471: PUSH
23472: LD_INT 1
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: LD_INT 1
23481: PUSH
23482: LD_INT 3
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 0
23491: PUSH
23492: LD_INT 3
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PUSH
23499: LD_INT 1
23501: NEG
23502: PUSH
23503: LD_INT 2
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: LIST
23514: LIST
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: LIST
23520: LIST
23521: LIST
23522: LIST
23523: LIST
23524: LIST
23525: LIST
23526: LIST
23527: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23528: LD_ADDR_VAR 0 12
23532: PUSH
23533: LD_INT 0
23535: PUSH
23536: LD_INT 0
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 0
23545: PUSH
23546: LD_INT 1
23548: NEG
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: LD_INT 1
23556: PUSH
23557: LD_INT 0
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 1
23566: PUSH
23567: LD_INT 1
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: LD_INT 0
23576: PUSH
23577: LD_INT 1
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: PUSH
23584: LD_INT 1
23586: NEG
23587: PUSH
23588: LD_INT 0
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PUSH
23595: LD_INT 1
23597: NEG
23598: PUSH
23599: LD_INT 1
23601: NEG
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: PUSH
23607: LD_INT 1
23609: PUSH
23610: LD_INT 1
23612: NEG
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 2
23620: PUSH
23621: LD_INT 0
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 2
23630: PUSH
23631: LD_INT 1
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 1
23640: NEG
23641: PUSH
23642: LD_INT 1
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: LD_INT 2
23651: NEG
23652: PUSH
23653: LD_INT 0
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 2
23662: NEG
23663: PUSH
23664: LD_INT 1
23666: NEG
23667: PUSH
23668: EMPTY
23669: LIST
23670: LIST
23671: PUSH
23672: LD_INT 2
23674: NEG
23675: PUSH
23676: LD_INT 1
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: LD_INT 3
23685: NEG
23686: PUSH
23687: LD_INT 0
23689: PUSH
23690: EMPTY
23691: LIST
23692: LIST
23693: PUSH
23694: LD_INT 3
23696: NEG
23697: PUSH
23698: LD_INT 1
23700: NEG
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: LIST
23710: LIST
23711: LIST
23712: LIST
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: LIST
23718: LIST
23719: LIST
23720: LIST
23721: LIST
23722: LIST
23723: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23724: LD_ADDR_VAR 0 13
23728: PUSH
23729: LD_INT 0
23731: PUSH
23732: LD_INT 0
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: PUSH
23739: LD_INT 0
23741: PUSH
23742: LD_INT 1
23744: NEG
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: LD_INT 1
23752: PUSH
23753: LD_INT 0
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: LD_INT 1
23762: PUSH
23763: LD_INT 1
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: PUSH
23770: LD_INT 0
23772: PUSH
23773: LD_INT 1
23775: PUSH
23776: EMPTY
23777: LIST
23778: LIST
23779: PUSH
23780: LD_INT 1
23782: NEG
23783: PUSH
23784: LD_INT 0
23786: PUSH
23787: EMPTY
23788: LIST
23789: LIST
23790: PUSH
23791: LD_INT 1
23793: NEG
23794: PUSH
23795: LD_INT 1
23797: NEG
23798: PUSH
23799: EMPTY
23800: LIST
23801: LIST
23802: PUSH
23803: LD_INT 1
23805: NEG
23806: PUSH
23807: LD_INT 2
23809: NEG
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: PUSH
23815: LD_INT 2
23817: PUSH
23818: LD_INT 1
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: PUSH
23825: LD_INT 2
23827: PUSH
23828: LD_INT 2
23830: PUSH
23831: EMPTY
23832: LIST
23833: LIST
23834: PUSH
23835: LD_INT 1
23837: PUSH
23838: LD_INT 2
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: PUSH
23845: LD_INT 2
23847: NEG
23848: PUSH
23849: LD_INT 1
23851: NEG
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: PUSH
23857: LD_INT 2
23859: NEG
23860: PUSH
23861: LD_INT 2
23863: NEG
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 2
23871: NEG
23872: PUSH
23873: LD_INT 3
23875: NEG
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 3
23883: NEG
23884: PUSH
23885: LD_INT 2
23887: NEG
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: PUSH
23893: LD_INT 3
23895: NEG
23896: PUSH
23897: LD_INT 3
23899: NEG
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PUSH
23905: EMPTY
23906: LIST
23907: LIST
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23923: LD_ADDR_VAR 0 14
23927: PUSH
23928: LD_INT 0
23930: PUSH
23931: LD_INT 0
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: PUSH
23938: LD_INT 0
23940: PUSH
23941: LD_INT 1
23943: NEG
23944: PUSH
23945: EMPTY
23946: LIST
23947: LIST
23948: PUSH
23949: LD_INT 1
23951: PUSH
23952: LD_INT 0
23954: PUSH
23955: EMPTY
23956: LIST
23957: LIST
23958: PUSH
23959: LD_INT 1
23961: PUSH
23962: LD_INT 1
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: PUSH
23969: LD_INT 0
23971: PUSH
23972: LD_INT 1
23974: PUSH
23975: EMPTY
23976: LIST
23977: LIST
23978: PUSH
23979: LD_INT 1
23981: NEG
23982: PUSH
23983: LD_INT 0
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: LD_INT 1
23992: NEG
23993: PUSH
23994: LD_INT 1
23996: NEG
23997: PUSH
23998: EMPTY
23999: LIST
24000: LIST
24001: PUSH
24002: LD_INT 1
24004: NEG
24005: PUSH
24006: LD_INT 2
24008: NEG
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 0
24016: PUSH
24017: LD_INT 2
24019: NEG
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: PUSH
24025: LD_INT 1
24027: PUSH
24028: LD_INT 1
24030: NEG
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 1
24038: PUSH
24039: LD_INT 2
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PUSH
24046: LD_INT 0
24048: PUSH
24049: LD_INT 2
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: PUSH
24056: LD_INT 1
24058: NEG
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: PUSH
24067: LD_INT 1
24069: NEG
24070: PUSH
24071: LD_INT 3
24073: NEG
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 0
24081: PUSH
24082: LD_INT 3
24084: NEG
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 1
24092: PUSH
24093: LD_INT 2
24095: NEG
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: LIST
24108: LIST
24109: LIST
24110: LIST
24111: LIST
24112: LIST
24113: LIST
24114: LIST
24115: LIST
24116: LIST
24117: LIST
24118: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24119: LD_ADDR_VAR 0 15
24123: PUSH
24124: LD_INT 0
24126: PUSH
24127: LD_INT 0
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PUSH
24134: LD_INT 0
24136: PUSH
24137: LD_INT 1
24139: NEG
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: PUSH
24145: LD_INT 1
24147: PUSH
24148: LD_INT 0
24150: PUSH
24151: EMPTY
24152: LIST
24153: LIST
24154: PUSH
24155: LD_INT 1
24157: PUSH
24158: LD_INT 1
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: PUSH
24165: LD_INT 0
24167: PUSH
24168: LD_INT 1
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: PUSH
24175: LD_INT 1
24177: NEG
24178: PUSH
24179: LD_INT 0
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PUSH
24186: LD_INT 1
24188: NEG
24189: PUSH
24190: LD_INT 1
24192: NEG
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PUSH
24198: LD_INT 1
24200: PUSH
24201: LD_INT 1
24203: NEG
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 2
24211: PUSH
24212: LD_INT 0
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 2
24221: PUSH
24222: LD_INT 1
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: PUSH
24229: LD_INT 1
24231: NEG
24232: PUSH
24233: LD_INT 1
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PUSH
24240: LD_INT 2
24242: NEG
24243: PUSH
24244: LD_INT 0
24246: PUSH
24247: EMPTY
24248: LIST
24249: LIST
24250: PUSH
24251: LD_INT 2
24253: NEG
24254: PUSH
24255: LD_INT 1
24257: NEG
24258: PUSH
24259: EMPTY
24260: LIST
24261: LIST
24262: PUSH
24263: LD_INT 2
24265: PUSH
24266: LD_INT 1
24268: NEG
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 3
24276: PUSH
24277: LD_INT 0
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 3
24286: PUSH
24287: LD_INT 1
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24312: LD_ADDR_VAR 0 16
24316: PUSH
24317: LD_INT 0
24319: PUSH
24320: LD_INT 0
24322: PUSH
24323: EMPTY
24324: LIST
24325: LIST
24326: PUSH
24327: LD_INT 0
24329: PUSH
24330: LD_INT 1
24332: NEG
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 1
24340: PUSH
24341: LD_INT 0
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: LD_INT 1
24350: PUSH
24351: LD_INT 1
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: LD_INT 0
24360: PUSH
24361: LD_INT 1
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: PUSH
24368: LD_INT 1
24370: NEG
24371: PUSH
24372: LD_INT 0
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 1
24381: NEG
24382: PUSH
24383: LD_INT 1
24385: NEG
24386: PUSH
24387: EMPTY
24388: LIST
24389: LIST
24390: PUSH
24391: LD_INT 1
24393: NEG
24394: PUSH
24395: LD_INT 2
24397: NEG
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: PUSH
24403: LD_INT 2
24405: PUSH
24406: LD_INT 1
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PUSH
24413: LD_INT 2
24415: PUSH
24416: LD_INT 2
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: LD_INT 2
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 2
24435: NEG
24436: PUSH
24437: LD_INT 1
24439: NEG
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: LD_INT 2
24447: NEG
24448: PUSH
24449: LD_INT 2
24451: NEG
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: PUSH
24457: LD_INT 3
24459: PUSH
24460: LD_INT 2
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: PUSH
24467: LD_INT 3
24469: PUSH
24470: LD_INT 3
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PUSH
24477: LD_INT 2
24479: PUSH
24480: LD_INT 3
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: LIST
24494: LIST
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: LIST
24500: LIST
24501: LIST
24502: LIST
24503: LIST
24504: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24505: LD_ADDR_VAR 0 17
24509: PUSH
24510: LD_INT 0
24512: PUSH
24513: LD_INT 0
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: LD_INT 0
24522: PUSH
24523: LD_INT 1
24525: NEG
24526: PUSH
24527: EMPTY
24528: LIST
24529: LIST
24530: PUSH
24531: LD_INT 1
24533: PUSH
24534: LD_INT 0
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 1
24543: PUSH
24544: LD_INT 1
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: PUSH
24551: LD_INT 0
24553: PUSH
24554: LD_INT 1
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 1
24563: NEG
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: EMPTY
24569: LIST
24570: LIST
24571: PUSH
24572: LD_INT 1
24574: NEG
24575: PUSH
24576: LD_INT 1
24578: NEG
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: LD_INT 1
24586: NEG
24587: PUSH
24588: LD_INT 2
24590: NEG
24591: PUSH
24592: EMPTY
24593: LIST
24594: LIST
24595: PUSH
24596: LD_INT 0
24598: PUSH
24599: LD_INT 2
24601: NEG
24602: PUSH
24603: EMPTY
24604: LIST
24605: LIST
24606: PUSH
24607: LD_INT 1
24609: PUSH
24610: LD_INT 1
24612: NEG
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: PUSH
24618: LD_INT 2
24620: PUSH
24621: LD_INT 0
24623: PUSH
24624: EMPTY
24625: LIST
24626: LIST
24627: PUSH
24628: LD_INT 2
24630: PUSH
24631: LD_INT 1
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 2
24640: PUSH
24641: LD_INT 2
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 1
24650: PUSH
24651: LD_INT 2
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: LD_INT 2
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: PUSH
24668: LD_INT 1
24670: NEG
24671: PUSH
24672: LD_INT 1
24674: PUSH
24675: EMPTY
24676: LIST
24677: LIST
24678: PUSH
24679: LD_INT 2
24681: NEG
24682: PUSH
24683: LD_INT 0
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 2
24692: NEG
24693: PUSH
24694: LD_INT 1
24696: NEG
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: PUSH
24702: LD_INT 2
24704: NEG
24705: PUSH
24706: LD_INT 2
24708: NEG
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: LIST
24722: LIST
24723: LIST
24724: LIST
24725: LIST
24726: LIST
24727: LIST
24728: LIST
24729: LIST
24730: LIST
24731: LIST
24732: LIST
24733: LIST
24734: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24735: LD_ADDR_VAR 0 18
24739: PUSH
24740: LD_INT 0
24742: PUSH
24743: LD_INT 0
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 0
24752: PUSH
24753: LD_INT 1
24755: NEG
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 1
24763: PUSH
24764: LD_INT 0
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PUSH
24771: LD_INT 1
24773: PUSH
24774: LD_INT 1
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: PUSH
24781: LD_INT 0
24783: PUSH
24784: LD_INT 1
24786: PUSH
24787: EMPTY
24788: LIST
24789: LIST
24790: PUSH
24791: LD_INT 1
24793: NEG
24794: PUSH
24795: LD_INT 0
24797: PUSH
24798: EMPTY
24799: LIST
24800: LIST
24801: PUSH
24802: LD_INT 1
24804: NEG
24805: PUSH
24806: LD_INT 1
24808: NEG
24809: PUSH
24810: EMPTY
24811: LIST
24812: LIST
24813: PUSH
24814: LD_INT 1
24816: NEG
24817: PUSH
24818: LD_INT 2
24820: NEG
24821: PUSH
24822: EMPTY
24823: LIST
24824: LIST
24825: PUSH
24826: LD_INT 0
24828: PUSH
24829: LD_INT 2
24831: NEG
24832: PUSH
24833: EMPTY
24834: LIST
24835: LIST
24836: PUSH
24837: LD_INT 1
24839: PUSH
24840: LD_INT 1
24842: NEG
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PUSH
24848: LD_INT 2
24850: PUSH
24851: LD_INT 0
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: LD_INT 1
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 2
24870: PUSH
24871: LD_INT 2
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 1
24880: PUSH
24881: LD_INT 2
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 0
24890: PUSH
24891: LD_INT 2
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: LD_INT 1
24900: NEG
24901: PUSH
24902: LD_INT 1
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 2
24911: NEG
24912: PUSH
24913: LD_INT 0
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 2
24922: NEG
24923: PUSH
24924: LD_INT 1
24926: NEG
24927: PUSH
24928: EMPTY
24929: LIST
24930: LIST
24931: PUSH
24932: LD_INT 2
24934: NEG
24935: PUSH
24936: LD_INT 2
24938: NEG
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: LIST
24963: LIST
24964: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24965: LD_ADDR_VAR 0 19
24969: PUSH
24970: LD_INT 0
24972: PUSH
24973: LD_INT 0
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 0
24982: PUSH
24983: LD_INT 1
24985: NEG
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 1
24993: PUSH
24994: LD_INT 0
24996: PUSH
24997: EMPTY
24998: LIST
24999: LIST
25000: PUSH
25001: LD_INT 1
25003: PUSH
25004: LD_INT 1
25006: PUSH
25007: EMPTY
25008: LIST
25009: LIST
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: LD_INT 1
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PUSH
25021: LD_INT 1
25023: NEG
25024: PUSH
25025: LD_INT 0
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: LD_INT 1
25034: NEG
25035: PUSH
25036: LD_INT 1
25038: NEG
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 1
25046: NEG
25047: PUSH
25048: LD_INT 2
25050: NEG
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 0
25058: PUSH
25059: LD_INT 2
25061: NEG
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 1
25069: PUSH
25070: LD_INT 1
25072: NEG
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: PUSH
25078: LD_INT 2
25080: PUSH
25081: LD_INT 0
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 2
25090: PUSH
25091: LD_INT 1
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: PUSH
25098: LD_INT 2
25100: PUSH
25101: LD_INT 2
25103: PUSH
25104: EMPTY
25105: LIST
25106: LIST
25107: PUSH
25108: LD_INT 1
25110: PUSH
25111: LD_INT 2
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: LD_INT 0
25120: PUSH
25121: LD_INT 2
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 1
25130: NEG
25131: PUSH
25132: LD_INT 1
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PUSH
25139: LD_INT 2
25141: NEG
25142: PUSH
25143: LD_INT 0
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: LD_INT 2
25152: NEG
25153: PUSH
25154: LD_INT 1
25156: NEG
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PUSH
25162: LD_INT 2
25164: NEG
25165: PUSH
25166: LD_INT 2
25168: NEG
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: LIST
25178: LIST
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: LIST
25184: LIST
25185: LIST
25186: LIST
25187: LIST
25188: LIST
25189: LIST
25190: LIST
25191: LIST
25192: LIST
25193: LIST
25194: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25195: LD_ADDR_VAR 0 20
25199: PUSH
25200: LD_INT 0
25202: PUSH
25203: LD_INT 0
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 0
25212: PUSH
25213: LD_INT 1
25215: NEG
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: LD_INT 1
25223: PUSH
25224: LD_INT 0
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: LD_INT 1
25233: PUSH
25234: LD_INT 1
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: PUSH
25241: LD_INT 0
25243: PUSH
25244: LD_INT 1
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PUSH
25251: LD_INT 1
25253: NEG
25254: PUSH
25255: LD_INT 0
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: LD_INT 1
25264: NEG
25265: PUSH
25266: LD_INT 1
25268: NEG
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: PUSH
25274: LD_INT 1
25276: NEG
25277: PUSH
25278: LD_INT 2
25280: NEG
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: PUSH
25286: LD_INT 0
25288: PUSH
25289: LD_INT 2
25291: NEG
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: PUSH
25297: LD_INT 1
25299: PUSH
25300: LD_INT 1
25302: NEG
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 2
25310: PUSH
25311: LD_INT 0
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: LD_INT 2
25320: PUSH
25321: LD_INT 1
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: LD_INT 2
25330: PUSH
25331: LD_INT 2
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PUSH
25338: LD_INT 1
25340: PUSH
25341: LD_INT 2
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 0
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 1
25360: NEG
25361: PUSH
25362: LD_INT 1
25364: PUSH
25365: EMPTY
25366: LIST
25367: LIST
25368: PUSH
25369: LD_INT 2
25371: NEG
25372: PUSH
25373: LD_INT 0
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: PUSH
25380: LD_INT 2
25382: NEG
25383: PUSH
25384: LD_INT 1
25386: NEG
25387: PUSH
25388: EMPTY
25389: LIST
25390: LIST
25391: PUSH
25392: LD_INT 2
25394: NEG
25395: PUSH
25396: LD_INT 2
25398: NEG
25399: PUSH
25400: EMPTY
25401: LIST
25402: LIST
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: LIST
25412: LIST
25413: LIST
25414: LIST
25415: LIST
25416: LIST
25417: LIST
25418: LIST
25419: LIST
25420: LIST
25421: LIST
25422: LIST
25423: LIST
25424: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25425: LD_ADDR_VAR 0 21
25429: PUSH
25430: LD_INT 0
25432: PUSH
25433: LD_INT 0
25435: PUSH
25436: EMPTY
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 0
25442: PUSH
25443: LD_INT 1
25445: NEG
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: PUSH
25451: LD_INT 1
25453: PUSH
25454: LD_INT 0
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 1
25463: PUSH
25464: LD_INT 1
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 0
25473: PUSH
25474: LD_INT 1
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: LD_INT 1
25483: NEG
25484: PUSH
25485: LD_INT 0
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PUSH
25492: LD_INT 1
25494: NEG
25495: PUSH
25496: LD_INT 1
25498: NEG
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: PUSH
25504: LD_INT 1
25506: NEG
25507: PUSH
25508: LD_INT 2
25510: NEG
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 0
25518: PUSH
25519: LD_INT 2
25521: NEG
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PUSH
25527: LD_INT 1
25529: PUSH
25530: LD_INT 1
25532: NEG
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 2
25540: PUSH
25541: LD_INT 0
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: LD_INT 2
25550: PUSH
25551: LD_INT 1
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 2
25560: PUSH
25561: LD_INT 2
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 1
25570: PUSH
25571: LD_INT 2
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: LD_INT 0
25580: PUSH
25581: LD_INT 2
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 1
25590: NEG
25591: PUSH
25592: LD_INT 1
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: LD_INT 2
25601: NEG
25602: PUSH
25603: LD_INT 0
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: LD_INT 2
25612: NEG
25613: PUSH
25614: LD_INT 1
25616: NEG
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: LD_INT 2
25624: NEG
25625: PUSH
25626: LD_INT 2
25628: NEG
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: LIST
25638: LIST
25639: LIST
25640: LIST
25641: LIST
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: LIST
25652: LIST
25653: LIST
25654: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25655: LD_ADDR_VAR 0 22
25659: PUSH
25660: LD_INT 0
25662: PUSH
25663: LD_INT 0
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 0
25672: PUSH
25673: LD_INT 1
25675: NEG
25676: PUSH
25677: EMPTY
25678: LIST
25679: LIST
25680: PUSH
25681: LD_INT 1
25683: PUSH
25684: LD_INT 0
25686: PUSH
25687: EMPTY
25688: LIST
25689: LIST
25690: PUSH
25691: LD_INT 1
25693: PUSH
25694: LD_INT 1
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 0
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: NEG
25714: PUSH
25715: LD_INT 0
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 1
25724: NEG
25725: PUSH
25726: LD_INT 1
25728: NEG
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 1
25736: NEG
25737: PUSH
25738: LD_INT 2
25740: NEG
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: PUSH
25746: LD_INT 0
25748: PUSH
25749: LD_INT 2
25751: NEG
25752: PUSH
25753: EMPTY
25754: LIST
25755: LIST
25756: PUSH
25757: LD_INT 1
25759: PUSH
25760: LD_INT 1
25762: NEG
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 2
25770: PUSH
25771: LD_INT 0
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: LD_INT 2
25780: PUSH
25781: LD_INT 1
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 2
25790: PUSH
25791: LD_INT 2
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 1
25800: PUSH
25801: LD_INT 2
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 0
25810: PUSH
25811: LD_INT 2
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: LD_INT 1
25820: NEG
25821: PUSH
25822: LD_INT 1
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: LD_INT 2
25831: NEG
25832: PUSH
25833: LD_INT 0
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 2
25842: NEG
25843: PUSH
25844: LD_INT 1
25846: NEG
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: LD_INT 2
25854: NEG
25855: PUSH
25856: LD_INT 2
25858: NEG
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: LIST
25871: LIST
25872: LIST
25873: LIST
25874: LIST
25875: LIST
25876: LIST
25877: LIST
25878: LIST
25879: LIST
25880: LIST
25881: LIST
25882: LIST
25883: LIST
25884: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25885: LD_ADDR_VAR 0 23
25889: PUSH
25890: LD_INT 0
25892: PUSH
25893: LD_INT 0
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: LD_INT 1
25905: NEG
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: PUSH
25911: LD_INT 1
25913: PUSH
25914: LD_INT 0
25916: PUSH
25917: EMPTY
25918: LIST
25919: LIST
25920: PUSH
25921: LD_INT 1
25923: PUSH
25924: LD_INT 1
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PUSH
25931: LD_INT 0
25933: PUSH
25934: LD_INT 1
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: LD_INT 1
25943: NEG
25944: PUSH
25945: LD_INT 0
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: PUSH
25952: LD_INT 1
25954: NEG
25955: PUSH
25956: LD_INT 1
25958: NEG
25959: PUSH
25960: EMPTY
25961: LIST
25962: LIST
25963: PUSH
25964: LD_INT 1
25966: NEG
25967: PUSH
25968: LD_INT 2
25970: NEG
25971: PUSH
25972: EMPTY
25973: LIST
25974: LIST
25975: PUSH
25976: LD_INT 0
25978: PUSH
25979: LD_INT 2
25981: NEG
25982: PUSH
25983: EMPTY
25984: LIST
25985: LIST
25986: PUSH
25987: LD_INT 1
25989: PUSH
25990: LD_INT 1
25992: NEG
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: LD_INT 2
26000: PUSH
26001: LD_INT 0
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 2
26010: PUSH
26011: LD_INT 1
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 2
26020: PUSH
26021: LD_INT 2
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 1
26030: PUSH
26031: LD_INT 2
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 0
26040: PUSH
26041: LD_INT 2
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: LD_INT 1
26050: NEG
26051: PUSH
26052: LD_INT 1
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PUSH
26059: LD_INT 2
26061: NEG
26062: PUSH
26063: LD_INT 0
26065: PUSH
26066: EMPTY
26067: LIST
26068: LIST
26069: PUSH
26070: LD_INT 2
26072: NEG
26073: PUSH
26074: LD_INT 1
26076: NEG
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 2
26084: NEG
26085: PUSH
26086: LD_INT 2
26088: NEG
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: PUSH
26094: LD_INT 2
26096: NEG
26097: PUSH
26098: LD_INT 3
26100: NEG
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: LD_INT 3
26112: NEG
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 1
26120: PUSH
26121: LD_INT 2
26123: NEG
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 2
26131: PUSH
26132: LD_INT 1
26134: NEG
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: LIST
26144: LIST
26145: LIST
26146: LIST
26147: LIST
26148: LIST
26149: LIST
26150: LIST
26151: LIST
26152: LIST
26153: LIST
26154: LIST
26155: LIST
26156: LIST
26157: LIST
26158: LIST
26159: LIST
26160: LIST
26161: LIST
26162: LIST
26163: LIST
26164: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26165: LD_ADDR_VAR 0 24
26169: PUSH
26170: LD_INT 0
26172: PUSH
26173: LD_INT 0
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PUSH
26180: LD_INT 0
26182: PUSH
26183: LD_INT 1
26185: NEG
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PUSH
26191: LD_INT 1
26193: PUSH
26194: LD_INT 0
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 1
26203: PUSH
26204: LD_INT 1
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 0
26213: PUSH
26214: LD_INT 1
26216: PUSH
26217: EMPTY
26218: LIST
26219: LIST
26220: PUSH
26221: LD_INT 1
26223: NEG
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 1
26234: NEG
26235: PUSH
26236: LD_INT 1
26238: NEG
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 1
26246: NEG
26247: PUSH
26248: LD_INT 2
26250: NEG
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 0
26258: PUSH
26259: LD_INT 2
26261: NEG
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 1
26269: PUSH
26270: LD_INT 1
26272: NEG
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 2
26280: PUSH
26281: LD_INT 0
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: LD_INT 2
26290: PUSH
26291: LD_INT 1
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 2
26300: PUSH
26301: LD_INT 2
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 1
26310: PUSH
26311: LD_INT 2
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: LD_INT 0
26320: PUSH
26321: LD_INT 2
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 1
26330: NEG
26331: PUSH
26332: LD_INT 1
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 2
26341: NEG
26342: PUSH
26343: LD_INT 0
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PUSH
26350: LD_INT 2
26352: NEG
26353: PUSH
26354: LD_INT 1
26356: NEG
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 2
26364: NEG
26365: PUSH
26366: LD_INT 2
26368: NEG
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 1
26376: PUSH
26377: LD_INT 2
26379: NEG
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 2
26387: PUSH
26388: LD_INT 1
26390: NEG
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 3
26398: PUSH
26399: LD_INT 1
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PUSH
26406: LD_INT 3
26408: PUSH
26409: LD_INT 2
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: LIST
26420: LIST
26421: LIST
26422: LIST
26423: LIST
26424: LIST
26425: LIST
26426: LIST
26427: LIST
26428: LIST
26429: LIST
26430: LIST
26431: LIST
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26441: LD_ADDR_VAR 0 25
26445: PUSH
26446: LD_INT 0
26448: PUSH
26449: LD_INT 0
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 0
26458: PUSH
26459: LD_INT 1
26461: NEG
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PUSH
26467: LD_INT 1
26469: PUSH
26470: LD_INT 0
26472: PUSH
26473: EMPTY
26474: LIST
26475: LIST
26476: PUSH
26477: LD_INT 1
26479: PUSH
26480: LD_INT 1
26482: PUSH
26483: EMPTY
26484: LIST
26485: LIST
26486: PUSH
26487: LD_INT 0
26489: PUSH
26490: LD_INT 1
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PUSH
26497: LD_INT 1
26499: NEG
26500: PUSH
26501: LD_INT 0
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: LD_INT 1
26510: NEG
26511: PUSH
26512: LD_INT 1
26514: NEG
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: NEG
26523: PUSH
26524: LD_INT 2
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 0
26534: PUSH
26535: LD_INT 2
26537: NEG
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 1
26545: PUSH
26546: LD_INT 1
26548: NEG
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: LD_INT 2
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PUSH
26564: LD_INT 2
26566: PUSH
26567: LD_INT 1
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 2
26576: PUSH
26577: LD_INT 2
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: LD_INT 2
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 0
26596: PUSH
26597: LD_INT 2
26599: PUSH
26600: EMPTY
26601: LIST
26602: LIST
26603: PUSH
26604: LD_INT 1
26606: NEG
26607: PUSH
26608: LD_INT 1
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 2
26617: NEG
26618: PUSH
26619: LD_INT 0
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 2
26628: NEG
26629: PUSH
26630: LD_INT 1
26632: NEG
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 2
26640: NEG
26641: PUSH
26642: LD_INT 2
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 3
26652: PUSH
26653: LD_INT 1
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: PUSH
26660: LD_INT 3
26662: PUSH
26663: LD_INT 2
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 2
26672: PUSH
26673: LD_INT 3
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: LD_INT 1
26682: PUSH
26683: LD_INT 3
26685: PUSH
26686: EMPTY
26687: LIST
26688: LIST
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: LIST
26694: LIST
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: LIST
26706: LIST
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: LIST
26712: LIST
26713: LIST
26714: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26715: LD_ADDR_VAR 0 26
26719: PUSH
26720: LD_INT 0
26722: PUSH
26723: LD_INT 0
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 0
26732: PUSH
26733: LD_INT 1
26735: NEG
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 1
26743: PUSH
26744: LD_INT 0
26746: PUSH
26747: EMPTY
26748: LIST
26749: LIST
26750: PUSH
26751: LD_INT 1
26753: PUSH
26754: LD_INT 1
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: PUSH
26761: LD_INT 0
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 1
26773: NEG
26774: PUSH
26775: LD_INT 0
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: NEG
26785: PUSH
26786: LD_INT 1
26788: NEG
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 1
26796: NEG
26797: PUSH
26798: LD_INT 2
26800: NEG
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 0
26808: PUSH
26809: LD_INT 2
26811: NEG
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 1
26819: PUSH
26820: LD_INT 1
26822: NEG
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: PUSH
26828: LD_INT 2
26830: PUSH
26831: LD_INT 0
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: LD_INT 2
26840: PUSH
26841: LD_INT 1
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 2
26850: PUSH
26851: LD_INT 2
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: PUSH
26858: LD_INT 1
26860: PUSH
26861: LD_INT 2
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 0
26870: PUSH
26871: LD_INT 2
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: PUSH
26878: LD_INT 1
26880: NEG
26881: PUSH
26882: LD_INT 1
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 2
26891: NEG
26892: PUSH
26893: LD_INT 0
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 2
26902: NEG
26903: PUSH
26904: LD_INT 1
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 2
26914: NEG
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: LD_INT 3
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 1
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 1
26946: NEG
26947: PUSH
26948: LD_INT 2
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: LD_INT 2
26957: NEG
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: LIST
26970: LIST
26971: LIST
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: LIST
26987: LIST
26988: LIST
26989: LIST
26990: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
26991: LD_ADDR_VAR 0 27
26995: PUSH
26996: LD_INT 0
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_INT 1
27011: NEG
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: PUSH
27017: LD_INT 1
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 1
27029: PUSH
27030: LD_INT 1
27032: PUSH
27033: EMPTY
27034: LIST
27035: LIST
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: LD_INT 1
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: PUSH
27047: LD_INT 1
27049: NEG
27050: PUSH
27051: LD_INT 0
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 1
27060: NEG
27061: PUSH
27062: LD_INT 1
27064: NEG
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 1
27072: NEG
27073: PUSH
27074: LD_INT 2
27076: NEG
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 0
27084: PUSH
27085: LD_INT 2
27087: NEG
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: PUSH
27093: LD_INT 1
27095: PUSH
27096: LD_INT 1
27098: NEG
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PUSH
27104: LD_INT 2
27106: PUSH
27107: LD_INT 0
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: LD_INT 2
27116: PUSH
27117: LD_INT 1
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 2
27126: PUSH
27127: LD_INT 2
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: LD_INT 2
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: PUSH
27144: LD_INT 0
27146: PUSH
27147: LD_INT 2
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PUSH
27154: LD_INT 1
27156: NEG
27157: PUSH
27158: LD_INT 1
27160: PUSH
27161: EMPTY
27162: LIST
27163: LIST
27164: PUSH
27165: LD_INT 2
27167: NEG
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 2
27178: NEG
27179: PUSH
27180: LD_INT 1
27182: NEG
27183: PUSH
27184: EMPTY
27185: LIST
27186: LIST
27187: PUSH
27188: LD_INT 2
27190: NEG
27191: PUSH
27192: LD_INT 2
27194: NEG
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 1
27202: NEG
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 2
27213: NEG
27214: PUSH
27215: LD_INT 1
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 3
27224: NEG
27225: PUSH
27226: LD_INT 1
27228: NEG
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 3
27236: NEG
27237: PUSH
27238: LD_INT 2
27240: NEG
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: LIST
27256: LIST
27257: LIST
27258: LIST
27259: LIST
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: LIST
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27271: LD_ADDR_VAR 0 28
27275: PUSH
27276: LD_INT 0
27278: PUSH
27279: LD_INT 0
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 0
27288: PUSH
27289: LD_INT 1
27291: NEG
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 1
27299: PUSH
27300: LD_INT 0
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 1
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 0
27319: PUSH
27320: LD_INT 1
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 1
27329: NEG
27330: PUSH
27331: LD_INT 0
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 1
27340: NEG
27341: PUSH
27342: LD_INT 1
27344: NEG
27345: PUSH
27346: EMPTY
27347: LIST
27348: LIST
27349: PUSH
27350: LD_INT 1
27352: NEG
27353: PUSH
27354: LD_INT 2
27356: NEG
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 0
27364: PUSH
27365: LD_INT 2
27367: NEG
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: LD_INT 1
27378: NEG
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 2
27386: PUSH
27387: LD_INT 0
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 2
27396: PUSH
27397: LD_INT 1
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 2
27406: PUSH
27407: LD_INT 2
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: LD_INT 1
27416: PUSH
27417: LD_INT 2
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: LD_INT 0
27426: PUSH
27427: LD_INT 2
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: LD_INT 1
27436: NEG
27437: PUSH
27438: LD_INT 1
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 2
27447: NEG
27448: PUSH
27449: LD_INT 0
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 2
27458: NEG
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 2
27470: NEG
27471: PUSH
27472: LD_INT 2
27474: NEG
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 2
27482: NEG
27483: PUSH
27484: LD_INT 3
27486: NEG
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 1
27494: NEG
27495: PUSH
27496: LD_INT 3
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 3
27506: NEG
27507: PUSH
27508: LD_INT 1
27510: NEG
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 3
27518: NEG
27519: PUSH
27520: LD_INT 2
27522: NEG
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27553: LD_ADDR_VAR 0 29
27557: PUSH
27558: LD_INT 0
27560: PUSH
27561: LD_INT 0
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 0
27570: PUSH
27571: LD_INT 1
27573: NEG
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PUSH
27592: LD_INT 1
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 0
27601: PUSH
27602: LD_INT 1
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: LD_INT 1
27611: NEG
27612: PUSH
27613: LD_INT 0
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: NEG
27623: PUSH
27624: LD_INT 1
27626: NEG
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: PUSH
27632: LD_INT 1
27634: NEG
27635: PUSH
27636: LD_INT 2
27638: NEG
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 0
27646: PUSH
27647: LD_INT 2
27649: NEG
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 1
27657: PUSH
27658: LD_INT 1
27660: NEG
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 2
27668: PUSH
27669: LD_INT 0
27671: PUSH
27672: EMPTY
27673: LIST
27674: LIST
27675: PUSH
27676: LD_INT 2
27678: PUSH
27679: LD_INT 1
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 1
27688: PUSH
27689: LD_INT 2
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: LD_INT 0
27698: PUSH
27699: LD_INT 2
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: PUSH
27706: LD_INT 1
27708: NEG
27709: PUSH
27710: LD_INT 1
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 2
27719: NEG
27720: PUSH
27721: LD_INT 1
27723: NEG
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: LD_INT 2
27731: NEG
27732: PUSH
27733: LD_INT 2
27735: NEG
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: LD_INT 2
27743: NEG
27744: PUSH
27745: LD_INT 3
27747: NEG
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 2
27755: PUSH
27756: LD_INT 1
27758: NEG
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 3
27766: PUSH
27767: LD_INT 1
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: LD_INT 3
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: LD_INT 2
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 3
27797: NEG
27798: PUSH
27799: LD_INT 2
27801: NEG
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: LIST
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27832: LD_ADDR_VAR 0 30
27836: PUSH
27837: LD_INT 0
27839: PUSH
27840: LD_INT 0
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: LD_INT 0
27849: PUSH
27850: LD_INT 1
27852: NEG
27853: PUSH
27854: EMPTY
27855: LIST
27856: LIST
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PUSH
27868: LD_INT 1
27870: PUSH
27871: LD_INT 1
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 1
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: NEG
27891: PUSH
27892: LD_INT 0
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 1
27901: NEG
27902: PUSH
27903: LD_INT 1
27905: NEG
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 1
27913: NEG
27914: PUSH
27915: LD_INT 2
27917: NEG
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 0
27925: PUSH
27926: LD_INT 2
27928: NEG
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: LD_INT 1
27936: PUSH
27937: LD_INT 1
27939: NEG
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: PUSH
27945: LD_INT 2
27947: PUSH
27948: LD_INT 0
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: PUSH
27955: LD_INT 2
27957: PUSH
27958: LD_INT 1
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 2
27967: PUSH
27968: LD_INT 2
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: LD_INT 1
27977: PUSH
27978: LD_INT 2
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 1
27987: NEG
27988: PUSH
27989: LD_INT 1
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 2
27998: NEG
27999: PUSH
28000: LD_INT 0
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: NEG
28010: PUSH
28011: LD_INT 1
28013: NEG
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 1
28021: NEG
28022: PUSH
28023: LD_INT 3
28025: NEG
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 1
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 3
28044: PUSH
28045: LD_INT 2
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 2
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 2
28064: NEG
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: PUSH
28073: LD_INT 3
28075: NEG
28076: PUSH
28077: LD_INT 1
28079: NEG
28080: PUSH
28081: EMPTY
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28110: LD_ADDR_VAR 0 31
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: LD_INT 1
28130: NEG
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 1
28138: PUSH
28139: LD_INT 0
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 1
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 0
28158: PUSH
28159: LD_INT 1
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 1
28168: NEG
28169: PUSH
28170: LD_INT 0
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: LD_INT 1
28183: NEG
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 1
28191: NEG
28192: PUSH
28193: LD_INT 2
28195: NEG
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: LD_INT 1
28203: PUSH
28204: LD_INT 1
28206: NEG
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 2
28214: PUSH
28215: LD_INT 0
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: LD_INT 1
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 2
28234: PUSH
28235: LD_INT 2
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 1
28244: PUSH
28245: LD_INT 2
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: LD_INT 2
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PUSH
28262: LD_INT 1
28264: NEG
28265: PUSH
28266: LD_INT 1
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 2
28275: NEG
28276: PUSH
28277: LD_INT 1
28279: NEG
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 2
28287: NEG
28288: PUSH
28289: LD_INT 2
28291: NEG
28292: PUSH
28293: EMPTY
28294: LIST
28295: LIST
28296: PUSH
28297: LD_INT 2
28299: NEG
28300: PUSH
28301: LD_INT 3
28303: NEG
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PUSH
28309: LD_INT 2
28311: PUSH
28312: LD_INT 1
28314: NEG
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PUSH
28320: LD_INT 3
28322: PUSH
28323: LD_INT 1
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: PUSH
28330: LD_INT 1
28332: PUSH
28333: LD_INT 3
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: LD_INT 2
28346: PUSH
28347: EMPTY
28348: LIST
28349: LIST
28350: PUSH
28351: LD_INT 3
28353: NEG
28354: PUSH
28355: LD_INT 2
28357: NEG
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28388: LD_ADDR_VAR 0 32
28392: PUSH
28393: LD_INT 0
28395: PUSH
28396: LD_INT 0
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 0
28405: PUSH
28406: LD_INT 1
28408: NEG
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 1
28416: PUSH
28417: LD_INT 0
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 1
28426: PUSH
28427: LD_INT 1
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 0
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 1
28446: NEG
28447: PUSH
28448: LD_INT 0
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: PUSH
28455: LD_INT 1
28457: NEG
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 1
28469: NEG
28470: PUSH
28471: LD_INT 2
28473: NEG
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 0
28481: PUSH
28482: LD_INT 2
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: PUSH
28493: LD_INT 1
28495: NEG
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 2
28503: PUSH
28504: LD_INT 1
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: LD_INT 2
28513: PUSH
28514: LD_INT 2
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 1
28523: PUSH
28524: LD_INT 2
28526: PUSH
28527: EMPTY
28528: LIST
28529: LIST
28530: PUSH
28531: LD_INT 0
28533: PUSH
28534: LD_INT 2
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: LD_INT 1
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 2
28554: NEG
28555: PUSH
28556: LD_INT 0
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: LD_INT 1
28569: NEG
28570: PUSH
28571: EMPTY
28572: LIST
28573: LIST
28574: PUSH
28575: LD_INT 1
28577: NEG
28578: PUSH
28579: LD_INT 3
28581: NEG
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: PUSH
28587: LD_INT 1
28589: PUSH
28590: LD_INT 2
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 2
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 2
28610: PUSH
28611: LD_INT 3
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: NEG
28621: PUSH
28622: LD_INT 1
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 3
28631: NEG
28632: PUSH
28633: LD_INT 1
28635: NEG
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28666: LD_ADDR_VAR 0 33
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: LD_INT 0
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: LD_INT 1
28686: NEG
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: LD_INT 1
28694: PUSH
28695: LD_INT 0
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 0
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 1
28724: NEG
28725: PUSH
28726: LD_INT 0
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: LD_INT 1
28735: NEG
28736: PUSH
28737: LD_INT 1
28739: NEG
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: LD_INT 1
28747: NEG
28748: PUSH
28749: LD_INT 2
28751: NEG
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: LD_INT 1
28762: NEG
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 2
28770: PUSH
28771: LD_INT 0
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 2
28780: PUSH
28781: LD_INT 1
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 0
28800: PUSH
28801: LD_INT 2
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: NEG
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: NEG
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 2
28832: NEG
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 2
28844: NEG
28845: PUSH
28846: LD_INT 2
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 2
28856: NEG
28857: PUSH
28858: LD_INT 3
28860: NEG
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: LD_INT 2
28868: PUSH
28869: LD_INT 1
28871: NEG
28872: PUSH
28873: EMPTY
28874: LIST
28875: LIST
28876: PUSH
28877: LD_INT 3
28879: PUSH
28880: LD_INT 1
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PUSH
28887: LD_INT 1
28889: PUSH
28890: LD_INT 3
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: PUSH
28897: LD_INT 1
28899: NEG
28900: PUSH
28901: LD_INT 2
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 3
28910: NEG
28911: PUSH
28912: LD_INT 2
28914: NEG
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28945: LD_ADDR_VAR 0 34
28949: PUSH
28950: LD_INT 0
28952: PUSH
28953: LD_INT 0
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 1
28965: NEG
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 1
28973: PUSH
28974: LD_INT 0
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: LD_INT 1
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 0
28993: PUSH
28994: LD_INT 1
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 0
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: LD_INT 1
29014: NEG
29015: PUSH
29016: LD_INT 1
29018: NEG
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 1
29026: NEG
29027: PUSH
29028: LD_INT 2
29030: NEG
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: LD_INT 0
29038: PUSH
29039: LD_INT 2
29041: NEG
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 1
29049: PUSH
29050: LD_INT 1
29052: NEG
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 2
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 2
29070: PUSH
29071: LD_INT 2
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 1
29090: NEG
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 2
29101: NEG
29102: PUSH
29103: LD_INT 0
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 2
29112: NEG
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 2
29124: NEG
29125: PUSH
29126: LD_INT 2
29128: NEG
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: PUSH
29134: LD_INT 1
29136: NEG
29137: PUSH
29138: LD_INT 3
29140: NEG
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: LD_INT 2
29151: NEG
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 3
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: PUSH
29170: LD_INT 3
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 2
29179: NEG
29180: PUSH
29181: LD_INT 1
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: PUSH
29188: LD_INT 3
29190: NEG
29191: PUSH
29192: LD_INT 1
29194: NEG
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29225: LD_ADDR_VAR 0 35
29229: PUSH
29230: LD_INT 0
29232: PUSH
29233: LD_INT 0
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: LD_INT 1
29245: NEG
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 1
29253: PUSH
29254: LD_INT 0
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 1
29263: PUSH
29264: LD_INT 1
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 0
29273: PUSH
29274: LD_INT 1
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 1
29283: NEG
29284: PUSH
29285: LD_INT 0
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 1
29294: NEG
29295: PUSH
29296: LD_INT 1
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 2
29306: PUSH
29307: LD_INT 1
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 2
29316: NEG
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: LIST
29336: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29337: LD_ADDR_VAR 0 36
29341: PUSH
29342: LD_INT 0
29344: PUSH
29345: LD_INT 0
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 0
29354: PUSH
29355: LD_INT 1
29357: NEG
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 1
29365: PUSH
29366: LD_INT 0
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 1
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 0
29385: PUSH
29386: LD_INT 1
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 1
29418: NEG
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: LD_INT 2
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29449: LD_ADDR_VAR 0 37
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: LD_INT 0
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 0
29466: PUSH
29467: LD_INT 1
29469: NEG
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 1
29477: PUSH
29478: LD_INT 0
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 1
29487: PUSH
29488: LD_INT 1
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PUSH
29495: LD_INT 0
29497: PUSH
29498: LD_INT 1
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: LD_INT 1
29507: NEG
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 1
29518: NEG
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: LD_INT 1
29533: NEG
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29561: LD_ADDR_VAR 0 38
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 0
29578: PUSH
29579: LD_INT 1
29581: NEG
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: LD_INT 0
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 1
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 0
29609: PUSH
29610: LD_INT 1
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 1
29619: NEG
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 1
29630: NEG
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: LD_INT 1
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 1
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29673: LD_ADDR_VAR 0 39
29677: PUSH
29678: LD_INT 0
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 1
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 1
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 1
29731: NEG
29732: PUSH
29733: LD_INT 0
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: NEG
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 2
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: PUSH
29767: LD_INT 2
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29785: LD_ADDR_VAR 0 40
29789: PUSH
29790: LD_INT 0
29792: PUSH
29793: LD_INT 0
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: LD_INT 1
29805: NEG
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: LD_INT 0
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 1
29823: PUSH
29824: LD_INT 1
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 0
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 1
29843: NEG
29844: PUSH
29845: LD_INT 0
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PUSH
29852: LD_INT 1
29854: NEG
29855: PUSH
29856: LD_INT 1
29858: NEG
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 1
29866: PUSH
29867: LD_INT 1
29869: NEG
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 1
29877: NEG
29878: PUSH
29879: LD_INT 1
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: LIST
29895: LIST
29896: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29897: LD_ADDR_VAR 0 41
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 0
29914: PUSH
29915: LD_INT 1
29917: NEG
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 0
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 1
29955: NEG
29956: PUSH
29957: LD_INT 0
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 1
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 1
29978: NEG
29979: PUSH
29980: LD_INT 2
29982: NEG
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: PUSH
29991: LD_INT 1
29993: NEG
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 2
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 2
30011: PUSH
30012: LD_INT 1
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 2
30021: PUSH
30022: LD_INT 2
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: LD_INT 2
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 1
30041: NEG
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 2
30063: NEG
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: LD_INT 2
30079: NEG
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 2
30087: NEG
30088: PUSH
30089: LD_INT 3
30091: NEG
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 2
30099: PUSH
30100: LD_INT 1
30102: NEG
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: LD_INT 3
30110: PUSH
30111: LD_INT 0
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: LD_INT 1
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 3
30130: PUSH
30131: LD_INT 2
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 3
30140: PUSH
30141: LD_INT 3
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: PUSH
30151: LD_INT 3
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 2
30160: NEG
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 3
30171: NEG
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 3
30182: NEG
30183: PUSH
30184: LD_INT 1
30186: NEG
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 3
30194: NEG
30195: PUSH
30196: LD_INT 2
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 3
30206: NEG
30207: PUSH
30208: LD_INT 3
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30247: LD_ADDR_VAR 0 42
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 0
30264: PUSH
30265: LD_INT 1
30267: NEG
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: LD_INT 0
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 0
30295: PUSH
30296: LD_INT 1
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: NEG
30306: PUSH
30307: LD_INT 0
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: LD_INT 1
30320: NEG
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 0
30340: PUSH
30341: LD_INT 2
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 2
30372: PUSH
30373: LD_INT 2
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: PUSH
30383: LD_INT 2
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 0
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 1
30402: NEG
30403: PUSH
30404: LD_INT 1
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 2
30425: NEG
30426: PUSH
30427: LD_INT 2
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: NEG
30438: PUSH
30439: LD_INT 3
30441: NEG
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 1
30449: NEG
30450: PUSH
30451: LD_INT 3
30453: NEG
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 0
30461: PUSH
30462: LD_INT 3
30464: NEG
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: LD_INT 2
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 3
30483: PUSH
30484: LD_INT 2
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: PUSH
30491: LD_INT 3
30493: PUSH
30494: LD_INT 3
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: PUSH
30501: LD_INT 2
30503: PUSH
30504: LD_INT 3
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 1
30513: PUSH
30514: LD_INT 3
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 0
30523: PUSH
30524: LD_INT 3
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: LD_INT 2
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 3
30544: NEG
30545: PUSH
30546: LD_INT 2
30548: NEG
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 3
30556: NEG
30557: PUSH
30558: LD_INT 3
30560: NEG
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30597: LD_ADDR_VAR 0 43
30601: PUSH
30602: LD_INT 0
30604: PUSH
30605: LD_INT 0
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 0
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: LD_INT 1
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: NEG
30656: PUSH
30657: LD_INT 0
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: NEG
30667: PUSH
30668: LD_INT 1
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 1
30678: NEG
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: LD_INT 2
30693: NEG
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 1
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 2
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 2
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 1
30732: PUSH
30733: LD_INT 2
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 2
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: NEG
30753: PUSH
30754: LD_INT 1
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 2
30774: NEG
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: LD_INT 3
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 0
30798: PUSH
30799: LD_INT 3
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: LD_INT 2
30812: NEG
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 2
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 3
30831: PUSH
30832: LD_INT 0
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 3
30841: PUSH
30842: LD_INT 1
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 1
30851: PUSH
30852: LD_INT 3
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: LD_INT 0
30861: PUSH
30862: LD_INT 3
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 1
30871: NEG
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: NEG
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 3
30893: NEG
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 3
30904: NEG
30905: PUSH
30906: LD_INT 1
30908: NEG
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30945: LD_ADDR_VAR 0 44
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: LD_INT 1
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: LD_INT 0
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 1
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 0
30993: PUSH
30994: LD_INT 1
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: LD_INT 0
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 1
31014: NEG
31015: PUSH
31016: LD_INT 1
31018: NEG
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 1
31026: NEG
31027: PUSH
31028: LD_INT 2
31030: NEG
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: LD_INT 1
31041: NEG
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 2
31059: PUSH
31060: LD_INT 1
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 2
31069: PUSH
31070: LD_INT 2
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 1
31079: PUSH
31080: LD_INT 2
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 2
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 2
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 2
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 2
31135: NEG
31136: PUSH
31137: LD_INT 3
31139: NEG
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 2
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 3
31158: PUSH
31159: LD_INT 0
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 3
31168: PUSH
31169: LD_INT 1
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PUSH
31176: LD_INT 3
31178: PUSH
31179: LD_INT 2
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 3
31188: PUSH
31189: LD_INT 3
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 2
31198: PUSH
31199: LD_INT 3
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 2
31208: NEG
31209: PUSH
31210: LD_INT 1
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: LD_INT 3
31219: NEG
31220: PUSH
31221: LD_INT 0
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 3
31230: NEG
31231: PUSH
31232: LD_INT 1
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 3
31242: NEG
31243: PUSH
31244: LD_INT 2
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 3
31254: NEG
31255: PUSH
31256: LD_INT 3
31258: NEG
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: LIST
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: LIST
31294: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31295: LD_ADDR_VAR 0 45
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 0
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 0
31312: PUSH
31313: LD_INT 1
31315: NEG
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: LD_INT 0
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 1
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 0
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: LD_INT 0
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: LD_INT 1
31364: NEG
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: LD_INT 2
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 0
31388: PUSH
31389: LD_INT 2
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 1
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 1
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: PUSH
31421: LD_INT 2
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 2
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 2
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 1
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 2
31461: NEG
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 2
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 2
31485: NEG
31486: PUSH
31487: LD_INT 3
31489: NEG
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 1
31497: NEG
31498: PUSH
31499: LD_INT 3
31501: NEG
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: LD_INT 3
31512: NEG
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: LD_INT 2
31523: NEG
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 3
31531: PUSH
31532: LD_INT 2
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 3
31541: PUSH
31542: LD_INT 3
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 2
31551: PUSH
31552: LD_INT 3
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 1
31561: PUSH
31562: LD_INT 3
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PUSH
31569: LD_INT 0
31571: PUSH
31572: LD_INT 3
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: NEG
31582: PUSH
31583: LD_INT 2
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 3
31592: NEG
31593: PUSH
31594: LD_INT 2
31596: NEG
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 3
31604: NEG
31605: PUSH
31606: LD_INT 3
31608: NEG
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31645: LD_ADDR_VAR 0 46
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 0
31662: PUSH
31663: LD_INT 1
31665: NEG
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: LD_INT 1
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 0
31693: PUSH
31694: LD_INT 1
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: NEG
31715: PUSH
31716: LD_INT 1
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: LD_INT 2
31730: NEG
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 0
31738: PUSH
31739: LD_INT 2
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: LD_INT 1
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 2
31760: PUSH
31761: LD_INT 0
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 2
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: PUSH
31781: LD_INT 2
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: LD_INT 2
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PUSH
31798: LD_INT 1
31800: NEG
31801: PUSH
31802: LD_INT 1
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 2
31811: NEG
31812: PUSH
31813: LD_INT 0
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: LD_INT 1
31826: NEG
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 1
31834: NEG
31835: PUSH
31836: LD_INT 3
31838: NEG
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 0
31846: PUSH
31847: LD_INT 3
31849: NEG
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: LD_INT 2
31860: NEG
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 2
31868: PUSH
31869: LD_INT 1
31871: NEG
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 3
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 3
31889: PUSH
31890: LD_INT 1
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 1
31899: PUSH
31900: LD_INT 3
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 0
31909: PUSH
31910: LD_INT 3
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: LD_INT 2
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 3
31941: NEG
31942: PUSH
31943: LD_INT 0
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 3
31952: NEG
31953: PUSH
31954: LD_INT 1
31956: NEG
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: LIST
31974: LIST
31975: LIST
31976: LIST
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: LIST
31985: LIST
31986: LIST
31987: LIST
31988: LIST
31989: LIST
31990: LIST
31991: LIST
31992: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31993: LD_ADDR_VAR 0 47
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: LD_INT 0
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: LD_INT 1
32013: NEG
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 1
32021: PUSH
32022: LD_INT 0
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 1
32031: PUSH
32032: LD_INT 1
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: LD_INT 0
32041: PUSH
32042: LD_INT 1
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: LD_INT 0
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 1
32062: NEG
32063: PUSH
32064: LD_INT 1
32066: NEG
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 1
32074: NEG
32075: PUSH
32076: LD_INT 2
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: LD_INT 2
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: LD_INT 1
32100: NEG
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: NEG
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 2
32120: NEG
32121: PUSH
32122: LD_INT 2
32124: NEG
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: LIST
32134: LIST
32135: LIST
32136: LIST
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32144: LD_ADDR_VAR 0 48
32148: PUSH
32149: LD_INT 0
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 1
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 1
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 1
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: NEG
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 1
32213: NEG
32214: PUSH
32215: LD_INT 1
32217: NEG
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: NEG
32226: PUSH
32227: LD_INT 2
32229: NEG
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: LD_INT 2
32240: NEG
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 1
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 2
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 2
32269: PUSH
32270: LD_INT 1
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32291: LD_ADDR_VAR 0 49
32295: PUSH
32296: LD_INT 0
32298: PUSH
32299: LD_INT 0
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 0
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 1
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: LD_INT 1
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: NEG
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: LD_INT 1
32364: NEG
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 1
32372: PUSH
32373: LD_INT 1
32375: NEG
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 2
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: PUSH
32404: LD_INT 2
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: PUSH
32414: LD_INT 2
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32435: LD_ADDR_VAR 0 50
32439: PUSH
32440: LD_INT 0
32442: PUSH
32443: LD_INT 0
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 0
32452: PUSH
32453: LD_INT 1
32455: NEG
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: LD_INT 1
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 0
32483: PUSH
32484: LD_INT 1
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: LD_INT 0
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 1
32504: NEG
32505: PUSH
32506: LD_INT 1
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 2
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 2
32526: PUSH
32527: LD_INT 2
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 1
32536: PUSH
32537: LD_INT 2
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 0
32546: PUSH
32547: LD_INT 2
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 1
32556: NEG
32557: PUSH
32558: LD_INT 1
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32579: LD_ADDR_VAR 0 51
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 0
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 0
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: LD_INT 1
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 1
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 1
32648: NEG
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: LD_INT 2
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 0
32670: PUSH
32671: LD_INT 2
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 2
32691: NEG
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: NEG
32703: PUSH
32704: LD_INT 1
32706: NEG
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32726: LD_ADDR_VAR 0 52
32730: PUSH
32731: LD_INT 0
32733: PUSH
32734: LD_INT 0
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 0
32743: PUSH
32744: LD_INT 1
32746: NEG
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 1
32764: PUSH
32765: LD_INT 1
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: LD_INT 0
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 1
32795: NEG
32796: PUSH
32797: LD_INT 1
32799: NEG
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 1
32807: NEG
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 1
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 0
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 2
32841: NEG
32842: PUSH
32843: LD_INT 1
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 2
32853: NEG
32854: PUSH
32855: LD_INT 2
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32877: LD_ADDR_VAR 0 53
32881: PUSH
32882: LD_INT 0
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 0
32894: PUSH
32895: LD_INT 1
32897: NEG
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 1
32905: PUSH
32906: LD_INT 0
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 1
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: LD_INT 1
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 1
32935: NEG
32936: PUSH
32937: LD_INT 0
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 1
32950: NEG
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 1
32958: NEG
32959: PUSH
32960: LD_INT 2
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: LD_INT 2
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: LD_INT 1
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 2
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 2
33002: PUSH
33003: LD_INT 1
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 2
33012: PUSH
33013: LD_INT 2
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: PUSH
33023: LD_INT 2
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 0
33032: PUSH
33033: LD_INT 2
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: NEG
33043: PUSH
33044: LD_INT 1
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: LD_INT 1
33068: NEG
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: NEG
33077: PUSH
33078: LD_INT 2
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: LIST
33106: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33107: LD_ADDR_VAR 0 54
33111: PUSH
33112: LD_INT 0
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: LD_INT 0
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: PUSH
33146: LD_INT 1
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 0
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 1
33176: NEG
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 1
33188: NEG
33189: PUSH
33190: LD_INT 2
33192: NEG
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: LD_INT 2
33203: NEG
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 1
33211: PUSH
33212: LD_INT 1
33214: NEG
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: PUSH
33220: LD_INT 2
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 2
33232: PUSH
33233: LD_INT 1
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 2
33242: PUSH
33243: LD_INT 2
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 1
33252: PUSH
33253: LD_INT 2
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 0
33262: PUSH
33263: LD_INT 2
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: NEG
33273: PUSH
33274: LD_INT 1
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: NEG
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 2
33294: NEG
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: NEG
33307: PUSH
33308: LD_INT 2
33310: NEG
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33337: LD_ADDR_VAR 0 55
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 0
33354: PUSH
33355: LD_INT 1
33357: NEG
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: PUSH
33366: LD_INT 0
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: LD_INT 1
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: PUSH
33404: LD_INT 1
33406: NEG
33407: PUSH
33408: LD_INT 1
33410: NEG
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: NEG
33419: PUSH
33420: LD_INT 2
33422: NEG
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 2
33452: PUSH
33453: LD_INT 0
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: LD_INT 2
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 1
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 0
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: LD_INT 1
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: PUSH
33511: LD_INT 2
33513: NEG
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 2
33524: NEG
33525: PUSH
33526: LD_INT 1
33528: NEG
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: NEG
33537: PUSH
33538: LD_INT 2
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33567: LD_ADDR_VAR 0 56
33571: PUSH
33572: LD_INT 0
33574: PUSH
33575: LD_INT 0
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 0
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: LD_INT 0
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 1
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: LD_INT 0
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 1
33625: NEG
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: NEG
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 1
33648: NEG
33649: PUSH
33650: LD_INT 2
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 2
33663: NEG
33664: PUSH
33665: EMPTY
33666: LIST
33667: LIST
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 2
33682: PUSH
33683: LD_INT 0
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 2
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 2
33702: PUSH
33703: LD_INT 2
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: LD_INT 2
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 2
33743: NEG
33744: PUSH
33745: LD_INT 0
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 2
33754: NEG
33755: PUSH
33756: LD_INT 1
33758: NEG
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 2
33766: NEG
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33797: LD_ADDR_VAR 0 57
33801: PUSH
33802: LD_INT 0
33804: PUSH
33805: LD_INT 0
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 1
33825: PUSH
33826: LD_INT 0
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: LD_INT 1
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 0
33845: PUSH
33846: LD_INT 1
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: LD_INT 1
33870: NEG
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 1
33878: NEG
33879: PUSH
33880: LD_INT 2
33882: NEG
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 0
33890: PUSH
33891: LD_INT 2
33893: NEG
33894: PUSH
33895: EMPTY
33896: LIST
33897: LIST
33898: PUSH
33899: LD_INT 1
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 2
33912: PUSH
33913: LD_INT 0
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 2
33922: PUSH
33923: LD_INT 1
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: PUSH
33933: LD_INT 2
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 1
33942: PUSH
33943: LD_INT 2
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: LD_INT 2
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 1
33962: NEG
33963: PUSH
33964: LD_INT 1
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 2
33973: NEG
33974: PUSH
33975: LD_INT 0
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 2
33984: NEG
33985: PUSH
33986: LD_INT 1
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: LD_INT 2
34000: NEG
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: LIST
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34027: LD_ADDR_VAR 0 58
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: LD_INT 0
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: PUSH
34042: LD_INT 0
34044: PUSH
34045: LD_INT 1
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: LD_INT 0
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: LD_INT 1
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 0
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 1
34085: NEG
34086: PUSH
34087: LD_INT 0
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: LD_INT 1
34096: NEG
34097: PUSH
34098: LD_INT 1
34100: NEG
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 1
34108: NEG
34109: PUSH
34110: LD_INT 2
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 0
34120: PUSH
34121: LD_INT 2
34123: NEG
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: LD_INT 1
34134: NEG
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 2
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 2
34152: PUSH
34153: LD_INT 1
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 2
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 0
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 1
34192: NEG
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 2
34203: NEG
34204: PUSH
34205: LD_INT 0
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 2
34214: NEG
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 2
34226: NEG
34227: PUSH
34228: LD_INT 2
34230: NEG
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34257: LD_ADDR_VAR 0 59
34261: PUSH
34262: LD_INT 0
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 0
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: LD_INT 0
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: LD_INT 1
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: LD_INT 1
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: NEG
34316: PUSH
34317: LD_INT 0
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 1
34326: NEG
34327: PUSH
34328: LD_INT 1
34330: NEG
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34345: LD_ADDR_VAR 0 60
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 1
34373: PUSH
34374: LD_INT 0
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: LD_INT 1
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: LD_INT 0
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: LD_INT 1
34414: NEG
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34433: LD_ADDR_VAR 0 61
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 1
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34521: LD_ADDR_VAR 0 62
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 0
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 0
34538: PUSH
34539: LD_INT 1
34541: NEG
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: PUSH
34550: LD_INT 0
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: LD_INT 1
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: LD_INT 0
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: LD_INT 1
34594: NEG
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34609: LD_ADDR_VAR 0 63
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 0
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 0
34626: PUSH
34627: LD_INT 1
34629: NEG
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 1
34647: PUSH
34648: LD_INT 1
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 0
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 1
34667: NEG
34668: PUSH
34669: LD_INT 0
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: LD_INT 1
34682: NEG
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34697: LD_ADDR_VAR 0 64
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: ST_TO_ADDR
// end ; 1 :
34785: GO 40682
34787: LD_INT 1
34789: DOUBLE
34790: EQUAL
34791: IFTRUE 34795
34793: GO 37418
34795: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34796: LD_ADDR_VAR 0 11
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 3
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 0
34815: PUSH
34816: LD_INT 3
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: PUSH
34827: LD_INT 2
34829: NEG
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: LIST
34839: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34840: LD_ADDR_VAR 0 12
34844: PUSH
34845: LD_INT 2
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 3
34858: PUSH
34859: LD_INT 0
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 3
34868: PUSH
34869: LD_INT 1
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: LIST
34880: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34881: LD_ADDR_VAR 0 13
34885: PUSH
34886: LD_INT 3
34888: PUSH
34889: LD_INT 2
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 3
34898: PUSH
34899: LD_INT 3
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: LD_INT 3
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: LIST
34920: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34921: LD_ADDR_VAR 0 14
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: LD_INT 3
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: LD_INT 3
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: LIST
34961: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34962: LD_ADDR_VAR 0 15
34966: PUSH
34967: LD_INT 2
34969: NEG
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 3
34980: NEG
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 3
34991: NEG
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: LIST
35005: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35006: LD_ADDR_VAR 0 16
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 3
35017: NEG
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 3
35025: NEG
35026: PUSH
35027: LD_INT 2
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 3
35037: NEG
35038: PUSH
35039: LD_INT 3
35041: NEG
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: LIST
35051: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35052: LD_ADDR_VAR 0 17
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: LD_INT 3
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 0
35071: PUSH
35072: LD_INT 3
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: PUSH
35083: LD_INT 2
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: LIST
35095: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35096: LD_ADDR_VAR 0 18
35100: PUSH
35101: LD_INT 2
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 3
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 3
35124: PUSH
35125: LD_INT 1
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: LIST
35136: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35137: LD_ADDR_VAR 0 19
35141: PUSH
35142: LD_INT 3
35144: PUSH
35145: LD_INT 2
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 3
35154: PUSH
35155: LD_INT 3
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 2
35164: PUSH
35165: LD_INT 3
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: LIST
35176: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35177: LD_ADDR_VAR 0 20
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: LD_INT 3
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 0
35194: PUSH
35195: LD_INT 3
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 2
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: LIST
35217: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35218: LD_ADDR_VAR 0 21
35222: PUSH
35223: LD_INT 2
35225: NEG
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 3
35236: NEG
35237: PUSH
35238: LD_INT 0
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 3
35247: NEG
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: LIST
35261: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35262: LD_ADDR_VAR 0 22
35266: PUSH
35267: LD_INT 2
35269: NEG
35270: PUSH
35271: LD_INT 3
35273: NEG
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PUSH
35279: LD_INT 3
35281: NEG
35282: PUSH
35283: LD_INT 2
35285: NEG
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 3
35293: NEG
35294: PUSH
35295: LD_INT 3
35297: NEG
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: LIST
35307: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35308: LD_ADDR_VAR 0 23
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: LD_INT 3
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 1
35326: NEG
35327: PUSH
35328: LD_INT 4
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: LD_INT 3
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: LIST
35351: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35352: LD_ADDR_VAR 0 24
35356: PUSH
35357: LD_INT 3
35359: PUSH
35360: LD_INT 0
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 3
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 4
35380: PUSH
35381: LD_INT 1
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: LIST
35392: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35393: LD_ADDR_VAR 0 25
35397: PUSH
35398: LD_INT 3
35400: PUSH
35401: LD_INT 3
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 4
35410: PUSH
35411: LD_INT 3
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 3
35420: PUSH
35421: LD_INT 4
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: LIST
35432: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35433: LD_ADDR_VAR 0 26
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 3
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: LD_INT 4
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: NEG
35461: PUSH
35462: LD_INT 3
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: LIST
35473: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35474: LD_ADDR_VAR 0 27
35478: PUSH
35479: LD_INT 3
35481: NEG
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 3
35492: NEG
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 4
35503: NEG
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: LIST
35517: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35518: LD_ADDR_VAR 0 28
35522: PUSH
35523: LD_INT 3
35525: NEG
35526: PUSH
35527: LD_INT 3
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 3
35537: NEG
35538: PUSH
35539: LD_INT 4
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 4
35549: NEG
35550: PUSH
35551: LD_INT 3
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: LIST
35563: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35564: LD_ADDR_VAR 0 29
35568: PUSH
35569: LD_INT 1
35571: NEG
35572: PUSH
35573: LD_INT 3
35575: NEG
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 0
35583: PUSH
35584: LD_INT 3
35586: NEG
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: LD_INT 2
35597: NEG
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 1
35605: NEG
35606: PUSH
35607: LD_INT 4
35609: NEG
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 0
35617: PUSH
35618: LD_INT 4
35620: NEG
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: LD_INT 3
35631: NEG
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 5
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: LD_INT 5
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: PUSH
35663: LD_INT 4
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: LD_INT 6
35677: NEG
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 6
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: LD_INT 5
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35719: LD_ADDR_VAR 0 30
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: LD_INT 0
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 3
35747: PUSH
35748: LD_INT 1
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 3
35757: PUSH
35758: LD_INT 1
35760: NEG
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 4
35768: PUSH
35769: LD_INT 0
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 4
35778: PUSH
35779: LD_INT 1
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 4
35788: PUSH
35789: LD_INT 1
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 5
35799: PUSH
35800: LD_INT 0
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 5
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 5
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 6
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 6
35840: PUSH
35841: LD_INT 1
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35862: LD_ADDR_VAR 0 31
35866: PUSH
35867: LD_INT 3
35869: PUSH
35870: LD_INT 2
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: LD_INT 3
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 2
35889: PUSH
35890: LD_INT 3
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 4
35899: PUSH
35900: LD_INT 3
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 4
35909: PUSH
35910: LD_INT 4
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: PUSH
35920: LD_INT 4
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 5
35929: PUSH
35930: LD_INT 4
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 5
35939: PUSH
35940: LD_INT 5
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 4
35949: PUSH
35950: LD_INT 5
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 6
35959: PUSH
35960: LD_INT 5
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 6
35969: PUSH
35970: LD_INT 6
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 5
35979: PUSH
35980: LD_INT 6
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36001: LD_ADDR_VAR 0 32
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 3
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 0
36018: PUSH
36019: LD_INT 3
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 1
36028: NEG
36029: PUSH
36030: LD_INT 2
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: LD_INT 4
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 0
36049: PUSH
36050: LD_INT 4
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 1
36059: NEG
36060: PUSH
36061: LD_INT 3
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: LD_INT 5
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 0
36080: PUSH
36081: LD_INT 5
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 1
36090: NEG
36091: PUSH
36092: LD_INT 4
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 1
36101: PUSH
36102: LD_INT 6
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: LD_INT 6
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 5
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36144: LD_ADDR_VAR 0 33
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 3
36162: NEG
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 3
36173: NEG
36174: PUSH
36175: LD_INT 1
36177: NEG
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 3
36185: NEG
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 4
36196: NEG
36197: PUSH
36198: LD_INT 0
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 4
36207: NEG
36208: PUSH
36209: LD_INT 1
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 4
36219: NEG
36220: PUSH
36221: LD_INT 1
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 5
36230: NEG
36231: PUSH
36232: LD_INT 0
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 5
36241: NEG
36242: PUSH
36243: LD_INT 1
36245: NEG
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 5
36253: NEG
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 6
36264: NEG
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 6
36275: NEG
36276: PUSH
36277: LD_INT 1
36279: NEG
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: LIST
36298: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36299: LD_ADDR_VAR 0 34
36303: PUSH
36304: LD_INT 2
36306: NEG
36307: PUSH
36308: LD_INT 3
36310: NEG
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 3
36318: NEG
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 3
36330: NEG
36331: PUSH
36332: LD_INT 3
36334: NEG
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: LD_INT 3
36342: NEG
36343: PUSH
36344: LD_INT 4
36346: NEG
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 4
36354: NEG
36355: PUSH
36356: LD_INT 3
36358: NEG
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 4
36366: NEG
36367: PUSH
36368: LD_INT 4
36370: NEG
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 4
36378: NEG
36379: PUSH
36380: LD_INT 5
36382: NEG
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 5
36390: NEG
36391: PUSH
36392: LD_INT 4
36394: NEG
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 5
36402: NEG
36403: PUSH
36404: LD_INT 5
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 5
36414: NEG
36415: PUSH
36416: LD_INT 6
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 6
36426: NEG
36427: PUSH
36428: LD_INT 5
36430: NEG
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 6
36438: NEG
36439: PUSH
36440: LD_INT 6
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36462: LD_ADDR_VAR 0 41
36466: PUSH
36467: LD_INT 0
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: LD_INT 3
36484: NEG
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 1
36492: PUSH
36493: LD_INT 2
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: LIST
36505: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36506: LD_ADDR_VAR 0 42
36510: PUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 3
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: LIST
36546: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36547: LD_ADDR_VAR 0 43
36551: PUSH
36552: LD_INT 2
36554: PUSH
36555: LD_INT 2
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 3
36564: PUSH
36565: LD_INT 2
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: LD_INT 3
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: LIST
36586: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36587: LD_ADDR_VAR 0 44
36591: PUSH
36592: LD_INT 0
36594: PUSH
36595: LD_INT 2
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: PUSH
36605: LD_INT 3
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 1
36614: NEG
36615: PUSH
36616: LD_INT 2
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36628: LD_ADDR_VAR 0 45
36632: PUSH
36633: LD_INT 2
36635: NEG
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 2
36646: NEG
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 3
36657: NEG
36658: PUSH
36659: LD_INT 1
36661: NEG
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: LIST
36671: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36672: LD_ADDR_VAR 0 46
36676: PUSH
36677: LD_INT 2
36679: NEG
36680: PUSH
36681: LD_INT 2
36683: NEG
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PUSH
36689: LD_INT 2
36691: NEG
36692: PUSH
36693: LD_INT 3
36695: NEG
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 3
36703: NEG
36704: PUSH
36705: LD_INT 2
36707: NEG
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: LIST
36717: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36718: LD_ADDR_VAR 0 47
36722: PUSH
36723: LD_INT 2
36725: NEG
36726: PUSH
36727: LD_INT 3
36729: NEG
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: LD_INT 3
36741: NEG
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36751: LD_ADDR_VAR 0 48
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: LD_INT 2
36761: NEG
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 2
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36782: LD_ADDR_VAR 0 49
36786: PUSH
36787: LD_INT 3
36789: PUSH
36790: LD_INT 1
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 3
36799: PUSH
36800: LD_INT 2
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36811: LD_ADDR_VAR 0 50
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: LD_INT 3
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 1
36828: PUSH
36829: LD_INT 3
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36840: LD_ADDR_VAR 0 51
36844: PUSH
36845: LD_INT 1
36847: NEG
36848: PUSH
36849: LD_INT 2
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 1
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36871: LD_ADDR_VAR 0 52
36875: PUSH
36876: LD_INT 3
36878: NEG
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 3
36890: NEG
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36904: LD_ADDR_VAR 0 53
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: LD_INT 3
36926: NEG
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: LIST
36947: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36948: LD_ADDR_VAR 0 54
36952: PUSH
36953: LD_INT 2
36955: PUSH
36956: LD_INT 1
36958: NEG
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 3
36966: PUSH
36967: LD_INT 0
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 3
36976: PUSH
36977: LD_INT 1
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: LIST
36988: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36989: LD_ADDR_VAR 0 55
36993: PUSH
36994: LD_INT 3
36996: PUSH
36997: LD_INT 2
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 3
37006: PUSH
37007: LD_INT 3
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: LD_INT 3
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: LIST
37028: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37029: LD_ADDR_VAR 0 56
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 3
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: LD_INT 3
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 2
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: LIST
37069: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37070: LD_ADDR_VAR 0 57
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: LD_INT 1
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 3
37088: NEG
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 3
37099: NEG
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: LIST
37113: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37114: LD_ADDR_VAR 0 58
37118: PUSH
37119: LD_INT 2
37121: NEG
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 3
37133: NEG
37134: PUSH
37135: LD_INT 2
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 3
37145: NEG
37146: PUSH
37147: LD_INT 3
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: LIST
37159: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37160: LD_ADDR_VAR 0 59
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: LD_INT 2
37171: NEG
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: LD_INT 2
37182: NEG
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 1
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: LIST
37203: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37204: LD_ADDR_VAR 0 60
37208: PUSH
37209: LD_INT 1
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 2
37222: PUSH
37223: LD_INT 0
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 2
37232: PUSH
37233: LD_INT 1
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: LIST
37244: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37245: LD_ADDR_VAR 0 61
37249: PUSH
37250: LD_INT 2
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: LD_INT 2
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: PUSH
37273: LD_INT 2
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: LIST
37284: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37285: LD_ADDR_VAR 0 62
37289: PUSH
37290: LD_INT 1
37292: PUSH
37293: LD_INT 2
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: LD_INT 2
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: LD_INT 1
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: LIST
37325: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37326: LD_ADDR_VAR 0 63
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: LD_INT 1
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 2
37344: NEG
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 2
37355: NEG
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: LIST
37369: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37370: LD_ADDR_VAR 0 64
37374: PUSH
37375: LD_INT 1
37377: NEG
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 2
37401: NEG
37402: PUSH
37403: LD_INT 2
37405: NEG
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: LIST
37415: ST_TO_ADDR
// end ; 2 :
37416: GO 40682
37418: LD_INT 2
37420: DOUBLE
37421: EQUAL
37422: IFTRUE 37426
37424: GO 40681
37426: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37427: LD_ADDR_VAR 0 29
37431: PUSH
37432: LD_INT 4
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 4
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 5
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 5
37465: PUSH
37466: LD_INT 1
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 4
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: PUSH
37486: LD_INT 0
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 3
37495: PUSH
37496: LD_INT 1
37498: NEG
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 3
37506: PUSH
37507: LD_INT 2
37509: NEG
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 5
37517: PUSH
37518: LD_INT 2
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 3
37527: PUSH
37528: LD_INT 3
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 3
37537: PUSH
37538: LD_INT 2
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 4
37547: PUSH
37548: LD_INT 3
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 4
37557: PUSH
37558: LD_INT 4
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: LD_INT 3
37567: PUSH
37568: LD_INT 4
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: LD_INT 3
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 4
37597: PUSH
37598: LD_INT 2
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 2
37607: PUSH
37608: LD_INT 4
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: PUSH
37615: LD_INT 0
37617: PUSH
37618: LD_INT 4
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 0
37627: PUSH
37628: LD_INT 3
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: LD_INT 4
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: LD_INT 5
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: LD_INT 5
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: NEG
37668: PUSH
37669: LD_INT 4
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 3
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 2
37689: PUSH
37690: LD_INT 5
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 2
37699: NEG
37700: PUSH
37701: LD_INT 3
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 3
37710: NEG
37711: PUSH
37712: LD_INT 0
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 3
37721: NEG
37722: PUSH
37723: LD_INT 1
37725: NEG
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 2
37733: NEG
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 2
37744: NEG
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 3
37755: NEG
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 4
37766: NEG
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 4
37777: NEG
37778: PUSH
37779: LD_INT 1
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 4
37789: NEG
37790: PUSH
37791: LD_INT 2
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: LD_INT 2
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 4
37812: NEG
37813: PUSH
37814: LD_INT 4
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 4
37824: NEG
37825: PUSH
37826: LD_INT 5
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 3
37836: NEG
37837: PUSH
37838: LD_INT 4
37840: NEG
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 3
37848: NEG
37849: PUSH
37850: LD_INT 3
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 4
37860: NEG
37861: PUSH
37862: LD_INT 3
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: LD_INT 5
37872: NEG
37873: PUSH
37874: LD_INT 4
37876: NEG
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 5
37884: NEG
37885: PUSH
37886: LD_INT 5
37888: NEG
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 3
37896: NEG
37897: PUSH
37898: LD_INT 5
37900: NEG
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 5
37908: NEG
37909: PUSH
37910: LD_INT 3
37912: NEG
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
37965: LD_ADDR_VAR 0 30
37969: PUSH
37970: LD_INT 4
37972: PUSH
37973: LD_INT 4
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 4
37982: PUSH
37983: LD_INT 3
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 5
37992: PUSH
37993: LD_INT 4
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 5
38002: PUSH
38003: LD_INT 5
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 4
38012: PUSH
38013: LD_INT 5
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 3
38022: PUSH
38023: LD_INT 4
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 3
38032: PUSH
38033: LD_INT 3
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 5
38042: PUSH
38043: LD_INT 3
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 3
38052: PUSH
38053: LD_INT 5
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 3
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 2
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: LD_INT 3
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: LD_INT 4
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: LD_INT 0
38102: PUSH
38103: LD_INT 4
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 1
38112: NEG
38113: PUSH
38114: LD_INT 3
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 1
38123: NEG
38124: PUSH
38125: LD_INT 2
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 2
38134: PUSH
38135: LD_INT 4
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 2
38144: NEG
38145: PUSH
38146: LD_INT 2
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 4
38155: NEG
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 4
38166: NEG
38167: PUSH
38168: LD_INT 1
38170: NEG
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 3
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 3
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 4
38200: NEG
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 5
38211: NEG
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 5
38222: NEG
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 5
38234: NEG
38235: PUSH
38236: LD_INT 2
38238: NEG
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 3
38246: NEG
38247: PUSH
38248: LD_INT 2
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 3
38257: NEG
38258: PUSH
38259: LD_INT 3
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 3
38269: NEG
38270: PUSH
38271: LD_INT 4
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 2
38281: NEG
38282: PUSH
38283: LD_INT 3
38285: NEG
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 2
38293: NEG
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 3
38305: NEG
38306: PUSH
38307: LD_INT 2
38309: NEG
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 4
38317: NEG
38318: PUSH
38319: LD_INT 3
38321: NEG
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 4
38329: NEG
38330: PUSH
38331: LD_INT 4
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 2
38341: NEG
38342: PUSH
38343: LD_INT 4
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 4
38353: NEG
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 0
38365: PUSH
38366: LD_INT 4
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: LD_INT 5
38379: NEG
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 1
38387: PUSH
38388: LD_INT 4
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: LD_INT 1
38398: PUSH
38399: LD_INT 3
38401: NEG
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: LD_INT 3
38412: NEG
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 4
38424: NEG
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 5
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 2
38444: PUSH
38445: LD_INT 3
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 5
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: LIST
38484: LIST
38485: LIST
38486: LIST
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38512: LD_ADDR_VAR 0 31
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: LD_INT 4
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 0
38529: PUSH
38530: LD_INT 3
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 1
38539: PUSH
38540: LD_INT 4
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: LD_INT 5
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: LD_INT 5
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 1
38569: NEG
38570: PUSH
38571: LD_INT 4
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 1
38580: NEG
38581: PUSH
38582: LD_INT 3
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 2
38591: PUSH
38592: LD_INT 5
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: LD_INT 3
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 3
38612: NEG
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 3
38623: NEG
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 2
38635: NEG
38636: PUSH
38637: LD_INT 0
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 2
38646: NEG
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 3
38657: NEG
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 4
38668: NEG
38669: PUSH
38670: LD_INT 0
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 4
38679: NEG
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 4
38691: NEG
38692: PUSH
38693: LD_INT 2
38695: NEG
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 2
38703: NEG
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 4
38714: NEG
38715: PUSH
38716: LD_INT 4
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 4
38726: NEG
38727: PUSH
38728: LD_INT 5
38730: NEG
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 3
38738: NEG
38739: PUSH
38740: LD_INT 4
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 3
38750: NEG
38751: PUSH
38752: LD_INT 3
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 4
38762: NEG
38763: PUSH
38764: LD_INT 3
38766: NEG
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 5
38774: NEG
38775: PUSH
38776: LD_INT 4
38778: NEG
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 5
38786: NEG
38787: PUSH
38788: LD_INT 5
38790: NEG
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 3
38798: NEG
38799: PUSH
38800: LD_INT 5
38802: NEG
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 5
38810: NEG
38811: PUSH
38812: LD_INT 3
38814: NEG
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 3
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 0
38833: PUSH
38834: LD_INT 4
38836: NEG
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: LD_INT 3
38847: NEG
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 1
38855: PUSH
38856: LD_INT 2
38858: NEG
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 0
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: NEG
38878: PUSH
38879: LD_INT 3
38881: NEG
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 1
38889: NEG
38890: PUSH
38891: LD_INT 4
38893: NEG
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 2
38901: PUSH
38902: LD_INT 2
38904: NEG
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 2
38912: NEG
38913: PUSH
38914: LD_INT 4
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 4
38924: PUSH
38925: LD_INT 0
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 4
38934: PUSH
38935: LD_INT 1
38937: NEG
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 5
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 5
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: LD_INT 1
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 3
38975: PUSH
38976: LD_INT 0
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: LD_INT 1
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 3
38996: PUSH
38997: LD_INT 2
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 5
39007: PUSH
39008: LD_INT 2
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39062: LD_ADDR_VAR 0 32
39066: PUSH
39067: LD_INT 4
39069: NEG
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 4
39080: NEG
39081: PUSH
39082: LD_INT 1
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 3
39092: NEG
39093: PUSH
39094: LD_INT 0
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 3
39103: NEG
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 4
39114: NEG
39115: PUSH
39116: LD_INT 1
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 5
39125: NEG
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 5
39136: NEG
39137: PUSH
39138: LD_INT 1
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 5
39148: NEG
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 3
39160: NEG
39161: PUSH
39162: LD_INT 2
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 3
39171: NEG
39172: PUSH
39173: LD_INT 3
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 3
39183: NEG
39184: PUSH
39185: LD_INT 4
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 2
39195: NEG
39196: PUSH
39197: LD_INT 3
39199: NEG
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: LD_INT 2
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 3
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 4
39231: NEG
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 4
39243: NEG
39244: PUSH
39245: LD_INT 4
39247: NEG
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 2
39255: NEG
39256: PUSH
39257: LD_INT 4
39259: NEG
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 4
39267: NEG
39268: PUSH
39269: LD_INT 2
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 0
39279: PUSH
39280: LD_INT 4
39282: NEG
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 0
39290: PUSH
39291: LD_INT 5
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: PUSH
39302: LD_INT 4
39304: NEG
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: PUSH
39313: LD_INT 3
39315: NEG
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: LD_INT 0
39323: PUSH
39324: LD_INT 3
39326: NEG
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: NEG
39335: PUSH
39336: LD_INT 4
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: NEG
39347: PUSH
39348: LD_INT 5
39350: NEG
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 2
39358: PUSH
39359: LD_INT 3
39361: NEG
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 2
39369: NEG
39370: PUSH
39371: LD_INT 5
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 3
39381: PUSH
39382: LD_INT 0
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 3
39391: PUSH
39392: LD_INT 1
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 4
39402: PUSH
39403: LD_INT 0
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 4
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 3
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 2
39432: PUSH
39433: LD_INT 0
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 2
39453: PUSH
39454: LD_INT 2
39456: NEG
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 4
39464: PUSH
39465: LD_INT 2
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 4
39474: PUSH
39475: LD_INT 4
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 4
39484: PUSH
39485: LD_INT 3
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 5
39494: PUSH
39495: LD_INT 4
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 5
39504: PUSH
39505: LD_INT 5
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 4
39514: PUSH
39515: LD_INT 5
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 3
39524: PUSH
39525: LD_INT 4
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 3
39534: PUSH
39535: LD_INT 3
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PUSH
39542: LD_INT 5
39544: PUSH
39545: LD_INT 3
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 3
39554: PUSH
39555: LD_INT 5
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39609: LD_ADDR_VAR 0 33
39613: PUSH
39614: LD_INT 4
39616: NEG
39617: PUSH
39618: LD_INT 4
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 4
39628: NEG
39629: PUSH
39630: LD_INT 5
39632: NEG
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 3
39640: NEG
39641: PUSH
39642: LD_INT 4
39644: NEG
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 3
39652: NEG
39653: PUSH
39654: LD_INT 3
39656: NEG
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 4
39664: NEG
39665: PUSH
39666: LD_INT 3
39668: NEG
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 5
39676: NEG
39677: PUSH
39678: LD_INT 4
39680: NEG
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 5
39688: NEG
39689: PUSH
39690: LD_INT 5
39692: NEG
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 3
39700: NEG
39701: PUSH
39702: LD_INT 5
39704: NEG
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: PUSH
39710: LD_INT 5
39712: NEG
39713: PUSH
39714: LD_INT 3
39716: NEG
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 0
39724: PUSH
39725: LD_INT 3
39727: NEG
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 0
39735: PUSH
39736: LD_INT 4
39738: NEG
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 1
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 2
39760: NEG
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 1
39779: NEG
39780: PUSH
39781: LD_INT 3
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 1
39791: NEG
39792: PUSH
39793: LD_INT 4
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 2
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 2
39814: NEG
39815: PUSH
39816: LD_INT 4
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 4
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 4
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 5
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 5
39857: PUSH
39858: LD_INT 1
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 4
39867: PUSH
39868: LD_INT 1
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 3
39877: PUSH
39878: LD_INT 0
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 3
39887: PUSH
39888: LD_INT 1
39890: NEG
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: PUSH
39899: LD_INT 2
39901: NEG
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 5
39909: PUSH
39910: LD_INT 2
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 3
39919: PUSH
39920: LD_INT 3
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 3
39929: PUSH
39930: LD_INT 2
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 4
39939: PUSH
39940: LD_INT 3
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 4
39949: PUSH
39950: LD_INT 4
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 3
39959: PUSH
39960: LD_INT 4
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 2
39969: PUSH
39970: LD_INT 3
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 2
39979: PUSH
39980: LD_INT 2
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 4
39989: PUSH
39990: LD_INT 2
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 2
39999: PUSH
40000: LD_INT 4
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PUSH
40007: LD_INT 0
40009: PUSH
40010: LD_INT 4
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 0
40019: PUSH
40020: LD_INT 3
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 1
40029: PUSH
40030: LD_INT 4
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: LD_INT 5
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: LD_INT 5
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 4
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 1
40070: NEG
40071: PUSH
40072: LD_INT 3
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: PUSH
40082: LD_INT 5
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 2
40091: NEG
40092: PUSH
40093: LD_INT 3
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: LIST
40116: LIST
40117: LIST
40118: LIST
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40147: LD_ADDR_VAR 0 34
40151: PUSH
40152: LD_INT 0
40154: PUSH
40155: LD_INT 4
40157: NEG
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 0
40165: PUSH
40166: LD_INT 5
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 1
40176: PUSH
40177: LD_INT 4
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: PUSH
40188: LD_INT 3
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 3
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 4
40213: NEG
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 1
40221: NEG
40222: PUSH
40223: LD_INT 5
40225: NEG
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 3
40236: NEG
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 2
40244: NEG
40245: PUSH
40246: LD_INT 5
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 3
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 3
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 4
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 4
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 3
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 2
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 2
40317: PUSH
40318: LD_INT 1
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: PUSH
40329: LD_INT 2
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 4
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 4
40349: PUSH
40350: LD_INT 4
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 4
40359: PUSH
40360: LD_INT 3
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 5
40369: PUSH
40370: LD_INT 4
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 5
40379: PUSH
40380: LD_INT 5
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 4
40389: PUSH
40390: LD_INT 5
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 3
40399: PUSH
40400: LD_INT 4
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 3
40409: PUSH
40410: LD_INT 3
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 5
40419: PUSH
40420: LD_INT 3
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 3
40429: PUSH
40430: LD_INT 5
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 3
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: LD_INT 2
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: LD_INT 3
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: LD_INT 4
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 4
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: LD_INT 3
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 1
40500: NEG
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 2
40511: PUSH
40512: LD_INT 4
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 2
40521: NEG
40522: PUSH
40523: LD_INT 2
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 4
40532: NEG
40533: PUSH
40534: LD_INT 0
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: LD_INT 4
40543: NEG
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 3
40555: NEG
40556: PUSH
40557: LD_INT 0
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: LD_INT 3
40566: NEG
40567: PUSH
40568: LD_INT 1
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 4
40577: NEG
40578: PUSH
40579: LD_INT 1
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 5
40588: NEG
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 5
40599: NEG
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 5
40611: NEG
40612: PUSH
40613: LD_INT 2
40615: NEG
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 3
40623: NEG
40624: PUSH
40625: LD_INT 2
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: ST_TO_ADDR
// end ; end ;
40679: GO 40682
40681: POP
// case btype of b_depot , b_warehouse :
40682: LD_VAR 0 1
40686: PUSH
40687: LD_INT 0
40689: DOUBLE
40690: EQUAL
40691: IFTRUE 40701
40693: LD_INT 1
40695: DOUBLE
40696: EQUAL
40697: IFTRUE 40701
40699: GO 40902
40701: POP
// case nation of nation_american :
40702: LD_VAR 0 5
40706: PUSH
40707: LD_INT 1
40709: DOUBLE
40710: EQUAL
40711: IFTRUE 40715
40713: GO 40771
40715: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40716: LD_ADDR_VAR 0 9
40720: PUSH
40721: LD_VAR 0 11
40725: PUSH
40726: LD_VAR 0 12
40730: PUSH
40731: LD_VAR 0 13
40735: PUSH
40736: LD_VAR 0 14
40740: PUSH
40741: LD_VAR 0 15
40745: PUSH
40746: LD_VAR 0 16
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: PUSH
40759: LD_VAR 0 4
40763: PUSH
40764: LD_INT 1
40766: PLUS
40767: ARRAY
40768: ST_TO_ADDR
40769: GO 40900
40771: LD_INT 2
40773: DOUBLE
40774: EQUAL
40775: IFTRUE 40779
40777: GO 40835
40779: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40780: LD_ADDR_VAR 0 9
40784: PUSH
40785: LD_VAR 0 17
40789: PUSH
40790: LD_VAR 0 18
40794: PUSH
40795: LD_VAR 0 19
40799: PUSH
40800: LD_VAR 0 20
40804: PUSH
40805: LD_VAR 0 21
40809: PUSH
40810: LD_VAR 0 22
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: PUSH
40823: LD_VAR 0 4
40827: PUSH
40828: LD_INT 1
40830: PLUS
40831: ARRAY
40832: ST_TO_ADDR
40833: GO 40900
40835: LD_INT 3
40837: DOUBLE
40838: EQUAL
40839: IFTRUE 40843
40841: GO 40899
40843: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40844: LD_ADDR_VAR 0 9
40848: PUSH
40849: LD_VAR 0 23
40853: PUSH
40854: LD_VAR 0 24
40858: PUSH
40859: LD_VAR 0 25
40863: PUSH
40864: LD_VAR 0 26
40868: PUSH
40869: LD_VAR 0 27
40873: PUSH
40874: LD_VAR 0 28
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: PUSH
40887: LD_VAR 0 4
40891: PUSH
40892: LD_INT 1
40894: PLUS
40895: ARRAY
40896: ST_TO_ADDR
40897: GO 40900
40899: POP
40900: GO 41455
40902: LD_INT 2
40904: DOUBLE
40905: EQUAL
40906: IFTRUE 40916
40908: LD_INT 3
40910: DOUBLE
40911: EQUAL
40912: IFTRUE 40916
40914: GO 40972
40916: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40917: LD_ADDR_VAR 0 9
40921: PUSH
40922: LD_VAR 0 29
40926: PUSH
40927: LD_VAR 0 30
40931: PUSH
40932: LD_VAR 0 31
40936: PUSH
40937: LD_VAR 0 32
40941: PUSH
40942: LD_VAR 0 33
40946: PUSH
40947: LD_VAR 0 34
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: PUSH
40960: LD_VAR 0 4
40964: PUSH
40965: LD_INT 1
40967: PLUS
40968: ARRAY
40969: ST_TO_ADDR
40970: GO 41455
40972: LD_INT 16
40974: DOUBLE
40975: EQUAL
40976: IFTRUE 41034
40978: LD_INT 17
40980: DOUBLE
40981: EQUAL
40982: IFTRUE 41034
40984: LD_INT 18
40986: DOUBLE
40987: EQUAL
40988: IFTRUE 41034
40990: LD_INT 19
40992: DOUBLE
40993: EQUAL
40994: IFTRUE 41034
40996: LD_INT 22
40998: DOUBLE
40999: EQUAL
41000: IFTRUE 41034
41002: LD_INT 20
41004: DOUBLE
41005: EQUAL
41006: IFTRUE 41034
41008: LD_INT 21
41010: DOUBLE
41011: EQUAL
41012: IFTRUE 41034
41014: LD_INT 23
41016: DOUBLE
41017: EQUAL
41018: IFTRUE 41034
41020: LD_INT 24
41022: DOUBLE
41023: EQUAL
41024: IFTRUE 41034
41026: LD_INT 25
41028: DOUBLE
41029: EQUAL
41030: IFTRUE 41034
41032: GO 41090
41034: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41035: LD_ADDR_VAR 0 9
41039: PUSH
41040: LD_VAR 0 35
41044: PUSH
41045: LD_VAR 0 36
41049: PUSH
41050: LD_VAR 0 37
41054: PUSH
41055: LD_VAR 0 38
41059: PUSH
41060: LD_VAR 0 39
41064: PUSH
41065: LD_VAR 0 40
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: PUSH
41078: LD_VAR 0 4
41082: PUSH
41083: LD_INT 1
41085: PLUS
41086: ARRAY
41087: ST_TO_ADDR
41088: GO 41455
41090: LD_INT 6
41092: DOUBLE
41093: EQUAL
41094: IFTRUE 41146
41096: LD_INT 7
41098: DOUBLE
41099: EQUAL
41100: IFTRUE 41146
41102: LD_INT 8
41104: DOUBLE
41105: EQUAL
41106: IFTRUE 41146
41108: LD_INT 13
41110: DOUBLE
41111: EQUAL
41112: IFTRUE 41146
41114: LD_INT 12
41116: DOUBLE
41117: EQUAL
41118: IFTRUE 41146
41120: LD_INT 15
41122: DOUBLE
41123: EQUAL
41124: IFTRUE 41146
41126: LD_INT 11
41128: DOUBLE
41129: EQUAL
41130: IFTRUE 41146
41132: LD_INT 14
41134: DOUBLE
41135: EQUAL
41136: IFTRUE 41146
41138: LD_INT 10
41140: DOUBLE
41141: EQUAL
41142: IFTRUE 41146
41144: GO 41202
41146: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41147: LD_ADDR_VAR 0 9
41151: PUSH
41152: LD_VAR 0 41
41156: PUSH
41157: LD_VAR 0 42
41161: PUSH
41162: LD_VAR 0 43
41166: PUSH
41167: LD_VAR 0 44
41171: PUSH
41172: LD_VAR 0 45
41176: PUSH
41177: LD_VAR 0 46
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: LIST
41186: LIST
41187: LIST
41188: LIST
41189: PUSH
41190: LD_VAR 0 4
41194: PUSH
41195: LD_INT 1
41197: PLUS
41198: ARRAY
41199: ST_TO_ADDR
41200: GO 41455
41202: LD_INT 36
41204: DOUBLE
41205: EQUAL
41206: IFTRUE 41210
41208: GO 41266
41210: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41211: LD_ADDR_VAR 0 9
41215: PUSH
41216: LD_VAR 0 47
41220: PUSH
41221: LD_VAR 0 48
41225: PUSH
41226: LD_VAR 0 49
41230: PUSH
41231: LD_VAR 0 50
41235: PUSH
41236: LD_VAR 0 51
41240: PUSH
41241: LD_VAR 0 52
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: PUSH
41254: LD_VAR 0 4
41258: PUSH
41259: LD_INT 1
41261: PLUS
41262: ARRAY
41263: ST_TO_ADDR
41264: GO 41455
41266: LD_INT 4
41268: DOUBLE
41269: EQUAL
41270: IFTRUE 41292
41272: LD_INT 5
41274: DOUBLE
41275: EQUAL
41276: IFTRUE 41292
41278: LD_INT 34
41280: DOUBLE
41281: EQUAL
41282: IFTRUE 41292
41284: LD_INT 37
41286: DOUBLE
41287: EQUAL
41288: IFTRUE 41292
41290: GO 41348
41292: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41293: LD_ADDR_VAR 0 9
41297: PUSH
41298: LD_VAR 0 53
41302: PUSH
41303: LD_VAR 0 54
41307: PUSH
41308: LD_VAR 0 55
41312: PUSH
41313: LD_VAR 0 56
41317: PUSH
41318: LD_VAR 0 57
41322: PUSH
41323: LD_VAR 0 58
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: LIST
41332: LIST
41333: LIST
41334: LIST
41335: PUSH
41336: LD_VAR 0 4
41340: PUSH
41341: LD_INT 1
41343: PLUS
41344: ARRAY
41345: ST_TO_ADDR
41346: GO 41455
41348: LD_INT 31
41350: DOUBLE
41351: EQUAL
41352: IFTRUE 41398
41354: LD_INT 32
41356: DOUBLE
41357: EQUAL
41358: IFTRUE 41398
41360: LD_INT 33
41362: DOUBLE
41363: EQUAL
41364: IFTRUE 41398
41366: LD_INT 27
41368: DOUBLE
41369: EQUAL
41370: IFTRUE 41398
41372: LD_INT 26
41374: DOUBLE
41375: EQUAL
41376: IFTRUE 41398
41378: LD_INT 28
41380: DOUBLE
41381: EQUAL
41382: IFTRUE 41398
41384: LD_INT 29
41386: DOUBLE
41387: EQUAL
41388: IFTRUE 41398
41390: LD_INT 30
41392: DOUBLE
41393: EQUAL
41394: IFTRUE 41398
41396: GO 41454
41398: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41399: LD_ADDR_VAR 0 9
41403: PUSH
41404: LD_VAR 0 59
41408: PUSH
41409: LD_VAR 0 60
41413: PUSH
41414: LD_VAR 0 61
41418: PUSH
41419: LD_VAR 0 62
41423: PUSH
41424: LD_VAR 0 63
41428: PUSH
41429: LD_VAR 0 64
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: PUSH
41442: LD_VAR 0 4
41446: PUSH
41447: LD_INT 1
41449: PLUS
41450: ARRAY
41451: ST_TO_ADDR
41452: GO 41455
41454: POP
// temp_list2 = [ ] ;
41455: LD_ADDR_VAR 0 10
41459: PUSH
41460: EMPTY
41461: ST_TO_ADDR
// for i in temp_list do
41462: LD_ADDR_VAR 0 8
41466: PUSH
41467: LD_VAR 0 9
41471: PUSH
41472: FOR_IN
41473: IFFALSE 41525
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41475: LD_ADDR_VAR 0 10
41479: PUSH
41480: LD_VAR 0 10
41484: PUSH
41485: LD_VAR 0 8
41489: PUSH
41490: LD_INT 1
41492: ARRAY
41493: PUSH
41494: LD_VAR 0 2
41498: PLUS
41499: PUSH
41500: LD_VAR 0 8
41504: PUSH
41505: LD_INT 2
41507: ARRAY
41508: PUSH
41509: LD_VAR 0 3
41513: PLUS
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: EMPTY
41520: LIST
41521: ADD
41522: ST_TO_ADDR
41523: GO 41472
41525: POP
41526: POP
// result = temp_list2 ;
41527: LD_ADDR_VAR 0 7
41531: PUSH
41532: LD_VAR 0 10
41536: ST_TO_ADDR
// end ;
41537: LD_VAR 0 7
41541: RET
// export function EnemyInRange ( unit , dist ) ; begin
41542: LD_INT 0
41544: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41545: LD_ADDR_VAR 0 3
41549: PUSH
41550: LD_VAR 0 1
41554: PPUSH
41555: CALL_OW 255
41559: PPUSH
41560: LD_VAR 0 1
41564: PPUSH
41565: CALL_OW 250
41569: PPUSH
41570: LD_VAR 0 1
41574: PPUSH
41575: CALL_OW 251
41579: PPUSH
41580: LD_VAR 0 2
41584: PPUSH
41585: CALL 15646 0 4
41589: PUSH
41590: LD_INT 4
41592: ARRAY
41593: ST_TO_ADDR
// end ;
41594: LD_VAR 0 3
41598: RET
// export function PlayerSeeMe ( unit ) ; begin
41599: LD_INT 0
41601: PPUSH
// result := See ( your_side , unit ) ;
41602: LD_ADDR_VAR 0 2
41606: PUSH
41607: LD_OWVAR 2
41611: PPUSH
41612: LD_VAR 0 1
41616: PPUSH
41617: CALL_OW 292
41621: ST_TO_ADDR
// end ;
41622: LD_VAR 0 2
41626: RET
// export function ReverseDir ( unit ) ; begin
41627: LD_INT 0
41629: PPUSH
// if not unit then
41630: LD_VAR 0 1
41634: NOT
41635: IFFALSE 41639
// exit ;
41637: GO 41662
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41639: LD_ADDR_VAR 0 2
41643: PUSH
41644: LD_VAR 0 1
41648: PPUSH
41649: CALL_OW 254
41653: PUSH
41654: LD_INT 3
41656: PLUS
41657: PUSH
41658: LD_INT 6
41660: MOD
41661: ST_TO_ADDR
// end ;
41662: LD_VAR 0 2
41666: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41667: LD_INT 0
41669: PPUSH
41670: PPUSH
41671: PPUSH
41672: PPUSH
41673: PPUSH
// if not hexes then
41674: LD_VAR 0 2
41678: NOT
41679: IFFALSE 41683
// exit ;
41681: GO 41831
// dist := 9999 ;
41683: LD_ADDR_VAR 0 5
41687: PUSH
41688: LD_INT 9999
41690: ST_TO_ADDR
// for i = 1 to hexes do
41691: LD_ADDR_VAR 0 4
41695: PUSH
41696: DOUBLE
41697: LD_INT 1
41699: DEC
41700: ST_TO_ADDR
41701: LD_VAR 0 2
41705: PUSH
41706: FOR_TO
41707: IFFALSE 41819
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41709: LD_VAR 0 1
41713: PPUSH
41714: LD_VAR 0 2
41718: PUSH
41719: LD_VAR 0 4
41723: ARRAY
41724: PUSH
41725: LD_INT 1
41727: ARRAY
41728: PPUSH
41729: LD_VAR 0 2
41733: PUSH
41734: LD_VAR 0 4
41738: ARRAY
41739: PUSH
41740: LD_INT 2
41742: ARRAY
41743: PPUSH
41744: CALL_OW 297
41748: PUSH
41749: LD_VAR 0 5
41753: LESS
41754: IFFALSE 41817
// begin hex := hexes [ i ] ;
41756: LD_ADDR_VAR 0 7
41760: PUSH
41761: LD_VAR 0 2
41765: PUSH
41766: LD_VAR 0 4
41770: ARRAY
41771: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41772: LD_ADDR_VAR 0 5
41776: PUSH
41777: LD_VAR 0 1
41781: PPUSH
41782: LD_VAR 0 2
41786: PUSH
41787: LD_VAR 0 4
41791: ARRAY
41792: PUSH
41793: LD_INT 1
41795: ARRAY
41796: PPUSH
41797: LD_VAR 0 2
41801: PUSH
41802: LD_VAR 0 4
41806: ARRAY
41807: PUSH
41808: LD_INT 2
41810: ARRAY
41811: PPUSH
41812: CALL_OW 297
41816: ST_TO_ADDR
// end ; end ;
41817: GO 41706
41819: POP
41820: POP
// result := hex ;
41821: LD_ADDR_VAR 0 3
41825: PUSH
41826: LD_VAR 0 7
41830: ST_TO_ADDR
// end ;
41831: LD_VAR 0 3
41835: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41836: LD_INT 0
41838: PPUSH
41839: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41840: LD_VAR 0 1
41844: NOT
41845: PUSH
41846: LD_VAR 0 1
41850: PUSH
41851: LD_INT 21
41853: PUSH
41854: LD_INT 2
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 23
41863: PUSH
41864: LD_INT 2
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PPUSH
41875: CALL_OW 69
41879: IN
41880: NOT
41881: OR
41882: IFFALSE 41886
// exit ;
41884: GO 41933
// for i = 1 to 3 do
41886: LD_ADDR_VAR 0 3
41890: PUSH
41891: DOUBLE
41892: LD_INT 1
41894: DEC
41895: ST_TO_ADDR
41896: LD_INT 3
41898: PUSH
41899: FOR_TO
41900: IFFALSE 41931
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41902: LD_VAR 0 1
41906: PPUSH
41907: CALL_OW 250
41911: PPUSH
41912: LD_VAR 0 1
41916: PPUSH
41917: CALL_OW 251
41921: PPUSH
41922: LD_INT 1
41924: PPUSH
41925: CALL_OW 453
41929: GO 41899
41931: POP
41932: POP
// end ;
41933: LD_VAR 0 2
41937: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41938: LD_INT 0
41940: PPUSH
41941: PPUSH
41942: PPUSH
41943: PPUSH
41944: PPUSH
41945: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
41946: LD_VAR 0 1
41950: NOT
41951: PUSH
41952: LD_VAR 0 2
41956: NOT
41957: OR
41958: PUSH
41959: LD_VAR 0 1
41963: PPUSH
41964: CALL_OW 314
41968: OR
41969: IFFALSE 41973
// exit ;
41971: GO 42414
// x := GetX ( enemy_unit ) ;
41973: LD_ADDR_VAR 0 7
41977: PUSH
41978: LD_VAR 0 2
41982: PPUSH
41983: CALL_OW 250
41987: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
41988: LD_ADDR_VAR 0 8
41992: PUSH
41993: LD_VAR 0 2
41997: PPUSH
41998: CALL_OW 251
42002: ST_TO_ADDR
// if not x or not y then
42003: LD_VAR 0 7
42007: NOT
42008: PUSH
42009: LD_VAR 0 8
42013: NOT
42014: OR
42015: IFFALSE 42019
// exit ;
42017: GO 42414
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42019: LD_ADDR_VAR 0 6
42023: PUSH
42024: LD_VAR 0 7
42028: PPUSH
42029: LD_INT 0
42031: PPUSH
42032: LD_INT 4
42034: PPUSH
42035: CALL_OW 272
42039: PUSH
42040: LD_VAR 0 8
42044: PPUSH
42045: LD_INT 0
42047: PPUSH
42048: LD_INT 4
42050: PPUSH
42051: CALL_OW 273
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_VAR 0 7
42064: PPUSH
42065: LD_INT 1
42067: PPUSH
42068: LD_INT 4
42070: PPUSH
42071: CALL_OW 272
42075: PUSH
42076: LD_VAR 0 8
42080: PPUSH
42081: LD_INT 1
42083: PPUSH
42084: LD_INT 4
42086: PPUSH
42087: CALL_OW 273
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_VAR 0 7
42100: PPUSH
42101: LD_INT 2
42103: PPUSH
42104: LD_INT 4
42106: PPUSH
42107: CALL_OW 272
42111: PUSH
42112: LD_VAR 0 8
42116: PPUSH
42117: LD_INT 2
42119: PPUSH
42120: LD_INT 4
42122: PPUSH
42123: CALL_OW 273
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_VAR 0 7
42136: PPUSH
42137: LD_INT 3
42139: PPUSH
42140: LD_INT 4
42142: PPUSH
42143: CALL_OW 272
42147: PUSH
42148: LD_VAR 0 8
42152: PPUSH
42153: LD_INT 3
42155: PPUSH
42156: LD_INT 4
42158: PPUSH
42159: CALL_OW 273
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_VAR 0 7
42172: PPUSH
42173: LD_INT 4
42175: PPUSH
42176: LD_INT 4
42178: PPUSH
42179: CALL_OW 272
42183: PUSH
42184: LD_VAR 0 8
42188: PPUSH
42189: LD_INT 4
42191: PPUSH
42192: LD_INT 4
42194: PPUSH
42195: CALL_OW 273
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_VAR 0 7
42208: PPUSH
42209: LD_INT 5
42211: PPUSH
42212: LD_INT 4
42214: PPUSH
42215: CALL_OW 272
42219: PUSH
42220: LD_VAR 0 8
42224: PPUSH
42225: LD_INT 5
42227: PPUSH
42228: LD_INT 4
42230: PPUSH
42231: CALL_OW 273
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: ST_TO_ADDR
// for i = tmp downto 1 do
42248: LD_ADDR_VAR 0 4
42252: PUSH
42253: DOUBLE
42254: LD_VAR 0 6
42258: INC
42259: ST_TO_ADDR
42260: LD_INT 1
42262: PUSH
42263: FOR_DOWNTO
42264: IFFALSE 42365
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42266: LD_VAR 0 6
42270: PUSH
42271: LD_VAR 0 4
42275: ARRAY
42276: PUSH
42277: LD_INT 1
42279: ARRAY
42280: PPUSH
42281: LD_VAR 0 6
42285: PUSH
42286: LD_VAR 0 4
42290: ARRAY
42291: PUSH
42292: LD_INT 2
42294: ARRAY
42295: PPUSH
42296: CALL_OW 488
42300: NOT
42301: PUSH
42302: LD_VAR 0 6
42306: PUSH
42307: LD_VAR 0 4
42311: ARRAY
42312: PUSH
42313: LD_INT 1
42315: ARRAY
42316: PPUSH
42317: LD_VAR 0 6
42321: PUSH
42322: LD_VAR 0 4
42326: ARRAY
42327: PUSH
42328: LD_INT 2
42330: ARRAY
42331: PPUSH
42332: CALL_OW 428
42336: PUSH
42337: LD_INT 0
42339: NONEQUAL
42340: OR
42341: IFFALSE 42363
// tmp := Delete ( tmp , i ) ;
42343: LD_ADDR_VAR 0 6
42347: PUSH
42348: LD_VAR 0 6
42352: PPUSH
42353: LD_VAR 0 4
42357: PPUSH
42358: CALL_OW 3
42362: ST_TO_ADDR
42363: GO 42263
42365: POP
42366: POP
// j := GetClosestHex ( unit , tmp ) ;
42367: LD_ADDR_VAR 0 5
42371: PUSH
42372: LD_VAR 0 1
42376: PPUSH
42377: LD_VAR 0 6
42381: PPUSH
42382: CALL 41667 0 2
42386: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42387: LD_VAR 0 1
42391: PPUSH
42392: LD_VAR 0 5
42396: PUSH
42397: LD_INT 1
42399: ARRAY
42400: PPUSH
42401: LD_VAR 0 5
42405: PUSH
42406: LD_INT 2
42408: ARRAY
42409: PPUSH
42410: CALL_OW 111
// end ;
42414: LD_VAR 0 3
42418: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42419: LD_INT 0
42421: PPUSH
42422: PPUSH
42423: PPUSH
// uc_side = 0 ;
42424: LD_ADDR_OWVAR 20
42428: PUSH
42429: LD_INT 0
42431: ST_TO_ADDR
// uc_nation = 0 ;
42432: LD_ADDR_OWVAR 21
42436: PUSH
42437: LD_INT 0
42439: ST_TO_ADDR
// InitHc_All ( ) ;
42440: CALL_OW 584
// InitVc ;
42444: CALL_OW 20
// if mastodonts then
42448: LD_VAR 0 6
42452: IFFALSE 42519
// for i = 1 to mastodonts do
42454: LD_ADDR_VAR 0 11
42458: PUSH
42459: DOUBLE
42460: LD_INT 1
42462: DEC
42463: ST_TO_ADDR
42464: LD_VAR 0 6
42468: PUSH
42469: FOR_TO
42470: IFFALSE 42517
// begin vc_chassis := 31 ;
42472: LD_ADDR_OWVAR 37
42476: PUSH
42477: LD_INT 31
42479: ST_TO_ADDR
// vc_control := control_rider ;
42480: LD_ADDR_OWVAR 38
42484: PUSH
42485: LD_INT 4
42487: ST_TO_ADDR
// animal := CreateVehicle ;
42488: LD_ADDR_VAR 0 12
42492: PUSH
42493: CALL_OW 45
42497: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42498: LD_VAR 0 12
42502: PPUSH
42503: LD_VAR 0 8
42507: PPUSH
42508: LD_INT 0
42510: PPUSH
42511: CALL 44707 0 3
// end ;
42515: GO 42469
42517: POP
42518: POP
// if horses then
42519: LD_VAR 0 5
42523: IFFALSE 42590
// for i = 1 to horses do
42525: LD_ADDR_VAR 0 11
42529: PUSH
42530: DOUBLE
42531: LD_INT 1
42533: DEC
42534: ST_TO_ADDR
42535: LD_VAR 0 5
42539: PUSH
42540: FOR_TO
42541: IFFALSE 42588
// begin hc_class := 21 ;
42543: LD_ADDR_OWVAR 28
42547: PUSH
42548: LD_INT 21
42550: ST_TO_ADDR
// hc_gallery :=  ;
42551: LD_ADDR_OWVAR 33
42555: PUSH
42556: LD_STRING 
42558: ST_TO_ADDR
// animal := CreateHuman ;
42559: LD_ADDR_VAR 0 12
42563: PUSH
42564: CALL_OW 44
42568: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42569: LD_VAR 0 12
42573: PPUSH
42574: LD_VAR 0 8
42578: PPUSH
42579: LD_INT 0
42581: PPUSH
42582: CALL 44707 0 3
// end ;
42586: GO 42540
42588: POP
42589: POP
// if birds then
42590: LD_VAR 0 1
42594: IFFALSE 42661
// for i = 1 to birds do
42596: LD_ADDR_VAR 0 11
42600: PUSH
42601: DOUBLE
42602: LD_INT 1
42604: DEC
42605: ST_TO_ADDR
42606: LD_VAR 0 1
42610: PUSH
42611: FOR_TO
42612: IFFALSE 42659
// begin hc_class = 18 ;
42614: LD_ADDR_OWVAR 28
42618: PUSH
42619: LD_INT 18
42621: ST_TO_ADDR
// hc_gallery =  ;
42622: LD_ADDR_OWVAR 33
42626: PUSH
42627: LD_STRING 
42629: ST_TO_ADDR
// animal := CreateHuman ;
42630: LD_ADDR_VAR 0 12
42634: PUSH
42635: CALL_OW 44
42639: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42640: LD_VAR 0 12
42644: PPUSH
42645: LD_VAR 0 8
42649: PPUSH
42650: LD_INT 0
42652: PPUSH
42653: CALL 44707 0 3
// end ;
42657: GO 42611
42659: POP
42660: POP
// if tigers then
42661: LD_VAR 0 2
42665: IFFALSE 42749
// for i = 1 to tigers do
42667: LD_ADDR_VAR 0 11
42671: PUSH
42672: DOUBLE
42673: LD_INT 1
42675: DEC
42676: ST_TO_ADDR
42677: LD_VAR 0 2
42681: PUSH
42682: FOR_TO
42683: IFFALSE 42747
// begin hc_class = class_tiger ;
42685: LD_ADDR_OWVAR 28
42689: PUSH
42690: LD_INT 14
42692: ST_TO_ADDR
// hc_gallery =  ;
42693: LD_ADDR_OWVAR 33
42697: PUSH
42698: LD_STRING 
42700: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42701: LD_ADDR_OWVAR 35
42705: PUSH
42706: LD_INT 7
42708: NEG
42709: PPUSH
42710: LD_INT 7
42712: PPUSH
42713: CALL_OW 12
42717: ST_TO_ADDR
// animal := CreateHuman ;
42718: LD_ADDR_VAR 0 12
42722: PUSH
42723: CALL_OW 44
42727: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42728: LD_VAR 0 12
42732: PPUSH
42733: LD_VAR 0 8
42737: PPUSH
42738: LD_INT 0
42740: PPUSH
42741: CALL 44707 0 3
// end ;
42745: GO 42682
42747: POP
42748: POP
// if apemans then
42749: LD_VAR 0 3
42753: IFFALSE 42876
// for i = 1 to apemans do
42755: LD_ADDR_VAR 0 11
42759: PUSH
42760: DOUBLE
42761: LD_INT 1
42763: DEC
42764: ST_TO_ADDR
42765: LD_VAR 0 3
42769: PUSH
42770: FOR_TO
42771: IFFALSE 42874
// begin hc_class = class_apeman ;
42773: LD_ADDR_OWVAR 28
42777: PUSH
42778: LD_INT 12
42780: ST_TO_ADDR
// hc_gallery =  ;
42781: LD_ADDR_OWVAR 33
42785: PUSH
42786: LD_STRING 
42788: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42789: LD_ADDR_OWVAR 35
42793: PUSH
42794: LD_INT 5
42796: NEG
42797: PPUSH
42798: LD_INT 5
42800: PPUSH
42801: CALL_OW 12
42805: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42806: LD_ADDR_OWVAR 31
42810: PUSH
42811: LD_INT 1
42813: PPUSH
42814: LD_INT 3
42816: PPUSH
42817: CALL_OW 12
42821: PUSH
42822: LD_INT 1
42824: PPUSH
42825: LD_INT 3
42827: PPUSH
42828: CALL_OW 12
42832: PUSH
42833: LD_INT 0
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: ST_TO_ADDR
// animal := CreateHuman ;
42845: LD_ADDR_VAR 0 12
42849: PUSH
42850: CALL_OW 44
42854: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42855: LD_VAR 0 12
42859: PPUSH
42860: LD_VAR 0 8
42864: PPUSH
42865: LD_INT 0
42867: PPUSH
42868: CALL 44707 0 3
// end ;
42872: GO 42770
42874: POP
42875: POP
// if enchidnas then
42876: LD_VAR 0 4
42880: IFFALSE 42947
// for i = 1 to enchidnas do
42882: LD_ADDR_VAR 0 11
42886: PUSH
42887: DOUBLE
42888: LD_INT 1
42890: DEC
42891: ST_TO_ADDR
42892: LD_VAR 0 4
42896: PUSH
42897: FOR_TO
42898: IFFALSE 42945
// begin hc_class = 13 ;
42900: LD_ADDR_OWVAR 28
42904: PUSH
42905: LD_INT 13
42907: ST_TO_ADDR
// hc_gallery =  ;
42908: LD_ADDR_OWVAR 33
42912: PUSH
42913: LD_STRING 
42915: ST_TO_ADDR
// animal := CreateHuman ;
42916: LD_ADDR_VAR 0 12
42920: PUSH
42921: CALL_OW 44
42925: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42926: LD_VAR 0 12
42930: PPUSH
42931: LD_VAR 0 8
42935: PPUSH
42936: LD_INT 0
42938: PPUSH
42939: CALL 44707 0 3
// end ;
42943: GO 42897
42945: POP
42946: POP
// if fishes then
42947: LD_VAR 0 7
42951: IFFALSE 43018
// for i = 1 to fishes do
42953: LD_ADDR_VAR 0 11
42957: PUSH
42958: DOUBLE
42959: LD_INT 1
42961: DEC
42962: ST_TO_ADDR
42963: LD_VAR 0 7
42967: PUSH
42968: FOR_TO
42969: IFFALSE 43016
// begin hc_class = 20 ;
42971: LD_ADDR_OWVAR 28
42975: PUSH
42976: LD_INT 20
42978: ST_TO_ADDR
// hc_gallery =  ;
42979: LD_ADDR_OWVAR 33
42983: PUSH
42984: LD_STRING 
42986: ST_TO_ADDR
// animal := CreateHuman ;
42987: LD_ADDR_VAR 0 12
42991: PUSH
42992: CALL_OW 44
42996: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
42997: LD_VAR 0 12
43001: PPUSH
43002: LD_VAR 0 9
43006: PPUSH
43007: LD_INT 0
43009: PPUSH
43010: CALL 44707 0 3
// end ;
43014: GO 42968
43016: POP
43017: POP
// end ;
43018: LD_VAR 0 10
43022: RET
// export function WantHeal ( sci , unit ) ; begin
43023: LD_INT 0
43025: PPUSH
// if GetTaskList ( sci ) > 0 then
43026: LD_VAR 0 1
43030: PPUSH
43031: CALL_OW 437
43035: PUSH
43036: LD_INT 0
43038: GREATER
43039: IFFALSE 43109
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43041: LD_VAR 0 1
43045: PPUSH
43046: CALL_OW 437
43050: PUSH
43051: LD_INT 1
43053: ARRAY
43054: PUSH
43055: LD_INT 1
43057: ARRAY
43058: PUSH
43059: LD_STRING l
43061: EQUAL
43062: PUSH
43063: LD_VAR 0 1
43067: PPUSH
43068: CALL_OW 437
43072: PUSH
43073: LD_INT 1
43075: ARRAY
43076: PUSH
43077: LD_INT 4
43079: ARRAY
43080: PUSH
43081: LD_VAR 0 2
43085: EQUAL
43086: AND
43087: IFFALSE 43099
// result := true else
43089: LD_ADDR_VAR 0 3
43093: PUSH
43094: LD_INT 1
43096: ST_TO_ADDR
43097: GO 43107
// result := false ;
43099: LD_ADDR_VAR 0 3
43103: PUSH
43104: LD_INT 0
43106: ST_TO_ADDR
// end else
43107: GO 43117
// result := false ;
43109: LD_ADDR_VAR 0 3
43113: PUSH
43114: LD_INT 0
43116: ST_TO_ADDR
// end ;
43117: LD_VAR 0 3
43121: RET
// export function HealTarget ( sci ) ; begin
43122: LD_INT 0
43124: PPUSH
// if not sci then
43125: LD_VAR 0 1
43129: NOT
43130: IFFALSE 43134
// exit ;
43132: GO 43199
// result := 0 ;
43134: LD_ADDR_VAR 0 2
43138: PUSH
43139: LD_INT 0
43141: ST_TO_ADDR
// if GetTaskList ( sci ) then
43142: LD_VAR 0 1
43146: PPUSH
43147: CALL_OW 437
43151: IFFALSE 43199
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43153: LD_VAR 0 1
43157: PPUSH
43158: CALL_OW 437
43162: PUSH
43163: LD_INT 1
43165: ARRAY
43166: PUSH
43167: LD_INT 1
43169: ARRAY
43170: PUSH
43171: LD_STRING l
43173: EQUAL
43174: IFFALSE 43199
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43176: LD_ADDR_VAR 0 2
43180: PUSH
43181: LD_VAR 0 1
43185: PPUSH
43186: CALL_OW 437
43190: PUSH
43191: LD_INT 1
43193: ARRAY
43194: PUSH
43195: LD_INT 4
43197: ARRAY
43198: ST_TO_ADDR
// end ;
43199: LD_VAR 0 2
43203: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43204: LD_INT 0
43206: PPUSH
43207: PPUSH
43208: PPUSH
43209: PPUSH
// if not base_units then
43210: LD_VAR 0 1
43214: NOT
43215: IFFALSE 43219
// exit ;
43217: GO 43306
// result := false ;
43219: LD_ADDR_VAR 0 2
43223: PUSH
43224: LD_INT 0
43226: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43227: LD_ADDR_VAR 0 5
43231: PUSH
43232: LD_VAR 0 1
43236: PPUSH
43237: LD_INT 21
43239: PUSH
43240: LD_INT 3
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PPUSH
43247: CALL_OW 72
43251: ST_TO_ADDR
// if not tmp then
43252: LD_VAR 0 5
43256: NOT
43257: IFFALSE 43261
// exit ;
43259: GO 43306
// for i in tmp do
43261: LD_ADDR_VAR 0 3
43265: PUSH
43266: LD_VAR 0 5
43270: PUSH
43271: FOR_IN
43272: IFFALSE 43304
// begin result := EnemyInRange ( i , 22 ) ;
43274: LD_ADDR_VAR 0 2
43278: PUSH
43279: LD_VAR 0 3
43283: PPUSH
43284: LD_INT 22
43286: PPUSH
43287: CALL 41542 0 2
43291: ST_TO_ADDR
// if result then
43292: LD_VAR 0 2
43296: IFFALSE 43302
// exit ;
43298: POP
43299: POP
43300: GO 43306
// end ;
43302: GO 43271
43304: POP
43305: POP
// end ;
43306: LD_VAR 0 2
43310: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43311: LD_INT 0
43313: PPUSH
43314: PPUSH
// if not units then
43315: LD_VAR 0 1
43319: NOT
43320: IFFALSE 43324
// exit ;
43322: GO 43394
// result := [ ] ;
43324: LD_ADDR_VAR 0 3
43328: PUSH
43329: EMPTY
43330: ST_TO_ADDR
// for i in units do
43331: LD_ADDR_VAR 0 4
43335: PUSH
43336: LD_VAR 0 1
43340: PUSH
43341: FOR_IN
43342: IFFALSE 43392
// if GetTag ( i ) = tag then
43344: LD_VAR 0 4
43348: PPUSH
43349: CALL_OW 110
43353: PUSH
43354: LD_VAR 0 2
43358: EQUAL
43359: IFFALSE 43390
// result := Insert ( result , result + 1 , i ) ;
43361: LD_ADDR_VAR 0 3
43365: PUSH
43366: LD_VAR 0 3
43370: PPUSH
43371: LD_VAR 0 3
43375: PUSH
43376: LD_INT 1
43378: PLUS
43379: PPUSH
43380: LD_VAR 0 4
43384: PPUSH
43385: CALL_OW 2
43389: ST_TO_ADDR
43390: GO 43341
43392: POP
43393: POP
// end ;
43394: LD_VAR 0 3
43398: RET
// export function IsDriver ( un ) ; begin
43399: LD_INT 0
43401: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43402: LD_ADDR_VAR 0 2
43406: PUSH
43407: LD_VAR 0 1
43411: PUSH
43412: LD_INT 55
43414: PUSH
43415: EMPTY
43416: LIST
43417: PPUSH
43418: CALL_OW 69
43422: IN
43423: ST_TO_ADDR
// end ;
43424: LD_VAR 0 2
43428: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43429: LD_INT 0
43431: PPUSH
43432: PPUSH
// list := [ ] ;
43433: LD_ADDR_VAR 0 5
43437: PUSH
43438: EMPTY
43439: ST_TO_ADDR
// case d of 0 :
43440: LD_VAR 0 3
43444: PUSH
43445: LD_INT 0
43447: DOUBLE
43448: EQUAL
43449: IFTRUE 43453
43451: GO 43586
43453: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43454: LD_ADDR_VAR 0 5
43458: PUSH
43459: LD_VAR 0 1
43463: PUSH
43464: LD_INT 4
43466: MINUS
43467: PUSH
43468: LD_VAR 0 2
43472: PUSH
43473: LD_INT 4
43475: MINUS
43476: PUSH
43477: LD_INT 2
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: LIST
43484: PUSH
43485: LD_VAR 0 1
43489: PUSH
43490: LD_INT 3
43492: MINUS
43493: PUSH
43494: LD_VAR 0 2
43498: PUSH
43499: LD_INT 1
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: LIST
43506: PUSH
43507: LD_VAR 0 1
43511: PUSH
43512: LD_INT 4
43514: PLUS
43515: PUSH
43516: LD_VAR 0 2
43520: PUSH
43521: LD_INT 4
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: LIST
43528: PUSH
43529: LD_VAR 0 1
43533: PUSH
43534: LD_INT 3
43536: PLUS
43537: PUSH
43538: LD_VAR 0 2
43542: PUSH
43543: LD_INT 3
43545: PLUS
43546: PUSH
43547: LD_INT 5
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: LIST
43554: PUSH
43555: LD_VAR 0 1
43559: PUSH
43560: LD_VAR 0 2
43564: PUSH
43565: LD_INT 4
43567: PLUS
43568: PUSH
43569: LD_INT 0
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: ST_TO_ADDR
// end ; 1 :
43584: GO 44284
43586: LD_INT 1
43588: DOUBLE
43589: EQUAL
43590: IFTRUE 43594
43592: GO 43727
43594: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43595: LD_ADDR_VAR 0 5
43599: PUSH
43600: LD_VAR 0 1
43604: PUSH
43605: LD_VAR 0 2
43609: PUSH
43610: LD_INT 4
43612: MINUS
43613: PUSH
43614: LD_INT 3
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: LIST
43621: PUSH
43622: LD_VAR 0 1
43626: PUSH
43627: LD_INT 3
43629: MINUS
43630: PUSH
43631: LD_VAR 0 2
43635: PUSH
43636: LD_INT 3
43638: MINUS
43639: PUSH
43640: LD_INT 2
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: LIST
43647: PUSH
43648: LD_VAR 0 1
43652: PUSH
43653: LD_INT 4
43655: MINUS
43656: PUSH
43657: LD_VAR 0 2
43661: PUSH
43662: LD_INT 1
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: LIST
43669: PUSH
43670: LD_VAR 0 1
43674: PUSH
43675: LD_VAR 0 2
43679: PUSH
43680: LD_INT 3
43682: PLUS
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: LIST
43691: PUSH
43692: LD_VAR 0 1
43696: PUSH
43697: LD_INT 4
43699: PLUS
43700: PUSH
43701: LD_VAR 0 2
43705: PUSH
43706: LD_INT 4
43708: PLUS
43709: PUSH
43710: LD_INT 5
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: LIST
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: ST_TO_ADDR
// end ; 2 :
43725: GO 44284
43727: LD_INT 2
43729: DOUBLE
43730: EQUAL
43731: IFTRUE 43735
43733: GO 43864
43735: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43736: LD_ADDR_VAR 0 5
43740: PUSH
43741: LD_VAR 0 1
43745: PUSH
43746: LD_VAR 0 2
43750: PUSH
43751: LD_INT 3
43753: MINUS
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: LIST
43762: PUSH
43763: LD_VAR 0 1
43767: PUSH
43768: LD_INT 4
43770: PLUS
43771: PUSH
43772: LD_VAR 0 2
43776: PUSH
43777: LD_INT 4
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: LIST
43784: PUSH
43785: LD_VAR 0 1
43789: PUSH
43790: LD_VAR 0 2
43794: PUSH
43795: LD_INT 4
43797: PLUS
43798: PUSH
43799: LD_INT 0
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: LIST
43806: PUSH
43807: LD_VAR 0 1
43811: PUSH
43812: LD_INT 3
43814: MINUS
43815: PUSH
43816: LD_VAR 0 2
43820: PUSH
43821: LD_INT 1
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: LIST
43828: PUSH
43829: LD_VAR 0 1
43833: PUSH
43834: LD_INT 4
43836: MINUS
43837: PUSH
43838: LD_VAR 0 2
43842: PUSH
43843: LD_INT 4
43845: MINUS
43846: PUSH
43847: LD_INT 2
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: LIST
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: ST_TO_ADDR
// end ; 3 :
43862: GO 44284
43864: LD_INT 3
43866: DOUBLE
43867: EQUAL
43868: IFTRUE 43872
43870: GO 44005
43872: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43873: LD_ADDR_VAR 0 5
43877: PUSH
43878: LD_VAR 0 1
43882: PUSH
43883: LD_INT 3
43885: PLUS
43886: PUSH
43887: LD_VAR 0 2
43891: PUSH
43892: LD_INT 4
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: LIST
43899: PUSH
43900: LD_VAR 0 1
43904: PUSH
43905: LD_INT 4
43907: PLUS
43908: PUSH
43909: LD_VAR 0 2
43913: PUSH
43914: LD_INT 4
43916: PLUS
43917: PUSH
43918: LD_INT 5
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: LIST
43925: PUSH
43926: LD_VAR 0 1
43930: PUSH
43931: LD_INT 4
43933: MINUS
43934: PUSH
43935: LD_VAR 0 2
43939: PUSH
43940: LD_INT 1
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: LIST
43947: PUSH
43948: LD_VAR 0 1
43952: PUSH
43953: LD_VAR 0 2
43957: PUSH
43958: LD_INT 4
43960: MINUS
43961: PUSH
43962: LD_INT 3
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: LIST
43969: PUSH
43970: LD_VAR 0 1
43974: PUSH
43975: LD_INT 3
43977: MINUS
43978: PUSH
43979: LD_VAR 0 2
43983: PUSH
43984: LD_INT 3
43986: MINUS
43987: PUSH
43988: LD_INT 2
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: LIST
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: ST_TO_ADDR
// end ; 4 :
44003: GO 44284
44005: LD_INT 4
44007: DOUBLE
44008: EQUAL
44009: IFTRUE 44013
44011: GO 44146
44013: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44014: LD_ADDR_VAR 0 5
44018: PUSH
44019: LD_VAR 0 1
44023: PUSH
44024: LD_VAR 0 2
44028: PUSH
44029: LD_INT 4
44031: PLUS
44032: PUSH
44033: LD_INT 0
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: LIST
44040: PUSH
44041: LD_VAR 0 1
44045: PUSH
44046: LD_INT 3
44048: PLUS
44049: PUSH
44050: LD_VAR 0 2
44054: PUSH
44055: LD_INT 3
44057: PLUS
44058: PUSH
44059: LD_INT 5
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: LIST
44066: PUSH
44067: LD_VAR 0 1
44071: PUSH
44072: LD_INT 4
44074: PLUS
44075: PUSH
44076: LD_VAR 0 2
44080: PUSH
44081: LD_INT 4
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: LIST
44088: PUSH
44089: LD_VAR 0 1
44093: PUSH
44094: LD_VAR 0 2
44098: PUSH
44099: LD_INT 3
44101: MINUS
44102: PUSH
44103: LD_INT 3
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: LIST
44110: PUSH
44111: LD_VAR 0 1
44115: PUSH
44116: LD_INT 4
44118: MINUS
44119: PUSH
44120: LD_VAR 0 2
44124: PUSH
44125: LD_INT 4
44127: MINUS
44128: PUSH
44129: LD_INT 2
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: LIST
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: ST_TO_ADDR
// end ; 5 :
44144: GO 44284
44146: LD_INT 5
44148: DOUBLE
44149: EQUAL
44150: IFTRUE 44154
44152: GO 44283
44154: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44155: LD_ADDR_VAR 0 5
44159: PUSH
44160: LD_VAR 0 1
44164: PUSH
44165: LD_INT 4
44167: MINUS
44168: PUSH
44169: LD_VAR 0 2
44173: PUSH
44174: LD_INT 1
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: LIST
44181: PUSH
44182: LD_VAR 0 1
44186: PUSH
44187: LD_VAR 0 2
44191: PUSH
44192: LD_INT 4
44194: MINUS
44195: PUSH
44196: LD_INT 3
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: LIST
44203: PUSH
44204: LD_VAR 0 1
44208: PUSH
44209: LD_INT 4
44211: PLUS
44212: PUSH
44213: LD_VAR 0 2
44217: PUSH
44218: LD_INT 4
44220: PLUS
44221: PUSH
44222: LD_INT 5
44224: PUSH
44225: EMPTY
44226: LIST
44227: LIST
44228: LIST
44229: PUSH
44230: LD_VAR 0 1
44234: PUSH
44235: LD_INT 3
44237: PLUS
44238: PUSH
44239: LD_VAR 0 2
44243: PUSH
44244: LD_INT 4
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: PUSH
44252: LD_VAR 0 1
44256: PUSH
44257: LD_VAR 0 2
44261: PUSH
44262: LD_INT 3
44264: PLUS
44265: PUSH
44266: LD_INT 0
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: LIST
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: ST_TO_ADDR
// end ; end ;
44281: GO 44284
44283: POP
// result := list ;
44284: LD_ADDR_VAR 0 4
44288: PUSH
44289: LD_VAR 0 5
44293: ST_TO_ADDR
// end ;
44294: LD_VAR 0 4
44298: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44299: LD_INT 0
44301: PPUSH
44302: PPUSH
44303: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44304: LD_VAR 0 1
44308: NOT
44309: PUSH
44310: LD_VAR 0 2
44314: PUSH
44315: LD_INT 1
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 3
44323: PUSH
44324: LD_INT 4
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: IN
44333: NOT
44334: OR
44335: IFFALSE 44339
// exit ;
44337: GO 44431
// tmp := [ ] ;
44339: LD_ADDR_VAR 0 5
44343: PUSH
44344: EMPTY
44345: ST_TO_ADDR
// for i in units do
44346: LD_ADDR_VAR 0 4
44350: PUSH
44351: LD_VAR 0 1
44355: PUSH
44356: FOR_IN
44357: IFFALSE 44400
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44359: LD_ADDR_VAR 0 5
44363: PUSH
44364: LD_VAR 0 5
44368: PPUSH
44369: LD_VAR 0 5
44373: PUSH
44374: LD_INT 1
44376: PLUS
44377: PPUSH
44378: LD_VAR 0 4
44382: PPUSH
44383: LD_VAR 0 2
44387: PPUSH
44388: CALL_OW 259
44392: PPUSH
44393: CALL_OW 2
44397: ST_TO_ADDR
44398: GO 44356
44400: POP
44401: POP
// if not tmp then
44402: LD_VAR 0 5
44406: NOT
44407: IFFALSE 44411
// exit ;
44409: GO 44431
// result := SortListByListDesc ( units , tmp ) ;
44411: LD_ADDR_VAR 0 3
44415: PUSH
44416: LD_VAR 0 1
44420: PPUSH
44421: LD_VAR 0 5
44425: PPUSH
44426: CALL_OW 77
44430: ST_TO_ADDR
// end ;
44431: LD_VAR 0 3
44435: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44436: LD_INT 0
44438: PPUSH
44439: PPUSH
44440: PPUSH
// result := false ;
44441: LD_ADDR_VAR 0 3
44445: PUSH
44446: LD_INT 0
44448: ST_TO_ADDR
// x := GetX ( building ) ;
44449: LD_ADDR_VAR 0 4
44453: PUSH
44454: LD_VAR 0 2
44458: PPUSH
44459: CALL_OW 250
44463: ST_TO_ADDR
// y := GetY ( building ) ;
44464: LD_ADDR_VAR 0 5
44468: PUSH
44469: LD_VAR 0 2
44473: PPUSH
44474: CALL_OW 251
44478: ST_TO_ADDR
// if not building or not x or not y then
44479: LD_VAR 0 2
44483: NOT
44484: PUSH
44485: LD_VAR 0 4
44489: NOT
44490: OR
44491: PUSH
44492: LD_VAR 0 5
44496: NOT
44497: OR
44498: IFFALSE 44502
// exit ;
44500: GO 44594
// if GetTaskList ( unit ) then
44502: LD_VAR 0 1
44506: PPUSH
44507: CALL_OW 437
44511: IFFALSE 44594
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44513: LD_STRING e
44515: PUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: CALL_OW 437
44525: PUSH
44526: LD_INT 1
44528: ARRAY
44529: PUSH
44530: LD_INT 1
44532: ARRAY
44533: EQUAL
44534: PUSH
44535: LD_VAR 0 4
44539: PUSH
44540: LD_VAR 0 1
44544: PPUSH
44545: CALL_OW 437
44549: PUSH
44550: LD_INT 1
44552: ARRAY
44553: PUSH
44554: LD_INT 2
44556: ARRAY
44557: EQUAL
44558: AND
44559: PUSH
44560: LD_VAR 0 5
44564: PUSH
44565: LD_VAR 0 1
44569: PPUSH
44570: CALL_OW 437
44574: PUSH
44575: LD_INT 1
44577: ARRAY
44578: PUSH
44579: LD_INT 3
44581: ARRAY
44582: EQUAL
44583: AND
44584: IFFALSE 44594
// result := true end ;
44586: LD_ADDR_VAR 0 3
44590: PUSH
44591: LD_INT 1
44593: ST_TO_ADDR
// end ;
44594: LD_VAR 0 3
44598: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44599: LD_INT 0
44601: PPUSH
// result := false ;
44602: LD_ADDR_VAR 0 4
44606: PUSH
44607: LD_INT 0
44609: ST_TO_ADDR
// if GetTaskList ( unit ) then
44610: LD_VAR 0 1
44614: PPUSH
44615: CALL_OW 437
44619: IFFALSE 44702
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44621: LD_STRING M
44623: PUSH
44624: LD_VAR 0 1
44628: PPUSH
44629: CALL_OW 437
44633: PUSH
44634: LD_INT 1
44636: ARRAY
44637: PUSH
44638: LD_INT 1
44640: ARRAY
44641: EQUAL
44642: PUSH
44643: LD_VAR 0 2
44647: PUSH
44648: LD_VAR 0 1
44652: PPUSH
44653: CALL_OW 437
44657: PUSH
44658: LD_INT 1
44660: ARRAY
44661: PUSH
44662: LD_INT 2
44664: ARRAY
44665: EQUAL
44666: AND
44667: PUSH
44668: LD_VAR 0 3
44672: PUSH
44673: LD_VAR 0 1
44677: PPUSH
44678: CALL_OW 437
44682: PUSH
44683: LD_INT 1
44685: ARRAY
44686: PUSH
44687: LD_INT 3
44689: ARRAY
44690: EQUAL
44691: AND
44692: IFFALSE 44702
// result := true ;
44694: LD_ADDR_VAR 0 4
44698: PUSH
44699: LD_INT 1
44701: ST_TO_ADDR
// end ; end ;
44702: LD_VAR 0 4
44706: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44707: LD_INT 0
44709: PPUSH
44710: PPUSH
44711: PPUSH
44712: PPUSH
// if not unit or not area then
44713: LD_VAR 0 1
44717: NOT
44718: PUSH
44719: LD_VAR 0 2
44723: NOT
44724: OR
44725: IFFALSE 44729
// exit ;
44727: GO 44893
// tmp := AreaToList ( area , i ) ;
44729: LD_ADDR_VAR 0 6
44733: PUSH
44734: LD_VAR 0 2
44738: PPUSH
44739: LD_VAR 0 5
44743: PPUSH
44744: CALL_OW 517
44748: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44749: LD_ADDR_VAR 0 5
44753: PUSH
44754: DOUBLE
44755: LD_INT 1
44757: DEC
44758: ST_TO_ADDR
44759: LD_VAR 0 6
44763: PUSH
44764: LD_INT 1
44766: ARRAY
44767: PUSH
44768: FOR_TO
44769: IFFALSE 44891
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44771: LD_ADDR_VAR 0 7
44775: PUSH
44776: LD_VAR 0 6
44780: PUSH
44781: LD_INT 1
44783: ARRAY
44784: PUSH
44785: LD_VAR 0 5
44789: ARRAY
44790: PUSH
44791: LD_VAR 0 6
44795: PUSH
44796: LD_INT 2
44798: ARRAY
44799: PUSH
44800: LD_VAR 0 5
44804: ARRAY
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44810: LD_VAR 0 7
44814: PUSH
44815: LD_INT 1
44817: ARRAY
44818: PPUSH
44819: LD_VAR 0 7
44823: PUSH
44824: LD_INT 2
44826: ARRAY
44827: PPUSH
44828: CALL_OW 428
44832: PUSH
44833: LD_INT 0
44835: EQUAL
44836: IFFALSE 44889
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44838: LD_VAR 0 1
44842: PPUSH
44843: LD_VAR 0 7
44847: PUSH
44848: LD_INT 1
44850: ARRAY
44851: PPUSH
44852: LD_VAR 0 7
44856: PUSH
44857: LD_INT 2
44859: ARRAY
44860: PPUSH
44861: LD_VAR 0 3
44865: PPUSH
44866: CALL_OW 48
// result := IsPlaced ( unit ) ;
44870: LD_ADDR_VAR 0 4
44874: PUSH
44875: LD_VAR 0 1
44879: PPUSH
44880: CALL_OW 305
44884: ST_TO_ADDR
// exit ;
44885: POP
44886: POP
44887: GO 44893
// end ; end ;
44889: GO 44768
44891: POP
44892: POP
// end ;
44893: LD_VAR 0 4
44897: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44898: LD_INT 0
44900: PPUSH
44901: PPUSH
44902: PPUSH
// if not side or side > 8 then
44903: LD_VAR 0 1
44907: NOT
44908: PUSH
44909: LD_VAR 0 1
44913: PUSH
44914: LD_INT 8
44916: GREATER
44917: OR
44918: IFFALSE 44922
// exit ;
44920: GO 45109
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44922: LD_ADDR_VAR 0 4
44926: PUSH
44927: LD_INT 22
44929: PUSH
44930: LD_VAR 0 1
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 21
44941: PUSH
44942: LD_INT 3
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PPUSH
44953: CALL_OW 69
44957: ST_TO_ADDR
// if not tmp then
44958: LD_VAR 0 4
44962: NOT
44963: IFFALSE 44967
// exit ;
44965: GO 45109
// enable_addtolog := true ;
44967: LD_ADDR_OWVAR 81
44971: PUSH
44972: LD_INT 1
44974: ST_TO_ADDR
// AddToLog ( [ ) ;
44975: LD_STRING [
44977: PPUSH
44978: CALL_OW 561
// for i in tmp do
44982: LD_ADDR_VAR 0 3
44986: PUSH
44987: LD_VAR 0 4
44991: PUSH
44992: FOR_IN
44993: IFFALSE 45100
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
44995: LD_STRING [
44997: PUSH
44998: LD_VAR 0 3
45002: PPUSH
45003: CALL_OW 266
45007: STR
45008: PUSH
45009: LD_STRING , 
45011: STR
45012: PUSH
45013: LD_VAR 0 3
45017: PPUSH
45018: CALL_OW 250
45022: STR
45023: PUSH
45024: LD_STRING , 
45026: STR
45027: PUSH
45028: LD_VAR 0 3
45032: PPUSH
45033: CALL_OW 251
45037: STR
45038: PUSH
45039: LD_STRING , 
45041: STR
45042: PUSH
45043: LD_VAR 0 3
45047: PPUSH
45048: CALL_OW 254
45052: STR
45053: PUSH
45054: LD_STRING , 
45056: STR
45057: PUSH
45058: LD_VAR 0 3
45062: PPUSH
45063: LD_INT 1
45065: PPUSH
45066: CALL_OW 268
45070: STR
45071: PUSH
45072: LD_STRING , 
45074: STR
45075: PUSH
45076: LD_VAR 0 3
45080: PPUSH
45081: LD_INT 2
45083: PPUSH
45084: CALL_OW 268
45088: STR
45089: PUSH
45090: LD_STRING ],
45092: STR
45093: PPUSH
45094: CALL_OW 561
// end ;
45098: GO 44992
45100: POP
45101: POP
// AddToLog ( ]; ) ;
45102: LD_STRING ];
45104: PPUSH
45105: CALL_OW 561
// end ;
45109: LD_VAR 0 2
45113: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45114: LD_INT 0
45116: PPUSH
45117: PPUSH
45118: PPUSH
45119: PPUSH
45120: PPUSH
// if not area or not rate or not max then
45121: LD_VAR 0 1
45125: NOT
45126: PUSH
45127: LD_VAR 0 2
45131: NOT
45132: OR
45133: PUSH
45134: LD_VAR 0 4
45138: NOT
45139: OR
45140: IFFALSE 45144
// exit ;
45142: GO 45336
// while 1 do
45144: LD_INT 1
45146: IFFALSE 45336
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45148: LD_ADDR_VAR 0 9
45152: PUSH
45153: LD_VAR 0 1
45157: PPUSH
45158: LD_INT 1
45160: PPUSH
45161: CALL_OW 287
45165: PUSH
45166: LD_INT 10
45168: MUL
45169: ST_TO_ADDR
// r := rate / 10 ;
45170: LD_ADDR_VAR 0 7
45174: PUSH
45175: LD_VAR 0 2
45179: PUSH
45180: LD_INT 10
45182: DIVREAL
45183: ST_TO_ADDR
// time := 1 1$00 ;
45184: LD_ADDR_VAR 0 8
45188: PUSH
45189: LD_INT 2100
45191: ST_TO_ADDR
// if amount < min then
45192: LD_VAR 0 9
45196: PUSH
45197: LD_VAR 0 3
45201: LESS
45202: IFFALSE 45220
// r := r * 2 else
45204: LD_ADDR_VAR 0 7
45208: PUSH
45209: LD_VAR 0 7
45213: PUSH
45214: LD_INT 2
45216: MUL
45217: ST_TO_ADDR
45218: GO 45246
// if amount > max then
45220: LD_VAR 0 9
45224: PUSH
45225: LD_VAR 0 4
45229: GREATER
45230: IFFALSE 45246
// r := r / 2 ;
45232: LD_ADDR_VAR 0 7
45236: PUSH
45237: LD_VAR 0 7
45241: PUSH
45242: LD_INT 2
45244: DIVREAL
45245: ST_TO_ADDR
// time := time / r ;
45246: LD_ADDR_VAR 0 8
45250: PUSH
45251: LD_VAR 0 8
45255: PUSH
45256: LD_VAR 0 7
45260: DIVREAL
45261: ST_TO_ADDR
// if time < 0 then
45262: LD_VAR 0 8
45266: PUSH
45267: LD_INT 0
45269: LESS
45270: IFFALSE 45287
// time := time * - 1 ;
45272: LD_ADDR_VAR 0 8
45276: PUSH
45277: LD_VAR 0 8
45281: PUSH
45282: LD_INT 1
45284: NEG
45285: MUL
45286: ST_TO_ADDR
// wait ( time ) ;
45287: LD_VAR 0 8
45291: PPUSH
45292: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45296: LD_INT 35
45298: PPUSH
45299: LD_INT 875
45301: PPUSH
45302: CALL_OW 12
45306: PPUSH
45307: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45311: LD_INT 1
45313: PPUSH
45314: LD_INT 5
45316: PPUSH
45317: CALL_OW 12
45321: PPUSH
45322: LD_VAR 0 1
45326: PPUSH
45327: LD_INT 1
45329: PPUSH
45330: CALL_OW 55
// end ;
45334: GO 45144
// end ;
45336: LD_VAR 0 5
45340: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45341: LD_INT 0
45343: PPUSH
45344: PPUSH
45345: PPUSH
45346: PPUSH
45347: PPUSH
45348: PPUSH
45349: PPUSH
45350: PPUSH
// if not turrets or not factories then
45351: LD_VAR 0 1
45355: NOT
45356: PUSH
45357: LD_VAR 0 2
45361: NOT
45362: OR
45363: IFFALSE 45367
// exit ;
45365: GO 45674
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45367: LD_ADDR_VAR 0 10
45371: PUSH
45372: LD_INT 5
45374: PUSH
45375: LD_INT 6
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 2
45384: PUSH
45385: LD_INT 4
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 3
45394: PUSH
45395: LD_INT 5
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 24
45409: PUSH
45410: LD_INT 25
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 23
45419: PUSH
45420: LD_INT 27
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: PUSH
45431: LD_INT 42
45433: PUSH
45434: LD_INT 43
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 44
45443: PUSH
45444: LD_INT 46
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 45
45453: PUSH
45454: LD_INT 47
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: LIST
45470: ST_TO_ADDR
// result := [ ] ;
45471: LD_ADDR_VAR 0 3
45475: PUSH
45476: EMPTY
45477: ST_TO_ADDR
// for i in turrets do
45478: LD_ADDR_VAR 0 4
45482: PUSH
45483: LD_VAR 0 1
45487: PUSH
45488: FOR_IN
45489: IFFALSE 45672
// begin nat := GetNation ( i ) ;
45491: LD_ADDR_VAR 0 7
45495: PUSH
45496: LD_VAR 0 4
45500: PPUSH
45501: CALL_OW 248
45505: ST_TO_ADDR
// weapon := 0 ;
45506: LD_ADDR_VAR 0 8
45510: PUSH
45511: LD_INT 0
45513: ST_TO_ADDR
// if not nat then
45514: LD_VAR 0 7
45518: NOT
45519: IFFALSE 45523
// continue ;
45521: GO 45488
// for j in list [ nat ] do
45523: LD_ADDR_VAR 0 5
45527: PUSH
45528: LD_VAR 0 10
45532: PUSH
45533: LD_VAR 0 7
45537: ARRAY
45538: PUSH
45539: FOR_IN
45540: IFFALSE 45581
// if GetBWeapon ( i ) = j [ 1 ] then
45542: LD_VAR 0 4
45546: PPUSH
45547: CALL_OW 269
45551: PUSH
45552: LD_VAR 0 5
45556: PUSH
45557: LD_INT 1
45559: ARRAY
45560: EQUAL
45561: IFFALSE 45579
// begin weapon := j [ 2 ] ;
45563: LD_ADDR_VAR 0 8
45567: PUSH
45568: LD_VAR 0 5
45572: PUSH
45573: LD_INT 2
45575: ARRAY
45576: ST_TO_ADDR
// break ;
45577: GO 45581
// end ;
45579: GO 45539
45581: POP
45582: POP
// if not weapon then
45583: LD_VAR 0 8
45587: NOT
45588: IFFALSE 45592
// continue ;
45590: GO 45488
// for k in factories do
45592: LD_ADDR_VAR 0 6
45596: PUSH
45597: LD_VAR 0 2
45601: PUSH
45602: FOR_IN
45603: IFFALSE 45668
// begin weapons := AvailableWeaponList ( k ) ;
45605: LD_ADDR_VAR 0 9
45609: PUSH
45610: LD_VAR 0 6
45614: PPUSH
45615: CALL_OW 478
45619: ST_TO_ADDR
// if not weapons then
45620: LD_VAR 0 9
45624: NOT
45625: IFFALSE 45629
// continue ;
45627: GO 45602
// if weapon in weapons then
45629: LD_VAR 0 8
45633: PUSH
45634: LD_VAR 0 9
45638: IN
45639: IFFALSE 45666
// begin result := [ i , weapon ] ;
45641: LD_ADDR_VAR 0 3
45645: PUSH
45646: LD_VAR 0 4
45650: PUSH
45651: LD_VAR 0 8
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: ST_TO_ADDR
// exit ;
45660: POP
45661: POP
45662: POP
45663: POP
45664: GO 45674
// end ; end ;
45666: GO 45602
45668: POP
45669: POP
// end ;
45670: GO 45488
45672: POP
45673: POP
// end ;
45674: LD_VAR 0 3
45678: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45679: LD_INT 0
45681: PPUSH
// if not side or side > 8 then
45682: LD_VAR 0 3
45686: NOT
45687: PUSH
45688: LD_VAR 0 3
45692: PUSH
45693: LD_INT 8
45695: GREATER
45696: OR
45697: IFFALSE 45701
// exit ;
45699: GO 45760
// if not range then
45701: LD_VAR 0 4
45705: NOT
45706: IFFALSE 45717
// range := - 12 ;
45708: LD_ADDR_VAR 0 4
45712: PUSH
45713: LD_INT 12
45715: NEG
45716: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45717: LD_VAR 0 1
45721: PPUSH
45722: LD_VAR 0 2
45726: PPUSH
45727: LD_VAR 0 3
45731: PPUSH
45732: LD_VAR 0 4
45736: PPUSH
45737: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45741: LD_VAR 0 1
45745: PPUSH
45746: LD_VAR 0 2
45750: PPUSH
45751: LD_VAR 0 3
45755: PPUSH
45756: CALL_OW 331
// end ;
45760: LD_VAR 0 5
45764: RET
// export function Video ( mode ) ; begin
45765: LD_INT 0
45767: PPUSH
// ingame_video = mode ;
45768: LD_ADDR_OWVAR 52
45772: PUSH
45773: LD_VAR 0 1
45777: ST_TO_ADDR
// interface_hidden = mode ;
45778: LD_ADDR_OWVAR 54
45782: PUSH
45783: LD_VAR 0 1
45787: ST_TO_ADDR
// end ;
45788: LD_VAR 0 2
45792: RET
// export function Join ( array , element ) ; begin
45793: LD_INT 0
45795: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45796: LD_ADDR_VAR 0 3
45800: PUSH
45801: LD_VAR 0 1
45805: PPUSH
45806: LD_VAR 0 1
45810: PUSH
45811: LD_INT 1
45813: PLUS
45814: PPUSH
45815: LD_VAR 0 2
45819: PPUSH
45820: CALL_OW 1
45824: ST_TO_ADDR
// end ;
45825: LD_VAR 0 3
45829: RET
// export function JoinUnion ( array , element ) ; begin
45830: LD_INT 0
45832: PPUSH
// result := array union element ;
45833: LD_ADDR_VAR 0 3
45837: PUSH
45838: LD_VAR 0 1
45842: PUSH
45843: LD_VAR 0 2
45847: UNION
45848: ST_TO_ADDR
// end ;
45849: LD_VAR 0 3
45853: RET
// export function GetBehemoths ( side ) ; begin
45854: LD_INT 0
45856: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45857: LD_ADDR_VAR 0 2
45861: PUSH
45862: LD_INT 22
45864: PUSH
45865: LD_VAR 0 1
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 31
45876: PUSH
45877: LD_INT 25
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PPUSH
45888: CALL_OW 69
45892: ST_TO_ADDR
// end ;
45893: LD_VAR 0 2
45897: RET
// export function Shuffle ( array ) ; var i , index ; begin
45898: LD_INT 0
45900: PPUSH
45901: PPUSH
45902: PPUSH
// result := [ ] ;
45903: LD_ADDR_VAR 0 2
45907: PUSH
45908: EMPTY
45909: ST_TO_ADDR
// if not array then
45910: LD_VAR 0 1
45914: NOT
45915: IFFALSE 45919
// exit ;
45917: GO 46018
// Randomize ;
45919: CALL_OW 10
// for i = array downto 1 do
45923: LD_ADDR_VAR 0 3
45927: PUSH
45928: DOUBLE
45929: LD_VAR 0 1
45933: INC
45934: ST_TO_ADDR
45935: LD_INT 1
45937: PUSH
45938: FOR_DOWNTO
45939: IFFALSE 46016
// begin index := rand ( 1 , array ) ;
45941: LD_ADDR_VAR 0 4
45945: PUSH
45946: LD_INT 1
45948: PPUSH
45949: LD_VAR 0 1
45953: PPUSH
45954: CALL_OW 12
45958: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
45959: LD_ADDR_VAR 0 2
45963: PUSH
45964: LD_VAR 0 2
45968: PPUSH
45969: LD_VAR 0 2
45973: PUSH
45974: LD_INT 1
45976: PLUS
45977: PPUSH
45978: LD_VAR 0 1
45982: PUSH
45983: LD_VAR 0 4
45987: ARRAY
45988: PPUSH
45989: CALL_OW 2
45993: ST_TO_ADDR
// array := Delete ( array , index ) ;
45994: LD_ADDR_VAR 0 1
45998: PUSH
45999: LD_VAR 0 1
46003: PPUSH
46004: LD_VAR 0 4
46008: PPUSH
46009: CALL_OW 3
46013: ST_TO_ADDR
// end ;
46014: GO 45938
46016: POP
46017: POP
// end ;
46018: LD_VAR 0 2
46022: RET
// export function GetBaseMaterials ( base ) ; begin
46023: LD_INT 0
46025: PPUSH
// result := [ 0 , 0 , 0 ] ;
46026: LD_ADDR_VAR 0 2
46030: PUSH
46031: LD_INT 0
46033: PUSH
46034: LD_INT 0
46036: PUSH
46037: LD_INT 0
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: LIST
46044: ST_TO_ADDR
// if not base then
46045: LD_VAR 0 1
46049: NOT
46050: IFFALSE 46054
// exit ;
46052: GO 46103
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46054: LD_ADDR_VAR 0 2
46058: PUSH
46059: LD_VAR 0 1
46063: PPUSH
46064: LD_INT 1
46066: PPUSH
46067: CALL_OW 275
46071: PUSH
46072: LD_VAR 0 1
46076: PPUSH
46077: LD_INT 2
46079: PPUSH
46080: CALL_OW 275
46084: PUSH
46085: LD_VAR 0 1
46089: PPUSH
46090: LD_INT 3
46092: PPUSH
46093: CALL_OW 275
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: LIST
46102: ST_TO_ADDR
// end ;
46103: LD_VAR 0 2
46107: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46108: LD_INT 0
46110: PPUSH
46111: PPUSH
// result := array ;
46112: LD_ADDR_VAR 0 3
46116: PUSH
46117: LD_VAR 0 1
46121: ST_TO_ADDR
// if size > 0 then
46122: LD_VAR 0 2
46126: PUSH
46127: LD_INT 0
46129: GREATER
46130: IFFALSE 46176
// for i := array downto size do
46132: LD_ADDR_VAR 0 4
46136: PUSH
46137: DOUBLE
46138: LD_VAR 0 1
46142: INC
46143: ST_TO_ADDR
46144: LD_VAR 0 2
46148: PUSH
46149: FOR_DOWNTO
46150: IFFALSE 46174
// result := Delete ( result , result ) ;
46152: LD_ADDR_VAR 0 3
46156: PUSH
46157: LD_VAR 0 3
46161: PPUSH
46162: LD_VAR 0 3
46166: PPUSH
46167: CALL_OW 3
46171: ST_TO_ADDR
46172: GO 46149
46174: POP
46175: POP
// end ;
46176: LD_VAR 0 3
46180: RET
// export function ComExit ( unit ) ; var tmp ; begin
46181: LD_INT 0
46183: PPUSH
46184: PPUSH
// if not IsInUnit ( unit ) then
46185: LD_VAR 0 1
46189: PPUSH
46190: CALL_OW 310
46194: NOT
46195: IFFALSE 46199
// exit ;
46197: GO 46259
// tmp := IsInUnit ( unit ) ;
46199: LD_ADDR_VAR 0 3
46203: PUSH
46204: LD_VAR 0 1
46208: PPUSH
46209: CALL_OW 310
46213: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46214: LD_VAR 0 3
46218: PPUSH
46219: CALL_OW 247
46223: PUSH
46224: LD_INT 2
46226: EQUAL
46227: IFFALSE 46240
// ComExitVehicle ( unit ) else
46229: LD_VAR 0 1
46233: PPUSH
46234: CALL_OW 121
46238: GO 46249
// ComExitBuilding ( unit ) ;
46240: LD_VAR 0 1
46244: PPUSH
46245: CALL_OW 122
// result := tmp ;
46249: LD_ADDR_VAR 0 2
46253: PUSH
46254: LD_VAR 0 3
46258: ST_TO_ADDR
// end ;
46259: LD_VAR 0 2
46263: RET
// export function ResetHc ; begin
46264: LD_INT 0
46266: PPUSH
// InitHc ;
46267: CALL_OW 19
// hc_importance := 0 ;
46271: LD_ADDR_OWVAR 32
46275: PUSH
46276: LD_INT 0
46278: ST_TO_ADDR
// end ;
46279: LD_VAR 0 1
46283: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46284: LD_INT 0
46286: PPUSH
46287: PPUSH
46288: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46289: LD_ADDR_VAR 0 6
46293: PUSH
46294: LD_VAR 0 1
46298: PUSH
46299: LD_VAR 0 3
46303: PLUS
46304: PUSH
46305: LD_INT 2
46307: DIV
46308: ST_TO_ADDR
// if _x < 0 then
46309: LD_VAR 0 6
46313: PUSH
46314: LD_INT 0
46316: LESS
46317: IFFALSE 46334
// _x := _x * - 1 ;
46319: LD_ADDR_VAR 0 6
46323: PUSH
46324: LD_VAR 0 6
46328: PUSH
46329: LD_INT 1
46331: NEG
46332: MUL
46333: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46334: LD_ADDR_VAR 0 7
46338: PUSH
46339: LD_VAR 0 2
46343: PUSH
46344: LD_VAR 0 4
46348: PLUS
46349: PUSH
46350: LD_INT 2
46352: DIV
46353: ST_TO_ADDR
// if _y < 0 then
46354: LD_VAR 0 7
46358: PUSH
46359: LD_INT 0
46361: LESS
46362: IFFALSE 46379
// _y := _y * - 1 ;
46364: LD_ADDR_VAR 0 7
46368: PUSH
46369: LD_VAR 0 7
46373: PUSH
46374: LD_INT 1
46376: NEG
46377: MUL
46378: ST_TO_ADDR
// result := [ _x , _y ] ;
46379: LD_ADDR_VAR 0 5
46383: PUSH
46384: LD_VAR 0 6
46388: PUSH
46389: LD_VAR 0 7
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: ST_TO_ADDR
// end ;
46398: LD_VAR 0 5
46402: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46403: LD_INT 0
46405: PPUSH
46406: PPUSH
46407: PPUSH
46408: PPUSH
// task := GetTaskList ( unit ) ;
46409: LD_ADDR_VAR 0 7
46413: PUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: CALL_OW 437
46423: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46424: LD_VAR 0 7
46428: NOT
46429: PUSH
46430: LD_VAR 0 1
46434: PPUSH
46435: LD_VAR 0 2
46439: PPUSH
46440: CALL_OW 308
46444: NOT
46445: AND
46446: IFFALSE 46450
// exit ;
46448: GO 46568
// if IsInArea ( unit , area ) then
46450: LD_VAR 0 1
46454: PPUSH
46455: LD_VAR 0 2
46459: PPUSH
46460: CALL_OW 308
46464: IFFALSE 46482
// begin ComMoveToArea ( unit , goAway ) ;
46466: LD_VAR 0 1
46470: PPUSH
46471: LD_VAR 0 3
46475: PPUSH
46476: CALL_OW 113
// exit ;
46480: GO 46568
// end ; if task [ 1 ] [ 1 ] <> M then
46482: LD_VAR 0 7
46486: PUSH
46487: LD_INT 1
46489: ARRAY
46490: PUSH
46491: LD_INT 1
46493: ARRAY
46494: PUSH
46495: LD_STRING M
46497: NONEQUAL
46498: IFFALSE 46502
// exit ;
46500: GO 46568
// x := task [ 1 ] [ 2 ] ;
46502: LD_ADDR_VAR 0 5
46506: PUSH
46507: LD_VAR 0 7
46511: PUSH
46512: LD_INT 1
46514: ARRAY
46515: PUSH
46516: LD_INT 2
46518: ARRAY
46519: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46520: LD_ADDR_VAR 0 6
46524: PUSH
46525: LD_VAR 0 7
46529: PUSH
46530: LD_INT 1
46532: ARRAY
46533: PUSH
46534: LD_INT 3
46536: ARRAY
46537: ST_TO_ADDR
// if InArea ( x , y , area ) then
46538: LD_VAR 0 5
46542: PPUSH
46543: LD_VAR 0 6
46547: PPUSH
46548: LD_VAR 0 2
46552: PPUSH
46553: CALL_OW 309
46557: IFFALSE 46568
// ComStop ( unit ) ;
46559: LD_VAR 0 1
46563: PPUSH
46564: CALL_OW 141
// end ;
46568: LD_VAR 0 4
46572: RET
// export function Abs ( value ) ; begin
46573: LD_INT 0
46575: PPUSH
// result := value ;
46576: LD_ADDR_VAR 0 2
46580: PUSH
46581: LD_VAR 0 1
46585: ST_TO_ADDR
// if value < 0 then
46586: LD_VAR 0 1
46590: PUSH
46591: LD_INT 0
46593: LESS
46594: IFFALSE 46611
// result := value * - 1 ;
46596: LD_ADDR_VAR 0 2
46600: PUSH
46601: LD_VAR 0 1
46605: PUSH
46606: LD_INT 1
46608: NEG
46609: MUL
46610: ST_TO_ADDR
// end ;
46611: LD_VAR 0 2
46615: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46616: LD_INT 0
46618: PPUSH
46619: PPUSH
46620: PPUSH
46621: PPUSH
46622: PPUSH
46623: PPUSH
46624: PPUSH
46625: PPUSH
// if not unit or not building then
46626: LD_VAR 0 1
46630: NOT
46631: PUSH
46632: LD_VAR 0 2
46636: NOT
46637: OR
46638: IFFALSE 46642
// exit ;
46640: GO 46868
// x := GetX ( building ) ;
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: LD_VAR 0 2
46651: PPUSH
46652: CALL_OW 250
46656: ST_TO_ADDR
// y := GetY ( building ) ;
46657: LD_ADDR_VAR 0 6
46661: PUSH
46662: LD_VAR 0 2
46666: PPUSH
46667: CALL_OW 251
46671: ST_TO_ADDR
// d := GetDir ( building ) ;
46672: LD_ADDR_VAR 0 8
46676: PUSH
46677: LD_VAR 0 2
46681: PPUSH
46682: CALL_OW 254
46686: ST_TO_ADDR
// r := 4 ;
46687: LD_ADDR_VAR 0 9
46691: PUSH
46692: LD_INT 4
46694: ST_TO_ADDR
// for i := 1 to 5 do
46695: LD_ADDR_VAR 0 10
46699: PUSH
46700: DOUBLE
46701: LD_INT 1
46703: DEC
46704: ST_TO_ADDR
46705: LD_INT 5
46707: PUSH
46708: FOR_TO
46709: IFFALSE 46866
// begin _x := ShiftX ( x , d , r + i ) ;
46711: LD_ADDR_VAR 0 5
46715: PUSH
46716: LD_VAR 0 4
46720: PPUSH
46721: LD_VAR 0 8
46725: PPUSH
46726: LD_VAR 0 9
46730: PUSH
46731: LD_VAR 0 10
46735: PLUS
46736: PPUSH
46737: CALL_OW 272
46741: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46742: LD_ADDR_VAR 0 7
46746: PUSH
46747: LD_VAR 0 6
46751: PPUSH
46752: LD_VAR 0 8
46756: PPUSH
46757: LD_VAR 0 9
46761: PUSH
46762: LD_VAR 0 10
46766: PLUS
46767: PPUSH
46768: CALL_OW 273
46772: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46773: LD_VAR 0 5
46777: PPUSH
46778: LD_VAR 0 7
46782: PPUSH
46783: CALL_OW 488
46787: PUSH
46788: LD_VAR 0 5
46792: PPUSH
46793: LD_VAR 0 7
46797: PPUSH
46798: CALL_OW 428
46802: PPUSH
46803: CALL_OW 247
46807: PUSH
46808: LD_INT 3
46810: PUSH
46811: LD_INT 2
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: IN
46818: NOT
46819: AND
46820: IFFALSE 46864
// begin ComMoveXY ( unit , _x , _y ) ;
46822: LD_VAR 0 1
46826: PPUSH
46827: LD_VAR 0 5
46831: PPUSH
46832: LD_VAR 0 7
46836: PPUSH
46837: CALL_OW 111
// result := [ _x , _y ] ;
46841: LD_ADDR_VAR 0 3
46845: PUSH
46846: LD_VAR 0 5
46850: PUSH
46851: LD_VAR 0 7
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: ST_TO_ADDR
// exit ;
46860: POP
46861: POP
46862: GO 46868
// end ; end ;
46864: GO 46708
46866: POP
46867: POP
// end ;
46868: LD_VAR 0 3
46872: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46873: LD_INT 0
46875: PPUSH
46876: PPUSH
46877: PPUSH
// result := 0 ;
46878: LD_ADDR_VAR 0 3
46882: PUSH
46883: LD_INT 0
46885: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46886: LD_VAR 0 1
46890: PUSH
46891: LD_INT 0
46893: LESS
46894: PUSH
46895: LD_VAR 0 1
46899: PUSH
46900: LD_INT 8
46902: GREATER
46903: OR
46904: PUSH
46905: LD_VAR 0 2
46909: PUSH
46910: LD_INT 0
46912: LESS
46913: OR
46914: PUSH
46915: LD_VAR 0 2
46919: PUSH
46920: LD_INT 8
46922: GREATER
46923: OR
46924: IFFALSE 46928
// exit ;
46926: GO 47003
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46928: LD_ADDR_VAR 0 4
46932: PUSH
46933: LD_INT 22
46935: PUSH
46936: LD_VAR 0 2
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PPUSH
46945: CALL_OW 69
46949: PUSH
46950: FOR_IN
46951: IFFALSE 47001
// begin un := UnitShoot ( i ) ;
46953: LD_ADDR_VAR 0 5
46957: PUSH
46958: LD_VAR 0 4
46962: PPUSH
46963: CALL_OW 504
46967: ST_TO_ADDR
// if GetSide ( un ) = side1 then
46968: LD_VAR 0 5
46972: PPUSH
46973: CALL_OW 255
46977: PUSH
46978: LD_VAR 0 1
46982: EQUAL
46983: IFFALSE 46999
// begin result := un ;
46985: LD_ADDR_VAR 0 3
46989: PUSH
46990: LD_VAR 0 5
46994: ST_TO_ADDR
// exit ;
46995: POP
46996: POP
46997: GO 47003
// end ; end ;
46999: GO 46950
47001: POP
47002: POP
// end ; end_of_file
47003: LD_VAR 0 3
47007: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
47008: LD_INT 0
47010: PPUSH
47011: PPUSH
// skirmish := false ;
47012: LD_ADDR_EXP 40
47016: PUSH
47017: LD_INT 0
47019: ST_TO_ADDR
// debug_mc := false ;
47020: LD_ADDR_EXP 41
47024: PUSH
47025: LD_INT 0
47027: ST_TO_ADDR
// mc_bases := [ ] ;
47028: LD_ADDR_EXP 42
47032: PUSH
47033: EMPTY
47034: ST_TO_ADDR
// mc_sides := [ ] ;
47035: LD_ADDR_EXP 68
47039: PUSH
47040: EMPTY
47041: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47042: LD_ADDR_EXP 43
47046: PUSH
47047: EMPTY
47048: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47049: LD_ADDR_EXP 44
47053: PUSH
47054: EMPTY
47055: ST_TO_ADDR
// mc_need_heal := [ ] ;
47056: LD_ADDR_EXP 45
47060: PUSH
47061: EMPTY
47062: ST_TO_ADDR
// mc_healers := [ ] ;
47063: LD_ADDR_EXP 46
47067: PUSH
47068: EMPTY
47069: ST_TO_ADDR
// mc_build_list := [ ] ;
47070: LD_ADDR_EXP 47
47074: PUSH
47075: EMPTY
47076: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47077: LD_ADDR_EXP 74
47081: PUSH
47082: EMPTY
47083: ST_TO_ADDR
// mc_builders := [ ] ;
47084: LD_ADDR_EXP 48
47088: PUSH
47089: EMPTY
47090: ST_TO_ADDR
// mc_construct_list := [ ] ;
47091: LD_ADDR_EXP 49
47095: PUSH
47096: EMPTY
47097: ST_TO_ADDR
// mc_turret_list := [ ] ;
47098: LD_ADDR_EXP 50
47102: PUSH
47103: EMPTY
47104: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47105: LD_ADDR_EXP 51
47109: PUSH
47110: EMPTY
47111: ST_TO_ADDR
// mc_miners := [ ] ;
47112: LD_ADDR_EXP 56
47116: PUSH
47117: EMPTY
47118: ST_TO_ADDR
// mc_mines := [ ] ;
47119: LD_ADDR_EXP 55
47123: PUSH
47124: EMPTY
47125: ST_TO_ADDR
// mc_minefields := [ ] ;
47126: LD_ADDR_EXP 57
47130: PUSH
47131: EMPTY
47132: ST_TO_ADDR
// mc_crates := [ ] ;
47133: LD_ADDR_EXP 58
47137: PUSH
47138: EMPTY
47139: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47140: LD_ADDR_EXP 59
47144: PUSH
47145: EMPTY
47146: ST_TO_ADDR
// mc_crates_area := [ ] ;
47147: LD_ADDR_EXP 60
47151: PUSH
47152: EMPTY
47153: ST_TO_ADDR
// mc_vehicles := [ ] ;
47154: LD_ADDR_EXP 61
47158: PUSH
47159: EMPTY
47160: ST_TO_ADDR
// mc_attack := [ ] ;
47161: LD_ADDR_EXP 62
47165: PUSH
47166: EMPTY
47167: ST_TO_ADDR
// mc_produce := [ ] ;
47168: LD_ADDR_EXP 63
47172: PUSH
47173: EMPTY
47174: ST_TO_ADDR
// mc_defender := [ ] ;
47175: LD_ADDR_EXP 64
47179: PUSH
47180: EMPTY
47181: ST_TO_ADDR
// mc_parking := [ ] ;
47182: LD_ADDR_EXP 66
47186: PUSH
47187: EMPTY
47188: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47189: LD_ADDR_EXP 52
47193: PUSH
47194: EMPTY
47195: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47196: LD_ADDR_EXP 54
47200: PUSH
47201: EMPTY
47202: ST_TO_ADDR
// mc_scan := [ ] ;
47203: LD_ADDR_EXP 65
47207: PUSH
47208: EMPTY
47209: ST_TO_ADDR
// mc_scan_area := [ ] ;
47210: LD_ADDR_EXP 67
47214: PUSH
47215: EMPTY
47216: ST_TO_ADDR
// mc_tech := [ ] ;
47217: LD_ADDR_EXP 69
47221: PUSH
47222: EMPTY
47223: ST_TO_ADDR
// mc_class := [ ] ;
47224: LD_ADDR_EXP 83
47228: PUSH
47229: EMPTY
47230: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47231: LD_ADDR_EXP 84
47235: PUSH
47236: EMPTY
47237: ST_TO_ADDR
// end ;
47238: LD_VAR 0 1
47242: RET
// export function MC_Kill ( base ) ; begin
47243: LD_INT 0
47245: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47246: LD_ADDR_EXP 42
47250: PUSH
47251: LD_EXP 42
47255: PPUSH
47256: LD_VAR 0 1
47260: PPUSH
47261: EMPTY
47262: PPUSH
47263: CALL_OW 1
47267: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47268: LD_ADDR_EXP 43
47272: PUSH
47273: LD_EXP 43
47277: PPUSH
47278: LD_VAR 0 1
47282: PPUSH
47283: EMPTY
47284: PPUSH
47285: CALL_OW 1
47289: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47290: LD_ADDR_EXP 44
47294: PUSH
47295: LD_EXP 44
47299: PPUSH
47300: LD_VAR 0 1
47304: PPUSH
47305: EMPTY
47306: PPUSH
47307: CALL_OW 1
47311: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47312: LD_ADDR_EXP 45
47316: PUSH
47317: LD_EXP 45
47321: PPUSH
47322: LD_VAR 0 1
47326: PPUSH
47327: EMPTY
47328: PPUSH
47329: CALL_OW 1
47333: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47334: LD_ADDR_EXP 46
47338: PUSH
47339: LD_EXP 46
47343: PPUSH
47344: LD_VAR 0 1
47348: PPUSH
47349: EMPTY
47350: PPUSH
47351: CALL_OW 1
47355: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47356: LD_ADDR_EXP 47
47360: PUSH
47361: LD_EXP 47
47365: PPUSH
47366: LD_VAR 0 1
47370: PPUSH
47371: EMPTY
47372: PPUSH
47373: CALL_OW 1
47377: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47378: LD_ADDR_EXP 48
47382: PUSH
47383: LD_EXP 48
47387: PPUSH
47388: LD_VAR 0 1
47392: PPUSH
47393: EMPTY
47394: PPUSH
47395: CALL_OW 1
47399: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47400: LD_ADDR_EXP 49
47404: PUSH
47405: LD_EXP 49
47409: PPUSH
47410: LD_VAR 0 1
47414: PPUSH
47415: EMPTY
47416: PPUSH
47417: CALL_OW 1
47421: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47422: LD_ADDR_EXP 50
47426: PUSH
47427: LD_EXP 50
47431: PPUSH
47432: LD_VAR 0 1
47436: PPUSH
47437: EMPTY
47438: PPUSH
47439: CALL_OW 1
47443: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47444: LD_ADDR_EXP 51
47448: PUSH
47449: LD_EXP 51
47453: PPUSH
47454: LD_VAR 0 1
47458: PPUSH
47459: EMPTY
47460: PPUSH
47461: CALL_OW 1
47465: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47466: LD_ADDR_EXP 52
47470: PUSH
47471: LD_EXP 52
47475: PPUSH
47476: LD_VAR 0 1
47480: PPUSH
47481: EMPTY
47482: PPUSH
47483: CALL_OW 1
47487: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47488: LD_ADDR_EXP 53
47492: PUSH
47493: LD_EXP 53
47497: PPUSH
47498: LD_VAR 0 1
47502: PPUSH
47503: LD_INT 0
47505: PPUSH
47506: CALL_OW 1
47510: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47511: LD_ADDR_EXP 54
47515: PUSH
47516: LD_EXP 54
47520: PPUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: EMPTY
47527: PPUSH
47528: CALL_OW 1
47532: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47533: LD_ADDR_EXP 55
47537: PUSH
47538: LD_EXP 55
47542: PPUSH
47543: LD_VAR 0 1
47547: PPUSH
47548: EMPTY
47549: PPUSH
47550: CALL_OW 1
47554: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47555: LD_ADDR_EXP 56
47559: PUSH
47560: LD_EXP 56
47564: PPUSH
47565: LD_VAR 0 1
47569: PPUSH
47570: EMPTY
47571: PPUSH
47572: CALL_OW 1
47576: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47577: LD_ADDR_EXP 57
47581: PUSH
47582: LD_EXP 57
47586: PPUSH
47587: LD_VAR 0 1
47591: PPUSH
47592: EMPTY
47593: PPUSH
47594: CALL_OW 1
47598: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47599: LD_ADDR_EXP 58
47603: PUSH
47604: LD_EXP 58
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: EMPTY
47615: PPUSH
47616: CALL_OW 1
47620: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47621: LD_ADDR_EXP 59
47625: PUSH
47626: LD_EXP 59
47630: PPUSH
47631: LD_VAR 0 1
47635: PPUSH
47636: EMPTY
47637: PPUSH
47638: CALL_OW 1
47642: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47643: LD_ADDR_EXP 60
47647: PUSH
47648: LD_EXP 60
47652: PPUSH
47653: LD_VAR 0 1
47657: PPUSH
47658: EMPTY
47659: PPUSH
47660: CALL_OW 1
47664: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47665: LD_ADDR_EXP 61
47669: PUSH
47670: LD_EXP 61
47674: PPUSH
47675: LD_VAR 0 1
47679: PPUSH
47680: EMPTY
47681: PPUSH
47682: CALL_OW 1
47686: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47687: LD_ADDR_EXP 62
47691: PUSH
47692: LD_EXP 62
47696: PPUSH
47697: LD_VAR 0 1
47701: PPUSH
47702: EMPTY
47703: PPUSH
47704: CALL_OW 1
47708: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47709: LD_ADDR_EXP 63
47713: PUSH
47714: LD_EXP 63
47718: PPUSH
47719: LD_VAR 0 1
47723: PPUSH
47724: EMPTY
47725: PPUSH
47726: CALL_OW 1
47730: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47731: LD_ADDR_EXP 64
47735: PUSH
47736: LD_EXP 64
47740: PPUSH
47741: LD_VAR 0 1
47745: PPUSH
47746: EMPTY
47747: PPUSH
47748: CALL_OW 1
47752: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47753: LD_ADDR_EXP 65
47757: PUSH
47758: LD_EXP 65
47762: PPUSH
47763: LD_VAR 0 1
47767: PPUSH
47768: EMPTY
47769: PPUSH
47770: CALL_OW 1
47774: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47775: LD_ADDR_EXP 66
47779: PUSH
47780: LD_EXP 66
47784: PPUSH
47785: LD_VAR 0 1
47789: PPUSH
47790: EMPTY
47791: PPUSH
47792: CALL_OW 1
47796: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47797: LD_ADDR_EXP 67
47801: PUSH
47802: LD_EXP 67
47806: PPUSH
47807: LD_VAR 0 1
47811: PPUSH
47812: EMPTY
47813: PPUSH
47814: CALL_OW 1
47818: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47819: LD_ADDR_EXP 69
47823: PUSH
47824: LD_EXP 69
47828: PPUSH
47829: LD_VAR 0 1
47833: PPUSH
47834: EMPTY
47835: PPUSH
47836: CALL_OW 1
47840: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47841: LD_ADDR_EXP 71
47845: PUSH
47846: LD_EXP 71
47850: PPUSH
47851: LD_VAR 0 1
47855: PPUSH
47856: EMPTY
47857: PPUSH
47858: CALL_OW 1
47862: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47863: LD_ADDR_EXP 72
47867: PUSH
47868: LD_EXP 72
47872: PPUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: EMPTY
47879: PPUSH
47880: CALL_OW 1
47884: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
47885: LD_ADDR_EXP 73
47889: PUSH
47890: LD_EXP 73
47894: PPUSH
47895: LD_VAR 0 1
47899: PPUSH
47900: EMPTY
47901: PPUSH
47902: CALL_OW 1
47906: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
47907: LD_ADDR_EXP 74
47911: PUSH
47912: LD_EXP 74
47916: PPUSH
47917: LD_VAR 0 1
47921: PPUSH
47922: EMPTY
47923: PPUSH
47924: CALL_OW 1
47928: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
47929: LD_ADDR_EXP 75
47933: PUSH
47934: LD_EXP 75
47938: PPUSH
47939: LD_VAR 0 1
47943: PPUSH
47944: EMPTY
47945: PPUSH
47946: CALL_OW 1
47950: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
47951: LD_ADDR_EXP 76
47955: PUSH
47956: LD_EXP 76
47960: PPUSH
47961: LD_VAR 0 1
47965: PPUSH
47966: EMPTY
47967: PPUSH
47968: CALL_OW 1
47972: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
47973: LD_ADDR_EXP 77
47977: PUSH
47978: LD_EXP 77
47982: PPUSH
47983: LD_VAR 0 1
47987: PPUSH
47988: EMPTY
47989: PPUSH
47990: CALL_OW 1
47994: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
47995: LD_ADDR_EXP 78
47999: PUSH
48000: LD_EXP 78
48004: PPUSH
48005: LD_VAR 0 1
48009: PPUSH
48010: EMPTY
48011: PPUSH
48012: CALL_OW 1
48016: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48017: LD_ADDR_EXP 79
48021: PUSH
48022: LD_EXP 79
48026: PPUSH
48027: LD_VAR 0 1
48031: PPUSH
48032: EMPTY
48033: PPUSH
48034: CALL_OW 1
48038: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48039: LD_ADDR_EXP 80
48043: PUSH
48044: LD_EXP 80
48048: PPUSH
48049: LD_VAR 0 1
48053: PPUSH
48054: EMPTY
48055: PPUSH
48056: CALL_OW 1
48060: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48061: LD_ADDR_EXP 81
48065: PUSH
48066: LD_EXP 81
48070: PPUSH
48071: LD_VAR 0 1
48075: PPUSH
48076: EMPTY
48077: PPUSH
48078: CALL_OW 1
48082: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48083: LD_ADDR_EXP 82
48087: PUSH
48088: LD_EXP 82
48092: PPUSH
48093: LD_VAR 0 1
48097: PPUSH
48098: EMPTY
48099: PPUSH
48100: CALL_OW 1
48104: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48105: LD_ADDR_EXP 83
48109: PUSH
48110: LD_EXP 83
48114: PPUSH
48115: LD_VAR 0 1
48119: PPUSH
48120: EMPTY
48121: PPUSH
48122: CALL_OW 1
48126: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48127: LD_ADDR_EXP 84
48131: PUSH
48132: LD_EXP 84
48136: PPUSH
48137: LD_VAR 0 1
48141: PPUSH
48142: LD_INT 0
48144: PPUSH
48145: CALL_OW 1
48149: ST_TO_ADDR
// end ;
48150: LD_VAR 0 2
48154: RET
// export function MC_Add ( side , units ) ; var base ; begin
48155: LD_INT 0
48157: PPUSH
48158: PPUSH
// base := mc_bases + 1 ;
48159: LD_ADDR_VAR 0 4
48163: PUSH
48164: LD_EXP 42
48168: PUSH
48169: LD_INT 1
48171: PLUS
48172: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48173: LD_ADDR_EXP 68
48177: PUSH
48178: LD_EXP 68
48182: PPUSH
48183: LD_VAR 0 4
48187: PPUSH
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 1
48197: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48198: LD_ADDR_EXP 42
48202: PUSH
48203: LD_EXP 42
48207: PPUSH
48208: LD_VAR 0 4
48212: PPUSH
48213: LD_VAR 0 2
48217: PPUSH
48218: CALL_OW 1
48222: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48223: LD_ADDR_EXP 43
48227: PUSH
48228: LD_EXP 43
48232: PPUSH
48233: LD_VAR 0 4
48237: PPUSH
48238: EMPTY
48239: PPUSH
48240: CALL_OW 1
48244: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48245: LD_ADDR_EXP 44
48249: PUSH
48250: LD_EXP 44
48254: PPUSH
48255: LD_VAR 0 4
48259: PPUSH
48260: EMPTY
48261: PPUSH
48262: CALL_OW 1
48266: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48267: LD_ADDR_EXP 45
48271: PUSH
48272: LD_EXP 45
48276: PPUSH
48277: LD_VAR 0 4
48281: PPUSH
48282: EMPTY
48283: PPUSH
48284: CALL_OW 1
48288: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48289: LD_ADDR_EXP 46
48293: PUSH
48294: LD_EXP 46
48298: PPUSH
48299: LD_VAR 0 4
48303: PPUSH
48304: EMPTY
48305: PPUSH
48306: CALL_OW 1
48310: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48311: LD_ADDR_EXP 47
48315: PUSH
48316: LD_EXP 47
48320: PPUSH
48321: LD_VAR 0 4
48325: PPUSH
48326: EMPTY
48327: PPUSH
48328: CALL_OW 1
48332: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48333: LD_ADDR_EXP 48
48337: PUSH
48338: LD_EXP 48
48342: PPUSH
48343: LD_VAR 0 4
48347: PPUSH
48348: EMPTY
48349: PPUSH
48350: CALL_OW 1
48354: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48355: LD_ADDR_EXP 49
48359: PUSH
48360: LD_EXP 49
48364: PPUSH
48365: LD_VAR 0 4
48369: PPUSH
48370: EMPTY
48371: PPUSH
48372: CALL_OW 1
48376: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48377: LD_ADDR_EXP 50
48381: PUSH
48382: LD_EXP 50
48386: PPUSH
48387: LD_VAR 0 4
48391: PPUSH
48392: EMPTY
48393: PPUSH
48394: CALL_OW 1
48398: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48399: LD_ADDR_EXP 51
48403: PUSH
48404: LD_EXP 51
48408: PPUSH
48409: LD_VAR 0 4
48413: PPUSH
48414: EMPTY
48415: PPUSH
48416: CALL_OW 1
48420: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48421: LD_ADDR_EXP 52
48425: PUSH
48426: LD_EXP 52
48430: PPUSH
48431: LD_VAR 0 4
48435: PPUSH
48436: EMPTY
48437: PPUSH
48438: CALL_OW 1
48442: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48443: LD_ADDR_EXP 53
48447: PUSH
48448: LD_EXP 53
48452: PPUSH
48453: LD_VAR 0 4
48457: PPUSH
48458: LD_INT 0
48460: PPUSH
48461: CALL_OW 1
48465: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48466: LD_ADDR_EXP 54
48470: PUSH
48471: LD_EXP 54
48475: PPUSH
48476: LD_VAR 0 4
48480: PPUSH
48481: EMPTY
48482: PPUSH
48483: CALL_OW 1
48487: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48488: LD_ADDR_EXP 55
48492: PUSH
48493: LD_EXP 55
48497: PPUSH
48498: LD_VAR 0 4
48502: PPUSH
48503: EMPTY
48504: PPUSH
48505: CALL_OW 1
48509: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48510: LD_ADDR_EXP 56
48514: PUSH
48515: LD_EXP 56
48519: PPUSH
48520: LD_VAR 0 4
48524: PPUSH
48525: EMPTY
48526: PPUSH
48527: CALL_OW 1
48531: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48532: LD_ADDR_EXP 57
48536: PUSH
48537: LD_EXP 57
48541: PPUSH
48542: LD_VAR 0 4
48546: PPUSH
48547: EMPTY
48548: PPUSH
48549: CALL_OW 1
48553: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48554: LD_ADDR_EXP 58
48558: PUSH
48559: LD_EXP 58
48563: PPUSH
48564: LD_VAR 0 4
48568: PPUSH
48569: EMPTY
48570: PPUSH
48571: CALL_OW 1
48575: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48576: LD_ADDR_EXP 59
48580: PUSH
48581: LD_EXP 59
48585: PPUSH
48586: LD_VAR 0 4
48590: PPUSH
48591: EMPTY
48592: PPUSH
48593: CALL_OW 1
48597: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48598: LD_ADDR_EXP 60
48602: PUSH
48603: LD_EXP 60
48607: PPUSH
48608: LD_VAR 0 4
48612: PPUSH
48613: EMPTY
48614: PPUSH
48615: CALL_OW 1
48619: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48620: LD_ADDR_EXP 61
48624: PUSH
48625: LD_EXP 61
48629: PPUSH
48630: LD_VAR 0 4
48634: PPUSH
48635: EMPTY
48636: PPUSH
48637: CALL_OW 1
48641: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48642: LD_ADDR_EXP 62
48646: PUSH
48647: LD_EXP 62
48651: PPUSH
48652: LD_VAR 0 4
48656: PPUSH
48657: EMPTY
48658: PPUSH
48659: CALL_OW 1
48663: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48664: LD_ADDR_EXP 63
48668: PUSH
48669: LD_EXP 63
48673: PPUSH
48674: LD_VAR 0 4
48678: PPUSH
48679: EMPTY
48680: PPUSH
48681: CALL_OW 1
48685: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48686: LD_ADDR_EXP 64
48690: PUSH
48691: LD_EXP 64
48695: PPUSH
48696: LD_VAR 0 4
48700: PPUSH
48701: EMPTY
48702: PPUSH
48703: CALL_OW 1
48707: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48708: LD_ADDR_EXP 65
48712: PUSH
48713: LD_EXP 65
48717: PPUSH
48718: LD_VAR 0 4
48722: PPUSH
48723: EMPTY
48724: PPUSH
48725: CALL_OW 1
48729: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48730: LD_ADDR_EXP 66
48734: PUSH
48735: LD_EXP 66
48739: PPUSH
48740: LD_VAR 0 4
48744: PPUSH
48745: EMPTY
48746: PPUSH
48747: CALL_OW 1
48751: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48752: LD_ADDR_EXP 67
48756: PUSH
48757: LD_EXP 67
48761: PPUSH
48762: LD_VAR 0 4
48766: PPUSH
48767: EMPTY
48768: PPUSH
48769: CALL_OW 1
48773: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48774: LD_ADDR_EXP 69
48778: PUSH
48779: LD_EXP 69
48783: PPUSH
48784: LD_VAR 0 4
48788: PPUSH
48789: EMPTY
48790: PPUSH
48791: CALL_OW 1
48795: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48796: LD_ADDR_EXP 71
48800: PUSH
48801: LD_EXP 71
48805: PPUSH
48806: LD_VAR 0 4
48810: PPUSH
48811: EMPTY
48812: PPUSH
48813: CALL_OW 1
48817: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48818: LD_ADDR_EXP 72
48822: PUSH
48823: LD_EXP 72
48827: PPUSH
48828: LD_VAR 0 4
48832: PPUSH
48833: EMPTY
48834: PPUSH
48835: CALL_OW 1
48839: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48840: LD_ADDR_EXP 73
48844: PUSH
48845: LD_EXP 73
48849: PPUSH
48850: LD_VAR 0 4
48854: PPUSH
48855: EMPTY
48856: PPUSH
48857: CALL_OW 1
48861: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48862: LD_ADDR_EXP 74
48866: PUSH
48867: LD_EXP 74
48871: PPUSH
48872: LD_VAR 0 4
48876: PPUSH
48877: EMPTY
48878: PPUSH
48879: CALL_OW 1
48883: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48884: LD_ADDR_EXP 75
48888: PUSH
48889: LD_EXP 75
48893: PPUSH
48894: LD_VAR 0 4
48898: PPUSH
48899: EMPTY
48900: PPUSH
48901: CALL_OW 1
48905: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48906: LD_ADDR_EXP 76
48910: PUSH
48911: LD_EXP 76
48915: PPUSH
48916: LD_VAR 0 4
48920: PPUSH
48921: EMPTY
48922: PPUSH
48923: CALL_OW 1
48927: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48928: LD_ADDR_EXP 77
48932: PUSH
48933: LD_EXP 77
48937: PPUSH
48938: LD_VAR 0 4
48942: PPUSH
48943: EMPTY
48944: PPUSH
48945: CALL_OW 1
48949: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48950: LD_ADDR_EXP 78
48954: PUSH
48955: LD_EXP 78
48959: PPUSH
48960: LD_VAR 0 4
48964: PPUSH
48965: EMPTY
48966: PPUSH
48967: CALL_OW 1
48971: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48972: LD_ADDR_EXP 79
48976: PUSH
48977: LD_EXP 79
48981: PPUSH
48982: LD_VAR 0 4
48986: PPUSH
48987: EMPTY
48988: PPUSH
48989: CALL_OW 1
48993: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48994: LD_ADDR_EXP 80
48998: PUSH
48999: LD_EXP 80
49003: PPUSH
49004: LD_VAR 0 4
49008: PPUSH
49009: EMPTY
49010: PPUSH
49011: CALL_OW 1
49015: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49016: LD_ADDR_EXP 81
49020: PUSH
49021: LD_EXP 81
49025: PPUSH
49026: LD_VAR 0 4
49030: PPUSH
49031: EMPTY
49032: PPUSH
49033: CALL_OW 1
49037: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49038: LD_ADDR_EXP 82
49042: PUSH
49043: LD_EXP 82
49047: PPUSH
49048: LD_VAR 0 4
49052: PPUSH
49053: EMPTY
49054: PPUSH
49055: CALL_OW 1
49059: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49060: LD_ADDR_EXP 83
49064: PUSH
49065: LD_EXP 83
49069: PPUSH
49070: LD_VAR 0 4
49074: PPUSH
49075: EMPTY
49076: PPUSH
49077: CALL_OW 1
49081: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49082: LD_ADDR_EXP 84
49086: PUSH
49087: LD_EXP 84
49091: PPUSH
49092: LD_VAR 0 4
49096: PPUSH
49097: LD_INT 0
49099: PPUSH
49100: CALL_OW 1
49104: ST_TO_ADDR
// result := base ;
49105: LD_ADDR_VAR 0 3
49109: PUSH
49110: LD_VAR 0 4
49114: ST_TO_ADDR
// end ;
49115: LD_VAR 0 3
49119: RET
// export function MC_Start ( ) ; var i ; begin
49120: LD_INT 0
49122: PPUSH
49123: PPUSH
// for i = 1 to mc_bases do
49124: LD_ADDR_VAR 0 2
49128: PUSH
49129: DOUBLE
49130: LD_INT 1
49132: DEC
49133: ST_TO_ADDR
49134: LD_EXP 42
49138: PUSH
49139: FOR_TO
49140: IFFALSE 50217
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49142: LD_ADDR_EXP 42
49146: PUSH
49147: LD_EXP 42
49151: PPUSH
49152: LD_VAR 0 2
49156: PPUSH
49157: LD_EXP 42
49161: PUSH
49162: LD_VAR 0 2
49166: ARRAY
49167: PUSH
49168: LD_INT 0
49170: DIFF
49171: PPUSH
49172: CALL_OW 1
49176: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49177: LD_ADDR_EXP 43
49181: PUSH
49182: LD_EXP 43
49186: PPUSH
49187: LD_VAR 0 2
49191: PPUSH
49192: EMPTY
49193: PPUSH
49194: CALL_OW 1
49198: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49199: LD_ADDR_EXP 44
49203: PUSH
49204: LD_EXP 44
49208: PPUSH
49209: LD_VAR 0 2
49213: PPUSH
49214: EMPTY
49215: PPUSH
49216: CALL_OW 1
49220: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49221: LD_ADDR_EXP 45
49225: PUSH
49226: LD_EXP 45
49230: PPUSH
49231: LD_VAR 0 2
49235: PPUSH
49236: EMPTY
49237: PPUSH
49238: CALL_OW 1
49242: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49243: LD_ADDR_EXP 46
49247: PUSH
49248: LD_EXP 46
49252: PPUSH
49253: LD_VAR 0 2
49257: PPUSH
49258: EMPTY
49259: PUSH
49260: EMPTY
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: PPUSH
49266: CALL_OW 1
49270: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49271: LD_ADDR_EXP 47
49275: PUSH
49276: LD_EXP 47
49280: PPUSH
49281: LD_VAR 0 2
49285: PPUSH
49286: EMPTY
49287: PPUSH
49288: CALL_OW 1
49292: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49293: LD_ADDR_EXP 74
49297: PUSH
49298: LD_EXP 74
49302: PPUSH
49303: LD_VAR 0 2
49307: PPUSH
49308: EMPTY
49309: PPUSH
49310: CALL_OW 1
49314: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49315: LD_ADDR_EXP 48
49319: PUSH
49320: LD_EXP 48
49324: PPUSH
49325: LD_VAR 0 2
49329: PPUSH
49330: EMPTY
49331: PPUSH
49332: CALL_OW 1
49336: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49337: LD_ADDR_EXP 49
49341: PUSH
49342: LD_EXP 49
49346: PPUSH
49347: LD_VAR 0 2
49351: PPUSH
49352: EMPTY
49353: PPUSH
49354: CALL_OW 1
49358: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49359: LD_ADDR_EXP 50
49363: PUSH
49364: LD_EXP 50
49368: PPUSH
49369: LD_VAR 0 2
49373: PPUSH
49374: LD_EXP 42
49378: PUSH
49379: LD_VAR 0 2
49383: ARRAY
49384: PPUSH
49385: LD_INT 2
49387: PUSH
49388: LD_INT 30
49390: PUSH
49391: LD_INT 32
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: PUSH
49398: LD_INT 30
49400: PUSH
49401: LD_INT 33
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: LIST
49412: PPUSH
49413: CALL_OW 72
49417: PPUSH
49418: CALL_OW 1
49422: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49423: LD_ADDR_EXP 51
49427: PUSH
49428: LD_EXP 51
49432: PPUSH
49433: LD_VAR 0 2
49437: PPUSH
49438: LD_EXP 42
49442: PUSH
49443: LD_VAR 0 2
49447: ARRAY
49448: PPUSH
49449: LD_INT 2
49451: PUSH
49452: LD_INT 30
49454: PUSH
49455: LD_INT 32
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 30
49464: PUSH
49465: LD_INT 31
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: LIST
49476: PUSH
49477: LD_INT 58
49479: PUSH
49480: EMPTY
49481: LIST
49482: PUSH
49483: EMPTY
49484: LIST
49485: LIST
49486: PPUSH
49487: CALL_OW 72
49491: PPUSH
49492: CALL_OW 1
49496: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49497: LD_ADDR_EXP 52
49501: PUSH
49502: LD_EXP 52
49506: PPUSH
49507: LD_VAR 0 2
49511: PPUSH
49512: EMPTY
49513: PPUSH
49514: CALL_OW 1
49518: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49519: LD_ADDR_EXP 56
49523: PUSH
49524: LD_EXP 56
49528: PPUSH
49529: LD_VAR 0 2
49533: PPUSH
49534: EMPTY
49535: PPUSH
49536: CALL_OW 1
49540: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49541: LD_ADDR_EXP 55
49545: PUSH
49546: LD_EXP 55
49550: PPUSH
49551: LD_VAR 0 2
49555: PPUSH
49556: EMPTY
49557: PPUSH
49558: CALL_OW 1
49562: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49563: LD_ADDR_EXP 57
49567: PUSH
49568: LD_EXP 57
49572: PPUSH
49573: LD_VAR 0 2
49577: PPUSH
49578: EMPTY
49579: PPUSH
49580: CALL_OW 1
49584: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49585: LD_ADDR_EXP 58
49589: PUSH
49590: LD_EXP 58
49594: PPUSH
49595: LD_VAR 0 2
49599: PPUSH
49600: EMPTY
49601: PPUSH
49602: CALL_OW 1
49606: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49607: LD_ADDR_EXP 59
49611: PUSH
49612: LD_EXP 59
49616: PPUSH
49617: LD_VAR 0 2
49621: PPUSH
49622: EMPTY
49623: PPUSH
49624: CALL_OW 1
49628: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49629: LD_ADDR_EXP 60
49633: PUSH
49634: LD_EXP 60
49638: PPUSH
49639: LD_VAR 0 2
49643: PPUSH
49644: EMPTY
49645: PPUSH
49646: CALL_OW 1
49650: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49651: LD_ADDR_EXP 61
49655: PUSH
49656: LD_EXP 61
49660: PPUSH
49661: LD_VAR 0 2
49665: PPUSH
49666: EMPTY
49667: PPUSH
49668: CALL_OW 1
49672: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49673: LD_ADDR_EXP 62
49677: PUSH
49678: LD_EXP 62
49682: PPUSH
49683: LD_VAR 0 2
49687: PPUSH
49688: EMPTY
49689: PPUSH
49690: CALL_OW 1
49694: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49695: LD_ADDR_EXP 63
49699: PUSH
49700: LD_EXP 63
49704: PPUSH
49705: LD_VAR 0 2
49709: PPUSH
49710: EMPTY
49711: PPUSH
49712: CALL_OW 1
49716: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49717: LD_ADDR_EXP 64
49721: PUSH
49722: LD_EXP 64
49726: PPUSH
49727: LD_VAR 0 2
49731: PPUSH
49732: EMPTY
49733: PPUSH
49734: CALL_OW 1
49738: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49739: LD_ADDR_EXP 53
49743: PUSH
49744: LD_EXP 53
49748: PPUSH
49749: LD_VAR 0 2
49753: PPUSH
49754: LD_INT 0
49756: PPUSH
49757: CALL_OW 1
49761: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49762: LD_ADDR_EXP 66
49766: PUSH
49767: LD_EXP 66
49771: PPUSH
49772: LD_VAR 0 2
49776: PPUSH
49777: LD_INT 0
49779: PPUSH
49780: CALL_OW 1
49784: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49785: LD_ADDR_EXP 54
49789: PUSH
49790: LD_EXP 54
49794: PPUSH
49795: LD_VAR 0 2
49799: PPUSH
49800: EMPTY
49801: PPUSH
49802: CALL_OW 1
49806: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49807: LD_ADDR_EXP 65
49811: PUSH
49812: LD_EXP 65
49816: PPUSH
49817: LD_VAR 0 2
49821: PPUSH
49822: LD_INT 0
49824: PPUSH
49825: CALL_OW 1
49829: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49830: LD_ADDR_EXP 67
49834: PUSH
49835: LD_EXP 67
49839: PPUSH
49840: LD_VAR 0 2
49844: PPUSH
49845: EMPTY
49846: PPUSH
49847: CALL_OW 1
49851: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
49852: LD_ADDR_EXP 70
49856: PUSH
49857: LD_EXP 70
49861: PPUSH
49862: LD_VAR 0 2
49866: PPUSH
49867: LD_INT 0
49869: PPUSH
49870: CALL_OW 1
49874: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
49875: LD_ADDR_EXP 71
49879: PUSH
49880: LD_EXP 71
49884: PPUSH
49885: LD_VAR 0 2
49889: PPUSH
49890: EMPTY
49891: PPUSH
49892: CALL_OW 1
49896: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49897: LD_ADDR_EXP 72
49901: PUSH
49902: LD_EXP 72
49906: PPUSH
49907: LD_VAR 0 2
49911: PPUSH
49912: EMPTY
49913: PPUSH
49914: CALL_OW 1
49918: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49919: LD_ADDR_EXP 73
49923: PUSH
49924: LD_EXP 73
49928: PPUSH
49929: LD_VAR 0 2
49933: PPUSH
49934: EMPTY
49935: PPUSH
49936: CALL_OW 1
49940: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
49941: LD_ADDR_EXP 75
49945: PUSH
49946: LD_EXP 75
49950: PPUSH
49951: LD_VAR 0 2
49955: PPUSH
49956: LD_EXP 42
49960: PUSH
49961: LD_VAR 0 2
49965: ARRAY
49966: PPUSH
49967: LD_INT 2
49969: PUSH
49970: LD_INT 30
49972: PUSH
49973: LD_INT 6
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PUSH
49980: LD_INT 30
49982: PUSH
49983: LD_INT 7
49985: PUSH
49986: EMPTY
49987: LIST
49988: LIST
49989: PUSH
49990: LD_INT 30
49992: PUSH
49993: LD_INT 8
49995: PUSH
49996: EMPTY
49997: LIST
49998: LIST
49999: PUSH
50000: EMPTY
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: PPUSH
50006: CALL_OW 72
50010: PPUSH
50011: CALL_OW 1
50015: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50016: LD_ADDR_EXP 76
50020: PUSH
50021: LD_EXP 76
50025: PPUSH
50026: LD_VAR 0 2
50030: PPUSH
50031: EMPTY
50032: PPUSH
50033: CALL_OW 1
50037: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50038: LD_ADDR_EXP 77
50042: PUSH
50043: LD_EXP 77
50047: PPUSH
50048: LD_VAR 0 2
50052: PPUSH
50053: EMPTY
50054: PPUSH
50055: CALL_OW 1
50059: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50060: LD_ADDR_EXP 78
50064: PUSH
50065: LD_EXP 78
50069: PPUSH
50070: LD_VAR 0 2
50074: PPUSH
50075: EMPTY
50076: PPUSH
50077: CALL_OW 1
50081: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50082: LD_ADDR_EXP 79
50086: PUSH
50087: LD_EXP 79
50091: PPUSH
50092: LD_VAR 0 2
50096: PPUSH
50097: EMPTY
50098: PPUSH
50099: CALL_OW 1
50103: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50104: LD_ADDR_EXP 80
50108: PUSH
50109: LD_EXP 80
50113: PPUSH
50114: LD_VAR 0 2
50118: PPUSH
50119: EMPTY
50120: PPUSH
50121: CALL_OW 1
50125: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50126: LD_ADDR_EXP 81
50130: PUSH
50131: LD_EXP 81
50135: PPUSH
50136: LD_VAR 0 2
50140: PPUSH
50141: EMPTY
50142: PPUSH
50143: CALL_OW 1
50147: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50148: LD_ADDR_EXP 82
50152: PUSH
50153: LD_EXP 82
50157: PPUSH
50158: LD_VAR 0 2
50162: PPUSH
50163: EMPTY
50164: PPUSH
50165: CALL_OW 1
50169: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50170: LD_ADDR_EXP 83
50174: PUSH
50175: LD_EXP 83
50179: PPUSH
50180: LD_VAR 0 2
50184: PPUSH
50185: EMPTY
50186: PPUSH
50187: CALL_OW 1
50191: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50192: LD_ADDR_EXP 84
50196: PUSH
50197: LD_EXP 84
50201: PPUSH
50202: LD_VAR 0 2
50206: PPUSH
50207: LD_INT 0
50209: PPUSH
50210: CALL_OW 1
50214: ST_TO_ADDR
// end ;
50215: GO 49139
50217: POP
50218: POP
// MC_InitSides ( ) ;
50219: CALL 50505 0 0
// MC_InitResearch ( ) ;
50223: CALL 50244 0 0
// CustomInitMacro ( ) ;
50227: CALL 101 0 0
// skirmish := true ;
50231: LD_ADDR_EXP 40
50235: PUSH
50236: LD_INT 1
50238: ST_TO_ADDR
// end ;
50239: LD_VAR 0 1
50243: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50244: LD_INT 0
50246: PPUSH
50247: PPUSH
50248: PPUSH
50249: PPUSH
50250: PPUSH
50251: PPUSH
// if not mc_bases then
50252: LD_EXP 42
50256: NOT
50257: IFFALSE 50261
// exit ;
50259: GO 50500
// for i = 1 to 8 do
50261: LD_ADDR_VAR 0 2
50265: PUSH
50266: DOUBLE
50267: LD_INT 1
50269: DEC
50270: ST_TO_ADDR
50271: LD_INT 8
50273: PUSH
50274: FOR_TO
50275: IFFALSE 50301
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50277: LD_ADDR_EXP 69
50281: PUSH
50282: LD_EXP 69
50286: PPUSH
50287: LD_VAR 0 2
50291: PPUSH
50292: EMPTY
50293: PPUSH
50294: CALL_OW 1
50298: ST_TO_ADDR
50299: GO 50274
50301: POP
50302: POP
// tmp := [ ] ;
50303: LD_ADDR_VAR 0 5
50307: PUSH
50308: EMPTY
50309: ST_TO_ADDR
// for i = 1 to mc_sides do
50310: LD_ADDR_VAR 0 2
50314: PUSH
50315: DOUBLE
50316: LD_INT 1
50318: DEC
50319: ST_TO_ADDR
50320: LD_EXP 68
50324: PUSH
50325: FOR_TO
50326: IFFALSE 50384
// if not mc_sides [ i ] in tmp then
50328: LD_EXP 68
50332: PUSH
50333: LD_VAR 0 2
50337: ARRAY
50338: PUSH
50339: LD_VAR 0 5
50343: IN
50344: NOT
50345: IFFALSE 50382
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50347: LD_ADDR_VAR 0 5
50351: PUSH
50352: LD_VAR 0 5
50356: PPUSH
50357: LD_VAR 0 5
50361: PUSH
50362: LD_INT 1
50364: PLUS
50365: PPUSH
50366: LD_EXP 68
50370: PUSH
50371: LD_VAR 0 2
50375: ARRAY
50376: PPUSH
50377: CALL_OW 2
50381: ST_TO_ADDR
50382: GO 50325
50384: POP
50385: POP
// if not tmp then
50386: LD_VAR 0 5
50390: NOT
50391: IFFALSE 50395
// exit ;
50393: GO 50500
// for j in tmp do
50395: LD_ADDR_VAR 0 3
50399: PUSH
50400: LD_VAR 0 5
50404: PUSH
50405: FOR_IN
50406: IFFALSE 50498
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50408: LD_ADDR_VAR 0 6
50412: PUSH
50413: LD_INT 22
50415: PUSH
50416: LD_VAR 0 3
50420: PUSH
50421: EMPTY
50422: LIST
50423: LIST
50424: PPUSH
50425: CALL_OW 69
50429: ST_TO_ADDR
// if not un then
50430: LD_VAR 0 6
50434: NOT
50435: IFFALSE 50439
// continue ;
50437: GO 50405
// nation := GetNation ( un [ 1 ] ) ;
50439: LD_ADDR_VAR 0 4
50443: PUSH
50444: LD_VAR 0 6
50448: PUSH
50449: LD_INT 1
50451: ARRAY
50452: PPUSH
50453: CALL_OW 248
50457: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50458: LD_ADDR_EXP 69
50462: PUSH
50463: LD_EXP 69
50467: PPUSH
50468: LD_VAR 0 3
50472: PPUSH
50473: LD_VAR 0 3
50477: PPUSH
50478: LD_VAR 0 4
50482: PPUSH
50483: LD_INT 1
50485: PPUSH
50486: CALL 9867 0 3
50490: PPUSH
50491: CALL_OW 1
50495: ST_TO_ADDR
// end ;
50496: GO 50405
50498: POP
50499: POP
// end ;
50500: LD_VAR 0 1
50504: RET
// export function MC_InitSides ( ) ; var i ; begin
50505: LD_INT 0
50507: PPUSH
50508: PPUSH
// if not mc_bases then
50509: LD_EXP 42
50513: NOT
50514: IFFALSE 50518
// exit ;
50516: GO 50592
// for i = 1 to mc_bases do
50518: LD_ADDR_VAR 0 2
50522: PUSH
50523: DOUBLE
50524: LD_INT 1
50526: DEC
50527: ST_TO_ADDR
50528: LD_EXP 42
50532: PUSH
50533: FOR_TO
50534: IFFALSE 50590
// if mc_bases [ i ] then
50536: LD_EXP 42
50540: PUSH
50541: LD_VAR 0 2
50545: ARRAY
50546: IFFALSE 50588
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50548: LD_ADDR_EXP 68
50552: PUSH
50553: LD_EXP 68
50557: PPUSH
50558: LD_VAR 0 2
50562: PPUSH
50563: LD_EXP 42
50567: PUSH
50568: LD_VAR 0 2
50572: ARRAY
50573: PUSH
50574: LD_INT 1
50576: ARRAY
50577: PPUSH
50578: CALL_OW 255
50582: PPUSH
50583: CALL_OW 1
50587: ST_TO_ADDR
50588: GO 50533
50590: POP
50591: POP
// end ;
50592: LD_VAR 0 1
50596: RET
// every 0 0$01 trigger skirmish do
50597: LD_EXP 40
50601: IFFALSE 50755
50603: GO 50605
50605: DISABLE
// begin enable ;
50606: ENABLE
// MC_CheckBuildings ( ) ;
50607: CALL 55253 0 0
// MC_CheckPeopleLife ( ) ;
50611: CALL 55378 0 0
// RaiseSailEvent ( 100 ) ;
50615: LD_INT 100
50617: PPUSH
50618: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50622: LD_INT 103
50624: PPUSH
50625: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50629: LD_INT 104
50631: PPUSH
50632: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50636: LD_INT 105
50638: PPUSH
50639: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50643: LD_INT 106
50645: PPUSH
50646: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50650: LD_INT 107
50652: PPUSH
50653: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50657: LD_INT 108
50659: PPUSH
50660: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50664: LD_INT 109
50666: PPUSH
50667: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50671: LD_INT 110
50673: PPUSH
50674: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50678: LD_INT 111
50680: PPUSH
50681: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50685: LD_INT 112
50687: PPUSH
50688: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50692: LD_INT 113
50694: PPUSH
50695: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50699: LD_INT 120
50701: PPUSH
50702: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50706: LD_INT 121
50708: PPUSH
50709: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50713: LD_INT 122
50715: PPUSH
50716: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50720: LD_INT 123
50722: PPUSH
50723: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50727: LD_INT 124
50729: PPUSH
50730: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50734: LD_INT 125
50736: PPUSH
50737: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50741: LD_INT 126
50743: PPUSH
50744: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50748: LD_INT 200
50750: PPUSH
50751: CALL_OW 427
// end ;
50755: END
// on SailEvent ( event ) do begin if event < 100 then
50756: LD_VAR 0 1
50760: PUSH
50761: LD_INT 100
50763: LESS
50764: IFFALSE 50775
// CustomEvent ( event ) ;
50766: LD_VAR 0 1
50770: PPUSH
50771: CALL 571 0 1
// if event = 100 then
50775: LD_VAR 0 1
50779: PUSH
50780: LD_INT 100
50782: EQUAL
50783: IFFALSE 50789
// MC_ClassManager ( ) ;
50785: CALL 51181 0 0
// if event = 101 then
50789: LD_VAR 0 1
50793: PUSH
50794: LD_INT 101
50796: EQUAL
50797: IFFALSE 50803
// MC_RepairBuildings ( ) ;
50799: CALL 55963 0 0
// if event = 102 then
50803: LD_VAR 0 1
50807: PUSH
50808: LD_INT 102
50810: EQUAL
50811: IFFALSE 50817
// MC_Heal ( ) ;
50813: CALL 56848 0 0
// if event = 103 then
50817: LD_VAR 0 1
50821: PUSH
50822: LD_INT 103
50824: EQUAL
50825: IFFALSE 50831
// MC_Build ( ) ;
50827: CALL 57270 0 0
// if event = 104 then
50831: LD_VAR 0 1
50835: PUSH
50836: LD_INT 104
50838: EQUAL
50839: IFFALSE 50845
// MC_TurretWeapon ( ) ;
50841: CALL 58883 0 0
// if event = 105 then
50845: LD_VAR 0 1
50849: PUSH
50850: LD_INT 105
50852: EQUAL
50853: IFFALSE 50859
// MC_BuildUpgrade ( ) ;
50855: CALL 58434 0 0
// if event = 106 then
50859: LD_VAR 0 1
50863: PUSH
50864: LD_INT 106
50866: EQUAL
50867: IFFALSE 50873
// MC_PlantMines ( ) ;
50869: CALL 59313 0 0
// if event = 107 then
50873: LD_VAR 0 1
50877: PUSH
50878: LD_INT 107
50880: EQUAL
50881: IFFALSE 50887
// MC_CollectCrates ( ) ;
50883: CALL 60111 0 0
// if event = 108 then
50887: LD_VAR 0 1
50891: PUSH
50892: LD_INT 108
50894: EQUAL
50895: IFFALSE 50901
// MC_LinkRemoteControl ( ) ;
50897: CALL 61887 0 0
// if event = 109 then
50901: LD_VAR 0 1
50905: PUSH
50906: LD_INT 109
50908: EQUAL
50909: IFFALSE 50915
// MC_ProduceVehicle ( ) ;
50911: CALL 62068 0 0
// if event = 110 then
50915: LD_VAR 0 1
50919: PUSH
50920: LD_INT 110
50922: EQUAL
50923: IFFALSE 50929
// MC_SendAttack ( ) ;
50925: CALL 62534 0 0
// if event = 111 then
50929: LD_VAR 0 1
50933: PUSH
50934: LD_INT 111
50936: EQUAL
50937: IFFALSE 50943
// MC_Defend ( ) ;
50939: CALL 62642 0 0
// if event = 112 then
50943: LD_VAR 0 1
50947: PUSH
50948: LD_INT 112
50950: EQUAL
50951: IFFALSE 50957
// MC_Research ( ) ;
50953: CALL 63269 0 0
// if event = 113 then
50957: LD_VAR 0 1
50961: PUSH
50962: LD_INT 113
50964: EQUAL
50965: IFFALSE 50971
// MC_MinesTrigger ( ) ;
50967: CALL 64383 0 0
// if event = 120 then
50971: LD_VAR 0 1
50975: PUSH
50976: LD_INT 120
50978: EQUAL
50979: IFFALSE 50985
// MC_RepairVehicle ( ) ;
50981: CALL 64482 0 0
// if event = 121 then
50985: LD_VAR 0 1
50989: PUSH
50990: LD_INT 121
50992: EQUAL
50993: IFFALSE 50999
// MC_TameApe ( ) ;
50995: CALL 65212 0 0
// if event = 122 then
50999: LD_VAR 0 1
51003: PUSH
51004: LD_INT 122
51006: EQUAL
51007: IFFALSE 51013
// MC_ChangeApeClass ( ) ;
51009: CALL 66041 0 0
// if event = 123 then
51013: LD_VAR 0 1
51017: PUSH
51018: LD_INT 123
51020: EQUAL
51021: IFFALSE 51027
// MC_Bazooka ( ) ;
51023: CALL 66691 0 0
// if event = 124 then
51027: LD_VAR 0 1
51031: PUSH
51032: LD_INT 124
51034: EQUAL
51035: IFFALSE 51041
// MC_TeleportExit ( ) ;
51037: CALL 66889 0 0
// if event = 125 then
51041: LD_VAR 0 1
51045: PUSH
51046: LD_INT 125
51048: EQUAL
51049: IFFALSE 51055
// MC_Deposits ( ) ;
51051: CALL 67536 0 0
// if event = 126 then
51055: LD_VAR 0 1
51059: PUSH
51060: LD_INT 126
51062: EQUAL
51063: IFFALSE 51069
// MC_RemoteDriver ( ) ;
51065: CALL 68161 0 0
// if event = 200 then
51069: LD_VAR 0 1
51073: PUSH
51074: LD_INT 200
51076: EQUAL
51077: IFFALSE 51083
// MC_Idle ( ) ;
51079: CALL 70110 0 0
// end ;
51083: PPOPN 1
51085: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51086: LD_INT 0
51088: PPUSH
51089: PPUSH
// if not mc_bases [ base ] or not tag then
51090: LD_EXP 42
51094: PUSH
51095: LD_VAR 0 1
51099: ARRAY
51100: NOT
51101: PUSH
51102: LD_VAR 0 2
51106: NOT
51107: OR
51108: IFFALSE 51112
// exit ;
51110: GO 51176
// for i in mc_bases [ base ] union mc_ape [ base ] do
51112: LD_ADDR_VAR 0 4
51116: PUSH
51117: LD_EXP 42
51121: PUSH
51122: LD_VAR 0 1
51126: ARRAY
51127: PUSH
51128: LD_EXP 71
51132: PUSH
51133: LD_VAR 0 1
51137: ARRAY
51138: UNION
51139: PUSH
51140: FOR_IN
51141: IFFALSE 51174
// if GetTag ( i ) = tag then
51143: LD_VAR 0 4
51147: PPUSH
51148: CALL_OW 110
51152: PUSH
51153: LD_VAR 0 2
51157: EQUAL
51158: IFFALSE 51172
// SetTag ( i , 0 ) ;
51160: LD_VAR 0 4
51164: PPUSH
51165: LD_INT 0
51167: PPUSH
51168: CALL_OW 109
51172: GO 51140
51174: POP
51175: POP
// end ;
51176: LD_VAR 0 3
51180: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51181: LD_INT 0
51183: PPUSH
51184: PPUSH
51185: PPUSH
51186: PPUSH
51187: PPUSH
51188: PPUSH
51189: PPUSH
51190: PPUSH
// if not mc_bases then
51191: LD_EXP 42
51195: NOT
51196: IFFALSE 51200
// exit ;
51198: GO 51658
// for i = 1 to mc_bases do
51200: LD_ADDR_VAR 0 2
51204: PUSH
51205: DOUBLE
51206: LD_INT 1
51208: DEC
51209: ST_TO_ADDR
51210: LD_EXP 42
51214: PUSH
51215: FOR_TO
51216: IFFALSE 51656
// begin tmp := MC_ClassCheckReq ( i ) ;
51218: LD_ADDR_VAR 0 4
51222: PUSH
51223: LD_VAR 0 2
51227: PPUSH
51228: CALL 51663 0 1
51232: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51233: LD_ADDR_EXP 83
51237: PUSH
51238: LD_EXP 83
51242: PPUSH
51243: LD_VAR 0 2
51247: PPUSH
51248: LD_VAR 0 4
51252: PPUSH
51253: CALL_OW 1
51257: ST_TO_ADDR
// if not tmp then
51258: LD_VAR 0 4
51262: NOT
51263: IFFALSE 51267
// continue ;
51265: GO 51215
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51267: LD_ADDR_VAR 0 6
51271: PUSH
51272: LD_EXP 42
51276: PUSH
51277: LD_VAR 0 2
51281: ARRAY
51282: PPUSH
51283: LD_INT 2
51285: PUSH
51286: LD_INT 30
51288: PUSH
51289: LD_INT 4
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: LD_INT 30
51298: PUSH
51299: LD_INT 5
51301: PUSH
51302: EMPTY
51303: LIST
51304: LIST
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: LIST
51310: PPUSH
51311: CALL_OW 72
51315: PUSH
51316: LD_EXP 42
51320: PUSH
51321: LD_VAR 0 2
51325: ARRAY
51326: PPUSH
51327: LD_INT 2
51329: PUSH
51330: LD_INT 30
51332: PUSH
51333: LD_INT 0
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 30
51342: PUSH
51343: LD_INT 1
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: PPUSH
51355: CALL_OW 72
51359: PUSH
51360: LD_EXP 42
51364: PUSH
51365: LD_VAR 0 2
51369: ARRAY
51370: PPUSH
51371: LD_INT 30
51373: PUSH
51374: LD_INT 3
51376: PUSH
51377: EMPTY
51378: LIST
51379: LIST
51380: PPUSH
51381: CALL_OW 72
51385: PUSH
51386: LD_EXP 42
51390: PUSH
51391: LD_VAR 0 2
51395: ARRAY
51396: PPUSH
51397: LD_INT 2
51399: PUSH
51400: LD_INT 30
51402: PUSH
51403: LD_INT 6
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 30
51412: PUSH
51413: LD_INT 7
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 30
51422: PUSH
51423: LD_INT 8
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: LIST
51434: LIST
51435: PPUSH
51436: CALL_OW 72
51440: PUSH
51441: EMPTY
51442: LIST
51443: LIST
51444: LIST
51445: LIST
51446: ST_TO_ADDR
// for j = 1 to 4 do
51447: LD_ADDR_VAR 0 3
51451: PUSH
51452: DOUBLE
51453: LD_INT 1
51455: DEC
51456: ST_TO_ADDR
51457: LD_INT 4
51459: PUSH
51460: FOR_TO
51461: IFFALSE 51652
// begin if not tmp [ j ] then
51463: LD_VAR 0 4
51467: PUSH
51468: LD_VAR 0 3
51472: ARRAY
51473: NOT
51474: IFFALSE 51478
// continue ;
51476: GO 51460
// for p in tmp [ j ] do
51478: LD_ADDR_VAR 0 5
51482: PUSH
51483: LD_VAR 0 4
51487: PUSH
51488: LD_VAR 0 3
51492: ARRAY
51493: PUSH
51494: FOR_IN
51495: IFFALSE 51648
// begin if not b [ j ] then
51497: LD_VAR 0 6
51501: PUSH
51502: LD_VAR 0 3
51506: ARRAY
51507: NOT
51508: IFFALSE 51512
// break ;
51510: GO 51648
// e := 0 ;
51512: LD_ADDR_VAR 0 7
51516: PUSH
51517: LD_INT 0
51519: ST_TO_ADDR
// for k in b [ j ] do
51520: LD_ADDR_VAR 0 8
51524: PUSH
51525: LD_VAR 0 6
51529: PUSH
51530: LD_VAR 0 3
51534: ARRAY
51535: PUSH
51536: FOR_IN
51537: IFFALSE 51564
// if IsNotFull ( k ) then
51539: LD_VAR 0 8
51543: PPUSH
51544: CALL 12016 0 1
51548: IFFALSE 51562
// begin e := k ;
51550: LD_ADDR_VAR 0 7
51554: PUSH
51555: LD_VAR 0 8
51559: ST_TO_ADDR
// break ;
51560: GO 51564
// end ;
51562: GO 51536
51564: POP
51565: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51566: LD_VAR 0 7
51570: PUSH
51571: LD_VAR 0 5
51575: PPUSH
51576: LD_VAR 0 7
51580: PPUSH
51581: CALL 44436 0 2
51585: NOT
51586: AND
51587: IFFALSE 51646
// begin if IsInUnit ( p ) then
51589: LD_VAR 0 5
51593: PPUSH
51594: CALL_OW 310
51598: IFFALSE 51609
// ComExitBuilding ( p ) ;
51600: LD_VAR 0 5
51604: PPUSH
51605: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51609: LD_VAR 0 5
51613: PPUSH
51614: LD_VAR 0 7
51618: PPUSH
51619: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51623: LD_VAR 0 5
51627: PPUSH
51628: LD_VAR 0 3
51632: PPUSH
51633: CALL_OW 183
// AddComExitBuilding ( p ) ;
51637: LD_VAR 0 5
51641: PPUSH
51642: CALL_OW 182
// end ; end ;
51646: GO 51494
51648: POP
51649: POP
// end ;
51650: GO 51460
51652: POP
51653: POP
// end ;
51654: GO 51215
51656: POP
51657: POP
// end ;
51658: LD_VAR 0 1
51662: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51663: LD_INT 0
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
51674: PPUSH
51675: PPUSH
51676: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51677: LD_VAR 0 1
51681: NOT
51682: PUSH
51683: LD_EXP 42
51687: PUSH
51688: LD_VAR 0 1
51692: ARRAY
51693: NOT
51694: OR
51695: PUSH
51696: LD_EXP 42
51700: PUSH
51701: LD_VAR 0 1
51705: ARRAY
51706: PPUSH
51707: LD_INT 2
51709: PUSH
51710: LD_INT 30
51712: PUSH
51713: LD_INT 0
51715: PUSH
51716: EMPTY
51717: LIST
51718: LIST
51719: PUSH
51720: LD_INT 30
51722: PUSH
51723: LD_INT 1
51725: PUSH
51726: EMPTY
51727: LIST
51728: LIST
51729: PUSH
51730: EMPTY
51731: LIST
51732: LIST
51733: LIST
51734: PPUSH
51735: CALL_OW 72
51739: NOT
51740: OR
51741: IFFALSE 51745
// exit ;
51743: GO 55248
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51745: LD_ADDR_VAR 0 4
51749: PUSH
51750: LD_EXP 42
51754: PUSH
51755: LD_VAR 0 1
51759: ARRAY
51760: PPUSH
51761: LD_INT 2
51763: PUSH
51764: LD_INT 25
51766: PUSH
51767: LD_INT 1
51769: PUSH
51770: EMPTY
51771: LIST
51772: LIST
51773: PUSH
51774: LD_INT 25
51776: PUSH
51777: LD_INT 2
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: PUSH
51784: LD_INT 25
51786: PUSH
51787: LD_INT 3
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: PUSH
51794: LD_INT 25
51796: PUSH
51797: LD_INT 4
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: PUSH
51804: LD_INT 25
51806: PUSH
51807: LD_INT 5
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: PUSH
51814: LD_INT 25
51816: PUSH
51817: LD_INT 8
51819: PUSH
51820: EMPTY
51821: LIST
51822: LIST
51823: PUSH
51824: LD_INT 25
51826: PUSH
51827: LD_INT 9
51829: PUSH
51830: EMPTY
51831: LIST
51832: LIST
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: PPUSH
51844: CALL_OW 72
51848: ST_TO_ADDR
// if not tmp then
51849: LD_VAR 0 4
51853: NOT
51854: IFFALSE 51858
// exit ;
51856: GO 55248
// for i in tmp do
51858: LD_ADDR_VAR 0 3
51862: PUSH
51863: LD_VAR 0 4
51867: PUSH
51868: FOR_IN
51869: IFFALSE 51900
// if GetTag ( i ) then
51871: LD_VAR 0 3
51875: PPUSH
51876: CALL_OW 110
51880: IFFALSE 51898
// tmp := tmp diff i ;
51882: LD_ADDR_VAR 0 4
51886: PUSH
51887: LD_VAR 0 4
51891: PUSH
51892: LD_VAR 0 3
51896: DIFF
51897: ST_TO_ADDR
51898: GO 51868
51900: POP
51901: POP
// if not tmp then
51902: LD_VAR 0 4
51906: NOT
51907: IFFALSE 51911
// exit ;
51909: GO 55248
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51911: LD_ADDR_VAR 0 5
51915: PUSH
51916: LD_EXP 42
51920: PUSH
51921: LD_VAR 0 1
51925: ARRAY
51926: PPUSH
51927: LD_INT 2
51929: PUSH
51930: LD_INT 25
51932: PUSH
51933: LD_INT 1
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: PUSH
51940: LD_INT 25
51942: PUSH
51943: LD_INT 5
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: PUSH
51950: LD_INT 25
51952: PUSH
51953: LD_INT 8
51955: PUSH
51956: EMPTY
51957: LIST
51958: LIST
51959: PUSH
51960: LD_INT 25
51962: PUSH
51963: LD_INT 9
51965: PUSH
51966: EMPTY
51967: LIST
51968: LIST
51969: PUSH
51970: EMPTY
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: LIST
51976: PPUSH
51977: CALL_OW 72
51981: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
51982: LD_ADDR_VAR 0 6
51986: PUSH
51987: LD_EXP 42
51991: PUSH
51992: LD_VAR 0 1
51996: ARRAY
51997: PPUSH
51998: LD_INT 25
52000: PUSH
52001: LD_INT 2
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: PPUSH
52008: CALL_OW 72
52012: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52013: LD_ADDR_VAR 0 7
52017: PUSH
52018: LD_EXP 42
52022: PUSH
52023: LD_VAR 0 1
52027: ARRAY
52028: PPUSH
52029: LD_INT 25
52031: PUSH
52032: LD_INT 3
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PPUSH
52039: CALL_OW 72
52043: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52044: LD_ADDR_VAR 0 8
52048: PUSH
52049: LD_EXP 42
52053: PUSH
52054: LD_VAR 0 1
52058: ARRAY
52059: PPUSH
52060: LD_INT 25
52062: PUSH
52063: LD_INT 4
52065: PUSH
52066: EMPTY
52067: LIST
52068: LIST
52069: PUSH
52070: LD_INT 24
52072: PUSH
52073: LD_INT 251
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: PPUSH
52084: CALL_OW 72
52088: ST_TO_ADDR
// if mc_scan [ base ] then
52089: LD_EXP 65
52093: PUSH
52094: LD_VAR 0 1
52098: ARRAY
52099: IFFALSE 52560
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52101: LD_ADDR_EXP 84
52105: PUSH
52106: LD_EXP 84
52110: PPUSH
52111: LD_VAR 0 1
52115: PPUSH
52116: LD_INT 4
52118: PPUSH
52119: CALL_OW 1
52123: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52124: LD_ADDR_VAR 0 12
52128: PUSH
52129: LD_EXP 42
52133: PUSH
52134: LD_VAR 0 1
52138: ARRAY
52139: PPUSH
52140: LD_INT 2
52142: PUSH
52143: LD_INT 30
52145: PUSH
52146: LD_INT 4
52148: PUSH
52149: EMPTY
52150: LIST
52151: LIST
52152: PUSH
52153: LD_INT 30
52155: PUSH
52156: LD_INT 5
52158: PUSH
52159: EMPTY
52160: LIST
52161: LIST
52162: PUSH
52163: EMPTY
52164: LIST
52165: LIST
52166: LIST
52167: PPUSH
52168: CALL_OW 72
52172: ST_TO_ADDR
// if not b then
52173: LD_VAR 0 12
52177: NOT
52178: IFFALSE 52182
// exit ;
52180: GO 55248
// p := [ ] ;
52182: LD_ADDR_VAR 0 11
52186: PUSH
52187: EMPTY
52188: ST_TO_ADDR
// if sci >= 2 then
52189: LD_VAR 0 8
52193: PUSH
52194: LD_INT 2
52196: GREATEREQUAL
52197: IFFALSE 52228
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52199: LD_ADDR_VAR 0 8
52203: PUSH
52204: LD_VAR 0 8
52208: PUSH
52209: LD_INT 1
52211: ARRAY
52212: PUSH
52213: LD_VAR 0 8
52217: PUSH
52218: LD_INT 2
52220: ARRAY
52221: PUSH
52222: EMPTY
52223: LIST
52224: LIST
52225: ST_TO_ADDR
52226: GO 52289
// if sci = 1 then
52228: LD_VAR 0 8
52232: PUSH
52233: LD_INT 1
52235: EQUAL
52236: IFFALSE 52257
// sci := [ sci [ 1 ] ] else
52238: LD_ADDR_VAR 0 8
52242: PUSH
52243: LD_VAR 0 8
52247: PUSH
52248: LD_INT 1
52250: ARRAY
52251: PUSH
52252: EMPTY
52253: LIST
52254: ST_TO_ADDR
52255: GO 52289
// if sci = 0 then
52257: LD_VAR 0 8
52261: PUSH
52262: LD_INT 0
52264: EQUAL
52265: IFFALSE 52289
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52267: LD_ADDR_VAR 0 11
52271: PUSH
52272: LD_VAR 0 4
52276: PPUSH
52277: LD_INT 4
52279: PPUSH
52280: CALL 44299 0 2
52284: PUSH
52285: LD_INT 1
52287: ARRAY
52288: ST_TO_ADDR
// if eng > 4 then
52289: LD_VAR 0 6
52293: PUSH
52294: LD_INT 4
52296: GREATER
52297: IFFALSE 52343
// for i = eng downto 4 do
52299: LD_ADDR_VAR 0 3
52303: PUSH
52304: DOUBLE
52305: LD_VAR 0 6
52309: INC
52310: ST_TO_ADDR
52311: LD_INT 4
52313: PUSH
52314: FOR_DOWNTO
52315: IFFALSE 52341
// eng := eng diff eng [ i ] ;
52317: LD_ADDR_VAR 0 6
52321: PUSH
52322: LD_VAR 0 6
52326: PUSH
52327: LD_VAR 0 6
52331: PUSH
52332: LD_VAR 0 3
52336: ARRAY
52337: DIFF
52338: ST_TO_ADDR
52339: GO 52314
52341: POP
52342: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52343: LD_ADDR_VAR 0 4
52347: PUSH
52348: LD_VAR 0 4
52352: PUSH
52353: LD_VAR 0 5
52357: PUSH
52358: LD_VAR 0 6
52362: UNION
52363: PUSH
52364: LD_VAR 0 7
52368: UNION
52369: PUSH
52370: LD_VAR 0 8
52374: UNION
52375: DIFF
52376: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52377: LD_ADDR_VAR 0 13
52381: PUSH
52382: LD_EXP 42
52386: PUSH
52387: LD_VAR 0 1
52391: ARRAY
52392: PPUSH
52393: LD_INT 2
52395: PUSH
52396: LD_INT 30
52398: PUSH
52399: LD_INT 32
52401: PUSH
52402: EMPTY
52403: LIST
52404: LIST
52405: PUSH
52406: LD_INT 30
52408: PUSH
52409: LD_INT 31
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: LIST
52420: PPUSH
52421: CALL_OW 72
52425: PUSH
52426: LD_EXP 42
52430: PUSH
52431: LD_VAR 0 1
52435: ARRAY
52436: PPUSH
52437: LD_INT 2
52439: PUSH
52440: LD_INT 30
52442: PUSH
52443: LD_INT 4
52445: PUSH
52446: EMPTY
52447: LIST
52448: LIST
52449: PUSH
52450: LD_INT 30
52452: PUSH
52453: LD_INT 5
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: PUSH
52460: EMPTY
52461: LIST
52462: LIST
52463: LIST
52464: PPUSH
52465: CALL_OW 72
52469: PUSH
52470: LD_INT 6
52472: MUL
52473: PLUS
52474: ST_TO_ADDR
// if bcount < tmp then
52475: LD_VAR 0 13
52479: PUSH
52480: LD_VAR 0 4
52484: LESS
52485: IFFALSE 52531
// for i = tmp downto bcount do
52487: LD_ADDR_VAR 0 3
52491: PUSH
52492: DOUBLE
52493: LD_VAR 0 4
52497: INC
52498: ST_TO_ADDR
52499: LD_VAR 0 13
52503: PUSH
52504: FOR_DOWNTO
52505: IFFALSE 52529
// tmp := Delete ( tmp , tmp ) ;
52507: LD_ADDR_VAR 0 4
52511: PUSH
52512: LD_VAR 0 4
52516: PPUSH
52517: LD_VAR 0 4
52521: PPUSH
52522: CALL_OW 3
52526: ST_TO_ADDR
52527: GO 52504
52529: POP
52530: POP
// result := [ tmp , 0 , 0 , p ] ;
52531: LD_ADDR_VAR 0 2
52535: PUSH
52536: LD_VAR 0 4
52540: PUSH
52541: LD_INT 0
52543: PUSH
52544: LD_INT 0
52546: PUSH
52547: LD_VAR 0 11
52551: PUSH
52552: EMPTY
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: ST_TO_ADDR
// exit ;
52558: GO 55248
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52560: LD_EXP 42
52564: PUSH
52565: LD_VAR 0 1
52569: ARRAY
52570: PPUSH
52571: LD_INT 2
52573: PUSH
52574: LD_INT 30
52576: PUSH
52577: LD_INT 6
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: LD_INT 30
52586: PUSH
52587: LD_INT 7
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: PUSH
52594: LD_INT 30
52596: PUSH
52597: LD_INT 8
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: LIST
52608: LIST
52609: PPUSH
52610: CALL_OW 72
52614: NOT
52615: PUSH
52616: LD_EXP 42
52620: PUSH
52621: LD_VAR 0 1
52625: ARRAY
52626: PPUSH
52627: LD_INT 30
52629: PUSH
52630: LD_INT 3
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: PPUSH
52637: CALL_OW 72
52641: NOT
52642: AND
52643: IFFALSE 52715
// begin if eng = tmp then
52645: LD_VAR 0 6
52649: PUSH
52650: LD_VAR 0 4
52654: EQUAL
52655: IFFALSE 52659
// exit ;
52657: GO 55248
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52659: LD_ADDR_EXP 84
52663: PUSH
52664: LD_EXP 84
52668: PPUSH
52669: LD_VAR 0 1
52673: PPUSH
52674: LD_INT 1
52676: PPUSH
52677: CALL_OW 1
52681: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52682: LD_ADDR_VAR 0 2
52686: PUSH
52687: LD_INT 0
52689: PUSH
52690: LD_VAR 0 4
52694: PUSH
52695: LD_VAR 0 6
52699: DIFF
52700: PUSH
52701: LD_INT 0
52703: PUSH
52704: LD_INT 0
52706: PUSH
52707: EMPTY
52708: LIST
52709: LIST
52710: LIST
52711: LIST
52712: ST_TO_ADDR
// exit ;
52713: GO 55248
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52715: LD_EXP 69
52719: PUSH
52720: LD_EXP 68
52724: PUSH
52725: LD_VAR 0 1
52729: ARRAY
52730: ARRAY
52731: PUSH
52732: LD_EXP 42
52736: PUSH
52737: LD_VAR 0 1
52741: ARRAY
52742: PPUSH
52743: LD_INT 2
52745: PUSH
52746: LD_INT 30
52748: PUSH
52749: LD_INT 6
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: PUSH
52756: LD_INT 30
52758: PUSH
52759: LD_INT 7
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: PUSH
52766: LD_INT 30
52768: PUSH
52769: LD_INT 8
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: PUSH
52776: EMPTY
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: PPUSH
52782: CALL_OW 72
52786: AND
52787: PUSH
52788: LD_EXP 42
52792: PUSH
52793: LD_VAR 0 1
52797: ARRAY
52798: PPUSH
52799: LD_INT 30
52801: PUSH
52802: LD_INT 3
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PPUSH
52809: CALL_OW 72
52813: NOT
52814: AND
52815: IFFALSE 53029
// begin if sci >= 6 then
52817: LD_VAR 0 8
52821: PUSH
52822: LD_INT 6
52824: GREATEREQUAL
52825: IFFALSE 52829
// exit ;
52827: GO 55248
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
52829: LD_ADDR_EXP 84
52833: PUSH
52834: LD_EXP 84
52838: PPUSH
52839: LD_VAR 0 1
52843: PPUSH
52844: LD_INT 2
52846: PPUSH
52847: CALL_OW 1
52851: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
52852: LD_ADDR_VAR 0 9
52856: PUSH
52857: LD_VAR 0 4
52861: PUSH
52862: LD_VAR 0 8
52866: DIFF
52867: PPUSH
52868: LD_INT 4
52870: PPUSH
52871: CALL 44299 0 2
52875: ST_TO_ADDR
// p := [ ] ;
52876: LD_ADDR_VAR 0 11
52880: PUSH
52881: EMPTY
52882: ST_TO_ADDR
// if sci < 6 and sort > 6 then
52883: LD_VAR 0 8
52887: PUSH
52888: LD_INT 6
52890: LESS
52891: PUSH
52892: LD_VAR 0 9
52896: PUSH
52897: LD_INT 6
52899: GREATER
52900: AND
52901: IFFALSE 52982
// begin for i = 1 to 6 - sci do
52903: LD_ADDR_VAR 0 3
52907: PUSH
52908: DOUBLE
52909: LD_INT 1
52911: DEC
52912: ST_TO_ADDR
52913: LD_INT 6
52915: PUSH
52916: LD_VAR 0 8
52920: MINUS
52921: PUSH
52922: FOR_TO
52923: IFFALSE 52978
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
52925: LD_ADDR_VAR 0 11
52929: PUSH
52930: LD_VAR 0 11
52934: PPUSH
52935: LD_VAR 0 11
52939: PUSH
52940: LD_INT 1
52942: PLUS
52943: PPUSH
52944: LD_VAR 0 9
52948: PUSH
52949: LD_INT 1
52951: ARRAY
52952: PPUSH
52953: CALL_OW 2
52957: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
52958: LD_ADDR_VAR 0 9
52962: PUSH
52963: LD_VAR 0 9
52967: PPUSH
52968: LD_INT 1
52970: PPUSH
52971: CALL_OW 3
52975: ST_TO_ADDR
// end ;
52976: GO 52922
52978: POP
52979: POP
// end else
52980: GO 53002
// if sort then
52982: LD_VAR 0 9
52986: IFFALSE 53002
// p := sort [ 1 ] ;
52988: LD_ADDR_VAR 0 11
52992: PUSH
52993: LD_VAR 0 9
52997: PUSH
52998: LD_INT 1
53000: ARRAY
53001: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53002: LD_ADDR_VAR 0 2
53006: PUSH
53007: LD_INT 0
53009: PUSH
53010: LD_INT 0
53012: PUSH
53013: LD_INT 0
53015: PUSH
53016: LD_VAR 0 11
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: LIST
53025: LIST
53026: ST_TO_ADDR
// exit ;
53027: GO 55248
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53029: LD_EXP 69
53033: PUSH
53034: LD_EXP 68
53038: PUSH
53039: LD_VAR 0 1
53043: ARRAY
53044: ARRAY
53045: PUSH
53046: LD_EXP 42
53050: PUSH
53051: LD_VAR 0 1
53055: ARRAY
53056: PPUSH
53057: LD_INT 2
53059: PUSH
53060: LD_INT 30
53062: PUSH
53063: LD_INT 6
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: PUSH
53070: LD_INT 30
53072: PUSH
53073: LD_INT 7
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: PUSH
53080: LD_INT 30
53082: PUSH
53083: LD_INT 8
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: PUSH
53090: EMPTY
53091: LIST
53092: LIST
53093: LIST
53094: LIST
53095: PPUSH
53096: CALL_OW 72
53100: AND
53101: PUSH
53102: LD_EXP 42
53106: PUSH
53107: LD_VAR 0 1
53111: ARRAY
53112: PPUSH
53113: LD_INT 30
53115: PUSH
53116: LD_INT 3
53118: PUSH
53119: EMPTY
53120: LIST
53121: LIST
53122: PPUSH
53123: CALL_OW 72
53127: AND
53128: IFFALSE 53862
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53130: LD_ADDR_EXP 84
53134: PUSH
53135: LD_EXP 84
53139: PPUSH
53140: LD_VAR 0 1
53144: PPUSH
53145: LD_INT 3
53147: PPUSH
53148: CALL_OW 1
53152: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53153: LD_ADDR_VAR 0 2
53157: PUSH
53158: LD_INT 0
53160: PUSH
53161: LD_INT 0
53163: PUSH
53164: LD_INT 0
53166: PUSH
53167: LD_INT 0
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: LIST
53174: LIST
53175: ST_TO_ADDR
// if not eng then
53176: LD_VAR 0 6
53180: NOT
53181: IFFALSE 53244
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53183: LD_ADDR_VAR 0 11
53187: PUSH
53188: LD_VAR 0 4
53192: PPUSH
53193: LD_INT 2
53195: PPUSH
53196: CALL 44299 0 2
53200: PUSH
53201: LD_INT 1
53203: ARRAY
53204: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53205: LD_ADDR_VAR 0 2
53209: PUSH
53210: LD_VAR 0 2
53214: PPUSH
53215: LD_INT 2
53217: PPUSH
53218: LD_VAR 0 11
53222: PPUSH
53223: CALL_OW 1
53227: ST_TO_ADDR
// tmp := tmp diff p ;
53228: LD_ADDR_VAR 0 4
53232: PUSH
53233: LD_VAR 0 4
53237: PUSH
53238: LD_VAR 0 11
53242: DIFF
53243: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53244: LD_VAR 0 4
53248: PUSH
53249: LD_VAR 0 8
53253: PUSH
53254: LD_INT 6
53256: LESS
53257: AND
53258: IFFALSE 53446
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53260: LD_ADDR_VAR 0 9
53264: PUSH
53265: LD_VAR 0 4
53269: PUSH
53270: LD_VAR 0 8
53274: PUSH
53275: LD_VAR 0 7
53279: UNION
53280: DIFF
53281: PPUSH
53282: LD_INT 4
53284: PPUSH
53285: CALL 44299 0 2
53289: ST_TO_ADDR
// p := [ ] ;
53290: LD_ADDR_VAR 0 11
53294: PUSH
53295: EMPTY
53296: ST_TO_ADDR
// if sort then
53297: LD_VAR 0 9
53301: IFFALSE 53417
// for i = 1 to 6 - sci do
53303: LD_ADDR_VAR 0 3
53307: PUSH
53308: DOUBLE
53309: LD_INT 1
53311: DEC
53312: ST_TO_ADDR
53313: LD_INT 6
53315: PUSH
53316: LD_VAR 0 8
53320: MINUS
53321: PUSH
53322: FOR_TO
53323: IFFALSE 53415
// begin if i = sort then
53325: LD_VAR 0 3
53329: PUSH
53330: LD_VAR 0 9
53334: EQUAL
53335: IFFALSE 53339
// break ;
53337: GO 53415
// if GetClass ( i ) = 4 then
53339: LD_VAR 0 3
53343: PPUSH
53344: CALL_OW 257
53348: PUSH
53349: LD_INT 4
53351: EQUAL
53352: IFFALSE 53356
// continue ;
53354: GO 53322
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53356: LD_ADDR_VAR 0 11
53360: PUSH
53361: LD_VAR 0 11
53365: PPUSH
53366: LD_VAR 0 11
53370: PUSH
53371: LD_INT 1
53373: PLUS
53374: PPUSH
53375: LD_VAR 0 9
53379: PUSH
53380: LD_VAR 0 3
53384: ARRAY
53385: PPUSH
53386: CALL_OW 2
53390: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53391: LD_ADDR_VAR 0 4
53395: PUSH
53396: LD_VAR 0 4
53400: PUSH
53401: LD_VAR 0 9
53405: PUSH
53406: LD_VAR 0 3
53410: ARRAY
53411: DIFF
53412: ST_TO_ADDR
// end ;
53413: GO 53322
53415: POP
53416: POP
// if p then
53417: LD_VAR 0 11
53421: IFFALSE 53446
// result := Replace ( result , 4 , p ) ;
53423: LD_ADDR_VAR 0 2
53427: PUSH
53428: LD_VAR 0 2
53432: PPUSH
53433: LD_INT 4
53435: PPUSH
53436: LD_VAR 0 11
53440: PPUSH
53441: CALL_OW 1
53445: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53446: LD_VAR 0 4
53450: PUSH
53451: LD_VAR 0 7
53455: PUSH
53456: LD_INT 6
53458: LESS
53459: AND
53460: IFFALSE 53648
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53462: LD_ADDR_VAR 0 9
53466: PUSH
53467: LD_VAR 0 4
53471: PUSH
53472: LD_VAR 0 8
53476: PUSH
53477: LD_VAR 0 7
53481: UNION
53482: DIFF
53483: PPUSH
53484: LD_INT 3
53486: PPUSH
53487: CALL 44299 0 2
53491: ST_TO_ADDR
// p := [ ] ;
53492: LD_ADDR_VAR 0 11
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// if sort then
53499: LD_VAR 0 9
53503: IFFALSE 53619
// for i = 1 to 6 - mech do
53505: LD_ADDR_VAR 0 3
53509: PUSH
53510: DOUBLE
53511: LD_INT 1
53513: DEC
53514: ST_TO_ADDR
53515: LD_INT 6
53517: PUSH
53518: LD_VAR 0 7
53522: MINUS
53523: PUSH
53524: FOR_TO
53525: IFFALSE 53617
// begin if i = sort then
53527: LD_VAR 0 3
53531: PUSH
53532: LD_VAR 0 9
53536: EQUAL
53537: IFFALSE 53541
// break ;
53539: GO 53617
// if GetClass ( i ) = 3 then
53541: LD_VAR 0 3
53545: PPUSH
53546: CALL_OW 257
53550: PUSH
53551: LD_INT 3
53553: EQUAL
53554: IFFALSE 53558
// continue ;
53556: GO 53524
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53558: LD_ADDR_VAR 0 11
53562: PUSH
53563: LD_VAR 0 11
53567: PPUSH
53568: LD_VAR 0 11
53572: PUSH
53573: LD_INT 1
53575: PLUS
53576: PPUSH
53577: LD_VAR 0 9
53581: PUSH
53582: LD_VAR 0 3
53586: ARRAY
53587: PPUSH
53588: CALL_OW 2
53592: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53593: LD_ADDR_VAR 0 4
53597: PUSH
53598: LD_VAR 0 4
53602: PUSH
53603: LD_VAR 0 9
53607: PUSH
53608: LD_VAR 0 3
53612: ARRAY
53613: DIFF
53614: ST_TO_ADDR
// end ;
53615: GO 53524
53617: POP
53618: POP
// if p then
53619: LD_VAR 0 11
53623: IFFALSE 53648
// result := Replace ( result , 3 , p ) ;
53625: LD_ADDR_VAR 0 2
53629: PUSH
53630: LD_VAR 0 2
53634: PPUSH
53635: LD_INT 3
53637: PPUSH
53638: LD_VAR 0 11
53642: PPUSH
53643: CALL_OW 1
53647: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53648: LD_VAR 0 4
53652: PUSH
53653: LD_INT 6
53655: GREATER
53656: PUSH
53657: LD_VAR 0 6
53661: PUSH
53662: LD_INT 6
53664: LESS
53665: AND
53666: IFFALSE 53860
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53668: LD_ADDR_VAR 0 9
53672: PUSH
53673: LD_VAR 0 4
53677: PUSH
53678: LD_VAR 0 8
53682: PUSH
53683: LD_VAR 0 7
53687: UNION
53688: PUSH
53689: LD_VAR 0 6
53693: UNION
53694: DIFF
53695: PPUSH
53696: LD_INT 2
53698: PPUSH
53699: CALL 44299 0 2
53703: ST_TO_ADDR
// p := [ ] ;
53704: LD_ADDR_VAR 0 11
53708: PUSH
53709: EMPTY
53710: ST_TO_ADDR
// if sort then
53711: LD_VAR 0 9
53715: IFFALSE 53831
// for i = 1 to 6 - eng do
53717: LD_ADDR_VAR 0 3
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_INT 6
53729: PUSH
53730: LD_VAR 0 6
53734: MINUS
53735: PUSH
53736: FOR_TO
53737: IFFALSE 53829
// begin if i = sort then
53739: LD_VAR 0 3
53743: PUSH
53744: LD_VAR 0 9
53748: EQUAL
53749: IFFALSE 53753
// break ;
53751: GO 53829
// if GetClass ( i ) = 2 then
53753: LD_VAR 0 3
53757: PPUSH
53758: CALL_OW 257
53762: PUSH
53763: LD_INT 2
53765: EQUAL
53766: IFFALSE 53770
// continue ;
53768: GO 53736
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53770: LD_ADDR_VAR 0 11
53774: PUSH
53775: LD_VAR 0 11
53779: PPUSH
53780: LD_VAR 0 11
53784: PUSH
53785: LD_INT 1
53787: PLUS
53788: PPUSH
53789: LD_VAR 0 9
53793: PUSH
53794: LD_VAR 0 3
53798: ARRAY
53799: PPUSH
53800: CALL_OW 2
53804: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53805: LD_ADDR_VAR 0 4
53809: PUSH
53810: LD_VAR 0 4
53814: PUSH
53815: LD_VAR 0 9
53819: PUSH
53820: LD_VAR 0 3
53824: ARRAY
53825: DIFF
53826: ST_TO_ADDR
// end ;
53827: GO 53736
53829: POP
53830: POP
// if p then
53831: LD_VAR 0 11
53835: IFFALSE 53860
// result := Replace ( result , 2 , p ) ;
53837: LD_ADDR_VAR 0 2
53841: PUSH
53842: LD_VAR 0 2
53846: PPUSH
53847: LD_INT 2
53849: PPUSH
53850: LD_VAR 0 11
53854: PPUSH
53855: CALL_OW 1
53859: ST_TO_ADDR
// end ; exit ;
53860: GO 55248
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
53862: LD_EXP 69
53866: PUSH
53867: LD_EXP 68
53871: PUSH
53872: LD_VAR 0 1
53876: ARRAY
53877: ARRAY
53878: NOT
53879: PUSH
53880: LD_EXP 42
53884: PUSH
53885: LD_VAR 0 1
53889: ARRAY
53890: PPUSH
53891: LD_INT 30
53893: PUSH
53894: LD_INT 3
53896: PUSH
53897: EMPTY
53898: LIST
53899: LIST
53900: PPUSH
53901: CALL_OW 72
53905: AND
53906: PUSH
53907: LD_EXP 47
53911: PUSH
53912: LD_VAR 0 1
53916: ARRAY
53917: AND
53918: IFFALSE 54526
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
53920: LD_ADDR_EXP 84
53924: PUSH
53925: LD_EXP 84
53929: PPUSH
53930: LD_VAR 0 1
53934: PPUSH
53935: LD_INT 5
53937: PPUSH
53938: CALL_OW 1
53942: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53943: LD_ADDR_VAR 0 2
53947: PUSH
53948: LD_INT 0
53950: PUSH
53951: LD_INT 0
53953: PUSH
53954: LD_INT 0
53956: PUSH
53957: LD_INT 0
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: LIST
53964: LIST
53965: ST_TO_ADDR
// if sci > 1 then
53966: LD_VAR 0 8
53970: PUSH
53971: LD_INT 1
53973: GREATER
53974: IFFALSE 54002
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
53976: LD_ADDR_VAR 0 4
53980: PUSH
53981: LD_VAR 0 4
53985: PUSH
53986: LD_VAR 0 8
53990: PUSH
53991: LD_VAR 0 8
53995: PUSH
53996: LD_INT 1
53998: ARRAY
53999: DIFF
54000: DIFF
54001: ST_TO_ADDR
// if tmp and not sci then
54002: LD_VAR 0 4
54006: PUSH
54007: LD_VAR 0 8
54011: NOT
54012: AND
54013: IFFALSE 54082
// begin sort := SortBySkill ( tmp , 4 ) ;
54015: LD_ADDR_VAR 0 9
54019: PUSH
54020: LD_VAR 0 4
54024: PPUSH
54025: LD_INT 4
54027: PPUSH
54028: CALL 44299 0 2
54032: ST_TO_ADDR
// if sort then
54033: LD_VAR 0 9
54037: IFFALSE 54053
// p := sort [ 1 ] ;
54039: LD_ADDR_VAR 0 11
54043: PUSH
54044: LD_VAR 0 9
54048: PUSH
54049: LD_INT 1
54051: ARRAY
54052: ST_TO_ADDR
// if p then
54053: LD_VAR 0 11
54057: IFFALSE 54082
// result := Replace ( result , 4 , p ) ;
54059: LD_ADDR_VAR 0 2
54063: PUSH
54064: LD_VAR 0 2
54068: PPUSH
54069: LD_INT 4
54071: PPUSH
54072: LD_VAR 0 11
54076: PPUSH
54077: CALL_OW 1
54081: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54082: LD_ADDR_VAR 0 4
54086: PUSH
54087: LD_VAR 0 4
54091: PUSH
54092: LD_VAR 0 7
54096: DIFF
54097: ST_TO_ADDR
// if tmp and mech < 6 then
54098: LD_VAR 0 4
54102: PUSH
54103: LD_VAR 0 7
54107: PUSH
54108: LD_INT 6
54110: LESS
54111: AND
54112: IFFALSE 54300
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54114: LD_ADDR_VAR 0 9
54118: PUSH
54119: LD_VAR 0 4
54123: PUSH
54124: LD_VAR 0 8
54128: PUSH
54129: LD_VAR 0 7
54133: UNION
54134: DIFF
54135: PPUSH
54136: LD_INT 3
54138: PPUSH
54139: CALL 44299 0 2
54143: ST_TO_ADDR
// p := [ ] ;
54144: LD_ADDR_VAR 0 11
54148: PUSH
54149: EMPTY
54150: ST_TO_ADDR
// if sort then
54151: LD_VAR 0 9
54155: IFFALSE 54271
// for i = 1 to 6 - mech do
54157: LD_ADDR_VAR 0 3
54161: PUSH
54162: DOUBLE
54163: LD_INT 1
54165: DEC
54166: ST_TO_ADDR
54167: LD_INT 6
54169: PUSH
54170: LD_VAR 0 7
54174: MINUS
54175: PUSH
54176: FOR_TO
54177: IFFALSE 54269
// begin if i = sort then
54179: LD_VAR 0 3
54183: PUSH
54184: LD_VAR 0 9
54188: EQUAL
54189: IFFALSE 54193
// break ;
54191: GO 54269
// if GetClass ( i ) = 3 then
54193: LD_VAR 0 3
54197: PPUSH
54198: CALL_OW 257
54202: PUSH
54203: LD_INT 3
54205: EQUAL
54206: IFFALSE 54210
// continue ;
54208: GO 54176
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54210: LD_ADDR_VAR 0 11
54214: PUSH
54215: LD_VAR 0 11
54219: PPUSH
54220: LD_VAR 0 11
54224: PUSH
54225: LD_INT 1
54227: PLUS
54228: PPUSH
54229: LD_VAR 0 9
54233: PUSH
54234: LD_VAR 0 3
54238: ARRAY
54239: PPUSH
54240: CALL_OW 2
54244: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54245: LD_ADDR_VAR 0 4
54249: PUSH
54250: LD_VAR 0 4
54254: PUSH
54255: LD_VAR 0 9
54259: PUSH
54260: LD_VAR 0 3
54264: ARRAY
54265: DIFF
54266: ST_TO_ADDR
// end ;
54267: GO 54176
54269: POP
54270: POP
// if p then
54271: LD_VAR 0 11
54275: IFFALSE 54300
// result := Replace ( result , 3 , p ) ;
54277: LD_ADDR_VAR 0 2
54281: PUSH
54282: LD_VAR 0 2
54286: PPUSH
54287: LD_INT 3
54289: PPUSH
54290: LD_VAR 0 11
54294: PPUSH
54295: CALL_OW 1
54299: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54300: LD_ADDR_VAR 0 4
54304: PUSH
54305: LD_VAR 0 4
54309: PUSH
54310: LD_VAR 0 6
54314: DIFF
54315: ST_TO_ADDR
// if tmp and eng < 6 then
54316: LD_VAR 0 4
54320: PUSH
54321: LD_VAR 0 6
54325: PUSH
54326: LD_INT 6
54328: LESS
54329: AND
54330: IFFALSE 54524
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54332: LD_ADDR_VAR 0 9
54336: PUSH
54337: LD_VAR 0 4
54341: PUSH
54342: LD_VAR 0 8
54346: PUSH
54347: LD_VAR 0 7
54351: UNION
54352: PUSH
54353: LD_VAR 0 6
54357: UNION
54358: DIFF
54359: PPUSH
54360: LD_INT 2
54362: PPUSH
54363: CALL 44299 0 2
54367: ST_TO_ADDR
// p := [ ] ;
54368: LD_ADDR_VAR 0 11
54372: PUSH
54373: EMPTY
54374: ST_TO_ADDR
// if sort then
54375: LD_VAR 0 9
54379: IFFALSE 54495
// for i = 1 to 6 - eng do
54381: LD_ADDR_VAR 0 3
54385: PUSH
54386: DOUBLE
54387: LD_INT 1
54389: DEC
54390: ST_TO_ADDR
54391: LD_INT 6
54393: PUSH
54394: LD_VAR 0 6
54398: MINUS
54399: PUSH
54400: FOR_TO
54401: IFFALSE 54493
// begin if i = sort then
54403: LD_VAR 0 3
54407: PUSH
54408: LD_VAR 0 9
54412: EQUAL
54413: IFFALSE 54417
// break ;
54415: GO 54493
// if GetClass ( i ) = 2 then
54417: LD_VAR 0 3
54421: PPUSH
54422: CALL_OW 257
54426: PUSH
54427: LD_INT 2
54429: EQUAL
54430: IFFALSE 54434
// continue ;
54432: GO 54400
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54434: LD_ADDR_VAR 0 11
54438: PUSH
54439: LD_VAR 0 11
54443: PPUSH
54444: LD_VAR 0 11
54448: PUSH
54449: LD_INT 1
54451: PLUS
54452: PPUSH
54453: LD_VAR 0 9
54457: PUSH
54458: LD_VAR 0 3
54462: ARRAY
54463: PPUSH
54464: CALL_OW 2
54468: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54469: LD_ADDR_VAR 0 4
54473: PUSH
54474: LD_VAR 0 4
54478: PUSH
54479: LD_VAR 0 9
54483: PUSH
54484: LD_VAR 0 3
54488: ARRAY
54489: DIFF
54490: ST_TO_ADDR
// end ;
54491: GO 54400
54493: POP
54494: POP
// if p then
54495: LD_VAR 0 11
54499: IFFALSE 54524
// result := Replace ( result , 2 , p ) ;
54501: LD_ADDR_VAR 0 2
54505: PUSH
54506: LD_VAR 0 2
54510: PPUSH
54511: LD_INT 2
54513: PPUSH
54514: LD_VAR 0 11
54518: PPUSH
54519: CALL_OW 1
54523: ST_TO_ADDR
// end ; exit ;
54524: GO 55248
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54526: LD_EXP 69
54530: PUSH
54531: LD_EXP 68
54535: PUSH
54536: LD_VAR 0 1
54540: ARRAY
54541: ARRAY
54542: NOT
54543: PUSH
54544: LD_EXP 42
54548: PUSH
54549: LD_VAR 0 1
54553: ARRAY
54554: PPUSH
54555: LD_INT 30
54557: PUSH
54558: LD_INT 3
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PPUSH
54565: CALL_OW 72
54569: AND
54570: PUSH
54571: LD_EXP 47
54575: PUSH
54576: LD_VAR 0 1
54580: ARRAY
54581: NOT
54582: AND
54583: IFFALSE 55248
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54585: LD_ADDR_EXP 84
54589: PUSH
54590: LD_EXP 84
54594: PPUSH
54595: LD_VAR 0 1
54599: PPUSH
54600: LD_INT 6
54602: PPUSH
54603: CALL_OW 1
54607: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54608: LD_ADDR_VAR 0 2
54612: PUSH
54613: LD_INT 0
54615: PUSH
54616: LD_INT 0
54618: PUSH
54619: LD_INT 0
54621: PUSH
54622: LD_INT 0
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: LIST
54629: LIST
54630: ST_TO_ADDR
// if sci >= 1 then
54631: LD_VAR 0 8
54635: PUSH
54636: LD_INT 1
54638: GREATEREQUAL
54639: IFFALSE 54661
// tmp := tmp diff sci [ 1 ] ;
54641: LD_ADDR_VAR 0 4
54645: PUSH
54646: LD_VAR 0 4
54650: PUSH
54651: LD_VAR 0 8
54655: PUSH
54656: LD_INT 1
54658: ARRAY
54659: DIFF
54660: ST_TO_ADDR
// if tmp and not sci then
54661: LD_VAR 0 4
54665: PUSH
54666: LD_VAR 0 8
54670: NOT
54671: AND
54672: IFFALSE 54741
// begin sort := SortBySkill ( tmp , 4 ) ;
54674: LD_ADDR_VAR 0 9
54678: PUSH
54679: LD_VAR 0 4
54683: PPUSH
54684: LD_INT 4
54686: PPUSH
54687: CALL 44299 0 2
54691: ST_TO_ADDR
// if sort then
54692: LD_VAR 0 9
54696: IFFALSE 54712
// p := sort [ 1 ] ;
54698: LD_ADDR_VAR 0 11
54702: PUSH
54703: LD_VAR 0 9
54707: PUSH
54708: LD_INT 1
54710: ARRAY
54711: ST_TO_ADDR
// if p then
54712: LD_VAR 0 11
54716: IFFALSE 54741
// result := Replace ( result , 4 , p ) ;
54718: LD_ADDR_VAR 0 2
54722: PUSH
54723: LD_VAR 0 2
54727: PPUSH
54728: LD_INT 4
54730: PPUSH
54731: LD_VAR 0 11
54735: PPUSH
54736: CALL_OW 1
54740: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54741: LD_ADDR_VAR 0 4
54745: PUSH
54746: LD_VAR 0 4
54750: PUSH
54751: LD_VAR 0 7
54755: DIFF
54756: ST_TO_ADDR
// if tmp and mech < 6 then
54757: LD_VAR 0 4
54761: PUSH
54762: LD_VAR 0 7
54766: PUSH
54767: LD_INT 6
54769: LESS
54770: AND
54771: IFFALSE 54953
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54773: LD_ADDR_VAR 0 9
54777: PUSH
54778: LD_VAR 0 4
54782: PUSH
54783: LD_VAR 0 7
54787: DIFF
54788: PPUSH
54789: LD_INT 3
54791: PPUSH
54792: CALL 44299 0 2
54796: ST_TO_ADDR
// p := [ ] ;
54797: LD_ADDR_VAR 0 11
54801: PUSH
54802: EMPTY
54803: ST_TO_ADDR
// if sort then
54804: LD_VAR 0 9
54808: IFFALSE 54924
// for i = 1 to 6 - mech do
54810: LD_ADDR_VAR 0 3
54814: PUSH
54815: DOUBLE
54816: LD_INT 1
54818: DEC
54819: ST_TO_ADDR
54820: LD_INT 6
54822: PUSH
54823: LD_VAR 0 7
54827: MINUS
54828: PUSH
54829: FOR_TO
54830: IFFALSE 54922
// begin if i = sort then
54832: LD_VAR 0 3
54836: PUSH
54837: LD_VAR 0 9
54841: EQUAL
54842: IFFALSE 54846
// break ;
54844: GO 54922
// if GetClass ( i ) = 3 then
54846: LD_VAR 0 3
54850: PPUSH
54851: CALL_OW 257
54855: PUSH
54856: LD_INT 3
54858: EQUAL
54859: IFFALSE 54863
// continue ;
54861: GO 54829
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54863: LD_ADDR_VAR 0 11
54867: PUSH
54868: LD_VAR 0 11
54872: PPUSH
54873: LD_VAR 0 11
54877: PUSH
54878: LD_INT 1
54880: PLUS
54881: PPUSH
54882: LD_VAR 0 9
54886: PUSH
54887: LD_VAR 0 3
54891: ARRAY
54892: PPUSH
54893: CALL_OW 2
54897: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54898: LD_ADDR_VAR 0 4
54902: PUSH
54903: LD_VAR 0 4
54907: PUSH
54908: LD_VAR 0 9
54912: PUSH
54913: LD_VAR 0 3
54917: ARRAY
54918: DIFF
54919: ST_TO_ADDR
// end ;
54920: GO 54829
54922: POP
54923: POP
// if p then
54924: LD_VAR 0 11
54928: IFFALSE 54953
// result := Replace ( result , 3 , p ) ;
54930: LD_ADDR_VAR 0 2
54934: PUSH
54935: LD_VAR 0 2
54939: PPUSH
54940: LD_INT 3
54942: PPUSH
54943: LD_VAR 0 11
54947: PPUSH
54948: CALL_OW 1
54952: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54953: LD_ADDR_VAR 0 4
54957: PUSH
54958: LD_VAR 0 4
54962: PUSH
54963: LD_VAR 0 6
54967: DIFF
54968: ST_TO_ADDR
// if tmp and eng < 4 then
54969: LD_VAR 0 4
54973: PUSH
54974: LD_VAR 0 6
54978: PUSH
54979: LD_INT 4
54981: LESS
54982: AND
54983: IFFALSE 55173
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
54985: LD_ADDR_VAR 0 9
54989: PUSH
54990: LD_VAR 0 4
54994: PUSH
54995: LD_VAR 0 7
54999: PUSH
55000: LD_VAR 0 6
55004: UNION
55005: DIFF
55006: PPUSH
55007: LD_INT 2
55009: PPUSH
55010: CALL 44299 0 2
55014: ST_TO_ADDR
// p := [ ] ;
55015: LD_ADDR_VAR 0 11
55019: PUSH
55020: EMPTY
55021: ST_TO_ADDR
// if sort then
55022: LD_VAR 0 9
55026: IFFALSE 55142
// for i = 1 to 4 - eng do
55028: LD_ADDR_VAR 0 3
55032: PUSH
55033: DOUBLE
55034: LD_INT 1
55036: DEC
55037: ST_TO_ADDR
55038: LD_INT 4
55040: PUSH
55041: LD_VAR 0 6
55045: MINUS
55046: PUSH
55047: FOR_TO
55048: IFFALSE 55140
// begin if i = sort then
55050: LD_VAR 0 3
55054: PUSH
55055: LD_VAR 0 9
55059: EQUAL
55060: IFFALSE 55064
// break ;
55062: GO 55140
// if GetClass ( i ) = 2 then
55064: LD_VAR 0 3
55068: PPUSH
55069: CALL_OW 257
55073: PUSH
55074: LD_INT 2
55076: EQUAL
55077: IFFALSE 55081
// continue ;
55079: GO 55047
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55081: LD_ADDR_VAR 0 11
55085: PUSH
55086: LD_VAR 0 11
55090: PPUSH
55091: LD_VAR 0 11
55095: PUSH
55096: LD_INT 1
55098: PLUS
55099: PPUSH
55100: LD_VAR 0 9
55104: PUSH
55105: LD_VAR 0 3
55109: ARRAY
55110: PPUSH
55111: CALL_OW 2
55115: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55116: LD_ADDR_VAR 0 4
55120: PUSH
55121: LD_VAR 0 4
55125: PUSH
55126: LD_VAR 0 9
55130: PUSH
55131: LD_VAR 0 3
55135: ARRAY
55136: DIFF
55137: ST_TO_ADDR
// end ;
55138: GO 55047
55140: POP
55141: POP
// if p then
55142: LD_VAR 0 11
55146: IFFALSE 55171
// result := Replace ( result , 2 , p ) ;
55148: LD_ADDR_VAR 0 2
55152: PUSH
55153: LD_VAR 0 2
55157: PPUSH
55158: LD_INT 2
55160: PPUSH
55161: LD_VAR 0 11
55165: PPUSH
55166: CALL_OW 1
55170: ST_TO_ADDR
// end else
55171: GO 55217
// for i = eng downto 5 do
55173: LD_ADDR_VAR 0 3
55177: PUSH
55178: DOUBLE
55179: LD_VAR 0 6
55183: INC
55184: ST_TO_ADDR
55185: LD_INT 5
55187: PUSH
55188: FOR_DOWNTO
55189: IFFALSE 55215
// tmp := tmp union eng [ i ] ;
55191: LD_ADDR_VAR 0 4
55195: PUSH
55196: LD_VAR 0 4
55200: PUSH
55201: LD_VAR 0 6
55205: PUSH
55206: LD_VAR 0 3
55210: ARRAY
55211: UNION
55212: ST_TO_ADDR
55213: GO 55188
55215: POP
55216: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55217: LD_ADDR_VAR 0 2
55221: PUSH
55222: LD_VAR 0 2
55226: PPUSH
55227: LD_INT 1
55229: PPUSH
55230: LD_VAR 0 4
55234: PUSH
55235: LD_VAR 0 5
55239: DIFF
55240: PPUSH
55241: CALL_OW 1
55245: ST_TO_ADDR
// exit ;
55246: GO 55248
// end ; end ;
55248: LD_VAR 0 2
55252: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55253: LD_INT 0
55255: PPUSH
55256: PPUSH
55257: PPUSH
// if not mc_bases then
55258: LD_EXP 42
55262: NOT
55263: IFFALSE 55267
// exit ;
55265: GO 55373
// for i = 1 to mc_bases do
55267: LD_ADDR_VAR 0 2
55271: PUSH
55272: DOUBLE
55273: LD_INT 1
55275: DEC
55276: ST_TO_ADDR
55277: LD_EXP 42
55281: PUSH
55282: FOR_TO
55283: IFFALSE 55364
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55285: LD_ADDR_VAR 0 3
55289: PUSH
55290: LD_EXP 42
55294: PUSH
55295: LD_VAR 0 2
55299: ARRAY
55300: PPUSH
55301: LD_INT 21
55303: PUSH
55304: LD_INT 3
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: PUSH
55311: LD_INT 3
55313: PUSH
55314: LD_INT 24
55316: PUSH
55317: LD_INT 1000
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: PUSH
55324: EMPTY
55325: LIST
55326: LIST
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: CALL_OW 72
55336: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55337: LD_ADDR_EXP 43
55341: PUSH
55342: LD_EXP 43
55346: PPUSH
55347: LD_VAR 0 2
55351: PPUSH
55352: LD_VAR 0 3
55356: PPUSH
55357: CALL_OW 1
55361: ST_TO_ADDR
// end ;
55362: GO 55282
55364: POP
55365: POP
// RaiseSailEvent ( 101 ) ;
55366: LD_INT 101
55368: PPUSH
55369: CALL_OW 427
// end ;
55373: LD_VAR 0 1
55377: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55378: LD_INT 0
55380: PPUSH
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
55386: PPUSH
// if not mc_bases then
55387: LD_EXP 42
55391: NOT
55392: IFFALSE 55396
// exit ;
55394: GO 55958
// for i = 1 to mc_bases do
55396: LD_ADDR_VAR 0 2
55400: PUSH
55401: DOUBLE
55402: LD_INT 1
55404: DEC
55405: ST_TO_ADDR
55406: LD_EXP 42
55410: PUSH
55411: FOR_TO
55412: IFFALSE 55949
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
55414: LD_ADDR_VAR 0 5
55418: PUSH
55419: LD_EXP 42
55423: PUSH
55424: LD_VAR 0 2
55428: ARRAY
55429: PUSH
55430: LD_EXP 71
55434: PUSH
55435: LD_VAR 0 2
55439: ARRAY
55440: UNION
55441: PPUSH
55442: LD_INT 21
55444: PUSH
55445: LD_INT 1
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: PUSH
55452: LD_INT 1
55454: PUSH
55455: LD_INT 3
55457: PUSH
55458: LD_INT 54
55460: PUSH
55461: EMPTY
55462: LIST
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: PUSH
55468: LD_INT 3
55470: PUSH
55471: LD_INT 24
55473: PUSH
55474: LD_INT 800
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: PUSH
55481: EMPTY
55482: LIST
55483: LIST
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: LIST
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PPUSH
55494: CALL_OW 72
55498: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55499: LD_ADDR_VAR 0 6
55503: PUSH
55504: LD_EXP 42
55508: PUSH
55509: LD_VAR 0 2
55513: ARRAY
55514: PPUSH
55515: LD_INT 21
55517: PUSH
55518: LD_INT 1
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: LD_INT 1
55527: PUSH
55528: LD_INT 3
55530: PUSH
55531: LD_INT 54
55533: PUSH
55534: EMPTY
55535: LIST
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: PUSH
55541: LD_INT 3
55543: PUSH
55544: LD_INT 24
55546: PUSH
55547: LD_INT 250
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: PUSH
55558: EMPTY
55559: LIST
55560: LIST
55561: LIST
55562: PUSH
55563: EMPTY
55564: LIST
55565: LIST
55566: PPUSH
55567: CALL_OW 72
55571: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55572: LD_ADDR_VAR 0 7
55576: PUSH
55577: LD_VAR 0 5
55581: PUSH
55582: LD_VAR 0 6
55586: DIFF
55587: ST_TO_ADDR
// if not need_heal_1 then
55588: LD_VAR 0 6
55592: NOT
55593: IFFALSE 55626
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55595: LD_ADDR_EXP 45
55599: PUSH
55600: LD_EXP 45
55604: PPUSH
55605: LD_VAR 0 2
55609: PUSH
55610: LD_INT 1
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PPUSH
55617: EMPTY
55618: PPUSH
55619: CALL 14750 0 3
55623: ST_TO_ADDR
55624: GO 55696
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55626: LD_ADDR_EXP 45
55630: PUSH
55631: LD_EXP 45
55635: PPUSH
55636: LD_VAR 0 2
55640: PUSH
55641: LD_INT 1
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: PPUSH
55648: LD_EXP 45
55652: PUSH
55653: LD_VAR 0 2
55657: ARRAY
55658: PUSH
55659: LD_INT 1
55661: ARRAY
55662: PPUSH
55663: LD_INT 3
55665: PUSH
55666: LD_INT 24
55668: PUSH
55669: LD_INT 1000
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: PPUSH
55680: CALL_OW 72
55684: PUSH
55685: LD_VAR 0 6
55689: UNION
55690: PPUSH
55691: CALL 14750 0 3
55695: ST_TO_ADDR
// if not need_heal_2 then
55696: LD_VAR 0 7
55700: NOT
55701: IFFALSE 55734
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55703: LD_ADDR_EXP 45
55707: PUSH
55708: LD_EXP 45
55712: PPUSH
55713: LD_VAR 0 2
55717: PUSH
55718: LD_INT 2
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PPUSH
55725: EMPTY
55726: PPUSH
55727: CALL 14750 0 3
55731: ST_TO_ADDR
55732: GO 55766
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55734: LD_ADDR_EXP 45
55738: PUSH
55739: LD_EXP 45
55743: PPUSH
55744: LD_VAR 0 2
55748: PUSH
55749: LD_INT 2
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: PPUSH
55756: LD_VAR 0 7
55760: PPUSH
55761: CALL 14750 0 3
55765: ST_TO_ADDR
// if need_heal_2 then
55766: LD_VAR 0 7
55770: IFFALSE 55931
// for j in need_heal_2 do
55772: LD_ADDR_VAR 0 3
55776: PUSH
55777: LD_VAR 0 7
55781: PUSH
55782: FOR_IN
55783: IFFALSE 55929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55785: LD_ADDR_VAR 0 5
55789: PUSH
55790: LD_EXP 42
55794: PUSH
55795: LD_VAR 0 2
55799: ARRAY
55800: PPUSH
55801: LD_INT 2
55803: PUSH
55804: LD_INT 30
55806: PUSH
55807: LD_INT 6
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: LD_INT 30
55816: PUSH
55817: LD_INT 7
55819: PUSH
55820: EMPTY
55821: LIST
55822: LIST
55823: PUSH
55824: LD_INT 30
55826: PUSH
55827: LD_INT 8
55829: PUSH
55830: EMPTY
55831: LIST
55832: LIST
55833: PUSH
55834: LD_INT 30
55836: PUSH
55837: LD_INT 0
55839: PUSH
55840: EMPTY
55841: LIST
55842: LIST
55843: PUSH
55844: LD_INT 30
55846: PUSH
55847: LD_INT 1
55849: PUSH
55850: EMPTY
55851: LIST
55852: LIST
55853: PUSH
55854: EMPTY
55855: LIST
55856: LIST
55857: LIST
55858: LIST
55859: LIST
55860: LIST
55861: PPUSH
55862: CALL_OW 72
55866: ST_TO_ADDR
// if tmp then
55867: LD_VAR 0 5
55871: IFFALSE 55927
// begin k := NearestUnitToUnit ( tmp , j ) ;
55873: LD_ADDR_VAR 0 4
55877: PUSH
55878: LD_VAR 0 5
55882: PPUSH
55883: LD_VAR 0 3
55887: PPUSH
55888: CALL_OW 74
55892: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
55893: LD_VAR 0 3
55897: PPUSH
55898: LD_VAR 0 4
55902: PPUSH
55903: CALL_OW 296
55907: PUSH
55908: LD_INT 5
55910: GREATER
55911: IFFALSE 55927
// ComMoveToNearbyEntrance ( j , k ) ;
55913: LD_VAR 0 3
55917: PPUSH
55918: LD_VAR 0 4
55922: PPUSH
55923: CALL 46616 0 2
// end ; end ;
55927: GO 55782
55929: POP
55930: POP
// if not need_heal_1 and not need_heal_2 then
55931: LD_VAR 0 6
55935: NOT
55936: PUSH
55937: LD_VAR 0 7
55941: NOT
55942: AND
55943: IFFALSE 55947
// continue ;
55945: GO 55411
// end ;
55947: GO 55411
55949: POP
55950: POP
// RaiseSailEvent ( 102 ) ;
55951: LD_INT 102
55953: PPUSH
55954: CALL_OW 427
// end ;
55958: LD_VAR 0 1
55962: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
55963: LD_INT 0
55965: PPUSH
55966: PPUSH
55967: PPUSH
55968: PPUSH
55969: PPUSH
55970: PPUSH
55971: PPUSH
55972: PPUSH
// if not mc_bases then
55973: LD_EXP 42
55977: NOT
55978: IFFALSE 55982
// exit ;
55980: GO 56843
// for i = 1 to mc_bases do
55982: LD_ADDR_VAR 0 2
55986: PUSH
55987: DOUBLE
55988: LD_INT 1
55990: DEC
55991: ST_TO_ADDR
55992: LD_EXP 42
55996: PUSH
55997: FOR_TO
55998: IFFALSE 56841
// begin if not mc_building_need_repair [ i ] then
56000: LD_EXP 43
56004: PUSH
56005: LD_VAR 0 2
56009: ARRAY
56010: NOT
56011: IFFALSE 56198
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56013: LD_ADDR_VAR 0 6
56017: PUSH
56018: LD_EXP 61
56022: PUSH
56023: LD_VAR 0 2
56027: ARRAY
56028: PPUSH
56029: LD_INT 3
56031: PUSH
56032: LD_INT 24
56034: PUSH
56035: LD_INT 1000
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: PUSH
56046: LD_INT 2
56048: PUSH
56049: LD_INT 34
56051: PUSH
56052: LD_INT 13
56054: PUSH
56055: EMPTY
56056: LIST
56057: LIST
56058: PUSH
56059: LD_INT 34
56061: PUSH
56062: LD_INT 52
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: PUSH
56069: LD_INT 34
56071: PUSH
56072: LD_EXP 91
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: LIST
56086: PUSH
56087: EMPTY
56088: LIST
56089: LIST
56090: PPUSH
56091: CALL_OW 72
56095: ST_TO_ADDR
// if cranes then
56096: LD_VAR 0 6
56100: IFFALSE 56162
// for j in cranes do
56102: LD_ADDR_VAR 0 3
56106: PUSH
56107: LD_VAR 0 6
56111: PUSH
56112: FOR_IN
56113: IFFALSE 56160
// if not IsInArea ( j , mc_parking [ i ] ) then
56115: LD_VAR 0 3
56119: PPUSH
56120: LD_EXP 66
56124: PUSH
56125: LD_VAR 0 2
56129: ARRAY
56130: PPUSH
56131: CALL_OW 308
56135: NOT
56136: IFFALSE 56158
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56138: LD_VAR 0 3
56142: PPUSH
56143: LD_EXP 66
56147: PUSH
56148: LD_VAR 0 2
56152: ARRAY
56153: PPUSH
56154: CALL_OW 113
56158: GO 56112
56160: POP
56161: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56162: LD_ADDR_EXP 44
56166: PUSH
56167: LD_EXP 44
56171: PPUSH
56172: LD_VAR 0 2
56176: PPUSH
56177: EMPTY
56178: PPUSH
56179: CALL_OW 1
56183: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56184: LD_VAR 0 2
56188: PPUSH
56189: LD_INT 101
56191: PPUSH
56192: CALL 51086 0 2
// continue ;
56196: GO 55997
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56198: LD_ADDR_EXP 48
56202: PUSH
56203: LD_EXP 48
56207: PPUSH
56208: LD_VAR 0 2
56212: PPUSH
56213: EMPTY
56214: PPUSH
56215: CALL_OW 1
56219: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56220: LD_VAR 0 2
56224: PPUSH
56225: LD_INT 103
56227: PPUSH
56228: CALL 51086 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56232: LD_ADDR_VAR 0 5
56236: PUSH
56237: LD_EXP 42
56241: PUSH
56242: LD_VAR 0 2
56246: ARRAY
56247: PUSH
56248: LD_EXP 71
56252: PUSH
56253: LD_VAR 0 2
56257: ARRAY
56258: UNION
56259: PPUSH
56260: LD_INT 2
56262: PUSH
56263: LD_INT 25
56265: PUSH
56266: LD_INT 2
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: PUSH
56273: LD_INT 25
56275: PUSH
56276: LD_INT 16
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: LIST
56287: PUSH
56288: EMPTY
56289: LIST
56290: PPUSH
56291: CALL_OW 72
56295: PUSH
56296: LD_EXP 45
56300: PUSH
56301: LD_VAR 0 2
56305: ARRAY
56306: PUSH
56307: LD_INT 1
56309: ARRAY
56310: PUSH
56311: LD_EXP 45
56315: PUSH
56316: LD_VAR 0 2
56320: ARRAY
56321: PUSH
56322: LD_INT 2
56324: ARRAY
56325: UNION
56326: DIFF
56327: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56328: LD_ADDR_VAR 0 6
56332: PUSH
56333: LD_EXP 61
56337: PUSH
56338: LD_VAR 0 2
56342: ARRAY
56343: PPUSH
56344: LD_INT 2
56346: PUSH
56347: LD_INT 34
56349: PUSH
56350: LD_INT 13
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: PUSH
56357: LD_INT 34
56359: PUSH
56360: LD_INT 52
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: PUSH
56367: LD_INT 34
56369: PUSH
56370: LD_EXP 91
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: PUSH
56379: EMPTY
56380: LIST
56381: LIST
56382: LIST
56383: LIST
56384: PPUSH
56385: CALL_OW 72
56389: ST_TO_ADDR
// if cranes then
56390: LD_VAR 0 6
56394: IFFALSE 56530
// begin for j in cranes do
56396: LD_ADDR_VAR 0 3
56400: PUSH
56401: LD_VAR 0 6
56405: PUSH
56406: FOR_IN
56407: IFFALSE 56528
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56409: LD_VAR 0 3
56413: PPUSH
56414: CALL_OW 256
56418: PUSH
56419: LD_INT 1000
56421: EQUAL
56422: PUSH
56423: LD_VAR 0 3
56427: PPUSH
56428: CALL_OW 314
56432: NOT
56433: AND
56434: IFFALSE 56468
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56436: LD_VAR 0 3
56440: PPUSH
56441: LD_EXP 43
56445: PUSH
56446: LD_VAR 0 2
56450: ARRAY
56451: PPUSH
56452: LD_VAR 0 3
56456: PPUSH
56457: CALL_OW 74
56461: PPUSH
56462: CALL_OW 130
56466: GO 56526
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56468: LD_VAR 0 3
56472: PPUSH
56473: CALL_OW 256
56477: PUSH
56478: LD_INT 500
56480: LESS
56481: PUSH
56482: LD_VAR 0 3
56486: PPUSH
56487: LD_EXP 66
56491: PUSH
56492: LD_VAR 0 2
56496: ARRAY
56497: PPUSH
56498: CALL_OW 308
56502: NOT
56503: AND
56504: IFFALSE 56526
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56506: LD_VAR 0 3
56510: PPUSH
56511: LD_EXP 66
56515: PUSH
56516: LD_VAR 0 2
56520: ARRAY
56521: PPUSH
56522: CALL_OW 113
// end ;
56526: GO 56406
56528: POP
56529: POP
// end ; if tmp > 3 then
56530: LD_VAR 0 5
56534: PUSH
56535: LD_INT 3
56537: GREATER
56538: IFFALSE 56558
// tmp := ShrinkArray ( tmp , 4 ) ;
56540: LD_ADDR_VAR 0 5
56544: PUSH
56545: LD_VAR 0 5
56549: PPUSH
56550: LD_INT 4
56552: PPUSH
56553: CALL 46108 0 2
56557: ST_TO_ADDR
// if not tmp then
56558: LD_VAR 0 5
56562: NOT
56563: IFFALSE 56567
// continue ;
56565: GO 55997
// for j in tmp do
56567: LD_ADDR_VAR 0 3
56571: PUSH
56572: LD_VAR 0 5
56576: PUSH
56577: FOR_IN
56578: IFFALSE 56837
// begin if IsInUnit ( j ) then
56580: LD_VAR 0 3
56584: PPUSH
56585: CALL_OW 310
56589: IFFALSE 56600
// ComExitBuilding ( j ) ;
56591: LD_VAR 0 3
56595: PPUSH
56596: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56600: LD_VAR 0 3
56604: PUSH
56605: LD_EXP 44
56609: PUSH
56610: LD_VAR 0 2
56614: ARRAY
56615: IN
56616: NOT
56617: IFFALSE 56675
// begin SetTag ( j , 101 ) ;
56619: LD_VAR 0 3
56623: PPUSH
56624: LD_INT 101
56626: PPUSH
56627: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56631: LD_ADDR_EXP 44
56635: PUSH
56636: LD_EXP 44
56640: PPUSH
56641: LD_VAR 0 2
56645: PUSH
56646: LD_EXP 44
56650: PUSH
56651: LD_VAR 0 2
56655: ARRAY
56656: PUSH
56657: LD_INT 1
56659: PLUS
56660: PUSH
56661: EMPTY
56662: LIST
56663: LIST
56664: PPUSH
56665: LD_VAR 0 3
56669: PPUSH
56670: CALL 14750 0 3
56674: ST_TO_ADDR
// end ; wait ( 1 ) ;
56675: LD_INT 1
56677: PPUSH
56678: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56682: LD_ADDR_VAR 0 7
56686: PUSH
56687: LD_EXP 43
56691: PUSH
56692: LD_VAR 0 2
56696: ARRAY
56697: ST_TO_ADDR
// if mc_scan [ i ] then
56698: LD_EXP 65
56702: PUSH
56703: LD_VAR 0 2
56707: ARRAY
56708: IFFALSE 56770
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56710: LD_ADDR_VAR 0 7
56714: PUSH
56715: LD_EXP 43
56719: PUSH
56720: LD_VAR 0 2
56724: ARRAY
56725: PPUSH
56726: LD_INT 3
56728: PUSH
56729: LD_INT 30
56731: PUSH
56732: LD_INT 32
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: PUSH
56739: LD_INT 30
56741: PUSH
56742: LD_INT 33
56744: PUSH
56745: EMPTY
56746: LIST
56747: LIST
56748: PUSH
56749: LD_INT 30
56751: PUSH
56752: LD_INT 31
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: PUSH
56759: EMPTY
56760: LIST
56761: LIST
56762: LIST
56763: LIST
56764: PPUSH
56765: CALL_OW 72
56769: ST_TO_ADDR
// if not to_repair_tmp then
56770: LD_VAR 0 7
56774: NOT
56775: IFFALSE 56779
// continue ;
56777: GO 56577
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56779: LD_ADDR_VAR 0 8
56783: PUSH
56784: LD_VAR 0 7
56788: PPUSH
56789: LD_VAR 0 3
56793: PPUSH
56794: CALL_OW 74
56798: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56799: LD_VAR 0 8
56803: PPUSH
56804: LD_INT 16
56806: PPUSH
56807: CALL 17343 0 2
56811: PUSH
56812: LD_INT 4
56814: ARRAY
56815: PUSH
56816: LD_INT 10
56818: LESS
56819: IFFALSE 56835
// ComRepairBuilding ( j , to_repair ) ;
56821: LD_VAR 0 3
56825: PPUSH
56826: LD_VAR 0 8
56830: PPUSH
56831: CALL_OW 130
// end ;
56835: GO 56577
56837: POP
56838: POP
// end ;
56839: GO 55997
56841: POP
56842: POP
// end ;
56843: LD_VAR 0 1
56847: RET
// export function MC_Heal ; var i , j , tmp ; begin
56848: LD_INT 0
56850: PPUSH
56851: PPUSH
56852: PPUSH
56853: PPUSH
// if not mc_bases then
56854: LD_EXP 42
56858: NOT
56859: IFFALSE 56863
// exit ;
56861: GO 57265
// for i = 1 to mc_bases do
56863: LD_ADDR_VAR 0 2
56867: PUSH
56868: DOUBLE
56869: LD_INT 1
56871: DEC
56872: ST_TO_ADDR
56873: LD_EXP 42
56877: PUSH
56878: FOR_TO
56879: IFFALSE 57263
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
56881: LD_EXP 45
56885: PUSH
56886: LD_VAR 0 2
56890: ARRAY
56891: PUSH
56892: LD_INT 1
56894: ARRAY
56895: NOT
56896: PUSH
56897: LD_EXP 45
56901: PUSH
56902: LD_VAR 0 2
56906: ARRAY
56907: PUSH
56908: LD_INT 2
56910: ARRAY
56911: NOT
56912: AND
56913: IFFALSE 56951
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
56915: LD_ADDR_EXP 46
56919: PUSH
56920: LD_EXP 46
56924: PPUSH
56925: LD_VAR 0 2
56929: PPUSH
56930: EMPTY
56931: PPUSH
56932: CALL_OW 1
56936: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
56937: LD_VAR 0 2
56941: PPUSH
56942: LD_INT 102
56944: PPUSH
56945: CALL 51086 0 2
// continue ;
56949: GO 56878
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56951: LD_ADDR_VAR 0 4
56955: PUSH
56956: LD_EXP 42
56960: PUSH
56961: LD_VAR 0 2
56965: ARRAY
56966: PPUSH
56967: LD_INT 25
56969: PUSH
56970: LD_INT 4
56972: PUSH
56973: EMPTY
56974: LIST
56975: LIST
56976: PPUSH
56977: CALL_OW 72
56981: ST_TO_ADDR
// if not tmp then
56982: LD_VAR 0 4
56986: NOT
56987: IFFALSE 56991
// continue ;
56989: GO 56878
// if mc_taming [ i ] then
56991: LD_EXP 73
56995: PUSH
56996: LD_VAR 0 2
57000: ARRAY
57001: IFFALSE 57025
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57003: LD_ADDR_EXP 73
57007: PUSH
57008: LD_EXP 73
57012: PPUSH
57013: LD_VAR 0 2
57017: PPUSH
57018: EMPTY
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// for j in tmp do
57025: LD_ADDR_VAR 0 3
57029: PUSH
57030: LD_VAR 0 4
57034: PUSH
57035: FOR_IN
57036: IFFALSE 57259
// begin if IsInUnit ( j ) then
57038: LD_VAR 0 3
57042: PPUSH
57043: CALL_OW 310
57047: IFFALSE 57058
// ComExitBuilding ( j ) ;
57049: LD_VAR 0 3
57053: PPUSH
57054: CALL_OW 122
// if not j in mc_healers [ i ] then
57058: LD_VAR 0 3
57062: PUSH
57063: LD_EXP 46
57067: PUSH
57068: LD_VAR 0 2
57072: ARRAY
57073: IN
57074: NOT
57075: IFFALSE 57121
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57077: LD_ADDR_EXP 46
57081: PUSH
57082: LD_EXP 46
57086: PPUSH
57087: LD_VAR 0 2
57091: PUSH
57092: LD_EXP 46
57096: PUSH
57097: LD_VAR 0 2
57101: ARRAY
57102: PUSH
57103: LD_INT 1
57105: PLUS
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: PPUSH
57111: LD_VAR 0 3
57115: PPUSH
57116: CALL 14750 0 3
57120: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57121: LD_VAR 0 3
57125: PPUSH
57126: CALL_OW 110
57130: PUSH
57131: LD_INT 102
57133: NONEQUAL
57134: IFFALSE 57148
// SetTag ( j , 102 ) ;
57136: LD_VAR 0 3
57140: PPUSH
57141: LD_INT 102
57143: PPUSH
57144: CALL_OW 109
// Wait ( 3 ) ;
57148: LD_INT 3
57150: PPUSH
57151: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57155: LD_EXP 45
57159: PUSH
57160: LD_VAR 0 2
57164: ARRAY
57165: PUSH
57166: LD_INT 1
57168: ARRAY
57169: IFFALSE 57201
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57171: LD_VAR 0 3
57175: PPUSH
57176: LD_EXP 45
57180: PUSH
57181: LD_VAR 0 2
57185: ARRAY
57186: PUSH
57187: LD_INT 1
57189: ARRAY
57190: PUSH
57191: LD_INT 1
57193: ARRAY
57194: PPUSH
57195: CALL_OW 128
57199: GO 57257
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57201: LD_VAR 0 3
57205: PPUSH
57206: CALL_OW 314
57210: NOT
57211: PUSH
57212: LD_EXP 45
57216: PUSH
57217: LD_VAR 0 2
57221: ARRAY
57222: PUSH
57223: LD_INT 2
57225: ARRAY
57226: AND
57227: IFFALSE 57257
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57229: LD_VAR 0 3
57233: PPUSH
57234: LD_EXP 45
57238: PUSH
57239: LD_VAR 0 2
57243: ARRAY
57244: PUSH
57245: LD_INT 2
57247: ARRAY
57248: PUSH
57249: LD_INT 1
57251: ARRAY
57252: PPUSH
57253: CALL_OW 128
// end ;
57257: GO 57035
57259: POP
57260: POP
// end ;
57261: GO 56878
57263: POP
57264: POP
// end ;
57265: LD_VAR 0 1
57269: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57270: LD_INT 0
57272: PPUSH
57273: PPUSH
57274: PPUSH
57275: PPUSH
57276: PPUSH
// if not mc_bases then
57277: LD_EXP 42
57281: NOT
57282: IFFALSE 57286
// exit ;
57284: GO 58429
// for i = 1 to mc_bases do
57286: LD_ADDR_VAR 0 2
57290: PUSH
57291: DOUBLE
57292: LD_INT 1
57294: DEC
57295: ST_TO_ADDR
57296: LD_EXP 42
57300: PUSH
57301: FOR_TO
57302: IFFALSE 58427
// begin if mc_scan [ i ] then
57304: LD_EXP 65
57308: PUSH
57309: LD_VAR 0 2
57313: ARRAY
57314: IFFALSE 57318
// continue ;
57316: GO 57301
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57318: LD_EXP 47
57322: PUSH
57323: LD_VAR 0 2
57327: ARRAY
57328: NOT
57329: PUSH
57330: LD_EXP 49
57334: PUSH
57335: LD_VAR 0 2
57339: ARRAY
57340: NOT
57341: AND
57342: PUSH
57343: LD_EXP 48
57347: PUSH
57348: LD_VAR 0 2
57352: ARRAY
57353: AND
57354: IFFALSE 57392
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57356: LD_ADDR_EXP 48
57360: PUSH
57361: LD_EXP 48
57365: PPUSH
57366: LD_VAR 0 2
57370: PPUSH
57371: EMPTY
57372: PPUSH
57373: CALL_OW 1
57377: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57378: LD_VAR 0 2
57382: PPUSH
57383: LD_INT 103
57385: PPUSH
57386: CALL 51086 0 2
// continue ;
57390: GO 57301
// end ; if mc_construct_list [ i ] then
57392: LD_EXP 49
57396: PUSH
57397: LD_VAR 0 2
57401: ARRAY
57402: IFFALSE 57622
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57404: LD_ADDR_VAR 0 4
57408: PUSH
57409: LD_EXP 42
57413: PUSH
57414: LD_VAR 0 2
57418: ARRAY
57419: PPUSH
57420: LD_INT 25
57422: PUSH
57423: LD_INT 2
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: PPUSH
57430: CALL_OW 72
57434: PUSH
57435: LD_EXP 44
57439: PUSH
57440: LD_VAR 0 2
57444: ARRAY
57445: DIFF
57446: ST_TO_ADDR
// if not tmp then
57447: LD_VAR 0 4
57451: NOT
57452: IFFALSE 57456
// continue ;
57454: GO 57301
// for j in tmp do
57456: LD_ADDR_VAR 0 3
57460: PUSH
57461: LD_VAR 0 4
57465: PUSH
57466: FOR_IN
57467: IFFALSE 57618
// begin if not mc_builders [ i ] then
57469: LD_EXP 48
57473: PUSH
57474: LD_VAR 0 2
57478: ARRAY
57479: NOT
57480: IFFALSE 57538
// begin SetTag ( j , 103 ) ;
57482: LD_VAR 0 3
57486: PPUSH
57487: LD_INT 103
57489: PPUSH
57490: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57494: LD_ADDR_EXP 48
57498: PUSH
57499: LD_EXP 48
57503: PPUSH
57504: LD_VAR 0 2
57508: PUSH
57509: LD_EXP 48
57513: PUSH
57514: LD_VAR 0 2
57518: ARRAY
57519: PUSH
57520: LD_INT 1
57522: PLUS
57523: PUSH
57524: EMPTY
57525: LIST
57526: LIST
57527: PPUSH
57528: LD_VAR 0 3
57532: PPUSH
57533: CALL 14750 0 3
57537: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57538: LD_VAR 0 3
57542: PPUSH
57543: CALL_OW 310
57547: IFFALSE 57558
// ComExitBuilding ( j ) ;
57549: LD_VAR 0 3
57553: PPUSH
57554: CALL_OW 122
// wait ( 3 ) ;
57558: LD_INT 3
57560: PPUSH
57561: CALL_OW 67
// if not mc_construct_list [ i ] then
57565: LD_EXP 49
57569: PUSH
57570: LD_VAR 0 2
57574: ARRAY
57575: NOT
57576: IFFALSE 57580
// break ;
57578: GO 57618
// if not HasTask ( j ) then
57580: LD_VAR 0 3
57584: PPUSH
57585: CALL_OW 314
57589: NOT
57590: IFFALSE 57616
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57592: LD_VAR 0 3
57596: PPUSH
57597: LD_EXP 49
57601: PUSH
57602: LD_VAR 0 2
57606: ARRAY
57607: PUSH
57608: LD_INT 1
57610: ARRAY
57611: PPUSH
57612: CALL 17601 0 2
// end ;
57616: GO 57466
57618: POP
57619: POP
// end else
57620: GO 58425
// if mc_build_list [ i ] then
57622: LD_EXP 47
57626: PUSH
57627: LD_VAR 0 2
57631: ARRAY
57632: IFFALSE 58425
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57634: LD_ADDR_VAR 0 5
57638: PUSH
57639: LD_EXP 42
57643: PUSH
57644: LD_VAR 0 2
57648: ARRAY
57649: PPUSH
57650: LD_INT 2
57652: PUSH
57653: LD_INT 30
57655: PUSH
57656: LD_INT 0
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: PUSH
57663: LD_INT 30
57665: PUSH
57666: LD_INT 1
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: LIST
57677: PPUSH
57678: CALL_OW 72
57682: ST_TO_ADDR
// if depot then
57683: LD_VAR 0 5
57687: IFFALSE 57705
// depot := depot [ 1 ] else
57689: LD_ADDR_VAR 0 5
57693: PUSH
57694: LD_VAR 0 5
57698: PUSH
57699: LD_INT 1
57701: ARRAY
57702: ST_TO_ADDR
57703: GO 57713
// depot := 0 ;
57705: LD_ADDR_VAR 0 5
57709: PUSH
57710: LD_INT 0
57712: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57713: LD_EXP 47
57717: PUSH
57718: LD_VAR 0 2
57722: ARRAY
57723: PUSH
57724: LD_INT 1
57726: ARRAY
57727: PUSH
57728: LD_INT 1
57730: ARRAY
57731: PPUSH
57732: CALL 17431 0 1
57736: PUSH
57737: LD_EXP 42
57741: PUSH
57742: LD_VAR 0 2
57746: ARRAY
57747: PPUSH
57748: LD_INT 2
57750: PUSH
57751: LD_INT 30
57753: PUSH
57754: LD_INT 2
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: LD_INT 30
57763: PUSH
57764: LD_INT 3
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: LIST
57775: PPUSH
57776: CALL_OW 72
57780: NOT
57781: AND
57782: IFFALSE 57887
// begin for j = 1 to mc_build_list [ i ] do
57784: LD_ADDR_VAR 0 3
57788: PUSH
57789: DOUBLE
57790: LD_INT 1
57792: DEC
57793: ST_TO_ADDR
57794: LD_EXP 47
57798: PUSH
57799: LD_VAR 0 2
57803: ARRAY
57804: PUSH
57805: FOR_TO
57806: IFFALSE 57885
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57808: LD_EXP 47
57812: PUSH
57813: LD_VAR 0 2
57817: ARRAY
57818: PUSH
57819: LD_VAR 0 3
57823: ARRAY
57824: PUSH
57825: LD_INT 1
57827: ARRAY
57828: PUSH
57829: LD_INT 2
57831: EQUAL
57832: IFFALSE 57883
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
57834: LD_ADDR_EXP 47
57838: PUSH
57839: LD_EXP 47
57843: PPUSH
57844: LD_VAR 0 2
57848: PPUSH
57849: LD_EXP 47
57853: PUSH
57854: LD_VAR 0 2
57858: ARRAY
57859: PPUSH
57860: LD_VAR 0 3
57864: PPUSH
57865: LD_INT 1
57867: PPUSH
57868: LD_INT 0
57870: PPUSH
57871: CALL 14168 0 4
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
// break ;
57881: GO 57885
// end ;
57883: GO 57805
57885: POP
57886: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
57887: LD_EXP 47
57891: PUSH
57892: LD_VAR 0 2
57896: ARRAY
57897: PUSH
57898: LD_INT 1
57900: ARRAY
57901: PUSH
57902: LD_INT 1
57904: ARRAY
57905: PUSH
57906: LD_INT 0
57908: EQUAL
57909: PUSH
57910: LD_VAR 0 5
57914: PUSH
57915: LD_VAR 0 5
57919: PPUSH
57920: LD_EXP 47
57924: PUSH
57925: LD_VAR 0 2
57929: ARRAY
57930: PUSH
57931: LD_INT 1
57933: ARRAY
57934: PUSH
57935: LD_INT 1
57937: ARRAY
57938: PPUSH
57939: LD_EXP 47
57943: PUSH
57944: LD_VAR 0 2
57948: ARRAY
57949: PUSH
57950: LD_INT 1
57952: ARRAY
57953: PUSH
57954: LD_INT 2
57956: ARRAY
57957: PPUSH
57958: LD_EXP 47
57962: PUSH
57963: LD_VAR 0 2
57967: ARRAY
57968: PUSH
57969: LD_INT 1
57971: ARRAY
57972: PUSH
57973: LD_INT 3
57975: ARRAY
57976: PPUSH
57977: LD_EXP 47
57981: PUSH
57982: LD_VAR 0 2
57986: ARRAY
57987: PUSH
57988: LD_INT 1
57990: ARRAY
57991: PUSH
57992: LD_INT 4
57994: ARRAY
57995: PPUSH
57996: CALL 22165 0 5
58000: AND
58001: OR
58002: IFFALSE 58283
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58004: LD_ADDR_VAR 0 4
58008: PUSH
58009: LD_EXP 42
58013: PUSH
58014: LD_VAR 0 2
58018: ARRAY
58019: PPUSH
58020: LD_INT 25
58022: PUSH
58023: LD_INT 2
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: PPUSH
58030: CALL_OW 72
58034: PUSH
58035: LD_EXP 44
58039: PUSH
58040: LD_VAR 0 2
58044: ARRAY
58045: DIFF
58046: ST_TO_ADDR
// if not tmp then
58047: LD_VAR 0 4
58051: NOT
58052: IFFALSE 58056
// continue ;
58054: GO 57301
// for j in tmp do
58056: LD_ADDR_VAR 0 3
58060: PUSH
58061: LD_VAR 0 4
58065: PUSH
58066: FOR_IN
58067: IFFALSE 58279
// begin if not mc_builders [ i ] then
58069: LD_EXP 48
58073: PUSH
58074: LD_VAR 0 2
58078: ARRAY
58079: NOT
58080: IFFALSE 58138
// begin SetTag ( j , 103 ) ;
58082: LD_VAR 0 3
58086: PPUSH
58087: LD_INT 103
58089: PPUSH
58090: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58094: LD_ADDR_EXP 48
58098: PUSH
58099: LD_EXP 48
58103: PPUSH
58104: LD_VAR 0 2
58108: PUSH
58109: LD_EXP 48
58113: PUSH
58114: LD_VAR 0 2
58118: ARRAY
58119: PUSH
58120: LD_INT 1
58122: PLUS
58123: PUSH
58124: EMPTY
58125: LIST
58126: LIST
58127: PPUSH
58128: LD_VAR 0 3
58132: PPUSH
58133: CALL 14750 0 3
58137: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58138: LD_VAR 0 3
58142: PPUSH
58143: CALL_OW 310
58147: IFFALSE 58158
// ComExitBuilding ( j ) ;
58149: LD_VAR 0 3
58153: PPUSH
58154: CALL_OW 122
// wait ( 3 ) ;
58158: LD_INT 3
58160: PPUSH
58161: CALL_OW 67
// if not mc_build_list [ i ] then
58165: LD_EXP 47
58169: PUSH
58170: LD_VAR 0 2
58174: ARRAY
58175: NOT
58176: IFFALSE 58180
// break ;
58178: GO 58279
// if not HasTask ( j ) then
58180: LD_VAR 0 3
58184: PPUSH
58185: CALL_OW 314
58189: NOT
58190: IFFALSE 58277
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58192: LD_VAR 0 3
58196: PPUSH
58197: LD_EXP 47
58201: PUSH
58202: LD_VAR 0 2
58206: ARRAY
58207: PUSH
58208: LD_INT 1
58210: ARRAY
58211: PUSH
58212: LD_INT 1
58214: ARRAY
58215: PPUSH
58216: LD_EXP 47
58220: PUSH
58221: LD_VAR 0 2
58225: ARRAY
58226: PUSH
58227: LD_INT 1
58229: ARRAY
58230: PUSH
58231: LD_INT 2
58233: ARRAY
58234: PPUSH
58235: LD_EXP 47
58239: PUSH
58240: LD_VAR 0 2
58244: ARRAY
58245: PUSH
58246: LD_INT 1
58248: ARRAY
58249: PUSH
58250: LD_INT 3
58252: ARRAY
58253: PPUSH
58254: LD_EXP 47
58258: PUSH
58259: LD_VAR 0 2
58263: ARRAY
58264: PUSH
58265: LD_INT 1
58267: ARRAY
58268: PUSH
58269: LD_INT 4
58271: ARRAY
58272: PPUSH
58273: CALL_OW 145
// end ;
58277: GO 58066
58279: POP
58280: POP
// end else
58281: GO 58425
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
58283: LD_EXP 42
58287: PUSH
58288: LD_VAR 0 2
58292: ARRAY
58293: PPUSH
58294: LD_EXP 47
58298: PUSH
58299: LD_VAR 0 2
58303: ARRAY
58304: PUSH
58305: LD_INT 1
58307: ARRAY
58308: PUSH
58309: LD_INT 1
58311: ARRAY
58312: PPUSH
58313: LD_EXP 47
58317: PUSH
58318: LD_VAR 0 2
58322: ARRAY
58323: PUSH
58324: LD_INT 1
58326: ARRAY
58327: PUSH
58328: LD_INT 2
58330: ARRAY
58331: PPUSH
58332: LD_EXP 47
58336: PUSH
58337: LD_VAR 0 2
58341: ARRAY
58342: PUSH
58343: LD_INT 1
58345: ARRAY
58346: PUSH
58347: LD_INT 3
58349: ARRAY
58350: PPUSH
58351: LD_EXP 47
58355: PUSH
58356: LD_VAR 0 2
58360: ARRAY
58361: PUSH
58362: LD_INT 1
58364: ARRAY
58365: PUSH
58366: LD_INT 4
58368: ARRAY
58369: PPUSH
58370: CALL 21501 0 5
58374: NOT
58375: IFFALSE 58425
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58377: LD_ADDR_EXP 47
58381: PUSH
58382: LD_EXP 47
58386: PPUSH
58387: LD_VAR 0 2
58391: PPUSH
58392: LD_EXP 47
58396: PUSH
58397: LD_VAR 0 2
58401: ARRAY
58402: PPUSH
58403: LD_INT 1
58405: PPUSH
58406: LD_INT 1
58408: NEG
58409: PPUSH
58410: LD_INT 0
58412: PPUSH
58413: CALL 14168 0 4
58417: PPUSH
58418: CALL_OW 1
58422: ST_TO_ADDR
// continue ;
58423: GO 57301
// end ; end ; end ;
58425: GO 57301
58427: POP
58428: POP
// end ;
58429: LD_VAR 0 1
58433: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58434: LD_INT 0
58436: PPUSH
58437: PPUSH
58438: PPUSH
58439: PPUSH
58440: PPUSH
58441: PPUSH
// if not mc_bases then
58442: LD_EXP 42
58446: NOT
58447: IFFALSE 58451
// exit ;
58449: GO 58878
// for i = 1 to mc_bases do
58451: LD_ADDR_VAR 0 2
58455: PUSH
58456: DOUBLE
58457: LD_INT 1
58459: DEC
58460: ST_TO_ADDR
58461: LD_EXP 42
58465: PUSH
58466: FOR_TO
58467: IFFALSE 58876
// begin tmp := mc_build_upgrade [ i ] ;
58469: LD_ADDR_VAR 0 4
58473: PUSH
58474: LD_EXP 74
58478: PUSH
58479: LD_VAR 0 2
58483: ARRAY
58484: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58485: LD_ADDR_VAR 0 6
58489: PUSH
58490: LD_EXP 75
58494: PUSH
58495: LD_VAR 0 2
58499: ARRAY
58500: PPUSH
58501: LD_INT 2
58503: PUSH
58504: LD_INT 30
58506: PUSH
58507: LD_INT 6
58509: PUSH
58510: EMPTY
58511: LIST
58512: LIST
58513: PUSH
58514: LD_INT 30
58516: PUSH
58517: LD_INT 7
58519: PUSH
58520: EMPTY
58521: LIST
58522: LIST
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: LIST
58528: PPUSH
58529: CALL_OW 72
58533: ST_TO_ADDR
// if not tmp and not lab then
58534: LD_VAR 0 4
58538: NOT
58539: PUSH
58540: LD_VAR 0 6
58544: NOT
58545: AND
58546: IFFALSE 58550
// continue ;
58548: GO 58466
// if tmp then
58550: LD_VAR 0 4
58554: IFFALSE 58674
// for j in tmp do
58556: LD_ADDR_VAR 0 3
58560: PUSH
58561: LD_VAR 0 4
58565: PUSH
58566: FOR_IN
58567: IFFALSE 58672
// begin if UpgradeCost ( j ) then
58569: LD_VAR 0 3
58573: PPUSH
58574: CALL 21161 0 1
58578: IFFALSE 58670
// begin ComUpgrade ( j ) ;
58580: LD_VAR 0 3
58584: PPUSH
58585: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58589: LD_ADDR_EXP 74
58593: PUSH
58594: LD_EXP 74
58598: PPUSH
58599: LD_VAR 0 2
58603: PPUSH
58604: LD_EXP 74
58608: PUSH
58609: LD_VAR 0 2
58613: ARRAY
58614: PUSH
58615: LD_VAR 0 3
58619: DIFF
58620: PPUSH
58621: CALL_OW 1
58625: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58626: LD_ADDR_EXP 49
58630: PUSH
58631: LD_EXP 49
58635: PPUSH
58636: LD_VAR 0 2
58640: PUSH
58641: LD_EXP 49
58645: PUSH
58646: LD_VAR 0 2
58650: ARRAY
58651: PUSH
58652: LD_INT 1
58654: PLUS
58655: PUSH
58656: EMPTY
58657: LIST
58658: LIST
58659: PPUSH
58660: LD_VAR 0 3
58664: PPUSH
58665: CALL 14750 0 3
58669: ST_TO_ADDR
// end ; end ;
58670: GO 58566
58672: POP
58673: POP
// if not lab or not mc_lab_upgrade [ i ] then
58674: LD_VAR 0 6
58678: NOT
58679: PUSH
58680: LD_EXP 76
58684: PUSH
58685: LD_VAR 0 2
58689: ARRAY
58690: NOT
58691: OR
58692: IFFALSE 58696
// continue ;
58694: GO 58466
// for j in lab do
58696: LD_ADDR_VAR 0 3
58700: PUSH
58701: LD_VAR 0 6
58705: PUSH
58706: FOR_IN
58707: IFFALSE 58872
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58709: LD_VAR 0 3
58713: PPUSH
58714: CALL_OW 266
58718: PUSH
58719: LD_INT 6
58721: PUSH
58722: LD_INT 7
58724: PUSH
58725: EMPTY
58726: LIST
58727: LIST
58728: IN
58729: PUSH
58730: LD_VAR 0 3
58734: PPUSH
58735: CALL_OW 461
58739: PUSH
58740: LD_INT 1
58742: NONEQUAL
58743: AND
58744: IFFALSE 58870
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58746: LD_VAR 0 3
58750: PPUSH
58751: LD_EXP 76
58755: PUSH
58756: LD_VAR 0 2
58760: ARRAY
58761: PUSH
58762: LD_INT 1
58764: ARRAY
58765: PPUSH
58766: CALL 21366 0 2
58770: IFFALSE 58870
// begin ComCancel ( j ) ;
58772: LD_VAR 0 3
58776: PPUSH
58777: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58781: LD_VAR 0 3
58785: PPUSH
58786: LD_EXP 76
58790: PUSH
58791: LD_VAR 0 2
58795: ARRAY
58796: PUSH
58797: LD_INT 1
58799: ARRAY
58800: PPUSH
58801: CALL_OW 207
// if not j in mc_construct_list [ i ] then
58805: LD_VAR 0 3
58809: PUSH
58810: LD_EXP 49
58814: PUSH
58815: LD_VAR 0 2
58819: ARRAY
58820: IN
58821: NOT
58822: IFFALSE 58868
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58824: LD_ADDR_EXP 49
58828: PUSH
58829: LD_EXP 49
58833: PPUSH
58834: LD_VAR 0 2
58838: PUSH
58839: LD_EXP 49
58843: PUSH
58844: LD_VAR 0 2
58848: ARRAY
58849: PUSH
58850: LD_INT 1
58852: PLUS
58853: PUSH
58854: EMPTY
58855: LIST
58856: LIST
58857: PPUSH
58858: LD_VAR 0 3
58862: PPUSH
58863: CALL 14750 0 3
58867: ST_TO_ADDR
// break ;
58868: GO 58872
// end ; end ; end ;
58870: GO 58706
58872: POP
58873: POP
// end ;
58874: GO 58466
58876: POP
58877: POP
// end ;
58878: LD_VAR 0 1
58882: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
58883: LD_INT 0
58885: PPUSH
58886: PPUSH
58887: PPUSH
58888: PPUSH
58889: PPUSH
58890: PPUSH
58891: PPUSH
58892: PPUSH
58893: PPUSH
// if not mc_bases then
58894: LD_EXP 42
58898: NOT
58899: IFFALSE 58903
// exit ;
58901: GO 59308
// for i = 1 to mc_bases do
58903: LD_ADDR_VAR 0 2
58907: PUSH
58908: DOUBLE
58909: LD_INT 1
58911: DEC
58912: ST_TO_ADDR
58913: LD_EXP 42
58917: PUSH
58918: FOR_TO
58919: IFFALSE 59306
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
58921: LD_EXP 50
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: NOT
58932: PUSH
58933: LD_EXP 42
58937: PUSH
58938: LD_VAR 0 2
58942: ARRAY
58943: PPUSH
58944: LD_INT 30
58946: PUSH
58947: LD_INT 3
58949: PUSH
58950: EMPTY
58951: LIST
58952: LIST
58953: PPUSH
58954: CALL_OW 72
58958: NOT
58959: OR
58960: IFFALSE 58964
// continue ;
58962: GO 58918
// busy := false ;
58964: LD_ADDR_VAR 0 8
58968: PUSH
58969: LD_INT 0
58971: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58972: LD_ADDR_VAR 0 4
58976: PUSH
58977: LD_EXP 42
58981: PUSH
58982: LD_VAR 0 2
58986: ARRAY
58987: PPUSH
58988: LD_INT 30
58990: PUSH
58991: LD_INT 3
58993: PUSH
58994: EMPTY
58995: LIST
58996: LIST
58997: PPUSH
58998: CALL_OW 72
59002: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59003: LD_ADDR_VAR 0 6
59007: PUSH
59008: LD_EXP 50
59012: PUSH
59013: LD_VAR 0 2
59017: ARRAY
59018: PPUSH
59019: LD_INT 2
59021: PUSH
59022: LD_INT 30
59024: PUSH
59025: LD_INT 32
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: PUSH
59032: LD_INT 30
59034: PUSH
59035: LD_INT 33
59037: PUSH
59038: EMPTY
59039: LIST
59040: LIST
59041: PUSH
59042: EMPTY
59043: LIST
59044: LIST
59045: LIST
59046: PPUSH
59047: CALL_OW 72
59051: ST_TO_ADDR
// if not t then
59052: LD_VAR 0 6
59056: NOT
59057: IFFALSE 59061
// continue ;
59059: GO 58918
// for j in tmp do
59061: LD_ADDR_VAR 0 3
59065: PUSH
59066: LD_VAR 0 4
59070: PUSH
59071: FOR_IN
59072: IFFALSE 59102
// if not BuildingStatus ( j ) = bs_idle then
59074: LD_VAR 0 3
59078: PPUSH
59079: CALL_OW 461
59083: PUSH
59084: LD_INT 2
59086: EQUAL
59087: NOT
59088: IFFALSE 59100
// begin busy := true ;
59090: LD_ADDR_VAR 0 8
59094: PUSH
59095: LD_INT 1
59097: ST_TO_ADDR
// break ;
59098: GO 59102
// end ;
59100: GO 59071
59102: POP
59103: POP
// if busy then
59104: LD_VAR 0 8
59108: IFFALSE 59112
// continue ;
59110: GO 58918
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59112: LD_ADDR_VAR 0 7
59116: PUSH
59117: LD_VAR 0 6
59121: PPUSH
59122: LD_INT 35
59124: PUSH
59125: LD_INT 0
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PPUSH
59132: CALL_OW 72
59136: ST_TO_ADDR
// if tw then
59137: LD_VAR 0 7
59141: IFFALSE 59218
// begin tw := tw [ 1 ] ;
59143: LD_ADDR_VAR 0 7
59147: PUSH
59148: LD_VAR 0 7
59152: PUSH
59153: LD_INT 1
59155: ARRAY
59156: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59157: LD_ADDR_VAR 0 9
59161: PUSH
59162: LD_VAR 0 7
59166: PPUSH
59167: LD_EXP 67
59171: PUSH
59172: LD_VAR 0 2
59176: ARRAY
59177: PPUSH
59178: CALL 19720 0 2
59182: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59183: LD_EXP 81
59187: PUSH
59188: LD_VAR 0 2
59192: ARRAY
59193: IFFALSE 59216
// if not weapon in mc_allowed_tower_weapons [ i ] then
59195: LD_VAR 0 9
59199: PUSH
59200: LD_EXP 81
59204: PUSH
59205: LD_VAR 0 2
59209: ARRAY
59210: IN
59211: NOT
59212: IFFALSE 59216
// continue ;
59214: GO 58918
// end else
59216: GO 59281
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59218: LD_ADDR_VAR 0 5
59222: PUSH
59223: LD_EXP 50
59227: PUSH
59228: LD_VAR 0 2
59232: ARRAY
59233: PPUSH
59234: LD_VAR 0 4
59238: PPUSH
59239: CALL 45341 0 2
59243: ST_TO_ADDR
// if not tmp2 then
59244: LD_VAR 0 5
59248: NOT
59249: IFFALSE 59253
// continue ;
59251: GO 58918
// tw := tmp2 [ 1 ] ;
59253: LD_ADDR_VAR 0 7
59257: PUSH
59258: LD_VAR 0 5
59262: PUSH
59263: LD_INT 1
59265: ARRAY
59266: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59267: LD_ADDR_VAR 0 9
59271: PUSH
59272: LD_VAR 0 5
59276: PUSH
59277: LD_INT 2
59279: ARRAY
59280: ST_TO_ADDR
// end ; if not weapon then
59281: LD_VAR 0 9
59285: NOT
59286: IFFALSE 59290
// continue ;
59288: GO 58918
// ComPlaceWeapon ( tw , weapon ) ;
59290: LD_VAR 0 7
59294: PPUSH
59295: LD_VAR 0 9
59299: PPUSH
59300: CALL_OW 148
// end ;
59304: GO 58918
59306: POP
59307: POP
// end ;
59308: LD_VAR 0 1
59312: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
59313: LD_INT 0
59315: PPUSH
59316: PPUSH
59317: PPUSH
59318: PPUSH
59319: PPUSH
59320: PPUSH
// if not mc_bases then
59321: LD_EXP 42
59325: NOT
59326: IFFALSE 59330
// exit ;
59328: GO 60106
// for i = 1 to mc_bases do
59330: LD_ADDR_VAR 0 2
59334: PUSH
59335: DOUBLE
59336: LD_INT 1
59338: DEC
59339: ST_TO_ADDR
59340: LD_EXP 42
59344: PUSH
59345: FOR_TO
59346: IFFALSE 60104
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59348: LD_EXP 55
59352: PUSH
59353: LD_VAR 0 2
59357: ARRAY
59358: NOT
59359: PUSH
59360: LD_EXP 55
59364: PUSH
59365: LD_VAR 0 2
59369: ARRAY
59370: PUSH
59371: LD_EXP 56
59375: PUSH
59376: LD_VAR 0 2
59380: ARRAY
59381: EQUAL
59382: OR
59383: PUSH
59384: LD_EXP 65
59388: PUSH
59389: LD_VAR 0 2
59393: ARRAY
59394: OR
59395: IFFALSE 59399
// continue ;
59397: GO 59345
// if mc_miners [ i ] then
59399: LD_EXP 56
59403: PUSH
59404: LD_VAR 0 2
59408: ARRAY
59409: IFFALSE 59791
// begin for j = mc_miners [ i ] downto 1 do
59411: LD_ADDR_VAR 0 3
59415: PUSH
59416: DOUBLE
59417: LD_EXP 56
59421: PUSH
59422: LD_VAR 0 2
59426: ARRAY
59427: INC
59428: ST_TO_ADDR
59429: LD_INT 1
59431: PUSH
59432: FOR_DOWNTO
59433: IFFALSE 59789
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59435: LD_EXP 56
59439: PUSH
59440: LD_VAR 0 2
59444: ARRAY
59445: PUSH
59446: LD_VAR 0 3
59450: ARRAY
59451: PPUSH
59452: CALL_OW 301
59456: PUSH
59457: LD_EXP 56
59461: PUSH
59462: LD_VAR 0 2
59466: ARRAY
59467: PUSH
59468: LD_VAR 0 3
59472: ARRAY
59473: PPUSH
59474: CALL_OW 257
59478: PUSH
59479: LD_INT 1
59481: NONEQUAL
59482: OR
59483: IFFALSE 59546
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59485: LD_ADDR_VAR 0 5
59489: PUSH
59490: LD_EXP 56
59494: PUSH
59495: LD_VAR 0 2
59499: ARRAY
59500: PUSH
59501: LD_EXP 56
59505: PUSH
59506: LD_VAR 0 2
59510: ARRAY
59511: PUSH
59512: LD_VAR 0 3
59516: ARRAY
59517: DIFF
59518: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59519: LD_ADDR_EXP 56
59523: PUSH
59524: LD_EXP 56
59528: PPUSH
59529: LD_VAR 0 2
59533: PPUSH
59534: LD_VAR 0 5
59538: PPUSH
59539: CALL_OW 1
59543: ST_TO_ADDR
// continue ;
59544: GO 59432
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59546: LD_EXP 56
59550: PUSH
59551: LD_VAR 0 2
59555: ARRAY
59556: PUSH
59557: LD_VAR 0 3
59561: ARRAY
59562: PPUSH
59563: CALL_OW 257
59567: PUSH
59568: LD_INT 1
59570: EQUAL
59571: PUSH
59572: LD_EXP 56
59576: PUSH
59577: LD_VAR 0 2
59581: ARRAY
59582: PUSH
59583: LD_VAR 0 3
59587: ARRAY
59588: PPUSH
59589: CALL_OW 459
59593: NOT
59594: AND
59595: PUSH
59596: LD_EXP 56
59600: PUSH
59601: LD_VAR 0 2
59605: ARRAY
59606: PUSH
59607: LD_VAR 0 3
59611: ARRAY
59612: PPUSH
59613: CALL_OW 314
59617: NOT
59618: AND
59619: IFFALSE 59787
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59621: LD_EXP 56
59625: PUSH
59626: LD_VAR 0 2
59630: ARRAY
59631: PUSH
59632: LD_VAR 0 3
59636: ARRAY
59637: PPUSH
59638: CALL_OW 310
59642: IFFALSE 59665
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59644: LD_EXP 56
59648: PUSH
59649: LD_VAR 0 2
59653: ARRAY
59654: PUSH
59655: LD_VAR 0 3
59659: ARRAY
59660: PPUSH
59661: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59665: LD_EXP 56
59669: PUSH
59670: LD_VAR 0 2
59674: ARRAY
59675: PUSH
59676: LD_VAR 0 3
59680: ARRAY
59681: PPUSH
59682: CALL_OW 314
59686: NOT
59687: IFFALSE 59787
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
59689: LD_EXP 56
59693: PUSH
59694: LD_VAR 0 2
59698: ARRAY
59699: PUSH
59700: LD_VAR 0 3
59704: ARRAY
59705: PPUSH
59706: LD_EXP 55
59710: PUSH
59711: LD_VAR 0 2
59715: ARRAY
59716: PUSH
59717: LD_VAR 0 3
59721: PUSH
59722: LD_EXP 55
59726: PUSH
59727: LD_VAR 0 2
59731: ARRAY
59732: MOD
59733: PUSH
59734: LD_INT 1
59736: PLUS
59737: ARRAY
59738: PUSH
59739: LD_INT 1
59741: ARRAY
59742: PPUSH
59743: LD_EXP 55
59747: PUSH
59748: LD_VAR 0 2
59752: ARRAY
59753: PUSH
59754: LD_VAR 0 3
59758: PUSH
59759: LD_EXP 55
59763: PUSH
59764: LD_VAR 0 2
59768: ARRAY
59769: MOD
59770: PUSH
59771: LD_INT 1
59773: PLUS
59774: ARRAY
59775: PUSH
59776: LD_INT 2
59778: ARRAY
59779: PPUSH
59780: LD_INT 0
59782: PPUSH
59783: CALL_OW 193
// end ; end ;
59787: GO 59432
59789: POP
59790: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59791: LD_ADDR_VAR 0 5
59795: PUSH
59796: LD_EXP 42
59800: PUSH
59801: LD_VAR 0 2
59805: ARRAY
59806: PPUSH
59807: LD_INT 2
59809: PUSH
59810: LD_INT 30
59812: PUSH
59813: LD_INT 4
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: LD_INT 30
59822: PUSH
59823: LD_INT 5
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: PUSH
59830: LD_INT 30
59832: PUSH
59833: LD_INT 32
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: LIST
59844: LIST
59845: PPUSH
59846: CALL_OW 72
59850: ST_TO_ADDR
// if not tmp then
59851: LD_VAR 0 5
59855: NOT
59856: IFFALSE 59860
// continue ;
59858: GO 59345
// list := [ ] ;
59860: LD_ADDR_VAR 0 6
59864: PUSH
59865: EMPTY
59866: ST_TO_ADDR
// for j in tmp do
59867: LD_ADDR_VAR 0 3
59871: PUSH
59872: LD_VAR 0 5
59876: PUSH
59877: FOR_IN
59878: IFFALSE 59947
// begin for k in UnitsInside ( j ) do
59880: LD_ADDR_VAR 0 4
59884: PUSH
59885: LD_VAR 0 3
59889: PPUSH
59890: CALL_OW 313
59894: PUSH
59895: FOR_IN
59896: IFFALSE 59943
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
59898: LD_VAR 0 4
59902: PPUSH
59903: CALL_OW 257
59907: PUSH
59908: LD_INT 1
59910: EQUAL
59911: PUSH
59912: LD_VAR 0 4
59916: PPUSH
59917: CALL_OW 459
59921: NOT
59922: AND
59923: IFFALSE 59941
// list := list ^ k ;
59925: LD_ADDR_VAR 0 6
59929: PUSH
59930: LD_VAR 0 6
59934: PUSH
59935: LD_VAR 0 4
59939: ADD
59940: ST_TO_ADDR
59941: GO 59895
59943: POP
59944: POP
// end ;
59945: GO 59877
59947: POP
59948: POP
// list := list diff mc_miners [ i ] ;
59949: LD_ADDR_VAR 0 6
59953: PUSH
59954: LD_VAR 0 6
59958: PUSH
59959: LD_EXP 56
59963: PUSH
59964: LD_VAR 0 2
59968: ARRAY
59969: DIFF
59970: ST_TO_ADDR
// if not list then
59971: LD_VAR 0 6
59975: NOT
59976: IFFALSE 59980
// continue ;
59978: GO 59345
// k := mc_mines [ i ] - mc_miners [ i ] ;
59980: LD_ADDR_VAR 0 4
59984: PUSH
59985: LD_EXP 55
59989: PUSH
59990: LD_VAR 0 2
59994: ARRAY
59995: PUSH
59996: LD_EXP 56
60000: PUSH
60001: LD_VAR 0 2
60005: ARRAY
60006: MINUS
60007: ST_TO_ADDR
// if k > list then
60008: LD_VAR 0 4
60012: PUSH
60013: LD_VAR 0 6
60017: GREATER
60018: IFFALSE 60030
// k := list ;
60020: LD_ADDR_VAR 0 4
60024: PUSH
60025: LD_VAR 0 6
60029: ST_TO_ADDR
// for j = 1 to k do
60030: LD_ADDR_VAR 0 3
60034: PUSH
60035: DOUBLE
60036: LD_INT 1
60038: DEC
60039: ST_TO_ADDR
60040: LD_VAR 0 4
60044: PUSH
60045: FOR_TO
60046: IFFALSE 60100
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60048: LD_ADDR_EXP 56
60052: PUSH
60053: LD_EXP 56
60057: PPUSH
60058: LD_VAR 0 2
60062: PUSH
60063: LD_EXP 56
60067: PUSH
60068: LD_VAR 0 2
60072: ARRAY
60073: PUSH
60074: LD_INT 1
60076: PLUS
60077: PUSH
60078: EMPTY
60079: LIST
60080: LIST
60081: PPUSH
60082: LD_VAR 0 6
60086: PUSH
60087: LD_VAR 0 3
60091: ARRAY
60092: PPUSH
60093: CALL 14750 0 3
60097: ST_TO_ADDR
60098: GO 60045
60100: POP
60101: POP
// end ;
60102: GO 59345
60104: POP
60105: POP
// end ;
60106: LD_VAR 0 1
60110: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60111: LD_INT 0
60113: PPUSH
60114: PPUSH
60115: PPUSH
60116: PPUSH
60117: PPUSH
60118: PPUSH
60119: PPUSH
60120: PPUSH
60121: PPUSH
60122: PPUSH
// if not mc_bases then
60123: LD_EXP 42
60127: NOT
60128: IFFALSE 60132
// exit ;
60130: GO 61882
// for i = 1 to mc_bases do
60132: LD_ADDR_VAR 0 2
60136: PUSH
60137: DOUBLE
60138: LD_INT 1
60140: DEC
60141: ST_TO_ADDR
60142: LD_EXP 42
60146: PUSH
60147: FOR_TO
60148: IFFALSE 61880
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60150: LD_EXP 42
60154: PUSH
60155: LD_VAR 0 2
60159: ARRAY
60160: NOT
60161: PUSH
60162: LD_EXP 49
60166: PUSH
60167: LD_VAR 0 2
60171: ARRAY
60172: OR
60173: IFFALSE 60177
// continue ;
60175: GO 60147
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60177: LD_EXP 58
60181: PUSH
60182: LD_VAR 0 2
60186: ARRAY
60187: NOT
60188: PUSH
60189: LD_EXP 59
60193: PUSH
60194: LD_VAR 0 2
60198: ARRAY
60199: AND
60200: IFFALSE 60238
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60202: LD_ADDR_EXP 59
60206: PUSH
60207: LD_EXP 59
60211: PPUSH
60212: LD_VAR 0 2
60216: PPUSH
60217: EMPTY
60218: PPUSH
60219: CALL_OW 1
60223: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60224: LD_VAR 0 2
60228: PPUSH
60229: LD_INT 107
60231: PPUSH
60232: CALL 51086 0 2
// continue ;
60236: GO 60147
// end ; target := [ ] ;
60238: LD_ADDR_VAR 0 6
60242: PUSH
60243: EMPTY
60244: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60245: LD_ADDR_VAR 0 3
60249: PUSH
60250: DOUBLE
60251: LD_EXP 58
60255: PUSH
60256: LD_VAR 0 2
60260: ARRAY
60261: INC
60262: ST_TO_ADDR
60263: LD_INT 1
60265: PUSH
60266: FOR_DOWNTO
60267: IFFALSE 60527
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60269: LD_EXP 58
60273: PUSH
60274: LD_VAR 0 2
60278: ARRAY
60279: PUSH
60280: LD_VAR 0 3
60284: ARRAY
60285: PUSH
60286: LD_INT 2
60288: ARRAY
60289: PPUSH
60290: LD_EXP 58
60294: PUSH
60295: LD_VAR 0 2
60299: ARRAY
60300: PUSH
60301: LD_VAR 0 3
60305: ARRAY
60306: PUSH
60307: LD_INT 3
60309: ARRAY
60310: PPUSH
60311: CALL_OW 488
60315: PUSH
60316: LD_EXP 58
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: PUSH
60327: LD_VAR 0 3
60331: ARRAY
60332: PUSH
60333: LD_INT 2
60335: ARRAY
60336: PPUSH
60337: LD_EXP 58
60341: PUSH
60342: LD_VAR 0 2
60346: ARRAY
60347: PUSH
60348: LD_VAR 0 3
60352: ARRAY
60353: PUSH
60354: LD_INT 3
60356: ARRAY
60357: PPUSH
60358: CALL_OW 284
60362: PUSH
60363: LD_INT 0
60365: EQUAL
60366: AND
60367: IFFALSE 60422
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60369: LD_ADDR_VAR 0 5
60373: PUSH
60374: LD_EXP 58
60378: PUSH
60379: LD_VAR 0 2
60383: ARRAY
60384: PPUSH
60385: LD_VAR 0 3
60389: PPUSH
60390: CALL_OW 3
60394: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60395: LD_ADDR_EXP 58
60399: PUSH
60400: LD_EXP 58
60404: PPUSH
60405: LD_VAR 0 2
60409: PPUSH
60410: LD_VAR 0 5
60414: PPUSH
60415: CALL_OW 1
60419: ST_TO_ADDR
// continue ;
60420: GO 60266
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60422: LD_EXP 42
60426: PUSH
60427: LD_VAR 0 2
60431: ARRAY
60432: PUSH
60433: LD_INT 1
60435: ARRAY
60436: PPUSH
60437: CALL_OW 255
60441: PPUSH
60442: LD_EXP 58
60446: PUSH
60447: LD_VAR 0 2
60451: ARRAY
60452: PUSH
60453: LD_VAR 0 3
60457: ARRAY
60458: PUSH
60459: LD_INT 2
60461: ARRAY
60462: PPUSH
60463: LD_EXP 58
60467: PUSH
60468: LD_VAR 0 2
60472: ARRAY
60473: PUSH
60474: LD_VAR 0 3
60478: ARRAY
60479: PUSH
60480: LD_INT 3
60482: ARRAY
60483: PPUSH
60484: LD_INT 30
60486: PPUSH
60487: CALL 15646 0 4
60491: PUSH
60492: LD_INT 4
60494: ARRAY
60495: PUSH
60496: LD_INT 0
60498: EQUAL
60499: IFFALSE 60525
// begin target := mc_crates [ i ] [ j ] ;
60501: LD_ADDR_VAR 0 6
60505: PUSH
60506: LD_EXP 58
60510: PUSH
60511: LD_VAR 0 2
60515: ARRAY
60516: PUSH
60517: LD_VAR 0 3
60521: ARRAY
60522: ST_TO_ADDR
// break ;
60523: GO 60527
// end ; end ;
60525: GO 60266
60527: POP
60528: POP
// if not target then
60529: LD_VAR 0 6
60533: NOT
60534: IFFALSE 60538
// continue ;
60536: GO 60147
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60538: LD_ADDR_VAR 0 7
60542: PUSH
60543: LD_EXP 61
60547: PUSH
60548: LD_VAR 0 2
60552: ARRAY
60553: PPUSH
60554: LD_INT 2
60556: PUSH
60557: LD_INT 3
60559: PUSH
60560: LD_INT 58
60562: PUSH
60563: EMPTY
60564: LIST
60565: PUSH
60566: EMPTY
60567: LIST
60568: LIST
60569: PUSH
60570: LD_INT 61
60572: PUSH
60573: EMPTY
60574: LIST
60575: PUSH
60576: LD_INT 33
60578: PUSH
60579: LD_INT 5
60581: PUSH
60582: EMPTY
60583: LIST
60584: LIST
60585: PUSH
60586: LD_INT 33
60588: PUSH
60589: LD_INT 3
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: LIST
60600: LIST
60601: LIST
60602: PUSH
60603: LD_INT 2
60605: PUSH
60606: LD_INT 34
60608: PUSH
60609: LD_INT 32
60611: PUSH
60612: EMPTY
60613: LIST
60614: LIST
60615: PUSH
60616: LD_INT 34
60618: PUSH
60619: LD_INT 51
60621: PUSH
60622: EMPTY
60623: LIST
60624: LIST
60625: PUSH
60626: LD_INT 34
60628: PUSH
60629: LD_INT 12
60631: PUSH
60632: EMPTY
60633: LIST
60634: LIST
60635: PUSH
60636: EMPTY
60637: LIST
60638: LIST
60639: LIST
60640: LIST
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: PPUSH
60646: CALL_OW 72
60650: ST_TO_ADDR
// if not cargo then
60651: LD_VAR 0 7
60655: NOT
60656: IFFALSE 61299
// begin if mc_crates_collector [ i ] < 5 then
60658: LD_EXP 59
60662: PUSH
60663: LD_VAR 0 2
60667: ARRAY
60668: PUSH
60669: LD_INT 5
60671: LESS
60672: IFFALSE 61038
// begin if mc_ape [ i ] then
60674: LD_EXP 71
60678: PUSH
60679: LD_VAR 0 2
60683: ARRAY
60684: IFFALSE 60731
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60686: LD_ADDR_VAR 0 5
60690: PUSH
60691: LD_EXP 71
60695: PUSH
60696: LD_VAR 0 2
60700: ARRAY
60701: PPUSH
60702: LD_INT 25
60704: PUSH
60705: LD_INT 16
60707: PUSH
60708: EMPTY
60709: LIST
60710: LIST
60711: PUSH
60712: LD_INT 24
60714: PUSH
60715: LD_INT 750
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: PUSH
60722: EMPTY
60723: LIST
60724: LIST
60725: PPUSH
60726: CALL_OW 72
60730: ST_TO_ADDR
// if not tmp then
60731: LD_VAR 0 5
60735: NOT
60736: IFFALSE 60783
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60738: LD_ADDR_VAR 0 5
60742: PUSH
60743: LD_EXP 42
60747: PUSH
60748: LD_VAR 0 2
60752: ARRAY
60753: PPUSH
60754: LD_INT 25
60756: PUSH
60757: LD_INT 2
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: PUSH
60764: LD_INT 24
60766: PUSH
60767: LD_INT 750
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: EMPTY
60775: LIST
60776: LIST
60777: PPUSH
60778: CALL_OW 72
60782: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60783: LD_EXP 71
60787: PUSH
60788: LD_VAR 0 2
60792: ARRAY
60793: PUSH
60794: LD_EXP 42
60798: PUSH
60799: LD_VAR 0 2
60803: ARRAY
60804: PPUSH
60805: LD_INT 25
60807: PUSH
60808: LD_INT 2
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PUSH
60815: LD_INT 24
60817: PUSH
60818: LD_INT 750
60820: PUSH
60821: EMPTY
60822: LIST
60823: LIST
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PPUSH
60829: CALL_OW 72
60833: AND
60834: PUSH
60835: LD_VAR 0 5
60839: PUSH
60840: LD_INT 5
60842: LESS
60843: AND
60844: IFFALSE 60926
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
60846: LD_ADDR_VAR 0 3
60850: PUSH
60851: LD_EXP 42
60855: PUSH
60856: LD_VAR 0 2
60860: ARRAY
60861: PPUSH
60862: LD_INT 25
60864: PUSH
60865: LD_INT 2
60867: PUSH
60868: EMPTY
60869: LIST
60870: LIST
60871: PUSH
60872: LD_INT 24
60874: PUSH
60875: LD_INT 750
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PPUSH
60886: CALL_OW 72
60890: PUSH
60891: FOR_IN
60892: IFFALSE 60924
// begin tmp := tmp union j ;
60894: LD_ADDR_VAR 0 5
60898: PUSH
60899: LD_VAR 0 5
60903: PUSH
60904: LD_VAR 0 3
60908: UNION
60909: ST_TO_ADDR
// if tmp >= 5 then
60910: LD_VAR 0 5
60914: PUSH
60915: LD_INT 5
60917: GREATEREQUAL
60918: IFFALSE 60922
// break ;
60920: GO 60924
// end ;
60922: GO 60891
60924: POP
60925: POP
// end ; if not tmp then
60926: LD_VAR 0 5
60930: NOT
60931: IFFALSE 60935
// continue ;
60933: GO 60147
// for j in tmp do
60935: LD_ADDR_VAR 0 3
60939: PUSH
60940: LD_VAR 0 5
60944: PUSH
60945: FOR_IN
60946: IFFALSE 61036
// if not GetTag ( j ) then
60948: LD_VAR 0 3
60952: PPUSH
60953: CALL_OW 110
60957: NOT
60958: IFFALSE 61034
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
60960: LD_ADDR_EXP 59
60964: PUSH
60965: LD_EXP 59
60969: PPUSH
60970: LD_VAR 0 2
60974: PUSH
60975: LD_EXP 59
60979: PUSH
60980: LD_VAR 0 2
60984: ARRAY
60985: PUSH
60986: LD_INT 1
60988: PLUS
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: PPUSH
60994: LD_VAR 0 3
60998: PPUSH
60999: CALL 14750 0 3
61003: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61004: LD_VAR 0 3
61008: PPUSH
61009: LD_INT 107
61011: PPUSH
61012: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61016: LD_EXP 59
61020: PUSH
61021: LD_VAR 0 2
61025: ARRAY
61026: PUSH
61027: LD_INT 5
61029: GREATEREQUAL
61030: IFFALSE 61034
// break ;
61032: GO 61036
// end ;
61034: GO 60945
61036: POP
61037: POP
// end ; if mc_crates_collector [ i ] and target then
61038: LD_EXP 59
61042: PUSH
61043: LD_VAR 0 2
61047: ARRAY
61048: PUSH
61049: LD_VAR 0 6
61053: AND
61054: IFFALSE 61297
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61056: LD_EXP 59
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: PUSH
61067: LD_VAR 0 6
61071: PUSH
61072: LD_INT 1
61074: ARRAY
61075: LESS
61076: IFFALSE 61096
// tmp := mc_crates_collector [ i ] else
61078: LD_ADDR_VAR 0 5
61082: PUSH
61083: LD_EXP 59
61087: PUSH
61088: LD_VAR 0 2
61092: ARRAY
61093: ST_TO_ADDR
61094: GO 61110
// tmp := target [ 1 ] ;
61096: LD_ADDR_VAR 0 5
61100: PUSH
61101: LD_VAR 0 6
61105: PUSH
61106: LD_INT 1
61108: ARRAY
61109: ST_TO_ADDR
// k := 0 ;
61110: LD_ADDR_VAR 0 4
61114: PUSH
61115: LD_INT 0
61117: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61118: LD_ADDR_VAR 0 3
61122: PUSH
61123: LD_EXP 59
61127: PUSH
61128: LD_VAR 0 2
61132: ARRAY
61133: PUSH
61134: FOR_IN
61135: IFFALSE 61295
// begin k := k + 1 ;
61137: LD_ADDR_VAR 0 4
61141: PUSH
61142: LD_VAR 0 4
61146: PUSH
61147: LD_INT 1
61149: PLUS
61150: ST_TO_ADDR
// if k > tmp then
61151: LD_VAR 0 4
61155: PUSH
61156: LD_VAR 0 5
61160: GREATER
61161: IFFALSE 61165
// break ;
61163: GO 61295
// if not GetClass ( j ) in [ 2 , 16 ] then
61165: LD_VAR 0 3
61169: PPUSH
61170: CALL_OW 257
61174: PUSH
61175: LD_INT 2
61177: PUSH
61178: LD_INT 16
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: IN
61185: NOT
61186: IFFALSE 61239
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61188: LD_ADDR_EXP 59
61192: PUSH
61193: LD_EXP 59
61197: PPUSH
61198: LD_VAR 0 2
61202: PPUSH
61203: LD_EXP 59
61207: PUSH
61208: LD_VAR 0 2
61212: ARRAY
61213: PUSH
61214: LD_VAR 0 3
61218: DIFF
61219: PPUSH
61220: CALL_OW 1
61224: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61225: LD_VAR 0 3
61229: PPUSH
61230: LD_INT 0
61232: PPUSH
61233: CALL_OW 109
// continue ;
61237: GO 61134
// end ; if IsInUnit ( j ) then
61239: LD_VAR 0 3
61243: PPUSH
61244: CALL_OW 310
61248: IFFALSE 61259
// ComExitBuilding ( j ) ;
61250: LD_VAR 0 3
61254: PPUSH
61255: CALL_OW 122
// wait ( 3 ) ;
61259: LD_INT 3
61261: PPUSH
61262: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61266: LD_VAR 0 3
61270: PPUSH
61271: LD_VAR 0 6
61275: PUSH
61276: LD_INT 2
61278: ARRAY
61279: PPUSH
61280: LD_VAR 0 6
61284: PUSH
61285: LD_INT 3
61287: ARRAY
61288: PPUSH
61289: CALL_OW 117
// end ;
61293: GO 61134
61295: POP
61296: POP
// end ; end else
61297: GO 61878
// begin for j in cargo do
61299: LD_ADDR_VAR 0 3
61303: PUSH
61304: LD_VAR 0 7
61308: PUSH
61309: FOR_IN
61310: IFFALSE 61876
// begin if GetTag ( j ) <> 0 then
61312: LD_VAR 0 3
61316: PPUSH
61317: CALL_OW 110
61321: PUSH
61322: LD_INT 0
61324: NONEQUAL
61325: IFFALSE 61329
// continue ;
61327: GO 61309
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61329: LD_VAR 0 3
61333: PPUSH
61334: CALL_OW 256
61338: PUSH
61339: LD_INT 1000
61341: LESS
61342: PUSH
61343: LD_VAR 0 3
61347: PPUSH
61348: LD_EXP 66
61352: PUSH
61353: LD_VAR 0 2
61357: ARRAY
61358: PPUSH
61359: CALL_OW 308
61363: NOT
61364: AND
61365: IFFALSE 61387
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61367: LD_VAR 0 3
61371: PPUSH
61372: LD_EXP 66
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PPUSH
61383: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61387: LD_VAR 0 3
61391: PPUSH
61392: CALL_OW 256
61396: PUSH
61397: LD_INT 1000
61399: LESS
61400: PUSH
61401: LD_VAR 0 3
61405: PPUSH
61406: LD_EXP 66
61410: PUSH
61411: LD_VAR 0 2
61415: ARRAY
61416: PPUSH
61417: CALL_OW 308
61421: AND
61422: IFFALSE 61426
// continue ;
61424: GO 61309
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61426: LD_VAR 0 3
61430: PPUSH
61431: CALL_OW 262
61435: PUSH
61436: LD_INT 2
61438: EQUAL
61439: PUSH
61440: LD_VAR 0 3
61444: PPUSH
61445: CALL_OW 261
61449: PUSH
61450: LD_INT 15
61452: LESS
61453: AND
61454: IFFALSE 61458
// continue ;
61456: GO 61309
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61458: LD_VAR 0 3
61462: PPUSH
61463: CALL_OW 262
61467: PUSH
61468: LD_INT 1
61470: EQUAL
61471: PUSH
61472: LD_VAR 0 3
61476: PPUSH
61477: CALL_OW 261
61481: PUSH
61482: LD_INT 10
61484: LESS
61485: AND
61486: IFFALSE 61815
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61488: LD_ADDR_VAR 0 8
61492: PUSH
61493: LD_EXP 42
61497: PUSH
61498: LD_VAR 0 2
61502: ARRAY
61503: PPUSH
61504: LD_INT 2
61506: PUSH
61507: LD_INT 30
61509: PUSH
61510: LD_INT 0
61512: PUSH
61513: EMPTY
61514: LIST
61515: LIST
61516: PUSH
61517: LD_INT 30
61519: PUSH
61520: LD_INT 1
61522: PUSH
61523: EMPTY
61524: LIST
61525: LIST
61526: PUSH
61527: EMPTY
61528: LIST
61529: LIST
61530: LIST
61531: PPUSH
61532: CALL_OW 72
61536: ST_TO_ADDR
// if not depot then
61537: LD_VAR 0 8
61541: NOT
61542: IFFALSE 61546
// continue ;
61544: GO 61309
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61546: LD_VAR 0 3
61550: PPUSH
61551: LD_VAR 0 8
61555: PPUSH
61556: LD_VAR 0 3
61560: PPUSH
61561: CALL_OW 74
61565: PPUSH
61566: CALL_OW 296
61570: PUSH
61571: LD_INT 6
61573: LESS
61574: IFFALSE 61590
// SetFuel ( j , 100 ) else
61576: LD_VAR 0 3
61580: PPUSH
61581: LD_INT 100
61583: PPUSH
61584: CALL_OW 240
61588: GO 61815
// if GetFuel ( j ) = 0 then
61590: LD_VAR 0 3
61594: PPUSH
61595: CALL_OW 261
61599: PUSH
61600: LD_INT 0
61602: EQUAL
61603: IFFALSE 61815
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61605: LD_ADDR_EXP 61
61609: PUSH
61610: LD_EXP 61
61614: PPUSH
61615: LD_VAR 0 2
61619: PPUSH
61620: LD_EXP 61
61624: PUSH
61625: LD_VAR 0 2
61629: ARRAY
61630: PUSH
61631: LD_VAR 0 3
61635: DIFF
61636: PPUSH
61637: CALL_OW 1
61641: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61642: LD_VAR 0 3
61646: PPUSH
61647: CALL_OW 263
61651: PUSH
61652: LD_INT 1
61654: EQUAL
61655: IFFALSE 61671
// ComExitVehicle ( IsInUnit ( j ) ) ;
61657: LD_VAR 0 3
61661: PPUSH
61662: CALL_OW 310
61666: PPUSH
61667: CALL_OW 121
// if GetControl ( j ) = control_remote then
61671: LD_VAR 0 3
61675: PPUSH
61676: CALL_OW 263
61680: PUSH
61681: LD_INT 2
61683: EQUAL
61684: IFFALSE 61695
// ComUnlink ( j ) ;
61686: LD_VAR 0 3
61690: PPUSH
61691: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61695: LD_ADDR_VAR 0 9
61699: PUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: LD_INT 3
61707: PPUSH
61708: CALL 71190 0 2
61712: ST_TO_ADDR
// if fac then
61713: LD_VAR 0 9
61717: IFFALSE 61813
// begin for k in fac do
61719: LD_ADDR_VAR 0 4
61723: PUSH
61724: LD_VAR 0 9
61728: PUSH
61729: FOR_IN
61730: IFFALSE 61811
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61732: LD_ADDR_VAR 0 10
61736: PUSH
61737: LD_VAR 0 9
61741: PPUSH
61742: LD_VAR 0 3
61746: PPUSH
61747: CALL_OW 265
61751: PPUSH
61752: LD_VAR 0 3
61756: PPUSH
61757: CALL_OW 262
61761: PPUSH
61762: LD_VAR 0 3
61766: PPUSH
61767: CALL_OW 263
61771: PPUSH
61772: LD_VAR 0 3
61776: PPUSH
61777: CALL_OW 264
61781: PPUSH
61782: CALL 12282 0 5
61786: ST_TO_ADDR
// if components then
61787: LD_VAR 0 10
61791: IFFALSE 61809
// begin MC_InsertProduceList ( i , components ) ;
61793: LD_VAR 0 2
61797: PPUSH
61798: LD_VAR 0 10
61802: PPUSH
61803: CALL 70735 0 2
// break ;
61807: GO 61811
// end ; end ;
61809: GO 61729
61811: POP
61812: POP
// end ; continue ;
61813: GO 61309
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
61815: LD_VAR 0 3
61819: PPUSH
61820: LD_INT 1
61822: PPUSH
61823: CALL_OW 289
61827: PUSH
61828: LD_INT 100
61830: LESS
61831: PUSH
61832: LD_VAR 0 3
61836: PPUSH
61837: CALL_OW 314
61841: NOT
61842: AND
61843: IFFALSE 61872
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61845: LD_VAR 0 3
61849: PPUSH
61850: LD_VAR 0 6
61854: PUSH
61855: LD_INT 2
61857: ARRAY
61858: PPUSH
61859: LD_VAR 0 6
61863: PUSH
61864: LD_INT 3
61866: ARRAY
61867: PPUSH
61868: CALL_OW 117
// break ;
61872: GO 61876
// end ;
61874: GO 61309
61876: POP
61877: POP
// end ; end ;
61878: GO 60147
61880: POP
61881: POP
// end ;
61882: LD_VAR 0 1
61886: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
61887: LD_INT 0
61889: PPUSH
61890: PPUSH
61891: PPUSH
61892: PPUSH
// if not mc_bases then
61893: LD_EXP 42
61897: NOT
61898: IFFALSE 61902
// exit ;
61900: GO 62063
// for i = 1 to mc_bases do
61902: LD_ADDR_VAR 0 2
61906: PUSH
61907: DOUBLE
61908: LD_INT 1
61910: DEC
61911: ST_TO_ADDR
61912: LD_EXP 42
61916: PUSH
61917: FOR_TO
61918: IFFALSE 62061
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
61920: LD_ADDR_VAR 0 4
61924: PUSH
61925: LD_EXP 61
61929: PUSH
61930: LD_VAR 0 2
61934: ARRAY
61935: PUSH
61936: LD_EXP 64
61940: PUSH
61941: LD_VAR 0 2
61945: ARRAY
61946: UNION
61947: PPUSH
61948: LD_INT 33
61950: PUSH
61951: LD_INT 2
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: PPUSH
61958: CALL_OW 72
61962: ST_TO_ADDR
// if tmp then
61963: LD_VAR 0 4
61967: IFFALSE 62059
// for j in tmp do
61969: LD_ADDR_VAR 0 3
61973: PUSH
61974: LD_VAR 0 4
61978: PUSH
61979: FOR_IN
61980: IFFALSE 62057
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
61982: LD_VAR 0 3
61986: PPUSH
61987: CALL_OW 312
61991: NOT
61992: PUSH
61993: LD_VAR 0 3
61997: PPUSH
61998: CALL_OW 256
62002: PUSH
62003: LD_INT 250
62005: GREATEREQUAL
62006: AND
62007: IFFALSE 62020
// Connect ( j ) else
62009: LD_VAR 0 3
62013: PPUSH
62014: CALL 17683 0 1
62018: GO 62055
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62020: LD_VAR 0 3
62024: PPUSH
62025: CALL_OW 256
62029: PUSH
62030: LD_INT 250
62032: LESS
62033: PUSH
62034: LD_VAR 0 3
62038: PPUSH
62039: CALL_OW 312
62043: AND
62044: IFFALSE 62055
// ComUnlink ( j ) ;
62046: LD_VAR 0 3
62050: PPUSH
62051: CALL_OW 136
62055: GO 61979
62057: POP
62058: POP
// end ;
62059: GO 61917
62061: POP
62062: POP
// end ;
62063: LD_VAR 0 1
62067: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62068: LD_INT 0
62070: PPUSH
62071: PPUSH
62072: PPUSH
62073: PPUSH
62074: PPUSH
// if not mc_bases then
62075: LD_EXP 42
62079: NOT
62080: IFFALSE 62084
// exit ;
62082: GO 62529
// for i = 1 to mc_bases do
62084: LD_ADDR_VAR 0 2
62088: PUSH
62089: DOUBLE
62090: LD_INT 1
62092: DEC
62093: ST_TO_ADDR
62094: LD_EXP 42
62098: PUSH
62099: FOR_TO
62100: IFFALSE 62527
// begin if not mc_produce [ i ] then
62102: LD_EXP 63
62106: PUSH
62107: LD_VAR 0 2
62111: ARRAY
62112: NOT
62113: IFFALSE 62117
// continue ;
62115: GO 62099
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62117: LD_ADDR_VAR 0 5
62121: PUSH
62122: LD_EXP 42
62126: PUSH
62127: LD_VAR 0 2
62131: ARRAY
62132: PPUSH
62133: LD_INT 30
62135: PUSH
62136: LD_INT 3
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PPUSH
62143: CALL_OW 72
62147: ST_TO_ADDR
// if not fac then
62148: LD_VAR 0 5
62152: NOT
62153: IFFALSE 62157
// continue ;
62155: GO 62099
// for j in fac do
62157: LD_ADDR_VAR 0 3
62161: PUSH
62162: LD_VAR 0 5
62166: PUSH
62167: FOR_IN
62168: IFFALSE 62523
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62170: LD_VAR 0 3
62174: PPUSH
62175: CALL_OW 461
62179: PUSH
62180: LD_INT 2
62182: NONEQUAL
62183: PUSH
62184: LD_VAR 0 3
62188: PPUSH
62189: LD_INT 15
62191: PPUSH
62192: CALL 17343 0 2
62196: PUSH
62197: LD_INT 4
62199: ARRAY
62200: OR
62201: IFFALSE 62205
// continue ;
62203: GO 62167
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62205: LD_VAR 0 3
62209: PPUSH
62210: LD_EXP 63
62214: PUSH
62215: LD_VAR 0 2
62219: ARRAY
62220: PUSH
62221: LD_INT 1
62223: ARRAY
62224: PUSH
62225: LD_INT 1
62227: ARRAY
62228: PPUSH
62229: LD_EXP 63
62233: PUSH
62234: LD_VAR 0 2
62238: ARRAY
62239: PUSH
62240: LD_INT 1
62242: ARRAY
62243: PUSH
62244: LD_INT 2
62246: ARRAY
62247: PPUSH
62248: LD_EXP 63
62252: PUSH
62253: LD_VAR 0 2
62257: ARRAY
62258: PUSH
62259: LD_INT 1
62261: ARRAY
62262: PUSH
62263: LD_INT 3
62265: ARRAY
62266: PPUSH
62267: LD_EXP 63
62271: PUSH
62272: LD_VAR 0 2
62276: ARRAY
62277: PUSH
62278: LD_INT 1
62280: ARRAY
62281: PUSH
62282: LD_INT 4
62284: ARRAY
62285: PPUSH
62286: CALL_OW 448
62290: PUSH
62291: LD_VAR 0 3
62295: PPUSH
62296: LD_EXP 63
62300: PUSH
62301: LD_VAR 0 2
62305: ARRAY
62306: PUSH
62307: LD_INT 1
62309: ARRAY
62310: PUSH
62311: LD_INT 1
62313: ARRAY
62314: PUSH
62315: LD_EXP 63
62319: PUSH
62320: LD_VAR 0 2
62324: ARRAY
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: PUSH
62330: LD_INT 2
62332: ARRAY
62333: PUSH
62334: LD_EXP 63
62338: PUSH
62339: LD_VAR 0 2
62343: ARRAY
62344: PUSH
62345: LD_INT 1
62347: ARRAY
62348: PUSH
62349: LD_INT 3
62351: ARRAY
62352: PUSH
62353: LD_EXP 63
62357: PUSH
62358: LD_VAR 0 2
62362: ARRAY
62363: PUSH
62364: LD_INT 1
62366: ARRAY
62367: PUSH
62368: LD_INT 4
62370: ARRAY
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: PPUSH
62378: CALL 21014 0 2
62382: AND
62383: IFFALSE 62521
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62385: LD_VAR 0 3
62389: PPUSH
62390: LD_EXP 63
62394: PUSH
62395: LD_VAR 0 2
62399: ARRAY
62400: PUSH
62401: LD_INT 1
62403: ARRAY
62404: PUSH
62405: LD_INT 1
62407: ARRAY
62408: PPUSH
62409: LD_EXP 63
62413: PUSH
62414: LD_VAR 0 2
62418: ARRAY
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PUSH
62424: LD_INT 2
62426: ARRAY
62427: PPUSH
62428: LD_EXP 63
62432: PUSH
62433: LD_VAR 0 2
62437: ARRAY
62438: PUSH
62439: LD_INT 1
62441: ARRAY
62442: PUSH
62443: LD_INT 3
62445: ARRAY
62446: PPUSH
62447: LD_EXP 63
62451: PUSH
62452: LD_VAR 0 2
62456: ARRAY
62457: PUSH
62458: LD_INT 1
62460: ARRAY
62461: PUSH
62462: LD_INT 4
62464: ARRAY
62465: PPUSH
62466: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62470: LD_ADDR_VAR 0 4
62474: PUSH
62475: LD_EXP 63
62479: PUSH
62480: LD_VAR 0 2
62484: ARRAY
62485: PPUSH
62486: LD_INT 1
62488: PPUSH
62489: CALL_OW 3
62493: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62494: LD_ADDR_EXP 63
62498: PUSH
62499: LD_EXP 63
62503: PPUSH
62504: LD_VAR 0 2
62508: PPUSH
62509: LD_VAR 0 4
62513: PPUSH
62514: CALL_OW 1
62518: ST_TO_ADDR
// break ;
62519: GO 62523
// end ; end ;
62521: GO 62167
62523: POP
62524: POP
// end ;
62525: GO 62099
62527: POP
62528: POP
// end ;
62529: LD_VAR 0 1
62533: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62534: LD_INT 0
62536: PPUSH
62537: PPUSH
62538: PPUSH
// if not mc_bases then
62539: LD_EXP 42
62543: NOT
62544: IFFALSE 62548
// exit ;
62546: GO 62637
// for i = 1 to mc_bases do
62548: LD_ADDR_VAR 0 2
62552: PUSH
62553: DOUBLE
62554: LD_INT 1
62556: DEC
62557: ST_TO_ADDR
62558: LD_EXP 42
62562: PUSH
62563: FOR_TO
62564: IFFALSE 62635
// begin if mc_attack [ i ] then
62566: LD_EXP 62
62570: PUSH
62571: LD_VAR 0 2
62575: ARRAY
62576: IFFALSE 62633
// begin tmp := mc_attack [ i ] [ 1 ] ;
62578: LD_ADDR_VAR 0 3
62582: PUSH
62583: LD_EXP 62
62587: PUSH
62588: LD_VAR 0 2
62592: ARRAY
62593: PUSH
62594: LD_INT 1
62596: ARRAY
62597: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62598: LD_ADDR_EXP 62
62602: PUSH
62603: LD_EXP 62
62607: PPUSH
62608: LD_VAR 0 2
62612: PPUSH
62613: EMPTY
62614: PPUSH
62615: CALL_OW 1
62619: ST_TO_ADDR
// Attack ( tmp ) ;
62620: LD_VAR 0 3
62624: PPUSH
62625: CALL 77242 0 1
// exit ;
62629: POP
62630: POP
62631: GO 62637
// end ; end ;
62633: GO 62563
62635: POP
62636: POP
// end ;
62637: LD_VAR 0 1
62641: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62642: LD_INT 0
62644: PPUSH
62645: PPUSH
62646: PPUSH
62647: PPUSH
62648: PPUSH
62649: PPUSH
62650: PPUSH
// if not mc_bases then
62651: LD_EXP 42
62655: NOT
62656: IFFALSE 62660
// exit ;
62658: GO 63264
// for i = 1 to mc_bases do
62660: LD_ADDR_VAR 0 2
62664: PUSH
62665: DOUBLE
62666: LD_INT 1
62668: DEC
62669: ST_TO_ADDR
62670: LD_EXP 42
62674: PUSH
62675: FOR_TO
62676: IFFALSE 63262
// begin if not mc_bases [ i ] then
62678: LD_EXP 42
62682: PUSH
62683: LD_VAR 0 2
62687: ARRAY
62688: NOT
62689: IFFALSE 62693
// continue ;
62691: GO 62675
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62693: LD_ADDR_VAR 0 7
62697: PUSH
62698: LD_EXP 42
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: PUSH
62709: LD_INT 1
62711: ARRAY
62712: PPUSH
62713: CALL 11586 0 1
62717: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62718: LD_ADDR_EXP 65
62722: PUSH
62723: LD_EXP 65
62727: PPUSH
62728: LD_VAR 0 2
62732: PPUSH
62733: LD_EXP 42
62737: PUSH
62738: LD_VAR 0 2
62742: ARRAY
62743: PUSH
62744: LD_INT 1
62746: ARRAY
62747: PPUSH
62748: CALL_OW 255
62752: PPUSH
62753: LD_EXP 67
62757: PUSH
62758: LD_VAR 0 2
62762: ARRAY
62763: PPUSH
62764: CALL 11551 0 2
62768: PPUSH
62769: CALL_OW 1
62773: ST_TO_ADDR
// if not mc_scan [ i ] then
62774: LD_EXP 65
62778: PUSH
62779: LD_VAR 0 2
62783: ARRAY
62784: NOT
62785: IFFALSE 62940
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62787: LD_ADDR_VAR 0 4
62791: PUSH
62792: LD_EXP 42
62796: PUSH
62797: LD_VAR 0 2
62801: ARRAY
62802: PPUSH
62803: LD_INT 2
62805: PUSH
62806: LD_INT 25
62808: PUSH
62809: LD_INT 5
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: LD_INT 25
62818: PUSH
62819: LD_INT 8
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: LD_INT 25
62828: PUSH
62829: LD_INT 9
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: PUSH
62836: EMPTY
62837: LIST
62838: LIST
62839: LIST
62840: LIST
62841: PPUSH
62842: CALL_OW 72
62846: ST_TO_ADDR
// if not tmp then
62847: LD_VAR 0 4
62851: NOT
62852: IFFALSE 62856
// continue ;
62854: GO 62675
// for j in tmp do
62856: LD_ADDR_VAR 0 3
62860: PUSH
62861: LD_VAR 0 4
62865: PUSH
62866: FOR_IN
62867: IFFALSE 62938
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
62869: LD_VAR 0 3
62873: PPUSH
62874: CALL_OW 310
62878: PPUSH
62879: CALL_OW 266
62883: PUSH
62884: LD_INT 5
62886: EQUAL
62887: PUSH
62888: LD_VAR 0 3
62892: PPUSH
62893: CALL_OW 257
62897: PUSH
62898: LD_INT 1
62900: EQUAL
62901: AND
62902: PUSH
62903: LD_VAR 0 3
62907: PPUSH
62908: CALL_OW 459
62912: NOT
62913: AND
62914: PUSH
62915: LD_VAR 0 7
62919: AND
62920: IFFALSE 62936
// ComChangeProfession ( j , class ) ;
62922: LD_VAR 0 3
62926: PPUSH
62927: LD_VAR 0 7
62931: PPUSH
62932: CALL_OW 123
62936: GO 62866
62938: POP
62939: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
62940: LD_EXP 65
62944: PUSH
62945: LD_VAR 0 2
62949: ARRAY
62950: PUSH
62951: LD_EXP 64
62955: PUSH
62956: LD_VAR 0 2
62960: ARRAY
62961: NOT
62962: AND
62963: PUSH
62964: LD_EXP 42
62968: PUSH
62969: LD_VAR 0 2
62973: ARRAY
62974: PPUSH
62975: LD_INT 30
62977: PUSH
62978: LD_INT 32
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PPUSH
62985: CALL_OW 72
62989: NOT
62990: AND
62991: PUSH
62992: LD_EXP 42
62996: PUSH
62997: LD_VAR 0 2
63001: ARRAY
63002: PPUSH
63003: LD_INT 2
63005: PUSH
63006: LD_INT 30
63008: PUSH
63009: LD_INT 4
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PUSH
63016: LD_INT 30
63018: PUSH
63019: LD_INT 5
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: LIST
63030: PPUSH
63031: CALL_OW 72
63035: NOT
63036: AND
63037: IFFALSE 63169
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63039: LD_ADDR_VAR 0 4
63043: PUSH
63044: LD_EXP 42
63048: PUSH
63049: LD_VAR 0 2
63053: ARRAY
63054: PPUSH
63055: LD_INT 2
63057: PUSH
63058: LD_INT 25
63060: PUSH
63061: LD_INT 1
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: LD_INT 25
63070: PUSH
63071: LD_INT 5
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 25
63080: PUSH
63081: LD_INT 8
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: PUSH
63088: LD_INT 25
63090: PUSH
63091: LD_INT 9
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: LIST
63102: LIST
63103: LIST
63104: PPUSH
63105: CALL_OW 72
63109: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63110: LD_ADDR_VAR 0 4
63114: PUSH
63115: LD_VAR 0 4
63119: PUSH
63120: LD_VAR 0 4
63124: PPUSH
63125: LD_INT 18
63127: PPUSH
63128: CALL 43311 0 2
63132: DIFF
63133: ST_TO_ADDR
// if tmp then
63134: LD_VAR 0 4
63138: IFFALSE 63169
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63140: LD_VAR 0 2
63144: PPUSH
63145: LD_VAR 0 4
63149: PPUSH
63150: LD_EXP 67
63154: PUSH
63155: LD_VAR 0 2
63159: ARRAY
63160: PPUSH
63161: CALL 81951 0 3
// exit ;
63165: POP
63166: POP
63167: GO 63264
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
63169: LD_EXP 65
63173: PUSH
63174: LD_VAR 0 2
63178: ARRAY
63179: PUSH
63180: LD_EXP 64
63184: PUSH
63185: LD_VAR 0 2
63189: ARRAY
63190: AND
63191: IFFALSE 63260
// begin tmp := mc_defender [ i ] ;
63193: LD_ADDR_VAR 0 4
63197: PUSH
63198: LD_EXP 64
63202: PUSH
63203: LD_VAR 0 2
63207: ARRAY
63208: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63209: LD_ADDR_EXP 64
63213: PUSH
63214: LD_EXP 64
63218: PPUSH
63219: LD_VAR 0 2
63223: PPUSH
63224: EMPTY
63225: PPUSH
63226: CALL_OW 1
63230: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63231: LD_VAR 0 2
63235: PPUSH
63236: LD_VAR 0 4
63240: PPUSH
63241: LD_EXP 65
63245: PUSH
63246: LD_VAR 0 2
63250: ARRAY
63251: PPUSH
63252: CALL 82512 0 3
// exit ;
63256: POP
63257: POP
63258: GO 63264
// end ; end ;
63260: GO 62675
63262: POP
63263: POP
// end ;
63264: LD_VAR 0 1
63268: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63269: LD_INT 0
63271: PPUSH
63272: PPUSH
63273: PPUSH
63274: PPUSH
63275: PPUSH
63276: PPUSH
63277: PPUSH
63278: PPUSH
63279: PPUSH
63280: PPUSH
63281: PPUSH
// if not mc_bases then
63282: LD_EXP 42
63286: NOT
63287: IFFALSE 63291
// exit ;
63289: GO 64378
// for i = 1 to mc_bases do
63291: LD_ADDR_VAR 0 2
63295: PUSH
63296: DOUBLE
63297: LD_INT 1
63299: DEC
63300: ST_TO_ADDR
63301: LD_EXP 42
63305: PUSH
63306: FOR_TO
63307: IFFALSE 64376
// begin tmp := mc_lab [ i ] ;
63309: LD_ADDR_VAR 0 6
63313: PUSH
63314: LD_EXP 75
63318: PUSH
63319: LD_VAR 0 2
63323: ARRAY
63324: ST_TO_ADDR
// if not tmp then
63325: LD_VAR 0 6
63329: NOT
63330: IFFALSE 63334
// continue ;
63332: GO 63306
// idle_lab := 0 ;
63334: LD_ADDR_VAR 0 11
63338: PUSH
63339: LD_INT 0
63341: ST_TO_ADDR
// for j in tmp do
63342: LD_ADDR_VAR 0 3
63346: PUSH
63347: LD_VAR 0 6
63351: PUSH
63352: FOR_IN
63353: IFFALSE 64372
// begin researching := false ;
63355: LD_ADDR_VAR 0 10
63359: PUSH
63360: LD_INT 0
63362: ST_TO_ADDR
// side := GetSide ( j ) ;
63363: LD_ADDR_VAR 0 4
63367: PUSH
63368: LD_VAR 0 3
63372: PPUSH
63373: CALL_OW 255
63377: ST_TO_ADDR
// if not mc_tech [ side ] then
63378: LD_EXP 69
63382: PUSH
63383: LD_VAR 0 4
63387: ARRAY
63388: NOT
63389: IFFALSE 63393
// continue ;
63391: GO 63352
// if BuildingStatus ( j ) = bs_idle then
63393: LD_VAR 0 3
63397: PPUSH
63398: CALL_OW 461
63402: PUSH
63403: LD_INT 2
63405: EQUAL
63406: IFFALSE 63594
// begin if idle_lab and UnitsInside ( j ) < 6 then
63408: LD_VAR 0 11
63412: PUSH
63413: LD_VAR 0 3
63417: PPUSH
63418: CALL_OW 313
63422: PUSH
63423: LD_INT 6
63425: LESS
63426: AND
63427: IFFALSE 63498
// begin tmp2 := UnitsInside ( idle_lab ) ;
63429: LD_ADDR_VAR 0 9
63433: PUSH
63434: LD_VAR 0 11
63438: PPUSH
63439: CALL_OW 313
63443: ST_TO_ADDR
// if tmp2 then
63444: LD_VAR 0 9
63448: IFFALSE 63490
// for x in tmp2 do
63450: LD_ADDR_VAR 0 7
63454: PUSH
63455: LD_VAR 0 9
63459: PUSH
63460: FOR_IN
63461: IFFALSE 63488
// begin ComExitBuilding ( x ) ;
63463: LD_VAR 0 7
63467: PPUSH
63468: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63472: LD_VAR 0 7
63476: PPUSH
63477: LD_VAR 0 3
63481: PPUSH
63482: CALL_OW 180
// end ;
63486: GO 63460
63488: POP
63489: POP
// idle_lab := 0 ;
63490: LD_ADDR_VAR 0 11
63494: PUSH
63495: LD_INT 0
63497: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63498: LD_ADDR_VAR 0 5
63502: PUSH
63503: LD_EXP 69
63507: PUSH
63508: LD_VAR 0 4
63512: ARRAY
63513: PUSH
63514: FOR_IN
63515: IFFALSE 63575
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63517: LD_VAR 0 3
63521: PPUSH
63522: LD_VAR 0 5
63526: PPUSH
63527: CALL_OW 430
63531: PUSH
63532: LD_VAR 0 4
63536: PPUSH
63537: LD_VAR 0 5
63541: PPUSH
63542: CALL 10656 0 2
63546: AND
63547: IFFALSE 63573
// begin researching := true ;
63549: LD_ADDR_VAR 0 10
63553: PUSH
63554: LD_INT 1
63556: ST_TO_ADDR
// ComResearch ( j , t ) ;
63557: LD_VAR 0 3
63561: PPUSH
63562: LD_VAR 0 5
63566: PPUSH
63567: CALL_OW 124
// break ;
63571: GO 63575
// end ;
63573: GO 63514
63575: POP
63576: POP
// if not researching then
63577: LD_VAR 0 10
63581: NOT
63582: IFFALSE 63594
// idle_lab := j ;
63584: LD_ADDR_VAR 0 11
63588: PUSH
63589: LD_VAR 0 3
63593: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63594: LD_VAR 0 3
63598: PPUSH
63599: CALL_OW 461
63603: PUSH
63604: LD_INT 10
63606: EQUAL
63607: IFFALSE 64195
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63609: LD_EXP 71
63613: PUSH
63614: LD_VAR 0 2
63618: ARRAY
63619: NOT
63620: PUSH
63621: LD_EXP 72
63625: PUSH
63626: LD_VAR 0 2
63630: ARRAY
63631: NOT
63632: AND
63633: PUSH
63634: LD_EXP 69
63638: PUSH
63639: LD_VAR 0 4
63643: ARRAY
63644: PUSH
63645: LD_INT 1
63647: GREATER
63648: AND
63649: IFFALSE 63780
// begin ComCancel ( j ) ;
63651: LD_VAR 0 3
63655: PPUSH
63656: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63660: LD_ADDR_EXP 69
63664: PUSH
63665: LD_EXP 69
63669: PPUSH
63670: LD_VAR 0 4
63674: PPUSH
63675: LD_EXP 69
63679: PUSH
63680: LD_VAR 0 4
63684: ARRAY
63685: PPUSH
63686: LD_EXP 69
63690: PUSH
63691: LD_VAR 0 4
63695: ARRAY
63696: PUSH
63697: LD_INT 1
63699: MINUS
63700: PPUSH
63701: LD_EXP 69
63705: PUSH
63706: LD_VAR 0 4
63710: ARRAY
63711: PPUSH
63712: LD_INT 0
63714: PPUSH
63715: CALL 14168 0 4
63719: PPUSH
63720: CALL_OW 1
63724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
63725: LD_ADDR_EXP 69
63729: PUSH
63730: LD_EXP 69
63734: PPUSH
63735: LD_VAR 0 4
63739: PPUSH
63740: LD_EXP 69
63744: PUSH
63745: LD_VAR 0 4
63749: ARRAY
63750: PPUSH
63751: LD_EXP 69
63755: PUSH
63756: LD_VAR 0 4
63760: ARRAY
63761: PPUSH
63762: LD_INT 1
63764: PPUSH
63765: LD_INT 0
63767: PPUSH
63768: CALL 14168 0 4
63772: PPUSH
63773: CALL_OW 1
63777: ST_TO_ADDR
// continue ;
63778: GO 63352
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
63780: LD_EXP 71
63784: PUSH
63785: LD_VAR 0 2
63789: ARRAY
63790: PUSH
63791: LD_EXP 72
63795: PUSH
63796: LD_VAR 0 2
63800: ARRAY
63801: NOT
63802: AND
63803: IFFALSE 63930
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
63805: LD_ADDR_EXP 72
63809: PUSH
63810: LD_EXP 72
63814: PPUSH
63815: LD_VAR 0 2
63819: PUSH
63820: LD_EXP 72
63824: PUSH
63825: LD_VAR 0 2
63829: ARRAY
63830: PUSH
63831: LD_INT 1
63833: PLUS
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PPUSH
63839: LD_EXP 71
63843: PUSH
63844: LD_VAR 0 2
63848: ARRAY
63849: PUSH
63850: LD_INT 1
63852: ARRAY
63853: PPUSH
63854: CALL 14750 0 3
63858: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
63859: LD_EXP 71
63863: PUSH
63864: LD_VAR 0 2
63868: ARRAY
63869: PUSH
63870: LD_INT 1
63872: ARRAY
63873: PPUSH
63874: LD_INT 112
63876: PPUSH
63877: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
63881: LD_ADDR_VAR 0 9
63885: PUSH
63886: LD_EXP 71
63890: PUSH
63891: LD_VAR 0 2
63895: ARRAY
63896: PPUSH
63897: LD_INT 1
63899: PPUSH
63900: CALL_OW 3
63904: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
63905: LD_ADDR_EXP 71
63909: PUSH
63910: LD_EXP 71
63914: PPUSH
63915: LD_VAR 0 2
63919: PPUSH
63920: LD_VAR 0 9
63924: PPUSH
63925: CALL_OW 1
63929: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
63930: LD_EXP 71
63934: PUSH
63935: LD_VAR 0 2
63939: ARRAY
63940: PUSH
63941: LD_EXP 72
63945: PUSH
63946: LD_VAR 0 2
63950: ARRAY
63951: AND
63952: PUSH
63953: LD_EXP 72
63957: PUSH
63958: LD_VAR 0 2
63962: ARRAY
63963: PUSH
63964: LD_INT 1
63966: ARRAY
63967: PPUSH
63968: CALL_OW 310
63972: NOT
63973: AND
63974: PUSH
63975: LD_VAR 0 3
63979: PPUSH
63980: CALL_OW 313
63984: PUSH
63985: LD_INT 6
63987: EQUAL
63988: AND
63989: IFFALSE 64045
// begin tmp2 := UnitsInside ( j ) ;
63991: LD_ADDR_VAR 0 9
63995: PUSH
63996: LD_VAR 0 3
64000: PPUSH
64001: CALL_OW 313
64005: ST_TO_ADDR
// if tmp2 = 6 then
64006: LD_VAR 0 9
64010: PUSH
64011: LD_INT 6
64013: EQUAL
64014: IFFALSE 64045
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64016: LD_VAR 0 9
64020: PUSH
64021: LD_INT 1
64023: ARRAY
64024: PPUSH
64025: LD_INT 112
64027: PPUSH
64028: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64032: LD_VAR 0 9
64036: PUSH
64037: LD_INT 1
64039: ARRAY
64040: PPUSH
64041: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64045: LD_EXP 72
64049: PUSH
64050: LD_VAR 0 2
64054: ARRAY
64055: PUSH
64056: LD_EXP 72
64060: PUSH
64061: LD_VAR 0 2
64065: ARRAY
64066: PUSH
64067: LD_INT 1
64069: ARRAY
64070: PPUSH
64071: CALL_OW 314
64075: NOT
64076: AND
64077: PUSH
64078: LD_EXP 72
64082: PUSH
64083: LD_VAR 0 2
64087: ARRAY
64088: PUSH
64089: LD_INT 1
64091: ARRAY
64092: PPUSH
64093: CALL_OW 310
64097: NOT
64098: AND
64099: IFFALSE 64125
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64101: LD_EXP 72
64105: PUSH
64106: LD_VAR 0 2
64110: ARRAY
64111: PUSH
64112: LD_INT 1
64114: ARRAY
64115: PPUSH
64116: LD_VAR 0 3
64120: PPUSH
64121: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64125: LD_EXP 72
64129: PUSH
64130: LD_VAR 0 2
64134: ARRAY
64135: PUSH
64136: LD_INT 1
64138: ARRAY
64139: PPUSH
64140: CALL_OW 310
64144: PUSH
64145: LD_EXP 72
64149: PUSH
64150: LD_VAR 0 2
64154: ARRAY
64155: PUSH
64156: LD_INT 1
64158: ARRAY
64159: PPUSH
64160: CALL_OW 310
64164: PPUSH
64165: CALL_OW 461
64169: PUSH
64170: LD_INT 3
64172: NONEQUAL
64173: AND
64174: IFFALSE 64195
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64176: LD_EXP 72
64180: PUSH
64181: LD_VAR 0 2
64185: ARRAY
64186: PUSH
64187: LD_INT 1
64189: ARRAY
64190: PPUSH
64191: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64195: LD_VAR 0 3
64199: PPUSH
64200: CALL_OW 461
64204: PUSH
64205: LD_INT 6
64207: EQUAL
64208: PUSH
64209: LD_VAR 0 6
64213: PUSH
64214: LD_INT 1
64216: GREATER
64217: AND
64218: IFFALSE 64370
// begin sci := [ ] ;
64220: LD_ADDR_VAR 0 8
64224: PUSH
64225: EMPTY
64226: ST_TO_ADDR
// for x in ( tmp diff j ) do
64227: LD_ADDR_VAR 0 7
64231: PUSH
64232: LD_VAR 0 6
64236: PUSH
64237: LD_VAR 0 3
64241: DIFF
64242: PUSH
64243: FOR_IN
64244: IFFALSE 64296
// begin if sci = 6 then
64246: LD_VAR 0 8
64250: PUSH
64251: LD_INT 6
64253: EQUAL
64254: IFFALSE 64258
// break ;
64256: GO 64296
// if BuildingStatus ( x ) = bs_idle then
64258: LD_VAR 0 7
64262: PPUSH
64263: CALL_OW 461
64267: PUSH
64268: LD_INT 2
64270: EQUAL
64271: IFFALSE 64294
// sci := sci ^ UnitsInside ( x ) ;
64273: LD_ADDR_VAR 0 8
64277: PUSH
64278: LD_VAR 0 8
64282: PUSH
64283: LD_VAR 0 7
64287: PPUSH
64288: CALL_OW 313
64292: ADD
64293: ST_TO_ADDR
// end ;
64294: GO 64243
64296: POP
64297: POP
// if not sci then
64298: LD_VAR 0 8
64302: NOT
64303: IFFALSE 64307
// continue ;
64305: GO 63352
// for x in sci do
64307: LD_ADDR_VAR 0 7
64311: PUSH
64312: LD_VAR 0 8
64316: PUSH
64317: FOR_IN
64318: IFFALSE 64368
// if IsInUnit ( x ) and not HasTask ( x ) then
64320: LD_VAR 0 7
64324: PPUSH
64325: CALL_OW 310
64329: PUSH
64330: LD_VAR 0 7
64334: PPUSH
64335: CALL_OW 314
64339: NOT
64340: AND
64341: IFFALSE 64366
// begin ComExitBuilding ( x ) ;
64343: LD_VAR 0 7
64347: PPUSH
64348: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64352: LD_VAR 0 7
64356: PPUSH
64357: LD_VAR 0 3
64361: PPUSH
64362: CALL_OW 180
// end ;
64366: GO 64317
64368: POP
64369: POP
// end ; end ;
64370: GO 63352
64372: POP
64373: POP
// end ;
64374: GO 63306
64376: POP
64377: POP
// end ;
64378: LD_VAR 0 1
64382: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64383: LD_INT 0
64385: PPUSH
64386: PPUSH
// if not mc_bases then
64387: LD_EXP 42
64391: NOT
64392: IFFALSE 64396
// exit ;
64394: GO 64477
// for i = 1 to mc_bases do
64396: LD_ADDR_VAR 0 2
64400: PUSH
64401: DOUBLE
64402: LD_INT 1
64404: DEC
64405: ST_TO_ADDR
64406: LD_EXP 42
64410: PUSH
64411: FOR_TO
64412: IFFALSE 64475
// if mc_mines [ i ] and mc_miners [ i ] then
64414: LD_EXP 55
64418: PUSH
64419: LD_VAR 0 2
64423: ARRAY
64424: PUSH
64425: LD_EXP 56
64429: PUSH
64430: LD_VAR 0 2
64434: ARRAY
64435: AND
64436: IFFALSE 64473
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64438: LD_EXP 56
64442: PUSH
64443: LD_VAR 0 2
64447: ARRAY
64448: PUSH
64449: LD_INT 1
64451: ARRAY
64452: PPUSH
64453: CALL_OW 255
64457: PPUSH
64458: LD_EXP 55
64462: PUSH
64463: LD_VAR 0 2
64467: ARRAY
64468: PPUSH
64469: CALL 11739 0 2
64473: GO 64411
64475: POP
64476: POP
// end ;
64477: LD_VAR 0 1
64481: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64482: LD_INT 0
64484: PPUSH
64485: PPUSH
64486: PPUSH
64487: PPUSH
64488: PPUSH
64489: PPUSH
64490: PPUSH
64491: PPUSH
// if not mc_bases or not mc_parking then
64492: LD_EXP 42
64496: NOT
64497: PUSH
64498: LD_EXP 66
64502: NOT
64503: OR
64504: IFFALSE 64508
// exit ;
64506: GO 65207
// for i = 1 to mc_bases do
64508: LD_ADDR_VAR 0 2
64512: PUSH
64513: DOUBLE
64514: LD_INT 1
64516: DEC
64517: ST_TO_ADDR
64518: LD_EXP 42
64522: PUSH
64523: FOR_TO
64524: IFFALSE 65205
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64526: LD_EXP 42
64530: PUSH
64531: LD_VAR 0 2
64535: ARRAY
64536: NOT
64537: PUSH
64538: LD_EXP 66
64542: PUSH
64543: LD_VAR 0 2
64547: ARRAY
64548: NOT
64549: OR
64550: IFFALSE 64554
// continue ;
64552: GO 64523
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64554: LD_ADDR_VAR 0 5
64558: PUSH
64559: LD_EXP 42
64563: PUSH
64564: LD_VAR 0 2
64568: ARRAY
64569: PUSH
64570: LD_INT 1
64572: ARRAY
64573: PPUSH
64574: CALL_OW 255
64578: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64579: LD_ADDR_VAR 0 6
64583: PUSH
64584: LD_EXP 42
64588: PUSH
64589: LD_VAR 0 2
64593: ARRAY
64594: PPUSH
64595: LD_INT 30
64597: PUSH
64598: LD_INT 3
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PPUSH
64605: CALL_OW 72
64609: ST_TO_ADDR
// if not fac then
64610: LD_VAR 0 6
64614: NOT
64615: IFFALSE 64666
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64617: LD_ADDR_VAR 0 6
64621: PUSH
64622: LD_EXP 42
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: PPUSH
64633: LD_INT 2
64635: PUSH
64636: LD_INT 30
64638: PUSH
64639: LD_INT 0
64641: PUSH
64642: EMPTY
64643: LIST
64644: LIST
64645: PUSH
64646: LD_INT 30
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: LIST
64660: PPUSH
64661: CALL_OW 72
64665: ST_TO_ADDR
// if not fac then
64666: LD_VAR 0 6
64670: NOT
64671: IFFALSE 64675
// continue ;
64673: GO 64523
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64675: LD_ADDR_VAR 0 7
64679: PUSH
64680: LD_EXP 66
64684: PUSH
64685: LD_VAR 0 2
64689: ARRAY
64690: PPUSH
64691: LD_INT 22
64693: PUSH
64694: LD_VAR 0 5
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 21
64705: PUSH
64706: LD_INT 2
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 3
64715: PUSH
64716: LD_INT 24
64718: PUSH
64719: LD_INT 1000
64721: PUSH
64722: EMPTY
64723: LIST
64724: LIST
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: PUSH
64730: EMPTY
64731: LIST
64732: LIST
64733: LIST
64734: PPUSH
64735: CALL_OW 70
64739: ST_TO_ADDR
// for j in fac do
64740: LD_ADDR_VAR 0 3
64744: PUSH
64745: LD_VAR 0 6
64749: PUSH
64750: FOR_IN
64751: IFFALSE 64832
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64753: LD_ADDR_VAR 0 7
64757: PUSH
64758: LD_VAR 0 7
64762: PUSH
64763: LD_INT 22
64765: PUSH
64766: LD_VAR 0 5
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: LD_INT 91
64777: PUSH
64778: LD_VAR 0 3
64782: PUSH
64783: LD_INT 15
64785: PUSH
64786: EMPTY
64787: LIST
64788: LIST
64789: LIST
64790: PUSH
64791: LD_INT 21
64793: PUSH
64794: LD_INT 2
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: LD_INT 3
64803: PUSH
64804: LD_INT 24
64806: PUSH
64807: LD_INT 1000
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: PPUSH
64824: CALL_OW 69
64828: UNION
64829: ST_TO_ADDR
64830: GO 64750
64832: POP
64833: POP
// if not vehs then
64834: LD_VAR 0 7
64838: NOT
64839: IFFALSE 64865
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64841: LD_ADDR_EXP 54
64845: PUSH
64846: LD_EXP 54
64850: PPUSH
64851: LD_VAR 0 2
64855: PPUSH
64856: EMPTY
64857: PPUSH
64858: CALL_OW 1
64862: ST_TO_ADDR
// continue ;
64863: GO 64523
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64865: LD_ADDR_VAR 0 8
64869: PUSH
64870: LD_EXP 42
64874: PUSH
64875: LD_VAR 0 2
64879: ARRAY
64880: PPUSH
64881: LD_INT 30
64883: PUSH
64884: LD_INT 3
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PPUSH
64891: CALL_OW 72
64895: ST_TO_ADDR
// if tmp then
64896: LD_VAR 0 8
64900: IFFALSE 65003
// begin for j in tmp do
64902: LD_ADDR_VAR 0 3
64906: PUSH
64907: LD_VAR 0 8
64911: PUSH
64912: FOR_IN
64913: IFFALSE 65001
// for k in UnitsInside ( j ) do
64915: LD_ADDR_VAR 0 4
64919: PUSH
64920: LD_VAR 0 3
64924: PPUSH
64925: CALL_OW 313
64929: PUSH
64930: FOR_IN
64931: IFFALSE 64997
// if k then
64933: LD_VAR 0 4
64937: IFFALSE 64995
// if not k in mc_repair_vehicle [ i ] then
64939: LD_VAR 0 4
64943: PUSH
64944: LD_EXP 54
64948: PUSH
64949: LD_VAR 0 2
64953: ARRAY
64954: IN
64955: NOT
64956: IFFALSE 64995
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
64958: LD_ADDR_EXP 54
64962: PUSH
64963: LD_EXP 54
64967: PPUSH
64968: LD_VAR 0 2
64972: PPUSH
64973: LD_EXP 54
64977: PUSH
64978: LD_VAR 0 2
64982: ARRAY
64983: PUSH
64984: LD_VAR 0 4
64988: UNION
64989: PPUSH
64990: CALL_OW 1
64994: ST_TO_ADDR
64995: GO 64930
64997: POP
64998: POP
64999: GO 64912
65001: POP
65002: POP
// end ; if not mc_repair_vehicle [ i ] then
65003: LD_EXP 54
65007: PUSH
65008: LD_VAR 0 2
65012: ARRAY
65013: NOT
65014: IFFALSE 65018
// continue ;
65016: GO 64523
// for j in mc_repair_vehicle [ i ] do
65018: LD_ADDR_VAR 0 3
65022: PUSH
65023: LD_EXP 54
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: PUSH
65034: FOR_IN
65035: IFFALSE 65201
// begin if GetClass ( j ) <> 3 then
65037: LD_VAR 0 3
65041: PPUSH
65042: CALL_OW 257
65046: PUSH
65047: LD_INT 3
65049: NONEQUAL
65050: IFFALSE 65091
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65052: LD_ADDR_EXP 54
65056: PUSH
65057: LD_EXP 54
65061: PPUSH
65062: LD_VAR 0 2
65066: PPUSH
65067: LD_EXP 54
65071: PUSH
65072: LD_VAR 0 2
65076: ARRAY
65077: PUSH
65078: LD_VAR 0 3
65082: DIFF
65083: PPUSH
65084: CALL_OW 1
65088: ST_TO_ADDR
// continue ;
65089: GO 65034
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65091: LD_VAR 0 3
65095: PPUSH
65096: CALL_OW 311
65100: NOT
65101: PUSH
65102: LD_VAR 0 3
65106: PUSH
65107: LD_EXP 45
65111: PUSH
65112: LD_VAR 0 2
65116: ARRAY
65117: PUSH
65118: LD_INT 1
65120: ARRAY
65121: IN
65122: NOT
65123: AND
65124: PUSH
65125: LD_VAR 0 3
65129: PUSH
65130: LD_EXP 45
65134: PUSH
65135: LD_VAR 0 2
65139: ARRAY
65140: PUSH
65141: LD_INT 2
65143: ARRAY
65144: IN
65145: NOT
65146: AND
65147: IFFALSE 65199
// begin if IsInUnit ( j ) then
65149: LD_VAR 0 3
65153: PPUSH
65154: CALL_OW 310
65158: IFFALSE 65169
// ComExitBuilding ( j ) ;
65160: LD_VAR 0 3
65164: PPUSH
65165: CALL_OW 122
// if not HasTask ( j ) then
65169: LD_VAR 0 3
65173: PPUSH
65174: CALL_OW 314
65178: NOT
65179: IFFALSE 65199
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65181: LD_VAR 0 3
65185: PPUSH
65186: LD_VAR 0 7
65190: PUSH
65191: LD_INT 1
65193: ARRAY
65194: PPUSH
65195: CALL_OW 189
// end ; end ;
65199: GO 65034
65201: POP
65202: POP
// end ;
65203: GO 64523
65205: POP
65206: POP
// end ;
65207: LD_VAR 0 1
65211: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65212: LD_INT 0
65214: PPUSH
65215: PPUSH
65216: PPUSH
65217: PPUSH
65218: PPUSH
65219: PPUSH
65220: PPUSH
65221: PPUSH
65222: PPUSH
65223: PPUSH
65224: PPUSH
// if not mc_bases then
65225: LD_EXP 42
65229: NOT
65230: IFFALSE 65234
// exit ;
65232: GO 66036
// for i = 1 to mc_bases do
65234: LD_ADDR_VAR 0 2
65238: PUSH
65239: DOUBLE
65240: LD_INT 1
65242: DEC
65243: ST_TO_ADDR
65244: LD_EXP 42
65248: PUSH
65249: FOR_TO
65250: IFFALSE 66034
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65252: LD_EXP 70
65256: PUSH
65257: LD_VAR 0 2
65261: ARRAY
65262: NOT
65263: PUSH
65264: LD_EXP 45
65268: PUSH
65269: LD_VAR 0 2
65273: ARRAY
65274: PUSH
65275: LD_INT 1
65277: ARRAY
65278: OR
65279: PUSH
65280: LD_EXP 45
65284: PUSH
65285: LD_VAR 0 2
65289: ARRAY
65290: PUSH
65291: LD_INT 2
65293: ARRAY
65294: OR
65295: PUSH
65296: LD_EXP 68
65300: PUSH
65301: LD_VAR 0 2
65305: ARRAY
65306: PPUSH
65307: LD_INT 1
65309: PPUSH
65310: CALL_OW 325
65314: NOT
65315: OR
65316: PUSH
65317: LD_EXP 65
65321: PUSH
65322: LD_VAR 0 2
65326: ARRAY
65327: OR
65328: IFFALSE 65332
// continue ;
65330: GO 65249
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65332: LD_ADDR_VAR 0 8
65336: PUSH
65337: LD_EXP 42
65341: PUSH
65342: LD_VAR 0 2
65346: ARRAY
65347: PPUSH
65348: LD_INT 25
65350: PUSH
65351: LD_INT 4
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: LD_INT 50
65360: PUSH
65361: EMPTY
65362: LIST
65363: PUSH
65364: LD_INT 3
65366: PUSH
65367: LD_INT 60
65369: PUSH
65370: EMPTY
65371: LIST
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: LIST
65381: PPUSH
65382: CALL_OW 72
65386: PUSH
65387: LD_EXP 46
65391: PUSH
65392: LD_VAR 0 2
65396: ARRAY
65397: DIFF
65398: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65399: LD_ADDR_VAR 0 9
65403: PUSH
65404: LD_EXP 42
65408: PUSH
65409: LD_VAR 0 2
65413: ARRAY
65414: PPUSH
65415: LD_INT 2
65417: PUSH
65418: LD_INT 30
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 30
65430: PUSH
65431: LD_INT 1
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: LIST
65442: PPUSH
65443: CALL_OW 72
65447: ST_TO_ADDR
// if not tmp or not dep then
65448: LD_VAR 0 8
65452: NOT
65453: PUSH
65454: LD_VAR 0 9
65458: NOT
65459: OR
65460: IFFALSE 65464
// continue ;
65462: GO 65249
// side := GetSide ( tmp [ 1 ] ) ;
65464: LD_ADDR_VAR 0 11
65468: PUSH
65469: LD_VAR 0 8
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: PPUSH
65478: CALL_OW 255
65482: ST_TO_ADDR
// dep := dep [ 1 ] ;
65483: LD_ADDR_VAR 0 9
65487: PUSH
65488: LD_VAR 0 9
65492: PUSH
65493: LD_INT 1
65495: ARRAY
65496: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65497: LD_ADDR_VAR 0 7
65501: PUSH
65502: LD_EXP 70
65506: PUSH
65507: LD_VAR 0 2
65511: ARRAY
65512: PPUSH
65513: LD_INT 22
65515: PUSH
65516: LD_INT 0
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: LD_INT 25
65525: PUSH
65526: LD_INT 12
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PPUSH
65537: CALL_OW 70
65541: PUSH
65542: LD_INT 22
65544: PUSH
65545: LD_INT 0
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 25
65554: PUSH
65555: LD_INT 12
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 91
65564: PUSH
65565: LD_VAR 0 9
65569: PUSH
65570: LD_INT 20
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: LIST
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: LIST
65582: PPUSH
65583: CALL_OW 69
65587: UNION
65588: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65589: LD_ADDR_VAR 0 10
65593: PUSH
65594: LD_EXP 70
65598: PUSH
65599: LD_VAR 0 2
65603: ARRAY
65604: PPUSH
65605: LD_INT 81
65607: PUSH
65608: LD_VAR 0 11
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PPUSH
65617: CALL_OW 70
65621: ST_TO_ADDR
// if not apes or danger_at_area then
65622: LD_VAR 0 7
65626: NOT
65627: PUSH
65628: LD_VAR 0 10
65632: OR
65633: IFFALSE 65683
// begin if mc_taming [ i ] then
65635: LD_EXP 73
65639: PUSH
65640: LD_VAR 0 2
65644: ARRAY
65645: IFFALSE 65681
// begin MC_Reset ( i , 121 ) ;
65647: LD_VAR 0 2
65651: PPUSH
65652: LD_INT 121
65654: PPUSH
65655: CALL 51086 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65659: LD_ADDR_EXP 73
65663: PUSH
65664: LD_EXP 73
65668: PPUSH
65669: LD_VAR 0 2
65673: PPUSH
65674: EMPTY
65675: PPUSH
65676: CALL_OW 1
65680: ST_TO_ADDR
// end ; continue ;
65681: GO 65249
// end ; for j in tmp do
65683: LD_ADDR_VAR 0 3
65687: PUSH
65688: LD_VAR 0 8
65692: PUSH
65693: FOR_IN
65694: IFFALSE 66030
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65696: LD_VAR 0 3
65700: PUSH
65701: LD_EXP 73
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: IN
65712: NOT
65713: PUSH
65714: LD_EXP 73
65718: PUSH
65719: LD_VAR 0 2
65723: ARRAY
65724: PUSH
65725: LD_INT 3
65727: LESS
65728: AND
65729: IFFALSE 65787
// begin SetTag ( j , 121 ) ;
65731: LD_VAR 0 3
65735: PPUSH
65736: LD_INT 121
65738: PPUSH
65739: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
65743: LD_ADDR_EXP 73
65747: PUSH
65748: LD_EXP 73
65752: PPUSH
65753: LD_VAR 0 2
65757: PUSH
65758: LD_EXP 73
65762: PUSH
65763: LD_VAR 0 2
65767: ARRAY
65768: PUSH
65769: LD_INT 1
65771: PLUS
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PPUSH
65777: LD_VAR 0 3
65781: PPUSH
65782: CALL 14750 0 3
65786: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
65787: LD_VAR 0 3
65791: PUSH
65792: LD_EXP 73
65796: PUSH
65797: LD_VAR 0 2
65801: ARRAY
65802: IN
65803: IFFALSE 66028
// begin if GetClass ( j ) <> 4 then
65805: LD_VAR 0 3
65809: PPUSH
65810: CALL_OW 257
65814: PUSH
65815: LD_INT 4
65817: NONEQUAL
65818: IFFALSE 65871
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
65820: LD_ADDR_EXP 73
65824: PUSH
65825: LD_EXP 73
65829: PPUSH
65830: LD_VAR 0 2
65834: PPUSH
65835: LD_EXP 73
65839: PUSH
65840: LD_VAR 0 2
65844: ARRAY
65845: PUSH
65846: LD_VAR 0 3
65850: DIFF
65851: PPUSH
65852: CALL_OW 1
65856: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65857: LD_VAR 0 3
65861: PPUSH
65862: LD_INT 0
65864: PPUSH
65865: CALL_OW 109
// continue ;
65869: GO 65693
// end ; if IsInUnit ( j ) then
65871: LD_VAR 0 3
65875: PPUSH
65876: CALL_OW 310
65880: IFFALSE 65891
// ComExitBuilding ( j ) ;
65882: LD_VAR 0 3
65886: PPUSH
65887: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
65891: LD_ADDR_VAR 0 6
65895: PUSH
65896: LD_VAR 0 7
65900: PPUSH
65901: LD_VAR 0 3
65905: PPUSH
65906: CALL_OW 74
65910: ST_TO_ADDR
// if not ape then
65911: LD_VAR 0 6
65915: NOT
65916: IFFALSE 65920
// break ;
65918: GO 66030
// x := GetX ( ape ) ;
65920: LD_ADDR_VAR 0 4
65924: PUSH
65925: LD_VAR 0 6
65929: PPUSH
65930: CALL_OW 250
65934: ST_TO_ADDR
// y := GetY ( ape ) ;
65935: LD_ADDR_VAR 0 5
65939: PUSH
65940: LD_VAR 0 6
65944: PPUSH
65945: CALL_OW 251
65949: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65950: LD_VAR 0 4
65954: PPUSH
65955: LD_VAR 0 5
65959: PPUSH
65960: CALL_OW 488
65964: NOT
65965: PUSH
65966: LD_VAR 0 11
65970: PPUSH
65971: LD_VAR 0 4
65975: PPUSH
65976: LD_VAR 0 5
65980: PPUSH
65981: LD_INT 20
65983: PPUSH
65984: CALL 15646 0 4
65988: PUSH
65989: LD_INT 4
65991: ARRAY
65992: OR
65993: IFFALSE 65997
// break ;
65995: GO 66030
// if not HasTask ( j ) then
65997: LD_VAR 0 3
66001: PPUSH
66002: CALL_OW 314
66006: NOT
66007: IFFALSE 66028
// ComTameXY ( j , x , y ) ;
66009: LD_VAR 0 3
66013: PPUSH
66014: LD_VAR 0 4
66018: PPUSH
66019: LD_VAR 0 5
66023: PPUSH
66024: CALL_OW 131
// end ; end ;
66028: GO 65693
66030: POP
66031: POP
// end ;
66032: GO 65249
66034: POP
66035: POP
// end ;
66036: LD_VAR 0 1
66040: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66041: LD_INT 0
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
// if not mc_bases then
66051: LD_EXP 42
66055: NOT
66056: IFFALSE 66060
// exit ;
66058: GO 66686
// for i = 1 to mc_bases do
66060: LD_ADDR_VAR 0 2
66064: PUSH
66065: DOUBLE
66066: LD_INT 1
66068: DEC
66069: ST_TO_ADDR
66070: LD_EXP 42
66074: PUSH
66075: FOR_TO
66076: IFFALSE 66684
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66078: LD_EXP 71
66082: PUSH
66083: LD_VAR 0 2
66087: ARRAY
66088: NOT
66089: PUSH
66090: LD_EXP 71
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: PPUSH
66101: LD_INT 25
66103: PUSH
66104: LD_INT 12
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PPUSH
66111: CALL_OW 72
66115: NOT
66116: OR
66117: IFFALSE 66121
// continue ;
66119: GO 66075
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66121: LD_ADDR_VAR 0 5
66125: PUSH
66126: LD_EXP 71
66130: PUSH
66131: LD_VAR 0 2
66135: ARRAY
66136: PUSH
66137: LD_INT 1
66139: ARRAY
66140: PPUSH
66141: CALL_OW 255
66145: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66146: LD_VAR 0 5
66150: PPUSH
66151: LD_INT 2
66153: PPUSH
66154: CALL_OW 325
66158: IFFALSE 66411
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66160: LD_ADDR_VAR 0 4
66164: PUSH
66165: LD_EXP 71
66169: PUSH
66170: LD_VAR 0 2
66174: ARRAY
66175: PPUSH
66176: LD_INT 25
66178: PUSH
66179: LD_INT 16
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: PPUSH
66186: CALL_OW 72
66190: ST_TO_ADDR
// if tmp < 6 then
66191: LD_VAR 0 4
66195: PUSH
66196: LD_INT 6
66198: LESS
66199: IFFALSE 66411
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66201: LD_ADDR_VAR 0 6
66205: PUSH
66206: LD_EXP 42
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PPUSH
66217: LD_INT 2
66219: PUSH
66220: LD_INT 30
66222: PUSH
66223: LD_INT 0
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 30
66232: PUSH
66233: LD_INT 1
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: LIST
66244: PPUSH
66245: CALL_OW 72
66249: ST_TO_ADDR
// if depot then
66250: LD_VAR 0 6
66254: IFFALSE 66411
// begin selected := 0 ;
66256: LD_ADDR_VAR 0 7
66260: PUSH
66261: LD_INT 0
66263: ST_TO_ADDR
// for j in depot do
66264: LD_ADDR_VAR 0 3
66268: PUSH
66269: LD_VAR 0 6
66273: PUSH
66274: FOR_IN
66275: IFFALSE 66306
// begin if UnitsInside ( j ) < 6 then
66277: LD_VAR 0 3
66281: PPUSH
66282: CALL_OW 313
66286: PUSH
66287: LD_INT 6
66289: LESS
66290: IFFALSE 66304
// begin selected := j ;
66292: LD_ADDR_VAR 0 7
66296: PUSH
66297: LD_VAR 0 3
66301: ST_TO_ADDR
// break ;
66302: GO 66306
// end ; end ;
66304: GO 66274
66306: POP
66307: POP
// if selected then
66308: LD_VAR 0 7
66312: IFFALSE 66411
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66314: LD_ADDR_VAR 0 3
66318: PUSH
66319: LD_EXP 71
66323: PUSH
66324: LD_VAR 0 2
66328: ARRAY
66329: PPUSH
66330: LD_INT 25
66332: PUSH
66333: LD_INT 12
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PPUSH
66340: CALL_OW 72
66344: PUSH
66345: FOR_IN
66346: IFFALSE 66409
// if not HasTask ( j ) then
66348: LD_VAR 0 3
66352: PPUSH
66353: CALL_OW 314
66357: NOT
66358: IFFALSE 66407
// begin if not IsInUnit ( j ) then
66360: LD_VAR 0 3
66364: PPUSH
66365: CALL_OW 310
66369: NOT
66370: IFFALSE 66386
// ComEnterUnit ( j , selected ) ;
66372: LD_VAR 0 3
66376: PPUSH
66377: LD_VAR 0 7
66381: PPUSH
66382: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66386: LD_VAR 0 3
66390: PPUSH
66391: LD_INT 16
66393: PPUSH
66394: CALL_OW 183
// AddComExitBuilding ( j ) ;
66398: LD_VAR 0 3
66402: PPUSH
66403: CALL_OW 182
// end ;
66407: GO 66345
66409: POP
66410: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66411: LD_VAR 0 5
66415: PPUSH
66416: LD_INT 11
66418: PPUSH
66419: CALL_OW 325
66423: IFFALSE 66682
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66425: LD_ADDR_VAR 0 4
66429: PUSH
66430: LD_EXP 71
66434: PUSH
66435: LD_VAR 0 2
66439: ARRAY
66440: PPUSH
66441: LD_INT 25
66443: PUSH
66444: LD_INT 16
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PPUSH
66451: CALL_OW 72
66455: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66456: LD_VAR 0 4
66460: PUSH
66461: LD_INT 6
66463: GREATEREQUAL
66464: PUSH
66465: LD_VAR 0 5
66469: PPUSH
66470: LD_INT 2
66472: PPUSH
66473: CALL_OW 325
66477: NOT
66478: OR
66479: IFFALSE 66682
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66481: LD_ADDR_VAR 0 8
66485: PUSH
66486: LD_EXP 42
66490: PUSH
66491: LD_VAR 0 2
66495: ARRAY
66496: PPUSH
66497: LD_INT 2
66499: PUSH
66500: LD_INT 30
66502: PUSH
66503: LD_INT 4
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 30
66512: PUSH
66513: LD_INT 5
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: LIST
66524: PPUSH
66525: CALL_OW 72
66529: ST_TO_ADDR
// if barracks then
66530: LD_VAR 0 8
66534: IFFALSE 66682
// begin selected := 0 ;
66536: LD_ADDR_VAR 0 7
66540: PUSH
66541: LD_INT 0
66543: ST_TO_ADDR
// for j in barracks do
66544: LD_ADDR_VAR 0 3
66548: PUSH
66549: LD_VAR 0 8
66553: PUSH
66554: FOR_IN
66555: IFFALSE 66586
// begin if UnitsInside ( j ) < 6 then
66557: LD_VAR 0 3
66561: PPUSH
66562: CALL_OW 313
66566: PUSH
66567: LD_INT 6
66569: LESS
66570: IFFALSE 66584
// begin selected := j ;
66572: LD_ADDR_VAR 0 7
66576: PUSH
66577: LD_VAR 0 3
66581: ST_TO_ADDR
// break ;
66582: GO 66586
// end ; end ;
66584: GO 66554
66586: POP
66587: POP
// if selected then
66588: LD_VAR 0 7
66592: IFFALSE 66682
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66594: LD_ADDR_VAR 0 3
66598: PUSH
66599: LD_EXP 71
66603: PUSH
66604: LD_VAR 0 2
66608: ARRAY
66609: PPUSH
66610: LD_INT 25
66612: PUSH
66613: LD_INT 12
66615: PUSH
66616: EMPTY
66617: LIST
66618: LIST
66619: PPUSH
66620: CALL_OW 72
66624: PUSH
66625: FOR_IN
66626: IFFALSE 66680
// if not IsInUnit ( j ) and not HasTask ( j ) then
66628: LD_VAR 0 3
66632: PPUSH
66633: CALL_OW 310
66637: NOT
66638: PUSH
66639: LD_VAR 0 3
66643: PPUSH
66644: CALL_OW 314
66648: NOT
66649: AND
66650: IFFALSE 66678
// begin ComEnterUnit ( j , selected ) ;
66652: LD_VAR 0 3
66656: PPUSH
66657: LD_VAR 0 7
66661: PPUSH
66662: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66666: LD_VAR 0 3
66670: PPUSH
66671: LD_INT 15
66673: PPUSH
66674: CALL_OW 183
// end ;
66678: GO 66625
66680: POP
66681: POP
// end ; end ; end ; end ; end ;
66682: GO 66075
66684: POP
66685: POP
// end ;
66686: LD_VAR 0 1
66690: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66691: LD_INT 0
66693: PPUSH
66694: PPUSH
66695: PPUSH
66696: PPUSH
// if not mc_bases then
66697: LD_EXP 42
66701: NOT
66702: IFFALSE 66706
// exit ;
66704: GO 66884
// for i = 1 to mc_bases do
66706: LD_ADDR_VAR 0 2
66710: PUSH
66711: DOUBLE
66712: LD_INT 1
66714: DEC
66715: ST_TO_ADDR
66716: LD_EXP 42
66720: PUSH
66721: FOR_TO
66722: IFFALSE 66882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
66724: LD_ADDR_VAR 0 4
66728: PUSH
66729: LD_EXP 42
66733: PUSH
66734: LD_VAR 0 2
66738: ARRAY
66739: PPUSH
66740: LD_INT 25
66742: PUSH
66743: LD_INT 9
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PPUSH
66750: CALL_OW 72
66754: ST_TO_ADDR
// if not tmp then
66755: LD_VAR 0 4
66759: NOT
66760: IFFALSE 66764
// continue ;
66762: GO 66721
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
66764: LD_EXP 68
66768: PUSH
66769: LD_VAR 0 2
66773: ARRAY
66774: PPUSH
66775: LD_INT 29
66777: PPUSH
66778: CALL_OW 325
66782: NOT
66783: PUSH
66784: LD_EXP 68
66788: PUSH
66789: LD_VAR 0 2
66793: ARRAY
66794: PPUSH
66795: LD_INT 28
66797: PPUSH
66798: CALL_OW 325
66802: NOT
66803: AND
66804: IFFALSE 66808
// continue ;
66806: GO 66721
// for j in tmp do
66808: LD_ADDR_VAR 0 3
66812: PUSH
66813: LD_VAR 0 4
66817: PUSH
66818: FOR_IN
66819: IFFALSE 66878
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66821: LD_VAR 0 3
66825: PUSH
66826: LD_EXP 45
66830: PUSH
66831: LD_VAR 0 2
66835: ARRAY
66836: PUSH
66837: LD_INT 1
66839: ARRAY
66840: IN
66841: NOT
66842: PUSH
66843: LD_VAR 0 3
66847: PUSH
66848: LD_EXP 45
66852: PUSH
66853: LD_VAR 0 2
66857: ARRAY
66858: PUSH
66859: LD_INT 2
66861: ARRAY
66862: IN
66863: NOT
66864: AND
66865: IFFALSE 66876
// ComSpaceTimeShoot ( j ) ;
66867: LD_VAR 0 3
66871: PPUSH
66872: CALL 10747 0 1
66876: GO 66818
66878: POP
66879: POP
// end ;
66880: GO 66721
66882: POP
66883: POP
// end ;
66884: LD_VAR 0 1
66888: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
66889: LD_INT 0
66891: PPUSH
66892: PPUSH
66893: PPUSH
66894: PPUSH
66895: PPUSH
66896: PPUSH
66897: PPUSH
66898: PPUSH
66899: PPUSH
// if not mc_bases then
66900: LD_EXP 42
66904: NOT
66905: IFFALSE 66909
// exit ;
66907: GO 67531
// for i = 1 to mc_bases do
66909: LD_ADDR_VAR 0 2
66913: PUSH
66914: DOUBLE
66915: LD_INT 1
66917: DEC
66918: ST_TO_ADDR
66919: LD_EXP 42
66923: PUSH
66924: FOR_TO
66925: IFFALSE 67529
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
66927: LD_EXP 77
66931: PUSH
66932: LD_VAR 0 2
66936: ARRAY
66937: NOT
66938: PUSH
66939: LD_INT 38
66941: PPUSH
66942: LD_EXP 68
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: PPUSH
66953: CALL_OW 321
66957: PUSH
66958: LD_INT 2
66960: NONEQUAL
66961: OR
66962: IFFALSE 66966
// continue ;
66964: GO 66924
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
66966: LD_ADDR_VAR 0 8
66970: PUSH
66971: LD_EXP 42
66975: PUSH
66976: LD_VAR 0 2
66980: ARRAY
66981: PPUSH
66982: LD_INT 30
66984: PUSH
66985: LD_INT 34
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PPUSH
66992: CALL_OW 72
66996: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
66997: LD_ADDR_VAR 0 9
67001: PUSH
67002: LD_EXP 42
67006: PUSH
67007: LD_VAR 0 2
67011: ARRAY
67012: PPUSH
67013: LD_INT 25
67015: PUSH
67016: LD_INT 4
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PPUSH
67023: CALL_OW 72
67027: PPUSH
67028: LD_INT 0
67030: PPUSH
67031: CALL 43311 0 2
67035: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67036: LD_VAR 0 9
67040: NOT
67041: PUSH
67042: LD_VAR 0 8
67046: NOT
67047: OR
67048: PUSH
67049: LD_EXP 42
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: PPUSH
67060: LD_INT 124
67062: PPUSH
67063: CALL 43311 0 2
67067: OR
67068: IFFALSE 67072
// continue ;
67070: GO 66924
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67072: LD_EXP 78
67076: PUSH
67077: LD_VAR 0 2
67081: ARRAY
67082: PUSH
67083: LD_EXP 77
67087: PUSH
67088: LD_VAR 0 2
67092: ARRAY
67093: LESS
67094: PUSH
67095: LD_EXP 78
67099: PUSH
67100: LD_VAR 0 2
67104: ARRAY
67105: PUSH
67106: LD_VAR 0 8
67110: LESS
67111: AND
67112: IFFALSE 67527
// begin tmp := sci [ 1 ] ;
67114: LD_ADDR_VAR 0 7
67118: PUSH
67119: LD_VAR 0 9
67123: PUSH
67124: LD_INT 1
67126: ARRAY
67127: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67128: LD_VAR 0 7
67132: PPUSH
67133: LD_INT 124
67135: PPUSH
67136: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67140: LD_ADDR_VAR 0 3
67144: PUSH
67145: DOUBLE
67146: LD_EXP 77
67150: PUSH
67151: LD_VAR 0 2
67155: ARRAY
67156: INC
67157: ST_TO_ADDR
67158: LD_EXP 77
67162: PUSH
67163: LD_VAR 0 2
67167: ARRAY
67168: PUSH
67169: FOR_DOWNTO
67170: IFFALSE 67513
// begin if IsInUnit ( tmp ) then
67172: LD_VAR 0 7
67176: PPUSH
67177: CALL_OW 310
67181: IFFALSE 67192
// ComExitBuilding ( tmp ) ;
67183: LD_VAR 0 7
67187: PPUSH
67188: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67192: LD_INT 35
67194: PPUSH
67195: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67199: LD_VAR 0 7
67203: PPUSH
67204: CALL_OW 310
67208: NOT
67209: PUSH
67210: LD_VAR 0 7
67214: PPUSH
67215: CALL_OW 314
67219: NOT
67220: AND
67221: IFFALSE 67192
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67223: LD_ADDR_VAR 0 6
67227: PUSH
67228: LD_VAR 0 7
67232: PPUSH
67233: CALL_OW 250
67237: PUSH
67238: LD_VAR 0 7
67242: PPUSH
67243: CALL_OW 251
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67252: LD_INT 35
67254: PPUSH
67255: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67259: LD_ADDR_VAR 0 4
67263: PUSH
67264: LD_EXP 77
67268: PUSH
67269: LD_VAR 0 2
67273: ARRAY
67274: PUSH
67275: LD_VAR 0 3
67279: ARRAY
67280: PUSH
67281: LD_INT 1
67283: ARRAY
67284: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67285: LD_ADDR_VAR 0 5
67289: PUSH
67290: LD_EXP 77
67294: PUSH
67295: LD_VAR 0 2
67299: ARRAY
67300: PUSH
67301: LD_VAR 0 3
67305: ARRAY
67306: PUSH
67307: LD_INT 2
67309: ARRAY
67310: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67311: LD_VAR 0 7
67315: PPUSH
67316: LD_INT 10
67318: PPUSH
67319: CALL 17343 0 2
67323: PUSH
67324: LD_INT 4
67326: ARRAY
67327: IFFALSE 67365
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67329: LD_VAR 0 7
67333: PPUSH
67334: LD_VAR 0 6
67338: PUSH
67339: LD_INT 1
67341: ARRAY
67342: PPUSH
67343: LD_VAR 0 6
67347: PUSH
67348: LD_INT 2
67350: ARRAY
67351: PPUSH
67352: CALL_OW 111
// wait ( 0 0$10 ) ;
67356: LD_INT 350
67358: PPUSH
67359: CALL_OW 67
// end else
67363: GO 67391
// begin ComMoveXY ( tmp , x , y ) ;
67365: LD_VAR 0 7
67369: PPUSH
67370: LD_VAR 0 4
67374: PPUSH
67375: LD_VAR 0 5
67379: PPUSH
67380: CALL_OW 111
// wait ( 0 0$3 ) ;
67384: LD_INT 105
67386: PPUSH
67387: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67391: LD_VAR 0 7
67395: PPUSH
67396: LD_VAR 0 4
67400: PPUSH
67401: LD_VAR 0 5
67405: PPUSH
67406: CALL_OW 307
67410: IFFALSE 67252
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67412: LD_VAR 0 7
67416: PPUSH
67417: LD_VAR 0 4
67421: PPUSH
67422: LD_VAR 0 5
67426: PPUSH
67427: LD_VAR 0 8
67431: PUSH
67432: LD_VAR 0 3
67436: ARRAY
67437: PPUSH
67438: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67442: LD_INT 35
67444: PPUSH
67445: CALL_OW 67
// until not HasTask ( tmp ) ;
67449: LD_VAR 0 7
67453: PPUSH
67454: CALL_OW 314
67458: NOT
67459: IFFALSE 67442
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67461: LD_ADDR_EXP 78
67465: PUSH
67466: LD_EXP 78
67470: PPUSH
67471: LD_VAR 0 2
67475: PUSH
67476: LD_EXP 78
67480: PUSH
67481: LD_VAR 0 2
67485: ARRAY
67486: PUSH
67487: LD_INT 1
67489: PLUS
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PPUSH
67495: LD_VAR 0 8
67499: PUSH
67500: LD_VAR 0 3
67504: ARRAY
67505: PPUSH
67506: CALL 14750 0 3
67510: ST_TO_ADDR
// end ;
67511: GO 67169
67513: POP
67514: POP
// MC_Reset ( i , 124 ) ;
67515: LD_VAR 0 2
67519: PPUSH
67520: LD_INT 124
67522: PPUSH
67523: CALL 51086 0 2
// end ; end ;
67527: GO 66924
67529: POP
67530: POP
// end ;
67531: LD_VAR 0 1
67535: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67536: LD_INT 0
67538: PPUSH
67539: PPUSH
67540: PPUSH
// if not mc_bases then
67541: LD_EXP 42
67545: NOT
67546: IFFALSE 67550
// exit ;
67548: GO 68156
// for i = 1 to mc_bases do
67550: LD_ADDR_VAR 0 2
67554: PUSH
67555: DOUBLE
67556: LD_INT 1
67558: DEC
67559: ST_TO_ADDR
67560: LD_EXP 42
67564: PUSH
67565: FOR_TO
67566: IFFALSE 68154
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67568: LD_ADDR_VAR 0 3
67572: PUSH
67573: LD_EXP 42
67577: PUSH
67578: LD_VAR 0 2
67582: ARRAY
67583: PPUSH
67584: LD_INT 25
67586: PUSH
67587: LD_INT 4
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PPUSH
67594: CALL_OW 72
67598: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67599: LD_VAR 0 3
67603: NOT
67604: PUSH
67605: LD_EXP 79
67609: PUSH
67610: LD_VAR 0 2
67614: ARRAY
67615: NOT
67616: OR
67617: PUSH
67618: LD_EXP 42
67622: PUSH
67623: LD_VAR 0 2
67627: ARRAY
67628: PPUSH
67629: LD_INT 2
67631: PUSH
67632: LD_INT 30
67634: PUSH
67635: LD_INT 0
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 30
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: LIST
67656: PPUSH
67657: CALL_OW 72
67661: NOT
67662: OR
67663: IFFALSE 67713
// begin if mc_deposits_finder [ i ] then
67665: LD_EXP 80
67669: PUSH
67670: LD_VAR 0 2
67674: ARRAY
67675: IFFALSE 67711
// begin MC_Reset ( i , 125 ) ;
67677: LD_VAR 0 2
67681: PPUSH
67682: LD_INT 125
67684: PPUSH
67685: CALL 51086 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67689: LD_ADDR_EXP 80
67693: PUSH
67694: LD_EXP 80
67698: PPUSH
67699: LD_VAR 0 2
67703: PPUSH
67704: EMPTY
67705: PPUSH
67706: CALL_OW 1
67710: ST_TO_ADDR
// end ; continue ;
67711: GO 67565
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
67713: LD_EXP 79
67717: PUSH
67718: LD_VAR 0 2
67722: ARRAY
67723: PUSH
67724: LD_INT 1
67726: ARRAY
67727: PUSH
67728: LD_INT 3
67730: ARRAY
67731: PUSH
67732: LD_INT 1
67734: EQUAL
67735: PUSH
67736: LD_INT 20
67738: PPUSH
67739: LD_EXP 68
67743: PUSH
67744: LD_VAR 0 2
67748: ARRAY
67749: PPUSH
67750: CALL_OW 321
67754: PUSH
67755: LD_INT 2
67757: NONEQUAL
67758: AND
67759: IFFALSE 67809
// begin if mc_deposits_finder [ i ] then
67761: LD_EXP 80
67765: PUSH
67766: LD_VAR 0 2
67770: ARRAY
67771: IFFALSE 67807
// begin MC_Reset ( i , 125 ) ;
67773: LD_VAR 0 2
67777: PPUSH
67778: LD_INT 125
67780: PPUSH
67781: CALL 51086 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67785: LD_ADDR_EXP 80
67789: PUSH
67790: LD_EXP 80
67794: PPUSH
67795: LD_VAR 0 2
67799: PPUSH
67800: EMPTY
67801: PPUSH
67802: CALL_OW 1
67806: ST_TO_ADDR
// end ; continue ;
67807: GO 67565
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
67809: LD_EXP 79
67813: PUSH
67814: LD_VAR 0 2
67818: ARRAY
67819: PUSH
67820: LD_INT 1
67822: ARRAY
67823: PUSH
67824: LD_INT 1
67826: ARRAY
67827: PPUSH
67828: LD_EXP 79
67832: PUSH
67833: LD_VAR 0 2
67837: ARRAY
67838: PUSH
67839: LD_INT 1
67841: ARRAY
67842: PUSH
67843: LD_INT 2
67845: ARRAY
67846: PPUSH
67847: LD_EXP 68
67851: PUSH
67852: LD_VAR 0 2
67856: ARRAY
67857: PPUSH
67858: CALL_OW 440
67862: IFFALSE 67905
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
67864: LD_ADDR_EXP 79
67868: PUSH
67869: LD_EXP 79
67873: PPUSH
67874: LD_VAR 0 2
67878: PPUSH
67879: LD_EXP 79
67883: PUSH
67884: LD_VAR 0 2
67888: ARRAY
67889: PPUSH
67890: LD_INT 1
67892: PPUSH
67893: CALL_OW 3
67897: PPUSH
67898: CALL_OW 1
67902: ST_TO_ADDR
67903: GO 68152
// begin if not mc_deposits_finder [ i ] then
67905: LD_EXP 80
67909: PUSH
67910: LD_VAR 0 2
67914: ARRAY
67915: NOT
67916: IFFALSE 67968
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
67918: LD_ADDR_EXP 80
67922: PUSH
67923: LD_EXP 80
67927: PPUSH
67928: LD_VAR 0 2
67932: PPUSH
67933: LD_VAR 0 3
67937: PUSH
67938: LD_INT 1
67940: ARRAY
67941: PUSH
67942: EMPTY
67943: LIST
67944: PPUSH
67945: CALL_OW 1
67949: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
67950: LD_VAR 0 3
67954: PUSH
67955: LD_INT 1
67957: ARRAY
67958: PPUSH
67959: LD_INT 125
67961: PPUSH
67962: CALL_OW 109
// end else
67966: GO 68152
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
67968: LD_EXP 80
67972: PUSH
67973: LD_VAR 0 2
67977: ARRAY
67978: PUSH
67979: LD_INT 1
67981: ARRAY
67982: PPUSH
67983: CALL_OW 310
67987: IFFALSE 68010
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
67989: LD_EXP 80
67993: PUSH
67994: LD_VAR 0 2
67998: ARRAY
67999: PUSH
68000: LD_INT 1
68002: ARRAY
68003: PPUSH
68004: CALL_OW 122
68008: GO 68152
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68010: LD_EXP 80
68014: PUSH
68015: LD_VAR 0 2
68019: ARRAY
68020: PUSH
68021: LD_INT 1
68023: ARRAY
68024: PPUSH
68025: CALL_OW 314
68029: NOT
68030: PUSH
68031: LD_EXP 80
68035: PUSH
68036: LD_VAR 0 2
68040: ARRAY
68041: PUSH
68042: LD_INT 1
68044: ARRAY
68045: PPUSH
68046: LD_EXP 79
68050: PUSH
68051: LD_VAR 0 2
68055: ARRAY
68056: PUSH
68057: LD_INT 1
68059: ARRAY
68060: PUSH
68061: LD_INT 1
68063: ARRAY
68064: PPUSH
68065: LD_EXP 79
68069: PUSH
68070: LD_VAR 0 2
68074: ARRAY
68075: PUSH
68076: LD_INT 1
68078: ARRAY
68079: PUSH
68080: LD_INT 2
68082: ARRAY
68083: PPUSH
68084: CALL_OW 297
68088: PUSH
68089: LD_INT 6
68091: GREATER
68092: AND
68093: IFFALSE 68152
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68095: LD_EXP 80
68099: PUSH
68100: LD_VAR 0 2
68104: ARRAY
68105: PUSH
68106: LD_INT 1
68108: ARRAY
68109: PPUSH
68110: LD_EXP 79
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: PUSH
68121: LD_INT 1
68123: ARRAY
68124: PUSH
68125: LD_INT 1
68127: ARRAY
68128: PPUSH
68129: LD_EXP 79
68133: PUSH
68134: LD_VAR 0 2
68138: ARRAY
68139: PUSH
68140: LD_INT 1
68142: ARRAY
68143: PUSH
68144: LD_INT 2
68146: ARRAY
68147: PPUSH
68148: CALL_OW 111
// end ; end ; end ;
68152: GO 67565
68154: POP
68155: POP
// end ;
68156: LD_VAR 0 1
68160: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68161: LD_INT 0
68163: PPUSH
68164: PPUSH
68165: PPUSH
68166: PPUSH
68167: PPUSH
68168: PPUSH
68169: PPUSH
68170: PPUSH
68171: PPUSH
68172: PPUSH
68173: PPUSH
// if not mc_bases then
68174: LD_EXP 42
68178: NOT
68179: IFFALSE 68183
// exit ;
68181: GO 69123
// for i = 1 to mc_bases do
68183: LD_ADDR_VAR 0 2
68187: PUSH
68188: DOUBLE
68189: LD_INT 1
68191: DEC
68192: ST_TO_ADDR
68193: LD_EXP 42
68197: PUSH
68198: FOR_TO
68199: IFFALSE 69121
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68201: LD_EXP 42
68205: PUSH
68206: LD_VAR 0 2
68210: ARRAY
68211: NOT
68212: PUSH
68213: LD_EXP 65
68217: PUSH
68218: LD_VAR 0 2
68222: ARRAY
68223: OR
68224: IFFALSE 68228
// continue ;
68226: GO 68198
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68228: LD_ADDR_VAR 0 7
68232: PUSH
68233: LD_EXP 42
68237: PUSH
68238: LD_VAR 0 2
68242: ARRAY
68243: PUSH
68244: LD_INT 1
68246: ARRAY
68247: PPUSH
68248: CALL_OW 248
68252: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68253: LD_VAR 0 7
68257: PUSH
68258: LD_INT 3
68260: EQUAL
68261: PUSH
68262: LD_EXP 61
68266: PUSH
68267: LD_VAR 0 2
68271: ARRAY
68272: PUSH
68273: LD_EXP 64
68277: PUSH
68278: LD_VAR 0 2
68282: ARRAY
68283: UNION
68284: PPUSH
68285: LD_INT 33
68287: PUSH
68288: LD_INT 2
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PPUSH
68295: CALL_OW 72
68299: NOT
68300: OR
68301: IFFALSE 68305
// continue ;
68303: GO 68198
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68305: LD_ADDR_VAR 0 9
68309: PUSH
68310: LD_EXP 42
68314: PUSH
68315: LD_VAR 0 2
68319: ARRAY
68320: PPUSH
68321: LD_INT 30
68323: PUSH
68324: LD_INT 36
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PPUSH
68331: CALL_OW 72
68335: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68336: LD_ADDR_VAR 0 10
68340: PUSH
68341: LD_EXP 61
68345: PUSH
68346: LD_VAR 0 2
68350: ARRAY
68351: PPUSH
68352: LD_INT 34
68354: PUSH
68355: LD_INT 31
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PPUSH
68362: CALL_OW 72
68366: ST_TO_ADDR
// if not cts and not mcts then
68367: LD_VAR 0 9
68371: NOT
68372: PUSH
68373: LD_VAR 0 10
68377: NOT
68378: AND
68379: IFFALSE 68383
// continue ;
68381: GO 68198
// x := cts ;
68383: LD_ADDR_VAR 0 11
68387: PUSH
68388: LD_VAR 0 9
68392: ST_TO_ADDR
// if not x then
68393: LD_VAR 0 11
68397: NOT
68398: IFFALSE 68410
// x := mcts ;
68400: LD_ADDR_VAR 0 11
68404: PUSH
68405: LD_VAR 0 10
68409: ST_TO_ADDR
// if not x then
68410: LD_VAR 0 11
68414: NOT
68415: IFFALSE 68419
// continue ;
68417: GO 68198
// if mc_remote_driver [ i ] then
68419: LD_EXP 82
68423: PUSH
68424: LD_VAR 0 2
68428: ARRAY
68429: IFFALSE 68816
// for j in mc_remote_driver [ i ] do
68431: LD_ADDR_VAR 0 3
68435: PUSH
68436: LD_EXP 82
68440: PUSH
68441: LD_VAR 0 2
68445: ARRAY
68446: PUSH
68447: FOR_IN
68448: IFFALSE 68814
// begin if GetClass ( j ) <> 3 then
68450: LD_VAR 0 3
68454: PPUSH
68455: CALL_OW 257
68459: PUSH
68460: LD_INT 3
68462: NONEQUAL
68463: IFFALSE 68516
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68465: LD_ADDR_EXP 82
68469: PUSH
68470: LD_EXP 82
68474: PPUSH
68475: LD_VAR 0 2
68479: PPUSH
68480: LD_EXP 82
68484: PUSH
68485: LD_VAR 0 2
68489: ARRAY
68490: PUSH
68491: LD_VAR 0 3
68495: DIFF
68496: PPUSH
68497: CALL_OW 1
68501: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68502: LD_VAR 0 3
68506: PPUSH
68507: LD_INT 0
68509: PPUSH
68510: CALL_OW 109
// continue ;
68514: GO 68447
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68516: LD_EXP 61
68520: PUSH
68521: LD_VAR 0 2
68525: ARRAY
68526: PPUSH
68527: LD_INT 34
68529: PUSH
68530: LD_INT 31
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 58
68539: PUSH
68540: EMPTY
68541: LIST
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PPUSH
68547: CALL_OW 72
68551: PUSH
68552: LD_VAR 0 3
68556: PPUSH
68557: CALL 43399 0 1
68561: NOT
68562: AND
68563: IFFALSE 68634
// begin if IsInUnit ( j ) then
68565: LD_VAR 0 3
68569: PPUSH
68570: CALL_OW 310
68574: IFFALSE 68585
// ComExitBuilding ( j ) ;
68576: LD_VAR 0 3
68580: PPUSH
68581: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68585: LD_VAR 0 3
68589: PPUSH
68590: LD_EXP 61
68594: PUSH
68595: LD_VAR 0 2
68599: ARRAY
68600: PPUSH
68601: LD_INT 34
68603: PUSH
68604: LD_INT 31
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 58
68613: PUSH
68614: EMPTY
68615: LIST
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PPUSH
68621: CALL_OW 72
68625: PUSH
68626: LD_INT 1
68628: ARRAY
68629: PPUSH
68630: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68634: LD_VAR 0 3
68638: PPUSH
68639: CALL_OW 310
68643: NOT
68644: PUSH
68645: LD_VAR 0 3
68649: PPUSH
68650: CALL_OW 310
68654: PPUSH
68655: CALL_OW 266
68659: PUSH
68660: LD_INT 36
68662: NONEQUAL
68663: PUSH
68664: LD_VAR 0 3
68668: PPUSH
68669: CALL 43399 0 1
68673: NOT
68674: AND
68675: OR
68676: IFFALSE 68812
// begin if IsInUnit ( j ) then
68678: LD_VAR 0 3
68682: PPUSH
68683: CALL_OW 310
68687: IFFALSE 68698
// ComExitBuilding ( j ) ;
68689: LD_VAR 0 3
68693: PPUSH
68694: CALL_OW 122
// ct := 0 ;
68698: LD_ADDR_VAR 0 8
68702: PUSH
68703: LD_INT 0
68705: ST_TO_ADDR
// for k in x do
68706: LD_ADDR_VAR 0 4
68710: PUSH
68711: LD_VAR 0 11
68715: PUSH
68716: FOR_IN
68717: IFFALSE 68790
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
68719: LD_VAR 0 4
68723: PPUSH
68724: CALL_OW 264
68728: PUSH
68729: LD_INT 31
68731: EQUAL
68732: PUSH
68733: LD_VAR 0 4
68737: PPUSH
68738: CALL_OW 311
68742: NOT
68743: AND
68744: PUSH
68745: LD_VAR 0 4
68749: PPUSH
68750: CALL_OW 266
68754: PUSH
68755: LD_INT 36
68757: EQUAL
68758: PUSH
68759: LD_VAR 0 4
68763: PPUSH
68764: CALL_OW 313
68768: PUSH
68769: LD_INT 3
68771: LESS
68772: AND
68773: OR
68774: IFFALSE 68788
// begin ct := k ;
68776: LD_ADDR_VAR 0 8
68780: PUSH
68781: LD_VAR 0 4
68785: ST_TO_ADDR
// break ;
68786: GO 68790
// end ;
68788: GO 68716
68790: POP
68791: POP
// if ct then
68792: LD_VAR 0 8
68796: IFFALSE 68812
// ComEnterUnit ( j , ct ) ;
68798: LD_VAR 0 3
68802: PPUSH
68803: LD_VAR 0 8
68807: PPUSH
68808: CALL_OW 120
// end ; end ;
68812: GO 68447
68814: POP
68815: POP
// places := 0 ;
68816: LD_ADDR_VAR 0 5
68820: PUSH
68821: LD_INT 0
68823: ST_TO_ADDR
// for j = 1 to x do
68824: LD_ADDR_VAR 0 3
68828: PUSH
68829: DOUBLE
68830: LD_INT 1
68832: DEC
68833: ST_TO_ADDR
68834: LD_VAR 0 11
68838: PUSH
68839: FOR_TO
68840: IFFALSE 68916
// if GetWeapon ( x [ j ] ) = ar_control_tower then
68842: LD_VAR 0 11
68846: PUSH
68847: LD_VAR 0 3
68851: ARRAY
68852: PPUSH
68853: CALL_OW 264
68857: PUSH
68858: LD_INT 31
68860: EQUAL
68861: IFFALSE 68879
// places := places + 1 else
68863: LD_ADDR_VAR 0 5
68867: PUSH
68868: LD_VAR 0 5
68872: PUSH
68873: LD_INT 1
68875: PLUS
68876: ST_TO_ADDR
68877: GO 68914
// if GetBType ( x [ j ] ) = b_control_tower then
68879: LD_VAR 0 11
68883: PUSH
68884: LD_VAR 0 3
68888: ARRAY
68889: PPUSH
68890: CALL_OW 266
68894: PUSH
68895: LD_INT 36
68897: EQUAL
68898: IFFALSE 68914
// places := places + 3 ;
68900: LD_ADDR_VAR 0 5
68904: PUSH
68905: LD_VAR 0 5
68909: PUSH
68910: LD_INT 3
68912: PLUS
68913: ST_TO_ADDR
68914: GO 68839
68916: POP
68917: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
68918: LD_VAR 0 5
68922: PUSH
68923: LD_INT 0
68925: EQUAL
68926: PUSH
68927: LD_VAR 0 5
68931: PUSH
68932: LD_EXP 82
68936: PUSH
68937: LD_VAR 0 2
68941: ARRAY
68942: LESSEQUAL
68943: OR
68944: IFFALSE 68948
// continue ;
68946: GO 68198
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
68948: LD_ADDR_VAR 0 6
68952: PUSH
68953: LD_EXP 42
68957: PUSH
68958: LD_VAR 0 2
68962: ARRAY
68963: PPUSH
68964: LD_INT 25
68966: PUSH
68967: LD_INT 3
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PPUSH
68974: CALL_OW 72
68978: PUSH
68979: LD_EXP 82
68983: PUSH
68984: LD_VAR 0 2
68988: ARRAY
68989: DIFF
68990: PPUSH
68991: LD_INT 3
68993: PPUSH
68994: CALL 44299 0 2
68998: ST_TO_ADDR
// for j in tmp do
68999: LD_ADDR_VAR 0 3
69003: PUSH
69004: LD_VAR 0 6
69008: PUSH
69009: FOR_IN
69010: IFFALSE 69045
// if GetTag ( j ) > 0 then
69012: LD_VAR 0 3
69016: PPUSH
69017: CALL_OW 110
69021: PUSH
69022: LD_INT 0
69024: GREATER
69025: IFFALSE 69043
// tmp := tmp diff j ;
69027: LD_ADDR_VAR 0 6
69031: PUSH
69032: LD_VAR 0 6
69036: PUSH
69037: LD_VAR 0 3
69041: DIFF
69042: ST_TO_ADDR
69043: GO 69009
69045: POP
69046: POP
// if not tmp then
69047: LD_VAR 0 6
69051: NOT
69052: IFFALSE 69056
// continue ;
69054: GO 68198
// if places then
69056: LD_VAR 0 5
69060: IFFALSE 69119
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69062: LD_ADDR_EXP 82
69066: PUSH
69067: LD_EXP 82
69071: PPUSH
69072: LD_VAR 0 2
69076: PPUSH
69077: LD_EXP 82
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: PUSH
69088: LD_VAR 0 6
69092: PUSH
69093: LD_INT 1
69095: ARRAY
69096: UNION
69097: PPUSH
69098: CALL_OW 1
69102: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69103: LD_VAR 0 6
69107: PUSH
69108: LD_INT 1
69110: ARRAY
69111: PPUSH
69112: LD_INT 126
69114: PPUSH
69115: CALL_OW 109
// end ; end ;
69119: GO 68198
69121: POP
69122: POP
// end ;
69123: LD_VAR 0 1
69127: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69128: LD_INT 0
69130: PPUSH
69131: PPUSH
69132: PPUSH
69133: PPUSH
69134: PPUSH
69135: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69136: LD_VAR 0 1
69140: NOT
69141: PUSH
69142: LD_VAR 0 2
69146: NOT
69147: OR
69148: PUSH
69149: LD_VAR 0 3
69153: NOT
69154: OR
69155: PUSH
69156: LD_VAR 0 4
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 2
69166: PUSH
69167: LD_INT 3
69169: PUSH
69170: LD_INT 4
69172: PUSH
69173: LD_INT 5
69175: PUSH
69176: LD_INT 8
69178: PUSH
69179: LD_INT 9
69181: PUSH
69182: LD_INT 15
69184: PUSH
69185: LD_INT 16
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: IN
69199: NOT
69200: OR
69201: IFFALSE 69205
// exit ;
69203: GO 70105
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69205: LD_ADDR_VAR 0 2
69209: PUSH
69210: LD_VAR 0 2
69214: PPUSH
69215: LD_INT 21
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 24
69227: PUSH
69228: LD_INT 250
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PPUSH
69239: CALL_OW 72
69243: ST_TO_ADDR
// case class of 1 , 15 :
69244: LD_VAR 0 4
69248: PUSH
69249: LD_INT 1
69251: DOUBLE
69252: EQUAL
69253: IFTRUE 69263
69255: LD_INT 15
69257: DOUBLE
69258: EQUAL
69259: IFTRUE 69263
69261: GO 69348
69263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69264: LD_ADDR_VAR 0 8
69268: PUSH
69269: LD_VAR 0 2
69273: PPUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 30
69279: PUSH
69280: LD_INT 32
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 30
69289: PUSH
69290: LD_INT 31
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: LIST
69301: PPUSH
69302: CALL_OW 72
69306: PUSH
69307: LD_VAR 0 2
69311: PPUSH
69312: LD_INT 2
69314: PUSH
69315: LD_INT 30
69317: PUSH
69318: LD_INT 4
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 30
69327: PUSH
69328: LD_INT 5
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: LIST
69339: PPUSH
69340: CALL_OW 72
69344: ADD
69345: ST_TO_ADDR
69346: GO 69594
69348: LD_INT 2
69350: DOUBLE
69351: EQUAL
69352: IFTRUE 69362
69354: LD_INT 16
69356: DOUBLE
69357: EQUAL
69358: IFTRUE 69362
69360: GO 69408
69362: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69363: LD_ADDR_VAR 0 8
69367: PUSH
69368: LD_VAR 0 2
69372: PPUSH
69373: LD_INT 2
69375: PUSH
69376: LD_INT 30
69378: PUSH
69379: LD_INT 0
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: LD_INT 30
69388: PUSH
69389: LD_INT 1
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: LIST
69400: PPUSH
69401: CALL_OW 72
69405: ST_TO_ADDR
69406: GO 69594
69408: LD_INT 3
69410: DOUBLE
69411: EQUAL
69412: IFTRUE 69416
69414: GO 69462
69416: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69417: LD_ADDR_VAR 0 8
69421: PUSH
69422: LD_VAR 0 2
69426: PPUSH
69427: LD_INT 2
69429: PUSH
69430: LD_INT 30
69432: PUSH
69433: LD_INT 2
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 30
69442: PUSH
69443: LD_INT 3
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: LIST
69454: PPUSH
69455: CALL_OW 72
69459: ST_TO_ADDR
69460: GO 69594
69462: LD_INT 4
69464: DOUBLE
69465: EQUAL
69466: IFTRUE 69470
69468: GO 69527
69470: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69471: LD_ADDR_VAR 0 8
69475: PUSH
69476: LD_VAR 0 2
69480: PPUSH
69481: LD_INT 2
69483: PUSH
69484: LD_INT 30
69486: PUSH
69487: LD_INT 6
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 30
69496: PUSH
69497: LD_INT 7
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 30
69506: PUSH
69507: LD_INT 8
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: PPUSH
69520: CALL_OW 72
69524: ST_TO_ADDR
69525: GO 69594
69527: LD_INT 5
69529: DOUBLE
69530: EQUAL
69531: IFTRUE 69547
69533: LD_INT 8
69535: DOUBLE
69536: EQUAL
69537: IFTRUE 69547
69539: LD_INT 9
69541: DOUBLE
69542: EQUAL
69543: IFTRUE 69547
69545: GO 69593
69547: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69548: LD_ADDR_VAR 0 8
69552: PUSH
69553: LD_VAR 0 2
69557: PPUSH
69558: LD_INT 2
69560: PUSH
69561: LD_INT 30
69563: PUSH
69564: LD_INT 4
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 30
69573: PUSH
69574: LD_INT 5
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: LIST
69585: PPUSH
69586: CALL_OW 72
69590: ST_TO_ADDR
69591: GO 69594
69593: POP
// if not tmp then
69594: LD_VAR 0 8
69598: NOT
69599: IFFALSE 69603
// exit ;
69601: GO 70105
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69603: LD_VAR 0 4
69607: PUSH
69608: LD_INT 1
69610: PUSH
69611: LD_INT 15
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: IN
69618: PUSH
69619: LD_EXP 51
69623: PUSH
69624: LD_VAR 0 1
69628: ARRAY
69629: AND
69630: IFFALSE 69786
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69632: LD_ADDR_VAR 0 9
69636: PUSH
69637: LD_EXP 51
69641: PUSH
69642: LD_VAR 0 1
69646: ARRAY
69647: PUSH
69648: LD_INT 1
69650: ARRAY
69651: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69652: LD_VAR 0 9
69656: PUSH
69657: LD_EXP 52
69661: PUSH
69662: LD_VAR 0 1
69666: ARRAY
69667: IN
69668: NOT
69669: IFFALSE 69784
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69671: LD_ADDR_EXP 52
69675: PUSH
69676: LD_EXP 52
69680: PPUSH
69681: LD_VAR 0 1
69685: PUSH
69686: LD_EXP 52
69690: PUSH
69691: LD_VAR 0 1
69695: ARRAY
69696: PUSH
69697: LD_INT 1
69699: PLUS
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PPUSH
69705: LD_VAR 0 9
69709: PPUSH
69710: CALL 14750 0 3
69714: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
69715: LD_ADDR_EXP 51
69719: PUSH
69720: LD_EXP 51
69724: PPUSH
69725: LD_VAR 0 1
69729: PPUSH
69730: LD_EXP 51
69734: PUSH
69735: LD_VAR 0 1
69739: ARRAY
69740: PUSH
69741: LD_VAR 0 9
69745: DIFF
69746: PPUSH
69747: CALL_OW 1
69751: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
69752: LD_VAR 0 3
69756: PPUSH
69757: LD_EXP 52
69761: PUSH
69762: LD_VAR 0 1
69766: ARRAY
69767: PUSH
69768: LD_EXP 52
69772: PUSH
69773: LD_VAR 0 1
69777: ARRAY
69778: ARRAY
69779: PPUSH
69780: CALL_OW 120
// end ; exit ;
69784: GO 70105
// end ; if tmp > 1 then
69786: LD_VAR 0 8
69790: PUSH
69791: LD_INT 1
69793: GREATER
69794: IFFALSE 69898
// for i = 2 to tmp do
69796: LD_ADDR_VAR 0 6
69800: PUSH
69801: DOUBLE
69802: LD_INT 2
69804: DEC
69805: ST_TO_ADDR
69806: LD_VAR 0 8
69810: PUSH
69811: FOR_TO
69812: IFFALSE 69896
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
69814: LD_VAR 0 8
69818: PUSH
69819: LD_VAR 0 6
69823: ARRAY
69824: PPUSH
69825: CALL_OW 461
69829: PUSH
69830: LD_INT 6
69832: EQUAL
69833: IFFALSE 69894
// begin x := tmp [ i ] ;
69835: LD_ADDR_VAR 0 9
69839: PUSH
69840: LD_VAR 0 8
69844: PUSH
69845: LD_VAR 0 6
69849: ARRAY
69850: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
69851: LD_ADDR_VAR 0 8
69855: PUSH
69856: LD_VAR 0 8
69860: PPUSH
69861: LD_VAR 0 6
69865: PPUSH
69866: CALL_OW 3
69870: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
69871: LD_ADDR_VAR 0 8
69875: PUSH
69876: LD_VAR 0 8
69880: PPUSH
69881: LD_INT 1
69883: PPUSH
69884: LD_VAR 0 9
69888: PPUSH
69889: CALL_OW 2
69893: ST_TO_ADDR
// end ;
69894: GO 69811
69896: POP
69897: POP
// for i in tmp do
69898: LD_ADDR_VAR 0 6
69902: PUSH
69903: LD_VAR 0 8
69907: PUSH
69908: FOR_IN
69909: IFFALSE 69978
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
69911: LD_VAR 0 6
69915: PPUSH
69916: CALL_OW 313
69920: PUSH
69921: LD_INT 6
69923: LESS
69924: PUSH
69925: LD_VAR 0 6
69929: PPUSH
69930: CALL_OW 266
69934: PUSH
69935: LD_INT 31
69937: PUSH
69938: LD_INT 32
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: IN
69945: NOT
69946: AND
69947: PUSH
69948: LD_VAR 0 6
69952: PPUSH
69953: CALL_OW 313
69957: PUSH
69958: LD_INT 0
69960: EQUAL
69961: OR
69962: IFFALSE 69976
// begin j := i ;
69964: LD_ADDR_VAR 0 7
69968: PUSH
69969: LD_VAR 0 6
69973: ST_TO_ADDR
// break ;
69974: GO 69978
// end ; end ;
69976: GO 69908
69978: POP
69979: POP
// if j then
69980: LD_VAR 0 7
69984: IFFALSE 70002
// ComEnterUnit ( unit , j ) else
69986: LD_VAR 0 3
69990: PPUSH
69991: LD_VAR 0 7
69995: PPUSH
69996: CALL_OW 120
70000: GO 70105
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70002: LD_ADDR_VAR 0 10
70006: PUSH
70007: LD_VAR 0 2
70011: PPUSH
70012: LD_INT 2
70014: PUSH
70015: LD_INT 30
70017: PUSH
70018: LD_INT 0
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 30
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: LIST
70039: PPUSH
70040: CALL_OW 72
70044: ST_TO_ADDR
// if depot then
70045: LD_VAR 0 10
70049: IFFALSE 70105
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70051: LD_ADDR_VAR 0 10
70055: PUSH
70056: LD_VAR 0 10
70060: PPUSH
70061: LD_VAR 0 3
70065: PPUSH
70066: CALL_OW 74
70070: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70071: LD_VAR 0 3
70075: PPUSH
70076: LD_VAR 0 10
70080: PPUSH
70081: CALL_OW 296
70085: PUSH
70086: LD_INT 10
70088: GREATER
70089: IFFALSE 70105
// ComStandNearbyBuilding ( unit , depot ) ;
70091: LD_VAR 0 3
70095: PPUSH
70096: LD_VAR 0 10
70100: PPUSH
70101: CALL 11364 0 2
// end ; end ; end ;
70105: LD_VAR 0 5
70109: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70110: LD_INT 0
70112: PPUSH
70113: PPUSH
70114: PPUSH
70115: PPUSH
// if not mc_bases then
70116: LD_EXP 42
70120: NOT
70121: IFFALSE 70125
// exit ;
70123: GO 70364
// for i = 1 to mc_bases do
70125: LD_ADDR_VAR 0 2
70129: PUSH
70130: DOUBLE
70131: LD_INT 1
70133: DEC
70134: ST_TO_ADDR
70135: LD_EXP 42
70139: PUSH
70140: FOR_TO
70141: IFFALSE 70362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70143: LD_ADDR_VAR 0 4
70147: PUSH
70148: LD_EXP 42
70152: PUSH
70153: LD_VAR 0 2
70157: ARRAY
70158: PPUSH
70159: LD_INT 21
70161: PUSH
70162: LD_INT 1
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PPUSH
70169: CALL_OW 72
70173: PUSH
70174: LD_EXP 71
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: UNION
70185: ST_TO_ADDR
// if not tmp then
70186: LD_VAR 0 4
70190: NOT
70191: IFFALSE 70195
// continue ;
70193: GO 70140
// for j in tmp do
70195: LD_ADDR_VAR 0 3
70199: PUSH
70200: LD_VAR 0 4
70204: PUSH
70205: FOR_IN
70206: IFFALSE 70358
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70208: LD_VAR 0 3
70212: PPUSH
70213: CALL_OW 110
70217: NOT
70218: PUSH
70219: LD_VAR 0 3
70223: PPUSH
70224: CALL_OW 314
70228: NOT
70229: AND
70230: PUSH
70231: LD_VAR 0 3
70235: PPUSH
70236: CALL_OW 311
70240: NOT
70241: AND
70242: PUSH
70243: LD_VAR 0 3
70247: PPUSH
70248: CALL_OW 310
70252: NOT
70253: AND
70254: PUSH
70255: LD_VAR 0 3
70259: PUSH
70260: LD_EXP 45
70264: PUSH
70265: LD_VAR 0 2
70269: ARRAY
70270: PUSH
70271: LD_INT 1
70273: ARRAY
70274: IN
70275: NOT
70276: AND
70277: PUSH
70278: LD_VAR 0 3
70282: PUSH
70283: LD_EXP 45
70287: PUSH
70288: LD_VAR 0 2
70292: ARRAY
70293: PUSH
70294: LD_INT 2
70296: ARRAY
70297: IN
70298: NOT
70299: AND
70300: PUSH
70301: LD_VAR 0 3
70305: PUSH
70306: LD_EXP 54
70310: PUSH
70311: LD_VAR 0 2
70315: ARRAY
70316: IN
70317: NOT
70318: AND
70319: IFFALSE 70356
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70321: LD_VAR 0 2
70325: PPUSH
70326: LD_EXP 42
70330: PUSH
70331: LD_VAR 0 2
70335: ARRAY
70336: PPUSH
70337: LD_VAR 0 3
70341: PPUSH
70342: LD_VAR 0 3
70346: PPUSH
70347: CALL_OW 257
70351: PPUSH
70352: CALL 69128 0 4
// end ;
70356: GO 70205
70358: POP
70359: POP
// end ;
70360: GO 70140
70362: POP
70363: POP
// end ;
70364: LD_VAR 0 1
70368: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70369: LD_INT 0
70371: PPUSH
70372: PPUSH
70373: PPUSH
70374: PPUSH
70375: PPUSH
70376: PPUSH
// if not mc_bases [ base ] then
70377: LD_EXP 42
70381: PUSH
70382: LD_VAR 0 1
70386: ARRAY
70387: NOT
70388: IFFALSE 70392
// exit ;
70390: GO 70574
// tmp := [ ] ;
70392: LD_ADDR_VAR 0 6
70396: PUSH
70397: EMPTY
70398: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70399: LD_ADDR_VAR 0 7
70403: PUSH
70404: LD_VAR 0 3
70408: PPUSH
70409: LD_INT 0
70411: PPUSH
70412: CALL_OW 517
70416: ST_TO_ADDR
// if not list then
70417: LD_VAR 0 7
70421: NOT
70422: IFFALSE 70426
// exit ;
70424: GO 70574
// for i = 1 to amount do
70426: LD_ADDR_VAR 0 5
70430: PUSH
70431: DOUBLE
70432: LD_INT 1
70434: DEC
70435: ST_TO_ADDR
70436: LD_VAR 0 2
70440: PUSH
70441: FOR_TO
70442: IFFALSE 70522
// begin x := rand ( 1 , list [ 1 ] ) ;
70444: LD_ADDR_VAR 0 8
70448: PUSH
70449: LD_INT 1
70451: PPUSH
70452: LD_VAR 0 7
70456: PUSH
70457: LD_INT 1
70459: ARRAY
70460: PPUSH
70461: CALL_OW 12
70465: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70466: LD_ADDR_VAR 0 6
70470: PUSH
70471: LD_VAR 0 6
70475: PPUSH
70476: LD_VAR 0 5
70480: PPUSH
70481: LD_VAR 0 7
70485: PUSH
70486: LD_INT 1
70488: ARRAY
70489: PUSH
70490: LD_VAR 0 8
70494: ARRAY
70495: PUSH
70496: LD_VAR 0 7
70500: PUSH
70501: LD_INT 2
70503: ARRAY
70504: PUSH
70505: LD_VAR 0 8
70509: ARRAY
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PPUSH
70515: CALL_OW 1
70519: ST_TO_ADDR
// end ;
70520: GO 70441
70522: POP
70523: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70524: LD_ADDR_EXP 55
70528: PUSH
70529: LD_EXP 55
70533: PPUSH
70534: LD_VAR 0 1
70538: PPUSH
70539: LD_VAR 0 6
70543: PPUSH
70544: CALL_OW 1
70548: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70549: LD_ADDR_EXP 57
70553: PUSH
70554: LD_EXP 57
70558: PPUSH
70559: LD_VAR 0 1
70563: PPUSH
70564: LD_VAR 0 3
70568: PPUSH
70569: CALL_OW 1
70573: ST_TO_ADDR
// end ;
70574: LD_VAR 0 4
70578: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70579: LD_INT 0
70581: PPUSH
// if not mc_bases [ base ] then
70582: LD_EXP 42
70586: PUSH
70587: LD_VAR 0 1
70591: ARRAY
70592: NOT
70593: IFFALSE 70597
// exit ;
70595: GO 70622
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70597: LD_ADDR_EXP 47
70601: PUSH
70602: LD_EXP 47
70606: PPUSH
70607: LD_VAR 0 1
70611: PPUSH
70612: LD_VAR 0 2
70616: PPUSH
70617: CALL_OW 1
70621: ST_TO_ADDR
// end ;
70622: LD_VAR 0 3
70626: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70627: LD_INT 0
70629: PPUSH
// if not mc_bases [ base ] then
70630: LD_EXP 42
70634: PUSH
70635: LD_VAR 0 1
70639: ARRAY
70640: NOT
70641: IFFALSE 70645
// exit ;
70643: GO 70682
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70645: LD_ADDR_EXP 47
70649: PUSH
70650: LD_EXP 47
70654: PPUSH
70655: LD_VAR 0 1
70659: PPUSH
70660: LD_EXP 47
70664: PUSH
70665: LD_VAR 0 1
70669: ARRAY
70670: PUSH
70671: LD_VAR 0 2
70675: UNION
70676: PPUSH
70677: CALL_OW 1
70681: ST_TO_ADDR
// end ;
70682: LD_VAR 0 3
70686: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70687: LD_INT 0
70689: PPUSH
// if not mc_bases [ base ] then
70690: LD_EXP 42
70694: PUSH
70695: LD_VAR 0 1
70699: ARRAY
70700: NOT
70701: IFFALSE 70705
// exit ;
70703: GO 70730
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70705: LD_ADDR_EXP 63
70709: PUSH
70710: LD_EXP 63
70714: PPUSH
70715: LD_VAR 0 1
70719: PPUSH
70720: LD_VAR 0 2
70724: PPUSH
70725: CALL_OW 1
70729: ST_TO_ADDR
// end ;
70730: LD_VAR 0 3
70734: RET
// export function MC_InsertProduceList ( base , components ) ; begin
70735: LD_INT 0
70737: PPUSH
// if not mc_bases [ base ] then
70738: LD_EXP 42
70742: PUSH
70743: LD_VAR 0 1
70747: ARRAY
70748: NOT
70749: IFFALSE 70753
// exit ;
70751: GO 70790
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
70753: LD_ADDR_EXP 63
70757: PUSH
70758: LD_EXP 63
70762: PPUSH
70763: LD_VAR 0 1
70767: PPUSH
70768: LD_EXP 63
70772: PUSH
70773: LD_VAR 0 1
70777: ARRAY
70778: PUSH
70779: LD_VAR 0 2
70783: ADD
70784: PPUSH
70785: CALL_OW 1
70789: ST_TO_ADDR
// end ;
70790: LD_VAR 0 3
70794: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
70795: LD_INT 0
70797: PPUSH
// if not mc_bases [ base ] then
70798: LD_EXP 42
70802: PUSH
70803: LD_VAR 0 1
70807: ARRAY
70808: NOT
70809: IFFALSE 70813
// exit ;
70811: GO 70867
// mc_defender := Replace ( mc_defender , base , deflist ) ;
70813: LD_ADDR_EXP 64
70817: PUSH
70818: LD_EXP 64
70822: PPUSH
70823: LD_VAR 0 1
70827: PPUSH
70828: LD_VAR 0 2
70832: PPUSH
70833: CALL_OW 1
70837: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
70838: LD_ADDR_EXP 53
70842: PUSH
70843: LD_EXP 53
70847: PPUSH
70848: LD_VAR 0 1
70852: PPUSH
70853: LD_VAR 0 2
70857: PUSH
70858: LD_INT 0
70860: PLUS
70861: PPUSH
70862: CALL_OW 1
70866: ST_TO_ADDR
// end ;
70867: LD_VAR 0 3
70871: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
70872: LD_INT 0
70874: PPUSH
// if not mc_bases [ base ] then
70875: LD_EXP 42
70879: PUSH
70880: LD_VAR 0 1
70884: ARRAY
70885: NOT
70886: IFFALSE 70890
// exit ;
70888: GO 70915
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
70890: LD_ADDR_EXP 53
70894: PUSH
70895: LD_EXP 53
70899: PPUSH
70900: LD_VAR 0 1
70904: PPUSH
70905: LD_VAR 0 2
70909: PPUSH
70910: CALL_OW 1
70914: ST_TO_ADDR
// end ;
70915: LD_VAR 0 3
70919: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
70920: LD_INT 0
70922: PPUSH
70923: PPUSH
70924: PPUSH
70925: PPUSH
// if not mc_bases [ base ] then
70926: LD_EXP 42
70930: PUSH
70931: LD_VAR 0 1
70935: ARRAY
70936: NOT
70937: IFFALSE 70941
// exit ;
70939: GO 71006
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
70941: LD_ADDR_EXP 62
70945: PUSH
70946: LD_EXP 62
70950: PPUSH
70951: LD_VAR 0 1
70955: PUSH
70956: LD_EXP 62
70960: PUSH
70961: LD_VAR 0 1
70965: ARRAY
70966: PUSH
70967: LD_INT 1
70969: PLUS
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PPUSH
70975: LD_VAR 0 1
70979: PUSH
70980: LD_VAR 0 2
70984: PUSH
70985: LD_VAR 0 3
70989: PUSH
70990: LD_VAR 0 4
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: PPUSH
71001: CALL 14750 0 3
71005: ST_TO_ADDR
// end ;
71006: LD_VAR 0 5
71010: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71011: LD_INT 0
71013: PPUSH
// if not mc_bases [ base ] then
71014: LD_EXP 42
71018: PUSH
71019: LD_VAR 0 1
71023: ARRAY
71024: NOT
71025: IFFALSE 71029
// exit ;
71027: GO 71054
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71029: LD_ADDR_EXP 79
71033: PUSH
71034: LD_EXP 79
71038: PPUSH
71039: LD_VAR 0 1
71043: PPUSH
71044: LD_VAR 0 2
71048: PPUSH
71049: CALL_OW 1
71053: ST_TO_ADDR
// end ;
71054: LD_VAR 0 3
71058: RET
// export function MC_GetMinesField ( base ) ; begin
71059: LD_INT 0
71061: PPUSH
// result := mc_mines [ base ] ;
71062: LD_ADDR_VAR 0 2
71066: PUSH
71067: LD_EXP 55
71071: PUSH
71072: LD_VAR 0 1
71076: ARRAY
71077: ST_TO_ADDR
// end ;
71078: LD_VAR 0 2
71082: RET
// export function MC_GetProduceList ( base ) ; begin
71083: LD_INT 0
71085: PPUSH
// result := mc_produce [ base ] ;
71086: LD_ADDR_VAR 0 2
71090: PUSH
71091: LD_EXP 63
71095: PUSH
71096: LD_VAR 0 1
71100: ARRAY
71101: ST_TO_ADDR
// end ;
71102: LD_VAR 0 2
71106: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71107: LD_INT 0
71109: PPUSH
71110: PPUSH
// if not mc_bases then
71111: LD_EXP 42
71115: NOT
71116: IFFALSE 71120
// exit ;
71118: GO 71185
// if mc_bases [ base ] then
71120: LD_EXP 42
71124: PUSH
71125: LD_VAR 0 1
71129: ARRAY
71130: IFFALSE 71185
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71132: LD_ADDR_VAR 0 3
71136: PUSH
71137: LD_EXP 42
71141: PUSH
71142: LD_VAR 0 1
71146: ARRAY
71147: PPUSH
71148: LD_INT 30
71150: PUSH
71151: LD_VAR 0 2
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PPUSH
71160: CALL_OW 72
71164: ST_TO_ADDR
// if result then
71165: LD_VAR 0 3
71169: IFFALSE 71185
// result := result [ 1 ] ;
71171: LD_ADDR_VAR 0 3
71175: PUSH
71176: LD_VAR 0 3
71180: PUSH
71181: LD_INT 1
71183: ARRAY
71184: ST_TO_ADDR
// end ; end ;
71185: LD_VAR 0 3
71189: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71190: LD_INT 0
71192: PPUSH
71193: PPUSH
// if not mc_bases then
71194: LD_EXP 42
71198: NOT
71199: IFFALSE 71203
// exit ;
71201: GO 71248
// if mc_bases [ base ] then
71203: LD_EXP 42
71207: PUSH
71208: LD_VAR 0 1
71212: ARRAY
71213: IFFALSE 71248
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71215: LD_ADDR_VAR 0 3
71219: PUSH
71220: LD_EXP 42
71224: PUSH
71225: LD_VAR 0 1
71229: ARRAY
71230: PPUSH
71231: LD_INT 30
71233: PUSH
71234: LD_VAR 0 2
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PPUSH
71243: CALL_OW 72
71247: ST_TO_ADDR
// end ;
71248: LD_VAR 0 3
71252: RET
// export function MC_SetTame ( base , area ) ; begin
71253: LD_INT 0
71255: PPUSH
// if not mc_bases or not base then
71256: LD_EXP 42
71260: NOT
71261: PUSH
71262: LD_VAR 0 1
71266: NOT
71267: OR
71268: IFFALSE 71272
// exit ;
71270: GO 71297
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71272: LD_ADDR_EXP 70
71276: PUSH
71277: LD_EXP 70
71281: PPUSH
71282: LD_VAR 0 1
71286: PPUSH
71287: LD_VAR 0 2
71291: PPUSH
71292: CALL_OW 1
71296: ST_TO_ADDR
// end ;
71297: LD_VAR 0 3
71301: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71302: LD_INT 0
71304: PPUSH
71305: PPUSH
// if not mc_bases or not base then
71306: LD_EXP 42
71310: NOT
71311: PUSH
71312: LD_VAR 0 1
71316: NOT
71317: OR
71318: IFFALSE 71322
// exit ;
71320: GO 71424
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71322: LD_ADDR_VAR 0 4
71326: PUSH
71327: LD_EXP 42
71331: PUSH
71332: LD_VAR 0 1
71336: ARRAY
71337: PPUSH
71338: LD_INT 30
71340: PUSH
71341: LD_VAR 0 2
71345: PUSH
71346: EMPTY
71347: LIST
71348: LIST
71349: PPUSH
71350: CALL_OW 72
71354: ST_TO_ADDR
// if not tmp then
71355: LD_VAR 0 4
71359: NOT
71360: IFFALSE 71364
// exit ;
71362: GO 71424
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71364: LD_ADDR_EXP 74
71368: PUSH
71369: LD_EXP 74
71373: PPUSH
71374: LD_VAR 0 1
71378: PPUSH
71379: LD_EXP 74
71383: PUSH
71384: LD_VAR 0 1
71388: ARRAY
71389: PPUSH
71390: LD_EXP 74
71394: PUSH
71395: LD_VAR 0 1
71399: ARRAY
71400: PUSH
71401: LD_INT 1
71403: PLUS
71404: PPUSH
71405: LD_VAR 0 4
71409: PUSH
71410: LD_INT 1
71412: ARRAY
71413: PPUSH
71414: CALL_OW 2
71418: PPUSH
71419: CALL_OW 1
71423: ST_TO_ADDR
// end ;
71424: LD_VAR 0 3
71428: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71429: LD_INT 0
71431: PPUSH
71432: PPUSH
// if not mc_bases or not base or not kinds then
71433: LD_EXP 42
71437: NOT
71438: PUSH
71439: LD_VAR 0 1
71443: NOT
71444: OR
71445: PUSH
71446: LD_VAR 0 2
71450: NOT
71451: OR
71452: IFFALSE 71456
// exit ;
71454: GO 71517
// for i in kinds do
71456: LD_ADDR_VAR 0 4
71460: PUSH
71461: LD_VAR 0 2
71465: PUSH
71466: FOR_IN
71467: IFFALSE 71515
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71469: LD_ADDR_EXP 76
71473: PUSH
71474: LD_EXP 76
71478: PPUSH
71479: LD_VAR 0 1
71483: PUSH
71484: LD_EXP 76
71488: PUSH
71489: LD_VAR 0 1
71493: ARRAY
71494: PUSH
71495: LD_INT 1
71497: PLUS
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PPUSH
71503: LD_VAR 0 4
71507: PPUSH
71508: CALL 14750 0 3
71512: ST_TO_ADDR
71513: GO 71466
71515: POP
71516: POP
// end ;
71517: LD_VAR 0 3
71521: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71522: LD_INT 0
71524: PPUSH
// if not mc_bases or not base or not areas then
71525: LD_EXP 42
71529: NOT
71530: PUSH
71531: LD_VAR 0 1
71535: NOT
71536: OR
71537: PUSH
71538: LD_VAR 0 2
71542: NOT
71543: OR
71544: IFFALSE 71548
// exit ;
71546: GO 71573
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71548: LD_ADDR_EXP 60
71552: PUSH
71553: LD_EXP 60
71557: PPUSH
71558: LD_VAR 0 1
71562: PPUSH
71563: LD_VAR 0 2
71567: PPUSH
71568: CALL_OW 1
71572: ST_TO_ADDR
// end ;
71573: LD_VAR 0 3
71577: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71578: LD_INT 0
71580: PPUSH
// if not mc_bases or not base or not teleports_exit then
71581: LD_EXP 42
71585: NOT
71586: PUSH
71587: LD_VAR 0 1
71591: NOT
71592: OR
71593: PUSH
71594: LD_VAR 0 2
71598: NOT
71599: OR
71600: IFFALSE 71604
// exit ;
71602: GO 71629
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71604: LD_ADDR_EXP 77
71608: PUSH
71609: LD_EXP 77
71613: PPUSH
71614: LD_VAR 0 1
71618: PPUSH
71619: LD_VAR 0 2
71623: PPUSH
71624: CALL_OW 1
71628: ST_TO_ADDR
// end ;
71629: LD_VAR 0 3
71633: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71634: LD_INT 0
71636: PPUSH
71637: PPUSH
71638: PPUSH
// if not mc_bases or not base or not ext_list then
71639: LD_EXP 42
71643: NOT
71644: PUSH
71645: LD_VAR 0 1
71649: NOT
71650: OR
71651: PUSH
71652: LD_VAR 0 5
71656: NOT
71657: OR
71658: IFFALSE 71662
// exit ;
71660: GO 71835
// tmp := GetFacExtXYD ( x , y , d ) ;
71662: LD_ADDR_VAR 0 8
71666: PUSH
71667: LD_VAR 0 2
71671: PPUSH
71672: LD_VAR 0 3
71676: PPUSH
71677: LD_VAR 0 4
71681: PPUSH
71682: CALL 43429 0 3
71686: ST_TO_ADDR
// if not tmp then
71687: LD_VAR 0 8
71691: NOT
71692: IFFALSE 71696
// exit ;
71694: GO 71835
// for i in tmp do
71696: LD_ADDR_VAR 0 7
71700: PUSH
71701: LD_VAR 0 8
71705: PUSH
71706: FOR_IN
71707: IFFALSE 71833
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
71709: LD_ADDR_EXP 47
71713: PUSH
71714: LD_EXP 47
71718: PPUSH
71719: LD_VAR 0 1
71723: PPUSH
71724: LD_EXP 47
71728: PUSH
71729: LD_VAR 0 1
71733: ARRAY
71734: PPUSH
71735: LD_EXP 47
71739: PUSH
71740: LD_VAR 0 1
71744: ARRAY
71745: PUSH
71746: LD_INT 1
71748: PLUS
71749: PPUSH
71750: LD_VAR 0 5
71754: PUSH
71755: LD_INT 1
71757: ARRAY
71758: PUSH
71759: LD_VAR 0 7
71763: PUSH
71764: LD_INT 1
71766: ARRAY
71767: PUSH
71768: LD_VAR 0 7
71772: PUSH
71773: LD_INT 2
71775: ARRAY
71776: PUSH
71777: LD_VAR 0 7
71781: PUSH
71782: LD_INT 3
71784: ARRAY
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: PPUSH
71792: CALL_OW 2
71796: PPUSH
71797: CALL_OW 1
71801: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
71802: LD_ADDR_VAR 0 5
71806: PUSH
71807: LD_VAR 0 5
71811: PPUSH
71812: LD_INT 1
71814: PPUSH
71815: CALL_OW 3
71819: ST_TO_ADDR
// if not ext_list then
71820: LD_VAR 0 5
71824: NOT
71825: IFFALSE 71831
// exit ;
71827: POP
71828: POP
71829: GO 71835
// end ;
71831: GO 71706
71833: POP
71834: POP
// end ;
71835: LD_VAR 0 6
71839: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
71840: LD_INT 0
71842: PPUSH
// if not mc_bases or not base or not weapon_list then
71843: LD_EXP 42
71847: NOT
71848: PUSH
71849: LD_VAR 0 1
71853: NOT
71854: OR
71855: PUSH
71856: LD_VAR 0 2
71860: NOT
71861: OR
71862: IFFALSE 71866
// exit ;
71864: GO 71891
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
71866: LD_ADDR_EXP 81
71870: PUSH
71871: LD_EXP 81
71875: PPUSH
71876: LD_VAR 0 1
71880: PPUSH
71881: LD_VAR 0 2
71885: PPUSH
71886: CALL_OW 1
71890: ST_TO_ADDR
// end ;
71891: LD_VAR 0 3
71895: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
71896: LD_INT 0
71898: PPUSH
// if not mc_bases or not base or not tech_list then
71899: LD_EXP 42
71903: NOT
71904: PUSH
71905: LD_VAR 0 1
71909: NOT
71910: OR
71911: PUSH
71912: LD_VAR 0 2
71916: NOT
71917: OR
71918: IFFALSE 71922
// exit ;
71920: GO 71947
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
71922: LD_ADDR_EXP 69
71926: PUSH
71927: LD_EXP 69
71931: PPUSH
71932: LD_VAR 0 1
71936: PPUSH
71937: LD_VAR 0 2
71941: PPUSH
71942: CALL_OW 1
71946: ST_TO_ADDR
// end ;
71947: LD_VAR 0 3
71951: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
71952: LD_INT 0
71954: PPUSH
// if not mc_bases or not parking_area or not base then
71955: LD_EXP 42
71959: NOT
71960: PUSH
71961: LD_VAR 0 2
71965: NOT
71966: OR
71967: PUSH
71968: LD_VAR 0 1
71972: NOT
71973: OR
71974: IFFALSE 71978
// exit ;
71976: GO 72003
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
71978: LD_ADDR_EXP 66
71982: PUSH
71983: LD_EXP 66
71987: PPUSH
71988: LD_VAR 0 1
71992: PPUSH
71993: LD_VAR 0 2
71997: PPUSH
71998: CALL_OW 1
72002: ST_TO_ADDR
// end ;
72003: LD_VAR 0 3
72007: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72008: LD_INT 0
72010: PPUSH
// if not mc_bases or not base or not scan_area then
72011: LD_EXP 42
72015: NOT
72016: PUSH
72017: LD_VAR 0 1
72021: NOT
72022: OR
72023: PUSH
72024: LD_VAR 0 2
72028: NOT
72029: OR
72030: IFFALSE 72034
// exit ;
72032: GO 72059
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72034: LD_ADDR_EXP 67
72038: PUSH
72039: LD_EXP 67
72043: PPUSH
72044: LD_VAR 0 1
72048: PPUSH
72049: LD_VAR 0 2
72053: PPUSH
72054: CALL_OW 1
72058: ST_TO_ADDR
// end ;
72059: LD_VAR 0 3
72063: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72064: LD_INT 0
72066: PPUSH
72067: PPUSH
// if not mc_bases or not base then
72068: LD_EXP 42
72072: NOT
72073: PUSH
72074: LD_VAR 0 1
72078: NOT
72079: OR
72080: IFFALSE 72084
// exit ;
72082: GO 72148
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72084: LD_ADDR_VAR 0 3
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: LD_INT 2
72094: PUSH
72095: LD_INT 3
72097: PUSH
72098: LD_INT 4
72100: PUSH
72101: LD_INT 11
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72111: LD_ADDR_EXP 69
72115: PUSH
72116: LD_EXP 69
72120: PPUSH
72121: LD_VAR 0 1
72125: PPUSH
72126: LD_EXP 69
72130: PUSH
72131: LD_VAR 0 1
72135: ARRAY
72136: PUSH
72137: LD_VAR 0 3
72141: DIFF
72142: PPUSH
72143: CALL_OW 1
72147: ST_TO_ADDR
// end ;
72148: LD_VAR 0 2
72152: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72153: LD_INT 0
72155: PPUSH
// result := mc_vehicles [ base ] ;
72156: LD_ADDR_VAR 0 3
72160: PUSH
72161: LD_EXP 61
72165: PUSH
72166: LD_VAR 0 1
72170: ARRAY
72171: ST_TO_ADDR
// if onlyCombat then
72172: LD_VAR 0 2
72176: IFFALSE 72354
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72178: LD_ADDR_VAR 0 3
72182: PUSH
72183: LD_VAR 0 3
72187: PUSH
72188: LD_VAR 0 3
72192: PPUSH
72193: LD_INT 2
72195: PUSH
72196: LD_INT 34
72198: PUSH
72199: LD_INT 12
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 34
72208: PUSH
72209: LD_INT 51
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 34
72218: PUSH
72219: LD_EXP 86
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 34
72230: PUSH
72231: LD_INT 32
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 34
72240: PUSH
72241: LD_INT 13
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 34
72250: PUSH
72251: LD_INT 52
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 34
72260: PUSH
72261: LD_EXP 91
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 34
72272: PUSH
72273: LD_INT 14
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 34
72282: PUSH
72283: LD_INT 53
72285: PUSH
72286: EMPTY
72287: LIST
72288: LIST
72289: PUSH
72290: LD_INT 34
72292: PUSH
72293: LD_EXP 85
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 34
72304: PUSH
72305: LD_INT 31
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 34
72314: PUSH
72315: LD_INT 48
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 34
72324: PUSH
72325: LD_INT 8
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: PPUSH
72348: CALL_OW 72
72352: DIFF
72353: ST_TO_ADDR
// end ; end_of_file
72354: LD_VAR 0 3
72358: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72359: LD_INT 0
72361: PPUSH
72362: PPUSH
72363: PPUSH
// if not mc_bases or not skirmish then
72364: LD_EXP 42
72368: NOT
72369: PUSH
72370: LD_EXP 40
72374: NOT
72375: OR
72376: IFFALSE 72380
// exit ;
72378: GO 72545
// for i = 1 to mc_bases do
72380: LD_ADDR_VAR 0 4
72384: PUSH
72385: DOUBLE
72386: LD_INT 1
72388: DEC
72389: ST_TO_ADDR
72390: LD_EXP 42
72394: PUSH
72395: FOR_TO
72396: IFFALSE 72543
// begin if sci in mc_bases [ i ] then
72398: LD_VAR 0 2
72402: PUSH
72403: LD_EXP 42
72407: PUSH
72408: LD_VAR 0 4
72412: ARRAY
72413: IN
72414: IFFALSE 72541
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72416: LD_ADDR_EXP 71
72420: PUSH
72421: LD_EXP 71
72425: PPUSH
72426: LD_VAR 0 4
72430: PUSH
72431: LD_EXP 71
72435: PUSH
72436: LD_VAR 0 4
72440: ARRAY
72441: PUSH
72442: LD_INT 1
72444: PLUS
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PPUSH
72450: LD_VAR 0 1
72454: PPUSH
72455: CALL 14750 0 3
72459: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72460: LD_ADDR_VAR 0 5
72464: PUSH
72465: LD_EXP 42
72469: PUSH
72470: LD_VAR 0 4
72474: ARRAY
72475: PPUSH
72476: LD_INT 2
72478: PUSH
72479: LD_INT 30
72481: PUSH
72482: LD_INT 0
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 30
72491: PUSH
72492: LD_INT 1
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: LIST
72503: PPUSH
72504: CALL_OW 72
72508: PPUSH
72509: LD_VAR 0 1
72513: PPUSH
72514: CALL_OW 74
72518: ST_TO_ADDR
// if tmp then
72519: LD_VAR 0 5
72523: IFFALSE 72539
// ComStandNearbyBuilding ( ape , tmp ) ;
72525: LD_VAR 0 1
72529: PPUSH
72530: LD_VAR 0 5
72534: PPUSH
72535: CALL 11364 0 2
// break ;
72539: GO 72543
// end ; end ;
72541: GO 72395
72543: POP
72544: POP
// end ;
72545: LD_VAR 0 3
72549: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72550: LD_INT 0
72552: PPUSH
72553: PPUSH
72554: PPUSH
// if not mc_bases or not skirmish then
72555: LD_EXP 42
72559: NOT
72560: PUSH
72561: LD_EXP 40
72565: NOT
72566: OR
72567: IFFALSE 72571
// exit ;
72569: GO 72660
// for i = 1 to mc_bases do
72571: LD_ADDR_VAR 0 4
72575: PUSH
72576: DOUBLE
72577: LD_INT 1
72579: DEC
72580: ST_TO_ADDR
72581: LD_EXP 42
72585: PUSH
72586: FOR_TO
72587: IFFALSE 72658
// begin if building in mc_busy_turret_list [ i ] then
72589: LD_VAR 0 1
72593: PUSH
72594: LD_EXP 52
72598: PUSH
72599: LD_VAR 0 4
72603: ARRAY
72604: IN
72605: IFFALSE 72656
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72607: LD_ADDR_VAR 0 5
72611: PUSH
72612: LD_EXP 52
72616: PUSH
72617: LD_VAR 0 4
72621: ARRAY
72622: PUSH
72623: LD_VAR 0 1
72627: DIFF
72628: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72629: LD_ADDR_EXP 52
72633: PUSH
72634: LD_EXP 52
72638: PPUSH
72639: LD_VAR 0 4
72643: PPUSH
72644: LD_VAR 0 5
72648: PPUSH
72649: CALL_OW 1
72653: ST_TO_ADDR
// break ;
72654: GO 72658
// end ; end ;
72656: GO 72586
72658: POP
72659: POP
// end ;
72660: LD_VAR 0 3
72664: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72665: LD_INT 0
72667: PPUSH
72668: PPUSH
72669: PPUSH
// if not mc_bases or not skirmish then
72670: LD_EXP 42
72674: NOT
72675: PUSH
72676: LD_EXP 40
72680: NOT
72681: OR
72682: IFFALSE 72686
// exit ;
72684: GO 72885
// for i = 1 to mc_bases do
72686: LD_ADDR_VAR 0 5
72690: PUSH
72691: DOUBLE
72692: LD_INT 1
72694: DEC
72695: ST_TO_ADDR
72696: LD_EXP 42
72700: PUSH
72701: FOR_TO
72702: IFFALSE 72883
// if building in mc_bases [ i ] then
72704: LD_VAR 0 1
72708: PUSH
72709: LD_EXP 42
72713: PUSH
72714: LD_VAR 0 5
72718: ARRAY
72719: IN
72720: IFFALSE 72881
// begin tmp := mc_bases [ i ] diff building ;
72722: LD_ADDR_VAR 0 6
72726: PUSH
72727: LD_EXP 42
72731: PUSH
72732: LD_VAR 0 5
72736: ARRAY
72737: PUSH
72738: LD_VAR 0 1
72742: DIFF
72743: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
72744: LD_ADDR_EXP 42
72748: PUSH
72749: LD_EXP 42
72753: PPUSH
72754: LD_VAR 0 5
72758: PPUSH
72759: LD_VAR 0 6
72763: PPUSH
72764: CALL_OW 1
72768: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
72769: LD_VAR 0 1
72773: PUSH
72774: LD_EXP 50
72778: PUSH
72779: LD_VAR 0 5
72783: ARRAY
72784: IN
72785: IFFALSE 72824
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
72787: LD_ADDR_EXP 50
72791: PUSH
72792: LD_EXP 50
72796: PPUSH
72797: LD_VAR 0 5
72801: PPUSH
72802: LD_EXP 50
72806: PUSH
72807: LD_VAR 0 5
72811: ARRAY
72812: PUSH
72813: LD_VAR 0 1
72817: DIFF
72818: PPUSH
72819: CALL_OW 1
72823: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
72824: LD_VAR 0 1
72828: PUSH
72829: LD_EXP 51
72833: PUSH
72834: LD_VAR 0 5
72838: ARRAY
72839: IN
72840: IFFALSE 72879
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
72842: LD_ADDR_EXP 51
72846: PUSH
72847: LD_EXP 51
72851: PPUSH
72852: LD_VAR 0 5
72856: PPUSH
72857: LD_EXP 51
72861: PUSH
72862: LD_VAR 0 5
72866: ARRAY
72867: PUSH
72868: LD_VAR 0 1
72872: DIFF
72873: PPUSH
72874: CALL_OW 1
72878: ST_TO_ADDR
// break ;
72879: GO 72883
// end ;
72881: GO 72701
72883: POP
72884: POP
// end ;
72885: LD_VAR 0 4
72889: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
72890: LD_INT 0
72892: PPUSH
72893: PPUSH
72894: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
72895: LD_EXP 42
72899: NOT
72900: PUSH
72901: LD_EXP 40
72905: NOT
72906: OR
72907: PUSH
72908: LD_VAR 0 3
72912: PUSH
72913: LD_EXP 68
72917: IN
72918: NOT
72919: OR
72920: IFFALSE 72924
// exit ;
72922: GO 73047
// for i = 1 to mc_vehicles do
72924: LD_ADDR_VAR 0 6
72928: PUSH
72929: DOUBLE
72930: LD_INT 1
72932: DEC
72933: ST_TO_ADDR
72934: LD_EXP 61
72938: PUSH
72939: FOR_TO
72940: IFFALSE 73045
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
72942: LD_VAR 0 2
72946: PUSH
72947: LD_EXP 61
72951: PUSH
72952: LD_VAR 0 6
72956: ARRAY
72957: IN
72958: PUSH
72959: LD_VAR 0 1
72963: PUSH
72964: LD_EXP 61
72968: PUSH
72969: LD_VAR 0 6
72973: ARRAY
72974: IN
72975: OR
72976: IFFALSE 73043
// begin tmp := mc_vehicles [ i ] diff old ;
72978: LD_ADDR_VAR 0 7
72982: PUSH
72983: LD_EXP 61
72987: PUSH
72988: LD_VAR 0 6
72992: ARRAY
72993: PUSH
72994: LD_VAR 0 2
72998: DIFF
72999: ST_TO_ADDR
// tmp := tmp diff new ;
73000: LD_ADDR_VAR 0 7
73004: PUSH
73005: LD_VAR 0 7
73009: PUSH
73010: LD_VAR 0 1
73014: DIFF
73015: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73016: LD_ADDR_EXP 61
73020: PUSH
73021: LD_EXP 61
73025: PPUSH
73026: LD_VAR 0 6
73030: PPUSH
73031: LD_VAR 0 7
73035: PPUSH
73036: CALL_OW 1
73040: ST_TO_ADDR
// break ;
73041: GO 73045
// end ;
73043: GO 72939
73045: POP
73046: POP
// end ;
73047: LD_VAR 0 5
73051: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73052: LD_INT 0
73054: PPUSH
73055: PPUSH
73056: PPUSH
73057: PPUSH
// if not mc_bases or not skirmish then
73058: LD_EXP 42
73062: NOT
73063: PUSH
73064: LD_EXP 40
73068: NOT
73069: OR
73070: IFFALSE 73074
// exit ;
73072: GO 73457
// side := GetSide ( vehicle ) ;
73074: LD_ADDR_VAR 0 5
73078: PUSH
73079: LD_VAR 0 1
73083: PPUSH
73084: CALL_OW 255
73088: ST_TO_ADDR
// for i = 1 to mc_bases do
73089: LD_ADDR_VAR 0 4
73093: PUSH
73094: DOUBLE
73095: LD_INT 1
73097: DEC
73098: ST_TO_ADDR
73099: LD_EXP 42
73103: PUSH
73104: FOR_TO
73105: IFFALSE 73455
// begin if factory in mc_bases [ i ] then
73107: LD_VAR 0 2
73111: PUSH
73112: LD_EXP 42
73116: PUSH
73117: LD_VAR 0 4
73121: ARRAY
73122: IN
73123: IFFALSE 73453
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73125: LD_EXP 64
73129: PUSH
73130: LD_VAR 0 4
73134: ARRAY
73135: PUSH
73136: LD_EXP 53
73140: PUSH
73141: LD_VAR 0 4
73145: ARRAY
73146: LESS
73147: PUSH
73148: LD_VAR 0 1
73152: PPUSH
73153: CALL_OW 264
73157: PUSH
73158: LD_INT 31
73160: PUSH
73161: LD_INT 32
73163: PUSH
73164: LD_INT 51
73166: PUSH
73167: LD_EXP 86
73171: PUSH
73172: LD_INT 12
73174: PUSH
73175: LD_INT 30
73177: PUSH
73178: LD_EXP 85
73182: PUSH
73183: LD_INT 11
73185: PUSH
73186: LD_INT 53
73188: PUSH
73189: LD_INT 14
73191: PUSH
73192: LD_EXP 89
73196: PUSH
73197: LD_INT 29
73199: PUSH
73200: LD_EXP 87
73204: PUSH
73205: LD_INT 13
73207: PUSH
73208: LD_INT 52
73210: PUSH
73211: LD_EXP 91
73215: PUSH
73216: LD_INT 48
73218: PUSH
73219: LD_INT 8
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: IN
73242: NOT
73243: AND
73244: IFFALSE 73292
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73246: LD_ADDR_EXP 64
73250: PUSH
73251: LD_EXP 64
73255: PPUSH
73256: LD_VAR 0 4
73260: PUSH
73261: LD_EXP 64
73265: PUSH
73266: LD_VAR 0 4
73270: ARRAY
73271: PUSH
73272: LD_INT 1
73274: PLUS
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PPUSH
73280: LD_VAR 0 1
73284: PPUSH
73285: CALL 14750 0 3
73289: ST_TO_ADDR
73290: GO 73336
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73292: LD_ADDR_EXP 61
73296: PUSH
73297: LD_EXP 61
73301: PPUSH
73302: LD_VAR 0 4
73306: PUSH
73307: LD_EXP 61
73311: PUSH
73312: LD_VAR 0 4
73316: ARRAY
73317: PUSH
73318: LD_INT 1
73320: PLUS
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PPUSH
73326: LD_VAR 0 1
73330: PPUSH
73331: CALL 14750 0 3
73335: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73336: LD_VAR 0 1
73340: PPUSH
73341: CALL_OW 263
73345: PUSH
73346: LD_INT 2
73348: EQUAL
73349: IFFALSE 73369
// begin repeat wait ( 0 0$1 ) ;
73351: LD_INT 35
73353: PPUSH
73354: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73358: LD_VAR 0 1
73362: PPUSH
73363: CALL_OW 312
73367: IFFALSE 73351
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73369: LD_VAR 0 1
73373: PPUSH
73374: LD_EXP 66
73378: PUSH
73379: LD_VAR 0 4
73383: ARRAY
73384: PPUSH
73385: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73389: LD_VAR 0 1
73393: PPUSH
73394: CALL_OW 263
73398: PUSH
73399: LD_INT 1
73401: NONEQUAL
73402: IFFALSE 73406
// break ;
73404: GO 73455
// repeat wait ( 0 0$1 ) ;
73406: LD_INT 35
73408: PPUSH
73409: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73413: LD_VAR 0 1
73417: PPUSH
73418: LD_EXP 66
73422: PUSH
73423: LD_VAR 0 4
73427: ARRAY
73428: PPUSH
73429: CALL_OW 308
73433: IFFALSE 73406
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73435: LD_VAR 0 1
73439: PPUSH
73440: CALL_OW 311
73444: PPUSH
73445: CALL_OW 121
// exit ;
73449: POP
73450: POP
73451: GO 73457
// end ; end ;
73453: GO 73104
73455: POP
73456: POP
// end ;
73457: LD_VAR 0 3
73461: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73462: LD_INT 0
73464: PPUSH
73465: PPUSH
73466: PPUSH
73467: PPUSH
// if not mc_bases or not skirmish then
73468: LD_EXP 42
73472: NOT
73473: PUSH
73474: LD_EXP 40
73478: NOT
73479: OR
73480: IFFALSE 73484
// exit ;
73482: GO 73837
// repeat wait ( 0 0$1 ) ;
73484: LD_INT 35
73486: PPUSH
73487: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73491: LD_VAR 0 2
73495: PPUSH
73496: LD_VAR 0 3
73500: PPUSH
73501: CALL_OW 284
73505: IFFALSE 73484
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73507: LD_VAR 0 2
73511: PPUSH
73512: LD_VAR 0 3
73516: PPUSH
73517: CALL_OW 283
73521: PUSH
73522: LD_INT 4
73524: EQUAL
73525: IFFALSE 73529
// exit ;
73527: GO 73837
// for i = 1 to mc_bases do
73529: LD_ADDR_VAR 0 7
73533: PUSH
73534: DOUBLE
73535: LD_INT 1
73537: DEC
73538: ST_TO_ADDR
73539: LD_EXP 42
73543: PUSH
73544: FOR_TO
73545: IFFALSE 73835
// begin if mc_crates_area [ i ] then
73547: LD_EXP 60
73551: PUSH
73552: LD_VAR 0 7
73556: ARRAY
73557: IFFALSE 73668
// for j in mc_crates_area [ i ] do
73559: LD_ADDR_VAR 0 8
73563: PUSH
73564: LD_EXP 60
73568: PUSH
73569: LD_VAR 0 7
73573: ARRAY
73574: PUSH
73575: FOR_IN
73576: IFFALSE 73666
// if InArea ( x , y , j ) then
73578: LD_VAR 0 2
73582: PPUSH
73583: LD_VAR 0 3
73587: PPUSH
73588: LD_VAR 0 8
73592: PPUSH
73593: CALL_OW 309
73597: IFFALSE 73664
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73599: LD_ADDR_EXP 58
73603: PUSH
73604: LD_EXP 58
73608: PPUSH
73609: LD_VAR 0 7
73613: PUSH
73614: LD_EXP 58
73618: PUSH
73619: LD_VAR 0 7
73623: ARRAY
73624: PUSH
73625: LD_INT 1
73627: PLUS
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PPUSH
73633: LD_VAR 0 4
73637: PUSH
73638: LD_VAR 0 2
73642: PUSH
73643: LD_VAR 0 3
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: PPUSH
73653: CALL 14750 0 3
73657: ST_TO_ADDR
// exit ;
73658: POP
73659: POP
73660: POP
73661: POP
73662: GO 73837
// end ;
73664: GO 73575
73666: POP
73667: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73668: LD_ADDR_VAR 0 9
73672: PUSH
73673: LD_EXP 42
73677: PUSH
73678: LD_VAR 0 7
73682: ARRAY
73683: PPUSH
73684: LD_INT 2
73686: PUSH
73687: LD_INT 30
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 30
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: LIST
73711: PPUSH
73712: CALL_OW 72
73716: ST_TO_ADDR
// if not depot then
73717: LD_VAR 0 9
73721: NOT
73722: IFFALSE 73726
// continue ;
73724: GO 73544
// for j in depot do
73726: LD_ADDR_VAR 0 8
73730: PUSH
73731: LD_VAR 0 9
73735: PUSH
73736: FOR_IN
73737: IFFALSE 73831
// if GetDistUnitXY ( j , x , y ) < 30 then
73739: LD_VAR 0 8
73743: PPUSH
73744: LD_VAR 0 2
73748: PPUSH
73749: LD_VAR 0 3
73753: PPUSH
73754: CALL_OW 297
73758: PUSH
73759: LD_INT 30
73761: LESS
73762: IFFALSE 73829
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73764: LD_ADDR_EXP 58
73768: PUSH
73769: LD_EXP 58
73773: PPUSH
73774: LD_VAR 0 7
73778: PUSH
73779: LD_EXP 58
73783: PUSH
73784: LD_VAR 0 7
73788: ARRAY
73789: PUSH
73790: LD_INT 1
73792: PLUS
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PPUSH
73798: LD_VAR 0 4
73802: PUSH
73803: LD_VAR 0 2
73807: PUSH
73808: LD_VAR 0 3
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: LIST
73817: PPUSH
73818: CALL 14750 0 3
73822: ST_TO_ADDR
// exit ;
73823: POP
73824: POP
73825: POP
73826: POP
73827: GO 73837
// end ;
73829: GO 73736
73831: POP
73832: POP
// end ;
73833: GO 73544
73835: POP
73836: POP
// end ;
73837: LD_VAR 0 6
73841: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
73842: LD_INT 0
73844: PPUSH
73845: PPUSH
73846: PPUSH
73847: PPUSH
// if not mc_bases or not skirmish then
73848: LD_EXP 42
73852: NOT
73853: PUSH
73854: LD_EXP 40
73858: NOT
73859: OR
73860: IFFALSE 73864
// exit ;
73862: GO 74141
// side := GetSide ( lab ) ;
73864: LD_ADDR_VAR 0 4
73868: PUSH
73869: LD_VAR 0 2
73873: PPUSH
73874: CALL_OW 255
73878: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
73879: LD_VAR 0 4
73883: PUSH
73884: LD_EXP 68
73888: IN
73889: NOT
73890: PUSH
73891: LD_EXP 69
73895: NOT
73896: OR
73897: PUSH
73898: LD_EXP 42
73902: NOT
73903: OR
73904: IFFALSE 73908
// exit ;
73906: GO 74141
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
73908: LD_ADDR_EXP 69
73912: PUSH
73913: LD_EXP 69
73917: PPUSH
73918: LD_VAR 0 4
73922: PPUSH
73923: LD_EXP 69
73927: PUSH
73928: LD_VAR 0 4
73932: ARRAY
73933: PUSH
73934: LD_VAR 0 1
73938: DIFF
73939: PPUSH
73940: CALL_OW 1
73944: ST_TO_ADDR
// for i = 1 to mc_bases do
73945: LD_ADDR_VAR 0 5
73949: PUSH
73950: DOUBLE
73951: LD_INT 1
73953: DEC
73954: ST_TO_ADDR
73955: LD_EXP 42
73959: PUSH
73960: FOR_TO
73961: IFFALSE 74139
// begin if lab in mc_bases [ i ] then
73963: LD_VAR 0 2
73967: PUSH
73968: LD_EXP 42
73972: PUSH
73973: LD_VAR 0 5
73977: ARRAY
73978: IN
73979: IFFALSE 74137
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
73981: LD_VAR 0 1
73985: PUSH
73986: LD_INT 11
73988: PUSH
73989: LD_INT 4
73991: PUSH
73992: LD_INT 3
73994: PUSH
73995: LD_INT 2
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: IN
74004: PUSH
74005: LD_EXP 72
74009: PUSH
74010: LD_VAR 0 5
74014: ARRAY
74015: AND
74016: IFFALSE 74137
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74018: LD_ADDR_VAR 0 6
74022: PUSH
74023: LD_EXP 72
74027: PUSH
74028: LD_VAR 0 5
74032: ARRAY
74033: PUSH
74034: LD_INT 1
74036: ARRAY
74037: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74038: LD_ADDR_EXP 72
74042: PUSH
74043: LD_EXP 72
74047: PPUSH
74048: LD_VAR 0 5
74052: PPUSH
74053: EMPTY
74054: PPUSH
74055: CALL_OW 1
74059: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74060: LD_VAR 0 6
74064: PPUSH
74065: LD_INT 0
74067: PPUSH
74068: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74072: LD_VAR 0 6
74076: PPUSH
74077: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74081: LD_ADDR_EXP 71
74085: PUSH
74086: LD_EXP 71
74090: PPUSH
74091: LD_VAR 0 5
74095: PPUSH
74096: LD_EXP 71
74100: PUSH
74101: LD_VAR 0 5
74105: ARRAY
74106: PPUSH
74107: LD_INT 1
74109: PPUSH
74110: LD_VAR 0 6
74114: PPUSH
74115: CALL_OW 2
74119: PPUSH
74120: CALL_OW 1
74124: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74125: LD_VAR 0 5
74129: PPUSH
74130: LD_INT 112
74132: PPUSH
74133: CALL 51086 0 2
// end ; end ; end ;
74137: GO 73960
74139: POP
74140: POP
// end ;
74141: LD_VAR 0 3
74145: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74146: LD_INT 0
74148: PPUSH
74149: PPUSH
74150: PPUSH
74151: PPUSH
74152: PPUSH
74153: PPUSH
74154: PPUSH
74155: PPUSH
// if not mc_bases or not skirmish then
74156: LD_EXP 42
74160: NOT
74161: PUSH
74162: LD_EXP 40
74166: NOT
74167: OR
74168: IFFALSE 74172
// exit ;
74170: GO 75543
// for i = 1 to mc_bases do
74172: LD_ADDR_VAR 0 3
74176: PUSH
74177: DOUBLE
74178: LD_INT 1
74180: DEC
74181: ST_TO_ADDR
74182: LD_EXP 42
74186: PUSH
74187: FOR_TO
74188: IFFALSE 75541
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74190: LD_VAR 0 1
74194: PUSH
74195: LD_EXP 42
74199: PUSH
74200: LD_VAR 0 3
74204: ARRAY
74205: IN
74206: PUSH
74207: LD_VAR 0 1
74211: PUSH
74212: LD_EXP 49
74216: PUSH
74217: LD_VAR 0 3
74221: ARRAY
74222: IN
74223: OR
74224: PUSH
74225: LD_VAR 0 1
74229: PUSH
74230: LD_EXP 64
74234: PUSH
74235: LD_VAR 0 3
74239: ARRAY
74240: IN
74241: OR
74242: PUSH
74243: LD_VAR 0 1
74247: PUSH
74248: LD_EXP 61
74252: PUSH
74253: LD_VAR 0 3
74257: ARRAY
74258: IN
74259: OR
74260: PUSH
74261: LD_VAR 0 1
74265: PUSH
74266: LD_EXP 71
74270: PUSH
74271: LD_VAR 0 3
74275: ARRAY
74276: IN
74277: OR
74278: PUSH
74279: LD_VAR 0 1
74283: PUSH
74284: LD_EXP 72
74288: PUSH
74289: LD_VAR 0 3
74293: ARRAY
74294: IN
74295: OR
74296: IFFALSE 75539
// begin if un in mc_ape [ i ] then
74298: LD_VAR 0 1
74302: PUSH
74303: LD_EXP 71
74307: PUSH
74308: LD_VAR 0 3
74312: ARRAY
74313: IN
74314: IFFALSE 74353
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74316: LD_ADDR_EXP 71
74320: PUSH
74321: LD_EXP 71
74325: PPUSH
74326: LD_VAR 0 3
74330: PPUSH
74331: LD_EXP 71
74335: PUSH
74336: LD_VAR 0 3
74340: ARRAY
74341: PUSH
74342: LD_VAR 0 1
74346: DIFF
74347: PPUSH
74348: CALL_OW 1
74352: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74353: LD_VAR 0 1
74357: PUSH
74358: LD_EXP 72
74362: PUSH
74363: LD_VAR 0 3
74367: ARRAY
74368: IN
74369: IFFALSE 74393
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74371: LD_ADDR_EXP 72
74375: PUSH
74376: LD_EXP 72
74380: PPUSH
74381: LD_VAR 0 3
74385: PPUSH
74386: EMPTY
74387: PPUSH
74388: CALL_OW 1
74392: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74393: LD_VAR 0 1
74397: PPUSH
74398: CALL_OW 247
74402: PUSH
74403: LD_INT 2
74405: EQUAL
74406: PUSH
74407: LD_VAR 0 1
74411: PPUSH
74412: CALL_OW 110
74416: PUSH
74417: LD_INT 20
74419: EQUAL
74420: PUSH
74421: LD_VAR 0 1
74425: PUSH
74426: LD_EXP 64
74430: PUSH
74431: LD_VAR 0 3
74435: ARRAY
74436: IN
74437: OR
74438: PUSH
74439: LD_VAR 0 1
74443: PPUSH
74444: CALL_OW 264
74448: PUSH
74449: LD_INT 12
74451: PUSH
74452: LD_INT 51
74454: PUSH
74455: LD_EXP 86
74459: PUSH
74460: LD_INT 32
74462: PUSH
74463: LD_INT 13
74465: PUSH
74466: LD_INT 52
74468: PUSH
74469: LD_INT 31
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: LIST
74476: LIST
74477: LIST
74478: LIST
74479: LIST
74480: IN
74481: OR
74482: AND
74483: IFFALSE 74791
// begin if un in mc_defender [ i ] then
74485: LD_VAR 0 1
74489: PUSH
74490: LD_EXP 64
74494: PUSH
74495: LD_VAR 0 3
74499: ARRAY
74500: IN
74501: IFFALSE 74540
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74503: LD_ADDR_EXP 64
74507: PUSH
74508: LD_EXP 64
74512: PPUSH
74513: LD_VAR 0 3
74517: PPUSH
74518: LD_EXP 64
74522: PUSH
74523: LD_VAR 0 3
74527: ARRAY
74528: PUSH
74529: LD_VAR 0 1
74533: DIFF
74534: PPUSH
74535: CALL_OW 1
74539: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74540: LD_ADDR_VAR 0 8
74544: PUSH
74545: LD_VAR 0 3
74549: PPUSH
74550: LD_INT 3
74552: PPUSH
74553: CALL 71190 0 2
74557: ST_TO_ADDR
// if fac then
74558: LD_VAR 0 8
74562: IFFALSE 74791
// begin for j in fac do
74564: LD_ADDR_VAR 0 4
74568: PUSH
74569: LD_VAR 0 8
74573: PUSH
74574: FOR_IN
74575: IFFALSE 74789
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74577: LD_ADDR_VAR 0 9
74581: PUSH
74582: LD_VAR 0 8
74586: PPUSH
74587: LD_VAR 0 1
74591: PPUSH
74592: CALL_OW 265
74596: PPUSH
74597: LD_VAR 0 1
74601: PPUSH
74602: CALL_OW 262
74606: PPUSH
74607: LD_VAR 0 1
74611: PPUSH
74612: CALL_OW 263
74616: PPUSH
74617: LD_VAR 0 1
74621: PPUSH
74622: CALL_OW 264
74626: PPUSH
74627: CALL 12282 0 5
74631: ST_TO_ADDR
// if components then
74632: LD_VAR 0 9
74636: IFFALSE 74787
// begin if GetWeapon ( un ) = ar_control_tower then
74638: LD_VAR 0 1
74642: PPUSH
74643: CALL_OW 264
74647: PUSH
74648: LD_INT 31
74650: EQUAL
74651: IFFALSE 74768
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74653: LD_VAR 0 1
74657: PPUSH
74658: CALL_OW 311
74662: PPUSH
74663: LD_INT 0
74665: PPUSH
74666: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74670: LD_ADDR_EXP 82
74674: PUSH
74675: LD_EXP 82
74679: PPUSH
74680: LD_VAR 0 3
74684: PPUSH
74685: LD_EXP 82
74689: PUSH
74690: LD_VAR 0 3
74694: ARRAY
74695: PUSH
74696: LD_VAR 0 1
74700: PPUSH
74701: CALL_OW 311
74705: DIFF
74706: PPUSH
74707: CALL_OW 1
74711: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
74712: LD_ADDR_VAR 0 7
74716: PUSH
74717: LD_EXP 63
74721: PUSH
74722: LD_VAR 0 3
74726: ARRAY
74727: PPUSH
74728: LD_INT 1
74730: PPUSH
74731: LD_VAR 0 9
74735: PPUSH
74736: CALL_OW 2
74740: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74741: LD_ADDR_EXP 63
74745: PUSH
74746: LD_EXP 63
74750: PPUSH
74751: LD_VAR 0 3
74755: PPUSH
74756: LD_VAR 0 7
74760: PPUSH
74761: CALL_OW 1
74765: ST_TO_ADDR
// end else
74766: GO 74785
// MC_InsertProduceList ( i , [ components ] ) ;
74768: LD_VAR 0 3
74772: PPUSH
74773: LD_VAR 0 9
74777: PUSH
74778: EMPTY
74779: LIST
74780: PPUSH
74781: CALL 70735 0 2
// break ;
74785: GO 74789
// end ; end ;
74787: GO 74574
74789: POP
74790: POP
// end ; end ; if GetType ( un ) = unit_building then
74791: LD_VAR 0 1
74795: PPUSH
74796: CALL_OW 247
74800: PUSH
74801: LD_INT 3
74803: EQUAL
74804: IFFALSE 75207
// begin btype := GetBType ( un ) ;
74806: LD_ADDR_VAR 0 5
74810: PUSH
74811: LD_VAR 0 1
74815: PPUSH
74816: CALL_OW 266
74820: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
74821: LD_VAR 0 5
74825: PUSH
74826: LD_INT 29
74828: PUSH
74829: LD_INT 30
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: IN
74836: IFFALSE 74909
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
74838: LD_VAR 0 1
74842: PPUSH
74843: CALL_OW 250
74847: PPUSH
74848: LD_VAR 0 1
74852: PPUSH
74853: CALL_OW 251
74857: PPUSH
74858: LD_VAR 0 1
74862: PPUSH
74863: CALL_OW 255
74867: PPUSH
74868: CALL_OW 440
74872: NOT
74873: IFFALSE 74909
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
74875: LD_VAR 0 1
74879: PPUSH
74880: CALL_OW 250
74884: PPUSH
74885: LD_VAR 0 1
74889: PPUSH
74890: CALL_OW 251
74894: PPUSH
74895: LD_VAR 0 1
74899: PPUSH
74900: CALL_OW 255
74904: PPUSH
74905: CALL_OW 441
// end ; if btype = b_warehouse then
74909: LD_VAR 0 5
74913: PUSH
74914: LD_INT 1
74916: EQUAL
74917: IFFALSE 74935
// begin btype := b_depot ;
74919: LD_ADDR_VAR 0 5
74923: PUSH
74924: LD_INT 0
74926: ST_TO_ADDR
// pos := 1 ;
74927: LD_ADDR_VAR 0 6
74931: PUSH
74932: LD_INT 1
74934: ST_TO_ADDR
// end ; if btype = b_factory then
74935: LD_VAR 0 5
74939: PUSH
74940: LD_INT 3
74942: EQUAL
74943: IFFALSE 74961
// begin btype := b_workshop ;
74945: LD_ADDR_VAR 0 5
74949: PUSH
74950: LD_INT 2
74952: ST_TO_ADDR
// pos := 1 ;
74953: LD_ADDR_VAR 0 6
74957: PUSH
74958: LD_INT 1
74960: ST_TO_ADDR
// end ; if btype = b_barracks then
74961: LD_VAR 0 5
74965: PUSH
74966: LD_INT 5
74968: EQUAL
74969: IFFALSE 74979
// btype := b_armoury ;
74971: LD_ADDR_VAR 0 5
74975: PUSH
74976: LD_INT 4
74978: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
74979: LD_VAR 0 5
74983: PUSH
74984: LD_INT 7
74986: PUSH
74987: LD_INT 8
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: IN
74994: IFFALSE 75004
// btype := b_lab ;
74996: LD_ADDR_VAR 0 5
75000: PUSH
75001: LD_INT 6
75003: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75004: LD_ADDR_EXP 47
75008: PUSH
75009: LD_EXP 47
75013: PPUSH
75014: LD_VAR 0 3
75018: PUSH
75019: LD_EXP 47
75023: PUSH
75024: LD_VAR 0 3
75028: ARRAY
75029: PUSH
75030: LD_INT 1
75032: PLUS
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PPUSH
75038: LD_VAR 0 5
75042: PUSH
75043: LD_VAR 0 1
75047: PPUSH
75048: CALL_OW 250
75052: PUSH
75053: LD_VAR 0 1
75057: PPUSH
75058: CALL_OW 251
75062: PUSH
75063: LD_VAR 0 1
75067: PPUSH
75068: CALL_OW 254
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: PPUSH
75079: CALL 14750 0 3
75083: ST_TO_ADDR
// if pos = 1 then
75084: LD_VAR 0 6
75088: PUSH
75089: LD_INT 1
75091: EQUAL
75092: IFFALSE 75207
// begin tmp := mc_build_list [ i ] ;
75094: LD_ADDR_VAR 0 7
75098: PUSH
75099: LD_EXP 47
75103: PUSH
75104: LD_VAR 0 3
75108: ARRAY
75109: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75110: LD_VAR 0 7
75114: PPUSH
75115: LD_INT 2
75117: PUSH
75118: LD_INT 30
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 30
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: LIST
75142: PPUSH
75143: CALL_OW 72
75147: IFFALSE 75157
// pos := 2 ;
75149: LD_ADDR_VAR 0 6
75153: PUSH
75154: LD_INT 2
75156: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75157: LD_ADDR_VAR 0 7
75161: PUSH
75162: LD_VAR 0 7
75166: PPUSH
75167: LD_VAR 0 6
75171: PPUSH
75172: LD_VAR 0 7
75176: PPUSH
75177: CALL 15076 0 3
75181: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75182: LD_ADDR_EXP 47
75186: PUSH
75187: LD_EXP 47
75191: PPUSH
75192: LD_VAR 0 3
75196: PPUSH
75197: LD_VAR 0 7
75201: PPUSH
75202: CALL_OW 1
75206: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75207: LD_VAR 0 1
75211: PUSH
75212: LD_EXP 42
75216: PUSH
75217: LD_VAR 0 3
75221: ARRAY
75222: IN
75223: IFFALSE 75262
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75225: LD_ADDR_EXP 42
75229: PUSH
75230: LD_EXP 42
75234: PPUSH
75235: LD_VAR 0 3
75239: PPUSH
75240: LD_EXP 42
75244: PUSH
75245: LD_VAR 0 3
75249: ARRAY
75250: PUSH
75251: LD_VAR 0 1
75255: DIFF
75256: PPUSH
75257: CALL_OW 1
75261: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75262: LD_VAR 0 1
75266: PUSH
75267: LD_EXP 49
75271: PUSH
75272: LD_VAR 0 3
75276: ARRAY
75277: IN
75278: IFFALSE 75317
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75280: LD_ADDR_EXP 49
75284: PUSH
75285: LD_EXP 49
75289: PPUSH
75290: LD_VAR 0 3
75294: PPUSH
75295: LD_EXP 49
75299: PUSH
75300: LD_VAR 0 3
75304: ARRAY
75305: PUSH
75306: LD_VAR 0 1
75310: DIFF
75311: PPUSH
75312: CALL_OW 1
75316: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75317: LD_VAR 0 1
75321: PUSH
75322: LD_EXP 61
75326: PUSH
75327: LD_VAR 0 3
75331: ARRAY
75332: IN
75333: IFFALSE 75372
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75335: LD_ADDR_EXP 61
75339: PUSH
75340: LD_EXP 61
75344: PPUSH
75345: LD_VAR 0 3
75349: PPUSH
75350: LD_EXP 61
75354: PUSH
75355: LD_VAR 0 3
75359: ARRAY
75360: PUSH
75361: LD_VAR 0 1
75365: DIFF
75366: PPUSH
75367: CALL_OW 1
75371: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75372: LD_VAR 0 1
75376: PUSH
75377: LD_EXP 64
75381: PUSH
75382: LD_VAR 0 3
75386: ARRAY
75387: IN
75388: IFFALSE 75427
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75390: LD_ADDR_EXP 64
75394: PUSH
75395: LD_EXP 64
75399: PPUSH
75400: LD_VAR 0 3
75404: PPUSH
75405: LD_EXP 64
75409: PUSH
75410: LD_VAR 0 3
75414: ARRAY
75415: PUSH
75416: LD_VAR 0 1
75420: DIFF
75421: PPUSH
75422: CALL_OW 1
75426: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75427: LD_VAR 0 1
75431: PUSH
75432: LD_EXP 51
75436: PUSH
75437: LD_VAR 0 3
75441: ARRAY
75442: IN
75443: IFFALSE 75482
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75445: LD_ADDR_EXP 51
75449: PUSH
75450: LD_EXP 51
75454: PPUSH
75455: LD_VAR 0 3
75459: PPUSH
75460: LD_EXP 51
75464: PUSH
75465: LD_VAR 0 3
75469: ARRAY
75470: PUSH
75471: LD_VAR 0 1
75475: DIFF
75476: PPUSH
75477: CALL_OW 1
75481: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75482: LD_VAR 0 1
75486: PUSH
75487: LD_EXP 50
75491: PUSH
75492: LD_VAR 0 3
75496: ARRAY
75497: IN
75498: IFFALSE 75537
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75500: LD_ADDR_EXP 50
75504: PUSH
75505: LD_EXP 50
75509: PPUSH
75510: LD_VAR 0 3
75514: PPUSH
75515: LD_EXP 50
75519: PUSH
75520: LD_VAR 0 3
75524: ARRAY
75525: PUSH
75526: LD_VAR 0 1
75530: DIFF
75531: PPUSH
75532: CALL_OW 1
75536: ST_TO_ADDR
// end ; break ;
75537: GO 75541
// end ;
75539: GO 74187
75541: POP
75542: POP
// end ;
75543: LD_VAR 0 2
75547: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75548: LD_INT 0
75550: PPUSH
75551: PPUSH
75552: PPUSH
// if not mc_bases or not skirmish then
75553: LD_EXP 42
75557: NOT
75558: PUSH
75559: LD_EXP 40
75563: NOT
75564: OR
75565: IFFALSE 75569
// exit ;
75567: GO 75784
// for i = 1 to mc_bases do
75569: LD_ADDR_VAR 0 3
75573: PUSH
75574: DOUBLE
75575: LD_INT 1
75577: DEC
75578: ST_TO_ADDR
75579: LD_EXP 42
75583: PUSH
75584: FOR_TO
75585: IFFALSE 75782
// begin if building in mc_construct_list [ i ] then
75587: LD_VAR 0 1
75591: PUSH
75592: LD_EXP 49
75596: PUSH
75597: LD_VAR 0 3
75601: ARRAY
75602: IN
75603: IFFALSE 75780
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75605: LD_ADDR_EXP 49
75609: PUSH
75610: LD_EXP 49
75614: PPUSH
75615: LD_VAR 0 3
75619: PPUSH
75620: LD_EXP 49
75624: PUSH
75625: LD_VAR 0 3
75629: ARRAY
75630: PUSH
75631: LD_VAR 0 1
75635: DIFF
75636: PPUSH
75637: CALL_OW 1
75641: ST_TO_ADDR
// if building in mc_lab [ i ] then
75642: LD_VAR 0 1
75646: PUSH
75647: LD_EXP 75
75651: PUSH
75652: LD_VAR 0 3
75656: ARRAY
75657: IN
75658: IFFALSE 75713
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75660: LD_ADDR_EXP 76
75664: PUSH
75665: LD_EXP 76
75669: PPUSH
75670: LD_VAR 0 3
75674: PPUSH
75675: LD_EXP 76
75679: PUSH
75680: LD_VAR 0 3
75684: ARRAY
75685: PPUSH
75686: LD_INT 1
75688: PPUSH
75689: LD_EXP 76
75693: PUSH
75694: LD_VAR 0 3
75698: ARRAY
75699: PPUSH
75700: LD_INT 0
75702: PPUSH
75703: CALL 14168 0 4
75707: PPUSH
75708: CALL_OW 1
75712: ST_TO_ADDR
// if not building in mc_bases [ i ] then
75713: LD_VAR 0 1
75717: PUSH
75718: LD_EXP 42
75722: PUSH
75723: LD_VAR 0 3
75727: ARRAY
75728: IN
75729: NOT
75730: IFFALSE 75776
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75732: LD_ADDR_EXP 42
75736: PUSH
75737: LD_EXP 42
75741: PPUSH
75742: LD_VAR 0 3
75746: PUSH
75747: LD_EXP 42
75751: PUSH
75752: LD_VAR 0 3
75756: ARRAY
75757: PUSH
75758: LD_INT 1
75760: PLUS
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PPUSH
75766: LD_VAR 0 1
75770: PPUSH
75771: CALL 14750 0 3
75775: ST_TO_ADDR
// exit ;
75776: POP
75777: POP
75778: GO 75784
// end ; end ;
75780: GO 75584
75782: POP
75783: POP
// end ;
75784: LD_VAR 0 2
75788: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
75789: LD_INT 0
75791: PPUSH
75792: PPUSH
75793: PPUSH
75794: PPUSH
75795: PPUSH
75796: PPUSH
75797: PPUSH
// if not mc_bases or not skirmish then
75798: LD_EXP 42
75802: NOT
75803: PUSH
75804: LD_EXP 40
75808: NOT
75809: OR
75810: IFFALSE 75814
// exit ;
75812: GO 76475
// for i = 1 to mc_bases do
75814: LD_ADDR_VAR 0 3
75818: PUSH
75819: DOUBLE
75820: LD_INT 1
75822: DEC
75823: ST_TO_ADDR
75824: LD_EXP 42
75828: PUSH
75829: FOR_TO
75830: IFFALSE 76473
// begin if building in mc_construct_list [ i ] then
75832: LD_VAR 0 1
75836: PUSH
75837: LD_EXP 49
75841: PUSH
75842: LD_VAR 0 3
75846: ARRAY
75847: IN
75848: IFFALSE 76471
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75850: LD_ADDR_EXP 49
75854: PUSH
75855: LD_EXP 49
75859: PPUSH
75860: LD_VAR 0 3
75864: PPUSH
75865: LD_EXP 49
75869: PUSH
75870: LD_VAR 0 3
75874: ARRAY
75875: PUSH
75876: LD_VAR 0 1
75880: DIFF
75881: PPUSH
75882: CALL_OW 1
75886: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75887: LD_ADDR_EXP 42
75891: PUSH
75892: LD_EXP 42
75896: PPUSH
75897: LD_VAR 0 3
75901: PUSH
75902: LD_EXP 42
75906: PUSH
75907: LD_VAR 0 3
75911: ARRAY
75912: PUSH
75913: LD_INT 1
75915: PLUS
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PPUSH
75921: LD_VAR 0 1
75925: PPUSH
75926: CALL 14750 0 3
75930: ST_TO_ADDR
// btype := GetBType ( building ) ;
75931: LD_ADDR_VAR 0 5
75935: PUSH
75936: LD_VAR 0 1
75940: PPUSH
75941: CALL_OW 266
75945: ST_TO_ADDR
// side := GetSide ( building ) ;
75946: LD_ADDR_VAR 0 8
75950: PUSH
75951: LD_VAR 0 1
75955: PPUSH
75956: CALL_OW 255
75960: ST_TO_ADDR
// if btype = b_lab then
75961: LD_VAR 0 5
75965: PUSH
75966: LD_INT 6
75968: EQUAL
75969: IFFALSE 76019
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
75971: LD_ADDR_EXP 75
75975: PUSH
75976: LD_EXP 75
75980: PPUSH
75981: LD_VAR 0 3
75985: PUSH
75986: LD_EXP 75
75990: PUSH
75991: LD_VAR 0 3
75995: ARRAY
75996: PUSH
75997: LD_INT 1
75999: PLUS
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PPUSH
76005: LD_VAR 0 1
76009: PPUSH
76010: CALL 14750 0 3
76014: ST_TO_ADDR
// exit ;
76015: POP
76016: POP
76017: GO 76475
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76019: LD_VAR 0 5
76023: PUSH
76024: LD_INT 0
76026: PUSH
76027: LD_INT 2
76029: PUSH
76030: LD_INT 4
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: LIST
76037: IN
76038: IFFALSE 76162
// begin if btype = b_armoury then
76040: LD_VAR 0 5
76044: PUSH
76045: LD_INT 4
76047: EQUAL
76048: IFFALSE 76058
// btype := b_barracks ;
76050: LD_ADDR_VAR 0 5
76054: PUSH
76055: LD_INT 5
76057: ST_TO_ADDR
// if btype = b_depot then
76058: LD_VAR 0 5
76062: PUSH
76063: LD_INT 0
76065: EQUAL
76066: IFFALSE 76076
// btype := b_warehouse ;
76068: LD_ADDR_VAR 0 5
76072: PUSH
76073: LD_INT 1
76075: ST_TO_ADDR
// if btype = b_workshop then
76076: LD_VAR 0 5
76080: PUSH
76081: LD_INT 2
76083: EQUAL
76084: IFFALSE 76094
// btype := b_factory ;
76086: LD_ADDR_VAR 0 5
76090: PUSH
76091: LD_INT 3
76093: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76094: LD_VAR 0 5
76098: PPUSH
76099: LD_VAR 0 8
76103: PPUSH
76104: CALL_OW 323
76108: PUSH
76109: LD_INT 1
76111: EQUAL
76112: IFFALSE 76158
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76114: LD_ADDR_EXP 74
76118: PUSH
76119: LD_EXP 74
76123: PPUSH
76124: LD_VAR 0 3
76128: PUSH
76129: LD_EXP 74
76133: PUSH
76134: LD_VAR 0 3
76138: ARRAY
76139: PUSH
76140: LD_INT 1
76142: PLUS
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PPUSH
76148: LD_VAR 0 1
76152: PPUSH
76153: CALL 14750 0 3
76157: ST_TO_ADDR
// exit ;
76158: POP
76159: POP
76160: GO 76475
// end ; if btype in [ b_bunker , b_turret ] then
76162: LD_VAR 0 5
76166: PUSH
76167: LD_INT 32
76169: PUSH
76170: LD_INT 33
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: IN
76177: IFFALSE 76467
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76179: LD_ADDR_EXP 50
76183: PUSH
76184: LD_EXP 50
76188: PPUSH
76189: LD_VAR 0 3
76193: PUSH
76194: LD_EXP 50
76198: PUSH
76199: LD_VAR 0 3
76203: ARRAY
76204: PUSH
76205: LD_INT 1
76207: PLUS
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PPUSH
76213: LD_VAR 0 1
76217: PPUSH
76218: CALL 14750 0 3
76222: ST_TO_ADDR
// if btype = b_bunker then
76223: LD_VAR 0 5
76227: PUSH
76228: LD_INT 32
76230: EQUAL
76231: IFFALSE 76467
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76233: LD_ADDR_EXP 51
76237: PUSH
76238: LD_EXP 51
76242: PPUSH
76243: LD_VAR 0 3
76247: PUSH
76248: LD_EXP 51
76252: PUSH
76253: LD_VAR 0 3
76257: ARRAY
76258: PUSH
76259: LD_INT 1
76261: PLUS
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PPUSH
76267: LD_VAR 0 1
76271: PPUSH
76272: CALL 14750 0 3
76276: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76277: LD_ADDR_VAR 0 6
76281: PUSH
76282: LD_EXP 42
76286: PUSH
76287: LD_VAR 0 3
76291: ARRAY
76292: PPUSH
76293: LD_INT 25
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 3
76305: PUSH
76306: LD_INT 54
76308: PUSH
76309: EMPTY
76310: LIST
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PPUSH
76320: CALL_OW 72
76324: ST_TO_ADDR
// if tmp then
76325: LD_VAR 0 6
76329: IFFALSE 76335
// exit ;
76331: POP
76332: POP
76333: GO 76475
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76335: LD_ADDR_VAR 0 6
76339: PUSH
76340: LD_EXP 42
76344: PUSH
76345: LD_VAR 0 3
76349: ARRAY
76350: PPUSH
76351: LD_INT 2
76353: PUSH
76354: LD_INT 30
76356: PUSH
76357: LD_INT 4
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 30
76366: PUSH
76367: LD_INT 5
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: LIST
76378: PPUSH
76379: CALL_OW 72
76383: ST_TO_ADDR
// if not tmp then
76384: LD_VAR 0 6
76388: NOT
76389: IFFALSE 76395
// exit ;
76391: POP
76392: POP
76393: GO 76475
// for j in tmp do
76395: LD_ADDR_VAR 0 4
76399: PUSH
76400: LD_VAR 0 6
76404: PUSH
76405: FOR_IN
76406: IFFALSE 76465
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76408: LD_ADDR_VAR 0 7
76412: PUSH
76413: LD_VAR 0 4
76417: PPUSH
76418: CALL_OW 313
76422: PPUSH
76423: LD_INT 25
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PPUSH
76433: CALL_OW 72
76437: ST_TO_ADDR
// if units then
76438: LD_VAR 0 7
76442: IFFALSE 76463
// begin ComExitBuilding ( units [ 1 ] ) ;
76444: LD_VAR 0 7
76448: PUSH
76449: LD_INT 1
76451: ARRAY
76452: PPUSH
76453: CALL_OW 122
// exit ;
76457: POP
76458: POP
76459: POP
76460: POP
76461: GO 76475
// end ; end ;
76463: GO 76405
76465: POP
76466: POP
// end ; end ; exit ;
76467: POP
76468: POP
76469: GO 76475
// end ; end ;
76471: GO 75829
76473: POP
76474: POP
// end ;
76475: LD_VAR 0 2
76479: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76480: LD_INT 0
76482: PPUSH
76483: PPUSH
76484: PPUSH
76485: PPUSH
76486: PPUSH
76487: PPUSH
76488: PPUSH
// if not mc_bases or not skirmish then
76489: LD_EXP 42
76493: NOT
76494: PUSH
76495: LD_EXP 40
76499: NOT
76500: OR
76501: IFFALSE 76505
// exit ;
76503: GO 76736
// btype := GetBType ( building ) ;
76505: LD_ADDR_VAR 0 6
76509: PUSH
76510: LD_VAR 0 1
76514: PPUSH
76515: CALL_OW 266
76519: ST_TO_ADDR
// x := GetX ( building ) ;
76520: LD_ADDR_VAR 0 7
76524: PUSH
76525: LD_VAR 0 1
76529: PPUSH
76530: CALL_OW 250
76534: ST_TO_ADDR
// y := GetY ( building ) ;
76535: LD_ADDR_VAR 0 8
76539: PUSH
76540: LD_VAR 0 1
76544: PPUSH
76545: CALL_OW 251
76549: ST_TO_ADDR
// d := GetDir ( building ) ;
76550: LD_ADDR_VAR 0 9
76554: PUSH
76555: LD_VAR 0 1
76559: PPUSH
76560: CALL_OW 254
76564: ST_TO_ADDR
// for i = 1 to mc_bases do
76565: LD_ADDR_VAR 0 4
76569: PUSH
76570: DOUBLE
76571: LD_INT 1
76573: DEC
76574: ST_TO_ADDR
76575: LD_EXP 42
76579: PUSH
76580: FOR_TO
76581: IFFALSE 76734
// begin if not mc_build_list [ i ] then
76583: LD_EXP 47
76587: PUSH
76588: LD_VAR 0 4
76592: ARRAY
76593: NOT
76594: IFFALSE 76598
// continue ;
76596: GO 76580
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
76598: LD_VAR 0 6
76602: PUSH
76603: LD_VAR 0 7
76607: PUSH
76608: LD_VAR 0 8
76612: PUSH
76613: LD_VAR 0 9
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: LIST
76622: LIST
76623: PPUSH
76624: LD_EXP 47
76628: PUSH
76629: LD_VAR 0 4
76633: ARRAY
76634: PUSH
76635: LD_INT 1
76637: ARRAY
76638: PPUSH
76639: CALL 20919 0 2
76643: IFFALSE 76732
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
76645: LD_ADDR_EXP 47
76649: PUSH
76650: LD_EXP 47
76654: PPUSH
76655: LD_VAR 0 4
76659: PPUSH
76660: LD_EXP 47
76664: PUSH
76665: LD_VAR 0 4
76669: ARRAY
76670: PPUSH
76671: LD_INT 1
76673: PPUSH
76674: CALL_OW 3
76678: PPUSH
76679: CALL_OW 1
76683: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
76684: LD_ADDR_EXP 49
76688: PUSH
76689: LD_EXP 49
76693: PPUSH
76694: LD_VAR 0 4
76698: PUSH
76699: LD_EXP 49
76703: PUSH
76704: LD_VAR 0 4
76708: ARRAY
76709: PUSH
76710: LD_INT 1
76712: PLUS
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PPUSH
76718: LD_VAR 0 1
76722: PPUSH
76723: CALL 14750 0 3
76727: ST_TO_ADDR
// exit ;
76728: POP
76729: POP
76730: GO 76736
// end ; end ;
76732: GO 76580
76734: POP
76735: POP
// end ;
76736: LD_VAR 0 3
76740: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
76741: LD_INT 0
76743: PPUSH
76744: PPUSH
76745: PPUSH
// if not mc_bases or not skirmish then
76746: LD_EXP 42
76750: NOT
76751: PUSH
76752: LD_EXP 40
76756: NOT
76757: OR
76758: IFFALSE 76762
// exit ;
76760: GO 76952
// for i = 1 to mc_bases do
76762: LD_ADDR_VAR 0 4
76766: PUSH
76767: DOUBLE
76768: LD_INT 1
76770: DEC
76771: ST_TO_ADDR
76772: LD_EXP 42
76776: PUSH
76777: FOR_TO
76778: IFFALSE 76865
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
76780: LD_VAR 0 1
76784: PUSH
76785: LD_EXP 50
76789: PUSH
76790: LD_VAR 0 4
76794: ARRAY
76795: IN
76796: PUSH
76797: LD_VAR 0 1
76801: PUSH
76802: LD_EXP 51
76806: PUSH
76807: LD_VAR 0 4
76811: ARRAY
76812: IN
76813: NOT
76814: AND
76815: IFFALSE 76863
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76817: LD_ADDR_EXP 51
76821: PUSH
76822: LD_EXP 51
76826: PPUSH
76827: LD_VAR 0 4
76831: PUSH
76832: LD_EXP 51
76836: PUSH
76837: LD_VAR 0 4
76841: ARRAY
76842: PUSH
76843: LD_INT 1
76845: PLUS
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PPUSH
76851: LD_VAR 0 1
76855: PPUSH
76856: CALL 14750 0 3
76860: ST_TO_ADDR
// break ;
76861: GO 76865
// end ; end ;
76863: GO 76777
76865: POP
76866: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
76867: LD_VAR 0 1
76871: PPUSH
76872: CALL_OW 257
76876: PUSH
76877: LD_EXP 68
76881: IN
76882: PUSH
76883: LD_VAR 0 1
76887: PPUSH
76888: CALL_OW 266
76892: PUSH
76893: LD_INT 5
76895: EQUAL
76896: AND
76897: PUSH
76898: LD_VAR 0 2
76902: PPUSH
76903: CALL_OW 110
76907: PUSH
76908: LD_INT 18
76910: NONEQUAL
76911: AND
76912: IFFALSE 76952
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
76914: LD_VAR 0 2
76918: PPUSH
76919: CALL_OW 257
76923: PUSH
76924: LD_INT 5
76926: PUSH
76927: LD_INT 8
76929: PUSH
76930: LD_INT 9
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: IN
76938: IFFALSE 76952
// SetClass ( unit , 1 ) ;
76940: LD_VAR 0 2
76944: PPUSH
76945: LD_INT 1
76947: PPUSH
76948: CALL_OW 336
// end ;
76952: LD_VAR 0 3
76956: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
76957: LD_INT 0
76959: PPUSH
76960: PPUSH
// if not mc_bases or not skirmish then
76961: LD_EXP 42
76965: NOT
76966: PUSH
76967: LD_EXP 40
76971: NOT
76972: OR
76973: IFFALSE 76977
// exit ;
76975: GO 77093
// if GetLives ( abandoned_vehicle ) > 250 then
76977: LD_VAR 0 2
76981: PPUSH
76982: CALL_OW 256
76986: PUSH
76987: LD_INT 250
76989: GREATER
76990: IFFALSE 76994
// exit ;
76992: GO 77093
// for i = 1 to mc_bases do
76994: LD_ADDR_VAR 0 6
76998: PUSH
76999: DOUBLE
77000: LD_INT 1
77002: DEC
77003: ST_TO_ADDR
77004: LD_EXP 42
77008: PUSH
77009: FOR_TO
77010: IFFALSE 77091
// begin if driver in mc_bases [ i ] then
77012: LD_VAR 0 1
77016: PUSH
77017: LD_EXP 42
77021: PUSH
77022: LD_VAR 0 6
77026: ARRAY
77027: IN
77028: IFFALSE 77089
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77030: LD_VAR 0 1
77034: PPUSH
77035: LD_EXP 42
77039: PUSH
77040: LD_VAR 0 6
77044: ARRAY
77045: PPUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 30
77051: PUSH
77052: LD_INT 0
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 30
77061: PUSH
77062: LD_INT 1
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: LIST
77073: PPUSH
77074: CALL_OW 72
77078: PUSH
77079: LD_INT 1
77081: ARRAY
77082: PPUSH
77083: CALL 46616 0 2
// break ;
77087: GO 77091
// end ; end ;
77089: GO 77009
77091: POP
77092: POP
// end ; end_of_file
77093: LD_VAR 0 5
77097: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77098: LD_INT 0
77100: PPUSH
// ar_miner := 81 ;
77101: LD_ADDR_EXP 92
77105: PUSH
77106: LD_INT 81
77108: ST_TO_ADDR
// ar_crane := 88 ;
77109: LD_ADDR_EXP 91
77113: PUSH
77114: LD_INT 88
77116: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77117: LD_ADDR_EXP 86
77121: PUSH
77122: LD_INT 89
77124: ST_TO_ADDR
// us_hack := 99 ;
77125: LD_ADDR_EXP 87
77129: PUSH
77130: LD_INT 99
77132: ST_TO_ADDR
// us_artillery := 97 ;
77133: LD_ADDR_EXP 88
77137: PUSH
77138: LD_INT 97
77140: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77141: LD_ADDR_EXP 89
77145: PUSH
77146: LD_INT 91
77148: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77149: LD_ADDR_EXP 90
77153: PUSH
77154: LD_INT 92
77156: ST_TO_ADDR
// ru_radar := 98 ;
77157: LD_ADDR_EXP 85
77161: PUSH
77162: LD_INT 98
77164: ST_TO_ADDR
// tech_Artillery := 80 ;
77165: LD_ADDR_EXP 93
77169: PUSH
77170: LD_INT 80
77172: ST_TO_ADDR
// tech_RadMat := 81 ;
77173: LD_ADDR_EXP 94
77177: PUSH
77178: LD_INT 81
77180: ST_TO_ADDR
// tech_BasicTools := 82 ;
77181: LD_ADDR_EXP 95
77185: PUSH
77186: LD_INT 82
77188: ST_TO_ADDR
// tech_Cargo := 83 ;
77189: LD_ADDR_EXP 96
77193: PUSH
77194: LD_INT 83
77196: ST_TO_ADDR
// tech_Track := 84 ;
77197: LD_ADDR_EXP 97
77201: PUSH
77202: LD_INT 84
77204: ST_TO_ADDR
// tech_Crane := 85 ;
77205: LD_ADDR_EXP 98
77209: PUSH
77210: LD_INT 85
77212: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77213: LD_ADDR_EXP 99
77217: PUSH
77218: LD_INT 86
77220: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77221: LD_ADDR_EXP 100
77225: PUSH
77226: LD_INT 87
77228: ST_TO_ADDR
// end ;
77229: LD_VAR 0 1
77233: RET
// every 1 do
77234: GO 77236
77236: DISABLE
// InitGlobalVariables ; end_of_file
77237: CALL 77098 0 0
77241: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77242: LD_INT 0
77244: PPUSH
77245: PPUSH
77246: PPUSH
77247: PPUSH
77248: PPUSH
77249: PPUSH
77250: PPUSH
77251: PPUSH
77252: PPUSH
77253: PPUSH
77254: PPUSH
77255: PPUSH
77256: PPUSH
77257: PPUSH
77258: PPUSH
77259: PPUSH
77260: PPUSH
77261: PPUSH
77262: PPUSH
77263: PPUSH
77264: PPUSH
77265: PPUSH
77266: PPUSH
77267: PPUSH
77268: PPUSH
77269: PPUSH
77270: PPUSH
77271: PPUSH
77272: PPUSH
77273: PPUSH
77274: PPUSH
77275: PPUSH
77276: PPUSH
77277: PPUSH
// if not list then
77278: LD_VAR 0 1
77282: NOT
77283: IFFALSE 77287
// exit ;
77285: GO 81946
// base := list [ 1 ] ;
77287: LD_ADDR_VAR 0 3
77291: PUSH
77292: LD_VAR 0 1
77296: PUSH
77297: LD_INT 1
77299: ARRAY
77300: ST_TO_ADDR
// group := list [ 2 ] ;
77301: LD_ADDR_VAR 0 4
77305: PUSH
77306: LD_VAR 0 1
77310: PUSH
77311: LD_INT 2
77313: ARRAY
77314: ST_TO_ADDR
// path := list [ 3 ] ;
77315: LD_ADDR_VAR 0 5
77319: PUSH
77320: LD_VAR 0 1
77324: PUSH
77325: LD_INT 3
77327: ARRAY
77328: ST_TO_ADDR
// flags := list [ 4 ] ;
77329: LD_ADDR_VAR 0 6
77333: PUSH
77334: LD_VAR 0 1
77338: PUSH
77339: LD_INT 4
77341: ARRAY
77342: ST_TO_ADDR
// mined := [ ] ;
77343: LD_ADDR_VAR 0 27
77347: PUSH
77348: EMPTY
77349: ST_TO_ADDR
// bombed := [ ] ;
77350: LD_ADDR_VAR 0 28
77354: PUSH
77355: EMPTY
77356: ST_TO_ADDR
// healers := [ ] ;
77357: LD_ADDR_VAR 0 31
77361: PUSH
77362: EMPTY
77363: ST_TO_ADDR
// to_heal := [ ] ;
77364: LD_ADDR_VAR 0 30
77368: PUSH
77369: EMPTY
77370: ST_TO_ADDR
// repairs := [ ] ;
77371: LD_ADDR_VAR 0 33
77375: PUSH
77376: EMPTY
77377: ST_TO_ADDR
// to_repair := [ ] ;
77378: LD_ADDR_VAR 0 32
77382: PUSH
77383: EMPTY
77384: ST_TO_ADDR
// if not group or not path then
77385: LD_VAR 0 4
77389: NOT
77390: PUSH
77391: LD_VAR 0 5
77395: NOT
77396: OR
77397: IFFALSE 77401
// exit ;
77399: GO 81946
// side := GetSide ( group [ 1 ] ) ;
77401: LD_ADDR_VAR 0 35
77405: PUSH
77406: LD_VAR 0 4
77410: PUSH
77411: LD_INT 1
77413: ARRAY
77414: PPUSH
77415: CALL_OW 255
77419: ST_TO_ADDR
// if flags then
77420: LD_VAR 0 6
77424: IFFALSE 77568
// begin f_ignore_area := flags [ 1 ] ;
77426: LD_ADDR_VAR 0 17
77430: PUSH
77431: LD_VAR 0 6
77435: PUSH
77436: LD_INT 1
77438: ARRAY
77439: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77440: LD_ADDR_VAR 0 18
77444: PUSH
77445: LD_VAR 0 6
77449: PUSH
77450: LD_INT 2
77452: ARRAY
77453: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77454: LD_ADDR_VAR 0 19
77458: PUSH
77459: LD_VAR 0 6
77463: PUSH
77464: LD_INT 3
77466: ARRAY
77467: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77468: LD_ADDR_VAR 0 20
77472: PUSH
77473: LD_VAR 0 6
77477: PUSH
77478: LD_INT 4
77480: ARRAY
77481: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77482: LD_ADDR_VAR 0 21
77486: PUSH
77487: LD_VAR 0 6
77491: PUSH
77492: LD_INT 5
77494: ARRAY
77495: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77496: LD_ADDR_VAR 0 22
77500: PUSH
77501: LD_VAR 0 6
77505: PUSH
77506: LD_INT 6
77508: ARRAY
77509: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77510: LD_ADDR_VAR 0 23
77514: PUSH
77515: LD_VAR 0 6
77519: PUSH
77520: LD_INT 7
77522: ARRAY
77523: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77524: LD_ADDR_VAR 0 24
77528: PUSH
77529: LD_VAR 0 6
77533: PUSH
77534: LD_INT 8
77536: ARRAY
77537: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77538: LD_ADDR_VAR 0 25
77542: PUSH
77543: LD_VAR 0 6
77547: PUSH
77548: LD_INT 9
77550: ARRAY
77551: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77552: LD_ADDR_VAR 0 26
77556: PUSH
77557: LD_VAR 0 6
77561: PUSH
77562: LD_INT 10
77564: ARRAY
77565: ST_TO_ADDR
// end else
77566: GO 77648
// begin f_ignore_area := false ;
77568: LD_ADDR_VAR 0 17
77572: PUSH
77573: LD_INT 0
77575: ST_TO_ADDR
// f_capture := false ;
77576: LD_ADDR_VAR 0 18
77580: PUSH
77581: LD_INT 0
77583: ST_TO_ADDR
// f_ignore_civ := false ;
77584: LD_ADDR_VAR 0 19
77588: PUSH
77589: LD_INT 0
77591: ST_TO_ADDR
// f_murder := false ;
77592: LD_ADDR_VAR 0 20
77596: PUSH
77597: LD_INT 0
77599: ST_TO_ADDR
// f_mines := false ;
77600: LD_ADDR_VAR 0 21
77604: PUSH
77605: LD_INT 0
77607: ST_TO_ADDR
// f_repair := false ;
77608: LD_ADDR_VAR 0 22
77612: PUSH
77613: LD_INT 0
77615: ST_TO_ADDR
// f_heal := false ;
77616: LD_ADDR_VAR 0 23
77620: PUSH
77621: LD_INT 0
77623: ST_TO_ADDR
// f_spacetime := false ;
77624: LD_ADDR_VAR 0 24
77628: PUSH
77629: LD_INT 0
77631: ST_TO_ADDR
// f_attack_depot := false ;
77632: LD_ADDR_VAR 0 25
77636: PUSH
77637: LD_INT 0
77639: ST_TO_ADDR
// f_crawl := false ;
77640: LD_ADDR_VAR 0 26
77644: PUSH
77645: LD_INT 0
77647: ST_TO_ADDR
// end ; if f_heal then
77648: LD_VAR 0 23
77652: IFFALSE 77679
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77654: LD_ADDR_VAR 0 31
77658: PUSH
77659: LD_VAR 0 4
77663: PPUSH
77664: LD_INT 25
77666: PUSH
77667: LD_INT 4
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PPUSH
77674: CALL_OW 72
77678: ST_TO_ADDR
// if f_repair then
77679: LD_VAR 0 22
77683: IFFALSE 77710
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77685: LD_ADDR_VAR 0 33
77689: PUSH
77690: LD_VAR 0 4
77694: PPUSH
77695: LD_INT 25
77697: PUSH
77698: LD_INT 3
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PPUSH
77705: CALL_OW 72
77709: ST_TO_ADDR
// units_path := [ ] ;
77710: LD_ADDR_VAR 0 16
77714: PUSH
77715: EMPTY
77716: ST_TO_ADDR
// for i = 1 to group do
77717: LD_ADDR_VAR 0 7
77721: PUSH
77722: DOUBLE
77723: LD_INT 1
77725: DEC
77726: ST_TO_ADDR
77727: LD_VAR 0 4
77731: PUSH
77732: FOR_TO
77733: IFFALSE 77762
// units_path := Replace ( units_path , i , path ) ;
77735: LD_ADDR_VAR 0 16
77739: PUSH
77740: LD_VAR 0 16
77744: PPUSH
77745: LD_VAR 0 7
77749: PPUSH
77750: LD_VAR 0 5
77754: PPUSH
77755: CALL_OW 1
77759: ST_TO_ADDR
77760: GO 77732
77762: POP
77763: POP
// repeat for i = group downto 1 do
77764: LD_ADDR_VAR 0 7
77768: PUSH
77769: DOUBLE
77770: LD_VAR 0 4
77774: INC
77775: ST_TO_ADDR
77776: LD_INT 1
77778: PUSH
77779: FOR_DOWNTO
77780: IFFALSE 81902
// begin wait ( 5 ) ;
77782: LD_INT 5
77784: PPUSH
77785: CALL_OW 67
// tmp := [ ] ;
77789: LD_ADDR_VAR 0 14
77793: PUSH
77794: EMPTY
77795: ST_TO_ADDR
// attacking := false ;
77796: LD_ADDR_VAR 0 29
77800: PUSH
77801: LD_INT 0
77803: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77804: LD_VAR 0 4
77808: PUSH
77809: LD_VAR 0 7
77813: ARRAY
77814: PPUSH
77815: CALL_OW 301
77819: PUSH
77820: LD_VAR 0 4
77824: PUSH
77825: LD_VAR 0 7
77829: ARRAY
77830: NOT
77831: OR
77832: IFFALSE 77941
// begin if GetType ( group [ i ] ) = unit_human then
77834: LD_VAR 0 4
77838: PUSH
77839: LD_VAR 0 7
77843: ARRAY
77844: PPUSH
77845: CALL_OW 247
77849: PUSH
77850: LD_INT 1
77852: EQUAL
77853: IFFALSE 77899
// begin to_heal := to_heal diff group [ i ] ;
77855: LD_ADDR_VAR 0 30
77859: PUSH
77860: LD_VAR 0 30
77864: PUSH
77865: LD_VAR 0 4
77869: PUSH
77870: LD_VAR 0 7
77874: ARRAY
77875: DIFF
77876: ST_TO_ADDR
// healers := healers diff group [ i ] ;
77877: LD_ADDR_VAR 0 31
77881: PUSH
77882: LD_VAR 0 31
77886: PUSH
77887: LD_VAR 0 4
77891: PUSH
77892: LD_VAR 0 7
77896: ARRAY
77897: DIFF
77898: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
77899: LD_ADDR_VAR 0 4
77903: PUSH
77904: LD_VAR 0 4
77908: PPUSH
77909: LD_VAR 0 7
77913: PPUSH
77914: CALL_OW 3
77918: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
77919: LD_ADDR_VAR 0 16
77923: PUSH
77924: LD_VAR 0 16
77928: PPUSH
77929: LD_VAR 0 7
77933: PPUSH
77934: CALL_OW 3
77938: ST_TO_ADDR
// continue ;
77939: GO 77779
// end ; if f_repair then
77941: LD_VAR 0 22
77945: IFFALSE 78434
// begin if GetType ( group [ i ] ) = unit_vehicle then
77947: LD_VAR 0 4
77951: PUSH
77952: LD_VAR 0 7
77956: ARRAY
77957: PPUSH
77958: CALL_OW 247
77962: PUSH
77963: LD_INT 2
77965: EQUAL
77966: IFFALSE 78156
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
77968: LD_VAR 0 4
77972: PUSH
77973: LD_VAR 0 7
77977: ARRAY
77978: PPUSH
77979: CALL_OW 256
77983: PUSH
77984: LD_INT 700
77986: LESS
77987: PUSH
77988: LD_VAR 0 4
77992: PUSH
77993: LD_VAR 0 7
77997: ARRAY
77998: PUSH
77999: LD_VAR 0 32
78003: IN
78004: NOT
78005: AND
78006: IFFALSE 78030
// to_repair := to_repair union group [ i ] ;
78008: LD_ADDR_VAR 0 32
78012: PUSH
78013: LD_VAR 0 32
78017: PUSH
78018: LD_VAR 0 4
78022: PUSH
78023: LD_VAR 0 7
78027: ARRAY
78028: UNION
78029: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78030: LD_VAR 0 4
78034: PUSH
78035: LD_VAR 0 7
78039: ARRAY
78040: PPUSH
78041: CALL_OW 256
78045: PUSH
78046: LD_INT 1000
78048: EQUAL
78049: PUSH
78050: LD_VAR 0 4
78054: PUSH
78055: LD_VAR 0 7
78059: ARRAY
78060: PUSH
78061: LD_VAR 0 32
78065: IN
78066: AND
78067: IFFALSE 78091
// to_repair := to_repair diff group [ i ] ;
78069: LD_ADDR_VAR 0 32
78073: PUSH
78074: LD_VAR 0 32
78078: PUSH
78079: LD_VAR 0 4
78083: PUSH
78084: LD_VAR 0 7
78088: ARRAY
78089: DIFF
78090: ST_TO_ADDR
// if group [ i ] in to_repair then
78091: LD_VAR 0 4
78095: PUSH
78096: LD_VAR 0 7
78100: ARRAY
78101: PUSH
78102: LD_VAR 0 32
78106: IN
78107: IFFALSE 78154
// begin if not IsInArea ( group [ i ] , f_repair ) then
78109: LD_VAR 0 4
78113: PUSH
78114: LD_VAR 0 7
78118: ARRAY
78119: PPUSH
78120: LD_VAR 0 22
78124: PPUSH
78125: CALL_OW 308
78129: NOT
78130: IFFALSE 78152
// ComMoveToArea ( group [ i ] , f_repair ) ;
78132: LD_VAR 0 4
78136: PUSH
78137: LD_VAR 0 7
78141: ARRAY
78142: PPUSH
78143: LD_VAR 0 22
78147: PPUSH
78148: CALL_OW 113
// continue ;
78152: GO 77779
// end ; end else
78154: GO 78434
// if group [ i ] in repairs then
78156: LD_VAR 0 4
78160: PUSH
78161: LD_VAR 0 7
78165: ARRAY
78166: PUSH
78167: LD_VAR 0 33
78171: IN
78172: IFFALSE 78434
// begin if IsInUnit ( group [ i ] ) then
78174: LD_VAR 0 4
78178: PUSH
78179: LD_VAR 0 7
78183: ARRAY
78184: PPUSH
78185: CALL_OW 310
78189: IFFALSE 78257
// begin z := IsInUnit ( group [ i ] ) ;
78191: LD_ADDR_VAR 0 13
78195: PUSH
78196: LD_VAR 0 4
78200: PUSH
78201: LD_VAR 0 7
78205: ARRAY
78206: PPUSH
78207: CALL_OW 310
78211: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78212: LD_VAR 0 13
78216: PUSH
78217: LD_VAR 0 32
78221: IN
78222: PUSH
78223: LD_VAR 0 13
78227: PPUSH
78228: LD_VAR 0 22
78232: PPUSH
78233: CALL_OW 308
78237: AND
78238: IFFALSE 78255
// ComExitVehicle ( group [ i ] ) ;
78240: LD_VAR 0 4
78244: PUSH
78245: LD_VAR 0 7
78249: ARRAY
78250: PPUSH
78251: CALL_OW 121
// end else
78255: GO 78434
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78257: LD_ADDR_VAR 0 13
78261: PUSH
78262: LD_VAR 0 4
78266: PPUSH
78267: LD_INT 95
78269: PUSH
78270: LD_VAR 0 22
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 58
78281: PUSH
78282: EMPTY
78283: LIST
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PPUSH
78289: CALL_OW 72
78293: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78294: LD_VAR 0 4
78298: PUSH
78299: LD_VAR 0 7
78303: ARRAY
78304: PPUSH
78305: CALL_OW 314
78309: NOT
78310: IFFALSE 78432
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78312: LD_ADDR_VAR 0 10
78316: PUSH
78317: LD_VAR 0 13
78321: PPUSH
78322: LD_VAR 0 4
78326: PUSH
78327: LD_VAR 0 7
78331: ARRAY
78332: PPUSH
78333: CALL_OW 74
78337: ST_TO_ADDR
// if not x then
78338: LD_VAR 0 10
78342: NOT
78343: IFFALSE 78347
// continue ;
78345: GO 77779
// if GetLives ( x ) < 1000 then
78347: LD_VAR 0 10
78351: PPUSH
78352: CALL_OW 256
78356: PUSH
78357: LD_INT 1000
78359: LESS
78360: IFFALSE 78384
// ComRepairVehicle ( group [ i ] , x ) else
78362: LD_VAR 0 4
78366: PUSH
78367: LD_VAR 0 7
78371: ARRAY
78372: PPUSH
78373: LD_VAR 0 10
78377: PPUSH
78378: CALL_OW 129
78382: GO 78432
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78384: LD_VAR 0 23
78388: PUSH
78389: LD_VAR 0 4
78393: PUSH
78394: LD_VAR 0 7
78398: ARRAY
78399: PPUSH
78400: CALL_OW 256
78404: PUSH
78405: LD_INT 1000
78407: LESS
78408: AND
78409: NOT
78410: IFFALSE 78432
// ComEnterUnit ( group [ i ] , x ) ;
78412: LD_VAR 0 4
78416: PUSH
78417: LD_VAR 0 7
78421: ARRAY
78422: PPUSH
78423: LD_VAR 0 10
78427: PPUSH
78428: CALL_OW 120
// end ; continue ;
78432: GO 77779
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78434: LD_VAR 0 23
78438: PUSH
78439: LD_VAR 0 4
78443: PUSH
78444: LD_VAR 0 7
78448: ARRAY
78449: PPUSH
78450: CALL_OW 247
78454: PUSH
78455: LD_INT 1
78457: EQUAL
78458: AND
78459: IFFALSE 78937
// begin if group [ i ] in healers then
78461: LD_VAR 0 4
78465: PUSH
78466: LD_VAR 0 7
78470: ARRAY
78471: PUSH
78472: LD_VAR 0 31
78476: IN
78477: IFFALSE 78750
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78479: LD_VAR 0 4
78483: PUSH
78484: LD_VAR 0 7
78488: ARRAY
78489: PPUSH
78490: LD_VAR 0 23
78494: PPUSH
78495: CALL_OW 308
78499: NOT
78500: PUSH
78501: LD_VAR 0 4
78505: PUSH
78506: LD_VAR 0 7
78510: ARRAY
78511: PPUSH
78512: CALL_OW 314
78516: NOT
78517: AND
78518: IFFALSE 78542
// ComMoveToArea ( group [ i ] , f_heal ) else
78520: LD_VAR 0 4
78524: PUSH
78525: LD_VAR 0 7
78529: ARRAY
78530: PPUSH
78531: LD_VAR 0 23
78535: PPUSH
78536: CALL_OW 113
78540: GO 78748
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78542: LD_VAR 0 4
78546: PUSH
78547: LD_VAR 0 7
78551: ARRAY
78552: PPUSH
78553: CALL 43122 0 1
78557: PPUSH
78558: CALL_OW 256
78562: PUSH
78563: LD_INT 1000
78565: EQUAL
78566: IFFALSE 78585
// ComStop ( group [ i ] ) else
78568: LD_VAR 0 4
78572: PUSH
78573: LD_VAR 0 7
78577: ARRAY
78578: PPUSH
78579: CALL_OW 141
78583: GO 78748
// if not HasTask ( group [ i ] ) and to_heal then
78585: LD_VAR 0 4
78589: PUSH
78590: LD_VAR 0 7
78594: ARRAY
78595: PPUSH
78596: CALL_OW 314
78600: NOT
78601: PUSH
78602: LD_VAR 0 30
78606: AND
78607: IFFALSE 78748
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78609: LD_ADDR_VAR 0 13
78613: PUSH
78614: LD_VAR 0 30
78618: PPUSH
78619: LD_INT 3
78621: PUSH
78622: LD_INT 54
78624: PUSH
78625: EMPTY
78626: LIST
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PPUSH
78632: CALL_OW 72
78636: PPUSH
78637: LD_VAR 0 4
78641: PUSH
78642: LD_VAR 0 7
78646: ARRAY
78647: PPUSH
78648: CALL_OW 74
78652: ST_TO_ADDR
// if z then
78653: LD_VAR 0 13
78657: IFFALSE 78748
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78659: LD_INT 91
78661: PUSH
78662: LD_VAR 0 13
78666: PUSH
78667: LD_INT 10
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 81
78677: PUSH
78678: LD_VAR 0 13
78682: PPUSH
78683: CALL_OW 255
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PPUSH
78696: CALL_OW 69
78700: PUSH
78701: LD_INT 0
78703: EQUAL
78704: IFFALSE 78728
// ComHeal ( group [ i ] , z ) else
78706: LD_VAR 0 4
78710: PUSH
78711: LD_VAR 0 7
78715: ARRAY
78716: PPUSH
78717: LD_VAR 0 13
78721: PPUSH
78722: CALL_OW 128
78726: GO 78748
// ComMoveToArea ( group [ i ] , f_heal ) ;
78728: LD_VAR 0 4
78732: PUSH
78733: LD_VAR 0 7
78737: ARRAY
78738: PPUSH
78739: LD_VAR 0 23
78743: PPUSH
78744: CALL_OW 113
// end ; continue ;
78748: GO 77779
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78750: LD_VAR 0 4
78754: PUSH
78755: LD_VAR 0 7
78759: ARRAY
78760: PPUSH
78761: CALL_OW 256
78765: PUSH
78766: LD_INT 700
78768: LESS
78769: PUSH
78770: LD_VAR 0 4
78774: PUSH
78775: LD_VAR 0 7
78779: ARRAY
78780: PUSH
78781: LD_VAR 0 30
78785: IN
78786: NOT
78787: AND
78788: IFFALSE 78812
// to_heal := to_heal union group [ i ] ;
78790: LD_ADDR_VAR 0 30
78794: PUSH
78795: LD_VAR 0 30
78799: PUSH
78800: LD_VAR 0 4
78804: PUSH
78805: LD_VAR 0 7
78809: ARRAY
78810: UNION
78811: ST_TO_ADDR
// if group [ i ] in to_heal then
78812: LD_VAR 0 4
78816: PUSH
78817: LD_VAR 0 7
78821: ARRAY
78822: PUSH
78823: LD_VAR 0 30
78827: IN
78828: IFFALSE 78937
// begin if GetLives ( group [ i ] ) = 1000 then
78830: LD_VAR 0 4
78834: PUSH
78835: LD_VAR 0 7
78839: ARRAY
78840: PPUSH
78841: CALL_OW 256
78845: PUSH
78846: LD_INT 1000
78848: EQUAL
78849: IFFALSE 78875
// to_heal := to_heal diff group [ i ] else
78851: LD_ADDR_VAR 0 30
78855: PUSH
78856: LD_VAR 0 30
78860: PUSH
78861: LD_VAR 0 4
78865: PUSH
78866: LD_VAR 0 7
78870: ARRAY
78871: DIFF
78872: ST_TO_ADDR
78873: GO 78937
// begin if not IsInArea ( group [ i ] , to_heal ) then
78875: LD_VAR 0 4
78879: PUSH
78880: LD_VAR 0 7
78884: ARRAY
78885: PPUSH
78886: LD_VAR 0 30
78890: PPUSH
78891: CALL_OW 308
78895: NOT
78896: IFFALSE 78920
// ComMoveToArea ( group [ i ] , f_heal ) else
78898: LD_VAR 0 4
78902: PUSH
78903: LD_VAR 0 7
78907: ARRAY
78908: PPUSH
78909: LD_VAR 0 23
78913: PPUSH
78914: CALL_OW 113
78918: GO 78935
// ComHold ( group [ i ] ) ;
78920: LD_VAR 0 4
78924: PUSH
78925: LD_VAR 0 7
78929: ARRAY
78930: PPUSH
78931: CALL_OW 140
// continue ;
78935: GO 77779
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
78937: LD_VAR 0 4
78941: PUSH
78942: LD_VAR 0 7
78946: ARRAY
78947: PPUSH
78948: LD_INT 10
78950: PPUSH
78951: CALL 41542 0 2
78955: NOT
78956: PUSH
78957: LD_VAR 0 16
78961: PUSH
78962: LD_VAR 0 7
78966: ARRAY
78967: PUSH
78968: EMPTY
78969: EQUAL
78970: NOT
78971: AND
78972: IFFALSE 79238
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
78974: LD_VAR 0 4
78978: PUSH
78979: LD_VAR 0 7
78983: ARRAY
78984: PPUSH
78985: CALL_OW 262
78989: PUSH
78990: LD_INT 1
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: IN
79000: IFFALSE 79041
// if GetFuel ( group [ i ] ) < 10 then
79002: LD_VAR 0 4
79006: PUSH
79007: LD_VAR 0 7
79011: ARRAY
79012: PPUSH
79013: CALL_OW 261
79017: PUSH
79018: LD_INT 10
79020: LESS
79021: IFFALSE 79041
// SetFuel ( group [ i ] , 12 ) ;
79023: LD_VAR 0 4
79027: PUSH
79028: LD_VAR 0 7
79032: ARRAY
79033: PPUSH
79034: LD_INT 12
79036: PPUSH
79037: CALL_OW 240
// if units_path [ i ] then
79041: LD_VAR 0 16
79045: PUSH
79046: LD_VAR 0 7
79050: ARRAY
79051: IFFALSE 79236
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79053: LD_VAR 0 4
79057: PUSH
79058: LD_VAR 0 7
79062: ARRAY
79063: PPUSH
79064: LD_VAR 0 16
79068: PUSH
79069: LD_VAR 0 7
79073: ARRAY
79074: PUSH
79075: LD_INT 1
79077: ARRAY
79078: PUSH
79079: LD_INT 1
79081: ARRAY
79082: PPUSH
79083: LD_VAR 0 16
79087: PUSH
79088: LD_VAR 0 7
79092: ARRAY
79093: PUSH
79094: LD_INT 1
79096: ARRAY
79097: PUSH
79098: LD_INT 2
79100: ARRAY
79101: PPUSH
79102: CALL_OW 297
79106: PUSH
79107: LD_INT 6
79109: GREATER
79110: IFFALSE 79185
// begin if not HasTask ( group [ i ] ) then
79112: LD_VAR 0 4
79116: PUSH
79117: LD_VAR 0 7
79121: ARRAY
79122: PPUSH
79123: CALL_OW 314
79127: NOT
79128: IFFALSE 79183
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79130: LD_VAR 0 4
79134: PUSH
79135: LD_VAR 0 7
79139: ARRAY
79140: PPUSH
79141: LD_VAR 0 16
79145: PUSH
79146: LD_VAR 0 7
79150: ARRAY
79151: PUSH
79152: LD_INT 1
79154: ARRAY
79155: PUSH
79156: LD_INT 1
79158: ARRAY
79159: PPUSH
79160: LD_VAR 0 16
79164: PUSH
79165: LD_VAR 0 7
79169: ARRAY
79170: PUSH
79171: LD_INT 1
79173: ARRAY
79174: PUSH
79175: LD_INT 2
79177: ARRAY
79178: PPUSH
79179: CALL_OW 114
// end else
79183: GO 79236
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79185: LD_ADDR_VAR 0 15
79189: PUSH
79190: LD_VAR 0 16
79194: PUSH
79195: LD_VAR 0 7
79199: ARRAY
79200: PPUSH
79201: LD_INT 1
79203: PPUSH
79204: CALL_OW 3
79208: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79209: LD_ADDR_VAR 0 16
79213: PUSH
79214: LD_VAR 0 16
79218: PPUSH
79219: LD_VAR 0 7
79223: PPUSH
79224: LD_VAR 0 15
79228: PPUSH
79229: CALL_OW 1
79233: ST_TO_ADDR
// continue ;
79234: GO 77779
// end ; end ; end else
79236: GO 81900
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79238: LD_ADDR_VAR 0 14
79242: PUSH
79243: LD_INT 81
79245: PUSH
79246: LD_VAR 0 4
79250: PUSH
79251: LD_VAR 0 7
79255: ARRAY
79256: PPUSH
79257: CALL_OW 255
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PPUSH
79266: CALL_OW 69
79270: ST_TO_ADDR
// if not tmp then
79271: LD_VAR 0 14
79275: NOT
79276: IFFALSE 79280
// continue ;
79278: GO 77779
// if f_ignore_area then
79280: LD_VAR 0 17
79284: IFFALSE 79372
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79286: LD_ADDR_VAR 0 15
79290: PUSH
79291: LD_VAR 0 14
79295: PPUSH
79296: LD_INT 3
79298: PUSH
79299: LD_INT 92
79301: PUSH
79302: LD_VAR 0 17
79306: PUSH
79307: LD_INT 1
79309: ARRAY
79310: PUSH
79311: LD_VAR 0 17
79315: PUSH
79316: LD_INT 2
79318: ARRAY
79319: PUSH
79320: LD_VAR 0 17
79324: PUSH
79325: LD_INT 3
79327: ARRAY
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PPUSH
79339: CALL_OW 72
79343: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79344: LD_VAR 0 14
79348: PUSH
79349: LD_VAR 0 15
79353: DIFF
79354: IFFALSE 79372
// tmp := tmp diff tmp2 ;
79356: LD_ADDR_VAR 0 14
79360: PUSH
79361: LD_VAR 0 14
79365: PUSH
79366: LD_VAR 0 15
79370: DIFF
79371: ST_TO_ADDR
// end ; if not f_murder then
79372: LD_VAR 0 20
79376: NOT
79377: IFFALSE 79435
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79379: LD_ADDR_VAR 0 15
79383: PUSH
79384: LD_VAR 0 14
79388: PPUSH
79389: LD_INT 3
79391: PUSH
79392: LD_INT 50
79394: PUSH
79395: EMPTY
79396: LIST
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PPUSH
79402: CALL_OW 72
79406: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79407: LD_VAR 0 14
79411: PUSH
79412: LD_VAR 0 15
79416: DIFF
79417: IFFALSE 79435
// tmp := tmp diff tmp2 ;
79419: LD_ADDR_VAR 0 14
79423: PUSH
79424: LD_VAR 0 14
79428: PUSH
79429: LD_VAR 0 15
79433: DIFF
79434: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79435: LD_ADDR_VAR 0 14
79439: PUSH
79440: LD_VAR 0 4
79444: PUSH
79445: LD_VAR 0 7
79449: ARRAY
79450: PPUSH
79451: LD_VAR 0 14
79455: PPUSH
79456: LD_INT 1
79458: PPUSH
79459: LD_INT 1
79461: PPUSH
79462: CALL 15185 0 4
79466: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79467: LD_VAR 0 4
79471: PUSH
79472: LD_VAR 0 7
79476: ARRAY
79477: PPUSH
79478: CALL_OW 257
79482: PUSH
79483: LD_INT 1
79485: EQUAL
79486: IFFALSE 79934
// begin if WantPlant ( group [ i ] ) then
79488: LD_VAR 0 4
79492: PUSH
79493: LD_VAR 0 7
79497: ARRAY
79498: PPUSH
79499: CALL 14686 0 1
79503: IFFALSE 79507
// continue ;
79505: GO 77779
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79507: LD_VAR 0 18
79511: PUSH
79512: LD_VAR 0 4
79516: PUSH
79517: LD_VAR 0 7
79521: ARRAY
79522: PPUSH
79523: CALL_OW 310
79527: NOT
79528: AND
79529: PUSH
79530: LD_VAR 0 14
79534: PUSH
79535: LD_INT 1
79537: ARRAY
79538: PUSH
79539: LD_VAR 0 14
79543: PPUSH
79544: LD_INT 21
79546: PUSH
79547: LD_INT 2
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 58
79556: PUSH
79557: EMPTY
79558: LIST
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PPUSH
79564: CALL_OW 72
79568: IN
79569: AND
79570: IFFALSE 79606
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79572: LD_VAR 0 4
79576: PUSH
79577: LD_VAR 0 7
79581: ARRAY
79582: PPUSH
79583: LD_VAR 0 14
79587: PUSH
79588: LD_INT 1
79590: ARRAY
79591: PPUSH
79592: CALL_OW 120
// attacking := true ;
79596: LD_ADDR_VAR 0 29
79600: PUSH
79601: LD_INT 1
79603: ST_TO_ADDR
// continue ;
79604: GO 77779
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79606: LD_VAR 0 26
79610: PUSH
79611: LD_VAR 0 4
79615: PUSH
79616: LD_VAR 0 7
79620: ARRAY
79621: PPUSH
79622: CALL_OW 257
79626: PUSH
79627: LD_INT 1
79629: EQUAL
79630: AND
79631: PUSH
79632: LD_VAR 0 4
79636: PUSH
79637: LD_VAR 0 7
79641: ARRAY
79642: PPUSH
79643: CALL_OW 256
79647: PUSH
79648: LD_INT 800
79650: LESS
79651: AND
79652: PUSH
79653: LD_VAR 0 4
79657: PUSH
79658: LD_VAR 0 7
79662: ARRAY
79663: PPUSH
79664: CALL_OW 318
79668: NOT
79669: AND
79670: IFFALSE 79687
// ComCrawl ( group [ i ] ) ;
79672: LD_VAR 0 4
79676: PUSH
79677: LD_VAR 0 7
79681: ARRAY
79682: PPUSH
79683: CALL_OW 137
// if f_mines then
79687: LD_VAR 0 21
79691: IFFALSE 79934
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79693: LD_VAR 0 14
79697: PUSH
79698: LD_INT 1
79700: ARRAY
79701: PPUSH
79702: CALL_OW 247
79706: PUSH
79707: LD_INT 3
79709: EQUAL
79710: PUSH
79711: LD_VAR 0 14
79715: PUSH
79716: LD_INT 1
79718: ARRAY
79719: PUSH
79720: LD_VAR 0 27
79724: IN
79725: NOT
79726: AND
79727: IFFALSE 79934
// begin x := GetX ( tmp [ 1 ] ) ;
79729: LD_ADDR_VAR 0 10
79733: PUSH
79734: LD_VAR 0 14
79738: PUSH
79739: LD_INT 1
79741: ARRAY
79742: PPUSH
79743: CALL_OW 250
79747: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79748: LD_ADDR_VAR 0 11
79752: PUSH
79753: LD_VAR 0 14
79757: PUSH
79758: LD_INT 1
79760: ARRAY
79761: PPUSH
79762: CALL_OW 251
79766: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79767: LD_ADDR_VAR 0 12
79771: PUSH
79772: LD_VAR 0 4
79776: PUSH
79777: LD_VAR 0 7
79781: ARRAY
79782: PPUSH
79783: CALL 41627 0 1
79787: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79788: LD_VAR 0 4
79792: PUSH
79793: LD_VAR 0 7
79797: ARRAY
79798: PPUSH
79799: LD_VAR 0 10
79803: PPUSH
79804: LD_VAR 0 11
79808: PPUSH
79809: LD_VAR 0 14
79813: PUSH
79814: LD_INT 1
79816: ARRAY
79817: PPUSH
79818: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79822: LD_VAR 0 4
79826: PUSH
79827: LD_VAR 0 7
79831: ARRAY
79832: PPUSH
79833: LD_VAR 0 10
79837: PPUSH
79838: LD_VAR 0 12
79842: PPUSH
79843: LD_INT 7
79845: PPUSH
79846: CALL_OW 272
79850: PPUSH
79851: LD_VAR 0 11
79855: PPUSH
79856: LD_VAR 0 12
79860: PPUSH
79861: LD_INT 7
79863: PPUSH
79864: CALL_OW 273
79868: PPUSH
79869: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
79873: LD_VAR 0 4
79877: PUSH
79878: LD_VAR 0 7
79882: ARRAY
79883: PPUSH
79884: LD_INT 71
79886: PPUSH
79887: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
79891: LD_ADDR_VAR 0 27
79895: PUSH
79896: LD_VAR 0 27
79900: PPUSH
79901: LD_VAR 0 27
79905: PUSH
79906: LD_INT 1
79908: PLUS
79909: PPUSH
79910: LD_VAR 0 14
79914: PUSH
79915: LD_INT 1
79917: ARRAY
79918: PPUSH
79919: CALL_OW 1
79923: ST_TO_ADDR
// attacking := true ;
79924: LD_ADDR_VAR 0 29
79928: PUSH
79929: LD_INT 1
79931: ST_TO_ADDR
// continue ;
79932: GO 77779
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
79934: LD_VAR 0 4
79938: PUSH
79939: LD_VAR 0 7
79943: ARRAY
79944: PPUSH
79945: CALL_OW 257
79949: PUSH
79950: LD_INT 17
79952: EQUAL
79953: PUSH
79954: LD_VAR 0 4
79958: PUSH
79959: LD_VAR 0 7
79963: ARRAY
79964: PPUSH
79965: CALL_OW 110
79969: PUSH
79970: LD_INT 71
79972: EQUAL
79973: NOT
79974: AND
79975: IFFALSE 80121
// begin attacking := false ;
79977: LD_ADDR_VAR 0 29
79981: PUSH
79982: LD_INT 0
79984: ST_TO_ADDR
// k := 5 ;
79985: LD_ADDR_VAR 0 9
79989: PUSH
79990: LD_INT 5
79992: ST_TO_ADDR
// if tmp < k then
79993: LD_VAR 0 14
79997: PUSH
79998: LD_VAR 0 9
80002: LESS
80003: IFFALSE 80015
// k := tmp ;
80005: LD_ADDR_VAR 0 9
80009: PUSH
80010: LD_VAR 0 14
80014: ST_TO_ADDR
// for j = 1 to k do
80015: LD_ADDR_VAR 0 8
80019: PUSH
80020: DOUBLE
80021: LD_INT 1
80023: DEC
80024: ST_TO_ADDR
80025: LD_VAR 0 9
80029: PUSH
80030: FOR_TO
80031: IFFALSE 80119
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80033: LD_VAR 0 14
80037: PUSH
80038: LD_VAR 0 8
80042: ARRAY
80043: PUSH
80044: LD_VAR 0 14
80048: PPUSH
80049: LD_INT 58
80051: PUSH
80052: EMPTY
80053: LIST
80054: PPUSH
80055: CALL_OW 72
80059: IN
80060: NOT
80061: IFFALSE 80117
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80063: LD_VAR 0 4
80067: PUSH
80068: LD_VAR 0 7
80072: ARRAY
80073: PPUSH
80074: LD_VAR 0 14
80078: PUSH
80079: LD_VAR 0 8
80083: ARRAY
80084: PPUSH
80085: CALL_OW 115
// attacking := true ;
80089: LD_ADDR_VAR 0 29
80093: PUSH
80094: LD_INT 1
80096: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80097: LD_VAR 0 4
80101: PUSH
80102: LD_VAR 0 7
80106: ARRAY
80107: PPUSH
80108: LD_INT 71
80110: PPUSH
80111: CALL_OW 109
// continue ;
80115: GO 80030
// end ; end ;
80117: GO 80030
80119: POP
80120: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80121: LD_VAR 0 4
80125: PUSH
80126: LD_VAR 0 7
80130: ARRAY
80131: PPUSH
80132: CALL_OW 257
80136: PUSH
80137: LD_INT 8
80139: EQUAL
80140: PUSH
80141: LD_VAR 0 4
80145: PUSH
80146: LD_VAR 0 7
80150: ARRAY
80151: PPUSH
80152: CALL_OW 264
80156: PUSH
80157: LD_INT 28
80159: PUSH
80160: LD_INT 45
80162: PUSH
80163: LD_INT 7
80165: PUSH
80166: LD_INT 47
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: IN
80175: OR
80176: IFFALSE 80432
// begin attacking := false ;
80178: LD_ADDR_VAR 0 29
80182: PUSH
80183: LD_INT 0
80185: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80186: LD_VAR 0 14
80190: PUSH
80191: LD_INT 1
80193: ARRAY
80194: PPUSH
80195: CALL_OW 266
80199: PUSH
80200: LD_INT 32
80202: PUSH
80203: LD_INT 31
80205: PUSH
80206: LD_INT 33
80208: PUSH
80209: LD_INT 4
80211: PUSH
80212: LD_INT 5
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: IN
80222: IFFALSE 80408
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80224: LD_ADDR_VAR 0 9
80228: PUSH
80229: LD_VAR 0 14
80233: PUSH
80234: LD_INT 1
80236: ARRAY
80237: PPUSH
80238: CALL_OW 266
80242: PPUSH
80243: LD_VAR 0 14
80247: PUSH
80248: LD_INT 1
80250: ARRAY
80251: PPUSH
80252: CALL_OW 250
80256: PPUSH
80257: LD_VAR 0 14
80261: PUSH
80262: LD_INT 1
80264: ARRAY
80265: PPUSH
80266: CALL_OW 251
80270: PPUSH
80271: LD_VAR 0 14
80275: PUSH
80276: LD_INT 1
80278: ARRAY
80279: PPUSH
80280: CALL_OW 254
80284: PPUSH
80285: LD_VAR 0 14
80289: PUSH
80290: LD_INT 1
80292: ARRAY
80293: PPUSH
80294: CALL_OW 248
80298: PPUSH
80299: LD_INT 0
80301: PPUSH
80302: CALL 22997 0 6
80306: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80307: LD_ADDR_VAR 0 8
80311: PUSH
80312: LD_VAR 0 4
80316: PUSH
80317: LD_VAR 0 7
80321: ARRAY
80322: PPUSH
80323: LD_VAR 0 9
80327: PPUSH
80328: CALL 41667 0 2
80332: ST_TO_ADDR
// if j then
80333: LD_VAR 0 8
80337: IFFALSE 80406
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80339: LD_VAR 0 8
80343: PUSH
80344: LD_INT 1
80346: ARRAY
80347: PPUSH
80348: LD_VAR 0 8
80352: PUSH
80353: LD_INT 2
80355: ARRAY
80356: PPUSH
80357: CALL_OW 488
80361: IFFALSE 80406
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80363: LD_VAR 0 4
80367: PUSH
80368: LD_VAR 0 7
80372: ARRAY
80373: PPUSH
80374: LD_VAR 0 8
80378: PUSH
80379: LD_INT 1
80381: ARRAY
80382: PPUSH
80383: LD_VAR 0 8
80387: PUSH
80388: LD_INT 2
80390: ARRAY
80391: PPUSH
80392: CALL_OW 116
// attacking := true ;
80396: LD_ADDR_VAR 0 29
80400: PUSH
80401: LD_INT 1
80403: ST_TO_ADDR
// continue ;
80404: GO 77779
// end ; end else
80406: GO 80432
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80408: LD_VAR 0 4
80412: PUSH
80413: LD_VAR 0 7
80417: ARRAY
80418: PPUSH
80419: LD_VAR 0 14
80423: PUSH
80424: LD_INT 1
80426: ARRAY
80427: PPUSH
80428: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80432: LD_VAR 0 4
80436: PUSH
80437: LD_VAR 0 7
80441: ARRAY
80442: PPUSH
80443: CALL_OW 265
80447: PUSH
80448: LD_INT 11
80450: EQUAL
80451: IFFALSE 80729
// begin k := 10 ;
80453: LD_ADDR_VAR 0 9
80457: PUSH
80458: LD_INT 10
80460: ST_TO_ADDR
// x := 0 ;
80461: LD_ADDR_VAR 0 10
80465: PUSH
80466: LD_INT 0
80468: ST_TO_ADDR
// if tmp < k then
80469: LD_VAR 0 14
80473: PUSH
80474: LD_VAR 0 9
80478: LESS
80479: IFFALSE 80491
// k := tmp ;
80481: LD_ADDR_VAR 0 9
80485: PUSH
80486: LD_VAR 0 14
80490: ST_TO_ADDR
// for j = k downto 1 do
80491: LD_ADDR_VAR 0 8
80495: PUSH
80496: DOUBLE
80497: LD_VAR 0 9
80501: INC
80502: ST_TO_ADDR
80503: LD_INT 1
80505: PUSH
80506: FOR_DOWNTO
80507: IFFALSE 80582
// begin if GetType ( tmp [ j ] ) = unit_human then
80509: LD_VAR 0 14
80513: PUSH
80514: LD_VAR 0 8
80518: ARRAY
80519: PPUSH
80520: CALL_OW 247
80524: PUSH
80525: LD_INT 1
80527: EQUAL
80528: IFFALSE 80580
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80530: LD_VAR 0 4
80534: PUSH
80535: LD_VAR 0 7
80539: ARRAY
80540: PPUSH
80541: LD_VAR 0 14
80545: PUSH
80546: LD_VAR 0 8
80550: ARRAY
80551: PPUSH
80552: CALL 41938 0 2
// x := tmp [ j ] ;
80556: LD_ADDR_VAR 0 10
80560: PUSH
80561: LD_VAR 0 14
80565: PUSH
80566: LD_VAR 0 8
80570: ARRAY
80571: ST_TO_ADDR
// attacking := true ;
80572: LD_ADDR_VAR 0 29
80576: PUSH
80577: LD_INT 1
80579: ST_TO_ADDR
// end ; end ;
80580: GO 80506
80582: POP
80583: POP
// if not x then
80584: LD_VAR 0 10
80588: NOT
80589: IFFALSE 80729
// begin attacking := true ;
80591: LD_ADDR_VAR 0 29
80595: PUSH
80596: LD_INT 1
80598: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80599: LD_VAR 0 4
80603: PUSH
80604: LD_VAR 0 7
80608: ARRAY
80609: PPUSH
80610: CALL_OW 250
80614: PPUSH
80615: LD_VAR 0 4
80619: PUSH
80620: LD_VAR 0 7
80624: ARRAY
80625: PPUSH
80626: CALL_OW 251
80630: PPUSH
80631: CALL_OW 546
80635: PUSH
80636: LD_INT 2
80638: ARRAY
80639: PUSH
80640: LD_VAR 0 14
80644: PUSH
80645: LD_INT 1
80647: ARRAY
80648: PPUSH
80649: CALL_OW 250
80653: PPUSH
80654: LD_VAR 0 14
80658: PUSH
80659: LD_INT 1
80661: ARRAY
80662: PPUSH
80663: CALL_OW 251
80667: PPUSH
80668: CALL_OW 546
80672: PUSH
80673: LD_INT 2
80675: ARRAY
80676: EQUAL
80677: IFFALSE 80705
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80679: LD_VAR 0 4
80683: PUSH
80684: LD_VAR 0 7
80688: ARRAY
80689: PPUSH
80690: LD_VAR 0 14
80694: PUSH
80695: LD_INT 1
80697: ARRAY
80698: PPUSH
80699: CALL 41938 0 2
80703: GO 80729
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80705: LD_VAR 0 4
80709: PUSH
80710: LD_VAR 0 7
80714: ARRAY
80715: PPUSH
80716: LD_VAR 0 14
80720: PUSH
80721: LD_INT 1
80723: ARRAY
80724: PPUSH
80725: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80729: LD_VAR 0 4
80733: PUSH
80734: LD_VAR 0 7
80738: ARRAY
80739: PPUSH
80740: CALL_OW 264
80744: PUSH
80745: LD_INT 29
80747: EQUAL
80748: IFFALSE 81114
// begin if WantsToAttack ( group [ i ] ) in bombed then
80750: LD_VAR 0 4
80754: PUSH
80755: LD_VAR 0 7
80759: ARRAY
80760: PPUSH
80761: CALL_OW 319
80765: PUSH
80766: LD_VAR 0 28
80770: IN
80771: IFFALSE 80775
// continue ;
80773: GO 77779
// k := 8 ;
80775: LD_ADDR_VAR 0 9
80779: PUSH
80780: LD_INT 8
80782: ST_TO_ADDR
// x := 0 ;
80783: LD_ADDR_VAR 0 10
80787: PUSH
80788: LD_INT 0
80790: ST_TO_ADDR
// if tmp < k then
80791: LD_VAR 0 14
80795: PUSH
80796: LD_VAR 0 9
80800: LESS
80801: IFFALSE 80813
// k := tmp ;
80803: LD_ADDR_VAR 0 9
80807: PUSH
80808: LD_VAR 0 14
80812: ST_TO_ADDR
// for j = 1 to k do
80813: LD_ADDR_VAR 0 8
80817: PUSH
80818: DOUBLE
80819: LD_INT 1
80821: DEC
80822: ST_TO_ADDR
80823: LD_VAR 0 9
80827: PUSH
80828: FOR_TO
80829: IFFALSE 80961
// begin if GetType ( tmp [ j ] ) = unit_building then
80831: LD_VAR 0 14
80835: PUSH
80836: LD_VAR 0 8
80840: ARRAY
80841: PPUSH
80842: CALL_OW 247
80846: PUSH
80847: LD_INT 3
80849: EQUAL
80850: IFFALSE 80959
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80852: LD_VAR 0 14
80856: PUSH
80857: LD_VAR 0 8
80861: ARRAY
80862: PUSH
80863: LD_VAR 0 28
80867: IN
80868: NOT
80869: PUSH
80870: LD_VAR 0 14
80874: PUSH
80875: LD_VAR 0 8
80879: ARRAY
80880: PPUSH
80881: CALL_OW 313
80885: AND
80886: IFFALSE 80959
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80888: LD_VAR 0 4
80892: PUSH
80893: LD_VAR 0 7
80897: ARRAY
80898: PPUSH
80899: LD_VAR 0 14
80903: PUSH
80904: LD_VAR 0 8
80908: ARRAY
80909: PPUSH
80910: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
80914: LD_ADDR_VAR 0 28
80918: PUSH
80919: LD_VAR 0 28
80923: PPUSH
80924: LD_VAR 0 28
80928: PUSH
80929: LD_INT 1
80931: PLUS
80932: PPUSH
80933: LD_VAR 0 14
80937: PUSH
80938: LD_VAR 0 8
80942: ARRAY
80943: PPUSH
80944: CALL_OW 1
80948: ST_TO_ADDR
// attacking := true ;
80949: LD_ADDR_VAR 0 29
80953: PUSH
80954: LD_INT 1
80956: ST_TO_ADDR
// break ;
80957: GO 80961
// end ; end ;
80959: GO 80828
80961: POP
80962: POP
// if not attacking and f_attack_depot then
80963: LD_VAR 0 29
80967: NOT
80968: PUSH
80969: LD_VAR 0 25
80973: AND
80974: IFFALSE 81069
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80976: LD_ADDR_VAR 0 13
80980: PUSH
80981: LD_VAR 0 14
80985: PPUSH
80986: LD_INT 2
80988: PUSH
80989: LD_INT 30
80991: PUSH
80992: LD_INT 0
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 30
81001: PUSH
81002: LD_INT 1
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: LIST
81013: PPUSH
81014: CALL_OW 72
81018: ST_TO_ADDR
// if z then
81019: LD_VAR 0 13
81023: IFFALSE 81069
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81025: LD_VAR 0 4
81029: PUSH
81030: LD_VAR 0 7
81034: ARRAY
81035: PPUSH
81036: LD_VAR 0 13
81040: PPUSH
81041: LD_VAR 0 4
81045: PUSH
81046: LD_VAR 0 7
81050: ARRAY
81051: PPUSH
81052: CALL_OW 74
81056: PPUSH
81057: CALL_OW 115
// attacking := true ;
81061: LD_ADDR_VAR 0 29
81065: PUSH
81066: LD_INT 1
81068: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81069: LD_VAR 0 4
81073: PUSH
81074: LD_VAR 0 7
81078: ARRAY
81079: PPUSH
81080: CALL_OW 256
81084: PUSH
81085: LD_INT 500
81087: LESS
81088: IFFALSE 81114
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81090: LD_VAR 0 4
81094: PUSH
81095: LD_VAR 0 7
81099: ARRAY
81100: PPUSH
81101: LD_VAR 0 14
81105: PUSH
81106: LD_INT 1
81108: ARRAY
81109: PPUSH
81110: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81114: LD_VAR 0 4
81118: PUSH
81119: LD_VAR 0 7
81123: ARRAY
81124: PPUSH
81125: CALL_OW 264
81129: PUSH
81130: LD_INT 49
81132: EQUAL
81133: IFFALSE 81254
// begin if not HasTask ( group [ i ] ) then
81135: LD_VAR 0 4
81139: PUSH
81140: LD_VAR 0 7
81144: ARRAY
81145: PPUSH
81146: CALL_OW 314
81150: NOT
81151: IFFALSE 81254
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81153: LD_ADDR_VAR 0 9
81157: PUSH
81158: LD_INT 81
81160: PUSH
81161: LD_VAR 0 4
81165: PUSH
81166: LD_VAR 0 7
81170: ARRAY
81171: PPUSH
81172: CALL_OW 255
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PPUSH
81181: CALL_OW 69
81185: PPUSH
81186: LD_VAR 0 4
81190: PUSH
81191: LD_VAR 0 7
81195: ARRAY
81196: PPUSH
81197: CALL_OW 74
81201: ST_TO_ADDR
// if k then
81202: LD_VAR 0 9
81206: IFFALSE 81254
// if GetDistUnits ( group [ i ] , k ) > 10 then
81208: LD_VAR 0 4
81212: PUSH
81213: LD_VAR 0 7
81217: ARRAY
81218: PPUSH
81219: LD_VAR 0 9
81223: PPUSH
81224: CALL_OW 296
81228: PUSH
81229: LD_INT 10
81231: GREATER
81232: IFFALSE 81254
// ComMoveUnit ( group [ i ] , k ) ;
81234: LD_VAR 0 4
81238: PUSH
81239: LD_VAR 0 7
81243: ARRAY
81244: PPUSH
81245: LD_VAR 0 9
81249: PPUSH
81250: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81254: LD_VAR 0 4
81258: PUSH
81259: LD_VAR 0 7
81263: ARRAY
81264: PPUSH
81265: CALL_OW 256
81269: PUSH
81270: LD_INT 250
81272: LESS
81273: PUSH
81274: LD_VAR 0 4
81278: PUSH
81279: LD_VAR 0 7
81283: ARRAY
81284: PUSH
81285: LD_INT 21
81287: PUSH
81288: LD_INT 2
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 23
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PPUSH
81309: CALL_OW 69
81313: IN
81314: AND
81315: IFFALSE 81440
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81317: LD_ADDR_VAR 0 9
81321: PUSH
81322: LD_OWVAR 3
81326: PUSH
81327: LD_VAR 0 4
81331: PUSH
81332: LD_VAR 0 7
81336: ARRAY
81337: DIFF
81338: PPUSH
81339: LD_VAR 0 4
81343: PUSH
81344: LD_VAR 0 7
81348: ARRAY
81349: PPUSH
81350: CALL_OW 74
81354: ST_TO_ADDR
// if not k then
81355: LD_VAR 0 9
81359: NOT
81360: IFFALSE 81364
// continue ;
81362: GO 77779
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81364: LD_VAR 0 9
81368: PUSH
81369: LD_INT 81
81371: PUSH
81372: LD_VAR 0 4
81376: PUSH
81377: LD_VAR 0 7
81381: ARRAY
81382: PPUSH
81383: CALL_OW 255
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PPUSH
81392: CALL_OW 69
81396: IN
81397: PUSH
81398: LD_VAR 0 9
81402: PPUSH
81403: LD_VAR 0 4
81407: PUSH
81408: LD_VAR 0 7
81412: ARRAY
81413: PPUSH
81414: CALL_OW 296
81418: PUSH
81419: LD_INT 5
81421: LESS
81422: AND
81423: IFFALSE 81440
// ComAutodestruct ( group [ i ] ) ;
81425: LD_VAR 0 4
81429: PUSH
81430: LD_VAR 0 7
81434: ARRAY
81435: PPUSH
81436: CALL 41836 0 1
// end ; if f_attack_depot then
81440: LD_VAR 0 25
81444: IFFALSE 81556
// begin k := 6 ;
81446: LD_ADDR_VAR 0 9
81450: PUSH
81451: LD_INT 6
81453: ST_TO_ADDR
// if tmp < k then
81454: LD_VAR 0 14
81458: PUSH
81459: LD_VAR 0 9
81463: LESS
81464: IFFALSE 81476
// k := tmp ;
81466: LD_ADDR_VAR 0 9
81470: PUSH
81471: LD_VAR 0 14
81475: ST_TO_ADDR
// for j = 1 to k do
81476: LD_ADDR_VAR 0 8
81480: PUSH
81481: DOUBLE
81482: LD_INT 1
81484: DEC
81485: ST_TO_ADDR
81486: LD_VAR 0 9
81490: PUSH
81491: FOR_TO
81492: IFFALSE 81554
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81494: LD_VAR 0 8
81498: PPUSH
81499: CALL_OW 266
81503: PUSH
81504: LD_INT 0
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: IN
81514: IFFALSE 81552
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81516: LD_VAR 0 4
81520: PUSH
81521: LD_VAR 0 7
81525: ARRAY
81526: PPUSH
81527: LD_VAR 0 14
81531: PUSH
81532: LD_VAR 0 8
81536: ARRAY
81537: PPUSH
81538: CALL_OW 115
// attacking := true ;
81542: LD_ADDR_VAR 0 29
81546: PUSH
81547: LD_INT 1
81549: ST_TO_ADDR
// break ;
81550: GO 81554
// end ;
81552: GO 81491
81554: POP
81555: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81556: LD_VAR 0 4
81560: PUSH
81561: LD_VAR 0 7
81565: ARRAY
81566: PPUSH
81567: CALL_OW 302
81571: PUSH
81572: LD_VAR 0 29
81576: NOT
81577: AND
81578: IFFALSE 81900
// begin if GetTag ( group [ i ] ) = 71 then
81580: LD_VAR 0 4
81584: PUSH
81585: LD_VAR 0 7
81589: ARRAY
81590: PPUSH
81591: CALL_OW 110
81595: PUSH
81596: LD_INT 71
81598: EQUAL
81599: IFFALSE 81640
// begin if HasTask ( group [ i ] ) then
81601: LD_VAR 0 4
81605: PUSH
81606: LD_VAR 0 7
81610: ARRAY
81611: PPUSH
81612: CALL_OW 314
81616: IFFALSE 81622
// continue else
81618: GO 77779
81620: GO 81640
// SetTag ( group [ i ] , 0 ) ;
81622: LD_VAR 0 4
81626: PUSH
81627: LD_VAR 0 7
81631: ARRAY
81632: PPUSH
81633: LD_INT 0
81635: PPUSH
81636: CALL_OW 109
// end ; k := 8 ;
81640: LD_ADDR_VAR 0 9
81644: PUSH
81645: LD_INT 8
81647: ST_TO_ADDR
// x := 0 ;
81648: LD_ADDR_VAR 0 10
81652: PUSH
81653: LD_INT 0
81655: ST_TO_ADDR
// if tmp < k then
81656: LD_VAR 0 14
81660: PUSH
81661: LD_VAR 0 9
81665: LESS
81666: IFFALSE 81678
// k := tmp ;
81668: LD_ADDR_VAR 0 9
81672: PUSH
81673: LD_VAR 0 14
81677: ST_TO_ADDR
// for j = 1 to k do
81678: LD_ADDR_VAR 0 8
81682: PUSH
81683: DOUBLE
81684: LD_INT 1
81686: DEC
81687: ST_TO_ADDR
81688: LD_VAR 0 9
81692: PUSH
81693: FOR_TO
81694: IFFALSE 81792
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81696: LD_VAR 0 14
81700: PUSH
81701: LD_VAR 0 8
81705: ARRAY
81706: PPUSH
81707: CALL_OW 247
81711: PUSH
81712: LD_INT 1
81714: EQUAL
81715: PUSH
81716: LD_VAR 0 14
81720: PUSH
81721: LD_VAR 0 8
81725: ARRAY
81726: PPUSH
81727: CALL_OW 256
81731: PUSH
81732: LD_INT 250
81734: LESS
81735: PUSH
81736: LD_VAR 0 20
81740: AND
81741: PUSH
81742: LD_VAR 0 20
81746: NOT
81747: PUSH
81748: LD_VAR 0 14
81752: PUSH
81753: LD_VAR 0 8
81757: ARRAY
81758: PPUSH
81759: CALL_OW 256
81763: PUSH
81764: LD_INT 250
81766: GREATEREQUAL
81767: AND
81768: OR
81769: AND
81770: IFFALSE 81790
// begin x := tmp [ j ] ;
81772: LD_ADDR_VAR 0 10
81776: PUSH
81777: LD_VAR 0 14
81781: PUSH
81782: LD_VAR 0 8
81786: ARRAY
81787: ST_TO_ADDR
// break ;
81788: GO 81792
// end ;
81790: GO 81693
81792: POP
81793: POP
// if x then
81794: LD_VAR 0 10
81798: IFFALSE 81822
// ComAttackUnit ( group [ i ] , x ) else
81800: LD_VAR 0 4
81804: PUSH
81805: LD_VAR 0 7
81809: ARRAY
81810: PPUSH
81811: LD_VAR 0 10
81815: PPUSH
81816: CALL_OW 115
81820: GO 81846
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81822: LD_VAR 0 4
81826: PUSH
81827: LD_VAR 0 7
81831: ARRAY
81832: PPUSH
81833: LD_VAR 0 14
81837: PUSH
81838: LD_INT 1
81840: ARRAY
81841: PPUSH
81842: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81846: LD_VAR 0 4
81850: PUSH
81851: LD_VAR 0 7
81855: ARRAY
81856: PPUSH
81857: CALL_OW 314
81861: NOT
81862: IFFALSE 81900
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81864: LD_VAR 0 4
81868: PUSH
81869: LD_VAR 0 7
81873: ARRAY
81874: PPUSH
81875: LD_VAR 0 14
81879: PPUSH
81880: LD_VAR 0 4
81884: PUSH
81885: LD_VAR 0 7
81889: ARRAY
81890: PPUSH
81891: CALL_OW 74
81895: PPUSH
81896: CALL_OW 115
// end ; end ; end ;
81900: GO 77779
81902: POP
81903: POP
// wait ( 0 0$2 ) ;
81904: LD_INT 70
81906: PPUSH
81907: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
81911: LD_VAR 0 4
81915: NOT
81916: PUSH
81917: LD_VAR 0 4
81921: PUSH
81922: EMPTY
81923: EQUAL
81924: OR
81925: PUSH
81926: LD_INT 81
81928: PUSH
81929: LD_VAR 0 35
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PPUSH
81938: CALL_OW 69
81942: NOT
81943: OR
81944: IFFALSE 77764
// end ;
81946: LD_VAR 0 2
81950: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
81951: LD_INT 0
81953: PPUSH
81954: PPUSH
81955: PPUSH
81956: PPUSH
81957: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
81958: LD_VAR 0 1
81962: NOT
81963: PUSH
81964: LD_EXP 42
81968: PUSH
81969: LD_VAR 0 1
81973: ARRAY
81974: NOT
81975: OR
81976: PUSH
81977: LD_VAR 0 2
81981: NOT
81982: OR
81983: PUSH
81984: LD_VAR 0 3
81988: NOT
81989: OR
81990: IFFALSE 81994
// exit ;
81992: GO 82507
// side := mc_sides [ base ] ;
81994: LD_ADDR_VAR 0 6
81998: PUSH
81999: LD_EXP 68
82003: PUSH
82004: LD_VAR 0 1
82008: ARRAY
82009: ST_TO_ADDR
// if not side then
82010: LD_VAR 0 6
82014: NOT
82015: IFFALSE 82019
// exit ;
82017: GO 82507
// for i in solds do
82019: LD_ADDR_VAR 0 7
82023: PUSH
82024: LD_VAR 0 2
82028: PUSH
82029: FOR_IN
82030: IFFALSE 82091
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82032: LD_VAR 0 7
82036: PPUSH
82037: CALL_OW 310
82041: PPUSH
82042: CALL_OW 266
82046: PUSH
82047: LD_INT 32
82049: PUSH
82050: LD_INT 31
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: IN
82057: IFFALSE 82077
// solds := solds diff i else
82059: LD_ADDR_VAR 0 2
82063: PUSH
82064: LD_VAR 0 2
82068: PUSH
82069: LD_VAR 0 7
82073: DIFF
82074: ST_TO_ADDR
82075: GO 82089
// SetTag ( i , 18 ) ;
82077: LD_VAR 0 7
82081: PPUSH
82082: LD_INT 18
82084: PPUSH
82085: CALL_OW 109
82089: GO 82029
82091: POP
82092: POP
// if not solds then
82093: LD_VAR 0 2
82097: NOT
82098: IFFALSE 82102
// exit ;
82100: GO 82507
// repeat wait ( 0 0$2 ) ;
82102: LD_INT 70
82104: PPUSH
82105: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82109: LD_ADDR_VAR 0 5
82113: PUSH
82114: LD_VAR 0 6
82118: PPUSH
82119: LD_VAR 0 3
82123: PPUSH
82124: CALL 11551 0 2
82128: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82129: LD_EXP 42
82133: PUSH
82134: LD_VAR 0 1
82138: ARRAY
82139: NOT
82140: PUSH
82141: LD_EXP 42
82145: PUSH
82146: LD_VAR 0 1
82150: ARRAY
82151: PUSH
82152: EMPTY
82153: EQUAL
82154: OR
82155: IFFALSE 82192
// begin for i in solds do
82157: LD_ADDR_VAR 0 7
82161: PUSH
82162: LD_VAR 0 2
82166: PUSH
82167: FOR_IN
82168: IFFALSE 82181
// ComStop ( i ) ;
82170: LD_VAR 0 7
82174: PPUSH
82175: CALL_OW 141
82179: GO 82167
82181: POP
82182: POP
// solds := [ ] ;
82183: LD_ADDR_VAR 0 2
82187: PUSH
82188: EMPTY
82189: ST_TO_ADDR
// exit ;
82190: GO 82507
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82192: LD_VAR 0 5
82196: NOT
82197: PUSH
82198: LD_VAR 0 5
82202: PUSH
82203: LD_INT 3
82205: GREATER
82206: OR
82207: PUSH
82208: LD_EXP 64
82212: PUSH
82213: LD_VAR 0 1
82217: ARRAY
82218: OR
82219: IFFALSE 82260
// begin for i in solds do
82221: LD_ADDR_VAR 0 7
82225: PUSH
82226: LD_VAR 0 2
82230: PUSH
82231: FOR_IN
82232: IFFALSE 82256
// if HasTask ( i ) then
82234: LD_VAR 0 7
82238: PPUSH
82239: CALL_OW 314
82243: IFFALSE 82254
// ComStop ( i ) ;
82245: LD_VAR 0 7
82249: PPUSH
82250: CALL_OW 141
82254: GO 82231
82256: POP
82257: POP
// break ;
82258: GO 82495
// end ; for i in solds do
82260: LD_ADDR_VAR 0 7
82264: PUSH
82265: LD_VAR 0 2
82269: PUSH
82270: FOR_IN
82271: IFFALSE 82487
// begin if IsInUnit ( i ) then
82273: LD_VAR 0 7
82277: PPUSH
82278: CALL_OW 310
82282: IFFALSE 82293
// ComExitBuilding ( i ) ;
82284: LD_VAR 0 7
82288: PPUSH
82289: CALL_OW 122
// if GetLives ( i ) > 333 then
82293: LD_VAR 0 7
82297: PPUSH
82298: CALL_OW 256
82302: PUSH
82303: LD_INT 333
82305: GREATER
82306: IFFALSE 82334
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82308: LD_VAR 0 7
82312: PPUSH
82313: LD_VAR 0 5
82317: PPUSH
82318: LD_VAR 0 7
82322: PPUSH
82323: CALL_OW 74
82327: PPUSH
82328: CALL_OW 115
82332: GO 82485
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82334: LD_ADDR_VAR 0 8
82338: PUSH
82339: LD_EXP 42
82343: PUSH
82344: LD_VAR 0 1
82348: ARRAY
82349: PPUSH
82350: LD_INT 2
82352: PUSH
82353: LD_INT 30
82355: PUSH
82356: LD_INT 0
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 30
82365: PUSH
82366: LD_INT 1
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 30
82375: PUSH
82376: LD_INT 6
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: PPUSH
82389: CALL_OW 72
82393: PPUSH
82394: LD_VAR 0 7
82398: PPUSH
82399: CALL_OW 74
82403: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82404: LD_VAR 0 7
82408: PPUSH
82409: LD_VAR 0 8
82413: PPUSH
82414: CALL_OW 250
82418: PPUSH
82419: LD_INT 3
82421: PPUSH
82422: LD_INT 5
82424: PPUSH
82425: CALL_OW 272
82429: PPUSH
82430: LD_VAR 0 8
82434: PPUSH
82435: CALL_OW 251
82439: PPUSH
82440: LD_INT 3
82442: PPUSH
82443: LD_INT 5
82445: PPUSH
82446: CALL_OW 273
82450: PPUSH
82451: CALL_OW 111
// SetTag ( i , 0 ) ;
82455: LD_VAR 0 7
82459: PPUSH
82460: LD_INT 0
82462: PPUSH
82463: CALL_OW 109
// solds := solds diff i ;
82467: LD_ADDR_VAR 0 2
82471: PUSH
82472: LD_VAR 0 2
82476: PUSH
82477: LD_VAR 0 7
82481: DIFF
82482: ST_TO_ADDR
// continue ;
82483: GO 82270
// end ; end ;
82485: GO 82270
82487: POP
82488: POP
// until solds ;
82489: LD_VAR 0 2
82493: IFFALSE 82102
// MC_Reset ( base , 18 ) ;
82495: LD_VAR 0 1
82499: PPUSH
82500: LD_INT 18
82502: PPUSH
82503: CALL 51086 0 2
// end ;
82507: LD_VAR 0 4
82511: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82512: LD_INT 0
82514: PPUSH
82515: PPUSH
82516: PPUSH
82517: PPUSH
82518: PPUSH
82519: PPUSH
82520: PPUSH
82521: PPUSH
82522: PPUSH
82523: PPUSH
82524: PPUSH
82525: PPUSH
82526: PPUSH
82527: PPUSH
82528: PPUSH
82529: PPUSH
82530: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82531: LD_ADDR_VAR 0 13
82535: PUSH
82536: LD_EXP 42
82540: PUSH
82541: LD_VAR 0 1
82545: ARRAY
82546: PPUSH
82547: LD_INT 25
82549: PUSH
82550: LD_INT 3
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PPUSH
82557: CALL_OW 72
82561: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82562: LD_EXP 82
82566: PUSH
82567: LD_VAR 0 1
82571: ARRAY
82572: IFFALSE 82596
// mechs := mechs diff mc_remote_driver [ base ] ;
82574: LD_ADDR_VAR 0 13
82578: PUSH
82579: LD_VAR 0 13
82583: PUSH
82584: LD_EXP 82
82588: PUSH
82589: LD_VAR 0 1
82593: ARRAY
82594: DIFF
82595: ST_TO_ADDR
// for i in mechs do
82596: LD_ADDR_VAR 0 5
82600: PUSH
82601: LD_VAR 0 13
82605: PUSH
82606: FOR_IN
82607: IFFALSE 82642
// if GetTag ( i ) > 0 then
82609: LD_VAR 0 5
82613: PPUSH
82614: CALL_OW 110
82618: PUSH
82619: LD_INT 0
82621: GREATER
82622: IFFALSE 82640
// mechs := mechs diff i ;
82624: LD_ADDR_VAR 0 13
82628: PUSH
82629: LD_VAR 0 13
82633: PUSH
82634: LD_VAR 0 5
82638: DIFF
82639: ST_TO_ADDR
82640: GO 82606
82642: POP
82643: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82644: LD_ADDR_VAR 0 9
82648: PUSH
82649: LD_EXP 42
82653: PUSH
82654: LD_VAR 0 1
82658: ARRAY
82659: PPUSH
82660: LD_INT 2
82662: PUSH
82663: LD_INT 25
82665: PUSH
82666: LD_INT 1
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 25
82675: PUSH
82676: LD_INT 5
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 25
82685: PUSH
82686: LD_INT 8
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 25
82695: PUSH
82696: LD_INT 9
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: PPUSH
82710: CALL_OW 72
82714: ST_TO_ADDR
// if not defenders and not solds then
82715: LD_VAR 0 2
82719: NOT
82720: PUSH
82721: LD_VAR 0 9
82725: NOT
82726: AND
82727: IFFALSE 82731
// exit ;
82729: GO 84421
// depot_under_attack := false ;
82731: LD_ADDR_VAR 0 17
82735: PUSH
82736: LD_INT 0
82738: ST_TO_ADDR
// sold_defenders := [ ] ;
82739: LD_ADDR_VAR 0 18
82743: PUSH
82744: EMPTY
82745: ST_TO_ADDR
// if mechs then
82746: LD_VAR 0 13
82750: IFFALSE 82903
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82752: LD_ADDR_VAR 0 5
82756: PUSH
82757: LD_VAR 0 2
82761: PPUSH
82762: LD_INT 21
82764: PUSH
82765: LD_INT 2
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PPUSH
82772: CALL_OW 72
82776: PUSH
82777: FOR_IN
82778: IFFALSE 82901
// begin if GetTag ( i ) <> 20 then
82780: LD_VAR 0 5
82784: PPUSH
82785: CALL_OW 110
82789: PUSH
82790: LD_INT 20
82792: NONEQUAL
82793: IFFALSE 82807
// SetTag ( i , 20 ) ;
82795: LD_VAR 0 5
82799: PPUSH
82800: LD_INT 20
82802: PPUSH
82803: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82807: LD_VAR 0 5
82811: PPUSH
82812: CALL_OW 263
82816: PUSH
82817: LD_INT 1
82819: EQUAL
82820: PUSH
82821: LD_VAR 0 5
82825: PPUSH
82826: CALL_OW 311
82830: NOT
82831: AND
82832: IFFALSE 82899
// begin un := mechs [ 1 ] ;
82834: LD_ADDR_VAR 0 11
82838: PUSH
82839: LD_VAR 0 13
82843: PUSH
82844: LD_INT 1
82846: ARRAY
82847: ST_TO_ADDR
// ComExit ( un ) ;
82848: LD_VAR 0 11
82852: PPUSH
82853: CALL 46181 0 1
// AddComEnterUnit ( un , i ) ;
82857: LD_VAR 0 11
82861: PPUSH
82862: LD_VAR 0 5
82866: PPUSH
82867: CALL_OW 180
// SetTag ( un , 19 ) ;
82871: LD_VAR 0 11
82875: PPUSH
82876: LD_INT 19
82878: PPUSH
82879: CALL_OW 109
// mechs := mechs diff un ;
82883: LD_ADDR_VAR 0 13
82887: PUSH
82888: LD_VAR 0 13
82892: PUSH
82893: LD_VAR 0 11
82897: DIFF
82898: ST_TO_ADDR
// end ; end ;
82899: GO 82777
82901: POP
82902: POP
// if solds then
82903: LD_VAR 0 9
82907: IFFALSE 82966
// for i in solds do
82909: LD_ADDR_VAR 0 5
82913: PUSH
82914: LD_VAR 0 9
82918: PUSH
82919: FOR_IN
82920: IFFALSE 82964
// if not GetTag ( i ) then
82922: LD_VAR 0 5
82926: PPUSH
82927: CALL_OW 110
82931: NOT
82932: IFFALSE 82962
// begin defenders := defenders union i ;
82934: LD_ADDR_VAR 0 2
82938: PUSH
82939: LD_VAR 0 2
82943: PUSH
82944: LD_VAR 0 5
82948: UNION
82949: ST_TO_ADDR
// SetTag ( i , 18 ) ;
82950: LD_VAR 0 5
82954: PPUSH
82955: LD_INT 18
82957: PPUSH
82958: CALL_OW 109
// end ;
82962: GO 82919
82964: POP
82965: POP
// repeat wait ( 0 0$2 ) ;
82966: LD_INT 70
82968: PPUSH
82969: CALL_OW 67
// enemy := mc_scan [ base ] ;
82973: LD_ADDR_VAR 0 3
82977: PUSH
82978: LD_EXP 65
82982: PUSH
82983: LD_VAR 0 1
82987: ARRAY
82988: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82989: LD_EXP 42
82993: PUSH
82994: LD_VAR 0 1
82998: ARRAY
82999: NOT
83000: PUSH
83001: LD_EXP 42
83005: PUSH
83006: LD_VAR 0 1
83010: ARRAY
83011: PUSH
83012: EMPTY
83013: EQUAL
83014: OR
83015: IFFALSE 83052
// begin for i in defenders do
83017: LD_ADDR_VAR 0 5
83021: PUSH
83022: LD_VAR 0 2
83026: PUSH
83027: FOR_IN
83028: IFFALSE 83041
// ComStop ( i ) ;
83030: LD_VAR 0 5
83034: PPUSH
83035: CALL_OW 141
83039: GO 83027
83041: POP
83042: POP
// defenders := [ ] ;
83043: LD_ADDR_VAR 0 2
83047: PUSH
83048: EMPTY
83049: ST_TO_ADDR
// exit ;
83050: GO 84421
// end ; for i in defenders do
83052: LD_ADDR_VAR 0 5
83056: PUSH
83057: LD_VAR 0 2
83061: PUSH
83062: FOR_IN
83063: IFFALSE 83881
// begin e := NearestUnitToUnit ( enemy , i ) ;
83065: LD_ADDR_VAR 0 14
83069: PUSH
83070: LD_VAR 0 3
83074: PPUSH
83075: LD_VAR 0 5
83079: PPUSH
83080: CALL_OW 74
83084: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83085: LD_ADDR_VAR 0 8
83089: PUSH
83090: LD_EXP 42
83094: PUSH
83095: LD_VAR 0 1
83099: ARRAY
83100: PPUSH
83101: LD_INT 2
83103: PUSH
83104: LD_INT 30
83106: PUSH
83107: LD_INT 0
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 30
83116: PUSH
83117: LD_INT 1
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: LIST
83128: PPUSH
83129: CALL_OW 72
83133: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83134: LD_ADDR_VAR 0 17
83138: PUSH
83139: LD_VAR 0 8
83143: NOT
83144: PUSH
83145: LD_VAR 0 8
83149: PPUSH
83150: LD_INT 3
83152: PUSH
83153: LD_INT 24
83155: PUSH
83156: LD_INT 600
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PPUSH
83167: CALL_OW 72
83171: OR
83172: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83173: LD_VAR 0 5
83177: PPUSH
83178: CALL_OW 247
83182: PUSH
83183: LD_INT 2
83185: DOUBLE
83186: EQUAL
83187: IFTRUE 83191
83189: GO 83587
83191: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83192: LD_VAR 0 5
83196: PPUSH
83197: CALL_OW 256
83201: PUSH
83202: LD_INT 650
83204: GREATER
83205: PUSH
83206: LD_VAR 0 5
83210: PPUSH
83211: LD_VAR 0 14
83215: PPUSH
83216: CALL_OW 296
83220: PUSH
83221: LD_INT 40
83223: LESS
83224: PUSH
83225: LD_VAR 0 14
83229: PPUSH
83230: LD_EXP 67
83234: PUSH
83235: LD_VAR 0 1
83239: ARRAY
83240: PPUSH
83241: CALL_OW 308
83245: OR
83246: AND
83247: IFFALSE 83369
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83249: LD_VAR 0 5
83253: PPUSH
83254: CALL_OW 262
83258: PUSH
83259: LD_INT 1
83261: EQUAL
83262: PUSH
83263: LD_VAR 0 5
83267: PPUSH
83268: CALL_OW 261
83272: PUSH
83273: LD_INT 30
83275: LESS
83276: AND
83277: PUSH
83278: LD_VAR 0 8
83282: AND
83283: IFFALSE 83353
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83285: LD_VAR 0 5
83289: PPUSH
83290: LD_VAR 0 8
83294: PPUSH
83295: LD_VAR 0 5
83299: PPUSH
83300: CALL_OW 74
83304: PPUSH
83305: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83309: LD_VAR 0 5
83313: PPUSH
83314: LD_VAR 0 8
83318: PPUSH
83319: LD_VAR 0 5
83323: PPUSH
83324: CALL_OW 74
83328: PPUSH
83329: CALL_OW 296
83333: PUSH
83334: LD_INT 6
83336: LESS
83337: IFFALSE 83351
// SetFuel ( i , 100 ) ;
83339: LD_VAR 0 5
83343: PPUSH
83344: LD_INT 100
83346: PPUSH
83347: CALL_OW 240
// end else
83351: GO 83367
// ComAttackUnit ( i , e ) ;
83353: LD_VAR 0 5
83357: PPUSH
83358: LD_VAR 0 14
83362: PPUSH
83363: CALL_OW 115
// end else
83367: GO 83470
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83369: LD_VAR 0 14
83373: PPUSH
83374: LD_EXP 67
83378: PUSH
83379: LD_VAR 0 1
83383: ARRAY
83384: PPUSH
83385: CALL_OW 308
83389: NOT
83390: PUSH
83391: LD_VAR 0 5
83395: PPUSH
83396: LD_VAR 0 14
83400: PPUSH
83401: CALL_OW 296
83405: PUSH
83406: LD_INT 40
83408: GREATEREQUAL
83409: AND
83410: PUSH
83411: LD_VAR 0 5
83415: PPUSH
83416: CALL_OW 256
83420: PUSH
83421: LD_INT 650
83423: LESSEQUAL
83424: OR
83425: PUSH
83426: LD_VAR 0 5
83430: PPUSH
83431: LD_EXP 66
83435: PUSH
83436: LD_VAR 0 1
83440: ARRAY
83441: PPUSH
83442: CALL_OW 308
83446: NOT
83447: AND
83448: IFFALSE 83470
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83450: LD_VAR 0 5
83454: PPUSH
83455: LD_EXP 66
83459: PUSH
83460: LD_VAR 0 1
83464: ARRAY
83465: PPUSH
83466: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83470: LD_VAR 0 5
83474: PPUSH
83475: CALL_OW 256
83479: PUSH
83480: LD_INT 998
83482: LESS
83483: PUSH
83484: LD_VAR 0 5
83488: PPUSH
83489: CALL_OW 263
83493: PUSH
83494: LD_INT 1
83496: EQUAL
83497: AND
83498: PUSH
83499: LD_VAR 0 5
83503: PPUSH
83504: CALL_OW 311
83508: AND
83509: PUSH
83510: LD_VAR 0 5
83514: PPUSH
83515: LD_EXP 66
83519: PUSH
83520: LD_VAR 0 1
83524: ARRAY
83525: PPUSH
83526: CALL_OW 308
83530: AND
83531: IFFALSE 83585
// begin mech := IsDrivenBy ( i ) ;
83533: LD_ADDR_VAR 0 10
83537: PUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: CALL_OW 311
83547: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83548: LD_VAR 0 10
83552: PPUSH
83553: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83557: LD_VAR 0 10
83561: PPUSH
83562: LD_VAR 0 5
83566: PPUSH
83567: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83571: LD_VAR 0 10
83575: PPUSH
83576: LD_VAR 0 5
83580: PPUSH
83581: CALL_OW 180
// end ; end ; unit_human :
83585: GO 83852
83587: LD_INT 1
83589: DOUBLE
83590: EQUAL
83591: IFTRUE 83595
83593: GO 83851
83595: POP
// begin b := IsInUnit ( i ) ;
83596: LD_ADDR_VAR 0 19
83600: PUSH
83601: LD_VAR 0 5
83605: PPUSH
83606: CALL_OW 310
83610: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83611: LD_ADDR_VAR 0 20
83615: PUSH
83616: LD_VAR 0 19
83620: NOT
83621: PUSH
83622: LD_VAR 0 19
83626: PPUSH
83627: CALL_OW 266
83631: PUSH
83632: LD_INT 32
83634: PUSH
83635: LD_INT 31
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: IN
83642: OR
83643: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83644: LD_VAR 0 17
83648: PUSH
83649: LD_VAR 0 2
83653: PPUSH
83654: LD_INT 21
83656: PUSH
83657: LD_INT 2
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PPUSH
83664: CALL_OW 72
83668: PUSH
83669: LD_INT 1
83671: LESSEQUAL
83672: OR
83673: PUSH
83674: LD_VAR 0 20
83678: AND
83679: PUSH
83680: LD_VAR 0 5
83684: PUSH
83685: LD_VAR 0 18
83689: IN
83690: NOT
83691: AND
83692: IFFALSE 83785
// begin if b then
83694: LD_VAR 0 19
83698: IFFALSE 83747
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83700: LD_VAR 0 19
83704: PPUSH
83705: LD_VAR 0 3
83709: PPUSH
83710: LD_VAR 0 19
83714: PPUSH
83715: CALL_OW 74
83719: PPUSH
83720: CALL_OW 296
83724: PUSH
83725: LD_INT 10
83727: LESS
83728: PUSH
83729: LD_VAR 0 19
83733: PPUSH
83734: CALL_OW 461
83738: PUSH
83739: LD_INT 7
83741: NONEQUAL
83742: AND
83743: IFFALSE 83747
// continue ;
83745: GO 83062
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83747: LD_ADDR_VAR 0 18
83751: PUSH
83752: LD_VAR 0 18
83756: PPUSH
83757: LD_VAR 0 18
83761: PUSH
83762: LD_INT 1
83764: PLUS
83765: PPUSH
83766: LD_VAR 0 5
83770: PPUSH
83771: CALL_OW 1
83775: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83776: LD_VAR 0 5
83780: PPUSH
83781: CALL_OW 122
// end ; if sold_defenders then
83785: LD_VAR 0 18
83789: IFFALSE 83849
// if i in sold_defenders then
83791: LD_VAR 0 5
83795: PUSH
83796: LD_VAR 0 18
83800: IN
83801: IFFALSE 83849
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83803: LD_VAR 0 5
83807: PPUSH
83808: CALL_OW 314
83812: NOT
83813: PUSH
83814: LD_VAR 0 5
83818: PPUSH
83819: LD_VAR 0 14
83823: PPUSH
83824: CALL_OW 296
83828: PUSH
83829: LD_INT 30
83831: LESS
83832: AND
83833: IFFALSE 83849
// ComAttackUnit ( i , e ) ;
83835: LD_VAR 0 5
83839: PPUSH
83840: LD_VAR 0 14
83844: PPUSH
83845: CALL_OW 115
// end ; end ; end ;
83849: GO 83852
83851: POP
// if IsDead ( i ) then
83852: LD_VAR 0 5
83856: PPUSH
83857: CALL_OW 301
83861: IFFALSE 83879
// defenders := defenders diff i ;
83863: LD_ADDR_VAR 0 2
83867: PUSH
83868: LD_VAR 0 2
83872: PUSH
83873: LD_VAR 0 5
83877: DIFF
83878: ST_TO_ADDR
// end ;
83879: GO 83062
83881: POP
83882: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83883: LD_VAR 0 3
83887: NOT
83888: PUSH
83889: LD_VAR 0 2
83893: NOT
83894: OR
83895: PUSH
83896: LD_EXP 42
83900: PUSH
83901: LD_VAR 0 1
83905: ARRAY
83906: NOT
83907: OR
83908: IFFALSE 82966
// MC_Reset ( base , 18 ) ;
83910: LD_VAR 0 1
83914: PPUSH
83915: LD_INT 18
83917: PPUSH
83918: CALL 51086 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83922: LD_ADDR_VAR 0 2
83926: PUSH
83927: LD_VAR 0 2
83931: PUSH
83932: LD_VAR 0 2
83936: PPUSH
83937: LD_INT 2
83939: PUSH
83940: LD_INT 25
83942: PUSH
83943: LD_INT 1
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 25
83952: PUSH
83953: LD_INT 5
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 25
83962: PUSH
83963: LD_INT 8
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 25
83972: PUSH
83973: LD_INT 9
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: PPUSH
83987: CALL_OW 72
83991: DIFF
83992: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
83993: LD_VAR 0 3
83997: NOT
83998: PUSH
83999: LD_VAR 0 2
84003: PPUSH
84004: LD_INT 21
84006: PUSH
84007: LD_INT 2
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PPUSH
84014: CALL_OW 72
84018: AND
84019: IFFALSE 84357
// begin tmp := FilterByTag ( defenders , 19 ) ;
84021: LD_ADDR_VAR 0 12
84025: PUSH
84026: LD_VAR 0 2
84030: PPUSH
84031: LD_INT 19
84033: PPUSH
84034: CALL 43311 0 2
84038: ST_TO_ADDR
// if tmp then
84039: LD_VAR 0 12
84043: IFFALSE 84113
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84045: LD_ADDR_VAR 0 12
84049: PUSH
84050: LD_VAR 0 12
84054: PPUSH
84055: LD_INT 25
84057: PUSH
84058: LD_INT 3
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PPUSH
84065: CALL_OW 72
84069: ST_TO_ADDR
// if tmp then
84070: LD_VAR 0 12
84074: IFFALSE 84113
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84076: LD_ADDR_EXP 54
84080: PUSH
84081: LD_EXP 54
84085: PPUSH
84086: LD_VAR 0 1
84090: PPUSH
84091: LD_EXP 54
84095: PUSH
84096: LD_VAR 0 1
84100: ARRAY
84101: PUSH
84102: LD_VAR 0 12
84106: UNION
84107: PPUSH
84108: CALL_OW 1
84112: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84113: LD_VAR 0 1
84117: PPUSH
84118: LD_INT 19
84120: PPUSH
84121: CALL 51086 0 2
// repeat wait ( 0 0$1 ) ;
84125: LD_INT 35
84127: PPUSH
84128: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84132: LD_EXP 42
84136: PUSH
84137: LD_VAR 0 1
84141: ARRAY
84142: NOT
84143: PUSH
84144: LD_EXP 42
84148: PUSH
84149: LD_VAR 0 1
84153: ARRAY
84154: PUSH
84155: EMPTY
84156: EQUAL
84157: OR
84158: IFFALSE 84195
// begin for i in defenders do
84160: LD_ADDR_VAR 0 5
84164: PUSH
84165: LD_VAR 0 2
84169: PUSH
84170: FOR_IN
84171: IFFALSE 84184
// ComStop ( i ) ;
84173: LD_VAR 0 5
84177: PPUSH
84178: CALL_OW 141
84182: GO 84170
84184: POP
84185: POP
// defenders := [ ] ;
84186: LD_ADDR_VAR 0 2
84190: PUSH
84191: EMPTY
84192: ST_TO_ADDR
// exit ;
84193: GO 84421
// end ; for i in defenders do
84195: LD_ADDR_VAR 0 5
84199: PUSH
84200: LD_VAR 0 2
84204: PUSH
84205: FOR_IN
84206: IFFALSE 84295
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84208: LD_VAR 0 5
84212: PPUSH
84213: LD_EXP 66
84217: PUSH
84218: LD_VAR 0 1
84222: ARRAY
84223: PPUSH
84224: CALL_OW 308
84228: NOT
84229: IFFALSE 84253
// ComMoveToArea ( i , mc_parking [ base ] ) else
84231: LD_VAR 0 5
84235: PPUSH
84236: LD_EXP 66
84240: PUSH
84241: LD_VAR 0 1
84245: ARRAY
84246: PPUSH
84247: CALL_OW 113
84251: GO 84293
// if GetControl ( i ) = control_manual then
84253: LD_VAR 0 5
84257: PPUSH
84258: CALL_OW 263
84262: PUSH
84263: LD_INT 1
84265: EQUAL
84266: IFFALSE 84293
// if IsDrivenBy ( i ) then
84268: LD_VAR 0 5
84272: PPUSH
84273: CALL_OW 311
84277: IFFALSE 84293
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84279: LD_VAR 0 5
84283: PPUSH
84284: CALL_OW 311
84288: PPUSH
84289: CALL_OW 121
// end ;
84293: GO 84205
84295: POP
84296: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84297: LD_VAR 0 2
84301: PPUSH
84302: LD_INT 95
84304: PUSH
84305: LD_EXP 66
84309: PUSH
84310: LD_VAR 0 1
84314: ARRAY
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PPUSH
84320: CALL_OW 72
84324: PUSH
84325: LD_VAR 0 2
84329: EQUAL
84330: PUSH
84331: LD_EXP 65
84335: PUSH
84336: LD_VAR 0 1
84340: ARRAY
84341: OR
84342: PUSH
84343: LD_EXP 42
84347: PUSH
84348: LD_VAR 0 1
84352: ARRAY
84353: NOT
84354: OR
84355: IFFALSE 84125
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84357: LD_ADDR_EXP 64
84361: PUSH
84362: LD_EXP 64
84366: PPUSH
84367: LD_VAR 0 1
84371: PPUSH
84372: LD_VAR 0 2
84376: PPUSH
84377: LD_INT 21
84379: PUSH
84380: LD_INT 2
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PPUSH
84387: CALL_OW 72
84391: PPUSH
84392: CALL_OW 1
84396: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84397: LD_VAR 0 1
84401: PPUSH
84402: LD_INT 19
84404: PPUSH
84405: CALL 51086 0 2
// MC_Reset ( base , 20 ) ;
84409: LD_VAR 0 1
84413: PPUSH
84414: LD_INT 20
84416: PPUSH
84417: CALL 51086 0 2
// end ; end_of_file
84421: LD_VAR 0 4
84425: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84426: LD_INT 0
84428: PPUSH
84429: PPUSH
84430: PPUSH
84431: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84432: LD_VAR 0 1
84436: PPUSH
84437: CALL_OW 264
84441: PUSH
84442: LD_EXP 89
84446: EQUAL
84447: IFFALSE 84519
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84449: LD_INT 68
84451: PPUSH
84452: LD_VAR 0 1
84456: PPUSH
84457: CALL_OW 255
84461: PPUSH
84462: CALL_OW 321
84466: PUSH
84467: LD_INT 2
84469: EQUAL
84470: IFFALSE 84482
// eff := 70 else
84472: LD_ADDR_VAR 0 4
84476: PUSH
84477: LD_INT 70
84479: ST_TO_ADDR
84480: GO 84490
// eff := 30 ;
84482: LD_ADDR_VAR 0 4
84486: PUSH
84487: LD_INT 30
84489: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84490: LD_VAR 0 1
84494: PPUSH
84495: CALL_OW 250
84499: PPUSH
84500: LD_VAR 0 1
84504: PPUSH
84505: CALL_OW 251
84509: PPUSH
84510: LD_VAR 0 4
84514: PPUSH
84515: CALL_OW 495
// end ; end ;
84519: LD_VAR 0 2
84523: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84524: LD_INT 0
84526: PPUSH
// end ;
84527: LD_VAR 0 4
84531: RET
// export function SOS_Command ( cmd ) ; begin
84532: LD_INT 0
84534: PPUSH
// end ;
84535: LD_VAR 0 2
84539: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84540: LD_INT 0
84542: PPUSH
// if cmd = 121 then
84543: LD_VAR 0 1
84547: PUSH
84548: LD_INT 121
84550: EQUAL
84551: IFFALSE 84553
// end ;
84553: LD_VAR 0 6
84557: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84558: LD_INT 0
84560: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84561: LD_VAR 0 1
84565: PUSH
84566: LD_INT 250
84568: EQUAL
84569: PUSH
84570: LD_VAR 0 2
84574: PPUSH
84575: CALL_OW 264
84579: PUSH
84580: LD_EXP 92
84584: EQUAL
84585: AND
84586: IFFALSE 84607
// MinerPlaceMine ( unit , x , y ) ;
84588: LD_VAR 0 2
84592: PPUSH
84593: LD_VAR 0 4
84597: PPUSH
84598: LD_VAR 0 5
84602: PPUSH
84603: CALL 86982 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84607: LD_VAR 0 1
84611: PUSH
84612: LD_INT 251
84614: EQUAL
84615: PUSH
84616: LD_VAR 0 2
84620: PPUSH
84621: CALL_OW 264
84625: PUSH
84626: LD_EXP 92
84630: EQUAL
84631: AND
84632: IFFALSE 84653
// MinerDetonateMine ( unit , x , y ) ;
84634: LD_VAR 0 2
84638: PPUSH
84639: LD_VAR 0 4
84643: PPUSH
84644: LD_VAR 0 5
84648: PPUSH
84649: CALL 87259 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
84653: LD_VAR 0 1
84657: PUSH
84658: LD_INT 252
84660: EQUAL
84661: PUSH
84662: LD_VAR 0 2
84666: PPUSH
84667: CALL_OW 264
84671: PUSH
84672: LD_EXP 92
84676: EQUAL
84677: AND
84678: IFFALSE 84699
// MinerCreateMinefield ( unit , x , y ) ;
84680: LD_VAR 0 2
84684: PPUSH
84685: LD_VAR 0 4
84689: PPUSH
84690: LD_VAR 0 5
84694: PPUSH
84695: CALL 87676 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
84699: LD_VAR 0 1
84703: PUSH
84704: LD_INT 253
84706: EQUAL
84707: PUSH
84708: LD_VAR 0 2
84712: PPUSH
84713: CALL_OW 257
84717: PUSH
84718: LD_INT 5
84720: EQUAL
84721: AND
84722: IFFALSE 84743
// ComBinocular ( unit , x , y ) ;
84724: LD_VAR 0 2
84728: PPUSH
84729: LD_VAR 0 4
84733: PPUSH
84734: LD_VAR 0 5
84738: PPUSH
84739: CALL 88047 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
84743: LD_VAR 0 1
84747: PUSH
84748: LD_INT 254
84750: EQUAL
84751: PUSH
84752: LD_VAR 0 2
84756: PPUSH
84757: CALL_OW 264
84761: PUSH
84762: LD_EXP 87
84766: EQUAL
84767: AND
84768: PUSH
84769: LD_VAR 0 3
84773: PPUSH
84774: CALL_OW 263
84778: PUSH
84779: LD_INT 3
84781: EQUAL
84782: AND
84783: IFFALSE 84799
// HackDestroyVehicle ( unit , selectedUnit ) ;
84785: LD_VAR 0 2
84789: PPUSH
84790: LD_VAR 0 3
84794: PPUSH
84795: CALL 86342 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
84799: LD_VAR 0 1
84803: PUSH
84804: LD_INT 255
84806: EQUAL
84807: PUSH
84808: LD_VAR 0 2
84812: PPUSH
84813: CALL_OW 264
84817: PUSH
84818: LD_INT 14
84820: PUSH
84821: LD_INT 53
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: IN
84828: AND
84829: PUSH
84830: LD_VAR 0 4
84834: PPUSH
84835: LD_VAR 0 5
84839: PPUSH
84840: CALL_OW 488
84844: AND
84845: IFFALSE 84869
// CutTreeXYR ( unit , x , y , 12 ) ;
84847: LD_VAR 0 2
84851: PPUSH
84852: LD_VAR 0 4
84856: PPUSH
84857: LD_VAR 0 5
84861: PPUSH
84862: LD_INT 12
84864: PPUSH
84865: CALL 84908 0 4
// end ;
84869: LD_VAR 0 6
84873: RET
// export initPlantMineScript , plantMineList ; every 1 trigger not initPlantMineScript do
84874: LD_EXP 101
84878: NOT
84879: IFFALSE 84899
84881: GO 84883
84883: DISABLE
// begin initPlantMineScript := true ;
84884: LD_ADDR_EXP 101
84888: PUSH
84889: LD_INT 1
84891: ST_TO_ADDR
// plantMineList := [ ] ;
84892: LD_ADDR_EXP 102
84896: PUSH
84897: EMPTY
84898: ST_TO_ADDR
// end ;
84899: END
// export function ComGroupPlantMineXY ( units , x , y ) ; begin
84900: LD_INT 0
84902: PPUSH
// end ;
84903: LD_VAR 0 4
84907: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
84908: LD_INT 0
84910: PPUSH
84911: PPUSH
84912: PPUSH
84913: PPUSH
84914: PPUSH
84915: PPUSH
84916: PPUSH
84917: PPUSH
84918: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
84919: LD_VAR 0 1
84923: NOT
84924: PUSH
84925: LD_VAR 0 2
84929: PPUSH
84930: LD_VAR 0 3
84934: PPUSH
84935: CALL_OW 488
84939: NOT
84940: OR
84941: PUSH
84942: LD_VAR 0 4
84946: NOT
84947: OR
84948: IFFALSE 84952
// exit ;
84950: GO 85292
// list := [ ] ;
84952: LD_ADDR_VAR 0 13
84956: PUSH
84957: EMPTY
84958: ST_TO_ADDR
// if x - r < 0 then
84959: LD_VAR 0 2
84963: PUSH
84964: LD_VAR 0 4
84968: MINUS
84969: PUSH
84970: LD_INT 0
84972: LESS
84973: IFFALSE 84985
// min_x := 0 else
84975: LD_ADDR_VAR 0 7
84979: PUSH
84980: LD_INT 0
84982: ST_TO_ADDR
84983: GO 85001
// min_x := x - r ;
84985: LD_ADDR_VAR 0 7
84989: PUSH
84990: LD_VAR 0 2
84994: PUSH
84995: LD_VAR 0 4
84999: MINUS
85000: ST_TO_ADDR
// if y - r < 0 then
85001: LD_VAR 0 3
85005: PUSH
85006: LD_VAR 0 4
85010: MINUS
85011: PUSH
85012: LD_INT 0
85014: LESS
85015: IFFALSE 85027
// min_y := 0 else
85017: LD_ADDR_VAR 0 8
85021: PUSH
85022: LD_INT 0
85024: ST_TO_ADDR
85025: GO 85043
// min_y := y - r ;
85027: LD_ADDR_VAR 0 8
85031: PUSH
85032: LD_VAR 0 3
85036: PUSH
85037: LD_VAR 0 4
85041: MINUS
85042: ST_TO_ADDR
// max_x := x + r ;
85043: LD_ADDR_VAR 0 9
85047: PUSH
85048: LD_VAR 0 2
85052: PUSH
85053: LD_VAR 0 4
85057: PLUS
85058: ST_TO_ADDR
// max_y := y + r ;
85059: LD_ADDR_VAR 0 10
85063: PUSH
85064: LD_VAR 0 3
85068: PUSH
85069: LD_VAR 0 4
85073: PLUS
85074: ST_TO_ADDR
// for _x = min_x to max_x do
85075: LD_ADDR_VAR 0 11
85079: PUSH
85080: DOUBLE
85081: LD_VAR 0 7
85085: DEC
85086: ST_TO_ADDR
85087: LD_VAR 0 9
85091: PUSH
85092: FOR_TO
85093: IFFALSE 85210
// for _y = min_y to max_y do
85095: LD_ADDR_VAR 0 12
85099: PUSH
85100: DOUBLE
85101: LD_VAR 0 8
85105: DEC
85106: ST_TO_ADDR
85107: LD_VAR 0 10
85111: PUSH
85112: FOR_TO
85113: IFFALSE 85206
// begin if not ValidHex ( _x , _y ) then
85115: LD_VAR 0 11
85119: PPUSH
85120: LD_VAR 0 12
85124: PPUSH
85125: CALL_OW 488
85129: NOT
85130: IFFALSE 85134
// continue ;
85132: GO 85112
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85134: LD_VAR 0 11
85138: PPUSH
85139: LD_VAR 0 12
85143: PPUSH
85144: CALL_OW 351
85148: PUSH
85149: LD_VAR 0 11
85153: PPUSH
85154: LD_VAR 0 12
85158: PPUSH
85159: CALL_OW 554
85163: AND
85164: IFFALSE 85204
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85166: LD_ADDR_VAR 0 13
85170: PUSH
85171: LD_VAR 0 13
85175: PPUSH
85176: LD_VAR 0 13
85180: PUSH
85181: LD_INT 1
85183: PLUS
85184: PPUSH
85185: LD_VAR 0 11
85189: PUSH
85190: LD_VAR 0 12
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PPUSH
85199: CALL_OW 2
85203: ST_TO_ADDR
// end ;
85204: GO 85112
85206: POP
85207: POP
85208: GO 85092
85210: POP
85211: POP
// if not list then
85212: LD_VAR 0 13
85216: NOT
85217: IFFALSE 85221
// exit ;
85219: GO 85292
// for i in list do
85221: LD_ADDR_VAR 0 6
85225: PUSH
85226: LD_VAR 0 13
85230: PUSH
85231: FOR_IN
85232: IFFALSE 85290
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85234: LD_VAR 0 1
85238: PPUSH
85239: LD_STRING M
85241: PUSH
85242: LD_VAR 0 6
85246: PUSH
85247: LD_INT 1
85249: ARRAY
85250: PUSH
85251: LD_VAR 0 6
85255: PUSH
85256: LD_INT 2
85258: ARRAY
85259: PUSH
85260: LD_INT 0
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: PUSH
85281: EMPTY
85282: LIST
85283: PPUSH
85284: CALL_OW 447
85288: GO 85231
85290: POP
85291: POP
// end ;
85292: LD_VAR 0 5
85296: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85297: LD_EXP 103
85301: NOT
85302: IFFALSE 85352
85304: GO 85306
85306: DISABLE
// begin initHack := true ;
85307: LD_ADDR_EXP 103
85311: PUSH
85312: LD_INT 1
85314: ST_TO_ADDR
// hackTanks := [ ] ;
85315: LD_ADDR_EXP 104
85319: PUSH
85320: EMPTY
85321: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85322: LD_ADDR_EXP 105
85326: PUSH
85327: EMPTY
85328: ST_TO_ADDR
// hackLimit := 3 ;
85329: LD_ADDR_EXP 106
85333: PUSH
85334: LD_INT 3
85336: ST_TO_ADDR
// hackDist := 12 ;
85337: LD_ADDR_EXP 107
85341: PUSH
85342: LD_INT 12
85344: ST_TO_ADDR
// hackCounter := [ ] ;
85345: LD_ADDR_EXP 108
85349: PUSH
85350: EMPTY
85351: ST_TO_ADDR
// end ;
85352: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85353: LD_EXP 103
85357: PUSH
85358: LD_INT 34
85360: PUSH
85361: LD_EXP 87
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PPUSH
85370: CALL_OW 69
85374: AND
85375: IFFALSE 85630
85377: GO 85379
85379: DISABLE
85380: LD_INT 0
85382: PPUSH
85383: PPUSH
// begin enable ;
85384: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85385: LD_ADDR_VAR 0 1
85389: PUSH
85390: LD_INT 34
85392: PUSH
85393: LD_EXP 87
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: PPUSH
85402: CALL_OW 69
85406: PUSH
85407: FOR_IN
85408: IFFALSE 85628
// begin if not i in hackTanks then
85410: LD_VAR 0 1
85414: PUSH
85415: LD_EXP 104
85419: IN
85420: NOT
85421: IFFALSE 85504
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85423: LD_ADDR_EXP 104
85427: PUSH
85428: LD_EXP 104
85432: PPUSH
85433: LD_EXP 104
85437: PUSH
85438: LD_INT 1
85440: PLUS
85441: PPUSH
85442: LD_VAR 0 1
85446: PPUSH
85447: CALL_OW 1
85451: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85452: LD_ADDR_EXP 105
85456: PUSH
85457: LD_EXP 105
85461: PPUSH
85462: LD_EXP 105
85466: PUSH
85467: LD_INT 1
85469: PLUS
85470: PPUSH
85471: EMPTY
85472: PPUSH
85473: CALL_OW 1
85477: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85478: LD_ADDR_EXP 108
85482: PUSH
85483: LD_EXP 108
85487: PPUSH
85488: LD_EXP 108
85492: PUSH
85493: LD_INT 1
85495: PLUS
85496: PPUSH
85497: EMPTY
85498: PPUSH
85499: CALL_OW 1
85503: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85504: LD_VAR 0 1
85508: PPUSH
85509: CALL_OW 302
85513: NOT
85514: IFFALSE 85527
// begin HackUnlinkAll ( i ) ;
85516: LD_VAR 0 1
85520: PPUSH
85521: CALL 85633 0 1
// continue ;
85525: GO 85407
// end ; HackCheckCapturedStatus ( i ) ;
85527: LD_VAR 0 1
85531: PPUSH
85532: CALL 86076 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85536: LD_ADDR_VAR 0 2
85540: PUSH
85541: LD_INT 81
85543: PUSH
85544: LD_VAR 0 1
85548: PPUSH
85549: CALL_OW 255
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 33
85560: PUSH
85561: LD_INT 3
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 91
85570: PUSH
85571: LD_VAR 0 1
85575: PUSH
85576: LD_EXP 107
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 50
85588: PUSH
85589: EMPTY
85590: LIST
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: PPUSH
85598: CALL_OW 69
85602: ST_TO_ADDR
// if not tmp then
85603: LD_VAR 0 2
85607: NOT
85608: IFFALSE 85612
// continue ;
85610: GO 85407
// HackLink ( i , tmp ) ;
85612: LD_VAR 0 1
85616: PPUSH
85617: LD_VAR 0 2
85621: PPUSH
85622: CALL 85769 0 2
// end ;
85626: GO 85407
85628: POP
85629: POP
// end ;
85630: PPOPN 2
85632: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85633: LD_INT 0
85635: PPUSH
85636: PPUSH
85637: PPUSH
// if not hack in hackTanks then
85638: LD_VAR 0 1
85642: PUSH
85643: LD_EXP 104
85647: IN
85648: NOT
85649: IFFALSE 85653
// exit ;
85651: GO 85764
// index := GetElementIndex ( hackTanks , hack ) ;
85653: LD_ADDR_VAR 0 4
85657: PUSH
85658: LD_EXP 104
85662: PPUSH
85663: LD_VAR 0 1
85667: PPUSH
85668: CALL 14535 0 2
85672: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85673: LD_EXP 105
85677: PUSH
85678: LD_VAR 0 4
85682: ARRAY
85683: IFFALSE 85764
// begin for i in hackTanksCaptured [ index ] do
85685: LD_ADDR_VAR 0 3
85689: PUSH
85690: LD_EXP 105
85694: PUSH
85695: LD_VAR 0 4
85699: ARRAY
85700: PUSH
85701: FOR_IN
85702: IFFALSE 85728
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
85704: LD_VAR 0 3
85708: PUSH
85709: LD_INT 1
85711: ARRAY
85712: PPUSH
85713: LD_VAR 0 3
85717: PUSH
85718: LD_INT 2
85720: ARRAY
85721: PPUSH
85722: CALL_OW 235
85726: GO 85701
85728: POP
85729: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
85730: LD_ADDR_EXP 105
85734: PUSH
85735: LD_EXP 105
85739: PPUSH
85740: LD_VAR 0 4
85744: PPUSH
85745: EMPTY
85746: PPUSH
85747: CALL_OW 1
85751: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
85752: LD_VAR 0 1
85756: PPUSH
85757: LD_INT 0
85759: PPUSH
85760: CALL_OW 505
// end ; end ;
85764: LD_VAR 0 2
85768: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
85769: LD_INT 0
85771: PPUSH
85772: PPUSH
85773: PPUSH
// if not hack in hackTanks or not vehicles then
85774: LD_VAR 0 1
85778: PUSH
85779: LD_EXP 104
85783: IN
85784: NOT
85785: PUSH
85786: LD_VAR 0 2
85790: NOT
85791: OR
85792: IFFALSE 85796
// exit ;
85794: GO 86071
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
85796: LD_ADDR_VAR 0 2
85800: PUSH
85801: LD_VAR 0 1
85805: PPUSH
85806: LD_VAR 0 2
85810: PPUSH
85811: LD_INT 1
85813: PPUSH
85814: LD_INT 1
85816: PPUSH
85817: CALL 15185 0 4
85821: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
85822: LD_ADDR_VAR 0 5
85826: PUSH
85827: LD_EXP 104
85831: PPUSH
85832: LD_VAR 0 1
85836: PPUSH
85837: CALL 14535 0 2
85841: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
85842: LD_EXP 105
85846: PUSH
85847: LD_VAR 0 5
85851: ARRAY
85852: PUSH
85853: LD_EXP 106
85857: LESS
85858: IFFALSE 86047
// begin for i := 1 to vehicles do
85860: LD_ADDR_VAR 0 4
85864: PUSH
85865: DOUBLE
85866: LD_INT 1
85868: DEC
85869: ST_TO_ADDR
85870: LD_VAR 0 2
85874: PUSH
85875: FOR_TO
85876: IFFALSE 86045
// begin if hackTanksCaptured [ index ] = hackLimit then
85878: LD_EXP 105
85882: PUSH
85883: LD_VAR 0 5
85887: ARRAY
85888: PUSH
85889: LD_EXP 106
85893: EQUAL
85894: IFFALSE 85898
// break ;
85896: GO 86045
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
85898: LD_ADDR_EXP 108
85902: PUSH
85903: LD_EXP 108
85907: PPUSH
85908: LD_VAR 0 5
85912: PPUSH
85913: LD_EXP 108
85917: PUSH
85918: LD_VAR 0 5
85922: ARRAY
85923: PUSH
85924: LD_INT 1
85926: PLUS
85927: PPUSH
85928: CALL_OW 1
85932: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
85933: LD_ADDR_EXP 105
85937: PUSH
85938: LD_EXP 105
85942: PPUSH
85943: LD_VAR 0 5
85947: PUSH
85948: LD_EXP 105
85952: PUSH
85953: LD_VAR 0 5
85957: ARRAY
85958: PUSH
85959: LD_INT 1
85961: PLUS
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PPUSH
85967: LD_VAR 0 2
85971: PUSH
85972: LD_VAR 0 4
85976: ARRAY
85977: PUSH
85978: LD_VAR 0 2
85982: PUSH
85983: LD_VAR 0 4
85987: ARRAY
85988: PPUSH
85989: CALL_OW 255
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PPUSH
85998: CALL 14750 0 3
86002: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86003: LD_VAR 0 2
86007: PUSH
86008: LD_VAR 0 4
86012: ARRAY
86013: PPUSH
86014: LD_VAR 0 1
86018: PPUSH
86019: CALL_OW 255
86023: PPUSH
86024: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86028: LD_VAR 0 2
86032: PUSH
86033: LD_VAR 0 4
86037: ARRAY
86038: PPUSH
86039: CALL_OW 141
// end ;
86043: GO 85875
86045: POP
86046: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86047: LD_VAR 0 1
86051: PPUSH
86052: LD_EXP 105
86056: PUSH
86057: LD_VAR 0 5
86061: ARRAY
86062: PUSH
86063: LD_INT 0
86065: PLUS
86066: PPUSH
86067: CALL_OW 505
// end ;
86071: LD_VAR 0 3
86075: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86076: LD_INT 0
86078: PPUSH
86079: PPUSH
86080: PPUSH
86081: PPUSH
// if not hack in hackTanks then
86082: LD_VAR 0 1
86086: PUSH
86087: LD_EXP 104
86091: IN
86092: NOT
86093: IFFALSE 86097
// exit ;
86095: GO 86337
// index := GetElementIndex ( hackTanks , hack ) ;
86097: LD_ADDR_VAR 0 4
86101: PUSH
86102: LD_EXP 104
86106: PPUSH
86107: LD_VAR 0 1
86111: PPUSH
86112: CALL 14535 0 2
86116: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86117: LD_ADDR_VAR 0 3
86121: PUSH
86122: DOUBLE
86123: LD_EXP 105
86127: PUSH
86128: LD_VAR 0 4
86132: ARRAY
86133: INC
86134: ST_TO_ADDR
86135: LD_INT 1
86137: PUSH
86138: FOR_DOWNTO
86139: IFFALSE 86311
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86141: LD_ADDR_VAR 0 5
86145: PUSH
86146: LD_EXP 105
86150: PUSH
86151: LD_VAR 0 4
86155: ARRAY
86156: PUSH
86157: LD_VAR 0 3
86161: ARRAY
86162: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86163: LD_VAR 0 5
86167: PUSH
86168: LD_INT 1
86170: ARRAY
86171: PPUSH
86172: CALL_OW 302
86176: NOT
86177: PUSH
86178: LD_VAR 0 5
86182: PUSH
86183: LD_INT 1
86185: ARRAY
86186: PPUSH
86187: CALL_OW 255
86191: PUSH
86192: LD_VAR 0 1
86196: PPUSH
86197: CALL_OW 255
86201: NONEQUAL
86202: OR
86203: IFFALSE 86309
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86205: LD_VAR 0 5
86209: PUSH
86210: LD_INT 1
86212: ARRAY
86213: PPUSH
86214: CALL_OW 305
86218: PUSH
86219: LD_VAR 0 5
86223: PUSH
86224: LD_INT 1
86226: ARRAY
86227: PPUSH
86228: CALL_OW 255
86232: PUSH
86233: LD_VAR 0 1
86237: PPUSH
86238: CALL_OW 255
86242: EQUAL
86243: AND
86244: IFFALSE 86268
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86246: LD_VAR 0 5
86250: PUSH
86251: LD_INT 1
86253: ARRAY
86254: PPUSH
86255: LD_VAR 0 5
86259: PUSH
86260: LD_INT 2
86262: ARRAY
86263: PPUSH
86264: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86268: LD_ADDR_EXP 105
86272: PUSH
86273: LD_EXP 105
86277: PPUSH
86278: LD_VAR 0 4
86282: PPUSH
86283: LD_EXP 105
86287: PUSH
86288: LD_VAR 0 4
86292: ARRAY
86293: PPUSH
86294: LD_VAR 0 3
86298: PPUSH
86299: CALL_OW 3
86303: PPUSH
86304: CALL_OW 1
86308: ST_TO_ADDR
// end ; end ;
86309: GO 86138
86311: POP
86312: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86313: LD_VAR 0 1
86317: PPUSH
86318: LD_EXP 105
86322: PUSH
86323: LD_VAR 0 4
86327: ARRAY
86328: PUSH
86329: LD_INT 0
86331: PLUS
86332: PPUSH
86333: CALL_OW 505
// end ;
86337: LD_VAR 0 2
86341: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86342: LD_INT 0
86344: PPUSH
86345: PPUSH
86346: PPUSH
86347: PPUSH
// if not hack in hackTanks then
86348: LD_VAR 0 1
86352: PUSH
86353: LD_EXP 104
86357: IN
86358: NOT
86359: IFFALSE 86363
// exit ;
86361: GO 86448
// index := GetElementIndex ( hackTanks , hack ) ;
86363: LD_ADDR_VAR 0 5
86367: PUSH
86368: LD_EXP 104
86372: PPUSH
86373: LD_VAR 0 1
86377: PPUSH
86378: CALL 14535 0 2
86382: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86383: LD_ADDR_VAR 0 4
86387: PUSH
86388: DOUBLE
86389: LD_INT 1
86391: DEC
86392: ST_TO_ADDR
86393: LD_EXP 105
86397: PUSH
86398: LD_VAR 0 5
86402: ARRAY
86403: PUSH
86404: FOR_TO
86405: IFFALSE 86446
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86407: LD_EXP 105
86411: PUSH
86412: LD_VAR 0 5
86416: ARRAY
86417: PUSH
86418: LD_VAR 0 4
86422: ARRAY
86423: PUSH
86424: LD_INT 1
86426: ARRAY
86427: PUSH
86428: LD_VAR 0 2
86432: EQUAL
86433: IFFALSE 86444
// KillUnit ( vehicle ) ;
86435: LD_VAR 0 2
86439: PPUSH
86440: CALL_OW 66
86444: GO 86404
86446: POP
86447: POP
// end ;
86448: LD_VAR 0 3
86452: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86453: LD_EXP 109
86457: NOT
86458: IFFALSE 86493
86460: GO 86462
86462: DISABLE
// begin initMiner := true ;
86463: LD_ADDR_EXP 109
86467: PUSH
86468: LD_INT 1
86470: ST_TO_ADDR
// minersList := [ ] ;
86471: LD_ADDR_EXP 110
86475: PUSH
86476: EMPTY
86477: ST_TO_ADDR
// minerMinesList := [ ] ;
86478: LD_ADDR_EXP 111
86482: PUSH
86483: EMPTY
86484: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86485: LD_ADDR_EXP 112
86489: PUSH
86490: LD_INT 5
86492: ST_TO_ADDR
// end ;
86493: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86494: LD_EXP 109
86498: PUSH
86499: LD_INT 34
86501: PUSH
86502: LD_EXP 92
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PPUSH
86511: CALL_OW 69
86515: AND
86516: IFFALSE 86979
86518: GO 86520
86520: DISABLE
86521: LD_INT 0
86523: PPUSH
86524: PPUSH
86525: PPUSH
86526: PPUSH
// begin enable ;
86527: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86528: LD_ADDR_VAR 0 1
86532: PUSH
86533: LD_INT 34
86535: PUSH
86536: LD_EXP 92
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PPUSH
86545: CALL_OW 69
86549: PUSH
86550: FOR_IN
86551: IFFALSE 86623
// begin if not i in minersList then
86553: LD_VAR 0 1
86557: PUSH
86558: LD_EXP 110
86562: IN
86563: NOT
86564: IFFALSE 86621
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86566: LD_ADDR_EXP 110
86570: PUSH
86571: LD_EXP 110
86575: PPUSH
86576: LD_EXP 110
86580: PUSH
86581: LD_INT 1
86583: PLUS
86584: PPUSH
86585: LD_VAR 0 1
86589: PPUSH
86590: CALL_OW 1
86594: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86595: LD_ADDR_EXP 111
86599: PUSH
86600: LD_EXP 111
86604: PPUSH
86605: LD_EXP 111
86609: PUSH
86610: LD_INT 1
86612: PLUS
86613: PPUSH
86614: EMPTY
86615: PPUSH
86616: CALL_OW 1
86620: ST_TO_ADDR
// end end ;
86621: GO 86550
86623: POP
86624: POP
// for i := minerMinesList downto 1 do
86625: LD_ADDR_VAR 0 1
86629: PUSH
86630: DOUBLE
86631: LD_EXP 111
86635: INC
86636: ST_TO_ADDR
86637: LD_INT 1
86639: PUSH
86640: FOR_DOWNTO
86641: IFFALSE 86977
// begin if IsLive ( minersList [ i ] ) then
86643: LD_EXP 110
86647: PUSH
86648: LD_VAR 0 1
86652: ARRAY
86653: PPUSH
86654: CALL_OW 300
86658: IFFALSE 86686
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86660: LD_EXP 110
86664: PUSH
86665: LD_VAR 0 1
86669: ARRAY
86670: PPUSH
86671: LD_EXP 111
86675: PUSH
86676: LD_VAR 0 1
86680: ARRAY
86681: PPUSH
86682: CALL_OW 505
// if not minerMinesList [ i ] then
86686: LD_EXP 111
86690: PUSH
86691: LD_VAR 0 1
86695: ARRAY
86696: NOT
86697: IFFALSE 86701
// continue ;
86699: GO 86640
// for j := minerMinesList [ i ] downto 1 do
86701: LD_ADDR_VAR 0 2
86705: PUSH
86706: DOUBLE
86707: LD_EXP 111
86711: PUSH
86712: LD_VAR 0 1
86716: ARRAY
86717: INC
86718: ST_TO_ADDR
86719: LD_INT 1
86721: PUSH
86722: FOR_DOWNTO
86723: IFFALSE 86973
// begin side := GetSide ( minersList [ i ] ) ;
86725: LD_ADDR_VAR 0 3
86729: PUSH
86730: LD_EXP 110
86734: PUSH
86735: LD_VAR 0 1
86739: ARRAY
86740: PPUSH
86741: CALL_OW 255
86745: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
86746: LD_ADDR_VAR 0 4
86750: PUSH
86751: LD_EXP 111
86755: PUSH
86756: LD_VAR 0 1
86760: ARRAY
86761: PUSH
86762: LD_VAR 0 2
86766: ARRAY
86767: PUSH
86768: LD_INT 1
86770: ARRAY
86771: PPUSH
86772: LD_EXP 111
86776: PUSH
86777: LD_VAR 0 1
86781: ARRAY
86782: PUSH
86783: LD_VAR 0 2
86787: ARRAY
86788: PUSH
86789: LD_INT 2
86791: ARRAY
86792: PPUSH
86793: CALL_OW 428
86797: ST_TO_ADDR
// if not tmp then
86798: LD_VAR 0 4
86802: NOT
86803: IFFALSE 86807
// continue ;
86805: GO 86722
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
86807: LD_VAR 0 4
86811: PUSH
86812: LD_INT 81
86814: PUSH
86815: LD_VAR 0 3
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PPUSH
86824: CALL_OW 69
86828: IN
86829: PUSH
86830: LD_EXP 111
86834: PUSH
86835: LD_VAR 0 1
86839: ARRAY
86840: PUSH
86841: LD_VAR 0 2
86845: ARRAY
86846: PUSH
86847: LD_INT 1
86849: ARRAY
86850: PPUSH
86851: LD_EXP 111
86855: PUSH
86856: LD_VAR 0 1
86860: ARRAY
86861: PUSH
86862: LD_VAR 0 2
86866: ARRAY
86867: PUSH
86868: LD_INT 2
86870: ARRAY
86871: PPUSH
86872: CALL_OW 458
86876: AND
86877: IFFALSE 86971
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
86879: LD_EXP 111
86883: PUSH
86884: LD_VAR 0 1
86888: ARRAY
86889: PUSH
86890: LD_VAR 0 2
86894: ARRAY
86895: PUSH
86896: LD_INT 1
86898: ARRAY
86899: PPUSH
86900: LD_EXP 111
86904: PUSH
86905: LD_VAR 0 1
86909: ARRAY
86910: PUSH
86911: LD_VAR 0 2
86915: ARRAY
86916: PUSH
86917: LD_INT 2
86919: ARRAY
86920: PPUSH
86921: LD_VAR 0 3
86925: PPUSH
86926: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
86930: LD_ADDR_EXP 111
86934: PUSH
86935: LD_EXP 111
86939: PPUSH
86940: LD_VAR 0 1
86944: PPUSH
86945: LD_EXP 111
86949: PUSH
86950: LD_VAR 0 1
86954: ARRAY
86955: PPUSH
86956: LD_VAR 0 2
86960: PPUSH
86961: CALL_OW 3
86965: PPUSH
86966: CALL_OW 1
86970: ST_TO_ADDR
// end ; end ;
86971: GO 86722
86973: POP
86974: POP
// end ;
86975: GO 86640
86977: POP
86978: POP
// end ;
86979: PPOPN 4
86981: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
86982: LD_INT 0
86984: PPUSH
86985: PPUSH
// result := false ;
86986: LD_ADDR_VAR 0 4
86990: PUSH
86991: LD_INT 0
86993: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
86994: LD_VAR 0 1
86998: PPUSH
86999: CALL_OW 264
87003: PUSH
87004: LD_EXP 92
87008: EQUAL
87009: NOT
87010: IFFALSE 87014
// exit ;
87012: GO 87254
// index := GetElementIndex ( minersList , unit ) ;
87014: LD_ADDR_VAR 0 5
87018: PUSH
87019: LD_EXP 110
87023: PPUSH
87024: LD_VAR 0 1
87028: PPUSH
87029: CALL 14535 0 2
87033: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87034: LD_EXP 111
87038: PUSH
87039: LD_VAR 0 5
87043: ARRAY
87044: PUSH
87045: LD_EXP 112
87049: GREATEREQUAL
87050: IFFALSE 87054
// exit ;
87052: GO 87254
// ComMoveXY ( unit , x , y ) ;
87054: LD_VAR 0 1
87058: PPUSH
87059: LD_VAR 0 2
87063: PPUSH
87064: LD_VAR 0 3
87068: PPUSH
87069: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87073: LD_INT 35
87075: PPUSH
87076: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87080: LD_VAR 0 1
87084: PPUSH
87085: LD_VAR 0 2
87089: PPUSH
87090: LD_VAR 0 3
87094: PPUSH
87095: CALL 44599 0 3
87099: NOT
87100: PUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: CALL_OW 314
87110: AND
87111: IFFALSE 87115
// exit ;
87113: GO 87254
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87115: LD_VAR 0 2
87119: PPUSH
87120: LD_VAR 0 3
87124: PPUSH
87125: CALL_OW 428
87129: PUSH
87130: LD_VAR 0 1
87134: EQUAL
87135: PUSH
87136: LD_VAR 0 1
87140: PPUSH
87141: CALL_OW 314
87145: NOT
87146: AND
87147: IFFALSE 87073
// PlaySoundXY ( x , y , PlantMine ) ;
87149: LD_VAR 0 2
87153: PPUSH
87154: LD_VAR 0 3
87158: PPUSH
87159: LD_STRING PlantMine
87161: PPUSH
87162: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87166: LD_VAR 0 2
87170: PPUSH
87171: LD_VAR 0 3
87175: PPUSH
87176: LD_VAR 0 1
87180: PPUSH
87181: CALL_OW 255
87185: PPUSH
87186: LD_INT 0
87188: PPUSH
87189: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87193: LD_ADDR_EXP 111
87197: PUSH
87198: LD_EXP 111
87202: PPUSH
87203: LD_VAR 0 5
87207: PUSH
87208: LD_EXP 111
87212: PUSH
87213: LD_VAR 0 5
87217: ARRAY
87218: PUSH
87219: LD_INT 1
87221: PLUS
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PPUSH
87227: LD_VAR 0 2
87231: PUSH
87232: LD_VAR 0 3
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PPUSH
87241: CALL 14750 0 3
87245: ST_TO_ADDR
// result := true ;
87246: LD_ADDR_VAR 0 4
87250: PUSH
87251: LD_INT 1
87253: ST_TO_ADDR
// end ;
87254: LD_VAR 0 4
87258: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87259: LD_INT 0
87261: PPUSH
87262: PPUSH
87263: PPUSH
// if not unit in minersList then
87264: LD_VAR 0 1
87268: PUSH
87269: LD_EXP 110
87273: IN
87274: NOT
87275: IFFALSE 87279
// exit ;
87277: GO 87671
// index := GetElementIndex ( minersList , unit ) ;
87279: LD_ADDR_VAR 0 6
87283: PUSH
87284: LD_EXP 110
87288: PPUSH
87289: LD_VAR 0 1
87293: PPUSH
87294: CALL 14535 0 2
87298: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87299: LD_ADDR_VAR 0 5
87303: PUSH
87304: DOUBLE
87305: LD_EXP 111
87309: PUSH
87310: LD_VAR 0 6
87314: ARRAY
87315: INC
87316: ST_TO_ADDR
87317: LD_INT 1
87319: PUSH
87320: FOR_DOWNTO
87321: IFFALSE 87482
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87323: LD_EXP 111
87327: PUSH
87328: LD_VAR 0 6
87332: ARRAY
87333: PUSH
87334: LD_VAR 0 5
87338: ARRAY
87339: PUSH
87340: LD_INT 1
87342: ARRAY
87343: PUSH
87344: LD_VAR 0 2
87348: EQUAL
87349: PUSH
87350: LD_EXP 111
87354: PUSH
87355: LD_VAR 0 6
87359: ARRAY
87360: PUSH
87361: LD_VAR 0 5
87365: ARRAY
87366: PUSH
87367: LD_INT 2
87369: ARRAY
87370: PUSH
87371: LD_VAR 0 3
87375: EQUAL
87376: AND
87377: IFFALSE 87480
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87379: LD_EXP 111
87383: PUSH
87384: LD_VAR 0 6
87388: ARRAY
87389: PUSH
87390: LD_VAR 0 5
87394: ARRAY
87395: PUSH
87396: LD_INT 1
87398: ARRAY
87399: PPUSH
87400: LD_EXP 111
87404: PUSH
87405: LD_VAR 0 6
87409: ARRAY
87410: PUSH
87411: LD_VAR 0 5
87415: ARRAY
87416: PUSH
87417: LD_INT 2
87419: ARRAY
87420: PPUSH
87421: LD_VAR 0 1
87425: PPUSH
87426: CALL_OW 255
87430: PPUSH
87431: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87435: LD_ADDR_EXP 111
87439: PUSH
87440: LD_EXP 111
87444: PPUSH
87445: LD_VAR 0 6
87449: PPUSH
87450: LD_EXP 111
87454: PUSH
87455: LD_VAR 0 6
87459: ARRAY
87460: PPUSH
87461: LD_VAR 0 5
87465: PPUSH
87466: CALL_OW 3
87470: PPUSH
87471: CALL_OW 1
87475: ST_TO_ADDR
// exit ;
87476: POP
87477: POP
87478: GO 87671
// end ; end ;
87480: GO 87320
87482: POP
87483: POP
// for i := minerMinesList [ index ] downto 1 do
87484: LD_ADDR_VAR 0 5
87488: PUSH
87489: DOUBLE
87490: LD_EXP 111
87494: PUSH
87495: LD_VAR 0 6
87499: ARRAY
87500: INC
87501: ST_TO_ADDR
87502: LD_INT 1
87504: PUSH
87505: FOR_DOWNTO
87506: IFFALSE 87669
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87508: LD_EXP 111
87512: PUSH
87513: LD_VAR 0 6
87517: ARRAY
87518: PUSH
87519: LD_VAR 0 5
87523: ARRAY
87524: PUSH
87525: LD_INT 1
87527: ARRAY
87528: PPUSH
87529: LD_EXP 111
87533: PUSH
87534: LD_VAR 0 6
87538: ARRAY
87539: PUSH
87540: LD_VAR 0 5
87544: ARRAY
87545: PUSH
87546: LD_INT 2
87548: ARRAY
87549: PPUSH
87550: LD_VAR 0 2
87554: PPUSH
87555: LD_VAR 0 3
87559: PPUSH
87560: CALL_OW 298
87564: PUSH
87565: LD_INT 6
87567: LESS
87568: IFFALSE 87667
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87570: LD_EXP 111
87574: PUSH
87575: LD_VAR 0 6
87579: ARRAY
87580: PUSH
87581: LD_VAR 0 5
87585: ARRAY
87586: PUSH
87587: LD_INT 1
87589: ARRAY
87590: PPUSH
87591: LD_EXP 111
87595: PUSH
87596: LD_VAR 0 6
87600: ARRAY
87601: PUSH
87602: LD_VAR 0 5
87606: ARRAY
87607: PUSH
87608: LD_INT 2
87610: ARRAY
87611: PPUSH
87612: LD_VAR 0 1
87616: PPUSH
87617: CALL_OW 255
87621: PPUSH
87622: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87626: LD_ADDR_EXP 111
87630: PUSH
87631: LD_EXP 111
87635: PPUSH
87636: LD_VAR 0 6
87640: PPUSH
87641: LD_EXP 111
87645: PUSH
87646: LD_VAR 0 6
87650: ARRAY
87651: PPUSH
87652: LD_VAR 0 5
87656: PPUSH
87657: CALL_OW 3
87661: PPUSH
87662: CALL_OW 1
87666: ST_TO_ADDR
// end ; end ;
87667: GO 87505
87669: POP
87670: POP
// end ;
87671: LD_VAR 0 4
87675: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87676: LD_INT 0
87678: PPUSH
87679: PPUSH
87680: PPUSH
87681: PPUSH
87682: PPUSH
87683: PPUSH
87684: PPUSH
87685: PPUSH
87686: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
87687: LD_VAR 0 1
87691: PPUSH
87692: CALL_OW 264
87696: PUSH
87697: LD_EXP 92
87701: EQUAL
87702: NOT
87703: PUSH
87704: LD_VAR 0 1
87708: PUSH
87709: LD_EXP 110
87713: IN
87714: NOT
87715: OR
87716: IFFALSE 87720
// exit ;
87718: GO 88042
// index := GetElementIndex ( minersList , unit ) ;
87720: LD_ADDR_VAR 0 6
87724: PUSH
87725: LD_EXP 110
87729: PPUSH
87730: LD_VAR 0 1
87734: PPUSH
87735: CALL 14535 0 2
87739: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
87740: LD_ADDR_VAR 0 8
87744: PUSH
87745: LD_EXP 112
87749: PUSH
87750: LD_EXP 111
87754: PUSH
87755: LD_VAR 0 6
87759: ARRAY
87760: MINUS
87761: ST_TO_ADDR
// if not minesFreeAmount then
87762: LD_VAR 0 8
87766: NOT
87767: IFFALSE 87771
// exit ;
87769: GO 88042
// tmp := [ ] ;
87771: LD_ADDR_VAR 0 7
87775: PUSH
87776: EMPTY
87777: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
87778: LD_ADDR_VAR 0 5
87782: PUSH
87783: DOUBLE
87784: LD_INT 1
87786: DEC
87787: ST_TO_ADDR
87788: LD_VAR 0 8
87792: PUSH
87793: FOR_TO
87794: IFFALSE 87989
// begin _d := rand ( 0 , 5 ) ;
87796: LD_ADDR_VAR 0 11
87800: PUSH
87801: LD_INT 0
87803: PPUSH
87804: LD_INT 5
87806: PPUSH
87807: CALL_OW 12
87811: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
87812: LD_ADDR_VAR 0 12
87816: PUSH
87817: LD_INT 2
87819: PPUSH
87820: LD_INT 6
87822: PPUSH
87823: CALL_OW 12
87827: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
87828: LD_ADDR_VAR 0 9
87832: PUSH
87833: LD_VAR 0 2
87837: PPUSH
87838: LD_VAR 0 11
87842: PPUSH
87843: LD_VAR 0 12
87847: PPUSH
87848: CALL_OW 272
87852: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
87853: LD_ADDR_VAR 0 10
87857: PUSH
87858: LD_VAR 0 3
87862: PPUSH
87863: LD_VAR 0 11
87867: PPUSH
87868: LD_VAR 0 12
87872: PPUSH
87873: CALL_OW 273
87877: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
87878: LD_VAR 0 9
87882: PPUSH
87883: LD_VAR 0 10
87887: PPUSH
87888: CALL_OW 488
87892: PUSH
87893: LD_VAR 0 9
87897: PUSH
87898: LD_VAR 0 10
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_VAR 0 7
87911: IN
87912: NOT
87913: AND
87914: PUSH
87915: LD_VAR 0 9
87919: PPUSH
87920: LD_VAR 0 10
87924: PPUSH
87925: CALL_OW 458
87929: NOT
87930: AND
87931: IFFALSE 87973
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
87933: LD_ADDR_VAR 0 7
87937: PUSH
87938: LD_VAR 0 7
87942: PPUSH
87943: LD_VAR 0 7
87947: PUSH
87948: LD_INT 1
87950: PLUS
87951: PPUSH
87952: LD_VAR 0 9
87956: PUSH
87957: LD_VAR 0 10
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PPUSH
87966: CALL_OW 1
87970: ST_TO_ADDR
87971: GO 87987
// i := i - 1 ;
87973: LD_ADDR_VAR 0 5
87977: PUSH
87978: LD_VAR 0 5
87982: PUSH
87983: LD_INT 1
87985: MINUS
87986: ST_TO_ADDR
// end ;
87987: GO 87793
87989: POP
87990: POP
// for i in tmp do
87991: LD_ADDR_VAR 0 5
87995: PUSH
87996: LD_VAR 0 7
88000: PUSH
88001: FOR_IN
88002: IFFALSE 88040
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88004: LD_VAR 0 1
88008: PPUSH
88009: LD_VAR 0 5
88013: PUSH
88014: LD_INT 1
88016: ARRAY
88017: PPUSH
88018: LD_VAR 0 5
88022: PUSH
88023: LD_INT 2
88025: ARRAY
88026: PPUSH
88027: CALL 86982 0 3
88031: NOT
88032: IFFALSE 88038
// exit ;
88034: POP
88035: POP
88036: GO 88042
88038: GO 88001
88040: POP
88041: POP
// end ;
88042: LD_VAR 0 4
88046: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88047: LD_INT 0
88049: PPUSH
88050: PPUSH
88051: PPUSH
88052: PPUSH
88053: PPUSH
88054: PPUSH
88055: PPUSH
// if not GetClass ( unit ) = class_sniper then
88056: LD_VAR 0 1
88060: PPUSH
88061: CALL_OW 257
88065: PUSH
88066: LD_INT 5
88068: EQUAL
88069: NOT
88070: IFFALSE 88074
// exit ;
88072: GO 88462
// dist := 8 ;
88074: LD_ADDR_VAR 0 5
88078: PUSH
88079: LD_INT 8
88081: ST_TO_ADDR
// viewRange := 12 ;
88082: LD_ADDR_VAR 0 7
88086: PUSH
88087: LD_INT 12
88089: ST_TO_ADDR
// side := GetSide ( unit ) ;
88090: LD_ADDR_VAR 0 6
88094: PUSH
88095: LD_VAR 0 1
88099: PPUSH
88100: CALL_OW 255
88104: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88105: LD_INT 61
88107: PPUSH
88108: LD_VAR 0 6
88112: PPUSH
88113: CALL_OW 321
88117: PUSH
88118: LD_INT 2
88120: EQUAL
88121: IFFALSE 88131
// viewRange := 16 ;
88123: LD_ADDR_VAR 0 7
88127: PUSH
88128: LD_INT 16
88130: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88131: LD_VAR 0 1
88135: PPUSH
88136: LD_VAR 0 2
88140: PPUSH
88141: LD_VAR 0 3
88145: PPUSH
88146: CALL_OW 297
88150: PUSH
88151: LD_VAR 0 5
88155: GREATER
88156: IFFALSE 88235
// begin ComMoveXY ( unit , x , y ) ;
88158: LD_VAR 0 1
88162: PPUSH
88163: LD_VAR 0 2
88167: PPUSH
88168: LD_VAR 0 3
88172: PPUSH
88173: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88177: LD_INT 35
88179: PPUSH
88180: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88184: LD_VAR 0 1
88188: PPUSH
88189: LD_VAR 0 2
88193: PPUSH
88194: LD_VAR 0 3
88198: PPUSH
88199: CALL 44599 0 3
88203: NOT
88204: IFFALSE 88208
// exit ;
88206: GO 88462
// until GetDistUnitXY ( unit , x , y ) < dist ;
88208: LD_VAR 0 1
88212: PPUSH
88213: LD_VAR 0 2
88217: PPUSH
88218: LD_VAR 0 3
88222: PPUSH
88223: CALL_OW 297
88227: PUSH
88228: LD_VAR 0 5
88232: LESS
88233: IFFALSE 88177
// end ; ComTurnXY ( unit , x , y ) ;
88235: LD_VAR 0 1
88239: PPUSH
88240: LD_VAR 0 2
88244: PPUSH
88245: LD_VAR 0 3
88249: PPUSH
88250: CALL_OW 118
// wait ( 5 ) ;
88254: LD_INT 5
88256: PPUSH
88257: CALL_OW 67
// _d := GetDir ( unit ) ;
88261: LD_ADDR_VAR 0 10
88265: PUSH
88266: LD_VAR 0 1
88270: PPUSH
88271: CALL_OW 254
88275: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88276: LD_ADDR_VAR 0 8
88280: PUSH
88281: LD_VAR 0 1
88285: PPUSH
88286: CALL_OW 250
88290: PPUSH
88291: LD_VAR 0 10
88295: PPUSH
88296: LD_VAR 0 5
88300: PPUSH
88301: CALL_OW 272
88305: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88306: LD_ADDR_VAR 0 9
88310: PUSH
88311: LD_VAR 0 1
88315: PPUSH
88316: CALL_OW 251
88320: PPUSH
88321: LD_VAR 0 10
88325: PPUSH
88326: LD_VAR 0 5
88330: PPUSH
88331: CALL_OW 273
88335: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88336: LD_VAR 0 8
88340: PPUSH
88341: LD_VAR 0 9
88345: PPUSH
88346: CALL_OW 488
88350: NOT
88351: IFFALSE 88355
// exit ;
88353: GO 88462
// ComAnimCustom ( unit , 1 ) ;
88355: LD_VAR 0 1
88359: PPUSH
88360: LD_INT 1
88362: PPUSH
88363: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88367: LD_VAR 0 8
88371: PPUSH
88372: LD_VAR 0 9
88376: PPUSH
88377: LD_VAR 0 6
88381: PPUSH
88382: LD_VAR 0 7
88386: PPUSH
88387: CALL_OW 330
// repeat wait ( 1 ) ;
88391: LD_INT 1
88393: PPUSH
88394: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88398: LD_VAR 0 1
88402: PPUSH
88403: CALL_OW 316
88407: PUSH
88408: LD_VAR 0 1
88412: PPUSH
88413: CALL_OW 314
88417: OR
88418: PUSH
88419: LD_VAR 0 1
88423: PPUSH
88424: CALL_OW 302
88428: NOT
88429: OR
88430: PUSH
88431: LD_VAR 0 1
88435: PPUSH
88436: CALL_OW 301
88440: OR
88441: IFFALSE 88391
// RemoveSeeing ( _x , _y , side ) ;
88443: LD_VAR 0 8
88447: PPUSH
88448: LD_VAR 0 9
88452: PPUSH
88453: LD_VAR 0 6
88457: PPUSH
88458: CALL_OW 331
// end ; end_of_file
88462: LD_VAR 0 4
88466: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88467: LD_VAR 0 1
88471: PUSH
88472: LD_INT 200
88474: DOUBLE
88475: GREATEREQUAL
88476: IFFALSE 88484
88478: LD_INT 299
88480: DOUBLE
88481: LESSEQUAL
88482: IFTRUE 88486
88484: GO 88518
88486: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
88487: LD_VAR 0 1
88491: PPUSH
88492: LD_VAR 0 2
88496: PPUSH
88497: LD_VAR 0 3
88501: PPUSH
88502: LD_VAR 0 4
88506: PPUSH
88507: LD_VAR 0 5
88511: PPUSH
88512: CALL 84558 0 5
88516: GO 88595
88518: LD_INT 300
88520: DOUBLE
88521: GREATEREQUAL
88522: IFFALSE 88530
88524: LD_INT 399
88526: DOUBLE
88527: LESSEQUAL
88528: IFTRUE 88532
88530: GO 88594
88532: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
88533: LD_VAR 0 1
88537: PPUSH
88538: LD_VAR 0 2
88542: PPUSH
88543: LD_VAR 0 3
88547: PPUSH
88548: LD_VAR 0 4
88552: PPUSH
88553: LD_VAR 0 5
88557: PPUSH
88558: LD_VAR 0 6
88562: PPUSH
88563: LD_VAR 0 7
88567: PPUSH
88568: LD_VAR 0 8
88572: PPUSH
88573: LD_VAR 0 9
88577: PPUSH
88578: LD_VAR 0 10
88582: PPUSH
88583: LD_VAR 0 11
88587: PPUSH
88588: CALL 99785 0 11
88592: GO 88595
88594: POP
// end ; end_of_file
88595: PPOPN 11
88597: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
88598: LD_VAR 0 2
88602: PUSH
88603: LD_INT 100
88605: EQUAL
88606: IFFALSE 89555
// begin if not StreamModeActive then
88608: LD_EXP 113
88612: NOT
88613: IFFALSE 88623
// StreamModeActive := true ;
88615: LD_ADDR_EXP 113
88619: PUSH
88620: LD_INT 1
88622: ST_TO_ADDR
// if p3 = 0 then
88623: LD_VAR 0 3
88627: PUSH
88628: LD_INT 0
88630: EQUAL
88631: IFFALSE 88637
// InitStreamMode ;
88633: CALL 89713 0 0
// if p3 = 1 then
88637: LD_VAR 0 3
88641: PUSH
88642: LD_INT 1
88644: EQUAL
88645: IFFALSE 88655
// sRocket := true ;
88647: LD_ADDR_EXP 118
88651: PUSH
88652: LD_INT 1
88654: ST_TO_ADDR
// if p3 = 2 then
88655: LD_VAR 0 3
88659: PUSH
88660: LD_INT 2
88662: EQUAL
88663: IFFALSE 88673
// sSpeed := true ;
88665: LD_ADDR_EXP 117
88669: PUSH
88670: LD_INT 1
88672: ST_TO_ADDR
// if p3 = 3 then
88673: LD_VAR 0 3
88677: PUSH
88678: LD_INT 3
88680: EQUAL
88681: IFFALSE 88691
// sEngine := true ;
88683: LD_ADDR_EXP 119
88687: PUSH
88688: LD_INT 1
88690: ST_TO_ADDR
// if p3 = 4 then
88691: LD_VAR 0 3
88695: PUSH
88696: LD_INT 4
88698: EQUAL
88699: IFFALSE 88709
// sSpec := true ;
88701: LD_ADDR_EXP 116
88705: PUSH
88706: LD_INT 1
88708: ST_TO_ADDR
// if p3 = 5 then
88709: LD_VAR 0 3
88713: PUSH
88714: LD_INT 5
88716: EQUAL
88717: IFFALSE 88727
// sLevel := true ;
88719: LD_ADDR_EXP 120
88723: PUSH
88724: LD_INT 1
88726: ST_TO_ADDR
// if p3 = 6 then
88727: LD_VAR 0 3
88731: PUSH
88732: LD_INT 6
88734: EQUAL
88735: IFFALSE 88745
// sArmoury := true ;
88737: LD_ADDR_EXP 121
88741: PUSH
88742: LD_INT 1
88744: ST_TO_ADDR
// if p3 = 7 then
88745: LD_VAR 0 3
88749: PUSH
88750: LD_INT 7
88752: EQUAL
88753: IFFALSE 88763
// sRadar := true ;
88755: LD_ADDR_EXP 122
88759: PUSH
88760: LD_INT 1
88762: ST_TO_ADDR
// if p3 = 8 then
88763: LD_VAR 0 3
88767: PUSH
88768: LD_INT 8
88770: EQUAL
88771: IFFALSE 88781
// sBunker := true ;
88773: LD_ADDR_EXP 123
88777: PUSH
88778: LD_INT 1
88780: ST_TO_ADDR
// if p3 = 9 then
88781: LD_VAR 0 3
88785: PUSH
88786: LD_INT 9
88788: EQUAL
88789: IFFALSE 88799
// sHack := true ;
88791: LD_ADDR_EXP 124
88795: PUSH
88796: LD_INT 1
88798: ST_TO_ADDR
// if p3 = 10 then
88799: LD_VAR 0 3
88803: PUSH
88804: LD_INT 10
88806: EQUAL
88807: IFFALSE 88817
// sFire := true ;
88809: LD_ADDR_EXP 125
88813: PUSH
88814: LD_INT 1
88816: ST_TO_ADDR
// if p3 = 11 then
88817: LD_VAR 0 3
88821: PUSH
88822: LD_INT 11
88824: EQUAL
88825: IFFALSE 88835
// sRefresh := true ;
88827: LD_ADDR_EXP 126
88831: PUSH
88832: LD_INT 1
88834: ST_TO_ADDR
// if p3 = 12 then
88835: LD_VAR 0 3
88839: PUSH
88840: LD_INT 12
88842: EQUAL
88843: IFFALSE 88853
// sExp := true ;
88845: LD_ADDR_EXP 127
88849: PUSH
88850: LD_INT 1
88852: ST_TO_ADDR
// if p3 = 13 then
88853: LD_VAR 0 3
88857: PUSH
88858: LD_INT 13
88860: EQUAL
88861: IFFALSE 88871
// sDepot := true ;
88863: LD_ADDR_EXP 128
88867: PUSH
88868: LD_INT 1
88870: ST_TO_ADDR
// if p3 = 14 then
88871: LD_VAR 0 3
88875: PUSH
88876: LD_INT 14
88878: EQUAL
88879: IFFALSE 88889
// sFlag := true ;
88881: LD_ADDR_EXP 129
88885: PUSH
88886: LD_INT 1
88888: ST_TO_ADDR
// if p3 = 15 then
88889: LD_VAR 0 3
88893: PUSH
88894: LD_INT 15
88896: EQUAL
88897: IFFALSE 88907
// sKamikadze := true ;
88899: LD_ADDR_EXP 137
88903: PUSH
88904: LD_INT 1
88906: ST_TO_ADDR
// if p3 = 16 then
88907: LD_VAR 0 3
88911: PUSH
88912: LD_INT 16
88914: EQUAL
88915: IFFALSE 88925
// sTroll := true ;
88917: LD_ADDR_EXP 138
88921: PUSH
88922: LD_INT 1
88924: ST_TO_ADDR
// if p3 = 17 then
88925: LD_VAR 0 3
88929: PUSH
88930: LD_INT 17
88932: EQUAL
88933: IFFALSE 88943
// sSlow := true ;
88935: LD_ADDR_EXP 139
88939: PUSH
88940: LD_INT 1
88942: ST_TO_ADDR
// if p3 = 18 then
88943: LD_VAR 0 3
88947: PUSH
88948: LD_INT 18
88950: EQUAL
88951: IFFALSE 88961
// sLack := true ;
88953: LD_ADDR_EXP 140
88957: PUSH
88958: LD_INT 1
88960: ST_TO_ADDR
// if p3 = 19 then
88961: LD_VAR 0 3
88965: PUSH
88966: LD_INT 19
88968: EQUAL
88969: IFFALSE 88979
// sTank := true ;
88971: LD_ADDR_EXP 142
88975: PUSH
88976: LD_INT 1
88978: ST_TO_ADDR
// if p3 = 20 then
88979: LD_VAR 0 3
88983: PUSH
88984: LD_INT 20
88986: EQUAL
88987: IFFALSE 88997
// sRemote := true ;
88989: LD_ADDR_EXP 143
88993: PUSH
88994: LD_INT 1
88996: ST_TO_ADDR
// if p3 = 21 then
88997: LD_VAR 0 3
89001: PUSH
89002: LD_INT 21
89004: EQUAL
89005: IFFALSE 89015
// sPowell := true ;
89007: LD_ADDR_EXP 144
89011: PUSH
89012: LD_INT 1
89014: ST_TO_ADDR
// if p3 = 22 then
89015: LD_VAR 0 3
89019: PUSH
89020: LD_INT 22
89022: EQUAL
89023: IFFALSE 89033
// sTeleport := true ;
89025: LD_ADDR_EXP 147
89029: PUSH
89030: LD_INT 1
89032: ST_TO_ADDR
// if p3 = 23 then
89033: LD_VAR 0 3
89037: PUSH
89038: LD_INT 23
89040: EQUAL
89041: IFFALSE 89051
// sOilTower := true ;
89043: LD_ADDR_EXP 149
89047: PUSH
89048: LD_INT 1
89050: ST_TO_ADDR
// if p3 = 24 then
89051: LD_VAR 0 3
89055: PUSH
89056: LD_INT 24
89058: EQUAL
89059: IFFALSE 89069
// sShovel := true ;
89061: LD_ADDR_EXP 150
89065: PUSH
89066: LD_INT 1
89068: ST_TO_ADDR
// if p3 = 25 then
89069: LD_VAR 0 3
89073: PUSH
89074: LD_INT 25
89076: EQUAL
89077: IFFALSE 89087
// sSheik := true ;
89079: LD_ADDR_EXP 151
89083: PUSH
89084: LD_INT 1
89086: ST_TO_ADDR
// if p3 = 26 then
89087: LD_VAR 0 3
89091: PUSH
89092: LD_INT 26
89094: EQUAL
89095: IFFALSE 89105
// sEarthquake := true ;
89097: LD_ADDR_EXP 153
89101: PUSH
89102: LD_INT 1
89104: ST_TO_ADDR
// if p3 = 27 then
89105: LD_VAR 0 3
89109: PUSH
89110: LD_INT 27
89112: EQUAL
89113: IFFALSE 89123
// sAI := true ;
89115: LD_ADDR_EXP 154
89119: PUSH
89120: LD_INT 1
89122: ST_TO_ADDR
// if p3 = 28 then
89123: LD_VAR 0 3
89127: PUSH
89128: LD_INT 28
89130: EQUAL
89131: IFFALSE 89141
// sCargo := true ;
89133: LD_ADDR_EXP 157
89137: PUSH
89138: LD_INT 1
89140: ST_TO_ADDR
// if p3 = 29 then
89141: LD_VAR 0 3
89145: PUSH
89146: LD_INT 29
89148: EQUAL
89149: IFFALSE 89159
// sDLaser := true ;
89151: LD_ADDR_EXP 158
89155: PUSH
89156: LD_INT 1
89158: ST_TO_ADDR
// if p3 = 30 then
89159: LD_VAR 0 3
89163: PUSH
89164: LD_INT 30
89166: EQUAL
89167: IFFALSE 89177
// sExchange := true ;
89169: LD_ADDR_EXP 159
89173: PUSH
89174: LD_INT 1
89176: ST_TO_ADDR
// if p3 = 31 then
89177: LD_VAR 0 3
89181: PUSH
89182: LD_INT 31
89184: EQUAL
89185: IFFALSE 89195
// sFac := true ;
89187: LD_ADDR_EXP 160
89191: PUSH
89192: LD_INT 1
89194: ST_TO_ADDR
// if p3 = 32 then
89195: LD_VAR 0 3
89199: PUSH
89200: LD_INT 32
89202: EQUAL
89203: IFFALSE 89213
// sPower := true ;
89205: LD_ADDR_EXP 161
89209: PUSH
89210: LD_INT 1
89212: ST_TO_ADDR
// if p3 = 33 then
89213: LD_VAR 0 3
89217: PUSH
89218: LD_INT 33
89220: EQUAL
89221: IFFALSE 89231
// sRandom := true ;
89223: LD_ADDR_EXP 162
89227: PUSH
89228: LD_INT 1
89230: ST_TO_ADDR
// if p3 = 34 then
89231: LD_VAR 0 3
89235: PUSH
89236: LD_INT 34
89238: EQUAL
89239: IFFALSE 89249
// sShield := true ;
89241: LD_ADDR_EXP 163
89245: PUSH
89246: LD_INT 1
89248: ST_TO_ADDR
// if p3 = 35 then
89249: LD_VAR 0 3
89253: PUSH
89254: LD_INT 35
89256: EQUAL
89257: IFFALSE 89267
// sTime := true ;
89259: LD_ADDR_EXP 164
89263: PUSH
89264: LD_INT 1
89266: ST_TO_ADDR
// if p3 = 36 then
89267: LD_VAR 0 3
89271: PUSH
89272: LD_INT 36
89274: EQUAL
89275: IFFALSE 89285
// sTools := true ;
89277: LD_ADDR_EXP 165
89281: PUSH
89282: LD_INT 1
89284: ST_TO_ADDR
// if p3 = 101 then
89285: LD_VAR 0 3
89289: PUSH
89290: LD_INT 101
89292: EQUAL
89293: IFFALSE 89303
// sSold := true ;
89295: LD_ADDR_EXP 130
89299: PUSH
89300: LD_INT 1
89302: ST_TO_ADDR
// if p3 = 102 then
89303: LD_VAR 0 3
89307: PUSH
89308: LD_INT 102
89310: EQUAL
89311: IFFALSE 89321
// sDiff := true ;
89313: LD_ADDR_EXP 131
89317: PUSH
89318: LD_INT 1
89320: ST_TO_ADDR
// if p3 = 103 then
89321: LD_VAR 0 3
89325: PUSH
89326: LD_INT 103
89328: EQUAL
89329: IFFALSE 89339
// sFog := true ;
89331: LD_ADDR_EXP 134
89335: PUSH
89336: LD_INT 1
89338: ST_TO_ADDR
// if p3 = 104 then
89339: LD_VAR 0 3
89343: PUSH
89344: LD_INT 104
89346: EQUAL
89347: IFFALSE 89357
// sReset := true ;
89349: LD_ADDR_EXP 135
89353: PUSH
89354: LD_INT 1
89356: ST_TO_ADDR
// if p3 = 105 then
89357: LD_VAR 0 3
89361: PUSH
89362: LD_INT 105
89364: EQUAL
89365: IFFALSE 89375
// sSun := true ;
89367: LD_ADDR_EXP 136
89371: PUSH
89372: LD_INT 1
89374: ST_TO_ADDR
// if p3 = 106 then
89375: LD_VAR 0 3
89379: PUSH
89380: LD_INT 106
89382: EQUAL
89383: IFFALSE 89393
// sTiger := true ;
89385: LD_ADDR_EXP 132
89389: PUSH
89390: LD_INT 1
89392: ST_TO_ADDR
// if p3 = 107 then
89393: LD_VAR 0 3
89397: PUSH
89398: LD_INT 107
89400: EQUAL
89401: IFFALSE 89411
// sBomb := true ;
89403: LD_ADDR_EXP 133
89407: PUSH
89408: LD_INT 1
89410: ST_TO_ADDR
// if p3 = 108 then
89411: LD_VAR 0 3
89415: PUSH
89416: LD_INT 108
89418: EQUAL
89419: IFFALSE 89429
// sWound := true ;
89421: LD_ADDR_EXP 141
89425: PUSH
89426: LD_INT 1
89428: ST_TO_ADDR
// if p3 = 109 then
89429: LD_VAR 0 3
89433: PUSH
89434: LD_INT 109
89436: EQUAL
89437: IFFALSE 89447
// sBetray := true ;
89439: LD_ADDR_EXP 145
89443: PUSH
89444: LD_INT 1
89446: ST_TO_ADDR
// if p3 = 110 then
89447: LD_VAR 0 3
89451: PUSH
89452: LD_INT 110
89454: EQUAL
89455: IFFALSE 89465
// sContamin := true ;
89457: LD_ADDR_EXP 146
89461: PUSH
89462: LD_INT 1
89464: ST_TO_ADDR
// if p3 = 111 then
89465: LD_VAR 0 3
89469: PUSH
89470: LD_INT 111
89472: EQUAL
89473: IFFALSE 89483
// sOil := true ;
89475: LD_ADDR_EXP 148
89479: PUSH
89480: LD_INT 1
89482: ST_TO_ADDR
// if p3 = 112 then
89483: LD_VAR 0 3
89487: PUSH
89488: LD_INT 112
89490: EQUAL
89491: IFFALSE 89501
// sStu := true ;
89493: LD_ADDR_EXP 152
89497: PUSH
89498: LD_INT 1
89500: ST_TO_ADDR
// if p3 = 113 then
89501: LD_VAR 0 3
89505: PUSH
89506: LD_INT 113
89508: EQUAL
89509: IFFALSE 89519
// sBazooka := true ;
89511: LD_ADDR_EXP 155
89515: PUSH
89516: LD_INT 1
89518: ST_TO_ADDR
// if p3 = 114 then
89519: LD_VAR 0 3
89523: PUSH
89524: LD_INT 114
89526: EQUAL
89527: IFFALSE 89537
// sMortar := true ;
89529: LD_ADDR_EXP 156
89533: PUSH
89534: LD_INT 1
89536: ST_TO_ADDR
// if p3 = 115 then
89537: LD_VAR 0 3
89541: PUSH
89542: LD_INT 115
89544: EQUAL
89545: IFFALSE 89555
// sRanger := true ;
89547: LD_ADDR_EXP 166
89551: PUSH
89552: LD_INT 1
89554: ST_TO_ADDR
// end ; if p2 = 101 then
89555: LD_VAR 0 2
89559: PUSH
89560: LD_INT 101
89562: EQUAL
89563: IFFALSE 89691
// begin case p3 of 1 :
89565: LD_VAR 0 3
89569: PUSH
89570: LD_INT 1
89572: DOUBLE
89573: EQUAL
89574: IFTRUE 89578
89576: GO 89585
89578: POP
// hHackUnlimitedResources ; 2 :
89579: CALL 100726 0 0
89583: GO 89691
89585: LD_INT 2
89587: DOUBLE
89588: EQUAL
89589: IFTRUE 89593
89591: GO 89600
89593: POP
// hHackSetLevel10 ; 3 :
89594: CALL 100859 0 0
89598: GO 89691
89600: LD_INT 3
89602: DOUBLE
89603: EQUAL
89604: IFTRUE 89608
89606: GO 89615
89608: POP
// hHackSetLevel10YourUnits ; 4 :
89609: CALL 100944 0 0
89613: GO 89691
89615: LD_INT 4
89617: DOUBLE
89618: EQUAL
89619: IFTRUE 89623
89621: GO 89630
89623: POP
// hHackInvincible ; 5 :
89624: CALL 101392 0 0
89628: GO 89691
89630: LD_INT 5
89632: DOUBLE
89633: EQUAL
89634: IFTRUE 89638
89636: GO 89645
89638: POP
// hHackInvisible ; 6 :
89639: CALL 101503 0 0
89643: GO 89691
89645: LD_INT 6
89647: DOUBLE
89648: EQUAL
89649: IFTRUE 89653
89651: GO 89660
89653: POP
// hHackChangeYourSide ; 7 :
89654: CALL 101560 0 0
89658: GO 89691
89660: LD_INT 7
89662: DOUBLE
89663: EQUAL
89664: IFTRUE 89668
89666: GO 89675
89668: POP
// hHackChangeUnitSide ; 8 :
89669: CALL 101602 0 0
89673: GO 89691
89675: LD_INT 8
89677: DOUBLE
89678: EQUAL
89679: IFTRUE 89683
89681: GO 89690
89683: POP
// hHackFog ; end ;
89684: CALL 101703 0 0
89688: GO 89691
89690: POP
// end ; end ;
89691: PPOPN 6
89693: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89694: GO 89696
89696: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89697: LD_STRING initStreamRollete();
89699: PPUSH
89700: CALL_OW 559
// InitStreamMode ;
89704: CALL 89713 0 0
// DefineStreamItems ( ) ;
89708: CALL 90153 0 0
// end ;
89712: END
// function InitStreamMode ; begin
89713: LD_INT 0
89715: PPUSH
// streamModeActive := false ;
89716: LD_ADDR_EXP 113
89720: PUSH
89721: LD_INT 0
89723: ST_TO_ADDR
// normalCounter := 36 ;
89724: LD_ADDR_EXP 114
89728: PUSH
89729: LD_INT 36
89731: ST_TO_ADDR
// hardcoreCounter := 16 ;
89732: LD_ADDR_EXP 115
89736: PUSH
89737: LD_INT 16
89739: ST_TO_ADDR
// sRocket := false ;
89740: LD_ADDR_EXP 118
89744: PUSH
89745: LD_INT 0
89747: ST_TO_ADDR
// sSpeed := false ;
89748: LD_ADDR_EXP 117
89752: PUSH
89753: LD_INT 0
89755: ST_TO_ADDR
// sEngine := false ;
89756: LD_ADDR_EXP 119
89760: PUSH
89761: LD_INT 0
89763: ST_TO_ADDR
// sSpec := false ;
89764: LD_ADDR_EXP 116
89768: PUSH
89769: LD_INT 0
89771: ST_TO_ADDR
// sLevel := false ;
89772: LD_ADDR_EXP 120
89776: PUSH
89777: LD_INT 0
89779: ST_TO_ADDR
// sArmoury := false ;
89780: LD_ADDR_EXP 121
89784: PUSH
89785: LD_INT 0
89787: ST_TO_ADDR
// sRadar := false ;
89788: LD_ADDR_EXP 122
89792: PUSH
89793: LD_INT 0
89795: ST_TO_ADDR
// sBunker := false ;
89796: LD_ADDR_EXP 123
89800: PUSH
89801: LD_INT 0
89803: ST_TO_ADDR
// sHack := false ;
89804: LD_ADDR_EXP 124
89808: PUSH
89809: LD_INT 0
89811: ST_TO_ADDR
// sFire := false ;
89812: LD_ADDR_EXP 125
89816: PUSH
89817: LD_INT 0
89819: ST_TO_ADDR
// sRefresh := false ;
89820: LD_ADDR_EXP 126
89824: PUSH
89825: LD_INT 0
89827: ST_TO_ADDR
// sExp := false ;
89828: LD_ADDR_EXP 127
89832: PUSH
89833: LD_INT 0
89835: ST_TO_ADDR
// sDepot := false ;
89836: LD_ADDR_EXP 128
89840: PUSH
89841: LD_INT 0
89843: ST_TO_ADDR
// sFlag := false ;
89844: LD_ADDR_EXP 129
89848: PUSH
89849: LD_INT 0
89851: ST_TO_ADDR
// sKamikadze := false ;
89852: LD_ADDR_EXP 137
89856: PUSH
89857: LD_INT 0
89859: ST_TO_ADDR
// sTroll := false ;
89860: LD_ADDR_EXP 138
89864: PUSH
89865: LD_INT 0
89867: ST_TO_ADDR
// sSlow := false ;
89868: LD_ADDR_EXP 139
89872: PUSH
89873: LD_INT 0
89875: ST_TO_ADDR
// sLack := false ;
89876: LD_ADDR_EXP 140
89880: PUSH
89881: LD_INT 0
89883: ST_TO_ADDR
// sTank := false ;
89884: LD_ADDR_EXP 142
89888: PUSH
89889: LD_INT 0
89891: ST_TO_ADDR
// sRemote := false ;
89892: LD_ADDR_EXP 143
89896: PUSH
89897: LD_INT 0
89899: ST_TO_ADDR
// sPowell := false ;
89900: LD_ADDR_EXP 144
89904: PUSH
89905: LD_INT 0
89907: ST_TO_ADDR
// sTeleport := false ;
89908: LD_ADDR_EXP 147
89912: PUSH
89913: LD_INT 0
89915: ST_TO_ADDR
// sOilTower := false ;
89916: LD_ADDR_EXP 149
89920: PUSH
89921: LD_INT 0
89923: ST_TO_ADDR
// sShovel := false ;
89924: LD_ADDR_EXP 150
89928: PUSH
89929: LD_INT 0
89931: ST_TO_ADDR
// sSheik := false ;
89932: LD_ADDR_EXP 151
89936: PUSH
89937: LD_INT 0
89939: ST_TO_ADDR
// sEarthquake := false ;
89940: LD_ADDR_EXP 153
89944: PUSH
89945: LD_INT 0
89947: ST_TO_ADDR
// sAI := false ;
89948: LD_ADDR_EXP 154
89952: PUSH
89953: LD_INT 0
89955: ST_TO_ADDR
// sCargo := false ;
89956: LD_ADDR_EXP 157
89960: PUSH
89961: LD_INT 0
89963: ST_TO_ADDR
// sDLaser := false ;
89964: LD_ADDR_EXP 158
89968: PUSH
89969: LD_INT 0
89971: ST_TO_ADDR
// sExchange := false ;
89972: LD_ADDR_EXP 159
89976: PUSH
89977: LD_INT 0
89979: ST_TO_ADDR
// sFac := false ;
89980: LD_ADDR_EXP 160
89984: PUSH
89985: LD_INT 0
89987: ST_TO_ADDR
// sPower := false ;
89988: LD_ADDR_EXP 161
89992: PUSH
89993: LD_INT 0
89995: ST_TO_ADDR
// sRandom := false ;
89996: LD_ADDR_EXP 162
90000: PUSH
90001: LD_INT 0
90003: ST_TO_ADDR
// sShield := false ;
90004: LD_ADDR_EXP 163
90008: PUSH
90009: LD_INT 0
90011: ST_TO_ADDR
// sTime := false ;
90012: LD_ADDR_EXP 164
90016: PUSH
90017: LD_INT 0
90019: ST_TO_ADDR
// sTools := false ;
90020: LD_ADDR_EXP 165
90024: PUSH
90025: LD_INT 0
90027: ST_TO_ADDR
// sSold := false ;
90028: LD_ADDR_EXP 130
90032: PUSH
90033: LD_INT 0
90035: ST_TO_ADDR
// sDiff := false ;
90036: LD_ADDR_EXP 131
90040: PUSH
90041: LD_INT 0
90043: ST_TO_ADDR
// sFog := false ;
90044: LD_ADDR_EXP 134
90048: PUSH
90049: LD_INT 0
90051: ST_TO_ADDR
// sReset := false ;
90052: LD_ADDR_EXP 135
90056: PUSH
90057: LD_INT 0
90059: ST_TO_ADDR
// sSun := false ;
90060: LD_ADDR_EXP 136
90064: PUSH
90065: LD_INT 0
90067: ST_TO_ADDR
// sTiger := false ;
90068: LD_ADDR_EXP 132
90072: PUSH
90073: LD_INT 0
90075: ST_TO_ADDR
// sBomb := false ;
90076: LD_ADDR_EXP 133
90080: PUSH
90081: LD_INT 0
90083: ST_TO_ADDR
// sWound := false ;
90084: LD_ADDR_EXP 141
90088: PUSH
90089: LD_INT 0
90091: ST_TO_ADDR
// sBetray := false ;
90092: LD_ADDR_EXP 145
90096: PUSH
90097: LD_INT 0
90099: ST_TO_ADDR
// sContamin := false ;
90100: LD_ADDR_EXP 146
90104: PUSH
90105: LD_INT 0
90107: ST_TO_ADDR
// sOil := false ;
90108: LD_ADDR_EXP 148
90112: PUSH
90113: LD_INT 0
90115: ST_TO_ADDR
// sStu := false ;
90116: LD_ADDR_EXP 152
90120: PUSH
90121: LD_INT 0
90123: ST_TO_ADDR
// sBazooka := false ;
90124: LD_ADDR_EXP 155
90128: PUSH
90129: LD_INT 0
90131: ST_TO_ADDR
// sMortar := false ;
90132: LD_ADDR_EXP 156
90136: PUSH
90137: LD_INT 0
90139: ST_TO_ADDR
// sRanger := false ;
90140: LD_ADDR_EXP 166
90144: PUSH
90145: LD_INT 0
90147: ST_TO_ADDR
// end ;
90148: LD_VAR 0 1
90152: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
90153: LD_INT 0
90155: PPUSH
90156: PPUSH
90157: PPUSH
90158: PPUSH
90159: PPUSH
// result := [ ] ;
90160: LD_ADDR_VAR 0 1
90164: PUSH
90165: EMPTY
90166: ST_TO_ADDR
// if campaign_id = 1 then
90167: LD_OWVAR 69
90171: PUSH
90172: LD_INT 1
90174: EQUAL
90175: IFFALSE 93113
// begin case mission_number of 1 :
90177: LD_OWVAR 70
90181: PUSH
90182: LD_INT 1
90184: DOUBLE
90185: EQUAL
90186: IFTRUE 90190
90188: GO 90254
90190: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
90191: LD_ADDR_VAR 0 1
90195: PUSH
90196: LD_INT 2
90198: PUSH
90199: LD_INT 4
90201: PUSH
90202: LD_INT 11
90204: PUSH
90205: LD_INT 12
90207: PUSH
90208: LD_INT 15
90210: PUSH
90211: LD_INT 16
90213: PUSH
90214: LD_INT 22
90216: PUSH
90217: LD_INT 23
90219: PUSH
90220: LD_INT 26
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 101
90236: PUSH
90237: LD_INT 102
90239: PUSH
90240: LD_INT 106
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: LIST
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: ST_TO_ADDR
90252: GO 93111
90254: LD_INT 2
90256: DOUBLE
90257: EQUAL
90258: IFTRUE 90262
90260: GO 90334
90262: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
90263: LD_ADDR_VAR 0 1
90267: PUSH
90268: LD_INT 2
90270: PUSH
90271: LD_INT 4
90273: PUSH
90274: LD_INT 11
90276: PUSH
90277: LD_INT 12
90279: PUSH
90280: LD_INT 15
90282: PUSH
90283: LD_INT 16
90285: PUSH
90286: LD_INT 22
90288: PUSH
90289: LD_INT 23
90291: PUSH
90292: LD_INT 26
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 101
90308: PUSH
90309: LD_INT 102
90311: PUSH
90312: LD_INT 105
90314: PUSH
90315: LD_INT 106
90317: PUSH
90318: LD_INT 108
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: ST_TO_ADDR
90332: GO 93111
90334: LD_INT 3
90336: DOUBLE
90337: EQUAL
90338: IFTRUE 90342
90340: GO 90418
90342: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
90343: LD_ADDR_VAR 0 1
90347: PUSH
90348: LD_INT 2
90350: PUSH
90351: LD_INT 4
90353: PUSH
90354: LD_INT 5
90356: PUSH
90357: LD_INT 11
90359: PUSH
90360: LD_INT 12
90362: PUSH
90363: LD_INT 15
90365: PUSH
90366: LD_INT 16
90368: PUSH
90369: LD_INT 22
90371: PUSH
90372: LD_INT 26
90374: PUSH
90375: LD_INT 36
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 101
90392: PUSH
90393: LD_INT 102
90395: PUSH
90396: LD_INT 105
90398: PUSH
90399: LD_INT 106
90401: PUSH
90402: LD_INT 108
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: ST_TO_ADDR
90416: GO 93111
90418: LD_INT 4
90420: DOUBLE
90421: EQUAL
90422: IFTRUE 90426
90424: GO 90510
90426: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
90427: LD_ADDR_VAR 0 1
90431: PUSH
90432: LD_INT 2
90434: PUSH
90435: LD_INT 4
90437: PUSH
90438: LD_INT 5
90440: PUSH
90441: LD_INT 8
90443: PUSH
90444: LD_INT 11
90446: PUSH
90447: LD_INT 12
90449: PUSH
90450: LD_INT 15
90452: PUSH
90453: LD_INT 16
90455: PUSH
90456: LD_INT 22
90458: PUSH
90459: LD_INT 23
90461: PUSH
90462: LD_INT 26
90464: PUSH
90465: LD_INT 36
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 101
90484: PUSH
90485: LD_INT 102
90487: PUSH
90488: LD_INT 105
90490: PUSH
90491: LD_INT 106
90493: PUSH
90494: LD_INT 108
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: ST_TO_ADDR
90508: GO 93111
90510: LD_INT 5
90512: DOUBLE
90513: EQUAL
90514: IFTRUE 90518
90516: GO 90618
90518: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90519: LD_ADDR_VAR 0 1
90523: PUSH
90524: LD_INT 2
90526: PUSH
90527: LD_INT 4
90529: PUSH
90530: LD_INT 5
90532: PUSH
90533: LD_INT 6
90535: PUSH
90536: LD_INT 8
90538: PUSH
90539: LD_INT 11
90541: PUSH
90542: LD_INT 12
90544: PUSH
90545: LD_INT 15
90547: PUSH
90548: LD_INT 16
90550: PUSH
90551: LD_INT 22
90553: PUSH
90554: LD_INT 23
90556: PUSH
90557: LD_INT 25
90559: PUSH
90560: LD_INT 26
90562: PUSH
90563: LD_INT 36
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: PUSH
90582: LD_INT 101
90584: PUSH
90585: LD_INT 102
90587: PUSH
90588: LD_INT 105
90590: PUSH
90591: LD_INT 106
90593: PUSH
90594: LD_INT 108
90596: PUSH
90597: LD_INT 109
90599: PUSH
90600: LD_INT 112
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: ST_TO_ADDR
90616: GO 93111
90618: LD_INT 6
90620: DOUBLE
90621: EQUAL
90622: IFTRUE 90626
90624: GO 90746
90626: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90627: LD_ADDR_VAR 0 1
90631: PUSH
90632: LD_INT 2
90634: PUSH
90635: LD_INT 4
90637: PUSH
90638: LD_INT 5
90640: PUSH
90641: LD_INT 6
90643: PUSH
90644: LD_INT 8
90646: PUSH
90647: LD_INT 11
90649: PUSH
90650: LD_INT 12
90652: PUSH
90653: LD_INT 15
90655: PUSH
90656: LD_INT 16
90658: PUSH
90659: LD_INT 20
90661: PUSH
90662: LD_INT 21
90664: PUSH
90665: LD_INT 22
90667: PUSH
90668: LD_INT 23
90670: PUSH
90671: LD_INT 25
90673: PUSH
90674: LD_INT 26
90676: PUSH
90677: LD_INT 30
90679: PUSH
90680: LD_INT 31
90682: PUSH
90683: LD_INT 32
90685: PUSH
90686: LD_INT 36
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 101
90712: PUSH
90713: LD_INT 102
90715: PUSH
90716: LD_INT 105
90718: PUSH
90719: LD_INT 106
90721: PUSH
90722: LD_INT 108
90724: PUSH
90725: LD_INT 109
90727: PUSH
90728: LD_INT 112
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: ST_TO_ADDR
90744: GO 93111
90746: LD_INT 7
90748: DOUBLE
90749: EQUAL
90750: IFTRUE 90754
90752: GO 90854
90754: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90755: LD_ADDR_VAR 0 1
90759: PUSH
90760: LD_INT 2
90762: PUSH
90763: LD_INT 4
90765: PUSH
90766: LD_INT 5
90768: PUSH
90769: LD_INT 7
90771: PUSH
90772: LD_INT 11
90774: PUSH
90775: LD_INT 12
90777: PUSH
90778: LD_INT 15
90780: PUSH
90781: LD_INT 16
90783: PUSH
90784: LD_INT 20
90786: PUSH
90787: LD_INT 21
90789: PUSH
90790: LD_INT 22
90792: PUSH
90793: LD_INT 23
90795: PUSH
90796: LD_INT 25
90798: PUSH
90799: LD_INT 26
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 101
90820: PUSH
90821: LD_INT 102
90823: PUSH
90824: LD_INT 103
90826: PUSH
90827: LD_INT 105
90829: PUSH
90830: LD_INT 106
90832: PUSH
90833: LD_INT 108
90835: PUSH
90836: LD_INT 112
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: ST_TO_ADDR
90852: GO 93111
90854: LD_INT 8
90856: DOUBLE
90857: EQUAL
90858: IFTRUE 90862
90860: GO 90990
90862: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90863: LD_ADDR_VAR 0 1
90867: PUSH
90868: LD_INT 2
90870: PUSH
90871: LD_INT 4
90873: PUSH
90874: LD_INT 5
90876: PUSH
90877: LD_INT 6
90879: PUSH
90880: LD_INT 7
90882: PUSH
90883: LD_INT 8
90885: PUSH
90886: LD_INT 11
90888: PUSH
90889: LD_INT 12
90891: PUSH
90892: LD_INT 15
90894: PUSH
90895: LD_INT 16
90897: PUSH
90898: LD_INT 20
90900: PUSH
90901: LD_INT 21
90903: PUSH
90904: LD_INT 22
90906: PUSH
90907: LD_INT 23
90909: PUSH
90910: LD_INT 25
90912: PUSH
90913: LD_INT 26
90915: PUSH
90916: LD_INT 30
90918: PUSH
90919: LD_INT 31
90921: PUSH
90922: LD_INT 32
90924: PUSH
90925: LD_INT 36
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 101
90952: PUSH
90953: LD_INT 102
90955: PUSH
90956: LD_INT 103
90958: PUSH
90959: LD_INT 105
90961: PUSH
90962: LD_INT 106
90964: PUSH
90965: LD_INT 108
90967: PUSH
90968: LD_INT 109
90970: PUSH
90971: LD_INT 112
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: ST_TO_ADDR
90988: GO 93111
90990: LD_INT 9
90992: DOUBLE
90993: EQUAL
90994: IFTRUE 90998
90996: GO 91134
90998: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
90999: LD_ADDR_VAR 0 1
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: LD_INT 4
91009: PUSH
91010: LD_INT 5
91012: PUSH
91013: LD_INT 6
91015: PUSH
91016: LD_INT 7
91018: PUSH
91019: LD_INT 8
91021: PUSH
91022: LD_INT 11
91024: PUSH
91025: LD_INT 12
91027: PUSH
91028: LD_INT 15
91030: PUSH
91031: LD_INT 16
91033: PUSH
91034: LD_INT 20
91036: PUSH
91037: LD_INT 21
91039: PUSH
91040: LD_INT 22
91042: PUSH
91043: LD_INT 23
91045: PUSH
91046: LD_INT 25
91048: PUSH
91049: LD_INT 26
91051: PUSH
91052: LD_INT 28
91054: PUSH
91055: LD_INT 30
91057: PUSH
91058: LD_INT 31
91060: PUSH
91061: LD_INT 32
91063: PUSH
91064: LD_INT 36
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 101
91092: PUSH
91093: LD_INT 102
91095: PUSH
91096: LD_INT 103
91098: PUSH
91099: LD_INT 105
91101: PUSH
91102: LD_INT 106
91104: PUSH
91105: LD_INT 108
91107: PUSH
91108: LD_INT 109
91110: PUSH
91111: LD_INT 112
91113: PUSH
91114: LD_INT 114
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: ST_TO_ADDR
91132: GO 93111
91134: LD_INT 10
91136: DOUBLE
91137: EQUAL
91138: IFTRUE 91142
91140: GO 91326
91142: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
91143: LD_ADDR_VAR 0 1
91147: PUSH
91148: LD_INT 2
91150: PUSH
91151: LD_INT 4
91153: PUSH
91154: LD_INT 5
91156: PUSH
91157: LD_INT 6
91159: PUSH
91160: LD_INT 7
91162: PUSH
91163: LD_INT 8
91165: PUSH
91166: LD_INT 9
91168: PUSH
91169: LD_INT 10
91171: PUSH
91172: LD_INT 11
91174: PUSH
91175: LD_INT 12
91177: PUSH
91178: LD_INT 13
91180: PUSH
91181: LD_INT 14
91183: PUSH
91184: LD_INT 15
91186: PUSH
91187: LD_INT 16
91189: PUSH
91190: LD_INT 17
91192: PUSH
91193: LD_INT 18
91195: PUSH
91196: LD_INT 19
91198: PUSH
91199: LD_INT 20
91201: PUSH
91202: LD_INT 21
91204: PUSH
91205: LD_INT 22
91207: PUSH
91208: LD_INT 23
91210: PUSH
91211: LD_INT 24
91213: PUSH
91214: LD_INT 25
91216: PUSH
91217: LD_INT 26
91219: PUSH
91220: LD_INT 28
91222: PUSH
91223: LD_INT 30
91225: PUSH
91226: LD_INT 31
91228: PUSH
91229: LD_INT 32
91231: PUSH
91232: LD_INT 36
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: PUSH
91266: LD_INT 101
91268: PUSH
91269: LD_INT 102
91271: PUSH
91272: LD_INT 103
91274: PUSH
91275: LD_INT 104
91277: PUSH
91278: LD_INT 105
91280: PUSH
91281: LD_INT 106
91283: PUSH
91284: LD_INT 107
91286: PUSH
91287: LD_INT 108
91289: PUSH
91290: LD_INT 109
91292: PUSH
91293: LD_INT 110
91295: PUSH
91296: LD_INT 111
91298: PUSH
91299: LD_INT 112
91301: PUSH
91302: LD_INT 114
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: ST_TO_ADDR
91324: GO 93111
91326: LD_INT 11
91328: DOUBLE
91329: EQUAL
91330: IFTRUE 91334
91332: GO 91526
91334: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
91335: LD_ADDR_VAR 0 1
91339: PUSH
91340: LD_INT 2
91342: PUSH
91343: LD_INT 3
91345: PUSH
91346: LD_INT 4
91348: PUSH
91349: LD_INT 5
91351: PUSH
91352: LD_INT 6
91354: PUSH
91355: LD_INT 7
91357: PUSH
91358: LD_INT 8
91360: PUSH
91361: LD_INT 9
91363: PUSH
91364: LD_INT 10
91366: PUSH
91367: LD_INT 11
91369: PUSH
91370: LD_INT 12
91372: PUSH
91373: LD_INT 13
91375: PUSH
91376: LD_INT 14
91378: PUSH
91379: LD_INT 15
91381: PUSH
91382: LD_INT 16
91384: PUSH
91385: LD_INT 17
91387: PUSH
91388: LD_INT 18
91390: PUSH
91391: LD_INT 19
91393: PUSH
91394: LD_INT 20
91396: PUSH
91397: LD_INT 21
91399: PUSH
91400: LD_INT 22
91402: PUSH
91403: LD_INT 23
91405: PUSH
91406: LD_INT 24
91408: PUSH
91409: LD_INT 25
91411: PUSH
91412: LD_INT 26
91414: PUSH
91415: LD_INT 28
91417: PUSH
91418: LD_INT 30
91420: PUSH
91421: LD_INT 31
91423: PUSH
91424: LD_INT 32
91426: PUSH
91427: LD_INT 34
91429: PUSH
91430: LD_INT 36
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 101
91468: PUSH
91469: LD_INT 102
91471: PUSH
91472: LD_INT 103
91474: PUSH
91475: LD_INT 104
91477: PUSH
91478: LD_INT 105
91480: PUSH
91481: LD_INT 106
91483: PUSH
91484: LD_INT 107
91486: PUSH
91487: LD_INT 108
91489: PUSH
91490: LD_INT 109
91492: PUSH
91493: LD_INT 110
91495: PUSH
91496: LD_INT 111
91498: PUSH
91499: LD_INT 112
91501: PUSH
91502: LD_INT 114
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: ST_TO_ADDR
91524: GO 93111
91526: LD_INT 12
91528: DOUBLE
91529: EQUAL
91530: IFTRUE 91534
91532: GO 91742
91534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91535: LD_ADDR_VAR 0 1
91539: PUSH
91540: LD_INT 1
91542: PUSH
91543: LD_INT 2
91545: PUSH
91546: LD_INT 3
91548: PUSH
91549: LD_INT 4
91551: PUSH
91552: LD_INT 5
91554: PUSH
91555: LD_INT 6
91557: PUSH
91558: LD_INT 7
91560: PUSH
91561: LD_INT 8
91563: PUSH
91564: LD_INT 9
91566: PUSH
91567: LD_INT 10
91569: PUSH
91570: LD_INT 11
91572: PUSH
91573: LD_INT 12
91575: PUSH
91576: LD_INT 13
91578: PUSH
91579: LD_INT 14
91581: PUSH
91582: LD_INT 15
91584: PUSH
91585: LD_INT 16
91587: PUSH
91588: LD_INT 17
91590: PUSH
91591: LD_INT 18
91593: PUSH
91594: LD_INT 19
91596: PUSH
91597: LD_INT 20
91599: PUSH
91600: LD_INT 21
91602: PUSH
91603: LD_INT 22
91605: PUSH
91606: LD_INT 23
91608: PUSH
91609: LD_INT 24
91611: PUSH
91612: LD_INT 25
91614: PUSH
91615: LD_INT 26
91617: PUSH
91618: LD_INT 27
91620: PUSH
91621: LD_INT 28
91623: PUSH
91624: LD_INT 30
91626: PUSH
91627: LD_INT 31
91629: PUSH
91630: LD_INT 32
91632: PUSH
91633: LD_INT 33
91635: PUSH
91636: LD_INT 34
91638: PUSH
91639: LD_INT 36
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 101
91680: PUSH
91681: LD_INT 102
91683: PUSH
91684: LD_INT 103
91686: PUSH
91687: LD_INT 104
91689: PUSH
91690: LD_INT 105
91692: PUSH
91693: LD_INT 106
91695: PUSH
91696: LD_INT 107
91698: PUSH
91699: LD_INT 108
91701: PUSH
91702: LD_INT 109
91704: PUSH
91705: LD_INT 110
91707: PUSH
91708: LD_INT 111
91710: PUSH
91711: LD_INT 112
91713: PUSH
91714: LD_INT 113
91716: PUSH
91717: LD_INT 114
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: ST_TO_ADDR
91740: GO 93111
91742: LD_INT 13
91744: DOUBLE
91745: EQUAL
91746: IFTRUE 91750
91748: GO 91946
91750: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91751: LD_ADDR_VAR 0 1
91755: PUSH
91756: LD_INT 1
91758: PUSH
91759: LD_INT 2
91761: PUSH
91762: LD_INT 3
91764: PUSH
91765: LD_INT 4
91767: PUSH
91768: LD_INT 5
91770: PUSH
91771: LD_INT 8
91773: PUSH
91774: LD_INT 9
91776: PUSH
91777: LD_INT 10
91779: PUSH
91780: LD_INT 11
91782: PUSH
91783: LD_INT 12
91785: PUSH
91786: LD_INT 14
91788: PUSH
91789: LD_INT 15
91791: PUSH
91792: LD_INT 16
91794: PUSH
91795: LD_INT 17
91797: PUSH
91798: LD_INT 18
91800: PUSH
91801: LD_INT 19
91803: PUSH
91804: LD_INT 20
91806: PUSH
91807: LD_INT 21
91809: PUSH
91810: LD_INT 22
91812: PUSH
91813: LD_INT 23
91815: PUSH
91816: LD_INT 24
91818: PUSH
91819: LD_INT 25
91821: PUSH
91822: LD_INT 26
91824: PUSH
91825: LD_INT 27
91827: PUSH
91828: LD_INT 28
91830: PUSH
91831: LD_INT 30
91833: PUSH
91834: LD_INT 31
91836: PUSH
91837: LD_INT 32
91839: PUSH
91840: LD_INT 33
91842: PUSH
91843: LD_INT 34
91845: PUSH
91846: LD_INT 36
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 101
91884: PUSH
91885: LD_INT 102
91887: PUSH
91888: LD_INT 103
91890: PUSH
91891: LD_INT 104
91893: PUSH
91894: LD_INT 105
91896: PUSH
91897: LD_INT 106
91899: PUSH
91900: LD_INT 107
91902: PUSH
91903: LD_INT 108
91905: PUSH
91906: LD_INT 109
91908: PUSH
91909: LD_INT 110
91911: PUSH
91912: LD_INT 111
91914: PUSH
91915: LD_INT 112
91917: PUSH
91918: LD_INT 113
91920: PUSH
91921: LD_INT 114
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: ST_TO_ADDR
91944: GO 93111
91946: LD_INT 14
91948: DOUBLE
91949: EQUAL
91950: IFTRUE 91954
91952: GO 92166
91954: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
91955: LD_ADDR_VAR 0 1
91959: PUSH
91960: LD_INT 1
91962: PUSH
91963: LD_INT 2
91965: PUSH
91966: LD_INT 3
91968: PUSH
91969: LD_INT 4
91971: PUSH
91972: LD_INT 5
91974: PUSH
91975: LD_INT 6
91977: PUSH
91978: LD_INT 7
91980: PUSH
91981: LD_INT 8
91983: PUSH
91984: LD_INT 9
91986: PUSH
91987: LD_INT 10
91989: PUSH
91990: LD_INT 11
91992: PUSH
91993: LD_INT 12
91995: PUSH
91996: LD_INT 13
91998: PUSH
91999: LD_INT 14
92001: PUSH
92002: LD_INT 15
92004: PUSH
92005: LD_INT 16
92007: PUSH
92008: LD_INT 17
92010: PUSH
92011: LD_INT 18
92013: PUSH
92014: LD_INT 19
92016: PUSH
92017: LD_INT 20
92019: PUSH
92020: LD_INT 21
92022: PUSH
92023: LD_INT 22
92025: PUSH
92026: LD_INT 23
92028: PUSH
92029: LD_INT 24
92031: PUSH
92032: LD_INT 25
92034: PUSH
92035: LD_INT 26
92037: PUSH
92038: LD_INT 27
92040: PUSH
92041: LD_INT 28
92043: PUSH
92044: LD_INT 29
92046: PUSH
92047: LD_INT 30
92049: PUSH
92050: LD_INT 31
92052: PUSH
92053: LD_INT 32
92055: PUSH
92056: LD_INT 33
92058: PUSH
92059: LD_INT 34
92061: PUSH
92062: LD_INT 36
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: PUSH
92102: LD_INT 101
92104: PUSH
92105: LD_INT 102
92107: PUSH
92108: LD_INT 103
92110: PUSH
92111: LD_INT 104
92113: PUSH
92114: LD_INT 105
92116: PUSH
92117: LD_INT 106
92119: PUSH
92120: LD_INT 107
92122: PUSH
92123: LD_INT 108
92125: PUSH
92126: LD_INT 109
92128: PUSH
92129: LD_INT 110
92131: PUSH
92132: LD_INT 111
92134: PUSH
92135: LD_INT 112
92137: PUSH
92138: LD_INT 113
92140: PUSH
92141: LD_INT 114
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: ST_TO_ADDR
92164: GO 93111
92166: LD_INT 15
92168: DOUBLE
92169: EQUAL
92170: IFTRUE 92174
92172: GO 92386
92174: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
92175: LD_ADDR_VAR 0 1
92179: PUSH
92180: LD_INT 1
92182: PUSH
92183: LD_INT 2
92185: PUSH
92186: LD_INT 3
92188: PUSH
92189: LD_INT 4
92191: PUSH
92192: LD_INT 5
92194: PUSH
92195: LD_INT 6
92197: PUSH
92198: LD_INT 7
92200: PUSH
92201: LD_INT 8
92203: PUSH
92204: LD_INT 9
92206: PUSH
92207: LD_INT 10
92209: PUSH
92210: LD_INT 11
92212: PUSH
92213: LD_INT 12
92215: PUSH
92216: LD_INT 13
92218: PUSH
92219: LD_INT 14
92221: PUSH
92222: LD_INT 15
92224: PUSH
92225: LD_INT 16
92227: PUSH
92228: LD_INT 17
92230: PUSH
92231: LD_INT 18
92233: PUSH
92234: LD_INT 19
92236: PUSH
92237: LD_INT 20
92239: PUSH
92240: LD_INT 21
92242: PUSH
92243: LD_INT 22
92245: PUSH
92246: LD_INT 23
92248: PUSH
92249: LD_INT 24
92251: PUSH
92252: LD_INT 25
92254: PUSH
92255: LD_INT 26
92257: PUSH
92258: LD_INT 27
92260: PUSH
92261: LD_INT 28
92263: PUSH
92264: LD_INT 29
92266: PUSH
92267: LD_INT 30
92269: PUSH
92270: LD_INT 31
92272: PUSH
92273: LD_INT 32
92275: PUSH
92276: LD_INT 33
92278: PUSH
92279: LD_INT 34
92281: PUSH
92282: LD_INT 36
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 101
92324: PUSH
92325: LD_INT 102
92327: PUSH
92328: LD_INT 103
92330: PUSH
92331: LD_INT 104
92333: PUSH
92334: LD_INT 105
92336: PUSH
92337: LD_INT 106
92339: PUSH
92340: LD_INT 107
92342: PUSH
92343: LD_INT 108
92345: PUSH
92346: LD_INT 109
92348: PUSH
92349: LD_INT 110
92351: PUSH
92352: LD_INT 111
92354: PUSH
92355: LD_INT 112
92357: PUSH
92358: LD_INT 113
92360: PUSH
92361: LD_INT 114
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: ST_TO_ADDR
92384: GO 93111
92386: LD_INT 16
92388: DOUBLE
92389: EQUAL
92390: IFTRUE 92394
92392: GO 92518
92394: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
92395: LD_ADDR_VAR 0 1
92399: PUSH
92400: LD_INT 2
92402: PUSH
92403: LD_INT 4
92405: PUSH
92406: LD_INT 5
92408: PUSH
92409: LD_INT 7
92411: PUSH
92412: LD_INT 11
92414: PUSH
92415: LD_INT 12
92417: PUSH
92418: LD_INT 15
92420: PUSH
92421: LD_INT 16
92423: PUSH
92424: LD_INT 20
92426: PUSH
92427: LD_INT 21
92429: PUSH
92430: LD_INT 22
92432: PUSH
92433: LD_INT 23
92435: PUSH
92436: LD_INT 25
92438: PUSH
92439: LD_INT 26
92441: PUSH
92442: LD_INT 30
92444: PUSH
92445: LD_INT 31
92447: PUSH
92448: LD_INT 32
92450: PUSH
92451: LD_INT 33
92453: PUSH
92454: LD_INT 34
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 101
92480: PUSH
92481: LD_INT 102
92483: PUSH
92484: LD_INT 103
92486: PUSH
92487: LD_INT 106
92489: PUSH
92490: LD_INT 108
92492: PUSH
92493: LD_INT 112
92495: PUSH
92496: LD_INT 113
92498: PUSH
92499: LD_INT 114
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: ST_TO_ADDR
92516: GO 93111
92518: LD_INT 17
92520: DOUBLE
92521: EQUAL
92522: IFTRUE 92526
92524: GO 92738
92526: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92527: LD_ADDR_VAR 0 1
92531: PUSH
92532: LD_INT 1
92534: PUSH
92535: LD_INT 2
92537: PUSH
92538: LD_INT 3
92540: PUSH
92541: LD_INT 4
92543: PUSH
92544: LD_INT 5
92546: PUSH
92547: LD_INT 6
92549: PUSH
92550: LD_INT 7
92552: PUSH
92553: LD_INT 8
92555: PUSH
92556: LD_INT 9
92558: PUSH
92559: LD_INT 10
92561: PUSH
92562: LD_INT 11
92564: PUSH
92565: LD_INT 12
92567: PUSH
92568: LD_INT 13
92570: PUSH
92571: LD_INT 14
92573: PUSH
92574: LD_INT 15
92576: PUSH
92577: LD_INT 16
92579: PUSH
92580: LD_INT 17
92582: PUSH
92583: LD_INT 18
92585: PUSH
92586: LD_INT 19
92588: PUSH
92589: LD_INT 20
92591: PUSH
92592: LD_INT 21
92594: PUSH
92595: LD_INT 22
92597: PUSH
92598: LD_INT 23
92600: PUSH
92601: LD_INT 24
92603: PUSH
92604: LD_INT 25
92606: PUSH
92607: LD_INT 26
92609: PUSH
92610: LD_INT 27
92612: PUSH
92613: LD_INT 28
92615: PUSH
92616: LD_INT 29
92618: PUSH
92619: LD_INT 30
92621: PUSH
92622: LD_INT 31
92624: PUSH
92625: LD_INT 32
92627: PUSH
92628: LD_INT 33
92630: PUSH
92631: LD_INT 34
92633: PUSH
92634: LD_INT 36
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 101
92676: PUSH
92677: LD_INT 102
92679: PUSH
92680: LD_INT 103
92682: PUSH
92683: LD_INT 104
92685: PUSH
92686: LD_INT 105
92688: PUSH
92689: LD_INT 106
92691: PUSH
92692: LD_INT 107
92694: PUSH
92695: LD_INT 108
92697: PUSH
92698: LD_INT 109
92700: PUSH
92701: LD_INT 110
92703: PUSH
92704: LD_INT 111
92706: PUSH
92707: LD_INT 112
92709: PUSH
92710: LD_INT 113
92712: PUSH
92713: LD_INT 114
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: ST_TO_ADDR
92736: GO 93111
92738: LD_INT 18
92740: DOUBLE
92741: EQUAL
92742: IFTRUE 92746
92744: GO 92882
92746: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92747: LD_ADDR_VAR 0 1
92751: PUSH
92752: LD_INT 2
92754: PUSH
92755: LD_INT 4
92757: PUSH
92758: LD_INT 5
92760: PUSH
92761: LD_INT 7
92763: PUSH
92764: LD_INT 11
92766: PUSH
92767: LD_INT 12
92769: PUSH
92770: LD_INT 15
92772: PUSH
92773: LD_INT 16
92775: PUSH
92776: LD_INT 20
92778: PUSH
92779: LD_INT 21
92781: PUSH
92782: LD_INT 22
92784: PUSH
92785: LD_INT 23
92787: PUSH
92788: LD_INT 25
92790: PUSH
92791: LD_INT 26
92793: PUSH
92794: LD_INT 30
92796: PUSH
92797: LD_INT 31
92799: PUSH
92800: LD_INT 32
92802: PUSH
92803: LD_INT 33
92805: PUSH
92806: LD_INT 34
92808: PUSH
92809: LD_INT 35
92811: PUSH
92812: LD_INT 36
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 101
92840: PUSH
92841: LD_INT 102
92843: PUSH
92844: LD_INT 103
92846: PUSH
92847: LD_INT 106
92849: PUSH
92850: LD_INT 108
92852: PUSH
92853: LD_INT 112
92855: PUSH
92856: LD_INT 113
92858: PUSH
92859: LD_INT 114
92861: PUSH
92862: LD_INT 115
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: ST_TO_ADDR
92880: GO 93111
92882: LD_INT 19
92884: DOUBLE
92885: EQUAL
92886: IFTRUE 92890
92888: GO 93110
92890: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92891: LD_ADDR_VAR 0 1
92895: PUSH
92896: LD_INT 1
92898: PUSH
92899: LD_INT 2
92901: PUSH
92902: LD_INT 3
92904: PUSH
92905: LD_INT 4
92907: PUSH
92908: LD_INT 5
92910: PUSH
92911: LD_INT 6
92913: PUSH
92914: LD_INT 7
92916: PUSH
92917: LD_INT 8
92919: PUSH
92920: LD_INT 9
92922: PUSH
92923: LD_INT 10
92925: PUSH
92926: LD_INT 11
92928: PUSH
92929: LD_INT 12
92931: PUSH
92932: LD_INT 13
92934: PUSH
92935: LD_INT 14
92937: PUSH
92938: LD_INT 15
92940: PUSH
92941: LD_INT 16
92943: PUSH
92944: LD_INT 17
92946: PUSH
92947: LD_INT 18
92949: PUSH
92950: LD_INT 19
92952: PUSH
92953: LD_INT 20
92955: PUSH
92956: LD_INT 21
92958: PUSH
92959: LD_INT 22
92961: PUSH
92962: LD_INT 23
92964: PUSH
92965: LD_INT 24
92967: PUSH
92968: LD_INT 25
92970: PUSH
92971: LD_INT 26
92973: PUSH
92974: LD_INT 27
92976: PUSH
92977: LD_INT 28
92979: PUSH
92980: LD_INT 29
92982: PUSH
92983: LD_INT 30
92985: PUSH
92986: LD_INT 31
92988: PUSH
92989: LD_INT 32
92991: PUSH
92992: LD_INT 33
92994: PUSH
92995: LD_INT 34
92997: PUSH
92998: LD_INT 35
93000: PUSH
93001: LD_INT 36
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 101
93044: PUSH
93045: LD_INT 102
93047: PUSH
93048: LD_INT 103
93050: PUSH
93051: LD_INT 104
93053: PUSH
93054: LD_INT 105
93056: PUSH
93057: LD_INT 106
93059: PUSH
93060: LD_INT 107
93062: PUSH
93063: LD_INT 108
93065: PUSH
93066: LD_INT 109
93068: PUSH
93069: LD_INT 110
93071: PUSH
93072: LD_INT 111
93074: PUSH
93075: LD_INT 112
93077: PUSH
93078: LD_INT 113
93080: PUSH
93081: LD_INT 114
93083: PUSH
93084: LD_INT 115
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: ST_TO_ADDR
93108: GO 93111
93110: POP
// end else
93111: GO 93330
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
93113: LD_ADDR_VAR 0 1
93117: PUSH
93118: LD_INT 1
93120: PUSH
93121: LD_INT 2
93123: PUSH
93124: LD_INT 3
93126: PUSH
93127: LD_INT 4
93129: PUSH
93130: LD_INT 5
93132: PUSH
93133: LD_INT 6
93135: PUSH
93136: LD_INT 7
93138: PUSH
93139: LD_INT 8
93141: PUSH
93142: LD_INT 9
93144: PUSH
93145: LD_INT 10
93147: PUSH
93148: LD_INT 11
93150: PUSH
93151: LD_INT 12
93153: PUSH
93154: LD_INT 13
93156: PUSH
93157: LD_INT 14
93159: PUSH
93160: LD_INT 15
93162: PUSH
93163: LD_INT 16
93165: PUSH
93166: LD_INT 17
93168: PUSH
93169: LD_INT 18
93171: PUSH
93172: LD_INT 19
93174: PUSH
93175: LD_INT 20
93177: PUSH
93178: LD_INT 21
93180: PUSH
93181: LD_INT 22
93183: PUSH
93184: LD_INT 23
93186: PUSH
93187: LD_INT 24
93189: PUSH
93190: LD_INT 25
93192: PUSH
93193: LD_INT 26
93195: PUSH
93196: LD_INT 27
93198: PUSH
93199: LD_INT 28
93201: PUSH
93202: LD_INT 29
93204: PUSH
93205: LD_INT 30
93207: PUSH
93208: LD_INT 31
93210: PUSH
93211: LD_INT 32
93213: PUSH
93214: LD_INT 33
93216: PUSH
93217: LD_INT 34
93219: PUSH
93220: LD_INT 35
93222: PUSH
93223: LD_INT 36
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 101
93266: PUSH
93267: LD_INT 102
93269: PUSH
93270: LD_INT 103
93272: PUSH
93273: LD_INT 104
93275: PUSH
93276: LD_INT 105
93278: PUSH
93279: LD_INT 106
93281: PUSH
93282: LD_INT 107
93284: PUSH
93285: LD_INT 108
93287: PUSH
93288: LD_INT 109
93290: PUSH
93291: LD_INT 110
93293: PUSH
93294: LD_INT 111
93296: PUSH
93297: LD_INT 112
93299: PUSH
93300: LD_INT 113
93302: PUSH
93303: LD_INT 114
93305: PUSH
93306: LD_INT 115
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: ST_TO_ADDR
// if result then
93330: LD_VAR 0 1
93334: IFFALSE 93623
// begin normal :=  ;
93336: LD_ADDR_VAR 0 3
93340: PUSH
93341: LD_STRING 
93343: ST_TO_ADDR
// hardcore :=  ;
93344: LD_ADDR_VAR 0 4
93348: PUSH
93349: LD_STRING 
93351: ST_TO_ADDR
// for i = 1 to normalCounter do
93352: LD_ADDR_VAR 0 5
93356: PUSH
93357: DOUBLE
93358: LD_INT 1
93360: DEC
93361: ST_TO_ADDR
93362: LD_EXP 114
93366: PUSH
93367: FOR_TO
93368: IFFALSE 93469
// begin tmp := 0 ;
93370: LD_ADDR_VAR 0 2
93374: PUSH
93375: LD_STRING 0
93377: ST_TO_ADDR
// if result [ 1 ] then
93378: LD_VAR 0 1
93382: PUSH
93383: LD_INT 1
93385: ARRAY
93386: IFFALSE 93451
// if result [ 1 ] [ 1 ] = i then
93388: LD_VAR 0 1
93392: PUSH
93393: LD_INT 1
93395: ARRAY
93396: PUSH
93397: LD_INT 1
93399: ARRAY
93400: PUSH
93401: LD_VAR 0 5
93405: EQUAL
93406: IFFALSE 93451
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93408: LD_ADDR_VAR 0 1
93412: PUSH
93413: LD_VAR 0 1
93417: PPUSH
93418: LD_INT 1
93420: PPUSH
93421: LD_VAR 0 1
93425: PUSH
93426: LD_INT 1
93428: ARRAY
93429: PPUSH
93430: LD_INT 1
93432: PPUSH
93433: CALL_OW 3
93437: PPUSH
93438: CALL_OW 1
93442: ST_TO_ADDR
// tmp := 1 ;
93443: LD_ADDR_VAR 0 2
93447: PUSH
93448: LD_STRING 1
93450: ST_TO_ADDR
// end ; normal := normal & tmp ;
93451: LD_ADDR_VAR 0 3
93455: PUSH
93456: LD_VAR 0 3
93460: PUSH
93461: LD_VAR 0 2
93465: STR
93466: ST_TO_ADDR
// end ;
93467: GO 93367
93469: POP
93470: POP
// for i = 1 to hardcoreCounter do
93471: LD_ADDR_VAR 0 5
93475: PUSH
93476: DOUBLE
93477: LD_INT 1
93479: DEC
93480: ST_TO_ADDR
93481: LD_EXP 115
93485: PUSH
93486: FOR_TO
93487: IFFALSE 93592
// begin tmp := 0 ;
93489: LD_ADDR_VAR 0 2
93493: PUSH
93494: LD_STRING 0
93496: ST_TO_ADDR
// if result [ 2 ] then
93497: LD_VAR 0 1
93501: PUSH
93502: LD_INT 2
93504: ARRAY
93505: IFFALSE 93574
// if result [ 2 ] [ 1 ] = 100 + i then
93507: LD_VAR 0 1
93511: PUSH
93512: LD_INT 2
93514: ARRAY
93515: PUSH
93516: LD_INT 1
93518: ARRAY
93519: PUSH
93520: LD_INT 100
93522: PUSH
93523: LD_VAR 0 5
93527: PLUS
93528: EQUAL
93529: IFFALSE 93574
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93531: LD_ADDR_VAR 0 1
93535: PUSH
93536: LD_VAR 0 1
93540: PPUSH
93541: LD_INT 2
93543: PPUSH
93544: LD_VAR 0 1
93548: PUSH
93549: LD_INT 2
93551: ARRAY
93552: PPUSH
93553: LD_INT 1
93555: PPUSH
93556: CALL_OW 3
93560: PPUSH
93561: CALL_OW 1
93565: ST_TO_ADDR
// tmp := 1 ;
93566: LD_ADDR_VAR 0 2
93570: PUSH
93571: LD_STRING 1
93573: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93574: LD_ADDR_VAR 0 4
93578: PUSH
93579: LD_VAR 0 4
93583: PUSH
93584: LD_VAR 0 2
93588: STR
93589: ST_TO_ADDR
// end ;
93590: GO 93486
93592: POP
93593: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93594: LD_STRING getStreamItemsFromMission("
93596: PUSH
93597: LD_VAR 0 3
93601: STR
93602: PUSH
93603: LD_STRING ","
93605: STR
93606: PUSH
93607: LD_VAR 0 4
93611: STR
93612: PUSH
93613: LD_STRING ")
93615: STR
93616: PPUSH
93617: CALL_OW 559
// end else
93621: GO 93630
// ToLua ( getStreamItemsFromMission("","") ) ;
93623: LD_STRING getStreamItemsFromMission("","")
93625: PPUSH
93626: CALL_OW 559
// end ;
93630: LD_VAR 0 1
93634: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93635: LD_EXP 113
93639: PUSH
93640: LD_EXP 118
93644: AND
93645: IFFALSE 93769
93647: GO 93649
93649: DISABLE
93650: LD_INT 0
93652: PPUSH
93653: PPUSH
// begin enable ;
93654: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93655: LD_ADDR_VAR 0 2
93659: PUSH
93660: LD_INT 22
93662: PUSH
93663: LD_OWVAR 2
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: LD_INT 2
93674: PUSH
93675: LD_INT 34
93677: PUSH
93678: LD_INT 7
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 34
93687: PUSH
93688: LD_INT 45
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 34
93697: PUSH
93698: LD_INT 28
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 34
93707: PUSH
93708: LD_INT 47
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PPUSH
93726: CALL_OW 69
93730: ST_TO_ADDR
// if not tmp then
93731: LD_VAR 0 2
93735: NOT
93736: IFFALSE 93740
// exit ;
93738: GO 93769
// for i in tmp do
93740: LD_ADDR_VAR 0 1
93744: PUSH
93745: LD_VAR 0 2
93749: PUSH
93750: FOR_IN
93751: IFFALSE 93767
// begin SetLives ( i , 0 ) ;
93753: LD_VAR 0 1
93757: PPUSH
93758: LD_INT 0
93760: PPUSH
93761: CALL_OW 234
// end ;
93765: GO 93750
93767: POP
93768: POP
// end ;
93769: PPOPN 2
93771: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93772: LD_EXP 113
93776: PUSH
93777: LD_EXP 119
93781: AND
93782: IFFALSE 93866
93784: GO 93786
93786: DISABLE
93787: LD_INT 0
93789: PPUSH
93790: PPUSH
// begin enable ;
93791: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93792: LD_ADDR_VAR 0 2
93796: PUSH
93797: LD_INT 22
93799: PUSH
93800: LD_OWVAR 2
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 32
93811: PUSH
93812: LD_INT 3
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PPUSH
93823: CALL_OW 69
93827: ST_TO_ADDR
// if not tmp then
93828: LD_VAR 0 2
93832: NOT
93833: IFFALSE 93837
// exit ;
93835: GO 93866
// for i in tmp do
93837: LD_ADDR_VAR 0 1
93841: PUSH
93842: LD_VAR 0 2
93846: PUSH
93847: FOR_IN
93848: IFFALSE 93864
// begin SetLives ( i , 0 ) ;
93850: LD_VAR 0 1
93854: PPUSH
93855: LD_INT 0
93857: PPUSH
93858: CALL_OW 234
// end ;
93862: GO 93847
93864: POP
93865: POP
// end ;
93866: PPOPN 2
93868: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93869: LD_EXP 113
93873: PUSH
93874: LD_EXP 116
93878: AND
93879: IFFALSE 93972
93881: GO 93883
93883: DISABLE
93884: LD_INT 0
93886: PPUSH
// begin enable ;
93887: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93888: LD_ADDR_VAR 0 1
93892: PUSH
93893: LD_INT 22
93895: PUSH
93896: LD_OWVAR 2
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 2
93907: PUSH
93908: LD_INT 25
93910: PUSH
93911: LD_INT 5
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 25
93920: PUSH
93921: LD_INT 9
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: LD_INT 25
93930: PUSH
93931: LD_INT 8
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PPUSH
93948: CALL_OW 69
93952: PUSH
93953: FOR_IN
93954: IFFALSE 93970
// begin SetClass ( i , 1 ) ;
93956: LD_VAR 0 1
93960: PPUSH
93961: LD_INT 1
93963: PPUSH
93964: CALL_OW 336
// end ;
93968: GO 93953
93970: POP
93971: POP
// end ;
93972: PPOPN 1
93974: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93975: LD_EXP 113
93979: PUSH
93980: LD_EXP 117
93984: AND
93985: PUSH
93986: LD_OWVAR 65
93990: PUSH
93991: LD_INT 7
93993: LESS
93994: AND
93995: IFFALSE 94009
93997: GO 93999
93999: DISABLE
// begin enable ;
94000: ENABLE
// game_speed := 7 ;
94001: LD_ADDR_OWVAR 65
94005: PUSH
94006: LD_INT 7
94008: ST_TO_ADDR
// end ;
94009: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94010: LD_EXP 113
94014: PUSH
94015: LD_EXP 120
94019: AND
94020: IFFALSE 94222
94022: GO 94024
94024: DISABLE
94025: LD_INT 0
94027: PPUSH
94028: PPUSH
94029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94030: LD_ADDR_VAR 0 3
94034: PUSH
94035: LD_INT 81
94037: PUSH
94038: LD_OWVAR 2
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 21
94049: PUSH
94050: LD_INT 1
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PPUSH
94061: CALL_OW 69
94065: ST_TO_ADDR
// if not tmp then
94066: LD_VAR 0 3
94070: NOT
94071: IFFALSE 94075
// exit ;
94073: GO 94222
// if tmp > 5 then
94075: LD_VAR 0 3
94079: PUSH
94080: LD_INT 5
94082: GREATER
94083: IFFALSE 94095
// k := 5 else
94085: LD_ADDR_VAR 0 2
94089: PUSH
94090: LD_INT 5
94092: ST_TO_ADDR
94093: GO 94105
// k := tmp ;
94095: LD_ADDR_VAR 0 2
94099: PUSH
94100: LD_VAR 0 3
94104: ST_TO_ADDR
// for i := 1 to k do
94105: LD_ADDR_VAR 0 1
94109: PUSH
94110: DOUBLE
94111: LD_INT 1
94113: DEC
94114: ST_TO_ADDR
94115: LD_VAR 0 2
94119: PUSH
94120: FOR_TO
94121: IFFALSE 94220
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94123: LD_VAR 0 3
94127: PUSH
94128: LD_VAR 0 1
94132: ARRAY
94133: PPUSH
94134: LD_VAR 0 1
94138: PUSH
94139: LD_INT 4
94141: MOD
94142: PUSH
94143: LD_INT 1
94145: PLUS
94146: PPUSH
94147: CALL_OW 259
94151: PUSH
94152: LD_INT 10
94154: LESS
94155: IFFALSE 94218
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94157: LD_VAR 0 3
94161: PUSH
94162: LD_VAR 0 1
94166: ARRAY
94167: PPUSH
94168: LD_VAR 0 1
94172: PUSH
94173: LD_INT 4
94175: MOD
94176: PUSH
94177: LD_INT 1
94179: PLUS
94180: PPUSH
94181: LD_VAR 0 3
94185: PUSH
94186: LD_VAR 0 1
94190: ARRAY
94191: PPUSH
94192: LD_VAR 0 1
94196: PUSH
94197: LD_INT 4
94199: MOD
94200: PUSH
94201: LD_INT 1
94203: PLUS
94204: PPUSH
94205: CALL_OW 259
94209: PUSH
94210: LD_INT 1
94212: PLUS
94213: PPUSH
94214: CALL_OW 237
94218: GO 94120
94220: POP
94221: POP
// end ;
94222: PPOPN 3
94224: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94225: LD_EXP 113
94229: PUSH
94230: LD_EXP 121
94234: AND
94235: IFFALSE 94255
94237: GO 94239
94239: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94240: LD_INT 4
94242: PPUSH
94243: LD_OWVAR 2
94247: PPUSH
94248: LD_INT 0
94250: PPUSH
94251: CALL_OW 324
94255: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94256: LD_EXP 113
94260: PUSH
94261: LD_EXP 150
94265: AND
94266: IFFALSE 94286
94268: GO 94270
94270: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94271: LD_INT 19
94273: PPUSH
94274: LD_OWVAR 2
94278: PPUSH
94279: LD_INT 0
94281: PPUSH
94282: CALL_OW 324
94286: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94287: LD_EXP 113
94291: PUSH
94292: LD_EXP 122
94296: AND
94297: IFFALSE 94399
94299: GO 94301
94301: DISABLE
94302: LD_INT 0
94304: PPUSH
94305: PPUSH
// begin enable ;
94306: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94307: LD_ADDR_VAR 0 2
94311: PUSH
94312: LD_INT 22
94314: PUSH
94315: LD_OWVAR 2
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: LD_INT 2
94326: PUSH
94327: LD_INT 34
94329: PUSH
94330: LD_INT 11
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 34
94339: PUSH
94340: LD_INT 30
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: LIST
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PPUSH
94356: CALL_OW 69
94360: ST_TO_ADDR
// if not tmp then
94361: LD_VAR 0 2
94365: NOT
94366: IFFALSE 94370
// exit ;
94368: GO 94399
// for i in tmp do
94370: LD_ADDR_VAR 0 1
94374: PUSH
94375: LD_VAR 0 2
94379: PUSH
94380: FOR_IN
94381: IFFALSE 94397
// begin SetLives ( i , 0 ) ;
94383: LD_VAR 0 1
94387: PPUSH
94388: LD_INT 0
94390: PPUSH
94391: CALL_OW 234
// end ;
94395: GO 94380
94397: POP
94398: POP
// end ;
94399: PPOPN 2
94401: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94402: LD_EXP 113
94406: PUSH
94407: LD_EXP 123
94411: AND
94412: IFFALSE 94432
94414: GO 94416
94416: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94417: LD_INT 32
94419: PPUSH
94420: LD_OWVAR 2
94424: PPUSH
94425: LD_INT 0
94427: PPUSH
94428: CALL_OW 324
94432: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94433: LD_EXP 113
94437: PUSH
94438: LD_EXP 124
94442: AND
94443: IFFALSE 94624
94445: GO 94447
94447: DISABLE
94448: LD_INT 0
94450: PPUSH
94451: PPUSH
94452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94453: LD_ADDR_VAR 0 2
94457: PUSH
94458: LD_INT 22
94460: PUSH
94461: LD_OWVAR 2
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 33
94472: PUSH
94473: LD_INT 3
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PPUSH
94484: CALL_OW 69
94488: ST_TO_ADDR
// if not tmp then
94489: LD_VAR 0 2
94493: NOT
94494: IFFALSE 94498
// exit ;
94496: GO 94624
// side := 0 ;
94498: LD_ADDR_VAR 0 3
94502: PUSH
94503: LD_INT 0
94505: ST_TO_ADDR
// for i := 1 to 8 do
94506: LD_ADDR_VAR 0 1
94510: PUSH
94511: DOUBLE
94512: LD_INT 1
94514: DEC
94515: ST_TO_ADDR
94516: LD_INT 8
94518: PUSH
94519: FOR_TO
94520: IFFALSE 94568
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94522: LD_OWVAR 2
94526: PUSH
94527: LD_VAR 0 1
94531: NONEQUAL
94532: PUSH
94533: LD_OWVAR 2
94537: PPUSH
94538: LD_VAR 0 1
94542: PPUSH
94543: CALL_OW 81
94547: PUSH
94548: LD_INT 2
94550: EQUAL
94551: AND
94552: IFFALSE 94566
// begin side := i ;
94554: LD_ADDR_VAR 0 3
94558: PUSH
94559: LD_VAR 0 1
94563: ST_TO_ADDR
// break ;
94564: GO 94568
// end ;
94566: GO 94519
94568: POP
94569: POP
// if not side then
94570: LD_VAR 0 3
94574: NOT
94575: IFFALSE 94579
// exit ;
94577: GO 94624
// for i := 1 to tmp do
94579: LD_ADDR_VAR 0 1
94583: PUSH
94584: DOUBLE
94585: LD_INT 1
94587: DEC
94588: ST_TO_ADDR
94589: LD_VAR 0 2
94593: PUSH
94594: FOR_TO
94595: IFFALSE 94622
// if Prob ( 60 ) then
94597: LD_INT 60
94599: PPUSH
94600: CALL_OW 13
94604: IFFALSE 94620
// SetSide ( i , side ) ;
94606: LD_VAR 0 1
94610: PPUSH
94611: LD_VAR 0 3
94615: PPUSH
94616: CALL_OW 235
94620: GO 94594
94622: POP
94623: POP
// end ;
94624: PPOPN 3
94626: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94627: LD_EXP 113
94631: PUSH
94632: LD_EXP 126
94636: AND
94637: IFFALSE 94756
94639: GO 94641
94641: DISABLE
94642: LD_INT 0
94644: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94645: LD_ADDR_VAR 0 1
94649: PUSH
94650: LD_INT 22
94652: PUSH
94653: LD_OWVAR 2
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 21
94664: PUSH
94665: LD_INT 1
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 3
94674: PUSH
94675: LD_INT 23
94677: PUSH
94678: LD_INT 0
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: EMPTY
94686: LIST
94687: LIST
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: LIST
94693: PPUSH
94694: CALL_OW 69
94698: PUSH
94699: FOR_IN
94700: IFFALSE 94754
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94702: LD_VAR 0 1
94706: PPUSH
94707: CALL_OW 257
94711: PUSH
94712: LD_INT 1
94714: PUSH
94715: LD_INT 2
94717: PUSH
94718: LD_INT 3
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: IN
94730: IFFALSE 94752
// SetClass ( un , rand ( 1 , 4 ) ) ;
94732: LD_VAR 0 1
94736: PPUSH
94737: LD_INT 1
94739: PPUSH
94740: LD_INT 4
94742: PPUSH
94743: CALL_OW 12
94747: PPUSH
94748: CALL_OW 336
94752: GO 94699
94754: POP
94755: POP
// end ;
94756: PPOPN 1
94758: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94759: LD_EXP 113
94763: PUSH
94764: LD_EXP 125
94768: AND
94769: IFFALSE 94848
94771: GO 94773
94773: DISABLE
94774: LD_INT 0
94776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94777: LD_ADDR_VAR 0 1
94781: PUSH
94782: LD_INT 22
94784: PUSH
94785: LD_OWVAR 2
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 21
94796: PUSH
94797: LD_INT 3
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PPUSH
94808: CALL_OW 69
94812: ST_TO_ADDR
// if not tmp then
94813: LD_VAR 0 1
94817: NOT
94818: IFFALSE 94822
// exit ;
94820: GO 94848
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94822: LD_VAR 0 1
94826: PUSH
94827: LD_INT 1
94829: PPUSH
94830: LD_VAR 0 1
94834: PPUSH
94835: CALL_OW 12
94839: ARRAY
94840: PPUSH
94841: LD_INT 100
94843: PPUSH
94844: CALL_OW 234
// end ;
94848: PPOPN 1
94850: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94851: LD_EXP 113
94855: PUSH
94856: LD_EXP 127
94860: AND
94861: IFFALSE 94959
94863: GO 94865
94865: DISABLE
94866: LD_INT 0
94868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94869: LD_ADDR_VAR 0 1
94873: PUSH
94874: LD_INT 22
94876: PUSH
94877: LD_OWVAR 2
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 21
94888: PUSH
94889: LD_INT 1
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PPUSH
94900: CALL_OW 69
94904: ST_TO_ADDR
// if not tmp then
94905: LD_VAR 0 1
94909: NOT
94910: IFFALSE 94914
// exit ;
94912: GO 94959
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94914: LD_VAR 0 1
94918: PUSH
94919: LD_INT 1
94921: PPUSH
94922: LD_VAR 0 1
94926: PPUSH
94927: CALL_OW 12
94931: ARRAY
94932: PPUSH
94933: LD_INT 1
94935: PPUSH
94936: LD_INT 4
94938: PPUSH
94939: CALL_OW 12
94943: PPUSH
94944: LD_INT 3000
94946: PPUSH
94947: LD_INT 9000
94949: PPUSH
94950: CALL_OW 12
94954: PPUSH
94955: CALL_OW 492
// end ;
94959: PPOPN 1
94961: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94962: LD_EXP 113
94966: PUSH
94967: LD_EXP 128
94971: AND
94972: IFFALSE 94992
94974: GO 94976
94976: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94977: LD_INT 1
94979: PPUSH
94980: LD_OWVAR 2
94984: PPUSH
94985: LD_INT 0
94987: PPUSH
94988: CALL_OW 324
94992: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94993: LD_EXP 113
94997: PUSH
94998: LD_EXP 129
95002: AND
95003: IFFALSE 95086
95005: GO 95007
95007: DISABLE
95008: LD_INT 0
95010: PPUSH
95011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95012: LD_ADDR_VAR 0 2
95016: PUSH
95017: LD_INT 22
95019: PUSH
95020: LD_OWVAR 2
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 21
95031: PUSH
95032: LD_INT 3
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PPUSH
95043: CALL_OW 69
95047: ST_TO_ADDR
// if not tmp then
95048: LD_VAR 0 2
95052: NOT
95053: IFFALSE 95057
// exit ;
95055: GO 95086
// for i in tmp do
95057: LD_ADDR_VAR 0 1
95061: PUSH
95062: LD_VAR 0 2
95066: PUSH
95067: FOR_IN
95068: IFFALSE 95084
// SetBLevel ( i , 10 ) ;
95070: LD_VAR 0 1
95074: PPUSH
95075: LD_INT 10
95077: PPUSH
95078: CALL_OW 241
95082: GO 95067
95084: POP
95085: POP
// end ;
95086: PPOPN 2
95088: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95089: LD_EXP 113
95093: PUSH
95094: LD_EXP 130
95098: AND
95099: IFFALSE 95210
95101: GO 95103
95103: DISABLE
95104: LD_INT 0
95106: PPUSH
95107: PPUSH
95108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95109: LD_ADDR_VAR 0 3
95113: PUSH
95114: LD_INT 22
95116: PUSH
95117: LD_OWVAR 2
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 25
95128: PUSH
95129: LD_INT 1
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PPUSH
95140: CALL_OW 69
95144: ST_TO_ADDR
// if not tmp then
95145: LD_VAR 0 3
95149: NOT
95150: IFFALSE 95154
// exit ;
95152: GO 95210
// un := tmp [ rand ( 1 , tmp ) ] ;
95154: LD_ADDR_VAR 0 2
95158: PUSH
95159: LD_VAR 0 3
95163: PUSH
95164: LD_INT 1
95166: PPUSH
95167: LD_VAR 0 3
95171: PPUSH
95172: CALL_OW 12
95176: ARRAY
95177: ST_TO_ADDR
// if Crawls ( un ) then
95178: LD_VAR 0 2
95182: PPUSH
95183: CALL_OW 318
95187: IFFALSE 95198
// ComWalk ( un ) ;
95189: LD_VAR 0 2
95193: PPUSH
95194: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95198: LD_VAR 0 2
95202: PPUSH
95203: LD_INT 5
95205: PPUSH
95206: CALL_OW 336
// end ;
95210: PPOPN 3
95212: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95213: LD_EXP 113
95217: PUSH
95218: LD_EXP 131
95222: AND
95223: PUSH
95224: LD_OWVAR 67
95228: PUSH
95229: LD_INT 3
95231: LESS
95232: AND
95233: IFFALSE 95252
95235: GO 95237
95237: DISABLE
// Difficulty := Difficulty + 1 ;
95238: LD_ADDR_OWVAR 67
95242: PUSH
95243: LD_OWVAR 67
95247: PUSH
95248: LD_INT 1
95250: PLUS
95251: ST_TO_ADDR
95252: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95253: LD_EXP 113
95257: PUSH
95258: LD_EXP 132
95262: AND
95263: IFFALSE 95366
95265: GO 95267
95267: DISABLE
95268: LD_INT 0
95270: PPUSH
// begin for i := 1 to 5 do
95271: LD_ADDR_VAR 0 1
95275: PUSH
95276: DOUBLE
95277: LD_INT 1
95279: DEC
95280: ST_TO_ADDR
95281: LD_INT 5
95283: PUSH
95284: FOR_TO
95285: IFFALSE 95364
// begin uc_nation := nation_nature ;
95287: LD_ADDR_OWVAR 21
95291: PUSH
95292: LD_INT 0
95294: ST_TO_ADDR
// uc_side := 0 ;
95295: LD_ADDR_OWVAR 20
95299: PUSH
95300: LD_INT 0
95302: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95303: LD_ADDR_OWVAR 29
95307: PUSH
95308: LD_INT 12
95310: PUSH
95311: LD_INT 12
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: ST_TO_ADDR
// hc_agressivity := 20 ;
95318: LD_ADDR_OWVAR 35
95322: PUSH
95323: LD_INT 20
95325: ST_TO_ADDR
// hc_class := class_tiger ;
95326: LD_ADDR_OWVAR 28
95330: PUSH
95331: LD_INT 14
95333: ST_TO_ADDR
// hc_gallery :=  ;
95334: LD_ADDR_OWVAR 33
95338: PUSH
95339: LD_STRING 
95341: ST_TO_ADDR
// hc_name :=  ;
95342: LD_ADDR_OWVAR 26
95346: PUSH
95347: LD_STRING 
95349: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95350: CALL_OW 44
95354: PPUSH
95355: LD_INT 0
95357: PPUSH
95358: CALL_OW 51
// end ;
95362: GO 95284
95364: POP
95365: POP
// end ;
95366: PPOPN 1
95368: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95369: LD_EXP 113
95373: PUSH
95374: LD_EXP 133
95378: AND
95379: IFFALSE 95388
95381: GO 95383
95383: DISABLE
// StreamSibBomb ;
95384: CALL 95389 0 0
95388: END
// export function StreamSibBomb ; var i , x , y ; begin
95389: LD_INT 0
95391: PPUSH
95392: PPUSH
95393: PPUSH
95394: PPUSH
// result := false ;
95395: LD_ADDR_VAR 0 1
95399: PUSH
95400: LD_INT 0
95402: ST_TO_ADDR
// for i := 1 to 16 do
95403: LD_ADDR_VAR 0 2
95407: PUSH
95408: DOUBLE
95409: LD_INT 1
95411: DEC
95412: ST_TO_ADDR
95413: LD_INT 16
95415: PUSH
95416: FOR_TO
95417: IFFALSE 95616
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95419: LD_ADDR_VAR 0 3
95423: PUSH
95424: LD_INT 10
95426: PUSH
95427: LD_INT 20
95429: PUSH
95430: LD_INT 30
95432: PUSH
95433: LD_INT 40
95435: PUSH
95436: LD_INT 50
95438: PUSH
95439: LD_INT 60
95441: PUSH
95442: LD_INT 70
95444: PUSH
95445: LD_INT 80
95447: PUSH
95448: LD_INT 90
95450: PUSH
95451: LD_INT 100
95453: PUSH
95454: LD_INT 110
95456: PUSH
95457: LD_INT 120
95459: PUSH
95460: LD_INT 130
95462: PUSH
95463: LD_INT 140
95465: PUSH
95466: LD_INT 150
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 1
95488: PPUSH
95489: LD_INT 15
95491: PPUSH
95492: CALL_OW 12
95496: ARRAY
95497: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95498: LD_ADDR_VAR 0 4
95502: PUSH
95503: LD_INT 10
95505: PUSH
95506: LD_INT 20
95508: PUSH
95509: LD_INT 30
95511: PUSH
95512: LD_INT 40
95514: PUSH
95515: LD_INT 50
95517: PUSH
95518: LD_INT 60
95520: PUSH
95521: LD_INT 70
95523: PUSH
95524: LD_INT 80
95526: PUSH
95527: LD_INT 90
95529: PUSH
95530: LD_INT 100
95532: PUSH
95533: LD_INT 110
95535: PUSH
95536: LD_INT 120
95538: PUSH
95539: LD_INT 130
95541: PUSH
95542: LD_INT 140
95544: PUSH
95545: LD_INT 150
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 1
95567: PPUSH
95568: LD_INT 15
95570: PPUSH
95571: CALL_OW 12
95575: ARRAY
95576: ST_TO_ADDR
// if ValidHex ( x , y ) then
95577: LD_VAR 0 3
95581: PPUSH
95582: LD_VAR 0 4
95586: PPUSH
95587: CALL_OW 488
95591: IFFALSE 95614
// begin result := [ x , y ] ;
95593: LD_ADDR_VAR 0 1
95597: PUSH
95598: LD_VAR 0 3
95602: PUSH
95603: LD_VAR 0 4
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: ST_TO_ADDR
// break ;
95612: GO 95616
// end ; end ;
95614: GO 95416
95616: POP
95617: POP
// if result then
95618: LD_VAR 0 1
95622: IFFALSE 95682
// begin ToLua ( playSibBomb() ) ;
95624: LD_STRING playSibBomb()
95626: PPUSH
95627: CALL_OW 559
// wait ( 0 0$14 ) ;
95631: LD_INT 490
95633: PPUSH
95634: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95638: LD_VAR 0 1
95642: PUSH
95643: LD_INT 1
95645: ARRAY
95646: PPUSH
95647: LD_VAR 0 1
95651: PUSH
95652: LD_INT 2
95654: ARRAY
95655: PPUSH
95656: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95660: LD_VAR 0 1
95664: PUSH
95665: LD_INT 1
95667: ARRAY
95668: PPUSH
95669: LD_VAR 0 1
95673: PUSH
95674: LD_INT 2
95676: ARRAY
95677: PPUSH
95678: CALL_OW 429
// end ; end ;
95682: LD_VAR 0 1
95686: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95687: LD_EXP 113
95691: PUSH
95692: LD_EXP 135
95696: AND
95697: IFFALSE 95709
95699: GO 95701
95701: DISABLE
// YouLost (  ) ;
95702: LD_STRING 
95704: PPUSH
95705: CALL_OW 104
95709: END
// every 0 0$1 trigger StreamModeActive and sFog do
95710: LD_EXP 113
95714: PUSH
95715: LD_EXP 134
95719: AND
95720: IFFALSE 95734
95722: GO 95724
95724: DISABLE
// FogOff ( your_side ) ;
95725: LD_OWVAR 2
95729: PPUSH
95730: CALL_OW 344
95734: END
// every 0 0$1 trigger StreamModeActive and sSun do
95735: LD_EXP 113
95739: PUSH
95740: LD_EXP 136
95744: AND
95745: IFFALSE 95773
95747: GO 95749
95749: DISABLE
// begin solar_recharge_percent := 0 ;
95750: LD_ADDR_OWVAR 79
95754: PUSH
95755: LD_INT 0
95757: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95758: LD_INT 10500
95760: PPUSH
95761: CALL_OW 67
// solar_recharge_percent := 100 ;
95765: LD_ADDR_OWVAR 79
95769: PUSH
95770: LD_INT 100
95772: ST_TO_ADDR
// end ;
95773: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95774: LD_EXP 113
95778: PUSH
95779: LD_EXP 137
95783: AND
95784: IFFALSE 96023
95786: GO 95788
95788: DISABLE
95789: LD_INT 0
95791: PPUSH
95792: PPUSH
95793: PPUSH
// begin tmp := [ ] ;
95794: LD_ADDR_VAR 0 3
95798: PUSH
95799: EMPTY
95800: ST_TO_ADDR
// for i := 1 to 6 do
95801: LD_ADDR_VAR 0 1
95805: PUSH
95806: DOUBLE
95807: LD_INT 1
95809: DEC
95810: ST_TO_ADDR
95811: LD_INT 6
95813: PUSH
95814: FOR_TO
95815: IFFALSE 95920
// begin uc_nation := nation_nature ;
95817: LD_ADDR_OWVAR 21
95821: PUSH
95822: LD_INT 0
95824: ST_TO_ADDR
// uc_side := 0 ;
95825: LD_ADDR_OWVAR 20
95829: PUSH
95830: LD_INT 0
95832: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95833: LD_ADDR_OWVAR 29
95837: PUSH
95838: LD_INT 12
95840: PUSH
95841: LD_INT 12
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: ST_TO_ADDR
// hc_agressivity := 20 ;
95848: LD_ADDR_OWVAR 35
95852: PUSH
95853: LD_INT 20
95855: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95856: LD_ADDR_OWVAR 28
95860: PUSH
95861: LD_INT 17
95863: ST_TO_ADDR
// hc_gallery :=  ;
95864: LD_ADDR_OWVAR 33
95868: PUSH
95869: LD_STRING 
95871: ST_TO_ADDR
// hc_name :=  ;
95872: LD_ADDR_OWVAR 26
95876: PUSH
95877: LD_STRING 
95879: ST_TO_ADDR
// un := CreateHuman ;
95880: LD_ADDR_VAR 0 2
95884: PUSH
95885: CALL_OW 44
95889: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95890: LD_VAR 0 2
95894: PPUSH
95895: LD_INT 1
95897: PPUSH
95898: CALL_OW 51
// tmp := tmp ^ un ;
95902: LD_ADDR_VAR 0 3
95906: PUSH
95907: LD_VAR 0 3
95911: PUSH
95912: LD_VAR 0 2
95916: ADD
95917: ST_TO_ADDR
// end ;
95918: GO 95814
95920: POP
95921: POP
// repeat wait ( 0 0$1 ) ;
95922: LD_INT 35
95924: PPUSH
95925: CALL_OW 67
// for un in tmp do
95929: LD_ADDR_VAR 0 2
95933: PUSH
95934: LD_VAR 0 3
95938: PUSH
95939: FOR_IN
95940: IFFALSE 96014
// begin if IsDead ( un ) then
95942: LD_VAR 0 2
95946: PPUSH
95947: CALL_OW 301
95951: IFFALSE 95971
// begin tmp := tmp diff un ;
95953: LD_ADDR_VAR 0 3
95957: PUSH
95958: LD_VAR 0 3
95962: PUSH
95963: LD_VAR 0 2
95967: DIFF
95968: ST_TO_ADDR
// continue ;
95969: GO 95939
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95971: LD_VAR 0 2
95975: PPUSH
95976: LD_INT 3
95978: PUSH
95979: LD_INT 22
95981: PUSH
95982: LD_INT 0
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PPUSH
95993: CALL_OW 69
95997: PPUSH
95998: LD_VAR 0 2
96002: PPUSH
96003: CALL_OW 74
96007: PPUSH
96008: CALL_OW 115
// end ;
96012: GO 95939
96014: POP
96015: POP
// until not tmp ;
96016: LD_VAR 0 3
96020: NOT
96021: IFFALSE 95922
// end ;
96023: PPOPN 3
96025: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96026: LD_EXP 113
96030: PUSH
96031: LD_EXP 138
96035: AND
96036: IFFALSE 96090
96038: GO 96040
96040: DISABLE
// begin ToLua ( displayTroll(); ) ;
96041: LD_STRING displayTroll();
96043: PPUSH
96044: CALL_OW 559
// wait ( 3 3$00 ) ;
96048: LD_INT 6300
96050: PPUSH
96051: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96055: LD_STRING hideTroll();
96057: PPUSH
96058: CALL_OW 559
// wait ( 1 1$00 ) ;
96062: LD_INT 2100
96064: PPUSH
96065: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96069: LD_STRING displayTroll();
96071: PPUSH
96072: CALL_OW 559
// wait ( 1 1$00 ) ;
96076: LD_INT 2100
96078: PPUSH
96079: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96083: LD_STRING hideTroll();
96085: PPUSH
96086: CALL_OW 559
// end ;
96090: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96091: LD_EXP 113
96095: PUSH
96096: LD_EXP 139
96100: AND
96101: IFFALSE 96164
96103: GO 96105
96105: DISABLE
96106: LD_INT 0
96108: PPUSH
// begin p := 0 ;
96109: LD_ADDR_VAR 0 1
96113: PUSH
96114: LD_INT 0
96116: ST_TO_ADDR
// repeat game_speed := 1 ;
96117: LD_ADDR_OWVAR 65
96121: PUSH
96122: LD_INT 1
96124: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96125: LD_INT 35
96127: PPUSH
96128: CALL_OW 67
// p := p + 1 ;
96132: LD_ADDR_VAR 0 1
96136: PUSH
96137: LD_VAR 0 1
96141: PUSH
96142: LD_INT 1
96144: PLUS
96145: ST_TO_ADDR
// until p >= 60 ;
96146: LD_VAR 0 1
96150: PUSH
96151: LD_INT 60
96153: GREATEREQUAL
96154: IFFALSE 96117
// game_speed := 4 ;
96156: LD_ADDR_OWVAR 65
96160: PUSH
96161: LD_INT 4
96163: ST_TO_ADDR
// end ;
96164: PPOPN 1
96166: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96167: LD_EXP 113
96171: PUSH
96172: LD_EXP 140
96176: AND
96177: IFFALSE 96323
96179: GO 96181
96181: DISABLE
96182: LD_INT 0
96184: PPUSH
96185: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96186: LD_ADDR_VAR 0 1
96190: PUSH
96191: LD_INT 22
96193: PUSH
96194: LD_OWVAR 2
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 2
96205: PUSH
96206: LD_INT 30
96208: PUSH
96209: LD_INT 0
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 30
96218: PUSH
96219: LD_INT 1
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: LIST
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PPUSH
96235: CALL_OW 69
96239: ST_TO_ADDR
// if not depot then
96240: LD_VAR 0 1
96244: NOT
96245: IFFALSE 96249
// exit ;
96247: GO 96323
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96249: LD_ADDR_VAR 0 2
96253: PUSH
96254: LD_VAR 0 1
96258: PUSH
96259: LD_INT 1
96261: PPUSH
96262: LD_VAR 0 1
96266: PPUSH
96267: CALL_OW 12
96271: ARRAY
96272: PPUSH
96273: CALL_OW 274
96277: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96278: LD_VAR 0 2
96282: PPUSH
96283: LD_INT 1
96285: PPUSH
96286: LD_INT 0
96288: PPUSH
96289: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96293: LD_VAR 0 2
96297: PPUSH
96298: LD_INT 2
96300: PPUSH
96301: LD_INT 0
96303: PPUSH
96304: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96308: LD_VAR 0 2
96312: PPUSH
96313: LD_INT 3
96315: PPUSH
96316: LD_INT 0
96318: PPUSH
96319: CALL_OW 277
// end ;
96323: PPOPN 2
96325: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96326: LD_EXP 113
96330: PUSH
96331: LD_EXP 141
96335: AND
96336: IFFALSE 96433
96338: GO 96340
96340: DISABLE
96341: LD_INT 0
96343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96344: LD_ADDR_VAR 0 1
96348: PUSH
96349: LD_INT 22
96351: PUSH
96352: LD_OWVAR 2
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 21
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 3
96373: PUSH
96374: LD_INT 23
96376: PUSH
96377: LD_INT 0
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: LIST
96392: PPUSH
96393: CALL_OW 69
96397: ST_TO_ADDR
// if not tmp then
96398: LD_VAR 0 1
96402: NOT
96403: IFFALSE 96407
// exit ;
96405: GO 96433
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96407: LD_VAR 0 1
96411: PUSH
96412: LD_INT 1
96414: PPUSH
96415: LD_VAR 0 1
96419: PPUSH
96420: CALL_OW 12
96424: ARRAY
96425: PPUSH
96426: LD_INT 200
96428: PPUSH
96429: CALL_OW 234
// end ;
96433: PPOPN 1
96435: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96436: LD_EXP 113
96440: PUSH
96441: LD_EXP 142
96445: AND
96446: IFFALSE 96525
96448: GO 96450
96450: DISABLE
96451: LD_INT 0
96453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96454: LD_ADDR_VAR 0 1
96458: PUSH
96459: LD_INT 22
96461: PUSH
96462: LD_OWVAR 2
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 21
96473: PUSH
96474: LD_INT 2
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PPUSH
96485: CALL_OW 69
96489: ST_TO_ADDR
// if not tmp then
96490: LD_VAR 0 1
96494: NOT
96495: IFFALSE 96499
// exit ;
96497: GO 96525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96499: LD_VAR 0 1
96503: PUSH
96504: LD_INT 1
96506: PPUSH
96507: LD_VAR 0 1
96511: PPUSH
96512: CALL_OW 12
96516: ARRAY
96517: PPUSH
96518: LD_INT 60
96520: PPUSH
96521: CALL_OW 234
// end ;
96525: PPOPN 1
96527: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96528: LD_EXP 113
96532: PUSH
96533: LD_EXP 143
96537: AND
96538: IFFALSE 96637
96540: GO 96542
96542: DISABLE
96543: LD_INT 0
96545: PPUSH
96546: PPUSH
// begin enable ;
96547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96548: LD_ADDR_VAR 0 1
96552: PUSH
96553: LD_INT 22
96555: PUSH
96556: LD_OWVAR 2
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 61
96567: PUSH
96568: EMPTY
96569: LIST
96570: PUSH
96571: LD_INT 33
96573: PUSH
96574: LD_INT 2
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: LIST
96585: PPUSH
96586: CALL_OW 69
96590: ST_TO_ADDR
// if not tmp then
96591: LD_VAR 0 1
96595: NOT
96596: IFFALSE 96600
// exit ;
96598: GO 96637
// for i in tmp do
96600: LD_ADDR_VAR 0 2
96604: PUSH
96605: LD_VAR 0 1
96609: PUSH
96610: FOR_IN
96611: IFFALSE 96635
// if IsControledBy ( i ) then
96613: LD_VAR 0 2
96617: PPUSH
96618: CALL_OW 312
96622: IFFALSE 96633
// ComUnlink ( i ) ;
96624: LD_VAR 0 2
96628: PPUSH
96629: CALL_OW 136
96633: GO 96610
96635: POP
96636: POP
// end ;
96637: PPOPN 2
96639: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96640: LD_EXP 113
96644: PUSH
96645: LD_EXP 144
96649: AND
96650: IFFALSE 96790
96652: GO 96654
96654: DISABLE
96655: LD_INT 0
96657: PPUSH
96658: PPUSH
// begin ToLua ( displayPowell(); ) ;
96659: LD_STRING displayPowell();
96661: PPUSH
96662: CALL_OW 559
// uc_side := 0 ;
96666: LD_ADDR_OWVAR 20
96670: PUSH
96671: LD_INT 0
96673: ST_TO_ADDR
// uc_nation := 2 ;
96674: LD_ADDR_OWVAR 21
96678: PUSH
96679: LD_INT 2
96681: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96682: LD_ADDR_OWVAR 37
96686: PUSH
96687: LD_INT 14
96689: ST_TO_ADDR
// vc_engine := engine_siberite ;
96690: LD_ADDR_OWVAR 39
96694: PUSH
96695: LD_INT 3
96697: ST_TO_ADDR
// vc_control := control_apeman ;
96698: LD_ADDR_OWVAR 38
96702: PUSH
96703: LD_INT 5
96705: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96706: LD_ADDR_OWVAR 40
96710: PUSH
96711: LD_INT 29
96713: ST_TO_ADDR
// un := CreateVehicle ;
96714: LD_ADDR_VAR 0 2
96718: PUSH
96719: CALL_OW 45
96723: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96724: LD_VAR 0 2
96728: PPUSH
96729: LD_INT 1
96731: PPUSH
96732: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96736: LD_INT 35
96738: PPUSH
96739: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96743: LD_VAR 0 2
96747: PPUSH
96748: LD_INT 22
96750: PUSH
96751: LD_OWVAR 2
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PPUSH
96760: CALL_OW 69
96764: PPUSH
96765: LD_VAR 0 2
96769: PPUSH
96770: CALL_OW 74
96774: PPUSH
96775: CALL_OW 115
// until IsDead ( un ) ;
96779: LD_VAR 0 2
96783: PPUSH
96784: CALL_OW 301
96788: IFFALSE 96736
// end ;
96790: PPOPN 2
96792: END
// every 0 0$1 trigger StreamModeActive and sStu do
96793: LD_EXP 113
96797: PUSH
96798: LD_EXP 152
96802: AND
96803: IFFALSE 96819
96805: GO 96807
96807: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96808: LD_STRING displayStucuk();
96810: PPUSH
96811: CALL_OW 559
// ResetFog ;
96815: CALL_OW 335
// end ;
96819: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96820: LD_EXP 113
96824: PUSH
96825: LD_EXP 145
96829: AND
96830: IFFALSE 96971
96832: GO 96834
96834: DISABLE
96835: LD_INT 0
96837: PPUSH
96838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96839: LD_ADDR_VAR 0 2
96843: PUSH
96844: LD_INT 22
96846: PUSH
96847: LD_OWVAR 2
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 21
96858: PUSH
96859: LD_INT 1
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: PPUSH
96870: CALL_OW 69
96874: ST_TO_ADDR
// if not tmp then
96875: LD_VAR 0 2
96879: NOT
96880: IFFALSE 96884
// exit ;
96882: GO 96971
// un := tmp [ rand ( 1 , tmp ) ] ;
96884: LD_ADDR_VAR 0 1
96888: PUSH
96889: LD_VAR 0 2
96893: PUSH
96894: LD_INT 1
96896: PPUSH
96897: LD_VAR 0 2
96901: PPUSH
96902: CALL_OW 12
96906: ARRAY
96907: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96908: LD_VAR 0 1
96912: PPUSH
96913: LD_INT 0
96915: PPUSH
96916: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96920: LD_VAR 0 1
96924: PPUSH
96925: LD_OWVAR 3
96929: PUSH
96930: LD_VAR 0 1
96934: DIFF
96935: PPUSH
96936: LD_VAR 0 1
96940: PPUSH
96941: CALL_OW 74
96945: PPUSH
96946: CALL_OW 115
// wait ( 0 0$20 ) ;
96950: LD_INT 700
96952: PPUSH
96953: CALL_OW 67
// SetSide ( un , your_side ) ;
96957: LD_VAR 0 1
96961: PPUSH
96962: LD_OWVAR 2
96966: PPUSH
96967: CALL_OW 235
// end ;
96971: PPOPN 2
96973: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96974: LD_EXP 113
96978: PUSH
96979: LD_EXP 146
96983: AND
96984: IFFALSE 97090
96986: GO 96988
96988: DISABLE
96989: LD_INT 0
96991: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96992: LD_ADDR_VAR 0 1
96996: PUSH
96997: LD_INT 22
96999: PUSH
97000: LD_OWVAR 2
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: LD_INT 2
97011: PUSH
97012: LD_INT 30
97014: PUSH
97015: LD_INT 0
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 30
97024: PUSH
97025: LD_INT 1
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PPUSH
97041: CALL_OW 69
97045: ST_TO_ADDR
// if not depot then
97046: LD_VAR 0 1
97050: NOT
97051: IFFALSE 97055
// exit ;
97053: GO 97090
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97055: LD_VAR 0 1
97059: PUSH
97060: LD_INT 1
97062: ARRAY
97063: PPUSH
97064: CALL_OW 250
97068: PPUSH
97069: LD_VAR 0 1
97073: PUSH
97074: LD_INT 1
97076: ARRAY
97077: PPUSH
97078: CALL_OW 251
97082: PPUSH
97083: LD_INT 70
97085: PPUSH
97086: CALL_OW 495
// end ;
97090: PPOPN 1
97092: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97093: LD_EXP 113
97097: PUSH
97098: LD_EXP 147
97102: AND
97103: IFFALSE 97314
97105: GO 97107
97107: DISABLE
97108: LD_INT 0
97110: PPUSH
97111: PPUSH
97112: PPUSH
97113: PPUSH
97114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97115: LD_ADDR_VAR 0 5
97119: PUSH
97120: LD_INT 22
97122: PUSH
97123: LD_OWVAR 2
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PUSH
97132: LD_INT 21
97134: PUSH
97135: LD_INT 1
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: PPUSH
97146: CALL_OW 69
97150: ST_TO_ADDR
// if not tmp then
97151: LD_VAR 0 5
97155: NOT
97156: IFFALSE 97160
// exit ;
97158: GO 97314
// for i in tmp do
97160: LD_ADDR_VAR 0 1
97164: PUSH
97165: LD_VAR 0 5
97169: PUSH
97170: FOR_IN
97171: IFFALSE 97312
// begin d := rand ( 0 , 5 ) ;
97173: LD_ADDR_VAR 0 4
97177: PUSH
97178: LD_INT 0
97180: PPUSH
97181: LD_INT 5
97183: PPUSH
97184: CALL_OW 12
97188: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97189: LD_ADDR_VAR 0 2
97193: PUSH
97194: LD_VAR 0 1
97198: PPUSH
97199: CALL_OW 250
97203: PPUSH
97204: LD_VAR 0 4
97208: PPUSH
97209: LD_INT 3
97211: PPUSH
97212: LD_INT 12
97214: PPUSH
97215: CALL_OW 12
97219: PPUSH
97220: CALL_OW 272
97224: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97225: LD_ADDR_VAR 0 3
97229: PUSH
97230: LD_VAR 0 1
97234: PPUSH
97235: CALL_OW 251
97239: PPUSH
97240: LD_VAR 0 4
97244: PPUSH
97245: LD_INT 3
97247: PPUSH
97248: LD_INT 12
97250: PPUSH
97251: CALL_OW 12
97255: PPUSH
97256: CALL_OW 273
97260: ST_TO_ADDR
// if ValidHex ( x , y ) then
97261: LD_VAR 0 2
97265: PPUSH
97266: LD_VAR 0 3
97270: PPUSH
97271: CALL_OW 488
97275: IFFALSE 97310
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97277: LD_VAR 0 1
97281: PPUSH
97282: LD_VAR 0 2
97286: PPUSH
97287: LD_VAR 0 3
97291: PPUSH
97292: LD_INT 3
97294: PPUSH
97295: LD_INT 6
97297: PPUSH
97298: CALL_OW 12
97302: PPUSH
97303: LD_INT 1
97305: PPUSH
97306: CALL_OW 483
// end ;
97310: GO 97170
97312: POP
97313: POP
// end ;
97314: PPOPN 5
97316: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97317: LD_EXP 113
97321: PUSH
97322: LD_EXP 148
97326: AND
97327: IFFALSE 97421
97329: GO 97331
97331: DISABLE
97332: LD_INT 0
97334: PPUSH
97335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97336: LD_ADDR_VAR 0 2
97340: PUSH
97341: LD_INT 22
97343: PUSH
97344: LD_OWVAR 2
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: LD_INT 32
97355: PUSH
97356: LD_INT 1
97358: PUSH
97359: EMPTY
97360: LIST
97361: LIST
97362: PUSH
97363: LD_INT 21
97365: PUSH
97366: LD_INT 2
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: LIST
97377: PPUSH
97378: CALL_OW 69
97382: ST_TO_ADDR
// if not tmp then
97383: LD_VAR 0 2
97387: NOT
97388: IFFALSE 97392
// exit ;
97390: GO 97421
// for i in tmp do
97392: LD_ADDR_VAR 0 1
97396: PUSH
97397: LD_VAR 0 2
97401: PUSH
97402: FOR_IN
97403: IFFALSE 97419
// SetFuel ( i , 0 ) ;
97405: LD_VAR 0 1
97409: PPUSH
97410: LD_INT 0
97412: PPUSH
97413: CALL_OW 240
97417: GO 97402
97419: POP
97420: POP
// end ;
97421: PPOPN 2
97423: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97424: LD_EXP 113
97428: PUSH
97429: LD_EXP 149
97433: AND
97434: IFFALSE 97500
97436: GO 97438
97438: DISABLE
97439: LD_INT 0
97441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97442: LD_ADDR_VAR 0 1
97446: PUSH
97447: LD_INT 22
97449: PUSH
97450: LD_OWVAR 2
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 30
97461: PUSH
97462: LD_INT 29
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: EMPTY
97470: LIST
97471: LIST
97472: PPUSH
97473: CALL_OW 69
97477: ST_TO_ADDR
// if not tmp then
97478: LD_VAR 0 1
97482: NOT
97483: IFFALSE 97487
// exit ;
97485: GO 97500
// DestroyUnit ( tmp [ 1 ] ) ;
97487: LD_VAR 0 1
97491: PUSH
97492: LD_INT 1
97494: ARRAY
97495: PPUSH
97496: CALL_OW 65
// end ;
97500: PPOPN 1
97502: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97503: LD_EXP 113
97507: PUSH
97508: LD_EXP 151
97512: AND
97513: IFFALSE 97642
97515: GO 97517
97517: DISABLE
97518: LD_INT 0
97520: PPUSH
// begin uc_side := 0 ;
97521: LD_ADDR_OWVAR 20
97525: PUSH
97526: LD_INT 0
97528: ST_TO_ADDR
// uc_nation := nation_arabian ;
97529: LD_ADDR_OWVAR 21
97533: PUSH
97534: LD_INT 2
97536: ST_TO_ADDR
// hc_gallery :=  ;
97537: LD_ADDR_OWVAR 33
97541: PUSH
97542: LD_STRING 
97544: ST_TO_ADDR
// hc_name :=  ;
97545: LD_ADDR_OWVAR 26
97549: PUSH
97550: LD_STRING 
97552: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97553: LD_INT 1
97555: PPUSH
97556: LD_INT 11
97558: PPUSH
97559: LD_INT 10
97561: PPUSH
97562: CALL_OW 380
// un := CreateHuman ;
97566: LD_ADDR_VAR 0 1
97570: PUSH
97571: CALL_OW 44
97575: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97576: LD_VAR 0 1
97580: PPUSH
97581: LD_INT 1
97583: PPUSH
97584: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97588: LD_INT 35
97590: PPUSH
97591: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97595: LD_VAR 0 1
97599: PPUSH
97600: LD_INT 22
97602: PUSH
97603: LD_OWVAR 2
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: PPUSH
97612: CALL_OW 69
97616: PPUSH
97617: LD_VAR 0 1
97621: PPUSH
97622: CALL_OW 74
97626: PPUSH
97627: CALL_OW 115
// until IsDead ( un ) ;
97631: LD_VAR 0 1
97635: PPUSH
97636: CALL_OW 301
97640: IFFALSE 97588
// end ;
97642: PPOPN 1
97644: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97645: LD_EXP 113
97649: PUSH
97650: LD_EXP 153
97654: AND
97655: IFFALSE 97667
97657: GO 97659
97659: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97660: LD_STRING earthquake(getX(game), 0, 32)
97662: PPUSH
97663: CALL_OW 559
97667: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97668: LD_EXP 113
97672: PUSH
97673: LD_EXP 154
97677: AND
97678: IFFALSE 97769
97680: GO 97682
97682: DISABLE
97683: LD_INT 0
97685: PPUSH
// begin enable ;
97686: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97687: LD_ADDR_VAR 0 1
97691: PUSH
97692: LD_INT 22
97694: PUSH
97695: LD_OWVAR 2
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: PUSH
97704: LD_INT 21
97706: PUSH
97707: LD_INT 2
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: PUSH
97714: LD_INT 33
97716: PUSH
97717: LD_INT 3
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: LIST
97728: PPUSH
97729: CALL_OW 69
97733: ST_TO_ADDR
// if not tmp then
97734: LD_VAR 0 1
97738: NOT
97739: IFFALSE 97743
// exit ;
97741: GO 97769
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97743: LD_VAR 0 1
97747: PUSH
97748: LD_INT 1
97750: PPUSH
97751: LD_VAR 0 1
97755: PPUSH
97756: CALL_OW 12
97760: ARRAY
97761: PPUSH
97762: LD_INT 1
97764: PPUSH
97765: CALL_OW 234
// end ;
97769: PPOPN 1
97771: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97772: LD_EXP 113
97776: PUSH
97777: LD_EXP 155
97781: AND
97782: IFFALSE 97923
97784: GO 97786
97786: DISABLE
97787: LD_INT 0
97789: PPUSH
97790: PPUSH
97791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97792: LD_ADDR_VAR 0 3
97796: PUSH
97797: LD_INT 22
97799: PUSH
97800: LD_OWVAR 2
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 25
97811: PUSH
97812: LD_INT 1
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PUSH
97819: EMPTY
97820: LIST
97821: LIST
97822: PPUSH
97823: CALL_OW 69
97827: ST_TO_ADDR
// if not tmp then
97828: LD_VAR 0 3
97832: NOT
97833: IFFALSE 97837
// exit ;
97835: GO 97923
// un := tmp [ rand ( 1 , tmp ) ] ;
97837: LD_ADDR_VAR 0 2
97841: PUSH
97842: LD_VAR 0 3
97846: PUSH
97847: LD_INT 1
97849: PPUSH
97850: LD_VAR 0 3
97854: PPUSH
97855: CALL_OW 12
97859: ARRAY
97860: ST_TO_ADDR
// if Crawls ( un ) then
97861: LD_VAR 0 2
97865: PPUSH
97866: CALL_OW 318
97870: IFFALSE 97881
// ComWalk ( un ) ;
97872: LD_VAR 0 2
97876: PPUSH
97877: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97881: LD_VAR 0 2
97885: PPUSH
97886: LD_INT 9
97888: PPUSH
97889: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97893: LD_INT 28
97895: PPUSH
97896: LD_OWVAR 2
97900: PPUSH
97901: LD_INT 2
97903: PPUSH
97904: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97908: LD_INT 29
97910: PPUSH
97911: LD_OWVAR 2
97915: PPUSH
97916: LD_INT 2
97918: PPUSH
97919: CALL_OW 322
// end ;
97923: PPOPN 3
97925: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97926: LD_EXP 113
97930: PUSH
97931: LD_EXP 156
97935: AND
97936: IFFALSE 98047
97938: GO 97940
97940: DISABLE
97941: LD_INT 0
97943: PPUSH
97944: PPUSH
97945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97946: LD_ADDR_VAR 0 3
97950: PUSH
97951: LD_INT 22
97953: PUSH
97954: LD_OWVAR 2
97958: PUSH
97959: EMPTY
97960: LIST
97961: LIST
97962: PUSH
97963: LD_INT 25
97965: PUSH
97966: LD_INT 1
97968: PUSH
97969: EMPTY
97970: LIST
97971: LIST
97972: PUSH
97973: EMPTY
97974: LIST
97975: LIST
97976: PPUSH
97977: CALL_OW 69
97981: ST_TO_ADDR
// if not tmp then
97982: LD_VAR 0 3
97986: NOT
97987: IFFALSE 97991
// exit ;
97989: GO 98047
// un := tmp [ rand ( 1 , tmp ) ] ;
97991: LD_ADDR_VAR 0 2
97995: PUSH
97996: LD_VAR 0 3
98000: PUSH
98001: LD_INT 1
98003: PPUSH
98004: LD_VAR 0 3
98008: PPUSH
98009: CALL_OW 12
98013: ARRAY
98014: ST_TO_ADDR
// if Crawls ( un ) then
98015: LD_VAR 0 2
98019: PPUSH
98020: CALL_OW 318
98024: IFFALSE 98035
// ComWalk ( un ) ;
98026: LD_VAR 0 2
98030: PPUSH
98031: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98035: LD_VAR 0 2
98039: PPUSH
98040: LD_INT 8
98042: PPUSH
98043: CALL_OW 336
// end ;
98047: PPOPN 3
98049: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98050: LD_EXP 113
98054: PUSH
98055: LD_EXP 157
98059: AND
98060: IFFALSE 98204
98062: GO 98064
98064: DISABLE
98065: LD_INT 0
98067: PPUSH
98068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98069: LD_ADDR_VAR 0 2
98073: PUSH
98074: LD_INT 22
98076: PUSH
98077: LD_OWVAR 2
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PUSH
98086: LD_INT 21
98088: PUSH
98089: LD_INT 2
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PUSH
98096: LD_INT 2
98098: PUSH
98099: LD_INT 34
98101: PUSH
98102: LD_INT 12
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PUSH
98109: LD_INT 34
98111: PUSH
98112: LD_INT 51
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: PUSH
98119: LD_INT 34
98121: PUSH
98122: LD_INT 32
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: LIST
98139: PPUSH
98140: CALL_OW 69
98144: ST_TO_ADDR
// if not tmp then
98145: LD_VAR 0 2
98149: NOT
98150: IFFALSE 98154
// exit ;
98152: GO 98204
// for i in tmp do
98154: LD_ADDR_VAR 0 1
98158: PUSH
98159: LD_VAR 0 2
98163: PUSH
98164: FOR_IN
98165: IFFALSE 98202
// if GetCargo ( i , mat_artifact ) = 0 then
98167: LD_VAR 0 1
98171: PPUSH
98172: LD_INT 4
98174: PPUSH
98175: CALL_OW 289
98179: PUSH
98180: LD_INT 0
98182: EQUAL
98183: IFFALSE 98200
// SetCargo ( i , mat_siberit , 100 ) ;
98185: LD_VAR 0 1
98189: PPUSH
98190: LD_INT 3
98192: PPUSH
98193: LD_INT 100
98195: PPUSH
98196: CALL_OW 290
98200: GO 98164
98202: POP
98203: POP
// end ;
98204: PPOPN 2
98206: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98207: LD_EXP 113
98211: PUSH
98212: LD_EXP 158
98216: AND
98217: IFFALSE 98400
98219: GO 98221
98221: DISABLE
98222: LD_INT 0
98224: PPUSH
98225: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98226: LD_ADDR_VAR 0 2
98230: PUSH
98231: LD_INT 22
98233: PUSH
98234: LD_OWVAR 2
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PPUSH
98243: CALL_OW 69
98247: ST_TO_ADDR
// if not tmp then
98248: LD_VAR 0 2
98252: NOT
98253: IFFALSE 98257
// exit ;
98255: GO 98400
// for i := 1 to 2 do
98257: LD_ADDR_VAR 0 1
98261: PUSH
98262: DOUBLE
98263: LD_INT 1
98265: DEC
98266: ST_TO_ADDR
98267: LD_INT 2
98269: PUSH
98270: FOR_TO
98271: IFFALSE 98398
// begin uc_side := your_side ;
98273: LD_ADDR_OWVAR 20
98277: PUSH
98278: LD_OWVAR 2
98282: ST_TO_ADDR
// uc_nation := nation_american ;
98283: LD_ADDR_OWVAR 21
98287: PUSH
98288: LD_INT 1
98290: ST_TO_ADDR
// vc_chassis := us_morphling ;
98291: LD_ADDR_OWVAR 37
98295: PUSH
98296: LD_INT 5
98298: ST_TO_ADDR
// vc_engine := engine_siberite ;
98299: LD_ADDR_OWVAR 39
98303: PUSH
98304: LD_INT 3
98306: ST_TO_ADDR
// vc_control := control_computer ;
98307: LD_ADDR_OWVAR 38
98311: PUSH
98312: LD_INT 3
98314: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98315: LD_ADDR_OWVAR 40
98319: PUSH
98320: LD_INT 10
98322: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98323: LD_VAR 0 2
98327: PUSH
98328: LD_INT 1
98330: ARRAY
98331: PPUSH
98332: CALL_OW 310
98336: NOT
98337: IFFALSE 98384
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98339: CALL_OW 45
98343: PPUSH
98344: LD_VAR 0 2
98348: PUSH
98349: LD_INT 1
98351: ARRAY
98352: PPUSH
98353: CALL_OW 250
98357: PPUSH
98358: LD_VAR 0 2
98362: PUSH
98363: LD_INT 1
98365: ARRAY
98366: PPUSH
98367: CALL_OW 251
98371: PPUSH
98372: LD_INT 12
98374: PPUSH
98375: LD_INT 1
98377: PPUSH
98378: CALL_OW 50
98382: GO 98396
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98384: CALL_OW 45
98388: PPUSH
98389: LD_INT 1
98391: PPUSH
98392: CALL_OW 51
// end ;
98396: GO 98270
98398: POP
98399: POP
// end ;
98400: PPOPN 2
98402: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98403: LD_EXP 113
98407: PUSH
98408: LD_EXP 159
98412: AND
98413: IFFALSE 98635
98415: GO 98417
98417: DISABLE
98418: LD_INT 0
98420: PPUSH
98421: PPUSH
98422: PPUSH
98423: PPUSH
98424: PPUSH
98425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98426: LD_ADDR_VAR 0 6
98430: PUSH
98431: LD_INT 22
98433: PUSH
98434: LD_OWVAR 2
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: PUSH
98443: LD_INT 21
98445: PUSH
98446: LD_INT 1
98448: PUSH
98449: EMPTY
98450: LIST
98451: LIST
98452: PUSH
98453: LD_INT 3
98455: PUSH
98456: LD_INT 23
98458: PUSH
98459: LD_INT 0
98461: PUSH
98462: EMPTY
98463: LIST
98464: LIST
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: LIST
98474: PPUSH
98475: CALL_OW 69
98479: ST_TO_ADDR
// if not tmp then
98480: LD_VAR 0 6
98484: NOT
98485: IFFALSE 98489
// exit ;
98487: GO 98635
// s1 := rand ( 1 , 4 ) ;
98489: LD_ADDR_VAR 0 2
98493: PUSH
98494: LD_INT 1
98496: PPUSH
98497: LD_INT 4
98499: PPUSH
98500: CALL_OW 12
98504: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98505: LD_ADDR_VAR 0 4
98509: PUSH
98510: LD_VAR 0 6
98514: PUSH
98515: LD_INT 1
98517: ARRAY
98518: PPUSH
98519: LD_VAR 0 2
98523: PPUSH
98524: CALL_OW 259
98528: ST_TO_ADDR
// if s1 = 1 then
98529: LD_VAR 0 2
98533: PUSH
98534: LD_INT 1
98536: EQUAL
98537: IFFALSE 98557
// s2 := rand ( 2 , 4 ) else
98539: LD_ADDR_VAR 0 3
98543: PUSH
98544: LD_INT 2
98546: PPUSH
98547: LD_INT 4
98549: PPUSH
98550: CALL_OW 12
98554: ST_TO_ADDR
98555: GO 98565
// s2 := 1 ;
98557: LD_ADDR_VAR 0 3
98561: PUSH
98562: LD_INT 1
98564: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98565: LD_ADDR_VAR 0 5
98569: PUSH
98570: LD_VAR 0 6
98574: PUSH
98575: LD_INT 1
98577: ARRAY
98578: PPUSH
98579: LD_VAR 0 3
98583: PPUSH
98584: CALL_OW 259
98588: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98589: LD_VAR 0 6
98593: PUSH
98594: LD_INT 1
98596: ARRAY
98597: PPUSH
98598: LD_VAR 0 2
98602: PPUSH
98603: LD_VAR 0 5
98607: PPUSH
98608: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98612: LD_VAR 0 6
98616: PUSH
98617: LD_INT 1
98619: ARRAY
98620: PPUSH
98621: LD_VAR 0 3
98625: PPUSH
98626: LD_VAR 0 4
98630: PPUSH
98631: CALL_OW 237
// end ;
98635: PPOPN 6
98637: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98638: LD_EXP 113
98642: PUSH
98643: LD_EXP 160
98647: AND
98648: IFFALSE 98727
98650: GO 98652
98652: DISABLE
98653: LD_INT 0
98655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98656: LD_ADDR_VAR 0 1
98660: PUSH
98661: LD_INT 22
98663: PUSH
98664: LD_OWVAR 2
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: PUSH
98673: LD_INT 30
98675: PUSH
98676: LD_INT 3
98678: PUSH
98679: EMPTY
98680: LIST
98681: LIST
98682: PUSH
98683: EMPTY
98684: LIST
98685: LIST
98686: PPUSH
98687: CALL_OW 69
98691: ST_TO_ADDR
// if not tmp then
98692: LD_VAR 0 1
98696: NOT
98697: IFFALSE 98701
// exit ;
98699: GO 98727
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98701: LD_VAR 0 1
98705: PUSH
98706: LD_INT 1
98708: PPUSH
98709: LD_VAR 0 1
98713: PPUSH
98714: CALL_OW 12
98718: ARRAY
98719: PPUSH
98720: LD_INT 1
98722: PPUSH
98723: CALL_OW 234
// end ;
98727: PPOPN 1
98729: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98730: LD_EXP 113
98734: PUSH
98735: LD_EXP 161
98739: AND
98740: IFFALSE 98852
98742: GO 98744
98744: DISABLE
98745: LD_INT 0
98747: PPUSH
98748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98749: LD_ADDR_VAR 0 2
98753: PUSH
98754: LD_INT 22
98756: PUSH
98757: LD_OWVAR 2
98761: PUSH
98762: EMPTY
98763: LIST
98764: LIST
98765: PUSH
98766: LD_INT 2
98768: PUSH
98769: LD_INT 30
98771: PUSH
98772: LD_INT 27
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: PUSH
98779: LD_INT 30
98781: PUSH
98782: LD_INT 26
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: PUSH
98789: LD_INT 30
98791: PUSH
98792: LD_INT 28
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: PUSH
98805: EMPTY
98806: LIST
98807: LIST
98808: PPUSH
98809: CALL_OW 69
98813: ST_TO_ADDR
// if not tmp then
98814: LD_VAR 0 2
98818: NOT
98819: IFFALSE 98823
// exit ;
98821: GO 98852
// for i in tmp do
98823: LD_ADDR_VAR 0 1
98827: PUSH
98828: LD_VAR 0 2
98832: PUSH
98833: FOR_IN
98834: IFFALSE 98850
// SetLives ( i , 1 ) ;
98836: LD_VAR 0 1
98840: PPUSH
98841: LD_INT 1
98843: PPUSH
98844: CALL_OW 234
98848: GO 98833
98850: POP
98851: POP
// end ;
98852: PPOPN 2
98854: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98855: LD_EXP 113
98859: PUSH
98860: LD_EXP 162
98864: AND
98865: IFFALSE 99139
98867: GO 98869
98869: DISABLE
98870: LD_INT 0
98872: PPUSH
98873: PPUSH
98874: PPUSH
// begin i := rand ( 1 , 7 ) ;
98875: LD_ADDR_VAR 0 1
98879: PUSH
98880: LD_INT 1
98882: PPUSH
98883: LD_INT 7
98885: PPUSH
98886: CALL_OW 12
98890: ST_TO_ADDR
// case i of 1 :
98891: LD_VAR 0 1
98895: PUSH
98896: LD_INT 1
98898: DOUBLE
98899: EQUAL
98900: IFTRUE 98904
98902: GO 98914
98904: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98905: LD_STRING earthquake(getX(game), 0, 32)
98907: PPUSH
98908: CALL_OW 559
98912: GO 99139
98914: LD_INT 2
98916: DOUBLE
98917: EQUAL
98918: IFTRUE 98922
98920: GO 98936
98922: POP
// begin ToLua ( displayStucuk(); ) ;
98923: LD_STRING displayStucuk();
98925: PPUSH
98926: CALL_OW 559
// ResetFog ;
98930: CALL_OW 335
// end ; 3 :
98934: GO 99139
98936: LD_INT 3
98938: DOUBLE
98939: EQUAL
98940: IFTRUE 98944
98942: GO 99048
98944: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98945: LD_ADDR_VAR 0 2
98949: PUSH
98950: LD_INT 22
98952: PUSH
98953: LD_OWVAR 2
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 25
98964: PUSH
98965: LD_INT 1
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PPUSH
98976: CALL_OW 69
98980: ST_TO_ADDR
// if not tmp then
98981: LD_VAR 0 2
98985: NOT
98986: IFFALSE 98990
// exit ;
98988: GO 99139
// un := tmp [ rand ( 1 , tmp ) ] ;
98990: LD_ADDR_VAR 0 3
98994: PUSH
98995: LD_VAR 0 2
98999: PUSH
99000: LD_INT 1
99002: PPUSH
99003: LD_VAR 0 2
99007: PPUSH
99008: CALL_OW 12
99012: ARRAY
99013: ST_TO_ADDR
// if Crawls ( un ) then
99014: LD_VAR 0 3
99018: PPUSH
99019: CALL_OW 318
99023: IFFALSE 99034
// ComWalk ( un ) ;
99025: LD_VAR 0 3
99029: PPUSH
99030: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99034: LD_VAR 0 3
99038: PPUSH
99039: LD_INT 8
99041: PPUSH
99042: CALL_OW 336
// end ; 4 :
99046: GO 99139
99048: LD_INT 4
99050: DOUBLE
99051: EQUAL
99052: IFTRUE 99056
99054: GO 99117
99056: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99057: LD_ADDR_VAR 0 2
99061: PUSH
99062: LD_INT 22
99064: PUSH
99065: LD_OWVAR 2
99069: PUSH
99070: EMPTY
99071: LIST
99072: LIST
99073: PUSH
99074: LD_INT 30
99076: PUSH
99077: LD_INT 29
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PPUSH
99088: CALL_OW 69
99092: ST_TO_ADDR
// if not tmp then
99093: LD_VAR 0 2
99097: NOT
99098: IFFALSE 99102
// exit ;
99100: GO 99139
// DestroyUnit ( tmp [ 1 ] ) ;
99102: LD_VAR 0 2
99106: PUSH
99107: LD_INT 1
99109: ARRAY
99110: PPUSH
99111: CALL_OW 65
// end ; 5 .. 7 :
99115: GO 99139
99117: LD_INT 5
99119: DOUBLE
99120: GREATEREQUAL
99121: IFFALSE 99129
99123: LD_INT 7
99125: DOUBLE
99126: LESSEQUAL
99127: IFTRUE 99131
99129: GO 99138
99131: POP
// StreamSibBomb ; end ;
99132: CALL 95389 0 0
99136: GO 99139
99138: POP
// end ;
99139: PPOPN 3
99141: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99142: LD_EXP 113
99146: PUSH
99147: LD_EXP 163
99151: AND
99152: IFFALSE 99308
99154: GO 99156
99156: DISABLE
99157: LD_INT 0
99159: PPUSH
99160: PPUSH
99161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99162: LD_ADDR_VAR 0 2
99166: PUSH
99167: LD_INT 81
99169: PUSH
99170: LD_OWVAR 2
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 2
99181: PUSH
99182: LD_INT 21
99184: PUSH
99185: LD_INT 1
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: PUSH
99192: LD_INT 21
99194: PUSH
99195: LD_INT 2
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: PPUSH
99211: CALL_OW 69
99215: ST_TO_ADDR
// if not tmp then
99216: LD_VAR 0 2
99220: NOT
99221: IFFALSE 99225
// exit ;
99223: GO 99308
// p := 0 ;
99225: LD_ADDR_VAR 0 3
99229: PUSH
99230: LD_INT 0
99232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99233: LD_INT 35
99235: PPUSH
99236: CALL_OW 67
// p := p + 1 ;
99240: LD_ADDR_VAR 0 3
99244: PUSH
99245: LD_VAR 0 3
99249: PUSH
99250: LD_INT 1
99252: PLUS
99253: ST_TO_ADDR
// for i in tmp do
99254: LD_ADDR_VAR 0 1
99258: PUSH
99259: LD_VAR 0 2
99263: PUSH
99264: FOR_IN
99265: IFFALSE 99296
// if GetLives ( i ) < 1000 then
99267: LD_VAR 0 1
99271: PPUSH
99272: CALL_OW 256
99276: PUSH
99277: LD_INT 1000
99279: LESS
99280: IFFALSE 99294
// SetLives ( i , 1000 ) ;
99282: LD_VAR 0 1
99286: PPUSH
99287: LD_INT 1000
99289: PPUSH
99290: CALL_OW 234
99294: GO 99264
99296: POP
99297: POP
// until p > 20 ;
99298: LD_VAR 0 3
99302: PUSH
99303: LD_INT 20
99305: GREATER
99306: IFFALSE 99233
// end ;
99308: PPOPN 3
99310: END
// every 0 0$1 trigger StreamModeActive and sTime do
99311: LD_EXP 113
99315: PUSH
99316: LD_EXP 164
99320: AND
99321: IFFALSE 99356
99323: GO 99325
99325: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99326: LD_INT 28
99328: PPUSH
99329: LD_OWVAR 2
99333: PPUSH
99334: LD_INT 2
99336: PPUSH
99337: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99341: LD_INT 30
99343: PPUSH
99344: LD_OWVAR 2
99348: PPUSH
99349: LD_INT 2
99351: PPUSH
99352: CALL_OW 322
// end ;
99356: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99357: LD_EXP 113
99361: PUSH
99362: LD_EXP 165
99366: AND
99367: IFFALSE 99488
99369: GO 99371
99371: DISABLE
99372: LD_INT 0
99374: PPUSH
99375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99376: LD_ADDR_VAR 0 2
99380: PUSH
99381: LD_INT 22
99383: PUSH
99384: LD_OWVAR 2
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: PUSH
99393: LD_INT 21
99395: PUSH
99396: LD_INT 1
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: LD_INT 3
99405: PUSH
99406: LD_INT 23
99408: PUSH
99409: LD_INT 0
99411: PUSH
99412: EMPTY
99413: LIST
99414: LIST
99415: PUSH
99416: EMPTY
99417: LIST
99418: LIST
99419: PUSH
99420: EMPTY
99421: LIST
99422: LIST
99423: LIST
99424: PPUSH
99425: CALL_OW 69
99429: ST_TO_ADDR
// if not tmp then
99430: LD_VAR 0 2
99434: NOT
99435: IFFALSE 99439
// exit ;
99437: GO 99488
// for i in tmp do
99439: LD_ADDR_VAR 0 1
99443: PUSH
99444: LD_VAR 0 2
99448: PUSH
99449: FOR_IN
99450: IFFALSE 99486
// begin if Crawls ( i ) then
99452: LD_VAR 0 1
99456: PPUSH
99457: CALL_OW 318
99461: IFFALSE 99472
// ComWalk ( i ) ;
99463: LD_VAR 0 1
99467: PPUSH
99468: CALL_OW 138
// SetClass ( i , 2 ) ;
99472: LD_VAR 0 1
99476: PPUSH
99477: LD_INT 2
99479: PPUSH
99480: CALL_OW 336
// end ;
99484: GO 99449
99486: POP
99487: POP
// end ;
99488: PPOPN 2
99490: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99491: LD_EXP 113
99495: PUSH
99496: LD_EXP 166
99500: AND
99501: IFFALSE 99782
99503: GO 99505
99505: DISABLE
99506: LD_INT 0
99508: PPUSH
99509: PPUSH
99510: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99511: LD_OWVAR 2
99515: PPUSH
99516: LD_INT 9
99518: PPUSH
99519: LD_INT 1
99521: PPUSH
99522: LD_INT 1
99524: PPUSH
99525: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99529: LD_INT 9
99531: PPUSH
99532: LD_OWVAR 2
99536: PPUSH
99537: CALL_OW 343
// uc_side := 9 ;
99541: LD_ADDR_OWVAR 20
99545: PUSH
99546: LD_INT 9
99548: ST_TO_ADDR
// uc_nation := 2 ;
99549: LD_ADDR_OWVAR 21
99553: PUSH
99554: LD_INT 2
99556: ST_TO_ADDR
// hc_name := Dark Warrior ;
99557: LD_ADDR_OWVAR 26
99561: PUSH
99562: LD_STRING Dark Warrior
99564: ST_TO_ADDR
// hc_gallery :=  ;
99565: LD_ADDR_OWVAR 33
99569: PUSH
99570: LD_STRING 
99572: ST_TO_ADDR
// hc_noskilllimit := true ;
99573: LD_ADDR_OWVAR 76
99577: PUSH
99578: LD_INT 1
99580: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99581: LD_ADDR_OWVAR 31
99585: PUSH
99586: LD_INT 30
99588: PUSH
99589: LD_INT 30
99591: PUSH
99592: LD_INT 30
99594: PUSH
99595: LD_INT 30
99597: PUSH
99598: EMPTY
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: ST_TO_ADDR
// un := CreateHuman ;
99604: LD_ADDR_VAR 0 3
99608: PUSH
99609: CALL_OW 44
99613: ST_TO_ADDR
// hc_noskilllimit := false ;
99614: LD_ADDR_OWVAR 76
99618: PUSH
99619: LD_INT 0
99621: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99622: LD_VAR 0 3
99626: PPUSH
99627: LD_INT 1
99629: PPUSH
99630: CALL_OW 51
// p := 0 ;
99634: LD_ADDR_VAR 0 2
99638: PUSH
99639: LD_INT 0
99641: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99642: LD_INT 35
99644: PPUSH
99645: CALL_OW 67
// p := p + 1 ;
99649: LD_ADDR_VAR 0 2
99653: PUSH
99654: LD_VAR 0 2
99658: PUSH
99659: LD_INT 1
99661: PLUS
99662: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99663: LD_VAR 0 3
99667: PPUSH
99668: CALL_OW 256
99672: PUSH
99673: LD_INT 1000
99675: LESS
99676: IFFALSE 99690
// SetLives ( un , 1000 ) ;
99678: LD_VAR 0 3
99682: PPUSH
99683: LD_INT 1000
99685: PPUSH
99686: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99690: LD_VAR 0 3
99694: PPUSH
99695: LD_INT 81
99697: PUSH
99698: LD_OWVAR 2
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: PUSH
99707: LD_INT 91
99709: PUSH
99710: LD_VAR 0 3
99714: PUSH
99715: LD_INT 30
99717: PUSH
99718: EMPTY
99719: LIST
99720: LIST
99721: LIST
99722: PUSH
99723: EMPTY
99724: LIST
99725: LIST
99726: PPUSH
99727: CALL_OW 69
99731: PPUSH
99732: LD_VAR 0 3
99736: PPUSH
99737: CALL_OW 74
99741: PPUSH
99742: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99746: LD_VAR 0 2
99750: PUSH
99751: LD_INT 60
99753: GREATER
99754: PUSH
99755: LD_VAR 0 3
99759: PPUSH
99760: CALL_OW 301
99764: OR
99765: IFFALSE 99642
// if un then
99767: LD_VAR 0 3
99771: IFFALSE 99782
// RemoveUnit ( un ) ;
99773: LD_VAR 0 3
99777: PPUSH
99778: CALL_OW 64
// end ;
99782: PPOPN 3
99784: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99785: LD_INT 0
99787: PPUSH
// case cmd of 301 :
99788: LD_VAR 0 1
99792: PUSH
99793: LD_INT 301
99795: DOUBLE
99796: EQUAL
99797: IFTRUE 99801
99799: GO 99833
99801: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99802: LD_VAR 0 6
99806: PPUSH
99807: LD_VAR 0 7
99811: PPUSH
99812: LD_VAR 0 8
99816: PPUSH
99817: LD_VAR 0 4
99821: PPUSH
99822: LD_VAR 0 5
99826: PPUSH
99827: CALL 101034 0 5
99831: GO 99954
99833: LD_INT 302
99835: DOUBLE
99836: EQUAL
99837: IFTRUE 99841
99839: GO 99878
99841: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99842: LD_VAR 0 6
99846: PPUSH
99847: LD_VAR 0 7
99851: PPUSH
99852: LD_VAR 0 8
99856: PPUSH
99857: LD_VAR 0 9
99861: PPUSH
99862: LD_VAR 0 4
99866: PPUSH
99867: LD_VAR 0 5
99871: PPUSH
99872: CALL 101125 0 6
99876: GO 99954
99878: LD_INT 303
99880: DOUBLE
99881: EQUAL
99882: IFTRUE 99886
99884: GO 99923
99886: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99887: LD_VAR 0 6
99891: PPUSH
99892: LD_VAR 0 7
99896: PPUSH
99897: LD_VAR 0 8
99901: PPUSH
99902: LD_VAR 0 9
99906: PPUSH
99907: LD_VAR 0 4
99911: PPUSH
99912: LD_VAR 0 5
99916: PPUSH
99917: CALL 99959 0 6
99921: GO 99954
99923: LD_INT 304
99925: DOUBLE
99926: EQUAL
99927: IFTRUE 99931
99929: GO 99953
99931: POP
// hHackTeleport ( unit , x , y ) ; end ;
99932: LD_VAR 0 2
99936: PPUSH
99937: LD_VAR 0 4
99941: PPUSH
99942: LD_VAR 0 5
99946: PPUSH
99947: CALL 101718 0 3
99951: GO 99954
99953: POP
// end ;
99954: LD_VAR 0 12
99958: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99959: LD_INT 0
99961: PPUSH
99962: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99963: LD_VAR 0 1
99967: PUSH
99968: LD_INT 1
99970: LESS
99971: PUSH
99972: LD_VAR 0 1
99976: PUSH
99977: LD_INT 3
99979: GREATER
99980: OR
99981: PUSH
99982: LD_VAR 0 5
99986: PPUSH
99987: LD_VAR 0 6
99991: PPUSH
99992: CALL_OW 428
99996: OR
99997: IFFALSE 100001
// exit ;
99999: GO 100721
// uc_side := your_side ;
100001: LD_ADDR_OWVAR 20
100005: PUSH
100006: LD_OWVAR 2
100010: ST_TO_ADDR
// uc_nation := nation ;
100011: LD_ADDR_OWVAR 21
100015: PUSH
100016: LD_VAR 0 1
100020: ST_TO_ADDR
// bc_level = 1 ;
100021: LD_ADDR_OWVAR 43
100025: PUSH
100026: LD_INT 1
100028: ST_TO_ADDR
// case btype of 1 :
100029: LD_VAR 0 2
100033: PUSH
100034: LD_INT 1
100036: DOUBLE
100037: EQUAL
100038: IFTRUE 100042
100040: GO 100053
100042: POP
// bc_type := b_depot ; 2 :
100043: LD_ADDR_OWVAR 42
100047: PUSH
100048: LD_INT 0
100050: ST_TO_ADDR
100051: GO 100665
100053: LD_INT 2
100055: DOUBLE
100056: EQUAL
100057: IFTRUE 100061
100059: GO 100072
100061: POP
// bc_type := b_warehouse ; 3 :
100062: LD_ADDR_OWVAR 42
100066: PUSH
100067: LD_INT 1
100069: ST_TO_ADDR
100070: GO 100665
100072: LD_INT 3
100074: DOUBLE
100075: EQUAL
100076: IFTRUE 100080
100078: GO 100091
100080: POP
// bc_type := b_lab ; 4 .. 9 :
100081: LD_ADDR_OWVAR 42
100085: PUSH
100086: LD_INT 6
100088: ST_TO_ADDR
100089: GO 100665
100091: LD_INT 4
100093: DOUBLE
100094: GREATEREQUAL
100095: IFFALSE 100103
100097: LD_INT 9
100099: DOUBLE
100100: LESSEQUAL
100101: IFTRUE 100105
100103: GO 100157
100105: POP
// begin bc_type := b_lab_half ;
100106: LD_ADDR_OWVAR 42
100110: PUSH
100111: LD_INT 7
100113: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100114: LD_ADDR_OWVAR 44
100118: PUSH
100119: LD_INT 10
100121: PUSH
100122: LD_INT 11
100124: PUSH
100125: LD_INT 12
100127: PUSH
100128: LD_INT 15
100130: PUSH
100131: LD_INT 14
100133: PUSH
100134: LD_INT 13
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: LIST
100141: LIST
100142: LIST
100143: LIST
100144: PUSH
100145: LD_VAR 0 2
100149: PUSH
100150: LD_INT 3
100152: MINUS
100153: ARRAY
100154: ST_TO_ADDR
// end ; 10 .. 13 :
100155: GO 100665
100157: LD_INT 10
100159: DOUBLE
100160: GREATEREQUAL
100161: IFFALSE 100169
100163: LD_INT 13
100165: DOUBLE
100166: LESSEQUAL
100167: IFTRUE 100171
100169: GO 100248
100171: POP
// begin bc_type := b_lab_full ;
100172: LD_ADDR_OWVAR 42
100176: PUSH
100177: LD_INT 8
100179: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100180: LD_ADDR_OWVAR 44
100184: PUSH
100185: LD_INT 10
100187: PUSH
100188: LD_INT 12
100190: PUSH
100191: LD_INT 14
100193: PUSH
100194: LD_INT 13
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: LIST
100201: LIST
100202: PUSH
100203: LD_VAR 0 2
100207: PUSH
100208: LD_INT 9
100210: MINUS
100211: ARRAY
100212: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100213: LD_ADDR_OWVAR 45
100217: PUSH
100218: LD_INT 11
100220: PUSH
100221: LD_INT 15
100223: PUSH
100224: LD_INT 12
100226: PUSH
100227: LD_INT 15
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: LIST
100234: LIST
100235: PUSH
100236: LD_VAR 0 2
100240: PUSH
100241: LD_INT 9
100243: MINUS
100244: ARRAY
100245: ST_TO_ADDR
// end ; 14 :
100246: GO 100665
100248: LD_INT 14
100250: DOUBLE
100251: EQUAL
100252: IFTRUE 100256
100254: GO 100267
100256: POP
// bc_type := b_workshop ; 15 :
100257: LD_ADDR_OWVAR 42
100261: PUSH
100262: LD_INT 2
100264: ST_TO_ADDR
100265: GO 100665
100267: LD_INT 15
100269: DOUBLE
100270: EQUAL
100271: IFTRUE 100275
100273: GO 100286
100275: POP
// bc_type := b_factory ; 16 :
100276: LD_ADDR_OWVAR 42
100280: PUSH
100281: LD_INT 3
100283: ST_TO_ADDR
100284: GO 100665
100286: LD_INT 16
100288: DOUBLE
100289: EQUAL
100290: IFTRUE 100294
100292: GO 100305
100294: POP
// bc_type := b_ext_gun ; 17 :
100295: LD_ADDR_OWVAR 42
100299: PUSH
100300: LD_INT 17
100302: ST_TO_ADDR
100303: GO 100665
100305: LD_INT 17
100307: DOUBLE
100308: EQUAL
100309: IFTRUE 100313
100311: GO 100341
100313: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100314: LD_ADDR_OWVAR 42
100318: PUSH
100319: LD_INT 19
100321: PUSH
100322: LD_INT 23
100324: PUSH
100325: LD_INT 19
100327: PUSH
100328: EMPTY
100329: LIST
100330: LIST
100331: LIST
100332: PUSH
100333: LD_VAR 0 1
100337: ARRAY
100338: ST_TO_ADDR
100339: GO 100665
100341: LD_INT 18
100343: DOUBLE
100344: EQUAL
100345: IFTRUE 100349
100347: GO 100360
100349: POP
// bc_type := b_ext_radar ; 19 :
100350: LD_ADDR_OWVAR 42
100354: PUSH
100355: LD_INT 20
100357: ST_TO_ADDR
100358: GO 100665
100360: LD_INT 19
100362: DOUBLE
100363: EQUAL
100364: IFTRUE 100368
100366: GO 100379
100368: POP
// bc_type := b_ext_radio ; 20 :
100369: LD_ADDR_OWVAR 42
100373: PUSH
100374: LD_INT 22
100376: ST_TO_ADDR
100377: GO 100665
100379: LD_INT 20
100381: DOUBLE
100382: EQUAL
100383: IFTRUE 100387
100385: GO 100398
100387: POP
// bc_type := b_ext_siberium ; 21 :
100388: LD_ADDR_OWVAR 42
100392: PUSH
100393: LD_INT 21
100395: ST_TO_ADDR
100396: GO 100665
100398: LD_INT 21
100400: DOUBLE
100401: EQUAL
100402: IFTRUE 100406
100404: GO 100417
100406: POP
// bc_type := b_ext_computer ; 22 :
100407: LD_ADDR_OWVAR 42
100411: PUSH
100412: LD_INT 24
100414: ST_TO_ADDR
100415: GO 100665
100417: LD_INT 22
100419: DOUBLE
100420: EQUAL
100421: IFTRUE 100425
100423: GO 100436
100425: POP
// bc_type := b_ext_track ; 23 :
100426: LD_ADDR_OWVAR 42
100430: PUSH
100431: LD_INT 16
100433: ST_TO_ADDR
100434: GO 100665
100436: LD_INT 23
100438: DOUBLE
100439: EQUAL
100440: IFTRUE 100444
100442: GO 100455
100444: POP
// bc_type := b_ext_laser ; 24 :
100445: LD_ADDR_OWVAR 42
100449: PUSH
100450: LD_INT 25
100452: ST_TO_ADDR
100453: GO 100665
100455: LD_INT 24
100457: DOUBLE
100458: EQUAL
100459: IFTRUE 100463
100461: GO 100474
100463: POP
// bc_type := b_control_tower ; 25 :
100464: LD_ADDR_OWVAR 42
100468: PUSH
100469: LD_INT 36
100471: ST_TO_ADDR
100472: GO 100665
100474: LD_INT 25
100476: DOUBLE
100477: EQUAL
100478: IFTRUE 100482
100480: GO 100493
100482: POP
// bc_type := b_breastwork ; 26 :
100483: LD_ADDR_OWVAR 42
100487: PUSH
100488: LD_INT 31
100490: ST_TO_ADDR
100491: GO 100665
100493: LD_INT 26
100495: DOUBLE
100496: EQUAL
100497: IFTRUE 100501
100499: GO 100512
100501: POP
// bc_type := b_bunker ; 27 :
100502: LD_ADDR_OWVAR 42
100506: PUSH
100507: LD_INT 32
100509: ST_TO_ADDR
100510: GO 100665
100512: LD_INT 27
100514: DOUBLE
100515: EQUAL
100516: IFTRUE 100520
100518: GO 100531
100520: POP
// bc_type := b_turret ; 28 :
100521: LD_ADDR_OWVAR 42
100525: PUSH
100526: LD_INT 33
100528: ST_TO_ADDR
100529: GO 100665
100531: LD_INT 28
100533: DOUBLE
100534: EQUAL
100535: IFTRUE 100539
100537: GO 100550
100539: POP
// bc_type := b_armoury ; 29 :
100540: LD_ADDR_OWVAR 42
100544: PUSH
100545: LD_INT 4
100547: ST_TO_ADDR
100548: GO 100665
100550: LD_INT 29
100552: DOUBLE
100553: EQUAL
100554: IFTRUE 100558
100556: GO 100569
100558: POP
// bc_type := b_barracks ; 30 :
100559: LD_ADDR_OWVAR 42
100563: PUSH
100564: LD_INT 5
100566: ST_TO_ADDR
100567: GO 100665
100569: LD_INT 30
100571: DOUBLE
100572: EQUAL
100573: IFTRUE 100577
100575: GO 100588
100577: POP
// bc_type := b_solar_power ; 31 :
100578: LD_ADDR_OWVAR 42
100582: PUSH
100583: LD_INT 27
100585: ST_TO_ADDR
100586: GO 100665
100588: LD_INT 31
100590: DOUBLE
100591: EQUAL
100592: IFTRUE 100596
100594: GO 100607
100596: POP
// bc_type := b_oil_power ; 32 :
100597: LD_ADDR_OWVAR 42
100601: PUSH
100602: LD_INT 26
100604: ST_TO_ADDR
100605: GO 100665
100607: LD_INT 32
100609: DOUBLE
100610: EQUAL
100611: IFTRUE 100615
100613: GO 100626
100615: POP
// bc_type := b_siberite_power ; 33 :
100616: LD_ADDR_OWVAR 42
100620: PUSH
100621: LD_INT 28
100623: ST_TO_ADDR
100624: GO 100665
100626: LD_INT 33
100628: DOUBLE
100629: EQUAL
100630: IFTRUE 100634
100632: GO 100645
100634: POP
// bc_type := b_oil_mine ; 34 :
100635: LD_ADDR_OWVAR 42
100639: PUSH
100640: LD_INT 29
100642: ST_TO_ADDR
100643: GO 100665
100645: LD_INT 34
100647: DOUBLE
100648: EQUAL
100649: IFTRUE 100653
100651: GO 100664
100653: POP
// bc_type := b_siberite_mine ; end ;
100654: LD_ADDR_OWVAR 42
100658: PUSH
100659: LD_INT 30
100661: ST_TO_ADDR
100662: GO 100665
100664: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100665: LD_ADDR_VAR 0 8
100669: PUSH
100670: LD_VAR 0 5
100674: PPUSH
100675: LD_VAR 0 6
100679: PPUSH
100680: LD_VAR 0 3
100684: PPUSH
100685: CALL_OW 47
100689: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100690: LD_OWVAR 42
100694: PUSH
100695: LD_INT 32
100697: PUSH
100698: LD_INT 33
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: IN
100705: IFFALSE 100721
// PlaceWeaponTurret ( b , weapon ) ;
100707: LD_VAR 0 8
100711: PPUSH
100712: LD_VAR 0 4
100716: PPUSH
100717: CALL_OW 431
// end ;
100721: LD_VAR 0 7
100725: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100726: LD_INT 0
100728: PPUSH
100729: PPUSH
100730: PPUSH
100731: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100732: LD_ADDR_VAR 0 4
100736: PUSH
100737: LD_INT 22
100739: PUSH
100740: LD_OWVAR 2
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PUSH
100749: LD_INT 2
100751: PUSH
100752: LD_INT 30
100754: PUSH
100755: LD_INT 0
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 30
100764: PUSH
100765: LD_INT 1
100767: PUSH
100768: EMPTY
100769: LIST
100770: LIST
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: LIST
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: PPUSH
100781: CALL_OW 69
100785: ST_TO_ADDR
// if not tmp then
100786: LD_VAR 0 4
100790: NOT
100791: IFFALSE 100795
// exit ;
100793: GO 100854
// for i in tmp do
100795: LD_ADDR_VAR 0 2
100799: PUSH
100800: LD_VAR 0 4
100804: PUSH
100805: FOR_IN
100806: IFFALSE 100852
// for j = 1 to 3 do
100808: LD_ADDR_VAR 0 3
100812: PUSH
100813: DOUBLE
100814: LD_INT 1
100816: DEC
100817: ST_TO_ADDR
100818: LD_INT 3
100820: PUSH
100821: FOR_TO
100822: IFFALSE 100848
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100824: LD_VAR 0 2
100828: PPUSH
100829: CALL_OW 274
100833: PPUSH
100834: LD_VAR 0 3
100838: PPUSH
100839: LD_INT 99999
100841: PPUSH
100842: CALL_OW 277
100846: GO 100821
100848: POP
100849: POP
100850: GO 100805
100852: POP
100853: POP
// end ;
100854: LD_VAR 0 1
100858: RET
// export function hHackSetLevel10 ; var i , j ; begin
100859: LD_INT 0
100861: PPUSH
100862: PPUSH
100863: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100864: LD_ADDR_VAR 0 2
100868: PUSH
100869: LD_INT 21
100871: PUSH
100872: LD_INT 1
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PPUSH
100879: CALL_OW 69
100883: PUSH
100884: FOR_IN
100885: IFFALSE 100937
// if IsSelected ( i ) then
100887: LD_VAR 0 2
100891: PPUSH
100892: CALL_OW 306
100896: IFFALSE 100935
// begin for j := 1 to 4 do
100898: LD_ADDR_VAR 0 3
100902: PUSH
100903: DOUBLE
100904: LD_INT 1
100906: DEC
100907: ST_TO_ADDR
100908: LD_INT 4
100910: PUSH
100911: FOR_TO
100912: IFFALSE 100933
// SetSkill ( i , j , 10 ) ;
100914: LD_VAR 0 2
100918: PPUSH
100919: LD_VAR 0 3
100923: PPUSH
100924: LD_INT 10
100926: PPUSH
100927: CALL_OW 237
100931: GO 100911
100933: POP
100934: POP
// end ;
100935: GO 100884
100937: POP
100938: POP
// end ;
100939: LD_VAR 0 1
100943: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100944: LD_INT 0
100946: PPUSH
100947: PPUSH
100948: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100949: LD_ADDR_VAR 0 2
100953: PUSH
100954: LD_INT 22
100956: PUSH
100957: LD_OWVAR 2
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PUSH
100966: LD_INT 21
100968: PUSH
100969: LD_INT 1
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: PUSH
100976: EMPTY
100977: LIST
100978: LIST
100979: PPUSH
100980: CALL_OW 69
100984: PUSH
100985: FOR_IN
100986: IFFALSE 101027
// begin for j := 1 to 4 do
100988: LD_ADDR_VAR 0 3
100992: PUSH
100993: DOUBLE
100994: LD_INT 1
100996: DEC
100997: ST_TO_ADDR
100998: LD_INT 4
101000: PUSH
101001: FOR_TO
101002: IFFALSE 101023
// SetSkill ( i , j , 10 ) ;
101004: LD_VAR 0 2
101008: PPUSH
101009: LD_VAR 0 3
101013: PPUSH
101014: LD_INT 10
101016: PPUSH
101017: CALL_OW 237
101021: GO 101001
101023: POP
101024: POP
// end ;
101025: GO 100985
101027: POP
101028: POP
// end ;
101029: LD_VAR 0 1
101033: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101034: LD_INT 0
101036: PPUSH
// uc_side := your_side ;
101037: LD_ADDR_OWVAR 20
101041: PUSH
101042: LD_OWVAR 2
101046: ST_TO_ADDR
// uc_nation := nation ;
101047: LD_ADDR_OWVAR 21
101051: PUSH
101052: LD_VAR 0 1
101056: ST_TO_ADDR
// InitHc ;
101057: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101061: LD_INT 0
101063: PPUSH
101064: LD_VAR 0 2
101068: PPUSH
101069: LD_VAR 0 3
101073: PPUSH
101074: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101078: LD_VAR 0 4
101082: PPUSH
101083: LD_VAR 0 5
101087: PPUSH
101088: CALL_OW 428
101092: PUSH
101093: LD_INT 0
101095: EQUAL
101096: IFFALSE 101120
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101098: CALL_OW 44
101102: PPUSH
101103: LD_VAR 0 4
101107: PPUSH
101108: LD_VAR 0 5
101112: PPUSH
101113: LD_INT 1
101115: PPUSH
101116: CALL_OW 48
// end ;
101120: LD_VAR 0 6
101124: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101125: LD_INT 0
101127: PPUSH
101128: PPUSH
// uc_side := your_side ;
101129: LD_ADDR_OWVAR 20
101133: PUSH
101134: LD_OWVAR 2
101138: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101139: LD_VAR 0 1
101143: PUSH
101144: LD_INT 1
101146: PUSH
101147: LD_INT 2
101149: PUSH
101150: LD_INT 3
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: LD_INT 5
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: IN
101166: IFFALSE 101178
// uc_nation := nation_american else
101168: LD_ADDR_OWVAR 21
101172: PUSH
101173: LD_INT 1
101175: ST_TO_ADDR
101176: GO 101221
// if chassis in [ 11 , 12 , 13 , 14 ] then
101178: LD_VAR 0 1
101182: PUSH
101183: LD_INT 11
101185: PUSH
101186: LD_INT 12
101188: PUSH
101189: LD_INT 13
101191: PUSH
101192: LD_INT 14
101194: PUSH
101195: EMPTY
101196: LIST
101197: LIST
101198: LIST
101199: LIST
101200: IN
101201: IFFALSE 101213
// uc_nation := nation_arabian else
101203: LD_ADDR_OWVAR 21
101207: PUSH
101208: LD_INT 2
101210: ST_TO_ADDR
101211: GO 101221
// uc_nation := nation_russian ;
101213: LD_ADDR_OWVAR 21
101217: PUSH
101218: LD_INT 3
101220: ST_TO_ADDR
// vc_chassis := chassis ;
101221: LD_ADDR_OWVAR 37
101225: PUSH
101226: LD_VAR 0 1
101230: ST_TO_ADDR
// vc_engine := engine ;
101231: LD_ADDR_OWVAR 39
101235: PUSH
101236: LD_VAR 0 2
101240: ST_TO_ADDR
// vc_control := control ;
101241: LD_ADDR_OWVAR 38
101245: PUSH
101246: LD_VAR 0 3
101250: ST_TO_ADDR
// vc_weapon := weapon ;
101251: LD_ADDR_OWVAR 40
101255: PUSH
101256: LD_VAR 0 4
101260: ST_TO_ADDR
// un := CreateVehicle ;
101261: LD_ADDR_VAR 0 8
101265: PUSH
101266: CALL_OW 45
101270: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101271: LD_VAR 0 8
101275: PPUSH
101276: LD_INT 0
101278: PPUSH
101279: LD_INT 5
101281: PPUSH
101282: CALL_OW 12
101286: PPUSH
101287: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101291: LD_VAR 0 8
101295: PPUSH
101296: LD_VAR 0 5
101300: PPUSH
101301: LD_VAR 0 6
101305: PPUSH
101306: LD_INT 1
101308: PPUSH
101309: CALL_OW 48
// end ;
101313: LD_VAR 0 7
101317: RET
// export hInvincible ; every 1 do
101318: GO 101320
101320: DISABLE
// hInvincible := [ ] ;
101321: LD_ADDR_EXP 167
101325: PUSH
101326: EMPTY
101327: ST_TO_ADDR
101328: END
// every 10 do var i ;
101329: GO 101331
101331: DISABLE
101332: LD_INT 0
101334: PPUSH
// begin enable ;
101335: ENABLE
// if not hInvincible then
101336: LD_EXP 167
101340: NOT
101341: IFFALSE 101345
// exit ;
101343: GO 101389
// for i in hInvincible do
101345: LD_ADDR_VAR 0 1
101349: PUSH
101350: LD_EXP 167
101354: PUSH
101355: FOR_IN
101356: IFFALSE 101387
// if GetLives ( i ) < 1000 then
101358: LD_VAR 0 1
101362: PPUSH
101363: CALL_OW 256
101367: PUSH
101368: LD_INT 1000
101370: LESS
101371: IFFALSE 101385
// SetLives ( i , 1000 ) ;
101373: LD_VAR 0 1
101377: PPUSH
101378: LD_INT 1000
101380: PPUSH
101381: CALL_OW 234
101385: GO 101355
101387: POP
101388: POP
// end ;
101389: PPOPN 1
101391: END
// export function hHackInvincible ; var i ; begin
101392: LD_INT 0
101394: PPUSH
101395: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101396: LD_ADDR_VAR 0 2
101400: PUSH
101401: LD_INT 2
101403: PUSH
101404: LD_INT 21
101406: PUSH
101407: LD_INT 1
101409: PUSH
101410: EMPTY
101411: LIST
101412: LIST
101413: PUSH
101414: LD_INT 21
101416: PUSH
101417: LD_INT 2
101419: PUSH
101420: EMPTY
101421: LIST
101422: LIST
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: LIST
101428: PPUSH
101429: CALL_OW 69
101433: PUSH
101434: FOR_IN
101435: IFFALSE 101496
// if IsSelected ( i ) then
101437: LD_VAR 0 2
101441: PPUSH
101442: CALL_OW 306
101446: IFFALSE 101494
// begin if i in hInvincible then
101448: LD_VAR 0 2
101452: PUSH
101453: LD_EXP 167
101457: IN
101458: IFFALSE 101478
// hInvincible := hInvincible diff i else
101460: LD_ADDR_EXP 167
101464: PUSH
101465: LD_EXP 167
101469: PUSH
101470: LD_VAR 0 2
101474: DIFF
101475: ST_TO_ADDR
101476: GO 101494
// hInvincible := hInvincible union i ;
101478: LD_ADDR_EXP 167
101482: PUSH
101483: LD_EXP 167
101487: PUSH
101488: LD_VAR 0 2
101492: UNION
101493: ST_TO_ADDR
// end ;
101494: GO 101434
101496: POP
101497: POP
// end ;
101498: LD_VAR 0 1
101502: RET
// export function hHackInvisible ; var i , j ; begin
101503: LD_INT 0
101505: PPUSH
101506: PPUSH
101507: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101508: LD_ADDR_VAR 0 2
101512: PUSH
101513: LD_INT 21
101515: PUSH
101516: LD_INT 1
101518: PUSH
101519: EMPTY
101520: LIST
101521: LIST
101522: PPUSH
101523: CALL_OW 69
101527: PUSH
101528: FOR_IN
101529: IFFALSE 101553
// if IsSelected ( i ) then
101531: LD_VAR 0 2
101535: PPUSH
101536: CALL_OW 306
101540: IFFALSE 101551
// ComForceInvisible ( i ) ;
101542: LD_VAR 0 2
101546: PPUSH
101547: CALL_OW 496
101551: GO 101528
101553: POP
101554: POP
// end ;
101555: LD_VAR 0 1
101559: RET
// export function hHackChangeYourSide ; begin
101560: LD_INT 0
101562: PPUSH
// if your_side = 8 then
101563: LD_OWVAR 2
101567: PUSH
101568: LD_INT 8
101570: EQUAL
101571: IFFALSE 101583
// your_side := 0 else
101573: LD_ADDR_OWVAR 2
101577: PUSH
101578: LD_INT 0
101580: ST_TO_ADDR
101581: GO 101597
// your_side := your_side + 1 ;
101583: LD_ADDR_OWVAR 2
101587: PUSH
101588: LD_OWVAR 2
101592: PUSH
101593: LD_INT 1
101595: PLUS
101596: ST_TO_ADDR
// end ;
101597: LD_VAR 0 1
101601: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101602: LD_INT 0
101604: PPUSH
101605: PPUSH
101606: PPUSH
// for i in all_units do
101607: LD_ADDR_VAR 0 2
101611: PUSH
101612: LD_OWVAR 3
101616: PUSH
101617: FOR_IN
101618: IFFALSE 101696
// if IsSelected ( i ) then
101620: LD_VAR 0 2
101624: PPUSH
101625: CALL_OW 306
101629: IFFALSE 101694
// begin j := GetSide ( i ) ;
101631: LD_ADDR_VAR 0 3
101635: PUSH
101636: LD_VAR 0 2
101640: PPUSH
101641: CALL_OW 255
101645: ST_TO_ADDR
// if j = 8 then
101646: LD_VAR 0 3
101650: PUSH
101651: LD_INT 8
101653: EQUAL
101654: IFFALSE 101666
// j := 0 else
101656: LD_ADDR_VAR 0 3
101660: PUSH
101661: LD_INT 0
101663: ST_TO_ADDR
101664: GO 101680
// j := j + 1 ;
101666: LD_ADDR_VAR 0 3
101670: PUSH
101671: LD_VAR 0 3
101675: PUSH
101676: LD_INT 1
101678: PLUS
101679: ST_TO_ADDR
// SetSide ( i , j ) ;
101680: LD_VAR 0 2
101684: PPUSH
101685: LD_VAR 0 3
101689: PPUSH
101690: CALL_OW 235
// end ;
101694: GO 101617
101696: POP
101697: POP
// end ;
101698: LD_VAR 0 1
101702: RET
// export function hHackFog ; begin
101703: LD_INT 0
101705: PPUSH
// FogOff ( true ) ;
101706: LD_INT 1
101708: PPUSH
101709: CALL_OW 344
// end ;
101713: LD_VAR 0 1
101717: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101718: LD_INT 0
101720: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101721: LD_VAR 0 1
101725: PPUSH
101726: LD_VAR 0 2
101730: PPUSH
101731: LD_VAR 0 3
101735: PPUSH
101736: LD_INT 1
101738: PPUSH
101739: LD_INT 1
101741: PPUSH
101742: CALL_OW 483
// CenterOnXY ( x , y ) ;
101746: LD_VAR 0 2
101750: PPUSH
101751: LD_VAR 0 3
101755: PPUSH
101756: CALL_OW 84
// end ;
101760: LD_VAR 0 4
101764: RET
