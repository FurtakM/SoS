// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 350 0 0
// InitMultiplayer ;
  20: CALL 611 0 0
// InitMacro ;
  24: CALL 47507 0 0
// if debug then
  28: LD_EXP 1
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: CALL 42799 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: CALL 1893 0 1
  79: PPUSH
  80: CALL 5848 0 1
// Multiplayer_Start ;
  84: CALL 3757 0 0
// MC_Start ( ) ;
  88: CALL 49619 0 0
// Multiplayer_End ;
  92: CALL 3881 0 0
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: CALL 70889 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: LD_OWVAR 67
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: CALL 70889 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_OWVAR 67
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: CALL 70889 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: CALL 70889 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: LD_OWVAR 67
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: CALL 70889 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: LD_ADDR_EXP 67
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: LD_ADDR_EXP 68
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_EXP 38
 330: PUSH
 331: LD_VAR 0 2
 335: ARRAY
 336: PPUSH
 337: CALL 71315 0 2
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: LD_ADDR_EXP 1
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: LD_ADDR_EXP 4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: LD_ADDR_EXP 5
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: LD_EXP 2
 489: PUSH
 490: LD_OWVAR 48
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: CALL 4582 0 0
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: LD_EXP 1
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: LD_ADDR_VAR 0 2
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: CALL_OW 44
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: LD_ADDR_EXP 18
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: LD_OWVAR 4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: LD_OWVAR 7
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: LD_ADDR_EXP 6
 646: PUSH
 647: LD_OWVAR 6
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: LD_ADDR_EXP 7
 656: PUSH
 657: LD_OWVAR 17
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: LD_ADDR_EXP 8
 666: PUSH
 667: LD_OWVAR 15
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: LD_ADDR_EXP 9
 676: PUSH
 677: LD_OWVAR 16
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: LD_ADDR_EXP 10
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: LD_OWVAR 12
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: LD_ADDR_EXP 10
 706: PUSH
 707: LD_EXP 10
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: LD_EXP 10
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: CALL 14797 0 3
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: LD_ADDR_VAR 0 2
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_EXP 18
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: LD_ADDR_EXP 17
 772: PUSH
 773: LD_EXP 17
 777: PPUSH
 778: LD_EXP 17
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 426
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: CALL_OW 2
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: LD_ADDR_EXP 6
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: LD_ADDR_EXP 7
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: LD_ADDR_EXP 8
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: LD_ADDR_EXP 10
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: LD_ADDR_EXP 17
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: LD_ADDR_EXP 11
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: LD_ADDR_EXP 25
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: LD_ADDR_EXP 15
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: LD_ADDR_EXP 13
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: LD_ADDR_EXP 16
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: LD_ADDR_EXP 24
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: LD_ADDR_EXP 27
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: LD_ADDR_EXP 26
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: LD_ADDR_EXP 12
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: LD_VAR 0 2
1232: PPUSH
1233: CALL_OW 530
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: LD_ADDR_EXP 11
1243: PUSH
1244: LD_EXP 11
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: CALL_OW 1
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: LD_ADDR_EXP 9
1266: PUSH
1267: LD_EXP 9
1271: PPUSH
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 1
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_EXP 7
1294: PPUSH
1295: LD_VAR 0 2
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: CALL_OW 1
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_EXP 10
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: LD_VAR 0 2
1330: PUSH
1331: LD_EXP 10
1335: PUSH
1336: LD_VAR 0 3
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: LD_ADDR_VAR 0 5
1348: PUSH
1349: LD_EXP 10
1353: PUSH
1354: LD_VAR 0 3
1358: ARRAY
1359: PUSH
1360: LD_VAR 0 2
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: LD_ADDR_EXP 10
1370: PUSH
1371: LD_EXP 10
1375: PPUSH
1376: LD_VAR 0 3
1380: PPUSH
1381: LD_VAR 0 5
1385: PPUSH
1386: CALL_OW 1
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: LD_EXP 9
1399: PUSH
1400: LD_VAR 0 2
1404: ARRAY
1405: PUSH
1406: LD_EXP 9
1410: PUSH
1411: LD_VAR 0 2
1415: ARRAY
1416: PUSH
1417: LD_EXP 13
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: LD_ADDR_EXP 9
1430: PUSH
1431: LD_EXP 9
1435: PPUSH
1436: LD_VAR 0 2
1440: PPUSH
1441: LD_EXP 13
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: LD_EXP 13
1453: PPUSH
1454: CALL_OW 12
1458: ARRAY
1459: PPUSH
1460: CALL_OW 1
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: LD_EXP 9
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: PUSH
1477: LD_EXP 7
1481: PUSH
1482: LD_VAR 0 2
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: LD_EXP 11
1494: PUSH
1495: LD_VAR 0 2
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: LD_ADDR_EXP 14
1508: PUSH
1509: LD_EXP 14
1513: PPUSH
1514: LD_VAR 0 2
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: CALL_OW 1
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: LD_EXP 7
1531: PUSH
1532: LD_VAR 0 2
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: LD_ADDR_EXP 26
1543: PUSH
1544: LD_EXP 26
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_EXP 10
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: LD_VAR 0 2
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 3
1597: ARRAY
1598: PPUSH
1599: LD_VAR 0 2
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: CALL_OW 343
// for x = 1 to j - 1 do
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: LD_VAR 0 3
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: LD_VAR 0 2
1638: PUSH
1639: LD_VAR 0 3
1643: ARRAY
1644: PPUSH
1645: LD_VAR 0 2
1649: PUSH
1650: LD_VAR 0 4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 80
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_EXP 17
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: LD_ADDR_EXP 20
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: LD_ADDR_EXP 21
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: LD_ADDR_EXP 22
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_EXP 17
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: LD_ADDR_EXP 23
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: LD_EXP 17
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: LD_VAR 0 1
1901: PUSH
1902: LD_EXP 7
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: LD_ADDR_VAR 0 2
1914: PUSH
1915: LD_VAR 0 1
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: LD_ADDR_VAR 0 3
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: LD_EXP 7
1942: PUSH
1943: LD_VAR 0 3
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: LD_VAR 0 3
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_VAR 0 1
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: LD_ADDR_VAR 0 3
2095: PUSH
2096: CALL_OW 44
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: LD_VAR 0 2
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: CALL_OW 44
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: LD_VAR 0 2
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: CALL_OW 44
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: LD_EXP 7
2317: PUSH
2318: LD_VAR 0 2
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: LD_EXP 16
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 2
2343: PPUSH
2344: LD_EXP 7
2348: PUSH
2349: LD_VAR 0 2
2353: ARRAY
2354: PPUSH
2355: CALL 1974 0 2
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: LD_ADDR_EXP 24
2364: PUSH
2365: LD_EXP 24
2369: PPUSH
2370: LD_EXP 24
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: CALL_OW 2
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: LD_VAR 0 5
2393: PPUSH
2394: LD_EXP 12
2398: PUSH
2399: LD_EXP 7
2403: PUSH
2404: LD_VAR 0 2
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 49
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_VAR 0 2
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: LD_EXP 9
2443: PUSH
2444: LD_VAR 0 2
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: LD_EXP 20
2468: PPUSH
2469: CALL_OW 380
// if multiplayer then
2473: LD_OWVAR 4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: LD_OWVAR 19
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: LD_VAR 0 2
2512: PPUSH
2513: CALL_OW 525
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: LD_VAR 0 2
2527: PPUSH
2528: CALL_OW 526
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: CALL_OW 12
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: LD_VAR 0 5
2581: PPUSH
2582: LD_EXP 12
2586: PUSH
2587: LD_EXP 7
2591: PUSH
2592: LD_VAR 0 2
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: LD_ADDR_EXP 24
2614: PUSH
2615: LD_EXP 24
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: LD_VAR 0 5
2629: PPUSH
2630: CALL_OW 1
2634: ST_TO_ADDR
// end ; InitHc ;
2635: CALL_OW 19
// InitUc ;
2639: CALL_OW 18
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: LD_EXP 9
2662: PUSH
2663: LD_VAR 0 2
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: LD_ADDR_VAR 0 3
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: LD_EXP 19
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: LD_EXP 19
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_EXP 20
2773: PPUSH
2774: CALL_OW 380
// un := CreateHuman ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: CALL_OW 44
2787: ST_TO_ADDR
// if j > copy then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_VAR 0 8
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: LD_ADDR_VAR 0 8
2804: PUSH
2805: LD_VAR 0 8
2809: PPUSH
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 1
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: LD_VAR 0 8
2831: PUSH
2832: LD_VAR 0 3
2836: ARRAY
2837: PPUSH
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: LD_VAR 0 5
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: LD_VAR 0 8
2859: PUSH
2860: LD_VAR 0 3
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: CALL_OW 260
2873: PPUSH
2874: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: LD_VAR 0 5
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 8
2890: PUSH
2891: LD_VAR 0 3
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: CALL_OW 260
2904: PPUSH
2905: CALL_OW 239
// end ; if multi_pos_area then
2909: LD_EXP 12
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: LD_VAR 0 5
2919: PPUSH
2920: CALL_OW 257
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_VAR 0 3
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_VAR 0 3
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: CALL 14675 0 5
// veh := CreateVehicle ;
2995: LD_ADDR_VAR 0 6
2999: PUSH
3000: CALL_OW 45
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_EXP 12
3014: PUSH
3015: LD_EXP 7
3019: PUSH
3020: LD_VAR 0 2
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3038: LD_VAR 0 5
3042: PPUSH
3043: LD_VAR 0 6
3047: PPUSH
3048: CALL_OW 52
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_EXP 12
3063: PUSH
3064: LD_EXP 7
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 49
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: LD_ADDR_VAR 0 3
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: CALL_OW 12
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_VAR 0 3
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: CALL 14675 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: CALL_OW 45
3166: PPUSH
3167: LD_EXP 12
3171: PUSH
3172: LD_EXP 7
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: CALL_OW 49
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: LD_EXP 23
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: LD_ADDR_VAR 0 1
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: LD_EXP 7
3251: PUSH
3252: LD_VAR 0 2
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: LD_ADDR_VAR 0 5
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: LD_EXP 23
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: LD_VAR 0 2
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: LD_EXP 9
3295: PUSH
3296: LD_VAR 0 2
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3321: LD_ADDR_VAR 0 5
3325: PUSH
3326: LD_VAR 0 5
3330: PUSH
3331: CALL_OW 45
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: LD_VAR 0 5
3365: PUSH
3366: CALL_OW 45
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: LD_VAR 0 5
3400: PUSH
3401: CALL_OW 45
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_VAR 0 5
3435: PUSH
3436: CALL_OW 45
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: LD_EXP 23
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: LD_VAR 0 2
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: LD_EXP 9
3471: PUSH
3472: LD_VAR 0 2
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3497: LD_ADDR_VAR 0 5
3501: PUSH
3502: LD_VAR 0 5
3506: PUSH
3507: CALL_OW 45
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3532: LD_ADDR_VAR 0 5
3536: PUSH
3537: LD_VAR 0 5
3541: PUSH
3542: CALL_OW 45
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3567: LD_ADDR_VAR 0 5
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: CALL_OW 45
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_VAR 0 5
3611: PUSH
3612: CALL_OW 45
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3637: LD_ADDR_VAR 0 5
3641: PUSH
3642: LD_VAR 0 5
3646: PUSH
3647: CALL_OW 45
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: CALL_OW 45
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3707: LD_ADDR_VAR 0 5
3711: PUSH
3712: LD_VAR 0 5
3716: PUSH
3717: CALL_OW 45
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: LD_ADDR_VAR 0 1
3727: PUSH
3728: LD_VAR 0 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_VAR 0 5
3742: PPUSH
3743: CALL_OW 2
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: CALL 2286 0 0
// Multiplayer_InitPointSystem ( ) ;
3764: CALL 4681 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: CALL 4857 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: CALL 4857 0 1
// Multiplayer_SpawnArtifact ;
3811: CALL 5297 0 0
// if multi_support then
3815: LD_EXP 23
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: LD_ADDR_EXP 27
3825: PUSH
3826: CALL 3208 0 0
3830: ST_TO_ADDR
// game := true ;
3831: LD_ADDR_EXP 2
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: LD_EXP 7
3843: PUSH
3844: LD_OWVAR 2
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: LD_OWVAR 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: CALL_OW 69
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: CALL_OW 87
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: LD_ADDR_VAR 0 5
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: LD_OWVAR 1
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: LD_EXP 28
3916: NOT
3917: AND
3918: PUSH
3919: LD_EXP 23
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: LD_ADDR_EXP 28
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: LD_ADDR_VAR 0 2
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: LD_EXP 7
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PUSH
3965: LD_EXP 25
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: LD_EXP 27
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: LD_EXP 27
4000: PUSH
4001: LD_VAR 0 2
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: LD_ADDR_VAR 0 3
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 3
4032: ARRAY
4033: PPUSH
4034: LD_EXP 12
4038: PUSH
4039: LD_EXP 7
4043: PUSH
4044: LD_VAR 0 2
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 3
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: LD_ADDR_EXP 27
4088: PUSH
4089: LD_EXP 27
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 1
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: LD_OWVAR 1
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: LD_OWVAR 1
4136: LESS
4137: PUSH
4138: LD_EXP 28
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: LD_EXP 23
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: LD_ADDR_EXP 28
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: LD_ADDR_VAR 0 2
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: LD_EXP 7
4187: PUSH
4188: LD_VAR 0 2
4192: ARRAY
4193: PUSH
4194: LD_EXP 25
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: LD_EXP 27
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_EXP 27
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: LD_ADDR_VAR 0 3
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: LD_VAR 0 4
4256: PUSH
4257: LD_VAR 0 3
4261: ARRAY
4262: PPUSH
4263: LD_EXP 12
4267: PUSH
4268: LD_EXP 7
4272: PUSH
4273: LD_VAR 0 2
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: CALL_OW 3
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: LD_ADDR_EXP 27
4317: PUSH
4318: LD_EXP 27
4322: PPUSH
4323: LD_VAR 0 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PPUSH
4333: CALL_OW 1
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: LD_EXP 16
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: LD_ADDR_VAR 0 2
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 69
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_VAR 0 2
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: LD_ADDR_EXP 25
4404: PUSH
4405: LD_EXP 25
4409: PPUSH
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: CALL_OW 1
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: CALL 4927 0 1
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: LD_EXP 25
4440: PPUSH
4441: CALL 11949 0 1
4445: PUSH
4446: LD_EXP 7
4450: PPUSH
4451: CALL 11949 0 1
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: LD_EXP 3
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: LD_EXP 2
4485: AND
4486: PUSH
4487: LD_EXP 24
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: LD_ADDR_EXP 2
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: LD_ADDR_VAR 0 2
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: LD_EXP 7
4523: PUSH
4524: LD_VAR 0 2
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_EXP 29
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: CALL_OW 506
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: LD_EXP 25
4559: PUSH
4560: LD_OWVAR 2
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: CALL_OW 107
4571: GO 4577
// YouWinInMultiplayer ;
4573: CALL_OW 106
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: LD_ADDR_VAR 0 1
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: LD_OWVAR 1
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: LD_EXP 7
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: LD_ADDR_VAR 0 1
4635: PUSH
4636: LD_VAR 0 1
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_VAR 0 2
4653: PUSH
4654: LD_EXP 29
4658: PUSH
4659: LD_VAR 0 2
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: LD_ADDR_EXP 29
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: LD_ADDR_EXP 30
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: LD_EXP 29
4743: NOT
4744: PUSH
4745: LD_VAR 0 1
4749: NOT
4750: OR
4751: PUSH
4752: LD_VAR 0 1
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: LD_ADDR_EXP 29
4769: PUSH
4770: LD_EXP 29
4774: PPUSH
4775: LD_VAR 0 1
4779: PPUSH
4780: LD_EXP 29
4784: PUSH
4785: LD_VAR 0 1
4789: ARRAY
4790: PUSH
4791: LD_VAR 0 2
4795: PLUS
4796: PPUSH
4797: CALL_OW 1
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: LD_EXP 29
4814: NOT
4815: PUSH
4816: LD_VAR 0 1
4820: NOT
4821: OR
4822: PUSH
4823: LD_VAR 0 1
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: LD_EXP 29
4845: PUSH
4846: LD_VAR 0 1
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: LD_ADDR_EXP 30
4864: PUSH
4865: LD_EXP 30
4869: PPUSH
4870: LD_EXP 30
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: LD_VAR 0 1
4883: PPUSH
4884: CALL_OW 2
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: LD_VAR 0 1
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: LD_EXP 30
4915: PUSH
4916: LD_VAR 0 1
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: LD_ADDR_VAR 0 3
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: LD_ADDR_VAR 0 4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: LD_VAR 0 4
4961: PUSH
4962: LD_VAR 0 1
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: LD_EXP 7
4975: PUSH
4976: LD_VAR 0 4
4980: ARRAY
4981: PUSH
4982: LD_EXP 25
4986: PUSH
4987: LD_VAR 0 4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_VAR 0 4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: LD_VAR 0 3
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: LD_ADDR_VAR 0 4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_VAR 0 1
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL_OW 69
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: LD_VAR 0 4
5074: PPUSH
5075: LD_VAR 0 3
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: CALL_OW 235
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: LD_ADDR_VAR 0 5
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: LD_VAR 0 1
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: LD_VAR 0 4
5173: PPUSH
5174: LD_VAR 0 3
5178: PUSH
5179: LD_VAR 0 5
5183: ARRAY
5184: PPUSH
5185: CALL_OW 235
// if IsDrivenBy ( i ) then
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 311
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: LD_VAR 0 3
5214: PUSH
5215: LD_VAR 0 5
5219: ARRAY
5220: PPUSH
5221: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 310
5234: PPUSH
5235: CALL_OW 247
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: LD_VAR 0 4
5249: PPUSH
5250: CALL_OW 122
// j := j + 1 ;
5254: LD_ADDR_VAR 0 5
5258: PUSH
5259: LD_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: LD_VAR 0 5
5272: PUSH
5273: LD_VAR 0 3
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: LD_ADDR_VAR 0 5
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PPUSH
5366: CALL_OW 12
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: LD_VAR 0 3
5381: PUSH
5382: LD_VAR 0 2
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: LD_VAR 0 3
5396: PUSH
5397: LD_VAR 0 2
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 58
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: LD_VAR 0 1
5426: NOT
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: CALL 4894 0 1
5453: PPUSH
5454: CALL 4736 0 2
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: LD_VAR 0 1
5470: NOT
5471: PUSH
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: CALL 4894 0 1
5497: PPUSH
5498: CALL 4736 0 2
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: LD_VAR 0 1
5514: NOT
5515: PUSH
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: LD_VAR 0 2
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL 4894 0 1
5567: PPUSH
5568: CALL 4736 0 2
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: LD_VAR 0 1
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: LD_VAR 0 2
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: LD_ADDR_VAR 0 8
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: CALL 4894 0 1
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: LD_ADDR_VAR 0 8
5620: PUSH
5621: LD_VAR 0 2
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: LD_ADDR_VAR 0 6
5630: PUSH
5631: LD_VAR 0 1
5635: PPUSH
5636: CALL_OW 503
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: LD_VAR 0 6
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: LD_ADDR_VAR 0 4
5656: PUSH
5657: LD_VAR 0 6
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: LD_ADDR_VAR 0 7
5666: PUSH
5667: LD_OWVAR 3
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: DIFF
5694: PPUSH
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 74
5704: ST_TO_ADDR
// if nearest_unit then
5705: LD_VAR 0 7
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_VAR 0 7
5720: PPUSH
5721: CALL_OW 255
5725: ST_TO_ADDR
// if not side and not side2 then
5726: LD_VAR 0 4
5730: NOT
5731: PUSH
5732: LD_VAR 0 5
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 5
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: LD_VAR 0 4
5758: PPUSH
5759: LD_VAR 0 8
5763: PPUSH
5764: CALL 4736 0 2
5768: GO 5818
// begin if side then
5770: LD_VAR 0 4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: LD_VAR 0 4
5780: PPUSH
5781: LD_VAR 0 8
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: CALL 4736 0 2
// if side2 then
5794: LD_VAR 0 5
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: LD_VAR 0 5
5804: PPUSH
5805: LD_VAR 0 8
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: CALL 4736 0 2
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 4894 0 1
5838: PPUSH
5839: CALL 4736 0 2
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: LD_ADDR_VAR 0 9
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: CALL_OW 69
5878: ST_TO_ADDR
// side_bot := side ;
5879: LD_ADDR_EXP 3
5883: PUSH
5884: LD_VAR 0 1
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: LD_VAR 0 9
5893: PUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_VAR 0 9
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: LD_VAR 0 3
5922: PPUSH
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 235
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: LD_ADDR_VAR 0 10
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 10
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: LD_VAR 0 3
6012: PPUSH
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 322
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: LD_ADDR_VAR 0 8
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_OWVAR 67
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: CALL_OW 169
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: CALL_OW 67
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: LD_VAR 0 1
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: LD_ADDR_EXP 33
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: LD_VAR 0 8
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: CALL 18116 0 6
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: LD_ADDR_EXP 34
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: LD_VAR 0 8
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL 18116 0 6
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: LD_ADDR_EXP 31
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: LD_VAR 0 8
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL 18116 0 6
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: LD_ADDR_EXP 32
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: LD_VAR 0 8
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL 18116 0 6
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: LD_ADDR_EXP 35
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: LD_VAR 0 8
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: CALL 18116 0 6
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: LD_ADDR_EXP 43
6377: PUSH
6378: LD_EXP 33
6382: PUSH
6383: LD_EXP 31
6387: PUSH
6388: LD_EXP 35
6392: PUSH
6393: LD_EXP 32
6397: PUSH
6398: LD_EXP 34
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: LD_ADDR_VAR 0 5
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: LD_VAR 0 3
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: LD_VAR 0 8
6511: PPUSH
6512: CALL_OW 380
// un := CreateVehicle ;
6516: LD_ADDR_VAR 0 6
6520: PUSH
6521: CALL_OW 45
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: PPUSH
6542: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: LD_VAR 0 5
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: CALL_OW 50
// un2 := CreateHuman ;
6579: LD_ADDR_VAR 0 7
6583: PUSH
6584: CALL_OW 44
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: LD_VAR 0 7
6593: PPUSH
6594: LD_VAR 0 6
6598: PPUSH
6599: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: LD_ADDR_EXP 43
6607: PUSH
6608: LD_EXP 43
6612: PPUSH
6613: LD_VAR 0 3
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: LD_EXP 43
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: LD_VAR 0 6
6657: PPUSH
6658: CALL 14797 0 3
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: LD_ADDR_EXP 43
6667: PUSH
6668: LD_EXP 43
6672: PPUSH
6673: LD_VAR 0 3
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: LD_EXP 43
6690: PUSH
6691: LD_VAR 0 3
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: LD_VAR 0 7
6717: PPUSH
6718: CALL 14797 0 3
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: LD_EXP 3
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: LD_VAR 0 3
6777: PPUSH
6778: CALL_OW 274
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: LD_ADDR_VAR 0 4
6790: PUSH
6791: LD_VAR 0 3
6795: PPUSH
6796: CALL_OW 254
6800: ST_TO_ADDR
// if d < 3 then
6801: LD_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: LD_ADDR_VAR 0 4
6815: PUSH
6816: LD_VAR 0 4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: LD_ADDR_VAR 0 4
6831: PUSH
6832: LD_VAR 0 4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: LD_VAR 0 8
6851: PPUSH
6852: CALL_OW 380
// un := CreateHuman ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: CALL_OW 44
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: LD_VAR 0 6
6870: PPUSH
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6880: LD_VAR 0 6
6884: PPUSH
6885: LD_VAR 0 3
6889: PPUSH
6890: CALL_OW 52
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: LD_ADDR_EXP 36
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_VAR 0 8
6915: PPUSH
6916: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: LD_ADDR_EXP 36
6940: PUSH
6941: LD_EXP 36
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: CALL_OW 44
6953: PPUSH
6954: CALL_OW 1
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: LD_VAR 0 8
6969: PPUSH
6970: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: LD_ADDR_EXP 36
6994: PUSH
6995: LD_EXP 36
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: CALL_OW 44
7007: PPUSH
7008: CALL_OW 1
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: LD_VAR 0 8
7023: PPUSH
7024: CALL_OW 380
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: LD_ADDR_EXP 36
7040: PUSH
7041: LD_EXP 36
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 44
7053: PPUSH
7054: CALL_OW 1
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: LD_ADDR_EXP 39
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: LD_EXP 39
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: CALL_OW 52
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: LD_ADDR_EXP 40
7203: PUSH
7204: CALL_OW 44
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: LD_EXP 40
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: CALL_OW 52
// InitHc ;
7221: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: LD_ADDR_EXP 38
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: LD_ADDR_VAR 0 4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: LD_OWVAR 67
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: LD_ADDR_VAR 0 3
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 12
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: CALL 14675 0 5
// un := CreateVehicle ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: CALL_OW 45
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: LD_ADDR_EXP 38
7391: PUSH
7392: LD_EXP 38
7396: PPUSH
7397: LD_VAR 0 3
7401: PUSH
7402: LD_EXP 38
7406: PUSH
7407: LD_VAR 0 3
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: LD_VAR 0 6
7425: PPUSH
7426: CALL 14797 0 3
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: LD_VAR 0 6
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: CALL_OW 12
7446: PPUSH
7447: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: LD_VAR 0 6
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_VAR 0 3
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: CALL_OW 19
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: CALL_OW 302
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: CALL_OW 255
7519: PUSH
7520: LD_EXP 3
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: LD_ADDR_VAR 0 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: LD_ADDR_VAR 0 7
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: LD_ADDR_VAR 0 6
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: LD_ADDR_VAR 0 9
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: LD_ADDR_VAR 0 5
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: LD_OWVAR 67
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: LD_ADDR_VAR 0 1
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_OWVAR 67
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_VAR 0 5
7790: PPUSH
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: CALL_OW 12
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 2
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: LD_VAR 0 4
7858: PPUSH
7859: LD_VAR 0 5
7863: PPUSH
7864: CALL 71207 0 2
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7875: LD_VAR 0 4
7879: PPUSH
7880: CALL 71603 0 1
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: CALL_OW 67
// for i = 1 to coords do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: LD_VAR 0 6
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: LD_EXP 3
7924: PPUSH
7925: LD_VAR 0 6
7929: PUSH
7930: LD_VAR 0 1
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: LD_VAR 0 6
7944: PUSH
7945: LD_VAR 0 1
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: CALL 15693 0 4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: LD_VAR 0 2
7971: PUSH
7972: LD_VAR 0 3
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 2
7988: ST_TO_ADDR
// target := i ;
7989: LD_ADDR_VAR 0 9
7993: PUSH
7994: LD_VAR 0 1
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: LD_VAR 0 9
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: LD_ADDR_VAR 0 10
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: LD_ADDR_VAR 0 10
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: LD_VAR 0 10
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: LD_ADDR_VAR 0 10
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: LD_VAR 0 4
8209: PPUSH
8210: LD_EXP 62
8214: PUSH
8215: LD_VAR 0 4
8219: ARRAY
8220: PPUSH
8221: LD_VAR 0 10
8225: PPUSH
8226: LD_VAR 0 7
8230: PPUSH
8231: CALL 71440 0 4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: CALL_OW 302
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: CALL_OW 255
8253: PUSH
8254: LD_EXP 3
8258: EQUAL
8259: AND
8260: PUSH
8261: LD_EXP 26
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: CALL_OW 301
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: CALL_OW 255
8286: PUSH
8287: LD_EXP 3
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: LD_ADDR_VAR 0 7
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: LD_ADDR_VAR 0 9
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: LD_ADDR_VAR 0 5
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: LD_OWVAR 67
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: LD_ADDR_VAR 0 1
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: LD_OWVAR 67
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: LD_ADDR_VAR 0 5
8512: PUSH
8513: LD_VAR 0 5
8517: PPUSH
8518: LD_VAR 0 5
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 1
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 2
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 5
8588: PPUSH
8589: CALL 71207 0 2
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL 71603 0 1
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: CALL_OW 67
// for i = 1 to coords do
8622: LD_ADDR_VAR 0 1
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: LD_VAR 0 6
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_EXP 3
8649: PPUSH
8650: LD_VAR 0 6
8654: PUSH
8655: LD_VAR 0 1
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_VAR 0 6
8669: PUSH
8670: LD_VAR 0 1
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: CALL 15693 0 4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_VAR 0 3
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_VAR 0 2
8713: ST_TO_ADDR
// target := i ;
8714: LD_ADDR_VAR 0 9
8718: PUSH
8719: LD_VAR 0 1
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: LD_VAR 0 9
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: LD_ADDR_VAR 0 10
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: LD_VAR 0 10
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: LD_ADDR_VAR 0 10
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_EXP 62
8859: PUSH
8860: LD_VAR 0 4
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 10
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL 71440 0 4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: LD_EXP 4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 255
8904: PPUSH
8905: CALL 5823 0 1
// artifact_get := true ;
8909: LD_ADDR_EXP 4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: LD_ADDR_VAR 0 3
8928: PUSH
8929: LD_VAR 0 1
8933: PPUSH
8934: CALL_OW 255
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_EXP 69
8948: IN
8949: NOT
8950: PUSH
8951: LD_EXP 7
8955: PUSH
8956: LD_VAR 0 3
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: LD_VAR 0 1
8968: PPUSH
8969: CALL_OW 247
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: LD_VAR 0 3
8983: PPUSH
8984: CALL 5463 0 1
// if side in mc_sides then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_EXP 69
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: LD_VAR 0 1
9004: PUSH
9005: LD_EXP 40
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: CALL 5577 0 2
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: CALL 4894 0 1
9038: PPUSH
9039: CALL 5577 0 2
// if multi_commanders and multi_custom_commanders then
9043: LD_EXP 24
9047: PUSH
9048: LD_EXP 16
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: LD_VAR 0 1
9059: PUSH
9060: LD_EXP 24
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: LD_ADDR_EXP 25
9071: PUSH
9072: LD_EXP 25
9076: PPUSH
9077: LD_VAR 0 3
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: CALL_OW 1
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: LD_ADDR_EXP 24
9094: PUSH
9095: LD_EXP 24
9099: PUSH
9100: LD_VAR 0 1
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: CALL 4927 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL 74666 0 1
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL 77000 0 2
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: LD_VAR 0 1
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_EXP 69
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: LD_VAR 0 1
9169: PPUSH
9170: CALL_OW 255
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 266
9184: PPUSH
9185: CALL 5507 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: LD_VAR 0 1
9193: PPUSH
9194: CALL_OW 266
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_EXP 69
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: LD_EXP 5
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: LD_VAR 0 1
9232: PPUSH
9233: LD_EXP 5
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9246: LD_ADDR_EXP 5
9250: PUSH
9251: LD_EXP 5
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: CALL_OW 3
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: CALL 76309 0 1
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL 74362 0 2
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: LD_VAR 0 1
9297: PPUSH
9298: LD_VAR 0 2
9302: PPUSH
9303: LD_VAR 0 3
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: LD_VAR 0 5
9317: PPUSH
9318: CALL 73982 0 5
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 255
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: LD_VAR 0 4
9349: PUSH
9350: LD_EXP 69
9354: IN
9355: NOT
9356: PUSH
9357: LD_EXP 7
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: LD_VAR 0 4
9374: PPUSH
9375: CALL 5419 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_VAR 0 2
9388: PPUSH
9389: CALL 73572 0 2
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: LD_VAR 0 1
9400: PPUSH
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 3
9410: PPUSH
9411: LD_VAR 0 4
9415: PPUSH
9416: CALL 73410 0 4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: LD_VAR 0 3
9437: PPUSH
9438: CALL 73185 0 3
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_VAR 0 2
9454: PPUSH
9455: CALL 73070 0 2
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: LD_VAR 0 1
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: CALL 77261 0 2
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PPUSH
9489: LD_VAR 0 3
9493: PPUSH
9494: LD_VAR 0 4
9498: PPUSH
9499: CALL 77477 0 4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: LD_EXP 2
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: LD_EXP 21
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: LD_EXP 21
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: CALL 9556 0 3
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: LD_VAR 0 1
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 67
// x := 5 ;
9599: LD_ADDR_VAR 0 6
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: LD_OWVAR 1
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: LD_OWVAR 67
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: LD_ADDR_VAR 0 5
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_EXP 7
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: LD_EXP 7
9656: PUSH
9657: LD_VAR 0 5
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: LD_VAR 0 6
9668: PPUSH
9669: LD_VAR 0 7
9673: PUSH
9674: LD_EXP 7
9678: PUSH
9679: LD_VAR 0 5
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 55
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: CALL_OW 67
// end ; for i in areas do
9704: LD_ADDR_VAR 0 5
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9724: LD_VAR 0 6
9728: PPUSH
9729: LD_VAR 0 5
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL_OW 55
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_VAR 0 2
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: LD_ADDR_VAR 0 3
9763: PUSH
9764: LD_VAR 0 3
9768: PUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: LD_ADDR_VAR 0 6
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: LD_ADDR_VAR 0 6
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: LD_EXP 2
9833: NOT
9834: PUSH
9835: LD_VAR 0 3
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: LD_VAR 0 2
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: LD_ADDR_VAR 0 5
9865: PUSH
9866: LD_VAR 0 3
9870: PUSH
9871: LD_VAR 0 1
9875: STR
9876: PPUSH
9877: CALL_OW 34
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: LD_ADDR_VAR 0 5
9888: PUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 25
9898: ST_TO_ADDR
// result := unit ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_VAR 0 5
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: LD_VAR 0 1
9922: NOT
9923: PUSH
9924: LD_VAR 0 2
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10698
// case nation of nation_american :
9934: LD_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: LD_ADDR_VAR 0 4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10622
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10391
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10170: LD_ADDR_VAR 0 4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: ST_TO_ADDR
10389: GO 10622
10391: LD_INT 3
10393: DOUBLE
10394: EQUAL
10395: IFTRUE 10399
10397: GO 10621
10399: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10400: LD_ADDR_VAR 0 4
10404: PUSH
10405: LD_INT 46
10407: PUSH
10408: LD_INT 47
10410: PUSH
10411: LD_INT 1
10413: PUSH
10414: LD_INT 2
10416: PUSH
10417: LD_INT 82
10419: PUSH
10420: LD_INT 83
10422: PUSH
10423: LD_INT 84
10425: PUSH
10426: LD_INT 85
10428: PUSH
10429: LD_INT 86
10431: PUSH
10432: LD_INT 11
10434: PUSH
10435: LD_INT 9
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 19
10443: PUSH
10444: LD_INT 21
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 25
10455: PUSH
10456: LD_INT 28
10458: PUSH
10459: LD_INT 29
10461: PUSH
10462: LD_INT 30
10464: PUSH
10465: LD_INT 31
10467: PUSH
10468: LD_INT 37
10470: PUSH
10471: LD_INT 38
10473: PUSH
10474: LD_INT 32
10476: PUSH
10477: LD_INT 27
10479: PUSH
10480: LD_INT 33
10482: PUSH
10483: LD_INT 69
10485: PUSH
10486: LD_INT 39
10488: PUSH
10489: LD_INT 34
10491: PUSH
10492: LD_INT 40
10494: PUSH
10495: LD_INT 71
10497: PUSH
10498: LD_INT 23
10500: PUSH
10501: LD_INT 44
10503: PUSH
10504: LD_INT 48
10506: PUSH
10507: LD_INT 49
10509: PUSH
10510: LD_INT 50
10512: PUSH
10513: LD_INT 51
10515: PUSH
10516: LD_INT 52
10518: PUSH
10519: LD_INT 53
10521: PUSH
10522: LD_INT 54
10524: PUSH
10525: LD_INT 55
10527: PUSH
10528: LD_INT 56
10530: PUSH
10531: LD_INT 57
10533: PUSH
10534: LD_INT 58
10536: PUSH
10537: LD_INT 59
10539: PUSH
10540: LD_INT 63
10542: PUSH
10543: LD_INT 64
10545: PUSH
10546: LD_INT 65
10548: PUSH
10549: LD_INT 82
10551: PUSH
10552: LD_INT 83
10554: PUSH
10555: LD_INT 84
10557: PUSH
10558: LD_INT 85
10560: PUSH
10561: LD_INT 86
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: ST_TO_ADDR
10619: GO 10622
10621: POP
// if state > - 1 and state < 3 then
10622: LD_VAR 0 3
10626: PUSH
10627: LD_INT 1
10629: NEG
10630: GREATER
10631: PUSH
10632: LD_VAR 0 3
10636: PUSH
10637: LD_INT 3
10639: LESS
10640: AND
10641: IFFALSE 10698
// for i in result do
10643: LD_ADDR_VAR 0 5
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: FOR_IN
10654: IFFALSE 10696
// if GetTech ( i , side ) <> state then
10656: LD_VAR 0 5
10660: PPUSH
10661: LD_VAR 0 1
10665: PPUSH
10666: CALL_OW 321
10670: PUSH
10671: LD_VAR 0 3
10675: NONEQUAL
10676: IFFALSE 10694
// result := result diff i ;
10678: LD_ADDR_VAR 0 4
10682: PUSH
10683: LD_VAR 0 4
10687: PUSH
10688: LD_VAR 0 5
10692: DIFF
10693: ST_TO_ADDR
10694: GO 10653
10696: POP
10697: POP
// end ;
10698: LD_VAR 0 4
10702: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
// result := true ;
10708: LD_ADDR_VAR 0 3
10712: PUSH
10713: LD_INT 1
10715: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10716: LD_ADDR_VAR 0 5
10720: PUSH
10721: LD_VAR 0 2
10725: PPUSH
10726: CALL_OW 480
10730: ST_TO_ADDR
// if not tmp then
10731: LD_VAR 0 5
10735: NOT
10736: IFFALSE 10740
// exit ;
10738: GO 10789
// for i in tmp do
10740: LD_ADDR_VAR 0 4
10744: PUSH
10745: LD_VAR 0 5
10749: PUSH
10750: FOR_IN
10751: IFFALSE 10787
// if GetTech ( i , side ) <> state_researched then
10753: LD_VAR 0 4
10757: PPUSH
10758: LD_VAR 0 1
10762: PPUSH
10763: CALL_OW 321
10767: PUSH
10768: LD_INT 2
10770: NONEQUAL
10771: IFFALSE 10785
// begin result := false ;
10773: LD_ADDR_VAR 0 3
10777: PUSH
10778: LD_INT 0
10780: ST_TO_ADDR
// exit ;
10781: POP
10782: POP
10783: GO 10789
// end ;
10785: GO 10750
10787: POP
10788: POP
// end ;
10789: LD_VAR 0 3
10793: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10794: LD_INT 0
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10809: LD_VAR 0 1
10813: NOT
10814: PUSH
10815: LD_VAR 0 1
10819: PPUSH
10820: CALL_OW 257
10824: PUSH
10825: LD_INT 9
10827: NONEQUAL
10828: OR
10829: IFFALSE 10833
// exit ;
10831: GO 11406
// side := GetSide ( unit ) ;
10833: LD_ADDR_VAR 0 9
10837: PUSH
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 255
10847: ST_TO_ADDR
// tech_space := tech_spacanom ;
10848: LD_ADDR_VAR 0 12
10852: PUSH
10853: LD_INT 29
10855: ST_TO_ADDR
// tech_time := tech_taurad ;
10856: LD_ADDR_VAR 0 13
10860: PUSH
10861: LD_INT 28
10863: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10864: LD_ADDR_VAR 0 11
10868: PUSH
10869: LD_VAR 0 1
10873: PPUSH
10874: CALL_OW 310
10878: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10879: LD_VAR 0 11
10883: PPUSH
10884: CALL_OW 247
10888: PUSH
10889: LD_INT 2
10891: EQUAL
10892: IFFALSE 10896
// exit ;
10894: GO 11406
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10896: LD_ADDR_VAR 0 8
10900: PUSH
10901: LD_INT 81
10903: PUSH
10904: LD_VAR 0 9
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 3
10915: PUSH
10916: LD_INT 21
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PPUSH
10934: CALL_OW 69
10938: ST_TO_ADDR
// if not tmp then
10939: LD_VAR 0 8
10943: NOT
10944: IFFALSE 10948
// exit ;
10946: GO 11406
// if in_unit then
10948: LD_VAR 0 11
10952: IFFALSE 10976
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10954: LD_ADDR_VAR 0 10
10958: PUSH
10959: LD_VAR 0 8
10963: PPUSH
10964: LD_VAR 0 11
10968: PPUSH
10969: CALL_OW 74
10973: ST_TO_ADDR
10974: GO 10996
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10976: LD_ADDR_VAR 0 10
10980: PUSH
10981: LD_VAR 0 8
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: ST_TO_ADDR
// if not enemy then
10996: LD_VAR 0 10
11000: NOT
11001: IFFALSE 11005
// exit ;
11003: GO 11406
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11005: LD_VAR 0 11
11009: PUSH
11010: LD_VAR 0 11
11014: PPUSH
11015: LD_VAR 0 10
11019: PPUSH
11020: CALL_OW 296
11024: PUSH
11025: LD_INT 13
11027: GREATER
11028: AND
11029: PUSH
11030: LD_VAR 0 1
11034: PPUSH
11035: LD_VAR 0 10
11039: PPUSH
11040: CALL_OW 296
11044: PUSH
11045: LD_INT 12
11047: GREATER
11048: OR
11049: IFFALSE 11053
// exit ;
11051: GO 11406
// missile := [ 1 ] ;
11053: LD_ADDR_VAR 0 14
11057: PUSH
11058: LD_INT 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11064: LD_VAR 0 9
11068: PPUSH
11069: LD_VAR 0 12
11073: PPUSH
11074: CALL_OW 325
11078: IFFALSE 11107
// missile := Insert ( missile , missile + 1 , 2 ) ;
11080: LD_ADDR_VAR 0 14
11084: PUSH
11085: LD_VAR 0 14
11089: PPUSH
11090: LD_VAR 0 14
11094: PUSH
11095: LD_INT 1
11097: PLUS
11098: PPUSH
11099: LD_INT 2
11101: PPUSH
11102: CALL_OW 2
11106: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11107: LD_VAR 0 9
11111: PPUSH
11112: LD_VAR 0 13
11116: PPUSH
11117: CALL_OW 325
11121: PUSH
11122: LD_VAR 0 10
11126: PPUSH
11127: CALL_OW 255
11131: PPUSH
11132: LD_VAR 0 13
11136: PPUSH
11137: CALL_OW 325
11141: NOT
11142: AND
11143: IFFALSE 11172
// missile := Insert ( missile , missile + 1 , 3 ) ;
11145: LD_ADDR_VAR 0 14
11149: PUSH
11150: LD_VAR 0 14
11154: PPUSH
11155: LD_VAR 0 14
11159: PUSH
11160: LD_INT 1
11162: PLUS
11163: PPUSH
11164: LD_INT 3
11166: PPUSH
11167: CALL_OW 2
11171: ST_TO_ADDR
// if missile < 2 then
11172: LD_VAR 0 14
11176: PUSH
11177: LD_INT 2
11179: LESS
11180: IFFALSE 11184
// exit ;
11182: GO 11406
// x := GetX ( enemy ) ;
11184: LD_ADDR_VAR 0 4
11188: PUSH
11189: LD_VAR 0 10
11193: PPUSH
11194: CALL_OW 250
11198: ST_TO_ADDR
// y := GetY ( enemy ) ;
11199: LD_ADDR_VAR 0 5
11203: PUSH
11204: LD_VAR 0 10
11208: PPUSH
11209: CALL_OW 251
11213: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 4
11223: PUSH
11224: LD_INT 1
11226: NEG
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL_OW 12
11235: PLUS
11236: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11237: LD_ADDR_VAR 0 7
11241: PUSH
11242: LD_VAR 0 5
11246: PUSH
11247: LD_INT 1
11249: NEG
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: CALL_OW 12
11258: PLUS
11259: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11260: LD_VAR 0 6
11264: PPUSH
11265: LD_VAR 0 7
11269: PPUSH
11270: CALL_OW 488
11274: NOT
11275: IFFALSE 11297
// begin _x := x ;
11277: LD_ADDR_VAR 0 6
11281: PUSH
11282: LD_VAR 0 4
11286: ST_TO_ADDR
// _y := y ;
11287: LD_ADDR_VAR 0 7
11291: PUSH
11292: LD_VAR 0 5
11296: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11297: LD_ADDR_VAR 0 3
11301: PUSH
11302: LD_INT 1
11304: PPUSH
11305: LD_VAR 0 14
11309: PPUSH
11310: CALL_OW 12
11314: ST_TO_ADDR
// case i of 1 :
11315: LD_VAR 0 3
11319: PUSH
11320: LD_INT 1
11322: DOUBLE
11323: EQUAL
11324: IFTRUE 11328
11326: GO 11345
11328: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11329: LD_VAR 0 1
11333: PPUSH
11334: LD_VAR 0 10
11338: PPUSH
11339: CALL_OW 115
11343: GO 11406
11345: LD_INT 2
11347: DOUBLE
11348: EQUAL
11349: IFTRUE 11353
11351: GO 11375
11353: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_VAR 0 6
11363: PPUSH
11364: LD_VAR 0 7
11368: PPUSH
11369: CALL_OW 153
11373: GO 11406
11375: LD_INT 3
11377: DOUBLE
11378: EQUAL
11379: IFTRUE 11383
11381: GO 11405
11383: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11384: LD_VAR 0 1
11388: PPUSH
11389: LD_VAR 0 6
11393: PPUSH
11394: LD_VAR 0 7
11398: PPUSH
11399: CALL_OW 154
11403: GO 11406
11405: POP
// end ;
11406: LD_VAR 0 2
11410: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11411: LD_INT 0
11413: PPUSH
11414: PPUSH
11415: PPUSH
11416: PPUSH
11417: PPUSH
11418: PPUSH
// if not unit or not building then
11419: LD_VAR 0 1
11423: NOT
11424: PUSH
11425: LD_VAR 0 2
11429: NOT
11430: OR
11431: IFFALSE 11435
// exit ;
11433: GO 11593
// x := GetX ( building ) ;
11435: LD_ADDR_VAR 0 5
11439: PUSH
11440: LD_VAR 0 2
11444: PPUSH
11445: CALL_OW 250
11449: ST_TO_ADDR
// y := GetY ( building ) ;
11450: LD_ADDR_VAR 0 6
11454: PUSH
11455: LD_VAR 0 2
11459: PPUSH
11460: CALL_OW 251
11464: ST_TO_ADDR
// for i = 0 to 5 do
11465: LD_ADDR_VAR 0 4
11469: PUSH
11470: DOUBLE
11471: LD_INT 0
11473: DEC
11474: ST_TO_ADDR
11475: LD_INT 5
11477: PUSH
11478: FOR_TO
11479: IFFALSE 11591
// begin _x := ShiftX ( x , i , 3 ) ;
11481: LD_ADDR_VAR 0 7
11485: PUSH
11486: LD_VAR 0 5
11490: PPUSH
11491: LD_VAR 0 4
11495: PPUSH
11496: LD_INT 3
11498: PPUSH
11499: CALL_OW 272
11503: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11504: LD_ADDR_VAR 0 8
11508: PUSH
11509: LD_VAR 0 6
11513: PPUSH
11514: LD_VAR 0 4
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: CALL_OW 273
11526: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11527: LD_VAR 0 7
11531: PPUSH
11532: LD_VAR 0 8
11536: PPUSH
11537: CALL_OW 488
11541: NOT
11542: IFFALSE 11546
// continue ;
11544: GO 11478
// if HexInfo ( _x , _y ) = 0 then
11546: LD_VAR 0 7
11550: PPUSH
11551: LD_VAR 0 8
11555: PPUSH
11556: CALL_OW 428
11560: PUSH
11561: LD_INT 0
11563: EQUAL
11564: IFFALSE 11589
// begin ComMoveXY ( unit , _x , _y ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: LD_VAR 0 7
11575: PPUSH
11576: LD_VAR 0 8
11580: PPUSH
11581: CALL_OW 111
// exit ;
11585: POP
11586: POP
11587: GO 11593
// end ; end ;
11589: GO 11478
11591: POP
11592: POP
// end ;
11593: LD_VAR 0 3
11597: RET
// export function ScanBase ( side , base_area ) ; begin
11598: LD_INT 0
11600: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11601: LD_ADDR_VAR 0 3
11605: PUSH
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 81
11613: PUSH
11614: LD_VAR 0 1
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 70
11627: ST_TO_ADDR
// end ;
11628: LD_VAR 0 3
11632: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11633: LD_INT 0
11635: PPUSH
11636: PPUSH
11637: PPUSH
11638: PPUSH
// result := false ;
11639: LD_ADDR_VAR 0 2
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
// side := GetSide ( unit ) ;
11647: LD_ADDR_VAR 0 3
11651: PUSH
11652: LD_VAR 0 1
11656: PPUSH
11657: CALL_OW 255
11661: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11662: LD_ADDR_VAR 0 4
11666: PUSH
11667: LD_VAR 0 1
11671: PPUSH
11672: CALL_OW 248
11676: ST_TO_ADDR
// case nat of 1 :
11677: LD_VAR 0 4
11681: PUSH
11682: LD_INT 1
11684: DOUBLE
11685: EQUAL
11686: IFTRUE 11690
11688: GO 11701
11690: POP
// tech := tech_lassight ; 2 :
11691: LD_ADDR_VAR 0 5
11695: PUSH
11696: LD_INT 12
11698: ST_TO_ADDR
11699: GO 11740
11701: LD_INT 2
11703: DOUBLE
11704: EQUAL
11705: IFTRUE 11709
11707: GO 11720
11709: POP
// tech := tech_mortar ; 3 :
11710: LD_ADDR_VAR 0 5
11714: PUSH
11715: LD_INT 41
11717: ST_TO_ADDR
11718: GO 11740
11720: LD_INT 3
11722: DOUBLE
11723: EQUAL
11724: IFTRUE 11728
11726: GO 11739
11728: POP
// tech := tech_bazooka ; end ;
11729: LD_ADDR_VAR 0 5
11733: PUSH
11734: LD_INT 44
11736: ST_TO_ADDR
11737: GO 11740
11739: POP
// if Researched ( side , tech ) then
11740: LD_VAR 0 3
11744: PPUSH
11745: LD_VAR 0 5
11749: PPUSH
11750: CALL_OW 325
11754: IFFALSE 11781
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11756: LD_ADDR_VAR 0 2
11760: PUSH
11761: LD_INT 5
11763: PUSH
11764: LD_INT 8
11766: PUSH
11767: LD_INT 9
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_VAR 0 4
11779: ARRAY
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 2
11785: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11786: LD_INT 0
11788: PPUSH
11789: PPUSH
11790: PPUSH
// if not mines then
11791: LD_VAR 0 2
11795: NOT
11796: IFFALSE 11800
// exit ;
11798: GO 11944
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_INT 81
11807: PUSH
11808: LD_VAR 0 1
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: PUSH
11817: LD_INT 3
11819: PUSH
11820: LD_INT 21
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PPUSH
11838: CALL_OW 69
11842: ST_TO_ADDR
// for i in mines do
11843: LD_ADDR_VAR 0 4
11847: PUSH
11848: LD_VAR 0 2
11852: PUSH
11853: FOR_IN
11854: IFFALSE 11942
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11856: LD_VAR 0 4
11860: PUSH
11861: LD_INT 1
11863: ARRAY
11864: PPUSH
11865: LD_VAR 0 4
11869: PUSH
11870: LD_INT 2
11872: ARRAY
11873: PPUSH
11874: CALL_OW 458
11878: NOT
11879: IFFALSE 11883
// continue ;
11881: GO 11853
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11883: LD_VAR 0 4
11887: PUSH
11888: LD_INT 1
11890: ARRAY
11891: PPUSH
11892: LD_VAR 0 4
11896: PUSH
11897: LD_INT 2
11899: ARRAY
11900: PPUSH
11901: CALL_OW 428
11905: PUSH
11906: LD_VAR 0 5
11910: IN
11911: IFFALSE 11940
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11913: LD_VAR 0 4
11917: PUSH
11918: LD_INT 1
11920: ARRAY
11921: PPUSH
11922: LD_VAR 0 4
11926: PUSH
11927: LD_INT 2
11929: ARRAY
11930: PPUSH
11931: LD_VAR 0 1
11935: PPUSH
11936: CALL_OW 456
// end ;
11940: GO 11853
11942: POP
11943: POP
// end ;
11944: LD_VAR 0 3
11948: RET
// export function Count ( array ) ; var i ; begin
11949: LD_INT 0
11951: PPUSH
11952: PPUSH
// result := 0 ;
11953: LD_ADDR_VAR 0 2
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// for i in array do
11961: LD_ADDR_VAR 0 3
11965: PUSH
11966: LD_VAR 0 1
11970: PUSH
11971: FOR_IN
11972: IFFALSE 11996
// if i then
11974: LD_VAR 0 3
11978: IFFALSE 11994
// result := result + 1 ;
11980: LD_ADDR_VAR 0 2
11984: PUSH
11985: LD_VAR 0 2
11989: PUSH
11990: LD_INT 1
11992: PLUS
11993: ST_TO_ADDR
11994: GO 11971
11996: POP
11997: POP
// end ;
11998: LD_VAR 0 2
12002: RET
// export function IsEmpty ( building ) ; begin
12003: LD_INT 0
12005: PPUSH
// if not building then
12006: LD_VAR 0 1
12010: NOT
12011: IFFALSE 12015
// exit ;
12013: GO 12058
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12015: LD_ADDR_VAR 0 2
12019: PUSH
12020: LD_VAR 0 1
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 58
12044: PUSH
12045: EMPTY
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PPUSH
12052: CALL_OW 69
12056: IN
12057: ST_TO_ADDR
// end ;
12058: LD_VAR 0 2
12062: RET
// export function IsNotFull ( building ) ; begin
12063: LD_INT 0
12065: PPUSH
// if not building then
12066: LD_VAR 0 1
12070: NOT
12071: IFFALSE 12075
// exit ;
12073: GO 12094
// result := UnitsInside ( building ) < 6 ;
12075: LD_ADDR_VAR 0 2
12079: PUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 313
12089: PUSH
12090: LD_INT 6
12092: LESS
12093: ST_TO_ADDR
// end ;
12094: LD_VAR 0 2
12098: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
12103: PPUSH
12104: PPUSH
// tmp := [ ] ;
12105: LD_ADDR_VAR 0 3
12109: PUSH
12110: EMPTY
12111: ST_TO_ADDR
// list := [ ] ;
12112: LD_ADDR_VAR 0 5
12116: PUSH
12117: EMPTY
12118: ST_TO_ADDR
// for i = 16 to 25 do
12119: LD_ADDR_VAR 0 4
12123: PUSH
12124: DOUBLE
12125: LD_INT 16
12127: DEC
12128: ST_TO_ADDR
12129: LD_INT 25
12131: PUSH
12132: FOR_TO
12133: IFFALSE 12206
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12135: LD_ADDR_VAR 0 3
12139: PUSH
12140: LD_VAR 0 3
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: LD_VAR 0 1
12152: PPUSH
12153: CALL_OW 255
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 91
12164: PUSH
12165: LD_VAR 0 1
12169: PUSH
12170: LD_INT 6
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 30
12180: PUSH
12181: LD_VAR 0 4
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: PUSH
12195: EMPTY
12196: LIST
12197: PPUSH
12198: CALL_OW 69
12202: ADD
12203: ST_TO_ADDR
12204: GO 12132
12206: POP
12207: POP
// for i = 1 to tmp do
12208: LD_ADDR_VAR 0 4
12212: PUSH
12213: DOUBLE
12214: LD_INT 1
12216: DEC
12217: ST_TO_ADDR
12218: LD_VAR 0 3
12222: PUSH
12223: FOR_TO
12224: IFFALSE 12312
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12226: LD_ADDR_VAR 0 5
12230: PUSH
12231: LD_VAR 0 5
12235: PUSH
12236: LD_VAR 0 3
12240: PUSH
12241: LD_VAR 0 4
12245: ARRAY
12246: PPUSH
12247: CALL_OW 266
12251: PUSH
12252: LD_VAR 0 3
12256: PUSH
12257: LD_VAR 0 4
12261: ARRAY
12262: PPUSH
12263: CALL_OW 250
12267: PUSH
12268: LD_VAR 0 3
12272: PUSH
12273: LD_VAR 0 4
12277: ARRAY
12278: PPUSH
12279: CALL_OW 251
12283: PUSH
12284: LD_VAR 0 3
12288: PUSH
12289: LD_VAR 0 4
12293: ARRAY
12294: PPUSH
12295: CALL_OW 254
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: PUSH
12306: EMPTY
12307: LIST
12308: ADD
12309: ST_TO_ADDR
12310: GO 12223
12312: POP
12313: POP
// result := list ;
12314: LD_ADDR_VAR 0 2
12318: PUSH
12319: LD_VAR 0 5
12323: ST_TO_ADDR
// end ;
12324: LD_VAR 0 2
12328: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12329: LD_INT 0
12331: PPUSH
12332: PPUSH
12333: PPUSH
12334: PPUSH
12335: PPUSH
12336: PPUSH
12337: PPUSH
// if not factory then
12338: LD_VAR 0 1
12342: NOT
12343: IFFALSE 12347
// exit ;
12345: GO 12940
// if control = control_apeman then
12347: LD_VAR 0 4
12351: PUSH
12352: LD_INT 5
12354: EQUAL
12355: IFFALSE 12464
// begin tmp := UnitsInside ( factory ) ;
12357: LD_ADDR_VAR 0 8
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 313
12371: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12372: LD_VAR 0 8
12376: PPUSH
12377: LD_INT 25
12379: PUSH
12380: LD_INT 12
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PPUSH
12387: CALL_OW 72
12391: NOT
12392: IFFALSE 12402
// control := control_manual ;
12394: LD_ADDR_VAR 0 4
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12402: LD_ADDR_VAR 0 8
12406: PUSH
12407: LD_VAR 0 1
12411: PPUSH
12412: CALL 12099 0 1
12416: ST_TO_ADDR
// if tmp then
12417: LD_VAR 0 8
12421: IFFALSE 12464
// begin for i in tmp do
12423: LD_ADDR_VAR 0 7
12427: PUSH
12428: LD_VAR 0 8
12432: PUSH
12433: FOR_IN
12434: IFFALSE 12462
// if i [ 1 ] = b_ext_radio then
12436: LD_VAR 0 7
12440: PUSH
12441: LD_INT 1
12443: ARRAY
12444: PUSH
12445: LD_INT 22
12447: EQUAL
12448: IFFALSE 12460
// begin control := control_remote ;
12450: LD_ADDR_VAR 0 4
12454: PUSH
12455: LD_INT 2
12457: ST_TO_ADDR
// break ;
12458: GO 12462
// end ;
12460: GO 12433
12462: POP
12463: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12464: LD_VAR 0 1
12468: PPUSH
12469: LD_VAR 0 2
12473: PPUSH
12474: LD_VAR 0 3
12478: PPUSH
12479: LD_VAR 0 4
12483: PPUSH
12484: LD_VAR 0 5
12488: PPUSH
12489: CALL_OW 448
12493: IFFALSE 12528
// begin result := [ chassis , engine , control , weapon ] ;
12495: LD_ADDR_VAR 0 6
12499: PUSH
12500: LD_VAR 0 2
12504: PUSH
12505: LD_VAR 0 3
12509: PUSH
12510: LD_VAR 0 4
12514: PUSH
12515: LD_VAR 0 5
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: ST_TO_ADDR
// exit ;
12526: GO 12940
// end ; _chassis := AvailableChassisList ( factory ) ;
12528: LD_ADDR_VAR 0 9
12532: PUSH
12533: LD_VAR 0 1
12537: PPUSH
12538: CALL_OW 475
12542: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12543: LD_ADDR_VAR 0 11
12547: PUSH
12548: LD_VAR 0 1
12552: PPUSH
12553: CALL_OW 476
12557: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12558: LD_ADDR_VAR 0 12
12562: PUSH
12563: LD_VAR 0 1
12567: PPUSH
12568: CALL_OW 477
12572: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12573: LD_ADDR_VAR 0 10
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 478
12587: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12588: LD_VAR 0 9
12592: NOT
12593: PUSH
12594: LD_VAR 0 11
12598: NOT
12599: OR
12600: PUSH
12601: LD_VAR 0 12
12605: NOT
12606: OR
12607: PUSH
12608: LD_VAR 0 10
12612: NOT
12613: OR
12614: IFFALSE 12649
// begin result := [ chassis , engine , control , weapon ] ;
12616: LD_ADDR_VAR 0 6
12620: PUSH
12621: LD_VAR 0 2
12625: PUSH
12626: LD_VAR 0 3
12630: PUSH
12631: LD_VAR 0 4
12635: PUSH
12636: LD_VAR 0 5
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: ST_TO_ADDR
// exit ;
12647: GO 12940
// end ; if not chassis in _chassis then
12649: LD_VAR 0 2
12653: PUSH
12654: LD_VAR 0 9
12658: IN
12659: NOT
12660: IFFALSE 12686
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 9
12671: PUSH
12672: LD_INT 1
12674: PPUSH
12675: LD_VAR 0 9
12679: PPUSH
12680: CALL_OW 12
12684: ARRAY
12685: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12686: LD_VAR 0 2
12690: PPUSH
12691: LD_VAR 0 3
12695: PPUSH
12696: CALL 12945 0 2
12700: NOT
12701: IFFALSE 12760
// repeat engine := _engine [ 1 ] ;
12703: LD_ADDR_VAR 0 3
12707: PUSH
12708: LD_VAR 0 11
12712: PUSH
12713: LD_INT 1
12715: ARRAY
12716: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12717: LD_ADDR_VAR 0 11
12721: PUSH
12722: LD_VAR 0 11
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 3
12734: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_VAR 0 3
12744: PPUSH
12745: CALL 12945 0 2
12749: PUSH
12750: LD_VAR 0 11
12754: PUSH
12755: EMPTY
12756: EQUAL
12757: OR
12758: IFFALSE 12703
// if not control in _control then
12760: LD_VAR 0 4
12764: PUSH
12765: LD_VAR 0 12
12769: IN
12770: NOT
12771: IFFALSE 12797
// control := _control [ rand ( 1 , _control ) ] ;
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: LD_VAR 0 12
12782: PUSH
12783: LD_INT 1
12785: PPUSH
12786: LD_VAR 0 12
12790: PPUSH
12791: CALL_OW 12
12795: ARRAY
12796: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12797: LD_VAR 0 2
12801: PPUSH
12802: LD_VAR 0 5
12806: PPUSH
12807: CALL 13165 0 2
12811: NOT
12812: IFFALSE 12871
// repeat weapon := _weapon [ 1 ] ;
12814: LD_ADDR_VAR 0 5
12818: PUSH
12819: LD_VAR 0 10
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12828: LD_ADDR_VAR 0 10
12832: PUSH
12833: LD_VAR 0 10
12837: PPUSH
12838: LD_INT 1
12840: PPUSH
12841: CALL_OW 3
12845: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12846: LD_VAR 0 2
12850: PPUSH
12851: LD_VAR 0 5
12855: PPUSH
12856: CALL 13165 0 2
12860: PUSH
12861: LD_VAR 0 10
12865: PUSH
12866: EMPTY
12867: EQUAL
12868: OR
12869: IFFALSE 12814
// result := [ ] ;
12871: LD_ADDR_VAR 0 6
12875: PUSH
12876: EMPTY
12877: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12878: LD_VAR 0 1
12882: PPUSH
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_VAR 0 3
12892: PPUSH
12893: LD_VAR 0 4
12897: PPUSH
12898: LD_VAR 0 5
12902: PPUSH
12903: CALL_OW 448
12907: IFFALSE 12940
// result := [ chassis , engine , control , weapon ] ;
12909: LD_ADDR_VAR 0 6
12913: PUSH
12914: LD_VAR 0 2
12918: PUSH
12919: LD_VAR 0 3
12923: PUSH
12924: LD_VAR 0 4
12928: PUSH
12929: LD_VAR 0 5
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: ST_TO_ADDR
// end ;
12940: LD_VAR 0 6
12944: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12945: LD_INT 0
12947: PPUSH
// if not chassis or not engine then
12948: LD_VAR 0 1
12952: NOT
12953: PUSH
12954: LD_VAR 0 2
12958: NOT
12959: OR
12960: IFFALSE 12964
// exit ;
12962: GO 13160
// case engine of engine_solar :
12964: LD_VAR 0 2
12968: PUSH
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 13015
12977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12978: LD_ADDR_VAR 0 3
12982: PUSH
12983: LD_INT 11
12985: PUSH
12986: LD_INT 12
12988: PUSH
12989: LD_INT 13
12991: PUSH
12992: LD_INT 14
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: ST_TO_ADDR
13013: GO 13144
13015: LD_INT 1
13017: DOUBLE
13018: EQUAL
13019: IFTRUE 13023
13021: GO 13085
13023: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13024: LD_ADDR_VAR 0 3
13028: PUSH
13029: LD_INT 11
13031: PUSH
13032: LD_INT 12
13034: PUSH
13035: LD_INT 13
13037: PUSH
13038: LD_INT 14
13040: PUSH
13041: LD_INT 1
13043: PUSH
13044: LD_INT 2
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 4
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 21
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 22
13064: PUSH
13065: LD_INT 24
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 13144
13085: LD_INT 3
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13143
13093: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 13
13101: PUSH
13102: LD_INT 14
13104: PUSH
13105: LD_INT 2
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: LD_INT 4
13113: PUSH
13114: LD_INT 5
13116: PUSH
13117: LD_INT 21
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 23
13125: PUSH
13126: LD_INT 24
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: ST_TO_ADDR
13141: GO 13144
13143: POP
// result := ( chassis in result ) ;
13144: LD_ADDR_VAR 0 3
13148: PUSH
13149: LD_VAR 0 1
13153: PUSH
13154: LD_VAR 0 3
13158: IN
13159: ST_TO_ADDR
// end ;
13160: LD_VAR 0 3
13164: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13165: LD_INT 0
13167: PPUSH
// if not chassis or not weapon then
13168: LD_VAR 0 1
13172: NOT
13173: PUSH
13174: LD_VAR 0 2
13178: NOT
13179: OR
13180: IFFALSE 13184
// exit ;
13182: GO 14210
// case weapon of us_machine_gun :
13184: LD_VAR 0 2
13188: PUSH
13189: LD_INT 2
13191: DOUBLE
13192: EQUAL
13193: IFTRUE 13197
13195: GO 13227
13197: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13198: LD_ADDR_VAR 0 3
13202: PUSH
13203: LD_INT 1
13205: PUSH
13206: LD_INT 2
13208: PUSH
13209: LD_INT 3
13211: PUSH
13212: LD_INT 4
13214: PUSH
13215: LD_INT 5
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: ST_TO_ADDR
13225: GO 14194
13227: LD_INT 3
13229: DOUBLE
13230: EQUAL
13231: IFTRUE 13235
13233: GO 13265
13235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13236: LD_ADDR_VAR 0 3
13240: PUSH
13241: LD_INT 1
13243: PUSH
13244: LD_INT 2
13246: PUSH
13247: LD_INT 3
13249: PUSH
13250: LD_INT 4
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: ST_TO_ADDR
13263: GO 14194
13265: LD_INT 11
13267: DOUBLE
13268: EQUAL
13269: IFTRUE 13273
13271: GO 13303
13273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13274: LD_ADDR_VAR 0 3
13278: PUSH
13279: LD_INT 1
13281: PUSH
13282: LD_INT 2
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 4
13290: PUSH
13291: LD_INT 5
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: ST_TO_ADDR
13301: GO 14194
13303: LD_INT 4
13305: DOUBLE
13306: EQUAL
13307: IFTRUE 13311
13309: GO 13337
13311: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13312: LD_ADDR_VAR 0 3
13316: PUSH
13317: LD_INT 2
13319: PUSH
13320: LD_INT 3
13322: PUSH
13323: LD_INT 4
13325: PUSH
13326: LD_INT 5
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: ST_TO_ADDR
13335: GO 14194
13337: LD_INT 5
13339: DOUBLE
13340: EQUAL
13341: IFTRUE 13345
13343: GO 13371
13345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13346: LD_ADDR_VAR 0 3
13350: PUSH
13351: LD_INT 2
13353: PUSH
13354: LD_INT 3
13356: PUSH
13357: LD_INT 4
13359: PUSH
13360: LD_INT 5
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: ST_TO_ADDR
13369: GO 14194
13371: LD_INT 9
13373: DOUBLE
13374: EQUAL
13375: IFTRUE 13379
13377: GO 13405
13379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13380: LD_ADDR_VAR 0 3
13384: PUSH
13385: LD_INT 2
13387: PUSH
13388: LD_INT 3
13390: PUSH
13391: LD_INT 4
13393: PUSH
13394: LD_INT 5
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: ST_TO_ADDR
13403: GO 14194
13405: LD_INT 7
13407: DOUBLE
13408: EQUAL
13409: IFTRUE 13413
13411: GO 13439
13413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13414: LD_ADDR_VAR 0 3
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: LD_INT 3
13424: PUSH
13425: LD_INT 4
13427: PUSH
13428: LD_INT 5
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: ST_TO_ADDR
13437: GO 14194
13439: LD_INT 12
13441: DOUBLE
13442: EQUAL
13443: IFTRUE 13447
13445: GO 13473
13447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_INT 2
13455: PUSH
13456: LD_INT 3
13458: PUSH
13459: LD_INT 4
13461: PUSH
13462: LD_INT 5
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: ST_TO_ADDR
13471: GO 14194
13473: LD_INT 13
13475: DOUBLE
13476: EQUAL
13477: IFTRUE 13481
13479: GO 13507
13481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: LD_INT 3
13492: PUSH
13493: LD_INT 4
13495: PUSH
13496: LD_INT 5
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: LIST
13504: ST_TO_ADDR
13505: GO 14194
13507: LD_INT 14
13509: DOUBLE
13510: EQUAL
13511: IFTRUE 13515
13513: GO 13533
13515: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13516: LD_ADDR_VAR 0 3
13520: PUSH
13521: LD_INT 4
13523: PUSH
13524: LD_INT 5
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: ST_TO_ADDR
13531: GO 14194
13533: LD_INT 6
13535: DOUBLE
13536: EQUAL
13537: IFTRUE 13541
13539: GO 13559
13541: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13542: LD_ADDR_VAR 0 3
13546: PUSH
13547: LD_INT 4
13549: PUSH
13550: LD_INT 5
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: ST_TO_ADDR
13557: GO 14194
13559: LD_INT 10
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13585
13567: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13568: LD_ADDR_VAR 0 3
13572: PUSH
13573: LD_INT 4
13575: PUSH
13576: LD_INT 5
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: ST_TO_ADDR
13583: GO 14194
13585: LD_INT 22
13587: DOUBLE
13588: EQUAL
13589: IFTRUE 13593
13591: GO 13619
13593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13594: LD_ADDR_VAR 0 3
13598: PUSH
13599: LD_INT 11
13601: PUSH
13602: LD_INT 12
13604: PUSH
13605: LD_INT 13
13607: PUSH
13608: LD_INT 14
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: ST_TO_ADDR
13617: GO 14194
13619: LD_INT 23
13621: DOUBLE
13622: EQUAL
13623: IFTRUE 13627
13625: GO 13653
13627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13628: LD_ADDR_VAR 0 3
13632: PUSH
13633: LD_INT 11
13635: PUSH
13636: LD_INT 12
13638: PUSH
13639: LD_INT 13
13641: PUSH
13642: LD_INT 14
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: ST_TO_ADDR
13651: GO 14194
13653: LD_INT 24
13655: DOUBLE
13656: EQUAL
13657: IFTRUE 13661
13659: GO 13687
13661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13662: LD_ADDR_VAR 0 3
13666: PUSH
13667: LD_INT 11
13669: PUSH
13670: LD_INT 12
13672: PUSH
13673: LD_INT 13
13675: PUSH
13676: LD_INT 14
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: ST_TO_ADDR
13685: GO 14194
13687: LD_INT 30
13689: DOUBLE
13690: EQUAL
13691: IFTRUE 13695
13693: GO 13721
13695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13696: LD_ADDR_VAR 0 3
13700: PUSH
13701: LD_INT 11
13703: PUSH
13704: LD_INT 12
13706: PUSH
13707: LD_INT 13
13709: PUSH
13710: LD_INT 14
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: ST_TO_ADDR
13719: GO 14194
13721: LD_INT 25
13723: DOUBLE
13724: EQUAL
13725: IFTRUE 13729
13727: GO 13747
13729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13730: LD_ADDR_VAR 0 3
13734: PUSH
13735: LD_INT 13
13737: PUSH
13738: LD_INT 14
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: ST_TO_ADDR
13745: GO 14194
13747: LD_INT 27
13749: DOUBLE
13750: EQUAL
13751: IFTRUE 13755
13753: GO 13773
13755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13756: LD_ADDR_VAR 0 3
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 14
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14194
13773: LD_INT 28
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13799
13781: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13782: LD_ADDR_VAR 0 3
13786: PUSH
13787: LD_INT 13
13789: PUSH
13790: LD_INT 14
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: ST_TO_ADDR
13797: GO 14194
13799: LD_INT 29
13801: DOUBLE
13802: EQUAL
13803: IFTRUE 13807
13805: GO 13825
13807: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_INT 13
13815: PUSH
13816: LD_INT 14
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: ST_TO_ADDR
13823: GO 14194
13825: LD_INT 31
13827: DOUBLE
13828: EQUAL
13829: IFTRUE 13833
13831: GO 13851
13833: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: ST_TO_ADDR
13849: GO 14194
13851: LD_INT 26
13853: DOUBLE
13854: EQUAL
13855: IFTRUE 13859
13857: GO 13877
13859: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_INT 13
13867: PUSH
13868: LD_INT 14
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: ST_TO_ADDR
13875: GO 14194
13877: LD_INT 42
13879: DOUBLE
13880: EQUAL
13881: IFTRUE 13885
13883: GO 13911
13885: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13886: LD_ADDR_VAR 0 3
13890: PUSH
13891: LD_INT 21
13893: PUSH
13894: LD_INT 22
13896: PUSH
13897: LD_INT 23
13899: PUSH
13900: LD_INT 24
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: ST_TO_ADDR
13909: GO 14194
13911: LD_INT 43
13913: DOUBLE
13914: EQUAL
13915: IFTRUE 13919
13917: GO 13945
13919: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: LD_INT 21
13927: PUSH
13928: LD_INT 22
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 24
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14194
13945: LD_INT 44
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 13979
13953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13954: LD_ADDR_VAR 0 3
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 22
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: ST_TO_ADDR
13977: GO 14194
13979: LD_INT 45
13981: DOUBLE
13982: EQUAL
13983: IFTRUE 13987
13985: GO 14013
13987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13988: LD_ADDR_VAR 0 3
13992: PUSH
13993: LD_INT 21
13995: PUSH
13996: LD_INT 22
13998: PUSH
13999: LD_INT 23
14001: PUSH
14002: LD_INT 24
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: ST_TO_ADDR
14011: GO 14194
14013: LD_INT 49
14015: DOUBLE
14016: EQUAL
14017: IFTRUE 14021
14019: GO 14047
14021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14022: LD_ADDR_VAR 0 3
14026: PUSH
14027: LD_INT 21
14029: PUSH
14030: LD_INT 22
14032: PUSH
14033: LD_INT 23
14035: PUSH
14036: LD_INT 24
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: ST_TO_ADDR
14045: GO 14194
14047: LD_INT 51
14049: DOUBLE
14050: EQUAL
14051: IFTRUE 14055
14053: GO 14081
14055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14056: LD_ADDR_VAR 0 3
14060: PUSH
14061: LD_INT 21
14063: PUSH
14064: LD_INT 22
14066: PUSH
14067: LD_INT 23
14069: PUSH
14070: LD_INT 24
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: ST_TO_ADDR
14079: GO 14194
14081: LD_INT 52
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14115
14089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14090: LD_ADDR_VAR 0 3
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_INT 23
14103: PUSH
14104: LD_INT 24
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: ST_TO_ADDR
14113: GO 14194
14115: LD_INT 53
14117: DOUBLE
14118: EQUAL
14119: IFTRUE 14123
14121: GO 14141
14123: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14124: LD_ADDR_VAR 0 3
14128: PUSH
14129: LD_INT 23
14131: PUSH
14132: LD_INT 24
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: ST_TO_ADDR
14139: GO 14194
14141: LD_INT 46
14143: DOUBLE
14144: EQUAL
14145: IFTRUE 14149
14147: GO 14167
14149: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_INT 23
14157: PUSH
14158: LD_INT 24
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
14165: GO 14194
14167: LD_INT 47
14169: DOUBLE
14170: EQUAL
14171: IFTRUE 14175
14173: GO 14193
14175: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14176: LD_ADDR_VAR 0 3
14180: PUSH
14181: LD_INT 23
14183: PUSH
14184: LD_INT 24
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: ST_TO_ADDR
14191: GO 14194
14193: POP
// result := ( chassis in result ) ;
14194: LD_ADDR_VAR 0 3
14198: PUSH
14199: LD_VAR 0 1
14203: PUSH
14204: LD_VAR 0 3
14208: IN
14209: ST_TO_ADDR
// end ;
14210: LD_VAR 0 3
14214: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14215: LD_INT 0
14217: PPUSH
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
14223: PPUSH
// result := array ;
14224: LD_ADDR_VAR 0 5
14228: PUSH
14229: LD_VAR 0 1
14233: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14234: LD_VAR 0 1
14238: NOT
14239: PUSH
14240: LD_VAR 0 2
14244: NOT
14245: OR
14246: PUSH
14247: LD_VAR 0 3
14251: NOT
14252: OR
14253: PUSH
14254: LD_VAR 0 2
14258: PUSH
14259: LD_VAR 0 1
14263: GREATER
14264: OR
14265: PUSH
14266: LD_VAR 0 3
14270: PUSH
14271: LD_VAR 0 1
14275: GREATER
14276: OR
14277: IFFALSE 14281
// exit ;
14279: GO 14577
// if direction then
14281: LD_VAR 0 4
14285: IFFALSE 14349
// begin d := 1 ;
14287: LD_ADDR_VAR 0 9
14291: PUSH
14292: LD_INT 1
14294: ST_TO_ADDR
// if i_from > i_to then
14295: LD_VAR 0 2
14299: PUSH
14300: LD_VAR 0 3
14304: GREATER
14305: IFFALSE 14331
// length := ( array - i_from ) + i_to else
14307: LD_ADDR_VAR 0 11
14311: PUSH
14312: LD_VAR 0 1
14316: PUSH
14317: LD_VAR 0 2
14321: MINUS
14322: PUSH
14323: LD_VAR 0 3
14327: PLUS
14328: ST_TO_ADDR
14329: GO 14347
// length := i_to - i_from ;
14331: LD_ADDR_VAR 0 11
14335: PUSH
14336: LD_VAR 0 3
14340: PUSH
14341: LD_VAR 0 2
14345: MINUS
14346: ST_TO_ADDR
// end else
14347: GO 14410
// begin d := - 1 ;
14349: LD_ADDR_VAR 0 9
14353: PUSH
14354: LD_INT 1
14356: NEG
14357: ST_TO_ADDR
// if i_from > i_to then
14358: LD_VAR 0 2
14362: PUSH
14363: LD_VAR 0 3
14367: GREATER
14368: IFFALSE 14388
// length := i_from - i_to else
14370: LD_ADDR_VAR 0 11
14374: PUSH
14375: LD_VAR 0 2
14379: PUSH
14380: LD_VAR 0 3
14384: MINUS
14385: ST_TO_ADDR
14386: GO 14410
// length := ( array - i_to ) + i_from ;
14388: LD_ADDR_VAR 0 11
14392: PUSH
14393: LD_VAR 0 1
14397: PUSH
14398: LD_VAR 0 3
14402: MINUS
14403: PUSH
14404: LD_VAR 0 2
14408: PLUS
14409: ST_TO_ADDR
// end ; if not length then
14410: LD_VAR 0 11
14414: NOT
14415: IFFALSE 14419
// exit ;
14417: GO 14577
// tmp := array ;
14419: LD_ADDR_VAR 0 10
14423: PUSH
14424: LD_VAR 0 1
14428: ST_TO_ADDR
// for i = 1 to length do
14429: LD_ADDR_VAR 0 6
14433: PUSH
14434: DOUBLE
14435: LD_INT 1
14437: DEC
14438: ST_TO_ADDR
14439: LD_VAR 0 11
14443: PUSH
14444: FOR_TO
14445: IFFALSE 14565
// begin for j = 1 to array do
14447: LD_ADDR_VAR 0 7
14451: PUSH
14452: DOUBLE
14453: LD_INT 1
14455: DEC
14456: ST_TO_ADDR
14457: LD_VAR 0 1
14461: PUSH
14462: FOR_TO
14463: IFFALSE 14551
// begin k := j + d ;
14465: LD_ADDR_VAR 0 8
14469: PUSH
14470: LD_VAR 0 7
14474: PUSH
14475: LD_VAR 0 9
14479: PLUS
14480: ST_TO_ADDR
// if k > array then
14481: LD_VAR 0 8
14485: PUSH
14486: LD_VAR 0 1
14490: GREATER
14491: IFFALSE 14501
// k := 1 ;
14493: LD_ADDR_VAR 0 8
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// if not k then
14501: LD_VAR 0 8
14505: NOT
14506: IFFALSE 14518
// k := array ;
14508: LD_ADDR_VAR 0 8
14512: PUSH
14513: LD_VAR 0 1
14517: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14518: LD_ADDR_VAR 0 10
14522: PUSH
14523: LD_VAR 0 10
14527: PPUSH
14528: LD_VAR 0 8
14532: PPUSH
14533: LD_VAR 0 1
14537: PUSH
14538: LD_VAR 0 7
14542: ARRAY
14543: PPUSH
14544: CALL_OW 1
14548: ST_TO_ADDR
// end ;
14549: GO 14462
14551: POP
14552: POP
// array := tmp ;
14553: LD_ADDR_VAR 0 1
14557: PUSH
14558: LD_VAR 0 10
14562: ST_TO_ADDR
// end ;
14563: GO 14444
14565: POP
14566: POP
// result := array ;
14567: LD_ADDR_VAR 0 5
14571: PUSH
14572: LD_VAR 0 1
14576: ST_TO_ADDR
// end ;
14577: LD_VAR 0 5
14581: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14582: LD_INT 0
14584: PPUSH
14585: PPUSH
// result := 0 ;
14586: LD_ADDR_VAR 0 3
14590: PUSH
14591: LD_INT 0
14593: ST_TO_ADDR
// if not array or not value in array then
14594: LD_VAR 0 1
14598: NOT
14599: PUSH
14600: LD_VAR 0 2
14604: PUSH
14605: LD_VAR 0 1
14609: IN
14610: NOT
14611: OR
14612: IFFALSE 14616
// exit ;
14614: GO 14670
// for i = 1 to array do
14616: LD_ADDR_VAR 0 4
14620: PUSH
14621: DOUBLE
14622: LD_INT 1
14624: DEC
14625: ST_TO_ADDR
14626: LD_VAR 0 1
14630: PUSH
14631: FOR_TO
14632: IFFALSE 14668
// if value = array [ i ] then
14634: LD_VAR 0 2
14638: PUSH
14639: LD_VAR 0 1
14643: PUSH
14644: LD_VAR 0 4
14648: ARRAY
14649: EQUAL
14650: IFFALSE 14666
// begin result := i ;
14652: LD_ADDR_VAR 0 3
14656: PUSH
14657: LD_VAR 0 4
14661: ST_TO_ADDR
// exit ;
14662: POP
14663: POP
14664: GO 14670
// end ;
14666: GO 14631
14668: POP
14669: POP
// end ;
14670: LD_VAR 0 3
14674: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14675: LD_INT 0
14677: PPUSH
// vc_chassis := chassis ;
14678: LD_ADDR_OWVAR 37
14682: PUSH
14683: LD_VAR 0 1
14687: ST_TO_ADDR
// vc_engine := engine ;
14688: LD_ADDR_OWVAR 39
14692: PUSH
14693: LD_VAR 0 2
14697: ST_TO_ADDR
// vc_control := control ;
14698: LD_ADDR_OWVAR 38
14702: PUSH
14703: LD_VAR 0 3
14707: ST_TO_ADDR
// vc_weapon := weapon ;
14708: LD_ADDR_OWVAR 40
14712: PUSH
14713: LD_VAR 0 4
14717: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14718: LD_ADDR_OWVAR 41
14722: PUSH
14723: LD_VAR 0 5
14727: ST_TO_ADDR
// end ;
14728: LD_VAR 0 6
14732: RET
// export function WantPlant ( unit ) ; var task ; begin
14733: LD_INT 0
14735: PPUSH
14736: PPUSH
// result := false ;
14737: LD_ADDR_VAR 0 2
14741: PUSH
14742: LD_INT 0
14744: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14745: LD_ADDR_VAR 0 3
14749: PUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 437
14759: ST_TO_ADDR
// if task then
14760: LD_VAR 0 3
14764: IFFALSE 14792
// if task [ 1 ] [ 1 ] = p then
14766: LD_VAR 0 3
14770: PUSH
14771: LD_INT 1
14773: ARRAY
14774: PUSH
14775: LD_INT 1
14777: ARRAY
14778: PUSH
14779: LD_STRING p
14781: EQUAL
14782: IFFALSE 14792
// result := true ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
// end ;
14792: LD_VAR 0 2
14796: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
// if pos < 1 then
14803: LD_VAR 0 2
14807: PUSH
14808: LD_INT 1
14810: LESS
14811: IFFALSE 14815
// exit ;
14813: GO 15118
// if pos = 1 then
14815: LD_VAR 0 2
14819: PUSH
14820: LD_INT 1
14822: EQUAL
14823: IFFALSE 14856
// result := Replace ( arr , pos [ 1 ] , value ) else
14825: LD_ADDR_VAR 0 4
14829: PUSH
14830: LD_VAR 0 1
14834: PPUSH
14835: LD_VAR 0 2
14839: PUSH
14840: LD_INT 1
14842: ARRAY
14843: PPUSH
14844: LD_VAR 0 3
14848: PPUSH
14849: CALL_OW 1
14853: ST_TO_ADDR
14854: GO 15118
// begin tmp := arr ;
14856: LD_ADDR_VAR 0 6
14860: PUSH
14861: LD_VAR 0 1
14865: ST_TO_ADDR
// s_arr := [ tmp ] ;
14866: LD_ADDR_VAR 0 7
14870: PUSH
14871: LD_VAR 0 6
14875: PUSH
14876: EMPTY
14877: LIST
14878: ST_TO_ADDR
// for i = 1 to pos - 1 do
14879: LD_ADDR_VAR 0 5
14883: PUSH
14884: DOUBLE
14885: LD_INT 1
14887: DEC
14888: ST_TO_ADDR
14889: LD_VAR 0 2
14893: PUSH
14894: LD_INT 1
14896: MINUS
14897: PUSH
14898: FOR_TO
14899: IFFALSE 14944
// begin tmp := tmp [ pos [ i ] ] ;
14901: LD_ADDR_VAR 0 6
14905: PUSH
14906: LD_VAR 0 6
14910: PUSH
14911: LD_VAR 0 2
14915: PUSH
14916: LD_VAR 0 5
14920: ARRAY
14921: ARRAY
14922: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14923: LD_ADDR_VAR 0 7
14927: PUSH
14928: LD_VAR 0 7
14932: PUSH
14933: LD_VAR 0 6
14937: PUSH
14938: EMPTY
14939: LIST
14940: ADD
14941: ST_TO_ADDR
// end ;
14942: GO 14898
14944: POP
14945: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14946: LD_ADDR_VAR 0 6
14950: PUSH
14951: LD_VAR 0 6
14955: PPUSH
14956: LD_VAR 0 2
14960: PUSH
14961: LD_VAR 0 2
14965: ARRAY
14966: PPUSH
14967: LD_VAR 0 3
14971: PPUSH
14972: CALL_OW 1
14976: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14977: LD_ADDR_VAR 0 7
14981: PUSH
14982: LD_VAR 0 7
14986: PPUSH
14987: LD_VAR 0 7
14991: PPUSH
14992: LD_VAR 0 6
14996: PPUSH
14997: CALL_OW 1
15001: ST_TO_ADDR
// for i = s_arr downto 2 do
15002: LD_ADDR_VAR 0 5
15006: PUSH
15007: DOUBLE
15008: LD_VAR 0 7
15012: INC
15013: ST_TO_ADDR
15014: LD_INT 2
15016: PUSH
15017: FOR_DOWNTO
15018: IFFALSE 15102
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15020: LD_ADDR_VAR 0 6
15024: PUSH
15025: LD_VAR 0 7
15029: PUSH
15030: LD_VAR 0 5
15034: PUSH
15035: LD_INT 1
15037: MINUS
15038: ARRAY
15039: PPUSH
15040: LD_VAR 0 2
15044: PUSH
15045: LD_VAR 0 5
15049: PUSH
15050: LD_INT 1
15052: MINUS
15053: ARRAY
15054: PPUSH
15055: LD_VAR 0 7
15059: PUSH
15060: LD_VAR 0 5
15064: ARRAY
15065: PPUSH
15066: CALL_OW 1
15070: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15071: LD_ADDR_VAR 0 7
15075: PUSH
15076: LD_VAR 0 7
15080: PPUSH
15081: LD_VAR 0 5
15085: PUSH
15086: LD_INT 1
15088: MINUS
15089: PPUSH
15090: LD_VAR 0 6
15094: PPUSH
15095: CALL_OW 1
15099: ST_TO_ADDR
// end ;
15100: GO 15017
15102: POP
15103: POP
// result := s_arr [ 1 ] ;
15104: LD_ADDR_VAR 0 4
15108: PUSH
15109: LD_VAR 0 7
15113: PUSH
15114: LD_INT 1
15116: ARRAY
15117: ST_TO_ADDR
// end ; end ;
15118: LD_VAR 0 4
15122: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15123: LD_INT 0
15125: PPUSH
15126: PPUSH
// if not list then
15127: LD_VAR 0 1
15131: NOT
15132: IFFALSE 15136
// exit ;
15134: GO 15227
// i := list [ pos1 ] ;
15136: LD_ADDR_VAR 0 5
15140: PUSH
15141: LD_VAR 0 1
15145: PUSH
15146: LD_VAR 0 2
15150: ARRAY
15151: ST_TO_ADDR
// if not i then
15152: LD_VAR 0 5
15156: NOT
15157: IFFALSE 15161
// exit ;
15159: GO 15227
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15161: LD_ADDR_VAR 0 1
15165: PUSH
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 2
15175: PPUSH
15176: LD_VAR 0 1
15180: PUSH
15181: LD_VAR 0 3
15185: ARRAY
15186: PPUSH
15187: CALL_OW 1
15191: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15192: LD_ADDR_VAR 0 1
15196: PUSH
15197: LD_VAR 0 1
15201: PPUSH
15202: LD_VAR 0 3
15206: PPUSH
15207: LD_VAR 0 5
15211: PPUSH
15212: CALL_OW 1
15216: ST_TO_ADDR
// result := list ;
15217: LD_ADDR_VAR 0 4
15221: PUSH
15222: LD_VAR 0 1
15226: ST_TO_ADDR
// end ;
15227: LD_VAR 0 4
15231: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15232: LD_INT 0
15234: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15235: LD_ADDR_VAR 0 5
15239: PUSH
15240: LD_VAR 0 1
15244: PPUSH
15245: CALL_OW 250
15249: PPUSH
15250: LD_VAR 0 1
15254: PPUSH
15255: CALL_OW 251
15259: PPUSH
15260: LD_VAR 0 2
15264: PPUSH
15265: LD_VAR 0 3
15269: PPUSH
15270: LD_VAR 0 4
15274: PPUSH
15275: CALL 15285 0 5
15279: ST_TO_ADDR
// end ;
15280: LD_VAR 0 5
15284: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15285: LD_INT 0
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
// if not list then
15291: LD_VAR 0 3
15295: NOT
15296: IFFALSE 15300
// exit ;
15298: GO 15688
// result := [ ] ;
15300: LD_ADDR_VAR 0 6
15304: PUSH
15305: EMPTY
15306: ST_TO_ADDR
// for i in list do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_VAR 0 3
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15520
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15320: LD_ADDR_VAR 0 9
15324: PUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 2
15339: PPUSH
15340: CALL_OW 297
15344: ST_TO_ADDR
// if not result then
15345: LD_VAR 0 6
15349: NOT
15350: IFFALSE 15376
// result := [ [ i , tmp ] ] else
15352: LD_ADDR_VAR 0 6
15356: PUSH
15357: LD_VAR 0 7
15361: PUSH
15362: LD_VAR 0 9
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: ST_TO_ADDR
15374: GO 15518
// begin if result [ result ] [ 2 ] < tmp then
15376: LD_VAR 0 6
15380: PUSH
15381: LD_VAR 0 6
15385: ARRAY
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PUSH
15391: LD_VAR 0 9
15395: LESS
15396: IFFALSE 15438
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15398: LD_ADDR_VAR 0 6
15402: PUSH
15403: LD_VAR 0 6
15407: PPUSH
15408: LD_VAR 0 6
15412: PUSH
15413: LD_INT 1
15415: PLUS
15416: PPUSH
15417: LD_VAR 0 7
15421: PUSH
15422: LD_VAR 0 9
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PPUSH
15431: CALL_OW 2
15435: ST_TO_ADDR
15436: GO 15518
// for j = 1 to result do
15438: LD_ADDR_VAR 0 8
15442: PUSH
15443: DOUBLE
15444: LD_INT 1
15446: DEC
15447: ST_TO_ADDR
15448: LD_VAR 0 6
15452: PUSH
15453: FOR_TO
15454: IFFALSE 15516
// begin if tmp < result [ j ] [ 2 ] then
15456: LD_VAR 0 9
15460: PUSH
15461: LD_VAR 0 6
15465: PUSH
15466: LD_VAR 0 8
15470: ARRAY
15471: PUSH
15472: LD_INT 2
15474: ARRAY
15475: LESS
15476: IFFALSE 15514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15478: LD_ADDR_VAR 0 6
15482: PUSH
15483: LD_VAR 0 6
15487: PPUSH
15488: LD_VAR 0 8
15492: PPUSH
15493: LD_VAR 0 7
15497: PUSH
15498: LD_VAR 0 9
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: PPUSH
15507: CALL_OW 2
15511: ST_TO_ADDR
// break ;
15512: GO 15516
// end ; end ;
15514: GO 15453
15516: POP
15517: POP
// end ; end ;
15518: GO 15317
15520: POP
15521: POP
// if result and not asc then
15522: LD_VAR 0 6
15526: PUSH
15527: LD_VAR 0 4
15531: NOT
15532: AND
15533: IFFALSE 15608
// begin tmp := result ;
15535: LD_ADDR_VAR 0 9
15539: PUSH
15540: LD_VAR 0 6
15544: ST_TO_ADDR
// for i = tmp downto 1 do
15545: LD_ADDR_VAR 0 7
15549: PUSH
15550: DOUBLE
15551: LD_VAR 0 9
15555: INC
15556: ST_TO_ADDR
15557: LD_INT 1
15559: PUSH
15560: FOR_DOWNTO
15561: IFFALSE 15606
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15563: LD_ADDR_VAR 0 6
15567: PUSH
15568: LD_VAR 0 6
15572: PPUSH
15573: LD_VAR 0 9
15577: PUSH
15578: LD_VAR 0 7
15582: MINUS
15583: PUSH
15584: LD_INT 1
15586: PLUS
15587: PPUSH
15588: LD_VAR 0 9
15592: PUSH
15593: LD_VAR 0 7
15597: ARRAY
15598: PPUSH
15599: CALL_OW 1
15603: ST_TO_ADDR
15604: GO 15560
15606: POP
15607: POP
// end ; tmp := [ ] ;
15608: LD_ADDR_VAR 0 9
15612: PUSH
15613: EMPTY
15614: ST_TO_ADDR
// if mode then
15615: LD_VAR 0 5
15619: IFFALSE 15688
// begin for i = 1 to result do
15621: LD_ADDR_VAR 0 7
15625: PUSH
15626: DOUBLE
15627: LD_INT 1
15629: DEC
15630: ST_TO_ADDR
15631: LD_VAR 0 6
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15676
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15639: LD_ADDR_VAR 0 9
15643: PUSH
15644: LD_VAR 0 9
15648: PPUSH
15649: LD_VAR 0 7
15653: PPUSH
15654: LD_VAR 0 6
15658: PUSH
15659: LD_VAR 0 7
15663: ARRAY
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: PPUSH
15669: CALL_OW 1
15673: ST_TO_ADDR
15674: GO 15636
15676: POP
15677: POP
// result := tmp ;
15678: LD_ADDR_VAR 0 6
15682: PUSH
15683: LD_VAR 0 9
15687: ST_TO_ADDR
// end ; end ;
15688: LD_VAR 0 6
15692: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15693: LD_INT 0
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15701: LD_ADDR_VAR 0 5
15705: PUSH
15706: LD_INT 0
15708: PUSH
15709: LD_INT 0
15711: PUSH
15712: LD_INT 0
15714: PUSH
15715: EMPTY
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: LIST
15722: ST_TO_ADDR
// if not x or not y then
15723: LD_VAR 0 2
15727: NOT
15728: PUSH
15729: LD_VAR 0 3
15733: NOT
15734: OR
15735: IFFALSE 15739
// exit ;
15737: GO 17385
// if not range then
15739: LD_VAR 0 4
15743: NOT
15744: IFFALSE 15754
// range := 10 ;
15746: LD_ADDR_VAR 0 4
15750: PUSH
15751: LD_INT 10
15753: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15754: LD_ADDR_VAR 0 8
15758: PUSH
15759: LD_INT 81
15761: PUSH
15762: LD_VAR 0 1
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: LD_INT 92
15773: PUSH
15774: LD_VAR 0 2
15778: PUSH
15779: LD_VAR 0 3
15783: PUSH
15784: LD_VAR 0 4
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: LD_INT 21
15800: PUSH
15801: LD_INT 3
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PPUSH
15817: CALL_OW 69
15821: ST_TO_ADDR
// if not tmp then
15822: LD_VAR 0 8
15826: NOT
15827: IFFALSE 15831
// exit ;
15829: GO 17385
// for i in tmp do
15831: LD_ADDR_VAR 0 6
15835: PUSH
15836: LD_VAR 0 8
15840: PUSH
15841: FOR_IN
15842: IFFALSE 17360
// begin points := [ 0 , 0 , 0 ] ;
15844: LD_ADDR_VAR 0 9
15848: PUSH
15849: LD_INT 0
15851: PUSH
15852: LD_INT 0
15854: PUSH
15855: LD_INT 0
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: LIST
15862: ST_TO_ADDR
// bpoints := 1 ;
15863: LD_ADDR_VAR 0 10
15867: PUSH
15868: LD_INT 1
15870: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15871: LD_VAR 0 6
15875: PPUSH
15876: CALL_OW 247
15880: PUSH
15881: LD_INT 1
15883: DOUBLE
15884: EQUAL
15885: IFTRUE 15889
15887: GO 16467
15889: POP
// begin if GetClass ( i ) = 1 then
15890: LD_VAR 0 6
15894: PPUSH
15895: CALL_OW 257
15899: PUSH
15900: LD_INT 1
15902: EQUAL
15903: IFFALSE 15924
// points := [ 10 , 5 , 3 ] ;
15905: LD_ADDR_VAR 0 9
15909: PUSH
15910: LD_INT 10
15912: PUSH
15913: LD_INT 5
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15924: LD_VAR 0 6
15928: PPUSH
15929: CALL_OW 257
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 3 , 2 , 1 ] ;
15950: LD_ADDR_VAR 0 9
15954: PUSH
15955: LD_INT 3
15957: PUSH
15958: LD_INT 2
15960: PUSH
15961: LD_INT 1
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15969: LD_VAR 0 6
15973: PPUSH
15974: CALL_OW 257
15978: PUSH
15979: LD_INT 5
15981: EQUAL
15982: IFFALSE 16003
// points := [ 130 , 5 , 2 ] ;
15984: LD_ADDR_VAR 0 9
15988: PUSH
15989: LD_INT 130
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 2
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16003: LD_VAR 0 6
16007: PPUSH
16008: CALL_OW 257
16012: PUSH
16013: LD_INT 8
16015: EQUAL
16016: IFFALSE 16037
// points := [ 35 , 35 , 30 ] ;
16018: LD_ADDR_VAR 0 9
16022: PUSH
16023: LD_INT 35
16025: PUSH
16026: LD_INT 35
16028: PUSH
16029: LD_INT 30
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL_OW 257
16046: PUSH
16047: LD_INT 9
16049: EQUAL
16050: IFFALSE 16071
// points := [ 20 , 55 , 40 ] ;
16052: LD_ADDR_VAR 0 9
16056: PUSH
16057: LD_INT 20
16059: PUSH
16060: LD_INT 55
16062: PUSH
16063: LD_INT 40
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: LIST
16070: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16071: LD_VAR 0 6
16075: PPUSH
16076: CALL_OW 257
16080: PUSH
16081: LD_INT 12
16083: PUSH
16084: LD_INT 16
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: IN
16091: IFFALSE 16112
// points := [ 5 , 3 , 2 ] ;
16093: LD_ADDR_VAR 0 9
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 3
16103: PUSH
16104: LD_INT 2
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL_OW 257
16121: PUSH
16122: LD_INT 17
16124: EQUAL
16125: IFFALSE 16146
// points := [ 100 , 50 , 75 ] ;
16127: LD_ADDR_VAR 0 9
16131: PUSH
16132: LD_INT 100
16134: PUSH
16135: LD_INT 50
16137: PUSH
16138: LD_INT 75
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: LIST
16145: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16146: LD_VAR 0 6
16150: PPUSH
16151: CALL_OW 257
16155: PUSH
16156: LD_INT 15
16158: EQUAL
16159: IFFALSE 16180
// points := [ 10 , 5 , 3 ] ;
16161: LD_ADDR_VAR 0 9
16165: PUSH
16166: LD_INT 10
16168: PUSH
16169: LD_INT 5
16171: PUSH
16172: LD_INT 3
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 257
16189: PUSH
16190: LD_INT 14
16192: EQUAL
16193: IFFALSE 16214
// points := [ 10 , 0 , 0 ] ;
16195: LD_ADDR_VAR 0 9
16199: PUSH
16200: LD_INT 10
16202: PUSH
16203: LD_INT 0
16205: PUSH
16206: LD_INT 0
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16214: LD_VAR 0 6
16218: PPUSH
16219: CALL_OW 257
16223: PUSH
16224: LD_INT 11
16226: EQUAL
16227: IFFALSE 16248
// points := [ 30 , 10 , 5 ] ;
16229: LD_ADDR_VAR 0 9
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 10
16239: PUSH
16240: LD_INT 5
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: LIST
16247: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16248: LD_VAR 0 1
16252: PPUSH
16253: LD_INT 5
16255: PPUSH
16256: CALL_OW 321
16260: PUSH
16261: LD_INT 2
16263: EQUAL
16264: IFFALSE 16281
// bpoints := bpoints * 1.8 ;
16266: LD_ADDR_VAR 0 10
16270: PUSH
16271: LD_VAR 0 10
16275: PUSH
16276: LD_REAL  1.80000000000000E+0000
16279: MUL
16280: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16281: LD_VAR 0 6
16285: PPUSH
16286: CALL_OW 257
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: LD_INT 3
16299: PUSH
16300: LD_INT 4
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: IN
16309: PUSH
16310: LD_VAR 0 1
16314: PPUSH
16315: LD_INT 51
16317: PPUSH
16318: CALL_OW 321
16322: PUSH
16323: LD_INT 2
16325: EQUAL
16326: AND
16327: IFFALSE 16344
// bpoints := bpoints * 1.2 ;
16329: LD_ADDR_VAR 0 10
16333: PUSH
16334: LD_VAR 0 10
16338: PUSH
16339: LD_REAL  1.20000000000000E+0000
16342: MUL
16343: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16344: LD_VAR 0 6
16348: PPUSH
16349: CALL_OW 257
16353: PUSH
16354: LD_INT 5
16356: PUSH
16357: LD_INT 7
16359: PUSH
16360: LD_INT 9
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: IN
16368: PUSH
16369: LD_VAR 0 1
16373: PPUSH
16374: LD_INT 52
16376: PPUSH
16377: CALL_OW 321
16381: PUSH
16382: LD_INT 2
16384: EQUAL
16385: AND
16386: IFFALSE 16403
// bpoints := bpoints * 1.5 ;
16388: LD_ADDR_VAR 0 10
16392: PUSH
16393: LD_VAR 0 10
16397: PUSH
16398: LD_REAL  1.50000000000000E+0000
16401: MUL
16402: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16403: LD_VAR 0 1
16407: PPUSH
16408: LD_INT 66
16410: PPUSH
16411: CALL_OW 321
16415: PUSH
16416: LD_INT 2
16418: EQUAL
16419: IFFALSE 16436
// bpoints := bpoints * 1.1 ;
16421: LD_ADDR_VAR 0 10
16425: PUSH
16426: LD_VAR 0 10
16430: PUSH
16431: LD_REAL  1.10000000000000E+0000
16434: MUL
16435: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16436: LD_ADDR_VAR 0 10
16440: PUSH
16441: LD_VAR 0 10
16445: PUSH
16446: LD_VAR 0 6
16450: PPUSH
16451: LD_INT 1
16453: PPUSH
16454: CALL_OW 259
16458: PUSH
16459: LD_REAL  1.15000000000000E+0000
16462: MUL
16463: MUL
16464: ST_TO_ADDR
// end ; unit_vehicle :
16465: GO 17289
16467: LD_INT 2
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 17277
16475: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16476: LD_VAR 0 6
16480: PPUSH
16481: CALL_OW 264
16485: PUSH
16486: LD_INT 2
16488: PUSH
16489: LD_INT 42
16491: PUSH
16492: LD_INT 24
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: IFFALSE 16521
// points := [ 25 , 5 , 3 ] ;
16502: LD_ADDR_VAR 0 9
16506: PUSH
16507: LD_INT 25
16509: PUSH
16510: LD_INT 5
16512: PUSH
16513: LD_INT 3
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: LIST
16520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16521: LD_VAR 0 6
16525: PPUSH
16526: CALL_OW 264
16530: PUSH
16531: LD_INT 4
16533: PUSH
16534: LD_INT 43
16536: PUSH
16537: LD_INT 25
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: LIST
16544: IN
16545: IFFALSE 16566
// points := [ 40 , 15 , 5 ] ;
16547: LD_ADDR_VAR 0 9
16551: PUSH
16552: LD_INT 40
16554: PUSH
16555: LD_INT 15
16557: PUSH
16558: LD_INT 5
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16566: LD_VAR 0 6
16570: PPUSH
16571: CALL_OW 264
16575: PUSH
16576: LD_INT 3
16578: PUSH
16579: LD_INT 23
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: IN
16586: IFFALSE 16607
// points := [ 7 , 25 , 8 ] ;
16588: LD_ADDR_VAR 0 9
16592: PUSH
16593: LD_INT 7
16595: PUSH
16596: LD_INT 25
16598: PUSH
16599: LD_INT 8
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16607: LD_VAR 0 6
16611: PPUSH
16612: CALL_OW 264
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: LD_INT 27
16622: PUSH
16623: LD_INT 44
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: LIST
16630: IN
16631: IFFALSE 16652
// points := [ 14 , 50 , 16 ] ;
16633: LD_ADDR_VAR 0 9
16637: PUSH
16638: LD_INT 14
16640: PUSH
16641: LD_INT 50
16643: PUSH
16644: LD_INT 16
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16652: LD_VAR 0 6
16656: PPUSH
16657: CALL_OW 264
16661: PUSH
16662: LD_INT 6
16664: PUSH
16665: LD_INT 46
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: IN
16672: IFFALSE 16693
// points := [ 32 , 120 , 70 ] ;
16674: LD_ADDR_VAR 0 9
16678: PUSH
16679: LD_INT 32
16681: PUSH
16682: LD_INT 120
16684: PUSH
16685: LD_INT 70
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16693: LD_VAR 0 6
16697: PPUSH
16698: CALL_OW 264
16702: PUSH
16703: LD_INT 7
16705: PUSH
16706: LD_INT 28
16708: PUSH
16709: LD_INT 45
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: LIST
16716: IN
16717: IFFALSE 16738
// points := [ 35 , 20 , 45 ] ;
16719: LD_ADDR_VAR 0 9
16723: PUSH
16724: LD_INT 35
16726: PUSH
16727: LD_INT 20
16729: PUSH
16730: LD_INT 45
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16738: LD_VAR 0 6
16742: PPUSH
16743: CALL_OW 264
16747: PUSH
16748: LD_INT 47
16750: PUSH
16751: EMPTY
16752: LIST
16753: IN
16754: IFFALSE 16775
// points := [ 67 , 45 , 75 ] ;
16756: LD_ADDR_VAR 0 9
16760: PUSH
16761: LD_INT 67
16763: PUSH
16764: LD_INT 45
16766: PUSH
16767: LD_INT 75
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: LIST
16774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16775: LD_VAR 0 6
16779: PPUSH
16780: CALL_OW 264
16784: PUSH
16785: LD_INT 26
16787: PUSH
16788: EMPTY
16789: LIST
16790: IN
16791: IFFALSE 16812
// points := [ 120 , 30 , 80 ] ;
16793: LD_ADDR_VAR 0 9
16797: PUSH
16798: LD_INT 120
16800: PUSH
16801: LD_INT 30
16803: PUSH
16804: LD_INT 80
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16812: LD_VAR 0 6
16816: PPUSH
16817: CALL_OW 264
16821: PUSH
16822: LD_INT 22
16824: PUSH
16825: EMPTY
16826: LIST
16827: IN
16828: IFFALSE 16849
// points := [ 40 , 1 , 1 ] ;
16830: LD_ADDR_VAR 0 9
16834: PUSH
16835: LD_INT 40
16837: PUSH
16838: LD_INT 1
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16849: LD_VAR 0 6
16853: PPUSH
16854: CALL_OW 264
16858: PUSH
16859: LD_INT 29
16861: PUSH
16862: EMPTY
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 70 , 200 , 400 ] ;
16867: LD_ADDR_VAR 0 9
16871: PUSH
16872: LD_INT 70
16874: PUSH
16875: LD_INT 200
16877: PUSH
16878: LD_INT 400
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16886: LD_VAR 0 6
16890: PPUSH
16891: CALL_OW 264
16895: PUSH
16896: LD_INT 14
16898: PUSH
16899: LD_INT 53
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: IN
16906: IFFALSE 16927
// points := [ 40 , 10 , 20 ] ;
16908: LD_ADDR_VAR 0 9
16912: PUSH
16913: LD_INT 40
16915: PUSH
16916: LD_INT 10
16918: PUSH
16919: LD_INT 20
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16927: LD_VAR 0 6
16931: PPUSH
16932: CALL_OW 264
16936: PUSH
16937: LD_INT 9
16939: PUSH
16940: EMPTY
16941: LIST
16942: IN
16943: IFFALSE 16964
// points := [ 5 , 70 , 20 ] ;
16945: LD_ADDR_VAR 0 9
16949: PUSH
16950: LD_INT 5
16952: PUSH
16953: LD_INT 70
16955: PUSH
16956: LD_INT 20
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16964: LD_VAR 0 6
16968: PPUSH
16969: CALL_OW 264
16973: PUSH
16974: LD_INT 10
16976: PUSH
16977: EMPTY
16978: LIST
16979: IN
16980: IFFALSE 17001
// points := [ 35 , 110 , 70 ] ;
16982: LD_ADDR_VAR 0 9
16986: PUSH
16987: LD_INT 35
16989: PUSH
16990: LD_INT 110
16992: PUSH
16993: LD_INT 70
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17001: LD_VAR 0 6
17005: PPUSH
17006: CALL_OW 265
17010: PUSH
17011: LD_INT 25
17013: EQUAL
17014: IFFALSE 17035
// points := [ 80 , 65 , 100 ] ;
17016: LD_ADDR_VAR 0 9
17020: PUSH
17021: LD_INT 80
17023: PUSH
17024: LD_INT 65
17026: PUSH
17027: LD_INT 100
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17035: LD_VAR 0 6
17039: PPUSH
17040: CALL_OW 263
17044: PUSH
17045: LD_INT 1
17047: EQUAL
17048: IFFALSE 17083
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17050: LD_ADDR_VAR 0 10
17054: PUSH
17055: LD_VAR 0 10
17059: PUSH
17060: LD_VAR 0 6
17064: PPUSH
17065: CALL_OW 311
17069: PPUSH
17070: LD_INT 3
17072: PPUSH
17073: CALL_OW 259
17077: PUSH
17078: LD_INT 4
17080: MUL
17081: MUL
17082: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 263
17092: PUSH
17093: LD_INT 2
17095: EQUAL
17096: IFFALSE 17147
// begin j := IsControledBy ( i ) ;
17098: LD_ADDR_VAR 0 7
17102: PUSH
17103: LD_VAR 0 6
17107: PPUSH
17108: CALL_OW 312
17112: ST_TO_ADDR
// if j then
17113: LD_VAR 0 7
17117: IFFALSE 17147
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17119: LD_ADDR_VAR 0 10
17123: PUSH
17124: LD_VAR 0 10
17128: PUSH
17129: LD_VAR 0 7
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: CALL_OW 259
17141: PUSH
17142: LD_INT 3
17144: MUL
17145: MUL
17146: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17147: LD_VAR 0 6
17151: PPUSH
17152: CALL_OW 264
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: LD_INT 46
17165: PUSH
17166: LD_INT 44
17168: PUSH
17169: LD_INT 47
17171: PUSH
17172: LD_INT 45
17174: PUSH
17175: LD_INT 28
17177: PUSH
17178: LD_INT 7
17180: PUSH
17181: LD_INT 27
17183: PUSH
17184: LD_INT 29
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: IN
17199: PUSH
17200: LD_VAR 0 1
17204: PPUSH
17205: LD_INT 52
17207: PPUSH
17208: CALL_OW 321
17212: PUSH
17213: LD_INT 2
17215: EQUAL
17216: AND
17217: IFFALSE 17234
// bpoints := bpoints * 1.2 ;
17219: LD_ADDR_VAR 0 10
17223: PUSH
17224: LD_VAR 0 10
17228: PUSH
17229: LD_REAL  1.20000000000000E+0000
17232: MUL
17233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17234: LD_VAR 0 6
17238: PPUSH
17239: CALL_OW 264
17243: PUSH
17244: LD_INT 6
17246: PUSH
17247: LD_INT 46
17249: PUSH
17250: LD_INT 47
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: IN
17258: IFFALSE 17275
// bpoints := bpoints * 1.2 ;
17260: LD_ADDR_VAR 0 10
17264: PUSH
17265: LD_VAR 0 10
17269: PUSH
17270: LD_REAL  1.20000000000000E+0000
17273: MUL
17274: ST_TO_ADDR
// end ; unit_building :
17275: GO 17289
17277: LD_INT 3
17279: DOUBLE
17280: EQUAL
17281: IFTRUE 17285
17283: GO 17288
17285: POP
// ; end ;
17286: GO 17289
17288: POP
// for j = 1 to 3 do
17289: LD_ADDR_VAR 0 7
17293: PUSH
17294: DOUBLE
17295: LD_INT 1
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 3
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17356
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17305: LD_ADDR_VAR 0 5
17309: PUSH
17310: LD_VAR 0 5
17314: PPUSH
17315: LD_VAR 0 7
17319: PPUSH
17320: LD_VAR 0 5
17324: PUSH
17325: LD_VAR 0 7
17329: ARRAY
17330: PUSH
17331: LD_VAR 0 9
17335: PUSH
17336: LD_VAR 0 7
17340: ARRAY
17341: PUSH
17342: LD_VAR 0 10
17346: MUL
17347: PLUS
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
17354: GO 17302
17356: POP
17357: POP
// end ;
17358: GO 15841
17360: POP
17361: POP
// result := Replace ( result , 4 , tmp ) ;
17362: LD_ADDR_VAR 0 5
17366: PUSH
17367: LD_VAR 0 5
17371: PPUSH
17372: LD_INT 4
17374: PPUSH
17375: LD_VAR 0 8
17379: PPUSH
17380: CALL_OW 1
17384: ST_TO_ADDR
// end ;
17385: LD_VAR 0 5
17389: RET
// export function DangerAtRange ( unit , range ) ; begin
17390: LD_INT 0
17392: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17393: LD_ADDR_VAR 0 3
17397: PUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL_OW 255
17407: PPUSH
17408: LD_VAR 0 1
17412: PPUSH
17413: CALL_OW 250
17417: PPUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: CALL_OW 251
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL 15693 0 4
17437: ST_TO_ADDR
// end ;
17438: LD_VAR 0 3
17442: RET
// export function DangerInArea ( side , area ) ; begin
17443: LD_INT 0
17445: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17446: LD_ADDR_VAR 0 3
17450: PUSH
17451: LD_VAR 0 2
17455: PPUSH
17456: LD_INT 81
17458: PUSH
17459: LD_VAR 0 1
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PPUSH
17468: CALL_OW 70
17472: ST_TO_ADDR
// end ;
17473: LD_VAR 0 3
17477: RET
// export function IsExtension ( b ) ; begin
17478: LD_INT 0
17480: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17481: LD_ADDR_VAR 0 2
17485: PUSH
17486: LD_VAR 0 1
17490: PUSH
17491: LD_INT 23
17493: PUSH
17494: LD_INT 20
17496: PUSH
17497: LD_INT 22
17499: PUSH
17500: LD_INT 17
17502: PUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 21
17508: PUSH
17509: LD_INT 19
17511: PUSH
17512: LD_INT 16
17514: PUSH
17515: LD_INT 25
17517: PUSH
17518: LD_INT 18
17520: PUSH
17521: EMPTY
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: IN
17533: ST_TO_ADDR
// end ;
17534: LD_VAR 0 2
17538: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
17543: PPUSH
// result := [ ] ;
17544: LD_ADDR_VAR 0 4
17548: PUSH
17549: EMPTY
17550: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17551: LD_ADDR_VAR 0 5
17555: PUSH
17556: LD_VAR 0 2
17560: PPUSH
17561: LD_INT 21
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: CALL_OW 70
17575: ST_TO_ADDR
// if not tmp then
17576: LD_VAR 0 5
17580: NOT
17581: IFFALSE 17585
// exit ;
17583: GO 17649
// if checkLink then
17585: LD_VAR 0 3
17589: IFFALSE 17639
// begin for i in tmp do
17591: LD_ADDR_VAR 0 6
17595: PUSH
17596: LD_VAR 0 5
17600: PUSH
17601: FOR_IN
17602: IFFALSE 17637
// if GetBase ( i ) <> base then
17604: LD_VAR 0 6
17608: PPUSH
17609: CALL_OW 274
17613: PUSH
17614: LD_VAR 0 1
17618: NONEQUAL
17619: IFFALSE 17635
// ComLinkToBase ( base , i ) ;
17621: LD_VAR 0 1
17625: PPUSH
17626: LD_VAR 0 6
17630: PPUSH
17631: CALL_OW 169
17635: GO 17601
17637: POP
17638: POP
// end ; result := tmp ;
17639: LD_ADDR_VAR 0 4
17643: PUSH
17644: LD_VAR 0 5
17648: ST_TO_ADDR
// end ;
17649: LD_VAR 0 4
17653: RET
// export function ComComplete ( units , b ) ; var i ; begin
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// if not units then
17658: LD_VAR 0 1
17662: NOT
17663: IFFALSE 17667
// exit ;
17665: GO 17757
// for i in units do
17667: LD_ADDR_VAR 0 4
17671: PUSH
17672: LD_VAR 0 1
17676: PUSH
17677: FOR_IN
17678: IFFALSE 17755
// if BuildingStatus ( b ) = bs_build then
17680: LD_VAR 0 2
17684: PPUSH
17685: CALL_OW 461
17689: PUSH
17690: LD_INT 1
17692: EQUAL
17693: IFFALSE 17753
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17695: LD_VAR 0 4
17699: PPUSH
17700: LD_STRING h
17702: PUSH
17703: LD_VAR 0 2
17707: PPUSH
17708: CALL_OW 250
17712: PUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL_OW 251
17722: PUSH
17723: LD_VAR 0 2
17727: PUSH
17728: LD_INT 0
17730: PUSH
17731: LD_INT 0
17733: PUSH
17734: LD_INT 0
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: LIST
17741: LIST
17742: LIST
17743: LIST
17744: LIST
17745: PUSH
17746: EMPTY
17747: LIST
17748: PPUSH
17749: CALL_OW 446
17753: GO 17677
17755: POP
17756: POP
// end ;
17757: LD_VAR 0 3
17761: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17762: LD_INT 0
17764: PPUSH
17765: PPUSH
17766: PPUSH
17767: PPUSH
17768: PPUSH
17769: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17770: LD_VAR 0 1
17774: NOT
17775: PUSH
17776: LD_VAR 0 1
17780: PPUSH
17781: CALL_OW 263
17785: PUSH
17786: LD_INT 2
17788: EQUAL
17789: NOT
17790: OR
17791: IFFALSE 17795
// exit ;
17793: GO 18111
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17795: LD_ADDR_VAR 0 6
17799: PUSH
17800: LD_INT 22
17802: PUSH
17803: LD_VAR 0 1
17807: PPUSH
17808: CALL_OW 255
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: PUSH
17817: LD_INT 2
17819: PUSH
17820: LD_INT 30
17822: PUSH
17823: LD_INT 36
17825: PUSH
17826: EMPTY
17827: LIST
17828: LIST
17829: PUSH
17830: LD_INT 34
17832: PUSH
17833: LD_INT 31
17835: PUSH
17836: EMPTY
17837: LIST
17838: LIST
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: PPUSH
17849: CALL_OW 69
17853: ST_TO_ADDR
// if not tmp then
17854: LD_VAR 0 6
17858: NOT
17859: IFFALSE 17863
// exit ;
17861: GO 18111
// result := [ ] ;
17863: LD_ADDR_VAR 0 2
17867: PUSH
17868: EMPTY
17869: ST_TO_ADDR
// for i in tmp do
17870: LD_ADDR_VAR 0 3
17874: PUSH
17875: LD_VAR 0 6
17879: PUSH
17880: FOR_IN
17881: IFFALSE 17952
// begin t := UnitsInside ( i ) ;
17883: LD_ADDR_VAR 0 4
17887: PUSH
17888: LD_VAR 0 3
17892: PPUSH
17893: CALL_OW 313
17897: ST_TO_ADDR
// if t then
17898: LD_VAR 0 4
17902: IFFALSE 17950
// for j in t do
17904: LD_ADDR_VAR 0 7
17908: PUSH
17909: LD_VAR 0 4
17913: PUSH
17914: FOR_IN
17915: IFFALSE 17948
// result := Insert ( result , result + 1 , j ) ;
17917: LD_ADDR_VAR 0 2
17921: PUSH
17922: LD_VAR 0 2
17926: PPUSH
17927: LD_VAR 0 2
17931: PUSH
17932: LD_INT 1
17934: PLUS
17935: PPUSH
17936: LD_VAR 0 7
17940: PPUSH
17941: CALL_OW 2
17945: ST_TO_ADDR
17946: GO 17914
17948: POP
17949: POP
// end ;
17950: GO 17880
17952: POP
17953: POP
// if not result then
17954: LD_VAR 0 2
17958: NOT
17959: IFFALSE 17963
// exit ;
17961: GO 18111
// mech := result [ 1 ] ;
17963: LD_ADDR_VAR 0 5
17967: PUSH
17968: LD_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ARRAY
17976: ST_TO_ADDR
// if result > 1 then
17977: LD_VAR 0 2
17981: PUSH
17982: LD_INT 1
17984: GREATER
17985: IFFALSE 18097
// for i = 2 to result do
17987: LD_ADDR_VAR 0 3
17991: PUSH
17992: DOUBLE
17993: LD_INT 2
17995: DEC
17996: ST_TO_ADDR
17997: LD_VAR 0 2
18001: PUSH
18002: FOR_TO
18003: IFFALSE 18095
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18005: LD_ADDR_VAR 0 4
18009: PUSH
18010: LD_VAR 0 2
18014: PUSH
18015: LD_VAR 0 3
18019: ARRAY
18020: PPUSH
18021: LD_INT 3
18023: PPUSH
18024: CALL_OW 259
18028: PUSH
18029: LD_VAR 0 2
18033: PUSH
18034: LD_VAR 0 3
18038: ARRAY
18039: PPUSH
18040: CALL_OW 432
18044: MINUS
18045: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18046: LD_VAR 0 4
18050: PUSH
18051: LD_VAR 0 5
18055: PPUSH
18056: LD_INT 3
18058: PPUSH
18059: CALL_OW 259
18063: PUSH
18064: LD_VAR 0 5
18068: PPUSH
18069: CALL_OW 432
18073: MINUS
18074: GREATEREQUAL
18075: IFFALSE 18093
// mech := result [ i ] ;
18077: LD_ADDR_VAR 0 5
18081: PUSH
18082: LD_VAR 0 2
18086: PUSH
18087: LD_VAR 0 3
18091: ARRAY
18092: ST_TO_ADDR
// end ;
18093: GO 18002
18095: POP
18096: POP
// ComLinkTo ( vehicle , mech ) ;
18097: LD_VAR 0 1
18101: PPUSH
18102: LD_VAR 0 5
18106: PPUSH
18107: CALL_OW 135
// end ;
18111: LD_VAR 0 2
18115: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18116: LD_INT 0
18118: PPUSH
18119: PPUSH
18120: PPUSH
18121: PPUSH
18122: PPUSH
18123: PPUSH
18124: PPUSH
18125: PPUSH
18126: PPUSH
18127: PPUSH
18128: PPUSH
18129: PPUSH
18130: PPUSH
// result := [ ] ;
18131: LD_ADDR_VAR 0 7
18135: PUSH
18136: EMPTY
18137: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18138: LD_VAR 0 1
18142: PPUSH
18143: CALL_OW 266
18147: PUSH
18148: LD_INT 0
18150: PUSH
18151: LD_INT 1
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: IN
18158: NOT
18159: IFFALSE 18163
// exit ;
18161: GO 19797
// if name then
18163: LD_VAR 0 3
18167: IFFALSE 18183
// SetBName ( base_dep , name ) ;
18169: LD_VAR 0 1
18173: PPUSH
18174: LD_VAR 0 3
18178: PPUSH
18179: CALL_OW 500
// base := GetBase ( base_dep ) ;
18183: LD_ADDR_VAR 0 15
18187: PUSH
18188: LD_VAR 0 1
18192: PPUSH
18193: CALL_OW 274
18197: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18198: LD_ADDR_VAR 0 16
18202: PUSH
18203: LD_VAR 0 1
18207: PPUSH
18208: CALL_OW 255
18212: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18213: LD_ADDR_VAR 0 17
18217: PUSH
18218: LD_VAR 0 1
18222: PPUSH
18223: CALL_OW 248
18227: ST_TO_ADDR
// if sources then
18228: LD_VAR 0 5
18232: IFFALSE 18279
// for i = 1 to 3 do
18234: LD_ADDR_VAR 0 8
18238: PUSH
18239: DOUBLE
18240: LD_INT 1
18242: DEC
18243: ST_TO_ADDR
18244: LD_INT 3
18246: PUSH
18247: FOR_TO
18248: IFFALSE 18277
// AddResourceType ( base , i , sources [ i ] ) ;
18250: LD_VAR 0 15
18254: PPUSH
18255: LD_VAR 0 8
18259: PPUSH
18260: LD_VAR 0 5
18264: PUSH
18265: LD_VAR 0 8
18269: ARRAY
18270: PPUSH
18271: CALL_OW 276
18275: GO 18247
18277: POP
18278: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18279: LD_ADDR_VAR 0 18
18283: PUSH
18284: LD_VAR 0 15
18288: PPUSH
18289: LD_VAR 0 2
18293: PPUSH
18294: LD_INT 1
18296: PPUSH
18297: CALL 17539 0 3
18301: ST_TO_ADDR
// InitHc ;
18302: CALL_OW 19
// InitUc ;
18306: CALL_OW 18
// uc_side := side ;
18310: LD_ADDR_OWVAR 20
18314: PUSH
18315: LD_VAR 0 16
18319: ST_TO_ADDR
// uc_nation := nation ;
18320: LD_ADDR_OWVAR 21
18324: PUSH
18325: LD_VAR 0 17
18329: ST_TO_ADDR
// if buildings then
18330: LD_VAR 0 18
18334: IFFALSE 19656
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18336: LD_ADDR_VAR 0 19
18340: PUSH
18341: LD_VAR 0 18
18345: PPUSH
18346: LD_INT 2
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 29
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 30
18361: PUSH
18362: LD_INT 30
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: LIST
18373: PPUSH
18374: CALL_OW 72
18378: ST_TO_ADDR
// if tmp then
18379: LD_VAR 0 19
18383: IFFALSE 18431
// for i in tmp do
18385: LD_ADDR_VAR 0 8
18389: PUSH
18390: LD_VAR 0 19
18394: PUSH
18395: FOR_IN
18396: IFFALSE 18429
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18398: LD_VAR 0 8
18402: PPUSH
18403: CALL_OW 250
18407: PPUSH
18408: LD_VAR 0 8
18412: PPUSH
18413: CALL_OW 251
18417: PPUSH
18418: LD_VAR 0 16
18422: PPUSH
18423: CALL_OW 441
18427: GO 18395
18429: POP
18430: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18431: LD_VAR 0 18
18435: PPUSH
18436: LD_INT 2
18438: PUSH
18439: LD_INT 30
18441: PUSH
18442: LD_INT 32
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: PUSH
18449: LD_INT 30
18451: PUSH
18452: LD_INT 33
18454: PUSH
18455: EMPTY
18456: LIST
18457: LIST
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: LIST
18463: PPUSH
18464: CALL_OW 72
18468: IFFALSE 18556
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18470: LD_ADDR_VAR 0 8
18474: PUSH
18475: LD_VAR 0 18
18479: PPUSH
18480: LD_INT 2
18482: PUSH
18483: LD_INT 30
18485: PUSH
18486: LD_INT 32
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PUSH
18493: LD_INT 30
18495: PUSH
18496: LD_INT 33
18498: PUSH
18499: EMPTY
18500: LIST
18501: LIST
18502: PUSH
18503: EMPTY
18504: LIST
18505: LIST
18506: LIST
18507: PPUSH
18508: CALL_OW 72
18512: PUSH
18513: FOR_IN
18514: IFFALSE 18554
// begin if not GetBWeapon ( i ) then
18516: LD_VAR 0 8
18520: PPUSH
18521: CALL_OW 269
18525: NOT
18526: IFFALSE 18552
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18528: LD_VAR 0 8
18532: PPUSH
18533: LD_VAR 0 8
18537: PPUSH
18538: LD_VAR 0 2
18542: PPUSH
18543: CALL 19802 0 2
18547: PPUSH
18548: CALL_OW 431
// end ;
18552: GO 18513
18554: POP
18555: POP
// end ; for i = 1 to personel do
18556: LD_ADDR_VAR 0 8
18560: PUSH
18561: DOUBLE
18562: LD_INT 1
18564: DEC
18565: ST_TO_ADDR
18566: LD_VAR 0 6
18570: PUSH
18571: FOR_TO
18572: IFFALSE 19636
// begin if i > 4 then
18574: LD_VAR 0 8
18578: PUSH
18579: LD_INT 4
18581: GREATER
18582: IFFALSE 18586
// break ;
18584: GO 19636
// case i of 1 :
18586: LD_VAR 0 8
18590: PUSH
18591: LD_INT 1
18593: DOUBLE
18594: EQUAL
18595: IFTRUE 18599
18597: GO 18679
18599: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18600: LD_ADDR_VAR 0 12
18604: PUSH
18605: LD_VAR 0 18
18609: PPUSH
18610: LD_INT 22
18612: PUSH
18613: LD_VAR 0 16
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: LD_INT 58
18624: PUSH
18625: EMPTY
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 30
18633: PUSH
18634: LD_INT 32
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 30
18643: PUSH
18644: LD_INT 4
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: LD_INT 30
18653: PUSH
18654: LD_INT 5
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: LIST
18671: PPUSH
18672: CALL_OW 72
18676: ST_TO_ADDR
18677: GO 18901
18679: LD_INT 2
18681: DOUBLE
18682: EQUAL
18683: IFTRUE 18687
18685: GO 18749
18687: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18688: LD_ADDR_VAR 0 12
18692: PUSH
18693: LD_VAR 0 18
18697: PPUSH
18698: LD_INT 22
18700: PUSH
18701: LD_VAR 0 16
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: PUSH
18710: LD_INT 2
18712: PUSH
18713: LD_INT 30
18715: PUSH
18716: LD_INT 0
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 30
18725: PUSH
18726: LD_INT 1
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: PPUSH
18742: CALL_OW 72
18746: ST_TO_ADDR
18747: GO 18901
18749: LD_INT 3
18751: DOUBLE
18752: EQUAL
18753: IFTRUE 18757
18755: GO 18819
18757: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18758: LD_ADDR_VAR 0 12
18762: PUSH
18763: LD_VAR 0 18
18767: PPUSH
18768: LD_INT 22
18770: PUSH
18771: LD_VAR 0 16
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: LD_INT 2
18782: PUSH
18783: LD_INT 30
18785: PUSH
18786: LD_INT 2
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PUSH
18793: LD_INT 30
18795: PUSH
18796: LD_INT 3
18798: PUSH
18799: EMPTY
18800: LIST
18801: LIST
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: LIST
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PPUSH
18812: CALL_OW 72
18816: ST_TO_ADDR
18817: GO 18901
18819: LD_INT 4
18821: DOUBLE
18822: EQUAL
18823: IFTRUE 18827
18825: GO 18900
18827: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18828: LD_ADDR_VAR 0 12
18832: PUSH
18833: LD_VAR 0 18
18837: PPUSH
18838: LD_INT 22
18840: PUSH
18841: LD_VAR 0 16
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: PUSH
18850: LD_INT 2
18852: PUSH
18853: LD_INT 30
18855: PUSH
18856: LD_INT 6
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 30
18865: PUSH
18866: LD_INT 7
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: PUSH
18873: LD_INT 30
18875: PUSH
18876: LD_INT 8
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: PPUSH
18893: CALL_OW 72
18897: ST_TO_ADDR
18898: GO 18901
18900: POP
// if i = 1 then
18901: LD_VAR 0 8
18905: PUSH
18906: LD_INT 1
18908: EQUAL
18909: IFFALSE 19020
// begin tmp := [ ] ;
18911: LD_ADDR_VAR 0 19
18915: PUSH
18916: EMPTY
18917: ST_TO_ADDR
// for j in f do
18918: LD_ADDR_VAR 0 9
18922: PUSH
18923: LD_VAR 0 12
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19002
// if GetBType ( j ) = b_bunker then
18931: LD_VAR 0 9
18935: PPUSH
18936: CALL_OW 266
18940: PUSH
18941: LD_INT 32
18943: EQUAL
18944: IFFALSE 18971
// tmp := Insert ( tmp , 1 , j ) else
18946: LD_ADDR_VAR 0 19
18950: PUSH
18951: LD_VAR 0 19
18955: PPUSH
18956: LD_INT 1
18958: PPUSH
18959: LD_VAR 0 9
18963: PPUSH
18964: CALL_OW 2
18968: ST_TO_ADDR
18969: GO 19000
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18971: LD_ADDR_VAR 0 19
18975: PUSH
18976: LD_VAR 0 19
18980: PPUSH
18981: LD_VAR 0 19
18985: PUSH
18986: LD_INT 1
18988: PLUS
18989: PPUSH
18990: LD_VAR 0 9
18994: PPUSH
18995: CALL_OW 2
18999: ST_TO_ADDR
19000: GO 18928
19002: POP
19003: POP
// if tmp then
19004: LD_VAR 0 19
19008: IFFALSE 19020
// f := tmp ;
19010: LD_ADDR_VAR 0 12
19014: PUSH
19015: LD_VAR 0 19
19019: ST_TO_ADDR
// end ; x := personel [ i ] ;
19020: LD_ADDR_VAR 0 13
19024: PUSH
19025: LD_VAR 0 6
19029: PUSH
19030: LD_VAR 0 8
19034: ARRAY
19035: ST_TO_ADDR
// if x = - 1 then
19036: LD_VAR 0 13
19040: PUSH
19041: LD_INT 1
19043: NEG
19044: EQUAL
19045: IFFALSE 19254
// begin for j in f do
19047: LD_ADDR_VAR 0 9
19051: PUSH
19052: LD_VAR 0 12
19056: PUSH
19057: FOR_IN
19058: IFFALSE 19250
// repeat InitHc ;
19060: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19064: LD_VAR 0 9
19068: PPUSH
19069: CALL_OW 266
19073: PUSH
19074: LD_INT 5
19076: EQUAL
19077: IFFALSE 19147
// begin if UnitsInside ( j ) < 3 then
19079: LD_VAR 0 9
19083: PPUSH
19084: CALL_OW 313
19088: PUSH
19089: LD_INT 3
19091: LESS
19092: IFFALSE 19128
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19094: LD_INT 0
19096: PPUSH
19097: LD_INT 5
19099: PUSH
19100: LD_INT 8
19102: PUSH
19103: LD_INT 9
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: LIST
19110: PUSH
19111: LD_VAR 0 17
19115: ARRAY
19116: PPUSH
19117: LD_VAR 0 4
19121: PPUSH
19122: CALL_OW 380
19126: GO 19145
// PrepareHuman ( false , i , skill ) ;
19128: LD_INT 0
19130: PPUSH
19131: LD_VAR 0 8
19135: PPUSH
19136: LD_VAR 0 4
19140: PPUSH
19141: CALL_OW 380
// end else
19145: GO 19164
// PrepareHuman ( false , i , skill ) ;
19147: LD_INT 0
19149: PPUSH
19150: LD_VAR 0 8
19154: PPUSH
19155: LD_VAR 0 4
19159: PPUSH
19160: CALL_OW 380
// un := CreateHuman ;
19164: LD_ADDR_VAR 0 14
19168: PUSH
19169: CALL_OW 44
19173: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19174: LD_ADDR_VAR 0 7
19178: PUSH
19179: LD_VAR 0 7
19183: PPUSH
19184: LD_INT 1
19186: PPUSH
19187: LD_VAR 0 14
19191: PPUSH
19192: CALL_OW 2
19196: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19197: LD_VAR 0 14
19201: PPUSH
19202: LD_VAR 0 9
19206: PPUSH
19207: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19211: LD_VAR 0 9
19215: PPUSH
19216: CALL_OW 313
19220: PUSH
19221: LD_INT 6
19223: EQUAL
19224: PUSH
19225: LD_VAR 0 9
19229: PPUSH
19230: CALL_OW 266
19234: PUSH
19235: LD_INT 32
19237: PUSH
19238: LD_INT 31
19240: PUSH
19241: EMPTY
19242: LIST
19243: LIST
19244: IN
19245: OR
19246: IFFALSE 19060
19248: GO 19057
19250: POP
19251: POP
// end else
19252: GO 19634
// for j = 1 to x do
19254: LD_ADDR_VAR 0 9
19258: PUSH
19259: DOUBLE
19260: LD_INT 1
19262: DEC
19263: ST_TO_ADDR
19264: LD_VAR 0 13
19268: PUSH
19269: FOR_TO
19270: IFFALSE 19632
// begin InitHc ;
19272: CALL_OW 19
// if not f then
19276: LD_VAR 0 12
19280: NOT
19281: IFFALSE 19370
// begin PrepareHuman ( false , i , skill ) ;
19283: LD_INT 0
19285: PPUSH
19286: LD_VAR 0 8
19290: PPUSH
19291: LD_VAR 0 4
19295: PPUSH
19296: CALL_OW 380
// un := CreateHuman ;
19300: LD_ADDR_VAR 0 14
19304: PUSH
19305: CALL_OW 44
19309: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19310: LD_ADDR_VAR 0 7
19314: PUSH
19315: LD_VAR 0 7
19319: PPUSH
19320: LD_INT 1
19322: PPUSH
19323: LD_VAR 0 14
19327: PPUSH
19328: CALL_OW 2
19332: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19333: LD_VAR 0 14
19337: PPUSH
19338: LD_VAR 0 1
19342: PPUSH
19343: CALL_OW 250
19347: PPUSH
19348: LD_VAR 0 1
19352: PPUSH
19353: CALL_OW 251
19357: PPUSH
19358: LD_INT 10
19360: PPUSH
19361: LD_INT 0
19363: PPUSH
19364: CALL_OW 50
// continue ;
19368: GO 19269
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19370: LD_VAR 0 12
19374: PUSH
19375: LD_INT 1
19377: ARRAY
19378: PPUSH
19379: CALL_OW 313
19383: PUSH
19384: LD_VAR 0 12
19388: PUSH
19389: LD_INT 1
19391: ARRAY
19392: PPUSH
19393: CALL_OW 266
19397: PUSH
19398: LD_INT 32
19400: PUSH
19401: LD_INT 31
19403: PUSH
19404: EMPTY
19405: LIST
19406: LIST
19407: IN
19408: AND
19409: PUSH
19410: LD_VAR 0 12
19414: PUSH
19415: LD_INT 1
19417: ARRAY
19418: PPUSH
19419: CALL_OW 313
19423: PUSH
19424: LD_INT 6
19426: EQUAL
19427: OR
19428: IFFALSE 19448
// f := Delete ( f , 1 ) ;
19430: LD_ADDR_VAR 0 12
19434: PUSH
19435: LD_VAR 0 12
19439: PPUSH
19440: LD_INT 1
19442: PPUSH
19443: CALL_OW 3
19447: ST_TO_ADDR
// if not f then
19448: LD_VAR 0 12
19452: NOT
19453: IFFALSE 19471
// begin x := x + 2 ;
19455: LD_ADDR_VAR 0 13
19459: PUSH
19460: LD_VAR 0 13
19464: PUSH
19465: LD_INT 2
19467: PLUS
19468: ST_TO_ADDR
// continue ;
19469: GO 19269
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19471: LD_VAR 0 12
19475: PUSH
19476: LD_INT 1
19478: ARRAY
19479: PPUSH
19480: CALL_OW 266
19484: PUSH
19485: LD_INT 5
19487: EQUAL
19488: IFFALSE 19562
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19490: LD_VAR 0 12
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PPUSH
19499: CALL_OW 313
19503: PUSH
19504: LD_INT 3
19506: LESS
19507: IFFALSE 19543
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19509: LD_INT 0
19511: PPUSH
19512: LD_INT 5
19514: PUSH
19515: LD_INT 8
19517: PUSH
19518: LD_INT 9
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: LIST
19525: PUSH
19526: LD_VAR 0 17
19530: ARRAY
19531: PPUSH
19532: LD_VAR 0 4
19536: PPUSH
19537: CALL_OW 380
19541: GO 19560
// PrepareHuman ( false , i , skill ) ;
19543: LD_INT 0
19545: PPUSH
19546: LD_VAR 0 8
19550: PPUSH
19551: LD_VAR 0 4
19555: PPUSH
19556: CALL_OW 380
// end else
19560: GO 19579
// PrepareHuman ( false , i , skill ) ;
19562: LD_INT 0
19564: PPUSH
19565: LD_VAR 0 8
19569: PPUSH
19570: LD_VAR 0 4
19574: PPUSH
19575: CALL_OW 380
// un := CreateHuman ;
19579: LD_ADDR_VAR 0 14
19583: PUSH
19584: CALL_OW 44
19588: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19589: LD_ADDR_VAR 0 7
19593: PUSH
19594: LD_VAR 0 7
19598: PPUSH
19599: LD_INT 1
19601: PPUSH
19602: LD_VAR 0 14
19606: PPUSH
19607: CALL_OW 2
19611: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19612: LD_VAR 0 14
19616: PPUSH
19617: LD_VAR 0 12
19621: PUSH
19622: LD_INT 1
19624: ARRAY
19625: PPUSH
19626: CALL_OW 52
// end ;
19630: GO 19269
19632: POP
19633: POP
// end ;
19634: GO 18571
19636: POP
19637: POP
// result := result ^ buildings ;
19638: LD_ADDR_VAR 0 7
19642: PUSH
19643: LD_VAR 0 7
19647: PUSH
19648: LD_VAR 0 18
19652: ADD
19653: ST_TO_ADDR
// end else
19654: GO 19797
// begin for i = 1 to personel do
19656: LD_ADDR_VAR 0 8
19660: PUSH
19661: DOUBLE
19662: LD_INT 1
19664: DEC
19665: ST_TO_ADDR
19666: LD_VAR 0 6
19670: PUSH
19671: FOR_TO
19672: IFFALSE 19795
// begin if i > 4 then
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 4
19681: GREATER
19682: IFFALSE 19686
// break ;
19684: GO 19795
// x := personel [ i ] ;
19686: LD_ADDR_VAR 0 13
19690: PUSH
19691: LD_VAR 0 6
19695: PUSH
19696: LD_VAR 0 8
19700: ARRAY
19701: ST_TO_ADDR
// if x = - 1 then
19702: LD_VAR 0 13
19706: PUSH
19707: LD_INT 1
19709: NEG
19710: EQUAL
19711: IFFALSE 19715
// continue ;
19713: GO 19671
// PrepareHuman ( false , i , skill ) ;
19715: LD_INT 0
19717: PPUSH
19718: LD_VAR 0 8
19722: PPUSH
19723: LD_VAR 0 4
19727: PPUSH
19728: CALL_OW 380
// un := CreateHuman ;
19732: LD_ADDR_VAR 0 14
19736: PUSH
19737: CALL_OW 44
19741: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19742: LD_VAR 0 14
19746: PPUSH
19747: LD_VAR 0 1
19751: PPUSH
19752: CALL_OW 250
19756: PPUSH
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 251
19766: PPUSH
19767: LD_INT 10
19769: PPUSH
19770: LD_INT 0
19772: PPUSH
19773: CALL_OW 50
// result := result ^ un ;
19777: LD_ADDR_VAR 0 7
19781: PUSH
19782: LD_VAR 0 7
19786: PUSH
19787: LD_VAR 0 14
19791: ADD
19792: ST_TO_ADDR
// end ;
19793: GO 19671
19795: POP
19796: POP
// end ; end ;
19797: LD_VAR 0 7
19801: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19802: LD_INT 0
19804: PPUSH
19805: PPUSH
19806: PPUSH
19807: PPUSH
19808: PPUSH
19809: PPUSH
19810: PPUSH
19811: PPUSH
19812: PPUSH
19813: PPUSH
19814: PPUSH
19815: PPUSH
19816: PPUSH
19817: PPUSH
19818: PPUSH
19819: PPUSH
// result := false ;
19820: LD_ADDR_VAR 0 3
19824: PUSH
19825: LD_INT 0
19827: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19828: LD_VAR 0 1
19832: NOT
19833: PUSH
19834: LD_VAR 0 1
19838: PPUSH
19839: CALL_OW 266
19843: PUSH
19844: LD_INT 32
19846: PUSH
19847: LD_INT 33
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: IN
19854: NOT
19855: OR
19856: IFFALSE 19860
// exit ;
19858: GO 20999
// nat := GetNation ( tower ) ;
19860: LD_ADDR_VAR 0 12
19864: PUSH
19865: LD_VAR 0 1
19869: PPUSH
19870: CALL_OW 248
19874: ST_TO_ADDR
// side := GetSide ( tower ) ;
19875: LD_ADDR_VAR 0 16
19879: PUSH
19880: LD_VAR 0 1
19884: PPUSH
19885: CALL_OW 255
19889: ST_TO_ADDR
// x := GetX ( tower ) ;
19890: LD_ADDR_VAR 0 10
19894: PUSH
19895: LD_VAR 0 1
19899: PPUSH
19900: CALL_OW 250
19904: ST_TO_ADDR
// y := GetY ( tower ) ;
19905: LD_ADDR_VAR 0 11
19909: PUSH
19910: LD_VAR 0 1
19914: PPUSH
19915: CALL_OW 251
19919: ST_TO_ADDR
// if not x or not y then
19920: LD_VAR 0 10
19924: NOT
19925: PUSH
19926: LD_VAR 0 11
19930: NOT
19931: OR
19932: IFFALSE 19936
// exit ;
19934: GO 20999
// weapon := 0 ;
19936: LD_ADDR_VAR 0 18
19940: PUSH
19941: LD_INT 0
19943: ST_TO_ADDR
// fac_list := [ ] ;
19944: LD_ADDR_VAR 0 17
19948: PUSH
19949: EMPTY
19950: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19951: LD_ADDR_VAR 0 6
19955: PUSH
19956: LD_VAR 0 1
19960: PPUSH
19961: CALL_OW 274
19965: PPUSH
19966: LD_VAR 0 2
19970: PPUSH
19971: LD_INT 0
19973: PPUSH
19974: CALL 17539 0 3
19978: PPUSH
19979: LD_INT 30
19981: PUSH
19982: LD_INT 3
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: PPUSH
19989: CALL_OW 72
19993: ST_TO_ADDR
// if not factories then
19994: LD_VAR 0 6
19998: NOT
19999: IFFALSE 20003
// exit ;
20001: GO 20999
// for i in factories do
20003: LD_ADDR_VAR 0 8
20007: PUSH
20008: LD_VAR 0 6
20012: PUSH
20013: FOR_IN
20014: IFFALSE 20039
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20016: LD_ADDR_VAR 0 17
20020: PUSH
20021: LD_VAR 0 17
20025: PUSH
20026: LD_VAR 0 8
20030: PPUSH
20031: CALL_OW 478
20035: UNION
20036: ST_TO_ADDR
20037: GO 20013
20039: POP
20040: POP
// if not fac_list then
20041: LD_VAR 0 17
20045: NOT
20046: IFFALSE 20050
// exit ;
20048: GO 20999
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20050: LD_ADDR_VAR 0 5
20054: PUSH
20055: LD_INT 4
20057: PUSH
20058: LD_INT 5
20060: PUSH
20061: LD_INT 9
20063: PUSH
20064: LD_INT 10
20066: PUSH
20067: LD_INT 6
20069: PUSH
20070: LD_INT 7
20072: PUSH
20073: LD_INT 11
20075: PUSH
20076: EMPTY
20077: LIST
20078: LIST
20079: LIST
20080: LIST
20081: LIST
20082: LIST
20083: LIST
20084: PUSH
20085: LD_INT 27
20087: PUSH
20088: LD_INT 28
20090: PUSH
20091: LD_INT 26
20093: PUSH
20094: LD_INT 30
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: PUSH
20103: LD_INT 43
20105: PUSH
20106: LD_INT 44
20108: PUSH
20109: LD_INT 46
20111: PUSH
20112: LD_INT 45
20114: PUSH
20115: LD_INT 47
20117: PUSH
20118: LD_INT 49
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: LIST
20133: PUSH
20134: LD_VAR 0 12
20138: ARRAY
20139: ST_TO_ADDR
// for i in list do
20140: LD_ADDR_VAR 0 8
20144: PUSH
20145: LD_VAR 0 5
20149: PUSH
20150: FOR_IN
20151: IFFALSE 20184
// if not i in fac_list then
20153: LD_VAR 0 8
20157: PUSH
20158: LD_VAR 0 17
20162: IN
20163: NOT
20164: IFFALSE 20182
// list := list diff i ;
20166: LD_ADDR_VAR 0 5
20170: PUSH
20171: LD_VAR 0 5
20175: PUSH
20176: LD_VAR 0 8
20180: DIFF
20181: ST_TO_ADDR
20182: GO 20150
20184: POP
20185: POP
// if not list then
20186: LD_VAR 0 5
20190: NOT
20191: IFFALSE 20195
// exit ;
20193: GO 20999
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20195: LD_VAR 0 12
20199: PUSH
20200: LD_INT 3
20202: EQUAL
20203: PUSH
20204: LD_INT 49
20206: PUSH
20207: LD_VAR 0 5
20211: IN
20212: AND
20213: PUSH
20214: LD_INT 31
20216: PPUSH
20217: LD_VAR 0 16
20221: PPUSH
20222: CALL_OW 321
20226: PUSH
20227: LD_INT 2
20229: EQUAL
20230: AND
20231: IFFALSE 20291
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20233: LD_INT 22
20235: PUSH
20236: LD_VAR 0 16
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: LD_INT 35
20247: PUSH
20248: LD_INT 49
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PUSH
20255: LD_INT 91
20257: PUSH
20258: LD_VAR 0 1
20262: PUSH
20263: LD_INT 10
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: LIST
20270: PUSH
20271: EMPTY
20272: LIST
20273: LIST
20274: LIST
20275: PPUSH
20276: CALL_OW 69
20280: NOT
20281: IFFALSE 20291
// weapon := ru_time_lapser ;
20283: LD_ADDR_VAR 0 18
20287: PUSH
20288: LD_INT 49
20290: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20291: LD_VAR 0 12
20295: PUSH
20296: LD_INT 1
20298: PUSH
20299: LD_INT 2
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: IN
20306: PUSH
20307: LD_INT 11
20309: PUSH
20310: LD_VAR 0 5
20314: IN
20315: PUSH
20316: LD_INT 30
20318: PUSH
20319: LD_VAR 0 5
20323: IN
20324: OR
20325: AND
20326: PUSH
20327: LD_INT 6
20329: PPUSH
20330: LD_VAR 0 16
20334: PPUSH
20335: CALL_OW 321
20339: PUSH
20340: LD_INT 2
20342: EQUAL
20343: AND
20344: IFFALSE 20509
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20346: LD_INT 22
20348: PUSH
20349: LD_VAR 0 16
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 2
20360: PUSH
20361: LD_INT 35
20363: PUSH
20364: LD_INT 11
20366: PUSH
20367: EMPTY
20368: LIST
20369: LIST
20370: PUSH
20371: LD_INT 35
20373: PUSH
20374: LD_INT 30
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PUSH
20381: EMPTY
20382: LIST
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 91
20388: PUSH
20389: LD_VAR 0 1
20393: PUSH
20394: LD_INT 18
20396: PUSH
20397: EMPTY
20398: LIST
20399: LIST
20400: LIST
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: LIST
20406: PPUSH
20407: CALL_OW 69
20411: NOT
20412: PUSH
20413: LD_INT 22
20415: PUSH
20416: LD_VAR 0 16
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PUSH
20425: LD_INT 2
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: LD_INT 32
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 30
20440: PUSH
20441: LD_INT 33
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 91
20455: PUSH
20456: LD_VAR 0 1
20460: PUSH
20461: LD_INT 12
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: PUSH
20474: EMPTY
20475: LIST
20476: PPUSH
20477: CALL_OW 69
20481: PUSH
20482: LD_INT 2
20484: GREATER
20485: AND
20486: IFFALSE 20509
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20488: LD_ADDR_VAR 0 18
20492: PUSH
20493: LD_INT 11
20495: PUSH
20496: LD_INT 30
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: LD_VAR 0 12
20507: ARRAY
20508: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20509: LD_VAR 0 18
20513: NOT
20514: PUSH
20515: LD_INT 40
20517: PPUSH
20518: LD_VAR 0 16
20522: PPUSH
20523: CALL_OW 321
20527: PUSH
20528: LD_INT 2
20530: EQUAL
20531: AND
20532: PUSH
20533: LD_INT 7
20535: PUSH
20536: LD_VAR 0 5
20540: IN
20541: PUSH
20542: LD_INT 28
20544: PUSH
20545: LD_VAR 0 5
20549: IN
20550: OR
20551: PUSH
20552: LD_INT 45
20554: PUSH
20555: LD_VAR 0 5
20559: IN
20560: OR
20561: AND
20562: IFFALSE 20816
// begin hex := GetHexInfo ( x , y ) ;
20564: LD_ADDR_VAR 0 4
20568: PUSH
20569: LD_VAR 0 10
20573: PPUSH
20574: LD_VAR 0 11
20578: PPUSH
20579: CALL_OW 546
20583: ST_TO_ADDR
// if hex [ 1 ] then
20584: LD_VAR 0 4
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: IFFALSE 20596
// exit ;
20594: GO 20999
// height := hex [ 2 ] ;
20596: LD_ADDR_VAR 0 15
20600: PUSH
20601: LD_VAR 0 4
20605: PUSH
20606: LD_INT 2
20608: ARRAY
20609: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20610: LD_ADDR_VAR 0 14
20614: PUSH
20615: LD_INT 0
20617: PUSH
20618: LD_INT 2
20620: PUSH
20621: LD_INT 3
20623: PUSH
20624: LD_INT 5
20626: PUSH
20627: EMPTY
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: ST_TO_ADDR
// for i in tmp do
20633: LD_ADDR_VAR 0 8
20637: PUSH
20638: LD_VAR 0 14
20642: PUSH
20643: FOR_IN
20644: IFFALSE 20814
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20646: LD_ADDR_VAR 0 9
20650: PUSH
20651: LD_VAR 0 10
20655: PPUSH
20656: LD_VAR 0 8
20660: PPUSH
20661: LD_INT 5
20663: PPUSH
20664: CALL_OW 272
20668: PUSH
20669: LD_VAR 0 11
20673: PPUSH
20674: LD_VAR 0 8
20678: PPUSH
20679: LD_INT 5
20681: PPUSH
20682: CALL_OW 273
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20691: LD_VAR 0 9
20695: PUSH
20696: LD_INT 1
20698: ARRAY
20699: PPUSH
20700: LD_VAR 0 9
20704: PUSH
20705: LD_INT 2
20707: ARRAY
20708: PPUSH
20709: CALL_OW 488
20713: IFFALSE 20812
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 9
20724: PUSH
20725: LD_INT 1
20727: ARRAY
20728: PPUSH
20729: LD_VAR 0 9
20733: PUSH
20734: LD_INT 2
20736: ARRAY
20737: PPUSH
20738: CALL_OW 546
20742: ST_TO_ADDR
// if hex [ 1 ] then
20743: LD_VAR 0 4
20747: PUSH
20748: LD_INT 1
20750: ARRAY
20751: IFFALSE 20755
// continue ;
20753: GO 20643
// h := hex [ 2 ] ;
20755: LD_ADDR_VAR 0 13
20759: PUSH
20760: LD_VAR 0 4
20764: PUSH
20765: LD_INT 2
20767: ARRAY
20768: ST_TO_ADDR
// if h + 7 < height then
20769: LD_VAR 0 13
20773: PUSH
20774: LD_INT 7
20776: PLUS
20777: PUSH
20778: LD_VAR 0 15
20782: LESS
20783: IFFALSE 20812
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20785: LD_ADDR_VAR 0 18
20789: PUSH
20790: LD_INT 7
20792: PUSH
20793: LD_INT 28
20795: PUSH
20796: LD_INT 45
20798: PUSH
20799: EMPTY
20800: LIST
20801: LIST
20802: LIST
20803: PUSH
20804: LD_VAR 0 12
20808: ARRAY
20809: ST_TO_ADDR
// break ;
20810: GO 20814
// end ; end ; end ;
20812: GO 20643
20814: POP
20815: POP
// end ; if not weapon then
20816: LD_VAR 0 18
20820: NOT
20821: IFFALSE 20881
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20823: LD_ADDR_VAR 0 5
20827: PUSH
20828: LD_VAR 0 5
20832: PUSH
20833: LD_INT 11
20835: PUSH
20836: LD_INT 30
20838: PUSH
20839: LD_INT 49
20841: PUSH
20842: EMPTY
20843: LIST
20844: LIST
20845: LIST
20846: DIFF
20847: ST_TO_ADDR
// if not list then
20848: LD_VAR 0 5
20852: NOT
20853: IFFALSE 20857
// exit ;
20855: GO 20999
// weapon := list [ rand ( 1 , list ) ] ;
20857: LD_ADDR_VAR 0 18
20861: PUSH
20862: LD_VAR 0 5
20866: PUSH
20867: LD_INT 1
20869: PPUSH
20870: LD_VAR 0 5
20874: PPUSH
20875: CALL_OW 12
20879: ARRAY
20880: ST_TO_ADDR
// end ; if weapon then
20881: LD_VAR 0 18
20885: IFFALSE 20999
// begin tmp := CostOfWeapon ( weapon ) ;
20887: LD_ADDR_VAR 0 14
20891: PUSH
20892: LD_VAR 0 18
20896: PPUSH
20897: CALL_OW 451
20901: ST_TO_ADDR
// j := GetBase ( tower ) ;
20902: LD_ADDR_VAR 0 9
20906: PUSH
20907: LD_VAR 0 1
20911: PPUSH
20912: CALL_OW 274
20916: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20917: LD_VAR 0 9
20921: PPUSH
20922: LD_INT 1
20924: PPUSH
20925: CALL_OW 275
20929: PUSH
20930: LD_VAR 0 14
20934: PUSH
20935: LD_INT 1
20937: ARRAY
20938: GREATEREQUAL
20939: PUSH
20940: LD_VAR 0 9
20944: PPUSH
20945: LD_INT 2
20947: PPUSH
20948: CALL_OW 275
20952: PUSH
20953: LD_VAR 0 14
20957: PUSH
20958: LD_INT 2
20960: ARRAY
20961: GREATEREQUAL
20962: AND
20963: PUSH
20964: LD_VAR 0 9
20968: PPUSH
20969: LD_INT 3
20971: PPUSH
20972: CALL_OW 275
20976: PUSH
20977: LD_VAR 0 14
20981: PUSH
20982: LD_INT 3
20984: ARRAY
20985: GREATEREQUAL
20986: AND
20987: IFFALSE 20999
// result := weapon ;
20989: LD_ADDR_VAR 0 3
20993: PUSH
20994: LD_VAR 0 18
20998: ST_TO_ADDR
// end ; end ;
20999: LD_VAR 0 3
21003: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21004: LD_INT 0
21006: PPUSH
21007: PPUSH
// result := true ;
21008: LD_ADDR_VAR 0 3
21012: PUSH
21013: LD_INT 1
21015: ST_TO_ADDR
// if array1 = array2 then
21016: LD_VAR 0 1
21020: PUSH
21021: LD_VAR 0 2
21025: EQUAL
21026: IFFALSE 21086
// begin for i = 1 to array1 do
21028: LD_ADDR_VAR 0 4
21032: PUSH
21033: DOUBLE
21034: LD_INT 1
21036: DEC
21037: ST_TO_ADDR
21038: LD_VAR 0 1
21042: PUSH
21043: FOR_TO
21044: IFFALSE 21082
// if array1 [ i ] <> array2 [ i ] then
21046: LD_VAR 0 1
21050: PUSH
21051: LD_VAR 0 4
21055: ARRAY
21056: PUSH
21057: LD_VAR 0 2
21061: PUSH
21062: LD_VAR 0 4
21066: ARRAY
21067: NONEQUAL
21068: IFFALSE 21080
// begin result := false ;
21070: LD_ADDR_VAR 0 3
21074: PUSH
21075: LD_INT 0
21077: ST_TO_ADDR
// break ;
21078: GO 21082
// end ;
21080: GO 21043
21082: POP
21083: POP
// end else
21084: GO 21094
// result := false ;
21086: LD_ADDR_VAR 0 3
21090: PUSH
21091: LD_INT 0
21093: ST_TO_ADDR
// end ;
21094: LD_VAR 0 3
21098: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21099: LD_INT 0
21101: PPUSH
21102: PPUSH
// if not array1 or not array2 then
21103: LD_VAR 0 1
21107: NOT
21108: PUSH
21109: LD_VAR 0 2
21113: NOT
21114: OR
21115: IFFALSE 21119
// exit ;
21117: GO 21183
// result := true ;
21119: LD_ADDR_VAR 0 3
21123: PUSH
21124: LD_INT 1
21126: ST_TO_ADDR
// for i = 1 to array1 do
21127: LD_ADDR_VAR 0 4
21131: PUSH
21132: DOUBLE
21133: LD_INT 1
21135: DEC
21136: ST_TO_ADDR
21137: LD_VAR 0 1
21141: PUSH
21142: FOR_TO
21143: IFFALSE 21181
// if array1 [ i ] <> array2 [ i ] then
21145: LD_VAR 0 1
21149: PUSH
21150: LD_VAR 0 4
21154: ARRAY
21155: PUSH
21156: LD_VAR 0 2
21160: PUSH
21161: LD_VAR 0 4
21165: ARRAY
21166: NONEQUAL
21167: IFFALSE 21179
// begin result := false ;
21169: LD_ADDR_VAR 0 3
21173: PUSH
21174: LD_INT 0
21176: ST_TO_ADDR
// break ;
21177: GO 21181
// end ;
21179: GO 21142
21181: POP
21182: POP
// end ;
21183: LD_VAR 0 3
21187: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21188: LD_INT 0
21190: PPUSH
21191: PPUSH
21192: PPUSH
// pom := GetBase ( fac ) ;
21193: LD_ADDR_VAR 0 5
21197: PUSH
21198: LD_VAR 0 1
21202: PPUSH
21203: CALL_OW 274
21207: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21208: LD_ADDR_VAR 0 4
21212: PUSH
21213: LD_VAR 0 2
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_INT 2
21229: ARRAY
21230: PPUSH
21231: LD_VAR 0 2
21235: PUSH
21236: LD_INT 3
21238: ARRAY
21239: PPUSH
21240: LD_VAR 0 2
21244: PUSH
21245: LD_INT 4
21247: ARRAY
21248: PPUSH
21249: CALL_OW 449
21253: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21254: LD_ADDR_VAR 0 3
21258: PUSH
21259: LD_VAR 0 5
21263: PPUSH
21264: LD_INT 1
21266: PPUSH
21267: CALL_OW 275
21271: PUSH
21272: LD_VAR 0 4
21276: PUSH
21277: LD_INT 1
21279: ARRAY
21280: GREATEREQUAL
21281: PUSH
21282: LD_VAR 0 5
21286: PPUSH
21287: LD_INT 2
21289: PPUSH
21290: CALL_OW 275
21294: PUSH
21295: LD_VAR 0 4
21299: PUSH
21300: LD_INT 2
21302: ARRAY
21303: GREATEREQUAL
21304: AND
21305: PUSH
21306: LD_VAR 0 5
21310: PPUSH
21311: LD_INT 3
21313: PPUSH
21314: CALL_OW 275
21318: PUSH
21319: LD_VAR 0 4
21323: PUSH
21324: LD_INT 3
21326: ARRAY
21327: GREATEREQUAL
21328: AND
21329: ST_TO_ADDR
// end ;
21330: LD_VAR 0 3
21334: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21335: LD_INT 0
21337: PPUSH
21338: PPUSH
21339: PPUSH
21340: PPUSH
// pom := GetBase ( building ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_VAR 0 1
21350: PPUSH
21351: CALL_OW 274
21355: ST_TO_ADDR
// if not pom then
21356: LD_VAR 0 3
21360: NOT
21361: IFFALSE 21365
// exit ;
21363: GO 21535
// btype := GetBType ( building ) ;
21365: LD_ADDR_VAR 0 5
21369: PUSH
21370: LD_VAR 0 1
21374: PPUSH
21375: CALL_OW 266
21379: ST_TO_ADDR
// if btype = b_armoury then
21380: LD_VAR 0 5
21384: PUSH
21385: LD_INT 4
21387: EQUAL
21388: IFFALSE 21398
// btype := b_barracks ;
21390: LD_ADDR_VAR 0 5
21394: PUSH
21395: LD_INT 5
21397: ST_TO_ADDR
// if btype = b_depot then
21398: LD_VAR 0 5
21402: PUSH
21403: LD_INT 0
21405: EQUAL
21406: IFFALSE 21416
// btype := b_warehouse ;
21408: LD_ADDR_VAR 0 5
21412: PUSH
21413: LD_INT 1
21415: ST_TO_ADDR
// if btype = b_workshop then
21416: LD_VAR 0 5
21420: PUSH
21421: LD_INT 2
21423: EQUAL
21424: IFFALSE 21434
// btype := b_factory ;
21426: LD_ADDR_VAR 0 5
21430: PUSH
21431: LD_INT 3
21433: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21434: LD_ADDR_VAR 0 4
21438: PUSH
21439: LD_VAR 0 5
21443: PPUSH
21444: LD_VAR 0 1
21448: PPUSH
21449: CALL_OW 248
21453: PPUSH
21454: CALL_OW 450
21458: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21459: LD_ADDR_VAR 0 2
21463: PUSH
21464: LD_VAR 0 3
21468: PPUSH
21469: LD_INT 1
21471: PPUSH
21472: CALL_OW 275
21476: PUSH
21477: LD_VAR 0 4
21481: PUSH
21482: LD_INT 1
21484: ARRAY
21485: GREATEREQUAL
21486: PUSH
21487: LD_VAR 0 3
21491: PPUSH
21492: LD_INT 2
21494: PPUSH
21495: CALL_OW 275
21499: PUSH
21500: LD_VAR 0 4
21504: PUSH
21505: LD_INT 2
21507: ARRAY
21508: GREATEREQUAL
21509: AND
21510: PUSH
21511: LD_VAR 0 3
21515: PPUSH
21516: LD_INT 3
21518: PPUSH
21519: CALL_OW 275
21523: PUSH
21524: LD_VAR 0 4
21528: PUSH
21529: LD_INT 3
21531: ARRAY
21532: GREATEREQUAL
21533: AND
21534: ST_TO_ADDR
// end ;
21535: LD_VAR 0 2
21539: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21540: LD_INT 0
21542: PPUSH
21543: PPUSH
21544: PPUSH
// pom := GetBase ( building ) ;
21545: LD_ADDR_VAR 0 4
21549: PUSH
21550: LD_VAR 0 1
21554: PPUSH
21555: CALL_OW 274
21559: ST_TO_ADDR
// if not pom then
21560: LD_VAR 0 4
21564: NOT
21565: IFFALSE 21569
// exit ;
21567: GO 21670
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21569: LD_ADDR_VAR 0 5
21573: PUSH
21574: LD_VAR 0 2
21578: PPUSH
21579: LD_VAR 0 1
21583: PPUSH
21584: CALL_OW 248
21588: PPUSH
21589: CALL_OW 450
21593: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21594: LD_ADDR_VAR 0 3
21598: PUSH
21599: LD_VAR 0 4
21603: PPUSH
21604: LD_INT 1
21606: PPUSH
21607: CALL_OW 275
21611: PUSH
21612: LD_VAR 0 5
21616: PUSH
21617: LD_INT 1
21619: ARRAY
21620: GREATEREQUAL
21621: PUSH
21622: LD_VAR 0 4
21626: PPUSH
21627: LD_INT 2
21629: PPUSH
21630: CALL_OW 275
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 2
21642: ARRAY
21643: GREATEREQUAL
21644: AND
21645: PUSH
21646: LD_VAR 0 4
21650: PPUSH
21651: LD_INT 3
21653: PPUSH
21654: CALL_OW 275
21658: PUSH
21659: LD_VAR 0 5
21663: PUSH
21664: LD_INT 3
21666: ARRAY
21667: GREATEREQUAL
21668: AND
21669: ST_TO_ADDR
// end ;
21670: LD_VAR 0 3
21674: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21675: LD_INT 0
21677: PPUSH
21678: PPUSH
21679: PPUSH
21680: PPUSH
21681: PPUSH
21682: PPUSH
21683: PPUSH
21684: PPUSH
21685: PPUSH
21686: PPUSH
21687: PPUSH
// result := false ;
21688: LD_ADDR_VAR 0 8
21692: PUSH
21693: LD_INT 0
21695: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21696: LD_VAR 0 5
21700: NOT
21701: PUSH
21702: LD_VAR 0 1
21706: NOT
21707: OR
21708: PUSH
21709: LD_VAR 0 2
21713: NOT
21714: OR
21715: PUSH
21716: LD_VAR 0 3
21720: NOT
21721: OR
21722: IFFALSE 21726
// exit ;
21724: GO 22540
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21726: LD_ADDR_VAR 0 14
21730: PUSH
21731: LD_VAR 0 1
21735: PPUSH
21736: LD_VAR 0 2
21740: PPUSH
21741: LD_VAR 0 3
21745: PPUSH
21746: LD_VAR 0 4
21750: PPUSH
21751: LD_VAR 0 5
21755: PUSH
21756: LD_INT 1
21758: ARRAY
21759: PPUSH
21760: CALL_OW 248
21764: PPUSH
21765: LD_INT 0
21767: PPUSH
21768: CALL 23377 0 6
21772: ST_TO_ADDR
// if not hexes then
21773: LD_VAR 0 14
21777: NOT
21778: IFFALSE 21782
// exit ;
21780: GO 22540
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21782: LD_ADDR_VAR 0 17
21786: PUSH
21787: LD_VAR 0 5
21791: PPUSH
21792: LD_INT 22
21794: PUSH
21795: LD_VAR 0 13
21799: PPUSH
21800: CALL_OW 255
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 2
21811: PUSH
21812: LD_INT 30
21814: PUSH
21815: LD_INT 0
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: PUSH
21822: LD_INT 30
21824: PUSH
21825: LD_INT 1
21827: PUSH
21828: EMPTY
21829: LIST
21830: LIST
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: PPUSH
21841: CALL_OW 72
21845: ST_TO_ADDR
// for i = 1 to hexes do
21846: LD_ADDR_VAR 0 9
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: LD_VAR 0 14
21860: PUSH
21861: FOR_TO
21862: IFFALSE 22538
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21864: LD_ADDR_VAR 0 13
21868: PUSH
21869: LD_VAR 0 14
21873: PUSH
21874: LD_VAR 0 9
21878: ARRAY
21879: PUSH
21880: LD_INT 1
21882: ARRAY
21883: PPUSH
21884: LD_VAR 0 14
21888: PUSH
21889: LD_VAR 0 9
21893: ARRAY
21894: PUSH
21895: LD_INT 2
21897: ARRAY
21898: PPUSH
21899: CALL_OW 428
21903: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21904: LD_VAR 0 14
21908: PUSH
21909: LD_VAR 0 9
21913: ARRAY
21914: PUSH
21915: LD_INT 1
21917: ARRAY
21918: PPUSH
21919: LD_VAR 0 14
21923: PUSH
21924: LD_VAR 0 9
21928: ARRAY
21929: PUSH
21930: LD_INT 2
21932: ARRAY
21933: PPUSH
21934: CALL_OW 351
21938: PUSH
21939: LD_VAR 0 14
21943: PUSH
21944: LD_VAR 0 9
21948: ARRAY
21949: PUSH
21950: LD_INT 1
21952: ARRAY
21953: PPUSH
21954: LD_VAR 0 14
21958: PUSH
21959: LD_VAR 0 9
21963: ARRAY
21964: PUSH
21965: LD_INT 2
21967: ARRAY
21968: PPUSH
21969: CALL_OW 488
21973: NOT
21974: OR
21975: PUSH
21976: LD_VAR 0 13
21980: PPUSH
21981: CALL_OW 247
21985: PUSH
21986: LD_INT 3
21988: EQUAL
21989: OR
21990: IFFALSE 21996
// exit ;
21992: POP
21993: POP
21994: GO 22540
// if not tmp then
21996: LD_VAR 0 13
22000: NOT
22001: IFFALSE 22005
// continue ;
22003: GO 21861
// result := true ;
22005: LD_ADDR_VAR 0 8
22009: PUSH
22010: LD_INT 1
22012: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22013: LD_VAR 0 6
22017: PUSH
22018: LD_VAR 0 13
22022: PPUSH
22023: CALL_OW 247
22027: PUSH
22028: LD_INT 2
22030: EQUAL
22031: AND
22032: PUSH
22033: LD_VAR 0 13
22037: PPUSH
22038: CALL_OW 263
22042: PUSH
22043: LD_INT 1
22045: EQUAL
22046: AND
22047: IFFALSE 22211
// begin if IsDrivenBy ( tmp ) then
22049: LD_VAR 0 13
22053: PPUSH
22054: CALL_OW 311
22058: IFFALSE 22062
// continue ;
22060: GO 21861
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22062: LD_VAR 0 6
22066: PPUSH
22067: LD_INT 3
22069: PUSH
22070: LD_INT 60
22072: PUSH
22073: EMPTY
22074: LIST
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: LD_INT 55
22085: PUSH
22086: EMPTY
22087: LIST
22088: PUSH
22089: EMPTY
22090: LIST
22091: LIST
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: PPUSH
22097: CALL_OW 72
22101: IFFALSE 22209
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22103: LD_ADDR_VAR 0 18
22107: PUSH
22108: LD_VAR 0 6
22112: PPUSH
22113: LD_INT 3
22115: PUSH
22116: LD_INT 60
22118: PUSH
22119: EMPTY
22120: LIST
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: LD_INT 3
22128: PUSH
22129: LD_INT 55
22131: PUSH
22132: EMPTY
22133: LIST
22134: PUSH
22135: EMPTY
22136: LIST
22137: LIST
22138: PUSH
22139: EMPTY
22140: LIST
22141: LIST
22142: PPUSH
22143: CALL_OW 72
22147: PUSH
22148: LD_INT 1
22150: ARRAY
22151: ST_TO_ADDR
// if IsInUnit ( driver ) then
22152: LD_VAR 0 18
22156: PPUSH
22157: CALL_OW 310
22161: IFFALSE 22172
// ComExit ( driver ) ;
22163: LD_VAR 0 18
22167: PPUSH
22168: CALL 46561 0 1
// AddComEnterUnit ( driver , tmp ) ;
22172: LD_VAR 0 18
22176: PPUSH
22177: LD_VAR 0 13
22181: PPUSH
22182: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22186: LD_VAR 0 18
22190: PPUSH
22191: LD_VAR 0 7
22195: PPUSH
22196: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22200: LD_VAR 0 18
22204: PPUSH
22205: CALL_OW 181
// end ; continue ;
22209: GO 21861
// end ; if not cleaners or not tmp in cleaners then
22211: LD_VAR 0 6
22215: NOT
22216: PUSH
22217: LD_VAR 0 13
22221: PUSH
22222: LD_VAR 0 6
22226: IN
22227: NOT
22228: OR
22229: IFFALSE 22536
// begin if dep then
22231: LD_VAR 0 17
22235: IFFALSE 22371
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22237: LD_ADDR_VAR 0 16
22241: PUSH
22242: LD_VAR 0 17
22246: PUSH
22247: LD_INT 1
22249: ARRAY
22250: PPUSH
22251: CALL_OW 250
22255: PPUSH
22256: LD_VAR 0 17
22260: PUSH
22261: LD_INT 1
22263: ARRAY
22264: PPUSH
22265: CALL_OW 254
22269: PPUSH
22270: LD_INT 5
22272: PPUSH
22273: CALL_OW 272
22277: PUSH
22278: LD_VAR 0 17
22282: PUSH
22283: LD_INT 1
22285: ARRAY
22286: PPUSH
22287: CALL_OW 251
22291: PPUSH
22292: LD_VAR 0 17
22296: PUSH
22297: LD_INT 1
22299: ARRAY
22300: PPUSH
22301: CALL_OW 254
22305: PPUSH
22306: LD_INT 5
22308: PPUSH
22309: CALL_OW 273
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22318: LD_VAR 0 16
22322: PUSH
22323: LD_INT 1
22325: ARRAY
22326: PPUSH
22327: LD_VAR 0 16
22331: PUSH
22332: LD_INT 2
22334: ARRAY
22335: PPUSH
22336: CALL_OW 488
22340: IFFALSE 22371
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22342: LD_VAR 0 13
22346: PPUSH
22347: LD_VAR 0 16
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: LD_VAR 0 16
22360: PUSH
22361: LD_INT 2
22363: ARRAY
22364: PPUSH
22365: CALL_OW 111
// continue ;
22369: GO 21861
// end ; end ; r := GetDir ( tmp ) ;
22371: LD_ADDR_VAR 0 15
22375: PUSH
22376: LD_VAR 0 13
22380: PPUSH
22381: CALL_OW 254
22385: ST_TO_ADDR
// if r = 5 then
22386: LD_VAR 0 15
22390: PUSH
22391: LD_INT 5
22393: EQUAL
22394: IFFALSE 22404
// r := 0 ;
22396: LD_ADDR_VAR 0 15
22400: PUSH
22401: LD_INT 0
22403: ST_TO_ADDR
// for j = r to 5 do
22404: LD_ADDR_VAR 0 10
22408: PUSH
22409: DOUBLE
22410: LD_VAR 0 15
22414: DEC
22415: ST_TO_ADDR
22416: LD_INT 5
22418: PUSH
22419: FOR_TO
22420: IFFALSE 22534
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22422: LD_ADDR_VAR 0 11
22426: PUSH
22427: LD_VAR 0 13
22431: PPUSH
22432: CALL_OW 250
22436: PPUSH
22437: LD_VAR 0 10
22441: PPUSH
22442: LD_INT 2
22444: PPUSH
22445: CALL_OW 272
22449: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22450: LD_ADDR_VAR 0 12
22454: PUSH
22455: LD_VAR 0 13
22459: PPUSH
22460: CALL_OW 251
22464: PPUSH
22465: LD_VAR 0 10
22469: PPUSH
22470: LD_INT 2
22472: PPUSH
22473: CALL_OW 273
22477: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22478: LD_VAR 0 11
22482: PPUSH
22483: LD_VAR 0 12
22487: PPUSH
22488: CALL_OW 488
22492: PUSH
22493: LD_VAR 0 11
22497: PPUSH
22498: LD_VAR 0 12
22502: PPUSH
22503: CALL_OW 428
22507: NOT
22508: AND
22509: IFFALSE 22532
// begin ComMoveXY ( tmp , _x , _y ) ;
22511: LD_VAR 0 13
22515: PPUSH
22516: LD_VAR 0 11
22520: PPUSH
22521: LD_VAR 0 12
22525: PPUSH
22526: CALL_OW 111
// break ;
22530: GO 22534
// end ; end ;
22532: GO 22419
22534: POP
22535: POP
// end ; end ;
22536: GO 21861
22538: POP
22539: POP
// end ;
22540: LD_VAR 0 8
22544: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22545: LD_INT 0
22547: PPUSH
22548: PPUSH
22549: PPUSH
22550: PPUSH
22551: PPUSH
22552: PPUSH
22553: PPUSH
22554: PPUSH
22555: PPUSH
22556: PPUSH
// result := false ;
22557: LD_ADDR_VAR 0 6
22561: PUSH
22562: LD_INT 0
22564: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22565: LD_VAR 0 1
22569: NOT
22570: PUSH
22571: LD_VAR 0 1
22575: PPUSH
22576: CALL_OW 266
22580: PUSH
22581: LD_INT 0
22583: PUSH
22584: LD_INT 1
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: IN
22591: NOT
22592: OR
22593: PUSH
22594: LD_VAR 0 2
22598: NOT
22599: OR
22600: PUSH
22601: LD_VAR 0 5
22605: PUSH
22606: LD_INT 0
22608: PUSH
22609: LD_INT 1
22611: PUSH
22612: LD_INT 2
22614: PUSH
22615: LD_INT 3
22617: PUSH
22618: LD_INT 4
22620: PUSH
22621: LD_INT 5
22623: PUSH
22624: EMPTY
22625: LIST
22626: LIST
22627: LIST
22628: LIST
22629: LIST
22630: LIST
22631: IN
22632: NOT
22633: OR
22634: PUSH
22635: LD_VAR 0 3
22639: PPUSH
22640: LD_VAR 0 4
22644: PPUSH
22645: CALL_OW 488
22649: NOT
22650: OR
22651: IFFALSE 22655
// exit ;
22653: GO 23372
// pom := GetBase ( depot ) ;
22655: LD_ADDR_VAR 0 10
22659: PUSH
22660: LD_VAR 0 1
22664: PPUSH
22665: CALL_OW 274
22669: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22670: LD_ADDR_VAR 0 11
22674: PUSH
22675: LD_VAR 0 2
22679: PPUSH
22680: LD_VAR 0 1
22684: PPUSH
22685: CALL_OW 248
22689: PPUSH
22690: CALL_OW 450
22694: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22695: LD_VAR 0 10
22699: PPUSH
22700: LD_INT 1
22702: PPUSH
22703: CALL_OW 275
22707: PUSH
22708: LD_VAR 0 11
22712: PUSH
22713: LD_INT 1
22715: ARRAY
22716: GREATEREQUAL
22717: PUSH
22718: LD_VAR 0 10
22722: PPUSH
22723: LD_INT 2
22725: PPUSH
22726: CALL_OW 275
22730: PUSH
22731: LD_VAR 0 11
22735: PUSH
22736: LD_INT 2
22738: ARRAY
22739: GREATEREQUAL
22740: AND
22741: PUSH
22742: LD_VAR 0 10
22746: PPUSH
22747: LD_INT 3
22749: PPUSH
22750: CALL_OW 275
22754: PUSH
22755: LD_VAR 0 11
22759: PUSH
22760: LD_INT 3
22762: ARRAY
22763: GREATEREQUAL
22764: AND
22765: NOT
22766: IFFALSE 22770
// exit ;
22768: GO 23372
// if GetBType ( depot ) = b_depot then
22770: LD_VAR 0 1
22774: PPUSH
22775: CALL_OW 266
22779: PUSH
22780: LD_INT 0
22782: EQUAL
22783: IFFALSE 22795
// dist := 28 else
22785: LD_ADDR_VAR 0 14
22789: PUSH
22790: LD_INT 28
22792: ST_TO_ADDR
22793: GO 22803
// dist := 36 ;
22795: LD_ADDR_VAR 0 14
22799: PUSH
22800: LD_INT 36
22802: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22803: LD_VAR 0 1
22807: PPUSH
22808: LD_VAR 0 3
22812: PPUSH
22813: LD_VAR 0 4
22817: PPUSH
22818: CALL_OW 297
22822: PUSH
22823: LD_VAR 0 14
22827: GREATER
22828: IFFALSE 22832
// exit ;
22830: GO 23372
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22832: LD_ADDR_VAR 0 12
22836: PUSH
22837: LD_VAR 0 2
22841: PPUSH
22842: LD_VAR 0 3
22846: PPUSH
22847: LD_VAR 0 4
22851: PPUSH
22852: LD_VAR 0 5
22856: PPUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: CALL_OW 248
22866: PPUSH
22867: LD_INT 0
22869: PPUSH
22870: CALL 23377 0 6
22874: ST_TO_ADDR
// if not hexes then
22875: LD_VAR 0 12
22879: NOT
22880: IFFALSE 22884
// exit ;
22882: GO 23372
// hex := GetHexInfo ( x , y ) ;
22884: LD_ADDR_VAR 0 15
22888: PUSH
22889: LD_VAR 0 3
22893: PPUSH
22894: LD_VAR 0 4
22898: PPUSH
22899: CALL_OW 546
22903: ST_TO_ADDR
// if hex [ 1 ] then
22904: LD_VAR 0 15
22908: PUSH
22909: LD_INT 1
22911: ARRAY
22912: IFFALSE 22916
// exit ;
22914: GO 23372
// height := hex [ 2 ] ;
22916: LD_ADDR_VAR 0 13
22920: PUSH
22921: LD_VAR 0 15
22925: PUSH
22926: LD_INT 2
22928: ARRAY
22929: ST_TO_ADDR
// for i = 1 to hexes do
22930: LD_ADDR_VAR 0 7
22934: PUSH
22935: DOUBLE
22936: LD_INT 1
22938: DEC
22939: ST_TO_ADDR
22940: LD_VAR 0 12
22944: PUSH
22945: FOR_TO
22946: IFFALSE 23276
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22948: LD_VAR 0 12
22952: PUSH
22953: LD_VAR 0 7
22957: ARRAY
22958: PUSH
22959: LD_INT 1
22961: ARRAY
22962: PPUSH
22963: LD_VAR 0 12
22967: PUSH
22968: LD_VAR 0 7
22972: ARRAY
22973: PUSH
22974: LD_INT 2
22976: ARRAY
22977: PPUSH
22978: CALL_OW 488
22982: NOT
22983: PUSH
22984: LD_VAR 0 12
22988: PUSH
22989: LD_VAR 0 7
22993: ARRAY
22994: PUSH
22995: LD_INT 1
22997: ARRAY
22998: PPUSH
22999: LD_VAR 0 12
23003: PUSH
23004: LD_VAR 0 7
23008: ARRAY
23009: PUSH
23010: LD_INT 2
23012: ARRAY
23013: PPUSH
23014: CALL_OW 428
23018: PUSH
23019: LD_INT 0
23021: GREATER
23022: OR
23023: PUSH
23024: LD_VAR 0 12
23028: PUSH
23029: LD_VAR 0 7
23033: ARRAY
23034: PUSH
23035: LD_INT 1
23037: ARRAY
23038: PPUSH
23039: LD_VAR 0 12
23043: PUSH
23044: LD_VAR 0 7
23048: ARRAY
23049: PUSH
23050: LD_INT 2
23052: ARRAY
23053: PPUSH
23054: CALL_OW 351
23058: OR
23059: IFFALSE 23065
// exit ;
23061: POP
23062: POP
23063: GO 23372
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23065: LD_ADDR_VAR 0 8
23069: PUSH
23070: LD_VAR 0 12
23074: PUSH
23075: LD_VAR 0 7
23079: ARRAY
23080: PUSH
23081: LD_INT 1
23083: ARRAY
23084: PPUSH
23085: LD_VAR 0 12
23089: PUSH
23090: LD_VAR 0 7
23094: ARRAY
23095: PUSH
23096: LD_INT 2
23098: ARRAY
23099: PPUSH
23100: CALL_OW 546
23104: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23105: LD_VAR 0 8
23109: PUSH
23110: LD_INT 1
23112: ARRAY
23113: PUSH
23114: LD_VAR 0 8
23118: PUSH
23119: LD_INT 2
23121: ARRAY
23122: PUSH
23123: LD_VAR 0 13
23127: PUSH
23128: LD_INT 2
23130: PLUS
23131: GREATER
23132: OR
23133: PUSH
23134: LD_VAR 0 8
23138: PUSH
23139: LD_INT 2
23141: ARRAY
23142: PUSH
23143: LD_VAR 0 13
23147: PUSH
23148: LD_INT 2
23150: MINUS
23151: LESS
23152: OR
23153: PUSH
23154: LD_VAR 0 8
23158: PUSH
23159: LD_INT 3
23161: ARRAY
23162: PUSH
23163: LD_INT 0
23165: PUSH
23166: LD_INT 8
23168: PUSH
23169: LD_INT 9
23171: PUSH
23172: LD_INT 10
23174: PUSH
23175: LD_INT 11
23177: PUSH
23178: LD_INT 12
23180: PUSH
23181: LD_INT 13
23183: PUSH
23184: LD_INT 16
23186: PUSH
23187: LD_INT 17
23189: PUSH
23190: LD_INT 18
23192: PUSH
23193: LD_INT 19
23195: PUSH
23196: LD_INT 20
23198: PUSH
23199: LD_INT 21
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: IN
23217: NOT
23218: OR
23219: PUSH
23220: LD_VAR 0 8
23224: PUSH
23225: LD_INT 5
23227: ARRAY
23228: NOT
23229: OR
23230: PUSH
23231: LD_VAR 0 8
23235: PUSH
23236: LD_INT 6
23238: ARRAY
23239: PUSH
23240: LD_INT 1
23242: PUSH
23243: LD_INT 2
23245: PUSH
23246: LD_INT 7
23248: PUSH
23249: LD_INT 9
23251: PUSH
23252: LD_INT 10
23254: PUSH
23255: LD_INT 11
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: IN
23266: NOT
23267: OR
23268: IFFALSE 23274
// exit ;
23270: POP
23271: POP
23272: GO 23372
// end ;
23274: GO 22945
23276: POP
23277: POP
// side := GetSide ( depot ) ;
23278: LD_ADDR_VAR 0 9
23282: PUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: CALL_OW 255
23292: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23293: LD_VAR 0 9
23297: PPUSH
23298: LD_VAR 0 3
23302: PPUSH
23303: LD_VAR 0 4
23307: PPUSH
23308: LD_INT 20
23310: PPUSH
23311: CALL 15693 0 4
23315: PUSH
23316: LD_INT 4
23318: ARRAY
23319: IFFALSE 23323
// exit ;
23321: GO 23372
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23323: LD_VAR 0 2
23327: PUSH
23328: LD_INT 29
23330: PUSH
23331: LD_INT 30
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: IN
23338: PUSH
23339: LD_VAR 0 3
23343: PPUSH
23344: LD_VAR 0 4
23348: PPUSH
23349: LD_VAR 0 9
23353: PPUSH
23354: CALL_OW 440
23358: NOT
23359: AND
23360: IFFALSE 23364
// exit ;
23362: GO 23372
// result := true ;
23364: LD_ADDR_VAR 0 6
23368: PUSH
23369: LD_INT 1
23371: ST_TO_ADDR
// end ;
23372: LD_VAR 0 6
23376: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23377: LD_INT 0
23379: PPUSH
23380: PPUSH
23381: PPUSH
23382: PPUSH
23383: PPUSH
23384: PPUSH
23385: PPUSH
23386: PPUSH
23387: PPUSH
23388: PPUSH
23389: PPUSH
23390: PPUSH
23391: PPUSH
23392: PPUSH
23393: PPUSH
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
23404: PPUSH
23405: PPUSH
23406: PPUSH
23407: PPUSH
23408: PPUSH
23409: PPUSH
23410: PPUSH
23411: PPUSH
23412: PPUSH
23413: PPUSH
23414: PPUSH
23415: PPUSH
23416: PPUSH
23417: PPUSH
23418: PPUSH
23419: PPUSH
23420: PPUSH
23421: PPUSH
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
23430: PPUSH
23431: PPUSH
23432: PPUSH
23433: PPUSH
23434: PPUSH
23435: PPUSH
23436: PPUSH
// result = [ ] ;
23437: LD_ADDR_VAR 0 7
23441: PUSH
23442: EMPTY
23443: ST_TO_ADDR
// temp_list = [ ] ;
23444: LD_ADDR_VAR 0 9
23448: PUSH
23449: EMPTY
23450: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23451: LD_VAR 0 4
23455: PUSH
23456: LD_INT 0
23458: PUSH
23459: LD_INT 1
23461: PUSH
23462: LD_INT 2
23464: PUSH
23465: LD_INT 3
23467: PUSH
23468: LD_INT 4
23470: PUSH
23471: LD_INT 5
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: LIST
23478: LIST
23479: LIST
23480: LIST
23481: IN
23482: NOT
23483: PUSH
23484: LD_VAR 0 1
23488: PUSH
23489: LD_INT 0
23491: PUSH
23492: LD_INT 1
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: IN
23499: PUSH
23500: LD_VAR 0 5
23504: PUSH
23505: LD_INT 1
23507: PUSH
23508: LD_INT 2
23510: PUSH
23511: LD_INT 3
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: LIST
23518: IN
23519: NOT
23520: AND
23521: OR
23522: IFFALSE 23526
// exit ;
23524: GO 41917
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23526: LD_VAR 0 1
23530: PUSH
23531: LD_INT 6
23533: PUSH
23534: LD_INT 7
23536: PUSH
23537: LD_INT 8
23539: PUSH
23540: LD_INT 13
23542: PUSH
23543: LD_INT 12
23545: PUSH
23546: LD_INT 15
23548: PUSH
23549: LD_INT 11
23551: PUSH
23552: LD_INT 14
23554: PUSH
23555: LD_INT 10
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: LIST
23562: LIST
23563: LIST
23564: LIST
23565: LIST
23566: LIST
23567: LIST
23568: IN
23569: IFFALSE 23579
// btype = b_lab ;
23571: LD_ADDR_VAR 0 1
23575: PUSH
23576: LD_INT 6
23578: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23579: LD_VAR 0 6
23583: PUSH
23584: LD_INT 0
23586: PUSH
23587: LD_INT 1
23589: PUSH
23590: LD_INT 2
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: IN
23598: NOT
23599: PUSH
23600: LD_VAR 0 1
23604: PUSH
23605: LD_INT 0
23607: PUSH
23608: LD_INT 1
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: LD_INT 3
23616: PUSH
23617: LD_INT 6
23619: PUSH
23620: LD_INT 36
23622: PUSH
23623: LD_INT 4
23625: PUSH
23626: LD_INT 5
23628: PUSH
23629: LD_INT 31
23631: PUSH
23632: LD_INT 32
23634: PUSH
23635: LD_INT 33
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: LIST
23647: LIST
23648: LIST
23649: LIST
23650: IN
23651: NOT
23652: PUSH
23653: LD_VAR 0 6
23657: PUSH
23658: LD_INT 1
23660: EQUAL
23661: AND
23662: OR
23663: PUSH
23664: LD_VAR 0 1
23668: PUSH
23669: LD_INT 2
23671: PUSH
23672: LD_INT 3
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: IN
23679: NOT
23680: PUSH
23681: LD_VAR 0 6
23685: PUSH
23686: LD_INT 2
23688: EQUAL
23689: AND
23690: OR
23691: IFFALSE 23701
// mode = 0 ;
23693: LD_ADDR_VAR 0 6
23697: PUSH
23698: LD_INT 0
23700: ST_TO_ADDR
// case mode of 0 :
23701: LD_VAR 0 6
23705: PUSH
23706: LD_INT 0
23708: DOUBLE
23709: EQUAL
23710: IFTRUE 23714
23712: GO 35167
23714: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23715: LD_ADDR_VAR 0 11
23719: PUSH
23720: LD_INT 0
23722: PUSH
23723: LD_INT 0
23725: PUSH
23726: EMPTY
23727: LIST
23728: LIST
23729: PUSH
23730: LD_INT 0
23732: PUSH
23733: LD_INT 1
23735: NEG
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: PUSH
23741: LD_INT 1
23743: PUSH
23744: LD_INT 0
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PUSH
23751: LD_INT 1
23753: PUSH
23754: LD_INT 1
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: LD_INT 0
23763: PUSH
23764: LD_INT 1
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PUSH
23771: LD_INT 1
23773: NEG
23774: PUSH
23775: LD_INT 0
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: PUSH
23782: LD_INT 1
23784: NEG
23785: PUSH
23786: LD_INT 1
23788: NEG
23789: PUSH
23790: EMPTY
23791: LIST
23792: LIST
23793: PUSH
23794: LD_INT 1
23796: NEG
23797: PUSH
23798: LD_INT 2
23800: NEG
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PUSH
23806: LD_INT 0
23808: PUSH
23809: LD_INT 2
23811: NEG
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 1
23819: PUSH
23820: LD_INT 1
23822: NEG
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PUSH
23828: LD_INT 1
23830: PUSH
23831: LD_INT 2
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PUSH
23838: LD_INT 0
23840: PUSH
23841: LD_INT 2
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 1
23850: NEG
23851: PUSH
23852: LD_INT 1
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: PUSH
23859: LD_INT 1
23861: PUSH
23862: LD_INT 3
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 0
23871: PUSH
23872: LD_INT 3
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 1
23881: NEG
23882: PUSH
23883: LD_INT 2
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: LIST
23907: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23908: LD_ADDR_VAR 0 12
23912: PUSH
23913: LD_INT 0
23915: PUSH
23916: LD_INT 0
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: LD_INT 0
23925: PUSH
23926: LD_INT 1
23928: NEG
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 1
23936: PUSH
23937: LD_INT 0
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 1
23946: PUSH
23947: LD_INT 1
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: LD_INT 0
23956: PUSH
23957: LD_INT 1
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: LD_INT 1
23966: NEG
23967: PUSH
23968: LD_INT 0
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: PUSH
23975: LD_INT 1
23977: NEG
23978: PUSH
23979: LD_INT 1
23981: NEG
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 1
23989: PUSH
23990: LD_INT 1
23992: NEG
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: PUSH
23998: LD_INT 2
24000: PUSH
24001: LD_INT 0
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: PUSH
24008: LD_INT 2
24010: PUSH
24011: LD_INT 1
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: PUSH
24018: LD_INT 1
24020: NEG
24021: PUSH
24022: LD_INT 1
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 2
24031: NEG
24032: PUSH
24033: LD_INT 0
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 2
24042: NEG
24043: PUSH
24044: LD_INT 1
24046: NEG
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 2
24054: NEG
24055: PUSH
24056: LD_INT 1
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: PUSH
24063: LD_INT 3
24065: NEG
24066: PUSH
24067: LD_INT 0
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 3
24076: NEG
24077: PUSH
24078: LD_INT 1
24080: NEG
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24104: LD_ADDR_VAR 0 13
24108: PUSH
24109: LD_INT 0
24111: PUSH
24112: LD_INT 0
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: PUSH
24119: LD_INT 0
24121: PUSH
24122: LD_INT 1
24124: NEG
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 1
24132: PUSH
24133: LD_INT 0
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 1
24142: PUSH
24143: LD_INT 1
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 0
24152: PUSH
24153: LD_INT 1
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: LD_INT 1
24162: NEG
24163: PUSH
24164: LD_INT 0
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: LD_INT 1
24173: NEG
24174: PUSH
24175: LD_INT 1
24177: NEG
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: LD_INT 1
24185: NEG
24186: PUSH
24187: LD_INT 2
24189: NEG
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PUSH
24195: LD_INT 2
24197: PUSH
24198: LD_INT 1
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: PUSH
24205: LD_INT 2
24207: PUSH
24208: LD_INT 2
24210: PUSH
24211: EMPTY
24212: LIST
24213: LIST
24214: PUSH
24215: LD_INT 1
24217: PUSH
24218: LD_INT 2
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 2
24227: NEG
24228: PUSH
24229: LD_INT 1
24231: NEG
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: PUSH
24237: LD_INT 2
24239: NEG
24240: PUSH
24241: LD_INT 2
24243: NEG
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: PUSH
24249: LD_INT 2
24251: NEG
24252: PUSH
24253: LD_INT 3
24255: NEG
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_INT 3
24263: NEG
24264: PUSH
24265: LD_INT 2
24267: NEG
24268: PUSH
24269: EMPTY
24270: LIST
24271: LIST
24272: PUSH
24273: LD_INT 3
24275: NEG
24276: PUSH
24277: LD_INT 3
24279: NEG
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: LIST
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24303: LD_ADDR_VAR 0 14
24307: PUSH
24308: LD_INT 0
24310: PUSH
24311: LD_INT 0
24313: PUSH
24314: EMPTY
24315: LIST
24316: LIST
24317: PUSH
24318: LD_INT 0
24320: PUSH
24321: LD_INT 1
24323: NEG
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 1
24331: PUSH
24332: LD_INT 0
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: PUSH
24342: LD_INT 1
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 0
24351: PUSH
24352: LD_INT 1
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 1
24361: NEG
24362: PUSH
24363: LD_INT 0
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: PUSH
24370: LD_INT 1
24372: NEG
24373: PUSH
24374: LD_INT 1
24376: NEG
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: PUSH
24382: LD_INT 1
24384: NEG
24385: PUSH
24386: LD_INT 2
24388: NEG
24389: PUSH
24390: EMPTY
24391: LIST
24392: LIST
24393: PUSH
24394: LD_INT 0
24396: PUSH
24397: LD_INT 2
24399: NEG
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: LD_INT 1
24407: PUSH
24408: LD_INT 1
24410: NEG
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PUSH
24416: LD_INT 1
24418: PUSH
24419: LD_INT 2
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 0
24428: PUSH
24429: LD_INT 2
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 1
24438: NEG
24439: PUSH
24440: LD_INT 1
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: LD_INT 3
24453: NEG
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PUSH
24459: LD_INT 0
24461: PUSH
24462: LD_INT 3
24464: NEG
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: PUSH
24470: LD_INT 1
24472: PUSH
24473: LD_INT 2
24475: NEG
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: LIST
24488: LIST
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: LIST
24494: LIST
24495: LIST
24496: LIST
24497: LIST
24498: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24499: LD_ADDR_VAR 0 15
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 0
24516: PUSH
24517: LD_INT 1
24519: NEG
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 1
24527: PUSH
24528: LD_INT 0
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 1
24537: PUSH
24538: LD_INT 1
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 0
24547: PUSH
24548: LD_INT 1
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: NEG
24558: PUSH
24559: LD_INT 0
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: LD_INT 1
24568: NEG
24569: PUSH
24570: LD_INT 1
24572: NEG
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 1
24580: PUSH
24581: LD_INT 1
24583: NEG
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 2
24591: PUSH
24592: LD_INT 0
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: PUSH
24599: LD_INT 2
24601: PUSH
24602: LD_INT 1
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: PUSH
24609: LD_INT 1
24611: NEG
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: NEG
24623: PUSH
24624: LD_INT 0
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 2
24633: NEG
24634: PUSH
24635: LD_INT 1
24637: NEG
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 2
24645: PUSH
24646: LD_INT 1
24648: NEG
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 3
24656: PUSH
24657: LD_INT 0
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: LD_INT 3
24666: PUSH
24667: LD_INT 1
24669: PUSH
24670: EMPTY
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: LIST
24684: LIST
24685: LIST
24686: LIST
24687: LIST
24688: LIST
24689: LIST
24690: LIST
24691: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24692: LD_ADDR_VAR 0 16
24696: PUSH
24697: LD_INT 0
24699: PUSH
24700: LD_INT 0
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: LD_INT 0
24709: PUSH
24710: LD_INT 1
24712: NEG
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 1
24720: PUSH
24721: LD_INT 0
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 1
24730: PUSH
24731: LD_INT 1
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: LD_INT 1
24743: PUSH
24744: EMPTY
24745: LIST
24746: LIST
24747: PUSH
24748: LD_INT 1
24750: NEG
24751: PUSH
24752: LD_INT 0
24754: PUSH
24755: EMPTY
24756: LIST
24757: LIST
24758: PUSH
24759: LD_INT 1
24761: NEG
24762: PUSH
24763: LD_INT 1
24765: NEG
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PUSH
24771: LD_INT 1
24773: NEG
24774: PUSH
24775: LD_INT 2
24777: NEG
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 2
24785: PUSH
24786: LD_INT 1
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 2
24795: PUSH
24796: LD_INT 2
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: LD_INT 1
24805: PUSH
24806: LD_INT 2
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 2
24815: NEG
24816: PUSH
24817: LD_INT 1
24819: NEG
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 2
24827: NEG
24828: PUSH
24829: LD_INT 2
24831: NEG
24832: PUSH
24833: EMPTY
24834: LIST
24835: LIST
24836: PUSH
24837: LD_INT 3
24839: PUSH
24840: LD_INT 2
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PUSH
24847: LD_INT 3
24849: PUSH
24850: LD_INT 3
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 2
24859: PUSH
24860: LD_INT 3
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: LIST
24872: LIST
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: LIST
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24885: LD_ADDR_VAR 0 17
24889: PUSH
24890: LD_INT 0
24892: PUSH
24893: LD_INT 0
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: LD_INT 0
24902: PUSH
24903: LD_INT 1
24905: NEG
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: PUSH
24911: LD_INT 1
24913: PUSH
24914: LD_INT 0
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PUSH
24921: LD_INT 1
24923: PUSH
24924: LD_INT 1
24926: PUSH
24927: EMPTY
24928: LIST
24929: LIST
24930: PUSH
24931: LD_INT 0
24933: PUSH
24934: LD_INT 1
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PUSH
24941: LD_INT 1
24943: NEG
24944: PUSH
24945: LD_INT 0
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: LD_INT 1
24954: NEG
24955: PUSH
24956: LD_INT 1
24958: NEG
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PUSH
24964: LD_INT 1
24966: NEG
24967: PUSH
24968: LD_INT 2
24970: NEG
24971: PUSH
24972: EMPTY
24973: LIST
24974: LIST
24975: PUSH
24976: LD_INT 0
24978: PUSH
24979: LD_INT 2
24981: NEG
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PUSH
24987: LD_INT 1
24989: PUSH
24990: LD_INT 1
24992: NEG
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 2
25000: PUSH
25001: LD_INT 0
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 2
25010: PUSH
25011: LD_INT 1
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: LD_INT 2
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: LD_INT 1
25030: PUSH
25031: LD_INT 2
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 0
25040: PUSH
25041: LD_INT 2
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 1
25050: NEG
25051: PUSH
25052: LD_INT 1
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 2
25061: NEG
25062: PUSH
25063: LD_INT 0
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 2
25072: NEG
25073: PUSH
25074: LD_INT 1
25076: NEG
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 2
25084: NEG
25085: PUSH
25086: LD_INT 2
25088: NEG
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: LIST
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25115: LD_ADDR_VAR 0 18
25119: PUSH
25120: LD_INT 0
25122: PUSH
25123: LD_INT 0
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 0
25132: PUSH
25133: LD_INT 1
25135: NEG
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: LD_INT 0
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: LD_INT 1
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: LD_INT 0
25163: PUSH
25164: LD_INT 1
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PUSH
25171: LD_INT 1
25173: NEG
25174: PUSH
25175: LD_INT 0
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 1
25184: NEG
25185: PUSH
25186: LD_INT 1
25188: NEG
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: LD_INT 1
25196: NEG
25197: PUSH
25198: LD_INT 2
25200: NEG
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: PUSH
25206: LD_INT 0
25208: PUSH
25209: LD_INT 2
25211: NEG
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 1
25219: PUSH
25220: LD_INT 1
25222: NEG
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: PUSH
25231: LD_INT 0
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: PUSH
25238: LD_INT 2
25240: PUSH
25241: LD_INT 1
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 2
25250: PUSH
25251: LD_INT 2
25253: PUSH
25254: EMPTY
25255: LIST
25256: LIST
25257: PUSH
25258: LD_INT 1
25260: PUSH
25261: LD_INT 2
25263: PUSH
25264: EMPTY
25265: LIST
25266: LIST
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: LD_INT 2
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: NEG
25281: PUSH
25282: LD_INT 1
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PUSH
25289: LD_INT 2
25291: NEG
25292: PUSH
25293: LD_INT 0
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 2
25302: NEG
25303: PUSH
25304: LD_INT 1
25306: NEG
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: PUSH
25312: LD_INT 2
25314: NEG
25315: PUSH
25316: LD_INT 2
25318: NEG
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: LIST
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: LIST
25340: LIST
25341: LIST
25342: LIST
25343: LIST
25344: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25345: LD_ADDR_VAR 0 19
25349: PUSH
25350: LD_INT 0
25352: PUSH
25353: LD_INT 0
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: LD_INT 1
25365: NEG
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: PUSH
25371: LD_INT 1
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: PUSH
25381: LD_INT 1
25383: PUSH
25384: LD_INT 1
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 1
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 1
25403: NEG
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 1
25414: NEG
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 1
25426: NEG
25427: PUSH
25428: LD_INT 2
25430: NEG
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 0
25438: PUSH
25439: LD_INT 2
25441: NEG
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: PUSH
25450: LD_INT 1
25452: NEG
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 2
25460: PUSH
25461: LD_INT 0
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 2
25470: PUSH
25471: LD_INT 1
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 2
25480: PUSH
25481: LD_INT 2
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: LD_INT 1
25490: PUSH
25491: LD_INT 2
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 0
25500: PUSH
25501: LD_INT 2
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 1
25510: NEG
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 2
25521: NEG
25522: PUSH
25523: LD_INT 0
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 2
25532: NEG
25533: PUSH
25534: LD_INT 1
25536: NEG
25537: PUSH
25538: EMPTY
25539: LIST
25540: LIST
25541: PUSH
25542: LD_INT 2
25544: NEG
25545: PUSH
25546: LD_INT 2
25548: NEG
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: LIST
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: LIST
25564: LIST
25565: LIST
25566: LIST
25567: LIST
25568: LIST
25569: LIST
25570: LIST
25571: LIST
25572: LIST
25573: LIST
25574: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25575: LD_ADDR_VAR 0 20
25579: PUSH
25580: LD_INT 0
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: LD_INT 1
25595: NEG
25596: PUSH
25597: EMPTY
25598: LIST
25599: LIST
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: LD_INT 0
25606: PUSH
25607: EMPTY
25608: LIST
25609: LIST
25610: PUSH
25611: LD_INT 1
25613: PUSH
25614: LD_INT 1
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 1
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 1
25656: NEG
25657: PUSH
25658: LD_INT 2
25660: NEG
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 0
25668: PUSH
25669: LD_INT 2
25671: NEG
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: PUSH
25677: LD_INT 1
25679: PUSH
25680: LD_INT 1
25682: NEG
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 2
25690: PUSH
25691: LD_INT 0
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 2
25700: PUSH
25701: LD_INT 1
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 2
25710: PUSH
25711: LD_INT 2
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 1
25720: PUSH
25721: LD_INT 2
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 0
25730: PUSH
25731: LD_INT 2
25733: PUSH
25734: EMPTY
25735: LIST
25736: LIST
25737: PUSH
25738: LD_INT 1
25740: NEG
25741: PUSH
25742: LD_INT 1
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_INT 2
25751: NEG
25752: PUSH
25753: LD_INT 0
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 2
25762: NEG
25763: PUSH
25764: LD_INT 1
25766: NEG
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 2
25774: NEG
25775: PUSH
25776: LD_INT 2
25778: NEG
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: LIST
25788: LIST
25789: LIST
25790: LIST
25791: LIST
25792: LIST
25793: LIST
25794: LIST
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: LIST
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25805: LD_ADDR_VAR 0 21
25809: PUSH
25810: LD_INT 0
25812: PUSH
25813: LD_INT 0
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 0
25822: PUSH
25823: LD_INT 1
25825: NEG
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 1
25833: PUSH
25834: LD_INT 0
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 1
25843: PUSH
25844: LD_INT 1
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 0
25853: PUSH
25854: LD_INT 1
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: LD_INT 1
25863: NEG
25864: PUSH
25865: LD_INT 0
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 1
25874: NEG
25875: PUSH
25876: LD_INT 1
25878: NEG
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: NEG
25887: PUSH
25888: LD_INT 2
25890: NEG
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PUSH
25896: LD_INT 0
25898: PUSH
25899: LD_INT 2
25901: NEG
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: NEG
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 2
25920: PUSH
25921: LD_INT 0
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 2
25930: PUSH
25931: LD_INT 1
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 2
25940: PUSH
25941: LD_INT 2
25943: PUSH
25944: EMPTY
25945: LIST
25946: LIST
25947: PUSH
25948: LD_INT 1
25950: PUSH
25951: LD_INT 2
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PUSH
25958: LD_INT 0
25960: PUSH
25961: LD_INT 2
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: PUSH
25968: LD_INT 1
25970: NEG
25971: PUSH
25972: LD_INT 1
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: PUSH
25979: LD_INT 2
25981: NEG
25982: PUSH
25983: LD_INT 0
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: PUSH
25990: LD_INT 2
25992: NEG
25993: PUSH
25994: LD_INT 1
25996: NEG
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PUSH
26002: LD_INT 2
26004: NEG
26005: PUSH
26006: LD_INT 2
26008: NEG
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: LIST
26030: LIST
26031: LIST
26032: LIST
26033: LIST
26034: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26035: LD_ADDR_VAR 0 22
26039: PUSH
26040: LD_INT 0
26042: PUSH
26043: LD_INT 0
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 1
26055: NEG
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PUSH
26061: LD_INT 1
26063: PUSH
26064: LD_INT 0
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: PUSH
26071: LD_INT 1
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 1
26086: PUSH
26087: EMPTY
26088: LIST
26089: LIST
26090: PUSH
26091: LD_INT 1
26093: NEG
26094: PUSH
26095: LD_INT 0
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 1
26116: NEG
26117: PUSH
26118: LD_INT 2
26120: NEG
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 0
26128: PUSH
26129: LD_INT 2
26131: NEG
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: PUSH
26151: LD_INT 0
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 1
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PUSH
26168: LD_INT 2
26170: PUSH
26171: LD_INT 2
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: LD_INT 1
26180: PUSH
26181: LD_INT 2
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 0
26190: PUSH
26191: LD_INT 2
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 1
26200: NEG
26201: PUSH
26202: LD_INT 1
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: PUSH
26209: LD_INT 2
26211: NEG
26212: PUSH
26213: LD_INT 0
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 2
26222: NEG
26223: PUSH
26224: LD_INT 1
26226: NEG
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 2
26234: NEG
26235: PUSH
26236: LD_INT 2
26238: NEG
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: LIST
26260: LIST
26261: LIST
26262: LIST
26263: LIST
26264: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26265: LD_ADDR_VAR 0 23
26269: PUSH
26270: LD_INT 0
26272: PUSH
26273: LD_INT 0
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 0
26282: PUSH
26283: LD_INT 1
26285: NEG
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: PUSH
26294: LD_INT 0
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: PUSH
26301: LD_INT 1
26303: PUSH
26304: LD_INT 1
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 1
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 1
26323: NEG
26324: PUSH
26325: LD_INT 0
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 1
26334: NEG
26335: PUSH
26336: LD_INT 1
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 1
26346: NEG
26347: PUSH
26348: LD_INT 2
26350: NEG
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: LD_INT 0
26358: PUSH
26359: LD_INT 2
26361: NEG
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 1
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 2
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 2
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 2
26400: PUSH
26401: LD_INT 2
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: LD_INT 1
26410: PUSH
26411: LD_INT 2
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 0
26420: PUSH
26421: LD_INT 2
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: NEG
26431: PUSH
26432: LD_INT 1
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: PUSH
26439: LD_INT 2
26441: NEG
26442: PUSH
26443: LD_INT 0
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 2
26452: NEG
26453: PUSH
26454: LD_INT 1
26456: NEG
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 2
26464: NEG
26465: PUSH
26466: LD_INT 2
26468: NEG
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: LD_INT 2
26476: NEG
26477: PUSH
26478: LD_INT 3
26480: NEG
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: NEG
26489: PUSH
26490: LD_INT 3
26492: NEG
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: LD_INT 1
26500: PUSH
26501: LD_INT 2
26503: NEG
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 2
26511: PUSH
26512: LD_INT 1
26514: NEG
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: LIST
26527: LIST
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26545: LD_ADDR_VAR 0 24
26549: PUSH
26550: LD_INT 0
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 0
26562: PUSH
26563: LD_INT 1
26565: NEG
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 1
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 0
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 1
26603: NEG
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: NEG
26627: PUSH
26628: LD_INT 2
26630: NEG
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 0
26638: PUSH
26639: LD_INT 2
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 1
26649: PUSH
26650: LD_INT 1
26652: NEG
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 2
26660: PUSH
26661: LD_INT 0
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: LD_INT 2
26670: PUSH
26671: LD_INT 1
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: PUSH
26678: LD_INT 2
26680: PUSH
26681: LD_INT 2
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 1
26690: PUSH
26691: LD_INT 2
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 2
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 1
26710: NEG
26711: PUSH
26712: LD_INT 1
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 2
26721: NEG
26722: PUSH
26723: LD_INT 0
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 2
26732: NEG
26733: PUSH
26734: LD_INT 1
26736: NEG
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 2
26744: NEG
26745: PUSH
26746: LD_INT 2
26748: NEG
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 1
26756: PUSH
26757: LD_INT 2
26759: NEG
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: LD_INT 1
26770: NEG
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 3
26778: PUSH
26779: LD_INT 1
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PUSH
26786: LD_INT 3
26788: PUSH
26789: LD_INT 2
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: LIST
26800: LIST
26801: LIST
26802: LIST
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26821: LD_ADDR_VAR 0 25
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: LD_INT 0
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 1
26841: NEG
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: PUSH
26860: LD_INT 1
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 0
26869: PUSH
26870: LD_INT 1
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: NEG
26880: PUSH
26881: LD_INT 0
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 1
26890: NEG
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 2
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: LD_INT 2
26917: NEG
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 1
26928: NEG
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 2
26946: PUSH
26947: LD_INT 1
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 2
26956: PUSH
26957: LD_INT 2
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PUSH
26964: LD_INT 1
26966: PUSH
26967: LD_INT 2
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PUSH
26974: LD_INT 0
26976: PUSH
26977: LD_INT 2
26979: PUSH
26980: EMPTY
26981: LIST
26982: LIST
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: LD_INT 1
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 2
26997: NEG
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 2
27008: NEG
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 2
27020: NEG
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 3
27032: PUSH
27033: LD_INT 1
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 3
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 2
27052: PUSH
27053: LD_INT 3
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: PUSH
27063: LD_INT 3
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: LIST
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27095: LD_ADDR_VAR 0 26
27099: PUSH
27100: LD_INT 0
27102: PUSH
27103: LD_INT 0
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 0
27112: PUSH
27113: LD_INT 1
27115: NEG
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: LD_INT 1
27123: PUSH
27124: LD_INT 0
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 1
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: LD_INT 1
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 1
27153: NEG
27154: PUSH
27155: LD_INT 0
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 1
27164: NEG
27165: PUSH
27166: LD_INT 1
27168: NEG
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: LD_INT 1
27176: NEG
27177: PUSH
27178: LD_INT 2
27180: NEG
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 0
27188: PUSH
27189: LD_INT 2
27191: NEG
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: PUSH
27200: LD_INT 1
27202: NEG
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 2
27210: PUSH
27211: LD_INT 0
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 2
27220: PUSH
27221: LD_INT 1
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 2
27230: PUSH
27231: LD_INT 2
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: LD_INT 1
27240: PUSH
27241: LD_INT 2
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 0
27250: PUSH
27251: LD_INT 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 1
27260: NEG
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: PUSH
27269: LD_INT 2
27271: NEG
27272: PUSH
27273: LD_INT 0
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PUSH
27280: LD_INT 2
27282: NEG
27283: PUSH
27284: LD_INT 1
27286: NEG
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 2
27294: NEG
27295: PUSH
27296: LD_INT 2
27298: NEG
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: PUSH
27304: LD_INT 2
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: LD_INT 3
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 2
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 2
27337: NEG
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: EMPTY
27347: LIST
27348: LIST
27349: LIST
27350: LIST
27351: LIST
27352: LIST
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27371: LD_ADDR_VAR 0 27
27375: PUSH
27376: LD_INT 0
27378: PUSH
27379: LD_INT 0
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: LD_INT 1
27391: NEG
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 1
27399: PUSH
27400: LD_INT 0
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: LD_INT 1
27409: PUSH
27410: LD_INT 1
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 0
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 1
27429: NEG
27430: PUSH
27431: LD_INT 0
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: LD_INT 1
27440: NEG
27441: PUSH
27442: LD_INT 1
27444: NEG
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 1
27452: NEG
27453: PUSH
27454: LD_INT 2
27456: NEG
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 0
27464: PUSH
27465: LD_INT 2
27467: NEG
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 1
27475: PUSH
27476: LD_INT 1
27478: NEG
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: PUSH
27487: LD_INT 0
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 2
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 2
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 1
27516: PUSH
27517: LD_INT 2
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 0
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 1
27536: NEG
27537: PUSH
27538: LD_INT 1
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 2
27547: NEG
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 2
27558: NEG
27559: PUSH
27560: LD_INT 1
27562: NEG
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 2
27570: NEG
27571: PUSH
27572: LD_INT 2
27574: NEG
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 1
27582: NEG
27583: PUSH
27584: LD_INT 2
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PUSH
27591: LD_INT 2
27593: NEG
27594: PUSH
27595: LD_INT 1
27597: PUSH
27598: EMPTY
27599: LIST
27600: LIST
27601: PUSH
27602: LD_INT 3
27604: NEG
27605: PUSH
27606: LD_INT 1
27608: NEG
27609: PUSH
27610: EMPTY
27611: LIST
27612: LIST
27613: PUSH
27614: LD_INT 3
27616: NEG
27617: PUSH
27618: LD_INT 2
27620: NEG
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: LIST
27630: LIST
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27651: LD_ADDR_VAR 0 28
27655: PUSH
27656: LD_INT 0
27658: PUSH
27659: LD_INT 0
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 0
27668: PUSH
27669: LD_INT 1
27671: NEG
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 1
27679: PUSH
27680: LD_INT 0
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 1
27689: PUSH
27690: LD_INT 1
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 0
27699: PUSH
27700: LD_INT 1
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 1
27709: NEG
27710: PUSH
27711: LD_INT 0
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 1
27720: NEG
27721: PUSH
27722: LD_INT 1
27724: NEG
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: LD_INT 2
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: LD_INT 2
27747: NEG
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 1
27758: NEG
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 2
27776: PUSH
27777: LD_INT 1
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 2
27786: PUSH
27787: LD_INT 2
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 1
27796: PUSH
27797: LD_INT 2
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 0
27806: PUSH
27807: LD_INT 2
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 1
27816: NEG
27817: PUSH
27818: LD_INT 1
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 2
27827: NEG
27828: PUSH
27829: LD_INT 0
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: LD_INT 2
27838: NEG
27839: PUSH
27840: LD_INT 1
27842: NEG
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: NEG
27851: PUSH
27852: LD_INT 2
27854: NEG
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 2
27862: NEG
27863: PUSH
27864: LD_INT 3
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 1
27874: NEG
27875: PUSH
27876: LD_INT 3
27878: NEG
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 3
27886: NEG
27887: PUSH
27888: LD_INT 1
27890: NEG
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 3
27898: NEG
27899: PUSH
27900: LD_INT 2
27902: NEG
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27933: LD_ADDR_VAR 0 29
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 0
27950: PUSH
27951: LD_INT 1
27953: NEG
27954: PUSH
27955: EMPTY
27956: LIST
27957: LIST
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 1
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 1
27991: NEG
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 1
28002: NEG
28003: PUSH
28004: LD_INT 1
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 1
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: LD_INT 2
28029: NEG
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 1
28037: PUSH
28038: LD_INT 1
28040: NEG
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: LD_INT 1
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 1
28088: NEG
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 2
28099: NEG
28100: PUSH
28101: LD_INT 1
28103: NEG
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 2
28111: NEG
28112: PUSH
28113: LD_INT 2
28115: NEG
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: LD_INT 3
28127: NEG
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 2
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 3
28146: PUSH
28147: LD_INT 1
28149: PUSH
28150: EMPTY
28151: LIST
28152: LIST
28153: PUSH
28154: LD_INT 1
28156: PUSH
28157: LD_INT 3
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 1
28166: NEG
28167: PUSH
28168: LD_INT 2
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 3
28177: NEG
28178: PUSH
28179: LD_INT 2
28181: NEG
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28212: LD_ADDR_VAR 0 30
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 0
28305: PUSH
28306: LD_INT 2
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 1
28316: PUSH
28317: LD_INT 1
28319: NEG
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 2
28327: PUSH
28328: LD_INT 0
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 2
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: PUSH
28348: LD_INT 2
28350: PUSH
28351: EMPTY
28352: LIST
28353: LIST
28354: PUSH
28355: LD_INT 1
28357: PUSH
28358: LD_INT 2
28360: PUSH
28361: EMPTY
28362: LIST
28363: LIST
28364: PUSH
28365: LD_INT 1
28367: NEG
28368: PUSH
28369: LD_INT 1
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: LD_INT 2
28378: NEG
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 2
28389: NEG
28390: PUSH
28391: LD_INT 1
28393: NEG
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 1
28401: NEG
28402: PUSH
28403: LD_INT 3
28405: NEG
28406: PUSH
28407: EMPTY
28408: LIST
28409: LIST
28410: PUSH
28411: LD_INT 1
28413: PUSH
28414: LD_INT 2
28416: NEG
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: LD_INT 2
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 2
28434: PUSH
28435: LD_INT 3
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PUSH
28442: LD_INT 2
28444: NEG
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 3
28455: NEG
28456: PUSH
28457: LD_INT 1
28459: NEG
28460: PUSH
28461: EMPTY
28462: LIST
28463: LIST
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28490: LD_ADDR_VAR 0 31
28494: PUSH
28495: LD_INT 0
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: LD_INT 1
28510: NEG
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: PUSH
28516: LD_INT 1
28518: PUSH
28519: LD_INT 0
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 0
28538: PUSH
28539: LD_INT 1
28541: PUSH
28542: EMPTY
28543: LIST
28544: LIST
28545: PUSH
28546: LD_INT 1
28548: NEG
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 1
28563: NEG
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: NEG
28572: PUSH
28573: LD_INT 2
28575: NEG
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 1
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 2
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 2
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 2
28614: PUSH
28615: LD_INT 2
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 1
28624: PUSH
28625: LD_INT 2
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 0
28634: PUSH
28635: LD_INT 2
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 1
28644: NEG
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 2
28655: NEG
28656: PUSH
28657: LD_INT 1
28659: NEG
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 2
28671: NEG
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 3
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 3
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: LD_INT 3
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 1
28722: NEG
28723: PUSH
28724: LD_INT 2
28726: PUSH
28727: EMPTY
28728: LIST
28729: LIST
28730: PUSH
28731: LD_INT 3
28733: NEG
28734: PUSH
28735: LD_INT 2
28737: NEG
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28768: LD_ADDR_VAR 0 32
28772: PUSH
28773: LD_INT 0
28775: PUSH
28776: LD_INT 0
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 0
28785: PUSH
28786: LD_INT 1
28788: NEG
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: LD_INT 1
28796: PUSH
28797: LD_INT 0
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 1
28806: PUSH
28807: LD_INT 1
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: LD_INT 1
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 1
28826: NEG
28827: PUSH
28828: LD_INT 0
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 1
28837: NEG
28838: PUSH
28839: LD_INT 1
28841: NEG
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: NEG
28850: PUSH
28851: LD_INT 2
28853: NEG
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 0
28861: PUSH
28862: LD_INT 2
28864: NEG
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: LD_INT 1
28872: PUSH
28873: LD_INT 1
28875: NEG
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 2
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 2
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 1
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 0
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 1
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 2
28934: NEG
28935: PUSH
28936: LD_INT 0
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 2
28945: NEG
28946: PUSH
28947: LD_INT 1
28949: NEG
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 1
28957: NEG
28958: PUSH
28959: LD_INT 3
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 1
28969: PUSH
28970: LD_INT 2
28972: NEG
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 3
28980: PUSH
28981: LD_INT 2
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: LD_INT 2
28990: PUSH
28991: LD_INT 3
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 2
29000: NEG
29001: PUSH
29002: LD_INT 1
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 3
29011: NEG
29012: PUSH
29013: LD_INT 1
29015: NEG
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29046: LD_ADDR_VAR 0 33
29050: PUSH
29051: LD_INT 0
29053: PUSH
29054: LD_INT 0
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PUSH
29061: LD_INT 0
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: PUSH
29075: LD_INT 0
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 0
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 1
29115: NEG
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: LD_INT 2
29131: NEG
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 2
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 2
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 2
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 0
29180: PUSH
29181: LD_INT 2
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: PUSH
29188: LD_INT 1
29190: NEG
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 2
29201: NEG
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 2
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: NEG
29225: PUSH
29226: LD_INT 2
29228: NEG
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 3
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 2
29248: PUSH
29249: LD_INT 1
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 3
29259: PUSH
29260: LD_INT 1
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: LD_INT 3
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 1
29279: NEG
29280: PUSH
29281: LD_INT 2
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 3
29290: NEG
29291: PUSH
29292: LD_INT 2
29294: NEG
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29325: LD_ADDR_VAR 0 34
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: LD_INT 0
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 1
29353: PUSH
29354: LD_INT 0
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 1
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 0
29373: PUSH
29374: LD_INT 1
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 1
29383: NEG
29384: PUSH
29385: LD_INT 0
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 1
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 2
29440: PUSH
29441: LD_INT 1
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 2
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: LD_INT 2
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 1
29470: NEG
29471: PUSH
29472: LD_INT 1
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 2
29481: NEG
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 2
29492: NEG
29493: PUSH
29494: LD_INT 1
29496: NEG
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 2
29504: NEG
29505: PUSH
29506: LD_INT 2
29508: NEG
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: LD_INT 3
29520: NEG
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 1
29528: PUSH
29529: LD_INT 2
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 3
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 2
29549: PUSH
29550: LD_INT 3
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 2
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 3
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29605: LD_ADDR_VAR 0 35
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 0
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 0
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 1
29663: NEG
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 1
29674: NEG
29675: PUSH
29676: LD_INT 1
29678: NEG
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: LD_INT 1
29700: NEG
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29717: LD_ADDR_VAR 0 36
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: LD_INT 1
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 1
29775: NEG
29776: PUSH
29777: LD_INT 0
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: NEG
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 2
29802: NEG
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: LD_INT 2
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29829: LD_ADDR_VAR 0 37
29833: PUSH
29834: LD_INT 0
29836: PUSH
29837: LD_INT 0
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: LD_INT 0
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 1
29857: PUSH
29858: LD_INT 0
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: LD_INT 0
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: LD_INT 1
29902: NEG
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 1
29921: NEG
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29941: LD_ADDR_VAR 0 38
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: LD_INT 0
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 0
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: PUSH
29970: LD_INT 0
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: LD_INT 1
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: LD_INT 1
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: LD_INT 0
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 2
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30053: LD_ADDR_VAR 0 39
30057: PUSH
30058: LD_INT 0
30060: PUSH
30061: LD_INT 0
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: LD_INT 1
30073: NEG
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: PUSH
30082: LD_INT 0
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: LD_INT 1
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 0
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: NEG
30112: PUSH
30113: LD_INT 0
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: NEG
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: LD_INT 2
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 1
30146: PUSH
30147: LD_INT 2
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30165: LD_ADDR_VAR 0 40
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: LD_INT 1
30185: NEG
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 0
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: NEG
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: LD_INT 1
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30277: LD_ADDR_VAR 0 41
30281: PUSH
30282: LD_INT 0
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: LD_INT 0
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: LD_INT 2
30362: NEG
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: LD_INT 1
30373: NEG
30374: PUSH
30375: EMPTY
30376: LIST
30377: LIST
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 2
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 2
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: LD_INT 0
30436: PUSH
30437: EMPTY
30438: LIST
30439: LIST
30440: PUSH
30441: LD_INT 2
30443: NEG
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 2
30455: NEG
30456: PUSH
30457: LD_INT 2
30459: NEG
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: LD_INT 3
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 2
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 3
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 3
30500: PUSH
30501: LD_INT 1
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 3
30510: PUSH
30511: LD_INT 2
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 3
30520: PUSH
30521: LD_INT 3
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 2
30530: PUSH
30531: LD_INT 3
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 3
30551: NEG
30552: PUSH
30553: LD_INT 0
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 3
30562: NEG
30563: PUSH
30564: LD_INT 1
30566: NEG
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 3
30574: NEG
30575: PUSH
30576: LD_INT 2
30578: NEG
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 3
30586: NEG
30587: PUSH
30588: LD_INT 3
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30627: LD_ADDR_VAR 0 42
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: LD_INT 0
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: LD_INT 1
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 0
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: NEG
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 0
30720: PUSH
30721: LD_INT 2
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 2
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 2
30752: PUSH
30753: LD_INT 2
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: LD_INT 2
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 2
30805: NEG
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 2
30817: NEG
30818: PUSH
30819: LD_INT 3
30821: NEG
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 3
30833: NEG
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 0
30841: PUSH
30842: LD_INT 3
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 2
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 3
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 3
30873: PUSH
30874: LD_INT 3
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: LD_INT 3
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: LD_INT 2
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 3
30924: NEG
30925: PUSH
30926: LD_INT 2
30928: NEG
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 3
30936: NEG
30937: PUSH
30938: LD_INT 3
30940: NEG
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30977: LD_ADDR_VAR 0 43
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: LD_INT 0
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 0
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 1
31046: NEG
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: NEG
31059: PUSH
31060: LD_INT 2
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 0
31070: PUSH
31071: LD_INT 2
31073: NEG
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 1
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: LD_INT 0
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 1
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: NEG
31133: PUSH
31134: LD_INT 1
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 2
31143: NEG
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: LD_INT 1
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 1
31166: NEG
31167: PUSH
31168: LD_INT 3
31170: NEG
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PUSH
31176: LD_INT 0
31178: PUSH
31179: LD_INT 3
31181: NEG
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: LD_INT 2
31192: NEG
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 2
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 3
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 3
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: LD_INT 3
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 1
31251: NEG
31252: PUSH
31253: LD_INT 2
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 2
31262: NEG
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 3
31273: NEG
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 3
31284: NEG
31285: PUSH
31286: LD_INT 1
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31325: LD_ADDR_VAR 0 44
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 0
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: LD_INT 1
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 0
31373: PUSH
31374: LD_INT 1
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 1
31383: NEG
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: NEG
31407: PUSH
31408: LD_INT 2
31410: NEG
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 1
31418: PUSH
31419: LD_INT 1
31421: NEG
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 2
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 2
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 2
31449: PUSH
31450: LD_INT 2
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 1
31459: PUSH
31460: LD_INT 2
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: NEG
31470: PUSH
31471: LD_INT 1
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 2
31480: NEG
31481: PUSH
31482: LD_INT 0
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 2
31491: NEG
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: NEG
31504: PUSH
31505: LD_INT 2
31507: NEG
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 2
31515: NEG
31516: PUSH
31517: LD_INT 3
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 3
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 3
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 3
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 3
31568: PUSH
31569: LD_INT 3
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 2
31578: PUSH
31579: LD_INT 3
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 2
31588: NEG
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 3
31599: NEG
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 3
31610: NEG
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 3
31622: NEG
31623: PUSH
31624: LD_INT 2
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 3
31634: NEG
31635: PUSH
31636: LD_INT 3
31638: NEG
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31675: LD_ADDR_VAR 0 45
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 0
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: NEG
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 1
31744: NEG
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 1
31756: NEG
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 0
31768: PUSH
31769: LD_INT 2
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 1
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 2
31790: PUSH
31791: LD_INT 1
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PUSH
31798: LD_INT 2
31800: PUSH
31801: LD_INT 2
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: LD_INT 2
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: LD_INT 2
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 1
31830: NEG
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: LD_INT 1
31845: NEG
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 2
31853: NEG
31854: PUSH
31855: LD_INT 2
31857: NEG
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 2
31865: NEG
31866: PUSH
31867: LD_INT 3
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: LD_INT 3
31881: NEG
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 0
31889: PUSH
31890: LD_INT 3
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: LD_INT 2
31903: NEG
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 3
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 3
31921: PUSH
31922: LD_INT 3
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 2
31931: PUSH
31932: LD_INT 3
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 1
31941: PUSH
31942: LD_INT 3
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 0
31951: PUSH
31952: LD_INT 3
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 1
31961: NEG
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 3
31972: NEG
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 3
31984: NEG
31985: PUSH
31986: LD_INT 3
31988: NEG
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32025: LD_ADDR_VAR 0 46
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: LD_INT 1
32045: NEG
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 1
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: LD_INT 1
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 1
32083: NEG
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: NEG
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 1
32106: NEG
32107: PUSH
32108: LD_INT 2
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: LD_INT 2
32121: NEG
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 1
32129: PUSH
32130: LD_INT 1
32132: NEG
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: LD_INT 2
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: LD_INT 2
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 0
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 2
32202: NEG
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: NEG
32215: PUSH
32216: LD_INT 3
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: LD_INT 3
32229: NEG
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: LD_INT 2
32240: NEG
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 2
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 3
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 3
32269: PUSH
32270: LD_INT 1
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 3
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: NEG
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 3
32321: NEG
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 3
32332: NEG
32333: PUSH
32334: LD_INT 1
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: LIST
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32373: LD_ADDR_VAR 0 47
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 0
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: LD_INT 0
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 1
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 0
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: LD_INT 0
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: LD_INT 1
32446: NEG
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: NEG
32455: PUSH
32456: LD_INT 2
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: LD_INT 2
32469: NEG
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: LD_INT 1
32480: NEG
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: LD_INT 1
32492: NEG
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 2
32500: NEG
32501: PUSH
32502: LD_INT 2
32504: NEG
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32524: LD_ADDR_VAR 0 48
32528: PUSH
32529: LD_INT 0
32531: PUSH
32532: LD_INT 0
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: LD_INT 1
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PUSH
32570: LD_INT 0
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: PUSH
32580: LD_INT 1
32582: NEG
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: LD_INT 1
32597: NEG
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 1
32605: NEG
32606: PUSH
32607: LD_INT 2
32609: NEG
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 0
32617: PUSH
32618: LD_INT 2
32620: NEG
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 1
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 2
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32671: LD_ADDR_VAR 0 49
32675: PUSH
32676: LD_INT 0
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: LD_INT 1
32691: NEG
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: LD_INT 1
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: LD_INT 1
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 0
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 1
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: LD_INT 1
32755: NEG
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 2
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: LD_INT 2
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: LD_INT 2
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: LIST
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32815: LD_ADDR_VAR 0 50
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: LD_INT 1
32835: NEG
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 1
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 0
32863: PUSH
32864: LD_INT 1
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 1
32884: NEG
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 2
32906: PUSH
32907: LD_INT 2
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: LD_INT 2
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32959: LD_ADDR_VAR 0 51
32963: PUSH
32964: LD_INT 0
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 0
32976: PUSH
32977: LD_INT 1
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: LD_INT 0
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: NEG
33029: PUSH
33030: LD_INT 1
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33106: LD_ADDR_VAR 0 52
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 0
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: LD_INT 1
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: NEG
33176: PUSH
33177: LD_INT 1
33179: NEG
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: NEG
33188: PUSH
33189: LD_INT 2
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 2
33210: NEG
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33257: LD_ADDR_VAR 0 53
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 0
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: LD_INT 1
33277: NEG
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 1
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 1
33326: NEG
33327: PUSH
33328: LD_INT 1
33330: NEG
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: LD_INT 2
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: LD_INT 2
33353: NEG
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 1
33364: NEG
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 2
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 2
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: LD_INT 2
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 0
33412: PUSH
33413: LD_INT 2
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 1
33422: NEG
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 2
33444: NEG
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33487: LD_ADDR_VAR 0 54
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: LD_INT 1
33507: NEG
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: PUSH
33516: LD_INT 0
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 1
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 0
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 1
33545: NEG
33546: PUSH
33547: LD_INT 0
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: NEG
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: LD_INT 2
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 0
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 1
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 2
33602: PUSH
33603: LD_INT 0
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: PUSH
33613: LD_INT 1
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 2
33622: PUSH
33623: LD_INT 2
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: LD_INT 2
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: LD_INT 2
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: LD_INT 1
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 2
33663: NEG
33664: PUSH
33665: LD_INT 0
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 2
33686: NEG
33687: PUSH
33688: LD_INT 2
33690: NEG
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33717: LD_ADDR_VAR 0 55
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 0
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 1
33755: PUSH
33756: LD_INT 1
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 1
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 1
33775: NEG
33776: PUSH
33777: LD_INT 0
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 2
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: PUSH
33853: LD_INT 2
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: PUSH
33863: LD_INT 2
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 0
33872: PUSH
33873: LD_INT 2
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: NEG
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: EMPTY
33888: LIST
33889: LIST
33890: PUSH
33891: LD_INT 2
33893: NEG
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 2
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 2
33916: NEG
33917: PUSH
33918: LD_INT 2
33920: NEG
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33947: LD_ADDR_VAR 0 56
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 0
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 1
33967: NEG
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 1
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: NEG
34006: PUSH
34007: LD_INT 0
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: LD_INT 2
34032: NEG
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 0
34040: PUSH
34041: LD_INT 2
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 1
34051: PUSH
34052: LD_INT 1
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 2
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 2
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 2
34082: PUSH
34083: LD_INT 2
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 1
34092: PUSH
34093: LD_INT 2
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: LD_INT 1
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 2
34123: NEG
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 2
34134: NEG
34135: PUSH
34136: LD_INT 1
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 2
34146: NEG
34147: PUSH
34148: LD_INT 2
34150: NEG
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34177: LD_ADDR_VAR 0 57
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 1
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 0
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 1
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 1
34235: NEG
34236: PUSH
34237: LD_INT 0
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 1
34258: NEG
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 1
34281: PUSH
34282: LD_INT 1
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 2
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: PUSH
34303: LD_INT 1
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 0
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 2
34353: NEG
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: LD_INT 1
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 2
34376: NEG
34377: PUSH
34378: LD_INT 2
34380: NEG
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34407: LD_ADDR_VAR 0 58
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: LD_INT 1
34427: NEG
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: LD_INT 0
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 1
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 1
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: NEG
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 1
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: LD_INT 2
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 2
34503: NEG
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: PUSH
34509: LD_INT 1
34511: PUSH
34512: LD_INT 1
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: LD_INT 0
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: PUSH
34543: LD_INT 2
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: LD_INT 2
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 0
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: NEG
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: NEG
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 2
34594: NEG
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: LD_INT 2
34610: NEG
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34637: LD_ADDR_VAR 0 59
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34725: LD_ADDR_VAR 0 60
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 1
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 1
34794: NEG
34795: PUSH
34796: LD_INT 1
34798: NEG
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34813: LD_ADDR_VAR 0 61
34817: PUSH
34818: LD_INT 0
34820: PUSH
34821: LD_INT 0
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: LD_INT 0
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 1
34871: NEG
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: NEG
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34901: LD_ADDR_VAR 0 62
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34989: LD_ADDR_VAR 0 63
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: LD_INT 0
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: LD_INT 1
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 0
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: NEG
35048: PUSH
35049: LD_INT 0
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35077: LD_ADDR_VAR 0 64
35081: PUSH
35082: LD_INT 0
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 0
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 1
35115: PUSH
35116: LD_INT 1
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: LD_INT 1
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: ST_TO_ADDR
// end ; 1 :
35165: GO 41062
35167: LD_INT 1
35169: DOUBLE
35170: EQUAL
35171: IFTRUE 35175
35173: GO 37798
35175: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35176: LD_ADDR_VAR 0 11
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: LD_INT 3
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: LD_INT 3
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 2
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: LIST
35219: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35220: LD_ADDR_VAR 0 12
35224: PUSH
35225: LD_INT 2
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 3
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 3
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: LIST
35260: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35261: LD_ADDR_VAR 0 13
35265: PUSH
35266: LD_INT 3
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 3
35278: PUSH
35279: LD_INT 3
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 2
35288: PUSH
35289: LD_INT 3
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: LIST
35300: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35301: LD_ADDR_VAR 0 14
35305: PUSH
35306: LD_INT 1
35308: PUSH
35309: LD_INT 3
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: LD_INT 3
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 1
35328: NEG
35329: PUSH
35330: LD_INT 2
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: LIST
35341: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35342: LD_ADDR_VAR 0 15
35346: PUSH
35347: LD_INT 2
35349: NEG
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 3
35360: NEG
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 3
35371: NEG
35372: PUSH
35373: LD_INT 1
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: LIST
35385: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35386: LD_ADDR_VAR 0 16
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: LD_INT 3
35397: NEG
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 3
35405: NEG
35406: PUSH
35407: LD_INT 2
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 3
35417: NEG
35418: PUSH
35419: LD_INT 3
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: LIST
35431: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35432: LD_ADDR_VAR 0 17
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: LD_INT 3
35443: NEG
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: LD_INT 3
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 1
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: LIST
35475: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35476: LD_ADDR_VAR 0 18
35480: PUSH
35481: LD_INT 2
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 3
35494: PUSH
35495: LD_INT 0
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 3
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: LIST
35516: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35517: LD_ADDR_VAR 0 19
35521: PUSH
35522: LD_INT 3
35524: PUSH
35525: LD_INT 2
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 3
35534: PUSH
35535: LD_INT 3
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 2
35544: PUSH
35545: LD_INT 3
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: LIST
35556: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35557: LD_ADDR_VAR 0 20
35561: PUSH
35562: LD_INT 1
35564: PUSH
35565: LD_INT 3
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: LD_INT 3
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 2
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: LIST
35597: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35598: LD_ADDR_VAR 0 21
35602: PUSH
35603: LD_INT 2
35605: NEG
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 3
35616: NEG
35617: PUSH
35618: LD_INT 0
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: LD_INT 1
35631: NEG
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: LIST
35641: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35642: LD_ADDR_VAR 0 22
35646: PUSH
35647: LD_INT 2
35649: NEG
35650: PUSH
35651: LD_INT 3
35653: NEG
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 3
35661: NEG
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 3
35673: NEG
35674: PUSH
35675: LD_INT 3
35677: NEG
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: LIST
35687: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35688: LD_ADDR_VAR 0 23
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: LD_INT 3
35698: NEG
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 4
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 1
35718: PUSH
35719: LD_INT 3
35721: NEG
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: LIST
35731: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35732: LD_ADDR_VAR 0 24
35736: PUSH
35737: LD_INT 3
35739: PUSH
35740: LD_INT 0
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 3
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 4
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: LIST
35772: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35773: LD_ADDR_VAR 0 25
35777: PUSH
35778: LD_INT 3
35780: PUSH
35781: LD_INT 3
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 4
35790: PUSH
35791: LD_INT 3
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: LD_INT 4
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: LIST
35812: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35813: LD_ADDR_VAR 0 26
35817: PUSH
35818: LD_INT 0
35820: PUSH
35821: LD_INT 3
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: LD_INT 4
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 1
35840: NEG
35841: PUSH
35842: LD_INT 3
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: LIST
35853: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35854: LD_ADDR_VAR 0 27
35858: PUSH
35859: LD_INT 3
35861: NEG
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 3
35872: NEG
35873: PUSH
35874: LD_INT 1
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 4
35883: NEG
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: LIST
35897: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35898: LD_ADDR_VAR 0 28
35902: PUSH
35903: LD_INT 3
35905: NEG
35906: PUSH
35907: LD_INT 3
35909: NEG
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 3
35917: NEG
35918: PUSH
35919: LD_INT 4
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 4
35929: NEG
35930: PUSH
35931: LD_INT 3
35933: NEG
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: LIST
35943: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35944: LD_ADDR_VAR 0 29
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 4
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 4
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 3
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 5
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 5
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 4
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: NEG
36054: PUSH
36055: LD_INT 6
36057: NEG
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: LD_INT 6
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 1
36076: PUSH
36077: LD_INT 5
36079: NEG
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36099: LD_ADDR_VAR 0 30
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 3
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 3
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 3
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 4
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 4
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 4
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 5
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 5
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 5
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 6
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 6
36220: PUSH
36221: LD_INT 1
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36242: LD_ADDR_VAR 0 31
36246: PUSH
36247: LD_INT 3
36249: PUSH
36250: LD_INT 2
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 3
36259: PUSH
36260: LD_INT 3
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 3
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 4
36279: PUSH
36280: LD_INT 3
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 4
36289: PUSH
36290: LD_INT 4
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 3
36299: PUSH
36300: LD_INT 4
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 5
36309: PUSH
36310: LD_INT 4
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 5
36319: PUSH
36320: LD_INT 5
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 4
36329: PUSH
36330: LD_INT 5
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 6
36339: PUSH
36340: LD_INT 5
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 6
36349: PUSH
36350: LD_INT 6
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 5
36359: PUSH
36360: LD_INT 6
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36381: LD_ADDR_VAR 0 32
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: LD_INT 3
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 3
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: LD_INT 2
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 4
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 4
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 3
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 5
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 5
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 4
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 6
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 6
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: LD_INT 5
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36524: LD_ADDR_VAR 0 33
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: NEG
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 3
36553: NEG
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 3
36565: NEG
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 4
36576: NEG
36577: PUSH
36578: LD_INT 0
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 4
36587: NEG
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 4
36599: NEG
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 5
36610: NEG
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 5
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 5
36633: NEG
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 6
36644: NEG
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 6
36655: NEG
36656: PUSH
36657: LD_INT 1
36659: NEG
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36679: LD_ADDR_VAR 0 34
36683: PUSH
36684: LD_INT 2
36686: NEG
36687: PUSH
36688: LD_INT 3
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: LD_INT 2
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 3
36710: NEG
36711: PUSH
36712: LD_INT 3
36714: NEG
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 3
36722: NEG
36723: PUSH
36724: LD_INT 4
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 4
36734: NEG
36735: PUSH
36736: LD_INT 3
36738: NEG
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 4
36746: NEG
36747: PUSH
36748: LD_INT 4
36750: NEG
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 4
36758: NEG
36759: PUSH
36760: LD_INT 5
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 5
36770: NEG
36771: PUSH
36772: LD_INT 4
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 5
36782: NEG
36783: PUSH
36784: LD_INT 5
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 5
36794: NEG
36795: PUSH
36796: LD_INT 6
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 6
36806: NEG
36807: PUSH
36808: LD_INT 5
36810: NEG
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 6
36818: NEG
36819: PUSH
36820: LD_INT 6
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36842: LD_ADDR_VAR 0 41
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: NEG
36861: PUSH
36862: LD_INT 3
36864: NEG
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 1
36872: PUSH
36873: LD_INT 2
36875: NEG
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: LIST
36885: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36886: LD_ADDR_VAR 0 42
36890: PUSH
36891: LD_INT 2
36893: PUSH
36894: LD_INT 0
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: PUSH
36901: LD_INT 2
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: LD_INT 1
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: LIST
36926: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36927: LD_ADDR_VAR 0 43
36931: PUSH
36932: LD_INT 2
36934: PUSH
36935: LD_INT 2
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 2
36954: PUSH
36955: LD_INT 3
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: LIST
36966: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36967: LD_ADDR_VAR 0 44
36971: PUSH
36972: LD_INT 0
36974: PUSH
36975: LD_INT 2
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 1
36984: PUSH
36985: LD_INT 3
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 1
36994: NEG
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37008: LD_ADDR_VAR 0 45
37012: PUSH
37013: LD_INT 2
37015: NEG
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 2
37026: NEG
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 3
37037: NEG
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: LIST
37051: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37052: LD_ADDR_VAR 0 46
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 2
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: NEG
37072: PUSH
37073: LD_INT 3
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: LIST
37097: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37098: LD_ADDR_VAR 0 47
37102: PUSH
37103: LD_INT 2
37105: NEG
37106: PUSH
37107: LD_INT 3
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37131: LD_ADDR_VAR 0 48
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: LD_INT 2
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 2
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37162: LD_ADDR_VAR 0 49
37166: PUSH
37167: LD_INT 3
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 3
37179: PUSH
37180: LD_INT 2
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37191: LD_ADDR_VAR 0 50
37195: PUSH
37196: LD_INT 2
37198: PUSH
37199: LD_INT 3
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 1
37208: PUSH
37209: LD_INT 3
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37220: LD_ADDR_VAR 0 51
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: LD_INT 2
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 2
37238: NEG
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37251: LD_ADDR_VAR 0 52
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: LD_INT 1
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 3
37270: NEG
37271: PUSH
37272: LD_INT 2
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37284: LD_ADDR_VAR 0 53
37288: PUSH
37289: LD_INT 1
37291: NEG
37292: PUSH
37293: LD_INT 3
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: LD_INT 3
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 1
37314: PUSH
37315: LD_INT 2
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: LIST
37327: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37328: LD_ADDR_VAR 0 54
37332: PUSH
37333: LD_INT 2
37335: PUSH
37336: LD_INT 1
37338: NEG
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 3
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 3
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: LIST
37368: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37369: LD_ADDR_VAR 0 55
37373: PUSH
37374: LD_INT 3
37376: PUSH
37377: LD_INT 2
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 3
37386: PUSH
37387: LD_INT 3
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 2
37396: PUSH
37397: LD_INT 3
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: LIST
37408: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37409: LD_ADDR_VAR 0 56
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: LD_INT 3
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 3
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 1
37436: NEG
37437: PUSH
37438: LD_INT 2
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: LIST
37449: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37450: LD_ADDR_VAR 0 57
37454: PUSH
37455: LD_INT 2
37457: NEG
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 3
37468: NEG
37469: PUSH
37470: LD_INT 0
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 3
37479: NEG
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: LIST
37493: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37494: LD_ADDR_VAR 0 58
37498: PUSH
37499: LD_INT 2
37501: NEG
37502: PUSH
37503: LD_INT 3
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 3
37513: NEG
37514: PUSH
37515: LD_INT 2
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 3
37525: NEG
37526: PUSH
37527: LD_INT 3
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: LIST
37539: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37540: LD_ADDR_VAR 0 59
37544: PUSH
37545: LD_INT 1
37547: NEG
37548: PUSH
37549: LD_INT 2
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 2
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 1
37573: NEG
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: EMPTY
37580: LIST
37581: LIST
37582: LIST
37583: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37584: LD_ADDR_VAR 0 60
37588: PUSH
37589: LD_INT 1
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 2
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 2
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: LIST
37624: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37625: LD_ADDR_VAR 0 61
37629: PUSH
37630: LD_INT 2
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 2
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: LD_INT 2
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: LIST
37664: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37665: LD_ADDR_VAR 0 62
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: LD_INT 2
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: LD_INT 2
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: LIST
37705: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37706: LD_ADDR_VAR 0 63
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: LD_INT 1
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 2
37724: NEG
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 2
37735: NEG
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: LIST
37749: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37750: LD_ADDR_VAR 0 64
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 2
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 2
37769: NEG
37770: PUSH
37771: LD_INT 1
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: LD_INT 2
37785: NEG
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: LIST
37795: ST_TO_ADDR
// end ; 2 :
37796: GO 41062
37798: LD_INT 2
37800: DOUBLE
37801: EQUAL
37802: IFTRUE 37806
37804: GO 41061
37806: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37807: LD_ADDR_VAR 0 29
37811: PUSH
37812: LD_INT 4
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 4
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 5
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 5
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 4
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 3
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 3
37875: PUSH
37876: LD_INT 1
37878: NEG
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 2
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 5
37897: PUSH
37898: LD_INT 2
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 3
37907: PUSH
37908: LD_INT 3
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 3
37917: PUSH
37918: LD_INT 2
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 4
37927: PUSH
37928: LD_INT 3
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 4
37937: PUSH
37938: LD_INT 4
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: LD_INT 4
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 2
37957: PUSH
37958: LD_INT 3
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 2
37967: PUSH
37968: LD_INT 2
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 4
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 3
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 1
38017: PUSH
38018: LD_INT 4
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 1
38027: PUSH
38028: LD_INT 5
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: LD_INT 5
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 1
38047: NEG
38048: PUSH
38049: LD_INT 4
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 3
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: PUSH
38070: LD_INT 5
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: LD_INT 3
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 3
38090: NEG
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 3
38101: NEG
38102: PUSH
38103: LD_INT 1
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 2
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 2
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 3
38135: NEG
38136: PUSH
38137: LD_INT 1
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 4
38146: NEG
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 4
38157: NEG
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 4
38169: NEG
38170: PUSH
38171: LD_INT 2
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: NEG
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 4
38192: NEG
38193: PUSH
38194: LD_INT 4
38196: NEG
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 4
38204: NEG
38205: PUSH
38206: LD_INT 5
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 3
38216: NEG
38217: PUSH
38218: LD_INT 4
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 3
38228: NEG
38229: PUSH
38230: LD_INT 3
38232: NEG
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 4
38240: NEG
38241: PUSH
38242: LD_INT 3
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 5
38252: NEG
38253: PUSH
38254: LD_INT 4
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 5
38264: NEG
38265: PUSH
38266: LD_INT 5
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 3
38276: NEG
38277: PUSH
38278: LD_INT 5
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 5
38288: NEG
38289: PUSH
38290: LD_INT 3
38292: NEG
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38345: LD_ADDR_VAR 0 30
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 4
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 4
38362: PUSH
38363: LD_INT 3
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 5
38372: PUSH
38373: LD_INT 4
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 5
38382: PUSH
38383: LD_INT 5
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 5
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 3
38402: PUSH
38403: LD_INT 4
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 3
38412: PUSH
38413: LD_INT 3
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 5
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 3
38432: PUSH
38433: LD_INT 5
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: LD_INT 3
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 2
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: LD_INT 3
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 1
38472: PUSH
38473: LD_INT 4
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 0
38482: PUSH
38483: LD_INT 4
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: NEG
38493: PUSH
38494: LD_INT 3
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 1
38503: NEG
38504: PUSH
38505: LD_INT 2
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: LD_INT 4
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 2
38524: NEG
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 4
38535: NEG
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 4
38546: NEG
38547: PUSH
38548: LD_INT 1
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 3
38558: NEG
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 3
38569: NEG
38570: PUSH
38571: LD_INT 1
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 4
38580: NEG
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 5
38591: NEG
38592: PUSH
38593: LD_INT 0
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 5
38602: NEG
38603: PUSH
38604: LD_INT 1
38606: NEG
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 5
38614: NEG
38615: PUSH
38616: LD_INT 2
38618: NEG
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 3
38626: NEG
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 3
38637: NEG
38638: PUSH
38639: LD_INT 3
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 3
38649: NEG
38650: PUSH
38651: LD_INT 4
38653: NEG
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 2
38661: NEG
38662: PUSH
38663: LD_INT 3
38665: NEG
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 2
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 3
38685: NEG
38686: PUSH
38687: LD_INT 2
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 4
38697: NEG
38698: PUSH
38699: LD_INT 3
38701: NEG
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 4
38709: NEG
38710: PUSH
38711: LD_INT 4
38713: NEG
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: LD_INT 4
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 4
38733: NEG
38734: PUSH
38735: LD_INT 2
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: LD_INT 4
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 0
38756: PUSH
38757: LD_INT 5
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: PUSH
38768: LD_INT 4
38770: NEG
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: LD_INT 4
38804: NEG
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 1
38812: NEG
38813: PUSH
38814: LD_INT 5
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: PUSH
38825: LD_INT 3
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 2
38835: NEG
38836: PUSH
38837: LD_INT 5
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38892: LD_ADDR_VAR 0 31
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: LD_INT 4
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: LD_INT 3
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 4
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 5
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 5
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 4
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 3
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: LD_INT 5
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: NEG
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: NEG
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 3
39003: NEG
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 3
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 4
39048: NEG
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 4
39059: NEG
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 4
39071: NEG
39072: PUSH
39073: LD_INT 2
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: LD_INT 2
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 4
39094: NEG
39095: PUSH
39096: LD_INT 4
39098: NEG
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 4
39106: NEG
39107: PUSH
39108: LD_INT 5
39110: NEG
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 3
39118: NEG
39119: PUSH
39120: LD_INT 4
39122: NEG
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 3
39130: NEG
39131: PUSH
39132: LD_INT 3
39134: NEG
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 4
39142: NEG
39143: PUSH
39144: LD_INT 3
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 5
39154: NEG
39155: PUSH
39156: LD_INT 4
39158: NEG
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 5
39166: NEG
39167: PUSH
39168: LD_INT 5
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 3
39178: NEG
39179: PUSH
39180: LD_INT 5
39182: NEG
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 5
39190: NEG
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 0
39213: PUSH
39214: LD_INT 4
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: LD_INT 3
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 1
39235: PUSH
39236: LD_INT 2
39238: NEG
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: LD_INT 3
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: LD_INT 4
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 2
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 4
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 4
39304: PUSH
39305: LD_INT 0
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 4
39314: PUSH
39315: LD_INT 1
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 5
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 5
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 4
39345: PUSH
39346: LD_INT 1
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 3
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 3
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 5
39387: PUSH
39388: LD_INT 2
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39442: LD_ADDR_VAR 0 32
39446: PUSH
39447: LD_INT 4
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 4
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 3
39472: NEG
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 3
39483: NEG
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 4
39494: NEG
39495: PUSH
39496: LD_INT 1
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 5
39505: NEG
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 5
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: NEG
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 5
39528: NEG
39529: PUSH
39530: LD_INT 2
39532: NEG
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 3
39540: NEG
39541: PUSH
39542: LD_INT 2
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: LD_INT 3
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: LD_INT 4
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: LD_INT 3
39579: NEG
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 2
39587: NEG
39588: PUSH
39589: LD_INT 2
39591: NEG
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: NEG
39600: PUSH
39601: LD_INT 2
39603: NEG
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 4
39611: NEG
39612: PUSH
39613: LD_INT 3
39615: NEG
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 4
39623: NEG
39624: PUSH
39625: LD_INT 4
39627: NEG
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: LD_INT 4
39639: NEG
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 4
39647: NEG
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: LD_INT 4
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: LD_INT 5
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: LD_INT 4
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: PUSH
39693: LD_INT 3
39695: NEG
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 4
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 1
39726: NEG
39727: PUSH
39728: LD_INT 5
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 2
39738: PUSH
39739: LD_INT 3
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 5
39753: NEG
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 3
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 3
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 4
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 4
39792: PUSH
39793: LD_INT 1
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 3
39802: PUSH
39803: LD_INT 1
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 2
39812: PUSH
39813: LD_INT 0
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 2
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 2
39833: PUSH
39834: LD_INT 2
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 4
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 4
39854: PUSH
39855: LD_INT 4
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 4
39864: PUSH
39865: LD_INT 3
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 5
39874: PUSH
39875: LD_INT 4
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 5
39884: PUSH
39885: LD_INT 5
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 4
39894: PUSH
39895: LD_INT 5
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: LD_INT 3
39904: PUSH
39905: LD_INT 4
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 3
39914: PUSH
39915: LD_INT 3
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 5
39924: PUSH
39925: LD_INT 3
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 3
39934: PUSH
39935: LD_INT 5
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39989: LD_ADDR_VAR 0 33
39993: PUSH
39994: LD_INT 4
39996: NEG
39997: PUSH
39998: LD_INT 4
40000: NEG
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 4
40008: NEG
40009: PUSH
40010: LD_INT 5
40012: NEG
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 3
40020: NEG
40021: PUSH
40022: LD_INT 4
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 3
40032: NEG
40033: PUSH
40034: LD_INT 3
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 4
40044: NEG
40045: PUSH
40046: LD_INT 3
40048: NEG
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 5
40056: NEG
40057: PUSH
40058: LD_INT 4
40060: NEG
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 5
40068: NEG
40069: PUSH
40070: LD_INT 5
40072: NEG
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 3
40080: NEG
40081: PUSH
40082: LD_INT 5
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 5
40092: NEG
40093: PUSH
40094: LD_INT 3
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: LD_INT 3
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 4
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 3
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 1
40137: PUSH
40138: LD_INT 2
40140: NEG
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: LD_INT 4
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 2
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 2
40194: NEG
40195: PUSH
40196: LD_INT 4
40198: NEG
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 4
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 4
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 5
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 5
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 4
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 3
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 3
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 2
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 5
40289: PUSH
40290: LD_INT 2
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 3
40299: PUSH
40300: LD_INT 3
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 3
40309: PUSH
40310: LD_INT 2
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 4
40319: PUSH
40320: LD_INT 3
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 4
40329: PUSH
40330: LD_INT 4
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: PUSH
40340: LD_INT 4
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 2
40349: PUSH
40350: LD_INT 3
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 2
40359: PUSH
40360: LD_INT 2
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 4
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 2
40379: PUSH
40380: LD_INT 4
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 0
40389: PUSH
40390: LD_INT 4
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: LD_INT 3
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 1
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: LD_INT 5
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 5
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 1
40439: NEG
40440: PUSH
40441: LD_INT 4
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 2
40461: PUSH
40462: LD_INT 5
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: LD_INT 3
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40527: LD_ADDR_VAR 0 34
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: LD_INT 4
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 0
40545: PUSH
40546: LD_INT 5
40548: NEG
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: LD_INT 4
40559: NEG
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PUSH
40565: LD_INT 1
40567: PUSH
40568: LD_INT 3
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: LD_INT 3
40581: NEG
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: NEG
40590: PUSH
40591: LD_INT 4
40593: NEG
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 5
40605: NEG
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 2
40613: PUSH
40614: LD_INT 3
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 2
40624: NEG
40625: PUSH
40626: LD_INT 5
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 3
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 4
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 4
40667: PUSH
40668: LD_INT 1
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 3
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 2
40687: PUSH
40688: LD_INT 0
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 2
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 2
40708: PUSH
40709: LD_INT 2
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 4
40719: PUSH
40720: LD_INT 2
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 4
40729: PUSH
40730: LD_INT 4
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 4
40739: PUSH
40740: LD_INT 3
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 5
40749: PUSH
40750: LD_INT 4
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 5
40759: PUSH
40760: LD_INT 5
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 4
40769: PUSH
40770: LD_INT 5
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 3
40779: PUSH
40780: LD_INT 4
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 3
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: PUSH
40800: LD_INT 3
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: LD_INT 5
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 3
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 0
40829: PUSH
40830: LD_INT 2
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 3
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 1
40849: PUSH
40850: LD_INT 4
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: LD_INT 4
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: NEG
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 1
40880: NEG
40881: PUSH
40882: LD_INT 2
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 2
40891: PUSH
40892: LD_INT 4
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 2
40901: NEG
40902: PUSH
40903: LD_INT 2
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 4
40923: NEG
40924: PUSH
40925: LD_INT 1
40927: NEG
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 3
40935: NEG
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 3
40946: NEG
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 4
40957: NEG
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 5
40968: NEG
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 5
40979: NEG
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 5
40991: NEG
40992: PUSH
40993: LD_INT 2
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 3
41003: NEG
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: ST_TO_ADDR
// end ; end ;
41059: GO 41062
41061: POP
// case btype of b_depot , b_warehouse :
41062: LD_VAR 0 1
41066: PUSH
41067: LD_INT 0
41069: DOUBLE
41070: EQUAL
41071: IFTRUE 41081
41073: LD_INT 1
41075: DOUBLE
41076: EQUAL
41077: IFTRUE 41081
41079: GO 41282
41081: POP
// case nation of nation_american :
41082: LD_VAR 0 5
41086: PUSH
41087: LD_INT 1
41089: DOUBLE
41090: EQUAL
41091: IFTRUE 41095
41093: GO 41151
41095: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41096: LD_ADDR_VAR 0 9
41100: PUSH
41101: LD_VAR 0 11
41105: PUSH
41106: LD_VAR 0 12
41110: PUSH
41111: LD_VAR 0 13
41115: PUSH
41116: LD_VAR 0 14
41120: PUSH
41121: LD_VAR 0 15
41125: PUSH
41126: LD_VAR 0 16
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: PUSH
41139: LD_VAR 0 4
41143: PUSH
41144: LD_INT 1
41146: PLUS
41147: ARRAY
41148: ST_TO_ADDR
41149: GO 41280
41151: LD_INT 2
41153: DOUBLE
41154: EQUAL
41155: IFTRUE 41159
41157: GO 41215
41159: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41160: LD_ADDR_VAR 0 9
41164: PUSH
41165: LD_VAR 0 17
41169: PUSH
41170: LD_VAR 0 18
41174: PUSH
41175: LD_VAR 0 19
41179: PUSH
41180: LD_VAR 0 20
41184: PUSH
41185: LD_VAR 0 21
41189: PUSH
41190: LD_VAR 0 22
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: PUSH
41203: LD_VAR 0 4
41207: PUSH
41208: LD_INT 1
41210: PLUS
41211: ARRAY
41212: ST_TO_ADDR
41213: GO 41280
41215: LD_INT 3
41217: DOUBLE
41218: EQUAL
41219: IFTRUE 41223
41221: GO 41279
41223: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41224: LD_ADDR_VAR 0 9
41228: PUSH
41229: LD_VAR 0 23
41233: PUSH
41234: LD_VAR 0 24
41238: PUSH
41239: LD_VAR 0 25
41243: PUSH
41244: LD_VAR 0 26
41248: PUSH
41249: LD_VAR 0 27
41253: PUSH
41254: LD_VAR 0 28
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: PUSH
41267: LD_VAR 0 4
41271: PUSH
41272: LD_INT 1
41274: PLUS
41275: ARRAY
41276: ST_TO_ADDR
41277: GO 41280
41279: POP
41280: GO 41835
41282: LD_INT 2
41284: DOUBLE
41285: EQUAL
41286: IFTRUE 41296
41288: LD_INT 3
41290: DOUBLE
41291: EQUAL
41292: IFTRUE 41296
41294: GO 41352
41296: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41297: LD_ADDR_VAR 0 9
41301: PUSH
41302: LD_VAR 0 29
41306: PUSH
41307: LD_VAR 0 30
41311: PUSH
41312: LD_VAR 0 31
41316: PUSH
41317: LD_VAR 0 32
41321: PUSH
41322: LD_VAR 0 33
41326: PUSH
41327: LD_VAR 0 34
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: LIST
41336: LIST
41337: LIST
41338: LIST
41339: PUSH
41340: LD_VAR 0 4
41344: PUSH
41345: LD_INT 1
41347: PLUS
41348: ARRAY
41349: ST_TO_ADDR
41350: GO 41835
41352: LD_INT 16
41354: DOUBLE
41355: EQUAL
41356: IFTRUE 41414
41358: LD_INT 17
41360: DOUBLE
41361: EQUAL
41362: IFTRUE 41414
41364: LD_INT 18
41366: DOUBLE
41367: EQUAL
41368: IFTRUE 41414
41370: LD_INT 19
41372: DOUBLE
41373: EQUAL
41374: IFTRUE 41414
41376: LD_INT 22
41378: DOUBLE
41379: EQUAL
41380: IFTRUE 41414
41382: LD_INT 20
41384: DOUBLE
41385: EQUAL
41386: IFTRUE 41414
41388: LD_INT 21
41390: DOUBLE
41391: EQUAL
41392: IFTRUE 41414
41394: LD_INT 23
41396: DOUBLE
41397: EQUAL
41398: IFTRUE 41414
41400: LD_INT 24
41402: DOUBLE
41403: EQUAL
41404: IFTRUE 41414
41406: LD_INT 25
41408: DOUBLE
41409: EQUAL
41410: IFTRUE 41414
41412: GO 41470
41414: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41415: LD_ADDR_VAR 0 9
41419: PUSH
41420: LD_VAR 0 35
41424: PUSH
41425: LD_VAR 0 36
41429: PUSH
41430: LD_VAR 0 37
41434: PUSH
41435: LD_VAR 0 38
41439: PUSH
41440: LD_VAR 0 39
41444: PUSH
41445: LD_VAR 0 40
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: PUSH
41458: LD_VAR 0 4
41462: PUSH
41463: LD_INT 1
41465: PLUS
41466: ARRAY
41467: ST_TO_ADDR
41468: GO 41835
41470: LD_INT 6
41472: DOUBLE
41473: EQUAL
41474: IFTRUE 41526
41476: LD_INT 7
41478: DOUBLE
41479: EQUAL
41480: IFTRUE 41526
41482: LD_INT 8
41484: DOUBLE
41485: EQUAL
41486: IFTRUE 41526
41488: LD_INT 13
41490: DOUBLE
41491: EQUAL
41492: IFTRUE 41526
41494: LD_INT 12
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41526
41500: LD_INT 15
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41526
41506: LD_INT 11
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41526
41512: LD_INT 14
41514: DOUBLE
41515: EQUAL
41516: IFTRUE 41526
41518: LD_INT 10
41520: DOUBLE
41521: EQUAL
41522: IFTRUE 41526
41524: GO 41582
41526: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41527: LD_ADDR_VAR 0 9
41531: PUSH
41532: LD_VAR 0 41
41536: PUSH
41537: LD_VAR 0 42
41541: PUSH
41542: LD_VAR 0 43
41546: PUSH
41547: LD_VAR 0 44
41551: PUSH
41552: LD_VAR 0 45
41556: PUSH
41557: LD_VAR 0 46
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: PUSH
41570: LD_VAR 0 4
41574: PUSH
41575: LD_INT 1
41577: PLUS
41578: ARRAY
41579: ST_TO_ADDR
41580: GO 41835
41582: LD_INT 36
41584: DOUBLE
41585: EQUAL
41586: IFTRUE 41590
41588: GO 41646
41590: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41591: LD_ADDR_VAR 0 9
41595: PUSH
41596: LD_VAR 0 47
41600: PUSH
41601: LD_VAR 0 48
41605: PUSH
41606: LD_VAR 0 49
41610: PUSH
41611: LD_VAR 0 50
41615: PUSH
41616: LD_VAR 0 51
41620: PUSH
41621: LD_VAR 0 52
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: PUSH
41634: LD_VAR 0 4
41638: PUSH
41639: LD_INT 1
41641: PLUS
41642: ARRAY
41643: ST_TO_ADDR
41644: GO 41835
41646: LD_INT 4
41648: DOUBLE
41649: EQUAL
41650: IFTRUE 41672
41652: LD_INT 5
41654: DOUBLE
41655: EQUAL
41656: IFTRUE 41672
41658: LD_INT 34
41660: DOUBLE
41661: EQUAL
41662: IFTRUE 41672
41664: LD_INT 37
41666: DOUBLE
41667: EQUAL
41668: IFTRUE 41672
41670: GO 41728
41672: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41673: LD_ADDR_VAR 0 9
41677: PUSH
41678: LD_VAR 0 53
41682: PUSH
41683: LD_VAR 0 54
41687: PUSH
41688: LD_VAR 0 55
41692: PUSH
41693: LD_VAR 0 56
41697: PUSH
41698: LD_VAR 0 57
41702: PUSH
41703: LD_VAR 0 58
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: PUSH
41716: LD_VAR 0 4
41720: PUSH
41721: LD_INT 1
41723: PLUS
41724: ARRAY
41725: ST_TO_ADDR
41726: GO 41835
41728: LD_INT 31
41730: DOUBLE
41731: EQUAL
41732: IFTRUE 41778
41734: LD_INT 32
41736: DOUBLE
41737: EQUAL
41738: IFTRUE 41778
41740: LD_INT 33
41742: DOUBLE
41743: EQUAL
41744: IFTRUE 41778
41746: LD_INT 27
41748: DOUBLE
41749: EQUAL
41750: IFTRUE 41778
41752: LD_INT 26
41754: DOUBLE
41755: EQUAL
41756: IFTRUE 41778
41758: LD_INT 28
41760: DOUBLE
41761: EQUAL
41762: IFTRUE 41778
41764: LD_INT 29
41766: DOUBLE
41767: EQUAL
41768: IFTRUE 41778
41770: LD_INT 30
41772: DOUBLE
41773: EQUAL
41774: IFTRUE 41778
41776: GO 41834
41778: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41779: LD_ADDR_VAR 0 9
41783: PUSH
41784: LD_VAR 0 59
41788: PUSH
41789: LD_VAR 0 60
41793: PUSH
41794: LD_VAR 0 61
41798: PUSH
41799: LD_VAR 0 62
41803: PUSH
41804: LD_VAR 0 63
41808: PUSH
41809: LD_VAR 0 64
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: PUSH
41822: LD_VAR 0 4
41826: PUSH
41827: LD_INT 1
41829: PLUS
41830: ARRAY
41831: ST_TO_ADDR
41832: GO 41835
41834: POP
// temp_list2 = [ ] ;
41835: LD_ADDR_VAR 0 10
41839: PUSH
41840: EMPTY
41841: ST_TO_ADDR
// for i in temp_list do
41842: LD_ADDR_VAR 0 8
41846: PUSH
41847: LD_VAR 0 9
41851: PUSH
41852: FOR_IN
41853: IFFALSE 41905
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41855: LD_ADDR_VAR 0 10
41859: PUSH
41860: LD_VAR 0 10
41864: PUSH
41865: LD_VAR 0 8
41869: PUSH
41870: LD_INT 1
41872: ARRAY
41873: PUSH
41874: LD_VAR 0 2
41878: PLUS
41879: PUSH
41880: LD_VAR 0 8
41884: PUSH
41885: LD_INT 2
41887: ARRAY
41888: PUSH
41889: LD_VAR 0 3
41893: PLUS
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: ADD
41902: ST_TO_ADDR
41903: GO 41852
41905: POP
41906: POP
// result = temp_list2 ;
41907: LD_ADDR_VAR 0 7
41911: PUSH
41912: LD_VAR 0 10
41916: ST_TO_ADDR
// end ;
41917: LD_VAR 0 7
41921: RET
// export function EnemyInRange ( unit , dist ) ; begin
41922: LD_INT 0
41924: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41925: LD_ADDR_VAR 0 3
41929: PUSH
41930: LD_VAR 0 1
41934: PPUSH
41935: CALL_OW 255
41939: PPUSH
41940: LD_VAR 0 1
41944: PPUSH
41945: CALL_OW 250
41949: PPUSH
41950: LD_VAR 0 1
41954: PPUSH
41955: CALL_OW 251
41959: PPUSH
41960: LD_VAR 0 2
41964: PPUSH
41965: CALL 15693 0 4
41969: PUSH
41970: LD_INT 4
41972: ARRAY
41973: ST_TO_ADDR
// end ;
41974: LD_VAR 0 3
41978: RET
// export function PlayerSeeMe ( unit ) ; begin
41979: LD_INT 0
41981: PPUSH
// result := See ( your_side , unit ) ;
41982: LD_ADDR_VAR 0 2
41986: PUSH
41987: LD_OWVAR 2
41991: PPUSH
41992: LD_VAR 0 1
41996: PPUSH
41997: CALL_OW 292
42001: ST_TO_ADDR
// end ;
42002: LD_VAR 0 2
42006: RET
// export function ReverseDir ( unit ) ; begin
42007: LD_INT 0
42009: PPUSH
// if not unit then
42010: LD_VAR 0 1
42014: NOT
42015: IFFALSE 42019
// exit ;
42017: GO 42042
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42019: LD_ADDR_VAR 0 2
42023: PUSH
42024: LD_VAR 0 1
42028: PPUSH
42029: CALL_OW 254
42033: PUSH
42034: LD_INT 3
42036: PLUS
42037: PUSH
42038: LD_INT 6
42040: MOD
42041: ST_TO_ADDR
// end ;
42042: LD_VAR 0 2
42046: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42047: LD_INT 0
42049: PPUSH
42050: PPUSH
42051: PPUSH
42052: PPUSH
42053: PPUSH
// if not hexes then
42054: LD_VAR 0 2
42058: NOT
42059: IFFALSE 42063
// exit ;
42061: GO 42211
// dist := 9999 ;
42063: LD_ADDR_VAR 0 5
42067: PUSH
42068: LD_INT 9999
42070: ST_TO_ADDR
// for i = 1 to hexes do
42071: LD_ADDR_VAR 0 4
42075: PUSH
42076: DOUBLE
42077: LD_INT 1
42079: DEC
42080: ST_TO_ADDR
42081: LD_VAR 0 2
42085: PUSH
42086: FOR_TO
42087: IFFALSE 42199
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42089: LD_VAR 0 1
42093: PPUSH
42094: LD_VAR 0 2
42098: PUSH
42099: LD_VAR 0 4
42103: ARRAY
42104: PUSH
42105: LD_INT 1
42107: ARRAY
42108: PPUSH
42109: LD_VAR 0 2
42113: PUSH
42114: LD_VAR 0 4
42118: ARRAY
42119: PUSH
42120: LD_INT 2
42122: ARRAY
42123: PPUSH
42124: CALL_OW 297
42128: PUSH
42129: LD_VAR 0 5
42133: LESS
42134: IFFALSE 42197
// begin hex := hexes [ i ] ;
42136: LD_ADDR_VAR 0 7
42140: PUSH
42141: LD_VAR 0 2
42145: PUSH
42146: LD_VAR 0 4
42150: ARRAY
42151: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42152: LD_ADDR_VAR 0 5
42156: PUSH
42157: LD_VAR 0 1
42161: PPUSH
42162: LD_VAR 0 2
42166: PUSH
42167: LD_VAR 0 4
42171: ARRAY
42172: PUSH
42173: LD_INT 1
42175: ARRAY
42176: PPUSH
42177: LD_VAR 0 2
42181: PUSH
42182: LD_VAR 0 4
42186: ARRAY
42187: PUSH
42188: LD_INT 2
42190: ARRAY
42191: PPUSH
42192: CALL_OW 297
42196: ST_TO_ADDR
// end ; end ;
42197: GO 42086
42199: POP
42200: POP
// result := hex ;
42201: LD_ADDR_VAR 0 3
42205: PUSH
42206: LD_VAR 0 7
42210: ST_TO_ADDR
// end ;
42211: LD_VAR 0 3
42215: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42216: LD_INT 0
42218: PPUSH
42219: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42220: LD_VAR 0 1
42224: NOT
42225: PUSH
42226: LD_VAR 0 1
42230: PUSH
42231: LD_INT 21
42233: PUSH
42234: LD_INT 2
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 23
42243: PUSH
42244: LD_INT 2
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PPUSH
42255: CALL_OW 69
42259: IN
42260: NOT
42261: OR
42262: IFFALSE 42266
// exit ;
42264: GO 42313
// for i = 1 to 3 do
42266: LD_ADDR_VAR 0 3
42270: PUSH
42271: DOUBLE
42272: LD_INT 1
42274: DEC
42275: ST_TO_ADDR
42276: LD_INT 3
42278: PUSH
42279: FOR_TO
42280: IFFALSE 42311
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42282: LD_VAR 0 1
42286: PPUSH
42287: CALL_OW 250
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: CALL_OW 251
42301: PPUSH
42302: LD_INT 1
42304: PPUSH
42305: CALL_OW 453
42309: GO 42279
42311: POP
42312: POP
// end ;
42313: LD_VAR 0 2
42317: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42318: LD_INT 0
42320: PPUSH
42321: PPUSH
42322: PPUSH
42323: PPUSH
42324: PPUSH
42325: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42326: LD_VAR 0 1
42330: NOT
42331: PUSH
42332: LD_VAR 0 2
42336: NOT
42337: OR
42338: PUSH
42339: LD_VAR 0 1
42343: PPUSH
42344: CALL_OW 314
42348: OR
42349: IFFALSE 42353
// exit ;
42351: GO 42794
// x := GetX ( enemy_unit ) ;
42353: LD_ADDR_VAR 0 7
42357: PUSH
42358: LD_VAR 0 2
42362: PPUSH
42363: CALL_OW 250
42367: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42368: LD_ADDR_VAR 0 8
42372: PUSH
42373: LD_VAR 0 2
42377: PPUSH
42378: CALL_OW 251
42382: ST_TO_ADDR
// if not x or not y then
42383: LD_VAR 0 7
42387: NOT
42388: PUSH
42389: LD_VAR 0 8
42393: NOT
42394: OR
42395: IFFALSE 42399
// exit ;
42397: GO 42794
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42399: LD_ADDR_VAR 0 6
42403: PUSH
42404: LD_VAR 0 7
42408: PPUSH
42409: LD_INT 0
42411: PPUSH
42412: LD_INT 4
42414: PPUSH
42415: CALL_OW 272
42419: PUSH
42420: LD_VAR 0 8
42424: PPUSH
42425: LD_INT 0
42427: PPUSH
42428: LD_INT 4
42430: PPUSH
42431: CALL_OW 273
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_VAR 0 7
42444: PPUSH
42445: LD_INT 1
42447: PPUSH
42448: LD_INT 4
42450: PPUSH
42451: CALL_OW 272
42455: PUSH
42456: LD_VAR 0 8
42460: PPUSH
42461: LD_INT 1
42463: PPUSH
42464: LD_INT 4
42466: PPUSH
42467: CALL_OW 273
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_VAR 0 7
42480: PPUSH
42481: LD_INT 2
42483: PPUSH
42484: LD_INT 4
42486: PPUSH
42487: CALL_OW 272
42491: PUSH
42492: LD_VAR 0 8
42496: PPUSH
42497: LD_INT 2
42499: PPUSH
42500: LD_INT 4
42502: PPUSH
42503: CALL_OW 273
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_VAR 0 7
42516: PPUSH
42517: LD_INT 3
42519: PPUSH
42520: LD_INT 4
42522: PPUSH
42523: CALL_OW 272
42527: PUSH
42528: LD_VAR 0 8
42532: PPUSH
42533: LD_INT 3
42535: PPUSH
42536: LD_INT 4
42538: PPUSH
42539: CALL_OW 273
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_VAR 0 7
42552: PPUSH
42553: LD_INT 4
42555: PPUSH
42556: LD_INT 4
42558: PPUSH
42559: CALL_OW 272
42563: PUSH
42564: LD_VAR 0 8
42568: PPUSH
42569: LD_INT 4
42571: PPUSH
42572: LD_INT 4
42574: PPUSH
42575: CALL_OW 273
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_VAR 0 7
42588: PPUSH
42589: LD_INT 5
42591: PPUSH
42592: LD_INT 4
42594: PPUSH
42595: CALL_OW 272
42599: PUSH
42600: LD_VAR 0 8
42604: PPUSH
42605: LD_INT 5
42607: PPUSH
42608: LD_INT 4
42610: PPUSH
42611: CALL_OW 273
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: ST_TO_ADDR
// for i = tmp downto 1 do
42628: LD_ADDR_VAR 0 4
42632: PUSH
42633: DOUBLE
42634: LD_VAR 0 6
42638: INC
42639: ST_TO_ADDR
42640: LD_INT 1
42642: PUSH
42643: FOR_DOWNTO
42644: IFFALSE 42745
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42646: LD_VAR 0 6
42650: PUSH
42651: LD_VAR 0 4
42655: ARRAY
42656: PUSH
42657: LD_INT 1
42659: ARRAY
42660: PPUSH
42661: LD_VAR 0 6
42665: PUSH
42666: LD_VAR 0 4
42670: ARRAY
42671: PUSH
42672: LD_INT 2
42674: ARRAY
42675: PPUSH
42676: CALL_OW 488
42680: NOT
42681: PUSH
42682: LD_VAR 0 6
42686: PUSH
42687: LD_VAR 0 4
42691: ARRAY
42692: PUSH
42693: LD_INT 1
42695: ARRAY
42696: PPUSH
42697: LD_VAR 0 6
42701: PUSH
42702: LD_VAR 0 4
42706: ARRAY
42707: PUSH
42708: LD_INT 2
42710: ARRAY
42711: PPUSH
42712: CALL_OW 428
42716: PUSH
42717: LD_INT 0
42719: NONEQUAL
42720: OR
42721: IFFALSE 42743
// tmp := Delete ( tmp , i ) ;
42723: LD_ADDR_VAR 0 6
42727: PUSH
42728: LD_VAR 0 6
42732: PPUSH
42733: LD_VAR 0 4
42737: PPUSH
42738: CALL_OW 3
42742: ST_TO_ADDR
42743: GO 42643
42745: POP
42746: POP
// j := GetClosestHex ( unit , tmp ) ;
42747: LD_ADDR_VAR 0 5
42751: PUSH
42752: LD_VAR 0 1
42756: PPUSH
42757: LD_VAR 0 6
42761: PPUSH
42762: CALL 42047 0 2
42766: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42767: LD_VAR 0 1
42771: PPUSH
42772: LD_VAR 0 5
42776: PUSH
42777: LD_INT 1
42779: ARRAY
42780: PPUSH
42781: LD_VAR 0 5
42785: PUSH
42786: LD_INT 2
42788: ARRAY
42789: PPUSH
42790: CALL_OW 111
// end ;
42794: LD_VAR 0 3
42798: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42799: LD_INT 0
42801: PPUSH
42802: PPUSH
42803: PPUSH
// uc_side = 0 ;
42804: LD_ADDR_OWVAR 20
42808: PUSH
42809: LD_INT 0
42811: ST_TO_ADDR
// uc_nation = 0 ;
42812: LD_ADDR_OWVAR 21
42816: PUSH
42817: LD_INT 0
42819: ST_TO_ADDR
// InitHc_All ( ) ;
42820: CALL_OW 584
// InitVc ;
42824: CALL_OW 20
// if mastodonts then
42828: LD_VAR 0 6
42832: IFFALSE 42899
// for i = 1 to mastodonts do
42834: LD_ADDR_VAR 0 11
42838: PUSH
42839: DOUBLE
42840: LD_INT 1
42842: DEC
42843: ST_TO_ADDR
42844: LD_VAR 0 6
42848: PUSH
42849: FOR_TO
42850: IFFALSE 42897
// begin vc_chassis := 31 ;
42852: LD_ADDR_OWVAR 37
42856: PUSH
42857: LD_INT 31
42859: ST_TO_ADDR
// vc_control := control_rider ;
42860: LD_ADDR_OWVAR 38
42864: PUSH
42865: LD_INT 4
42867: ST_TO_ADDR
// animal := CreateVehicle ;
42868: LD_ADDR_VAR 0 12
42872: PUSH
42873: CALL_OW 45
42877: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42878: LD_VAR 0 12
42882: PPUSH
42883: LD_VAR 0 8
42887: PPUSH
42888: LD_INT 0
42890: PPUSH
42891: CALL 45087 0 3
// end ;
42895: GO 42849
42897: POP
42898: POP
// if horses then
42899: LD_VAR 0 5
42903: IFFALSE 42970
// for i = 1 to horses do
42905: LD_ADDR_VAR 0 11
42909: PUSH
42910: DOUBLE
42911: LD_INT 1
42913: DEC
42914: ST_TO_ADDR
42915: LD_VAR 0 5
42919: PUSH
42920: FOR_TO
42921: IFFALSE 42968
// begin hc_class := 21 ;
42923: LD_ADDR_OWVAR 28
42927: PUSH
42928: LD_INT 21
42930: ST_TO_ADDR
// hc_gallery :=  ;
42931: LD_ADDR_OWVAR 33
42935: PUSH
42936: LD_STRING 
42938: ST_TO_ADDR
// animal := CreateHuman ;
42939: LD_ADDR_VAR 0 12
42943: PUSH
42944: CALL_OW 44
42948: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42949: LD_VAR 0 12
42953: PPUSH
42954: LD_VAR 0 8
42958: PPUSH
42959: LD_INT 0
42961: PPUSH
42962: CALL 45087 0 3
// end ;
42966: GO 42920
42968: POP
42969: POP
// if birds then
42970: LD_VAR 0 1
42974: IFFALSE 43041
// for i = 1 to birds do
42976: LD_ADDR_VAR 0 11
42980: PUSH
42981: DOUBLE
42982: LD_INT 1
42984: DEC
42985: ST_TO_ADDR
42986: LD_VAR 0 1
42990: PUSH
42991: FOR_TO
42992: IFFALSE 43039
// begin hc_class = 18 ;
42994: LD_ADDR_OWVAR 28
42998: PUSH
42999: LD_INT 18
43001: ST_TO_ADDR
// hc_gallery =  ;
43002: LD_ADDR_OWVAR 33
43006: PUSH
43007: LD_STRING 
43009: ST_TO_ADDR
// animal := CreateHuman ;
43010: LD_ADDR_VAR 0 12
43014: PUSH
43015: CALL_OW 44
43019: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43020: LD_VAR 0 12
43024: PPUSH
43025: LD_VAR 0 8
43029: PPUSH
43030: LD_INT 0
43032: PPUSH
43033: CALL 45087 0 3
// end ;
43037: GO 42991
43039: POP
43040: POP
// if tigers then
43041: LD_VAR 0 2
43045: IFFALSE 43129
// for i = 1 to tigers do
43047: LD_ADDR_VAR 0 11
43051: PUSH
43052: DOUBLE
43053: LD_INT 1
43055: DEC
43056: ST_TO_ADDR
43057: LD_VAR 0 2
43061: PUSH
43062: FOR_TO
43063: IFFALSE 43127
// begin hc_class = class_tiger ;
43065: LD_ADDR_OWVAR 28
43069: PUSH
43070: LD_INT 14
43072: ST_TO_ADDR
// hc_gallery =  ;
43073: LD_ADDR_OWVAR 33
43077: PUSH
43078: LD_STRING 
43080: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43081: LD_ADDR_OWVAR 35
43085: PUSH
43086: LD_INT 7
43088: NEG
43089: PPUSH
43090: LD_INT 7
43092: PPUSH
43093: CALL_OW 12
43097: ST_TO_ADDR
// animal := CreateHuman ;
43098: LD_ADDR_VAR 0 12
43102: PUSH
43103: CALL_OW 44
43107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43108: LD_VAR 0 12
43112: PPUSH
43113: LD_VAR 0 8
43117: PPUSH
43118: LD_INT 0
43120: PPUSH
43121: CALL 45087 0 3
// end ;
43125: GO 43062
43127: POP
43128: POP
// if apemans then
43129: LD_VAR 0 3
43133: IFFALSE 43256
// for i = 1 to apemans do
43135: LD_ADDR_VAR 0 11
43139: PUSH
43140: DOUBLE
43141: LD_INT 1
43143: DEC
43144: ST_TO_ADDR
43145: LD_VAR 0 3
43149: PUSH
43150: FOR_TO
43151: IFFALSE 43254
// begin hc_class = class_apeman ;
43153: LD_ADDR_OWVAR 28
43157: PUSH
43158: LD_INT 12
43160: ST_TO_ADDR
// hc_gallery =  ;
43161: LD_ADDR_OWVAR 33
43165: PUSH
43166: LD_STRING 
43168: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
43169: LD_ADDR_OWVAR 35
43173: PUSH
43174: LD_INT 5
43176: NEG
43177: PPUSH
43178: LD_INT 5
43180: PPUSH
43181: CALL_OW 12
43185: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43186: LD_ADDR_OWVAR 31
43190: PUSH
43191: LD_INT 1
43193: PPUSH
43194: LD_INT 3
43196: PPUSH
43197: CALL_OW 12
43201: PUSH
43202: LD_INT 1
43204: PPUSH
43205: LD_INT 3
43207: PPUSH
43208: CALL_OW 12
43212: PUSH
43213: LD_INT 0
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: ST_TO_ADDR
// animal := CreateHuman ;
43225: LD_ADDR_VAR 0 12
43229: PUSH
43230: CALL_OW 44
43234: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43235: LD_VAR 0 12
43239: PPUSH
43240: LD_VAR 0 8
43244: PPUSH
43245: LD_INT 0
43247: PPUSH
43248: CALL 45087 0 3
// end ;
43252: GO 43150
43254: POP
43255: POP
// if enchidnas then
43256: LD_VAR 0 4
43260: IFFALSE 43327
// for i = 1 to enchidnas do
43262: LD_ADDR_VAR 0 11
43266: PUSH
43267: DOUBLE
43268: LD_INT 1
43270: DEC
43271: ST_TO_ADDR
43272: LD_VAR 0 4
43276: PUSH
43277: FOR_TO
43278: IFFALSE 43325
// begin hc_class = 13 ;
43280: LD_ADDR_OWVAR 28
43284: PUSH
43285: LD_INT 13
43287: ST_TO_ADDR
// hc_gallery =  ;
43288: LD_ADDR_OWVAR 33
43292: PUSH
43293: LD_STRING 
43295: ST_TO_ADDR
// animal := CreateHuman ;
43296: LD_ADDR_VAR 0 12
43300: PUSH
43301: CALL_OW 44
43305: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43306: LD_VAR 0 12
43310: PPUSH
43311: LD_VAR 0 8
43315: PPUSH
43316: LD_INT 0
43318: PPUSH
43319: CALL 45087 0 3
// end ;
43323: GO 43277
43325: POP
43326: POP
// if fishes then
43327: LD_VAR 0 7
43331: IFFALSE 43398
// for i = 1 to fishes do
43333: LD_ADDR_VAR 0 11
43337: PUSH
43338: DOUBLE
43339: LD_INT 1
43341: DEC
43342: ST_TO_ADDR
43343: LD_VAR 0 7
43347: PUSH
43348: FOR_TO
43349: IFFALSE 43396
// begin hc_class = 20 ;
43351: LD_ADDR_OWVAR 28
43355: PUSH
43356: LD_INT 20
43358: ST_TO_ADDR
// hc_gallery =  ;
43359: LD_ADDR_OWVAR 33
43363: PUSH
43364: LD_STRING 
43366: ST_TO_ADDR
// animal := CreateHuman ;
43367: LD_ADDR_VAR 0 12
43371: PUSH
43372: CALL_OW 44
43376: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43377: LD_VAR 0 12
43381: PPUSH
43382: LD_VAR 0 9
43386: PPUSH
43387: LD_INT 0
43389: PPUSH
43390: CALL 45087 0 3
// end ;
43394: GO 43348
43396: POP
43397: POP
// end ;
43398: LD_VAR 0 10
43402: RET
// export function WantHeal ( sci , unit ) ; begin
43403: LD_INT 0
43405: PPUSH
// if GetTaskList ( sci ) > 0 then
43406: LD_VAR 0 1
43410: PPUSH
43411: CALL_OW 437
43415: PUSH
43416: LD_INT 0
43418: GREATER
43419: IFFALSE 43489
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43421: LD_VAR 0 1
43425: PPUSH
43426: CALL_OW 437
43430: PUSH
43431: LD_INT 1
43433: ARRAY
43434: PUSH
43435: LD_INT 1
43437: ARRAY
43438: PUSH
43439: LD_STRING l
43441: EQUAL
43442: PUSH
43443: LD_VAR 0 1
43447: PPUSH
43448: CALL_OW 437
43452: PUSH
43453: LD_INT 1
43455: ARRAY
43456: PUSH
43457: LD_INT 4
43459: ARRAY
43460: PUSH
43461: LD_VAR 0 2
43465: EQUAL
43466: AND
43467: IFFALSE 43479
// result := true else
43469: LD_ADDR_VAR 0 3
43473: PUSH
43474: LD_INT 1
43476: ST_TO_ADDR
43477: GO 43487
// result := false ;
43479: LD_ADDR_VAR 0 3
43483: PUSH
43484: LD_INT 0
43486: ST_TO_ADDR
// end else
43487: GO 43497
// result := false ;
43489: LD_ADDR_VAR 0 3
43493: PUSH
43494: LD_INT 0
43496: ST_TO_ADDR
// end ;
43497: LD_VAR 0 3
43501: RET
// export function HealTarget ( sci ) ; begin
43502: LD_INT 0
43504: PPUSH
// if not sci then
43505: LD_VAR 0 1
43509: NOT
43510: IFFALSE 43514
// exit ;
43512: GO 43579
// result := 0 ;
43514: LD_ADDR_VAR 0 2
43518: PUSH
43519: LD_INT 0
43521: ST_TO_ADDR
// if GetTaskList ( sci ) then
43522: LD_VAR 0 1
43526: PPUSH
43527: CALL_OW 437
43531: IFFALSE 43579
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43533: LD_VAR 0 1
43537: PPUSH
43538: CALL_OW 437
43542: PUSH
43543: LD_INT 1
43545: ARRAY
43546: PUSH
43547: LD_INT 1
43549: ARRAY
43550: PUSH
43551: LD_STRING l
43553: EQUAL
43554: IFFALSE 43579
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43556: LD_ADDR_VAR 0 2
43560: PUSH
43561: LD_VAR 0 1
43565: PPUSH
43566: CALL_OW 437
43570: PUSH
43571: LD_INT 1
43573: ARRAY
43574: PUSH
43575: LD_INT 4
43577: ARRAY
43578: ST_TO_ADDR
// end ;
43579: LD_VAR 0 2
43583: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43584: LD_INT 0
43586: PPUSH
43587: PPUSH
43588: PPUSH
43589: PPUSH
// if not base_units then
43590: LD_VAR 0 1
43594: NOT
43595: IFFALSE 43599
// exit ;
43597: GO 43686
// result := false ;
43599: LD_ADDR_VAR 0 2
43603: PUSH
43604: LD_INT 0
43606: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43607: LD_ADDR_VAR 0 5
43611: PUSH
43612: LD_VAR 0 1
43616: PPUSH
43617: LD_INT 21
43619: PUSH
43620: LD_INT 3
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PPUSH
43627: CALL_OW 72
43631: ST_TO_ADDR
// if not tmp then
43632: LD_VAR 0 5
43636: NOT
43637: IFFALSE 43641
// exit ;
43639: GO 43686
// for i in tmp do
43641: LD_ADDR_VAR 0 3
43645: PUSH
43646: LD_VAR 0 5
43650: PUSH
43651: FOR_IN
43652: IFFALSE 43684
// begin result := EnemyInRange ( i , 22 ) ;
43654: LD_ADDR_VAR 0 2
43658: PUSH
43659: LD_VAR 0 3
43663: PPUSH
43664: LD_INT 22
43666: PPUSH
43667: CALL 41922 0 2
43671: ST_TO_ADDR
// if result then
43672: LD_VAR 0 2
43676: IFFALSE 43682
// exit ;
43678: POP
43679: POP
43680: GO 43686
// end ;
43682: GO 43651
43684: POP
43685: POP
// end ;
43686: LD_VAR 0 2
43690: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43691: LD_INT 0
43693: PPUSH
43694: PPUSH
// if not units then
43695: LD_VAR 0 1
43699: NOT
43700: IFFALSE 43704
// exit ;
43702: GO 43774
// result := [ ] ;
43704: LD_ADDR_VAR 0 3
43708: PUSH
43709: EMPTY
43710: ST_TO_ADDR
// for i in units do
43711: LD_ADDR_VAR 0 4
43715: PUSH
43716: LD_VAR 0 1
43720: PUSH
43721: FOR_IN
43722: IFFALSE 43772
// if GetTag ( i ) = tag then
43724: LD_VAR 0 4
43728: PPUSH
43729: CALL_OW 110
43733: PUSH
43734: LD_VAR 0 2
43738: EQUAL
43739: IFFALSE 43770
// result := Insert ( result , result + 1 , i ) ;
43741: LD_ADDR_VAR 0 3
43745: PUSH
43746: LD_VAR 0 3
43750: PPUSH
43751: LD_VAR 0 3
43755: PUSH
43756: LD_INT 1
43758: PLUS
43759: PPUSH
43760: LD_VAR 0 4
43764: PPUSH
43765: CALL_OW 2
43769: ST_TO_ADDR
43770: GO 43721
43772: POP
43773: POP
// end ;
43774: LD_VAR 0 3
43778: RET
// export function IsDriver ( un ) ; begin
43779: LD_INT 0
43781: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43782: LD_ADDR_VAR 0 2
43786: PUSH
43787: LD_VAR 0 1
43791: PUSH
43792: LD_INT 55
43794: PUSH
43795: EMPTY
43796: LIST
43797: PPUSH
43798: CALL_OW 69
43802: IN
43803: ST_TO_ADDR
// end ;
43804: LD_VAR 0 2
43808: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43809: LD_INT 0
43811: PPUSH
43812: PPUSH
// list := [ ] ;
43813: LD_ADDR_VAR 0 5
43817: PUSH
43818: EMPTY
43819: ST_TO_ADDR
// case d of 0 :
43820: LD_VAR 0 3
43824: PUSH
43825: LD_INT 0
43827: DOUBLE
43828: EQUAL
43829: IFTRUE 43833
43831: GO 43966
43833: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43834: LD_ADDR_VAR 0 5
43838: PUSH
43839: LD_VAR 0 1
43843: PUSH
43844: LD_INT 4
43846: MINUS
43847: PUSH
43848: LD_VAR 0 2
43852: PUSH
43853: LD_INT 4
43855: MINUS
43856: PUSH
43857: LD_INT 2
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: PUSH
43865: LD_VAR 0 1
43869: PUSH
43870: LD_INT 3
43872: MINUS
43873: PUSH
43874: LD_VAR 0 2
43878: PUSH
43879: LD_INT 1
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: LIST
43886: PUSH
43887: LD_VAR 0 1
43891: PUSH
43892: LD_INT 4
43894: PLUS
43895: PUSH
43896: LD_VAR 0 2
43900: PUSH
43901: LD_INT 4
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: LIST
43908: PUSH
43909: LD_VAR 0 1
43913: PUSH
43914: LD_INT 3
43916: PLUS
43917: PUSH
43918: LD_VAR 0 2
43922: PUSH
43923: LD_INT 3
43925: PLUS
43926: PUSH
43927: LD_INT 5
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: LIST
43934: PUSH
43935: LD_VAR 0 1
43939: PUSH
43940: LD_VAR 0 2
43944: PUSH
43945: LD_INT 4
43947: PLUS
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: LIST
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: ST_TO_ADDR
// end ; 1 :
43964: GO 44664
43966: LD_INT 1
43968: DOUBLE
43969: EQUAL
43970: IFTRUE 43974
43972: GO 44107
43974: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43975: LD_ADDR_VAR 0 5
43979: PUSH
43980: LD_VAR 0 1
43984: PUSH
43985: LD_VAR 0 2
43989: PUSH
43990: LD_INT 4
43992: MINUS
43993: PUSH
43994: LD_INT 3
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: LIST
44001: PUSH
44002: LD_VAR 0 1
44006: PUSH
44007: LD_INT 3
44009: MINUS
44010: PUSH
44011: LD_VAR 0 2
44015: PUSH
44016: LD_INT 3
44018: MINUS
44019: PUSH
44020: LD_INT 2
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: LIST
44027: PUSH
44028: LD_VAR 0 1
44032: PUSH
44033: LD_INT 4
44035: MINUS
44036: PUSH
44037: LD_VAR 0 2
44041: PUSH
44042: LD_INT 1
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: LIST
44049: PUSH
44050: LD_VAR 0 1
44054: PUSH
44055: LD_VAR 0 2
44059: PUSH
44060: LD_INT 3
44062: PLUS
44063: PUSH
44064: LD_INT 0
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: LIST
44071: PUSH
44072: LD_VAR 0 1
44076: PUSH
44077: LD_INT 4
44079: PLUS
44080: PUSH
44081: LD_VAR 0 2
44085: PUSH
44086: LD_INT 4
44088: PLUS
44089: PUSH
44090: LD_INT 5
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: LIST
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: ST_TO_ADDR
// end ; 2 :
44105: GO 44664
44107: LD_INT 2
44109: DOUBLE
44110: EQUAL
44111: IFTRUE 44115
44113: GO 44244
44115: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44116: LD_ADDR_VAR 0 5
44120: PUSH
44121: LD_VAR 0 1
44125: PUSH
44126: LD_VAR 0 2
44130: PUSH
44131: LD_INT 3
44133: MINUS
44134: PUSH
44135: LD_INT 3
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: LIST
44142: PUSH
44143: LD_VAR 0 1
44147: PUSH
44148: LD_INT 4
44150: PLUS
44151: PUSH
44152: LD_VAR 0 2
44156: PUSH
44157: LD_INT 4
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: LIST
44164: PUSH
44165: LD_VAR 0 1
44169: PUSH
44170: LD_VAR 0 2
44174: PUSH
44175: LD_INT 4
44177: PLUS
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: PUSH
44187: LD_VAR 0 1
44191: PUSH
44192: LD_INT 3
44194: MINUS
44195: PUSH
44196: LD_VAR 0 2
44200: PUSH
44201: LD_INT 1
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: LIST
44208: PUSH
44209: LD_VAR 0 1
44213: PUSH
44214: LD_INT 4
44216: MINUS
44217: PUSH
44218: LD_VAR 0 2
44222: PUSH
44223: LD_INT 4
44225: MINUS
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: LIST
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: ST_TO_ADDR
// end ; 3 :
44242: GO 44664
44244: LD_INT 3
44246: DOUBLE
44247: EQUAL
44248: IFTRUE 44252
44250: GO 44385
44252: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44253: LD_ADDR_VAR 0 5
44257: PUSH
44258: LD_VAR 0 1
44262: PUSH
44263: LD_INT 3
44265: PLUS
44266: PUSH
44267: LD_VAR 0 2
44271: PUSH
44272: LD_INT 4
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: LIST
44279: PUSH
44280: LD_VAR 0 1
44284: PUSH
44285: LD_INT 4
44287: PLUS
44288: PUSH
44289: LD_VAR 0 2
44293: PUSH
44294: LD_INT 4
44296: PLUS
44297: PUSH
44298: LD_INT 5
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: LIST
44305: PUSH
44306: LD_VAR 0 1
44310: PUSH
44311: LD_INT 4
44313: MINUS
44314: PUSH
44315: LD_VAR 0 2
44319: PUSH
44320: LD_INT 1
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: PUSH
44328: LD_VAR 0 1
44332: PUSH
44333: LD_VAR 0 2
44337: PUSH
44338: LD_INT 4
44340: MINUS
44341: PUSH
44342: LD_INT 3
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: LIST
44349: PUSH
44350: LD_VAR 0 1
44354: PUSH
44355: LD_INT 3
44357: MINUS
44358: PUSH
44359: LD_VAR 0 2
44363: PUSH
44364: LD_INT 3
44366: MINUS
44367: PUSH
44368: LD_INT 2
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: LIST
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: ST_TO_ADDR
// end ; 4 :
44383: GO 44664
44385: LD_INT 4
44387: DOUBLE
44388: EQUAL
44389: IFTRUE 44393
44391: GO 44526
44393: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44394: LD_ADDR_VAR 0 5
44398: PUSH
44399: LD_VAR 0 1
44403: PUSH
44404: LD_VAR 0 2
44408: PUSH
44409: LD_INT 4
44411: PLUS
44412: PUSH
44413: LD_INT 0
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: LIST
44420: PUSH
44421: LD_VAR 0 1
44425: PUSH
44426: LD_INT 3
44428: PLUS
44429: PUSH
44430: LD_VAR 0 2
44434: PUSH
44435: LD_INT 3
44437: PLUS
44438: PUSH
44439: LD_INT 5
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: LIST
44446: PUSH
44447: LD_VAR 0 1
44451: PUSH
44452: LD_INT 4
44454: PLUS
44455: PUSH
44456: LD_VAR 0 2
44460: PUSH
44461: LD_INT 4
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: LIST
44468: PUSH
44469: LD_VAR 0 1
44473: PUSH
44474: LD_VAR 0 2
44478: PUSH
44479: LD_INT 3
44481: MINUS
44482: PUSH
44483: LD_INT 3
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: LIST
44490: PUSH
44491: LD_VAR 0 1
44495: PUSH
44496: LD_INT 4
44498: MINUS
44499: PUSH
44500: LD_VAR 0 2
44504: PUSH
44505: LD_INT 4
44507: MINUS
44508: PUSH
44509: LD_INT 2
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: ST_TO_ADDR
// end ; 5 :
44524: GO 44664
44526: LD_INT 5
44528: DOUBLE
44529: EQUAL
44530: IFTRUE 44534
44532: GO 44663
44534: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44535: LD_ADDR_VAR 0 5
44539: PUSH
44540: LD_VAR 0 1
44544: PUSH
44545: LD_INT 4
44547: MINUS
44548: PUSH
44549: LD_VAR 0 2
44553: PUSH
44554: LD_INT 1
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: LIST
44561: PUSH
44562: LD_VAR 0 1
44566: PUSH
44567: LD_VAR 0 2
44571: PUSH
44572: LD_INT 4
44574: MINUS
44575: PUSH
44576: LD_INT 3
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: LIST
44583: PUSH
44584: LD_VAR 0 1
44588: PUSH
44589: LD_INT 4
44591: PLUS
44592: PUSH
44593: LD_VAR 0 2
44597: PUSH
44598: LD_INT 4
44600: PLUS
44601: PUSH
44602: LD_INT 5
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: LIST
44609: PUSH
44610: LD_VAR 0 1
44614: PUSH
44615: LD_INT 3
44617: PLUS
44618: PUSH
44619: LD_VAR 0 2
44623: PUSH
44624: LD_INT 4
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: LIST
44631: PUSH
44632: LD_VAR 0 1
44636: PUSH
44637: LD_VAR 0 2
44641: PUSH
44642: LD_INT 3
44644: PLUS
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: ST_TO_ADDR
// end ; end ;
44661: GO 44664
44663: POP
// result := list ;
44664: LD_ADDR_VAR 0 4
44668: PUSH
44669: LD_VAR 0 5
44673: ST_TO_ADDR
// end ;
44674: LD_VAR 0 4
44678: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44679: LD_INT 0
44681: PPUSH
44682: PPUSH
44683: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44684: LD_VAR 0 1
44688: NOT
44689: PUSH
44690: LD_VAR 0 2
44694: PUSH
44695: LD_INT 1
44697: PUSH
44698: LD_INT 2
44700: PUSH
44701: LD_INT 3
44703: PUSH
44704: LD_INT 4
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: IN
44713: NOT
44714: OR
44715: IFFALSE 44719
// exit ;
44717: GO 44811
// tmp := [ ] ;
44719: LD_ADDR_VAR 0 5
44723: PUSH
44724: EMPTY
44725: ST_TO_ADDR
// for i in units do
44726: LD_ADDR_VAR 0 4
44730: PUSH
44731: LD_VAR 0 1
44735: PUSH
44736: FOR_IN
44737: IFFALSE 44780
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44739: LD_ADDR_VAR 0 5
44743: PUSH
44744: LD_VAR 0 5
44748: PPUSH
44749: LD_VAR 0 5
44753: PUSH
44754: LD_INT 1
44756: PLUS
44757: PPUSH
44758: LD_VAR 0 4
44762: PPUSH
44763: LD_VAR 0 2
44767: PPUSH
44768: CALL_OW 259
44772: PPUSH
44773: CALL_OW 2
44777: ST_TO_ADDR
44778: GO 44736
44780: POP
44781: POP
// if not tmp then
44782: LD_VAR 0 5
44786: NOT
44787: IFFALSE 44791
// exit ;
44789: GO 44811
// result := SortListByListDesc ( units , tmp ) ;
44791: LD_ADDR_VAR 0 3
44795: PUSH
44796: LD_VAR 0 1
44800: PPUSH
44801: LD_VAR 0 5
44805: PPUSH
44806: CALL_OW 77
44810: ST_TO_ADDR
// end ;
44811: LD_VAR 0 3
44815: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44816: LD_INT 0
44818: PPUSH
44819: PPUSH
44820: PPUSH
// result := false ;
44821: LD_ADDR_VAR 0 3
44825: PUSH
44826: LD_INT 0
44828: ST_TO_ADDR
// x := GetX ( building ) ;
44829: LD_ADDR_VAR 0 4
44833: PUSH
44834: LD_VAR 0 2
44838: PPUSH
44839: CALL_OW 250
44843: ST_TO_ADDR
// y := GetY ( building ) ;
44844: LD_ADDR_VAR 0 5
44848: PUSH
44849: LD_VAR 0 2
44853: PPUSH
44854: CALL_OW 251
44858: ST_TO_ADDR
// if not building or not x or not y then
44859: LD_VAR 0 2
44863: NOT
44864: PUSH
44865: LD_VAR 0 4
44869: NOT
44870: OR
44871: PUSH
44872: LD_VAR 0 5
44876: NOT
44877: OR
44878: IFFALSE 44882
// exit ;
44880: GO 44974
// if GetTaskList ( unit ) then
44882: LD_VAR 0 1
44886: PPUSH
44887: CALL_OW 437
44891: IFFALSE 44974
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44893: LD_STRING e
44895: PUSH
44896: LD_VAR 0 1
44900: PPUSH
44901: CALL_OW 437
44905: PUSH
44906: LD_INT 1
44908: ARRAY
44909: PUSH
44910: LD_INT 1
44912: ARRAY
44913: EQUAL
44914: PUSH
44915: LD_VAR 0 4
44919: PUSH
44920: LD_VAR 0 1
44924: PPUSH
44925: CALL_OW 437
44929: PUSH
44930: LD_INT 1
44932: ARRAY
44933: PUSH
44934: LD_INT 2
44936: ARRAY
44937: EQUAL
44938: AND
44939: PUSH
44940: LD_VAR 0 5
44944: PUSH
44945: LD_VAR 0 1
44949: PPUSH
44950: CALL_OW 437
44954: PUSH
44955: LD_INT 1
44957: ARRAY
44958: PUSH
44959: LD_INT 3
44961: ARRAY
44962: EQUAL
44963: AND
44964: IFFALSE 44974
// result := true end ;
44966: LD_ADDR_VAR 0 3
44970: PUSH
44971: LD_INT 1
44973: ST_TO_ADDR
// end ;
44974: LD_VAR 0 3
44978: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44979: LD_INT 0
44981: PPUSH
// result := false ;
44982: LD_ADDR_VAR 0 4
44986: PUSH
44987: LD_INT 0
44989: ST_TO_ADDR
// if GetTaskList ( unit ) then
44990: LD_VAR 0 1
44994: PPUSH
44995: CALL_OW 437
44999: IFFALSE 45082
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45001: LD_STRING M
45003: PUSH
45004: LD_VAR 0 1
45008: PPUSH
45009: CALL_OW 437
45013: PUSH
45014: LD_INT 1
45016: ARRAY
45017: PUSH
45018: LD_INT 1
45020: ARRAY
45021: EQUAL
45022: PUSH
45023: LD_VAR 0 2
45027: PUSH
45028: LD_VAR 0 1
45032: PPUSH
45033: CALL_OW 437
45037: PUSH
45038: LD_INT 1
45040: ARRAY
45041: PUSH
45042: LD_INT 2
45044: ARRAY
45045: EQUAL
45046: AND
45047: PUSH
45048: LD_VAR 0 3
45052: PUSH
45053: LD_VAR 0 1
45057: PPUSH
45058: CALL_OW 437
45062: PUSH
45063: LD_INT 1
45065: ARRAY
45066: PUSH
45067: LD_INT 3
45069: ARRAY
45070: EQUAL
45071: AND
45072: IFFALSE 45082
// result := true ;
45074: LD_ADDR_VAR 0 4
45078: PUSH
45079: LD_INT 1
45081: ST_TO_ADDR
// end ; end ;
45082: LD_VAR 0 4
45086: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45087: LD_INT 0
45089: PPUSH
45090: PPUSH
45091: PPUSH
45092: PPUSH
// if not unit or not area then
45093: LD_VAR 0 1
45097: NOT
45098: PUSH
45099: LD_VAR 0 2
45103: NOT
45104: OR
45105: IFFALSE 45109
// exit ;
45107: GO 45273
// tmp := AreaToList ( area , i ) ;
45109: LD_ADDR_VAR 0 6
45113: PUSH
45114: LD_VAR 0 2
45118: PPUSH
45119: LD_VAR 0 5
45123: PPUSH
45124: CALL_OW 517
45128: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45129: LD_ADDR_VAR 0 5
45133: PUSH
45134: DOUBLE
45135: LD_INT 1
45137: DEC
45138: ST_TO_ADDR
45139: LD_VAR 0 6
45143: PUSH
45144: LD_INT 1
45146: ARRAY
45147: PUSH
45148: FOR_TO
45149: IFFALSE 45271
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45151: LD_ADDR_VAR 0 7
45155: PUSH
45156: LD_VAR 0 6
45160: PUSH
45161: LD_INT 1
45163: ARRAY
45164: PUSH
45165: LD_VAR 0 5
45169: ARRAY
45170: PUSH
45171: LD_VAR 0 6
45175: PUSH
45176: LD_INT 2
45178: ARRAY
45179: PUSH
45180: LD_VAR 0 5
45184: ARRAY
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45190: LD_VAR 0 7
45194: PUSH
45195: LD_INT 1
45197: ARRAY
45198: PPUSH
45199: LD_VAR 0 7
45203: PUSH
45204: LD_INT 2
45206: ARRAY
45207: PPUSH
45208: CALL_OW 428
45212: PUSH
45213: LD_INT 0
45215: EQUAL
45216: IFFALSE 45269
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45218: LD_VAR 0 1
45222: PPUSH
45223: LD_VAR 0 7
45227: PUSH
45228: LD_INT 1
45230: ARRAY
45231: PPUSH
45232: LD_VAR 0 7
45236: PUSH
45237: LD_INT 2
45239: ARRAY
45240: PPUSH
45241: LD_VAR 0 3
45245: PPUSH
45246: CALL_OW 48
// result := IsPlaced ( unit ) ;
45250: LD_ADDR_VAR 0 4
45254: PUSH
45255: LD_VAR 0 1
45259: PPUSH
45260: CALL_OW 305
45264: ST_TO_ADDR
// exit ;
45265: POP
45266: POP
45267: GO 45273
// end ; end ;
45269: GO 45148
45271: POP
45272: POP
// end ;
45273: LD_VAR 0 4
45277: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45278: LD_INT 0
45280: PPUSH
45281: PPUSH
45282: PPUSH
// if not side or side > 8 then
45283: LD_VAR 0 1
45287: NOT
45288: PUSH
45289: LD_VAR 0 1
45293: PUSH
45294: LD_INT 8
45296: GREATER
45297: OR
45298: IFFALSE 45302
// exit ;
45300: GO 45489
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45302: LD_ADDR_VAR 0 4
45306: PUSH
45307: LD_INT 22
45309: PUSH
45310: LD_VAR 0 1
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: LD_INT 21
45321: PUSH
45322: LD_INT 3
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PPUSH
45333: CALL_OW 69
45337: ST_TO_ADDR
// if not tmp then
45338: LD_VAR 0 4
45342: NOT
45343: IFFALSE 45347
// exit ;
45345: GO 45489
// enable_addtolog := true ;
45347: LD_ADDR_OWVAR 81
45351: PUSH
45352: LD_INT 1
45354: ST_TO_ADDR
// AddToLog ( [ ) ;
45355: LD_STRING [
45357: PPUSH
45358: CALL_OW 561
// for i in tmp do
45362: LD_ADDR_VAR 0 3
45366: PUSH
45367: LD_VAR 0 4
45371: PUSH
45372: FOR_IN
45373: IFFALSE 45480
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45375: LD_STRING [
45377: PUSH
45378: LD_VAR 0 3
45382: PPUSH
45383: CALL_OW 266
45387: STR
45388: PUSH
45389: LD_STRING , 
45391: STR
45392: PUSH
45393: LD_VAR 0 3
45397: PPUSH
45398: CALL_OW 250
45402: STR
45403: PUSH
45404: LD_STRING , 
45406: STR
45407: PUSH
45408: LD_VAR 0 3
45412: PPUSH
45413: CALL_OW 251
45417: STR
45418: PUSH
45419: LD_STRING , 
45421: STR
45422: PUSH
45423: LD_VAR 0 3
45427: PPUSH
45428: CALL_OW 254
45432: STR
45433: PUSH
45434: LD_STRING , 
45436: STR
45437: PUSH
45438: LD_VAR 0 3
45442: PPUSH
45443: LD_INT 1
45445: PPUSH
45446: CALL_OW 268
45450: STR
45451: PUSH
45452: LD_STRING , 
45454: STR
45455: PUSH
45456: LD_VAR 0 3
45460: PPUSH
45461: LD_INT 2
45463: PPUSH
45464: CALL_OW 268
45468: STR
45469: PUSH
45470: LD_STRING ],
45472: STR
45473: PPUSH
45474: CALL_OW 561
// end ;
45478: GO 45372
45480: POP
45481: POP
// AddToLog ( ]; ) ;
45482: LD_STRING ];
45484: PPUSH
45485: CALL_OW 561
// end ;
45489: LD_VAR 0 2
45493: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45494: LD_INT 0
45496: PPUSH
45497: PPUSH
45498: PPUSH
45499: PPUSH
45500: PPUSH
// if not area or not rate or not max then
45501: LD_VAR 0 1
45505: NOT
45506: PUSH
45507: LD_VAR 0 2
45511: NOT
45512: OR
45513: PUSH
45514: LD_VAR 0 4
45518: NOT
45519: OR
45520: IFFALSE 45524
// exit ;
45522: GO 45716
// while 1 do
45524: LD_INT 1
45526: IFFALSE 45716
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45528: LD_ADDR_VAR 0 9
45532: PUSH
45533: LD_VAR 0 1
45537: PPUSH
45538: LD_INT 1
45540: PPUSH
45541: CALL_OW 287
45545: PUSH
45546: LD_INT 10
45548: MUL
45549: ST_TO_ADDR
// r := rate / 10 ;
45550: LD_ADDR_VAR 0 7
45554: PUSH
45555: LD_VAR 0 2
45559: PUSH
45560: LD_INT 10
45562: DIVREAL
45563: ST_TO_ADDR
// time := 1 1$00 ;
45564: LD_ADDR_VAR 0 8
45568: PUSH
45569: LD_INT 2100
45571: ST_TO_ADDR
// if amount < min then
45572: LD_VAR 0 9
45576: PUSH
45577: LD_VAR 0 3
45581: LESS
45582: IFFALSE 45600
// r := r * 2 else
45584: LD_ADDR_VAR 0 7
45588: PUSH
45589: LD_VAR 0 7
45593: PUSH
45594: LD_INT 2
45596: MUL
45597: ST_TO_ADDR
45598: GO 45626
// if amount > max then
45600: LD_VAR 0 9
45604: PUSH
45605: LD_VAR 0 4
45609: GREATER
45610: IFFALSE 45626
// r := r / 2 ;
45612: LD_ADDR_VAR 0 7
45616: PUSH
45617: LD_VAR 0 7
45621: PUSH
45622: LD_INT 2
45624: DIVREAL
45625: ST_TO_ADDR
// time := time / r ;
45626: LD_ADDR_VAR 0 8
45630: PUSH
45631: LD_VAR 0 8
45635: PUSH
45636: LD_VAR 0 7
45640: DIVREAL
45641: ST_TO_ADDR
// if time < 0 then
45642: LD_VAR 0 8
45646: PUSH
45647: LD_INT 0
45649: LESS
45650: IFFALSE 45667
// time := time * - 1 ;
45652: LD_ADDR_VAR 0 8
45656: PUSH
45657: LD_VAR 0 8
45661: PUSH
45662: LD_INT 1
45664: NEG
45665: MUL
45666: ST_TO_ADDR
// wait ( time ) ;
45667: LD_VAR 0 8
45671: PPUSH
45672: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45676: LD_INT 35
45678: PPUSH
45679: LD_INT 875
45681: PPUSH
45682: CALL_OW 12
45686: PPUSH
45687: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45691: LD_INT 1
45693: PPUSH
45694: LD_INT 5
45696: PPUSH
45697: CALL_OW 12
45701: PPUSH
45702: LD_VAR 0 1
45706: PPUSH
45707: LD_INT 1
45709: PPUSH
45710: CALL_OW 55
// end ;
45714: GO 45524
// end ;
45716: LD_VAR 0 5
45720: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45721: LD_INT 0
45723: PPUSH
45724: PPUSH
45725: PPUSH
45726: PPUSH
45727: PPUSH
45728: PPUSH
45729: PPUSH
45730: PPUSH
// if not turrets or not factories then
45731: LD_VAR 0 1
45735: NOT
45736: PUSH
45737: LD_VAR 0 2
45741: NOT
45742: OR
45743: IFFALSE 45747
// exit ;
45745: GO 46054
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45747: LD_ADDR_VAR 0 10
45751: PUSH
45752: LD_INT 5
45754: PUSH
45755: LD_INT 6
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: LD_INT 4
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 5
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 24
45789: PUSH
45790: LD_INT 25
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 23
45799: PUSH
45800: LD_INT 27
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 42
45813: PUSH
45814: LD_INT 43
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 44
45823: PUSH
45824: LD_INT 46
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 45
45833: PUSH
45834: LD_INT 47
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: LIST
45850: ST_TO_ADDR
// result := [ ] ;
45851: LD_ADDR_VAR 0 3
45855: PUSH
45856: EMPTY
45857: ST_TO_ADDR
// for i in turrets do
45858: LD_ADDR_VAR 0 4
45862: PUSH
45863: LD_VAR 0 1
45867: PUSH
45868: FOR_IN
45869: IFFALSE 46052
// begin nat := GetNation ( i ) ;
45871: LD_ADDR_VAR 0 7
45875: PUSH
45876: LD_VAR 0 4
45880: PPUSH
45881: CALL_OW 248
45885: ST_TO_ADDR
// weapon := 0 ;
45886: LD_ADDR_VAR 0 8
45890: PUSH
45891: LD_INT 0
45893: ST_TO_ADDR
// if not nat then
45894: LD_VAR 0 7
45898: NOT
45899: IFFALSE 45903
// continue ;
45901: GO 45868
// for j in list [ nat ] do
45903: LD_ADDR_VAR 0 5
45907: PUSH
45908: LD_VAR 0 10
45912: PUSH
45913: LD_VAR 0 7
45917: ARRAY
45918: PUSH
45919: FOR_IN
45920: IFFALSE 45961
// if GetBWeapon ( i ) = j [ 1 ] then
45922: LD_VAR 0 4
45926: PPUSH
45927: CALL_OW 269
45931: PUSH
45932: LD_VAR 0 5
45936: PUSH
45937: LD_INT 1
45939: ARRAY
45940: EQUAL
45941: IFFALSE 45959
// begin weapon := j [ 2 ] ;
45943: LD_ADDR_VAR 0 8
45947: PUSH
45948: LD_VAR 0 5
45952: PUSH
45953: LD_INT 2
45955: ARRAY
45956: ST_TO_ADDR
// break ;
45957: GO 45961
// end ;
45959: GO 45919
45961: POP
45962: POP
// if not weapon then
45963: LD_VAR 0 8
45967: NOT
45968: IFFALSE 45972
// continue ;
45970: GO 45868
// for k in factories do
45972: LD_ADDR_VAR 0 6
45976: PUSH
45977: LD_VAR 0 2
45981: PUSH
45982: FOR_IN
45983: IFFALSE 46048
// begin weapons := AvailableWeaponList ( k ) ;
45985: LD_ADDR_VAR 0 9
45989: PUSH
45990: LD_VAR 0 6
45994: PPUSH
45995: CALL_OW 478
45999: ST_TO_ADDR
// if not weapons then
46000: LD_VAR 0 9
46004: NOT
46005: IFFALSE 46009
// continue ;
46007: GO 45982
// if weapon in weapons then
46009: LD_VAR 0 8
46013: PUSH
46014: LD_VAR 0 9
46018: IN
46019: IFFALSE 46046
// begin result := [ i , weapon ] ;
46021: LD_ADDR_VAR 0 3
46025: PUSH
46026: LD_VAR 0 4
46030: PUSH
46031: LD_VAR 0 8
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: ST_TO_ADDR
// exit ;
46040: POP
46041: POP
46042: POP
46043: POP
46044: GO 46054
// end ; end ;
46046: GO 45982
46048: POP
46049: POP
// end ;
46050: GO 45868
46052: POP
46053: POP
// end ;
46054: LD_VAR 0 3
46058: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46059: LD_INT 0
46061: PPUSH
// if not side or side > 8 then
46062: LD_VAR 0 3
46066: NOT
46067: PUSH
46068: LD_VAR 0 3
46072: PUSH
46073: LD_INT 8
46075: GREATER
46076: OR
46077: IFFALSE 46081
// exit ;
46079: GO 46140
// if not range then
46081: LD_VAR 0 4
46085: NOT
46086: IFFALSE 46097
// range := - 12 ;
46088: LD_ADDR_VAR 0 4
46092: PUSH
46093: LD_INT 12
46095: NEG
46096: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46097: LD_VAR 0 1
46101: PPUSH
46102: LD_VAR 0 2
46106: PPUSH
46107: LD_VAR 0 3
46111: PPUSH
46112: LD_VAR 0 4
46116: PPUSH
46117: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
46121: LD_VAR 0 1
46125: PPUSH
46126: LD_VAR 0 2
46130: PPUSH
46131: LD_VAR 0 3
46135: PPUSH
46136: CALL_OW 331
// end ;
46140: LD_VAR 0 5
46144: RET
// export function Video ( mode ) ; begin
46145: LD_INT 0
46147: PPUSH
// ingame_video = mode ;
46148: LD_ADDR_OWVAR 52
46152: PUSH
46153: LD_VAR 0 1
46157: ST_TO_ADDR
// interface_hidden = mode ;
46158: LD_ADDR_OWVAR 54
46162: PUSH
46163: LD_VAR 0 1
46167: ST_TO_ADDR
// end ;
46168: LD_VAR 0 2
46172: RET
// export function Join ( array , element ) ; begin
46173: LD_INT 0
46175: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46176: LD_ADDR_VAR 0 3
46180: PUSH
46181: LD_VAR 0 1
46185: PPUSH
46186: LD_VAR 0 1
46190: PUSH
46191: LD_INT 1
46193: PLUS
46194: PPUSH
46195: LD_VAR 0 2
46199: PPUSH
46200: CALL_OW 1
46204: ST_TO_ADDR
// end ;
46205: LD_VAR 0 3
46209: RET
// export function JoinUnion ( array , element ) ; begin
46210: LD_INT 0
46212: PPUSH
// result := array union element ;
46213: LD_ADDR_VAR 0 3
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_VAR 0 2
46227: UNION
46228: ST_TO_ADDR
// end ;
46229: LD_VAR 0 3
46233: RET
// export function GetBehemoths ( side ) ; begin
46234: LD_INT 0
46236: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46237: LD_ADDR_VAR 0 2
46241: PUSH
46242: LD_INT 22
46244: PUSH
46245: LD_VAR 0 1
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 31
46256: PUSH
46257: LD_INT 25
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PPUSH
46268: CALL_OW 69
46272: ST_TO_ADDR
// end ;
46273: LD_VAR 0 2
46277: RET
// export function Shuffle ( array ) ; var i , index ; begin
46278: LD_INT 0
46280: PPUSH
46281: PPUSH
46282: PPUSH
// result := [ ] ;
46283: LD_ADDR_VAR 0 2
46287: PUSH
46288: EMPTY
46289: ST_TO_ADDR
// if not array then
46290: LD_VAR 0 1
46294: NOT
46295: IFFALSE 46299
// exit ;
46297: GO 46398
// Randomize ;
46299: CALL_OW 10
// for i = array downto 1 do
46303: LD_ADDR_VAR 0 3
46307: PUSH
46308: DOUBLE
46309: LD_VAR 0 1
46313: INC
46314: ST_TO_ADDR
46315: LD_INT 1
46317: PUSH
46318: FOR_DOWNTO
46319: IFFALSE 46396
// begin index := rand ( 1 , array ) ;
46321: LD_ADDR_VAR 0 4
46325: PUSH
46326: LD_INT 1
46328: PPUSH
46329: LD_VAR 0 1
46333: PPUSH
46334: CALL_OW 12
46338: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46339: LD_ADDR_VAR 0 2
46343: PUSH
46344: LD_VAR 0 2
46348: PPUSH
46349: LD_VAR 0 2
46353: PUSH
46354: LD_INT 1
46356: PLUS
46357: PPUSH
46358: LD_VAR 0 1
46362: PUSH
46363: LD_VAR 0 4
46367: ARRAY
46368: PPUSH
46369: CALL_OW 2
46373: ST_TO_ADDR
// array := Delete ( array , index ) ;
46374: LD_ADDR_VAR 0 1
46378: PUSH
46379: LD_VAR 0 1
46383: PPUSH
46384: LD_VAR 0 4
46388: PPUSH
46389: CALL_OW 3
46393: ST_TO_ADDR
// end ;
46394: GO 46318
46396: POP
46397: POP
// end ;
46398: LD_VAR 0 2
46402: RET
// export function GetBaseMaterials ( base ) ; begin
46403: LD_INT 0
46405: PPUSH
// result := [ 0 , 0 , 0 ] ;
46406: LD_ADDR_VAR 0 2
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 0
46416: PUSH
46417: LD_INT 0
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: LIST
46424: ST_TO_ADDR
// if not base then
46425: LD_VAR 0 1
46429: NOT
46430: IFFALSE 46434
// exit ;
46432: GO 46483
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46434: LD_ADDR_VAR 0 2
46438: PUSH
46439: LD_VAR 0 1
46443: PPUSH
46444: LD_INT 1
46446: PPUSH
46447: CALL_OW 275
46451: PUSH
46452: LD_VAR 0 1
46456: PPUSH
46457: LD_INT 2
46459: PPUSH
46460: CALL_OW 275
46464: PUSH
46465: LD_VAR 0 1
46469: PPUSH
46470: LD_INT 3
46472: PPUSH
46473: CALL_OW 275
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: LIST
46482: ST_TO_ADDR
// end ;
46483: LD_VAR 0 2
46487: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46488: LD_INT 0
46490: PPUSH
46491: PPUSH
// result := array ;
46492: LD_ADDR_VAR 0 3
46496: PUSH
46497: LD_VAR 0 1
46501: ST_TO_ADDR
// if size > 0 then
46502: LD_VAR 0 2
46506: PUSH
46507: LD_INT 0
46509: GREATER
46510: IFFALSE 46556
// for i := array downto size do
46512: LD_ADDR_VAR 0 4
46516: PUSH
46517: DOUBLE
46518: LD_VAR 0 1
46522: INC
46523: ST_TO_ADDR
46524: LD_VAR 0 2
46528: PUSH
46529: FOR_DOWNTO
46530: IFFALSE 46554
// result := Delete ( result , result ) ;
46532: LD_ADDR_VAR 0 3
46536: PUSH
46537: LD_VAR 0 3
46541: PPUSH
46542: LD_VAR 0 3
46546: PPUSH
46547: CALL_OW 3
46551: ST_TO_ADDR
46552: GO 46529
46554: POP
46555: POP
// end ;
46556: LD_VAR 0 3
46560: RET
// export function ComExit ( unit ) ; var tmp ; begin
46561: LD_INT 0
46563: PPUSH
46564: PPUSH
// if not IsInUnit ( unit ) then
46565: LD_VAR 0 1
46569: PPUSH
46570: CALL_OW 310
46574: NOT
46575: IFFALSE 46579
// exit ;
46577: GO 46639
// tmp := IsInUnit ( unit ) ;
46579: LD_ADDR_VAR 0 3
46583: PUSH
46584: LD_VAR 0 1
46588: PPUSH
46589: CALL_OW 310
46593: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46594: LD_VAR 0 3
46598: PPUSH
46599: CALL_OW 247
46603: PUSH
46604: LD_INT 2
46606: EQUAL
46607: IFFALSE 46620
// ComExitVehicle ( unit ) else
46609: LD_VAR 0 1
46613: PPUSH
46614: CALL_OW 121
46618: GO 46629
// ComExitBuilding ( unit ) ;
46620: LD_VAR 0 1
46624: PPUSH
46625: CALL_OW 122
// result := tmp ;
46629: LD_ADDR_VAR 0 2
46633: PUSH
46634: LD_VAR 0 3
46638: ST_TO_ADDR
// end ;
46639: LD_VAR 0 2
46643: RET
// export function ComExitAll ( units ) ; var i ; begin
46644: LD_INT 0
46646: PPUSH
46647: PPUSH
// if not units then
46648: LD_VAR 0 1
46652: NOT
46653: IFFALSE 46657
// exit ;
46655: GO 46683
// for i in units do
46657: LD_ADDR_VAR 0 3
46661: PUSH
46662: LD_VAR 0 1
46666: PUSH
46667: FOR_IN
46668: IFFALSE 46681
// ComExit ( i ) ;
46670: LD_VAR 0 3
46674: PPUSH
46675: CALL 46561 0 1
46679: GO 46667
46681: POP
46682: POP
// end ;
46683: LD_VAR 0 2
46687: RET
// export function ResetHc ; begin
46688: LD_INT 0
46690: PPUSH
// InitHc ;
46691: CALL_OW 19
// hc_importance := 0 ;
46695: LD_ADDR_OWVAR 32
46699: PUSH
46700: LD_INT 0
46702: ST_TO_ADDR
// end ;
46703: LD_VAR 0 1
46707: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46708: LD_INT 0
46710: PPUSH
46711: PPUSH
46712: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46713: LD_ADDR_VAR 0 6
46717: PUSH
46718: LD_VAR 0 1
46722: PUSH
46723: LD_VAR 0 3
46727: PLUS
46728: PUSH
46729: LD_INT 2
46731: DIV
46732: ST_TO_ADDR
// if _x < 0 then
46733: LD_VAR 0 6
46737: PUSH
46738: LD_INT 0
46740: LESS
46741: IFFALSE 46758
// _x := _x * - 1 ;
46743: LD_ADDR_VAR 0 6
46747: PUSH
46748: LD_VAR 0 6
46752: PUSH
46753: LD_INT 1
46755: NEG
46756: MUL
46757: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46758: LD_ADDR_VAR 0 7
46762: PUSH
46763: LD_VAR 0 2
46767: PUSH
46768: LD_VAR 0 4
46772: PLUS
46773: PUSH
46774: LD_INT 2
46776: DIV
46777: ST_TO_ADDR
// if _y < 0 then
46778: LD_VAR 0 7
46782: PUSH
46783: LD_INT 0
46785: LESS
46786: IFFALSE 46803
// _y := _y * - 1 ;
46788: LD_ADDR_VAR 0 7
46792: PUSH
46793: LD_VAR 0 7
46797: PUSH
46798: LD_INT 1
46800: NEG
46801: MUL
46802: ST_TO_ADDR
// result := [ _x , _y ] ;
46803: LD_ADDR_VAR 0 5
46807: PUSH
46808: LD_VAR 0 6
46812: PUSH
46813: LD_VAR 0 7
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: ST_TO_ADDR
// end ;
46822: LD_VAR 0 5
46826: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46827: LD_INT 0
46829: PPUSH
46830: PPUSH
46831: PPUSH
46832: PPUSH
// task := GetTaskList ( unit ) ;
46833: LD_ADDR_VAR 0 7
46837: PUSH
46838: LD_VAR 0 1
46842: PPUSH
46843: CALL_OW 437
46847: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46848: LD_VAR 0 7
46852: NOT
46853: PUSH
46854: LD_VAR 0 1
46858: PPUSH
46859: LD_VAR 0 2
46863: PPUSH
46864: CALL_OW 308
46868: NOT
46869: AND
46870: IFFALSE 46874
// exit ;
46872: GO 46992
// if IsInArea ( unit , area ) then
46874: LD_VAR 0 1
46878: PPUSH
46879: LD_VAR 0 2
46883: PPUSH
46884: CALL_OW 308
46888: IFFALSE 46906
// begin ComMoveToArea ( unit , goAway ) ;
46890: LD_VAR 0 1
46894: PPUSH
46895: LD_VAR 0 3
46899: PPUSH
46900: CALL_OW 113
// exit ;
46904: GO 46992
// end ; if task [ 1 ] [ 1 ] <> M then
46906: LD_VAR 0 7
46910: PUSH
46911: LD_INT 1
46913: ARRAY
46914: PUSH
46915: LD_INT 1
46917: ARRAY
46918: PUSH
46919: LD_STRING M
46921: NONEQUAL
46922: IFFALSE 46926
// exit ;
46924: GO 46992
// x := task [ 1 ] [ 2 ] ;
46926: LD_ADDR_VAR 0 5
46930: PUSH
46931: LD_VAR 0 7
46935: PUSH
46936: LD_INT 1
46938: ARRAY
46939: PUSH
46940: LD_INT 2
46942: ARRAY
46943: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46944: LD_ADDR_VAR 0 6
46948: PUSH
46949: LD_VAR 0 7
46953: PUSH
46954: LD_INT 1
46956: ARRAY
46957: PUSH
46958: LD_INT 3
46960: ARRAY
46961: ST_TO_ADDR
// if InArea ( x , y , area ) then
46962: LD_VAR 0 5
46966: PPUSH
46967: LD_VAR 0 6
46971: PPUSH
46972: LD_VAR 0 2
46976: PPUSH
46977: CALL_OW 309
46981: IFFALSE 46992
// ComStop ( unit ) ;
46983: LD_VAR 0 1
46987: PPUSH
46988: CALL_OW 141
// end ;
46992: LD_VAR 0 4
46996: RET
// export function Abs ( value ) ; begin
46997: LD_INT 0
46999: PPUSH
// result := value ;
47000: LD_ADDR_VAR 0 2
47004: PUSH
47005: LD_VAR 0 1
47009: ST_TO_ADDR
// if value < 0 then
47010: LD_VAR 0 1
47014: PUSH
47015: LD_INT 0
47017: LESS
47018: IFFALSE 47035
// result := value * - 1 ;
47020: LD_ADDR_VAR 0 2
47024: PUSH
47025: LD_VAR 0 1
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: MUL
47034: ST_TO_ADDR
// end ;
47035: LD_VAR 0 2
47039: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47040: LD_INT 0
47042: PPUSH
47043: PPUSH
47044: PPUSH
47045: PPUSH
47046: PPUSH
47047: PPUSH
47048: PPUSH
47049: PPUSH
// if not unit or not building then
47050: LD_VAR 0 1
47054: NOT
47055: PUSH
47056: LD_VAR 0 2
47060: NOT
47061: OR
47062: IFFALSE 47066
// exit ;
47064: GO 47292
// x := GetX ( building ) ;
47066: LD_ADDR_VAR 0 4
47070: PUSH
47071: LD_VAR 0 2
47075: PPUSH
47076: CALL_OW 250
47080: ST_TO_ADDR
// y := GetY ( building ) ;
47081: LD_ADDR_VAR 0 6
47085: PUSH
47086: LD_VAR 0 2
47090: PPUSH
47091: CALL_OW 251
47095: ST_TO_ADDR
// d := GetDir ( building ) ;
47096: LD_ADDR_VAR 0 8
47100: PUSH
47101: LD_VAR 0 2
47105: PPUSH
47106: CALL_OW 254
47110: ST_TO_ADDR
// r := 4 ;
47111: LD_ADDR_VAR 0 9
47115: PUSH
47116: LD_INT 4
47118: ST_TO_ADDR
// for i := 1 to 5 do
47119: LD_ADDR_VAR 0 10
47123: PUSH
47124: DOUBLE
47125: LD_INT 1
47127: DEC
47128: ST_TO_ADDR
47129: LD_INT 5
47131: PUSH
47132: FOR_TO
47133: IFFALSE 47290
// begin _x := ShiftX ( x , d , r + i ) ;
47135: LD_ADDR_VAR 0 5
47139: PUSH
47140: LD_VAR 0 4
47144: PPUSH
47145: LD_VAR 0 8
47149: PPUSH
47150: LD_VAR 0 9
47154: PUSH
47155: LD_VAR 0 10
47159: PLUS
47160: PPUSH
47161: CALL_OW 272
47165: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47166: LD_ADDR_VAR 0 7
47170: PUSH
47171: LD_VAR 0 6
47175: PPUSH
47176: LD_VAR 0 8
47180: PPUSH
47181: LD_VAR 0 9
47185: PUSH
47186: LD_VAR 0 10
47190: PLUS
47191: PPUSH
47192: CALL_OW 273
47196: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47197: LD_VAR 0 5
47201: PPUSH
47202: LD_VAR 0 7
47206: PPUSH
47207: CALL_OW 488
47211: PUSH
47212: LD_VAR 0 5
47216: PPUSH
47217: LD_VAR 0 7
47221: PPUSH
47222: CALL_OW 428
47226: PPUSH
47227: CALL_OW 247
47231: PUSH
47232: LD_INT 3
47234: PUSH
47235: LD_INT 2
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: IN
47242: NOT
47243: AND
47244: IFFALSE 47288
// begin ComMoveXY ( unit , _x , _y ) ;
47246: LD_VAR 0 1
47250: PPUSH
47251: LD_VAR 0 5
47255: PPUSH
47256: LD_VAR 0 7
47260: PPUSH
47261: CALL_OW 111
// result := [ _x , _y ] ;
47265: LD_ADDR_VAR 0 3
47269: PUSH
47270: LD_VAR 0 5
47274: PUSH
47275: LD_VAR 0 7
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: ST_TO_ADDR
// exit ;
47284: POP
47285: POP
47286: GO 47292
// end ; end ;
47288: GO 47132
47290: POP
47291: POP
// end ;
47292: LD_VAR 0 3
47296: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47297: LD_INT 0
47299: PPUSH
47300: PPUSH
47301: PPUSH
// result := 0 ;
47302: LD_ADDR_VAR 0 3
47306: PUSH
47307: LD_INT 0
47309: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47310: LD_VAR 0 1
47314: PUSH
47315: LD_INT 0
47317: LESS
47318: PUSH
47319: LD_VAR 0 1
47323: PUSH
47324: LD_INT 8
47326: GREATER
47327: OR
47328: PUSH
47329: LD_VAR 0 2
47333: PUSH
47334: LD_INT 0
47336: LESS
47337: OR
47338: PUSH
47339: LD_VAR 0 2
47343: PUSH
47344: LD_INT 8
47346: GREATER
47347: OR
47348: IFFALSE 47352
// exit ;
47350: GO 47427
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47352: LD_ADDR_VAR 0 4
47356: PUSH
47357: LD_INT 22
47359: PUSH
47360: LD_VAR 0 2
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PPUSH
47369: CALL_OW 69
47373: PUSH
47374: FOR_IN
47375: IFFALSE 47425
// begin un := UnitShoot ( i ) ;
47377: LD_ADDR_VAR 0 5
47381: PUSH
47382: LD_VAR 0 4
47386: PPUSH
47387: CALL_OW 504
47391: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47392: LD_VAR 0 5
47396: PPUSH
47397: CALL_OW 255
47401: PUSH
47402: LD_VAR 0 1
47406: EQUAL
47407: IFFALSE 47423
// begin result := un ;
47409: LD_ADDR_VAR 0 3
47413: PUSH
47414: LD_VAR 0 5
47418: ST_TO_ADDR
// exit ;
47419: POP
47420: POP
47421: GO 47427
// end ; end ;
47423: GO 47374
47425: POP
47426: POP
// end ;
47427: LD_VAR 0 3
47431: RET
// export function GetCargoBay ( units ) ; begin
47432: LD_INT 0
47434: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47435: LD_ADDR_VAR 0 2
47439: PUSH
47440: LD_VAR 0 1
47444: PPUSH
47445: LD_INT 2
47447: PUSH
47448: LD_INT 34
47450: PUSH
47451: LD_INT 12
47453: PUSH
47454: EMPTY
47455: LIST
47456: LIST
47457: PUSH
47458: LD_INT 34
47460: PUSH
47461: LD_INT 51
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 34
47470: PUSH
47471: LD_INT 32
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 34
47480: PUSH
47481: LD_EXP 87
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: PPUSH
47497: CALL_OW 72
47501: ST_TO_ADDR
// end ; end_of_file
47502: LD_VAR 0 2
47506: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
47507: LD_INT 0
47509: PPUSH
47510: PPUSH
// skirmish := false ;
47511: LD_ADDR_EXP 41
47515: PUSH
47516: LD_INT 0
47518: ST_TO_ADDR
// debug_mc := false ;
47519: LD_ADDR_EXP 42
47523: PUSH
47524: LD_INT 0
47526: ST_TO_ADDR
// mc_bases := [ ] ;
47527: LD_ADDR_EXP 43
47531: PUSH
47532: EMPTY
47533: ST_TO_ADDR
// mc_sides := [ ] ;
47534: LD_ADDR_EXP 69
47538: PUSH
47539: EMPTY
47540: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47541: LD_ADDR_EXP 44
47545: PUSH
47546: EMPTY
47547: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47548: LD_ADDR_EXP 45
47552: PUSH
47553: EMPTY
47554: ST_TO_ADDR
// mc_need_heal := [ ] ;
47555: LD_ADDR_EXP 46
47559: PUSH
47560: EMPTY
47561: ST_TO_ADDR
// mc_healers := [ ] ;
47562: LD_ADDR_EXP 47
47566: PUSH
47567: EMPTY
47568: ST_TO_ADDR
// mc_build_list := [ ] ;
47569: LD_ADDR_EXP 48
47573: PUSH
47574: EMPTY
47575: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47576: LD_ADDR_EXP 75
47580: PUSH
47581: EMPTY
47582: ST_TO_ADDR
// mc_builders := [ ] ;
47583: LD_ADDR_EXP 49
47587: PUSH
47588: EMPTY
47589: ST_TO_ADDR
// mc_construct_list := [ ] ;
47590: LD_ADDR_EXP 50
47594: PUSH
47595: EMPTY
47596: ST_TO_ADDR
// mc_turret_list := [ ] ;
47597: LD_ADDR_EXP 51
47601: PUSH
47602: EMPTY
47603: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47604: LD_ADDR_EXP 52
47608: PUSH
47609: EMPTY
47610: ST_TO_ADDR
// mc_miners := [ ] ;
47611: LD_ADDR_EXP 57
47615: PUSH
47616: EMPTY
47617: ST_TO_ADDR
// mc_mines := [ ] ;
47618: LD_ADDR_EXP 56
47622: PUSH
47623: EMPTY
47624: ST_TO_ADDR
// mc_minefields := [ ] ;
47625: LD_ADDR_EXP 58
47629: PUSH
47630: EMPTY
47631: ST_TO_ADDR
// mc_crates := [ ] ;
47632: LD_ADDR_EXP 59
47636: PUSH
47637: EMPTY
47638: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47639: LD_ADDR_EXP 60
47643: PUSH
47644: EMPTY
47645: ST_TO_ADDR
// mc_crates_area := [ ] ;
47646: LD_ADDR_EXP 61
47650: PUSH
47651: EMPTY
47652: ST_TO_ADDR
// mc_vehicles := [ ] ;
47653: LD_ADDR_EXP 62
47657: PUSH
47658: EMPTY
47659: ST_TO_ADDR
// mc_attack := [ ] ;
47660: LD_ADDR_EXP 63
47664: PUSH
47665: EMPTY
47666: ST_TO_ADDR
// mc_produce := [ ] ;
47667: LD_ADDR_EXP 64
47671: PUSH
47672: EMPTY
47673: ST_TO_ADDR
// mc_defender := [ ] ;
47674: LD_ADDR_EXP 65
47678: PUSH
47679: EMPTY
47680: ST_TO_ADDR
// mc_parking := [ ] ;
47681: LD_ADDR_EXP 67
47685: PUSH
47686: EMPTY
47687: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47688: LD_ADDR_EXP 53
47692: PUSH
47693: EMPTY
47694: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47695: LD_ADDR_EXP 55
47699: PUSH
47700: EMPTY
47701: ST_TO_ADDR
// mc_scan := [ ] ;
47702: LD_ADDR_EXP 66
47706: PUSH
47707: EMPTY
47708: ST_TO_ADDR
// mc_scan_area := [ ] ;
47709: LD_ADDR_EXP 68
47713: PUSH
47714: EMPTY
47715: ST_TO_ADDR
// mc_tech := [ ] ;
47716: LD_ADDR_EXP 70
47720: PUSH
47721: EMPTY
47722: ST_TO_ADDR
// mc_class := [ ] ;
47723: LD_ADDR_EXP 84
47727: PUSH
47728: EMPTY
47729: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47730: LD_ADDR_EXP 85
47734: PUSH
47735: EMPTY
47736: ST_TO_ADDR
// end ;
47737: LD_VAR 0 1
47741: RET
// export function MC_Kill ( base ) ; begin
47742: LD_INT 0
47744: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47745: LD_ADDR_EXP 43
47749: PUSH
47750: LD_EXP 43
47754: PPUSH
47755: LD_VAR 0 1
47759: PPUSH
47760: EMPTY
47761: PPUSH
47762: CALL_OW 1
47766: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47767: LD_ADDR_EXP 44
47771: PUSH
47772: LD_EXP 44
47776: PPUSH
47777: LD_VAR 0 1
47781: PPUSH
47782: EMPTY
47783: PPUSH
47784: CALL_OW 1
47788: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47789: LD_ADDR_EXP 45
47793: PUSH
47794: LD_EXP 45
47798: PPUSH
47799: LD_VAR 0 1
47803: PPUSH
47804: EMPTY
47805: PPUSH
47806: CALL_OW 1
47810: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47811: LD_ADDR_EXP 46
47815: PUSH
47816: LD_EXP 46
47820: PPUSH
47821: LD_VAR 0 1
47825: PPUSH
47826: EMPTY
47827: PPUSH
47828: CALL_OW 1
47832: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47833: LD_ADDR_EXP 47
47837: PUSH
47838: LD_EXP 47
47842: PPUSH
47843: LD_VAR 0 1
47847: PPUSH
47848: EMPTY
47849: PPUSH
47850: CALL_OW 1
47854: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47855: LD_ADDR_EXP 48
47859: PUSH
47860: LD_EXP 48
47864: PPUSH
47865: LD_VAR 0 1
47869: PPUSH
47870: EMPTY
47871: PPUSH
47872: CALL_OW 1
47876: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47877: LD_ADDR_EXP 49
47881: PUSH
47882: LD_EXP 49
47886: PPUSH
47887: LD_VAR 0 1
47891: PPUSH
47892: EMPTY
47893: PPUSH
47894: CALL_OW 1
47898: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47899: LD_ADDR_EXP 50
47903: PUSH
47904: LD_EXP 50
47908: PPUSH
47909: LD_VAR 0 1
47913: PPUSH
47914: EMPTY
47915: PPUSH
47916: CALL_OW 1
47920: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47921: LD_ADDR_EXP 51
47925: PUSH
47926: LD_EXP 51
47930: PPUSH
47931: LD_VAR 0 1
47935: PPUSH
47936: EMPTY
47937: PPUSH
47938: CALL_OW 1
47942: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47943: LD_ADDR_EXP 52
47947: PUSH
47948: LD_EXP 52
47952: PPUSH
47953: LD_VAR 0 1
47957: PPUSH
47958: EMPTY
47959: PPUSH
47960: CALL_OW 1
47964: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47965: LD_ADDR_EXP 53
47969: PUSH
47970: LD_EXP 53
47974: PPUSH
47975: LD_VAR 0 1
47979: PPUSH
47980: EMPTY
47981: PPUSH
47982: CALL_OW 1
47986: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47987: LD_ADDR_EXP 54
47991: PUSH
47992: LD_EXP 54
47996: PPUSH
47997: LD_VAR 0 1
48001: PPUSH
48002: LD_INT 0
48004: PPUSH
48005: CALL_OW 1
48009: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48010: LD_ADDR_EXP 55
48014: PUSH
48015: LD_EXP 55
48019: PPUSH
48020: LD_VAR 0 1
48024: PPUSH
48025: EMPTY
48026: PPUSH
48027: CALL_OW 1
48031: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48032: LD_ADDR_EXP 56
48036: PUSH
48037: LD_EXP 56
48041: PPUSH
48042: LD_VAR 0 1
48046: PPUSH
48047: EMPTY
48048: PPUSH
48049: CALL_OW 1
48053: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48054: LD_ADDR_EXP 57
48058: PUSH
48059: LD_EXP 57
48063: PPUSH
48064: LD_VAR 0 1
48068: PPUSH
48069: EMPTY
48070: PPUSH
48071: CALL_OW 1
48075: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48076: LD_ADDR_EXP 58
48080: PUSH
48081: LD_EXP 58
48085: PPUSH
48086: LD_VAR 0 1
48090: PPUSH
48091: EMPTY
48092: PPUSH
48093: CALL_OW 1
48097: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48098: LD_ADDR_EXP 59
48102: PUSH
48103: LD_EXP 59
48107: PPUSH
48108: LD_VAR 0 1
48112: PPUSH
48113: EMPTY
48114: PPUSH
48115: CALL_OW 1
48119: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48120: LD_ADDR_EXP 60
48124: PUSH
48125: LD_EXP 60
48129: PPUSH
48130: LD_VAR 0 1
48134: PPUSH
48135: EMPTY
48136: PPUSH
48137: CALL_OW 1
48141: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48142: LD_ADDR_EXP 61
48146: PUSH
48147: LD_EXP 61
48151: PPUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: EMPTY
48158: PPUSH
48159: CALL_OW 1
48163: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48164: LD_ADDR_EXP 62
48168: PUSH
48169: LD_EXP 62
48173: PPUSH
48174: LD_VAR 0 1
48178: PPUSH
48179: EMPTY
48180: PPUSH
48181: CALL_OW 1
48185: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48186: LD_ADDR_EXP 63
48190: PUSH
48191: LD_EXP 63
48195: PPUSH
48196: LD_VAR 0 1
48200: PPUSH
48201: EMPTY
48202: PPUSH
48203: CALL_OW 1
48207: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48208: LD_ADDR_EXP 64
48212: PUSH
48213: LD_EXP 64
48217: PPUSH
48218: LD_VAR 0 1
48222: PPUSH
48223: EMPTY
48224: PPUSH
48225: CALL_OW 1
48229: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48230: LD_ADDR_EXP 65
48234: PUSH
48235: LD_EXP 65
48239: PPUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: EMPTY
48246: PPUSH
48247: CALL_OW 1
48251: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48252: LD_ADDR_EXP 66
48256: PUSH
48257: LD_EXP 66
48261: PPUSH
48262: LD_VAR 0 1
48266: PPUSH
48267: EMPTY
48268: PPUSH
48269: CALL_OW 1
48273: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48274: LD_ADDR_EXP 67
48278: PUSH
48279: LD_EXP 67
48283: PPUSH
48284: LD_VAR 0 1
48288: PPUSH
48289: EMPTY
48290: PPUSH
48291: CALL_OW 1
48295: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48296: LD_ADDR_EXP 68
48300: PUSH
48301: LD_EXP 68
48305: PPUSH
48306: LD_VAR 0 1
48310: PPUSH
48311: EMPTY
48312: PPUSH
48313: CALL_OW 1
48317: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48318: LD_ADDR_EXP 70
48322: PUSH
48323: LD_EXP 70
48327: PPUSH
48328: LD_VAR 0 1
48332: PPUSH
48333: EMPTY
48334: PPUSH
48335: CALL_OW 1
48339: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48340: LD_ADDR_EXP 72
48344: PUSH
48345: LD_EXP 72
48349: PPUSH
48350: LD_VAR 0 1
48354: PPUSH
48355: EMPTY
48356: PPUSH
48357: CALL_OW 1
48361: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48362: LD_ADDR_EXP 73
48366: PUSH
48367: LD_EXP 73
48371: PPUSH
48372: LD_VAR 0 1
48376: PPUSH
48377: EMPTY
48378: PPUSH
48379: CALL_OW 1
48383: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48384: LD_ADDR_EXP 74
48388: PUSH
48389: LD_EXP 74
48393: PPUSH
48394: LD_VAR 0 1
48398: PPUSH
48399: EMPTY
48400: PPUSH
48401: CALL_OW 1
48405: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48406: LD_ADDR_EXP 75
48410: PUSH
48411: LD_EXP 75
48415: PPUSH
48416: LD_VAR 0 1
48420: PPUSH
48421: EMPTY
48422: PPUSH
48423: CALL_OW 1
48427: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48428: LD_ADDR_EXP 76
48432: PUSH
48433: LD_EXP 76
48437: PPUSH
48438: LD_VAR 0 1
48442: PPUSH
48443: EMPTY
48444: PPUSH
48445: CALL_OW 1
48449: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48450: LD_ADDR_EXP 77
48454: PUSH
48455: LD_EXP 77
48459: PPUSH
48460: LD_VAR 0 1
48464: PPUSH
48465: EMPTY
48466: PPUSH
48467: CALL_OW 1
48471: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48472: LD_ADDR_EXP 78
48476: PUSH
48477: LD_EXP 78
48481: PPUSH
48482: LD_VAR 0 1
48486: PPUSH
48487: EMPTY
48488: PPUSH
48489: CALL_OW 1
48493: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48494: LD_ADDR_EXP 79
48498: PUSH
48499: LD_EXP 79
48503: PPUSH
48504: LD_VAR 0 1
48508: PPUSH
48509: EMPTY
48510: PPUSH
48511: CALL_OW 1
48515: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48516: LD_ADDR_EXP 80
48520: PUSH
48521: LD_EXP 80
48525: PPUSH
48526: LD_VAR 0 1
48530: PPUSH
48531: EMPTY
48532: PPUSH
48533: CALL_OW 1
48537: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48538: LD_ADDR_EXP 81
48542: PUSH
48543: LD_EXP 81
48547: PPUSH
48548: LD_VAR 0 1
48552: PPUSH
48553: EMPTY
48554: PPUSH
48555: CALL_OW 1
48559: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48560: LD_ADDR_EXP 82
48564: PUSH
48565: LD_EXP 82
48569: PPUSH
48570: LD_VAR 0 1
48574: PPUSH
48575: EMPTY
48576: PPUSH
48577: CALL_OW 1
48581: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48582: LD_ADDR_EXP 83
48586: PUSH
48587: LD_EXP 83
48591: PPUSH
48592: LD_VAR 0 1
48596: PPUSH
48597: EMPTY
48598: PPUSH
48599: CALL_OW 1
48603: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48604: LD_ADDR_EXP 84
48608: PUSH
48609: LD_EXP 84
48613: PPUSH
48614: LD_VAR 0 1
48618: PPUSH
48619: EMPTY
48620: PPUSH
48621: CALL_OW 1
48625: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48626: LD_ADDR_EXP 85
48630: PUSH
48631: LD_EXP 85
48635: PPUSH
48636: LD_VAR 0 1
48640: PPUSH
48641: LD_INT 0
48643: PPUSH
48644: CALL_OW 1
48648: ST_TO_ADDR
// end ;
48649: LD_VAR 0 2
48653: RET
// export function MC_Add ( side , units ) ; var base ; begin
48654: LD_INT 0
48656: PPUSH
48657: PPUSH
// base := mc_bases + 1 ;
48658: LD_ADDR_VAR 0 4
48662: PUSH
48663: LD_EXP 43
48667: PUSH
48668: LD_INT 1
48670: PLUS
48671: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48672: LD_ADDR_EXP 69
48676: PUSH
48677: LD_EXP 69
48681: PPUSH
48682: LD_VAR 0 4
48686: PPUSH
48687: LD_VAR 0 1
48691: PPUSH
48692: CALL_OW 1
48696: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48697: LD_ADDR_EXP 43
48701: PUSH
48702: LD_EXP 43
48706: PPUSH
48707: LD_VAR 0 4
48711: PPUSH
48712: LD_VAR 0 2
48716: PPUSH
48717: CALL_OW 1
48721: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48722: LD_ADDR_EXP 44
48726: PUSH
48727: LD_EXP 44
48731: PPUSH
48732: LD_VAR 0 4
48736: PPUSH
48737: EMPTY
48738: PPUSH
48739: CALL_OW 1
48743: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48744: LD_ADDR_EXP 45
48748: PUSH
48749: LD_EXP 45
48753: PPUSH
48754: LD_VAR 0 4
48758: PPUSH
48759: EMPTY
48760: PPUSH
48761: CALL_OW 1
48765: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48766: LD_ADDR_EXP 46
48770: PUSH
48771: LD_EXP 46
48775: PPUSH
48776: LD_VAR 0 4
48780: PPUSH
48781: EMPTY
48782: PPUSH
48783: CALL_OW 1
48787: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48788: LD_ADDR_EXP 47
48792: PUSH
48793: LD_EXP 47
48797: PPUSH
48798: LD_VAR 0 4
48802: PPUSH
48803: EMPTY
48804: PPUSH
48805: CALL_OW 1
48809: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48810: LD_ADDR_EXP 48
48814: PUSH
48815: LD_EXP 48
48819: PPUSH
48820: LD_VAR 0 4
48824: PPUSH
48825: EMPTY
48826: PPUSH
48827: CALL_OW 1
48831: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48832: LD_ADDR_EXP 49
48836: PUSH
48837: LD_EXP 49
48841: PPUSH
48842: LD_VAR 0 4
48846: PPUSH
48847: EMPTY
48848: PPUSH
48849: CALL_OW 1
48853: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48854: LD_ADDR_EXP 50
48858: PUSH
48859: LD_EXP 50
48863: PPUSH
48864: LD_VAR 0 4
48868: PPUSH
48869: EMPTY
48870: PPUSH
48871: CALL_OW 1
48875: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48876: LD_ADDR_EXP 51
48880: PUSH
48881: LD_EXP 51
48885: PPUSH
48886: LD_VAR 0 4
48890: PPUSH
48891: EMPTY
48892: PPUSH
48893: CALL_OW 1
48897: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48898: LD_ADDR_EXP 52
48902: PUSH
48903: LD_EXP 52
48907: PPUSH
48908: LD_VAR 0 4
48912: PPUSH
48913: EMPTY
48914: PPUSH
48915: CALL_OW 1
48919: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48920: LD_ADDR_EXP 53
48924: PUSH
48925: LD_EXP 53
48929: PPUSH
48930: LD_VAR 0 4
48934: PPUSH
48935: EMPTY
48936: PPUSH
48937: CALL_OW 1
48941: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48942: LD_ADDR_EXP 54
48946: PUSH
48947: LD_EXP 54
48951: PPUSH
48952: LD_VAR 0 4
48956: PPUSH
48957: LD_INT 0
48959: PPUSH
48960: CALL_OW 1
48964: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48965: LD_ADDR_EXP 55
48969: PUSH
48970: LD_EXP 55
48974: PPUSH
48975: LD_VAR 0 4
48979: PPUSH
48980: EMPTY
48981: PPUSH
48982: CALL_OW 1
48986: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48987: LD_ADDR_EXP 56
48991: PUSH
48992: LD_EXP 56
48996: PPUSH
48997: LD_VAR 0 4
49001: PPUSH
49002: EMPTY
49003: PPUSH
49004: CALL_OW 1
49008: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49009: LD_ADDR_EXP 57
49013: PUSH
49014: LD_EXP 57
49018: PPUSH
49019: LD_VAR 0 4
49023: PPUSH
49024: EMPTY
49025: PPUSH
49026: CALL_OW 1
49030: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49031: LD_ADDR_EXP 58
49035: PUSH
49036: LD_EXP 58
49040: PPUSH
49041: LD_VAR 0 4
49045: PPUSH
49046: EMPTY
49047: PPUSH
49048: CALL_OW 1
49052: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
49053: LD_ADDR_EXP 59
49057: PUSH
49058: LD_EXP 59
49062: PPUSH
49063: LD_VAR 0 4
49067: PPUSH
49068: EMPTY
49069: PPUSH
49070: CALL_OW 1
49074: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
49075: LD_ADDR_EXP 60
49079: PUSH
49080: LD_EXP 60
49084: PPUSH
49085: LD_VAR 0 4
49089: PPUSH
49090: EMPTY
49091: PPUSH
49092: CALL_OW 1
49096: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
49097: LD_ADDR_EXP 61
49101: PUSH
49102: LD_EXP 61
49106: PPUSH
49107: LD_VAR 0 4
49111: PPUSH
49112: EMPTY
49113: PPUSH
49114: CALL_OW 1
49118: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
49119: LD_ADDR_EXP 62
49123: PUSH
49124: LD_EXP 62
49128: PPUSH
49129: LD_VAR 0 4
49133: PPUSH
49134: EMPTY
49135: PPUSH
49136: CALL_OW 1
49140: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
49141: LD_ADDR_EXP 63
49145: PUSH
49146: LD_EXP 63
49150: PPUSH
49151: LD_VAR 0 4
49155: PPUSH
49156: EMPTY
49157: PPUSH
49158: CALL_OW 1
49162: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
49163: LD_ADDR_EXP 64
49167: PUSH
49168: LD_EXP 64
49172: PPUSH
49173: LD_VAR 0 4
49177: PPUSH
49178: EMPTY
49179: PPUSH
49180: CALL_OW 1
49184: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
49185: LD_ADDR_EXP 65
49189: PUSH
49190: LD_EXP 65
49194: PPUSH
49195: LD_VAR 0 4
49199: PPUSH
49200: EMPTY
49201: PPUSH
49202: CALL_OW 1
49206: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
49207: LD_ADDR_EXP 66
49211: PUSH
49212: LD_EXP 66
49216: PPUSH
49217: LD_VAR 0 4
49221: PPUSH
49222: EMPTY
49223: PPUSH
49224: CALL_OW 1
49228: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
49229: LD_ADDR_EXP 67
49233: PUSH
49234: LD_EXP 67
49238: PPUSH
49239: LD_VAR 0 4
49243: PPUSH
49244: EMPTY
49245: PPUSH
49246: CALL_OW 1
49250: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
49251: LD_ADDR_EXP 68
49255: PUSH
49256: LD_EXP 68
49260: PPUSH
49261: LD_VAR 0 4
49265: PPUSH
49266: EMPTY
49267: PPUSH
49268: CALL_OW 1
49272: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
49273: LD_ADDR_EXP 70
49277: PUSH
49278: LD_EXP 70
49282: PPUSH
49283: LD_VAR 0 4
49287: PPUSH
49288: EMPTY
49289: PPUSH
49290: CALL_OW 1
49294: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
49295: LD_ADDR_EXP 72
49299: PUSH
49300: LD_EXP 72
49304: PPUSH
49305: LD_VAR 0 4
49309: PPUSH
49310: EMPTY
49311: PPUSH
49312: CALL_OW 1
49316: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
49317: LD_ADDR_EXP 73
49321: PUSH
49322: LD_EXP 73
49326: PPUSH
49327: LD_VAR 0 4
49331: PPUSH
49332: EMPTY
49333: PPUSH
49334: CALL_OW 1
49338: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
49339: LD_ADDR_EXP 74
49343: PUSH
49344: LD_EXP 74
49348: PPUSH
49349: LD_VAR 0 4
49353: PPUSH
49354: EMPTY
49355: PPUSH
49356: CALL_OW 1
49360: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
49361: LD_ADDR_EXP 75
49365: PUSH
49366: LD_EXP 75
49370: PPUSH
49371: LD_VAR 0 4
49375: PPUSH
49376: EMPTY
49377: PPUSH
49378: CALL_OW 1
49382: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49383: LD_ADDR_EXP 76
49387: PUSH
49388: LD_EXP 76
49392: PPUSH
49393: LD_VAR 0 4
49397: PPUSH
49398: EMPTY
49399: PPUSH
49400: CALL_OW 1
49404: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49405: LD_ADDR_EXP 77
49409: PUSH
49410: LD_EXP 77
49414: PPUSH
49415: LD_VAR 0 4
49419: PPUSH
49420: EMPTY
49421: PPUSH
49422: CALL_OW 1
49426: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49427: LD_ADDR_EXP 78
49431: PUSH
49432: LD_EXP 78
49436: PPUSH
49437: LD_VAR 0 4
49441: PPUSH
49442: EMPTY
49443: PPUSH
49444: CALL_OW 1
49448: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49449: LD_ADDR_EXP 79
49453: PUSH
49454: LD_EXP 79
49458: PPUSH
49459: LD_VAR 0 4
49463: PPUSH
49464: EMPTY
49465: PPUSH
49466: CALL_OW 1
49470: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49471: LD_ADDR_EXP 80
49475: PUSH
49476: LD_EXP 80
49480: PPUSH
49481: LD_VAR 0 4
49485: PPUSH
49486: EMPTY
49487: PPUSH
49488: CALL_OW 1
49492: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49493: LD_ADDR_EXP 81
49497: PUSH
49498: LD_EXP 81
49502: PPUSH
49503: LD_VAR 0 4
49507: PPUSH
49508: EMPTY
49509: PPUSH
49510: CALL_OW 1
49514: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49515: LD_ADDR_EXP 82
49519: PUSH
49520: LD_EXP 82
49524: PPUSH
49525: LD_VAR 0 4
49529: PPUSH
49530: EMPTY
49531: PPUSH
49532: CALL_OW 1
49536: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49537: LD_ADDR_EXP 83
49541: PUSH
49542: LD_EXP 83
49546: PPUSH
49547: LD_VAR 0 4
49551: PPUSH
49552: EMPTY
49553: PPUSH
49554: CALL_OW 1
49558: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49559: LD_ADDR_EXP 84
49563: PUSH
49564: LD_EXP 84
49568: PPUSH
49569: LD_VAR 0 4
49573: PPUSH
49574: EMPTY
49575: PPUSH
49576: CALL_OW 1
49580: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49581: LD_ADDR_EXP 85
49585: PUSH
49586: LD_EXP 85
49590: PPUSH
49591: LD_VAR 0 4
49595: PPUSH
49596: LD_INT 0
49598: PPUSH
49599: CALL_OW 1
49603: ST_TO_ADDR
// result := base ;
49604: LD_ADDR_VAR 0 3
49608: PUSH
49609: LD_VAR 0 4
49613: ST_TO_ADDR
// end ;
49614: LD_VAR 0 3
49618: RET
// export function MC_Start ( ) ; var i ; begin
49619: LD_INT 0
49621: PPUSH
49622: PPUSH
// for i = 1 to mc_bases do
49623: LD_ADDR_VAR 0 2
49627: PUSH
49628: DOUBLE
49629: LD_INT 1
49631: DEC
49632: ST_TO_ADDR
49633: LD_EXP 43
49637: PUSH
49638: FOR_TO
49639: IFFALSE 50716
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49641: LD_ADDR_EXP 43
49645: PUSH
49646: LD_EXP 43
49650: PPUSH
49651: LD_VAR 0 2
49655: PPUSH
49656: LD_EXP 43
49660: PUSH
49661: LD_VAR 0 2
49665: ARRAY
49666: PUSH
49667: LD_INT 0
49669: DIFF
49670: PPUSH
49671: CALL_OW 1
49675: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49676: LD_ADDR_EXP 44
49680: PUSH
49681: LD_EXP 44
49685: PPUSH
49686: LD_VAR 0 2
49690: PPUSH
49691: EMPTY
49692: PPUSH
49693: CALL_OW 1
49697: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49698: LD_ADDR_EXP 45
49702: PUSH
49703: LD_EXP 45
49707: PPUSH
49708: LD_VAR 0 2
49712: PPUSH
49713: EMPTY
49714: PPUSH
49715: CALL_OW 1
49719: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49720: LD_ADDR_EXP 46
49724: PUSH
49725: LD_EXP 46
49729: PPUSH
49730: LD_VAR 0 2
49734: PPUSH
49735: EMPTY
49736: PPUSH
49737: CALL_OW 1
49741: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49742: LD_ADDR_EXP 47
49746: PUSH
49747: LD_EXP 47
49751: PPUSH
49752: LD_VAR 0 2
49756: PPUSH
49757: EMPTY
49758: PUSH
49759: EMPTY
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: PPUSH
49765: CALL_OW 1
49769: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49770: LD_ADDR_EXP 48
49774: PUSH
49775: LD_EXP 48
49779: PPUSH
49780: LD_VAR 0 2
49784: PPUSH
49785: EMPTY
49786: PPUSH
49787: CALL_OW 1
49791: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49792: LD_ADDR_EXP 75
49796: PUSH
49797: LD_EXP 75
49801: PPUSH
49802: LD_VAR 0 2
49806: PPUSH
49807: EMPTY
49808: PPUSH
49809: CALL_OW 1
49813: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49814: LD_ADDR_EXP 49
49818: PUSH
49819: LD_EXP 49
49823: PPUSH
49824: LD_VAR 0 2
49828: PPUSH
49829: EMPTY
49830: PPUSH
49831: CALL_OW 1
49835: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49836: LD_ADDR_EXP 50
49840: PUSH
49841: LD_EXP 50
49845: PPUSH
49846: LD_VAR 0 2
49850: PPUSH
49851: EMPTY
49852: PPUSH
49853: CALL_OW 1
49857: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49858: LD_ADDR_EXP 51
49862: PUSH
49863: LD_EXP 51
49867: PPUSH
49868: LD_VAR 0 2
49872: PPUSH
49873: LD_EXP 43
49877: PUSH
49878: LD_VAR 0 2
49882: ARRAY
49883: PPUSH
49884: LD_INT 2
49886: PUSH
49887: LD_INT 30
49889: PUSH
49890: LD_INT 32
49892: PUSH
49893: EMPTY
49894: LIST
49895: LIST
49896: PUSH
49897: LD_INT 30
49899: PUSH
49900: LD_INT 33
49902: PUSH
49903: EMPTY
49904: LIST
49905: LIST
49906: PUSH
49907: EMPTY
49908: LIST
49909: LIST
49910: LIST
49911: PPUSH
49912: CALL_OW 72
49916: PPUSH
49917: CALL_OW 1
49921: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49922: LD_ADDR_EXP 52
49926: PUSH
49927: LD_EXP 52
49931: PPUSH
49932: LD_VAR 0 2
49936: PPUSH
49937: LD_EXP 43
49941: PUSH
49942: LD_VAR 0 2
49946: ARRAY
49947: PPUSH
49948: LD_INT 2
49950: PUSH
49951: LD_INT 30
49953: PUSH
49954: LD_INT 32
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: PUSH
49961: LD_INT 30
49963: PUSH
49964: LD_INT 31
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: LIST
49975: PUSH
49976: LD_INT 58
49978: PUSH
49979: EMPTY
49980: LIST
49981: PUSH
49982: EMPTY
49983: LIST
49984: LIST
49985: PPUSH
49986: CALL_OW 72
49990: PPUSH
49991: CALL_OW 1
49995: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49996: LD_ADDR_EXP 53
50000: PUSH
50001: LD_EXP 53
50005: PPUSH
50006: LD_VAR 0 2
50010: PPUSH
50011: EMPTY
50012: PPUSH
50013: CALL_OW 1
50017: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
50018: LD_ADDR_EXP 57
50022: PUSH
50023: LD_EXP 57
50027: PPUSH
50028: LD_VAR 0 2
50032: PPUSH
50033: EMPTY
50034: PPUSH
50035: CALL_OW 1
50039: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
50040: LD_ADDR_EXP 56
50044: PUSH
50045: LD_EXP 56
50049: PPUSH
50050: LD_VAR 0 2
50054: PPUSH
50055: EMPTY
50056: PPUSH
50057: CALL_OW 1
50061: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
50062: LD_ADDR_EXP 58
50066: PUSH
50067: LD_EXP 58
50071: PPUSH
50072: LD_VAR 0 2
50076: PPUSH
50077: EMPTY
50078: PPUSH
50079: CALL_OW 1
50083: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
50084: LD_ADDR_EXP 59
50088: PUSH
50089: LD_EXP 59
50093: PPUSH
50094: LD_VAR 0 2
50098: PPUSH
50099: EMPTY
50100: PPUSH
50101: CALL_OW 1
50105: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50106: LD_ADDR_EXP 60
50110: PUSH
50111: LD_EXP 60
50115: PPUSH
50116: LD_VAR 0 2
50120: PPUSH
50121: EMPTY
50122: PPUSH
50123: CALL_OW 1
50127: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
50128: LD_ADDR_EXP 61
50132: PUSH
50133: LD_EXP 61
50137: PPUSH
50138: LD_VAR 0 2
50142: PPUSH
50143: EMPTY
50144: PPUSH
50145: CALL_OW 1
50149: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
50150: LD_ADDR_EXP 62
50154: PUSH
50155: LD_EXP 62
50159: PPUSH
50160: LD_VAR 0 2
50164: PPUSH
50165: EMPTY
50166: PPUSH
50167: CALL_OW 1
50171: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50172: LD_ADDR_EXP 63
50176: PUSH
50177: LD_EXP 63
50181: PPUSH
50182: LD_VAR 0 2
50186: PPUSH
50187: EMPTY
50188: PPUSH
50189: CALL_OW 1
50193: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
50194: LD_ADDR_EXP 64
50198: PUSH
50199: LD_EXP 64
50203: PPUSH
50204: LD_VAR 0 2
50208: PPUSH
50209: EMPTY
50210: PPUSH
50211: CALL_OW 1
50215: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
50216: LD_ADDR_EXP 65
50220: PUSH
50221: LD_EXP 65
50225: PPUSH
50226: LD_VAR 0 2
50230: PPUSH
50231: EMPTY
50232: PPUSH
50233: CALL_OW 1
50237: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
50238: LD_ADDR_EXP 54
50242: PUSH
50243: LD_EXP 54
50247: PPUSH
50248: LD_VAR 0 2
50252: PPUSH
50253: LD_INT 0
50255: PPUSH
50256: CALL_OW 1
50260: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
50261: LD_ADDR_EXP 67
50265: PUSH
50266: LD_EXP 67
50270: PPUSH
50271: LD_VAR 0 2
50275: PPUSH
50276: LD_INT 0
50278: PPUSH
50279: CALL_OW 1
50283: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50284: LD_ADDR_EXP 55
50288: PUSH
50289: LD_EXP 55
50293: PPUSH
50294: LD_VAR 0 2
50298: PPUSH
50299: EMPTY
50300: PPUSH
50301: CALL_OW 1
50305: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
50306: LD_ADDR_EXP 66
50310: PUSH
50311: LD_EXP 66
50315: PPUSH
50316: LD_VAR 0 2
50320: PPUSH
50321: LD_INT 0
50323: PPUSH
50324: CALL_OW 1
50328: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
50329: LD_ADDR_EXP 68
50333: PUSH
50334: LD_EXP 68
50338: PPUSH
50339: LD_VAR 0 2
50343: PPUSH
50344: EMPTY
50345: PPUSH
50346: CALL_OW 1
50350: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
50351: LD_ADDR_EXP 71
50355: PUSH
50356: LD_EXP 71
50360: PPUSH
50361: LD_VAR 0 2
50365: PPUSH
50366: LD_INT 0
50368: PPUSH
50369: CALL_OW 1
50373: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
50374: LD_ADDR_EXP 72
50378: PUSH
50379: LD_EXP 72
50383: PPUSH
50384: LD_VAR 0 2
50388: PPUSH
50389: EMPTY
50390: PPUSH
50391: CALL_OW 1
50395: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50396: LD_ADDR_EXP 73
50400: PUSH
50401: LD_EXP 73
50405: PPUSH
50406: LD_VAR 0 2
50410: PPUSH
50411: EMPTY
50412: PPUSH
50413: CALL_OW 1
50417: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50418: LD_ADDR_EXP 74
50422: PUSH
50423: LD_EXP 74
50427: PPUSH
50428: LD_VAR 0 2
50432: PPUSH
50433: EMPTY
50434: PPUSH
50435: CALL_OW 1
50439: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
50440: LD_ADDR_EXP 76
50444: PUSH
50445: LD_EXP 76
50449: PPUSH
50450: LD_VAR 0 2
50454: PPUSH
50455: LD_EXP 43
50459: PUSH
50460: LD_VAR 0 2
50464: ARRAY
50465: PPUSH
50466: LD_INT 2
50468: PUSH
50469: LD_INT 30
50471: PUSH
50472: LD_INT 6
50474: PUSH
50475: EMPTY
50476: LIST
50477: LIST
50478: PUSH
50479: LD_INT 30
50481: PUSH
50482: LD_INT 7
50484: PUSH
50485: EMPTY
50486: LIST
50487: LIST
50488: PUSH
50489: LD_INT 30
50491: PUSH
50492: LD_INT 8
50494: PUSH
50495: EMPTY
50496: LIST
50497: LIST
50498: PUSH
50499: EMPTY
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: PPUSH
50505: CALL_OW 72
50509: PPUSH
50510: CALL_OW 1
50514: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50515: LD_ADDR_EXP 77
50519: PUSH
50520: LD_EXP 77
50524: PPUSH
50525: LD_VAR 0 2
50529: PPUSH
50530: EMPTY
50531: PPUSH
50532: CALL_OW 1
50536: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50537: LD_ADDR_EXP 78
50541: PUSH
50542: LD_EXP 78
50546: PPUSH
50547: LD_VAR 0 2
50551: PPUSH
50552: EMPTY
50553: PPUSH
50554: CALL_OW 1
50558: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50559: LD_ADDR_EXP 79
50563: PUSH
50564: LD_EXP 79
50568: PPUSH
50569: LD_VAR 0 2
50573: PPUSH
50574: EMPTY
50575: PPUSH
50576: CALL_OW 1
50580: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50581: LD_ADDR_EXP 80
50585: PUSH
50586: LD_EXP 80
50590: PPUSH
50591: LD_VAR 0 2
50595: PPUSH
50596: EMPTY
50597: PPUSH
50598: CALL_OW 1
50602: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50603: LD_ADDR_EXP 81
50607: PUSH
50608: LD_EXP 81
50612: PPUSH
50613: LD_VAR 0 2
50617: PPUSH
50618: EMPTY
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50625: LD_ADDR_EXP 82
50629: PUSH
50630: LD_EXP 82
50634: PPUSH
50635: LD_VAR 0 2
50639: PPUSH
50640: EMPTY
50641: PPUSH
50642: CALL_OW 1
50646: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50647: LD_ADDR_EXP 83
50651: PUSH
50652: LD_EXP 83
50656: PPUSH
50657: LD_VAR 0 2
50661: PPUSH
50662: EMPTY
50663: PPUSH
50664: CALL_OW 1
50668: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50669: LD_ADDR_EXP 84
50673: PUSH
50674: LD_EXP 84
50678: PPUSH
50679: LD_VAR 0 2
50683: PPUSH
50684: EMPTY
50685: PPUSH
50686: CALL_OW 1
50690: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50691: LD_ADDR_EXP 85
50695: PUSH
50696: LD_EXP 85
50700: PPUSH
50701: LD_VAR 0 2
50705: PPUSH
50706: LD_INT 0
50708: PPUSH
50709: CALL_OW 1
50713: ST_TO_ADDR
// end ;
50714: GO 49638
50716: POP
50717: POP
// MC_InitSides ( ) ;
50718: CALL 51004 0 0
// MC_InitResearch ( ) ;
50722: CALL 50743 0 0
// CustomInitMacro ( ) ;
50726: CALL 97 0 0
// skirmish := true ;
50730: LD_ADDR_EXP 41
50734: PUSH
50735: LD_INT 1
50737: ST_TO_ADDR
// end ;
50738: LD_VAR 0 1
50742: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50743: LD_INT 0
50745: PPUSH
50746: PPUSH
50747: PPUSH
50748: PPUSH
50749: PPUSH
50750: PPUSH
// if not mc_bases then
50751: LD_EXP 43
50755: NOT
50756: IFFALSE 50760
// exit ;
50758: GO 50999
// for i = 1 to 8 do
50760: LD_ADDR_VAR 0 2
50764: PUSH
50765: DOUBLE
50766: LD_INT 1
50768: DEC
50769: ST_TO_ADDR
50770: LD_INT 8
50772: PUSH
50773: FOR_TO
50774: IFFALSE 50800
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50776: LD_ADDR_EXP 70
50780: PUSH
50781: LD_EXP 70
50785: PPUSH
50786: LD_VAR 0 2
50790: PPUSH
50791: EMPTY
50792: PPUSH
50793: CALL_OW 1
50797: ST_TO_ADDR
50798: GO 50773
50800: POP
50801: POP
// tmp := [ ] ;
50802: LD_ADDR_VAR 0 5
50806: PUSH
50807: EMPTY
50808: ST_TO_ADDR
// for i = 1 to mc_sides do
50809: LD_ADDR_VAR 0 2
50813: PUSH
50814: DOUBLE
50815: LD_INT 1
50817: DEC
50818: ST_TO_ADDR
50819: LD_EXP 69
50823: PUSH
50824: FOR_TO
50825: IFFALSE 50883
// if not mc_sides [ i ] in tmp then
50827: LD_EXP 69
50831: PUSH
50832: LD_VAR 0 2
50836: ARRAY
50837: PUSH
50838: LD_VAR 0 5
50842: IN
50843: NOT
50844: IFFALSE 50881
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50846: LD_ADDR_VAR 0 5
50850: PUSH
50851: LD_VAR 0 5
50855: PPUSH
50856: LD_VAR 0 5
50860: PUSH
50861: LD_INT 1
50863: PLUS
50864: PPUSH
50865: LD_EXP 69
50869: PUSH
50870: LD_VAR 0 2
50874: ARRAY
50875: PPUSH
50876: CALL_OW 2
50880: ST_TO_ADDR
50881: GO 50824
50883: POP
50884: POP
// if not tmp then
50885: LD_VAR 0 5
50889: NOT
50890: IFFALSE 50894
// exit ;
50892: GO 50999
// for j in tmp do
50894: LD_ADDR_VAR 0 3
50898: PUSH
50899: LD_VAR 0 5
50903: PUSH
50904: FOR_IN
50905: IFFALSE 50997
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50907: LD_ADDR_VAR 0 6
50911: PUSH
50912: LD_INT 22
50914: PUSH
50915: LD_VAR 0 3
50919: PUSH
50920: EMPTY
50921: LIST
50922: LIST
50923: PPUSH
50924: CALL_OW 69
50928: ST_TO_ADDR
// if not un then
50929: LD_VAR 0 6
50933: NOT
50934: IFFALSE 50938
// continue ;
50936: GO 50904
// nation := GetNation ( un [ 1 ] ) ;
50938: LD_ADDR_VAR 0 4
50942: PUSH
50943: LD_VAR 0 6
50947: PUSH
50948: LD_INT 1
50950: ARRAY
50951: PPUSH
50952: CALL_OW 248
50956: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50957: LD_ADDR_EXP 70
50961: PUSH
50962: LD_EXP 70
50966: PPUSH
50967: LD_VAR 0 3
50971: PPUSH
50972: LD_VAR 0 3
50976: PPUSH
50977: LD_VAR 0 4
50981: PPUSH
50982: LD_INT 1
50984: PPUSH
50985: CALL 9914 0 3
50989: PPUSH
50990: CALL_OW 1
50994: ST_TO_ADDR
// end ;
50995: GO 50904
50997: POP
50998: POP
// end ;
50999: LD_VAR 0 1
51003: RET
// export function MC_InitSides ( ) ; var i ; begin
51004: LD_INT 0
51006: PPUSH
51007: PPUSH
// if not mc_bases then
51008: LD_EXP 43
51012: NOT
51013: IFFALSE 51017
// exit ;
51015: GO 51091
// for i = 1 to mc_bases do
51017: LD_ADDR_VAR 0 2
51021: PUSH
51022: DOUBLE
51023: LD_INT 1
51025: DEC
51026: ST_TO_ADDR
51027: LD_EXP 43
51031: PUSH
51032: FOR_TO
51033: IFFALSE 51089
// if mc_bases [ i ] then
51035: LD_EXP 43
51039: PUSH
51040: LD_VAR 0 2
51044: ARRAY
51045: IFFALSE 51087
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
51047: LD_ADDR_EXP 69
51051: PUSH
51052: LD_EXP 69
51056: PPUSH
51057: LD_VAR 0 2
51061: PPUSH
51062: LD_EXP 43
51066: PUSH
51067: LD_VAR 0 2
51071: ARRAY
51072: PUSH
51073: LD_INT 1
51075: ARRAY
51076: PPUSH
51077: CALL_OW 255
51081: PPUSH
51082: CALL_OW 1
51086: ST_TO_ADDR
51087: GO 51032
51089: POP
51090: POP
// end ;
51091: LD_VAR 0 1
51095: RET
// every 0 0$03 trigger skirmish do
51096: LD_EXP 41
51100: IFFALSE 51254
51102: GO 51104
51104: DISABLE
// begin enable ;
51105: ENABLE
// MC_CheckBuildings ( ) ;
51106: CALL 55752 0 0
// MC_CheckPeopleLife ( ) ;
51110: CALL 55877 0 0
// RaiseSailEvent ( 100 ) ;
51114: LD_INT 100
51116: PPUSH
51117: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
51121: LD_INT 103
51123: PPUSH
51124: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
51128: LD_INT 104
51130: PPUSH
51131: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
51135: LD_INT 105
51137: PPUSH
51138: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
51142: LD_INT 106
51144: PPUSH
51145: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
51149: LD_INT 107
51151: PPUSH
51152: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
51156: LD_INT 108
51158: PPUSH
51159: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
51163: LD_INT 109
51165: PPUSH
51166: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
51170: LD_INT 110
51172: PPUSH
51173: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
51177: LD_INT 111
51179: PPUSH
51180: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
51184: LD_INT 112
51186: PPUSH
51187: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
51191: LD_INT 113
51193: PPUSH
51194: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
51198: LD_INT 120
51200: PPUSH
51201: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
51205: LD_INT 121
51207: PPUSH
51208: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
51212: LD_INT 122
51214: PPUSH
51215: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
51219: LD_INT 123
51221: PPUSH
51222: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
51226: LD_INT 124
51228: PPUSH
51229: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
51233: LD_INT 125
51235: PPUSH
51236: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
51240: LD_INT 126
51242: PPUSH
51243: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
51247: LD_INT 200
51249: PPUSH
51250: CALL_OW 427
// end ;
51254: END
// on SailEvent ( event ) do begin if event < 100 then
51255: LD_VAR 0 1
51259: PUSH
51260: LD_INT 100
51262: LESS
51263: IFFALSE 51274
// CustomEvent ( event ) ;
51265: LD_VAR 0 1
51269: PPUSH
51270: CALL 603 0 1
// if event = 100 then
51274: LD_VAR 0 1
51278: PUSH
51279: LD_INT 100
51281: EQUAL
51282: IFFALSE 51288
// MC_ClassManager ( ) ;
51284: CALL 51680 0 0
// if event = 101 then
51288: LD_VAR 0 1
51292: PUSH
51293: LD_INT 101
51295: EQUAL
51296: IFFALSE 51302
// MC_RepairBuildings ( ) ;
51298: CALL 56462 0 0
// if event = 102 then
51302: LD_VAR 0 1
51306: PUSH
51307: LD_INT 102
51309: EQUAL
51310: IFFALSE 51316
// MC_Heal ( ) ;
51312: CALL 57347 0 0
// if event = 103 then
51316: LD_VAR 0 1
51320: PUSH
51321: LD_INT 103
51323: EQUAL
51324: IFFALSE 51330
// MC_Build ( ) ;
51326: CALL 57769 0 0
// if event = 104 then
51330: LD_VAR 0 1
51334: PUSH
51335: LD_INT 104
51337: EQUAL
51338: IFFALSE 51344
// MC_TurretWeapon ( ) ;
51340: CALL 59410 0 0
// if event = 105 then
51344: LD_VAR 0 1
51348: PUSH
51349: LD_INT 105
51351: EQUAL
51352: IFFALSE 51358
// MC_BuildUpgrade ( ) ;
51354: CALL 58961 0 0
// if event = 106 then
51358: LD_VAR 0 1
51362: PUSH
51363: LD_INT 106
51365: EQUAL
51366: IFFALSE 51372
// MC_PlantMines ( ) ;
51368: CALL 59840 0 0
// if event = 107 then
51372: LD_VAR 0 1
51376: PUSH
51377: LD_INT 107
51379: EQUAL
51380: IFFALSE 51386
// MC_CollectCrates ( ) ;
51382: CALL 60631 0 0
// if event = 108 then
51386: LD_VAR 0 1
51390: PUSH
51391: LD_INT 108
51393: EQUAL
51394: IFFALSE 51400
// MC_LinkRemoteControl ( ) ;
51396: CALL 62407 0 0
// if event = 109 then
51400: LD_VAR 0 1
51404: PUSH
51405: LD_INT 109
51407: EQUAL
51408: IFFALSE 51414
// MC_ProduceVehicle ( ) ;
51410: CALL 62588 0 0
// if event = 110 then
51414: LD_VAR 0 1
51418: PUSH
51419: LD_INT 110
51421: EQUAL
51422: IFFALSE 51428
// MC_SendAttack ( ) ;
51424: CALL 63054 0 0
// if event = 111 then
51428: LD_VAR 0 1
51432: PUSH
51433: LD_INT 111
51435: EQUAL
51436: IFFALSE 51442
// MC_Defend ( ) ;
51438: CALL 63162 0 0
// if event = 112 then
51442: LD_VAR 0 1
51446: PUSH
51447: LD_INT 112
51449: EQUAL
51450: IFFALSE 51456
// MC_Research ( ) ;
51452: CALL 63789 0 0
// if event = 113 then
51456: LD_VAR 0 1
51460: PUSH
51461: LD_INT 113
51463: EQUAL
51464: IFFALSE 51470
// MC_MinesTrigger ( ) ;
51466: CALL 64903 0 0
// if event = 120 then
51470: LD_VAR 0 1
51474: PUSH
51475: LD_INT 120
51477: EQUAL
51478: IFFALSE 51484
// MC_RepairVehicle ( ) ;
51480: CALL 65002 0 0
// if event = 121 then
51484: LD_VAR 0 1
51488: PUSH
51489: LD_INT 121
51491: EQUAL
51492: IFFALSE 51498
// MC_TameApe ( ) ;
51494: CALL 65732 0 0
// if event = 122 then
51498: LD_VAR 0 1
51502: PUSH
51503: LD_INT 122
51505: EQUAL
51506: IFFALSE 51512
// MC_ChangeApeClass ( ) ;
51508: CALL 66561 0 0
// if event = 123 then
51512: LD_VAR 0 1
51516: PUSH
51517: LD_INT 123
51519: EQUAL
51520: IFFALSE 51526
// MC_Bazooka ( ) ;
51522: CALL 67211 0 0
// if event = 124 then
51526: LD_VAR 0 1
51530: PUSH
51531: LD_INT 124
51533: EQUAL
51534: IFFALSE 51540
// MC_TeleportExit ( ) ;
51536: CALL 67409 0 0
// if event = 125 then
51540: LD_VAR 0 1
51544: PUSH
51545: LD_INT 125
51547: EQUAL
51548: IFFALSE 51554
// MC_Deposits ( ) ;
51550: CALL 68056 0 0
// if event = 126 then
51554: LD_VAR 0 1
51558: PUSH
51559: LD_INT 126
51561: EQUAL
51562: IFFALSE 51568
// MC_RemoteDriver ( ) ;
51564: CALL 68681 0 0
// if event = 200 then
51568: LD_VAR 0 1
51572: PUSH
51573: LD_INT 200
51575: EQUAL
51576: IFFALSE 51582
// MC_Idle ( ) ;
51578: CALL 70630 0 0
// end ;
51582: PPOPN 1
51584: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51585: LD_INT 0
51587: PPUSH
51588: PPUSH
// if not mc_bases [ base ] or not tag then
51589: LD_EXP 43
51593: PUSH
51594: LD_VAR 0 1
51598: ARRAY
51599: NOT
51600: PUSH
51601: LD_VAR 0 2
51605: NOT
51606: OR
51607: IFFALSE 51611
// exit ;
51609: GO 51675
// for i in mc_bases [ base ] union mc_ape [ base ] do
51611: LD_ADDR_VAR 0 4
51615: PUSH
51616: LD_EXP 43
51620: PUSH
51621: LD_VAR 0 1
51625: ARRAY
51626: PUSH
51627: LD_EXP 72
51631: PUSH
51632: LD_VAR 0 1
51636: ARRAY
51637: UNION
51638: PUSH
51639: FOR_IN
51640: IFFALSE 51673
// if GetTag ( i ) = tag then
51642: LD_VAR 0 4
51646: PPUSH
51647: CALL_OW 110
51651: PUSH
51652: LD_VAR 0 2
51656: EQUAL
51657: IFFALSE 51671
// SetTag ( i , 0 ) ;
51659: LD_VAR 0 4
51663: PPUSH
51664: LD_INT 0
51666: PPUSH
51667: CALL_OW 109
51671: GO 51639
51673: POP
51674: POP
// end ;
51675: LD_VAR 0 3
51679: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51680: LD_INT 0
51682: PPUSH
51683: PPUSH
51684: PPUSH
51685: PPUSH
51686: PPUSH
51687: PPUSH
51688: PPUSH
51689: PPUSH
// if not mc_bases then
51690: LD_EXP 43
51694: NOT
51695: IFFALSE 51699
// exit ;
51697: GO 52157
// for i = 1 to mc_bases do
51699: LD_ADDR_VAR 0 2
51703: PUSH
51704: DOUBLE
51705: LD_INT 1
51707: DEC
51708: ST_TO_ADDR
51709: LD_EXP 43
51713: PUSH
51714: FOR_TO
51715: IFFALSE 52155
// begin tmp := MC_ClassCheckReq ( i ) ;
51717: LD_ADDR_VAR 0 4
51721: PUSH
51722: LD_VAR 0 2
51726: PPUSH
51727: CALL 52162 0 1
51731: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51732: LD_ADDR_EXP 84
51736: PUSH
51737: LD_EXP 84
51741: PPUSH
51742: LD_VAR 0 2
51746: PPUSH
51747: LD_VAR 0 4
51751: PPUSH
51752: CALL_OW 1
51756: ST_TO_ADDR
// if not tmp then
51757: LD_VAR 0 4
51761: NOT
51762: IFFALSE 51766
// continue ;
51764: GO 51714
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51766: LD_ADDR_VAR 0 6
51770: PUSH
51771: LD_EXP 43
51775: PUSH
51776: LD_VAR 0 2
51780: ARRAY
51781: PPUSH
51782: LD_INT 2
51784: PUSH
51785: LD_INT 30
51787: PUSH
51788: LD_INT 4
51790: PUSH
51791: EMPTY
51792: LIST
51793: LIST
51794: PUSH
51795: LD_INT 30
51797: PUSH
51798: LD_INT 5
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: PUSH
51805: EMPTY
51806: LIST
51807: LIST
51808: LIST
51809: PPUSH
51810: CALL_OW 72
51814: PUSH
51815: LD_EXP 43
51819: PUSH
51820: LD_VAR 0 2
51824: ARRAY
51825: PPUSH
51826: LD_INT 2
51828: PUSH
51829: LD_INT 30
51831: PUSH
51832: LD_INT 0
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: PUSH
51839: LD_INT 30
51841: PUSH
51842: LD_INT 1
51844: PUSH
51845: EMPTY
51846: LIST
51847: LIST
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: LIST
51853: PPUSH
51854: CALL_OW 72
51858: PUSH
51859: LD_EXP 43
51863: PUSH
51864: LD_VAR 0 2
51868: ARRAY
51869: PPUSH
51870: LD_INT 30
51872: PUSH
51873: LD_INT 3
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: PPUSH
51880: CALL_OW 72
51884: PUSH
51885: LD_EXP 43
51889: PUSH
51890: LD_VAR 0 2
51894: ARRAY
51895: PPUSH
51896: LD_INT 2
51898: PUSH
51899: LD_INT 30
51901: PUSH
51902: LD_INT 6
51904: PUSH
51905: EMPTY
51906: LIST
51907: LIST
51908: PUSH
51909: LD_INT 30
51911: PUSH
51912: LD_INT 7
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PUSH
51919: LD_INT 30
51921: PUSH
51922: LD_INT 8
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: PPUSH
51935: CALL_OW 72
51939: PUSH
51940: EMPTY
51941: LIST
51942: LIST
51943: LIST
51944: LIST
51945: ST_TO_ADDR
// for j = 1 to 4 do
51946: LD_ADDR_VAR 0 3
51950: PUSH
51951: DOUBLE
51952: LD_INT 1
51954: DEC
51955: ST_TO_ADDR
51956: LD_INT 4
51958: PUSH
51959: FOR_TO
51960: IFFALSE 52151
// begin if not tmp [ j ] then
51962: LD_VAR 0 4
51966: PUSH
51967: LD_VAR 0 3
51971: ARRAY
51972: NOT
51973: IFFALSE 51977
// continue ;
51975: GO 51959
// for p in tmp [ j ] do
51977: LD_ADDR_VAR 0 5
51981: PUSH
51982: LD_VAR 0 4
51986: PUSH
51987: LD_VAR 0 3
51991: ARRAY
51992: PUSH
51993: FOR_IN
51994: IFFALSE 52147
// begin if not b [ j ] then
51996: LD_VAR 0 6
52000: PUSH
52001: LD_VAR 0 3
52005: ARRAY
52006: NOT
52007: IFFALSE 52011
// break ;
52009: GO 52147
// e := 0 ;
52011: LD_ADDR_VAR 0 7
52015: PUSH
52016: LD_INT 0
52018: ST_TO_ADDR
// for k in b [ j ] do
52019: LD_ADDR_VAR 0 8
52023: PUSH
52024: LD_VAR 0 6
52028: PUSH
52029: LD_VAR 0 3
52033: ARRAY
52034: PUSH
52035: FOR_IN
52036: IFFALSE 52063
// if IsNotFull ( k ) then
52038: LD_VAR 0 8
52042: PPUSH
52043: CALL 12063 0 1
52047: IFFALSE 52061
// begin e := k ;
52049: LD_ADDR_VAR 0 7
52053: PUSH
52054: LD_VAR 0 8
52058: ST_TO_ADDR
// break ;
52059: GO 52063
// end ;
52061: GO 52035
52063: POP
52064: POP
// if e and not UnitGoingToBuilding ( p , e ) then
52065: LD_VAR 0 7
52069: PUSH
52070: LD_VAR 0 5
52074: PPUSH
52075: LD_VAR 0 7
52079: PPUSH
52080: CALL 44816 0 2
52084: NOT
52085: AND
52086: IFFALSE 52145
// begin if IsInUnit ( p ) then
52088: LD_VAR 0 5
52092: PPUSH
52093: CALL_OW 310
52097: IFFALSE 52108
// ComExitBuilding ( p ) ;
52099: LD_VAR 0 5
52103: PPUSH
52104: CALL_OW 122
// ComEnterUnit ( p , e ) ;
52108: LD_VAR 0 5
52112: PPUSH
52113: LD_VAR 0 7
52117: PPUSH
52118: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
52122: LD_VAR 0 5
52126: PPUSH
52127: LD_VAR 0 3
52131: PPUSH
52132: CALL_OW 183
// AddComExitBuilding ( p ) ;
52136: LD_VAR 0 5
52140: PPUSH
52141: CALL_OW 182
// end ; end ;
52145: GO 51993
52147: POP
52148: POP
// end ;
52149: GO 51959
52151: POP
52152: POP
// end ;
52153: GO 51714
52155: POP
52156: POP
// end ;
52157: LD_VAR 0 1
52161: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
52162: LD_INT 0
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
52169: PPUSH
52170: PPUSH
52171: PPUSH
52172: PPUSH
52173: PPUSH
52174: PPUSH
52175: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52176: LD_VAR 0 1
52180: NOT
52181: PUSH
52182: LD_EXP 43
52186: PUSH
52187: LD_VAR 0 1
52191: ARRAY
52192: NOT
52193: OR
52194: PUSH
52195: LD_EXP 43
52199: PUSH
52200: LD_VAR 0 1
52204: ARRAY
52205: PPUSH
52206: LD_INT 2
52208: PUSH
52209: LD_INT 30
52211: PUSH
52212: LD_INT 0
52214: PUSH
52215: EMPTY
52216: LIST
52217: LIST
52218: PUSH
52219: LD_INT 30
52221: PUSH
52222: LD_INT 1
52224: PUSH
52225: EMPTY
52226: LIST
52227: LIST
52228: PUSH
52229: EMPTY
52230: LIST
52231: LIST
52232: LIST
52233: PPUSH
52234: CALL_OW 72
52238: NOT
52239: OR
52240: IFFALSE 52244
// exit ;
52242: GO 55747
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52244: LD_ADDR_VAR 0 4
52248: PUSH
52249: LD_EXP 43
52253: PUSH
52254: LD_VAR 0 1
52258: ARRAY
52259: PPUSH
52260: LD_INT 2
52262: PUSH
52263: LD_INT 25
52265: PUSH
52266: LD_INT 1
52268: PUSH
52269: EMPTY
52270: LIST
52271: LIST
52272: PUSH
52273: LD_INT 25
52275: PUSH
52276: LD_INT 2
52278: PUSH
52279: EMPTY
52280: LIST
52281: LIST
52282: PUSH
52283: LD_INT 25
52285: PUSH
52286: LD_INT 3
52288: PUSH
52289: EMPTY
52290: LIST
52291: LIST
52292: PUSH
52293: LD_INT 25
52295: PUSH
52296: LD_INT 4
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: PUSH
52303: LD_INT 25
52305: PUSH
52306: LD_INT 5
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: PUSH
52313: LD_INT 25
52315: PUSH
52316: LD_INT 8
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: PUSH
52323: LD_INT 25
52325: PUSH
52326: LD_INT 9
52328: PUSH
52329: EMPTY
52330: LIST
52331: LIST
52332: PUSH
52333: EMPTY
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: PPUSH
52343: CALL_OW 72
52347: ST_TO_ADDR
// if not tmp then
52348: LD_VAR 0 4
52352: NOT
52353: IFFALSE 52357
// exit ;
52355: GO 55747
// for i in tmp do
52357: LD_ADDR_VAR 0 3
52361: PUSH
52362: LD_VAR 0 4
52366: PUSH
52367: FOR_IN
52368: IFFALSE 52399
// if GetTag ( i ) then
52370: LD_VAR 0 3
52374: PPUSH
52375: CALL_OW 110
52379: IFFALSE 52397
// tmp := tmp diff i ;
52381: LD_ADDR_VAR 0 4
52385: PUSH
52386: LD_VAR 0 4
52390: PUSH
52391: LD_VAR 0 3
52395: DIFF
52396: ST_TO_ADDR
52397: GO 52367
52399: POP
52400: POP
// if not tmp then
52401: LD_VAR 0 4
52405: NOT
52406: IFFALSE 52410
// exit ;
52408: GO 55747
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52410: LD_ADDR_VAR 0 5
52414: PUSH
52415: LD_EXP 43
52419: PUSH
52420: LD_VAR 0 1
52424: ARRAY
52425: PPUSH
52426: LD_INT 2
52428: PUSH
52429: LD_INT 25
52431: PUSH
52432: LD_INT 1
52434: PUSH
52435: EMPTY
52436: LIST
52437: LIST
52438: PUSH
52439: LD_INT 25
52441: PUSH
52442: LD_INT 5
52444: PUSH
52445: EMPTY
52446: LIST
52447: LIST
52448: PUSH
52449: LD_INT 25
52451: PUSH
52452: LD_INT 8
52454: PUSH
52455: EMPTY
52456: LIST
52457: LIST
52458: PUSH
52459: LD_INT 25
52461: PUSH
52462: LD_INT 9
52464: PUSH
52465: EMPTY
52466: LIST
52467: LIST
52468: PUSH
52469: EMPTY
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: LIST
52475: PPUSH
52476: CALL_OW 72
52480: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52481: LD_ADDR_VAR 0 6
52485: PUSH
52486: LD_EXP 43
52490: PUSH
52491: LD_VAR 0 1
52495: ARRAY
52496: PPUSH
52497: LD_INT 25
52499: PUSH
52500: LD_INT 2
52502: PUSH
52503: EMPTY
52504: LIST
52505: LIST
52506: PPUSH
52507: CALL_OW 72
52511: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52512: LD_ADDR_VAR 0 7
52516: PUSH
52517: LD_EXP 43
52521: PUSH
52522: LD_VAR 0 1
52526: ARRAY
52527: PPUSH
52528: LD_INT 25
52530: PUSH
52531: LD_INT 3
52533: PUSH
52534: EMPTY
52535: LIST
52536: LIST
52537: PPUSH
52538: CALL_OW 72
52542: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52543: LD_ADDR_VAR 0 8
52547: PUSH
52548: LD_EXP 43
52552: PUSH
52553: LD_VAR 0 1
52557: ARRAY
52558: PPUSH
52559: LD_INT 25
52561: PUSH
52562: LD_INT 4
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: PUSH
52569: LD_INT 24
52571: PUSH
52572: LD_INT 251
52574: PUSH
52575: EMPTY
52576: LIST
52577: LIST
52578: PUSH
52579: EMPTY
52580: LIST
52581: LIST
52582: PPUSH
52583: CALL_OW 72
52587: ST_TO_ADDR
// if mc_scan [ base ] then
52588: LD_EXP 66
52592: PUSH
52593: LD_VAR 0 1
52597: ARRAY
52598: IFFALSE 53059
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52600: LD_ADDR_EXP 85
52604: PUSH
52605: LD_EXP 85
52609: PPUSH
52610: LD_VAR 0 1
52614: PPUSH
52615: LD_INT 4
52617: PPUSH
52618: CALL_OW 1
52622: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52623: LD_ADDR_VAR 0 12
52627: PUSH
52628: LD_EXP 43
52632: PUSH
52633: LD_VAR 0 1
52637: ARRAY
52638: PPUSH
52639: LD_INT 2
52641: PUSH
52642: LD_INT 30
52644: PUSH
52645: LD_INT 4
52647: PUSH
52648: EMPTY
52649: LIST
52650: LIST
52651: PUSH
52652: LD_INT 30
52654: PUSH
52655: LD_INT 5
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: PUSH
52662: EMPTY
52663: LIST
52664: LIST
52665: LIST
52666: PPUSH
52667: CALL_OW 72
52671: ST_TO_ADDR
// if not b then
52672: LD_VAR 0 12
52676: NOT
52677: IFFALSE 52681
// exit ;
52679: GO 55747
// p := [ ] ;
52681: LD_ADDR_VAR 0 11
52685: PUSH
52686: EMPTY
52687: ST_TO_ADDR
// if sci >= 2 then
52688: LD_VAR 0 8
52692: PUSH
52693: LD_INT 2
52695: GREATEREQUAL
52696: IFFALSE 52727
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52698: LD_ADDR_VAR 0 8
52702: PUSH
52703: LD_VAR 0 8
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PUSH
52712: LD_VAR 0 8
52716: PUSH
52717: LD_INT 2
52719: ARRAY
52720: PUSH
52721: EMPTY
52722: LIST
52723: LIST
52724: ST_TO_ADDR
52725: GO 52788
// if sci = 1 then
52727: LD_VAR 0 8
52731: PUSH
52732: LD_INT 1
52734: EQUAL
52735: IFFALSE 52756
// sci := [ sci [ 1 ] ] else
52737: LD_ADDR_VAR 0 8
52741: PUSH
52742: LD_VAR 0 8
52746: PUSH
52747: LD_INT 1
52749: ARRAY
52750: PUSH
52751: EMPTY
52752: LIST
52753: ST_TO_ADDR
52754: GO 52788
// if sci = 0 then
52756: LD_VAR 0 8
52760: PUSH
52761: LD_INT 0
52763: EQUAL
52764: IFFALSE 52788
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52766: LD_ADDR_VAR 0 11
52770: PUSH
52771: LD_VAR 0 4
52775: PPUSH
52776: LD_INT 4
52778: PPUSH
52779: CALL 44679 0 2
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: ST_TO_ADDR
// if eng > 4 then
52788: LD_VAR 0 6
52792: PUSH
52793: LD_INT 4
52795: GREATER
52796: IFFALSE 52842
// for i = eng downto 4 do
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: DOUBLE
52804: LD_VAR 0 6
52808: INC
52809: ST_TO_ADDR
52810: LD_INT 4
52812: PUSH
52813: FOR_DOWNTO
52814: IFFALSE 52840
// eng := eng diff eng [ i ] ;
52816: LD_ADDR_VAR 0 6
52820: PUSH
52821: LD_VAR 0 6
52825: PUSH
52826: LD_VAR 0 6
52830: PUSH
52831: LD_VAR 0 3
52835: ARRAY
52836: DIFF
52837: ST_TO_ADDR
52838: GO 52813
52840: POP
52841: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52842: LD_ADDR_VAR 0 4
52846: PUSH
52847: LD_VAR 0 4
52851: PUSH
52852: LD_VAR 0 5
52856: PUSH
52857: LD_VAR 0 6
52861: UNION
52862: PUSH
52863: LD_VAR 0 7
52867: UNION
52868: PUSH
52869: LD_VAR 0 8
52873: UNION
52874: DIFF
52875: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52876: LD_ADDR_VAR 0 13
52880: PUSH
52881: LD_EXP 43
52885: PUSH
52886: LD_VAR 0 1
52890: ARRAY
52891: PPUSH
52892: LD_INT 2
52894: PUSH
52895: LD_INT 30
52897: PUSH
52898: LD_INT 32
52900: PUSH
52901: EMPTY
52902: LIST
52903: LIST
52904: PUSH
52905: LD_INT 30
52907: PUSH
52908: LD_INT 31
52910: PUSH
52911: EMPTY
52912: LIST
52913: LIST
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: PPUSH
52920: CALL_OW 72
52924: PUSH
52925: LD_EXP 43
52929: PUSH
52930: LD_VAR 0 1
52934: ARRAY
52935: PPUSH
52936: LD_INT 2
52938: PUSH
52939: LD_INT 30
52941: PUSH
52942: LD_INT 4
52944: PUSH
52945: EMPTY
52946: LIST
52947: LIST
52948: PUSH
52949: LD_INT 30
52951: PUSH
52952: LD_INT 5
52954: PUSH
52955: EMPTY
52956: LIST
52957: LIST
52958: PUSH
52959: EMPTY
52960: LIST
52961: LIST
52962: LIST
52963: PPUSH
52964: CALL_OW 72
52968: PUSH
52969: LD_INT 6
52971: MUL
52972: PLUS
52973: ST_TO_ADDR
// if bcount < tmp then
52974: LD_VAR 0 13
52978: PUSH
52979: LD_VAR 0 4
52983: LESS
52984: IFFALSE 53030
// for i = tmp downto bcount do
52986: LD_ADDR_VAR 0 3
52990: PUSH
52991: DOUBLE
52992: LD_VAR 0 4
52996: INC
52997: ST_TO_ADDR
52998: LD_VAR 0 13
53002: PUSH
53003: FOR_DOWNTO
53004: IFFALSE 53028
// tmp := Delete ( tmp , tmp ) ;
53006: LD_ADDR_VAR 0 4
53010: PUSH
53011: LD_VAR 0 4
53015: PPUSH
53016: LD_VAR 0 4
53020: PPUSH
53021: CALL_OW 3
53025: ST_TO_ADDR
53026: GO 53003
53028: POP
53029: POP
// result := [ tmp , 0 , 0 , p ] ;
53030: LD_ADDR_VAR 0 2
53034: PUSH
53035: LD_VAR 0 4
53039: PUSH
53040: LD_INT 0
53042: PUSH
53043: LD_INT 0
53045: PUSH
53046: LD_VAR 0 11
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: LIST
53055: LIST
53056: ST_TO_ADDR
// exit ;
53057: GO 55747
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53059: LD_EXP 43
53063: PUSH
53064: LD_VAR 0 1
53068: ARRAY
53069: PPUSH
53070: LD_INT 2
53072: PUSH
53073: LD_INT 30
53075: PUSH
53076: LD_INT 6
53078: PUSH
53079: EMPTY
53080: LIST
53081: LIST
53082: PUSH
53083: LD_INT 30
53085: PUSH
53086: LD_INT 7
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: PUSH
53093: LD_INT 30
53095: PUSH
53096: LD_INT 8
53098: PUSH
53099: EMPTY
53100: LIST
53101: LIST
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: LIST
53107: LIST
53108: PPUSH
53109: CALL_OW 72
53113: NOT
53114: PUSH
53115: LD_EXP 43
53119: PUSH
53120: LD_VAR 0 1
53124: ARRAY
53125: PPUSH
53126: LD_INT 30
53128: PUSH
53129: LD_INT 3
53131: PUSH
53132: EMPTY
53133: LIST
53134: LIST
53135: PPUSH
53136: CALL_OW 72
53140: NOT
53141: AND
53142: IFFALSE 53214
// begin if eng = tmp then
53144: LD_VAR 0 6
53148: PUSH
53149: LD_VAR 0 4
53153: EQUAL
53154: IFFALSE 53158
// exit ;
53156: GO 55747
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
53158: LD_ADDR_EXP 85
53162: PUSH
53163: LD_EXP 85
53167: PPUSH
53168: LD_VAR 0 1
53172: PPUSH
53173: LD_INT 1
53175: PPUSH
53176: CALL_OW 1
53180: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
53181: LD_ADDR_VAR 0 2
53185: PUSH
53186: LD_INT 0
53188: PUSH
53189: LD_VAR 0 4
53193: PUSH
53194: LD_VAR 0 6
53198: DIFF
53199: PUSH
53200: LD_INT 0
53202: PUSH
53203: LD_INT 0
53205: PUSH
53206: EMPTY
53207: LIST
53208: LIST
53209: LIST
53210: LIST
53211: ST_TO_ADDR
// exit ;
53212: GO 55747
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53214: LD_EXP 70
53218: PUSH
53219: LD_EXP 69
53223: PUSH
53224: LD_VAR 0 1
53228: ARRAY
53229: ARRAY
53230: PUSH
53231: LD_EXP 43
53235: PUSH
53236: LD_VAR 0 1
53240: ARRAY
53241: PPUSH
53242: LD_INT 2
53244: PUSH
53245: LD_INT 30
53247: PUSH
53248: LD_INT 6
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: LD_INT 30
53257: PUSH
53258: LD_INT 7
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PUSH
53265: LD_INT 30
53267: PUSH
53268: LD_INT 8
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: LIST
53280: PPUSH
53281: CALL_OW 72
53285: AND
53286: PUSH
53287: LD_EXP 43
53291: PUSH
53292: LD_VAR 0 1
53296: ARRAY
53297: PPUSH
53298: LD_INT 30
53300: PUSH
53301: LD_INT 3
53303: PUSH
53304: EMPTY
53305: LIST
53306: LIST
53307: PPUSH
53308: CALL_OW 72
53312: NOT
53313: AND
53314: IFFALSE 53528
// begin if sci >= 6 then
53316: LD_VAR 0 8
53320: PUSH
53321: LD_INT 6
53323: GREATEREQUAL
53324: IFFALSE 53328
// exit ;
53326: GO 55747
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
53328: LD_ADDR_EXP 85
53332: PUSH
53333: LD_EXP 85
53337: PPUSH
53338: LD_VAR 0 1
53342: PPUSH
53343: LD_INT 2
53345: PPUSH
53346: CALL_OW 1
53350: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
53351: LD_ADDR_VAR 0 9
53355: PUSH
53356: LD_VAR 0 4
53360: PUSH
53361: LD_VAR 0 8
53365: DIFF
53366: PPUSH
53367: LD_INT 4
53369: PPUSH
53370: CALL 44679 0 2
53374: ST_TO_ADDR
// p := [ ] ;
53375: LD_ADDR_VAR 0 11
53379: PUSH
53380: EMPTY
53381: ST_TO_ADDR
// if sci < 6 and sort > 6 then
53382: LD_VAR 0 8
53386: PUSH
53387: LD_INT 6
53389: LESS
53390: PUSH
53391: LD_VAR 0 9
53395: PUSH
53396: LD_INT 6
53398: GREATER
53399: AND
53400: IFFALSE 53481
// begin for i = 1 to 6 - sci do
53402: LD_ADDR_VAR 0 3
53406: PUSH
53407: DOUBLE
53408: LD_INT 1
53410: DEC
53411: ST_TO_ADDR
53412: LD_INT 6
53414: PUSH
53415: LD_VAR 0 8
53419: MINUS
53420: PUSH
53421: FOR_TO
53422: IFFALSE 53477
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
53424: LD_ADDR_VAR 0 11
53428: PUSH
53429: LD_VAR 0 11
53433: PPUSH
53434: LD_VAR 0 11
53438: PUSH
53439: LD_INT 1
53441: PLUS
53442: PPUSH
53443: LD_VAR 0 9
53447: PUSH
53448: LD_INT 1
53450: ARRAY
53451: PPUSH
53452: CALL_OW 2
53456: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53457: LD_ADDR_VAR 0 9
53461: PUSH
53462: LD_VAR 0 9
53466: PPUSH
53467: LD_INT 1
53469: PPUSH
53470: CALL_OW 3
53474: ST_TO_ADDR
// end ;
53475: GO 53421
53477: POP
53478: POP
// end else
53479: GO 53501
// if sort then
53481: LD_VAR 0 9
53485: IFFALSE 53501
// p := sort [ 1 ] ;
53487: LD_ADDR_VAR 0 11
53491: PUSH
53492: LD_VAR 0 9
53496: PUSH
53497: LD_INT 1
53499: ARRAY
53500: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53501: LD_ADDR_VAR 0 2
53505: PUSH
53506: LD_INT 0
53508: PUSH
53509: LD_INT 0
53511: PUSH
53512: LD_INT 0
53514: PUSH
53515: LD_VAR 0 11
53519: PUSH
53520: EMPTY
53521: LIST
53522: LIST
53523: LIST
53524: LIST
53525: ST_TO_ADDR
// exit ;
53526: GO 55747
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53528: LD_EXP 70
53532: PUSH
53533: LD_EXP 69
53537: PUSH
53538: LD_VAR 0 1
53542: ARRAY
53543: ARRAY
53544: PUSH
53545: LD_EXP 43
53549: PUSH
53550: LD_VAR 0 1
53554: ARRAY
53555: PPUSH
53556: LD_INT 2
53558: PUSH
53559: LD_INT 30
53561: PUSH
53562: LD_INT 6
53564: PUSH
53565: EMPTY
53566: LIST
53567: LIST
53568: PUSH
53569: LD_INT 30
53571: PUSH
53572: LD_INT 7
53574: PUSH
53575: EMPTY
53576: LIST
53577: LIST
53578: PUSH
53579: LD_INT 30
53581: PUSH
53582: LD_INT 8
53584: PUSH
53585: EMPTY
53586: LIST
53587: LIST
53588: PUSH
53589: EMPTY
53590: LIST
53591: LIST
53592: LIST
53593: LIST
53594: PPUSH
53595: CALL_OW 72
53599: AND
53600: PUSH
53601: LD_EXP 43
53605: PUSH
53606: LD_VAR 0 1
53610: ARRAY
53611: PPUSH
53612: LD_INT 30
53614: PUSH
53615: LD_INT 3
53617: PUSH
53618: EMPTY
53619: LIST
53620: LIST
53621: PPUSH
53622: CALL_OW 72
53626: AND
53627: IFFALSE 54361
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53629: LD_ADDR_EXP 85
53633: PUSH
53634: LD_EXP 85
53638: PPUSH
53639: LD_VAR 0 1
53643: PPUSH
53644: LD_INT 3
53646: PPUSH
53647: CALL_OW 1
53651: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53652: LD_ADDR_VAR 0 2
53656: PUSH
53657: LD_INT 0
53659: PUSH
53660: LD_INT 0
53662: PUSH
53663: LD_INT 0
53665: PUSH
53666: LD_INT 0
53668: PUSH
53669: EMPTY
53670: LIST
53671: LIST
53672: LIST
53673: LIST
53674: ST_TO_ADDR
// if not eng then
53675: LD_VAR 0 6
53679: NOT
53680: IFFALSE 53743
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53682: LD_ADDR_VAR 0 11
53686: PUSH
53687: LD_VAR 0 4
53691: PPUSH
53692: LD_INT 2
53694: PPUSH
53695: CALL 44679 0 2
53699: PUSH
53700: LD_INT 1
53702: ARRAY
53703: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53704: LD_ADDR_VAR 0 2
53708: PUSH
53709: LD_VAR 0 2
53713: PPUSH
53714: LD_INT 2
53716: PPUSH
53717: LD_VAR 0 11
53721: PPUSH
53722: CALL_OW 1
53726: ST_TO_ADDR
// tmp := tmp diff p ;
53727: LD_ADDR_VAR 0 4
53731: PUSH
53732: LD_VAR 0 4
53736: PUSH
53737: LD_VAR 0 11
53741: DIFF
53742: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53743: LD_VAR 0 4
53747: PUSH
53748: LD_VAR 0 8
53752: PUSH
53753: LD_INT 6
53755: LESS
53756: AND
53757: IFFALSE 53945
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53759: LD_ADDR_VAR 0 9
53763: PUSH
53764: LD_VAR 0 4
53768: PUSH
53769: LD_VAR 0 8
53773: PUSH
53774: LD_VAR 0 7
53778: UNION
53779: DIFF
53780: PPUSH
53781: LD_INT 4
53783: PPUSH
53784: CALL 44679 0 2
53788: ST_TO_ADDR
// p := [ ] ;
53789: LD_ADDR_VAR 0 11
53793: PUSH
53794: EMPTY
53795: ST_TO_ADDR
// if sort then
53796: LD_VAR 0 9
53800: IFFALSE 53916
// for i = 1 to 6 - sci do
53802: LD_ADDR_VAR 0 3
53806: PUSH
53807: DOUBLE
53808: LD_INT 1
53810: DEC
53811: ST_TO_ADDR
53812: LD_INT 6
53814: PUSH
53815: LD_VAR 0 8
53819: MINUS
53820: PUSH
53821: FOR_TO
53822: IFFALSE 53914
// begin if i = sort then
53824: LD_VAR 0 3
53828: PUSH
53829: LD_VAR 0 9
53833: EQUAL
53834: IFFALSE 53838
// break ;
53836: GO 53914
// if GetClass ( i ) = 4 then
53838: LD_VAR 0 3
53842: PPUSH
53843: CALL_OW 257
53847: PUSH
53848: LD_INT 4
53850: EQUAL
53851: IFFALSE 53855
// continue ;
53853: GO 53821
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53855: LD_ADDR_VAR 0 11
53859: PUSH
53860: LD_VAR 0 11
53864: PPUSH
53865: LD_VAR 0 11
53869: PUSH
53870: LD_INT 1
53872: PLUS
53873: PPUSH
53874: LD_VAR 0 9
53878: PUSH
53879: LD_VAR 0 3
53883: ARRAY
53884: PPUSH
53885: CALL_OW 2
53889: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53890: LD_ADDR_VAR 0 4
53894: PUSH
53895: LD_VAR 0 4
53899: PUSH
53900: LD_VAR 0 9
53904: PUSH
53905: LD_VAR 0 3
53909: ARRAY
53910: DIFF
53911: ST_TO_ADDR
// end ;
53912: GO 53821
53914: POP
53915: POP
// if p then
53916: LD_VAR 0 11
53920: IFFALSE 53945
// result := Replace ( result , 4 , p ) ;
53922: LD_ADDR_VAR 0 2
53926: PUSH
53927: LD_VAR 0 2
53931: PPUSH
53932: LD_INT 4
53934: PPUSH
53935: LD_VAR 0 11
53939: PPUSH
53940: CALL_OW 1
53944: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53945: LD_VAR 0 4
53949: PUSH
53950: LD_VAR 0 7
53954: PUSH
53955: LD_INT 6
53957: LESS
53958: AND
53959: IFFALSE 54147
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53961: LD_ADDR_VAR 0 9
53965: PUSH
53966: LD_VAR 0 4
53970: PUSH
53971: LD_VAR 0 8
53975: PUSH
53976: LD_VAR 0 7
53980: UNION
53981: DIFF
53982: PPUSH
53983: LD_INT 3
53985: PPUSH
53986: CALL 44679 0 2
53990: ST_TO_ADDR
// p := [ ] ;
53991: LD_ADDR_VAR 0 11
53995: PUSH
53996: EMPTY
53997: ST_TO_ADDR
// if sort then
53998: LD_VAR 0 9
54002: IFFALSE 54118
// for i = 1 to 6 - mech do
54004: LD_ADDR_VAR 0 3
54008: PUSH
54009: DOUBLE
54010: LD_INT 1
54012: DEC
54013: ST_TO_ADDR
54014: LD_INT 6
54016: PUSH
54017: LD_VAR 0 7
54021: MINUS
54022: PUSH
54023: FOR_TO
54024: IFFALSE 54116
// begin if i = sort then
54026: LD_VAR 0 3
54030: PUSH
54031: LD_VAR 0 9
54035: EQUAL
54036: IFFALSE 54040
// break ;
54038: GO 54116
// if GetClass ( i ) = 3 then
54040: LD_VAR 0 3
54044: PPUSH
54045: CALL_OW 257
54049: PUSH
54050: LD_INT 3
54052: EQUAL
54053: IFFALSE 54057
// continue ;
54055: GO 54023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54057: LD_ADDR_VAR 0 11
54061: PUSH
54062: LD_VAR 0 11
54066: PPUSH
54067: LD_VAR 0 11
54071: PUSH
54072: LD_INT 1
54074: PLUS
54075: PPUSH
54076: LD_VAR 0 9
54080: PUSH
54081: LD_VAR 0 3
54085: ARRAY
54086: PPUSH
54087: CALL_OW 2
54091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54092: LD_ADDR_VAR 0 4
54096: PUSH
54097: LD_VAR 0 4
54101: PUSH
54102: LD_VAR 0 9
54106: PUSH
54107: LD_VAR 0 3
54111: ARRAY
54112: DIFF
54113: ST_TO_ADDR
// end ;
54114: GO 54023
54116: POP
54117: POP
// if p then
54118: LD_VAR 0 11
54122: IFFALSE 54147
// result := Replace ( result , 3 , p ) ;
54124: LD_ADDR_VAR 0 2
54128: PUSH
54129: LD_VAR 0 2
54133: PPUSH
54134: LD_INT 3
54136: PPUSH
54137: LD_VAR 0 11
54141: PPUSH
54142: CALL_OW 1
54146: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
54147: LD_VAR 0 4
54151: PUSH
54152: LD_INT 6
54154: GREATER
54155: PUSH
54156: LD_VAR 0 6
54160: PUSH
54161: LD_INT 6
54163: LESS
54164: AND
54165: IFFALSE 54359
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54167: LD_ADDR_VAR 0 9
54171: PUSH
54172: LD_VAR 0 4
54176: PUSH
54177: LD_VAR 0 8
54181: PUSH
54182: LD_VAR 0 7
54186: UNION
54187: PUSH
54188: LD_VAR 0 6
54192: UNION
54193: DIFF
54194: PPUSH
54195: LD_INT 2
54197: PPUSH
54198: CALL 44679 0 2
54202: ST_TO_ADDR
// p := [ ] ;
54203: LD_ADDR_VAR 0 11
54207: PUSH
54208: EMPTY
54209: ST_TO_ADDR
// if sort then
54210: LD_VAR 0 9
54214: IFFALSE 54330
// for i = 1 to 6 - eng do
54216: LD_ADDR_VAR 0 3
54220: PUSH
54221: DOUBLE
54222: LD_INT 1
54224: DEC
54225: ST_TO_ADDR
54226: LD_INT 6
54228: PUSH
54229: LD_VAR 0 6
54233: MINUS
54234: PUSH
54235: FOR_TO
54236: IFFALSE 54328
// begin if i = sort then
54238: LD_VAR 0 3
54242: PUSH
54243: LD_VAR 0 9
54247: EQUAL
54248: IFFALSE 54252
// break ;
54250: GO 54328
// if GetClass ( i ) = 2 then
54252: LD_VAR 0 3
54256: PPUSH
54257: CALL_OW 257
54261: PUSH
54262: LD_INT 2
54264: EQUAL
54265: IFFALSE 54269
// continue ;
54267: GO 54235
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54269: LD_ADDR_VAR 0 11
54273: PUSH
54274: LD_VAR 0 11
54278: PPUSH
54279: LD_VAR 0 11
54283: PUSH
54284: LD_INT 1
54286: PLUS
54287: PPUSH
54288: LD_VAR 0 9
54292: PUSH
54293: LD_VAR 0 3
54297: ARRAY
54298: PPUSH
54299: CALL_OW 2
54303: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54304: LD_ADDR_VAR 0 4
54308: PUSH
54309: LD_VAR 0 4
54313: PUSH
54314: LD_VAR 0 9
54318: PUSH
54319: LD_VAR 0 3
54323: ARRAY
54324: DIFF
54325: ST_TO_ADDR
// end ;
54326: GO 54235
54328: POP
54329: POP
// if p then
54330: LD_VAR 0 11
54334: IFFALSE 54359
// result := Replace ( result , 2 , p ) ;
54336: LD_ADDR_VAR 0 2
54340: PUSH
54341: LD_VAR 0 2
54345: PPUSH
54346: LD_INT 2
54348: PPUSH
54349: LD_VAR 0 11
54353: PPUSH
54354: CALL_OW 1
54358: ST_TO_ADDR
// end ; exit ;
54359: GO 55747
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
54361: LD_EXP 70
54365: PUSH
54366: LD_EXP 69
54370: PUSH
54371: LD_VAR 0 1
54375: ARRAY
54376: ARRAY
54377: NOT
54378: PUSH
54379: LD_EXP 43
54383: PUSH
54384: LD_VAR 0 1
54388: ARRAY
54389: PPUSH
54390: LD_INT 30
54392: PUSH
54393: LD_INT 3
54395: PUSH
54396: EMPTY
54397: LIST
54398: LIST
54399: PPUSH
54400: CALL_OW 72
54404: AND
54405: PUSH
54406: LD_EXP 48
54410: PUSH
54411: LD_VAR 0 1
54415: ARRAY
54416: AND
54417: IFFALSE 55025
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
54419: LD_ADDR_EXP 85
54423: PUSH
54424: LD_EXP 85
54428: PPUSH
54429: LD_VAR 0 1
54433: PPUSH
54434: LD_INT 5
54436: PPUSH
54437: CALL_OW 1
54441: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54442: LD_ADDR_VAR 0 2
54446: PUSH
54447: LD_INT 0
54449: PUSH
54450: LD_INT 0
54452: PUSH
54453: LD_INT 0
54455: PUSH
54456: LD_INT 0
54458: PUSH
54459: EMPTY
54460: LIST
54461: LIST
54462: LIST
54463: LIST
54464: ST_TO_ADDR
// if sci > 1 then
54465: LD_VAR 0 8
54469: PUSH
54470: LD_INT 1
54472: GREATER
54473: IFFALSE 54501
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54475: LD_ADDR_VAR 0 4
54479: PUSH
54480: LD_VAR 0 4
54484: PUSH
54485: LD_VAR 0 8
54489: PUSH
54490: LD_VAR 0 8
54494: PUSH
54495: LD_INT 1
54497: ARRAY
54498: DIFF
54499: DIFF
54500: ST_TO_ADDR
// if tmp and not sci then
54501: LD_VAR 0 4
54505: PUSH
54506: LD_VAR 0 8
54510: NOT
54511: AND
54512: IFFALSE 54581
// begin sort := SortBySkill ( tmp , 4 ) ;
54514: LD_ADDR_VAR 0 9
54518: PUSH
54519: LD_VAR 0 4
54523: PPUSH
54524: LD_INT 4
54526: PPUSH
54527: CALL 44679 0 2
54531: ST_TO_ADDR
// if sort then
54532: LD_VAR 0 9
54536: IFFALSE 54552
// p := sort [ 1 ] ;
54538: LD_ADDR_VAR 0 11
54542: PUSH
54543: LD_VAR 0 9
54547: PUSH
54548: LD_INT 1
54550: ARRAY
54551: ST_TO_ADDR
// if p then
54552: LD_VAR 0 11
54556: IFFALSE 54581
// result := Replace ( result , 4 , p ) ;
54558: LD_ADDR_VAR 0 2
54562: PUSH
54563: LD_VAR 0 2
54567: PPUSH
54568: LD_INT 4
54570: PPUSH
54571: LD_VAR 0 11
54575: PPUSH
54576: CALL_OW 1
54580: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54581: LD_ADDR_VAR 0 4
54585: PUSH
54586: LD_VAR 0 4
54590: PUSH
54591: LD_VAR 0 7
54595: DIFF
54596: ST_TO_ADDR
// if tmp and mech < 6 then
54597: LD_VAR 0 4
54601: PUSH
54602: LD_VAR 0 7
54606: PUSH
54607: LD_INT 6
54609: LESS
54610: AND
54611: IFFALSE 54799
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54613: LD_ADDR_VAR 0 9
54617: PUSH
54618: LD_VAR 0 4
54622: PUSH
54623: LD_VAR 0 8
54627: PUSH
54628: LD_VAR 0 7
54632: UNION
54633: DIFF
54634: PPUSH
54635: LD_INT 3
54637: PPUSH
54638: CALL 44679 0 2
54642: ST_TO_ADDR
// p := [ ] ;
54643: LD_ADDR_VAR 0 11
54647: PUSH
54648: EMPTY
54649: ST_TO_ADDR
// if sort then
54650: LD_VAR 0 9
54654: IFFALSE 54770
// for i = 1 to 6 - mech do
54656: LD_ADDR_VAR 0 3
54660: PUSH
54661: DOUBLE
54662: LD_INT 1
54664: DEC
54665: ST_TO_ADDR
54666: LD_INT 6
54668: PUSH
54669: LD_VAR 0 7
54673: MINUS
54674: PUSH
54675: FOR_TO
54676: IFFALSE 54768
// begin if i = sort then
54678: LD_VAR 0 3
54682: PUSH
54683: LD_VAR 0 9
54687: EQUAL
54688: IFFALSE 54692
// break ;
54690: GO 54768
// if GetClass ( i ) = 3 then
54692: LD_VAR 0 3
54696: PPUSH
54697: CALL_OW 257
54701: PUSH
54702: LD_INT 3
54704: EQUAL
54705: IFFALSE 54709
// continue ;
54707: GO 54675
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54709: LD_ADDR_VAR 0 11
54713: PUSH
54714: LD_VAR 0 11
54718: PPUSH
54719: LD_VAR 0 11
54723: PUSH
54724: LD_INT 1
54726: PLUS
54727: PPUSH
54728: LD_VAR 0 9
54732: PUSH
54733: LD_VAR 0 3
54737: ARRAY
54738: PPUSH
54739: CALL_OW 2
54743: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54744: LD_ADDR_VAR 0 4
54748: PUSH
54749: LD_VAR 0 4
54753: PUSH
54754: LD_VAR 0 9
54758: PUSH
54759: LD_VAR 0 3
54763: ARRAY
54764: DIFF
54765: ST_TO_ADDR
// end ;
54766: GO 54675
54768: POP
54769: POP
// if p then
54770: LD_VAR 0 11
54774: IFFALSE 54799
// result := Replace ( result , 3 , p ) ;
54776: LD_ADDR_VAR 0 2
54780: PUSH
54781: LD_VAR 0 2
54785: PPUSH
54786: LD_INT 3
54788: PPUSH
54789: LD_VAR 0 11
54793: PPUSH
54794: CALL_OW 1
54798: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54799: LD_ADDR_VAR 0 4
54803: PUSH
54804: LD_VAR 0 4
54808: PUSH
54809: LD_VAR 0 6
54813: DIFF
54814: ST_TO_ADDR
// if tmp and eng < 6 then
54815: LD_VAR 0 4
54819: PUSH
54820: LD_VAR 0 6
54824: PUSH
54825: LD_INT 6
54827: LESS
54828: AND
54829: IFFALSE 55023
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54831: LD_ADDR_VAR 0 9
54835: PUSH
54836: LD_VAR 0 4
54840: PUSH
54841: LD_VAR 0 8
54845: PUSH
54846: LD_VAR 0 7
54850: UNION
54851: PUSH
54852: LD_VAR 0 6
54856: UNION
54857: DIFF
54858: PPUSH
54859: LD_INT 2
54861: PPUSH
54862: CALL 44679 0 2
54866: ST_TO_ADDR
// p := [ ] ;
54867: LD_ADDR_VAR 0 11
54871: PUSH
54872: EMPTY
54873: ST_TO_ADDR
// if sort then
54874: LD_VAR 0 9
54878: IFFALSE 54994
// for i = 1 to 6 - eng do
54880: LD_ADDR_VAR 0 3
54884: PUSH
54885: DOUBLE
54886: LD_INT 1
54888: DEC
54889: ST_TO_ADDR
54890: LD_INT 6
54892: PUSH
54893: LD_VAR 0 6
54897: MINUS
54898: PUSH
54899: FOR_TO
54900: IFFALSE 54992
// begin if i = sort then
54902: LD_VAR 0 3
54906: PUSH
54907: LD_VAR 0 9
54911: EQUAL
54912: IFFALSE 54916
// break ;
54914: GO 54992
// if GetClass ( i ) = 2 then
54916: LD_VAR 0 3
54920: PPUSH
54921: CALL_OW 257
54925: PUSH
54926: LD_INT 2
54928: EQUAL
54929: IFFALSE 54933
// continue ;
54931: GO 54899
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54933: LD_ADDR_VAR 0 11
54937: PUSH
54938: LD_VAR 0 11
54942: PPUSH
54943: LD_VAR 0 11
54947: PUSH
54948: LD_INT 1
54950: PLUS
54951: PPUSH
54952: LD_VAR 0 9
54956: PUSH
54957: LD_VAR 0 3
54961: ARRAY
54962: PPUSH
54963: CALL_OW 2
54967: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54968: LD_ADDR_VAR 0 4
54972: PUSH
54973: LD_VAR 0 4
54977: PUSH
54978: LD_VAR 0 9
54982: PUSH
54983: LD_VAR 0 3
54987: ARRAY
54988: DIFF
54989: ST_TO_ADDR
// end ;
54990: GO 54899
54992: POP
54993: POP
// if p then
54994: LD_VAR 0 11
54998: IFFALSE 55023
// result := Replace ( result , 2 , p ) ;
55000: LD_ADDR_VAR 0 2
55004: PUSH
55005: LD_VAR 0 2
55009: PPUSH
55010: LD_INT 2
55012: PPUSH
55013: LD_VAR 0 11
55017: PPUSH
55018: CALL_OW 1
55022: ST_TO_ADDR
// end ; exit ;
55023: GO 55747
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
55025: LD_EXP 70
55029: PUSH
55030: LD_EXP 69
55034: PUSH
55035: LD_VAR 0 1
55039: ARRAY
55040: ARRAY
55041: NOT
55042: PUSH
55043: LD_EXP 43
55047: PUSH
55048: LD_VAR 0 1
55052: ARRAY
55053: PPUSH
55054: LD_INT 30
55056: PUSH
55057: LD_INT 3
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: PPUSH
55064: CALL_OW 72
55068: AND
55069: PUSH
55070: LD_EXP 48
55074: PUSH
55075: LD_VAR 0 1
55079: ARRAY
55080: NOT
55081: AND
55082: IFFALSE 55747
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
55084: LD_ADDR_EXP 85
55088: PUSH
55089: LD_EXP 85
55093: PPUSH
55094: LD_VAR 0 1
55098: PPUSH
55099: LD_INT 6
55101: PPUSH
55102: CALL_OW 1
55106: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55107: LD_ADDR_VAR 0 2
55111: PUSH
55112: LD_INT 0
55114: PUSH
55115: LD_INT 0
55117: PUSH
55118: LD_INT 0
55120: PUSH
55121: LD_INT 0
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: LIST
55128: LIST
55129: ST_TO_ADDR
// if sci >= 1 then
55130: LD_VAR 0 8
55134: PUSH
55135: LD_INT 1
55137: GREATEREQUAL
55138: IFFALSE 55160
// tmp := tmp diff sci [ 1 ] ;
55140: LD_ADDR_VAR 0 4
55144: PUSH
55145: LD_VAR 0 4
55149: PUSH
55150: LD_VAR 0 8
55154: PUSH
55155: LD_INT 1
55157: ARRAY
55158: DIFF
55159: ST_TO_ADDR
// if tmp and not sci then
55160: LD_VAR 0 4
55164: PUSH
55165: LD_VAR 0 8
55169: NOT
55170: AND
55171: IFFALSE 55240
// begin sort := SortBySkill ( tmp , 4 ) ;
55173: LD_ADDR_VAR 0 9
55177: PUSH
55178: LD_VAR 0 4
55182: PPUSH
55183: LD_INT 4
55185: PPUSH
55186: CALL 44679 0 2
55190: ST_TO_ADDR
// if sort then
55191: LD_VAR 0 9
55195: IFFALSE 55211
// p := sort [ 1 ] ;
55197: LD_ADDR_VAR 0 11
55201: PUSH
55202: LD_VAR 0 9
55206: PUSH
55207: LD_INT 1
55209: ARRAY
55210: ST_TO_ADDR
// if p then
55211: LD_VAR 0 11
55215: IFFALSE 55240
// result := Replace ( result , 4 , p ) ;
55217: LD_ADDR_VAR 0 2
55221: PUSH
55222: LD_VAR 0 2
55226: PPUSH
55227: LD_INT 4
55229: PPUSH
55230: LD_VAR 0 11
55234: PPUSH
55235: CALL_OW 1
55239: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
55240: LD_ADDR_VAR 0 4
55244: PUSH
55245: LD_VAR 0 4
55249: PUSH
55250: LD_VAR 0 7
55254: DIFF
55255: ST_TO_ADDR
// if tmp and mech < 6 then
55256: LD_VAR 0 4
55260: PUSH
55261: LD_VAR 0 7
55265: PUSH
55266: LD_INT 6
55268: LESS
55269: AND
55270: IFFALSE 55452
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
55272: LD_ADDR_VAR 0 9
55276: PUSH
55277: LD_VAR 0 4
55281: PUSH
55282: LD_VAR 0 7
55286: DIFF
55287: PPUSH
55288: LD_INT 3
55290: PPUSH
55291: CALL 44679 0 2
55295: ST_TO_ADDR
// p := [ ] ;
55296: LD_ADDR_VAR 0 11
55300: PUSH
55301: EMPTY
55302: ST_TO_ADDR
// if sort then
55303: LD_VAR 0 9
55307: IFFALSE 55423
// for i = 1 to 6 - mech do
55309: LD_ADDR_VAR 0 3
55313: PUSH
55314: DOUBLE
55315: LD_INT 1
55317: DEC
55318: ST_TO_ADDR
55319: LD_INT 6
55321: PUSH
55322: LD_VAR 0 7
55326: MINUS
55327: PUSH
55328: FOR_TO
55329: IFFALSE 55421
// begin if i = sort then
55331: LD_VAR 0 3
55335: PUSH
55336: LD_VAR 0 9
55340: EQUAL
55341: IFFALSE 55345
// break ;
55343: GO 55421
// if GetClass ( i ) = 3 then
55345: LD_VAR 0 3
55349: PPUSH
55350: CALL_OW 257
55354: PUSH
55355: LD_INT 3
55357: EQUAL
55358: IFFALSE 55362
// continue ;
55360: GO 55328
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55362: LD_ADDR_VAR 0 11
55366: PUSH
55367: LD_VAR 0 11
55371: PPUSH
55372: LD_VAR 0 11
55376: PUSH
55377: LD_INT 1
55379: PLUS
55380: PPUSH
55381: LD_VAR 0 9
55385: PUSH
55386: LD_VAR 0 3
55390: ARRAY
55391: PPUSH
55392: CALL_OW 2
55396: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55397: LD_ADDR_VAR 0 4
55401: PUSH
55402: LD_VAR 0 4
55406: PUSH
55407: LD_VAR 0 9
55411: PUSH
55412: LD_VAR 0 3
55416: ARRAY
55417: DIFF
55418: ST_TO_ADDR
// end ;
55419: GO 55328
55421: POP
55422: POP
// if p then
55423: LD_VAR 0 11
55427: IFFALSE 55452
// result := Replace ( result , 3 , p ) ;
55429: LD_ADDR_VAR 0 2
55433: PUSH
55434: LD_VAR 0 2
55438: PPUSH
55439: LD_INT 3
55441: PPUSH
55442: LD_VAR 0 11
55446: PPUSH
55447: CALL_OW 1
55451: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55452: LD_ADDR_VAR 0 4
55456: PUSH
55457: LD_VAR 0 4
55461: PUSH
55462: LD_VAR 0 6
55466: DIFF
55467: ST_TO_ADDR
// if tmp and eng < 4 then
55468: LD_VAR 0 4
55472: PUSH
55473: LD_VAR 0 6
55477: PUSH
55478: LD_INT 4
55480: LESS
55481: AND
55482: IFFALSE 55672
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55484: LD_ADDR_VAR 0 9
55488: PUSH
55489: LD_VAR 0 4
55493: PUSH
55494: LD_VAR 0 7
55498: PUSH
55499: LD_VAR 0 6
55503: UNION
55504: DIFF
55505: PPUSH
55506: LD_INT 2
55508: PPUSH
55509: CALL 44679 0 2
55513: ST_TO_ADDR
// p := [ ] ;
55514: LD_ADDR_VAR 0 11
55518: PUSH
55519: EMPTY
55520: ST_TO_ADDR
// if sort then
55521: LD_VAR 0 9
55525: IFFALSE 55641
// for i = 1 to 4 - eng do
55527: LD_ADDR_VAR 0 3
55531: PUSH
55532: DOUBLE
55533: LD_INT 1
55535: DEC
55536: ST_TO_ADDR
55537: LD_INT 4
55539: PUSH
55540: LD_VAR 0 6
55544: MINUS
55545: PUSH
55546: FOR_TO
55547: IFFALSE 55639
// begin if i = sort then
55549: LD_VAR 0 3
55553: PUSH
55554: LD_VAR 0 9
55558: EQUAL
55559: IFFALSE 55563
// break ;
55561: GO 55639
// if GetClass ( i ) = 2 then
55563: LD_VAR 0 3
55567: PPUSH
55568: CALL_OW 257
55572: PUSH
55573: LD_INT 2
55575: EQUAL
55576: IFFALSE 55580
// continue ;
55578: GO 55546
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55580: LD_ADDR_VAR 0 11
55584: PUSH
55585: LD_VAR 0 11
55589: PPUSH
55590: LD_VAR 0 11
55594: PUSH
55595: LD_INT 1
55597: PLUS
55598: PPUSH
55599: LD_VAR 0 9
55603: PUSH
55604: LD_VAR 0 3
55608: ARRAY
55609: PPUSH
55610: CALL_OW 2
55614: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55615: LD_ADDR_VAR 0 4
55619: PUSH
55620: LD_VAR 0 4
55624: PUSH
55625: LD_VAR 0 9
55629: PUSH
55630: LD_VAR 0 3
55634: ARRAY
55635: DIFF
55636: ST_TO_ADDR
// end ;
55637: GO 55546
55639: POP
55640: POP
// if p then
55641: LD_VAR 0 11
55645: IFFALSE 55670
// result := Replace ( result , 2 , p ) ;
55647: LD_ADDR_VAR 0 2
55651: PUSH
55652: LD_VAR 0 2
55656: PPUSH
55657: LD_INT 2
55659: PPUSH
55660: LD_VAR 0 11
55664: PPUSH
55665: CALL_OW 1
55669: ST_TO_ADDR
// end else
55670: GO 55716
// for i = eng downto 5 do
55672: LD_ADDR_VAR 0 3
55676: PUSH
55677: DOUBLE
55678: LD_VAR 0 6
55682: INC
55683: ST_TO_ADDR
55684: LD_INT 5
55686: PUSH
55687: FOR_DOWNTO
55688: IFFALSE 55714
// tmp := tmp union eng [ i ] ;
55690: LD_ADDR_VAR 0 4
55694: PUSH
55695: LD_VAR 0 4
55699: PUSH
55700: LD_VAR 0 6
55704: PUSH
55705: LD_VAR 0 3
55709: ARRAY
55710: UNION
55711: ST_TO_ADDR
55712: GO 55687
55714: POP
55715: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55716: LD_ADDR_VAR 0 2
55720: PUSH
55721: LD_VAR 0 2
55725: PPUSH
55726: LD_INT 1
55728: PPUSH
55729: LD_VAR 0 4
55733: PUSH
55734: LD_VAR 0 5
55738: DIFF
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// exit ;
55745: GO 55747
// end ; end ;
55747: LD_VAR 0 2
55751: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55752: LD_INT 0
55754: PPUSH
55755: PPUSH
55756: PPUSH
// if not mc_bases then
55757: LD_EXP 43
55761: NOT
55762: IFFALSE 55766
// exit ;
55764: GO 55872
// for i = 1 to mc_bases do
55766: LD_ADDR_VAR 0 2
55770: PUSH
55771: DOUBLE
55772: LD_INT 1
55774: DEC
55775: ST_TO_ADDR
55776: LD_EXP 43
55780: PUSH
55781: FOR_TO
55782: IFFALSE 55863
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55784: LD_ADDR_VAR 0 3
55788: PUSH
55789: LD_EXP 43
55793: PUSH
55794: LD_VAR 0 2
55798: ARRAY
55799: PPUSH
55800: LD_INT 21
55802: PUSH
55803: LD_INT 3
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: PUSH
55810: LD_INT 3
55812: PUSH
55813: LD_INT 24
55815: PUSH
55816: LD_INT 1000
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: PUSH
55827: EMPTY
55828: LIST
55829: LIST
55830: PPUSH
55831: CALL_OW 72
55835: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55836: LD_ADDR_EXP 44
55840: PUSH
55841: LD_EXP 44
55845: PPUSH
55846: LD_VAR 0 2
55850: PPUSH
55851: LD_VAR 0 3
55855: PPUSH
55856: CALL_OW 1
55860: ST_TO_ADDR
// end ;
55861: GO 55781
55863: POP
55864: POP
// RaiseSailEvent ( 101 ) ;
55865: LD_INT 101
55867: PPUSH
55868: CALL_OW 427
// end ;
55872: LD_VAR 0 1
55876: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55877: LD_INT 0
55879: PPUSH
55880: PPUSH
55881: PPUSH
55882: PPUSH
55883: PPUSH
55884: PPUSH
55885: PPUSH
// if not mc_bases then
55886: LD_EXP 43
55890: NOT
55891: IFFALSE 55895
// exit ;
55893: GO 56457
// for i = 1 to mc_bases do
55895: LD_ADDR_VAR 0 2
55899: PUSH
55900: DOUBLE
55901: LD_INT 1
55903: DEC
55904: ST_TO_ADDR
55905: LD_EXP 43
55909: PUSH
55910: FOR_TO
55911: IFFALSE 56448
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
55913: LD_ADDR_VAR 0 5
55917: PUSH
55918: LD_EXP 43
55922: PUSH
55923: LD_VAR 0 2
55927: ARRAY
55928: PUSH
55929: LD_EXP 72
55933: PUSH
55934: LD_VAR 0 2
55938: ARRAY
55939: UNION
55940: PPUSH
55941: LD_INT 21
55943: PUSH
55944: LD_INT 1
55946: PUSH
55947: EMPTY
55948: LIST
55949: LIST
55950: PUSH
55951: LD_INT 1
55953: PUSH
55954: LD_INT 3
55956: PUSH
55957: LD_INT 54
55959: PUSH
55960: EMPTY
55961: LIST
55962: PUSH
55963: EMPTY
55964: LIST
55965: LIST
55966: PUSH
55967: LD_INT 3
55969: PUSH
55970: LD_INT 24
55972: PUSH
55973: LD_INT 1000
55975: PUSH
55976: EMPTY
55977: LIST
55978: LIST
55979: PUSH
55980: EMPTY
55981: LIST
55982: LIST
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: LIST
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: PPUSH
55993: CALL_OW 72
55997: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55998: LD_ADDR_VAR 0 6
56002: PUSH
56003: LD_EXP 43
56007: PUSH
56008: LD_VAR 0 2
56012: ARRAY
56013: PPUSH
56014: LD_INT 21
56016: PUSH
56017: LD_INT 1
56019: PUSH
56020: EMPTY
56021: LIST
56022: LIST
56023: PUSH
56024: LD_INT 1
56026: PUSH
56027: LD_INT 3
56029: PUSH
56030: LD_INT 54
56032: PUSH
56033: EMPTY
56034: LIST
56035: PUSH
56036: EMPTY
56037: LIST
56038: LIST
56039: PUSH
56040: LD_INT 3
56042: PUSH
56043: LD_INT 24
56045: PUSH
56046: LD_INT 250
56048: PUSH
56049: EMPTY
56050: LIST
56051: LIST
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: LIST
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: PPUSH
56066: CALL_OW 72
56070: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
56071: LD_ADDR_VAR 0 7
56075: PUSH
56076: LD_VAR 0 5
56080: PUSH
56081: LD_VAR 0 6
56085: DIFF
56086: ST_TO_ADDR
// if not need_heal_1 then
56087: LD_VAR 0 6
56091: NOT
56092: IFFALSE 56125
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
56094: LD_ADDR_EXP 46
56098: PUSH
56099: LD_EXP 46
56103: PPUSH
56104: LD_VAR 0 2
56108: PUSH
56109: LD_INT 1
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: PPUSH
56116: EMPTY
56117: PPUSH
56118: CALL 14797 0 3
56122: ST_TO_ADDR
56123: GO 56195
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
56125: LD_ADDR_EXP 46
56129: PUSH
56130: LD_EXP 46
56134: PPUSH
56135: LD_VAR 0 2
56139: PUSH
56140: LD_INT 1
56142: PUSH
56143: EMPTY
56144: LIST
56145: LIST
56146: PPUSH
56147: LD_EXP 46
56151: PUSH
56152: LD_VAR 0 2
56156: ARRAY
56157: PUSH
56158: LD_INT 1
56160: ARRAY
56161: PPUSH
56162: LD_INT 3
56164: PUSH
56165: LD_INT 24
56167: PUSH
56168: LD_INT 1000
56170: PUSH
56171: EMPTY
56172: LIST
56173: LIST
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: PPUSH
56179: CALL_OW 72
56183: PUSH
56184: LD_VAR 0 6
56188: UNION
56189: PPUSH
56190: CALL 14797 0 3
56194: ST_TO_ADDR
// if not need_heal_2 then
56195: LD_VAR 0 7
56199: NOT
56200: IFFALSE 56233
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
56202: LD_ADDR_EXP 46
56206: PUSH
56207: LD_EXP 46
56211: PPUSH
56212: LD_VAR 0 2
56216: PUSH
56217: LD_INT 2
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: PPUSH
56224: EMPTY
56225: PPUSH
56226: CALL 14797 0 3
56230: ST_TO_ADDR
56231: GO 56265
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
56233: LD_ADDR_EXP 46
56237: PUSH
56238: LD_EXP 46
56242: PPUSH
56243: LD_VAR 0 2
56247: PUSH
56248: LD_INT 2
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: PPUSH
56255: LD_VAR 0 7
56259: PPUSH
56260: CALL 14797 0 3
56264: ST_TO_ADDR
// if need_heal_2 then
56265: LD_VAR 0 7
56269: IFFALSE 56430
// for j in need_heal_2 do
56271: LD_ADDR_VAR 0 3
56275: PUSH
56276: LD_VAR 0 7
56280: PUSH
56281: FOR_IN
56282: IFFALSE 56428
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56284: LD_ADDR_VAR 0 5
56288: PUSH
56289: LD_EXP 43
56293: PUSH
56294: LD_VAR 0 2
56298: ARRAY
56299: PPUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 30
56305: PUSH
56306: LD_INT 6
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 30
56315: PUSH
56316: LD_INT 7
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 30
56325: PUSH
56326: LD_INT 8
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 30
56335: PUSH
56336: LD_INT 0
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: PUSH
56343: LD_INT 30
56345: PUSH
56346: LD_INT 1
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: LIST
56357: LIST
56358: LIST
56359: LIST
56360: PPUSH
56361: CALL_OW 72
56365: ST_TO_ADDR
// if tmp then
56366: LD_VAR 0 5
56370: IFFALSE 56426
// begin k := NearestUnitToUnit ( tmp , j ) ;
56372: LD_ADDR_VAR 0 4
56376: PUSH
56377: LD_VAR 0 5
56381: PPUSH
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 74
56391: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
56392: LD_VAR 0 3
56396: PPUSH
56397: LD_VAR 0 4
56401: PPUSH
56402: CALL_OW 296
56406: PUSH
56407: LD_INT 5
56409: GREATER
56410: IFFALSE 56426
// ComMoveToNearbyEntrance ( j , k ) ;
56412: LD_VAR 0 3
56416: PPUSH
56417: LD_VAR 0 4
56421: PPUSH
56422: CALL 47040 0 2
// end ; end ;
56426: GO 56281
56428: POP
56429: POP
// if not need_heal_1 and not need_heal_2 then
56430: LD_VAR 0 6
56434: NOT
56435: PUSH
56436: LD_VAR 0 7
56440: NOT
56441: AND
56442: IFFALSE 56446
// continue ;
56444: GO 55910
// end ;
56446: GO 55910
56448: POP
56449: POP
// RaiseSailEvent ( 102 ) ;
56450: LD_INT 102
56452: PPUSH
56453: CALL_OW 427
// end ;
56457: LD_VAR 0 1
56461: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56462: LD_INT 0
56464: PPUSH
56465: PPUSH
56466: PPUSH
56467: PPUSH
56468: PPUSH
56469: PPUSH
56470: PPUSH
56471: PPUSH
// if not mc_bases then
56472: LD_EXP 43
56476: NOT
56477: IFFALSE 56481
// exit ;
56479: GO 57342
// for i = 1 to mc_bases do
56481: LD_ADDR_VAR 0 2
56485: PUSH
56486: DOUBLE
56487: LD_INT 1
56489: DEC
56490: ST_TO_ADDR
56491: LD_EXP 43
56495: PUSH
56496: FOR_TO
56497: IFFALSE 57340
// begin if not mc_building_need_repair [ i ] then
56499: LD_EXP 44
56503: PUSH
56504: LD_VAR 0 2
56508: ARRAY
56509: NOT
56510: IFFALSE 56697
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56512: LD_ADDR_VAR 0 6
56516: PUSH
56517: LD_EXP 62
56521: PUSH
56522: LD_VAR 0 2
56526: ARRAY
56527: PPUSH
56528: LD_INT 3
56530: PUSH
56531: LD_INT 24
56533: PUSH
56534: LD_INT 1000
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: PUSH
56545: LD_INT 2
56547: PUSH
56548: LD_INT 34
56550: PUSH
56551: LD_INT 13
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: PUSH
56558: LD_INT 34
56560: PUSH
56561: LD_INT 52
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: LD_INT 34
56570: PUSH
56571: LD_EXP 92
56575: PUSH
56576: EMPTY
56577: LIST
56578: LIST
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: LIST
56584: LIST
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: PPUSH
56590: CALL_OW 72
56594: ST_TO_ADDR
// if cranes then
56595: LD_VAR 0 6
56599: IFFALSE 56661
// for j in cranes do
56601: LD_ADDR_VAR 0 3
56605: PUSH
56606: LD_VAR 0 6
56610: PUSH
56611: FOR_IN
56612: IFFALSE 56659
// if not IsInArea ( j , mc_parking [ i ] ) then
56614: LD_VAR 0 3
56618: PPUSH
56619: LD_EXP 67
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PPUSH
56630: CALL_OW 308
56634: NOT
56635: IFFALSE 56657
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56637: LD_VAR 0 3
56641: PPUSH
56642: LD_EXP 67
56646: PUSH
56647: LD_VAR 0 2
56651: ARRAY
56652: PPUSH
56653: CALL_OW 113
56657: GO 56611
56659: POP
56660: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56661: LD_ADDR_EXP 45
56665: PUSH
56666: LD_EXP 45
56670: PPUSH
56671: LD_VAR 0 2
56675: PPUSH
56676: EMPTY
56677: PPUSH
56678: CALL_OW 1
56682: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56683: LD_VAR 0 2
56687: PPUSH
56688: LD_INT 101
56690: PPUSH
56691: CALL 51585 0 2
// continue ;
56695: GO 56496
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56697: LD_ADDR_EXP 49
56701: PUSH
56702: LD_EXP 49
56706: PPUSH
56707: LD_VAR 0 2
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56719: LD_VAR 0 2
56723: PPUSH
56724: LD_INT 103
56726: PPUSH
56727: CALL 51585 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56731: LD_ADDR_VAR 0 5
56735: PUSH
56736: LD_EXP 43
56740: PUSH
56741: LD_VAR 0 2
56745: ARRAY
56746: PUSH
56747: LD_EXP 72
56751: PUSH
56752: LD_VAR 0 2
56756: ARRAY
56757: UNION
56758: PPUSH
56759: LD_INT 2
56761: PUSH
56762: LD_INT 25
56764: PUSH
56765: LD_INT 2
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: LD_INT 25
56774: PUSH
56775: LD_INT 16
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: LIST
56786: PUSH
56787: EMPTY
56788: LIST
56789: PPUSH
56790: CALL_OW 72
56794: PUSH
56795: LD_EXP 46
56799: PUSH
56800: LD_VAR 0 2
56804: ARRAY
56805: PUSH
56806: LD_INT 1
56808: ARRAY
56809: PUSH
56810: LD_EXP 46
56814: PUSH
56815: LD_VAR 0 2
56819: ARRAY
56820: PUSH
56821: LD_INT 2
56823: ARRAY
56824: UNION
56825: DIFF
56826: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56827: LD_ADDR_VAR 0 6
56831: PUSH
56832: LD_EXP 62
56836: PUSH
56837: LD_VAR 0 2
56841: ARRAY
56842: PPUSH
56843: LD_INT 2
56845: PUSH
56846: LD_INT 34
56848: PUSH
56849: LD_INT 13
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PUSH
56856: LD_INT 34
56858: PUSH
56859: LD_INT 52
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PUSH
56866: LD_INT 34
56868: PUSH
56869: LD_EXP 92
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: LIST
56882: LIST
56883: PPUSH
56884: CALL_OW 72
56888: ST_TO_ADDR
// if cranes then
56889: LD_VAR 0 6
56893: IFFALSE 57029
// begin for j in cranes do
56895: LD_ADDR_VAR 0 3
56899: PUSH
56900: LD_VAR 0 6
56904: PUSH
56905: FOR_IN
56906: IFFALSE 57027
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56908: LD_VAR 0 3
56912: PPUSH
56913: CALL_OW 256
56917: PUSH
56918: LD_INT 1000
56920: EQUAL
56921: PUSH
56922: LD_VAR 0 3
56926: PPUSH
56927: CALL_OW 314
56931: NOT
56932: AND
56933: IFFALSE 56967
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56935: LD_VAR 0 3
56939: PPUSH
56940: LD_EXP 44
56944: PUSH
56945: LD_VAR 0 2
56949: ARRAY
56950: PPUSH
56951: LD_VAR 0 3
56955: PPUSH
56956: CALL_OW 74
56960: PPUSH
56961: CALL_OW 130
56965: GO 57025
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56967: LD_VAR 0 3
56971: PPUSH
56972: CALL_OW 256
56976: PUSH
56977: LD_INT 500
56979: LESS
56980: PUSH
56981: LD_VAR 0 3
56985: PPUSH
56986: LD_EXP 67
56990: PUSH
56991: LD_VAR 0 2
56995: ARRAY
56996: PPUSH
56997: CALL_OW 308
57001: NOT
57002: AND
57003: IFFALSE 57025
// ComMoveToArea ( j , mc_parking [ i ] ) ;
57005: LD_VAR 0 3
57009: PPUSH
57010: LD_EXP 67
57014: PUSH
57015: LD_VAR 0 2
57019: ARRAY
57020: PPUSH
57021: CALL_OW 113
// end ;
57025: GO 56905
57027: POP
57028: POP
// end ; if tmp > 3 then
57029: LD_VAR 0 5
57033: PUSH
57034: LD_INT 3
57036: GREATER
57037: IFFALSE 57057
// tmp := ShrinkArray ( tmp , 4 ) ;
57039: LD_ADDR_VAR 0 5
57043: PUSH
57044: LD_VAR 0 5
57048: PPUSH
57049: LD_INT 4
57051: PPUSH
57052: CALL 46488 0 2
57056: ST_TO_ADDR
// if not tmp then
57057: LD_VAR 0 5
57061: NOT
57062: IFFALSE 57066
// continue ;
57064: GO 56496
// for j in tmp do
57066: LD_ADDR_VAR 0 3
57070: PUSH
57071: LD_VAR 0 5
57075: PUSH
57076: FOR_IN
57077: IFFALSE 57336
// begin if IsInUnit ( j ) then
57079: LD_VAR 0 3
57083: PPUSH
57084: CALL_OW 310
57088: IFFALSE 57099
// ComExitBuilding ( j ) ;
57090: LD_VAR 0 3
57094: PPUSH
57095: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
57099: LD_VAR 0 3
57103: PUSH
57104: LD_EXP 45
57108: PUSH
57109: LD_VAR 0 2
57113: ARRAY
57114: IN
57115: NOT
57116: IFFALSE 57174
// begin SetTag ( j , 101 ) ;
57118: LD_VAR 0 3
57122: PPUSH
57123: LD_INT 101
57125: PPUSH
57126: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
57130: LD_ADDR_EXP 45
57134: PUSH
57135: LD_EXP 45
57139: PPUSH
57140: LD_VAR 0 2
57144: PUSH
57145: LD_EXP 45
57149: PUSH
57150: LD_VAR 0 2
57154: ARRAY
57155: PUSH
57156: LD_INT 1
57158: PLUS
57159: PUSH
57160: EMPTY
57161: LIST
57162: LIST
57163: PPUSH
57164: LD_VAR 0 3
57168: PPUSH
57169: CALL 14797 0 3
57173: ST_TO_ADDR
// end ; wait ( 1 ) ;
57174: LD_INT 1
57176: PPUSH
57177: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
57181: LD_ADDR_VAR 0 7
57185: PUSH
57186: LD_EXP 44
57190: PUSH
57191: LD_VAR 0 2
57195: ARRAY
57196: ST_TO_ADDR
// if mc_scan [ i ] then
57197: LD_EXP 66
57201: PUSH
57202: LD_VAR 0 2
57206: ARRAY
57207: IFFALSE 57269
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
57209: LD_ADDR_VAR 0 7
57213: PUSH
57214: LD_EXP 44
57218: PUSH
57219: LD_VAR 0 2
57223: ARRAY
57224: PPUSH
57225: LD_INT 3
57227: PUSH
57228: LD_INT 30
57230: PUSH
57231: LD_INT 32
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 30
57240: PUSH
57241: LD_INT 33
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: PUSH
57248: LD_INT 30
57250: PUSH
57251: LD_INT 31
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: LIST
57262: LIST
57263: PPUSH
57264: CALL_OW 72
57268: ST_TO_ADDR
// if not to_repair_tmp then
57269: LD_VAR 0 7
57273: NOT
57274: IFFALSE 57278
// continue ;
57276: GO 57076
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
57278: LD_ADDR_VAR 0 8
57282: PUSH
57283: LD_VAR 0 7
57287: PPUSH
57288: LD_VAR 0 3
57292: PPUSH
57293: CALL_OW 74
57297: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
57298: LD_VAR 0 8
57302: PPUSH
57303: LD_INT 16
57305: PPUSH
57306: CALL 17390 0 2
57310: PUSH
57311: LD_INT 4
57313: ARRAY
57314: PUSH
57315: LD_INT 10
57317: LESS
57318: IFFALSE 57334
// ComRepairBuilding ( j , to_repair ) ;
57320: LD_VAR 0 3
57324: PPUSH
57325: LD_VAR 0 8
57329: PPUSH
57330: CALL_OW 130
// end ;
57334: GO 57076
57336: POP
57337: POP
// end ;
57338: GO 56496
57340: POP
57341: POP
// end ;
57342: LD_VAR 0 1
57346: RET
// export function MC_Heal ; var i , j , tmp ; begin
57347: LD_INT 0
57349: PPUSH
57350: PPUSH
57351: PPUSH
57352: PPUSH
// if not mc_bases then
57353: LD_EXP 43
57357: NOT
57358: IFFALSE 57362
// exit ;
57360: GO 57764
// for i = 1 to mc_bases do
57362: LD_ADDR_VAR 0 2
57366: PUSH
57367: DOUBLE
57368: LD_INT 1
57370: DEC
57371: ST_TO_ADDR
57372: LD_EXP 43
57376: PUSH
57377: FOR_TO
57378: IFFALSE 57762
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
57380: LD_EXP 46
57384: PUSH
57385: LD_VAR 0 2
57389: ARRAY
57390: PUSH
57391: LD_INT 1
57393: ARRAY
57394: NOT
57395: PUSH
57396: LD_EXP 46
57400: PUSH
57401: LD_VAR 0 2
57405: ARRAY
57406: PUSH
57407: LD_INT 2
57409: ARRAY
57410: NOT
57411: AND
57412: IFFALSE 57450
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
57414: LD_ADDR_EXP 47
57418: PUSH
57419: LD_EXP 47
57423: PPUSH
57424: LD_VAR 0 2
57428: PPUSH
57429: EMPTY
57430: PPUSH
57431: CALL_OW 1
57435: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
57436: LD_VAR 0 2
57440: PPUSH
57441: LD_INT 102
57443: PPUSH
57444: CALL 51585 0 2
// continue ;
57448: GO 57377
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57450: LD_ADDR_VAR 0 4
57454: PUSH
57455: LD_EXP 43
57459: PUSH
57460: LD_VAR 0 2
57464: ARRAY
57465: PPUSH
57466: LD_INT 25
57468: PUSH
57469: LD_INT 4
57471: PUSH
57472: EMPTY
57473: LIST
57474: LIST
57475: PPUSH
57476: CALL_OW 72
57480: ST_TO_ADDR
// if not tmp then
57481: LD_VAR 0 4
57485: NOT
57486: IFFALSE 57490
// continue ;
57488: GO 57377
// if mc_taming [ i ] then
57490: LD_EXP 74
57494: PUSH
57495: LD_VAR 0 2
57499: ARRAY
57500: IFFALSE 57524
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57502: LD_ADDR_EXP 74
57506: PUSH
57507: LD_EXP 74
57511: PPUSH
57512: LD_VAR 0 2
57516: PPUSH
57517: EMPTY
57518: PPUSH
57519: CALL_OW 1
57523: ST_TO_ADDR
// for j in tmp do
57524: LD_ADDR_VAR 0 3
57528: PUSH
57529: LD_VAR 0 4
57533: PUSH
57534: FOR_IN
57535: IFFALSE 57758
// begin if IsInUnit ( j ) then
57537: LD_VAR 0 3
57541: PPUSH
57542: CALL_OW 310
57546: IFFALSE 57557
// ComExitBuilding ( j ) ;
57548: LD_VAR 0 3
57552: PPUSH
57553: CALL_OW 122
// if not j in mc_healers [ i ] then
57557: LD_VAR 0 3
57561: PUSH
57562: LD_EXP 47
57566: PUSH
57567: LD_VAR 0 2
57571: ARRAY
57572: IN
57573: NOT
57574: IFFALSE 57620
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57576: LD_ADDR_EXP 47
57580: PUSH
57581: LD_EXP 47
57585: PPUSH
57586: LD_VAR 0 2
57590: PUSH
57591: LD_EXP 47
57595: PUSH
57596: LD_VAR 0 2
57600: ARRAY
57601: PUSH
57602: LD_INT 1
57604: PLUS
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: PPUSH
57610: LD_VAR 0 3
57614: PPUSH
57615: CALL 14797 0 3
57619: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57620: LD_VAR 0 3
57624: PPUSH
57625: CALL_OW 110
57629: PUSH
57630: LD_INT 102
57632: NONEQUAL
57633: IFFALSE 57647
// SetTag ( j , 102 ) ;
57635: LD_VAR 0 3
57639: PPUSH
57640: LD_INT 102
57642: PPUSH
57643: CALL_OW 109
// Wait ( 3 ) ;
57647: LD_INT 3
57649: PPUSH
57650: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57654: LD_EXP 46
57658: PUSH
57659: LD_VAR 0 2
57663: ARRAY
57664: PUSH
57665: LD_INT 1
57667: ARRAY
57668: IFFALSE 57700
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57670: LD_VAR 0 3
57674: PPUSH
57675: LD_EXP 46
57679: PUSH
57680: LD_VAR 0 2
57684: ARRAY
57685: PUSH
57686: LD_INT 1
57688: ARRAY
57689: PUSH
57690: LD_INT 1
57692: ARRAY
57693: PPUSH
57694: CALL_OW 128
57698: GO 57756
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57700: LD_VAR 0 3
57704: PPUSH
57705: CALL_OW 314
57709: NOT
57710: PUSH
57711: LD_EXP 46
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_INT 2
57724: ARRAY
57725: AND
57726: IFFALSE 57756
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57728: LD_VAR 0 3
57732: PPUSH
57733: LD_EXP 46
57737: PUSH
57738: LD_VAR 0 2
57742: ARRAY
57743: PUSH
57744: LD_INT 2
57746: ARRAY
57747: PUSH
57748: LD_INT 1
57750: ARRAY
57751: PPUSH
57752: CALL_OW 128
// end ;
57756: GO 57534
57758: POP
57759: POP
// end ;
57760: GO 57377
57762: POP
57763: POP
// end ;
57764: LD_VAR 0 1
57768: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57769: LD_INT 0
57771: PPUSH
57772: PPUSH
57773: PPUSH
57774: PPUSH
57775: PPUSH
// if not mc_bases then
57776: LD_EXP 43
57780: NOT
57781: IFFALSE 57785
// exit ;
57783: GO 58956
// for i = 1 to mc_bases do
57785: LD_ADDR_VAR 0 2
57789: PUSH
57790: DOUBLE
57791: LD_INT 1
57793: DEC
57794: ST_TO_ADDR
57795: LD_EXP 43
57799: PUSH
57800: FOR_TO
57801: IFFALSE 58954
// begin if mc_scan [ i ] then
57803: LD_EXP 66
57807: PUSH
57808: LD_VAR 0 2
57812: ARRAY
57813: IFFALSE 57817
// continue ;
57815: GO 57800
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57817: LD_EXP 48
57821: PUSH
57822: LD_VAR 0 2
57826: ARRAY
57827: NOT
57828: PUSH
57829: LD_EXP 50
57833: PUSH
57834: LD_VAR 0 2
57838: ARRAY
57839: NOT
57840: AND
57841: PUSH
57842: LD_EXP 49
57846: PUSH
57847: LD_VAR 0 2
57851: ARRAY
57852: AND
57853: IFFALSE 57891
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57855: LD_ADDR_EXP 49
57859: PUSH
57860: LD_EXP 49
57864: PPUSH
57865: LD_VAR 0 2
57869: PPUSH
57870: EMPTY
57871: PPUSH
57872: CALL_OW 1
57876: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57877: LD_VAR 0 2
57881: PPUSH
57882: LD_INT 103
57884: PPUSH
57885: CALL 51585 0 2
// continue ;
57889: GO 57800
// end ; if mc_construct_list [ i ] then
57891: LD_EXP 50
57895: PUSH
57896: LD_VAR 0 2
57900: ARRAY
57901: IFFALSE 58121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57903: LD_ADDR_VAR 0 4
57907: PUSH
57908: LD_EXP 43
57912: PUSH
57913: LD_VAR 0 2
57917: ARRAY
57918: PPUSH
57919: LD_INT 25
57921: PUSH
57922: LD_INT 2
57924: PUSH
57925: EMPTY
57926: LIST
57927: LIST
57928: PPUSH
57929: CALL_OW 72
57933: PUSH
57934: LD_EXP 45
57938: PUSH
57939: LD_VAR 0 2
57943: ARRAY
57944: DIFF
57945: ST_TO_ADDR
// if not tmp then
57946: LD_VAR 0 4
57950: NOT
57951: IFFALSE 57955
// continue ;
57953: GO 57800
// for j in tmp do
57955: LD_ADDR_VAR 0 3
57959: PUSH
57960: LD_VAR 0 4
57964: PUSH
57965: FOR_IN
57966: IFFALSE 58117
// begin if not mc_builders [ i ] then
57968: LD_EXP 49
57972: PUSH
57973: LD_VAR 0 2
57977: ARRAY
57978: NOT
57979: IFFALSE 58037
// begin SetTag ( j , 103 ) ;
57981: LD_VAR 0 3
57985: PPUSH
57986: LD_INT 103
57988: PPUSH
57989: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57993: LD_ADDR_EXP 49
57997: PUSH
57998: LD_EXP 49
58002: PPUSH
58003: LD_VAR 0 2
58007: PUSH
58008: LD_EXP 49
58012: PUSH
58013: LD_VAR 0 2
58017: ARRAY
58018: PUSH
58019: LD_INT 1
58021: PLUS
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: PPUSH
58027: LD_VAR 0 3
58031: PPUSH
58032: CALL 14797 0 3
58036: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58037: LD_VAR 0 3
58041: PPUSH
58042: CALL_OW 310
58046: IFFALSE 58057
// ComExitBuilding ( j ) ;
58048: LD_VAR 0 3
58052: PPUSH
58053: CALL_OW 122
// wait ( 3 ) ;
58057: LD_INT 3
58059: PPUSH
58060: CALL_OW 67
// if not mc_construct_list [ i ] then
58064: LD_EXP 50
58068: PUSH
58069: LD_VAR 0 2
58073: ARRAY
58074: NOT
58075: IFFALSE 58079
// break ;
58077: GO 58117
// if not HasTask ( j ) then
58079: LD_VAR 0 3
58083: PPUSH
58084: CALL_OW 314
58088: NOT
58089: IFFALSE 58115
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
58091: LD_VAR 0 3
58095: PPUSH
58096: LD_EXP 50
58100: PUSH
58101: LD_VAR 0 2
58105: ARRAY
58106: PUSH
58107: LD_INT 1
58109: ARRAY
58110: PPUSH
58111: CALL 17654 0 2
// end ;
58115: GO 57965
58117: POP
58118: POP
// end else
58119: GO 58952
// if mc_build_list [ i ] then
58121: LD_EXP 48
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: IFFALSE 58952
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58133: LD_ADDR_VAR 0 5
58137: PUSH
58138: LD_EXP 43
58142: PUSH
58143: LD_VAR 0 2
58147: ARRAY
58148: PPUSH
58149: LD_INT 2
58151: PUSH
58152: LD_INT 30
58154: PUSH
58155: LD_INT 0
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: PUSH
58162: LD_INT 30
58164: PUSH
58165: LD_INT 1
58167: PUSH
58168: EMPTY
58169: LIST
58170: LIST
58171: PUSH
58172: EMPTY
58173: LIST
58174: LIST
58175: LIST
58176: PPUSH
58177: CALL_OW 72
58181: ST_TO_ADDR
// if depot then
58182: LD_VAR 0 5
58186: IFFALSE 58204
// depot := depot [ 1 ] else
58188: LD_ADDR_VAR 0 5
58192: PUSH
58193: LD_VAR 0 5
58197: PUSH
58198: LD_INT 1
58200: ARRAY
58201: ST_TO_ADDR
58202: GO 58212
// depot := 0 ;
58204: LD_ADDR_VAR 0 5
58208: PUSH
58209: LD_INT 0
58211: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
58212: LD_EXP 48
58216: PUSH
58217: LD_VAR 0 2
58221: ARRAY
58222: PUSH
58223: LD_INT 1
58225: ARRAY
58226: PUSH
58227: LD_INT 1
58229: ARRAY
58230: PPUSH
58231: CALL 17478 0 1
58235: PUSH
58236: LD_EXP 43
58240: PUSH
58241: LD_VAR 0 2
58245: ARRAY
58246: PPUSH
58247: LD_INT 2
58249: PUSH
58250: LD_INT 30
58252: PUSH
58253: LD_INT 2
58255: PUSH
58256: EMPTY
58257: LIST
58258: LIST
58259: PUSH
58260: LD_INT 30
58262: PUSH
58263: LD_INT 3
58265: PUSH
58266: EMPTY
58267: LIST
58268: LIST
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: LIST
58274: PPUSH
58275: CALL_OW 72
58279: NOT
58280: AND
58281: IFFALSE 58386
// begin for j = 1 to mc_build_list [ i ] do
58283: LD_ADDR_VAR 0 3
58287: PUSH
58288: DOUBLE
58289: LD_INT 1
58291: DEC
58292: ST_TO_ADDR
58293: LD_EXP 48
58297: PUSH
58298: LD_VAR 0 2
58302: ARRAY
58303: PUSH
58304: FOR_TO
58305: IFFALSE 58384
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
58307: LD_EXP 48
58311: PUSH
58312: LD_VAR 0 2
58316: ARRAY
58317: PUSH
58318: LD_VAR 0 3
58322: ARRAY
58323: PUSH
58324: LD_INT 1
58326: ARRAY
58327: PUSH
58328: LD_INT 2
58330: EQUAL
58331: IFFALSE 58382
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
58333: LD_ADDR_EXP 48
58337: PUSH
58338: LD_EXP 48
58342: PPUSH
58343: LD_VAR 0 2
58347: PPUSH
58348: LD_EXP 48
58352: PUSH
58353: LD_VAR 0 2
58357: ARRAY
58358: PPUSH
58359: LD_VAR 0 3
58363: PPUSH
58364: LD_INT 1
58366: PPUSH
58367: LD_INT 0
58369: PPUSH
58370: CALL 14215 0 4
58374: PPUSH
58375: CALL_OW 1
58379: ST_TO_ADDR
// break ;
58380: GO 58384
// end ;
58382: GO 58304
58384: POP
58385: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
58386: LD_EXP 48
58390: PUSH
58391: LD_VAR 0 2
58395: ARRAY
58396: PUSH
58397: LD_INT 1
58399: ARRAY
58400: PUSH
58401: LD_INT 1
58403: ARRAY
58404: PUSH
58405: LD_INT 0
58407: EQUAL
58408: PUSH
58409: LD_VAR 0 5
58413: PUSH
58414: LD_VAR 0 5
58418: PPUSH
58419: LD_EXP 48
58423: PUSH
58424: LD_VAR 0 2
58428: ARRAY
58429: PUSH
58430: LD_INT 1
58432: ARRAY
58433: PUSH
58434: LD_INT 1
58436: ARRAY
58437: PPUSH
58438: LD_EXP 48
58442: PUSH
58443: LD_VAR 0 2
58447: ARRAY
58448: PUSH
58449: LD_INT 1
58451: ARRAY
58452: PUSH
58453: LD_INT 2
58455: ARRAY
58456: PPUSH
58457: LD_EXP 48
58461: PUSH
58462: LD_VAR 0 2
58466: ARRAY
58467: PUSH
58468: LD_INT 1
58470: ARRAY
58471: PUSH
58472: LD_INT 3
58474: ARRAY
58475: PPUSH
58476: LD_EXP 48
58480: PUSH
58481: LD_VAR 0 2
58485: ARRAY
58486: PUSH
58487: LD_INT 1
58489: ARRAY
58490: PUSH
58491: LD_INT 4
58493: ARRAY
58494: PPUSH
58495: CALL 22545 0 5
58499: AND
58500: OR
58501: IFFALSE 58782
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58503: LD_ADDR_VAR 0 4
58507: PUSH
58508: LD_EXP 43
58512: PUSH
58513: LD_VAR 0 2
58517: ARRAY
58518: PPUSH
58519: LD_INT 25
58521: PUSH
58522: LD_INT 2
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: PPUSH
58529: CALL_OW 72
58533: PUSH
58534: LD_EXP 45
58538: PUSH
58539: LD_VAR 0 2
58543: ARRAY
58544: DIFF
58545: ST_TO_ADDR
// if not tmp then
58546: LD_VAR 0 4
58550: NOT
58551: IFFALSE 58555
// continue ;
58553: GO 57800
// for j in tmp do
58555: LD_ADDR_VAR 0 3
58559: PUSH
58560: LD_VAR 0 4
58564: PUSH
58565: FOR_IN
58566: IFFALSE 58778
// begin if not mc_builders [ i ] then
58568: LD_EXP 49
58572: PUSH
58573: LD_VAR 0 2
58577: ARRAY
58578: NOT
58579: IFFALSE 58637
// begin SetTag ( j , 103 ) ;
58581: LD_VAR 0 3
58585: PPUSH
58586: LD_INT 103
58588: PPUSH
58589: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58593: LD_ADDR_EXP 49
58597: PUSH
58598: LD_EXP 49
58602: PPUSH
58603: LD_VAR 0 2
58607: PUSH
58608: LD_EXP 49
58612: PUSH
58613: LD_VAR 0 2
58617: ARRAY
58618: PUSH
58619: LD_INT 1
58621: PLUS
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: PPUSH
58627: LD_VAR 0 3
58631: PPUSH
58632: CALL 14797 0 3
58636: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58637: LD_VAR 0 3
58641: PPUSH
58642: CALL_OW 310
58646: IFFALSE 58657
// ComExitBuilding ( j ) ;
58648: LD_VAR 0 3
58652: PPUSH
58653: CALL_OW 122
// wait ( 3 ) ;
58657: LD_INT 3
58659: PPUSH
58660: CALL_OW 67
// if not mc_build_list [ i ] then
58664: LD_EXP 48
58668: PUSH
58669: LD_VAR 0 2
58673: ARRAY
58674: NOT
58675: IFFALSE 58679
// break ;
58677: GO 58778
// if not HasTask ( j ) then
58679: LD_VAR 0 3
58683: PPUSH
58684: CALL_OW 314
58688: NOT
58689: IFFALSE 58776
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58691: LD_VAR 0 3
58695: PPUSH
58696: LD_EXP 48
58700: PUSH
58701: LD_VAR 0 2
58705: ARRAY
58706: PUSH
58707: LD_INT 1
58709: ARRAY
58710: PUSH
58711: LD_INT 1
58713: ARRAY
58714: PPUSH
58715: LD_EXP 48
58719: PUSH
58720: LD_VAR 0 2
58724: ARRAY
58725: PUSH
58726: LD_INT 1
58728: ARRAY
58729: PUSH
58730: LD_INT 2
58732: ARRAY
58733: PPUSH
58734: LD_EXP 48
58738: PUSH
58739: LD_VAR 0 2
58743: ARRAY
58744: PUSH
58745: LD_INT 1
58747: ARRAY
58748: PUSH
58749: LD_INT 3
58751: ARRAY
58752: PPUSH
58753: LD_EXP 48
58757: PUSH
58758: LD_VAR 0 2
58762: ARRAY
58763: PUSH
58764: LD_INT 1
58766: ARRAY
58767: PUSH
58768: LD_INT 4
58770: ARRAY
58771: PPUSH
58772: CALL_OW 145
// end ;
58776: GO 58565
58778: POP
58779: POP
// end else
58780: GO 58952
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
58782: LD_EXP 43
58786: PUSH
58787: LD_VAR 0 2
58791: ARRAY
58792: PPUSH
58793: LD_EXP 48
58797: PUSH
58798: LD_VAR 0 2
58802: ARRAY
58803: PUSH
58804: LD_INT 1
58806: ARRAY
58807: PUSH
58808: LD_INT 1
58810: ARRAY
58811: PPUSH
58812: LD_EXP 48
58816: PUSH
58817: LD_VAR 0 2
58821: ARRAY
58822: PUSH
58823: LD_INT 1
58825: ARRAY
58826: PUSH
58827: LD_INT 2
58829: ARRAY
58830: PPUSH
58831: LD_EXP 48
58835: PUSH
58836: LD_VAR 0 2
58840: ARRAY
58841: PUSH
58842: LD_INT 1
58844: ARRAY
58845: PUSH
58846: LD_INT 3
58848: ARRAY
58849: PPUSH
58850: LD_EXP 48
58854: PUSH
58855: LD_VAR 0 2
58859: ARRAY
58860: PUSH
58861: LD_INT 1
58863: ARRAY
58864: PUSH
58865: LD_INT 4
58867: ARRAY
58868: PPUSH
58869: LD_EXP 43
58873: PUSH
58874: LD_VAR 0 2
58878: ARRAY
58879: PPUSH
58880: LD_INT 21
58882: PUSH
58883: LD_INT 3
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: PPUSH
58890: CALL_OW 72
58894: PPUSH
58895: EMPTY
58896: PPUSH
58897: CALL 21675 0 7
58901: NOT
58902: IFFALSE 58952
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58904: LD_ADDR_EXP 48
58908: PUSH
58909: LD_EXP 48
58913: PPUSH
58914: LD_VAR 0 2
58918: PPUSH
58919: LD_EXP 48
58923: PUSH
58924: LD_VAR 0 2
58928: ARRAY
58929: PPUSH
58930: LD_INT 1
58932: PPUSH
58933: LD_INT 1
58935: NEG
58936: PPUSH
58937: LD_INT 0
58939: PPUSH
58940: CALL 14215 0 4
58944: PPUSH
58945: CALL_OW 1
58949: ST_TO_ADDR
// continue ;
58950: GO 57800
// end ; end ; end ;
58952: GO 57800
58954: POP
58955: POP
// end ;
58956: LD_VAR 0 1
58960: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58961: LD_INT 0
58963: PPUSH
58964: PPUSH
58965: PPUSH
58966: PPUSH
58967: PPUSH
58968: PPUSH
// if not mc_bases then
58969: LD_EXP 43
58973: NOT
58974: IFFALSE 58978
// exit ;
58976: GO 59405
// for i = 1 to mc_bases do
58978: LD_ADDR_VAR 0 2
58982: PUSH
58983: DOUBLE
58984: LD_INT 1
58986: DEC
58987: ST_TO_ADDR
58988: LD_EXP 43
58992: PUSH
58993: FOR_TO
58994: IFFALSE 59403
// begin tmp := mc_build_upgrade [ i ] ;
58996: LD_ADDR_VAR 0 4
59000: PUSH
59001: LD_EXP 75
59005: PUSH
59006: LD_VAR 0 2
59010: ARRAY
59011: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
59012: LD_ADDR_VAR 0 6
59016: PUSH
59017: LD_EXP 76
59021: PUSH
59022: LD_VAR 0 2
59026: ARRAY
59027: PPUSH
59028: LD_INT 2
59030: PUSH
59031: LD_INT 30
59033: PUSH
59034: LD_INT 6
59036: PUSH
59037: EMPTY
59038: LIST
59039: LIST
59040: PUSH
59041: LD_INT 30
59043: PUSH
59044: LD_INT 7
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: EMPTY
59052: LIST
59053: LIST
59054: LIST
59055: PPUSH
59056: CALL_OW 72
59060: ST_TO_ADDR
// if not tmp and not lab then
59061: LD_VAR 0 4
59065: NOT
59066: PUSH
59067: LD_VAR 0 6
59071: NOT
59072: AND
59073: IFFALSE 59077
// continue ;
59075: GO 58993
// if tmp then
59077: LD_VAR 0 4
59081: IFFALSE 59201
// for j in tmp do
59083: LD_ADDR_VAR 0 3
59087: PUSH
59088: LD_VAR 0 4
59092: PUSH
59093: FOR_IN
59094: IFFALSE 59199
// begin if UpgradeCost ( j ) then
59096: LD_VAR 0 3
59100: PPUSH
59101: CALL 21335 0 1
59105: IFFALSE 59197
// begin ComUpgrade ( j ) ;
59107: LD_VAR 0 3
59111: PPUSH
59112: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
59116: LD_ADDR_EXP 75
59120: PUSH
59121: LD_EXP 75
59125: PPUSH
59126: LD_VAR 0 2
59130: PPUSH
59131: LD_EXP 75
59135: PUSH
59136: LD_VAR 0 2
59140: ARRAY
59141: PUSH
59142: LD_VAR 0 3
59146: DIFF
59147: PPUSH
59148: CALL_OW 1
59152: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59153: LD_ADDR_EXP 50
59157: PUSH
59158: LD_EXP 50
59162: PPUSH
59163: LD_VAR 0 2
59167: PUSH
59168: LD_EXP 50
59172: PUSH
59173: LD_VAR 0 2
59177: ARRAY
59178: PUSH
59179: LD_INT 1
59181: PLUS
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: PPUSH
59187: LD_VAR 0 3
59191: PPUSH
59192: CALL 14797 0 3
59196: ST_TO_ADDR
// end ; end ;
59197: GO 59093
59199: POP
59200: POP
// if not lab or not mc_lab_upgrade [ i ] then
59201: LD_VAR 0 6
59205: NOT
59206: PUSH
59207: LD_EXP 77
59211: PUSH
59212: LD_VAR 0 2
59216: ARRAY
59217: NOT
59218: OR
59219: IFFALSE 59223
// continue ;
59221: GO 58993
// for j in lab do
59223: LD_ADDR_VAR 0 3
59227: PUSH
59228: LD_VAR 0 6
59232: PUSH
59233: FOR_IN
59234: IFFALSE 59399
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
59236: LD_VAR 0 3
59240: PPUSH
59241: CALL_OW 266
59245: PUSH
59246: LD_INT 6
59248: PUSH
59249: LD_INT 7
59251: PUSH
59252: EMPTY
59253: LIST
59254: LIST
59255: IN
59256: PUSH
59257: LD_VAR 0 3
59261: PPUSH
59262: CALL_OW 461
59266: PUSH
59267: LD_INT 1
59269: NONEQUAL
59270: AND
59271: IFFALSE 59397
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
59273: LD_VAR 0 3
59277: PPUSH
59278: LD_EXP 77
59282: PUSH
59283: LD_VAR 0 2
59287: ARRAY
59288: PUSH
59289: LD_INT 1
59291: ARRAY
59292: PPUSH
59293: CALL 21540 0 2
59297: IFFALSE 59397
// begin ComCancel ( j ) ;
59299: LD_VAR 0 3
59303: PPUSH
59304: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
59308: LD_VAR 0 3
59312: PPUSH
59313: LD_EXP 77
59317: PUSH
59318: LD_VAR 0 2
59322: ARRAY
59323: PUSH
59324: LD_INT 1
59326: ARRAY
59327: PPUSH
59328: CALL_OW 207
// if not j in mc_construct_list [ i ] then
59332: LD_VAR 0 3
59336: PUSH
59337: LD_EXP 50
59341: PUSH
59342: LD_VAR 0 2
59346: ARRAY
59347: IN
59348: NOT
59349: IFFALSE 59395
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59351: LD_ADDR_EXP 50
59355: PUSH
59356: LD_EXP 50
59360: PPUSH
59361: LD_VAR 0 2
59365: PUSH
59366: LD_EXP 50
59370: PUSH
59371: LD_VAR 0 2
59375: ARRAY
59376: PUSH
59377: LD_INT 1
59379: PLUS
59380: PUSH
59381: EMPTY
59382: LIST
59383: LIST
59384: PPUSH
59385: LD_VAR 0 3
59389: PPUSH
59390: CALL 14797 0 3
59394: ST_TO_ADDR
// break ;
59395: GO 59399
// end ; end ; end ;
59397: GO 59233
59399: POP
59400: POP
// end ;
59401: GO 58993
59403: POP
59404: POP
// end ;
59405: LD_VAR 0 1
59409: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
59410: LD_INT 0
59412: PPUSH
59413: PPUSH
59414: PPUSH
59415: PPUSH
59416: PPUSH
59417: PPUSH
59418: PPUSH
59419: PPUSH
59420: PPUSH
// if not mc_bases then
59421: LD_EXP 43
59425: NOT
59426: IFFALSE 59430
// exit ;
59428: GO 59835
// for i = 1 to mc_bases do
59430: LD_ADDR_VAR 0 2
59434: PUSH
59435: DOUBLE
59436: LD_INT 1
59438: DEC
59439: ST_TO_ADDR
59440: LD_EXP 43
59444: PUSH
59445: FOR_TO
59446: IFFALSE 59833
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
59448: LD_EXP 51
59452: PUSH
59453: LD_VAR 0 2
59457: ARRAY
59458: NOT
59459: PUSH
59460: LD_EXP 43
59464: PUSH
59465: LD_VAR 0 2
59469: ARRAY
59470: PPUSH
59471: LD_INT 30
59473: PUSH
59474: LD_INT 3
59476: PUSH
59477: EMPTY
59478: LIST
59479: LIST
59480: PPUSH
59481: CALL_OW 72
59485: NOT
59486: OR
59487: IFFALSE 59491
// continue ;
59489: GO 59445
// busy := false ;
59491: LD_ADDR_VAR 0 8
59495: PUSH
59496: LD_INT 0
59498: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59499: LD_ADDR_VAR 0 4
59503: PUSH
59504: LD_EXP 43
59508: PUSH
59509: LD_VAR 0 2
59513: ARRAY
59514: PPUSH
59515: LD_INT 30
59517: PUSH
59518: LD_INT 3
59520: PUSH
59521: EMPTY
59522: LIST
59523: LIST
59524: PPUSH
59525: CALL_OW 72
59529: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59530: LD_ADDR_VAR 0 6
59534: PUSH
59535: LD_EXP 51
59539: PUSH
59540: LD_VAR 0 2
59544: ARRAY
59545: PPUSH
59546: LD_INT 2
59548: PUSH
59549: LD_INT 30
59551: PUSH
59552: LD_INT 32
59554: PUSH
59555: EMPTY
59556: LIST
59557: LIST
59558: PUSH
59559: LD_INT 30
59561: PUSH
59562: LD_INT 33
59564: PUSH
59565: EMPTY
59566: LIST
59567: LIST
59568: PUSH
59569: EMPTY
59570: LIST
59571: LIST
59572: LIST
59573: PPUSH
59574: CALL_OW 72
59578: ST_TO_ADDR
// if not t then
59579: LD_VAR 0 6
59583: NOT
59584: IFFALSE 59588
// continue ;
59586: GO 59445
// for j in tmp do
59588: LD_ADDR_VAR 0 3
59592: PUSH
59593: LD_VAR 0 4
59597: PUSH
59598: FOR_IN
59599: IFFALSE 59629
// if not BuildingStatus ( j ) = bs_idle then
59601: LD_VAR 0 3
59605: PPUSH
59606: CALL_OW 461
59610: PUSH
59611: LD_INT 2
59613: EQUAL
59614: NOT
59615: IFFALSE 59627
// begin busy := true ;
59617: LD_ADDR_VAR 0 8
59621: PUSH
59622: LD_INT 1
59624: ST_TO_ADDR
// break ;
59625: GO 59629
// end ;
59627: GO 59598
59629: POP
59630: POP
// if busy then
59631: LD_VAR 0 8
59635: IFFALSE 59639
// continue ;
59637: GO 59445
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59639: LD_ADDR_VAR 0 7
59643: PUSH
59644: LD_VAR 0 6
59648: PPUSH
59649: LD_INT 35
59651: PUSH
59652: LD_INT 0
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 72
59663: ST_TO_ADDR
// if tw then
59664: LD_VAR 0 7
59668: IFFALSE 59745
// begin tw := tw [ 1 ] ;
59670: LD_ADDR_VAR 0 7
59674: PUSH
59675: LD_VAR 0 7
59679: PUSH
59680: LD_INT 1
59682: ARRAY
59683: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59684: LD_ADDR_VAR 0 9
59688: PUSH
59689: LD_VAR 0 7
59693: PPUSH
59694: LD_EXP 68
59698: PUSH
59699: LD_VAR 0 2
59703: ARRAY
59704: PPUSH
59705: CALL 19802 0 2
59709: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59710: LD_EXP 82
59714: PUSH
59715: LD_VAR 0 2
59719: ARRAY
59720: IFFALSE 59743
// if not weapon in mc_allowed_tower_weapons [ i ] then
59722: LD_VAR 0 9
59726: PUSH
59727: LD_EXP 82
59731: PUSH
59732: LD_VAR 0 2
59736: ARRAY
59737: IN
59738: NOT
59739: IFFALSE 59743
// continue ;
59741: GO 59445
// end else
59743: GO 59808
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59745: LD_ADDR_VAR 0 5
59749: PUSH
59750: LD_EXP 51
59754: PUSH
59755: LD_VAR 0 2
59759: ARRAY
59760: PPUSH
59761: LD_VAR 0 4
59765: PPUSH
59766: CALL 45721 0 2
59770: ST_TO_ADDR
// if not tmp2 then
59771: LD_VAR 0 5
59775: NOT
59776: IFFALSE 59780
// continue ;
59778: GO 59445
// tw := tmp2 [ 1 ] ;
59780: LD_ADDR_VAR 0 7
59784: PUSH
59785: LD_VAR 0 5
59789: PUSH
59790: LD_INT 1
59792: ARRAY
59793: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59794: LD_ADDR_VAR 0 9
59798: PUSH
59799: LD_VAR 0 5
59803: PUSH
59804: LD_INT 2
59806: ARRAY
59807: ST_TO_ADDR
// end ; if not weapon then
59808: LD_VAR 0 9
59812: NOT
59813: IFFALSE 59817
// continue ;
59815: GO 59445
// ComPlaceWeapon ( tw , weapon ) ;
59817: LD_VAR 0 7
59821: PPUSH
59822: LD_VAR 0 9
59826: PPUSH
59827: CALL_OW 148
// end ;
59831: GO 59445
59833: POP
59834: POP
// end ;
59835: LD_VAR 0 1
59839: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
59840: LD_INT 0
59842: PPUSH
59843: PPUSH
59844: PPUSH
59845: PPUSH
59846: PPUSH
59847: PPUSH
59848: PPUSH
// if not mc_bases then
59849: LD_EXP 43
59853: NOT
59854: IFFALSE 59858
// exit ;
59856: GO 60626
// for i = 1 to mc_bases do
59858: LD_ADDR_VAR 0 2
59862: PUSH
59863: DOUBLE
59864: LD_INT 1
59866: DEC
59867: ST_TO_ADDR
59868: LD_EXP 43
59872: PUSH
59873: FOR_TO
59874: IFFALSE 60624
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59876: LD_EXP 56
59880: PUSH
59881: LD_VAR 0 2
59885: ARRAY
59886: NOT
59887: PUSH
59888: LD_EXP 56
59892: PUSH
59893: LD_VAR 0 2
59897: ARRAY
59898: PUSH
59899: LD_EXP 57
59903: PUSH
59904: LD_VAR 0 2
59908: ARRAY
59909: EQUAL
59910: OR
59911: PUSH
59912: LD_EXP 66
59916: PUSH
59917: LD_VAR 0 2
59921: ARRAY
59922: OR
59923: IFFALSE 59927
// continue ;
59925: GO 59873
// if mc_miners [ i ] then
59927: LD_EXP 57
59931: PUSH
59932: LD_VAR 0 2
59936: ARRAY
59937: IFFALSE 60311
// begin for j = mc_miners [ i ] downto 1 do
59939: LD_ADDR_VAR 0 3
59943: PUSH
59944: DOUBLE
59945: LD_EXP 57
59949: PUSH
59950: LD_VAR 0 2
59954: ARRAY
59955: INC
59956: ST_TO_ADDR
59957: LD_INT 1
59959: PUSH
59960: FOR_DOWNTO
59961: IFFALSE 60309
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59963: LD_EXP 57
59967: PUSH
59968: LD_VAR 0 2
59972: ARRAY
59973: PUSH
59974: LD_VAR 0 3
59978: ARRAY
59979: PPUSH
59980: CALL_OW 301
59984: PUSH
59985: LD_EXP 57
59989: PUSH
59990: LD_VAR 0 2
59994: ARRAY
59995: PUSH
59996: LD_VAR 0 3
60000: ARRAY
60001: PPUSH
60002: CALL_OW 257
60006: PUSH
60007: LD_INT 1
60009: NONEQUAL
60010: OR
60011: IFFALSE 60074
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
60013: LD_ADDR_VAR 0 5
60017: PUSH
60018: LD_EXP 57
60022: PUSH
60023: LD_VAR 0 2
60027: ARRAY
60028: PUSH
60029: LD_EXP 57
60033: PUSH
60034: LD_VAR 0 2
60038: ARRAY
60039: PUSH
60040: LD_VAR 0 3
60044: ARRAY
60045: DIFF
60046: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
60047: LD_ADDR_EXP 57
60051: PUSH
60052: LD_EXP 57
60056: PPUSH
60057: LD_VAR 0 2
60061: PPUSH
60062: LD_VAR 0 5
60066: PPUSH
60067: CALL_OW 1
60071: ST_TO_ADDR
// continue ;
60072: GO 59960
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
60074: LD_EXP 57
60078: PUSH
60079: LD_VAR 0 2
60083: ARRAY
60084: PUSH
60085: LD_VAR 0 3
60089: ARRAY
60090: PPUSH
60091: CALL_OW 257
60095: PUSH
60096: LD_INT 1
60098: EQUAL
60099: PUSH
60100: LD_EXP 57
60104: PUSH
60105: LD_VAR 0 2
60109: ARRAY
60110: PUSH
60111: LD_VAR 0 3
60115: ARRAY
60116: PPUSH
60117: CALL_OW 459
60121: NOT
60122: AND
60123: PUSH
60124: LD_EXP 57
60128: PUSH
60129: LD_VAR 0 2
60133: ARRAY
60134: PUSH
60135: LD_VAR 0 3
60139: ARRAY
60140: PPUSH
60141: CALL_OW 314
60145: NOT
60146: AND
60147: IFFALSE 60307
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
60149: LD_EXP 57
60153: PUSH
60154: LD_VAR 0 2
60158: ARRAY
60159: PUSH
60160: LD_VAR 0 3
60164: ARRAY
60165: PPUSH
60166: CALL_OW 310
60170: IFFALSE 60193
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
60172: LD_EXP 57
60176: PUSH
60177: LD_VAR 0 2
60181: ARRAY
60182: PUSH
60183: LD_VAR 0 3
60187: ARRAY
60188: PPUSH
60189: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
60193: LD_EXP 57
60197: PUSH
60198: LD_VAR 0 2
60202: ARRAY
60203: PUSH
60204: LD_VAR 0 3
60208: ARRAY
60209: PPUSH
60210: CALL_OW 314
60214: NOT
60215: IFFALSE 60307
// begin r := rand ( 1 , mc_mines [ i ] ) ;
60217: LD_ADDR_VAR 0 7
60221: PUSH
60222: LD_INT 1
60224: PPUSH
60225: LD_EXP 56
60229: PUSH
60230: LD_VAR 0 2
60234: ARRAY
60235: PPUSH
60236: CALL_OW 12
60240: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
60241: LD_EXP 57
60245: PUSH
60246: LD_VAR 0 2
60250: ARRAY
60251: PUSH
60252: LD_VAR 0 3
60256: ARRAY
60257: PPUSH
60258: LD_EXP 56
60262: PUSH
60263: LD_VAR 0 2
60267: ARRAY
60268: PUSH
60269: LD_VAR 0 7
60273: ARRAY
60274: PUSH
60275: LD_INT 1
60277: ARRAY
60278: PPUSH
60279: LD_EXP 56
60283: PUSH
60284: LD_VAR 0 2
60288: ARRAY
60289: PUSH
60290: LD_VAR 0 7
60294: ARRAY
60295: PUSH
60296: LD_INT 2
60298: ARRAY
60299: PPUSH
60300: LD_INT 0
60302: PPUSH
60303: CALL_OW 193
// end ; end ; end ;
60307: GO 59960
60309: POP
60310: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
60311: LD_ADDR_VAR 0 5
60315: PUSH
60316: LD_EXP 43
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: PPUSH
60327: LD_INT 2
60329: PUSH
60330: LD_INT 30
60332: PUSH
60333: LD_INT 4
60335: PUSH
60336: EMPTY
60337: LIST
60338: LIST
60339: PUSH
60340: LD_INT 30
60342: PUSH
60343: LD_INT 5
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PUSH
60350: LD_INT 30
60352: PUSH
60353: LD_INT 32
60355: PUSH
60356: EMPTY
60357: LIST
60358: LIST
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: LIST
60364: LIST
60365: PPUSH
60366: CALL_OW 72
60370: ST_TO_ADDR
// if not tmp then
60371: LD_VAR 0 5
60375: NOT
60376: IFFALSE 60380
// continue ;
60378: GO 59873
// list := [ ] ;
60380: LD_ADDR_VAR 0 6
60384: PUSH
60385: EMPTY
60386: ST_TO_ADDR
// for j in tmp do
60387: LD_ADDR_VAR 0 3
60391: PUSH
60392: LD_VAR 0 5
60396: PUSH
60397: FOR_IN
60398: IFFALSE 60467
// begin for k in UnitsInside ( j ) do
60400: LD_ADDR_VAR 0 4
60404: PUSH
60405: LD_VAR 0 3
60409: PPUSH
60410: CALL_OW 313
60414: PUSH
60415: FOR_IN
60416: IFFALSE 60463
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
60418: LD_VAR 0 4
60422: PPUSH
60423: CALL_OW 257
60427: PUSH
60428: LD_INT 1
60430: EQUAL
60431: PUSH
60432: LD_VAR 0 4
60436: PPUSH
60437: CALL_OW 459
60441: NOT
60442: AND
60443: IFFALSE 60461
// list := list ^ k ;
60445: LD_ADDR_VAR 0 6
60449: PUSH
60450: LD_VAR 0 6
60454: PUSH
60455: LD_VAR 0 4
60459: ADD
60460: ST_TO_ADDR
60461: GO 60415
60463: POP
60464: POP
// end ;
60465: GO 60397
60467: POP
60468: POP
// list := list diff mc_miners [ i ] ;
60469: LD_ADDR_VAR 0 6
60473: PUSH
60474: LD_VAR 0 6
60478: PUSH
60479: LD_EXP 57
60483: PUSH
60484: LD_VAR 0 2
60488: ARRAY
60489: DIFF
60490: ST_TO_ADDR
// if not list then
60491: LD_VAR 0 6
60495: NOT
60496: IFFALSE 60500
// continue ;
60498: GO 59873
// k := mc_mines [ i ] - mc_miners [ i ] ;
60500: LD_ADDR_VAR 0 4
60504: PUSH
60505: LD_EXP 56
60509: PUSH
60510: LD_VAR 0 2
60514: ARRAY
60515: PUSH
60516: LD_EXP 57
60520: PUSH
60521: LD_VAR 0 2
60525: ARRAY
60526: MINUS
60527: ST_TO_ADDR
// if k > list then
60528: LD_VAR 0 4
60532: PUSH
60533: LD_VAR 0 6
60537: GREATER
60538: IFFALSE 60550
// k := list ;
60540: LD_ADDR_VAR 0 4
60544: PUSH
60545: LD_VAR 0 6
60549: ST_TO_ADDR
// for j = 1 to k do
60550: LD_ADDR_VAR 0 3
60554: PUSH
60555: DOUBLE
60556: LD_INT 1
60558: DEC
60559: ST_TO_ADDR
60560: LD_VAR 0 4
60564: PUSH
60565: FOR_TO
60566: IFFALSE 60620
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60568: LD_ADDR_EXP 57
60572: PUSH
60573: LD_EXP 57
60577: PPUSH
60578: LD_VAR 0 2
60582: PUSH
60583: LD_EXP 57
60587: PUSH
60588: LD_VAR 0 2
60592: ARRAY
60593: PUSH
60594: LD_INT 1
60596: PLUS
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PPUSH
60602: LD_VAR 0 6
60606: PUSH
60607: LD_VAR 0 3
60611: ARRAY
60612: PPUSH
60613: CALL 14797 0 3
60617: ST_TO_ADDR
60618: GO 60565
60620: POP
60621: POP
// end ;
60622: GO 59873
60624: POP
60625: POP
// end ;
60626: LD_VAR 0 1
60630: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60631: LD_INT 0
60633: PPUSH
60634: PPUSH
60635: PPUSH
60636: PPUSH
60637: PPUSH
60638: PPUSH
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
// if not mc_bases then
60643: LD_EXP 43
60647: NOT
60648: IFFALSE 60652
// exit ;
60650: GO 62402
// for i = 1 to mc_bases do
60652: LD_ADDR_VAR 0 2
60656: PUSH
60657: DOUBLE
60658: LD_INT 1
60660: DEC
60661: ST_TO_ADDR
60662: LD_EXP 43
60666: PUSH
60667: FOR_TO
60668: IFFALSE 62400
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60670: LD_EXP 43
60674: PUSH
60675: LD_VAR 0 2
60679: ARRAY
60680: NOT
60681: PUSH
60682: LD_EXP 50
60686: PUSH
60687: LD_VAR 0 2
60691: ARRAY
60692: OR
60693: IFFALSE 60697
// continue ;
60695: GO 60667
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60697: LD_EXP 59
60701: PUSH
60702: LD_VAR 0 2
60706: ARRAY
60707: NOT
60708: PUSH
60709: LD_EXP 60
60713: PUSH
60714: LD_VAR 0 2
60718: ARRAY
60719: AND
60720: IFFALSE 60758
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60722: LD_ADDR_EXP 60
60726: PUSH
60727: LD_EXP 60
60731: PPUSH
60732: LD_VAR 0 2
60736: PPUSH
60737: EMPTY
60738: PPUSH
60739: CALL_OW 1
60743: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60744: LD_VAR 0 2
60748: PPUSH
60749: LD_INT 107
60751: PPUSH
60752: CALL 51585 0 2
// continue ;
60756: GO 60667
// end ; target := [ ] ;
60758: LD_ADDR_VAR 0 6
60762: PUSH
60763: EMPTY
60764: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60765: LD_ADDR_VAR 0 3
60769: PUSH
60770: DOUBLE
60771: LD_EXP 59
60775: PUSH
60776: LD_VAR 0 2
60780: ARRAY
60781: INC
60782: ST_TO_ADDR
60783: LD_INT 1
60785: PUSH
60786: FOR_DOWNTO
60787: IFFALSE 61047
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60789: LD_EXP 59
60793: PUSH
60794: LD_VAR 0 2
60798: ARRAY
60799: PUSH
60800: LD_VAR 0 3
60804: ARRAY
60805: PUSH
60806: LD_INT 2
60808: ARRAY
60809: PPUSH
60810: LD_EXP 59
60814: PUSH
60815: LD_VAR 0 2
60819: ARRAY
60820: PUSH
60821: LD_VAR 0 3
60825: ARRAY
60826: PUSH
60827: LD_INT 3
60829: ARRAY
60830: PPUSH
60831: CALL_OW 488
60835: PUSH
60836: LD_EXP 59
60840: PUSH
60841: LD_VAR 0 2
60845: ARRAY
60846: PUSH
60847: LD_VAR 0 3
60851: ARRAY
60852: PUSH
60853: LD_INT 2
60855: ARRAY
60856: PPUSH
60857: LD_EXP 59
60861: PUSH
60862: LD_VAR 0 2
60866: ARRAY
60867: PUSH
60868: LD_VAR 0 3
60872: ARRAY
60873: PUSH
60874: LD_INT 3
60876: ARRAY
60877: PPUSH
60878: CALL_OW 284
60882: PUSH
60883: LD_INT 0
60885: EQUAL
60886: AND
60887: IFFALSE 60942
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60889: LD_ADDR_VAR 0 5
60893: PUSH
60894: LD_EXP 59
60898: PUSH
60899: LD_VAR 0 2
60903: ARRAY
60904: PPUSH
60905: LD_VAR 0 3
60909: PPUSH
60910: CALL_OW 3
60914: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60915: LD_ADDR_EXP 59
60919: PUSH
60920: LD_EXP 59
60924: PPUSH
60925: LD_VAR 0 2
60929: PPUSH
60930: LD_VAR 0 5
60934: PPUSH
60935: CALL_OW 1
60939: ST_TO_ADDR
// continue ;
60940: GO 60786
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60942: LD_EXP 43
60946: PUSH
60947: LD_VAR 0 2
60951: ARRAY
60952: PUSH
60953: LD_INT 1
60955: ARRAY
60956: PPUSH
60957: CALL_OW 255
60961: PPUSH
60962: LD_EXP 59
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: PUSH
60973: LD_VAR 0 3
60977: ARRAY
60978: PUSH
60979: LD_INT 2
60981: ARRAY
60982: PPUSH
60983: LD_EXP 59
60987: PUSH
60988: LD_VAR 0 2
60992: ARRAY
60993: PUSH
60994: LD_VAR 0 3
60998: ARRAY
60999: PUSH
61000: LD_INT 3
61002: ARRAY
61003: PPUSH
61004: LD_INT 30
61006: PPUSH
61007: CALL 15693 0 4
61011: PUSH
61012: LD_INT 4
61014: ARRAY
61015: PUSH
61016: LD_INT 0
61018: EQUAL
61019: IFFALSE 61045
// begin target := mc_crates [ i ] [ j ] ;
61021: LD_ADDR_VAR 0 6
61025: PUSH
61026: LD_EXP 59
61030: PUSH
61031: LD_VAR 0 2
61035: ARRAY
61036: PUSH
61037: LD_VAR 0 3
61041: ARRAY
61042: ST_TO_ADDR
// break ;
61043: GO 61047
// end ; end ;
61045: GO 60786
61047: POP
61048: POP
// if not target then
61049: LD_VAR 0 6
61053: NOT
61054: IFFALSE 61058
// continue ;
61056: GO 60667
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
61058: LD_ADDR_VAR 0 7
61062: PUSH
61063: LD_EXP 62
61067: PUSH
61068: LD_VAR 0 2
61072: ARRAY
61073: PPUSH
61074: LD_INT 2
61076: PUSH
61077: LD_INT 3
61079: PUSH
61080: LD_INT 58
61082: PUSH
61083: EMPTY
61084: LIST
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: PUSH
61090: LD_INT 61
61092: PUSH
61093: EMPTY
61094: LIST
61095: PUSH
61096: LD_INT 33
61098: PUSH
61099: LD_INT 5
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 33
61108: PUSH
61109: LD_INT 3
61111: PUSH
61112: EMPTY
61113: LIST
61114: LIST
61115: PUSH
61116: EMPTY
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: PUSH
61123: LD_INT 2
61125: PUSH
61126: LD_INT 34
61128: PUSH
61129: LD_INT 32
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 34
61138: PUSH
61139: LD_INT 51
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 34
61148: PUSH
61149: LD_INT 12
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: LIST
61160: LIST
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PPUSH
61166: CALL_OW 72
61170: ST_TO_ADDR
// if not cargo then
61171: LD_VAR 0 7
61175: NOT
61176: IFFALSE 61819
// begin if mc_crates_collector [ i ] < 5 then
61178: LD_EXP 60
61182: PUSH
61183: LD_VAR 0 2
61187: ARRAY
61188: PUSH
61189: LD_INT 5
61191: LESS
61192: IFFALSE 61558
// begin if mc_ape [ i ] then
61194: LD_EXP 72
61198: PUSH
61199: LD_VAR 0 2
61203: ARRAY
61204: IFFALSE 61251
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
61206: LD_ADDR_VAR 0 5
61210: PUSH
61211: LD_EXP 72
61215: PUSH
61216: LD_VAR 0 2
61220: ARRAY
61221: PPUSH
61222: LD_INT 25
61224: PUSH
61225: LD_INT 16
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PUSH
61232: LD_INT 24
61234: PUSH
61235: LD_INT 750
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: PUSH
61242: EMPTY
61243: LIST
61244: LIST
61245: PPUSH
61246: CALL_OW 72
61250: ST_TO_ADDR
// if not tmp then
61251: LD_VAR 0 5
61255: NOT
61256: IFFALSE 61303
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
61258: LD_ADDR_VAR 0 5
61262: PUSH
61263: LD_EXP 43
61267: PUSH
61268: LD_VAR 0 2
61272: ARRAY
61273: PPUSH
61274: LD_INT 25
61276: PUSH
61277: LD_INT 2
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: LD_INT 24
61286: PUSH
61287: LD_INT 750
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PPUSH
61298: CALL_OW 72
61302: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
61303: LD_EXP 72
61307: PUSH
61308: LD_VAR 0 2
61312: ARRAY
61313: PUSH
61314: LD_EXP 43
61318: PUSH
61319: LD_VAR 0 2
61323: ARRAY
61324: PPUSH
61325: LD_INT 25
61327: PUSH
61328: LD_INT 2
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: PUSH
61335: LD_INT 24
61337: PUSH
61338: LD_INT 750
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PPUSH
61349: CALL_OW 72
61353: AND
61354: PUSH
61355: LD_VAR 0 5
61359: PUSH
61360: LD_INT 5
61362: LESS
61363: AND
61364: IFFALSE 61446
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
61366: LD_ADDR_VAR 0 3
61370: PUSH
61371: LD_EXP 43
61375: PUSH
61376: LD_VAR 0 2
61380: ARRAY
61381: PPUSH
61382: LD_INT 25
61384: PUSH
61385: LD_INT 2
61387: PUSH
61388: EMPTY
61389: LIST
61390: LIST
61391: PUSH
61392: LD_INT 24
61394: PUSH
61395: LD_INT 750
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: PPUSH
61406: CALL_OW 72
61410: PUSH
61411: FOR_IN
61412: IFFALSE 61444
// begin tmp := tmp union j ;
61414: LD_ADDR_VAR 0 5
61418: PUSH
61419: LD_VAR 0 5
61423: PUSH
61424: LD_VAR 0 3
61428: UNION
61429: ST_TO_ADDR
// if tmp >= 5 then
61430: LD_VAR 0 5
61434: PUSH
61435: LD_INT 5
61437: GREATEREQUAL
61438: IFFALSE 61442
// break ;
61440: GO 61444
// end ;
61442: GO 61411
61444: POP
61445: POP
// end ; if not tmp then
61446: LD_VAR 0 5
61450: NOT
61451: IFFALSE 61455
// continue ;
61453: GO 60667
// for j in tmp do
61455: LD_ADDR_VAR 0 3
61459: PUSH
61460: LD_VAR 0 5
61464: PUSH
61465: FOR_IN
61466: IFFALSE 61556
// if not GetTag ( j ) then
61468: LD_VAR 0 3
61472: PPUSH
61473: CALL_OW 110
61477: NOT
61478: IFFALSE 61554
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61480: LD_ADDR_EXP 60
61484: PUSH
61485: LD_EXP 60
61489: PPUSH
61490: LD_VAR 0 2
61494: PUSH
61495: LD_EXP 60
61499: PUSH
61500: LD_VAR 0 2
61504: ARRAY
61505: PUSH
61506: LD_INT 1
61508: PLUS
61509: PUSH
61510: EMPTY
61511: LIST
61512: LIST
61513: PPUSH
61514: LD_VAR 0 3
61518: PPUSH
61519: CALL 14797 0 3
61523: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61524: LD_VAR 0 3
61528: PPUSH
61529: LD_INT 107
61531: PPUSH
61532: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61536: LD_EXP 60
61540: PUSH
61541: LD_VAR 0 2
61545: ARRAY
61546: PUSH
61547: LD_INT 5
61549: GREATEREQUAL
61550: IFFALSE 61554
// break ;
61552: GO 61556
// end ;
61554: GO 61465
61556: POP
61557: POP
// end ; if mc_crates_collector [ i ] and target then
61558: LD_EXP 60
61562: PUSH
61563: LD_VAR 0 2
61567: ARRAY
61568: PUSH
61569: LD_VAR 0 6
61573: AND
61574: IFFALSE 61817
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61576: LD_EXP 60
61580: PUSH
61581: LD_VAR 0 2
61585: ARRAY
61586: PUSH
61587: LD_VAR 0 6
61591: PUSH
61592: LD_INT 1
61594: ARRAY
61595: LESS
61596: IFFALSE 61616
// tmp := mc_crates_collector [ i ] else
61598: LD_ADDR_VAR 0 5
61602: PUSH
61603: LD_EXP 60
61607: PUSH
61608: LD_VAR 0 2
61612: ARRAY
61613: ST_TO_ADDR
61614: GO 61630
// tmp := target [ 1 ] ;
61616: LD_ADDR_VAR 0 5
61620: PUSH
61621: LD_VAR 0 6
61625: PUSH
61626: LD_INT 1
61628: ARRAY
61629: ST_TO_ADDR
// k := 0 ;
61630: LD_ADDR_VAR 0 4
61634: PUSH
61635: LD_INT 0
61637: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61638: LD_ADDR_VAR 0 3
61642: PUSH
61643: LD_EXP 60
61647: PUSH
61648: LD_VAR 0 2
61652: ARRAY
61653: PUSH
61654: FOR_IN
61655: IFFALSE 61815
// begin k := k + 1 ;
61657: LD_ADDR_VAR 0 4
61661: PUSH
61662: LD_VAR 0 4
61666: PUSH
61667: LD_INT 1
61669: PLUS
61670: ST_TO_ADDR
// if k > tmp then
61671: LD_VAR 0 4
61675: PUSH
61676: LD_VAR 0 5
61680: GREATER
61681: IFFALSE 61685
// break ;
61683: GO 61815
// if not GetClass ( j ) in [ 2 , 16 ] then
61685: LD_VAR 0 3
61689: PPUSH
61690: CALL_OW 257
61694: PUSH
61695: LD_INT 2
61697: PUSH
61698: LD_INT 16
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: IN
61705: NOT
61706: IFFALSE 61759
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61708: LD_ADDR_EXP 60
61712: PUSH
61713: LD_EXP 60
61717: PPUSH
61718: LD_VAR 0 2
61722: PPUSH
61723: LD_EXP 60
61727: PUSH
61728: LD_VAR 0 2
61732: ARRAY
61733: PUSH
61734: LD_VAR 0 3
61738: DIFF
61739: PPUSH
61740: CALL_OW 1
61744: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61745: LD_VAR 0 3
61749: PPUSH
61750: LD_INT 0
61752: PPUSH
61753: CALL_OW 109
// continue ;
61757: GO 61654
// end ; if IsInUnit ( j ) then
61759: LD_VAR 0 3
61763: PPUSH
61764: CALL_OW 310
61768: IFFALSE 61779
// ComExitBuilding ( j ) ;
61770: LD_VAR 0 3
61774: PPUSH
61775: CALL_OW 122
// wait ( 3 ) ;
61779: LD_INT 3
61781: PPUSH
61782: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61786: LD_VAR 0 3
61790: PPUSH
61791: LD_VAR 0 6
61795: PUSH
61796: LD_INT 2
61798: ARRAY
61799: PPUSH
61800: LD_VAR 0 6
61804: PUSH
61805: LD_INT 3
61807: ARRAY
61808: PPUSH
61809: CALL_OW 117
// end ;
61813: GO 61654
61815: POP
61816: POP
// end ; end else
61817: GO 62398
// begin for j in cargo do
61819: LD_ADDR_VAR 0 3
61823: PUSH
61824: LD_VAR 0 7
61828: PUSH
61829: FOR_IN
61830: IFFALSE 62396
// begin if GetTag ( j ) <> 0 then
61832: LD_VAR 0 3
61836: PPUSH
61837: CALL_OW 110
61841: PUSH
61842: LD_INT 0
61844: NONEQUAL
61845: IFFALSE 61849
// continue ;
61847: GO 61829
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61849: LD_VAR 0 3
61853: PPUSH
61854: CALL_OW 256
61858: PUSH
61859: LD_INT 1000
61861: LESS
61862: PUSH
61863: LD_VAR 0 3
61867: PPUSH
61868: LD_EXP 67
61872: PUSH
61873: LD_VAR 0 2
61877: ARRAY
61878: PPUSH
61879: CALL_OW 308
61883: NOT
61884: AND
61885: IFFALSE 61907
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61887: LD_VAR 0 3
61891: PPUSH
61892: LD_EXP 67
61896: PUSH
61897: LD_VAR 0 2
61901: ARRAY
61902: PPUSH
61903: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61907: LD_VAR 0 3
61911: PPUSH
61912: CALL_OW 256
61916: PUSH
61917: LD_INT 1000
61919: LESS
61920: PUSH
61921: LD_VAR 0 3
61925: PPUSH
61926: LD_EXP 67
61930: PUSH
61931: LD_VAR 0 2
61935: ARRAY
61936: PPUSH
61937: CALL_OW 308
61941: AND
61942: IFFALSE 61946
// continue ;
61944: GO 61829
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61946: LD_VAR 0 3
61950: PPUSH
61951: CALL_OW 262
61955: PUSH
61956: LD_INT 2
61958: EQUAL
61959: PUSH
61960: LD_VAR 0 3
61964: PPUSH
61965: CALL_OW 261
61969: PUSH
61970: LD_INT 15
61972: LESS
61973: AND
61974: IFFALSE 61978
// continue ;
61976: GO 61829
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61978: LD_VAR 0 3
61982: PPUSH
61983: CALL_OW 262
61987: PUSH
61988: LD_INT 1
61990: EQUAL
61991: PUSH
61992: LD_VAR 0 3
61996: PPUSH
61997: CALL_OW 261
62001: PUSH
62002: LD_INT 10
62004: LESS
62005: AND
62006: IFFALSE 62335
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62008: LD_ADDR_VAR 0 8
62012: PUSH
62013: LD_EXP 43
62017: PUSH
62018: LD_VAR 0 2
62022: ARRAY
62023: PPUSH
62024: LD_INT 2
62026: PUSH
62027: LD_INT 30
62029: PUSH
62030: LD_INT 0
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: PUSH
62037: LD_INT 30
62039: PUSH
62040: LD_INT 1
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: LIST
62051: PPUSH
62052: CALL_OW 72
62056: ST_TO_ADDR
// if not depot then
62057: LD_VAR 0 8
62061: NOT
62062: IFFALSE 62066
// continue ;
62064: GO 61829
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
62066: LD_VAR 0 3
62070: PPUSH
62071: LD_VAR 0 8
62075: PPUSH
62076: LD_VAR 0 3
62080: PPUSH
62081: CALL_OW 74
62085: PPUSH
62086: CALL_OW 296
62090: PUSH
62091: LD_INT 6
62093: LESS
62094: IFFALSE 62110
// SetFuel ( j , 100 ) else
62096: LD_VAR 0 3
62100: PPUSH
62101: LD_INT 100
62103: PPUSH
62104: CALL_OW 240
62108: GO 62335
// if GetFuel ( j ) = 0 then
62110: LD_VAR 0 3
62114: PPUSH
62115: CALL_OW 261
62119: PUSH
62120: LD_INT 0
62122: EQUAL
62123: IFFALSE 62335
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
62125: LD_ADDR_EXP 62
62129: PUSH
62130: LD_EXP 62
62134: PPUSH
62135: LD_VAR 0 2
62139: PPUSH
62140: LD_EXP 62
62144: PUSH
62145: LD_VAR 0 2
62149: ARRAY
62150: PUSH
62151: LD_VAR 0 3
62155: DIFF
62156: PPUSH
62157: CALL_OW 1
62161: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
62162: LD_VAR 0 3
62166: PPUSH
62167: CALL_OW 263
62171: PUSH
62172: LD_INT 1
62174: EQUAL
62175: IFFALSE 62191
// ComExitVehicle ( IsInUnit ( j ) ) ;
62177: LD_VAR 0 3
62181: PPUSH
62182: CALL_OW 310
62186: PPUSH
62187: CALL_OW 121
// if GetControl ( j ) = control_remote then
62191: LD_VAR 0 3
62195: PPUSH
62196: CALL_OW 263
62200: PUSH
62201: LD_INT 2
62203: EQUAL
62204: IFFALSE 62215
// ComUnlink ( j ) ;
62206: LD_VAR 0 3
62210: PPUSH
62211: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
62215: LD_ADDR_VAR 0 9
62219: PUSH
62220: LD_VAR 0 2
62224: PPUSH
62225: LD_INT 3
62227: PPUSH
62228: CALL 71710 0 2
62232: ST_TO_ADDR
// if fac then
62233: LD_VAR 0 9
62237: IFFALSE 62333
// begin for k in fac do
62239: LD_ADDR_VAR 0 4
62243: PUSH
62244: LD_VAR 0 9
62248: PUSH
62249: FOR_IN
62250: IFFALSE 62331
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
62252: LD_ADDR_VAR 0 10
62256: PUSH
62257: LD_VAR 0 9
62261: PPUSH
62262: LD_VAR 0 3
62266: PPUSH
62267: CALL_OW 265
62271: PPUSH
62272: LD_VAR 0 3
62276: PPUSH
62277: CALL_OW 262
62281: PPUSH
62282: LD_VAR 0 3
62286: PPUSH
62287: CALL_OW 263
62291: PPUSH
62292: LD_VAR 0 3
62296: PPUSH
62297: CALL_OW 264
62301: PPUSH
62302: CALL 12329 0 5
62306: ST_TO_ADDR
// if components then
62307: LD_VAR 0 10
62311: IFFALSE 62329
// begin MC_InsertProduceList ( i , components ) ;
62313: LD_VAR 0 2
62317: PPUSH
62318: LD_VAR 0 10
62322: PPUSH
62323: CALL 71255 0 2
// break ;
62327: GO 62331
// end ; end ;
62329: GO 62249
62331: POP
62332: POP
// end ; continue ;
62333: GO 61829
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
62335: LD_VAR 0 3
62339: PPUSH
62340: LD_INT 1
62342: PPUSH
62343: CALL_OW 289
62347: PUSH
62348: LD_INT 100
62350: LESS
62351: PUSH
62352: LD_VAR 0 3
62356: PPUSH
62357: CALL_OW 314
62361: NOT
62362: AND
62363: IFFALSE 62392
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
62365: LD_VAR 0 3
62369: PPUSH
62370: LD_VAR 0 6
62374: PUSH
62375: LD_INT 2
62377: ARRAY
62378: PPUSH
62379: LD_VAR 0 6
62383: PUSH
62384: LD_INT 3
62386: ARRAY
62387: PPUSH
62388: CALL_OW 117
// break ;
62392: GO 62396
// end ;
62394: GO 61829
62396: POP
62397: POP
// end ; end ;
62398: GO 60667
62400: POP
62401: POP
// end ;
62402: LD_VAR 0 1
62406: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
62407: LD_INT 0
62409: PPUSH
62410: PPUSH
62411: PPUSH
62412: PPUSH
// if not mc_bases then
62413: LD_EXP 43
62417: NOT
62418: IFFALSE 62422
// exit ;
62420: GO 62583
// for i = 1 to mc_bases do
62422: LD_ADDR_VAR 0 2
62426: PUSH
62427: DOUBLE
62428: LD_INT 1
62430: DEC
62431: ST_TO_ADDR
62432: LD_EXP 43
62436: PUSH
62437: FOR_TO
62438: IFFALSE 62581
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
62440: LD_ADDR_VAR 0 4
62444: PUSH
62445: LD_EXP 62
62449: PUSH
62450: LD_VAR 0 2
62454: ARRAY
62455: PUSH
62456: LD_EXP 65
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: UNION
62467: PPUSH
62468: LD_INT 33
62470: PUSH
62471: LD_INT 2
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PPUSH
62478: CALL_OW 72
62482: ST_TO_ADDR
// if tmp then
62483: LD_VAR 0 4
62487: IFFALSE 62579
// for j in tmp do
62489: LD_ADDR_VAR 0 3
62493: PUSH
62494: LD_VAR 0 4
62498: PUSH
62499: FOR_IN
62500: IFFALSE 62577
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62502: LD_VAR 0 3
62506: PPUSH
62507: CALL_OW 312
62511: NOT
62512: PUSH
62513: LD_VAR 0 3
62517: PPUSH
62518: CALL_OW 256
62522: PUSH
62523: LD_INT 250
62525: GREATEREQUAL
62526: AND
62527: IFFALSE 62540
// Connect ( j ) else
62529: LD_VAR 0 3
62533: PPUSH
62534: CALL 17762 0 1
62538: GO 62575
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62540: LD_VAR 0 3
62544: PPUSH
62545: CALL_OW 256
62549: PUSH
62550: LD_INT 250
62552: LESS
62553: PUSH
62554: LD_VAR 0 3
62558: PPUSH
62559: CALL_OW 312
62563: AND
62564: IFFALSE 62575
// ComUnlink ( j ) ;
62566: LD_VAR 0 3
62570: PPUSH
62571: CALL_OW 136
62575: GO 62499
62577: POP
62578: POP
// end ;
62579: GO 62437
62581: POP
62582: POP
// end ;
62583: LD_VAR 0 1
62587: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62588: LD_INT 0
62590: PPUSH
62591: PPUSH
62592: PPUSH
62593: PPUSH
62594: PPUSH
// if not mc_bases then
62595: LD_EXP 43
62599: NOT
62600: IFFALSE 62604
// exit ;
62602: GO 63049
// for i = 1 to mc_bases do
62604: LD_ADDR_VAR 0 2
62608: PUSH
62609: DOUBLE
62610: LD_INT 1
62612: DEC
62613: ST_TO_ADDR
62614: LD_EXP 43
62618: PUSH
62619: FOR_TO
62620: IFFALSE 63047
// begin if not mc_produce [ i ] then
62622: LD_EXP 64
62626: PUSH
62627: LD_VAR 0 2
62631: ARRAY
62632: NOT
62633: IFFALSE 62637
// continue ;
62635: GO 62619
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62637: LD_ADDR_VAR 0 5
62641: PUSH
62642: LD_EXP 43
62646: PUSH
62647: LD_VAR 0 2
62651: ARRAY
62652: PPUSH
62653: LD_INT 30
62655: PUSH
62656: LD_INT 3
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PPUSH
62663: CALL_OW 72
62667: ST_TO_ADDR
// if not fac then
62668: LD_VAR 0 5
62672: NOT
62673: IFFALSE 62677
// continue ;
62675: GO 62619
// for j in fac do
62677: LD_ADDR_VAR 0 3
62681: PUSH
62682: LD_VAR 0 5
62686: PUSH
62687: FOR_IN
62688: IFFALSE 63043
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62690: LD_VAR 0 3
62694: PPUSH
62695: CALL_OW 461
62699: PUSH
62700: LD_INT 2
62702: NONEQUAL
62703: PUSH
62704: LD_VAR 0 3
62708: PPUSH
62709: LD_INT 15
62711: PPUSH
62712: CALL 17390 0 2
62716: PUSH
62717: LD_INT 4
62719: ARRAY
62720: OR
62721: IFFALSE 62725
// continue ;
62723: GO 62687
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62725: LD_VAR 0 3
62729: PPUSH
62730: LD_EXP 64
62734: PUSH
62735: LD_VAR 0 2
62739: ARRAY
62740: PUSH
62741: LD_INT 1
62743: ARRAY
62744: PUSH
62745: LD_INT 1
62747: ARRAY
62748: PPUSH
62749: LD_EXP 64
62753: PUSH
62754: LD_VAR 0 2
62758: ARRAY
62759: PUSH
62760: LD_INT 1
62762: ARRAY
62763: PUSH
62764: LD_INT 2
62766: ARRAY
62767: PPUSH
62768: LD_EXP 64
62772: PUSH
62773: LD_VAR 0 2
62777: ARRAY
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: PUSH
62783: LD_INT 3
62785: ARRAY
62786: PPUSH
62787: LD_EXP 64
62791: PUSH
62792: LD_VAR 0 2
62796: ARRAY
62797: PUSH
62798: LD_INT 1
62800: ARRAY
62801: PUSH
62802: LD_INT 4
62804: ARRAY
62805: PPUSH
62806: CALL_OW 448
62810: PUSH
62811: LD_VAR 0 3
62815: PPUSH
62816: LD_EXP 64
62820: PUSH
62821: LD_VAR 0 2
62825: ARRAY
62826: PUSH
62827: LD_INT 1
62829: ARRAY
62830: PUSH
62831: LD_INT 1
62833: ARRAY
62834: PUSH
62835: LD_EXP 64
62839: PUSH
62840: LD_VAR 0 2
62844: ARRAY
62845: PUSH
62846: LD_INT 1
62848: ARRAY
62849: PUSH
62850: LD_INT 2
62852: ARRAY
62853: PUSH
62854: LD_EXP 64
62858: PUSH
62859: LD_VAR 0 2
62863: ARRAY
62864: PUSH
62865: LD_INT 1
62867: ARRAY
62868: PUSH
62869: LD_INT 3
62871: ARRAY
62872: PUSH
62873: LD_EXP 64
62877: PUSH
62878: LD_VAR 0 2
62882: ARRAY
62883: PUSH
62884: LD_INT 1
62886: ARRAY
62887: PUSH
62888: LD_INT 4
62890: ARRAY
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: PPUSH
62898: CALL 21188 0 2
62902: AND
62903: IFFALSE 63041
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62905: LD_VAR 0 3
62909: PPUSH
62910: LD_EXP 64
62914: PUSH
62915: LD_VAR 0 2
62919: ARRAY
62920: PUSH
62921: LD_INT 1
62923: ARRAY
62924: PUSH
62925: LD_INT 1
62927: ARRAY
62928: PPUSH
62929: LD_EXP 64
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: PUSH
62940: LD_INT 1
62942: ARRAY
62943: PUSH
62944: LD_INT 2
62946: ARRAY
62947: PPUSH
62948: LD_EXP 64
62952: PUSH
62953: LD_VAR 0 2
62957: ARRAY
62958: PUSH
62959: LD_INT 1
62961: ARRAY
62962: PUSH
62963: LD_INT 3
62965: ARRAY
62966: PPUSH
62967: LD_EXP 64
62971: PUSH
62972: LD_VAR 0 2
62976: ARRAY
62977: PUSH
62978: LD_INT 1
62980: ARRAY
62981: PUSH
62982: LD_INT 4
62984: ARRAY
62985: PPUSH
62986: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62990: LD_ADDR_VAR 0 4
62994: PUSH
62995: LD_EXP 64
62999: PUSH
63000: LD_VAR 0 2
63004: ARRAY
63005: PPUSH
63006: LD_INT 1
63008: PPUSH
63009: CALL_OW 3
63013: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63014: LD_ADDR_EXP 64
63018: PUSH
63019: LD_EXP 64
63023: PPUSH
63024: LD_VAR 0 2
63028: PPUSH
63029: LD_VAR 0 4
63033: PPUSH
63034: CALL_OW 1
63038: ST_TO_ADDR
// break ;
63039: GO 63043
// end ; end ;
63041: GO 62687
63043: POP
63044: POP
// end ;
63045: GO 62619
63047: POP
63048: POP
// end ;
63049: LD_VAR 0 1
63053: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
63054: LD_INT 0
63056: PPUSH
63057: PPUSH
63058: PPUSH
// if not mc_bases then
63059: LD_EXP 43
63063: NOT
63064: IFFALSE 63068
// exit ;
63066: GO 63157
// for i = 1 to mc_bases do
63068: LD_ADDR_VAR 0 2
63072: PUSH
63073: DOUBLE
63074: LD_INT 1
63076: DEC
63077: ST_TO_ADDR
63078: LD_EXP 43
63082: PUSH
63083: FOR_TO
63084: IFFALSE 63155
// begin if mc_attack [ i ] then
63086: LD_EXP 63
63090: PUSH
63091: LD_VAR 0 2
63095: ARRAY
63096: IFFALSE 63153
// begin tmp := mc_attack [ i ] [ 1 ] ;
63098: LD_ADDR_VAR 0 3
63102: PUSH
63103: LD_EXP 63
63107: PUSH
63108: LD_VAR 0 2
63112: ARRAY
63113: PUSH
63114: LD_INT 1
63116: ARRAY
63117: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63118: LD_ADDR_EXP 63
63122: PUSH
63123: LD_EXP 63
63127: PPUSH
63128: LD_VAR 0 2
63132: PPUSH
63133: EMPTY
63134: PPUSH
63135: CALL_OW 1
63139: ST_TO_ADDR
// Attack ( tmp ) ;
63140: LD_VAR 0 3
63144: PPUSH
63145: CALL 77762 0 1
// exit ;
63149: POP
63150: POP
63151: GO 63157
// end ; end ;
63153: GO 63083
63155: POP
63156: POP
// end ;
63157: LD_VAR 0 1
63161: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
63162: LD_INT 0
63164: PPUSH
63165: PPUSH
63166: PPUSH
63167: PPUSH
63168: PPUSH
63169: PPUSH
63170: PPUSH
// if not mc_bases then
63171: LD_EXP 43
63175: NOT
63176: IFFALSE 63180
// exit ;
63178: GO 63784
// for i = 1 to mc_bases do
63180: LD_ADDR_VAR 0 2
63184: PUSH
63185: DOUBLE
63186: LD_INT 1
63188: DEC
63189: ST_TO_ADDR
63190: LD_EXP 43
63194: PUSH
63195: FOR_TO
63196: IFFALSE 63782
// begin if not mc_bases [ i ] then
63198: LD_EXP 43
63202: PUSH
63203: LD_VAR 0 2
63207: ARRAY
63208: NOT
63209: IFFALSE 63213
// continue ;
63211: GO 63195
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
63213: LD_ADDR_VAR 0 7
63217: PUSH
63218: LD_EXP 43
63222: PUSH
63223: LD_VAR 0 2
63227: ARRAY
63228: PUSH
63229: LD_INT 1
63231: ARRAY
63232: PPUSH
63233: CALL 11633 0 1
63237: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
63238: LD_ADDR_EXP 66
63242: PUSH
63243: LD_EXP 66
63247: PPUSH
63248: LD_VAR 0 2
63252: PPUSH
63253: LD_EXP 43
63257: PUSH
63258: LD_VAR 0 2
63262: ARRAY
63263: PUSH
63264: LD_INT 1
63266: ARRAY
63267: PPUSH
63268: CALL_OW 255
63272: PPUSH
63273: LD_EXP 68
63277: PUSH
63278: LD_VAR 0 2
63282: ARRAY
63283: PPUSH
63284: CALL 11598 0 2
63288: PPUSH
63289: CALL_OW 1
63293: ST_TO_ADDR
// if not mc_scan [ i ] then
63294: LD_EXP 66
63298: PUSH
63299: LD_VAR 0 2
63303: ARRAY
63304: NOT
63305: IFFALSE 63460
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63307: LD_ADDR_VAR 0 4
63311: PUSH
63312: LD_EXP 43
63316: PUSH
63317: LD_VAR 0 2
63321: ARRAY
63322: PPUSH
63323: LD_INT 2
63325: PUSH
63326: LD_INT 25
63328: PUSH
63329: LD_INT 5
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 25
63338: PUSH
63339: LD_INT 8
63341: PUSH
63342: EMPTY
63343: LIST
63344: LIST
63345: PUSH
63346: LD_INT 25
63348: PUSH
63349: LD_INT 9
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: PPUSH
63362: CALL_OW 72
63366: ST_TO_ADDR
// if not tmp then
63367: LD_VAR 0 4
63371: NOT
63372: IFFALSE 63376
// continue ;
63374: GO 63195
// for j in tmp do
63376: LD_ADDR_VAR 0 3
63380: PUSH
63381: LD_VAR 0 4
63385: PUSH
63386: FOR_IN
63387: IFFALSE 63458
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
63389: LD_VAR 0 3
63393: PPUSH
63394: CALL_OW 310
63398: PPUSH
63399: CALL_OW 266
63403: PUSH
63404: LD_INT 5
63406: EQUAL
63407: PUSH
63408: LD_VAR 0 3
63412: PPUSH
63413: CALL_OW 257
63417: PUSH
63418: LD_INT 1
63420: EQUAL
63421: AND
63422: PUSH
63423: LD_VAR 0 3
63427: PPUSH
63428: CALL_OW 459
63432: NOT
63433: AND
63434: PUSH
63435: LD_VAR 0 7
63439: AND
63440: IFFALSE 63456
// ComChangeProfession ( j , class ) ;
63442: LD_VAR 0 3
63446: PPUSH
63447: LD_VAR 0 7
63451: PPUSH
63452: CALL_OW 123
63456: GO 63386
63458: POP
63459: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
63460: LD_EXP 66
63464: PUSH
63465: LD_VAR 0 2
63469: ARRAY
63470: PUSH
63471: LD_EXP 65
63475: PUSH
63476: LD_VAR 0 2
63480: ARRAY
63481: NOT
63482: AND
63483: PUSH
63484: LD_EXP 43
63488: PUSH
63489: LD_VAR 0 2
63493: ARRAY
63494: PPUSH
63495: LD_INT 30
63497: PUSH
63498: LD_INT 32
63500: PUSH
63501: EMPTY
63502: LIST
63503: LIST
63504: PPUSH
63505: CALL_OW 72
63509: NOT
63510: AND
63511: PUSH
63512: LD_EXP 43
63516: PUSH
63517: LD_VAR 0 2
63521: ARRAY
63522: PPUSH
63523: LD_INT 2
63525: PUSH
63526: LD_INT 30
63528: PUSH
63529: LD_INT 4
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 30
63538: PUSH
63539: LD_INT 5
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: LIST
63550: PPUSH
63551: CALL_OW 72
63555: NOT
63556: AND
63557: IFFALSE 63689
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63559: LD_ADDR_VAR 0 4
63563: PUSH
63564: LD_EXP 43
63568: PUSH
63569: LD_VAR 0 2
63573: ARRAY
63574: PPUSH
63575: LD_INT 2
63577: PUSH
63578: LD_INT 25
63580: PUSH
63581: LD_INT 1
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PUSH
63588: LD_INT 25
63590: PUSH
63591: LD_INT 5
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 25
63600: PUSH
63601: LD_INT 8
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PUSH
63608: LD_INT 25
63610: PUSH
63611: LD_INT 9
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: PPUSH
63625: CALL_OW 72
63629: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63630: LD_ADDR_VAR 0 4
63634: PUSH
63635: LD_VAR 0 4
63639: PUSH
63640: LD_VAR 0 4
63644: PPUSH
63645: LD_INT 18
63647: PPUSH
63648: CALL 43691 0 2
63652: DIFF
63653: ST_TO_ADDR
// if tmp then
63654: LD_VAR 0 4
63658: IFFALSE 63689
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63660: LD_VAR 0 2
63664: PPUSH
63665: LD_VAR 0 4
63669: PPUSH
63670: LD_EXP 68
63674: PUSH
63675: LD_VAR 0 2
63679: ARRAY
63680: PPUSH
63681: CALL 82471 0 3
// exit ;
63685: POP
63686: POP
63687: GO 63784
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
63689: LD_EXP 66
63693: PUSH
63694: LD_VAR 0 2
63698: ARRAY
63699: PUSH
63700: LD_EXP 65
63704: PUSH
63705: LD_VAR 0 2
63709: ARRAY
63710: AND
63711: IFFALSE 63780
// begin tmp := mc_defender [ i ] ;
63713: LD_ADDR_VAR 0 4
63717: PUSH
63718: LD_EXP 65
63722: PUSH
63723: LD_VAR 0 2
63727: ARRAY
63728: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63729: LD_ADDR_EXP 65
63733: PUSH
63734: LD_EXP 65
63738: PPUSH
63739: LD_VAR 0 2
63743: PPUSH
63744: EMPTY
63745: PPUSH
63746: CALL_OW 1
63750: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63751: LD_VAR 0 2
63755: PPUSH
63756: LD_VAR 0 4
63760: PPUSH
63761: LD_EXP 66
63765: PUSH
63766: LD_VAR 0 2
63770: ARRAY
63771: PPUSH
63772: CALL 83032 0 3
// exit ;
63776: POP
63777: POP
63778: GO 63784
// end ; end ;
63780: GO 63195
63782: POP
63783: POP
// end ;
63784: LD_VAR 0 1
63788: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63789: LD_INT 0
63791: PPUSH
63792: PPUSH
63793: PPUSH
63794: PPUSH
63795: PPUSH
63796: PPUSH
63797: PPUSH
63798: PPUSH
63799: PPUSH
63800: PPUSH
63801: PPUSH
// if not mc_bases then
63802: LD_EXP 43
63806: NOT
63807: IFFALSE 63811
// exit ;
63809: GO 64898
// for i = 1 to mc_bases do
63811: LD_ADDR_VAR 0 2
63815: PUSH
63816: DOUBLE
63817: LD_INT 1
63819: DEC
63820: ST_TO_ADDR
63821: LD_EXP 43
63825: PUSH
63826: FOR_TO
63827: IFFALSE 64896
// begin tmp := mc_lab [ i ] ;
63829: LD_ADDR_VAR 0 6
63833: PUSH
63834: LD_EXP 76
63838: PUSH
63839: LD_VAR 0 2
63843: ARRAY
63844: ST_TO_ADDR
// if not tmp then
63845: LD_VAR 0 6
63849: NOT
63850: IFFALSE 63854
// continue ;
63852: GO 63826
// idle_lab := 0 ;
63854: LD_ADDR_VAR 0 11
63858: PUSH
63859: LD_INT 0
63861: ST_TO_ADDR
// for j in tmp do
63862: LD_ADDR_VAR 0 3
63866: PUSH
63867: LD_VAR 0 6
63871: PUSH
63872: FOR_IN
63873: IFFALSE 64892
// begin researching := false ;
63875: LD_ADDR_VAR 0 10
63879: PUSH
63880: LD_INT 0
63882: ST_TO_ADDR
// side := GetSide ( j ) ;
63883: LD_ADDR_VAR 0 4
63887: PUSH
63888: LD_VAR 0 3
63892: PPUSH
63893: CALL_OW 255
63897: ST_TO_ADDR
// if not mc_tech [ side ] then
63898: LD_EXP 70
63902: PUSH
63903: LD_VAR 0 4
63907: ARRAY
63908: NOT
63909: IFFALSE 63913
// continue ;
63911: GO 63872
// if BuildingStatus ( j ) = bs_idle then
63913: LD_VAR 0 3
63917: PPUSH
63918: CALL_OW 461
63922: PUSH
63923: LD_INT 2
63925: EQUAL
63926: IFFALSE 64114
// begin if idle_lab and UnitsInside ( j ) < 6 then
63928: LD_VAR 0 11
63932: PUSH
63933: LD_VAR 0 3
63937: PPUSH
63938: CALL_OW 313
63942: PUSH
63943: LD_INT 6
63945: LESS
63946: AND
63947: IFFALSE 64018
// begin tmp2 := UnitsInside ( idle_lab ) ;
63949: LD_ADDR_VAR 0 9
63953: PUSH
63954: LD_VAR 0 11
63958: PPUSH
63959: CALL_OW 313
63963: ST_TO_ADDR
// if tmp2 then
63964: LD_VAR 0 9
63968: IFFALSE 64010
// for x in tmp2 do
63970: LD_ADDR_VAR 0 7
63974: PUSH
63975: LD_VAR 0 9
63979: PUSH
63980: FOR_IN
63981: IFFALSE 64008
// begin ComExitBuilding ( x ) ;
63983: LD_VAR 0 7
63987: PPUSH
63988: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63992: LD_VAR 0 7
63996: PPUSH
63997: LD_VAR 0 3
64001: PPUSH
64002: CALL_OW 180
// end ;
64006: GO 63980
64008: POP
64009: POP
// idle_lab := 0 ;
64010: LD_ADDR_VAR 0 11
64014: PUSH
64015: LD_INT 0
64017: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
64018: LD_ADDR_VAR 0 5
64022: PUSH
64023: LD_EXP 70
64027: PUSH
64028: LD_VAR 0 4
64032: ARRAY
64033: PUSH
64034: FOR_IN
64035: IFFALSE 64095
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
64037: LD_VAR 0 3
64041: PPUSH
64042: LD_VAR 0 5
64046: PPUSH
64047: CALL_OW 430
64051: PUSH
64052: LD_VAR 0 4
64056: PPUSH
64057: LD_VAR 0 5
64061: PPUSH
64062: CALL 10703 0 2
64066: AND
64067: IFFALSE 64093
// begin researching := true ;
64069: LD_ADDR_VAR 0 10
64073: PUSH
64074: LD_INT 1
64076: ST_TO_ADDR
// ComResearch ( j , t ) ;
64077: LD_VAR 0 3
64081: PPUSH
64082: LD_VAR 0 5
64086: PPUSH
64087: CALL_OW 124
// break ;
64091: GO 64095
// end ;
64093: GO 64034
64095: POP
64096: POP
// if not researching then
64097: LD_VAR 0 10
64101: NOT
64102: IFFALSE 64114
// idle_lab := j ;
64104: LD_ADDR_VAR 0 11
64108: PUSH
64109: LD_VAR 0 3
64113: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
64114: LD_VAR 0 3
64118: PPUSH
64119: CALL_OW 461
64123: PUSH
64124: LD_INT 10
64126: EQUAL
64127: IFFALSE 64715
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
64129: LD_EXP 72
64133: PUSH
64134: LD_VAR 0 2
64138: ARRAY
64139: NOT
64140: PUSH
64141: LD_EXP 73
64145: PUSH
64146: LD_VAR 0 2
64150: ARRAY
64151: NOT
64152: AND
64153: PUSH
64154: LD_EXP 70
64158: PUSH
64159: LD_VAR 0 4
64163: ARRAY
64164: PUSH
64165: LD_INT 1
64167: GREATER
64168: AND
64169: IFFALSE 64300
// begin ComCancel ( j ) ;
64171: LD_VAR 0 3
64175: PPUSH
64176: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
64180: LD_ADDR_EXP 70
64184: PUSH
64185: LD_EXP 70
64189: PPUSH
64190: LD_VAR 0 4
64194: PPUSH
64195: LD_EXP 70
64199: PUSH
64200: LD_VAR 0 4
64204: ARRAY
64205: PPUSH
64206: LD_EXP 70
64210: PUSH
64211: LD_VAR 0 4
64215: ARRAY
64216: PUSH
64217: LD_INT 1
64219: MINUS
64220: PPUSH
64221: LD_EXP 70
64225: PUSH
64226: LD_VAR 0 4
64230: ARRAY
64231: PPUSH
64232: LD_INT 0
64234: PPUSH
64235: CALL 14215 0 4
64239: PPUSH
64240: CALL_OW 1
64244: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
64245: LD_ADDR_EXP 70
64249: PUSH
64250: LD_EXP 70
64254: PPUSH
64255: LD_VAR 0 4
64259: PPUSH
64260: LD_EXP 70
64264: PUSH
64265: LD_VAR 0 4
64269: ARRAY
64270: PPUSH
64271: LD_EXP 70
64275: PUSH
64276: LD_VAR 0 4
64280: ARRAY
64281: PPUSH
64282: LD_INT 1
64284: PPUSH
64285: LD_INT 0
64287: PPUSH
64288: CALL 14215 0 4
64292: PPUSH
64293: CALL_OW 1
64297: ST_TO_ADDR
// continue ;
64298: GO 63872
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
64300: LD_EXP 72
64304: PUSH
64305: LD_VAR 0 2
64309: ARRAY
64310: PUSH
64311: LD_EXP 73
64315: PUSH
64316: LD_VAR 0 2
64320: ARRAY
64321: NOT
64322: AND
64323: IFFALSE 64450
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
64325: LD_ADDR_EXP 73
64329: PUSH
64330: LD_EXP 73
64334: PPUSH
64335: LD_VAR 0 2
64339: PUSH
64340: LD_EXP 73
64344: PUSH
64345: LD_VAR 0 2
64349: ARRAY
64350: PUSH
64351: LD_INT 1
64353: PLUS
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PPUSH
64359: LD_EXP 72
64363: PUSH
64364: LD_VAR 0 2
64368: ARRAY
64369: PUSH
64370: LD_INT 1
64372: ARRAY
64373: PPUSH
64374: CALL 14797 0 3
64378: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
64379: LD_EXP 72
64383: PUSH
64384: LD_VAR 0 2
64388: ARRAY
64389: PUSH
64390: LD_INT 1
64392: ARRAY
64393: PPUSH
64394: LD_INT 112
64396: PPUSH
64397: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
64401: LD_ADDR_VAR 0 9
64405: PUSH
64406: LD_EXP 72
64410: PUSH
64411: LD_VAR 0 2
64415: ARRAY
64416: PPUSH
64417: LD_INT 1
64419: PPUSH
64420: CALL_OW 3
64424: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
64425: LD_ADDR_EXP 72
64429: PUSH
64430: LD_EXP 72
64434: PPUSH
64435: LD_VAR 0 2
64439: PPUSH
64440: LD_VAR 0 9
64444: PPUSH
64445: CALL_OW 1
64449: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
64450: LD_EXP 72
64454: PUSH
64455: LD_VAR 0 2
64459: ARRAY
64460: PUSH
64461: LD_EXP 73
64465: PUSH
64466: LD_VAR 0 2
64470: ARRAY
64471: AND
64472: PUSH
64473: LD_EXP 73
64477: PUSH
64478: LD_VAR 0 2
64482: ARRAY
64483: PUSH
64484: LD_INT 1
64486: ARRAY
64487: PPUSH
64488: CALL_OW 310
64492: NOT
64493: AND
64494: PUSH
64495: LD_VAR 0 3
64499: PPUSH
64500: CALL_OW 313
64504: PUSH
64505: LD_INT 6
64507: EQUAL
64508: AND
64509: IFFALSE 64565
// begin tmp2 := UnitsInside ( j ) ;
64511: LD_ADDR_VAR 0 9
64515: PUSH
64516: LD_VAR 0 3
64520: PPUSH
64521: CALL_OW 313
64525: ST_TO_ADDR
// if tmp2 = 6 then
64526: LD_VAR 0 9
64530: PUSH
64531: LD_INT 6
64533: EQUAL
64534: IFFALSE 64565
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64536: LD_VAR 0 9
64540: PUSH
64541: LD_INT 1
64543: ARRAY
64544: PPUSH
64545: LD_INT 112
64547: PPUSH
64548: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64552: LD_VAR 0 9
64556: PUSH
64557: LD_INT 1
64559: ARRAY
64560: PPUSH
64561: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64565: LD_EXP 73
64569: PUSH
64570: LD_VAR 0 2
64574: ARRAY
64575: PUSH
64576: LD_EXP 73
64580: PUSH
64581: LD_VAR 0 2
64585: ARRAY
64586: PUSH
64587: LD_INT 1
64589: ARRAY
64590: PPUSH
64591: CALL_OW 314
64595: NOT
64596: AND
64597: PUSH
64598: LD_EXP 73
64602: PUSH
64603: LD_VAR 0 2
64607: ARRAY
64608: PUSH
64609: LD_INT 1
64611: ARRAY
64612: PPUSH
64613: CALL_OW 310
64617: NOT
64618: AND
64619: IFFALSE 64645
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64621: LD_EXP 73
64625: PUSH
64626: LD_VAR 0 2
64630: ARRAY
64631: PUSH
64632: LD_INT 1
64634: ARRAY
64635: PPUSH
64636: LD_VAR 0 3
64640: PPUSH
64641: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64645: LD_EXP 73
64649: PUSH
64650: LD_VAR 0 2
64654: ARRAY
64655: PUSH
64656: LD_INT 1
64658: ARRAY
64659: PPUSH
64660: CALL_OW 310
64664: PUSH
64665: LD_EXP 73
64669: PUSH
64670: LD_VAR 0 2
64674: ARRAY
64675: PUSH
64676: LD_INT 1
64678: ARRAY
64679: PPUSH
64680: CALL_OW 310
64684: PPUSH
64685: CALL_OW 461
64689: PUSH
64690: LD_INT 3
64692: NONEQUAL
64693: AND
64694: IFFALSE 64715
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64696: LD_EXP 73
64700: PUSH
64701: LD_VAR 0 2
64705: ARRAY
64706: PUSH
64707: LD_INT 1
64709: ARRAY
64710: PPUSH
64711: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64715: LD_VAR 0 3
64719: PPUSH
64720: CALL_OW 461
64724: PUSH
64725: LD_INT 6
64727: EQUAL
64728: PUSH
64729: LD_VAR 0 6
64733: PUSH
64734: LD_INT 1
64736: GREATER
64737: AND
64738: IFFALSE 64890
// begin sci := [ ] ;
64740: LD_ADDR_VAR 0 8
64744: PUSH
64745: EMPTY
64746: ST_TO_ADDR
// for x in ( tmp diff j ) do
64747: LD_ADDR_VAR 0 7
64751: PUSH
64752: LD_VAR 0 6
64756: PUSH
64757: LD_VAR 0 3
64761: DIFF
64762: PUSH
64763: FOR_IN
64764: IFFALSE 64816
// begin if sci = 6 then
64766: LD_VAR 0 8
64770: PUSH
64771: LD_INT 6
64773: EQUAL
64774: IFFALSE 64778
// break ;
64776: GO 64816
// if BuildingStatus ( x ) = bs_idle then
64778: LD_VAR 0 7
64782: PPUSH
64783: CALL_OW 461
64787: PUSH
64788: LD_INT 2
64790: EQUAL
64791: IFFALSE 64814
// sci := sci ^ UnitsInside ( x ) ;
64793: LD_ADDR_VAR 0 8
64797: PUSH
64798: LD_VAR 0 8
64802: PUSH
64803: LD_VAR 0 7
64807: PPUSH
64808: CALL_OW 313
64812: ADD
64813: ST_TO_ADDR
// end ;
64814: GO 64763
64816: POP
64817: POP
// if not sci then
64818: LD_VAR 0 8
64822: NOT
64823: IFFALSE 64827
// continue ;
64825: GO 63872
// for x in sci do
64827: LD_ADDR_VAR 0 7
64831: PUSH
64832: LD_VAR 0 8
64836: PUSH
64837: FOR_IN
64838: IFFALSE 64888
// if IsInUnit ( x ) and not HasTask ( x ) then
64840: LD_VAR 0 7
64844: PPUSH
64845: CALL_OW 310
64849: PUSH
64850: LD_VAR 0 7
64854: PPUSH
64855: CALL_OW 314
64859: NOT
64860: AND
64861: IFFALSE 64886
// begin ComExitBuilding ( x ) ;
64863: LD_VAR 0 7
64867: PPUSH
64868: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64872: LD_VAR 0 7
64876: PPUSH
64877: LD_VAR 0 3
64881: PPUSH
64882: CALL_OW 180
// end ;
64886: GO 64837
64888: POP
64889: POP
// end ; end ;
64890: GO 63872
64892: POP
64893: POP
// end ;
64894: GO 63826
64896: POP
64897: POP
// end ;
64898: LD_VAR 0 1
64902: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64903: LD_INT 0
64905: PPUSH
64906: PPUSH
// if not mc_bases then
64907: LD_EXP 43
64911: NOT
64912: IFFALSE 64916
// exit ;
64914: GO 64997
// for i = 1 to mc_bases do
64916: LD_ADDR_VAR 0 2
64920: PUSH
64921: DOUBLE
64922: LD_INT 1
64924: DEC
64925: ST_TO_ADDR
64926: LD_EXP 43
64930: PUSH
64931: FOR_TO
64932: IFFALSE 64995
// if mc_mines [ i ] and mc_miners [ i ] then
64934: LD_EXP 56
64938: PUSH
64939: LD_VAR 0 2
64943: ARRAY
64944: PUSH
64945: LD_EXP 57
64949: PUSH
64950: LD_VAR 0 2
64954: ARRAY
64955: AND
64956: IFFALSE 64993
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64958: LD_EXP 57
64962: PUSH
64963: LD_VAR 0 2
64967: ARRAY
64968: PUSH
64969: LD_INT 1
64971: ARRAY
64972: PPUSH
64973: CALL_OW 255
64977: PPUSH
64978: LD_EXP 56
64982: PUSH
64983: LD_VAR 0 2
64987: ARRAY
64988: PPUSH
64989: CALL 11786 0 2
64993: GO 64931
64995: POP
64996: POP
// end ;
64997: LD_VAR 0 1
65001: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
65002: LD_INT 0
65004: PPUSH
65005: PPUSH
65006: PPUSH
65007: PPUSH
65008: PPUSH
65009: PPUSH
65010: PPUSH
65011: PPUSH
// if not mc_bases or not mc_parking then
65012: LD_EXP 43
65016: NOT
65017: PUSH
65018: LD_EXP 67
65022: NOT
65023: OR
65024: IFFALSE 65028
// exit ;
65026: GO 65727
// for i = 1 to mc_bases do
65028: LD_ADDR_VAR 0 2
65032: PUSH
65033: DOUBLE
65034: LD_INT 1
65036: DEC
65037: ST_TO_ADDR
65038: LD_EXP 43
65042: PUSH
65043: FOR_TO
65044: IFFALSE 65725
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
65046: LD_EXP 43
65050: PUSH
65051: LD_VAR 0 2
65055: ARRAY
65056: NOT
65057: PUSH
65058: LD_EXP 67
65062: PUSH
65063: LD_VAR 0 2
65067: ARRAY
65068: NOT
65069: OR
65070: IFFALSE 65074
// continue ;
65072: GO 65043
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65074: LD_ADDR_VAR 0 5
65078: PUSH
65079: LD_EXP 43
65083: PUSH
65084: LD_VAR 0 2
65088: ARRAY
65089: PUSH
65090: LD_INT 1
65092: ARRAY
65093: PPUSH
65094: CALL_OW 255
65098: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65099: LD_ADDR_VAR 0 6
65103: PUSH
65104: LD_EXP 43
65108: PUSH
65109: LD_VAR 0 2
65113: ARRAY
65114: PPUSH
65115: LD_INT 30
65117: PUSH
65118: LD_INT 3
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PPUSH
65125: CALL_OW 72
65129: ST_TO_ADDR
// if not fac then
65130: LD_VAR 0 6
65134: NOT
65135: IFFALSE 65186
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65137: LD_ADDR_VAR 0 6
65141: PUSH
65142: LD_EXP 43
65146: PUSH
65147: LD_VAR 0 2
65151: ARRAY
65152: PPUSH
65153: LD_INT 2
65155: PUSH
65156: LD_INT 30
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 30
65168: PUSH
65169: LD_INT 1
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: LIST
65180: PPUSH
65181: CALL_OW 72
65185: ST_TO_ADDR
// if not fac then
65186: LD_VAR 0 6
65190: NOT
65191: IFFALSE 65195
// continue ;
65193: GO 65043
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65195: LD_ADDR_VAR 0 7
65199: PUSH
65200: LD_EXP 67
65204: PUSH
65205: LD_VAR 0 2
65209: ARRAY
65210: PPUSH
65211: LD_INT 22
65213: PUSH
65214: LD_VAR 0 5
65218: PUSH
65219: EMPTY
65220: LIST
65221: LIST
65222: PUSH
65223: LD_INT 21
65225: PUSH
65226: LD_INT 2
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 3
65235: PUSH
65236: LD_INT 24
65238: PUSH
65239: LD_INT 1000
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: LIST
65254: PPUSH
65255: CALL_OW 70
65259: ST_TO_ADDR
// for j in fac do
65260: LD_ADDR_VAR 0 3
65264: PUSH
65265: LD_VAR 0 6
65269: PUSH
65270: FOR_IN
65271: IFFALSE 65352
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65273: LD_ADDR_VAR 0 7
65277: PUSH
65278: LD_VAR 0 7
65282: PUSH
65283: LD_INT 22
65285: PUSH
65286: LD_VAR 0 5
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: LD_INT 91
65297: PUSH
65298: LD_VAR 0 3
65302: PUSH
65303: LD_INT 15
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 21
65313: PUSH
65314: LD_INT 2
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 3
65323: PUSH
65324: LD_INT 24
65326: PUSH
65327: LD_INT 1000
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: PPUSH
65344: CALL_OW 69
65348: UNION
65349: ST_TO_ADDR
65350: GO 65270
65352: POP
65353: POP
// if not vehs then
65354: LD_VAR 0 7
65358: NOT
65359: IFFALSE 65385
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65361: LD_ADDR_EXP 55
65365: PUSH
65366: LD_EXP 55
65370: PPUSH
65371: LD_VAR 0 2
65375: PPUSH
65376: EMPTY
65377: PPUSH
65378: CALL_OW 1
65382: ST_TO_ADDR
// continue ;
65383: GO 65043
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65385: LD_ADDR_VAR 0 8
65389: PUSH
65390: LD_EXP 43
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: PPUSH
65401: LD_INT 30
65403: PUSH
65404: LD_INT 3
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PPUSH
65411: CALL_OW 72
65415: ST_TO_ADDR
// if tmp then
65416: LD_VAR 0 8
65420: IFFALSE 65523
// begin for j in tmp do
65422: LD_ADDR_VAR 0 3
65426: PUSH
65427: LD_VAR 0 8
65431: PUSH
65432: FOR_IN
65433: IFFALSE 65521
// for k in UnitsInside ( j ) do
65435: LD_ADDR_VAR 0 4
65439: PUSH
65440: LD_VAR 0 3
65444: PPUSH
65445: CALL_OW 313
65449: PUSH
65450: FOR_IN
65451: IFFALSE 65517
// if k then
65453: LD_VAR 0 4
65457: IFFALSE 65515
// if not k in mc_repair_vehicle [ i ] then
65459: LD_VAR 0 4
65463: PUSH
65464: LD_EXP 55
65468: PUSH
65469: LD_VAR 0 2
65473: ARRAY
65474: IN
65475: NOT
65476: IFFALSE 65515
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65478: LD_ADDR_EXP 55
65482: PUSH
65483: LD_EXP 55
65487: PPUSH
65488: LD_VAR 0 2
65492: PPUSH
65493: LD_EXP 55
65497: PUSH
65498: LD_VAR 0 2
65502: ARRAY
65503: PUSH
65504: LD_VAR 0 4
65508: UNION
65509: PPUSH
65510: CALL_OW 1
65514: ST_TO_ADDR
65515: GO 65450
65517: POP
65518: POP
65519: GO 65432
65521: POP
65522: POP
// end ; if not mc_repair_vehicle [ i ] then
65523: LD_EXP 55
65527: PUSH
65528: LD_VAR 0 2
65532: ARRAY
65533: NOT
65534: IFFALSE 65538
// continue ;
65536: GO 65043
// for j in mc_repair_vehicle [ i ] do
65538: LD_ADDR_VAR 0 3
65542: PUSH
65543: LD_EXP 55
65547: PUSH
65548: LD_VAR 0 2
65552: ARRAY
65553: PUSH
65554: FOR_IN
65555: IFFALSE 65721
// begin if GetClass ( j ) <> 3 then
65557: LD_VAR 0 3
65561: PPUSH
65562: CALL_OW 257
65566: PUSH
65567: LD_INT 3
65569: NONEQUAL
65570: IFFALSE 65611
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65572: LD_ADDR_EXP 55
65576: PUSH
65577: LD_EXP 55
65581: PPUSH
65582: LD_VAR 0 2
65586: PPUSH
65587: LD_EXP 55
65591: PUSH
65592: LD_VAR 0 2
65596: ARRAY
65597: PUSH
65598: LD_VAR 0 3
65602: DIFF
65603: PPUSH
65604: CALL_OW 1
65608: ST_TO_ADDR
// continue ;
65609: GO 65554
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65611: LD_VAR 0 3
65615: PPUSH
65616: CALL_OW 311
65620: NOT
65621: PUSH
65622: LD_VAR 0 3
65626: PUSH
65627: LD_EXP 46
65631: PUSH
65632: LD_VAR 0 2
65636: ARRAY
65637: PUSH
65638: LD_INT 1
65640: ARRAY
65641: IN
65642: NOT
65643: AND
65644: PUSH
65645: LD_VAR 0 3
65649: PUSH
65650: LD_EXP 46
65654: PUSH
65655: LD_VAR 0 2
65659: ARRAY
65660: PUSH
65661: LD_INT 2
65663: ARRAY
65664: IN
65665: NOT
65666: AND
65667: IFFALSE 65719
// begin if IsInUnit ( j ) then
65669: LD_VAR 0 3
65673: PPUSH
65674: CALL_OW 310
65678: IFFALSE 65689
// ComExitBuilding ( j ) ;
65680: LD_VAR 0 3
65684: PPUSH
65685: CALL_OW 122
// if not HasTask ( j ) then
65689: LD_VAR 0 3
65693: PPUSH
65694: CALL_OW 314
65698: NOT
65699: IFFALSE 65719
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65701: LD_VAR 0 3
65705: PPUSH
65706: LD_VAR 0 7
65710: PUSH
65711: LD_INT 1
65713: ARRAY
65714: PPUSH
65715: CALL_OW 189
// end ; end ;
65719: GO 65554
65721: POP
65722: POP
// end ;
65723: GO 65043
65725: POP
65726: POP
// end ;
65727: LD_VAR 0 1
65731: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65732: LD_INT 0
65734: PPUSH
65735: PPUSH
65736: PPUSH
65737: PPUSH
65738: PPUSH
65739: PPUSH
65740: PPUSH
65741: PPUSH
65742: PPUSH
65743: PPUSH
65744: PPUSH
// if not mc_bases then
65745: LD_EXP 43
65749: NOT
65750: IFFALSE 65754
// exit ;
65752: GO 66556
// for i = 1 to mc_bases do
65754: LD_ADDR_VAR 0 2
65758: PUSH
65759: DOUBLE
65760: LD_INT 1
65762: DEC
65763: ST_TO_ADDR
65764: LD_EXP 43
65768: PUSH
65769: FOR_TO
65770: IFFALSE 66554
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65772: LD_EXP 71
65776: PUSH
65777: LD_VAR 0 2
65781: ARRAY
65782: NOT
65783: PUSH
65784: LD_EXP 46
65788: PUSH
65789: LD_VAR 0 2
65793: ARRAY
65794: PUSH
65795: LD_INT 1
65797: ARRAY
65798: OR
65799: PUSH
65800: LD_EXP 46
65804: PUSH
65805: LD_VAR 0 2
65809: ARRAY
65810: PUSH
65811: LD_INT 2
65813: ARRAY
65814: OR
65815: PUSH
65816: LD_EXP 69
65820: PUSH
65821: LD_VAR 0 2
65825: ARRAY
65826: PPUSH
65827: LD_INT 1
65829: PPUSH
65830: CALL_OW 325
65834: NOT
65835: OR
65836: PUSH
65837: LD_EXP 66
65841: PUSH
65842: LD_VAR 0 2
65846: ARRAY
65847: OR
65848: IFFALSE 65852
// continue ;
65850: GO 65769
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65852: LD_ADDR_VAR 0 8
65856: PUSH
65857: LD_EXP 43
65861: PUSH
65862: LD_VAR 0 2
65866: ARRAY
65867: PPUSH
65868: LD_INT 25
65870: PUSH
65871: LD_INT 4
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 50
65880: PUSH
65881: EMPTY
65882: LIST
65883: PUSH
65884: LD_INT 3
65886: PUSH
65887: LD_INT 60
65889: PUSH
65890: EMPTY
65891: LIST
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: LIST
65901: PPUSH
65902: CALL_OW 72
65906: PUSH
65907: LD_EXP 47
65911: PUSH
65912: LD_VAR 0 2
65916: ARRAY
65917: DIFF
65918: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65919: LD_ADDR_VAR 0 9
65923: PUSH
65924: LD_EXP 43
65928: PUSH
65929: LD_VAR 0 2
65933: ARRAY
65934: PPUSH
65935: LD_INT 2
65937: PUSH
65938: LD_INT 30
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 30
65950: PUSH
65951: LD_INT 1
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: LIST
65962: PPUSH
65963: CALL_OW 72
65967: ST_TO_ADDR
// if not tmp or not dep then
65968: LD_VAR 0 8
65972: NOT
65973: PUSH
65974: LD_VAR 0 9
65978: NOT
65979: OR
65980: IFFALSE 65984
// continue ;
65982: GO 65769
// side := GetSide ( tmp [ 1 ] ) ;
65984: LD_ADDR_VAR 0 11
65988: PUSH
65989: LD_VAR 0 8
65993: PUSH
65994: LD_INT 1
65996: ARRAY
65997: PPUSH
65998: CALL_OW 255
66002: ST_TO_ADDR
// dep := dep [ 1 ] ;
66003: LD_ADDR_VAR 0 9
66007: PUSH
66008: LD_VAR 0 9
66012: PUSH
66013: LD_INT 1
66015: ARRAY
66016: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
66017: LD_ADDR_VAR 0 7
66021: PUSH
66022: LD_EXP 71
66026: PUSH
66027: LD_VAR 0 2
66031: ARRAY
66032: PPUSH
66033: LD_INT 22
66035: PUSH
66036: LD_INT 0
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: LD_INT 25
66045: PUSH
66046: LD_INT 12
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PPUSH
66057: CALL_OW 70
66061: PUSH
66062: LD_INT 22
66064: PUSH
66065: LD_INT 0
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 25
66074: PUSH
66075: LD_INT 12
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 91
66084: PUSH
66085: LD_VAR 0 9
66089: PUSH
66090: LD_INT 20
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: LIST
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: LIST
66102: PPUSH
66103: CALL_OW 69
66107: UNION
66108: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
66109: LD_ADDR_VAR 0 10
66113: PUSH
66114: LD_EXP 71
66118: PUSH
66119: LD_VAR 0 2
66123: ARRAY
66124: PPUSH
66125: LD_INT 81
66127: PUSH
66128: LD_VAR 0 11
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PPUSH
66137: CALL_OW 70
66141: ST_TO_ADDR
// if not apes or danger_at_area then
66142: LD_VAR 0 7
66146: NOT
66147: PUSH
66148: LD_VAR 0 10
66152: OR
66153: IFFALSE 66203
// begin if mc_taming [ i ] then
66155: LD_EXP 74
66159: PUSH
66160: LD_VAR 0 2
66164: ARRAY
66165: IFFALSE 66201
// begin MC_Reset ( i , 121 ) ;
66167: LD_VAR 0 2
66171: PPUSH
66172: LD_INT 121
66174: PPUSH
66175: CALL 51585 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66179: LD_ADDR_EXP 74
66183: PUSH
66184: LD_EXP 74
66188: PPUSH
66189: LD_VAR 0 2
66193: PPUSH
66194: EMPTY
66195: PPUSH
66196: CALL_OW 1
66200: ST_TO_ADDR
// end ; continue ;
66201: GO 65769
// end ; for j in tmp do
66203: LD_ADDR_VAR 0 3
66207: PUSH
66208: LD_VAR 0 8
66212: PUSH
66213: FOR_IN
66214: IFFALSE 66550
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
66216: LD_VAR 0 3
66220: PUSH
66221: LD_EXP 74
66225: PUSH
66226: LD_VAR 0 2
66230: ARRAY
66231: IN
66232: NOT
66233: PUSH
66234: LD_EXP 74
66238: PUSH
66239: LD_VAR 0 2
66243: ARRAY
66244: PUSH
66245: LD_INT 3
66247: LESS
66248: AND
66249: IFFALSE 66307
// begin SetTag ( j , 121 ) ;
66251: LD_VAR 0 3
66255: PPUSH
66256: LD_INT 121
66258: PPUSH
66259: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
66263: LD_ADDR_EXP 74
66267: PUSH
66268: LD_EXP 74
66272: PPUSH
66273: LD_VAR 0 2
66277: PUSH
66278: LD_EXP 74
66282: PUSH
66283: LD_VAR 0 2
66287: ARRAY
66288: PUSH
66289: LD_INT 1
66291: PLUS
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PPUSH
66297: LD_VAR 0 3
66301: PPUSH
66302: CALL 14797 0 3
66306: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
66307: LD_VAR 0 3
66311: PUSH
66312: LD_EXP 74
66316: PUSH
66317: LD_VAR 0 2
66321: ARRAY
66322: IN
66323: IFFALSE 66548
// begin if GetClass ( j ) <> 4 then
66325: LD_VAR 0 3
66329: PPUSH
66330: CALL_OW 257
66334: PUSH
66335: LD_INT 4
66337: NONEQUAL
66338: IFFALSE 66391
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
66340: LD_ADDR_EXP 74
66344: PUSH
66345: LD_EXP 74
66349: PPUSH
66350: LD_VAR 0 2
66354: PPUSH
66355: LD_EXP 74
66359: PUSH
66360: LD_VAR 0 2
66364: ARRAY
66365: PUSH
66366: LD_VAR 0 3
66370: DIFF
66371: PPUSH
66372: CALL_OW 1
66376: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66377: LD_VAR 0 3
66381: PPUSH
66382: LD_INT 0
66384: PPUSH
66385: CALL_OW 109
// continue ;
66389: GO 66213
// end ; if IsInUnit ( j ) then
66391: LD_VAR 0 3
66395: PPUSH
66396: CALL_OW 310
66400: IFFALSE 66411
// ComExitBuilding ( j ) ;
66402: LD_VAR 0 3
66406: PPUSH
66407: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
66411: LD_ADDR_VAR 0 6
66415: PUSH
66416: LD_VAR 0 7
66420: PPUSH
66421: LD_VAR 0 3
66425: PPUSH
66426: CALL_OW 74
66430: ST_TO_ADDR
// if not ape then
66431: LD_VAR 0 6
66435: NOT
66436: IFFALSE 66440
// break ;
66438: GO 66550
// x := GetX ( ape ) ;
66440: LD_ADDR_VAR 0 4
66444: PUSH
66445: LD_VAR 0 6
66449: PPUSH
66450: CALL_OW 250
66454: ST_TO_ADDR
// y := GetY ( ape ) ;
66455: LD_ADDR_VAR 0 5
66459: PUSH
66460: LD_VAR 0 6
66464: PPUSH
66465: CALL_OW 251
66469: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66470: LD_VAR 0 4
66474: PPUSH
66475: LD_VAR 0 5
66479: PPUSH
66480: CALL_OW 488
66484: NOT
66485: PUSH
66486: LD_VAR 0 11
66490: PPUSH
66491: LD_VAR 0 4
66495: PPUSH
66496: LD_VAR 0 5
66500: PPUSH
66501: LD_INT 20
66503: PPUSH
66504: CALL 15693 0 4
66508: PUSH
66509: LD_INT 4
66511: ARRAY
66512: OR
66513: IFFALSE 66517
// break ;
66515: GO 66550
// if not HasTask ( j ) then
66517: LD_VAR 0 3
66521: PPUSH
66522: CALL_OW 314
66526: NOT
66527: IFFALSE 66548
// ComTameXY ( j , x , y ) ;
66529: LD_VAR 0 3
66533: PPUSH
66534: LD_VAR 0 4
66538: PPUSH
66539: LD_VAR 0 5
66543: PPUSH
66544: CALL_OW 131
// end ; end ;
66548: GO 66213
66550: POP
66551: POP
// end ;
66552: GO 65769
66554: POP
66555: POP
// end ;
66556: LD_VAR 0 1
66560: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66561: LD_INT 0
66563: PPUSH
66564: PPUSH
66565: PPUSH
66566: PPUSH
66567: PPUSH
66568: PPUSH
66569: PPUSH
66570: PPUSH
// if not mc_bases then
66571: LD_EXP 43
66575: NOT
66576: IFFALSE 66580
// exit ;
66578: GO 67206
// for i = 1 to mc_bases do
66580: LD_ADDR_VAR 0 2
66584: PUSH
66585: DOUBLE
66586: LD_INT 1
66588: DEC
66589: ST_TO_ADDR
66590: LD_EXP 43
66594: PUSH
66595: FOR_TO
66596: IFFALSE 67204
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66598: LD_EXP 72
66602: PUSH
66603: LD_VAR 0 2
66607: ARRAY
66608: NOT
66609: PUSH
66610: LD_EXP 72
66614: PUSH
66615: LD_VAR 0 2
66619: ARRAY
66620: PPUSH
66621: LD_INT 25
66623: PUSH
66624: LD_INT 12
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PPUSH
66631: CALL_OW 72
66635: NOT
66636: OR
66637: IFFALSE 66641
// continue ;
66639: GO 66595
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66641: LD_ADDR_VAR 0 5
66645: PUSH
66646: LD_EXP 72
66650: PUSH
66651: LD_VAR 0 2
66655: ARRAY
66656: PUSH
66657: LD_INT 1
66659: ARRAY
66660: PPUSH
66661: CALL_OW 255
66665: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66666: LD_VAR 0 5
66670: PPUSH
66671: LD_INT 2
66673: PPUSH
66674: CALL_OW 325
66678: IFFALSE 66931
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66680: LD_ADDR_VAR 0 4
66684: PUSH
66685: LD_EXP 72
66689: PUSH
66690: LD_VAR 0 2
66694: ARRAY
66695: PPUSH
66696: LD_INT 25
66698: PUSH
66699: LD_INT 16
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PPUSH
66706: CALL_OW 72
66710: ST_TO_ADDR
// if tmp < 6 then
66711: LD_VAR 0 4
66715: PUSH
66716: LD_INT 6
66718: LESS
66719: IFFALSE 66931
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66721: LD_ADDR_VAR 0 6
66725: PUSH
66726: LD_EXP 43
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: PPUSH
66737: LD_INT 2
66739: PUSH
66740: LD_INT 30
66742: PUSH
66743: LD_INT 0
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 30
66752: PUSH
66753: LD_INT 1
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: LIST
66764: PPUSH
66765: CALL_OW 72
66769: ST_TO_ADDR
// if depot then
66770: LD_VAR 0 6
66774: IFFALSE 66931
// begin selected := 0 ;
66776: LD_ADDR_VAR 0 7
66780: PUSH
66781: LD_INT 0
66783: ST_TO_ADDR
// for j in depot do
66784: LD_ADDR_VAR 0 3
66788: PUSH
66789: LD_VAR 0 6
66793: PUSH
66794: FOR_IN
66795: IFFALSE 66826
// begin if UnitsInside ( j ) < 6 then
66797: LD_VAR 0 3
66801: PPUSH
66802: CALL_OW 313
66806: PUSH
66807: LD_INT 6
66809: LESS
66810: IFFALSE 66824
// begin selected := j ;
66812: LD_ADDR_VAR 0 7
66816: PUSH
66817: LD_VAR 0 3
66821: ST_TO_ADDR
// break ;
66822: GO 66826
// end ; end ;
66824: GO 66794
66826: POP
66827: POP
// if selected then
66828: LD_VAR 0 7
66832: IFFALSE 66931
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66834: LD_ADDR_VAR 0 3
66838: PUSH
66839: LD_EXP 72
66843: PUSH
66844: LD_VAR 0 2
66848: ARRAY
66849: PPUSH
66850: LD_INT 25
66852: PUSH
66853: LD_INT 12
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PPUSH
66860: CALL_OW 72
66864: PUSH
66865: FOR_IN
66866: IFFALSE 66929
// if not HasTask ( j ) then
66868: LD_VAR 0 3
66872: PPUSH
66873: CALL_OW 314
66877: NOT
66878: IFFALSE 66927
// begin if not IsInUnit ( j ) then
66880: LD_VAR 0 3
66884: PPUSH
66885: CALL_OW 310
66889: NOT
66890: IFFALSE 66906
// ComEnterUnit ( j , selected ) ;
66892: LD_VAR 0 3
66896: PPUSH
66897: LD_VAR 0 7
66901: PPUSH
66902: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66906: LD_VAR 0 3
66910: PPUSH
66911: LD_INT 16
66913: PPUSH
66914: CALL_OW 183
// AddComExitBuilding ( j ) ;
66918: LD_VAR 0 3
66922: PPUSH
66923: CALL_OW 182
// end ;
66927: GO 66865
66929: POP
66930: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66931: LD_VAR 0 5
66935: PPUSH
66936: LD_INT 11
66938: PPUSH
66939: CALL_OW 325
66943: IFFALSE 67202
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66945: LD_ADDR_VAR 0 4
66949: PUSH
66950: LD_EXP 72
66954: PUSH
66955: LD_VAR 0 2
66959: ARRAY
66960: PPUSH
66961: LD_INT 25
66963: PUSH
66964: LD_INT 16
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PPUSH
66971: CALL_OW 72
66975: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66976: LD_VAR 0 4
66980: PUSH
66981: LD_INT 6
66983: GREATEREQUAL
66984: PUSH
66985: LD_VAR 0 5
66989: PPUSH
66990: LD_INT 2
66992: PPUSH
66993: CALL_OW 325
66997: NOT
66998: OR
66999: IFFALSE 67202
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67001: LD_ADDR_VAR 0 8
67005: PUSH
67006: LD_EXP 43
67010: PUSH
67011: LD_VAR 0 2
67015: ARRAY
67016: PPUSH
67017: LD_INT 2
67019: PUSH
67020: LD_INT 30
67022: PUSH
67023: LD_INT 4
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 30
67032: PUSH
67033: LD_INT 5
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: LIST
67044: PPUSH
67045: CALL_OW 72
67049: ST_TO_ADDR
// if barracks then
67050: LD_VAR 0 8
67054: IFFALSE 67202
// begin selected := 0 ;
67056: LD_ADDR_VAR 0 7
67060: PUSH
67061: LD_INT 0
67063: ST_TO_ADDR
// for j in barracks do
67064: LD_ADDR_VAR 0 3
67068: PUSH
67069: LD_VAR 0 8
67073: PUSH
67074: FOR_IN
67075: IFFALSE 67106
// begin if UnitsInside ( j ) < 6 then
67077: LD_VAR 0 3
67081: PPUSH
67082: CALL_OW 313
67086: PUSH
67087: LD_INT 6
67089: LESS
67090: IFFALSE 67104
// begin selected := j ;
67092: LD_ADDR_VAR 0 7
67096: PUSH
67097: LD_VAR 0 3
67101: ST_TO_ADDR
// break ;
67102: GO 67106
// end ; end ;
67104: GO 67074
67106: POP
67107: POP
// if selected then
67108: LD_VAR 0 7
67112: IFFALSE 67202
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
67114: LD_ADDR_VAR 0 3
67118: PUSH
67119: LD_EXP 72
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: PPUSH
67130: LD_INT 25
67132: PUSH
67133: LD_INT 12
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PPUSH
67140: CALL_OW 72
67144: PUSH
67145: FOR_IN
67146: IFFALSE 67200
// if not IsInUnit ( j ) and not HasTask ( j ) then
67148: LD_VAR 0 3
67152: PPUSH
67153: CALL_OW 310
67157: NOT
67158: PUSH
67159: LD_VAR 0 3
67163: PPUSH
67164: CALL_OW 314
67168: NOT
67169: AND
67170: IFFALSE 67198
// begin ComEnterUnit ( j , selected ) ;
67172: LD_VAR 0 3
67176: PPUSH
67177: LD_VAR 0 7
67181: PPUSH
67182: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
67186: LD_VAR 0 3
67190: PPUSH
67191: LD_INT 15
67193: PPUSH
67194: CALL_OW 183
// end ;
67198: GO 67145
67200: POP
67201: POP
// end ; end ; end ; end ; end ;
67202: GO 66595
67204: POP
67205: POP
// end ;
67206: LD_VAR 0 1
67210: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
67211: LD_INT 0
67213: PPUSH
67214: PPUSH
67215: PPUSH
67216: PPUSH
// if not mc_bases then
67217: LD_EXP 43
67221: NOT
67222: IFFALSE 67226
// exit ;
67224: GO 67404
// for i = 1 to mc_bases do
67226: LD_ADDR_VAR 0 2
67230: PUSH
67231: DOUBLE
67232: LD_INT 1
67234: DEC
67235: ST_TO_ADDR
67236: LD_EXP 43
67240: PUSH
67241: FOR_TO
67242: IFFALSE 67402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
67244: LD_ADDR_VAR 0 4
67248: PUSH
67249: LD_EXP 43
67253: PUSH
67254: LD_VAR 0 2
67258: ARRAY
67259: PPUSH
67260: LD_INT 25
67262: PUSH
67263: LD_INT 9
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PPUSH
67270: CALL_OW 72
67274: ST_TO_ADDR
// if not tmp then
67275: LD_VAR 0 4
67279: NOT
67280: IFFALSE 67284
// continue ;
67282: GO 67241
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
67284: LD_EXP 69
67288: PUSH
67289: LD_VAR 0 2
67293: ARRAY
67294: PPUSH
67295: LD_INT 29
67297: PPUSH
67298: CALL_OW 325
67302: NOT
67303: PUSH
67304: LD_EXP 69
67308: PUSH
67309: LD_VAR 0 2
67313: ARRAY
67314: PPUSH
67315: LD_INT 28
67317: PPUSH
67318: CALL_OW 325
67322: NOT
67323: AND
67324: IFFALSE 67328
// continue ;
67326: GO 67241
// for j in tmp do
67328: LD_ADDR_VAR 0 3
67332: PUSH
67333: LD_VAR 0 4
67337: PUSH
67338: FOR_IN
67339: IFFALSE 67398
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67341: LD_VAR 0 3
67345: PUSH
67346: LD_EXP 46
67350: PUSH
67351: LD_VAR 0 2
67355: ARRAY
67356: PUSH
67357: LD_INT 1
67359: ARRAY
67360: IN
67361: NOT
67362: PUSH
67363: LD_VAR 0 3
67367: PUSH
67368: LD_EXP 46
67372: PUSH
67373: LD_VAR 0 2
67377: ARRAY
67378: PUSH
67379: LD_INT 2
67381: ARRAY
67382: IN
67383: NOT
67384: AND
67385: IFFALSE 67396
// ComSpaceTimeShoot ( j ) ;
67387: LD_VAR 0 3
67391: PPUSH
67392: CALL 10794 0 1
67396: GO 67338
67398: POP
67399: POP
// end ;
67400: GO 67241
67402: POP
67403: POP
// end ;
67404: LD_VAR 0 1
67408: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
67409: LD_INT 0
67411: PPUSH
67412: PPUSH
67413: PPUSH
67414: PPUSH
67415: PPUSH
67416: PPUSH
67417: PPUSH
67418: PPUSH
67419: PPUSH
// if not mc_bases then
67420: LD_EXP 43
67424: NOT
67425: IFFALSE 67429
// exit ;
67427: GO 68051
// for i = 1 to mc_bases do
67429: LD_ADDR_VAR 0 2
67433: PUSH
67434: DOUBLE
67435: LD_INT 1
67437: DEC
67438: ST_TO_ADDR
67439: LD_EXP 43
67443: PUSH
67444: FOR_TO
67445: IFFALSE 68049
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
67447: LD_EXP 78
67451: PUSH
67452: LD_VAR 0 2
67456: ARRAY
67457: NOT
67458: PUSH
67459: LD_INT 38
67461: PPUSH
67462: LD_EXP 69
67466: PUSH
67467: LD_VAR 0 2
67471: ARRAY
67472: PPUSH
67473: CALL_OW 321
67477: PUSH
67478: LD_INT 2
67480: NONEQUAL
67481: OR
67482: IFFALSE 67486
// continue ;
67484: GO 67444
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67486: LD_ADDR_VAR 0 8
67490: PUSH
67491: LD_EXP 43
67495: PUSH
67496: LD_VAR 0 2
67500: ARRAY
67501: PPUSH
67502: LD_INT 30
67504: PUSH
67505: LD_INT 34
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PPUSH
67512: CALL_OW 72
67516: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67517: LD_ADDR_VAR 0 9
67521: PUSH
67522: LD_EXP 43
67526: PUSH
67527: LD_VAR 0 2
67531: ARRAY
67532: PPUSH
67533: LD_INT 25
67535: PUSH
67536: LD_INT 4
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PPUSH
67543: CALL_OW 72
67547: PPUSH
67548: LD_INT 0
67550: PPUSH
67551: CALL 43691 0 2
67555: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67556: LD_VAR 0 9
67560: NOT
67561: PUSH
67562: LD_VAR 0 8
67566: NOT
67567: OR
67568: PUSH
67569: LD_EXP 43
67573: PUSH
67574: LD_VAR 0 2
67578: ARRAY
67579: PPUSH
67580: LD_INT 124
67582: PPUSH
67583: CALL 43691 0 2
67587: OR
67588: IFFALSE 67592
// continue ;
67590: GO 67444
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67592: LD_EXP 79
67596: PUSH
67597: LD_VAR 0 2
67601: ARRAY
67602: PUSH
67603: LD_EXP 78
67607: PUSH
67608: LD_VAR 0 2
67612: ARRAY
67613: LESS
67614: PUSH
67615: LD_EXP 79
67619: PUSH
67620: LD_VAR 0 2
67624: ARRAY
67625: PUSH
67626: LD_VAR 0 8
67630: LESS
67631: AND
67632: IFFALSE 68047
// begin tmp := sci [ 1 ] ;
67634: LD_ADDR_VAR 0 7
67638: PUSH
67639: LD_VAR 0 9
67643: PUSH
67644: LD_INT 1
67646: ARRAY
67647: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67648: LD_VAR 0 7
67652: PPUSH
67653: LD_INT 124
67655: PPUSH
67656: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67660: LD_ADDR_VAR 0 3
67664: PUSH
67665: DOUBLE
67666: LD_EXP 78
67670: PUSH
67671: LD_VAR 0 2
67675: ARRAY
67676: INC
67677: ST_TO_ADDR
67678: LD_EXP 78
67682: PUSH
67683: LD_VAR 0 2
67687: ARRAY
67688: PUSH
67689: FOR_DOWNTO
67690: IFFALSE 68033
// begin if IsInUnit ( tmp ) then
67692: LD_VAR 0 7
67696: PPUSH
67697: CALL_OW 310
67701: IFFALSE 67712
// ComExitBuilding ( tmp ) ;
67703: LD_VAR 0 7
67707: PPUSH
67708: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67712: LD_INT 35
67714: PPUSH
67715: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67719: LD_VAR 0 7
67723: PPUSH
67724: CALL_OW 310
67728: NOT
67729: PUSH
67730: LD_VAR 0 7
67734: PPUSH
67735: CALL_OW 314
67739: NOT
67740: AND
67741: IFFALSE 67712
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67743: LD_ADDR_VAR 0 6
67747: PUSH
67748: LD_VAR 0 7
67752: PPUSH
67753: CALL_OW 250
67757: PUSH
67758: LD_VAR 0 7
67762: PPUSH
67763: CALL_OW 251
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67772: LD_INT 35
67774: PPUSH
67775: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67779: LD_ADDR_VAR 0 4
67783: PUSH
67784: LD_EXP 78
67788: PUSH
67789: LD_VAR 0 2
67793: ARRAY
67794: PUSH
67795: LD_VAR 0 3
67799: ARRAY
67800: PUSH
67801: LD_INT 1
67803: ARRAY
67804: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67805: LD_ADDR_VAR 0 5
67809: PUSH
67810: LD_EXP 78
67814: PUSH
67815: LD_VAR 0 2
67819: ARRAY
67820: PUSH
67821: LD_VAR 0 3
67825: ARRAY
67826: PUSH
67827: LD_INT 2
67829: ARRAY
67830: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67831: LD_VAR 0 7
67835: PPUSH
67836: LD_INT 10
67838: PPUSH
67839: CALL 17390 0 2
67843: PUSH
67844: LD_INT 4
67846: ARRAY
67847: IFFALSE 67885
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67849: LD_VAR 0 7
67853: PPUSH
67854: LD_VAR 0 6
67858: PUSH
67859: LD_INT 1
67861: ARRAY
67862: PPUSH
67863: LD_VAR 0 6
67867: PUSH
67868: LD_INT 2
67870: ARRAY
67871: PPUSH
67872: CALL_OW 111
// wait ( 0 0$10 ) ;
67876: LD_INT 350
67878: PPUSH
67879: CALL_OW 67
// end else
67883: GO 67911
// begin ComMoveXY ( tmp , x , y ) ;
67885: LD_VAR 0 7
67889: PPUSH
67890: LD_VAR 0 4
67894: PPUSH
67895: LD_VAR 0 5
67899: PPUSH
67900: CALL_OW 111
// wait ( 0 0$3 ) ;
67904: LD_INT 105
67906: PPUSH
67907: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67911: LD_VAR 0 7
67915: PPUSH
67916: LD_VAR 0 4
67920: PPUSH
67921: LD_VAR 0 5
67925: PPUSH
67926: CALL_OW 307
67930: IFFALSE 67772
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67932: LD_VAR 0 7
67936: PPUSH
67937: LD_VAR 0 4
67941: PPUSH
67942: LD_VAR 0 5
67946: PPUSH
67947: LD_VAR 0 8
67951: PUSH
67952: LD_VAR 0 3
67956: ARRAY
67957: PPUSH
67958: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67962: LD_INT 35
67964: PPUSH
67965: CALL_OW 67
// until not HasTask ( tmp ) ;
67969: LD_VAR 0 7
67973: PPUSH
67974: CALL_OW 314
67978: NOT
67979: IFFALSE 67962
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67981: LD_ADDR_EXP 79
67985: PUSH
67986: LD_EXP 79
67990: PPUSH
67991: LD_VAR 0 2
67995: PUSH
67996: LD_EXP 79
68000: PUSH
68001: LD_VAR 0 2
68005: ARRAY
68006: PUSH
68007: LD_INT 1
68009: PLUS
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PPUSH
68015: LD_VAR 0 8
68019: PUSH
68020: LD_VAR 0 3
68024: ARRAY
68025: PPUSH
68026: CALL 14797 0 3
68030: ST_TO_ADDR
// end ;
68031: GO 67689
68033: POP
68034: POP
// MC_Reset ( i , 124 ) ;
68035: LD_VAR 0 2
68039: PPUSH
68040: LD_INT 124
68042: PPUSH
68043: CALL 51585 0 2
// end ; end ;
68047: GO 67444
68049: POP
68050: POP
// end ;
68051: LD_VAR 0 1
68055: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
68056: LD_INT 0
68058: PPUSH
68059: PPUSH
68060: PPUSH
// if not mc_bases then
68061: LD_EXP 43
68065: NOT
68066: IFFALSE 68070
// exit ;
68068: GO 68676
// for i = 1 to mc_bases do
68070: LD_ADDR_VAR 0 2
68074: PUSH
68075: DOUBLE
68076: LD_INT 1
68078: DEC
68079: ST_TO_ADDR
68080: LD_EXP 43
68084: PUSH
68085: FOR_TO
68086: IFFALSE 68674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
68088: LD_ADDR_VAR 0 3
68092: PUSH
68093: LD_EXP 43
68097: PUSH
68098: LD_VAR 0 2
68102: ARRAY
68103: PPUSH
68104: LD_INT 25
68106: PUSH
68107: LD_INT 4
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PPUSH
68114: CALL_OW 72
68118: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68119: LD_VAR 0 3
68123: NOT
68124: PUSH
68125: LD_EXP 80
68129: PUSH
68130: LD_VAR 0 2
68134: ARRAY
68135: NOT
68136: OR
68137: PUSH
68138: LD_EXP 43
68142: PUSH
68143: LD_VAR 0 2
68147: ARRAY
68148: PPUSH
68149: LD_INT 2
68151: PUSH
68152: LD_INT 30
68154: PUSH
68155: LD_INT 0
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 30
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: LIST
68176: PPUSH
68177: CALL_OW 72
68181: NOT
68182: OR
68183: IFFALSE 68233
// begin if mc_deposits_finder [ i ] then
68185: LD_EXP 81
68189: PUSH
68190: LD_VAR 0 2
68194: ARRAY
68195: IFFALSE 68231
// begin MC_Reset ( i , 125 ) ;
68197: LD_VAR 0 2
68201: PPUSH
68202: LD_INT 125
68204: PPUSH
68205: CALL 51585 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68209: LD_ADDR_EXP 81
68213: PUSH
68214: LD_EXP 81
68218: PPUSH
68219: LD_VAR 0 2
68223: PPUSH
68224: EMPTY
68225: PPUSH
68226: CALL_OW 1
68230: ST_TO_ADDR
// end ; continue ;
68231: GO 68085
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
68233: LD_EXP 80
68237: PUSH
68238: LD_VAR 0 2
68242: ARRAY
68243: PUSH
68244: LD_INT 1
68246: ARRAY
68247: PUSH
68248: LD_INT 3
68250: ARRAY
68251: PUSH
68252: LD_INT 1
68254: EQUAL
68255: PUSH
68256: LD_INT 20
68258: PPUSH
68259: LD_EXP 69
68263: PUSH
68264: LD_VAR 0 2
68268: ARRAY
68269: PPUSH
68270: CALL_OW 321
68274: PUSH
68275: LD_INT 2
68277: NONEQUAL
68278: AND
68279: IFFALSE 68329
// begin if mc_deposits_finder [ i ] then
68281: LD_EXP 81
68285: PUSH
68286: LD_VAR 0 2
68290: ARRAY
68291: IFFALSE 68327
// begin MC_Reset ( i , 125 ) ;
68293: LD_VAR 0 2
68297: PPUSH
68298: LD_INT 125
68300: PPUSH
68301: CALL 51585 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68305: LD_ADDR_EXP 81
68309: PUSH
68310: LD_EXP 81
68314: PPUSH
68315: LD_VAR 0 2
68319: PPUSH
68320: EMPTY
68321: PPUSH
68322: CALL_OW 1
68326: ST_TO_ADDR
// end ; continue ;
68327: GO 68085
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
68329: LD_EXP 80
68333: PUSH
68334: LD_VAR 0 2
68338: ARRAY
68339: PUSH
68340: LD_INT 1
68342: ARRAY
68343: PUSH
68344: LD_INT 1
68346: ARRAY
68347: PPUSH
68348: LD_EXP 80
68352: PUSH
68353: LD_VAR 0 2
68357: ARRAY
68358: PUSH
68359: LD_INT 1
68361: ARRAY
68362: PUSH
68363: LD_INT 2
68365: ARRAY
68366: PPUSH
68367: LD_EXP 69
68371: PUSH
68372: LD_VAR 0 2
68376: ARRAY
68377: PPUSH
68378: CALL_OW 440
68382: IFFALSE 68425
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
68384: LD_ADDR_EXP 80
68388: PUSH
68389: LD_EXP 80
68393: PPUSH
68394: LD_VAR 0 2
68398: PPUSH
68399: LD_EXP 80
68403: PUSH
68404: LD_VAR 0 2
68408: ARRAY
68409: PPUSH
68410: LD_INT 1
68412: PPUSH
68413: CALL_OW 3
68417: PPUSH
68418: CALL_OW 1
68422: ST_TO_ADDR
68423: GO 68672
// begin if not mc_deposits_finder [ i ] then
68425: LD_EXP 81
68429: PUSH
68430: LD_VAR 0 2
68434: ARRAY
68435: NOT
68436: IFFALSE 68488
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
68438: LD_ADDR_EXP 81
68442: PUSH
68443: LD_EXP 81
68447: PPUSH
68448: LD_VAR 0 2
68452: PPUSH
68453: LD_VAR 0 3
68457: PUSH
68458: LD_INT 1
68460: ARRAY
68461: PUSH
68462: EMPTY
68463: LIST
68464: PPUSH
68465: CALL_OW 1
68469: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68470: LD_VAR 0 3
68474: PUSH
68475: LD_INT 1
68477: ARRAY
68478: PPUSH
68479: LD_INT 125
68481: PPUSH
68482: CALL_OW 109
// end else
68486: GO 68672
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68488: LD_EXP 81
68492: PUSH
68493: LD_VAR 0 2
68497: ARRAY
68498: PUSH
68499: LD_INT 1
68501: ARRAY
68502: PPUSH
68503: CALL_OW 310
68507: IFFALSE 68530
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68509: LD_EXP 81
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: PUSH
68520: LD_INT 1
68522: ARRAY
68523: PPUSH
68524: CALL_OW 122
68528: GO 68672
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68530: LD_EXP 81
68534: PUSH
68535: LD_VAR 0 2
68539: ARRAY
68540: PUSH
68541: LD_INT 1
68543: ARRAY
68544: PPUSH
68545: CALL_OW 314
68549: NOT
68550: PUSH
68551: LD_EXP 81
68555: PUSH
68556: LD_VAR 0 2
68560: ARRAY
68561: PUSH
68562: LD_INT 1
68564: ARRAY
68565: PPUSH
68566: LD_EXP 80
68570: PUSH
68571: LD_VAR 0 2
68575: ARRAY
68576: PUSH
68577: LD_INT 1
68579: ARRAY
68580: PUSH
68581: LD_INT 1
68583: ARRAY
68584: PPUSH
68585: LD_EXP 80
68589: PUSH
68590: LD_VAR 0 2
68594: ARRAY
68595: PUSH
68596: LD_INT 1
68598: ARRAY
68599: PUSH
68600: LD_INT 2
68602: ARRAY
68603: PPUSH
68604: CALL_OW 297
68608: PUSH
68609: LD_INT 6
68611: GREATER
68612: AND
68613: IFFALSE 68672
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68615: LD_EXP 81
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: PUSH
68626: LD_INT 1
68628: ARRAY
68629: PPUSH
68630: LD_EXP 80
68634: PUSH
68635: LD_VAR 0 2
68639: ARRAY
68640: PUSH
68641: LD_INT 1
68643: ARRAY
68644: PUSH
68645: LD_INT 1
68647: ARRAY
68648: PPUSH
68649: LD_EXP 80
68653: PUSH
68654: LD_VAR 0 2
68658: ARRAY
68659: PUSH
68660: LD_INT 1
68662: ARRAY
68663: PUSH
68664: LD_INT 2
68666: ARRAY
68667: PPUSH
68668: CALL_OW 111
// end ; end ; end ;
68672: GO 68085
68674: POP
68675: POP
// end ;
68676: LD_VAR 0 1
68680: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68681: LD_INT 0
68683: PPUSH
68684: PPUSH
68685: PPUSH
68686: PPUSH
68687: PPUSH
68688: PPUSH
68689: PPUSH
68690: PPUSH
68691: PPUSH
68692: PPUSH
68693: PPUSH
// if not mc_bases then
68694: LD_EXP 43
68698: NOT
68699: IFFALSE 68703
// exit ;
68701: GO 69643
// for i = 1 to mc_bases do
68703: LD_ADDR_VAR 0 2
68707: PUSH
68708: DOUBLE
68709: LD_INT 1
68711: DEC
68712: ST_TO_ADDR
68713: LD_EXP 43
68717: PUSH
68718: FOR_TO
68719: IFFALSE 69641
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68721: LD_EXP 43
68725: PUSH
68726: LD_VAR 0 2
68730: ARRAY
68731: NOT
68732: PUSH
68733: LD_EXP 66
68737: PUSH
68738: LD_VAR 0 2
68742: ARRAY
68743: OR
68744: IFFALSE 68748
// continue ;
68746: GO 68718
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68748: LD_ADDR_VAR 0 7
68752: PUSH
68753: LD_EXP 43
68757: PUSH
68758: LD_VAR 0 2
68762: ARRAY
68763: PUSH
68764: LD_INT 1
68766: ARRAY
68767: PPUSH
68768: CALL_OW 248
68772: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68773: LD_VAR 0 7
68777: PUSH
68778: LD_INT 3
68780: EQUAL
68781: PUSH
68782: LD_EXP 62
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_EXP 65
68797: PUSH
68798: LD_VAR 0 2
68802: ARRAY
68803: UNION
68804: PPUSH
68805: LD_INT 33
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PPUSH
68815: CALL_OW 72
68819: NOT
68820: OR
68821: IFFALSE 68825
// continue ;
68823: GO 68718
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68825: LD_ADDR_VAR 0 9
68829: PUSH
68830: LD_EXP 43
68834: PUSH
68835: LD_VAR 0 2
68839: ARRAY
68840: PPUSH
68841: LD_INT 30
68843: PUSH
68844: LD_INT 36
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PPUSH
68851: CALL_OW 72
68855: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68856: LD_ADDR_VAR 0 10
68860: PUSH
68861: LD_EXP 62
68865: PUSH
68866: LD_VAR 0 2
68870: ARRAY
68871: PPUSH
68872: LD_INT 34
68874: PUSH
68875: LD_INT 31
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PPUSH
68882: CALL_OW 72
68886: ST_TO_ADDR
// if not cts and not mcts then
68887: LD_VAR 0 9
68891: NOT
68892: PUSH
68893: LD_VAR 0 10
68897: NOT
68898: AND
68899: IFFALSE 68903
// continue ;
68901: GO 68718
// x := cts ;
68903: LD_ADDR_VAR 0 11
68907: PUSH
68908: LD_VAR 0 9
68912: ST_TO_ADDR
// if not x then
68913: LD_VAR 0 11
68917: NOT
68918: IFFALSE 68930
// x := mcts ;
68920: LD_ADDR_VAR 0 11
68924: PUSH
68925: LD_VAR 0 10
68929: ST_TO_ADDR
// if not x then
68930: LD_VAR 0 11
68934: NOT
68935: IFFALSE 68939
// continue ;
68937: GO 68718
// if mc_remote_driver [ i ] then
68939: LD_EXP 83
68943: PUSH
68944: LD_VAR 0 2
68948: ARRAY
68949: IFFALSE 69336
// for j in mc_remote_driver [ i ] do
68951: LD_ADDR_VAR 0 3
68955: PUSH
68956: LD_EXP 83
68960: PUSH
68961: LD_VAR 0 2
68965: ARRAY
68966: PUSH
68967: FOR_IN
68968: IFFALSE 69334
// begin if GetClass ( j ) <> 3 then
68970: LD_VAR 0 3
68974: PPUSH
68975: CALL_OW 257
68979: PUSH
68980: LD_INT 3
68982: NONEQUAL
68983: IFFALSE 69036
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68985: LD_ADDR_EXP 83
68989: PUSH
68990: LD_EXP 83
68994: PPUSH
68995: LD_VAR 0 2
68999: PPUSH
69000: LD_EXP 83
69004: PUSH
69005: LD_VAR 0 2
69009: ARRAY
69010: PUSH
69011: LD_VAR 0 3
69015: DIFF
69016: PPUSH
69017: CALL_OW 1
69021: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69022: LD_VAR 0 3
69026: PPUSH
69027: LD_INT 0
69029: PPUSH
69030: CALL_OW 109
// continue ;
69034: GO 68967
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
69036: LD_EXP 62
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: PPUSH
69047: LD_INT 34
69049: PUSH
69050: LD_INT 31
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 58
69059: PUSH
69060: EMPTY
69061: LIST
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PPUSH
69067: CALL_OW 72
69071: PUSH
69072: LD_VAR 0 3
69076: PPUSH
69077: CALL 43779 0 1
69081: NOT
69082: AND
69083: IFFALSE 69154
// begin if IsInUnit ( j ) then
69085: LD_VAR 0 3
69089: PPUSH
69090: CALL_OW 310
69094: IFFALSE 69105
// ComExitBuilding ( j ) ;
69096: LD_VAR 0 3
69100: PPUSH
69101: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
69105: LD_VAR 0 3
69109: PPUSH
69110: LD_EXP 62
69114: PUSH
69115: LD_VAR 0 2
69119: ARRAY
69120: PPUSH
69121: LD_INT 34
69123: PUSH
69124: LD_INT 31
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: LD_INT 58
69133: PUSH
69134: EMPTY
69135: LIST
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PPUSH
69141: CALL_OW 72
69145: PUSH
69146: LD_INT 1
69148: ARRAY
69149: PPUSH
69150: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
69154: LD_VAR 0 3
69158: PPUSH
69159: CALL_OW 310
69163: NOT
69164: PUSH
69165: LD_VAR 0 3
69169: PPUSH
69170: CALL_OW 310
69174: PPUSH
69175: CALL_OW 266
69179: PUSH
69180: LD_INT 36
69182: NONEQUAL
69183: PUSH
69184: LD_VAR 0 3
69188: PPUSH
69189: CALL 43779 0 1
69193: NOT
69194: AND
69195: OR
69196: IFFALSE 69332
// begin if IsInUnit ( j ) then
69198: LD_VAR 0 3
69202: PPUSH
69203: CALL_OW 310
69207: IFFALSE 69218
// ComExitBuilding ( j ) ;
69209: LD_VAR 0 3
69213: PPUSH
69214: CALL_OW 122
// ct := 0 ;
69218: LD_ADDR_VAR 0 8
69222: PUSH
69223: LD_INT 0
69225: ST_TO_ADDR
// for k in x do
69226: LD_ADDR_VAR 0 4
69230: PUSH
69231: LD_VAR 0 11
69235: PUSH
69236: FOR_IN
69237: IFFALSE 69310
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
69239: LD_VAR 0 4
69243: PPUSH
69244: CALL_OW 264
69248: PUSH
69249: LD_INT 31
69251: EQUAL
69252: PUSH
69253: LD_VAR 0 4
69257: PPUSH
69258: CALL_OW 311
69262: NOT
69263: AND
69264: PUSH
69265: LD_VAR 0 4
69269: PPUSH
69270: CALL_OW 266
69274: PUSH
69275: LD_INT 36
69277: EQUAL
69278: PUSH
69279: LD_VAR 0 4
69283: PPUSH
69284: CALL_OW 313
69288: PUSH
69289: LD_INT 3
69291: LESS
69292: AND
69293: OR
69294: IFFALSE 69308
// begin ct := k ;
69296: LD_ADDR_VAR 0 8
69300: PUSH
69301: LD_VAR 0 4
69305: ST_TO_ADDR
// break ;
69306: GO 69310
// end ;
69308: GO 69236
69310: POP
69311: POP
// if ct then
69312: LD_VAR 0 8
69316: IFFALSE 69332
// ComEnterUnit ( j , ct ) ;
69318: LD_VAR 0 3
69322: PPUSH
69323: LD_VAR 0 8
69327: PPUSH
69328: CALL_OW 120
// end ; end ;
69332: GO 68967
69334: POP
69335: POP
// places := 0 ;
69336: LD_ADDR_VAR 0 5
69340: PUSH
69341: LD_INT 0
69343: ST_TO_ADDR
// for j = 1 to x do
69344: LD_ADDR_VAR 0 3
69348: PUSH
69349: DOUBLE
69350: LD_INT 1
69352: DEC
69353: ST_TO_ADDR
69354: LD_VAR 0 11
69358: PUSH
69359: FOR_TO
69360: IFFALSE 69436
// if GetWeapon ( x [ j ] ) = ar_control_tower then
69362: LD_VAR 0 11
69366: PUSH
69367: LD_VAR 0 3
69371: ARRAY
69372: PPUSH
69373: CALL_OW 264
69377: PUSH
69378: LD_INT 31
69380: EQUAL
69381: IFFALSE 69399
// places := places + 1 else
69383: LD_ADDR_VAR 0 5
69387: PUSH
69388: LD_VAR 0 5
69392: PUSH
69393: LD_INT 1
69395: PLUS
69396: ST_TO_ADDR
69397: GO 69434
// if GetBType ( x [ j ] ) = b_control_tower then
69399: LD_VAR 0 11
69403: PUSH
69404: LD_VAR 0 3
69408: ARRAY
69409: PPUSH
69410: CALL_OW 266
69414: PUSH
69415: LD_INT 36
69417: EQUAL
69418: IFFALSE 69434
// places := places + 3 ;
69420: LD_ADDR_VAR 0 5
69424: PUSH
69425: LD_VAR 0 5
69429: PUSH
69430: LD_INT 3
69432: PLUS
69433: ST_TO_ADDR
69434: GO 69359
69436: POP
69437: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
69438: LD_VAR 0 5
69442: PUSH
69443: LD_INT 0
69445: EQUAL
69446: PUSH
69447: LD_VAR 0 5
69451: PUSH
69452: LD_EXP 83
69456: PUSH
69457: LD_VAR 0 2
69461: ARRAY
69462: LESSEQUAL
69463: OR
69464: IFFALSE 69468
// continue ;
69466: GO 68718
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69468: LD_ADDR_VAR 0 6
69472: PUSH
69473: LD_EXP 43
69477: PUSH
69478: LD_VAR 0 2
69482: ARRAY
69483: PPUSH
69484: LD_INT 25
69486: PUSH
69487: LD_INT 3
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PPUSH
69494: CALL_OW 72
69498: PUSH
69499: LD_EXP 83
69503: PUSH
69504: LD_VAR 0 2
69508: ARRAY
69509: DIFF
69510: PPUSH
69511: LD_INT 3
69513: PPUSH
69514: CALL 44679 0 2
69518: ST_TO_ADDR
// for j in tmp do
69519: LD_ADDR_VAR 0 3
69523: PUSH
69524: LD_VAR 0 6
69528: PUSH
69529: FOR_IN
69530: IFFALSE 69565
// if GetTag ( j ) > 0 then
69532: LD_VAR 0 3
69536: PPUSH
69537: CALL_OW 110
69541: PUSH
69542: LD_INT 0
69544: GREATER
69545: IFFALSE 69563
// tmp := tmp diff j ;
69547: LD_ADDR_VAR 0 6
69551: PUSH
69552: LD_VAR 0 6
69556: PUSH
69557: LD_VAR 0 3
69561: DIFF
69562: ST_TO_ADDR
69563: GO 69529
69565: POP
69566: POP
// if not tmp then
69567: LD_VAR 0 6
69571: NOT
69572: IFFALSE 69576
// continue ;
69574: GO 68718
// if places then
69576: LD_VAR 0 5
69580: IFFALSE 69639
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69582: LD_ADDR_EXP 83
69586: PUSH
69587: LD_EXP 83
69591: PPUSH
69592: LD_VAR 0 2
69596: PPUSH
69597: LD_EXP 83
69601: PUSH
69602: LD_VAR 0 2
69606: ARRAY
69607: PUSH
69608: LD_VAR 0 6
69612: PUSH
69613: LD_INT 1
69615: ARRAY
69616: UNION
69617: PPUSH
69618: CALL_OW 1
69622: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69623: LD_VAR 0 6
69627: PUSH
69628: LD_INT 1
69630: ARRAY
69631: PPUSH
69632: LD_INT 126
69634: PPUSH
69635: CALL_OW 109
// end ; end ;
69639: GO 68718
69641: POP
69642: POP
// end ;
69643: LD_VAR 0 1
69647: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69648: LD_INT 0
69650: PPUSH
69651: PPUSH
69652: PPUSH
69653: PPUSH
69654: PPUSH
69655: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69656: LD_VAR 0 1
69660: NOT
69661: PUSH
69662: LD_VAR 0 2
69666: NOT
69667: OR
69668: PUSH
69669: LD_VAR 0 3
69673: NOT
69674: OR
69675: PUSH
69676: LD_VAR 0 4
69680: PUSH
69681: LD_INT 1
69683: PUSH
69684: LD_INT 2
69686: PUSH
69687: LD_INT 3
69689: PUSH
69690: LD_INT 4
69692: PUSH
69693: LD_INT 5
69695: PUSH
69696: LD_INT 8
69698: PUSH
69699: LD_INT 9
69701: PUSH
69702: LD_INT 15
69704: PUSH
69705: LD_INT 16
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: IN
69719: NOT
69720: OR
69721: IFFALSE 69725
// exit ;
69723: GO 70625
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69725: LD_ADDR_VAR 0 2
69729: PUSH
69730: LD_VAR 0 2
69734: PPUSH
69735: LD_INT 21
69737: PUSH
69738: LD_INT 3
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 24
69747: PUSH
69748: LD_INT 250
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PPUSH
69759: CALL_OW 72
69763: ST_TO_ADDR
// case class of 1 , 15 :
69764: LD_VAR 0 4
69768: PUSH
69769: LD_INT 1
69771: DOUBLE
69772: EQUAL
69773: IFTRUE 69783
69775: LD_INT 15
69777: DOUBLE
69778: EQUAL
69779: IFTRUE 69783
69781: GO 69868
69783: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69784: LD_ADDR_VAR 0 8
69788: PUSH
69789: LD_VAR 0 2
69793: PPUSH
69794: LD_INT 2
69796: PUSH
69797: LD_INT 30
69799: PUSH
69800: LD_INT 32
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 30
69809: PUSH
69810: LD_INT 31
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: LIST
69821: PPUSH
69822: CALL_OW 72
69826: PUSH
69827: LD_VAR 0 2
69831: PPUSH
69832: LD_INT 2
69834: PUSH
69835: LD_INT 30
69837: PUSH
69838: LD_INT 4
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 30
69847: PUSH
69848: LD_INT 5
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: LIST
69859: PPUSH
69860: CALL_OW 72
69864: ADD
69865: ST_TO_ADDR
69866: GO 70114
69868: LD_INT 2
69870: DOUBLE
69871: EQUAL
69872: IFTRUE 69882
69874: LD_INT 16
69876: DOUBLE
69877: EQUAL
69878: IFTRUE 69882
69880: GO 69928
69882: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69883: LD_ADDR_VAR 0 8
69887: PUSH
69888: LD_VAR 0 2
69892: PPUSH
69893: LD_INT 2
69895: PUSH
69896: LD_INT 30
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 30
69908: PUSH
69909: LD_INT 1
69911: PUSH
69912: EMPTY
69913: LIST
69914: LIST
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: LIST
69920: PPUSH
69921: CALL_OW 72
69925: ST_TO_ADDR
69926: GO 70114
69928: LD_INT 3
69930: DOUBLE
69931: EQUAL
69932: IFTRUE 69936
69934: GO 69982
69936: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69937: LD_ADDR_VAR 0 8
69941: PUSH
69942: LD_VAR 0 2
69946: PPUSH
69947: LD_INT 2
69949: PUSH
69950: LD_INT 30
69952: PUSH
69953: LD_INT 2
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 30
69962: PUSH
69963: LD_INT 3
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: LIST
69974: PPUSH
69975: CALL_OW 72
69979: ST_TO_ADDR
69980: GO 70114
69982: LD_INT 4
69984: DOUBLE
69985: EQUAL
69986: IFTRUE 69990
69988: GO 70047
69990: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69991: LD_ADDR_VAR 0 8
69995: PUSH
69996: LD_VAR 0 2
70000: PPUSH
70001: LD_INT 2
70003: PUSH
70004: LD_INT 30
70006: PUSH
70007: LD_INT 6
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 30
70016: PUSH
70017: LD_INT 7
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 30
70026: PUSH
70027: LD_INT 8
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: PPUSH
70040: CALL_OW 72
70044: ST_TO_ADDR
70045: GO 70114
70047: LD_INT 5
70049: DOUBLE
70050: EQUAL
70051: IFTRUE 70067
70053: LD_INT 8
70055: DOUBLE
70056: EQUAL
70057: IFTRUE 70067
70059: LD_INT 9
70061: DOUBLE
70062: EQUAL
70063: IFTRUE 70067
70065: GO 70113
70067: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
70068: LD_ADDR_VAR 0 8
70072: PUSH
70073: LD_VAR 0 2
70077: PPUSH
70078: LD_INT 2
70080: PUSH
70081: LD_INT 30
70083: PUSH
70084: LD_INT 4
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 30
70093: PUSH
70094: LD_INT 5
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: LIST
70105: PPUSH
70106: CALL_OW 72
70110: ST_TO_ADDR
70111: GO 70114
70113: POP
// if not tmp then
70114: LD_VAR 0 8
70118: NOT
70119: IFFALSE 70123
// exit ;
70121: GO 70625
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
70123: LD_VAR 0 4
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: LD_INT 15
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: IN
70138: PUSH
70139: LD_EXP 52
70143: PUSH
70144: LD_VAR 0 1
70148: ARRAY
70149: AND
70150: IFFALSE 70306
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
70152: LD_ADDR_VAR 0 9
70156: PUSH
70157: LD_EXP 52
70161: PUSH
70162: LD_VAR 0 1
70166: ARRAY
70167: PUSH
70168: LD_INT 1
70170: ARRAY
70171: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
70172: LD_VAR 0 9
70176: PUSH
70177: LD_EXP 53
70181: PUSH
70182: LD_VAR 0 1
70186: ARRAY
70187: IN
70188: NOT
70189: IFFALSE 70304
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
70191: LD_ADDR_EXP 53
70195: PUSH
70196: LD_EXP 53
70200: PPUSH
70201: LD_VAR 0 1
70205: PUSH
70206: LD_EXP 53
70210: PUSH
70211: LD_VAR 0 1
70215: ARRAY
70216: PUSH
70217: LD_INT 1
70219: PLUS
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PPUSH
70225: LD_VAR 0 9
70229: PPUSH
70230: CALL 14797 0 3
70234: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
70235: LD_ADDR_EXP 52
70239: PUSH
70240: LD_EXP 52
70244: PPUSH
70245: LD_VAR 0 1
70249: PPUSH
70250: LD_EXP 52
70254: PUSH
70255: LD_VAR 0 1
70259: ARRAY
70260: PUSH
70261: LD_VAR 0 9
70265: DIFF
70266: PPUSH
70267: CALL_OW 1
70271: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
70272: LD_VAR 0 3
70276: PPUSH
70277: LD_EXP 53
70281: PUSH
70282: LD_VAR 0 1
70286: ARRAY
70287: PUSH
70288: LD_EXP 53
70292: PUSH
70293: LD_VAR 0 1
70297: ARRAY
70298: ARRAY
70299: PPUSH
70300: CALL_OW 120
// end ; exit ;
70304: GO 70625
// end ; if tmp > 1 then
70306: LD_VAR 0 8
70310: PUSH
70311: LD_INT 1
70313: GREATER
70314: IFFALSE 70418
// for i = 2 to tmp do
70316: LD_ADDR_VAR 0 6
70320: PUSH
70321: DOUBLE
70322: LD_INT 2
70324: DEC
70325: ST_TO_ADDR
70326: LD_VAR 0 8
70330: PUSH
70331: FOR_TO
70332: IFFALSE 70416
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
70334: LD_VAR 0 8
70338: PUSH
70339: LD_VAR 0 6
70343: ARRAY
70344: PPUSH
70345: CALL_OW 461
70349: PUSH
70350: LD_INT 6
70352: EQUAL
70353: IFFALSE 70414
// begin x := tmp [ i ] ;
70355: LD_ADDR_VAR 0 9
70359: PUSH
70360: LD_VAR 0 8
70364: PUSH
70365: LD_VAR 0 6
70369: ARRAY
70370: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
70371: LD_ADDR_VAR 0 8
70375: PUSH
70376: LD_VAR 0 8
70380: PPUSH
70381: LD_VAR 0 6
70385: PPUSH
70386: CALL_OW 3
70390: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
70391: LD_ADDR_VAR 0 8
70395: PUSH
70396: LD_VAR 0 8
70400: PPUSH
70401: LD_INT 1
70403: PPUSH
70404: LD_VAR 0 9
70408: PPUSH
70409: CALL_OW 2
70413: ST_TO_ADDR
// end ;
70414: GO 70331
70416: POP
70417: POP
// for i in tmp do
70418: LD_ADDR_VAR 0 6
70422: PUSH
70423: LD_VAR 0 8
70427: PUSH
70428: FOR_IN
70429: IFFALSE 70498
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
70431: LD_VAR 0 6
70435: PPUSH
70436: CALL_OW 313
70440: PUSH
70441: LD_INT 6
70443: LESS
70444: PUSH
70445: LD_VAR 0 6
70449: PPUSH
70450: CALL_OW 266
70454: PUSH
70455: LD_INT 31
70457: PUSH
70458: LD_INT 32
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: IN
70465: NOT
70466: AND
70467: PUSH
70468: LD_VAR 0 6
70472: PPUSH
70473: CALL_OW 313
70477: PUSH
70478: LD_INT 0
70480: EQUAL
70481: OR
70482: IFFALSE 70496
// begin j := i ;
70484: LD_ADDR_VAR 0 7
70488: PUSH
70489: LD_VAR 0 6
70493: ST_TO_ADDR
// break ;
70494: GO 70498
// end ; end ;
70496: GO 70428
70498: POP
70499: POP
// if j then
70500: LD_VAR 0 7
70504: IFFALSE 70522
// ComEnterUnit ( unit , j ) else
70506: LD_VAR 0 3
70510: PPUSH
70511: LD_VAR 0 7
70515: PPUSH
70516: CALL_OW 120
70520: GO 70625
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70522: LD_ADDR_VAR 0 10
70526: PUSH
70527: LD_VAR 0 2
70531: PPUSH
70532: LD_INT 2
70534: PUSH
70535: LD_INT 30
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 30
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: LIST
70559: PPUSH
70560: CALL_OW 72
70564: ST_TO_ADDR
// if depot then
70565: LD_VAR 0 10
70569: IFFALSE 70625
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70571: LD_ADDR_VAR 0 10
70575: PUSH
70576: LD_VAR 0 10
70580: PPUSH
70581: LD_VAR 0 3
70585: PPUSH
70586: CALL_OW 74
70590: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70591: LD_VAR 0 3
70595: PPUSH
70596: LD_VAR 0 10
70600: PPUSH
70601: CALL_OW 296
70605: PUSH
70606: LD_INT 10
70608: GREATER
70609: IFFALSE 70625
// ComStandNearbyBuilding ( unit , depot ) ;
70611: LD_VAR 0 3
70615: PPUSH
70616: LD_VAR 0 10
70620: PPUSH
70621: CALL 11411 0 2
// end ; end ; end ;
70625: LD_VAR 0 5
70629: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70630: LD_INT 0
70632: PPUSH
70633: PPUSH
70634: PPUSH
70635: PPUSH
// if not mc_bases then
70636: LD_EXP 43
70640: NOT
70641: IFFALSE 70645
// exit ;
70643: GO 70884
// for i = 1 to mc_bases do
70645: LD_ADDR_VAR 0 2
70649: PUSH
70650: DOUBLE
70651: LD_INT 1
70653: DEC
70654: ST_TO_ADDR
70655: LD_EXP 43
70659: PUSH
70660: FOR_TO
70661: IFFALSE 70882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70663: LD_ADDR_VAR 0 4
70667: PUSH
70668: LD_EXP 43
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: PPUSH
70679: LD_INT 21
70681: PUSH
70682: LD_INT 1
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PPUSH
70689: CALL_OW 72
70693: PUSH
70694: LD_EXP 72
70698: PUSH
70699: LD_VAR 0 2
70703: ARRAY
70704: UNION
70705: ST_TO_ADDR
// if not tmp then
70706: LD_VAR 0 4
70710: NOT
70711: IFFALSE 70715
// continue ;
70713: GO 70660
// for j in tmp do
70715: LD_ADDR_VAR 0 3
70719: PUSH
70720: LD_VAR 0 4
70724: PUSH
70725: FOR_IN
70726: IFFALSE 70878
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70728: LD_VAR 0 3
70732: PPUSH
70733: CALL_OW 110
70737: NOT
70738: PUSH
70739: LD_VAR 0 3
70743: PPUSH
70744: CALL_OW 314
70748: NOT
70749: AND
70750: PUSH
70751: LD_VAR 0 3
70755: PPUSH
70756: CALL_OW 311
70760: NOT
70761: AND
70762: PUSH
70763: LD_VAR 0 3
70767: PPUSH
70768: CALL_OW 310
70772: NOT
70773: AND
70774: PUSH
70775: LD_VAR 0 3
70779: PUSH
70780: LD_EXP 46
70784: PUSH
70785: LD_VAR 0 2
70789: ARRAY
70790: PUSH
70791: LD_INT 1
70793: ARRAY
70794: IN
70795: NOT
70796: AND
70797: PUSH
70798: LD_VAR 0 3
70802: PUSH
70803: LD_EXP 46
70807: PUSH
70808: LD_VAR 0 2
70812: ARRAY
70813: PUSH
70814: LD_INT 2
70816: ARRAY
70817: IN
70818: NOT
70819: AND
70820: PUSH
70821: LD_VAR 0 3
70825: PUSH
70826: LD_EXP 55
70830: PUSH
70831: LD_VAR 0 2
70835: ARRAY
70836: IN
70837: NOT
70838: AND
70839: IFFALSE 70876
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70841: LD_VAR 0 2
70845: PPUSH
70846: LD_EXP 43
70850: PUSH
70851: LD_VAR 0 2
70855: ARRAY
70856: PPUSH
70857: LD_VAR 0 3
70861: PPUSH
70862: LD_VAR 0 3
70866: PPUSH
70867: CALL_OW 257
70871: PPUSH
70872: CALL 69648 0 4
// end ;
70876: GO 70725
70878: POP
70879: POP
// end ;
70880: GO 70660
70882: POP
70883: POP
// end ;
70884: LD_VAR 0 1
70888: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70889: LD_INT 0
70891: PPUSH
70892: PPUSH
70893: PPUSH
70894: PPUSH
70895: PPUSH
70896: PPUSH
// if not mc_bases [ base ] then
70897: LD_EXP 43
70901: PUSH
70902: LD_VAR 0 1
70906: ARRAY
70907: NOT
70908: IFFALSE 70912
// exit ;
70910: GO 71094
// tmp := [ ] ;
70912: LD_ADDR_VAR 0 6
70916: PUSH
70917: EMPTY
70918: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70919: LD_ADDR_VAR 0 7
70923: PUSH
70924: LD_VAR 0 3
70928: PPUSH
70929: LD_INT 0
70931: PPUSH
70932: CALL_OW 517
70936: ST_TO_ADDR
// if not list then
70937: LD_VAR 0 7
70941: NOT
70942: IFFALSE 70946
// exit ;
70944: GO 71094
// for i = 1 to amount do
70946: LD_ADDR_VAR 0 5
70950: PUSH
70951: DOUBLE
70952: LD_INT 1
70954: DEC
70955: ST_TO_ADDR
70956: LD_VAR 0 2
70960: PUSH
70961: FOR_TO
70962: IFFALSE 71042
// begin x := rand ( 1 , list [ 1 ] ) ;
70964: LD_ADDR_VAR 0 8
70968: PUSH
70969: LD_INT 1
70971: PPUSH
70972: LD_VAR 0 7
70976: PUSH
70977: LD_INT 1
70979: ARRAY
70980: PPUSH
70981: CALL_OW 12
70985: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70986: LD_ADDR_VAR 0 6
70990: PUSH
70991: LD_VAR 0 6
70995: PPUSH
70996: LD_VAR 0 5
71000: PPUSH
71001: LD_VAR 0 7
71005: PUSH
71006: LD_INT 1
71008: ARRAY
71009: PUSH
71010: LD_VAR 0 8
71014: ARRAY
71015: PUSH
71016: LD_VAR 0 7
71020: PUSH
71021: LD_INT 2
71023: ARRAY
71024: PUSH
71025: LD_VAR 0 8
71029: ARRAY
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PPUSH
71035: CALL_OW 1
71039: ST_TO_ADDR
// end ;
71040: GO 70961
71042: POP
71043: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
71044: LD_ADDR_EXP 56
71048: PUSH
71049: LD_EXP 56
71053: PPUSH
71054: LD_VAR 0 1
71058: PPUSH
71059: LD_VAR 0 6
71063: PPUSH
71064: CALL_OW 1
71068: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
71069: LD_ADDR_EXP 58
71073: PUSH
71074: LD_EXP 58
71078: PPUSH
71079: LD_VAR 0 1
71083: PPUSH
71084: LD_VAR 0 3
71088: PPUSH
71089: CALL_OW 1
71093: ST_TO_ADDR
// end ;
71094: LD_VAR 0 4
71098: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
71099: LD_INT 0
71101: PPUSH
// if not mc_bases [ base ] then
71102: LD_EXP 43
71106: PUSH
71107: LD_VAR 0 1
71111: ARRAY
71112: NOT
71113: IFFALSE 71117
// exit ;
71115: GO 71142
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
71117: LD_ADDR_EXP 48
71121: PUSH
71122: LD_EXP 48
71126: PPUSH
71127: LD_VAR 0 1
71131: PPUSH
71132: LD_VAR 0 2
71136: PPUSH
71137: CALL_OW 1
71141: ST_TO_ADDR
// end ;
71142: LD_VAR 0 3
71146: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
71147: LD_INT 0
71149: PPUSH
// if not mc_bases [ base ] then
71150: LD_EXP 43
71154: PUSH
71155: LD_VAR 0 1
71159: ARRAY
71160: NOT
71161: IFFALSE 71165
// exit ;
71163: GO 71202
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
71165: LD_ADDR_EXP 48
71169: PUSH
71170: LD_EXP 48
71174: PPUSH
71175: LD_VAR 0 1
71179: PPUSH
71180: LD_EXP 48
71184: PUSH
71185: LD_VAR 0 1
71189: ARRAY
71190: PUSH
71191: LD_VAR 0 2
71195: UNION
71196: PPUSH
71197: CALL_OW 1
71201: ST_TO_ADDR
// end ;
71202: LD_VAR 0 3
71206: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
71207: LD_INT 0
71209: PPUSH
// if not mc_bases [ base ] then
71210: LD_EXP 43
71214: PUSH
71215: LD_VAR 0 1
71219: ARRAY
71220: NOT
71221: IFFALSE 71225
// exit ;
71223: GO 71250
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
71225: LD_ADDR_EXP 64
71229: PUSH
71230: LD_EXP 64
71234: PPUSH
71235: LD_VAR 0 1
71239: PPUSH
71240: LD_VAR 0 2
71244: PPUSH
71245: CALL_OW 1
71249: ST_TO_ADDR
// end ;
71250: LD_VAR 0 3
71254: RET
// export function MC_InsertProduceList ( base , components ) ; begin
71255: LD_INT 0
71257: PPUSH
// if not mc_bases [ base ] then
71258: LD_EXP 43
71262: PUSH
71263: LD_VAR 0 1
71267: ARRAY
71268: NOT
71269: IFFALSE 71273
// exit ;
71271: GO 71310
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
71273: LD_ADDR_EXP 64
71277: PUSH
71278: LD_EXP 64
71282: PPUSH
71283: LD_VAR 0 1
71287: PPUSH
71288: LD_EXP 64
71292: PUSH
71293: LD_VAR 0 1
71297: ARRAY
71298: PUSH
71299: LD_VAR 0 2
71303: ADD
71304: PPUSH
71305: CALL_OW 1
71309: ST_TO_ADDR
// end ;
71310: LD_VAR 0 3
71314: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
71315: LD_INT 0
71317: PPUSH
// if not mc_bases [ base ] then
71318: LD_EXP 43
71322: PUSH
71323: LD_VAR 0 1
71327: ARRAY
71328: NOT
71329: IFFALSE 71333
// exit ;
71331: GO 71387
// mc_defender := Replace ( mc_defender , base , deflist ) ;
71333: LD_ADDR_EXP 65
71337: PUSH
71338: LD_EXP 65
71342: PPUSH
71343: LD_VAR 0 1
71347: PPUSH
71348: LD_VAR 0 2
71352: PPUSH
71353: CALL_OW 1
71357: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
71358: LD_ADDR_EXP 54
71362: PUSH
71363: LD_EXP 54
71367: PPUSH
71368: LD_VAR 0 1
71372: PPUSH
71373: LD_VAR 0 2
71377: PUSH
71378: LD_INT 0
71380: PLUS
71381: PPUSH
71382: CALL_OW 1
71386: ST_TO_ADDR
// end ;
71387: LD_VAR 0 3
71391: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
71392: LD_INT 0
71394: PPUSH
// if not mc_bases [ base ] then
71395: LD_EXP 43
71399: PUSH
71400: LD_VAR 0 1
71404: ARRAY
71405: NOT
71406: IFFALSE 71410
// exit ;
71408: GO 71435
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
71410: LD_ADDR_EXP 54
71414: PUSH
71415: LD_EXP 54
71419: PPUSH
71420: LD_VAR 0 1
71424: PPUSH
71425: LD_VAR 0 2
71429: PPUSH
71430: CALL_OW 1
71434: ST_TO_ADDR
// end ;
71435: LD_VAR 0 3
71439: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
71440: LD_INT 0
71442: PPUSH
71443: PPUSH
71444: PPUSH
71445: PPUSH
// if not mc_bases [ base ] then
71446: LD_EXP 43
71450: PUSH
71451: LD_VAR 0 1
71455: ARRAY
71456: NOT
71457: IFFALSE 71461
// exit ;
71459: GO 71526
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
71461: LD_ADDR_EXP 63
71465: PUSH
71466: LD_EXP 63
71470: PPUSH
71471: LD_VAR 0 1
71475: PUSH
71476: LD_EXP 63
71480: PUSH
71481: LD_VAR 0 1
71485: ARRAY
71486: PUSH
71487: LD_INT 1
71489: PLUS
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PPUSH
71495: LD_VAR 0 1
71499: PUSH
71500: LD_VAR 0 2
71504: PUSH
71505: LD_VAR 0 3
71509: PUSH
71510: LD_VAR 0 4
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: PPUSH
71521: CALL 14797 0 3
71525: ST_TO_ADDR
// end ;
71526: LD_VAR 0 5
71530: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71531: LD_INT 0
71533: PPUSH
// if not mc_bases [ base ] then
71534: LD_EXP 43
71538: PUSH
71539: LD_VAR 0 1
71543: ARRAY
71544: NOT
71545: IFFALSE 71549
// exit ;
71547: GO 71574
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71549: LD_ADDR_EXP 80
71553: PUSH
71554: LD_EXP 80
71558: PPUSH
71559: LD_VAR 0 1
71563: PPUSH
71564: LD_VAR 0 2
71568: PPUSH
71569: CALL_OW 1
71573: ST_TO_ADDR
// end ;
71574: LD_VAR 0 3
71578: RET
// export function MC_GetMinesField ( base ) ; begin
71579: LD_INT 0
71581: PPUSH
// result := mc_mines [ base ] ;
71582: LD_ADDR_VAR 0 2
71586: PUSH
71587: LD_EXP 56
71591: PUSH
71592: LD_VAR 0 1
71596: ARRAY
71597: ST_TO_ADDR
// end ;
71598: LD_VAR 0 2
71602: RET
// export function MC_GetProduceList ( base ) ; begin
71603: LD_INT 0
71605: PPUSH
// result := mc_produce [ base ] ;
71606: LD_ADDR_VAR 0 2
71610: PUSH
71611: LD_EXP 64
71615: PUSH
71616: LD_VAR 0 1
71620: ARRAY
71621: ST_TO_ADDR
// end ;
71622: LD_VAR 0 2
71626: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71627: LD_INT 0
71629: PPUSH
71630: PPUSH
// if not mc_bases then
71631: LD_EXP 43
71635: NOT
71636: IFFALSE 71640
// exit ;
71638: GO 71705
// if mc_bases [ base ] then
71640: LD_EXP 43
71644: PUSH
71645: LD_VAR 0 1
71649: ARRAY
71650: IFFALSE 71705
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71652: LD_ADDR_VAR 0 3
71656: PUSH
71657: LD_EXP 43
71661: PUSH
71662: LD_VAR 0 1
71666: ARRAY
71667: PPUSH
71668: LD_INT 30
71670: PUSH
71671: LD_VAR 0 2
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PPUSH
71680: CALL_OW 72
71684: ST_TO_ADDR
// if result then
71685: LD_VAR 0 3
71689: IFFALSE 71705
// result := result [ 1 ] ;
71691: LD_ADDR_VAR 0 3
71695: PUSH
71696: LD_VAR 0 3
71700: PUSH
71701: LD_INT 1
71703: ARRAY
71704: ST_TO_ADDR
// end ; end ;
71705: LD_VAR 0 3
71709: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71710: LD_INT 0
71712: PPUSH
71713: PPUSH
// if not mc_bases then
71714: LD_EXP 43
71718: NOT
71719: IFFALSE 71723
// exit ;
71721: GO 71768
// if mc_bases [ base ] then
71723: LD_EXP 43
71727: PUSH
71728: LD_VAR 0 1
71732: ARRAY
71733: IFFALSE 71768
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71735: LD_ADDR_VAR 0 3
71739: PUSH
71740: LD_EXP 43
71744: PUSH
71745: LD_VAR 0 1
71749: ARRAY
71750: PPUSH
71751: LD_INT 30
71753: PUSH
71754: LD_VAR 0 2
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PPUSH
71763: CALL_OW 72
71767: ST_TO_ADDR
// end ;
71768: LD_VAR 0 3
71772: RET
// export function MC_SetTame ( base , area ) ; begin
71773: LD_INT 0
71775: PPUSH
// if not mc_bases or not base then
71776: LD_EXP 43
71780: NOT
71781: PUSH
71782: LD_VAR 0 1
71786: NOT
71787: OR
71788: IFFALSE 71792
// exit ;
71790: GO 71817
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71792: LD_ADDR_EXP 71
71796: PUSH
71797: LD_EXP 71
71801: PPUSH
71802: LD_VAR 0 1
71806: PPUSH
71807: LD_VAR 0 2
71811: PPUSH
71812: CALL_OW 1
71816: ST_TO_ADDR
// end ;
71817: LD_VAR 0 3
71821: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71822: LD_INT 0
71824: PPUSH
71825: PPUSH
// if not mc_bases or not base then
71826: LD_EXP 43
71830: NOT
71831: PUSH
71832: LD_VAR 0 1
71836: NOT
71837: OR
71838: IFFALSE 71842
// exit ;
71840: GO 71944
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71842: LD_ADDR_VAR 0 4
71846: PUSH
71847: LD_EXP 43
71851: PUSH
71852: LD_VAR 0 1
71856: ARRAY
71857: PPUSH
71858: LD_INT 30
71860: PUSH
71861: LD_VAR 0 2
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PPUSH
71870: CALL_OW 72
71874: ST_TO_ADDR
// if not tmp then
71875: LD_VAR 0 4
71879: NOT
71880: IFFALSE 71884
// exit ;
71882: GO 71944
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71884: LD_ADDR_EXP 75
71888: PUSH
71889: LD_EXP 75
71893: PPUSH
71894: LD_VAR 0 1
71898: PPUSH
71899: LD_EXP 75
71903: PUSH
71904: LD_VAR 0 1
71908: ARRAY
71909: PPUSH
71910: LD_EXP 75
71914: PUSH
71915: LD_VAR 0 1
71919: ARRAY
71920: PUSH
71921: LD_INT 1
71923: PLUS
71924: PPUSH
71925: LD_VAR 0 4
71929: PUSH
71930: LD_INT 1
71932: ARRAY
71933: PPUSH
71934: CALL_OW 2
71938: PPUSH
71939: CALL_OW 1
71943: ST_TO_ADDR
// end ;
71944: LD_VAR 0 3
71948: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71949: LD_INT 0
71951: PPUSH
71952: PPUSH
// if not mc_bases or not base or not kinds then
71953: LD_EXP 43
71957: NOT
71958: PUSH
71959: LD_VAR 0 1
71963: NOT
71964: OR
71965: PUSH
71966: LD_VAR 0 2
71970: NOT
71971: OR
71972: IFFALSE 71976
// exit ;
71974: GO 72037
// for i in kinds do
71976: LD_ADDR_VAR 0 4
71980: PUSH
71981: LD_VAR 0 2
71985: PUSH
71986: FOR_IN
71987: IFFALSE 72035
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71989: LD_ADDR_EXP 77
71993: PUSH
71994: LD_EXP 77
71998: PPUSH
71999: LD_VAR 0 1
72003: PUSH
72004: LD_EXP 77
72008: PUSH
72009: LD_VAR 0 1
72013: ARRAY
72014: PUSH
72015: LD_INT 1
72017: PLUS
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PPUSH
72023: LD_VAR 0 4
72027: PPUSH
72028: CALL 14797 0 3
72032: ST_TO_ADDR
72033: GO 71986
72035: POP
72036: POP
// end ;
72037: LD_VAR 0 3
72041: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
72042: LD_INT 0
72044: PPUSH
// if not mc_bases or not base or not areas then
72045: LD_EXP 43
72049: NOT
72050: PUSH
72051: LD_VAR 0 1
72055: NOT
72056: OR
72057: PUSH
72058: LD_VAR 0 2
72062: NOT
72063: OR
72064: IFFALSE 72068
// exit ;
72066: GO 72093
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
72068: LD_ADDR_EXP 61
72072: PUSH
72073: LD_EXP 61
72077: PPUSH
72078: LD_VAR 0 1
72082: PPUSH
72083: LD_VAR 0 2
72087: PPUSH
72088: CALL_OW 1
72092: ST_TO_ADDR
// end ;
72093: LD_VAR 0 3
72097: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
72098: LD_INT 0
72100: PPUSH
// if not mc_bases or not base or not teleports_exit then
72101: LD_EXP 43
72105: NOT
72106: PUSH
72107: LD_VAR 0 1
72111: NOT
72112: OR
72113: PUSH
72114: LD_VAR 0 2
72118: NOT
72119: OR
72120: IFFALSE 72124
// exit ;
72122: GO 72149
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
72124: LD_ADDR_EXP 78
72128: PUSH
72129: LD_EXP 78
72133: PPUSH
72134: LD_VAR 0 1
72138: PPUSH
72139: LD_VAR 0 2
72143: PPUSH
72144: CALL_OW 1
72148: ST_TO_ADDR
// end ;
72149: LD_VAR 0 3
72153: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
72154: LD_INT 0
72156: PPUSH
72157: PPUSH
72158: PPUSH
// if not mc_bases or not base or not ext_list then
72159: LD_EXP 43
72163: NOT
72164: PUSH
72165: LD_VAR 0 1
72169: NOT
72170: OR
72171: PUSH
72172: LD_VAR 0 5
72176: NOT
72177: OR
72178: IFFALSE 72182
// exit ;
72180: GO 72355
// tmp := GetFacExtXYD ( x , y , d ) ;
72182: LD_ADDR_VAR 0 8
72186: PUSH
72187: LD_VAR 0 2
72191: PPUSH
72192: LD_VAR 0 3
72196: PPUSH
72197: LD_VAR 0 4
72201: PPUSH
72202: CALL 43809 0 3
72206: ST_TO_ADDR
// if not tmp then
72207: LD_VAR 0 8
72211: NOT
72212: IFFALSE 72216
// exit ;
72214: GO 72355
// for i in tmp do
72216: LD_ADDR_VAR 0 7
72220: PUSH
72221: LD_VAR 0 8
72225: PUSH
72226: FOR_IN
72227: IFFALSE 72353
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
72229: LD_ADDR_EXP 48
72233: PUSH
72234: LD_EXP 48
72238: PPUSH
72239: LD_VAR 0 1
72243: PPUSH
72244: LD_EXP 48
72248: PUSH
72249: LD_VAR 0 1
72253: ARRAY
72254: PPUSH
72255: LD_EXP 48
72259: PUSH
72260: LD_VAR 0 1
72264: ARRAY
72265: PUSH
72266: LD_INT 1
72268: PLUS
72269: PPUSH
72270: LD_VAR 0 5
72274: PUSH
72275: LD_INT 1
72277: ARRAY
72278: PUSH
72279: LD_VAR 0 7
72283: PUSH
72284: LD_INT 1
72286: ARRAY
72287: PUSH
72288: LD_VAR 0 7
72292: PUSH
72293: LD_INT 2
72295: ARRAY
72296: PUSH
72297: LD_VAR 0 7
72301: PUSH
72302: LD_INT 3
72304: ARRAY
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: PPUSH
72312: CALL_OW 2
72316: PPUSH
72317: CALL_OW 1
72321: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
72322: LD_ADDR_VAR 0 5
72326: PUSH
72327: LD_VAR 0 5
72331: PPUSH
72332: LD_INT 1
72334: PPUSH
72335: CALL_OW 3
72339: ST_TO_ADDR
// if not ext_list then
72340: LD_VAR 0 5
72344: NOT
72345: IFFALSE 72351
// exit ;
72347: POP
72348: POP
72349: GO 72355
// end ;
72351: GO 72226
72353: POP
72354: POP
// end ;
72355: LD_VAR 0 6
72359: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
72360: LD_INT 0
72362: PPUSH
// if not mc_bases or not base or not weapon_list then
72363: LD_EXP 43
72367: NOT
72368: PUSH
72369: LD_VAR 0 1
72373: NOT
72374: OR
72375: PUSH
72376: LD_VAR 0 2
72380: NOT
72381: OR
72382: IFFALSE 72386
// exit ;
72384: GO 72411
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
72386: LD_ADDR_EXP 82
72390: PUSH
72391: LD_EXP 82
72395: PPUSH
72396: LD_VAR 0 1
72400: PPUSH
72401: LD_VAR 0 2
72405: PPUSH
72406: CALL_OW 1
72410: ST_TO_ADDR
// end ;
72411: LD_VAR 0 3
72415: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
72416: LD_INT 0
72418: PPUSH
// if not mc_bases or not base or not tech_list then
72419: LD_EXP 43
72423: NOT
72424: PUSH
72425: LD_VAR 0 1
72429: NOT
72430: OR
72431: PUSH
72432: LD_VAR 0 2
72436: NOT
72437: OR
72438: IFFALSE 72442
// exit ;
72440: GO 72467
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
72442: LD_ADDR_EXP 70
72446: PUSH
72447: LD_EXP 70
72451: PPUSH
72452: LD_VAR 0 1
72456: PPUSH
72457: LD_VAR 0 2
72461: PPUSH
72462: CALL_OW 1
72466: ST_TO_ADDR
// end ;
72467: LD_VAR 0 3
72471: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72472: LD_INT 0
72474: PPUSH
// if not mc_bases or not parking_area or not base then
72475: LD_EXP 43
72479: NOT
72480: PUSH
72481: LD_VAR 0 2
72485: NOT
72486: OR
72487: PUSH
72488: LD_VAR 0 1
72492: NOT
72493: OR
72494: IFFALSE 72498
// exit ;
72496: GO 72523
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72498: LD_ADDR_EXP 67
72502: PUSH
72503: LD_EXP 67
72507: PPUSH
72508: LD_VAR 0 1
72512: PPUSH
72513: LD_VAR 0 2
72517: PPUSH
72518: CALL_OW 1
72522: ST_TO_ADDR
// end ;
72523: LD_VAR 0 3
72527: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72528: LD_INT 0
72530: PPUSH
// if not mc_bases or not base or not scan_area then
72531: LD_EXP 43
72535: NOT
72536: PUSH
72537: LD_VAR 0 1
72541: NOT
72542: OR
72543: PUSH
72544: LD_VAR 0 2
72548: NOT
72549: OR
72550: IFFALSE 72554
// exit ;
72552: GO 72579
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72554: LD_ADDR_EXP 68
72558: PUSH
72559: LD_EXP 68
72563: PPUSH
72564: LD_VAR 0 1
72568: PPUSH
72569: LD_VAR 0 2
72573: PPUSH
72574: CALL_OW 1
72578: ST_TO_ADDR
// end ;
72579: LD_VAR 0 3
72583: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72584: LD_INT 0
72586: PPUSH
72587: PPUSH
// if not mc_bases or not base then
72588: LD_EXP 43
72592: NOT
72593: PUSH
72594: LD_VAR 0 1
72598: NOT
72599: OR
72600: IFFALSE 72604
// exit ;
72602: GO 72668
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72604: LD_ADDR_VAR 0 3
72608: PUSH
72609: LD_INT 1
72611: PUSH
72612: LD_INT 2
72614: PUSH
72615: LD_INT 3
72617: PUSH
72618: LD_INT 4
72620: PUSH
72621: LD_INT 11
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72631: LD_ADDR_EXP 70
72635: PUSH
72636: LD_EXP 70
72640: PPUSH
72641: LD_VAR 0 1
72645: PPUSH
72646: LD_EXP 70
72650: PUSH
72651: LD_VAR 0 1
72655: ARRAY
72656: PUSH
72657: LD_VAR 0 3
72661: DIFF
72662: PPUSH
72663: CALL_OW 1
72667: ST_TO_ADDR
// end ;
72668: LD_VAR 0 2
72672: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72673: LD_INT 0
72675: PPUSH
// result := mc_vehicles [ base ] ;
72676: LD_ADDR_VAR 0 3
72680: PUSH
72681: LD_EXP 62
72685: PUSH
72686: LD_VAR 0 1
72690: ARRAY
72691: ST_TO_ADDR
// if onlyCombat then
72692: LD_VAR 0 2
72696: IFFALSE 72874
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72698: LD_ADDR_VAR 0 3
72702: PUSH
72703: LD_VAR 0 3
72707: PUSH
72708: LD_VAR 0 3
72712: PPUSH
72713: LD_INT 2
72715: PUSH
72716: LD_INT 34
72718: PUSH
72719: LD_INT 12
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 34
72728: PUSH
72729: LD_INT 51
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 34
72738: PUSH
72739: LD_EXP 87
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 34
72750: PUSH
72751: LD_INT 32
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 34
72760: PUSH
72761: LD_INT 13
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 34
72770: PUSH
72771: LD_INT 52
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 34
72780: PUSH
72781: LD_EXP 92
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: LD_INT 34
72792: PUSH
72793: LD_INT 14
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 34
72802: PUSH
72803: LD_INT 53
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 34
72812: PUSH
72813: LD_EXP 86
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 34
72824: PUSH
72825: LD_INT 31
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 34
72834: PUSH
72835: LD_INT 48
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: LD_INT 34
72844: PUSH
72845: LD_INT 8
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: LIST
72867: PPUSH
72868: CALL_OW 72
72872: DIFF
72873: ST_TO_ADDR
// end ; end_of_file
72874: LD_VAR 0 3
72878: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72879: LD_INT 0
72881: PPUSH
72882: PPUSH
72883: PPUSH
// if not mc_bases or not skirmish then
72884: LD_EXP 43
72888: NOT
72889: PUSH
72890: LD_EXP 41
72894: NOT
72895: OR
72896: IFFALSE 72900
// exit ;
72898: GO 73065
// for i = 1 to mc_bases do
72900: LD_ADDR_VAR 0 4
72904: PUSH
72905: DOUBLE
72906: LD_INT 1
72908: DEC
72909: ST_TO_ADDR
72910: LD_EXP 43
72914: PUSH
72915: FOR_TO
72916: IFFALSE 73063
// begin if sci in mc_bases [ i ] then
72918: LD_VAR 0 2
72922: PUSH
72923: LD_EXP 43
72927: PUSH
72928: LD_VAR 0 4
72932: ARRAY
72933: IN
72934: IFFALSE 73061
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72936: LD_ADDR_EXP 72
72940: PUSH
72941: LD_EXP 72
72945: PPUSH
72946: LD_VAR 0 4
72950: PUSH
72951: LD_EXP 72
72955: PUSH
72956: LD_VAR 0 4
72960: ARRAY
72961: PUSH
72962: LD_INT 1
72964: PLUS
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PPUSH
72970: LD_VAR 0 1
72974: PPUSH
72975: CALL 14797 0 3
72979: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72980: LD_ADDR_VAR 0 5
72984: PUSH
72985: LD_EXP 43
72989: PUSH
72990: LD_VAR 0 4
72994: ARRAY
72995: PPUSH
72996: LD_INT 2
72998: PUSH
72999: LD_INT 30
73001: PUSH
73002: LD_INT 0
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 30
73011: PUSH
73012: LD_INT 1
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: LIST
73023: PPUSH
73024: CALL_OW 72
73028: PPUSH
73029: LD_VAR 0 1
73033: PPUSH
73034: CALL_OW 74
73038: ST_TO_ADDR
// if tmp then
73039: LD_VAR 0 5
73043: IFFALSE 73059
// ComStandNearbyBuilding ( ape , tmp ) ;
73045: LD_VAR 0 1
73049: PPUSH
73050: LD_VAR 0 5
73054: PPUSH
73055: CALL 11411 0 2
// break ;
73059: GO 73063
// end ; end ;
73061: GO 72915
73063: POP
73064: POP
// end ;
73065: LD_VAR 0 3
73069: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
73070: LD_INT 0
73072: PPUSH
73073: PPUSH
73074: PPUSH
// if not mc_bases or not skirmish then
73075: LD_EXP 43
73079: NOT
73080: PUSH
73081: LD_EXP 41
73085: NOT
73086: OR
73087: IFFALSE 73091
// exit ;
73089: GO 73180
// for i = 1 to mc_bases do
73091: LD_ADDR_VAR 0 4
73095: PUSH
73096: DOUBLE
73097: LD_INT 1
73099: DEC
73100: ST_TO_ADDR
73101: LD_EXP 43
73105: PUSH
73106: FOR_TO
73107: IFFALSE 73178
// begin if building in mc_busy_turret_list [ i ] then
73109: LD_VAR 0 1
73113: PUSH
73114: LD_EXP 53
73118: PUSH
73119: LD_VAR 0 4
73123: ARRAY
73124: IN
73125: IFFALSE 73176
// begin tmp := mc_busy_turret_list [ i ] diff building ;
73127: LD_ADDR_VAR 0 5
73131: PUSH
73132: LD_EXP 53
73136: PUSH
73137: LD_VAR 0 4
73141: ARRAY
73142: PUSH
73143: LD_VAR 0 1
73147: DIFF
73148: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
73149: LD_ADDR_EXP 53
73153: PUSH
73154: LD_EXP 53
73158: PPUSH
73159: LD_VAR 0 4
73163: PPUSH
73164: LD_VAR 0 5
73168: PPUSH
73169: CALL_OW 1
73173: ST_TO_ADDR
// break ;
73174: GO 73178
// end ; end ;
73176: GO 73106
73178: POP
73179: POP
// end ;
73180: LD_VAR 0 3
73184: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
73185: LD_INT 0
73187: PPUSH
73188: PPUSH
73189: PPUSH
// if not mc_bases or not skirmish then
73190: LD_EXP 43
73194: NOT
73195: PUSH
73196: LD_EXP 41
73200: NOT
73201: OR
73202: IFFALSE 73206
// exit ;
73204: GO 73405
// for i = 1 to mc_bases do
73206: LD_ADDR_VAR 0 5
73210: PUSH
73211: DOUBLE
73212: LD_INT 1
73214: DEC
73215: ST_TO_ADDR
73216: LD_EXP 43
73220: PUSH
73221: FOR_TO
73222: IFFALSE 73403
// if building in mc_bases [ i ] then
73224: LD_VAR 0 1
73228: PUSH
73229: LD_EXP 43
73233: PUSH
73234: LD_VAR 0 5
73238: ARRAY
73239: IN
73240: IFFALSE 73401
// begin tmp := mc_bases [ i ] diff building ;
73242: LD_ADDR_VAR 0 6
73246: PUSH
73247: LD_EXP 43
73251: PUSH
73252: LD_VAR 0 5
73256: ARRAY
73257: PUSH
73258: LD_VAR 0 1
73262: DIFF
73263: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
73264: LD_ADDR_EXP 43
73268: PUSH
73269: LD_EXP 43
73273: PPUSH
73274: LD_VAR 0 5
73278: PPUSH
73279: LD_VAR 0 6
73283: PPUSH
73284: CALL_OW 1
73288: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
73289: LD_VAR 0 1
73293: PUSH
73294: LD_EXP 51
73298: PUSH
73299: LD_VAR 0 5
73303: ARRAY
73304: IN
73305: IFFALSE 73344
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
73307: LD_ADDR_EXP 51
73311: PUSH
73312: LD_EXP 51
73316: PPUSH
73317: LD_VAR 0 5
73321: PPUSH
73322: LD_EXP 51
73326: PUSH
73327: LD_VAR 0 5
73331: ARRAY
73332: PUSH
73333: LD_VAR 0 1
73337: DIFF
73338: PPUSH
73339: CALL_OW 1
73343: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
73344: LD_VAR 0 1
73348: PUSH
73349: LD_EXP 52
73353: PUSH
73354: LD_VAR 0 5
73358: ARRAY
73359: IN
73360: IFFALSE 73399
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
73362: LD_ADDR_EXP 52
73366: PUSH
73367: LD_EXP 52
73371: PPUSH
73372: LD_VAR 0 5
73376: PPUSH
73377: LD_EXP 52
73381: PUSH
73382: LD_VAR 0 5
73386: ARRAY
73387: PUSH
73388: LD_VAR 0 1
73392: DIFF
73393: PPUSH
73394: CALL_OW 1
73398: ST_TO_ADDR
// break ;
73399: GO 73403
// end ;
73401: GO 73221
73403: POP
73404: POP
// end ;
73405: LD_VAR 0 4
73409: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
73410: LD_INT 0
73412: PPUSH
73413: PPUSH
73414: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
73415: LD_EXP 43
73419: NOT
73420: PUSH
73421: LD_EXP 41
73425: NOT
73426: OR
73427: PUSH
73428: LD_VAR 0 3
73432: PUSH
73433: LD_EXP 69
73437: IN
73438: NOT
73439: OR
73440: IFFALSE 73444
// exit ;
73442: GO 73567
// for i = 1 to mc_vehicles do
73444: LD_ADDR_VAR 0 6
73448: PUSH
73449: DOUBLE
73450: LD_INT 1
73452: DEC
73453: ST_TO_ADDR
73454: LD_EXP 62
73458: PUSH
73459: FOR_TO
73460: IFFALSE 73565
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
73462: LD_VAR 0 2
73466: PUSH
73467: LD_EXP 62
73471: PUSH
73472: LD_VAR 0 6
73476: ARRAY
73477: IN
73478: PUSH
73479: LD_VAR 0 1
73483: PUSH
73484: LD_EXP 62
73488: PUSH
73489: LD_VAR 0 6
73493: ARRAY
73494: IN
73495: OR
73496: IFFALSE 73563
// begin tmp := mc_vehicles [ i ] diff old ;
73498: LD_ADDR_VAR 0 7
73502: PUSH
73503: LD_EXP 62
73507: PUSH
73508: LD_VAR 0 6
73512: ARRAY
73513: PUSH
73514: LD_VAR 0 2
73518: DIFF
73519: ST_TO_ADDR
// tmp := tmp diff new ;
73520: LD_ADDR_VAR 0 7
73524: PUSH
73525: LD_VAR 0 7
73529: PUSH
73530: LD_VAR 0 1
73534: DIFF
73535: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73536: LD_ADDR_EXP 62
73540: PUSH
73541: LD_EXP 62
73545: PPUSH
73546: LD_VAR 0 6
73550: PPUSH
73551: LD_VAR 0 7
73555: PPUSH
73556: CALL_OW 1
73560: ST_TO_ADDR
// break ;
73561: GO 73565
// end ;
73563: GO 73459
73565: POP
73566: POP
// end ;
73567: LD_VAR 0 5
73571: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73572: LD_INT 0
73574: PPUSH
73575: PPUSH
73576: PPUSH
73577: PPUSH
// if not mc_bases or not skirmish then
73578: LD_EXP 43
73582: NOT
73583: PUSH
73584: LD_EXP 41
73588: NOT
73589: OR
73590: IFFALSE 73594
// exit ;
73592: GO 73977
// side := GetSide ( vehicle ) ;
73594: LD_ADDR_VAR 0 5
73598: PUSH
73599: LD_VAR 0 1
73603: PPUSH
73604: CALL_OW 255
73608: ST_TO_ADDR
// for i = 1 to mc_bases do
73609: LD_ADDR_VAR 0 4
73613: PUSH
73614: DOUBLE
73615: LD_INT 1
73617: DEC
73618: ST_TO_ADDR
73619: LD_EXP 43
73623: PUSH
73624: FOR_TO
73625: IFFALSE 73975
// begin if factory in mc_bases [ i ] then
73627: LD_VAR 0 2
73631: PUSH
73632: LD_EXP 43
73636: PUSH
73637: LD_VAR 0 4
73641: ARRAY
73642: IN
73643: IFFALSE 73973
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73645: LD_EXP 65
73649: PUSH
73650: LD_VAR 0 4
73654: ARRAY
73655: PUSH
73656: LD_EXP 54
73660: PUSH
73661: LD_VAR 0 4
73665: ARRAY
73666: LESS
73667: PUSH
73668: LD_VAR 0 1
73672: PPUSH
73673: CALL_OW 264
73677: PUSH
73678: LD_INT 31
73680: PUSH
73681: LD_INT 32
73683: PUSH
73684: LD_INT 51
73686: PUSH
73687: LD_EXP 87
73691: PUSH
73692: LD_INT 12
73694: PUSH
73695: LD_INT 30
73697: PUSH
73698: LD_EXP 86
73702: PUSH
73703: LD_INT 11
73705: PUSH
73706: LD_INT 53
73708: PUSH
73709: LD_INT 14
73711: PUSH
73712: LD_EXP 90
73716: PUSH
73717: LD_INT 29
73719: PUSH
73720: LD_EXP 88
73724: PUSH
73725: LD_INT 13
73727: PUSH
73728: LD_INT 52
73730: PUSH
73731: LD_EXP 92
73735: PUSH
73736: LD_INT 48
73738: PUSH
73739: LD_INT 8
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: IN
73762: NOT
73763: AND
73764: IFFALSE 73812
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73766: LD_ADDR_EXP 65
73770: PUSH
73771: LD_EXP 65
73775: PPUSH
73776: LD_VAR 0 4
73780: PUSH
73781: LD_EXP 65
73785: PUSH
73786: LD_VAR 0 4
73790: ARRAY
73791: PUSH
73792: LD_INT 1
73794: PLUS
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PPUSH
73800: LD_VAR 0 1
73804: PPUSH
73805: CALL 14797 0 3
73809: ST_TO_ADDR
73810: GO 73856
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73812: LD_ADDR_EXP 62
73816: PUSH
73817: LD_EXP 62
73821: PPUSH
73822: LD_VAR 0 4
73826: PUSH
73827: LD_EXP 62
73831: PUSH
73832: LD_VAR 0 4
73836: ARRAY
73837: PUSH
73838: LD_INT 1
73840: PLUS
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PPUSH
73846: LD_VAR 0 1
73850: PPUSH
73851: CALL 14797 0 3
73855: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73856: LD_VAR 0 1
73860: PPUSH
73861: CALL_OW 263
73865: PUSH
73866: LD_INT 2
73868: EQUAL
73869: IFFALSE 73889
// begin repeat wait ( 0 0$1 ) ;
73871: LD_INT 35
73873: PPUSH
73874: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73878: LD_VAR 0 1
73882: PPUSH
73883: CALL_OW 312
73887: IFFALSE 73871
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73889: LD_VAR 0 1
73893: PPUSH
73894: LD_EXP 67
73898: PUSH
73899: LD_VAR 0 4
73903: ARRAY
73904: PPUSH
73905: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73909: LD_VAR 0 1
73913: PPUSH
73914: CALL_OW 263
73918: PUSH
73919: LD_INT 1
73921: NONEQUAL
73922: IFFALSE 73926
// break ;
73924: GO 73975
// repeat wait ( 0 0$1 ) ;
73926: LD_INT 35
73928: PPUSH
73929: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73933: LD_VAR 0 1
73937: PPUSH
73938: LD_EXP 67
73942: PUSH
73943: LD_VAR 0 4
73947: ARRAY
73948: PPUSH
73949: CALL_OW 308
73953: IFFALSE 73926
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73955: LD_VAR 0 1
73959: PPUSH
73960: CALL_OW 311
73964: PPUSH
73965: CALL_OW 121
// exit ;
73969: POP
73970: POP
73971: GO 73977
// end ; end ;
73973: GO 73624
73975: POP
73976: POP
// end ;
73977: LD_VAR 0 3
73981: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73982: LD_INT 0
73984: PPUSH
73985: PPUSH
73986: PPUSH
73987: PPUSH
// if not mc_bases or not skirmish then
73988: LD_EXP 43
73992: NOT
73993: PUSH
73994: LD_EXP 41
73998: NOT
73999: OR
74000: IFFALSE 74004
// exit ;
74002: GO 74357
// repeat wait ( 0 0$1 ) ;
74004: LD_INT 35
74006: PPUSH
74007: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
74011: LD_VAR 0 2
74015: PPUSH
74016: LD_VAR 0 3
74020: PPUSH
74021: CALL_OW 284
74025: IFFALSE 74004
// if GetResourceTypeXY ( x , y ) = mat_artefact then
74027: LD_VAR 0 2
74031: PPUSH
74032: LD_VAR 0 3
74036: PPUSH
74037: CALL_OW 283
74041: PUSH
74042: LD_INT 4
74044: EQUAL
74045: IFFALSE 74049
// exit ;
74047: GO 74357
// for i = 1 to mc_bases do
74049: LD_ADDR_VAR 0 7
74053: PUSH
74054: DOUBLE
74055: LD_INT 1
74057: DEC
74058: ST_TO_ADDR
74059: LD_EXP 43
74063: PUSH
74064: FOR_TO
74065: IFFALSE 74355
// begin if mc_crates_area [ i ] then
74067: LD_EXP 61
74071: PUSH
74072: LD_VAR 0 7
74076: ARRAY
74077: IFFALSE 74188
// for j in mc_crates_area [ i ] do
74079: LD_ADDR_VAR 0 8
74083: PUSH
74084: LD_EXP 61
74088: PUSH
74089: LD_VAR 0 7
74093: ARRAY
74094: PUSH
74095: FOR_IN
74096: IFFALSE 74186
// if InArea ( x , y , j ) then
74098: LD_VAR 0 2
74102: PPUSH
74103: LD_VAR 0 3
74107: PPUSH
74108: LD_VAR 0 8
74112: PPUSH
74113: CALL_OW 309
74117: IFFALSE 74184
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74119: LD_ADDR_EXP 59
74123: PUSH
74124: LD_EXP 59
74128: PPUSH
74129: LD_VAR 0 7
74133: PUSH
74134: LD_EXP 59
74138: PUSH
74139: LD_VAR 0 7
74143: ARRAY
74144: PUSH
74145: LD_INT 1
74147: PLUS
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PPUSH
74153: LD_VAR 0 4
74157: PUSH
74158: LD_VAR 0 2
74162: PUSH
74163: LD_VAR 0 3
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: LIST
74172: PPUSH
74173: CALL 14797 0 3
74177: ST_TO_ADDR
// exit ;
74178: POP
74179: POP
74180: POP
74181: POP
74182: GO 74357
// end ;
74184: GO 74095
74186: POP
74187: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74188: LD_ADDR_VAR 0 9
74192: PUSH
74193: LD_EXP 43
74197: PUSH
74198: LD_VAR 0 7
74202: ARRAY
74203: PPUSH
74204: LD_INT 2
74206: PUSH
74207: LD_INT 30
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 30
74219: PUSH
74220: LD_INT 1
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: LIST
74231: PPUSH
74232: CALL_OW 72
74236: ST_TO_ADDR
// if not depot then
74237: LD_VAR 0 9
74241: NOT
74242: IFFALSE 74246
// continue ;
74244: GO 74064
// for j in depot do
74246: LD_ADDR_VAR 0 8
74250: PUSH
74251: LD_VAR 0 9
74255: PUSH
74256: FOR_IN
74257: IFFALSE 74351
// if GetDistUnitXY ( j , x , y ) < 30 then
74259: LD_VAR 0 8
74263: PPUSH
74264: LD_VAR 0 2
74268: PPUSH
74269: LD_VAR 0 3
74273: PPUSH
74274: CALL_OW 297
74278: PUSH
74279: LD_INT 30
74281: LESS
74282: IFFALSE 74349
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74284: LD_ADDR_EXP 59
74288: PUSH
74289: LD_EXP 59
74293: PPUSH
74294: LD_VAR 0 7
74298: PUSH
74299: LD_EXP 59
74303: PUSH
74304: LD_VAR 0 7
74308: ARRAY
74309: PUSH
74310: LD_INT 1
74312: PLUS
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PPUSH
74318: LD_VAR 0 4
74322: PUSH
74323: LD_VAR 0 2
74327: PUSH
74328: LD_VAR 0 3
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: PPUSH
74338: CALL 14797 0 3
74342: ST_TO_ADDR
// exit ;
74343: POP
74344: POP
74345: POP
74346: POP
74347: GO 74357
// end ;
74349: GO 74256
74351: POP
74352: POP
// end ;
74353: GO 74064
74355: POP
74356: POP
// end ;
74357: LD_VAR 0 6
74361: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
74362: LD_INT 0
74364: PPUSH
74365: PPUSH
74366: PPUSH
74367: PPUSH
// if not mc_bases or not skirmish then
74368: LD_EXP 43
74372: NOT
74373: PUSH
74374: LD_EXP 41
74378: NOT
74379: OR
74380: IFFALSE 74384
// exit ;
74382: GO 74661
// side := GetSide ( lab ) ;
74384: LD_ADDR_VAR 0 4
74388: PUSH
74389: LD_VAR 0 2
74393: PPUSH
74394: CALL_OW 255
74398: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
74399: LD_VAR 0 4
74403: PUSH
74404: LD_EXP 69
74408: IN
74409: NOT
74410: PUSH
74411: LD_EXP 70
74415: NOT
74416: OR
74417: PUSH
74418: LD_EXP 43
74422: NOT
74423: OR
74424: IFFALSE 74428
// exit ;
74426: GO 74661
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
74428: LD_ADDR_EXP 70
74432: PUSH
74433: LD_EXP 70
74437: PPUSH
74438: LD_VAR 0 4
74442: PPUSH
74443: LD_EXP 70
74447: PUSH
74448: LD_VAR 0 4
74452: ARRAY
74453: PUSH
74454: LD_VAR 0 1
74458: DIFF
74459: PPUSH
74460: CALL_OW 1
74464: ST_TO_ADDR
// for i = 1 to mc_bases do
74465: LD_ADDR_VAR 0 5
74469: PUSH
74470: DOUBLE
74471: LD_INT 1
74473: DEC
74474: ST_TO_ADDR
74475: LD_EXP 43
74479: PUSH
74480: FOR_TO
74481: IFFALSE 74659
// begin if lab in mc_bases [ i ] then
74483: LD_VAR 0 2
74487: PUSH
74488: LD_EXP 43
74492: PUSH
74493: LD_VAR 0 5
74497: ARRAY
74498: IN
74499: IFFALSE 74657
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74501: LD_VAR 0 1
74505: PUSH
74506: LD_INT 11
74508: PUSH
74509: LD_INT 4
74511: PUSH
74512: LD_INT 3
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: IN
74524: PUSH
74525: LD_EXP 73
74529: PUSH
74530: LD_VAR 0 5
74534: ARRAY
74535: AND
74536: IFFALSE 74657
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74538: LD_ADDR_VAR 0 6
74542: PUSH
74543: LD_EXP 73
74547: PUSH
74548: LD_VAR 0 5
74552: ARRAY
74553: PUSH
74554: LD_INT 1
74556: ARRAY
74557: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74558: LD_ADDR_EXP 73
74562: PUSH
74563: LD_EXP 73
74567: PPUSH
74568: LD_VAR 0 5
74572: PPUSH
74573: EMPTY
74574: PPUSH
74575: CALL_OW 1
74579: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74580: LD_VAR 0 6
74584: PPUSH
74585: LD_INT 0
74587: PPUSH
74588: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74592: LD_VAR 0 6
74596: PPUSH
74597: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74601: LD_ADDR_EXP 72
74605: PUSH
74606: LD_EXP 72
74610: PPUSH
74611: LD_VAR 0 5
74615: PPUSH
74616: LD_EXP 72
74620: PUSH
74621: LD_VAR 0 5
74625: ARRAY
74626: PPUSH
74627: LD_INT 1
74629: PPUSH
74630: LD_VAR 0 6
74634: PPUSH
74635: CALL_OW 2
74639: PPUSH
74640: CALL_OW 1
74644: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74645: LD_VAR 0 5
74649: PPUSH
74650: LD_INT 112
74652: PPUSH
74653: CALL 51585 0 2
// end ; end ; end ;
74657: GO 74480
74659: POP
74660: POP
// end ;
74661: LD_VAR 0 3
74665: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74666: LD_INT 0
74668: PPUSH
74669: PPUSH
74670: PPUSH
74671: PPUSH
74672: PPUSH
74673: PPUSH
74674: PPUSH
74675: PPUSH
// if not mc_bases or not skirmish then
74676: LD_EXP 43
74680: NOT
74681: PUSH
74682: LD_EXP 41
74686: NOT
74687: OR
74688: IFFALSE 74692
// exit ;
74690: GO 76063
// for i = 1 to mc_bases do
74692: LD_ADDR_VAR 0 3
74696: PUSH
74697: DOUBLE
74698: LD_INT 1
74700: DEC
74701: ST_TO_ADDR
74702: LD_EXP 43
74706: PUSH
74707: FOR_TO
74708: IFFALSE 76061
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74710: LD_VAR 0 1
74714: PUSH
74715: LD_EXP 43
74719: PUSH
74720: LD_VAR 0 3
74724: ARRAY
74725: IN
74726: PUSH
74727: LD_VAR 0 1
74731: PUSH
74732: LD_EXP 50
74736: PUSH
74737: LD_VAR 0 3
74741: ARRAY
74742: IN
74743: OR
74744: PUSH
74745: LD_VAR 0 1
74749: PUSH
74750: LD_EXP 65
74754: PUSH
74755: LD_VAR 0 3
74759: ARRAY
74760: IN
74761: OR
74762: PUSH
74763: LD_VAR 0 1
74767: PUSH
74768: LD_EXP 62
74772: PUSH
74773: LD_VAR 0 3
74777: ARRAY
74778: IN
74779: OR
74780: PUSH
74781: LD_VAR 0 1
74785: PUSH
74786: LD_EXP 72
74790: PUSH
74791: LD_VAR 0 3
74795: ARRAY
74796: IN
74797: OR
74798: PUSH
74799: LD_VAR 0 1
74803: PUSH
74804: LD_EXP 73
74808: PUSH
74809: LD_VAR 0 3
74813: ARRAY
74814: IN
74815: OR
74816: IFFALSE 76059
// begin if un in mc_ape [ i ] then
74818: LD_VAR 0 1
74822: PUSH
74823: LD_EXP 72
74827: PUSH
74828: LD_VAR 0 3
74832: ARRAY
74833: IN
74834: IFFALSE 74873
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74836: LD_ADDR_EXP 72
74840: PUSH
74841: LD_EXP 72
74845: PPUSH
74846: LD_VAR 0 3
74850: PPUSH
74851: LD_EXP 72
74855: PUSH
74856: LD_VAR 0 3
74860: ARRAY
74861: PUSH
74862: LD_VAR 0 1
74866: DIFF
74867: PPUSH
74868: CALL_OW 1
74872: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74873: LD_VAR 0 1
74877: PUSH
74878: LD_EXP 73
74882: PUSH
74883: LD_VAR 0 3
74887: ARRAY
74888: IN
74889: IFFALSE 74913
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74891: LD_ADDR_EXP 73
74895: PUSH
74896: LD_EXP 73
74900: PPUSH
74901: LD_VAR 0 3
74905: PPUSH
74906: EMPTY
74907: PPUSH
74908: CALL_OW 1
74912: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74913: LD_VAR 0 1
74917: PPUSH
74918: CALL_OW 247
74922: PUSH
74923: LD_INT 2
74925: EQUAL
74926: PUSH
74927: LD_VAR 0 1
74931: PPUSH
74932: CALL_OW 110
74936: PUSH
74937: LD_INT 20
74939: EQUAL
74940: PUSH
74941: LD_VAR 0 1
74945: PUSH
74946: LD_EXP 65
74950: PUSH
74951: LD_VAR 0 3
74955: ARRAY
74956: IN
74957: OR
74958: PUSH
74959: LD_VAR 0 1
74963: PPUSH
74964: CALL_OW 264
74968: PUSH
74969: LD_INT 12
74971: PUSH
74972: LD_INT 51
74974: PUSH
74975: LD_EXP 87
74979: PUSH
74980: LD_INT 32
74982: PUSH
74983: LD_INT 13
74985: PUSH
74986: LD_INT 52
74988: PUSH
74989: LD_INT 31
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: LIST
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: IN
75001: OR
75002: AND
75003: IFFALSE 75311
// begin if un in mc_defender [ i ] then
75005: LD_VAR 0 1
75009: PUSH
75010: LD_EXP 65
75014: PUSH
75015: LD_VAR 0 3
75019: ARRAY
75020: IN
75021: IFFALSE 75060
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75023: LD_ADDR_EXP 65
75027: PUSH
75028: LD_EXP 65
75032: PPUSH
75033: LD_VAR 0 3
75037: PPUSH
75038: LD_EXP 65
75042: PUSH
75043: LD_VAR 0 3
75047: ARRAY
75048: PUSH
75049: LD_VAR 0 1
75053: DIFF
75054: PPUSH
75055: CALL_OW 1
75059: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
75060: LD_ADDR_VAR 0 8
75064: PUSH
75065: LD_VAR 0 3
75069: PPUSH
75070: LD_INT 3
75072: PPUSH
75073: CALL 71710 0 2
75077: ST_TO_ADDR
// if fac then
75078: LD_VAR 0 8
75082: IFFALSE 75311
// begin for j in fac do
75084: LD_ADDR_VAR 0 4
75088: PUSH
75089: LD_VAR 0 8
75093: PUSH
75094: FOR_IN
75095: IFFALSE 75309
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
75097: LD_ADDR_VAR 0 9
75101: PUSH
75102: LD_VAR 0 8
75106: PPUSH
75107: LD_VAR 0 1
75111: PPUSH
75112: CALL_OW 265
75116: PPUSH
75117: LD_VAR 0 1
75121: PPUSH
75122: CALL_OW 262
75126: PPUSH
75127: LD_VAR 0 1
75131: PPUSH
75132: CALL_OW 263
75136: PPUSH
75137: LD_VAR 0 1
75141: PPUSH
75142: CALL_OW 264
75146: PPUSH
75147: CALL 12329 0 5
75151: ST_TO_ADDR
// if components then
75152: LD_VAR 0 9
75156: IFFALSE 75307
// begin if GetWeapon ( un ) = ar_control_tower then
75158: LD_VAR 0 1
75162: PPUSH
75163: CALL_OW 264
75167: PUSH
75168: LD_INT 31
75170: EQUAL
75171: IFFALSE 75288
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
75173: LD_VAR 0 1
75177: PPUSH
75178: CALL_OW 311
75182: PPUSH
75183: LD_INT 0
75185: PPUSH
75186: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
75190: LD_ADDR_EXP 83
75194: PUSH
75195: LD_EXP 83
75199: PPUSH
75200: LD_VAR 0 3
75204: PPUSH
75205: LD_EXP 83
75209: PUSH
75210: LD_VAR 0 3
75214: ARRAY
75215: PUSH
75216: LD_VAR 0 1
75220: PPUSH
75221: CALL_OW 311
75225: DIFF
75226: PPUSH
75227: CALL_OW 1
75231: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
75232: LD_ADDR_VAR 0 7
75236: PUSH
75237: LD_EXP 64
75241: PUSH
75242: LD_VAR 0 3
75246: ARRAY
75247: PPUSH
75248: LD_INT 1
75250: PPUSH
75251: LD_VAR 0 9
75255: PPUSH
75256: CALL_OW 2
75260: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75261: LD_ADDR_EXP 64
75265: PUSH
75266: LD_EXP 64
75270: PPUSH
75271: LD_VAR 0 3
75275: PPUSH
75276: LD_VAR 0 7
75280: PPUSH
75281: CALL_OW 1
75285: ST_TO_ADDR
// end else
75286: GO 75305
// MC_InsertProduceList ( i , [ components ] ) ;
75288: LD_VAR 0 3
75292: PPUSH
75293: LD_VAR 0 9
75297: PUSH
75298: EMPTY
75299: LIST
75300: PPUSH
75301: CALL 71255 0 2
// break ;
75305: GO 75309
// end ; end ;
75307: GO 75094
75309: POP
75310: POP
// end ; end ; if GetType ( un ) = unit_building then
75311: LD_VAR 0 1
75315: PPUSH
75316: CALL_OW 247
75320: PUSH
75321: LD_INT 3
75323: EQUAL
75324: IFFALSE 75727
// begin btype := GetBType ( un ) ;
75326: LD_ADDR_VAR 0 5
75330: PUSH
75331: LD_VAR 0 1
75335: PPUSH
75336: CALL_OW 266
75340: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
75341: LD_VAR 0 5
75345: PUSH
75346: LD_INT 29
75348: PUSH
75349: LD_INT 30
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: IN
75356: IFFALSE 75429
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
75358: LD_VAR 0 1
75362: PPUSH
75363: CALL_OW 250
75367: PPUSH
75368: LD_VAR 0 1
75372: PPUSH
75373: CALL_OW 251
75377: PPUSH
75378: LD_VAR 0 1
75382: PPUSH
75383: CALL_OW 255
75387: PPUSH
75388: CALL_OW 440
75392: NOT
75393: IFFALSE 75429
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
75395: LD_VAR 0 1
75399: PPUSH
75400: CALL_OW 250
75404: PPUSH
75405: LD_VAR 0 1
75409: PPUSH
75410: CALL_OW 251
75414: PPUSH
75415: LD_VAR 0 1
75419: PPUSH
75420: CALL_OW 255
75424: PPUSH
75425: CALL_OW 441
// end ; if btype = b_warehouse then
75429: LD_VAR 0 5
75433: PUSH
75434: LD_INT 1
75436: EQUAL
75437: IFFALSE 75455
// begin btype := b_depot ;
75439: LD_ADDR_VAR 0 5
75443: PUSH
75444: LD_INT 0
75446: ST_TO_ADDR
// pos := 1 ;
75447: LD_ADDR_VAR 0 6
75451: PUSH
75452: LD_INT 1
75454: ST_TO_ADDR
// end ; if btype = b_factory then
75455: LD_VAR 0 5
75459: PUSH
75460: LD_INT 3
75462: EQUAL
75463: IFFALSE 75481
// begin btype := b_workshop ;
75465: LD_ADDR_VAR 0 5
75469: PUSH
75470: LD_INT 2
75472: ST_TO_ADDR
// pos := 1 ;
75473: LD_ADDR_VAR 0 6
75477: PUSH
75478: LD_INT 1
75480: ST_TO_ADDR
// end ; if btype = b_barracks then
75481: LD_VAR 0 5
75485: PUSH
75486: LD_INT 5
75488: EQUAL
75489: IFFALSE 75499
// btype := b_armoury ;
75491: LD_ADDR_VAR 0 5
75495: PUSH
75496: LD_INT 4
75498: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75499: LD_VAR 0 5
75503: PUSH
75504: LD_INT 7
75506: PUSH
75507: LD_INT 8
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: IN
75514: IFFALSE 75524
// btype := b_lab ;
75516: LD_ADDR_VAR 0 5
75520: PUSH
75521: LD_INT 6
75523: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75524: LD_ADDR_EXP 48
75528: PUSH
75529: LD_EXP 48
75533: PPUSH
75534: LD_VAR 0 3
75538: PUSH
75539: LD_EXP 48
75543: PUSH
75544: LD_VAR 0 3
75548: ARRAY
75549: PUSH
75550: LD_INT 1
75552: PLUS
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PPUSH
75558: LD_VAR 0 5
75562: PUSH
75563: LD_VAR 0 1
75567: PPUSH
75568: CALL_OW 250
75572: PUSH
75573: LD_VAR 0 1
75577: PPUSH
75578: CALL_OW 251
75582: PUSH
75583: LD_VAR 0 1
75587: PPUSH
75588: CALL_OW 254
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: PPUSH
75599: CALL 14797 0 3
75603: ST_TO_ADDR
// if pos = 1 then
75604: LD_VAR 0 6
75608: PUSH
75609: LD_INT 1
75611: EQUAL
75612: IFFALSE 75727
// begin tmp := mc_build_list [ i ] ;
75614: LD_ADDR_VAR 0 7
75618: PUSH
75619: LD_EXP 48
75623: PUSH
75624: LD_VAR 0 3
75628: ARRAY
75629: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75630: LD_VAR 0 7
75634: PPUSH
75635: LD_INT 2
75637: PUSH
75638: LD_INT 30
75640: PUSH
75641: LD_INT 0
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 30
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: LIST
75662: PPUSH
75663: CALL_OW 72
75667: IFFALSE 75677
// pos := 2 ;
75669: LD_ADDR_VAR 0 6
75673: PUSH
75674: LD_INT 2
75676: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75677: LD_ADDR_VAR 0 7
75681: PUSH
75682: LD_VAR 0 7
75686: PPUSH
75687: LD_VAR 0 6
75691: PPUSH
75692: LD_VAR 0 7
75696: PPUSH
75697: CALL 15123 0 3
75701: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75702: LD_ADDR_EXP 48
75706: PUSH
75707: LD_EXP 48
75711: PPUSH
75712: LD_VAR 0 3
75716: PPUSH
75717: LD_VAR 0 7
75721: PPUSH
75722: CALL_OW 1
75726: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75727: LD_VAR 0 1
75731: PUSH
75732: LD_EXP 43
75736: PUSH
75737: LD_VAR 0 3
75741: ARRAY
75742: IN
75743: IFFALSE 75782
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75745: LD_ADDR_EXP 43
75749: PUSH
75750: LD_EXP 43
75754: PPUSH
75755: LD_VAR 0 3
75759: PPUSH
75760: LD_EXP 43
75764: PUSH
75765: LD_VAR 0 3
75769: ARRAY
75770: PUSH
75771: LD_VAR 0 1
75775: DIFF
75776: PPUSH
75777: CALL_OW 1
75781: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75782: LD_VAR 0 1
75786: PUSH
75787: LD_EXP 50
75791: PUSH
75792: LD_VAR 0 3
75796: ARRAY
75797: IN
75798: IFFALSE 75837
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75800: LD_ADDR_EXP 50
75804: PUSH
75805: LD_EXP 50
75809: PPUSH
75810: LD_VAR 0 3
75814: PPUSH
75815: LD_EXP 50
75819: PUSH
75820: LD_VAR 0 3
75824: ARRAY
75825: PUSH
75826: LD_VAR 0 1
75830: DIFF
75831: PPUSH
75832: CALL_OW 1
75836: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75837: LD_VAR 0 1
75841: PUSH
75842: LD_EXP 62
75846: PUSH
75847: LD_VAR 0 3
75851: ARRAY
75852: IN
75853: IFFALSE 75892
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75855: LD_ADDR_EXP 62
75859: PUSH
75860: LD_EXP 62
75864: PPUSH
75865: LD_VAR 0 3
75869: PPUSH
75870: LD_EXP 62
75874: PUSH
75875: LD_VAR 0 3
75879: ARRAY
75880: PUSH
75881: LD_VAR 0 1
75885: DIFF
75886: PPUSH
75887: CALL_OW 1
75891: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75892: LD_VAR 0 1
75896: PUSH
75897: LD_EXP 65
75901: PUSH
75902: LD_VAR 0 3
75906: ARRAY
75907: IN
75908: IFFALSE 75947
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75910: LD_ADDR_EXP 65
75914: PUSH
75915: LD_EXP 65
75919: PPUSH
75920: LD_VAR 0 3
75924: PPUSH
75925: LD_EXP 65
75929: PUSH
75930: LD_VAR 0 3
75934: ARRAY
75935: PUSH
75936: LD_VAR 0 1
75940: DIFF
75941: PPUSH
75942: CALL_OW 1
75946: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75947: LD_VAR 0 1
75951: PUSH
75952: LD_EXP 52
75956: PUSH
75957: LD_VAR 0 3
75961: ARRAY
75962: IN
75963: IFFALSE 76002
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75965: LD_ADDR_EXP 52
75969: PUSH
75970: LD_EXP 52
75974: PPUSH
75975: LD_VAR 0 3
75979: PPUSH
75980: LD_EXP 52
75984: PUSH
75985: LD_VAR 0 3
75989: ARRAY
75990: PUSH
75991: LD_VAR 0 1
75995: DIFF
75996: PPUSH
75997: CALL_OW 1
76001: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
76002: LD_VAR 0 1
76006: PUSH
76007: LD_EXP 51
76011: PUSH
76012: LD_VAR 0 3
76016: ARRAY
76017: IN
76018: IFFALSE 76057
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
76020: LD_ADDR_EXP 51
76024: PUSH
76025: LD_EXP 51
76029: PPUSH
76030: LD_VAR 0 3
76034: PPUSH
76035: LD_EXP 51
76039: PUSH
76040: LD_VAR 0 3
76044: ARRAY
76045: PUSH
76046: LD_VAR 0 1
76050: DIFF
76051: PPUSH
76052: CALL_OW 1
76056: ST_TO_ADDR
// end ; break ;
76057: GO 76061
// end ;
76059: GO 74707
76061: POP
76062: POP
// end ;
76063: LD_VAR 0 2
76067: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
76068: LD_INT 0
76070: PPUSH
76071: PPUSH
76072: PPUSH
// if not mc_bases or not skirmish then
76073: LD_EXP 43
76077: NOT
76078: PUSH
76079: LD_EXP 41
76083: NOT
76084: OR
76085: IFFALSE 76089
// exit ;
76087: GO 76304
// for i = 1 to mc_bases do
76089: LD_ADDR_VAR 0 3
76093: PUSH
76094: DOUBLE
76095: LD_INT 1
76097: DEC
76098: ST_TO_ADDR
76099: LD_EXP 43
76103: PUSH
76104: FOR_TO
76105: IFFALSE 76302
// begin if building in mc_construct_list [ i ] then
76107: LD_VAR 0 1
76111: PUSH
76112: LD_EXP 50
76116: PUSH
76117: LD_VAR 0 3
76121: ARRAY
76122: IN
76123: IFFALSE 76300
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76125: LD_ADDR_EXP 50
76129: PUSH
76130: LD_EXP 50
76134: PPUSH
76135: LD_VAR 0 3
76139: PPUSH
76140: LD_EXP 50
76144: PUSH
76145: LD_VAR 0 3
76149: ARRAY
76150: PUSH
76151: LD_VAR 0 1
76155: DIFF
76156: PPUSH
76157: CALL_OW 1
76161: ST_TO_ADDR
// if building in mc_lab [ i ] then
76162: LD_VAR 0 1
76166: PUSH
76167: LD_EXP 76
76171: PUSH
76172: LD_VAR 0 3
76176: ARRAY
76177: IN
76178: IFFALSE 76233
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
76180: LD_ADDR_EXP 77
76184: PUSH
76185: LD_EXP 77
76189: PPUSH
76190: LD_VAR 0 3
76194: PPUSH
76195: LD_EXP 77
76199: PUSH
76200: LD_VAR 0 3
76204: ARRAY
76205: PPUSH
76206: LD_INT 1
76208: PPUSH
76209: LD_EXP 77
76213: PUSH
76214: LD_VAR 0 3
76218: ARRAY
76219: PPUSH
76220: LD_INT 0
76222: PPUSH
76223: CALL 14215 0 4
76227: PPUSH
76228: CALL_OW 1
76232: ST_TO_ADDR
// if not building in mc_bases [ i ] then
76233: LD_VAR 0 1
76237: PUSH
76238: LD_EXP 43
76242: PUSH
76243: LD_VAR 0 3
76247: ARRAY
76248: IN
76249: NOT
76250: IFFALSE 76296
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76252: LD_ADDR_EXP 43
76256: PUSH
76257: LD_EXP 43
76261: PPUSH
76262: LD_VAR 0 3
76266: PUSH
76267: LD_EXP 43
76271: PUSH
76272: LD_VAR 0 3
76276: ARRAY
76277: PUSH
76278: LD_INT 1
76280: PLUS
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PPUSH
76286: LD_VAR 0 1
76290: PPUSH
76291: CALL 14797 0 3
76295: ST_TO_ADDR
// exit ;
76296: POP
76297: POP
76298: GO 76304
// end ; end ;
76300: GO 76104
76302: POP
76303: POP
// end ;
76304: LD_VAR 0 2
76308: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
76309: LD_INT 0
76311: PPUSH
76312: PPUSH
76313: PPUSH
76314: PPUSH
76315: PPUSH
76316: PPUSH
76317: PPUSH
// if not mc_bases or not skirmish then
76318: LD_EXP 43
76322: NOT
76323: PUSH
76324: LD_EXP 41
76328: NOT
76329: OR
76330: IFFALSE 76334
// exit ;
76332: GO 76995
// for i = 1 to mc_bases do
76334: LD_ADDR_VAR 0 3
76338: PUSH
76339: DOUBLE
76340: LD_INT 1
76342: DEC
76343: ST_TO_ADDR
76344: LD_EXP 43
76348: PUSH
76349: FOR_TO
76350: IFFALSE 76993
// begin if building in mc_construct_list [ i ] then
76352: LD_VAR 0 1
76356: PUSH
76357: LD_EXP 50
76361: PUSH
76362: LD_VAR 0 3
76366: ARRAY
76367: IN
76368: IFFALSE 76991
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76370: LD_ADDR_EXP 50
76374: PUSH
76375: LD_EXP 50
76379: PPUSH
76380: LD_VAR 0 3
76384: PPUSH
76385: LD_EXP 50
76389: PUSH
76390: LD_VAR 0 3
76394: ARRAY
76395: PUSH
76396: LD_VAR 0 1
76400: DIFF
76401: PPUSH
76402: CALL_OW 1
76406: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76407: LD_ADDR_EXP 43
76411: PUSH
76412: LD_EXP 43
76416: PPUSH
76417: LD_VAR 0 3
76421: PUSH
76422: LD_EXP 43
76426: PUSH
76427: LD_VAR 0 3
76431: ARRAY
76432: PUSH
76433: LD_INT 1
76435: PLUS
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PPUSH
76441: LD_VAR 0 1
76445: PPUSH
76446: CALL 14797 0 3
76450: ST_TO_ADDR
// btype := GetBType ( building ) ;
76451: LD_ADDR_VAR 0 5
76455: PUSH
76456: LD_VAR 0 1
76460: PPUSH
76461: CALL_OW 266
76465: ST_TO_ADDR
// side := GetSide ( building ) ;
76466: LD_ADDR_VAR 0 8
76470: PUSH
76471: LD_VAR 0 1
76475: PPUSH
76476: CALL_OW 255
76480: ST_TO_ADDR
// if btype = b_lab then
76481: LD_VAR 0 5
76485: PUSH
76486: LD_INT 6
76488: EQUAL
76489: IFFALSE 76539
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76491: LD_ADDR_EXP 76
76495: PUSH
76496: LD_EXP 76
76500: PPUSH
76501: LD_VAR 0 3
76505: PUSH
76506: LD_EXP 76
76510: PUSH
76511: LD_VAR 0 3
76515: ARRAY
76516: PUSH
76517: LD_INT 1
76519: PLUS
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PPUSH
76525: LD_VAR 0 1
76529: PPUSH
76530: CALL 14797 0 3
76534: ST_TO_ADDR
// exit ;
76535: POP
76536: POP
76537: GO 76995
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76539: LD_VAR 0 5
76543: PUSH
76544: LD_INT 0
76546: PUSH
76547: LD_INT 2
76549: PUSH
76550: LD_INT 4
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: LIST
76557: IN
76558: IFFALSE 76682
// begin if btype = b_armoury then
76560: LD_VAR 0 5
76564: PUSH
76565: LD_INT 4
76567: EQUAL
76568: IFFALSE 76578
// btype := b_barracks ;
76570: LD_ADDR_VAR 0 5
76574: PUSH
76575: LD_INT 5
76577: ST_TO_ADDR
// if btype = b_depot then
76578: LD_VAR 0 5
76582: PUSH
76583: LD_INT 0
76585: EQUAL
76586: IFFALSE 76596
// btype := b_warehouse ;
76588: LD_ADDR_VAR 0 5
76592: PUSH
76593: LD_INT 1
76595: ST_TO_ADDR
// if btype = b_workshop then
76596: LD_VAR 0 5
76600: PUSH
76601: LD_INT 2
76603: EQUAL
76604: IFFALSE 76614
// btype := b_factory ;
76606: LD_ADDR_VAR 0 5
76610: PUSH
76611: LD_INT 3
76613: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76614: LD_VAR 0 5
76618: PPUSH
76619: LD_VAR 0 8
76623: PPUSH
76624: CALL_OW 323
76628: PUSH
76629: LD_INT 1
76631: EQUAL
76632: IFFALSE 76678
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76634: LD_ADDR_EXP 75
76638: PUSH
76639: LD_EXP 75
76643: PPUSH
76644: LD_VAR 0 3
76648: PUSH
76649: LD_EXP 75
76653: PUSH
76654: LD_VAR 0 3
76658: ARRAY
76659: PUSH
76660: LD_INT 1
76662: PLUS
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PPUSH
76668: LD_VAR 0 1
76672: PPUSH
76673: CALL 14797 0 3
76677: ST_TO_ADDR
// exit ;
76678: POP
76679: POP
76680: GO 76995
// end ; if btype in [ b_bunker , b_turret ] then
76682: LD_VAR 0 5
76686: PUSH
76687: LD_INT 32
76689: PUSH
76690: LD_INT 33
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: IN
76697: IFFALSE 76987
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76699: LD_ADDR_EXP 51
76703: PUSH
76704: LD_EXP 51
76708: PPUSH
76709: LD_VAR 0 3
76713: PUSH
76714: LD_EXP 51
76718: PUSH
76719: LD_VAR 0 3
76723: ARRAY
76724: PUSH
76725: LD_INT 1
76727: PLUS
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PPUSH
76733: LD_VAR 0 1
76737: PPUSH
76738: CALL 14797 0 3
76742: ST_TO_ADDR
// if btype = b_bunker then
76743: LD_VAR 0 5
76747: PUSH
76748: LD_INT 32
76750: EQUAL
76751: IFFALSE 76987
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76753: LD_ADDR_EXP 52
76757: PUSH
76758: LD_EXP 52
76762: PPUSH
76763: LD_VAR 0 3
76767: PUSH
76768: LD_EXP 52
76772: PUSH
76773: LD_VAR 0 3
76777: ARRAY
76778: PUSH
76779: LD_INT 1
76781: PLUS
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PPUSH
76787: LD_VAR 0 1
76791: PPUSH
76792: CALL 14797 0 3
76796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76797: LD_ADDR_VAR 0 6
76801: PUSH
76802: LD_EXP 43
76806: PUSH
76807: LD_VAR 0 3
76811: ARRAY
76812: PPUSH
76813: LD_INT 25
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 3
76825: PUSH
76826: LD_INT 54
76828: PUSH
76829: EMPTY
76830: LIST
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PPUSH
76840: CALL_OW 72
76844: ST_TO_ADDR
// if tmp then
76845: LD_VAR 0 6
76849: IFFALSE 76855
// exit ;
76851: POP
76852: POP
76853: GO 76995
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76855: LD_ADDR_VAR 0 6
76859: PUSH
76860: LD_EXP 43
76864: PUSH
76865: LD_VAR 0 3
76869: ARRAY
76870: PPUSH
76871: LD_INT 2
76873: PUSH
76874: LD_INT 30
76876: PUSH
76877: LD_INT 4
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 30
76886: PUSH
76887: LD_INT 5
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: LIST
76898: PPUSH
76899: CALL_OW 72
76903: ST_TO_ADDR
// if not tmp then
76904: LD_VAR 0 6
76908: NOT
76909: IFFALSE 76915
// exit ;
76911: POP
76912: POP
76913: GO 76995
// for j in tmp do
76915: LD_ADDR_VAR 0 4
76919: PUSH
76920: LD_VAR 0 6
76924: PUSH
76925: FOR_IN
76926: IFFALSE 76985
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76928: LD_ADDR_VAR 0 7
76932: PUSH
76933: LD_VAR 0 4
76937: PPUSH
76938: CALL_OW 313
76942: PPUSH
76943: LD_INT 25
76945: PUSH
76946: LD_INT 1
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PPUSH
76953: CALL_OW 72
76957: ST_TO_ADDR
// if units then
76958: LD_VAR 0 7
76962: IFFALSE 76983
// begin ComExitBuilding ( units [ 1 ] ) ;
76964: LD_VAR 0 7
76968: PUSH
76969: LD_INT 1
76971: ARRAY
76972: PPUSH
76973: CALL_OW 122
// exit ;
76977: POP
76978: POP
76979: POP
76980: POP
76981: GO 76995
// end ; end ;
76983: GO 76925
76985: POP
76986: POP
// end ; end ; exit ;
76987: POP
76988: POP
76989: GO 76995
// end ; end ;
76991: GO 76349
76993: POP
76994: POP
// end ;
76995: LD_VAR 0 2
76999: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
77000: LD_INT 0
77002: PPUSH
77003: PPUSH
77004: PPUSH
77005: PPUSH
77006: PPUSH
77007: PPUSH
77008: PPUSH
// if not mc_bases or not skirmish then
77009: LD_EXP 43
77013: NOT
77014: PUSH
77015: LD_EXP 41
77019: NOT
77020: OR
77021: IFFALSE 77025
// exit ;
77023: GO 77256
// btype := GetBType ( building ) ;
77025: LD_ADDR_VAR 0 6
77029: PUSH
77030: LD_VAR 0 1
77034: PPUSH
77035: CALL_OW 266
77039: ST_TO_ADDR
// x := GetX ( building ) ;
77040: LD_ADDR_VAR 0 7
77044: PUSH
77045: LD_VAR 0 1
77049: PPUSH
77050: CALL_OW 250
77054: ST_TO_ADDR
// y := GetY ( building ) ;
77055: LD_ADDR_VAR 0 8
77059: PUSH
77060: LD_VAR 0 1
77064: PPUSH
77065: CALL_OW 251
77069: ST_TO_ADDR
// d := GetDir ( building ) ;
77070: LD_ADDR_VAR 0 9
77074: PUSH
77075: LD_VAR 0 1
77079: PPUSH
77080: CALL_OW 254
77084: ST_TO_ADDR
// for i = 1 to mc_bases do
77085: LD_ADDR_VAR 0 4
77089: PUSH
77090: DOUBLE
77091: LD_INT 1
77093: DEC
77094: ST_TO_ADDR
77095: LD_EXP 43
77099: PUSH
77100: FOR_TO
77101: IFFALSE 77254
// begin if not mc_build_list [ i ] then
77103: LD_EXP 48
77107: PUSH
77108: LD_VAR 0 4
77112: ARRAY
77113: NOT
77114: IFFALSE 77118
// continue ;
77116: GO 77100
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
77118: LD_VAR 0 6
77122: PUSH
77123: LD_VAR 0 7
77127: PUSH
77128: LD_VAR 0 8
77132: PUSH
77133: LD_VAR 0 9
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: PPUSH
77144: LD_EXP 48
77148: PUSH
77149: LD_VAR 0 4
77153: ARRAY
77154: PUSH
77155: LD_INT 1
77157: ARRAY
77158: PPUSH
77159: CALL 21004 0 2
77163: IFFALSE 77252
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
77165: LD_ADDR_EXP 48
77169: PUSH
77170: LD_EXP 48
77174: PPUSH
77175: LD_VAR 0 4
77179: PPUSH
77180: LD_EXP 48
77184: PUSH
77185: LD_VAR 0 4
77189: ARRAY
77190: PPUSH
77191: LD_INT 1
77193: PPUSH
77194: CALL_OW 3
77198: PPUSH
77199: CALL_OW 1
77203: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
77204: LD_ADDR_EXP 50
77208: PUSH
77209: LD_EXP 50
77213: PPUSH
77214: LD_VAR 0 4
77218: PUSH
77219: LD_EXP 50
77223: PUSH
77224: LD_VAR 0 4
77228: ARRAY
77229: PUSH
77230: LD_INT 1
77232: PLUS
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: PPUSH
77238: LD_VAR 0 1
77242: PPUSH
77243: CALL 14797 0 3
77247: ST_TO_ADDR
// exit ;
77248: POP
77249: POP
77250: GO 77256
// end ; end ;
77252: GO 77100
77254: POP
77255: POP
// end ;
77256: LD_VAR 0 3
77260: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
77261: LD_INT 0
77263: PPUSH
77264: PPUSH
77265: PPUSH
// if not mc_bases or not skirmish then
77266: LD_EXP 43
77270: NOT
77271: PUSH
77272: LD_EXP 41
77276: NOT
77277: OR
77278: IFFALSE 77282
// exit ;
77280: GO 77472
// for i = 1 to mc_bases do
77282: LD_ADDR_VAR 0 4
77286: PUSH
77287: DOUBLE
77288: LD_INT 1
77290: DEC
77291: ST_TO_ADDR
77292: LD_EXP 43
77296: PUSH
77297: FOR_TO
77298: IFFALSE 77385
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
77300: LD_VAR 0 1
77304: PUSH
77305: LD_EXP 51
77309: PUSH
77310: LD_VAR 0 4
77314: ARRAY
77315: IN
77316: PUSH
77317: LD_VAR 0 1
77321: PUSH
77322: LD_EXP 52
77326: PUSH
77327: LD_VAR 0 4
77331: ARRAY
77332: IN
77333: NOT
77334: AND
77335: IFFALSE 77383
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
77337: LD_ADDR_EXP 52
77341: PUSH
77342: LD_EXP 52
77346: PPUSH
77347: LD_VAR 0 4
77351: PUSH
77352: LD_EXP 52
77356: PUSH
77357: LD_VAR 0 4
77361: ARRAY
77362: PUSH
77363: LD_INT 1
77365: PLUS
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PPUSH
77371: LD_VAR 0 1
77375: PPUSH
77376: CALL 14797 0 3
77380: ST_TO_ADDR
// break ;
77381: GO 77385
// end ; end ;
77383: GO 77297
77385: POP
77386: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
77387: LD_VAR 0 1
77391: PPUSH
77392: CALL_OW 257
77396: PUSH
77397: LD_EXP 69
77401: IN
77402: PUSH
77403: LD_VAR 0 1
77407: PPUSH
77408: CALL_OW 266
77412: PUSH
77413: LD_INT 5
77415: EQUAL
77416: AND
77417: PUSH
77418: LD_VAR 0 2
77422: PPUSH
77423: CALL_OW 110
77427: PUSH
77428: LD_INT 18
77430: NONEQUAL
77431: AND
77432: IFFALSE 77472
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
77434: LD_VAR 0 2
77438: PPUSH
77439: CALL_OW 257
77443: PUSH
77444: LD_INT 5
77446: PUSH
77447: LD_INT 8
77449: PUSH
77450: LD_INT 9
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: LIST
77457: IN
77458: IFFALSE 77472
// SetClass ( unit , 1 ) ;
77460: LD_VAR 0 2
77464: PPUSH
77465: LD_INT 1
77467: PPUSH
77468: CALL_OW 336
// end ;
77472: LD_VAR 0 3
77476: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77477: LD_INT 0
77479: PPUSH
77480: PPUSH
// if not mc_bases or not skirmish then
77481: LD_EXP 43
77485: NOT
77486: PUSH
77487: LD_EXP 41
77491: NOT
77492: OR
77493: IFFALSE 77497
// exit ;
77495: GO 77613
// if GetLives ( abandoned_vehicle ) > 250 then
77497: LD_VAR 0 2
77501: PPUSH
77502: CALL_OW 256
77506: PUSH
77507: LD_INT 250
77509: GREATER
77510: IFFALSE 77514
// exit ;
77512: GO 77613
// for i = 1 to mc_bases do
77514: LD_ADDR_VAR 0 6
77518: PUSH
77519: DOUBLE
77520: LD_INT 1
77522: DEC
77523: ST_TO_ADDR
77524: LD_EXP 43
77528: PUSH
77529: FOR_TO
77530: IFFALSE 77611
// begin if driver in mc_bases [ i ] then
77532: LD_VAR 0 1
77536: PUSH
77537: LD_EXP 43
77541: PUSH
77542: LD_VAR 0 6
77546: ARRAY
77547: IN
77548: IFFALSE 77609
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77550: LD_VAR 0 1
77554: PPUSH
77555: LD_EXP 43
77559: PUSH
77560: LD_VAR 0 6
77564: ARRAY
77565: PPUSH
77566: LD_INT 2
77568: PUSH
77569: LD_INT 30
77571: PUSH
77572: LD_INT 0
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 30
77581: PUSH
77582: LD_INT 1
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: LIST
77593: PPUSH
77594: CALL_OW 72
77598: PUSH
77599: LD_INT 1
77601: ARRAY
77602: PPUSH
77603: CALL 47040 0 2
// break ;
77607: GO 77611
// end ; end ;
77609: GO 77529
77611: POP
77612: POP
// end ; end_of_file
77613: LD_VAR 0 5
77617: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77618: LD_INT 0
77620: PPUSH
// ar_miner := 81 ;
77621: LD_ADDR_EXP 93
77625: PUSH
77626: LD_INT 81
77628: ST_TO_ADDR
// ar_crane := 88 ;
77629: LD_ADDR_EXP 92
77633: PUSH
77634: LD_INT 88
77636: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77637: LD_ADDR_EXP 87
77641: PUSH
77642: LD_INT 89
77644: ST_TO_ADDR
// us_hack := 99 ;
77645: LD_ADDR_EXP 88
77649: PUSH
77650: LD_INT 99
77652: ST_TO_ADDR
// us_artillery := 97 ;
77653: LD_ADDR_EXP 89
77657: PUSH
77658: LD_INT 97
77660: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77661: LD_ADDR_EXP 90
77665: PUSH
77666: LD_INT 91
77668: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77669: LD_ADDR_EXP 91
77673: PUSH
77674: LD_INT 92
77676: ST_TO_ADDR
// ru_radar := 98 ;
77677: LD_ADDR_EXP 86
77681: PUSH
77682: LD_INT 98
77684: ST_TO_ADDR
// tech_Artillery := 80 ;
77685: LD_ADDR_EXP 94
77689: PUSH
77690: LD_INT 80
77692: ST_TO_ADDR
// tech_RadMat := 81 ;
77693: LD_ADDR_EXP 95
77697: PUSH
77698: LD_INT 81
77700: ST_TO_ADDR
// tech_BasicTools := 82 ;
77701: LD_ADDR_EXP 96
77705: PUSH
77706: LD_INT 82
77708: ST_TO_ADDR
// tech_Cargo := 83 ;
77709: LD_ADDR_EXP 97
77713: PUSH
77714: LD_INT 83
77716: ST_TO_ADDR
// tech_Track := 84 ;
77717: LD_ADDR_EXP 98
77721: PUSH
77722: LD_INT 84
77724: ST_TO_ADDR
// tech_Crane := 85 ;
77725: LD_ADDR_EXP 99
77729: PUSH
77730: LD_INT 85
77732: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77733: LD_ADDR_EXP 100
77737: PUSH
77738: LD_INT 86
77740: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77741: LD_ADDR_EXP 101
77745: PUSH
77746: LD_INT 87
77748: ST_TO_ADDR
// end ;
77749: LD_VAR 0 1
77753: RET
// every 1 do
77754: GO 77756
77756: DISABLE
// InitGlobalVariables ; end_of_file
77757: CALL 77618 0 0
77761: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77762: LD_INT 0
77764: PPUSH
77765: PPUSH
77766: PPUSH
77767: PPUSH
77768: PPUSH
77769: PPUSH
77770: PPUSH
77771: PPUSH
77772: PPUSH
77773: PPUSH
77774: PPUSH
77775: PPUSH
77776: PPUSH
77777: PPUSH
77778: PPUSH
77779: PPUSH
77780: PPUSH
77781: PPUSH
77782: PPUSH
77783: PPUSH
77784: PPUSH
77785: PPUSH
77786: PPUSH
77787: PPUSH
77788: PPUSH
77789: PPUSH
77790: PPUSH
77791: PPUSH
77792: PPUSH
77793: PPUSH
77794: PPUSH
77795: PPUSH
77796: PPUSH
77797: PPUSH
// if not list then
77798: LD_VAR 0 1
77802: NOT
77803: IFFALSE 77807
// exit ;
77805: GO 82466
// base := list [ 1 ] ;
77807: LD_ADDR_VAR 0 3
77811: PUSH
77812: LD_VAR 0 1
77816: PUSH
77817: LD_INT 1
77819: ARRAY
77820: ST_TO_ADDR
// group := list [ 2 ] ;
77821: LD_ADDR_VAR 0 4
77825: PUSH
77826: LD_VAR 0 1
77830: PUSH
77831: LD_INT 2
77833: ARRAY
77834: ST_TO_ADDR
// path := list [ 3 ] ;
77835: LD_ADDR_VAR 0 5
77839: PUSH
77840: LD_VAR 0 1
77844: PUSH
77845: LD_INT 3
77847: ARRAY
77848: ST_TO_ADDR
// flags := list [ 4 ] ;
77849: LD_ADDR_VAR 0 6
77853: PUSH
77854: LD_VAR 0 1
77858: PUSH
77859: LD_INT 4
77861: ARRAY
77862: ST_TO_ADDR
// mined := [ ] ;
77863: LD_ADDR_VAR 0 27
77867: PUSH
77868: EMPTY
77869: ST_TO_ADDR
// bombed := [ ] ;
77870: LD_ADDR_VAR 0 28
77874: PUSH
77875: EMPTY
77876: ST_TO_ADDR
// healers := [ ] ;
77877: LD_ADDR_VAR 0 31
77881: PUSH
77882: EMPTY
77883: ST_TO_ADDR
// to_heal := [ ] ;
77884: LD_ADDR_VAR 0 30
77888: PUSH
77889: EMPTY
77890: ST_TO_ADDR
// repairs := [ ] ;
77891: LD_ADDR_VAR 0 33
77895: PUSH
77896: EMPTY
77897: ST_TO_ADDR
// to_repair := [ ] ;
77898: LD_ADDR_VAR 0 32
77902: PUSH
77903: EMPTY
77904: ST_TO_ADDR
// if not group or not path then
77905: LD_VAR 0 4
77909: NOT
77910: PUSH
77911: LD_VAR 0 5
77915: NOT
77916: OR
77917: IFFALSE 77921
// exit ;
77919: GO 82466
// side := GetSide ( group [ 1 ] ) ;
77921: LD_ADDR_VAR 0 35
77925: PUSH
77926: LD_VAR 0 4
77930: PUSH
77931: LD_INT 1
77933: ARRAY
77934: PPUSH
77935: CALL_OW 255
77939: ST_TO_ADDR
// if flags then
77940: LD_VAR 0 6
77944: IFFALSE 78088
// begin f_ignore_area := flags [ 1 ] ;
77946: LD_ADDR_VAR 0 17
77950: PUSH
77951: LD_VAR 0 6
77955: PUSH
77956: LD_INT 1
77958: ARRAY
77959: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77960: LD_ADDR_VAR 0 18
77964: PUSH
77965: LD_VAR 0 6
77969: PUSH
77970: LD_INT 2
77972: ARRAY
77973: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77974: LD_ADDR_VAR 0 19
77978: PUSH
77979: LD_VAR 0 6
77983: PUSH
77984: LD_INT 3
77986: ARRAY
77987: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77988: LD_ADDR_VAR 0 20
77992: PUSH
77993: LD_VAR 0 6
77997: PUSH
77998: LD_INT 4
78000: ARRAY
78001: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
78002: LD_ADDR_VAR 0 21
78006: PUSH
78007: LD_VAR 0 6
78011: PUSH
78012: LD_INT 5
78014: ARRAY
78015: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
78016: LD_ADDR_VAR 0 22
78020: PUSH
78021: LD_VAR 0 6
78025: PUSH
78026: LD_INT 6
78028: ARRAY
78029: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
78030: LD_ADDR_VAR 0 23
78034: PUSH
78035: LD_VAR 0 6
78039: PUSH
78040: LD_INT 7
78042: ARRAY
78043: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
78044: LD_ADDR_VAR 0 24
78048: PUSH
78049: LD_VAR 0 6
78053: PUSH
78054: LD_INT 8
78056: ARRAY
78057: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
78058: LD_ADDR_VAR 0 25
78062: PUSH
78063: LD_VAR 0 6
78067: PUSH
78068: LD_INT 9
78070: ARRAY
78071: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
78072: LD_ADDR_VAR 0 26
78076: PUSH
78077: LD_VAR 0 6
78081: PUSH
78082: LD_INT 10
78084: ARRAY
78085: ST_TO_ADDR
// end else
78086: GO 78168
// begin f_ignore_area := false ;
78088: LD_ADDR_VAR 0 17
78092: PUSH
78093: LD_INT 0
78095: ST_TO_ADDR
// f_capture := false ;
78096: LD_ADDR_VAR 0 18
78100: PUSH
78101: LD_INT 0
78103: ST_TO_ADDR
// f_ignore_civ := false ;
78104: LD_ADDR_VAR 0 19
78108: PUSH
78109: LD_INT 0
78111: ST_TO_ADDR
// f_murder := false ;
78112: LD_ADDR_VAR 0 20
78116: PUSH
78117: LD_INT 0
78119: ST_TO_ADDR
// f_mines := false ;
78120: LD_ADDR_VAR 0 21
78124: PUSH
78125: LD_INT 0
78127: ST_TO_ADDR
// f_repair := false ;
78128: LD_ADDR_VAR 0 22
78132: PUSH
78133: LD_INT 0
78135: ST_TO_ADDR
// f_heal := false ;
78136: LD_ADDR_VAR 0 23
78140: PUSH
78141: LD_INT 0
78143: ST_TO_ADDR
// f_spacetime := false ;
78144: LD_ADDR_VAR 0 24
78148: PUSH
78149: LD_INT 0
78151: ST_TO_ADDR
// f_attack_depot := false ;
78152: LD_ADDR_VAR 0 25
78156: PUSH
78157: LD_INT 0
78159: ST_TO_ADDR
// f_crawl := false ;
78160: LD_ADDR_VAR 0 26
78164: PUSH
78165: LD_INT 0
78167: ST_TO_ADDR
// end ; if f_heal then
78168: LD_VAR 0 23
78172: IFFALSE 78199
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
78174: LD_ADDR_VAR 0 31
78178: PUSH
78179: LD_VAR 0 4
78183: PPUSH
78184: LD_INT 25
78186: PUSH
78187: LD_INT 4
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PPUSH
78194: CALL_OW 72
78198: ST_TO_ADDR
// if f_repair then
78199: LD_VAR 0 22
78203: IFFALSE 78230
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
78205: LD_ADDR_VAR 0 33
78209: PUSH
78210: LD_VAR 0 4
78214: PPUSH
78215: LD_INT 25
78217: PUSH
78218: LD_INT 3
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PPUSH
78225: CALL_OW 72
78229: ST_TO_ADDR
// units_path := [ ] ;
78230: LD_ADDR_VAR 0 16
78234: PUSH
78235: EMPTY
78236: ST_TO_ADDR
// for i = 1 to group do
78237: LD_ADDR_VAR 0 7
78241: PUSH
78242: DOUBLE
78243: LD_INT 1
78245: DEC
78246: ST_TO_ADDR
78247: LD_VAR 0 4
78251: PUSH
78252: FOR_TO
78253: IFFALSE 78282
// units_path := Replace ( units_path , i , path ) ;
78255: LD_ADDR_VAR 0 16
78259: PUSH
78260: LD_VAR 0 16
78264: PPUSH
78265: LD_VAR 0 7
78269: PPUSH
78270: LD_VAR 0 5
78274: PPUSH
78275: CALL_OW 1
78279: ST_TO_ADDR
78280: GO 78252
78282: POP
78283: POP
// repeat for i = group downto 1 do
78284: LD_ADDR_VAR 0 7
78288: PUSH
78289: DOUBLE
78290: LD_VAR 0 4
78294: INC
78295: ST_TO_ADDR
78296: LD_INT 1
78298: PUSH
78299: FOR_DOWNTO
78300: IFFALSE 82422
// begin wait ( 5 ) ;
78302: LD_INT 5
78304: PPUSH
78305: CALL_OW 67
// tmp := [ ] ;
78309: LD_ADDR_VAR 0 14
78313: PUSH
78314: EMPTY
78315: ST_TO_ADDR
// attacking := false ;
78316: LD_ADDR_VAR 0 29
78320: PUSH
78321: LD_INT 0
78323: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78324: LD_VAR 0 4
78328: PUSH
78329: LD_VAR 0 7
78333: ARRAY
78334: PPUSH
78335: CALL_OW 301
78339: PUSH
78340: LD_VAR 0 4
78344: PUSH
78345: LD_VAR 0 7
78349: ARRAY
78350: NOT
78351: OR
78352: IFFALSE 78461
// begin if GetType ( group [ i ] ) = unit_human then
78354: LD_VAR 0 4
78358: PUSH
78359: LD_VAR 0 7
78363: ARRAY
78364: PPUSH
78365: CALL_OW 247
78369: PUSH
78370: LD_INT 1
78372: EQUAL
78373: IFFALSE 78419
// begin to_heal := to_heal diff group [ i ] ;
78375: LD_ADDR_VAR 0 30
78379: PUSH
78380: LD_VAR 0 30
78384: PUSH
78385: LD_VAR 0 4
78389: PUSH
78390: LD_VAR 0 7
78394: ARRAY
78395: DIFF
78396: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78397: LD_ADDR_VAR 0 31
78401: PUSH
78402: LD_VAR 0 31
78406: PUSH
78407: LD_VAR 0 4
78411: PUSH
78412: LD_VAR 0 7
78416: ARRAY
78417: DIFF
78418: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78419: LD_ADDR_VAR 0 4
78423: PUSH
78424: LD_VAR 0 4
78428: PPUSH
78429: LD_VAR 0 7
78433: PPUSH
78434: CALL_OW 3
78438: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78439: LD_ADDR_VAR 0 16
78443: PUSH
78444: LD_VAR 0 16
78448: PPUSH
78449: LD_VAR 0 7
78453: PPUSH
78454: CALL_OW 3
78458: ST_TO_ADDR
// continue ;
78459: GO 78299
// end ; if f_repair then
78461: LD_VAR 0 22
78465: IFFALSE 78954
// begin if GetType ( group [ i ] ) = unit_vehicle then
78467: LD_VAR 0 4
78471: PUSH
78472: LD_VAR 0 7
78476: ARRAY
78477: PPUSH
78478: CALL_OW 247
78482: PUSH
78483: LD_INT 2
78485: EQUAL
78486: IFFALSE 78676
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78488: LD_VAR 0 4
78492: PUSH
78493: LD_VAR 0 7
78497: ARRAY
78498: PPUSH
78499: CALL_OW 256
78503: PUSH
78504: LD_INT 700
78506: LESS
78507: PUSH
78508: LD_VAR 0 4
78512: PUSH
78513: LD_VAR 0 7
78517: ARRAY
78518: PUSH
78519: LD_VAR 0 32
78523: IN
78524: NOT
78525: AND
78526: IFFALSE 78550
// to_repair := to_repair union group [ i ] ;
78528: LD_ADDR_VAR 0 32
78532: PUSH
78533: LD_VAR 0 32
78537: PUSH
78538: LD_VAR 0 4
78542: PUSH
78543: LD_VAR 0 7
78547: ARRAY
78548: UNION
78549: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78550: LD_VAR 0 4
78554: PUSH
78555: LD_VAR 0 7
78559: ARRAY
78560: PPUSH
78561: CALL_OW 256
78565: PUSH
78566: LD_INT 1000
78568: EQUAL
78569: PUSH
78570: LD_VAR 0 4
78574: PUSH
78575: LD_VAR 0 7
78579: ARRAY
78580: PUSH
78581: LD_VAR 0 32
78585: IN
78586: AND
78587: IFFALSE 78611
// to_repair := to_repair diff group [ i ] ;
78589: LD_ADDR_VAR 0 32
78593: PUSH
78594: LD_VAR 0 32
78598: PUSH
78599: LD_VAR 0 4
78603: PUSH
78604: LD_VAR 0 7
78608: ARRAY
78609: DIFF
78610: ST_TO_ADDR
// if group [ i ] in to_repair then
78611: LD_VAR 0 4
78615: PUSH
78616: LD_VAR 0 7
78620: ARRAY
78621: PUSH
78622: LD_VAR 0 32
78626: IN
78627: IFFALSE 78674
// begin if not IsInArea ( group [ i ] , f_repair ) then
78629: LD_VAR 0 4
78633: PUSH
78634: LD_VAR 0 7
78638: ARRAY
78639: PPUSH
78640: LD_VAR 0 22
78644: PPUSH
78645: CALL_OW 308
78649: NOT
78650: IFFALSE 78672
// ComMoveToArea ( group [ i ] , f_repair ) ;
78652: LD_VAR 0 4
78656: PUSH
78657: LD_VAR 0 7
78661: ARRAY
78662: PPUSH
78663: LD_VAR 0 22
78667: PPUSH
78668: CALL_OW 113
// continue ;
78672: GO 78299
// end ; end else
78674: GO 78954
// if group [ i ] in repairs then
78676: LD_VAR 0 4
78680: PUSH
78681: LD_VAR 0 7
78685: ARRAY
78686: PUSH
78687: LD_VAR 0 33
78691: IN
78692: IFFALSE 78954
// begin if IsInUnit ( group [ i ] ) then
78694: LD_VAR 0 4
78698: PUSH
78699: LD_VAR 0 7
78703: ARRAY
78704: PPUSH
78705: CALL_OW 310
78709: IFFALSE 78777
// begin z := IsInUnit ( group [ i ] ) ;
78711: LD_ADDR_VAR 0 13
78715: PUSH
78716: LD_VAR 0 4
78720: PUSH
78721: LD_VAR 0 7
78725: ARRAY
78726: PPUSH
78727: CALL_OW 310
78731: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78732: LD_VAR 0 13
78736: PUSH
78737: LD_VAR 0 32
78741: IN
78742: PUSH
78743: LD_VAR 0 13
78747: PPUSH
78748: LD_VAR 0 22
78752: PPUSH
78753: CALL_OW 308
78757: AND
78758: IFFALSE 78775
// ComExitVehicle ( group [ i ] ) ;
78760: LD_VAR 0 4
78764: PUSH
78765: LD_VAR 0 7
78769: ARRAY
78770: PPUSH
78771: CALL_OW 121
// end else
78775: GO 78954
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78777: LD_ADDR_VAR 0 13
78781: PUSH
78782: LD_VAR 0 4
78786: PPUSH
78787: LD_INT 95
78789: PUSH
78790: LD_VAR 0 22
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 58
78801: PUSH
78802: EMPTY
78803: LIST
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PPUSH
78809: CALL_OW 72
78813: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78814: LD_VAR 0 4
78818: PUSH
78819: LD_VAR 0 7
78823: ARRAY
78824: PPUSH
78825: CALL_OW 314
78829: NOT
78830: IFFALSE 78952
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78832: LD_ADDR_VAR 0 10
78836: PUSH
78837: LD_VAR 0 13
78841: PPUSH
78842: LD_VAR 0 4
78846: PUSH
78847: LD_VAR 0 7
78851: ARRAY
78852: PPUSH
78853: CALL_OW 74
78857: ST_TO_ADDR
// if not x then
78858: LD_VAR 0 10
78862: NOT
78863: IFFALSE 78867
// continue ;
78865: GO 78299
// if GetLives ( x ) < 1000 then
78867: LD_VAR 0 10
78871: PPUSH
78872: CALL_OW 256
78876: PUSH
78877: LD_INT 1000
78879: LESS
78880: IFFALSE 78904
// ComRepairVehicle ( group [ i ] , x ) else
78882: LD_VAR 0 4
78886: PUSH
78887: LD_VAR 0 7
78891: ARRAY
78892: PPUSH
78893: LD_VAR 0 10
78897: PPUSH
78898: CALL_OW 129
78902: GO 78952
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78904: LD_VAR 0 23
78908: PUSH
78909: LD_VAR 0 4
78913: PUSH
78914: LD_VAR 0 7
78918: ARRAY
78919: PPUSH
78920: CALL_OW 256
78924: PUSH
78925: LD_INT 1000
78927: LESS
78928: AND
78929: NOT
78930: IFFALSE 78952
// ComEnterUnit ( group [ i ] , x ) ;
78932: LD_VAR 0 4
78936: PUSH
78937: LD_VAR 0 7
78941: ARRAY
78942: PPUSH
78943: LD_VAR 0 10
78947: PPUSH
78948: CALL_OW 120
// end ; continue ;
78952: GO 78299
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78954: LD_VAR 0 23
78958: PUSH
78959: LD_VAR 0 4
78963: PUSH
78964: LD_VAR 0 7
78968: ARRAY
78969: PPUSH
78970: CALL_OW 247
78974: PUSH
78975: LD_INT 1
78977: EQUAL
78978: AND
78979: IFFALSE 79457
// begin if group [ i ] in healers then
78981: LD_VAR 0 4
78985: PUSH
78986: LD_VAR 0 7
78990: ARRAY
78991: PUSH
78992: LD_VAR 0 31
78996: IN
78997: IFFALSE 79270
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78999: LD_VAR 0 4
79003: PUSH
79004: LD_VAR 0 7
79008: ARRAY
79009: PPUSH
79010: LD_VAR 0 23
79014: PPUSH
79015: CALL_OW 308
79019: NOT
79020: PUSH
79021: LD_VAR 0 4
79025: PUSH
79026: LD_VAR 0 7
79030: ARRAY
79031: PPUSH
79032: CALL_OW 314
79036: NOT
79037: AND
79038: IFFALSE 79062
// ComMoveToArea ( group [ i ] , f_heal ) else
79040: LD_VAR 0 4
79044: PUSH
79045: LD_VAR 0 7
79049: ARRAY
79050: PPUSH
79051: LD_VAR 0 23
79055: PPUSH
79056: CALL_OW 113
79060: GO 79268
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
79062: LD_VAR 0 4
79066: PUSH
79067: LD_VAR 0 7
79071: ARRAY
79072: PPUSH
79073: CALL 43502 0 1
79077: PPUSH
79078: CALL_OW 256
79082: PUSH
79083: LD_INT 1000
79085: EQUAL
79086: IFFALSE 79105
// ComStop ( group [ i ] ) else
79088: LD_VAR 0 4
79092: PUSH
79093: LD_VAR 0 7
79097: ARRAY
79098: PPUSH
79099: CALL_OW 141
79103: GO 79268
// if not HasTask ( group [ i ] ) and to_heal then
79105: LD_VAR 0 4
79109: PUSH
79110: LD_VAR 0 7
79114: ARRAY
79115: PPUSH
79116: CALL_OW 314
79120: NOT
79121: PUSH
79122: LD_VAR 0 30
79126: AND
79127: IFFALSE 79268
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
79129: LD_ADDR_VAR 0 13
79133: PUSH
79134: LD_VAR 0 30
79138: PPUSH
79139: LD_INT 3
79141: PUSH
79142: LD_INT 54
79144: PUSH
79145: EMPTY
79146: LIST
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PPUSH
79152: CALL_OW 72
79156: PPUSH
79157: LD_VAR 0 4
79161: PUSH
79162: LD_VAR 0 7
79166: ARRAY
79167: PPUSH
79168: CALL_OW 74
79172: ST_TO_ADDR
// if z then
79173: LD_VAR 0 13
79177: IFFALSE 79268
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
79179: LD_INT 91
79181: PUSH
79182: LD_VAR 0 13
79186: PUSH
79187: LD_INT 10
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 81
79197: PUSH
79198: LD_VAR 0 13
79202: PPUSH
79203: CALL_OW 255
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PPUSH
79216: CALL_OW 69
79220: PUSH
79221: LD_INT 0
79223: EQUAL
79224: IFFALSE 79248
// ComHeal ( group [ i ] , z ) else
79226: LD_VAR 0 4
79230: PUSH
79231: LD_VAR 0 7
79235: ARRAY
79236: PPUSH
79237: LD_VAR 0 13
79241: PPUSH
79242: CALL_OW 128
79246: GO 79268
// ComMoveToArea ( group [ i ] , f_heal ) ;
79248: LD_VAR 0 4
79252: PUSH
79253: LD_VAR 0 7
79257: ARRAY
79258: PPUSH
79259: LD_VAR 0 23
79263: PPUSH
79264: CALL_OW 113
// end ; continue ;
79268: GO 78299
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
79270: LD_VAR 0 4
79274: PUSH
79275: LD_VAR 0 7
79279: ARRAY
79280: PPUSH
79281: CALL_OW 256
79285: PUSH
79286: LD_INT 700
79288: LESS
79289: PUSH
79290: LD_VAR 0 4
79294: PUSH
79295: LD_VAR 0 7
79299: ARRAY
79300: PUSH
79301: LD_VAR 0 30
79305: IN
79306: NOT
79307: AND
79308: IFFALSE 79332
// to_heal := to_heal union group [ i ] ;
79310: LD_ADDR_VAR 0 30
79314: PUSH
79315: LD_VAR 0 30
79319: PUSH
79320: LD_VAR 0 4
79324: PUSH
79325: LD_VAR 0 7
79329: ARRAY
79330: UNION
79331: ST_TO_ADDR
// if group [ i ] in to_heal then
79332: LD_VAR 0 4
79336: PUSH
79337: LD_VAR 0 7
79341: ARRAY
79342: PUSH
79343: LD_VAR 0 30
79347: IN
79348: IFFALSE 79457
// begin if GetLives ( group [ i ] ) = 1000 then
79350: LD_VAR 0 4
79354: PUSH
79355: LD_VAR 0 7
79359: ARRAY
79360: PPUSH
79361: CALL_OW 256
79365: PUSH
79366: LD_INT 1000
79368: EQUAL
79369: IFFALSE 79395
// to_heal := to_heal diff group [ i ] else
79371: LD_ADDR_VAR 0 30
79375: PUSH
79376: LD_VAR 0 30
79380: PUSH
79381: LD_VAR 0 4
79385: PUSH
79386: LD_VAR 0 7
79390: ARRAY
79391: DIFF
79392: ST_TO_ADDR
79393: GO 79457
// begin if not IsInArea ( group [ i ] , to_heal ) then
79395: LD_VAR 0 4
79399: PUSH
79400: LD_VAR 0 7
79404: ARRAY
79405: PPUSH
79406: LD_VAR 0 30
79410: PPUSH
79411: CALL_OW 308
79415: NOT
79416: IFFALSE 79440
// ComMoveToArea ( group [ i ] , f_heal ) else
79418: LD_VAR 0 4
79422: PUSH
79423: LD_VAR 0 7
79427: ARRAY
79428: PPUSH
79429: LD_VAR 0 23
79433: PPUSH
79434: CALL_OW 113
79438: GO 79455
// ComHold ( group [ i ] ) ;
79440: LD_VAR 0 4
79444: PUSH
79445: LD_VAR 0 7
79449: ARRAY
79450: PPUSH
79451: CALL_OW 140
// continue ;
79455: GO 78299
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79457: LD_VAR 0 4
79461: PUSH
79462: LD_VAR 0 7
79466: ARRAY
79467: PPUSH
79468: LD_INT 10
79470: PPUSH
79471: CALL 41922 0 2
79475: NOT
79476: PUSH
79477: LD_VAR 0 16
79481: PUSH
79482: LD_VAR 0 7
79486: ARRAY
79487: PUSH
79488: EMPTY
79489: EQUAL
79490: NOT
79491: AND
79492: IFFALSE 79758
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79494: LD_VAR 0 4
79498: PUSH
79499: LD_VAR 0 7
79503: ARRAY
79504: PPUSH
79505: CALL_OW 262
79509: PUSH
79510: LD_INT 1
79512: PUSH
79513: LD_INT 2
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: IN
79520: IFFALSE 79561
// if GetFuel ( group [ i ] ) < 10 then
79522: LD_VAR 0 4
79526: PUSH
79527: LD_VAR 0 7
79531: ARRAY
79532: PPUSH
79533: CALL_OW 261
79537: PUSH
79538: LD_INT 10
79540: LESS
79541: IFFALSE 79561
// SetFuel ( group [ i ] , 12 ) ;
79543: LD_VAR 0 4
79547: PUSH
79548: LD_VAR 0 7
79552: ARRAY
79553: PPUSH
79554: LD_INT 12
79556: PPUSH
79557: CALL_OW 240
// if units_path [ i ] then
79561: LD_VAR 0 16
79565: PUSH
79566: LD_VAR 0 7
79570: ARRAY
79571: IFFALSE 79756
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79573: LD_VAR 0 4
79577: PUSH
79578: LD_VAR 0 7
79582: ARRAY
79583: PPUSH
79584: LD_VAR 0 16
79588: PUSH
79589: LD_VAR 0 7
79593: ARRAY
79594: PUSH
79595: LD_INT 1
79597: ARRAY
79598: PUSH
79599: LD_INT 1
79601: ARRAY
79602: PPUSH
79603: LD_VAR 0 16
79607: PUSH
79608: LD_VAR 0 7
79612: ARRAY
79613: PUSH
79614: LD_INT 1
79616: ARRAY
79617: PUSH
79618: LD_INT 2
79620: ARRAY
79621: PPUSH
79622: CALL_OW 297
79626: PUSH
79627: LD_INT 6
79629: GREATER
79630: IFFALSE 79705
// begin if not HasTask ( group [ i ] ) then
79632: LD_VAR 0 4
79636: PUSH
79637: LD_VAR 0 7
79641: ARRAY
79642: PPUSH
79643: CALL_OW 314
79647: NOT
79648: IFFALSE 79703
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79650: LD_VAR 0 4
79654: PUSH
79655: LD_VAR 0 7
79659: ARRAY
79660: PPUSH
79661: LD_VAR 0 16
79665: PUSH
79666: LD_VAR 0 7
79670: ARRAY
79671: PUSH
79672: LD_INT 1
79674: ARRAY
79675: PUSH
79676: LD_INT 1
79678: ARRAY
79679: PPUSH
79680: LD_VAR 0 16
79684: PUSH
79685: LD_VAR 0 7
79689: ARRAY
79690: PUSH
79691: LD_INT 1
79693: ARRAY
79694: PUSH
79695: LD_INT 2
79697: ARRAY
79698: PPUSH
79699: CALL_OW 114
// end else
79703: GO 79756
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79705: LD_ADDR_VAR 0 15
79709: PUSH
79710: LD_VAR 0 16
79714: PUSH
79715: LD_VAR 0 7
79719: ARRAY
79720: PPUSH
79721: LD_INT 1
79723: PPUSH
79724: CALL_OW 3
79728: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79729: LD_ADDR_VAR 0 16
79733: PUSH
79734: LD_VAR 0 16
79738: PPUSH
79739: LD_VAR 0 7
79743: PPUSH
79744: LD_VAR 0 15
79748: PPUSH
79749: CALL_OW 1
79753: ST_TO_ADDR
// continue ;
79754: GO 78299
// end ; end ; end else
79756: GO 82420
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79758: LD_ADDR_VAR 0 14
79762: PUSH
79763: LD_INT 81
79765: PUSH
79766: LD_VAR 0 4
79770: PUSH
79771: LD_VAR 0 7
79775: ARRAY
79776: PPUSH
79777: CALL_OW 255
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PPUSH
79786: CALL_OW 69
79790: ST_TO_ADDR
// if not tmp then
79791: LD_VAR 0 14
79795: NOT
79796: IFFALSE 79800
// continue ;
79798: GO 78299
// if f_ignore_area then
79800: LD_VAR 0 17
79804: IFFALSE 79892
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79806: LD_ADDR_VAR 0 15
79810: PUSH
79811: LD_VAR 0 14
79815: PPUSH
79816: LD_INT 3
79818: PUSH
79819: LD_INT 92
79821: PUSH
79822: LD_VAR 0 17
79826: PUSH
79827: LD_INT 1
79829: ARRAY
79830: PUSH
79831: LD_VAR 0 17
79835: PUSH
79836: LD_INT 2
79838: ARRAY
79839: PUSH
79840: LD_VAR 0 17
79844: PUSH
79845: LD_INT 3
79847: ARRAY
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PPUSH
79859: CALL_OW 72
79863: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79864: LD_VAR 0 14
79868: PUSH
79869: LD_VAR 0 15
79873: DIFF
79874: IFFALSE 79892
// tmp := tmp diff tmp2 ;
79876: LD_ADDR_VAR 0 14
79880: PUSH
79881: LD_VAR 0 14
79885: PUSH
79886: LD_VAR 0 15
79890: DIFF
79891: ST_TO_ADDR
// end ; if not f_murder then
79892: LD_VAR 0 20
79896: NOT
79897: IFFALSE 79955
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79899: LD_ADDR_VAR 0 15
79903: PUSH
79904: LD_VAR 0 14
79908: PPUSH
79909: LD_INT 3
79911: PUSH
79912: LD_INT 50
79914: PUSH
79915: EMPTY
79916: LIST
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PPUSH
79922: CALL_OW 72
79926: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79927: LD_VAR 0 14
79931: PUSH
79932: LD_VAR 0 15
79936: DIFF
79937: IFFALSE 79955
// tmp := tmp diff tmp2 ;
79939: LD_ADDR_VAR 0 14
79943: PUSH
79944: LD_VAR 0 14
79948: PUSH
79949: LD_VAR 0 15
79953: DIFF
79954: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79955: LD_ADDR_VAR 0 14
79959: PUSH
79960: LD_VAR 0 4
79964: PUSH
79965: LD_VAR 0 7
79969: ARRAY
79970: PPUSH
79971: LD_VAR 0 14
79975: PPUSH
79976: LD_INT 1
79978: PPUSH
79979: LD_INT 1
79981: PPUSH
79982: CALL 15232 0 4
79986: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79987: LD_VAR 0 4
79991: PUSH
79992: LD_VAR 0 7
79996: ARRAY
79997: PPUSH
79998: CALL_OW 257
80002: PUSH
80003: LD_INT 1
80005: EQUAL
80006: IFFALSE 80454
// begin if WantPlant ( group [ i ] ) then
80008: LD_VAR 0 4
80012: PUSH
80013: LD_VAR 0 7
80017: ARRAY
80018: PPUSH
80019: CALL 14733 0 1
80023: IFFALSE 80027
// continue ;
80025: GO 78299
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
80027: LD_VAR 0 18
80031: PUSH
80032: LD_VAR 0 4
80036: PUSH
80037: LD_VAR 0 7
80041: ARRAY
80042: PPUSH
80043: CALL_OW 310
80047: NOT
80048: AND
80049: PUSH
80050: LD_VAR 0 14
80054: PUSH
80055: LD_INT 1
80057: ARRAY
80058: PUSH
80059: LD_VAR 0 14
80063: PPUSH
80064: LD_INT 21
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 58
80076: PUSH
80077: EMPTY
80078: LIST
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PPUSH
80084: CALL_OW 72
80088: IN
80089: AND
80090: IFFALSE 80126
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
80092: LD_VAR 0 4
80096: PUSH
80097: LD_VAR 0 7
80101: ARRAY
80102: PPUSH
80103: LD_VAR 0 14
80107: PUSH
80108: LD_INT 1
80110: ARRAY
80111: PPUSH
80112: CALL_OW 120
// attacking := true ;
80116: LD_ADDR_VAR 0 29
80120: PUSH
80121: LD_INT 1
80123: ST_TO_ADDR
// continue ;
80124: GO 78299
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
80126: LD_VAR 0 26
80130: PUSH
80131: LD_VAR 0 4
80135: PUSH
80136: LD_VAR 0 7
80140: ARRAY
80141: PPUSH
80142: CALL_OW 257
80146: PUSH
80147: LD_INT 1
80149: EQUAL
80150: AND
80151: PUSH
80152: LD_VAR 0 4
80156: PUSH
80157: LD_VAR 0 7
80161: ARRAY
80162: PPUSH
80163: CALL_OW 256
80167: PUSH
80168: LD_INT 800
80170: LESS
80171: AND
80172: PUSH
80173: LD_VAR 0 4
80177: PUSH
80178: LD_VAR 0 7
80182: ARRAY
80183: PPUSH
80184: CALL_OW 318
80188: NOT
80189: AND
80190: IFFALSE 80207
// ComCrawl ( group [ i ] ) ;
80192: LD_VAR 0 4
80196: PUSH
80197: LD_VAR 0 7
80201: ARRAY
80202: PPUSH
80203: CALL_OW 137
// if f_mines then
80207: LD_VAR 0 21
80211: IFFALSE 80454
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
80213: LD_VAR 0 14
80217: PUSH
80218: LD_INT 1
80220: ARRAY
80221: PPUSH
80222: CALL_OW 247
80226: PUSH
80227: LD_INT 3
80229: EQUAL
80230: PUSH
80231: LD_VAR 0 14
80235: PUSH
80236: LD_INT 1
80238: ARRAY
80239: PUSH
80240: LD_VAR 0 27
80244: IN
80245: NOT
80246: AND
80247: IFFALSE 80454
// begin x := GetX ( tmp [ 1 ] ) ;
80249: LD_ADDR_VAR 0 10
80253: PUSH
80254: LD_VAR 0 14
80258: PUSH
80259: LD_INT 1
80261: ARRAY
80262: PPUSH
80263: CALL_OW 250
80267: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
80268: LD_ADDR_VAR 0 11
80272: PUSH
80273: LD_VAR 0 14
80277: PUSH
80278: LD_INT 1
80280: ARRAY
80281: PPUSH
80282: CALL_OW 251
80286: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
80287: LD_ADDR_VAR 0 12
80291: PUSH
80292: LD_VAR 0 4
80296: PUSH
80297: LD_VAR 0 7
80301: ARRAY
80302: PPUSH
80303: CALL 42007 0 1
80307: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80308: LD_VAR 0 4
80312: PUSH
80313: LD_VAR 0 7
80317: ARRAY
80318: PPUSH
80319: LD_VAR 0 10
80323: PPUSH
80324: LD_VAR 0 11
80328: PPUSH
80329: LD_VAR 0 14
80333: PUSH
80334: LD_INT 1
80336: ARRAY
80337: PPUSH
80338: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80342: LD_VAR 0 4
80346: PUSH
80347: LD_VAR 0 7
80351: ARRAY
80352: PPUSH
80353: LD_VAR 0 10
80357: PPUSH
80358: LD_VAR 0 12
80362: PPUSH
80363: LD_INT 7
80365: PPUSH
80366: CALL_OW 272
80370: PPUSH
80371: LD_VAR 0 11
80375: PPUSH
80376: LD_VAR 0 12
80380: PPUSH
80381: LD_INT 7
80383: PPUSH
80384: CALL_OW 273
80388: PPUSH
80389: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80393: LD_VAR 0 4
80397: PUSH
80398: LD_VAR 0 7
80402: ARRAY
80403: PPUSH
80404: LD_INT 71
80406: PPUSH
80407: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80411: LD_ADDR_VAR 0 27
80415: PUSH
80416: LD_VAR 0 27
80420: PPUSH
80421: LD_VAR 0 27
80425: PUSH
80426: LD_INT 1
80428: PLUS
80429: PPUSH
80430: LD_VAR 0 14
80434: PUSH
80435: LD_INT 1
80437: ARRAY
80438: PPUSH
80439: CALL_OW 1
80443: ST_TO_ADDR
// attacking := true ;
80444: LD_ADDR_VAR 0 29
80448: PUSH
80449: LD_INT 1
80451: ST_TO_ADDR
// continue ;
80452: GO 78299
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80454: LD_VAR 0 4
80458: PUSH
80459: LD_VAR 0 7
80463: ARRAY
80464: PPUSH
80465: CALL_OW 257
80469: PUSH
80470: LD_INT 17
80472: EQUAL
80473: PUSH
80474: LD_VAR 0 4
80478: PUSH
80479: LD_VAR 0 7
80483: ARRAY
80484: PPUSH
80485: CALL_OW 110
80489: PUSH
80490: LD_INT 71
80492: EQUAL
80493: NOT
80494: AND
80495: IFFALSE 80641
// begin attacking := false ;
80497: LD_ADDR_VAR 0 29
80501: PUSH
80502: LD_INT 0
80504: ST_TO_ADDR
// k := 5 ;
80505: LD_ADDR_VAR 0 9
80509: PUSH
80510: LD_INT 5
80512: ST_TO_ADDR
// if tmp < k then
80513: LD_VAR 0 14
80517: PUSH
80518: LD_VAR 0 9
80522: LESS
80523: IFFALSE 80535
// k := tmp ;
80525: LD_ADDR_VAR 0 9
80529: PUSH
80530: LD_VAR 0 14
80534: ST_TO_ADDR
// for j = 1 to k do
80535: LD_ADDR_VAR 0 8
80539: PUSH
80540: DOUBLE
80541: LD_INT 1
80543: DEC
80544: ST_TO_ADDR
80545: LD_VAR 0 9
80549: PUSH
80550: FOR_TO
80551: IFFALSE 80639
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80553: LD_VAR 0 14
80557: PUSH
80558: LD_VAR 0 8
80562: ARRAY
80563: PUSH
80564: LD_VAR 0 14
80568: PPUSH
80569: LD_INT 58
80571: PUSH
80572: EMPTY
80573: LIST
80574: PPUSH
80575: CALL_OW 72
80579: IN
80580: NOT
80581: IFFALSE 80637
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80583: LD_VAR 0 4
80587: PUSH
80588: LD_VAR 0 7
80592: ARRAY
80593: PPUSH
80594: LD_VAR 0 14
80598: PUSH
80599: LD_VAR 0 8
80603: ARRAY
80604: PPUSH
80605: CALL_OW 115
// attacking := true ;
80609: LD_ADDR_VAR 0 29
80613: PUSH
80614: LD_INT 1
80616: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80617: LD_VAR 0 4
80621: PUSH
80622: LD_VAR 0 7
80626: ARRAY
80627: PPUSH
80628: LD_INT 71
80630: PPUSH
80631: CALL_OW 109
// continue ;
80635: GO 80550
// end ; end ;
80637: GO 80550
80639: POP
80640: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80641: LD_VAR 0 4
80645: PUSH
80646: LD_VAR 0 7
80650: ARRAY
80651: PPUSH
80652: CALL_OW 257
80656: PUSH
80657: LD_INT 8
80659: EQUAL
80660: PUSH
80661: LD_VAR 0 4
80665: PUSH
80666: LD_VAR 0 7
80670: ARRAY
80671: PPUSH
80672: CALL_OW 264
80676: PUSH
80677: LD_INT 28
80679: PUSH
80680: LD_INT 45
80682: PUSH
80683: LD_INT 7
80685: PUSH
80686: LD_INT 47
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: IN
80695: OR
80696: IFFALSE 80952
// begin attacking := false ;
80698: LD_ADDR_VAR 0 29
80702: PUSH
80703: LD_INT 0
80705: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80706: LD_VAR 0 14
80710: PUSH
80711: LD_INT 1
80713: ARRAY
80714: PPUSH
80715: CALL_OW 266
80719: PUSH
80720: LD_INT 32
80722: PUSH
80723: LD_INT 31
80725: PUSH
80726: LD_INT 33
80728: PUSH
80729: LD_INT 4
80731: PUSH
80732: LD_INT 5
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: IN
80742: IFFALSE 80928
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80744: LD_ADDR_VAR 0 9
80748: PUSH
80749: LD_VAR 0 14
80753: PUSH
80754: LD_INT 1
80756: ARRAY
80757: PPUSH
80758: CALL_OW 266
80762: PPUSH
80763: LD_VAR 0 14
80767: PUSH
80768: LD_INT 1
80770: ARRAY
80771: PPUSH
80772: CALL_OW 250
80776: PPUSH
80777: LD_VAR 0 14
80781: PUSH
80782: LD_INT 1
80784: ARRAY
80785: PPUSH
80786: CALL_OW 251
80790: PPUSH
80791: LD_VAR 0 14
80795: PUSH
80796: LD_INT 1
80798: ARRAY
80799: PPUSH
80800: CALL_OW 254
80804: PPUSH
80805: LD_VAR 0 14
80809: PUSH
80810: LD_INT 1
80812: ARRAY
80813: PPUSH
80814: CALL_OW 248
80818: PPUSH
80819: LD_INT 0
80821: PPUSH
80822: CALL 23377 0 6
80826: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80827: LD_ADDR_VAR 0 8
80831: PUSH
80832: LD_VAR 0 4
80836: PUSH
80837: LD_VAR 0 7
80841: ARRAY
80842: PPUSH
80843: LD_VAR 0 9
80847: PPUSH
80848: CALL 42047 0 2
80852: ST_TO_ADDR
// if j then
80853: LD_VAR 0 8
80857: IFFALSE 80926
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80859: LD_VAR 0 8
80863: PUSH
80864: LD_INT 1
80866: ARRAY
80867: PPUSH
80868: LD_VAR 0 8
80872: PUSH
80873: LD_INT 2
80875: ARRAY
80876: PPUSH
80877: CALL_OW 488
80881: IFFALSE 80926
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80883: LD_VAR 0 4
80887: PUSH
80888: LD_VAR 0 7
80892: ARRAY
80893: PPUSH
80894: LD_VAR 0 8
80898: PUSH
80899: LD_INT 1
80901: ARRAY
80902: PPUSH
80903: LD_VAR 0 8
80907: PUSH
80908: LD_INT 2
80910: ARRAY
80911: PPUSH
80912: CALL_OW 116
// attacking := true ;
80916: LD_ADDR_VAR 0 29
80920: PUSH
80921: LD_INT 1
80923: ST_TO_ADDR
// continue ;
80924: GO 78299
// end ; end else
80926: GO 80952
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80928: LD_VAR 0 4
80932: PUSH
80933: LD_VAR 0 7
80937: ARRAY
80938: PPUSH
80939: LD_VAR 0 14
80943: PUSH
80944: LD_INT 1
80946: ARRAY
80947: PPUSH
80948: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80952: LD_VAR 0 4
80956: PUSH
80957: LD_VAR 0 7
80961: ARRAY
80962: PPUSH
80963: CALL_OW 265
80967: PUSH
80968: LD_INT 11
80970: EQUAL
80971: IFFALSE 81249
// begin k := 10 ;
80973: LD_ADDR_VAR 0 9
80977: PUSH
80978: LD_INT 10
80980: ST_TO_ADDR
// x := 0 ;
80981: LD_ADDR_VAR 0 10
80985: PUSH
80986: LD_INT 0
80988: ST_TO_ADDR
// if tmp < k then
80989: LD_VAR 0 14
80993: PUSH
80994: LD_VAR 0 9
80998: LESS
80999: IFFALSE 81011
// k := tmp ;
81001: LD_ADDR_VAR 0 9
81005: PUSH
81006: LD_VAR 0 14
81010: ST_TO_ADDR
// for j = k downto 1 do
81011: LD_ADDR_VAR 0 8
81015: PUSH
81016: DOUBLE
81017: LD_VAR 0 9
81021: INC
81022: ST_TO_ADDR
81023: LD_INT 1
81025: PUSH
81026: FOR_DOWNTO
81027: IFFALSE 81102
// begin if GetType ( tmp [ j ] ) = unit_human then
81029: LD_VAR 0 14
81033: PUSH
81034: LD_VAR 0 8
81038: ARRAY
81039: PPUSH
81040: CALL_OW 247
81044: PUSH
81045: LD_INT 1
81047: EQUAL
81048: IFFALSE 81100
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
81050: LD_VAR 0 4
81054: PUSH
81055: LD_VAR 0 7
81059: ARRAY
81060: PPUSH
81061: LD_VAR 0 14
81065: PUSH
81066: LD_VAR 0 8
81070: ARRAY
81071: PPUSH
81072: CALL 42318 0 2
// x := tmp [ j ] ;
81076: LD_ADDR_VAR 0 10
81080: PUSH
81081: LD_VAR 0 14
81085: PUSH
81086: LD_VAR 0 8
81090: ARRAY
81091: ST_TO_ADDR
// attacking := true ;
81092: LD_ADDR_VAR 0 29
81096: PUSH
81097: LD_INT 1
81099: ST_TO_ADDR
// end ; end ;
81100: GO 81026
81102: POP
81103: POP
// if not x then
81104: LD_VAR 0 10
81108: NOT
81109: IFFALSE 81249
// begin attacking := true ;
81111: LD_ADDR_VAR 0 29
81115: PUSH
81116: LD_INT 1
81118: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
81119: LD_VAR 0 4
81123: PUSH
81124: LD_VAR 0 7
81128: ARRAY
81129: PPUSH
81130: CALL_OW 250
81134: PPUSH
81135: LD_VAR 0 4
81139: PUSH
81140: LD_VAR 0 7
81144: ARRAY
81145: PPUSH
81146: CALL_OW 251
81150: PPUSH
81151: CALL_OW 546
81155: PUSH
81156: LD_INT 2
81158: ARRAY
81159: PUSH
81160: LD_VAR 0 14
81164: PUSH
81165: LD_INT 1
81167: ARRAY
81168: PPUSH
81169: CALL_OW 250
81173: PPUSH
81174: LD_VAR 0 14
81178: PUSH
81179: LD_INT 1
81181: ARRAY
81182: PPUSH
81183: CALL_OW 251
81187: PPUSH
81188: CALL_OW 546
81192: PUSH
81193: LD_INT 2
81195: ARRAY
81196: EQUAL
81197: IFFALSE 81225
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
81199: LD_VAR 0 4
81203: PUSH
81204: LD_VAR 0 7
81208: ARRAY
81209: PPUSH
81210: LD_VAR 0 14
81214: PUSH
81215: LD_INT 1
81217: ARRAY
81218: PPUSH
81219: CALL 42318 0 2
81223: GO 81249
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81225: LD_VAR 0 4
81229: PUSH
81230: LD_VAR 0 7
81234: ARRAY
81235: PPUSH
81236: LD_VAR 0 14
81240: PUSH
81241: LD_INT 1
81243: ARRAY
81244: PPUSH
81245: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
81249: LD_VAR 0 4
81253: PUSH
81254: LD_VAR 0 7
81258: ARRAY
81259: PPUSH
81260: CALL_OW 264
81264: PUSH
81265: LD_INT 29
81267: EQUAL
81268: IFFALSE 81634
// begin if WantsToAttack ( group [ i ] ) in bombed then
81270: LD_VAR 0 4
81274: PUSH
81275: LD_VAR 0 7
81279: ARRAY
81280: PPUSH
81281: CALL_OW 319
81285: PUSH
81286: LD_VAR 0 28
81290: IN
81291: IFFALSE 81295
// continue ;
81293: GO 78299
// k := 8 ;
81295: LD_ADDR_VAR 0 9
81299: PUSH
81300: LD_INT 8
81302: ST_TO_ADDR
// x := 0 ;
81303: LD_ADDR_VAR 0 10
81307: PUSH
81308: LD_INT 0
81310: ST_TO_ADDR
// if tmp < k then
81311: LD_VAR 0 14
81315: PUSH
81316: LD_VAR 0 9
81320: LESS
81321: IFFALSE 81333
// k := tmp ;
81323: LD_ADDR_VAR 0 9
81327: PUSH
81328: LD_VAR 0 14
81332: ST_TO_ADDR
// for j = 1 to k do
81333: LD_ADDR_VAR 0 8
81337: PUSH
81338: DOUBLE
81339: LD_INT 1
81341: DEC
81342: ST_TO_ADDR
81343: LD_VAR 0 9
81347: PUSH
81348: FOR_TO
81349: IFFALSE 81481
// begin if GetType ( tmp [ j ] ) = unit_building then
81351: LD_VAR 0 14
81355: PUSH
81356: LD_VAR 0 8
81360: ARRAY
81361: PPUSH
81362: CALL_OW 247
81366: PUSH
81367: LD_INT 3
81369: EQUAL
81370: IFFALSE 81479
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81372: LD_VAR 0 14
81376: PUSH
81377: LD_VAR 0 8
81381: ARRAY
81382: PUSH
81383: LD_VAR 0 28
81387: IN
81388: NOT
81389: PUSH
81390: LD_VAR 0 14
81394: PUSH
81395: LD_VAR 0 8
81399: ARRAY
81400: PPUSH
81401: CALL_OW 313
81405: AND
81406: IFFALSE 81479
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81408: LD_VAR 0 4
81412: PUSH
81413: LD_VAR 0 7
81417: ARRAY
81418: PPUSH
81419: LD_VAR 0 14
81423: PUSH
81424: LD_VAR 0 8
81428: ARRAY
81429: PPUSH
81430: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81434: LD_ADDR_VAR 0 28
81438: PUSH
81439: LD_VAR 0 28
81443: PPUSH
81444: LD_VAR 0 28
81448: PUSH
81449: LD_INT 1
81451: PLUS
81452: PPUSH
81453: LD_VAR 0 14
81457: PUSH
81458: LD_VAR 0 8
81462: ARRAY
81463: PPUSH
81464: CALL_OW 1
81468: ST_TO_ADDR
// attacking := true ;
81469: LD_ADDR_VAR 0 29
81473: PUSH
81474: LD_INT 1
81476: ST_TO_ADDR
// break ;
81477: GO 81481
// end ; end ;
81479: GO 81348
81481: POP
81482: POP
// if not attacking and f_attack_depot then
81483: LD_VAR 0 29
81487: NOT
81488: PUSH
81489: LD_VAR 0 25
81493: AND
81494: IFFALSE 81589
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81496: LD_ADDR_VAR 0 13
81500: PUSH
81501: LD_VAR 0 14
81505: PPUSH
81506: LD_INT 2
81508: PUSH
81509: LD_INT 30
81511: PUSH
81512: LD_INT 0
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 30
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: LIST
81533: PPUSH
81534: CALL_OW 72
81538: ST_TO_ADDR
// if z then
81539: LD_VAR 0 13
81543: IFFALSE 81589
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81545: LD_VAR 0 4
81549: PUSH
81550: LD_VAR 0 7
81554: ARRAY
81555: PPUSH
81556: LD_VAR 0 13
81560: PPUSH
81561: LD_VAR 0 4
81565: PUSH
81566: LD_VAR 0 7
81570: ARRAY
81571: PPUSH
81572: CALL_OW 74
81576: PPUSH
81577: CALL_OW 115
// attacking := true ;
81581: LD_ADDR_VAR 0 29
81585: PUSH
81586: LD_INT 1
81588: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81589: LD_VAR 0 4
81593: PUSH
81594: LD_VAR 0 7
81598: ARRAY
81599: PPUSH
81600: CALL_OW 256
81604: PUSH
81605: LD_INT 500
81607: LESS
81608: IFFALSE 81634
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81610: LD_VAR 0 4
81614: PUSH
81615: LD_VAR 0 7
81619: ARRAY
81620: PPUSH
81621: LD_VAR 0 14
81625: PUSH
81626: LD_INT 1
81628: ARRAY
81629: PPUSH
81630: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81634: LD_VAR 0 4
81638: PUSH
81639: LD_VAR 0 7
81643: ARRAY
81644: PPUSH
81645: CALL_OW 264
81649: PUSH
81650: LD_INT 49
81652: EQUAL
81653: IFFALSE 81774
// begin if not HasTask ( group [ i ] ) then
81655: LD_VAR 0 4
81659: PUSH
81660: LD_VAR 0 7
81664: ARRAY
81665: PPUSH
81666: CALL_OW 314
81670: NOT
81671: IFFALSE 81774
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81673: LD_ADDR_VAR 0 9
81677: PUSH
81678: LD_INT 81
81680: PUSH
81681: LD_VAR 0 4
81685: PUSH
81686: LD_VAR 0 7
81690: ARRAY
81691: PPUSH
81692: CALL_OW 255
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PPUSH
81701: CALL_OW 69
81705: PPUSH
81706: LD_VAR 0 4
81710: PUSH
81711: LD_VAR 0 7
81715: ARRAY
81716: PPUSH
81717: CALL_OW 74
81721: ST_TO_ADDR
// if k then
81722: LD_VAR 0 9
81726: IFFALSE 81774
// if GetDistUnits ( group [ i ] , k ) > 10 then
81728: LD_VAR 0 4
81732: PUSH
81733: LD_VAR 0 7
81737: ARRAY
81738: PPUSH
81739: LD_VAR 0 9
81743: PPUSH
81744: CALL_OW 296
81748: PUSH
81749: LD_INT 10
81751: GREATER
81752: IFFALSE 81774
// ComMoveUnit ( group [ i ] , k ) ;
81754: LD_VAR 0 4
81758: PUSH
81759: LD_VAR 0 7
81763: ARRAY
81764: PPUSH
81765: LD_VAR 0 9
81769: PPUSH
81770: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81774: LD_VAR 0 4
81778: PUSH
81779: LD_VAR 0 7
81783: ARRAY
81784: PPUSH
81785: CALL_OW 256
81789: PUSH
81790: LD_INT 250
81792: LESS
81793: PUSH
81794: LD_VAR 0 4
81798: PUSH
81799: LD_VAR 0 7
81803: ARRAY
81804: PUSH
81805: LD_INT 21
81807: PUSH
81808: LD_INT 2
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 23
81817: PUSH
81818: LD_INT 2
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PPUSH
81829: CALL_OW 69
81833: IN
81834: AND
81835: IFFALSE 81960
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81837: LD_ADDR_VAR 0 9
81841: PUSH
81842: LD_OWVAR 3
81846: PUSH
81847: LD_VAR 0 4
81851: PUSH
81852: LD_VAR 0 7
81856: ARRAY
81857: DIFF
81858: PPUSH
81859: LD_VAR 0 4
81863: PUSH
81864: LD_VAR 0 7
81868: ARRAY
81869: PPUSH
81870: CALL_OW 74
81874: ST_TO_ADDR
// if not k then
81875: LD_VAR 0 9
81879: NOT
81880: IFFALSE 81884
// continue ;
81882: GO 78299
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81884: LD_VAR 0 9
81888: PUSH
81889: LD_INT 81
81891: PUSH
81892: LD_VAR 0 4
81896: PUSH
81897: LD_VAR 0 7
81901: ARRAY
81902: PPUSH
81903: CALL_OW 255
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PPUSH
81912: CALL_OW 69
81916: IN
81917: PUSH
81918: LD_VAR 0 9
81922: PPUSH
81923: LD_VAR 0 4
81927: PUSH
81928: LD_VAR 0 7
81932: ARRAY
81933: PPUSH
81934: CALL_OW 296
81938: PUSH
81939: LD_INT 5
81941: LESS
81942: AND
81943: IFFALSE 81960
// ComAutodestruct ( group [ i ] ) ;
81945: LD_VAR 0 4
81949: PUSH
81950: LD_VAR 0 7
81954: ARRAY
81955: PPUSH
81956: CALL 42216 0 1
// end ; if f_attack_depot then
81960: LD_VAR 0 25
81964: IFFALSE 82076
// begin k := 6 ;
81966: LD_ADDR_VAR 0 9
81970: PUSH
81971: LD_INT 6
81973: ST_TO_ADDR
// if tmp < k then
81974: LD_VAR 0 14
81978: PUSH
81979: LD_VAR 0 9
81983: LESS
81984: IFFALSE 81996
// k := tmp ;
81986: LD_ADDR_VAR 0 9
81990: PUSH
81991: LD_VAR 0 14
81995: ST_TO_ADDR
// for j = 1 to k do
81996: LD_ADDR_VAR 0 8
82000: PUSH
82001: DOUBLE
82002: LD_INT 1
82004: DEC
82005: ST_TO_ADDR
82006: LD_VAR 0 9
82010: PUSH
82011: FOR_TO
82012: IFFALSE 82074
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
82014: LD_VAR 0 8
82018: PPUSH
82019: CALL_OW 266
82023: PUSH
82024: LD_INT 0
82026: PUSH
82027: LD_INT 1
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: IN
82034: IFFALSE 82072
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82036: LD_VAR 0 4
82040: PUSH
82041: LD_VAR 0 7
82045: ARRAY
82046: PPUSH
82047: LD_VAR 0 14
82051: PUSH
82052: LD_VAR 0 8
82056: ARRAY
82057: PPUSH
82058: CALL_OW 115
// attacking := true ;
82062: LD_ADDR_VAR 0 29
82066: PUSH
82067: LD_INT 1
82069: ST_TO_ADDR
// break ;
82070: GO 82074
// end ;
82072: GO 82011
82074: POP
82075: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
82076: LD_VAR 0 4
82080: PUSH
82081: LD_VAR 0 7
82085: ARRAY
82086: PPUSH
82087: CALL_OW 302
82091: PUSH
82092: LD_VAR 0 29
82096: NOT
82097: AND
82098: IFFALSE 82420
// begin if GetTag ( group [ i ] ) = 71 then
82100: LD_VAR 0 4
82104: PUSH
82105: LD_VAR 0 7
82109: ARRAY
82110: PPUSH
82111: CALL_OW 110
82115: PUSH
82116: LD_INT 71
82118: EQUAL
82119: IFFALSE 82160
// begin if HasTask ( group [ i ] ) then
82121: LD_VAR 0 4
82125: PUSH
82126: LD_VAR 0 7
82130: ARRAY
82131: PPUSH
82132: CALL_OW 314
82136: IFFALSE 82142
// continue else
82138: GO 78299
82140: GO 82160
// SetTag ( group [ i ] , 0 ) ;
82142: LD_VAR 0 4
82146: PUSH
82147: LD_VAR 0 7
82151: ARRAY
82152: PPUSH
82153: LD_INT 0
82155: PPUSH
82156: CALL_OW 109
// end ; k := 8 ;
82160: LD_ADDR_VAR 0 9
82164: PUSH
82165: LD_INT 8
82167: ST_TO_ADDR
// x := 0 ;
82168: LD_ADDR_VAR 0 10
82172: PUSH
82173: LD_INT 0
82175: ST_TO_ADDR
// if tmp < k then
82176: LD_VAR 0 14
82180: PUSH
82181: LD_VAR 0 9
82185: LESS
82186: IFFALSE 82198
// k := tmp ;
82188: LD_ADDR_VAR 0 9
82192: PUSH
82193: LD_VAR 0 14
82197: ST_TO_ADDR
// for j = 1 to k do
82198: LD_ADDR_VAR 0 8
82202: PUSH
82203: DOUBLE
82204: LD_INT 1
82206: DEC
82207: ST_TO_ADDR
82208: LD_VAR 0 9
82212: PUSH
82213: FOR_TO
82214: IFFALSE 82312
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
82216: LD_VAR 0 14
82220: PUSH
82221: LD_VAR 0 8
82225: ARRAY
82226: PPUSH
82227: CALL_OW 247
82231: PUSH
82232: LD_INT 1
82234: EQUAL
82235: PUSH
82236: LD_VAR 0 14
82240: PUSH
82241: LD_VAR 0 8
82245: ARRAY
82246: PPUSH
82247: CALL_OW 256
82251: PUSH
82252: LD_INT 250
82254: LESS
82255: PUSH
82256: LD_VAR 0 20
82260: AND
82261: PUSH
82262: LD_VAR 0 20
82266: NOT
82267: PUSH
82268: LD_VAR 0 14
82272: PUSH
82273: LD_VAR 0 8
82277: ARRAY
82278: PPUSH
82279: CALL_OW 256
82283: PUSH
82284: LD_INT 250
82286: GREATEREQUAL
82287: AND
82288: OR
82289: AND
82290: IFFALSE 82310
// begin x := tmp [ j ] ;
82292: LD_ADDR_VAR 0 10
82296: PUSH
82297: LD_VAR 0 14
82301: PUSH
82302: LD_VAR 0 8
82306: ARRAY
82307: ST_TO_ADDR
// break ;
82308: GO 82312
// end ;
82310: GO 82213
82312: POP
82313: POP
// if x then
82314: LD_VAR 0 10
82318: IFFALSE 82342
// ComAttackUnit ( group [ i ] , x ) else
82320: LD_VAR 0 4
82324: PUSH
82325: LD_VAR 0 7
82329: ARRAY
82330: PPUSH
82331: LD_VAR 0 10
82335: PPUSH
82336: CALL_OW 115
82340: GO 82366
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82342: LD_VAR 0 4
82346: PUSH
82347: LD_VAR 0 7
82351: ARRAY
82352: PPUSH
82353: LD_VAR 0 14
82357: PUSH
82358: LD_INT 1
82360: ARRAY
82361: PPUSH
82362: CALL_OW 115
// if not HasTask ( group [ i ] ) then
82366: LD_VAR 0 4
82370: PUSH
82371: LD_VAR 0 7
82375: ARRAY
82376: PPUSH
82377: CALL_OW 314
82381: NOT
82382: IFFALSE 82420
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82384: LD_VAR 0 4
82388: PUSH
82389: LD_VAR 0 7
82393: ARRAY
82394: PPUSH
82395: LD_VAR 0 14
82399: PPUSH
82400: LD_VAR 0 4
82404: PUSH
82405: LD_VAR 0 7
82409: ARRAY
82410: PPUSH
82411: CALL_OW 74
82415: PPUSH
82416: CALL_OW 115
// end ; end ; end ;
82420: GO 78299
82422: POP
82423: POP
// wait ( 0 0$2 ) ;
82424: LD_INT 70
82426: PPUSH
82427: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82431: LD_VAR 0 4
82435: NOT
82436: PUSH
82437: LD_VAR 0 4
82441: PUSH
82442: EMPTY
82443: EQUAL
82444: OR
82445: PUSH
82446: LD_INT 81
82448: PUSH
82449: LD_VAR 0 35
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PPUSH
82458: CALL_OW 69
82462: NOT
82463: OR
82464: IFFALSE 78284
// end ;
82466: LD_VAR 0 2
82470: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82471: LD_INT 0
82473: PPUSH
82474: PPUSH
82475: PPUSH
82476: PPUSH
82477: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82478: LD_VAR 0 1
82482: NOT
82483: PUSH
82484: LD_EXP 43
82488: PUSH
82489: LD_VAR 0 1
82493: ARRAY
82494: NOT
82495: OR
82496: PUSH
82497: LD_VAR 0 2
82501: NOT
82502: OR
82503: PUSH
82504: LD_VAR 0 3
82508: NOT
82509: OR
82510: IFFALSE 82514
// exit ;
82512: GO 83027
// side := mc_sides [ base ] ;
82514: LD_ADDR_VAR 0 6
82518: PUSH
82519: LD_EXP 69
82523: PUSH
82524: LD_VAR 0 1
82528: ARRAY
82529: ST_TO_ADDR
// if not side then
82530: LD_VAR 0 6
82534: NOT
82535: IFFALSE 82539
// exit ;
82537: GO 83027
// for i in solds do
82539: LD_ADDR_VAR 0 7
82543: PUSH
82544: LD_VAR 0 2
82548: PUSH
82549: FOR_IN
82550: IFFALSE 82611
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82552: LD_VAR 0 7
82556: PPUSH
82557: CALL_OW 310
82561: PPUSH
82562: CALL_OW 266
82566: PUSH
82567: LD_INT 32
82569: PUSH
82570: LD_INT 31
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: IN
82577: IFFALSE 82597
// solds := solds diff i else
82579: LD_ADDR_VAR 0 2
82583: PUSH
82584: LD_VAR 0 2
82588: PUSH
82589: LD_VAR 0 7
82593: DIFF
82594: ST_TO_ADDR
82595: GO 82609
// SetTag ( i , 18 ) ;
82597: LD_VAR 0 7
82601: PPUSH
82602: LD_INT 18
82604: PPUSH
82605: CALL_OW 109
82609: GO 82549
82611: POP
82612: POP
// if not solds then
82613: LD_VAR 0 2
82617: NOT
82618: IFFALSE 82622
// exit ;
82620: GO 83027
// repeat wait ( 0 0$2 ) ;
82622: LD_INT 70
82624: PPUSH
82625: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82629: LD_ADDR_VAR 0 5
82633: PUSH
82634: LD_VAR 0 6
82638: PPUSH
82639: LD_VAR 0 3
82643: PPUSH
82644: CALL 11598 0 2
82648: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82649: LD_EXP 43
82653: PUSH
82654: LD_VAR 0 1
82658: ARRAY
82659: NOT
82660: PUSH
82661: LD_EXP 43
82665: PUSH
82666: LD_VAR 0 1
82670: ARRAY
82671: PUSH
82672: EMPTY
82673: EQUAL
82674: OR
82675: IFFALSE 82712
// begin for i in solds do
82677: LD_ADDR_VAR 0 7
82681: PUSH
82682: LD_VAR 0 2
82686: PUSH
82687: FOR_IN
82688: IFFALSE 82701
// ComStop ( i ) ;
82690: LD_VAR 0 7
82694: PPUSH
82695: CALL_OW 141
82699: GO 82687
82701: POP
82702: POP
// solds := [ ] ;
82703: LD_ADDR_VAR 0 2
82707: PUSH
82708: EMPTY
82709: ST_TO_ADDR
// exit ;
82710: GO 83027
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82712: LD_VAR 0 5
82716: NOT
82717: PUSH
82718: LD_VAR 0 5
82722: PUSH
82723: LD_INT 3
82725: GREATER
82726: OR
82727: PUSH
82728: LD_EXP 65
82732: PUSH
82733: LD_VAR 0 1
82737: ARRAY
82738: OR
82739: IFFALSE 82780
// begin for i in solds do
82741: LD_ADDR_VAR 0 7
82745: PUSH
82746: LD_VAR 0 2
82750: PUSH
82751: FOR_IN
82752: IFFALSE 82776
// if HasTask ( i ) then
82754: LD_VAR 0 7
82758: PPUSH
82759: CALL_OW 314
82763: IFFALSE 82774
// ComStop ( i ) ;
82765: LD_VAR 0 7
82769: PPUSH
82770: CALL_OW 141
82774: GO 82751
82776: POP
82777: POP
// break ;
82778: GO 83015
// end ; for i in solds do
82780: LD_ADDR_VAR 0 7
82784: PUSH
82785: LD_VAR 0 2
82789: PUSH
82790: FOR_IN
82791: IFFALSE 83007
// begin if IsInUnit ( i ) then
82793: LD_VAR 0 7
82797: PPUSH
82798: CALL_OW 310
82802: IFFALSE 82813
// ComExitBuilding ( i ) ;
82804: LD_VAR 0 7
82808: PPUSH
82809: CALL_OW 122
// if GetLives ( i ) > 333 then
82813: LD_VAR 0 7
82817: PPUSH
82818: CALL_OW 256
82822: PUSH
82823: LD_INT 333
82825: GREATER
82826: IFFALSE 82854
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82828: LD_VAR 0 7
82832: PPUSH
82833: LD_VAR 0 5
82837: PPUSH
82838: LD_VAR 0 7
82842: PPUSH
82843: CALL_OW 74
82847: PPUSH
82848: CALL_OW 115
82852: GO 83005
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82854: LD_ADDR_VAR 0 8
82858: PUSH
82859: LD_EXP 43
82863: PUSH
82864: LD_VAR 0 1
82868: ARRAY
82869: PPUSH
82870: LD_INT 2
82872: PUSH
82873: LD_INT 30
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 30
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 30
82895: PUSH
82896: LD_INT 6
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: PPUSH
82909: CALL_OW 72
82913: PPUSH
82914: LD_VAR 0 7
82918: PPUSH
82919: CALL_OW 74
82923: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82924: LD_VAR 0 7
82928: PPUSH
82929: LD_VAR 0 8
82933: PPUSH
82934: CALL_OW 250
82938: PPUSH
82939: LD_INT 3
82941: PPUSH
82942: LD_INT 5
82944: PPUSH
82945: CALL_OW 272
82949: PPUSH
82950: LD_VAR 0 8
82954: PPUSH
82955: CALL_OW 251
82959: PPUSH
82960: LD_INT 3
82962: PPUSH
82963: LD_INT 5
82965: PPUSH
82966: CALL_OW 273
82970: PPUSH
82971: CALL_OW 111
// SetTag ( i , 0 ) ;
82975: LD_VAR 0 7
82979: PPUSH
82980: LD_INT 0
82982: PPUSH
82983: CALL_OW 109
// solds := solds diff i ;
82987: LD_ADDR_VAR 0 2
82991: PUSH
82992: LD_VAR 0 2
82996: PUSH
82997: LD_VAR 0 7
83001: DIFF
83002: ST_TO_ADDR
// continue ;
83003: GO 82790
// end ; end ;
83005: GO 82790
83007: POP
83008: POP
// until solds ;
83009: LD_VAR 0 2
83013: IFFALSE 82622
// MC_Reset ( base , 18 ) ;
83015: LD_VAR 0 1
83019: PPUSH
83020: LD_INT 18
83022: PPUSH
83023: CALL 51585 0 2
// end ;
83027: LD_VAR 0 4
83031: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
83032: LD_INT 0
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
83042: PPUSH
83043: PPUSH
83044: PPUSH
83045: PPUSH
83046: PPUSH
83047: PPUSH
83048: PPUSH
83049: PPUSH
83050: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
83051: LD_ADDR_VAR 0 13
83055: PUSH
83056: LD_EXP 43
83060: PUSH
83061: LD_VAR 0 1
83065: ARRAY
83066: PPUSH
83067: LD_INT 25
83069: PUSH
83070: LD_INT 3
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PPUSH
83077: CALL_OW 72
83081: ST_TO_ADDR
// if mc_remote_driver [ base ] then
83082: LD_EXP 83
83086: PUSH
83087: LD_VAR 0 1
83091: ARRAY
83092: IFFALSE 83116
// mechs := mechs diff mc_remote_driver [ base ] ;
83094: LD_ADDR_VAR 0 13
83098: PUSH
83099: LD_VAR 0 13
83103: PUSH
83104: LD_EXP 83
83108: PUSH
83109: LD_VAR 0 1
83113: ARRAY
83114: DIFF
83115: ST_TO_ADDR
// for i in mechs do
83116: LD_ADDR_VAR 0 5
83120: PUSH
83121: LD_VAR 0 13
83125: PUSH
83126: FOR_IN
83127: IFFALSE 83162
// if GetTag ( i ) > 0 then
83129: LD_VAR 0 5
83133: PPUSH
83134: CALL_OW 110
83138: PUSH
83139: LD_INT 0
83141: GREATER
83142: IFFALSE 83160
// mechs := mechs diff i ;
83144: LD_ADDR_VAR 0 13
83148: PUSH
83149: LD_VAR 0 13
83153: PUSH
83154: LD_VAR 0 5
83158: DIFF
83159: ST_TO_ADDR
83160: GO 83126
83162: POP
83163: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83164: LD_ADDR_VAR 0 9
83168: PUSH
83169: LD_EXP 43
83173: PUSH
83174: LD_VAR 0 1
83178: ARRAY
83179: PPUSH
83180: LD_INT 2
83182: PUSH
83183: LD_INT 25
83185: PUSH
83186: LD_INT 1
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 25
83195: PUSH
83196: LD_INT 5
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 25
83205: PUSH
83206: LD_INT 8
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 25
83215: PUSH
83216: LD_INT 9
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: PPUSH
83230: CALL_OW 72
83234: ST_TO_ADDR
// if not defenders and not solds then
83235: LD_VAR 0 2
83239: NOT
83240: PUSH
83241: LD_VAR 0 9
83245: NOT
83246: AND
83247: IFFALSE 83251
// exit ;
83249: GO 84941
// depot_under_attack := false ;
83251: LD_ADDR_VAR 0 17
83255: PUSH
83256: LD_INT 0
83258: ST_TO_ADDR
// sold_defenders := [ ] ;
83259: LD_ADDR_VAR 0 18
83263: PUSH
83264: EMPTY
83265: ST_TO_ADDR
// if mechs then
83266: LD_VAR 0 13
83270: IFFALSE 83423
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
83272: LD_ADDR_VAR 0 5
83276: PUSH
83277: LD_VAR 0 2
83281: PPUSH
83282: LD_INT 21
83284: PUSH
83285: LD_INT 2
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PPUSH
83292: CALL_OW 72
83296: PUSH
83297: FOR_IN
83298: IFFALSE 83421
// begin if GetTag ( i ) <> 20 then
83300: LD_VAR 0 5
83304: PPUSH
83305: CALL_OW 110
83309: PUSH
83310: LD_INT 20
83312: NONEQUAL
83313: IFFALSE 83327
// SetTag ( i , 20 ) ;
83315: LD_VAR 0 5
83319: PPUSH
83320: LD_INT 20
83322: PPUSH
83323: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
83327: LD_VAR 0 5
83331: PPUSH
83332: CALL_OW 263
83336: PUSH
83337: LD_INT 1
83339: EQUAL
83340: PUSH
83341: LD_VAR 0 5
83345: PPUSH
83346: CALL_OW 311
83350: NOT
83351: AND
83352: IFFALSE 83419
// begin un := mechs [ 1 ] ;
83354: LD_ADDR_VAR 0 11
83358: PUSH
83359: LD_VAR 0 13
83363: PUSH
83364: LD_INT 1
83366: ARRAY
83367: ST_TO_ADDR
// ComExit ( un ) ;
83368: LD_VAR 0 11
83372: PPUSH
83373: CALL 46561 0 1
// AddComEnterUnit ( un , i ) ;
83377: LD_VAR 0 11
83381: PPUSH
83382: LD_VAR 0 5
83386: PPUSH
83387: CALL_OW 180
// SetTag ( un , 19 ) ;
83391: LD_VAR 0 11
83395: PPUSH
83396: LD_INT 19
83398: PPUSH
83399: CALL_OW 109
// mechs := mechs diff un ;
83403: LD_ADDR_VAR 0 13
83407: PUSH
83408: LD_VAR 0 13
83412: PUSH
83413: LD_VAR 0 11
83417: DIFF
83418: ST_TO_ADDR
// end ; end ;
83419: GO 83297
83421: POP
83422: POP
// if solds then
83423: LD_VAR 0 9
83427: IFFALSE 83486
// for i in solds do
83429: LD_ADDR_VAR 0 5
83433: PUSH
83434: LD_VAR 0 9
83438: PUSH
83439: FOR_IN
83440: IFFALSE 83484
// if not GetTag ( i ) then
83442: LD_VAR 0 5
83446: PPUSH
83447: CALL_OW 110
83451: NOT
83452: IFFALSE 83482
// begin defenders := defenders union i ;
83454: LD_ADDR_VAR 0 2
83458: PUSH
83459: LD_VAR 0 2
83463: PUSH
83464: LD_VAR 0 5
83468: UNION
83469: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83470: LD_VAR 0 5
83474: PPUSH
83475: LD_INT 18
83477: PPUSH
83478: CALL_OW 109
// end ;
83482: GO 83439
83484: POP
83485: POP
// repeat wait ( 0 0$2 ) ;
83486: LD_INT 70
83488: PPUSH
83489: CALL_OW 67
// enemy := mc_scan [ base ] ;
83493: LD_ADDR_VAR 0 3
83497: PUSH
83498: LD_EXP 66
83502: PUSH
83503: LD_VAR 0 1
83507: ARRAY
83508: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83509: LD_EXP 43
83513: PUSH
83514: LD_VAR 0 1
83518: ARRAY
83519: NOT
83520: PUSH
83521: LD_EXP 43
83525: PUSH
83526: LD_VAR 0 1
83530: ARRAY
83531: PUSH
83532: EMPTY
83533: EQUAL
83534: OR
83535: IFFALSE 83572
// begin for i in defenders do
83537: LD_ADDR_VAR 0 5
83541: PUSH
83542: LD_VAR 0 2
83546: PUSH
83547: FOR_IN
83548: IFFALSE 83561
// ComStop ( i ) ;
83550: LD_VAR 0 5
83554: PPUSH
83555: CALL_OW 141
83559: GO 83547
83561: POP
83562: POP
// defenders := [ ] ;
83563: LD_ADDR_VAR 0 2
83567: PUSH
83568: EMPTY
83569: ST_TO_ADDR
// exit ;
83570: GO 84941
// end ; for i in defenders do
83572: LD_ADDR_VAR 0 5
83576: PUSH
83577: LD_VAR 0 2
83581: PUSH
83582: FOR_IN
83583: IFFALSE 84401
// begin e := NearestUnitToUnit ( enemy , i ) ;
83585: LD_ADDR_VAR 0 14
83589: PUSH
83590: LD_VAR 0 3
83594: PPUSH
83595: LD_VAR 0 5
83599: PPUSH
83600: CALL_OW 74
83604: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83605: LD_ADDR_VAR 0 8
83609: PUSH
83610: LD_EXP 43
83614: PUSH
83615: LD_VAR 0 1
83619: ARRAY
83620: PPUSH
83621: LD_INT 2
83623: PUSH
83624: LD_INT 30
83626: PUSH
83627: LD_INT 0
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 30
83636: PUSH
83637: LD_INT 1
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: LIST
83648: PPUSH
83649: CALL_OW 72
83653: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83654: LD_ADDR_VAR 0 17
83658: PUSH
83659: LD_VAR 0 8
83663: NOT
83664: PUSH
83665: LD_VAR 0 8
83669: PPUSH
83670: LD_INT 3
83672: PUSH
83673: LD_INT 24
83675: PUSH
83676: LD_INT 600
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PPUSH
83687: CALL_OW 72
83691: OR
83692: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83693: LD_VAR 0 5
83697: PPUSH
83698: CALL_OW 247
83702: PUSH
83703: LD_INT 2
83705: DOUBLE
83706: EQUAL
83707: IFTRUE 83711
83709: GO 84107
83711: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83712: LD_VAR 0 5
83716: PPUSH
83717: CALL_OW 256
83721: PUSH
83722: LD_INT 650
83724: GREATER
83725: PUSH
83726: LD_VAR 0 5
83730: PPUSH
83731: LD_VAR 0 14
83735: PPUSH
83736: CALL_OW 296
83740: PUSH
83741: LD_INT 40
83743: LESS
83744: PUSH
83745: LD_VAR 0 14
83749: PPUSH
83750: LD_EXP 68
83754: PUSH
83755: LD_VAR 0 1
83759: ARRAY
83760: PPUSH
83761: CALL_OW 308
83765: OR
83766: AND
83767: IFFALSE 83889
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83769: LD_VAR 0 5
83773: PPUSH
83774: CALL_OW 262
83778: PUSH
83779: LD_INT 1
83781: EQUAL
83782: PUSH
83783: LD_VAR 0 5
83787: PPUSH
83788: CALL_OW 261
83792: PUSH
83793: LD_INT 30
83795: LESS
83796: AND
83797: PUSH
83798: LD_VAR 0 8
83802: AND
83803: IFFALSE 83873
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83805: LD_VAR 0 5
83809: PPUSH
83810: LD_VAR 0 8
83814: PPUSH
83815: LD_VAR 0 5
83819: PPUSH
83820: CALL_OW 74
83824: PPUSH
83825: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83829: LD_VAR 0 5
83833: PPUSH
83834: LD_VAR 0 8
83838: PPUSH
83839: LD_VAR 0 5
83843: PPUSH
83844: CALL_OW 74
83848: PPUSH
83849: CALL_OW 296
83853: PUSH
83854: LD_INT 6
83856: LESS
83857: IFFALSE 83871
// SetFuel ( i , 100 ) ;
83859: LD_VAR 0 5
83863: PPUSH
83864: LD_INT 100
83866: PPUSH
83867: CALL_OW 240
// end else
83871: GO 83887
// ComAttackUnit ( i , e ) ;
83873: LD_VAR 0 5
83877: PPUSH
83878: LD_VAR 0 14
83882: PPUSH
83883: CALL_OW 115
// end else
83887: GO 83990
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83889: LD_VAR 0 14
83893: PPUSH
83894: LD_EXP 68
83898: PUSH
83899: LD_VAR 0 1
83903: ARRAY
83904: PPUSH
83905: CALL_OW 308
83909: NOT
83910: PUSH
83911: LD_VAR 0 5
83915: PPUSH
83916: LD_VAR 0 14
83920: PPUSH
83921: CALL_OW 296
83925: PUSH
83926: LD_INT 40
83928: GREATEREQUAL
83929: AND
83930: PUSH
83931: LD_VAR 0 5
83935: PPUSH
83936: CALL_OW 256
83940: PUSH
83941: LD_INT 650
83943: LESSEQUAL
83944: OR
83945: PUSH
83946: LD_VAR 0 5
83950: PPUSH
83951: LD_EXP 67
83955: PUSH
83956: LD_VAR 0 1
83960: ARRAY
83961: PPUSH
83962: CALL_OW 308
83966: NOT
83967: AND
83968: IFFALSE 83990
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83970: LD_VAR 0 5
83974: PPUSH
83975: LD_EXP 67
83979: PUSH
83980: LD_VAR 0 1
83984: ARRAY
83985: PPUSH
83986: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83990: LD_VAR 0 5
83994: PPUSH
83995: CALL_OW 256
83999: PUSH
84000: LD_INT 998
84002: LESS
84003: PUSH
84004: LD_VAR 0 5
84008: PPUSH
84009: CALL_OW 263
84013: PUSH
84014: LD_INT 1
84016: EQUAL
84017: AND
84018: PUSH
84019: LD_VAR 0 5
84023: PPUSH
84024: CALL_OW 311
84028: AND
84029: PUSH
84030: LD_VAR 0 5
84034: PPUSH
84035: LD_EXP 67
84039: PUSH
84040: LD_VAR 0 1
84044: ARRAY
84045: PPUSH
84046: CALL_OW 308
84050: AND
84051: IFFALSE 84105
// begin mech := IsDrivenBy ( i ) ;
84053: LD_ADDR_VAR 0 10
84057: PUSH
84058: LD_VAR 0 5
84062: PPUSH
84063: CALL_OW 311
84067: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
84068: LD_VAR 0 10
84072: PPUSH
84073: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
84077: LD_VAR 0 10
84081: PPUSH
84082: LD_VAR 0 5
84086: PPUSH
84087: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
84091: LD_VAR 0 10
84095: PPUSH
84096: LD_VAR 0 5
84100: PPUSH
84101: CALL_OW 180
// end ; end ; unit_human :
84105: GO 84372
84107: LD_INT 1
84109: DOUBLE
84110: EQUAL
84111: IFTRUE 84115
84113: GO 84371
84115: POP
// begin b := IsInUnit ( i ) ;
84116: LD_ADDR_VAR 0 19
84120: PUSH
84121: LD_VAR 0 5
84125: PPUSH
84126: CALL_OW 310
84130: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
84131: LD_ADDR_VAR 0 20
84135: PUSH
84136: LD_VAR 0 19
84140: NOT
84141: PUSH
84142: LD_VAR 0 19
84146: PPUSH
84147: CALL_OW 266
84151: PUSH
84152: LD_INT 32
84154: PUSH
84155: LD_INT 31
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: IN
84162: OR
84163: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
84164: LD_VAR 0 17
84168: PUSH
84169: LD_VAR 0 2
84173: PPUSH
84174: LD_INT 21
84176: PUSH
84177: LD_INT 2
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PPUSH
84184: CALL_OW 72
84188: PUSH
84189: LD_INT 1
84191: LESSEQUAL
84192: OR
84193: PUSH
84194: LD_VAR 0 20
84198: AND
84199: PUSH
84200: LD_VAR 0 5
84204: PUSH
84205: LD_VAR 0 18
84209: IN
84210: NOT
84211: AND
84212: IFFALSE 84305
// begin if b then
84214: LD_VAR 0 19
84218: IFFALSE 84267
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
84220: LD_VAR 0 19
84224: PPUSH
84225: LD_VAR 0 3
84229: PPUSH
84230: LD_VAR 0 19
84234: PPUSH
84235: CALL_OW 74
84239: PPUSH
84240: CALL_OW 296
84244: PUSH
84245: LD_INT 10
84247: LESS
84248: PUSH
84249: LD_VAR 0 19
84253: PPUSH
84254: CALL_OW 461
84258: PUSH
84259: LD_INT 7
84261: NONEQUAL
84262: AND
84263: IFFALSE 84267
// continue ;
84265: GO 83582
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
84267: LD_ADDR_VAR 0 18
84271: PUSH
84272: LD_VAR 0 18
84276: PPUSH
84277: LD_VAR 0 18
84281: PUSH
84282: LD_INT 1
84284: PLUS
84285: PPUSH
84286: LD_VAR 0 5
84290: PPUSH
84291: CALL_OW 1
84295: ST_TO_ADDR
// ComExitBuilding ( i ) ;
84296: LD_VAR 0 5
84300: PPUSH
84301: CALL_OW 122
// end ; if sold_defenders then
84305: LD_VAR 0 18
84309: IFFALSE 84369
// if i in sold_defenders then
84311: LD_VAR 0 5
84315: PUSH
84316: LD_VAR 0 18
84320: IN
84321: IFFALSE 84369
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
84323: LD_VAR 0 5
84327: PPUSH
84328: CALL_OW 314
84332: NOT
84333: PUSH
84334: LD_VAR 0 5
84338: PPUSH
84339: LD_VAR 0 14
84343: PPUSH
84344: CALL_OW 296
84348: PUSH
84349: LD_INT 30
84351: LESS
84352: AND
84353: IFFALSE 84369
// ComAttackUnit ( i , e ) ;
84355: LD_VAR 0 5
84359: PPUSH
84360: LD_VAR 0 14
84364: PPUSH
84365: CALL_OW 115
// end ; end ; end ;
84369: GO 84372
84371: POP
// if IsDead ( i ) then
84372: LD_VAR 0 5
84376: PPUSH
84377: CALL_OW 301
84381: IFFALSE 84399
// defenders := defenders diff i ;
84383: LD_ADDR_VAR 0 2
84387: PUSH
84388: LD_VAR 0 2
84392: PUSH
84393: LD_VAR 0 5
84397: DIFF
84398: ST_TO_ADDR
// end ;
84399: GO 83582
84401: POP
84402: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84403: LD_VAR 0 3
84407: NOT
84408: PUSH
84409: LD_VAR 0 2
84413: NOT
84414: OR
84415: PUSH
84416: LD_EXP 43
84420: PUSH
84421: LD_VAR 0 1
84425: ARRAY
84426: NOT
84427: OR
84428: IFFALSE 83486
// MC_Reset ( base , 18 ) ;
84430: LD_VAR 0 1
84434: PPUSH
84435: LD_INT 18
84437: PPUSH
84438: CALL 51585 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84442: LD_ADDR_VAR 0 2
84446: PUSH
84447: LD_VAR 0 2
84451: PUSH
84452: LD_VAR 0 2
84456: PPUSH
84457: LD_INT 2
84459: PUSH
84460: LD_INT 25
84462: PUSH
84463: LD_INT 1
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 25
84472: PUSH
84473: LD_INT 5
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 25
84482: PUSH
84483: LD_INT 8
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 25
84492: PUSH
84493: LD_INT 9
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: PPUSH
84507: CALL_OW 72
84511: DIFF
84512: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84513: LD_VAR 0 3
84517: NOT
84518: PUSH
84519: LD_VAR 0 2
84523: PPUSH
84524: LD_INT 21
84526: PUSH
84527: LD_INT 2
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PPUSH
84534: CALL_OW 72
84538: AND
84539: IFFALSE 84877
// begin tmp := FilterByTag ( defenders , 19 ) ;
84541: LD_ADDR_VAR 0 12
84545: PUSH
84546: LD_VAR 0 2
84550: PPUSH
84551: LD_INT 19
84553: PPUSH
84554: CALL 43691 0 2
84558: ST_TO_ADDR
// if tmp then
84559: LD_VAR 0 12
84563: IFFALSE 84633
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84565: LD_ADDR_VAR 0 12
84569: PUSH
84570: LD_VAR 0 12
84574: PPUSH
84575: LD_INT 25
84577: PUSH
84578: LD_INT 3
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PPUSH
84585: CALL_OW 72
84589: ST_TO_ADDR
// if tmp then
84590: LD_VAR 0 12
84594: IFFALSE 84633
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84596: LD_ADDR_EXP 55
84600: PUSH
84601: LD_EXP 55
84605: PPUSH
84606: LD_VAR 0 1
84610: PPUSH
84611: LD_EXP 55
84615: PUSH
84616: LD_VAR 0 1
84620: ARRAY
84621: PUSH
84622: LD_VAR 0 12
84626: UNION
84627: PPUSH
84628: CALL_OW 1
84632: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84633: LD_VAR 0 1
84637: PPUSH
84638: LD_INT 19
84640: PPUSH
84641: CALL 51585 0 2
// repeat wait ( 0 0$1 ) ;
84645: LD_INT 35
84647: PPUSH
84648: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84652: LD_EXP 43
84656: PUSH
84657: LD_VAR 0 1
84661: ARRAY
84662: NOT
84663: PUSH
84664: LD_EXP 43
84668: PUSH
84669: LD_VAR 0 1
84673: ARRAY
84674: PUSH
84675: EMPTY
84676: EQUAL
84677: OR
84678: IFFALSE 84715
// begin for i in defenders do
84680: LD_ADDR_VAR 0 5
84684: PUSH
84685: LD_VAR 0 2
84689: PUSH
84690: FOR_IN
84691: IFFALSE 84704
// ComStop ( i ) ;
84693: LD_VAR 0 5
84697: PPUSH
84698: CALL_OW 141
84702: GO 84690
84704: POP
84705: POP
// defenders := [ ] ;
84706: LD_ADDR_VAR 0 2
84710: PUSH
84711: EMPTY
84712: ST_TO_ADDR
// exit ;
84713: GO 84941
// end ; for i in defenders do
84715: LD_ADDR_VAR 0 5
84719: PUSH
84720: LD_VAR 0 2
84724: PUSH
84725: FOR_IN
84726: IFFALSE 84815
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84728: LD_VAR 0 5
84732: PPUSH
84733: LD_EXP 67
84737: PUSH
84738: LD_VAR 0 1
84742: ARRAY
84743: PPUSH
84744: CALL_OW 308
84748: NOT
84749: IFFALSE 84773
// ComMoveToArea ( i , mc_parking [ base ] ) else
84751: LD_VAR 0 5
84755: PPUSH
84756: LD_EXP 67
84760: PUSH
84761: LD_VAR 0 1
84765: ARRAY
84766: PPUSH
84767: CALL_OW 113
84771: GO 84813
// if GetControl ( i ) = control_manual then
84773: LD_VAR 0 5
84777: PPUSH
84778: CALL_OW 263
84782: PUSH
84783: LD_INT 1
84785: EQUAL
84786: IFFALSE 84813
// if IsDrivenBy ( i ) then
84788: LD_VAR 0 5
84792: PPUSH
84793: CALL_OW 311
84797: IFFALSE 84813
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84799: LD_VAR 0 5
84803: PPUSH
84804: CALL_OW 311
84808: PPUSH
84809: CALL_OW 121
// end ;
84813: GO 84725
84815: POP
84816: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84817: LD_VAR 0 2
84821: PPUSH
84822: LD_INT 95
84824: PUSH
84825: LD_EXP 67
84829: PUSH
84830: LD_VAR 0 1
84834: ARRAY
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PPUSH
84840: CALL_OW 72
84844: PUSH
84845: LD_VAR 0 2
84849: EQUAL
84850: PUSH
84851: LD_EXP 66
84855: PUSH
84856: LD_VAR 0 1
84860: ARRAY
84861: OR
84862: PUSH
84863: LD_EXP 43
84867: PUSH
84868: LD_VAR 0 1
84872: ARRAY
84873: NOT
84874: OR
84875: IFFALSE 84645
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84877: LD_ADDR_EXP 65
84881: PUSH
84882: LD_EXP 65
84886: PPUSH
84887: LD_VAR 0 1
84891: PPUSH
84892: LD_VAR 0 2
84896: PPUSH
84897: LD_INT 21
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PPUSH
84907: CALL_OW 72
84911: PPUSH
84912: CALL_OW 1
84916: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84917: LD_VAR 0 1
84921: PPUSH
84922: LD_INT 19
84924: PPUSH
84925: CALL 51585 0 2
// MC_Reset ( base , 20 ) ;
84929: LD_VAR 0 1
84933: PPUSH
84934: LD_INT 20
84936: PPUSH
84937: CALL 51585 0 2
// end ; end_of_file
84941: LD_VAR 0 4
84945: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84946: LD_INT 0
84948: PPUSH
84949: PPUSH
84950: PPUSH
84951: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84952: LD_VAR 0 1
84956: PPUSH
84957: CALL_OW 264
84961: PUSH
84962: LD_EXP 90
84966: EQUAL
84967: IFFALSE 85039
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84969: LD_INT 68
84971: PPUSH
84972: LD_VAR 0 1
84976: PPUSH
84977: CALL_OW 255
84981: PPUSH
84982: CALL_OW 321
84986: PUSH
84987: LD_INT 2
84989: EQUAL
84990: IFFALSE 85002
// eff := 70 else
84992: LD_ADDR_VAR 0 4
84996: PUSH
84997: LD_INT 70
84999: ST_TO_ADDR
85000: GO 85010
// eff := 30 ;
85002: LD_ADDR_VAR 0 4
85006: PUSH
85007: LD_INT 30
85009: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
85010: LD_VAR 0 1
85014: PPUSH
85015: CALL_OW 250
85019: PPUSH
85020: LD_VAR 0 1
85024: PPUSH
85025: CALL_OW 251
85029: PPUSH
85030: LD_VAR 0 4
85034: PPUSH
85035: CALL_OW 495
// end ; end ;
85039: LD_VAR 0 2
85043: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
85044: LD_INT 0
85046: PPUSH
// end ;
85047: LD_VAR 0 4
85051: RET
// export function SOS_Command ( cmd ) ; begin
85052: LD_INT 0
85054: PPUSH
// end ;
85055: LD_VAR 0 2
85059: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
85060: LD_INT 0
85062: PPUSH
// if cmd = 121 then
85063: LD_VAR 0 1
85067: PUSH
85068: LD_INT 121
85070: EQUAL
85071: IFFALSE 85073
// end ;
85073: LD_VAR 0 6
85077: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
85078: LD_INT 0
85080: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
85081: LD_VAR 0 1
85085: PUSH
85086: LD_INT 250
85088: EQUAL
85089: PUSH
85090: LD_VAR 0 2
85094: PPUSH
85095: CALL_OW 264
85099: PUSH
85100: LD_EXP 93
85104: EQUAL
85105: AND
85106: IFFALSE 85127
// MinerPlaceMine ( unit , x , y ) ;
85108: LD_VAR 0 2
85112: PPUSH
85113: LD_VAR 0 4
85117: PPUSH
85118: LD_VAR 0 5
85122: PPUSH
85123: CALL 87476 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
85127: LD_VAR 0 1
85131: PUSH
85132: LD_INT 251
85134: EQUAL
85135: PUSH
85136: LD_VAR 0 2
85140: PPUSH
85141: CALL_OW 264
85145: PUSH
85146: LD_EXP 93
85150: EQUAL
85151: AND
85152: IFFALSE 85173
// MinerDetonateMine ( unit , x , y ) ;
85154: LD_VAR 0 2
85158: PPUSH
85159: LD_VAR 0 4
85163: PPUSH
85164: LD_VAR 0 5
85168: PPUSH
85169: CALL 87753 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
85173: LD_VAR 0 1
85177: PUSH
85178: LD_INT 252
85180: EQUAL
85181: PUSH
85182: LD_VAR 0 2
85186: PPUSH
85187: CALL_OW 264
85191: PUSH
85192: LD_EXP 93
85196: EQUAL
85197: AND
85198: IFFALSE 85219
// MinerCreateMinefield ( unit , x , y ) ;
85200: LD_VAR 0 2
85204: PPUSH
85205: LD_VAR 0 4
85209: PPUSH
85210: LD_VAR 0 5
85214: PPUSH
85215: CALL 88170 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
85219: LD_VAR 0 1
85223: PUSH
85224: LD_INT 253
85226: EQUAL
85227: PUSH
85228: LD_VAR 0 2
85232: PPUSH
85233: CALL_OW 257
85237: PUSH
85238: LD_INT 5
85240: EQUAL
85241: AND
85242: IFFALSE 85263
// ComBinocular ( unit , x , y ) ;
85244: LD_VAR 0 2
85248: PPUSH
85249: LD_VAR 0 4
85253: PPUSH
85254: LD_VAR 0 5
85258: PPUSH
85259: CALL 88541 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
85263: LD_VAR 0 1
85267: PUSH
85268: LD_INT 254
85270: EQUAL
85271: PUSH
85272: LD_VAR 0 2
85276: PPUSH
85277: CALL_OW 264
85281: PUSH
85282: LD_EXP 88
85286: EQUAL
85287: AND
85288: PUSH
85289: LD_VAR 0 3
85293: PPUSH
85294: CALL_OW 263
85298: PUSH
85299: LD_INT 3
85301: EQUAL
85302: AND
85303: IFFALSE 85319
// HackDestroyVehicle ( unit , selectedUnit ) ;
85305: LD_VAR 0 2
85309: PPUSH
85310: LD_VAR 0 3
85314: PPUSH
85315: CALL 86836 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
85319: LD_VAR 0 1
85323: PUSH
85324: LD_INT 255
85326: EQUAL
85327: PUSH
85328: LD_VAR 0 2
85332: PPUSH
85333: CALL_OW 264
85337: PUSH
85338: LD_INT 14
85340: PUSH
85341: LD_INT 53
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: IN
85348: AND
85349: PUSH
85350: LD_VAR 0 4
85354: PPUSH
85355: LD_VAR 0 5
85359: PPUSH
85360: CALL_OW 488
85364: AND
85365: IFFALSE 85389
// CutTreeXYR ( unit , x , y , 12 ) ;
85367: LD_VAR 0 2
85371: PPUSH
85372: LD_VAR 0 4
85376: PPUSH
85377: LD_VAR 0 5
85381: PPUSH
85382: LD_INT 12
85384: PPUSH
85385: CALL 85402 0 4
// end ;
85389: LD_VAR 0 6
85393: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
85394: LD_INT 0
85396: PPUSH
// end ;
85397: LD_VAR 0 4
85401: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
85402: LD_INT 0
85404: PPUSH
85405: PPUSH
85406: PPUSH
85407: PPUSH
85408: PPUSH
85409: PPUSH
85410: PPUSH
85411: PPUSH
85412: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
85413: LD_VAR 0 1
85417: NOT
85418: PUSH
85419: LD_VAR 0 2
85423: PPUSH
85424: LD_VAR 0 3
85428: PPUSH
85429: CALL_OW 488
85433: NOT
85434: OR
85435: PUSH
85436: LD_VAR 0 4
85440: NOT
85441: OR
85442: IFFALSE 85446
// exit ;
85444: GO 85786
// list := [ ] ;
85446: LD_ADDR_VAR 0 13
85450: PUSH
85451: EMPTY
85452: ST_TO_ADDR
// if x - r < 0 then
85453: LD_VAR 0 2
85457: PUSH
85458: LD_VAR 0 4
85462: MINUS
85463: PUSH
85464: LD_INT 0
85466: LESS
85467: IFFALSE 85479
// min_x := 0 else
85469: LD_ADDR_VAR 0 7
85473: PUSH
85474: LD_INT 0
85476: ST_TO_ADDR
85477: GO 85495
// min_x := x - r ;
85479: LD_ADDR_VAR 0 7
85483: PUSH
85484: LD_VAR 0 2
85488: PUSH
85489: LD_VAR 0 4
85493: MINUS
85494: ST_TO_ADDR
// if y - r < 0 then
85495: LD_VAR 0 3
85499: PUSH
85500: LD_VAR 0 4
85504: MINUS
85505: PUSH
85506: LD_INT 0
85508: LESS
85509: IFFALSE 85521
// min_y := 0 else
85511: LD_ADDR_VAR 0 8
85515: PUSH
85516: LD_INT 0
85518: ST_TO_ADDR
85519: GO 85537
// min_y := y - r ;
85521: LD_ADDR_VAR 0 8
85525: PUSH
85526: LD_VAR 0 3
85530: PUSH
85531: LD_VAR 0 4
85535: MINUS
85536: ST_TO_ADDR
// max_x := x + r ;
85537: LD_ADDR_VAR 0 9
85541: PUSH
85542: LD_VAR 0 2
85546: PUSH
85547: LD_VAR 0 4
85551: PLUS
85552: ST_TO_ADDR
// max_y := y + r ;
85553: LD_ADDR_VAR 0 10
85557: PUSH
85558: LD_VAR 0 3
85562: PUSH
85563: LD_VAR 0 4
85567: PLUS
85568: ST_TO_ADDR
// for _x = min_x to max_x do
85569: LD_ADDR_VAR 0 11
85573: PUSH
85574: DOUBLE
85575: LD_VAR 0 7
85579: DEC
85580: ST_TO_ADDR
85581: LD_VAR 0 9
85585: PUSH
85586: FOR_TO
85587: IFFALSE 85704
// for _y = min_y to max_y do
85589: LD_ADDR_VAR 0 12
85593: PUSH
85594: DOUBLE
85595: LD_VAR 0 8
85599: DEC
85600: ST_TO_ADDR
85601: LD_VAR 0 10
85605: PUSH
85606: FOR_TO
85607: IFFALSE 85700
// begin if not ValidHex ( _x , _y ) then
85609: LD_VAR 0 11
85613: PPUSH
85614: LD_VAR 0 12
85618: PPUSH
85619: CALL_OW 488
85623: NOT
85624: IFFALSE 85628
// continue ;
85626: GO 85606
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85628: LD_VAR 0 11
85632: PPUSH
85633: LD_VAR 0 12
85637: PPUSH
85638: CALL_OW 351
85642: PUSH
85643: LD_VAR 0 11
85647: PPUSH
85648: LD_VAR 0 12
85652: PPUSH
85653: CALL_OW 554
85657: AND
85658: IFFALSE 85698
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85660: LD_ADDR_VAR 0 13
85664: PUSH
85665: LD_VAR 0 13
85669: PPUSH
85670: LD_VAR 0 13
85674: PUSH
85675: LD_INT 1
85677: PLUS
85678: PPUSH
85679: LD_VAR 0 11
85683: PUSH
85684: LD_VAR 0 12
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PPUSH
85693: CALL_OW 2
85697: ST_TO_ADDR
// end ;
85698: GO 85606
85700: POP
85701: POP
85702: GO 85586
85704: POP
85705: POP
// if not list then
85706: LD_VAR 0 13
85710: NOT
85711: IFFALSE 85715
// exit ;
85713: GO 85786
// for i in list do
85715: LD_ADDR_VAR 0 6
85719: PUSH
85720: LD_VAR 0 13
85724: PUSH
85725: FOR_IN
85726: IFFALSE 85784
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85728: LD_VAR 0 1
85732: PPUSH
85733: LD_STRING M
85735: PUSH
85736: LD_VAR 0 6
85740: PUSH
85741: LD_INT 1
85743: ARRAY
85744: PUSH
85745: LD_VAR 0 6
85749: PUSH
85750: LD_INT 2
85752: ARRAY
85753: PUSH
85754: LD_INT 0
85756: PUSH
85757: LD_INT 0
85759: PUSH
85760: LD_INT 0
85762: PUSH
85763: LD_INT 0
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: PUSH
85775: EMPTY
85776: LIST
85777: PPUSH
85778: CALL_OW 447
85782: GO 85725
85784: POP
85785: POP
// end ;
85786: LD_VAR 0 5
85790: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85791: LD_EXP 104
85795: NOT
85796: IFFALSE 85846
85798: GO 85800
85800: DISABLE
// begin initHack := true ;
85801: LD_ADDR_EXP 104
85805: PUSH
85806: LD_INT 1
85808: ST_TO_ADDR
// hackTanks := [ ] ;
85809: LD_ADDR_EXP 105
85813: PUSH
85814: EMPTY
85815: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85816: LD_ADDR_EXP 106
85820: PUSH
85821: EMPTY
85822: ST_TO_ADDR
// hackLimit := 3 ;
85823: LD_ADDR_EXP 107
85827: PUSH
85828: LD_INT 3
85830: ST_TO_ADDR
// hackDist := 12 ;
85831: LD_ADDR_EXP 108
85835: PUSH
85836: LD_INT 12
85838: ST_TO_ADDR
// hackCounter := [ ] ;
85839: LD_ADDR_EXP 109
85843: PUSH
85844: EMPTY
85845: ST_TO_ADDR
// end ;
85846: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85847: LD_EXP 104
85851: PUSH
85852: LD_INT 34
85854: PUSH
85855: LD_EXP 88
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PPUSH
85864: CALL_OW 69
85868: AND
85869: IFFALSE 86124
85871: GO 85873
85873: DISABLE
85874: LD_INT 0
85876: PPUSH
85877: PPUSH
// begin enable ;
85878: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85879: LD_ADDR_VAR 0 1
85883: PUSH
85884: LD_INT 34
85886: PUSH
85887: LD_EXP 88
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PPUSH
85896: CALL_OW 69
85900: PUSH
85901: FOR_IN
85902: IFFALSE 86122
// begin if not i in hackTanks then
85904: LD_VAR 0 1
85908: PUSH
85909: LD_EXP 105
85913: IN
85914: NOT
85915: IFFALSE 85998
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85917: LD_ADDR_EXP 105
85921: PUSH
85922: LD_EXP 105
85926: PPUSH
85927: LD_EXP 105
85931: PUSH
85932: LD_INT 1
85934: PLUS
85935: PPUSH
85936: LD_VAR 0 1
85940: PPUSH
85941: CALL_OW 1
85945: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85946: LD_ADDR_EXP 106
85950: PUSH
85951: LD_EXP 106
85955: PPUSH
85956: LD_EXP 106
85960: PUSH
85961: LD_INT 1
85963: PLUS
85964: PPUSH
85965: EMPTY
85966: PPUSH
85967: CALL_OW 1
85971: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85972: LD_ADDR_EXP 109
85976: PUSH
85977: LD_EXP 109
85981: PPUSH
85982: LD_EXP 109
85986: PUSH
85987: LD_INT 1
85989: PLUS
85990: PPUSH
85991: EMPTY
85992: PPUSH
85993: CALL_OW 1
85997: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85998: LD_VAR 0 1
86002: PPUSH
86003: CALL_OW 302
86007: NOT
86008: IFFALSE 86021
// begin HackUnlinkAll ( i ) ;
86010: LD_VAR 0 1
86014: PPUSH
86015: CALL 86127 0 1
// continue ;
86019: GO 85901
// end ; HackCheckCapturedStatus ( i ) ;
86021: LD_VAR 0 1
86025: PPUSH
86026: CALL 86570 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
86030: LD_ADDR_VAR 0 2
86034: PUSH
86035: LD_INT 81
86037: PUSH
86038: LD_VAR 0 1
86042: PPUSH
86043: CALL_OW 255
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 33
86054: PUSH
86055: LD_INT 3
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 91
86064: PUSH
86065: LD_VAR 0 1
86069: PUSH
86070: LD_EXP 108
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 50
86082: PUSH
86083: EMPTY
86084: LIST
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: PPUSH
86092: CALL_OW 69
86096: ST_TO_ADDR
// if not tmp then
86097: LD_VAR 0 2
86101: NOT
86102: IFFALSE 86106
// continue ;
86104: GO 85901
// HackLink ( i , tmp ) ;
86106: LD_VAR 0 1
86110: PPUSH
86111: LD_VAR 0 2
86115: PPUSH
86116: CALL 86263 0 2
// end ;
86120: GO 85901
86122: POP
86123: POP
// end ;
86124: PPOPN 2
86126: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
86127: LD_INT 0
86129: PPUSH
86130: PPUSH
86131: PPUSH
// if not hack in hackTanks then
86132: LD_VAR 0 1
86136: PUSH
86137: LD_EXP 105
86141: IN
86142: NOT
86143: IFFALSE 86147
// exit ;
86145: GO 86258
// index := GetElementIndex ( hackTanks , hack ) ;
86147: LD_ADDR_VAR 0 4
86151: PUSH
86152: LD_EXP 105
86156: PPUSH
86157: LD_VAR 0 1
86161: PPUSH
86162: CALL 14582 0 2
86166: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
86167: LD_EXP 106
86171: PUSH
86172: LD_VAR 0 4
86176: ARRAY
86177: IFFALSE 86258
// begin for i in hackTanksCaptured [ index ] do
86179: LD_ADDR_VAR 0 3
86183: PUSH
86184: LD_EXP 106
86188: PUSH
86189: LD_VAR 0 4
86193: ARRAY
86194: PUSH
86195: FOR_IN
86196: IFFALSE 86222
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
86198: LD_VAR 0 3
86202: PUSH
86203: LD_INT 1
86205: ARRAY
86206: PPUSH
86207: LD_VAR 0 3
86211: PUSH
86212: LD_INT 2
86214: ARRAY
86215: PPUSH
86216: CALL_OW 235
86220: GO 86195
86222: POP
86223: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
86224: LD_ADDR_EXP 106
86228: PUSH
86229: LD_EXP 106
86233: PPUSH
86234: LD_VAR 0 4
86238: PPUSH
86239: EMPTY
86240: PPUSH
86241: CALL_OW 1
86245: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
86246: LD_VAR 0 1
86250: PPUSH
86251: LD_INT 0
86253: PPUSH
86254: CALL_OW 505
// end ; end ;
86258: LD_VAR 0 2
86262: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
86263: LD_INT 0
86265: PPUSH
86266: PPUSH
86267: PPUSH
// if not hack in hackTanks or not vehicles then
86268: LD_VAR 0 1
86272: PUSH
86273: LD_EXP 105
86277: IN
86278: NOT
86279: PUSH
86280: LD_VAR 0 2
86284: NOT
86285: OR
86286: IFFALSE 86290
// exit ;
86288: GO 86565
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
86290: LD_ADDR_VAR 0 2
86294: PUSH
86295: LD_VAR 0 1
86299: PPUSH
86300: LD_VAR 0 2
86304: PPUSH
86305: LD_INT 1
86307: PPUSH
86308: LD_INT 1
86310: PPUSH
86311: CALL 15232 0 4
86315: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
86316: LD_ADDR_VAR 0 5
86320: PUSH
86321: LD_EXP 105
86325: PPUSH
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL 14582 0 2
86335: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
86336: LD_EXP 106
86340: PUSH
86341: LD_VAR 0 5
86345: ARRAY
86346: PUSH
86347: LD_EXP 107
86351: LESS
86352: IFFALSE 86541
// begin for i := 1 to vehicles do
86354: LD_ADDR_VAR 0 4
86358: PUSH
86359: DOUBLE
86360: LD_INT 1
86362: DEC
86363: ST_TO_ADDR
86364: LD_VAR 0 2
86368: PUSH
86369: FOR_TO
86370: IFFALSE 86539
// begin if hackTanksCaptured [ index ] = hackLimit then
86372: LD_EXP 106
86376: PUSH
86377: LD_VAR 0 5
86381: ARRAY
86382: PUSH
86383: LD_EXP 107
86387: EQUAL
86388: IFFALSE 86392
// break ;
86390: GO 86539
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
86392: LD_ADDR_EXP 109
86396: PUSH
86397: LD_EXP 109
86401: PPUSH
86402: LD_VAR 0 5
86406: PPUSH
86407: LD_EXP 109
86411: PUSH
86412: LD_VAR 0 5
86416: ARRAY
86417: PUSH
86418: LD_INT 1
86420: PLUS
86421: PPUSH
86422: CALL_OW 1
86426: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
86427: LD_ADDR_EXP 106
86431: PUSH
86432: LD_EXP 106
86436: PPUSH
86437: LD_VAR 0 5
86441: PUSH
86442: LD_EXP 106
86446: PUSH
86447: LD_VAR 0 5
86451: ARRAY
86452: PUSH
86453: LD_INT 1
86455: PLUS
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PPUSH
86461: LD_VAR 0 2
86465: PUSH
86466: LD_VAR 0 4
86470: ARRAY
86471: PUSH
86472: LD_VAR 0 2
86476: PUSH
86477: LD_VAR 0 4
86481: ARRAY
86482: PPUSH
86483: CALL_OW 255
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PPUSH
86492: CALL 14797 0 3
86496: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86497: LD_VAR 0 2
86501: PUSH
86502: LD_VAR 0 4
86506: ARRAY
86507: PPUSH
86508: LD_VAR 0 1
86512: PPUSH
86513: CALL_OW 255
86517: PPUSH
86518: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86522: LD_VAR 0 2
86526: PUSH
86527: LD_VAR 0 4
86531: ARRAY
86532: PPUSH
86533: CALL_OW 141
// end ;
86537: GO 86369
86539: POP
86540: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86541: LD_VAR 0 1
86545: PPUSH
86546: LD_EXP 106
86550: PUSH
86551: LD_VAR 0 5
86555: ARRAY
86556: PUSH
86557: LD_INT 0
86559: PLUS
86560: PPUSH
86561: CALL_OW 505
// end ;
86565: LD_VAR 0 3
86569: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86570: LD_INT 0
86572: PPUSH
86573: PPUSH
86574: PPUSH
86575: PPUSH
// if not hack in hackTanks then
86576: LD_VAR 0 1
86580: PUSH
86581: LD_EXP 105
86585: IN
86586: NOT
86587: IFFALSE 86591
// exit ;
86589: GO 86831
// index := GetElementIndex ( hackTanks , hack ) ;
86591: LD_ADDR_VAR 0 4
86595: PUSH
86596: LD_EXP 105
86600: PPUSH
86601: LD_VAR 0 1
86605: PPUSH
86606: CALL 14582 0 2
86610: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86611: LD_ADDR_VAR 0 3
86615: PUSH
86616: DOUBLE
86617: LD_EXP 106
86621: PUSH
86622: LD_VAR 0 4
86626: ARRAY
86627: INC
86628: ST_TO_ADDR
86629: LD_INT 1
86631: PUSH
86632: FOR_DOWNTO
86633: IFFALSE 86805
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86635: LD_ADDR_VAR 0 5
86639: PUSH
86640: LD_EXP 106
86644: PUSH
86645: LD_VAR 0 4
86649: ARRAY
86650: PUSH
86651: LD_VAR 0 3
86655: ARRAY
86656: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86657: LD_VAR 0 5
86661: PUSH
86662: LD_INT 1
86664: ARRAY
86665: PPUSH
86666: CALL_OW 302
86670: NOT
86671: PUSH
86672: LD_VAR 0 5
86676: PUSH
86677: LD_INT 1
86679: ARRAY
86680: PPUSH
86681: CALL_OW 255
86685: PUSH
86686: LD_VAR 0 1
86690: PPUSH
86691: CALL_OW 255
86695: NONEQUAL
86696: OR
86697: IFFALSE 86803
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86699: LD_VAR 0 5
86703: PUSH
86704: LD_INT 1
86706: ARRAY
86707: PPUSH
86708: CALL_OW 305
86712: PUSH
86713: LD_VAR 0 5
86717: PUSH
86718: LD_INT 1
86720: ARRAY
86721: PPUSH
86722: CALL_OW 255
86726: PUSH
86727: LD_VAR 0 1
86731: PPUSH
86732: CALL_OW 255
86736: EQUAL
86737: AND
86738: IFFALSE 86762
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86740: LD_VAR 0 5
86744: PUSH
86745: LD_INT 1
86747: ARRAY
86748: PPUSH
86749: LD_VAR 0 5
86753: PUSH
86754: LD_INT 2
86756: ARRAY
86757: PPUSH
86758: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86762: LD_ADDR_EXP 106
86766: PUSH
86767: LD_EXP 106
86771: PPUSH
86772: LD_VAR 0 4
86776: PPUSH
86777: LD_EXP 106
86781: PUSH
86782: LD_VAR 0 4
86786: ARRAY
86787: PPUSH
86788: LD_VAR 0 3
86792: PPUSH
86793: CALL_OW 3
86797: PPUSH
86798: CALL_OW 1
86802: ST_TO_ADDR
// end ; end ;
86803: GO 86632
86805: POP
86806: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86807: LD_VAR 0 1
86811: PPUSH
86812: LD_EXP 106
86816: PUSH
86817: LD_VAR 0 4
86821: ARRAY
86822: PUSH
86823: LD_INT 0
86825: PLUS
86826: PPUSH
86827: CALL_OW 505
// end ;
86831: LD_VAR 0 2
86835: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86836: LD_INT 0
86838: PPUSH
86839: PPUSH
86840: PPUSH
86841: PPUSH
// if not hack in hackTanks then
86842: LD_VAR 0 1
86846: PUSH
86847: LD_EXP 105
86851: IN
86852: NOT
86853: IFFALSE 86857
// exit ;
86855: GO 86942
// index := GetElementIndex ( hackTanks , hack ) ;
86857: LD_ADDR_VAR 0 5
86861: PUSH
86862: LD_EXP 105
86866: PPUSH
86867: LD_VAR 0 1
86871: PPUSH
86872: CALL 14582 0 2
86876: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86877: LD_ADDR_VAR 0 4
86881: PUSH
86882: DOUBLE
86883: LD_INT 1
86885: DEC
86886: ST_TO_ADDR
86887: LD_EXP 106
86891: PUSH
86892: LD_VAR 0 5
86896: ARRAY
86897: PUSH
86898: FOR_TO
86899: IFFALSE 86940
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86901: LD_EXP 106
86905: PUSH
86906: LD_VAR 0 5
86910: ARRAY
86911: PUSH
86912: LD_VAR 0 4
86916: ARRAY
86917: PUSH
86918: LD_INT 1
86920: ARRAY
86921: PUSH
86922: LD_VAR 0 2
86926: EQUAL
86927: IFFALSE 86938
// KillUnit ( vehicle ) ;
86929: LD_VAR 0 2
86933: PPUSH
86934: CALL_OW 66
86938: GO 86898
86940: POP
86941: POP
// end ;
86942: LD_VAR 0 3
86946: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86947: LD_EXP 110
86951: NOT
86952: IFFALSE 86987
86954: GO 86956
86956: DISABLE
// begin initMiner := true ;
86957: LD_ADDR_EXP 110
86961: PUSH
86962: LD_INT 1
86964: ST_TO_ADDR
// minersList := [ ] ;
86965: LD_ADDR_EXP 111
86969: PUSH
86970: EMPTY
86971: ST_TO_ADDR
// minerMinesList := [ ] ;
86972: LD_ADDR_EXP 112
86976: PUSH
86977: EMPTY
86978: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86979: LD_ADDR_EXP 113
86983: PUSH
86984: LD_INT 5
86986: ST_TO_ADDR
// end ;
86987: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86988: LD_EXP 110
86992: PUSH
86993: LD_INT 34
86995: PUSH
86996: LD_EXP 93
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PPUSH
87005: CALL_OW 69
87009: AND
87010: IFFALSE 87473
87012: GO 87014
87014: DISABLE
87015: LD_INT 0
87017: PPUSH
87018: PPUSH
87019: PPUSH
87020: PPUSH
// begin enable ;
87021: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
87022: LD_ADDR_VAR 0 1
87026: PUSH
87027: LD_INT 34
87029: PUSH
87030: LD_EXP 93
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PPUSH
87039: CALL_OW 69
87043: PUSH
87044: FOR_IN
87045: IFFALSE 87117
// begin if not i in minersList then
87047: LD_VAR 0 1
87051: PUSH
87052: LD_EXP 111
87056: IN
87057: NOT
87058: IFFALSE 87115
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
87060: LD_ADDR_EXP 111
87064: PUSH
87065: LD_EXP 111
87069: PPUSH
87070: LD_EXP 111
87074: PUSH
87075: LD_INT 1
87077: PLUS
87078: PPUSH
87079: LD_VAR 0 1
87083: PPUSH
87084: CALL_OW 1
87088: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
87089: LD_ADDR_EXP 112
87093: PUSH
87094: LD_EXP 112
87098: PPUSH
87099: LD_EXP 112
87103: PUSH
87104: LD_INT 1
87106: PLUS
87107: PPUSH
87108: EMPTY
87109: PPUSH
87110: CALL_OW 1
87114: ST_TO_ADDR
// end end ;
87115: GO 87044
87117: POP
87118: POP
// for i := minerMinesList downto 1 do
87119: LD_ADDR_VAR 0 1
87123: PUSH
87124: DOUBLE
87125: LD_EXP 112
87129: INC
87130: ST_TO_ADDR
87131: LD_INT 1
87133: PUSH
87134: FOR_DOWNTO
87135: IFFALSE 87471
// begin if IsLive ( minersList [ i ] ) then
87137: LD_EXP 111
87141: PUSH
87142: LD_VAR 0 1
87146: ARRAY
87147: PPUSH
87148: CALL_OW 300
87152: IFFALSE 87180
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
87154: LD_EXP 111
87158: PUSH
87159: LD_VAR 0 1
87163: ARRAY
87164: PPUSH
87165: LD_EXP 112
87169: PUSH
87170: LD_VAR 0 1
87174: ARRAY
87175: PPUSH
87176: CALL_OW 505
// if not minerMinesList [ i ] then
87180: LD_EXP 112
87184: PUSH
87185: LD_VAR 0 1
87189: ARRAY
87190: NOT
87191: IFFALSE 87195
// continue ;
87193: GO 87134
// for j := minerMinesList [ i ] downto 1 do
87195: LD_ADDR_VAR 0 2
87199: PUSH
87200: DOUBLE
87201: LD_EXP 112
87205: PUSH
87206: LD_VAR 0 1
87210: ARRAY
87211: INC
87212: ST_TO_ADDR
87213: LD_INT 1
87215: PUSH
87216: FOR_DOWNTO
87217: IFFALSE 87467
// begin side := GetSide ( minersList [ i ] ) ;
87219: LD_ADDR_VAR 0 3
87223: PUSH
87224: LD_EXP 111
87228: PUSH
87229: LD_VAR 0 1
87233: ARRAY
87234: PPUSH
87235: CALL_OW 255
87239: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
87240: LD_ADDR_VAR 0 4
87244: PUSH
87245: LD_EXP 112
87249: PUSH
87250: LD_VAR 0 1
87254: ARRAY
87255: PUSH
87256: LD_VAR 0 2
87260: ARRAY
87261: PUSH
87262: LD_INT 1
87264: ARRAY
87265: PPUSH
87266: LD_EXP 112
87270: PUSH
87271: LD_VAR 0 1
87275: ARRAY
87276: PUSH
87277: LD_VAR 0 2
87281: ARRAY
87282: PUSH
87283: LD_INT 2
87285: ARRAY
87286: PPUSH
87287: CALL_OW 428
87291: ST_TO_ADDR
// if not tmp then
87292: LD_VAR 0 4
87296: NOT
87297: IFFALSE 87301
// continue ;
87299: GO 87216
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
87301: LD_VAR 0 4
87305: PUSH
87306: LD_INT 81
87308: PUSH
87309: LD_VAR 0 3
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PPUSH
87318: CALL_OW 69
87322: IN
87323: PUSH
87324: LD_EXP 112
87328: PUSH
87329: LD_VAR 0 1
87333: ARRAY
87334: PUSH
87335: LD_VAR 0 2
87339: ARRAY
87340: PUSH
87341: LD_INT 1
87343: ARRAY
87344: PPUSH
87345: LD_EXP 112
87349: PUSH
87350: LD_VAR 0 1
87354: ARRAY
87355: PUSH
87356: LD_VAR 0 2
87360: ARRAY
87361: PUSH
87362: LD_INT 2
87364: ARRAY
87365: PPUSH
87366: CALL_OW 458
87370: AND
87371: IFFALSE 87465
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
87373: LD_EXP 112
87377: PUSH
87378: LD_VAR 0 1
87382: ARRAY
87383: PUSH
87384: LD_VAR 0 2
87388: ARRAY
87389: PUSH
87390: LD_INT 1
87392: ARRAY
87393: PPUSH
87394: LD_EXP 112
87398: PUSH
87399: LD_VAR 0 1
87403: ARRAY
87404: PUSH
87405: LD_VAR 0 2
87409: ARRAY
87410: PUSH
87411: LD_INT 2
87413: ARRAY
87414: PPUSH
87415: LD_VAR 0 3
87419: PPUSH
87420: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
87424: LD_ADDR_EXP 112
87428: PUSH
87429: LD_EXP 112
87433: PPUSH
87434: LD_VAR 0 1
87438: PPUSH
87439: LD_EXP 112
87443: PUSH
87444: LD_VAR 0 1
87448: ARRAY
87449: PPUSH
87450: LD_VAR 0 2
87454: PPUSH
87455: CALL_OW 3
87459: PPUSH
87460: CALL_OW 1
87464: ST_TO_ADDR
// end ; end ;
87465: GO 87216
87467: POP
87468: POP
// end ;
87469: GO 87134
87471: POP
87472: POP
// end ;
87473: PPOPN 4
87475: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87476: LD_INT 0
87478: PPUSH
87479: PPUSH
// result := false ;
87480: LD_ADDR_VAR 0 4
87484: PUSH
87485: LD_INT 0
87487: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87488: LD_VAR 0 1
87492: PPUSH
87493: CALL_OW 264
87497: PUSH
87498: LD_EXP 93
87502: EQUAL
87503: NOT
87504: IFFALSE 87508
// exit ;
87506: GO 87748
// index := GetElementIndex ( minersList , unit ) ;
87508: LD_ADDR_VAR 0 5
87512: PUSH
87513: LD_EXP 111
87517: PPUSH
87518: LD_VAR 0 1
87522: PPUSH
87523: CALL 14582 0 2
87527: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87528: LD_EXP 112
87532: PUSH
87533: LD_VAR 0 5
87537: ARRAY
87538: PUSH
87539: LD_EXP 113
87543: GREATEREQUAL
87544: IFFALSE 87548
// exit ;
87546: GO 87748
// ComMoveXY ( unit , x , y ) ;
87548: LD_VAR 0 1
87552: PPUSH
87553: LD_VAR 0 2
87557: PPUSH
87558: LD_VAR 0 3
87562: PPUSH
87563: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87567: LD_INT 35
87569: PPUSH
87570: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87574: LD_VAR 0 1
87578: PPUSH
87579: LD_VAR 0 2
87583: PPUSH
87584: LD_VAR 0 3
87588: PPUSH
87589: CALL 44979 0 3
87593: NOT
87594: PUSH
87595: LD_VAR 0 1
87599: PPUSH
87600: CALL_OW 314
87604: AND
87605: IFFALSE 87609
// exit ;
87607: GO 87748
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87609: LD_VAR 0 2
87613: PPUSH
87614: LD_VAR 0 3
87618: PPUSH
87619: CALL_OW 428
87623: PUSH
87624: LD_VAR 0 1
87628: EQUAL
87629: PUSH
87630: LD_VAR 0 1
87634: PPUSH
87635: CALL_OW 314
87639: NOT
87640: AND
87641: IFFALSE 87567
// PlaySoundXY ( x , y , PlantMine ) ;
87643: LD_VAR 0 2
87647: PPUSH
87648: LD_VAR 0 3
87652: PPUSH
87653: LD_STRING PlantMine
87655: PPUSH
87656: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87660: LD_VAR 0 2
87664: PPUSH
87665: LD_VAR 0 3
87669: PPUSH
87670: LD_VAR 0 1
87674: PPUSH
87675: CALL_OW 255
87679: PPUSH
87680: LD_INT 0
87682: PPUSH
87683: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87687: LD_ADDR_EXP 112
87691: PUSH
87692: LD_EXP 112
87696: PPUSH
87697: LD_VAR 0 5
87701: PUSH
87702: LD_EXP 112
87706: PUSH
87707: LD_VAR 0 5
87711: ARRAY
87712: PUSH
87713: LD_INT 1
87715: PLUS
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PPUSH
87721: LD_VAR 0 2
87725: PUSH
87726: LD_VAR 0 3
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PPUSH
87735: CALL 14797 0 3
87739: ST_TO_ADDR
// result := true ;
87740: LD_ADDR_VAR 0 4
87744: PUSH
87745: LD_INT 1
87747: ST_TO_ADDR
// end ;
87748: LD_VAR 0 4
87752: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87753: LD_INT 0
87755: PPUSH
87756: PPUSH
87757: PPUSH
// if not unit in minersList then
87758: LD_VAR 0 1
87762: PUSH
87763: LD_EXP 111
87767: IN
87768: NOT
87769: IFFALSE 87773
// exit ;
87771: GO 88165
// index := GetElementIndex ( minersList , unit ) ;
87773: LD_ADDR_VAR 0 6
87777: PUSH
87778: LD_EXP 111
87782: PPUSH
87783: LD_VAR 0 1
87787: PPUSH
87788: CALL 14582 0 2
87792: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87793: LD_ADDR_VAR 0 5
87797: PUSH
87798: DOUBLE
87799: LD_EXP 112
87803: PUSH
87804: LD_VAR 0 6
87808: ARRAY
87809: INC
87810: ST_TO_ADDR
87811: LD_INT 1
87813: PUSH
87814: FOR_DOWNTO
87815: IFFALSE 87976
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87817: LD_EXP 112
87821: PUSH
87822: LD_VAR 0 6
87826: ARRAY
87827: PUSH
87828: LD_VAR 0 5
87832: ARRAY
87833: PUSH
87834: LD_INT 1
87836: ARRAY
87837: PUSH
87838: LD_VAR 0 2
87842: EQUAL
87843: PUSH
87844: LD_EXP 112
87848: PUSH
87849: LD_VAR 0 6
87853: ARRAY
87854: PUSH
87855: LD_VAR 0 5
87859: ARRAY
87860: PUSH
87861: LD_INT 2
87863: ARRAY
87864: PUSH
87865: LD_VAR 0 3
87869: EQUAL
87870: AND
87871: IFFALSE 87974
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87873: LD_EXP 112
87877: PUSH
87878: LD_VAR 0 6
87882: ARRAY
87883: PUSH
87884: LD_VAR 0 5
87888: ARRAY
87889: PUSH
87890: LD_INT 1
87892: ARRAY
87893: PPUSH
87894: LD_EXP 112
87898: PUSH
87899: LD_VAR 0 6
87903: ARRAY
87904: PUSH
87905: LD_VAR 0 5
87909: ARRAY
87910: PUSH
87911: LD_INT 2
87913: ARRAY
87914: PPUSH
87915: LD_VAR 0 1
87919: PPUSH
87920: CALL_OW 255
87924: PPUSH
87925: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87929: LD_ADDR_EXP 112
87933: PUSH
87934: LD_EXP 112
87938: PPUSH
87939: LD_VAR 0 6
87943: PPUSH
87944: LD_EXP 112
87948: PUSH
87949: LD_VAR 0 6
87953: ARRAY
87954: PPUSH
87955: LD_VAR 0 5
87959: PPUSH
87960: CALL_OW 3
87964: PPUSH
87965: CALL_OW 1
87969: ST_TO_ADDR
// exit ;
87970: POP
87971: POP
87972: GO 88165
// end ; end ;
87974: GO 87814
87976: POP
87977: POP
// for i := minerMinesList [ index ] downto 1 do
87978: LD_ADDR_VAR 0 5
87982: PUSH
87983: DOUBLE
87984: LD_EXP 112
87988: PUSH
87989: LD_VAR 0 6
87993: ARRAY
87994: INC
87995: ST_TO_ADDR
87996: LD_INT 1
87998: PUSH
87999: FOR_DOWNTO
88000: IFFALSE 88163
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
88002: LD_EXP 112
88006: PUSH
88007: LD_VAR 0 6
88011: ARRAY
88012: PUSH
88013: LD_VAR 0 5
88017: ARRAY
88018: PUSH
88019: LD_INT 1
88021: ARRAY
88022: PPUSH
88023: LD_EXP 112
88027: PUSH
88028: LD_VAR 0 6
88032: ARRAY
88033: PUSH
88034: LD_VAR 0 5
88038: ARRAY
88039: PUSH
88040: LD_INT 2
88042: ARRAY
88043: PPUSH
88044: LD_VAR 0 2
88048: PPUSH
88049: LD_VAR 0 3
88053: PPUSH
88054: CALL_OW 298
88058: PUSH
88059: LD_INT 6
88061: LESS
88062: IFFALSE 88161
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
88064: LD_EXP 112
88068: PUSH
88069: LD_VAR 0 6
88073: ARRAY
88074: PUSH
88075: LD_VAR 0 5
88079: ARRAY
88080: PUSH
88081: LD_INT 1
88083: ARRAY
88084: PPUSH
88085: LD_EXP 112
88089: PUSH
88090: LD_VAR 0 6
88094: ARRAY
88095: PUSH
88096: LD_VAR 0 5
88100: ARRAY
88101: PUSH
88102: LD_INT 2
88104: ARRAY
88105: PPUSH
88106: LD_VAR 0 1
88110: PPUSH
88111: CALL_OW 255
88115: PPUSH
88116: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
88120: LD_ADDR_EXP 112
88124: PUSH
88125: LD_EXP 112
88129: PPUSH
88130: LD_VAR 0 6
88134: PPUSH
88135: LD_EXP 112
88139: PUSH
88140: LD_VAR 0 6
88144: ARRAY
88145: PPUSH
88146: LD_VAR 0 5
88150: PPUSH
88151: CALL_OW 3
88155: PPUSH
88156: CALL_OW 1
88160: ST_TO_ADDR
// end ; end ;
88161: GO 87999
88163: POP
88164: POP
// end ;
88165: LD_VAR 0 4
88169: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
88170: LD_INT 0
88172: PPUSH
88173: PPUSH
88174: PPUSH
88175: PPUSH
88176: PPUSH
88177: PPUSH
88178: PPUSH
88179: PPUSH
88180: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
88181: LD_VAR 0 1
88185: PPUSH
88186: CALL_OW 264
88190: PUSH
88191: LD_EXP 93
88195: EQUAL
88196: NOT
88197: PUSH
88198: LD_VAR 0 1
88202: PUSH
88203: LD_EXP 111
88207: IN
88208: NOT
88209: OR
88210: IFFALSE 88214
// exit ;
88212: GO 88536
// index := GetElementIndex ( minersList , unit ) ;
88214: LD_ADDR_VAR 0 6
88218: PUSH
88219: LD_EXP 111
88223: PPUSH
88224: LD_VAR 0 1
88228: PPUSH
88229: CALL 14582 0 2
88233: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
88234: LD_ADDR_VAR 0 8
88238: PUSH
88239: LD_EXP 113
88243: PUSH
88244: LD_EXP 112
88248: PUSH
88249: LD_VAR 0 6
88253: ARRAY
88254: MINUS
88255: ST_TO_ADDR
// if not minesFreeAmount then
88256: LD_VAR 0 8
88260: NOT
88261: IFFALSE 88265
// exit ;
88263: GO 88536
// tmp := [ ] ;
88265: LD_ADDR_VAR 0 7
88269: PUSH
88270: EMPTY
88271: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
88272: LD_ADDR_VAR 0 5
88276: PUSH
88277: DOUBLE
88278: LD_INT 1
88280: DEC
88281: ST_TO_ADDR
88282: LD_VAR 0 8
88286: PUSH
88287: FOR_TO
88288: IFFALSE 88483
// begin _d := rand ( 0 , 5 ) ;
88290: LD_ADDR_VAR 0 11
88294: PUSH
88295: LD_INT 0
88297: PPUSH
88298: LD_INT 5
88300: PPUSH
88301: CALL_OW 12
88305: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
88306: LD_ADDR_VAR 0 12
88310: PUSH
88311: LD_INT 2
88313: PPUSH
88314: LD_INT 6
88316: PPUSH
88317: CALL_OW 12
88321: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
88322: LD_ADDR_VAR 0 9
88326: PUSH
88327: LD_VAR 0 2
88331: PPUSH
88332: LD_VAR 0 11
88336: PPUSH
88337: LD_VAR 0 12
88341: PPUSH
88342: CALL_OW 272
88346: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
88347: LD_ADDR_VAR 0 10
88351: PUSH
88352: LD_VAR 0 3
88356: PPUSH
88357: LD_VAR 0 11
88361: PPUSH
88362: LD_VAR 0 12
88366: PPUSH
88367: CALL_OW 273
88371: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
88372: LD_VAR 0 9
88376: PPUSH
88377: LD_VAR 0 10
88381: PPUSH
88382: CALL_OW 488
88386: PUSH
88387: LD_VAR 0 9
88391: PUSH
88392: LD_VAR 0 10
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_VAR 0 7
88405: IN
88406: NOT
88407: AND
88408: PUSH
88409: LD_VAR 0 9
88413: PPUSH
88414: LD_VAR 0 10
88418: PPUSH
88419: CALL_OW 458
88423: NOT
88424: AND
88425: IFFALSE 88467
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
88427: LD_ADDR_VAR 0 7
88431: PUSH
88432: LD_VAR 0 7
88436: PPUSH
88437: LD_VAR 0 7
88441: PUSH
88442: LD_INT 1
88444: PLUS
88445: PPUSH
88446: LD_VAR 0 9
88450: PUSH
88451: LD_VAR 0 10
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PPUSH
88460: CALL_OW 1
88464: ST_TO_ADDR
88465: GO 88481
// i := i - 1 ;
88467: LD_ADDR_VAR 0 5
88471: PUSH
88472: LD_VAR 0 5
88476: PUSH
88477: LD_INT 1
88479: MINUS
88480: ST_TO_ADDR
// end ;
88481: GO 88287
88483: POP
88484: POP
// for i in tmp do
88485: LD_ADDR_VAR 0 5
88489: PUSH
88490: LD_VAR 0 7
88494: PUSH
88495: FOR_IN
88496: IFFALSE 88534
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88498: LD_VAR 0 1
88502: PPUSH
88503: LD_VAR 0 5
88507: PUSH
88508: LD_INT 1
88510: ARRAY
88511: PPUSH
88512: LD_VAR 0 5
88516: PUSH
88517: LD_INT 2
88519: ARRAY
88520: PPUSH
88521: CALL 87476 0 3
88525: NOT
88526: IFFALSE 88532
// exit ;
88528: POP
88529: POP
88530: GO 88536
88532: GO 88495
88534: POP
88535: POP
// end ;
88536: LD_VAR 0 4
88540: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88541: LD_INT 0
88543: PPUSH
88544: PPUSH
88545: PPUSH
88546: PPUSH
88547: PPUSH
88548: PPUSH
88549: PPUSH
// if not GetClass ( unit ) = class_sniper then
88550: LD_VAR 0 1
88554: PPUSH
88555: CALL_OW 257
88559: PUSH
88560: LD_INT 5
88562: EQUAL
88563: NOT
88564: IFFALSE 88568
// exit ;
88566: GO 88956
// dist := 8 ;
88568: LD_ADDR_VAR 0 5
88572: PUSH
88573: LD_INT 8
88575: ST_TO_ADDR
// viewRange := 12 ;
88576: LD_ADDR_VAR 0 7
88580: PUSH
88581: LD_INT 12
88583: ST_TO_ADDR
// side := GetSide ( unit ) ;
88584: LD_ADDR_VAR 0 6
88588: PUSH
88589: LD_VAR 0 1
88593: PPUSH
88594: CALL_OW 255
88598: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88599: LD_INT 61
88601: PPUSH
88602: LD_VAR 0 6
88606: PPUSH
88607: CALL_OW 321
88611: PUSH
88612: LD_INT 2
88614: EQUAL
88615: IFFALSE 88625
// viewRange := 16 ;
88617: LD_ADDR_VAR 0 7
88621: PUSH
88622: LD_INT 16
88624: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88625: LD_VAR 0 1
88629: PPUSH
88630: LD_VAR 0 2
88634: PPUSH
88635: LD_VAR 0 3
88639: PPUSH
88640: CALL_OW 297
88644: PUSH
88645: LD_VAR 0 5
88649: GREATER
88650: IFFALSE 88729
// begin ComMoveXY ( unit , x , y ) ;
88652: LD_VAR 0 1
88656: PPUSH
88657: LD_VAR 0 2
88661: PPUSH
88662: LD_VAR 0 3
88666: PPUSH
88667: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88671: LD_INT 35
88673: PPUSH
88674: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88678: LD_VAR 0 1
88682: PPUSH
88683: LD_VAR 0 2
88687: PPUSH
88688: LD_VAR 0 3
88692: PPUSH
88693: CALL 44979 0 3
88697: NOT
88698: IFFALSE 88702
// exit ;
88700: GO 88956
// until GetDistUnitXY ( unit , x , y ) < dist ;
88702: LD_VAR 0 1
88706: PPUSH
88707: LD_VAR 0 2
88711: PPUSH
88712: LD_VAR 0 3
88716: PPUSH
88717: CALL_OW 297
88721: PUSH
88722: LD_VAR 0 5
88726: LESS
88727: IFFALSE 88671
// end ; ComTurnXY ( unit , x , y ) ;
88729: LD_VAR 0 1
88733: PPUSH
88734: LD_VAR 0 2
88738: PPUSH
88739: LD_VAR 0 3
88743: PPUSH
88744: CALL_OW 118
// wait ( 5 ) ;
88748: LD_INT 5
88750: PPUSH
88751: CALL_OW 67
// _d := GetDir ( unit ) ;
88755: LD_ADDR_VAR 0 10
88759: PUSH
88760: LD_VAR 0 1
88764: PPUSH
88765: CALL_OW 254
88769: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88770: LD_ADDR_VAR 0 8
88774: PUSH
88775: LD_VAR 0 1
88779: PPUSH
88780: CALL_OW 250
88784: PPUSH
88785: LD_VAR 0 10
88789: PPUSH
88790: LD_VAR 0 5
88794: PPUSH
88795: CALL_OW 272
88799: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88800: LD_ADDR_VAR 0 9
88804: PUSH
88805: LD_VAR 0 1
88809: PPUSH
88810: CALL_OW 251
88814: PPUSH
88815: LD_VAR 0 10
88819: PPUSH
88820: LD_VAR 0 5
88824: PPUSH
88825: CALL_OW 273
88829: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88830: LD_VAR 0 8
88834: PPUSH
88835: LD_VAR 0 9
88839: PPUSH
88840: CALL_OW 488
88844: NOT
88845: IFFALSE 88849
// exit ;
88847: GO 88956
// ComAnimCustom ( unit , 1 ) ;
88849: LD_VAR 0 1
88853: PPUSH
88854: LD_INT 1
88856: PPUSH
88857: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88861: LD_VAR 0 8
88865: PPUSH
88866: LD_VAR 0 9
88870: PPUSH
88871: LD_VAR 0 6
88875: PPUSH
88876: LD_VAR 0 7
88880: PPUSH
88881: CALL_OW 330
// repeat wait ( 1 ) ;
88885: LD_INT 1
88887: PPUSH
88888: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88892: LD_VAR 0 1
88896: PPUSH
88897: CALL_OW 316
88901: PUSH
88902: LD_VAR 0 1
88906: PPUSH
88907: CALL_OW 314
88911: OR
88912: PUSH
88913: LD_VAR 0 1
88917: PPUSH
88918: CALL_OW 302
88922: NOT
88923: OR
88924: PUSH
88925: LD_VAR 0 1
88929: PPUSH
88930: CALL_OW 301
88934: OR
88935: IFFALSE 88885
// RemoveSeeing ( _x , _y , side ) ;
88937: LD_VAR 0 8
88941: PPUSH
88942: LD_VAR 0 9
88946: PPUSH
88947: LD_VAR 0 6
88951: PPUSH
88952: CALL_OW 331
// end ; end_of_file
88956: LD_VAR 0 4
88960: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88961: LD_VAR 0 1
88965: PUSH
88966: LD_INT 200
88968: DOUBLE
88969: GREATEREQUAL
88970: IFFALSE 88978
88972: LD_INT 299
88974: DOUBLE
88975: LESSEQUAL
88976: IFTRUE 88980
88978: GO 89012
88980: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
88981: LD_VAR 0 1
88985: PPUSH
88986: LD_VAR 0 2
88990: PPUSH
88991: LD_VAR 0 3
88995: PPUSH
88996: LD_VAR 0 4
89000: PPUSH
89001: LD_VAR 0 5
89005: PPUSH
89006: CALL 85078 0 5
89010: GO 89013
89012: POP
// end ;
89013: PPOPN 11
89015: END
