// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: NOP4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: NOP4
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: NOP4
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: NOP4
10651: PUSH
10652: NOP4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: NOP4
10664: PPUSH
10665: NOP4
10669: PPUSH
10670: NOP4
10674: PUSH
10675: NOP4
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: NOP4
10686: PUSH
10687: NOP4
10691: PUSH
10692: NOP4
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: NOP4
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: NOP4
10724: PUSH
10725: NOP4
10729: PPUSH
10730: NOP4
10734: ST_TO_ADDR
// if not tmp then
10735: NOP4
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: NOP4
10748: PUSH
10749: NOP4
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: NOP4
10761: PPUSH
10762: NOP4
10766: PPUSH
10767: NOP4
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: NOP4
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: NOP4
10817: NOT
10818: PUSH
10819: NOP4
10823: PPUSH
10824: NOP4
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: NOP4
10841: PUSH
10842: NOP4
10846: PPUSH
10847: NOP4
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: NOP4
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: NOP4
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: NOP4
10872: PUSH
10873: NOP4
10877: PPUSH
10878: NOP4
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: NOP4
10887: PPUSH
10888: NOP4
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: NOP4
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: NOP4
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: NOP4
10942: ST_TO_ADDR
// if not tmp then
10943: NOP4
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: NOP4
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: NOP4
10962: PUSH
10963: NOP4
10967: PPUSH
10968: NOP4
10972: PPUSH
10973: NOP4
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: NOP4
10984: PUSH
10985: NOP4
10989: PPUSH
10990: NOP4
10994: PPUSH
10995: NOP4
10999: ST_TO_ADDR
// if not enemy then
11000: NOP4
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: NOP4
11013: PUSH
11014: NOP4
11018: PPUSH
11019: NOP4
11023: PPUSH
11024: NOP4
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: NOP4
11038: PPUSH
11039: NOP4
11043: PPUSH
11044: NOP4
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: NOP4
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: NOP4
11072: PPUSH
11073: NOP4
11077: PPUSH
11078: NOP4
11082: IFFALSE 11111
// missile := Insert ( missile , missile + 1 , 2 ) ;
11084: NOP4
11088: PUSH
11089: NOP4
11093: PPUSH
11094: NOP4
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: NOP4
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: NOP4
11115: PPUSH
11116: NOP4
11120: PPUSH
11121: NOP4
11125: PUSH
11126: NOP4
11130: PPUSH
11131: NOP4
11135: PPUSH
11136: NOP4
11140: PPUSH
11141: NOP4
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Insert ( missile , missile + 1 , 3 ) ;
11149: NOP4
11153: PUSH
11154: NOP4
11158: PPUSH
11159: NOP4
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: NOP4
11175: ST_TO_ADDR
// if missile < 2 then
11176: NOP4
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: NOP4
11192: PUSH
11193: NOP4
11197: PPUSH
11198: NOP4
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: NOP4
11207: PUSH
11208: NOP4
11212: PPUSH
11213: NOP4
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: NOP4
11222: PUSH
11223: NOP4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: NOP4
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: NOP4
11245: PUSH
11246: NOP4
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: NOP4
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: NOP4
11268: PPUSH
11269: NOP4
11273: PPUSH
11274: NOP4
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: NOP4
11285: PUSH
11286: NOP4
11290: ST_TO_ADDR
// _y := y ;
11291: NOP4
11295: PUSH
11296: NOP4
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: NOP4
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: NOP4
11313: PPUSH
11314: NOP4
11318: ST_TO_ADDR
// case i of 1 :
11319: NOP4
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: NOP4
11337: PPUSH
11338: NOP4
11342: PPUSH
11343: NOP4
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: NOP4
11362: PPUSH
11363: NOP4
11367: PPUSH
11368: NOP4
11372: PPUSH
11373: NOP4
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: NOP4
11392: PPUSH
11393: NOP4
11397: PPUSH
11398: NOP4
11402: PPUSH
11403: NOP4
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: NOP4
11427: NOT
11428: PUSH
11429: NOP4
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: NOP4
11443: PUSH
11444: NOP4
11448: PPUSH
11449: NOP4
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: NOP4
11458: PUSH
11459: NOP4
11463: PPUSH
11464: NOP4
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: NOP4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: NOP4
11489: PUSH
11490: NOP4
11494: PPUSH
11495: NOP4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: NOP4
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: NOP4
11512: PUSH
11513: NOP4
11517: PPUSH
11518: NOP4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: NOP4
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: NOP4
11535: PPUSH
11536: NOP4
11540: PPUSH
11541: NOP4
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: NOP4
11554: PPUSH
11555: NOP4
11559: PPUSH
11560: NOP4
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: NOP4
11574: PPUSH
11575: NOP4
11579: PPUSH
11580: NOP4
11584: PPUSH
11585: NOP4
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: NOP4
11609: PUSH
11610: NOP4
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: NOP4
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: NOP4
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: NOP4
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: NOP4
11655: PUSH
11656: NOP4
11660: PPUSH
11661: NOP4
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: NOP4
11670: PUSH
11671: NOP4
11675: PPUSH
11676: NOP4
11680: ST_TO_ADDR
// case nat of 1 :
11681: NOP4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: NOP4
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: NOP4
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: NOP4
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: NOP4
11748: PPUSH
11749: NOP4
11753: PPUSH
11754: NOP4
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: NOP4
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: NOP4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: NOP4
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: NOP4
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: NOP4
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: NOP4
11846: ST_TO_ADDR
// for i in mines do
11847: NOP4
11851: PUSH
11852: NOP4
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: NOP4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: NOP4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: NOP4
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: NOP4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: NOP4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: NOP4
11909: PUSH
11910: NOP4
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: NOP4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: NOP4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: NOP4
11939: PPUSH
11940: NOP4
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: NOP4
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: NOP4
11969: PUSH
11970: NOP4
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: NOP4
11982: IFFALSE 11998
// result := result + 1 ;
11984: NOP4
11988: PUSH
11989: NOP4
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: NOP4
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: NOP4
12023: PUSH
12024: NOP4
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: NOP4
12036: PPUSH
12037: NOP4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: NOP4
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; begin
12067: LD_INT 0
12069: PPUSH
// if not building then
12070: NOP4
12074: NOT
12075: IFFALSE 12079
// exit ;
12077: GO 12098
// result := UnitsInside ( building ) < 6 ;
12079: NOP4
12083: PUSH
12084: NOP4
12088: PPUSH
12089: NOP4
12093: PUSH
12094: LD_INT 6
12096: LESS
12097: ST_TO_ADDR
// end ;
12098: LD_VAR 0 2
12102: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12103: LD_INT 0
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// tmp := [ ] ;
12109: NOP4
12113: PUSH
12114: EMPTY
12115: ST_TO_ADDR
// list := [ ] ;
12116: NOP4
12120: PUSH
12121: EMPTY
12122: ST_TO_ADDR
// for i = 16 to 25 do
12123: NOP4
12127: PUSH
12128: DOUBLE
12129: LD_INT 16
12131: DEC
12132: ST_TO_ADDR
12133: LD_INT 25
12135: PUSH
12136: FOR_TO
12137: IFFALSE 12210
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12139: NOP4
12143: PUSH
12144: NOP4
12148: PUSH
12149: LD_INT 22
12151: PUSH
12152: NOP4
12156: PPUSH
12157: NOP4
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 91
12168: PUSH
12169: NOP4
12173: PUSH
12174: LD_INT 6
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 30
12184: PUSH
12185: NOP4
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: LIST
12198: PUSH
12199: EMPTY
12200: LIST
12201: PPUSH
12202: NOP4
12206: ADD
12207: ST_TO_ADDR
12208: GO 12136
12210: POP
12211: POP
// for i = 1 to tmp do
12212: NOP4
12216: PUSH
12217: DOUBLE
12218: LD_INT 1
12220: DEC
12221: ST_TO_ADDR
12222: NOP4
12226: PUSH
12227: FOR_TO
12228: IFFALSE 12316
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12230: NOP4
12234: PUSH
12235: NOP4
12239: PUSH
12240: NOP4
12244: PUSH
12245: NOP4
12249: ARRAY
12250: PPUSH
12251: NOP4
12255: PUSH
12256: NOP4
12260: PUSH
12261: NOP4
12265: ARRAY
12266: PPUSH
12267: NOP4
12271: PUSH
12272: NOP4
12276: PUSH
12277: NOP4
12281: ARRAY
12282: PPUSH
12283: NOP4
12287: PUSH
12288: NOP4
12292: PUSH
12293: NOP4
12297: ARRAY
12298: PPUSH
12299: NOP4
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: PUSH
12310: EMPTY
12311: LIST
12312: ADD
12313: ST_TO_ADDR
12314: GO 12227
12316: POP
12317: POP
// result := list ;
12318: NOP4
12322: PUSH
12323: NOP4
12327: ST_TO_ADDR
// end ;
12328: LD_VAR 0 2
12332: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12333: LD_INT 0
12335: PPUSH
12336: PPUSH
12337: PPUSH
12338: PPUSH
12339: PPUSH
12340: PPUSH
12341: PPUSH
// if not factory then
12342: NOP4
12346: NOT
12347: IFFALSE 12351
// exit ;
12349: GO 12944
// if control = control_apeman then
12351: NOP4
12355: PUSH
12356: LD_INT 5
12358: EQUAL
12359: IFFALSE 12468
// begin tmp := UnitsInside ( factory ) ;
12361: NOP4
12365: PUSH
12366: NOP4
12370: PPUSH
12371: NOP4
12375: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12376: NOP4
12380: PPUSH
12381: LD_INT 25
12383: PUSH
12384: LD_INT 12
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PPUSH
12391: NOP4
12395: NOT
12396: IFFALSE 12406
// control := control_manual ;
12398: NOP4
12402: PUSH
12403: LD_INT 1
12405: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12406: NOP4
12410: PUSH
12411: NOP4
12415: PPUSH
12416: NOP4
12420: ST_TO_ADDR
// if tmp then
12421: NOP4
12425: IFFALSE 12468
// begin for i in tmp do
12427: NOP4
12431: PUSH
12432: NOP4
12436: PUSH
12437: FOR_IN
12438: IFFALSE 12466
// if i [ 1 ] = b_ext_radio then
12440: NOP4
12444: PUSH
12445: LD_INT 1
12447: ARRAY
12448: PUSH
12449: LD_INT 22
12451: EQUAL
12452: IFFALSE 12464
// begin control := control_remote ;
12454: NOP4
12458: PUSH
12459: LD_INT 2
12461: ST_TO_ADDR
// break ;
12462: GO 12466
// end ;
12464: GO 12437
12466: POP
12467: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12468: NOP4
12472: PPUSH
12473: NOP4
12477: PPUSH
12478: NOP4
12482: PPUSH
12483: NOP4
12487: PPUSH
12488: NOP4
12492: PPUSH
12493: NOP4
12497: IFFALSE 12532
// begin result := [ chassis , engine , control , weapon ] ;
12499: NOP4
12503: PUSH
12504: NOP4
12508: PUSH
12509: NOP4
12513: PUSH
12514: NOP4
12518: PUSH
12519: NOP4
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: ST_TO_ADDR
// exit ;
12530: GO 12944
// end ; _chassis := AvailableChassisList ( factory ) ;
12532: NOP4
12536: PUSH
12537: NOP4
12541: PPUSH
12542: NOP4
12546: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12547: NOP4
12551: PUSH
12552: NOP4
12556: PPUSH
12557: NOP4
12561: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12562: NOP4
12566: PUSH
12567: NOP4
12571: PPUSH
12572: NOP4
12576: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12577: NOP4
12581: PUSH
12582: NOP4
12586: PPUSH
12587: NOP4
12591: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12592: NOP4
12596: NOT
12597: PUSH
12598: NOP4
12602: NOT
12603: OR
12604: PUSH
12605: NOP4
12609: NOT
12610: OR
12611: PUSH
12612: NOP4
12616: NOT
12617: OR
12618: IFFALSE 12653
// begin result := [ chassis , engine , control , weapon ] ;
12620: NOP4
12624: PUSH
12625: NOP4
12629: PUSH
12630: NOP4
12634: PUSH
12635: NOP4
12639: PUSH
12640: NOP4
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: ST_TO_ADDR
// exit ;
12651: GO 12944
// end ; if not chassis in _chassis then
12653: NOP4
12657: PUSH
12658: NOP4
12662: IN
12663: NOT
12664: IFFALSE 12690
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12666: NOP4
12670: PUSH
12671: NOP4
12675: PUSH
12676: LD_INT 1
12678: PPUSH
12679: NOP4
12683: PPUSH
12684: NOP4
12688: ARRAY
12689: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12690: NOP4
12694: PPUSH
12695: NOP4
12699: PPUSH
12700: NOP4
12704: NOT
12705: IFFALSE 12764
// repeat engine := _engine [ 1 ] ;
12707: NOP4
12711: PUSH
12712: NOP4
12716: PUSH
12717: LD_INT 1
12719: ARRAY
12720: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12721: NOP4
12725: PUSH
12726: NOP4
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: NOP4
12738: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12739: NOP4
12743: PPUSH
12744: NOP4
12748: PPUSH
12749: NOP4
12753: PUSH
12754: NOP4
12758: PUSH
12759: EMPTY
12760: EQUAL
12761: OR
12762: IFFALSE 12707
// if not control in _control then
12764: NOP4
12768: PUSH
12769: NOP4
12773: IN
12774: NOT
12775: IFFALSE 12801
// control := _control [ rand ( 1 , _control ) ] ;
12777: NOP4
12781: PUSH
12782: NOP4
12786: PUSH
12787: LD_INT 1
12789: PPUSH
12790: NOP4
12794: PPUSH
12795: NOP4
12799: ARRAY
12800: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12801: NOP4
12805: PPUSH
12806: NOP4
12810: PPUSH
12811: NOP4
12815: NOT
12816: IFFALSE 12875
// repeat weapon := _weapon [ 1 ] ;
12818: NOP4
12822: PUSH
12823: NOP4
12827: PUSH
12828: LD_INT 1
12830: ARRAY
12831: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12832: NOP4
12836: PUSH
12837: NOP4
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: NOP4
12849: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12850: NOP4
12854: PPUSH
12855: NOP4
12859: PPUSH
12860: NOP4
12864: PUSH
12865: NOP4
12869: PUSH
12870: EMPTY
12871: EQUAL
12872: OR
12873: IFFALSE 12818
// result := [ ] ;
12875: NOP4
12879: PUSH
12880: EMPTY
12881: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12882: NOP4
12886: PPUSH
12887: NOP4
12891: PPUSH
12892: NOP4
12896: PPUSH
12897: NOP4
12901: PPUSH
12902: NOP4
12906: PPUSH
12907: NOP4
12911: IFFALSE 12944
// result := [ chassis , engine , control , weapon ] ;
12913: NOP4
12917: PUSH
12918: NOP4
12922: PUSH
12923: NOP4
12927: PUSH
12928: NOP4
12932: PUSH
12933: NOP4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: ST_TO_ADDR
// end ;
12944: LD_VAR 0 6
12948: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12949: LD_INT 0
12951: PPUSH
// if not chassis or not engine then
12952: NOP4
12956: NOT
12957: PUSH
12958: NOP4
12962: NOT
12963: OR
12964: IFFALSE 12968
// exit ;
12966: GO 13164
// case engine of engine_solar :
12968: NOP4
12972: PUSH
12973: LD_INT 2
12975: DOUBLE
12976: EQUAL
12977: IFTRUE 12981
12979: GO 13019
12981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12982: NOP4
12986: PUSH
12987: LD_INT 11
12989: PUSH
12990: LD_INT 12
12992: PUSH
12993: LD_INT 13
12995: PUSH
12996: LD_INT 14
12998: PUSH
12999: LD_INT 1
13001: PUSH
13002: LD_INT 2
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: ST_TO_ADDR
13017: GO 13148
13019: LD_INT 1
13021: DOUBLE
13022: EQUAL
13023: IFTRUE 13027
13025: GO 13089
13027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13028: NOP4
13032: PUSH
13033: LD_INT 11
13035: PUSH
13036: LD_INT 12
13038: PUSH
13039: LD_INT 13
13041: PUSH
13042: LD_INT 14
13044: PUSH
13045: LD_INT 1
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 3
13053: PUSH
13054: LD_INT 4
13056: PUSH
13057: LD_INT 5
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 23
13065: PUSH
13066: LD_INT 22
13068: PUSH
13069: LD_INT 24
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: ST_TO_ADDR
13087: GO 13148
13089: LD_INT 3
13091: DOUBLE
13092: EQUAL
13093: IFTRUE 13097
13095: GO 13147
13097: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13098: NOP4
13102: PUSH
13103: LD_INT 13
13105: PUSH
13106: LD_INT 14
13108: PUSH
13109: LD_INT 2
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 4
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 21
13123: PUSH
13124: LD_INT 22
13126: PUSH
13127: LD_INT 23
13129: PUSH
13130: LD_INT 24
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: ST_TO_ADDR
13145: GO 13148
13147: POP
// result := ( chassis in result ) ;
13148: NOP4
13152: PUSH
13153: NOP4
13157: PUSH
13158: NOP4
13162: IN
13163: ST_TO_ADDR
// end ;
13164: LD_VAR 0 3
13168: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13169: LD_INT 0
13171: PPUSH
// if not chassis or not weapon then
13172: NOP4
13176: NOT
13177: PUSH
13178: NOP4
13182: NOT
13183: OR
13184: IFFALSE 13188
// exit ;
13186: GO 14250
// case weapon of us_machine_gun :
13188: NOP4
13192: PUSH
13193: LD_INT 2
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13231
13201: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13202: NOP4
13206: PUSH
13207: LD_INT 1
13209: PUSH
13210: LD_INT 2
13212: PUSH
13213: LD_INT 3
13215: PUSH
13216: LD_INT 4
13218: PUSH
13219: LD_INT 5
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: ST_TO_ADDR
13229: GO 14234
13231: LD_INT 3
13233: DOUBLE
13234: EQUAL
13235: IFTRUE 13239
13237: GO 13269
13239: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13240: NOP4
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: LD_INT 2
13250: PUSH
13251: LD_INT 3
13253: PUSH
13254: LD_INT 4
13256: PUSH
13257: LD_INT 5
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: ST_TO_ADDR
13267: GO 14234
13269: LD_INT 11
13271: DOUBLE
13272: EQUAL
13273: IFTRUE 13277
13275: GO 13307
13277: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13278: NOP4
13282: PUSH
13283: LD_INT 1
13285: PUSH
13286: LD_INT 2
13288: PUSH
13289: LD_INT 3
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: LD_INT 5
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: ST_TO_ADDR
13305: GO 14234
13307: LD_INT 4
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13341
13315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13316: NOP4
13320: PUSH
13321: LD_INT 2
13323: PUSH
13324: LD_INT 3
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: LD_INT 5
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: ST_TO_ADDR
13339: GO 14234
13341: LD_INT 5
13343: DOUBLE
13344: EQUAL
13345: IFTRUE 13349
13347: GO 13375
13349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13350: NOP4
13354: PUSH
13355: LD_INT 2
13357: PUSH
13358: LD_INT 3
13360: PUSH
13361: LD_INT 4
13363: PUSH
13364: LD_INT 5
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: ST_TO_ADDR
13373: GO 14234
13375: LD_INT 9
13377: DOUBLE
13378: EQUAL
13379: IFTRUE 13383
13381: GO 13409
13383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13384: NOP4
13388: PUSH
13389: LD_INT 2
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: LD_INT 4
13397: PUSH
13398: LD_INT 5
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: ST_TO_ADDR
13407: GO 14234
13409: LD_INT 7
13411: DOUBLE
13412: EQUAL
13413: IFTRUE 13417
13415: GO 13443
13417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13418: NOP4
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: LD_INT 3
13428: PUSH
13429: LD_INT 4
13431: PUSH
13432: LD_INT 5
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: ST_TO_ADDR
13441: GO 14234
13443: LD_INT 12
13445: DOUBLE
13446: EQUAL
13447: IFTRUE 13451
13449: GO 13477
13451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13452: NOP4
13456: PUSH
13457: LD_INT 2
13459: PUSH
13460: LD_INT 3
13462: PUSH
13463: LD_INT 4
13465: PUSH
13466: LD_INT 5
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: ST_TO_ADDR
13475: GO 14234
13477: LD_INT 13
13479: DOUBLE
13480: EQUAL
13481: IFTRUE 13485
13483: GO 13511
13485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13486: NOP4
13490: PUSH
13491: LD_INT 2
13493: PUSH
13494: LD_INT 3
13496: PUSH
13497: LD_INT 4
13499: PUSH
13500: LD_INT 5
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: LIST
13507: LIST
13508: ST_TO_ADDR
13509: GO 14234
13511: LD_INT 14
13513: DOUBLE
13514: EQUAL
13515: IFTRUE 13519
13517: GO 13537
13519: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13520: NOP4
13524: PUSH
13525: LD_INT 4
13527: PUSH
13528: LD_INT 5
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: ST_TO_ADDR
13535: GO 14234
13537: LD_INT 6
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13563
13545: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13546: NOP4
13550: PUSH
13551: LD_INT 4
13553: PUSH
13554: LD_INT 5
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: ST_TO_ADDR
13561: GO 14234
13563: LD_INT 10
13565: DOUBLE
13566: EQUAL
13567: IFTRUE 13571
13569: GO 13589
13571: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13572: NOP4
13576: PUSH
13577: LD_INT 4
13579: PUSH
13580: LD_INT 5
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: ST_TO_ADDR
13587: GO 14234
13589: LD_INT 22
13591: DOUBLE
13592: EQUAL
13593: IFTRUE 13597
13595: GO 13623
13597: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13598: NOP4
13602: PUSH
13603: LD_INT 11
13605: PUSH
13606: LD_INT 12
13608: PUSH
13609: LD_INT 13
13611: PUSH
13612: LD_INT 14
13614: PUSH
13615: EMPTY
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: ST_TO_ADDR
13621: GO 14234
13623: LD_INT 23
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13657
13631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13632: NOP4
13636: PUSH
13637: LD_INT 11
13639: PUSH
13640: LD_INT 12
13642: PUSH
13643: LD_INT 13
13645: PUSH
13646: LD_INT 14
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14234
13657: LD_INT 24
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13691
13665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13666: NOP4
13670: PUSH
13671: LD_INT 11
13673: PUSH
13674: LD_INT 12
13676: PUSH
13677: LD_INT 13
13679: PUSH
13680: LD_INT 14
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: ST_TO_ADDR
13689: GO 14234
13691: LD_INT 30
13693: DOUBLE
13694: EQUAL
13695: IFTRUE 13699
13697: GO 13725
13699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13700: NOP4
13704: PUSH
13705: LD_INT 11
13707: PUSH
13708: LD_INT 12
13710: PUSH
13711: LD_INT 13
13713: PUSH
13714: LD_INT 14
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: ST_TO_ADDR
13723: GO 14234
13725: LD_INT 25
13727: DOUBLE
13728: EQUAL
13729: IFTRUE 13733
13731: GO 13751
13733: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13734: NOP4
13738: PUSH
13739: LD_INT 13
13741: PUSH
13742: LD_INT 14
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: ST_TO_ADDR
13749: GO 14234
13751: LD_INT 27
13753: DOUBLE
13754: EQUAL
13755: IFTRUE 13759
13757: GO 13777
13759: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13760: NOP4
13764: PUSH
13765: LD_INT 13
13767: PUSH
13768: LD_INT 14
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: ST_TO_ADDR
13775: GO 14234
13777: NOP4
13781: DOUBLE
13782: EQUAL
13783: IFTRUE 13787
13785: GO 13813
13787: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13788: NOP4
13792: PUSH
13793: LD_INT 11
13795: PUSH
13796: LD_INT 12
13798: PUSH
13799: LD_INT 13
13801: PUSH
13802: LD_INT 14
13804: PUSH
13805: EMPTY
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: ST_TO_ADDR
13811: GO 14234
13813: LD_INT 28
13815: DOUBLE
13816: EQUAL
13817: IFTRUE 13821
13819: GO 13839
13821: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13822: NOP4
13826: PUSH
13827: LD_INT 13
13829: PUSH
13830: LD_INT 14
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: ST_TO_ADDR
13837: GO 14234
13839: LD_INT 29
13841: DOUBLE
13842: EQUAL
13843: IFTRUE 13847
13845: GO 13865
13847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13848: NOP4
13852: PUSH
13853: LD_INT 13
13855: PUSH
13856: LD_INT 14
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: ST_TO_ADDR
13863: GO 14234
13865: LD_INT 31
13867: DOUBLE
13868: EQUAL
13869: IFTRUE 13873
13871: GO 13891
13873: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13874: NOP4
13878: PUSH
13879: LD_INT 13
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: ST_TO_ADDR
13889: GO 14234
13891: LD_INT 26
13893: DOUBLE
13894: EQUAL
13895: IFTRUE 13899
13897: GO 13917
13899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13900: NOP4
13904: PUSH
13905: LD_INT 13
13907: PUSH
13908: LD_INT 14
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: ST_TO_ADDR
13915: GO 14234
13917: LD_INT 42
13919: DOUBLE
13920: EQUAL
13921: IFTRUE 13925
13923: GO 13951
13925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13926: NOP4
13930: PUSH
13931: LD_INT 21
13933: PUSH
13934: LD_INT 22
13936: PUSH
13937: LD_INT 23
13939: PUSH
13940: LD_INT 24
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: ST_TO_ADDR
13949: GO 14234
13951: LD_INT 43
13953: DOUBLE
13954: EQUAL
13955: IFTRUE 13959
13957: GO 13985
13959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13960: NOP4
13964: PUSH
13965: LD_INT 21
13967: PUSH
13968: LD_INT 22
13970: PUSH
13971: LD_INT 23
13973: PUSH
13974: LD_INT 24
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: ST_TO_ADDR
13983: GO 14234
13985: LD_INT 44
13987: DOUBLE
13988: EQUAL
13989: IFTRUE 13993
13991: GO 14019
13993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13994: NOP4
13998: PUSH
13999: LD_INT 21
14001: PUSH
14002: LD_INT 22
14004: PUSH
14005: LD_INT 23
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: ST_TO_ADDR
14017: GO 14234
14019: LD_INT 45
14021: DOUBLE
14022: EQUAL
14023: IFTRUE 14027
14025: GO 14053
14027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14028: NOP4
14032: PUSH
14033: LD_INT 21
14035: PUSH
14036: LD_INT 22
14038: PUSH
14039: LD_INT 23
14041: PUSH
14042: LD_INT 24
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: ST_TO_ADDR
14051: GO 14234
14053: LD_INT 49
14055: DOUBLE
14056: EQUAL
14057: IFTRUE 14061
14059: GO 14087
14061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14062: NOP4
14066: PUSH
14067: LD_INT 21
14069: PUSH
14070: LD_INT 22
14072: PUSH
14073: LD_INT 23
14075: PUSH
14076: LD_INT 24
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: ST_TO_ADDR
14085: GO 14234
14087: LD_INT 51
14089: DOUBLE
14090: EQUAL
14091: IFTRUE 14095
14093: GO 14121
14095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14096: NOP4
14100: PUSH
14101: LD_INT 21
14103: PUSH
14104: LD_INT 22
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 24
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: ST_TO_ADDR
14119: GO 14234
14121: LD_INT 52
14123: DOUBLE
14124: EQUAL
14125: IFTRUE 14129
14127: GO 14155
14129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14130: NOP4
14134: PUSH
14135: LD_INT 21
14137: PUSH
14138: LD_INT 22
14140: PUSH
14141: LD_INT 23
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14234
14155: LD_INT 53
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14181
14163: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14164: NOP4
14168: PUSH
14169: LD_INT 23
14171: PUSH
14172: LD_INT 24
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: ST_TO_ADDR
14179: GO 14234
14181: LD_INT 46
14183: DOUBLE
14184: EQUAL
14185: IFTRUE 14189
14187: GO 14207
14189: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14190: NOP4
14194: PUSH
14195: LD_INT 23
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: ST_TO_ADDR
14205: GO 14234
14207: LD_INT 47
14209: DOUBLE
14210: EQUAL
14211: IFTRUE 14215
14213: GO 14233
14215: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14216: NOP4
14220: PUSH
14221: LD_INT 23
14223: PUSH
14224: LD_INT 24
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14234
14233: POP
// result := ( chassis in result ) ;
14234: NOP4
14238: PUSH
14239: NOP4
14243: PUSH
14244: NOP4
14248: IN
14249: ST_TO_ADDR
// end ;
14250: LD_VAR 0 3
14254: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14255: LD_INT 0
14257: PPUSH
14258: PPUSH
14259: PPUSH
14260: PPUSH
14261: PPUSH
14262: PPUSH
14263: PPUSH
// result := array ;
14264: NOP4
14268: PUSH
14269: NOP4
14273: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14274: NOP4
14278: NOT
14279: PUSH
14280: NOP4
14284: NOT
14285: OR
14286: PUSH
14287: NOP4
14291: NOT
14292: OR
14293: PUSH
14294: NOP4
14298: PUSH
14299: NOP4
14303: GREATER
14304: OR
14305: PUSH
14306: NOP4
14310: PUSH
14311: NOP4
14315: GREATER
14316: OR
14317: IFFALSE 14321
// exit ;
14319: GO 14617
// if direction then
14321: NOP4
14325: IFFALSE 14389
// begin d := 1 ;
14327: NOP4
14331: PUSH
14332: LD_INT 1
14334: ST_TO_ADDR
// if i_from > i_to then
14335: NOP4
14339: PUSH
14340: NOP4
14344: GREATER
14345: IFFALSE 14371
// length := ( array - i_from ) + i_to else
14347: NOP4
14351: PUSH
14352: NOP4
14356: PUSH
14357: NOP4
14361: MINUS
14362: PUSH
14363: NOP4
14367: PLUS
14368: ST_TO_ADDR
14369: GO 14387
// length := i_to - i_from ;
14371: NOP4
14375: PUSH
14376: NOP4
14380: PUSH
14381: NOP4
14385: MINUS
14386: ST_TO_ADDR
// end else
14387: GO 14450
// begin d := - 1 ;
14389: NOP4
14393: PUSH
14394: LD_INT 1
14396: NEG
14397: ST_TO_ADDR
// if i_from > i_to then
14398: NOP4
14402: PUSH
14403: NOP4
14407: GREATER
14408: IFFALSE 14428
// length := i_from - i_to else
14410: NOP4
14414: PUSH
14415: NOP4
14419: PUSH
14420: NOP4
14424: MINUS
14425: ST_TO_ADDR
14426: GO 14450
// length := ( array - i_to ) + i_from ;
14428: NOP4
14432: PUSH
14433: NOP4
14437: PUSH
14438: NOP4
14442: MINUS
14443: PUSH
14444: NOP4
14448: PLUS
14449: ST_TO_ADDR
// end ; if not length then
14450: NOP4
14454: NOT
14455: IFFALSE 14459
// exit ;
14457: GO 14617
// tmp := array ;
14459: NOP4
14463: PUSH
14464: NOP4
14468: ST_TO_ADDR
// for i = 1 to length do
14469: NOP4
14473: PUSH
14474: DOUBLE
14475: LD_INT 1
14477: DEC
14478: ST_TO_ADDR
14479: NOP4
14483: PUSH
14484: FOR_TO
14485: IFFALSE 14605
// begin for j = 1 to array do
14487: NOP4
14491: PUSH
14492: DOUBLE
14493: LD_INT 1
14495: DEC
14496: ST_TO_ADDR
14497: NOP4
14501: PUSH
14502: FOR_TO
14503: IFFALSE 14591
// begin k := j + d ;
14505: NOP4
14509: PUSH
14510: NOP4
14514: PUSH
14515: NOP4
14519: PLUS
14520: ST_TO_ADDR
// if k > array then
14521: NOP4
14525: PUSH
14526: NOP4
14530: GREATER
14531: IFFALSE 14541
// k := 1 ;
14533: NOP4
14537: PUSH
14538: LD_INT 1
14540: ST_TO_ADDR
// if not k then
14541: NOP4
14545: NOT
14546: IFFALSE 14558
// k := array ;
14548: NOP4
14552: PUSH
14553: NOP4
14557: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14558: NOP4
14562: PUSH
14563: NOP4
14567: PPUSH
14568: NOP4
14572: PPUSH
14573: NOP4
14577: PUSH
14578: NOP4
14582: ARRAY
14583: PPUSH
14584: NOP4
14588: ST_TO_ADDR
// end ;
14589: GO 14502
14591: POP
14592: POP
// array := tmp ;
14593: NOP4
14597: PUSH
14598: NOP4
14602: ST_TO_ADDR
// end ;
14603: GO 14484
14605: POP
14606: POP
// result := array ;
14607: NOP4
14611: PUSH
14612: NOP4
14616: ST_TO_ADDR
// end ;
14617: LD_VAR 0 5
14621: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14622: LD_INT 0
14624: PPUSH
14625: PPUSH
// result := 0 ;
14626: NOP4
14630: PUSH
14631: LD_INT 0
14633: ST_TO_ADDR
// if not array or not value in array then
14634: NOP4
14638: NOT
14639: PUSH
14640: NOP4
14644: PUSH
14645: NOP4
14649: IN
14650: NOT
14651: OR
14652: IFFALSE 14656
// exit ;
14654: GO 14710
// for i = 1 to array do
14656: NOP4
14660: PUSH
14661: DOUBLE
14662: LD_INT 1
14664: DEC
14665: ST_TO_ADDR
14666: NOP4
14670: PUSH
14671: FOR_TO
14672: IFFALSE 14708
// if value = array [ i ] then
14674: NOP4
14678: PUSH
14679: NOP4
14683: PUSH
14684: NOP4
14688: ARRAY
14689: EQUAL
14690: IFFALSE 14706
// begin result := i ;
14692: NOP4
14696: PUSH
14697: NOP4
14701: ST_TO_ADDR
// exit ;
14702: POP
14703: POP
14704: GO 14710
// end ;
14706: GO 14671
14708: POP
14709: POP
// end ;
14710: LD_VAR 0 3
14714: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14715: LD_INT 0
14717: PPUSH
// vc_chassis := chassis ;
14718: LD_ADDR_OWVAR 37
14722: PUSH
14723: NOP4
14727: ST_TO_ADDR
// vc_engine := engine ;
14728: LD_ADDR_OWVAR 39
14732: PUSH
14733: NOP4
14737: ST_TO_ADDR
// vc_control := control ;
14738: LD_ADDR_OWVAR 38
14742: PUSH
14743: NOP4
14747: ST_TO_ADDR
// vc_weapon := weapon ;
14748: LD_ADDR_OWVAR 40
14752: PUSH
14753: NOP4
14757: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14758: LD_ADDR_OWVAR 41
14762: PUSH
14763: NOP4
14767: ST_TO_ADDR
// end ;
14768: LD_VAR 0 6
14772: RET
// export function WantPlant ( unit ) ; var task ; begin
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
// result := false ;
14777: NOP4
14781: PUSH
14782: LD_INT 0
14784: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14785: NOP4
14789: PUSH
14790: NOP4
14794: PPUSH
14795: NOP4
14799: ST_TO_ADDR
// if task then
14800: NOP4
14804: IFFALSE 14832
// if task [ 1 ] [ 1 ] = p then
14806: NOP4
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: PUSH
14815: LD_INT 1
14817: ARRAY
14818: PUSH
14819: LD_STRING p
14821: EQUAL
14822: IFFALSE 14832
// result := true ;
14824: NOP4
14828: PUSH
14829: LD_INT 1
14831: ST_TO_ADDR
// end ;
14832: LD_VAR 0 2
14836: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
14841: PPUSH
14842: PPUSH
// if pos < 1 then
14843: NOP4
14847: PUSH
14848: LD_INT 1
14850: LESS
14851: IFFALSE 14855
// exit ;
14853: GO 15158
// if pos = 1 then
14855: NOP4
14859: PUSH
14860: LD_INT 1
14862: EQUAL
14863: IFFALSE 14896
// result := Replace ( arr , pos [ 1 ] , value ) else
14865: NOP4
14869: PUSH
14870: NOP4
14874: PPUSH
14875: NOP4
14879: PUSH
14880: LD_INT 1
14882: ARRAY
14883: PPUSH
14884: NOP4
14888: PPUSH
14889: NOP4
14893: ST_TO_ADDR
14894: GO 15158
// begin tmp := arr ;
14896: NOP4
14900: PUSH
14901: NOP4
14905: ST_TO_ADDR
// s_arr := [ tmp ] ;
14906: NOP4
14910: PUSH
14911: NOP4
14915: PUSH
14916: EMPTY
14917: LIST
14918: ST_TO_ADDR
// for i = 1 to pos - 1 do
14919: NOP4
14923: PUSH
14924: DOUBLE
14925: LD_INT 1
14927: DEC
14928: ST_TO_ADDR
14929: NOP4
14933: PUSH
14934: LD_INT 1
14936: MINUS
14937: PUSH
14938: FOR_TO
14939: IFFALSE 14984
// begin tmp := tmp [ pos [ i ] ] ;
14941: NOP4
14945: PUSH
14946: NOP4
14950: PUSH
14951: NOP4
14955: PUSH
14956: NOP4
14960: ARRAY
14961: ARRAY
14962: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14963: NOP4
14967: PUSH
14968: NOP4
14972: PUSH
14973: NOP4
14977: PUSH
14978: EMPTY
14979: LIST
14980: ADD
14981: ST_TO_ADDR
// end ;
14982: GO 14938
14984: POP
14985: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14986: NOP4
14990: PUSH
14991: NOP4
14995: PPUSH
14996: NOP4
15000: PUSH
15001: NOP4
15005: ARRAY
15006: PPUSH
15007: NOP4
15011: PPUSH
15012: NOP4
15016: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15017: NOP4
15021: PUSH
15022: NOP4
15026: PPUSH
15027: NOP4
15031: PPUSH
15032: NOP4
15036: PPUSH
15037: NOP4
15041: ST_TO_ADDR
// for i = s_arr downto 2 do
15042: NOP4
15046: PUSH
15047: DOUBLE
15048: NOP4
15052: INC
15053: ST_TO_ADDR
15054: LD_INT 2
15056: PUSH
15057: FOR_DOWNTO
15058: IFFALSE 15142
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15060: NOP4
15064: PUSH
15065: NOP4
15069: PUSH
15070: NOP4
15074: PUSH
15075: LD_INT 1
15077: MINUS
15078: ARRAY
15079: PPUSH
15080: NOP4
15084: PUSH
15085: NOP4
15089: PUSH
15090: LD_INT 1
15092: MINUS
15093: ARRAY
15094: PPUSH
15095: NOP4
15099: PUSH
15100: NOP4
15104: ARRAY
15105: PPUSH
15106: NOP4
15110: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15111: NOP4
15115: PUSH
15116: NOP4
15120: PPUSH
15121: NOP4
15125: PUSH
15126: LD_INT 1
15128: MINUS
15129: PPUSH
15130: NOP4
15134: PPUSH
15135: NOP4
15139: ST_TO_ADDR
// end ;
15140: GO 15057
15142: POP
15143: POP
// result := s_arr [ 1 ] ;
15144: NOP4
15148: PUSH
15149: NOP4
15153: PUSH
15154: LD_INT 1
15156: ARRAY
15157: ST_TO_ADDR
// end ; end ;
15158: LD_VAR 0 4
15162: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15163: LD_INT 0
15165: PPUSH
15166: PPUSH
// if not list then
15167: NOP4
15171: NOT
15172: IFFALSE 15176
// exit ;
15174: GO 15267
// i := list [ pos1 ] ;
15176: NOP4
15180: PUSH
15181: NOP4
15185: PUSH
15186: NOP4
15190: ARRAY
15191: ST_TO_ADDR
// if not i then
15192: NOP4
15196: NOT
15197: IFFALSE 15201
// exit ;
15199: GO 15267
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15201: NOP4
15205: PUSH
15206: NOP4
15210: PPUSH
15211: NOP4
15215: PPUSH
15216: NOP4
15220: PUSH
15221: NOP4
15225: ARRAY
15226: PPUSH
15227: NOP4
15231: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15232: NOP4
15236: PUSH
15237: NOP4
15241: PPUSH
15242: NOP4
15246: PPUSH
15247: NOP4
15251: PPUSH
15252: NOP4
15256: ST_TO_ADDR
// result := list ;
15257: NOP4
15261: PUSH
15262: NOP4
15266: ST_TO_ADDR
// end ;
15267: LD_VAR 0 4
15271: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15272: LD_INT 0
15274: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15275: NOP4
15279: PUSH
15280: NOP4
15284: PPUSH
15285: NOP4
15289: PPUSH
15290: NOP4
15294: PPUSH
15295: NOP4
15299: PPUSH
15300: NOP4
15304: PPUSH
15305: NOP4
15309: PPUSH
15310: NOP4
15314: PPUSH
15315: NOP4
15319: ST_TO_ADDR
// end ;
15320: LD_VAR 0 5
15324: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15325: LD_INT 0
15327: PPUSH
15328: PPUSH
15329: PPUSH
15330: PPUSH
// if not list then
15331: NOP4
15335: NOT
15336: IFFALSE 15340
// exit ;
15338: GO 15728
// result := [ ] ;
15340: NOP4
15344: PUSH
15345: EMPTY
15346: ST_TO_ADDR
// for i in list do
15347: NOP4
15351: PUSH
15352: NOP4
15356: PUSH
15357: FOR_IN
15358: IFFALSE 15560
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15360: NOP4
15364: PUSH
15365: NOP4
15369: PPUSH
15370: NOP4
15374: PPUSH
15375: NOP4
15379: PPUSH
15380: NOP4
15384: ST_TO_ADDR
// if not result then
15385: NOP4
15389: NOT
15390: IFFALSE 15416
// result := [ [ i , tmp ] ] else
15392: NOP4
15396: PUSH
15397: NOP4
15401: PUSH
15402: NOP4
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: EMPTY
15412: LIST
15413: ST_TO_ADDR
15414: GO 15558
// begin if result [ result ] [ 2 ] < tmp then
15416: NOP4
15420: PUSH
15421: NOP4
15425: ARRAY
15426: PUSH
15427: LD_INT 2
15429: ARRAY
15430: PUSH
15431: NOP4
15435: LESS
15436: IFFALSE 15478
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15438: NOP4
15442: PUSH
15443: NOP4
15447: PPUSH
15448: NOP4
15452: PUSH
15453: LD_INT 1
15455: PLUS
15456: PPUSH
15457: NOP4
15461: PUSH
15462: NOP4
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: PPUSH
15471: NOP4
15475: ST_TO_ADDR
15476: GO 15558
// for j = 1 to result do
15478: NOP4
15482: PUSH
15483: DOUBLE
15484: LD_INT 1
15486: DEC
15487: ST_TO_ADDR
15488: NOP4
15492: PUSH
15493: FOR_TO
15494: IFFALSE 15556
// begin if tmp < result [ j ] [ 2 ] then
15496: NOP4
15500: PUSH
15501: NOP4
15505: PUSH
15506: NOP4
15510: ARRAY
15511: PUSH
15512: LD_INT 2
15514: ARRAY
15515: LESS
15516: IFFALSE 15554
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15518: NOP4
15522: PUSH
15523: NOP4
15527: PPUSH
15528: NOP4
15532: PPUSH
15533: NOP4
15537: PUSH
15538: NOP4
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: NOP4
15551: ST_TO_ADDR
// break ;
15552: GO 15556
// end ; end ;
15554: GO 15493
15556: POP
15557: POP
// end ; end ;
15558: GO 15357
15560: POP
15561: POP
// if result and not asc then
15562: NOP4
15566: PUSH
15567: NOP4
15571: NOT
15572: AND
15573: IFFALSE 15648
// begin tmp := result ;
15575: NOP4
15579: PUSH
15580: NOP4
15584: ST_TO_ADDR
// for i = tmp downto 1 do
15585: NOP4
15589: PUSH
15590: DOUBLE
15591: NOP4
15595: INC
15596: ST_TO_ADDR
15597: LD_INT 1
15599: PUSH
15600: FOR_DOWNTO
15601: IFFALSE 15646
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15603: NOP4
15607: PUSH
15608: NOP4
15612: PPUSH
15613: NOP4
15617: PUSH
15618: NOP4
15622: MINUS
15623: PUSH
15624: LD_INT 1
15626: PLUS
15627: PPUSH
15628: NOP4
15632: PUSH
15633: NOP4
15637: ARRAY
15638: PPUSH
15639: NOP4
15643: ST_TO_ADDR
15644: GO 15600
15646: POP
15647: POP
// end ; tmp := [ ] ;
15648: NOP4
15652: PUSH
15653: EMPTY
15654: ST_TO_ADDR
// if mode then
15655: NOP4
15659: IFFALSE 15728
// begin for i = 1 to result do
15661: NOP4
15665: PUSH
15666: DOUBLE
15667: LD_INT 1
15669: DEC
15670: ST_TO_ADDR
15671: NOP4
15675: PUSH
15676: FOR_TO
15677: IFFALSE 15716
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15679: NOP4
15683: PUSH
15684: NOP4
15688: PPUSH
15689: NOP4
15693: PPUSH
15694: NOP4
15698: PUSH
15699: NOP4
15703: ARRAY
15704: PUSH
15705: LD_INT 1
15707: ARRAY
15708: PPUSH
15709: NOP4
15713: ST_TO_ADDR
15714: GO 15676
15716: POP
15717: POP
// result := tmp ;
15718: NOP4
15722: PUSH
15723: NOP4
15727: ST_TO_ADDR
// end ; end ;
15728: LD_VAR 0 6
15732: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15733: LD_INT 0
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
15739: PPUSH
15740: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15741: NOP4
15745: PUSH
15746: LD_INT 0
15748: PUSH
15749: LD_INT 0
15751: PUSH
15752: LD_INT 0
15754: PUSH
15755: EMPTY
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: ST_TO_ADDR
// if not x or not y then
15763: NOP4
15767: NOT
15768: PUSH
15769: NOP4
15773: NOT
15774: OR
15775: IFFALSE 15779
// exit ;
15777: GO 17431
// if not range then
15779: NOP4
15783: NOT
15784: IFFALSE 15794
// range := 10 ;
15786: NOP4
15790: PUSH
15791: LD_INT 10
15793: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15794: NOP4
15798: PUSH
15799: LD_INT 81
15801: PUSH
15802: NOP4
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 92
15813: PUSH
15814: NOP4
15818: PUSH
15819: NOP4
15823: PUSH
15824: NOP4
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 3
15837: PUSH
15838: LD_INT 21
15840: PUSH
15841: LD_INT 3
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: LIST
15856: PPUSH
15857: NOP4
15861: ST_TO_ADDR
// if not tmp then
15862: NOP4
15866: NOT
15867: IFFALSE 15871
// exit ;
15869: GO 17431
// for i in tmp do
15871: NOP4
15875: PUSH
15876: NOP4
15880: PUSH
15881: FOR_IN
15882: IFFALSE 17406
// begin points := [ 0 , 0 , 0 ] ;
15884: NOP4
15888: PUSH
15889: LD_INT 0
15891: PUSH
15892: LD_INT 0
15894: PUSH
15895: LD_INT 0
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: ST_TO_ADDR
// bpoints := 1 ;
15903: NOP4
15907: PUSH
15908: LD_INT 1
15910: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15911: NOP4
15915: PPUSH
15916: NOP4
15920: PUSH
15921: LD_INT 1
15923: DOUBLE
15924: EQUAL
15925: IFTRUE 15929
15927: GO 16507
15929: POP
// begin if GetClass ( i ) = 1 then
15930: NOP4
15934: PPUSH
15935: NOP4
15939: PUSH
15940: LD_INT 1
15942: EQUAL
15943: IFFALSE 15964
// points := [ 10 , 5 , 3 ] ;
15945: NOP4
15949: PUSH
15950: LD_INT 10
15952: PUSH
15953: LD_INT 5
15955: PUSH
15956: LD_INT 3
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: LIST
15963: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15964: NOP4
15968: PPUSH
15969: NOP4
15973: PUSH
15974: LD_INT 2
15976: PUSH
15977: LD_INT 3
15979: PUSH
15980: LD_INT 4
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: LIST
15987: IN
15988: IFFALSE 16009
// points := [ 3 , 2 , 1 ] ;
15990: NOP4
15994: PUSH
15995: LD_INT 3
15997: PUSH
15998: LD_INT 2
16000: PUSH
16001: LD_INT 1
16003: PUSH
16004: EMPTY
16005: LIST
16006: LIST
16007: LIST
16008: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16009: NOP4
16013: PPUSH
16014: NOP4
16018: PUSH
16019: LD_INT 5
16021: EQUAL
16022: IFFALSE 16043
// points := [ 130 , 5 , 2 ] ;
16024: NOP4
16028: PUSH
16029: LD_INT 130
16031: PUSH
16032: LD_INT 5
16034: PUSH
16035: LD_INT 2
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16043: NOP4
16047: PPUSH
16048: NOP4
16052: PUSH
16053: LD_INT 8
16055: EQUAL
16056: IFFALSE 16077
// points := [ 35 , 35 , 30 ] ;
16058: NOP4
16062: PUSH
16063: LD_INT 35
16065: PUSH
16066: LD_INT 35
16068: PUSH
16069: LD_INT 30
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: LIST
16076: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16077: NOP4
16081: PPUSH
16082: NOP4
16086: PUSH
16087: LD_INT 9
16089: EQUAL
16090: IFFALSE 16111
// points := [ 20 , 55 , 40 ] ;
16092: NOP4
16096: PUSH
16097: LD_INT 20
16099: PUSH
16100: LD_INT 55
16102: PUSH
16103: LD_INT 40
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: LIST
16110: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16111: NOP4
16115: PPUSH
16116: NOP4
16120: PUSH
16121: LD_INT 12
16123: PUSH
16124: LD_INT 16
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: IN
16131: IFFALSE 16152
// points := [ 5 , 3 , 2 ] ;
16133: NOP4
16137: PUSH
16138: LD_INT 5
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: LIST
16151: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16152: NOP4
16156: PPUSH
16157: NOP4
16161: PUSH
16162: LD_INT 17
16164: EQUAL
16165: IFFALSE 16186
// points := [ 100 , 50 , 75 ] ;
16167: NOP4
16171: PUSH
16172: LD_INT 100
16174: PUSH
16175: LD_INT 50
16177: PUSH
16178: LD_INT 75
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: LIST
16185: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16186: NOP4
16190: PPUSH
16191: NOP4
16195: PUSH
16196: LD_INT 15
16198: EQUAL
16199: IFFALSE 16220
// points := [ 10 , 5 , 3 ] ;
16201: NOP4
16205: PUSH
16206: LD_INT 10
16208: PUSH
16209: LD_INT 5
16211: PUSH
16212: LD_INT 3
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: LIST
16219: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16220: NOP4
16224: PPUSH
16225: NOP4
16229: PUSH
16230: LD_INT 14
16232: EQUAL
16233: IFFALSE 16254
// points := [ 10 , 0 , 0 ] ;
16235: NOP4
16239: PUSH
16240: LD_INT 10
16242: PUSH
16243: LD_INT 0
16245: PUSH
16246: LD_INT 0
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: LIST
16253: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16254: NOP4
16258: PPUSH
16259: NOP4
16263: PUSH
16264: LD_INT 11
16266: EQUAL
16267: IFFALSE 16288
// points := [ 30 , 10 , 5 ] ;
16269: NOP4
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 10
16279: PUSH
16280: LD_INT 5
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: LIST
16287: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16288: NOP4
16292: PPUSH
16293: LD_INT 5
16295: PPUSH
16296: NOP4
16300: PUSH
16301: LD_INT 2
16303: EQUAL
16304: IFFALSE 16321
// bpoints := bpoints * 1.8 ;
16306: NOP4
16310: PUSH
16311: NOP4
16315: PUSH
16316: LD_REAL  1.80000000000000E+0000
16319: MUL
16320: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16321: NOP4
16325: PPUSH
16326: NOP4
16330: PUSH
16331: LD_INT 1
16333: PUSH
16334: LD_INT 2
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: LIST
16348: IN
16349: PUSH
16350: NOP4
16354: PPUSH
16355: LD_INT 51
16357: PPUSH
16358: NOP4
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: IFFALSE 16384
// bpoints := bpoints * 1.2 ;
16369: NOP4
16373: PUSH
16374: NOP4
16378: PUSH
16379: LD_REAL  1.20000000000000E+0000
16382: MUL
16383: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16384: NOP4
16388: PPUSH
16389: NOP4
16393: PUSH
16394: LD_INT 5
16396: PUSH
16397: LD_INT 7
16399: PUSH
16400: LD_INT 9
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: LIST
16407: IN
16408: PUSH
16409: NOP4
16413: PPUSH
16414: LD_INT 52
16416: PPUSH
16417: NOP4
16421: PUSH
16422: LD_INT 2
16424: EQUAL
16425: AND
16426: IFFALSE 16443
// bpoints := bpoints * 1.5 ;
16428: NOP4
16432: PUSH
16433: NOP4
16437: PUSH
16438: LD_REAL  1.50000000000000E+0000
16441: MUL
16442: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16443: NOP4
16447: PPUSH
16448: LD_INT 66
16450: PPUSH
16451: NOP4
16455: PUSH
16456: LD_INT 2
16458: EQUAL
16459: IFFALSE 16476
// bpoints := bpoints * 1.1 ;
16461: NOP4
16465: PUSH
16466: NOP4
16470: PUSH
16471: LD_REAL  1.10000000000000E+0000
16474: MUL
16475: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16476: NOP4
16480: PUSH
16481: NOP4
16485: PUSH
16486: NOP4
16490: PPUSH
16491: LD_INT 1
16493: PPUSH
16494: NOP4
16498: PUSH
16499: LD_REAL  1.15000000000000E+0000
16502: MUL
16503: MUL
16504: ST_TO_ADDR
// end ; unit_vehicle :
16505: GO 17335
16507: LD_INT 2
16509: DOUBLE
16510: EQUAL
16511: IFTRUE 16515
16513: GO 17323
16515: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16516: NOP4
16520: PPUSH
16521: NOP4
16525: PUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 42
16531: PUSH
16532: LD_INT 24
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: LIST
16539: IN
16540: IFFALSE 16561
// points := [ 25 , 5 , 3 ] ;
16542: NOP4
16546: PUSH
16547: LD_INT 25
16549: PUSH
16550: LD_INT 5
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16561: NOP4
16565: PPUSH
16566: NOP4
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: LD_INT 43
16576: PUSH
16577: LD_INT 25
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: LIST
16584: IN
16585: IFFALSE 16606
// points := [ 40 , 15 , 5 ] ;
16587: NOP4
16591: PUSH
16592: LD_INT 40
16594: PUSH
16595: LD_INT 15
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: LIST
16605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16606: NOP4
16610: PPUSH
16611: NOP4
16615: PUSH
16616: LD_INT 3
16618: PUSH
16619: LD_INT 23
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: IN
16626: IFFALSE 16647
// points := [ 7 , 25 , 8 ] ;
16628: NOP4
16632: PUSH
16633: LD_INT 7
16635: PUSH
16636: LD_INT 25
16638: PUSH
16639: LD_INT 8
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: LIST
16646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16647: NOP4
16651: PPUSH
16652: NOP4
16656: PUSH
16657: LD_INT 5
16659: PUSH
16660: LD_INT 27
16662: PUSH
16663: LD_INT 44
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: IN
16671: IFFALSE 16692
// points := [ 14 , 50 , 16 ] ;
16673: NOP4
16677: PUSH
16678: LD_INT 14
16680: PUSH
16681: LD_INT 50
16683: PUSH
16684: LD_INT 16
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: LIST
16691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16692: NOP4
16696: PPUSH
16697: NOP4
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: LD_INT 46
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: IN
16712: IFFALSE 16733
// points := [ 32 , 120 , 70 ] ;
16714: NOP4
16718: PUSH
16719: LD_INT 32
16721: PUSH
16722: LD_INT 120
16724: PUSH
16725: LD_INT 70
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: LIST
16732: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16733: NOP4
16737: PPUSH
16738: NOP4
16742: PUSH
16743: LD_INT 7
16745: PUSH
16746: LD_INT 28
16748: PUSH
16749: LD_INT 45
16751: PUSH
16752: NOP4
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: IN
16763: IFFALSE 16784
// points := [ 35 , 20 , 45 ] ;
16765: NOP4
16769: PUSH
16770: LD_INT 35
16772: PUSH
16773: LD_INT 20
16775: PUSH
16776: LD_INT 45
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: LIST
16783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16784: NOP4
16788: PPUSH
16789: NOP4
16793: PUSH
16794: LD_INT 47
16796: PUSH
16797: EMPTY
16798: LIST
16799: IN
16800: IFFALSE 16821
// points := [ 67 , 45 , 75 ] ;
16802: NOP4
16806: PUSH
16807: LD_INT 67
16809: PUSH
16810: LD_INT 45
16812: PUSH
16813: LD_INT 75
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: LIST
16820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16821: NOP4
16825: PPUSH
16826: NOP4
16830: PUSH
16831: LD_INT 26
16833: PUSH
16834: EMPTY
16835: LIST
16836: IN
16837: IFFALSE 16858
// points := [ 120 , 30 , 80 ] ;
16839: NOP4
16843: PUSH
16844: LD_INT 120
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 80
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16858: NOP4
16862: PPUSH
16863: NOP4
16867: PUSH
16868: LD_INT 22
16870: PUSH
16871: EMPTY
16872: LIST
16873: IN
16874: IFFALSE 16895
// points := [ 40 , 1 , 1 ] ;
16876: NOP4
16880: PUSH
16881: LD_INT 40
16883: PUSH
16884: LD_INT 1
16886: PUSH
16887: LD_INT 1
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16895: NOP4
16899: PPUSH
16900: NOP4
16904: PUSH
16905: LD_INT 29
16907: PUSH
16908: EMPTY
16909: LIST
16910: IN
16911: IFFALSE 16932
// points := [ 70 , 200 , 400 ] ;
16913: NOP4
16917: PUSH
16918: LD_INT 70
16920: PUSH
16921: LD_INT 200
16923: PUSH
16924: LD_INT 400
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: LIST
16931: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16932: NOP4
16936: PPUSH
16937: NOP4
16941: PUSH
16942: LD_INT 14
16944: PUSH
16945: LD_INT 53
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: IN
16952: IFFALSE 16973
// points := [ 40 , 10 , 20 ] ;
16954: NOP4
16958: PUSH
16959: LD_INT 40
16961: PUSH
16962: LD_INT 10
16964: PUSH
16965: LD_INT 20
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16973: NOP4
16977: PPUSH
16978: NOP4
16982: PUSH
16983: LD_INT 9
16985: PUSH
16986: EMPTY
16987: LIST
16988: IN
16989: IFFALSE 17010
// points := [ 5 , 70 , 20 ] ;
16991: NOP4
16995: PUSH
16996: LD_INT 5
16998: PUSH
16999: LD_INT 70
17001: PUSH
17002: LD_INT 20
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17010: NOP4
17014: PPUSH
17015: NOP4
17019: PUSH
17020: LD_INT 10
17022: PUSH
17023: EMPTY
17024: LIST
17025: IN
17026: IFFALSE 17047
// points := [ 35 , 110 , 70 ] ;
17028: NOP4
17032: PUSH
17033: LD_INT 35
17035: PUSH
17036: LD_INT 110
17038: PUSH
17039: LD_INT 70
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17047: NOP4
17051: PPUSH
17052: NOP4
17056: PUSH
17057: LD_INT 25
17059: EQUAL
17060: IFFALSE 17081
// points := [ 80 , 65 , 100 ] ;
17062: NOP4
17066: PUSH
17067: LD_INT 80
17069: PUSH
17070: LD_INT 65
17072: PUSH
17073: LD_INT 100
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17081: NOP4
17085: PPUSH
17086: NOP4
17090: PUSH
17091: LD_INT 1
17093: EQUAL
17094: IFFALSE 17129
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17096: NOP4
17100: PUSH
17101: NOP4
17105: PUSH
17106: NOP4
17110: PPUSH
17111: NOP4
17115: PPUSH
17116: LD_INT 3
17118: PPUSH
17119: NOP4
17123: PUSH
17124: LD_INT 4
17126: MUL
17127: MUL
17128: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17129: NOP4
17133: PPUSH
17134: NOP4
17138: PUSH
17139: LD_INT 2
17141: EQUAL
17142: IFFALSE 17193
// begin j := IsControledBy ( i ) ;
17144: NOP4
17148: PUSH
17149: NOP4
17153: PPUSH
17154: NOP4
17158: ST_TO_ADDR
// if j then
17159: NOP4
17163: IFFALSE 17193
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17165: NOP4
17169: PUSH
17170: NOP4
17174: PUSH
17175: NOP4
17179: PPUSH
17180: LD_INT 3
17182: PPUSH
17183: NOP4
17187: PUSH
17188: LD_INT 3
17190: MUL
17191: MUL
17192: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17193: NOP4
17197: PPUSH
17198: NOP4
17202: PUSH
17203: LD_INT 5
17205: PUSH
17206: LD_INT 6
17208: PUSH
17209: LD_INT 46
17211: PUSH
17212: LD_INT 44
17214: PUSH
17215: LD_INT 47
17217: PUSH
17218: LD_INT 45
17220: PUSH
17221: LD_INT 28
17223: PUSH
17224: LD_INT 7
17226: PUSH
17227: LD_INT 27
17229: PUSH
17230: LD_INT 29
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: LIST
17239: LIST
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: IN
17245: PUSH
17246: NOP4
17250: PPUSH
17251: LD_INT 52
17253: PPUSH
17254: NOP4
17258: PUSH
17259: LD_INT 2
17261: EQUAL
17262: AND
17263: IFFALSE 17280
// bpoints := bpoints * 1.2 ;
17265: NOP4
17269: PUSH
17270: NOP4
17274: PUSH
17275: LD_REAL  1.20000000000000E+0000
17278: MUL
17279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17280: NOP4
17284: PPUSH
17285: NOP4
17289: PUSH
17290: LD_INT 6
17292: PUSH
17293: LD_INT 46
17295: PUSH
17296: LD_INT 47
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: IN
17304: IFFALSE 17321
// bpoints := bpoints * 1.2 ;
17306: NOP4
17310: PUSH
17311: NOP4
17315: PUSH
17316: LD_REAL  1.20000000000000E+0000
17319: MUL
17320: ST_TO_ADDR
// end ; unit_building :
17321: GO 17335
17323: LD_INT 3
17325: DOUBLE
17326: EQUAL
17327: IFTRUE 17331
17329: GO 17334
17331: POP
// ; end ;
17332: GO 17335
17334: POP
// for j = 1 to 3 do
17335: NOP4
17339: PUSH
17340: DOUBLE
17341: LD_INT 1
17343: DEC
17344: ST_TO_ADDR
17345: LD_INT 3
17347: PUSH
17348: FOR_TO
17349: IFFALSE 17402
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17351: NOP4
17355: PUSH
17356: NOP4
17360: PPUSH
17361: NOP4
17365: PPUSH
17366: NOP4
17370: PUSH
17371: NOP4
17375: ARRAY
17376: PUSH
17377: NOP4
17381: PUSH
17382: NOP4
17386: ARRAY
17387: PUSH
17388: NOP4
17392: MUL
17393: PLUS
17394: PPUSH
17395: NOP4
17399: ST_TO_ADDR
17400: GO 17348
17402: POP
17403: POP
// end ;
17404: GO 15881
17406: POP
17407: POP
// result := Replace ( result , 4 , tmp ) ;
17408: NOP4
17412: PUSH
17413: NOP4
17417: PPUSH
17418: LD_INT 4
17420: PPUSH
17421: NOP4
17425: PPUSH
17426: NOP4
17430: ST_TO_ADDR
// end ;
17431: LD_VAR 0 5
17435: RET
// export function DangerAtRange ( unit , range ) ; begin
17436: LD_INT 0
17438: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17439: NOP4
17443: PUSH
17444: NOP4
17448: PPUSH
17449: NOP4
17453: PPUSH
17454: NOP4
17458: PPUSH
17459: NOP4
17463: PPUSH
17464: NOP4
17468: PPUSH
17469: NOP4
17473: PPUSH
17474: NOP4
17478: PPUSH
17479: NOP4
17483: ST_TO_ADDR
// end ;
17484: LD_VAR 0 3
17488: RET
// export function DangerInArea ( side , area ) ; begin
17489: LD_INT 0
17491: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17492: NOP4
17496: PUSH
17497: NOP4
17501: PPUSH
17502: LD_INT 81
17504: PUSH
17505: NOP4
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PPUSH
17514: NOP4
17518: ST_TO_ADDR
// end ;
17519: LD_VAR 0 3
17523: RET
// export function IsExtension ( b ) ; begin
17524: LD_INT 0
17526: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17527: NOP4
17531: PUSH
17532: NOP4
17536: PUSH
17537: LD_INT 23
17539: PUSH
17540: LD_INT 20
17542: PUSH
17543: LD_INT 22
17545: PUSH
17546: LD_INT 17
17548: PUSH
17549: LD_INT 24
17551: PUSH
17552: LD_INT 21
17554: PUSH
17555: LD_INT 19
17557: PUSH
17558: LD_INT 16
17560: PUSH
17561: LD_INT 25
17563: PUSH
17564: LD_INT 18
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: IN
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 2
17584: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
// result := [ ] ;
17590: NOP4
17594: PUSH
17595: EMPTY
17596: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17597: NOP4
17601: PUSH
17602: NOP4
17606: PPUSH
17607: LD_INT 21
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PPUSH
17617: NOP4
17621: ST_TO_ADDR
// if not tmp then
17622: NOP4
17626: NOT
17627: IFFALSE 17631
// exit ;
17629: GO 17695
// if checkLink then
17631: NOP4
17635: IFFALSE 17685
// begin for i in tmp do
17637: NOP4
17641: PUSH
17642: NOP4
17646: PUSH
17647: FOR_IN
17648: IFFALSE 17683
// if GetBase ( i ) <> base then
17650: NOP4
17654: PPUSH
17655: NOP4
17659: PUSH
17660: NOP4
17664: NONEQUAL
17665: IFFALSE 17681
// ComLinkToBase ( base , i ) ;
17667: NOP4
17671: PPUSH
17672: NOP4
17676: PPUSH
17677: NOP4
17681: GO 17647
17683: POP
17684: POP
// end ; result := tmp ;
17685: NOP4
17689: PUSH
17690: NOP4
17694: ST_TO_ADDR
// end ;
17695: LD_VAR 0 4
17699: RET
// export function ComComplete ( units , b ) ; var i ; begin
17700: LD_INT 0
17702: PPUSH
17703: PPUSH
// if not units then
17704: NOP4
17708: NOT
17709: IFFALSE 17713
// exit ;
17711: GO 17803
// for i in units do
17713: NOP4
17717: PUSH
17718: NOP4
17722: PUSH
17723: FOR_IN
17724: IFFALSE 17801
// if BuildingStatus ( b ) = bs_build then
17726: NOP4
17730: PPUSH
17731: NOP4
17735: PUSH
17736: LD_INT 1
17738: EQUAL
17739: IFFALSE 17799
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17741: NOP4
17745: PPUSH
17746: LD_STRING h
17748: PUSH
17749: NOP4
17753: PPUSH
17754: NOP4
17758: PUSH
17759: NOP4
17763: PPUSH
17764: NOP4
17768: PUSH
17769: NOP4
17773: PUSH
17774: LD_INT 0
17776: PUSH
17777: LD_INT 0
17779: PUSH
17780: LD_INT 0
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: PUSH
17792: EMPTY
17793: LIST
17794: PPUSH
17795: NOP4
17799: GO 17723
17801: POP
17802: POP
// end ;
17803: LD_VAR 0 3
17807: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17808: LD_INT 0
17810: PPUSH
17811: PPUSH
17812: PPUSH
17813: PPUSH
17814: PPUSH
17815: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17816: NOP4
17820: NOT
17821: PUSH
17822: NOP4
17826: PPUSH
17827: NOP4
17831: PUSH
17832: LD_INT 2
17834: NONEQUAL
17835: OR
17836: IFFALSE 17840
// exit ;
17838: GO 18156
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17840: NOP4
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: NOP4
17852: PPUSH
17853: NOP4
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PUSH
17862: LD_INT 2
17864: PUSH
17865: LD_INT 30
17867: PUSH
17868: LD_INT 36
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 34
17877: PUSH
17878: LD_INT 31
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: PPUSH
17894: NOP4
17898: ST_TO_ADDR
// if not tmp then
17899: NOP4
17903: NOT
17904: IFFALSE 17908
// exit ;
17906: GO 18156
// result := [ ] ;
17908: NOP4
17912: PUSH
17913: EMPTY
17914: ST_TO_ADDR
// for i in tmp do
17915: NOP4
17919: PUSH
17920: NOP4
17924: PUSH
17925: FOR_IN
17926: IFFALSE 17997
// begin t := UnitsInside ( i ) ;
17928: NOP4
17932: PUSH
17933: NOP4
17937: PPUSH
17938: NOP4
17942: ST_TO_ADDR
// if t then
17943: NOP4
17947: IFFALSE 17995
// for j in t do
17949: NOP4
17953: PUSH
17954: NOP4
17958: PUSH
17959: FOR_IN
17960: IFFALSE 17993
// result := Replace ( result , result + 1 , j ) ;
17962: NOP4
17966: PUSH
17967: NOP4
17971: PPUSH
17972: NOP4
17976: PUSH
17977: LD_INT 1
17979: PLUS
17980: PPUSH
17981: NOP4
17985: PPUSH
17986: NOP4
17990: ST_TO_ADDR
17991: GO 17959
17993: POP
17994: POP
// end ;
17995: GO 17925
17997: POP
17998: POP
// if not result then
17999: NOP4
18003: NOT
18004: IFFALSE 18008
// exit ;
18006: GO 18156
// mech := result [ 1 ] ;
18008: NOP4
18012: PUSH
18013: NOP4
18017: PUSH
18018: LD_INT 1
18020: ARRAY
18021: ST_TO_ADDR
// if result > 1 then
18022: NOP4
18026: PUSH
18027: LD_INT 1
18029: GREATER
18030: IFFALSE 18142
// begin for i = 2 to result do
18032: NOP4
18036: PUSH
18037: DOUBLE
18038: LD_INT 2
18040: DEC
18041: ST_TO_ADDR
18042: NOP4
18046: PUSH
18047: FOR_TO
18048: IFFALSE 18140
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18050: NOP4
18054: PUSH
18055: NOP4
18059: PUSH
18060: NOP4
18064: ARRAY
18065: PPUSH
18066: LD_INT 3
18068: PPUSH
18069: NOP4
18073: PUSH
18074: NOP4
18078: PUSH
18079: NOP4
18083: ARRAY
18084: PPUSH
18085: NOP4
18089: MINUS
18090: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18091: NOP4
18095: PUSH
18096: NOP4
18100: PPUSH
18101: LD_INT 3
18103: PPUSH
18104: NOP4
18108: PUSH
18109: NOP4
18113: PPUSH
18114: NOP4
18118: MINUS
18119: GREATEREQUAL
18120: IFFALSE 18138
// mech := result [ i ] ;
18122: NOP4
18126: PUSH
18127: NOP4
18131: PUSH
18132: NOP4
18136: ARRAY
18137: ST_TO_ADDR
// end ;
18138: GO 18047
18140: POP
18141: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18142: NOP4
18146: PPUSH
18147: NOP4
18151: PPUSH
18152: NOP4
// end ;
18156: LD_VAR 0 2
18160: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18161: LD_INT 0
18163: PPUSH
18164: PPUSH
18165: PPUSH
18166: PPUSH
18167: PPUSH
18168: PPUSH
18169: PPUSH
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
// result := [ ] ;
18176: NOP4
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18183: NOP4
18187: PPUSH
18188: NOP4
18192: PUSH
18193: LD_INT 0
18195: PUSH
18196: LD_INT 1
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: IN
18203: NOT
18204: IFFALSE 18208
// exit ;
18206: GO 19842
// if name then
18208: NOP4
18212: IFFALSE 18228
// SetBName ( base_dep , name ) ;
18214: NOP4
18218: PPUSH
18219: NOP4
18223: PPUSH
18224: NOP4
// base := GetBase ( base_dep ) ;
18228: NOP4
18232: PUSH
18233: NOP4
18237: PPUSH
18238: NOP4
18242: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18243: NOP4
18247: PUSH
18248: NOP4
18252: PPUSH
18253: NOP4
18257: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18258: NOP4
18262: PUSH
18263: NOP4
18267: PPUSH
18268: NOP4
18272: ST_TO_ADDR
// if sources then
18273: NOP4
18277: IFFALSE 18324
// for i = 1 to 3 do
18279: NOP4
18283: PUSH
18284: DOUBLE
18285: LD_INT 1
18287: DEC
18288: ST_TO_ADDR
18289: LD_INT 3
18291: PUSH
18292: FOR_TO
18293: IFFALSE 18322
// AddResourceType ( base , i , sources [ i ] ) ;
18295: NOP4
18299: PPUSH
18300: NOP4
18304: PPUSH
18305: NOP4
18309: PUSH
18310: NOP4
18314: ARRAY
18315: PPUSH
18316: NOP4
18320: GO 18292
18322: POP
18323: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18324: NOP4
18328: PUSH
18329: NOP4
18333: PPUSH
18334: NOP4
18338: PPUSH
18339: LD_INT 1
18341: PPUSH
18342: NOP4
18346: ST_TO_ADDR
// InitHc ;
18347: NOP4
// InitUc ;
18351: NOP4
// uc_side := side ;
18355: LD_ADDR_OWVAR 20
18359: PUSH
18360: NOP4
18364: ST_TO_ADDR
// uc_nation := nation ;
18365: LD_ADDR_OWVAR 21
18369: PUSH
18370: NOP4
18374: ST_TO_ADDR
// if buildings then
18375: NOP4
18379: IFFALSE 19701
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18381: NOP4
18385: PUSH
18386: NOP4
18390: PPUSH
18391: LD_INT 2
18393: PUSH
18394: LD_INT 30
18396: PUSH
18397: LD_INT 29
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 30
18406: PUSH
18407: LD_INT 30
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: LIST
18418: PPUSH
18419: NOP4
18423: ST_TO_ADDR
// if tmp then
18424: NOP4
18428: IFFALSE 18476
// for i in tmp do
18430: NOP4
18434: PUSH
18435: NOP4
18439: PUSH
18440: FOR_IN
18441: IFFALSE 18474
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18443: NOP4
18447: PPUSH
18448: NOP4
18452: PPUSH
18453: NOP4
18457: PPUSH
18458: NOP4
18462: PPUSH
18463: NOP4
18467: PPUSH
18468: NOP4
18472: GO 18440
18474: POP
18475: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18476: NOP4
18480: PPUSH
18481: LD_INT 2
18483: PUSH
18484: LD_INT 30
18486: PUSH
18487: LD_INT 32
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: LD_INT 30
18496: PUSH
18497: LD_INT 33
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: PPUSH
18509: NOP4
18513: IFFALSE 18601
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18515: NOP4
18519: PUSH
18520: NOP4
18524: PPUSH
18525: LD_INT 2
18527: PUSH
18528: LD_INT 30
18530: PUSH
18531: LD_INT 32
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PUSH
18538: LD_INT 30
18540: PUSH
18541: LD_INT 33
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: PPUSH
18553: NOP4
18557: PUSH
18558: FOR_IN
18559: IFFALSE 18599
// begin if not GetBWeapon ( i ) then
18561: NOP4
18565: PPUSH
18566: NOP4
18570: NOT
18571: IFFALSE 18597
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18573: NOP4
18577: PPUSH
18578: NOP4
18582: PPUSH
18583: NOP4
18587: PPUSH
18588: NOP4
18592: PPUSH
18593: NOP4
// end ;
18597: GO 18558
18599: POP
18600: POP
// end ; for i = 1 to personel do
18601: NOP4
18605: PUSH
18606: DOUBLE
18607: LD_INT 1
18609: DEC
18610: ST_TO_ADDR
18611: NOP4
18615: PUSH
18616: FOR_TO
18617: IFFALSE 19681
// begin if i > 4 then
18619: NOP4
18623: PUSH
18624: LD_INT 4
18626: GREATER
18627: IFFALSE 18631
// break ;
18629: GO 19681
// case i of 1 :
18631: NOP4
18635: PUSH
18636: LD_INT 1
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18724
18644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18645: NOP4
18649: PUSH
18650: NOP4
18654: PPUSH
18655: LD_INT 22
18657: PUSH
18658: NOP4
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 58
18669: PUSH
18670: EMPTY
18671: LIST
18672: PUSH
18673: LD_INT 2
18675: PUSH
18676: LD_INT 30
18678: PUSH
18679: LD_INT 32
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: LD_INT 30
18688: PUSH
18689: LD_INT 4
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: PUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 5
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: LIST
18716: PPUSH
18717: NOP4
18721: ST_TO_ADDR
18722: GO 18946
18724: LD_INT 2
18726: DOUBLE
18727: EQUAL
18728: IFTRUE 18732
18730: GO 18794
18732: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18733: NOP4
18737: PUSH
18738: NOP4
18742: PPUSH
18743: LD_INT 22
18745: PUSH
18746: NOP4
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 30
18760: PUSH
18761: LD_INT 0
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 1
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PPUSH
18787: NOP4
18791: ST_TO_ADDR
18792: GO 18946
18794: LD_INT 3
18796: DOUBLE
18797: EQUAL
18798: IFTRUE 18802
18800: GO 18864
18802: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18803: NOP4
18807: PUSH
18808: NOP4
18812: PPUSH
18813: LD_INT 22
18815: PUSH
18816: NOP4
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 2
18827: PUSH
18828: LD_INT 30
18830: PUSH
18831: LD_INT 2
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 30
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: EMPTY
18845: LIST
18846: LIST
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: LIST
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PPUSH
18857: NOP4
18861: ST_TO_ADDR
18862: GO 18946
18864: LD_INT 4
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18945
18872: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18873: NOP4
18877: PUSH
18878: NOP4
18882: PPUSH
18883: LD_INT 22
18885: PUSH
18886: NOP4
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: PUSH
18895: LD_INT 2
18897: PUSH
18898: LD_INT 30
18900: PUSH
18901: LD_INT 6
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 30
18910: PUSH
18911: LD_INT 7
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 30
18920: PUSH
18921: LD_INT 8
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: EMPTY
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PPUSH
18938: NOP4
18942: ST_TO_ADDR
18943: GO 18946
18945: POP
// if i = 1 then
18946: NOP4
18950: PUSH
18951: LD_INT 1
18953: EQUAL
18954: IFFALSE 19065
// begin tmp := [ ] ;
18956: NOP4
18960: PUSH
18961: EMPTY
18962: ST_TO_ADDR
// for j in f do
18963: NOP4
18967: PUSH
18968: NOP4
18972: PUSH
18973: FOR_IN
18974: IFFALSE 19047
// if GetBType ( j ) = b_bunker then
18976: NOP4
18980: PPUSH
18981: NOP4
18985: PUSH
18986: LD_INT 32
18988: EQUAL
18989: IFFALSE 19016
// tmp := Insert ( tmp , 1 , j ) else
18991: NOP4
18995: PUSH
18996: NOP4
19000: PPUSH
19001: LD_INT 1
19003: PPUSH
19004: NOP4
19008: PPUSH
19009: NOP4
19013: ST_TO_ADDR
19014: GO 19045
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19016: NOP4
19020: PUSH
19021: NOP4
19025: PPUSH
19026: NOP4
19030: PUSH
19031: LD_INT 1
19033: PLUS
19034: PPUSH
19035: NOP4
19039: PPUSH
19040: NOP4
19044: ST_TO_ADDR
19045: GO 18973
19047: POP
19048: POP
// if tmp then
19049: NOP4
19053: IFFALSE 19065
// f := tmp ;
19055: NOP4
19059: PUSH
19060: NOP4
19064: ST_TO_ADDR
// end ; x := personel [ i ] ;
19065: NOP4
19069: PUSH
19070: NOP4
19074: PUSH
19075: NOP4
19079: ARRAY
19080: ST_TO_ADDR
// if x = - 1 then
19081: NOP4
19085: PUSH
19086: LD_INT 1
19088: NEG
19089: EQUAL
19090: IFFALSE 19299
// begin for j in f do
19092: NOP4
19096: PUSH
19097: NOP4
19101: PUSH
19102: FOR_IN
19103: IFFALSE 19295
// repeat InitHc ;
19105: NOP4
// if GetBType ( j ) = b_barracks then
19109: NOP4
19113: PPUSH
19114: NOP4
19118: PUSH
19119: LD_INT 5
19121: EQUAL
19122: IFFALSE 19192
// begin if UnitsInside ( j ) < 3 then
19124: NOP4
19128: PPUSH
19129: NOP4
19133: PUSH
19134: LD_INT 3
19136: LESS
19137: IFFALSE 19173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19139: LD_INT 0
19141: PPUSH
19142: LD_INT 5
19144: PUSH
19145: LD_INT 8
19147: PUSH
19148: LD_INT 9
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: LIST
19155: PUSH
19156: NOP4
19160: ARRAY
19161: PPUSH
19162: NOP4
19166: PPUSH
19167: NOP4
19171: GO 19190
// PrepareHuman ( false , i , skill ) ;
19173: LD_INT 0
19175: PPUSH
19176: NOP4
19180: PPUSH
19181: NOP4
19185: PPUSH
19186: NOP4
// end else
19190: GO 19209
// PrepareHuman ( false , i , skill ) ;
19192: LD_INT 0
19194: PPUSH
19195: NOP4
19199: PPUSH
19200: NOP4
19204: PPUSH
19205: NOP4
// un := CreateHuman ;
19209: NOP4
19213: PUSH
19214: NOP4
19218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19219: NOP4
19223: PUSH
19224: NOP4
19228: PPUSH
19229: LD_INT 1
19231: PPUSH
19232: NOP4
19236: PPUSH
19237: NOP4
19241: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19242: NOP4
19246: PPUSH
19247: NOP4
19251: PPUSH
19252: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19256: NOP4
19260: PPUSH
19261: NOP4
19265: PUSH
19266: LD_INT 6
19268: EQUAL
19269: PUSH
19270: NOP4
19274: PPUSH
19275: NOP4
19279: PUSH
19280: LD_INT 32
19282: PUSH
19283: LD_INT 31
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: IN
19290: OR
19291: IFFALSE 19105
19293: GO 19102
19295: POP
19296: POP
// end else
19297: GO 19679
// for j = 1 to x do
19299: NOP4
19303: PUSH
19304: DOUBLE
19305: LD_INT 1
19307: DEC
19308: ST_TO_ADDR
19309: NOP4
19313: PUSH
19314: FOR_TO
19315: IFFALSE 19677
// begin InitHc ;
19317: NOP4
// if not f then
19321: NOP4
19325: NOT
19326: IFFALSE 19415
// begin PrepareHuman ( false , i , skill ) ;
19328: LD_INT 0
19330: PPUSH
19331: NOP4
19335: PPUSH
19336: NOP4
19340: PPUSH
19341: NOP4
// un := CreateHuman ;
19345: NOP4
19349: PUSH
19350: NOP4
19354: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19355: NOP4
19359: PUSH
19360: NOP4
19364: PPUSH
19365: LD_INT 1
19367: PPUSH
19368: NOP4
19372: PPUSH
19373: NOP4
19377: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19378: NOP4
19382: PPUSH
19383: NOP4
19387: PPUSH
19388: NOP4
19392: PPUSH
19393: NOP4
19397: PPUSH
19398: NOP4
19402: PPUSH
19403: LD_INT 10
19405: PPUSH
19406: LD_INT 0
19408: PPUSH
19409: NOP4
// continue ;
19413: GO 19314
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19415: NOP4
19419: PUSH
19420: LD_INT 1
19422: ARRAY
19423: PPUSH
19424: NOP4
19428: PUSH
19429: NOP4
19433: PUSH
19434: LD_INT 1
19436: ARRAY
19437: PPUSH
19438: NOP4
19442: PUSH
19443: LD_INT 32
19445: PUSH
19446: LD_INT 31
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: IN
19453: AND
19454: PUSH
19455: NOP4
19459: PUSH
19460: LD_INT 1
19462: ARRAY
19463: PPUSH
19464: NOP4
19468: PUSH
19469: LD_INT 6
19471: EQUAL
19472: OR
19473: IFFALSE 19493
// f := Delete ( f , 1 ) ;
19475: NOP4
19479: PUSH
19480: NOP4
19484: PPUSH
19485: LD_INT 1
19487: PPUSH
19488: NOP4
19492: ST_TO_ADDR
// if not f then
19493: NOP4
19497: NOT
19498: IFFALSE 19516
// begin x := x + 2 ;
19500: NOP4
19504: PUSH
19505: NOP4
19509: PUSH
19510: LD_INT 2
19512: PLUS
19513: ST_TO_ADDR
// continue ;
19514: GO 19314
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19516: NOP4
19520: PUSH
19521: LD_INT 1
19523: ARRAY
19524: PPUSH
19525: NOP4
19529: PUSH
19530: LD_INT 5
19532: EQUAL
19533: IFFALSE 19607
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19535: NOP4
19539: PUSH
19540: LD_INT 1
19542: ARRAY
19543: PPUSH
19544: NOP4
19548: PUSH
19549: LD_INT 3
19551: LESS
19552: IFFALSE 19588
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19554: LD_INT 0
19556: PPUSH
19557: LD_INT 5
19559: PUSH
19560: LD_INT 8
19562: PUSH
19563: LD_INT 9
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: PUSH
19571: NOP4
19575: ARRAY
19576: PPUSH
19577: NOP4
19581: PPUSH
19582: NOP4
19586: GO 19605
// PrepareHuman ( false , i , skill ) ;
19588: LD_INT 0
19590: PPUSH
19591: NOP4
19595: PPUSH
19596: NOP4
19600: PPUSH
19601: NOP4
// end else
19605: GO 19624
// PrepareHuman ( false , i , skill ) ;
19607: LD_INT 0
19609: PPUSH
19610: NOP4
19614: PPUSH
19615: NOP4
19619: PPUSH
19620: NOP4
// un := CreateHuman ;
19624: NOP4
19628: PUSH
19629: NOP4
19633: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19634: NOP4
19638: PUSH
19639: NOP4
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: NOP4
19651: PPUSH
19652: NOP4
19656: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19657: NOP4
19661: PPUSH
19662: NOP4
19666: PUSH
19667: LD_INT 1
19669: ARRAY
19670: PPUSH
19671: NOP4
// end ;
19675: GO 19314
19677: POP
19678: POP
// end ;
19679: GO 18616
19681: POP
19682: POP
// result := result ^ buildings ;
19683: NOP4
19687: PUSH
19688: NOP4
19692: PUSH
19693: NOP4
19697: ADD
19698: ST_TO_ADDR
// end else
19699: GO 19842
// begin for i = 1 to personel do
19701: NOP4
19705: PUSH
19706: DOUBLE
19707: LD_INT 1
19709: DEC
19710: ST_TO_ADDR
19711: NOP4
19715: PUSH
19716: FOR_TO
19717: IFFALSE 19840
// begin if i > 4 then
19719: NOP4
19723: PUSH
19724: LD_INT 4
19726: GREATER
19727: IFFALSE 19731
// break ;
19729: GO 19840
// x := personel [ i ] ;
19731: NOP4
19735: PUSH
19736: NOP4
19740: PUSH
19741: NOP4
19745: ARRAY
19746: ST_TO_ADDR
// if x = - 1 then
19747: NOP4
19751: PUSH
19752: LD_INT 1
19754: NEG
19755: EQUAL
19756: IFFALSE 19760
// continue ;
19758: GO 19716
// PrepareHuman ( false , i , skill ) ;
19760: LD_INT 0
19762: PPUSH
19763: NOP4
19767: PPUSH
19768: NOP4
19772: PPUSH
19773: NOP4
// un := CreateHuman ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19787: NOP4
19791: PPUSH
19792: NOP4
19796: PPUSH
19797: NOP4
19801: PPUSH
19802: NOP4
19806: PPUSH
19807: NOP4
19811: PPUSH
19812: LD_INT 10
19814: PPUSH
19815: LD_INT 0
19817: PPUSH
19818: NOP4
// result := result ^ un ;
19822: NOP4
19826: PUSH
19827: NOP4
19831: PUSH
19832: NOP4
19836: ADD
19837: ST_TO_ADDR
// end ;
19838: GO 19716
19840: POP
19841: POP
// end ; end ;
19842: LD_VAR 0 7
19846: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19847: LD_INT 0
19849: PPUSH
19850: PPUSH
19851: PPUSH
19852: PPUSH
19853: PPUSH
19854: PPUSH
19855: PPUSH
19856: PPUSH
19857: PPUSH
19858: PPUSH
19859: PPUSH
19860: PPUSH
19861: PPUSH
19862: PPUSH
19863: PPUSH
19864: PPUSH
// result := false ;
19865: NOP4
19869: PUSH
19870: LD_INT 0
19872: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19873: NOP4
19877: NOT
19878: PUSH
19879: NOP4
19883: PPUSH
19884: NOP4
19888: PUSH
19889: LD_INT 32
19891: PUSH
19892: LD_INT 33
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: IN
19899: NOT
19900: OR
19901: IFFALSE 19905
// exit ;
19903: GO 21014
// nat := GetNation ( tower ) ;
19905: NOP4
19909: PUSH
19910: NOP4
19914: PPUSH
19915: NOP4
19919: ST_TO_ADDR
// side := GetSide ( tower ) ;
19920: NOP4
19924: PUSH
19925: NOP4
19929: PPUSH
19930: NOP4
19934: ST_TO_ADDR
// x := GetX ( tower ) ;
19935: NOP4
19939: PUSH
19940: NOP4
19944: PPUSH
19945: NOP4
19949: ST_TO_ADDR
// y := GetY ( tower ) ;
19950: NOP4
19954: PUSH
19955: NOP4
19959: PPUSH
19960: NOP4
19964: ST_TO_ADDR
// if not x or not y then
19965: NOP4
19969: NOT
19970: PUSH
19971: NOP4
19975: NOT
19976: OR
19977: IFFALSE 19981
// exit ;
19979: GO 21014
// weapon := 0 ;
19981: NOP4
19985: PUSH
19986: LD_INT 0
19988: ST_TO_ADDR
// fac_list := [ ] ;
19989: NOP4
19993: PUSH
19994: EMPTY
19995: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19996: NOP4
20000: PUSH
20001: NOP4
20005: PPUSH
20006: NOP4
20010: PPUSH
20011: NOP4
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: NOP4
20023: PPUSH
20024: LD_INT 30
20026: PUSH
20027: LD_INT 3
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: PPUSH
20034: NOP4
20038: ST_TO_ADDR
// if not factories then
20039: NOP4
20043: NOT
20044: IFFALSE 20048
// exit ;
20046: GO 21014
// for i in factories do
20048: NOP4
20052: PUSH
20053: NOP4
20057: PUSH
20058: FOR_IN
20059: IFFALSE 20084
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20061: NOP4
20065: PUSH
20066: NOP4
20070: PUSH
20071: NOP4
20075: PPUSH
20076: NOP4
20080: UNION
20081: ST_TO_ADDR
20082: GO 20058
20084: POP
20085: POP
// if not fac_list then
20086: NOP4
20090: NOT
20091: IFFALSE 20095
// exit ;
20093: GO 21014
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20095: NOP4
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: LD_INT 5
20105: PUSH
20106: LD_INT 9
20108: PUSH
20109: LD_INT 10
20111: PUSH
20112: LD_INT 6
20114: PUSH
20115: LD_INT 7
20117: PUSH
20118: LD_INT 11
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: PUSH
20130: LD_INT 27
20132: PUSH
20133: LD_INT 28
20135: PUSH
20136: LD_INT 26
20138: PUSH
20139: LD_INT 30
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: PUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: LD_INT 46
20156: PUSH
20157: LD_INT 45
20159: PUSH
20160: LD_INT 47
20162: PUSH
20163: LD_INT 49
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: LIST
20178: PUSH
20179: NOP4
20183: ARRAY
20184: ST_TO_ADDR
// list := list isect fac_list ;
20185: NOP4
20189: PUSH
20190: NOP4
20194: PUSH
20195: NOP4
20199: ISECT
20200: ST_TO_ADDR
// if not list then
20201: NOP4
20205: NOT
20206: IFFALSE 20210
// exit ;
20208: GO 21014
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20210: NOP4
20214: PUSH
20215: LD_INT 3
20217: EQUAL
20218: PUSH
20219: LD_INT 49
20221: PUSH
20222: NOP4
20226: IN
20227: AND
20228: PUSH
20229: LD_INT 31
20231: PPUSH
20232: NOP4
20236: PPUSH
20237: NOP4
20241: PUSH
20242: LD_INT 2
20244: EQUAL
20245: AND
20246: IFFALSE 20306
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20248: LD_INT 22
20250: PUSH
20251: NOP4
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PUSH
20260: LD_INT 35
20262: PUSH
20263: LD_INT 49
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: PUSH
20270: LD_INT 91
20272: PUSH
20273: NOP4
20277: PUSH
20278: LD_INT 10
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: PPUSH
20291: NOP4
20295: NOT
20296: IFFALSE 20306
// weapon := ru_time_lapser ;
20298: NOP4
20302: PUSH
20303: LD_INT 49
20305: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20306: NOP4
20310: PUSH
20311: LD_INT 1
20313: PUSH
20314: LD_INT 2
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: IN
20321: PUSH
20322: LD_INT 11
20324: PUSH
20325: NOP4
20329: IN
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: NOP4
20338: IN
20339: OR
20340: AND
20341: PUSH
20342: LD_INT 6
20344: PPUSH
20345: NOP4
20349: PPUSH
20350: NOP4
20354: PUSH
20355: LD_INT 2
20357: EQUAL
20358: AND
20359: IFFALSE 20524
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20361: LD_INT 22
20363: PUSH
20364: NOP4
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: PUSH
20373: LD_INT 2
20375: PUSH
20376: LD_INT 35
20378: PUSH
20379: LD_INT 11
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 35
20388: PUSH
20389: LD_INT 30
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: LIST
20400: PUSH
20401: LD_INT 91
20403: PUSH
20404: NOP4
20408: PUSH
20409: LD_INT 18
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: PPUSH
20422: NOP4
20426: NOT
20427: PUSH
20428: LD_INT 22
20430: PUSH
20431: NOP4
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 2
20442: PUSH
20443: LD_INT 30
20445: PUSH
20446: LD_INT 32
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 30
20455: PUSH
20456: LD_INT 33
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 91
20470: PUSH
20471: NOP4
20475: PUSH
20476: LD_INT 12
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: PUSH
20489: EMPTY
20490: LIST
20491: PPUSH
20492: NOP4
20496: PUSH
20497: LD_INT 2
20499: GREATER
20500: AND
20501: IFFALSE 20524
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20503: NOP4
20507: PUSH
20508: LD_INT 11
20510: PUSH
20511: LD_INT 30
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: NOP4
20522: ARRAY
20523: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20524: NOP4
20528: NOT
20529: PUSH
20530: LD_INT 40
20532: PPUSH
20533: NOP4
20537: PPUSH
20538: NOP4
20542: PUSH
20543: LD_INT 2
20545: EQUAL
20546: AND
20547: PUSH
20548: LD_INT 7
20550: PUSH
20551: NOP4
20555: IN
20556: PUSH
20557: LD_INT 28
20559: PUSH
20560: NOP4
20564: IN
20565: OR
20566: PUSH
20567: LD_INT 45
20569: PUSH
20570: NOP4
20574: IN
20575: OR
20576: AND
20577: IFFALSE 20831
// begin hex := GetHexInfo ( x , y ) ;
20579: NOP4
20583: PUSH
20584: NOP4
20588: PPUSH
20589: NOP4
20593: PPUSH
20594: NOP4
20598: ST_TO_ADDR
// if hex [ 1 ] then
20599: NOP4
20603: PUSH
20604: LD_INT 1
20606: ARRAY
20607: IFFALSE 20611
// exit ;
20609: GO 21014
// height := hex [ 2 ] ;
20611: NOP4
20615: PUSH
20616: NOP4
20620: PUSH
20621: LD_INT 2
20623: ARRAY
20624: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20625: NOP4
20629: PUSH
20630: LD_INT 0
20632: PUSH
20633: LD_INT 2
20635: PUSH
20636: LD_INT 3
20638: PUSH
20639: LD_INT 5
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: ST_TO_ADDR
// for i in tmp do
20648: NOP4
20652: PUSH
20653: NOP4
20657: PUSH
20658: FOR_IN
20659: IFFALSE 20829
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20661: NOP4
20665: PUSH
20666: NOP4
20670: PPUSH
20671: NOP4
20675: PPUSH
20676: LD_INT 5
20678: PPUSH
20679: NOP4
20683: PUSH
20684: NOP4
20688: PPUSH
20689: NOP4
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: NOP4
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20706: NOP4
20710: PUSH
20711: LD_INT 1
20713: ARRAY
20714: PPUSH
20715: NOP4
20719: PUSH
20720: LD_INT 2
20722: ARRAY
20723: PPUSH
20724: NOP4
20728: IFFALSE 20827
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20730: NOP4
20734: PUSH
20735: NOP4
20739: PUSH
20740: LD_INT 1
20742: ARRAY
20743: PPUSH
20744: NOP4
20748: PUSH
20749: LD_INT 2
20751: ARRAY
20752: PPUSH
20753: NOP4
20757: ST_TO_ADDR
// if hex [ 1 ] then
20758: NOP4
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: IFFALSE 20770
// continue ;
20768: GO 20658
// h := hex [ 2 ] ;
20770: NOP4
20774: PUSH
20775: NOP4
20779: PUSH
20780: LD_INT 2
20782: ARRAY
20783: ST_TO_ADDR
// if h + 7 < height then
20784: NOP4
20788: PUSH
20789: LD_INT 7
20791: PLUS
20792: PUSH
20793: NOP4
20797: LESS
20798: IFFALSE 20827
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20800: NOP4
20804: PUSH
20805: LD_INT 7
20807: PUSH
20808: LD_INT 28
20810: PUSH
20811: LD_INT 45
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: LIST
20818: PUSH
20819: NOP4
20823: ARRAY
20824: ST_TO_ADDR
// break ;
20825: GO 20829
// end ; end ; end ;
20827: GO 20658
20829: POP
20830: POP
// end ; if not weapon then
20831: NOP4
20835: NOT
20836: IFFALSE 20896
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20838: NOP4
20842: PUSH
20843: NOP4
20847: PUSH
20848: LD_INT 11
20850: PUSH
20851: LD_INT 30
20853: PUSH
20854: LD_INT 49
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: LIST
20861: DIFF
20862: ST_TO_ADDR
// if not list then
20863: NOP4
20867: NOT
20868: IFFALSE 20872
// exit ;
20870: GO 21014
// weapon := list [ rand ( 1 , list ) ] ;
20872: NOP4
20876: PUSH
20877: NOP4
20881: PUSH
20882: LD_INT 1
20884: PPUSH
20885: NOP4
20889: PPUSH
20890: NOP4
20894: ARRAY
20895: ST_TO_ADDR
// end ; if weapon then
20896: NOP4
20900: IFFALSE 21014
// begin tmp := CostOfWeapon ( weapon ) ;
20902: NOP4
20906: PUSH
20907: NOP4
20911: PPUSH
20912: NOP4
20916: ST_TO_ADDR
// j := GetBase ( tower ) ;
20917: NOP4
20921: PUSH
20922: NOP4
20926: PPUSH
20927: NOP4
20931: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20932: NOP4
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: NOP4
20944: PUSH
20945: NOP4
20949: PUSH
20950: LD_INT 1
20952: ARRAY
20953: GREATEREQUAL
20954: PUSH
20955: NOP4
20959: PPUSH
20960: LD_INT 2
20962: PPUSH
20963: NOP4
20967: PUSH
20968: NOP4
20972: PUSH
20973: LD_INT 2
20975: ARRAY
20976: GREATEREQUAL
20977: AND
20978: PUSH
20979: NOP4
20983: PPUSH
20984: LD_INT 3
20986: PPUSH
20987: NOP4
20991: PUSH
20992: NOP4
20996: PUSH
20997: LD_INT 3
20999: ARRAY
21000: GREATEREQUAL
21001: AND
21002: IFFALSE 21014
// result := weapon ;
21004: NOP4
21008: PUSH
21009: NOP4
21013: ST_TO_ADDR
// end ; end ;
21014: LD_VAR 0 3
21018: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21019: LD_INT 0
21021: PPUSH
21022: PPUSH
// result := true ;
21023: NOP4
21027: PUSH
21028: LD_INT 1
21030: ST_TO_ADDR
// if array1 = array2 then
21031: NOP4
21035: PUSH
21036: NOP4
21040: EQUAL
21041: IFFALSE 21101
// begin for i = 1 to array1 do
21043: NOP4
21047: PUSH
21048: DOUBLE
21049: LD_INT 1
21051: DEC
21052: ST_TO_ADDR
21053: NOP4
21057: PUSH
21058: FOR_TO
21059: IFFALSE 21097
// if array1 [ i ] <> array2 [ i ] then
21061: NOP4
21065: PUSH
21066: NOP4
21070: ARRAY
21071: PUSH
21072: NOP4
21076: PUSH
21077: NOP4
21081: ARRAY
21082: NONEQUAL
21083: IFFALSE 21095
// begin result := false ;
21085: NOP4
21089: PUSH
21090: LD_INT 0
21092: ST_TO_ADDR
// break ;
21093: GO 21097
// end ;
21095: GO 21058
21097: POP
21098: POP
// end else
21099: GO 21109
// result := false ;
21101: NOP4
21105: PUSH
21106: LD_INT 0
21108: ST_TO_ADDR
// end ;
21109: LD_VAR 0 3
21113: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21114: LD_INT 0
21116: PPUSH
21117: PPUSH
// if not array1 or not array2 then
21118: NOP4
21122: NOT
21123: PUSH
21124: NOP4
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 21198
// result := true ;
21134: NOP4
21138: PUSH
21139: LD_INT 1
21141: ST_TO_ADDR
// for i = 1 to array1 do
21142: NOP4
21146: PUSH
21147: DOUBLE
21148: LD_INT 1
21150: DEC
21151: ST_TO_ADDR
21152: NOP4
21156: PUSH
21157: FOR_TO
21158: IFFALSE 21196
// if array1 [ i ] <> array2 [ i ] then
21160: NOP4
21164: PUSH
21165: NOP4
21169: ARRAY
21170: PUSH
21171: NOP4
21175: PUSH
21176: NOP4
21180: ARRAY
21181: NONEQUAL
21182: IFFALSE 21194
// begin result := false ;
21184: NOP4
21188: PUSH
21189: LD_INT 0
21191: ST_TO_ADDR
// break ;
21192: GO 21196
// end ;
21194: GO 21157
21196: POP
21197: POP
// end ;
21198: LD_VAR 0 3
21202: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21203: LD_INT 0
21205: PPUSH
21206: PPUSH
21207: PPUSH
// pom := GetBase ( fac ) ;
21208: NOP4
21212: PUSH
21213: NOP4
21217: PPUSH
21218: NOP4
21222: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21223: NOP4
21227: PUSH
21228: NOP4
21232: PUSH
21233: LD_INT 1
21235: ARRAY
21236: PPUSH
21237: NOP4
21241: PUSH
21242: LD_INT 2
21244: ARRAY
21245: PPUSH
21246: NOP4
21250: PUSH
21251: LD_INT 3
21253: ARRAY
21254: PPUSH
21255: NOP4
21259: PUSH
21260: LD_INT 4
21262: ARRAY
21263: PPUSH
21264: NOP4
21268: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21269: NOP4
21273: PUSH
21274: NOP4
21278: PPUSH
21279: LD_INT 1
21281: PPUSH
21282: NOP4
21286: PUSH
21287: NOP4
21291: PUSH
21292: LD_INT 1
21294: ARRAY
21295: GREATEREQUAL
21296: PUSH
21297: NOP4
21301: PPUSH
21302: LD_INT 2
21304: PPUSH
21305: NOP4
21309: PUSH
21310: NOP4
21314: PUSH
21315: LD_INT 2
21317: ARRAY
21318: GREATEREQUAL
21319: AND
21320: PUSH
21321: NOP4
21325: PPUSH
21326: LD_INT 3
21328: PPUSH
21329: NOP4
21333: PUSH
21334: NOP4
21338: PUSH
21339: LD_INT 3
21341: ARRAY
21342: GREATEREQUAL
21343: AND
21344: ST_TO_ADDR
// end ;
21345: LD_VAR 0 3
21349: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21350: LD_INT 0
21352: PPUSH
21353: PPUSH
21354: PPUSH
21355: PPUSH
// pom := GetBase ( building ) ;
21356: NOP4
21360: PUSH
21361: NOP4
21365: PPUSH
21366: NOP4
21370: ST_TO_ADDR
// if not pom then
21371: NOP4
21375: NOT
21376: IFFALSE 21380
// exit ;
21378: GO 21550
// btype := GetBType ( building ) ;
21380: NOP4
21384: PUSH
21385: NOP4
21389: PPUSH
21390: NOP4
21394: ST_TO_ADDR
// if btype = b_armoury then
21395: NOP4
21399: PUSH
21400: LD_INT 4
21402: EQUAL
21403: IFFALSE 21413
// btype := b_barracks ;
21405: NOP4
21409: PUSH
21410: LD_INT 5
21412: ST_TO_ADDR
// if btype = b_depot then
21413: NOP4
21417: PUSH
21418: LD_INT 0
21420: EQUAL
21421: IFFALSE 21431
// btype := b_warehouse ;
21423: NOP4
21427: PUSH
21428: LD_INT 1
21430: ST_TO_ADDR
// if btype = b_workshop then
21431: NOP4
21435: PUSH
21436: LD_INT 2
21438: EQUAL
21439: IFFALSE 21449
// btype := b_factory ;
21441: NOP4
21445: PUSH
21446: LD_INT 3
21448: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21449: NOP4
21453: PUSH
21454: NOP4
21458: PPUSH
21459: NOP4
21463: PPUSH
21464: NOP4
21468: PPUSH
21469: NOP4
21473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21474: NOP4
21478: PUSH
21479: NOP4
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: NOP4
21491: PUSH
21492: NOP4
21496: PUSH
21497: LD_INT 1
21499: ARRAY
21500: GREATEREQUAL
21501: PUSH
21502: NOP4
21506: PPUSH
21507: LD_INT 2
21509: PPUSH
21510: NOP4
21514: PUSH
21515: NOP4
21519: PUSH
21520: LD_INT 2
21522: ARRAY
21523: GREATEREQUAL
21524: AND
21525: PUSH
21526: NOP4
21530: PPUSH
21531: LD_INT 3
21533: PPUSH
21534: NOP4
21538: PUSH
21539: NOP4
21543: PUSH
21544: LD_INT 3
21546: ARRAY
21547: GREATEREQUAL
21548: AND
21549: ST_TO_ADDR
// end ;
21550: LD_VAR 0 2
21554: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
// pom := GetBase ( building ) ;
21560: NOP4
21564: PUSH
21565: NOP4
21569: PPUSH
21570: NOP4
21574: ST_TO_ADDR
// if not pom then
21575: NOP4
21579: NOT
21580: IFFALSE 21584
// exit ;
21582: GO 21685
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21584: NOP4
21588: PUSH
21589: NOP4
21593: PPUSH
21594: NOP4
21598: PPUSH
21599: NOP4
21603: PPUSH
21604: NOP4
21608: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21609: NOP4
21613: PUSH
21614: NOP4
21618: PPUSH
21619: LD_INT 1
21621: PPUSH
21622: NOP4
21626: PUSH
21627: NOP4
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: GREATEREQUAL
21636: PUSH
21637: NOP4
21641: PPUSH
21642: LD_INT 2
21644: PPUSH
21645: NOP4
21649: PUSH
21650: NOP4
21654: PUSH
21655: LD_INT 2
21657: ARRAY
21658: GREATEREQUAL
21659: AND
21660: PUSH
21661: NOP4
21665: PPUSH
21666: LD_INT 3
21668: PPUSH
21669: NOP4
21673: PUSH
21674: NOP4
21678: PUSH
21679: LD_INT 3
21681: ARRAY
21682: GREATEREQUAL
21683: AND
21684: ST_TO_ADDR
// end ;
21685: LD_VAR 0 3
21689: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21690: LD_INT 0
21692: PPUSH
21693: PPUSH
21694: PPUSH
21695: PPUSH
21696: PPUSH
21697: PPUSH
21698: PPUSH
21699: PPUSH
21700: PPUSH
21701: PPUSH
21702: PPUSH
// result := false ;
21703: NOP4
21707: PUSH
21708: LD_INT 0
21710: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21711: NOP4
21715: NOT
21716: PUSH
21717: NOP4
21721: NOT
21722: OR
21723: PUSH
21724: NOP4
21728: NOT
21729: OR
21730: PUSH
21731: NOP4
21735: NOT
21736: OR
21737: IFFALSE 21741
// exit ;
21739: GO 22555
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21741: NOP4
21745: PUSH
21746: NOP4
21750: PPUSH
21751: NOP4
21755: PPUSH
21756: NOP4
21760: PPUSH
21761: NOP4
21765: PPUSH
21766: NOP4
21770: PUSH
21771: LD_INT 1
21773: ARRAY
21774: PPUSH
21775: NOP4
21779: PPUSH
21780: LD_INT 0
21782: PPUSH
21783: NOP4
21787: ST_TO_ADDR
// if not hexes then
21788: NOP4
21792: NOT
21793: IFFALSE 21797
// exit ;
21795: GO 22555
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21797: NOP4
21801: PUSH
21802: NOP4
21806: PPUSH
21807: LD_INT 22
21809: PUSH
21810: NOP4
21814: PPUSH
21815: NOP4
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: LD_INT 30
21829: PUSH
21830: LD_INT 0
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 30
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: LIST
21851: PUSH
21852: EMPTY
21853: LIST
21854: LIST
21855: PPUSH
21856: NOP4
21860: ST_TO_ADDR
// for i = 1 to hexes do
21861: NOP4
21865: PUSH
21866: DOUBLE
21867: LD_INT 1
21869: DEC
21870: ST_TO_ADDR
21871: NOP4
21875: PUSH
21876: FOR_TO
21877: IFFALSE 22553
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21879: NOP4
21883: PUSH
21884: NOP4
21888: PUSH
21889: NOP4
21893: ARRAY
21894: PUSH
21895: LD_INT 1
21897: ARRAY
21898: PPUSH
21899: NOP4
21903: PUSH
21904: NOP4
21908: ARRAY
21909: PUSH
21910: LD_INT 2
21912: ARRAY
21913: PPUSH
21914: NOP4
21918: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21919: NOP4
21923: PUSH
21924: NOP4
21928: ARRAY
21929: PUSH
21930: LD_INT 1
21932: ARRAY
21933: PPUSH
21934: NOP4
21938: PUSH
21939: NOP4
21943: ARRAY
21944: PUSH
21945: LD_INT 2
21947: ARRAY
21948: PPUSH
21949: NOP4
21953: PUSH
21954: NOP4
21958: PUSH
21959: NOP4
21963: ARRAY
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PPUSH
21969: NOP4
21973: PUSH
21974: NOP4
21978: ARRAY
21979: PUSH
21980: LD_INT 2
21982: ARRAY
21983: PPUSH
21984: NOP4
21988: NOT
21989: OR
21990: PUSH
21991: NOP4
21995: PPUSH
21996: NOP4
22000: PUSH
22001: LD_INT 3
22003: EQUAL
22004: OR
22005: IFFALSE 22011
// exit ;
22007: POP
22008: POP
22009: GO 22555
// if not tmp then
22011: NOP4
22015: NOT
22016: IFFALSE 22020
// continue ;
22018: GO 21876
// result := true ;
22020: NOP4
22024: PUSH
22025: LD_INT 1
22027: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22028: NOP4
22032: PUSH
22033: NOP4
22037: PPUSH
22038: NOP4
22042: PUSH
22043: LD_INT 2
22045: EQUAL
22046: AND
22047: PUSH
22048: NOP4
22052: PPUSH
22053: NOP4
22057: PUSH
22058: LD_INT 1
22060: EQUAL
22061: AND
22062: IFFALSE 22226
// begin if IsDrivenBy ( tmp ) then
22064: NOP4
22068: PPUSH
22069: NOP4
22073: IFFALSE 22077
// continue ;
22075: GO 21876
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22077: NOP4
22081: PPUSH
22082: LD_INT 3
22084: PUSH
22085: LD_INT 60
22087: PUSH
22088: EMPTY
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: LD_INT 55
22100: PUSH
22101: EMPTY
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: PUSH
22108: EMPTY
22109: LIST
22110: LIST
22111: PPUSH
22112: NOP4
22116: IFFALSE 22224
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22118: NOP4
22122: PUSH
22123: NOP4
22127: PPUSH
22128: LD_INT 3
22130: PUSH
22131: LD_INT 60
22133: PUSH
22134: EMPTY
22135: LIST
22136: PUSH
22137: EMPTY
22138: LIST
22139: LIST
22140: PUSH
22141: LD_INT 3
22143: PUSH
22144: LD_INT 55
22146: PUSH
22147: EMPTY
22148: LIST
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PPUSH
22158: NOP4
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: ST_TO_ADDR
// if IsInUnit ( driver ) then
22167: NOP4
22171: PPUSH
22172: NOP4
22176: IFFALSE 22187
// ComExit ( driver ) ;
22178: NOP4
22182: PPUSH
22183: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22187: NOP4
22191: PPUSH
22192: NOP4
22196: PPUSH
22197: NOP4
// AddComMoveToArea ( driver , parking ) ;
22201: NOP4
22205: PPUSH
22206: NOP4
22210: PPUSH
22211: NOP4
// AddComExitVehicle ( driver ) ;
22215: NOP4
22219: PPUSH
22220: NOP4
// end ; continue ;
22224: GO 21876
// end ; if not cleaners or not tmp in cleaners then
22226: NOP4
22230: NOT
22231: PUSH
22232: NOP4
22236: PUSH
22237: NOP4
22241: IN
22242: NOT
22243: OR
22244: IFFALSE 22551
// begin if dep then
22246: NOP4
22250: IFFALSE 22386
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22252: NOP4
22256: PUSH
22257: NOP4
22261: PUSH
22262: LD_INT 1
22264: ARRAY
22265: PPUSH
22266: NOP4
22270: PPUSH
22271: NOP4
22275: PUSH
22276: LD_INT 1
22278: ARRAY
22279: PPUSH
22280: NOP4
22284: PPUSH
22285: LD_INT 5
22287: PPUSH
22288: NOP4
22292: PUSH
22293: NOP4
22297: PUSH
22298: LD_INT 1
22300: ARRAY
22301: PPUSH
22302: NOP4
22306: PPUSH
22307: NOP4
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PPUSH
22316: NOP4
22320: PPUSH
22321: LD_INT 5
22323: PPUSH
22324: NOP4
22328: PUSH
22329: EMPTY
22330: LIST
22331: LIST
22332: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22333: NOP4
22337: PUSH
22338: LD_INT 1
22340: ARRAY
22341: PPUSH
22342: NOP4
22346: PUSH
22347: LD_INT 2
22349: ARRAY
22350: PPUSH
22351: NOP4
22355: IFFALSE 22386
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22357: NOP4
22361: PPUSH
22362: NOP4
22366: PUSH
22367: LD_INT 1
22369: ARRAY
22370: PPUSH
22371: NOP4
22375: PUSH
22376: LD_INT 2
22378: ARRAY
22379: PPUSH
22380: NOP4
// continue ;
22384: GO 21876
// end ; end ; r := GetDir ( tmp ) ;
22386: NOP4
22390: PUSH
22391: NOP4
22395: PPUSH
22396: NOP4
22400: ST_TO_ADDR
// if r = 5 then
22401: NOP4
22405: PUSH
22406: LD_INT 5
22408: EQUAL
22409: IFFALSE 22419
// r := 0 ;
22411: NOP4
22415: PUSH
22416: LD_INT 0
22418: ST_TO_ADDR
// for j = r to 5 do
22419: NOP4
22423: PUSH
22424: DOUBLE
22425: NOP4
22429: DEC
22430: ST_TO_ADDR
22431: LD_INT 5
22433: PUSH
22434: FOR_TO
22435: IFFALSE 22549
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22437: NOP4
22441: PUSH
22442: NOP4
22446: PPUSH
22447: NOP4
22451: PPUSH
22452: NOP4
22456: PPUSH
22457: LD_INT 2
22459: PPUSH
22460: NOP4
22464: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22465: NOP4
22469: PUSH
22470: NOP4
22474: PPUSH
22475: NOP4
22479: PPUSH
22480: NOP4
22484: PPUSH
22485: LD_INT 2
22487: PPUSH
22488: NOP4
22492: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22493: NOP4
22497: PPUSH
22498: NOP4
22502: PPUSH
22503: NOP4
22507: PUSH
22508: NOP4
22512: PPUSH
22513: NOP4
22517: PPUSH
22518: NOP4
22522: NOT
22523: AND
22524: IFFALSE 22547
// begin ComMoveXY ( tmp , _x , _y ) ;
22526: NOP4
22530: PPUSH
22531: NOP4
22535: PPUSH
22536: NOP4
22540: PPUSH
22541: NOP4
// break ;
22545: GO 22549
// end ; end ;
22547: GO 22434
22549: POP
22550: POP
// end ; end ;
22551: GO 21876
22553: POP
22554: POP
// end ;
22555: LD_VAR 0 8
22559: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22560: LD_INT 0
22562: PPUSH
// result := true ;
22563: NOP4
22567: PUSH
22568: LD_INT 1
22570: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22571: NOP4
22575: PUSH
22576: LD_INT 24
22578: DOUBLE
22579: EQUAL
22580: IFTRUE 22590
22582: LD_INT 33
22584: DOUBLE
22585: EQUAL
22586: IFTRUE 22590
22588: GO 22615
22590: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22591: NOP4
22595: PUSH
22596: LD_INT 32
22598: PPUSH
22599: NOP4
22603: PPUSH
22604: NOP4
22608: PUSH
22609: LD_INT 2
22611: EQUAL
22612: ST_TO_ADDR
22613: GO 22935
22615: LD_INT 20
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22648
22623: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22624: NOP4
22628: PUSH
22629: LD_INT 6
22631: PPUSH
22632: NOP4
22636: PPUSH
22637: NOP4
22641: PUSH
22642: LD_INT 2
22644: EQUAL
22645: ST_TO_ADDR
22646: GO 22935
22648: LD_INT 22
22650: DOUBLE
22651: EQUAL
22652: IFTRUE 22662
22654: LD_INT 36
22656: DOUBLE
22657: EQUAL
22658: IFTRUE 22662
22660: GO 22687
22662: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22663: NOP4
22667: PUSH
22668: LD_INT 15
22670: PPUSH
22671: NOP4
22675: PPUSH
22676: NOP4
22680: PUSH
22681: LD_INT 2
22683: EQUAL
22684: ST_TO_ADDR
22685: GO 22935
22687: LD_INT 30
22689: DOUBLE
22690: EQUAL
22691: IFTRUE 22695
22693: GO 22720
22695: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22696: NOP4
22700: PUSH
22701: LD_INT 20
22703: PPUSH
22704: NOP4
22708: PPUSH
22709: NOP4
22713: PUSH
22714: LD_INT 2
22716: EQUAL
22717: ST_TO_ADDR
22718: GO 22935
22720: LD_INT 28
22722: DOUBLE
22723: EQUAL
22724: IFTRUE 22734
22726: LD_INT 21
22728: DOUBLE
22729: EQUAL
22730: IFTRUE 22734
22732: GO 22759
22734: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22735: NOP4
22739: PUSH
22740: LD_INT 21
22742: PPUSH
22743: NOP4
22747: PPUSH
22748: NOP4
22752: PUSH
22753: LD_INT 2
22755: EQUAL
22756: ST_TO_ADDR
22757: GO 22935
22759: LD_INT 16
22761: DOUBLE
22762: EQUAL
22763: IFTRUE 22767
22765: GO 22794
22767: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22768: NOP4
22772: PUSH
22773: NOP4
22777: PPUSH
22778: NOP4
22782: PPUSH
22783: NOP4
22787: PUSH
22788: LD_INT 2
22790: EQUAL
22791: ST_TO_ADDR
22792: GO 22935
22794: LD_INT 19
22796: DOUBLE
22797: EQUAL
22798: IFTRUE 22808
22800: LD_INT 23
22802: DOUBLE
22803: EQUAL
22804: IFTRUE 22808
22806: GO 22835
22808: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22809: NOP4
22813: PUSH
22814: NOP4
22818: PPUSH
22819: NOP4
22823: PPUSH
22824: NOP4
22828: PUSH
22829: LD_INT 2
22831: EQUAL
22832: ST_TO_ADDR
22833: GO 22935
22835: LD_INT 17
22837: DOUBLE
22838: EQUAL
22839: IFTRUE 22843
22841: GO 22868
22843: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22844: NOP4
22848: PUSH
22849: LD_INT 39
22851: PPUSH
22852: NOP4
22856: PPUSH
22857: NOP4
22861: PUSH
22862: LD_INT 2
22864: EQUAL
22865: ST_TO_ADDR
22866: GO 22935
22868: LD_INT 18
22870: DOUBLE
22871: EQUAL
22872: IFTRUE 22876
22874: GO 22901
22876: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22877: NOP4
22881: PUSH
22882: LD_INT 40
22884: PPUSH
22885: NOP4
22889: PPUSH
22890: NOP4
22894: PUSH
22895: LD_INT 2
22897: EQUAL
22898: ST_TO_ADDR
22899: GO 22935
22901: LD_INT 27
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22934
22909: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22910: NOP4
22914: PUSH
22915: LD_INT 35
22917: PPUSH
22918: NOP4
22922: PPUSH
22923: NOP4
22927: PUSH
22928: LD_INT 2
22930: EQUAL
22931: ST_TO_ADDR
22932: GO 22935
22934: POP
// end ;
22935: LD_VAR 0 3
22939: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
22940: LD_INT 0
22942: PPUSH
22943: PPUSH
22944: PPUSH
22945: PPUSH
22946: PPUSH
22947: PPUSH
22948: PPUSH
22949: PPUSH
22950: PPUSH
22951: PPUSH
22952: PPUSH
// result := false ;
22953: NOP4
22957: PUSH
22958: LD_INT 0
22960: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22961: NOP4
22965: NOT
22966: PUSH
22967: NOP4
22971: PPUSH
22972: NOP4
22976: PUSH
22977: LD_INT 0
22979: PUSH
22980: LD_INT 1
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: IN
22987: NOT
22988: OR
22989: PUSH
22990: NOP4
22994: NOT
22995: OR
22996: PUSH
22997: NOP4
23001: PUSH
23002: LD_INT 0
23004: PUSH
23005: LD_INT 1
23007: PUSH
23008: LD_INT 2
23010: PUSH
23011: LD_INT 3
23013: PUSH
23014: LD_INT 4
23016: PUSH
23017: LD_INT 5
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: IN
23028: NOT
23029: OR
23030: PUSH
23031: NOP4
23035: PPUSH
23036: NOP4
23040: PPUSH
23041: NOP4
23045: NOT
23046: OR
23047: IFFALSE 23051
// exit ;
23049: GO 23787
// side := GetSide ( depot ) ;
23051: NOP4
23055: PUSH
23056: NOP4
23060: PPUSH
23061: NOP4
23065: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23066: NOP4
23070: PPUSH
23071: NOP4
23075: PPUSH
23076: NOP4
23080: NOT
23081: IFFALSE 23085
// exit ;
23083: GO 23787
// pom := GetBase ( depot ) ;
23085: NOP4
23089: PUSH
23090: NOP4
23094: PPUSH
23095: NOP4
23099: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23100: NOP4
23104: PUSH
23105: NOP4
23109: PPUSH
23110: NOP4
23114: PPUSH
23115: NOP4
23119: PPUSH
23120: NOP4
23124: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23125: NOP4
23129: PPUSH
23130: LD_INT 1
23132: PPUSH
23133: NOP4
23137: PUSH
23138: NOP4
23142: PUSH
23143: LD_INT 1
23145: ARRAY
23146: GREATEREQUAL
23147: PUSH
23148: NOP4
23152: PPUSH
23153: LD_INT 2
23155: PPUSH
23156: NOP4
23160: PUSH
23161: NOP4
23165: PUSH
23166: LD_INT 2
23168: ARRAY
23169: GREATEREQUAL
23170: AND
23171: PUSH
23172: NOP4
23176: PPUSH
23177: LD_INT 3
23179: PPUSH
23180: NOP4
23184: PUSH
23185: NOP4
23189: PUSH
23190: LD_INT 3
23192: ARRAY
23193: GREATEREQUAL
23194: AND
23195: NOT
23196: IFFALSE 23200
// exit ;
23198: GO 23787
// if GetBType ( depot ) = b_depot then
23200: NOP4
23204: PPUSH
23205: NOP4
23209: PUSH
23210: LD_INT 0
23212: EQUAL
23213: IFFALSE 23225
// dist := 28 else
23215: NOP4
23219: PUSH
23220: LD_INT 28
23222: ST_TO_ADDR
23223: GO 23233
// dist := 36 ;
23225: NOP4
23229: PUSH
23230: LD_INT 36
23232: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23233: NOP4
23237: PPUSH
23238: NOP4
23242: PPUSH
23243: NOP4
23247: PPUSH
23248: NOP4
23252: PUSH
23253: NOP4
23257: GREATER
23258: IFFALSE 23262
// exit ;
23260: GO 23787
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23262: NOP4
23266: PUSH
23267: NOP4
23271: PPUSH
23272: NOP4
23276: PPUSH
23277: NOP4
23281: PPUSH
23282: NOP4
23286: PPUSH
23287: NOP4
23291: PPUSH
23292: NOP4
23296: PPUSH
23297: LD_INT 0
23299: PPUSH
23300: NOP4
23304: ST_TO_ADDR
// if not hexes then
23305: NOP4
23309: NOT
23310: IFFALSE 23314
// exit ;
23312: GO 23787
// hex := GetHexInfo ( x , y ) ;
23314: NOP4
23318: PUSH
23319: NOP4
23323: PPUSH
23324: NOP4
23328: PPUSH
23329: NOP4
23333: ST_TO_ADDR
// if hex [ 1 ] then
23334: NOP4
23338: PUSH
23339: LD_INT 1
23341: ARRAY
23342: IFFALSE 23346
// exit ;
23344: GO 23787
// height := hex [ 2 ] ;
23346: NOP4
23350: PUSH
23351: NOP4
23355: PUSH
23356: LD_INT 2
23358: ARRAY
23359: ST_TO_ADDR
// for i = 1 to hexes do
23360: NOP4
23364: PUSH
23365: DOUBLE
23366: LD_INT 1
23368: DEC
23369: ST_TO_ADDR
23370: NOP4
23374: PUSH
23375: FOR_TO
23376: IFFALSE 23706
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23378: NOP4
23382: PUSH
23383: NOP4
23387: ARRAY
23388: PUSH
23389: LD_INT 1
23391: ARRAY
23392: PPUSH
23393: NOP4
23397: PUSH
23398: NOP4
23402: ARRAY
23403: PUSH
23404: LD_INT 2
23406: ARRAY
23407: PPUSH
23408: NOP4
23412: NOT
23413: PUSH
23414: NOP4
23418: PUSH
23419: NOP4
23423: ARRAY
23424: PUSH
23425: LD_INT 1
23427: ARRAY
23428: PPUSH
23429: NOP4
23433: PUSH
23434: NOP4
23438: ARRAY
23439: PUSH
23440: LD_INT 2
23442: ARRAY
23443: PPUSH
23444: NOP4
23448: PUSH
23449: LD_INT 0
23451: GREATER
23452: OR
23453: PUSH
23454: NOP4
23458: PUSH
23459: NOP4
23463: ARRAY
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: NOP4
23473: PUSH
23474: NOP4
23478: ARRAY
23479: PUSH
23480: LD_INT 2
23482: ARRAY
23483: PPUSH
23484: NOP4
23488: OR
23489: IFFALSE 23495
// exit ;
23491: POP
23492: POP
23493: GO 23787
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23495: NOP4
23499: PUSH
23500: NOP4
23504: PUSH
23505: NOP4
23509: ARRAY
23510: PUSH
23511: LD_INT 1
23513: ARRAY
23514: PPUSH
23515: NOP4
23519: PUSH
23520: NOP4
23524: ARRAY
23525: PUSH
23526: LD_INT 2
23528: ARRAY
23529: PPUSH
23530: NOP4
23534: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23535: NOP4
23539: PUSH
23540: LD_INT 1
23542: ARRAY
23543: PUSH
23544: NOP4
23548: PUSH
23549: LD_INT 2
23551: ARRAY
23552: PUSH
23553: NOP4
23557: PUSH
23558: LD_INT 2
23560: PLUS
23561: GREATER
23562: OR
23563: PUSH
23564: NOP4
23568: PUSH
23569: LD_INT 2
23571: ARRAY
23572: PUSH
23573: NOP4
23577: PUSH
23578: LD_INT 2
23580: MINUS
23581: LESS
23582: OR
23583: PUSH
23584: NOP4
23588: PUSH
23589: LD_INT 3
23591: ARRAY
23592: PUSH
23593: LD_INT 0
23595: PUSH
23596: LD_INT 8
23598: PUSH
23599: LD_INT 9
23601: PUSH
23602: LD_INT 10
23604: PUSH
23605: LD_INT 11
23607: PUSH
23608: LD_INT 12
23610: PUSH
23611: LD_INT 13
23613: PUSH
23614: LD_INT 16
23616: PUSH
23617: LD_INT 17
23619: PUSH
23620: LD_INT 18
23622: PUSH
23623: LD_INT 19
23625: PUSH
23626: LD_INT 20
23628: PUSH
23629: LD_INT 21
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: IN
23647: NOT
23648: OR
23649: PUSH
23650: NOP4
23654: PUSH
23655: LD_INT 5
23657: ARRAY
23658: NOT
23659: OR
23660: PUSH
23661: NOP4
23665: PUSH
23666: LD_INT 6
23668: ARRAY
23669: PUSH
23670: LD_INT 1
23672: PUSH
23673: LD_INT 2
23675: PUSH
23676: LD_INT 7
23678: PUSH
23679: LD_INT 9
23681: PUSH
23682: LD_INT 10
23684: PUSH
23685: LD_INT 11
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: IN
23696: NOT
23697: OR
23698: IFFALSE 23704
// exit ;
23700: POP
23701: POP
23702: GO 23787
// end ;
23704: GO 23375
23706: POP
23707: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23708: NOP4
23712: PPUSH
23713: NOP4
23717: PPUSH
23718: NOP4
23722: PPUSH
23723: LD_INT 20
23725: PPUSH
23726: NOP4
23730: PUSH
23731: LD_INT 4
23733: ARRAY
23734: IFFALSE 23738
// exit ;
23736: GO 23787
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23738: NOP4
23742: PUSH
23743: LD_INT 29
23745: PUSH
23746: LD_INT 30
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: IN
23753: PUSH
23754: NOP4
23758: PPUSH
23759: NOP4
23763: PPUSH
23764: NOP4
23768: PPUSH
23769: NOP4
23773: NOT
23774: AND
23775: IFFALSE 23779
// exit ;
23777: GO 23787
// result := true ;
23779: NOP4
23783: PUSH
23784: LD_INT 1
23786: ST_TO_ADDR
// end ;
23787: LD_VAR 0 6
23791: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23792: LD_INT 0
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
23809: PPUSH
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
23816: PPUSH
23817: PPUSH
23818: PPUSH
23819: PPUSH
23820: PPUSH
23821: PPUSH
23822: PPUSH
23823: PPUSH
23824: PPUSH
23825: PPUSH
23826: PPUSH
23827: PPUSH
23828: PPUSH
23829: PPUSH
23830: PPUSH
23831: PPUSH
23832: PPUSH
23833: PPUSH
23834: PPUSH
23835: PPUSH
23836: PPUSH
23837: PPUSH
23838: PPUSH
23839: PPUSH
23840: PPUSH
23841: PPUSH
23842: PPUSH
23843: PPUSH
23844: PPUSH
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
23851: PPUSH
// result = [ ] ;
23852: NOP4
23856: PUSH
23857: EMPTY
23858: ST_TO_ADDR
// temp_list = [ ] ;
23859: NOP4
23863: PUSH
23864: EMPTY
23865: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23866: NOP4
23870: PUSH
23871: LD_INT 0
23873: PUSH
23874: LD_INT 1
23876: PUSH
23877: LD_INT 2
23879: PUSH
23880: LD_INT 3
23882: PUSH
23883: LD_INT 4
23885: PUSH
23886: LD_INT 5
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: IN
23897: NOT
23898: PUSH
23899: NOP4
23903: PUSH
23904: LD_INT 0
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: IN
23914: PUSH
23915: NOP4
23919: PUSH
23920: LD_INT 1
23922: PUSH
23923: LD_INT 2
23925: PUSH
23926: LD_INT 3
23928: PUSH
23929: EMPTY
23930: LIST
23931: LIST
23932: LIST
23933: IN
23934: NOT
23935: AND
23936: OR
23937: IFFALSE 23941
// exit ;
23939: GO 42332
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23941: NOP4
23945: PUSH
23946: LD_INT 6
23948: PUSH
23949: LD_INT 7
23951: PUSH
23952: LD_INT 8
23954: PUSH
23955: LD_INT 13
23957: PUSH
23958: LD_INT 12
23960: PUSH
23961: LD_INT 15
23963: PUSH
23964: LD_INT 11
23966: PUSH
23967: LD_INT 14
23969: PUSH
23970: LD_INT 10
23972: PUSH
23973: EMPTY
23974: LIST
23975: LIST
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: LIST
23981: LIST
23982: LIST
23983: IN
23984: IFFALSE 23994
// btype = b_lab ;
23986: NOP4
23990: PUSH
23991: LD_INT 6
23993: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23994: NOP4
23998: PUSH
23999: LD_INT 0
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: LD_INT 2
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: LIST
24012: IN
24013: NOT
24014: PUSH
24015: NOP4
24019: PUSH
24020: LD_INT 0
24022: PUSH
24023: LD_INT 1
24025: PUSH
24026: LD_INT 2
24028: PUSH
24029: LD_INT 3
24031: PUSH
24032: LD_INT 6
24034: PUSH
24035: LD_INT 36
24037: PUSH
24038: LD_INT 4
24040: PUSH
24041: LD_INT 5
24043: PUSH
24044: LD_INT 31
24046: PUSH
24047: LD_INT 32
24049: PUSH
24050: LD_INT 33
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: IN
24066: NOT
24067: PUSH
24068: NOP4
24072: PUSH
24073: LD_INT 1
24075: EQUAL
24076: AND
24077: OR
24078: PUSH
24079: NOP4
24083: PUSH
24084: LD_INT 2
24086: PUSH
24087: LD_INT 3
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: IN
24094: NOT
24095: PUSH
24096: NOP4
24100: PUSH
24101: LD_INT 2
24103: EQUAL
24104: AND
24105: OR
24106: IFFALSE 24116
// mode = 0 ;
24108: NOP4
24112: PUSH
24113: LD_INT 0
24115: ST_TO_ADDR
// case mode of 0 :
24116: NOP4
24120: PUSH
24121: LD_INT 0
24123: DOUBLE
24124: EQUAL
24125: IFTRUE 24129
24127: GO 35582
24129: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24130: NOP4
24134: PUSH
24135: LD_INT 0
24137: PUSH
24138: LD_INT 0
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: PUSH
24145: LD_INT 0
24147: PUSH
24148: LD_INT 1
24150: NEG
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: LD_INT 0
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 1
24168: PUSH
24169: LD_INT 1
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 0
24178: PUSH
24179: LD_INT 1
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PUSH
24186: LD_INT 1
24188: NEG
24189: PUSH
24190: LD_INT 0
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: LD_INT 1
24199: NEG
24200: PUSH
24201: LD_INT 1
24203: NEG
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 1
24211: NEG
24212: PUSH
24213: LD_INT 2
24215: NEG
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: PUSH
24221: LD_INT 0
24223: PUSH
24224: LD_INT 2
24226: NEG
24227: PUSH
24228: EMPTY
24229: LIST
24230: LIST
24231: PUSH
24232: LD_INT 1
24234: PUSH
24235: LD_INT 1
24237: NEG
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: PUSH
24243: LD_INT 1
24245: PUSH
24246: LD_INT 2
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PUSH
24253: LD_INT 0
24255: PUSH
24256: LD_INT 2
24258: PUSH
24259: EMPTY
24260: LIST
24261: LIST
24262: PUSH
24263: LD_INT 1
24265: NEG
24266: PUSH
24267: LD_INT 1
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: LD_INT 3
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 1
24296: NEG
24297: PUSH
24298: LD_INT 2
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24323: NOP4
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 0
24340: PUSH
24341: LD_INT 1
24343: NEG
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 1
24351: PUSH
24352: LD_INT 0
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 1
24361: PUSH
24362: LD_INT 1
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 0
24371: PUSH
24372: LD_INT 1
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 1
24381: NEG
24382: PUSH
24383: LD_INT 0
24385: PUSH
24386: EMPTY
24387: LIST
24388: LIST
24389: PUSH
24390: LD_INT 1
24392: NEG
24393: PUSH
24394: LD_INT 1
24396: NEG
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: LD_INT 1
24404: PUSH
24405: LD_INT 1
24407: NEG
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PUSH
24413: LD_INT 2
24415: PUSH
24416: LD_INT 0
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 2
24425: PUSH
24426: LD_INT 1
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 1
24435: NEG
24436: PUSH
24437: LD_INT 1
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 2
24446: NEG
24447: PUSH
24448: LD_INT 0
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 2
24457: NEG
24458: PUSH
24459: LD_INT 1
24461: NEG
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: PUSH
24467: LD_INT 2
24469: NEG
24470: PUSH
24471: LD_INT 1
24473: PUSH
24474: EMPTY
24475: LIST
24476: LIST
24477: PUSH
24478: LD_INT 3
24480: NEG
24481: PUSH
24482: LD_INT 0
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: PUSH
24489: LD_INT 3
24491: NEG
24492: PUSH
24493: LD_INT 1
24495: NEG
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24519: NOP4
24523: PUSH
24524: LD_INT 0
24526: PUSH
24527: LD_INT 0
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: LD_INT 0
24536: PUSH
24537: LD_INT 1
24539: NEG
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 1
24547: PUSH
24548: LD_INT 0
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: PUSH
24558: LD_INT 1
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: LD_INT 1
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PUSH
24575: LD_INT 1
24577: NEG
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 1
24588: NEG
24589: PUSH
24590: LD_INT 1
24592: NEG
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: LD_INT 1
24600: NEG
24601: PUSH
24602: LD_INT 2
24604: NEG
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 2
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: PUSH
24623: LD_INT 2
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 1
24632: PUSH
24633: LD_INT 2
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 2
24642: NEG
24643: PUSH
24644: LD_INT 1
24646: NEG
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: LD_INT 2
24654: NEG
24655: PUSH
24656: LD_INT 2
24658: NEG
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: LD_INT 2
24666: NEG
24667: PUSH
24668: LD_INT 3
24670: NEG
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 3
24678: NEG
24679: PUSH
24680: LD_INT 2
24682: NEG
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: PUSH
24688: LD_INT 3
24690: NEG
24691: PUSH
24692: LD_INT 3
24694: NEG
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: LIST
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: LIST
24713: LIST
24714: LIST
24715: LIST
24716: LIST
24717: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24718: NOP4
24722: PUSH
24723: LD_INT 0
24725: PUSH
24726: LD_INT 0
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 0
24735: PUSH
24736: LD_INT 1
24738: NEG
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 1
24746: PUSH
24747: LD_INT 0
24749: PUSH
24750: EMPTY
24751: LIST
24752: LIST
24753: PUSH
24754: LD_INT 1
24756: PUSH
24757: LD_INT 1
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: LD_INT 0
24766: PUSH
24767: LD_INT 1
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 1
24776: NEG
24777: PUSH
24778: LD_INT 0
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 1
24787: NEG
24788: PUSH
24789: LD_INT 1
24791: NEG
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 1
24799: NEG
24800: PUSH
24801: LD_INT 2
24803: NEG
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 0
24811: PUSH
24812: LD_INT 2
24814: NEG
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: LD_INT 1
24822: PUSH
24823: LD_INT 1
24825: NEG
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: LD_INT 2
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: LD_INT 2
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 1
24864: NEG
24865: PUSH
24866: LD_INT 3
24868: NEG
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PUSH
24874: LD_INT 0
24876: PUSH
24877: LD_INT 3
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: LD_INT 2
24890: NEG
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24914: NOP4
24918: PUSH
24919: LD_INT 0
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 0
24931: PUSH
24932: LD_INT 1
24934: NEG
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: LD_INT 1
24942: PUSH
24943: LD_INT 0
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: PUSH
24953: LD_INT 1
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 0
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 1
24972: NEG
24973: PUSH
24974: LD_INT 0
24976: PUSH
24977: EMPTY
24978: LIST
24979: LIST
24980: PUSH
24981: LD_INT 1
24983: NEG
24984: PUSH
24985: LD_INT 1
24987: NEG
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 1
24995: PUSH
24996: LD_INT 1
24998: NEG
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 2
25006: PUSH
25007: LD_INT 0
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 2
25016: PUSH
25017: LD_INT 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: LD_INT 1
25026: NEG
25027: PUSH
25028: LD_INT 1
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: LD_INT 2
25037: NEG
25038: PUSH
25039: LD_INT 0
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: LD_INT 2
25048: NEG
25049: PUSH
25050: LD_INT 1
25052: NEG
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 2
25060: PUSH
25061: LD_INT 1
25063: NEG
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: LD_INT 3
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: LD_INT 1
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: LIST
25093: LIST
25094: LIST
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25107: NOP4
25111: PUSH
25112: LD_INT 0
25114: PUSH
25115: LD_INT 0
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 1
25127: NEG
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PUSH
25143: LD_INT 1
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 0
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: LD_INT 1
25165: NEG
25166: PUSH
25167: LD_INT 0
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 1
25176: NEG
25177: PUSH
25178: LD_INT 1
25180: NEG
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 1
25188: NEG
25189: PUSH
25190: LD_INT 2
25192: NEG
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 2
25200: PUSH
25201: LD_INT 1
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 2
25210: PUSH
25211: LD_INT 2
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: PUSH
25218: LD_INT 1
25220: PUSH
25221: LD_INT 2
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: NEG
25231: PUSH
25232: LD_INT 1
25234: NEG
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: LD_INT 2
25242: NEG
25243: PUSH
25244: LD_INT 2
25246: NEG
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 3
25254: PUSH
25255: LD_INT 2
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: LD_INT 3
25264: PUSH
25265: LD_INT 3
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: LD_INT 3
25277: PUSH
25278: EMPTY
25279: LIST
25280: LIST
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25300: NOP4
25304: PUSH
25305: LD_INT 0
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: PUSH
25315: LD_INT 0
25317: PUSH
25318: LD_INT 1
25320: NEG
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 1
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 1
25338: PUSH
25339: LD_INT 1
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 0
25348: PUSH
25349: LD_INT 1
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 1
25358: NEG
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 1
25369: NEG
25370: PUSH
25371: LD_INT 1
25373: NEG
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: LD_INT 2
25385: NEG
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 2
25396: NEG
25397: PUSH
25398: EMPTY
25399: LIST
25400: LIST
25401: PUSH
25402: LD_INT 1
25404: PUSH
25405: LD_INT 1
25407: NEG
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: LD_INT 2
25415: PUSH
25416: LD_INT 0
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 2
25425: PUSH
25426: LD_INT 1
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 2
25435: PUSH
25436: LD_INT 2
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 1
25445: PUSH
25446: LD_INT 2
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: LD_INT 2
25458: PUSH
25459: EMPTY
25460: LIST
25461: LIST
25462: PUSH
25463: LD_INT 1
25465: NEG
25466: PUSH
25467: LD_INT 1
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PUSH
25474: LD_INT 2
25476: NEG
25477: PUSH
25478: LD_INT 0
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 2
25487: NEG
25488: PUSH
25489: LD_INT 1
25491: NEG
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 2
25499: NEG
25500: PUSH
25501: LD_INT 2
25503: NEG
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: LIST
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: LIST
25527: LIST
25528: LIST
25529: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25530: NOP4
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 0
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: PUSH
25545: LD_INT 0
25547: PUSH
25548: LD_INT 1
25550: NEG
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 1
25558: PUSH
25559: LD_INT 0
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: LD_INT 1
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 0
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 1
25599: NEG
25600: PUSH
25601: LD_INT 1
25603: NEG
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 1
25611: NEG
25612: PUSH
25613: LD_INT 2
25615: NEG
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 2
25626: NEG
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 1
25634: PUSH
25635: LD_INT 1
25637: NEG
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 2
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: LD_INT 2
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: LD_INT 1
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: LD_INT 2
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 2
25706: NEG
25707: PUSH
25708: LD_INT 0
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 2
25717: NEG
25718: PUSH
25719: LD_INT 1
25721: NEG
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: LD_INT 2
25729: NEG
25730: PUSH
25731: LD_INT 2
25733: NEG
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: LIST
25747: LIST
25748: LIST
25749: LIST
25750: LIST
25751: LIST
25752: LIST
25753: LIST
25754: LIST
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25760: NOP4
25764: PUSH
25765: LD_INT 0
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 0
25777: PUSH
25778: LD_INT 1
25780: NEG
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 1
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 1
25798: PUSH
25799: LD_INT 1
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 1
25818: NEG
25819: PUSH
25820: LD_INT 0
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 1
25829: NEG
25830: PUSH
25831: LD_INT 1
25833: NEG
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: LD_INT 1
25841: NEG
25842: PUSH
25843: LD_INT 2
25845: NEG
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 0
25853: PUSH
25854: LD_INT 2
25856: NEG
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 1
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: LD_INT 1
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 2
25895: PUSH
25896: LD_INT 2
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 1
25905: PUSH
25906: LD_INT 2
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: LD_INT 2
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 1
25925: NEG
25926: PUSH
25927: LD_INT 1
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: PUSH
25934: LD_INT 2
25936: NEG
25937: PUSH
25938: LD_INT 0
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: PUSH
25945: LD_INT 2
25947: NEG
25948: PUSH
25949: LD_INT 1
25951: NEG
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: PUSH
25957: LD_INT 2
25959: NEG
25960: PUSH
25961: LD_INT 2
25963: NEG
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: LIST
25985: LIST
25986: LIST
25987: LIST
25988: LIST
25989: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25990: NOP4
25994: PUSH
25995: LD_INT 0
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 0
26007: PUSH
26008: LD_INT 1
26010: NEG
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PUSH
26016: LD_INT 1
26018: PUSH
26019: LD_INT 0
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 1
26028: PUSH
26029: LD_INT 1
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: NEG
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 1
26059: NEG
26060: PUSH
26061: LD_INT 1
26063: NEG
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 1
26071: NEG
26072: PUSH
26073: LD_INT 2
26075: NEG
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 2
26086: NEG
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 1
26094: PUSH
26095: LD_INT 1
26097: NEG
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 2
26105: PUSH
26106: LD_INT 0
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 2
26125: PUSH
26126: LD_INT 2
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 1
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: LD_INT 2
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: LD_INT 1
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 2
26166: NEG
26167: PUSH
26168: LD_INT 0
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 2
26177: NEG
26178: PUSH
26179: LD_INT 1
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 2
26189: NEG
26190: PUSH
26191: LD_INT 2
26193: NEG
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26220: NOP4
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: PUSH
26235: LD_INT 0
26237: PUSH
26238: LD_INT 1
26240: NEG
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 1
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: PUSH
26259: LD_INT 1
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 1
26278: NEG
26279: PUSH
26280: LD_INT 0
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: PUSH
26287: LD_INT 1
26289: NEG
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: LD_INT 1
26301: NEG
26302: PUSH
26303: LD_INT 2
26305: NEG
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 2
26316: NEG
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 1
26324: PUSH
26325: LD_INT 1
26327: NEG
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 2
26335: PUSH
26336: LD_INT 0
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 2
26355: PUSH
26356: LD_INT 2
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: PUSH
26363: LD_INT 1
26365: PUSH
26366: LD_INT 2
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: LD_INT 2
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: PUSH
26383: LD_INT 1
26385: NEG
26386: PUSH
26387: LD_INT 1
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 2
26396: NEG
26397: PUSH
26398: LD_INT 0
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 2
26407: NEG
26408: PUSH
26409: LD_INT 1
26411: NEG
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 2
26419: NEG
26420: PUSH
26421: LD_INT 2
26423: NEG
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26450: NOP4
26454: PUSH
26455: LD_INT 0
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: PUSH
26479: LD_INT 0
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: LD_INT 0
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 1
26519: NEG
26520: PUSH
26521: LD_INT 1
26523: NEG
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 1
26531: NEG
26532: PUSH
26533: LD_INT 2
26535: NEG
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 0
26543: PUSH
26544: LD_INT 2
26546: NEG
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 1
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 2
26565: PUSH
26566: LD_INT 0
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 2
26575: PUSH
26576: LD_INT 1
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 2
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 1
26595: PUSH
26596: LD_INT 2
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 0
26605: PUSH
26606: LD_INT 2
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 1
26615: NEG
26616: PUSH
26617: LD_INT 1
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 2
26626: NEG
26627: PUSH
26628: LD_INT 0
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 2
26637: NEG
26638: PUSH
26639: LD_INT 1
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 2
26649: NEG
26650: PUSH
26651: LD_INT 2
26653: NEG
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26680: NOP4
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: PUSH
26695: LD_INT 0
26697: PUSH
26698: LD_INT 1
26700: NEG
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 0
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 1
26738: NEG
26739: PUSH
26740: LD_INT 0
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 1
26749: NEG
26750: PUSH
26751: LD_INT 1
26753: NEG
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: LD_INT 1
26761: NEG
26762: PUSH
26763: LD_INT 2
26765: NEG
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 0
26773: PUSH
26774: LD_INT 2
26776: NEG
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: PUSH
26785: LD_INT 1
26787: NEG
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 2
26795: PUSH
26796: LD_INT 0
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 2
26805: PUSH
26806: LD_INT 1
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 2
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: LD_INT 2
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 0
26835: PUSH
26836: LD_INT 2
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 1
26845: NEG
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 2
26856: NEG
26857: PUSH
26858: LD_INT 0
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 2
26867: NEG
26868: PUSH
26869: LD_INT 1
26871: NEG
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 2
26879: NEG
26880: PUSH
26881: LD_INT 2
26883: NEG
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 2
26891: NEG
26892: PUSH
26893: LD_INT 3
26895: NEG
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 1
26903: NEG
26904: PUSH
26905: LD_INT 3
26907: NEG
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 1
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: LIST
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26960: NOP4
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: LD_INT 0
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: LD_INT 1
26980: NEG
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: LD_INT 0
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: LD_INT 1
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_INT 1
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: LD_INT 1
27018: NEG
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 1
27029: NEG
27030: PUSH
27031: LD_INT 1
27033: NEG
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 1
27041: NEG
27042: PUSH
27043: LD_INT 2
27045: NEG
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: LD_INT 0
27053: PUSH
27054: LD_INT 2
27056: NEG
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: LD_INT 1
27067: NEG
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 2
27075: PUSH
27076: LD_INT 0
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 2
27085: PUSH
27086: LD_INT 1
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: PUSH
27093: LD_INT 2
27095: PUSH
27096: LD_INT 2
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PUSH
27103: LD_INT 1
27105: PUSH
27106: LD_INT 2
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 0
27115: PUSH
27116: LD_INT 2
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: LD_INT 1
27125: NEG
27126: PUSH
27127: LD_INT 1
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: LD_INT 2
27136: NEG
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 2
27147: NEG
27148: PUSH
27149: LD_INT 1
27151: NEG
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 2
27159: NEG
27160: PUSH
27161: LD_INT 2
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 2
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 2
27182: PUSH
27183: LD_INT 1
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 3
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 3
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: LIST
27216: LIST
27217: LIST
27218: LIST
27219: LIST
27220: LIST
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: LIST
27231: LIST
27232: LIST
27233: LIST
27234: LIST
27235: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27236: NOP4
27240: PUSH
27241: LD_INT 0
27243: PUSH
27244: LD_INT 0
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: LD_INT 1
27256: NEG
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 1
27274: PUSH
27275: LD_INT 1
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: LD_INT 1
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 1
27294: NEG
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 1
27305: NEG
27306: PUSH
27307: LD_INT 1
27309: NEG
27310: PUSH
27311: EMPTY
27312: LIST
27313: LIST
27314: PUSH
27315: LD_INT 1
27317: NEG
27318: PUSH
27319: LD_INT 2
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 0
27329: PUSH
27330: LD_INT 2
27332: NEG
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: LD_INT 1
27343: NEG
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: LD_INT 0
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: PUSH
27369: LD_INT 2
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: PUSH
27379: LD_INT 1
27381: PUSH
27382: LD_INT 2
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 0
27391: PUSH
27392: LD_INT 2
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: LD_INT 1
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 2
27412: NEG
27413: PUSH
27414: LD_INT 0
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 2
27423: NEG
27424: PUSH
27425: LD_INT 1
27427: NEG
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 2
27435: NEG
27436: PUSH
27437: LD_INT 2
27439: NEG
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 3
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 3
27457: PUSH
27458: LD_INT 2
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: LD_INT 3
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 3
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: LIST
27495: LIST
27496: LIST
27497: LIST
27498: LIST
27499: LIST
27500: LIST
27501: LIST
27502: LIST
27503: LIST
27504: LIST
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27510: NOP4
27514: PUSH
27515: LD_INT 0
27517: PUSH
27518: LD_INT 0
27520: PUSH
27521: EMPTY
27522: LIST
27523: LIST
27524: PUSH
27525: LD_INT 0
27527: PUSH
27528: LD_INT 1
27530: NEG
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: LD_INT 0
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 1
27548: PUSH
27549: LD_INT 1
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 0
27558: PUSH
27559: LD_INT 1
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: LD_INT 0
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: PUSH
27577: LD_INT 1
27579: NEG
27580: PUSH
27581: LD_INT 1
27583: NEG
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 2
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: LD_INT 2
27606: NEG
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 1
27614: PUSH
27615: LD_INT 1
27617: NEG
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: LD_INT 1
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: LD_INT 2
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 2
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: PUSH
27673: LD_INT 1
27675: NEG
27676: PUSH
27677: LD_INT 1
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 2
27697: NEG
27698: PUSH
27699: LD_INT 1
27701: NEG
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 2
27709: NEG
27710: PUSH
27711: LD_INT 2
27713: NEG
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: LD_INT 3
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 1
27741: NEG
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 2
27752: NEG
27753: PUSH
27754: LD_INT 1
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: LIST
27784: LIST
27785: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27786: NOP4
27790: PUSH
27791: LD_INT 0
27793: PUSH
27794: LD_INT 0
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 0
27803: PUSH
27804: LD_INT 1
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: LD_INT 0
27817: PUSH
27818: EMPTY
27819: LIST
27820: LIST
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: LD_INT 1
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: PUSH
27832: LD_INT 0
27834: PUSH
27835: LD_INT 1
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 1
27844: NEG
27845: PUSH
27846: LD_INT 0
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PUSH
27853: LD_INT 1
27855: NEG
27856: PUSH
27857: LD_INT 1
27859: NEG
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: NEG
27868: PUSH
27869: LD_INT 2
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: LD_INT 2
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: PUSH
27891: LD_INT 1
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 2
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 2
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: PUSH
27919: LD_INT 2
27921: PUSH
27922: LD_INT 2
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 1
27931: PUSH
27932: LD_INT 2
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: LD_INT 2
27944: PUSH
27945: EMPTY
27946: LIST
27947: LIST
27948: PUSH
27949: LD_INT 1
27951: NEG
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: LD_INT 0
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 2
27973: NEG
27974: PUSH
27975: LD_INT 1
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 2
27985: NEG
27986: PUSH
27987: LD_INT 2
27989: NEG
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: LD_INT 2
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 2
28008: NEG
28009: PUSH
28010: LD_INT 1
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 3
28019: NEG
28020: PUSH
28021: LD_INT 1
28023: NEG
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 3
28031: NEG
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28066: NOP4
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: LD_INT 0
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: PUSH
28105: LD_INT 1
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 0
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: LD_INT 2
28151: NEG
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 0
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: PUSH
28171: LD_INT 1
28173: NEG
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 2
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 2
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 2
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: LD_INT 1
28211: PUSH
28212: LD_INT 2
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: LD_INT 1
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 2
28242: NEG
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 2
28253: NEG
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: NEG
28266: PUSH
28267: LD_INT 2
28269: NEG
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: NEG
28278: PUSH
28279: LD_INT 3
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 1
28289: NEG
28290: PUSH
28291: LD_INT 3
28293: NEG
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 3
28301: NEG
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 3
28313: NEG
28314: PUSH
28315: LD_INT 2
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: LIST
28347: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28348: NOP4
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: LD_INT 0
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 1
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 1
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 1
28406: NEG
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: NEG
28418: PUSH
28419: LD_INT 1
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 1
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 0
28441: PUSH
28442: LD_INT 2
28444: NEG
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: LD_INT 1
28455: NEG
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 2
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 2
28473: PUSH
28474: LD_INT 1
28476: PUSH
28477: EMPTY
28478: LIST
28479: LIST
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: LD_INT 2
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 0
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 1
28503: NEG
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: NEG
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 2
28526: NEG
28527: PUSH
28528: LD_INT 2
28530: NEG
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 2
28538: NEG
28539: PUSH
28540: LD_INT 3
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 1
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: LD_INT 2
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 3
28592: NEG
28593: PUSH
28594: LD_INT 2
28596: NEG
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28627: NOP4
28631: PUSH
28632: LD_INT 0
28634: PUSH
28635: LD_INT 0
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 0
28644: PUSH
28645: LD_INT 1
28647: NEG
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 1
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: PUSH
28666: LD_INT 1
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: EMPTY
28691: LIST
28692: LIST
28693: PUSH
28694: LD_INT 1
28696: NEG
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: PUSH
28706: LD_INT 1
28708: NEG
28709: PUSH
28710: LD_INT 2
28712: NEG
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 0
28720: PUSH
28721: LD_INT 2
28723: NEG
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: LD_INT 1
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 2
28742: PUSH
28743: LD_INT 0
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 2
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 2
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 1
28772: PUSH
28773: LD_INT 2
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PUSH
28791: LD_INT 2
28793: NEG
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: PUSH
28802: LD_INT 2
28804: NEG
28805: PUSH
28806: LD_INT 1
28808: NEG
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: LD_INT 3
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 2
28831: NEG
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 3
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 2
28849: PUSH
28850: LD_INT 3
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 3
28870: NEG
28871: PUSH
28872: LD_INT 1
28874: NEG
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28905: NOP4
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: LD_INT 1
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: NEG
28964: PUSH
28965: LD_INT 0
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 1
28974: NEG
28975: PUSH
28976: LD_INT 1
28978: NEG
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 1
28986: NEG
28987: PUSH
28988: LD_INT 2
28990: NEG
28991: PUSH
28992: EMPTY
28993: LIST
28994: LIST
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: LD_INT 1
29001: NEG
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 2
29019: PUSH
29020: LD_INT 1
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 2
29029: PUSH
29030: LD_INT 2
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: LD_INT 2
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: LD_INT 2
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: NEG
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 2
29070: NEG
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 2
29082: NEG
29083: PUSH
29084: LD_INT 2
29086: NEG
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 2
29094: NEG
29095: PUSH
29096: LD_INT 3
29098: NEG
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 3
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 3
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 3
29148: NEG
29149: PUSH
29150: LD_INT 2
29152: NEG
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: LIST
29179: LIST
29180: LIST
29181: LIST
29182: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29183: NOP4
29187: PUSH
29188: LD_INT 0
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 0
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 1
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 1
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: LD_INT 1
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: NEG
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 2
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: LD_INT 2
29279: NEG
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 1
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 2
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 2
29308: PUSH
29309: LD_INT 2
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: LD_INT 2
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 0
29328: PUSH
29329: LD_INT 2
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: NEG
29339: PUSH
29340: LD_INT 1
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 0
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 2
29360: NEG
29361: PUSH
29362: LD_INT 1
29364: NEG
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 1
29372: NEG
29373: PUSH
29374: LD_INT 3
29376: NEG
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: LD_INT 2
29387: NEG
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 3
29395: PUSH
29396: LD_INT 2
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: LD_INT 3
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: NEG
29416: PUSH
29417: LD_INT 1
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 3
29426: NEG
29427: PUSH
29428: LD_INT 1
29430: NEG
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29461: NOP4
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 0
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 1
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: LD_INT 1
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 1
29519: NEG
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 1
29530: NEG
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 1
29542: NEG
29543: PUSH
29544: LD_INT 2
29546: NEG
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: LD_INT 1
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 1
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 0
29595: PUSH
29596: LD_INT 2
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: NEG
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: LD_INT 0
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 2
29627: NEG
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: LD_INT 2
29643: NEG
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: LD_INT 2
29651: NEG
29652: PUSH
29653: LD_INT 3
29655: NEG
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 2
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 3
29674: PUSH
29675: LD_INT 1
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: LD_INT 3
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: LD_INT 2
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 3
29705: NEG
29706: PUSH
29707: LD_INT 2
29709: NEG
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29740: NOP4
29744: PUSH
29745: LD_INT 0
29747: PUSH
29748: LD_INT 0
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: LD_INT 1
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: LD_INT 0
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 0
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: NEG
29822: PUSH
29823: LD_INT 2
29825: NEG
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 0
29833: PUSH
29834: LD_INT 2
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: LD_INT 2
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: LD_INT 2
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: NEG
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: NEG
29908: PUSH
29909: LD_INT 1
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 2
29919: NEG
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 3
29935: NEG
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 3
29954: PUSH
29955: LD_INT 2
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 2
29974: NEG
29975: PUSH
29976: LD_INT 1
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 3
29985: NEG
29986: PUSH
29987: LD_INT 1
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30020: NOP4
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 0
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 1
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 0
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 2
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 2
30111: NEG
30112: PUSH
30113: LD_INT 1
30115: NEG
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30132: NOP4
30136: PUSH
30137: LD_INT 0
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 0
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 1
30160: PUSH
30161: LD_INT 0
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 1
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: LD_INT 1
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 1
30190: NEG
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30244: NOP4
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 0
30292: PUSH
30293: LD_INT 1
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: NEG
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 1
30317: NEG
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 1
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30356: NOP4
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: LD_INT 0
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 0
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 0
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 1
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 1
30414: NEG
30415: PUSH
30416: LD_INT 0
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 2
30447: NEG
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30468: NOP4
30472: PUSH
30473: LD_INT 0
30475: PUSH
30476: LD_INT 0
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: LD_INT 1
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 1
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 1
30526: NEG
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: NEG
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 1
30549: NEG
30550: PUSH
30551: LD_INT 2
30553: NEG
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30580: NOP4
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 1
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: NEG
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30692: NOP4
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 0
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 1
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 1
30750: NEG
30751: PUSH
30752: LD_INT 0
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: NEG
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: NEG
30774: PUSH
30775: LD_INT 2
30777: NEG
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 1
30788: NEG
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 2
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 2
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 2
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 1
30836: NEG
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: NEG
30883: PUSH
30884: LD_INT 3
30886: NEG
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 3
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 3
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 3
30925: PUSH
30926: LD_INT 2
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 3
30935: PUSH
30936: LD_INT 3
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: LD_INT 3
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 2
30955: NEG
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 3
30966: NEG
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 3
30977: NEG
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 3
30989: NEG
30990: PUSH
30991: LD_INT 2
30993: NEG
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 3
31001: NEG
31002: PUSH
31003: LD_INT 3
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31042: NOP4
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 1
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 2
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 2
31208: NEG
31209: PUSH
31210: LD_INT 1
31212: NEG
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 2
31220: NEG
31221: PUSH
31222: LD_INT 2
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: LD_INT 3
31236: NEG
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: NEG
31245: PUSH
31246: LD_INT 3
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 0
31256: PUSH
31257: LD_INT 3
31259: NEG
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 3
31278: PUSH
31279: LD_INT 2
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 3
31288: PUSH
31289: LD_INT 3
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: PUSH
31299: LD_INT 3
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: LD_INT 3
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: LD_INT 3
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 3
31339: NEG
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 3
31351: NEG
31352: PUSH
31353: LD_INT 3
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31392: NOP4
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 0
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 2
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 0
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: NEG
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: NEG
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 2
31569: NEG
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: NEG
31582: PUSH
31583: LD_INT 3
31585: NEG
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 3
31596: NEG
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 1
31604: PUSH
31605: LD_INT 2
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 2
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 3
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 3
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: PUSH
31647: LD_INT 3
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 0
31656: PUSH
31657: LD_INT 3
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 1
31666: NEG
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: NEG
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 3
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 3
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31740: NOP4
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 2
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: LD_INT 2
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 2
31895: NEG
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 2
31906: NEG
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: NEG
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: LD_INT 3
31934: NEG
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 3
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 3
31963: PUSH
31964: LD_INT 1
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 3
31973: PUSH
31974: LD_INT 2
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 3
31983: PUSH
31984: LD_INT 3
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: PUSH
31994: LD_INT 3
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 3
32014: NEG
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 3
32025: NEG
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 3
32037: NEG
32038: PUSH
32039: LD_INT 2
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 3
32049: NEG
32050: PUSH
32051: LD_INT 3
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: LIST
32072: LIST
32073: LIST
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32090: NOP4
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 1
32128: PUSH
32129: LD_INT 1
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 0
32138: PUSH
32139: LD_INT 1
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: LD_INT 0
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: LD_INT 1
32163: NEG
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: LD_INT 2
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: LD_INT 2
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 2
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: LD_INT 3
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: NEG
32293: PUSH
32294: LD_INT 3
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 3
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: LD_INT 2
32318: NEG
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 3
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 3
32336: PUSH
32337: LD_INT 3
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 3
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 0
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: NEG
32377: PUSH
32378: LD_INT 2
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 3
32387: NEG
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 3
32399: NEG
32400: PUSH
32401: LD_INT 3
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32440: NOP4
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: LD_INT 1
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 1
32498: NEG
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 0
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: PUSH
32556: LD_INT 0
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: LD_INT 3
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: LD_INT 3
32644: NEG
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: LD_INT 2
32655: NEG
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 2
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 3
32674: PUSH
32675: LD_INT 0
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 3
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 3
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 2
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 2
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 3
32736: NEG
32737: PUSH
32738: LD_INT 0
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 3
32747: NEG
32748: PUSH
32749: LD_INT 1
32751: NEG
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32788: NOP4
32792: PUSH
32793: LD_INT 0
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 1
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: LD_INT 0
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 1
32869: NEG
32870: PUSH
32871: LD_INT 2
32873: NEG
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: LD_INT 1
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: LD_INT 2
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32939: NOP4
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 1
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 0
33032: PUSH
33033: LD_INT 2
33035: NEG
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 1
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: PUSH
33065: LD_INT 1
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33086: NOP4
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 0
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: NEG
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: LD_INT 1
33170: NEG
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 1
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 2
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33230: NOP4
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 1
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 0
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: LD_INT 1
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 2
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 2
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 1
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33374: NOP4
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33521: NOP4
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 1
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 1
33602: NEG
33603: PUSH
33604: LD_INT 2
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: NEG
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 2
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: NEG
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 2
33648: NEG
33649: PUSH
33650: LD_INT 2
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33672: NOP4
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: LD_INT 1
33692: NEG
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 2
33848: NEG
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33902: NOP4
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 1
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: LD_INT 2
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 2
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 2
34017: PUSH
34018: LD_INT 0
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 2
34037: PUSH
34038: LD_INT 2
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 1
34047: PUSH
34048: LD_INT 2
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 2
34078: NEG
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 2
34089: NEG
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 2
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34132: NOP4
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 1
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 2
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 2
34267: PUSH
34268: LD_INT 2
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 2
34308: NEG
34309: PUSH
34310: LD_INT 0
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 2
34319: NEG
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: NEG
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34362: NOP4
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 0
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 2
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 1
34469: NEG
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: LD_INT 0
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 2
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34592: NOP4
34596: PUSH
34597: LD_INT 0
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 0
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: LD_INT 1
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: NEG
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: LD_INT 2
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 2
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 2
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 2
34727: PUSH
34728: LD_INT 2
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 1
34737: PUSH
34738: LD_INT 2
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: LD_INT 2
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 2
34779: NEG
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 2
34791: NEG
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34822: NOP4
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: LD_INT 2
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 0
34915: PUSH
34916: LD_INT 2
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35052: NOP4
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 1
35072: NEG
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: LD_INT 0
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35140: NOP4
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 0
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: LD_INT 0
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35228: NOP4
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: NEG
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: LD_INT 1
35301: NEG
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35316: NOP4
35320: PUSH
35321: LD_INT 0
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35404: NOP4
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 0
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: LD_INT 1
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: LD_INT 1
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 1
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 1
35462: NEG
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35492: NOP4
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: LD_INT 1
35565: NEG
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: ST_TO_ADDR
// end ; 1 :
35580: GO 41477
35582: LD_INT 1
35584: DOUBLE
35585: EQUAL
35586: IFTRUE 35590
35588: GO 38213
35590: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35591: NOP4
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 3
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 3
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: LIST
35634: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35635: NOP4
35639: PUSH
35640: LD_INT 2
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 3
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 3
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35676: NOP4
35680: PUSH
35681: LD_INT 3
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 3
35693: PUSH
35694: LD_INT 3
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 3
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35716: NOP4
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 3
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 3
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35757: NOP4
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 3
35775: NEG
35776: PUSH
35777: LD_INT 0
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 3
35786: NEG
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35801: NOP4
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: LD_INT 3
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 3
35820: NEG
35821: PUSH
35822: LD_INT 2
35824: NEG
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 3
35832: NEG
35833: PUSH
35834: LD_INT 3
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: LIST
35846: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35847: NOP4
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: LD_INT 3
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 3
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: LIST
35890: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35891: NOP4
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: NEG
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: PUSH
35920: LD_INT 1
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: LIST
35931: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35932: NOP4
35936: PUSH
35937: LD_INT 3
35939: PUSH
35940: LD_INT 2
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 3
35949: PUSH
35950: LD_INT 3
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 3
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: LIST
35971: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35972: NOP4
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: LD_INT 3
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 0
35989: PUSH
35990: LD_INT 3
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: LIST
36012: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36013: NOP4
36017: PUSH
36018: LD_INT 2
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 3
36031: NEG
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 3
36042: NEG
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: LIST
36056: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36057: NOP4
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 3
36076: NEG
36077: PUSH
36078: LD_INT 2
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 3
36088: NEG
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: LIST
36102: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36103: NOP4
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: LD_INT 3
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 4
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 3
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36147: NOP4
36151: PUSH
36152: LD_INT 3
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 3
36164: PUSH
36165: LD_INT 1
36167: NEG
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 4
36175: PUSH
36176: LD_INT 1
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: LIST
36187: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36188: NOP4
36192: PUSH
36193: LD_INT 3
36195: PUSH
36196: LD_INT 3
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 4
36205: PUSH
36206: LD_INT 3
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 3
36215: PUSH
36216: LD_INT 4
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36228: NOP4
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 3
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 1
36245: PUSH
36246: LD_INT 4
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: NEG
36256: PUSH
36257: LD_INT 3
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36269: NOP4
36273: PUSH
36274: LD_INT 3
36276: NEG
36277: PUSH
36278: LD_INT 0
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 3
36287: NEG
36288: PUSH
36289: LD_INT 1
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 4
36298: NEG
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36313: NOP4
36317: PUSH
36318: LD_INT 3
36320: NEG
36321: PUSH
36322: LD_INT 3
36324: NEG
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 3
36332: NEG
36333: PUSH
36334: LD_INT 4
36336: NEG
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 4
36344: NEG
36345: PUSH
36346: LD_INT 3
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: LIST
36358: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36359: NOP4
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: LD_INT 3
36370: NEG
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 3
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: LD_INT 2
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: LD_INT 4
36404: NEG
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: LD_INT 4
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 1
36423: PUSH
36424: LD_INT 3
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 5
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 4
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: LD_INT 6
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: LD_INT 6
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 5
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36514: NOP4
36518: PUSH
36519: LD_INT 2
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 3
36532: PUSH
36533: LD_INT 0
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 3
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 4
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 4
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 4
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 5
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 5
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 5
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 6
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 6
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36657: NOP4
36661: PUSH
36662: LD_INT 3
36664: PUSH
36665: LD_INT 2
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 3
36674: PUSH
36675: LD_INT 3
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 2
36684: PUSH
36685: LD_INT 3
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 4
36694: PUSH
36695: LD_INT 3
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 4
36704: PUSH
36705: LD_INT 4
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 3
36714: PUSH
36715: LD_INT 4
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 5
36724: PUSH
36725: LD_INT 4
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 5
36734: PUSH
36735: LD_INT 5
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 4
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 6
36754: PUSH
36755: LD_INT 5
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 6
36764: PUSH
36765: LD_INT 6
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 5
36774: PUSH
36775: LD_INT 6
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36796: NOP4
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 2
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: PUSH
36835: LD_INT 4
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: LD_INT 3
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 5
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 5
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: NEG
36886: PUSH
36887: LD_INT 4
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 6
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 6
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 5
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36939: NOP4
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 3
36957: NEG
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 3
36968: NEG
36969: PUSH
36970: LD_INT 1
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: LD_INT 1
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 4
36991: NEG
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 4
37002: NEG
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 4
37014: NEG
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 5
37025: NEG
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 5
37036: NEG
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 5
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 6
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 6
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: LIST
37092: LIST
37093: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37094: NOP4
37098: PUSH
37099: LD_INT 2
37101: NEG
37102: PUSH
37103: LD_INT 3
37105: NEG
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: LD_INT 3
37129: NEG
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 3
37137: NEG
37138: PUSH
37139: LD_INT 4
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 4
37149: NEG
37150: PUSH
37151: LD_INT 3
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 4
37161: NEG
37162: PUSH
37163: LD_INT 4
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 4
37173: NEG
37174: PUSH
37175: LD_INT 5
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 5
37185: NEG
37186: PUSH
37187: LD_INT 4
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 5
37197: NEG
37198: PUSH
37199: LD_INT 5
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 5
37209: NEG
37210: PUSH
37211: LD_INT 6
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 6
37221: NEG
37222: PUSH
37223: LD_INT 5
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 6
37233: NEG
37234: PUSH
37235: LD_INT 6
37237: NEG
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37257: NOP4
37261: PUSH
37262: LD_INT 0
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 1
37275: NEG
37276: PUSH
37277: LD_INT 3
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: LD_INT 2
37290: NEG
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37301: NOP4
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: PUSH
37319: LD_INT 1
37321: NEG
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 3
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37342: NOP4
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: LD_INT 2
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 3
37359: PUSH
37360: LD_INT 2
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 2
37369: PUSH
37370: LD_INT 3
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: LIST
37381: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37382: NOP4
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: LD_INT 3
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 1
37409: NEG
37410: PUSH
37411: LD_INT 2
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37423: NOP4
37427: PUSH
37428: LD_INT 2
37430: NEG
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 2
37441: NEG
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 3
37452: NEG
37453: PUSH
37454: LD_INT 1
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: LIST
37466: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37467: NOP4
37471: PUSH
37472: LD_INT 2
37474: NEG
37475: PUSH
37476: LD_INT 2
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 2
37486: NEG
37487: PUSH
37488: LD_INT 3
37490: NEG
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 3
37498: NEG
37499: PUSH
37500: LD_INT 2
37502: NEG
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: LIST
37512: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37513: NOP4
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: LD_INT 3
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: LD_INT 3
37536: NEG
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37546: NOP4
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: LD_INT 2
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37577: NOP4
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 3
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37606: NOP4
37610: PUSH
37611: LD_INT 2
37613: PUSH
37614: LD_INT 3
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 3
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37635: NOP4
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37666: NOP4
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: NEG
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37699: NOP4
37703: PUSH
37704: LD_INT 1
37706: NEG
37707: PUSH
37708: LD_INT 3
37710: NEG
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 0
37718: PUSH
37719: LD_INT 3
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: LIST
37742: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37743: NOP4
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37784: NOP4
37788: PUSH
37789: LD_INT 3
37791: PUSH
37792: LD_INT 2
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 3
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 3
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: LIST
37823: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37824: NOP4
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 3
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 3
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 2
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: LIST
37864: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37865: NOP4
37869: PUSH
37870: LD_INT 2
37872: NEG
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 3
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: LIST
37908: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37909: NOP4
37913: PUSH
37914: LD_INT 2
37916: NEG
37917: PUSH
37918: LD_INT 3
37920: NEG
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 2
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 3
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: LIST
37954: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37955: NOP4
37959: PUSH
37960: LD_INT 1
37962: NEG
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: LD_INT 2
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: LD_INT 1
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37999: NOP4
38003: PUSH
38004: LD_INT 1
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 2
38027: PUSH
38028: LD_INT 1
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38040: NOP4
38044: PUSH
38045: LD_INT 2
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 2
38057: PUSH
38058: LD_INT 2
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: PUSH
38068: LD_INT 2
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: LIST
38079: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38080: NOP4
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: LIST
38120: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38121: NOP4
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 2
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 2
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: LIST
38164: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38165: NOP4
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: NEG
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 2
38200: NEG
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: ST_TO_ADDR
// end ; 2 :
38211: GO 41477
38213: LD_INT 2
38215: DOUBLE
38216: EQUAL
38217: IFTRUE 38221
38219: GO 41476
38221: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38222: NOP4
38226: PUSH
38227: LD_INT 4
38229: PUSH
38230: LD_INT 0
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 4
38239: PUSH
38240: LD_INT 1
38242: NEG
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 5
38250: PUSH
38251: LD_INT 0
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 5
38260: PUSH
38261: LD_INT 1
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 4
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 3
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: PUSH
38291: LD_INT 1
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 3
38301: PUSH
38302: LD_INT 2
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 5
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 3
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 3
38332: PUSH
38333: LD_INT 2
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 4
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 4
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 3
38362: PUSH
38363: LD_INT 4
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 2
38372: PUSH
38373: LD_INT 3
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 2
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 2
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 4
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 4
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: LD_INT 4
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 1
38442: PUSH
38443: LD_INT 5
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 5
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: LD_INT 4
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 1
38473: NEG
38474: PUSH
38475: LD_INT 3
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 5
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: NEG
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: NEG
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 3
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 3
38550: NEG
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 4
38561: NEG
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 4
38572: NEG
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 4
38584: NEG
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 4
38607: NEG
38608: PUSH
38609: LD_INT 4
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 4
38619: NEG
38620: PUSH
38621: LD_INT 5
38623: NEG
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 3
38631: NEG
38632: PUSH
38633: LD_INT 4
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: LD_INT 3
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 4
38655: NEG
38656: PUSH
38657: LD_INT 3
38659: NEG
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 5
38667: NEG
38668: PUSH
38669: LD_INT 4
38671: NEG
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 5
38679: NEG
38680: PUSH
38681: LD_INT 5
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 3
38691: NEG
38692: PUSH
38693: LD_INT 5
38695: NEG
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 5
38703: NEG
38704: PUSH
38705: LD_INT 3
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38760: NOP4
38764: PUSH
38765: LD_INT 4
38767: PUSH
38768: LD_INT 4
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 4
38777: PUSH
38778: LD_INT 3
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 5
38787: PUSH
38788: LD_INT 4
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 5
38797: PUSH
38798: LD_INT 5
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 4
38807: PUSH
38808: LD_INT 5
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 3
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 3
38827: PUSH
38828: LD_INT 3
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 5
38837: PUSH
38838: LD_INT 3
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 3
38847: PUSH
38848: LD_INT 5
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 3
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 3
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: LD_INT 4
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 0
38897: PUSH
38898: LD_INT 4
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: LD_INT 3
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 1
38918: NEG
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: LD_INT 4
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 2
38939: NEG
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 4
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 4
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 3
38973: NEG
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 3
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 4
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 5
39006: NEG
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 5
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: NEG
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 5
39029: NEG
39030: PUSH
39031: LD_INT 2
39033: NEG
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 3
39041: NEG
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 3
39052: NEG
39053: PUSH
39054: LD_INT 3
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 3
39064: NEG
39065: PUSH
39066: LD_INT 4
39068: NEG
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: NEG
39077: PUSH
39078: LD_INT 3
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 2
39088: NEG
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 3
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 4
39112: NEG
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 4
39124: NEG
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: NEG
39137: PUSH
39138: LD_INT 4
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 4
39148: NEG
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: LD_INT 4
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: LD_INT 4
39185: NEG
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 0
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: LD_INT 4
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: LD_INT 5
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 2
39239: PUSH
39240: LD_INT 3
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 2
39250: NEG
39251: PUSH
39252: LD_INT 5
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: LIST
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39307: NOP4
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 4
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 4
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 1
39344: PUSH
39345: LD_INT 5
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: LD_INT 5
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: NEG
39365: PUSH
39366: LD_INT 4
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 3
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 5
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: NEG
39397: PUSH
39398: LD_INT 3
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 3
39407: NEG
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 3
39418: NEG
39419: PUSH
39420: LD_INT 1
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 2
39430: NEG
39431: PUSH
39432: LD_INT 0
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 3
39452: NEG
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 4
39463: NEG
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 4
39474: NEG
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 4
39486: NEG
39487: PUSH
39488: LD_INT 2
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 4
39509: NEG
39510: PUSH
39511: LD_INT 4
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 4
39521: NEG
39522: PUSH
39523: LD_INT 5
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 3
39533: NEG
39534: PUSH
39535: LD_INT 4
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: NEG
39546: PUSH
39547: LD_INT 3
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 4
39557: NEG
39558: PUSH
39559: LD_INT 3
39561: NEG
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 5
39569: NEG
39570: PUSH
39571: LD_INT 4
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 5
39581: NEG
39582: PUSH
39583: LD_INT 5
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 3
39593: NEG
39594: PUSH
39595: LD_INT 5
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 5
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 1
39639: PUSH
39640: LD_INT 3
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: LD_INT 1
39650: PUSH
39651: LD_INT 2
39653: NEG
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: LD_INT 3
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: LD_INT 4
39688: NEG
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 2
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: LD_INT 4
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 4
39719: PUSH
39720: LD_INT 0
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 4
39729: PUSH
39730: LD_INT 1
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: LD_INT 1
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 3
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 3
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 3
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 5
39802: PUSH
39803: LD_INT 2
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39857: NOP4
39861: PUSH
39862: LD_INT 4
39864: NEG
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 4
39875: NEG
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: NEG
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 4
39909: NEG
39910: PUSH
39911: LD_INT 1
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 5
39920: NEG
39921: PUSH
39922: LD_INT 0
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 5
39931: NEG
39932: PUSH
39933: LD_INT 1
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 5
39943: NEG
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 3
39955: NEG
39956: PUSH
39957: LD_INT 2
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: NEG
39967: PUSH
39968: LD_INT 3
39970: NEG
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 3
39978: NEG
39979: PUSH
39980: LD_INT 4
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 2
39990: NEG
39991: PUSH
39992: LD_INT 3
39994: NEG
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 2
40002: NEG
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 3
40014: NEG
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 4
40026: NEG
40027: PUSH
40028: LD_INT 3
40030: NEG
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 4
40038: NEG
40039: PUSH
40040: LD_INT 4
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 2
40050: NEG
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 2
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: LD_INT 4
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: LD_INT 4
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 3
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: LD_INT 5
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 2
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: LD_INT 5
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 3
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 3
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 4
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: PUSH
40208: LD_INT 1
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 2
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 2
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 4
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 4
40269: PUSH
40270: LD_INT 4
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 4
40279: PUSH
40280: LD_INT 3
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 5
40289: PUSH
40290: LD_INT 4
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 5
40299: PUSH
40300: LD_INT 5
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 4
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: PUSH
40320: LD_INT 4
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 3
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 5
40339: PUSH
40340: LD_INT 3
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 3
40349: PUSH
40350: LD_INT 5
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40404: NOP4
40408: PUSH
40409: LD_INT 4
40411: NEG
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 4
40423: NEG
40424: PUSH
40425: LD_INT 5
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 3
40435: NEG
40436: PUSH
40437: LD_INT 4
40439: NEG
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: NEG
40448: PUSH
40449: LD_INT 3
40451: NEG
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 4
40459: NEG
40460: PUSH
40461: LD_INT 3
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 5
40471: NEG
40472: PUSH
40473: LD_INT 4
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 5
40483: NEG
40484: PUSH
40485: LD_INT 5
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: LD_INT 5
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 5
40507: NEG
40508: PUSH
40509: LD_INT 3
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: LD_INT 3
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 4
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 3
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 2
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: LD_INT 2
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 3
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: LD_INT 4
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 2
40598: PUSH
40599: LD_INT 2
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: LD_INT 4
40613: NEG
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 4
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 4
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 5
40642: PUSH
40643: LD_INT 0
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 5
40652: PUSH
40653: LD_INT 1
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: PUSH
40663: LD_INT 1
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 3
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 3
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: LD_INT 2
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 5
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 3
40714: PUSH
40715: LD_INT 3
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: PUSH
40725: LD_INT 2
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 4
40734: PUSH
40735: LD_INT 3
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 4
40744: PUSH
40745: LD_INT 4
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 3
40754: PUSH
40755: LD_INT 4
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 2
40764: PUSH
40765: LD_INT 3
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 2
40774: PUSH
40775: LD_INT 2
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: PUSH
40785: LD_INT 2
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 2
40794: PUSH
40795: LD_INT 4
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 4
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 5
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 5
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: LD_INT 3
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 2
40876: PUSH
40877: LD_INT 5
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 2
40886: NEG
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40942: NOP4
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: LD_INT 4
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 0
40960: PUSH
40961: LD_INT 5
40963: NEG
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: PUSH
40972: LD_INT 4
40974: NEG
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 1
40982: PUSH
40983: LD_INT 3
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: LD_INT 3
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 4
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 1
41016: NEG
41017: PUSH
41018: LD_INT 5
41020: NEG
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 2
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 5
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 4
41072: PUSH
41073: LD_INT 0
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 4
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 3
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: LD_INT 1
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 2
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 4
41134: PUSH
41135: LD_INT 2
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: LD_INT 4
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 4
41154: PUSH
41155: LD_INT 3
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 5
41164: PUSH
41165: LD_INT 4
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 5
41174: PUSH
41175: LD_INT 5
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 4
41184: PUSH
41185: LD_INT 5
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 3
41194: PUSH
41195: LD_INT 4
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 3
41204: PUSH
41205: LD_INT 3
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 5
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: PUSH
41225: LD_INT 5
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: LD_INT 3
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: LD_INT 1
41254: PUSH
41255: LD_INT 3
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 1
41264: PUSH
41265: LD_INT 4
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 0
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 1
41284: NEG
41285: PUSH
41286: LD_INT 3
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 1
41295: NEG
41296: PUSH
41297: LD_INT 2
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 4
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: LD_INT 2
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 4
41327: NEG
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 4
41338: NEG
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 3
41350: NEG
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 3
41361: NEG
41362: PUSH
41363: LD_INT 1
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 4
41372: NEG
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 5
41383: NEG
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 5
41394: NEG
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 5
41406: NEG
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 3
41418: NEG
41419: PUSH
41420: LD_INT 2
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: ST_TO_ADDR
// end ; end ;
41474: GO 41477
41476: POP
// case btype of b_depot , b_warehouse :
41477: NOP4
41481: PUSH
41482: LD_INT 0
41484: DOUBLE
41485: EQUAL
41486: IFTRUE 41496
41488: LD_INT 1
41490: DOUBLE
41491: EQUAL
41492: IFTRUE 41496
41494: GO 41697
41496: POP
// case nation of nation_american :
41497: NOP4
41501: PUSH
41502: LD_INT 1
41504: DOUBLE
41505: EQUAL
41506: IFTRUE 41510
41508: GO 41566
41510: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41511: NOP4
41515: PUSH
41516: NOP4
41520: PUSH
41521: NOP4
41525: PUSH
41526: NOP4
41530: PUSH
41531: NOP4
41535: PUSH
41536: NOP4
41540: PUSH
41541: NOP4
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: PUSH
41554: NOP4
41558: PUSH
41559: LD_INT 1
41561: PLUS
41562: ARRAY
41563: ST_TO_ADDR
41564: GO 41695
41566: LD_INT 2
41568: DOUBLE
41569: EQUAL
41570: IFTRUE 41574
41572: GO 41630
41574: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41575: NOP4
41579: PUSH
41580: NOP4
41584: PUSH
41585: NOP4
41589: PUSH
41590: NOP4
41594: PUSH
41595: NOP4
41599: PUSH
41600: NOP4
41604: PUSH
41605: NOP4
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PUSH
41618: NOP4
41622: PUSH
41623: LD_INT 1
41625: PLUS
41626: ARRAY
41627: ST_TO_ADDR
41628: GO 41695
41630: LD_INT 3
41632: DOUBLE
41633: EQUAL
41634: IFTRUE 41638
41636: GO 41694
41638: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41639: NOP4
41643: PUSH
41644: NOP4
41648: PUSH
41649: NOP4
41653: PUSH
41654: NOP4
41658: PUSH
41659: NOP4
41663: PUSH
41664: NOP4
41668: PUSH
41669: NOP4
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: PUSH
41682: NOP4
41686: PUSH
41687: LD_INT 1
41689: PLUS
41690: ARRAY
41691: ST_TO_ADDR
41692: GO 41695
41694: POP
41695: GO 42250
41697: LD_INT 2
41699: DOUBLE
41700: EQUAL
41701: IFTRUE 41711
41703: LD_INT 3
41705: DOUBLE
41706: EQUAL
41707: IFTRUE 41711
41709: GO 41767
41711: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41712: NOP4
41716: PUSH
41717: NOP4
41721: PUSH
41722: NOP4
41726: PUSH
41727: NOP4
41731: PUSH
41732: NOP4
41736: PUSH
41737: NOP4
41741: PUSH
41742: NOP4
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: PUSH
41755: NOP4
41759: PUSH
41760: LD_INT 1
41762: PLUS
41763: ARRAY
41764: ST_TO_ADDR
41765: GO 42250
41767: LD_INT 16
41769: DOUBLE
41770: EQUAL
41771: IFTRUE 41829
41773: LD_INT 17
41775: DOUBLE
41776: EQUAL
41777: IFTRUE 41829
41779: LD_INT 18
41781: DOUBLE
41782: EQUAL
41783: IFTRUE 41829
41785: LD_INT 19
41787: DOUBLE
41788: EQUAL
41789: IFTRUE 41829
41791: LD_INT 22
41793: DOUBLE
41794: EQUAL
41795: IFTRUE 41829
41797: LD_INT 20
41799: DOUBLE
41800: EQUAL
41801: IFTRUE 41829
41803: LD_INT 21
41805: DOUBLE
41806: EQUAL
41807: IFTRUE 41829
41809: LD_INT 23
41811: DOUBLE
41812: EQUAL
41813: IFTRUE 41829
41815: LD_INT 24
41817: DOUBLE
41818: EQUAL
41819: IFTRUE 41829
41821: LD_INT 25
41823: DOUBLE
41824: EQUAL
41825: IFTRUE 41829
41827: GO 41885
41829: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41830: NOP4
41834: PUSH
41835: NOP4
41839: PUSH
41840: NOP4
41844: PUSH
41845: NOP4
41849: PUSH
41850: NOP4
41854: PUSH
41855: NOP4
41859: PUSH
41860: NOP4
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: LIST
41869: LIST
41870: LIST
41871: LIST
41872: PUSH
41873: NOP4
41877: PUSH
41878: LD_INT 1
41880: PLUS
41881: ARRAY
41882: ST_TO_ADDR
41883: GO 42250
41885: LD_INT 6
41887: DOUBLE
41888: EQUAL
41889: IFTRUE 41941
41891: LD_INT 7
41893: DOUBLE
41894: EQUAL
41895: IFTRUE 41941
41897: LD_INT 8
41899: DOUBLE
41900: EQUAL
41901: IFTRUE 41941
41903: LD_INT 13
41905: DOUBLE
41906: EQUAL
41907: IFTRUE 41941
41909: LD_INT 12
41911: DOUBLE
41912: EQUAL
41913: IFTRUE 41941
41915: LD_INT 15
41917: DOUBLE
41918: EQUAL
41919: IFTRUE 41941
41921: LD_INT 11
41923: DOUBLE
41924: EQUAL
41925: IFTRUE 41941
41927: LD_INT 14
41929: DOUBLE
41930: EQUAL
41931: IFTRUE 41941
41933: LD_INT 10
41935: DOUBLE
41936: EQUAL
41937: IFTRUE 41941
41939: GO 41997
41941: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41942: NOP4
41946: PUSH
41947: NOP4
41951: PUSH
41952: NOP4
41956: PUSH
41957: NOP4
41961: PUSH
41962: NOP4
41966: PUSH
41967: NOP4
41971: PUSH
41972: NOP4
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: NOP4
41989: PUSH
41990: LD_INT 1
41992: PLUS
41993: ARRAY
41994: ST_TO_ADDR
41995: GO 42250
41997: LD_INT 36
41999: DOUBLE
42000: EQUAL
42001: IFTRUE 42005
42003: GO 42061
42005: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42006: NOP4
42010: PUSH
42011: NOP4
42015: PUSH
42016: NOP4
42020: PUSH
42021: NOP4
42025: PUSH
42026: NOP4
42030: PUSH
42031: NOP4
42035: PUSH
42036: NOP4
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: PUSH
42049: NOP4
42053: PUSH
42054: LD_INT 1
42056: PLUS
42057: ARRAY
42058: ST_TO_ADDR
42059: GO 42250
42061: LD_INT 4
42063: DOUBLE
42064: EQUAL
42065: IFTRUE 42087
42067: LD_INT 5
42069: DOUBLE
42070: EQUAL
42071: IFTRUE 42087
42073: LD_INT 34
42075: DOUBLE
42076: EQUAL
42077: IFTRUE 42087
42079: LD_INT 37
42081: DOUBLE
42082: EQUAL
42083: IFTRUE 42087
42085: GO 42143
42087: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42088: NOP4
42092: PUSH
42093: NOP4
42097: PUSH
42098: NOP4
42102: PUSH
42103: NOP4
42107: PUSH
42108: NOP4
42112: PUSH
42113: NOP4
42117: PUSH
42118: NOP4
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: PUSH
42131: NOP4
42135: PUSH
42136: LD_INT 1
42138: PLUS
42139: ARRAY
42140: ST_TO_ADDR
42141: GO 42250
42143: LD_INT 31
42145: DOUBLE
42146: EQUAL
42147: IFTRUE 42193
42149: LD_INT 32
42151: DOUBLE
42152: EQUAL
42153: IFTRUE 42193
42155: LD_INT 33
42157: DOUBLE
42158: EQUAL
42159: IFTRUE 42193
42161: LD_INT 27
42163: DOUBLE
42164: EQUAL
42165: IFTRUE 42193
42167: LD_INT 26
42169: DOUBLE
42170: EQUAL
42171: IFTRUE 42193
42173: LD_INT 28
42175: DOUBLE
42176: EQUAL
42177: IFTRUE 42193
42179: LD_INT 29
42181: DOUBLE
42182: EQUAL
42183: IFTRUE 42193
42185: LD_INT 30
42187: DOUBLE
42188: EQUAL
42189: IFTRUE 42193
42191: GO 42249
42193: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42194: NOP4
42198: PUSH
42199: NOP4
42203: PUSH
42204: NOP4
42208: PUSH
42209: NOP4
42213: PUSH
42214: NOP4
42218: PUSH
42219: NOP4
42223: PUSH
42224: NOP4
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: PUSH
42237: NOP4
42241: PUSH
42242: LD_INT 1
42244: PLUS
42245: ARRAY
42246: ST_TO_ADDR
42247: GO 42250
42249: POP
// temp_list2 = [ ] ;
42250: NOP4
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// for i in temp_list do
42257: NOP4
42261: PUSH
42262: NOP4
42266: PUSH
42267: FOR_IN
42268: IFFALSE 42320
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42270: NOP4
42274: PUSH
42275: NOP4
42279: PUSH
42280: NOP4
42284: PUSH
42285: LD_INT 1
42287: ARRAY
42288: PUSH
42289: NOP4
42293: PLUS
42294: PUSH
42295: NOP4
42299: PUSH
42300: LD_INT 2
42302: ARRAY
42303: PUSH
42304: NOP4
42308: PLUS
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: ADD
42317: ST_TO_ADDR
42318: GO 42267
42320: POP
42321: POP
// result = temp_list2 ;
42322: NOP4
42326: PUSH
42327: NOP4
42331: ST_TO_ADDR
// end ;
42332: LD_VAR 0 7
42336: RET
// export function EnemyInRange ( unit , dist ) ; begin
42337: LD_INT 0
42339: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42340: NOP4
42344: PUSH
42345: NOP4
42349: PPUSH
42350: NOP4
42354: PPUSH
42355: NOP4
42359: PPUSH
42360: NOP4
42364: PPUSH
42365: NOP4
42369: PPUSH
42370: NOP4
42374: PPUSH
42375: NOP4
42379: PPUSH
42380: NOP4
42384: PUSH
42385: LD_INT 4
42387: ARRAY
42388: ST_TO_ADDR
// end ;
42389: LD_VAR 0 3
42393: RET
// export function PlayerSeeMe ( unit ) ; begin
42394: LD_INT 0
42396: PPUSH
// result := See ( your_side , unit ) ;
42397: NOP4
42401: PUSH
42402: NOP4
42406: PPUSH
42407: NOP4
42411: PPUSH
42412: NOP4
42416: ST_TO_ADDR
// end ;
42417: LD_VAR 0 2
42421: RET
// export function ReverseDir ( unit ) ; begin
42422: LD_INT 0
42424: PPUSH
// if not unit then
42425: NOP4
42429: NOT
42430: IFFALSE 42434
// exit ;
42432: GO 42457
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42434: NOP4
42438: PUSH
42439: NOP4
42443: PPUSH
42444: NOP4
42448: PUSH
42449: LD_INT 3
42451: PLUS
42452: PUSH
42453: LD_INT 6
42455: MOD
42456: ST_TO_ADDR
// end ;
42457: LD_VAR 0 2
42461: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42462: LD_INT 0
42464: PPUSH
42465: PPUSH
42466: PPUSH
42467: PPUSH
42468: PPUSH
// if not hexes then
42469: NOP4
42473: NOT
42474: IFFALSE 42478
// exit ;
42476: GO 42626
// dist := 9999 ;
42478: NOP4
42482: PUSH
42483: LD_INT 9999
42485: ST_TO_ADDR
// for i = 1 to hexes do
42486: NOP4
42490: PUSH
42491: DOUBLE
42492: LD_INT 1
42494: DEC
42495: ST_TO_ADDR
42496: NOP4
42500: PUSH
42501: FOR_TO
42502: IFFALSE 42614
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42504: NOP4
42508: PPUSH
42509: NOP4
42513: PUSH
42514: NOP4
42518: ARRAY
42519: PUSH
42520: LD_INT 1
42522: ARRAY
42523: PPUSH
42524: NOP4
42528: PUSH
42529: NOP4
42533: ARRAY
42534: PUSH
42535: LD_INT 2
42537: ARRAY
42538: PPUSH
42539: NOP4
42543: PUSH
42544: NOP4
42548: LESS
42549: IFFALSE 42612
// begin hex := hexes [ i ] ;
42551: NOP4
42555: PUSH
42556: NOP4
42560: PUSH
42561: NOP4
42565: ARRAY
42566: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42567: NOP4
42571: PUSH
42572: NOP4
42576: PPUSH
42577: NOP4
42581: PUSH
42582: NOP4
42586: ARRAY
42587: PUSH
42588: LD_INT 1
42590: ARRAY
42591: PPUSH
42592: NOP4
42596: PUSH
42597: NOP4
42601: ARRAY
42602: PUSH
42603: LD_INT 2
42605: ARRAY
42606: PPUSH
42607: NOP4
42611: ST_TO_ADDR
// end ; end ;
42612: GO 42501
42614: POP
42615: POP
// result := hex ;
42616: NOP4
42620: PUSH
42621: NOP4
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42631: LD_INT 0
42633: PPUSH
42634: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42635: NOP4
42639: NOT
42640: PUSH
42641: NOP4
42645: PUSH
42646: LD_INT 21
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 23
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PPUSH
42670: NOP4
42674: IN
42675: NOT
42676: OR
42677: IFFALSE 42681
// exit ;
42679: GO 42728
// for i = 1 to 3 do
42681: NOP4
42685: PUSH
42686: DOUBLE
42687: LD_INT 1
42689: DEC
42690: ST_TO_ADDR
42691: LD_INT 3
42693: PUSH
42694: FOR_TO
42695: IFFALSE 42726
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42697: NOP4
42701: PPUSH
42702: NOP4
42706: PPUSH
42707: NOP4
42711: PPUSH
42712: NOP4
42716: PPUSH
42717: LD_INT 1
42719: PPUSH
42720: NOP4
42724: GO 42694
42726: POP
42727: POP
// end ;
42728: LD_VAR 0 2
42732: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42733: LD_INT 0
42735: PPUSH
42736: PPUSH
42737: PPUSH
42738: PPUSH
42739: PPUSH
42740: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42741: NOP4
42745: NOT
42746: PUSH
42747: NOP4
42751: NOT
42752: OR
42753: PUSH
42754: NOP4
42758: PPUSH
42759: NOP4
42763: OR
42764: IFFALSE 42768
// exit ;
42766: GO 43209
// x := GetX ( enemy_unit ) ;
42768: NOP4
42772: PUSH
42773: NOP4
42777: PPUSH
42778: NOP4
42782: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42783: NOP4
42787: PUSH
42788: NOP4
42792: PPUSH
42793: NOP4
42797: ST_TO_ADDR
// if not x or not y then
42798: NOP4
42802: NOT
42803: PUSH
42804: NOP4
42808: NOT
42809: OR
42810: IFFALSE 42814
// exit ;
42812: GO 43209
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42814: NOP4
42818: PUSH
42819: NOP4
42823: PPUSH
42824: LD_INT 0
42826: PPUSH
42827: LD_INT 4
42829: PPUSH
42830: NOP4
42834: PUSH
42835: NOP4
42839: PPUSH
42840: LD_INT 0
42842: PPUSH
42843: LD_INT 4
42845: PPUSH
42846: NOP4
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: NOP4
42859: PPUSH
42860: LD_INT 1
42862: PPUSH
42863: LD_INT 4
42865: PPUSH
42866: NOP4
42870: PUSH
42871: NOP4
42875: PPUSH
42876: LD_INT 1
42878: PPUSH
42879: LD_INT 4
42881: PPUSH
42882: NOP4
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: NOP4
42895: PPUSH
42896: LD_INT 2
42898: PPUSH
42899: LD_INT 4
42901: PPUSH
42902: NOP4
42906: PUSH
42907: NOP4
42911: PPUSH
42912: LD_INT 2
42914: PPUSH
42915: LD_INT 4
42917: PPUSH
42918: NOP4
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: NOP4
42931: PPUSH
42932: LD_INT 3
42934: PPUSH
42935: LD_INT 4
42937: PPUSH
42938: NOP4
42942: PUSH
42943: NOP4
42947: PPUSH
42948: LD_INT 3
42950: PPUSH
42951: LD_INT 4
42953: PPUSH
42954: NOP4
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: NOP4
42967: PPUSH
42968: LD_INT 4
42970: PPUSH
42971: LD_INT 4
42973: PPUSH
42974: NOP4
42978: PUSH
42979: NOP4
42983: PPUSH
42984: LD_INT 4
42986: PPUSH
42987: LD_INT 4
42989: PPUSH
42990: NOP4
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: NOP4
43003: PPUSH
43004: LD_INT 5
43006: PPUSH
43007: LD_INT 4
43009: PPUSH
43010: NOP4
43014: PUSH
43015: NOP4
43019: PPUSH
43020: LD_INT 5
43022: PPUSH
43023: LD_INT 4
43025: PPUSH
43026: NOP4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: ST_TO_ADDR
// for i = tmp downto 1 do
43043: NOP4
43047: PUSH
43048: DOUBLE
43049: NOP4
43053: INC
43054: ST_TO_ADDR
43055: LD_INT 1
43057: PUSH
43058: FOR_DOWNTO
43059: IFFALSE 43160
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43061: NOP4
43065: PUSH
43066: NOP4
43070: ARRAY
43071: PUSH
43072: LD_INT 1
43074: ARRAY
43075: PPUSH
43076: NOP4
43080: PUSH
43081: NOP4
43085: ARRAY
43086: PUSH
43087: LD_INT 2
43089: ARRAY
43090: PPUSH
43091: NOP4
43095: NOT
43096: PUSH
43097: NOP4
43101: PUSH
43102: NOP4
43106: ARRAY
43107: PUSH
43108: LD_INT 1
43110: ARRAY
43111: PPUSH
43112: NOP4
43116: PUSH
43117: NOP4
43121: ARRAY
43122: PUSH
43123: LD_INT 2
43125: ARRAY
43126: PPUSH
43127: NOP4
43131: PUSH
43132: LD_INT 0
43134: NONEQUAL
43135: OR
43136: IFFALSE 43158
// tmp := Delete ( tmp , i ) ;
43138: NOP4
43142: PUSH
43143: NOP4
43147: PPUSH
43148: NOP4
43152: PPUSH
43153: NOP4
43157: ST_TO_ADDR
43158: GO 43058
43160: POP
43161: POP
// j := GetClosestHex ( unit , tmp ) ;
43162: NOP4
43166: PUSH
43167: NOP4
43171: PPUSH
43172: NOP4
43176: PPUSH
43177: NOP4
43181: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43182: NOP4
43186: PPUSH
43187: NOP4
43191: PUSH
43192: LD_INT 1
43194: ARRAY
43195: PPUSH
43196: NOP4
43200: PUSH
43201: LD_INT 2
43203: ARRAY
43204: PPUSH
43205: NOP4
// end ;
43209: LD_VAR 0 3
43213: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43214: LD_INT 0
43216: PPUSH
43217: PPUSH
43218: PPUSH
// uc_side = 0 ;
43219: LD_ADDR_OWVAR 20
43223: PUSH
43224: LD_INT 0
43226: ST_TO_ADDR
// uc_nation = 0 ;
43227: LD_ADDR_OWVAR 21
43231: PUSH
43232: LD_INT 0
43234: ST_TO_ADDR
// InitHc_All ( ) ;
43235: NOP4
// InitVc ;
43239: NOP4
// if mastodonts then
43243: NOP4
43247: IFFALSE 43314
// for i = 1 to mastodonts do
43249: NOP4
43253: PUSH
43254: DOUBLE
43255: LD_INT 1
43257: DEC
43258: ST_TO_ADDR
43259: NOP4
43263: PUSH
43264: FOR_TO
43265: IFFALSE 43312
// begin vc_chassis := 31 ;
43267: LD_ADDR_OWVAR 37
43271: PUSH
43272: LD_INT 31
43274: ST_TO_ADDR
// vc_control := control_rider ;
43275: LD_ADDR_OWVAR 38
43279: PUSH
43280: LD_INT 4
43282: ST_TO_ADDR
// animal := CreateVehicle ;
43283: NOP4
43287: PUSH
43288: NOP4
43292: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43293: NOP4
43297: PPUSH
43298: NOP4
43302: PPUSH
43303: LD_INT 0
43305: PPUSH
43306: NOP4
// end ;
43310: GO 43264
43312: POP
43313: POP
// if horses then
43314: NOP4
43318: IFFALSE 43385
// for i = 1 to horses do
43320: NOP4
43324: PUSH
43325: DOUBLE
43326: LD_INT 1
43328: DEC
43329: ST_TO_ADDR
43330: NOP4
43334: PUSH
43335: FOR_TO
43336: IFFALSE 43383
// begin hc_class := 21 ;
43338: LD_ADDR_OWVAR 28
43342: PUSH
43343: LD_INT 21
43345: ST_TO_ADDR
// hc_gallery :=  ;
43346: LD_ADDR_OWVAR 33
43350: PUSH
43351: LD_STRING 
43353: ST_TO_ADDR
// animal := CreateHuman ;
43354: NOP4
43358: PUSH
43359: NOP4
43363: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43364: NOP4
43368: PPUSH
43369: NOP4
43373: PPUSH
43374: LD_INT 0
43376: PPUSH
43377: NOP4
// end ;
43381: GO 43335
43383: POP
43384: POP
// if birds then
43385: NOP4
43389: IFFALSE 43456
// for i = 1 to birds do
43391: NOP4
43395: PUSH
43396: DOUBLE
43397: LD_INT 1
43399: DEC
43400: ST_TO_ADDR
43401: NOP4
43405: PUSH
43406: FOR_TO
43407: IFFALSE 43454
// begin hc_class = 18 ;
43409: LD_ADDR_OWVAR 28
43413: PUSH
43414: LD_INT 18
43416: ST_TO_ADDR
// hc_gallery =  ;
43417: LD_ADDR_OWVAR 33
43421: PUSH
43422: LD_STRING 
43424: ST_TO_ADDR
// animal := CreateHuman ;
43425: NOP4
43429: PUSH
43430: NOP4
43434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43435: NOP4
43439: PPUSH
43440: NOP4
43444: PPUSH
43445: LD_INT 0
43447: PPUSH
43448: NOP4
// end ;
43452: GO 43406
43454: POP
43455: POP
// if tigers then
43456: NOP4
43460: IFFALSE 43544
// for i = 1 to tigers do
43462: NOP4
43466: PUSH
43467: DOUBLE
43468: LD_INT 1
43470: DEC
43471: ST_TO_ADDR
43472: NOP4
43476: PUSH
43477: FOR_TO
43478: IFFALSE 43542
// begin hc_class = class_tiger ;
43480: LD_ADDR_OWVAR 28
43484: PUSH
43485: LD_INT 14
43487: ST_TO_ADDR
// hc_gallery =  ;
43488: LD_ADDR_OWVAR 33
43492: PUSH
43493: LD_STRING 
43495: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43496: LD_ADDR_OWVAR 35
43500: PUSH
43501: LD_INT 7
43503: NEG
43504: PPUSH
43505: LD_INT 7
43507: PPUSH
43508: NOP4
43512: ST_TO_ADDR
// animal := CreateHuman ;
43513: NOP4
43517: PUSH
43518: NOP4
43522: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43523: NOP4
43527: PPUSH
43528: NOP4
43532: PPUSH
43533: LD_INT 0
43535: PPUSH
43536: NOP4
// end ;
43540: GO 43477
43542: POP
43543: POP
// if apemans then
43544: NOP4
43548: IFFALSE 43671
// for i = 1 to apemans do
43550: NOP4
43554: PUSH
43555: DOUBLE
43556: LD_INT 1
43558: DEC
43559: ST_TO_ADDR
43560: NOP4
43564: PUSH
43565: FOR_TO
43566: IFFALSE 43669
// begin hc_class = class_apeman ;
43568: LD_ADDR_OWVAR 28
43572: PUSH
43573: LD_INT 12
43575: ST_TO_ADDR
// hc_gallery =  ;
43576: LD_ADDR_OWVAR 33
43580: PUSH
43581: LD_STRING 
43583: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
43584: LD_ADDR_OWVAR 35
43588: PUSH
43589: LD_INT 2
43591: NEG
43592: PPUSH
43593: LD_INT 2
43595: PPUSH
43596: NOP4
43600: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43601: LD_ADDR_OWVAR 31
43605: PUSH
43606: LD_INT 1
43608: PPUSH
43609: LD_INT 3
43611: PPUSH
43612: NOP4
43616: PUSH
43617: LD_INT 1
43619: PPUSH
43620: LD_INT 3
43622: PPUSH
43623: NOP4
43627: PUSH
43628: LD_INT 0
43630: PUSH
43631: LD_INT 0
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: ST_TO_ADDR
// animal := CreateHuman ;
43640: NOP4
43644: PUSH
43645: NOP4
43649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43650: NOP4
43654: PPUSH
43655: NOP4
43659: PPUSH
43660: LD_INT 0
43662: PPUSH
43663: NOP4
// end ;
43667: GO 43565
43669: POP
43670: POP
// if enchidnas then
43671: NOP4
43675: IFFALSE 43742
// for i = 1 to enchidnas do
43677: NOP4
43681: PUSH
43682: DOUBLE
43683: LD_INT 1
43685: DEC
43686: ST_TO_ADDR
43687: NOP4
43691: PUSH
43692: FOR_TO
43693: IFFALSE 43740
// begin hc_class = 13 ;
43695: LD_ADDR_OWVAR 28
43699: PUSH
43700: LD_INT 13
43702: ST_TO_ADDR
// hc_gallery =  ;
43703: LD_ADDR_OWVAR 33
43707: PUSH
43708: LD_STRING 
43710: ST_TO_ADDR
// animal := CreateHuman ;
43711: NOP4
43715: PUSH
43716: NOP4
43720: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43721: NOP4
43725: PPUSH
43726: NOP4
43730: PPUSH
43731: LD_INT 0
43733: PPUSH
43734: NOP4
// end ;
43738: GO 43692
43740: POP
43741: POP
// if fishes then
43742: NOP4
43746: IFFALSE 43813
// for i = 1 to fishes do
43748: NOP4
43752: PUSH
43753: DOUBLE
43754: LD_INT 1
43756: DEC
43757: ST_TO_ADDR
43758: NOP4
43762: PUSH
43763: FOR_TO
43764: IFFALSE 43811
// begin hc_class = 20 ;
43766: LD_ADDR_OWVAR 28
43770: PUSH
43771: LD_INT 20
43773: ST_TO_ADDR
// hc_gallery =  ;
43774: LD_ADDR_OWVAR 33
43778: PUSH
43779: LD_STRING 
43781: ST_TO_ADDR
// animal := CreateHuman ;
43782: NOP4
43786: PUSH
43787: NOP4
43791: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43792: NOP4
43796: PPUSH
43797: NOP4
43801: PPUSH
43802: LD_INT 0
43804: PPUSH
43805: NOP4
// end ;
43809: GO 43763
43811: POP
43812: POP
// end ;
43813: LD_VAR 0 10
43817: RET
// export function WantHeal ( sci , unit ) ; begin
43818: LD_INT 0
43820: PPUSH
// if GetTaskList ( sci ) > 0 then
43821: NOP4
43825: PPUSH
43826: NOP4
43830: PUSH
43831: LD_INT 0
43833: GREATER
43834: IFFALSE 43904
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43836: NOP4
43840: PPUSH
43841: NOP4
43845: PUSH
43846: LD_INT 1
43848: ARRAY
43849: PUSH
43850: LD_INT 1
43852: ARRAY
43853: PUSH
43854: LD_STRING l
43856: EQUAL
43857: PUSH
43858: NOP4
43862: PPUSH
43863: NOP4
43867: PUSH
43868: LD_INT 1
43870: ARRAY
43871: PUSH
43872: LD_INT 4
43874: ARRAY
43875: PUSH
43876: NOP4
43880: EQUAL
43881: AND
43882: IFFALSE 43894
// result := true else
43884: NOP4
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
43892: GO 43902
// result := false ;
43894: NOP4
43898: PUSH
43899: LD_INT 0
43901: ST_TO_ADDR
// end else
43902: GO 43912
// result := false ;
43904: NOP4
43908: PUSH
43909: LD_INT 0
43911: ST_TO_ADDR
// end ;
43912: LD_VAR 0 3
43916: RET
// export function HealTarget ( sci ) ; begin
43917: LD_INT 0
43919: PPUSH
// if not sci then
43920: NOP4
43924: NOT
43925: IFFALSE 43929
// exit ;
43927: GO 43994
// result := 0 ;
43929: NOP4
43933: PUSH
43934: LD_INT 0
43936: ST_TO_ADDR
// if GetTaskList ( sci ) then
43937: NOP4
43941: PPUSH
43942: NOP4
43946: IFFALSE 43994
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43948: NOP4
43952: PPUSH
43953: NOP4
43957: PUSH
43958: LD_INT 1
43960: ARRAY
43961: PUSH
43962: LD_INT 1
43964: ARRAY
43965: PUSH
43966: LD_STRING l
43968: EQUAL
43969: IFFALSE 43994
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43971: NOP4
43975: PUSH
43976: NOP4
43980: PPUSH
43981: NOP4
43985: PUSH
43986: LD_INT 1
43988: ARRAY
43989: PUSH
43990: LD_INT 4
43992: ARRAY
43993: ST_TO_ADDR
// end ;
43994: LD_VAR 0 2
43998: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43999: LD_INT 0
44001: PPUSH
44002: PPUSH
44003: PPUSH
44004: PPUSH
// if not base_units then
44005: NOP4
44009: NOT
44010: IFFALSE 44014
// exit ;
44012: GO 44101
// result := false ;
44014: NOP4
44018: PUSH
44019: LD_INT 0
44021: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44022: NOP4
44026: PUSH
44027: NOP4
44031: PPUSH
44032: LD_INT 21
44034: PUSH
44035: LD_INT 3
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PPUSH
44042: NOP4
44046: ST_TO_ADDR
// if not tmp then
44047: NOP4
44051: NOT
44052: IFFALSE 44056
// exit ;
44054: GO 44101
// for i in tmp do
44056: NOP4
44060: PUSH
44061: NOP4
44065: PUSH
44066: FOR_IN
44067: IFFALSE 44099
// begin result := EnemyInRange ( i , 22 ) ;
44069: NOP4
44073: PUSH
44074: NOP4
44078: PPUSH
44079: LD_INT 22
44081: PPUSH
44082: NOP4
44086: ST_TO_ADDR
// if result then
44087: NOP4
44091: IFFALSE 44097
// exit ;
44093: POP
44094: POP
44095: GO 44101
// end ;
44097: GO 44066
44099: POP
44100: POP
// end ;
44101: LD_VAR 0 2
44105: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
44106: LD_INT 0
44108: PPUSH
44109: PPUSH
// if not units then
44110: NOP4
44114: NOT
44115: IFFALSE 44119
// exit ;
44117: GO 44189
// result := [ ] ;
44119: NOP4
44123: PUSH
44124: EMPTY
44125: ST_TO_ADDR
// for i in units do
44126: NOP4
44130: PUSH
44131: NOP4
44135: PUSH
44136: FOR_IN
44137: IFFALSE 44187
// if GetTag ( i ) = tag then
44139: NOP4
44143: PPUSH
44144: NOP4
44148: PUSH
44149: NOP4
44153: EQUAL
44154: IFFALSE 44185
// result := Replace ( result , result + 1 , i ) ;
44156: NOP4
44160: PUSH
44161: NOP4
44165: PPUSH
44166: NOP4
44170: PUSH
44171: LD_INT 1
44173: PLUS
44174: PPUSH
44175: NOP4
44179: PPUSH
44180: NOP4
44184: ST_TO_ADDR
44185: GO 44136
44187: POP
44188: POP
// end ;
44189: LD_VAR 0 3
44193: RET
// export function IsDriver ( un ) ; begin
44194: LD_INT 0
44196: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44197: NOP4
44201: PUSH
44202: NOP4
44206: PUSH
44207: LD_INT 55
44209: PUSH
44210: EMPTY
44211: LIST
44212: PPUSH
44213: NOP4
44217: IN
44218: ST_TO_ADDR
// end ;
44219: LD_VAR 0 2
44223: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44224: LD_INT 0
44226: PPUSH
44227: PPUSH
// list := [ ] ;
44228: NOP4
44232: PUSH
44233: EMPTY
44234: ST_TO_ADDR
// case d of 0 :
44235: NOP4
44239: PUSH
44240: LD_INT 0
44242: DOUBLE
44243: EQUAL
44244: IFTRUE 44248
44246: GO 44381
44248: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44249: NOP4
44253: PUSH
44254: NOP4
44258: PUSH
44259: LD_INT 4
44261: MINUS
44262: PUSH
44263: NOP4
44267: PUSH
44268: LD_INT 4
44270: MINUS
44271: PUSH
44272: LD_INT 2
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: LIST
44279: PUSH
44280: NOP4
44284: PUSH
44285: LD_INT 3
44287: MINUS
44288: PUSH
44289: NOP4
44293: PUSH
44294: LD_INT 1
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: LIST
44301: PUSH
44302: NOP4
44306: PUSH
44307: LD_INT 4
44309: PLUS
44310: PUSH
44311: NOP4
44315: PUSH
44316: LD_INT 4
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: PUSH
44324: NOP4
44328: PUSH
44329: LD_INT 3
44331: PLUS
44332: PUSH
44333: NOP4
44337: PUSH
44338: LD_INT 3
44340: PLUS
44341: PUSH
44342: LD_INT 5
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: LIST
44349: PUSH
44350: NOP4
44354: PUSH
44355: NOP4
44359: PUSH
44360: LD_INT 4
44362: PLUS
44363: PUSH
44364: LD_INT 0
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: LIST
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: ST_TO_ADDR
// end ; 1 :
44379: GO 45079
44381: LD_INT 1
44383: DOUBLE
44384: EQUAL
44385: IFTRUE 44389
44387: GO 44522
44389: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44390: NOP4
44394: PUSH
44395: NOP4
44399: PUSH
44400: NOP4
44404: PUSH
44405: LD_INT 4
44407: MINUS
44408: PUSH
44409: LD_INT 3
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: LIST
44416: PUSH
44417: NOP4
44421: PUSH
44422: LD_INT 3
44424: MINUS
44425: PUSH
44426: NOP4
44430: PUSH
44431: LD_INT 3
44433: MINUS
44434: PUSH
44435: LD_INT 2
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: LIST
44442: PUSH
44443: NOP4
44447: PUSH
44448: LD_INT 4
44450: MINUS
44451: PUSH
44452: NOP4
44456: PUSH
44457: LD_INT 1
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: LIST
44464: PUSH
44465: NOP4
44469: PUSH
44470: NOP4
44474: PUSH
44475: LD_INT 3
44477: PLUS
44478: PUSH
44479: LD_INT 0
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: LIST
44486: PUSH
44487: NOP4
44491: PUSH
44492: LD_INT 4
44494: PLUS
44495: PUSH
44496: NOP4
44500: PUSH
44501: LD_INT 4
44503: PLUS
44504: PUSH
44505: LD_INT 5
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: LIST
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: ST_TO_ADDR
// end ; 2 :
44520: GO 45079
44522: LD_INT 2
44524: DOUBLE
44525: EQUAL
44526: IFTRUE 44530
44528: GO 44659
44530: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44531: NOP4
44535: PUSH
44536: NOP4
44540: PUSH
44541: NOP4
44545: PUSH
44546: LD_INT 3
44548: MINUS
44549: PUSH
44550: LD_INT 3
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: LIST
44557: PUSH
44558: NOP4
44562: PUSH
44563: LD_INT 4
44565: PLUS
44566: PUSH
44567: NOP4
44571: PUSH
44572: LD_INT 4
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: LIST
44579: PUSH
44580: NOP4
44584: PUSH
44585: NOP4
44589: PUSH
44590: LD_INT 4
44592: PLUS
44593: PUSH
44594: LD_INT 0
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: LIST
44601: PUSH
44602: NOP4
44606: PUSH
44607: LD_INT 3
44609: MINUS
44610: PUSH
44611: NOP4
44615: PUSH
44616: LD_INT 1
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: LIST
44623: PUSH
44624: NOP4
44628: PUSH
44629: LD_INT 4
44631: MINUS
44632: PUSH
44633: NOP4
44637: PUSH
44638: LD_INT 4
44640: MINUS
44641: PUSH
44642: LD_INT 2
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: LIST
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: ST_TO_ADDR
// end ; 3 :
44657: GO 45079
44659: LD_INT 3
44661: DOUBLE
44662: EQUAL
44663: IFTRUE 44667
44665: GO 44800
44667: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44668: NOP4
44672: PUSH
44673: NOP4
44677: PUSH
44678: LD_INT 3
44680: PLUS
44681: PUSH
44682: NOP4
44686: PUSH
44687: LD_INT 4
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: LIST
44694: PUSH
44695: NOP4
44699: PUSH
44700: LD_INT 4
44702: PLUS
44703: PUSH
44704: NOP4
44708: PUSH
44709: LD_INT 4
44711: PLUS
44712: PUSH
44713: LD_INT 5
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: LIST
44720: PUSH
44721: NOP4
44725: PUSH
44726: LD_INT 4
44728: MINUS
44729: PUSH
44730: NOP4
44734: PUSH
44735: LD_INT 1
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: LIST
44742: PUSH
44743: NOP4
44747: PUSH
44748: NOP4
44752: PUSH
44753: LD_INT 4
44755: MINUS
44756: PUSH
44757: LD_INT 3
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: LIST
44764: PUSH
44765: NOP4
44769: PUSH
44770: LD_INT 3
44772: MINUS
44773: PUSH
44774: NOP4
44778: PUSH
44779: LD_INT 3
44781: MINUS
44782: PUSH
44783: LD_INT 2
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: LIST
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: ST_TO_ADDR
// end ; 4 :
44798: GO 45079
44800: LD_INT 4
44802: DOUBLE
44803: EQUAL
44804: IFTRUE 44808
44806: GO 44941
44808: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44809: NOP4
44813: PUSH
44814: NOP4
44818: PUSH
44819: NOP4
44823: PUSH
44824: LD_INT 4
44826: PLUS
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: LIST
44835: PUSH
44836: NOP4
44840: PUSH
44841: LD_INT 3
44843: PLUS
44844: PUSH
44845: NOP4
44849: PUSH
44850: LD_INT 3
44852: PLUS
44853: PUSH
44854: LD_INT 5
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: LIST
44861: PUSH
44862: NOP4
44866: PUSH
44867: LD_INT 4
44869: PLUS
44870: PUSH
44871: NOP4
44875: PUSH
44876: LD_INT 4
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: LIST
44883: PUSH
44884: NOP4
44888: PUSH
44889: NOP4
44893: PUSH
44894: LD_INT 3
44896: MINUS
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: PUSH
44906: NOP4
44910: PUSH
44911: LD_INT 4
44913: MINUS
44914: PUSH
44915: NOP4
44919: PUSH
44920: LD_INT 4
44922: MINUS
44923: PUSH
44924: LD_INT 2
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: LIST
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: ST_TO_ADDR
// end ; 5 :
44939: GO 45079
44941: LD_INT 5
44943: DOUBLE
44944: EQUAL
44945: IFTRUE 44949
44947: GO 45078
44949: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44950: NOP4
44954: PUSH
44955: NOP4
44959: PUSH
44960: LD_INT 4
44962: MINUS
44963: PUSH
44964: NOP4
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: LIST
44976: PUSH
44977: NOP4
44981: PUSH
44982: NOP4
44986: PUSH
44987: LD_INT 4
44989: MINUS
44990: PUSH
44991: LD_INT 3
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: LIST
44998: PUSH
44999: NOP4
45003: PUSH
45004: LD_INT 4
45006: PLUS
45007: PUSH
45008: NOP4
45012: PUSH
45013: LD_INT 4
45015: PLUS
45016: PUSH
45017: LD_INT 5
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: LIST
45024: PUSH
45025: NOP4
45029: PUSH
45030: LD_INT 3
45032: PLUS
45033: PUSH
45034: NOP4
45038: PUSH
45039: LD_INT 4
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: LIST
45046: PUSH
45047: NOP4
45051: PUSH
45052: NOP4
45056: PUSH
45057: LD_INT 3
45059: PLUS
45060: PUSH
45061: LD_INT 0
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: ST_TO_ADDR
// end ; end ;
45076: GO 45079
45078: POP
// result := list ;
45079: NOP4
45083: PUSH
45084: NOP4
45088: ST_TO_ADDR
// end ;
45089: LD_VAR 0 4
45093: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45094: LD_INT 0
45096: PPUSH
45097: PPUSH
45098: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45099: NOP4
45103: NOT
45104: PUSH
45105: NOP4
45109: PUSH
45110: LD_INT 1
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 3
45118: PUSH
45119: LD_INT 4
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: IN
45128: NOT
45129: OR
45130: IFFALSE 45134
// exit ;
45132: GO 45226
// tmp := [ ] ;
45134: NOP4
45138: PUSH
45139: EMPTY
45140: ST_TO_ADDR
// for i in units do
45141: NOP4
45145: PUSH
45146: NOP4
45150: PUSH
45151: FOR_IN
45152: IFFALSE 45195
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45154: NOP4
45158: PUSH
45159: NOP4
45163: PPUSH
45164: NOP4
45168: PUSH
45169: LD_INT 1
45171: PLUS
45172: PPUSH
45173: NOP4
45177: PPUSH
45178: NOP4
45182: PPUSH
45183: NOP4
45187: PPUSH
45188: NOP4
45192: ST_TO_ADDR
45193: GO 45151
45195: POP
45196: POP
// if not tmp then
45197: NOP4
45201: NOT
45202: IFFALSE 45206
// exit ;
45204: GO 45226
// result := SortListByListDesc ( units , tmp ) ;
45206: NOP4
45210: PUSH
45211: NOP4
45215: PPUSH
45216: NOP4
45220: PPUSH
45221: NOP4
45225: ST_TO_ADDR
// end ;
45226: LD_VAR 0 3
45230: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45231: LD_INT 0
45233: PPUSH
45234: PPUSH
45235: PPUSH
// result := false ;
45236: NOP4
45240: PUSH
45241: LD_INT 0
45243: ST_TO_ADDR
// x := GetX ( building ) ;
45244: NOP4
45248: PUSH
45249: NOP4
45253: PPUSH
45254: NOP4
45258: ST_TO_ADDR
// y := GetY ( building ) ;
45259: NOP4
45263: PUSH
45264: NOP4
45268: PPUSH
45269: NOP4
45273: ST_TO_ADDR
// if not building or not x or not y then
45274: NOP4
45278: NOT
45279: PUSH
45280: NOP4
45284: NOT
45285: OR
45286: PUSH
45287: NOP4
45291: NOT
45292: OR
45293: IFFALSE 45297
// exit ;
45295: GO 45389
// if GetTaskList ( unit ) then
45297: NOP4
45301: PPUSH
45302: NOP4
45306: IFFALSE 45389
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45308: LD_STRING e
45310: PUSH
45311: NOP4
45315: PPUSH
45316: NOP4
45320: PUSH
45321: LD_INT 1
45323: ARRAY
45324: PUSH
45325: LD_INT 1
45327: ARRAY
45328: EQUAL
45329: PUSH
45330: NOP4
45334: PUSH
45335: NOP4
45339: PPUSH
45340: NOP4
45344: PUSH
45345: LD_INT 1
45347: ARRAY
45348: PUSH
45349: LD_INT 2
45351: ARRAY
45352: EQUAL
45353: AND
45354: PUSH
45355: NOP4
45359: PUSH
45360: NOP4
45364: PPUSH
45365: NOP4
45369: PUSH
45370: LD_INT 1
45372: ARRAY
45373: PUSH
45374: LD_INT 3
45376: ARRAY
45377: EQUAL
45378: AND
45379: IFFALSE 45389
// result := true end ;
45381: NOP4
45385: PUSH
45386: LD_INT 1
45388: ST_TO_ADDR
// end ;
45389: LD_VAR 0 3
45393: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45394: LD_INT 0
45396: PPUSH
// result := false ;
45397: NOP4
45401: PUSH
45402: LD_INT 0
45404: ST_TO_ADDR
// if GetTaskList ( unit ) then
45405: NOP4
45409: PPUSH
45410: NOP4
45414: IFFALSE 45497
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45416: LD_STRING M
45418: PUSH
45419: NOP4
45423: PPUSH
45424: NOP4
45428: PUSH
45429: LD_INT 1
45431: ARRAY
45432: PUSH
45433: LD_INT 1
45435: ARRAY
45436: EQUAL
45437: PUSH
45438: NOP4
45442: PUSH
45443: NOP4
45447: PPUSH
45448: NOP4
45452: PUSH
45453: LD_INT 1
45455: ARRAY
45456: PUSH
45457: LD_INT 2
45459: ARRAY
45460: EQUAL
45461: AND
45462: PUSH
45463: NOP4
45467: PUSH
45468: NOP4
45472: PPUSH
45473: NOP4
45477: PUSH
45478: LD_INT 1
45480: ARRAY
45481: PUSH
45482: LD_INT 3
45484: ARRAY
45485: EQUAL
45486: AND
45487: IFFALSE 45497
// result := true ;
45489: NOP4
45493: PUSH
45494: LD_INT 1
45496: ST_TO_ADDR
// end ; end ;
45497: LD_VAR 0 4
45501: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45502: LD_INT 0
45504: PPUSH
45505: PPUSH
45506: PPUSH
45507: PPUSH
// if not unit or not area then
45508: NOP4
45512: NOT
45513: PUSH
45514: NOP4
45518: NOT
45519: OR
45520: IFFALSE 45524
// exit ;
45522: GO 45688
// tmp := AreaToList ( area , i ) ;
45524: NOP4
45528: PUSH
45529: NOP4
45533: PPUSH
45534: NOP4
45538: PPUSH
45539: NOP4
45543: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45544: NOP4
45548: PUSH
45549: DOUBLE
45550: LD_INT 1
45552: DEC
45553: ST_TO_ADDR
45554: NOP4
45558: PUSH
45559: LD_INT 1
45561: ARRAY
45562: PUSH
45563: FOR_TO
45564: IFFALSE 45686
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45566: NOP4
45570: PUSH
45571: NOP4
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: PUSH
45580: NOP4
45584: ARRAY
45585: PUSH
45586: NOP4
45590: PUSH
45591: LD_INT 2
45593: ARRAY
45594: PUSH
45595: NOP4
45599: ARRAY
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45605: NOP4
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: NOP4
45618: PUSH
45619: LD_INT 2
45621: ARRAY
45622: PPUSH
45623: NOP4
45627: PUSH
45628: LD_INT 0
45630: EQUAL
45631: IFFALSE 45684
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45633: NOP4
45637: PPUSH
45638: NOP4
45642: PUSH
45643: LD_INT 1
45645: ARRAY
45646: PPUSH
45647: NOP4
45651: PUSH
45652: LD_INT 2
45654: ARRAY
45655: PPUSH
45656: NOP4
45660: PPUSH
45661: NOP4
// result := IsPlaced ( unit ) ;
45665: NOP4
45669: PUSH
45670: NOP4
45674: PPUSH
45675: NOP4
45679: ST_TO_ADDR
// exit ;
45680: POP
45681: POP
45682: GO 45688
// end ; end ;
45684: GO 45563
45686: POP
45687: POP
// end ;
45688: LD_VAR 0 4
45692: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45693: LD_INT 0
45695: PPUSH
45696: PPUSH
45697: PPUSH
// if not side or side > 8 then
45698: NOP4
45702: NOT
45703: PUSH
45704: NOP4
45708: PUSH
45709: LD_INT 8
45711: GREATER
45712: OR
45713: IFFALSE 45717
// exit ;
45715: GO 45904
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45717: NOP4
45721: PUSH
45722: LD_INT 22
45724: PUSH
45725: NOP4
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 21
45736: PUSH
45737: LD_INT 3
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PPUSH
45748: NOP4
45752: ST_TO_ADDR
// if not tmp then
45753: NOP4
45757: NOT
45758: IFFALSE 45762
// exit ;
45760: GO 45904
// enable_addtolog := true ;
45762: LD_ADDR_OWVAR 81
45766: PUSH
45767: LD_INT 1
45769: ST_TO_ADDR
// AddToLog ( [ ) ;
45770: LD_STRING [
45772: PPUSH
45773: NOP4
// for i in tmp do
45777: NOP4
45781: PUSH
45782: NOP4
45786: PUSH
45787: FOR_IN
45788: IFFALSE 45895
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45790: LD_STRING [
45792: PUSH
45793: NOP4
45797: PPUSH
45798: NOP4
45802: STR
45803: PUSH
45804: LD_STRING , 
45806: STR
45807: PUSH
45808: NOP4
45812: PPUSH
45813: NOP4
45817: STR
45818: PUSH
45819: LD_STRING , 
45821: STR
45822: PUSH
45823: NOP4
45827: PPUSH
45828: NOP4
45832: STR
45833: PUSH
45834: LD_STRING , 
45836: STR
45837: PUSH
45838: NOP4
45842: PPUSH
45843: NOP4
45847: STR
45848: PUSH
45849: LD_STRING , 
45851: STR
45852: PUSH
45853: NOP4
45857: PPUSH
45858: LD_INT 1
45860: PPUSH
45861: NOP4
45865: STR
45866: PUSH
45867: LD_STRING , 
45869: STR
45870: PUSH
45871: NOP4
45875: PPUSH
45876: LD_INT 2
45878: PPUSH
45879: NOP4
45883: STR
45884: PUSH
45885: LD_STRING ],
45887: STR
45888: PPUSH
45889: NOP4
// end ;
45893: GO 45787
45895: POP
45896: POP
// AddToLog ( ]; ) ;
45897: LD_STRING ];
45899: PPUSH
45900: NOP4
// end ;
45904: LD_VAR 0 2
45908: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45909: LD_INT 0
45911: PPUSH
45912: PPUSH
45913: PPUSH
45914: PPUSH
45915: PPUSH
// if not area or not rate or not max then
45916: NOP4
45920: NOT
45921: PUSH
45922: NOP4
45926: NOT
45927: OR
45928: PUSH
45929: NOP4
45933: NOT
45934: OR
45935: IFFALSE 45939
// exit ;
45937: GO 46131
// while 1 do
45939: LD_INT 1
45941: IFFALSE 46131
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45943: NOP4
45947: PUSH
45948: NOP4
45952: PPUSH
45953: LD_INT 1
45955: PPUSH
45956: NOP4
45960: PUSH
45961: LD_INT 10
45963: MUL
45964: ST_TO_ADDR
// r := rate / 10 ;
45965: NOP4
45969: PUSH
45970: NOP4
45974: PUSH
45975: LD_INT 10
45977: DIVREAL
45978: ST_TO_ADDR
// time := 1 1$00 ;
45979: NOP4
45983: PUSH
45984: LD_INT 2100
45986: ST_TO_ADDR
// if amount < min then
45987: NOP4
45991: PUSH
45992: NOP4
45996: LESS
45997: IFFALSE 46015
// r := r * 2 else
45999: NOP4
46003: PUSH
46004: NOP4
46008: PUSH
46009: LD_INT 2
46011: MUL
46012: ST_TO_ADDR
46013: GO 46041
// if amount > max then
46015: NOP4
46019: PUSH
46020: NOP4
46024: GREATER
46025: IFFALSE 46041
// r := r / 2 ;
46027: NOP4
46031: PUSH
46032: NOP4
46036: PUSH
46037: LD_INT 2
46039: DIVREAL
46040: ST_TO_ADDR
// time := time / r ;
46041: NOP4
46045: PUSH
46046: NOP4
46050: PUSH
46051: NOP4
46055: DIVREAL
46056: ST_TO_ADDR
// if time < 0 then
46057: NOP4
46061: PUSH
46062: LD_INT 0
46064: LESS
46065: IFFALSE 46082
// time := time * - 1 ;
46067: NOP4
46071: PUSH
46072: NOP4
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: MUL
46081: ST_TO_ADDR
// wait ( time ) ;
46082: NOP4
46086: PPUSH
46087: NOP4
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
46091: LD_INT 35
46093: PPUSH
46094: LD_INT 875
46096: PPUSH
46097: NOP4
46101: PPUSH
46102: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46106: LD_INT 1
46108: PPUSH
46109: LD_INT 5
46111: PPUSH
46112: NOP4
46116: PPUSH
46117: NOP4
46121: PPUSH
46122: LD_INT 1
46124: PPUSH
46125: NOP4
// end ;
46129: GO 45939
// end ;
46131: LD_VAR 0 5
46135: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46136: LD_INT 0
46138: PPUSH
46139: PPUSH
46140: PPUSH
46141: PPUSH
46142: PPUSH
46143: PPUSH
46144: PPUSH
46145: PPUSH
// if not turrets or not factories then
46146: NOP4
46150: NOT
46151: PUSH
46152: NOP4
46156: NOT
46157: OR
46158: IFFALSE 46162
// exit ;
46160: GO 46469
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46162: NOP4
46166: PUSH
46167: LD_INT 5
46169: PUSH
46170: LD_INT 6
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 2
46179: PUSH
46180: LD_INT 4
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: LD_INT 5
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 24
46204: PUSH
46205: LD_INT 25
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 23
46214: PUSH
46215: LD_INT 27
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 42
46228: PUSH
46229: LD_INT 43
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 44
46238: PUSH
46239: LD_INT 46
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 45
46248: PUSH
46249: LD_INT 47
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: LIST
46265: ST_TO_ADDR
// result := [ ] ;
46266: NOP4
46270: PUSH
46271: EMPTY
46272: ST_TO_ADDR
// for i in turrets do
46273: NOP4
46277: PUSH
46278: NOP4
46282: PUSH
46283: FOR_IN
46284: IFFALSE 46467
// begin nat := GetNation ( i ) ;
46286: NOP4
46290: PUSH
46291: NOP4
46295: PPUSH
46296: NOP4
46300: ST_TO_ADDR
// weapon := 0 ;
46301: NOP4
46305: PUSH
46306: LD_INT 0
46308: ST_TO_ADDR
// if not nat then
46309: NOP4
46313: NOT
46314: IFFALSE 46318
// continue ;
46316: GO 46283
// for j in list [ nat ] do
46318: NOP4
46322: PUSH
46323: NOP4
46327: PUSH
46328: NOP4
46332: ARRAY
46333: PUSH
46334: FOR_IN
46335: IFFALSE 46376
// if GetBWeapon ( i ) = j [ 1 ] then
46337: NOP4
46341: PPUSH
46342: NOP4
46346: PUSH
46347: NOP4
46351: PUSH
46352: LD_INT 1
46354: ARRAY
46355: EQUAL
46356: IFFALSE 46374
// begin weapon := j [ 2 ] ;
46358: NOP4
46362: PUSH
46363: NOP4
46367: PUSH
46368: LD_INT 2
46370: ARRAY
46371: ST_TO_ADDR
// break ;
46372: GO 46376
// end ;
46374: GO 46334
46376: POP
46377: POP
// if not weapon then
46378: NOP4
46382: NOT
46383: IFFALSE 46387
// continue ;
46385: GO 46283
// for k in factories do
46387: NOP4
46391: PUSH
46392: NOP4
46396: PUSH
46397: FOR_IN
46398: IFFALSE 46463
// begin weapons := AvailableWeaponList ( k ) ;
46400: NOP4
46404: PUSH
46405: NOP4
46409: PPUSH
46410: NOP4
46414: ST_TO_ADDR
// if not weapons then
46415: NOP4
46419: NOT
46420: IFFALSE 46424
// continue ;
46422: GO 46397
// if weapon in weapons then
46424: NOP4
46428: PUSH
46429: NOP4
46433: IN
46434: IFFALSE 46461
// begin result := [ i , weapon ] ;
46436: NOP4
46440: PUSH
46441: NOP4
46445: PUSH
46446: NOP4
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: ST_TO_ADDR
// exit ;
46455: POP
46456: POP
46457: POP
46458: POP
46459: GO 46469
// end ; end ;
46461: GO 46397
46463: POP
46464: POP
// end ;
46465: GO 46283
46467: POP
46468: POP
// end ;
46469: LD_VAR 0 3
46473: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46474: LD_INT 0
46476: PPUSH
// if not side or side > 8 then
46477: NOP4
46481: NOT
46482: PUSH
46483: NOP4
46487: PUSH
46488: LD_INT 8
46490: GREATER
46491: OR
46492: IFFALSE 46496
// exit ;
46494: GO 46555
// if not range then
46496: NOP4
46500: NOT
46501: IFFALSE 46512
// range := - 12 ;
46503: NOP4
46507: PUSH
46508: LD_INT 12
46510: NEG
46511: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46512: NOP4
46516: PPUSH
46517: NOP4
46521: PPUSH
46522: NOP4
46526: PPUSH
46527: NOP4
46531: PPUSH
46532: NOP4
// RemoveSeeing ( x , y , side ) ;
46536: NOP4
46540: PPUSH
46541: NOP4
46545: PPUSH
46546: NOP4
46550: PPUSH
46551: NOP4
// end ;
46555: LD_VAR 0 5
46559: RET
// export function Video ( mode ) ; begin
46560: LD_INT 0
46562: PPUSH
// ingame_video = mode ;
46563: LD_ADDR_OWVAR 52
46567: PUSH
46568: NOP4
46572: ST_TO_ADDR
// interface_hidden = mode ;
46573: LD_ADDR_OWVAR 54
46577: PUSH
46578: NOP4
46582: ST_TO_ADDR
// end ;
46583: LD_VAR 0 2
46587: RET
// export function Join ( array , element ) ; begin
46588: LD_INT 0
46590: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46591: NOP4
46595: PUSH
46596: NOP4
46600: PPUSH
46601: NOP4
46605: PUSH
46606: LD_INT 1
46608: PLUS
46609: PPUSH
46610: NOP4
46614: PPUSH
46615: NOP4
46619: ST_TO_ADDR
// end ;
46620: LD_VAR 0 3
46624: RET
// export function JoinUnion ( array , element ) ; begin
46625: LD_INT 0
46627: PPUSH
// result := array union element ;
46628: NOP4
46632: PUSH
46633: NOP4
46637: PUSH
46638: NOP4
46642: UNION
46643: ST_TO_ADDR
// end ;
46644: LD_VAR 0 3
46648: RET
// export function GetBehemoths ( side ) ; begin
46649: LD_INT 0
46651: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46652: NOP4
46656: PUSH
46657: LD_INT 22
46659: PUSH
46660: NOP4
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: LD_INT 31
46671: PUSH
46672: LD_INT 25
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: PPUSH
46683: NOP4
46687: ST_TO_ADDR
// end ;
46688: LD_VAR 0 2
46692: RET
// export function Shuffle ( array ) ; var i , index ; begin
46693: LD_INT 0
46695: PPUSH
46696: PPUSH
46697: PPUSH
// result := [ ] ;
46698: NOP4
46702: PUSH
46703: EMPTY
46704: ST_TO_ADDR
// if not array then
46705: NOP4
46709: NOT
46710: IFFALSE 46714
// exit ;
46712: GO 46813
// Randomize ;
46714: NOP4
// for i = array downto 1 do
46718: NOP4
46722: PUSH
46723: DOUBLE
46724: NOP4
46728: INC
46729: ST_TO_ADDR
46730: LD_INT 1
46732: PUSH
46733: FOR_DOWNTO
46734: IFFALSE 46811
// begin index := rand ( 1 , array ) ;
46736: NOP4
46740: PUSH
46741: LD_INT 1
46743: PPUSH
46744: NOP4
46748: PPUSH
46749: NOP4
46753: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46754: NOP4
46758: PUSH
46759: NOP4
46763: PPUSH
46764: NOP4
46768: PUSH
46769: LD_INT 1
46771: PLUS
46772: PPUSH
46773: NOP4
46777: PUSH
46778: NOP4
46782: ARRAY
46783: PPUSH
46784: NOP4
46788: ST_TO_ADDR
// array := Delete ( array , index ) ;
46789: NOP4
46793: PUSH
46794: NOP4
46798: PPUSH
46799: NOP4
46803: PPUSH
46804: NOP4
46808: ST_TO_ADDR
// end ;
46809: GO 46733
46811: POP
46812: POP
// end ;
46813: LD_VAR 0 2
46817: RET
// export function GetBaseMaterials ( base ) ; begin
46818: LD_INT 0
46820: PPUSH
// result := [ 0 , 0 , 0 ] ;
46821: NOP4
46825: PUSH
46826: LD_INT 0
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: LD_INT 0
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// if not base then
46840: NOP4
46844: NOT
46845: IFFALSE 46849
// exit ;
46847: GO 46898
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46849: NOP4
46853: PUSH
46854: NOP4
46858: PPUSH
46859: LD_INT 1
46861: PPUSH
46862: NOP4
46866: PUSH
46867: NOP4
46871: PPUSH
46872: LD_INT 2
46874: PPUSH
46875: NOP4
46879: PUSH
46880: NOP4
46884: PPUSH
46885: LD_INT 3
46887: PPUSH
46888: NOP4
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: LIST
46897: ST_TO_ADDR
// end ;
46898: LD_VAR 0 2
46902: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46903: LD_INT 0
46905: PPUSH
46906: PPUSH
// result := array ;
46907: NOP4
46911: PUSH
46912: NOP4
46916: ST_TO_ADDR
// if size > 0 then
46917: NOP4
46921: PUSH
46922: LD_INT 0
46924: GREATER
46925: IFFALSE 46971
// for i := array downto size do
46927: NOP4
46931: PUSH
46932: DOUBLE
46933: NOP4
46937: INC
46938: ST_TO_ADDR
46939: NOP4
46943: PUSH
46944: FOR_DOWNTO
46945: IFFALSE 46969
// result := Delete ( result , result ) ;
46947: NOP4
46951: PUSH
46952: NOP4
46956: PPUSH
46957: NOP4
46961: PPUSH
46962: NOP4
46966: ST_TO_ADDR
46967: GO 46944
46969: POP
46970: POP
// end ;
46971: LD_VAR 0 3
46975: RET
// export function ComExit ( unit ) ; var tmp ; begin
46976: LD_INT 0
46978: PPUSH
46979: PPUSH
// if not IsInUnit ( unit ) then
46980: NOP4
46984: PPUSH
46985: NOP4
46989: NOT
46990: IFFALSE 46994
// exit ;
46992: GO 47054
// tmp := IsInUnit ( unit ) ;
46994: NOP4
46998: PUSH
46999: NOP4
47003: PPUSH
47004: NOP4
47008: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47009: NOP4
47013: PPUSH
47014: NOP4
47018: PUSH
47019: LD_INT 2
47021: EQUAL
47022: IFFALSE 47035
// ComExitVehicle ( unit ) else
47024: NOP4
47028: PPUSH
47029: NOP4
47033: GO 47044
// ComExitBuilding ( unit ) ;
47035: NOP4
47039: PPUSH
47040: NOP4
// result := tmp ;
47044: NOP4
47048: PUSH
47049: NOP4
47053: ST_TO_ADDR
// end ;
47054: LD_VAR 0 2
47058: RET
// export function ComExitAll ( units ) ; var i ; begin
47059: LD_INT 0
47061: PPUSH
47062: PPUSH
// if not units then
47063: NOP4
47067: NOT
47068: IFFALSE 47072
// exit ;
47070: GO 47098
// for i in units do
47072: NOP4
47076: PUSH
47077: NOP4
47081: PUSH
47082: FOR_IN
47083: IFFALSE 47096
// ComExit ( i ) ;
47085: NOP4
47089: PPUSH
47090: NOP4
47094: GO 47082
47096: POP
47097: POP
// end ;
47098: LD_VAR 0 2
47102: RET
// export function ResetHc ; begin
47103: LD_INT 0
47105: PPUSH
// InitHc ;
47106: NOP4
// hc_importance := 0 ;
47110: LD_ADDR_OWVAR 32
47114: PUSH
47115: LD_INT 0
47117: ST_TO_ADDR
// end ;
47118: LD_VAR 0 1
47122: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47123: LD_INT 0
47125: PPUSH
47126: PPUSH
47127: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47128: NOP4
47132: PUSH
47133: NOP4
47137: PUSH
47138: NOP4
47142: PLUS
47143: PUSH
47144: LD_INT 2
47146: DIV
47147: ST_TO_ADDR
// if _x < 0 then
47148: NOP4
47152: PUSH
47153: LD_INT 0
47155: LESS
47156: IFFALSE 47173
// _x := _x * - 1 ;
47158: NOP4
47162: PUSH
47163: NOP4
47167: PUSH
47168: LD_INT 1
47170: NEG
47171: MUL
47172: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47173: NOP4
47177: PUSH
47178: NOP4
47182: PUSH
47183: NOP4
47187: PLUS
47188: PUSH
47189: LD_INT 2
47191: DIV
47192: ST_TO_ADDR
// if _y < 0 then
47193: NOP4
47197: PUSH
47198: LD_INT 0
47200: LESS
47201: IFFALSE 47218
// _y := _y * - 1 ;
47203: NOP4
47207: PUSH
47208: NOP4
47212: PUSH
47213: LD_INT 1
47215: NEG
47216: MUL
47217: ST_TO_ADDR
// result := [ _x , _y ] ;
47218: NOP4
47222: PUSH
47223: NOP4
47227: PUSH
47228: NOP4
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: ST_TO_ADDR
// end ;
47237: LD_VAR 0 5
47241: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47242: LD_INT 0
47244: PPUSH
47245: PPUSH
47246: PPUSH
47247: PPUSH
// task := GetTaskList ( unit ) ;
47248: NOP4
47252: PUSH
47253: NOP4
47257: PPUSH
47258: NOP4
47262: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47263: NOP4
47267: NOT
47268: PUSH
47269: NOP4
47273: PPUSH
47274: NOP4
47278: PPUSH
47279: NOP4
47283: NOT
47284: AND
47285: IFFALSE 47289
// exit ;
47287: GO 47407
// if IsInArea ( unit , area ) then
47289: NOP4
47293: PPUSH
47294: NOP4
47298: PPUSH
47299: NOP4
47303: IFFALSE 47321
// begin ComMoveToArea ( unit , goAway ) ;
47305: NOP4
47309: PPUSH
47310: NOP4
47314: PPUSH
47315: NOP4
// exit ;
47319: GO 47407
// end ; if task [ 1 ] [ 1 ] <> M then
47321: NOP4
47325: PUSH
47326: LD_INT 1
47328: ARRAY
47329: PUSH
47330: LD_INT 1
47332: ARRAY
47333: PUSH
47334: LD_STRING M
47336: NONEQUAL
47337: IFFALSE 47341
// exit ;
47339: GO 47407
// x := task [ 1 ] [ 2 ] ;
47341: NOP4
47345: PUSH
47346: NOP4
47350: PUSH
47351: LD_INT 1
47353: ARRAY
47354: PUSH
47355: LD_INT 2
47357: ARRAY
47358: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47359: NOP4
47363: PUSH
47364: NOP4
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: PUSH
47373: LD_INT 3
47375: ARRAY
47376: ST_TO_ADDR
// if InArea ( x , y , area ) then
47377: NOP4
47381: PPUSH
47382: NOP4
47386: PPUSH
47387: NOP4
47391: PPUSH
47392: NOP4
47396: IFFALSE 47407
// ComStop ( unit ) ;
47398: NOP4
47402: PPUSH
47403: NOP4
// end ;
47407: LD_VAR 0 4
47411: RET
// export function Abs ( value ) ; begin
47412: LD_INT 0
47414: PPUSH
// result := value ;
47415: NOP4
47419: PUSH
47420: NOP4
47424: ST_TO_ADDR
// if value < 0 then
47425: NOP4
47429: PUSH
47430: LD_INT 0
47432: LESS
47433: IFFALSE 47450
// result := value * - 1 ;
47435: NOP4
47439: PUSH
47440: NOP4
47444: PUSH
47445: LD_INT 1
47447: NEG
47448: MUL
47449: ST_TO_ADDR
// end ;
47450: LD_VAR 0 2
47454: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47455: LD_INT 0
47457: PPUSH
47458: PPUSH
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not unit or not building then
47465: NOP4
47469: NOT
47470: PUSH
47471: NOP4
47475: NOT
47476: OR
47477: IFFALSE 47481
// exit ;
47479: GO 47707
// x := GetX ( building ) ;
47481: NOP4
47485: PUSH
47486: NOP4
47490: PPUSH
47491: NOP4
47495: ST_TO_ADDR
// y := GetY ( building ) ;
47496: NOP4
47500: PUSH
47501: NOP4
47505: PPUSH
47506: NOP4
47510: ST_TO_ADDR
// d := GetDir ( building ) ;
47511: NOP4
47515: PUSH
47516: NOP4
47520: PPUSH
47521: NOP4
47525: ST_TO_ADDR
// r := 4 ;
47526: NOP4
47530: PUSH
47531: LD_INT 4
47533: ST_TO_ADDR
// for i := 1 to 5 do
47534: NOP4
47538: PUSH
47539: DOUBLE
47540: LD_INT 1
47542: DEC
47543: ST_TO_ADDR
47544: LD_INT 5
47546: PUSH
47547: FOR_TO
47548: IFFALSE 47705
// begin _x := ShiftX ( x , d , r + i ) ;
47550: NOP4
47554: PUSH
47555: NOP4
47559: PPUSH
47560: NOP4
47564: PPUSH
47565: NOP4
47569: PUSH
47570: NOP4
47574: PLUS
47575: PPUSH
47576: NOP4
47580: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47581: NOP4
47585: PUSH
47586: NOP4
47590: PPUSH
47591: NOP4
47595: PPUSH
47596: NOP4
47600: PUSH
47601: NOP4
47605: PLUS
47606: PPUSH
47607: NOP4
47611: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47612: NOP4
47616: PPUSH
47617: NOP4
47621: PPUSH
47622: NOP4
47626: PUSH
47627: NOP4
47631: PPUSH
47632: NOP4
47636: PPUSH
47637: NOP4
47641: PPUSH
47642: NOP4
47646: PUSH
47647: LD_INT 3
47649: PUSH
47650: LD_INT 2
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: IN
47657: NOT
47658: AND
47659: IFFALSE 47703
// begin ComMoveXY ( unit , _x , _y ) ;
47661: NOP4
47665: PPUSH
47666: NOP4
47670: PPUSH
47671: NOP4
47675: PPUSH
47676: NOP4
// result := [ _x , _y ] ;
47680: NOP4
47684: PUSH
47685: NOP4
47689: PUSH
47690: NOP4
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: ST_TO_ADDR
// exit ;
47699: POP
47700: POP
47701: GO 47707
// end ; end ;
47703: GO 47547
47705: POP
47706: POP
// end ;
47707: LD_VAR 0 3
47711: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47712: LD_INT 0
47714: PPUSH
47715: PPUSH
47716: PPUSH
// result := 0 ;
47717: NOP4
47721: PUSH
47722: LD_INT 0
47724: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47725: NOP4
47729: PUSH
47730: LD_INT 0
47732: LESS
47733: PUSH
47734: NOP4
47738: PUSH
47739: LD_INT 8
47741: GREATER
47742: OR
47743: PUSH
47744: NOP4
47748: PUSH
47749: LD_INT 0
47751: LESS
47752: OR
47753: PUSH
47754: NOP4
47758: PUSH
47759: LD_INT 8
47761: GREATER
47762: OR
47763: IFFALSE 47767
// exit ;
47765: GO 47842
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47767: NOP4
47771: PUSH
47772: LD_INT 22
47774: PUSH
47775: NOP4
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PPUSH
47784: NOP4
47788: PUSH
47789: FOR_IN
47790: IFFALSE 47840
// begin un := UnitShoot ( i ) ;
47792: NOP4
47796: PUSH
47797: NOP4
47801: PPUSH
47802: NOP4
47806: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47807: NOP4
47811: PPUSH
47812: NOP4
47816: PUSH
47817: NOP4
47821: EQUAL
47822: IFFALSE 47838
// begin result := un ;
47824: NOP4
47828: PUSH
47829: NOP4
47833: ST_TO_ADDR
// exit ;
47834: POP
47835: POP
47836: GO 47842
// end ; end ;
47838: GO 47789
47840: POP
47841: POP
// end ;
47842: LD_VAR 0 3
47846: RET
// export function GetCargoBay ( units ) ; begin
47847: LD_INT 0
47849: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47850: NOP4
47854: PUSH
47855: NOP4
47859: PPUSH
47860: LD_INT 2
47862: PUSH
47863: LD_INT 34
47865: PUSH
47866: LD_INT 12
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: LD_INT 34
47875: PUSH
47876: LD_INT 51
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: LD_INT 34
47885: PUSH
47886: LD_INT 32
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: PUSH
47893: LD_INT 34
47895: PUSH
47896: NOP4
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: PPUSH
47912: NOP4
47916: ST_TO_ADDR
// end ;
47917: LD_VAR 0 2
47921: RET
// export function Negate ( value ) ; begin
47922: LD_INT 0
47924: PPUSH
// result := not value ;
47925: NOP4
47929: PUSH
47930: NOP4
47934: NOT
47935: ST_TO_ADDR
// end ;
47936: LD_VAR 0 2
47940: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
47941: LD_INT 0
47943: PPUSH
// if x1 = x2 then
47944: NOP4
47948: PUSH
47949: NOP4
47953: EQUAL
47954: IFFALSE 47988
// begin if y1 > y2 then
47956: NOP4
47960: PUSH
47961: NOP4
47965: GREATER
47966: IFFALSE 47978
// result := 0 else
47968: NOP4
47972: PUSH
47973: LD_INT 0
47975: ST_TO_ADDR
47976: GO 47986
// result := 3 ;
47978: NOP4
47982: PUSH
47983: LD_INT 3
47985: ST_TO_ADDR
// exit ;
47986: GO 48074
// end ; if y1 = y2 then
47988: NOP4
47992: PUSH
47993: NOP4
47997: EQUAL
47998: IFFALSE 48032
// begin if x1 > x2 then
48000: NOP4
48004: PUSH
48005: NOP4
48009: GREATER
48010: IFFALSE 48022
// result := 1 else
48012: NOP4
48016: PUSH
48017: LD_INT 1
48019: ST_TO_ADDR
48020: GO 48030
// result := 4 ;
48022: NOP4
48026: PUSH
48027: LD_INT 4
48029: ST_TO_ADDR
// exit ;
48030: GO 48074
// end ; if x1 > x2 and y1 > y2 then
48032: NOP4
48036: PUSH
48037: NOP4
48041: GREATER
48042: PUSH
48043: NOP4
48047: PUSH
48048: NOP4
48052: GREATER
48053: AND
48054: IFFALSE 48066
// result := 2 else
48056: NOP4
48060: PUSH
48061: LD_INT 2
48063: ST_TO_ADDR
48064: GO 48074
// result := 5 ;
48066: NOP4
48070: PUSH
48071: LD_INT 5
48073: ST_TO_ADDR
// end ;
48074: LD_VAR 0 5
48078: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48079: LD_INT 0
48081: PPUSH
48082: PPUSH
// if not driver or not IsInUnit ( driver ) then
48083: NOP4
48087: NOT
48088: PUSH
48089: NOP4
48093: PPUSH
48094: NOP4
48098: NOT
48099: OR
48100: IFFALSE 48104
// exit ;
48102: GO 48194
// vehicle := IsInUnit ( driver ) ;
48104: NOP4
48108: PUSH
48109: NOP4
48113: PPUSH
48114: NOP4
48118: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48119: NOP4
48123: PPUSH
48124: LD_STRING \
48126: PUSH
48127: LD_INT 0
48129: PUSH
48130: LD_INT 0
48132: PUSH
48133: LD_INT 0
48135: PUSH
48136: LD_INT 0
48138: PUSH
48139: LD_INT 0
48141: PUSH
48142: LD_INT 0
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: PUSH
48154: LD_STRING E
48156: PUSH
48157: LD_INT 0
48159: PUSH
48160: LD_INT 0
48162: PUSH
48163: NOP4
48167: PUSH
48168: LD_INT 0
48170: PUSH
48171: LD_INT 0
48173: PUSH
48174: LD_INT 0
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: PPUSH
48190: NOP4
// end ;
48194: LD_VAR 0 2
48198: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48199: LD_INT 0
48201: PPUSH
48202: PPUSH
// if not driver or not IsInUnit ( driver ) then
48203: NOP4
48207: NOT
48208: PUSH
48209: NOP4
48213: PPUSH
48214: NOP4
48218: NOT
48219: OR
48220: IFFALSE 48224
// exit ;
48222: GO 48314
// vehicle := IsInUnit ( driver ) ;
48224: NOP4
48228: PUSH
48229: NOP4
48233: PPUSH
48234: NOP4
48238: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48239: NOP4
48243: PPUSH
48244: LD_STRING \
48246: PUSH
48247: LD_INT 0
48249: PUSH
48250: LD_INT 0
48252: PUSH
48253: LD_INT 0
48255: PUSH
48256: LD_INT 0
48258: PUSH
48259: LD_INT 0
48261: PUSH
48262: LD_INT 0
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: PUSH
48274: LD_STRING E
48276: PUSH
48277: LD_INT 0
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: NOP4
48287: PUSH
48288: LD_INT 0
48290: PUSH
48291: LD_INT 0
48293: PUSH
48294: LD_INT 0
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PPUSH
48310: NOP4
// end ;
48314: LD_VAR 0 2
48318: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
48319: LD_INT 0
48321: PPUSH
48322: PPUSH
48323: PPUSH
// tmp := [ ] ;
48324: NOP4
48328: PUSH
48329: EMPTY
48330: ST_TO_ADDR
// for i in units do
48331: NOP4
48335: PUSH
48336: NOP4
48340: PUSH
48341: FOR_IN
48342: IFFALSE 48380
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
48344: NOP4
48348: PUSH
48349: NOP4
48353: PPUSH
48354: NOP4
48358: PUSH
48359: LD_INT 1
48361: PLUS
48362: PPUSH
48363: NOP4
48367: PPUSH
48368: NOP4
48372: PPUSH
48373: NOP4
48377: ST_TO_ADDR
48378: GO 48341
48380: POP
48381: POP
// if not tmp then
48382: NOP4
48386: NOT
48387: IFFALSE 48391
// exit ;
48389: GO 48439
// if asc then
48391: NOP4
48395: IFFALSE 48419
// result := SortListByListAsc ( units , tmp ) else
48397: NOP4
48401: PUSH
48402: NOP4
48406: PPUSH
48407: NOP4
48411: PPUSH
48412: NOP4
48416: ST_TO_ADDR
48417: GO 48439
// result := SortListByListDesc ( units , tmp ) ;
48419: NOP4
48423: PUSH
48424: NOP4
48428: PPUSH
48429: NOP4
48433: PPUSH
48434: NOP4
48438: ST_TO_ADDR
// end ;
48439: LD_VAR 0 3
48443: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
48444: LD_INT 0
48446: PPUSH
48447: PPUSH
// task := GetTaskList ( mech ) ;
48448: NOP4
48452: PUSH
48453: NOP4
48457: PPUSH
48458: NOP4
48462: ST_TO_ADDR
// if not task then
48463: NOP4
48467: NOT
48468: IFFALSE 48472
// exit ;
48470: GO 48514
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
48472: NOP4
48476: PUSH
48477: NOP4
48481: PUSH
48482: LD_INT 1
48484: ARRAY
48485: PUSH
48486: LD_INT 1
48488: ARRAY
48489: PUSH
48490: LD_STRING r
48492: EQUAL
48493: PUSH
48494: NOP4
48498: PUSH
48499: LD_INT 1
48501: ARRAY
48502: PUSH
48503: LD_INT 4
48505: ARRAY
48506: PUSH
48507: NOP4
48511: EQUAL
48512: AND
48513: ST_TO_ADDR
// end ;
48514: LD_VAR 0 3
48518: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
48519: LD_INT 0
48521: PPUSH
// SetDir ( unit , d ) ;
48522: NOP4
48526: PPUSH
48527: NOP4
48531: PPUSH
48532: NOP4
// PlaceUnitXY ( unit , x , y , mode ) ;
48536: NOP4
48540: PPUSH
48541: NOP4
48545: PPUSH
48546: NOP4
48550: PPUSH
48551: NOP4
48555: PPUSH
48556: NOP4
// end ;
48560: LD_VAR 0 6
48564: RET
// export function ToNaturalNumber ( number ) ; begin
48565: LD_INT 0
48567: PPUSH
// result := number div 1 ;
48568: NOP4
48572: PUSH
48573: NOP4
48577: PUSH
48578: LD_INT 1
48580: DIV
48581: ST_TO_ADDR
// if number < 0 then
48582: NOP4
48586: PUSH
48587: LD_INT 0
48589: LESS
48590: IFFALSE 48600
// result := 0 ;
48592: NOP4
48596: PUSH
48597: LD_INT 0
48599: ST_TO_ADDR
// end ;
48600: LD_VAR 0 2
48604: RET
// export function SortByClass ( units , class ) ; var un ; begin
48605: LD_INT 0
48607: PPUSH
48608: PPUSH
// if not units or not class then
48609: NOP4
48613: NOT
48614: PUSH
48615: NOP4
48619: NOT
48620: OR
48621: IFFALSE 48625
// exit ;
48623: GO 48720
// result := [ ] ;
48625: NOP4
48629: PUSH
48630: EMPTY
48631: ST_TO_ADDR
// for un in units do
48632: NOP4
48636: PUSH
48637: NOP4
48641: PUSH
48642: FOR_IN
48643: IFFALSE 48718
// if GetClass ( un ) = class then
48645: NOP4
48649: PPUSH
48650: NOP4
48654: PUSH
48655: NOP4
48659: EQUAL
48660: IFFALSE 48687
// result := Insert ( result , 1 , un ) else
48662: NOP4
48666: PUSH
48667: NOP4
48671: PPUSH
48672: LD_INT 1
48674: PPUSH
48675: NOP4
48679: PPUSH
48680: NOP4
48684: ST_TO_ADDR
48685: GO 48716
// result := Replace ( result , result + 1 , un ) ;
48687: NOP4
48691: PUSH
48692: NOP4
48696: PPUSH
48697: NOP4
48701: PUSH
48702: LD_INT 1
48704: PLUS
48705: PPUSH
48706: NOP4
48710: PPUSH
48711: NOP4
48715: ST_TO_ADDR
48716: GO 48642
48718: POP
48719: POP
// end ;
48720: LD_VAR 0 3
48724: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
48725: LD_INT 0
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
// result := [ ] ;
48734: NOP4
48738: PUSH
48739: EMPTY
48740: ST_TO_ADDR
// if x - r < 0 then
48741: NOP4
48745: PUSH
48746: NOP4
48750: MINUS
48751: PUSH
48752: LD_INT 0
48754: LESS
48755: IFFALSE 48767
// min_x := 0 else
48757: NOP4
48761: PUSH
48762: LD_INT 0
48764: ST_TO_ADDR
48765: GO 48783
// min_x := x - r ;
48767: NOP4
48771: PUSH
48772: NOP4
48776: PUSH
48777: NOP4
48781: MINUS
48782: ST_TO_ADDR
// if y - r < 0 then
48783: NOP4
48787: PUSH
48788: NOP4
48792: MINUS
48793: PUSH
48794: LD_INT 0
48796: LESS
48797: IFFALSE 48809
// min_y := 0 else
48799: NOP4
48803: PUSH
48804: LD_INT 0
48806: ST_TO_ADDR
48807: GO 48825
// min_y := y - r ;
48809: NOP4
48813: PUSH
48814: NOP4
48818: PUSH
48819: NOP4
48823: MINUS
48824: ST_TO_ADDR
// max_x := x + r ;
48825: NOP4
48829: PUSH
48830: NOP4
48834: PUSH
48835: NOP4
48839: PLUS
48840: ST_TO_ADDR
// max_y := y + r ;
48841: NOP4
48845: PUSH
48846: NOP4
48850: PUSH
48851: NOP4
48855: PLUS
48856: ST_TO_ADDR
// for _x = min_x to max_x do
48857: NOP4
48861: PUSH
48862: DOUBLE
48863: NOP4
48867: DEC
48868: ST_TO_ADDR
48869: NOP4
48873: PUSH
48874: FOR_TO
48875: IFFALSE 48976
// for _y = min_y to max_y do
48877: NOP4
48881: PUSH
48882: DOUBLE
48883: NOP4
48887: DEC
48888: ST_TO_ADDR
48889: NOP4
48893: PUSH
48894: FOR_TO
48895: IFFALSE 48972
// begin if not ValidHex ( _x , _y ) then
48897: NOP4
48901: PPUSH
48902: NOP4
48906: PPUSH
48907: NOP4
48911: NOT
48912: IFFALSE 48916
// continue ;
48914: GO 48894
// if GetResourceTypeXY ( _x , _y ) then
48916: NOP4
48920: PPUSH
48921: NOP4
48925: PPUSH
48926: NOP4
48930: IFFALSE 48970
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
48932: NOP4
48936: PUSH
48937: NOP4
48941: PPUSH
48942: NOP4
48946: PUSH
48947: LD_INT 1
48949: PLUS
48950: PPUSH
48951: NOP4
48955: PUSH
48956: NOP4
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: PPUSH
48965: NOP4
48969: ST_TO_ADDR
// end ;
48970: GO 48894
48972: POP
48973: POP
48974: GO 48874
48976: POP
48977: POP
// end ;
48978: LD_VAR 0 4
48982: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
48983: LD_INT 0
48985: PPUSH
48986: PPUSH
48987: PPUSH
48988: PPUSH
48989: PPUSH
48990: PPUSH
// if not units then
48991: NOP4
48995: NOT
48996: IFFALSE 49000
// exit ;
48998: GO 49401
// result := UnitFilter ( units , [ f_ok ] ) ;
49000: NOP4
49004: PUSH
49005: NOP4
49009: PPUSH
49010: LD_INT 50
49012: PUSH
49013: EMPTY
49014: LIST
49015: PPUSH
49016: NOP4
49020: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49021: NOP4
49025: PUSH
49026: NOP4
49030: PUSH
49031: LD_INT 1
49033: ARRAY
49034: PPUSH
49035: NOP4
49039: ST_TO_ADDR
// if not result then
49040: NOP4
49044: NOT
49045: IFFALSE 49049
// exit ;
49047: GO 49401
// for i in result do
49049: NOP4
49053: PUSH
49054: NOP4
49058: PUSH
49059: FOR_IN
49060: IFFALSE 49399
// begin tag := GetTag ( i ) + 1 ;
49062: NOP4
49066: PUSH
49067: NOP4
49071: PPUSH
49072: NOP4
49076: PUSH
49077: LD_INT 1
49079: PLUS
49080: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49081: NOP4
49085: PUSH
49086: NOP4
49090: PPUSH
49091: NOP4
49095: PPUSH
49096: NOP4
49100: PPUSH
49101: NOP4
49105: PPUSH
49106: LD_INT 6
49108: PPUSH
49109: NOP4
49113: ST_TO_ADDR
// if cr then
49114: NOP4
49118: IFFALSE 49157
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
49120: NOP4
49124: PPUSH
49125: NOP4
49129: PUSH
49130: LD_INT 1
49132: ARRAY
49133: PUSH
49134: LD_INT 1
49136: ARRAY
49137: PPUSH
49138: NOP4
49142: PUSH
49143: LD_INT 1
49145: ARRAY
49146: PUSH
49147: LD_INT 2
49149: ARRAY
49150: PPUSH
49151: NOP4
49155: GO 49397
// if path > tag then
49157: NOP4
49161: PUSH
49162: NOP4
49166: GREATER
49167: IFFALSE 49345
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
49169: NOP4
49173: PUSH
49174: LD_INT 81
49176: PUSH
49177: NOP4
49181: PUSH
49182: EMPTY
49183: LIST
49184: LIST
49185: PUSH
49186: LD_INT 91
49188: PUSH
49189: NOP4
49193: PUSH
49194: LD_INT 12
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: LIST
49201: PUSH
49202: EMPTY
49203: LIST
49204: LIST
49205: PPUSH
49206: NOP4
49210: ST_TO_ADDR
// if enemy then
49211: NOP4
49215: IFFALSE 49243
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49217: NOP4
49221: PPUSH
49222: NOP4
49226: PPUSH
49227: NOP4
49231: PPUSH
49232: NOP4
49236: PPUSH
49237: NOP4
49241: GO 49343
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
49243: NOP4
49247: PPUSH
49248: NOP4
49252: PUSH
49253: NOP4
49257: ARRAY
49258: PUSH
49259: LD_INT 1
49261: ARRAY
49262: PPUSH
49263: NOP4
49267: PUSH
49268: NOP4
49272: ARRAY
49273: PUSH
49274: LD_INT 2
49276: ARRAY
49277: PPUSH
49278: NOP4
49282: PUSH
49283: LD_INT 6
49285: GREATER
49286: IFFALSE 49329
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
49288: NOP4
49292: PPUSH
49293: NOP4
49297: PUSH
49298: NOP4
49302: ARRAY
49303: PUSH
49304: LD_INT 1
49306: ARRAY
49307: PPUSH
49308: NOP4
49312: PUSH
49313: NOP4
49317: ARRAY
49318: PUSH
49319: LD_INT 2
49321: ARRAY
49322: PPUSH
49323: NOP4
49327: GO 49343
// SetTag ( i , tag ) ;
49329: NOP4
49333: PPUSH
49334: NOP4
49338: PPUSH
49339: NOP4
// end else
49343: GO 49397
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49345: NOP4
49349: PUSH
49350: LD_INT 81
49352: PUSH
49353: NOP4
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PPUSH
49362: NOP4
49366: ST_TO_ADDR
// if enemy then
49367: NOP4
49371: IFFALSE 49397
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
49373: NOP4
49377: PPUSH
49378: NOP4
49382: PPUSH
49383: NOP4
49387: PPUSH
49388: NOP4
49392: PPUSH
49393: NOP4
// end ; end ;
49397: GO 49059
49399: POP
49400: POP
// end ; end_of_file
49401: LD_VAR 0 3
49405: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
49406: LD_INT 0
49408: PPUSH
49409: PPUSH
// skirmish := false ;
49410: NOP4
49414: PUSH
49415: LD_INT 0
49417: ST_TO_ADDR
// debug_mc := false ;
49418: NOP4
49422: PUSH
49423: LD_INT 0
49425: ST_TO_ADDR
// mc_bases := [ ] ;
49426: NOP4
49430: PUSH
49431: EMPTY
49432: ST_TO_ADDR
// mc_sides := [ ] ;
49433: NOP4
49437: PUSH
49438: EMPTY
49439: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
49440: NOP4
49444: PUSH
49445: EMPTY
49446: ST_TO_ADDR
// mc_building_repairs := [ ] ;
49447: NOP4
49451: PUSH
49452: EMPTY
49453: ST_TO_ADDR
// mc_need_heal := [ ] ;
49454: NOP4
49458: PUSH
49459: EMPTY
49460: ST_TO_ADDR
// mc_healers := [ ] ;
49461: NOP4
49465: PUSH
49466: EMPTY
49467: ST_TO_ADDR
// mc_build_list := [ ] ;
49468: NOP4
49472: PUSH
49473: EMPTY
49474: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
49475: NOP4
49479: PUSH
49480: EMPTY
49481: ST_TO_ADDR
// mc_builders := [ ] ;
49482: NOP4
49486: PUSH
49487: EMPTY
49488: ST_TO_ADDR
// mc_construct_list := [ ] ;
49489: NOP4
49493: PUSH
49494: EMPTY
49495: ST_TO_ADDR
// mc_turret_list := [ ] ;
49496: NOP4
49500: PUSH
49501: EMPTY
49502: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
49503: NOP4
49507: PUSH
49508: EMPTY
49509: ST_TO_ADDR
// mc_miners := [ ] ;
49510: NOP4
49514: PUSH
49515: EMPTY
49516: ST_TO_ADDR
// mc_mines := [ ] ;
49517: NOP4
49521: PUSH
49522: EMPTY
49523: ST_TO_ADDR
// mc_minefields := [ ] ;
49524: NOP4
49528: PUSH
49529: EMPTY
49530: ST_TO_ADDR
// mc_crates := [ ] ;
49531: NOP4
49535: PUSH
49536: EMPTY
49537: ST_TO_ADDR
// mc_crates_collector := [ ] ;
49538: NOP4
49542: PUSH
49543: EMPTY
49544: ST_TO_ADDR
// mc_crates_area := [ ] ;
49545: NOP4
49549: PUSH
49550: EMPTY
49551: ST_TO_ADDR
// mc_vehicles := [ ] ;
49552: NOP4
49556: PUSH
49557: EMPTY
49558: ST_TO_ADDR
// mc_attack := [ ] ;
49559: NOP4
49563: PUSH
49564: EMPTY
49565: ST_TO_ADDR
// mc_produce := [ ] ;
49566: NOP4
49570: PUSH
49571: EMPTY
49572: ST_TO_ADDR
// mc_defender := [ ] ;
49573: NOP4
49577: PUSH
49578: EMPTY
49579: ST_TO_ADDR
// mc_parking := [ ] ;
49580: NOP4
49584: PUSH
49585: EMPTY
49586: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
49587: NOP4
49591: PUSH
49592: EMPTY
49593: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
49594: NOP4
49598: PUSH
49599: EMPTY
49600: ST_TO_ADDR
// mc_scan := [ ] ;
49601: NOP4
49605: PUSH
49606: EMPTY
49607: ST_TO_ADDR
// mc_scan_area := [ ] ;
49608: NOP4
49612: PUSH
49613: EMPTY
49614: ST_TO_ADDR
// mc_tech := [ ] ;
49615: NOP4
49619: PUSH
49620: EMPTY
49621: ST_TO_ADDR
// mc_class := [ ] ;
49622: NOP4
49626: PUSH
49627: EMPTY
49628: ST_TO_ADDR
// mc_class_case_use := [ ] ;
49629: NOP4
49633: PUSH
49634: EMPTY
49635: ST_TO_ADDR
// mc_is_defending := [ ] ;
49636: NOP4
49640: PUSH
49641: EMPTY
49642: ST_TO_ADDR
// end ;
49643: LD_VAR 0 1
49647: RET
// export function MC_Kill ( base ) ; begin
49648: LD_INT 0
49650: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
49651: NOP4
49655: PUSH
49656: NOP4
49660: PPUSH
49661: NOP4
49665: PPUSH
49666: EMPTY
49667: PPUSH
49668: NOP4
49672: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
49673: NOP4
49677: PUSH
49678: NOP4
49682: PPUSH
49683: NOP4
49687: PPUSH
49688: EMPTY
49689: PPUSH
49690: NOP4
49694: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
49695: NOP4
49699: PUSH
49700: NOP4
49704: PPUSH
49705: NOP4
49709: PPUSH
49710: EMPTY
49711: PPUSH
49712: NOP4
49716: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
49717: NOP4
49721: PUSH
49722: NOP4
49726: PPUSH
49727: NOP4
49731: PPUSH
49732: EMPTY
49733: PPUSH
49734: NOP4
49738: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
49739: NOP4
49743: PUSH
49744: NOP4
49748: PPUSH
49749: NOP4
49753: PPUSH
49754: EMPTY
49755: PPUSH
49756: NOP4
49760: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
49761: NOP4
49765: PUSH
49766: NOP4
49770: PPUSH
49771: NOP4
49775: PPUSH
49776: EMPTY
49777: PPUSH
49778: NOP4
49782: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
49783: NOP4
49787: PUSH
49788: NOP4
49792: PPUSH
49793: NOP4
49797: PPUSH
49798: EMPTY
49799: PPUSH
49800: NOP4
49804: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
49805: NOP4
49809: PUSH
49810: NOP4
49814: PPUSH
49815: NOP4
49819: PPUSH
49820: EMPTY
49821: PPUSH
49822: NOP4
49826: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
49827: NOP4
49831: PUSH
49832: NOP4
49836: PPUSH
49837: NOP4
49841: PPUSH
49842: EMPTY
49843: PPUSH
49844: NOP4
49848: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
49849: NOP4
49853: PUSH
49854: NOP4
49858: PPUSH
49859: NOP4
49863: PPUSH
49864: EMPTY
49865: PPUSH
49866: NOP4
49870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
49871: NOP4
49875: PUSH
49876: NOP4
49880: PPUSH
49881: NOP4
49885: PPUSH
49886: EMPTY
49887: PPUSH
49888: NOP4
49892: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
49893: NOP4
49897: PUSH
49898: NOP4
49902: PPUSH
49903: NOP4
49907: PPUSH
49908: LD_INT 0
49910: PPUSH
49911: NOP4
49915: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
49916: NOP4
49920: PUSH
49921: NOP4
49925: PPUSH
49926: NOP4
49930: PPUSH
49931: EMPTY
49932: PPUSH
49933: NOP4
49937: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
49938: NOP4
49942: PUSH
49943: NOP4
49947: PPUSH
49948: NOP4
49952: PPUSH
49953: EMPTY
49954: PPUSH
49955: NOP4
49959: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49960: NOP4
49964: PUSH
49965: NOP4
49969: PPUSH
49970: NOP4
49974: PPUSH
49975: EMPTY
49976: PPUSH
49977: NOP4
49981: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49982: NOP4
49986: PUSH
49987: NOP4
49991: PPUSH
49992: NOP4
49996: PPUSH
49997: EMPTY
49998: PPUSH
49999: NOP4
50003: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50004: NOP4
50008: PUSH
50009: NOP4
50013: PPUSH
50014: NOP4
50018: PPUSH
50019: EMPTY
50020: PPUSH
50021: NOP4
50025: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50026: NOP4
50030: PUSH
50031: NOP4
50035: PPUSH
50036: NOP4
50040: PPUSH
50041: EMPTY
50042: PPUSH
50043: NOP4
50047: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50048: NOP4
50052: PUSH
50053: NOP4
50057: PPUSH
50058: NOP4
50062: PPUSH
50063: EMPTY
50064: PPUSH
50065: NOP4
50069: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50070: NOP4
50074: PUSH
50075: NOP4
50079: PPUSH
50080: NOP4
50084: PPUSH
50085: EMPTY
50086: PPUSH
50087: NOP4
50091: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50092: NOP4
50096: PUSH
50097: NOP4
50101: PPUSH
50102: NOP4
50106: PPUSH
50107: EMPTY
50108: PPUSH
50109: NOP4
50113: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50114: NOP4
50118: PUSH
50119: NOP4
50123: PPUSH
50124: NOP4
50128: PPUSH
50129: EMPTY
50130: PPUSH
50131: NOP4
50135: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50136: NOP4
50140: PUSH
50141: NOP4
50145: PPUSH
50146: NOP4
50150: PPUSH
50151: EMPTY
50152: PPUSH
50153: NOP4
50157: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50158: NOP4
50162: PUSH
50163: NOP4
50167: PPUSH
50168: NOP4
50172: PPUSH
50173: EMPTY
50174: PPUSH
50175: NOP4
50179: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50180: NOP4
50184: PUSH
50185: NOP4
50189: PPUSH
50190: NOP4
50194: PPUSH
50195: EMPTY
50196: PPUSH
50197: NOP4
50201: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50202: NOP4
50206: PUSH
50207: NOP4
50211: PPUSH
50212: NOP4
50216: PPUSH
50217: EMPTY
50218: PPUSH
50219: NOP4
50223: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50224: NOP4
50228: PUSH
50229: NOP4
50233: PPUSH
50234: NOP4
50238: PPUSH
50239: EMPTY
50240: PPUSH
50241: NOP4
50245: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50246: NOP4
50250: PUSH
50251: NOP4
50255: PPUSH
50256: NOP4
50260: PPUSH
50261: EMPTY
50262: PPUSH
50263: NOP4
50267: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50268: NOP4
50272: PUSH
50273: NOP4
50277: PPUSH
50278: NOP4
50282: PPUSH
50283: EMPTY
50284: PPUSH
50285: NOP4
50289: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50290: NOP4
50294: PUSH
50295: NOP4
50299: PPUSH
50300: NOP4
50304: PPUSH
50305: EMPTY
50306: PPUSH
50307: NOP4
50311: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50312: NOP4
50316: PUSH
50317: NOP4
50321: PPUSH
50322: NOP4
50326: PPUSH
50327: EMPTY
50328: PPUSH
50329: NOP4
50333: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50334: NOP4
50338: PUSH
50339: NOP4
50343: PPUSH
50344: NOP4
50348: PPUSH
50349: EMPTY
50350: PPUSH
50351: NOP4
50355: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50356: NOP4
50360: PUSH
50361: NOP4
50365: PPUSH
50366: NOP4
50370: PPUSH
50371: EMPTY
50372: PPUSH
50373: NOP4
50377: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50378: NOP4
50382: PUSH
50383: NOP4
50387: PPUSH
50388: NOP4
50392: PPUSH
50393: EMPTY
50394: PPUSH
50395: NOP4
50399: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50400: NOP4
50404: PUSH
50405: NOP4
50409: PPUSH
50410: NOP4
50414: PPUSH
50415: EMPTY
50416: PPUSH
50417: NOP4
50421: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50422: NOP4
50426: PUSH
50427: NOP4
50431: PPUSH
50432: NOP4
50436: PPUSH
50437: EMPTY
50438: PPUSH
50439: NOP4
50443: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50444: NOP4
50448: PUSH
50449: NOP4
50453: PPUSH
50454: NOP4
50458: PPUSH
50459: EMPTY
50460: PPUSH
50461: NOP4
50465: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
50466: NOP4
50470: PUSH
50471: NOP4
50475: PPUSH
50476: NOP4
50480: PPUSH
50481: EMPTY
50482: PPUSH
50483: NOP4
50487: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
50488: NOP4
50492: PUSH
50493: NOP4
50497: PPUSH
50498: NOP4
50502: PPUSH
50503: EMPTY
50504: PPUSH
50505: NOP4
50509: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
50510: NOP4
50514: PUSH
50515: NOP4
50519: PPUSH
50520: NOP4
50524: PPUSH
50525: EMPTY
50526: PPUSH
50527: NOP4
50531: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
50532: NOP4
50536: PUSH
50537: NOP4
50541: PPUSH
50542: NOP4
50546: PPUSH
50547: LD_INT 0
50549: PPUSH
50550: NOP4
50554: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
50555: NOP4
50559: PUSH
50560: NOP4
50564: PPUSH
50565: NOP4
50569: PPUSH
50570: LD_INT 0
50572: PPUSH
50573: NOP4
50577: ST_TO_ADDR
// end ;
50578: LD_VAR 0 2
50582: RET
// export function MC_Add ( side , units ) ; var base ; begin
50583: LD_INT 0
50585: PPUSH
50586: PPUSH
// base := mc_bases + 1 ;
50587: NOP4
50591: PUSH
50592: NOP4
50596: PUSH
50597: LD_INT 1
50599: PLUS
50600: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
50601: NOP4
50605: PUSH
50606: NOP4
50610: PPUSH
50611: NOP4
50615: PPUSH
50616: NOP4
50620: PPUSH
50621: NOP4
50625: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
50626: NOP4
50630: PUSH
50631: NOP4
50635: PPUSH
50636: NOP4
50640: PPUSH
50641: NOP4
50645: PPUSH
50646: NOP4
50650: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50651: NOP4
50655: PUSH
50656: NOP4
50660: PPUSH
50661: NOP4
50665: PPUSH
50666: EMPTY
50667: PPUSH
50668: NOP4
50672: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50673: NOP4
50677: PUSH
50678: NOP4
50682: PPUSH
50683: NOP4
50687: PPUSH
50688: EMPTY
50689: PPUSH
50690: NOP4
50694: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50695: NOP4
50699: PUSH
50700: NOP4
50704: PPUSH
50705: NOP4
50709: PPUSH
50710: EMPTY
50711: PPUSH
50712: NOP4
50716: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50717: NOP4
50721: PUSH
50722: NOP4
50726: PPUSH
50727: NOP4
50731: PPUSH
50732: EMPTY
50733: PPUSH
50734: NOP4
50738: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50739: NOP4
50743: PUSH
50744: NOP4
50748: PPUSH
50749: NOP4
50753: PPUSH
50754: EMPTY
50755: PPUSH
50756: NOP4
50760: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50761: NOP4
50765: PUSH
50766: NOP4
50770: PPUSH
50771: NOP4
50775: PPUSH
50776: EMPTY
50777: PPUSH
50778: NOP4
50782: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50783: NOP4
50787: PUSH
50788: NOP4
50792: PPUSH
50793: NOP4
50797: PPUSH
50798: EMPTY
50799: PPUSH
50800: NOP4
50804: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50805: NOP4
50809: PUSH
50810: NOP4
50814: PPUSH
50815: NOP4
50819: PPUSH
50820: EMPTY
50821: PPUSH
50822: NOP4
50826: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50827: NOP4
50831: PUSH
50832: NOP4
50836: PPUSH
50837: NOP4
50841: PPUSH
50842: EMPTY
50843: PPUSH
50844: NOP4
50848: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50849: NOP4
50853: PUSH
50854: NOP4
50858: PPUSH
50859: NOP4
50863: PPUSH
50864: EMPTY
50865: PPUSH
50866: NOP4
50870: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50871: NOP4
50875: PUSH
50876: NOP4
50880: PPUSH
50881: NOP4
50885: PPUSH
50886: LD_INT 0
50888: PPUSH
50889: NOP4
50893: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50894: NOP4
50898: PUSH
50899: NOP4
50903: PPUSH
50904: NOP4
50908: PPUSH
50909: EMPTY
50910: PPUSH
50911: NOP4
50915: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50916: NOP4
50920: PUSH
50921: NOP4
50925: PPUSH
50926: NOP4
50930: PPUSH
50931: EMPTY
50932: PPUSH
50933: NOP4
50937: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50938: NOP4
50942: PUSH
50943: NOP4
50947: PPUSH
50948: NOP4
50952: PPUSH
50953: EMPTY
50954: PPUSH
50955: NOP4
50959: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50960: NOP4
50964: PUSH
50965: NOP4
50969: PPUSH
50970: NOP4
50974: PPUSH
50975: EMPTY
50976: PPUSH
50977: NOP4
50981: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50982: NOP4
50986: PUSH
50987: NOP4
50991: PPUSH
50992: NOP4
50996: PPUSH
50997: EMPTY
50998: PPUSH
50999: NOP4
51003: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51004: NOP4
51008: PUSH
51009: NOP4
51013: PPUSH
51014: NOP4
51018: PPUSH
51019: EMPTY
51020: PPUSH
51021: NOP4
51025: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51026: NOP4
51030: PUSH
51031: NOP4
51035: PPUSH
51036: NOP4
51040: PPUSH
51041: EMPTY
51042: PPUSH
51043: NOP4
51047: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51048: NOP4
51052: PUSH
51053: NOP4
51057: PPUSH
51058: NOP4
51062: PPUSH
51063: EMPTY
51064: PPUSH
51065: NOP4
51069: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51070: NOP4
51074: PUSH
51075: NOP4
51079: PPUSH
51080: NOP4
51084: PPUSH
51085: EMPTY
51086: PPUSH
51087: NOP4
51091: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51092: NOP4
51096: PUSH
51097: NOP4
51101: PPUSH
51102: NOP4
51106: PPUSH
51107: EMPTY
51108: PPUSH
51109: NOP4
51113: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51114: NOP4
51118: PUSH
51119: NOP4
51123: PPUSH
51124: NOP4
51128: PPUSH
51129: EMPTY
51130: PPUSH
51131: NOP4
51135: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51136: NOP4
51140: PUSH
51141: NOP4
51145: PPUSH
51146: NOP4
51150: PPUSH
51151: EMPTY
51152: PPUSH
51153: NOP4
51157: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51158: NOP4
51162: PUSH
51163: NOP4
51167: PPUSH
51168: NOP4
51172: PPUSH
51173: EMPTY
51174: PPUSH
51175: NOP4
51179: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51180: NOP4
51184: PUSH
51185: NOP4
51189: PPUSH
51190: NOP4
51194: PPUSH
51195: EMPTY
51196: PPUSH
51197: NOP4
51201: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51202: NOP4
51206: PUSH
51207: NOP4
51211: PPUSH
51212: NOP4
51216: PPUSH
51217: EMPTY
51218: PPUSH
51219: NOP4
51223: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51224: NOP4
51228: PUSH
51229: NOP4
51233: PPUSH
51234: NOP4
51238: PPUSH
51239: EMPTY
51240: PPUSH
51241: NOP4
51245: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51246: NOP4
51250: PUSH
51251: NOP4
51255: PPUSH
51256: NOP4
51260: PPUSH
51261: EMPTY
51262: PPUSH
51263: NOP4
51267: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51268: NOP4
51272: PUSH
51273: NOP4
51277: PPUSH
51278: NOP4
51282: PPUSH
51283: EMPTY
51284: PPUSH
51285: NOP4
51289: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51290: NOP4
51294: PUSH
51295: NOP4
51299: PPUSH
51300: NOP4
51304: PPUSH
51305: EMPTY
51306: PPUSH
51307: NOP4
51311: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51312: NOP4
51316: PUSH
51317: NOP4
51321: PPUSH
51322: NOP4
51326: PPUSH
51327: EMPTY
51328: PPUSH
51329: NOP4
51333: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51334: NOP4
51338: PUSH
51339: NOP4
51343: PPUSH
51344: NOP4
51348: PPUSH
51349: EMPTY
51350: PPUSH
51351: NOP4
51355: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51356: NOP4
51360: PUSH
51361: NOP4
51365: PPUSH
51366: NOP4
51370: PPUSH
51371: EMPTY
51372: PPUSH
51373: NOP4
51377: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51378: NOP4
51382: PUSH
51383: NOP4
51387: PPUSH
51388: NOP4
51392: PPUSH
51393: EMPTY
51394: PPUSH
51395: NOP4
51399: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51400: NOP4
51404: PUSH
51405: NOP4
51409: PPUSH
51410: NOP4
51414: PPUSH
51415: EMPTY
51416: PPUSH
51417: NOP4
51421: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51422: NOP4
51426: PUSH
51427: NOP4
51431: PPUSH
51432: NOP4
51436: PPUSH
51437: EMPTY
51438: PPUSH
51439: NOP4
51443: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51444: NOP4
51448: PUSH
51449: NOP4
51453: PPUSH
51454: NOP4
51458: PPUSH
51459: EMPTY
51460: PPUSH
51461: NOP4
51465: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51466: NOP4
51470: PUSH
51471: NOP4
51475: PPUSH
51476: NOP4
51480: PPUSH
51481: EMPTY
51482: PPUSH
51483: NOP4
51487: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51488: NOP4
51492: PUSH
51493: NOP4
51497: PPUSH
51498: NOP4
51502: PPUSH
51503: EMPTY
51504: PPUSH
51505: NOP4
51509: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51510: NOP4
51514: PUSH
51515: NOP4
51519: PPUSH
51520: NOP4
51524: PPUSH
51525: LD_INT 0
51527: PPUSH
51528: NOP4
51532: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51533: NOP4
51537: PUSH
51538: NOP4
51542: PPUSH
51543: NOP4
51547: PPUSH
51548: LD_INT 0
51550: PPUSH
51551: NOP4
51555: ST_TO_ADDR
// result := base ;
51556: NOP4
51560: PUSH
51561: NOP4
51565: ST_TO_ADDR
// end ;
51566: LD_VAR 0 3
51570: RET
// export function MC_Start ( ) ; var i ; begin
51571: LD_INT 0
51573: PPUSH
51574: PPUSH
// for i = 1 to mc_bases do
51575: NOP4
51579: PUSH
51580: DOUBLE
51581: LD_INT 1
51583: DEC
51584: ST_TO_ADDR
51585: NOP4
51589: PUSH
51590: FOR_TO
51591: IFFALSE 52691
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
51593: NOP4
51597: PUSH
51598: NOP4
51602: PPUSH
51603: NOP4
51607: PPUSH
51608: NOP4
51612: PUSH
51613: NOP4
51617: ARRAY
51618: PUSH
51619: LD_INT 0
51621: DIFF
51622: PPUSH
51623: NOP4
51627: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
51628: NOP4
51632: PUSH
51633: NOP4
51637: PPUSH
51638: NOP4
51642: PPUSH
51643: EMPTY
51644: PPUSH
51645: NOP4
51649: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
51650: NOP4
51654: PUSH
51655: NOP4
51659: PPUSH
51660: NOP4
51664: PPUSH
51665: EMPTY
51666: PPUSH
51667: NOP4
51671: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
51672: NOP4
51676: PUSH
51677: NOP4
51681: PPUSH
51682: NOP4
51686: PPUSH
51687: EMPTY
51688: PPUSH
51689: NOP4
51693: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
51694: NOP4
51698: PUSH
51699: NOP4
51703: PPUSH
51704: NOP4
51708: PPUSH
51709: EMPTY
51710: PUSH
51711: EMPTY
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: PPUSH
51717: NOP4
51721: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
51722: NOP4
51726: PUSH
51727: NOP4
51731: PPUSH
51732: NOP4
51736: PPUSH
51737: EMPTY
51738: PPUSH
51739: NOP4
51743: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
51744: NOP4
51748: PUSH
51749: NOP4
51753: PPUSH
51754: NOP4
51758: PPUSH
51759: EMPTY
51760: PPUSH
51761: NOP4
51765: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
51766: NOP4
51770: PUSH
51771: NOP4
51775: PPUSH
51776: NOP4
51780: PPUSH
51781: EMPTY
51782: PPUSH
51783: NOP4
51787: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
51788: NOP4
51792: PUSH
51793: NOP4
51797: PPUSH
51798: NOP4
51802: PPUSH
51803: EMPTY
51804: PPUSH
51805: NOP4
51809: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
51810: NOP4
51814: PUSH
51815: NOP4
51819: PPUSH
51820: NOP4
51824: PPUSH
51825: NOP4
51829: PUSH
51830: NOP4
51834: ARRAY
51835: PPUSH
51836: LD_INT 2
51838: PUSH
51839: LD_INT 30
51841: PUSH
51842: LD_INT 32
51844: PUSH
51845: EMPTY
51846: LIST
51847: LIST
51848: PUSH
51849: LD_INT 30
51851: PUSH
51852: LD_INT 33
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: LIST
51863: PPUSH
51864: NOP4
51868: PPUSH
51869: NOP4
51873: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
51874: NOP4
51878: PUSH
51879: NOP4
51883: PPUSH
51884: NOP4
51888: PPUSH
51889: NOP4
51893: PUSH
51894: NOP4
51898: ARRAY
51899: PPUSH
51900: LD_INT 2
51902: PUSH
51903: LD_INT 30
51905: PUSH
51906: LD_INT 32
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: LD_INT 30
51915: PUSH
51916: LD_INT 31
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: PUSH
51923: EMPTY
51924: LIST
51925: LIST
51926: LIST
51927: PUSH
51928: LD_INT 58
51930: PUSH
51931: EMPTY
51932: LIST
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PPUSH
51938: NOP4
51942: PPUSH
51943: NOP4
51947: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
51948: NOP4
51952: PUSH
51953: NOP4
51957: PPUSH
51958: NOP4
51962: PPUSH
51963: EMPTY
51964: PPUSH
51965: NOP4
51969: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
51970: NOP4
51974: PUSH
51975: NOP4
51979: PPUSH
51980: NOP4
51984: PPUSH
51985: EMPTY
51986: PPUSH
51987: NOP4
51991: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
51992: NOP4
51996: PUSH
51997: NOP4
52001: PPUSH
52002: NOP4
52006: PPUSH
52007: EMPTY
52008: PPUSH
52009: NOP4
52013: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52014: NOP4
52018: PUSH
52019: NOP4
52023: PPUSH
52024: NOP4
52028: PPUSH
52029: EMPTY
52030: PPUSH
52031: NOP4
52035: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52036: NOP4
52040: PUSH
52041: NOP4
52045: PPUSH
52046: NOP4
52050: PPUSH
52051: EMPTY
52052: PPUSH
52053: NOP4
52057: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52058: NOP4
52062: PUSH
52063: NOP4
52067: PPUSH
52068: NOP4
52072: PPUSH
52073: EMPTY
52074: PPUSH
52075: NOP4
52079: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52080: NOP4
52084: PUSH
52085: NOP4
52089: PPUSH
52090: NOP4
52094: PPUSH
52095: EMPTY
52096: PPUSH
52097: NOP4
52101: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52102: NOP4
52106: PUSH
52107: NOP4
52111: PPUSH
52112: NOP4
52116: PPUSH
52117: EMPTY
52118: PPUSH
52119: NOP4
52123: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52124: NOP4
52128: PUSH
52129: NOP4
52133: PPUSH
52134: NOP4
52138: PPUSH
52139: EMPTY
52140: PPUSH
52141: NOP4
52145: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52146: NOP4
52150: PUSH
52151: NOP4
52155: PPUSH
52156: NOP4
52160: PPUSH
52161: EMPTY
52162: PPUSH
52163: NOP4
52167: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52168: NOP4
52172: PUSH
52173: NOP4
52177: PPUSH
52178: NOP4
52182: PPUSH
52183: EMPTY
52184: PPUSH
52185: NOP4
52189: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52190: NOP4
52194: PUSH
52195: NOP4
52199: PPUSH
52200: NOP4
52204: PPUSH
52205: LD_INT 0
52207: PPUSH
52208: NOP4
52212: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52213: NOP4
52217: PUSH
52218: NOP4
52222: PPUSH
52223: NOP4
52227: PPUSH
52228: LD_INT 0
52230: PPUSH
52231: NOP4
52235: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52236: NOP4
52240: PUSH
52241: NOP4
52245: PPUSH
52246: NOP4
52250: PPUSH
52251: EMPTY
52252: PPUSH
52253: NOP4
52257: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52258: NOP4
52262: PUSH
52263: NOP4
52267: PPUSH
52268: NOP4
52272: PPUSH
52273: LD_INT 0
52275: PPUSH
52276: NOP4
52280: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52281: NOP4
52285: PUSH
52286: NOP4
52290: PPUSH
52291: NOP4
52295: PPUSH
52296: EMPTY
52297: PPUSH
52298: NOP4
52302: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52303: NOP4
52307: PUSH
52308: NOP4
52312: PPUSH
52313: NOP4
52317: PPUSH
52318: LD_INT 0
52320: PPUSH
52321: NOP4
52325: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52326: NOP4
52330: PUSH
52331: NOP4
52335: PPUSH
52336: NOP4
52340: PPUSH
52341: EMPTY
52342: PPUSH
52343: NOP4
52347: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52348: NOP4
52352: PUSH
52353: NOP4
52357: PPUSH
52358: NOP4
52362: PPUSH
52363: EMPTY
52364: PPUSH
52365: NOP4
52369: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52370: NOP4
52374: PUSH
52375: NOP4
52379: PPUSH
52380: NOP4
52384: PPUSH
52385: EMPTY
52386: PPUSH
52387: NOP4
52391: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52392: NOP4
52396: PUSH
52397: NOP4
52401: PPUSH
52402: NOP4
52406: PPUSH
52407: NOP4
52411: PUSH
52412: NOP4
52416: ARRAY
52417: PPUSH
52418: LD_INT 2
52420: PUSH
52421: LD_INT 30
52423: PUSH
52424: LD_INT 6
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: PUSH
52431: LD_INT 30
52433: PUSH
52434: LD_INT 7
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: PUSH
52441: LD_INT 30
52443: PUSH
52444: LD_INT 8
52446: PUSH
52447: EMPTY
52448: LIST
52449: LIST
52450: PUSH
52451: EMPTY
52452: LIST
52453: LIST
52454: LIST
52455: LIST
52456: PPUSH
52457: NOP4
52461: PPUSH
52462: NOP4
52466: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
52467: NOP4
52471: PUSH
52472: NOP4
52476: PPUSH
52477: NOP4
52481: PPUSH
52482: EMPTY
52483: PPUSH
52484: NOP4
52488: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
52489: NOP4
52493: PUSH
52494: NOP4
52498: PPUSH
52499: NOP4
52503: PPUSH
52504: EMPTY
52505: PPUSH
52506: NOP4
52510: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
52511: NOP4
52515: PUSH
52516: NOP4
52520: PPUSH
52521: NOP4
52525: PPUSH
52526: EMPTY
52527: PPUSH
52528: NOP4
52532: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
52533: NOP4
52537: PUSH
52538: NOP4
52542: PPUSH
52543: NOP4
52547: PPUSH
52548: EMPTY
52549: PPUSH
52550: NOP4
52554: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52555: NOP4
52559: PUSH
52560: NOP4
52564: PPUSH
52565: NOP4
52569: PPUSH
52570: EMPTY
52571: PPUSH
52572: NOP4
52576: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
52577: NOP4
52581: PUSH
52582: NOP4
52586: PPUSH
52587: NOP4
52591: PPUSH
52592: EMPTY
52593: PPUSH
52594: NOP4
52598: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
52599: NOP4
52603: PUSH
52604: NOP4
52608: PPUSH
52609: NOP4
52613: PPUSH
52614: EMPTY
52615: PPUSH
52616: NOP4
52620: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
52621: NOP4
52625: PUSH
52626: NOP4
52630: PPUSH
52631: NOP4
52635: PPUSH
52636: EMPTY
52637: PPUSH
52638: NOP4
52642: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
52643: NOP4
52647: PUSH
52648: NOP4
52652: PPUSH
52653: NOP4
52657: PPUSH
52658: LD_INT 0
52660: PPUSH
52661: NOP4
52665: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52666: NOP4
52670: PUSH
52671: NOP4
52675: PPUSH
52676: NOP4
52680: PPUSH
52681: LD_INT 0
52683: PPUSH
52684: NOP4
52688: ST_TO_ADDR
// end ;
52689: GO 51590
52691: POP
52692: POP
// MC_InitSides ( ) ;
52693: NOP4
// MC_InitResearch ( ) ;
52697: NOP4
// CustomInitMacro ( ) ;
52701: NOP4
// skirmish := true ;
52705: NOP4
52709: PUSH
52710: LD_INT 1
52712: ST_TO_ADDR
// end ;
52713: LD_VAR 0 1
52717: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
52718: LD_INT 0
52720: PPUSH
52721: PPUSH
52722: PPUSH
52723: PPUSH
52724: PPUSH
52725: PPUSH
// if not mc_bases then
52726: NOP4
52730: NOT
52731: IFFALSE 52735
// exit ;
52733: GO 52974
// for i = 1 to 8 do
52735: NOP4
52739: PUSH
52740: DOUBLE
52741: LD_INT 1
52743: DEC
52744: ST_TO_ADDR
52745: LD_INT 8
52747: PUSH
52748: FOR_TO
52749: IFFALSE 52775
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
52751: NOP4
52755: PUSH
52756: NOP4
52760: PPUSH
52761: NOP4
52765: PPUSH
52766: EMPTY
52767: PPUSH
52768: NOP4
52772: ST_TO_ADDR
52773: GO 52748
52775: POP
52776: POP
// tmp := [ ] ;
52777: NOP4
52781: PUSH
52782: EMPTY
52783: ST_TO_ADDR
// for i = 1 to mc_sides do
52784: NOP4
52788: PUSH
52789: DOUBLE
52790: LD_INT 1
52792: DEC
52793: ST_TO_ADDR
52794: NOP4
52798: PUSH
52799: FOR_TO
52800: IFFALSE 52858
// if not mc_sides [ i ] in tmp then
52802: NOP4
52806: PUSH
52807: NOP4
52811: ARRAY
52812: PUSH
52813: NOP4
52817: IN
52818: NOT
52819: IFFALSE 52856
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
52821: NOP4
52825: PUSH
52826: NOP4
52830: PPUSH
52831: NOP4
52835: PUSH
52836: LD_INT 1
52838: PLUS
52839: PPUSH
52840: NOP4
52844: PUSH
52845: NOP4
52849: ARRAY
52850: PPUSH
52851: NOP4
52855: ST_TO_ADDR
52856: GO 52799
52858: POP
52859: POP
// if not tmp then
52860: NOP4
52864: NOT
52865: IFFALSE 52869
// exit ;
52867: GO 52974
// for j in tmp do
52869: NOP4
52873: PUSH
52874: NOP4
52878: PUSH
52879: FOR_IN
52880: IFFALSE 52972
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
52882: NOP4
52886: PUSH
52887: LD_INT 22
52889: PUSH
52890: NOP4
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: PPUSH
52899: NOP4
52903: ST_TO_ADDR
// if not un then
52904: NOP4
52908: NOT
52909: IFFALSE 52913
// continue ;
52911: GO 52879
// nation := GetNation ( un [ 1 ] ) ;
52913: NOP4
52917: PUSH
52918: NOP4
52922: PUSH
52923: LD_INT 1
52925: ARRAY
52926: PPUSH
52927: NOP4
52931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
52932: NOP4
52936: PUSH
52937: NOP4
52941: PPUSH
52942: NOP4
52946: PPUSH
52947: NOP4
52951: PPUSH
52952: NOP4
52956: PPUSH
52957: LD_INT 1
52959: PPUSH
52960: NOP4
52964: PPUSH
52965: NOP4
52969: ST_TO_ADDR
// end ;
52970: GO 52879
52972: POP
52973: POP
// end ;
52974: LD_VAR 0 1
52978: RET
// export function MC_InitSides ( ) ; var i ; begin
52979: LD_INT 0
52981: PPUSH
52982: PPUSH
// if not mc_bases then
52983: NOP4
52987: NOT
52988: IFFALSE 52992
// exit ;
52990: GO 53066
// for i = 1 to mc_bases do
52992: NOP4
52996: PUSH
52997: DOUBLE
52998: LD_INT 1
53000: DEC
53001: ST_TO_ADDR
53002: NOP4
53006: PUSH
53007: FOR_TO
53008: IFFALSE 53064
// if mc_bases [ i ] then
53010: NOP4
53014: PUSH
53015: NOP4
53019: ARRAY
53020: IFFALSE 53062
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53022: NOP4
53026: PUSH
53027: NOP4
53031: PPUSH
53032: NOP4
53036: PPUSH
53037: NOP4
53041: PUSH
53042: NOP4
53046: ARRAY
53047: PUSH
53048: LD_INT 1
53050: ARRAY
53051: PPUSH
53052: NOP4
53056: PPUSH
53057: NOP4
53061: ST_TO_ADDR
53062: GO 53007
53064: POP
53065: POP
// end ;
53066: LD_VAR 0 1
53070: RET
// every 0 0$03 trigger skirmish do
53071: NOP4
53075: IFFALSE 53229
53077: GO 53079
53079: DISABLE
// begin enable ;
53080: ENABLE
// MC_CheckBuildings ( ) ;
53081: NOP4
// MC_CheckPeopleLife ( ) ;
53085: NOP4
// RaiseSailEvent ( 100 ) ;
53089: LD_INT 100
53091: PPUSH
53092: NOP4
// RaiseSailEvent ( 103 ) ;
53096: LD_INT 103
53098: PPUSH
53099: NOP4
// RaiseSailEvent ( 104 ) ;
53103: LD_INT 104
53105: PPUSH
53106: NOP4
// RaiseSailEvent ( 105 ) ;
53110: LD_INT 105
53112: PPUSH
53113: NOP4
// RaiseSailEvent ( 106 ) ;
53117: LD_INT 106
53119: PPUSH
53120: NOP4
// RaiseSailEvent ( 107 ) ;
53124: LD_INT 107
53126: PPUSH
53127: NOP4
// RaiseSailEvent ( 108 ) ;
53131: LD_INT 108
53133: PPUSH
53134: NOP4
// RaiseSailEvent ( 109 ) ;
53138: LD_INT 109
53140: PPUSH
53141: NOP4
// RaiseSailEvent ( 110 ) ;
53145: LD_INT 110
53147: PPUSH
53148: NOP4
// RaiseSailEvent ( 111 ) ;
53152: LD_INT 111
53154: PPUSH
53155: NOP4
// RaiseSailEvent ( 112 ) ;
53159: LD_INT 112
53161: PPUSH
53162: NOP4
// RaiseSailEvent ( 113 ) ;
53166: LD_INT 113
53168: PPUSH
53169: NOP4
// RaiseSailEvent ( 120 ) ;
53173: LD_INT 120
53175: PPUSH
53176: NOP4
// RaiseSailEvent ( 121 ) ;
53180: LD_INT 121
53182: PPUSH
53183: NOP4
// RaiseSailEvent ( 122 ) ;
53187: LD_INT 122
53189: PPUSH
53190: NOP4
// RaiseSailEvent ( 123 ) ;
53194: LD_INT 123
53196: PPUSH
53197: NOP4
// RaiseSailEvent ( 124 ) ;
53201: LD_INT 124
53203: PPUSH
53204: NOP4
// RaiseSailEvent ( 125 ) ;
53208: LD_INT 125
53210: PPUSH
53211: NOP4
// RaiseSailEvent ( 126 ) ;
53215: LD_INT 126
53217: PPUSH
53218: NOP4
// RaiseSailEvent ( 200 ) ;
53222: LD_INT 200
53224: PPUSH
53225: NOP4
// end ;
53229: END
// on SailEvent ( event ) do begin if event < 100 then
53230: NOP4
53234: PUSH
53235: LD_INT 100
53237: LESS
53238: IFFALSE 53249
// CustomEvent ( event ) ;
53240: NOP4
53244: PPUSH
53245: NOP4
// if event = 100 then
53249: NOP4
53253: PUSH
53254: LD_INT 100
53256: EQUAL
53257: IFFALSE 53263
// MC_ClassManager ( ) ;
53259: NOP4
// if event = 101 then
53263: NOP4
53267: PUSH
53268: LD_INT 101
53270: EQUAL
53271: IFFALSE 53277
// MC_RepairBuildings ( ) ;
53273: NOP4
// if event = 102 then
53277: NOP4
53281: PUSH
53282: LD_INT 102
53284: EQUAL
53285: IFFALSE 53291
// MC_Heal ( ) ;
53287: NOP4
// if event = 103 then
53291: NOP4
53295: PUSH
53296: LD_INT 103
53298: EQUAL
53299: IFFALSE 53305
// MC_Build ( ) ;
53301: NOP4
// if event = 104 then
53305: NOP4
53309: PUSH
53310: LD_INT 104
53312: EQUAL
53313: IFFALSE 53319
// MC_TurretWeapon ( ) ;
53315: NOP4
// if event = 105 then
53319: NOP4
53323: PUSH
53324: LD_INT 105
53326: EQUAL
53327: IFFALSE 53333
// MC_BuildUpgrade ( ) ;
53329: NOP4
// if event = 106 then
53333: NOP4
53337: PUSH
53338: LD_INT 106
53340: EQUAL
53341: IFFALSE 53347
// MC_PlantMines ( ) ;
53343: NOP4
// if event = 107 then
53347: NOP4
53351: PUSH
53352: LD_INT 107
53354: EQUAL
53355: IFFALSE 53361
// MC_CollectCrates ( ) ;
53357: NOP4
// if event = 108 then
53361: NOP4
53365: PUSH
53366: LD_INT 108
53368: EQUAL
53369: IFFALSE 53375
// MC_LinkRemoteControl ( ) ;
53371: NOP4
// if event = 109 then
53375: NOP4
53379: PUSH
53380: LD_INT 109
53382: EQUAL
53383: IFFALSE 53389
// MC_ProduceVehicle ( ) ;
53385: NOP4
// if event = 110 then
53389: NOP4
53393: PUSH
53394: LD_INT 110
53396: EQUAL
53397: IFFALSE 53403
// MC_SendAttack ( ) ;
53399: NOP4
// if event = 111 then
53403: NOP4
53407: PUSH
53408: LD_INT 111
53410: EQUAL
53411: IFFALSE 53417
// MC_Defend ( ) ;
53413: NOP4
// if event = 112 then
53417: NOP4
53421: PUSH
53422: LD_INT 112
53424: EQUAL
53425: IFFALSE 53431
// MC_Research ( ) ;
53427: NOP4
// if event = 113 then
53431: NOP4
53435: PUSH
53436: LD_INT 113
53438: EQUAL
53439: IFFALSE 53445
// MC_MinesTrigger ( ) ;
53441: NOP4
// if event = 120 then
53445: NOP4
53449: PUSH
53450: LD_INT 120
53452: EQUAL
53453: IFFALSE 53459
// MC_RepairVehicle ( ) ;
53455: NOP4
// if event = 121 then
53459: NOP4
53463: PUSH
53464: LD_INT 121
53466: EQUAL
53467: IFFALSE 53473
// MC_TameApe ( ) ;
53469: NOP4
// if event = 122 then
53473: NOP4
53477: PUSH
53478: LD_INT 122
53480: EQUAL
53481: IFFALSE 53487
// MC_ChangeApeClass ( ) ;
53483: NOP4
// if event = 123 then
53487: NOP4
53491: PUSH
53492: LD_INT 123
53494: EQUAL
53495: IFFALSE 53501
// MC_Bazooka ( ) ;
53497: NOP4
// if event = 124 then
53501: NOP4
53505: PUSH
53506: LD_INT 124
53508: EQUAL
53509: IFFALSE 53515
// MC_TeleportExit ( ) ;
53511: NOP4
// if event = 125 then
53515: NOP4
53519: PUSH
53520: LD_INT 125
53522: EQUAL
53523: IFFALSE 53529
// MC_Deposits ( ) ;
53525: NOP4
// if event = 126 then
53529: NOP4
53533: PUSH
53534: LD_INT 126
53536: EQUAL
53537: IFFALSE 53543
// MC_RemoteDriver ( ) ;
53539: NOP4
// if event = 200 then
53543: NOP4
53547: PUSH
53548: LD_INT 200
53550: EQUAL
53551: IFFALSE 53557
// MC_Idle ( ) ;
53553: NOP4
// end ;
53557: PPOPN 1
53559: END
// export function MC_Reset ( base , tag ) ; var i ; begin
53560: LD_INT 0
53562: PPUSH
53563: PPUSH
// if not mc_bases [ base ] or not tag then
53564: NOP4
53568: PUSH
53569: NOP4
53573: ARRAY
53574: NOT
53575: PUSH
53576: NOP4
53580: NOT
53581: OR
53582: IFFALSE 53586
// exit ;
53584: GO 53650
// for i in mc_bases [ base ] union mc_ape [ base ] do
53586: NOP4
53590: PUSH
53591: NOP4
53595: PUSH
53596: NOP4
53600: ARRAY
53601: PUSH
53602: NOP4
53606: PUSH
53607: NOP4
53611: ARRAY
53612: UNION
53613: PUSH
53614: FOR_IN
53615: IFFALSE 53648
// if GetTag ( i ) = tag then
53617: NOP4
53621: PPUSH
53622: NOP4
53626: PUSH
53627: NOP4
53631: EQUAL
53632: IFFALSE 53646
// SetTag ( i , 0 ) ;
53634: NOP4
53638: PPUSH
53639: LD_INT 0
53641: PPUSH
53642: NOP4
53646: GO 53614
53648: POP
53649: POP
// end ;
53650: LD_VAR 0 3
53654: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
53655: LD_INT 0
53657: PPUSH
53658: PPUSH
53659: PPUSH
53660: PPUSH
53661: PPUSH
53662: PPUSH
53663: PPUSH
53664: PPUSH
// if not mc_bases then
53665: NOP4
53669: NOT
53670: IFFALSE 53674
// exit ;
53672: GO 54132
// for i = 1 to mc_bases do
53674: NOP4
53678: PUSH
53679: DOUBLE
53680: LD_INT 1
53682: DEC
53683: ST_TO_ADDR
53684: NOP4
53688: PUSH
53689: FOR_TO
53690: IFFALSE 54130
// begin tmp := MC_ClassCheckReq ( i ) ;
53692: NOP4
53696: PUSH
53697: NOP4
53701: PPUSH
53702: NOP4
53706: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
53707: NOP4
53711: PUSH
53712: NOP4
53716: PPUSH
53717: NOP4
53721: PPUSH
53722: NOP4
53726: PPUSH
53727: NOP4
53731: ST_TO_ADDR
// if not tmp then
53732: NOP4
53736: NOT
53737: IFFALSE 53741
// continue ;
53739: GO 53689
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
53741: NOP4
53745: PUSH
53746: NOP4
53750: PUSH
53751: NOP4
53755: ARRAY
53756: PPUSH
53757: LD_INT 2
53759: PUSH
53760: LD_INT 30
53762: PUSH
53763: LD_INT 4
53765: PUSH
53766: EMPTY
53767: LIST
53768: LIST
53769: PUSH
53770: LD_INT 30
53772: PUSH
53773: LD_INT 5
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PUSH
53780: EMPTY
53781: LIST
53782: LIST
53783: LIST
53784: PPUSH
53785: NOP4
53789: PUSH
53790: NOP4
53794: PUSH
53795: NOP4
53799: ARRAY
53800: PPUSH
53801: LD_INT 2
53803: PUSH
53804: LD_INT 30
53806: PUSH
53807: LD_INT 0
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PUSH
53814: LD_INT 30
53816: PUSH
53817: LD_INT 1
53819: PUSH
53820: EMPTY
53821: LIST
53822: LIST
53823: PUSH
53824: EMPTY
53825: LIST
53826: LIST
53827: LIST
53828: PPUSH
53829: NOP4
53833: PUSH
53834: NOP4
53838: PUSH
53839: NOP4
53843: ARRAY
53844: PPUSH
53845: LD_INT 30
53847: PUSH
53848: LD_INT 3
53850: PUSH
53851: EMPTY
53852: LIST
53853: LIST
53854: PPUSH
53855: NOP4
53859: PUSH
53860: NOP4
53864: PUSH
53865: NOP4
53869: ARRAY
53870: PPUSH
53871: LD_INT 2
53873: PUSH
53874: LD_INT 30
53876: PUSH
53877: LD_INT 6
53879: PUSH
53880: EMPTY
53881: LIST
53882: LIST
53883: PUSH
53884: LD_INT 30
53886: PUSH
53887: LD_INT 7
53889: PUSH
53890: EMPTY
53891: LIST
53892: LIST
53893: PUSH
53894: LD_INT 30
53896: PUSH
53897: LD_INT 8
53899: PUSH
53900: EMPTY
53901: LIST
53902: LIST
53903: PUSH
53904: EMPTY
53905: LIST
53906: LIST
53907: LIST
53908: LIST
53909: PPUSH
53910: NOP4
53914: PUSH
53915: EMPTY
53916: LIST
53917: LIST
53918: LIST
53919: LIST
53920: ST_TO_ADDR
// for j = 1 to 4 do
53921: NOP4
53925: PUSH
53926: DOUBLE
53927: LD_INT 1
53929: DEC
53930: ST_TO_ADDR
53931: LD_INT 4
53933: PUSH
53934: FOR_TO
53935: IFFALSE 54126
// begin if not tmp [ j ] then
53937: NOP4
53941: PUSH
53942: NOP4
53946: ARRAY
53947: NOT
53948: IFFALSE 53952
// continue ;
53950: GO 53934
// for p in tmp [ j ] do
53952: NOP4
53956: PUSH
53957: NOP4
53961: PUSH
53962: NOP4
53966: ARRAY
53967: PUSH
53968: FOR_IN
53969: IFFALSE 54122
// begin if not b [ j ] then
53971: NOP4
53975: PUSH
53976: NOP4
53980: ARRAY
53981: NOT
53982: IFFALSE 53986
// break ;
53984: GO 54122
// e := 0 ;
53986: NOP4
53990: PUSH
53991: LD_INT 0
53993: ST_TO_ADDR
// for k in b [ j ] do
53994: NOP4
53998: PUSH
53999: NOP4
54003: PUSH
54004: NOP4
54008: ARRAY
54009: PUSH
54010: FOR_IN
54011: IFFALSE 54038
// if IsNotFull ( k ) then
54013: NOP4
54017: PPUSH
54018: NOP4
54022: IFFALSE 54036
// begin e := k ;
54024: NOP4
54028: PUSH
54029: NOP4
54033: ST_TO_ADDR
// break ;
54034: GO 54038
// end ;
54036: GO 54010
54038: POP
54039: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54040: NOP4
54044: PUSH
54045: NOP4
54049: PPUSH
54050: NOP4
54054: PPUSH
54055: NOP4
54059: NOT
54060: AND
54061: IFFALSE 54120
// begin if IsInUnit ( p ) then
54063: NOP4
54067: PPUSH
54068: NOP4
54072: IFFALSE 54083
// ComExitBuilding ( p ) ;
54074: NOP4
54078: PPUSH
54079: NOP4
// ComEnterUnit ( p , e ) ;
54083: NOP4
54087: PPUSH
54088: NOP4
54092: PPUSH
54093: NOP4
// AddComChangeProfession ( p , j ) ;
54097: NOP4
54101: PPUSH
54102: NOP4
54106: PPUSH
54107: NOP4
// AddComExitBuilding ( p ) ;
54111: NOP4
54115: PPUSH
54116: NOP4
// end ; end ;
54120: GO 53968
54122: POP
54123: POP
// end ;
54124: GO 53934
54126: POP
54127: POP
// end ;
54128: GO 53689
54130: POP
54131: POP
// end ;
54132: LD_VAR 0 1
54136: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54137: LD_INT 0
54139: PPUSH
54140: PPUSH
54141: PPUSH
54142: PPUSH
54143: PPUSH
54144: PPUSH
54145: PPUSH
54146: PPUSH
54147: PPUSH
54148: PPUSH
54149: PPUSH
54150: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54151: NOP4
54155: NOT
54156: PUSH
54157: NOP4
54161: PUSH
54162: NOP4
54166: ARRAY
54167: NOT
54168: OR
54169: PUSH
54170: NOP4
54174: PUSH
54175: NOP4
54179: ARRAY
54180: PPUSH
54181: LD_INT 2
54183: PUSH
54184: LD_INT 30
54186: PUSH
54187: LD_INT 0
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: PUSH
54194: LD_INT 30
54196: PUSH
54197: LD_INT 1
54199: PUSH
54200: EMPTY
54201: LIST
54202: LIST
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PPUSH
54209: NOP4
54213: NOT
54214: OR
54215: IFFALSE 54219
// exit ;
54217: GO 57722
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54219: NOP4
54223: PUSH
54224: NOP4
54228: PUSH
54229: NOP4
54233: ARRAY
54234: PPUSH
54235: LD_INT 2
54237: PUSH
54238: LD_INT 25
54240: PUSH
54241: LD_INT 1
54243: PUSH
54244: EMPTY
54245: LIST
54246: LIST
54247: PUSH
54248: LD_INT 25
54250: PUSH
54251: LD_INT 2
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PUSH
54258: LD_INT 25
54260: PUSH
54261: LD_INT 3
54263: PUSH
54264: EMPTY
54265: LIST
54266: LIST
54267: PUSH
54268: LD_INT 25
54270: PUSH
54271: LD_INT 4
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: PUSH
54278: LD_INT 25
54280: PUSH
54281: LD_INT 5
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: PUSH
54288: LD_INT 25
54290: PUSH
54291: LD_INT 8
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PUSH
54298: LD_INT 25
54300: PUSH
54301: LD_INT 9
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: LIST
54315: LIST
54316: LIST
54317: PPUSH
54318: NOP4
54322: ST_TO_ADDR
// if not tmp then
54323: NOP4
54327: NOT
54328: IFFALSE 54332
// exit ;
54330: GO 57722
// for i in tmp do
54332: NOP4
54336: PUSH
54337: NOP4
54341: PUSH
54342: FOR_IN
54343: IFFALSE 54374
// if GetTag ( i ) then
54345: NOP4
54349: PPUSH
54350: NOP4
54354: IFFALSE 54372
// tmp := tmp diff i ;
54356: NOP4
54360: PUSH
54361: NOP4
54365: PUSH
54366: NOP4
54370: DIFF
54371: ST_TO_ADDR
54372: GO 54342
54374: POP
54375: POP
// if not tmp then
54376: NOP4
54380: NOT
54381: IFFALSE 54385
// exit ;
54383: GO 57722
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54385: NOP4
54389: PUSH
54390: NOP4
54394: PUSH
54395: NOP4
54399: ARRAY
54400: PPUSH
54401: LD_INT 2
54403: PUSH
54404: LD_INT 25
54406: PUSH
54407: LD_INT 1
54409: PUSH
54410: EMPTY
54411: LIST
54412: LIST
54413: PUSH
54414: LD_INT 25
54416: PUSH
54417: LD_INT 5
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: PUSH
54424: LD_INT 25
54426: PUSH
54427: LD_INT 8
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: PUSH
54434: LD_INT 25
54436: PUSH
54437: LD_INT 9
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PUSH
54444: EMPTY
54445: LIST
54446: LIST
54447: LIST
54448: LIST
54449: LIST
54450: PPUSH
54451: NOP4
54455: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
54456: NOP4
54460: PUSH
54461: NOP4
54465: PUSH
54466: NOP4
54470: ARRAY
54471: PPUSH
54472: LD_INT 25
54474: PUSH
54475: LD_INT 2
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: PPUSH
54482: NOP4
54486: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
54487: NOP4
54491: PUSH
54492: NOP4
54496: PUSH
54497: NOP4
54501: ARRAY
54502: PPUSH
54503: LD_INT 25
54505: PUSH
54506: LD_INT 3
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: PPUSH
54513: NOP4
54517: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
54518: NOP4
54522: PUSH
54523: NOP4
54527: PUSH
54528: NOP4
54532: ARRAY
54533: PPUSH
54534: LD_INT 25
54536: PUSH
54537: LD_INT 4
54539: PUSH
54540: EMPTY
54541: LIST
54542: LIST
54543: PUSH
54544: LD_INT 24
54546: PUSH
54547: LD_INT 251
54549: PUSH
54550: EMPTY
54551: LIST
54552: LIST
54553: PUSH
54554: EMPTY
54555: LIST
54556: LIST
54557: PPUSH
54558: NOP4
54562: ST_TO_ADDR
// if mc_is_defending [ base ] then
54563: NOP4
54567: PUSH
54568: NOP4
54572: ARRAY
54573: IFFALSE 55034
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
54575: NOP4
54579: PUSH
54580: NOP4
54584: PPUSH
54585: NOP4
54589: PPUSH
54590: LD_INT 4
54592: PPUSH
54593: NOP4
54597: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54598: NOP4
54602: PUSH
54603: NOP4
54607: PUSH
54608: NOP4
54612: ARRAY
54613: PPUSH
54614: LD_INT 2
54616: PUSH
54617: LD_INT 30
54619: PUSH
54620: LD_INT 4
54622: PUSH
54623: EMPTY
54624: LIST
54625: LIST
54626: PUSH
54627: LD_INT 30
54629: PUSH
54630: LD_INT 5
54632: PUSH
54633: EMPTY
54634: LIST
54635: LIST
54636: PUSH
54637: EMPTY
54638: LIST
54639: LIST
54640: LIST
54641: PPUSH
54642: NOP4
54646: ST_TO_ADDR
// if not b then
54647: NOP4
54651: NOT
54652: IFFALSE 54656
// exit ;
54654: GO 57722
// p := [ ] ;
54656: NOP4
54660: PUSH
54661: EMPTY
54662: ST_TO_ADDR
// if sci >= 2 then
54663: NOP4
54667: PUSH
54668: LD_INT 2
54670: GREATEREQUAL
54671: IFFALSE 54702
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
54673: NOP4
54677: PUSH
54678: NOP4
54682: PUSH
54683: LD_INT 1
54685: ARRAY
54686: PUSH
54687: NOP4
54691: PUSH
54692: LD_INT 2
54694: ARRAY
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: ST_TO_ADDR
54700: GO 54763
// if sci = 1 then
54702: NOP4
54706: PUSH
54707: LD_INT 1
54709: EQUAL
54710: IFFALSE 54731
// sci := [ sci [ 1 ] ] else
54712: NOP4
54716: PUSH
54717: NOP4
54721: PUSH
54722: LD_INT 1
54724: ARRAY
54725: PUSH
54726: EMPTY
54727: LIST
54728: ST_TO_ADDR
54729: GO 54763
// if sci = 0 then
54731: NOP4
54735: PUSH
54736: LD_INT 0
54738: EQUAL
54739: IFFALSE 54763
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
54741: NOP4
54745: PUSH
54746: NOP4
54750: PPUSH
54751: LD_INT 4
54753: PPUSH
54754: NOP4
54758: PUSH
54759: LD_INT 1
54761: ARRAY
54762: ST_TO_ADDR
// if eng > 4 then
54763: NOP4
54767: PUSH
54768: LD_INT 4
54770: GREATER
54771: IFFALSE 54817
// for i = eng downto 4 do
54773: NOP4
54777: PUSH
54778: DOUBLE
54779: NOP4
54783: INC
54784: ST_TO_ADDR
54785: LD_INT 4
54787: PUSH
54788: FOR_DOWNTO
54789: IFFALSE 54815
// eng := eng diff eng [ i ] ;
54791: NOP4
54795: PUSH
54796: NOP4
54800: PUSH
54801: NOP4
54805: PUSH
54806: NOP4
54810: ARRAY
54811: DIFF
54812: ST_TO_ADDR
54813: GO 54788
54815: POP
54816: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
54817: NOP4
54821: PUSH
54822: NOP4
54826: PUSH
54827: NOP4
54831: PUSH
54832: NOP4
54836: UNION
54837: PUSH
54838: NOP4
54842: UNION
54843: PUSH
54844: NOP4
54848: UNION
54849: DIFF
54850: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
54851: NOP4
54855: PUSH
54856: NOP4
54860: PUSH
54861: NOP4
54865: ARRAY
54866: PPUSH
54867: LD_INT 2
54869: PUSH
54870: LD_INT 30
54872: PUSH
54873: LD_INT 32
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PUSH
54880: LD_INT 30
54882: PUSH
54883: LD_INT 31
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: EMPTY
54891: LIST
54892: LIST
54893: LIST
54894: PPUSH
54895: NOP4
54899: PUSH
54900: NOP4
54904: PUSH
54905: NOP4
54909: ARRAY
54910: PPUSH
54911: LD_INT 2
54913: PUSH
54914: LD_INT 30
54916: PUSH
54917: LD_INT 4
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: PUSH
54924: LD_INT 30
54926: PUSH
54927: LD_INT 5
54929: PUSH
54930: EMPTY
54931: LIST
54932: LIST
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: LIST
54938: PPUSH
54939: NOP4
54943: PUSH
54944: LD_INT 6
54946: MUL
54947: PLUS
54948: ST_TO_ADDR
// if bcount < tmp then
54949: NOP4
54953: PUSH
54954: NOP4
54958: LESS
54959: IFFALSE 55005
// for i = tmp downto bcount do
54961: NOP4
54965: PUSH
54966: DOUBLE
54967: NOP4
54971: INC
54972: ST_TO_ADDR
54973: NOP4
54977: PUSH
54978: FOR_DOWNTO
54979: IFFALSE 55003
// tmp := Delete ( tmp , tmp ) ;
54981: NOP4
54985: PUSH
54986: NOP4
54990: PPUSH
54991: NOP4
54995: PPUSH
54996: NOP4
55000: ST_TO_ADDR
55001: GO 54978
55003: POP
55004: POP
// result := [ tmp , 0 , 0 , p ] ;
55005: NOP4
55009: PUSH
55010: NOP4
55014: PUSH
55015: LD_INT 0
55017: PUSH
55018: LD_INT 0
55020: PUSH
55021: NOP4
55025: PUSH
55026: EMPTY
55027: LIST
55028: LIST
55029: LIST
55030: LIST
55031: ST_TO_ADDR
// exit ;
55032: GO 57722
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55034: NOP4
55038: PUSH
55039: NOP4
55043: ARRAY
55044: PPUSH
55045: LD_INT 2
55047: PUSH
55048: LD_INT 30
55050: PUSH
55051: LD_INT 6
55053: PUSH
55054: EMPTY
55055: LIST
55056: LIST
55057: PUSH
55058: LD_INT 30
55060: PUSH
55061: LD_INT 7
55063: PUSH
55064: EMPTY
55065: LIST
55066: LIST
55067: PUSH
55068: LD_INT 30
55070: PUSH
55071: LD_INT 8
55073: PUSH
55074: EMPTY
55075: LIST
55076: LIST
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: LIST
55082: LIST
55083: PPUSH
55084: NOP4
55088: NOT
55089: PUSH
55090: NOP4
55094: PUSH
55095: NOP4
55099: ARRAY
55100: PPUSH
55101: LD_INT 30
55103: PUSH
55104: LD_INT 3
55106: PUSH
55107: EMPTY
55108: LIST
55109: LIST
55110: PPUSH
55111: NOP4
55115: NOT
55116: AND
55117: IFFALSE 55189
// begin if eng = tmp then
55119: NOP4
55123: PUSH
55124: NOP4
55128: EQUAL
55129: IFFALSE 55133
// exit ;
55131: GO 57722
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55133: NOP4
55137: PUSH
55138: NOP4
55142: PPUSH
55143: NOP4
55147: PPUSH
55148: LD_INT 1
55150: PPUSH
55151: NOP4
55155: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55156: NOP4
55160: PUSH
55161: LD_INT 0
55163: PUSH
55164: NOP4
55168: PUSH
55169: NOP4
55173: DIFF
55174: PUSH
55175: LD_INT 0
55177: PUSH
55178: LD_INT 0
55180: PUSH
55181: EMPTY
55182: LIST
55183: LIST
55184: LIST
55185: LIST
55186: ST_TO_ADDR
// exit ;
55187: GO 57722
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55189: NOP4
55193: PUSH
55194: NOP4
55198: PUSH
55199: NOP4
55203: ARRAY
55204: ARRAY
55205: PUSH
55206: NOP4
55210: PUSH
55211: NOP4
55215: ARRAY
55216: PPUSH
55217: LD_INT 2
55219: PUSH
55220: LD_INT 30
55222: PUSH
55223: LD_INT 6
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: PUSH
55230: LD_INT 30
55232: PUSH
55233: LD_INT 7
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: PUSH
55240: LD_INT 30
55242: PUSH
55243: LD_INT 8
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: PPUSH
55256: NOP4
55260: AND
55261: PUSH
55262: NOP4
55266: PUSH
55267: NOP4
55271: ARRAY
55272: PPUSH
55273: LD_INT 30
55275: PUSH
55276: LD_INT 3
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: PPUSH
55283: NOP4
55287: NOT
55288: AND
55289: IFFALSE 55503
// begin if sci >= 6 then
55291: NOP4
55295: PUSH
55296: LD_INT 6
55298: GREATEREQUAL
55299: IFFALSE 55303
// exit ;
55301: GO 57722
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55303: NOP4
55307: PUSH
55308: NOP4
55312: PPUSH
55313: NOP4
55317: PPUSH
55318: LD_INT 2
55320: PPUSH
55321: NOP4
55325: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55326: NOP4
55330: PUSH
55331: NOP4
55335: PUSH
55336: NOP4
55340: DIFF
55341: PPUSH
55342: LD_INT 4
55344: PPUSH
55345: NOP4
55349: ST_TO_ADDR
// p := [ ] ;
55350: NOP4
55354: PUSH
55355: EMPTY
55356: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55357: NOP4
55361: PUSH
55362: LD_INT 6
55364: LESS
55365: PUSH
55366: NOP4
55370: PUSH
55371: LD_INT 6
55373: GREATER
55374: AND
55375: IFFALSE 55456
// begin for i = 1 to 6 - sci do
55377: NOP4
55381: PUSH
55382: DOUBLE
55383: LD_INT 1
55385: DEC
55386: ST_TO_ADDR
55387: LD_INT 6
55389: PUSH
55390: NOP4
55394: MINUS
55395: PUSH
55396: FOR_TO
55397: IFFALSE 55452
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55399: NOP4
55403: PUSH
55404: NOP4
55408: PPUSH
55409: NOP4
55413: PUSH
55414: LD_INT 1
55416: PLUS
55417: PPUSH
55418: NOP4
55422: PUSH
55423: LD_INT 1
55425: ARRAY
55426: PPUSH
55427: NOP4
55431: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
55432: NOP4
55436: PUSH
55437: NOP4
55441: PPUSH
55442: LD_INT 1
55444: PPUSH
55445: NOP4
55449: ST_TO_ADDR
// end ;
55450: GO 55396
55452: POP
55453: POP
// end else
55454: GO 55476
// if sort then
55456: NOP4
55460: IFFALSE 55476
// p := sort [ 1 ] ;
55462: NOP4
55466: PUSH
55467: NOP4
55471: PUSH
55472: LD_INT 1
55474: ARRAY
55475: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
55476: NOP4
55480: PUSH
55481: LD_INT 0
55483: PUSH
55484: LD_INT 0
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: NOP4
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: LIST
55499: LIST
55500: ST_TO_ADDR
// exit ;
55501: GO 57722
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55503: NOP4
55507: PUSH
55508: NOP4
55512: PUSH
55513: NOP4
55517: ARRAY
55518: ARRAY
55519: PUSH
55520: NOP4
55524: PUSH
55525: NOP4
55529: ARRAY
55530: PPUSH
55531: LD_INT 2
55533: PUSH
55534: LD_INT 30
55536: PUSH
55537: LD_INT 6
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: PUSH
55544: LD_INT 30
55546: PUSH
55547: LD_INT 7
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: PUSH
55554: LD_INT 30
55556: PUSH
55557: LD_INT 8
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: LIST
55568: LIST
55569: PPUSH
55570: NOP4
55574: AND
55575: PUSH
55576: NOP4
55580: PUSH
55581: NOP4
55585: ARRAY
55586: PPUSH
55587: LD_INT 30
55589: PUSH
55590: LD_INT 3
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: PPUSH
55597: NOP4
55601: AND
55602: IFFALSE 56336
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
55604: NOP4
55608: PUSH
55609: NOP4
55613: PPUSH
55614: NOP4
55618: PPUSH
55619: LD_INT 3
55621: PPUSH
55622: NOP4
55626: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55627: NOP4
55631: PUSH
55632: LD_INT 0
55634: PUSH
55635: LD_INT 0
55637: PUSH
55638: LD_INT 0
55640: PUSH
55641: LD_INT 0
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: LIST
55648: LIST
55649: ST_TO_ADDR
// if not eng then
55650: NOP4
55654: NOT
55655: IFFALSE 55718
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
55657: NOP4
55661: PUSH
55662: NOP4
55666: PPUSH
55667: LD_INT 2
55669: PPUSH
55670: NOP4
55674: PUSH
55675: LD_INT 1
55677: ARRAY
55678: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
55679: NOP4
55683: PUSH
55684: NOP4
55688: PPUSH
55689: LD_INT 2
55691: PPUSH
55692: NOP4
55696: PPUSH
55697: NOP4
55701: ST_TO_ADDR
// tmp := tmp diff p ;
55702: NOP4
55706: PUSH
55707: NOP4
55711: PUSH
55712: NOP4
55716: DIFF
55717: ST_TO_ADDR
// end ; if tmp and sci < 6 then
55718: NOP4
55722: PUSH
55723: NOP4
55727: PUSH
55728: LD_INT 6
55730: LESS
55731: AND
55732: IFFALSE 55920
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
55734: NOP4
55738: PUSH
55739: NOP4
55743: PUSH
55744: NOP4
55748: PUSH
55749: NOP4
55753: UNION
55754: DIFF
55755: PPUSH
55756: LD_INT 4
55758: PPUSH
55759: NOP4
55763: ST_TO_ADDR
// p := [ ] ;
55764: NOP4
55768: PUSH
55769: EMPTY
55770: ST_TO_ADDR
// if sort then
55771: NOP4
55775: IFFALSE 55891
// for i = 1 to 6 - sci do
55777: NOP4
55781: PUSH
55782: DOUBLE
55783: LD_INT 1
55785: DEC
55786: ST_TO_ADDR
55787: LD_INT 6
55789: PUSH
55790: NOP4
55794: MINUS
55795: PUSH
55796: FOR_TO
55797: IFFALSE 55889
// begin if i = sort then
55799: NOP4
55803: PUSH
55804: NOP4
55808: EQUAL
55809: IFFALSE 55813
// break ;
55811: GO 55889
// if GetClass ( i ) = 4 then
55813: NOP4
55817: PPUSH
55818: NOP4
55822: PUSH
55823: LD_INT 4
55825: EQUAL
55826: IFFALSE 55830
// continue ;
55828: GO 55796
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55830: NOP4
55834: PUSH
55835: NOP4
55839: PPUSH
55840: NOP4
55844: PUSH
55845: LD_INT 1
55847: PLUS
55848: PPUSH
55849: NOP4
55853: PUSH
55854: NOP4
55858: ARRAY
55859: PPUSH
55860: NOP4
55864: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55865: NOP4
55869: PUSH
55870: NOP4
55874: PUSH
55875: NOP4
55879: PUSH
55880: NOP4
55884: ARRAY
55885: DIFF
55886: ST_TO_ADDR
// end ;
55887: GO 55796
55889: POP
55890: POP
// if p then
55891: NOP4
55895: IFFALSE 55920
// result := Replace ( result , 4 , p ) ;
55897: NOP4
55901: PUSH
55902: NOP4
55906: PPUSH
55907: LD_INT 4
55909: PPUSH
55910: NOP4
55914: PPUSH
55915: NOP4
55919: ST_TO_ADDR
// end ; if tmp and mech < 6 then
55920: NOP4
55924: PUSH
55925: NOP4
55929: PUSH
55930: LD_INT 6
55932: LESS
55933: AND
55934: IFFALSE 56122
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
55936: NOP4
55940: PUSH
55941: NOP4
55945: PUSH
55946: NOP4
55950: PUSH
55951: NOP4
55955: UNION
55956: DIFF
55957: PPUSH
55958: LD_INT 3
55960: PPUSH
55961: NOP4
55965: ST_TO_ADDR
// p := [ ] ;
55966: NOP4
55970: PUSH
55971: EMPTY
55972: ST_TO_ADDR
// if sort then
55973: NOP4
55977: IFFALSE 56093
// for i = 1 to 6 - mech do
55979: NOP4
55983: PUSH
55984: DOUBLE
55985: LD_INT 1
55987: DEC
55988: ST_TO_ADDR
55989: LD_INT 6
55991: PUSH
55992: NOP4
55996: MINUS
55997: PUSH
55998: FOR_TO
55999: IFFALSE 56091
// begin if i = sort then
56001: NOP4
56005: PUSH
56006: NOP4
56010: EQUAL
56011: IFFALSE 56015
// break ;
56013: GO 56091
// if GetClass ( i ) = 3 then
56015: NOP4
56019: PPUSH
56020: NOP4
56024: PUSH
56025: LD_INT 3
56027: EQUAL
56028: IFFALSE 56032
// continue ;
56030: GO 55998
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56032: NOP4
56036: PUSH
56037: NOP4
56041: PPUSH
56042: NOP4
56046: PUSH
56047: LD_INT 1
56049: PLUS
56050: PPUSH
56051: NOP4
56055: PUSH
56056: NOP4
56060: ARRAY
56061: PPUSH
56062: NOP4
56066: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56067: NOP4
56071: PUSH
56072: NOP4
56076: PUSH
56077: NOP4
56081: PUSH
56082: NOP4
56086: ARRAY
56087: DIFF
56088: ST_TO_ADDR
// end ;
56089: GO 55998
56091: POP
56092: POP
// if p then
56093: NOP4
56097: IFFALSE 56122
// result := Replace ( result , 3 , p ) ;
56099: NOP4
56103: PUSH
56104: NOP4
56108: PPUSH
56109: LD_INT 3
56111: PPUSH
56112: NOP4
56116: PPUSH
56117: NOP4
56121: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56122: NOP4
56126: PUSH
56127: LD_INT 6
56129: GREATER
56130: PUSH
56131: NOP4
56135: PUSH
56136: LD_INT 6
56138: LESS
56139: AND
56140: IFFALSE 56334
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56142: NOP4
56146: PUSH
56147: NOP4
56151: PUSH
56152: NOP4
56156: PUSH
56157: NOP4
56161: UNION
56162: PUSH
56163: NOP4
56167: UNION
56168: DIFF
56169: PPUSH
56170: LD_INT 2
56172: PPUSH
56173: NOP4
56177: ST_TO_ADDR
// p := [ ] ;
56178: NOP4
56182: PUSH
56183: EMPTY
56184: ST_TO_ADDR
// if sort then
56185: NOP4
56189: IFFALSE 56305
// for i = 1 to 6 - eng do
56191: NOP4
56195: PUSH
56196: DOUBLE
56197: LD_INT 1
56199: DEC
56200: ST_TO_ADDR
56201: LD_INT 6
56203: PUSH
56204: NOP4
56208: MINUS
56209: PUSH
56210: FOR_TO
56211: IFFALSE 56303
// begin if i = sort then
56213: NOP4
56217: PUSH
56218: NOP4
56222: EQUAL
56223: IFFALSE 56227
// break ;
56225: GO 56303
// if GetClass ( i ) = 2 then
56227: NOP4
56231: PPUSH
56232: NOP4
56236: PUSH
56237: LD_INT 2
56239: EQUAL
56240: IFFALSE 56244
// continue ;
56242: GO 56210
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56244: NOP4
56248: PUSH
56249: NOP4
56253: PPUSH
56254: NOP4
56258: PUSH
56259: LD_INT 1
56261: PLUS
56262: PPUSH
56263: NOP4
56267: PUSH
56268: NOP4
56272: ARRAY
56273: PPUSH
56274: NOP4
56278: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56279: NOP4
56283: PUSH
56284: NOP4
56288: PUSH
56289: NOP4
56293: PUSH
56294: NOP4
56298: ARRAY
56299: DIFF
56300: ST_TO_ADDR
// end ;
56301: GO 56210
56303: POP
56304: POP
// if p then
56305: NOP4
56309: IFFALSE 56334
// result := Replace ( result , 2 , p ) ;
56311: NOP4
56315: PUSH
56316: NOP4
56320: PPUSH
56321: LD_INT 2
56323: PPUSH
56324: NOP4
56328: PPUSH
56329: NOP4
56333: ST_TO_ADDR
// end ; exit ;
56334: GO 57722
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56336: NOP4
56340: PUSH
56341: NOP4
56345: PUSH
56346: NOP4
56350: ARRAY
56351: ARRAY
56352: NOT
56353: PUSH
56354: NOP4
56358: PUSH
56359: NOP4
56363: ARRAY
56364: PPUSH
56365: LD_INT 30
56367: PUSH
56368: LD_INT 3
56370: PUSH
56371: EMPTY
56372: LIST
56373: LIST
56374: PPUSH
56375: NOP4
56379: AND
56380: PUSH
56381: NOP4
56385: PUSH
56386: NOP4
56390: ARRAY
56391: AND
56392: IFFALSE 57000
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56394: NOP4
56398: PUSH
56399: NOP4
56403: PPUSH
56404: NOP4
56408: PPUSH
56409: LD_INT 5
56411: PPUSH
56412: NOP4
56416: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56417: NOP4
56421: PUSH
56422: LD_INT 0
56424: PUSH
56425: LD_INT 0
56427: PUSH
56428: LD_INT 0
56430: PUSH
56431: LD_INT 0
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: LIST
56438: LIST
56439: ST_TO_ADDR
// if sci > 1 then
56440: NOP4
56444: PUSH
56445: LD_INT 1
56447: GREATER
56448: IFFALSE 56476
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
56450: NOP4
56454: PUSH
56455: NOP4
56459: PUSH
56460: NOP4
56464: PUSH
56465: NOP4
56469: PUSH
56470: LD_INT 1
56472: ARRAY
56473: DIFF
56474: DIFF
56475: ST_TO_ADDR
// if tmp and not sci then
56476: NOP4
56480: PUSH
56481: NOP4
56485: NOT
56486: AND
56487: IFFALSE 56556
// begin sort := SortBySkill ( tmp , 4 ) ;
56489: NOP4
56493: PUSH
56494: NOP4
56498: PPUSH
56499: LD_INT 4
56501: PPUSH
56502: NOP4
56506: ST_TO_ADDR
// if sort then
56507: NOP4
56511: IFFALSE 56527
// p := sort [ 1 ] ;
56513: NOP4
56517: PUSH
56518: NOP4
56522: PUSH
56523: LD_INT 1
56525: ARRAY
56526: ST_TO_ADDR
// if p then
56527: NOP4
56531: IFFALSE 56556
// result := Replace ( result , 4 , p ) ;
56533: NOP4
56537: PUSH
56538: NOP4
56542: PPUSH
56543: LD_INT 4
56545: PPUSH
56546: NOP4
56550: PPUSH
56551: NOP4
56555: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
56556: NOP4
56560: PUSH
56561: NOP4
56565: PUSH
56566: NOP4
56570: DIFF
56571: ST_TO_ADDR
// if tmp and mech < 6 then
56572: NOP4
56576: PUSH
56577: NOP4
56581: PUSH
56582: LD_INT 6
56584: LESS
56585: AND
56586: IFFALSE 56774
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56588: NOP4
56592: PUSH
56593: NOP4
56597: PUSH
56598: NOP4
56602: PUSH
56603: NOP4
56607: UNION
56608: DIFF
56609: PPUSH
56610: LD_INT 3
56612: PPUSH
56613: NOP4
56617: ST_TO_ADDR
// p := [ ] ;
56618: NOP4
56622: PUSH
56623: EMPTY
56624: ST_TO_ADDR
// if sort then
56625: NOP4
56629: IFFALSE 56745
// for i = 1 to 6 - mech do
56631: NOP4
56635: PUSH
56636: DOUBLE
56637: LD_INT 1
56639: DEC
56640: ST_TO_ADDR
56641: LD_INT 6
56643: PUSH
56644: NOP4
56648: MINUS
56649: PUSH
56650: FOR_TO
56651: IFFALSE 56743
// begin if i = sort then
56653: NOP4
56657: PUSH
56658: NOP4
56662: EQUAL
56663: IFFALSE 56667
// break ;
56665: GO 56743
// if GetClass ( i ) = 3 then
56667: NOP4
56671: PPUSH
56672: NOP4
56676: PUSH
56677: LD_INT 3
56679: EQUAL
56680: IFFALSE 56684
// continue ;
56682: GO 56650
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56684: NOP4
56688: PUSH
56689: NOP4
56693: PPUSH
56694: NOP4
56698: PUSH
56699: LD_INT 1
56701: PLUS
56702: PPUSH
56703: NOP4
56707: PUSH
56708: NOP4
56712: ARRAY
56713: PPUSH
56714: NOP4
56718: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56719: NOP4
56723: PUSH
56724: NOP4
56728: PUSH
56729: NOP4
56733: PUSH
56734: NOP4
56738: ARRAY
56739: DIFF
56740: ST_TO_ADDR
// end ;
56741: GO 56650
56743: POP
56744: POP
// if p then
56745: NOP4
56749: IFFALSE 56774
// result := Replace ( result , 3 , p ) ;
56751: NOP4
56755: PUSH
56756: NOP4
56760: PPUSH
56761: LD_INT 3
56763: PPUSH
56764: NOP4
56768: PPUSH
56769: NOP4
56773: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
56774: NOP4
56778: PUSH
56779: NOP4
56783: PUSH
56784: NOP4
56788: DIFF
56789: ST_TO_ADDR
// if tmp and eng < 6 then
56790: NOP4
56794: PUSH
56795: NOP4
56799: PUSH
56800: LD_INT 6
56802: LESS
56803: AND
56804: IFFALSE 56998
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56806: NOP4
56810: PUSH
56811: NOP4
56815: PUSH
56816: NOP4
56820: PUSH
56821: NOP4
56825: UNION
56826: PUSH
56827: NOP4
56831: UNION
56832: DIFF
56833: PPUSH
56834: LD_INT 2
56836: PPUSH
56837: NOP4
56841: ST_TO_ADDR
// p := [ ] ;
56842: NOP4
56846: PUSH
56847: EMPTY
56848: ST_TO_ADDR
// if sort then
56849: NOP4
56853: IFFALSE 56969
// for i = 1 to 6 - eng do
56855: NOP4
56859: PUSH
56860: DOUBLE
56861: LD_INT 1
56863: DEC
56864: ST_TO_ADDR
56865: LD_INT 6
56867: PUSH
56868: NOP4
56872: MINUS
56873: PUSH
56874: FOR_TO
56875: IFFALSE 56967
// begin if i = sort then
56877: NOP4
56881: PUSH
56882: NOP4
56886: EQUAL
56887: IFFALSE 56891
// break ;
56889: GO 56967
// if GetClass ( i ) = 2 then
56891: NOP4
56895: PPUSH
56896: NOP4
56900: PUSH
56901: LD_INT 2
56903: EQUAL
56904: IFFALSE 56908
// continue ;
56906: GO 56874
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56908: NOP4
56912: PUSH
56913: NOP4
56917: PPUSH
56918: NOP4
56922: PUSH
56923: LD_INT 1
56925: PLUS
56926: PPUSH
56927: NOP4
56931: PUSH
56932: NOP4
56936: ARRAY
56937: PPUSH
56938: NOP4
56942: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56943: NOP4
56947: PUSH
56948: NOP4
56952: PUSH
56953: NOP4
56957: PUSH
56958: NOP4
56962: ARRAY
56963: DIFF
56964: ST_TO_ADDR
// end ;
56965: GO 56874
56967: POP
56968: POP
// if p then
56969: NOP4
56973: IFFALSE 56998
// result := Replace ( result , 2 , p ) ;
56975: NOP4
56979: PUSH
56980: NOP4
56984: PPUSH
56985: LD_INT 2
56987: PPUSH
56988: NOP4
56992: PPUSH
56993: NOP4
56997: ST_TO_ADDR
// end ; exit ;
56998: GO 57722
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57000: NOP4
57004: PUSH
57005: NOP4
57009: PUSH
57010: NOP4
57014: ARRAY
57015: ARRAY
57016: NOT
57017: PUSH
57018: NOP4
57022: PUSH
57023: NOP4
57027: ARRAY
57028: PPUSH
57029: LD_INT 30
57031: PUSH
57032: LD_INT 3
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: PPUSH
57039: NOP4
57043: AND
57044: PUSH
57045: NOP4
57049: PUSH
57050: NOP4
57054: ARRAY
57055: NOT
57056: AND
57057: IFFALSE 57722
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57059: NOP4
57063: PUSH
57064: NOP4
57068: PPUSH
57069: NOP4
57073: PPUSH
57074: LD_INT 6
57076: PPUSH
57077: NOP4
57081: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57082: NOP4
57086: PUSH
57087: LD_INT 0
57089: PUSH
57090: LD_INT 0
57092: PUSH
57093: LD_INT 0
57095: PUSH
57096: LD_INT 0
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: LIST
57103: LIST
57104: ST_TO_ADDR
// if sci >= 1 then
57105: NOP4
57109: PUSH
57110: LD_INT 1
57112: GREATEREQUAL
57113: IFFALSE 57135
// tmp := tmp diff sci [ 1 ] ;
57115: NOP4
57119: PUSH
57120: NOP4
57124: PUSH
57125: NOP4
57129: PUSH
57130: LD_INT 1
57132: ARRAY
57133: DIFF
57134: ST_TO_ADDR
// if tmp and not sci then
57135: NOP4
57139: PUSH
57140: NOP4
57144: NOT
57145: AND
57146: IFFALSE 57215
// begin sort := SortBySkill ( tmp , 4 ) ;
57148: NOP4
57152: PUSH
57153: NOP4
57157: PPUSH
57158: LD_INT 4
57160: PPUSH
57161: NOP4
57165: ST_TO_ADDR
// if sort then
57166: NOP4
57170: IFFALSE 57186
// p := sort [ 1 ] ;
57172: NOP4
57176: PUSH
57177: NOP4
57181: PUSH
57182: LD_INT 1
57184: ARRAY
57185: ST_TO_ADDR
// if p then
57186: NOP4
57190: IFFALSE 57215
// result := Replace ( result , 4 , p ) ;
57192: NOP4
57196: PUSH
57197: NOP4
57201: PPUSH
57202: LD_INT 4
57204: PPUSH
57205: NOP4
57209: PPUSH
57210: NOP4
57214: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57215: NOP4
57219: PUSH
57220: NOP4
57224: PUSH
57225: NOP4
57229: DIFF
57230: ST_TO_ADDR
// if tmp and mech < 6 then
57231: NOP4
57235: PUSH
57236: NOP4
57240: PUSH
57241: LD_INT 6
57243: LESS
57244: AND
57245: IFFALSE 57427
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57247: NOP4
57251: PUSH
57252: NOP4
57256: PUSH
57257: NOP4
57261: DIFF
57262: PPUSH
57263: LD_INT 3
57265: PPUSH
57266: NOP4
57270: ST_TO_ADDR
// p := [ ] ;
57271: NOP4
57275: PUSH
57276: EMPTY
57277: ST_TO_ADDR
// if sort then
57278: NOP4
57282: IFFALSE 57398
// for i = 1 to 6 - mech do
57284: NOP4
57288: PUSH
57289: DOUBLE
57290: LD_INT 1
57292: DEC
57293: ST_TO_ADDR
57294: LD_INT 6
57296: PUSH
57297: NOP4
57301: MINUS
57302: PUSH
57303: FOR_TO
57304: IFFALSE 57396
// begin if i = sort then
57306: NOP4
57310: PUSH
57311: NOP4
57315: EQUAL
57316: IFFALSE 57320
// break ;
57318: GO 57396
// if GetClass ( i ) = 3 then
57320: NOP4
57324: PPUSH
57325: NOP4
57329: PUSH
57330: LD_INT 3
57332: EQUAL
57333: IFFALSE 57337
// continue ;
57335: GO 57303
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57337: NOP4
57341: PUSH
57342: NOP4
57346: PPUSH
57347: NOP4
57351: PUSH
57352: LD_INT 1
57354: PLUS
57355: PPUSH
57356: NOP4
57360: PUSH
57361: NOP4
57365: ARRAY
57366: PPUSH
57367: NOP4
57371: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57372: NOP4
57376: PUSH
57377: NOP4
57381: PUSH
57382: NOP4
57386: PUSH
57387: NOP4
57391: ARRAY
57392: DIFF
57393: ST_TO_ADDR
// end ;
57394: GO 57303
57396: POP
57397: POP
// if p then
57398: NOP4
57402: IFFALSE 57427
// result := Replace ( result , 3 , p ) ;
57404: NOP4
57408: PUSH
57409: NOP4
57413: PPUSH
57414: LD_INT 3
57416: PPUSH
57417: NOP4
57421: PPUSH
57422: NOP4
57426: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57427: NOP4
57431: PUSH
57432: NOP4
57436: PUSH
57437: NOP4
57441: DIFF
57442: ST_TO_ADDR
// if tmp and eng < 4 then
57443: NOP4
57447: PUSH
57448: NOP4
57452: PUSH
57453: LD_INT 4
57455: LESS
57456: AND
57457: IFFALSE 57647
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
57459: NOP4
57463: PUSH
57464: NOP4
57468: PUSH
57469: NOP4
57473: PUSH
57474: NOP4
57478: UNION
57479: DIFF
57480: PPUSH
57481: LD_INT 2
57483: PPUSH
57484: NOP4
57488: ST_TO_ADDR
// p := [ ] ;
57489: NOP4
57493: PUSH
57494: EMPTY
57495: ST_TO_ADDR
// if sort then
57496: NOP4
57500: IFFALSE 57616
// for i = 1 to 4 - eng do
57502: NOP4
57506: PUSH
57507: DOUBLE
57508: LD_INT 1
57510: DEC
57511: ST_TO_ADDR
57512: LD_INT 4
57514: PUSH
57515: NOP4
57519: MINUS
57520: PUSH
57521: FOR_TO
57522: IFFALSE 57614
// begin if i = sort then
57524: NOP4
57528: PUSH
57529: NOP4
57533: EQUAL
57534: IFFALSE 57538
// break ;
57536: GO 57614
// if GetClass ( i ) = 2 then
57538: NOP4
57542: PPUSH
57543: NOP4
57547: PUSH
57548: LD_INT 2
57550: EQUAL
57551: IFFALSE 57555
// continue ;
57553: GO 57521
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57555: NOP4
57559: PUSH
57560: NOP4
57564: PPUSH
57565: NOP4
57569: PUSH
57570: LD_INT 1
57572: PLUS
57573: PPUSH
57574: NOP4
57578: PUSH
57579: NOP4
57583: ARRAY
57584: PPUSH
57585: NOP4
57589: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57590: NOP4
57594: PUSH
57595: NOP4
57599: PUSH
57600: NOP4
57604: PUSH
57605: NOP4
57609: ARRAY
57610: DIFF
57611: ST_TO_ADDR
// end ;
57612: GO 57521
57614: POP
57615: POP
// if p then
57616: NOP4
57620: IFFALSE 57645
// result := Replace ( result , 2 , p ) ;
57622: NOP4
57626: PUSH
57627: NOP4
57631: PPUSH
57632: LD_INT 2
57634: PPUSH
57635: NOP4
57639: PPUSH
57640: NOP4
57644: ST_TO_ADDR
// end else
57645: GO 57691
// for i = eng downto 5 do
57647: NOP4
57651: PUSH
57652: DOUBLE
57653: NOP4
57657: INC
57658: ST_TO_ADDR
57659: LD_INT 5
57661: PUSH
57662: FOR_DOWNTO
57663: IFFALSE 57689
// tmp := tmp union eng [ i ] ;
57665: NOP4
57669: PUSH
57670: NOP4
57674: PUSH
57675: NOP4
57679: PUSH
57680: NOP4
57684: ARRAY
57685: UNION
57686: ST_TO_ADDR
57687: GO 57662
57689: POP
57690: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
57691: NOP4
57695: PUSH
57696: NOP4
57700: PPUSH
57701: LD_INT 1
57703: PPUSH
57704: NOP4
57708: PUSH
57709: NOP4
57713: DIFF
57714: PPUSH
57715: NOP4
57719: ST_TO_ADDR
// exit ;
57720: GO 57722
// end ; end ;
57722: LD_VAR 0 2
57726: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
57727: LD_INT 0
57729: PPUSH
57730: PPUSH
57731: PPUSH
// if not mc_bases then
57732: NOP4
57736: NOT
57737: IFFALSE 57741
// exit ;
57739: GO 57883
// for i = 1 to mc_bases do
57741: NOP4
57745: PUSH
57746: DOUBLE
57747: LD_INT 1
57749: DEC
57750: ST_TO_ADDR
57751: NOP4
57755: PUSH
57756: FOR_TO
57757: IFFALSE 57874
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57759: NOP4
57763: PUSH
57764: NOP4
57768: PUSH
57769: NOP4
57773: ARRAY
57774: PPUSH
57775: LD_INT 21
57777: PUSH
57778: LD_INT 3
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: PUSH
57785: LD_INT 3
57787: PUSH
57788: LD_INT 2
57790: PUSH
57791: LD_INT 30
57793: PUSH
57794: LD_INT 29
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: PUSH
57801: LD_INT 30
57803: PUSH
57804: LD_INT 30
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PUSH
57811: EMPTY
57812: LIST
57813: LIST
57814: LIST
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: PUSH
57820: LD_INT 3
57822: PUSH
57823: LD_INT 24
57825: PUSH
57826: LD_INT 1000
57828: PUSH
57829: EMPTY
57830: LIST
57831: LIST
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: PUSH
57837: EMPTY
57838: LIST
57839: LIST
57840: LIST
57841: PPUSH
57842: NOP4
57846: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
57847: NOP4
57851: PUSH
57852: NOP4
57856: PPUSH
57857: NOP4
57861: PPUSH
57862: NOP4
57866: PPUSH
57867: NOP4
57871: ST_TO_ADDR
// end ;
57872: GO 57756
57874: POP
57875: POP
// RaiseSailEvent ( 101 ) ;
57876: LD_INT 101
57878: PPUSH
57879: NOP4
// end ;
57883: LD_VAR 0 1
57887: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
57888: LD_INT 0
57890: PPUSH
57891: PPUSH
57892: PPUSH
57893: PPUSH
57894: PPUSH
57895: PPUSH
57896: PPUSH
// if not mc_bases then
57897: NOP4
57901: NOT
57902: IFFALSE 57906
// exit ;
57904: GO 58468
// for i = 1 to mc_bases do
57906: NOP4
57910: PUSH
57911: DOUBLE
57912: LD_INT 1
57914: DEC
57915: ST_TO_ADDR
57916: NOP4
57920: PUSH
57921: FOR_TO
57922: IFFALSE 58459
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
57924: NOP4
57928: PUSH
57929: NOP4
57933: PUSH
57934: NOP4
57938: ARRAY
57939: PUSH
57940: NOP4
57944: PUSH
57945: NOP4
57949: ARRAY
57950: UNION
57951: PPUSH
57952: LD_INT 21
57954: PUSH
57955: LD_INT 1
57957: PUSH
57958: EMPTY
57959: LIST
57960: LIST
57961: PUSH
57962: LD_INT 1
57964: PUSH
57965: LD_INT 3
57967: PUSH
57968: LD_INT 54
57970: PUSH
57971: EMPTY
57972: LIST
57973: PUSH
57974: EMPTY
57975: LIST
57976: LIST
57977: PUSH
57978: LD_INT 3
57980: PUSH
57981: LD_INT 24
57983: PUSH
57984: LD_INT 1000
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: LIST
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PPUSH
58004: NOP4
58008: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58009: NOP4
58013: PUSH
58014: NOP4
58018: PUSH
58019: NOP4
58023: ARRAY
58024: PPUSH
58025: LD_INT 21
58027: PUSH
58028: LD_INT 1
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: PUSH
58035: LD_INT 1
58037: PUSH
58038: LD_INT 3
58040: PUSH
58041: LD_INT 54
58043: PUSH
58044: EMPTY
58045: LIST
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: PUSH
58051: LD_INT 3
58053: PUSH
58054: LD_INT 24
58056: PUSH
58057: LD_INT 250
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: PUSH
58064: EMPTY
58065: LIST
58066: LIST
58067: PUSH
58068: EMPTY
58069: LIST
58070: LIST
58071: LIST
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: PPUSH
58077: NOP4
58081: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58082: NOP4
58086: PUSH
58087: NOP4
58091: PUSH
58092: NOP4
58096: DIFF
58097: ST_TO_ADDR
// if not need_heal_1 then
58098: NOP4
58102: NOT
58103: IFFALSE 58136
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58105: NOP4
58109: PUSH
58110: NOP4
58114: PPUSH
58115: NOP4
58119: PUSH
58120: LD_INT 1
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: PPUSH
58127: EMPTY
58128: PPUSH
58129: NOP4
58133: ST_TO_ADDR
58134: GO 58206
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58136: NOP4
58140: PUSH
58141: NOP4
58145: PPUSH
58146: NOP4
58150: PUSH
58151: LD_INT 1
58153: PUSH
58154: EMPTY
58155: LIST
58156: LIST
58157: PPUSH
58158: NOP4
58162: PUSH
58163: NOP4
58167: ARRAY
58168: PUSH
58169: LD_INT 1
58171: ARRAY
58172: PPUSH
58173: LD_INT 3
58175: PUSH
58176: LD_INT 24
58178: PUSH
58179: LD_INT 1000
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PPUSH
58190: NOP4
58194: PUSH
58195: NOP4
58199: UNION
58200: PPUSH
58201: NOP4
58205: ST_TO_ADDR
// if not need_heal_2 then
58206: NOP4
58210: NOT
58211: IFFALSE 58244
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58213: NOP4
58217: PUSH
58218: NOP4
58222: PPUSH
58223: NOP4
58227: PUSH
58228: LD_INT 2
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PPUSH
58235: EMPTY
58236: PPUSH
58237: NOP4
58241: ST_TO_ADDR
58242: GO 58276
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58244: NOP4
58248: PUSH
58249: NOP4
58253: PPUSH
58254: NOP4
58258: PUSH
58259: LD_INT 2
58261: PUSH
58262: EMPTY
58263: LIST
58264: LIST
58265: PPUSH
58266: NOP4
58270: PPUSH
58271: NOP4
58275: ST_TO_ADDR
// if need_heal_2 then
58276: NOP4
58280: IFFALSE 58441
// for j in need_heal_2 do
58282: NOP4
58286: PUSH
58287: NOP4
58291: PUSH
58292: FOR_IN
58293: IFFALSE 58439
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58295: NOP4
58299: PUSH
58300: NOP4
58304: PUSH
58305: NOP4
58309: ARRAY
58310: PPUSH
58311: LD_INT 2
58313: PUSH
58314: LD_INT 30
58316: PUSH
58317: LD_INT 6
58319: PUSH
58320: EMPTY
58321: LIST
58322: LIST
58323: PUSH
58324: LD_INT 30
58326: PUSH
58327: LD_INT 7
58329: PUSH
58330: EMPTY
58331: LIST
58332: LIST
58333: PUSH
58334: LD_INT 30
58336: PUSH
58337: LD_INT 8
58339: PUSH
58340: EMPTY
58341: LIST
58342: LIST
58343: PUSH
58344: LD_INT 30
58346: PUSH
58347: LD_INT 0
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: PUSH
58354: LD_INT 30
58356: PUSH
58357: LD_INT 1
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PUSH
58364: EMPTY
58365: LIST
58366: LIST
58367: LIST
58368: LIST
58369: LIST
58370: LIST
58371: PPUSH
58372: NOP4
58376: ST_TO_ADDR
// if tmp then
58377: NOP4
58381: IFFALSE 58437
// begin k := NearestUnitToUnit ( tmp , j ) ;
58383: NOP4
58387: PUSH
58388: NOP4
58392: PPUSH
58393: NOP4
58397: PPUSH
58398: NOP4
58402: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58403: NOP4
58407: PPUSH
58408: NOP4
58412: PPUSH
58413: NOP4
58417: PUSH
58418: LD_INT 5
58420: GREATER
58421: IFFALSE 58437
// ComMoveToNearbyEntrance ( j , k ) ;
58423: NOP4
58427: PPUSH
58428: NOP4
58432: PPUSH
58433: NOP4
// end ; end ;
58437: GO 58292
58439: POP
58440: POP
// if not need_heal_1 and not need_heal_2 then
58441: NOP4
58445: NOT
58446: PUSH
58447: NOP4
58451: NOT
58452: AND
58453: IFFALSE 58457
// continue ;
58455: GO 57921
// end ;
58457: GO 57921
58459: POP
58460: POP
// RaiseSailEvent ( 102 ) ;
58461: LD_INT 102
58463: PPUSH
58464: NOP4
// end ;
58468: LD_VAR 0 1
58472: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
58473: LD_INT 0
58475: PPUSH
58476: PPUSH
58477: PPUSH
58478: PPUSH
58479: PPUSH
58480: PPUSH
58481: PPUSH
58482: PPUSH
// if not mc_bases then
58483: NOP4
58487: NOT
58488: IFFALSE 58492
// exit ;
58490: GO 59375
// for i = 1 to mc_bases do
58492: NOP4
58496: PUSH
58497: DOUBLE
58498: LD_INT 1
58500: DEC
58501: ST_TO_ADDR
58502: NOP4
58506: PUSH
58507: FOR_TO
58508: IFFALSE 59373
// begin if not mc_building_need_repair [ i ] then
58510: NOP4
58514: PUSH
58515: NOP4
58519: ARRAY
58520: NOT
58521: IFFALSE 58708
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
58523: NOP4
58527: PUSH
58528: NOP4
58532: PUSH
58533: NOP4
58537: ARRAY
58538: PPUSH
58539: LD_INT 3
58541: PUSH
58542: LD_INT 24
58544: PUSH
58545: LD_INT 1000
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: PUSH
58556: LD_INT 2
58558: PUSH
58559: LD_INT 34
58561: PUSH
58562: LD_INT 13
58564: PUSH
58565: EMPTY
58566: LIST
58567: LIST
58568: PUSH
58569: LD_INT 34
58571: PUSH
58572: LD_INT 52
58574: PUSH
58575: EMPTY
58576: LIST
58577: LIST
58578: PUSH
58579: LD_INT 34
58581: PUSH
58582: NOP4
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: PUSH
58591: EMPTY
58592: LIST
58593: LIST
58594: LIST
58595: LIST
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PPUSH
58601: NOP4
58605: ST_TO_ADDR
// if cranes then
58606: NOP4
58610: IFFALSE 58672
// for j in cranes do
58612: NOP4
58616: PUSH
58617: NOP4
58621: PUSH
58622: FOR_IN
58623: IFFALSE 58670
// if not IsInArea ( j , mc_parking [ i ] ) then
58625: NOP4
58629: PPUSH
58630: NOP4
58634: PUSH
58635: NOP4
58639: ARRAY
58640: PPUSH
58641: NOP4
58645: NOT
58646: IFFALSE 58668
// ComMoveToArea ( j , mc_parking [ i ] ) ;
58648: NOP4
58652: PPUSH
58653: NOP4
58657: PUSH
58658: NOP4
58662: ARRAY
58663: PPUSH
58664: NOP4
58668: GO 58622
58670: POP
58671: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58672: NOP4
58676: PUSH
58677: NOP4
58681: PPUSH
58682: NOP4
58686: PPUSH
58687: EMPTY
58688: PPUSH
58689: NOP4
58693: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
58694: NOP4
58698: PPUSH
58699: LD_INT 101
58701: PPUSH
58702: NOP4
// continue ;
58706: GO 58507
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
58708: NOP4
58712: PUSH
58713: NOP4
58717: PPUSH
58718: NOP4
58722: PPUSH
58723: EMPTY
58724: PPUSH
58725: NOP4
58729: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
58730: NOP4
58734: PPUSH
58735: LD_INT 103
58737: PPUSH
58738: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
58742: NOP4
58746: PUSH
58747: NOP4
58751: PUSH
58752: NOP4
58756: ARRAY
58757: PUSH
58758: NOP4
58762: PUSH
58763: NOP4
58767: ARRAY
58768: UNION
58769: PPUSH
58770: LD_INT 2
58772: PUSH
58773: LD_INT 25
58775: PUSH
58776: LD_INT 2
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: PUSH
58783: LD_INT 25
58785: PUSH
58786: LD_INT 16
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: PUSH
58793: EMPTY
58794: LIST
58795: LIST
58796: LIST
58797: PUSH
58798: EMPTY
58799: LIST
58800: PPUSH
58801: NOP4
58805: ST_TO_ADDR
// if mc_need_heal [ i ] then
58806: NOP4
58810: PUSH
58811: NOP4
58815: ARRAY
58816: IFFALSE 58860
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
58818: NOP4
58822: PUSH
58823: NOP4
58827: PUSH
58828: NOP4
58832: PUSH
58833: NOP4
58837: ARRAY
58838: PUSH
58839: LD_INT 1
58841: ARRAY
58842: PUSH
58843: NOP4
58847: PUSH
58848: NOP4
58852: ARRAY
58853: PUSH
58854: LD_INT 2
58856: ARRAY
58857: UNION
58858: DIFF
58859: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
58860: NOP4
58864: PUSH
58865: NOP4
58869: PUSH
58870: NOP4
58874: ARRAY
58875: PPUSH
58876: LD_INT 2
58878: PUSH
58879: LD_INT 34
58881: PUSH
58882: LD_INT 13
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: PUSH
58889: LD_INT 34
58891: PUSH
58892: LD_INT 52
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: LD_INT 34
58901: PUSH
58902: NOP4
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: LIST
58915: LIST
58916: PPUSH
58917: NOP4
58921: ST_TO_ADDR
// if cranes then
58922: NOP4
58926: IFFALSE 59062
// begin for j in cranes do
58928: NOP4
58932: PUSH
58933: NOP4
58937: PUSH
58938: FOR_IN
58939: IFFALSE 59060
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
58941: NOP4
58945: PPUSH
58946: NOP4
58950: PUSH
58951: LD_INT 1000
58953: EQUAL
58954: PUSH
58955: NOP4
58959: PPUSH
58960: NOP4
58964: NOT
58965: AND
58966: IFFALSE 59000
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
58968: NOP4
58972: PPUSH
58973: NOP4
58977: PUSH
58978: NOP4
58982: ARRAY
58983: PPUSH
58984: NOP4
58988: PPUSH
58989: NOP4
58993: PPUSH
58994: NOP4
58998: GO 59058
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59000: NOP4
59004: PPUSH
59005: NOP4
59009: PUSH
59010: LD_INT 500
59012: LESS
59013: PUSH
59014: NOP4
59018: PPUSH
59019: NOP4
59023: PUSH
59024: NOP4
59028: ARRAY
59029: PPUSH
59030: NOP4
59034: NOT
59035: AND
59036: IFFALSE 59058
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59038: NOP4
59042: PPUSH
59043: NOP4
59047: PUSH
59048: NOP4
59052: ARRAY
59053: PPUSH
59054: NOP4
// end ;
59058: GO 58938
59060: POP
59061: POP
// end ; if tmp > 3 then
59062: NOP4
59066: PUSH
59067: LD_INT 3
59069: GREATER
59070: IFFALSE 59090
// tmp := ShrinkArray ( tmp , 4 ) ;
59072: NOP4
59076: PUSH
59077: NOP4
59081: PPUSH
59082: LD_INT 4
59084: PPUSH
59085: NOP4
59089: ST_TO_ADDR
// if not tmp then
59090: NOP4
59094: NOT
59095: IFFALSE 59099
// continue ;
59097: GO 58507
// for j in tmp do
59099: NOP4
59103: PUSH
59104: NOP4
59108: PUSH
59109: FOR_IN
59110: IFFALSE 59369
// begin if IsInUnit ( j ) then
59112: NOP4
59116: PPUSH
59117: NOP4
59121: IFFALSE 59132
// ComExitBuilding ( j ) ;
59123: NOP4
59127: PPUSH
59128: NOP4
// if not j in mc_building_repairs [ i ] then
59132: NOP4
59136: PUSH
59137: NOP4
59141: PUSH
59142: NOP4
59146: ARRAY
59147: IN
59148: NOT
59149: IFFALSE 59207
// begin SetTag ( j , 101 ) ;
59151: NOP4
59155: PPUSH
59156: LD_INT 101
59158: PPUSH
59159: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59163: NOP4
59167: PUSH
59168: NOP4
59172: PPUSH
59173: NOP4
59177: PUSH
59178: NOP4
59182: PUSH
59183: NOP4
59187: ARRAY
59188: PUSH
59189: LD_INT 1
59191: PLUS
59192: PUSH
59193: EMPTY
59194: LIST
59195: LIST
59196: PPUSH
59197: NOP4
59201: PPUSH
59202: NOP4
59206: ST_TO_ADDR
// end ; wait ( 1 ) ;
59207: LD_INT 1
59209: PPUSH
59210: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
59214: NOP4
59218: PUSH
59219: NOP4
59223: PUSH
59224: NOP4
59228: ARRAY
59229: ST_TO_ADDR
// if mc_scan [ i ] then
59230: NOP4
59234: PUSH
59235: NOP4
59239: ARRAY
59240: IFFALSE 59302
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59242: NOP4
59246: PUSH
59247: NOP4
59251: PUSH
59252: NOP4
59256: ARRAY
59257: PPUSH
59258: LD_INT 3
59260: PUSH
59261: LD_INT 30
59263: PUSH
59264: LD_INT 32
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: PUSH
59271: LD_INT 30
59273: PUSH
59274: LD_INT 33
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: PUSH
59281: LD_INT 30
59283: PUSH
59284: LD_INT 31
59286: PUSH
59287: EMPTY
59288: LIST
59289: LIST
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: LIST
59295: LIST
59296: PPUSH
59297: NOP4
59301: ST_TO_ADDR
// if not to_repair_tmp then
59302: NOP4
59306: NOT
59307: IFFALSE 59311
// continue ;
59309: GO 59109
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59311: NOP4
59315: PUSH
59316: NOP4
59320: PPUSH
59321: NOP4
59325: PPUSH
59326: NOP4
59330: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
59331: NOP4
59335: PPUSH
59336: LD_INT 16
59338: PPUSH
59339: NOP4
59343: PUSH
59344: LD_INT 4
59346: ARRAY
59347: PUSH
59348: LD_INT 10
59350: LESS
59351: IFFALSE 59367
// ComRepairBuilding ( j , to_repair ) ;
59353: NOP4
59357: PPUSH
59358: NOP4
59362: PPUSH
59363: NOP4
// end ;
59367: GO 59109
59369: POP
59370: POP
// end ;
59371: GO 58507
59373: POP
59374: POP
// end ;
59375: LD_VAR 0 1
59379: RET
// export function MC_Heal ; var i , j , tmp ; begin
59380: LD_INT 0
59382: PPUSH
59383: PPUSH
59384: PPUSH
59385: PPUSH
// if not mc_bases then
59386: NOP4
59390: NOT
59391: IFFALSE 59395
// exit ;
59393: GO 59797
// for i = 1 to mc_bases do
59395: NOP4
59399: PUSH
59400: DOUBLE
59401: LD_INT 1
59403: DEC
59404: ST_TO_ADDR
59405: NOP4
59409: PUSH
59410: FOR_TO
59411: IFFALSE 59795
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59413: NOP4
59417: PUSH
59418: NOP4
59422: ARRAY
59423: PUSH
59424: LD_INT 1
59426: ARRAY
59427: NOT
59428: PUSH
59429: NOP4
59433: PUSH
59434: NOP4
59438: ARRAY
59439: PUSH
59440: LD_INT 2
59442: ARRAY
59443: NOT
59444: AND
59445: IFFALSE 59483
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
59447: NOP4
59451: PUSH
59452: NOP4
59456: PPUSH
59457: NOP4
59461: PPUSH
59462: EMPTY
59463: PPUSH
59464: NOP4
59468: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
59469: NOP4
59473: PPUSH
59474: LD_INT 102
59476: PPUSH
59477: NOP4
// continue ;
59481: GO 59410
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59483: NOP4
59487: PUSH
59488: NOP4
59492: PUSH
59493: NOP4
59497: ARRAY
59498: PPUSH
59499: LD_INT 25
59501: PUSH
59502: LD_INT 4
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: PPUSH
59509: NOP4
59513: ST_TO_ADDR
// if not tmp then
59514: NOP4
59518: NOT
59519: IFFALSE 59523
// continue ;
59521: GO 59410
// if mc_taming [ i ] then
59523: NOP4
59527: PUSH
59528: NOP4
59532: ARRAY
59533: IFFALSE 59557
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59535: NOP4
59539: PUSH
59540: NOP4
59544: PPUSH
59545: NOP4
59549: PPUSH
59550: EMPTY
59551: PPUSH
59552: NOP4
59556: ST_TO_ADDR
// for j in tmp do
59557: NOP4
59561: PUSH
59562: NOP4
59566: PUSH
59567: FOR_IN
59568: IFFALSE 59791
// begin if IsInUnit ( j ) then
59570: NOP4
59574: PPUSH
59575: NOP4
59579: IFFALSE 59590
// ComExitBuilding ( j ) ;
59581: NOP4
59585: PPUSH
59586: NOP4
// if not j in mc_healers [ i ] then
59590: NOP4
59594: PUSH
59595: NOP4
59599: PUSH
59600: NOP4
59604: ARRAY
59605: IN
59606: NOT
59607: IFFALSE 59653
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
59609: NOP4
59613: PUSH
59614: NOP4
59618: PPUSH
59619: NOP4
59623: PUSH
59624: NOP4
59628: PUSH
59629: NOP4
59633: ARRAY
59634: PUSH
59635: LD_INT 1
59637: PLUS
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PPUSH
59643: NOP4
59647: PPUSH
59648: NOP4
59652: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
59653: NOP4
59657: PPUSH
59658: NOP4
59662: PUSH
59663: LD_INT 102
59665: NONEQUAL
59666: IFFALSE 59680
// SetTag ( j , 102 ) ;
59668: NOP4
59672: PPUSH
59673: LD_INT 102
59675: PPUSH
59676: NOP4
// Wait ( 3 ) ;
59680: LD_INT 3
59682: PPUSH
59683: NOP4
// if mc_need_heal [ i ] [ 1 ] then
59687: NOP4
59691: PUSH
59692: NOP4
59696: ARRAY
59697: PUSH
59698: LD_INT 1
59700: ARRAY
59701: IFFALSE 59733
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
59703: NOP4
59707: PPUSH
59708: NOP4
59712: PUSH
59713: NOP4
59717: ARRAY
59718: PUSH
59719: LD_INT 1
59721: ARRAY
59722: PUSH
59723: LD_INT 1
59725: ARRAY
59726: PPUSH
59727: NOP4
59731: GO 59789
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
59733: NOP4
59737: PPUSH
59738: NOP4
59742: NOT
59743: PUSH
59744: NOP4
59748: PUSH
59749: NOP4
59753: ARRAY
59754: PUSH
59755: LD_INT 2
59757: ARRAY
59758: AND
59759: IFFALSE 59789
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
59761: NOP4
59765: PPUSH
59766: NOP4
59770: PUSH
59771: NOP4
59775: ARRAY
59776: PUSH
59777: LD_INT 2
59779: ARRAY
59780: PUSH
59781: LD_INT 1
59783: ARRAY
59784: PPUSH
59785: NOP4
// end ;
59789: GO 59567
59791: POP
59792: POP
// end ;
59793: GO 59410
59795: POP
59796: POP
// end ;
59797: LD_VAR 0 1
59801: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
59802: LD_INT 0
59804: PPUSH
59805: PPUSH
59806: PPUSH
59807: PPUSH
59808: PPUSH
// if not mc_bases then
59809: NOP4
59813: NOT
59814: IFFALSE 59818
// exit ;
59816: GO 60989
// for i = 1 to mc_bases do
59818: NOP4
59822: PUSH
59823: DOUBLE
59824: LD_INT 1
59826: DEC
59827: ST_TO_ADDR
59828: NOP4
59832: PUSH
59833: FOR_TO
59834: IFFALSE 60987
// begin if mc_scan [ i ] then
59836: NOP4
59840: PUSH
59841: NOP4
59845: ARRAY
59846: IFFALSE 59850
// continue ;
59848: GO 59833
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
59850: NOP4
59854: PUSH
59855: NOP4
59859: ARRAY
59860: NOT
59861: PUSH
59862: NOP4
59866: PUSH
59867: NOP4
59871: ARRAY
59872: NOT
59873: AND
59874: PUSH
59875: NOP4
59879: PUSH
59880: NOP4
59884: ARRAY
59885: AND
59886: IFFALSE 59924
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
59888: NOP4
59892: PUSH
59893: NOP4
59897: PPUSH
59898: NOP4
59902: PPUSH
59903: EMPTY
59904: PPUSH
59905: NOP4
59909: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59910: NOP4
59914: PPUSH
59915: LD_INT 103
59917: PPUSH
59918: NOP4
// continue ;
59922: GO 59833
// end ; if mc_construct_list [ i ] then
59924: NOP4
59928: PUSH
59929: NOP4
59933: ARRAY
59934: IFFALSE 60154
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
59936: NOP4
59940: PUSH
59941: NOP4
59945: PUSH
59946: NOP4
59950: ARRAY
59951: PPUSH
59952: LD_INT 25
59954: PUSH
59955: LD_INT 2
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: PPUSH
59962: NOP4
59966: PUSH
59967: NOP4
59971: PUSH
59972: NOP4
59976: ARRAY
59977: DIFF
59978: ST_TO_ADDR
// if not tmp then
59979: NOP4
59983: NOT
59984: IFFALSE 59988
// continue ;
59986: GO 59833
// for j in tmp do
59988: NOP4
59992: PUSH
59993: NOP4
59997: PUSH
59998: FOR_IN
59999: IFFALSE 60150
// begin if not mc_builders [ i ] then
60001: NOP4
60005: PUSH
60006: NOP4
60010: ARRAY
60011: NOT
60012: IFFALSE 60070
// begin SetTag ( j , 103 ) ;
60014: NOP4
60018: PPUSH
60019: LD_INT 103
60021: PPUSH
60022: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60026: NOP4
60030: PUSH
60031: NOP4
60035: PPUSH
60036: NOP4
60040: PUSH
60041: NOP4
60045: PUSH
60046: NOP4
60050: ARRAY
60051: PUSH
60052: LD_INT 1
60054: PLUS
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PPUSH
60060: NOP4
60064: PPUSH
60065: NOP4
60069: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60070: NOP4
60074: PPUSH
60075: NOP4
60079: IFFALSE 60090
// ComExitBuilding ( j ) ;
60081: NOP4
60085: PPUSH
60086: NOP4
// wait ( 3 ) ;
60090: LD_INT 3
60092: PPUSH
60093: NOP4
// if not mc_construct_list [ i ] then
60097: NOP4
60101: PUSH
60102: NOP4
60106: ARRAY
60107: NOT
60108: IFFALSE 60112
// break ;
60110: GO 60150
// if not HasTask ( j ) then
60112: NOP4
60116: PPUSH
60117: NOP4
60121: NOT
60122: IFFALSE 60148
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60124: NOP4
60128: PPUSH
60129: NOP4
60133: PUSH
60134: NOP4
60138: ARRAY
60139: PUSH
60140: LD_INT 1
60142: ARRAY
60143: PPUSH
60144: NOP4
// end ;
60148: GO 59998
60150: POP
60151: POP
// end else
60152: GO 60985
// if mc_build_list [ i ] then
60154: NOP4
60158: PUSH
60159: NOP4
60163: ARRAY
60164: IFFALSE 60985
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60166: NOP4
60170: PUSH
60171: NOP4
60175: PUSH
60176: NOP4
60180: ARRAY
60181: PPUSH
60182: LD_INT 2
60184: PUSH
60185: LD_INT 30
60187: PUSH
60188: LD_INT 0
60190: PUSH
60191: EMPTY
60192: LIST
60193: LIST
60194: PUSH
60195: LD_INT 30
60197: PUSH
60198: LD_INT 1
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: PUSH
60205: EMPTY
60206: LIST
60207: LIST
60208: LIST
60209: PPUSH
60210: NOP4
60214: ST_TO_ADDR
// if depot then
60215: NOP4
60219: IFFALSE 60237
// depot := depot [ 1 ] else
60221: NOP4
60225: PUSH
60226: NOP4
60230: PUSH
60231: LD_INT 1
60233: ARRAY
60234: ST_TO_ADDR
60235: GO 60245
// depot := 0 ;
60237: NOP4
60241: PUSH
60242: LD_INT 0
60244: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60245: NOP4
60249: PUSH
60250: NOP4
60254: ARRAY
60255: PUSH
60256: LD_INT 1
60258: ARRAY
60259: PUSH
60260: LD_INT 1
60262: ARRAY
60263: PPUSH
60264: NOP4
60268: PUSH
60269: NOP4
60273: PUSH
60274: NOP4
60278: ARRAY
60279: PPUSH
60280: LD_INT 2
60282: PUSH
60283: LD_INT 30
60285: PUSH
60286: LD_INT 2
60288: PUSH
60289: EMPTY
60290: LIST
60291: LIST
60292: PUSH
60293: LD_INT 30
60295: PUSH
60296: LD_INT 3
60298: PUSH
60299: EMPTY
60300: LIST
60301: LIST
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: LIST
60307: PPUSH
60308: NOP4
60312: NOT
60313: AND
60314: IFFALSE 60419
// begin for j = 1 to mc_build_list [ i ] do
60316: NOP4
60320: PUSH
60321: DOUBLE
60322: LD_INT 1
60324: DEC
60325: ST_TO_ADDR
60326: NOP4
60330: PUSH
60331: NOP4
60335: ARRAY
60336: PUSH
60337: FOR_TO
60338: IFFALSE 60417
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60340: NOP4
60344: PUSH
60345: NOP4
60349: ARRAY
60350: PUSH
60351: NOP4
60355: ARRAY
60356: PUSH
60357: LD_INT 1
60359: ARRAY
60360: PUSH
60361: LD_INT 2
60363: EQUAL
60364: IFFALSE 60415
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60366: NOP4
60370: PUSH
60371: NOP4
60375: PPUSH
60376: NOP4
60380: PPUSH
60381: NOP4
60385: PUSH
60386: NOP4
60390: ARRAY
60391: PPUSH
60392: NOP4
60396: PPUSH
60397: LD_INT 1
60399: PPUSH
60400: LD_INT 0
60402: PPUSH
60403: NOP4
60407: PPUSH
60408: NOP4
60412: ST_TO_ADDR
// break ;
60413: GO 60417
// end ;
60415: GO 60337
60417: POP
60418: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
60419: NOP4
60423: PUSH
60424: NOP4
60428: ARRAY
60429: PUSH
60430: LD_INT 1
60432: ARRAY
60433: PUSH
60434: LD_INT 1
60436: ARRAY
60437: PUSH
60438: LD_INT 0
60440: EQUAL
60441: PUSH
60442: NOP4
60446: PUSH
60447: NOP4
60451: PPUSH
60452: NOP4
60456: PUSH
60457: NOP4
60461: ARRAY
60462: PUSH
60463: LD_INT 1
60465: ARRAY
60466: PUSH
60467: LD_INT 1
60469: ARRAY
60470: PPUSH
60471: NOP4
60475: PUSH
60476: NOP4
60480: ARRAY
60481: PUSH
60482: LD_INT 1
60484: ARRAY
60485: PUSH
60486: LD_INT 2
60488: ARRAY
60489: PPUSH
60490: NOP4
60494: PUSH
60495: NOP4
60499: ARRAY
60500: PUSH
60501: LD_INT 1
60503: ARRAY
60504: PUSH
60505: LD_INT 3
60507: ARRAY
60508: PPUSH
60509: NOP4
60513: PUSH
60514: NOP4
60518: ARRAY
60519: PUSH
60520: LD_INT 1
60522: ARRAY
60523: PUSH
60524: LD_INT 4
60526: ARRAY
60527: PPUSH
60528: NOP4
60532: AND
60533: OR
60534: IFFALSE 60815
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60536: NOP4
60540: PUSH
60541: NOP4
60545: PUSH
60546: NOP4
60550: ARRAY
60551: PPUSH
60552: LD_INT 25
60554: PUSH
60555: LD_INT 2
60557: PUSH
60558: EMPTY
60559: LIST
60560: LIST
60561: PPUSH
60562: NOP4
60566: PUSH
60567: NOP4
60571: PUSH
60572: NOP4
60576: ARRAY
60577: DIFF
60578: ST_TO_ADDR
// if not tmp then
60579: NOP4
60583: NOT
60584: IFFALSE 60588
// continue ;
60586: GO 59833
// for j in tmp do
60588: NOP4
60592: PUSH
60593: NOP4
60597: PUSH
60598: FOR_IN
60599: IFFALSE 60811
// begin if not mc_builders [ i ] then
60601: NOP4
60605: PUSH
60606: NOP4
60610: ARRAY
60611: NOT
60612: IFFALSE 60670
// begin SetTag ( j , 103 ) ;
60614: NOP4
60618: PPUSH
60619: LD_INT 103
60621: PPUSH
60622: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60626: NOP4
60630: PUSH
60631: NOP4
60635: PPUSH
60636: NOP4
60640: PUSH
60641: NOP4
60645: PUSH
60646: NOP4
60650: ARRAY
60651: PUSH
60652: LD_INT 1
60654: PLUS
60655: PUSH
60656: EMPTY
60657: LIST
60658: LIST
60659: PPUSH
60660: NOP4
60664: PPUSH
60665: NOP4
60669: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60670: NOP4
60674: PPUSH
60675: NOP4
60679: IFFALSE 60690
// ComExitBuilding ( j ) ;
60681: NOP4
60685: PPUSH
60686: NOP4
// wait ( 3 ) ;
60690: LD_INT 3
60692: PPUSH
60693: NOP4
// if not mc_build_list [ i ] then
60697: NOP4
60701: PUSH
60702: NOP4
60706: ARRAY
60707: NOT
60708: IFFALSE 60712
// break ;
60710: GO 60811
// if not HasTask ( j ) then
60712: NOP4
60716: PPUSH
60717: NOP4
60721: NOT
60722: IFFALSE 60809
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
60724: NOP4
60728: PPUSH
60729: NOP4
60733: PUSH
60734: NOP4
60738: ARRAY
60739: PUSH
60740: LD_INT 1
60742: ARRAY
60743: PUSH
60744: LD_INT 1
60746: ARRAY
60747: PPUSH
60748: NOP4
60752: PUSH
60753: NOP4
60757: ARRAY
60758: PUSH
60759: LD_INT 1
60761: ARRAY
60762: PUSH
60763: LD_INT 2
60765: ARRAY
60766: PPUSH
60767: NOP4
60771: PUSH
60772: NOP4
60776: ARRAY
60777: PUSH
60778: LD_INT 1
60780: ARRAY
60781: PUSH
60782: LD_INT 3
60784: ARRAY
60785: PPUSH
60786: NOP4
60790: PUSH
60791: NOP4
60795: ARRAY
60796: PUSH
60797: LD_INT 1
60799: ARRAY
60800: PUSH
60801: LD_INT 4
60803: ARRAY
60804: PPUSH
60805: NOP4
// end ;
60809: GO 60598
60811: POP
60812: POP
// end else
60813: GO 60985
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
60815: NOP4
60819: PUSH
60820: NOP4
60824: ARRAY
60825: PPUSH
60826: NOP4
60830: PUSH
60831: NOP4
60835: ARRAY
60836: PUSH
60837: LD_INT 1
60839: ARRAY
60840: PUSH
60841: LD_INT 1
60843: ARRAY
60844: PPUSH
60845: NOP4
60849: PUSH
60850: NOP4
60854: ARRAY
60855: PUSH
60856: LD_INT 1
60858: ARRAY
60859: PUSH
60860: LD_INT 2
60862: ARRAY
60863: PPUSH
60864: NOP4
60868: PUSH
60869: NOP4
60873: ARRAY
60874: PUSH
60875: LD_INT 1
60877: ARRAY
60878: PUSH
60879: LD_INT 3
60881: ARRAY
60882: PPUSH
60883: NOP4
60887: PUSH
60888: NOP4
60892: ARRAY
60893: PUSH
60894: LD_INT 1
60896: ARRAY
60897: PUSH
60898: LD_INT 4
60900: ARRAY
60901: PPUSH
60902: NOP4
60906: PUSH
60907: NOP4
60911: ARRAY
60912: PPUSH
60913: LD_INT 21
60915: PUSH
60916: LD_INT 3
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PPUSH
60923: NOP4
60927: PPUSH
60928: EMPTY
60929: PPUSH
60930: NOP4
60934: NOT
60935: IFFALSE 60985
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
60937: NOP4
60941: PUSH
60942: NOP4
60946: PPUSH
60947: NOP4
60951: PPUSH
60952: NOP4
60956: PUSH
60957: NOP4
60961: ARRAY
60962: PPUSH
60963: LD_INT 1
60965: PPUSH
60966: LD_INT 1
60968: NEG
60969: PPUSH
60970: LD_INT 0
60972: PPUSH
60973: NOP4
60977: PPUSH
60978: NOP4
60982: ST_TO_ADDR
// continue ;
60983: GO 59833
// end ; end ; end ;
60985: GO 59833
60987: POP
60988: POP
// end ;
60989: LD_VAR 0 1
60993: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
60994: LD_INT 0
60996: PPUSH
60997: PPUSH
60998: PPUSH
60999: PPUSH
61000: PPUSH
61001: PPUSH
// if not mc_bases then
61002: NOP4
61006: NOT
61007: IFFALSE 61011
// exit ;
61009: GO 61438
// for i = 1 to mc_bases do
61011: NOP4
61015: PUSH
61016: DOUBLE
61017: LD_INT 1
61019: DEC
61020: ST_TO_ADDR
61021: NOP4
61025: PUSH
61026: FOR_TO
61027: IFFALSE 61436
// begin tmp := mc_build_upgrade [ i ] ;
61029: NOP4
61033: PUSH
61034: NOP4
61038: PUSH
61039: NOP4
61043: ARRAY
61044: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61045: NOP4
61049: PUSH
61050: NOP4
61054: PUSH
61055: NOP4
61059: ARRAY
61060: PPUSH
61061: LD_INT 2
61063: PUSH
61064: LD_INT 30
61066: PUSH
61067: LD_INT 6
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 30
61076: PUSH
61077: LD_INT 7
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: LIST
61088: PPUSH
61089: NOP4
61093: ST_TO_ADDR
// if not tmp and not lab then
61094: NOP4
61098: NOT
61099: PUSH
61100: NOP4
61104: NOT
61105: AND
61106: IFFALSE 61110
// continue ;
61108: GO 61026
// if tmp then
61110: NOP4
61114: IFFALSE 61234
// for j in tmp do
61116: NOP4
61120: PUSH
61121: NOP4
61125: PUSH
61126: FOR_IN
61127: IFFALSE 61232
// begin if UpgradeCost ( j ) then
61129: NOP4
61133: PPUSH
61134: NOP4
61138: IFFALSE 61230
// begin ComUpgrade ( j ) ;
61140: NOP4
61144: PPUSH
61145: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61149: NOP4
61153: PUSH
61154: NOP4
61158: PPUSH
61159: NOP4
61163: PPUSH
61164: NOP4
61168: PUSH
61169: NOP4
61173: ARRAY
61174: PUSH
61175: NOP4
61179: DIFF
61180: PPUSH
61181: NOP4
61185: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61186: NOP4
61190: PUSH
61191: NOP4
61195: PPUSH
61196: NOP4
61200: PUSH
61201: NOP4
61205: PUSH
61206: NOP4
61210: ARRAY
61211: PUSH
61212: LD_INT 1
61214: PLUS
61215: PUSH
61216: EMPTY
61217: LIST
61218: LIST
61219: PPUSH
61220: NOP4
61224: PPUSH
61225: NOP4
61229: ST_TO_ADDR
// end ; end ;
61230: GO 61126
61232: POP
61233: POP
// if not lab or not mc_lab_upgrade [ i ] then
61234: NOP4
61238: NOT
61239: PUSH
61240: NOP4
61244: PUSH
61245: NOP4
61249: ARRAY
61250: NOT
61251: OR
61252: IFFALSE 61256
// continue ;
61254: GO 61026
// for j in lab do
61256: NOP4
61260: PUSH
61261: NOP4
61265: PUSH
61266: FOR_IN
61267: IFFALSE 61432
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61269: NOP4
61273: PPUSH
61274: NOP4
61278: PUSH
61279: LD_INT 6
61281: PUSH
61282: LD_INT 7
61284: PUSH
61285: EMPTY
61286: LIST
61287: LIST
61288: IN
61289: PUSH
61290: NOP4
61294: PPUSH
61295: NOP4
61299: PUSH
61300: LD_INT 1
61302: NONEQUAL
61303: AND
61304: IFFALSE 61430
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61306: NOP4
61310: PPUSH
61311: NOP4
61315: PUSH
61316: NOP4
61320: ARRAY
61321: PUSH
61322: LD_INT 1
61324: ARRAY
61325: PPUSH
61326: NOP4
61330: IFFALSE 61430
// begin ComCancel ( j ) ;
61332: NOP4
61336: PPUSH
61337: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61341: NOP4
61345: PPUSH
61346: NOP4
61350: PUSH
61351: NOP4
61355: ARRAY
61356: PUSH
61357: LD_INT 1
61359: ARRAY
61360: PPUSH
61361: NOP4
// if not j in mc_construct_list [ i ] then
61365: NOP4
61369: PUSH
61370: NOP4
61374: PUSH
61375: NOP4
61379: ARRAY
61380: IN
61381: NOT
61382: IFFALSE 61428
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61384: NOP4
61388: PUSH
61389: NOP4
61393: PPUSH
61394: NOP4
61398: PUSH
61399: NOP4
61403: PUSH
61404: NOP4
61408: ARRAY
61409: PUSH
61410: LD_INT 1
61412: PLUS
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PPUSH
61418: NOP4
61422: PPUSH
61423: NOP4
61427: ST_TO_ADDR
// break ;
61428: GO 61432
// end ; end ; end ;
61430: GO 61266
61432: POP
61433: POP
// end ;
61434: GO 61026
61436: POP
61437: POP
// end ;
61438: LD_VAR 0 1
61442: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
61443: LD_INT 0
61445: PPUSH
61446: PPUSH
61447: PPUSH
61448: PPUSH
61449: PPUSH
61450: PPUSH
61451: PPUSH
61452: PPUSH
61453: PPUSH
// if not mc_bases then
61454: NOP4
61458: NOT
61459: IFFALSE 61463
// exit ;
61461: GO 61868
// for i = 1 to mc_bases do
61463: NOP4
61467: PUSH
61468: DOUBLE
61469: LD_INT 1
61471: DEC
61472: ST_TO_ADDR
61473: NOP4
61477: PUSH
61478: FOR_TO
61479: IFFALSE 61866
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
61481: NOP4
61485: PUSH
61486: NOP4
61490: ARRAY
61491: NOT
61492: PUSH
61493: NOP4
61497: PUSH
61498: NOP4
61502: ARRAY
61503: PPUSH
61504: LD_INT 30
61506: PUSH
61507: LD_INT 3
61509: PUSH
61510: EMPTY
61511: LIST
61512: LIST
61513: PPUSH
61514: NOP4
61518: NOT
61519: OR
61520: IFFALSE 61524
// continue ;
61522: GO 61478
// busy := false ;
61524: NOP4
61528: PUSH
61529: LD_INT 0
61531: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
61532: NOP4
61536: PUSH
61537: NOP4
61541: PUSH
61542: NOP4
61546: ARRAY
61547: PPUSH
61548: LD_INT 30
61550: PUSH
61551: LD_INT 3
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: PPUSH
61558: NOP4
61562: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
61563: NOP4
61567: PUSH
61568: NOP4
61572: PUSH
61573: NOP4
61577: ARRAY
61578: PPUSH
61579: LD_INT 2
61581: PUSH
61582: LD_INT 30
61584: PUSH
61585: LD_INT 32
61587: PUSH
61588: EMPTY
61589: LIST
61590: LIST
61591: PUSH
61592: LD_INT 30
61594: PUSH
61595: LD_INT 33
61597: PUSH
61598: EMPTY
61599: LIST
61600: LIST
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: LIST
61606: PPUSH
61607: NOP4
61611: ST_TO_ADDR
// if not t then
61612: NOP4
61616: NOT
61617: IFFALSE 61621
// continue ;
61619: GO 61478
// for j in tmp do
61621: NOP4
61625: PUSH
61626: NOP4
61630: PUSH
61631: FOR_IN
61632: IFFALSE 61662
// if not BuildingStatus ( j ) = bs_idle then
61634: NOP4
61638: PPUSH
61639: NOP4
61643: PUSH
61644: LD_INT 2
61646: EQUAL
61647: NOT
61648: IFFALSE 61660
// begin busy := true ;
61650: NOP4
61654: PUSH
61655: LD_INT 1
61657: ST_TO_ADDR
// break ;
61658: GO 61662
// end ;
61660: GO 61631
61662: POP
61663: POP
// if busy then
61664: NOP4
61668: IFFALSE 61672
// continue ;
61670: GO 61478
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
61672: NOP4
61676: PUSH
61677: NOP4
61681: PPUSH
61682: LD_INT 35
61684: PUSH
61685: LD_INT 0
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: NOP4
61696: ST_TO_ADDR
// if tw then
61697: NOP4
61701: IFFALSE 61778
// begin tw := tw [ 1 ] ;
61703: NOP4
61707: PUSH
61708: NOP4
61712: PUSH
61713: LD_INT 1
61715: ARRAY
61716: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
61717: NOP4
61721: PUSH
61722: NOP4
61726: PPUSH
61727: NOP4
61731: PUSH
61732: NOP4
61736: ARRAY
61737: PPUSH
61738: NOP4
61742: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
61743: NOP4
61747: PUSH
61748: NOP4
61752: ARRAY
61753: IFFALSE 61776
// if not weapon in mc_allowed_tower_weapons [ i ] then
61755: NOP4
61759: PUSH
61760: NOP4
61764: PUSH
61765: NOP4
61769: ARRAY
61770: IN
61771: NOT
61772: IFFALSE 61776
// continue ;
61774: GO 61478
// end else
61776: GO 61841
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
61778: NOP4
61782: PUSH
61783: NOP4
61787: PUSH
61788: NOP4
61792: ARRAY
61793: PPUSH
61794: NOP4
61798: PPUSH
61799: NOP4
61803: ST_TO_ADDR
// if not tmp2 then
61804: NOP4
61808: NOT
61809: IFFALSE 61813
// continue ;
61811: GO 61478
// tw := tmp2 [ 1 ] ;
61813: NOP4
61817: PUSH
61818: NOP4
61822: PUSH
61823: LD_INT 1
61825: ARRAY
61826: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
61827: NOP4
61831: PUSH
61832: NOP4
61836: PUSH
61837: LD_INT 2
61839: ARRAY
61840: ST_TO_ADDR
// end ; if not weapon then
61841: NOP4
61845: NOT
61846: IFFALSE 61850
// continue ;
61848: GO 61478
// ComPlaceWeapon ( tw , weapon ) ;
61850: NOP4
61854: PPUSH
61855: NOP4
61859: PPUSH
61860: NOP4
// end ;
61864: GO 61478
61866: POP
61867: POP
// end ;
61868: LD_VAR 0 1
61872: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
61873: LD_INT 0
61875: PPUSH
61876: PPUSH
61877: PPUSH
61878: PPUSH
61879: PPUSH
61880: PPUSH
61881: PPUSH
// if not mc_bases then
61882: NOP4
61886: NOT
61887: IFFALSE 61891
// exit ;
61889: GO 62659
// for i = 1 to mc_bases do
61891: NOP4
61895: PUSH
61896: DOUBLE
61897: LD_INT 1
61899: DEC
61900: ST_TO_ADDR
61901: NOP4
61905: PUSH
61906: FOR_TO
61907: IFFALSE 62657
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
61909: NOP4
61913: PUSH
61914: NOP4
61918: ARRAY
61919: NOT
61920: PUSH
61921: NOP4
61925: PUSH
61926: NOP4
61930: ARRAY
61931: PUSH
61932: NOP4
61936: PUSH
61937: NOP4
61941: ARRAY
61942: EQUAL
61943: OR
61944: PUSH
61945: NOP4
61949: PUSH
61950: NOP4
61954: ARRAY
61955: OR
61956: IFFALSE 61960
// continue ;
61958: GO 61906
// if mc_miners [ i ] then
61960: NOP4
61964: PUSH
61965: NOP4
61969: ARRAY
61970: IFFALSE 62344
// begin for j = mc_miners [ i ] downto 1 do
61972: NOP4
61976: PUSH
61977: DOUBLE
61978: NOP4
61982: PUSH
61983: NOP4
61987: ARRAY
61988: INC
61989: ST_TO_ADDR
61990: LD_INT 1
61992: PUSH
61993: FOR_DOWNTO
61994: IFFALSE 62342
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
61996: NOP4
62000: PUSH
62001: NOP4
62005: ARRAY
62006: PUSH
62007: NOP4
62011: ARRAY
62012: PPUSH
62013: NOP4
62017: PUSH
62018: NOP4
62022: PUSH
62023: NOP4
62027: ARRAY
62028: PUSH
62029: NOP4
62033: ARRAY
62034: PPUSH
62035: NOP4
62039: PUSH
62040: LD_INT 1
62042: NONEQUAL
62043: OR
62044: IFFALSE 62107
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62046: NOP4
62050: PUSH
62051: NOP4
62055: PUSH
62056: NOP4
62060: ARRAY
62061: PUSH
62062: NOP4
62066: PUSH
62067: NOP4
62071: ARRAY
62072: PUSH
62073: NOP4
62077: ARRAY
62078: DIFF
62079: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62080: NOP4
62084: PUSH
62085: NOP4
62089: PPUSH
62090: NOP4
62094: PPUSH
62095: NOP4
62099: PPUSH
62100: NOP4
62104: ST_TO_ADDR
// continue ;
62105: GO 61993
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62107: NOP4
62111: PUSH
62112: NOP4
62116: ARRAY
62117: PUSH
62118: NOP4
62122: ARRAY
62123: PPUSH
62124: NOP4
62128: PUSH
62129: LD_INT 1
62131: EQUAL
62132: PUSH
62133: NOP4
62137: PUSH
62138: NOP4
62142: ARRAY
62143: PUSH
62144: NOP4
62148: ARRAY
62149: PPUSH
62150: NOP4
62154: NOT
62155: AND
62156: PUSH
62157: NOP4
62161: PUSH
62162: NOP4
62166: ARRAY
62167: PUSH
62168: NOP4
62172: ARRAY
62173: PPUSH
62174: NOP4
62178: NOT
62179: AND
62180: IFFALSE 62340
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62182: NOP4
62186: PUSH
62187: NOP4
62191: ARRAY
62192: PUSH
62193: NOP4
62197: ARRAY
62198: PPUSH
62199: NOP4
62203: IFFALSE 62226
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62205: NOP4
62209: PUSH
62210: NOP4
62214: ARRAY
62215: PUSH
62216: NOP4
62220: ARRAY
62221: PPUSH
62222: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62226: NOP4
62230: PUSH
62231: NOP4
62235: ARRAY
62236: PUSH
62237: NOP4
62241: ARRAY
62242: PPUSH
62243: NOP4
62247: NOT
62248: IFFALSE 62340
// begin r := rand ( 1 , mc_mines [ i ] ) ;
62250: NOP4
62254: PUSH
62255: LD_INT 1
62257: PPUSH
62258: NOP4
62262: PUSH
62263: NOP4
62267: ARRAY
62268: PPUSH
62269: NOP4
62273: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
62274: NOP4
62278: PUSH
62279: NOP4
62283: ARRAY
62284: PUSH
62285: NOP4
62289: ARRAY
62290: PPUSH
62291: NOP4
62295: PUSH
62296: NOP4
62300: ARRAY
62301: PUSH
62302: NOP4
62306: ARRAY
62307: PUSH
62308: LD_INT 1
62310: ARRAY
62311: PPUSH
62312: NOP4
62316: PUSH
62317: NOP4
62321: ARRAY
62322: PUSH
62323: NOP4
62327: ARRAY
62328: PUSH
62329: LD_INT 2
62331: ARRAY
62332: PPUSH
62333: LD_INT 0
62335: PPUSH
62336: NOP4
// end ; end ; end ;
62340: GO 61993
62342: POP
62343: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62344: NOP4
62348: PUSH
62349: NOP4
62353: PUSH
62354: NOP4
62358: ARRAY
62359: PPUSH
62360: LD_INT 2
62362: PUSH
62363: LD_INT 30
62365: PUSH
62366: LD_INT 4
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PUSH
62373: LD_INT 30
62375: PUSH
62376: LD_INT 5
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PUSH
62383: LD_INT 30
62385: PUSH
62386: LD_INT 32
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: LIST
62397: LIST
62398: PPUSH
62399: NOP4
62403: ST_TO_ADDR
// if not tmp then
62404: NOP4
62408: NOT
62409: IFFALSE 62413
// continue ;
62411: GO 61906
// list := [ ] ;
62413: NOP4
62417: PUSH
62418: EMPTY
62419: ST_TO_ADDR
// for j in tmp do
62420: NOP4
62424: PUSH
62425: NOP4
62429: PUSH
62430: FOR_IN
62431: IFFALSE 62500
// begin for k in UnitsInside ( j ) do
62433: NOP4
62437: PUSH
62438: NOP4
62442: PPUSH
62443: NOP4
62447: PUSH
62448: FOR_IN
62449: IFFALSE 62496
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
62451: NOP4
62455: PPUSH
62456: NOP4
62460: PUSH
62461: LD_INT 1
62463: EQUAL
62464: PUSH
62465: NOP4
62469: PPUSH
62470: NOP4
62474: NOT
62475: AND
62476: IFFALSE 62494
// list := list ^ k ;
62478: NOP4
62482: PUSH
62483: NOP4
62487: PUSH
62488: NOP4
62492: ADD
62493: ST_TO_ADDR
62494: GO 62448
62496: POP
62497: POP
// end ;
62498: GO 62430
62500: POP
62501: POP
// list := list diff mc_miners [ i ] ;
62502: NOP4
62506: PUSH
62507: NOP4
62511: PUSH
62512: NOP4
62516: PUSH
62517: NOP4
62521: ARRAY
62522: DIFF
62523: ST_TO_ADDR
// if not list then
62524: NOP4
62528: NOT
62529: IFFALSE 62533
// continue ;
62531: GO 61906
// k := mc_mines [ i ] - mc_miners [ i ] ;
62533: NOP4
62537: PUSH
62538: NOP4
62542: PUSH
62543: NOP4
62547: ARRAY
62548: PUSH
62549: NOP4
62553: PUSH
62554: NOP4
62558: ARRAY
62559: MINUS
62560: ST_TO_ADDR
// if k > list then
62561: NOP4
62565: PUSH
62566: NOP4
62570: GREATER
62571: IFFALSE 62583
// k := list ;
62573: NOP4
62577: PUSH
62578: NOP4
62582: ST_TO_ADDR
// for j = 1 to k do
62583: NOP4
62587: PUSH
62588: DOUBLE
62589: LD_INT 1
62591: DEC
62592: ST_TO_ADDR
62593: NOP4
62597: PUSH
62598: FOR_TO
62599: IFFALSE 62653
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
62601: NOP4
62605: PUSH
62606: NOP4
62610: PPUSH
62611: NOP4
62615: PUSH
62616: NOP4
62620: PUSH
62621: NOP4
62625: ARRAY
62626: PUSH
62627: LD_INT 1
62629: PLUS
62630: PUSH
62631: EMPTY
62632: LIST
62633: LIST
62634: PPUSH
62635: NOP4
62639: PUSH
62640: NOP4
62644: ARRAY
62645: PPUSH
62646: NOP4
62650: ST_TO_ADDR
62651: GO 62598
62653: POP
62654: POP
// end ;
62655: GO 61906
62657: POP
62658: POP
// end ;
62659: LD_VAR 0 1
62663: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
62664: LD_INT 0
62666: PPUSH
62667: PPUSH
62668: PPUSH
62669: PPUSH
62670: PPUSH
62671: PPUSH
62672: PPUSH
62673: PPUSH
62674: PPUSH
62675: PPUSH
62676: PPUSH
// if not mc_bases then
62677: NOP4
62681: NOT
62682: IFFALSE 62686
// exit ;
62684: GO 64509
// for i = 1 to mc_bases do
62686: NOP4
62690: PUSH
62691: DOUBLE
62692: LD_INT 1
62694: DEC
62695: ST_TO_ADDR
62696: NOP4
62700: PUSH
62701: FOR_TO
62702: IFFALSE 64507
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
62704: NOP4
62708: PUSH
62709: NOP4
62713: ARRAY
62714: NOT
62715: PUSH
62716: NOP4
62720: PUSH
62721: NOP4
62725: ARRAY
62726: OR
62727: IFFALSE 62731
// continue ;
62729: GO 62701
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
62731: NOP4
62735: PUSH
62736: NOP4
62740: ARRAY
62741: NOT
62742: PUSH
62743: NOP4
62747: PUSH
62748: NOP4
62752: ARRAY
62753: AND
62754: IFFALSE 62792
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62756: NOP4
62760: PUSH
62761: NOP4
62765: PPUSH
62766: NOP4
62770: PPUSH
62771: EMPTY
62772: PPUSH
62773: NOP4
62777: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
62778: NOP4
62782: PPUSH
62783: LD_INT 107
62785: PPUSH
62786: NOP4
// continue ;
62790: GO 62701
// end ; target := [ ] ;
62792: NOP4
62796: PUSH
62797: EMPTY
62798: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
62799: NOP4
62803: PUSH
62804: NOP4
62808: PUSH
62809: NOP4
62813: ARRAY
62814: PUSH
62815: LD_INT 1
62817: ARRAY
62818: PPUSH
62819: NOP4
62823: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62824: NOP4
62828: PUSH
62829: NOP4
62833: PUSH
62834: NOP4
62838: ARRAY
62839: PPUSH
62840: LD_INT 2
62842: PUSH
62843: LD_INT 30
62845: PUSH
62846: LD_INT 0
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: LD_INT 30
62855: PUSH
62856: LD_INT 1
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PUSH
62863: EMPTY
62864: LIST
62865: LIST
62866: LIST
62867: PPUSH
62868: NOP4
62872: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
62873: NOP4
62877: PUSH
62878: DOUBLE
62879: NOP4
62883: PUSH
62884: NOP4
62888: ARRAY
62889: INC
62890: ST_TO_ADDR
62891: LD_INT 1
62893: PUSH
62894: FOR_DOWNTO
62895: IFFALSE 63140
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
62897: NOP4
62901: PUSH
62902: NOP4
62906: ARRAY
62907: PUSH
62908: NOP4
62912: ARRAY
62913: PUSH
62914: LD_INT 2
62916: ARRAY
62917: PPUSH
62918: NOP4
62922: PUSH
62923: NOP4
62927: ARRAY
62928: PUSH
62929: NOP4
62933: ARRAY
62934: PUSH
62935: LD_INT 3
62937: ARRAY
62938: PPUSH
62939: NOP4
62943: PUSH
62944: NOP4
62948: PUSH
62949: NOP4
62953: ARRAY
62954: PUSH
62955: NOP4
62959: ARRAY
62960: PUSH
62961: LD_INT 2
62963: ARRAY
62964: PPUSH
62965: NOP4
62969: PUSH
62970: NOP4
62974: ARRAY
62975: PUSH
62976: NOP4
62980: ARRAY
62981: PUSH
62982: LD_INT 3
62984: ARRAY
62985: PPUSH
62986: NOP4
62990: PUSH
62991: LD_INT 0
62993: EQUAL
62994: AND
62995: IFFALSE 63050
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
62997: NOP4
63001: PUSH
63002: NOP4
63006: PUSH
63007: NOP4
63011: ARRAY
63012: PPUSH
63013: NOP4
63017: PPUSH
63018: NOP4
63022: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63023: NOP4
63027: PUSH
63028: NOP4
63032: PPUSH
63033: NOP4
63037: PPUSH
63038: NOP4
63042: PPUSH
63043: NOP4
63047: ST_TO_ADDR
// continue ;
63048: GO 62894
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63050: NOP4
63054: PPUSH
63055: NOP4
63059: PUSH
63060: NOP4
63064: ARRAY
63065: PUSH
63066: NOP4
63070: ARRAY
63071: PUSH
63072: LD_INT 2
63074: ARRAY
63075: PPUSH
63076: NOP4
63080: PUSH
63081: NOP4
63085: ARRAY
63086: PUSH
63087: NOP4
63091: ARRAY
63092: PUSH
63093: LD_INT 3
63095: ARRAY
63096: PPUSH
63097: LD_INT 30
63099: PPUSH
63100: NOP4
63104: PUSH
63105: LD_INT 4
63107: ARRAY
63108: PUSH
63109: LD_INT 0
63111: EQUAL
63112: IFFALSE 63138
// begin target := mc_crates [ i ] [ j ] ;
63114: NOP4
63118: PUSH
63119: NOP4
63123: PUSH
63124: NOP4
63128: ARRAY
63129: PUSH
63130: NOP4
63134: ARRAY
63135: ST_TO_ADDR
// break ;
63136: GO 63140
// end ; end ;
63138: GO 62894
63140: POP
63141: POP
// if not target then
63142: NOP4
63146: NOT
63147: IFFALSE 63151
// continue ;
63149: GO 62701
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63151: NOP4
63155: PUSH
63156: NOP4
63160: PUSH
63161: NOP4
63165: ARRAY
63166: PPUSH
63167: LD_INT 2
63169: PUSH
63170: LD_INT 3
63172: PUSH
63173: LD_INT 58
63175: PUSH
63176: EMPTY
63177: LIST
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 61
63185: PUSH
63186: EMPTY
63187: LIST
63188: PUSH
63189: LD_INT 33
63191: PUSH
63192: LD_INT 5
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 33
63201: PUSH
63202: LD_INT 3
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: PUSH
63216: LD_INT 2
63218: PUSH
63219: LD_INT 34
63221: PUSH
63222: LD_INT 32
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PUSH
63229: LD_INT 34
63231: PUSH
63232: LD_INT 51
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 34
63241: PUSH
63242: LD_INT 12
63244: PUSH
63245: EMPTY
63246: LIST
63247: LIST
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: PPUSH
63259: NOP4
63263: ST_TO_ADDR
// if not cargo then
63264: NOP4
63268: NOT
63269: IFFALSE 63975
// begin if mc_crates_collector [ i ] < 5 then
63271: NOP4
63275: PUSH
63276: NOP4
63280: ARRAY
63281: PUSH
63282: LD_INT 5
63284: LESS
63285: IFFALSE 63651
// begin if mc_ape [ i ] then
63287: NOP4
63291: PUSH
63292: NOP4
63296: ARRAY
63297: IFFALSE 63344
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63299: NOP4
63303: PUSH
63304: NOP4
63308: PUSH
63309: NOP4
63313: ARRAY
63314: PPUSH
63315: LD_INT 25
63317: PUSH
63318: LD_INT 16
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 24
63327: PUSH
63328: LD_INT 750
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PPUSH
63339: NOP4
63343: ST_TO_ADDR
// if not tmp then
63344: NOP4
63348: NOT
63349: IFFALSE 63396
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63351: NOP4
63355: PUSH
63356: NOP4
63360: PUSH
63361: NOP4
63365: ARRAY
63366: PPUSH
63367: LD_INT 25
63369: PUSH
63370: LD_INT 2
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 24
63379: PUSH
63380: LD_INT 750
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PPUSH
63391: NOP4
63395: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63396: NOP4
63400: PUSH
63401: NOP4
63405: ARRAY
63406: PUSH
63407: NOP4
63411: PUSH
63412: NOP4
63416: ARRAY
63417: PPUSH
63418: LD_INT 25
63420: PUSH
63421: LD_INT 2
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: PUSH
63428: LD_INT 24
63430: PUSH
63431: LD_INT 750
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: PUSH
63438: EMPTY
63439: LIST
63440: LIST
63441: PPUSH
63442: NOP4
63446: AND
63447: PUSH
63448: NOP4
63452: PUSH
63453: LD_INT 5
63455: LESS
63456: AND
63457: IFFALSE 63539
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
63459: NOP4
63463: PUSH
63464: NOP4
63468: PUSH
63469: NOP4
63473: ARRAY
63474: PPUSH
63475: LD_INT 25
63477: PUSH
63478: LD_INT 2
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 24
63487: PUSH
63488: LD_INT 750
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PPUSH
63499: NOP4
63503: PUSH
63504: FOR_IN
63505: IFFALSE 63537
// begin tmp := tmp union j ;
63507: NOP4
63511: PUSH
63512: NOP4
63516: PUSH
63517: NOP4
63521: UNION
63522: ST_TO_ADDR
// if tmp >= 5 then
63523: NOP4
63527: PUSH
63528: LD_INT 5
63530: GREATEREQUAL
63531: IFFALSE 63535
// break ;
63533: GO 63537
// end ;
63535: GO 63504
63537: POP
63538: POP
// end ; if not tmp then
63539: NOP4
63543: NOT
63544: IFFALSE 63548
// continue ;
63546: GO 62701
// for j in tmp do
63548: NOP4
63552: PUSH
63553: NOP4
63557: PUSH
63558: FOR_IN
63559: IFFALSE 63649
// if not GetTag ( j ) then
63561: NOP4
63565: PPUSH
63566: NOP4
63570: NOT
63571: IFFALSE 63647
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
63573: NOP4
63577: PUSH
63578: NOP4
63582: PPUSH
63583: NOP4
63587: PUSH
63588: NOP4
63592: PUSH
63593: NOP4
63597: ARRAY
63598: PUSH
63599: LD_INT 1
63601: PLUS
63602: PUSH
63603: EMPTY
63604: LIST
63605: LIST
63606: PPUSH
63607: NOP4
63611: PPUSH
63612: NOP4
63616: ST_TO_ADDR
// SetTag ( j , 107 ) ;
63617: NOP4
63621: PPUSH
63622: LD_INT 107
63624: PPUSH
63625: NOP4
// if mc_crates_collector [ i ] >= 5 then
63629: NOP4
63633: PUSH
63634: NOP4
63638: ARRAY
63639: PUSH
63640: LD_INT 5
63642: GREATEREQUAL
63643: IFFALSE 63647
// break ;
63645: GO 63649
// end ;
63647: GO 63558
63649: POP
63650: POP
// end ; if mc_crates_collector [ i ] and target then
63651: NOP4
63655: PUSH
63656: NOP4
63660: ARRAY
63661: PUSH
63662: NOP4
63666: AND
63667: IFFALSE 63973
// begin if mc_crates_collector [ i ] < target [ 1 ] then
63669: NOP4
63673: PUSH
63674: NOP4
63678: ARRAY
63679: PUSH
63680: NOP4
63684: PUSH
63685: LD_INT 1
63687: ARRAY
63688: LESS
63689: IFFALSE 63709
// tmp := mc_crates_collector [ i ] else
63691: NOP4
63695: PUSH
63696: NOP4
63700: PUSH
63701: NOP4
63705: ARRAY
63706: ST_TO_ADDR
63707: GO 63723
// tmp := target [ 1 ] ;
63709: NOP4
63713: PUSH
63714: NOP4
63718: PUSH
63719: LD_INT 1
63721: ARRAY
63722: ST_TO_ADDR
// k := 0 ;
63723: NOP4
63727: PUSH
63728: LD_INT 0
63730: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
63731: NOP4
63735: PUSH
63736: NOP4
63740: PUSH
63741: NOP4
63745: ARRAY
63746: PUSH
63747: FOR_IN
63748: IFFALSE 63971
// begin k := k + 1 ;
63750: NOP4
63754: PUSH
63755: NOP4
63759: PUSH
63760: LD_INT 1
63762: PLUS
63763: ST_TO_ADDR
// if k > tmp then
63764: NOP4
63768: PUSH
63769: NOP4
63773: GREATER
63774: IFFALSE 63778
// break ;
63776: GO 63971
// if not GetClass ( j ) in [ 2 , 16 ] then
63778: NOP4
63782: PPUSH
63783: NOP4
63787: PUSH
63788: LD_INT 2
63790: PUSH
63791: LD_INT 16
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: IN
63798: NOT
63799: IFFALSE 63852
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
63801: NOP4
63805: PUSH
63806: NOP4
63810: PPUSH
63811: NOP4
63815: PPUSH
63816: NOP4
63820: PUSH
63821: NOP4
63825: ARRAY
63826: PUSH
63827: NOP4
63831: DIFF
63832: PPUSH
63833: NOP4
63837: ST_TO_ADDR
// SetTag ( j , 0 ) ;
63838: NOP4
63842: PPUSH
63843: LD_INT 0
63845: PPUSH
63846: NOP4
// continue ;
63850: GO 63747
// end ; if IsInUnit ( j ) then
63852: NOP4
63856: PPUSH
63857: NOP4
63861: IFFALSE 63872
// ComExitBuilding ( j ) ;
63863: NOP4
63867: PPUSH
63868: NOP4
// wait ( 3 ) ;
63872: LD_INT 3
63874: PPUSH
63875: NOP4
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
63879: NOP4
63883: PPUSH
63884: NOP4
63888: PUSH
63889: NOP4
63893: PPUSH
63894: NOP4
63898: PUSH
63899: LD_INT 2
63901: ARRAY
63902: PPUSH
63903: NOP4
63907: PUSH
63908: LD_INT 3
63910: ARRAY
63911: PPUSH
63912: LD_INT 30
63914: PPUSH
63915: NOP4
63919: PUSH
63920: LD_INT 4
63922: ARRAY
63923: AND
63924: IFFALSE 63942
// ComStandNearbyBuilding ( j , depot ) else
63926: NOP4
63930: PPUSH
63931: NOP4
63935: PPUSH
63936: NOP4
63940: GO 63969
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
63942: NOP4
63946: PPUSH
63947: NOP4
63951: PUSH
63952: LD_INT 2
63954: ARRAY
63955: PPUSH
63956: NOP4
63960: PUSH
63961: LD_INT 3
63963: ARRAY
63964: PPUSH
63965: NOP4
// end ;
63969: GO 63747
63971: POP
63972: POP
// end ; end else
63973: GO 64505
// begin for j in cargo do
63975: NOP4
63979: PUSH
63980: NOP4
63984: PUSH
63985: FOR_IN
63986: IFFALSE 64503
// begin if GetTag ( j ) <> 0 then
63988: NOP4
63992: PPUSH
63993: NOP4
63997: PUSH
63998: LD_INT 0
64000: NONEQUAL
64001: IFFALSE 64005
// continue ;
64003: GO 63985
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64005: NOP4
64009: PPUSH
64010: NOP4
64014: PUSH
64015: LD_INT 1000
64017: LESS
64018: PUSH
64019: NOP4
64023: PPUSH
64024: NOP4
64028: PUSH
64029: NOP4
64033: ARRAY
64034: PPUSH
64035: NOP4
64039: NOT
64040: AND
64041: IFFALSE 64063
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64043: NOP4
64047: PPUSH
64048: NOP4
64052: PUSH
64053: NOP4
64057: ARRAY
64058: PPUSH
64059: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64063: NOP4
64067: PPUSH
64068: NOP4
64072: PUSH
64073: LD_INT 1000
64075: LESS
64076: PUSH
64077: NOP4
64081: PPUSH
64082: NOP4
64086: PUSH
64087: NOP4
64091: ARRAY
64092: PPUSH
64093: NOP4
64097: AND
64098: IFFALSE 64102
// continue ;
64100: GO 63985
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64102: NOP4
64106: PPUSH
64107: NOP4
64111: PUSH
64112: LD_INT 2
64114: EQUAL
64115: PUSH
64116: NOP4
64120: PPUSH
64121: NOP4
64125: PUSH
64126: LD_INT 15
64128: LESS
64129: AND
64130: IFFALSE 64134
// continue ;
64132: GO 63985
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64134: NOP4
64138: PPUSH
64139: NOP4
64143: PUSH
64144: LD_INT 1
64146: EQUAL
64147: PUSH
64148: NOP4
64152: PPUSH
64153: NOP4
64157: PUSH
64158: LD_INT 10
64160: LESS
64161: AND
64162: IFFALSE 64442
// begin if not depot then
64164: NOP4
64168: NOT
64169: IFFALSE 64173
// continue ;
64171: GO 63985
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64173: NOP4
64177: PPUSH
64178: NOP4
64182: PPUSH
64183: NOP4
64187: PPUSH
64188: NOP4
64192: PPUSH
64193: NOP4
64197: PUSH
64198: LD_INT 6
64200: LESS
64201: IFFALSE 64217
// SetFuel ( j , 100 ) else
64203: NOP4
64207: PPUSH
64208: LD_INT 100
64210: PPUSH
64211: NOP4
64215: GO 64442
// if GetFuel ( j ) = 0 then
64217: NOP4
64221: PPUSH
64222: NOP4
64226: PUSH
64227: LD_INT 0
64229: EQUAL
64230: IFFALSE 64442
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64232: NOP4
64236: PUSH
64237: NOP4
64241: PPUSH
64242: NOP4
64246: PPUSH
64247: NOP4
64251: PUSH
64252: NOP4
64256: ARRAY
64257: PUSH
64258: NOP4
64262: DIFF
64263: PPUSH
64264: NOP4
64268: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64269: NOP4
64273: PPUSH
64274: NOP4
64278: PUSH
64279: LD_INT 1
64281: EQUAL
64282: IFFALSE 64298
// ComExitVehicle ( IsInUnit ( j ) ) ;
64284: NOP4
64288: PPUSH
64289: NOP4
64293: PPUSH
64294: NOP4
// if GetControl ( j ) = control_remote then
64298: NOP4
64302: PPUSH
64303: NOP4
64307: PUSH
64308: LD_INT 2
64310: EQUAL
64311: IFFALSE 64322
// ComUnlink ( j ) ;
64313: NOP4
64317: PPUSH
64318: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
64322: NOP4
64326: PUSH
64327: NOP4
64331: PPUSH
64332: LD_INT 3
64334: PPUSH
64335: NOP4
64339: ST_TO_ADDR
// if fac then
64340: NOP4
64344: IFFALSE 64440
// begin for k in fac do
64346: NOP4
64350: PUSH
64351: NOP4
64355: PUSH
64356: FOR_IN
64357: IFFALSE 64438
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64359: NOP4
64363: PUSH
64364: NOP4
64368: PPUSH
64369: NOP4
64373: PPUSH
64374: NOP4
64378: PPUSH
64379: NOP4
64383: PPUSH
64384: NOP4
64388: PPUSH
64389: NOP4
64393: PPUSH
64394: NOP4
64398: PPUSH
64399: NOP4
64403: PPUSH
64404: NOP4
64408: PPUSH
64409: NOP4
64413: ST_TO_ADDR
// if components then
64414: NOP4
64418: IFFALSE 64436
// begin MC_InsertProduceList ( i , components ) ;
64420: NOP4
64424: PPUSH
64425: NOP4
64429: PPUSH
64430: NOP4
// break ;
64434: GO 64438
// end ; end ;
64436: GO 64356
64438: POP
64439: POP
// end ; continue ;
64440: GO 63985
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
64442: NOP4
64446: PPUSH
64447: LD_INT 1
64449: PPUSH
64450: NOP4
64454: PUSH
64455: LD_INT 100
64457: LESS
64458: PUSH
64459: NOP4
64463: PPUSH
64464: NOP4
64468: NOT
64469: AND
64470: IFFALSE 64499
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64472: NOP4
64476: PPUSH
64477: NOP4
64481: PUSH
64482: LD_INT 2
64484: ARRAY
64485: PPUSH
64486: NOP4
64490: PUSH
64491: LD_INT 3
64493: ARRAY
64494: PPUSH
64495: NOP4
// break ;
64499: GO 64503
// end ;
64501: GO 63985
64503: POP
64504: POP
// end ; end ;
64505: GO 62701
64507: POP
64508: POP
// end ;
64509: LD_VAR 0 1
64513: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
64514: LD_INT 0
64516: PPUSH
64517: PPUSH
64518: PPUSH
64519: PPUSH
// if not mc_bases then
64520: NOP4
64524: NOT
64525: IFFALSE 64529
// exit ;
64527: GO 64690
// for i = 1 to mc_bases do
64529: NOP4
64533: PUSH
64534: DOUBLE
64535: LD_INT 1
64537: DEC
64538: ST_TO_ADDR
64539: NOP4
64543: PUSH
64544: FOR_TO
64545: IFFALSE 64688
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
64547: NOP4
64551: PUSH
64552: NOP4
64556: PUSH
64557: NOP4
64561: ARRAY
64562: PUSH
64563: NOP4
64567: PUSH
64568: NOP4
64572: ARRAY
64573: UNION
64574: PPUSH
64575: LD_INT 33
64577: PUSH
64578: LD_INT 2
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PPUSH
64585: NOP4
64589: ST_TO_ADDR
// if tmp then
64590: NOP4
64594: IFFALSE 64686
// for j in tmp do
64596: NOP4
64600: PUSH
64601: NOP4
64605: PUSH
64606: FOR_IN
64607: IFFALSE 64684
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
64609: NOP4
64613: PPUSH
64614: NOP4
64618: NOT
64619: PUSH
64620: NOP4
64624: PPUSH
64625: NOP4
64629: PUSH
64630: LD_INT 250
64632: GREATEREQUAL
64633: AND
64634: IFFALSE 64647
// Connect ( j ) else
64636: NOP4
64640: PPUSH
64641: NOP4
64645: GO 64682
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
64647: NOP4
64651: PPUSH
64652: NOP4
64656: PUSH
64657: LD_INT 250
64659: LESS
64660: PUSH
64661: NOP4
64665: PPUSH
64666: NOP4
64670: AND
64671: IFFALSE 64682
// ComUnlink ( j ) ;
64673: NOP4
64677: PPUSH
64678: NOP4
64682: GO 64606
64684: POP
64685: POP
// end ;
64686: GO 64544
64688: POP
64689: POP
// end ;
64690: LD_VAR 0 1
64694: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
64695: LD_INT 0
64697: PPUSH
64698: PPUSH
64699: PPUSH
64700: PPUSH
64701: PPUSH
// if not mc_bases then
64702: NOP4
64706: NOT
64707: IFFALSE 64711
// exit ;
64709: GO 65156
// for i = 1 to mc_bases do
64711: NOP4
64715: PUSH
64716: DOUBLE
64717: LD_INT 1
64719: DEC
64720: ST_TO_ADDR
64721: NOP4
64725: PUSH
64726: FOR_TO
64727: IFFALSE 65154
// begin if not mc_produce [ i ] then
64729: NOP4
64733: PUSH
64734: NOP4
64738: ARRAY
64739: NOT
64740: IFFALSE 64744
// continue ;
64742: GO 64726
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64744: NOP4
64748: PUSH
64749: NOP4
64753: PUSH
64754: NOP4
64758: ARRAY
64759: PPUSH
64760: LD_INT 30
64762: PUSH
64763: LD_INT 3
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PPUSH
64770: NOP4
64774: ST_TO_ADDR
// if not fac then
64775: NOP4
64779: NOT
64780: IFFALSE 64784
// continue ;
64782: GO 64726
// for j in fac do
64784: NOP4
64788: PUSH
64789: NOP4
64793: PUSH
64794: FOR_IN
64795: IFFALSE 65150
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
64797: NOP4
64801: PPUSH
64802: NOP4
64806: PUSH
64807: LD_INT 2
64809: NONEQUAL
64810: PUSH
64811: NOP4
64815: PPUSH
64816: LD_INT 15
64818: PPUSH
64819: NOP4
64823: PUSH
64824: LD_INT 4
64826: ARRAY
64827: OR
64828: IFFALSE 64832
// continue ;
64830: GO 64794
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
64832: NOP4
64836: PPUSH
64837: NOP4
64841: PUSH
64842: NOP4
64846: ARRAY
64847: PUSH
64848: LD_INT 1
64850: ARRAY
64851: PUSH
64852: LD_INT 1
64854: ARRAY
64855: PPUSH
64856: NOP4
64860: PUSH
64861: NOP4
64865: ARRAY
64866: PUSH
64867: LD_INT 1
64869: ARRAY
64870: PUSH
64871: LD_INT 2
64873: ARRAY
64874: PPUSH
64875: NOP4
64879: PUSH
64880: NOP4
64884: ARRAY
64885: PUSH
64886: LD_INT 1
64888: ARRAY
64889: PUSH
64890: LD_INT 3
64892: ARRAY
64893: PPUSH
64894: NOP4
64898: PUSH
64899: NOP4
64903: ARRAY
64904: PUSH
64905: LD_INT 1
64907: ARRAY
64908: PUSH
64909: LD_INT 4
64911: ARRAY
64912: PPUSH
64913: NOP4
64917: PUSH
64918: NOP4
64922: PPUSH
64923: NOP4
64927: PUSH
64928: NOP4
64932: ARRAY
64933: PUSH
64934: LD_INT 1
64936: ARRAY
64937: PUSH
64938: LD_INT 1
64940: ARRAY
64941: PUSH
64942: NOP4
64946: PUSH
64947: NOP4
64951: ARRAY
64952: PUSH
64953: LD_INT 1
64955: ARRAY
64956: PUSH
64957: LD_INT 2
64959: ARRAY
64960: PUSH
64961: NOP4
64965: PUSH
64966: NOP4
64970: ARRAY
64971: PUSH
64972: LD_INT 1
64974: ARRAY
64975: PUSH
64976: LD_INT 3
64978: ARRAY
64979: PUSH
64980: NOP4
64984: PUSH
64985: NOP4
64989: ARRAY
64990: PUSH
64991: LD_INT 1
64993: ARRAY
64994: PUSH
64995: LD_INT 4
64997: ARRAY
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: PPUSH
65005: NOP4
65009: AND
65010: IFFALSE 65148
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65012: NOP4
65016: PPUSH
65017: NOP4
65021: PUSH
65022: NOP4
65026: ARRAY
65027: PUSH
65028: LD_INT 1
65030: ARRAY
65031: PUSH
65032: LD_INT 1
65034: ARRAY
65035: PPUSH
65036: NOP4
65040: PUSH
65041: NOP4
65045: ARRAY
65046: PUSH
65047: LD_INT 1
65049: ARRAY
65050: PUSH
65051: LD_INT 2
65053: ARRAY
65054: PPUSH
65055: NOP4
65059: PUSH
65060: NOP4
65064: ARRAY
65065: PUSH
65066: LD_INT 1
65068: ARRAY
65069: PUSH
65070: LD_INT 3
65072: ARRAY
65073: PPUSH
65074: NOP4
65078: PUSH
65079: NOP4
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: ARRAY
65088: PUSH
65089: LD_INT 4
65091: ARRAY
65092: PPUSH
65093: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65097: NOP4
65101: PUSH
65102: NOP4
65106: PUSH
65107: NOP4
65111: ARRAY
65112: PPUSH
65113: LD_INT 1
65115: PPUSH
65116: NOP4
65120: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65121: NOP4
65125: PUSH
65126: NOP4
65130: PPUSH
65131: NOP4
65135: PPUSH
65136: NOP4
65140: PPUSH
65141: NOP4
65145: ST_TO_ADDR
// break ;
65146: GO 65150
// end ; end ;
65148: GO 64794
65150: POP
65151: POP
// end ;
65152: GO 64726
65154: POP
65155: POP
// end ;
65156: LD_VAR 0 1
65160: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65161: LD_INT 0
65163: PPUSH
65164: PPUSH
65165: PPUSH
// if not mc_bases then
65166: NOP4
65170: NOT
65171: IFFALSE 65175
// exit ;
65173: GO 65264
// for i = 1 to mc_bases do
65175: NOP4
65179: PUSH
65180: DOUBLE
65181: LD_INT 1
65183: DEC
65184: ST_TO_ADDR
65185: NOP4
65189: PUSH
65190: FOR_TO
65191: IFFALSE 65262
// begin if mc_attack [ i ] then
65193: NOP4
65197: PUSH
65198: NOP4
65202: ARRAY
65203: IFFALSE 65260
// begin tmp := mc_attack [ i ] [ 1 ] ;
65205: NOP4
65209: PUSH
65210: NOP4
65214: PUSH
65215: NOP4
65219: ARRAY
65220: PUSH
65221: LD_INT 1
65223: ARRAY
65224: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65225: NOP4
65229: PUSH
65230: NOP4
65234: PPUSH
65235: NOP4
65239: PPUSH
65240: EMPTY
65241: PPUSH
65242: NOP4
65246: ST_TO_ADDR
// Attack ( tmp ) ;
65247: NOP4
65251: PPUSH
65252: NOP4
// exit ;
65256: POP
65257: POP
65258: GO 65264
// end ; end ;
65260: GO 65190
65262: POP
65263: POP
// end ;
65264: LD_VAR 0 1
65268: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65269: LD_INT 0
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
// if not mc_bases then
65278: NOP4
65282: NOT
65283: IFFALSE 65287
// exit ;
65285: GO 66144
// for i = 1 to mc_bases do
65287: NOP4
65291: PUSH
65292: DOUBLE
65293: LD_INT 1
65295: DEC
65296: ST_TO_ADDR
65297: NOP4
65301: PUSH
65302: FOR_TO
65303: IFFALSE 66142
// begin if not mc_bases [ i ] then
65305: NOP4
65309: PUSH
65310: NOP4
65314: ARRAY
65315: NOT
65316: IFFALSE 65320
// continue ;
65318: GO 65302
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65320: NOP4
65324: PUSH
65325: NOP4
65329: PUSH
65330: NOP4
65334: ARRAY
65335: PUSH
65336: LD_INT 1
65338: ARRAY
65339: PPUSH
65340: NOP4
65344: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65345: NOP4
65349: PUSH
65350: NOP4
65354: PPUSH
65355: NOP4
65359: PPUSH
65360: NOP4
65364: PUSH
65365: NOP4
65369: ARRAY
65370: PUSH
65371: LD_INT 1
65373: ARRAY
65374: PPUSH
65375: NOP4
65379: PPUSH
65380: NOP4
65384: PUSH
65385: NOP4
65389: ARRAY
65390: PPUSH
65391: NOP4
65395: PPUSH
65396: NOP4
65400: ST_TO_ADDR
// if not mc_scan [ i ] then
65401: NOP4
65405: PUSH
65406: NOP4
65410: ARRAY
65411: NOT
65412: IFFALSE 65590
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65414: NOP4
65418: PUSH
65419: NOP4
65423: PPUSH
65424: NOP4
65428: PPUSH
65429: LD_INT 0
65431: PPUSH
65432: NOP4
65436: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65437: NOP4
65441: PUSH
65442: NOP4
65446: PUSH
65447: NOP4
65451: ARRAY
65452: PPUSH
65453: LD_INT 2
65455: PUSH
65456: LD_INT 25
65458: PUSH
65459: LD_INT 5
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: PUSH
65466: LD_INT 25
65468: PUSH
65469: LD_INT 8
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: PUSH
65476: LD_INT 25
65478: PUSH
65479: LD_INT 9
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: NOP4
65496: ST_TO_ADDR
// if not tmp then
65497: NOP4
65501: NOT
65502: IFFALSE 65506
// continue ;
65504: GO 65302
// for j in tmp do
65506: NOP4
65510: PUSH
65511: NOP4
65515: PUSH
65516: FOR_IN
65517: IFFALSE 65588
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
65519: NOP4
65523: PPUSH
65524: NOP4
65528: PPUSH
65529: NOP4
65533: PUSH
65534: LD_INT 5
65536: EQUAL
65537: PUSH
65538: NOP4
65542: PPUSH
65543: NOP4
65547: PUSH
65548: LD_INT 1
65550: EQUAL
65551: AND
65552: PUSH
65553: NOP4
65557: PPUSH
65558: NOP4
65562: NOT
65563: AND
65564: PUSH
65565: NOP4
65569: AND
65570: IFFALSE 65586
// ComChangeProfession ( j , class ) ;
65572: NOP4
65576: PPUSH
65577: NOP4
65581: PPUSH
65582: NOP4
65586: GO 65516
65588: POP
65589: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
65590: NOP4
65594: PUSH
65595: NOP4
65599: ARRAY
65600: PUSH
65601: NOP4
65605: PUSH
65606: NOP4
65610: ARRAY
65611: NOT
65612: AND
65613: PUSH
65614: NOP4
65618: PUSH
65619: NOP4
65623: ARRAY
65624: NOT
65625: AND
65626: PUSH
65627: NOP4
65631: PUSH
65632: NOP4
65636: ARRAY
65637: PPUSH
65638: LD_INT 50
65640: PUSH
65641: EMPTY
65642: LIST
65643: PUSH
65644: LD_INT 2
65646: PUSH
65647: LD_INT 30
65649: PUSH
65650: LD_INT 32
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 30
65659: PUSH
65660: LD_INT 33
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 30
65669: PUSH
65670: LD_INT 4
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: PUSH
65677: LD_INT 30
65679: PUSH
65680: LD_INT 5
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: PPUSH
65698: NOP4
65702: PUSH
65703: LD_INT 4
65705: LESS
65706: PUSH
65707: NOP4
65711: PUSH
65712: NOP4
65716: ARRAY
65717: PPUSH
65718: LD_INT 3
65720: PUSH
65721: LD_INT 24
65723: PUSH
65724: LD_INT 1000
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 2
65737: PUSH
65738: LD_INT 30
65740: PUSH
65741: LD_INT 0
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 30
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: LIST
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PPUSH
65767: NOP4
65771: OR
65772: AND
65773: IFFALSE 66024
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
65775: NOP4
65779: PUSH
65780: NOP4
65784: PPUSH
65785: NOP4
65789: PPUSH
65790: LD_INT 1
65792: PPUSH
65793: NOP4
65797: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65798: NOP4
65802: PUSH
65803: NOP4
65807: PUSH
65808: NOP4
65812: ARRAY
65813: PPUSH
65814: LD_INT 2
65816: PUSH
65817: LD_INT 25
65819: PUSH
65820: LD_INT 1
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 25
65829: PUSH
65830: LD_INT 5
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 25
65839: PUSH
65840: LD_INT 8
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 25
65849: PUSH
65850: LD_INT 9
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: PPUSH
65864: NOP4
65868: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
65869: NOP4
65873: PUSH
65874: NOP4
65878: PUSH
65879: NOP4
65883: PPUSH
65884: LD_INT 18
65886: PPUSH
65887: NOP4
65891: DIFF
65892: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
65893: NOP4
65897: NOT
65898: PUSH
65899: NOP4
65903: PUSH
65904: NOP4
65908: ARRAY
65909: PPUSH
65910: LD_INT 2
65912: PUSH
65913: LD_INT 30
65915: PUSH
65916: LD_INT 4
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 30
65925: PUSH
65926: LD_INT 5
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: LIST
65937: PPUSH
65938: NOP4
65942: NOT
65943: AND
65944: IFFALSE 66006
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
65946: NOP4
65950: PUSH
65951: NOP4
65955: PUSH
65956: NOP4
65960: ARRAY
65961: PPUSH
65962: LD_INT 2
65964: PUSH
65965: LD_INT 25
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 25
65977: PUSH
65978: LD_INT 3
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 25
65987: PUSH
65988: LD_INT 4
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: PPUSH
66001: NOP4
66005: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
66006: NOP4
66010: PPUSH
66011: NOP4
66015: PPUSH
66016: NOP4
// exit ;
66020: POP
66021: POP
66022: GO 66144
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
66024: NOP4
66028: PUSH
66029: NOP4
66033: ARRAY
66034: PUSH
66035: NOP4
66039: PUSH
66040: NOP4
66044: ARRAY
66045: NOT
66046: AND
66047: PUSH
66048: NOP4
66052: PUSH
66053: NOP4
66057: ARRAY
66058: AND
66059: IFFALSE 66140
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66061: NOP4
66065: PUSH
66066: NOP4
66070: PPUSH
66071: NOP4
66075: PPUSH
66076: LD_INT 1
66078: PPUSH
66079: NOP4
66083: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
66084: NOP4
66088: PUSH
66089: NOP4
66093: PUSH
66094: NOP4
66098: ARRAY
66099: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66100: NOP4
66104: PUSH
66105: NOP4
66109: PPUSH
66110: NOP4
66114: PPUSH
66115: EMPTY
66116: PPUSH
66117: NOP4
66121: ST_TO_ADDR
// Defend ( i , tmp ) ;
66122: NOP4
66126: PPUSH
66127: NOP4
66131: PPUSH
66132: NOP4
// exit ;
66136: POP
66137: POP
66138: GO 66144
// end ; end ;
66140: GO 65302
66142: POP
66143: POP
// end ;
66144: LD_VAR 0 1
66148: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66149: LD_INT 0
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
// if not mc_bases then
66162: NOP4
66166: NOT
66167: IFFALSE 66171
// exit ;
66169: GO 67258
// for i = 1 to mc_bases do
66171: NOP4
66175: PUSH
66176: DOUBLE
66177: LD_INT 1
66179: DEC
66180: ST_TO_ADDR
66181: NOP4
66185: PUSH
66186: FOR_TO
66187: IFFALSE 67256
// begin tmp := mc_lab [ i ] ;
66189: NOP4
66193: PUSH
66194: NOP4
66198: PUSH
66199: NOP4
66203: ARRAY
66204: ST_TO_ADDR
// if not tmp then
66205: NOP4
66209: NOT
66210: IFFALSE 66214
// continue ;
66212: GO 66186
// idle_lab := 0 ;
66214: NOP4
66218: PUSH
66219: LD_INT 0
66221: ST_TO_ADDR
// for j in tmp do
66222: NOP4
66226: PUSH
66227: NOP4
66231: PUSH
66232: FOR_IN
66233: IFFALSE 67252
// begin researching := false ;
66235: NOP4
66239: PUSH
66240: LD_INT 0
66242: ST_TO_ADDR
// side := GetSide ( j ) ;
66243: NOP4
66247: PUSH
66248: NOP4
66252: PPUSH
66253: NOP4
66257: ST_TO_ADDR
// if not mc_tech [ side ] then
66258: NOP4
66262: PUSH
66263: NOP4
66267: ARRAY
66268: NOT
66269: IFFALSE 66273
// continue ;
66271: GO 66232
// if BuildingStatus ( j ) = bs_idle then
66273: NOP4
66277: PPUSH
66278: NOP4
66282: PUSH
66283: LD_INT 2
66285: EQUAL
66286: IFFALSE 66474
// begin if idle_lab and UnitsInside ( j ) < 6 then
66288: NOP4
66292: PUSH
66293: NOP4
66297: PPUSH
66298: NOP4
66302: PUSH
66303: LD_INT 6
66305: LESS
66306: AND
66307: IFFALSE 66378
// begin tmp2 := UnitsInside ( idle_lab ) ;
66309: NOP4
66313: PUSH
66314: NOP4
66318: PPUSH
66319: NOP4
66323: ST_TO_ADDR
// if tmp2 then
66324: NOP4
66328: IFFALSE 66370
// for x in tmp2 do
66330: NOP4
66334: PUSH
66335: NOP4
66339: PUSH
66340: FOR_IN
66341: IFFALSE 66368
// begin ComExitBuilding ( x ) ;
66343: NOP4
66347: PPUSH
66348: NOP4
// AddComEnterUnit ( x , j ) ;
66352: NOP4
66356: PPUSH
66357: NOP4
66361: PPUSH
66362: NOP4
// end ;
66366: GO 66340
66368: POP
66369: POP
// idle_lab := 0 ;
66370: NOP4
66374: PUSH
66375: LD_INT 0
66377: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66378: NOP4
66382: PUSH
66383: NOP4
66387: PUSH
66388: NOP4
66392: ARRAY
66393: PUSH
66394: FOR_IN
66395: IFFALSE 66455
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66397: NOP4
66401: PPUSH
66402: NOP4
66406: PPUSH
66407: NOP4
66411: PUSH
66412: NOP4
66416: PPUSH
66417: NOP4
66421: PPUSH
66422: NOP4
66426: AND
66427: IFFALSE 66453
// begin researching := true ;
66429: NOP4
66433: PUSH
66434: LD_INT 1
66436: ST_TO_ADDR
// ComResearch ( j , t ) ;
66437: NOP4
66441: PPUSH
66442: NOP4
66446: PPUSH
66447: NOP4
// break ;
66451: GO 66455
// end ;
66453: GO 66394
66455: POP
66456: POP
// if not researching then
66457: NOP4
66461: NOT
66462: IFFALSE 66474
// idle_lab := j ;
66464: NOP4
66468: PUSH
66469: NOP4
66473: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
66474: NOP4
66478: PPUSH
66479: NOP4
66483: PUSH
66484: LD_INT 10
66486: EQUAL
66487: IFFALSE 67075
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
66489: NOP4
66493: PUSH
66494: NOP4
66498: ARRAY
66499: NOT
66500: PUSH
66501: NOP4
66505: PUSH
66506: NOP4
66510: ARRAY
66511: NOT
66512: AND
66513: PUSH
66514: NOP4
66518: PUSH
66519: NOP4
66523: ARRAY
66524: PUSH
66525: LD_INT 1
66527: GREATER
66528: AND
66529: IFFALSE 66660
// begin ComCancel ( j ) ;
66531: NOP4
66535: PPUSH
66536: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
66540: NOP4
66544: PUSH
66545: NOP4
66549: PPUSH
66550: NOP4
66554: PPUSH
66555: NOP4
66559: PUSH
66560: NOP4
66564: ARRAY
66565: PPUSH
66566: NOP4
66570: PUSH
66571: NOP4
66575: ARRAY
66576: PUSH
66577: LD_INT 1
66579: MINUS
66580: PPUSH
66581: NOP4
66585: PUSH
66586: NOP4
66590: ARRAY
66591: PPUSH
66592: LD_INT 0
66594: PPUSH
66595: NOP4
66599: PPUSH
66600: NOP4
66604: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
66605: NOP4
66609: PUSH
66610: NOP4
66614: PPUSH
66615: NOP4
66619: PPUSH
66620: NOP4
66624: PUSH
66625: NOP4
66629: ARRAY
66630: PPUSH
66631: NOP4
66635: PUSH
66636: NOP4
66640: ARRAY
66641: PPUSH
66642: LD_INT 1
66644: PPUSH
66645: LD_INT 0
66647: PPUSH
66648: NOP4
66652: PPUSH
66653: NOP4
66657: ST_TO_ADDR
// continue ;
66658: GO 66232
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
66660: NOP4
66664: PUSH
66665: NOP4
66669: ARRAY
66670: PUSH
66671: NOP4
66675: PUSH
66676: NOP4
66680: ARRAY
66681: NOT
66682: AND
66683: IFFALSE 66810
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
66685: NOP4
66689: PUSH
66690: NOP4
66694: PPUSH
66695: NOP4
66699: PUSH
66700: NOP4
66704: PUSH
66705: NOP4
66709: ARRAY
66710: PUSH
66711: LD_INT 1
66713: PLUS
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PPUSH
66719: NOP4
66723: PUSH
66724: NOP4
66728: ARRAY
66729: PUSH
66730: LD_INT 1
66732: ARRAY
66733: PPUSH
66734: NOP4
66738: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
66739: NOP4
66743: PUSH
66744: NOP4
66748: ARRAY
66749: PUSH
66750: LD_INT 1
66752: ARRAY
66753: PPUSH
66754: LD_INT 112
66756: PPUSH
66757: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
66761: NOP4
66765: PUSH
66766: NOP4
66770: PUSH
66771: NOP4
66775: ARRAY
66776: PPUSH
66777: LD_INT 1
66779: PPUSH
66780: NOP4
66784: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
66785: NOP4
66789: PUSH
66790: NOP4
66794: PPUSH
66795: NOP4
66799: PPUSH
66800: NOP4
66804: PPUSH
66805: NOP4
66809: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
66810: NOP4
66814: PUSH
66815: NOP4
66819: ARRAY
66820: PUSH
66821: NOP4
66825: PUSH
66826: NOP4
66830: ARRAY
66831: AND
66832: PUSH
66833: NOP4
66837: PUSH
66838: NOP4
66842: ARRAY
66843: PUSH
66844: LD_INT 1
66846: ARRAY
66847: PPUSH
66848: NOP4
66852: NOT
66853: AND
66854: PUSH
66855: NOP4
66859: PPUSH
66860: NOP4
66864: PUSH
66865: LD_INT 6
66867: EQUAL
66868: AND
66869: IFFALSE 66925
// begin tmp2 := UnitsInside ( j ) ;
66871: NOP4
66875: PUSH
66876: NOP4
66880: PPUSH
66881: NOP4
66885: ST_TO_ADDR
// if tmp2 = 6 then
66886: NOP4
66890: PUSH
66891: LD_INT 6
66893: EQUAL
66894: IFFALSE 66925
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
66896: NOP4
66900: PUSH
66901: LD_INT 1
66903: ARRAY
66904: PPUSH
66905: LD_INT 112
66907: PPUSH
66908: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
66912: NOP4
66916: PUSH
66917: LD_INT 1
66919: ARRAY
66920: PPUSH
66921: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
66925: NOP4
66929: PUSH
66930: NOP4
66934: ARRAY
66935: PUSH
66936: NOP4
66940: PUSH
66941: NOP4
66945: ARRAY
66946: PUSH
66947: LD_INT 1
66949: ARRAY
66950: PPUSH
66951: NOP4
66955: NOT
66956: AND
66957: PUSH
66958: NOP4
66962: PUSH
66963: NOP4
66967: ARRAY
66968: PUSH
66969: LD_INT 1
66971: ARRAY
66972: PPUSH
66973: NOP4
66977: NOT
66978: AND
66979: IFFALSE 67005
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
66981: NOP4
66985: PUSH
66986: NOP4
66990: ARRAY
66991: PUSH
66992: LD_INT 1
66994: ARRAY
66995: PPUSH
66996: NOP4
67000: PPUSH
67001: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67005: NOP4
67009: PUSH
67010: NOP4
67014: ARRAY
67015: PUSH
67016: LD_INT 1
67018: ARRAY
67019: PPUSH
67020: NOP4
67024: PUSH
67025: NOP4
67029: PUSH
67030: NOP4
67034: ARRAY
67035: PUSH
67036: LD_INT 1
67038: ARRAY
67039: PPUSH
67040: NOP4
67044: PPUSH
67045: NOP4
67049: PUSH
67050: LD_INT 3
67052: NONEQUAL
67053: AND
67054: IFFALSE 67075
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67056: NOP4
67060: PUSH
67061: NOP4
67065: ARRAY
67066: PUSH
67067: LD_INT 1
67069: ARRAY
67070: PPUSH
67071: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67075: NOP4
67079: PPUSH
67080: NOP4
67084: PUSH
67085: LD_INT 6
67087: EQUAL
67088: PUSH
67089: NOP4
67093: PUSH
67094: LD_INT 1
67096: GREATER
67097: AND
67098: IFFALSE 67250
// begin sci := [ ] ;
67100: NOP4
67104: PUSH
67105: EMPTY
67106: ST_TO_ADDR
// for x in ( tmp diff j ) do
67107: NOP4
67111: PUSH
67112: NOP4
67116: PUSH
67117: NOP4
67121: DIFF
67122: PUSH
67123: FOR_IN
67124: IFFALSE 67176
// begin if sci = 6 then
67126: NOP4
67130: PUSH
67131: LD_INT 6
67133: EQUAL
67134: IFFALSE 67138
// break ;
67136: GO 67176
// if BuildingStatus ( x ) = bs_idle then
67138: NOP4
67142: PPUSH
67143: NOP4
67147: PUSH
67148: LD_INT 2
67150: EQUAL
67151: IFFALSE 67174
// sci := sci ^ UnitsInside ( x ) ;
67153: NOP4
67157: PUSH
67158: NOP4
67162: PUSH
67163: NOP4
67167: PPUSH
67168: NOP4
67172: ADD
67173: ST_TO_ADDR
// end ;
67174: GO 67123
67176: POP
67177: POP
// if not sci then
67178: NOP4
67182: NOT
67183: IFFALSE 67187
// continue ;
67185: GO 66232
// for x in sci do
67187: NOP4
67191: PUSH
67192: NOP4
67196: PUSH
67197: FOR_IN
67198: IFFALSE 67248
// if IsInUnit ( x ) and not HasTask ( x ) then
67200: NOP4
67204: PPUSH
67205: NOP4
67209: PUSH
67210: NOP4
67214: PPUSH
67215: NOP4
67219: NOT
67220: AND
67221: IFFALSE 67246
// begin ComExitBuilding ( x ) ;
67223: NOP4
67227: PPUSH
67228: NOP4
// AddComEnterUnit ( x , j ) ;
67232: NOP4
67236: PPUSH
67237: NOP4
67241: PPUSH
67242: NOP4
// end ;
67246: GO 67197
67248: POP
67249: POP
// end ; end ;
67250: GO 66232
67252: POP
67253: POP
// end ;
67254: GO 66186
67256: POP
67257: POP
// end ;
67258: LD_VAR 0 1
67262: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67263: LD_INT 0
67265: PPUSH
67266: PPUSH
// if not mc_bases then
67267: NOP4
67271: NOT
67272: IFFALSE 67276
// exit ;
67274: GO 67357
// for i = 1 to mc_bases do
67276: NOP4
67280: PUSH
67281: DOUBLE
67282: LD_INT 1
67284: DEC
67285: ST_TO_ADDR
67286: NOP4
67290: PUSH
67291: FOR_TO
67292: IFFALSE 67355
// if mc_mines [ i ] and mc_miners [ i ] then
67294: NOP4
67298: PUSH
67299: NOP4
67303: ARRAY
67304: PUSH
67305: NOP4
67309: PUSH
67310: NOP4
67314: ARRAY
67315: AND
67316: IFFALSE 67353
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67318: NOP4
67322: PUSH
67323: NOP4
67327: ARRAY
67328: PUSH
67329: LD_INT 1
67331: ARRAY
67332: PPUSH
67333: NOP4
67337: PPUSH
67338: NOP4
67342: PUSH
67343: NOP4
67347: ARRAY
67348: PPUSH
67349: NOP4
67353: GO 67291
67355: POP
67356: POP
// end ;
67357: LD_VAR 0 1
67361: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67362: LD_INT 0
67364: PPUSH
67365: PPUSH
67366: PPUSH
67367: PPUSH
67368: PPUSH
67369: PPUSH
67370: PPUSH
67371: PPUSH
// if not mc_bases or not mc_parking then
67372: NOP4
67376: NOT
67377: PUSH
67378: NOP4
67382: NOT
67383: OR
67384: IFFALSE 67388
// exit ;
67386: GO 68098
// for i = 1 to mc_bases do
67388: NOP4
67392: PUSH
67393: DOUBLE
67394: LD_INT 1
67396: DEC
67397: ST_TO_ADDR
67398: NOP4
67402: PUSH
67403: FOR_TO
67404: IFFALSE 68096
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67406: NOP4
67410: PUSH
67411: NOP4
67415: ARRAY
67416: NOT
67417: PUSH
67418: NOP4
67422: PUSH
67423: NOP4
67427: ARRAY
67428: NOT
67429: OR
67430: IFFALSE 67434
// continue ;
67432: GO 67403
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67434: NOP4
67438: PUSH
67439: NOP4
67443: PUSH
67444: NOP4
67448: ARRAY
67449: PUSH
67450: LD_INT 1
67452: ARRAY
67453: PPUSH
67454: NOP4
67458: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67459: NOP4
67463: PUSH
67464: NOP4
67468: PUSH
67469: NOP4
67473: ARRAY
67474: PPUSH
67475: LD_INT 30
67477: PUSH
67478: LD_INT 3
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PPUSH
67485: NOP4
67489: ST_TO_ADDR
// if not fac then
67490: NOP4
67494: NOT
67495: IFFALSE 67546
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67497: NOP4
67501: PUSH
67502: NOP4
67506: PUSH
67507: NOP4
67511: ARRAY
67512: PPUSH
67513: LD_INT 2
67515: PUSH
67516: LD_INT 30
67518: PUSH
67519: LD_INT 0
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 30
67528: PUSH
67529: LD_INT 1
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: LIST
67540: PPUSH
67541: NOP4
67545: ST_TO_ADDR
// if not fac then
67546: NOP4
67550: NOT
67551: IFFALSE 67555
// continue ;
67553: GO 67403
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67555: NOP4
67559: PUSH
67560: NOP4
67564: PUSH
67565: NOP4
67569: ARRAY
67570: PPUSH
67571: LD_INT 22
67573: PUSH
67574: NOP4
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 21
67585: PUSH
67586: LD_INT 2
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 3
67595: PUSH
67596: LD_INT 24
67598: PUSH
67599: LD_INT 1000
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: LIST
67614: PPUSH
67615: NOP4
67619: ST_TO_ADDR
// for j in fac do
67620: NOP4
67624: PUSH
67625: NOP4
67629: PUSH
67630: FOR_IN
67631: IFFALSE 67712
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67633: NOP4
67637: PUSH
67638: NOP4
67642: PUSH
67643: LD_INT 22
67645: PUSH
67646: NOP4
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 91
67657: PUSH
67658: NOP4
67662: PUSH
67663: LD_INT 15
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 21
67673: PUSH
67674: LD_INT 2
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 3
67683: PUSH
67684: LD_INT 24
67686: PUSH
67687: LD_INT 1000
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: PPUSH
67704: NOP4
67708: UNION
67709: ST_TO_ADDR
67710: GO 67630
67712: POP
67713: POP
// if not vehs then
67714: NOP4
67718: NOT
67719: IFFALSE 67745
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
67721: NOP4
67725: PUSH
67726: NOP4
67730: PPUSH
67731: NOP4
67735: PPUSH
67736: EMPTY
67737: PPUSH
67738: NOP4
67742: ST_TO_ADDR
// continue ;
67743: GO 67403
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67745: NOP4
67749: PUSH
67750: NOP4
67754: PUSH
67755: NOP4
67759: ARRAY
67760: PPUSH
67761: LD_INT 30
67763: PUSH
67764: LD_INT 3
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PPUSH
67771: NOP4
67775: ST_TO_ADDR
// if tmp then
67776: NOP4
67780: IFFALSE 67883
// begin for j in tmp do
67782: NOP4
67786: PUSH
67787: NOP4
67791: PUSH
67792: FOR_IN
67793: IFFALSE 67881
// for k in UnitsInside ( j ) do
67795: NOP4
67799: PUSH
67800: NOP4
67804: PPUSH
67805: NOP4
67809: PUSH
67810: FOR_IN
67811: IFFALSE 67877
// if k then
67813: NOP4
67817: IFFALSE 67875
// if not k in mc_repair_vehicle [ i ] then
67819: NOP4
67823: PUSH
67824: NOP4
67828: PUSH
67829: NOP4
67833: ARRAY
67834: IN
67835: NOT
67836: IFFALSE 67875
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
67838: NOP4
67842: PUSH
67843: NOP4
67847: PPUSH
67848: NOP4
67852: PPUSH
67853: NOP4
67857: PUSH
67858: NOP4
67862: ARRAY
67863: PUSH
67864: NOP4
67868: UNION
67869: PPUSH
67870: NOP4
67874: ST_TO_ADDR
67875: GO 67810
67877: POP
67878: POP
67879: GO 67792
67881: POP
67882: POP
// end ; if not mc_repair_vehicle [ i ] then
67883: NOP4
67887: PUSH
67888: NOP4
67892: ARRAY
67893: NOT
67894: IFFALSE 67898
// continue ;
67896: GO 67403
// for j in mc_repair_vehicle [ i ] do
67898: NOP4
67902: PUSH
67903: NOP4
67907: PUSH
67908: NOP4
67912: ARRAY
67913: PUSH
67914: FOR_IN
67915: IFFALSE 68092
// begin if GetClass ( j ) <> 3 then
67917: NOP4
67921: PPUSH
67922: NOP4
67926: PUSH
67927: LD_INT 3
67929: NONEQUAL
67930: IFFALSE 67971
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
67932: NOP4
67936: PUSH
67937: NOP4
67941: PPUSH
67942: NOP4
67946: PPUSH
67947: NOP4
67951: PUSH
67952: NOP4
67956: ARRAY
67957: PUSH
67958: NOP4
67962: DIFF
67963: PPUSH
67964: NOP4
67968: ST_TO_ADDR
// continue ;
67969: GO 67914
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67971: NOP4
67975: PPUSH
67976: NOP4
67980: NOT
67981: PUSH
67982: NOP4
67986: PUSH
67987: NOP4
67991: PUSH
67992: NOP4
67996: ARRAY
67997: PUSH
67998: LD_INT 1
68000: ARRAY
68001: IN
68002: NOT
68003: AND
68004: PUSH
68005: NOP4
68009: PUSH
68010: NOP4
68014: PUSH
68015: NOP4
68019: ARRAY
68020: PUSH
68021: LD_INT 2
68023: ARRAY
68024: IN
68025: NOT
68026: AND
68027: IFFALSE 68090
// begin if IsInUnit ( j ) then
68029: NOP4
68033: PPUSH
68034: NOP4
68038: IFFALSE 68051
// ComExitBuilding ( j ) else
68040: NOP4
68044: PPUSH
68045: NOP4
68049: GO 68090
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
68051: NOP4
68055: PPUSH
68056: NOP4
68060: PUSH
68061: LD_INT 1
68063: ARRAY
68064: PPUSH
68065: NOP4
68069: NOT
68070: IFFALSE 68090
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
68072: NOP4
68076: PPUSH
68077: NOP4
68081: PUSH
68082: LD_INT 1
68084: ARRAY
68085: PPUSH
68086: NOP4
// end ; end ;
68090: GO 67914
68092: POP
68093: POP
// end ;
68094: GO 67403
68096: POP
68097: POP
// end ;
68098: LD_VAR 0 1
68102: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68103: LD_INT 0
68105: PPUSH
68106: PPUSH
68107: PPUSH
68108: PPUSH
68109: PPUSH
68110: PPUSH
68111: PPUSH
68112: PPUSH
68113: PPUSH
68114: PPUSH
68115: PPUSH
// if not mc_bases then
68116: NOP4
68120: NOT
68121: IFFALSE 68125
// exit ;
68123: GO 68927
// for i = 1 to mc_bases do
68125: NOP4
68129: PUSH
68130: DOUBLE
68131: LD_INT 1
68133: DEC
68134: ST_TO_ADDR
68135: NOP4
68139: PUSH
68140: FOR_TO
68141: IFFALSE 68925
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68143: NOP4
68147: PUSH
68148: NOP4
68152: ARRAY
68153: NOT
68154: PUSH
68155: NOP4
68159: PUSH
68160: NOP4
68164: ARRAY
68165: PUSH
68166: LD_INT 1
68168: ARRAY
68169: OR
68170: PUSH
68171: NOP4
68175: PUSH
68176: NOP4
68180: ARRAY
68181: PUSH
68182: LD_INT 2
68184: ARRAY
68185: OR
68186: PUSH
68187: NOP4
68191: PUSH
68192: NOP4
68196: ARRAY
68197: PPUSH
68198: LD_INT 1
68200: PPUSH
68201: NOP4
68205: NOT
68206: OR
68207: PUSH
68208: NOP4
68212: PUSH
68213: NOP4
68217: ARRAY
68218: OR
68219: IFFALSE 68223
// continue ;
68221: GO 68140
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68223: NOP4
68227: PUSH
68228: NOP4
68232: PUSH
68233: NOP4
68237: ARRAY
68238: PPUSH
68239: LD_INT 25
68241: PUSH
68242: LD_INT 4
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 50
68251: PUSH
68252: EMPTY
68253: LIST
68254: PUSH
68255: LD_INT 3
68257: PUSH
68258: LD_INT 60
68260: PUSH
68261: EMPTY
68262: LIST
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: LIST
68272: PPUSH
68273: NOP4
68277: PUSH
68278: NOP4
68282: PUSH
68283: NOP4
68287: ARRAY
68288: DIFF
68289: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68290: NOP4
68294: PUSH
68295: NOP4
68299: PUSH
68300: NOP4
68304: ARRAY
68305: PPUSH
68306: LD_INT 2
68308: PUSH
68309: LD_INT 30
68311: PUSH
68312: LD_INT 0
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 30
68321: PUSH
68322: LD_INT 1
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: LIST
68333: PPUSH
68334: NOP4
68338: ST_TO_ADDR
// if not tmp or not dep then
68339: NOP4
68343: NOT
68344: PUSH
68345: NOP4
68349: NOT
68350: OR
68351: IFFALSE 68355
// continue ;
68353: GO 68140
// side := GetSide ( tmp [ 1 ] ) ;
68355: NOP4
68359: PUSH
68360: NOP4
68364: PUSH
68365: LD_INT 1
68367: ARRAY
68368: PPUSH
68369: NOP4
68373: ST_TO_ADDR
// dep := dep [ 1 ] ;
68374: NOP4
68378: PUSH
68379: NOP4
68383: PUSH
68384: LD_INT 1
68386: ARRAY
68387: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68388: NOP4
68392: PUSH
68393: NOP4
68397: PUSH
68398: NOP4
68402: ARRAY
68403: PPUSH
68404: LD_INT 22
68406: PUSH
68407: LD_INT 0
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 25
68416: PUSH
68417: LD_INT 12
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PPUSH
68428: NOP4
68432: PUSH
68433: LD_INT 22
68435: PUSH
68436: LD_INT 0
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 25
68445: PUSH
68446: LD_INT 12
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 91
68455: PUSH
68456: NOP4
68460: PUSH
68461: LD_INT 20
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: LIST
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: LIST
68473: PPUSH
68474: NOP4
68478: UNION
68479: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
68480: NOP4
68484: PUSH
68485: NOP4
68489: PUSH
68490: NOP4
68494: ARRAY
68495: PPUSH
68496: LD_INT 81
68498: PUSH
68499: NOP4
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PPUSH
68508: NOP4
68512: ST_TO_ADDR
// if not apes or danger_at_area then
68513: NOP4
68517: NOT
68518: PUSH
68519: NOP4
68523: OR
68524: IFFALSE 68574
// begin if mc_taming [ i ] then
68526: NOP4
68530: PUSH
68531: NOP4
68535: ARRAY
68536: IFFALSE 68572
// begin MC_Reset ( i , 121 ) ;
68538: NOP4
68542: PPUSH
68543: LD_INT 121
68545: PPUSH
68546: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68550: NOP4
68554: PUSH
68555: NOP4
68559: PPUSH
68560: NOP4
68564: PPUSH
68565: EMPTY
68566: PPUSH
68567: NOP4
68571: ST_TO_ADDR
// end ; continue ;
68572: GO 68140
// end ; for j in tmp do
68574: NOP4
68578: PUSH
68579: NOP4
68583: PUSH
68584: FOR_IN
68585: IFFALSE 68921
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
68587: NOP4
68591: PUSH
68592: NOP4
68596: PUSH
68597: NOP4
68601: ARRAY
68602: IN
68603: NOT
68604: PUSH
68605: NOP4
68609: PUSH
68610: NOP4
68614: ARRAY
68615: PUSH
68616: LD_INT 3
68618: LESS
68619: AND
68620: IFFALSE 68678
// begin SetTag ( j , 121 ) ;
68622: NOP4
68626: PPUSH
68627: LD_INT 121
68629: PPUSH
68630: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
68634: NOP4
68638: PUSH
68639: NOP4
68643: PPUSH
68644: NOP4
68648: PUSH
68649: NOP4
68653: PUSH
68654: NOP4
68658: ARRAY
68659: PUSH
68660: LD_INT 1
68662: PLUS
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PPUSH
68668: NOP4
68672: PPUSH
68673: NOP4
68677: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
68678: NOP4
68682: PUSH
68683: NOP4
68687: PUSH
68688: NOP4
68692: ARRAY
68693: IN
68694: IFFALSE 68919
// begin if GetClass ( j ) <> 4 then
68696: NOP4
68700: PPUSH
68701: NOP4
68705: PUSH
68706: LD_INT 4
68708: NONEQUAL
68709: IFFALSE 68762
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
68711: NOP4
68715: PUSH
68716: NOP4
68720: PPUSH
68721: NOP4
68725: PPUSH
68726: NOP4
68730: PUSH
68731: NOP4
68735: ARRAY
68736: PUSH
68737: NOP4
68741: DIFF
68742: PPUSH
68743: NOP4
68747: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68748: NOP4
68752: PPUSH
68753: LD_INT 0
68755: PPUSH
68756: NOP4
// continue ;
68760: GO 68584
// end ; if IsInUnit ( j ) then
68762: NOP4
68766: PPUSH
68767: NOP4
68771: IFFALSE 68782
// ComExitBuilding ( j ) ;
68773: NOP4
68777: PPUSH
68778: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
68782: NOP4
68786: PUSH
68787: NOP4
68791: PPUSH
68792: NOP4
68796: PPUSH
68797: NOP4
68801: ST_TO_ADDR
// if not ape then
68802: NOP4
68806: NOT
68807: IFFALSE 68811
// break ;
68809: GO 68921
// x := GetX ( ape ) ;
68811: NOP4
68815: PUSH
68816: NOP4
68820: PPUSH
68821: NOP4
68825: ST_TO_ADDR
// y := GetY ( ape ) ;
68826: NOP4
68830: PUSH
68831: NOP4
68835: PPUSH
68836: NOP4
68840: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68841: NOP4
68845: PPUSH
68846: NOP4
68850: PPUSH
68851: NOP4
68855: NOT
68856: PUSH
68857: NOP4
68861: PPUSH
68862: NOP4
68866: PPUSH
68867: NOP4
68871: PPUSH
68872: LD_INT 20
68874: PPUSH
68875: NOP4
68879: PUSH
68880: LD_INT 4
68882: ARRAY
68883: OR
68884: IFFALSE 68888
// break ;
68886: GO 68921
// if not HasTask ( j ) then
68888: NOP4
68892: PPUSH
68893: NOP4
68897: NOT
68898: IFFALSE 68919
// ComTameXY ( j , x , y ) ;
68900: NOP4
68904: PPUSH
68905: NOP4
68909: PPUSH
68910: NOP4
68914: PPUSH
68915: NOP4
// end ; end ;
68919: GO 68584
68921: POP
68922: POP
// end ;
68923: GO 68140
68925: POP
68926: POP
// end ;
68927: LD_VAR 0 1
68931: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
68932: LD_INT 0
68934: PPUSH
68935: PPUSH
68936: PPUSH
68937: PPUSH
68938: PPUSH
68939: PPUSH
68940: PPUSH
68941: PPUSH
// if not mc_bases then
68942: NOP4
68946: NOT
68947: IFFALSE 68951
// exit ;
68949: GO 69577
// for i = 1 to mc_bases do
68951: NOP4
68955: PUSH
68956: DOUBLE
68957: LD_INT 1
68959: DEC
68960: ST_TO_ADDR
68961: NOP4
68965: PUSH
68966: FOR_TO
68967: IFFALSE 69575
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
68969: NOP4
68973: PUSH
68974: NOP4
68978: ARRAY
68979: NOT
68980: PUSH
68981: NOP4
68985: PUSH
68986: NOP4
68990: ARRAY
68991: PPUSH
68992: LD_INT 25
68994: PUSH
68995: LD_INT 12
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PPUSH
69002: NOP4
69006: NOT
69007: OR
69008: IFFALSE 69012
// continue ;
69010: GO 68966
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69012: NOP4
69016: PUSH
69017: NOP4
69021: PUSH
69022: NOP4
69026: ARRAY
69027: PUSH
69028: LD_INT 1
69030: ARRAY
69031: PPUSH
69032: NOP4
69036: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69037: NOP4
69041: PPUSH
69042: LD_INT 2
69044: PPUSH
69045: NOP4
69049: IFFALSE 69302
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69051: NOP4
69055: PUSH
69056: NOP4
69060: PUSH
69061: NOP4
69065: ARRAY
69066: PPUSH
69067: LD_INT 25
69069: PUSH
69070: LD_INT 16
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PPUSH
69077: NOP4
69081: ST_TO_ADDR
// if tmp < 6 then
69082: NOP4
69086: PUSH
69087: LD_INT 6
69089: LESS
69090: IFFALSE 69302
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69092: NOP4
69096: PUSH
69097: NOP4
69101: PUSH
69102: NOP4
69106: ARRAY
69107: PPUSH
69108: LD_INT 2
69110: PUSH
69111: LD_INT 30
69113: PUSH
69114: LD_INT 0
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 30
69123: PUSH
69124: LD_INT 1
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: LIST
69135: PPUSH
69136: NOP4
69140: ST_TO_ADDR
// if depot then
69141: NOP4
69145: IFFALSE 69302
// begin selected := 0 ;
69147: NOP4
69151: PUSH
69152: LD_INT 0
69154: ST_TO_ADDR
// for j in depot do
69155: NOP4
69159: PUSH
69160: NOP4
69164: PUSH
69165: FOR_IN
69166: IFFALSE 69197
// begin if UnitsInside ( j ) < 6 then
69168: NOP4
69172: PPUSH
69173: NOP4
69177: PUSH
69178: LD_INT 6
69180: LESS
69181: IFFALSE 69195
// begin selected := j ;
69183: NOP4
69187: PUSH
69188: NOP4
69192: ST_TO_ADDR
// break ;
69193: GO 69197
// end ; end ;
69195: GO 69165
69197: POP
69198: POP
// if selected then
69199: NOP4
69203: IFFALSE 69302
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69205: NOP4
69209: PUSH
69210: NOP4
69214: PUSH
69215: NOP4
69219: ARRAY
69220: PPUSH
69221: LD_INT 25
69223: PUSH
69224: LD_INT 12
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PPUSH
69231: NOP4
69235: PUSH
69236: FOR_IN
69237: IFFALSE 69300
// if not HasTask ( j ) then
69239: NOP4
69243: PPUSH
69244: NOP4
69248: NOT
69249: IFFALSE 69298
// begin if not IsInUnit ( j ) then
69251: NOP4
69255: PPUSH
69256: NOP4
69260: NOT
69261: IFFALSE 69277
// ComEnterUnit ( j , selected ) ;
69263: NOP4
69267: PPUSH
69268: NOP4
69272: PPUSH
69273: NOP4
// AddComChangeProfession ( j , 16 ) ;
69277: NOP4
69281: PPUSH
69282: LD_INT 16
69284: PPUSH
69285: NOP4
// AddComExitBuilding ( j ) ;
69289: NOP4
69293: PPUSH
69294: NOP4
// end ;
69298: GO 69236
69300: POP
69301: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69302: NOP4
69306: PPUSH
69307: LD_INT 11
69309: PPUSH
69310: NOP4
69314: IFFALSE 69573
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69316: NOP4
69320: PUSH
69321: NOP4
69325: PUSH
69326: NOP4
69330: ARRAY
69331: PPUSH
69332: LD_INT 25
69334: PUSH
69335: LD_INT 16
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PPUSH
69342: NOP4
69346: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69347: NOP4
69351: PUSH
69352: LD_INT 6
69354: GREATEREQUAL
69355: PUSH
69356: NOP4
69360: PPUSH
69361: LD_INT 2
69363: PPUSH
69364: NOP4
69368: NOT
69369: OR
69370: IFFALSE 69573
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69372: NOP4
69376: PUSH
69377: NOP4
69381: PUSH
69382: NOP4
69386: ARRAY
69387: PPUSH
69388: LD_INT 2
69390: PUSH
69391: LD_INT 30
69393: PUSH
69394: LD_INT 4
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 30
69403: PUSH
69404: LD_INT 5
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: LIST
69415: PPUSH
69416: NOP4
69420: ST_TO_ADDR
// if barracks then
69421: NOP4
69425: IFFALSE 69573
// begin selected := 0 ;
69427: NOP4
69431: PUSH
69432: LD_INT 0
69434: ST_TO_ADDR
// for j in barracks do
69435: NOP4
69439: PUSH
69440: NOP4
69444: PUSH
69445: FOR_IN
69446: IFFALSE 69477
// begin if UnitsInside ( j ) < 6 then
69448: NOP4
69452: PPUSH
69453: NOP4
69457: PUSH
69458: LD_INT 6
69460: LESS
69461: IFFALSE 69475
// begin selected := j ;
69463: NOP4
69467: PUSH
69468: NOP4
69472: ST_TO_ADDR
// break ;
69473: GO 69477
// end ; end ;
69475: GO 69445
69477: POP
69478: POP
// if selected then
69479: NOP4
69483: IFFALSE 69573
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69485: NOP4
69489: PUSH
69490: NOP4
69494: PUSH
69495: NOP4
69499: ARRAY
69500: PPUSH
69501: LD_INT 25
69503: PUSH
69504: LD_INT 12
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PPUSH
69511: NOP4
69515: PUSH
69516: FOR_IN
69517: IFFALSE 69571
// if not IsInUnit ( j ) and not HasTask ( j ) then
69519: NOP4
69523: PPUSH
69524: NOP4
69528: NOT
69529: PUSH
69530: NOP4
69534: PPUSH
69535: NOP4
69539: NOT
69540: AND
69541: IFFALSE 69569
// begin ComEnterUnit ( j , selected ) ;
69543: NOP4
69547: PPUSH
69548: NOP4
69552: PPUSH
69553: NOP4
// AddComChangeProfession ( j , 15 ) ;
69557: NOP4
69561: PPUSH
69562: LD_INT 15
69564: PPUSH
69565: NOP4
// end ;
69569: GO 69516
69571: POP
69572: POP
// end ; end ; end ; end ; end ;
69573: GO 68966
69575: POP
69576: POP
// end ;
69577: LD_VAR 0 1
69581: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
69582: LD_INT 0
69584: PPUSH
69585: PPUSH
69586: PPUSH
69587: PPUSH
// if not mc_bases then
69588: NOP4
69592: NOT
69593: IFFALSE 69597
// exit ;
69595: GO 69775
// for i = 1 to mc_bases do
69597: NOP4
69601: PUSH
69602: DOUBLE
69603: LD_INT 1
69605: DEC
69606: ST_TO_ADDR
69607: NOP4
69611: PUSH
69612: FOR_TO
69613: IFFALSE 69773
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
69615: NOP4
69619: PUSH
69620: NOP4
69624: PUSH
69625: NOP4
69629: ARRAY
69630: PPUSH
69631: LD_INT 25
69633: PUSH
69634: LD_INT 9
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PPUSH
69641: NOP4
69645: ST_TO_ADDR
// if not tmp then
69646: NOP4
69650: NOT
69651: IFFALSE 69655
// continue ;
69653: GO 69612
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
69655: NOP4
69659: PUSH
69660: NOP4
69664: ARRAY
69665: PPUSH
69666: LD_INT 29
69668: PPUSH
69669: NOP4
69673: NOT
69674: PUSH
69675: NOP4
69679: PUSH
69680: NOP4
69684: ARRAY
69685: PPUSH
69686: LD_INT 28
69688: PPUSH
69689: NOP4
69693: NOT
69694: AND
69695: IFFALSE 69699
// continue ;
69697: GO 69612
// for j in tmp do
69699: NOP4
69703: PUSH
69704: NOP4
69708: PUSH
69709: FOR_IN
69710: IFFALSE 69769
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69712: NOP4
69716: PUSH
69717: NOP4
69721: PUSH
69722: NOP4
69726: ARRAY
69727: PUSH
69728: LD_INT 1
69730: ARRAY
69731: IN
69732: NOT
69733: PUSH
69734: NOP4
69738: PUSH
69739: NOP4
69743: PUSH
69744: NOP4
69748: ARRAY
69749: PUSH
69750: LD_INT 2
69752: ARRAY
69753: IN
69754: NOT
69755: AND
69756: IFFALSE 69767
// ComSpaceTimeShoot ( j ) ;
69758: NOP4
69762: PPUSH
69763: NOP4
69767: GO 69709
69769: POP
69770: POP
// end ;
69771: GO 69612
69773: POP
69774: POP
// end ;
69775: LD_VAR 0 1
69779: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
69780: LD_INT 0
69782: PPUSH
69783: PPUSH
69784: PPUSH
69785: PPUSH
69786: PPUSH
69787: PPUSH
69788: PPUSH
69789: PPUSH
69790: PPUSH
// if not mc_bases then
69791: NOP4
69795: NOT
69796: IFFALSE 69800
// exit ;
69798: GO 70422
// for i = 1 to mc_bases do
69800: NOP4
69804: PUSH
69805: DOUBLE
69806: LD_INT 1
69808: DEC
69809: ST_TO_ADDR
69810: NOP4
69814: PUSH
69815: FOR_TO
69816: IFFALSE 70420
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
69818: NOP4
69822: PUSH
69823: NOP4
69827: ARRAY
69828: NOT
69829: PUSH
69830: LD_INT 38
69832: PPUSH
69833: NOP4
69837: PUSH
69838: NOP4
69842: ARRAY
69843: PPUSH
69844: NOP4
69848: PUSH
69849: LD_INT 2
69851: NONEQUAL
69852: OR
69853: IFFALSE 69857
// continue ;
69855: GO 69815
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
69857: NOP4
69861: PUSH
69862: NOP4
69866: PUSH
69867: NOP4
69871: ARRAY
69872: PPUSH
69873: LD_INT 30
69875: PUSH
69876: LD_INT 34
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PPUSH
69883: NOP4
69887: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
69888: NOP4
69892: PUSH
69893: NOP4
69897: PUSH
69898: NOP4
69902: ARRAY
69903: PPUSH
69904: LD_INT 25
69906: PUSH
69907: LD_INT 4
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PPUSH
69914: NOP4
69918: PPUSH
69919: LD_INT 0
69921: PPUSH
69922: NOP4
69926: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
69927: NOP4
69931: NOT
69932: PUSH
69933: NOP4
69937: NOT
69938: OR
69939: PUSH
69940: NOP4
69944: PUSH
69945: NOP4
69949: ARRAY
69950: PPUSH
69951: LD_INT 124
69953: PPUSH
69954: NOP4
69958: OR
69959: IFFALSE 69963
// continue ;
69961: GO 69815
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
69963: NOP4
69967: PUSH
69968: NOP4
69972: ARRAY
69973: PUSH
69974: NOP4
69978: PUSH
69979: NOP4
69983: ARRAY
69984: LESS
69985: PUSH
69986: NOP4
69990: PUSH
69991: NOP4
69995: ARRAY
69996: PUSH
69997: NOP4
70001: LESS
70002: AND
70003: IFFALSE 70418
// begin tmp := sci [ 1 ] ;
70005: NOP4
70009: PUSH
70010: NOP4
70014: PUSH
70015: LD_INT 1
70017: ARRAY
70018: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70019: NOP4
70023: PPUSH
70024: LD_INT 124
70026: PPUSH
70027: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70031: NOP4
70035: PUSH
70036: DOUBLE
70037: NOP4
70041: PUSH
70042: NOP4
70046: ARRAY
70047: INC
70048: ST_TO_ADDR
70049: NOP4
70053: PUSH
70054: NOP4
70058: ARRAY
70059: PUSH
70060: FOR_DOWNTO
70061: IFFALSE 70404
// begin if IsInUnit ( tmp ) then
70063: NOP4
70067: PPUSH
70068: NOP4
70072: IFFALSE 70083
// ComExitBuilding ( tmp ) ;
70074: NOP4
70078: PPUSH
70079: NOP4
// repeat wait ( 0 0$1 ) ;
70083: LD_INT 35
70085: PPUSH
70086: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70090: NOP4
70094: PPUSH
70095: NOP4
70099: NOT
70100: PUSH
70101: NOP4
70105: PPUSH
70106: NOP4
70110: NOT
70111: AND
70112: IFFALSE 70083
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70114: NOP4
70118: PUSH
70119: NOP4
70123: PPUSH
70124: NOP4
70128: PUSH
70129: NOP4
70133: PPUSH
70134: NOP4
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70143: LD_INT 35
70145: PPUSH
70146: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70150: NOP4
70154: PUSH
70155: NOP4
70159: PUSH
70160: NOP4
70164: ARRAY
70165: PUSH
70166: NOP4
70170: ARRAY
70171: PUSH
70172: LD_INT 1
70174: ARRAY
70175: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70176: NOP4
70180: PUSH
70181: NOP4
70185: PUSH
70186: NOP4
70190: ARRAY
70191: PUSH
70192: NOP4
70196: ARRAY
70197: PUSH
70198: LD_INT 2
70200: ARRAY
70201: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70202: NOP4
70206: PPUSH
70207: LD_INT 10
70209: PPUSH
70210: NOP4
70214: PUSH
70215: LD_INT 4
70217: ARRAY
70218: IFFALSE 70256
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70220: NOP4
70224: PPUSH
70225: NOP4
70229: PUSH
70230: LD_INT 1
70232: ARRAY
70233: PPUSH
70234: NOP4
70238: PUSH
70239: LD_INT 2
70241: ARRAY
70242: PPUSH
70243: NOP4
// wait ( 0 0$10 ) ;
70247: LD_INT 350
70249: PPUSH
70250: NOP4
// end else
70254: GO 70282
// begin ComMoveXY ( tmp , x , y ) ;
70256: NOP4
70260: PPUSH
70261: NOP4
70265: PPUSH
70266: NOP4
70270: PPUSH
70271: NOP4
// wait ( 0 0$3 ) ;
70275: LD_INT 105
70277: PPUSH
70278: NOP4
// end ; until IsAt ( tmp , x , y ) ;
70282: NOP4
70286: PPUSH
70287: NOP4
70291: PPUSH
70292: NOP4
70296: PPUSH
70297: NOP4
70301: IFFALSE 70143
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70303: NOP4
70307: PPUSH
70308: NOP4
70312: PPUSH
70313: NOP4
70317: PPUSH
70318: NOP4
70322: PUSH
70323: NOP4
70327: ARRAY
70328: PPUSH
70329: NOP4
// repeat wait ( 0 0$1 ) ;
70333: LD_INT 35
70335: PPUSH
70336: NOP4
// until not HasTask ( tmp ) ;
70340: NOP4
70344: PPUSH
70345: NOP4
70349: NOT
70350: IFFALSE 70333
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70352: NOP4
70356: PUSH
70357: NOP4
70361: PPUSH
70362: NOP4
70366: PUSH
70367: NOP4
70371: PUSH
70372: NOP4
70376: ARRAY
70377: PUSH
70378: LD_INT 1
70380: PLUS
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PPUSH
70386: NOP4
70390: PUSH
70391: NOP4
70395: ARRAY
70396: PPUSH
70397: NOP4
70401: ST_TO_ADDR
// end ;
70402: GO 70060
70404: POP
70405: POP
// MC_Reset ( i , 124 ) ;
70406: NOP4
70410: PPUSH
70411: LD_INT 124
70413: PPUSH
70414: NOP4
// end ; end ;
70418: GO 69815
70420: POP
70421: POP
// end ;
70422: LD_VAR 0 1
70426: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70427: LD_INT 0
70429: PPUSH
70430: PPUSH
70431: PPUSH
// if not mc_bases then
70432: NOP4
70436: NOT
70437: IFFALSE 70441
// exit ;
70439: GO 71047
// for i = 1 to mc_bases do
70441: NOP4
70445: PUSH
70446: DOUBLE
70447: LD_INT 1
70449: DEC
70450: ST_TO_ADDR
70451: NOP4
70455: PUSH
70456: FOR_TO
70457: IFFALSE 71045
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70459: NOP4
70463: PUSH
70464: NOP4
70468: PUSH
70469: NOP4
70473: ARRAY
70474: PPUSH
70475: LD_INT 25
70477: PUSH
70478: LD_INT 4
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PPUSH
70485: NOP4
70489: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70490: NOP4
70494: NOT
70495: PUSH
70496: NOP4
70500: PUSH
70501: NOP4
70505: ARRAY
70506: NOT
70507: OR
70508: PUSH
70509: NOP4
70513: PUSH
70514: NOP4
70518: ARRAY
70519: PPUSH
70520: LD_INT 2
70522: PUSH
70523: LD_INT 30
70525: PUSH
70526: LD_INT 0
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 30
70535: PUSH
70536: LD_INT 1
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: LIST
70547: PPUSH
70548: NOP4
70552: NOT
70553: OR
70554: IFFALSE 70604
// begin if mc_deposits_finder [ i ] then
70556: NOP4
70560: PUSH
70561: NOP4
70565: ARRAY
70566: IFFALSE 70602
// begin MC_Reset ( i , 125 ) ;
70568: NOP4
70572: PPUSH
70573: LD_INT 125
70575: PPUSH
70576: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70580: NOP4
70584: PUSH
70585: NOP4
70589: PPUSH
70590: NOP4
70594: PPUSH
70595: EMPTY
70596: PPUSH
70597: NOP4
70601: ST_TO_ADDR
// end ; continue ;
70602: GO 70456
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
70604: NOP4
70608: PUSH
70609: NOP4
70613: ARRAY
70614: PUSH
70615: LD_INT 1
70617: ARRAY
70618: PUSH
70619: LD_INT 3
70621: ARRAY
70622: PUSH
70623: LD_INT 1
70625: EQUAL
70626: PUSH
70627: LD_INT 20
70629: PPUSH
70630: NOP4
70634: PUSH
70635: NOP4
70639: ARRAY
70640: PPUSH
70641: NOP4
70645: PUSH
70646: LD_INT 2
70648: NONEQUAL
70649: AND
70650: IFFALSE 70700
// begin if mc_deposits_finder [ i ] then
70652: NOP4
70656: PUSH
70657: NOP4
70661: ARRAY
70662: IFFALSE 70698
// begin MC_Reset ( i , 125 ) ;
70664: NOP4
70668: PPUSH
70669: LD_INT 125
70671: PPUSH
70672: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70676: NOP4
70680: PUSH
70681: NOP4
70685: PPUSH
70686: NOP4
70690: PPUSH
70691: EMPTY
70692: PPUSH
70693: NOP4
70697: ST_TO_ADDR
// end ; continue ;
70698: GO 70456
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
70700: NOP4
70704: PUSH
70705: NOP4
70709: ARRAY
70710: PUSH
70711: LD_INT 1
70713: ARRAY
70714: PUSH
70715: LD_INT 1
70717: ARRAY
70718: PPUSH
70719: NOP4
70723: PUSH
70724: NOP4
70728: ARRAY
70729: PUSH
70730: LD_INT 1
70732: ARRAY
70733: PUSH
70734: LD_INT 2
70736: ARRAY
70737: PPUSH
70738: NOP4
70742: PUSH
70743: NOP4
70747: ARRAY
70748: PPUSH
70749: NOP4
70753: IFFALSE 70796
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
70755: NOP4
70759: PUSH
70760: NOP4
70764: PPUSH
70765: NOP4
70769: PPUSH
70770: NOP4
70774: PUSH
70775: NOP4
70779: ARRAY
70780: PPUSH
70781: LD_INT 1
70783: PPUSH
70784: NOP4
70788: PPUSH
70789: NOP4
70793: ST_TO_ADDR
70794: GO 71043
// begin if not mc_deposits_finder [ i ] then
70796: NOP4
70800: PUSH
70801: NOP4
70805: ARRAY
70806: NOT
70807: IFFALSE 70859
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
70809: NOP4
70813: PUSH
70814: NOP4
70818: PPUSH
70819: NOP4
70823: PPUSH
70824: NOP4
70828: PUSH
70829: LD_INT 1
70831: ARRAY
70832: PUSH
70833: EMPTY
70834: LIST
70835: PPUSH
70836: NOP4
70840: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
70841: NOP4
70845: PUSH
70846: LD_INT 1
70848: ARRAY
70849: PPUSH
70850: LD_INT 125
70852: PPUSH
70853: NOP4
// end else
70857: GO 71043
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
70859: NOP4
70863: PUSH
70864: NOP4
70868: ARRAY
70869: PUSH
70870: LD_INT 1
70872: ARRAY
70873: PPUSH
70874: NOP4
70878: IFFALSE 70901
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
70880: NOP4
70884: PUSH
70885: NOP4
70889: ARRAY
70890: PUSH
70891: LD_INT 1
70893: ARRAY
70894: PPUSH
70895: NOP4
70899: GO 71043
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
70901: NOP4
70905: PUSH
70906: NOP4
70910: ARRAY
70911: PUSH
70912: LD_INT 1
70914: ARRAY
70915: PPUSH
70916: NOP4
70920: NOT
70921: PUSH
70922: NOP4
70926: PUSH
70927: NOP4
70931: ARRAY
70932: PUSH
70933: LD_INT 1
70935: ARRAY
70936: PPUSH
70937: NOP4
70941: PUSH
70942: NOP4
70946: ARRAY
70947: PUSH
70948: LD_INT 1
70950: ARRAY
70951: PUSH
70952: LD_INT 1
70954: ARRAY
70955: PPUSH
70956: NOP4
70960: PUSH
70961: NOP4
70965: ARRAY
70966: PUSH
70967: LD_INT 1
70969: ARRAY
70970: PUSH
70971: LD_INT 2
70973: ARRAY
70974: PPUSH
70975: NOP4
70979: PUSH
70980: LD_INT 6
70982: GREATER
70983: AND
70984: IFFALSE 71043
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
70986: NOP4
70990: PUSH
70991: NOP4
70995: ARRAY
70996: PUSH
70997: LD_INT 1
70999: ARRAY
71000: PPUSH
71001: NOP4
71005: PUSH
71006: NOP4
71010: ARRAY
71011: PUSH
71012: LD_INT 1
71014: ARRAY
71015: PUSH
71016: LD_INT 1
71018: ARRAY
71019: PPUSH
71020: NOP4
71024: PUSH
71025: NOP4
71029: ARRAY
71030: PUSH
71031: LD_INT 1
71033: ARRAY
71034: PUSH
71035: LD_INT 2
71037: ARRAY
71038: PPUSH
71039: NOP4
// end ; end ; end ;
71043: GO 70456
71045: POP
71046: POP
// end ;
71047: LD_VAR 0 1
71051: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71052: LD_INT 0
71054: PPUSH
71055: PPUSH
71056: PPUSH
71057: PPUSH
71058: PPUSH
71059: PPUSH
71060: PPUSH
71061: PPUSH
71062: PPUSH
71063: PPUSH
71064: PPUSH
// if not mc_bases then
71065: NOP4
71069: NOT
71070: IFFALSE 71074
// exit ;
71072: GO 72014
// for i = 1 to mc_bases do
71074: NOP4
71078: PUSH
71079: DOUBLE
71080: LD_INT 1
71082: DEC
71083: ST_TO_ADDR
71084: NOP4
71088: PUSH
71089: FOR_TO
71090: IFFALSE 72012
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71092: NOP4
71096: PUSH
71097: NOP4
71101: ARRAY
71102: NOT
71103: PUSH
71104: NOP4
71108: PUSH
71109: NOP4
71113: ARRAY
71114: OR
71115: IFFALSE 71119
// continue ;
71117: GO 71089
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71119: NOP4
71123: PUSH
71124: NOP4
71128: PUSH
71129: NOP4
71133: ARRAY
71134: PUSH
71135: LD_INT 1
71137: ARRAY
71138: PPUSH
71139: NOP4
71143: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71144: NOP4
71148: PUSH
71149: LD_INT 3
71151: EQUAL
71152: PUSH
71153: NOP4
71157: PUSH
71158: NOP4
71162: ARRAY
71163: PUSH
71164: NOP4
71168: PUSH
71169: NOP4
71173: ARRAY
71174: UNION
71175: PPUSH
71176: LD_INT 33
71178: PUSH
71179: LD_INT 2
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PPUSH
71186: NOP4
71190: NOT
71191: OR
71192: IFFALSE 71196
// continue ;
71194: GO 71089
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71196: NOP4
71200: PUSH
71201: NOP4
71205: PUSH
71206: NOP4
71210: ARRAY
71211: PPUSH
71212: LD_INT 30
71214: PUSH
71215: LD_INT 36
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PPUSH
71222: NOP4
71226: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71227: NOP4
71231: PUSH
71232: NOP4
71236: PUSH
71237: NOP4
71241: ARRAY
71242: PPUSH
71243: LD_INT 34
71245: PUSH
71246: LD_INT 31
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PPUSH
71253: NOP4
71257: ST_TO_ADDR
// if not cts and not mcts then
71258: NOP4
71262: NOT
71263: PUSH
71264: NOP4
71268: NOT
71269: AND
71270: IFFALSE 71274
// continue ;
71272: GO 71089
// x := cts ;
71274: NOP4
71278: PUSH
71279: NOP4
71283: ST_TO_ADDR
// if not x then
71284: NOP4
71288: NOT
71289: IFFALSE 71301
// x := mcts ;
71291: NOP4
71295: PUSH
71296: NOP4
71300: ST_TO_ADDR
// if not x then
71301: NOP4
71305: NOT
71306: IFFALSE 71310
// continue ;
71308: GO 71089
// if mc_remote_driver [ i ] then
71310: NOP4
71314: PUSH
71315: NOP4
71319: ARRAY
71320: IFFALSE 71707
// for j in mc_remote_driver [ i ] do
71322: NOP4
71326: PUSH
71327: NOP4
71331: PUSH
71332: NOP4
71336: ARRAY
71337: PUSH
71338: FOR_IN
71339: IFFALSE 71705
// begin if GetClass ( j ) <> 3 then
71341: NOP4
71345: PPUSH
71346: NOP4
71350: PUSH
71351: LD_INT 3
71353: NONEQUAL
71354: IFFALSE 71407
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71356: NOP4
71360: PUSH
71361: NOP4
71365: PPUSH
71366: NOP4
71370: PPUSH
71371: NOP4
71375: PUSH
71376: NOP4
71380: ARRAY
71381: PUSH
71382: NOP4
71386: DIFF
71387: PPUSH
71388: NOP4
71392: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71393: NOP4
71397: PPUSH
71398: LD_INT 0
71400: PPUSH
71401: NOP4
// continue ;
71405: GO 71338
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71407: NOP4
71411: PUSH
71412: NOP4
71416: ARRAY
71417: PPUSH
71418: LD_INT 34
71420: PUSH
71421: LD_INT 31
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 58
71430: PUSH
71431: EMPTY
71432: LIST
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PPUSH
71438: NOP4
71442: PUSH
71443: NOP4
71447: PPUSH
71448: NOP4
71452: NOT
71453: AND
71454: IFFALSE 71525
// begin if IsInUnit ( j ) then
71456: NOP4
71460: PPUSH
71461: NOP4
71465: IFFALSE 71476
// ComExitBuilding ( j ) ;
71467: NOP4
71471: PPUSH
71472: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
71476: NOP4
71480: PPUSH
71481: NOP4
71485: PUSH
71486: NOP4
71490: ARRAY
71491: PPUSH
71492: LD_INT 34
71494: PUSH
71495: LD_INT 31
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 58
71504: PUSH
71505: EMPTY
71506: LIST
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PPUSH
71512: NOP4
71516: PUSH
71517: LD_INT 1
71519: ARRAY
71520: PPUSH
71521: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
71525: NOP4
71529: PPUSH
71530: NOP4
71534: NOT
71535: PUSH
71536: NOP4
71540: PPUSH
71541: NOP4
71545: PPUSH
71546: NOP4
71550: PUSH
71551: LD_INT 36
71553: NONEQUAL
71554: PUSH
71555: NOP4
71559: PPUSH
71560: NOP4
71564: NOT
71565: AND
71566: OR
71567: IFFALSE 71703
// begin if IsInUnit ( j ) then
71569: NOP4
71573: PPUSH
71574: NOP4
71578: IFFALSE 71589
// ComExitBuilding ( j ) ;
71580: NOP4
71584: PPUSH
71585: NOP4
// ct := 0 ;
71589: NOP4
71593: PUSH
71594: LD_INT 0
71596: ST_TO_ADDR
// for k in x do
71597: NOP4
71601: PUSH
71602: NOP4
71606: PUSH
71607: FOR_IN
71608: IFFALSE 71681
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
71610: NOP4
71614: PPUSH
71615: NOP4
71619: PUSH
71620: LD_INT 31
71622: EQUAL
71623: PUSH
71624: NOP4
71628: PPUSH
71629: NOP4
71633: NOT
71634: AND
71635: PUSH
71636: NOP4
71640: PPUSH
71641: NOP4
71645: PUSH
71646: LD_INT 36
71648: EQUAL
71649: PUSH
71650: NOP4
71654: PPUSH
71655: NOP4
71659: PUSH
71660: LD_INT 3
71662: LESS
71663: AND
71664: OR
71665: IFFALSE 71679
// begin ct := k ;
71667: NOP4
71671: PUSH
71672: NOP4
71676: ST_TO_ADDR
// break ;
71677: GO 71681
// end ;
71679: GO 71607
71681: POP
71682: POP
// if ct then
71683: NOP4
71687: IFFALSE 71703
// ComEnterUnit ( j , ct ) ;
71689: NOP4
71693: PPUSH
71694: NOP4
71698: PPUSH
71699: NOP4
// end ; end ;
71703: GO 71338
71705: POP
71706: POP
// places := 0 ;
71707: NOP4
71711: PUSH
71712: LD_INT 0
71714: ST_TO_ADDR
// for j = 1 to x do
71715: NOP4
71719: PUSH
71720: DOUBLE
71721: LD_INT 1
71723: DEC
71724: ST_TO_ADDR
71725: NOP4
71729: PUSH
71730: FOR_TO
71731: IFFALSE 71807
// if GetWeapon ( x [ j ] ) = ar_control_tower then
71733: NOP4
71737: PUSH
71738: NOP4
71742: ARRAY
71743: PPUSH
71744: NOP4
71748: PUSH
71749: LD_INT 31
71751: EQUAL
71752: IFFALSE 71770
// places := places + 1 else
71754: NOP4
71758: PUSH
71759: NOP4
71763: PUSH
71764: LD_INT 1
71766: PLUS
71767: ST_TO_ADDR
71768: GO 71805
// if GetBType ( x [ j ] ) = b_control_tower then
71770: NOP4
71774: PUSH
71775: NOP4
71779: ARRAY
71780: PPUSH
71781: NOP4
71785: PUSH
71786: LD_INT 36
71788: EQUAL
71789: IFFALSE 71805
// places := places + 3 ;
71791: NOP4
71795: PUSH
71796: NOP4
71800: PUSH
71801: LD_INT 3
71803: PLUS
71804: ST_TO_ADDR
71805: GO 71730
71807: POP
71808: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
71809: NOP4
71813: PUSH
71814: LD_INT 0
71816: EQUAL
71817: PUSH
71818: NOP4
71822: PUSH
71823: NOP4
71827: PUSH
71828: NOP4
71832: ARRAY
71833: LESSEQUAL
71834: OR
71835: IFFALSE 71839
// continue ;
71837: GO 71089
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
71839: NOP4
71843: PUSH
71844: NOP4
71848: PUSH
71849: NOP4
71853: ARRAY
71854: PPUSH
71855: LD_INT 25
71857: PUSH
71858: LD_INT 3
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PPUSH
71865: NOP4
71869: PUSH
71870: NOP4
71874: PUSH
71875: NOP4
71879: ARRAY
71880: DIFF
71881: PPUSH
71882: LD_INT 3
71884: PPUSH
71885: NOP4
71889: ST_TO_ADDR
// for j in tmp do
71890: NOP4
71894: PUSH
71895: NOP4
71899: PUSH
71900: FOR_IN
71901: IFFALSE 71936
// if GetTag ( j ) > 0 then
71903: NOP4
71907: PPUSH
71908: NOP4
71912: PUSH
71913: LD_INT 0
71915: GREATER
71916: IFFALSE 71934
// tmp := tmp diff j ;
71918: NOP4
71922: PUSH
71923: NOP4
71927: PUSH
71928: NOP4
71932: DIFF
71933: ST_TO_ADDR
71934: GO 71900
71936: POP
71937: POP
// if not tmp then
71938: NOP4
71942: NOT
71943: IFFALSE 71947
// continue ;
71945: GO 71089
// if places then
71947: NOP4
71951: IFFALSE 72010
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
71953: NOP4
71957: PUSH
71958: NOP4
71962: PPUSH
71963: NOP4
71967: PPUSH
71968: NOP4
71972: PUSH
71973: NOP4
71977: ARRAY
71978: PUSH
71979: NOP4
71983: PUSH
71984: LD_INT 1
71986: ARRAY
71987: UNION
71988: PPUSH
71989: NOP4
71993: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
71994: NOP4
71998: PUSH
71999: LD_INT 1
72001: ARRAY
72002: PPUSH
72003: LD_INT 126
72005: PPUSH
72006: NOP4
// end ; end ;
72010: GO 71089
72012: POP
72013: POP
// end ;
72014: LD_VAR 0 1
72018: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72019: LD_INT 0
72021: PPUSH
72022: PPUSH
72023: PPUSH
72024: PPUSH
72025: PPUSH
72026: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72027: NOP4
72031: NOT
72032: PUSH
72033: NOP4
72037: NOT
72038: OR
72039: PUSH
72040: NOP4
72044: NOT
72045: OR
72046: PUSH
72047: NOP4
72051: PUSH
72052: LD_INT 1
72054: PUSH
72055: LD_INT 2
72057: PUSH
72058: LD_INT 3
72060: PUSH
72061: LD_INT 4
72063: PUSH
72064: LD_INT 5
72066: PUSH
72067: LD_INT 8
72069: PUSH
72070: LD_INT 9
72072: PUSH
72073: LD_INT 15
72075: PUSH
72076: LD_INT 16
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: IN
72090: NOT
72091: OR
72092: IFFALSE 72096
// exit ;
72094: GO 72996
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72096: NOP4
72100: PUSH
72101: NOP4
72105: PPUSH
72106: LD_INT 21
72108: PUSH
72109: LD_INT 3
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 24
72118: PUSH
72119: LD_INT 250
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PPUSH
72130: NOP4
72134: ST_TO_ADDR
// case class of 1 , 15 :
72135: NOP4
72139: PUSH
72140: LD_INT 1
72142: DOUBLE
72143: EQUAL
72144: IFTRUE 72154
72146: LD_INT 15
72148: DOUBLE
72149: EQUAL
72150: IFTRUE 72154
72152: GO 72239
72154: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72155: NOP4
72159: PUSH
72160: NOP4
72164: PPUSH
72165: LD_INT 2
72167: PUSH
72168: LD_INT 30
72170: PUSH
72171: LD_INT 32
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 30
72180: PUSH
72181: LD_INT 31
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: LIST
72192: PPUSH
72193: NOP4
72197: PUSH
72198: NOP4
72202: PPUSH
72203: LD_INT 2
72205: PUSH
72206: LD_INT 30
72208: PUSH
72209: LD_INT 4
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 30
72218: PUSH
72219: LD_INT 5
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: PPUSH
72231: NOP4
72235: ADD
72236: ST_TO_ADDR
72237: GO 72485
72239: LD_INT 2
72241: DOUBLE
72242: EQUAL
72243: IFTRUE 72253
72245: LD_INT 16
72247: DOUBLE
72248: EQUAL
72249: IFTRUE 72253
72251: GO 72299
72253: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72254: NOP4
72258: PUSH
72259: NOP4
72263: PPUSH
72264: LD_INT 2
72266: PUSH
72267: LD_INT 30
72269: PUSH
72270: LD_INT 0
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 30
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: LIST
72291: PPUSH
72292: NOP4
72296: ST_TO_ADDR
72297: GO 72485
72299: LD_INT 3
72301: DOUBLE
72302: EQUAL
72303: IFTRUE 72307
72305: GO 72353
72307: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72308: NOP4
72312: PUSH
72313: NOP4
72317: PPUSH
72318: LD_INT 2
72320: PUSH
72321: LD_INT 30
72323: PUSH
72324: LD_INT 2
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 30
72333: PUSH
72334: LD_INT 3
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: LIST
72345: PPUSH
72346: NOP4
72350: ST_TO_ADDR
72351: GO 72485
72353: LD_INT 4
72355: DOUBLE
72356: EQUAL
72357: IFTRUE 72361
72359: GO 72418
72361: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72362: NOP4
72366: PUSH
72367: NOP4
72371: PPUSH
72372: LD_INT 2
72374: PUSH
72375: LD_INT 30
72377: PUSH
72378: LD_INT 6
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 30
72387: PUSH
72388: LD_INT 7
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 30
72397: PUSH
72398: LD_INT 8
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: PPUSH
72411: NOP4
72415: ST_TO_ADDR
72416: GO 72485
72418: LD_INT 5
72420: DOUBLE
72421: EQUAL
72422: IFTRUE 72438
72424: LD_INT 8
72426: DOUBLE
72427: EQUAL
72428: IFTRUE 72438
72430: LD_INT 9
72432: DOUBLE
72433: EQUAL
72434: IFTRUE 72438
72436: GO 72484
72438: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72439: NOP4
72443: PUSH
72444: NOP4
72448: PPUSH
72449: LD_INT 2
72451: PUSH
72452: LD_INT 30
72454: PUSH
72455: LD_INT 4
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: LD_INT 30
72464: PUSH
72465: LD_INT 5
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: LIST
72476: PPUSH
72477: NOP4
72481: ST_TO_ADDR
72482: GO 72485
72484: POP
// if not tmp then
72485: NOP4
72489: NOT
72490: IFFALSE 72494
// exit ;
72492: GO 72996
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
72494: NOP4
72498: PUSH
72499: LD_INT 1
72501: PUSH
72502: LD_INT 15
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: IN
72509: PUSH
72510: NOP4
72514: PUSH
72515: NOP4
72519: ARRAY
72520: AND
72521: IFFALSE 72677
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
72523: NOP4
72527: PUSH
72528: NOP4
72532: PUSH
72533: NOP4
72537: ARRAY
72538: PUSH
72539: LD_INT 1
72541: ARRAY
72542: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
72543: NOP4
72547: PUSH
72548: NOP4
72552: PUSH
72553: NOP4
72557: ARRAY
72558: IN
72559: NOT
72560: IFFALSE 72675
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
72562: NOP4
72566: PUSH
72567: NOP4
72571: PPUSH
72572: NOP4
72576: PUSH
72577: NOP4
72581: PUSH
72582: NOP4
72586: ARRAY
72587: PUSH
72588: LD_INT 1
72590: PLUS
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PPUSH
72596: NOP4
72600: PPUSH
72601: NOP4
72605: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
72606: NOP4
72610: PUSH
72611: NOP4
72615: PPUSH
72616: NOP4
72620: PPUSH
72621: NOP4
72625: PUSH
72626: NOP4
72630: ARRAY
72631: PUSH
72632: NOP4
72636: DIFF
72637: PPUSH
72638: NOP4
72642: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
72643: NOP4
72647: PPUSH
72648: NOP4
72652: PUSH
72653: NOP4
72657: ARRAY
72658: PUSH
72659: NOP4
72663: PUSH
72664: NOP4
72668: ARRAY
72669: ARRAY
72670: PPUSH
72671: NOP4
// end ; exit ;
72675: GO 72996
// end ; if tmp > 1 then
72677: NOP4
72681: PUSH
72682: LD_INT 1
72684: GREATER
72685: IFFALSE 72789
// for i = 2 to tmp do
72687: NOP4
72691: PUSH
72692: DOUBLE
72693: LD_INT 2
72695: DEC
72696: ST_TO_ADDR
72697: NOP4
72701: PUSH
72702: FOR_TO
72703: IFFALSE 72787
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
72705: NOP4
72709: PUSH
72710: NOP4
72714: ARRAY
72715: PPUSH
72716: NOP4
72720: PUSH
72721: LD_INT 6
72723: EQUAL
72724: IFFALSE 72785
// begin x := tmp [ i ] ;
72726: NOP4
72730: PUSH
72731: NOP4
72735: PUSH
72736: NOP4
72740: ARRAY
72741: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
72742: NOP4
72746: PUSH
72747: NOP4
72751: PPUSH
72752: NOP4
72756: PPUSH
72757: NOP4
72761: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
72762: NOP4
72766: PUSH
72767: NOP4
72771: PPUSH
72772: LD_INT 1
72774: PPUSH
72775: NOP4
72779: PPUSH
72780: NOP4
72784: ST_TO_ADDR
// end ;
72785: GO 72702
72787: POP
72788: POP
// for i in tmp do
72789: NOP4
72793: PUSH
72794: NOP4
72798: PUSH
72799: FOR_IN
72800: IFFALSE 72869
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
72802: NOP4
72806: PPUSH
72807: NOP4
72811: PUSH
72812: LD_INT 6
72814: LESS
72815: PUSH
72816: NOP4
72820: PPUSH
72821: NOP4
72825: PUSH
72826: LD_INT 31
72828: PUSH
72829: LD_INT 32
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: IN
72836: NOT
72837: AND
72838: PUSH
72839: NOP4
72843: PPUSH
72844: NOP4
72848: PUSH
72849: LD_INT 0
72851: EQUAL
72852: OR
72853: IFFALSE 72867
// begin j := i ;
72855: NOP4
72859: PUSH
72860: NOP4
72864: ST_TO_ADDR
// break ;
72865: GO 72869
// end ; end ;
72867: GO 72799
72869: POP
72870: POP
// if j then
72871: NOP4
72875: IFFALSE 72893
// ComEnterUnit ( unit , j ) else
72877: NOP4
72881: PPUSH
72882: NOP4
72886: PPUSH
72887: NOP4
72891: GO 72996
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72893: NOP4
72897: PUSH
72898: NOP4
72902: PPUSH
72903: LD_INT 2
72905: PUSH
72906: LD_INT 30
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 30
72918: PUSH
72919: LD_INT 1
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: LIST
72930: PPUSH
72931: NOP4
72935: ST_TO_ADDR
// if depot then
72936: NOP4
72940: IFFALSE 72996
// begin depot := NearestUnitToUnit ( depot , unit ) ;
72942: NOP4
72946: PUSH
72947: NOP4
72951: PPUSH
72952: NOP4
72956: PPUSH
72957: NOP4
72961: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
72962: NOP4
72966: PPUSH
72967: NOP4
72971: PPUSH
72972: NOP4
72976: PUSH
72977: LD_INT 10
72979: GREATER
72980: IFFALSE 72996
// ComStandNearbyBuilding ( unit , depot ) ;
72982: NOP4
72986: PPUSH
72987: NOP4
72991: PPUSH
72992: NOP4
// end ; end ; end ;
72996: LD_VAR 0 5
73000: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73001: LD_INT 0
73003: PPUSH
73004: PPUSH
73005: PPUSH
73006: PPUSH
// if not mc_bases then
73007: NOP4
73011: NOT
73012: IFFALSE 73016
// exit ;
73014: GO 73255
// for i = 1 to mc_bases do
73016: NOP4
73020: PUSH
73021: DOUBLE
73022: LD_INT 1
73024: DEC
73025: ST_TO_ADDR
73026: NOP4
73030: PUSH
73031: FOR_TO
73032: IFFALSE 73253
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73034: NOP4
73038: PUSH
73039: NOP4
73043: PUSH
73044: NOP4
73048: ARRAY
73049: PPUSH
73050: LD_INT 21
73052: PUSH
73053: LD_INT 1
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PPUSH
73060: NOP4
73064: PUSH
73065: NOP4
73069: PUSH
73070: NOP4
73074: ARRAY
73075: UNION
73076: ST_TO_ADDR
// if not tmp then
73077: NOP4
73081: NOT
73082: IFFALSE 73086
// continue ;
73084: GO 73031
// for j in tmp do
73086: NOP4
73090: PUSH
73091: NOP4
73095: PUSH
73096: FOR_IN
73097: IFFALSE 73249
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73099: NOP4
73103: PPUSH
73104: NOP4
73108: NOT
73109: PUSH
73110: NOP4
73114: PPUSH
73115: NOP4
73119: NOT
73120: AND
73121: PUSH
73122: NOP4
73126: PPUSH
73127: NOP4
73131: NOT
73132: AND
73133: PUSH
73134: NOP4
73138: PPUSH
73139: NOP4
73143: NOT
73144: AND
73145: PUSH
73146: NOP4
73150: PUSH
73151: NOP4
73155: PUSH
73156: NOP4
73160: ARRAY
73161: PUSH
73162: LD_INT 1
73164: ARRAY
73165: IN
73166: NOT
73167: AND
73168: PUSH
73169: NOP4
73173: PUSH
73174: NOP4
73178: PUSH
73179: NOP4
73183: ARRAY
73184: PUSH
73185: LD_INT 2
73187: ARRAY
73188: IN
73189: NOT
73190: AND
73191: PUSH
73192: NOP4
73196: PUSH
73197: NOP4
73201: PUSH
73202: NOP4
73206: ARRAY
73207: IN
73208: NOT
73209: AND
73210: IFFALSE 73247
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73212: NOP4
73216: PPUSH
73217: NOP4
73221: PUSH
73222: NOP4
73226: ARRAY
73227: PPUSH
73228: NOP4
73232: PPUSH
73233: NOP4
73237: PPUSH
73238: NOP4
73242: PPUSH
73243: NOP4
// end ;
73247: GO 73096
73249: POP
73250: POP
// end ;
73251: GO 73031
73253: POP
73254: POP
// end ;
73255: LD_VAR 0 1
73259: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73260: LD_INT 0
73262: PPUSH
73263: PPUSH
73264: PPUSH
73265: PPUSH
73266: PPUSH
73267: PPUSH
// if not mc_bases [ base ] then
73268: NOP4
73272: PUSH
73273: NOP4
73277: ARRAY
73278: NOT
73279: IFFALSE 73283
// exit ;
73281: GO 73465
// tmp := [ ] ;
73283: NOP4
73287: PUSH
73288: EMPTY
73289: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73290: NOP4
73294: PUSH
73295: NOP4
73299: PPUSH
73300: LD_INT 0
73302: PPUSH
73303: NOP4
73307: ST_TO_ADDR
// if not list then
73308: NOP4
73312: NOT
73313: IFFALSE 73317
// exit ;
73315: GO 73465
// for i = 1 to amount do
73317: NOP4
73321: PUSH
73322: DOUBLE
73323: LD_INT 1
73325: DEC
73326: ST_TO_ADDR
73327: NOP4
73331: PUSH
73332: FOR_TO
73333: IFFALSE 73413
// begin x := rand ( 1 , list [ 1 ] ) ;
73335: NOP4
73339: PUSH
73340: LD_INT 1
73342: PPUSH
73343: NOP4
73347: PUSH
73348: LD_INT 1
73350: ARRAY
73351: PPUSH
73352: NOP4
73356: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73357: NOP4
73361: PUSH
73362: NOP4
73366: PPUSH
73367: NOP4
73371: PPUSH
73372: NOP4
73376: PUSH
73377: LD_INT 1
73379: ARRAY
73380: PUSH
73381: NOP4
73385: ARRAY
73386: PUSH
73387: NOP4
73391: PUSH
73392: LD_INT 2
73394: ARRAY
73395: PUSH
73396: NOP4
73400: ARRAY
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PPUSH
73406: NOP4
73410: ST_TO_ADDR
// end ;
73411: GO 73332
73413: POP
73414: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73415: NOP4
73419: PUSH
73420: NOP4
73424: PPUSH
73425: NOP4
73429: PPUSH
73430: NOP4
73434: PPUSH
73435: NOP4
73439: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73440: NOP4
73444: PUSH
73445: NOP4
73449: PPUSH
73450: NOP4
73454: PPUSH
73455: NOP4
73459: PPUSH
73460: NOP4
73464: ST_TO_ADDR
// end ;
73465: LD_VAR 0 4
73469: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
73470: LD_INT 0
73472: PPUSH
// if not mc_bases [ base ] then
73473: NOP4
73477: PUSH
73478: NOP4
73482: ARRAY
73483: NOT
73484: IFFALSE 73488
// exit ;
73486: GO 73513
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
73488: NOP4
73492: PUSH
73493: NOP4
73497: PPUSH
73498: NOP4
73502: PPUSH
73503: NOP4
73507: PPUSH
73508: NOP4
73512: ST_TO_ADDR
// end ;
73513: LD_VAR 0 3
73517: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
73518: LD_INT 0
73520: PPUSH
// if not mc_bases [ base ] then
73521: NOP4
73525: PUSH
73526: NOP4
73530: ARRAY
73531: NOT
73532: IFFALSE 73536
// exit ;
73534: GO 73573
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
73536: NOP4
73540: PUSH
73541: NOP4
73545: PPUSH
73546: NOP4
73550: PPUSH
73551: NOP4
73555: PUSH
73556: NOP4
73560: ARRAY
73561: PUSH
73562: NOP4
73566: UNION
73567: PPUSH
73568: NOP4
73572: ST_TO_ADDR
// end ;
73573: LD_VAR 0 3
73577: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
73578: LD_INT 0
73580: PPUSH
// if not mc_bases [ base ] then
73581: NOP4
73585: PUSH
73586: NOP4
73590: ARRAY
73591: NOT
73592: IFFALSE 73596
// exit ;
73594: GO 73621
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
73596: NOP4
73600: PUSH
73601: NOP4
73605: PPUSH
73606: NOP4
73610: PPUSH
73611: NOP4
73615: PPUSH
73616: NOP4
73620: ST_TO_ADDR
// end ;
73621: LD_VAR 0 3
73625: RET
// export function MC_InsertProduceList ( base , components ) ; begin
73626: LD_INT 0
73628: PPUSH
// if not mc_bases [ base ] then
73629: NOP4
73633: PUSH
73634: NOP4
73638: ARRAY
73639: NOT
73640: IFFALSE 73644
// exit ;
73642: GO 73681
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
73644: NOP4
73648: PUSH
73649: NOP4
73653: PPUSH
73654: NOP4
73658: PPUSH
73659: NOP4
73663: PUSH
73664: NOP4
73668: ARRAY
73669: PUSH
73670: NOP4
73674: ADD
73675: PPUSH
73676: NOP4
73680: ST_TO_ADDR
// end ;
73681: LD_VAR 0 3
73685: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
73686: LD_INT 0
73688: PPUSH
// if not mc_bases [ base ] then
73689: NOP4
73693: PUSH
73694: NOP4
73698: ARRAY
73699: NOT
73700: IFFALSE 73704
// exit ;
73702: GO 73758
// mc_defender := Replace ( mc_defender , base , deflist ) ;
73704: NOP4
73708: PUSH
73709: NOP4
73713: PPUSH
73714: NOP4
73718: PPUSH
73719: NOP4
73723: PPUSH
73724: NOP4
73728: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
73729: NOP4
73733: PUSH
73734: NOP4
73738: PPUSH
73739: NOP4
73743: PPUSH
73744: NOP4
73748: PUSH
73749: LD_INT 0
73751: PLUS
73752: PPUSH
73753: NOP4
73757: ST_TO_ADDR
// end ;
73758: LD_VAR 0 3
73762: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
73763: LD_INT 0
73765: PPUSH
// if not mc_bases [ base ] then
73766: NOP4
73770: PUSH
73771: NOP4
73775: ARRAY
73776: NOT
73777: IFFALSE 73781
// exit ;
73779: GO 73806
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
73781: NOP4
73785: PUSH
73786: NOP4
73790: PPUSH
73791: NOP4
73795: PPUSH
73796: NOP4
73800: PPUSH
73801: NOP4
73805: ST_TO_ADDR
// end ;
73806: LD_VAR 0 3
73810: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
73811: LD_INT 0
73813: PPUSH
73814: PPUSH
73815: PPUSH
73816: PPUSH
// if not mc_bases [ base ] then
73817: NOP4
73821: PUSH
73822: NOP4
73826: ARRAY
73827: NOT
73828: IFFALSE 73832
// exit ;
73830: GO 73897
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
73832: NOP4
73836: PUSH
73837: NOP4
73841: PPUSH
73842: NOP4
73846: PUSH
73847: NOP4
73851: PUSH
73852: NOP4
73856: ARRAY
73857: PUSH
73858: LD_INT 1
73860: PLUS
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PPUSH
73866: NOP4
73870: PUSH
73871: NOP4
73875: PUSH
73876: NOP4
73880: PUSH
73881: NOP4
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: PPUSH
73892: NOP4
73896: ST_TO_ADDR
// end ;
73897: LD_VAR 0 5
73901: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
73902: LD_INT 0
73904: PPUSH
// if not mc_bases [ base ] then
73905: NOP4
73909: PUSH
73910: NOP4
73914: ARRAY
73915: NOT
73916: IFFALSE 73920
// exit ;
73918: GO 73945
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
73920: NOP4
73924: PUSH
73925: NOP4
73929: PPUSH
73930: NOP4
73934: PPUSH
73935: NOP4
73939: PPUSH
73940: NOP4
73944: ST_TO_ADDR
// end ;
73945: LD_VAR 0 3
73949: RET
// export function MC_GetMinesField ( base ) ; begin
73950: LD_INT 0
73952: PPUSH
// result := mc_mines [ base ] ;
73953: NOP4
73957: PUSH
73958: NOP4
73962: PUSH
73963: NOP4
73967: ARRAY
73968: ST_TO_ADDR
// end ;
73969: LD_VAR 0 2
73973: RET
// export function MC_GetProduceList ( base ) ; begin
73974: LD_INT 0
73976: PPUSH
// result := mc_produce [ base ] ;
73977: NOP4
73981: PUSH
73982: NOP4
73986: PUSH
73987: NOP4
73991: ARRAY
73992: ST_TO_ADDR
// end ;
73993: LD_VAR 0 2
73997: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
73998: LD_INT 0
74000: PPUSH
74001: PPUSH
// if not mc_bases then
74002: NOP4
74006: NOT
74007: IFFALSE 74011
// exit ;
74009: GO 74076
// if mc_bases [ base ] then
74011: NOP4
74015: PUSH
74016: NOP4
74020: ARRAY
74021: IFFALSE 74076
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74023: NOP4
74027: PUSH
74028: NOP4
74032: PUSH
74033: NOP4
74037: ARRAY
74038: PPUSH
74039: LD_INT 30
74041: PUSH
74042: NOP4
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PPUSH
74051: NOP4
74055: ST_TO_ADDR
// if result then
74056: NOP4
74060: IFFALSE 74076
// result := result [ 1 ] ;
74062: NOP4
74066: PUSH
74067: NOP4
74071: PUSH
74072: LD_INT 1
74074: ARRAY
74075: ST_TO_ADDR
// end ; end ;
74076: LD_VAR 0 3
74080: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74081: LD_INT 0
74083: PPUSH
74084: PPUSH
// if not mc_bases then
74085: NOP4
74089: NOT
74090: IFFALSE 74094
// exit ;
74092: GO 74139
// if mc_bases [ base ] then
74094: NOP4
74098: PUSH
74099: NOP4
74103: ARRAY
74104: IFFALSE 74139
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74106: NOP4
74110: PUSH
74111: NOP4
74115: PUSH
74116: NOP4
74120: ARRAY
74121: PPUSH
74122: LD_INT 30
74124: PUSH
74125: NOP4
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PPUSH
74134: NOP4
74138: ST_TO_ADDR
// end ;
74139: LD_VAR 0 3
74143: RET
// export function MC_SetTame ( base , area ) ; begin
74144: LD_INT 0
74146: PPUSH
// if not mc_bases or not base then
74147: NOP4
74151: NOT
74152: PUSH
74153: NOP4
74157: NOT
74158: OR
74159: IFFALSE 74163
// exit ;
74161: GO 74188
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74163: NOP4
74167: PUSH
74168: NOP4
74172: PPUSH
74173: NOP4
74177: PPUSH
74178: NOP4
74182: PPUSH
74183: NOP4
74187: ST_TO_ADDR
// end ;
74188: LD_VAR 0 3
74192: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74193: LD_INT 0
74195: PPUSH
74196: PPUSH
// if not mc_bases or not base then
74197: NOP4
74201: NOT
74202: PUSH
74203: NOP4
74207: NOT
74208: OR
74209: IFFALSE 74213
// exit ;
74211: GO 74315
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74213: NOP4
74217: PUSH
74218: NOP4
74222: PUSH
74223: NOP4
74227: ARRAY
74228: PPUSH
74229: LD_INT 30
74231: PUSH
74232: NOP4
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PPUSH
74241: NOP4
74245: ST_TO_ADDR
// if not tmp then
74246: NOP4
74250: NOT
74251: IFFALSE 74255
// exit ;
74253: GO 74315
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74255: NOP4
74259: PUSH
74260: NOP4
74264: PPUSH
74265: NOP4
74269: PPUSH
74270: NOP4
74274: PUSH
74275: NOP4
74279: ARRAY
74280: PPUSH
74281: NOP4
74285: PUSH
74286: NOP4
74290: ARRAY
74291: PUSH
74292: LD_INT 1
74294: PLUS
74295: PPUSH
74296: NOP4
74300: PUSH
74301: LD_INT 1
74303: ARRAY
74304: PPUSH
74305: NOP4
74309: PPUSH
74310: NOP4
74314: ST_TO_ADDR
// end ;
74315: LD_VAR 0 3
74319: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74320: LD_INT 0
74322: PPUSH
74323: PPUSH
// if not mc_bases or not base or not kinds then
74324: NOP4
74328: NOT
74329: PUSH
74330: NOP4
74334: NOT
74335: OR
74336: PUSH
74337: NOP4
74341: NOT
74342: OR
74343: IFFALSE 74347
// exit ;
74345: GO 74408
// for i in kinds do
74347: NOP4
74351: PUSH
74352: NOP4
74356: PUSH
74357: FOR_IN
74358: IFFALSE 74406
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74360: NOP4
74364: PUSH
74365: NOP4
74369: PPUSH
74370: NOP4
74374: PUSH
74375: NOP4
74379: PUSH
74380: NOP4
74384: ARRAY
74385: PUSH
74386: LD_INT 1
74388: PLUS
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PPUSH
74394: NOP4
74398: PPUSH
74399: NOP4
74403: ST_TO_ADDR
74404: GO 74357
74406: POP
74407: POP
// end ;
74408: LD_VAR 0 3
74412: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74413: LD_INT 0
74415: PPUSH
// if not mc_bases or not base or not areas then
74416: NOP4
74420: NOT
74421: PUSH
74422: NOP4
74426: NOT
74427: OR
74428: PUSH
74429: NOP4
74433: NOT
74434: OR
74435: IFFALSE 74439
// exit ;
74437: GO 74464
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74439: NOP4
74443: PUSH
74444: NOP4
74448: PPUSH
74449: NOP4
74453: PPUSH
74454: NOP4
74458: PPUSH
74459: NOP4
74463: ST_TO_ADDR
// end ;
74464: LD_VAR 0 3
74468: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
74469: LD_INT 0
74471: PPUSH
// if not mc_bases or not base or not teleports_exit then
74472: NOP4
74476: NOT
74477: PUSH
74478: NOP4
74482: NOT
74483: OR
74484: PUSH
74485: NOP4
74489: NOT
74490: OR
74491: IFFALSE 74495
// exit ;
74493: GO 74520
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
74495: NOP4
74499: PUSH
74500: NOP4
74504: PPUSH
74505: NOP4
74509: PPUSH
74510: NOP4
74514: PPUSH
74515: NOP4
74519: ST_TO_ADDR
// end ;
74520: LD_VAR 0 3
74524: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
74525: LD_INT 0
74527: PPUSH
74528: PPUSH
74529: PPUSH
// if not mc_bases or not base or not ext_list then
74530: NOP4
74534: NOT
74535: PUSH
74536: NOP4
74540: NOT
74541: OR
74542: PUSH
74543: NOP4
74547: NOT
74548: OR
74549: IFFALSE 74553
// exit ;
74551: GO 74726
// tmp := GetFacExtXYD ( x , y , d ) ;
74553: NOP4
74557: PUSH
74558: NOP4
74562: PPUSH
74563: NOP4
74567: PPUSH
74568: NOP4
74572: PPUSH
74573: NOP4
74577: ST_TO_ADDR
// if not tmp then
74578: NOP4
74582: NOT
74583: IFFALSE 74587
// exit ;
74585: GO 74726
// for i in tmp do
74587: NOP4
74591: PUSH
74592: NOP4
74596: PUSH
74597: FOR_IN
74598: IFFALSE 74724
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
74600: NOP4
74604: PUSH
74605: NOP4
74609: PPUSH
74610: NOP4
74614: PPUSH
74615: NOP4
74619: PUSH
74620: NOP4
74624: ARRAY
74625: PPUSH
74626: NOP4
74630: PUSH
74631: NOP4
74635: ARRAY
74636: PUSH
74637: LD_INT 1
74639: PLUS
74640: PPUSH
74641: NOP4
74645: PUSH
74646: LD_INT 1
74648: ARRAY
74649: PUSH
74650: NOP4
74654: PUSH
74655: LD_INT 1
74657: ARRAY
74658: PUSH
74659: NOP4
74663: PUSH
74664: LD_INT 2
74666: ARRAY
74667: PUSH
74668: NOP4
74672: PUSH
74673: LD_INT 3
74675: ARRAY
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: PPUSH
74683: NOP4
74687: PPUSH
74688: NOP4
74692: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
74693: NOP4
74697: PUSH
74698: NOP4
74702: PPUSH
74703: LD_INT 1
74705: PPUSH
74706: NOP4
74710: ST_TO_ADDR
// if not ext_list then
74711: NOP4
74715: NOT
74716: IFFALSE 74722
// exit ;
74718: POP
74719: POP
74720: GO 74726
// end ;
74722: GO 74597
74724: POP
74725: POP
// end ;
74726: LD_VAR 0 6
74730: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
74731: LD_INT 0
74733: PPUSH
// if not mc_bases or not base or not weapon_list then
74734: NOP4
74738: NOT
74739: PUSH
74740: NOP4
74744: NOT
74745: OR
74746: PUSH
74747: NOP4
74751: NOT
74752: OR
74753: IFFALSE 74757
// exit ;
74755: GO 74782
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
74757: NOP4
74761: PUSH
74762: NOP4
74766: PPUSH
74767: NOP4
74771: PPUSH
74772: NOP4
74776: PPUSH
74777: NOP4
74781: ST_TO_ADDR
// end ;
74782: LD_VAR 0 3
74786: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
74787: LD_INT 0
74789: PPUSH
// if not mc_bases or not base or not tech_list then
74790: NOP4
74794: NOT
74795: PUSH
74796: NOP4
74800: NOT
74801: OR
74802: PUSH
74803: NOP4
74807: NOT
74808: OR
74809: IFFALSE 74813
// exit ;
74811: GO 74838
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
74813: NOP4
74817: PUSH
74818: NOP4
74822: PPUSH
74823: NOP4
74827: PPUSH
74828: NOP4
74832: PPUSH
74833: NOP4
74837: ST_TO_ADDR
// end ;
74838: LD_VAR 0 3
74842: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
74843: LD_INT 0
74845: PPUSH
// if not mc_bases or not parking_area or not base then
74846: NOP4
74850: NOT
74851: PUSH
74852: NOP4
74856: NOT
74857: OR
74858: PUSH
74859: NOP4
74863: NOT
74864: OR
74865: IFFALSE 74869
// exit ;
74867: GO 74894
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
74869: NOP4
74873: PUSH
74874: NOP4
74878: PPUSH
74879: NOP4
74883: PPUSH
74884: NOP4
74888: PPUSH
74889: NOP4
74893: ST_TO_ADDR
// end ;
74894: LD_VAR 0 3
74898: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
74899: LD_INT 0
74901: PPUSH
// if not mc_bases or not base or not scan_area then
74902: NOP4
74906: NOT
74907: PUSH
74908: NOP4
74912: NOT
74913: OR
74914: PUSH
74915: NOP4
74919: NOT
74920: OR
74921: IFFALSE 74925
// exit ;
74923: GO 74950
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
74925: NOP4
74929: PUSH
74930: NOP4
74934: PPUSH
74935: NOP4
74939: PPUSH
74940: NOP4
74944: PPUSH
74945: NOP4
74949: ST_TO_ADDR
// end ;
74950: LD_VAR 0 3
74954: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
74955: LD_INT 0
74957: PPUSH
74958: PPUSH
// if not mc_bases or not base then
74959: NOP4
74963: NOT
74964: PUSH
74965: NOP4
74969: NOT
74970: OR
74971: IFFALSE 74975
// exit ;
74973: GO 75039
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
74975: NOP4
74979: PUSH
74980: LD_INT 1
74982: PUSH
74983: LD_INT 2
74985: PUSH
74986: LD_INT 3
74988: PUSH
74989: LD_INT 4
74991: PUSH
74992: LD_INT 11
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: LIST
75001: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75002: NOP4
75006: PUSH
75007: NOP4
75011: PPUSH
75012: NOP4
75016: PPUSH
75017: NOP4
75021: PUSH
75022: NOP4
75026: ARRAY
75027: PUSH
75028: NOP4
75032: DIFF
75033: PPUSH
75034: NOP4
75038: ST_TO_ADDR
// end ;
75039: LD_VAR 0 2
75043: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75044: LD_INT 0
75046: PPUSH
// result := mc_vehicles [ base ] ;
75047: NOP4
75051: PUSH
75052: NOP4
75056: PUSH
75057: NOP4
75061: ARRAY
75062: ST_TO_ADDR
// if onlyCombat then
75063: NOP4
75067: IFFALSE 75245
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75069: NOP4
75073: PUSH
75074: NOP4
75078: PUSH
75079: NOP4
75083: PPUSH
75084: LD_INT 2
75086: PUSH
75087: LD_INT 34
75089: PUSH
75090: LD_INT 12
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 34
75099: PUSH
75100: LD_INT 51
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 34
75109: PUSH
75110: NOP4
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 34
75121: PUSH
75122: LD_INT 32
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 34
75131: PUSH
75132: LD_INT 13
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 34
75141: PUSH
75142: LD_INT 52
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 34
75151: PUSH
75152: NOP4
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 34
75163: PUSH
75164: LD_INT 14
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 34
75173: PUSH
75174: LD_INT 53
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 34
75183: PUSH
75184: NOP4
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 34
75195: PUSH
75196: LD_INT 31
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 34
75205: PUSH
75206: LD_INT 48
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 34
75215: PUSH
75216: LD_INT 8
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: LIST
75227: LIST
75228: LIST
75229: LIST
75230: LIST
75231: LIST
75232: LIST
75233: LIST
75234: LIST
75235: LIST
75236: LIST
75237: LIST
75238: PPUSH
75239: NOP4
75243: DIFF
75244: ST_TO_ADDR
// end ; end_of_file
75245: LD_VAR 0 3
75249: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75250: LD_INT 0
75252: PPUSH
75253: PPUSH
75254: PPUSH
// if not mc_bases or not skirmish then
75255: NOP4
75259: NOT
75260: PUSH
75261: NOP4
75265: NOT
75266: OR
75267: IFFALSE 75271
// exit ;
75269: GO 75436
// for i = 1 to mc_bases do
75271: NOP4
75275: PUSH
75276: DOUBLE
75277: LD_INT 1
75279: DEC
75280: ST_TO_ADDR
75281: NOP4
75285: PUSH
75286: FOR_TO
75287: IFFALSE 75434
// begin if sci in mc_bases [ i ] then
75289: NOP4
75293: PUSH
75294: NOP4
75298: PUSH
75299: NOP4
75303: ARRAY
75304: IN
75305: IFFALSE 75432
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75307: NOP4
75311: PUSH
75312: NOP4
75316: PPUSH
75317: NOP4
75321: PUSH
75322: NOP4
75326: PUSH
75327: NOP4
75331: ARRAY
75332: PUSH
75333: LD_INT 1
75335: PLUS
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PPUSH
75341: NOP4
75345: PPUSH
75346: NOP4
75350: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75351: NOP4
75355: PUSH
75356: NOP4
75360: PUSH
75361: NOP4
75365: ARRAY
75366: PPUSH
75367: LD_INT 2
75369: PUSH
75370: LD_INT 30
75372: PUSH
75373: LD_INT 0
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 30
75382: PUSH
75383: LD_INT 1
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: LIST
75394: PPUSH
75395: NOP4
75399: PPUSH
75400: NOP4
75404: PPUSH
75405: NOP4
75409: ST_TO_ADDR
// if tmp then
75410: NOP4
75414: IFFALSE 75430
// ComStandNearbyBuilding ( ape , tmp ) ;
75416: NOP4
75420: PPUSH
75421: NOP4
75425: PPUSH
75426: NOP4
// break ;
75430: GO 75434
// end ; end ;
75432: GO 75286
75434: POP
75435: POP
// end ;
75436: LD_VAR 0 3
75440: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75441: LD_INT 0
75443: PPUSH
75444: PPUSH
75445: PPUSH
// if not mc_bases or not skirmish then
75446: NOP4
75450: NOT
75451: PUSH
75452: NOP4
75456: NOT
75457: OR
75458: IFFALSE 75462
// exit ;
75460: GO 75551
// for i = 1 to mc_bases do
75462: NOP4
75466: PUSH
75467: DOUBLE
75468: LD_INT 1
75470: DEC
75471: ST_TO_ADDR
75472: NOP4
75476: PUSH
75477: FOR_TO
75478: IFFALSE 75549
// begin if building in mc_busy_turret_list [ i ] then
75480: NOP4
75484: PUSH
75485: NOP4
75489: PUSH
75490: NOP4
75494: ARRAY
75495: IN
75496: IFFALSE 75547
// begin tmp := mc_busy_turret_list [ i ] diff building ;
75498: NOP4
75502: PUSH
75503: NOP4
75507: PUSH
75508: NOP4
75512: ARRAY
75513: PUSH
75514: NOP4
75518: DIFF
75519: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
75520: NOP4
75524: PUSH
75525: NOP4
75529: PPUSH
75530: NOP4
75534: PPUSH
75535: NOP4
75539: PPUSH
75540: NOP4
75544: ST_TO_ADDR
// break ;
75545: GO 75549
// end ; end ;
75547: GO 75477
75549: POP
75550: POP
// end ;
75551: LD_VAR 0 3
75555: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
75556: LD_INT 0
75558: PPUSH
75559: PPUSH
75560: PPUSH
// if not mc_bases or not skirmish then
75561: NOP4
75565: NOT
75566: PUSH
75567: NOP4
75571: NOT
75572: OR
75573: IFFALSE 75577
// exit ;
75575: GO 75776
// for i = 1 to mc_bases do
75577: NOP4
75581: PUSH
75582: DOUBLE
75583: LD_INT 1
75585: DEC
75586: ST_TO_ADDR
75587: NOP4
75591: PUSH
75592: FOR_TO
75593: IFFALSE 75774
// if building in mc_bases [ i ] then
75595: NOP4
75599: PUSH
75600: NOP4
75604: PUSH
75605: NOP4
75609: ARRAY
75610: IN
75611: IFFALSE 75772
// begin tmp := mc_bases [ i ] diff building ;
75613: NOP4
75617: PUSH
75618: NOP4
75622: PUSH
75623: NOP4
75627: ARRAY
75628: PUSH
75629: NOP4
75633: DIFF
75634: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
75635: NOP4
75639: PUSH
75640: NOP4
75644: PPUSH
75645: NOP4
75649: PPUSH
75650: NOP4
75654: PPUSH
75655: NOP4
75659: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
75660: NOP4
75664: PUSH
75665: NOP4
75669: PUSH
75670: NOP4
75674: ARRAY
75675: IN
75676: IFFALSE 75715
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
75678: NOP4
75682: PUSH
75683: NOP4
75687: PPUSH
75688: NOP4
75692: PPUSH
75693: NOP4
75697: PUSH
75698: NOP4
75702: ARRAY
75703: PUSH
75704: NOP4
75708: DIFF
75709: PPUSH
75710: NOP4
75714: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
75715: NOP4
75719: PUSH
75720: NOP4
75724: PUSH
75725: NOP4
75729: ARRAY
75730: IN
75731: IFFALSE 75770
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
75733: NOP4
75737: PUSH
75738: NOP4
75742: PPUSH
75743: NOP4
75747: PPUSH
75748: NOP4
75752: PUSH
75753: NOP4
75757: ARRAY
75758: PUSH
75759: NOP4
75763: DIFF
75764: PPUSH
75765: NOP4
75769: ST_TO_ADDR
// break ;
75770: GO 75774
// end ;
75772: GO 75592
75774: POP
75775: POP
// end ;
75776: LD_VAR 0 4
75780: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
75781: LD_INT 0
75783: PPUSH
75784: PPUSH
75785: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
75786: NOP4
75790: NOT
75791: PUSH
75792: NOP4
75796: NOT
75797: OR
75798: PUSH
75799: NOP4
75803: PUSH
75804: NOP4
75808: IN
75809: NOT
75810: OR
75811: IFFALSE 75815
// exit ;
75813: GO 75938
// for i = 1 to mc_vehicles do
75815: NOP4
75819: PUSH
75820: DOUBLE
75821: LD_INT 1
75823: DEC
75824: ST_TO_ADDR
75825: NOP4
75829: PUSH
75830: FOR_TO
75831: IFFALSE 75936
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
75833: NOP4
75837: PUSH
75838: NOP4
75842: PUSH
75843: NOP4
75847: ARRAY
75848: IN
75849: PUSH
75850: NOP4
75854: PUSH
75855: NOP4
75859: PUSH
75860: NOP4
75864: ARRAY
75865: IN
75866: OR
75867: IFFALSE 75934
// begin tmp := mc_vehicles [ i ] diff old ;
75869: NOP4
75873: PUSH
75874: NOP4
75878: PUSH
75879: NOP4
75883: ARRAY
75884: PUSH
75885: NOP4
75889: DIFF
75890: ST_TO_ADDR
// tmp := tmp diff new ;
75891: NOP4
75895: PUSH
75896: NOP4
75900: PUSH
75901: NOP4
75905: DIFF
75906: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
75907: NOP4
75911: PUSH
75912: NOP4
75916: PPUSH
75917: NOP4
75921: PPUSH
75922: NOP4
75926: PPUSH
75927: NOP4
75931: ST_TO_ADDR
// break ;
75932: GO 75936
// end ;
75934: GO 75830
75936: POP
75937: POP
// end ;
75938: LD_VAR 0 5
75942: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
75943: LD_INT 0
75945: PPUSH
75946: PPUSH
75947: PPUSH
75948: PPUSH
// if not mc_bases or not skirmish then
75949: NOP4
75953: NOT
75954: PUSH
75955: NOP4
75959: NOT
75960: OR
75961: IFFALSE 75965
// exit ;
75963: GO 76357
// side := GetSide ( vehicle ) ;
75965: NOP4
75969: PUSH
75970: NOP4
75974: PPUSH
75975: NOP4
75979: ST_TO_ADDR
// for i = 1 to mc_bases do
75980: NOP4
75984: PUSH
75985: DOUBLE
75986: LD_INT 1
75988: DEC
75989: ST_TO_ADDR
75990: NOP4
75994: PUSH
75995: FOR_TO
75996: IFFALSE 76355
// begin if factory in mc_bases [ i ] then
75998: NOP4
76002: PUSH
76003: NOP4
76007: PUSH
76008: NOP4
76012: ARRAY
76013: IN
76014: IFFALSE 76353
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76016: NOP4
76020: PUSH
76021: NOP4
76025: ARRAY
76026: PUSH
76027: NOP4
76031: PUSH
76032: NOP4
76036: ARRAY
76037: LESS
76038: PUSH
76039: NOP4
76043: PPUSH
76044: NOP4
76048: PUSH
76049: LD_INT 31
76051: PUSH
76052: LD_INT 32
76054: PUSH
76055: LD_INT 51
76057: PUSH
76058: NOP4
76062: PUSH
76063: LD_INT 12
76065: PUSH
76066: LD_INT 30
76068: PUSH
76069: NOP4
76073: PUSH
76074: LD_INT 11
76076: PUSH
76077: LD_INT 53
76079: PUSH
76080: LD_INT 14
76082: PUSH
76083: NOP4
76087: PUSH
76088: LD_INT 29
76090: PUSH
76091: NOP4
76095: PUSH
76096: LD_INT 13
76098: PUSH
76099: LD_INT 52
76101: PUSH
76102: NOP4
76106: PUSH
76107: LD_INT 48
76109: PUSH
76110: LD_INT 8
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: LIST
76117: LIST
76118: LIST
76119: LIST
76120: LIST
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: IN
76133: NOT
76134: AND
76135: IFFALSE 76183
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76137: NOP4
76141: PUSH
76142: NOP4
76146: PPUSH
76147: NOP4
76151: PUSH
76152: NOP4
76156: PUSH
76157: NOP4
76161: ARRAY
76162: PUSH
76163: LD_INT 1
76165: PLUS
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PPUSH
76171: NOP4
76175: PPUSH
76176: NOP4
76180: ST_TO_ADDR
76181: GO 76227
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76183: NOP4
76187: PUSH
76188: NOP4
76192: PPUSH
76193: NOP4
76197: PUSH
76198: NOP4
76202: PUSH
76203: NOP4
76207: ARRAY
76208: PUSH
76209: LD_INT 1
76211: PLUS
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PPUSH
76217: NOP4
76221: PPUSH
76222: NOP4
76226: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76227: NOP4
76231: PPUSH
76232: NOP4
76236: PUSH
76237: LD_INT 2
76239: EQUAL
76240: IFFALSE 76269
// begin repeat wait ( 0 0$3 ) ;
76242: LD_INT 105
76244: PPUSH
76245: NOP4
// Connect ( vehicle ) ;
76249: NOP4
76253: PPUSH
76254: NOP4
// until IsControledBy ( vehicle ) ;
76258: NOP4
76262: PPUSH
76263: NOP4
76267: IFFALSE 76242
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76269: NOP4
76273: PPUSH
76274: NOP4
76278: PUSH
76279: NOP4
76283: ARRAY
76284: PPUSH
76285: NOP4
// if GetControl ( vehicle ) <> control_manual then
76289: NOP4
76293: PPUSH
76294: NOP4
76298: PUSH
76299: LD_INT 1
76301: NONEQUAL
76302: IFFALSE 76306
// break ;
76304: GO 76355
// repeat wait ( 0 0$1 ) ;
76306: LD_INT 35
76308: PPUSH
76309: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76313: NOP4
76317: PPUSH
76318: NOP4
76322: PUSH
76323: NOP4
76327: ARRAY
76328: PPUSH
76329: NOP4
76333: IFFALSE 76306
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76335: NOP4
76339: PPUSH
76340: NOP4
76344: PPUSH
76345: NOP4
// exit ;
76349: POP
76350: POP
76351: GO 76357
// end ; end ;
76353: GO 75995
76355: POP
76356: POP
// end ;
76357: LD_VAR 0 3
76361: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76362: LD_INT 0
76364: PPUSH
76365: PPUSH
76366: PPUSH
76367: PPUSH
// if not mc_bases or not skirmish then
76368: NOP4
76372: NOT
76373: PUSH
76374: NOP4
76378: NOT
76379: OR
76380: IFFALSE 76384
// exit ;
76382: GO 76737
// repeat wait ( 0 0$1 ) ;
76384: LD_INT 35
76386: PPUSH
76387: NOP4
// until GetResourceAmountXY ( x , y ) ;
76391: NOP4
76395: PPUSH
76396: NOP4
76400: PPUSH
76401: NOP4
76405: IFFALSE 76384
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76407: NOP4
76411: PPUSH
76412: NOP4
76416: PPUSH
76417: NOP4
76421: PUSH
76422: LD_INT 4
76424: EQUAL
76425: IFFALSE 76429
// exit ;
76427: GO 76737
// for i = 1 to mc_bases do
76429: NOP4
76433: PUSH
76434: DOUBLE
76435: LD_INT 1
76437: DEC
76438: ST_TO_ADDR
76439: NOP4
76443: PUSH
76444: FOR_TO
76445: IFFALSE 76735
// begin if mc_crates_area [ i ] then
76447: NOP4
76451: PUSH
76452: NOP4
76456: ARRAY
76457: IFFALSE 76568
// for j in mc_crates_area [ i ] do
76459: NOP4
76463: PUSH
76464: NOP4
76468: PUSH
76469: NOP4
76473: ARRAY
76474: PUSH
76475: FOR_IN
76476: IFFALSE 76566
// if InArea ( x , y , j ) then
76478: NOP4
76482: PPUSH
76483: NOP4
76487: PPUSH
76488: NOP4
76492: PPUSH
76493: NOP4
76497: IFFALSE 76564
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76499: NOP4
76503: PUSH
76504: NOP4
76508: PPUSH
76509: NOP4
76513: PUSH
76514: NOP4
76518: PUSH
76519: NOP4
76523: ARRAY
76524: PUSH
76525: LD_INT 1
76527: PLUS
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PPUSH
76533: NOP4
76537: PUSH
76538: NOP4
76542: PUSH
76543: NOP4
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: LIST
76552: PPUSH
76553: NOP4
76557: ST_TO_ADDR
// exit ;
76558: POP
76559: POP
76560: POP
76561: POP
76562: GO 76737
// end ;
76564: GO 76475
76566: POP
76567: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76568: NOP4
76572: PUSH
76573: NOP4
76577: PUSH
76578: NOP4
76582: ARRAY
76583: PPUSH
76584: LD_INT 2
76586: PUSH
76587: LD_INT 30
76589: PUSH
76590: LD_INT 0
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 30
76599: PUSH
76600: LD_INT 1
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: LIST
76611: PPUSH
76612: NOP4
76616: ST_TO_ADDR
// if not depot then
76617: NOP4
76621: NOT
76622: IFFALSE 76626
// continue ;
76624: GO 76444
// for j in depot do
76626: NOP4
76630: PUSH
76631: NOP4
76635: PUSH
76636: FOR_IN
76637: IFFALSE 76731
// if GetDistUnitXY ( j , x , y ) < 30 then
76639: NOP4
76643: PPUSH
76644: NOP4
76648: PPUSH
76649: NOP4
76653: PPUSH
76654: NOP4
76658: PUSH
76659: LD_INT 30
76661: LESS
76662: IFFALSE 76729
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76664: NOP4
76668: PUSH
76669: NOP4
76673: PPUSH
76674: NOP4
76678: PUSH
76679: NOP4
76683: PUSH
76684: NOP4
76688: ARRAY
76689: PUSH
76690: LD_INT 1
76692: PLUS
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PPUSH
76698: NOP4
76702: PUSH
76703: NOP4
76707: PUSH
76708: NOP4
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: LIST
76717: PPUSH
76718: NOP4
76722: ST_TO_ADDR
// exit ;
76723: POP
76724: POP
76725: POP
76726: POP
76727: GO 76737
// end ;
76729: GO 76636
76731: POP
76732: POP
// end ;
76733: GO 76444
76735: POP
76736: POP
// end ;
76737: LD_VAR 0 6
76741: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
76742: LD_INT 0
76744: PPUSH
76745: PPUSH
76746: PPUSH
76747: PPUSH
// if not mc_bases or not skirmish then
76748: NOP4
76752: NOT
76753: PUSH
76754: NOP4
76758: NOT
76759: OR
76760: IFFALSE 76764
// exit ;
76762: GO 77041
// side := GetSide ( lab ) ;
76764: NOP4
76768: PUSH
76769: NOP4
76773: PPUSH
76774: NOP4
76778: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
76779: NOP4
76783: PUSH
76784: NOP4
76788: IN
76789: NOT
76790: PUSH
76791: NOP4
76795: NOT
76796: OR
76797: PUSH
76798: NOP4
76802: NOT
76803: OR
76804: IFFALSE 76808
// exit ;
76806: GO 77041
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
76808: NOP4
76812: PUSH
76813: NOP4
76817: PPUSH
76818: NOP4
76822: PPUSH
76823: NOP4
76827: PUSH
76828: NOP4
76832: ARRAY
76833: PUSH
76834: NOP4
76838: DIFF
76839: PPUSH
76840: NOP4
76844: ST_TO_ADDR
// for i = 1 to mc_bases do
76845: NOP4
76849: PUSH
76850: DOUBLE
76851: LD_INT 1
76853: DEC
76854: ST_TO_ADDR
76855: NOP4
76859: PUSH
76860: FOR_TO
76861: IFFALSE 77039
// begin if lab in mc_bases [ i ] then
76863: NOP4
76867: PUSH
76868: NOP4
76872: PUSH
76873: NOP4
76877: ARRAY
76878: IN
76879: IFFALSE 77037
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
76881: NOP4
76885: PUSH
76886: LD_INT 11
76888: PUSH
76889: LD_INT 4
76891: PUSH
76892: LD_INT 3
76894: PUSH
76895: LD_INT 2
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: IN
76904: PUSH
76905: NOP4
76909: PUSH
76910: NOP4
76914: ARRAY
76915: AND
76916: IFFALSE 77037
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
76918: NOP4
76922: PUSH
76923: NOP4
76927: PUSH
76928: NOP4
76932: ARRAY
76933: PUSH
76934: LD_INT 1
76936: ARRAY
76937: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
76938: NOP4
76942: PUSH
76943: NOP4
76947: PPUSH
76948: NOP4
76952: PPUSH
76953: EMPTY
76954: PPUSH
76955: NOP4
76959: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
76960: NOP4
76964: PPUSH
76965: LD_INT 0
76967: PPUSH
76968: NOP4
// ComExitBuilding ( tmp ) ;
76972: NOP4
76976: PPUSH
76977: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
76981: NOP4
76985: PUSH
76986: NOP4
76990: PPUSH
76991: NOP4
76995: PPUSH
76996: NOP4
77000: PUSH
77001: NOP4
77005: ARRAY
77006: PPUSH
77007: LD_INT 1
77009: PPUSH
77010: NOP4
77014: PPUSH
77015: NOP4
77019: PPUSH
77020: NOP4
77024: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77025: NOP4
77029: PPUSH
77030: LD_INT 112
77032: PPUSH
77033: NOP4
// end ; end ; end ;
77037: GO 76860
77039: POP
77040: POP
// end ;
77041: LD_VAR 0 3
77045: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77046: LD_INT 0
77048: PPUSH
77049: PPUSH
77050: PPUSH
77051: PPUSH
77052: PPUSH
77053: PPUSH
77054: PPUSH
77055: PPUSH
// if not mc_bases or not skirmish then
77056: NOP4
77060: NOT
77061: PUSH
77062: NOP4
77066: NOT
77067: OR
77068: IFFALSE 77072
// exit ;
77070: GO 78443
// for i = 1 to mc_bases do
77072: NOP4
77076: PUSH
77077: DOUBLE
77078: LD_INT 1
77080: DEC
77081: ST_TO_ADDR
77082: NOP4
77086: PUSH
77087: FOR_TO
77088: IFFALSE 78441
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77090: NOP4
77094: PUSH
77095: NOP4
77099: PUSH
77100: NOP4
77104: ARRAY
77105: IN
77106: PUSH
77107: NOP4
77111: PUSH
77112: NOP4
77116: PUSH
77117: NOP4
77121: ARRAY
77122: IN
77123: OR
77124: PUSH
77125: NOP4
77129: PUSH
77130: NOP4
77134: PUSH
77135: NOP4
77139: ARRAY
77140: IN
77141: OR
77142: PUSH
77143: NOP4
77147: PUSH
77148: NOP4
77152: PUSH
77153: NOP4
77157: ARRAY
77158: IN
77159: OR
77160: PUSH
77161: NOP4
77165: PUSH
77166: NOP4
77170: PUSH
77171: NOP4
77175: ARRAY
77176: IN
77177: OR
77178: PUSH
77179: NOP4
77183: PUSH
77184: NOP4
77188: PUSH
77189: NOP4
77193: ARRAY
77194: IN
77195: OR
77196: IFFALSE 78439
// begin if un in mc_ape [ i ] then
77198: NOP4
77202: PUSH
77203: NOP4
77207: PUSH
77208: NOP4
77212: ARRAY
77213: IN
77214: IFFALSE 77253
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77216: NOP4
77220: PUSH
77221: NOP4
77225: PPUSH
77226: NOP4
77230: PPUSH
77231: NOP4
77235: PUSH
77236: NOP4
77240: ARRAY
77241: PUSH
77242: NOP4
77246: DIFF
77247: PPUSH
77248: NOP4
77252: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77253: NOP4
77257: PUSH
77258: NOP4
77262: PUSH
77263: NOP4
77267: ARRAY
77268: IN
77269: IFFALSE 77293
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77271: NOP4
77275: PUSH
77276: NOP4
77280: PPUSH
77281: NOP4
77285: PPUSH
77286: EMPTY
77287: PPUSH
77288: NOP4
77292: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77293: NOP4
77297: PPUSH
77298: NOP4
77302: PUSH
77303: LD_INT 2
77305: EQUAL
77306: PUSH
77307: NOP4
77311: PPUSH
77312: NOP4
77316: PUSH
77317: LD_INT 20
77319: EQUAL
77320: PUSH
77321: NOP4
77325: PUSH
77326: NOP4
77330: PUSH
77331: NOP4
77335: ARRAY
77336: IN
77337: OR
77338: PUSH
77339: NOP4
77343: PPUSH
77344: NOP4
77348: PUSH
77349: LD_INT 12
77351: PUSH
77352: LD_INT 51
77354: PUSH
77355: NOP4
77359: PUSH
77360: LD_INT 32
77362: PUSH
77363: LD_INT 13
77365: PUSH
77366: LD_INT 52
77368: PUSH
77369: LD_INT 31
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: IN
77381: OR
77382: AND
77383: IFFALSE 77691
// begin if un in mc_defender [ i ] then
77385: NOP4
77389: PUSH
77390: NOP4
77394: PUSH
77395: NOP4
77399: ARRAY
77400: IN
77401: IFFALSE 77440
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77403: NOP4
77407: PUSH
77408: NOP4
77412: PPUSH
77413: NOP4
77417: PPUSH
77418: NOP4
77422: PUSH
77423: NOP4
77427: ARRAY
77428: PUSH
77429: NOP4
77433: DIFF
77434: PPUSH
77435: NOP4
77439: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77440: NOP4
77444: PUSH
77445: NOP4
77449: PPUSH
77450: LD_INT 3
77452: PPUSH
77453: NOP4
77457: ST_TO_ADDR
// if fac then
77458: NOP4
77462: IFFALSE 77691
// begin for j in fac do
77464: NOP4
77468: PUSH
77469: NOP4
77473: PUSH
77474: FOR_IN
77475: IFFALSE 77689
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77477: NOP4
77481: PUSH
77482: NOP4
77486: PPUSH
77487: NOP4
77491: PPUSH
77492: NOP4
77496: PPUSH
77497: NOP4
77501: PPUSH
77502: NOP4
77506: PPUSH
77507: NOP4
77511: PPUSH
77512: NOP4
77516: PPUSH
77517: NOP4
77521: PPUSH
77522: NOP4
77526: PPUSH
77527: NOP4
77531: ST_TO_ADDR
// if components then
77532: NOP4
77536: IFFALSE 77687
// begin if GetWeapon ( un ) = ar_control_tower then
77538: NOP4
77542: PPUSH
77543: NOP4
77547: PUSH
77548: LD_INT 31
77550: EQUAL
77551: IFFALSE 77668
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
77553: NOP4
77557: PPUSH
77558: NOP4
77562: PPUSH
77563: LD_INT 0
77565: PPUSH
77566: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
77570: NOP4
77574: PUSH
77575: NOP4
77579: PPUSH
77580: NOP4
77584: PPUSH
77585: NOP4
77589: PUSH
77590: NOP4
77594: ARRAY
77595: PUSH
77596: NOP4
77600: PPUSH
77601: NOP4
77605: DIFF
77606: PPUSH
77607: NOP4
77611: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
77612: NOP4
77616: PUSH
77617: NOP4
77621: PUSH
77622: NOP4
77626: ARRAY
77627: PPUSH
77628: LD_INT 1
77630: PPUSH
77631: NOP4
77635: PPUSH
77636: NOP4
77640: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77641: NOP4
77645: PUSH
77646: NOP4
77650: PPUSH
77651: NOP4
77655: PPUSH
77656: NOP4
77660: PPUSH
77661: NOP4
77665: ST_TO_ADDR
// end else
77666: GO 77685
// MC_InsertProduceList ( i , [ components ] ) ;
77668: NOP4
77672: PPUSH
77673: NOP4
77677: PUSH
77678: EMPTY
77679: LIST
77680: PPUSH
77681: NOP4
// break ;
77685: GO 77689
// end ; end ;
77687: GO 77474
77689: POP
77690: POP
// end ; end ; if GetType ( un ) = unit_building then
77691: NOP4
77695: PPUSH
77696: NOP4
77700: PUSH
77701: LD_INT 3
77703: EQUAL
77704: IFFALSE 78107
// begin btype := GetBType ( un ) ;
77706: NOP4
77710: PUSH
77711: NOP4
77715: PPUSH
77716: NOP4
77720: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
77721: NOP4
77725: PUSH
77726: LD_INT 29
77728: PUSH
77729: LD_INT 30
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: IN
77736: IFFALSE 77809
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
77738: NOP4
77742: PPUSH
77743: NOP4
77747: PPUSH
77748: NOP4
77752: PPUSH
77753: NOP4
77757: PPUSH
77758: NOP4
77762: PPUSH
77763: NOP4
77767: PPUSH
77768: NOP4
77772: NOT
77773: IFFALSE 77809
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
77775: NOP4
77779: PPUSH
77780: NOP4
77784: PPUSH
77785: NOP4
77789: PPUSH
77790: NOP4
77794: PPUSH
77795: NOP4
77799: PPUSH
77800: NOP4
77804: PPUSH
77805: NOP4
// end ; if btype = b_warehouse then
77809: NOP4
77813: PUSH
77814: LD_INT 1
77816: EQUAL
77817: IFFALSE 77835
// begin btype := b_depot ;
77819: NOP4
77823: PUSH
77824: LD_INT 0
77826: ST_TO_ADDR
// pos := 1 ;
77827: NOP4
77831: PUSH
77832: LD_INT 1
77834: ST_TO_ADDR
// end ; if btype = b_factory then
77835: NOP4
77839: PUSH
77840: LD_INT 3
77842: EQUAL
77843: IFFALSE 77861
// begin btype := b_workshop ;
77845: NOP4
77849: PUSH
77850: LD_INT 2
77852: ST_TO_ADDR
// pos := 1 ;
77853: NOP4
77857: PUSH
77858: LD_INT 1
77860: ST_TO_ADDR
// end ; if btype = b_barracks then
77861: NOP4
77865: PUSH
77866: LD_INT 5
77868: EQUAL
77869: IFFALSE 77879
// btype := b_armoury ;
77871: NOP4
77875: PUSH
77876: LD_INT 4
77878: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
77879: NOP4
77883: PUSH
77884: LD_INT 7
77886: PUSH
77887: LD_INT 8
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: IN
77894: IFFALSE 77904
// btype := b_lab ;
77896: NOP4
77900: PUSH
77901: LD_INT 6
77903: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
77904: NOP4
77908: PUSH
77909: NOP4
77913: PPUSH
77914: NOP4
77918: PUSH
77919: NOP4
77923: PUSH
77924: NOP4
77928: ARRAY
77929: PUSH
77930: LD_INT 1
77932: PLUS
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PPUSH
77938: NOP4
77942: PUSH
77943: NOP4
77947: PPUSH
77948: NOP4
77952: PUSH
77953: NOP4
77957: PPUSH
77958: NOP4
77962: PUSH
77963: NOP4
77967: PPUSH
77968: NOP4
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: PPUSH
77979: NOP4
77983: ST_TO_ADDR
// if pos = 1 then
77984: NOP4
77988: PUSH
77989: LD_INT 1
77991: EQUAL
77992: IFFALSE 78107
// begin tmp := mc_build_list [ i ] ;
77994: NOP4
77998: PUSH
77999: NOP4
78003: PUSH
78004: NOP4
78008: ARRAY
78009: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78010: NOP4
78014: PPUSH
78015: LD_INT 2
78017: PUSH
78018: LD_INT 30
78020: PUSH
78021: LD_INT 0
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 30
78030: PUSH
78031: LD_INT 1
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: LIST
78042: PPUSH
78043: NOP4
78047: IFFALSE 78057
// pos := 2 ;
78049: NOP4
78053: PUSH
78054: LD_INT 2
78056: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78057: NOP4
78061: PUSH
78062: NOP4
78066: PPUSH
78067: NOP4
78071: PPUSH
78072: NOP4
78076: PPUSH
78077: NOP4
78081: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78082: NOP4
78086: PUSH
78087: NOP4
78091: PPUSH
78092: NOP4
78096: PPUSH
78097: NOP4
78101: PPUSH
78102: NOP4
78106: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78107: NOP4
78111: PUSH
78112: NOP4
78116: PUSH
78117: NOP4
78121: ARRAY
78122: IN
78123: IFFALSE 78162
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78125: NOP4
78129: PUSH
78130: NOP4
78134: PPUSH
78135: NOP4
78139: PPUSH
78140: NOP4
78144: PUSH
78145: NOP4
78149: ARRAY
78150: PUSH
78151: NOP4
78155: DIFF
78156: PPUSH
78157: NOP4
78161: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78162: NOP4
78166: PUSH
78167: NOP4
78171: PUSH
78172: NOP4
78176: ARRAY
78177: IN
78178: IFFALSE 78217
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78180: NOP4
78184: PUSH
78185: NOP4
78189: PPUSH
78190: NOP4
78194: PPUSH
78195: NOP4
78199: PUSH
78200: NOP4
78204: ARRAY
78205: PUSH
78206: NOP4
78210: DIFF
78211: PPUSH
78212: NOP4
78216: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78217: NOP4
78221: PUSH
78222: NOP4
78226: PUSH
78227: NOP4
78231: ARRAY
78232: IN
78233: IFFALSE 78272
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78235: NOP4
78239: PUSH
78240: NOP4
78244: PPUSH
78245: NOP4
78249: PPUSH
78250: NOP4
78254: PUSH
78255: NOP4
78259: ARRAY
78260: PUSH
78261: NOP4
78265: DIFF
78266: PPUSH
78267: NOP4
78271: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78272: NOP4
78276: PUSH
78277: NOP4
78281: PUSH
78282: NOP4
78286: ARRAY
78287: IN
78288: IFFALSE 78327
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78290: NOP4
78294: PUSH
78295: NOP4
78299: PPUSH
78300: NOP4
78304: PPUSH
78305: NOP4
78309: PUSH
78310: NOP4
78314: ARRAY
78315: PUSH
78316: NOP4
78320: DIFF
78321: PPUSH
78322: NOP4
78326: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78327: NOP4
78331: PUSH
78332: NOP4
78336: PUSH
78337: NOP4
78341: ARRAY
78342: IN
78343: IFFALSE 78382
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78345: NOP4
78349: PUSH
78350: NOP4
78354: PPUSH
78355: NOP4
78359: PPUSH
78360: NOP4
78364: PUSH
78365: NOP4
78369: ARRAY
78370: PUSH
78371: NOP4
78375: DIFF
78376: PPUSH
78377: NOP4
78381: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78382: NOP4
78386: PUSH
78387: NOP4
78391: PUSH
78392: NOP4
78396: ARRAY
78397: IN
78398: IFFALSE 78437
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78400: NOP4
78404: PUSH
78405: NOP4
78409: PPUSH
78410: NOP4
78414: PPUSH
78415: NOP4
78419: PUSH
78420: NOP4
78424: ARRAY
78425: PUSH
78426: NOP4
78430: DIFF
78431: PPUSH
78432: NOP4
78436: ST_TO_ADDR
// end ; break ;
78437: GO 78441
// end ;
78439: GO 77087
78441: POP
78442: POP
// end ;
78443: LD_VAR 0 2
78447: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78448: LD_INT 0
78450: PPUSH
78451: PPUSH
78452: PPUSH
// if not mc_bases or not skirmish then
78453: NOP4
78457: NOT
78458: PUSH
78459: NOP4
78463: NOT
78464: OR
78465: IFFALSE 78469
// exit ;
78467: GO 78684
// for i = 1 to mc_bases do
78469: NOP4
78473: PUSH
78474: DOUBLE
78475: LD_INT 1
78477: DEC
78478: ST_TO_ADDR
78479: NOP4
78483: PUSH
78484: FOR_TO
78485: IFFALSE 78682
// begin if building in mc_construct_list [ i ] then
78487: NOP4
78491: PUSH
78492: NOP4
78496: PUSH
78497: NOP4
78501: ARRAY
78502: IN
78503: IFFALSE 78680
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78505: NOP4
78509: PUSH
78510: NOP4
78514: PPUSH
78515: NOP4
78519: PPUSH
78520: NOP4
78524: PUSH
78525: NOP4
78529: ARRAY
78530: PUSH
78531: NOP4
78535: DIFF
78536: PPUSH
78537: NOP4
78541: ST_TO_ADDR
// if building in mc_lab [ i ] then
78542: NOP4
78546: PUSH
78547: NOP4
78551: PUSH
78552: NOP4
78556: ARRAY
78557: IN
78558: IFFALSE 78613
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
78560: NOP4
78564: PUSH
78565: NOP4
78569: PPUSH
78570: NOP4
78574: PPUSH
78575: NOP4
78579: PUSH
78580: NOP4
78584: ARRAY
78585: PPUSH
78586: LD_INT 1
78588: PPUSH
78589: NOP4
78593: PUSH
78594: NOP4
78598: ARRAY
78599: PPUSH
78600: LD_INT 0
78602: PPUSH
78603: NOP4
78607: PPUSH
78608: NOP4
78612: ST_TO_ADDR
// if not building in mc_bases [ i ] then
78613: NOP4
78617: PUSH
78618: NOP4
78622: PUSH
78623: NOP4
78627: ARRAY
78628: IN
78629: NOT
78630: IFFALSE 78676
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78632: NOP4
78636: PUSH
78637: NOP4
78641: PPUSH
78642: NOP4
78646: PUSH
78647: NOP4
78651: PUSH
78652: NOP4
78656: ARRAY
78657: PUSH
78658: LD_INT 1
78660: PLUS
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PPUSH
78666: NOP4
78670: PPUSH
78671: NOP4
78675: ST_TO_ADDR
// exit ;
78676: POP
78677: POP
78678: GO 78684
// end ; end ;
78680: GO 78484
78682: POP
78683: POP
// end ;
78684: LD_VAR 0 2
78688: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
78689: LD_INT 0
78691: PPUSH
78692: PPUSH
78693: PPUSH
78694: PPUSH
78695: PPUSH
78696: PPUSH
78697: PPUSH
// if not mc_bases or not skirmish then
78698: NOP4
78702: NOT
78703: PUSH
78704: NOP4
78708: NOT
78709: OR
78710: IFFALSE 78714
// exit ;
78712: GO 79375
// for i = 1 to mc_bases do
78714: NOP4
78718: PUSH
78719: DOUBLE
78720: LD_INT 1
78722: DEC
78723: ST_TO_ADDR
78724: NOP4
78728: PUSH
78729: FOR_TO
78730: IFFALSE 79373
// begin if building in mc_construct_list [ i ] then
78732: NOP4
78736: PUSH
78737: NOP4
78741: PUSH
78742: NOP4
78746: ARRAY
78747: IN
78748: IFFALSE 79371
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78750: NOP4
78754: PUSH
78755: NOP4
78759: PPUSH
78760: NOP4
78764: PPUSH
78765: NOP4
78769: PUSH
78770: NOP4
78774: ARRAY
78775: PUSH
78776: NOP4
78780: DIFF
78781: PPUSH
78782: NOP4
78786: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78787: NOP4
78791: PUSH
78792: NOP4
78796: PPUSH
78797: NOP4
78801: PUSH
78802: NOP4
78806: PUSH
78807: NOP4
78811: ARRAY
78812: PUSH
78813: LD_INT 1
78815: PLUS
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PPUSH
78821: NOP4
78825: PPUSH
78826: NOP4
78830: ST_TO_ADDR
// btype := GetBType ( building ) ;
78831: NOP4
78835: PUSH
78836: NOP4
78840: PPUSH
78841: NOP4
78845: ST_TO_ADDR
// side := GetSide ( building ) ;
78846: NOP4
78850: PUSH
78851: NOP4
78855: PPUSH
78856: NOP4
78860: ST_TO_ADDR
// if btype = b_lab then
78861: NOP4
78865: PUSH
78866: LD_INT 6
78868: EQUAL
78869: IFFALSE 78919
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
78871: NOP4
78875: PUSH
78876: NOP4
78880: PPUSH
78881: NOP4
78885: PUSH
78886: NOP4
78890: PUSH
78891: NOP4
78895: ARRAY
78896: PUSH
78897: LD_INT 1
78899: PLUS
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PPUSH
78905: NOP4
78909: PPUSH
78910: NOP4
78914: ST_TO_ADDR
// exit ;
78915: POP
78916: POP
78917: GO 79375
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
78919: NOP4
78923: PUSH
78924: LD_INT 0
78926: PUSH
78927: LD_INT 2
78929: PUSH
78930: LD_INT 4
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: LIST
78937: IN
78938: IFFALSE 79062
// begin if btype = b_armoury then
78940: NOP4
78944: PUSH
78945: LD_INT 4
78947: EQUAL
78948: IFFALSE 78958
// btype := b_barracks ;
78950: NOP4
78954: PUSH
78955: LD_INT 5
78957: ST_TO_ADDR
// if btype = b_depot then
78958: NOP4
78962: PUSH
78963: LD_INT 0
78965: EQUAL
78966: IFFALSE 78976
// btype := b_warehouse ;
78968: NOP4
78972: PUSH
78973: LD_INT 1
78975: ST_TO_ADDR
// if btype = b_workshop then
78976: NOP4
78980: PUSH
78981: LD_INT 2
78983: EQUAL
78984: IFFALSE 78994
// btype := b_factory ;
78986: NOP4
78990: PUSH
78991: LD_INT 3
78993: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
78994: NOP4
78998: PPUSH
78999: NOP4
79003: PPUSH
79004: NOP4
79008: PUSH
79009: LD_INT 1
79011: EQUAL
79012: IFFALSE 79058
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79014: NOP4
79018: PUSH
79019: NOP4
79023: PPUSH
79024: NOP4
79028: PUSH
79029: NOP4
79033: PUSH
79034: NOP4
79038: ARRAY
79039: PUSH
79040: LD_INT 1
79042: PLUS
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PPUSH
79048: NOP4
79052: PPUSH
79053: NOP4
79057: ST_TO_ADDR
// exit ;
79058: POP
79059: POP
79060: GO 79375
// end ; if btype in [ b_bunker , b_turret ] then
79062: NOP4
79066: PUSH
79067: LD_INT 32
79069: PUSH
79070: LD_INT 33
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: IN
79077: IFFALSE 79367
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79079: NOP4
79083: PUSH
79084: NOP4
79088: PPUSH
79089: NOP4
79093: PUSH
79094: NOP4
79098: PUSH
79099: NOP4
79103: ARRAY
79104: PUSH
79105: LD_INT 1
79107: PLUS
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PPUSH
79113: NOP4
79117: PPUSH
79118: NOP4
79122: ST_TO_ADDR
// if btype = b_bunker then
79123: NOP4
79127: PUSH
79128: LD_INT 32
79130: EQUAL
79131: IFFALSE 79367
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79133: NOP4
79137: PUSH
79138: NOP4
79142: PPUSH
79143: NOP4
79147: PUSH
79148: NOP4
79152: PUSH
79153: NOP4
79157: ARRAY
79158: PUSH
79159: LD_INT 1
79161: PLUS
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PPUSH
79167: NOP4
79171: PPUSH
79172: NOP4
79176: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79177: NOP4
79181: PUSH
79182: NOP4
79186: PUSH
79187: NOP4
79191: ARRAY
79192: PPUSH
79193: LD_INT 25
79195: PUSH
79196: LD_INT 1
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 3
79205: PUSH
79206: LD_INT 54
79208: PUSH
79209: EMPTY
79210: LIST
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PPUSH
79220: NOP4
79224: ST_TO_ADDR
// if tmp then
79225: NOP4
79229: IFFALSE 79235
// exit ;
79231: POP
79232: POP
79233: GO 79375
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79235: NOP4
79239: PUSH
79240: NOP4
79244: PUSH
79245: NOP4
79249: ARRAY
79250: PPUSH
79251: LD_INT 2
79253: PUSH
79254: LD_INT 30
79256: PUSH
79257: LD_INT 4
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 30
79266: PUSH
79267: LD_INT 5
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: LIST
79278: PPUSH
79279: NOP4
79283: ST_TO_ADDR
// if not tmp then
79284: NOP4
79288: NOT
79289: IFFALSE 79295
// exit ;
79291: POP
79292: POP
79293: GO 79375
// for j in tmp do
79295: NOP4
79299: PUSH
79300: NOP4
79304: PUSH
79305: FOR_IN
79306: IFFALSE 79365
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79308: NOP4
79312: PUSH
79313: NOP4
79317: PPUSH
79318: NOP4
79322: PPUSH
79323: LD_INT 25
79325: PUSH
79326: LD_INT 1
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PPUSH
79333: NOP4
79337: ST_TO_ADDR
// if units then
79338: NOP4
79342: IFFALSE 79363
// begin ComExitBuilding ( units [ 1 ] ) ;
79344: NOP4
79348: PUSH
79349: LD_INT 1
79351: ARRAY
79352: PPUSH
79353: NOP4
// exit ;
79357: POP
79358: POP
79359: POP
79360: POP
79361: GO 79375
// end ; end ;
79363: GO 79305
79365: POP
79366: POP
// end ; end ; exit ;
79367: POP
79368: POP
79369: GO 79375
// end ; end ;
79371: GO 78729
79373: POP
79374: POP
// end ;
79375: LD_VAR 0 2
79379: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79380: LD_INT 0
79382: PPUSH
79383: PPUSH
79384: PPUSH
79385: PPUSH
79386: PPUSH
79387: PPUSH
79388: PPUSH
// if not mc_bases or not skirmish then
79389: NOP4
79393: NOT
79394: PUSH
79395: NOP4
79399: NOT
79400: OR
79401: IFFALSE 79405
// exit ;
79403: GO 79670
// btype := GetBType ( building ) ;
79405: NOP4
79409: PUSH
79410: NOP4
79414: PPUSH
79415: NOP4
79419: ST_TO_ADDR
// x := GetX ( building ) ;
79420: NOP4
79424: PUSH
79425: NOP4
79429: PPUSH
79430: NOP4
79434: ST_TO_ADDR
// y := GetY ( building ) ;
79435: NOP4
79439: PUSH
79440: NOP4
79444: PPUSH
79445: NOP4
79449: ST_TO_ADDR
// d := GetDir ( building ) ;
79450: NOP4
79454: PUSH
79455: NOP4
79459: PPUSH
79460: NOP4
79464: ST_TO_ADDR
// for i = 1 to mc_bases do
79465: NOP4
79469: PUSH
79470: DOUBLE
79471: LD_INT 1
79473: DEC
79474: ST_TO_ADDR
79475: NOP4
79479: PUSH
79480: FOR_TO
79481: IFFALSE 79668
// begin if not mc_build_list [ i ] then
79483: NOP4
79487: PUSH
79488: NOP4
79492: ARRAY
79493: NOT
79494: IFFALSE 79498
// continue ;
79496: GO 79480
// for j := 1 to mc_build_list [ i ] do
79498: NOP4
79502: PUSH
79503: DOUBLE
79504: LD_INT 1
79506: DEC
79507: ST_TO_ADDR
79508: NOP4
79512: PUSH
79513: NOP4
79517: ARRAY
79518: PUSH
79519: FOR_TO
79520: IFFALSE 79664
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
79522: NOP4
79526: PUSH
79527: NOP4
79531: PUSH
79532: NOP4
79536: PUSH
79537: NOP4
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: PPUSH
79548: NOP4
79552: PUSH
79553: NOP4
79557: ARRAY
79558: PUSH
79559: NOP4
79563: ARRAY
79564: PPUSH
79565: NOP4
79569: IFFALSE 79662
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
79571: NOP4
79575: PUSH
79576: NOP4
79580: PPUSH
79581: NOP4
79585: PPUSH
79586: NOP4
79590: PUSH
79591: NOP4
79595: ARRAY
79596: PPUSH
79597: NOP4
79601: PPUSH
79602: NOP4
79606: PPUSH
79607: NOP4
79611: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
79612: NOP4
79616: PUSH
79617: NOP4
79621: PPUSH
79622: NOP4
79626: PUSH
79627: NOP4
79631: PUSH
79632: NOP4
79636: ARRAY
79637: PUSH
79638: LD_INT 1
79640: PLUS
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PPUSH
79646: NOP4
79650: PPUSH
79651: NOP4
79655: ST_TO_ADDR
// exit ;
79656: POP
79657: POP
79658: POP
79659: POP
79660: GO 79670
// end ;
79662: GO 79519
79664: POP
79665: POP
// end ;
79666: GO 79480
79668: POP
79669: POP
// end ;
79670: LD_VAR 0 3
79674: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
79675: LD_INT 0
79677: PPUSH
79678: PPUSH
79679: PPUSH
// if not mc_bases or not skirmish then
79680: NOP4
79684: NOT
79685: PUSH
79686: NOP4
79690: NOT
79691: OR
79692: IFFALSE 79696
// exit ;
79694: GO 79886
// for i = 1 to mc_bases do
79696: NOP4
79700: PUSH
79701: DOUBLE
79702: LD_INT 1
79704: DEC
79705: ST_TO_ADDR
79706: NOP4
79710: PUSH
79711: FOR_TO
79712: IFFALSE 79799
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
79714: NOP4
79718: PUSH
79719: NOP4
79723: PUSH
79724: NOP4
79728: ARRAY
79729: IN
79730: PUSH
79731: NOP4
79735: PUSH
79736: NOP4
79740: PUSH
79741: NOP4
79745: ARRAY
79746: IN
79747: NOT
79748: AND
79749: IFFALSE 79797
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79751: NOP4
79755: PUSH
79756: NOP4
79760: PPUSH
79761: NOP4
79765: PUSH
79766: NOP4
79770: PUSH
79771: NOP4
79775: ARRAY
79776: PUSH
79777: LD_INT 1
79779: PLUS
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PPUSH
79785: NOP4
79789: PPUSH
79790: NOP4
79794: ST_TO_ADDR
// break ;
79795: GO 79799
// end ; end ;
79797: GO 79711
79799: POP
79800: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
79801: NOP4
79805: PPUSH
79806: NOP4
79810: PUSH
79811: NOP4
79815: IN
79816: PUSH
79817: NOP4
79821: PPUSH
79822: NOP4
79826: PUSH
79827: LD_INT 5
79829: EQUAL
79830: AND
79831: PUSH
79832: NOP4
79836: PPUSH
79837: NOP4
79841: PUSH
79842: LD_INT 18
79844: NONEQUAL
79845: AND
79846: IFFALSE 79886
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
79848: NOP4
79852: PPUSH
79853: NOP4
79857: PUSH
79858: LD_INT 5
79860: PUSH
79861: LD_INT 8
79863: PUSH
79864: LD_INT 9
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: LIST
79871: IN
79872: IFFALSE 79886
// SetClass ( unit , 1 ) ;
79874: NOP4
79878: PPUSH
79879: LD_INT 1
79881: PPUSH
79882: NOP4
// end ;
79886: LD_VAR 0 3
79890: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
79891: LD_INT 0
79893: PPUSH
79894: PPUSH
// if not mc_bases or not skirmish then
79895: NOP4
79899: NOT
79900: PUSH
79901: NOP4
79905: NOT
79906: OR
79907: IFFALSE 79911
// exit ;
79909: GO 80027
// if GetLives ( abandoned_vehicle ) > 250 then
79911: NOP4
79915: PPUSH
79916: NOP4
79920: PUSH
79921: LD_INT 250
79923: GREATER
79924: IFFALSE 79928
// exit ;
79926: GO 80027
// for i = 1 to mc_bases do
79928: NOP4
79932: PUSH
79933: DOUBLE
79934: LD_INT 1
79936: DEC
79937: ST_TO_ADDR
79938: NOP4
79942: PUSH
79943: FOR_TO
79944: IFFALSE 80025
// begin if driver in mc_bases [ i ] then
79946: NOP4
79950: PUSH
79951: NOP4
79955: PUSH
79956: NOP4
79960: ARRAY
79961: IN
79962: IFFALSE 80023
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
79964: NOP4
79968: PPUSH
79969: NOP4
79973: PUSH
79974: NOP4
79978: ARRAY
79979: PPUSH
79980: LD_INT 2
79982: PUSH
79983: LD_INT 30
79985: PUSH
79986: LD_INT 0
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: LD_INT 30
79995: PUSH
79996: LD_INT 1
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: LIST
80007: PPUSH
80008: NOP4
80012: PUSH
80013: LD_INT 1
80015: ARRAY
80016: PPUSH
80017: NOP4
// break ;
80021: GO 80025
// end ; end ;
80023: GO 79943
80025: POP
80026: POP
// end ; end_of_file
80027: LD_VAR 0 5
80031: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
80032: LD_INT 0
80034: PPUSH
// ar_miner := 81 ;
80035: NOP4
80039: PUSH
80040: LD_INT 81
80042: ST_TO_ADDR
// ar_crane := 88 ;
80043: NOP4
80047: PUSH
80048: LD_INT 88
80050: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80051: NOP4
80055: PUSH
80056: LD_INT 89
80058: ST_TO_ADDR
// us_hack := 99 ;
80059: NOP4
80063: PUSH
80064: LD_INT 99
80066: ST_TO_ADDR
// us_artillery := 97 ;
80067: NOP4
80071: PUSH
80072: LD_INT 97
80074: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80075: NOP4
80079: PUSH
80080: LD_INT 91
80082: ST_TO_ADDR
// ar_mortar := 92 ;
80083: NOP4
80087: PUSH
80088: LD_INT 92
80090: ST_TO_ADDR
// ru_radar := 98 ;
80091: NOP4
80095: PUSH
80096: LD_INT 98
80098: ST_TO_ADDR
// tech_Artillery := 80 ;
80099: NOP4
80103: PUSH
80104: LD_INT 80
80106: ST_TO_ADDR
// tech_RadMat := 81 ;
80107: NOP4
80111: PUSH
80112: LD_INT 81
80114: ST_TO_ADDR
// tech_BasicTools := 82 ;
80115: NOP4
80119: PUSH
80120: LD_INT 82
80122: ST_TO_ADDR
// tech_Cargo := 83 ;
80123: NOP4
80127: PUSH
80128: LD_INT 83
80130: ST_TO_ADDR
// tech_Track := 84 ;
80131: NOP4
80135: PUSH
80136: LD_INT 84
80138: ST_TO_ADDR
// tech_Crane := 85 ;
80139: NOP4
80143: PUSH
80144: LD_INT 85
80146: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80147: NOP4
80151: PUSH
80152: LD_INT 86
80154: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80155: NOP4
80159: PUSH
80160: LD_INT 87
80162: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80163: NOP4
80167: PUSH
80168: LD_INT 88
80170: ST_TO_ADDR
// class_mastodont := 31 ;
80171: NOP4
80175: PUSH
80176: LD_INT 31
80178: ST_TO_ADDR
// class_horse := 21 ;
80179: NOP4
80183: PUSH
80184: LD_INT 21
80186: ST_TO_ADDR
// end ;
80187: LD_VAR 0 1
80191: RET
// every 1 do
80192: GO 80194
80194: DISABLE
// InitGlobalVariables ; end_of_file
80195: NOP4
80199: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80200: LD_INT 0
80202: PPUSH
80203: PPUSH
80204: PPUSH
80205: PPUSH
80206: PPUSH
80207: PPUSH
80208: PPUSH
80209: PPUSH
80210: PPUSH
80211: PPUSH
80212: PPUSH
80213: PPUSH
80214: PPUSH
80215: PPUSH
80216: PPUSH
80217: PPUSH
80218: PPUSH
80219: PPUSH
80220: PPUSH
80221: PPUSH
80222: PPUSH
80223: PPUSH
80224: PPUSH
80225: PPUSH
80226: PPUSH
80227: PPUSH
80228: PPUSH
80229: PPUSH
80230: PPUSH
80231: PPUSH
80232: PPUSH
80233: PPUSH
80234: PPUSH
80235: PPUSH
// if not list then
80236: NOP4
80240: NOT
80241: IFFALSE 80245
// exit ;
80243: GO 84904
// base := list [ 1 ] ;
80245: NOP4
80249: PUSH
80250: NOP4
80254: PUSH
80255: LD_INT 1
80257: ARRAY
80258: ST_TO_ADDR
// group := list [ 2 ] ;
80259: NOP4
80263: PUSH
80264: NOP4
80268: PUSH
80269: LD_INT 2
80271: ARRAY
80272: ST_TO_ADDR
// path := list [ 3 ] ;
80273: NOP4
80277: PUSH
80278: NOP4
80282: PUSH
80283: LD_INT 3
80285: ARRAY
80286: ST_TO_ADDR
// flags := list [ 4 ] ;
80287: NOP4
80291: PUSH
80292: NOP4
80296: PUSH
80297: LD_INT 4
80299: ARRAY
80300: ST_TO_ADDR
// mined := [ ] ;
80301: NOP4
80305: PUSH
80306: EMPTY
80307: ST_TO_ADDR
// bombed := [ ] ;
80308: NOP4
80312: PUSH
80313: EMPTY
80314: ST_TO_ADDR
// healers := [ ] ;
80315: NOP4
80319: PUSH
80320: EMPTY
80321: ST_TO_ADDR
// to_heal := [ ] ;
80322: NOP4
80326: PUSH
80327: EMPTY
80328: ST_TO_ADDR
// repairs := [ ] ;
80329: NOP4
80333: PUSH
80334: EMPTY
80335: ST_TO_ADDR
// to_repair := [ ] ;
80336: NOP4
80340: PUSH
80341: EMPTY
80342: ST_TO_ADDR
// if not group or not path then
80343: NOP4
80347: NOT
80348: PUSH
80349: NOP4
80353: NOT
80354: OR
80355: IFFALSE 80359
// exit ;
80357: GO 84904
// side := GetSide ( group [ 1 ] ) ;
80359: NOP4
80363: PUSH
80364: NOP4
80368: PUSH
80369: LD_INT 1
80371: ARRAY
80372: PPUSH
80373: NOP4
80377: ST_TO_ADDR
// if flags then
80378: NOP4
80382: IFFALSE 80526
// begin f_ignore_area := flags [ 1 ] ;
80384: NOP4
80388: PUSH
80389: NOP4
80393: PUSH
80394: LD_INT 1
80396: ARRAY
80397: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80398: NOP4
80402: PUSH
80403: NOP4
80407: PUSH
80408: LD_INT 2
80410: ARRAY
80411: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80412: NOP4
80416: PUSH
80417: NOP4
80421: PUSH
80422: LD_INT 3
80424: ARRAY
80425: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80426: NOP4
80430: PUSH
80431: NOP4
80435: PUSH
80436: LD_INT 4
80438: ARRAY
80439: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80440: NOP4
80444: PUSH
80445: NOP4
80449: PUSH
80450: LD_INT 5
80452: ARRAY
80453: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80454: NOP4
80458: PUSH
80459: NOP4
80463: PUSH
80464: LD_INT 6
80466: ARRAY
80467: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80468: NOP4
80472: PUSH
80473: NOP4
80477: PUSH
80478: LD_INT 7
80480: ARRAY
80481: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
80482: NOP4
80486: PUSH
80487: NOP4
80491: PUSH
80492: LD_INT 8
80494: ARRAY
80495: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
80496: NOP4
80500: PUSH
80501: NOP4
80505: PUSH
80506: LD_INT 9
80508: ARRAY
80509: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
80510: NOP4
80514: PUSH
80515: NOP4
80519: PUSH
80520: LD_INT 10
80522: ARRAY
80523: ST_TO_ADDR
// end else
80524: GO 80606
// begin f_ignore_area := false ;
80526: NOP4
80530: PUSH
80531: LD_INT 0
80533: ST_TO_ADDR
// f_capture := false ;
80534: NOP4
80538: PUSH
80539: LD_INT 0
80541: ST_TO_ADDR
// f_ignore_civ := false ;
80542: NOP4
80546: PUSH
80547: LD_INT 0
80549: ST_TO_ADDR
// f_murder := false ;
80550: NOP4
80554: PUSH
80555: LD_INT 0
80557: ST_TO_ADDR
// f_mines := false ;
80558: NOP4
80562: PUSH
80563: LD_INT 0
80565: ST_TO_ADDR
// f_repair := false ;
80566: NOP4
80570: PUSH
80571: LD_INT 0
80573: ST_TO_ADDR
// f_heal := false ;
80574: NOP4
80578: PUSH
80579: LD_INT 0
80581: ST_TO_ADDR
// f_spacetime := false ;
80582: NOP4
80586: PUSH
80587: LD_INT 0
80589: ST_TO_ADDR
// f_attack_depot := false ;
80590: NOP4
80594: PUSH
80595: LD_INT 0
80597: ST_TO_ADDR
// f_crawl := false ;
80598: NOP4
80602: PUSH
80603: LD_INT 0
80605: ST_TO_ADDR
// end ; if f_heal then
80606: NOP4
80610: IFFALSE 80637
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
80612: NOP4
80616: PUSH
80617: NOP4
80621: PPUSH
80622: LD_INT 25
80624: PUSH
80625: LD_INT 4
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PPUSH
80632: NOP4
80636: ST_TO_ADDR
// if f_repair then
80637: NOP4
80641: IFFALSE 80668
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
80643: NOP4
80647: PUSH
80648: NOP4
80652: PPUSH
80653: LD_INT 25
80655: PUSH
80656: LD_INT 3
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PPUSH
80663: NOP4
80667: ST_TO_ADDR
// units_path := [ ] ;
80668: NOP4
80672: PUSH
80673: EMPTY
80674: ST_TO_ADDR
// for i = 1 to group do
80675: NOP4
80679: PUSH
80680: DOUBLE
80681: LD_INT 1
80683: DEC
80684: ST_TO_ADDR
80685: NOP4
80689: PUSH
80690: FOR_TO
80691: IFFALSE 80720
// units_path := Replace ( units_path , i , path ) ;
80693: NOP4
80697: PUSH
80698: NOP4
80702: PPUSH
80703: NOP4
80707: PPUSH
80708: NOP4
80712: PPUSH
80713: NOP4
80717: ST_TO_ADDR
80718: GO 80690
80720: POP
80721: POP
// repeat for i = group downto 1 do
80722: NOP4
80726: PUSH
80727: DOUBLE
80728: NOP4
80732: INC
80733: ST_TO_ADDR
80734: LD_INT 1
80736: PUSH
80737: FOR_DOWNTO
80738: IFFALSE 84860
// begin wait ( 5 ) ;
80740: LD_INT 5
80742: PPUSH
80743: NOP4
// tmp := [ ] ;
80747: NOP4
80751: PUSH
80752: EMPTY
80753: ST_TO_ADDR
// attacking := false ;
80754: NOP4
80758: PUSH
80759: LD_INT 0
80761: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
80762: NOP4
80766: PUSH
80767: NOP4
80771: ARRAY
80772: PPUSH
80773: NOP4
80777: PUSH
80778: NOP4
80782: PUSH
80783: NOP4
80787: ARRAY
80788: NOT
80789: OR
80790: IFFALSE 80899
// begin if GetType ( group [ i ] ) = unit_human then
80792: NOP4
80796: PUSH
80797: NOP4
80801: ARRAY
80802: PPUSH
80803: NOP4
80807: PUSH
80808: LD_INT 1
80810: EQUAL
80811: IFFALSE 80857
// begin to_heal := to_heal diff group [ i ] ;
80813: NOP4
80817: PUSH
80818: NOP4
80822: PUSH
80823: NOP4
80827: PUSH
80828: NOP4
80832: ARRAY
80833: DIFF
80834: ST_TO_ADDR
// healers := healers diff group [ i ] ;
80835: NOP4
80839: PUSH
80840: NOP4
80844: PUSH
80845: NOP4
80849: PUSH
80850: NOP4
80854: ARRAY
80855: DIFF
80856: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
80857: NOP4
80861: PUSH
80862: NOP4
80866: PPUSH
80867: NOP4
80871: PPUSH
80872: NOP4
80876: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
80877: NOP4
80881: PUSH
80882: NOP4
80886: PPUSH
80887: NOP4
80891: PPUSH
80892: NOP4
80896: ST_TO_ADDR
// continue ;
80897: GO 80737
// end ; if f_repair then
80899: NOP4
80903: IFFALSE 81392
// begin if GetType ( group [ i ] ) = unit_vehicle then
80905: NOP4
80909: PUSH
80910: NOP4
80914: ARRAY
80915: PPUSH
80916: NOP4
80920: PUSH
80921: LD_INT 2
80923: EQUAL
80924: IFFALSE 81114
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
80926: NOP4
80930: PUSH
80931: NOP4
80935: ARRAY
80936: PPUSH
80937: NOP4
80941: PUSH
80942: LD_INT 700
80944: LESS
80945: PUSH
80946: NOP4
80950: PUSH
80951: NOP4
80955: ARRAY
80956: PUSH
80957: NOP4
80961: IN
80962: NOT
80963: AND
80964: IFFALSE 80988
// to_repair := to_repair union group [ i ] ;
80966: NOP4
80970: PUSH
80971: NOP4
80975: PUSH
80976: NOP4
80980: PUSH
80981: NOP4
80985: ARRAY
80986: UNION
80987: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
80988: NOP4
80992: PUSH
80993: NOP4
80997: ARRAY
80998: PPUSH
80999: NOP4
81003: PUSH
81004: LD_INT 1000
81006: EQUAL
81007: PUSH
81008: NOP4
81012: PUSH
81013: NOP4
81017: ARRAY
81018: PUSH
81019: NOP4
81023: IN
81024: AND
81025: IFFALSE 81049
// to_repair := to_repair diff group [ i ] ;
81027: NOP4
81031: PUSH
81032: NOP4
81036: PUSH
81037: NOP4
81041: PUSH
81042: NOP4
81046: ARRAY
81047: DIFF
81048: ST_TO_ADDR
// if group [ i ] in to_repair then
81049: NOP4
81053: PUSH
81054: NOP4
81058: ARRAY
81059: PUSH
81060: NOP4
81064: IN
81065: IFFALSE 81112
// begin if not IsInArea ( group [ i ] , f_repair ) then
81067: NOP4
81071: PUSH
81072: NOP4
81076: ARRAY
81077: PPUSH
81078: NOP4
81082: PPUSH
81083: NOP4
81087: NOT
81088: IFFALSE 81110
// ComMoveToArea ( group [ i ] , f_repair ) ;
81090: NOP4
81094: PUSH
81095: NOP4
81099: ARRAY
81100: PPUSH
81101: NOP4
81105: PPUSH
81106: NOP4
// continue ;
81110: GO 80737
// end ; end else
81112: GO 81392
// if group [ i ] in repairs then
81114: NOP4
81118: PUSH
81119: NOP4
81123: ARRAY
81124: PUSH
81125: NOP4
81129: IN
81130: IFFALSE 81392
// begin if IsInUnit ( group [ i ] ) then
81132: NOP4
81136: PUSH
81137: NOP4
81141: ARRAY
81142: PPUSH
81143: NOP4
81147: IFFALSE 81215
// begin z := IsInUnit ( group [ i ] ) ;
81149: NOP4
81153: PUSH
81154: NOP4
81158: PUSH
81159: NOP4
81163: ARRAY
81164: PPUSH
81165: NOP4
81169: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81170: NOP4
81174: PUSH
81175: NOP4
81179: IN
81180: PUSH
81181: NOP4
81185: PPUSH
81186: NOP4
81190: PPUSH
81191: NOP4
81195: AND
81196: IFFALSE 81213
// ComExitVehicle ( group [ i ] ) ;
81198: NOP4
81202: PUSH
81203: NOP4
81207: ARRAY
81208: PPUSH
81209: NOP4
// end else
81213: GO 81392
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81215: NOP4
81219: PUSH
81220: NOP4
81224: PPUSH
81225: LD_INT 95
81227: PUSH
81228: NOP4
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 58
81239: PUSH
81240: EMPTY
81241: LIST
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PPUSH
81247: NOP4
81251: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81252: NOP4
81256: PUSH
81257: NOP4
81261: ARRAY
81262: PPUSH
81263: NOP4
81267: NOT
81268: IFFALSE 81390
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81270: NOP4
81274: PUSH
81275: NOP4
81279: PPUSH
81280: NOP4
81284: PUSH
81285: NOP4
81289: ARRAY
81290: PPUSH
81291: NOP4
81295: ST_TO_ADDR
// if not x then
81296: NOP4
81300: NOT
81301: IFFALSE 81305
// continue ;
81303: GO 80737
// if GetLives ( x ) < 1000 then
81305: NOP4
81309: PPUSH
81310: NOP4
81314: PUSH
81315: LD_INT 1000
81317: LESS
81318: IFFALSE 81342
// ComRepairVehicle ( group [ i ] , x ) else
81320: NOP4
81324: PUSH
81325: NOP4
81329: ARRAY
81330: PPUSH
81331: NOP4
81335: PPUSH
81336: NOP4
81340: GO 81390
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81342: NOP4
81346: PUSH
81347: NOP4
81351: PUSH
81352: NOP4
81356: ARRAY
81357: PPUSH
81358: NOP4
81362: PUSH
81363: LD_INT 1000
81365: LESS
81366: AND
81367: NOT
81368: IFFALSE 81390
// ComEnterUnit ( group [ i ] , x ) ;
81370: NOP4
81374: PUSH
81375: NOP4
81379: ARRAY
81380: PPUSH
81381: NOP4
81385: PPUSH
81386: NOP4
// end ; continue ;
81390: GO 80737
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81392: NOP4
81396: PUSH
81397: NOP4
81401: PUSH
81402: NOP4
81406: ARRAY
81407: PPUSH
81408: NOP4
81412: PUSH
81413: LD_INT 1
81415: EQUAL
81416: AND
81417: IFFALSE 81895
// begin if group [ i ] in healers then
81419: NOP4
81423: PUSH
81424: NOP4
81428: ARRAY
81429: PUSH
81430: NOP4
81434: IN
81435: IFFALSE 81708
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81437: NOP4
81441: PUSH
81442: NOP4
81446: ARRAY
81447: PPUSH
81448: NOP4
81452: PPUSH
81453: NOP4
81457: NOT
81458: PUSH
81459: NOP4
81463: PUSH
81464: NOP4
81468: ARRAY
81469: PPUSH
81470: NOP4
81474: NOT
81475: AND
81476: IFFALSE 81500
// ComMoveToArea ( group [ i ] , f_heal ) else
81478: NOP4
81482: PUSH
81483: NOP4
81487: ARRAY
81488: PPUSH
81489: NOP4
81493: PPUSH
81494: NOP4
81498: GO 81706
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
81500: NOP4
81504: PUSH
81505: NOP4
81509: ARRAY
81510: PPUSH
81511: NOP4
81515: PPUSH
81516: NOP4
81520: PUSH
81521: LD_INT 1000
81523: EQUAL
81524: IFFALSE 81543
// ComStop ( group [ i ] ) else
81526: NOP4
81530: PUSH
81531: NOP4
81535: ARRAY
81536: PPUSH
81537: NOP4
81541: GO 81706
// if not HasTask ( group [ i ] ) and to_heal then
81543: NOP4
81547: PUSH
81548: NOP4
81552: ARRAY
81553: PPUSH
81554: NOP4
81558: NOT
81559: PUSH
81560: NOP4
81564: AND
81565: IFFALSE 81706
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
81567: NOP4
81571: PUSH
81572: NOP4
81576: PPUSH
81577: LD_INT 3
81579: PUSH
81580: LD_INT 54
81582: PUSH
81583: EMPTY
81584: LIST
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PPUSH
81590: NOP4
81594: PPUSH
81595: NOP4
81599: PUSH
81600: NOP4
81604: ARRAY
81605: PPUSH
81606: NOP4
81610: ST_TO_ADDR
// if z then
81611: NOP4
81615: IFFALSE 81706
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
81617: LD_INT 91
81619: PUSH
81620: NOP4
81624: PUSH
81625: LD_INT 10
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 81
81635: PUSH
81636: NOP4
81640: PPUSH
81641: NOP4
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PPUSH
81654: NOP4
81658: PUSH
81659: LD_INT 0
81661: EQUAL
81662: IFFALSE 81686
// ComHeal ( group [ i ] , z ) else
81664: NOP4
81668: PUSH
81669: NOP4
81673: ARRAY
81674: PPUSH
81675: NOP4
81679: PPUSH
81680: NOP4
81684: GO 81706
// ComMoveToArea ( group [ i ] , f_heal ) ;
81686: NOP4
81690: PUSH
81691: NOP4
81695: ARRAY
81696: PPUSH
81697: NOP4
81701: PPUSH
81702: NOP4
// end ; continue ;
81706: GO 80737
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
81708: NOP4
81712: PUSH
81713: NOP4
81717: ARRAY
81718: PPUSH
81719: NOP4
81723: PUSH
81724: LD_INT 700
81726: LESS
81727: PUSH
81728: NOP4
81732: PUSH
81733: NOP4
81737: ARRAY
81738: PUSH
81739: NOP4
81743: IN
81744: NOT
81745: AND
81746: IFFALSE 81770
// to_heal := to_heal union group [ i ] ;
81748: NOP4
81752: PUSH
81753: NOP4
81757: PUSH
81758: NOP4
81762: PUSH
81763: NOP4
81767: ARRAY
81768: UNION
81769: ST_TO_ADDR
// if group [ i ] in to_heal then
81770: NOP4
81774: PUSH
81775: NOP4
81779: ARRAY
81780: PUSH
81781: NOP4
81785: IN
81786: IFFALSE 81895
// begin if GetLives ( group [ i ] ) = 1000 then
81788: NOP4
81792: PUSH
81793: NOP4
81797: ARRAY
81798: PPUSH
81799: NOP4
81803: PUSH
81804: LD_INT 1000
81806: EQUAL
81807: IFFALSE 81833
// to_heal := to_heal diff group [ i ] else
81809: NOP4
81813: PUSH
81814: NOP4
81818: PUSH
81819: NOP4
81823: PUSH
81824: NOP4
81828: ARRAY
81829: DIFF
81830: ST_TO_ADDR
81831: GO 81895
// begin if not IsInArea ( group [ i ] , to_heal ) then
81833: NOP4
81837: PUSH
81838: NOP4
81842: ARRAY
81843: PPUSH
81844: NOP4
81848: PPUSH
81849: NOP4
81853: NOT
81854: IFFALSE 81878
// ComMoveToArea ( group [ i ] , f_heal ) else
81856: NOP4
81860: PUSH
81861: NOP4
81865: ARRAY
81866: PPUSH
81867: NOP4
81871: PPUSH
81872: NOP4
81876: GO 81893
// ComHold ( group [ i ] ) ;
81878: NOP4
81882: PUSH
81883: NOP4
81887: ARRAY
81888: PPUSH
81889: NOP4
// continue ;
81893: GO 80737
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
81895: NOP4
81899: PUSH
81900: NOP4
81904: ARRAY
81905: PPUSH
81906: LD_INT 10
81908: PPUSH
81909: NOP4
81913: NOT
81914: PUSH
81915: NOP4
81919: PUSH
81920: NOP4
81924: ARRAY
81925: PUSH
81926: EMPTY
81927: EQUAL
81928: NOT
81929: AND
81930: IFFALSE 82196
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
81932: NOP4
81936: PUSH
81937: NOP4
81941: ARRAY
81942: PPUSH
81943: NOP4
81947: PUSH
81948: LD_INT 1
81950: PUSH
81951: LD_INT 2
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: IN
81958: IFFALSE 81999
// if GetFuel ( group [ i ] ) < 10 then
81960: NOP4
81964: PUSH
81965: NOP4
81969: ARRAY
81970: PPUSH
81971: NOP4
81975: PUSH
81976: LD_INT 10
81978: LESS
81979: IFFALSE 81999
// SetFuel ( group [ i ] , 12 ) ;
81981: NOP4
81985: PUSH
81986: NOP4
81990: ARRAY
81991: PPUSH
81992: LD_INT 12
81994: PPUSH
81995: NOP4
// if units_path [ i ] then
81999: NOP4
82003: PUSH
82004: NOP4
82008: ARRAY
82009: IFFALSE 82194
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82011: NOP4
82015: PUSH
82016: NOP4
82020: ARRAY
82021: PPUSH
82022: NOP4
82026: PUSH
82027: NOP4
82031: ARRAY
82032: PUSH
82033: LD_INT 1
82035: ARRAY
82036: PUSH
82037: LD_INT 1
82039: ARRAY
82040: PPUSH
82041: NOP4
82045: PUSH
82046: NOP4
82050: ARRAY
82051: PUSH
82052: LD_INT 1
82054: ARRAY
82055: PUSH
82056: LD_INT 2
82058: ARRAY
82059: PPUSH
82060: NOP4
82064: PUSH
82065: LD_INT 6
82067: GREATER
82068: IFFALSE 82143
// begin if not HasTask ( group [ i ] ) then
82070: NOP4
82074: PUSH
82075: NOP4
82079: ARRAY
82080: PPUSH
82081: NOP4
82085: NOT
82086: IFFALSE 82141
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82088: NOP4
82092: PUSH
82093: NOP4
82097: ARRAY
82098: PPUSH
82099: NOP4
82103: PUSH
82104: NOP4
82108: ARRAY
82109: PUSH
82110: LD_INT 1
82112: ARRAY
82113: PUSH
82114: LD_INT 1
82116: ARRAY
82117: PPUSH
82118: NOP4
82122: PUSH
82123: NOP4
82127: ARRAY
82128: PUSH
82129: LD_INT 1
82131: ARRAY
82132: PUSH
82133: LD_INT 2
82135: ARRAY
82136: PPUSH
82137: NOP4
// end else
82141: GO 82194
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82143: NOP4
82147: PUSH
82148: NOP4
82152: PUSH
82153: NOP4
82157: ARRAY
82158: PPUSH
82159: LD_INT 1
82161: PPUSH
82162: NOP4
82166: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82167: NOP4
82171: PUSH
82172: NOP4
82176: PPUSH
82177: NOP4
82181: PPUSH
82182: NOP4
82186: PPUSH
82187: NOP4
82191: ST_TO_ADDR
// continue ;
82192: GO 80737
// end ; end ; end else
82194: GO 84858
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82196: NOP4
82200: PUSH
82201: LD_INT 81
82203: PUSH
82204: NOP4
82208: PUSH
82209: NOP4
82213: ARRAY
82214: PPUSH
82215: NOP4
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PPUSH
82224: NOP4
82228: ST_TO_ADDR
// if not tmp then
82229: NOP4
82233: NOT
82234: IFFALSE 82238
// continue ;
82236: GO 80737
// if f_ignore_area then
82238: NOP4
82242: IFFALSE 82330
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82244: NOP4
82248: PUSH
82249: NOP4
82253: PPUSH
82254: LD_INT 3
82256: PUSH
82257: LD_INT 92
82259: PUSH
82260: NOP4
82264: PUSH
82265: LD_INT 1
82267: ARRAY
82268: PUSH
82269: NOP4
82273: PUSH
82274: LD_INT 2
82276: ARRAY
82277: PUSH
82278: NOP4
82282: PUSH
82283: LD_INT 3
82285: ARRAY
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PPUSH
82297: NOP4
82301: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82302: NOP4
82306: PUSH
82307: NOP4
82311: DIFF
82312: IFFALSE 82330
// tmp := tmp diff tmp2 ;
82314: NOP4
82318: PUSH
82319: NOP4
82323: PUSH
82324: NOP4
82328: DIFF
82329: ST_TO_ADDR
// end ; if not f_murder then
82330: NOP4
82334: NOT
82335: IFFALSE 82393
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82337: NOP4
82341: PUSH
82342: NOP4
82346: PPUSH
82347: LD_INT 3
82349: PUSH
82350: LD_INT 50
82352: PUSH
82353: EMPTY
82354: LIST
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PPUSH
82360: NOP4
82364: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82365: NOP4
82369: PUSH
82370: NOP4
82374: DIFF
82375: IFFALSE 82393
// tmp := tmp diff tmp2 ;
82377: NOP4
82381: PUSH
82382: NOP4
82386: PUSH
82387: NOP4
82391: DIFF
82392: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82393: NOP4
82397: PUSH
82398: NOP4
82402: PUSH
82403: NOP4
82407: ARRAY
82408: PPUSH
82409: NOP4
82413: PPUSH
82414: LD_INT 1
82416: PPUSH
82417: LD_INT 1
82419: PPUSH
82420: NOP4
82424: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82425: NOP4
82429: PUSH
82430: NOP4
82434: ARRAY
82435: PPUSH
82436: NOP4
82440: PUSH
82441: LD_INT 1
82443: EQUAL
82444: IFFALSE 82892
// begin if WantPlant ( group [ i ] ) then
82446: NOP4
82450: PUSH
82451: NOP4
82455: ARRAY
82456: PPUSH
82457: NOP4
82461: IFFALSE 82465
// continue ;
82463: GO 80737
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82465: NOP4
82469: PUSH
82470: NOP4
82474: PUSH
82475: NOP4
82479: ARRAY
82480: PPUSH
82481: NOP4
82485: NOT
82486: AND
82487: PUSH
82488: NOP4
82492: PUSH
82493: LD_INT 1
82495: ARRAY
82496: PUSH
82497: NOP4
82501: PPUSH
82502: LD_INT 21
82504: PUSH
82505: LD_INT 2
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 58
82514: PUSH
82515: EMPTY
82516: LIST
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PPUSH
82522: NOP4
82526: IN
82527: AND
82528: IFFALSE 82564
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
82530: NOP4
82534: PUSH
82535: NOP4
82539: ARRAY
82540: PPUSH
82541: NOP4
82545: PUSH
82546: LD_INT 1
82548: ARRAY
82549: PPUSH
82550: NOP4
// attacking := true ;
82554: NOP4
82558: PUSH
82559: LD_INT 1
82561: ST_TO_ADDR
// continue ;
82562: GO 80737
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
82564: NOP4
82568: PUSH
82569: NOP4
82573: PUSH
82574: NOP4
82578: ARRAY
82579: PPUSH
82580: NOP4
82584: PUSH
82585: LD_INT 1
82587: EQUAL
82588: AND
82589: PUSH
82590: NOP4
82594: PUSH
82595: NOP4
82599: ARRAY
82600: PPUSH
82601: NOP4
82605: PUSH
82606: LD_INT 800
82608: LESS
82609: AND
82610: PUSH
82611: NOP4
82615: PUSH
82616: NOP4
82620: ARRAY
82621: PPUSH
82622: NOP4
82626: NOT
82627: AND
82628: IFFALSE 82645
// ComCrawl ( group [ i ] ) ;
82630: NOP4
82634: PUSH
82635: NOP4
82639: ARRAY
82640: PPUSH
82641: NOP4
// if f_mines then
82645: NOP4
82649: IFFALSE 82892
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
82651: NOP4
82655: PUSH
82656: LD_INT 1
82658: ARRAY
82659: PPUSH
82660: NOP4
82664: PUSH
82665: LD_INT 3
82667: EQUAL
82668: PUSH
82669: NOP4
82673: PUSH
82674: LD_INT 1
82676: ARRAY
82677: PUSH
82678: NOP4
82682: IN
82683: NOT
82684: AND
82685: IFFALSE 82892
// begin x := GetX ( tmp [ 1 ] ) ;
82687: NOP4
82691: PUSH
82692: NOP4
82696: PUSH
82697: LD_INT 1
82699: ARRAY
82700: PPUSH
82701: NOP4
82705: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
82706: NOP4
82710: PUSH
82711: NOP4
82715: PUSH
82716: LD_INT 1
82718: ARRAY
82719: PPUSH
82720: NOP4
82724: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
82725: NOP4
82729: PUSH
82730: NOP4
82734: PUSH
82735: NOP4
82739: ARRAY
82740: PPUSH
82741: NOP4
82745: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
82746: NOP4
82750: PUSH
82751: NOP4
82755: ARRAY
82756: PPUSH
82757: NOP4
82761: PPUSH
82762: NOP4
82766: PPUSH
82767: NOP4
82771: PUSH
82772: LD_INT 1
82774: ARRAY
82775: PPUSH
82776: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
82780: NOP4
82784: PUSH
82785: NOP4
82789: ARRAY
82790: PPUSH
82791: NOP4
82795: PPUSH
82796: NOP4
82800: PPUSH
82801: LD_INT 7
82803: PPUSH
82804: NOP4
82808: PPUSH
82809: NOP4
82813: PPUSH
82814: NOP4
82818: PPUSH
82819: LD_INT 7
82821: PPUSH
82822: NOP4
82826: PPUSH
82827: NOP4
// SetTag ( group [ i ] , 71 ) ;
82831: NOP4
82835: PUSH
82836: NOP4
82840: ARRAY
82841: PPUSH
82842: LD_INT 71
82844: PPUSH
82845: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
82849: NOP4
82853: PUSH
82854: NOP4
82858: PPUSH
82859: NOP4
82863: PUSH
82864: LD_INT 1
82866: PLUS
82867: PPUSH
82868: NOP4
82872: PUSH
82873: LD_INT 1
82875: ARRAY
82876: PPUSH
82877: NOP4
82881: ST_TO_ADDR
// attacking := true ;
82882: NOP4
82886: PUSH
82887: LD_INT 1
82889: ST_TO_ADDR
// continue ;
82890: GO 80737
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
82892: NOP4
82896: PUSH
82897: NOP4
82901: ARRAY
82902: PPUSH
82903: NOP4
82907: PUSH
82908: LD_INT 17
82910: EQUAL
82911: PUSH
82912: NOP4
82916: PUSH
82917: NOP4
82921: ARRAY
82922: PPUSH
82923: NOP4
82927: PUSH
82928: LD_INT 71
82930: EQUAL
82931: NOT
82932: AND
82933: IFFALSE 83079
// begin attacking := false ;
82935: NOP4
82939: PUSH
82940: LD_INT 0
82942: ST_TO_ADDR
// k := 5 ;
82943: NOP4
82947: PUSH
82948: LD_INT 5
82950: ST_TO_ADDR
// if tmp < k then
82951: NOP4
82955: PUSH
82956: NOP4
82960: LESS
82961: IFFALSE 82973
// k := tmp ;
82963: NOP4
82967: PUSH
82968: NOP4
82972: ST_TO_ADDR
// for j = 1 to k do
82973: NOP4
82977: PUSH
82978: DOUBLE
82979: LD_INT 1
82981: DEC
82982: ST_TO_ADDR
82983: NOP4
82987: PUSH
82988: FOR_TO
82989: IFFALSE 83077
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
82991: NOP4
82995: PUSH
82996: NOP4
83000: ARRAY
83001: PUSH
83002: NOP4
83006: PPUSH
83007: LD_INT 58
83009: PUSH
83010: EMPTY
83011: LIST
83012: PPUSH
83013: NOP4
83017: IN
83018: NOT
83019: IFFALSE 83075
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83021: NOP4
83025: PUSH
83026: NOP4
83030: ARRAY
83031: PPUSH
83032: NOP4
83036: PUSH
83037: NOP4
83041: ARRAY
83042: PPUSH
83043: NOP4
// attacking := true ;
83047: NOP4
83051: PUSH
83052: LD_INT 1
83054: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83055: NOP4
83059: PUSH
83060: NOP4
83064: ARRAY
83065: PPUSH
83066: LD_INT 71
83068: PPUSH
83069: NOP4
// continue ;
83073: GO 82988
// end ; end ;
83075: GO 82988
83077: POP
83078: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83079: NOP4
83083: PUSH
83084: NOP4
83088: ARRAY
83089: PPUSH
83090: NOP4
83094: PUSH
83095: LD_INT 8
83097: EQUAL
83098: PUSH
83099: NOP4
83103: PUSH
83104: NOP4
83108: ARRAY
83109: PPUSH
83110: NOP4
83114: PUSH
83115: LD_INT 28
83117: PUSH
83118: LD_INT 45
83120: PUSH
83121: LD_INT 7
83123: PUSH
83124: LD_INT 47
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: IN
83133: OR
83134: IFFALSE 83390
// begin attacking := false ;
83136: NOP4
83140: PUSH
83141: LD_INT 0
83143: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83144: NOP4
83148: PUSH
83149: LD_INT 1
83151: ARRAY
83152: PPUSH
83153: NOP4
83157: PUSH
83158: LD_INT 32
83160: PUSH
83161: LD_INT 31
83163: PUSH
83164: LD_INT 33
83166: PUSH
83167: LD_INT 4
83169: PUSH
83170: LD_INT 5
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: IN
83180: IFFALSE 83366
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83182: NOP4
83186: PUSH
83187: NOP4
83191: PUSH
83192: LD_INT 1
83194: ARRAY
83195: PPUSH
83196: NOP4
83200: PPUSH
83201: NOP4
83205: PUSH
83206: LD_INT 1
83208: ARRAY
83209: PPUSH
83210: NOP4
83214: PPUSH
83215: NOP4
83219: PUSH
83220: LD_INT 1
83222: ARRAY
83223: PPUSH
83224: NOP4
83228: PPUSH
83229: NOP4
83233: PUSH
83234: LD_INT 1
83236: ARRAY
83237: PPUSH
83238: NOP4
83242: PPUSH
83243: NOP4
83247: PUSH
83248: LD_INT 1
83250: ARRAY
83251: PPUSH
83252: NOP4
83256: PPUSH
83257: LD_INT 0
83259: PPUSH
83260: NOP4
83264: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83265: NOP4
83269: PUSH
83270: NOP4
83274: PUSH
83275: NOP4
83279: ARRAY
83280: PPUSH
83281: NOP4
83285: PPUSH
83286: NOP4
83290: ST_TO_ADDR
// if j then
83291: NOP4
83295: IFFALSE 83364
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83297: NOP4
83301: PUSH
83302: LD_INT 1
83304: ARRAY
83305: PPUSH
83306: NOP4
83310: PUSH
83311: LD_INT 2
83313: ARRAY
83314: PPUSH
83315: NOP4
83319: IFFALSE 83364
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83321: NOP4
83325: PUSH
83326: NOP4
83330: ARRAY
83331: PPUSH
83332: NOP4
83336: PUSH
83337: LD_INT 1
83339: ARRAY
83340: PPUSH
83341: NOP4
83345: PUSH
83346: LD_INT 2
83348: ARRAY
83349: PPUSH
83350: NOP4
// attacking := true ;
83354: NOP4
83358: PUSH
83359: LD_INT 1
83361: ST_TO_ADDR
// continue ;
83362: GO 80737
// end ; end else
83364: GO 83390
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83366: NOP4
83370: PUSH
83371: NOP4
83375: ARRAY
83376: PPUSH
83377: NOP4
83381: PUSH
83382: LD_INT 1
83384: ARRAY
83385: PPUSH
83386: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83390: NOP4
83394: PUSH
83395: NOP4
83399: ARRAY
83400: PPUSH
83401: NOP4
83405: PUSH
83406: LD_INT 11
83408: EQUAL
83409: IFFALSE 83687
// begin k := 10 ;
83411: NOP4
83415: PUSH
83416: LD_INT 10
83418: ST_TO_ADDR
// x := 0 ;
83419: NOP4
83423: PUSH
83424: LD_INT 0
83426: ST_TO_ADDR
// if tmp < k then
83427: NOP4
83431: PUSH
83432: NOP4
83436: LESS
83437: IFFALSE 83449
// k := tmp ;
83439: NOP4
83443: PUSH
83444: NOP4
83448: ST_TO_ADDR
// for j = k downto 1 do
83449: NOP4
83453: PUSH
83454: DOUBLE
83455: NOP4
83459: INC
83460: ST_TO_ADDR
83461: LD_INT 1
83463: PUSH
83464: FOR_DOWNTO
83465: IFFALSE 83540
// begin if GetType ( tmp [ j ] ) = unit_human then
83467: NOP4
83471: PUSH
83472: NOP4
83476: ARRAY
83477: PPUSH
83478: NOP4
83482: PUSH
83483: LD_INT 1
83485: EQUAL
83486: IFFALSE 83538
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
83488: NOP4
83492: PUSH
83493: NOP4
83497: ARRAY
83498: PPUSH
83499: NOP4
83503: PUSH
83504: NOP4
83508: ARRAY
83509: PPUSH
83510: NOP4
// x := tmp [ j ] ;
83514: NOP4
83518: PUSH
83519: NOP4
83523: PUSH
83524: NOP4
83528: ARRAY
83529: ST_TO_ADDR
// attacking := true ;
83530: NOP4
83534: PUSH
83535: LD_INT 1
83537: ST_TO_ADDR
// end ; end ;
83538: GO 83464
83540: POP
83541: POP
// if not x then
83542: NOP4
83546: NOT
83547: IFFALSE 83687
// begin attacking := true ;
83549: NOP4
83553: PUSH
83554: LD_INT 1
83556: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
83557: NOP4
83561: PUSH
83562: NOP4
83566: ARRAY
83567: PPUSH
83568: NOP4
83572: PPUSH
83573: NOP4
83577: PUSH
83578: NOP4
83582: ARRAY
83583: PPUSH
83584: NOP4
83588: PPUSH
83589: NOP4
83593: PUSH
83594: LD_INT 2
83596: ARRAY
83597: PUSH
83598: NOP4
83602: PUSH
83603: LD_INT 1
83605: ARRAY
83606: PPUSH
83607: NOP4
83611: PPUSH
83612: NOP4
83616: PUSH
83617: LD_INT 1
83619: ARRAY
83620: PPUSH
83621: NOP4
83625: PPUSH
83626: NOP4
83630: PUSH
83631: LD_INT 2
83633: ARRAY
83634: EQUAL
83635: IFFALSE 83663
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
83637: NOP4
83641: PUSH
83642: NOP4
83646: ARRAY
83647: PPUSH
83648: NOP4
83652: PUSH
83653: LD_INT 1
83655: ARRAY
83656: PPUSH
83657: NOP4
83661: GO 83687
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83663: NOP4
83667: PUSH
83668: NOP4
83672: ARRAY
83673: PPUSH
83674: NOP4
83678: PUSH
83679: LD_INT 1
83681: ARRAY
83682: PPUSH
83683: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
83687: NOP4
83691: PUSH
83692: NOP4
83696: ARRAY
83697: PPUSH
83698: NOP4
83702: PUSH
83703: LD_INT 29
83705: EQUAL
83706: IFFALSE 84072
// begin if WantsToAttack ( group [ i ] ) in bombed then
83708: NOP4
83712: PUSH
83713: NOP4
83717: ARRAY
83718: PPUSH
83719: NOP4
83723: PUSH
83724: NOP4
83728: IN
83729: IFFALSE 83733
// continue ;
83731: GO 80737
// k := 8 ;
83733: NOP4
83737: PUSH
83738: LD_INT 8
83740: ST_TO_ADDR
// x := 0 ;
83741: NOP4
83745: PUSH
83746: LD_INT 0
83748: ST_TO_ADDR
// if tmp < k then
83749: NOP4
83753: PUSH
83754: NOP4
83758: LESS
83759: IFFALSE 83771
// k := tmp ;
83761: NOP4
83765: PUSH
83766: NOP4
83770: ST_TO_ADDR
// for j = 1 to k do
83771: NOP4
83775: PUSH
83776: DOUBLE
83777: LD_INT 1
83779: DEC
83780: ST_TO_ADDR
83781: NOP4
83785: PUSH
83786: FOR_TO
83787: IFFALSE 83919
// begin if GetType ( tmp [ j ] ) = unit_building then
83789: NOP4
83793: PUSH
83794: NOP4
83798: ARRAY
83799: PPUSH
83800: NOP4
83804: PUSH
83805: LD_INT 3
83807: EQUAL
83808: IFFALSE 83917
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
83810: NOP4
83814: PUSH
83815: NOP4
83819: ARRAY
83820: PUSH
83821: NOP4
83825: IN
83826: NOT
83827: PUSH
83828: NOP4
83832: PUSH
83833: NOP4
83837: ARRAY
83838: PPUSH
83839: NOP4
83843: AND
83844: IFFALSE 83917
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83846: NOP4
83850: PUSH
83851: NOP4
83855: ARRAY
83856: PPUSH
83857: NOP4
83861: PUSH
83862: NOP4
83866: ARRAY
83867: PPUSH
83868: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
83872: NOP4
83876: PUSH
83877: NOP4
83881: PPUSH
83882: NOP4
83886: PUSH
83887: LD_INT 1
83889: PLUS
83890: PPUSH
83891: NOP4
83895: PUSH
83896: NOP4
83900: ARRAY
83901: PPUSH
83902: NOP4
83906: ST_TO_ADDR
// attacking := true ;
83907: NOP4
83911: PUSH
83912: LD_INT 1
83914: ST_TO_ADDR
// break ;
83915: GO 83919
// end ; end ;
83917: GO 83786
83919: POP
83920: POP
// if not attacking and f_attack_depot then
83921: NOP4
83925: NOT
83926: PUSH
83927: NOP4
83931: AND
83932: IFFALSE 84027
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83934: NOP4
83938: PUSH
83939: NOP4
83943: PPUSH
83944: LD_INT 2
83946: PUSH
83947: LD_INT 30
83949: PUSH
83950: LD_INT 0
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 30
83959: PUSH
83960: LD_INT 1
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: LIST
83971: PPUSH
83972: NOP4
83976: ST_TO_ADDR
// if z then
83977: NOP4
83981: IFFALSE 84027
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
83983: NOP4
83987: PUSH
83988: NOP4
83992: ARRAY
83993: PPUSH
83994: NOP4
83998: PPUSH
83999: NOP4
84003: PUSH
84004: NOP4
84008: ARRAY
84009: PPUSH
84010: NOP4
84014: PPUSH
84015: NOP4
// attacking := true ;
84019: NOP4
84023: PUSH
84024: LD_INT 1
84026: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84027: NOP4
84031: PUSH
84032: NOP4
84036: ARRAY
84037: PPUSH
84038: NOP4
84042: PUSH
84043: LD_INT 500
84045: LESS
84046: IFFALSE 84072
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84048: NOP4
84052: PUSH
84053: NOP4
84057: ARRAY
84058: PPUSH
84059: NOP4
84063: PUSH
84064: LD_INT 1
84066: ARRAY
84067: PPUSH
84068: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84072: NOP4
84076: PUSH
84077: NOP4
84081: ARRAY
84082: PPUSH
84083: NOP4
84087: PUSH
84088: LD_INT 49
84090: EQUAL
84091: IFFALSE 84212
// begin if not HasTask ( group [ i ] ) then
84093: NOP4
84097: PUSH
84098: NOP4
84102: ARRAY
84103: PPUSH
84104: NOP4
84108: NOT
84109: IFFALSE 84212
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84111: NOP4
84115: PUSH
84116: LD_INT 81
84118: PUSH
84119: NOP4
84123: PUSH
84124: NOP4
84128: ARRAY
84129: PPUSH
84130: NOP4
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PPUSH
84139: NOP4
84143: PPUSH
84144: NOP4
84148: PUSH
84149: NOP4
84153: ARRAY
84154: PPUSH
84155: NOP4
84159: ST_TO_ADDR
// if k then
84160: NOP4
84164: IFFALSE 84212
// if GetDistUnits ( group [ i ] , k ) > 10 then
84166: NOP4
84170: PUSH
84171: NOP4
84175: ARRAY
84176: PPUSH
84177: NOP4
84181: PPUSH
84182: NOP4
84186: PUSH
84187: LD_INT 10
84189: GREATER
84190: IFFALSE 84212
// ComMoveUnit ( group [ i ] , k ) ;
84192: NOP4
84196: PUSH
84197: NOP4
84201: ARRAY
84202: PPUSH
84203: NOP4
84207: PPUSH
84208: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84212: NOP4
84216: PUSH
84217: NOP4
84221: ARRAY
84222: PPUSH
84223: NOP4
84227: PUSH
84228: LD_INT 250
84230: LESS
84231: PUSH
84232: NOP4
84236: PUSH
84237: NOP4
84241: ARRAY
84242: PUSH
84243: LD_INT 21
84245: PUSH
84246: LD_INT 2
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 23
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PPUSH
84267: NOP4
84271: IN
84272: AND
84273: IFFALSE 84398
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84275: NOP4
84279: PUSH
84280: NOP4
84284: PUSH
84285: NOP4
84289: PUSH
84290: NOP4
84294: ARRAY
84295: DIFF
84296: PPUSH
84297: NOP4
84301: PUSH
84302: NOP4
84306: ARRAY
84307: PPUSH
84308: NOP4
84312: ST_TO_ADDR
// if not k then
84313: NOP4
84317: NOT
84318: IFFALSE 84322
// continue ;
84320: GO 80737
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84322: NOP4
84326: PUSH
84327: LD_INT 81
84329: PUSH
84330: NOP4
84334: PUSH
84335: NOP4
84339: ARRAY
84340: PPUSH
84341: NOP4
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PPUSH
84350: NOP4
84354: IN
84355: PUSH
84356: NOP4
84360: PPUSH
84361: NOP4
84365: PUSH
84366: NOP4
84370: ARRAY
84371: PPUSH
84372: NOP4
84376: PUSH
84377: LD_INT 5
84379: LESS
84380: AND
84381: IFFALSE 84398
// ComAutodestruct ( group [ i ] ) ;
84383: NOP4
84387: PUSH
84388: NOP4
84392: ARRAY
84393: PPUSH
84394: NOP4
// end ; if f_attack_depot then
84398: NOP4
84402: IFFALSE 84514
// begin k := 6 ;
84404: NOP4
84408: PUSH
84409: LD_INT 6
84411: ST_TO_ADDR
// if tmp < k then
84412: NOP4
84416: PUSH
84417: NOP4
84421: LESS
84422: IFFALSE 84434
// k := tmp ;
84424: NOP4
84428: PUSH
84429: NOP4
84433: ST_TO_ADDR
// for j = 1 to k do
84434: NOP4
84438: PUSH
84439: DOUBLE
84440: LD_INT 1
84442: DEC
84443: ST_TO_ADDR
84444: NOP4
84448: PUSH
84449: FOR_TO
84450: IFFALSE 84512
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84452: NOP4
84456: PPUSH
84457: NOP4
84461: PUSH
84462: LD_INT 0
84464: PUSH
84465: LD_INT 1
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: IN
84472: IFFALSE 84510
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84474: NOP4
84478: PUSH
84479: NOP4
84483: ARRAY
84484: PPUSH
84485: NOP4
84489: PUSH
84490: NOP4
84494: ARRAY
84495: PPUSH
84496: NOP4
// attacking := true ;
84500: NOP4
84504: PUSH
84505: LD_INT 1
84507: ST_TO_ADDR
// break ;
84508: GO 84512
// end ;
84510: GO 84449
84512: POP
84513: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
84514: NOP4
84518: PUSH
84519: NOP4
84523: ARRAY
84524: PPUSH
84525: NOP4
84529: PUSH
84530: NOP4
84534: NOT
84535: AND
84536: IFFALSE 84858
// begin if GetTag ( group [ i ] ) = 71 then
84538: NOP4
84542: PUSH
84543: NOP4
84547: ARRAY
84548: PPUSH
84549: NOP4
84553: PUSH
84554: LD_INT 71
84556: EQUAL
84557: IFFALSE 84598
// begin if HasTask ( group [ i ] ) then
84559: NOP4
84563: PUSH
84564: NOP4
84568: ARRAY
84569: PPUSH
84570: NOP4
84574: IFFALSE 84580
// continue else
84576: GO 80737
84578: GO 84598
// SetTag ( group [ i ] , 0 ) ;
84580: NOP4
84584: PUSH
84585: NOP4
84589: ARRAY
84590: PPUSH
84591: LD_INT 0
84593: PPUSH
84594: NOP4
// end ; k := 8 ;
84598: NOP4
84602: PUSH
84603: LD_INT 8
84605: ST_TO_ADDR
// x := 0 ;
84606: NOP4
84610: PUSH
84611: LD_INT 0
84613: ST_TO_ADDR
// if tmp < k then
84614: NOP4
84618: PUSH
84619: NOP4
84623: LESS
84624: IFFALSE 84636
// k := tmp ;
84626: NOP4
84630: PUSH
84631: NOP4
84635: ST_TO_ADDR
// for j = 1 to k do
84636: NOP4
84640: PUSH
84641: DOUBLE
84642: LD_INT 1
84644: DEC
84645: ST_TO_ADDR
84646: NOP4
84650: PUSH
84651: FOR_TO
84652: IFFALSE 84750
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
84654: NOP4
84658: PUSH
84659: NOP4
84663: ARRAY
84664: PPUSH
84665: NOP4
84669: PUSH
84670: LD_INT 1
84672: EQUAL
84673: PUSH
84674: NOP4
84678: PUSH
84679: NOP4
84683: ARRAY
84684: PPUSH
84685: NOP4
84689: PUSH
84690: LD_INT 250
84692: LESS
84693: PUSH
84694: NOP4
84698: AND
84699: PUSH
84700: NOP4
84704: NOT
84705: PUSH
84706: NOP4
84710: PUSH
84711: NOP4
84715: ARRAY
84716: PPUSH
84717: NOP4
84721: PUSH
84722: LD_INT 250
84724: GREATEREQUAL
84725: AND
84726: OR
84727: AND
84728: IFFALSE 84748
// begin x := tmp [ j ] ;
84730: NOP4
84734: PUSH
84735: NOP4
84739: PUSH
84740: NOP4
84744: ARRAY
84745: ST_TO_ADDR
// break ;
84746: GO 84750
// end ;
84748: GO 84651
84750: POP
84751: POP
// if x then
84752: NOP4
84756: IFFALSE 84780
// ComAttackUnit ( group [ i ] , x ) else
84758: NOP4
84762: PUSH
84763: NOP4
84767: ARRAY
84768: PPUSH
84769: NOP4
84773: PPUSH
84774: NOP4
84778: GO 84804
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84780: NOP4
84784: PUSH
84785: NOP4
84789: ARRAY
84790: PPUSH
84791: NOP4
84795: PUSH
84796: LD_INT 1
84798: ARRAY
84799: PPUSH
84800: NOP4
// if not HasTask ( group [ i ] ) then
84804: NOP4
84808: PUSH
84809: NOP4
84813: ARRAY
84814: PPUSH
84815: NOP4
84819: NOT
84820: IFFALSE 84858
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
84822: NOP4
84826: PUSH
84827: NOP4
84831: ARRAY
84832: PPUSH
84833: NOP4
84837: PPUSH
84838: NOP4
84842: PUSH
84843: NOP4
84847: ARRAY
84848: PPUSH
84849: NOP4
84853: PPUSH
84854: NOP4
// end ; end ; end ;
84858: GO 80737
84860: POP
84861: POP
// wait ( 0 0$2 ) ;
84862: LD_INT 70
84864: PPUSH
84865: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
84869: NOP4
84873: NOT
84874: PUSH
84875: NOP4
84879: PUSH
84880: EMPTY
84881: EQUAL
84882: OR
84883: PUSH
84884: LD_INT 81
84886: PUSH
84887: NOP4
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PPUSH
84896: NOP4
84900: NOT
84901: OR
84902: IFFALSE 80722
// end ;
84904: LD_VAR 0 2
84908: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
84909: LD_INT 0
84911: PPUSH
84912: PPUSH
84913: PPUSH
84914: PPUSH
84915: PPUSH
84916: PPUSH
// if not base or not mc_bases [ base ] or not solds then
84917: NOP4
84921: NOT
84922: PUSH
84923: NOP4
84927: PUSH
84928: NOP4
84932: ARRAY
84933: NOT
84934: OR
84935: PUSH
84936: NOP4
84940: NOT
84941: OR
84942: IFFALSE 84946
// exit ;
84944: GO 85500
// side := mc_sides [ base ] ;
84946: NOP4
84950: PUSH
84951: NOP4
84955: PUSH
84956: NOP4
84960: ARRAY
84961: ST_TO_ADDR
// if not side then
84962: NOP4
84966: NOT
84967: IFFALSE 84971
// exit ;
84969: GO 85500
// for i in solds do
84971: NOP4
84975: PUSH
84976: NOP4
84980: PUSH
84981: FOR_IN
84982: IFFALSE 85043
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
84984: NOP4
84988: PPUSH
84989: NOP4
84993: PPUSH
84994: NOP4
84998: PUSH
84999: LD_INT 32
85001: PUSH
85002: LD_INT 31
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: IN
85009: IFFALSE 85029
// solds := solds diff i else
85011: NOP4
85015: PUSH
85016: NOP4
85020: PUSH
85021: NOP4
85025: DIFF
85026: ST_TO_ADDR
85027: GO 85041
// SetTag ( i , 18 ) ;
85029: NOP4
85033: PPUSH
85034: LD_INT 18
85036: PPUSH
85037: NOP4
85041: GO 84981
85043: POP
85044: POP
// if not solds then
85045: NOP4
85049: NOT
85050: IFFALSE 85054
// exit ;
85052: GO 85500
// repeat wait ( 0 0$2 ) ;
85054: LD_INT 70
85056: PPUSH
85057: NOP4
// enemy := mc_scan [ base ] ;
85061: NOP4
85065: PUSH
85066: NOP4
85070: PUSH
85071: NOP4
85075: ARRAY
85076: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85077: NOP4
85081: PUSH
85082: NOP4
85086: ARRAY
85087: NOT
85088: PUSH
85089: NOP4
85093: PUSH
85094: NOP4
85098: ARRAY
85099: PUSH
85100: EMPTY
85101: EQUAL
85102: OR
85103: IFFALSE 85140
// begin for i in solds do
85105: NOP4
85109: PUSH
85110: NOP4
85114: PUSH
85115: FOR_IN
85116: IFFALSE 85129
// ComStop ( i ) ;
85118: NOP4
85122: PPUSH
85123: NOP4
85127: GO 85115
85129: POP
85130: POP
// solds := [ ] ;
85131: NOP4
85135: PUSH
85136: EMPTY
85137: ST_TO_ADDR
// exit ;
85138: GO 85500
// end ; for i in solds do
85140: NOP4
85144: PUSH
85145: NOP4
85149: PUSH
85150: FOR_IN
85151: IFFALSE 85472
// begin if IsInUnit ( i ) then
85153: NOP4
85157: PPUSH
85158: NOP4
85162: IFFALSE 85173
// ComExitBuilding ( i ) ;
85164: NOP4
85168: PPUSH
85169: NOP4
// if GetLives ( i ) > 500 then
85173: NOP4
85177: PPUSH
85178: NOP4
85182: PUSH
85183: LD_INT 500
85185: GREATER
85186: IFFALSE 85239
// begin e := NearestUnitToUnit ( enemy , i ) ;
85188: NOP4
85192: PUSH
85193: NOP4
85197: PPUSH
85198: NOP4
85202: PPUSH
85203: NOP4
85207: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85208: NOP4
85212: PPUSH
85213: NOP4
85217: PPUSH
85218: NOP4
85222: PPUSH
85223: NOP4
85227: PPUSH
85228: NOP4
85232: PPUSH
85233: NOP4
// end else
85237: GO 85470
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85239: NOP4
85243: PPUSH
85244: NOP4
85248: PUSH
85249: NOP4
85253: ARRAY
85254: PPUSH
85255: LD_INT 2
85257: PUSH
85258: LD_INT 30
85260: PUSH
85261: LD_INT 0
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 30
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 30
85280: PUSH
85281: LD_INT 6
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: PPUSH
85294: NOP4
85298: PPUSH
85299: NOP4
85303: PPUSH
85304: NOP4
85308: PPUSH
85309: NOP4
85313: PUSH
85314: LD_INT 10
85316: GREATER
85317: IFFALSE 85470
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85319: NOP4
85323: PUSH
85324: NOP4
85328: PUSH
85329: NOP4
85333: ARRAY
85334: PPUSH
85335: LD_INT 2
85337: PUSH
85338: LD_INT 30
85340: PUSH
85341: LD_INT 0
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 30
85350: PUSH
85351: LD_INT 1
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 30
85360: PUSH
85361: LD_INT 6
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: EMPTY
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: PPUSH
85374: NOP4
85378: PPUSH
85379: NOP4
85383: PPUSH
85384: NOP4
85388: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85389: NOP4
85393: PPUSH
85394: NOP4
85398: PPUSH
85399: NOP4
85403: PPUSH
85404: LD_INT 3
85406: PPUSH
85407: LD_INT 5
85409: PPUSH
85410: NOP4
85414: PPUSH
85415: NOP4
85419: PPUSH
85420: NOP4
85424: PPUSH
85425: LD_INT 3
85427: PPUSH
85428: LD_INT 5
85430: PPUSH
85431: NOP4
85435: PPUSH
85436: NOP4
// SetTag ( i , 0 ) ;
85440: NOP4
85444: PPUSH
85445: LD_INT 0
85447: PPUSH
85448: NOP4
// solds := solds diff i ;
85452: NOP4
85456: PUSH
85457: NOP4
85461: PUSH
85462: NOP4
85466: DIFF
85467: ST_TO_ADDR
// continue ;
85468: GO 85150
// end ; end ;
85470: GO 85150
85472: POP
85473: POP
// until not solds or not enemy ;
85474: NOP4
85478: NOT
85479: PUSH
85480: NOP4
85484: NOT
85485: OR
85486: IFFALSE 85054
// MC_Reset ( base , 18 ) ;
85488: NOP4
85492: PPUSH
85493: LD_INT 18
85495: PPUSH
85496: NOP4
// end ;
85500: LD_VAR 0 3
85504: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
85505: LD_INT 0
85507: PPUSH
85508: PPUSH
85509: PPUSH
85510: PPUSH
85511: PPUSH
85512: PPUSH
85513: PPUSH
85514: PPUSH
85515: PPUSH
85516: PPUSH
85517: PPUSH
85518: PPUSH
85519: PPUSH
85520: PPUSH
85521: PPUSH
85522: PPUSH
85523: PPUSH
85524: PPUSH
85525: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
85526: NOP4
85530: PUSH
85531: NOP4
85535: PUSH
85536: NOP4
85540: ARRAY
85541: PPUSH
85542: LD_INT 25
85544: PUSH
85545: LD_INT 3
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PPUSH
85552: NOP4
85556: ST_TO_ADDR
// if mc_remote_driver [ base ] then
85557: NOP4
85561: PUSH
85562: NOP4
85566: ARRAY
85567: IFFALSE 85591
// mechs := mechs diff mc_remote_driver [ base ] ;
85569: NOP4
85573: PUSH
85574: NOP4
85578: PUSH
85579: NOP4
85583: PUSH
85584: NOP4
85588: ARRAY
85589: DIFF
85590: ST_TO_ADDR
// for i in mechs do
85591: NOP4
85595: PUSH
85596: NOP4
85600: PUSH
85601: FOR_IN
85602: IFFALSE 85637
// if GetTag ( i ) > 0 then
85604: NOP4
85608: PPUSH
85609: NOP4
85613: PUSH
85614: LD_INT 0
85616: GREATER
85617: IFFALSE 85635
// mechs := mechs diff i ;
85619: NOP4
85623: PUSH
85624: NOP4
85628: PUSH
85629: NOP4
85633: DIFF
85634: ST_TO_ADDR
85635: GO 85601
85637: POP
85638: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85639: NOP4
85643: PUSH
85644: NOP4
85648: PUSH
85649: NOP4
85653: ARRAY
85654: PPUSH
85655: LD_INT 2
85657: PUSH
85658: LD_INT 25
85660: PUSH
85661: LD_INT 1
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 25
85670: PUSH
85671: LD_INT 5
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 25
85680: PUSH
85681: LD_INT 8
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 25
85690: PUSH
85691: LD_INT 9
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: PPUSH
85705: NOP4
85709: ST_TO_ADDR
// if not defenders and not solds then
85710: NOP4
85714: NOT
85715: PUSH
85716: NOP4
85720: NOT
85721: AND
85722: IFFALSE 85726
// exit ;
85724: GO 87496
// depot_under_attack := false ;
85726: NOP4
85730: PUSH
85731: LD_INT 0
85733: ST_TO_ADDR
// sold_defenders := [ ] ;
85734: NOP4
85738: PUSH
85739: EMPTY
85740: ST_TO_ADDR
// if mechs then
85741: NOP4
85745: IFFALSE 85898
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
85747: NOP4
85751: PUSH
85752: NOP4
85756: PPUSH
85757: LD_INT 21
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PPUSH
85767: NOP4
85771: PUSH
85772: FOR_IN
85773: IFFALSE 85896
// begin if GetTag ( i ) <> 20 then
85775: NOP4
85779: PPUSH
85780: NOP4
85784: PUSH
85785: LD_INT 20
85787: NONEQUAL
85788: IFFALSE 85802
// SetTag ( i , 20 ) ;
85790: NOP4
85794: PPUSH
85795: LD_INT 20
85797: PPUSH
85798: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
85802: NOP4
85806: PPUSH
85807: NOP4
85811: PUSH
85812: LD_INT 1
85814: EQUAL
85815: PUSH
85816: NOP4
85820: PPUSH
85821: NOP4
85825: NOT
85826: AND
85827: IFFALSE 85894
// begin un := mechs [ 1 ] ;
85829: NOP4
85833: PUSH
85834: NOP4
85838: PUSH
85839: LD_INT 1
85841: ARRAY
85842: ST_TO_ADDR
// ComExit ( un ) ;
85843: NOP4
85847: PPUSH
85848: NOP4
// AddComEnterUnit ( un , i ) ;
85852: NOP4
85856: PPUSH
85857: NOP4
85861: PPUSH
85862: NOP4
// SetTag ( un , 19 ) ;
85866: NOP4
85870: PPUSH
85871: LD_INT 19
85873: PPUSH
85874: NOP4
// mechs := mechs diff un ;
85878: NOP4
85882: PUSH
85883: NOP4
85887: PUSH
85888: NOP4
85892: DIFF
85893: ST_TO_ADDR
// end ; end ;
85894: GO 85772
85896: POP
85897: POP
// if solds then
85898: NOP4
85902: IFFALSE 85961
// for i in solds do
85904: NOP4
85908: PUSH
85909: NOP4
85913: PUSH
85914: FOR_IN
85915: IFFALSE 85959
// if not GetTag ( i ) then
85917: NOP4
85921: PPUSH
85922: NOP4
85926: NOT
85927: IFFALSE 85957
// begin defenders := defenders union i ;
85929: NOP4
85933: PUSH
85934: NOP4
85938: PUSH
85939: NOP4
85943: UNION
85944: ST_TO_ADDR
// SetTag ( i , 18 ) ;
85945: NOP4
85949: PPUSH
85950: LD_INT 18
85952: PPUSH
85953: NOP4
// end ;
85957: GO 85914
85959: POP
85960: POP
// repeat wait ( 0 0$2 ) ;
85961: LD_INT 70
85963: PPUSH
85964: NOP4
// enemy := mc_scan [ base ] ;
85968: NOP4
85972: PUSH
85973: NOP4
85977: PUSH
85978: NOP4
85982: ARRAY
85983: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85984: NOP4
85988: PUSH
85989: NOP4
85993: ARRAY
85994: NOT
85995: PUSH
85996: NOP4
86000: PUSH
86001: NOP4
86005: ARRAY
86006: PUSH
86007: EMPTY
86008: EQUAL
86009: OR
86010: IFFALSE 86047
// begin for i in defenders do
86012: NOP4
86016: PUSH
86017: NOP4
86021: PUSH
86022: FOR_IN
86023: IFFALSE 86036
// ComStop ( i ) ;
86025: NOP4
86029: PPUSH
86030: NOP4
86034: GO 86022
86036: POP
86037: POP
// defenders := [ ] ;
86038: NOP4
86042: PUSH
86043: EMPTY
86044: ST_TO_ADDR
// exit ;
86045: GO 87496
// end ; for i in defenders do
86047: NOP4
86051: PUSH
86052: NOP4
86056: PUSH
86057: FOR_IN
86058: IFFALSE 86956
// begin e := NearestUnitToUnit ( enemy , i ) ;
86060: NOP4
86064: PUSH
86065: NOP4
86069: PPUSH
86070: NOP4
86074: PPUSH
86075: NOP4
86079: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86080: NOP4
86084: PUSH
86085: NOP4
86089: PUSH
86090: NOP4
86094: ARRAY
86095: PPUSH
86096: LD_INT 2
86098: PUSH
86099: LD_INT 30
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 30
86111: PUSH
86112: LD_INT 1
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: LIST
86123: PPUSH
86124: NOP4
86128: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86129: NOP4
86133: PUSH
86134: NOP4
86138: NOT
86139: PUSH
86140: NOP4
86144: PPUSH
86145: LD_INT 3
86147: PUSH
86148: LD_INT 24
86150: PUSH
86151: LD_INT 600
86153: PUSH
86154: EMPTY
86155: LIST
86156: LIST
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PPUSH
86162: NOP4
86166: OR
86167: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86168: NOP4
86172: PPUSH
86173: NOP4
86177: PUSH
86178: LD_INT 2
86180: DOUBLE
86181: EQUAL
86182: IFTRUE 86186
86184: GO 86582
86186: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86187: NOP4
86191: PPUSH
86192: NOP4
86196: PUSH
86197: LD_INT 1000
86199: EQUAL
86200: PUSH
86201: NOP4
86205: PPUSH
86206: NOP4
86210: PPUSH
86211: NOP4
86215: PUSH
86216: LD_INT 40
86218: LESS
86219: PUSH
86220: NOP4
86224: PPUSH
86225: NOP4
86229: PUSH
86230: NOP4
86234: ARRAY
86235: PPUSH
86236: NOP4
86240: OR
86241: AND
86242: IFFALSE 86364
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86244: NOP4
86248: PPUSH
86249: NOP4
86253: PUSH
86254: LD_INT 1
86256: EQUAL
86257: PUSH
86258: NOP4
86262: PPUSH
86263: NOP4
86267: PUSH
86268: LD_INT 30
86270: LESS
86271: AND
86272: PUSH
86273: NOP4
86277: AND
86278: IFFALSE 86348
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86280: NOP4
86284: PPUSH
86285: NOP4
86289: PPUSH
86290: NOP4
86294: PPUSH
86295: NOP4
86299: PPUSH
86300: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86304: NOP4
86308: PPUSH
86309: NOP4
86313: PPUSH
86314: NOP4
86318: PPUSH
86319: NOP4
86323: PPUSH
86324: NOP4
86328: PUSH
86329: LD_INT 6
86331: LESS
86332: IFFALSE 86346
// SetFuel ( i , 100 ) ;
86334: NOP4
86338: PPUSH
86339: LD_INT 100
86341: PPUSH
86342: NOP4
// end else
86346: GO 86362
// ComAttackUnit ( i , e ) ;
86348: NOP4
86352: PPUSH
86353: NOP4
86357: PPUSH
86358: NOP4
// end else
86362: GO 86465
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86364: NOP4
86368: PPUSH
86369: NOP4
86373: PUSH
86374: NOP4
86378: ARRAY
86379: PPUSH
86380: NOP4
86384: NOT
86385: PUSH
86386: NOP4
86390: PPUSH
86391: NOP4
86395: PPUSH
86396: NOP4
86400: PUSH
86401: LD_INT 40
86403: GREATEREQUAL
86404: AND
86405: PUSH
86406: NOP4
86410: PPUSH
86411: NOP4
86415: PUSH
86416: LD_INT 650
86418: LESSEQUAL
86419: OR
86420: PUSH
86421: NOP4
86425: PPUSH
86426: NOP4
86430: PUSH
86431: NOP4
86435: ARRAY
86436: PPUSH
86437: NOP4
86441: NOT
86442: AND
86443: IFFALSE 86465
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86445: NOP4
86449: PPUSH
86450: NOP4
86454: PUSH
86455: NOP4
86459: ARRAY
86460: PPUSH
86461: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
86465: NOP4
86469: PPUSH
86470: NOP4
86474: PUSH
86475: LD_INT 1000
86477: LESS
86478: PUSH
86479: NOP4
86483: PPUSH
86484: NOP4
86488: PUSH
86489: LD_INT 1
86491: EQUAL
86492: AND
86493: PUSH
86494: NOP4
86498: PPUSH
86499: NOP4
86503: AND
86504: PUSH
86505: NOP4
86509: PPUSH
86510: NOP4
86514: PUSH
86515: NOP4
86519: ARRAY
86520: PPUSH
86521: NOP4
86525: AND
86526: IFFALSE 86580
// begin mech := IsDrivenBy ( i ) ;
86528: NOP4
86532: PUSH
86533: NOP4
86537: PPUSH
86538: NOP4
86542: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
86543: NOP4
86547: PPUSH
86548: NOP4
// AddComRepairVehicle ( mech , i ) ;
86552: NOP4
86556: PPUSH
86557: NOP4
86561: PPUSH
86562: NOP4
// AddComEnterUnit ( mech , i ) ;
86566: NOP4
86570: PPUSH
86571: NOP4
86575: PPUSH
86576: NOP4
// end ; end ; unit_human :
86580: GO 86927
86582: LD_INT 1
86584: DOUBLE
86585: EQUAL
86586: IFTRUE 86590
86588: GO 86926
86590: POP
// begin b := IsInUnit ( i ) ;
86591: NOP4
86595: PUSH
86596: NOP4
86600: PPUSH
86601: NOP4
86605: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
86606: NOP4
86610: PUSH
86611: NOP4
86615: NOT
86616: PUSH
86617: NOP4
86621: PPUSH
86622: NOP4
86626: PUSH
86627: LD_INT 32
86629: PUSH
86630: LD_INT 31
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: IN
86637: OR
86638: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
86639: NOP4
86643: PPUSH
86644: NOP4
86648: PUSH
86649: LD_INT 5
86651: EQUAL
86652: PUSH
86653: NOP4
86657: PPUSH
86658: NOP4
86662: PUSH
86663: LD_INT 1
86665: PUSH
86666: LD_INT 2
86668: PUSH
86669: LD_INT 3
86671: PUSH
86672: LD_INT 4
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: IN
86681: AND
86682: IFFALSE 86719
// begin class := AllowSpecClass ( i ) ;
86684: NOP4
86688: PUSH
86689: NOP4
86693: PPUSH
86694: NOP4
86698: ST_TO_ADDR
// if class then
86699: NOP4
86703: IFFALSE 86719
// ComChangeProfession ( i , class ) ;
86705: NOP4
86709: PPUSH
86710: NOP4
86714: PPUSH
86715: NOP4
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
86719: NOP4
86723: PUSH
86724: NOP4
86728: PPUSH
86729: LD_INT 21
86731: PUSH
86732: LD_INT 2
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PPUSH
86739: NOP4
86743: PUSH
86744: LD_INT 1
86746: LESSEQUAL
86747: OR
86748: PUSH
86749: NOP4
86753: AND
86754: PUSH
86755: NOP4
86759: PUSH
86760: NOP4
86764: IN
86765: NOT
86766: AND
86767: IFFALSE 86860
// begin if b then
86769: NOP4
86773: IFFALSE 86822
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
86775: NOP4
86779: PPUSH
86780: NOP4
86784: PPUSH
86785: NOP4
86789: PPUSH
86790: NOP4
86794: PPUSH
86795: NOP4
86799: PUSH
86800: LD_INT 10
86802: LESS
86803: PUSH
86804: NOP4
86808: PPUSH
86809: NOP4
86813: PUSH
86814: LD_INT 7
86816: NONEQUAL
86817: AND
86818: IFFALSE 86822
// continue ;
86820: GO 86057
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
86822: NOP4
86826: PUSH
86827: NOP4
86831: PPUSH
86832: NOP4
86836: PUSH
86837: LD_INT 1
86839: PLUS
86840: PPUSH
86841: NOP4
86845: PPUSH
86846: NOP4
86850: ST_TO_ADDR
// ComExitBuilding ( i ) ;
86851: NOP4
86855: PPUSH
86856: NOP4
// end ; if sold_defenders then
86860: NOP4
86864: IFFALSE 86924
// if i in sold_defenders then
86866: NOP4
86870: PUSH
86871: NOP4
86875: IN
86876: IFFALSE 86924
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
86878: NOP4
86882: PPUSH
86883: NOP4
86887: NOT
86888: PUSH
86889: NOP4
86893: PPUSH
86894: NOP4
86898: PPUSH
86899: NOP4
86903: PUSH
86904: LD_INT 30
86906: LESS
86907: AND
86908: IFFALSE 86924
// ComAttackUnit ( i , e ) ;
86910: NOP4
86914: PPUSH
86915: NOP4
86919: PPUSH
86920: NOP4
// end ; end ; end ;
86924: GO 86927
86926: POP
// if IsDead ( i ) then
86927: NOP4
86931: PPUSH
86932: NOP4
86936: IFFALSE 86954
// defenders := defenders diff i ;
86938: NOP4
86942: PUSH
86943: NOP4
86947: PUSH
86948: NOP4
86952: DIFF
86953: ST_TO_ADDR
// end ;
86954: GO 86057
86956: POP
86957: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
86958: NOP4
86962: NOT
86963: PUSH
86964: NOP4
86968: NOT
86969: OR
86970: PUSH
86971: NOP4
86975: PUSH
86976: NOP4
86980: ARRAY
86981: NOT
86982: OR
86983: IFFALSE 85961
// MC_Reset ( base , 18 ) ;
86985: NOP4
86989: PPUSH
86990: LD_INT 18
86992: PPUSH
86993: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86997: NOP4
87001: PUSH
87002: NOP4
87006: PUSH
87007: NOP4
87011: PPUSH
87012: LD_INT 2
87014: PUSH
87015: LD_INT 25
87017: PUSH
87018: LD_INT 1
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 25
87027: PUSH
87028: LD_INT 5
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 25
87037: PUSH
87038: LD_INT 8
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 25
87047: PUSH
87048: LD_INT 9
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: PPUSH
87062: NOP4
87066: DIFF
87067: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87068: NOP4
87072: NOT
87073: PUSH
87074: NOP4
87078: PPUSH
87079: LD_INT 21
87081: PUSH
87082: LD_INT 2
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PPUSH
87089: NOP4
87093: AND
87094: IFFALSE 87432
// begin tmp := FilterByTag ( defenders , 19 ) ;
87096: NOP4
87100: PUSH
87101: NOP4
87105: PPUSH
87106: LD_INT 19
87108: PPUSH
87109: NOP4
87113: ST_TO_ADDR
// if tmp then
87114: NOP4
87118: IFFALSE 87188
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87120: NOP4
87124: PUSH
87125: NOP4
87129: PPUSH
87130: LD_INT 25
87132: PUSH
87133: LD_INT 3
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PPUSH
87140: NOP4
87144: ST_TO_ADDR
// if tmp then
87145: NOP4
87149: IFFALSE 87188
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87151: NOP4
87155: PUSH
87156: NOP4
87160: PPUSH
87161: NOP4
87165: PPUSH
87166: NOP4
87170: PUSH
87171: NOP4
87175: ARRAY
87176: PUSH
87177: NOP4
87181: UNION
87182: PPUSH
87183: NOP4
87187: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87188: NOP4
87192: PPUSH
87193: LD_INT 19
87195: PPUSH
87196: NOP4
// repeat wait ( 0 0$1 ) ;
87200: LD_INT 35
87202: PPUSH
87203: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87207: NOP4
87211: PUSH
87212: NOP4
87216: ARRAY
87217: NOT
87218: PUSH
87219: NOP4
87223: PUSH
87224: NOP4
87228: ARRAY
87229: PUSH
87230: EMPTY
87231: EQUAL
87232: OR
87233: IFFALSE 87270
// begin for i in defenders do
87235: NOP4
87239: PUSH
87240: NOP4
87244: PUSH
87245: FOR_IN
87246: IFFALSE 87259
// ComStop ( i ) ;
87248: NOP4
87252: PPUSH
87253: NOP4
87257: GO 87245
87259: POP
87260: POP
// defenders := [ ] ;
87261: NOP4
87265: PUSH
87266: EMPTY
87267: ST_TO_ADDR
// exit ;
87268: GO 87496
// end ; for i in defenders do
87270: NOP4
87274: PUSH
87275: NOP4
87279: PUSH
87280: FOR_IN
87281: IFFALSE 87370
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87283: NOP4
87287: PPUSH
87288: NOP4
87292: PUSH
87293: NOP4
87297: ARRAY
87298: PPUSH
87299: NOP4
87303: NOT
87304: IFFALSE 87328
// ComMoveToArea ( i , mc_parking [ base ] ) else
87306: NOP4
87310: PPUSH
87311: NOP4
87315: PUSH
87316: NOP4
87320: ARRAY
87321: PPUSH
87322: NOP4
87326: GO 87368
// if GetControl ( i ) = control_manual then
87328: NOP4
87332: PPUSH
87333: NOP4
87337: PUSH
87338: LD_INT 1
87340: EQUAL
87341: IFFALSE 87368
// if IsDrivenBy ( i ) then
87343: NOP4
87347: PPUSH
87348: NOP4
87352: IFFALSE 87368
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87354: NOP4
87358: PPUSH
87359: NOP4
87363: PPUSH
87364: NOP4
// end ;
87368: GO 87280
87370: POP
87371: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87372: NOP4
87376: PPUSH
87377: LD_INT 95
87379: PUSH
87380: NOP4
87384: PUSH
87385: NOP4
87389: ARRAY
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PPUSH
87395: NOP4
87399: PUSH
87400: NOP4
87404: EQUAL
87405: PUSH
87406: NOP4
87410: PUSH
87411: NOP4
87415: ARRAY
87416: OR
87417: PUSH
87418: NOP4
87422: PUSH
87423: NOP4
87427: ARRAY
87428: NOT
87429: OR
87430: IFFALSE 87200
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87432: NOP4
87436: PUSH
87437: NOP4
87441: PPUSH
87442: NOP4
87446: PPUSH
87447: NOP4
87451: PPUSH
87452: LD_INT 21
87454: PUSH
87455: LD_INT 2
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PPUSH
87462: NOP4
87466: PPUSH
87467: NOP4
87471: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
87472: NOP4
87476: PPUSH
87477: LD_INT 19
87479: PPUSH
87480: NOP4
// MC_Reset ( base , 20 ) ;
87484: NOP4
87488: PPUSH
87489: LD_INT 20
87491: PPUSH
87492: NOP4
// end ; end_of_file
87496: LD_VAR 0 3
87500: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
87501: LD_INT 0
87503: PPUSH
87504: PPUSH
87505: PPUSH
87506: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87507: NOP4
87511: PPUSH
87512: NOP4
87516: PUSH
87517: NOP4
87521: EQUAL
87522: IFFALSE 87594
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87524: LD_INT 68
87526: PPUSH
87527: NOP4
87531: PPUSH
87532: NOP4
87536: PPUSH
87537: NOP4
87541: PUSH
87542: LD_INT 2
87544: EQUAL
87545: IFFALSE 87557
// eff := 70 else
87547: NOP4
87551: PUSH
87552: LD_INT 70
87554: ST_TO_ADDR
87555: GO 87565
// eff := 30 ;
87557: NOP4
87561: PUSH
87562: LD_INT 30
87564: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87565: NOP4
87569: PPUSH
87570: NOP4
87574: PPUSH
87575: NOP4
87579: PPUSH
87580: NOP4
87584: PPUSH
87585: NOP4
87589: PPUSH
87590: NOP4
// end ; end ;
87594: LD_VAR 0 2
87598: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
87599: LD_INT 0
87601: PPUSH
// end ;
87602: LD_VAR 0 4
87606: RET
// export function SOS_Command ( cmd ) ; begin
87607: LD_INT 0
87609: PPUSH
// end ;
87610: LD_VAR 0 2
87614: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
87615: LD_INT 0
87617: PPUSH
// end ;
87618: LD_VAR 0 6
87622: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
87623: LD_INT 0
87625: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
87626: NOP4
87630: PUSH
87631: LD_INT 250
87633: EQUAL
87634: PUSH
87635: NOP4
87639: PPUSH
87640: NOP4
87644: PUSH
87645: NOP4
87649: EQUAL
87650: AND
87651: IFFALSE 87672
// MinerPlaceMine ( unit , x , y ) ;
87653: NOP4
87657: PPUSH
87658: NOP4
87662: PPUSH
87663: NOP4
87667: PPUSH
87668: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
87672: NOP4
87676: PUSH
87677: LD_INT 251
87679: EQUAL
87680: PUSH
87681: NOP4
87685: PPUSH
87686: NOP4
87690: PUSH
87691: NOP4
87695: EQUAL
87696: AND
87697: IFFALSE 87718
// MinerDetonateMine ( unit , x , y ) ;
87699: NOP4
87703: PPUSH
87704: NOP4
87708: PPUSH
87709: NOP4
87713: PPUSH
87714: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
87718: NOP4
87722: PUSH
87723: LD_INT 252
87725: EQUAL
87726: PUSH
87727: NOP4
87731: PPUSH
87732: NOP4
87736: PUSH
87737: NOP4
87741: EQUAL
87742: AND
87743: IFFALSE 87764
// MinerCreateMinefield ( unit , x , y ) ;
87745: NOP4
87749: PPUSH
87750: NOP4
87754: PPUSH
87755: NOP4
87759: PPUSH
87760: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
87764: NOP4
87768: PUSH
87769: LD_INT 253
87771: EQUAL
87772: PUSH
87773: NOP4
87777: PPUSH
87778: NOP4
87782: PUSH
87783: LD_INT 5
87785: EQUAL
87786: AND
87787: IFFALSE 87808
// ComBinocular ( unit , x , y ) ;
87789: NOP4
87793: PPUSH
87794: NOP4
87798: PPUSH
87799: NOP4
87803: PPUSH
87804: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
87808: NOP4
87812: PUSH
87813: LD_INT 254
87815: EQUAL
87816: PUSH
87817: NOP4
87821: PPUSH
87822: NOP4
87826: PUSH
87827: NOP4
87831: EQUAL
87832: AND
87833: PUSH
87834: NOP4
87838: PPUSH
87839: NOP4
87843: PUSH
87844: LD_INT 3
87846: EQUAL
87847: AND
87848: IFFALSE 87864
// HackDestroyVehicle ( unit , selectedUnit ) ;
87850: NOP4
87854: PPUSH
87855: NOP4
87859: PPUSH
87860: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
87864: NOP4
87868: PUSH
87869: LD_INT 255
87871: EQUAL
87872: PUSH
87873: NOP4
87877: PPUSH
87878: NOP4
87882: PUSH
87883: LD_INT 14
87885: PUSH
87886: LD_INT 53
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: IN
87893: AND
87894: PUSH
87895: NOP4
87899: PPUSH
87900: NOP4
87904: PPUSH
87905: NOP4
87909: AND
87910: IFFALSE 87934
// CutTreeXYR ( unit , x , y , 12 ) ;
87912: NOP4
87916: PPUSH
87917: NOP4
87921: PPUSH
87922: NOP4
87926: PPUSH
87927: LD_INT 12
87929: PPUSH
87930: NOP4
// end ;
87934: LD_VAR 0 6
87938: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
87939: LD_INT 0
87941: PPUSH
// end ;
87942: LD_VAR 0 4
87946: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87947: LD_INT 0
87949: PPUSH
87950: PPUSH
87951: PPUSH
87952: PPUSH
87953: PPUSH
87954: PPUSH
87955: PPUSH
87956: PPUSH
87957: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87958: NOP4
87962: NOT
87963: PUSH
87964: NOP4
87968: PPUSH
87969: NOP4
87973: PPUSH
87974: NOP4
87978: NOT
87979: OR
87980: PUSH
87981: NOP4
87985: NOT
87986: OR
87987: IFFALSE 87991
// exit ;
87989: GO 88331
// list := [ ] ;
87991: NOP4
87995: PUSH
87996: EMPTY
87997: ST_TO_ADDR
// if x - r < 0 then
87998: NOP4
88002: PUSH
88003: NOP4
88007: MINUS
88008: PUSH
88009: LD_INT 0
88011: LESS
88012: IFFALSE 88024
// min_x := 0 else
88014: NOP4
88018: PUSH
88019: LD_INT 0
88021: ST_TO_ADDR
88022: GO 88040
// min_x := x - r ;
88024: NOP4
88028: PUSH
88029: NOP4
88033: PUSH
88034: NOP4
88038: MINUS
88039: ST_TO_ADDR
// if y - r < 0 then
88040: NOP4
88044: PUSH
88045: NOP4
88049: MINUS
88050: PUSH
88051: LD_INT 0
88053: LESS
88054: IFFALSE 88066
// min_y := 0 else
88056: NOP4
88060: PUSH
88061: LD_INT 0
88063: ST_TO_ADDR
88064: GO 88082
// min_y := y - r ;
88066: NOP4
88070: PUSH
88071: NOP4
88075: PUSH
88076: NOP4
88080: MINUS
88081: ST_TO_ADDR
// max_x := x + r ;
88082: NOP4
88086: PUSH
88087: NOP4
88091: PUSH
88092: NOP4
88096: PLUS
88097: ST_TO_ADDR
// max_y := y + r ;
88098: NOP4
88102: PUSH
88103: NOP4
88107: PUSH
88108: NOP4
88112: PLUS
88113: ST_TO_ADDR
// for _x = min_x to max_x do
88114: NOP4
88118: PUSH
88119: DOUBLE
88120: NOP4
88124: DEC
88125: ST_TO_ADDR
88126: NOP4
88130: PUSH
88131: FOR_TO
88132: IFFALSE 88249
// for _y = min_y to max_y do
88134: NOP4
88138: PUSH
88139: DOUBLE
88140: NOP4
88144: DEC
88145: ST_TO_ADDR
88146: NOP4
88150: PUSH
88151: FOR_TO
88152: IFFALSE 88245
// begin if not ValidHex ( _x , _y ) then
88154: NOP4
88158: PPUSH
88159: NOP4
88163: PPUSH
88164: NOP4
88168: NOT
88169: IFFALSE 88173
// continue ;
88171: GO 88151
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88173: NOP4
88177: PPUSH
88178: NOP4
88182: PPUSH
88183: NOP4
88187: PUSH
88188: NOP4
88192: PPUSH
88193: NOP4
88197: PPUSH
88198: NOP4
88202: AND
88203: IFFALSE 88243
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88205: NOP4
88209: PUSH
88210: NOP4
88214: PPUSH
88215: NOP4
88219: PUSH
88220: LD_INT 1
88222: PLUS
88223: PPUSH
88224: NOP4
88228: PUSH
88229: NOP4
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PPUSH
88238: NOP4
88242: ST_TO_ADDR
// end ;
88243: GO 88151
88245: POP
88246: POP
88247: GO 88131
88249: POP
88250: POP
// if not list then
88251: NOP4
88255: NOT
88256: IFFALSE 88260
// exit ;
88258: GO 88331
// for i in list do
88260: NOP4
88264: PUSH
88265: NOP4
88269: PUSH
88270: FOR_IN
88271: IFFALSE 88329
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88273: NOP4
88277: PPUSH
88278: LD_STRING M
88280: PUSH
88281: NOP4
88285: PUSH
88286: LD_INT 1
88288: ARRAY
88289: PUSH
88290: NOP4
88294: PUSH
88295: LD_INT 2
88297: ARRAY
88298: PUSH
88299: LD_INT 0
88301: PUSH
88302: LD_INT 0
88304: PUSH
88305: LD_INT 0
88307: PUSH
88308: LD_INT 0
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: PUSH
88320: EMPTY
88321: LIST
88322: PPUSH
88323: NOP4
88327: GO 88270
88329: POP
88330: POP
// end ;
88331: LD_VAR 0 5
88335: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
88336: NOP4
88340: NOT
88341: IFFALSE 88391
88343: GO 88345
88345: DISABLE
// begin initHack := true ;
88346: NOP4
88350: PUSH
88351: LD_INT 1
88353: ST_TO_ADDR
// hackTanks := [ ] ;
88354: NOP4
88358: PUSH
88359: EMPTY
88360: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
88361: NOP4
88365: PUSH
88366: EMPTY
88367: ST_TO_ADDR
// hackLimit := 3 ;
88368: NOP4
88372: PUSH
88373: LD_INT 3
88375: ST_TO_ADDR
// hackDist := 12 ;
88376: NOP4
88380: PUSH
88381: LD_INT 12
88383: ST_TO_ADDR
// hackCounter := [ ] ;
88384: NOP4
88388: PUSH
88389: EMPTY
88390: ST_TO_ADDR
// end ;
88391: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
88392: NOP4
88396: PUSH
88397: LD_INT 34
88399: PUSH
88400: NOP4
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PPUSH
88409: NOP4
88413: AND
88414: IFFALSE 88669
88416: GO 88418
88418: DISABLE
88419: LD_INT 0
88421: PPUSH
88422: PPUSH
// begin enable ;
88423: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
88424: NOP4
88428: PUSH
88429: LD_INT 34
88431: PUSH
88432: NOP4
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PPUSH
88441: NOP4
88445: PUSH
88446: FOR_IN
88447: IFFALSE 88667
// begin if not i in hackTanks then
88449: NOP4
88453: PUSH
88454: NOP4
88458: IN
88459: NOT
88460: IFFALSE 88543
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
88462: NOP4
88466: PUSH
88467: NOP4
88471: PPUSH
88472: NOP4
88476: PUSH
88477: LD_INT 1
88479: PLUS
88480: PPUSH
88481: NOP4
88485: PPUSH
88486: NOP4
88490: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
88491: NOP4
88495: PUSH
88496: NOP4
88500: PPUSH
88501: NOP4
88505: PUSH
88506: LD_INT 1
88508: PLUS
88509: PPUSH
88510: EMPTY
88511: PPUSH
88512: NOP4
88516: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
88517: NOP4
88521: PUSH
88522: NOP4
88526: PPUSH
88527: NOP4
88531: PUSH
88532: LD_INT 1
88534: PLUS
88535: PPUSH
88536: EMPTY
88537: PPUSH
88538: NOP4
88542: ST_TO_ADDR
// end ; if not IsOk ( i ) then
88543: NOP4
88547: PPUSH
88548: NOP4
88552: NOT
88553: IFFALSE 88566
// begin HackUnlinkAll ( i ) ;
88555: NOP4
88559: PPUSH
88560: NOP4
// continue ;
88564: GO 88446
// end ; HackCheckCapturedStatus ( i ) ;
88566: NOP4
88570: PPUSH
88571: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
88575: NOP4
88579: PUSH
88580: LD_INT 81
88582: PUSH
88583: NOP4
88587: PPUSH
88588: NOP4
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 33
88599: PUSH
88600: LD_INT 3
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 91
88609: PUSH
88610: NOP4
88614: PUSH
88615: NOP4
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 50
88627: PUSH
88628: EMPTY
88629: LIST
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: PPUSH
88637: NOP4
88641: ST_TO_ADDR
// if not tmp then
88642: NOP4
88646: NOT
88647: IFFALSE 88651
// continue ;
88649: GO 88446
// HackLink ( i , tmp ) ;
88651: NOP4
88655: PPUSH
88656: NOP4
88660: PPUSH
88661: NOP4
// end ;
88665: GO 88446
88667: POP
88668: POP
// end ;
88669: PPOPN 2
88671: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
88672: LD_INT 0
88674: PPUSH
88675: PPUSH
88676: PPUSH
// if not hack in hackTanks then
88677: NOP4
88681: PUSH
88682: NOP4
88686: IN
88687: NOT
88688: IFFALSE 88692
// exit ;
88690: GO 88803
// index := GetElementIndex ( hackTanks , hack ) ;
88692: NOP4
88696: PUSH
88697: NOP4
88701: PPUSH
88702: NOP4
88706: PPUSH
88707: NOP4
88711: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
88712: NOP4
88716: PUSH
88717: NOP4
88721: ARRAY
88722: IFFALSE 88803
// begin for i in hackTanksCaptured [ index ] do
88724: NOP4
88728: PUSH
88729: NOP4
88733: PUSH
88734: NOP4
88738: ARRAY
88739: PUSH
88740: FOR_IN
88741: IFFALSE 88767
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
88743: NOP4
88747: PUSH
88748: LD_INT 1
88750: ARRAY
88751: PPUSH
88752: NOP4
88756: PUSH
88757: LD_INT 2
88759: ARRAY
88760: PPUSH
88761: NOP4
88765: GO 88740
88767: POP
88768: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
88769: NOP4
88773: PUSH
88774: NOP4
88778: PPUSH
88779: NOP4
88783: PPUSH
88784: EMPTY
88785: PPUSH
88786: NOP4
88790: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
88791: NOP4
88795: PPUSH
88796: LD_INT 0
88798: PPUSH
88799: NOP4
// end ; end ;
88803: LD_VAR 0 2
88807: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
88808: LD_INT 0
88810: PPUSH
88811: PPUSH
88812: PPUSH
// if not hack in hackTanks or not vehicles then
88813: NOP4
88817: PUSH
88818: NOP4
88822: IN
88823: NOT
88824: PUSH
88825: NOP4
88829: NOT
88830: OR
88831: IFFALSE 88835
// exit ;
88833: GO 89110
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
88835: NOP4
88839: PUSH
88840: NOP4
88844: PPUSH
88845: NOP4
88849: PPUSH
88850: LD_INT 1
88852: PPUSH
88853: LD_INT 1
88855: PPUSH
88856: NOP4
88860: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
88861: NOP4
88865: PUSH
88866: NOP4
88870: PPUSH
88871: NOP4
88875: PPUSH
88876: NOP4
88880: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
88881: NOP4
88885: PUSH
88886: NOP4
88890: ARRAY
88891: PUSH
88892: NOP4
88896: LESS
88897: IFFALSE 89086
// begin for i := 1 to vehicles do
88899: NOP4
88903: PUSH
88904: DOUBLE
88905: LD_INT 1
88907: DEC
88908: ST_TO_ADDR
88909: NOP4
88913: PUSH
88914: FOR_TO
88915: IFFALSE 89084
// begin if hackTanksCaptured [ index ] = hackLimit then
88917: NOP4
88921: PUSH
88922: NOP4
88926: ARRAY
88927: PUSH
88928: NOP4
88932: EQUAL
88933: IFFALSE 88937
// break ;
88935: GO 89084
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
88937: NOP4
88941: PUSH
88942: NOP4
88946: PPUSH
88947: NOP4
88951: PPUSH
88952: NOP4
88956: PUSH
88957: NOP4
88961: ARRAY
88962: PUSH
88963: LD_INT 1
88965: PLUS
88966: PPUSH
88967: NOP4
88971: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
88972: NOP4
88976: PUSH
88977: NOP4
88981: PPUSH
88982: NOP4
88986: PUSH
88987: NOP4
88991: PUSH
88992: NOP4
88996: ARRAY
88997: PUSH
88998: LD_INT 1
89000: PLUS
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: PPUSH
89006: NOP4
89010: PUSH
89011: NOP4
89015: ARRAY
89016: PUSH
89017: NOP4
89021: PUSH
89022: NOP4
89026: ARRAY
89027: PPUSH
89028: NOP4
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PPUSH
89037: NOP4
89041: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
89042: NOP4
89046: PUSH
89047: NOP4
89051: ARRAY
89052: PPUSH
89053: NOP4
89057: PPUSH
89058: NOP4
89062: PPUSH
89063: NOP4
// ComStop ( vehicles [ i ] ) ;
89067: NOP4
89071: PUSH
89072: NOP4
89076: ARRAY
89077: PPUSH
89078: NOP4
// end ;
89082: GO 88914
89084: POP
89085: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89086: NOP4
89090: PPUSH
89091: NOP4
89095: PUSH
89096: NOP4
89100: ARRAY
89101: PUSH
89102: LD_INT 0
89104: PLUS
89105: PPUSH
89106: NOP4
// end ;
89110: LD_VAR 0 3
89114: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
89115: LD_INT 0
89117: PPUSH
89118: PPUSH
89119: PPUSH
89120: PPUSH
// if not hack in hackTanks then
89121: NOP4
89125: PUSH
89126: NOP4
89130: IN
89131: NOT
89132: IFFALSE 89136
// exit ;
89134: GO 89376
// index := GetElementIndex ( hackTanks , hack ) ;
89136: NOP4
89140: PUSH
89141: NOP4
89145: PPUSH
89146: NOP4
89150: PPUSH
89151: NOP4
89155: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
89156: NOP4
89160: PUSH
89161: DOUBLE
89162: NOP4
89166: PUSH
89167: NOP4
89171: ARRAY
89172: INC
89173: ST_TO_ADDR
89174: LD_INT 1
89176: PUSH
89177: FOR_DOWNTO
89178: IFFALSE 89350
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
89180: NOP4
89184: PUSH
89185: NOP4
89189: PUSH
89190: NOP4
89194: ARRAY
89195: PUSH
89196: NOP4
89200: ARRAY
89201: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
89202: NOP4
89206: PUSH
89207: LD_INT 1
89209: ARRAY
89210: PPUSH
89211: NOP4
89215: NOT
89216: PUSH
89217: NOP4
89221: PUSH
89222: LD_INT 1
89224: ARRAY
89225: PPUSH
89226: NOP4
89230: PUSH
89231: NOP4
89235: PPUSH
89236: NOP4
89240: NONEQUAL
89241: OR
89242: IFFALSE 89348
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
89244: NOP4
89248: PUSH
89249: LD_INT 1
89251: ARRAY
89252: PPUSH
89253: NOP4
89257: PUSH
89258: NOP4
89262: PUSH
89263: LD_INT 1
89265: ARRAY
89266: PPUSH
89267: NOP4
89271: PUSH
89272: NOP4
89276: PPUSH
89277: NOP4
89281: EQUAL
89282: AND
89283: IFFALSE 89307
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
89285: NOP4
89289: PUSH
89290: LD_INT 1
89292: ARRAY
89293: PPUSH
89294: NOP4
89298: PUSH
89299: LD_INT 2
89301: ARRAY
89302: PPUSH
89303: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
89307: NOP4
89311: PUSH
89312: NOP4
89316: PPUSH
89317: NOP4
89321: PPUSH
89322: NOP4
89326: PUSH
89327: NOP4
89331: ARRAY
89332: PPUSH
89333: NOP4
89337: PPUSH
89338: NOP4
89342: PPUSH
89343: NOP4
89347: ST_TO_ADDR
// end ; end ;
89348: GO 89177
89350: POP
89351: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89352: NOP4
89356: PPUSH
89357: NOP4
89361: PUSH
89362: NOP4
89366: ARRAY
89367: PUSH
89368: LD_INT 0
89370: PLUS
89371: PPUSH
89372: NOP4
// end ;
89376: LD_VAR 0 2
89380: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
89381: LD_INT 0
89383: PPUSH
89384: PPUSH
89385: PPUSH
89386: PPUSH
// if not hack in hackTanks then
89387: NOP4
89391: PUSH
89392: NOP4
89396: IN
89397: NOT
89398: IFFALSE 89402
// exit ;
89400: GO 89487
// index := GetElementIndex ( hackTanks , hack ) ;
89402: NOP4
89406: PUSH
89407: NOP4
89411: PPUSH
89412: NOP4
89416: PPUSH
89417: NOP4
89421: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
89422: NOP4
89426: PUSH
89427: DOUBLE
89428: LD_INT 1
89430: DEC
89431: ST_TO_ADDR
89432: NOP4
89436: PUSH
89437: NOP4
89441: ARRAY
89442: PUSH
89443: FOR_TO
89444: IFFALSE 89485
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
89446: NOP4
89450: PUSH
89451: NOP4
89455: ARRAY
89456: PUSH
89457: NOP4
89461: ARRAY
89462: PUSH
89463: LD_INT 1
89465: ARRAY
89466: PUSH
89467: NOP4
89471: EQUAL
89472: IFFALSE 89483
// KillUnit ( vehicle ) ;
89474: NOP4
89478: PPUSH
89479: NOP4
89483: GO 89443
89485: POP
89486: POP
// end ;
89487: LD_VAR 0 3
89491: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
89492: NOP4
89496: NOT
89497: IFFALSE 89532
89499: GO 89501
89501: DISABLE
// begin initMiner := true ;
89502: NOP4
89506: PUSH
89507: LD_INT 1
89509: ST_TO_ADDR
// minersList := [ ] ;
89510: NOP4
89514: PUSH
89515: EMPTY
89516: ST_TO_ADDR
// minerMinesList := [ ] ;
89517: NOP4
89521: PUSH
89522: EMPTY
89523: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
89524: NOP4
89528: PUSH
89529: LD_INT 5
89531: ST_TO_ADDR
// end ;
89532: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
89533: NOP4
89537: PUSH
89538: LD_INT 34
89540: PUSH
89541: NOP4
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PPUSH
89550: NOP4
89554: AND
89555: IFFALSE 90018
89557: GO 89559
89559: DISABLE
89560: LD_INT 0
89562: PPUSH
89563: PPUSH
89564: PPUSH
89565: PPUSH
// begin enable ;
89566: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
89567: NOP4
89571: PUSH
89572: LD_INT 34
89574: PUSH
89575: NOP4
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PPUSH
89584: NOP4
89588: PUSH
89589: FOR_IN
89590: IFFALSE 89662
// begin if not i in minersList then
89592: NOP4
89596: PUSH
89597: NOP4
89601: IN
89602: NOT
89603: IFFALSE 89660
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
89605: NOP4
89609: PUSH
89610: NOP4
89614: PPUSH
89615: NOP4
89619: PUSH
89620: LD_INT 1
89622: PLUS
89623: PPUSH
89624: NOP4
89628: PPUSH
89629: NOP4
89633: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
89634: NOP4
89638: PUSH
89639: NOP4
89643: PPUSH
89644: NOP4
89648: PUSH
89649: LD_INT 1
89651: PLUS
89652: PPUSH
89653: EMPTY
89654: PPUSH
89655: NOP4
89659: ST_TO_ADDR
// end end ;
89660: GO 89589
89662: POP
89663: POP
// for i := minerMinesList downto 1 do
89664: NOP4
89668: PUSH
89669: DOUBLE
89670: NOP4
89674: INC
89675: ST_TO_ADDR
89676: LD_INT 1
89678: PUSH
89679: FOR_DOWNTO
89680: IFFALSE 90016
// begin if IsLive ( minersList [ i ] ) then
89682: NOP4
89686: PUSH
89687: NOP4
89691: ARRAY
89692: PPUSH
89693: NOP4
89697: IFFALSE 89725
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
89699: NOP4
89703: PUSH
89704: NOP4
89708: ARRAY
89709: PPUSH
89710: NOP4
89714: PUSH
89715: NOP4
89719: ARRAY
89720: PPUSH
89721: NOP4
// if not minerMinesList [ i ] then
89725: NOP4
89729: PUSH
89730: NOP4
89734: ARRAY
89735: NOT
89736: IFFALSE 89740
// continue ;
89738: GO 89679
// for j := minerMinesList [ i ] downto 1 do
89740: NOP4
89744: PUSH
89745: DOUBLE
89746: NOP4
89750: PUSH
89751: NOP4
89755: ARRAY
89756: INC
89757: ST_TO_ADDR
89758: LD_INT 1
89760: PUSH
89761: FOR_DOWNTO
89762: IFFALSE 90012
// begin side := GetSide ( minersList [ i ] ) ;
89764: NOP4
89768: PUSH
89769: NOP4
89773: PUSH
89774: NOP4
89778: ARRAY
89779: PPUSH
89780: NOP4
89784: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
89785: NOP4
89789: PUSH
89790: NOP4
89794: PUSH
89795: NOP4
89799: ARRAY
89800: PUSH
89801: NOP4
89805: ARRAY
89806: PUSH
89807: LD_INT 1
89809: ARRAY
89810: PPUSH
89811: NOP4
89815: PUSH
89816: NOP4
89820: ARRAY
89821: PUSH
89822: NOP4
89826: ARRAY
89827: PUSH
89828: LD_INT 2
89830: ARRAY
89831: PPUSH
89832: NOP4
89836: ST_TO_ADDR
// if not tmp then
89837: NOP4
89841: NOT
89842: IFFALSE 89846
// continue ;
89844: GO 89761
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
89846: NOP4
89850: PUSH
89851: LD_INT 81
89853: PUSH
89854: NOP4
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PPUSH
89863: NOP4
89867: IN
89868: PUSH
89869: NOP4
89873: PUSH
89874: NOP4
89878: ARRAY
89879: PUSH
89880: NOP4
89884: ARRAY
89885: PUSH
89886: LD_INT 1
89888: ARRAY
89889: PPUSH
89890: NOP4
89894: PUSH
89895: NOP4
89899: ARRAY
89900: PUSH
89901: NOP4
89905: ARRAY
89906: PUSH
89907: LD_INT 2
89909: ARRAY
89910: PPUSH
89911: NOP4
89915: AND
89916: IFFALSE 90010
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
89918: NOP4
89922: PUSH
89923: NOP4
89927: ARRAY
89928: PUSH
89929: NOP4
89933: ARRAY
89934: PUSH
89935: LD_INT 1
89937: ARRAY
89938: PPUSH
89939: NOP4
89943: PUSH
89944: NOP4
89948: ARRAY
89949: PUSH
89950: NOP4
89954: ARRAY
89955: PUSH
89956: LD_INT 2
89958: ARRAY
89959: PPUSH
89960: NOP4
89964: PPUSH
89965: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
89969: NOP4
89973: PUSH
89974: NOP4
89978: PPUSH
89979: NOP4
89983: PPUSH
89984: NOP4
89988: PUSH
89989: NOP4
89993: ARRAY
89994: PPUSH
89995: NOP4
89999: PPUSH
90000: NOP4
90004: PPUSH
90005: NOP4
90009: ST_TO_ADDR
// end ; end ;
90010: GO 89761
90012: POP
90013: POP
// end ;
90014: GO 89679
90016: POP
90017: POP
// end ;
90018: PPOPN 4
90020: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
90021: LD_INT 0
90023: PPUSH
90024: PPUSH
// result := false ;
90025: NOP4
90029: PUSH
90030: LD_INT 0
90032: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
90033: NOP4
90037: PPUSH
90038: NOP4
90042: PUSH
90043: NOP4
90047: EQUAL
90048: NOT
90049: IFFALSE 90053
// exit ;
90051: GO 90293
// index := GetElementIndex ( minersList , unit ) ;
90053: NOP4
90057: PUSH
90058: NOP4
90062: PPUSH
90063: NOP4
90067: PPUSH
90068: NOP4
90072: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
90073: NOP4
90077: PUSH
90078: NOP4
90082: ARRAY
90083: PUSH
90084: NOP4
90088: GREATEREQUAL
90089: IFFALSE 90093
// exit ;
90091: GO 90293
// ComMoveXY ( unit , x , y ) ;
90093: NOP4
90097: PPUSH
90098: NOP4
90102: PPUSH
90103: NOP4
90107: PPUSH
90108: NOP4
// repeat wait ( 0 0$1 ) ;
90112: LD_INT 35
90114: PPUSH
90115: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
90119: NOP4
90123: PPUSH
90124: NOP4
90128: PPUSH
90129: NOP4
90133: PPUSH
90134: NOP4
90138: NOT
90139: PUSH
90140: NOP4
90144: PPUSH
90145: NOP4
90149: AND
90150: IFFALSE 90154
// exit ;
90152: GO 90293
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
90154: NOP4
90158: PPUSH
90159: NOP4
90163: PPUSH
90164: NOP4
90168: PUSH
90169: NOP4
90173: EQUAL
90174: PUSH
90175: NOP4
90179: PPUSH
90180: NOP4
90184: NOT
90185: AND
90186: IFFALSE 90112
// PlaySoundXY ( x , y , PlantMine ) ;
90188: NOP4
90192: PPUSH
90193: NOP4
90197: PPUSH
90198: LD_STRING PlantMine
90200: PPUSH
90201: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
90205: NOP4
90209: PPUSH
90210: NOP4
90214: PPUSH
90215: NOP4
90219: PPUSH
90220: NOP4
90224: PPUSH
90225: LD_INT 0
90227: PPUSH
90228: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
90232: NOP4
90236: PUSH
90237: NOP4
90241: PPUSH
90242: NOP4
90246: PUSH
90247: NOP4
90251: PUSH
90252: NOP4
90256: ARRAY
90257: PUSH
90258: LD_INT 1
90260: PLUS
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PPUSH
90266: NOP4
90270: PUSH
90271: NOP4
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PPUSH
90280: NOP4
90284: ST_TO_ADDR
// result := true ;
90285: NOP4
90289: PUSH
90290: LD_INT 1
90292: ST_TO_ADDR
// end ;
90293: LD_VAR 0 4
90297: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
90298: LD_INT 0
90300: PPUSH
90301: PPUSH
90302: PPUSH
// if not unit in minersList then
90303: NOP4
90307: PUSH
90308: NOP4
90312: IN
90313: NOT
90314: IFFALSE 90318
// exit ;
90316: GO 90710
// index := GetElementIndex ( minersList , unit ) ;
90318: NOP4
90322: PUSH
90323: NOP4
90327: PPUSH
90328: NOP4
90332: PPUSH
90333: NOP4
90337: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
90338: NOP4
90342: PUSH
90343: DOUBLE
90344: NOP4
90348: PUSH
90349: NOP4
90353: ARRAY
90354: INC
90355: ST_TO_ADDR
90356: LD_INT 1
90358: PUSH
90359: FOR_DOWNTO
90360: IFFALSE 90521
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
90362: NOP4
90366: PUSH
90367: NOP4
90371: ARRAY
90372: PUSH
90373: NOP4
90377: ARRAY
90378: PUSH
90379: LD_INT 1
90381: ARRAY
90382: PUSH
90383: NOP4
90387: EQUAL
90388: PUSH
90389: NOP4
90393: PUSH
90394: NOP4
90398: ARRAY
90399: PUSH
90400: NOP4
90404: ARRAY
90405: PUSH
90406: LD_INT 2
90408: ARRAY
90409: PUSH
90410: NOP4
90414: EQUAL
90415: AND
90416: IFFALSE 90519
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90418: NOP4
90422: PUSH
90423: NOP4
90427: ARRAY
90428: PUSH
90429: NOP4
90433: ARRAY
90434: PUSH
90435: LD_INT 1
90437: ARRAY
90438: PPUSH
90439: NOP4
90443: PUSH
90444: NOP4
90448: ARRAY
90449: PUSH
90450: NOP4
90454: ARRAY
90455: PUSH
90456: LD_INT 2
90458: ARRAY
90459: PPUSH
90460: NOP4
90464: PPUSH
90465: NOP4
90469: PPUSH
90470: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90474: NOP4
90478: PUSH
90479: NOP4
90483: PPUSH
90484: NOP4
90488: PPUSH
90489: NOP4
90493: PUSH
90494: NOP4
90498: ARRAY
90499: PPUSH
90500: NOP4
90504: PPUSH
90505: NOP4
90509: PPUSH
90510: NOP4
90514: ST_TO_ADDR
// exit ;
90515: POP
90516: POP
90517: GO 90710
// end ; end ;
90519: GO 90359
90521: POP
90522: POP
// for i := minerMinesList [ index ] downto 1 do
90523: NOP4
90527: PUSH
90528: DOUBLE
90529: NOP4
90533: PUSH
90534: NOP4
90538: ARRAY
90539: INC
90540: ST_TO_ADDR
90541: LD_INT 1
90543: PUSH
90544: FOR_DOWNTO
90545: IFFALSE 90708
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
90547: NOP4
90551: PUSH
90552: NOP4
90556: ARRAY
90557: PUSH
90558: NOP4
90562: ARRAY
90563: PUSH
90564: LD_INT 1
90566: ARRAY
90567: PPUSH
90568: NOP4
90572: PUSH
90573: NOP4
90577: ARRAY
90578: PUSH
90579: NOP4
90583: ARRAY
90584: PUSH
90585: LD_INT 2
90587: ARRAY
90588: PPUSH
90589: NOP4
90593: PPUSH
90594: NOP4
90598: PPUSH
90599: NOP4
90603: PUSH
90604: LD_INT 6
90606: LESS
90607: IFFALSE 90706
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90609: NOP4
90613: PUSH
90614: NOP4
90618: ARRAY
90619: PUSH
90620: NOP4
90624: ARRAY
90625: PUSH
90626: LD_INT 1
90628: ARRAY
90629: PPUSH
90630: NOP4
90634: PUSH
90635: NOP4
90639: ARRAY
90640: PUSH
90641: NOP4
90645: ARRAY
90646: PUSH
90647: LD_INT 2
90649: ARRAY
90650: PPUSH
90651: NOP4
90655: PPUSH
90656: NOP4
90660: PPUSH
90661: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90665: NOP4
90669: PUSH
90670: NOP4
90674: PPUSH
90675: NOP4
90679: PPUSH
90680: NOP4
90684: PUSH
90685: NOP4
90689: ARRAY
90690: PPUSH
90691: NOP4
90695: PPUSH
90696: NOP4
90700: PPUSH
90701: NOP4
90705: ST_TO_ADDR
// end ; end ;
90706: GO 90544
90708: POP
90709: POP
// end ;
90710: LD_VAR 0 4
90714: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
90715: LD_INT 0
90717: PPUSH
90718: PPUSH
90719: PPUSH
90720: PPUSH
90721: PPUSH
90722: PPUSH
90723: PPUSH
90724: PPUSH
90725: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
90726: NOP4
90730: PPUSH
90731: NOP4
90735: PUSH
90736: NOP4
90740: EQUAL
90741: NOT
90742: PUSH
90743: NOP4
90747: PUSH
90748: NOP4
90752: IN
90753: NOT
90754: OR
90755: IFFALSE 90759
// exit ;
90757: GO 91081
// index := GetElementIndex ( minersList , unit ) ;
90759: NOP4
90763: PUSH
90764: NOP4
90768: PPUSH
90769: NOP4
90773: PPUSH
90774: NOP4
90778: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
90779: NOP4
90783: PUSH
90784: NOP4
90788: PUSH
90789: NOP4
90793: PUSH
90794: NOP4
90798: ARRAY
90799: MINUS
90800: ST_TO_ADDR
// if not minesFreeAmount then
90801: NOP4
90805: NOT
90806: IFFALSE 90810
// exit ;
90808: GO 91081
// tmp := [ ] ;
90810: NOP4
90814: PUSH
90815: EMPTY
90816: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
90817: NOP4
90821: PUSH
90822: DOUBLE
90823: LD_INT 1
90825: DEC
90826: ST_TO_ADDR
90827: NOP4
90831: PUSH
90832: FOR_TO
90833: IFFALSE 91028
// begin _d := rand ( 0 , 5 ) ;
90835: NOP4
90839: PUSH
90840: LD_INT 0
90842: PPUSH
90843: LD_INT 5
90845: PPUSH
90846: NOP4
90850: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
90851: NOP4
90855: PUSH
90856: LD_INT 2
90858: PPUSH
90859: LD_INT 6
90861: PPUSH
90862: NOP4
90866: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
90867: NOP4
90871: PUSH
90872: NOP4
90876: PPUSH
90877: NOP4
90881: PPUSH
90882: NOP4
90886: PPUSH
90887: NOP4
90891: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
90892: NOP4
90896: PUSH
90897: NOP4
90901: PPUSH
90902: NOP4
90906: PPUSH
90907: NOP4
90911: PPUSH
90912: NOP4
90916: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
90917: NOP4
90921: PPUSH
90922: NOP4
90926: PPUSH
90927: NOP4
90931: PUSH
90932: NOP4
90936: PUSH
90937: NOP4
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: NOP4
90950: IN
90951: NOT
90952: AND
90953: PUSH
90954: NOP4
90958: PPUSH
90959: NOP4
90963: PPUSH
90964: NOP4
90968: NOT
90969: AND
90970: IFFALSE 91012
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
90972: NOP4
90976: PUSH
90977: NOP4
90981: PPUSH
90982: NOP4
90986: PUSH
90987: LD_INT 1
90989: PLUS
90990: PPUSH
90991: NOP4
90995: PUSH
90996: NOP4
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PPUSH
91005: NOP4
91009: ST_TO_ADDR
91010: GO 91026
// i := i - 1 ;
91012: NOP4
91016: PUSH
91017: NOP4
91021: PUSH
91022: LD_INT 1
91024: MINUS
91025: ST_TO_ADDR
// end ;
91026: GO 90832
91028: POP
91029: POP
// for i in tmp do
91030: NOP4
91034: PUSH
91035: NOP4
91039: PUSH
91040: FOR_IN
91041: IFFALSE 91079
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
91043: NOP4
91047: PPUSH
91048: NOP4
91052: PUSH
91053: LD_INT 1
91055: ARRAY
91056: PPUSH
91057: NOP4
91061: PUSH
91062: LD_INT 2
91064: ARRAY
91065: PPUSH
91066: NOP4
91070: NOT
91071: IFFALSE 91077
// exit ;
91073: POP
91074: POP
91075: GO 91081
91077: GO 91040
91079: POP
91080: POP
// end ;
91081: LD_VAR 0 4
91085: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
91086: LD_INT 0
91088: PPUSH
91089: PPUSH
91090: PPUSH
91091: PPUSH
91092: PPUSH
91093: PPUSH
91094: PPUSH
// if not GetClass ( unit ) = class_sniper then
91095: NOP4
91099: PPUSH
91100: NOP4
91104: PUSH
91105: LD_INT 5
91107: EQUAL
91108: NOT
91109: IFFALSE 91113
// exit ;
91111: GO 91501
// dist := 8 ;
91113: NOP4
91117: PUSH
91118: LD_INT 8
91120: ST_TO_ADDR
// viewRange := 12 ;
91121: NOP4
91125: PUSH
91126: LD_INT 12
91128: ST_TO_ADDR
// side := GetSide ( unit ) ;
91129: NOP4
91133: PUSH
91134: NOP4
91138: PPUSH
91139: NOP4
91143: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
91144: LD_INT 61
91146: PPUSH
91147: NOP4
91151: PPUSH
91152: NOP4
91156: PUSH
91157: LD_INT 2
91159: EQUAL
91160: IFFALSE 91170
// viewRange := 16 ;
91162: NOP4
91166: PUSH
91167: LD_INT 16
91169: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
91170: NOP4
91174: PPUSH
91175: NOP4
91179: PPUSH
91180: NOP4
91184: PPUSH
91185: NOP4
91189: PUSH
91190: NOP4
91194: GREATER
91195: IFFALSE 91274
// begin ComMoveXY ( unit , x , y ) ;
91197: NOP4
91201: PPUSH
91202: NOP4
91206: PPUSH
91207: NOP4
91211: PPUSH
91212: NOP4
// repeat wait ( 0 0$1 ) ;
91216: LD_INT 35
91218: PPUSH
91219: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
91223: NOP4
91227: PPUSH
91228: NOP4
91232: PPUSH
91233: NOP4
91237: PPUSH
91238: NOP4
91242: NOT
91243: IFFALSE 91247
// exit ;
91245: GO 91501
// until GetDistUnitXY ( unit , x , y ) < dist ;
91247: NOP4
91251: PPUSH
91252: NOP4
91256: PPUSH
91257: NOP4
91261: PPUSH
91262: NOP4
91266: PUSH
91267: NOP4
91271: LESS
91272: IFFALSE 91216
// end ; ComTurnXY ( unit , x , y ) ;
91274: NOP4
91278: PPUSH
91279: NOP4
91283: PPUSH
91284: NOP4
91288: PPUSH
91289: NOP4
// wait ( 5 ) ;
91293: LD_INT 5
91295: PPUSH
91296: NOP4
// _d := GetDir ( unit ) ;
91300: NOP4
91304: PUSH
91305: NOP4
91309: PPUSH
91310: NOP4
91314: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
91315: NOP4
91319: PUSH
91320: NOP4
91324: PPUSH
91325: NOP4
91329: PPUSH
91330: NOP4
91334: PPUSH
91335: NOP4
91339: PPUSH
91340: NOP4
91344: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
91345: NOP4
91349: PUSH
91350: NOP4
91354: PPUSH
91355: NOP4
91359: PPUSH
91360: NOP4
91364: PPUSH
91365: NOP4
91369: PPUSH
91370: NOP4
91374: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91375: NOP4
91379: PPUSH
91380: NOP4
91384: PPUSH
91385: NOP4
91389: NOT
91390: IFFALSE 91394
// exit ;
91392: GO 91501
// ComAnimCustom ( unit , 1 ) ;
91394: NOP4
91398: PPUSH
91399: LD_INT 1
91401: PPUSH
91402: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
91406: NOP4
91410: PPUSH
91411: NOP4
91415: PPUSH
91416: NOP4
91420: PPUSH
91421: NOP4
91425: PPUSH
91426: NOP4
// repeat wait ( 1 ) ;
91430: LD_INT 1
91432: PPUSH
91433: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
91437: NOP4
91441: PPUSH
91442: NOP4
91446: PUSH
91447: NOP4
91451: PPUSH
91452: NOP4
91456: OR
91457: PUSH
91458: NOP4
91462: PPUSH
91463: NOP4
91467: NOT
91468: OR
91469: PUSH
91470: NOP4
91474: PPUSH
91475: NOP4
91479: OR
91480: IFFALSE 91430
// RemoveSeeing ( _x , _y , side ) ;
91482: NOP4
91486: PPUSH
91487: NOP4
91491: PPUSH
91492: NOP4
91496: PPUSH
91497: NOP4
// end ; end_of_file
91501: LD_VAR 0 4
91505: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
91506: NOP4
91510: PUSH
91511: LD_INT 200
91513: DOUBLE
91514: GREATEREQUAL
91515: IFFALSE 91523
91517: LD_INT 299
91519: DOUBLE
91520: LESSEQUAL
91521: IFTRUE 91525
91523: GO 91557
91525: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
91526: NOP4
91530: PPUSH
91531: NOP4
91535: PPUSH
91536: NOP4
91540: PPUSH
91541: NOP4
91545: PPUSH
91546: NOP4
91550: PPUSH
91551: NOP4
91555: GO 91634
91557: LD_INT 300
91559: DOUBLE
91560: GREATEREQUAL
91561: IFFALSE 91569
91563: LD_INT 399
91565: DOUBLE
91566: LESSEQUAL
91567: IFTRUE 91571
91569: GO 91633
91571: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
91572: NOP4
91576: PPUSH
91577: NOP4
91581: PPUSH
91582: NOP4
91586: PPUSH
91587: NOP4
91591: PPUSH
91592: NOP4
91596: PPUSH
91597: NOP4
91601: PPUSH
91602: NOP4
91606: PPUSH
91607: NOP4
91611: PPUSH
91612: NOP4
91616: PPUSH
91617: NOP4
91621: PPUSH
91622: NOP4
91626: PPUSH
91627: NOP4
91631: GO 91634
91633: POP
// end ;
91634: PPOPN 11
91636: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
91637: NOP4
91641: PPUSH
91642: NOP4
91646: PPUSH
91647: NOP4
91651: PPUSH
91652: NOP4
91656: PPUSH
91657: NOP4
91661: PPUSH
91662: NOP4
// end ;
91666: PPOPN 5
91668: END
