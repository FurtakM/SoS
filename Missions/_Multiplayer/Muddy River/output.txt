// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 350 0 0
// InitMultiplayer ;
  20: CALL 611 0 0
// InitMacro ;
  24: CALL 47142 0 0
// if debug then
  28: LD_EXP 1
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: CALL 42478 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: CALL 1893 0 1
  79: PPUSH
  80: CALL 5848 0 1
// Multiplayer_Start ;
  84: CALL 3757 0 0
// MC_Start ( ) ;
  88: CALL 49254 0 0
// Multiplayer_End ;
  92: CALL 3881 0 0
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: CALL 70496 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: LD_OWVAR 67
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: CALL 70496 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_OWVAR 67
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: CALL 70496 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: CALL 70496 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: LD_OWVAR 67
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: CALL 70496 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: LD_ADDR_EXP 67
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: LD_ADDR_EXP 68
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_EXP 38
 330: PUSH
 331: LD_VAR 0 2
 335: ARRAY
 336: PPUSH
 337: CALL 70922 0 2
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: LD_ADDR_EXP 1
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: LD_ADDR_EXP 4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: LD_ADDR_EXP 5
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: LD_EXP 2
 489: PUSH
 490: LD_OWVAR 48
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: CALL 4582 0 0
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: LD_EXP 1
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: LD_ADDR_VAR 0 2
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: CALL_OW 44
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: LD_ADDR_EXP 18
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: LD_OWVAR 4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: LD_OWVAR 7
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: LD_ADDR_EXP 6
 646: PUSH
 647: LD_OWVAR 6
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: LD_ADDR_EXP 7
 656: PUSH
 657: LD_OWVAR 17
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: LD_ADDR_EXP 8
 666: PUSH
 667: LD_OWVAR 15
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: LD_ADDR_EXP 9
 676: PUSH
 677: LD_OWVAR 16
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: LD_ADDR_EXP 10
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: LD_OWVAR 12
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: LD_ADDR_EXP 10
 706: PUSH
 707: LD_EXP 10
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: LD_EXP 10
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: CALL 14797 0 3
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: LD_ADDR_VAR 0 2
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_EXP 18
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: LD_ADDR_EXP 17
 772: PUSH
 773: LD_EXP 17
 777: PPUSH
 778: LD_EXP 17
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 426
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: CALL_OW 2
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: LD_ADDR_EXP 6
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: LD_ADDR_EXP 7
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: LD_ADDR_EXP 8
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: LD_ADDR_EXP 10
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: LD_ADDR_EXP 17
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: LD_ADDR_EXP 11
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: LD_ADDR_EXP 25
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: LD_ADDR_EXP 15
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: LD_ADDR_EXP 13
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: LD_ADDR_EXP 16
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: LD_ADDR_EXP 24
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: LD_ADDR_EXP 27
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: LD_ADDR_EXP 26
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: LD_ADDR_EXP 12
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: LD_VAR 0 2
1232: PPUSH
1233: CALL_OW 530
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: LD_ADDR_EXP 11
1243: PUSH
1244: LD_EXP 11
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: CALL_OW 1
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: LD_ADDR_EXP 9
1266: PUSH
1267: LD_EXP 9
1271: PPUSH
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 1
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_EXP 7
1294: PPUSH
1295: LD_VAR 0 2
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: CALL_OW 1
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_EXP 10
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: LD_VAR 0 2
1330: PUSH
1331: LD_EXP 10
1335: PUSH
1336: LD_VAR 0 3
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: LD_ADDR_VAR 0 5
1348: PUSH
1349: LD_EXP 10
1353: PUSH
1354: LD_VAR 0 3
1358: ARRAY
1359: PUSH
1360: LD_VAR 0 2
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: LD_ADDR_EXP 10
1370: PUSH
1371: LD_EXP 10
1375: PPUSH
1376: LD_VAR 0 3
1380: PPUSH
1381: LD_VAR 0 5
1385: PPUSH
1386: CALL_OW 1
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: LD_EXP 9
1399: PUSH
1400: LD_VAR 0 2
1404: ARRAY
1405: PUSH
1406: LD_EXP 9
1410: PUSH
1411: LD_VAR 0 2
1415: ARRAY
1416: PUSH
1417: LD_EXP 13
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: LD_ADDR_EXP 9
1430: PUSH
1431: LD_EXP 9
1435: PPUSH
1436: LD_VAR 0 2
1440: PPUSH
1441: LD_EXP 13
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: LD_EXP 13
1453: PPUSH
1454: CALL_OW 12
1458: ARRAY
1459: PPUSH
1460: CALL_OW 1
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: LD_EXP 9
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: PUSH
1477: LD_EXP 7
1481: PUSH
1482: LD_VAR 0 2
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: LD_EXP 11
1494: PUSH
1495: LD_VAR 0 2
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: LD_ADDR_EXP 14
1508: PUSH
1509: LD_EXP 14
1513: PPUSH
1514: LD_VAR 0 2
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: CALL_OW 1
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: LD_EXP 7
1531: PUSH
1532: LD_VAR 0 2
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: LD_ADDR_EXP 26
1543: PUSH
1544: LD_EXP 26
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_EXP 10
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: LD_VAR 0 2
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 3
1597: ARRAY
1598: PPUSH
1599: LD_VAR 0 2
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: CALL_OW 343
// for x = 1 to j - 1 do
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: LD_VAR 0 3
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: LD_VAR 0 2
1638: PUSH
1639: LD_VAR 0 3
1643: ARRAY
1644: PPUSH
1645: LD_VAR 0 2
1649: PUSH
1650: LD_VAR 0 4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 80
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_EXP 17
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: LD_ADDR_EXP 20
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: LD_ADDR_EXP 21
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: LD_ADDR_EXP 22
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_EXP 17
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: LD_ADDR_EXP 23
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: LD_EXP 17
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: LD_VAR 0 1
1901: PUSH
1902: LD_EXP 7
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: LD_ADDR_VAR 0 2
1914: PUSH
1915: LD_VAR 0 1
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: LD_ADDR_VAR 0 3
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: LD_EXP 7
1942: PUSH
1943: LD_VAR 0 3
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: LD_VAR 0 3
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_VAR 0 1
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: LD_ADDR_VAR 0 3
2095: PUSH
2096: CALL_OW 44
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: LD_VAR 0 2
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: CALL_OW 44
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: LD_VAR 0 2
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: CALL_OW 44
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: LD_EXP 7
2317: PUSH
2318: LD_VAR 0 2
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: LD_EXP 16
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 2
2343: PPUSH
2344: LD_EXP 7
2348: PUSH
2349: LD_VAR 0 2
2353: ARRAY
2354: PPUSH
2355: CALL 1974 0 2
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: LD_ADDR_EXP 24
2364: PUSH
2365: LD_EXP 24
2369: PPUSH
2370: LD_EXP 24
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: CALL_OW 2
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: LD_VAR 0 5
2393: PPUSH
2394: LD_EXP 12
2398: PUSH
2399: LD_EXP 7
2403: PUSH
2404: LD_VAR 0 2
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 49
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_VAR 0 2
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: LD_EXP 9
2443: PUSH
2444: LD_VAR 0 2
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: LD_EXP 20
2468: PPUSH
2469: CALL_OW 380
// if multiplayer then
2473: LD_OWVAR 4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: LD_OWVAR 19
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: LD_VAR 0 2
2512: PPUSH
2513: CALL_OW 525
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: LD_VAR 0 2
2527: PPUSH
2528: CALL_OW 526
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: CALL_OW 12
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: LD_VAR 0 5
2581: PPUSH
2582: LD_EXP 12
2586: PUSH
2587: LD_EXP 7
2591: PUSH
2592: LD_VAR 0 2
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: LD_ADDR_EXP 24
2614: PUSH
2615: LD_EXP 24
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: LD_VAR 0 5
2629: PPUSH
2630: CALL_OW 1
2634: ST_TO_ADDR
// end ; InitHc ;
2635: CALL_OW 19
// InitUc ;
2639: CALL_OW 18
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: LD_EXP 9
2662: PUSH
2663: LD_VAR 0 2
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: LD_ADDR_VAR 0 3
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: LD_EXP 19
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: LD_EXP 19
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_EXP 20
2773: PPUSH
2774: CALL_OW 380
// un := CreateHuman ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: CALL_OW 44
2787: ST_TO_ADDR
// if j > copy then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_VAR 0 8
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: LD_ADDR_VAR 0 8
2804: PUSH
2805: LD_VAR 0 8
2809: PPUSH
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 1
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: LD_VAR 0 8
2831: PUSH
2832: LD_VAR 0 3
2836: ARRAY
2837: PPUSH
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: LD_VAR 0 5
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: LD_VAR 0 8
2859: PUSH
2860: LD_VAR 0 3
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: CALL_OW 260
2873: PPUSH
2874: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: LD_VAR 0 5
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 8
2890: PUSH
2891: LD_VAR 0 3
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: CALL_OW 260
2904: PPUSH
2905: CALL_OW 239
// end ; if multi_pos_area then
2909: LD_EXP 12
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: LD_VAR 0 5
2919: PPUSH
2920: CALL_OW 257
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_VAR 0 3
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_VAR 0 3
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: CALL 14675 0 5
// veh := CreateVehicle ;
2995: LD_ADDR_VAR 0 6
2999: PUSH
3000: CALL_OW 45
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_EXP 12
3014: PUSH
3015: LD_EXP 7
3019: PUSH
3020: LD_VAR 0 2
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3038: LD_VAR 0 5
3042: PPUSH
3043: LD_VAR 0 6
3047: PPUSH
3048: CALL_OW 52
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_EXP 12
3063: PUSH
3064: LD_EXP 7
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 49
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: LD_ADDR_VAR 0 3
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: CALL_OW 12
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_VAR 0 3
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: CALL 14675 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: CALL_OW 45
3166: PPUSH
3167: LD_EXP 12
3171: PUSH
3172: LD_EXP 7
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: CALL_OW 49
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: LD_EXP 23
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: LD_ADDR_VAR 0 1
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: LD_EXP 7
3251: PUSH
3252: LD_VAR 0 2
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: LD_ADDR_VAR 0 5
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: LD_EXP 23
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: LD_VAR 0 2
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: LD_EXP 9
3295: PUSH
3296: LD_VAR 0 2
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3321: LD_ADDR_VAR 0 5
3325: PUSH
3326: LD_VAR 0 5
3330: PUSH
3331: CALL_OW 45
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: LD_VAR 0 5
3365: PUSH
3366: CALL_OW 45
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: LD_VAR 0 5
3400: PUSH
3401: CALL_OW 45
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_VAR 0 5
3435: PUSH
3436: CALL_OW 45
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: LD_EXP 23
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: LD_VAR 0 2
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: LD_EXP 9
3471: PUSH
3472: LD_VAR 0 2
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3497: LD_ADDR_VAR 0 5
3501: PUSH
3502: LD_VAR 0 5
3506: PUSH
3507: CALL_OW 45
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3532: LD_ADDR_VAR 0 5
3536: PUSH
3537: LD_VAR 0 5
3541: PUSH
3542: CALL_OW 45
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3567: LD_ADDR_VAR 0 5
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: CALL_OW 45
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_VAR 0 5
3611: PUSH
3612: CALL_OW 45
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3637: LD_ADDR_VAR 0 5
3641: PUSH
3642: LD_VAR 0 5
3646: PUSH
3647: CALL_OW 45
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: CALL_OW 45
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: CALL 14675 0 5
// tmp := tmp ^ CreateVehicle ;
3707: LD_ADDR_VAR 0 5
3711: PUSH
3712: LD_VAR 0 5
3716: PUSH
3717: CALL_OW 45
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: LD_ADDR_VAR 0 1
3727: PUSH
3728: LD_VAR 0 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_VAR 0 5
3742: PPUSH
3743: CALL_OW 2
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: CALL 2286 0 0
// Multiplayer_InitPointSystem ( ) ;
3764: CALL 4681 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: CALL 4857 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: CALL 4857 0 1
// Multiplayer_SpawnArtifact ;
3811: CALL 5297 0 0
// if multi_support then
3815: LD_EXP 23
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: LD_ADDR_EXP 27
3825: PUSH
3826: CALL 3208 0 0
3830: ST_TO_ADDR
// game := true ;
3831: LD_ADDR_EXP 2
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: LD_EXP 7
3843: PUSH
3844: LD_OWVAR 2
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: LD_OWVAR 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: CALL_OW 69
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: CALL_OW 87
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: LD_ADDR_VAR 0 5
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: LD_OWVAR 1
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: LD_EXP 28
3916: NOT
3917: AND
3918: PUSH
3919: LD_EXP 23
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: LD_ADDR_EXP 28
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: LD_ADDR_VAR 0 2
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: LD_EXP 7
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PUSH
3965: LD_EXP 25
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: LD_EXP 27
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: LD_EXP 27
4000: PUSH
4001: LD_VAR 0 2
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: LD_ADDR_VAR 0 3
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 3
4032: ARRAY
4033: PPUSH
4034: LD_EXP 12
4038: PUSH
4039: LD_EXP 7
4043: PUSH
4044: LD_VAR 0 2
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 3
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: LD_ADDR_EXP 27
4088: PUSH
4089: LD_EXP 27
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 1
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: LD_OWVAR 1
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: LD_OWVAR 1
4136: LESS
4137: PUSH
4138: LD_EXP 28
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: LD_EXP 23
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: LD_ADDR_EXP 28
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: LD_ADDR_VAR 0 2
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: LD_EXP 7
4187: PUSH
4188: LD_VAR 0 2
4192: ARRAY
4193: PUSH
4194: LD_EXP 25
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: LD_EXP 27
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_EXP 27
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: LD_ADDR_VAR 0 3
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: LD_VAR 0 4
4256: PUSH
4257: LD_VAR 0 3
4261: ARRAY
4262: PPUSH
4263: LD_EXP 12
4267: PUSH
4268: LD_EXP 7
4272: PUSH
4273: LD_VAR 0 2
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: CALL_OW 3
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: LD_ADDR_EXP 27
4317: PUSH
4318: LD_EXP 27
4322: PPUSH
4323: LD_VAR 0 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PPUSH
4333: CALL_OW 1
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: LD_EXP 16
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: LD_ADDR_VAR 0 2
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 69
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_VAR 0 2
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: LD_ADDR_EXP 25
4404: PUSH
4405: LD_EXP 25
4409: PPUSH
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: CALL_OW 1
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: CALL 4927 0 1
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: LD_EXP 25
4440: PPUSH
4441: CALL 11949 0 1
4445: PUSH
4446: LD_EXP 7
4450: PPUSH
4451: CALL 11949 0 1
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: LD_EXP 3
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: LD_EXP 2
4485: AND
4486: PUSH
4487: LD_EXP 24
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: LD_ADDR_EXP 2
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: LD_ADDR_VAR 0 2
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: LD_EXP 7
4523: PUSH
4524: LD_VAR 0 2
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_EXP 29
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: CALL_OW 506
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: LD_EXP 25
4559: PUSH
4560: LD_OWVAR 2
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: CALL_OW 107
4571: GO 4577
// YouWinInMultiplayer ;
4573: CALL_OW 106
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: LD_ADDR_VAR 0 1
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: LD_OWVAR 1
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: LD_EXP 7
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: LD_ADDR_VAR 0 1
4635: PUSH
4636: LD_VAR 0 1
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_VAR 0 2
4653: PUSH
4654: LD_EXP 29
4658: PUSH
4659: LD_VAR 0 2
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: LD_ADDR_EXP 29
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: LD_ADDR_EXP 30
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: LD_EXP 29
4743: NOT
4744: PUSH
4745: LD_VAR 0 1
4749: NOT
4750: OR
4751: PUSH
4752: LD_VAR 0 1
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: LD_ADDR_EXP 29
4769: PUSH
4770: LD_EXP 29
4774: PPUSH
4775: LD_VAR 0 1
4779: PPUSH
4780: LD_EXP 29
4784: PUSH
4785: LD_VAR 0 1
4789: ARRAY
4790: PUSH
4791: LD_VAR 0 2
4795: PLUS
4796: PPUSH
4797: CALL_OW 1
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: LD_EXP 29
4814: NOT
4815: PUSH
4816: LD_VAR 0 1
4820: NOT
4821: OR
4822: PUSH
4823: LD_VAR 0 1
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: LD_EXP 29
4845: PUSH
4846: LD_VAR 0 1
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: LD_ADDR_EXP 30
4864: PUSH
4865: LD_EXP 30
4869: PPUSH
4870: LD_EXP 30
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: LD_VAR 0 1
4883: PPUSH
4884: CALL_OW 2
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: LD_VAR 0 1
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: LD_EXP 30
4915: PUSH
4916: LD_VAR 0 1
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: LD_ADDR_VAR 0 3
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: LD_ADDR_VAR 0 4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: LD_VAR 0 4
4961: PUSH
4962: LD_VAR 0 1
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: LD_EXP 7
4975: PUSH
4976: LD_VAR 0 4
4980: ARRAY
4981: PUSH
4982: LD_EXP 25
4986: PUSH
4987: LD_VAR 0 4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_VAR 0 4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: LD_VAR 0 3
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: LD_ADDR_VAR 0 4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_VAR 0 1
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL_OW 69
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: LD_VAR 0 4
5074: PPUSH
5075: LD_VAR 0 3
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: CALL_OW 235
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: LD_ADDR_VAR 0 5
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: LD_VAR 0 1
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: LD_VAR 0 4
5173: PPUSH
5174: LD_VAR 0 3
5178: PUSH
5179: LD_VAR 0 5
5183: ARRAY
5184: PPUSH
5185: CALL_OW 235
// if IsDrivenBy ( i ) then
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 311
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: LD_VAR 0 3
5214: PUSH
5215: LD_VAR 0 5
5219: ARRAY
5220: PPUSH
5221: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 310
5234: PPUSH
5235: CALL_OW 247
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: LD_VAR 0 4
5249: PPUSH
5250: CALL_OW 122
// j := j + 1 ;
5254: LD_ADDR_VAR 0 5
5258: PUSH
5259: LD_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: LD_VAR 0 5
5272: PUSH
5273: LD_VAR 0 3
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: LD_ADDR_VAR 0 5
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PPUSH
5366: CALL_OW 12
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: LD_VAR 0 3
5381: PUSH
5382: LD_VAR 0 2
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: LD_VAR 0 3
5396: PUSH
5397: LD_VAR 0 2
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 58
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: LD_VAR 0 1
5426: NOT
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: CALL 4894 0 1
5453: PPUSH
5454: CALL 4736 0 2
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: LD_VAR 0 1
5470: NOT
5471: PUSH
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: CALL 4894 0 1
5497: PPUSH
5498: CALL 4736 0 2
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: LD_VAR 0 1
5514: NOT
5515: PUSH
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: LD_VAR 0 2
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL 4894 0 1
5567: PPUSH
5568: CALL 4736 0 2
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: LD_VAR 0 1
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: LD_VAR 0 2
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: LD_ADDR_VAR 0 8
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: CALL 4894 0 1
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: LD_ADDR_VAR 0 8
5620: PUSH
5621: LD_VAR 0 2
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: LD_ADDR_VAR 0 6
5630: PUSH
5631: LD_VAR 0 1
5635: PPUSH
5636: CALL_OW 503
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: LD_VAR 0 6
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: LD_ADDR_VAR 0 4
5656: PUSH
5657: LD_VAR 0 6
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: LD_ADDR_VAR 0 7
5666: PUSH
5667: LD_OWVAR 3
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: DIFF
5694: PPUSH
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 74
5704: ST_TO_ADDR
// if nearest_unit then
5705: LD_VAR 0 7
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_VAR 0 7
5720: PPUSH
5721: CALL_OW 255
5725: ST_TO_ADDR
// if not side and not side2 then
5726: LD_VAR 0 4
5730: NOT
5731: PUSH
5732: LD_VAR 0 5
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 5
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: LD_VAR 0 4
5758: PPUSH
5759: LD_VAR 0 8
5763: PPUSH
5764: CALL 4736 0 2
5768: GO 5818
// begin if side then
5770: LD_VAR 0 4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: LD_VAR 0 4
5780: PPUSH
5781: LD_VAR 0 8
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: CALL 4736 0 2
// if side2 then
5794: LD_VAR 0 5
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: LD_VAR 0 5
5804: PPUSH
5805: LD_VAR 0 8
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: CALL 4736 0 2
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 4894 0 1
5838: PPUSH
5839: CALL 4736 0 2
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: LD_ADDR_VAR 0 9
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: CALL_OW 69
5878: ST_TO_ADDR
// side_bot := side ;
5879: LD_ADDR_EXP 3
5883: PUSH
5884: LD_VAR 0 1
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: LD_VAR 0 9
5893: PUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_VAR 0 9
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: LD_VAR 0 3
5922: PPUSH
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 235
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: LD_ADDR_VAR 0 10
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 10
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: LD_VAR 0 3
6012: PPUSH
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 322
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: LD_ADDR_VAR 0 8
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_OWVAR 67
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: CALL_OW 169
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: CALL_OW 67
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: LD_VAR 0 1
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: LD_ADDR_EXP 33
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: LD_VAR 0 8
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: CALL 18090 0 6
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: LD_ADDR_EXP 34
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: LD_VAR 0 8
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL 18090 0 6
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: LD_ADDR_EXP 31
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: LD_VAR 0 8
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL 18090 0 6
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: LD_ADDR_EXP 32
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: LD_VAR 0 8
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL 18090 0 6
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: LD_ADDR_EXP 35
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: LD_VAR 0 8
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: CALL 18090 0 6
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: LD_ADDR_EXP 43
6377: PUSH
6378: LD_EXP 33
6382: PUSH
6383: LD_EXP 31
6387: PUSH
6388: LD_EXP 35
6392: PUSH
6393: LD_EXP 32
6397: PUSH
6398: LD_EXP 34
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: LD_ADDR_VAR 0 5
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: LD_VAR 0 3
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: LD_VAR 0 8
6511: PPUSH
6512: CALL_OW 380
// un := CreateVehicle ;
6516: LD_ADDR_VAR 0 6
6520: PUSH
6521: CALL_OW 45
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: PPUSH
6542: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: LD_VAR 0 5
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: CALL_OW 50
// un2 := CreateHuman ;
6579: LD_ADDR_VAR 0 7
6583: PUSH
6584: CALL_OW 44
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: LD_VAR 0 7
6593: PPUSH
6594: LD_VAR 0 6
6598: PPUSH
6599: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: LD_ADDR_EXP 43
6607: PUSH
6608: LD_EXP 43
6612: PPUSH
6613: LD_VAR 0 3
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: LD_EXP 43
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: LD_VAR 0 6
6657: PPUSH
6658: CALL 14797 0 3
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: LD_ADDR_EXP 43
6667: PUSH
6668: LD_EXP 43
6672: PPUSH
6673: LD_VAR 0 3
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: LD_EXP 43
6690: PUSH
6691: LD_VAR 0 3
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: LD_VAR 0 7
6717: PPUSH
6718: CALL 14797 0 3
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: LD_EXP 3
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: LD_VAR 0 3
6777: PPUSH
6778: CALL_OW 274
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: LD_ADDR_VAR 0 4
6790: PUSH
6791: LD_VAR 0 3
6795: PPUSH
6796: CALL_OW 254
6800: ST_TO_ADDR
// if d < 3 then
6801: LD_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: LD_ADDR_VAR 0 4
6815: PUSH
6816: LD_VAR 0 4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: LD_ADDR_VAR 0 4
6831: PUSH
6832: LD_VAR 0 4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: LD_VAR 0 8
6851: PPUSH
6852: CALL_OW 380
// un := CreateHuman ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: CALL_OW 44
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: LD_VAR 0 6
6870: PPUSH
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6880: LD_VAR 0 6
6884: PPUSH
6885: LD_VAR 0 3
6889: PPUSH
6890: CALL_OW 52
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: LD_ADDR_EXP 36
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_VAR 0 8
6915: PPUSH
6916: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: LD_ADDR_EXP 36
6940: PUSH
6941: LD_EXP 36
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: CALL_OW 44
6953: PPUSH
6954: CALL_OW 1
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: LD_VAR 0 8
6969: PPUSH
6970: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: LD_ADDR_EXP 36
6994: PUSH
6995: LD_EXP 36
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: CALL_OW 44
7007: PPUSH
7008: CALL_OW 1
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: LD_VAR 0 8
7023: PPUSH
7024: CALL_OW 380
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: LD_ADDR_EXP 36
7040: PUSH
7041: LD_EXP 36
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 44
7053: PPUSH
7054: CALL_OW 1
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: LD_ADDR_EXP 39
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: LD_EXP 39
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: CALL_OW 52
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: LD_ADDR_EXP 40
7203: PUSH
7204: CALL_OW 44
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: LD_EXP 40
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: CALL_OW 52
// InitHc ;
7221: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: LD_ADDR_EXP 38
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: LD_ADDR_VAR 0 4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: LD_OWVAR 67
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: LD_ADDR_VAR 0 3
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 12
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: CALL 14675 0 5
// un := CreateVehicle ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: CALL_OW 45
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: LD_ADDR_EXP 38
7391: PUSH
7392: LD_EXP 38
7396: PPUSH
7397: LD_VAR 0 3
7401: PUSH
7402: LD_EXP 38
7406: PUSH
7407: LD_VAR 0 3
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: LD_VAR 0 6
7425: PPUSH
7426: CALL 14797 0 3
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: LD_VAR 0 6
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: CALL_OW 12
7446: PPUSH
7447: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: LD_VAR 0 6
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_VAR 0 3
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: CALL_OW 19
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: CALL_OW 302
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: CALL_OW 255
7519: PUSH
7520: LD_EXP 3
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: LD_ADDR_VAR 0 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: LD_ADDR_VAR 0 7
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: LD_ADDR_VAR 0 6
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: LD_ADDR_VAR 0 9
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: LD_ADDR_VAR 0 5
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: LD_OWVAR 67
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: LD_ADDR_VAR 0 1
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_OWVAR 67
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_VAR 0 5
7790: PPUSH
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: CALL_OW 12
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 2
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: LD_VAR 0 4
7858: PPUSH
7859: LD_VAR 0 5
7863: PPUSH
7864: CALL 70814 0 2
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7875: LD_VAR 0 4
7879: PPUSH
7880: CALL 71210 0 1
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: CALL_OW 67
// for i = 1 to coords do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: LD_VAR 0 6
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: LD_EXP 3
7924: PPUSH
7925: LD_VAR 0 6
7929: PUSH
7930: LD_VAR 0 1
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: LD_VAR 0 6
7944: PUSH
7945: LD_VAR 0 1
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: CALL 15693 0 4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: LD_VAR 0 2
7971: PUSH
7972: LD_VAR 0 3
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 2
7988: ST_TO_ADDR
// target := i ;
7989: LD_ADDR_VAR 0 9
7993: PUSH
7994: LD_VAR 0 1
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: LD_VAR 0 9
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: LD_ADDR_VAR 0 10
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: LD_ADDR_VAR 0 10
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: LD_VAR 0 10
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: LD_ADDR_VAR 0 10
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: LD_VAR 0 4
8209: PPUSH
8210: LD_EXP 62
8214: PUSH
8215: LD_VAR 0 4
8219: ARRAY
8220: PPUSH
8221: LD_VAR 0 10
8225: PPUSH
8226: LD_VAR 0 7
8230: PPUSH
8231: CALL 71047 0 4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: CALL_OW 302
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: CALL_OW 255
8253: PUSH
8254: LD_EXP 3
8258: EQUAL
8259: AND
8260: PUSH
8261: LD_EXP 26
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: CALL_OW 301
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: CALL_OW 255
8286: PUSH
8287: LD_EXP 3
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: LD_ADDR_VAR 0 7
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: LD_ADDR_VAR 0 9
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: LD_ADDR_VAR 0 5
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: LD_OWVAR 67
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: LD_ADDR_VAR 0 1
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: LD_OWVAR 67
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: LD_ADDR_VAR 0 5
8512: PUSH
8513: LD_VAR 0 5
8517: PPUSH
8518: LD_VAR 0 5
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 1
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 2
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 5
8588: PPUSH
8589: CALL 70814 0 2
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL 71210 0 1
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: CALL_OW 67
// for i = 1 to coords do
8622: LD_ADDR_VAR 0 1
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: LD_VAR 0 6
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_EXP 3
8649: PPUSH
8650: LD_VAR 0 6
8654: PUSH
8655: LD_VAR 0 1
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_VAR 0 6
8669: PUSH
8670: LD_VAR 0 1
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: CALL 15693 0 4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_VAR 0 3
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_VAR 0 2
8713: ST_TO_ADDR
// target := i ;
8714: LD_ADDR_VAR 0 9
8718: PUSH
8719: LD_VAR 0 1
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: LD_VAR 0 9
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: LD_ADDR_VAR 0 10
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: LD_VAR 0 10
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: LD_ADDR_VAR 0 10
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_EXP 62
8859: PUSH
8860: LD_VAR 0 4
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 10
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL 71047 0 4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: LD_EXP 4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 255
8904: PPUSH
8905: CALL 5823 0 1
// artifact_get := true ;
8909: LD_ADDR_EXP 4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: LD_ADDR_VAR 0 3
8928: PUSH
8929: LD_VAR 0 1
8933: PPUSH
8934: CALL_OW 255
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_EXP 69
8948: IN
8949: NOT
8950: PUSH
8951: LD_EXP 7
8955: PUSH
8956: LD_VAR 0 3
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: LD_VAR 0 1
8968: PPUSH
8969: CALL_OW 247
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: LD_VAR 0 3
8983: PPUSH
8984: CALL 5463 0 1
// if side in mc_sides then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_EXP 69
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: LD_VAR 0 1
9004: PUSH
9005: LD_EXP 40
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: CALL 5577 0 2
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: CALL 4894 0 1
9038: PPUSH
9039: CALL 5577 0 2
// if multi_commanders and multi_custom_commanders then
9043: LD_EXP 24
9047: PUSH
9048: LD_EXP 16
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: LD_VAR 0 1
9059: PUSH
9060: LD_EXP 24
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: LD_ADDR_EXP 25
9071: PUSH
9072: LD_EXP 25
9076: PPUSH
9077: LD_VAR 0 3
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: CALL_OW 1
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: LD_ADDR_EXP 24
9094: PUSH
9095: LD_EXP 24
9099: PUSH
9100: LD_VAR 0 1
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: CALL 4927 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL 74273 0 1
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL 76607 0 2
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: LD_VAR 0 1
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_EXP 69
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: LD_VAR 0 1
9169: PPUSH
9170: CALL_OW 255
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 266
9184: PPUSH
9185: CALL 5507 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: LD_VAR 0 1
9193: PPUSH
9194: CALL_OW 266
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_EXP 69
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: LD_EXP 5
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: LD_VAR 0 1
9232: PPUSH
9233: LD_EXP 5
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9246: LD_ADDR_EXP 5
9250: PUSH
9251: LD_EXP 5
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: CALL_OW 3
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: CALL 75916 0 1
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL 73969 0 2
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: LD_VAR 0 1
9297: PPUSH
9298: LD_VAR 0 2
9302: PPUSH
9303: LD_VAR 0 3
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: LD_VAR 0 5
9317: PPUSH
9318: CALL 73589 0 5
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 255
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: LD_VAR 0 4
9349: PUSH
9350: LD_EXP 69
9354: IN
9355: NOT
9356: PUSH
9357: LD_EXP 7
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: LD_VAR 0 4
9374: PPUSH
9375: CALL 5419 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_VAR 0 2
9388: PPUSH
9389: CALL 73179 0 2
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: LD_VAR 0 1
9400: PPUSH
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 3
9410: PPUSH
9411: LD_VAR 0 4
9415: PPUSH
9416: CALL 73017 0 4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: LD_VAR 0 3
9437: PPUSH
9438: CALL 72792 0 3
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_VAR 0 2
9454: PPUSH
9455: CALL 72677 0 2
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: LD_VAR 0 1
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: CALL 76868 0 2
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PPUSH
9489: LD_VAR 0 3
9493: PPUSH
9494: LD_VAR 0 4
9498: PPUSH
9499: CALL 77084 0 4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: LD_EXP 2
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: LD_EXP 21
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: LD_EXP 21
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: CALL 9556 0 3
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: LD_VAR 0 1
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 67
// x := 5 ;
9599: LD_ADDR_VAR 0 6
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: LD_OWVAR 1
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: LD_OWVAR 67
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: LD_ADDR_VAR 0 5
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_EXP 7
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: LD_EXP 7
9656: PUSH
9657: LD_VAR 0 5
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: LD_VAR 0 6
9668: PPUSH
9669: LD_VAR 0 7
9673: PUSH
9674: LD_EXP 7
9678: PUSH
9679: LD_VAR 0 5
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 55
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: CALL_OW 67
// end ; for i in areas do
9704: LD_ADDR_VAR 0 5
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9724: LD_VAR 0 6
9728: PPUSH
9729: LD_VAR 0 5
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL_OW 55
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_VAR 0 2
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: LD_ADDR_VAR 0 3
9763: PUSH
9764: LD_VAR 0 3
9768: PUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: LD_ADDR_VAR 0 6
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: LD_ADDR_VAR 0 6
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: LD_EXP 2
9833: NOT
9834: PUSH
9835: LD_VAR 0 3
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: LD_VAR 0 2
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: LD_ADDR_VAR 0 5
9865: PUSH
9866: LD_VAR 0 3
9870: PUSH
9871: LD_VAR 0 1
9875: STR
9876: PPUSH
9877: CALL_OW 34
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: LD_ADDR_VAR 0 5
9888: PUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 25
9898: ST_TO_ADDR
// result := unit ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_VAR 0 5
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: LD_VAR 0 1
9922: NOT
9923: PUSH
9924: LD_VAR 0 2
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10698
// case nation of nation_american :
9934: LD_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: LD_ADDR_VAR 0 4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10622
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10391
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10170: LD_ADDR_VAR 0 4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: ST_TO_ADDR
10389: GO 10622
10391: LD_INT 3
10393: DOUBLE
10394: EQUAL
10395: IFTRUE 10399
10397: GO 10621
10399: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10400: LD_ADDR_VAR 0 4
10404: PUSH
10405: LD_INT 46
10407: PUSH
10408: LD_INT 47
10410: PUSH
10411: LD_INT 1
10413: PUSH
10414: LD_INT 2
10416: PUSH
10417: LD_INT 82
10419: PUSH
10420: LD_INT 83
10422: PUSH
10423: LD_INT 84
10425: PUSH
10426: LD_INT 85
10428: PUSH
10429: LD_INT 86
10431: PUSH
10432: LD_INT 11
10434: PUSH
10435: LD_INT 9
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 19
10443: PUSH
10444: LD_INT 21
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 25
10455: PUSH
10456: LD_INT 28
10458: PUSH
10459: LD_INT 29
10461: PUSH
10462: LD_INT 30
10464: PUSH
10465: LD_INT 31
10467: PUSH
10468: LD_INT 37
10470: PUSH
10471: LD_INT 38
10473: PUSH
10474: LD_INT 32
10476: PUSH
10477: LD_INT 27
10479: PUSH
10480: LD_INT 33
10482: PUSH
10483: LD_INT 69
10485: PUSH
10486: LD_INT 39
10488: PUSH
10489: LD_INT 34
10491: PUSH
10492: LD_INT 40
10494: PUSH
10495: LD_INT 71
10497: PUSH
10498: LD_INT 23
10500: PUSH
10501: LD_INT 44
10503: PUSH
10504: LD_INT 48
10506: PUSH
10507: LD_INT 49
10509: PUSH
10510: LD_INT 50
10512: PUSH
10513: LD_INT 51
10515: PUSH
10516: LD_INT 52
10518: PUSH
10519: LD_INT 53
10521: PUSH
10522: LD_INT 54
10524: PUSH
10525: LD_INT 55
10527: PUSH
10528: LD_INT 56
10530: PUSH
10531: LD_INT 57
10533: PUSH
10534: LD_INT 58
10536: PUSH
10537: LD_INT 59
10539: PUSH
10540: LD_INT 63
10542: PUSH
10543: LD_INT 64
10545: PUSH
10546: LD_INT 65
10548: PUSH
10549: LD_INT 82
10551: PUSH
10552: LD_INT 83
10554: PUSH
10555: LD_INT 84
10557: PUSH
10558: LD_INT 85
10560: PUSH
10561: LD_INT 86
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: ST_TO_ADDR
10619: GO 10622
10621: POP
// if state > - 1 and state < 3 then
10622: LD_VAR 0 3
10626: PUSH
10627: LD_INT 1
10629: NEG
10630: GREATER
10631: PUSH
10632: LD_VAR 0 3
10636: PUSH
10637: LD_INT 3
10639: LESS
10640: AND
10641: IFFALSE 10698
// for i in result do
10643: LD_ADDR_VAR 0 5
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: FOR_IN
10654: IFFALSE 10696
// if GetTech ( i , side ) <> state then
10656: LD_VAR 0 5
10660: PPUSH
10661: LD_VAR 0 1
10665: PPUSH
10666: CALL_OW 321
10670: PUSH
10671: LD_VAR 0 3
10675: NONEQUAL
10676: IFFALSE 10694
// result := result diff i ;
10678: LD_ADDR_VAR 0 4
10682: PUSH
10683: LD_VAR 0 4
10687: PUSH
10688: LD_VAR 0 5
10692: DIFF
10693: ST_TO_ADDR
10694: GO 10653
10696: POP
10697: POP
// end ;
10698: LD_VAR 0 4
10702: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
// result := true ;
10708: LD_ADDR_VAR 0 3
10712: PUSH
10713: LD_INT 1
10715: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10716: LD_ADDR_VAR 0 5
10720: PUSH
10721: LD_VAR 0 2
10725: PPUSH
10726: CALL_OW 480
10730: ST_TO_ADDR
// if not tmp then
10731: LD_VAR 0 5
10735: NOT
10736: IFFALSE 10740
// exit ;
10738: GO 10789
// for i in tmp do
10740: LD_ADDR_VAR 0 4
10744: PUSH
10745: LD_VAR 0 5
10749: PUSH
10750: FOR_IN
10751: IFFALSE 10787
// if GetTech ( i , side ) <> state_researched then
10753: LD_VAR 0 4
10757: PPUSH
10758: LD_VAR 0 1
10762: PPUSH
10763: CALL_OW 321
10767: PUSH
10768: LD_INT 2
10770: NONEQUAL
10771: IFFALSE 10785
// begin result := false ;
10773: LD_ADDR_VAR 0 3
10777: PUSH
10778: LD_INT 0
10780: ST_TO_ADDR
// exit ;
10781: POP
10782: POP
10783: GO 10789
// end ;
10785: GO 10750
10787: POP
10788: POP
// end ;
10789: LD_VAR 0 3
10793: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10794: LD_INT 0
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10809: LD_VAR 0 1
10813: NOT
10814: PUSH
10815: LD_VAR 0 1
10819: PPUSH
10820: CALL_OW 257
10824: PUSH
10825: LD_INT 9
10827: NONEQUAL
10828: OR
10829: IFFALSE 10833
// exit ;
10831: GO 11406
// side := GetSide ( unit ) ;
10833: LD_ADDR_VAR 0 9
10837: PUSH
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 255
10847: ST_TO_ADDR
// tech_space := tech_spacanom ;
10848: LD_ADDR_VAR 0 12
10852: PUSH
10853: LD_INT 29
10855: ST_TO_ADDR
// tech_time := tech_taurad ;
10856: LD_ADDR_VAR 0 13
10860: PUSH
10861: LD_INT 28
10863: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10864: LD_ADDR_VAR 0 11
10868: PUSH
10869: LD_VAR 0 1
10873: PPUSH
10874: CALL_OW 310
10878: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10879: LD_VAR 0 11
10883: PPUSH
10884: CALL_OW 247
10888: PUSH
10889: LD_INT 2
10891: EQUAL
10892: IFFALSE 10896
// exit ;
10894: GO 11406
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10896: LD_ADDR_VAR 0 8
10900: PUSH
10901: LD_INT 81
10903: PUSH
10904: LD_VAR 0 9
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 3
10915: PUSH
10916: LD_INT 21
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PPUSH
10934: CALL_OW 69
10938: ST_TO_ADDR
// if not tmp then
10939: LD_VAR 0 8
10943: NOT
10944: IFFALSE 10948
// exit ;
10946: GO 11406
// if in_unit then
10948: LD_VAR 0 11
10952: IFFALSE 10976
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10954: LD_ADDR_VAR 0 10
10958: PUSH
10959: LD_VAR 0 8
10963: PPUSH
10964: LD_VAR 0 11
10968: PPUSH
10969: CALL_OW 74
10973: ST_TO_ADDR
10974: GO 10996
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10976: LD_ADDR_VAR 0 10
10980: PUSH
10981: LD_VAR 0 8
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: ST_TO_ADDR
// if not enemy then
10996: LD_VAR 0 10
11000: NOT
11001: IFFALSE 11005
// exit ;
11003: GO 11406
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11005: LD_VAR 0 11
11009: PUSH
11010: LD_VAR 0 11
11014: PPUSH
11015: LD_VAR 0 10
11019: PPUSH
11020: CALL_OW 296
11024: PUSH
11025: LD_INT 13
11027: GREATER
11028: AND
11029: PUSH
11030: LD_VAR 0 1
11034: PPUSH
11035: LD_VAR 0 10
11039: PPUSH
11040: CALL_OW 296
11044: PUSH
11045: LD_INT 12
11047: GREATER
11048: OR
11049: IFFALSE 11053
// exit ;
11051: GO 11406
// missile := [ 1 ] ;
11053: LD_ADDR_VAR 0 14
11057: PUSH
11058: LD_INT 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11064: LD_VAR 0 9
11068: PPUSH
11069: LD_VAR 0 12
11073: PPUSH
11074: CALL_OW 325
11078: IFFALSE 11107
// missile := Insert ( missile , missile + 1 , 2 ) ;
11080: LD_ADDR_VAR 0 14
11084: PUSH
11085: LD_VAR 0 14
11089: PPUSH
11090: LD_VAR 0 14
11094: PUSH
11095: LD_INT 1
11097: PLUS
11098: PPUSH
11099: LD_INT 2
11101: PPUSH
11102: CALL_OW 2
11106: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11107: LD_VAR 0 9
11111: PPUSH
11112: LD_VAR 0 13
11116: PPUSH
11117: CALL_OW 325
11121: PUSH
11122: LD_VAR 0 10
11126: PPUSH
11127: CALL_OW 255
11131: PPUSH
11132: LD_VAR 0 13
11136: PPUSH
11137: CALL_OW 325
11141: NOT
11142: AND
11143: IFFALSE 11172
// missile := Insert ( missile , missile + 1 , 3 ) ;
11145: LD_ADDR_VAR 0 14
11149: PUSH
11150: LD_VAR 0 14
11154: PPUSH
11155: LD_VAR 0 14
11159: PUSH
11160: LD_INT 1
11162: PLUS
11163: PPUSH
11164: LD_INT 3
11166: PPUSH
11167: CALL_OW 2
11171: ST_TO_ADDR
// if missile < 2 then
11172: LD_VAR 0 14
11176: PUSH
11177: LD_INT 2
11179: LESS
11180: IFFALSE 11184
// exit ;
11182: GO 11406
// x := GetX ( enemy ) ;
11184: LD_ADDR_VAR 0 4
11188: PUSH
11189: LD_VAR 0 10
11193: PPUSH
11194: CALL_OW 250
11198: ST_TO_ADDR
// y := GetY ( enemy ) ;
11199: LD_ADDR_VAR 0 5
11203: PUSH
11204: LD_VAR 0 10
11208: PPUSH
11209: CALL_OW 251
11213: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 4
11223: PUSH
11224: LD_INT 1
11226: NEG
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL_OW 12
11235: PLUS
11236: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11237: LD_ADDR_VAR 0 7
11241: PUSH
11242: LD_VAR 0 5
11246: PUSH
11247: LD_INT 1
11249: NEG
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: CALL_OW 12
11258: PLUS
11259: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11260: LD_VAR 0 6
11264: PPUSH
11265: LD_VAR 0 7
11269: PPUSH
11270: CALL_OW 488
11274: NOT
11275: IFFALSE 11297
// begin _x := x ;
11277: LD_ADDR_VAR 0 6
11281: PUSH
11282: LD_VAR 0 4
11286: ST_TO_ADDR
// _y := y ;
11287: LD_ADDR_VAR 0 7
11291: PUSH
11292: LD_VAR 0 5
11296: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11297: LD_ADDR_VAR 0 3
11301: PUSH
11302: LD_INT 1
11304: PPUSH
11305: LD_VAR 0 14
11309: PPUSH
11310: CALL_OW 12
11314: ST_TO_ADDR
// case i of 1 :
11315: LD_VAR 0 3
11319: PUSH
11320: LD_INT 1
11322: DOUBLE
11323: EQUAL
11324: IFTRUE 11328
11326: GO 11345
11328: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11329: LD_VAR 0 1
11333: PPUSH
11334: LD_VAR 0 10
11338: PPUSH
11339: CALL_OW 115
11343: GO 11406
11345: LD_INT 2
11347: DOUBLE
11348: EQUAL
11349: IFTRUE 11353
11351: GO 11375
11353: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_VAR 0 6
11363: PPUSH
11364: LD_VAR 0 7
11368: PPUSH
11369: CALL_OW 153
11373: GO 11406
11375: LD_INT 3
11377: DOUBLE
11378: EQUAL
11379: IFTRUE 11383
11381: GO 11405
11383: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11384: LD_VAR 0 1
11388: PPUSH
11389: LD_VAR 0 6
11393: PPUSH
11394: LD_VAR 0 7
11398: PPUSH
11399: CALL_OW 154
11403: GO 11406
11405: POP
// end ;
11406: LD_VAR 0 2
11410: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11411: LD_INT 0
11413: PPUSH
11414: PPUSH
11415: PPUSH
11416: PPUSH
11417: PPUSH
11418: PPUSH
// if not unit or not building then
11419: LD_VAR 0 1
11423: NOT
11424: PUSH
11425: LD_VAR 0 2
11429: NOT
11430: OR
11431: IFFALSE 11435
// exit ;
11433: GO 11593
// x := GetX ( building ) ;
11435: LD_ADDR_VAR 0 5
11439: PUSH
11440: LD_VAR 0 2
11444: PPUSH
11445: CALL_OW 250
11449: ST_TO_ADDR
// y := GetY ( building ) ;
11450: LD_ADDR_VAR 0 6
11454: PUSH
11455: LD_VAR 0 2
11459: PPUSH
11460: CALL_OW 251
11464: ST_TO_ADDR
// for i = 0 to 5 do
11465: LD_ADDR_VAR 0 4
11469: PUSH
11470: DOUBLE
11471: LD_INT 0
11473: DEC
11474: ST_TO_ADDR
11475: LD_INT 5
11477: PUSH
11478: FOR_TO
11479: IFFALSE 11591
// begin _x := ShiftX ( x , i , 3 ) ;
11481: LD_ADDR_VAR 0 7
11485: PUSH
11486: LD_VAR 0 5
11490: PPUSH
11491: LD_VAR 0 4
11495: PPUSH
11496: LD_INT 3
11498: PPUSH
11499: CALL_OW 272
11503: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11504: LD_ADDR_VAR 0 8
11508: PUSH
11509: LD_VAR 0 6
11513: PPUSH
11514: LD_VAR 0 4
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: CALL_OW 273
11526: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11527: LD_VAR 0 7
11531: PPUSH
11532: LD_VAR 0 8
11536: PPUSH
11537: CALL_OW 488
11541: NOT
11542: IFFALSE 11546
// continue ;
11544: GO 11478
// if HexInfo ( _x , _y ) = 0 then
11546: LD_VAR 0 7
11550: PPUSH
11551: LD_VAR 0 8
11555: PPUSH
11556: CALL_OW 428
11560: PUSH
11561: LD_INT 0
11563: EQUAL
11564: IFFALSE 11589
// begin ComMoveXY ( unit , _x , _y ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: LD_VAR 0 7
11575: PPUSH
11576: LD_VAR 0 8
11580: PPUSH
11581: CALL_OW 111
// exit ;
11585: POP
11586: POP
11587: GO 11593
// end ; end ;
11589: GO 11478
11591: POP
11592: POP
// end ;
11593: LD_VAR 0 3
11597: RET
// export function ScanBase ( side , base_area ) ; begin
11598: LD_INT 0
11600: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11601: LD_ADDR_VAR 0 3
11605: PUSH
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 81
11613: PUSH
11614: LD_VAR 0 1
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 70
11627: ST_TO_ADDR
// end ;
11628: LD_VAR 0 3
11632: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11633: LD_INT 0
11635: PPUSH
11636: PPUSH
11637: PPUSH
11638: PPUSH
// result := false ;
11639: LD_ADDR_VAR 0 2
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
// side := GetSide ( unit ) ;
11647: LD_ADDR_VAR 0 3
11651: PUSH
11652: LD_VAR 0 1
11656: PPUSH
11657: CALL_OW 255
11661: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11662: LD_ADDR_VAR 0 4
11666: PUSH
11667: LD_VAR 0 1
11671: PPUSH
11672: CALL_OW 248
11676: ST_TO_ADDR
// case nat of 1 :
11677: LD_VAR 0 4
11681: PUSH
11682: LD_INT 1
11684: DOUBLE
11685: EQUAL
11686: IFTRUE 11690
11688: GO 11701
11690: POP
// tech := tech_lassight ; 2 :
11691: LD_ADDR_VAR 0 5
11695: PUSH
11696: LD_INT 12
11698: ST_TO_ADDR
11699: GO 11740
11701: LD_INT 2
11703: DOUBLE
11704: EQUAL
11705: IFTRUE 11709
11707: GO 11720
11709: POP
// tech := tech_mortar ; 3 :
11710: LD_ADDR_VAR 0 5
11714: PUSH
11715: LD_INT 41
11717: ST_TO_ADDR
11718: GO 11740
11720: LD_INT 3
11722: DOUBLE
11723: EQUAL
11724: IFTRUE 11728
11726: GO 11739
11728: POP
// tech := tech_bazooka ; end ;
11729: LD_ADDR_VAR 0 5
11733: PUSH
11734: LD_INT 44
11736: ST_TO_ADDR
11737: GO 11740
11739: POP
// if Researched ( side , tech ) then
11740: LD_VAR 0 3
11744: PPUSH
11745: LD_VAR 0 5
11749: PPUSH
11750: CALL_OW 325
11754: IFFALSE 11781
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11756: LD_ADDR_VAR 0 2
11760: PUSH
11761: LD_INT 5
11763: PUSH
11764: LD_INT 8
11766: PUSH
11767: LD_INT 9
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: LD_VAR 0 4
11779: ARRAY
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 2
11785: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11786: LD_INT 0
11788: PPUSH
11789: PPUSH
11790: PPUSH
// if not mines then
11791: LD_VAR 0 2
11795: NOT
11796: IFFALSE 11800
// exit ;
11798: GO 11944
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_INT 81
11807: PUSH
11808: LD_VAR 0 1
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: PUSH
11817: LD_INT 3
11819: PUSH
11820: LD_INT 21
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PPUSH
11838: CALL_OW 69
11842: ST_TO_ADDR
// for i in mines do
11843: LD_ADDR_VAR 0 4
11847: PUSH
11848: LD_VAR 0 2
11852: PUSH
11853: FOR_IN
11854: IFFALSE 11942
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11856: LD_VAR 0 4
11860: PUSH
11861: LD_INT 1
11863: ARRAY
11864: PPUSH
11865: LD_VAR 0 4
11869: PUSH
11870: LD_INT 2
11872: ARRAY
11873: PPUSH
11874: CALL_OW 458
11878: NOT
11879: IFFALSE 11883
// continue ;
11881: GO 11853
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11883: LD_VAR 0 4
11887: PUSH
11888: LD_INT 1
11890: ARRAY
11891: PPUSH
11892: LD_VAR 0 4
11896: PUSH
11897: LD_INT 2
11899: ARRAY
11900: PPUSH
11901: CALL_OW 428
11905: PUSH
11906: LD_VAR 0 5
11910: IN
11911: IFFALSE 11940
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11913: LD_VAR 0 4
11917: PUSH
11918: LD_INT 1
11920: ARRAY
11921: PPUSH
11922: LD_VAR 0 4
11926: PUSH
11927: LD_INT 2
11929: ARRAY
11930: PPUSH
11931: LD_VAR 0 1
11935: PPUSH
11936: CALL_OW 456
// end ;
11940: GO 11853
11942: POP
11943: POP
// end ;
11944: LD_VAR 0 3
11948: RET
// export function Count ( array ) ; var i ; begin
11949: LD_INT 0
11951: PPUSH
11952: PPUSH
// result := 0 ;
11953: LD_ADDR_VAR 0 2
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// for i in array do
11961: LD_ADDR_VAR 0 3
11965: PUSH
11966: LD_VAR 0 1
11970: PUSH
11971: FOR_IN
11972: IFFALSE 11996
// if i then
11974: LD_VAR 0 3
11978: IFFALSE 11994
// result := result + 1 ;
11980: LD_ADDR_VAR 0 2
11984: PUSH
11985: LD_VAR 0 2
11989: PUSH
11990: LD_INT 1
11992: PLUS
11993: ST_TO_ADDR
11994: GO 11971
11996: POP
11997: POP
// end ;
11998: LD_VAR 0 2
12002: RET
// export function IsEmpty ( building ) ; begin
12003: LD_INT 0
12005: PPUSH
// if not building then
12006: LD_VAR 0 1
12010: NOT
12011: IFFALSE 12015
// exit ;
12013: GO 12058
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12015: LD_ADDR_VAR 0 2
12019: PUSH
12020: LD_VAR 0 1
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 58
12044: PUSH
12045: EMPTY
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PPUSH
12052: CALL_OW 69
12056: IN
12057: ST_TO_ADDR
// end ;
12058: LD_VAR 0 2
12062: RET
// export function IsNotFull ( building ) ; begin
12063: LD_INT 0
12065: PPUSH
// if not building then
12066: LD_VAR 0 1
12070: NOT
12071: IFFALSE 12075
// exit ;
12073: GO 12094
// result := UnitsInside ( building ) < 6 ;
12075: LD_ADDR_VAR 0 2
12079: PUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 313
12089: PUSH
12090: LD_INT 6
12092: LESS
12093: ST_TO_ADDR
// end ;
12094: LD_VAR 0 2
12098: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
12103: PPUSH
12104: PPUSH
// tmp := [ ] ;
12105: LD_ADDR_VAR 0 3
12109: PUSH
12110: EMPTY
12111: ST_TO_ADDR
// list := [ ] ;
12112: LD_ADDR_VAR 0 5
12116: PUSH
12117: EMPTY
12118: ST_TO_ADDR
// for i = 16 to 25 do
12119: LD_ADDR_VAR 0 4
12123: PUSH
12124: DOUBLE
12125: LD_INT 16
12127: DEC
12128: ST_TO_ADDR
12129: LD_INT 25
12131: PUSH
12132: FOR_TO
12133: IFFALSE 12206
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12135: LD_ADDR_VAR 0 3
12139: PUSH
12140: LD_VAR 0 3
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: LD_VAR 0 1
12152: PPUSH
12153: CALL_OW 255
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 91
12164: PUSH
12165: LD_VAR 0 1
12169: PUSH
12170: LD_INT 6
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 30
12180: PUSH
12181: LD_VAR 0 4
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: PUSH
12195: EMPTY
12196: LIST
12197: PPUSH
12198: CALL_OW 69
12202: ADD
12203: ST_TO_ADDR
12204: GO 12132
12206: POP
12207: POP
// for i = 1 to tmp do
12208: LD_ADDR_VAR 0 4
12212: PUSH
12213: DOUBLE
12214: LD_INT 1
12216: DEC
12217: ST_TO_ADDR
12218: LD_VAR 0 3
12222: PUSH
12223: FOR_TO
12224: IFFALSE 12312
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12226: LD_ADDR_VAR 0 5
12230: PUSH
12231: LD_VAR 0 5
12235: PUSH
12236: LD_VAR 0 3
12240: PUSH
12241: LD_VAR 0 4
12245: ARRAY
12246: PPUSH
12247: CALL_OW 266
12251: PUSH
12252: LD_VAR 0 3
12256: PUSH
12257: LD_VAR 0 4
12261: ARRAY
12262: PPUSH
12263: CALL_OW 250
12267: PUSH
12268: LD_VAR 0 3
12272: PUSH
12273: LD_VAR 0 4
12277: ARRAY
12278: PPUSH
12279: CALL_OW 251
12283: PUSH
12284: LD_VAR 0 3
12288: PUSH
12289: LD_VAR 0 4
12293: ARRAY
12294: PPUSH
12295: CALL_OW 254
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: PUSH
12306: EMPTY
12307: LIST
12308: ADD
12309: ST_TO_ADDR
12310: GO 12223
12312: POP
12313: POP
// result := list ;
12314: LD_ADDR_VAR 0 2
12318: PUSH
12319: LD_VAR 0 5
12323: ST_TO_ADDR
// end ;
12324: LD_VAR 0 2
12328: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12329: LD_INT 0
12331: PPUSH
12332: PPUSH
12333: PPUSH
12334: PPUSH
12335: PPUSH
12336: PPUSH
12337: PPUSH
// if not factory then
12338: LD_VAR 0 1
12342: NOT
12343: IFFALSE 12347
// exit ;
12345: GO 12940
// if control = control_apeman then
12347: LD_VAR 0 4
12351: PUSH
12352: LD_INT 5
12354: EQUAL
12355: IFFALSE 12464
// begin tmp := UnitsInside ( factory ) ;
12357: LD_ADDR_VAR 0 8
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 313
12371: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12372: LD_VAR 0 8
12376: PPUSH
12377: LD_INT 25
12379: PUSH
12380: LD_INT 12
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PPUSH
12387: CALL_OW 72
12391: NOT
12392: IFFALSE 12402
// control := control_manual ;
12394: LD_ADDR_VAR 0 4
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12402: LD_ADDR_VAR 0 8
12406: PUSH
12407: LD_VAR 0 1
12411: PPUSH
12412: CALL 12099 0 1
12416: ST_TO_ADDR
// if tmp then
12417: LD_VAR 0 8
12421: IFFALSE 12464
// begin for i in tmp do
12423: LD_ADDR_VAR 0 7
12427: PUSH
12428: LD_VAR 0 8
12432: PUSH
12433: FOR_IN
12434: IFFALSE 12462
// if i [ 1 ] = b_ext_radio then
12436: LD_VAR 0 7
12440: PUSH
12441: LD_INT 1
12443: ARRAY
12444: PUSH
12445: LD_INT 22
12447: EQUAL
12448: IFFALSE 12460
// begin control := control_remote ;
12450: LD_ADDR_VAR 0 4
12454: PUSH
12455: LD_INT 2
12457: ST_TO_ADDR
// break ;
12458: GO 12462
// end ;
12460: GO 12433
12462: POP
12463: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12464: LD_VAR 0 1
12468: PPUSH
12469: LD_VAR 0 2
12473: PPUSH
12474: LD_VAR 0 3
12478: PPUSH
12479: LD_VAR 0 4
12483: PPUSH
12484: LD_VAR 0 5
12488: PPUSH
12489: CALL_OW 448
12493: IFFALSE 12528
// begin result := [ chassis , engine , control , weapon ] ;
12495: LD_ADDR_VAR 0 6
12499: PUSH
12500: LD_VAR 0 2
12504: PUSH
12505: LD_VAR 0 3
12509: PUSH
12510: LD_VAR 0 4
12514: PUSH
12515: LD_VAR 0 5
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: ST_TO_ADDR
// exit ;
12526: GO 12940
// end ; _chassis := AvailableChassisList ( factory ) ;
12528: LD_ADDR_VAR 0 9
12532: PUSH
12533: LD_VAR 0 1
12537: PPUSH
12538: CALL_OW 475
12542: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12543: LD_ADDR_VAR 0 11
12547: PUSH
12548: LD_VAR 0 1
12552: PPUSH
12553: CALL_OW 476
12557: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12558: LD_ADDR_VAR 0 12
12562: PUSH
12563: LD_VAR 0 1
12567: PPUSH
12568: CALL_OW 477
12572: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12573: LD_ADDR_VAR 0 10
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 478
12587: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12588: LD_VAR 0 9
12592: NOT
12593: PUSH
12594: LD_VAR 0 11
12598: NOT
12599: OR
12600: PUSH
12601: LD_VAR 0 12
12605: NOT
12606: OR
12607: PUSH
12608: LD_VAR 0 10
12612: NOT
12613: OR
12614: IFFALSE 12649
// begin result := [ chassis , engine , control , weapon ] ;
12616: LD_ADDR_VAR 0 6
12620: PUSH
12621: LD_VAR 0 2
12625: PUSH
12626: LD_VAR 0 3
12630: PUSH
12631: LD_VAR 0 4
12635: PUSH
12636: LD_VAR 0 5
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: ST_TO_ADDR
// exit ;
12647: GO 12940
// end ; if not chassis in _chassis then
12649: LD_VAR 0 2
12653: PUSH
12654: LD_VAR 0 9
12658: IN
12659: NOT
12660: IFFALSE 12686
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 9
12671: PUSH
12672: LD_INT 1
12674: PPUSH
12675: LD_VAR 0 9
12679: PPUSH
12680: CALL_OW 12
12684: ARRAY
12685: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12686: LD_VAR 0 2
12690: PPUSH
12691: LD_VAR 0 3
12695: PPUSH
12696: CALL 12945 0 2
12700: NOT
12701: IFFALSE 12760
// repeat engine := _engine [ 1 ] ;
12703: LD_ADDR_VAR 0 3
12707: PUSH
12708: LD_VAR 0 11
12712: PUSH
12713: LD_INT 1
12715: ARRAY
12716: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12717: LD_ADDR_VAR 0 11
12721: PUSH
12722: LD_VAR 0 11
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 3
12734: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_VAR 0 3
12744: PPUSH
12745: CALL 12945 0 2
12749: PUSH
12750: LD_VAR 0 11
12754: PUSH
12755: EMPTY
12756: EQUAL
12757: OR
12758: IFFALSE 12703
// if not control in _control then
12760: LD_VAR 0 4
12764: PUSH
12765: LD_VAR 0 12
12769: IN
12770: NOT
12771: IFFALSE 12797
// control := _control [ rand ( 1 , _control ) ] ;
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: LD_VAR 0 12
12782: PUSH
12783: LD_INT 1
12785: PPUSH
12786: LD_VAR 0 12
12790: PPUSH
12791: CALL_OW 12
12795: ARRAY
12796: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12797: LD_VAR 0 2
12801: PPUSH
12802: LD_VAR 0 5
12806: PPUSH
12807: CALL 13165 0 2
12811: NOT
12812: IFFALSE 12871
// repeat weapon := _weapon [ 1 ] ;
12814: LD_ADDR_VAR 0 5
12818: PUSH
12819: LD_VAR 0 10
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12828: LD_ADDR_VAR 0 10
12832: PUSH
12833: LD_VAR 0 10
12837: PPUSH
12838: LD_INT 1
12840: PPUSH
12841: CALL_OW 3
12845: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12846: LD_VAR 0 2
12850: PPUSH
12851: LD_VAR 0 5
12855: PPUSH
12856: CALL 13165 0 2
12860: PUSH
12861: LD_VAR 0 10
12865: PUSH
12866: EMPTY
12867: EQUAL
12868: OR
12869: IFFALSE 12814
// result := [ ] ;
12871: LD_ADDR_VAR 0 6
12875: PUSH
12876: EMPTY
12877: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12878: LD_VAR 0 1
12882: PPUSH
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_VAR 0 3
12892: PPUSH
12893: LD_VAR 0 4
12897: PPUSH
12898: LD_VAR 0 5
12902: PPUSH
12903: CALL_OW 448
12907: IFFALSE 12940
// result := [ chassis , engine , control , weapon ] ;
12909: LD_ADDR_VAR 0 6
12913: PUSH
12914: LD_VAR 0 2
12918: PUSH
12919: LD_VAR 0 3
12923: PUSH
12924: LD_VAR 0 4
12928: PUSH
12929: LD_VAR 0 5
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: ST_TO_ADDR
// end ;
12940: LD_VAR 0 6
12944: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12945: LD_INT 0
12947: PPUSH
// if not chassis or not engine then
12948: LD_VAR 0 1
12952: NOT
12953: PUSH
12954: LD_VAR 0 2
12958: NOT
12959: OR
12960: IFFALSE 12964
// exit ;
12962: GO 13160
// case engine of engine_solar :
12964: LD_VAR 0 2
12968: PUSH
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 13015
12977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12978: LD_ADDR_VAR 0 3
12982: PUSH
12983: LD_INT 11
12985: PUSH
12986: LD_INT 12
12988: PUSH
12989: LD_INT 13
12991: PUSH
12992: LD_INT 14
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: ST_TO_ADDR
13013: GO 13144
13015: LD_INT 1
13017: DOUBLE
13018: EQUAL
13019: IFTRUE 13023
13021: GO 13085
13023: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13024: LD_ADDR_VAR 0 3
13028: PUSH
13029: LD_INT 11
13031: PUSH
13032: LD_INT 12
13034: PUSH
13035: LD_INT 13
13037: PUSH
13038: LD_INT 14
13040: PUSH
13041: LD_INT 1
13043: PUSH
13044: LD_INT 2
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 4
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 21
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 22
13064: PUSH
13065: LD_INT 24
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 13144
13085: LD_INT 3
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13143
13093: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 13
13101: PUSH
13102: LD_INT 14
13104: PUSH
13105: LD_INT 2
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: LD_INT 4
13113: PUSH
13114: LD_INT 5
13116: PUSH
13117: LD_INT 21
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 23
13125: PUSH
13126: LD_INT 24
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: ST_TO_ADDR
13141: GO 13144
13143: POP
// result := ( chassis in result ) ;
13144: LD_ADDR_VAR 0 3
13148: PUSH
13149: LD_VAR 0 1
13153: PUSH
13154: LD_VAR 0 3
13158: IN
13159: ST_TO_ADDR
// end ;
13160: LD_VAR 0 3
13164: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13165: LD_INT 0
13167: PPUSH
// if not chassis or not weapon then
13168: LD_VAR 0 1
13172: NOT
13173: PUSH
13174: LD_VAR 0 2
13178: NOT
13179: OR
13180: IFFALSE 13184
// exit ;
13182: GO 14210
// case weapon of us_machine_gun :
13184: LD_VAR 0 2
13188: PUSH
13189: LD_INT 2
13191: DOUBLE
13192: EQUAL
13193: IFTRUE 13197
13195: GO 13227
13197: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13198: LD_ADDR_VAR 0 3
13202: PUSH
13203: LD_INT 1
13205: PUSH
13206: LD_INT 2
13208: PUSH
13209: LD_INT 3
13211: PUSH
13212: LD_INT 4
13214: PUSH
13215: LD_INT 5
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: ST_TO_ADDR
13225: GO 14194
13227: LD_INT 3
13229: DOUBLE
13230: EQUAL
13231: IFTRUE 13235
13233: GO 13265
13235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13236: LD_ADDR_VAR 0 3
13240: PUSH
13241: LD_INT 1
13243: PUSH
13244: LD_INT 2
13246: PUSH
13247: LD_INT 3
13249: PUSH
13250: LD_INT 4
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: ST_TO_ADDR
13263: GO 14194
13265: LD_INT 11
13267: DOUBLE
13268: EQUAL
13269: IFTRUE 13273
13271: GO 13303
13273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13274: LD_ADDR_VAR 0 3
13278: PUSH
13279: LD_INT 1
13281: PUSH
13282: LD_INT 2
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 4
13290: PUSH
13291: LD_INT 5
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: ST_TO_ADDR
13301: GO 14194
13303: LD_INT 4
13305: DOUBLE
13306: EQUAL
13307: IFTRUE 13311
13309: GO 13337
13311: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13312: LD_ADDR_VAR 0 3
13316: PUSH
13317: LD_INT 2
13319: PUSH
13320: LD_INT 3
13322: PUSH
13323: LD_INT 4
13325: PUSH
13326: LD_INT 5
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: ST_TO_ADDR
13335: GO 14194
13337: LD_INT 5
13339: DOUBLE
13340: EQUAL
13341: IFTRUE 13345
13343: GO 13371
13345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13346: LD_ADDR_VAR 0 3
13350: PUSH
13351: LD_INT 2
13353: PUSH
13354: LD_INT 3
13356: PUSH
13357: LD_INT 4
13359: PUSH
13360: LD_INT 5
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: ST_TO_ADDR
13369: GO 14194
13371: LD_INT 9
13373: DOUBLE
13374: EQUAL
13375: IFTRUE 13379
13377: GO 13405
13379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13380: LD_ADDR_VAR 0 3
13384: PUSH
13385: LD_INT 2
13387: PUSH
13388: LD_INT 3
13390: PUSH
13391: LD_INT 4
13393: PUSH
13394: LD_INT 5
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: ST_TO_ADDR
13403: GO 14194
13405: LD_INT 7
13407: DOUBLE
13408: EQUAL
13409: IFTRUE 13413
13411: GO 13439
13413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13414: LD_ADDR_VAR 0 3
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: LD_INT 3
13424: PUSH
13425: LD_INT 4
13427: PUSH
13428: LD_INT 5
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: ST_TO_ADDR
13437: GO 14194
13439: LD_INT 12
13441: DOUBLE
13442: EQUAL
13443: IFTRUE 13447
13445: GO 13473
13447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_INT 2
13455: PUSH
13456: LD_INT 3
13458: PUSH
13459: LD_INT 4
13461: PUSH
13462: LD_INT 5
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: ST_TO_ADDR
13471: GO 14194
13473: LD_INT 13
13475: DOUBLE
13476: EQUAL
13477: IFTRUE 13481
13479: GO 13507
13481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: LD_INT 3
13492: PUSH
13493: LD_INT 4
13495: PUSH
13496: LD_INT 5
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: LIST
13504: ST_TO_ADDR
13505: GO 14194
13507: LD_INT 14
13509: DOUBLE
13510: EQUAL
13511: IFTRUE 13515
13513: GO 13533
13515: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13516: LD_ADDR_VAR 0 3
13520: PUSH
13521: LD_INT 4
13523: PUSH
13524: LD_INT 5
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: ST_TO_ADDR
13531: GO 14194
13533: LD_INT 6
13535: DOUBLE
13536: EQUAL
13537: IFTRUE 13541
13539: GO 13559
13541: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13542: LD_ADDR_VAR 0 3
13546: PUSH
13547: LD_INT 4
13549: PUSH
13550: LD_INT 5
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: ST_TO_ADDR
13557: GO 14194
13559: LD_INT 10
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13585
13567: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13568: LD_ADDR_VAR 0 3
13572: PUSH
13573: LD_INT 4
13575: PUSH
13576: LD_INT 5
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: ST_TO_ADDR
13583: GO 14194
13585: LD_INT 22
13587: DOUBLE
13588: EQUAL
13589: IFTRUE 13593
13591: GO 13619
13593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13594: LD_ADDR_VAR 0 3
13598: PUSH
13599: LD_INT 11
13601: PUSH
13602: LD_INT 12
13604: PUSH
13605: LD_INT 13
13607: PUSH
13608: LD_INT 14
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: ST_TO_ADDR
13617: GO 14194
13619: LD_INT 23
13621: DOUBLE
13622: EQUAL
13623: IFTRUE 13627
13625: GO 13653
13627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13628: LD_ADDR_VAR 0 3
13632: PUSH
13633: LD_INT 11
13635: PUSH
13636: LD_INT 12
13638: PUSH
13639: LD_INT 13
13641: PUSH
13642: LD_INT 14
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: ST_TO_ADDR
13651: GO 14194
13653: LD_INT 24
13655: DOUBLE
13656: EQUAL
13657: IFTRUE 13661
13659: GO 13687
13661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13662: LD_ADDR_VAR 0 3
13666: PUSH
13667: LD_INT 11
13669: PUSH
13670: LD_INT 12
13672: PUSH
13673: LD_INT 13
13675: PUSH
13676: LD_INT 14
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: ST_TO_ADDR
13685: GO 14194
13687: LD_INT 30
13689: DOUBLE
13690: EQUAL
13691: IFTRUE 13695
13693: GO 13721
13695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13696: LD_ADDR_VAR 0 3
13700: PUSH
13701: LD_INT 11
13703: PUSH
13704: LD_INT 12
13706: PUSH
13707: LD_INT 13
13709: PUSH
13710: LD_INT 14
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: ST_TO_ADDR
13719: GO 14194
13721: LD_INT 25
13723: DOUBLE
13724: EQUAL
13725: IFTRUE 13729
13727: GO 13747
13729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13730: LD_ADDR_VAR 0 3
13734: PUSH
13735: LD_INT 13
13737: PUSH
13738: LD_INT 14
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: ST_TO_ADDR
13745: GO 14194
13747: LD_INT 27
13749: DOUBLE
13750: EQUAL
13751: IFTRUE 13755
13753: GO 13773
13755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13756: LD_ADDR_VAR 0 3
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 14
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14194
13773: LD_INT 28
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13799
13781: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13782: LD_ADDR_VAR 0 3
13786: PUSH
13787: LD_INT 13
13789: PUSH
13790: LD_INT 14
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: ST_TO_ADDR
13797: GO 14194
13799: LD_INT 29
13801: DOUBLE
13802: EQUAL
13803: IFTRUE 13807
13805: GO 13825
13807: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_INT 13
13815: PUSH
13816: LD_INT 14
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: ST_TO_ADDR
13823: GO 14194
13825: LD_INT 31
13827: DOUBLE
13828: EQUAL
13829: IFTRUE 13833
13831: GO 13851
13833: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: ST_TO_ADDR
13849: GO 14194
13851: LD_INT 26
13853: DOUBLE
13854: EQUAL
13855: IFTRUE 13859
13857: GO 13877
13859: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_INT 13
13867: PUSH
13868: LD_INT 14
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: ST_TO_ADDR
13875: GO 14194
13877: LD_INT 42
13879: DOUBLE
13880: EQUAL
13881: IFTRUE 13885
13883: GO 13911
13885: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13886: LD_ADDR_VAR 0 3
13890: PUSH
13891: LD_INT 21
13893: PUSH
13894: LD_INT 22
13896: PUSH
13897: LD_INT 23
13899: PUSH
13900: LD_INT 24
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: ST_TO_ADDR
13909: GO 14194
13911: LD_INT 43
13913: DOUBLE
13914: EQUAL
13915: IFTRUE 13919
13917: GO 13945
13919: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: LD_INT 21
13927: PUSH
13928: LD_INT 22
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 24
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14194
13945: LD_INT 44
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 13979
13953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13954: LD_ADDR_VAR 0 3
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 22
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: ST_TO_ADDR
13977: GO 14194
13979: LD_INT 45
13981: DOUBLE
13982: EQUAL
13983: IFTRUE 13987
13985: GO 14013
13987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13988: LD_ADDR_VAR 0 3
13992: PUSH
13993: LD_INT 21
13995: PUSH
13996: LD_INT 22
13998: PUSH
13999: LD_INT 23
14001: PUSH
14002: LD_INT 24
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: ST_TO_ADDR
14011: GO 14194
14013: LD_INT 49
14015: DOUBLE
14016: EQUAL
14017: IFTRUE 14021
14019: GO 14047
14021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14022: LD_ADDR_VAR 0 3
14026: PUSH
14027: LD_INT 21
14029: PUSH
14030: LD_INT 22
14032: PUSH
14033: LD_INT 23
14035: PUSH
14036: LD_INT 24
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: ST_TO_ADDR
14045: GO 14194
14047: LD_INT 51
14049: DOUBLE
14050: EQUAL
14051: IFTRUE 14055
14053: GO 14081
14055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14056: LD_ADDR_VAR 0 3
14060: PUSH
14061: LD_INT 21
14063: PUSH
14064: LD_INT 22
14066: PUSH
14067: LD_INT 23
14069: PUSH
14070: LD_INT 24
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: ST_TO_ADDR
14079: GO 14194
14081: LD_INT 52
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14115
14089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14090: LD_ADDR_VAR 0 3
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_INT 23
14103: PUSH
14104: LD_INT 24
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: ST_TO_ADDR
14113: GO 14194
14115: LD_INT 53
14117: DOUBLE
14118: EQUAL
14119: IFTRUE 14123
14121: GO 14141
14123: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14124: LD_ADDR_VAR 0 3
14128: PUSH
14129: LD_INT 23
14131: PUSH
14132: LD_INT 24
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: ST_TO_ADDR
14139: GO 14194
14141: LD_INT 46
14143: DOUBLE
14144: EQUAL
14145: IFTRUE 14149
14147: GO 14167
14149: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_INT 23
14157: PUSH
14158: LD_INT 24
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
14165: GO 14194
14167: LD_INT 47
14169: DOUBLE
14170: EQUAL
14171: IFTRUE 14175
14173: GO 14193
14175: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14176: LD_ADDR_VAR 0 3
14180: PUSH
14181: LD_INT 23
14183: PUSH
14184: LD_INT 24
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: ST_TO_ADDR
14191: GO 14194
14193: POP
// result := ( chassis in result ) ;
14194: LD_ADDR_VAR 0 3
14198: PUSH
14199: LD_VAR 0 1
14203: PUSH
14204: LD_VAR 0 3
14208: IN
14209: ST_TO_ADDR
// end ;
14210: LD_VAR 0 3
14214: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14215: LD_INT 0
14217: PPUSH
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
14223: PPUSH
// result := array ;
14224: LD_ADDR_VAR 0 5
14228: PUSH
14229: LD_VAR 0 1
14233: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14234: LD_VAR 0 1
14238: NOT
14239: PUSH
14240: LD_VAR 0 2
14244: NOT
14245: OR
14246: PUSH
14247: LD_VAR 0 3
14251: NOT
14252: OR
14253: PUSH
14254: LD_VAR 0 2
14258: PUSH
14259: LD_VAR 0 1
14263: GREATER
14264: OR
14265: PUSH
14266: LD_VAR 0 3
14270: PUSH
14271: LD_VAR 0 1
14275: GREATER
14276: OR
14277: IFFALSE 14281
// exit ;
14279: GO 14577
// if direction then
14281: LD_VAR 0 4
14285: IFFALSE 14349
// begin d := 1 ;
14287: LD_ADDR_VAR 0 9
14291: PUSH
14292: LD_INT 1
14294: ST_TO_ADDR
// if i_from > i_to then
14295: LD_VAR 0 2
14299: PUSH
14300: LD_VAR 0 3
14304: GREATER
14305: IFFALSE 14331
// length := ( array - i_from ) + i_to else
14307: LD_ADDR_VAR 0 11
14311: PUSH
14312: LD_VAR 0 1
14316: PUSH
14317: LD_VAR 0 2
14321: MINUS
14322: PUSH
14323: LD_VAR 0 3
14327: PLUS
14328: ST_TO_ADDR
14329: GO 14347
// length := i_to - i_from ;
14331: LD_ADDR_VAR 0 11
14335: PUSH
14336: LD_VAR 0 3
14340: PUSH
14341: LD_VAR 0 2
14345: MINUS
14346: ST_TO_ADDR
// end else
14347: GO 14410
// begin d := - 1 ;
14349: LD_ADDR_VAR 0 9
14353: PUSH
14354: LD_INT 1
14356: NEG
14357: ST_TO_ADDR
// if i_from > i_to then
14358: LD_VAR 0 2
14362: PUSH
14363: LD_VAR 0 3
14367: GREATER
14368: IFFALSE 14388
// length := i_from - i_to else
14370: LD_ADDR_VAR 0 11
14374: PUSH
14375: LD_VAR 0 2
14379: PUSH
14380: LD_VAR 0 3
14384: MINUS
14385: ST_TO_ADDR
14386: GO 14410
// length := ( array - i_to ) + i_from ;
14388: LD_ADDR_VAR 0 11
14392: PUSH
14393: LD_VAR 0 1
14397: PUSH
14398: LD_VAR 0 3
14402: MINUS
14403: PUSH
14404: LD_VAR 0 2
14408: PLUS
14409: ST_TO_ADDR
// end ; if not length then
14410: LD_VAR 0 11
14414: NOT
14415: IFFALSE 14419
// exit ;
14417: GO 14577
// tmp := array ;
14419: LD_ADDR_VAR 0 10
14423: PUSH
14424: LD_VAR 0 1
14428: ST_TO_ADDR
// for i = 1 to length do
14429: LD_ADDR_VAR 0 6
14433: PUSH
14434: DOUBLE
14435: LD_INT 1
14437: DEC
14438: ST_TO_ADDR
14439: LD_VAR 0 11
14443: PUSH
14444: FOR_TO
14445: IFFALSE 14565
// begin for j = 1 to array do
14447: LD_ADDR_VAR 0 7
14451: PUSH
14452: DOUBLE
14453: LD_INT 1
14455: DEC
14456: ST_TO_ADDR
14457: LD_VAR 0 1
14461: PUSH
14462: FOR_TO
14463: IFFALSE 14551
// begin k := j + d ;
14465: LD_ADDR_VAR 0 8
14469: PUSH
14470: LD_VAR 0 7
14474: PUSH
14475: LD_VAR 0 9
14479: PLUS
14480: ST_TO_ADDR
// if k > array then
14481: LD_VAR 0 8
14485: PUSH
14486: LD_VAR 0 1
14490: GREATER
14491: IFFALSE 14501
// k := 1 ;
14493: LD_ADDR_VAR 0 8
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// if not k then
14501: LD_VAR 0 8
14505: NOT
14506: IFFALSE 14518
// k := array ;
14508: LD_ADDR_VAR 0 8
14512: PUSH
14513: LD_VAR 0 1
14517: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14518: LD_ADDR_VAR 0 10
14522: PUSH
14523: LD_VAR 0 10
14527: PPUSH
14528: LD_VAR 0 8
14532: PPUSH
14533: LD_VAR 0 1
14537: PUSH
14538: LD_VAR 0 7
14542: ARRAY
14543: PPUSH
14544: CALL_OW 1
14548: ST_TO_ADDR
// end ;
14549: GO 14462
14551: POP
14552: POP
// array := tmp ;
14553: LD_ADDR_VAR 0 1
14557: PUSH
14558: LD_VAR 0 10
14562: ST_TO_ADDR
// end ;
14563: GO 14444
14565: POP
14566: POP
// result := array ;
14567: LD_ADDR_VAR 0 5
14571: PUSH
14572: LD_VAR 0 1
14576: ST_TO_ADDR
// end ;
14577: LD_VAR 0 5
14581: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14582: LD_INT 0
14584: PPUSH
14585: PPUSH
// result := 0 ;
14586: LD_ADDR_VAR 0 3
14590: PUSH
14591: LD_INT 0
14593: ST_TO_ADDR
// if not array or not value in array then
14594: LD_VAR 0 1
14598: NOT
14599: PUSH
14600: LD_VAR 0 2
14604: PUSH
14605: LD_VAR 0 1
14609: IN
14610: NOT
14611: OR
14612: IFFALSE 14616
// exit ;
14614: GO 14670
// for i = 1 to array do
14616: LD_ADDR_VAR 0 4
14620: PUSH
14621: DOUBLE
14622: LD_INT 1
14624: DEC
14625: ST_TO_ADDR
14626: LD_VAR 0 1
14630: PUSH
14631: FOR_TO
14632: IFFALSE 14668
// if value = array [ i ] then
14634: LD_VAR 0 2
14638: PUSH
14639: LD_VAR 0 1
14643: PUSH
14644: LD_VAR 0 4
14648: ARRAY
14649: EQUAL
14650: IFFALSE 14666
// begin result := i ;
14652: LD_ADDR_VAR 0 3
14656: PUSH
14657: LD_VAR 0 4
14661: ST_TO_ADDR
// exit ;
14662: POP
14663: POP
14664: GO 14670
// end ;
14666: GO 14631
14668: POP
14669: POP
// end ;
14670: LD_VAR 0 3
14674: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14675: LD_INT 0
14677: PPUSH
// vc_chassis := chassis ;
14678: LD_ADDR_OWVAR 37
14682: PUSH
14683: LD_VAR 0 1
14687: ST_TO_ADDR
// vc_engine := engine ;
14688: LD_ADDR_OWVAR 39
14692: PUSH
14693: LD_VAR 0 2
14697: ST_TO_ADDR
// vc_control := control ;
14698: LD_ADDR_OWVAR 38
14702: PUSH
14703: LD_VAR 0 3
14707: ST_TO_ADDR
// vc_weapon := weapon ;
14708: LD_ADDR_OWVAR 40
14712: PUSH
14713: LD_VAR 0 4
14717: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14718: LD_ADDR_OWVAR 41
14722: PUSH
14723: LD_VAR 0 5
14727: ST_TO_ADDR
// end ;
14728: LD_VAR 0 6
14732: RET
// export function WantPlant ( unit ) ; var task ; begin
14733: LD_INT 0
14735: PPUSH
14736: PPUSH
// result := false ;
14737: LD_ADDR_VAR 0 2
14741: PUSH
14742: LD_INT 0
14744: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14745: LD_ADDR_VAR 0 3
14749: PUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 437
14759: ST_TO_ADDR
// if task then
14760: LD_VAR 0 3
14764: IFFALSE 14792
// if task [ 1 ] [ 1 ] = p then
14766: LD_VAR 0 3
14770: PUSH
14771: LD_INT 1
14773: ARRAY
14774: PUSH
14775: LD_INT 1
14777: ARRAY
14778: PUSH
14779: LD_STRING p
14781: EQUAL
14782: IFFALSE 14792
// result := true ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
// end ;
14792: LD_VAR 0 2
14796: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
// if pos < 1 then
14803: LD_VAR 0 2
14807: PUSH
14808: LD_INT 1
14810: LESS
14811: IFFALSE 14815
// exit ;
14813: GO 15118
// if pos = 1 then
14815: LD_VAR 0 2
14819: PUSH
14820: LD_INT 1
14822: EQUAL
14823: IFFALSE 14856
// result := Replace ( arr , pos [ 1 ] , value ) else
14825: LD_ADDR_VAR 0 4
14829: PUSH
14830: LD_VAR 0 1
14834: PPUSH
14835: LD_VAR 0 2
14839: PUSH
14840: LD_INT 1
14842: ARRAY
14843: PPUSH
14844: LD_VAR 0 3
14848: PPUSH
14849: CALL_OW 1
14853: ST_TO_ADDR
14854: GO 15118
// begin tmp := arr ;
14856: LD_ADDR_VAR 0 6
14860: PUSH
14861: LD_VAR 0 1
14865: ST_TO_ADDR
// s_arr := [ tmp ] ;
14866: LD_ADDR_VAR 0 7
14870: PUSH
14871: LD_VAR 0 6
14875: PUSH
14876: EMPTY
14877: LIST
14878: ST_TO_ADDR
// for i = 1 to pos - 1 do
14879: LD_ADDR_VAR 0 5
14883: PUSH
14884: DOUBLE
14885: LD_INT 1
14887: DEC
14888: ST_TO_ADDR
14889: LD_VAR 0 2
14893: PUSH
14894: LD_INT 1
14896: MINUS
14897: PUSH
14898: FOR_TO
14899: IFFALSE 14944
// begin tmp := tmp [ pos [ i ] ] ;
14901: LD_ADDR_VAR 0 6
14905: PUSH
14906: LD_VAR 0 6
14910: PUSH
14911: LD_VAR 0 2
14915: PUSH
14916: LD_VAR 0 5
14920: ARRAY
14921: ARRAY
14922: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14923: LD_ADDR_VAR 0 7
14927: PUSH
14928: LD_VAR 0 7
14932: PUSH
14933: LD_VAR 0 6
14937: PUSH
14938: EMPTY
14939: LIST
14940: ADD
14941: ST_TO_ADDR
// end ;
14942: GO 14898
14944: POP
14945: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14946: LD_ADDR_VAR 0 6
14950: PUSH
14951: LD_VAR 0 6
14955: PPUSH
14956: LD_VAR 0 2
14960: PUSH
14961: LD_VAR 0 2
14965: ARRAY
14966: PPUSH
14967: LD_VAR 0 3
14971: PPUSH
14972: CALL_OW 1
14976: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14977: LD_ADDR_VAR 0 7
14981: PUSH
14982: LD_VAR 0 7
14986: PPUSH
14987: LD_VAR 0 7
14991: PPUSH
14992: LD_VAR 0 6
14996: PPUSH
14997: CALL_OW 1
15001: ST_TO_ADDR
// for i = s_arr downto 2 do
15002: LD_ADDR_VAR 0 5
15006: PUSH
15007: DOUBLE
15008: LD_VAR 0 7
15012: INC
15013: ST_TO_ADDR
15014: LD_INT 2
15016: PUSH
15017: FOR_DOWNTO
15018: IFFALSE 15102
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15020: LD_ADDR_VAR 0 6
15024: PUSH
15025: LD_VAR 0 7
15029: PUSH
15030: LD_VAR 0 5
15034: PUSH
15035: LD_INT 1
15037: MINUS
15038: ARRAY
15039: PPUSH
15040: LD_VAR 0 2
15044: PUSH
15045: LD_VAR 0 5
15049: PUSH
15050: LD_INT 1
15052: MINUS
15053: ARRAY
15054: PPUSH
15055: LD_VAR 0 7
15059: PUSH
15060: LD_VAR 0 5
15064: ARRAY
15065: PPUSH
15066: CALL_OW 1
15070: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15071: LD_ADDR_VAR 0 7
15075: PUSH
15076: LD_VAR 0 7
15080: PPUSH
15081: LD_VAR 0 5
15085: PUSH
15086: LD_INT 1
15088: MINUS
15089: PPUSH
15090: LD_VAR 0 6
15094: PPUSH
15095: CALL_OW 1
15099: ST_TO_ADDR
// end ;
15100: GO 15017
15102: POP
15103: POP
// result := s_arr [ 1 ] ;
15104: LD_ADDR_VAR 0 4
15108: PUSH
15109: LD_VAR 0 7
15113: PUSH
15114: LD_INT 1
15116: ARRAY
15117: ST_TO_ADDR
// end ; end ;
15118: LD_VAR 0 4
15122: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15123: LD_INT 0
15125: PPUSH
15126: PPUSH
// if not list then
15127: LD_VAR 0 1
15131: NOT
15132: IFFALSE 15136
// exit ;
15134: GO 15227
// i := list [ pos1 ] ;
15136: LD_ADDR_VAR 0 5
15140: PUSH
15141: LD_VAR 0 1
15145: PUSH
15146: LD_VAR 0 2
15150: ARRAY
15151: ST_TO_ADDR
// if not i then
15152: LD_VAR 0 5
15156: NOT
15157: IFFALSE 15161
// exit ;
15159: GO 15227
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15161: LD_ADDR_VAR 0 1
15165: PUSH
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 2
15175: PPUSH
15176: LD_VAR 0 1
15180: PUSH
15181: LD_VAR 0 3
15185: ARRAY
15186: PPUSH
15187: CALL_OW 1
15191: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15192: LD_ADDR_VAR 0 1
15196: PUSH
15197: LD_VAR 0 1
15201: PPUSH
15202: LD_VAR 0 3
15206: PPUSH
15207: LD_VAR 0 5
15211: PPUSH
15212: CALL_OW 1
15216: ST_TO_ADDR
// result := list ;
15217: LD_ADDR_VAR 0 4
15221: PUSH
15222: LD_VAR 0 1
15226: ST_TO_ADDR
// end ;
15227: LD_VAR 0 4
15231: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15232: LD_INT 0
15234: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15235: LD_ADDR_VAR 0 5
15239: PUSH
15240: LD_VAR 0 1
15244: PPUSH
15245: CALL_OW 250
15249: PPUSH
15250: LD_VAR 0 1
15254: PPUSH
15255: CALL_OW 251
15259: PPUSH
15260: LD_VAR 0 2
15264: PPUSH
15265: LD_VAR 0 3
15269: PPUSH
15270: LD_VAR 0 4
15274: PPUSH
15275: CALL 15285 0 5
15279: ST_TO_ADDR
// end ;
15280: LD_VAR 0 5
15284: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15285: LD_INT 0
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
// if not list then
15291: LD_VAR 0 3
15295: NOT
15296: IFFALSE 15300
// exit ;
15298: GO 15688
// result := [ ] ;
15300: LD_ADDR_VAR 0 6
15304: PUSH
15305: EMPTY
15306: ST_TO_ADDR
// for i in list do
15307: LD_ADDR_VAR 0 7
15311: PUSH
15312: LD_VAR 0 3
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15520
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15320: LD_ADDR_VAR 0 9
15324: PUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 2
15339: PPUSH
15340: CALL_OW 297
15344: ST_TO_ADDR
// if not result then
15345: LD_VAR 0 6
15349: NOT
15350: IFFALSE 15376
// result := [ [ i , tmp ] ] else
15352: LD_ADDR_VAR 0 6
15356: PUSH
15357: LD_VAR 0 7
15361: PUSH
15362: LD_VAR 0 9
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: ST_TO_ADDR
15374: GO 15518
// begin if result [ result ] [ 2 ] < tmp then
15376: LD_VAR 0 6
15380: PUSH
15381: LD_VAR 0 6
15385: ARRAY
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PUSH
15391: LD_VAR 0 9
15395: LESS
15396: IFFALSE 15438
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15398: LD_ADDR_VAR 0 6
15402: PUSH
15403: LD_VAR 0 6
15407: PPUSH
15408: LD_VAR 0 6
15412: PUSH
15413: LD_INT 1
15415: PLUS
15416: PPUSH
15417: LD_VAR 0 7
15421: PUSH
15422: LD_VAR 0 9
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PPUSH
15431: CALL_OW 2
15435: ST_TO_ADDR
15436: GO 15518
// for j = 1 to result do
15438: LD_ADDR_VAR 0 8
15442: PUSH
15443: DOUBLE
15444: LD_INT 1
15446: DEC
15447: ST_TO_ADDR
15448: LD_VAR 0 6
15452: PUSH
15453: FOR_TO
15454: IFFALSE 15516
// begin if tmp < result [ j ] [ 2 ] then
15456: LD_VAR 0 9
15460: PUSH
15461: LD_VAR 0 6
15465: PUSH
15466: LD_VAR 0 8
15470: ARRAY
15471: PUSH
15472: LD_INT 2
15474: ARRAY
15475: LESS
15476: IFFALSE 15514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15478: LD_ADDR_VAR 0 6
15482: PUSH
15483: LD_VAR 0 6
15487: PPUSH
15488: LD_VAR 0 8
15492: PPUSH
15493: LD_VAR 0 7
15497: PUSH
15498: LD_VAR 0 9
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: PPUSH
15507: CALL_OW 2
15511: ST_TO_ADDR
// break ;
15512: GO 15516
// end ; end ;
15514: GO 15453
15516: POP
15517: POP
// end ; end ;
15518: GO 15317
15520: POP
15521: POP
// if result and not asc then
15522: LD_VAR 0 6
15526: PUSH
15527: LD_VAR 0 4
15531: NOT
15532: AND
15533: IFFALSE 15608
// begin tmp := result ;
15535: LD_ADDR_VAR 0 9
15539: PUSH
15540: LD_VAR 0 6
15544: ST_TO_ADDR
// for i = tmp downto 1 do
15545: LD_ADDR_VAR 0 7
15549: PUSH
15550: DOUBLE
15551: LD_VAR 0 9
15555: INC
15556: ST_TO_ADDR
15557: LD_INT 1
15559: PUSH
15560: FOR_DOWNTO
15561: IFFALSE 15606
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15563: LD_ADDR_VAR 0 6
15567: PUSH
15568: LD_VAR 0 6
15572: PPUSH
15573: LD_VAR 0 9
15577: PUSH
15578: LD_VAR 0 7
15582: MINUS
15583: PUSH
15584: LD_INT 1
15586: PLUS
15587: PPUSH
15588: LD_VAR 0 9
15592: PUSH
15593: LD_VAR 0 7
15597: ARRAY
15598: PPUSH
15599: CALL_OW 1
15603: ST_TO_ADDR
15604: GO 15560
15606: POP
15607: POP
// end ; tmp := [ ] ;
15608: LD_ADDR_VAR 0 9
15612: PUSH
15613: EMPTY
15614: ST_TO_ADDR
// if mode then
15615: LD_VAR 0 5
15619: IFFALSE 15688
// begin for i = 1 to result do
15621: LD_ADDR_VAR 0 7
15625: PUSH
15626: DOUBLE
15627: LD_INT 1
15629: DEC
15630: ST_TO_ADDR
15631: LD_VAR 0 6
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15676
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15639: LD_ADDR_VAR 0 9
15643: PUSH
15644: LD_VAR 0 9
15648: PPUSH
15649: LD_VAR 0 7
15653: PPUSH
15654: LD_VAR 0 6
15658: PUSH
15659: LD_VAR 0 7
15663: ARRAY
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: PPUSH
15669: CALL_OW 1
15673: ST_TO_ADDR
15674: GO 15636
15676: POP
15677: POP
// result := tmp ;
15678: LD_ADDR_VAR 0 6
15682: PUSH
15683: LD_VAR 0 9
15687: ST_TO_ADDR
// end ; end ;
15688: LD_VAR 0 6
15692: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15693: LD_INT 0
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15701: LD_ADDR_VAR 0 5
15705: PUSH
15706: LD_INT 0
15708: PUSH
15709: LD_INT 0
15711: PUSH
15712: LD_INT 0
15714: PUSH
15715: EMPTY
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: LIST
15722: ST_TO_ADDR
// if not x or not y then
15723: LD_VAR 0 2
15727: NOT
15728: PUSH
15729: LD_VAR 0 3
15733: NOT
15734: OR
15735: IFFALSE 15739
// exit ;
15737: GO 17385
// if not range then
15739: LD_VAR 0 4
15743: NOT
15744: IFFALSE 15754
// range := 10 ;
15746: LD_ADDR_VAR 0 4
15750: PUSH
15751: LD_INT 10
15753: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15754: LD_ADDR_VAR 0 8
15758: PUSH
15759: LD_INT 81
15761: PUSH
15762: LD_VAR 0 1
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: LD_INT 92
15773: PUSH
15774: LD_VAR 0 2
15778: PUSH
15779: LD_VAR 0 3
15783: PUSH
15784: LD_VAR 0 4
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: LD_INT 21
15800: PUSH
15801: LD_INT 3
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PPUSH
15817: CALL_OW 69
15821: ST_TO_ADDR
// if not tmp then
15822: LD_VAR 0 8
15826: NOT
15827: IFFALSE 15831
// exit ;
15829: GO 17385
// for i in tmp do
15831: LD_ADDR_VAR 0 6
15835: PUSH
15836: LD_VAR 0 8
15840: PUSH
15841: FOR_IN
15842: IFFALSE 17360
// begin points := [ 0 , 0 , 0 ] ;
15844: LD_ADDR_VAR 0 9
15848: PUSH
15849: LD_INT 0
15851: PUSH
15852: LD_INT 0
15854: PUSH
15855: LD_INT 0
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: LIST
15862: ST_TO_ADDR
// bpoints := 1 ;
15863: LD_ADDR_VAR 0 10
15867: PUSH
15868: LD_INT 1
15870: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15871: LD_VAR 0 6
15875: PPUSH
15876: CALL_OW 247
15880: PUSH
15881: LD_INT 1
15883: DOUBLE
15884: EQUAL
15885: IFTRUE 15889
15887: GO 16467
15889: POP
// begin if GetClass ( i ) = 1 then
15890: LD_VAR 0 6
15894: PPUSH
15895: CALL_OW 257
15899: PUSH
15900: LD_INT 1
15902: EQUAL
15903: IFFALSE 15924
// points := [ 10 , 5 , 3 ] ;
15905: LD_ADDR_VAR 0 9
15909: PUSH
15910: LD_INT 10
15912: PUSH
15913: LD_INT 5
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15924: LD_VAR 0 6
15928: PPUSH
15929: CALL_OW 257
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 3 , 2 , 1 ] ;
15950: LD_ADDR_VAR 0 9
15954: PUSH
15955: LD_INT 3
15957: PUSH
15958: LD_INT 2
15960: PUSH
15961: LD_INT 1
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15969: LD_VAR 0 6
15973: PPUSH
15974: CALL_OW 257
15978: PUSH
15979: LD_INT 5
15981: EQUAL
15982: IFFALSE 16003
// points := [ 130 , 5 , 2 ] ;
15984: LD_ADDR_VAR 0 9
15988: PUSH
15989: LD_INT 130
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 2
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16003: LD_VAR 0 6
16007: PPUSH
16008: CALL_OW 257
16012: PUSH
16013: LD_INT 8
16015: EQUAL
16016: IFFALSE 16037
// points := [ 35 , 35 , 30 ] ;
16018: LD_ADDR_VAR 0 9
16022: PUSH
16023: LD_INT 35
16025: PUSH
16026: LD_INT 35
16028: PUSH
16029: LD_INT 30
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL_OW 257
16046: PUSH
16047: LD_INT 9
16049: EQUAL
16050: IFFALSE 16071
// points := [ 20 , 55 , 40 ] ;
16052: LD_ADDR_VAR 0 9
16056: PUSH
16057: LD_INT 20
16059: PUSH
16060: LD_INT 55
16062: PUSH
16063: LD_INT 40
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: LIST
16070: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16071: LD_VAR 0 6
16075: PPUSH
16076: CALL_OW 257
16080: PUSH
16081: LD_INT 12
16083: PUSH
16084: LD_INT 16
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: IN
16091: IFFALSE 16112
// points := [ 5 , 3 , 2 ] ;
16093: LD_ADDR_VAR 0 9
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 3
16103: PUSH
16104: LD_INT 2
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL_OW 257
16121: PUSH
16122: LD_INT 17
16124: EQUAL
16125: IFFALSE 16146
// points := [ 100 , 50 , 75 ] ;
16127: LD_ADDR_VAR 0 9
16131: PUSH
16132: LD_INT 100
16134: PUSH
16135: LD_INT 50
16137: PUSH
16138: LD_INT 75
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: LIST
16145: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16146: LD_VAR 0 6
16150: PPUSH
16151: CALL_OW 257
16155: PUSH
16156: LD_INT 15
16158: EQUAL
16159: IFFALSE 16180
// points := [ 10 , 5 , 3 ] ;
16161: LD_ADDR_VAR 0 9
16165: PUSH
16166: LD_INT 10
16168: PUSH
16169: LD_INT 5
16171: PUSH
16172: LD_INT 3
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 257
16189: PUSH
16190: LD_INT 14
16192: EQUAL
16193: IFFALSE 16214
// points := [ 10 , 0 , 0 ] ;
16195: LD_ADDR_VAR 0 9
16199: PUSH
16200: LD_INT 10
16202: PUSH
16203: LD_INT 0
16205: PUSH
16206: LD_INT 0
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16214: LD_VAR 0 6
16218: PPUSH
16219: CALL_OW 257
16223: PUSH
16224: LD_INT 11
16226: EQUAL
16227: IFFALSE 16248
// points := [ 30 , 10 , 5 ] ;
16229: LD_ADDR_VAR 0 9
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 10
16239: PUSH
16240: LD_INT 5
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: LIST
16247: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16248: LD_VAR 0 1
16252: PPUSH
16253: LD_INT 5
16255: PPUSH
16256: CALL_OW 321
16260: PUSH
16261: LD_INT 2
16263: EQUAL
16264: IFFALSE 16281
// bpoints := bpoints * 1.8 ;
16266: LD_ADDR_VAR 0 10
16270: PUSH
16271: LD_VAR 0 10
16275: PUSH
16276: LD_REAL  1.80000000000000E+0000
16279: MUL
16280: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16281: LD_VAR 0 6
16285: PPUSH
16286: CALL_OW 257
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: LD_INT 3
16299: PUSH
16300: LD_INT 4
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: IN
16309: PUSH
16310: LD_VAR 0 1
16314: PPUSH
16315: LD_INT 51
16317: PPUSH
16318: CALL_OW 321
16322: PUSH
16323: LD_INT 2
16325: EQUAL
16326: AND
16327: IFFALSE 16344
// bpoints := bpoints * 1.2 ;
16329: LD_ADDR_VAR 0 10
16333: PUSH
16334: LD_VAR 0 10
16338: PUSH
16339: LD_REAL  1.20000000000000E+0000
16342: MUL
16343: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16344: LD_VAR 0 6
16348: PPUSH
16349: CALL_OW 257
16353: PUSH
16354: LD_INT 5
16356: PUSH
16357: LD_INT 7
16359: PUSH
16360: LD_INT 9
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: IN
16368: PUSH
16369: LD_VAR 0 1
16373: PPUSH
16374: LD_INT 52
16376: PPUSH
16377: CALL_OW 321
16381: PUSH
16382: LD_INT 2
16384: EQUAL
16385: AND
16386: IFFALSE 16403
// bpoints := bpoints * 1.5 ;
16388: LD_ADDR_VAR 0 10
16392: PUSH
16393: LD_VAR 0 10
16397: PUSH
16398: LD_REAL  1.50000000000000E+0000
16401: MUL
16402: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16403: LD_VAR 0 1
16407: PPUSH
16408: LD_INT 66
16410: PPUSH
16411: CALL_OW 321
16415: PUSH
16416: LD_INT 2
16418: EQUAL
16419: IFFALSE 16436
// bpoints := bpoints * 1.1 ;
16421: LD_ADDR_VAR 0 10
16425: PUSH
16426: LD_VAR 0 10
16430: PUSH
16431: LD_REAL  1.10000000000000E+0000
16434: MUL
16435: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16436: LD_ADDR_VAR 0 10
16440: PUSH
16441: LD_VAR 0 10
16445: PUSH
16446: LD_VAR 0 6
16450: PPUSH
16451: LD_INT 1
16453: PPUSH
16454: CALL_OW 259
16458: PUSH
16459: LD_REAL  1.15000000000000E+0000
16462: MUL
16463: MUL
16464: ST_TO_ADDR
// end ; unit_vehicle :
16465: GO 17289
16467: LD_INT 2
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 17277
16475: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16476: LD_VAR 0 6
16480: PPUSH
16481: CALL_OW 264
16485: PUSH
16486: LD_INT 2
16488: PUSH
16489: LD_INT 42
16491: PUSH
16492: LD_INT 24
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: IFFALSE 16521
// points := [ 25 , 5 , 3 ] ;
16502: LD_ADDR_VAR 0 9
16506: PUSH
16507: LD_INT 25
16509: PUSH
16510: LD_INT 5
16512: PUSH
16513: LD_INT 3
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: LIST
16520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16521: LD_VAR 0 6
16525: PPUSH
16526: CALL_OW 264
16530: PUSH
16531: LD_INT 4
16533: PUSH
16534: LD_INT 43
16536: PUSH
16537: LD_INT 25
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: LIST
16544: IN
16545: IFFALSE 16566
// points := [ 40 , 15 , 5 ] ;
16547: LD_ADDR_VAR 0 9
16551: PUSH
16552: LD_INT 40
16554: PUSH
16555: LD_INT 15
16557: PUSH
16558: LD_INT 5
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16566: LD_VAR 0 6
16570: PPUSH
16571: CALL_OW 264
16575: PUSH
16576: LD_INT 3
16578: PUSH
16579: LD_INT 23
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: IN
16586: IFFALSE 16607
// points := [ 7 , 25 , 8 ] ;
16588: LD_ADDR_VAR 0 9
16592: PUSH
16593: LD_INT 7
16595: PUSH
16596: LD_INT 25
16598: PUSH
16599: LD_INT 8
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16607: LD_VAR 0 6
16611: PPUSH
16612: CALL_OW 264
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: LD_INT 27
16622: PUSH
16623: LD_INT 44
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: LIST
16630: IN
16631: IFFALSE 16652
// points := [ 14 , 50 , 16 ] ;
16633: LD_ADDR_VAR 0 9
16637: PUSH
16638: LD_INT 14
16640: PUSH
16641: LD_INT 50
16643: PUSH
16644: LD_INT 16
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16652: LD_VAR 0 6
16656: PPUSH
16657: CALL_OW 264
16661: PUSH
16662: LD_INT 6
16664: PUSH
16665: LD_INT 46
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: IN
16672: IFFALSE 16693
// points := [ 32 , 120 , 70 ] ;
16674: LD_ADDR_VAR 0 9
16678: PUSH
16679: LD_INT 32
16681: PUSH
16682: LD_INT 120
16684: PUSH
16685: LD_INT 70
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16693: LD_VAR 0 6
16697: PPUSH
16698: CALL_OW 264
16702: PUSH
16703: LD_INT 7
16705: PUSH
16706: LD_INT 28
16708: PUSH
16709: LD_INT 45
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: LIST
16716: IN
16717: IFFALSE 16738
// points := [ 35 , 20 , 45 ] ;
16719: LD_ADDR_VAR 0 9
16723: PUSH
16724: LD_INT 35
16726: PUSH
16727: LD_INT 20
16729: PUSH
16730: LD_INT 45
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16738: LD_VAR 0 6
16742: PPUSH
16743: CALL_OW 264
16747: PUSH
16748: LD_INT 47
16750: PUSH
16751: EMPTY
16752: LIST
16753: IN
16754: IFFALSE 16775
// points := [ 67 , 45 , 75 ] ;
16756: LD_ADDR_VAR 0 9
16760: PUSH
16761: LD_INT 67
16763: PUSH
16764: LD_INT 45
16766: PUSH
16767: LD_INT 75
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: LIST
16774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16775: LD_VAR 0 6
16779: PPUSH
16780: CALL_OW 264
16784: PUSH
16785: LD_INT 26
16787: PUSH
16788: EMPTY
16789: LIST
16790: IN
16791: IFFALSE 16812
// points := [ 120 , 30 , 80 ] ;
16793: LD_ADDR_VAR 0 9
16797: PUSH
16798: LD_INT 120
16800: PUSH
16801: LD_INT 30
16803: PUSH
16804: LD_INT 80
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16812: LD_VAR 0 6
16816: PPUSH
16817: CALL_OW 264
16821: PUSH
16822: LD_INT 22
16824: PUSH
16825: EMPTY
16826: LIST
16827: IN
16828: IFFALSE 16849
// points := [ 40 , 1 , 1 ] ;
16830: LD_ADDR_VAR 0 9
16834: PUSH
16835: LD_INT 40
16837: PUSH
16838: LD_INT 1
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16849: LD_VAR 0 6
16853: PPUSH
16854: CALL_OW 264
16858: PUSH
16859: LD_INT 29
16861: PUSH
16862: EMPTY
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 70 , 200 , 400 ] ;
16867: LD_ADDR_VAR 0 9
16871: PUSH
16872: LD_INT 70
16874: PUSH
16875: LD_INT 200
16877: PUSH
16878: LD_INT 400
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16886: LD_VAR 0 6
16890: PPUSH
16891: CALL_OW 264
16895: PUSH
16896: LD_INT 14
16898: PUSH
16899: LD_INT 53
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: IN
16906: IFFALSE 16927
// points := [ 40 , 10 , 20 ] ;
16908: LD_ADDR_VAR 0 9
16912: PUSH
16913: LD_INT 40
16915: PUSH
16916: LD_INT 10
16918: PUSH
16919: LD_INT 20
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16927: LD_VAR 0 6
16931: PPUSH
16932: CALL_OW 264
16936: PUSH
16937: LD_INT 9
16939: PUSH
16940: EMPTY
16941: LIST
16942: IN
16943: IFFALSE 16964
// points := [ 5 , 70 , 20 ] ;
16945: LD_ADDR_VAR 0 9
16949: PUSH
16950: LD_INT 5
16952: PUSH
16953: LD_INT 70
16955: PUSH
16956: LD_INT 20
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16964: LD_VAR 0 6
16968: PPUSH
16969: CALL_OW 264
16973: PUSH
16974: LD_INT 10
16976: PUSH
16977: EMPTY
16978: LIST
16979: IN
16980: IFFALSE 17001
// points := [ 35 , 110 , 70 ] ;
16982: LD_ADDR_VAR 0 9
16986: PUSH
16987: LD_INT 35
16989: PUSH
16990: LD_INT 110
16992: PUSH
16993: LD_INT 70
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17001: LD_VAR 0 6
17005: PPUSH
17006: CALL_OW 265
17010: PUSH
17011: LD_INT 25
17013: EQUAL
17014: IFFALSE 17035
// points := [ 80 , 65 , 100 ] ;
17016: LD_ADDR_VAR 0 9
17020: PUSH
17021: LD_INT 80
17023: PUSH
17024: LD_INT 65
17026: PUSH
17027: LD_INT 100
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17035: LD_VAR 0 6
17039: PPUSH
17040: CALL_OW 263
17044: PUSH
17045: LD_INT 1
17047: EQUAL
17048: IFFALSE 17083
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17050: LD_ADDR_VAR 0 10
17054: PUSH
17055: LD_VAR 0 10
17059: PUSH
17060: LD_VAR 0 6
17064: PPUSH
17065: CALL_OW 311
17069: PPUSH
17070: LD_INT 3
17072: PPUSH
17073: CALL_OW 259
17077: PUSH
17078: LD_INT 4
17080: MUL
17081: MUL
17082: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 263
17092: PUSH
17093: LD_INT 2
17095: EQUAL
17096: IFFALSE 17147
// begin j := IsControledBy ( i ) ;
17098: LD_ADDR_VAR 0 7
17102: PUSH
17103: LD_VAR 0 6
17107: PPUSH
17108: CALL_OW 312
17112: ST_TO_ADDR
// if j then
17113: LD_VAR 0 7
17117: IFFALSE 17147
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17119: LD_ADDR_VAR 0 10
17123: PUSH
17124: LD_VAR 0 10
17128: PUSH
17129: LD_VAR 0 7
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: CALL_OW 259
17141: PUSH
17142: LD_INT 3
17144: MUL
17145: MUL
17146: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17147: LD_VAR 0 6
17151: PPUSH
17152: CALL_OW 264
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: LD_INT 46
17165: PUSH
17166: LD_INT 44
17168: PUSH
17169: LD_INT 47
17171: PUSH
17172: LD_INT 45
17174: PUSH
17175: LD_INT 28
17177: PUSH
17178: LD_INT 7
17180: PUSH
17181: LD_INT 27
17183: PUSH
17184: LD_INT 29
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: IN
17199: PUSH
17200: LD_VAR 0 1
17204: PPUSH
17205: LD_INT 52
17207: PPUSH
17208: CALL_OW 321
17212: PUSH
17213: LD_INT 2
17215: EQUAL
17216: AND
17217: IFFALSE 17234
// bpoints := bpoints * 1.2 ;
17219: LD_ADDR_VAR 0 10
17223: PUSH
17224: LD_VAR 0 10
17228: PUSH
17229: LD_REAL  1.20000000000000E+0000
17232: MUL
17233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17234: LD_VAR 0 6
17238: PPUSH
17239: CALL_OW 264
17243: PUSH
17244: LD_INT 6
17246: PUSH
17247: LD_INT 46
17249: PUSH
17250: LD_INT 47
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: IN
17258: IFFALSE 17275
// bpoints := bpoints * 1.2 ;
17260: LD_ADDR_VAR 0 10
17264: PUSH
17265: LD_VAR 0 10
17269: PUSH
17270: LD_REAL  1.20000000000000E+0000
17273: MUL
17274: ST_TO_ADDR
// end ; unit_building :
17275: GO 17289
17277: LD_INT 3
17279: DOUBLE
17280: EQUAL
17281: IFTRUE 17285
17283: GO 17288
17285: POP
// ; end ;
17286: GO 17289
17288: POP
// for j = 1 to 3 do
17289: LD_ADDR_VAR 0 7
17293: PUSH
17294: DOUBLE
17295: LD_INT 1
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 3
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17356
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17305: LD_ADDR_VAR 0 5
17309: PUSH
17310: LD_VAR 0 5
17314: PPUSH
17315: LD_VAR 0 7
17319: PPUSH
17320: LD_VAR 0 5
17324: PUSH
17325: LD_VAR 0 7
17329: ARRAY
17330: PUSH
17331: LD_VAR 0 9
17335: PUSH
17336: LD_VAR 0 7
17340: ARRAY
17341: PUSH
17342: LD_VAR 0 10
17346: MUL
17347: PLUS
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
17354: GO 17302
17356: POP
17357: POP
// end ;
17358: GO 15841
17360: POP
17361: POP
// result := Replace ( result , 4 , tmp ) ;
17362: LD_ADDR_VAR 0 5
17366: PUSH
17367: LD_VAR 0 5
17371: PPUSH
17372: LD_INT 4
17374: PPUSH
17375: LD_VAR 0 8
17379: PPUSH
17380: CALL_OW 1
17384: ST_TO_ADDR
// end ;
17385: LD_VAR 0 5
17389: RET
// export function DangerAtRange ( unit , range ) ; begin
17390: LD_INT 0
17392: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17393: LD_ADDR_VAR 0 3
17397: PUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL_OW 255
17407: PPUSH
17408: LD_VAR 0 1
17412: PPUSH
17413: CALL_OW 250
17417: PPUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: CALL_OW 251
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL 15693 0 4
17437: ST_TO_ADDR
// end ;
17438: LD_VAR 0 3
17442: RET
// export function DangerInArea ( side , area ) ; begin
17443: LD_INT 0
17445: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17446: LD_ADDR_VAR 0 3
17450: PUSH
17451: LD_VAR 0 2
17455: PPUSH
17456: LD_INT 81
17458: PUSH
17459: LD_VAR 0 1
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PPUSH
17468: CALL_OW 70
17472: ST_TO_ADDR
// end ;
17473: LD_VAR 0 3
17477: RET
// export function IsExtension ( b ) ; begin
17478: LD_INT 0
17480: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17481: LD_ADDR_VAR 0 2
17485: PUSH
17486: LD_VAR 0 1
17490: PUSH
17491: LD_INT 23
17493: PUSH
17494: LD_INT 20
17496: PUSH
17497: LD_INT 22
17499: PUSH
17500: LD_INT 17
17502: PUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 21
17508: PUSH
17509: LD_INT 19
17511: PUSH
17512: LD_INT 16
17514: PUSH
17515: LD_INT 25
17517: PUSH
17518: LD_INT 18
17520: PUSH
17521: EMPTY
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: IN
17533: ST_TO_ADDR
// end ;
17534: LD_VAR 0 2
17538: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
17543: PPUSH
// result := [ ] ;
17544: LD_ADDR_VAR 0 4
17548: PUSH
17549: EMPTY
17550: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17551: LD_ADDR_VAR 0 5
17555: PUSH
17556: LD_VAR 0 2
17560: PPUSH
17561: LD_INT 21
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: CALL_OW 70
17575: ST_TO_ADDR
// if not tmp then
17576: LD_VAR 0 5
17580: NOT
17581: IFFALSE 17585
// exit ;
17583: GO 17649
// if checkLink then
17585: LD_VAR 0 3
17589: IFFALSE 17639
// begin for i in tmp do
17591: LD_ADDR_VAR 0 6
17595: PUSH
17596: LD_VAR 0 5
17600: PUSH
17601: FOR_IN
17602: IFFALSE 17637
// if GetBase ( i ) <> base then
17604: LD_VAR 0 6
17608: PPUSH
17609: CALL_OW 274
17613: PUSH
17614: LD_VAR 0 1
17618: NONEQUAL
17619: IFFALSE 17635
// ComLinkToBase ( base , i ) ;
17621: LD_VAR 0 1
17625: PPUSH
17626: LD_VAR 0 6
17630: PPUSH
17631: CALL_OW 169
17635: GO 17601
17637: POP
17638: POP
// end ; result := tmp ;
17639: LD_ADDR_VAR 0 4
17643: PUSH
17644: LD_VAR 0 5
17648: ST_TO_ADDR
// end ;
17649: LD_VAR 0 4
17653: RET
// export function ComComplete ( unit , b ) ; var i ; begin
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// if BuildingStatus ( b ) = bs_build then
17658: LD_VAR 0 2
17662: PPUSH
17663: CALL_OW 461
17667: PUSH
17668: LD_INT 1
17670: EQUAL
17671: IFFALSE 17731
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17673: LD_VAR 0 1
17677: PPUSH
17678: LD_STRING h
17680: PUSH
17681: LD_VAR 0 2
17685: PPUSH
17686: CALL_OW 250
17690: PUSH
17691: LD_VAR 0 2
17695: PPUSH
17696: CALL_OW 251
17700: PUSH
17701: LD_VAR 0 2
17705: PUSH
17706: LD_INT 0
17708: PUSH
17709: LD_INT 0
17711: PUSH
17712: LD_INT 0
17714: PUSH
17715: EMPTY
17716: LIST
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: PUSH
17724: EMPTY
17725: LIST
17726: PPUSH
17727: CALL_OW 446
// end ;
17731: LD_VAR 0 3
17735: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
17743: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17744: LD_VAR 0 1
17748: NOT
17749: PUSH
17750: LD_VAR 0 1
17754: PPUSH
17755: CALL_OW 263
17759: PUSH
17760: LD_INT 2
17762: EQUAL
17763: NOT
17764: OR
17765: IFFALSE 17769
// exit ;
17767: GO 18085
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17769: LD_ADDR_VAR 0 6
17773: PUSH
17774: LD_INT 22
17776: PUSH
17777: LD_VAR 0 1
17781: PPUSH
17782: CALL_OW 255
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: PUSH
17791: LD_INT 2
17793: PUSH
17794: LD_INT 30
17796: PUSH
17797: LD_INT 36
17799: PUSH
17800: EMPTY
17801: LIST
17802: LIST
17803: PUSH
17804: LD_INT 34
17806: PUSH
17807: LD_INT 31
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: PUSH
17814: EMPTY
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PPUSH
17823: CALL_OW 69
17827: ST_TO_ADDR
// if not tmp then
17828: LD_VAR 0 6
17832: NOT
17833: IFFALSE 17837
// exit ;
17835: GO 18085
// result := [ ] ;
17837: LD_ADDR_VAR 0 2
17841: PUSH
17842: EMPTY
17843: ST_TO_ADDR
// for i in tmp do
17844: LD_ADDR_VAR 0 3
17848: PUSH
17849: LD_VAR 0 6
17853: PUSH
17854: FOR_IN
17855: IFFALSE 17926
// begin t := UnitsInside ( i ) ;
17857: LD_ADDR_VAR 0 4
17861: PUSH
17862: LD_VAR 0 3
17866: PPUSH
17867: CALL_OW 313
17871: ST_TO_ADDR
// if t then
17872: LD_VAR 0 4
17876: IFFALSE 17924
// for j in t do
17878: LD_ADDR_VAR 0 7
17882: PUSH
17883: LD_VAR 0 4
17887: PUSH
17888: FOR_IN
17889: IFFALSE 17922
// result := Insert ( result , result + 1 , j ) ;
17891: LD_ADDR_VAR 0 2
17895: PUSH
17896: LD_VAR 0 2
17900: PPUSH
17901: LD_VAR 0 2
17905: PUSH
17906: LD_INT 1
17908: PLUS
17909: PPUSH
17910: LD_VAR 0 7
17914: PPUSH
17915: CALL_OW 2
17919: ST_TO_ADDR
17920: GO 17888
17922: POP
17923: POP
// end ;
17924: GO 17854
17926: POP
17927: POP
// if not result then
17928: LD_VAR 0 2
17932: NOT
17933: IFFALSE 17937
// exit ;
17935: GO 18085
// mech := result [ 1 ] ;
17937: LD_ADDR_VAR 0 5
17941: PUSH
17942: LD_VAR 0 2
17946: PUSH
17947: LD_INT 1
17949: ARRAY
17950: ST_TO_ADDR
// if result > 1 then
17951: LD_VAR 0 2
17955: PUSH
17956: LD_INT 1
17958: GREATER
17959: IFFALSE 18071
// for i = 2 to result do
17961: LD_ADDR_VAR 0 3
17965: PUSH
17966: DOUBLE
17967: LD_INT 2
17969: DEC
17970: ST_TO_ADDR
17971: LD_VAR 0 2
17975: PUSH
17976: FOR_TO
17977: IFFALSE 18069
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17979: LD_ADDR_VAR 0 4
17983: PUSH
17984: LD_VAR 0 2
17988: PUSH
17989: LD_VAR 0 3
17993: ARRAY
17994: PPUSH
17995: LD_INT 3
17997: PPUSH
17998: CALL_OW 259
18002: PUSH
18003: LD_VAR 0 2
18007: PUSH
18008: LD_VAR 0 3
18012: ARRAY
18013: PPUSH
18014: CALL_OW 432
18018: MINUS
18019: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18020: LD_VAR 0 4
18024: PUSH
18025: LD_VAR 0 5
18029: PPUSH
18030: LD_INT 3
18032: PPUSH
18033: CALL_OW 259
18037: PUSH
18038: LD_VAR 0 5
18042: PPUSH
18043: CALL_OW 432
18047: MINUS
18048: GREATEREQUAL
18049: IFFALSE 18067
// mech := result [ i ] ;
18051: LD_ADDR_VAR 0 5
18055: PUSH
18056: LD_VAR 0 2
18060: PUSH
18061: LD_VAR 0 3
18065: ARRAY
18066: ST_TO_ADDR
// end ;
18067: GO 17976
18069: POP
18070: POP
// ComLinkTo ( vehicle , mech ) ;
18071: LD_VAR 0 1
18075: PPUSH
18076: LD_VAR 0 5
18080: PPUSH
18081: CALL_OW 135
// end ;
18085: LD_VAR 0 2
18089: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18090: LD_INT 0
18092: PPUSH
18093: PPUSH
18094: PPUSH
18095: PPUSH
18096: PPUSH
18097: PPUSH
18098: PPUSH
18099: PPUSH
18100: PPUSH
18101: PPUSH
18102: PPUSH
18103: PPUSH
18104: PPUSH
// result := [ ] ;
18105: LD_ADDR_VAR 0 7
18109: PUSH
18110: EMPTY
18111: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18112: LD_VAR 0 1
18116: PPUSH
18117: CALL_OW 266
18121: PUSH
18122: LD_INT 0
18124: PUSH
18125: LD_INT 1
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: IN
18132: NOT
18133: IFFALSE 18137
// exit ;
18135: GO 19771
// if name then
18137: LD_VAR 0 3
18141: IFFALSE 18157
// SetBName ( base_dep , name ) ;
18143: LD_VAR 0 1
18147: PPUSH
18148: LD_VAR 0 3
18152: PPUSH
18153: CALL_OW 500
// base := GetBase ( base_dep ) ;
18157: LD_ADDR_VAR 0 15
18161: PUSH
18162: LD_VAR 0 1
18166: PPUSH
18167: CALL_OW 274
18171: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18172: LD_ADDR_VAR 0 16
18176: PUSH
18177: LD_VAR 0 1
18181: PPUSH
18182: CALL_OW 255
18186: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18187: LD_ADDR_VAR 0 17
18191: PUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: CALL_OW 248
18201: ST_TO_ADDR
// if sources then
18202: LD_VAR 0 5
18206: IFFALSE 18253
// for i = 1 to 3 do
18208: LD_ADDR_VAR 0 8
18212: PUSH
18213: DOUBLE
18214: LD_INT 1
18216: DEC
18217: ST_TO_ADDR
18218: LD_INT 3
18220: PUSH
18221: FOR_TO
18222: IFFALSE 18251
// AddResourceType ( base , i , sources [ i ] ) ;
18224: LD_VAR 0 15
18228: PPUSH
18229: LD_VAR 0 8
18233: PPUSH
18234: LD_VAR 0 5
18238: PUSH
18239: LD_VAR 0 8
18243: ARRAY
18244: PPUSH
18245: CALL_OW 276
18249: GO 18221
18251: POP
18252: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18253: LD_ADDR_VAR 0 18
18257: PUSH
18258: LD_VAR 0 15
18262: PPUSH
18263: LD_VAR 0 2
18267: PPUSH
18268: LD_INT 1
18270: PPUSH
18271: CALL 17539 0 3
18275: ST_TO_ADDR
// InitHc ;
18276: CALL_OW 19
// InitUc ;
18280: CALL_OW 18
// uc_side := side ;
18284: LD_ADDR_OWVAR 20
18288: PUSH
18289: LD_VAR 0 16
18293: ST_TO_ADDR
// uc_nation := nation ;
18294: LD_ADDR_OWVAR 21
18298: PUSH
18299: LD_VAR 0 17
18303: ST_TO_ADDR
// if buildings then
18304: LD_VAR 0 18
18308: IFFALSE 19630
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18310: LD_ADDR_VAR 0 19
18314: PUSH
18315: LD_VAR 0 18
18319: PPUSH
18320: LD_INT 2
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 29
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: LD_INT 30
18335: PUSH
18336: LD_INT 30
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: PUSH
18343: EMPTY
18344: LIST
18345: LIST
18346: LIST
18347: PPUSH
18348: CALL_OW 72
18352: ST_TO_ADDR
// if tmp then
18353: LD_VAR 0 19
18357: IFFALSE 18405
// for i in tmp do
18359: LD_ADDR_VAR 0 8
18363: PUSH
18364: LD_VAR 0 19
18368: PUSH
18369: FOR_IN
18370: IFFALSE 18403
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18372: LD_VAR 0 8
18376: PPUSH
18377: CALL_OW 250
18381: PPUSH
18382: LD_VAR 0 8
18386: PPUSH
18387: CALL_OW 251
18391: PPUSH
18392: LD_VAR 0 16
18396: PPUSH
18397: CALL_OW 441
18401: GO 18369
18403: POP
18404: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18405: LD_VAR 0 18
18409: PPUSH
18410: LD_INT 2
18412: PUSH
18413: LD_INT 30
18415: PUSH
18416: LD_INT 32
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: PUSH
18423: LD_INT 30
18425: PUSH
18426: LD_INT 33
18428: PUSH
18429: EMPTY
18430: LIST
18431: LIST
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: LIST
18437: PPUSH
18438: CALL_OW 72
18442: IFFALSE 18530
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18444: LD_ADDR_VAR 0 8
18448: PUSH
18449: LD_VAR 0 18
18453: PPUSH
18454: LD_INT 2
18456: PUSH
18457: LD_INT 30
18459: PUSH
18460: LD_INT 32
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PUSH
18467: LD_INT 30
18469: PUSH
18470: LD_INT 33
18472: PUSH
18473: EMPTY
18474: LIST
18475: LIST
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: LIST
18481: PPUSH
18482: CALL_OW 72
18486: PUSH
18487: FOR_IN
18488: IFFALSE 18528
// begin if not GetBWeapon ( i ) then
18490: LD_VAR 0 8
18494: PPUSH
18495: CALL_OW 269
18499: NOT
18500: IFFALSE 18526
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18502: LD_VAR 0 8
18506: PPUSH
18507: LD_VAR 0 8
18511: PPUSH
18512: LD_VAR 0 2
18516: PPUSH
18517: CALL 19776 0 2
18521: PPUSH
18522: CALL_OW 431
// end ;
18526: GO 18487
18528: POP
18529: POP
// end ; for i = 1 to personel do
18530: LD_ADDR_VAR 0 8
18534: PUSH
18535: DOUBLE
18536: LD_INT 1
18538: DEC
18539: ST_TO_ADDR
18540: LD_VAR 0 6
18544: PUSH
18545: FOR_TO
18546: IFFALSE 19610
// begin if i > 4 then
18548: LD_VAR 0 8
18552: PUSH
18553: LD_INT 4
18555: GREATER
18556: IFFALSE 18560
// break ;
18558: GO 19610
// case i of 1 :
18560: LD_VAR 0 8
18564: PUSH
18565: LD_INT 1
18567: DOUBLE
18568: EQUAL
18569: IFTRUE 18573
18571: GO 18653
18573: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18574: LD_ADDR_VAR 0 12
18578: PUSH
18579: LD_VAR 0 18
18583: PPUSH
18584: LD_INT 22
18586: PUSH
18587: LD_VAR 0 16
18591: PUSH
18592: EMPTY
18593: LIST
18594: LIST
18595: PUSH
18596: LD_INT 58
18598: PUSH
18599: EMPTY
18600: LIST
18601: PUSH
18602: LD_INT 2
18604: PUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 32
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 30
18617: PUSH
18618: LD_INT 4
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PUSH
18625: LD_INT 30
18627: PUSH
18628: LD_INT 5
18630: PUSH
18631: EMPTY
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PUSH
18641: EMPTY
18642: LIST
18643: LIST
18644: LIST
18645: PPUSH
18646: CALL_OW 72
18650: ST_TO_ADDR
18651: GO 18875
18653: LD_INT 2
18655: DOUBLE
18656: EQUAL
18657: IFTRUE 18661
18659: GO 18723
18661: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18662: LD_ADDR_VAR 0 12
18666: PUSH
18667: LD_VAR 0 18
18671: PPUSH
18672: LD_INT 22
18674: PUSH
18675: LD_VAR 0 16
18679: PUSH
18680: EMPTY
18681: LIST
18682: LIST
18683: PUSH
18684: LD_INT 2
18686: PUSH
18687: LD_INT 30
18689: PUSH
18690: LD_INT 0
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PUSH
18697: LD_INT 30
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: LIST
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PPUSH
18716: CALL_OW 72
18720: ST_TO_ADDR
18721: GO 18875
18723: LD_INT 3
18725: DOUBLE
18726: EQUAL
18727: IFTRUE 18731
18729: GO 18793
18731: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18732: LD_ADDR_VAR 0 12
18736: PUSH
18737: LD_VAR 0 18
18741: PPUSH
18742: LD_INT 22
18744: PUSH
18745: LD_VAR 0 16
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: PUSH
18754: LD_INT 2
18756: PUSH
18757: LD_INT 30
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 30
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: LIST
18781: PUSH
18782: EMPTY
18783: LIST
18784: LIST
18785: PPUSH
18786: CALL_OW 72
18790: ST_TO_ADDR
18791: GO 18875
18793: LD_INT 4
18795: DOUBLE
18796: EQUAL
18797: IFTRUE 18801
18799: GO 18874
18801: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18802: LD_ADDR_VAR 0 12
18806: PUSH
18807: LD_VAR 0 18
18811: PPUSH
18812: LD_INT 22
18814: PUSH
18815: LD_VAR 0 16
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PUSH
18824: LD_INT 2
18826: PUSH
18827: LD_INT 30
18829: PUSH
18830: LD_INT 6
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: LD_INT 30
18839: PUSH
18840: LD_INT 7
18842: PUSH
18843: EMPTY
18844: LIST
18845: LIST
18846: PUSH
18847: LD_INT 30
18849: PUSH
18850: LD_INT 8
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: LIST
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: PPUSH
18867: CALL_OW 72
18871: ST_TO_ADDR
18872: GO 18875
18874: POP
// if i = 1 then
18875: LD_VAR 0 8
18879: PUSH
18880: LD_INT 1
18882: EQUAL
18883: IFFALSE 18994
// begin tmp := [ ] ;
18885: LD_ADDR_VAR 0 19
18889: PUSH
18890: EMPTY
18891: ST_TO_ADDR
// for j in f do
18892: LD_ADDR_VAR 0 9
18896: PUSH
18897: LD_VAR 0 12
18901: PUSH
18902: FOR_IN
18903: IFFALSE 18976
// if GetBType ( j ) = b_bunker then
18905: LD_VAR 0 9
18909: PPUSH
18910: CALL_OW 266
18914: PUSH
18915: LD_INT 32
18917: EQUAL
18918: IFFALSE 18945
// tmp := Insert ( tmp , 1 , j ) else
18920: LD_ADDR_VAR 0 19
18924: PUSH
18925: LD_VAR 0 19
18929: PPUSH
18930: LD_INT 1
18932: PPUSH
18933: LD_VAR 0 9
18937: PPUSH
18938: CALL_OW 2
18942: ST_TO_ADDR
18943: GO 18974
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18945: LD_ADDR_VAR 0 19
18949: PUSH
18950: LD_VAR 0 19
18954: PPUSH
18955: LD_VAR 0 19
18959: PUSH
18960: LD_INT 1
18962: PLUS
18963: PPUSH
18964: LD_VAR 0 9
18968: PPUSH
18969: CALL_OW 2
18973: ST_TO_ADDR
18974: GO 18902
18976: POP
18977: POP
// if tmp then
18978: LD_VAR 0 19
18982: IFFALSE 18994
// f := tmp ;
18984: LD_ADDR_VAR 0 12
18988: PUSH
18989: LD_VAR 0 19
18993: ST_TO_ADDR
// end ; x := personel [ i ] ;
18994: LD_ADDR_VAR 0 13
18998: PUSH
18999: LD_VAR 0 6
19003: PUSH
19004: LD_VAR 0 8
19008: ARRAY
19009: ST_TO_ADDR
// if x = - 1 then
19010: LD_VAR 0 13
19014: PUSH
19015: LD_INT 1
19017: NEG
19018: EQUAL
19019: IFFALSE 19228
// begin for j in f do
19021: LD_ADDR_VAR 0 9
19025: PUSH
19026: LD_VAR 0 12
19030: PUSH
19031: FOR_IN
19032: IFFALSE 19224
// repeat InitHc ;
19034: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19038: LD_VAR 0 9
19042: PPUSH
19043: CALL_OW 266
19047: PUSH
19048: LD_INT 5
19050: EQUAL
19051: IFFALSE 19121
// begin if UnitsInside ( j ) < 3 then
19053: LD_VAR 0 9
19057: PPUSH
19058: CALL_OW 313
19062: PUSH
19063: LD_INT 3
19065: LESS
19066: IFFALSE 19102
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19068: LD_INT 0
19070: PPUSH
19071: LD_INT 5
19073: PUSH
19074: LD_INT 8
19076: PUSH
19077: LD_INT 9
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: LIST
19084: PUSH
19085: LD_VAR 0 17
19089: ARRAY
19090: PPUSH
19091: LD_VAR 0 4
19095: PPUSH
19096: CALL_OW 380
19100: GO 19119
// PrepareHuman ( false , i , skill ) ;
19102: LD_INT 0
19104: PPUSH
19105: LD_VAR 0 8
19109: PPUSH
19110: LD_VAR 0 4
19114: PPUSH
19115: CALL_OW 380
// end else
19119: GO 19138
// PrepareHuman ( false , i , skill ) ;
19121: LD_INT 0
19123: PPUSH
19124: LD_VAR 0 8
19128: PPUSH
19129: LD_VAR 0 4
19133: PPUSH
19134: CALL_OW 380
// un := CreateHuman ;
19138: LD_ADDR_VAR 0 14
19142: PUSH
19143: CALL_OW 44
19147: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19148: LD_ADDR_VAR 0 7
19152: PUSH
19153: LD_VAR 0 7
19157: PPUSH
19158: LD_INT 1
19160: PPUSH
19161: LD_VAR 0 14
19165: PPUSH
19166: CALL_OW 2
19170: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19171: LD_VAR 0 14
19175: PPUSH
19176: LD_VAR 0 9
19180: PPUSH
19181: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19185: LD_VAR 0 9
19189: PPUSH
19190: CALL_OW 313
19194: PUSH
19195: LD_INT 6
19197: EQUAL
19198: PUSH
19199: LD_VAR 0 9
19203: PPUSH
19204: CALL_OW 266
19208: PUSH
19209: LD_INT 32
19211: PUSH
19212: LD_INT 31
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: IN
19219: OR
19220: IFFALSE 19034
19222: GO 19031
19224: POP
19225: POP
// end else
19226: GO 19608
// for j = 1 to x do
19228: LD_ADDR_VAR 0 9
19232: PUSH
19233: DOUBLE
19234: LD_INT 1
19236: DEC
19237: ST_TO_ADDR
19238: LD_VAR 0 13
19242: PUSH
19243: FOR_TO
19244: IFFALSE 19606
// begin InitHc ;
19246: CALL_OW 19
// if not f then
19250: LD_VAR 0 12
19254: NOT
19255: IFFALSE 19344
// begin PrepareHuman ( false , i , skill ) ;
19257: LD_INT 0
19259: PPUSH
19260: LD_VAR 0 8
19264: PPUSH
19265: LD_VAR 0 4
19269: PPUSH
19270: CALL_OW 380
// un := CreateHuman ;
19274: LD_ADDR_VAR 0 14
19278: PUSH
19279: CALL_OW 44
19283: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19284: LD_ADDR_VAR 0 7
19288: PUSH
19289: LD_VAR 0 7
19293: PPUSH
19294: LD_INT 1
19296: PPUSH
19297: LD_VAR 0 14
19301: PPUSH
19302: CALL_OW 2
19306: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19307: LD_VAR 0 14
19311: PPUSH
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 250
19321: PPUSH
19322: LD_VAR 0 1
19326: PPUSH
19327: CALL_OW 251
19331: PPUSH
19332: LD_INT 10
19334: PPUSH
19335: LD_INT 0
19337: PPUSH
19338: CALL_OW 50
// continue ;
19342: GO 19243
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19344: LD_VAR 0 12
19348: PUSH
19349: LD_INT 1
19351: ARRAY
19352: PPUSH
19353: CALL_OW 313
19357: PUSH
19358: LD_VAR 0 12
19362: PUSH
19363: LD_INT 1
19365: ARRAY
19366: PPUSH
19367: CALL_OW 266
19371: PUSH
19372: LD_INT 32
19374: PUSH
19375: LD_INT 31
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: IN
19382: AND
19383: PUSH
19384: LD_VAR 0 12
19388: PUSH
19389: LD_INT 1
19391: ARRAY
19392: PPUSH
19393: CALL_OW 313
19397: PUSH
19398: LD_INT 6
19400: EQUAL
19401: OR
19402: IFFALSE 19422
// f := Delete ( f , 1 ) ;
19404: LD_ADDR_VAR 0 12
19408: PUSH
19409: LD_VAR 0 12
19413: PPUSH
19414: LD_INT 1
19416: PPUSH
19417: CALL_OW 3
19421: ST_TO_ADDR
// if not f then
19422: LD_VAR 0 12
19426: NOT
19427: IFFALSE 19445
// begin x := x + 2 ;
19429: LD_ADDR_VAR 0 13
19433: PUSH
19434: LD_VAR 0 13
19438: PUSH
19439: LD_INT 2
19441: PLUS
19442: ST_TO_ADDR
// continue ;
19443: GO 19243
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19445: LD_VAR 0 12
19449: PUSH
19450: LD_INT 1
19452: ARRAY
19453: PPUSH
19454: CALL_OW 266
19458: PUSH
19459: LD_INT 5
19461: EQUAL
19462: IFFALSE 19536
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19464: LD_VAR 0 12
19468: PUSH
19469: LD_INT 1
19471: ARRAY
19472: PPUSH
19473: CALL_OW 313
19477: PUSH
19478: LD_INT 3
19480: LESS
19481: IFFALSE 19517
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19483: LD_INT 0
19485: PPUSH
19486: LD_INT 5
19488: PUSH
19489: LD_INT 8
19491: PUSH
19492: LD_INT 9
19494: PUSH
19495: EMPTY
19496: LIST
19497: LIST
19498: LIST
19499: PUSH
19500: LD_VAR 0 17
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 4
19510: PPUSH
19511: CALL_OW 380
19515: GO 19534
// PrepareHuman ( false , i , skill ) ;
19517: LD_INT 0
19519: PPUSH
19520: LD_VAR 0 8
19524: PPUSH
19525: LD_VAR 0 4
19529: PPUSH
19530: CALL_OW 380
// end else
19534: GO 19553
// PrepareHuman ( false , i , skill ) ;
19536: LD_INT 0
19538: PPUSH
19539: LD_VAR 0 8
19543: PPUSH
19544: LD_VAR 0 4
19548: PPUSH
19549: CALL_OW 380
// un := CreateHuman ;
19553: LD_ADDR_VAR 0 14
19557: PUSH
19558: CALL_OW 44
19562: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19563: LD_ADDR_VAR 0 7
19567: PUSH
19568: LD_VAR 0 7
19572: PPUSH
19573: LD_INT 1
19575: PPUSH
19576: LD_VAR 0 14
19580: PPUSH
19581: CALL_OW 2
19585: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19586: LD_VAR 0 14
19590: PPUSH
19591: LD_VAR 0 12
19595: PUSH
19596: LD_INT 1
19598: ARRAY
19599: PPUSH
19600: CALL_OW 52
// end ;
19604: GO 19243
19606: POP
19607: POP
// end ;
19608: GO 18545
19610: POP
19611: POP
// result := result ^ buildings ;
19612: LD_ADDR_VAR 0 7
19616: PUSH
19617: LD_VAR 0 7
19621: PUSH
19622: LD_VAR 0 18
19626: ADD
19627: ST_TO_ADDR
// end else
19628: GO 19771
// begin for i = 1 to personel do
19630: LD_ADDR_VAR 0 8
19634: PUSH
19635: DOUBLE
19636: LD_INT 1
19638: DEC
19639: ST_TO_ADDR
19640: LD_VAR 0 6
19644: PUSH
19645: FOR_TO
19646: IFFALSE 19769
// begin if i > 4 then
19648: LD_VAR 0 8
19652: PUSH
19653: LD_INT 4
19655: GREATER
19656: IFFALSE 19660
// break ;
19658: GO 19769
// x := personel [ i ] ;
19660: LD_ADDR_VAR 0 13
19664: PUSH
19665: LD_VAR 0 6
19669: PUSH
19670: LD_VAR 0 8
19674: ARRAY
19675: ST_TO_ADDR
// if x = - 1 then
19676: LD_VAR 0 13
19680: PUSH
19681: LD_INT 1
19683: NEG
19684: EQUAL
19685: IFFALSE 19689
// continue ;
19687: GO 19645
// PrepareHuman ( false , i , skill ) ;
19689: LD_INT 0
19691: PPUSH
19692: LD_VAR 0 8
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: CALL_OW 380
// un := CreateHuman ;
19706: LD_ADDR_VAR 0 14
19710: PUSH
19711: CALL_OW 44
19715: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19716: LD_VAR 0 14
19720: PPUSH
19721: LD_VAR 0 1
19725: PPUSH
19726: CALL_OW 250
19730: PPUSH
19731: LD_VAR 0 1
19735: PPUSH
19736: CALL_OW 251
19740: PPUSH
19741: LD_INT 10
19743: PPUSH
19744: LD_INT 0
19746: PPUSH
19747: CALL_OW 50
// result := result ^ un ;
19751: LD_ADDR_VAR 0 7
19755: PUSH
19756: LD_VAR 0 7
19760: PUSH
19761: LD_VAR 0 14
19765: ADD
19766: ST_TO_ADDR
// end ;
19767: GO 19645
19769: POP
19770: POP
// end ; end ;
19771: LD_VAR 0 7
19775: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19776: LD_INT 0
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
19785: PPUSH
19786: PPUSH
19787: PPUSH
19788: PPUSH
19789: PPUSH
19790: PPUSH
19791: PPUSH
19792: PPUSH
19793: PPUSH
// result := false ;
19794: LD_ADDR_VAR 0 3
19798: PUSH
19799: LD_INT 0
19801: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19802: LD_VAR 0 1
19806: NOT
19807: PUSH
19808: LD_VAR 0 1
19812: PPUSH
19813: CALL_OW 266
19817: PUSH
19818: LD_INT 32
19820: PUSH
19821: LD_INT 33
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: IN
19828: NOT
19829: OR
19830: IFFALSE 19834
// exit ;
19832: GO 20973
// nat := GetNation ( tower ) ;
19834: LD_ADDR_VAR 0 12
19838: PUSH
19839: LD_VAR 0 1
19843: PPUSH
19844: CALL_OW 248
19848: ST_TO_ADDR
// side := GetSide ( tower ) ;
19849: LD_ADDR_VAR 0 16
19853: PUSH
19854: LD_VAR 0 1
19858: PPUSH
19859: CALL_OW 255
19863: ST_TO_ADDR
// x := GetX ( tower ) ;
19864: LD_ADDR_VAR 0 10
19868: PUSH
19869: LD_VAR 0 1
19873: PPUSH
19874: CALL_OW 250
19878: ST_TO_ADDR
// y := GetY ( tower ) ;
19879: LD_ADDR_VAR 0 11
19883: PUSH
19884: LD_VAR 0 1
19888: PPUSH
19889: CALL_OW 251
19893: ST_TO_ADDR
// if not x or not y then
19894: LD_VAR 0 10
19898: NOT
19899: PUSH
19900: LD_VAR 0 11
19904: NOT
19905: OR
19906: IFFALSE 19910
// exit ;
19908: GO 20973
// weapon := 0 ;
19910: LD_ADDR_VAR 0 18
19914: PUSH
19915: LD_INT 0
19917: ST_TO_ADDR
// fac_list := [ ] ;
19918: LD_ADDR_VAR 0 17
19922: PUSH
19923: EMPTY
19924: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19925: LD_ADDR_VAR 0 6
19929: PUSH
19930: LD_VAR 0 1
19934: PPUSH
19935: CALL_OW 274
19939: PPUSH
19940: LD_VAR 0 2
19944: PPUSH
19945: LD_INT 0
19947: PPUSH
19948: CALL 17539 0 3
19952: PPUSH
19953: LD_INT 30
19955: PUSH
19956: LD_INT 3
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PPUSH
19963: CALL_OW 72
19967: ST_TO_ADDR
// if not factories then
19968: LD_VAR 0 6
19972: NOT
19973: IFFALSE 19977
// exit ;
19975: GO 20973
// for i in factories do
19977: LD_ADDR_VAR 0 8
19981: PUSH
19982: LD_VAR 0 6
19986: PUSH
19987: FOR_IN
19988: IFFALSE 20013
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19990: LD_ADDR_VAR 0 17
19994: PUSH
19995: LD_VAR 0 17
19999: PUSH
20000: LD_VAR 0 8
20004: PPUSH
20005: CALL_OW 478
20009: UNION
20010: ST_TO_ADDR
20011: GO 19987
20013: POP
20014: POP
// if not fac_list then
20015: LD_VAR 0 17
20019: NOT
20020: IFFALSE 20024
// exit ;
20022: GO 20973
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20024: LD_ADDR_VAR 0 5
20028: PUSH
20029: LD_INT 4
20031: PUSH
20032: LD_INT 5
20034: PUSH
20035: LD_INT 9
20037: PUSH
20038: LD_INT 10
20040: PUSH
20041: LD_INT 6
20043: PUSH
20044: LD_INT 7
20046: PUSH
20047: LD_INT 11
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: LIST
20054: LIST
20055: LIST
20056: LIST
20057: LIST
20058: PUSH
20059: LD_INT 27
20061: PUSH
20062: LD_INT 28
20064: PUSH
20065: LD_INT 26
20067: PUSH
20068: LD_INT 30
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: LIST
20075: LIST
20076: PUSH
20077: LD_INT 43
20079: PUSH
20080: LD_INT 44
20082: PUSH
20083: LD_INT 46
20085: PUSH
20086: LD_INT 45
20088: PUSH
20089: LD_INT 47
20091: PUSH
20092: LD_INT 49
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: LIST
20107: PUSH
20108: LD_VAR 0 12
20112: ARRAY
20113: ST_TO_ADDR
// for i in list do
20114: LD_ADDR_VAR 0 8
20118: PUSH
20119: LD_VAR 0 5
20123: PUSH
20124: FOR_IN
20125: IFFALSE 20158
// if not i in fac_list then
20127: LD_VAR 0 8
20131: PUSH
20132: LD_VAR 0 17
20136: IN
20137: NOT
20138: IFFALSE 20156
// list := list diff i ;
20140: LD_ADDR_VAR 0 5
20144: PUSH
20145: LD_VAR 0 5
20149: PUSH
20150: LD_VAR 0 8
20154: DIFF
20155: ST_TO_ADDR
20156: GO 20124
20158: POP
20159: POP
// if not list then
20160: LD_VAR 0 5
20164: NOT
20165: IFFALSE 20169
// exit ;
20167: GO 20973
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20169: LD_VAR 0 12
20173: PUSH
20174: LD_INT 3
20176: EQUAL
20177: PUSH
20178: LD_INT 49
20180: PUSH
20181: LD_VAR 0 5
20185: IN
20186: AND
20187: PUSH
20188: LD_INT 31
20190: PPUSH
20191: LD_VAR 0 16
20195: PPUSH
20196: CALL_OW 321
20200: PUSH
20201: LD_INT 2
20203: EQUAL
20204: AND
20205: IFFALSE 20265
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20207: LD_INT 22
20209: PUSH
20210: LD_VAR 0 16
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: PUSH
20219: LD_INT 35
20221: PUSH
20222: LD_INT 49
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: PUSH
20229: LD_INT 91
20231: PUSH
20232: LD_VAR 0 1
20236: PUSH
20237: LD_INT 10
20239: PUSH
20240: EMPTY
20241: LIST
20242: LIST
20243: LIST
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: PPUSH
20250: CALL_OW 69
20254: NOT
20255: IFFALSE 20265
// weapon := ru_time_lapser ;
20257: LD_ADDR_VAR 0 18
20261: PUSH
20262: LD_INT 49
20264: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20265: LD_VAR 0 12
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 2
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: IN
20280: PUSH
20281: LD_INT 11
20283: PUSH
20284: LD_VAR 0 5
20288: IN
20289: PUSH
20290: LD_INT 30
20292: PUSH
20293: LD_VAR 0 5
20297: IN
20298: OR
20299: AND
20300: PUSH
20301: LD_INT 6
20303: PPUSH
20304: LD_VAR 0 16
20308: PPUSH
20309: CALL_OW 321
20313: PUSH
20314: LD_INT 2
20316: EQUAL
20317: AND
20318: IFFALSE 20483
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20320: LD_INT 22
20322: PUSH
20323: LD_VAR 0 16
20327: PUSH
20328: EMPTY
20329: LIST
20330: LIST
20331: PUSH
20332: LD_INT 2
20334: PUSH
20335: LD_INT 35
20337: PUSH
20338: LD_INT 11
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: PUSH
20345: LD_INT 35
20347: PUSH
20348: LD_INT 30
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: PUSH
20360: LD_INT 91
20362: PUSH
20363: LD_VAR 0 1
20367: PUSH
20368: LD_INT 18
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: LIST
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: LIST
20380: PPUSH
20381: CALL_OW 69
20385: NOT
20386: PUSH
20387: LD_INT 22
20389: PUSH
20390: LD_VAR 0 16
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 30
20404: PUSH
20405: LD_INT 32
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 30
20414: PUSH
20415: LD_INT 33
20417: PUSH
20418: EMPTY
20419: LIST
20420: LIST
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: LIST
20426: PUSH
20427: LD_INT 91
20429: PUSH
20430: LD_VAR 0 1
20434: PUSH
20435: LD_INT 12
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: PPUSH
20451: CALL_OW 69
20455: PUSH
20456: LD_INT 2
20458: GREATER
20459: AND
20460: IFFALSE 20483
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20462: LD_ADDR_VAR 0 18
20466: PUSH
20467: LD_INT 11
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: PUSH
20477: LD_VAR 0 12
20481: ARRAY
20482: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20483: LD_VAR 0 18
20487: NOT
20488: PUSH
20489: LD_INT 40
20491: PPUSH
20492: LD_VAR 0 16
20496: PPUSH
20497: CALL_OW 321
20501: PUSH
20502: LD_INT 2
20504: EQUAL
20505: AND
20506: PUSH
20507: LD_INT 7
20509: PUSH
20510: LD_VAR 0 5
20514: IN
20515: PUSH
20516: LD_INT 28
20518: PUSH
20519: LD_VAR 0 5
20523: IN
20524: OR
20525: PUSH
20526: LD_INT 45
20528: PUSH
20529: LD_VAR 0 5
20533: IN
20534: OR
20535: AND
20536: IFFALSE 20790
// begin hex := GetHexInfo ( x , y ) ;
20538: LD_ADDR_VAR 0 4
20542: PUSH
20543: LD_VAR 0 10
20547: PPUSH
20548: LD_VAR 0 11
20552: PPUSH
20553: CALL_OW 546
20557: ST_TO_ADDR
// if hex [ 1 ] then
20558: LD_VAR 0 4
20562: PUSH
20563: LD_INT 1
20565: ARRAY
20566: IFFALSE 20570
// exit ;
20568: GO 20973
// height := hex [ 2 ] ;
20570: LD_ADDR_VAR 0 15
20574: PUSH
20575: LD_VAR 0 4
20579: PUSH
20580: LD_INT 2
20582: ARRAY
20583: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20584: LD_ADDR_VAR 0 14
20588: PUSH
20589: LD_INT 0
20591: PUSH
20592: LD_INT 2
20594: PUSH
20595: LD_INT 3
20597: PUSH
20598: LD_INT 5
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: ST_TO_ADDR
// for i in tmp do
20607: LD_ADDR_VAR 0 8
20611: PUSH
20612: LD_VAR 0 14
20616: PUSH
20617: FOR_IN
20618: IFFALSE 20788
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20620: LD_ADDR_VAR 0 9
20624: PUSH
20625: LD_VAR 0 10
20629: PPUSH
20630: LD_VAR 0 8
20634: PPUSH
20635: LD_INT 5
20637: PPUSH
20638: CALL_OW 272
20642: PUSH
20643: LD_VAR 0 11
20647: PPUSH
20648: LD_VAR 0 8
20652: PPUSH
20653: LD_INT 5
20655: PPUSH
20656: CALL_OW 273
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20665: LD_VAR 0 9
20669: PUSH
20670: LD_INT 1
20672: ARRAY
20673: PPUSH
20674: LD_VAR 0 9
20678: PUSH
20679: LD_INT 2
20681: ARRAY
20682: PPUSH
20683: CALL_OW 488
20687: IFFALSE 20786
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20689: LD_ADDR_VAR 0 4
20693: PUSH
20694: LD_VAR 0 9
20698: PUSH
20699: LD_INT 1
20701: ARRAY
20702: PPUSH
20703: LD_VAR 0 9
20707: PUSH
20708: LD_INT 2
20710: ARRAY
20711: PPUSH
20712: CALL_OW 546
20716: ST_TO_ADDR
// if hex [ 1 ] then
20717: LD_VAR 0 4
20721: PUSH
20722: LD_INT 1
20724: ARRAY
20725: IFFALSE 20729
// continue ;
20727: GO 20617
// h := hex [ 2 ] ;
20729: LD_ADDR_VAR 0 13
20733: PUSH
20734: LD_VAR 0 4
20738: PUSH
20739: LD_INT 2
20741: ARRAY
20742: ST_TO_ADDR
// if h + 7 < height then
20743: LD_VAR 0 13
20747: PUSH
20748: LD_INT 7
20750: PLUS
20751: PUSH
20752: LD_VAR 0 15
20756: LESS
20757: IFFALSE 20786
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20759: LD_ADDR_VAR 0 18
20763: PUSH
20764: LD_INT 7
20766: PUSH
20767: LD_INT 28
20769: PUSH
20770: LD_INT 45
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: LIST
20777: PUSH
20778: LD_VAR 0 12
20782: ARRAY
20783: ST_TO_ADDR
// break ;
20784: GO 20788
// end ; end ; end ;
20786: GO 20617
20788: POP
20789: POP
// end ; if not weapon then
20790: LD_VAR 0 18
20794: NOT
20795: IFFALSE 20855
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20797: LD_ADDR_VAR 0 5
20801: PUSH
20802: LD_VAR 0 5
20806: PUSH
20807: LD_INT 11
20809: PUSH
20810: LD_INT 30
20812: PUSH
20813: LD_INT 49
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: LIST
20820: DIFF
20821: ST_TO_ADDR
// if not list then
20822: LD_VAR 0 5
20826: NOT
20827: IFFALSE 20831
// exit ;
20829: GO 20973
// weapon := list [ rand ( 1 , list ) ] ;
20831: LD_ADDR_VAR 0 18
20835: PUSH
20836: LD_VAR 0 5
20840: PUSH
20841: LD_INT 1
20843: PPUSH
20844: LD_VAR 0 5
20848: PPUSH
20849: CALL_OW 12
20853: ARRAY
20854: ST_TO_ADDR
// end ; if weapon then
20855: LD_VAR 0 18
20859: IFFALSE 20973
// begin tmp := CostOfWeapon ( weapon ) ;
20861: LD_ADDR_VAR 0 14
20865: PUSH
20866: LD_VAR 0 18
20870: PPUSH
20871: CALL_OW 451
20875: ST_TO_ADDR
// j := GetBase ( tower ) ;
20876: LD_ADDR_VAR 0 9
20880: PUSH
20881: LD_VAR 0 1
20885: PPUSH
20886: CALL_OW 274
20890: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20891: LD_VAR 0 9
20895: PPUSH
20896: LD_INT 1
20898: PPUSH
20899: CALL_OW 275
20903: PUSH
20904: LD_VAR 0 14
20908: PUSH
20909: LD_INT 1
20911: ARRAY
20912: GREATEREQUAL
20913: PUSH
20914: LD_VAR 0 9
20918: PPUSH
20919: LD_INT 2
20921: PPUSH
20922: CALL_OW 275
20926: PUSH
20927: LD_VAR 0 14
20931: PUSH
20932: LD_INT 2
20934: ARRAY
20935: GREATEREQUAL
20936: AND
20937: PUSH
20938: LD_VAR 0 9
20942: PPUSH
20943: LD_INT 3
20945: PPUSH
20946: CALL_OW 275
20950: PUSH
20951: LD_VAR 0 14
20955: PUSH
20956: LD_INT 3
20958: ARRAY
20959: GREATEREQUAL
20960: AND
20961: IFFALSE 20973
// result := weapon ;
20963: LD_ADDR_VAR 0 3
20967: PUSH
20968: LD_VAR 0 18
20972: ST_TO_ADDR
// end ; end ;
20973: LD_VAR 0 3
20977: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20978: LD_INT 0
20980: PPUSH
20981: PPUSH
// result := true ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_INT 1
20989: ST_TO_ADDR
// if array1 = array2 then
20990: LD_VAR 0 1
20994: PUSH
20995: LD_VAR 0 2
20999: EQUAL
21000: IFFALSE 21060
// begin for i = 1 to array1 do
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: DOUBLE
21008: LD_INT 1
21010: DEC
21011: ST_TO_ADDR
21012: LD_VAR 0 1
21016: PUSH
21017: FOR_TO
21018: IFFALSE 21056
// if array1 [ i ] <> array2 [ i ] then
21020: LD_VAR 0 1
21024: PUSH
21025: LD_VAR 0 4
21029: ARRAY
21030: PUSH
21031: LD_VAR 0 2
21035: PUSH
21036: LD_VAR 0 4
21040: ARRAY
21041: NONEQUAL
21042: IFFALSE 21054
// begin result := false ;
21044: LD_ADDR_VAR 0 3
21048: PUSH
21049: LD_INT 0
21051: ST_TO_ADDR
// break ;
21052: GO 21056
// end ;
21054: GO 21017
21056: POP
21057: POP
// end else
21058: GO 21068
// result := false ;
21060: LD_ADDR_VAR 0 3
21064: PUSH
21065: LD_INT 0
21067: ST_TO_ADDR
// end ;
21068: LD_VAR 0 3
21072: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21073: LD_INT 0
21075: PPUSH
21076: PPUSH
21077: PPUSH
// pom := GetBase ( fac ) ;
21078: LD_ADDR_VAR 0 5
21082: PUSH
21083: LD_VAR 0 1
21087: PPUSH
21088: CALL_OW 274
21092: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21093: LD_ADDR_VAR 0 4
21097: PUSH
21098: LD_VAR 0 2
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: PPUSH
21107: LD_VAR 0 2
21111: PUSH
21112: LD_INT 2
21114: ARRAY
21115: PPUSH
21116: LD_VAR 0 2
21120: PUSH
21121: LD_INT 3
21123: ARRAY
21124: PPUSH
21125: LD_VAR 0 2
21129: PUSH
21130: LD_INT 4
21132: ARRAY
21133: PPUSH
21134: CALL_OW 449
21138: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21139: LD_ADDR_VAR 0 3
21143: PUSH
21144: LD_VAR 0 5
21148: PPUSH
21149: LD_INT 1
21151: PPUSH
21152: CALL_OW 275
21156: PUSH
21157: LD_VAR 0 4
21161: PUSH
21162: LD_INT 1
21164: ARRAY
21165: GREATEREQUAL
21166: PUSH
21167: LD_VAR 0 5
21171: PPUSH
21172: LD_INT 2
21174: PPUSH
21175: CALL_OW 275
21179: PUSH
21180: LD_VAR 0 4
21184: PUSH
21185: LD_INT 2
21187: ARRAY
21188: GREATEREQUAL
21189: AND
21190: PUSH
21191: LD_VAR 0 5
21195: PPUSH
21196: LD_INT 3
21198: PPUSH
21199: CALL_OW 275
21203: PUSH
21204: LD_VAR 0 4
21208: PUSH
21209: LD_INT 3
21211: ARRAY
21212: GREATEREQUAL
21213: AND
21214: ST_TO_ADDR
// end ;
21215: LD_VAR 0 3
21219: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21220: LD_INT 0
21222: PPUSH
21223: PPUSH
21224: PPUSH
21225: PPUSH
// pom := GetBase ( building ) ;
21226: LD_ADDR_VAR 0 3
21230: PUSH
21231: LD_VAR 0 1
21235: PPUSH
21236: CALL_OW 274
21240: ST_TO_ADDR
// if not pom then
21241: LD_VAR 0 3
21245: NOT
21246: IFFALSE 21250
// exit ;
21248: GO 21420
// btype := GetBType ( building ) ;
21250: LD_ADDR_VAR 0 5
21254: PUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: CALL_OW 266
21264: ST_TO_ADDR
// if btype = b_armoury then
21265: LD_VAR 0 5
21269: PUSH
21270: LD_INT 4
21272: EQUAL
21273: IFFALSE 21283
// btype := b_barracks ;
21275: LD_ADDR_VAR 0 5
21279: PUSH
21280: LD_INT 5
21282: ST_TO_ADDR
// if btype = b_depot then
21283: LD_VAR 0 5
21287: PUSH
21288: LD_INT 0
21290: EQUAL
21291: IFFALSE 21301
// btype := b_warehouse ;
21293: LD_ADDR_VAR 0 5
21297: PUSH
21298: LD_INT 1
21300: ST_TO_ADDR
// if btype = b_workshop then
21301: LD_VAR 0 5
21305: PUSH
21306: LD_INT 2
21308: EQUAL
21309: IFFALSE 21319
// btype := b_factory ;
21311: LD_ADDR_VAR 0 5
21315: PUSH
21316: LD_INT 3
21318: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21319: LD_ADDR_VAR 0 4
21323: PUSH
21324: LD_VAR 0 5
21328: PPUSH
21329: LD_VAR 0 1
21333: PPUSH
21334: CALL_OW 248
21338: PPUSH
21339: CALL_OW 450
21343: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21344: LD_ADDR_VAR 0 2
21348: PUSH
21349: LD_VAR 0 3
21353: PPUSH
21354: LD_INT 1
21356: PPUSH
21357: CALL_OW 275
21361: PUSH
21362: LD_VAR 0 4
21366: PUSH
21367: LD_INT 1
21369: ARRAY
21370: GREATEREQUAL
21371: PUSH
21372: LD_VAR 0 3
21376: PPUSH
21377: LD_INT 2
21379: PPUSH
21380: CALL_OW 275
21384: PUSH
21385: LD_VAR 0 4
21389: PUSH
21390: LD_INT 2
21392: ARRAY
21393: GREATEREQUAL
21394: AND
21395: PUSH
21396: LD_VAR 0 3
21400: PPUSH
21401: LD_INT 3
21403: PPUSH
21404: CALL_OW 275
21408: PUSH
21409: LD_VAR 0 4
21413: PUSH
21414: LD_INT 3
21416: ARRAY
21417: GREATEREQUAL
21418: AND
21419: ST_TO_ADDR
// end ;
21420: LD_VAR 0 2
21424: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21425: LD_INT 0
21427: PPUSH
21428: PPUSH
21429: PPUSH
// pom := GetBase ( building ) ;
21430: LD_ADDR_VAR 0 4
21434: PUSH
21435: LD_VAR 0 1
21439: PPUSH
21440: CALL_OW 274
21444: ST_TO_ADDR
// if not pom then
21445: LD_VAR 0 4
21449: NOT
21450: IFFALSE 21454
// exit ;
21452: GO 21555
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21454: LD_ADDR_VAR 0 5
21458: PUSH
21459: LD_VAR 0 2
21463: PPUSH
21464: LD_VAR 0 1
21468: PPUSH
21469: CALL_OW 248
21473: PPUSH
21474: CALL_OW 450
21478: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21479: LD_ADDR_VAR 0 3
21483: PUSH
21484: LD_VAR 0 4
21488: PPUSH
21489: LD_INT 1
21491: PPUSH
21492: CALL_OW 275
21496: PUSH
21497: LD_VAR 0 5
21501: PUSH
21502: LD_INT 1
21504: ARRAY
21505: GREATEREQUAL
21506: PUSH
21507: LD_VAR 0 4
21511: PPUSH
21512: LD_INT 2
21514: PPUSH
21515: CALL_OW 275
21519: PUSH
21520: LD_VAR 0 5
21524: PUSH
21525: LD_INT 2
21527: ARRAY
21528: GREATEREQUAL
21529: AND
21530: PUSH
21531: LD_VAR 0 4
21535: PPUSH
21536: LD_INT 3
21538: PPUSH
21539: CALL_OW 275
21543: PUSH
21544: LD_VAR 0 5
21548: PUSH
21549: LD_INT 3
21551: ARRAY
21552: GREATEREQUAL
21553: AND
21554: ST_TO_ADDR
// end ;
21555: LD_VAR 0 3
21559: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
21560: LD_INT 0
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
21567: PPUSH
21568: PPUSH
21569: PPUSH
21570: PPUSH
21571: PPUSH
// result := false ;
21572: LD_ADDR_VAR 0 6
21576: PUSH
21577: LD_INT 0
21579: ST_TO_ADDR
// if not base or not btype or not x or not y then
21580: LD_VAR 0 1
21584: NOT
21585: PUSH
21586: LD_VAR 0 2
21590: NOT
21591: OR
21592: PUSH
21593: LD_VAR 0 3
21597: NOT
21598: OR
21599: PUSH
21600: LD_VAR 0 4
21604: NOT
21605: OR
21606: IFFALSE 21610
// exit ;
21608: GO 22219
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
21610: LD_ADDR_VAR 0 12
21614: PUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: LD_VAR 0 3
21624: PPUSH
21625: LD_VAR 0 4
21629: PPUSH
21630: LD_VAR 0 5
21634: PPUSH
21635: LD_VAR 0 1
21639: PUSH
21640: LD_INT 1
21642: ARRAY
21643: PPUSH
21644: CALL_OW 248
21648: PPUSH
21649: LD_INT 0
21651: PPUSH
21652: CALL 23056 0 6
21656: ST_TO_ADDR
// if not hexes then
21657: LD_VAR 0 12
21661: NOT
21662: IFFALSE 21666
// exit ;
21664: GO 22219
// for i = 1 to hexes do
21666: LD_ADDR_VAR 0 7
21670: PUSH
21671: DOUBLE
21672: LD_INT 1
21674: DEC
21675: ST_TO_ADDR
21676: LD_VAR 0 12
21680: PUSH
21681: FOR_TO
21682: IFFALSE 22217
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21684: LD_ADDR_VAR 0 11
21688: PUSH
21689: LD_VAR 0 12
21693: PUSH
21694: LD_VAR 0 7
21698: ARRAY
21699: PUSH
21700: LD_INT 1
21702: ARRAY
21703: PPUSH
21704: LD_VAR 0 12
21708: PUSH
21709: LD_VAR 0 7
21713: ARRAY
21714: PUSH
21715: LD_INT 2
21717: ARRAY
21718: PPUSH
21719: CALL_OW 428
21723: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21724: LD_VAR 0 12
21728: PUSH
21729: LD_VAR 0 7
21733: ARRAY
21734: PUSH
21735: LD_INT 1
21737: ARRAY
21738: PPUSH
21739: LD_VAR 0 12
21743: PUSH
21744: LD_VAR 0 7
21748: ARRAY
21749: PUSH
21750: LD_INT 2
21752: ARRAY
21753: PPUSH
21754: CALL_OW 351
21758: PUSH
21759: LD_VAR 0 12
21763: PUSH
21764: LD_VAR 0 7
21768: ARRAY
21769: PUSH
21770: LD_INT 1
21772: ARRAY
21773: PPUSH
21774: LD_VAR 0 12
21778: PUSH
21779: LD_VAR 0 7
21783: ARRAY
21784: PUSH
21785: LD_INT 2
21787: ARRAY
21788: PPUSH
21789: CALL_OW 488
21793: NOT
21794: OR
21795: PUSH
21796: LD_VAR 0 11
21800: PPUSH
21801: CALL_OW 247
21805: PUSH
21806: LD_INT 3
21808: EQUAL
21809: OR
21810: IFFALSE 21816
// exit ;
21812: POP
21813: POP
21814: GO 22219
// if not tmp or not tmp in base then
21816: LD_VAR 0 11
21820: NOT
21821: PUSH
21822: LD_VAR 0 11
21826: PUSH
21827: LD_VAR 0 1
21831: IN
21832: NOT
21833: OR
21834: IFFALSE 21838
// continue ;
21836: GO 21681
// result := true ;
21838: LD_ADDR_VAR 0 6
21842: PUSH
21843: LD_INT 1
21845: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21846: LD_ADDR_VAR 0 15
21850: PUSH
21851: LD_VAR 0 1
21855: PPUSH
21856: LD_INT 22
21858: PUSH
21859: LD_VAR 0 11
21863: PPUSH
21864: CALL_OW 255
21868: PUSH
21869: EMPTY
21870: LIST
21871: LIST
21872: PUSH
21873: LD_INT 2
21875: PUSH
21876: LD_INT 30
21878: PUSH
21879: LD_INT 0
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: LD_INT 30
21888: PUSH
21889: LD_INT 1
21891: PUSH
21892: EMPTY
21893: LIST
21894: LIST
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 72
21909: ST_TO_ADDR
// if dep then
21910: LD_VAR 0 15
21914: IFFALSE 22050
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21916: LD_ADDR_VAR 0 14
21920: PUSH
21921: LD_VAR 0 15
21925: PUSH
21926: LD_INT 1
21928: ARRAY
21929: PPUSH
21930: CALL_OW 250
21934: PPUSH
21935: LD_VAR 0 15
21939: PUSH
21940: LD_INT 1
21942: ARRAY
21943: PPUSH
21944: CALL_OW 254
21948: PPUSH
21949: LD_INT 5
21951: PPUSH
21952: CALL_OW 272
21956: PUSH
21957: LD_VAR 0 15
21961: PUSH
21962: LD_INT 1
21964: ARRAY
21965: PPUSH
21966: CALL_OW 251
21970: PPUSH
21971: LD_VAR 0 15
21975: PUSH
21976: LD_INT 1
21978: ARRAY
21979: PPUSH
21980: CALL_OW 254
21984: PPUSH
21985: LD_INT 5
21987: PPUSH
21988: CALL_OW 273
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21997: LD_VAR 0 14
22001: PUSH
22002: LD_INT 1
22004: ARRAY
22005: PPUSH
22006: LD_VAR 0 14
22010: PUSH
22011: LD_INT 2
22013: ARRAY
22014: PPUSH
22015: CALL_OW 488
22019: IFFALSE 22050
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22021: LD_VAR 0 11
22025: PPUSH
22026: LD_VAR 0 14
22030: PUSH
22031: LD_INT 1
22033: ARRAY
22034: PPUSH
22035: LD_VAR 0 14
22039: PUSH
22040: LD_INT 2
22042: ARRAY
22043: PPUSH
22044: CALL_OW 111
// continue ;
22048: GO 21681
// end ; end ; r := GetDir ( tmp ) ;
22050: LD_ADDR_VAR 0 13
22054: PUSH
22055: LD_VAR 0 11
22059: PPUSH
22060: CALL_OW 254
22064: ST_TO_ADDR
// if r = 5 then
22065: LD_VAR 0 13
22069: PUSH
22070: LD_INT 5
22072: EQUAL
22073: IFFALSE 22083
// r := 0 ;
22075: LD_ADDR_VAR 0 13
22079: PUSH
22080: LD_INT 0
22082: ST_TO_ADDR
// for j = r to 5 do
22083: LD_ADDR_VAR 0 8
22087: PUSH
22088: DOUBLE
22089: LD_VAR 0 13
22093: DEC
22094: ST_TO_ADDR
22095: LD_INT 5
22097: PUSH
22098: FOR_TO
22099: IFFALSE 22213
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22101: LD_ADDR_VAR 0 9
22105: PUSH
22106: LD_VAR 0 11
22110: PPUSH
22111: CALL_OW 250
22115: PPUSH
22116: LD_VAR 0 8
22120: PPUSH
22121: LD_INT 2
22123: PPUSH
22124: CALL_OW 272
22128: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22129: LD_ADDR_VAR 0 10
22133: PUSH
22134: LD_VAR 0 11
22138: PPUSH
22139: CALL_OW 251
22143: PPUSH
22144: LD_VAR 0 8
22148: PPUSH
22149: LD_INT 2
22151: PPUSH
22152: CALL_OW 273
22156: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22157: LD_VAR 0 9
22161: PPUSH
22162: LD_VAR 0 10
22166: PPUSH
22167: CALL_OW 488
22171: PUSH
22172: LD_VAR 0 9
22176: PPUSH
22177: LD_VAR 0 10
22181: PPUSH
22182: CALL_OW 428
22186: NOT
22187: AND
22188: IFFALSE 22211
// begin ComMoveXY ( tmp , _x , _y ) ;
22190: LD_VAR 0 11
22194: PPUSH
22195: LD_VAR 0 9
22199: PPUSH
22200: LD_VAR 0 10
22204: PPUSH
22205: CALL_OW 111
// break ;
22209: GO 22213
// end ; end ;
22211: GO 22098
22213: POP
22214: POP
// end ;
22215: GO 21681
22217: POP
22218: POP
// end ;
22219: LD_VAR 0 6
22223: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22224: LD_INT 0
22226: PPUSH
22227: PPUSH
22228: PPUSH
22229: PPUSH
22230: PPUSH
22231: PPUSH
22232: PPUSH
22233: PPUSH
22234: PPUSH
22235: PPUSH
// result := false ;
22236: LD_ADDR_VAR 0 6
22240: PUSH
22241: LD_INT 0
22243: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22244: LD_VAR 0 1
22248: NOT
22249: PUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: CALL_OW 266
22259: PUSH
22260: LD_INT 0
22262: PUSH
22263: LD_INT 1
22265: PUSH
22266: EMPTY
22267: LIST
22268: LIST
22269: IN
22270: NOT
22271: OR
22272: PUSH
22273: LD_VAR 0 2
22277: NOT
22278: OR
22279: PUSH
22280: LD_VAR 0 5
22284: PUSH
22285: LD_INT 0
22287: PUSH
22288: LD_INT 1
22290: PUSH
22291: LD_INT 2
22293: PUSH
22294: LD_INT 3
22296: PUSH
22297: LD_INT 4
22299: PUSH
22300: LD_INT 5
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: LIST
22308: LIST
22309: LIST
22310: IN
22311: NOT
22312: OR
22313: PUSH
22314: LD_VAR 0 3
22318: PPUSH
22319: LD_VAR 0 4
22323: PPUSH
22324: CALL_OW 488
22328: NOT
22329: OR
22330: IFFALSE 22334
// exit ;
22332: GO 23051
// pom := GetBase ( depot ) ;
22334: LD_ADDR_VAR 0 10
22338: PUSH
22339: LD_VAR 0 1
22343: PPUSH
22344: CALL_OW 274
22348: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22349: LD_ADDR_VAR 0 11
22353: PUSH
22354: LD_VAR 0 2
22358: PPUSH
22359: LD_VAR 0 1
22363: PPUSH
22364: CALL_OW 248
22368: PPUSH
22369: CALL_OW 450
22373: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22374: LD_VAR 0 10
22378: PPUSH
22379: LD_INT 1
22381: PPUSH
22382: CALL_OW 275
22386: PUSH
22387: LD_VAR 0 11
22391: PUSH
22392: LD_INT 1
22394: ARRAY
22395: GREATEREQUAL
22396: PUSH
22397: LD_VAR 0 10
22401: PPUSH
22402: LD_INT 2
22404: PPUSH
22405: CALL_OW 275
22409: PUSH
22410: LD_VAR 0 11
22414: PUSH
22415: LD_INT 2
22417: ARRAY
22418: GREATEREQUAL
22419: AND
22420: PUSH
22421: LD_VAR 0 10
22425: PPUSH
22426: LD_INT 3
22428: PPUSH
22429: CALL_OW 275
22433: PUSH
22434: LD_VAR 0 11
22438: PUSH
22439: LD_INT 3
22441: ARRAY
22442: GREATEREQUAL
22443: AND
22444: NOT
22445: IFFALSE 22449
// exit ;
22447: GO 23051
// if GetBType ( depot ) = b_depot then
22449: LD_VAR 0 1
22453: PPUSH
22454: CALL_OW 266
22458: PUSH
22459: LD_INT 0
22461: EQUAL
22462: IFFALSE 22474
// dist := 28 else
22464: LD_ADDR_VAR 0 14
22468: PUSH
22469: LD_INT 28
22471: ST_TO_ADDR
22472: GO 22482
// dist := 36 ;
22474: LD_ADDR_VAR 0 14
22478: PUSH
22479: LD_INT 36
22481: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22482: LD_VAR 0 1
22486: PPUSH
22487: LD_VAR 0 3
22491: PPUSH
22492: LD_VAR 0 4
22496: PPUSH
22497: CALL_OW 297
22501: PUSH
22502: LD_VAR 0 14
22506: GREATER
22507: IFFALSE 22511
// exit ;
22509: GO 23051
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22511: LD_ADDR_VAR 0 12
22515: PUSH
22516: LD_VAR 0 2
22520: PPUSH
22521: LD_VAR 0 3
22525: PPUSH
22526: LD_VAR 0 4
22530: PPUSH
22531: LD_VAR 0 5
22535: PPUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: CALL_OW 248
22545: PPUSH
22546: LD_INT 0
22548: PPUSH
22549: CALL 23056 0 6
22553: ST_TO_ADDR
// if not hexes then
22554: LD_VAR 0 12
22558: NOT
22559: IFFALSE 22563
// exit ;
22561: GO 23051
// hex := GetHexInfo ( x , y ) ;
22563: LD_ADDR_VAR 0 15
22567: PUSH
22568: LD_VAR 0 3
22572: PPUSH
22573: LD_VAR 0 4
22577: PPUSH
22578: CALL_OW 546
22582: ST_TO_ADDR
// if hex [ 1 ] then
22583: LD_VAR 0 15
22587: PUSH
22588: LD_INT 1
22590: ARRAY
22591: IFFALSE 22595
// exit ;
22593: GO 23051
// height := hex [ 2 ] ;
22595: LD_ADDR_VAR 0 13
22599: PUSH
22600: LD_VAR 0 15
22604: PUSH
22605: LD_INT 2
22607: ARRAY
22608: ST_TO_ADDR
// for i = 1 to hexes do
22609: LD_ADDR_VAR 0 7
22613: PUSH
22614: DOUBLE
22615: LD_INT 1
22617: DEC
22618: ST_TO_ADDR
22619: LD_VAR 0 12
22623: PUSH
22624: FOR_TO
22625: IFFALSE 22955
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22627: LD_VAR 0 12
22631: PUSH
22632: LD_VAR 0 7
22636: ARRAY
22637: PUSH
22638: LD_INT 1
22640: ARRAY
22641: PPUSH
22642: LD_VAR 0 12
22646: PUSH
22647: LD_VAR 0 7
22651: ARRAY
22652: PUSH
22653: LD_INT 2
22655: ARRAY
22656: PPUSH
22657: CALL_OW 488
22661: NOT
22662: PUSH
22663: LD_VAR 0 12
22667: PUSH
22668: LD_VAR 0 7
22672: ARRAY
22673: PUSH
22674: LD_INT 1
22676: ARRAY
22677: PPUSH
22678: LD_VAR 0 12
22682: PUSH
22683: LD_VAR 0 7
22687: ARRAY
22688: PUSH
22689: LD_INT 2
22691: ARRAY
22692: PPUSH
22693: CALL_OW 428
22697: PUSH
22698: LD_INT 0
22700: GREATER
22701: OR
22702: PUSH
22703: LD_VAR 0 12
22707: PUSH
22708: LD_VAR 0 7
22712: ARRAY
22713: PUSH
22714: LD_INT 1
22716: ARRAY
22717: PPUSH
22718: LD_VAR 0 12
22722: PUSH
22723: LD_VAR 0 7
22727: ARRAY
22728: PUSH
22729: LD_INT 2
22731: ARRAY
22732: PPUSH
22733: CALL_OW 351
22737: OR
22738: IFFALSE 22744
// exit ;
22740: POP
22741: POP
22742: GO 23051
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22744: LD_ADDR_VAR 0 8
22748: PUSH
22749: LD_VAR 0 12
22753: PUSH
22754: LD_VAR 0 7
22758: ARRAY
22759: PUSH
22760: LD_INT 1
22762: ARRAY
22763: PPUSH
22764: LD_VAR 0 12
22768: PUSH
22769: LD_VAR 0 7
22773: ARRAY
22774: PUSH
22775: LD_INT 2
22777: ARRAY
22778: PPUSH
22779: CALL_OW 546
22783: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22784: LD_VAR 0 8
22788: PUSH
22789: LD_INT 1
22791: ARRAY
22792: PUSH
22793: LD_VAR 0 8
22797: PUSH
22798: LD_INT 2
22800: ARRAY
22801: PUSH
22802: LD_VAR 0 13
22806: PUSH
22807: LD_INT 2
22809: PLUS
22810: GREATER
22811: OR
22812: PUSH
22813: LD_VAR 0 8
22817: PUSH
22818: LD_INT 2
22820: ARRAY
22821: PUSH
22822: LD_VAR 0 13
22826: PUSH
22827: LD_INT 2
22829: MINUS
22830: LESS
22831: OR
22832: PUSH
22833: LD_VAR 0 8
22837: PUSH
22838: LD_INT 3
22840: ARRAY
22841: PUSH
22842: LD_INT 0
22844: PUSH
22845: LD_INT 8
22847: PUSH
22848: LD_INT 9
22850: PUSH
22851: LD_INT 10
22853: PUSH
22854: LD_INT 11
22856: PUSH
22857: LD_INT 12
22859: PUSH
22860: LD_INT 13
22862: PUSH
22863: LD_INT 16
22865: PUSH
22866: LD_INT 17
22868: PUSH
22869: LD_INT 18
22871: PUSH
22872: LD_INT 19
22874: PUSH
22875: LD_INT 20
22877: PUSH
22878: LD_INT 21
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: LIST
22885: LIST
22886: LIST
22887: LIST
22888: LIST
22889: LIST
22890: LIST
22891: LIST
22892: LIST
22893: LIST
22894: LIST
22895: IN
22896: NOT
22897: OR
22898: PUSH
22899: LD_VAR 0 8
22903: PUSH
22904: LD_INT 5
22906: ARRAY
22907: NOT
22908: OR
22909: PUSH
22910: LD_VAR 0 8
22914: PUSH
22915: LD_INT 6
22917: ARRAY
22918: PUSH
22919: LD_INT 1
22921: PUSH
22922: LD_INT 2
22924: PUSH
22925: LD_INT 7
22927: PUSH
22928: LD_INT 9
22930: PUSH
22931: LD_INT 10
22933: PUSH
22934: LD_INT 11
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: LIST
22941: LIST
22942: LIST
22943: LIST
22944: IN
22945: NOT
22946: OR
22947: IFFALSE 22953
// exit ;
22949: POP
22950: POP
22951: GO 23051
// end ;
22953: GO 22624
22955: POP
22956: POP
// side := GetSide ( depot ) ;
22957: LD_ADDR_VAR 0 9
22961: PUSH
22962: LD_VAR 0 1
22966: PPUSH
22967: CALL_OW 255
22971: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22972: LD_VAR 0 9
22976: PPUSH
22977: LD_VAR 0 3
22981: PPUSH
22982: LD_VAR 0 4
22986: PPUSH
22987: LD_INT 20
22989: PPUSH
22990: CALL 15693 0 4
22994: PUSH
22995: LD_INT 4
22997: ARRAY
22998: IFFALSE 23002
// exit ;
23000: GO 23051
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23002: LD_VAR 0 2
23006: PUSH
23007: LD_INT 29
23009: PUSH
23010: LD_INT 30
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: IN
23017: PUSH
23018: LD_VAR 0 3
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 9
23032: PPUSH
23033: CALL_OW 440
23037: NOT
23038: AND
23039: IFFALSE 23043
// exit ;
23041: GO 23051
// result := true ;
23043: LD_ADDR_VAR 0 6
23047: PUSH
23048: LD_INT 1
23050: ST_TO_ADDR
// end ;
23051: LD_VAR 0 6
23055: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23056: LD_INT 0
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
23065: PPUSH
23066: PPUSH
23067: PPUSH
23068: PPUSH
23069: PPUSH
23070: PPUSH
23071: PPUSH
23072: PPUSH
23073: PPUSH
23074: PPUSH
23075: PPUSH
23076: PPUSH
23077: PPUSH
23078: PPUSH
23079: PPUSH
23080: PPUSH
23081: PPUSH
23082: PPUSH
23083: PPUSH
23084: PPUSH
23085: PPUSH
23086: PPUSH
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
23104: PPUSH
23105: PPUSH
23106: PPUSH
23107: PPUSH
23108: PPUSH
23109: PPUSH
23110: PPUSH
23111: PPUSH
23112: PPUSH
23113: PPUSH
23114: PPUSH
23115: PPUSH
// result = [ ] ;
23116: LD_ADDR_VAR 0 7
23120: PUSH
23121: EMPTY
23122: ST_TO_ADDR
// temp_list = [ ] ;
23123: LD_ADDR_VAR 0 9
23127: PUSH
23128: EMPTY
23129: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23130: LD_VAR 0 4
23134: PUSH
23135: LD_INT 0
23137: PUSH
23138: LD_INT 1
23140: PUSH
23141: LD_INT 2
23143: PUSH
23144: LD_INT 3
23146: PUSH
23147: LD_INT 4
23149: PUSH
23150: LD_INT 5
23152: PUSH
23153: EMPTY
23154: LIST
23155: LIST
23156: LIST
23157: LIST
23158: LIST
23159: LIST
23160: IN
23161: NOT
23162: PUSH
23163: LD_VAR 0 1
23167: PUSH
23168: LD_INT 0
23170: PUSH
23171: LD_INT 1
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: IN
23178: PUSH
23179: LD_VAR 0 5
23183: PUSH
23184: LD_INT 1
23186: PUSH
23187: LD_INT 2
23189: PUSH
23190: LD_INT 3
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: LIST
23197: IN
23198: NOT
23199: AND
23200: OR
23201: IFFALSE 23205
// exit ;
23203: GO 41596
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23205: LD_VAR 0 1
23209: PUSH
23210: LD_INT 6
23212: PUSH
23213: LD_INT 7
23215: PUSH
23216: LD_INT 8
23218: PUSH
23219: LD_INT 13
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: LD_INT 15
23227: PUSH
23228: LD_INT 11
23230: PUSH
23231: LD_INT 14
23233: PUSH
23234: LD_INT 10
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: LIST
23241: LIST
23242: LIST
23243: LIST
23244: LIST
23245: LIST
23246: LIST
23247: IN
23248: IFFALSE 23258
// btype = b_lab ;
23250: LD_ADDR_VAR 0 1
23254: PUSH
23255: LD_INT 6
23257: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23258: LD_VAR 0 6
23262: PUSH
23263: LD_INT 0
23265: PUSH
23266: LD_INT 1
23268: PUSH
23269: LD_INT 2
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: NOT
23278: PUSH
23279: LD_VAR 0 1
23283: PUSH
23284: LD_INT 0
23286: PUSH
23287: LD_INT 1
23289: PUSH
23290: LD_INT 2
23292: PUSH
23293: LD_INT 3
23295: PUSH
23296: LD_INT 6
23298: PUSH
23299: LD_INT 36
23301: PUSH
23302: LD_INT 4
23304: PUSH
23305: LD_INT 5
23307: PUSH
23308: LD_INT 31
23310: PUSH
23311: LD_INT 32
23313: PUSH
23314: LD_INT 33
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: IN
23330: NOT
23331: PUSH
23332: LD_VAR 0 6
23336: PUSH
23337: LD_INT 1
23339: EQUAL
23340: AND
23341: OR
23342: PUSH
23343: LD_VAR 0 1
23347: PUSH
23348: LD_INT 2
23350: PUSH
23351: LD_INT 3
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: IN
23358: NOT
23359: PUSH
23360: LD_VAR 0 6
23364: PUSH
23365: LD_INT 2
23367: EQUAL
23368: AND
23369: OR
23370: IFFALSE 23380
// mode = 0 ;
23372: LD_ADDR_VAR 0 6
23376: PUSH
23377: LD_INT 0
23379: ST_TO_ADDR
// case mode of 0 :
23380: LD_VAR 0 6
23384: PUSH
23385: LD_INT 0
23387: DOUBLE
23388: EQUAL
23389: IFTRUE 23393
23391: GO 34846
23393: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23394: LD_ADDR_VAR 0 11
23398: PUSH
23399: LD_INT 0
23401: PUSH
23402: LD_INT 0
23404: PUSH
23405: EMPTY
23406: LIST
23407: LIST
23408: PUSH
23409: LD_INT 0
23411: PUSH
23412: LD_INT 1
23414: NEG
23415: PUSH
23416: EMPTY
23417: LIST
23418: LIST
23419: PUSH
23420: LD_INT 1
23422: PUSH
23423: LD_INT 0
23425: PUSH
23426: EMPTY
23427: LIST
23428: LIST
23429: PUSH
23430: LD_INT 1
23432: PUSH
23433: LD_INT 1
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: PUSH
23440: LD_INT 0
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 1
23452: NEG
23453: PUSH
23454: LD_INT 0
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PUSH
23461: LD_INT 1
23463: NEG
23464: PUSH
23465: LD_INT 1
23467: NEG
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: PUSH
23473: LD_INT 1
23475: NEG
23476: PUSH
23477: LD_INT 2
23479: NEG
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: PUSH
23485: LD_INT 0
23487: PUSH
23488: LD_INT 2
23490: NEG
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PUSH
23496: LD_INT 1
23498: PUSH
23499: LD_INT 1
23501: NEG
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: PUSH
23507: LD_INT 1
23509: PUSH
23510: LD_INT 2
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: LD_INT 0
23519: PUSH
23520: LD_INT 2
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PUSH
23527: LD_INT 1
23529: NEG
23530: PUSH
23531: LD_INT 1
23533: PUSH
23534: EMPTY
23535: LIST
23536: LIST
23537: PUSH
23538: LD_INT 1
23540: PUSH
23541: LD_INT 3
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: PUSH
23548: LD_INT 0
23550: PUSH
23551: LD_INT 3
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: PUSH
23558: LD_INT 1
23560: NEG
23561: PUSH
23562: LD_INT 2
23564: PUSH
23565: EMPTY
23566: LIST
23567: LIST
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23587: LD_ADDR_VAR 0 12
23591: PUSH
23592: LD_INT 0
23594: PUSH
23595: LD_INT 0
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: PUSH
23602: LD_INT 0
23604: PUSH
23605: LD_INT 1
23607: NEG
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: PUSH
23613: LD_INT 1
23615: PUSH
23616: LD_INT 0
23618: PUSH
23619: EMPTY
23620: LIST
23621: LIST
23622: PUSH
23623: LD_INT 1
23625: PUSH
23626: LD_INT 1
23628: PUSH
23629: EMPTY
23630: LIST
23631: LIST
23632: PUSH
23633: LD_INT 0
23635: PUSH
23636: LD_INT 1
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: PUSH
23643: LD_INT 1
23645: NEG
23646: PUSH
23647: LD_INT 0
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 1
23656: NEG
23657: PUSH
23658: LD_INT 1
23660: NEG
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: LD_INT 1
23668: PUSH
23669: LD_INT 1
23671: NEG
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: PUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 0
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: PUSH
23687: LD_INT 2
23689: PUSH
23690: LD_INT 1
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: PUSH
23697: LD_INT 1
23699: NEG
23700: PUSH
23701: LD_INT 1
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: PUSH
23708: LD_INT 2
23710: NEG
23711: PUSH
23712: LD_INT 0
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 2
23721: NEG
23722: PUSH
23723: LD_INT 1
23725: NEG
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: PUSH
23731: LD_INT 2
23733: NEG
23734: PUSH
23735: LD_INT 1
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: LD_INT 3
23744: NEG
23745: PUSH
23746: LD_INT 0
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 3
23755: NEG
23756: PUSH
23757: LD_INT 1
23759: NEG
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23783: LD_ADDR_VAR 0 13
23787: PUSH
23788: LD_INT 0
23790: PUSH
23791: LD_INT 0
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 0
23800: PUSH
23801: LD_INT 1
23803: NEG
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: LD_INT 1
23811: PUSH
23812: LD_INT 0
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: PUSH
23819: LD_INT 1
23821: PUSH
23822: LD_INT 1
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 0
23831: PUSH
23832: LD_INT 1
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 1
23841: NEG
23842: PUSH
23843: LD_INT 0
23845: PUSH
23846: EMPTY
23847: LIST
23848: LIST
23849: PUSH
23850: LD_INT 1
23852: NEG
23853: PUSH
23854: LD_INT 1
23856: NEG
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 1
23864: NEG
23865: PUSH
23866: LD_INT 2
23868: NEG
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: PUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 1
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: PUSH
23884: LD_INT 2
23886: PUSH
23887: LD_INT 2
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: PUSH
23894: LD_INT 1
23896: PUSH
23897: LD_INT 2
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PUSH
23904: LD_INT 2
23906: NEG
23907: PUSH
23908: LD_INT 1
23910: NEG
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: PUSH
23916: LD_INT 2
23918: NEG
23919: PUSH
23920: LD_INT 2
23922: NEG
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 2
23930: NEG
23931: PUSH
23932: LD_INT 3
23934: NEG
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: PUSH
23940: LD_INT 3
23942: NEG
23943: PUSH
23944: LD_INT 2
23946: NEG
23947: PUSH
23948: EMPTY
23949: LIST
23950: LIST
23951: PUSH
23952: LD_INT 3
23954: NEG
23955: PUSH
23956: LD_INT 3
23958: NEG
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: LIST
23974: LIST
23975: LIST
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: LIST
23981: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23982: LD_ADDR_VAR 0 14
23986: PUSH
23987: LD_INT 0
23989: PUSH
23990: LD_INT 0
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: LD_INT 0
23999: PUSH
24000: LD_INT 1
24002: NEG
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: PUSH
24008: LD_INT 1
24010: PUSH
24011: LD_INT 0
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: PUSH
24018: LD_INT 1
24020: PUSH
24021: LD_INT 1
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: PUSH
24028: LD_INT 0
24030: PUSH
24031: LD_INT 1
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: PUSH
24038: LD_INT 1
24040: NEG
24041: PUSH
24042: LD_INT 0
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PUSH
24049: LD_INT 1
24051: NEG
24052: PUSH
24053: LD_INT 1
24055: NEG
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 1
24063: NEG
24064: PUSH
24065: LD_INT 2
24067: NEG
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: PUSH
24073: LD_INT 0
24075: PUSH
24076: LD_INT 2
24078: NEG
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 1
24086: PUSH
24087: LD_INT 1
24089: NEG
24090: PUSH
24091: EMPTY
24092: LIST
24093: LIST
24094: PUSH
24095: LD_INT 1
24097: PUSH
24098: LD_INT 2
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PUSH
24105: LD_INT 0
24107: PUSH
24108: LD_INT 2
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: PUSH
24115: LD_INT 1
24117: NEG
24118: PUSH
24119: LD_INT 1
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: LD_INT 1
24128: NEG
24129: PUSH
24130: LD_INT 3
24132: NEG
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PUSH
24138: LD_INT 0
24140: PUSH
24141: LD_INT 3
24143: NEG
24144: PUSH
24145: EMPTY
24146: LIST
24147: LIST
24148: PUSH
24149: LD_INT 1
24151: PUSH
24152: LD_INT 2
24154: NEG
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: LIST
24173: LIST
24174: LIST
24175: LIST
24176: LIST
24177: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24178: LD_ADDR_VAR 0 15
24182: PUSH
24183: LD_INT 0
24185: PUSH
24186: LD_INT 0
24188: PUSH
24189: EMPTY
24190: LIST
24191: LIST
24192: PUSH
24193: LD_INT 0
24195: PUSH
24196: LD_INT 1
24198: NEG
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 1
24206: PUSH
24207: LD_INT 0
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: LD_INT 1
24216: PUSH
24217: LD_INT 1
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: PUSH
24224: LD_INT 0
24226: PUSH
24227: LD_INT 1
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: PUSH
24234: LD_INT 1
24236: NEG
24237: PUSH
24238: LD_INT 0
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PUSH
24245: LD_INT 1
24247: NEG
24248: PUSH
24249: LD_INT 1
24251: NEG
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PUSH
24257: LD_INT 1
24259: PUSH
24260: LD_INT 1
24262: NEG
24263: PUSH
24264: EMPTY
24265: LIST
24266: LIST
24267: PUSH
24268: LD_INT 2
24270: PUSH
24271: LD_INT 0
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PUSH
24278: LD_INT 2
24280: PUSH
24281: LD_INT 1
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 1
24290: NEG
24291: PUSH
24292: LD_INT 1
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: PUSH
24299: LD_INT 2
24301: NEG
24302: PUSH
24303: LD_INT 0
24305: PUSH
24306: EMPTY
24307: LIST
24308: LIST
24309: PUSH
24310: LD_INT 2
24312: NEG
24313: PUSH
24314: LD_INT 1
24316: NEG
24317: PUSH
24318: EMPTY
24319: LIST
24320: LIST
24321: PUSH
24322: LD_INT 2
24324: PUSH
24325: LD_INT 1
24327: NEG
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: PUSH
24333: LD_INT 3
24335: PUSH
24336: LD_INT 0
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: PUSH
24343: LD_INT 3
24345: PUSH
24346: LD_INT 1
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24371: LD_ADDR_VAR 0 16
24375: PUSH
24376: LD_INT 0
24378: PUSH
24379: LD_INT 0
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PUSH
24386: LD_INT 0
24388: PUSH
24389: LD_INT 1
24391: NEG
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: PUSH
24397: LD_INT 1
24399: PUSH
24400: LD_INT 0
24402: PUSH
24403: EMPTY
24404: LIST
24405: LIST
24406: PUSH
24407: LD_INT 1
24409: PUSH
24410: LD_INT 1
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PUSH
24417: LD_INT 0
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_INT 1
24429: NEG
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 1
24440: NEG
24441: PUSH
24442: LD_INT 1
24444: NEG
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: LD_INT 1
24452: NEG
24453: PUSH
24454: LD_INT 2
24456: NEG
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: PUSH
24462: LD_INT 2
24464: PUSH
24465: LD_INT 1
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: PUSH
24472: LD_INT 2
24474: PUSH
24475: LD_INT 2
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 1
24484: PUSH
24485: LD_INT 2
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: LD_INT 2
24494: NEG
24495: PUSH
24496: LD_INT 1
24498: NEG
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 2
24506: NEG
24507: PUSH
24508: LD_INT 2
24510: NEG
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PUSH
24516: LD_INT 3
24518: PUSH
24519: LD_INT 2
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 3
24528: PUSH
24529: LD_INT 3
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: LD_INT 2
24538: PUSH
24539: LD_INT 3
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: LIST
24557: LIST
24558: LIST
24559: LIST
24560: LIST
24561: LIST
24562: LIST
24563: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24564: LD_ADDR_VAR 0 17
24568: PUSH
24569: LD_INT 0
24571: PUSH
24572: LD_INT 0
24574: PUSH
24575: EMPTY
24576: LIST
24577: LIST
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: LD_INT 1
24584: NEG
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PUSH
24590: LD_INT 1
24592: PUSH
24593: LD_INT 0
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 1
24602: PUSH
24603: LD_INT 1
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 0
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 1
24622: NEG
24623: PUSH
24624: LD_INT 0
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 1
24633: NEG
24634: PUSH
24635: LD_INT 1
24637: NEG
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 1
24645: NEG
24646: PUSH
24647: LD_INT 2
24649: NEG
24650: PUSH
24651: EMPTY
24652: LIST
24653: LIST
24654: PUSH
24655: LD_INT 0
24657: PUSH
24658: LD_INT 2
24660: NEG
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: PUSH
24666: LD_INT 1
24668: PUSH
24669: LD_INT 1
24671: NEG
24672: PUSH
24673: EMPTY
24674: LIST
24675: LIST
24676: PUSH
24677: LD_INT 2
24679: PUSH
24680: LD_INT 0
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 2
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 2
24699: PUSH
24700: LD_INT 2
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: LD_INT 1
24709: PUSH
24710: LD_INT 2
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 0
24719: PUSH
24720: LD_INT 2
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: LD_INT 1
24729: NEG
24730: PUSH
24731: LD_INT 1
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 2
24740: NEG
24741: PUSH
24742: LD_INT 0
24744: PUSH
24745: EMPTY
24746: LIST
24747: LIST
24748: PUSH
24749: LD_INT 2
24751: NEG
24752: PUSH
24753: LD_INT 1
24755: NEG
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 2
24763: NEG
24764: PUSH
24765: LD_INT 2
24767: NEG
24768: PUSH
24769: EMPTY
24770: LIST
24771: LIST
24772: PUSH
24773: EMPTY
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24794: LD_ADDR_VAR 0 18
24798: PUSH
24799: LD_INT 0
24801: PUSH
24802: LD_INT 0
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 0
24811: PUSH
24812: LD_INT 1
24814: NEG
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: LD_INT 1
24822: PUSH
24823: LD_INT 0
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 1
24832: PUSH
24833: LD_INT 1
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 0
24842: PUSH
24843: LD_INT 1
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: LD_INT 1
24852: NEG
24853: PUSH
24854: LD_INT 0
24856: PUSH
24857: EMPTY
24858: LIST
24859: LIST
24860: PUSH
24861: LD_INT 1
24863: NEG
24864: PUSH
24865: LD_INT 1
24867: NEG
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 1
24875: NEG
24876: PUSH
24877: LD_INT 2
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 0
24887: PUSH
24888: LD_INT 2
24890: NEG
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: LD_INT 1
24898: PUSH
24899: LD_INT 1
24901: NEG
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: PUSH
24907: LD_INT 2
24909: PUSH
24910: LD_INT 0
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: PUSH
24917: LD_INT 2
24919: PUSH
24920: LD_INT 1
24922: PUSH
24923: EMPTY
24924: LIST
24925: LIST
24926: PUSH
24927: LD_INT 2
24929: PUSH
24930: LD_INT 2
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: LD_INT 1
24939: PUSH
24940: LD_INT 2
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PUSH
24947: LD_INT 0
24949: PUSH
24950: LD_INT 2
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 1
24959: NEG
24960: PUSH
24961: LD_INT 1
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 2
24970: NEG
24971: PUSH
24972: LD_INT 0
24974: PUSH
24975: EMPTY
24976: LIST
24977: LIST
24978: PUSH
24979: LD_INT 2
24981: NEG
24982: PUSH
24983: LD_INT 1
24985: NEG
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 2
24993: NEG
24994: PUSH
24995: LD_INT 2
24997: NEG
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: EMPTY
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: LIST
25011: LIST
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: LIST
25019: LIST
25020: LIST
25021: LIST
25022: LIST
25023: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25024: LD_ADDR_VAR 0 19
25028: PUSH
25029: LD_INT 0
25031: PUSH
25032: LD_INT 0
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 0
25041: PUSH
25042: LD_INT 1
25044: NEG
25045: PUSH
25046: EMPTY
25047: LIST
25048: LIST
25049: PUSH
25050: LD_INT 1
25052: PUSH
25053: LD_INT 0
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: LD_INT 1
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 0
25072: PUSH
25073: LD_INT 1
25075: PUSH
25076: EMPTY
25077: LIST
25078: LIST
25079: PUSH
25080: LD_INT 1
25082: NEG
25083: PUSH
25084: LD_INT 0
25086: PUSH
25087: EMPTY
25088: LIST
25089: LIST
25090: PUSH
25091: LD_INT 1
25093: NEG
25094: PUSH
25095: LD_INT 1
25097: NEG
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 1
25105: NEG
25106: PUSH
25107: LD_INT 2
25109: NEG
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: PUSH
25115: LD_INT 0
25117: PUSH
25118: LD_INT 2
25120: NEG
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: LD_INT 1
25128: PUSH
25129: LD_INT 1
25131: NEG
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: LD_INT 2
25139: PUSH
25140: LD_INT 0
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: PUSH
25147: LD_INT 2
25149: PUSH
25150: LD_INT 1
25152: PUSH
25153: EMPTY
25154: LIST
25155: LIST
25156: PUSH
25157: LD_INT 2
25159: PUSH
25160: LD_INT 2
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PUSH
25167: LD_INT 1
25169: PUSH
25170: LD_INT 2
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 0
25179: PUSH
25180: LD_INT 2
25182: PUSH
25183: EMPTY
25184: LIST
25185: LIST
25186: PUSH
25187: LD_INT 1
25189: NEG
25190: PUSH
25191: LD_INT 1
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 2
25200: NEG
25201: PUSH
25202: LD_INT 0
25204: PUSH
25205: EMPTY
25206: LIST
25207: LIST
25208: PUSH
25209: LD_INT 2
25211: NEG
25212: PUSH
25213: LD_INT 1
25215: NEG
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: LD_INT 2
25223: NEG
25224: PUSH
25225: LD_INT 2
25227: NEG
25228: PUSH
25229: EMPTY
25230: LIST
25231: LIST
25232: PUSH
25233: EMPTY
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25254: LD_ADDR_VAR 0 20
25258: PUSH
25259: LD_INT 0
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: LD_INT 0
25271: PUSH
25272: LD_INT 1
25274: NEG
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 1
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 0
25302: PUSH
25303: LD_INT 1
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 1
25312: NEG
25313: PUSH
25314: LD_INT 0
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 1
25323: NEG
25324: PUSH
25325: LD_INT 1
25327: NEG
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: LD_INT 1
25335: NEG
25336: PUSH
25337: LD_INT 2
25339: NEG
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_INT 0
25347: PUSH
25348: LD_INT 2
25350: NEG
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 1
25358: PUSH
25359: LD_INT 1
25361: NEG
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 2
25369: PUSH
25370: LD_INT 0
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: PUSH
25377: LD_INT 2
25379: PUSH
25380: LD_INT 1
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: PUSH
25387: LD_INT 2
25389: PUSH
25390: LD_INT 2
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 1
25399: PUSH
25400: LD_INT 2
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 0
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 1
25419: NEG
25420: PUSH
25421: LD_INT 1
25423: PUSH
25424: EMPTY
25425: LIST
25426: LIST
25427: PUSH
25428: LD_INT 2
25430: NEG
25431: PUSH
25432: LD_INT 0
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 2
25441: NEG
25442: PUSH
25443: LD_INT 1
25445: NEG
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: PUSH
25451: LD_INT 2
25453: NEG
25454: PUSH
25455: LD_INT 2
25457: NEG
25458: PUSH
25459: EMPTY
25460: LIST
25461: LIST
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25484: LD_ADDR_VAR 0 21
25488: PUSH
25489: LD_INT 0
25491: PUSH
25492: LD_INT 0
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 0
25501: PUSH
25502: LD_INT 1
25504: NEG
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 1
25512: PUSH
25513: LD_INT 0
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 1
25522: PUSH
25523: LD_INT 1
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 0
25532: PUSH
25533: LD_INT 1
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: PUSH
25540: LD_INT 1
25542: NEG
25543: PUSH
25544: LD_INT 0
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: PUSH
25551: LD_INT 1
25553: NEG
25554: PUSH
25555: LD_INT 1
25557: NEG
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: PUSH
25563: LD_INT 1
25565: NEG
25566: PUSH
25567: LD_INT 2
25569: NEG
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 0
25577: PUSH
25578: LD_INT 2
25580: NEG
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: PUSH
25589: LD_INT 1
25591: NEG
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: PUSH
25600: LD_INT 0
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PUSH
25607: LD_INT 2
25609: PUSH
25610: LD_INT 1
25612: PUSH
25613: EMPTY
25614: LIST
25615: LIST
25616: PUSH
25617: LD_INT 2
25619: PUSH
25620: LD_INT 2
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: LD_INT 1
25629: PUSH
25630: LD_INT 2
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 2
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: PUSH
25647: LD_INT 1
25649: NEG
25650: PUSH
25651: LD_INT 1
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 2
25660: NEG
25661: PUSH
25662: LD_INT 0
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: LD_INT 2
25671: NEG
25672: PUSH
25673: LD_INT 1
25675: NEG
25676: PUSH
25677: EMPTY
25678: LIST
25679: LIST
25680: PUSH
25681: LD_INT 2
25683: NEG
25684: PUSH
25685: LD_INT 2
25687: NEG
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: EMPTY
25694: LIST
25695: LIST
25696: LIST
25697: LIST
25698: LIST
25699: LIST
25700: LIST
25701: LIST
25702: LIST
25703: LIST
25704: LIST
25705: LIST
25706: LIST
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25714: LD_ADDR_VAR 0 22
25718: PUSH
25719: LD_INT 0
25721: PUSH
25722: LD_INT 0
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 0
25731: PUSH
25732: LD_INT 1
25734: NEG
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: LD_INT 1
25742: PUSH
25743: LD_INT 0
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 1
25752: PUSH
25753: LD_INT 1
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 0
25762: PUSH
25763: LD_INT 1
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PUSH
25770: LD_INT 1
25772: NEG
25773: PUSH
25774: LD_INT 0
25776: PUSH
25777: EMPTY
25778: LIST
25779: LIST
25780: PUSH
25781: LD_INT 1
25783: NEG
25784: PUSH
25785: LD_INT 1
25787: NEG
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 1
25795: NEG
25796: PUSH
25797: LD_INT 2
25799: NEG
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: LD_INT 0
25807: PUSH
25808: LD_INT 2
25810: NEG
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 1
25818: PUSH
25819: LD_INT 1
25821: NEG
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 2
25829: PUSH
25830: LD_INT 0
25832: PUSH
25833: EMPTY
25834: LIST
25835: LIST
25836: PUSH
25837: LD_INT 2
25839: PUSH
25840: LD_INT 1
25842: PUSH
25843: EMPTY
25844: LIST
25845: LIST
25846: PUSH
25847: LD_INT 2
25849: PUSH
25850: LD_INT 2
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PUSH
25857: LD_INT 1
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: PUSH
25867: LD_INT 0
25869: PUSH
25870: LD_INT 2
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 1
25879: NEG
25880: PUSH
25881: LD_INT 1
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 2
25890: NEG
25891: PUSH
25892: LD_INT 0
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PUSH
25899: LD_INT 2
25901: NEG
25902: PUSH
25903: LD_INT 1
25905: NEG
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: PUSH
25911: LD_INT 2
25913: NEG
25914: PUSH
25915: LD_INT 2
25917: NEG
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: LIST
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25944: LD_ADDR_VAR 0 23
25948: PUSH
25949: LD_INT 0
25951: PUSH
25952: LD_INT 0
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: LD_INT 0
25961: PUSH
25962: LD_INT 1
25964: NEG
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: PUSH
25970: LD_INT 1
25972: PUSH
25973: LD_INT 0
25975: PUSH
25976: EMPTY
25977: LIST
25978: LIST
25979: PUSH
25980: LD_INT 1
25982: PUSH
25983: LD_INT 1
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: PUSH
25990: LD_INT 0
25992: PUSH
25993: LD_INT 1
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 1
26002: NEG
26003: PUSH
26004: LD_INT 0
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: NEG
26014: PUSH
26015: LD_INT 1
26017: NEG
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 1
26025: NEG
26026: PUSH
26027: LD_INT 2
26029: NEG
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: PUSH
26035: LD_INT 0
26037: PUSH
26038: LD_INT 2
26040: NEG
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: PUSH
26049: LD_INT 1
26051: NEG
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 2
26059: PUSH
26060: LD_INT 0
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 2
26069: PUSH
26070: LD_INT 1
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: LD_INT 2
26079: PUSH
26080: LD_INT 2
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 2
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 0
26099: PUSH
26100: LD_INT 2
26102: PUSH
26103: EMPTY
26104: LIST
26105: LIST
26106: PUSH
26107: LD_INT 1
26109: NEG
26110: PUSH
26111: LD_INT 1
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 2
26120: NEG
26121: PUSH
26122: LD_INT 0
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 2
26131: NEG
26132: PUSH
26133: LD_INT 1
26135: NEG
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PUSH
26141: LD_INT 2
26143: NEG
26144: PUSH
26145: LD_INT 2
26147: NEG
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 2
26155: NEG
26156: PUSH
26157: LD_INT 3
26159: NEG
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_INT 1
26167: NEG
26168: PUSH
26169: LD_INT 3
26171: NEG
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 1
26179: PUSH
26180: LD_INT 2
26182: NEG
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: LD_INT 1
26193: NEG
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: LIST
26220: LIST
26221: LIST
26222: LIST
26223: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26224: LD_ADDR_VAR 0 24
26228: PUSH
26229: LD_INT 0
26231: PUSH
26232: LD_INT 0
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: PUSH
26239: LD_INT 0
26241: PUSH
26242: LD_INT 1
26244: NEG
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PUSH
26250: LD_INT 1
26252: PUSH
26253: LD_INT 0
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: LD_INT 1
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: LD_INT 0
26272: PUSH
26273: LD_INT 1
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 1
26282: NEG
26283: PUSH
26284: LD_INT 0
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: LD_INT 1
26297: NEG
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: PUSH
26303: LD_INT 1
26305: NEG
26306: PUSH
26307: LD_INT 2
26309: NEG
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 0
26317: PUSH
26318: LD_INT 2
26320: NEG
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PUSH
26326: LD_INT 1
26328: PUSH
26329: LD_INT 1
26331: NEG
26332: PUSH
26333: EMPTY
26334: LIST
26335: LIST
26336: PUSH
26337: LD_INT 2
26339: PUSH
26340: LD_INT 0
26342: PUSH
26343: EMPTY
26344: LIST
26345: LIST
26346: PUSH
26347: LD_INT 2
26349: PUSH
26350: LD_INT 1
26352: PUSH
26353: EMPTY
26354: LIST
26355: LIST
26356: PUSH
26357: LD_INT 2
26359: PUSH
26360: LD_INT 2
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 1
26369: PUSH
26370: LD_INT 2
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PUSH
26377: LD_INT 0
26379: PUSH
26380: LD_INT 2
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: PUSH
26387: LD_INT 1
26389: NEG
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 2
26400: NEG
26401: PUSH
26402: LD_INT 0
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 2
26411: NEG
26412: PUSH
26413: LD_INT 1
26415: NEG
26416: PUSH
26417: EMPTY
26418: LIST
26419: LIST
26420: PUSH
26421: LD_INT 2
26423: NEG
26424: PUSH
26425: LD_INT 2
26427: NEG
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 1
26435: PUSH
26436: LD_INT 2
26438: NEG
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 2
26446: PUSH
26447: LD_INT 1
26449: NEG
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PUSH
26455: LD_INT 3
26457: PUSH
26458: LD_INT 1
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 3
26467: PUSH
26468: LD_INT 2
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: LIST
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: LIST
26488: LIST
26489: LIST
26490: LIST
26491: LIST
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: LIST
26497: LIST
26498: LIST
26499: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26500: LD_ADDR_VAR 0 25
26504: PUSH
26505: LD_INT 0
26507: PUSH
26508: LD_INT 0
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 0
26517: PUSH
26518: LD_INT 1
26520: NEG
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 1
26528: PUSH
26529: LD_INT 0
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 1
26538: PUSH
26539: LD_INT 1
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: LD_INT 0
26548: PUSH
26549: LD_INT 1
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PUSH
26556: LD_INT 1
26558: NEG
26559: PUSH
26560: LD_INT 0
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 1
26569: NEG
26570: PUSH
26571: LD_INT 1
26573: NEG
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 1
26581: NEG
26582: PUSH
26583: LD_INT 2
26585: NEG
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 0
26593: PUSH
26594: LD_INT 2
26596: NEG
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PUSH
26602: LD_INT 1
26604: PUSH
26605: LD_INT 1
26607: NEG
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 2
26615: PUSH
26616: LD_INT 0
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 2
26625: PUSH
26626: LD_INT 1
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PUSH
26633: LD_INT 2
26635: PUSH
26636: LD_INT 2
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: LD_INT 2
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: LD_INT 0
26655: PUSH
26656: LD_INT 2
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: PUSH
26663: LD_INT 1
26665: NEG
26666: PUSH
26667: LD_INT 1
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: LD_INT 2
26676: NEG
26677: PUSH
26678: LD_INT 0
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 2
26687: NEG
26688: PUSH
26689: LD_INT 1
26691: NEG
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 2
26699: NEG
26700: PUSH
26701: LD_INT 2
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 3
26711: PUSH
26712: LD_INT 1
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 3
26721: PUSH
26722: LD_INT 2
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 2
26731: PUSH
26732: LD_INT 3
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: LD_INT 3
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: LIST
26753: LIST
26754: LIST
26755: LIST
26756: LIST
26757: LIST
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: LIST
26771: LIST
26772: LIST
26773: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26774: LD_ADDR_VAR 0 26
26778: PUSH
26779: LD_INT 0
26781: PUSH
26782: LD_INT 0
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 0
26791: PUSH
26792: LD_INT 1
26794: NEG
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 1
26802: PUSH
26803: LD_INT 0
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: PUSH
26810: LD_INT 1
26812: PUSH
26813: LD_INT 1
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PUSH
26820: LD_INT 0
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: PUSH
26830: LD_INT 1
26832: NEG
26833: PUSH
26834: LD_INT 0
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: PUSH
26841: LD_INT 1
26843: NEG
26844: PUSH
26845: LD_INT 1
26847: NEG
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 1
26855: NEG
26856: PUSH
26857: LD_INT 2
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 0
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 1
26878: PUSH
26879: LD_INT 1
26881: NEG
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 2
26889: PUSH
26890: LD_INT 0
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 2
26899: PUSH
26900: LD_INT 1
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 2
26909: PUSH
26910: LD_INT 2
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 1
26919: PUSH
26920: LD_INT 2
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 0
26929: PUSH
26930: LD_INT 2
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: PUSH
26937: LD_INT 1
26939: NEG
26940: PUSH
26941: LD_INT 1
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: PUSH
26948: LD_INT 2
26950: NEG
26951: PUSH
26952: LD_INT 0
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 2
26961: NEG
26962: PUSH
26963: LD_INT 1
26965: NEG
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 2
26973: NEG
26974: PUSH
26975: LD_INT 2
26977: NEG
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: PUSH
26983: LD_INT 2
26985: PUSH
26986: LD_INT 3
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PUSH
26993: LD_INT 1
26995: PUSH
26996: LD_INT 3
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 1
27005: NEG
27006: PUSH
27007: LD_INT 2
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: LD_INT 2
27016: NEG
27017: PUSH
27018: LD_INT 1
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: LIST
27038: LIST
27039: LIST
27040: LIST
27041: LIST
27042: LIST
27043: LIST
27044: LIST
27045: LIST
27046: LIST
27047: LIST
27048: LIST
27049: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27050: LD_ADDR_VAR 0 27
27054: PUSH
27055: LD_INT 0
27057: PUSH
27058: LD_INT 0
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 0
27067: PUSH
27068: LD_INT 1
27070: NEG
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 1
27078: PUSH
27079: LD_INT 0
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: PUSH
27086: LD_INT 1
27088: PUSH
27089: LD_INT 1
27091: PUSH
27092: EMPTY
27093: LIST
27094: LIST
27095: PUSH
27096: LD_INT 0
27098: PUSH
27099: LD_INT 1
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: NEG
27109: PUSH
27110: LD_INT 0
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: LD_INT 1
27119: NEG
27120: PUSH
27121: LD_INT 1
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 1
27131: NEG
27132: PUSH
27133: LD_INT 2
27135: NEG
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: LD_INT 2
27146: NEG
27147: PUSH
27148: EMPTY
27149: LIST
27150: LIST
27151: PUSH
27152: LD_INT 1
27154: PUSH
27155: LD_INT 1
27157: NEG
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: PUSH
27163: LD_INT 2
27165: PUSH
27166: LD_INT 0
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: LD_INT 2
27175: PUSH
27176: LD_INT 1
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: PUSH
27183: LD_INT 2
27185: PUSH
27186: LD_INT 2
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: PUSH
27193: LD_INT 1
27195: PUSH
27196: LD_INT 2
27198: PUSH
27199: EMPTY
27200: LIST
27201: LIST
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: LD_INT 2
27208: PUSH
27209: EMPTY
27210: LIST
27211: LIST
27212: PUSH
27213: LD_INT 1
27215: NEG
27216: PUSH
27217: LD_INT 1
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 2
27226: NEG
27227: PUSH
27228: LD_INT 0
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: NEG
27238: PUSH
27239: LD_INT 1
27241: NEG
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 2
27249: NEG
27250: PUSH
27251: LD_INT 2
27253: NEG
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: PUSH
27259: LD_INT 1
27261: NEG
27262: PUSH
27263: LD_INT 2
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PUSH
27270: LD_INT 2
27272: NEG
27273: PUSH
27274: LD_INT 1
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 3
27283: NEG
27284: PUSH
27285: LD_INT 1
27287: NEG
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: LD_INT 3
27295: NEG
27296: PUSH
27297: LD_INT 2
27299: NEG
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: LIST
27326: LIST
27327: LIST
27328: LIST
27329: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27330: LD_ADDR_VAR 0 28
27334: PUSH
27335: LD_INT 0
27337: PUSH
27338: LD_INT 0
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 0
27347: PUSH
27348: LD_INT 1
27350: NEG
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: LD_INT 1
27358: PUSH
27359: LD_INT 0
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 1
27368: PUSH
27369: LD_INT 1
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: PUSH
27376: LD_INT 0
27378: PUSH
27379: LD_INT 1
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 1
27388: NEG
27389: PUSH
27390: LD_INT 0
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 1
27399: NEG
27400: PUSH
27401: LD_INT 1
27403: NEG
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: NEG
27412: PUSH
27413: LD_INT 2
27415: NEG
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 0
27423: PUSH
27424: LD_INT 2
27426: NEG
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 1
27434: PUSH
27435: LD_INT 1
27437: NEG
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: PUSH
27443: LD_INT 2
27445: PUSH
27446: LD_INT 0
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_INT 2
27455: PUSH
27456: LD_INT 1
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: PUSH
27463: LD_INT 2
27465: PUSH
27466: LD_INT 2
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 1
27475: PUSH
27476: LD_INT 2
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: PUSH
27483: LD_INT 0
27485: PUSH
27486: LD_INT 2
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 1
27495: NEG
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: NEG
27507: PUSH
27508: LD_INT 0
27510: PUSH
27511: EMPTY
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 2
27517: NEG
27518: PUSH
27519: LD_INT 1
27521: NEG
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PUSH
27527: LD_INT 2
27529: NEG
27530: PUSH
27531: LD_INT 2
27533: NEG
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 2
27541: NEG
27542: PUSH
27543: LD_INT 3
27545: NEG
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PUSH
27551: LD_INT 1
27553: NEG
27554: PUSH
27555: LD_INT 3
27557: NEG
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 3
27565: NEG
27566: PUSH
27567: LD_INT 1
27569: NEG
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: LD_INT 3
27577: NEG
27578: PUSH
27579: LD_INT 2
27581: NEG
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27612: LD_ADDR_VAR 0 29
27616: PUSH
27617: LD_INT 0
27619: PUSH
27620: LD_INT 0
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: PUSH
27627: LD_INT 0
27629: PUSH
27630: LD_INT 1
27632: NEG
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: LD_INT 0
27643: PUSH
27644: EMPTY
27645: LIST
27646: LIST
27647: PUSH
27648: LD_INT 1
27650: PUSH
27651: LD_INT 1
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: PUSH
27658: LD_INT 0
27660: PUSH
27661: LD_INT 1
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 1
27670: NEG
27671: PUSH
27672: LD_INT 0
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 1
27681: NEG
27682: PUSH
27683: LD_INT 1
27685: NEG
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 1
27693: NEG
27694: PUSH
27695: LD_INT 2
27697: NEG
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 2
27708: NEG
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: LD_INT 1
27719: NEG
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: PUSH
27725: LD_INT 2
27727: PUSH
27728: LD_INT 0
27730: PUSH
27731: EMPTY
27732: LIST
27733: LIST
27734: PUSH
27735: LD_INT 2
27737: PUSH
27738: LD_INT 1
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: PUSH
27745: LD_INT 1
27747: PUSH
27748: LD_INT 2
27750: PUSH
27751: EMPTY
27752: LIST
27753: LIST
27754: PUSH
27755: LD_INT 0
27757: PUSH
27758: LD_INT 2
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: PUSH
27765: LD_INT 1
27767: NEG
27768: PUSH
27769: LD_INT 1
27771: PUSH
27772: EMPTY
27773: LIST
27774: LIST
27775: PUSH
27776: LD_INT 2
27778: NEG
27779: PUSH
27780: LD_INT 1
27782: NEG
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 2
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 3
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 2
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 3
27825: PUSH
27826: LD_INT 1
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: LD_INT 3
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: PUSH
27843: LD_INT 1
27845: NEG
27846: PUSH
27847: LD_INT 2
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 3
27856: NEG
27857: PUSH
27858: LD_INT 2
27860: NEG
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: LIST
27870: LIST
27871: LIST
27872: LIST
27873: LIST
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: LIST
27886: LIST
27887: LIST
27888: LIST
27889: LIST
27890: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27891: LD_ADDR_VAR 0 30
27895: PUSH
27896: LD_INT 0
27898: PUSH
27899: LD_INT 0
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 0
27908: PUSH
27909: LD_INT 1
27911: NEG
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 1
27919: PUSH
27920: LD_INT 0
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: PUSH
27930: LD_INT 1
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 0
27939: PUSH
27940: LD_INT 1
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: LD_INT 1
27949: NEG
27950: PUSH
27951: LD_INT 0
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 1
27960: NEG
27961: PUSH
27962: LD_INT 1
27964: NEG
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 1
27972: NEG
27973: PUSH
27974: LD_INT 2
27976: NEG
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: PUSH
27982: LD_INT 0
27984: PUSH
27985: LD_INT 2
27987: NEG
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 1
27995: PUSH
27996: LD_INT 1
27998: NEG
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 2
28006: PUSH
28007: LD_INT 0
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 2
28016: PUSH
28017: LD_INT 1
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 2
28026: PUSH
28027: LD_INT 2
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 1
28036: PUSH
28037: LD_INT 2
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 1
28046: NEG
28047: PUSH
28048: LD_INT 1
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PUSH
28055: LD_INT 2
28057: NEG
28058: PUSH
28059: LD_INT 0
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 2
28068: NEG
28069: PUSH
28070: LD_INT 1
28072: NEG
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 1
28080: NEG
28081: PUSH
28082: LD_INT 3
28084: NEG
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: LD_INT 2
28095: NEG
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 3
28103: PUSH
28104: LD_INT 2
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: LD_INT 2
28113: PUSH
28114: LD_INT 3
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: LD_INT 1
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 3
28134: NEG
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: LIST
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: LIST
28156: LIST
28157: LIST
28158: LIST
28159: LIST
28160: LIST
28161: LIST
28162: LIST
28163: LIST
28164: LIST
28165: LIST
28166: LIST
28167: LIST
28168: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28169: LD_ADDR_VAR 0 31
28173: PUSH
28174: LD_INT 0
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 0
28186: PUSH
28187: LD_INT 1
28189: NEG
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: PUSH
28195: LD_INT 1
28197: PUSH
28198: LD_INT 0
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PUSH
28205: LD_INT 1
28207: PUSH
28208: LD_INT 1
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 0
28217: PUSH
28218: LD_INT 1
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: PUSH
28225: LD_INT 1
28227: NEG
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 1
28238: NEG
28239: PUSH
28240: LD_INT 1
28242: NEG
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: NEG
28251: PUSH
28252: LD_INT 2
28254: NEG
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PUSH
28260: LD_INT 1
28262: PUSH
28263: LD_INT 1
28265: NEG
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 2
28273: PUSH
28274: LD_INT 0
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 2
28283: PUSH
28284: LD_INT 1
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 2
28293: PUSH
28294: LD_INT 2
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: LD_INT 1
28303: PUSH
28304: LD_INT 2
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 0
28313: PUSH
28314: LD_INT 2
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 1
28323: NEG
28324: PUSH
28325: LD_INT 1
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 2
28334: NEG
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 2
28346: NEG
28347: PUSH
28348: LD_INT 2
28350: NEG
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 2
28358: NEG
28359: PUSH
28360: LD_INT 3
28362: NEG
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PUSH
28368: LD_INT 2
28370: PUSH
28371: LD_INT 1
28373: NEG
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PUSH
28379: LD_INT 3
28381: PUSH
28382: LD_INT 1
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: PUSH
28389: LD_INT 1
28391: PUSH
28392: LD_INT 3
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 1
28401: NEG
28402: PUSH
28403: LD_INT 2
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: LD_INT 3
28412: NEG
28413: PUSH
28414: LD_INT 2
28416: NEG
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: LIST
28443: LIST
28444: LIST
28445: LIST
28446: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28447: LD_ADDR_VAR 0 32
28451: PUSH
28452: LD_INT 0
28454: PUSH
28455: LD_INT 0
28457: PUSH
28458: EMPTY
28459: LIST
28460: LIST
28461: PUSH
28462: LD_INT 0
28464: PUSH
28465: LD_INT 1
28467: NEG
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 1
28475: PUSH
28476: LD_INT 0
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: LD_INT 1
28485: PUSH
28486: LD_INT 1
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PUSH
28493: LD_INT 0
28495: PUSH
28496: LD_INT 1
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 1
28516: NEG
28517: PUSH
28518: LD_INT 1
28520: NEG
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 1
28528: NEG
28529: PUSH
28530: LD_INT 2
28532: NEG
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: LD_INT 2
28543: NEG
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: LD_INT 1
28554: NEG
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 2
28562: PUSH
28563: LD_INT 1
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 2
28572: PUSH
28573: LD_INT 2
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: PUSH
28583: LD_INT 2
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 0
28592: PUSH
28593: LD_INT 2
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 1
28602: NEG
28603: PUSH
28604: LD_INT 1
28606: PUSH
28607: EMPTY
28608: LIST
28609: LIST
28610: PUSH
28611: LD_INT 2
28613: NEG
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 2
28624: NEG
28625: PUSH
28626: LD_INT 1
28628: NEG
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 1
28636: NEG
28637: PUSH
28638: LD_INT 3
28640: NEG
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: LD_INT 2
28651: NEG
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 3
28659: PUSH
28660: LD_INT 2
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 2
28669: PUSH
28670: LD_INT 3
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 3
28690: NEG
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: LIST
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28725: LD_ADDR_VAR 0 33
28729: PUSH
28730: LD_INT 0
28732: PUSH
28733: LD_INT 0
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 0
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 1
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 1
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 0
28773: PUSH
28774: LD_INT 1
28776: PUSH
28777: EMPTY
28778: LIST
28779: LIST
28780: PUSH
28781: LD_INT 1
28783: NEG
28784: PUSH
28785: LD_INT 0
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: LD_INT 1
28794: NEG
28795: PUSH
28796: LD_INT 1
28798: NEG
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 1
28806: NEG
28807: PUSH
28808: LD_INT 2
28810: NEG
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: LD_INT 1
28821: NEG
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: LD_INT 2
28829: PUSH
28830: LD_INT 0
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: PUSH
28840: LD_INT 1
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: PUSH
28850: LD_INT 2
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 0
28859: PUSH
28860: LD_INT 2
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 2
28880: NEG
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 2
28891: NEG
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: LD_INT 2
28907: NEG
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 2
28915: NEG
28916: PUSH
28917: LD_INT 3
28919: NEG
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 2
28927: PUSH
28928: LD_INT 1
28930: NEG
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 3
28938: PUSH
28939: LD_INT 1
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 1
28948: PUSH
28949: LD_INT 3
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 1
28958: NEG
28959: PUSH
28960: LD_INT 2
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 3
28969: NEG
28970: PUSH
28971: LD_INT 2
28973: NEG
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29004: LD_ADDR_VAR 0 34
29008: PUSH
29009: LD_INT 0
29011: PUSH
29012: LD_INT 0
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: LD_INT 1
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 1
29032: PUSH
29033: LD_INT 0
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 1
29042: PUSH
29043: LD_INT 1
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: PUSH
29050: LD_INT 0
29052: PUSH
29053: LD_INT 1
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 0
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: PUSH
29071: LD_INT 1
29073: NEG
29074: PUSH
29075: LD_INT 1
29077: NEG
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 1
29085: NEG
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 0
29097: PUSH
29098: LD_INT 2
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: LD_INT 1
29111: NEG
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: LD_INT 2
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: EMPTY
29124: LIST
29125: LIST
29126: PUSH
29127: LD_INT 2
29129: PUSH
29130: LD_INT 2
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: PUSH
29140: LD_INT 2
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 1
29149: NEG
29150: PUSH
29151: LD_INT 1
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 2
29160: NEG
29161: PUSH
29162: LD_INT 0
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 2
29171: NEG
29172: PUSH
29173: LD_INT 1
29175: NEG
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 2
29183: NEG
29184: PUSH
29185: LD_INT 2
29187: NEG
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 1
29195: NEG
29196: PUSH
29197: LD_INT 3
29199: NEG
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: PUSH
29205: LD_INT 1
29207: PUSH
29208: LD_INT 2
29210: NEG
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 3
29218: PUSH
29219: LD_INT 2
29221: PUSH
29222: EMPTY
29223: LIST
29224: LIST
29225: PUSH
29226: LD_INT 2
29228: PUSH
29229: LD_INT 3
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 2
29238: NEG
29239: PUSH
29240: LD_INT 1
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 3
29249: NEG
29250: PUSH
29251: LD_INT 1
29253: NEG
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29284: LD_ADDR_VAR 0 35
29288: PUSH
29289: LD_INT 0
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 0
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 1
29312: PUSH
29313: LD_INT 0
29315: PUSH
29316: EMPTY
29317: LIST
29318: LIST
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: LD_INT 1
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: LD_INT 1
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: LD_INT 1
29342: NEG
29343: PUSH
29344: LD_INT 0
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: LD_INT 1
29357: NEG
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 2
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 2
29375: NEG
29376: PUSH
29377: LD_INT 1
29379: NEG
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: LIST
29391: LIST
29392: LIST
29393: LIST
29394: LIST
29395: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29396: LD_ADDR_VAR 0 36
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 0
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: LD_INT 1
29416: NEG
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 1
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 1
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 0
29444: PUSH
29445: LD_INT 1
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 1
29454: NEG
29455: PUSH
29456: LD_INT 0
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: LD_INT 1
29469: NEG
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 1
29477: NEG
29478: PUSH
29479: LD_INT 2
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: LD_INT 2
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29508: LD_ADDR_VAR 0 37
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 0
29525: PUSH
29526: LD_INT 1
29528: NEG
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 1
29536: PUSH
29537: LD_INT 0
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 1
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 0
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 1
29566: NEG
29567: PUSH
29568: LD_INT 0
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 1
29577: NEG
29578: PUSH
29579: LD_INT 1
29581: NEG
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: PUSH
29605: EMPTY
29606: LIST
29607: LIST
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29620: LD_ADDR_VAR 0 38
29624: PUSH
29625: LD_INT 0
29627: PUSH
29628: LD_INT 0
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 0
29637: PUSH
29638: LD_INT 1
29640: NEG
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PUSH
29646: LD_INT 1
29648: PUSH
29649: LD_INT 0
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: PUSH
29656: LD_INT 1
29658: PUSH
29659: LD_INT 1
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 0
29668: PUSH
29669: LD_INT 1
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: PUSH
29676: LD_INT 1
29678: NEG
29679: PUSH
29680: LD_INT 0
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 1
29689: NEG
29690: PUSH
29691: LD_INT 1
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 2
29701: PUSH
29702: LD_INT 1
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 2
29711: NEG
29712: PUSH
29713: LD_INT 1
29715: NEG
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: EMPTY
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29732: LD_ADDR_VAR 0 39
29736: PUSH
29737: LD_INT 0
29739: PUSH
29740: LD_INT 0
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 0
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 1
29760: PUSH
29761: LD_INT 0
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 1
29770: PUSH
29771: LD_INT 1
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 0
29780: PUSH
29781: LD_INT 1
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 1
29801: NEG
29802: PUSH
29803: LD_INT 1
29805: NEG
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: LD_INT 2
29817: NEG
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 1
29825: PUSH
29826: LD_INT 2
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29844: LD_ADDR_VAR 0 40
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: LD_INT 0
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 0
29861: PUSH
29862: LD_INT 1
29864: NEG
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 0
29892: PUSH
29893: LD_INT 1
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 1
29902: NEG
29903: PUSH
29904: LD_INT 0
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: LD_INT 1
29917: NEG
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 1
29928: NEG
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: LD_INT 1
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29956: LD_ADDR_VAR 0 41
29960: PUSH
29961: LD_INT 0
29963: PUSH
29964: LD_INT 0
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: LD_INT 1
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: LD_INT 0
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 1
30025: NEG
30026: PUSH
30027: LD_INT 1
30029: NEG
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 2
30060: PUSH
30061: LD_INT 0
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 1
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: LD_INT 2
30080: PUSH
30081: LD_INT 2
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: LD_INT 2
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 2
30111: NEG
30112: PUSH
30113: LD_INT 0
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: NEG
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 2
30134: NEG
30135: PUSH
30136: LD_INT 2
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 2
30146: NEG
30147: PUSH
30148: LD_INT 3
30150: NEG
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 3
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 3
30179: PUSH
30180: LD_INT 1
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 3
30189: PUSH
30190: LD_INT 2
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 3
30199: PUSH
30200: LD_INT 3
30202: PUSH
30203: EMPTY
30204: LIST
30205: LIST
30206: PUSH
30207: LD_INT 2
30209: PUSH
30210: LD_INT 3
30212: PUSH
30213: EMPTY
30214: LIST
30215: LIST
30216: PUSH
30217: LD_INT 2
30219: NEG
30220: PUSH
30221: LD_INT 1
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 3
30230: NEG
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 3
30241: NEG
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 3
30253: NEG
30254: PUSH
30255: LD_INT 2
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 3
30265: NEG
30266: PUSH
30267: LD_INT 3
30269: NEG
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30306: LD_ADDR_VAR 0 42
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: LD_INT 1
30326: NEG
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: LD_INT 0
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 1
30344: PUSH
30345: LD_INT 1
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 0
30354: PUSH
30355: LD_INT 1
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: NEG
30365: PUSH
30366: LD_INT 0
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 1
30375: NEG
30376: PUSH
30377: LD_INT 1
30379: NEG
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: LD_INT 2
30391: NEG
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 0
30399: PUSH
30400: LD_INT 2
30402: NEG
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 1
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 2
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 2
30431: PUSH
30432: LD_INT 2
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: LD_INT 2
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: LD_INT 2
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 2
30472: NEG
30473: PUSH
30474: LD_INT 1
30476: NEG
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 2
30484: NEG
30485: PUSH
30486: LD_INT 2
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 2
30496: NEG
30497: PUSH
30498: LD_INT 3
30500: NEG
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: LD_INT 3
30512: NEG
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 3
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: PUSH
30532: LD_INT 2
30534: NEG
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 3
30542: PUSH
30543: LD_INT 2
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 3
30552: PUSH
30553: LD_INT 3
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 2
30562: PUSH
30563: LD_INT 3
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: LD_INT 3
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: LD_INT 3
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 1
30592: NEG
30593: PUSH
30594: LD_INT 2
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 3
30603: NEG
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: LD_INT 3
30615: NEG
30616: PUSH
30617: LD_INT 3
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30656: LD_ADDR_VAR 0 43
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: LD_INT 0
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 0
30673: PUSH
30674: LD_INT 1
30676: NEG
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: LD_INT 1
30684: PUSH
30685: LD_INT 0
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: LD_INT 1
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 1
30714: NEG
30715: PUSH
30716: LD_INT 0
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 1
30725: NEG
30726: PUSH
30727: LD_INT 1
30729: NEG
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 1
30737: NEG
30738: PUSH
30739: LD_INT 2
30741: NEG
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: LD_INT 0
30749: PUSH
30750: LD_INT 2
30752: NEG
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 2
30771: PUSH
30772: LD_INT 0
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 2
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 1
30791: PUSH
30792: LD_INT 2
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 0
30801: PUSH
30802: LD_INT 2
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 1
30811: NEG
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 2
30822: NEG
30823: PUSH
30824: LD_INT 0
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 2
30833: NEG
30834: PUSH
30835: LD_INT 1
30837: NEG
30838: PUSH
30839: EMPTY
30840: LIST
30841: LIST
30842: PUSH
30843: LD_INT 1
30845: NEG
30846: PUSH
30847: LD_INT 3
30849: NEG
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PUSH
30855: LD_INT 0
30857: PUSH
30858: LD_INT 3
30860: NEG
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 1
30868: PUSH
30869: LD_INT 2
30871: NEG
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 2
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 3
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 3
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: PUSH
30911: LD_INT 3
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 0
30920: PUSH
30921: LD_INT 3
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 1
30930: NEG
30931: PUSH
30932: LD_INT 2
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: NEG
30942: PUSH
30943: LD_INT 1
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 3
30952: NEG
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 3
30963: NEG
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31004: LD_ADDR_VAR 0 44
31008: PUSH
31009: LD_INT 0
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 0
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 1
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: LD_INT 1
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: LD_INT 1
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: LD_INT 1
31077: NEG
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 1
31085: NEG
31086: PUSH
31087: LD_INT 2
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 2
31108: PUSH
31109: LD_INT 0
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 2
31118: PUSH
31119: LD_INT 1
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: PUSH
31129: LD_INT 2
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: LD_INT 2
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 1
31148: NEG
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 2
31159: NEG
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 2
31170: NEG
31171: PUSH
31172: LD_INT 1
31174: NEG
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: NEG
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: NEG
31195: PUSH
31196: LD_INT 3
31198: NEG
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 2
31206: PUSH
31207: LD_INT 1
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 3
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 3
31227: PUSH
31228: LD_INT 1
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 3
31237: PUSH
31238: LD_INT 2
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 3
31247: PUSH
31248: LD_INT 3
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: LD_INT 3
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 2
31267: NEG
31268: PUSH
31269: LD_INT 1
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 3
31278: NEG
31279: PUSH
31280: LD_INT 0
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 3
31289: NEG
31290: PUSH
31291: LD_INT 1
31293: NEG
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 3
31301: NEG
31302: PUSH
31303: LD_INT 2
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 3
31313: NEG
31314: PUSH
31315: LD_INT 3
31317: NEG
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31354: LD_ADDR_VAR 0 45
31358: PUSH
31359: LD_INT 0
31361: PUSH
31362: LD_INT 0
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: LD_INT 0
31371: PUSH
31372: LD_INT 1
31374: NEG
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: LD_INT 0
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: LD_INT 1
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: LD_INT 1
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 1
31423: NEG
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: NEG
31436: PUSH
31437: LD_INT 2
31439: NEG
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: LD_INT 2
31450: NEG
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PUSH
31456: LD_INT 1
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 2
31469: PUSH
31470: LD_INT 1
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: LD_INT 2
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: LD_INT 2
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: LD_INT 2
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 2
31544: NEG
31545: PUSH
31546: LD_INT 3
31548: NEG
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 1
31556: NEG
31557: PUSH
31558: LD_INT 3
31560: NEG
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: LD_INT 3
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: PUSH
31580: LD_INT 2
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 3
31590: PUSH
31591: LD_INT 2
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 3
31600: PUSH
31601: LD_INT 3
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 2
31610: PUSH
31611: LD_INT 3
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 1
31620: PUSH
31621: LD_INT 3
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 3
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 1
31640: NEG
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 3
31651: NEG
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 3
31663: NEG
31664: PUSH
31665: LD_INT 3
31667: NEG
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: LIST
31699: LIST
31700: LIST
31701: LIST
31702: LIST
31703: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31704: LD_ADDR_VAR 0 46
31708: PUSH
31709: LD_INT 0
31711: PUSH
31712: LD_INT 0
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 0
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 1
31732: PUSH
31733: LD_INT 0
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 1
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 0
31752: PUSH
31753: LD_INT 1
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 1
31762: NEG
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: NEG
31774: PUSH
31775: LD_INT 1
31777: NEG
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 1
31785: NEG
31786: PUSH
31787: LD_INT 2
31789: NEG
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 0
31797: PUSH
31798: LD_INT 2
31800: NEG
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: LD_INT 1
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 2
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 2
31829: PUSH
31830: LD_INT 1
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: PUSH
31840: LD_INT 2
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: LD_INT 0
31849: PUSH
31850: LD_INT 2
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 1
31859: NEG
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: LD_INT 3
31897: NEG
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 0
31905: PUSH
31906: LD_INT 3
31908: NEG
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: LD_INT 2
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 2
31927: PUSH
31928: LD_INT 1
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 3
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 3
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: LD_INT 3
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: LD_INT 3
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: NEG
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 2
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 3
32000: NEG
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 3
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32052: LD_ADDR_VAR 0 47
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: LD_INT 1
32072: NEG
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: LD_INT 1
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: LD_INT 1
32125: NEG
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 1
32133: NEG
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 0
32145: PUSH
32146: LD_INT 2
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 1
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 2
32179: NEG
32180: PUSH
32181: LD_INT 2
32183: NEG
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32203: LD_ADDR_VAR 0 48
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: LD_INT 0
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 0
32220: PUSH
32221: LD_INT 1
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: LD_INT 1
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 0
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 1
32261: NEG
32262: PUSH
32263: LD_INT 0
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 1
32272: NEG
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: LD_INT 2
32288: NEG
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 0
32296: PUSH
32297: LD_INT 2
32299: NEG
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PUSH
32305: LD_INT 1
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: PUSH
32316: LD_INT 2
32318: PUSH
32319: LD_INT 0
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 2
32328: PUSH
32329: LD_INT 1
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32350: LD_ADDR_VAR 0 49
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: LD_INT 0
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: LD_INT 1
32370: NEG
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: LD_INT 0
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 1
32388: PUSH
32389: LD_INT 1
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 0
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: PUSH
32432: LD_INT 1
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 2
32442: PUSH
32443: LD_INT 0
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: LD_INT 1
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: LD_INT 2
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: LD_INT 2
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32494: LD_ADDR_VAR 0 50
32498: PUSH
32499: LD_INT 0
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 1
32514: NEG
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: LD_INT 1
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: LD_INT 1
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: NEG
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 2
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 2
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: LD_INT 2
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 1
32615: NEG
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32638: LD_ADDR_VAR 0 51
32642: PUSH
32643: LD_INT 0
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 1
32676: PUSH
32677: LD_INT 1
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: LD_INT 1
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: LD_INT 0
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 1
32707: NEG
32708: PUSH
32709: LD_INT 1
32711: NEG
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 1
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 0
32729: PUSH
32730: LD_INT 2
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: NEG
32740: PUSH
32741: LD_INT 1
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 2
32750: NEG
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32785: LD_ADDR_VAR 0 52
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: LD_INT 0
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 0
32802: PUSH
32803: LD_INT 1
32805: NEG
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: LD_INT 0
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 1
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 0
32833: PUSH
32834: LD_INT 1
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: LD_INT 0
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 1
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 1
32866: NEG
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: NEG
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 2
32889: NEG
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: LD_INT 1
32904: NEG
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: LD_INT 2
32912: NEG
32913: PUSH
32914: LD_INT 2
32916: NEG
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32936: LD_ADDR_VAR 0 53
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 1
32994: NEG
32995: PUSH
32996: LD_INT 0
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: NEG
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 2
33021: NEG
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 0
33029: PUSH
33030: LD_INT 2
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 2
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 2
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: PUSH
33072: LD_INT 2
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 2
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 0
33091: PUSH
33092: LD_INT 2
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 1
33101: NEG
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 2
33112: NEG
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: NEG
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33166: LD_ADDR_VAR 0 54
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: LD_INT 0
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 1
33186: NEG
33187: PUSH
33188: EMPTY
33189: LIST
33190: LIST
33191: PUSH
33192: LD_INT 1
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: PUSH
33205: LD_INT 1
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 1
33224: NEG
33225: PUSH
33226: LD_INT 0
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: NEG
33248: PUSH
33249: LD_INT 2
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 0
33259: PUSH
33260: LD_INT 2
33262: NEG
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: LD_INT 0
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: LD_INT 2
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 1
33311: PUSH
33312: LD_INT 2
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 0
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: NEG
33332: PUSH
33333: LD_INT 1
33335: PUSH
33336: EMPTY
33337: LIST
33338: LIST
33339: PUSH
33340: LD_INT 2
33342: NEG
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 2
33353: NEG
33354: PUSH
33355: LD_INT 1
33357: NEG
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 2
33365: NEG
33366: PUSH
33367: LD_INT 2
33369: NEG
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33396: LD_ADDR_VAR 0 55
33400: PUSH
33401: LD_INT 0
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: LD_INT 1
33416: NEG
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 1
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 0
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 1
33454: NEG
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 1
33465: NEG
33466: PUSH
33467: LD_INT 1
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 1
33477: NEG
33478: PUSH
33479: LD_INT 2
33481: NEG
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: LD_INT 2
33492: NEG
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: LD_INT 1
33503: NEG
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 2
33511: PUSH
33512: LD_INT 0
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 2
33531: PUSH
33532: LD_INT 2
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: LD_INT 2
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 2
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: NEG
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 2
33572: NEG
33573: PUSH
33574: LD_INT 0
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 2
33595: NEG
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33626: LD_ADDR_VAR 0 56
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: LD_INT 0
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: LD_INT 1
33646: NEG
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 1
33654: PUSH
33655: LD_INT 0
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 1
33664: PUSH
33665: LD_INT 1
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: LD_INT 1
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 1
33684: NEG
33685: PUSH
33686: LD_INT 0
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: NEG
33696: PUSH
33697: LD_INT 1
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 1
33707: NEG
33708: PUSH
33709: LD_INT 2
33711: NEG
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: LD_INT 2
33722: NEG
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 2
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 2
33761: PUSH
33762: LD_INT 2
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: LD_INT 2
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: LD_INT 2
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 2
33802: NEG
33803: PUSH
33804: LD_INT 0
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 2
33825: NEG
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33856: LD_ADDR_VAR 0 57
33860: PUSH
33861: LD_INT 0
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 0
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 1
33914: NEG
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: LD_INT 1
33929: NEG
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 1
33937: NEG
33938: PUSH
33939: LD_INT 2
33941: NEG
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 0
33949: PUSH
33950: LD_INT 2
33952: NEG
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 2
33971: PUSH
33972: LD_INT 0
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 2
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 2
33991: PUSH
33992: LD_INT 2
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 1
34001: PUSH
34002: LD_INT 2
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 0
34011: PUSH
34012: LD_INT 2
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 2
34032: NEG
34033: PUSH
34034: LD_INT 0
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 2
34043: NEG
34044: PUSH
34045: LD_INT 1
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 2
34055: NEG
34056: PUSH
34057: LD_INT 2
34059: NEG
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34086: LD_ADDR_VAR 0 58
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 0
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: NEG
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: LD_INT 1
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 0
34134: PUSH
34135: LD_INT 1
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 1
34159: NEG
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: LD_INT 2
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: LD_INT 1
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 2
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 2
34221: PUSH
34222: LD_INT 2
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 1
34231: PUSH
34232: LD_INT 2
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 0
34241: PUSH
34242: LD_INT 2
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 1
34251: NEG
34252: PUSH
34253: LD_INT 1
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 2
34285: NEG
34286: PUSH
34287: LD_INT 2
34289: NEG
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34316: LD_ADDR_VAR 0 59
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: LD_INT 0
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 1
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 0
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 1
34374: NEG
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 1
34385: NEG
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34404: LD_ADDR_VAR 0 60
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: LD_INT 0
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: PUSH
34443: LD_INT 1
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 0
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 1
34462: NEG
34463: PUSH
34464: LD_INT 0
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 1
34473: NEG
34474: PUSH
34475: LD_INT 1
34477: NEG
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34492: LD_ADDR_VAR 0 61
34496: PUSH
34497: LD_INT 0
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 1
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34580: LD_ADDR_VAR 0 62
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 0
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 0
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: LD_INT 1
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: NEG
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: LD_INT 1
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34668: LD_ADDR_VAR 0 63
34672: PUSH
34673: LD_INT 0
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: PUSH
34707: LD_INT 1
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 0
34716: PUSH
34717: LD_INT 1
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: NEG
34727: PUSH
34728: LD_INT 0
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 1
34737: NEG
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34756: LD_ADDR_VAR 0 64
34760: PUSH
34761: LD_INT 0
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: LD_INT 1
34776: NEG
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: LD_INT 1
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 0
34804: PUSH
34805: LD_INT 1
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 1
34814: NEG
34815: PUSH
34816: LD_INT 0
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 1
34825: NEG
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: ST_TO_ADDR
// end ; 1 :
34844: GO 40741
34846: LD_INT 1
34848: DOUBLE
34849: EQUAL
34850: IFTRUE 34854
34852: GO 37477
34854: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34855: LD_ADDR_VAR 0 11
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: LD_INT 3
34866: NEG
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: LD_INT 3
34877: NEG
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: LD_INT 2
34888: NEG
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: LIST
34898: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34899: LD_ADDR_VAR 0 12
34903: PUSH
34904: LD_INT 2
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 3
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 3
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: LIST
34939: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34940: LD_ADDR_VAR 0 13
34944: PUSH
34945: LD_INT 3
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 3
34957: PUSH
34958: LD_INT 3
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: PUSH
34968: LD_INT 3
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: LIST
34979: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34980: LD_ADDR_VAR 0 14
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: LD_INT 3
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: NEG
35008: PUSH
35009: LD_INT 2
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: LIST
35020: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35021: LD_ADDR_VAR 0 15
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 3
35039: NEG
35040: PUSH
35041: LD_INT 0
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 3
35050: NEG
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: LIST
35064: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35065: LD_ADDR_VAR 0 16
35069: PUSH
35070: LD_INT 2
35072: NEG
35073: PUSH
35074: LD_INT 3
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 3
35084: NEG
35085: PUSH
35086: LD_INT 2
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 3
35096: NEG
35097: PUSH
35098: LD_INT 3
35100: NEG
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: LIST
35110: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35111: LD_ADDR_VAR 0 17
35115: PUSH
35116: LD_INT 1
35118: NEG
35119: PUSH
35120: LD_INT 3
35122: NEG
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 0
35130: PUSH
35131: LD_INT 3
35133: NEG
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 1
35141: PUSH
35142: LD_INT 2
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: LIST
35154: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35155: LD_ADDR_VAR 0 18
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 3
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 3
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: LIST
35195: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35196: LD_ADDR_VAR 0 19
35200: PUSH
35201: LD_INT 3
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 3
35213: PUSH
35214: LD_INT 3
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: LD_INT 3
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: LIST
35235: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35236: LD_ADDR_VAR 0 20
35240: PUSH
35241: LD_INT 1
35243: PUSH
35244: LD_INT 3
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 0
35253: PUSH
35254: LD_INT 3
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: LIST
35276: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35277: LD_ADDR_VAR 0 21
35281: PUSH
35282: LD_INT 2
35284: NEG
35285: PUSH
35286: LD_INT 1
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 3
35295: NEG
35296: PUSH
35297: LD_INT 0
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 3
35306: NEG
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: LIST
35320: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35321: LD_ADDR_VAR 0 22
35325: PUSH
35326: LD_INT 2
35328: NEG
35329: PUSH
35330: LD_INT 3
35332: NEG
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 3
35340: NEG
35341: PUSH
35342: LD_INT 2
35344: NEG
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 3
35352: NEG
35353: PUSH
35354: LD_INT 3
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: LIST
35366: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35367: LD_ADDR_VAR 0 23
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: LD_INT 3
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: LD_INT 4
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 3
35400: NEG
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: LIST
35410: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35411: LD_ADDR_VAR 0 24
35415: PUSH
35416: LD_INT 3
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 3
35428: PUSH
35429: LD_INT 1
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 4
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35452: LD_ADDR_VAR 0 25
35456: PUSH
35457: LD_INT 3
35459: PUSH
35460: LD_INT 3
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 4
35469: PUSH
35470: LD_INT 3
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 3
35479: PUSH
35480: LD_INT 4
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: LIST
35491: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35492: LD_ADDR_VAR 0 26
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: LD_INT 3
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: LD_INT 4
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: LD_INT 3
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: LIST
35532: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35533: LD_ADDR_VAR 0 27
35537: PUSH
35538: LD_INT 3
35540: NEG
35541: PUSH
35542: LD_INT 0
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 3
35551: NEG
35552: PUSH
35553: LD_INT 1
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 4
35562: NEG
35563: PUSH
35564: LD_INT 1
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35577: LD_ADDR_VAR 0 28
35581: PUSH
35582: LD_INT 3
35584: NEG
35585: PUSH
35586: LD_INT 3
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 3
35596: NEG
35597: PUSH
35598: LD_INT 4
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 4
35608: NEG
35609: PUSH
35610: LD_INT 3
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: LIST
35622: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35623: LD_ADDR_VAR 0 29
35627: PUSH
35628: LD_INT 1
35630: NEG
35631: PUSH
35632: LD_INT 3
35634: NEG
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 0
35642: PUSH
35643: LD_INT 3
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: LD_INT 2
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 1
35664: NEG
35665: PUSH
35666: LD_INT 4
35668: NEG
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: LD_INT 4
35679: NEG
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: PUSH
35688: LD_INT 3
35690: NEG
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 5
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: LD_INT 5
35713: NEG
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: LD_INT 4
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 1
35732: NEG
35733: PUSH
35734: LD_INT 6
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: LD_INT 6
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 1
35755: PUSH
35756: LD_INT 5
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35778: LD_ADDR_VAR 0 30
35782: PUSH
35783: LD_INT 2
35785: PUSH
35786: LD_INT 1
35788: NEG
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 3
35796: PUSH
35797: LD_INT 0
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 3
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 3
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 4
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 4
35837: PUSH
35838: LD_INT 1
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 4
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 5
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 5
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 5
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 6
35889: PUSH
35890: LD_INT 0
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 6
35899: PUSH
35900: LD_INT 1
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35921: LD_ADDR_VAR 0 31
35925: PUSH
35926: LD_INT 3
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: PUSH
35939: LD_INT 3
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 3
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 4
35958: PUSH
35959: LD_INT 3
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 4
35968: PUSH
35969: LD_INT 4
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 3
35978: PUSH
35979: LD_INT 4
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 5
35988: PUSH
35989: LD_INT 4
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 5
35998: PUSH
35999: LD_INT 5
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 4
36008: PUSH
36009: LD_INT 5
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 6
36018: PUSH
36019: LD_INT 5
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 6
36028: PUSH
36029: LD_INT 6
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: PUSH
36036: LD_INT 5
36038: PUSH
36039: LD_INT 6
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: LIST
36054: LIST
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36060: LD_ADDR_VAR 0 32
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: LD_INT 3
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 0
36077: PUSH
36078: LD_INT 3
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 1
36098: PUSH
36099: LD_INT 4
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 0
36108: PUSH
36109: LD_INT 4
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: LD_INT 3
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: LD_INT 1
36129: PUSH
36130: LD_INT 5
36132: PUSH
36133: EMPTY
36134: LIST
36135: LIST
36136: PUSH
36137: LD_INT 0
36139: PUSH
36140: LD_INT 5
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 1
36149: NEG
36150: PUSH
36151: LD_INT 4
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 1
36160: PUSH
36161: LD_INT 6
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: LD_INT 6
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: LD_INT 5
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36203: LD_ADDR_VAR 0 33
36207: PUSH
36208: LD_INT 2
36210: NEG
36211: PUSH
36212: LD_INT 1
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: LD_INT 0
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 3
36232: NEG
36233: PUSH
36234: LD_INT 1
36236: NEG
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 3
36244: NEG
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 4
36255: NEG
36256: PUSH
36257: LD_INT 0
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 4
36266: NEG
36267: PUSH
36268: LD_INT 1
36270: NEG
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 4
36278: NEG
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 5
36289: NEG
36290: PUSH
36291: LD_INT 0
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 5
36300: NEG
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 5
36312: NEG
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 6
36323: NEG
36324: PUSH
36325: LD_INT 0
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 6
36334: NEG
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36358: LD_ADDR_VAR 0 34
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: LD_INT 3
36369: NEG
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: LD_INT 2
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 3
36389: NEG
36390: PUSH
36391: LD_INT 3
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 3
36401: NEG
36402: PUSH
36403: LD_INT 4
36405: NEG
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 4
36413: NEG
36414: PUSH
36415: LD_INT 3
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 4
36425: NEG
36426: PUSH
36427: LD_INT 4
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 4
36437: NEG
36438: PUSH
36439: LD_INT 5
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: LD_INT 4
36453: NEG
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 5
36461: NEG
36462: PUSH
36463: LD_INT 5
36465: NEG
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 5
36473: NEG
36474: PUSH
36475: LD_INT 6
36477: NEG
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 6
36485: NEG
36486: PUSH
36487: LD_INT 5
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 6
36497: NEG
36498: PUSH
36499: LD_INT 6
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36521: LD_ADDR_VAR 0 41
36525: PUSH
36526: LD_INT 0
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: NEG
36540: PUSH
36541: LD_INT 3
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 1
36551: PUSH
36552: LD_INT 2
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: LIST
36564: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36565: LD_ADDR_VAR 0 42
36569: PUSH
36570: LD_INT 2
36572: PUSH
36573: LD_INT 0
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 2
36582: PUSH
36583: LD_INT 1
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 3
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: LIST
36605: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36606: LD_ADDR_VAR 0 43
36610: PUSH
36611: LD_INT 2
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 3
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 2
36633: PUSH
36634: LD_INT 3
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: LIST
36645: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36646: LD_ADDR_VAR 0 44
36650: PUSH
36651: LD_INT 0
36653: PUSH
36654: LD_INT 2
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: LD_INT 3
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: NEG
36674: PUSH
36675: LD_INT 2
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: LIST
36686: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36687: LD_ADDR_VAR 0 45
36691: PUSH
36692: LD_INT 2
36694: NEG
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 3
36716: NEG
36717: PUSH
36718: LD_INT 1
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: LIST
36730: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36731: LD_ADDR_VAR 0 46
36735: PUSH
36736: LD_INT 2
36738: NEG
36739: PUSH
36740: LD_INT 2
36742: NEG
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 2
36750: NEG
36751: PUSH
36752: LD_INT 3
36754: NEG
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 3
36762: NEG
36763: PUSH
36764: LD_INT 2
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: LIST
36776: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36777: LD_ADDR_VAR 0 47
36781: PUSH
36782: LD_INT 2
36784: NEG
36785: PUSH
36786: LD_INT 3
36788: NEG
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: LD_INT 3
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36810: LD_ADDR_VAR 0 48
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: PUSH
36829: LD_INT 1
36831: NEG
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36841: LD_ADDR_VAR 0 49
36845: PUSH
36846: LD_INT 3
36848: PUSH
36849: LD_INT 1
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 3
36858: PUSH
36859: LD_INT 2
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36870: LD_ADDR_VAR 0 50
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: LD_INT 3
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 3
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36899: LD_ADDR_VAR 0 51
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36930: LD_ADDR_VAR 0 52
36934: PUSH
36935: LD_INT 3
36937: NEG
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 3
36949: NEG
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36963: LD_ADDR_VAR 0 53
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: LD_INT 3
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 0
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 1
36993: PUSH
36994: LD_INT 2
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: LIST
37006: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37007: LD_ADDR_VAR 0 54
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 1
37017: NEG
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 3
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 3
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: LIST
37047: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37048: LD_ADDR_VAR 0 55
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: LD_INT 2
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: LD_INT 3
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 2
37075: PUSH
37076: LD_INT 3
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: LIST
37087: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37088: LD_ADDR_VAR 0 56
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 3
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 0
37105: PUSH
37106: LD_INT 3
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: LD_INT 2
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: LIST
37128: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37129: LD_ADDR_VAR 0 57
37133: PUSH
37134: LD_INT 2
37136: NEG
37137: PUSH
37138: LD_INT 1
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 3
37147: NEG
37148: PUSH
37149: LD_INT 0
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 3
37158: NEG
37159: PUSH
37160: LD_INT 1
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: LIST
37172: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37173: LD_ADDR_VAR 0 58
37177: PUSH
37178: LD_INT 2
37180: NEG
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 3
37192: NEG
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 3
37204: NEG
37205: PUSH
37206: LD_INT 3
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37219: LD_ADDR_VAR 0 59
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 2
37230: NEG
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 0
37238: PUSH
37239: LD_INT 2
37241: NEG
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 1
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: LIST
37262: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37263: LD_ADDR_VAR 0 60
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 0
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 2
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: LIST
37303: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37304: LD_ADDR_VAR 0 61
37308: PUSH
37309: LD_INT 2
37311: PUSH
37312: LD_INT 1
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 2
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: LD_INT 2
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: LIST
37343: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37344: LD_ADDR_VAR 0 62
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: LD_INT 2
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 0
37361: PUSH
37362: LD_INT 2
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 1
37371: NEG
37372: PUSH
37373: LD_INT 1
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: LIST
37384: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37385: LD_ADDR_VAR 0 63
37389: PUSH
37390: LD_INT 1
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 2
37403: NEG
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: LD_INT 1
37418: NEG
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: LIST
37428: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37429: LD_ADDR_VAR 0 64
37433: PUSH
37434: LD_INT 1
37436: NEG
37437: PUSH
37438: LD_INT 2
37440: NEG
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: NEG
37449: PUSH
37450: LD_INT 1
37452: NEG
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 2
37460: NEG
37461: PUSH
37462: LD_INT 2
37464: NEG
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: LIST
37474: ST_TO_ADDR
// end ; 2 :
37475: GO 40741
37477: LD_INT 2
37479: DOUBLE
37480: EQUAL
37481: IFTRUE 37485
37483: GO 40740
37485: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37486: LD_ADDR_VAR 0 29
37490: PUSH
37491: LD_INT 4
37493: PUSH
37494: LD_INT 0
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 4
37503: PUSH
37504: LD_INT 1
37506: NEG
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 5
37514: PUSH
37515: LD_INT 0
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 5
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 4
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 3
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 3
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 3
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 5
37576: PUSH
37577: LD_INT 2
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: LD_INT 3
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 3
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 4
37606: PUSH
37607: LD_INT 3
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 4
37616: PUSH
37617: LD_INT 4
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 3
37626: PUSH
37627: LD_INT 4
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 2
37636: PUSH
37637: LD_INT 3
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: LD_INT 2
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 4
37656: PUSH
37657: LD_INT 2
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 2
37666: PUSH
37667: LD_INT 4
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 0
37676: PUSH
37677: LD_INT 4
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 0
37686: PUSH
37687: LD_INT 3
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: LD_INT 4
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 1
37706: PUSH
37707: LD_INT 5
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 0
37716: PUSH
37717: LD_INT 5
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: LD_INT 4
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 1
37737: NEG
37738: PUSH
37739: LD_INT 3
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 2
37748: PUSH
37749: LD_INT 5
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 2
37758: NEG
37759: PUSH
37760: LD_INT 3
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 3
37769: NEG
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 3
37780: NEG
37781: PUSH
37782: LD_INT 1
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 2
37792: NEG
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: NEG
37804: PUSH
37805: LD_INT 1
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 3
37814: NEG
37815: PUSH
37816: LD_INT 1
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 4
37825: NEG
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 4
37836: NEG
37837: PUSH
37838: LD_INT 1
37840: NEG
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 4
37848: NEG
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 2
37860: NEG
37861: PUSH
37862: LD_INT 2
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 4
37871: NEG
37872: PUSH
37873: LD_INT 4
37875: NEG
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 4
37883: NEG
37884: PUSH
37885: LD_INT 5
37887: NEG
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 3
37895: NEG
37896: PUSH
37897: LD_INT 4
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 3
37907: NEG
37908: PUSH
37909: LD_INT 3
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 4
37919: NEG
37920: PUSH
37921: LD_INT 3
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 5
37931: NEG
37932: PUSH
37933: LD_INT 4
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 5
37943: NEG
37944: PUSH
37945: LD_INT 5
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 3
37955: NEG
37956: PUSH
37957: LD_INT 5
37959: NEG
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 5
37967: NEG
37968: PUSH
37969: LD_INT 3
37971: NEG
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38024: LD_ADDR_VAR 0 30
38028: PUSH
38029: LD_INT 4
38031: PUSH
38032: LD_INT 4
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 4
38041: PUSH
38042: LD_INT 3
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 5
38051: PUSH
38052: LD_INT 4
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: LD_INT 5
38061: PUSH
38062: LD_INT 5
38064: PUSH
38065: EMPTY
38066: LIST
38067: LIST
38068: PUSH
38069: LD_INT 4
38071: PUSH
38072: LD_INT 5
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 3
38081: PUSH
38082: LD_INT 4
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 3
38091: PUSH
38092: LD_INT 3
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 5
38101: PUSH
38102: LD_INT 3
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 3
38111: PUSH
38112: LD_INT 5
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 0
38121: PUSH
38122: LD_INT 3
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: LD_INT 2
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 3
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 4
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: LD_INT 4
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: LD_INT 3
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 2
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: LD_INT 4
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 2
38203: NEG
38204: PUSH
38205: LD_INT 2
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 4
38214: NEG
38215: PUSH
38216: LD_INT 0
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 4
38225: NEG
38226: PUSH
38227: LD_INT 1
38229: NEG
38230: PUSH
38231: EMPTY
38232: LIST
38233: LIST
38234: PUSH
38235: LD_INT 3
38237: NEG
38238: PUSH
38239: LD_INT 0
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 3
38248: NEG
38249: PUSH
38250: LD_INT 1
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 4
38259: NEG
38260: PUSH
38261: LD_INT 1
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 5
38270: NEG
38271: PUSH
38272: LD_INT 0
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 5
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: NEG
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 5
38293: NEG
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 3
38305: NEG
38306: PUSH
38307: LD_INT 2
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 3
38316: NEG
38317: PUSH
38318: LD_INT 3
38320: NEG
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 3
38328: NEG
38329: PUSH
38330: LD_INT 4
38332: NEG
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: LD_INT 3
38344: NEG
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 2
38352: NEG
38353: PUSH
38354: LD_INT 2
38356: NEG
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 3
38364: NEG
38365: PUSH
38366: LD_INT 2
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 4
38376: NEG
38377: PUSH
38378: LD_INT 3
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 4
38388: NEG
38389: PUSH
38390: LD_INT 4
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: NEG
38401: PUSH
38402: LD_INT 4
38404: NEG
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 4
38412: NEG
38413: PUSH
38414: LD_INT 2
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: LD_INT 4
38427: NEG
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 0
38435: PUSH
38436: LD_INT 5
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 1
38446: PUSH
38447: LD_INT 4
38449: NEG
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: LD_INT 3
38460: NEG
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 0
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: NEG
38480: PUSH
38481: LD_INT 4
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 1
38491: NEG
38492: PUSH
38493: LD_INT 5
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 2
38503: PUSH
38504: LD_INT 3
38506: NEG
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: NEG
38515: PUSH
38516: LD_INT 5
38518: NEG
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38571: LD_ADDR_VAR 0 31
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: LD_INT 4
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 3
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: LD_INT 4
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 1
38608: PUSH
38609: LD_INT 5
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: LD_INT 5
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: NEG
38629: PUSH
38630: LD_INT 4
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 5
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 2
38660: NEG
38661: PUSH
38662: LD_INT 3
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 3
38671: NEG
38672: PUSH
38673: LD_INT 0
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 3
38682: NEG
38683: PUSH
38684: LD_INT 1
38686: NEG
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 3
38716: NEG
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 4
38727: NEG
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 4
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 4
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 2
38762: NEG
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 4
38773: NEG
38774: PUSH
38775: LD_INT 4
38777: NEG
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 4
38785: NEG
38786: PUSH
38787: LD_INT 5
38789: NEG
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 3
38797: NEG
38798: PUSH
38799: LD_INT 4
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 3
38809: NEG
38810: PUSH
38811: LD_INT 3
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: LD_INT 4
38821: NEG
38822: PUSH
38823: LD_INT 3
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 5
38833: NEG
38834: PUSH
38835: LD_INT 4
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 5
38845: NEG
38846: PUSH
38847: LD_INT 5
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 3
38857: NEG
38858: PUSH
38859: LD_INT 5
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 5
38869: NEG
38870: PUSH
38871: LD_INT 3
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 3
38884: NEG
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 0
38892: PUSH
38893: LD_INT 4
38895: NEG
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: PUSH
38904: LD_INT 3
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 1
38914: PUSH
38915: LD_INT 2
38917: NEG
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: LD_INT 2
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 3
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 1
38948: NEG
38949: PUSH
38950: LD_INT 4
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 2
38960: PUSH
38961: LD_INT 2
38963: NEG
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: NEG
38972: PUSH
38973: LD_INT 4
38975: NEG
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 4
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 4
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 5
39004: PUSH
39005: LD_INT 0
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 5
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 4
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 3
39034: PUSH
39035: LD_INT 0
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 3
39044: PUSH
39045: LD_INT 1
39047: NEG
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: LD_INT 3
39055: PUSH
39056: LD_INT 2
39058: NEG
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 5
39066: PUSH
39067: LD_INT 2
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39121: LD_ADDR_VAR 0 32
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 4
39139: NEG
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 3
39151: NEG
39152: PUSH
39153: LD_INT 0
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 3
39162: NEG
39163: PUSH
39164: LD_INT 1
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 4
39173: NEG
39174: PUSH
39175: LD_INT 1
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 5
39184: NEG
39185: PUSH
39186: LD_INT 0
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 5
39195: NEG
39196: PUSH
39197: LD_INT 1
39199: NEG
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 5
39207: NEG
39208: PUSH
39209: LD_INT 2
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 3
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 3
39230: NEG
39231: PUSH
39232: LD_INT 3
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 3
39242: NEG
39243: PUSH
39244: LD_INT 4
39246: NEG
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: NEG
39255: PUSH
39256: LD_INT 3
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 2
39266: NEG
39267: PUSH
39268: LD_INT 2
39270: NEG
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 3
39278: NEG
39279: PUSH
39280: LD_INT 2
39282: NEG
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 4
39290: NEG
39291: PUSH
39292: LD_INT 3
39294: NEG
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 4
39302: NEG
39303: PUSH
39304: LD_INT 4
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 2
39314: NEG
39315: PUSH
39316: LD_INT 4
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 4
39326: NEG
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 0
39338: PUSH
39339: LD_INT 4
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 5
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: LD_INT 4
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 1
39371: PUSH
39372: LD_INT 3
39374: NEG
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 0
39382: PUSH
39383: LD_INT 3
39385: NEG
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: NEG
39394: PUSH
39395: LD_INT 4
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 1
39405: NEG
39406: PUSH
39407: LD_INT 5
39409: NEG
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: PUSH
39418: LD_INT 3
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: LD_INT 5
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 3
39440: PUSH
39441: LD_INT 0
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 3
39450: PUSH
39451: LD_INT 1
39453: NEG
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 4
39461: PUSH
39462: LD_INT 0
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 4
39471: PUSH
39472: LD_INT 1
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 3
39481: PUSH
39482: LD_INT 1
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 2
39491: PUSH
39492: LD_INT 0
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 2
39501: PUSH
39502: LD_INT 1
39504: NEG
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 2
39512: PUSH
39513: LD_INT 2
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 4
39523: PUSH
39524: LD_INT 2
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 4
39533: PUSH
39534: LD_INT 4
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 4
39543: PUSH
39544: LD_INT 3
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 5
39553: PUSH
39554: LD_INT 4
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 5
39563: PUSH
39564: LD_INT 5
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 4
39573: PUSH
39574: LD_INT 5
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 3
39583: PUSH
39584: LD_INT 4
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 3
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 5
39603: PUSH
39604: LD_INT 3
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 3
39613: PUSH
39614: LD_INT 5
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: LIST
39662: LIST
39663: LIST
39664: LIST
39665: LIST
39666: LIST
39667: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39668: LD_ADDR_VAR 0 33
39672: PUSH
39673: LD_INT 4
39675: NEG
39676: PUSH
39677: LD_INT 4
39679: NEG
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 4
39687: NEG
39688: PUSH
39689: LD_INT 5
39691: NEG
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: LD_INT 4
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 3
39711: NEG
39712: PUSH
39713: LD_INT 3
39715: NEG
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 4
39723: NEG
39724: PUSH
39725: LD_INT 3
39727: NEG
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 5
39735: NEG
39736: PUSH
39737: LD_INT 4
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 5
39747: NEG
39748: PUSH
39749: LD_INT 5
39751: NEG
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 3
39759: NEG
39760: PUSH
39761: LD_INT 5
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 5
39771: NEG
39772: PUSH
39773: LD_INT 3
39775: NEG
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 0
39783: PUSH
39784: LD_INT 3
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 0
39794: PUSH
39795: LD_INT 4
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 1
39805: PUSH
39806: LD_INT 3
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 1
39816: PUSH
39817: LD_INT 2
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 0
39827: PUSH
39828: LD_INT 2
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: LD_INT 3
39842: NEG
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 1
39850: NEG
39851: PUSH
39852: LD_INT 4
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 2
39862: PUSH
39863: LD_INT 2
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 2
39873: NEG
39874: PUSH
39875: LD_INT 4
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 4
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 4
39895: PUSH
39896: LD_INT 1
39898: NEG
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 5
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 5
39916: PUSH
39917: LD_INT 1
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 4
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 3
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 3
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 3
39957: PUSH
39958: LD_INT 2
39960: NEG
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: LD_INT 5
39968: PUSH
39969: LD_INT 2
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 3
39978: PUSH
39979: LD_INT 3
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 3
39988: PUSH
39989: LD_INT 2
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 4
39998: PUSH
39999: LD_INT 3
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 4
40008: PUSH
40009: LD_INT 4
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: LD_INT 4
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 2
40028: PUSH
40029: LD_INT 3
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 2
40038: PUSH
40039: LD_INT 2
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 4
40048: PUSH
40049: LD_INT 2
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 2
40058: PUSH
40059: LD_INT 4
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: LD_INT 4
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: LD_INT 3
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: LD_INT 4
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: LD_INT 1
40098: PUSH
40099: LD_INT 5
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: LD_INT 5
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 4
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: LD_INT 3
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 2
40140: PUSH
40141: LD_INT 5
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 2
40150: NEG
40151: PUSH
40152: LD_INT 3
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40206: LD_ADDR_VAR 0 34
40210: PUSH
40211: LD_INT 0
40213: PUSH
40214: LD_INT 4
40216: NEG
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: LD_INT 5
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 1
40235: PUSH
40236: LD_INT 4
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 3
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 0
40257: PUSH
40258: LD_INT 3
40260: NEG
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 4
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 1
40280: NEG
40281: PUSH
40282: LD_INT 5
40284: NEG
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 2
40292: PUSH
40293: LD_INT 3
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: LD_INT 5
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 3
40315: PUSH
40316: LD_INT 0
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 3
40325: PUSH
40326: LD_INT 1
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 4
40336: PUSH
40337: LD_INT 0
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 4
40346: PUSH
40347: LD_INT 1
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: PUSH
40354: LD_INT 3
40356: PUSH
40357: LD_INT 1
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 2
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 2
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 2
40387: PUSH
40388: LD_INT 2
40390: NEG
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 4
40398: PUSH
40399: LD_INT 2
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 4
40408: PUSH
40409: LD_INT 4
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 4
40418: PUSH
40419: LD_INT 3
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 5
40428: PUSH
40429: LD_INT 4
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 5
40438: PUSH
40439: LD_INT 5
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 4
40448: PUSH
40449: LD_INT 5
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 3
40458: PUSH
40459: LD_INT 4
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 3
40468: PUSH
40469: LD_INT 3
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 5
40478: PUSH
40479: LD_INT 3
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 3
40488: PUSH
40489: LD_INT 5
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 0
40498: PUSH
40499: LD_INT 3
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 2
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: LD_INT 3
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: LD_INT 4
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 0
40538: PUSH
40539: LD_INT 4
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 1
40548: NEG
40549: PUSH
40550: LD_INT 3
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 1
40559: NEG
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 2
40570: PUSH
40571: LD_INT 4
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 2
40580: NEG
40581: PUSH
40582: LD_INT 2
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 4
40591: NEG
40592: PUSH
40593: LD_INT 0
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 4
40602: NEG
40603: PUSH
40604: LD_INT 1
40606: NEG
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 3
40614: NEG
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 3
40625: NEG
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 4
40636: NEG
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 5
40647: NEG
40648: PUSH
40649: LD_INT 0
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 5
40658: NEG
40659: PUSH
40660: LD_INT 1
40662: NEG
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 5
40670: NEG
40671: PUSH
40672: LD_INT 2
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 3
40682: NEG
40683: PUSH
40684: LD_INT 2
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: LIST
40731: LIST
40732: LIST
40733: LIST
40734: LIST
40735: LIST
40736: LIST
40737: ST_TO_ADDR
// end ; end ;
40738: GO 40741
40740: POP
// case btype of b_depot , b_warehouse :
40741: LD_VAR 0 1
40745: PUSH
40746: LD_INT 0
40748: DOUBLE
40749: EQUAL
40750: IFTRUE 40760
40752: LD_INT 1
40754: DOUBLE
40755: EQUAL
40756: IFTRUE 40760
40758: GO 40961
40760: POP
// case nation of nation_american :
40761: LD_VAR 0 5
40765: PUSH
40766: LD_INT 1
40768: DOUBLE
40769: EQUAL
40770: IFTRUE 40774
40772: GO 40830
40774: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40775: LD_ADDR_VAR 0 9
40779: PUSH
40780: LD_VAR 0 11
40784: PUSH
40785: LD_VAR 0 12
40789: PUSH
40790: LD_VAR 0 13
40794: PUSH
40795: LD_VAR 0 14
40799: PUSH
40800: LD_VAR 0 15
40804: PUSH
40805: LD_VAR 0 16
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: LIST
40814: LIST
40815: LIST
40816: LIST
40817: PUSH
40818: LD_VAR 0 4
40822: PUSH
40823: LD_INT 1
40825: PLUS
40826: ARRAY
40827: ST_TO_ADDR
40828: GO 40959
40830: LD_INT 2
40832: DOUBLE
40833: EQUAL
40834: IFTRUE 40838
40836: GO 40894
40838: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40839: LD_ADDR_VAR 0 9
40843: PUSH
40844: LD_VAR 0 17
40848: PUSH
40849: LD_VAR 0 18
40853: PUSH
40854: LD_VAR 0 19
40858: PUSH
40859: LD_VAR 0 20
40863: PUSH
40864: LD_VAR 0 21
40868: PUSH
40869: LD_VAR 0 22
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: PUSH
40882: LD_VAR 0 4
40886: PUSH
40887: LD_INT 1
40889: PLUS
40890: ARRAY
40891: ST_TO_ADDR
40892: GO 40959
40894: LD_INT 3
40896: DOUBLE
40897: EQUAL
40898: IFTRUE 40902
40900: GO 40958
40902: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40903: LD_ADDR_VAR 0 9
40907: PUSH
40908: LD_VAR 0 23
40912: PUSH
40913: LD_VAR 0 24
40917: PUSH
40918: LD_VAR 0 25
40922: PUSH
40923: LD_VAR 0 26
40927: PUSH
40928: LD_VAR 0 27
40932: PUSH
40933: LD_VAR 0 28
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: PUSH
40946: LD_VAR 0 4
40950: PUSH
40951: LD_INT 1
40953: PLUS
40954: ARRAY
40955: ST_TO_ADDR
40956: GO 40959
40958: POP
40959: GO 41514
40961: LD_INT 2
40963: DOUBLE
40964: EQUAL
40965: IFTRUE 40975
40967: LD_INT 3
40969: DOUBLE
40970: EQUAL
40971: IFTRUE 40975
40973: GO 41031
40975: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40976: LD_ADDR_VAR 0 9
40980: PUSH
40981: LD_VAR 0 29
40985: PUSH
40986: LD_VAR 0 30
40990: PUSH
40991: LD_VAR 0 31
40995: PUSH
40996: LD_VAR 0 32
41000: PUSH
41001: LD_VAR 0 33
41005: PUSH
41006: LD_VAR 0 34
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: PUSH
41019: LD_VAR 0 4
41023: PUSH
41024: LD_INT 1
41026: PLUS
41027: ARRAY
41028: ST_TO_ADDR
41029: GO 41514
41031: LD_INT 16
41033: DOUBLE
41034: EQUAL
41035: IFTRUE 41093
41037: LD_INT 17
41039: DOUBLE
41040: EQUAL
41041: IFTRUE 41093
41043: LD_INT 18
41045: DOUBLE
41046: EQUAL
41047: IFTRUE 41093
41049: LD_INT 19
41051: DOUBLE
41052: EQUAL
41053: IFTRUE 41093
41055: LD_INT 22
41057: DOUBLE
41058: EQUAL
41059: IFTRUE 41093
41061: LD_INT 20
41063: DOUBLE
41064: EQUAL
41065: IFTRUE 41093
41067: LD_INT 21
41069: DOUBLE
41070: EQUAL
41071: IFTRUE 41093
41073: LD_INT 23
41075: DOUBLE
41076: EQUAL
41077: IFTRUE 41093
41079: LD_INT 24
41081: DOUBLE
41082: EQUAL
41083: IFTRUE 41093
41085: LD_INT 25
41087: DOUBLE
41088: EQUAL
41089: IFTRUE 41093
41091: GO 41149
41093: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41094: LD_ADDR_VAR 0 9
41098: PUSH
41099: LD_VAR 0 35
41103: PUSH
41104: LD_VAR 0 36
41108: PUSH
41109: LD_VAR 0 37
41113: PUSH
41114: LD_VAR 0 38
41118: PUSH
41119: LD_VAR 0 39
41123: PUSH
41124: LD_VAR 0 40
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: PUSH
41137: LD_VAR 0 4
41141: PUSH
41142: LD_INT 1
41144: PLUS
41145: ARRAY
41146: ST_TO_ADDR
41147: GO 41514
41149: LD_INT 6
41151: DOUBLE
41152: EQUAL
41153: IFTRUE 41205
41155: LD_INT 7
41157: DOUBLE
41158: EQUAL
41159: IFTRUE 41205
41161: LD_INT 8
41163: DOUBLE
41164: EQUAL
41165: IFTRUE 41205
41167: LD_INT 13
41169: DOUBLE
41170: EQUAL
41171: IFTRUE 41205
41173: LD_INT 12
41175: DOUBLE
41176: EQUAL
41177: IFTRUE 41205
41179: LD_INT 15
41181: DOUBLE
41182: EQUAL
41183: IFTRUE 41205
41185: LD_INT 11
41187: DOUBLE
41188: EQUAL
41189: IFTRUE 41205
41191: LD_INT 14
41193: DOUBLE
41194: EQUAL
41195: IFTRUE 41205
41197: LD_INT 10
41199: DOUBLE
41200: EQUAL
41201: IFTRUE 41205
41203: GO 41261
41205: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41206: LD_ADDR_VAR 0 9
41210: PUSH
41211: LD_VAR 0 41
41215: PUSH
41216: LD_VAR 0 42
41220: PUSH
41221: LD_VAR 0 43
41225: PUSH
41226: LD_VAR 0 44
41230: PUSH
41231: LD_VAR 0 45
41235: PUSH
41236: LD_VAR 0 46
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: PUSH
41249: LD_VAR 0 4
41253: PUSH
41254: LD_INT 1
41256: PLUS
41257: ARRAY
41258: ST_TO_ADDR
41259: GO 41514
41261: LD_INT 36
41263: DOUBLE
41264: EQUAL
41265: IFTRUE 41269
41267: GO 41325
41269: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41270: LD_ADDR_VAR 0 9
41274: PUSH
41275: LD_VAR 0 47
41279: PUSH
41280: LD_VAR 0 48
41284: PUSH
41285: LD_VAR 0 49
41289: PUSH
41290: LD_VAR 0 50
41294: PUSH
41295: LD_VAR 0 51
41299: PUSH
41300: LD_VAR 0 52
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: PUSH
41313: LD_VAR 0 4
41317: PUSH
41318: LD_INT 1
41320: PLUS
41321: ARRAY
41322: ST_TO_ADDR
41323: GO 41514
41325: LD_INT 4
41327: DOUBLE
41328: EQUAL
41329: IFTRUE 41351
41331: LD_INT 5
41333: DOUBLE
41334: EQUAL
41335: IFTRUE 41351
41337: LD_INT 34
41339: DOUBLE
41340: EQUAL
41341: IFTRUE 41351
41343: LD_INT 37
41345: DOUBLE
41346: EQUAL
41347: IFTRUE 41351
41349: GO 41407
41351: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41352: LD_ADDR_VAR 0 9
41356: PUSH
41357: LD_VAR 0 53
41361: PUSH
41362: LD_VAR 0 54
41366: PUSH
41367: LD_VAR 0 55
41371: PUSH
41372: LD_VAR 0 56
41376: PUSH
41377: LD_VAR 0 57
41381: PUSH
41382: LD_VAR 0 58
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: PUSH
41395: LD_VAR 0 4
41399: PUSH
41400: LD_INT 1
41402: PLUS
41403: ARRAY
41404: ST_TO_ADDR
41405: GO 41514
41407: LD_INT 31
41409: DOUBLE
41410: EQUAL
41411: IFTRUE 41457
41413: LD_INT 32
41415: DOUBLE
41416: EQUAL
41417: IFTRUE 41457
41419: LD_INT 33
41421: DOUBLE
41422: EQUAL
41423: IFTRUE 41457
41425: LD_INT 27
41427: DOUBLE
41428: EQUAL
41429: IFTRUE 41457
41431: LD_INT 26
41433: DOUBLE
41434: EQUAL
41435: IFTRUE 41457
41437: LD_INT 28
41439: DOUBLE
41440: EQUAL
41441: IFTRUE 41457
41443: LD_INT 29
41445: DOUBLE
41446: EQUAL
41447: IFTRUE 41457
41449: LD_INT 30
41451: DOUBLE
41452: EQUAL
41453: IFTRUE 41457
41455: GO 41513
41457: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41458: LD_ADDR_VAR 0 9
41462: PUSH
41463: LD_VAR 0 59
41467: PUSH
41468: LD_VAR 0 60
41472: PUSH
41473: LD_VAR 0 61
41477: PUSH
41478: LD_VAR 0 62
41482: PUSH
41483: LD_VAR 0 63
41487: PUSH
41488: LD_VAR 0 64
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: PUSH
41501: LD_VAR 0 4
41505: PUSH
41506: LD_INT 1
41508: PLUS
41509: ARRAY
41510: ST_TO_ADDR
41511: GO 41514
41513: POP
// temp_list2 = [ ] ;
41514: LD_ADDR_VAR 0 10
41518: PUSH
41519: EMPTY
41520: ST_TO_ADDR
// for i in temp_list do
41521: LD_ADDR_VAR 0 8
41525: PUSH
41526: LD_VAR 0 9
41530: PUSH
41531: FOR_IN
41532: IFFALSE 41584
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41534: LD_ADDR_VAR 0 10
41538: PUSH
41539: LD_VAR 0 10
41543: PUSH
41544: LD_VAR 0 8
41548: PUSH
41549: LD_INT 1
41551: ARRAY
41552: PUSH
41553: LD_VAR 0 2
41557: PLUS
41558: PUSH
41559: LD_VAR 0 8
41563: PUSH
41564: LD_INT 2
41566: ARRAY
41567: PUSH
41568: LD_VAR 0 3
41572: PLUS
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PUSH
41578: EMPTY
41579: LIST
41580: ADD
41581: ST_TO_ADDR
41582: GO 41531
41584: POP
41585: POP
// result = temp_list2 ;
41586: LD_ADDR_VAR 0 7
41590: PUSH
41591: LD_VAR 0 10
41595: ST_TO_ADDR
// end ;
41596: LD_VAR 0 7
41600: RET
// export function EnemyInRange ( unit , dist ) ; begin
41601: LD_INT 0
41603: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41604: LD_ADDR_VAR 0 3
41608: PUSH
41609: LD_VAR 0 1
41613: PPUSH
41614: CALL_OW 255
41618: PPUSH
41619: LD_VAR 0 1
41623: PPUSH
41624: CALL_OW 250
41628: PPUSH
41629: LD_VAR 0 1
41633: PPUSH
41634: CALL_OW 251
41638: PPUSH
41639: LD_VAR 0 2
41643: PPUSH
41644: CALL 15693 0 4
41648: PUSH
41649: LD_INT 4
41651: ARRAY
41652: ST_TO_ADDR
// end ;
41653: LD_VAR 0 3
41657: RET
// export function PlayerSeeMe ( unit ) ; begin
41658: LD_INT 0
41660: PPUSH
// result := See ( your_side , unit ) ;
41661: LD_ADDR_VAR 0 2
41665: PUSH
41666: LD_OWVAR 2
41670: PPUSH
41671: LD_VAR 0 1
41675: PPUSH
41676: CALL_OW 292
41680: ST_TO_ADDR
// end ;
41681: LD_VAR 0 2
41685: RET
// export function ReverseDir ( unit ) ; begin
41686: LD_INT 0
41688: PPUSH
// if not unit then
41689: LD_VAR 0 1
41693: NOT
41694: IFFALSE 41698
// exit ;
41696: GO 41721
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41698: LD_ADDR_VAR 0 2
41702: PUSH
41703: LD_VAR 0 1
41707: PPUSH
41708: CALL_OW 254
41712: PUSH
41713: LD_INT 3
41715: PLUS
41716: PUSH
41717: LD_INT 6
41719: MOD
41720: ST_TO_ADDR
// end ;
41721: LD_VAR 0 2
41725: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41726: LD_INT 0
41728: PPUSH
41729: PPUSH
41730: PPUSH
41731: PPUSH
41732: PPUSH
// if not hexes then
41733: LD_VAR 0 2
41737: NOT
41738: IFFALSE 41742
// exit ;
41740: GO 41890
// dist := 9999 ;
41742: LD_ADDR_VAR 0 5
41746: PUSH
41747: LD_INT 9999
41749: ST_TO_ADDR
// for i = 1 to hexes do
41750: LD_ADDR_VAR 0 4
41754: PUSH
41755: DOUBLE
41756: LD_INT 1
41758: DEC
41759: ST_TO_ADDR
41760: LD_VAR 0 2
41764: PUSH
41765: FOR_TO
41766: IFFALSE 41878
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41768: LD_VAR 0 1
41772: PPUSH
41773: LD_VAR 0 2
41777: PUSH
41778: LD_VAR 0 4
41782: ARRAY
41783: PUSH
41784: LD_INT 1
41786: ARRAY
41787: PPUSH
41788: LD_VAR 0 2
41792: PUSH
41793: LD_VAR 0 4
41797: ARRAY
41798: PUSH
41799: LD_INT 2
41801: ARRAY
41802: PPUSH
41803: CALL_OW 297
41807: PUSH
41808: LD_VAR 0 5
41812: LESS
41813: IFFALSE 41876
// begin hex := hexes [ i ] ;
41815: LD_ADDR_VAR 0 7
41819: PUSH
41820: LD_VAR 0 2
41824: PUSH
41825: LD_VAR 0 4
41829: ARRAY
41830: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41831: LD_ADDR_VAR 0 5
41835: PUSH
41836: LD_VAR 0 1
41840: PPUSH
41841: LD_VAR 0 2
41845: PUSH
41846: LD_VAR 0 4
41850: ARRAY
41851: PUSH
41852: LD_INT 1
41854: ARRAY
41855: PPUSH
41856: LD_VAR 0 2
41860: PUSH
41861: LD_VAR 0 4
41865: ARRAY
41866: PUSH
41867: LD_INT 2
41869: ARRAY
41870: PPUSH
41871: CALL_OW 297
41875: ST_TO_ADDR
// end ; end ;
41876: GO 41765
41878: POP
41879: POP
// result := hex ;
41880: LD_ADDR_VAR 0 3
41884: PUSH
41885: LD_VAR 0 7
41889: ST_TO_ADDR
// end ;
41890: LD_VAR 0 3
41894: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41895: LD_INT 0
41897: PPUSH
41898: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41899: LD_VAR 0 1
41903: NOT
41904: PUSH
41905: LD_VAR 0 1
41909: PUSH
41910: LD_INT 21
41912: PUSH
41913: LD_INT 2
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 23
41922: PUSH
41923: LD_INT 2
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PPUSH
41934: CALL_OW 69
41938: IN
41939: NOT
41940: OR
41941: IFFALSE 41945
// exit ;
41943: GO 41992
// for i = 1 to 3 do
41945: LD_ADDR_VAR 0 3
41949: PUSH
41950: DOUBLE
41951: LD_INT 1
41953: DEC
41954: ST_TO_ADDR
41955: LD_INT 3
41957: PUSH
41958: FOR_TO
41959: IFFALSE 41990
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41961: LD_VAR 0 1
41965: PPUSH
41966: CALL_OW 250
41970: PPUSH
41971: LD_VAR 0 1
41975: PPUSH
41976: CALL_OW 251
41980: PPUSH
41981: LD_INT 1
41983: PPUSH
41984: CALL_OW 453
41988: GO 41958
41990: POP
41991: POP
// end ;
41992: LD_VAR 0 2
41996: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41997: LD_INT 0
41999: PPUSH
42000: PPUSH
42001: PPUSH
42002: PPUSH
42003: PPUSH
42004: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42005: LD_VAR 0 1
42009: NOT
42010: PUSH
42011: LD_VAR 0 2
42015: NOT
42016: OR
42017: PUSH
42018: LD_VAR 0 1
42022: PPUSH
42023: CALL_OW 314
42027: OR
42028: IFFALSE 42032
// exit ;
42030: GO 42473
// x := GetX ( enemy_unit ) ;
42032: LD_ADDR_VAR 0 7
42036: PUSH
42037: LD_VAR 0 2
42041: PPUSH
42042: CALL_OW 250
42046: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42047: LD_ADDR_VAR 0 8
42051: PUSH
42052: LD_VAR 0 2
42056: PPUSH
42057: CALL_OW 251
42061: ST_TO_ADDR
// if not x or not y then
42062: LD_VAR 0 7
42066: NOT
42067: PUSH
42068: LD_VAR 0 8
42072: NOT
42073: OR
42074: IFFALSE 42078
// exit ;
42076: GO 42473
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42078: LD_ADDR_VAR 0 6
42082: PUSH
42083: LD_VAR 0 7
42087: PPUSH
42088: LD_INT 0
42090: PPUSH
42091: LD_INT 4
42093: PPUSH
42094: CALL_OW 272
42098: PUSH
42099: LD_VAR 0 8
42103: PPUSH
42104: LD_INT 0
42106: PPUSH
42107: LD_INT 4
42109: PPUSH
42110: CALL_OW 273
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_VAR 0 7
42123: PPUSH
42124: LD_INT 1
42126: PPUSH
42127: LD_INT 4
42129: PPUSH
42130: CALL_OW 272
42134: PUSH
42135: LD_VAR 0 8
42139: PPUSH
42140: LD_INT 1
42142: PPUSH
42143: LD_INT 4
42145: PPUSH
42146: CALL_OW 273
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_VAR 0 7
42159: PPUSH
42160: LD_INT 2
42162: PPUSH
42163: LD_INT 4
42165: PPUSH
42166: CALL_OW 272
42170: PUSH
42171: LD_VAR 0 8
42175: PPUSH
42176: LD_INT 2
42178: PPUSH
42179: LD_INT 4
42181: PPUSH
42182: CALL_OW 273
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_VAR 0 7
42195: PPUSH
42196: LD_INT 3
42198: PPUSH
42199: LD_INT 4
42201: PPUSH
42202: CALL_OW 272
42206: PUSH
42207: LD_VAR 0 8
42211: PPUSH
42212: LD_INT 3
42214: PPUSH
42215: LD_INT 4
42217: PPUSH
42218: CALL_OW 273
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_VAR 0 7
42231: PPUSH
42232: LD_INT 4
42234: PPUSH
42235: LD_INT 4
42237: PPUSH
42238: CALL_OW 272
42242: PUSH
42243: LD_VAR 0 8
42247: PPUSH
42248: LD_INT 4
42250: PPUSH
42251: LD_INT 4
42253: PPUSH
42254: CALL_OW 273
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_VAR 0 7
42267: PPUSH
42268: LD_INT 5
42270: PPUSH
42271: LD_INT 4
42273: PPUSH
42274: CALL_OW 272
42278: PUSH
42279: LD_VAR 0 8
42283: PPUSH
42284: LD_INT 5
42286: PPUSH
42287: LD_INT 4
42289: PPUSH
42290: CALL_OW 273
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: ST_TO_ADDR
// for i = tmp downto 1 do
42307: LD_ADDR_VAR 0 4
42311: PUSH
42312: DOUBLE
42313: LD_VAR 0 6
42317: INC
42318: ST_TO_ADDR
42319: LD_INT 1
42321: PUSH
42322: FOR_DOWNTO
42323: IFFALSE 42424
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42325: LD_VAR 0 6
42329: PUSH
42330: LD_VAR 0 4
42334: ARRAY
42335: PUSH
42336: LD_INT 1
42338: ARRAY
42339: PPUSH
42340: LD_VAR 0 6
42344: PUSH
42345: LD_VAR 0 4
42349: ARRAY
42350: PUSH
42351: LD_INT 2
42353: ARRAY
42354: PPUSH
42355: CALL_OW 488
42359: NOT
42360: PUSH
42361: LD_VAR 0 6
42365: PUSH
42366: LD_VAR 0 4
42370: ARRAY
42371: PUSH
42372: LD_INT 1
42374: ARRAY
42375: PPUSH
42376: LD_VAR 0 6
42380: PUSH
42381: LD_VAR 0 4
42385: ARRAY
42386: PUSH
42387: LD_INT 2
42389: ARRAY
42390: PPUSH
42391: CALL_OW 428
42395: PUSH
42396: LD_INT 0
42398: NONEQUAL
42399: OR
42400: IFFALSE 42422
// tmp := Delete ( tmp , i ) ;
42402: LD_ADDR_VAR 0 6
42406: PUSH
42407: LD_VAR 0 6
42411: PPUSH
42412: LD_VAR 0 4
42416: PPUSH
42417: CALL_OW 3
42421: ST_TO_ADDR
42422: GO 42322
42424: POP
42425: POP
// j := GetClosestHex ( unit , tmp ) ;
42426: LD_ADDR_VAR 0 5
42430: PUSH
42431: LD_VAR 0 1
42435: PPUSH
42436: LD_VAR 0 6
42440: PPUSH
42441: CALL 41726 0 2
42445: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42446: LD_VAR 0 1
42450: PPUSH
42451: LD_VAR 0 5
42455: PUSH
42456: LD_INT 1
42458: ARRAY
42459: PPUSH
42460: LD_VAR 0 5
42464: PUSH
42465: LD_INT 2
42467: ARRAY
42468: PPUSH
42469: CALL_OW 111
// end ;
42473: LD_VAR 0 3
42477: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42478: LD_INT 0
42480: PPUSH
42481: PPUSH
42482: PPUSH
// uc_side = 0 ;
42483: LD_ADDR_OWVAR 20
42487: PUSH
42488: LD_INT 0
42490: ST_TO_ADDR
// uc_nation = 0 ;
42491: LD_ADDR_OWVAR 21
42495: PUSH
42496: LD_INT 0
42498: ST_TO_ADDR
// InitHc_All ( ) ;
42499: CALL_OW 584
// InitVc ;
42503: CALL_OW 20
// if mastodonts then
42507: LD_VAR 0 6
42511: IFFALSE 42578
// for i = 1 to mastodonts do
42513: LD_ADDR_VAR 0 11
42517: PUSH
42518: DOUBLE
42519: LD_INT 1
42521: DEC
42522: ST_TO_ADDR
42523: LD_VAR 0 6
42527: PUSH
42528: FOR_TO
42529: IFFALSE 42576
// begin vc_chassis := 31 ;
42531: LD_ADDR_OWVAR 37
42535: PUSH
42536: LD_INT 31
42538: ST_TO_ADDR
// vc_control := control_rider ;
42539: LD_ADDR_OWVAR 38
42543: PUSH
42544: LD_INT 4
42546: ST_TO_ADDR
// animal := CreateVehicle ;
42547: LD_ADDR_VAR 0 12
42551: PUSH
42552: CALL_OW 45
42556: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42557: LD_VAR 0 12
42561: PPUSH
42562: LD_VAR 0 8
42566: PPUSH
42567: LD_INT 0
42569: PPUSH
42570: CALL 44766 0 3
// end ;
42574: GO 42528
42576: POP
42577: POP
// if horses then
42578: LD_VAR 0 5
42582: IFFALSE 42649
// for i = 1 to horses do
42584: LD_ADDR_VAR 0 11
42588: PUSH
42589: DOUBLE
42590: LD_INT 1
42592: DEC
42593: ST_TO_ADDR
42594: LD_VAR 0 5
42598: PUSH
42599: FOR_TO
42600: IFFALSE 42647
// begin hc_class := 21 ;
42602: LD_ADDR_OWVAR 28
42606: PUSH
42607: LD_INT 21
42609: ST_TO_ADDR
// hc_gallery :=  ;
42610: LD_ADDR_OWVAR 33
42614: PUSH
42615: LD_STRING 
42617: ST_TO_ADDR
// animal := CreateHuman ;
42618: LD_ADDR_VAR 0 12
42622: PUSH
42623: CALL_OW 44
42627: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42628: LD_VAR 0 12
42632: PPUSH
42633: LD_VAR 0 8
42637: PPUSH
42638: LD_INT 0
42640: PPUSH
42641: CALL 44766 0 3
// end ;
42645: GO 42599
42647: POP
42648: POP
// if birds then
42649: LD_VAR 0 1
42653: IFFALSE 42720
// for i = 1 to birds do
42655: LD_ADDR_VAR 0 11
42659: PUSH
42660: DOUBLE
42661: LD_INT 1
42663: DEC
42664: ST_TO_ADDR
42665: LD_VAR 0 1
42669: PUSH
42670: FOR_TO
42671: IFFALSE 42718
// begin hc_class = 18 ;
42673: LD_ADDR_OWVAR 28
42677: PUSH
42678: LD_INT 18
42680: ST_TO_ADDR
// hc_gallery =  ;
42681: LD_ADDR_OWVAR 33
42685: PUSH
42686: LD_STRING 
42688: ST_TO_ADDR
// animal := CreateHuman ;
42689: LD_ADDR_VAR 0 12
42693: PUSH
42694: CALL_OW 44
42698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42699: LD_VAR 0 12
42703: PPUSH
42704: LD_VAR 0 8
42708: PPUSH
42709: LD_INT 0
42711: PPUSH
42712: CALL 44766 0 3
// end ;
42716: GO 42670
42718: POP
42719: POP
// if tigers then
42720: LD_VAR 0 2
42724: IFFALSE 42808
// for i = 1 to tigers do
42726: LD_ADDR_VAR 0 11
42730: PUSH
42731: DOUBLE
42732: LD_INT 1
42734: DEC
42735: ST_TO_ADDR
42736: LD_VAR 0 2
42740: PUSH
42741: FOR_TO
42742: IFFALSE 42806
// begin hc_class = class_tiger ;
42744: LD_ADDR_OWVAR 28
42748: PUSH
42749: LD_INT 14
42751: ST_TO_ADDR
// hc_gallery =  ;
42752: LD_ADDR_OWVAR 33
42756: PUSH
42757: LD_STRING 
42759: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42760: LD_ADDR_OWVAR 35
42764: PUSH
42765: LD_INT 7
42767: NEG
42768: PPUSH
42769: LD_INT 7
42771: PPUSH
42772: CALL_OW 12
42776: ST_TO_ADDR
// animal := CreateHuman ;
42777: LD_ADDR_VAR 0 12
42781: PUSH
42782: CALL_OW 44
42786: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42787: LD_VAR 0 12
42791: PPUSH
42792: LD_VAR 0 8
42796: PPUSH
42797: LD_INT 0
42799: PPUSH
42800: CALL 44766 0 3
// end ;
42804: GO 42741
42806: POP
42807: POP
// if apemans then
42808: LD_VAR 0 3
42812: IFFALSE 42935
// for i = 1 to apemans do
42814: LD_ADDR_VAR 0 11
42818: PUSH
42819: DOUBLE
42820: LD_INT 1
42822: DEC
42823: ST_TO_ADDR
42824: LD_VAR 0 3
42828: PUSH
42829: FOR_TO
42830: IFFALSE 42933
// begin hc_class = class_apeman ;
42832: LD_ADDR_OWVAR 28
42836: PUSH
42837: LD_INT 12
42839: ST_TO_ADDR
// hc_gallery =  ;
42840: LD_ADDR_OWVAR 33
42844: PUSH
42845: LD_STRING 
42847: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42848: LD_ADDR_OWVAR 35
42852: PUSH
42853: LD_INT 5
42855: NEG
42856: PPUSH
42857: LD_INT 5
42859: PPUSH
42860: CALL_OW 12
42864: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42865: LD_ADDR_OWVAR 31
42869: PUSH
42870: LD_INT 1
42872: PPUSH
42873: LD_INT 3
42875: PPUSH
42876: CALL_OW 12
42880: PUSH
42881: LD_INT 1
42883: PPUSH
42884: LD_INT 3
42886: PPUSH
42887: CALL_OW 12
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: LIST
42902: LIST
42903: ST_TO_ADDR
// animal := CreateHuman ;
42904: LD_ADDR_VAR 0 12
42908: PUSH
42909: CALL_OW 44
42913: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42914: LD_VAR 0 12
42918: PPUSH
42919: LD_VAR 0 8
42923: PPUSH
42924: LD_INT 0
42926: PPUSH
42927: CALL 44766 0 3
// end ;
42931: GO 42829
42933: POP
42934: POP
// if enchidnas then
42935: LD_VAR 0 4
42939: IFFALSE 43006
// for i = 1 to enchidnas do
42941: LD_ADDR_VAR 0 11
42945: PUSH
42946: DOUBLE
42947: LD_INT 1
42949: DEC
42950: ST_TO_ADDR
42951: LD_VAR 0 4
42955: PUSH
42956: FOR_TO
42957: IFFALSE 43004
// begin hc_class = 13 ;
42959: LD_ADDR_OWVAR 28
42963: PUSH
42964: LD_INT 13
42966: ST_TO_ADDR
// hc_gallery =  ;
42967: LD_ADDR_OWVAR 33
42971: PUSH
42972: LD_STRING 
42974: ST_TO_ADDR
// animal := CreateHuman ;
42975: LD_ADDR_VAR 0 12
42979: PUSH
42980: CALL_OW 44
42984: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42985: LD_VAR 0 12
42989: PPUSH
42990: LD_VAR 0 8
42994: PPUSH
42995: LD_INT 0
42997: PPUSH
42998: CALL 44766 0 3
// end ;
43002: GO 42956
43004: POP
43005: POP
// if fishes then
43006: LD_VAR 0 7
43010: IFFALSE 43077
// for i = 1 to fishes do
43012: LD_ADDR_VAR 0 11
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 7
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43075
// begin hc_class = 20 ;
43030: LD_ADDR_OWVAR 28
43034: PUSH
43035: LD_INT 20
43037: ST_TO_ADDR
// hc_gallery =  ;
43038: LD_ADDR_OWVAR 33
43042: PUSH
43043: LD_STRING 
43045: ST_TO_ADDR
// animal := CreateHuman ;
43046: LD_ADDR_VAR 0 12
43050: PUSH
43051: CALL_OW 44
43055: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43056: LD_VAR 0 12
43060: PPUSH
43061: LD_VAR 0 9
43065: PPUSH
43066: LD_INT 0
43068: PPUSH
43069: CALL 44766 0 3
// end ;
43073: GO 43027
43075: POP
43076: POP
// end ;
43077: LD_VAR 0 10
43081: RET
// export function WantHeal ( sci , unit ) ; begin
43082: LD_INT 0
43084: PPUSH
// if GetTaskList ( sci ) > 0 then
43085: LD_VAR 0 1
43089: PPUSH
43090: CALL_OW 437
43094: PUSH
43095: LD_INT 0
43097: GREATER
43098: IFFALSE 43168
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43100: LD_VAR 0 1
43104: PPUSH
43105: CALL_OW 437
43109: PUSH
43110: LD_INT 1
43112: ARRAY
43113: PUSH
43114: LD_INT 1
43116: ARRAY
43117: PUSH
43118: LD_STRING l
43120: EQUAL
43121: PUSH
43122: LD_VAR 0 1
43126: PPUSH
43127: CALL_OW 437
43131: PUSH
43132: LD_INT 1
43134: ARRAY
43135: PUSH
43136: LD_INT 4
43138: ARRAY
43139: PUSH
43140: LD_VAR 0 2
43144: EQUAL
43145: AND
43146: IFFALSE 43158
// result := true else
43148: LD_ADDR_VAR 0 3
43152: PUSH
43153: LD_INT 1
43155: ST_TO_ADDR
43156: GO 43166
// result := false ;
43158: LD_ADDR_VAR 0 3
43162: PUSH
43163: LD_INT 0
43165: ST_TO_ADDR
// end else
43166: GO 43176
// result := false ;
43168: LD_ADDR_VAR 0 3
43172: PUSH
43173: LD_INT 0
43175: ST_TO_ADDR
// end ;
43176: LD_VAR 0 3
43180: RET
// export function HealTarget ( sci ) ; begin
43181: LD_INT 0
43183: PPUSH
// if not sci then
43184: LD_VAR 0 1
43188: NOT
43189: IFFALSE 43193
// exit ;
43191: GO 43258
// result := 0 ;
43193: LD_ADDR_VAR 0 2
43197: PUSH
43198: LD_INT 0
43200: ST_TO_ADDR
// if GetTaskList ( sci ) then
43201: LD_VAR 0 1
43205: PPUSH
43206: CALL_OW 437
43210: IFFALSE 43258
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43212: LD_VAR 0 1
43216: PPUSH
43217: CALL_OW 437
43221: PUSH
43222: LD_INT 1
43224: ARRAY
43225: PUSH
43226: LD_INT 1
43228: ARRAY
43229: PUSH
43230: LD_STRING l
43232: EQUAL
43233: IFFALSE 43258
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43235: LD_ADDR_VAR 0 2
43239: PUSH
43240: LD_VAR 0 1
43244: PPUSH
43245: CALL_OW 437
43249: PUSH
43250: LD_INT 1
43252: ARRAY
43253: PUSH
43254: LD_INT 4
43256: ARRAY
43257: ST_TO_ADDR
// end ;
43258: LD_VAR 0 2
43262: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43263: LD_INT 0
43265: PPUSH
43266: PPUSH
43267: PPUSH
43268: PPUSH
// if not base_units then
43269: LD_VAR 0 1
43273: NOT
43274: IFFALSE 43278
// exit ;
43276: GO 43365
// result := false ;
43278: LD_ADDR_VAR 0 2
43282: PUSH
43283: LD_INT 0
43285: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43286: LD_ADDR_VAR 0 5
43290: PUSH
43291: LD_VAR 0 1
43295: PPUSH
43296: LD_INT 21
43298: PUSH
43299: LD_INT 3
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PPUSH
43306: CALL_OW 72
43310: ST_TO_ADDR
// if not tmp then
43311: LD_VAR 0 5
43315: NOT
43316: IFFALSE 43320
// exit ;
43318: GO 43365
// for i in tmp do
43320: LD_ADDR_VAR 0 3
43324: PUSH
43325: LD_VAR 0 5
43329: PUSH
43330: FOR_IN
43331: IFFALSE 43363
// begin result := EnemyInRange ( i , 22 ) ;
43333: LD_ADDR_VAR 0 2
43337: PUSH
43338: LD_VAR 0 3
43342: PPUSH
43343: LD_INT 22
43345: PPUSH
43346: CALL 41601 0 2
43350: ST_TO_ADDR
// if result then
43351: LD_VAR 0 2
43355: IFFALSE 43361
// exit ;
43357: POP
43358: POP
43359: GO 43365
// end ;
43361: GO 43330
43363: POP
43364: POP
// end ;
43365: LD_VAR 0 2
43369: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43370: LD_INT 0
43372: PPUSH
43373: PPUSH
// if not units then
43374: LD_VAR 0 1
43378: NOT
43379: IFFALSE 43383
// exit ;
43381: GO 43453
// result := [ ] ;
43383: LD_ADDR_VAR 0 3
43387: PUSH
43388: EMPTY
43389: ST_TO_ADDR
// for i in units do
43390: LD_ADDR_VAR 0 4
43394: PUSH
43395: LD_VAR 0 1
43399: PUSH
43400: FOR_IN
43401: IFFALSE 43451
// if GetTag ( i ) = tag then
43403: LD_VAR 0 4
43407: PPUSH
43408: CALL_OW 110
43412: PUSH
43413: LD_VAR 0 2
43417: EQUAL
43418: IFFALSE 43449
// result := Insert ( result , result + 1 , i ) ;
43420: LD_ADDR_VAR 0 3
43424: PUSH
43425: LD_VAR 0 3
43429: PPUSH
43430: LD_VAR 0 3
43434: PUSH
43435: LD_INT 1
43437: PLUS
43438: PPUSH
43439: LD_VAR 0 4
43443: PPUSH
43444: CALL_OW 2
43448: ST_TO_ADDR
43449: GO 43400
43451: POP
43452: POP
// end ;
43453: LD_VAR 0 3
43457: RET
// export function IsDriver ( un ) ; begin
43458: LD_INT 0
43460: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43461: LD_ADDR_VAR 0 2
43465: PUSH
43466: LD_VAR 0 1
43470: PUSH
43471: LD_INT 55
43473: PUSH
43474: EMPTY
43475: LIST
43476: PPUSH
43477: CALL_OW 69
43481: IN
43482: ST_TO_ADDR
// end ;
43483: LD_VAR 0 2
43487: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43488: LD_INT 0
43490: PPUSH
43491: PPUSH
// list := [ ] ;
43492: LD_ADDR_VAR 0 5
43496: PUSH
43497: EMPTY
43498: ST_TO_ADDR
// case d of 0 :
43499: LD_VAR 0 3
43503: PUSH
43504: LD_INT 0
43506: DOUBLE
43507: EQUAL
43508: IFTRUE 43512
43510: GO 43645
43512: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43513: LD_ADDR_VAR 0 5
43517: PUSH
43518: LD_VAR 0 1
43522: PUSH
43523: LD_INT 4
43525: MINUS
43526: PUSH
43527: LD_VAR 0 2
43531: PUSH
43532: LD_INT 4
43534: MINUS
43535: PUSH
43536: LD_INT 2
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: LIST
43543: PUSH
43544: LD_VAR 0 1
43548: PUSH
43549: LD_INT 3
43551: MINUS
43552: PUSH
43553: LD_VAR 0 2
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: LIST
43565: PUSH
43566: LD_VAR 0 1
43570: PUSH
43571: LD_INT 4
43573: PLUS
43574: PUSH
43575: LD_VAR 0 2
43579: PUSH
43580: LD_INT 4
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: LIST
43587: PUSH
43588: LD_VAR 0 1
43592: PUSH
43593: LD_INT 3
43595: PLUS
43596: PUSH
43597: LD_VAR 0 2
43601: PUSH
43602: LD_INT 3
43604: PLUS
43605: PUSH
43606: LD_INT 5
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: LIST
43613: PUSH
43614: LD_VAR 0 1
43618: PUSH
43619: LD_VAR 0 2
43623: PUSH
43624: LD_INT 4
43626: PLUS
43627: PUSH
43628: LD_INT 0
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: LIST
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: ST_TO_ADDR
// end ; 1 :
43643: GO 44343
43645: LD_INT 1
43647: DOUBLE
43648: EQUAL
43649: IFTRUE 43653
43651: GO 43786
43653: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43654: LD_ADDR_VAR 0 5
43658: PUSH
43659: LD_VAR 0 1
43663: PUSH
43664: LD_VAR 0 2
43668: PUSH
43669: LD_INT 4
43671: MINUS
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: LIST
43680: PUSH
43681: LD_VAR 0 1
43685: PUSH
43686: LD_INT 3
43688: MINUS
43689: PUSH
43690: LD_VAR 0 2
43694: PUSH
43695: LD_INT 3
43697: MINUS
43698: PUSH
43699: LD_INT 2
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: LIST
43706: PUSH
43707: LD_VAR 0 1
43711: PUSH
43712: LD_INT 4
43714: MINUS
43715: PUSH
43716: LD_VAR 0 2
43720: PUSH
43721: LD_INT 1
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: LIST
43728: PUSH
43729: LD_VAR 0 1
43733: PUSH
43734: LD_VAR 0 2
43738: PUSH
43739: LD_INT 3
43741: PLUS
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: LIST
43750: PUSH
43751: LD_VAR 0 1
43755: PUSH
43756: LD_INT 4
43758: PLUS
43759: PUSH
43760: LD_VAR 0 2
43764: PUSH
43765: LD_INT 4
43767: PLUS
43768: PUSH
43769: LD_INT 5
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: LIST
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: ST_TO_ADDR
// end ; 2 :
43784: GO 44343
43786: LD_INT 2
43788: DOUBLE
43789: EQUAL
43790: IFTRUE 43794
43792: GO 43923
43794: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43795: LD_ADDR_VAR 0 5
43799: PUSH
43800: LD_VAR 0 1
43804: PUSH
43805: LD_VAR 0 2
43809: PUSH
43810: LD_INT 3
43812: MINUS
43813: PUSH
43814: LD_INT 3
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: LIST
43821: PUSH
43822: LD_VAR 0 1
43826: PUSH
43827: LD_INT 4
43829: PLUS
43830: PUSH
43831: LD_VAR 0 2
43835: PUSH
43836: LD_INT 4
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: LIST
43843: PUSH
43844: LD_VAR 0 1
43848: PUSH
43849: LD_VAR 0 2
43853: PUSH
43854: LD_INT 4
43856: PLUS
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: LIST
43865: PUSH
43866: LD_VAR 0 1
43870: PUSH
43871: LD_INT 3
43873: MINUS
43874: PUSH
43875: LD_VAR 0 2
43879: PUSH
43880: LD_INT 1
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: LIST
43887: PUSH
43888: LD_VAR 0 1
43892: PUSH
43893: LD_INT 4
43895: MINUS
43896: PUSH
43897: LD_VAR 0 2
43901: PUSH
43902: LD_INT 4
43904: MINUS
43905: PUSH
43906: LD_INT 2
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: LIST
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: ST_TO_ADDR
// end ; 3 :
43921: GO 44343
43923: LD_INT 3
43925: DOUBLE
43926: EQUAL
43927: IFTRUE 43931
43929: GO 44064
43931: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43932: LD_ADDR_VAR 0 5
43936: PUSH
43937: LD_VAR 0 1
43941: PUSH
43942: LD_INT 3
43944: PLUS
43945: PUSH
43946: LD_VAR 0 2
43950: PUSH
43951: LD_INT 4
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: LIST
43958: PUSH
43959: LD_VAR 0 1
43963: PUSH
43964: LD_INT 4
43966: PLUS
43967: PUSH
43968: LD_VAR 0 2
43972: PUSH
43973: LD_INT 4
43975: PLUS
43976: PUSH
43977: LD_INT 5
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: LIST
43984: PUSH
43985: LD_VAR 0 1
43989: PUSH
43990: LD_INT 4
43992: MINUS
43993: PUSH
43994: LD_VAR 0 2
43998: PUSH
43999: LD_INT 1
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: LIST
44006: PUSH
44007: LD_VAR 0 1
44011: PUSH
44012: LD_VAR 0 2
44016: PUSH
44017: LD_INT 4
44019: MINUS
44020: PUSH
44021: LD_INT 3
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: LIST
44028: PUSH
44029: LD_VAR 0 1
44033: PUSH
44034: LD_INT 3
44036: MINUS
44037: PUSH
44038: LD_VAR 0 2
44042: PUSH
44043: LD_INT 3
44045: MINUS
44046: PUSH
44047: LD_INT 2
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: ST_TO_ADDR
// end ; 4 :
44062: GO 44343
44064: LD_INT 4
44066: DOUBLE
44067: EQUAL
44068: IFTRUE 44072
44070: GO 44205
44072: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44073: LD_ADDR_VAR 0 5
44077: PUSH
44078: LD_VAR 0 1
44082: PUSH
44083: LD_VAR 0 2
44087: PUSH
44088: LD_INT 4
44090: PLUS
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: LIST
44099: PUSH
44100: LD_VAR 0 1
44104: PUSH
44105: LD_INT 3
44107: PLUS
44108: PUSH
44109: LD_VAR 0 2
44113: PUSH
44114: LD_INT 3
44116: PLUS
44117: PUSH
44118: LD_INT 5
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: LIST
44125: PUSH
44126: LD_VAR 0 1
44130: PUSH
44131: LD_INT 4
44133: PLUS
44134: PUSH
44135: LD_VAR 0 2
44139: PUSH
44140: LD_INT 4
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: LIST
44147: PUSH
44148: LD_VAR 0 1
44152: PUSH
44153: LD_VAR 0 2
44157: PUSH
44158: LD_INT 3
44160: MINUS
44161: PUSH
44162: LD_INT 3
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: LIST
44169: PUSH
44170: LD_VAR 0 1
44174: PUSH
44175: LD_INT 4
44177: MINUS
44178: PUSH
44179: LD_VAR 0 2
44183: PUSH
44184: LD_INT 4
44186: MINUS
44187: PUSH
44188: LD_INT 2
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: LIST
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: ST_TO_ADDR
// end ; 5 :
44203: GO 44343
44205: LD_INT 5
44207: DOUBLE
44208: EQUAL
44209: IFTRUE 44213
44211: GO 44342
44213: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44214: LD_ADDR_VAR 0 5
44218: PUSH
44219: LD_VAR 0 1
44223: PUSH
44224: LD_INT 4
44226: MINUS
44227: PUSH
44228: LD_VAR 0 2
44232: PUSH
44233: LD_INT 1
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: LIST
44240: PUSH
44241: LD_VAR 0 1
44245: PUSH
44246: LD_VAR 0 2
44250: PUSH
44251: LD_INT 4
44253: MINUS
44254: PUSH
44255: LD_INT 3
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: LIST
44262: PUSH
44263: LD_VAR 0 1
44267: PUSH
44268: LD_INT 4
44270: PLUS
44271: PUSH
44272: LD_VAR 0 2
44276: PUSH
44277: LD_INT 4
44279: PLUS
44280: PUSH
44281: LD_INT 5
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: LIST
44288: PUSH
44289: LD_VAR 0 1
44293: PUSH
44294: LD_INT 3
44296: PLUS
44297: PUSH
44298: LD_VAR 0 2
44302: PUSH
44303: LD_INT 4
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: LIST
44310: PUSH
44311: LD_VAR 0 1
44315: PUSH
44316: LD_VAR 0 2
44320: PUSH
44321: LD_INT 3
44323: PLUS
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: ST_TO_ADDR
// end ; end ;
44340: GO 44343
44342: POP
// result := list ;
44343: LD_ADDR_VAR 0 4
44347: PUSH
44348: LD_VAR 0 5
44352: ST_TO_ADDR
// end ;
44353: LD_VAR 0 4
44357: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44358: LD_INT 0
44360: PPUSH
44361: PPUSH
44362: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44363: LD_VAR 0 1
44367: NOT
44368: PUSH
44369: LD_VAR 0 2
44373: PUSH
44374: LD_INT 1
44376: PUSH
44377: LD_INT 2
44379: PUSH
44380: LD_INT 3
44382: PUSH
44383: LD_INT 4
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: IN
44392: NOT
44393: OR
44394: IFFALSE 44398
// exit ;
44396: GO 44490
// tmp := [ ] ;
44398: LD_ADDR_VAR 0 5
44402: PUSH
44403: EMPTY
44404: ST_TO_ADDR
// for i in units do
44405: LD_ADDR_VAR 0 4
44409: PUSH
44410: LD_VAR 0 1
44414: PUSH
44415: FOR_IN
44416: IFFALSE 44459
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44418: LD_ADDR_VAR 0 5
44422: PUSH
44423: LD_VAR 0 5
44427: PPUSH
44428: LD_VAR 0 5
44432: PUSH
44433: LD_INT 1
44435: PLUS
44436: PPUSH
44437: LD_VAR 0 4
44441: PPUSH
44442: LD_VAR 0 2
44446: PPUSH
44447: CALL_OW 259
44451: PPUSH
44452: CALL_OW 2
44456: ST_TO_ADDR
44457: GO 44415
44459: POP
44460: POP
// if not tmp then
44461: LD_VAR 0 5
44465: NOT
44466: IFFALSE 44470
// exit ;
44468: GO 44490
// result := SortListByListDesc ( units , tmp ) ;
44470: LD_ADDR_VAR 0 3
44474: PUSH
44475: LD_VAR 0 1
44479: PPUSH
44480: LD_VAR 0 5
44484: PPUSH
44485: CALL_OW 77
44489: ST_TO_ADDR
// end ;
44490: LD_VAR 0 3
44494: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44495: LD_INT 0
44497: PPUSH
44498: PPUSH
44499: PPUSH
// result := false ;
44500: LD_ADDR_VAR 0 3
44504: PUSH
44505: LD_INT 0
44507: ST_TO_ADDR
// x := GetX ( building ) ;
44508: LD_ADDR_VAR 0 4
44512: PUSH
44513: LD_VAR 0 2
44517: PPUSH
44518: CALL_OW 250
44522: ST_TO_ADDR
// y := GetY ( building ) ;
44523: LD_ADDR_VAR 0 5
44527: PUSH
44528: LD_VAR 0 2
44532: PPUSH
44533: CALL_OW 251
44537: ST_TO_ADDR
// if not building or not x or not y then
44538: LD_VAR 0 2
44542: NOT
44543: PUSH
44544: LD_VAR 0 4
44548: NOT
44549: OR
44550: PUSH
44551: LD_VAR 0 5
44555: NOT
44556: OR
44557: IFFALSE 44561
// exit ;
44559: GO 44653
// if GetTaskList ( unit ) then
44561: LD_VAR 0 1
44565: PPUSH
44566: CALL_OW 437
44570: IFFALSE 44653
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44572: LD_STRING e
44574: PUSH
44575: LD_VAR 0 1
44579: PPUSH
44580: CALL_OW 437
44584: PUSH
44585: LD_INT 1
44587: ARRAY
44588: PUSH
44589: LD_INT 1
44591: ARRAY
44592: EQUAL
44593: PUSH
44594: LD_VAR 0 4
44598: PUSH
44599: LD_VAR 0 1
44603: PPUSH
44604: CALL_OW 437
44608: PUSH
44609: LD_INT 1
44611: ARRAY
44612: PUSH
44613: LD_INT 2
44615: ARRAY
44616: EQUAL
44617: AND
44618: PUSH
44619: LD_VAR 0 5
44623: PUSH
44624: LD_VAR 0 1
44628: PPUSH
44629: CALL_OW 437
44633: PUSH
44634: LD_INT 1
44636: ARRAY
44637: PUSH
44638: LD_INT 3
44640: ARRAY
44641: EQUAL
44642: AND
44643: IFFALSE 44653
// result := true end ;
44645: LD_ADDR_VAR 0 3
44649: PUSH
44650: LD_INT 1
44652: ST_TO_ADDR
// end ;
44653: LD_VAR 0 3
44657: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44658: LD_INT 0
44660: PPUSH
// result := false ;
44661: LD_ADDR_VAR 0 4
44665: PUSH
44666: LD_INT 0
44668: ST_TO_ADDR
// if GetTaskList ( unit ) then
44669: LD_VAR 0 1
44673: PPUSH
44674: CALL_OW 437
44678: IFFALSE 44761
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44680: LD_STRING M
44682: PUSH
44683: LD_VAR 0 1
44687: PPUSH
44688: CALL_OW 437
44692: PUSH
44693: LD_INT 1
44695: ARRAY
44696: PUSH
44697: LD_INT 1
44699: ARRAY
44700: EQUAL
44701: PUSH
44702: LD_VAR 0 2
44706: PUSH
44707: LD_VAR 0 1
44711: PPUSH
44712: CALL_OW 437
44716: PUSH
44717: LD_INT 1
44719: ARRAY
44720: PUSH
44721: LD_INT 2
44723: ARRAY
44724: EQUAL
44725: AND
44726: PUSH
44727: LD_VAR 0 3
44731: PUSH
44732: LD_VAR 0 1
44736: PPUSH
44737: CALL_OW 437
44741: PUSH
44742: LD_INT 1
44744: ARRAY
44745: PUSH
44746: LD_INT 3
44748: ARRAY
44749: EQUAL
44750: AND
44751: IFFALSE 44761
// result := true ;
44753: LD_ADDR_VAR 0 4
44757: PUSH
44758: LD_INT 1
44760: ST_TO_ADDR
// end ; end ;
44761: LD_VAR 0 4
44765: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44766: LD_INT 0
44768: PPUSH
44769: PPUSH
44770: PPUSH
44771: PPUSH
// if not unit or not area then
44772: LD_VAR 0 1
44776: NOT
44777: PUSH
44778: LD_VAR 0 2
44782: NOT
44783: OR
44784: IFFALSE 44788
// exit ;
44786: GO 44952
// tmp := AreaToList ( area , i ) ;
44788: LD_ADDR_VAR 0 6
44792: PUSH
44793: LD_VAR 0 2
44797: PPUSH
44798: LD_VAR 0 5
44802: PPUSH
44803: CALL_OW 517
44807: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44808: LD_ADDR_VAR 0 5
44812: PUSH
44813: DOUBLE
44814: LD_INT 1
44816: DEC
44817: ST_TO_ADDR
44818: LD_VAR 0 6
44822: PUSH
44823: LD_INT 1
44825: ARRAY
44826: PUSH
44827: FOR_TO
44828: IFFALSE 44950
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44830: LD_ADDR_VAR 0 7
44834: PUSH
44835: LD_VAR 0 6
44839: PUSH
44840: LD_INT 1
44842: ARRAY
44843: PUSH
44844: LD_VAR 0 5
44848: ARRAY
44849: PUSH
44850: LD_VAR 0 6
44854: PUSH
44855: LD_INT 2
44857: ARRAY
44858: PUSH
44859: LD_VAR 0 5
44863: ARRAY
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44869: LD_VAR 0 7
44873: PUSH
44874: LD_INT 1
44876: ARRAY
44877: PPUSH
44878: LD_VAR 0 7
44882: PUSH
44883: LD_INT 2
44885: ARRAY
44886: PPUSH
44887: CALL_OW 428
44891: PUSH
44892: LD_INT 0
44894: EQUAL
44895: IFFALSE 44948
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44897: LD_VAR 0 1
44901: PPUSH
44902: LD_VAR 0 7
44906: PUSH
44907: LD_INT 1
44909: ARRAY
44910: PPUSH
44911: LD_VAR 0 7
44915: PUSH
44916: LD_INT 2
44918: ARRAY
44919: PPUSH
44920: LD_VAR 0 3
44924: PPUSH
44925: CALL_OW 48
// result := IsPlaced ( unit ) ;
44929: LD_ADDR_VAR 0 4
44933: PUSH
44934: LD_VAR 0 1
44938: PPUSH
44939: CALL_OW 305
44943: ST_TO_ADDR
// exit ;
44944: POP
44945: POP
44946: GO 44952
// end ; end ;
44948: GO 44827
44950: POP
44951: POP
// end ;
44952: LD_VAR 0 4
44956: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44957: LD_INT 0
44959: PPUSH
44960: PPUSH
44961: PPUSH
// if not side or side > 8 then
44962: LD_VAR 0 1
44966: NOT
44967: PUSH
44968: LD_VAR 0 1
44972: PUSH
44973: LD_INT 8
44975: GREATER
44976: OR
44977: IFFALSE 44981
// exit ;
44979: GO 45168
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44981: LD_ADDR_VAR 0 4
44985: PUSH
44986: LD_INT 22
44988: PUSH
44989: LD_VAR 0 1
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 21
45000: PUSH
45001: LD_INT 3
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PPUSH
45012: CALL_OW 69
45016: ST_TO_ADDR
// if not tmp then
45017: LD_VAR 0 4
45021: NOT
45022: IFFALSE 45026
// exit ;
45024: GO 45168
// enable_addtolog := true ;
45026: LD_ADDR_OWVAR 81
45030: PUSH
45031: LD_INT 1
45033: ST_TO_ADDR
// AddToLog ( [ ) ;
45034: LD_STRING [
45036: PPUSH
45037: CALL_OW 561
// for i in tmp do
45041: LD_ADDR_VAR 0 3
45045: PUSH
45046: LD_VAR 0 4
45050: PUSH
45051: FOR_IN
45052: IFFALSE 45159
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45054: LD_STRING [
45056: PUSH
45057: LD_VAR 0 3
45061: PPUSH
45062: CALL_OW 266
45066: STR
45067: PUSH
45068: LD_STRING , 
45070: STR
45071: PUSH
45072: LD_VAR 0 3
45076: PPUSH
45077: CALL_OW 250
45081: STR
45082: PUSH
45083: LD_STRING , 
45085: STR
45086: PUSH
45087: LD_VAR 0 3
45091: PPUSH
45092: CALL_OW 251
45096: STR
45097: PUSH
45098: LD_STRING , 
45100: STR
45101: PUSH
45102: LD_VAR 0 3
45106: PPUSH
45107: CALL_OW 254
45111: STR
45112: PUSH
45113: LD_STRING , 
45115: STR
45116: PUSH
45117: LD_VAR 0 3
45121: PPUSH
45122: LD_INT 1
45124: PPUSH
45125: CALL_OW 268
45129: STR
45130: PUSH
45131: LD_STRING , 
45133: STR
45134: PUSH
45135: LD_VAR 0 3
45139: PPUSH
45140: LD_INT 2
45142: PPUSH
45143: CALL_OW 268
45147: STR
45148: PUSH
45149: LD_STRING ],
45151: STR
45152: PPUSH
45153: CALL_OW 561
// end ;
45157: GO 45051
45159: POP
45160: POP
// AddToLog ( ]; ) ;
45161: LD_STRING ];
45163: PPUSH
45164: CALL_OW 561
// end ;
45168: LD_VAR 0 2
45172: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45173: LD_INT 0
45175: PPUSH
45176: PPUSH
45177: PPUSH
45178: PPUSH
45179: PPUSH
// if not area or not rate or not max then
45180: LD_VAR 0 1
45184: NOT
45185: PUSH
45186: LD_VAR 0 2
45190: NOT
45191: OR
45192: PUSH
45193: LD_VAR 0 4
45197: NOT
45198: OR
45199: IFFALSE 45203
// exit ;
45201: GO 45395
// while 1 do
45203: LD_INT 1
45205: IFFALSE 45395
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45207: LD_ADDR_VAR 0 9
45211: PUSH
45212: LD_VAR 0 1
45216: PPUSH
45217: LD_INT 1
45219: PPUSH
45220: CALL_OW 287
45224: PUSH
45225: LD_INT 10
45227: MUL
45228: ST_TO_ADDR
// r := rate / 10 ;
45229: LD_ADDR_VAR 0 7
45233: PUSH
45234: LD_VAR 0 2
45238: PUSH
45239: LD_INT 10
45241: DIVREAL
45242: ST_TO_ADDR
// time := 1 1$00 ;
45243: LD_ADDR_VAR 0 8
45247: PUSH
45248: LD_INT 2100
45250: ST_TO_ADDR
// if amount < min then
45251: LD_VAR 0 9
45255: PUSH
45256: LD_VAR 0 3
45260: LESS
45261: IFFALSE 45279
// r := r * 2 else
45263: LD_ADDR_VAR 0 7
45267: PUSH
45268: LD_VAR 0 7
45272: PUSH
45273: LD_INT 2
45275: MUL
45276: ST_TO_ADDR
45277: GO 45305
// if amount > max then
45279: LD_VAR 0 9
45283: PUSH
45284: LD_VAR 0 4
45288: GREATER
45289: IFFALSE 45305
// r := r / 2 ;
45291: LD_ADDR_VAR 0 7
45295: PUSH
45296: LD_VAR 0 7
45300: PUSH
45301: LD_INT 2
45303: DIVREAL
45304: ST_TO_ADDR
// time := time / r ;
45305: LD_ADDR_VAR 0 8
45309: PUSH
45310: LD_VAR 0 8
45314: PUSH
45315: LD_VAR 0 7
45319: DIVREAL
45320: ST_TO_ADDR
// if time < 0 then
45321: LD_VAR 0 8
45325: PUSH
45326: LD_INT 0
45328: LESS
45329: IFFALSE 45346
// time := time * - 1 ;
45331: LD_ADDR_VAR 0 8
45335: PUSH
45336: LD_VAR 0 8
45340: PUSH
45341: LD_INT 1
45343: NEG
45344: MUL
45345: ST_TO_ADDR
// wait ( time ) ;
45346: LD_VAR 0 8
45350: PPUSH
45351: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45355: LD_INT 35
45357: PPUSH
45358: LD_INT 875
45360: PPUSH
45361: CALL_OW 12
45365: PPUSH
45366: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45370: LD_INT 1
45372: PPUSH
45373: LD_INT 5
45375: PPUSH
45376: CALL_OW 12
45380: PPUSH
45381: LD_VAR 0 1
45385: PPUSH
45386: LD_INT 1
45388: PPUSH
45389: CALL_OW 55
// end ;
45393: GO 45203
// end ;
45395: LD_VAR 0 5
45399: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45400: LD_INT 0
45402: PPUSH
45403: PPUSH
45404: PPUSH
45405: PPUSH
45406: PPUSH
45407: PPUSH
45408: PPUSH
45409: PPUSH
// if not turrets or not factories then
45410: LD_VAR 0 1
45414: NOT
45415: PUSH
45416: LD_VAR 0 2
45420: NOT
45421: OR
45422: IFFALSE 45426
// exit ;
45424: GO 45733
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45426: LD_ADDR_VAR 0 10
45430: PUSH
45431: LD_INT 5
45433: PUSH
45434: LD_INT 6
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 2
45443: PUSH
45444: LD_INT 4
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 3
45453: PUSH
45454: LD_INT 5
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 24
45468: PUSH
45469: LD_INT 25
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 23
45478: PUSH
45479: LD_INT 27
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: PUSH
45490: LD_INT 42
45492: PUSH
45493: LD_INT 43
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: PUSH
45500: LD_INT 44
45502: PUSH
45503: LD_INT 46
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 45
45512: PUSH
45513: LD_INT 47
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: ST_TO_ADDR
// result := [ ] ;
45530: LD_ADDR_VAR 0 3
45534: PUSH
45535: EMPTY
45536: ST_TO_ADDR
// for i in turrets do
45537: LD_ADDR_VAR 0 4
45541: PUSH
45542: LD_VAR 0 1
45546: PUSH
45547: FOR_IN
45548: IFFALSE 45731
// begin nat := GetNation ( i ) ;
45550: LD_ADDR_VAR 0 7
45554: PUSH
45555: LD_VAR 0 4
45559: PPUSH
45560: CALL_OW 248
45564: ST_TO_ADDR
// weapon := 0 ;
45565: LD_ADDR_VAR 0 8
45569: PUSH
45570: LD_INT 0
45572: ST_TO_ADDR
// if not nat then
45573: LD_VAR 0 7
45577: NOT
45578: IFFALSE 45582
// continue ;
45580: GO 45547
// for j in list [ nat ] do
45582: LD_ADDR_VAR 0 5
45586: PUSH
45587: LD_VAR 0 10
45591: PUSH
45592: LD_VAR 0 7
45596: ARRAY
45597: PUSH
45598: FOR_IN
45599: IFFALSE 45640
// if GetBWeapon ( i ) = j [ 1 ] then
45601: LD_VAR 0 4
45605: PPUSH
45606: CALL_OW 269
45610: PUSH
45611: LD_VAR 0 5
45615: PUSH
45616: LD_INT 1
45618: ARRAY
45619: EQUAL
45620: IFFALSE 45638
// begin weapon := j [ 2 ] ;
45622: LD_ADDR_VAR 0 8
45626: PUSH
45627: LD_VAR 0 5
45631: PUSH
45632: LD_INT 2
45634: ARRAY
45635: ST_TO_ADDR
// break ;
45636: GO 45640
// end ;
45638: GO 45598
45640: POP
45641: POP
// if not weapon then
45642: LD_VAR 0 8
45646: NOT
45647: IFFALSE 45651
// continue ;
45649: GO 45547
// for k in factories do
45651: LD_ADDR_VAR 0 6
45655: PUSH
45656: LD_VAR 0 2
45660: PUSH
45661: FOR_IN
45662: IFFALSE 45727
// begin weapons := AvailableWeaponList ( k ) ;
45664: LD_ADDR_VAR 0 9
45668: PUSH
45669: LD_VAR 0 6
45673: PPUSH
45674: CALL_OW 478
45678: ST_TO_ADDR
// if not weapons then
45679: LD_VAR 0 9
45683: NOT
45684: IFFALSE 45688
// continue ;
45686: GO 45661
// if weapon in weapons then
45688: LD_VAR 0 8
45692: PUSH
45693: LD_VAR 0 9
45697: IN
45698: IFFALSE 45725
// begin result := [ i , weapon ] ;
45700: LD_ADDR_VAR 0 3
45704: PUSH
45705: LD_VAR 0 4
45709: PUSH
45710: LD_VAR 0 8
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: ST_TO_ADDR
// exit ;
45719: POP
45720: POP
45721: POP
45722: POP
45723: GO 45733
// end ; end ;
45725: GO 45661
45727: POP
45728: POP
// end ;
45729: GO 45547
45731: POP
45732: POP
// end ;
45733: LD_VAR 0 3
45737: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45738: LD_INT 0
45740: PPUSH
// if not side or side > 8 then
45741: LD_VAR 0 3
45745: NOT
45746: PUSH
45747: LD_VAR 0 3
45751: PUSH
45752: LD_INT 8
45754: GREATER
45755: OR
45756: IFFALSE 45760
// exit ;
45758: GO 45819
// if not range then
45760: LD_VAR 0 4
45764: NOT
45765: IFFALSE 45776
// range := - 12 ;
45767: LD_ADDR_VAR 0 4
45771: PUSH
45772: LD_INT 12
45774: NEG
45775: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45776: LD_VAR 0 1
45780: PPUSH
45781: LD_VAR 0 2
45785: PPUSH
45786: LD_VAR 0 3
45790: PPUSH
45791: LD_VAR 0 4
45795: PPUSH
45796: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45800: LD_VAR 0 1
45804: PPUSH
45805: LD_VAR 0 2
45809: PPUSH
45810: LD_VAR 0 3
45814: PPUSH
45815: CALL_OW 331
// end ;
45819: LD_VAR 0 5
45823: RET
// export function Video ( mode ) ; begin
45824: LD_INT 0
45826: PPUSH
// ingame_video = mode ;
45827: LD_ADDR_OWVAR 52
45831: PUSH
45832: LD_VAR 0 1
45836: ST_TO_ADDR
// interface_hidden = mode ;
45837: LD_ADDR_OWVAR 54
45841: PUSH
45842: LD_VAR 0 1
45846: ST_TO_ADDR
// end ;
45847: LD_VAR 0 2
45851: RET
// export function Join ( array , element ) ; begin
45852: LD_INT 0
45854: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45855: LD_ADDR_VAR 0 3
45859: PUSH
45860: LD_VAR 0 1
45864: PPUSH
45865: LD_VAR 0 1
45869: PUSH
45870: LD_INT 1
45872: PLUS
45873: PPUSH
45874: LD_VAR 0 2
45878: PPUSH
45879: CALL_OW 1
45883: ST_TO_ADDR
// end ;
45884: LD_VAR 0 3
45888: RET
// export function JoinUnion ( array , element ) ; begin
45889: LD_INT 0
45891: PPUSH
// result := array union element ;
45892: LD_ADDR_VAR 0 3
45896: PUSH
45897: LD_VAR 0 1
45901: PUSH
45902: LD_VAR 0 2
45906: UNION
45907: ST_TO_ADDR
// end ;
45908: LD_VAR 0 3
45912: RET
// export function GetBehemoths ( side ) ; begin
45913: LD_INT 0
45915: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45916: LD_ADDR_VAR 0 2
45920: PUSH
45921: LD_INT 22
45923: PUSH
45924: LD_VAR 0 1
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 31
45935: PUSH
45936: LD_INT 25
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: EMPTY
45944: LIST
45945: LIST
45946: PPUSH
45947: CALL_OW 69
45951: ST_TO_ADDR
// end ;
45952: LD_VAR 0 2
45956: RET
// export function Shuffle ( array ) ; var i , index ; begin
45957: LD_INT 0
45959: PPUSH
45960: PPUSH
45961: PPUSH
// result := [ ] ;
45962: LD_ADDR_VAR 0 2
45966: PUSH
45967: EMPTY
45968: ST_TO_ADDR
// if not array then
45969: LD_VAR 0 1
45973: NOT
45974: IFFALSE 45978
// exit ;
45976: GO 46077
// Randomize ;
45978: CALL_OW 10
// for i = array downto 1 do
45982: LD_ADDR_VAR 0 3
45986: PUSH
45987: DOUBLE
45988: LD_VAR 0 1
45992: INC
45993: ST_TO_ADDR
45994: LD_INT 1
45996: PUSH
45997: FOR_DOWNTO
45998: IFFALSE 46075
// begin index := rand ( 1 , array ) ;
46000: LD_ADDR_VAR 0 4
46004: PUSH
46005: LD_INT 1
46007: PPUSH
46008: LD_VAR 0 1
46012: PPUSH
46013: CALL_OW 12
46017: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46018: LD_ADDR_VAR 0 2
46022: PUSH
46023: LD_VAR 0 2
46027: PPUSH
46028: LD_VAR 0 2
46032: PUSH
46033: LD_INT 1
46035: PLUS
46036: PPUSH
46037: LD_VAR 0 1
46041: PUSH
46042: LD_VAR 0 4
46046: ARRAY
46047: PPUSH
46048: CALL_OW 2
46052: ST_TO_ADDR
// array := Delete ( array , index ) ;
46053: LD_ADDR_VAR 0 1
46057: PUSH
46058: LD_VAR 0 1
46062: PPUSH
46063: LD_VAR 0 4
46067: PPUSH
46068: CALL_OW 3
46072: ST_TO_ADDR
// end ;
46073: GO 45997
46075: POP
46076: POP
// end ;
46077: LD_VAR 0 2
46081: RET
// export function GetBaseMaterials ( base ) ; begin
46082: LD_INT 0
46084: PPUSH
// result := [ 0 , 0 , 0 ] ;
46085: LD_ADDR_VAR 0 2
46089: PUSH
46090: LD_INT 0
46092: PUSH
46093: LD_INT 0
46095: PUSH
46096: LD_INT 0
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: LIST
46103: ST_TO_ADDR
// if not base then
46104: LD_VAR 0 1
46108: NOT
46109: IFFALSE 46113
// exit ;
46111: GO 46162
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46113: LD_ADDR_VAR 0 2
46117: PUSH
46118: LD_VAR 0 1
46122: PPUSH
46123: LD_INT 1
46125: PPUSH
46126: CALL_OW 275
46130: PUSH
46131: LD_VAR 0 1
46135: PPUSH
46136: LD_INT 2
46138: PPUSH
46139: CALL_OW 275
46143: PUSH
46144: LD_VAR 0 1
46148: PPUSH
46149: LD_INT 3
46151: PPUSH
46152: CALL_OW 275
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: LIST
46161: ST_TO_ADDR
// end ;
46162: LD_VAR 0 2
46166: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46167: LD_INT 0
46169: PPUSH
46170: PPUSH
// result := array ;
46171: LD_ADDR_VAR 0 3
46175: PUSH
46176: LD_VAR 0 1
46180: ST_TO_ADDR
// if size > 0 then
46181: LD_VAR 0 2
46185: PUSH
46186: LD_INT 0
46188: GREATER
46189: IFFALSE 46235
// for i := array downto size do
46191: LD_ADDR_VAR 0 4
46195: PUSH
46196: DOUBLE
46197: LD_VAR 0 1
46201: INC
46202: ST_TO_ADDR
46203: LD_VAR 0 2
46207: PUSH
46208: FOR_DOWNTO
46209: IFFALSE 46233
// result := Delete ( result , result ) ;
46211: LD_ADDR_VAR 0 3
46215: PUSH
46216: LD_VAR 0 3
46220: PPUSH
46221: LD_VAR 0 3
46225: PPUSH
46226: CALL_OW 3
46230: ST_TO_ADDR
46231: GO 46208
46233: POP
46234: POP
// end ;
46235: LD_VAR 0 3
46239: RET
// export function ComExit ( unit ) ; var tmp ; begin
46240: LD_INT 0
46242: PPUSH
46243: PPUSH
// if not IsInUnit ( unit ) then
46244: LD_VAR 0 1
46248: PPUSH
46249: CALL_OW 310
46253: NOT
46254: IFFALSE 46258
// exit ;
46256: GO 46318
// tmp := IsInUnit ( unit ) ;
46258: LD_ADDR_VAR 0 3
46262: PUSH
46263: LD_VAR 0 1
46267: PPUSH
46268: CALL_OW 310
46272: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46273: LD_VAR 0 3
46277: PPUSH
46278: CALL_OW 247
46282: PUSH
46283: LD_INT 2
46285: EQUAL
46286: IFFALSE 46299
// ComExitVehicle ( unit ) else
46288: LD_VAR 0 1
46292: PPUSH
46293: CALL_OW 121
46297: GO 46308
// ComExitBuilding ( unit ) ;
46299: LD_VAR 0 1
46303: PPUSH
46304: CALL_OW 122
// result := tmp ;
46308: LD_ADDR_VAR 0 2
46312: PUSH
46313: LD_VAR 0 3
46317: ST_TO_ADDR
// end ;
46318: LD_VAR 0 2
46322: RET
// export function ResetHc ; begin
46323: LD_INT 0
46325: PPUSH
// InitHc ;
46326: CALL_OW 19
// hc_importance := 0 ;
46330: LD_ADDR_OWVAR 32
46334: PUSH
46335: LD_INT 0
46337: ST_TO_ADDR
// end ;
46338: LD_VAR 0 1
46342: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46343: LD_INT 0
46345: PPUSH
46346: PPUSH
46347: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46348: LD_ADDR_VAR 0 6
46352: PUSH
46353: LD_VAR 0 1
46357: PUSH
46358: LD_VAR 0 3
46362: PLUS
46363: PUSH
46364: LD_INT 2
46366: DIV
46367: ST_TO_ADDR
// if _x < 0 then
46368: LD_VAR 0 6
46372: PUSH
46373: LD_INT 0
46375: LESS
46376: IFFALSE 46393
// _x := _x * - 1 ;
46378: LD_ADDR_VAR 0 6
46382: PUSH
46383: LD_VAR 0 6
46387: PUSH
46388: LD_INT 1
46390: NEG
46391: MUL
46392: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46393: LD_ADDR_VAR 0 7
46397: PUSH
46398: LD_VAR 0 2
46402: PUSH
46403: LD_VAR 0 4
46407: PLUS
46408: PUSH
46409: LD_INT 2
46411: DIV
46412: ST_TO_ADDR
// if _y < 0 then
46413: LD_VAR 0 7
46417: PUSH
46418: LD_INT 0
46420: LESS
46421: IFFALSE 46438
// _y := _y * - 1 ;
46423: LD_ADDR_VAR 0 7
46427: PUSH
46428: LD_VAR 0 7
46432: PUSH
46433: LD_INT 1
46435: NEG
46436: MUL
46437: ST_TO_ADDR
// result := [ _x , _y ] ;
46438: LD_ADDR_VAR 0 5
46442: PUSH
46443: LD_VAR 0 6
46447: PUSH
46448: LD_VAR 0 7
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: ST_TO_ADDR
// end ;
46457: LD_VAR 0 5
46461: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46462: LD_INT 0
46464: PPUSH
46465: PPUSH
46466: PPUSH
46467: PPUSH
// task := GetTaskList ( unit ) ;
46468: LD_ADDR_VAR 0 7
46472: PUSH
46473: LD_VAR 0 1
46477: PPUSH
46478: CALL_OW 437
46482: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46483: LD_VAR 0 7
46487: NOT
46488: PUSH
46489: LD_VAR 0 1
46493: PPUSH
46494: LD_VAR 0 2
46498: PPUSH
46499: CALL_OW 308
46503: NOT
46504: AND
46505: IFFALSE 46509
// exit ;
46507: GO 46627
// if IsInArea ( unit , area ) then
46509: LD_VAR 0 1
46513: PPUSH
46514: LD_VAR 0 2
46518: PPUSH
46519: CALL_OW 308
46523: IFFALSE 46541
// begin ComMoveToArea ( unit , goAway ) ;
46525: LD_VAR 0 1
46529: PPUSH
46530: LD_VAR 0 3
46534: PPUSH
46535: CALL_OW 113
// exit ;
46539: GO 46627
// end ; if task [ 1 ] [ 1 ] <> M then
46541: LD_VAR 0 7
46545: PUSH
46546: LD_INT 1
46548: ARRAY
46549: PUSH
46550: LD_INT 1
46552: ARRAY
46553: PUSH
46554: LD_STRING M
46556: NONEQUAL
46557: IFFALSE 46561
// exit ;
46559: GO 46627
// x := task [ 1 ] [ 2 ] ;
46561: LD_ADDR_VAR 0 5
46565: PUSH
46566: LD_VAR 0 7
46570: PUSH
46571: LD_INT 1
46573: ARRAY
46574: PUSH
46575: LD_INT 2
46577: ARRAY
46578: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46579: LD_ADDR_VAR 0 6
46583: PUSH
46584: LD_VAR 0 7
46588: PUSH
46589: LD_INT 1
46591: ARRAY
46592: PUSH
46593: LD_INT 3
46595: ARRAY
46596: ST_TO_ADDR
// if InArea ( x , y , area ) then
46597: LD_VAR 0 5
46601: PPUSH
46602: LD_VAR 0 6
46606: PPUSH
46607: LD_VAR 0 2
46611: PPUSH
46612: CALL_OW 309
46616: IFFALSE 46627
// ComStop ( unit ) ;
46618: LD_VAR 0 1
46622: PPUSH
46623: CALL_OW 141
// end ;
46627: LD_VAR 0 4
46631: RET
// export function Abs ( value ) ; begin
46632: LD_INT 0
46634: PPUSH
// result := value ;
46635: LD_ADDR_VAR 0 2
46639: PUSH
46640: LD_VAR 0 1
46644: ST_TO_ADDR
// if value < 0 then
46645: LD_VAR 0 1
46649: PUSH
46650: LD_INT 0
46652: LESS
46653: IFFALSE 46670
// result := value * - 1 ;
46655: LD_ADDR_VAR 0 2
46659: PUSH
46660: LD_VAR 0 1
46664: PUSH
46665: LD_INT 1
46667: NEG
46668: MUL
46669: ST_TO_ADDR
// end ;
46670: LD_VAR 0 2
46674: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46675: LD_INT 0
46677: PPUSH
46678: PPUSH
46679: PPUSH
46680: PPUSH
46681: PPUSH
46682: PPUSH
46683: PPUSH
46684: PPUSH
// if not unit or not building then
46685: LD_VAR 0 1
46689: NOT
46690: PUSH
46691: LD_VAR 0 2
46695: NOT
46696: OR
46697: IFFALSE 46701
// exit ;
46699: GO 46927
// x := GetX ( building ) ;
46701: LD_ADDR_VAR 0 4
46705: PUSH
46706: LD_VAR 0 2
46710: PPUSH
46711: CALL_OW 250
46715: ST_TO_ADDR
// y := GetY ( building ) ;
46716: LD_ADDR_VAR 0 6
46720: PUSH
46721: LD_VAR 0 2
46725: PPUSH
46726: CALL_OW 251
46730: ST_TO_ADDR
// d := GetDir ( building ) ;
46731: LD_ADDR_VAR 0 8
46735: PUSH
46736: LD_VAR 0 2
46740: PPUSH
46741: CALL_OW 254
46745: ST_TO_ADDR
// r := 4 ;
46746: LD_ADDR_VAR 0 9
46750: PUSH
46751: LD_INT 4
46753: ST_TO_ADDR
// for i := 1 to 5 do
46754: LD_ADDR_VAR 0 10
46758: PUSH
46759: DOUBLE
46760: LD_INT 1
46762: DEC
46763: ST_TO_ADDR
46764: LD_INT 5
46766: PUSH
46767: FOR_TO
46768: IFFALSE 46925
// begin _x := ShiftX ( x , d , r + i ) ;
46770: LD_ADDR_VAR 0 5
46774: PUSH
46775: LD_VAR 0 4
46779: PPUSH
46780: LD_VAR 0 8
46784: PPUSH
46785: LD_VAR 0 9
46789: PUSH
46790: LD_VAR 0 10
46794: PLUS
46795: PPUSH
46796: CALL_OW 272
46800: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46801: LD_ADDR_VAR 0 7
46805: PUSH
46806: LD_VAR 0 6
46810: PPUSH
46811: LD_VAR 0 8
46815: PPUSH
46816: LD_VAR 0 9
46820: PUSH
46821: LD_VAR 0 10
46825: PLUS
46826: PPUSH
46827: CALL_OW 273
46831: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46832: LD_VAR 0 5
46836: PPUSH
46837: LD_VAR 0 7
46841: PPUSH
46842: CALL_OW 488
46846: PUSH
46847: LD_VAR 0 5
46851: PPUSH
46852: LD_VAR 0 7
46856: PPUSH
46857: CALL_OW 428
46861: PPUSH
46862: CALL_OW 247
46866: PUSH
46867: LD_INT 3
46869: PUSH
46870: LD_INT 2
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: IN
46877: NOT
46878: AND
46879: IFFALSE 46923
// begin ComMoveXY ( unit , _x , _y ) ;
46881: LD_VAR 0 1
46885: PPUSH
46886: LD_VAR 0 5
46890: PPUSH
46891: LD_VAR 0 7
46895: PPUSH
46896: CALL_OW 111
// result := [ _x , _y ] ;
46900: LD_ADDR_VAR 0 3
46904: PUSH
46905: LD_VAR 0 5
46909: PUSH
46910: LD_VAR 0 7
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// exit ;
46919: POP
46920: POP
46921: GO 46927
// end ; end ;
46923: GO 46767
46925: POP
46926: POP
// end ;
46927: LD_VAR 0 3
46931: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46932: LD_INT 0
46934: PPUSH
46935: PPUSH
46936: PPUSH
// result := 0 ;
46937: LD_ADDR_VAR 0 3
46941: PUSH
46942: LD_INT 0
46944: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46945: LD_VAR 0 1
46949: PUSH
46950: LD_INT 0
46952: LESS
46953: PUSH
46954: LD_VAR 0 1
46958: PUSH
46959: LD_INT 8
46961: GREATER
46962: OR
46963: PUSH
46964: LD_VAR 0 2
46968: PUSH
46969: LD_INT 0
46971: LESS
46972: OR
46973: PUSH
46974: LD_VAR 0 2
46978: PUSH
46979: LD_INT 8
46981: GREATER
46982: OR
46983: IFFALSE 46987
// exit ;
46985: GO 47062
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46987: LD_ADDR_VAR 0 4
46991: PUSH
46992: LD_INT 22
46994: PUSH
46995: LD_VAR 0 2
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PPUSH
47004: CALL_OW 69
47008: PUSH
47009: FOR_IN
47010: IFFALSE 47060
// begin un := UnitShoot ( i ) ;
47012: LD_ADDR_VAR 0 5
47016: PUSH
47017: LD_VAR 0 4
47021: PPUSH
47022: CALL_OW 504
47026: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47027: LD_VAR 0 5
47031: PPUSH
47032: CALL_OW 255
47036: PUSH
47037: LD_VAR 0 1
47041: EQUAL
47042: IFFALSE 47058
// begin result := un ;
47044: LD_ADDR_VAR 0 3
47048: PUSH
47049: LD_VAR 0 5
47053: ST_TO_ADDR
// exit ;
47054: POP
47055: POP
47056: GO 47062
// end ; end ;
47058: GO 47009
47060: POP
47061: POP
// end ;
47062: LD_VAR 0 3
47066: RET
// export function GetCargoBay ( units ) ; begin
47067: LD_INT 0
47069: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47070: LD_ADDR_VAR 0 2
47074: PUSH
47075: LD_VAR 0 1
47079: PPUSH
47080: LD_INT 2
47082: PUSH
47083: LD_INT 34
47085: PUSH
47086: LD_INT 12
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: LD_INT 34
47095: PUSH
47096: LD_INT 51
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 34
47105: PUSH
47106: LD_INT 32
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 34
47115: PUSH
47116: LD_EXP 87
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: PPUSH
47132: CALL_OW 72
47136: ST_TO_ADDR
// end ; end_of_file
47137: LD_VAR 0 2
47141: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
47142: LD_INT 0
47144: PPUSH
47145: PPUSH
// skirmish := false ;
47146: LD_ADDR_EXP 41
47150: PUSH
47151: LD_INT 0
47153: ST_TO_ADDR
// debug_mc := false ;
47154: LD_ADDR_EXP 42
47158: PUSH
47159: LD_INT 0
47161: ST_TO_ADDR
// mc_bases := [ ] ;
47162: LD_ADDR_EXP 43
47166: PUSH
47167: EMPTY
47168: ST_TO_ADDR
// mc_sides := [ ] ;
47169: LD_ADDR_EXP 69
47173: PUSH
47174: EMPTY
47175: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47176: LD_ADDR_EXP 44
47180: PUSH
47181: EMPTY
47182: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47183: LD_ADDR_EXP 45
47187: PUSH
47188: EMPTY
47189: ST_TO_ADDR
// mc_need_heal := [ ] ;
47190: LD_ADDR_EXP 46
47194: PUSH
47195: EMPTY
47196: ST_TO_ADDR
// mc_healers := [ ] ;
47197: LD_ADDR_EXP 47
47201: PUSH
47202: EMPTY
47203: ST_TO_ADDR
// mc_build_list := [ ] ;
47204: LD_ADDR_EXP 48
47208: PUSH
47209: EMPTY
47210: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47211: LD_ADDR_EXP 75
47215: PUSH
47216: EMPTY
47217: ST_TO_ADDR
// mc_builders := [ ] ;
47218: LD_ADDR_EXP 49
47222: PUSH
47223: EMPTY
47224: ST_TO_ADDR
// mc_construct_list := [ ] ;
47225: LD_ADDR_EXP 50
47229: PUSH
47230: EMPTY
47231: ST_TO_ADDR
// mc_turret_list := [ ] ;
47232: LD_ADDR_EXP 51
47236: PUSH
47237: EMPTY
47238: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47239: LD_ADDR_EXP 52
47243: PUSH
47244: EMPTY
47245: ST_TO_ADDR
// mc_miners := [ ] ;
47246: LD_ADDR_EXP 57
47250: PUSH
47251: EMPTY
47252: ST_TO_ADDR
// mc_mines := [ ] ;
47253: LD_ADDR_EXP 56
47257: PUSH
47258: EMPTY
47259: ST_TO_ADDR
// mc_minefields := [ ] ;
47260: LD_ADDR_EXP 58
47264: PUSH
47265: EMPTY
47266: ST_TO_ADDR
// mc_crates := [ ] ;
47267: LD_ADDR_EXP 59
47271: PUSH
47272: EMPTY
47273: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47274: LD_ADDR_EXP 60
47278: PUSH
47279: EMPTY
47280: ST_TO_ADDR
// mc_crates_area := [ ] ;
47281: LD_ADDR_EXP 61
47285: PUSH
47286: EMPTY
47287: ST_TO_ADDR
// mc_vehicles := [ ] ;
47288: LD_ADDR_EXP 62
47292: PUSH
47293: EMPTY
47294: ST_TO_ADDR
// mc_attack := [ ] ;
47295: LD_ADDR_EXP 63
47299: PUSH
47300: EMPTY
47301: ST_TO_ADDR
// mc_produce := [ ] ;
47302: LD_ADDR_EXP 64
47306: PUSH
47307: EMPTY
47308: ST_TO_ADDR
// mc_defender := [ ] ;
47309: LD_ADDR_EXP 65
47313: PUSH
47314: EMPTY
47315: ST_TO_ADDR
// mc_parking := [ ] ;
47316: LD_ADDR_EXP 67
47320: PUSH
47321: EMPTY
47322: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47323: LD_ADDR_EXP 53
47327: PUSH
47328: EMPTY
47329: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47330: LD_ADDR_EXP 55
47334: PUSH
47335: EMPTY
47336: ST_TO_ADDR
// mc_scan := [ ] ;
47337: LD_ADDR_EXP 66
47341: PUSH
47342: EMPTY
47343: ST_TO_ADDR
// mc_scan_area := [ ] ;
47344: LD_ADDR_EXP 68
47348: PUSH
47349: EMPTY
47350: ST_TO_ADDR
// mc_tech := [ ] ;
47351: LD_ADDR_EXP 70
47355: PUSH
47356: EMPTY
47357: ST_TO_ADDR
// mc_class := [ ] ;
47358: LD_ADDR_EXP 84
47362: PUSH
47363: EMPTY
47364: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47365: LD_ADDR_EXP 85
47369: PUSH
47370: EMPTY
47371: ST_TO_ADDR
// end ;
47372: LD_VAR 0 1
47376: RET
// export function MC_Kill ( base ) ; begin
47377: LD_INT 0
47379: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47380: LD_ADDR_EXP 43
47384: PUSH
47385: LD_EXP 43
47389: PPUSH
47390: LD_VAR 0 1
47394: PPUSH
47395: EMPTY
47396: PPUSH
47397: CALL_OW 1
47401: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47402: LD_ADDR_EXP 44
47406: PUSH
47407: LD_EXP 44
47411: PPUSH
47412: LD_VAR 0 1
47416: PPUSH
47417: EMPTY
47418: PPUSH
47419: CALL_OW 1
47423: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47424: LD_ADDR_EXP 45
47428: PUSH
47429: LD_EXP 45
47433: PPUSH
47434: LD_VAR 0 1
47438: PPUSH
47439: EMPTY
47440: PPUSH
47441: CALL_OW 1
47445: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47446: LD_ADDR_EXP 46
47450: PUSH
47451: LD_EXP 46
47455: PPUSH
47456: LD_VAR 0 1
47460: PPUSH
47461: EMPTY
47462: PPUSH
47463: CALL_OW 1
47467: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47468: LD_ADDR_EXP 47
47472: PUSH
47473: LD_EXP 47
47477: PPUSH
47478: LD_VAR 0 1
47482: PPUSH
47483: EMPTY
47484: PPUSH
47485: CALL_OW 1
47489: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47490: LD_ADDR_EXP 48
47494: PUSH
47495: LD_EXP 48
47499: PPUSH
47500: LD_VAR 0 1
47504: PPUSH
47505: EMPTY
47506: PPUSH
47507: CALL_OW 1
47511: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47512: LD_ADDR_EXP 49
47516: PUSH
47517: LD_EXP 49
47521: PPUSH
47522: LD_VAR 0 1
47526: PPUSH
47527: EMPTY
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47534: LD_ADDR_EXP 50
47538: PUSH
47539: LD_EXP 50
47543: PPUSH
47544: LD_VAR 0 1
47548: PPUSH
47549: EMPTY
47550: PPUSH
47551: CALL_OW 1
47555: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47556: LD_ADDR_EXP 51
47560: PUSH
47561: LD_EXP 51
47565: PPUSH
47566: LD_VAR 0 1
47570: PPUSH
47571: EMPTY
47572: PPUSH
47573: CALL_OW 1
47577: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47578: LD_ADDR_EXP 52
47582: PUSH
47583: LD_EXP 52
47587: PPUSH
47588: LD_VAR 0 1
47592: PPUSH
47593: EMPTY
47594: PPUSH
47595: CALL_OW 1
47599: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47600: LD_ADDR_EXP 53
47604: PUSH
47605: LD_EXP 53
47609: PPUSH
47610: LD_VAR 0 1
47614: PPUSH
47615: EMPTY
47616: PPUSH
47617: CALL_OW 1
47621: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47622: LD_ADDR_EXP 54
47626: PUSH
47627: LD_EXP 54
47631: PPUSH
47632: LD_VAR 0 1
47636: PPUSH
47637: LD_INT 0
47639: PPUSH
47640: CALL_OW 1
47644: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47645: LD_ADDR_EXP 55
47649: PUSH
47650: LD_EXP 55
47654: PPUSH
47655: LD_VAR 0 1
47659: PPUSH
47660: EMPTY
47661: PPUSH
47662: CALL_OW 1
47666: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47667: LD_ADDR_EXP 56
47671: PUSH
47672: LD_EXP 56
47676: PPUSH
47677: LD_VAR 0 1
47681: PPUSH
47682: EMPTY
47683: PPUSH
47684: CALL_OW 1
47688: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47689: LD_ADDR_EXP 57
47693: PUSH
47694: LD_EXP 57
47698: PPUSH
47699: LD_VAR 0 1
47703: PPUSH
47704: EMPTY
47705: PPUSH
47706: CALL_OW 1
47710: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47711: LD_ADDR_EXP 58
47715: PUSH
47716: LD_EXP 58
47720: PPUSH
47721: LD_VAR 0 1
47725: PPUSH
47726: EMPTY
47727: PPUSH
47728: CALL_OW 1
47732: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47733: LD_ADDR_EXP 59
47737: PUSH
47738: LD_EXP 59
47742: PPUSH
47743: LD_VAR 0 1
47747: PPUSH
47748: EMPTY
47749: PPUSH
47750: CALL_OW 1
47754: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47755: LD_ADDR_EXP 60
47759: PUSH
47760: LD_EXP 60
47764: PPUSH
47765: LD_VAR 0 1
47769: PPUSH
47770: EMPTY
47771: PPUSH
47772: CALL_OW 1
47776: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47777: LD_ADDR_EXP 61
47781: PUSH
47782: LD_EXP 61
47786: PPUSH
47787: LD_VAR 0 1
47791: PPUSH
47792: EMPTY
47793: PPUSH
47794: CALL_OW 1
47798: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47799: LD_ADDR_EXP 62
47803: PUSH
47804: LD_EXP 62
47808: PPUSH
47809: LD_VAR 0 1
47813: PPUSH
47814: EMPTY
47815: PPUSH
47816: CALL_OW 1
47820: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47821: LD_ADDR_EXP 63
47825: PUSH
47826: LD_EXP 63
47830: PPUSH
47831: LD_VAR 0 1
47835: PPUSH
47836: EMPTY
47837: PPUSH
47838: CALL_OW 1
47842: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47843: LD_ADDR_EXP 64
47847: PUSH
47848: LD_EXP 64
47852: PPUSH
47853: LD_VAR 0 1
47857: PPUSH
47858: EMPTY
47859: PPUSH
47860: CALL_OW 1
47864: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47865: LD_ADDR_EXP 65
47869: PUSH
47870: LD_EXP 65
47874: PPUSH
47875: LD_VAR 0 1
47879: PPUSH
47880: EMPTY
47881: PPUSH
47882: CALL_OW 1
47886: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47887: LD_ADDR_EXP 66
47891: PUSH
47892: LD_EXP 66
47896: PPUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: EMPTY
47903: PPUSH
47904: CALL_OW 1
47908: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47909: LD_ADDR_EXP 67
47913: PUSH
47914: LD_EXP 67
47918: PPUSH
47919: LD_VAR 0 1
47923: PPUSH
47924: EMPTY
47925: PPUSH
47926: CALL_OW 1
47930: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47931: LD_ADDR_EXP 68
47935: PUSH
47936: LD_EXP 68
47940: PPUSH
47941: LD_VAR 0 1
47945: PPUSH
47946: EMPTY
47947: PPUSH
47948: CALL_OW 1
47952: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47953: LD_ADDR_EXP 70
47957: PUSH
47958: LD_EXP 70
47962: PPUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: EMPTY
47969: PPUSH
47970: CALL_OW 1
47974: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47975: LD_ADDR_EXP 72
47979: PUSH
47980: LD_EXP 72
47984: PPUSH
47985: LD_VAR 0 1
47989: PPUSH
47990: EMPTY
47991: PPUSH
47992: CALL_OW 1
47996: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47997: LD_ADDR_EXP 73
48001: PUSH
48002: LD_EXP 73
48006: PPUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: EMPTY
48013: PPUSH
48014: CALL_OW 1
48018: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48019: LD_ADDR_EXP 74
48023: PUSH
48024: LD_EXP 74
48028: PPUSH
48029: LD_VAR 0 1
48033: PPUSH
48034: EMPTY
48035: PPUSH
48036: CALL_OW 1
48040: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48041: LD_ADDR_EXP 75
48045: PUSH
48046: LD_EXP 75
48050: PPUSH
48051: LD_VAR 0 1
48055: PPUSH
48056: EMPTY
48057: PPUSH
48058: CALL_OW 1
48062: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48063: LD_ADDR_EXP 76
48067: PUSH
48068: LD_EXP 76
48072: PPUSH
48073: LD_VAR 0 1
48077: PPUSH
48078: EMPTY
48079: PPUSH
48080: CALL_OW 1
48084: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48085: LD_ADDR_EXP 77
48089: PUSH
48090: LD_EXP 77
48094: PPUSH
48095: LD_VAR 0 1
48099: PPUSH
48100: EMPTY
48101: PPUSH
48102: CALL_OW 1
48106: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48107: LD_ADDR_EXP 78
48111: PUSH
48112: LD_EXP 78
48116: PPUSH
48117: LD_VAR 0 1
48121: PPUSH
48122: EMPTY
48123: PPUSH
48124: CALL_OW 1
48128: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48129: LD_ADDR_EXP 79
48133: PUSH
48134: LD_EXP 79
48138: PPUSH
48139: LD_VAR 0 1
48143: PPUSH
48144: EMPTY
48145: PPUSH
48146: CALL_OW 1
48150: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48151: LD_ADDR_EXP 80
48155: PUSH
48156: LD_EXP 80
48160: PPUSH
48161: LD_VAR 0 1
48165: PPUSH
48166: EMPTY
48167: PPUSH
48168: CALL_OW 1
48172: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48173: LD_ADDR_EXP 81
48177: PUSH
48178: LD_EXP 81
48182: PPUSH
48183: LD_VAR 0 1
48187: PPUSH
48188: EMPTY
48189: PPUSH
48190: CALL_OW 1
48194: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48195: LD_ADDR_EXP 82
48199: PUSH
48200: LD_EXP 82
48204: PPUSH
48205: LD_VAR 0 1
48209: PPUSH
48210: EMPTY
48211: PPUSH
48212: CALL_OW 1
48216: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48217: LD_ADDR_EXP 83
48221: PUSH
48222: LD_EXP 83
48226: PPUSH
48227: LD_VAR 0 1
48231: PPUSH
48232: EMPTY
48233: PPUSH
48234: CALL_OW 1
48238: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48239: LD_ADDR_EXP 84
48243: PUSH
48244: LD_EXP 84
48248: PPUSH
48249: LD_VAR 0 1
48253: PPUSH
48254: EMPTY
48255: PPUSH
48256: CALL_OW 1
48260: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48261: LD_ADDR_EXP 85
48265: PUSH
48266: LD_EXP 85
48270: PPUSH
48271: LD_VAR 0 1
48275: PPUSH
48276: LD_INT 0
48278: PPUSH
48279: CALL_OW 1
48283: ST_TO_ADDR
// end ;
48284: LD_VAR 0 2
48288: RET
// export function MC_Add ( side , units ) ; var base ; begin
48289: LD_INT 0
48291: PPUSH
48292: PPUSH
// base := mc_bases + 1 ;
48293: LD_ADDR_VAR 0 4
48297: PUSH
48298: LD_EXP 43
48302: PUSH
48303: LD_INT 1
48305: PLUS
48306: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48307: LD_ADDR_EXP 69
48311: PUSH
48312: LD_EXP 69
48316: PPUSH
48317: LD_VAR 0 4
48321: PPUSH
48322: LD_VAR 0 1
48326: PPUSH
48327: CALL_OW 1
48331: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48332: LD_ADDR_EXP 43
48336: PUSH
48337: LD_EXP 43
48341: PPUSH
48342: LD_VAR 0 4
48346: PPUSH
48347: LD_VAR 0 2
48351: PPUSH
48352: CALL_OW 1
48356: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48357: LD_ADDR_EXP 44
48361: PUSH
48362: LD_EXP 44
48366: PPUSH
48367: LD_VAR 0 4
48371: PPUSH
48372: EMPTY
48373: PPUSH
48374: CALL_OW 1
48378: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48379: LD_ADDR_EXP 45
48383: PUSH
48384: LD_EXP 45
48388: PPUSH
48389: LD_VAR 0 4
48393: PPUSH
48394: EMPTY
48395: PPUSH
48396: CALL_OW 1
48400: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48401: LD_ADDR_EXP 46
48405: PUSH
48406: LD_EXP 46
48410: PPUSH
48411: LD_VAR 0 4
48415: PPUSH
48416: EMPTY
48417: PPUSH
48418: CALL_OW 1
48422: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48423: LD_ADDR_EXP 47
48427: PUSH
48428: LD_EXP 47
48432: PPUSH
48433: LD_VAR 0 4
48437: PPUSH
48438: EMPTY
48439: PPUSH
48440: CALL_OW 1
48444: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48445: LD_ADDR_EXP 48
48449: PUSH
48450: LD_EXP 48
48454: PPUSH
48455: LD_VAR 0 4
48459: PPUSH
48460: EMPTY
48461: PPUSH
48462: CALL_OW 1
48466: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48467: LD_ADDR_EXP 49
48471: PUSH
48472: LD_EXP 49
48476: PPUSH
48477: LD_VAR 0 4
48481: PPUSH
48482: EMPTY
48483: PPUSH
48484: CALL_OW 1
48488: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48489: LD_ADDR_EXP 50
48493: PUSH
48494: LD_EXP 50
48498: PPUSH
48499: LD_VAR 0 4
48503: PPUSH
48504: EMPTY
48505: PPUSH
48506: CALL_OW 1
48510: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48511: LD_ADDR_EXP 51
48515: PUSH
48516: LD_EXP 51
48520: PPUSH
48521: LD_VAR 0 4
48525: PPUSH
48526: EMPTY
48527: PPUSH
48528: CALL_OW 1
48532: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48533: LD_ADDR_EXP 52
48537: PUSH
48538: LD_EXP 52
48542: PPUSH
48543: LD_VAR 0 4
48547: PPUSH
48548: EMPTY
48549: PPUSH
48550: CALL_OW 1
48554: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48555: LD_ADDR_EXP 53
48559: PUSH
48560: LD_EXP 53
48564: PPUSH
48565: LD_VAR 0 4
48569: PPUSH
48570: EMPTY
48571: PPUSH
48572: CALL_OW 1
48576: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48577: LD_ADDR_EXP 54
48581: PUSH
48582: LD_EXP 54
48586: PPUSH
48587: LD_VAR 0 4
48591: PPUSH
48592: LD_INT 0
48594: PPUSH
48595: CALL_OW 1
48599: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48600: LD_ADDR_EXP 55
48604: PUSH
48605: LD_EXP 55
48609: PPUSH
48610: LD_VAR 0 4
48614: PPUSH
48615: EMPTY
48616: PPUSH
48617: CALL_OW 1
48621: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48622: LD_ADDR_EXP 56
48626: PUSH
48627: LD_EXP 56
48631: PPUSH
48632: LD_VAR 0 4
48636: PPUSH
48637: EMPTY
48638: PPUSH
48639: CALL_OW 1
48643: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48644: LD_ADDR_EXP 57
48648: PUSH
48649: LD_EXP 57
48653: PPUSH
48654: LD_VAR 0 4
48658: PPUSH
48659: EMPTY
48660: PPUSH
48661: CALL_OW 1
48665: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48666: LD_ADDR_EXP 58
48670: PUSH
48671: LD_EXP 58
48675: PPUSH
48676: LD_VAR 0 4
48680: PPUSH
48681: EMPTY
48682: PPUSH
48683: CALL_OW 1
48687: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48688: LD_ADDR_EXP 59
48692: PUSH
48693: LD_EXP 59
48697: PPUSH
48698: LD_VAR 0 4
48702: PPUSH
48703: EMPTY
48704: PPUSH
48705: CALL_OW 1
48709: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48710: LD_ADDR_EXP 60
48714: PUSH
48715: LD_EXP 60
48719: PPUSH
48720: LD_VAR 0 4
48724: PPUSH
48725: EMPTY
48726: PPUSH
48727: CALL_OW 1
48731: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48732: LD_ADDR_EXP 61
48736: PUSH
48737: LD_EXP 61
48741: PPUSH
48742: LD_VAR 0 4
48746: PPUSH
48747: EMPTY
48748: PPUSH
48749: CALL_OW 1
48753: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48754: LD_ADDR_EXP 62
48758: PUSH
48759: LD_EXP 62
48763: PPUSH
48764: LD_VAR 0 4
48768: PPUSH
48769: EMPTY
48770: PPUSH
48771: CALL_OW 1
48775: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48776: LD_ADDR_EXP 63
48780: PUSH
48781: LD_EXP 63
48785: PPUSH
48786: LD_VAR 0 4
48790: PPUSH
48791: EMPTY
48792: PPUSH
48793: CALL_OW 1
48797: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48798: LD_ADDR_EXP 64
48802: PUSH
48803: LD_EXP 64
48807: PPUSH
48808: LD_VAR 0 4
48812: PPUSH
48813: EMPTY
48814: PPUSH
48815: CALL_OW 1
48819: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48820: LD_ADDR_EXP 65
48824: PUSH
48825: LD_EXP 65
48829: PPUSH
48830: LD_VAR 0 4
48834: PPUSH
48835: EMPTY
48836: PPUSH
48837: CALL_OW 1
48841: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48842: LD_ADDR_EXP 66
48846: PUSH
48847: LD_EXP 66
48851: PPUSH
48852: LD_VAR 0 4
48856: PPUSH
48857: EMPTY
48858: PPUSH
48859: CALL_OW 1
48863: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48864: LD_ADDR_EXP 67
48868: PUSH
48869: LD_EXP 67
48873: PPUSH
48874: LD_VAR 0 4
48878: PPUSH
48879: EMPTY
48880: PPUSH
48881: CALL_OW 1
48885: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48886: LD_ADDR_EXP 68
48890: PUSH
48891: LD_EXP 68
48895: PPUSH
48896: LD_VAR 0 4
48900: PPUSH
48901: EMPTY
48902: PPUSH
48903: CALL_OW 1
48907: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48908: LD_ADDR_EXP 70
48912: PUSH
48913: LD_EXP 70
48917: PPUSH
48918: LD_VAR 0 4
48922: PPUSH
48923: EMPTY
48924: PPUSH
48925: CALL_OW 1
48929: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48930: LD_ADDR_EXP 72
48934: PUSH
48935: LD_EXP 72
48939: PPUSH
48940: LD_VAR 0 4
48944: PPUSH
48945: EMPTY
48946: PPUSH
48947: CALL_OW 1
48951: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48952: LD_ADDR_EXP 73
48956: PUSH
48957: LD_EXP 73
48961: PPUSH
48962: LD_VAR 0 4
48966: PPUSH
48967: EMPTY
48968: PPUSH
48969: CALL_OW 1
48973: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48974: LD_ADDR_EXP 74
48978: PUSH
48979: LD_EXP 74
48983: PPUSH
48984: LD_VAR 0 4
48988: PPUSH
48989: EMPTY
48990: PPUSH
48991: CALL_OW 1
48995: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48996: LD_ADDR_EXP 75
49000: PUSH
49001: LD_EXP 75
49005: PPUSH
49006: LD_VAR 0 4
49010: PPUSH
49011: EMPTY
49012: PPUSH
49013: CALL_OW 1
49017: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49018: LD_ADDR_EXP 76
49022: PUSH
49023: LD_EXP 76
49027: PPUSH
49028: LD_VAR 0 4
49032: PPUSH
49033: EMPTY
49034: PPUSH
49035: CALL_OW 1
49039: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49040: LD_ADDR_EXP 77
49044: PUSH
49045: LD_EXP 77
49049: PPUSH
49050: LD_VAR 0 4
49054: PPUSH
49055: EMPTY
49056: PPUSH
49057: CALL_OW 1
49061: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49062: LD_ADDR_EXP 78
49066: PUSH
49067: LD_EXP 78
49071: PPUSH
49072: LD_VAR 0 4
49076: PPUSH
49077: EMPTY
49078: PPUSH
49079: CALL_OW 1
49083: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49084: LD_ADDR_EXP 79
49088: PUSH
49089: LD_EXP 79
49093: PPUSH
49094: LD_VAR 0 4
49098: PPUSH
49099: EMPTY
49100: PPUSH
49101: CALL_OW 1
49105: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49106: LD_ADDR_EXP 80
49110: PUSH
49111: LD_EXP 80
49115: PPUSH
49116: LD_VAR 0 4
49120: PPUSH
49121: EMPTY
49122: PPUSH
49123: CALL_OW 1
49127: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49128: LD_ADDR_EXP 81
49132: PUSH
49133: LD_EXP 81
49137: PPUSH
49138: LD_VAR 0 4
49142: PPUSH
49143: EMPTY
49144: PPUSH
49145: CALL_OW 1
49149: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49150: LD_ADDR_EXP 82
49154: PUSH
49155: LD_EXP 82
49159: PPUSH
49160: LD_VAR 0 4
49164: PPUSH
49165: EMPTY
49166: PPUSH
49167: CALL_OW 1
49171: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49172: LD_ADDR_EXP 83
49176: PUSH
49177: LD_EXP 83
49181: PPUSH
49182: LD_VAR 0 4
49186: PPUSH
49187: EMPTY
49188: PPUSH
49189: CALL_OW 1
49193: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49194: LD_ADDR_EXP 84
49198: PUSH
49199: LD_EXP 84
49203: PPUSH
49204: LD_VAR 0 4
49208: PPUSH
49209: EMPTY
49210: PPUSH
49211: CALL_OW 1
49215: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49216: LD_ADDR_EXP 85
49220: PUSH
49221: LD_EXP 85
49225: PPUSH
49226: LD_VAR 0 4
49230: PPUSH
49231: LD_INT 0
49233: PPUSH
49234: CALL_OW 1
49238: ST_TO_ADDR
// result := base ;
49239: LD_ADDR_VAR 0 3
49243: PUSH
49244: LD_VAR 0 4
49248: ST_TO_ADDR
// end ;
49249: LD_VAR 0 3
49253: RET
// export function MC_Start ( ) ; var i ; begin
49254: LD_INT 0
49256: PPUSH
49257: PPUSH
// for i = 1 to mc_bases do
49258: LD_ADDR_VAR 0 2
49262: PUSH
49263: DOUBLE
49264: LD_INT 1
49266: DEC
49267: ST_TO_ADDR
49268: LD_EXP 43
49272: PUSH
49273: FOR_TO
49274: IFFALSE 50351
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49276: LD_ADDR_EXP 43
49280: PUSH
49281: LD_EXP 43
49285: PPUSH
49286: LD_VAR 0 2
49290: PPUSH
49291: LD_EXP 43
49295: PUSH
49296: LD_VAR 0 2
49300: ARRAY
49301: PUSH
49302: LD_INT 0
49304: DIFF
49305: PPUSH
49306: CALL_OW 1
49310: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49311: LD_ADDR_EXP 44
49315: PUSH
49316: LD_EXP 44
49320: PPUSH
49321: LD_VAR 0 2
49325: PPUSH
49326: EMPTY
49327: PPUSH
49328: CALL_OW 1
49332: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49333: LD_ADDR_EXP 45
49337: PUSH
49338: LD_EXP 45
49342: PPUSH
49343: LD_VAR 0 2
49347: PPUSH
49348: EMPTY
49349: PPUSH
49350: CALL_OW 1
49354: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49355: LD_ADDR_EXP 46
49359: PUSH
49360: LD_EXP 46
49364: PPUSH
49365: LD_VAR 0 2
49369: PPUSH
49370: EMPTY
49371: PPUSH
49372: CALL_OW 1
49376: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49377: LD_ADDR_EXP 47
49381: PUSH
49382: LD_EXP 47
49386: PPUSH
49387: LD_VAR 0 2
49391: PPUSH
49392: EMPTY
49393: PUSH
49394: EMPTY
49395: PUSH
49396: EMPTY
49397: LIST
49398: LIST
49399: PPUSH
49400: CALL_OW 1
49404: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49405: LD_ADDR_EXP 48
49409: PUSH
49410: LD_EXP 48
49414: PPUSH
49415: LD_VAR 0 2
49419: PPUSH
49420: EMPTY
49421: PPUSH
49422: CALL_OW 1
49426: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49427: LD_ADDR_EXP 75
49431: PUSH
49432: LD_EXP 75
49436: PPUSH
49437: LD_VAR 0 2
49441: PPUSH
49442: EMPTY
49443: PPUSH
49444: CALL_OW 1
49448: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49449: LD_ADDR_EXP 49
49453: PUSH
49454: LD_EXP 49
49458: PPUSH
49459: LD_VAR 0 2
49463: PPUSH
49464: EMPTY
49465: PPUSH
49466: CALL_OW 1
49470: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49471: LD_ADDR_EXP 50
49475: PUSH
49476: LD_EXP 50
49480: PPUSH
49481: LD_VAR 0 2
49485: PPUSH
49486: EMPTY
49487: PPUSH
49488: CALL_OW 1
49492: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49493: LD_ADDR_EXP 51
49497: PUSH
49498: LD_EXP 51
49502: PPUSH
49503: LD_VAR 0 2
49507: PPUSH
49508: LD_EXP 43
49512: PUSH
49513: LD_VAR 0 2
49517: ARRAY
49518: PPUSH
49519: LD_INT 2
49521: PUSH
49522: LD_INT 30
49524: PUSH
49525: LD_INT 32
49527: PUSH
49528: EMPTY
49529: LIST
49530: LIST
49531: PUSH
49532: LD_INT 30
49534: PUSH
49535: LD_INT 33
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: LIST
49546: PPUSH
49547: CALL_OW 72
49551: PPUSH
49552: CALL_OW 1
49556: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49557: LD_ADDR_EXP 52
49561: PUSH
49562: LD_EXP 52
49566: PPUSH
49567: LD_VAR 0 2
49571: PPUSH
49572: LD_EXP 43
49576: PUSH
49577: LD_VAR 0 2
49581: ARRAY
49582: PPUSH
49583: LD_INT 2
49585: PUSH
49586: LD_INT 30
49588: PUSH
49589: LD_INT 32
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: PUSH
49596: LD_INT 30
49598: PUSH
49599: LD_INT 31
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: LIST
49610: PUSH
49611: LD_INT 58
49613: PUSH
49614: EMPTY
49615: LIST
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PPUSH
49621: CALL_OW 72
49625: PPUSH
49626: CALL_OW 1
49630: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49631: LD_ADDR_EXP 53
49635: PUSH
49636: LD_EXP 53
49640: PPUSH
49641: LD_VAR 0 2
49645: PPUSH
49646: EMPTY
49647: PPUSH
49648: CALL_OW 1
49652: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49653: LD_ADDR_EXP 57
49657: PUSH
49658: LD_EXP 57
49662: PPUSH
49663: LD_VAR 0 2
49667: PPUSH
49668: EMPTY
49669: PPUSH
49670: CALL_OW 1
49674: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49675: LD_ADDR_EXP 56
49679: PUSH
49680: LD_EXP 56
49684: PPUSH
49685: LD_VAR 0 2
49689: PPUSH
49690: EMPTY
49691: PPUSH
49692: CALL_OW 1
49696: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49697: LD_ADDR_EXP 58
49701: PUSH
49702: LD_EXP 58
49706: PPUSH
49707: LD_VAR 0 2
49711: PPUSH
49712: EMPTY
49713: PPUSH
49714: CALL_OW 1
49718: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49719: LD_ADDR_EXP 59
49723: PUSH
49724: LD_EXP 59
49728: PPUSH
49729: LD_VAR 0 2
49733: PPUSH
49734: EMPTY
49735: PPUSH
49736: CALL_OW 1
49740: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49741: LD_ADDR_EXP 60
49745: PUSH
49746: LD_EXP 60
49750: PPUSH
49751: LD_VAR 0 2
49755: PPUSH
49756: EMPTY
49757: PPUSH
49758: CALL_OW 1
49762: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49763: LD_ADDR_EXP 61
49767: PUSH
49768: LD_EXP 61
49772: PPUSH
49773: LD_VAR 0 2
49777: PPUSH
49778: EMPTY
49779: PPUSH
49780: CALL_OW 1
49784: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49785: LD_ADDR_EXP 62
49789: PUSH
49790: LD_EXP 62
49794: PPUSH
49795: LD_VAR 0 2
49799: PPUSH
49800: EMPTY
49801: PPUSH
49802: CALL_OW 1
49806: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49807: LD_ADDR_EXP 63
49811: PUSH
49812: LD_EXP 63
49816: PPUSH
49817: LD_VAR 0 2
49821: PPUSH
49822: EMPTY
49823: PPUSH
49824: CALL_OW 1
49828: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49829: LD_ADDR_EXP 64
49833: PUSH
49834: LD_EXP 64
49838: PPUSH
49839: LD_VAR 0 2
49843: PPUSH
49844: EMPTY
49845: PPUSH
49846: CALL_OW 1
49850: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49851: LD_ADDR_EXP 65
49855: PUSH
49856: LD_EXP 65
49860: PPUSH
49861: LD_VAR 0 2
49865: PPUSH
49866: EMPTY
49867: PPUSH
49868: CALL_OW 1
49872: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49873: LD_ADDR_EXP 54
49877: PUSH
49878: LD_EXP 54
49882: PPUSH
49883: LD_VAR 0 2
49887: PPUSH
49888: LD_INT 0
49890: PPUSH
49891: CALL_OW 1
49895: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49896: LD_ADDR_EXP 67
49900: PUSH
49901: LD_EXP 67
49905: PPUSH
49906: LD_VAR 0 2
49910: PPUSH
49911: LD_INT 0
49913: PPUSH
49914: CALL_OW 1
49918: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49919: LD_ADDR_EXP 55
49923: PUSH
49924: LD_EXP 55
49928: PPUSH
49929: LD_VAR 0 2
49933: PPUSH
49934: EMPTY
49935: PPUSH
49936: CALL_OW 1
49940: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49941: LD_ADDR_EXP 66
49945: PUSH
49946: LD_EXP 66
49950: PPUSH
49951: LD_VAR 0 2
49955: PPUSH
49956: LD_INT 0
49958: PPUSH
49959: CALL_OW 1
49963: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49964: LD_ADDR_EXP 68
49968: PUSH
49969: LD_EXP 68
49973: PPUSH
49974: LD_VAR 0 2
49978: PPUSH
49979: EMPTY
49980: PPUSH
49981: CALL_OW 1
49985: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
49986: LD_ADDR_EXP 71
49990: PUSH
49991: LD_EXP 71
49995: PPUSH
49996: LD_VAR 0 2
50000: PPUSH
50001: LD_INT 0
50003: PPUSH
50004: CALL_OW 1
50008: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
50009: LD_ADDR_EXP 72
50013: PUSH
50014: LD_EXP 72
50018: PPUSH
50019: LD_VAR 0 2
50023: PPUSH
50024: EMPTY
50025: PPUSH
50026: CALL_OW 1
50030: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50031: LD_ADDR_EXP 73
50035: PUSH
50036: LD_EXP 73
50040: PPUSH
50041: LD_VAR 0 2
50045: PPUSH
50046: EMPTY
50047: PPUSH
50048: CALL_OW 1
50052: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50053: LD_ADDR_EXP 74
50057: PUSH
50058: LD_EXP 74
50062: PPUSH
50063: LD_VAR 0 2
50067: PPUSH
50068: EMPTY
50069: PPUSH
50070: CALL_OW 1
50074: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
50075: LD_ADDR_EXP 76
50079: PUSH
50080: LD_EXP 76
50084: PPUSH
50085: LD_VAR 0 2
50089: PPUSH
50090: LD_EXP 43
50094: PUSH
50095: LD_VAR 0 2
50099: ARRAY
50100: PPUSH
50101: LD_INT 2
50103: PUSH
50104: LD_INT 30
50106: PUSH
50107: LD_INT 6
50109: PUSH
50110: EMPTY
50111: LIST
50112: LIST
50113: PUSH
50114: LD_INT 30
50116: PUSH
50117: LD_INT 7
50119: PUSH
50120: EMPTY
50121: LIST
50122: LIST
50123: PUSH
50124: LD_INT 30
50126: PUSH
50127: LD_INT 8
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PUSH
50134: EMPTY
50135: LIST
50136: LIST
50137: LIST
50138: LIST
50139: PPUSH
50140: CALL_OW 72
50144: PPUSH
50145: CALL_OW 1
50149: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50150: LD_ADDR_EXP 77
50154: PUSH
50155: LD_EXP 77
50159: PPUSH
50160: LD_VAR 0 2
50164: PPUSH
50165: EMPTY
50166: PPUSH
50167: CALL_OW 1
50171: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50172: LD_ADDR_EXP 78
50176: PUSH
50177: LD_EXP 78
50181: PPUSH
50182: LD_VAR 0 2
50186: PPUSH
50187: EMPTY
50188: PPUSH
50189: CALL_OW 1
50193: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50194: LD_ADDR_EXP 79
50198: PUSH
50199: LD_EXP 79
50203: PPUSH
50204: LD_VAR 0 2
50208: PPUSH
50209: EMPTY
50210: PPUSH
50211: CALL_OW 1
50215: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50216: LD_ADDR_EXP 80
50220: PUSH
50221: LD_EXP 80
50225: PPUSH
50226: LD_VAR 0 2
50230: PPUSH
50231: EMPTY
50232: PPUSH
50233: CALL_OW 1
50237: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50238: LD_ADDR_EXP 81
50242: PUSH
50243: LD_EXP 81
50247: PPUSH
50248: LD_VAR 0 2
50252: PPUSH
50253: EMPTY
50254: PPUSH
50255: CALL_OW 1
50259: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50260: LD_ADDR_EXP 82
50264: PUSH
50265: LD_EXP 82
50269: PPUSH
50270: LD_VAR 0 2
50274: PPUSH
50275: EMPTY
50276: PPUSH
50277: CALL_OW 1
50281: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50282: LD_ADDR_EXP 83
50286: PUSH
50287: LD_EXP 83
50291: PPUSH
50292: LD_VAR 0 2
50296: PPUSH
50297: EMPTY
50298: PPUSH
50299: CALL_OW 1
50303: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50304: LD_ADDR_EXP 84
50308: PUSH
50309: LD_EXP 84
50313: PPUSH
50314: LD_VAR 0 2
50318: PPUSH
50319: EMPTY
50320: PPUSH
50321: CALL_OW 1
50325: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50326: LD_ADDR_EXP 85
50330: PUSH
50331: LD_EXP 85
50335: PPUSH
50336: LD_VAR 0 2
50340: PPUSH
50341: LD_INT 0
50343: PPUSH
50344: CALL_OW 1
50348: ST_TO_ADDR
// end ;
50349: GO 49273
50351: POP
50352: POP
// MC_InitSides ( ) ;
50353: CALL 50639 0 0
// MC_InitResearch ( ) ;
50357: CALL 50378 0 0
// CustomInitMacro ( ) ;
50361: CALL 97 0 0
// skirmish := true ;
50365: LD_ADDR_EXP 41
50369: PUSH
50370: LD_INT 1
50372: ST_TO_ADDR
// end ;
50373: LD_VAR 0 1
50377: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50378: LD_INT 0
50380: PPUSH
50381: PPUSH
50382: PPUSH
50383: PPUSH
50384: PPUSH
50385: PPUSH
// if not mc_bases then
50386: LD_EXP 43
50390: NOT
50391: IFFALSE 50395
// exit ;
50393: GO 50634
// for i = 1 to 8 do
50395: LD_ADDR_VAR 0 2
50399: PUSH
50400: DOUBLE
50401: LD_INT 1
50403: DEC
50404: ST_TO_ADDR
50405: LD_INT 8
50407: PUSH
50408: FOR_TO
50409: IFFALSE 50435
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50411: LD_ADDR_EXP 70
50415: PUSH
50416: LD_EXP 70
50420: PPUSH
50421: LD_VAR 0 2
50425: PPUSH
50426: EMPTY
50427: PPUSH
50428: CALL_OW 1
50432: ST_TO_ADDR
50433: GO 50408
50435: POP
50436: POP
// tmp := [ ] ;
50437: LD_ADDR_VAR 0 5
50441: PUSH
50442: EMPTY
50443: ST_TO_ADDR
// for i = 1 to mc_sides do
50444: LD_ADDR_VAR 0 2
50448: PUSH
50449: DOUBLE
50450: LD_INT 1
50452: DEC
50453: ST_TO_ADDR
50454: LD_EXP 69
50458: PUSH
50459: FOR_TO
50460: IFFALSE 50518
// if not mc_sides [ i ] in tmp then
50462: LD_EXP 69
50466: PUSH
50467: LD_VAR 0 2
50471: ARRAY
50472: PUSH
50473: LD_VAR 0 5
50477: IN
50478: NOT
50479: IFFALSE 50516
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50481: LD_ADDR_VAR 0 5
50485: PUSH
50486: LD_VAR 0 5
50490: PPUSH
50491: LD_VAR 0 5
50495: PUSH
50496: LD_INT 1
50498: PLUS
50499: PPUSH
50500: LD_EXP 69
50504: PUSH
50505: LD_VAR 0 2
50509: ARRAY
50510: PPUSH
50511: CALL_OW 2
50515: ST_TO_ADDR
50516: GO 50459
50518: POP
50519: POP
// if not tmp then
50520: LD_VAR 0 5
50524: NOT
50525: IFFALSE 50529
// exit ;
50527: GO 50634
// for j in tmp do
50529: LD_ADDR_VAR 0 3
50533: PUSH
50534: LD_VAR 0 5
50538: PUSH
50539: FOR_IN
50540: IFFALSE 50632
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50542: LD_ADDR_VAR 0 6
50546: PUSH
50547: LD_INT 22
50549: PUSH
50550: LD_VAR 0 3
50554: PUSH
50555: EMPTY
50556: LIST
50557: LIST
50558: PPUSH
50559: CALL_OW 69
50563: ST_TO_ADDR
// if not un then
50564: LD_VAR 0 6
50568: NOT
50569: IFFALSE 50573
// continue ;
50571: GO 50539
// nation := GetNation ( un [ 1 ] ) ;
50573: LD_ADDR_VAR 0 4
50577: PUSH
50578: LD_VAR 0 6
50582: PUSH
50583: LD_INT 1
50585: ARRAY
50586: PPUSH
50587: CALL_OW 248
50591: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50592: LD_ADDR_EXP 70
50596: PUSH
50597: LD_EXP 70
50601: PPUSH
50602: LD_VAR 0 3
50606: PPUSH
50607: LD_VAR 0 3
50611: PPUSH
50612: LD_VAR 0 4
50616: PPUSH
50617: LD_INT 1
50619: PPUSH
50620: CALL 9914 0 3
50624: PPUSH
50625: CALL_OW 1
50629: ST_TO_ADDR
// end ;
50630: GO 50539
50632: POP
50633: POP
// end ;
50634: LD_VAR 0 1
50638: RET
// export function MC_InitSides ( ) ; var i ; begin
50639: LD_INT 0
50641: PPUSH
50642: PPUSH
// if not mc_bases then
50643: LD_EXP 43
50647: NOT
50648: IFFALSE 50652
// exit ;
50650: GO 50726
// for i = 1 to mc_bases do
50652: LD_ADDR_VAR 0 2
50656: PUSH
50657: DOUBLE
50658: LD_INT 1
50660: DEC
50661: ST_TO_ADDR
50662: LD_EXP 43
50666: PUSH
50667: FOR_TO
50668: IFFALSE 50724
// if mc_bases [ i ] then
50670: LD_EXP 43
50674: PUSH
50675: LD_VAR 0 2
50679: ARRAY
50680: IFFALSE 50722
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50682: LD_ADDR_EXP 69
50686: PUSH
50687: LD_EXP 69
50691: PPUSH
50692: LD_VAR 0 2
50696: PPUSH
50697: LD_EXP 43
50701: PUSH
50702: LD_VAR 0 2
50706: ARRAY
50707: PUSH
50708: LD_INT 1
50710: ARRAY
50711: PPUSH
50712: CALL_OW 255
50716: PPUSH
50717: CALL_OW 1
50721: ST_TO_ADDR
50722: GO 50667
50724: POP
50725: POP
// end ;
50726: LD_VAR 0 1
50730: RET
// every 0 0$03 trigger skirmish do
50731: LD_EXP 41
50735: IFFALSE 50889
50737: GO 50739
50739: DISABLE
// begin enable ;
50740: ENABLE
// MC_CheckBuildings ( ) ;
50741: CALL 55387 0 0
// MC_CheckPeopleLife ( ) ;
50745: CALL 55512 0 0
// RaiseSailEvent ( 100 ) ;
50749: LD_INT 100
50751: PPUSH
50752: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50756: LD_INT 103
50758: PPUSH
50759: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50763: LD_INT 104
50765: PPUSH
50766: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50770: LD_INT 105
50772: PPUSH
50773: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50777: LD_INT 106
50779: PPUSH
50780: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50784: LD_INT 107
50786: PPUSH
50787: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50791: LD_INT 108
50793: PPUSH
50794: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50798: LD_INT 109
50800: PPUSH
50801: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50805: LD_INT 110
50807: PPUSH
50808: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50812: LD_INT 111
50814: PPUSH
50815: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50819: LD_INT 112
50821: PPUSH
50822: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50826: LD_INT 113
50828: PPUSH
50829: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50833: LD_INT 120
50835: PPUSH
50836: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50840: LD_INT 121
50842: PPUSH
50843: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50847: LD_INT 122
50849: PPUSH
50850: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50854: LD_INT 123
50856: PPUSH
50857: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50861: LD_INT 124
50863: PPUSH
50864: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50868: LD_INT 125
50870: PPUSH
50871: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50875: LD_INT 126
50877: PPUSH
50878: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50882: LD_INT 200
50884: PPUSH
50885: CALL_OW 427
// end ;
50889: END
// on SailEvent ( event ) do begin if event < 100 then
50890: LD_VAR 0 1
50894: PUSH
50895: LD_INT 100
50897: LESS
50898: IFFALSE 50909
// CustomEvent ( event ) ;
50900: LD_VAR 0 1
50904: PPUSH
50905: CALL 603 0 1
// if event = 100 then
50909: LD_VAR 0 1
50913: PUSH
50914: LD_INT 100
50916: EQUAL
50917: IFFALSE 50923
// MC_ClassManager ( ) ;
50919: CALL 51315 0 0
// if event = 101 then
50923: LD_VAR 0 1
50927: PUSH
50928: LD_INT 101
50930: EQUAL
50931: IFFALSE 50937
// MC_RepairBuildings ( ) ;
50933: CALL 56097 0 0
// if event = 102 then
50937: LD_VAR 0 1
50941: PUSH
50942: LD_INT 102
50944: EQUAL
50945: IFFALSE 50951
// MC_Heal ( ) ;
50947: CALL 56982 0 0
// if event = 103 then
50951: LD_VAR 0 1
50955: PUSH
50956: LD_INT 103
50958: EQUAL
50959: IFFALSE 50965
// MC_Build ( ) ;
50961: CALL 57404 0 0
// if event = 104 then
50965: LD_VAR 0 1
50969: PUSH
50970: LD_INT 104
50972: EQUAL
50973: IFFALSE 50979
// MC_TurretWeapon ( ) ;
50975: CALL 59017 0 0
// if event = 105 then
50979: LD_VAR 0 1
50983: PUSH
50984: LD_INT 105
50986: EQUAL
50987: IFFALSE 50993
// MC_BuildUpgrade ( ) ;
50989: CALL 58568 0 0
// if event = 106 then
50993: LD_VAR 0 1
50997: PUSH
50998: LD_INT 106
51000: EQUAL
51001: IFFALSE 51007
// MC_PlantMines ( ) ;
51003: CALL 59447 0 0
// if event = 107 then
51007: LD_VAR 0 1
51011: PUSH
51012: LD_INT 107
51014: EQUAL
51015: IFFALSE 51021
// MC_CollectCrates ( ) ;
51017: CALL 60238 0 0
// if event = 108 then
51021: LD_VAR 0 1
51025: PUSH
51026: LD_INT 108
51028: EQUAL
51029: IFFALSE 51035
// MC_LinkRemoteControl ( ) ;
51031: CALL 62014 0 0
// if event = 109 then
51035: LD_VAR 0 1
51039: PUSH
51040: LD_INT 109
51042: EQUAL
51043: IFFALSE 51049
// MC_ProduceVehicle ( ) ;
51045: CALL 62195 0 0
// if event = 110 then
51049: LD_VAR 0 1
51053: PUSH
51054: LD_INT 110
51056: EQUAL
51057: IFFALSE 51063
// MC_SendAttack ( ) ;
51059: CALL 62661 0 0
// if event = 111 then
51063: LD_VAR 0 1
51067: PUSH
51068: LD_INT 111
51070: EQUAL
51071: IFFALSE 51077
// MC_Defend ( ) ;
51073: CALL 62769 0 0
// if event = 112 then
51077: LD_VAR 0 1
51081: PUSH
51082: LD_INT 112
51084: EQUAL
51085: IFFALSE 51091
// MC_Research ( ) ;
51087: CALL 63396 0 0
// if event = 113 then
51091: LD_VAR 0 1
51095: PUSH
51096: LD_INT 113
51098: EQUAL
51099: IFFALSE 51105
// MC_MinesTrigger ( ) ;
51101: CALL 64510 0 0
// if event = 120 then
51105: LD_VAR 0 1
51109: PUSH
51110: LD_INT 120
51112: EQUAL
51113: IFFALSE 51119
// MC_RepairVehicle ( ) ;
51115: CALL 64609 0 0
// if event = 121 then
51119: LD_VAR 0 1
51123: PUSH
51124: LD_INT 121
51126: EQUAL
51127: IFFALSE 51133
// MC_TameApe ( ) ;
51129: CALL 65339 0 0
// if event = 122 then
51133: LD_VAR 0 1
51137: PUSH
51138: LD_INT 122
51140: EQUAL
51141: IFFALSE 51147
// MC_ChangeApeClass ( ) ;
51143: CALL 66168 0 0
// if event = 123 then
51147: LD_VAR 0 1
51151: PUSH
51152: LD_INT 123
51154: EQUAL
51155: IFFALSE 51161
// MC_Bazooka ( ) ;
51157: CALL 66818 0 0
// if event = 124 then
51161: LD_VAR 0 1
51165: PUSH
51166: LD_INT 124
51168: EQUAL
51169: IFFALSE 51175
// MC_TeleportExit ( ) ;
51171: CALL 67016 0 0
// if event = 125 then
51175: LD_VAR 0 1
51179: PUSH
51180: LD_INT 125
51182: EQUAL
51183: IFFALSE 51189
// MC_Deposits ( ) ;
51185: CALL 67663 0 0
// if event = 126 then
51189: LD_VAR 0 1
51193: PUSH
51194: LD_INT 126
51196: EQUAL
51197: IFFALSE 51203
// MC_RemoteDriver ( ) ;
51199: CALL 68288 0 0
// if event = 200 then
51203: LD_VAR 0 1
51207: PUSH
51208: LD_INT 200
51210: EQUAL
51211: IFFALSE 51217
// MC_Idle ( ) ;
51213: CALL 70237 0 0
// end ;
51217: PPOPN 1
51219: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51220: LD_INT 0
51222: PPUSH
51223: PPUSH
// if not mc_bases [ base ] or not tag then
51224: LD_EXP 43
51228: PUSH
51229: LD_VAR 0 1
51233: ARRAY
51234: NOT
51235: PUSH
51236: LD_VAR 0 2
51240: NOT
51241: OR
51242: IFFALSE 51246
// exit ;
51244: GO 51310
// for i in mc_bases [ base ] union mc_ape [ base ] do
51246: LD_ADDR_VAR 0 4
51250: PUSH
51251: LD_EXP 43
51255: PUSH
51256: LD_VAR 0 1
51260: ARRAY
51261: PUSH
51262: LD_EXP 72
51266: PUSH
51267: LD_VAR 0 1
51271: ARRAY
51272: UNION
51273: PUSH
51274: FOR_IN
51275: IFFALSE 51308
// if GetTag ( i ) = tag then
51277: LD_VAR 0 4
51281: PPUSH
51282: CALL_OW 110
51286: PUSH
51287: LD_VAR 0 2
51291: EQUAL
51292: IFFALSE 51306
// SetTag ( i , 0 ) ;
51294: LD_VAR 0 4
51298: PPUSH
51299: LD_INT 0
51301: PPUSH
51302: CALL_OW 109
51306: GO 51274
51308: POP
51309: POP
// end ;
51310: LD_VAR 0 3
51314: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51315: LD_INT 0
51317: PPUSH
51318: PPUSH
51319: PPUSH
51320: PPUSH
51321: PPUSH
51322: PPUSH
51323: PPUSH
51324: PPUSH
// if not mc_bases then
51325: LD_EXP 43
51329: NOT
51330: IFFALSE 51334
// exit ;
51332: GO 51792
// for i = 1 to mc_bases do
51334: LD_ADDR_VAR 0 2
51338: PUSH
51339: DOUBLE
51340: LD_INT 1
51342: DEC
51343: ST_TO_ADDR
51344: LD_EXP 43
51348: PUSH
51349: FOR_TO
51350: IFFALSE 51790
// begin tmp := MC_ClassCheckReq ( i ) ;
51352: LD_ADDR_VAR 0 4
51356: PUSH
51357: LD_VAR 0 2
51361: PPUSH
51362: CALL 51797 0 1
51366: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51367: LD_ADDR_EXP 84
51371: PUSH
51372: LD_EXP 84
51376: PPUSH
51377: LD_VAR 0 2
51381: PPUSH
51382: LD_VAR 0 4
51386: PPUSH
51387: CALL_OW 1
51391: ST_TO_ADDR
// if not tmp then
51392: LD_VAR 0 4
51396: NOT
51397: IFFALSE 51401
// continue ;
51399: GO 51349
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51401: LD_ADDR_VAR 0 6
51405: PUSH
51406: LD_EXP 43
51410: PUSH
51411: LD_VAR 0 2
51415: ARRAY
51416: PPUSH
51417: LD_INT 2
51419: PUSH
51420: LD_INT 30
51422: PUSH
51423: LD_INT 4
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 30
51432: PUSH
51433: LD_INT 5
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: LIST
51444: PPUSH
51445: CALL_OW 72
51449: PUSH
51450: LD_EXP 43
51454: PUSH
51455: LD_VAR 0 2
51459: ARRAY
51460: PPUSH
51461: LD_INT 2
51463: PUSH
51464: LD_INT 30
51466: PUSH
51467: LD_INT 0
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: PUSH
51474: LD_INT 30
51476: PUSH
51477: LD_INT 1
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: LIST
51488: PPUSH
51489: CALL_OW 72
51493: PUSH
51494: LD_EXP 43
51498: PUSH
51499: LD_VAR 0 2
51503: ARRAY
51504: PPUSH
51505: LD_INT 30
51507: PUSH
51508: LD_INT 3
51510: PUSH
51511: EMPTY
51512: LIST
51513: LIST
51514: PPUSH
51515: CALL_OW 72
51519: PUSH
51520: LD_EXP 43
51524: PUSH
51525: LD_VAR 0 2
51529: ARRAY
51530: PPUSH
51531: LD_INT 2
51533: PUSH
51534: LD_INT 30
51536: PUSH
51537: LD_INT 6
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: PUSH
51544: LD_INT 30
51546: PUSH
51547: LD_INT 7
51549: PUSH
51550: EMPTY
51551: LIST
51552: LIST
51553: PUSH
51554: LD_INT 30
51556: PUSH
51557: LD_INT 8
51559: PUSH
51560: EMPTY
51561: LIST
51562: LIST
51563: PUSH
51564: EMPTY
51565: LIST
51566: LIST
51567: LIST
51568: LIST
51569: PPUSH
51570: CALL_OW 72
51574: PUSH
51575: EMPTY
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: ST_TO_ADDR
// for j = 1 to 4 do
51581: LD_ADDR_VAR 0 3
51585: PUSH
51586: DOUBLE
51587: LD_INT 1
51589: DEC
51590: ST_TO_ADDR
51591: LD_INT 4
51593: PUSH
51594: FOR_TO
51595: IFFALSE 51786
// begin if not tmp [ j ] then
51597: LD_VAR 0 4
51601: PUSH
51602: LD_VAR 0 3
51606: ARRAY
51607: NOT
51608: IFFALSE 51612
// continue ;
51610: GO 51594
// for p in tmp [ j ] do
51612: LD_ADDR_VAR 0 5
51616: PUSH
51617: LD_VAR 0 4
51621: PUSH
51622: LD_VAR 0 3
51626: ARRAY
51627: PUSH
51628: FOR_IN
51629: IFFALSE 51782
// begin if not b [ j ] then
51631: LD_VAR 0 6
51635: PUSH
51636: LD_VAR 0 3
51640: ARRAY
51641: NOT
51642: IFFALSE 51646
// break ;
51644: GO 51782
// e := 0 ;
51646: LD_ADDR_VAR 0 7
51650: PUSH
51651: LD_INT 0
51653: ST_TO_ADDR
// for k in b [ j ] do
51654: LD_ADDR_VAR 0 8
51658: PUSH
51659: LD_VAR 0 6
51663: PUSH
51664: LD_VAR 0 3
51668: ARRAY
51669: PUSH
51670: FOR_IN
51671: IFFALSE 51698
// if IsNotFull ( k ) then
51673: LD_VAR 0 8
51677: PPUSH
51678: CALL 12063 0 1
51682: IFFALSE 51696
// begin e := k ;
51684: LD_ADDR_VAR 0 7
51688: PUSH
51689: LD_VAR 0 8
51693: ST_TO_ADDR
// break ;
51694: GO 51698
// end ;
51696: GO 51670
51698: POP
51699: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51700: LD_VAR 0 7
51704: PUSH
51705: LD_VAR 0 5
51709: PPUSH
51710: LD_VAR 0 7
51714: PPUSH
51715: CALL 44495 0 2
51719: NOT
51720: AND
51721: IFFALSE 51780
// begin if IsInUnit ( p ) then
51723: LD_VAR 0 5
51727: PPUSH
51728: CALL_OW 310
51732: IFFALSE 51743
// ComExitBuilding ( p ) ;
51734: LD_VAR 0 5
51738: PPUSH
51739: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51743: LD_VAR 0 5
51747: PPUSH
51748: LD_VAR 0 7
51752: PPUSH
51753: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51757: LD_VAR 0 5
51761: PPUSH
51762: LD_VAR 0 3
51766: PPUSH
51767: CALL_OW 183
// AddComExitBuilding ( p ) ;
51771: LD_VAR 0 5
51775: PPUSH
51776: CALL_OW 182
// end ; end ;
51780: GO 51628
51782: POP
51783: POP
// end ;
51784: GO 51594
51786: POP
51787: POP
// end ;
51788: GO 51349
51790: POP
51791: POP
// end ;
51792: LD_VAR 0 1
51796: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51797: LD_INT 0
51799: PPUSH
51800: PPUSH
51801: PPUSH
51802: PPUSH
51803: PPUSH
51804: PPUSH
51805: PPUSH
51806: PPUSH
51807: PPUSH
51808: PPUSH
51809: PPUSH
51810: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51811: LD_VAR 0 1
51815: NOT
51816: PUSH
51817: LD_EXP 43
51821: PUSH
51822: LD_VAR 0 1
51826: ARRAY
51827: NOT
51828: OR
51829: PUSH
51830: LD_EXP 43
51834: PUSH
51835: LD_VAR 0 1
51839: ARRAY
51840: PPUSH
51841: LD_INT 2
51843: PUSH
51844: LD_INT 30
51846: PUSH
51847: LD_INT 0
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: LD_INT 30
51856: PUSH
51857: LD_INT 1
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: LIST
51868: PPUSH
51869: CALL_OW 72
51873: NOT
51874: OR
51875: IFFALSE 51879
// exit ;
51877: GO 55382
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51879: LD_ADDR_VAR 0 4
51883: PUSH
51884: LD_EXP 43
51888: PUSH
51889: LD_VAR 0 1
51893: ARRAY
51894: PPUSH
51895: LD_INT 2
51897: PUSH
51898: LD_INT 25
51900: PUSH
51901: LD_INT 1
51903: PUSH
51904: EMPTY
51905: LIST
51906: LIST
51907: PUSH
51908: LD_INT 25
51910: PUSH
51911: LD_INT 2
51913: PUSH
51914: EMPTY
51915: LIST
51916: LIST
51917: PUSH
51918: LD_INT 25
51920: PUSH
51921: LD_INT 3
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PUSH
51928: LD_INT 25
51930: PUSH
51931: LD_INT 4
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PUSH
51938: LD_INT 25
51940: PUSH
51941: LD_INT 5
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: PUSH
51948: LD_INT 25
51950: PUSH
51951: LD_INT 8
51953: PUSH
51954: EMPTY
51955: LIST
51956: LIST
51957: PUSH
51958: LD_INT 25
51960: PUSH
51961: LD_INT 9
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: LIST
51976: LIST
51977: PPUSH
51978: CALL_OW 72
51982: ST_TO_ADDR
// if not tmp then
51983: LD_VAR 0 4
51987: NOT
51988: IFFALSE 51992
// exit ;
51990: GO 55382
// for i in tmp do
51992: LD_ADDR_VAR 0 3
51996: PUSH
51997: LD_VAR 0 4
52001: PUSH
52002: FOR_IN
52003: IFFALSE 52034
// if GetTag ( i ) then
52005: LD_VAR 0 3
52009: PPUSH
52010: CALL_OW 110
52014: IFFALSE 52032
// tmp := tmp diff i ;
52016: LD_ADDR_VAR 0 4
52020: PUSH
52021: LD_VAR 0 4
52025: PUSH
52026: LD_VAR 0 3
52030: DIFF
52031: ST_TO_ADDR
52032: GO 52002
52034: POP
52035: POP
// if not tmp then
52036: LD_VAR 0 4
52040: NOT
52041: IFFALSE 52045
// exit ;
52043: GO 55382
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52045: LD_ADDR_VAR 0 5
52049: PUSH
52050: LD_EXP 43
52054: PUSH
52055: LD_VAR 0 1
52059: ARRAY
52060: PPUSH
52061: LD_INT 2
52063: PUSH
52064: LD_INT 25
52066: PUSH
52067: LD_INT 1
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: PUSH
52074: LD_INT 25
52076: PUSH
52077: LD_INT 5
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: PUSH
52084: LD_INT 25
52086: PUSH
52087: LD_INT 8
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: PUSH
52094: LD_INT 25
52096: PUSH
52097: LD_INT 9
52099: PUSH
52100: EMPTY
52101: LIST
52102: LIST
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: PPUSH
52111: CALL_OW 72
52115: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52116: LD_ADDR_VAR 0 6
52120: PUSH
52121: LD_EXP 43
52125: PUSH
52126: LD_VAR 0 1
52130: ARRAY
52131: PPUSH
52132: LD_INT 25
52134: PUSH
52135: LD_INT 2
52137: PUSH
52138: EMPTY
52139: LIST
52140: LIST
52141: PPUSH
52142: CALL_OW 72
52146: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52147: LD_ADDR_VAR 0 7
52151: PUSH
52152: LD_EXP 43
52156: PUSH
52157: LD_VAR 0 1
52161: ARRAY
52162: PPUSH
52163: LD_INT 25
52165: PUSH
52166: LD_INT 3
52168: PUSH
52169: EMPTY
52170: LIST
52171: LIST
52172: PPUSH
52173: CALL_OW 72
52177: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52178: LD_ADDR_VAR 0 8
52182: PUSH
52183: LD_EXP 43
52187: PUSH
52188: LD_VAR 0 1
52192: ARRAY
52193: PPUSH
52194: LD_INT 25
52196: PUSH
52197: LD_INT 4
52199: PUSH
52200: EMPTY
52201: LIST
52202: LIST
52203: PUSH
52204: LD_INT 24
52206: PUSH
52207: LD_INT 251
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: PPUSH
52218: CALL_OW 72
52222: ST_TO_ADDR
// if mc_scan [ base ] then
52223: LD_EXP 66
52227: PUSH
52228: LD_VAR 0 1
52232: ARRAY
52233: IFFALSE 52694
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52235: LD_ADDR_EXP 85
52239: PUSH
52240: LD_EXP 85
52244: PPUSH
52245: LD_VAR 0 1
52249: PPUSH
52250: LD_INT 4
52252: PPUSH
52253: CALL_OW 1
52257: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52258: LD_ADDR_VAR 0 12
52262: PUSH
52263: LD_EXP 43
52267: PUSH
52268: LD_VAR 0 1
52272: ARRAY
52273: PPUSH
52274: LD_INT 2
52276: PUSH
52277: LD_INT 30
52279: PUSH
52280: LD_INT 4
52282: PUSH
52283: EMPTY
52284: LIST
52285: LIST
52286: PUSH
52287: LD_INT 30
52289: PUSH
52290: LD_INT 5
52292: PUSH
52293: EMPTY
52294: LIST
52295: LIST
52296: PUSH
52297: EMPTY
52298: LIST
52299: LIST
52300: LIST
52301: PPUSH
52302: CALL_OW 72
52306: ST_TO_ADDR
// if not b then
52307: LD_VAR 0 12
52311: NOT
52312: IFFALSE 52316
// exit ;
52314: GO 55382
// p := [ ] ;
52316: LD_ADDR_VAR 0 11
52320: PUSH
52321: EMPTY
52322: ST_TO_ADDR
// if sci >= 2 then
52323: LD_VAR 0 8
52327: PUSH
52328: LD_INT 2
52330: GREATEREQUAL
52331: IFFALSE 52362
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52333: LD_ADDR_VAR 0 8
52337: PUSH
52338: LD_VAR 0 8
52342: PUSH
52343: LD_INT 1
52345: ARRAY
52346: PUSH
52347: LD_VAR 0 8
52351: PUSH
52352: LD_INT 2
52354: ARRAY
52355: PUSH
52356: EMPTY
52357: LIST
52358: LIST
52359: ST_TO_ADDR
52360: GO 52423
// if sci = 1 then
52362: LD_VAR 0 8
52366: PUSH
52367: LD_INT 1
52369: EQUAL
52370: IFFALSE 52391
// sci := [ sci [ 1 ] ] else
52372: LD_ADDR_VAR 0 8
52376: PUSH
52377: LD_VAR 0 8
52381: PUSH
52382: LD_INT 1
52384: ARRAY
52385: PUSH
52386: EMPTY
52387: LIST
52388: ST_TO_ADDR
52389: GO 52423
// if sci = 0 then
52391: LD_VAR 0 8
52395: PUSH
52396: LD_INT 0
52398: EQUAL
52399: IFFALSE 52423
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52401: LD_ADDR_VAR 0 11
52405: PUSH
52406: LD_VAR 0 4
52410: PPUSH
52411: LD_INT 4
52413: PPUSH
52414: CALL 44358 0 2
52418: PUSH
52419: LD_INT 1
52421: ARRAY
52422: ST_TO_ADDR
// if eng > 4 then
52423: LD_VAR 0 6
52427: PUSH
52428: LD_INT 4
52430: GREATER
52431: IFFALSE 52477
// for i = eng downto 4 do
52433: LD_ADDR_VAR 0 3
52437: PUSH
52438: DOUBLE
52439: LD_VAR 0 6
52443: INC
52444: ST_TO_ADDR
52445: LD_INT 4
52447: PUSH
52448: FOR_DOWNTO
52449: IFFALSE 52475
// eng := eng diff eng [ i ] ;
52451: LD_ADDR_VAR 0 6
52455: PUSH
52456: LD_VAR 0 6
52460: PUSH
52461: LD_VAR 0 6
52465: PUSH
52466: LD_VAR 0 3
52470: ARRAY
52471: DIFF
52472: ST_TO_ADDR
52473: GO 52448
52475: POP
52476: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52477: LD_ADDR_VAR 0 4
52481: PUSH
52482: LD_VAR 0 4
52486: PUSH
52487: LD_VAR 0 5
52491: PUSH
52492: LD_VAR 0 6
52496: UNION
52497: PUSH
52498: LD_VAR 0 7
52502: UNION
52503: PUSH
52504: LD_VAR 0 8
52508: UNION
52509: DIFF
52510: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52511: LD_ADDR_VAR 0 13
52515: PUSH
52516: LD_EXP 43
52520: PUSH
52521: LD_VAR 0 1
52525: ARRAY
52526: PPUSH
52527: LD_INT 2
52529: PUSH
52530: LD_INT 30
52532: PUSH
52533: LD_INT 32
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 30
52542: PUSH
52543: LD_INT 31
52545: PUSH
52546: EMPTY
52547: LIST
52548: LIST
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: LIST
52554: PPUSH
52555: CALL_OW 72
52559: PUSH
52560: LD_EXP 43
52564: PUSH
52565: LD_VAR 0 1
52569: ARRAY
52570: PPUSH
52571: LD_INT 2
52573: PUSH
52574: LD_INT 30
52576: PUSH
52577: LD_INT 4
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: LD_INT 30
52586: PUSH
52587: LD_INT 5
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: LIST
52598: PPUSH
52599: CALL_OW 72
52603: PUSH
52604: LD_INT 6
52606: MUL
52607: PLUS
52608: ST_TO_ADDR
// if bcount < tmp then
52609: LD_VAR 0 13
52613: PUSH
52614: LD_VAR 0 4
52618: LESS
52619: IFFALSE 52665
// for i = tmp downto bcount do
52621: LD_ADDR_VAR 0 3
52625: PUSH
52626: DOUBLE
52627: LD_VAR 0 4
52631: INC
52632: ST_TO_ADDR
52633: LD_VAR 0 13
52637: PUSH
52638: FOR_DOWNTO
52639: IFFALSE 52663
// tmp := Delete ( tmp , tmp ) ;
52641: LD_ADDR_VAR 0 4
52645: PUSH
52646: LD_VAR 0 4
52650: PPUSH
52651: LD_VAR 0 4
52655: PPUSH
52656: CALL_OW 3
52660: ST_TO_ADDR
52661: GO 52638
52663: POP
52664: POP
// result := [ tmp , 0 , 0 , p ] ;
52665: LD_ADDR_VAR 0 2
52669: PUSH
52670: LD_VAR 0 4
52674: PUSH
52675: LD_INT 0
52677: PUSH
52678: LD_INT 0
52680: PUSH
52681: LD_VAR 0 11
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: LIST
52690: LIST
52691: ST_TO_ADDR
// exit ;
52692: GO 55382
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52694: LD_EXP 43
52698: PUSH
52699: LD_VAR 0 1
52703: ARRAY
52704: PPUSH
52705: LD_INT 2
52707: PUSH
52708: LD_INT 30
52710: PUSH
52711: LD_INT 6
52713: PUSH
52714: EMPTY
52715: LIST
52716: LIST
52717: PUSH
52718: LD_INT 30
52720: PUSH
52721: LD_INT 7
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PUSH
52728: LD_INT 30
52730: PUSH
52731: LD_INT 8
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 72
52748: NOT
52749: PUSH
52750: LD_EXP 43
52754: PUSH
52755: LD_VAR 0 1
52759: ARRAY
52760: PPUSH
52761: LD_INT 30
52763: PUSH
52764: LD_INT 3
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: PPUSH
52771: CALL_OW 72
52775: NOT
52776: AND
52777: IFFALSE 52849
// begin if eng = tmp then
52779: LD_VAR 0 6
52783: PUSH
52784: LD_VAR 0 4
52788: EQUAL
52789: IFFALSE 52793
// exit ;
52791: GO 55382
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52793: LD_ADDR_EXP 85
52797: PUSH
52798: LD_EXP 85
52802: PPUSH
52803: LD_VAR 0 1
52807: PPUSH
52808: LD_INT 1
52810: PPUSH
52811: CALL_OW 1
52815: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52816: LD_ADDR_VAR 0 2
52820: PUSH
52821: LD_INT 0
52823: PUSH
52824: LD_VAR 0 4
52828: PUSH
52829: LD_VAR 0 6
52833: DIFF
52834: PUSH
52835: LD_INT 0
52837: PUSH
52838: LD_INT 0
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: LIST
52845: LIST
52846: ST_TO_ADDR
// exit ;
52847: GO 55382
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52849: LD_EXP 70
52853: PUSH
52854: LD_EXP 69
52858: PUSH
52859: LD_VAR 0 1
52863: ARRAY
52864: ARRAY
52865: PUSH
52866: LD_EXP 43
52870: PUSH
52871: LD_VAR 0 1
52875: ARRAY
52876: PPUSH
52877: LD_INT 2
52879: PUSH
52880: LD_INT 30
52882: PUSH
52883: LD_INT 6
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 30
52892: PUSH
52893: LD_INT 7
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: LD_INT 30
52902: PUSH
52903: LD_INT 8
52905: PUSH
52906: EMPTY
52907: LIST
52908: LIST
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 72
52920: AND
52921: PUSH
52922: LD_EXP 43
52926: PUSH
52927: LD_VAR 0 1
52931: ARRAY
52932: PPUSH
52933: LD_INT 30
52935: PUSH
52936: LD_INT 3
52938: PUSH
52939: EMPTY
52940: LIST
52941: LIST
52942: PPUSH
52943: CALL_OW 72
52947: NOT
52948: AND
52949: IFFALSE 53163
// begin if sci >= 6 then
52951: LD_VAR 0 8
52955: PUSH
52956: LD_INT 6
52958: GREATEREQUAL
52959: IFFALSE 52963
// exit ;
52961: GO 55382
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
52963: LD_ADDR_EXP 85
52967: PUSH
52968: LD_EXP 85
52972: PPUSH
52973: LD_VAR 0 1
52977: PPUSH
52978: LD_INT 2
52980: PPUSH
52981: CALL_OW 1
52985: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
52986: LD_ADDR_VAR 0 9
52990: PUSH
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 8
53000: DIFF
53001: PPUSH
53002: LD_INT 4
53004: PPUSH
53005: CALL 44358 0 2
53009: ST_TO_ADDR
// p := [ ] ;
53010: LD_ADDR_VAR 0 11
53014: PUSH
53015: EMPTY
53016: ST_TO_ADDR
// if sci < 6 and sort > 6 then
53017: LD_VAR 0 8
53021: PUSH
53022: LD_INT 6
53024: LESS
53025: PUSH
53026: LD_VAR 0 9
53030: PUSH
53031: LD_INT 6
53033: GREATER
53034: AND
53035: IFFALSE 53116
// begin for i = 1 to 6 - sci do
53037: LD_ADDR_VAR 0 3
53041: PUSH
53042: DOUBLE
53043: LD_INT 1
53045: DEC
53046: ST_TO_ADDR
53047: LD_INT 6
53049: PUSH
53050: LD_VAR 0 8
53054: MINUS
53055: PUSH
53056: FOR_TO
53057: IFFALSE 53112
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
53059: LD_ADDR_VAR 0 11
53063: PUSH
53064: LD_VAR 0 11
53068: PPUSH
53069: LD_VAR 0 11
53073: PUSH
53074: LD_INT 1
53076: PLUS
53077: PPUSH
53078: LD_VAR 0 9
53082: PUSH
53083: LD_INT 1
53085: ARRAY
53086: PPUSH
53087: CALL_OW 2
53091: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53092: LD_ADDR_VAR 0 9
53096: PUSH
53097: LD_VAR 0 9
53101: PPUSH
53102: LD_INT 1
53104: PPUSH
53105: CALL_OW 3
53109: ST_TO_ADDR
// end ;
53110: GO 53056
53112: POP
53113: POP
// end else
53114: GO 53136
// if sort then
53116: LD_VAR 0 9
53120: IFFALSE 53136
// p := sort [ 1 ] ;
53122: LD_ADDR_VAR 0 11
53126: PUSH
53127: LD_VAR 0 9
53131: PUSH
53132: LD_INT 1
53134: ARRAY
53135: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53136: LD_ADDR_VAR 0 2
53140: PUSH
53141: LD_INT 0
53143: PUSH
53144: LD_INT 0
53146: PUSH
53147: LD_INT 0
53149: PUSH
53150: LD_VAR 0 11
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: ST_TO_ADDR
// exit ;
53161: GO 55382
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53163: LD_EXP 70
53167: PUSH
53168: LD_EXP 69
53172: PUSH
53173: LD_VAR 0 1
53177: ARRAY
53178: ARRAY
53179: PUSH
53180: LD_EXP 43
53184: PUSH
53185: LD_VAR 0 1
53189: ARRAY
53190: PPUSH
53191: LD_INT 2
53193: PUSH
53194: LD_INT 30
53196: PUSH
53197: LD_INT 6
53199: PUSH
53200: EMPTY
53201: LIST
53202: LIST
53203: PUSH
53204: LD_INT 30
53206: PUSH
53207: LD_INT 7
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: PUSH
53214: LD_INT 30
53216: PUSH
53217: LD_INT 8
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: PUSH
53224: EMPTY
53225: LIST
53226: LIST
53227: LIST
53228: LIST
53229: PPUSH
53230: CALL_OW 72
53234: AND
53235: PUSH
53236: LD_EXP 43
53240: PUSH
53241: LD_VAR 0 1
53245: ARRAY
53246: PPUSH
53247: LD_INT 30
53249: PUSH
53250: LD_INT 3
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: PPUSH
53257: CALL_OW 72
53261: AND
53262: IFFALSE 53996
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53264: LD_ADDR_EXP 85
53268: PUSH
53269: LD_EXP 85
53273: PPUSH
53274: LD_VAR 0 1
53278: PPUSH
53279: LD_INT 3
53281: PPUSH
53282: CALL_OW 1
53286: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53287: LD_ADDR_VAR 0 2
53291: PUSH
53292: LD_INT 0
53294: PUSH
53295: LD_INT 0
53297: PUSH
53298: LD_INT 0
53300: PUSH
53301: LD_INT 0
53303: PUSH
53304: EMPTY
53305: LIST
53306: LIST
53307: LIST
53308: LIST
53309: ST_TO_ADDR
// if not eng then
53310: LD_VAR 0 6
53314: NOT
53315: IFFALSE 53378
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53317: LD_ADDR_VAR 0 11
53321: PUSH
53322: LD_VAR 0 4
53326: PPUSH
53327: LD_INT 2
53329: PPUSH
53330: CALL 44358 0 2
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53339: LD_ADDR_VAR 0 2
53343: PUSH
53344: LD_VAR 0 2
53348: PPUSH
53349: LD_INT 2
53351: PPUSH
53352: LD_VAR 0 11
53356: PPUSH
53357: CALL_OW 1
53361: ST_TO_ADDR
// tmp := tmp diff p ;
53362: LD_ADDR_VAR 0 4
53366: PUSH
53367: LD_VAR 0 4
53371: PUSH
53372: LD_VAR 0 11
53376: DIFF
53377: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53378: LD_VAR 0 4
53382: PUSH
53383: LD_VAR 0 8
53387: PUSH
53388: LD_INT 6
53390: LESS
53391: AND
53392: IFFALSE 53580
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53394: LD_ADDR_VAR 0 9
53398: PUSH
53399: LD_VAR 0 4
53403: PUSH
53404: LD_VAR 0 8
53408: PUSH
53409: LD_VAR 0 7
53413: UNION
53414: DIFF
53415: PPUSH
53416: LD_INT 4
53418: PPUSH
53419: CALL 44358 0 2
53423: ST_TO_ADDR
// p := [ ] ;
53424: LD_ADDR_VAR 0 11
53428: PUSH
53429: EMPTY
53430: ST_TO_ADDR
// if sort then
53431: LD_VAR 0 9
53435: IFFALSE 53551
// for i = 1 to 6 - sci do
53437: LD_ADDR_VAR 0 3
53441: PUSH
53442: DOUBLE
53443: LD_INT 1
53445: DEC
53446: ST_TO_ADDR
53447: LD_INT 6
53449: PUSH
53450: LD_VAR 0 8
53454: MINUS
53455: PUSH
53456: FOR_TO
53457: IFFALSE 53549
// begin if i = sort then
53459: LD_VAR 0 3
53463: PUSH
53464: LD_VAR 0 9
53468: EQUAL
53469: IFFALSE 53473
// break ;
53471: GO 53549
// if GetClass ( i ) = 4 then
53473: LD_VAR 0 3
53477: PPUSH
53478: CALL_OW 257
53482: PUSH
53483: LD_INT 4
53485: EQUAL
53486: IFFALSE 53490
// continue ;
53488: GO 53456
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53490: LD_ADDR_VAR 0 11
53494: PUSH
53495: LD_VAR 0 11
53499: PPUSH
53500: LD_VAR 0 11
53504: PUSH
53505: LD_INT 1
53507: PLUS
53508: PPUSH
53509: LD_VAR 0 9
53513: PUSH
53514: LD_VAR 0 3
53518: ARRAY
53519: PPUSH
53520: CALL_OW 2
53524: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53525: LD_ADDR_VAR 0 4
53529: PUSH
53530: LD_VAR 0 4
53534: PUSH
53535: LD_VAR 0 9
53539: PUSH
53540: LD_VAR 0 3
53544: ARRAY
53545: DIFF
53546: ST_TO_ADDR
// end ;
53547: GO 53456
53549: POP
53550: POP
// if p then
53551: LD_VAR 0 11
53555: IFFALSE 53580
// result := Replace ( result , 4 , p ) ;
53557: LD_ADDR_VAR 0 2
53561: PUSH
53562: LD_VAR 0 2
53566: PPUSH
53567: LD_INT 4
53569: PPUSH
53570: LD_VAR 0 11
53574: PPUSH
53575: CALL_OW 1
53579: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53580: LD_VAR 0 4
53584: PUSH
53585: LD_VAR 0 7
53589: PUSH
53590: LD_INT 6
53592: LESS
53593: AND
53594: IFFALSE 53782
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53596: LD_ADDR_VAR 0 9
53600: PUSH
53601: LD_VAR 0 4
53605: PUSH
53606: LD_VAR 0 8
53610: PUSH
53611: LD_VAR 0 7
53615: UNION
53616: DIFF
53617: PPUSH
53618: LD_INT 3
53620: PPUSH
53621: CALL 44358 0 2
53625: ST_TO_ADDR
// p := [ ] ;
53626: LD_ADDR_VAR 0 11
53630: PUSH
53631: EMPTY
53632: ST_TO_ADDR
// if sort then
53633: LD_VAR 0 9
53637: IFFALSE 53753
// for i = 1 to 6 - mech do
53639: LD_ADDR_VAR 0 3
53643: PUSH
53644: DOUBLE
53645: LD_INT 1
53647: DEC
53648: ST_TO_ADDR
53649: LD_INT 6
53651: PUSH
53652: LD_VAR 0 7
53656: MINUS
53657: PUSH
53658: FOR_TO
53659: IFFALSE 53751
// begin if i = sort then
53661: LD_VAR 0 3
53665: PUSH
53666: LD_VAR 0 9
53670: EQUAL
53671: IFFALSE 53675
// break ;
53673: GO 53751
// if GetClass ( i ) = 3 then
53675: LD_VAR 0 3
53679: PPUSH
53680: CALL_OW 257
53684: PUSH
53685: LD_INT 3
53687: EQUAL
53688: IFFALSE 53692
// continue ;
53690: GO 53658
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53692: LD_ADDR_VAR 0 11
53696: PUSH
53697: LD_VAR 0 11
53701: PPUSH
53702: LD_VAR 0 11
53706: PUSH
53707: LD_INT 1
53709: PLUS
53710: PPUSH
53711: LD_VAR 0 9
53715: PUSH
53716: LD_VAR 0 3
53720: ARRAY
53721: PPUSH
53722: CALL_OW 2
53726: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53727: LD_ADDR_VAR 0 4
53731: PUSH
53732: LD_VAR 0 4
53736: PUSH
53737: LD_VAR 0 9
53741: PUSH
53742: LD_VAR 0 3
53746: ARRAY
53747: DIFF
53748: ST_TO_ADDR
// end ;
53749: GO 53658
53751: POP
53752: POP
// if p then
53753: LD_VAR 0 11
53757: IFFALSE 53782
// result := Replace ( result , 3 , p ) ;
53759: LD_ADDR_VAR 0 2
53763: PUSH
53764: LD_VAR 0 2
53768: PPUSH
53769: LD_INT 3
53771: PPUSH
53772: LD_VAR 0 11
53776: PPUSH
53777: CALL_OW 1
53781: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53782: LD_VAR 0 4
53786: PUSH
53787: LD_INT 6
53789: GREATER
53790: PUSH
53791: LD_VAR 0 6
53795: PUSH
53796: LD_INT 6
53798: LESS
53799: AND
53800: IFFALSE 53994
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53802: LD_ADDR_VAR 0 9
53806: PUSH
53807: LD_VAR 0 4
53811: PUSH
53812: LD_VAR 0 8
53816: PUSH
53817: LD_VAR 0 7
53821: UNION
53822: PUSH
53823: LD_VAR 0 6
53827: UNION
53828: DIFF
53829: PPUSH
53830: LD_INT 2
53832: PPUSH
53833: CALL 44358 0 2
53837: ST_TO_ADDR
// p := [ ] ;
53838: LD_ADDR_VAR 0 11
53842: PUSH
53843: EMPTY
53844: ST_TO_ADDR
// if sort then
53845: LD_VAR 0 9
53849: IFFALSE 53965
// for i = 1 to 6 - eng do
53851: LD_ADDR_VAR 0 3
53855: PUSH
53856: DOUBLE
53857: LD_INT 1
53859: DEC
53860: ST_TO_ADDR
53861: LD_INT 6
53863: PUSH
53864: LD_VAR 0 6
53868: MINUS
53869: PUSH
53870: FOR_TO
53871: IFFALSE 53963
// begin if i = sort then
53873: LD_VAR 0 3
53877: PUSH
53878: LD_VAR 0 9
53882: EQUAL
53883: IFFALSE 53887
// break ;
53885: GO 53963
// if GetClass ( i ) = 2 then
53887: LD_VAR 0 3
53891: PPUSH
53892: CALL_OW 257
53896: PUSH
53897: LD_INT 2
53899: EQUAL
53900: IFFALSE 53904
// continue ;
53902: GO 53870
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53904: LD_ADDR_VAR 0 11
53908: PUSH
53909: LD_VAR 0 11
53913: PPUSH
53914: LD_VAR 0 11
53918: PUSH
53919: LD_INT 1
53921: PLUS
53922: PPUSH
53923: LD_VAR 0 9
53927: PUSH
53928: LD_VAR 0 3
53932: ARRAY
53933: PPUSH
53934: CALL_OW 2
53938: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53939: LD_ADDR_VAR 0 4
53943: PUSH
53944: LD_VAR 0 4
53948: PUSH
53949: LD_VAR 0 9
53953: PUSH
53954: LD_VAR 0 3
53958: ARRAY
53959: DIFF
53960: ST_TO_ADDR
// end ;
53961: GO 53870
53963: POP
53964: POP
// if p then
53965: LD_VAR 0 11
53969: IFFALSE 53994
// result := Replace ( result , 2 , p ) ;
53971: LD_ADDR_VAR 0 2
53975: PUSH
53976: LD_VAR 0 2
53980: PPUSH
53981: LD_INT 2
53983: PPUSH
53984: LD_VAR 0 11
53988: PPUSH
53989: CALL_OW 1
53993: ST_TO_ADDR
// end ; exit ;
53994: GO 55382
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
53996: LD_EXP 70
54000: PUSH
54001: LD_EXP 69
54005: PUSH
54006: LD_VAR 0 1
54010: ARRAY
54011: ARRAY
54012: NOT
54013: PUSH
54014: LD_EXP 43
54018: PUSH
54019: LD_VAR 0 1
54023: ARRAY
54024: PPUSH
54025: LD_INT 30
54027: PUSH
54028: LD_INT 3
54030: PUSH
54031: EMPTY
54032: LIST
54033: LIST
54034: PPUSH
54035: CALL_OW 72
54039: AND
54040: PUSH
54041: LD_EXP 48
54045: PUSH
54046: LD_VAR 0 1
54050: ARRAY
54051: AND
54052: IFFALSE 54660
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
54054: LD_ADDR_EXP 85
54058: PUSH
54059: LD_EXP 85
54063: PPUSH
54064: LD_VAR 0 1
54068: PPUSH
54069: LD_INT 5
54071: PPUSH
54072: CALL_OW 1
54076: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54077: LD_ADDR_VAR 0 2
54081: PUSH
54082: LD_INT 0
54084: PUSH
54085: LD_INT 0
54087: PUSH
54088: LD_INT 0
54090: PUSH
54091: LD_INT 0
54093: PUSH
54094: EMPTY
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: ST_TO_ADDR
// if sci > 1 then
54100: LD_VAR 0 8
54104: PUSH
54105: LD_INT 1
54107: GREATER
54108: IFFALSE 54136
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54110: LD_ADDR_VAR 0 4
54114: PUSH
54115: LD_VAR 0 4
54119: PUSH
54120: LD_VAR 0 8
54124: PUSH
54125: LD_VAR 0 8
54129: PUSH
54130: LD_INT 1
54132: ARRAY
54133: DIFF
54134: DIFF
54135: ST_TO_ADDR
// if tmp and not sci then
54136: LD_VAR 0 4
54140: PUSH
54141: LD_VAR 0 8
54145: NOT
54146: AND
54147: IFFALSE 54216
// begin sort := SortBySkill ( tmp , 4 ) ;
54149: LD_ADDR_VAR 0 9
54153: PUSH
54154: LD_VAR 0 4
54158: PPUSH
54159: LD_INT 4
54161: PPUSH
54162: CALL 44358 0 2
54166: ST_TO_ADDR
// if sort then
54167: LD_VAR 0 9
54171: IFFALSE 54187
// p := sort [ 1 ] ;
54173: LD_ADDR_VAR 0 11
54177: PUSH
54178: LD_VAR 0 9
54182: PUSH
54183: LD_INT 1
54185: ARRAY
54186: ST_TO_ADDR
// if p then
54187: LD_VAR 0 11
54191: IFFALSE 54216
// result := Replace ( result , 4 , p ) ;
54193: LD_ADDR_VAR 0 2
54197: PUSH
54198: LD_VAR 0 2
54202: PPUSH
54203: LD_INT 4
54205: PPUSH
54206: LD_VAR 0 11
54210: PPUSH
54211: CALL_OW 1
54215: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54216: LD_ADDR_VAR 0 4
54220: PUSH
54221: LD_VAR 0 4
54225: PUSH
54226: LD_VAR 0 7
54230: DIFF
54231: ST_TO_ADDR
// if tmp and mech < 6 then
54232: LD_VAR 0 4
54236: PUSH
54237: LD_VAR 0 7
54241: PUSH
54242: LD_INT 6
54244: LESS
54245: AND
54246: IFFALSE 54434
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54248: LD_ADDR_VAR 0 9
54252: PUSH
54253: LD_VAR 0 4
54257: PUSH
54258: LD_VAR 0 8
54262: PUSH
54263: LD_VAR 0 7
54267: UNION
54268: DIFF
54269: PPUSH
54270: LD_INT 3
54272: PPUSH
54273: CALL 44358 0 2
54277: ST_TO_ADDR
// p := [ ] ;
54278: LD_ADDR_VAR 0 11
54282: PUSH
54283: EMPTY
54284: ST_TO_ADDR
// if sort then
54285: LD_VAR 0 9
54289: IFFALSE 54405
// for i = 1 to 6 - mech do
54291: LD_ADDR_VAR 0 3
54295: PUSH
54296: DOUBLE
54297: LD_INT 1
54299: DEC
54300: ST_TO_ADDR
54301: LD_INT 6
54303: PUSH
54304: LD_VAR 0 7
54308: MINUS
54309: PUSH
54310: FOR_TO
54311: IFFALSE 54403
// begin if i = sort then
54313: LD_VAR 0 3
54317: PUSH
54318: LD_VAR 0 9
54322: EQUAL
54323: IFFALSE 54327
// break ;
54325: GO 54403
// if GetClass ( i ) = 3 then
54327: LD_VAR 0 3
54331: PPUSH
54332: CALL_OW 257
54336: PUSH
54337: LD_INT 3
54339: EQUAL
54340: IFFALSE 54344
// continue ;
54342: GO 54310
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54344: LD_ADDR_VAR 0 11
54348: PUSH
54349: LD_VAR 0 11
54353: PPUSH
54354: LD_VAR 0 11
54358: PUSH
54359: LD_INT 1
54361: PLUS
54362: PPUSH
54363: LD_VAR 0 9
54367: PUSH
54368: LD_VAR 0 3
54372: ARRAY
54373: PPUSH
54374: CALL_OW 2
54378: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54379: LD_ADDR_VAR 0 4
54383: PUSH
54384: LD_VAR 0 4
54388: PUSH
54389: LD_VAR 0 9
54393: PUSH
54394: LD_VAR 0 3
54398: ARRAY
54399: DIFF
54400: ST_TO_ADDR
// end ;
54401: GO 54310
54403: POP
54404: POP
// if p then
54405: LD_VAR 0 11
54409: IFFALSE 54434
// result := Replace ( result , 3 , p ) ;
54411: LD_ADDR_VAR 0 2
54415: PUSH
54416: LD_VAR 0 2
54420: PPUSH
54421: LD_INT 3
54423: PPUSH
54424: LD_VAR 0 11
54428: PPUSH
54429: CALL_OW 1
54433: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54434: LD_ADDR_VAR 0 4
54438: PUSH
54439: LD_VAR 0 4
54443: PUSH
54444: LD_VAR 0 6
54448: DIFF
54449: ST_TO_ADDR
// if tmp and eng < 6 then
54450: LD_VAR 0 4
54454: PUSH
54455: LD_VAR 0 6
54459: PUSH
54460: LD_INT 6
54462: LESS
54463: AND
54464: IFFALSE 54658
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54466: LD_ADDR_VAR 0 9
54470: PUSH
54471: LD_VAR 0 4
54475: PUSH
54476: LD_VAR 0 8
54480: PUSH
54481: LD_VAR 0 7
54485: UNION
54486: PUSH
54487: LD_VAR 0 6
54491: UNION
54492: DIFF
54493: PPUSH
54494: LD_INT 2
54496: PPUSH
54497: CALL 44358 0 2
54501: ST_TO_ADDR
// p := [ ] ;
54502: LD_ADDR_VAR 0 11
54506: PUSH
54507: EMPTY
54508: ST_TO_ADDR
// if sort then
54509: LD_VAR 0 9
54513: IFFALSE 54629
// for i = 1 to 6 - eng do
54515: LD_ADDR_VAR 0 3
54519: PUSH
54520: DOUBLE
54521: LD_INT 1
54523: DEC
54524: ST_TO_ADDR
54525: LD_INT 6
54527: PUSH
54528: LD_VAR 0 6
54532: MINUS
54533: PUSH
54534: FOR_TO
54535: IFFALSE 54627
// begin if i = sort then
54537: LD_VAR 0 3
54541: PUSH
54542: LD_VAR 0 9
54546: EQUAL
54547: IFFALSE 54551
// break ;
54549: GO 54627
// if GetClass ( i ) = 2 then
54551: LD_VAR 0 3
54555: PPUSH
54556: CALL_OW 257
54560: PUSH
54561: LD_INT 2
54563: EQUAL
54564: IFFALSE 54568
// continue ;
54566: GO 54534
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54568: LD_ADDR_VAR 0 11
54572: PUSH
54573: LD_VAR 0 11
54577: PPUSH
54578: LD_VAR 0 11
54582: PUSH
54583: LD_INT 1
54585: PLUS
54586: PPUSH
54587: LD_VAR 0 9
54591: PUSH
54592: LD_VAR 0 3
54596: ARRAY
54597: PPUSH
54598: CALL_OW 2
54602: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54603: LD_ADDR_VAR 0 4
54607: PUSH
54608: LD_VAR 0 4
54612: PUSH
54613: LD_VAR 0 9
54617: PUSH
54618: LD_VAR 0 3
54622: ARRAY
54623: DIFF
54624: ST_TO_ADDR
// end ;
54625: GO 54534
54627: POP
54628: POP
// if p then
54629: LD_VAR 0 11
54633: IFFALSE 54658
// result := Replace ( result , 2 , p ) ;
54635: LD_ADDR_VAR 0 2
54639: PUSH
54640: LD_VAR 0 2
54644: PPUSH
54645: LD_INT 2
54647: PPUSH
54648: LD_VAR 0 11
54652: PPUSH
54653: CALL_OW 1
54657: ST_TO_ADDR
// end ; exit ;
54658: GO 55382
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54660: LD_EXP 70
54664: PUSH
54665: LD_EXP 69
54669: PUSH
54670: LD_VAR 0 1
54674: ARRAY
54675: ARRAY
54676: NOT
54677: PUSH
54678: LD_EXP 43
54682: PUSH
54683: LD_VAR 0 1
54687: ARRAY
54688: PPUSH
54689: LD_INT 30
54691: PUSH
54692: LD_INT 3
54694: PUSH
54695: EMPTY
54696: LIST
54697: LIST
54698: PPUSH
54699: CALL_OW 72
54703: AND
54704: PUSH
54705: LD_EXP 48
54709: PUSH
54710: LD_VAR 0 1
54714: ARRAY
54715: NOT
54716: AND
54717: IFFALSE 55382
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54719: LD_ADDR_EXP 85
54723: PUSH
54724: LD_EXP 85
54728: PPUSH
54729: LD_VAR 0 1
54733: PPUSH
54734: LD_INT 6
54736: PPUSH
54737: CALL_OW 1
54741: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54742: LD_ADDR_VAR 0 2
54746: PUSH
54747: LD_INT 0
54749: PUSH
54750: LD_INT 0
54752: PUSH
54753: LD_INT 0
54755: PUSH
54756: LD_INT 0
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: LIST
54764: ST_TO_ADDR
// if sci >= 1 then
54765: LD_VAR 0 8
54769: PUSH
54770: LD_INT 1
54772: GREATEREQUAL
54773: IFFALSE 54795
// tmp := tmp diff sci [ 1 ] ;
54775: LD_ADDR_VAR 0 4
54779: PUSH
54780: LD_VAR 0 4
54784: PUSH
54785: LD_VAR 0 8
54789: PUSH
54790: LD_INT 1
54792: ARRAY
54793: DIFF
54794: ST_TO_ADDR
// if tmp and not sci then
54795: LD_VAR 0 4
54799: PUSH
54800: LD_VAR 0 8
54804: NOT
54805: AND
54806: IFFALSE 54875
// begin sort := SortBySkill ( tmp , 4 ) ;
54808: LD_ADDR_VAR 0 9
54812: PUSH
54813: LD_VAR 0 4
54817: PPUSH
54818: LD_INT 4
54820: PPUSH
54821: CALL 44358 0 2
54825: ST_TO_ADDR
// if sort then
54826: LD_VAR 0 9
54830: IFFALSE 54846
// p := sort [ 1 ] ;
54832: LD_ADDR_VAR 0 11
54836: PUSH
54837: LD_VAR 0 9
54841: PUSH
54842: LD_INT 1
54844: ARRAY
54845: ST_TO_ADDR
// if p then
54846: LD_VAR 0 11
54850: IFFALSE 54875
// result := Replace ( result , 4 , p ) ;
54852: LD_ADDR_VAR 0 2
54856: PUSH
54857: LD_VAR 0 2
54861: PPUSH
54862: LD_INT 4
54864: PPUSH
54865: LD_VAR 0 11
54869: PPUSH
54870: CALL_OW 1
54874: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54875: LD_ADDR_VAR 0 4
54879: PUSH
54880: LD_VAR 0 4
54884: PUSH
54885: LD_VAR 0 7
54889: DIFF
54890: ST_TO_ADDR
// if tmp and mech < 6 then
54891: LD_VAR 0 4
54895: PUSH
54896: LD_VAR 0 7
54900: PUSH
54901: LD_INT 6
54903: LESS
54904: AND
54905: IFFALSE 55087
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54907: LD_ADDR_VAR 0 9
54911: PUSH
54912: LD_VAR 0 4
54916: PUSH
54917: LD_VAR 0 7
54921: DIFF
54922: PPUSH
54923: LD_INT 3
54925: PPUSH
54926: CALL 44358 0 2
54930: ST_TO_ADDR
// p := [ ] ;
54931: LD_ADDR_VAR 0 11
54935: PUSH
54936: EMPTY
54937: ST_TO_ADDR
// if sort then
54938: LD_VAR 0 9
54942: IFFALSE 55058
// for i = 1 to 6 - mech do
54944: LD_ADDR_VAR 0 3
54948: PUSH
54949: DOUBLE
54950: LD_INT 1
54952: DEC
54953: ST_TO_ADDR
54954: LD_INT 6
54956: PUSH
54957: LD_VAR 0 7
54961: MINUS
54962: PUSH
54963: FOR_TO
54964: IFFALSE 55056
// begin if i = sort then
54966: LD_VAR 0 3
54970: PUSH
54971: LD_VAR 0 9
54975: EQUAL
54976: IFFALSE 54980
// break ;
54978: GO 55056
// if GetClass ( i ) = 3 then
54980: LD_VAR 0 3
54984: PPUSH
54985: CALL_OW 257
54989: PUSH
54990: LD_INT 3
54992: EQUAL
54993: IFFALSE 54997
// continue ;
54995: GO 54963
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54997: LD_ADDR_VAR 0 11
55001: PUSH
55002: LD_VAR 0 11
55006: PPUSH
55007: LD_VAR 0 11
55011: PUSH
55012: LD_INT 1
55014: PLUS
55015: PPUSH
55016: LD_VAR 0 9
55020: PUSH
55021: LD_VAR 0 3
55025: ARRAY
55026: PPUSH
55027: CALL_OW 2
55031: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55032: LD_ADDR_VAR 0 4
55036: PUSH
55037: LD_VAR 0 4
55041: PUSH
55042: LD_VAR 0 9
55046: PUSH
55047: LD_VAR 0 3
55051: ARRAY
55052: DIFF
55053: ST_TO_ADDR
// end ;
55054: GO 54963
55056: POP
55057: POP
// if p then
55058: LD_VAR 0 11
55062: IFFALSE 55087
// result := Replace ( result , 3 , p ) ;
55064: LD_ADDR_VAR 0 2
55068: PUSH
55069: LD_VAR 0 2
55073: PPUSH
55074: LD_INT 3
55076: PPUSH
55077: LD_VAR 0 11
55081: PPUSH
55082: CALL_OW 1
55086: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55087: LD_ADDR_VAR 0 4
55091: PUSH
55092: LD_VAR 0 4
55096: PUSH
55097: LD_VAR 0 6
55101: DIFF
55102: ST_TO_ADDR
// if tmp and eng < 4 then
55103: LD_VAR 0 4
55107: PUSH
55108: LD_VAR 0 6
55112: PUSH
55113: LD_INT 4
55115: LESS
55116: AND
55117: IFFALSE 55307
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55119: LD_ADDR_VAR 0 9
55123: PUSH
55124: LD_VAR 0 4
55128: PUSH
55129: LD_VAR 0 7
55133: PUSH
55134: LD_VAR 0 6
55138: UNION
55139: DIFF
55140: PPUSH
55141: LD_INT 2
55143: PPUSH
55144: CALL 44358 0 2
55148: ST_TO_ADDR
// p := [ ] ;
55149: LD_ADDR_VAR 0 11
55153: PUSH
55154: EMPTY
55155: ST_TO_ADDR
// if sort then
55156: LD_VAR 0 9
55160: IFFALSE 55276
// for i = 1 to 4 - eng do
55162: LD_ADDR_VAR 0 3
55166: PUSH
55167: DOUBLE
55168: LD_INT 1
55170: DEC
55171: ST_TO_ADDR
55172: LD_INT 4
55174: PUSH
55175: LD_VAR 0 6
55179: MINUS
55180: PUSH
55181: FOR_TO
55182: IFFALSE 55274
// begin if i = sort then
55184: LD_VAR 0 3
55188: PUSH
55189: LD_VAR 0 9
55193: EQUAL
55194: IFFALSE 55198
// break ;
55196: GO 55274
// if GetClass ( i ) = 2 then
55198: LD_VAR 0 3
55202: PPUSH
55203: CALL_OW 257
55207: PUSH
55208: LD_INT 2
55210: EQUAL
55211: IFFALSE 55215
// continue ;
55213: GO 55181
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55215: LD_ADDR_VAR 0 11
55219: PUSH
55220: LD_VAR 0 11
55224: PPUSH
55225: LD_VAR 0 11
55229: PUSH
55230: LD_INT 1
55232: PLUS
55233: PPUSH
55234: LD_VAR 0 9
55238: PUSH
55239: LD_VAR 0 3
55243: ARRAY
55244: PPUSH
55245: CALL_OW 2
55249: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55250: LD_ADDR_VAR 0 4
55254: PUSH
55255: LD_VAR 0 4
55259: PUSH
55260: LD_VAR 0 9
55264: PUSH
55265: LD_VAR 0 3
55269: ARRAY
55270: DIFF
55271: ST_TO_ADDR
// end ;
55272: GO 55181
55274: POP
55275: POP
// if p then
55276: LD_VAR 0 11
55280: IFFALSE 55305
// result := Replace ( result , 2 , p ) ;
55282: LD_ADDR_VAR 0 2
55286: PUSH
55287: LD_VAR 0 2
55291: PPUSH
55292: LD_INT 2
55294: PPUSH
55295: LD_VAR 0 11
55299: PPUSH
55300: CALL_OW 1
55304: ST_TO_ADDR
// end else
55305: GO 55351
// for i = eng downto 5 do
55307: LD_ADDR_VAR 0 3
55311: PUSH
55312: DOUBLE
55313: LD_VAR 0 6
55317: INC
55318: ST_TO_ADDR
55319: LD_INT 5
55321: PUSH
55322: FOR_DOWNTO
55323: IFFALSE 55349
// tmp := tmp union eng [ i ] ;
55325: LD_ADDR_VAR 0 4
55329: PUSH
55330: LD_VAR 0 4
55334: PUSH
55335: LD_VAR 0 6
55339: PUSH
55340: LD_VAR 0 3
55344: ARRAY
55345: UNION
55346: ST_TO_ADDR
55347: GO 55322
55349: POP
55350: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55351: LD_ADDR_VAR 0 2
55355: PUSH
55356: LD_VAR 0 2
55360: PPUSH
55361: LD_INT 1
55363: PPUSH
55364: LD_VAR 0 4
55368: PUSH
55369: LD_VAR 0 5
55373: DIFF
55374: PPUSH
55375: CALL_OW 1
55379: ST_TO_ADDR
// exit ;
55380: GO 55382
// end ; end ;
55382: LD_VAR 0 2
55386: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55387: LD_INT 0
55389: PPUSH
55390: PPUSH
55391: PPUSH
// if not mc_bases then
55392: LD_EXP 43
55396: NOT
55397: IFFALSE 55401
// exit ;
55399: GO 55507
// for i = 1 to mc_bases do
55401: LD_ADDR_VAR 0 2
55405: PUSH
55406: DOUBLE
55407: LD_INT 1
55409: DEC
55410: ST_TO_ADDR
55411: LD_EXP 43
55415: PUSH
55416: FOR_TO
55417: IFFALSE 55498
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55419: LD_ADDR_VAR 0 3
55423: PUSH
55424: LD_EXP 43
55428: PUSH
55429: LD_VAR 0 2
55433: ARRAY
55434: PPUSH
55435: LD_INT 21
55437: PUSH
55438: LD_INT 3
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: PUSH
55445: LD_INT 3
55447: PUSH
55448: LD_INT 24
55450: PUSH
55451: LD_INT 1000
55453: PUSH
55454: EMPTY
55455: LIST
55456: LIST
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: PPUSH
55466: CALL_OW 72
55470: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55471: LD_ADDR_EXP 44
55475: PUSH
55476: LD_EXP 44
55480: PPUSH
55481: LD_VAR 0 2
55485: PPUSH
55486: LD_VAR 0 3
55490: PPUSH
55491: CALL_OW 1
55495: ST_TO_ADDR
// end ;
55496: GO 55416
55498: POP
55499: POP
// RaiseSailEvent ( 101 ) ;
55500: LD_INT 101
55502: PPUSH
55503: CALL_OW 427
// end ;
55507: LD_VAR 0 1
55511: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55512: LD_INT 0
55514: PPUSH
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
55519: PPUSH
55520: PPUSH
// if not mc_bases then
55521: LD_EXP 43
55525: NOT
55526: IFFALSE 55530
// exit ;
55528: GO 56092
// for i = 1 to mc_bases do
55530: LD_ADDR_VAR 0 2
55534: PUSH
55535: DOUBLE
55536: LD_INT 1
55538: DEC
55539: ST_TO_ADDR
55540: LD_EXP 43
55544: PUSH
55545: FOR_TO
55546: IFFALSE 56083
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
55548: LD_ADDR_VAR 0 5
55552: PUSH
55553: LD_EXP 43
55557: PUSH
55558: LD_VAR 0 2
55562: ARRAY
55563: PUSH
55564: LD_EXP 72
55568: PUSH
55569: LD_VAR 0 2
55573: ARRAY
55574: UNION
55575: PPUSH
55576: LD_INT 21
55578: PUSH
55579: LD_INT 1
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PUSH
55586: LD_INT 1
55588: PUSH
55589: LD_INT 3
55591: PUSH
55592: LD_INT 54
55594: PUSH
55595: EMPTY
55596: LIST
55597: PUSH
55598: EMPTY
55599: LIST
55600: LIST
55601: PUSH
55602: LD_INT 3
55604: PUSH
55605: LD_INT 24
55607: PUSH
55608: LD_INT 1000
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: LIST
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: PPUSH
55628: CALL_OW 72
55632: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55633: LD_ADDR_VAR 0 6
55637: PUSH
55638: LD_EXP 43
55642: PUSH
55643: LD_VAR 0 2
55647: ARRAY
55648: PPUSH
55649: LD_INT 21
55651: PUSH
55652: LD_INT 1
55654: PUSH
55655: EMPTY
55656: LIST
55657: LIST
55658: PUSH
55659: LD_INT 1
55661: PUSH
55662: LD_INT 3
55664: PUSH
55665: LD_INT 54
55667: PUSH
55668: EMPTY
55669: LIST
55670: PUSH
55671: EMPTY
55672: LIST
55673: LIST
55674: PUSH
55675: LD_INT 3
55677: PUSH
55678: LD_INT 24
55680: PUSH
55681: LD_INT 250
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: PPUSH
55701: CALL_OW 72
55705: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55706: LD_ADDR_VAR 0 7
55710: PUSH
55711: LD_VAR 0 5
55715: PUSH
55716: LD_VAR 0 6
55720: DIFF
55721: ST_TO_ADDR
// if not need_heal_1 then
55722: LD_VAR 0 6
55726: NOT
55727: IFFALSE 55760
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55729: LD_ADDR_EXP 46
55733: PUSH
55734: LD_EXP 46
55738: PPUSH
55739: LD_VAR 0 2
55743: PUSH
55744: LD_INT 1
55746: PUSH
55747: EMPTY
55748: LIST
55749: LIST
55750: PPUSH
55751: EMPTY
55752: PPUSH
55753: CALL 14797 0 3
55757: ST_TO_ADDR
55758: GO 55830
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55760: LD_ADDR_EXP 46
55764: PUSH
55765: LD_EXP 46
55769: PPUSH
55770: LD_VAR 0 2
55774: PUSH
55775: LD_INT 1
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: PPUSH
55782: LD_EXP 46
55786: PUSH
55787: LD_VAR 0 2
55791: ARRAY
55792: PUSH
55793: LD_INT 1
55795: ARRAY
55796: PPUSH
55797: LD_INT 3
55799: PUSH
55800: LD_INT 24
55802: PUSH
55803: LD_INT 1000
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PPUSH
55814: CALL_OW 72
55818: PUSH
55819: LD_VAR 0 6
55823: UNION
55824: PPUSH
55825: CALL 14797 0 3
55829: ST_TO_ADDR
// if not need_heal_2 then
55830: LD_VAR 0 7
55834: NOT
55835: IFFALSE 55868
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55837: LD_ADDR_EXP 46
55841: PUSH
55842: LD_EXP 46
55846: PPUSH
55847: LD_VAR 0 2
55851: PUSH
55852: LD_INT 2
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: PPUSH
55859: EMPTY
55860: PPUSH
55861: CALL 14797 0 3
55865: ST_TO_ADDR
55866: GO 55900
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55868: LD_ADDR_EXP 46
55872: PUSH
55873: LD_EXP 46
55877: PPUSH
55878: LD_VAR 0 2
55882: PUSH
55883: LD_INT 2
55885: PUSH
55886: EMPTY
55887: LIST
55888: LIST
55889: PPUSH
55890: LD_VAR 0 7
55894: PPUSH
55895: CALL 14797 0 3
55899: ST_TO_ADDR
// if need_heal_2 then
55900: LD_VAR 0 7
55904: IFFALSE 56065
// for j in need_heal_2 do
55906: LD_ADDR_VAR 0 3
55910: PUSH
55911: LD_VAR 0 7
55915: PUSH
55916: FOR_IN
55917: IFFALSE 56063
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55919: LD_ADDR_VAR 0 5
55923: PUSH
55924: LD_EXP 43
55928: PUSH
55929: LD_VAR 0 2
55933: ARRAY
55934: PPUSH
55935: LD_INT 2
55937: PUSH
55938: LD_INT 30
55940: PUSH
55941: LD_INT 6
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: PUSH
55948: LD_INT 30
55950: PUSH
55951: LD_INT 7
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PUSH
55958: LD_INT 30
55960: PUSH
55961: LD_INT 8
55963: PUSH
55964: EMPTY
55965: LIST
55966: LIST
55967: PUSH
55968: LD_INT 30
55970: PUSH
55971: LD_INT 0
55973: PUSH
55974: EMPTY
55975: LIST
55976: LIST
55977: PUSH
55978: LD_INT 30
55980: PUSH
55981: LD_INT 1
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: LIST
55992: LIST
55993: LIST
55994: LIST
55995: PPUSH
55996: CALL_OW 72
56000: ST_TO_ADDR
// if tmp then
56001: LD_VAR 0 5
56005: IFFALSE 56061
// begin k := NearestUnitToUnit ( tmp , j ) ;
56007: LD_ADDR_VAR 0 4
56011: PUSH
56012: LD_VAR 0 5
56016: PPUSH
56017: LD_VAR 0 3
56021: PPUSH
56022: CALL_OW 74
56026: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
56027: LD_VAR 0 3
56031: PPUSH
56032: LD_VAR 0 4
56036: PPUSH
56037: CALL_OW 296
56041: PUSH
56042: LD_INT 5
56044: GREATER
56045: IFFALSE 56061
// ComMoveToNearbyEntrance ( j , k ) ;
56047: LD_VAR 0 3
56051: PPUSH
56052: LD_VAR 0 4
56056: PPUSH
56057: CALL 46675 0 2
// end ; end ;
56061: GO 55916
56063: POP
56064: POP
// if not need_heal_1 and not need_heal_2 then
56065: LD_VAR 0 6
56069: NOT
56070: PUSH
56071: LD_VAR 0 7
56075: NOT
56076: AND
56077: IFFALSE 56081
// continue ;
56079: GO 55545
// end ;
56081: GO 55545
56083: POP
56084: POP
// RaiseSailEvent ( 102 ) ;
56085: LD_INT 102
56087: PPUSH
56088: CALL_OW 427
// end ;
56092: LD_VAR 0 1
56096: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56097: LD_INT 0
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
56103: PPUSH
56104: PPUSH
56105: PPUSH
56106: PPUSH
// if not mc_bases then
56107: LD_EXP 43
56111: NOT
56112: IFFALSE 56116
// exit ;
56114: GO 56977
// for i = 1 to mc_bases do
56116: LD_ADDR_VAR 0 2
56120: PUSH
56121: DOUBLE
56122: LD_INT 1
56124: DEC
56125: ST_TO_ADDR
56126: LD_EXP 43
56130: PUSH
56131: FOR_TO
56132: IFFALSE 56975
// begin if not mc_building_need_repair [ i ] then
56134: LD_EXP 44
56138: PUSH
56139: LD_VAR 0 2
56143: ARRAY
56144: NOT
56145: IFFALSE 56332
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56147: LD_ADDR_VAR 0 6
56151: PUSH
56152: LD_EXP 62
56156: PUSH
56157: LD_VAR 0 2
56161: ARRAY
56162: PPUSH
56163: LD_INT 3
56165: PUSH
56166: LD_INT 24
56168: PUSH
56169: LD_INT 1000
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: PUSH
56180: LD_INT 2
56182: PUSH
56183: LD_INT 34
56185: PUSH
56186: LD_INT 13
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: PUSH
56193: LD_INT 34
56195: PUSH
56196: LD_INT 52
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: PUSH
56203: LD_INT 34
56205: PUSH
56206: LD_EXP 92
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: LIST
56219: LIST
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: PPUSH
56225: CALL_OW 72
56229: ST_TO_ADDR
// if cranes then
56230: LD_VAR 0 6
56234: IFFALSE 56296
// for j in cranes do
56236: LD_ADDR_VAR 0 3
56240: PUSH
56241: LD_VAR 0 6
56245: PUSH
56246: FOR_IN
56247: IFFALSE 56294
// if not IsInArea ( j , mc_parking [ i ] ) then
56249: LD_VAR 0 3
56253: PPUSH
56254: LD_EXP 67
56258: PUSH
56259: LD_VAR 0 2
56263: ARRAY
56264: PPUSH
56265: CALL_OW 308
56269: NOT
56270: IFFALSE 56292
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56272: LD_VAR 0 3
56276: PPUSH
56277: LD_EXP 67
56281: PUSH
56282: LD_VAR 0 2
56286: ARRAY
56287: PPUSH
56288: CALL_OW 113
56292: GO 56246
56294: POP
56295: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56296: LD_ADDR_EXP 45
56300: PUSH
56301: LD_EXP 45
56305: PPUSH
56306: LD_VAR 0 2
56310: PPUSH
56311: EMPTY
56312: PPUSH
56313: CALL_OW 1
56317: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56318: LD_VAR 0 2
56322: PPUSH
56323: LD_INT 101
56325: PPUSH
56326: CALL 51220 0 2
// continue ;
56330: GO 56131
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56332: LD_ADDR_EXP 49
56336: PUSH
56337: LD_EXP 49
56341: PPUSH
56342: LD_VAR 0 2
56346: PPUSH
56347: EMPTY
56348: PPUSH
56349: CALL_OW 1
56353: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56354: LD_VAR 0 2
56358: PPUSH
56359: LD_INT 103
56361: PPUSH
56362: CALL 51220 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56366: LD_ADDR_VAR 0 5
56370: PUSH
56371: LD_EXP 43
56375: PUSH
56376: LD_VAR 0 2
56380: ARRAY
56381: PUSH
56382: LD_EXP 72
56386: PUSH
56387: LD_VAR 0 2
56391: ARRAY
56392: UNION
56393: PPUSH
56394: LD_INT 2
56396: PUSH
56397: LD_INT 25
56399: PUSH
56400: LD_INT 2
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PUSH
56407: LD_INT 25
56409: PUSH
56410: LD_INT 16
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: LIST
56421: PUSH
56422: EMPTY
56423: LIST
56424: PPUSH
56425: CALL_OW 72
56429: PUSH
56430: LD_EXP 46
56434: PUSH
56435: LD_VAR 0 2
56439: ARRAY
56440: PUSH
56441: LD_INT 1
56443: ARRAY
56444: PUSH
56445: LD_EXP 46
56449: PUSH
56450: LD_VAR 0 2
56454: ARRAY
56455: PUSH
56456: LD_INT 2
56458: ARRAY
56459: UNION
56460: DIFF
56461: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56462: LD_ADDR_VAR 0 6
56466: PUSH
56467: LD_EXP 62
56471: PUSH
56472: LD_VAR 0 2
56476: ARRAY
56477: PPUSH
56478: LD_INT 2
56480: PUSH
56481: LD_INT 34
56483: PUSH
56484: LD_INT 13
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: PUSH
56491: LD_INT 34
56493: PUSH
56494: LD_INT 52
56496: PUSH
56497: EMPTY
56498: LIST
56499: LIST
56500: PUSH
56501: LD_INT 34
56503: PUSH
56504: LD_EXP 92
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: LIST
56517: LIST
56518: PPUSH
56519: CALL_OW 72
56523: ST_TO_ADDR
// if cranes then
56524: LD_VAR 0 6
56528: IFFALSE 56664
// begin for j in cranes do
56530: LD_ADDR_VAR 0 3
56534: PUSH
56535: LD_VAR 0 6
56539: PUSH
56540: FOR_IN
56541: IFFALSE 56662
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56543: LD_VAR 0 3
56547: PPUSH
56548: CALL_OW 256
56552: PUSH
56553: LD_INT 1000
56555: EQUAL
56556: PUSH
56557: LD_VAR 0 3
56561: PPUSH
56562: CALL_OW 314
56566: NOT
56567: AND
56568: IFFALSE 56602
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56570: LD_VAR 0 3
56574: PPUSH
56575: LD_EXP 44
56579: PUSH
56580: LD_VAR 0 2
56584: ARRAY
56585: PPUSH
56586: LD_VAR 0 3
56590: PPUSH
56591: CALL_OW 74
56595: PPUSH
56596: CALL_OW 130
56600: GO 56660
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56602: LD_VAR 0 3
56606: PPUSH
56607: CALL_OW 256
56611: PUSH
56612: LD_INT 500
56614: LESS
56615: PUSH
56616: LD_VAR 0 3
56620: PPUSH
56621: LD_EXP 67
56625: PUSH
56626: LD_VAR 0 2
56630: ARRAY
56631: PPUSH
56632: CALL_OW 308
56636: NOT
56637: AND
56638: IFFALSE 56660
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56640: LD_VAR 0 3
56644: PPUSH
56645: LD_EXP 67
56649: PUSH
56650: LD_VAR 0 2
56654: ARRAY
56655: PPUSH
56656: CALL_OW 113
// end ;
56660: GO 56540
56662: POP
56663: POP
// end ; if tmp > 3 then
56664: LD_VAR 0 5
56668: PUSH
56669: LD_INT 3
56671: GREATER
56672: IFFALSE 56692
// tmp := ShrinkArray ( tmp , 4 ) ;
56674: LD_ADDR_VAR 0 5
56678: PUSH
56679: LD_VAR 0 5
56683: PPUSH
56684: LD_INT 4
56686: PPUSH
56687: CALL 46167 0 2
56691: ST_TO_ADDR
// if not tmp then
56692: LD_VAR 0 5
56696: NOT
56697: IFFALSE 56701
// continue ;
56699: GO 56131
// for j in tmp do
56701: LD_ADDR_VAR 0 3
56705: PUSH
56706: LD_VAR 0 5
56710: PUSH
56711: FOR_IN
56712: IFFALSE 56971
// begin if IsInUnit ( j ) then
56714: LD_VAR 0 3
56718: PPUSH
56719: CALL_OW 310
56723: IFFALSE 56734
// ComExitBuilding ( j ) ;
56725: LD_VAR 0 3
56729: PPUSH
56730: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56734: LD_VAR 0 3
56738: PUSH
56739: LD_EXP 45
56743: PUSH
56744: LD_VAR 0 2
56748: ARRAY
56749: IN
56750: NOT
56751: IFFALSE 56809
// begin SetTag ( j , 101 ) ;
56753: LD_VAR 0 3
56757: PPUSH
56758: LD_INT 101
56760: PPUSH
56761: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56765: LD_ADDR_EXP 45
56769: PUSH
56770: LD_EXP 45
56774: PPUSH
56775: LD_VAR 0 2
56779: PUSH
56780: LD_EXP 45
56784: PUSH
56785: LD_VAR 0 2
56789: ARRAY
56790: PUSH
56791: LD_INT 1
56793: PLUS
56794: PUSH
56795: EMPTY
56796: LIST
56797: LIST
56798: PPUSH
56799: LD_VAR 0 3
56803: PPUSH
56804: CALL 14797 0 3
56808: ST_TO_ADDR
// end ; wait ( 1 ) ;
56809: LD_INT 1
56811: PPUSH
56812: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56816: LD_ADDR_VAR 0 7
56820: PUSH
56821: LD_EXP 44
56825: PUSH
56826: LD_VAR 0 2
56830: ARRAY
56831: ST_TO_ADDR
// if mc_scan [ i ] then
56832: LD_EXP 66
56836: PUSH
56837: LD_VAR 0 2
56841: ARRAY
56842: IFFALSE 56904
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56844: LD_ADDR_VAR 0 7
56848: PUSH
56849: LD_EXP 44
56853: PUSH
56854: LD_VAR 0 2
56858: ARRAY
56859: PPUSH
56860: LD_INT 3
56862: PUSH
56863: LD_INT 30
56865: PUSH
56866: LD_INT 32
56868: PUSH
56869: EMPTY
56870: LIST
56871: LIST
56872: PUSH
56873: LD_INT 30
56875: PUSH
56876: LD_INT 33
56878: PUSH
56879: EMPTY
56880: LIST
56881: LIST
56882: PUSH
56883: LD_INT 30
56885: PUSH
56886: LD_INT 31
56888: PUSH
56889: EMPTY
56890: LIST
56891: LIST
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: PPUSH
56899: CALL_OW 72
56903: ST_TO_ADDR
// if not to_repair_tmp then
56904: LD_VAR 0 7
56908: NOT
56909: IFFALSE 56913
// continue ;
56911: GO 56711
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56913: LD_ADDR_VAR 0 8
56917: PUSH
56918: LD_VAR 0 7
56922: PPUSH
56923: LD_VAR 0 3
56927: PPUSH
56928: CALL_OW 74
56932: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56933: LD_VAR 0 8
56937: PPUSH
56938: LD_INT 16
56940: PPUSH
56941: CALL 17390 0 2
56945: PUSH
56946: LD_INT 4
56948: ARRAY
56949: PUSH
56950: LD_INT 10
56952: LESS
56953: IFFALSE 56969
// ComRepairBuilding ( j , to_repair ) ;
56955: LD_VAR 0 3
56959: PPUSH
56960: LD_VAR 0 8
56964: PPUSH
56965: CALL_OW 130
// end ;
56969: GO 56711
56971: POP
56972: POP
// end ;
56973: GO 56131
56975: POP
56976: POP
// end ;
56977: LD_VAR 0 1
56981: RET
// export function MC_Heal ; var i , j , tmp ; begin
56982: LD_INT 0
56984: PPUSH
56985: PPUSH
56986: PPUSH
56987: PPUSH
// if not mc_bases then
56988: LD_EXP 43
56992: NOT
56993: IFFALSE 56997
// exit ;
56995: GO 57399
// for i = 1 to mc_bases do
56997: LD_ADDR_VAR 0 2
57001: PUSH
57002: DOUBLE
57003: LD_INT 1
57005: DEC
57006: ST_TO_ADDR
57007: LD_EXP 43
57011: PUSH
57012: FOR_TO
57013: IFFALSE 57397
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
57015: LD_EXP 46
57019: PUSH
57020: LD_VAR 0 2
57024: ARRAY
57025: PUSH
57026: LD_INT 1
57028: ARRAY
57029: NOT
57030: PUSH
57031: LD_EXP 46
57035: PUSH
57036: LD_VAR 0 2
57040: ARRAY
57041: PUSH
57042: LD_INT 2
57044: ARRAY
57045: NOT
57046: AND
57047: IFFALSE 57085
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
57049: LD_ADDR_EXP 47
57053: PUSH
57054: LD_EXP 47
57058: PPUSH
57059: LD_VAR 0 2
57063: PPUSH
57064: EMPTY
57065: PPUSH
57066: CALL_OW 1
57070: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
57071: LD_VAR 0 2
57075: PPUSH
57076: LD_INT 102
57078: PPUSH
57079: CALL 51220 0 2
// continue ;
57083: GO 57012
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57085: LD_ADDR_VAR 0 4
57089: PUSH
57090: LD_EXP 43
57094: PUSH
57095: LD_VAR 0 2
57099: ARRAY
57100: PPUSH
57101: LD_INT 25
57103: PUSH
57104: LD_INT 4
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: PPUSH
57111: CALL_OW 72
57115: ST_TO_ADDR
// if not tmp then
57116: LD_VAR 0 4
57120: NOT
57121: IFFALSE 57125
// continue ;
57123: GO 57012
// if mc_taming [ i ] then
57125: LD_EXP 74
57129: PUSH
57130: LD_VAR 0 2
57134: ARRAY
57135: IFFALSE 57159
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57137: LD_ADDR_EXP 74
57141: PUSH
57142: LD_EXP 74
57146: PPUSH
57147: LD_VAR 0 2
57151: PPUSH
57152: EMPTY
57153: PPUSH
57154: CALL_OW 1
57158: ST_TO_ADDR
// for j in tmp do
57159: LD_ADDR_VAR 0 3
57163: PUSH
57164: LD_VAR 0 4
57168: PUSH
57169: FOR_IN
57170: IFFALSE 57393
// begin if IsInUnit ( j ) then
57172: LD_VAR 0 3
57176: PPUSH
57177: CALL_OW 310
57181: IFFALSE 57192
// ComExitBuilding ( j ) ;
57183: LD_VAR 0 3
57187: PPUSH
57188: CALL_OW 122
// if not j in mc_healers [ i ] then
57192: LD_VAR 0 3
57196: PUSH
57197: LD_EXP 47
57201: PUSH
57202: LD_VAR 0 2
57206: ARRAY
57207: IN
57208: NOT
57209: IFFALSE 57255
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57211: LD_ADDR_EXP 47
57215: PUSH
57216: LD_EXP 47
57220: PPUSH
57221: LD_VAR 0 2
57225: PUSH
57226: LD_EXP 47
57230: PUSH
57231: LD_VAR 0 2
57235: ARRAY
57236: PUSH
57237: LD_INT 1
57239: PLUS
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PPUSH
57245: LD_VAR 0 3
57249: PPUSH
57250: CALL 14797 0 3
57254: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57255: LD_VAR 0 3
57259: PPUSH
57260: CALL_OW 110
57264: PUSH
57265: LD_INT 102
57267: NONEQUAL
57268: IFFALSE 57282
// SetTag ( j , 102 ) ;
57270: LD_VAR 0 3
57274: PPUSH
57275: LD_INT 102
57277: PPUSH
57278: CALL_OW 109
// Wait ( 3 ) ;
57282: LD_INT 3
57284: PPUSH
57285: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57289: LD_EXP 46
57293: PUSH
57294: LD_VAR 0 2
57298: ARRAY
57299: PUSH
57300: LD_INT 1
57302: ARRAY
57303: IFFALSE 57335
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57305: LD_VAR 0 3
57309: PPUSH
57310: LD_EXP 46
57314: PUSH
57315: LD_VAR 0 2
57319: ARRAY
57320: PUSH
57321: LD_INT 1
57323: ARRAY
57324: PUSH
57325: LD_INT 1
57327: ARRAY
57328: PPUSH
57329: CALL_OW 128
57333: GO 57391
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57335: LD_VAR 0 3
57339: PPUSH
57340: CALL_OW 314
57344: NOT
57345: PUSH
57346: LD_EXP 46
57350: PUSH
57351: LD_VAR 0 2
57355: ARRAY
57356: PUSH
57357: LD_INT 2
57359: ARRAY
57360: AND
57361: IFFALSE 57391
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57363: LD_VAR 0 3
57367: PPUSH
57368: LD_EXP 46
57372: PUSH
57373: LD_VAR 0 2
57377: ARRAY
57378: PUSH
57379: LD_INT 2
57381: ARRAY
57382: PUSH
57383: LD_INT 1
57385: ARRAY
57386: PPUSH
57387: CALL_OW 128
// end ;
57391: GO 57169
57393: POP
57394: POP
// end ;
57395: GO 57012
57397: POP
57398: POP
// end ;
57399: LD_VAR 0 1
57403: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57404: LD_INT 0
57406: PPUSH
57407: PPUSH
57408: PPUSH
57409: PPUSH
57410: PPUSH
// if not mc_bases then
57411: LD_EXP 43
57415: NOT
57416: IFFALSE 57420
// exit ;
57418: GO 58563
// for i = 1 to mc_bases do
57420: LD_ADDR_VAR 0 2
57424: PUSH
57425: DOUBLE
57426: LD_INT 1
57428: DEC
57429: ST_TO_ADDR
57430: LD_EXP 43
57434: PUSH
57435: FOR_TO
57436: IFFALSE 58561
// begin if mc_scan [ i ] then
57438: LD_EXP 66
57442: PUSH
57443: LD_VAR 0 2
57447: ARRAY
57448: IFFALSE 57452
// continue ;
57450: GO 57435
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57452: LD_EXP 48
57456: PUSH
57457: LD_VAR 0 2
57461: ARRAY
57462: NOT
57463: PUSH
57464: LD_EXP 50
57468: PUSH
57469: LD_VAR 0 2
57473: ARRAY
57474: NOT
57475: AND
57476: PUSH
57477: LD_EXP 49
57481: PUSH
57482: LD_VAR 0 2
57486: ARRAY
57487: AND
57488: IFFALSE 57526
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57490: LD_ADDR_EXP 49
57494: PUSH
57495: LD_EXP 49
57499: PPUSH
57500: LD_VAR 0 2
57504: PPUSH
57505: EMPTY
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57512: LD_VAR 0 2
57516: PPUSH
57517: LD_INT 103
57519: PPUSH
57520: CALL 51220 0 2
// continue ;
57524: GO 57435
// end ; if mc_construct_list [ i ] then
57526: LD_EXP 50
57530: PUSH
57531: LD_VAR 0 2
57535: ARRAY
57536: IFFALSE 57756
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57538: LD_ADDR_VAR 0 4
57542: PUSH
57543: LD_EXP 43
57547: PUSH
57548: LD_VAR 0 2
57552: ARRAY
57553: PPUSH
57554: LD_INT 25
57556: PUSH
57557: LD_INT 2
57559: PUSH
57560: EMPTY
57561: LIST
57562: LIST
57563: PPUSH
57564: CALL_OW 72
57568: PUSH
57569: LD_EXP 45
57573: PUSH
57574: LD_VAR 0 2
57578: ARRAY
57579: DIFF
57580: ST_TO_ADDR
// if not tmp then
57581: LD_VAR 0 4
57585: NOT
57586: IFFALSE 57590
// continue ;
57588: GO 57435
// for j in tmp do
57590: LD_ADDR_VAR 0 3
57594: PUSH
57595: LD_VAR 0 4
57599: PUSH
57600: FOR_IN
57601: IFFALSE 57752
// begin if not mc_builders [ i ] then
57603: LD_EXP 49
57607: PUSH
57608: LD_VAR 0 2
57612: ARRAY
57613: NOT
57614: IFFALSE 57672
// begin SetTag ( j , 103 ) ;
57616: LD_VAR 0 3
57620: PPUSH
57621: LD_INT 103
57623: PPUSH
57624: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57628: LD_ADDR_EXP 49
57632: PUSH
57633: LD_EXP 49
57637: PPUSH
57638: LD_VAR 0 2
57642: PUSH
57643: LD_EXP 49
57647: PUSH
57648: LD_VAR 0 2
57652: ARRAY
57653: PUSH
57654: LD_INT 1
57656: PLUS
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: PPUSH
57662: LD_VAR 0 3
57666: PPUSH
57667: CALL 14797 0 3
57671: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57672: LD_VAR 0 3
57676: PPUSH
57677: CALL_OW 310
57681: IFFALSE 57692
// ComExitBuilding ( j ) ;
57683: LD_VAR 0 3
57687: PPUSH
57688: CALL_OW 122
// wait ( 3 ) ;
57692: LD_INT 3
57694: PPUSH
57695: CALL_OW 67
// if not mc_construct_list [ i ] then
57699: LD_EXP 50
57703: PUSH
57704: LD_VAR 0 2
57708: ARRAY
57709: NOT
57710: IFFALSE 57714
// break ;
57712: GO 57752
// if not HasTask ( j ) then
57714: LD_VAR 0 3
57718: PPUSH
57719: CALL_OW 314
57723: NOT
57724: IFFALSE 57750
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57726: LD_VAR 0 3
57730: PPUSH
57731: LD_EXP 50
57735: PUSH
57736: LD_VAR 0 2
57740: ARRAY
57741: PUSH
57742: LD_INT 1
57744: ARRAY
57745: PPUSH
57746: CALL 17654 0 2
// end ;
57750: GO 57600
57752: POP
57753: POP
// end else
57754: GO 58559
// if mc_build_list [ i ] then
57756: LD_EXP 48
57760: PUSH
57761: LD_VAR 0 2
57765: ARRAY
57766: IFFALSE 58559
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57768: LD_ADDR_VAR 0 5
57772: PUSH
57773: LD_EXP 43
57777: PUSH
57778: LD_VAR 0 2
57782: ARRAY
57783: PPUSH
57784: LD_INT 2
57786: PUSH
57787: LD_INT 30
57789: PUSH
57790: LD_INT 0
57792: PUSH
57793: EMPTY
57794: LIST
57795: LIST
57796: PUSH
57797: LD_INT 30
57799: PUSH
57800: LD_INT 1
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: LIST
57811: PPUSH
57812: CALL_OW 72
57816: ST_TO_ADDR
// if depot then
57817: LD_VAR 0 5
57821: IFFALSE 57839
// depot := depot [ 1 ] else
57823: LD_ADDR_VAR 0 5
57827: PUSH
57828: LD_VAR 0 5
57832: PUSH
57833: LD_INT 1
57835: ARRAY
57836: ST_TO_ADDR
57837: GO 57847
// depot := 0 ;
57839: LD_ADDR_VAR 0 5
57843: PUSH
57844: LD_INT 0
57846: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57847: LD_EXP 48
57851: PUSH
57852: LD_VAR 0 2
57856: ARRAY
57857: PUSH
57858: LD_INT 1
57860: ARRAY
57861: PUSH
57862: LD_INT 1
57864: ARRAY
57865: PPUSH
57866: CALL 17478 0 1
57870: PUSH
57871: LD_EXP 43
57875: PUSH
57876: LD_VAR 0 2
57880: ARRAY
57881: PPUSH
57882: LD_INT 2
57884: PUSH
57885: LD_INT 30
57887: PUSH
57888: LD_INT 2
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: PUSH
57895: LD_INT 30
57897: PUSH
57898: LD_INT 3
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: LIST
57909: PPUSH
57910: CALL_OW 72
57914: NOT
57915: AND
57916: IFFALSE 58021
// begin for j = 1 to mc_build_list [ i ] do
57918: LD_ADDR_VAR 0 3
57922: PUSH
57923: DOUBLE
57924: LD_INT 1
57926: DEC
57927: ST_TO_ADDR
57928: LD_EXP 48
57932: PUSH
57933: LD_VAR 0 2
57937: ARRAY
57938: PUSH
57939: FOR_TO
57940: IFFALSE 58019
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57942: LD_EXP 48
57946: PUSH
57947: LD_VAR 0 2
57951: ARRAY
57952: PUSH
57953: LD_VAR 0 3
57957: ARRAY
57958: PUSH
57959: LD_INT 1
57961: ARRAY
57962: PUSH
57963: LD_INT 2
57965: EQUAL
57966: IFFALSE 58017
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
57968: LD_ADDR_EXP 48
57972: PUSH
57973: LD_EXP 48
57977: PPUSH
57978: LD_VAR 0 2
57982: PPUSH
57983: LD_EXP 48
57987: PUSH
57988: LD_VAR 0 2
57992: ARRAY
57993: PPUSH
57994: LD_VAR 0 3
57998: PPUSH
57999: LD_INT 1
58001: PPUSH
58002: LD_INT 0
58004: PPUSH
58005: CALL 14215 0 4
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
// break ;
58015: GO 58019
// end ;
58017: GO 57939
58019: POP
58020: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
58021: LD_EXP 48
58025: PUSH
58026: LD_VAR 0 2
58030: ARRAY
58031: PUSH
58032: LD_INT 1
58034: ARRAY
58035: PUSH
58036: LD_INT 1
58038: ARRAY
58039: PUSH
58040: LD_INT 0
58042: EQUAL
58043: PUSH
58044: LD_VAR 0 5
58048: PUSH
58049: LD_VAR 0 5
58053: PPUSH
58054: LD_EXP 48
58058: PUSH
58059: LD_VAR 0 2
58063: ARRAY
58064: PUSH
58065: LD_INT 1
58067: ARRAY
58068: PUSH
58069: LD_INT 1
58071: ARRAY
58072: PPUSH
58073: LD_EXP 48
58077: PUSH
58078: LD_VAR 0 2
58082: ARRAY
58083: PUSH
58084: LD_INT 1
58086: ARRAY
58087: PUSH
58088: LD_INT 2
58090: ARRAY
58091: PPUSH
58092: LD_EXP 48
58096: PUSH
58097: LD_VAR 0 2
58101: ARRAY
58102: PUSH
58103: LD_INT 1
58105: ARRAY
58106: PUSH
58107: LD_INT 3
58109: ARRAY
58110: PPUSH
58111: LD_EXP 48
58115: PUSH
58116: LD_VAR 0 2
58120: ARRAY
58121: PUSH
58122: LD_INT 1
58124: ARRAY
58125: PUSH
58126: LD_INT 4
58128: ARRAY
58129: PPUSH
58130: CALL 22224 0 5
58134: AND
58135: OR
58136: IFFALSE 58417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58138: LD_ADDR_VAR 0 4
58142: PUSH
58143: LD_EXP 43
58147: PUSH
58148: LD_VAR 0 2
58152: ARRAY
58153: PPUSH
58154: LD_INT 25
58156: PUSH
58157: LD_INT 2
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: PPUSH
58164: CALL_OW 72
58168: PUSH
58169: LD_EXP 45
58173: PUSH
58174: LD_VAR 0 2
58178: ARRAY
58179: DIFF
58180: ST_TO_ADDR
// if not tmp then
58181: LD_VAR 0 4
58185: NOT
58186: IFFALSE 58190
// continue ;
58188: GO 57435
// for j in tmp do
58190: LD_ADDR_VAR 0 3
58194: PUSH
58195: LD_VAR 0 4
58199: PUSH
58200: FOR_IN
58201: IFFALSE 58413
// begin if not mc_builders [ i ] then
58203: LD_EXP 49
58207: PUSH
58208: LD_VAR 0 2
58212: ARRAY
58213: NOT
58214: IFFALSE 58272
// begin SetTag ( j , 103 ) ;
58216: LD_VAR 0 3
58220: PPUSH
58221: LD_INT 103
58223: PPUSH
58224: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58228: LD_ADDR_EXP 49
58232: PUSH
58233: LD_EXP 49
58237: PPUSH
58238: LD_VAR 0 2
58242: PUSH
58243: LD_EXP 49
58247: PUSH
58248: LD_VAR 0 2
58252: ARRAY
58253: PUSH
58254: LD_INT 1
58256: PLUS
58257: PUSH
58258: EMPTY
58259: LIST
58260: LIST
58261: PPUSH
58262: LD_VAR 0 3
58266: PPUSH
58267: CALL 14797 0 3
58271: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58272: LD_VAR 0 3
58276: PPUSH
58277: CALL_OW 310
58281: IFFALSE 58292
// ComExitBuilding ( j ) ;
58283: LD_VAR 0 3
58287: PPUSH
58288: CALL_OW 122
// wait ( 3 ) ;
58292: LD_INT 3
58294: PPUSH
58295: CALL_OW 67
// if not mc_build_list [ i ] then
58299: LD_EXP 48
58303: PUSH
58304: LD_VAR 0 2
58308: ARRAY
58309: NOT
58310: IFFALSE 58314
// break ;
58312: GO 58413
// if not HasTask ( j ) then
58314: LD_VAR 0 3
58318: PPUSH
58319: CALL_OW 314
58323: NOT
58324: IFFALSE 58411
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58326: LD_VAR 0 3
58330: PPUSH
58331: LD_EXP 48
58335: PUSH
58336: LD_VAR 0 2
58340: ARRAY
58341: PUSH
58342: LD_INT 1
58344: ARRAY
58345: PUSH
58346: LD_INT 1
58348: ARRAY
58349: PPUSH
58350: LD_EXP 48
58354: PUSH
58355: LD_VAR 0 2
58359: ARRAY
58360: PUSH
58361: LD_INT 1
58363: ARRAY
58364: PUSH
58365: LD_INT 2
58367: ARRAY
58368: PPUSH
58369: LD_EXP 48
58373: PUSH
58374: LD_VAR 0 2
58378: ARRAY
58379: PUSH
58380: LD_INT 1
58382: ARRAY
58383: PUSH
58384: LD_INT 3
58386: ARRAY
58387: PPUSH
58388: LD_EXP 48
58392: PUSH
58393: LD_VAR 0 2
58397: ARRAY
58398: PUSH
58399: LD_INT 1
58401: ARRAY
58402: PUSH
58403: LD_INT 4
58405: ARRAY
58406: PPUSH
58407: CALL_OW 145
// end ;
58411: GO 58200
58413: POP
58414: POP
// end else
58415: GO 58559
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
58417: LD_EXP 43
58421: PUSH
58422: LD_VAR 0 2
58426: ARRAY
58427: PPUSH
58428: LD_EXP 48
58432: PUSH
58433: LD_VAR 0 2
58437: ARRAY
58438: PUSH
58439: LD_INT 1
58441: ARRAY
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: PPUSH
58447: LD_EXP 48
58451: PUSH
58452: LD_VAR 0 2
58456: ARRAY
58457: PUSH
58458: LD_INT 1
58460: ARRAY
58461: PUSH
58462: LD_INT 2
58464: ARRAY
58465: PPUSH
58466: LD_EXP 48
58470: PUSH
58471: LD_VAR 0 2
58475: ARRAY
58476: PUSH
58477: LD_INT 1
58479: ARRAY
58480: PUSH
58481: LD_INT 3
58483: ARRAY
58484: PPUSH
58485: LD_EXP 48
58489: PUSH
58490: LD_VAR 0 2
58494: ARRAY
58495: PUSH
58496: LD_INT 1
58498: ARRAY
58499: PUSH
58500: LD_INT 4
58502: ARRAY
58503: PPUSH
58504: CALL 21560 0 5
58508: NOT
58509: IFFALSE 58559
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58511: LD_ADDR_EXP 48
58515: PUSH
58516: LD_EXP 48
58520: PPUSH
58521: LD_VAR 0 2
58525: PPUSH
58526: LD_EXP 48
58530: PUSH
58531: LD_VAR 0 2
58535: ARRAY
58536: PPUSH
58537: LD_INT 1
58539: PPUSH
58540: LD_INT 1
58542: NEG
58543: PPUSH
58544: LD_INT 0
58546: PPUSH
58547: CALL 14215 0 4
58551: PPUSH
58552: CALL_OW 1
58556: ST_TO_ADDR
// continue ;
58557: GO 57435
// end ; end ; end ;
58559: GO 57435
58561: POP
58562: POP
// end ;
58563: LD_VAR 0 1
58567: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58568: LD_INT 0
58570: PPUSH
58571: PPUSH
58572: PPUSH
58573: PPUSH
58574: PPUSH
58575: PPUSH
// if not mc_bases then
58576: LD_EXP 43
58580: NOT
58581: IFFALSE 58585
// exit ;
58583: GO 59012
// for i = 1 to mc_bases do
58585: LD_ADDR_VAR 0 2
58589: PUSH
58590: DOUBLE
58591: LD_INT 1
58593: DEC
58594: ST_TO_ADDR
58595: LD_EXP 43
58599: PUSH
58600: FOR_TO
58601: IFFALSE 59010
// begin tmp := mc_build_upgrade [ i ] ;
58603: LD_ADDR_VAR 0 4
58607: PUSH
58608: LD_EXP 75
58612: PUSH
58613: LD_VAR 0 2
58617: ARRAY
58618: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58619: LD_ADDR_VAR 0 6
58623: PUSH
58624: LD_EXP 76
58628: PUSH
58629: LD_VAR 0 2
58633: ARRAY
58634: PPUSH
58635: LD_INT 2
58637: PUSH
58638: LD_INT 30
58640: PUSH
58641: LD_INT 6
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PUSH
58648: LD_INT 30
58650: PUSH
58651: LD_INT 7
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: PUSH
58658: EMPTY
58659: LIST
58660: LIST
58661: LIST
58662: PPUSH
58663: CALL_OW 72
58667: ST_TO_ADDR
// if not tmp and not lab then
58668: LD_VAR 0 4
58672: NOT
58673: PUSH
58674: LD_VAR 0 6
58678: NOT
58679: AND
58680: IFFALSE 58684
// continue ;
58682: GO 58600
// if tmp then
58684: LD_VAR 0 4
58688: IFFALSE 58808
// for j in tmp do
58690: LD_ADDR_VAR 0 3
58694: PUSH
58695: LD_VAR 0 4
58699: PUSH
58700: FOR_IN
58701: IFFALSE 58806
// begin if UpgradeCost ( j ) then
58703: LD_VAR 0 3
58707: PPUSH
58708: CALL 21220 0 1
58712: IFFALSE 58804
// begin ComUpgrade ( j ) ;
58714: LD_VAR 0 3
58718: PPUSH
58719: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58723: LD_ADDR_EXP 75
58727: PUSH
58728: LD_EXP 75
58732: PPUSH
58733: LD_VAR 0 2
58737: PPUSH
58738: LD_EXP 75
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PUSH
58749: LD_VAR 0 3
58753: DIFF
58754: PPUSH
58755: CALL_OW 1
58759: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58760: LD_ADDR_EXP 50
58764: PUSH
58765: LD_EXP 50
58769: PPUSH
58770: LD_VAR 0 2
58774: PUSH
58775: LD_EXP 50
58779: PUSH
58780: LD_VAR 0 2
58784: ARRAY
58785: PUSH
58786: LD_INT 1
58788: PLUS
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: PPUSH
58794: LD_VAR 0 3
58798: PPUSH
58799: CALL 14797 0 3
58803: ST_TO_ADDR
// end ; end ;
58804: GO 58700
58806: POP
58807: POP
// if not lab or not mc_lab_upgrade [ i ] then
58808: LD_VAR 0 6
58812: NOT
58813: PUSH
58814: LD_EXP 77
58818: PUSH
58819: LD_VAR 0 2
58823: ARRAY
58824: NOT
58825: OR
58826: IFFALSE 58830
// continue ;
58828: GO 58600
// for j in lab do
58830: LD_ADDR_VAR 0 3
58834: PUSH
58835: LD_VAR 0 6
58839: PUSH
58840: FOR_IN
58841: IFFALSE 59006
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58843: LD_VAR 0 3
58847: PPUSH
58848: CALL_OW 266
58852: PUSH
58853: LD_INT 6
58855: PUSH
58856: LD_INT 7
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: IN
58863: PUSH
58864: LD_VAR 0 3
58868: PPUSH
58869: CALL_OW 461
58873: PUSH
58874: LD_INT 1
58876: NONEQUAL
58877: AND
58878: IFFALSE 59004
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58880: LD_VAR 0 3
58884: PPUSH
58885: LD_EXP 77
58889: PUSH
58890: LD_VAR 0 2
58894: ARRAY
58895: PUSH
58896: LD_INT 1
58898: ARRAY
58899: PPUSH
58900: CALL 21425 0 2
58904: IFFALSE 59004
// begin ComCancel ( j ) ;
58906: LD_VAR 0 3
58910: PPUSH
58911: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58915: LD_VAR 0 3
58919: PPUSH
58920: LD_EXP 77
58924: PUSH
58925: LD_VAR 0 2
58929: ARRAY
58930: PUSH
58931: LD_INT 1
58933: ARRAY
58934: PPUSH
58935: CALL_OW 207
// if not j in mc_construct_list [ i ] then
58939: LD_VAR 0 3
58943: PUSH
58944: LD_EXP 50
58948: PUSH
58949: LD_VAR 0 2
58953: ARRAY
58954: IN
58955: NOT
58956: IFFALSE 59002
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58958: LD_ADDR_EXP 50
58962: PUSH
58963: LD_EXP 50
58967: PPUSH
58968: LD_VAR 0 2
58972: PUSH
58973: LD_EXP 50
58977: PUSH
58978: LD_VAR 0 2
58982: ARRAY
58983: PUSH
58984: LD_INT 1
58986: PLUS
58987: PUSH
58988: EMPTY
58989: LIST
58990: LIST
58991: PPUSH
58992: LD_VAR 0 3
58996: PPUSH
58997: CALL 14797 0 3
59001: ST_TO_ADDR
// break ;
59002: GO 59006
// end ; end ; end ;
59004: GO 58840
59006: POP
59007: POP
// end ;
59008: GO 58600
59010: POP
59011: POP
// end ;
59012: LD_VAR 0 1
59016: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
59017: LD_INT 0
59019: PPUSH
59020: PPUSH
59021: PPUSH
59022: PPUSH
59023: PPUSH
59024: PPUSH
59025: PPUSH
59026: PPUSH
59027: PPUSH
// if not mc_bases then
59028: LD_EXP 43
59032: NOT
59033: IFFALSE 59037
// exit ;
59035: GO 59442
// for i = 1 to mc_bases do
59037: LD_ADDR_VAR 0 2
59041: PUSH
59042: DOUBLE
59043: LD_INT 1
59045: DEC
59046: ST_TO_ADDR
59047: LD_EXP 43
59051: PUSH
59052: FOR_TO
59053: IFFALSE 59440
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
59055: LD_EXP 51
59059: PUSH
59060: LD_VAR 0 2
59064: ARRAY
59065: NOT
59066: PUSH
59067: LD_EXP 43
59071: PUSH
59072: LD_VAR 0 2
59076: ARRAY
59077: PPUSH
59078: LD_INT 30
59080: PUSH
59081: LD_INT 3
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PPUSH
59088: CALL_OW 72
59092: NOT
59093: OR
59094: IFFALSE 59098
// continue ;
59096: GO 59052
// busy := false ;
59098: LD_ADDR_VAR 0 8
59102: PUSH
59103: LD_INT 0
59105: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59106: LD_ADDR_VAR 0 4
59110: PUSH
59111: LD_EXP 43
59115: PUSH
59116: LD_VAR 0 2
59120: ARRAY
59121: PPUSH
59122: LD_INT 30
59124: PUSH
59125: LD_INT 3
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PPUSH
59132: CALL_OW 72
59136: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59137: LD_ADDR_VAR 0 6
59141: PUSH
59142: LD_EXP 51
59146: PUSH
59147: LD_VAR 0 2
59151: ARRAY
59152: PPUSH
59153: LD_INT 2
59155: PUSH
59156: LD_INT 30
59158: PUSH
59159: LD_INT 32
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PUSH
59166: LD_INT 30
59168: PUSH
59169: LD_INT 33
59171: PUSH
59172: EMPTY
59173: LIST
59174: LIST
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: LIST
59180: PPUSH
59181: CALL_OW 72
59185: ST_TO_ADDR
// if not t then
59186: LD_VAR 0 6
59190: NOT
59191: IFFALSE 59195
// continue ;
59193: GO 59052
// for j in tmp do
59195: LD_ADDR_VAR 0 3
59199: PUSH
59200: LD_VAR 0 4
59204: PUSH
59205: FOR_IN
59206: IFFALSE 59236
// if not BuildingStatus ( j ) = bs_idle then
59208: LD_VAR 0 3
59212: PPUSH
59213: CALL_OW 461
59217: PUSH
59218: LD_INT 2
59220: EQUAL
59221: NOT
59222: IFFALSE 59234
// begin busy := true ;
59224: LD_ADDR_VAR 0 8
59228: PUSH
59229: LD_INT 1
59231: ST_TO_ADDR
// break ;
59232: GO 59236
// end ;
59234: GO 59205
59236: POP
59237: POP
// if busy then
59238: LD_VAR 0 8
59242: IFFALSE 59246
// continue ;
59244: GO 59052
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59246: LD_ADDR_VAR 0 7
59250: PUSH
59251: LD_VAR 0 6
59255: PPUSH
59256: LD_INT 35
59258: PUSH
59259: LD_INT 0
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: PPUSH
59266: CALL_OW 72
59270: ST_TO_ADDR
// if tw then
59271: LD_VAR 0 7
59275: IFFALSE 59352
// begin tw := tw [ 1 ] ;
59277: LD_ADDR_VAR 0 7
59281: PUSH
59282: LD_VAR 0 7
59286: PUSH
59287: LD_INT 1
59289: ARRAY
59290: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59291: LD_ADDR_VAR 0 9
59295: PUSH
59296: LD_VAR 0 7
59300: PPUSH
59301: LD_EXP 68
59305: PUSH
59306: LD_VAR 0 2
59310: ARRAY
59311: PPUSH
59312: CALL 19776 0 2
59316: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59317: LD_EXP 82
59321: PUSH
59322: LD_VAR 0 2
59326: ARRAY
59327: IFFALSE 59350
// if not weapon in mc_allowed_tower_weapons [ i ] then
59329: LD_VAR 0 9
59333: PUSH
59334: LD_EXP 82
59338: PUSH
59339: LD_VAR 0 2
59343: ARRAY
59344: IN
59345: NOT
59346: IFFALSE 59350
// continue ;
59348: GO 59052
// end else
59350: GO 59415
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59352: LD_ADDR_VAR 0 5
59356: PUSH
59357: LD_EXP 51
59361: PUSH
59362: LD_VAR 0 2
59366: ARRAY
59367: PPUSH
59368: LD_VAR 0 4
59372: PPUSH
59373: CALL 45400 0 2
59377: ST_TO_ADDR
// if not tmp2 then
59378: LD_VAR 0 5
59382: NOT
59383: IFFALSE 59387
// continue ;
59385: GO 59052
// tw := tmp2 [ 1 ] ;
59387: LD_ADDR_VAR 0 7
59391: PUSH
59392: LD_VAR 0 5
59396: PUSH
59397: LD_INT 1
59399: ARRAY
59400: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59401: LD_ADDR_VAR 0 9
59405: PUSH
59406: LD_VAR 0 5
59410: PUSH
59411: LD_INT 2
59413: ARRAY
59414: ST_TO_ADDR
// end ; if not weapon then
59415: LD_VAR 0 9
59419: NOT
59420: IFFALSE 59424
// continue ;
59422: GO 59052
// ComPlaceWeapon ( tw , weapon ) ;
59424: LD_VAR 0 7
59428: PPUSH
59429: LD_VAR 0 9
59433: PPUSH
59434: CALL_OW 148
// end ;
59438: GO 59052
59440: POP
59441: POP
// end ;
59442: LD_VAR 0 1
59446: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
59447: LD_INT 0
59449: PPUSH
59450: PPUSH
59451: PPUSH
59452: PPUSH
59453: PPUSH
59454: PPUSH
59455: PPUSH
// if not mc_bases then
59456: LD_EXP 43
59460: NOT
59461: IFFALSE 59465
// exit ;
59463: GO 60233
// for i = 1 to mc_bases do
59465: LD_ADDR_VAR 0 2
59469: PUSH
59470: DOUBLE
59471: LD_INT 1
59473: DEC
59474: ST_TO_ADDR
59475: LD_EXP 43
59479: PUSH
59480: FOR_TO
59481: IFFALSE 60231
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59483: LD_EXP 56
59487: PUSH
59488: LD_VAR 0 2
59492: ARRAY
59493: NOT
59494: PUSH
59495: LD_EXP 56
59499: PUSH
59500: LD_VAR 0 2
59504: ARRAY
59505: PUSH
59506: LD_EXP 57
59510: PUSH
59511: LD_VAR 0 2
59515: ARRAY
59516: EQUAL
59517: OR
59518: PUSH
59519: LD_EXP 66
59523: PUSH
59524: LD_VAR 0 2
59528: ARRAY
59529: OR
59530: IFFALSE 59534
// continue ;
59532: GO 59480
// if mc_miners [ i ] then
59534: LD_EXP 57
59538: PUSH
59539: LD_VAR 0 2
59543: ARRAY
59544: IFFALSE 59918
// begin for j = mc_miners [ i ] downto 1 do
59546: LD_ADDR_VAR 0 3
59550: PUSH
59551: DOUBLE
59552: LD_EXP 57
59556: PUSH
59557: LD_VAR 0 2
59561: ARRAY
59562: INC
59563: ST_TO_ADDR
59564: LD_INT 1
59566: PUSH
59567: FOR_DOWNTO
59568: IFFALSE 59916
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59570: LD_EXP 57
59574: PUSH
59575: LD_VAR 0 2
59579: ARRAY
59580: PUSH
59581: LD_VAR 0 3
59585: ARRAY
59586: PPUSH
59587: CALL_OW 301
59591: PUSH
59592: LD_EXP 57
59596: PUSH
59597: LD_VAR 0 2
59601: ARRAY
59602: PUSH
59603: LD_VAR 0 3
59607: ARRAY
59608: PPUSH
59609: CALL_OW 257
59613: PUSH
59614: LD_INT 1
59616: NONEQUAL
59617: OR
59618: IFFALSE 59681
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59620: LD_ADDR_VAR 0 5
59624: PUSH
59625: LD_EXP 57
59629: PUSH
59630: LD_VAR 0 2
59634: ARRAY
59635: PUSH
59636: LD_EXP 57
59640: PUSH
59641: LD_VAR 0 2
59645: ARRAY
59646: PUSH
59647: LD_VAR 0 3
59651: ARRAY
59652: DIFF
59653: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59654: LD_ADDR_EXP 57
59658: PUSH
59659: LD_EXP 57
59663: PPUSH
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_VAR 0 5
59673: PPUSH
59674: CALL_OW 1
59678: ST_TO_ADDR
// continue ;
59679: GO 59567
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59681: LD_EXP 57
59685: PUSH
59686: LD_VAR 0 2
59690: ARRAY
59691: PUSH
59692: LD_VAR 0 3
59696: ARRAY
59697: PPUSH
59698: CALL_OW 257
59702: PUSH
59703: LD_INT 1
59705: EQUAL
59706: PUSH
59707: LD_EXP 57
59711: PUSH
59712: LD_VAR 0 2
59716: ARRAY
59717: PUSH
59718: LD_VAR 0 3
59722: ARRAY
59723: PPUSH
59724: CALL_OW 459
59728: NOT
59729: AND
59730: PUSH
59731: LD_EXP 57
59735: PUSH
59736: LD_VAR 0 2
59740: ARRAY
59741: PUSH
59742: LD_VAR 0 3
59746: ARRAY
59747: PPUSH
59748: CALL_OW 314
59752: NOT
59753: AND
59754: IFFALSE 59914
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59756: LD_EXP 57
59760: PUSH
59761: LD_VAR 0 2
59765: ARRAY
59766: PUSH
59767: LD_VAR 0 3
59771: ARRAY
59772: PPUSH
59773: CALL_OW 310
59777: IFFALSE 59800
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59779: LD_EXP 57
59783: PUSH
59784: LD_VAR 0 2
59788: ARRAY
59789: PUSH
59790: LD_VAR 0 3
59794: ARRAY
59795: PPUSH
59796: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59800: LD_EXP 57
59804: PUSH
59805: LD_VAR 0 2
59809: ARRAY
59810: PUSH
59811: LD_VAR 0 3
59815: ARRAY
59816: PPUSH
59817: CALL_OW 314
59821: NOT
59822: IFFALSE 59914
// begin r := rand ( 1 , mc_mines [ i ] ) ;
59824: LD_ADDR_VAR 0 7
59828: PUSH
59829: LD_INT 1
59831: PPUSH
59832: LD_EXP 56
59836: PUSH
59837: LD_VAR 0 2
59841: ARRAY
59842: PPUSH
59843: CALL_OW 12
59847: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
59848: LD_EXP 57
59852: PUSH
59853: LD_VAR 0 2
59857: ARRAY
59858: PUSH
59859: LD_VAR 0 3
59863: ARRAY
59864: PPUSH
59865: LD_EXP 56
59869: PUSH
59870: LD_VAR 0 2
59874: ARRAY
59875: PUSH
59876: LD_VAR 0 7
59880: ARRAY
59881: PUSH
59882: LD_INT 1
59884: ARRAY
59885: PPUSH
59886: LD_EXP 56
59890: PUSH
59891: LD_VAR 0 2
59895: ARRAY
59896: PUSH
59897: LD_VAR 0 7
59901: ARRAY
59902: PUSH
59903: LD_INT 2
59905: ARRAY
59906: PPUSH
59907: LD_INT 0
59909: PPUSH
59910: CALL_OW 193
// end ; end ; end ;
59914: GO 59567
59916: POP
59917: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59918: LD_ADDR_VAR 0 5
59922: PUSH
59923: LD_EXP 43
59927: PUSH
59928: LD_VAR 0 2
59932: ARRAY
59933: PPUSH
59934: LD_INT 2
59936: PUSH
59937: LD_INT 30
59939: PUSH
59940: LD_INT 4
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: PUSH
59947: LD_INT 30
59949: PUSH
59950: LD_INT 5
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PUSH
59957: LD_INT 30
59959: PUSH
59960: LD_INT 32
59962: PUSH
59963: EMPTY
59964: LIST
59965: LIST
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: LIST
59971: LIST
59972: PPUSH
59973: CALL_OW 72
59977: ST_TO_ADDR
// if not tmp then
59978: LD_VAR 0 5
59982: NOT
59983: IFFALSE 59987
// continue ;
59985: GO 59480
// list := [ ] ;
59987: LD_ADDR_VAR 0 6
59991: PUSH
59992: EMPTY
59993: ST_TO_ADDR
// for j in tmp do
59994: LD_ADDR_VAR 0 3
59998: PUSH
59999: LD_VAR 0 5
60003: PUSH
60004: FOR_IN
60005: IFFALSE 60074
// begin for k in UnitsInside ( j ) do
60007: LD_ADDR_VAR 0 4
60011: PUSH
60012: LD_VAR 0 3
60016: PPUSH
60017: CALL_OW 313
60021: PUSH
60022: FOR_IN
60023: IFFALSE 60070
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
60025: LD_VAR 0 4
60029: PPUSH
60030: CALL_OW 257
60034: PUSH
60035: LD_INT 1
60037: EQUAL
60038: PUSH
60039: LD_VAR 0 4
60043: PPUSH
60044: CALL_OW 459
60048: NOT
60049: AND
60050: IFFALSE 60068
// list := list ^ k ;
60052: LD_ADDR_VAR 0 6
60056: PUSH
60057: LD_VAR 0 6
60061: PUSH
60062: LD_VAR 0 4
60066: ADD
60067: ST_TO_ADDR
60068: GO 60022
60070: POP
60071: POP
// end ;
60072: GO 60004
60074: POP
60075: POP
// list := list diff mc_miners [ i ] ;
60076: LD_ADDR_VAR 0 6
60080: PUSH
60081: LD_VAR 0 6
60085: PUSH
60086: LD_EXP 57
60090: PUSH
60091: LD_VAR 0 2
60095: ARRAY
60096: DIFF
60097: ST_TO_ADDR
// if not list then
60098: LD_VAR 0 6
60102: NOT
60103: IFFALSE 60107
// continue ;
60105: GO 59480
// k := mc_mines [ i ] - mc_miners [ i ] ;
60107: LD_ADDR_VAR 0 4
60111: PUSH
60112: LD_EXP 56
60116: PUSH
60117: LD_VAR 0 2
60121: ARRAY
60122: PUSH
60123: LD_EXP 57
60127: PUSH
60128: LD_VAR 0 2
60132: ARRAY
60133: MINUS
60134: ST_TO_ADDR
// if k > list then
60135: LD_VAR 0 4
60139: PUSH
60140: LD_VAR 0 6
60144: GREATER
60145: IFFALSE 60157
// k := list ;
60147: LD_ADDR_VAR 0 4
60151: PUSH
60152: LD_VAR 0 6
60156: ST_TO_ADDR
// for j = 1 to k do
60157: LD_ADDR_VAR 0 3
60161: PUSH
60162: DOUBLE
60163: LD_INT 1
60165: DEC
60166: ST_TO_ADDR
60167: LD_VAR 0 4
60171: PUSH
60172: FOR_TO
60173: IFFALSE 60227
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60175: LD_ADDR_EXP 57
60179: PUSH
60180: LD_EXP 57
60184: PPUSH
60185: LD_VAR 0 2
60189: PUSH
60190: LD_EXP 57
60194: PUSH
60195: LD_VAR 0 2
60199: ARRAY
60200: PUSH
60201: LD_INT 1
60203: PLUS
60204: PUSH
60205: EMPTY
60206: LIST
60207: LIST
60208: PPUSH
60209: LD_VAR 0 6
60213: PUSH
60214: LD_VAR 0 3
60218: ARRAY
60219: PPUSH
60220: CALL 14797 0 3
60224: ST_TO_ADDR
60225: GO 60172
60227: POP
60228: POP
// end ;
60229: GO 59480
60231: POP
60232: POP
// end ;
60233: LD_VAR 0 1
60237: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60238: LD_INT 0
60240: PPUSH
60241: PPUSH
60242: PPUSH
60243: PPUSH
60244: PPUSH
60245: PPUSH
60246: PPUSH
60247: PPUSH
60248: PPUSH
60249: PPUSH
// if not mc_bases then
60250: LD_EXP 43
60254: NOT
60255: IFFALSE 60259
// exit ;
60257: GO 62009
// for i = 1 to mc_bases do
60259: LD_ADDR_VAR 0 2
60263: PUSH
60264: DOUBLE
60265: LD_INT 1
60267: DEC
60268: ST_TO_ADDR
60269: LD_EXP 43
60273: PUSH
60274: FOR_TO
60275: IFFALSE 62007
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60277: LD_EXP 43
60281: PUSH
60282: LD_VAR 0 2
60286: ARRAY
60287: NOT
60288: PUSH
60289: LD_EXP 50
60293: PUSH
60294: LD_VAR 0 2
60298: ARRAY
60299: OR
60300: IFFALSE 60304
// continue ;
60302: GO 60274
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60304: LD_EXP 59
60308: PUSH
60309: LD_VAR 0 2
60313: ARRAY
60314: NOT
60315: PUSH
60316: LD_EXP 60
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: AND
60327: IFFALSE 60365
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60329: LD_ADDR_EXP 60
60333: PUSH
60334: LD_EXP 60
60338: PPUSH
60339: LD_VAR 0 2
60343: PPUSH
60344: EMPTY
60345: PPUSH
60346: CALL_OW 1
60350: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60351: LD_VAR 0 2
60355: PPUSH
60356: LD_INT 107
60358: PPUSH
60359: CALL 51220 0 2
// continue ;
60363: GO 60274
// end ; target := [ ] ;
60365: LD_ADDR_VAR 0 6
60369: PUSH
60370: EMPTY
60371: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60372: LD_ADDR_VAR 0 3
60376: PUSH
60377: DOUBLE
60378: LD_EXP 59
60382: PUSH
60383: LD_VAR 0 2
60387: ARRAY
60388: INC
60389: ST_TO_ADDR
60390: LD_INT 1
60392: PUSH
60393: FOR_DOWNTO
60394: IFFALSE 60654
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60396: LD_EXP 59
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: PUSH
60407: LD_VAR 0 3
60411: ARRAY
60412: PUSH
60413: LD_INT 2
60415: ARRAY
60416: PPUSH
60417: LD_EXP 59
60421: PUSH
60422: LD_VAR 0 2
60426: ARRAY
60427: PUSH
60428: LD_VAR 0 3
60432: ARRAY
60433: PUSH
60434: LD_INT 3
60436: ARRAY
60437: PPUSH
60438: CALL_OW 488
60442: PUSH
60443: LD_EXP 59
60447: PUSH
60448: LD_VAR 0 2
60452: ARRAY
60453: PUSH
60454: LD_VAR 0 3
60458: ARRAY
60459: PUSH
60460: LD_INT 2
60462: ARRAY
60463: PPUSH
60464: LD_EXP 59
60468: PUSH
60469: LD_VAR 0 2
60473: ARRAY
60474: PUSH
60475: LD_VAR 0 3
60479: ARRAY
60480: PUSH
60481: LD_INT 3
60483: ARRAY
60484: PPUSH
60485: CALL_OW 284
60489: PUSH
60490: LD_INT 0
60492: EQUAL
60493: AND
60494: IFFALSE 60549
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60496: LD_ADDR_VAR 0 5
60500: PUSH
60501: LD_EXP 59
60505: PUSH
60506: LD_VAR 0 2
60510: ARRAY
60511: PPUSH
60512: LD_VAR 0 3
60516: PPUSH
60517: CALL_OW 3
60521: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60522: LD_ADDR_EXP 59
60526: PUSH
60527: LD_EXP 59
60531: PPUSH
60532: LD_VAR 0 2
60536: PPUSH
60537: LD_VAR 0 5
60541: PPUSH
60542: CALL_OW 1
60546: ST_TO_ADDR
// continue ;
60547: GO 60393
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60549: LD_EXP 43
60553: PUSH
60554: LD_VAR 0 2
60558: ARRAY
60559: PUSH
60560: LD_INT 1
60562: ARRAY
60563: PPUSH
60564: CALL_OW 255
60568: PPUSH
60569: LD_EXP 59
60573: PUSH
60574: LD_VAR 0 2
60578: ARRAY
60579: PUSH
60580: LD_VAR 0 3
60584: ARRAY
60585: PUSH
60586: LD_INT 2
60588: ARRAY
60589: PPUSH
60590: LD_EXP 59
60594: PUSH
60595: LD_VAR 0 2
60599: ARRAY
60600: PUSH
60601: LD_VAR 0 3
60605: ARRAY
60606: PUSH
60607: LD_INT 3
60609: ARRAY
60610: PPUSH
60611: LD_INT 30
60613: PPUSH
60614: CALL 15693 0 4
60618: PUSH
60619: LD_INT 4
60621: ARRAY
60622: PUSH
60623: LD_INT 0
60625: EQUAL
60626: IFFALSE 60652
// begin target := mc_crates [ i ] [ j ] ;
60628: LD_ADDR_VAR 0 6
60632: PUSH
60633: LD_EXP 59
60637: PUSH
60638: LD_VAR 0 2
60642: ARRAY
60643: PUSH
60644: LD_VAR 0 3
60648: ARRAY
60649: ST_TO_ADDR
// break ;
60650: GO 60654
// end ; end ;
60652: GO 60393
60654: POP
60655: POP
// if not target then
60656: LD_VAR 0 6
60660: NOT
60661: IFFALSE 60665
// continue ;
60663: GO 60274
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60665: LD_ADDR_VAR 0 7
60669: PUSH
60670: LD_EXP 62
60674: PUSH
60675: LD_VAR 0 2
60679: ARRAY
60680: PPUSH
60681: LD_INT 2
60683: PUSH
60684: LD_INT 3
60686: PUSH
60687: LD_INT 58
60689: PUSH
60690: EMPTY
60691: LIST
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PUSH
60697: LD_INT 61
60699: PUSH
60700: EMPTY
60701: LIST
60702: PUSH
60703: LD_INT 33
60705: PUSH
60706: LD_INT 5
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 33
60715: PUSH
60716: LD_INT 3
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: LIST
60728: LIST
60729: PUSH
60730: LD_INT 2
60732: PUSH
60733: LD_INT 34
60735: PUSH
60736: LD_INT 32
60738: PUSH
60739: EMPTY
60740: LIST
60741: LIST
60742: PUSH
60743: LD_INT 34
60745: PUSH
60746: LD_INT 51
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: PUSH
60753: LD_INT 34
60755: PUSH
60756: LD_INT 12
60758: PUSH
60759: EMPTY
60760: LIST
60761: LIST
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: PUSH
60769: EMPTY
60770: LIST
60771: LIST
60772: PPUSH
60773: CALL_OW 72
60777: ST_TO_ADDR
// if not cargo then
60778: LD_VAR 0 7
60782: NOT
60783: IFFALSE 61426
// begin if mc_crates_collector [ i ] < 5 then
60785: LD_EXP 60
60789: PUSH
60790: LD_VAR 0 2
60794: ARRAY
60795: PUSH
60796: LD_INT 5
60798: LESS
60799: IFFALSE 61165
// begin if mc_ape [ i ] then
60801: LD_EXP 72
60805: PUSH
60806: LD_VAR 0 2
60810: ARRAY
60811: IFFALSE 60858
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60813: LD_ADDR_VAR 0 5
60817: PUSH
60818: LD_EXP 72
60822: PUSH
60823: LD_VAR 0 2
60827: ARRAY
60828: PPUSH
60829: LD_INT 25
60831: PUSH
60832: LD_INT 16
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: LD_INT 24
60841: PUSH
60842: LD_INT 750
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: PPUSH
60853: CALL_OW 72
60857: ST_TO_ADDR
// if not tmp then
60858: LD_VAR 0 5
60862: NOT
60863: IFFALSE 60910
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60865: LD_ADDR_VAR 0 5
60869: PUSH
60870: LD_EXP 43
60874: PUSH
60875: LD_VAR 0 2
60879: ARRAY
60880: PPUSH
60881: LD_INT 25
60883: PUSH
60884: LD_INT 2
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: PUSH
60891: LD_INT 24
60893: PUSH
60894: LD_INT 750
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PPUSH
60905: CALL_OW 72
60909: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60910: LD_EXP 72
60914: PUSH
60915: LD_VAR 0 2
60919: ARRAY
60920: PUSH
60921: LD_EXP 43
60925: PUSH
60926: LD_VAR 0 2
60930: ARRAY
60931: PPUSH
60932: LD_INT 25
60934: PUSH
60935: LD_INT 2
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 24
60944: PUSH
60945: LD_INT 750
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: PPUSH
60956: CALL_OW 72
60960: AND
60961: PUSH
60962: LD_VAR 0 5
60966: PUSH
60967: LD_INT 5
60969: LESS
60970: AND
60971: IFFALSE 61053
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
60973: LD_ADDR_VAR 0 3
60977: PUSH
60978: LD_EXP 43
60982: PUSH
60983: LD_VAR 0 2
60987: ARRAY
60988: PPUSH
60989: LD_INT 25
60991: PUSH
60992: LD_INT 2
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PUSH
60999: LD_INT 24
61001: PUSH
61002: LD_INT 750
61004: PUSH
61005: EMPTY
61006: LIST
61007: LIST
61008: PUSH
61009: EMPTY
61010: LIST
61011: LIST
61012: PPUSH
61013: CALL_OW 72
61017: PUSH
61018: FOR_IN
61019: IFFALSE 61051
// begin tmp := tmp union j ;
61021: LD_ADDR_VAR 0 5
61025: PUSH
61026: LD_VAR 0 5
61030: PUSH
61031: LD_VAR 0 3
61035: UNION
61036: ST_TO_ADDR
// if tmp >= 5 then
61037: LD_VAR 0 5
61041: PUSH
61042: LD_INT 5
61044: GREATEREQUAL
61045: IFFALSE 61049
// break ;
61047: GO 61051
// end ;
61049: GO 61018
61051: POP
61052: POP
// end ; if not tmp then
61053: LD_VAR 0 5
61057: NOT
61058: IFFALSE 61062
// continue ;
61060: GO 60274
// for j in tmp do
61062: LD_ADDR_VAR 0 3
61066: PUSH
61067: LD_VAR 0 5
61071: PUSH
61072: FOR_IN
61073: IFFALSE 61163
// if not GetTag ( j ) then
61075: LD_VAR 0 3
61079: PPUSH
61080: CALL_OW 110
61084: NOT
61085: IFFALSE 61161
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61087: LD_ADDR_EXP 60
61091: PUSH
61092: LD_EXP 60
61096: PPUSH
61097: LD_VAR 0 2
61101: PUSH
61102: LD_EXP 60
61106: PUSH
61107: LD_VAR 0 2
61111: ARRAY
61112: PUSH
61113: LD_INT 1
61115: PLUS
61116: PUSH
61117: EMPTY
61118: LIST
61119: LIST
61120: PPUSH
61121: LD_VAR 0 3
61125: PPUSH
61126: CALL 14797 0 3
61130: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61131: LD_VAR 0 3
61135: PPUSH
61136: LD_INT 107
61138: PPUSH
61139: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61143: LD_EXP 60
61147: PUSH
61148: LD_VAR 0 2
61152: ARRAY
61153: PUSH
61154: LD_INT 5
61156: GREATEREQUAL
61157: IFFALSE 61161
// break ;
61159: GO 61163
// end ;
61161: GO 61072
61163: POP
61164: POP
// end ; if mc_crates_collector [ i ] and target then
61165: LD_EXP 60
61169: PUSH
61170: LD_VAR 0 2
61174: ARRAY
61175: PUSH
61176: LD_VAR 0 6
61180: AND
61181: IFFALSE 61424
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61183: LD_EXP 60
61187: PUSH
61188: LD_VAR 0 2
61192: ARRAY
61193: PUSH
61194: LD_VAR 0 6
61198: PUSH
61199: LD_INT 1
61201: ARRAY
61202: LESS
61203: IFFALSE 61223
// tmp := mc_crates_collector [ i ] else
61205: LD_ADDR_VAR 0 5
61209: PUSH
61210: LD_EXP 60
61214: PUSH
61215: LD_VAR 0 2
61219: ARRAY
61220: ST_TO_ADDR
61221: GO 61237
// tmp := target [ 1 ] ;
61223: LD_ADDR_VAR 0 5
61227: PUSH
61228: LD_VAR 0 6
61232: PUSH
61233: LD_INT 1
61235: ARRAY
61236: ST_TO_ADDR
// k := 0 ;
61237: LD_ADDR_VAR 0 4
61241: PUSH
61242: LD_INT 0
61244: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61245: LD_ADDR_VAR 0 3
61249: PUSH
61250: LD_EXP 60
61254: PUSH
61255: LD_VAR 0 2
61259: ARRAY
61260: PUSH
61261: FOR_IN
61262: IFFALSE 61422
// begin k := k + 1 ;
61264: LD_ADDR_VAR 0 4
61268: PUSH
61269: LD_VAR 0 4
61273: PUSH
61274: LD_INT 1
61276: PLUS
61277: ST_TO_ADDR
// if k > tmp then
61278: LD_VAR 0 4
61282: PUSH
61283: LD_VAR 0 5
61287: GREATER
61288: IFFALSE 61292
// break ;
61290: GO 61422
// if not GetClass ( j ) in [ 2 , 16 ] then
61292: LD_VAR 0 3
61296: PPUSH
61297: CALL_OW 257
61301: PUSH
61302: LD_INT 2
61304: PUSH
61305: LD_INT 16
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: IN
61312: NOT
61313: IFFALSE 61366
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61315: LD_ADDR_EXP 60
61319: PUSH
61320: LD_EXP 60
61324: PPUSH
61325: LD_VAR 0 2
61329: PPUSH
61330: LD_EXP 60
61334: PUSH
61335: LD_VAR 0 2
61339: ARRAY
61340: PUSH
61341: LD_VAR 0 3
61345: DIFF
61346: PPUSH
61347: CALL_OW 1
61351: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61352: LD_VAR 0 3
61356: PPUSH
61357: LD_INT 0
61359: PPUSH
61360: CALL_OW 109
// continue ;
61364: GO 61261
// end ; if IsInUnit ( j ) then
61366: LD_VAR 0 3
61370: PPUSH
61371: CALL_OW 310
61375: IFFALSE 61386
// ComExitBuilding ( j ) ;
61377: LD_VAR 0 3
61381: PPUSH
61382: CALL_OW 122
// wait ( 3 ) ;
61386: LD_INT 3
61388: PPUSH
61389: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61393: LD_VAR 0 3
61397: PPUSH
61398: LD_VAR 0 6
61402: PUSH
61403: LD_INT 2
61405: ARRAY
61406: PPUSH
61407: LD_VAR 0 6
61411: PUSH
61412: LD_INT 3
61414: ARRAY
61415: PPUSH
61416: CALL_OW 117
// end ;
61420: GO 61261
61422: POP
61423: POP
// end ; end else
61424: GO 62005
// begin for j in cargo do
61426: LD_ADDR_VAR 0 3
61430: PUSH
61431: LD_VAR 0 7
61435: PUSH
61436: FOR_IN
61437: IFFALSE 62003
// begin if GetTag ( j ) <> 0 then
61439: LD_VAR 0 3
61443: PPUSH
61444: CALL_OW 110
61448: PUSH
61449: LD_INT 0
61451: NONEQUAL
61452: IFFALSE 61456
// continue ;
61454: GO 61436
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61456: LD_VAR 0 3
61460: PPUSH
61461: CALL_OW 256
61465: PUSH
61466: LD_INT 1000
61468: LESS
61469: PUSH
61470: LD_VAR 0 3
61474: PPUSH
61475: LD_EXP 67
61479: PUSH
61480: LD_VAR 0 2
61484: ARRAY
61485: PPUSH
61486: CALL_OW 308
61490: NOT
61491: AND
61492: IFFALSE 61514
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61494: LD_VAR 0 3
61498: PPUSH
61499: LD_EXP 67
61503: PUSH
61504: LD_VAR 0 2
61508: ARRAY
61509: PPUSH
61510: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61514: LD_VAR 0 3
61518: PPUSH
61519: CALL_OW 256
61523: PUSH
61524: LD_INT 1000
61526: LESS
61527: PUSH
61528: LD_VAR 0 3
61532: PPUSH
61533: LD_EXP 67
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PPUSH
61544: CALL_OW 308
61548: AND
61549: IFFALSE 61553
// continue ;
61551: GO 61436
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61553: LD_VAR 0 3
61557: PPUSH
61558: CALL_OW 262
61562: PUSH
61563: LD_INT 2
61565: EQUAL
61566: PUSH
61567: LD_VAR 0 3
61571: PPUSH
61572: CALL_OW 261
61576: PUSH
61577: LD_INT 15
61579: LESS
61580: AND
61581: IFFALSE 61585
// continue ;
61583: GO 61436
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61585: LD_VAR 0 3
61589: PPUSH
61590: CALL_OW 262
61594: PUSH
61595: LD_INT 1
61597: EQUAL
61598: PUSH
61599: LD_VAR 0 3
61603: PPUSH
61604: CALL_OW 261
61608: PUSH
61609: LD_INT 10
61611: LESS
61612: AND
61613: IFFALSE 61942
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61615: LD_ADDR_VAR 0 8
61619: PUSH
61620: LD_EXP 43
61624: PUSH
61625: LD_VAR 0 2
61629: ARRAY
61630: PPUSH
61631: LD_INT 2
61633: PUSH
61634: LD_INT 30
61636: PUSH
61637: LD_INT 0
61639: PUSH
61640: EMPTY
61641: LIST
61642: LIST
61643: PUSH
61644: LD_INT 30
61646: PUSH
61647: LD_INT 1
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: LIST
61658: PPUSH
61659: CALL_OW 72
61663: ST_TO_ADDR
// if not depot then
61664: LD_VAR 0 8
61668: NOT
61669: IFFALSE 61673
// continue ;
61671: GO 61436
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61673: LD_VAR 0 3
61677: PPUSH
61678: LD_VAR 0 8
61682: PPUSH
61683: LD_VAR 0 3
61687: PPUSH
61688: CALL_OW 74
61692: PPUSH
61693: CALL_OW 296
61697: PUSH
61698: LD_INT 6
61700: LESS
61701: IFFALSE 61717
// SetFuel ( j , 100 ) else
61703: LD_VAR 0 3
61707: PPUSH
61708: LD_INT 100
61710: PPUSH
61711: CALL_OW 240
61715: GO 61942
// if GetFuel ( j ) = 0 then
61717: LD_VAR 0 3
61721: PPUSH
61722: CALL_OW 261
61726: PUSH
61727: LD_INT 0
61729: EQUAL
61730: IFFALSE 61942
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61732: LD_ADDR_EXP 62
61736: PUSH
61737: LD_EXP 62
61741: PPUSH
61742: LD_VAR 0 2
61746: PPUSH
61747: LD_EXP 62
61751: PUSH
61752: LD_VAR 0 2
61756: ARRAY
61757: PUSH
61758: LD_VAR 0 3
61762: DIFF
61763: PPUSH
61764: CALL_OW 1
61768: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61769: LD_VAR 0 3
61773: PPUSH
61774: CALL_OW 263
61778: PUSH
61779: LD_INT 1
61781: EQUAL
61782: IFFALSE 61798
// ComExitVehicle ( IsInUnit ( j ) ) ;
61784: LD_VAR 0 3
61788: PPUSH
61789: CALL_OW 310
61793: PPUSH
61794: CALL_OW 121
// if GetControl ( j ) = control_remote then
61798: LD_VAR 0 3
61802: PPUSH
61803: CALL_OW 263
61807: PUSH
61808: LD_INT 2
61810: EQUAL
61811: IFFALSE 61822
// ComUnlink ( j ) ;
61813: LD_VAR 0 3
61817: PPUSH
61818: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61822: LD_ADDR_VAR 0 9
61826: PUSH
61827: LD_VAR 0 2
61831: PPUSH
61832: LD_INT 3
61834: PPUSH
61835: CALL 71317 0 2
61839: ST_TO_ADDR
// if fac then
61840: LD_VAR 0 9
61844: IFFALSE 61940
// begin for k in fac do
61846: LD_ADDR_VAR 0 4
61850: PUSH
61851: LD_VAR 0 9
61855: PUSH
61856: FOR_IN
61857: IFFALSE 61938
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61859: LD_ADDR_VAR 0 10
61863: PUSH
61864: LD_VAR 0 9
61868: PPUSH
61869: LD_VAR 0 3
61873: PPUSH
61874: CALL_OW 265
61878: PPUSH
61879: LD_VAR 0 3
61883: PPUSH
61884: CALL_OW 262
61888: PPUSH
61889: LD_VAR 0 3
61893: PPUSH
61894: CALL_OW 263
61898: PPUSH
61899: LD_VAR 0 3
61903: PPUSH
61904: CALL_OW 264
61908: PPUSH
61909: CALL 12329 0 5
61913: ST_TO_ADDR
// if components then
61914: LD_VAR 0 10
61918: IFFALSE 61936
// begin MC_InsertProduceList ( i , components ) ;
61920: LD_VAR 0 2
61924: PPUSH
61925: LD_VAR 0 10
61929: PPUSH
61930: CALL 70862 0 2
// break ;
61934: GO 61938
// end ; end ;
61936: GO 61856
61938: POP
61939: POP
// end ; continue ;
61940: GO 61436
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
61942: LD_VAR 0 3
61946: PPUSH
61947: LD_INT 1
61949: PPUSH
61950: CALL_OW 289
61954: PUSH
61955: LD_INT 100
61957: LESS
61958: PUSH
61959: LD_VAR 0 3
61963: PPUSH
61964: CALL_OW 314
61968: NOT
61969: AND
61970: IFFALSE 61999
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61972: LD_VAR 0 3
61976: PPUSH
61977: LD_VAR 0 6
61981: PUSH
61982: LD_INT 2
61984: ARRAY
61985: PPUSH
61986: LD_VAR 0 6
61990: PUSH
61991: LD_INT 3
61993: ARRAY
61994: PPUSH
61995: CALL_OW 117
// break ;
61999: GO 62003
// end ;
62001: GO 61436
62003: POP
62004: POP
// end ; end ;
62005: GO 60274
62007: POP
62008: POP
// end ;
62009: LD_VAR 0 1
62013: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
62014: LD_INT 0
62016: PPUSH
62017: PPUSH
62018: PPUSH
62019: PPUSH
// if not mc_bases then
62020: LD_EXP 43
62024: NOT
62025: IFFALSE 62029
// exit ;
62027: GO 62190
// for i = 1 to mc_bases do
62029: LD_ADDR_VAR 0 2
62033: PUSH
62034: DOUBLE
62035: LD_INT 1
62037: DEC
62038: ST_TO_ADDR
62039: LD_EXP 43
62043: PUSH
62044: FOR_TO
62045: IFFALSE 62188
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
62047: LD_ADDR_VAR 0 4
62051: PUSH
62052: LD_EXP 62
62056: PUSH
62057: LD_VAR 0 2
62061: ARRAY
62062: PUSH
62063: LD_EXP 65
62067: PUSH
62068: LD_VAR 0 2
62072: ARRAY
62073: UNION
62074: PPUSH
62075: LD_INT 33
62077: PUSH
62078: LD_INT 2
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: PPUSH
62085: CALL_OW 72
62089: ST_TO_ADDR
// if tmp then
62090: LD_VAR 0 4
62094: IFFALSE 62186
// for j in tmp do
62096: LD_ADDR_VAR 0 3
62100: PUSH
62101: LD_VAR 0 4
62105: PUSH
62106: FOR_IN
62107: IFFALSE 62184
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62109: LD_VAR 0 3
62113: PPUSH
62114: CALL_OW 312
62118: NOT
62119: PUSH
62120: LD_VAR 0 3
62124: PPUSH
62125: CALL_OW 256
62129: PUSH
62130: LD_INT 250
62132: GREATEREQUAL
62133: AND
62134: IFFALSE 62147
// Connect ( j ) else
62136: LD_VAR 0 3
62140: PPUSH
62141: CALL 17736 0 1
62145: GO 62182
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62147: LD_VAR 0 3
62151: PPUSH
62152: CALL_OW 256
62156: PUSH
62157: LD_INT 250
62159: LESS
62160: PUSH
62161: LD_VAR 0 3
62165: PPUSH
62166: CALL_OW 312
62170: AND
62171: IFFALSE 62182
// ComUnlink ( j ) ;
62173: LD_VAR 0 3
62177: PPUSH
62178: CALL_OW 136
62182: GO 62106
62184: POP
62185: POP
// end ;
62186: GO 62044
62188: POP
62189: POP
// end ;
62190: LD_VAR 0 1
62194: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62195: LD_INT 0
62197: PPUSH
62198: PPUSH
62199: PPUSH
62200: PPUSH
62201: PPUSH
// if not mc_bases then
62202: LD_EXP 43
62206: NOT
62207: IFFALSE 62211
// exit ;
62209: GO 62656
// for i = 1 to mc_bases do
62211: LD_ADDR_VAR 0 2
62215: PUSH
62216: DOUBLE
62217: LD_INT 1
62219: DEC
62220: ST_TO_ADDR
62221: LD_EXP 43
62225: PUSH
62226: FOR_TO
62227: IFFALSE 62654
// begin if not mc_produce [ i ] then
62229: LD_EXP 64
62233: PUSH
62234: LD_VAR 0 2
62238: ARRAY
62239: NOT
62240: IFFALSE 62244
// continue ;
62242: GO 62226
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62244: LD_ADDR_VAR 0 5
62248: PUSH
62249: LD_EXP 43
62253: PUSH
62254: LD_VAR 0 2
62258: ARRAY
62259: PPUSH
62260: LD_INT 30
62262: PUSH
62263: LD_INT 3
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: PPUSH
62270: CALL_OW 72
62274: ST_TO_ADDR
// if not fac then
62275: LD_VAR 0 5
62279: NOT
62280: IFFALSE 62284
// continue ;
62282: GO 62226
// for j in fac do
62284: LD_ADDR_VAR 0 3
62288: PUSH
62289: LD_VAR 0 5
62293: PUSH
62294: FOR_IN
62295: IFFALSE 62650
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62297: LD_VAR 0 3
62301: PPUSH
62302: CALL_OW 461
62306: PUSH
62307: LD_INT 2
62309: NONEQUAL
62310: PUSH
62311: LD_VAR 0 3
62315: PPUSH
62316: LD_INT 15
62318: PPUSH
62319: CALL 17390 0 2
62323: PUSH
62324: LD_INT 4
62326: ARRAY
62327: OR
62328: IFFALSE 62332
// continue ;
62330: GO 62294
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62332: LD_VAR 0 3
62336: PPUSH
62337: LD_EXP 64
62341: PUSH
62342: LD_VAR 0 2
62346: ARRAY
62347: PUSH
62348: LD_INT 1
62350: ARRAY
62351: PUSH
62352: LD_INT 1
62354: ARRAY
62355: PPUSH
62356: LD_EXP 64
62360: PUSH
62361: LD_VAR 0 2
62365: ARRAY
62366: PUSH
62367: LD_INT 1
62369: ARRAY
62370: PUSH
62371: LD_INT 2
62373: ARRAY
62374: PPUSH
62375: LD_EXP 64
62379: PUSH
62380: LD_VAR 0 2
62384: ARRAY
62385: PUSH
62386: LD_INT 1
62388: ARRAY
62389: PUSH
62390: LD_INT 3
62392: ARRAY
62393: PPUSH
62394: LD_EXP 64
62398: PUSH
62399: LD_VAR 0 2
62403: ARRAY
62404: PUSH
62405: LD_INT 1
62407: ARRAY
62408: PUSH
62409: LD_INT 4
62411: ARRAY
62412: PPUSH
62413: CALL_OW 448
62417: PUSH
62418: LD_VAR 0 3
62422: PPUSH
62423: LD_EXP 64
62427: PUSH
62428: LD_VAR 0 2
62432: ARRAY
62433: PUSH
62434: LD_INT 1
62436: ARRAY
62437: PUSH
62438: LD_INT 1
62440: ARRAY
62441: PUSH
62442: LD_EXP 64
62446: PUSH
62447: LD_VAR 0 2
62451: ARRAY
62452: PUSH
62453: LD_INT 1
62455: ARRAY
62456: PUSH
62457: LD_INT 2
62459: ARRAY
62460: PUSH
62461: LD_EXP 64
62465: PUSH
62466: LD_VAR 0 2
62470: ARRAY
62471: PUSH
62472: LD_INT 1
62474: ARRAY
62475: PUSH
62476: LD_INT 3
62478: ARRAY
62479: PUSH
62480: LD_EXP 64
62484: PUSH
62485: LD_VAR 0 2
62489: ARRAY
62490: PUSH
62491: LD_INT 1
62493: ARRAY
62494: PUSH
62495: LD_INT 4
62497: ARRAY
62498: PUSH
62499: EMPTY
62500: LIST
62501: LIST
62502: LIST
62503: LIST
62504: PPUSH
62505: CALL 21073 0 2
62509: AND
62510: IFFALSE 62648
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62512: LD_VAR 0 3
62516: PPUSH
62517: LD_EXP 64
62521: PUSH
62522: LD_VAR 0 2
62526: ARRAY
62527: PUSH
62528: LD_INT 1
62530: ARRAY
62531: PUSH
62532: LD_INT 1
62534: ARRAY
62535: PPUSH
62536: LD_EXP 64
62540: PUSH
62541: LD_VAR 0 2
62545: ARRAY
62546: PUSH
62547: LD_INT 1
62549: ARRAY
62550: PUSH
62551: LD_INT 2
62553: ARRAY
62554: PPUSH
62555: LD_EXP 64
62559: PUSH
62560: LD_VAR 0 2
62564: ARRAY
62565: PUSH
62566: LD_INT 1
62568: ARRAY
62569: PUSH
62570: LD_INT 3
62572: ARRAY
62573: PPUSH
62574: LD_EXP 64
62578: PUSH
62579: LD_VAR 0 2
62583: ARRAY
62584: PUSH
62585: LD_INT 1
62587: ARRAY
62588: PUSH
62589: LD_INT 4
62591: ARRAY
62592: PPUSH
62593: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62597: LD_ADDR_VAR 0 4
62601: PUSH
62602: LD_EXP 64
62606: PUSH
62607: LD_VAR 0 2
62611: ARRAY
62612: PPUSH
62613: LD_INT 1
62615: PPUSH
62616: CALL_OW 3
62620: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62621: LD_ADDR_EXP 64
62625: PUSH
62626: LD_EXP 64
62630: PPUSH
62631: LD_VAR 0 2
62635: PPUSH
62636: LD_VAR 0 4
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// break ;
62646: GO 62650
// end ; end ;
62648: GO 62294
62650: POP
62651: POP
// end ;
62652: GO 62226
62654: POP
62655: POP
// end ;
62656: LD_VAR 0 1
62660: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62661: LD_INT 0
62663: PPUSH
62664: PPUSH
62665: PPUSH
// if not mc_bases then
62666: LD_EXP 43
62670: NOT
62671: IFFALSE 62675
// exit ;
62673: GO 62764
// for i = 1 to mc_bases do
62675: LD_ADDR_VAR 0 2
62679: PUSH
62680: DOUBLE
62681: LD_INT 1
62683: DEC
62684: ST_TO_ADDR
62685: LD_EXP 43
62689: PUSH
62690: FOR_TO
62691: IFFALSE 62762
// begin if mc_attack [ i ] then
62693: LD_EXP 63
62697: PUSH
62698: LD_VAR 0 2
62702: ARRAY
62703: IFFALSE 62760
// begin tmp := mc_attack [ i ] [ 1 ] ;
62705: LD_ADDR_VAR 0 3
62709: PUSH
62710: LD_EXP 63
62714: PUSH
62715: LD_VAR 0 2
62719: ARRAY
62720: PUSH
62721: LD_INT 1
62723: ARRAY
62724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62725: LD_ADDR_EXP 63
62729: PUSH
62730: LD_EXP 63
62734: PPUSH
62735: LD_VAR 0 2
62739: PPUSH
62740: EMPTY
62741: PPUSH
62742: CALL_OW 1
62746: ST_TO_ADDR
// Attack ( tmp ) ;
62747: LD_VAR 0 3
62751: PPUSH
62752: CALL 77369 0 1
// exit ;
62756: POP
62757: POP
62758: GO 62764
// end ; end ;
62760: GO 62690
62762: POP
62763: POP
// end ;
62764: LD_VAR 0 1
62768: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62769: LD_INT 0
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
// if not mc_bases then
62778: LD_EXP 43
62782: NOT
62783: IFFALSE 62787
// exit ;
62785: GO 63391
// for i = 1 to mc_bases do
62787: LD_ADDR_VAR 0 2
62791: PUSH
62792: DOUBLE
62793: LD_INT 1
62795: DEC
62796: ST_TO_ADDR
62797: LD_EXP 43
62801: PUSH
62802: FOR_TO
62803: IFFALSE 63389
// begin if not mc_bases [ i ] then
62805: LD_EXP 43
62809: PUSH
62810: LD_VAR 0 2
62814: ARRAY
62815: NOT
62816: IFFALSE 62820
// continue ;
62818: GO 62802
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62820: LD_ADDR_VAR 0 7
62824: PUSH
62825: LD_EXP 43
62829: PUSH
62830: LD_VAR 0 2
62834: ARRAY
62835: PUSH
62836: LD_INT 1
62838: ARRAY
62839: PPUSH
62840: CALL 11633 0 1
62844: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62845: LD_ADDR_EXP 66
62849: PUSH
62850: LD_EXP 66
62854: PPUSH
62855: LD_VAR 0 2
62859: PPUSH
62860: LD_EXP 43
62864: PUSH
62865: LD_VAR 0 2
62869: ARRAY
62870: PUSH
62871: LD_INT 1
62873: ARRAY
62874: PPUSH
62875: CALL_OW 255
62879: PPUSH
62880: LD_EXP 68
62884: PUSH
62885: LD_VAR 0 2
62889: ARRAY
62890: PPUSH
62891: CALL 11598 0 2
62895: PPUSH
62896: CALL_OW 1
62900: ST_TO_ADDR
// if not mc_scan [ i ] then
62901: LD_EXP 66
62905: PUSH
62906: LD_VAR 0 2
62910: ARRAY
62911: NOT
62912: IFFALSE 63067
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62914: LD_ADDR_VAR 0 4
62918: PUSH
62919: LD_EXP 43
62923: PUSH
62924: LD_VAR 0 2
62928: ARRAY
62929: PPUSH
62930: LD_INT 2
62932: PUSH
62933: LD_INT 25
62935: PUSH
62936: LD_INT 5
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: PUSH
62943: LD_INT 25
62945: PUSH
62946: LD_INT 8
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: PUSH
62953: LD_INT 25
62955: PUSH
62956: LD_INT 9
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: LIST
62967: LIST
62968: PPUSH
62969: CALL_OW 72
62973: ST_TO_ADDR
// if not tmp then
62974: LD_VAR 0 4
62978: NOT
62979: IFFALSE 62983
// continue ;
62981: GO 62802
// for j in tmp do
62983: LD_ADDR_VAR 0 3
62987: PUSH
62988: LD_VAR 0 4
62992: PUSH
62993: FOR_IN
62994: IFFALSE 63065
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
62996: LD_VAR 0 3
63000: PPUSH
63001: CALL_OW 310
63005: PPUSH
63006: CALL_OW 266
63010: PUSH
63011: LD_INT 5
63013: EQUAL
63014: PUSH
63015: LD_VAR 0 3
63019: PPUSH
63020: CALL_OW 257
63024: PUSH
63025: LD_INT 1
63027: EQUAL
63028: AND
63029: PUSH
63030: LD_VAR 0 3
63034: PPUSH
63035: CALL_OW 459
63039: NOT
63040: AND
63041: PUSH
63042: LD_VAR 0 7
63046: AND
63047: IFFALSE 63063
// ComChangeProfession ( j , class ) ;
63049: LD_VAR 0 3
63053: PPUSH
63054: LD_VAR 0 7
63058: PPUSH
63059: CALL_OW 123
63063: GO 62993
63065: POP
63066: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
63067: LD_EXP 66
63071: PUSH
63072: LD_VAR 0 2
63076: ARRAY
63077: PUSH
63078: LD_EXP 65
63082: PUSH
63083: LD_VAR 0 2
63087: ARRAY
63088: NOT
63089: AND
63090: PUSH
63091: LD_EXP 43
63095: PUSH
63096: LD_VAR 0 2
63100: ARRAY
63101: PPUSH
63102: LD_INT 30
63104: PUSH
63105: LD_INT 32
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PPUSH
63112: CALL_OW 72
63116: NOT
63117: AND
63118: PUSH
63119: LD_EXP 43
63123: PUSH
63124: LD_VAR 0 2
63128: ARRAY
63129: PPUSH
63130: LD_INT 2
63132: PUSH
63133: LD_INT 30
63135: PUSH
63136: LD_INT 4
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PUSH
63143: LD_INT 30
63145: PUSH
63146: LD_INT 5
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PUSH
63153: EMPTY
63154: LIST
63155: LIST
63156: LIST
63157: PPUSH
63158: CALL_OW 72
63162: NOT
63163: AND
63164: IFFALSE 63296
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63166: LD_ADDR_VAR 0 4
63170: PUSH
63171: LD_EXP 43
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: PPUSH
63182: LD_INT 2
63184: PUSH
63185: LD_INT 25
63187: PUSH
63188: LD_INT 1
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 25
63197: PUSH
63198: LD_INT 5
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 25
63207: PUSH
63208: LD_INT 8
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 25
63217: PUSH
63218: LD_INT 9
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: PPUSH
63232: CALL_OW 72
63236: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63237: LD_ADDR_VAR 0 4
63241: PUSH
63242: LD_VAR 0 4
63246: PUSH
63247: LD_VAR 0 4
63251: PPUSH
63252: LD_INT 18
63254: PPUSH
63255: CALL 43370 0 2
63259: DIFF
63260: ST_TO_ADDR
// if tmp then
63261: LD_VAR 0 4
63265: IFFALSE 63296
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63267: LD_VAR 0 2
63271: PPUSH
63272: LD_VAR 0 4
63276: PPUSH
63277: LD_EXP 68
63281: PUSH
63282: LD_VAR 0 2
63286: ARRAY
63287: PPUSH
63288: CALL 82078 0 3
// exit ;
63292: POP
63293: POP
63294: GO 63391
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
63296: LD_EXP 66
63300: PUSH
63301: LD_VAR 0 2
63305: ARRAY
63306: PUSH
63307: LD_EXP 65
63311: PUSH
63312: LD_VAR 0 2
63316: ARRAY
63317: AND
63318: IFFALSE 63387
// begin tmp := mc_defender [ i ] ;
63320: LD_ADDR_VAR 0 4
63324: PUSH
63325: LD_EXP 65
63329: PUSH
63330: LD_VAR 0 2
63334: ARRAY
63335: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63336: LD_ADDR_EXP 65
63340: PUSH
63341: LD_EXP 65
63345: PPUSH
63346: LD_VAR 0 2
63350: PPUSH
63351: EMPTY
63352: PPUSH
63353: CALL_OW 1
63357: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63358: LD_VAR 0 2
63362: PPUSH
63363: LD_VAR 0 4
63367: PPUSH
63368: LD_EXP 66
63372: PUSH
63373: LD_VAR 0 2
63377: ARRAY
63378: PPUSH
63379: CALL 82639 0 3
// exit ;
63383: POP
63384: POP
63385: GO 63391
// end ; end ;
63387: GO 62802
63389: POP
63390: POP
// end ;
63391: LD_VAR 0 1
63395: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63396: LD_INT 0
63398: PPUSH
63399: PPUSH
63400: PPUSH
63401: PPUSH
63402: PPUSH
63403: PPUSH
63404: PPUSH
63405: PPUSH
63406: PPUSH
63407: PPUSH
63408: PPUSH
// if not mc_bases then
63409: LD_EXP 43
63413: NOT
63414: IFFALSE 63418
// exit ;
63416: GO 64505
// for i = 1 to mc_bases do
63418: LD_ADDR_VAR 0 2
63422: PUSH
63423: DOUBLE
63424: LD_INT 1
63426: DEC
63427: ST_TO_ADDR
63428: LD_EXP 43
63432: PUSH
63433: FOR_TO
63434: IFFALSE 64503
// begin tmp := mc_lab [ i ] ;
63436: LD_ADDR_VAR 0 6
63440: PUSH
63441: LD_EXP 76
63445: PUSH
63446: LD_VAR 0 2
63450: ARRAY
63451: ST_TO_ADDR
// if not tmp then
63452: LD_VAR 0 6
63456: NOT
63457: IFFALSE 63461
// continue ;
63459: GO 63433
// idle_lab := 0 ;
63461: LD_ADDR_VAR 0 11
63465: PUSH
63466: LD_INT 0
63468: ST_TO_ADDR
// for j in tmp do
63469: LD_ADDR_VAR 0 3
63473: PUSH
63474: LD_VAR 0 6
63478: PUSH
63479: FOR_IN
63480: IFFALSE 64499
// begin researching := false ;
63482: LD_ADDR_VAR 0 10
63486: PUSH
63487: LD_INT 0
63489: ST_TO_ADDR
// side := GetSide ( j ) ;
63490: LD_ADDR_VAR 0 4
63494: PUSH
63495: LD_VAR 0 3
63499: PPUSH
63500: CALL_OW 255
63504: ST_TO_ADDR
// if not mc_tech [ side ] then
63505: LD_EXP 70
63509: PUSH
63510: LD_VAR 0 4
63514: ARRAY
63515: NOT
63516: IFFALSE 63520
// continue ;
63518: GO 63479
// if BuildingStatus ( j ) = bs_idle then
63520: LD_VAR 0 3
63524: PPUSH
63525: CALL_OW 461
63529: PUSH
63530: LD_INT 2
63532: EQUAL
63533: IFFALSE 63721
// begin if idle_lab and UnitsInside ( j ) < 6 then
63535: LD_VAR 0 11
63539: PUSH
63540: LD_VAR 0 3
63544: PPUSH
63545: CALL_OW 313
63549: PUSH
63550: LD_INT 6
63552: LESS
63553: AND
63554: IFFALSE 63625
// begin tmp2 := UnitsInside ( idle_lab ) ;
63556: LD_ADDR_VAR 0 9
63560: PUSH
63561: LD_VAR 0 11
63565: PPUSH
63566: CALL_OW 313
63570: ST_TO_ADDR
// if tmp2 then
63571: LD_VAR 0 9
63575: IFFALSE 63617
// for x in tmp2 do
63577: LD_ADDR_VAR 0 7
63581: PUSH
63582: LD_VAR 0 9
63586: PUSH
63587: FOR_IN
63588: IFFALSE 63615
// begin ComExitBuilding ( x ) ;
63590: LD_VAR 0 7
63594: PPUSH
63595: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63599: LD_VAR 0 7
63603: PPUSH
63604: LD_VAR 0 3
63608: PPUSH
63609: CALL_OW 180
// end ;
63613: GO 63587
63615: POP
63616: POP
// idle_lab := 0 ;
63617: LD_ADDR_VAR 0 11
63621: PUSH
63622: LD_INT 0
63624: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63625: LD_ADDR_VAR 0 5
63629: PUSH
63630: LD_EXP 70
63634: PUSH
63635: LD_VAR 0 4
63639: ARRAY
63640: PUSH
63641: FOR_IN
63642: IFFALSE 63702
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63644: LD_VAR 0 3
63648: PPUSH
63649: LD_VAR 0 5
63653: PPUSH
63654: CALL_OW 430
63658: PUSH
63659: LD_VAR 0 4
63663: PPUSH
63664: LD_VAR 0 5
63668: PPUSH
63669: CALL 10703 0 2
63673: AND
63674: IFFALSE 63700
// begin researching := true ;
63676: LD_ADDR_VAR 0 10
63680: PUSH
63681: LD_INT 1
63683: ST_TO_ADDR
// ComResearch ( j , t ) ;
63684: LD_VAR 0 3
63688: PPUSH
63689: LD_VAR 0 5
63693: PPUSH
63694: CALL_OW 124
// break ;
63698: GO 63702
// end ;
63700: GO 63641
63702: POP
63703: POP
// if not researching then
63704: LD_VAR 0 10
63708: NOT
63709: IFFALSE 63721
// idle_lab := j ;
63711: LD_ADDR_VAR 0 11
63715: PUSH
63716: LD_VAR 0 3
63720: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63721: LD_VAR 0 3
63725: PPUSH
63726: CALL_OW 461
63730: PUSH
63731: LD_INT 10
63733: EQUAL
63734: IFFALSE 64322
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63736: LD_EXP 72
63740: PUSH
63741: LD_VAR 0 2
63745: ARRAY
63746: NOT
63747: PUSH
63748: LD_EXP 73
63752: PUSH
63753: LD_VAR 0 2
63757: ARRAY
63758: NOT
63759: AND
63760: PUSH
63761: LD_EXP 70
63765: PUSH
63766: LD_VAR 0 4
63770: ARRAY
63771: PUSH
63772: LD_INT 1
63774: GREATER
63775: AND
63776: IFFALSE 63907
// begin ComCancel ( j ) ;
63778: LD_VAR 0 3
63782: PPUSH
63783: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63787: LD_ADDR_EXP 70
63791: PUSH
63792: LD_EXP 70
63796: PPUSH
63797: LD_VAR 0 4
63801: PPUSH
63802: LD_EXP 70
63806: PUSH
63807: LD_VAR 0 4
63811: ARRAY
63812: PPUSH
63813: LD_EXP 70
63817: PUSH
63818: LD_VAR 0 4
63822: ARRAY
63823: PUSH
63824: LD_INT 1
63826: MINUS
63827: PPUSH
63828: LD_EXP 70
63832: PUSH
63833: LD_VAR 0 4
63837: ARRAY
63838: PPUSH
63839: LD_INT 0
63841: PPUSH
63842: CALL 14215 0 4
63846: PPUSH
63847: CALL_OW 1
63851: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
63852: LD_ADDR_EXP 70
63856: PUSH
63857: LD_EXP 70
63861: PPUSH
63862: LD_VAR 0 4
63866: PPUSH
63867: LD_EXP 70
63871: PUSH
63872: LD_VAR 0 4
63876: ARRAY
63877: PPUSH
63878: LD_EXP 70
63882: PUSH
63883: LD_VAR 0 4
63887: ARRAY
63888: PPUSH
63889: LD_INT 1
63891: PPUSH
63892: LD_INT 0
63894: PPUSH
63895: CALL 14215 0 4
63899: PPUSH
63900: CALL_OW 1
63904: ST_TO_ADDR
// continue ;
63905: GO 63479
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
63907: LD_EXP 72
63911: PUSH
63912: LD_VAR 0 2
63916: ARRAY
63917: PUSH
63918: LD_EXP 73
63922: PUSH
63923: LD_VAR 0 2
63927: ARRAY
63928: NOT
63929: AND
63930: IFFALSE 64057
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
63932: LD_ADDR_EXP 73
63936: PUSH
63937: LD_EXP 73
63941: PPUSH
63942: LD_VAR 0 2
63946: PUSH
63947: LD_EXP 73
63951: PUSH
63952: LD_VAR 0 2
63956: ARRAY
63957: PUSH
63958: LD_INT 1
63960: PLUS
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PPUSH
63966: LD_EXP 72
63970: PUSH
63971: LD_VAR 0 2
63975: ARRAY
63976: PUSH
63977: LD_INT 1
63979: ARRAY
63980: PPUSH
63981: CALL 14797 0 3
63985: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
63986: LD_EXP 72
63990: PUSH
63991: LD_VAR 0 2
63995: ARRAY
63996: PUSH
63997: LD_INT 1
63999: ARRAY
64000: PPUSH
64001: LD_INT 112
64003: PPUSH
64004: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
64008: LD_ADDR_VAR 0 9
64012: PUSH
64013: LD_EXP 72
64017: PUSH
64018: LD_VAR 0 2
64022: ARRAY
64023: PPUSH
64024: LD_INT 1
64026: PPUSH
64027: CALL_OW 3
64031: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
64032: LD_ADDR_EXP 72
64036: PUSH
64037: LD_EXP 72
64041: PPUSH
64042: LD_VAR 0 2
64046: PPUSH
64047: LD_VAR 0 9
64051: PPUSH
64052: CALL_OW 1
64056: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
64057: LD_EXP 72
64061: PUSH
64062: LD_VAR 0 2
64066: ARRAY
64067: PUSH
64068: LD_EXP 73
64072: PUSH
64073: LD_VAR 0 2
64077: ARRAY
64078: AND
64079: PUSH
64080: LD_EXP 73
64084: PUSH
64085: LD_VAR 0 2
64089: ARRAY
64090: PUSH
64091: LD_INT 1
64093: ARRAY
64094: PPUSH
64095: CALL_OW 310
64099: NOT
64100: AND
64101: PUSH
64102: LD_VAR 0 3
64106: PPUSH
64107: CALL_OW 313
64111: PUSH
64112: LD_INT 6
64114: EQUAL
64115: AND
64116: IFFALSE 64172
// begin tmp2 := UnitsInside ( j ) ;
64118: LD_ADDR_VAR 0 9
64122: PUSH
64123: LD_VAR 0 3
64127: PPUSH
64128: CALL_OW 313
64132: ST_TO_ADDR
// if tmp2 = 6 then
64133: LD_VAR 0 9
64137: PUSH
64138: LD_INT 6
64140: EQUAL
64141: IFFALSE 64172
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64143: LD_VAR 0 9
64147: PUSH
64148: LD_INT 1
64150: ARRAY
64151: PPUSH
64152: LD_INT 112
64154: PPUSH
64155: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64159: LD_VAR 0 9
64163: PUSH
64164: LD_INT 1
64166: ARRAY
64167: PPUSH
64168: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64172: LD_EXP 73
64176: PUSH
64177: LD_VAR 0 2
64181: ARRAY
64182: PUSH
64183: LD_EXP 73
64187: PUSH
64188: LD_VAR 0 2
64192: ARRAY
64193: PUSH
64194: LD_INT 1
64196: ARRAY
64197: PPUSH
64198: CALL_OW 314
64202: NOT
64203: AND
64204: PUSH
64205: LD_EXP 73
64209: PUSH
64210: LD_VAR 0 2
64214: ARRAY
64215: PUSH
64216: LD_INT 1
64218: ARRAY
64219: PPUSH
64220: CALL_OW 310
64224: NOT
64225: AND
64226: IFFALSE 64252
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64228: LD_EXP 73
64232: PUSH
64233: LD_VAR 0 2
64237: ARRAY
64238: PUSH
64239: LD_INT 1
64241: ARRAY
64242: PPUSH
64243: LD_VAR 0 3
64247: PPUSH
64248: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64252: LD_EXP 73
64256: PUSH
64257: LD_VAR 0 2
64261: ARRAY
64262: PUSH
64263: LD_INT 1
64265: ARRAY
64266: PPUSH
64267: CALL_OW 310
64271: PUSH
64272: LD_EXP 73
64276: PUSH
64277: LD_VAR 0 2
64281: ARRAY
64282: PUSH
64283: LD_INT 1
64285: ARRAY
64286: PPUSH
64287: CALL_OW 310
64291: PPUSH
64292: CALL_OW 461
64296: PUSH
64297: LD_INT 3
64299: NONEQUAL
64300: AND
64301: IFFALSE 64322
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64303: LD_EXP 73
64307: PUSH
64308: LD_VAR 0 2
64312: ARRAY
64313: PUSH
64314: LD_INT 1
64316: ARRAY
64317: PPUSH
64318: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64322: LD_VAR 0 3
64326: PPUSH
64327: CALL_OW 461
64331: PUSH
64332: LD_INT 6
64334: EQUAL
64335: PUSH
64336: LD_VAR 0 6
64340: PUSH
64341: LD_INT 1
64343: GREATER
64344: AND
64345: IFFALSE 64497
// begin sci := [ ] ;
64347: LD_ADDR_VAR 0 8
64351: PUSH
64352: EMPTY
64353: ST_TO_ADDR
// for x in ( tmp diff j ) do
64354: LD_ADDR_VAR 0 7
64358: PUSH
64359: LD_VAR 0 6
64363: PUSH
64364: LD_VAR 0 3
64368: DIFF
64369: PUSH
64370: FOR_IN
64371: IFFALSE 64423
// begin if sci = 6 then
64373: LD_VAR 0 8
64377: PUSH
64378: LD_INT 6
64380: EQUAL
64381: IFFALSE 64385
// break ;
64383: GO 64423
// if BuildingStatus ( x ) = bs_idle then
64385: LD_VAR 0 7
64389: PPUSH
64390: CALL_OW 461
64394: PUSH
64395: LD_INT 2
64397: EQUAL
64398: IFFALSE 64421
// sci := sci ^ UnitsInside ( x ) ;
64400: LD_ADDR_VAR 0 8
64404: PUSH
64405: LD_VAR 0 8
64409: PUSH
64410: LD_VAR 0 7
64414: PPUSH
64415: CALL_OW 313
64419: ADD
64420: ST_TO_ADDR
// end ;
64421: GO 64370
64423: POP
64424: POP
// if not sci then
64425: LD_VAR 0 8
64429: NOT
64430: IFFALSE 64434
// continue ;
64432: GO 63479
// for x in sci do
64434: LD_ADDR_VAR 0 7
64438: PUSH
64439: LD_VAR 0 8
64443: PUSH
64444: FOR_IN
64445: IFFALSE 64495
// if IsInUnit ( x ) and not HasTask ( x ) then
64447: LD_VAR 0 7
64451: PPUSH
64452: CALL_OW 310
64456: PUSH
64457: LD_VAR 0 7
64461: PPUSH
64462: CALL_OW 314
64466: NOT
64467: AND
64468: IFFALSE 64493
// begin ComExitBuilding ( x ) ;
64470: LD_VAR 0 7
64474: PPUSH
64475: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64479: LD_VAR 0 7
64483: PPUSH
64484: LD_VAR 0 3
64488: PPUSH
64489: CALL_OW 180
// end ;
64493: GO 64444
64495: POP
64496: POP
// end ; end ;
64497: GO 63479
64499: POP
64500: POP
// end ;
64501: GO 63433
64503: POP
64504: POP
// end ;
64505: LD_VAR 0 1
64509: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64510: LD_INT 0
64512: PPUSH
64513: PPUSH
// if not mc_bases then
64514: LD_EXP 43
64518: NOT
64519: IFFALSE 64523
// exit ;
64521: GO 64604
// for i = 1 to mc_bases do
64523: LD_ADDR_VAR 0 2
64527: PUSH
64528: DOUBLE
64529: LD_INT 1
64531: DEC
64532: ST_TO_ADDR
64533: LD_EXP 43
64537: PUSH
64538: FOR_TO
64539: IFFALSE 64602
// if mc_mines [ i ] and mc_miners [ i ] then
64541: LD_EXP 56
64545: PUSH
64546: LD_VAR 0 2
64550: ARRAY
64551: PUSH
64552: LD_EXP 57
64556: PUSH
64557: LD_VAR 0 2
64561: ARRAY
64562: AND
64563: IFFALSE 64600
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64565: LD_EXP 57
64569: PUSH
64570: LD_VAR 0 2
64574: ARRAY
64575: PUSH
64576: LD_INT 1
64578: ARRAY
64579: PPUSH
64580: CALL_OW 255
64584: PPUSH
64585: LD_EXP 56
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: PPUSH
64596: CALL 11786 0 2
64600: GO 64538
64602: POP
64603: POP
// end ;
64604: LD_VAR 0 1
64608: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64609: LD_INT 0
64611: PPUSH
64612: PPUSH
64613: PPUSH
64614: PPUSH
64615: PPUSH
64616: PPUSH
64617: PPUSH
64618: PPUSH
// if not mc_bases or not mc_parking then
64619: LD_EXP 43
64623: NOT
64624: PUSH
64625: LD_EXP 67
64629: NOT
64630: OR
64631: IFFALSE 64635
// exit ;
64633: GO 65334
// for i = 1 to mc_bases do
64635: LD_ADDR_VAR 0 2
64639: PUSH
64640: DOUBLE
64641: LD_INT 1
64643: DEC
64644: ST_TO_ADDR
64645: LD_EXP 43
64649: PUSH
64650: FOR_TO
64651: IFFALSE 65332
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64653: LD_EXP 43
64657: PUSH
64658: LD_VAR 0 2
64662: ARRAY
64663: NOT
64664: PUSH
64665: LD_EXP 67
64669: PUSH
64670: LD_VAR 0 2
64674: ARRAY
64675: NOT
64676: OR
64677: IFFALSE 64681
// continue ;
64679: GO 64650
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64681: LD_ADDR_VAR 0 5
64685: PUSH
64686: LD_EXP 43
64690: PUSH
64691: LD_VAR 0 2
64695: ARRAY
64696: PUSH
64697: LD_INT 1
64699: ARRAY
64700: PPUSH
64701: CALL_OW 255
64705: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64706: LD_ADDR_VAR 0 6
64710: PUSH
64711: LD_EXP 43
64715: PUSH
64716: LD_VAR 0 2
64720: ARRAY
64721: PPUSH
64722: LD_INT 30
64724: PUSH
64725: LD_INT 3
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PPUSH
64732: CALL_OW 72
64736: ST_TO_ADDR
// if not fac then
64737: LD_VAR 0 6
64741: NOT
64742: IFFALSE 64793
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64744: LD_ADDR_VAR 0 6
64748: PUSH
64749: LD_EXP 43
64753: PUSH
64754: LD_VAR 0 2
64758: ARRAY
64759: PPUSH
64760: LD_INT 2
64762: PUSH
64763: LD_INT 30
64765: PUSH
64766: LD_INT 0
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 30
64775: PUSH
64776: LD_INT 1
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: LIST
64787: PPUSH
64788: CALL_OW 72
64792: ST_TO_ADDR
// if not fac then
64793: LD_VAR 0 6
64797: NOT
64798: IFFALSE 64802
// continue ;
64800: GO 64650
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64802: LD_ADDR_VAR 0 7
64806: PUSH
64807: LD_EXP 67
64811: PUSH
64812: LD_VAR 0 2
64816: ARRAY
64817: PPUSH
64818: LD_INT 22
64820: PUSH
64821: LD_VAR 0 5
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: PUSH
64830: LD_INT 21
64832: PUSH
64833: LD_INT 2
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 3
64842: PUSH
64843: LD_INT 24
64845: PUSH
64846: LD_INT 1000
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: LIST
64861: PPUSH
64862: CALL_OW 70
64866: ST_TO_ADDR
// for j in fac do
64867: LD_ADDR_VAR 0 3
64871: PUSH
64872: LD_VAR 0 6
64876: PUSH
64877: FOR_IN
64878: IFFALSE 64959
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64880: LD_ADDR_VAR 0 7
64884: PUSH
64885: LD_VAR 0 7
64889: PUSH
64890: LD_INT 22
64892: PUSH
64893: LD_VAR 0 5
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 91
64904: PUSH
64905: LD_VAR 0 3
64909: PUSH
64910: LD_INT 15
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: LIST
64917: PUSH
64918: LD_INT 21
64920: PUSH
64921: LD_INT 2
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: LD_INT 3
64930: PUSH
64931: LD_INT 24
64933: PUSH
64934: LD_INT 1000
64936: PUSH
64937: EMPTY
64938: LIST
64939: LIST
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: EMPTY
64946: LIST
64947: LIST
64948: LIST
64949: LIST
64950: PPUSH
64951: CALL_OW 69
64955: UNION
64956: ST_TO_ADDR
64957: GO 64877
64959: POP
64960: POP
// if not vehs then
64961: LD_VAR 0 7
64965: NOT
64966: IFFALSE 64992
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64968: LD_ADDR_EXP 55
64972: PUSH
64973: LD_EXP 55
64977: PPUSH
64978: LD_VAR 0 2
64982: PPUSH
64983: EMPTY
64984: PPUSH
64985: CALL_OW 1
64989: ST_TO_ADDR
// continue ;
64990: GO 64650
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64992: LD_ADDR_VAR 0 8
64996: PUSH
64997: LD_EXP 43
65001: PUSH
65002: LD_VAR 0 2
65006: ARRAY
65007: PPUSH
65008: LD_INT 30
65010: PUSH
65011: LD_INT 3
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PPUSH
65018: CALL_OW 72
65022: ST_TO_ADDR
// if tmp then
65023: LD_VAR 0 8
65027: IFFALSE 65130
// begin for j in tmp do
65029: LD_ADDR_VAR 0 3
65033: PUSH
65034: LD_VAR 0 8
65038: PUSH
65039: FOR_IN
65040: IFFALSE 65128
// for k in UnitsInside ( j ) do
65042: LD_ADDR_VAR 0 4
65046: PUSH
65047: LD_VAR 0 3
65051: PPUSH
65052: CALL_OW 313
65056: PUSH
65057: FOR_IN
65058: IFFALSE 65124
// if k then
65060: LD_VAR 0 4
65064: IFFALSE 65122
// if not k in mc_repair_vehicle [ i ] then
65066: LD_VAR 0 4
65070: PUSH
65071: LD_EXP 55
65075: PUSH
65076: LD_VAR 0 2
65080: ARRAY
65081: IN
65082: NOT
65083: IFFALSE 65122
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65085: LD_ADDR_EXP 55
65089: PUSH
65090: LD_EXP 55
65094: PPUSH
65095: LD_VAR 0 2
65099: PPUSH
65100: LD_EXP 55
65104: PUSH
65105: LD_VAR 0 2
65109: ARRAY
65110: PUSH
65111: LD_VAR 0 4
65115: UNION
65116: PPUSH
65117: CALL_OW 1
65121: ST_TO_ADDR
65122: GO 65057
65124: POP
65125: POP
65126: GO 65039
65128: POP
65129: POP
// end ; if not mc_repair_vehicle [ i ] then
65130: LD_EXP 55
65134: PUSH
65135: LD_VAR 0 2
65139: ARRAY
65140: NOT
65141: IFFALSE 65145
// continue ;
65143: GO 64650
// for j in mc_repair_vehicle [ i ] do
65145: LD_ADDR_VAR 0 3
65149: PUSH
65150: LD_EXP 55
65154: PUSH
65155: LD_VAR 0 2
65159: ARRAY
65160: PUSH
65161: FOR_IN
65162: IFFALSE 65328
// begin if GetClass ( j ) <> 3 then
65164: LD_VAR 0 3
65168: PPUSH
65169: CALL_OW 257
65173: PUSH
65174: LD_INT 3
65176: NONEQUAL
65177: IFFALSE 65218
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65179: LD_ADDR_EXP 55
65183: PUSH
65184: LD_EXP 55
65188: PPUSH
65189: LD_VAR 0 2
65193: PPUSH
65194: LD_EXP 55
65198: PUSH
65199: LD_VAR 0 2
65203: ARRAY
65204: PUSH
65205: LD_VAR 0 3
65209: DIFF
65210: PPUSH
65211: CALL_OW 1
65215: ST_TO_ADDR
// continue ;
65216: GO 65161
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65218: LD_VAR 0 3
65222: PPUSH
65223: CALL_OW 311
65227: NOT
65228: PUSH
65229: LD_VAR 0 3
65233: PUSH
65234: LD_EXP 46
65238: PUSH
65239: LD_VAR 0 2
65243: ARRAY
65244: PUSH
65245: LD_INT 1
65247: ARRAY
65248: IN
65249: NOT
65250: AND
65251: PUSH
65252: LD_VAR 0 3
65256: PUSH
65257: LD_EXP 46
65261: PUSH
65262: LD_VAR 0 2
65266: ARRAY
65267: PUSH
65268: LD_INT 2
65270: ARRAY
65271: IN
65272: NOT
65273: AND
65274: IFFALSE 65326
// begin if IsInUnit ( j ) then
65276: LD_VAR 0 3
65280: PPUSH
65281: CALL_OW 310
65285: IFFALSE 65296
// ComExitBuilding ( j ) ;
65287: LD_VAR 0 3
65291: PPUSH
65292: CALL_OW 122
// if not HasTask ( j ) then
65296: LD_VAR 0 3
65300: PPUSH
65301: CALL_OW 314
65305: NOT
65306: IFFALSE 65326
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65308: LD_VAR 0 3
65312: PPUSH
65313: LD_VAR 0 7
65317: PUSH
65318: LD_INT 1
65320: ARRAY
65321: PPUSH
65322: CALL_OW 189
// end ; end ;
65326: GO 65161
65328: POP
65329: POP
// end ;
65330: GO 64650
65332: POP
65333: POP
// end ;
65334: LD_VAR 0 1
65338: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65339: LD_INT 0
65341: PPUSH
65342: PPUSH
65343: PPUSH
65344: PPUSH
65345: PPUSH
65346: PPUSH
65347: PPUSH
65348: PPUSH
65349: PPUSH
65350: PPUSH
65351: PPUSH
// if not mc_bases then
65352: LD_EXP 43
65356: NOT
65357: IFFALSE 65361
// exit ;
65359: GO 66163
// for i = 1 to mc_bases do
65361: LD_ADDR_VAR 0 2
65365: PUSH
65366: DOUBLE
65367: LD_INT 1
65369: DEC
65370: ST_TO_ADDR
65371: LD_EXP 43
65375: PUSH
65376: FOR_TO
65377: IFFALSE 66161
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65379: LD_EXP 71
65383: PUSH
65384: LD_VAR 0 2
65388: ARRAY
65389: NOT
65390: PUSH
65391: LD_EXP 46
65395: PUSH
65396: LD_VAR 0 2
65400: ARRAY
65401: PUSH
65402: LD_INT 1
65404: ARRAY
65405: OR
65406: PUSH
65407: LD_EXP 46
65411: PUSH
65412: LD_VAR 0 2
65416: ARRAY
65417: PUSH
65418: LD_INT 2
65420: ARRAY
65421: OR
65422: PUSH
65423: LD_EXP 69
65427: PUSH
65428: LD_VAR 0 2
65432: ARRAY
65433: PPUSH
65434: LD_INT 1
65436: PPUSH
65437: CALL_OW 325
65441: NOT
65442: OR
65443: PUSH
65444: LD_EXP 66
65448: PUSH
65449: LD_VAR 0 2
65453: ARRAY
65454: OR
65455: IFFALSE 65459
// continue ;
65457: GO 65376
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65459: LD_ADDR_VAR 0 8
65463: PUSH
65464: LD_EXP 43
65468: PUSH
65469: LD_VAR 0 2
65473: ARRAY
65474: PPUSH
65475: LD_INT 25
65477: PUSH
65478: LD_INT 4
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 50
65487: PUSH
65488: EMPTY
65489: LIST
65490: PUSH
65491: LD_INT 3
65493: PUSH
65494: LD_INT 60
65496: PUSH
65497: EMPTY
65498: LIST
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: LIST
65508: PPUSH
65509: CALL_OW 72
65513: PUSH
65514: LD_EXP 47
65518: PUSH
65519: LD_VAR 0 2
65523: ARRAY
65524: DIFF
65525: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65526: LD_ADDR_VAR 0 9
65530: PUSH
65531: LD_EXP 43
65535: PUSH
65536: LD_VAR 0 2
65540: ARRAY
65541: PPUSH
65542: LD_INT 2
65544: PUSH
65545: LD_INT 30
65547: PUSH
65548: LD_INT 0
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 30
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: EMPTY
65562: LIST
65563: LIST
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: LIST
65569: PPUSH
65570: CALL_OW 72
65574: ST_TO_ADDR
// if not tmp or not dep then
65575: LD_VAR 0 8
65579: NOT
65580: PUSH
65581: LD_VAR 0 9
65585: NOT
65586: OR
65587: IFFALSE 65591
// continue ;
65589: GO 65376
// side := GetSide ( tmp [ 1 ] ) ;
65591: LD_ADDR_VAR 0 11
65595: PUSH
65596: LD_VAR 0 8
65600: PUSH
65601: LD_INT 1
65603: ARRAY
65604: PPUSH
65605: CALL_OW 255
65609: ST_TO_ADDR
// dep := dep [ 1 ] ;
65610: LD_ADDR_VAR 0 9
65614: PUSH
65615: LD_VAR 0 9
65619: PUSH
65620: LD_INT 1
65622: ARRAY
65623: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65624: LD_ADDR_VAR 0 7
65628: PUSH
65629: LD_EXP 71
65633: PUSH
65634: LD_VAR 0 2
65638: ARRAY
65639: PPUSH
65640: LD_INT 22
65642: PUSH
65643: LD_INT 0
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 25
65652: PUSH
65653: LD_INT 12
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PPUSH
65664: CALL_OW 70
65668: PUSH
65669: LD_INT 22
65671: PUSH
65672: LD_INT 0
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: LD_INT 25
65681: PUSH
65682: LD_INT 12
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 91
65691: PUSH
65692: LD_VAR 0 9
65696: PUSH
65697: LD_INT 20
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: LIST
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: LIST
65709: PPUSH
65710: CALL_OW 69
65714: UNION
65715: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65716: LD_ADDR_VAR 0 10
65720: PUSH
65721: LD_EXP 71
65725: PUSH
65726: LD_VAR 0 2
65730: ARRAY
65731: PPUSH
65732: LD_INT 81
65734: PUSH
65735: LD_VAR 0 11
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PPUSH
65744: CALL_OW 70
65748: ST_TO_ADDR
// if not apes or danger_at_area then
65749: LD_VAR 0 7
65753: NOT
65754: PUSH
65755: LD_VAR 0 10
65759: OR
65760: IFFALSE 65810
// begin if mc_taming [ i ] then
65762: LD_EXP 74
65766: PUSH
65767: LD_VAR 0 2
65771: ARRAY
65772: IFFALSE 65808
// begin MC_Reset ( i , 121 ) ;
65774: LD_VAR 0 2
65778: PPUSH
65779: LD_INT 121
65781: PPUSH
65782: CALL 51220 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65786: LD_ADDR_EXP 74
65790: PUSH
65791: LD_EXP 74
65795: PPUSH
65796: LD_VAR 0 2
65800: PPUSH
65801: EMPTY
65802: PPUSH
65803: CALL_OW 1
65807: ST_TO_ADDR
// end ; continue ;
65808: GO 65376
// end ; for j in tmp do
65810: LD_ADDR_VAR 0 3
65814: PUSH
65815: LD_VAR 0 8
65819: PUSH
65820: FOR_IN
65821: IFFALSE 66157
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65823: LD_VAR 0 3
65827: PUSH
65828: LD_EXP 74
65832: PUSH
65833: LD_VAR 0 2
65837: ARRAY
65838: IN
65839: NOT
65840: PUSH
65841: LD_EXP 74
65845: PUSH
65846: LD_VAR 0 2
65850: ARRAY
65851: PUSH
65852: LD_INT 3
65854: LESS
65855: AND
65856: IFFALSE 65914
// begin SetTag ( j , 121 ) ;
65858: LD_VAR 0 3
65862: PPUSH
65863: LD_INT 121
65865: PPUSH
65866: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
65870: LD_ADDR_EXP 74
65874: PUSH
65875: LD_EXP 74
65879: PPUSH
65880: LD_VAR 0 2
65884: PUSH
65885: LD_EXP 74
65889: PUSH
65890: LD_VAR 0 2
65894: ARRAY
65895: PUSH
65896: LD_INT 1
65898: PLUS
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PPUSH
65904: LD_VAR 0 3
65908: PPUSH
65909: CALL 14797 0 3
65913: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
65914: LD_VAR 0 3
65918: PUSH
65919: LD_EXP 74
65923: PUSH
65924: LD_VAR 0 2
65928: ARRAY
65929: IN
65930: IFFALSE 66155
// begin if GetClass ( j ) <> 4 then
65932: LD_VAR 0 3
65936: PPUSH
65937: CALL_OW 257
65941: PUSH
65942: LD_INT 4
65944: NONEQUAL
65945: IFFALSE 65998
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
65947: LD_ADDR_EXP 74
65951: PUSH
65952: LD_EXP 74
65956: PPUSH
65957: LD_VAR 0 2
65961: PPUSH
65962: LD_EXP 74
65966: PUSH
65967: LD_VAR 0 2
65971: ARRAY
65972: PUSH
65973: LD_VAR 0 3
65977: DIFF
65978: PPUSH
65979: CALL_OW 1
65983: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65984: LD_VAR 0 3
65988: PPUSH
65989: LD_INT 0
65991: PPUSH
65992: CALL_OW 109
// continue ;
65996: GO 65820
// end ; if IsInUnit ( j ) then
65998: LD_VAR 0 3
66002: PPUSH
66003: CALL_OW 310
66007: IFFALSE 66018
// ComExitBuilding ( j ) ;
66009: LD_VAR 0 3
66013: PPUSH
66014: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
66018: LD_ADDR_VAR 0 6
66022: PUSH
66023: LD_VAR 0 7
66027: PPUSH
66028: LD_VAR 0 3
66032: PPUSH
66033: CALL_OW 74
66037: ST_TO_ADDR
// if not ape then
66038: LD_VAR 0 6
66042: NOT
66043: IFFALSE 66047
// break ;
66045: GO 66157
// x := GetX ( ape ) ;
66047: LD_ADDR_VAR 0 4
66051: PUSH
66052: LD_VAR 0 6
66056: PPUSH
66057: CALL_OW 250
66061: ST_TO_ADDR
// y := GetY ( ape ) ;
66062: LD_ADDR_VAR 0 5
66066: PUSH
66067: LD_VAR 0 6
66071: PPUSH
66072: CALL_OW 251
66076: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66077: LD_VAR 0 4
66081: PPUSH
66082: LD_VAR 0 5
66086: PPUSH
66087: CALL_OW 488
66091: NOT
66092: PUSH
66093: LD_VAR 0 11
66097: PPUSH
66098: LD_VAR 0 4
66102: PPUSH
66103: LD_VAR 0 5
66107: PPUSH
66108: LD_INT 20
66110: PPUSH
66111: CALL 15693 0 4
66115: PUSH
66116: LD_INT 4
66118: ARRAY
66119: OR
66120: IFFALSE 66124
// break ;
66122: GO 66157
// if not HasTask ( j ) then
66124: LD_VAR 0 3
66128: PPUSH
66129: CALL_OW 314
66133: NOT
66134: IFFALSE 66155
// ComTameXY ( j , x , y ) ;
66136: LD_VAR 0 3
66140: PPUSH
66141: LD_VAR 0 4
66145: PPUSH
66146: LD_VAR 0 5
66150: PPUSH
66151: CALL_OW 131
// end ; end ;
66155: GO 65820
66157: POP
66158: POP
// end ;
66159: GO 65376
66161: POP
66162: POP
// end ;
66163: LD_VAR 0 1
66167: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66168: LD_INT 0
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
// if not mc_bases then
66178: LD_EXP 43
66182: NOT
66183: IFFALSE 66187
// exit ;
66185: GO 66813
// for i = 1 to mc_bases do
66187: LD_ADDR_VAR 0 2
66191: PUSH
66192: DOUBLE
66193: LD_INT 1
66195: DEC
66196: ST_TO_ADDR
66197: LD_EXP 43
66201: PUSH
66202: FOR_TO
66203: IFFALSE 66811
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66205: LD_EXP 72
66209: PUSH
66210: LD_VAR 0 2
66214: ARRAY
66215: NOT
66216: PUSH
66217: LD_EXP 72
66221: PUSH
66222: LD_VAR 0 2
66226: ARRAY
66227: PPUSH
66228: LD_INT 25
66230: PUSH
66231: LD_INT 12
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PPUSH
66238: CALL_OW 72
66242: NOT
66243: OR
66244: IFFALSE 66248
// continue ;
66246: GO 66202
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66248: LD_ADDR_VAR 0 5
66252: PUSH
66253: LD_EXP 72
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PUSH
66264: LD_INT 1
66266: ARRAY
66267: PPUSH
66268: CALL_OW 255
66272: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66273: LD_VAR 0 5
66277: PPUSH
66278: LD_INT 2
66280: PPUSH
66281: CALL_OW 325
66285: IFFALSE 66538
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66287: LD_ADDR_VAR 0 4
66291: PUSH
66292: LD_EXP 72
66296: PUSH
66297: LD_VAR 0 2
66301: ARRAY
66302: PPUSH
66303: LD_INT 25
66305: PUSH
66306: LD_INT 16
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PPUSH
66313: CALL_OW 72
66317: ST_TO_ADDR
// if tmp < 6 then
66318: LD_VAR 0 4
66322: PUSH
66323: LD_INT 6
66325: LESS
66326: IFFALSE 66538
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66328: LD_ADDR_VAR 0 6
66332: PUSH
66333: LD_EXP 43
66337: PUSH
66338: LD_VAR 0 2
66342: ARRAY
66343: PPUSH
66344: LD_INT 2
66346: PUSH
66347: LD_INT 30
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 30
66359: PUSH
66360: LD_INT 1
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: LIST
66371: PPUSH
66372: CALL_OW 72
66376: ST_TO_ADDR
// if depot then
66377: LD_VAR 0 6
66381: IFFALSE 66538
// begin selected := 0 ;
66383: LD_ADDR_VAR 0 7
66387: PUSH
66388: LD_INT 0
66390: ST_TO_ADDR
// for j in depot do
66391: LD_ADDR_VAR 0 3
66395: PUSH
66396: LD_VAR 0 6
66400: PUSH
66401: FOR_IN
66402: IFFALSE 66433
// begin if UnitsInside ( j ) < 6 then
66404: LD_VAR 0 3
66408: PPUSH
66409: CALL_OW 313
66413: PUSH
66414: LD_INT 6
66416: LESS
66417: IFFALSE 66431
// begin selected := j ;
66419: LD_ADDR_VAR 0 7
66423: PUSH
66424: LD_VAR 0 3
66428: ST_TO_ADDR
// break ;
66429: GO 66433
// end ; end ;
66431: GO 66401
66433: POP
66434: POP
// if selected then
66435: LD_VAR 0 7
66439: IFFALSE 66538
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66441: LD_ADDR_VAR 0 3
66445: PUSH
66446: LD_EXP 72
66450: PUSH
66451: LD_VAR 0 2
66455: ARRAY
66456: PPUSH
66457: LD_INT 25
66459: PUSH
66460: LD_INT 12
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PPUSH
66467: CALL_OW 72
66471: PUSH
66472: FOR_IN
66473: IFFALSE 66536
// if not HasTask ( j ) then
66475: LD_VAR 0 3
66479: PPUSH
66480: CALL_OW 314
66484: NOT
66485: IFFALSE 66534
// begin if not IsInUnit ( j ) then
66487: LD_VAR 0 3
66491: PPUSH
66492: CALL_OW 310
66496: NOT
66497: IFFALSE 66513
// ComEnterUnit ( j , selected ) ;
66499: LD_VAR 0 3
66503: PPUSH
66504: LD_VAR 0 7
66508: PPUSH
66509: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66513: LD_VAR 0 3
66517: PPUSH
66518: LD_INT 16
66520: PPUSH
66521: CALL_OW 183
// AddComExitBuilding ( j ) ;
66525: LD_VAR 0 3
66529: PPUSH
66530: CALL_OW 182
// end ;
66534: GO 66472
66536: POP
66537: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66538: LD_VAR 0 5
66542: PPUSH
66543: LD_INT 11
66545: PPUSH
66546: CALL_OW 325
66550: IFFALSE 66809
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66552: LD_ADDR_VAR 0 4
66556: PUSH
66557: LD_EXP 72
66561: PUSH
66562: LD_VAR 0 2
66566: ARRAY
66567: PPUSH
66568: LD_INT 25
66570: PUSH
66571: LD_INT 16
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PPUSH
66578: CALL_OW 72
66582: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66583: LD_VAR 0 4
66587: PUSH
66588: LD_INT 6
66590: GREATEREQUAL
66591: PUSH
66592: LD_VAR 0 5
66596: PPUSH
66597: LD_INT 2
66599: PPUSH
66600: CALL_OW 325
66604: NOT
66605: OR
66606: IFFALSE 66809
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66608: LD_ADDR_VAR 0 8
66612: PUSH
66613: LD_EXP 43
66617: PUSH
66618: LD_VAR 0 2
66622: ARRAY
66623: PPUSH
66624: LD_INT 2
66626: PUSH
66627: LD_INT 30
66629: PUSH
66630: LD_INT 4
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 30
66639: PUSH
66640: LD_INT 5
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: LIST
66651: PPUSH
66652: CALL_OW 72
66656: ST_TO_ADDR
// if barracks then
66657: LD_VAR 0 8
66661: IFFALSE 66809
// begin selected := 0 ;
66663: LD_ADDR_VAR 0 7
66667: PUSH
66668: LD_INT 0
66670: ST_TO_ADDR
// for j in barracks do
66671: LD_ADDR_VAR 0 3
66675: PUSH
66676: LD_VAR 0 8
66680: PUSH
66681: FOR_IN
66682: IFFALSE 66713
// begin if UnitsInside ( j ) < 6 then
66684: LD_VAR 0 3
66688: PPUSH
66689: CALL_OW 313
66693: PUSH
66694: LD_INT 6
66696: LESS
66697: IFFALSE 66711
// begin selected := j ;
66699: LD_ADDR_VAR 0 7
66703: PUSH
66704: LD_VAR 0 3
66708: ST_TO_ADDR
// break ;
66709: GO 66713
// end ; end ;
66711: GO 66681
66713: POP
66714: POP
// if selected then
66715: LD_VAR 0 7
66719: IFFALSE 66809
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66721: LD_ADDR_VAR 0 3
66725: PUSH
66726: LD_EXP 72
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: PPUSH
66737: LD_INT 25
66739: PUSH
66740: LD_INT 12
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PPUSH
66747: CALL_OW 72
66751: PUSH
66752: FOR_IN
66753: IFFALSE 66807
// if not IsInUnit ( j ) and not HasTask ( j ) then
66755: LD_VAR 0 3
66759: PPUSH
66760: CALL_OW 310
66764: NOT
66765: PUSH
66766: LD_VAR 0 3
66770: PPUSH
66771: CALL_OW 314
66775: NOT
66776: AND
66777: IFFALSE 66805
// begin ComEnterUnit ( j , selected ) ;
66779: LD_VAR 0 3
66783: PPUSH
66784: LD_VAR 0 7
66788: PPUSH
66789: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66793: LD_VAR 0 3
66797: PPUSH
66798: LD_INT 15
66800: PPUSH
66801: CALL_OW 183
// end ;
66805: GO 66752
66807: POP
66808: POP
// end ; end ; end ; end ; end ;
66809: GO 66202
66811: POP
66812: POP
// end ;
66813: LD_VAR 0 1
66817: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66818: LD_INT 0
66820: PPUSH
66821: PPUSH
66822: PPUSH
66823: PPUSH
// if not mc_bases then
66824: LD_EXP 43
66828: NOT
66829: IFFALSE 66833
// exit ;
66831: GO 67011
// for i = 1 to mc_bases do
66833: LD_ADDR_VAR 0 2
66837: PUSH
66838: DOUBLE
66839: LD_INT 1
66841: DEC
66842: ST_TO_ADDR
66843: LD_EXP 43
66847: PUSH
66848: FOR_TO
66849: IFFALSE 67009
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
66851: LD_ADDR_VAR 0 4
66855: PUSH
66856: LD_EXP 43
66860: PUSH
66861: LD_VAR 0 2
66865: ARRAY
66866: PPUSH
66867: LD_INT 25
66869: PUSH
66870: LD_INT 9
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PPUSH
66877: CALL_OW 72
66881: ST_TO_ADDR
// if not tmp then
66882: LD_VAR 0 4
66886: NOT
66887: IFFALSE 66891
// continue ;
66889: GO 66848
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
66891: LD_EXP 69
66895: PUSH
66896: LD_VAR 0 2
66900: ARRAY
66901: PPUSH
66902: LD_INT 29
66904: PPUSH
66905: CALL_OW 325
66909: NOT
66910: PUSH
66911: LD_EXP 69
66915: PUSH
66916: LD_VAR 0 2
66920: ARRAY
66921: PPUSH
66922: LD_INT 28
66924: PPUSH
66925: CALL_OW 325
66929: NOT
66930: AND
66931: IFFALSE 66935
// continue ;
66933: GO 66848
// for j in tmp do
66935: LD_ADDR_VAR 0 3
66939: PUSH
66940: LD_VAR 0 4
66944: PUSH
66945: FOR_IN
66946: IFFALSE 67005
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66948: LD_VAR 0 3
66952: PUSH
66953: LD_EXP 46
66957: PUSH
66958: LD_VAR 0 2
66962: ARRAY
66963: PUSH
66964: LD_INT 1
66966: ARRAY
66967: IN
66968: NOT
66969: PUSH
66970: LD_VAR 0 3
66974: PUSH
66975: LD_EXP 46
66979: PUSH
66980: LD_VAR 0 2
66984: ARRAY
66985: PUSH
66986: LD_INT 2
66988: ARRAY
66989: IN
66990: NOT
66991: AND
66992: IFFALSE 67003
// ComSpaceTimeShoot ( j ) ;
66994: LD_VAR 0 3
66998: PPUSH
66999: CALL 10794 0 1
67003: GO 66945
67005: POP
67006: POP
// end ;
67007: GO 66848
67009: POP
67010: POP
// end ;
67011: LD_VAR 0 1
67015: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
67016: LD_INT 0
67018: PPUSH
67019: PPUSH
67020: PPUSH
67021: PPUSH
67022: PPUSH
67023: PPUSH
67024: PPUSH
67025: PPUSH
67026: PPUSH
// if not mc_bases then
67027: LD_EXP 43
67031: NOT
67032: IFFALSE 67036
// exit ;
67034: GO 67658
// for i = 1 to mc_bases do
67036: LD_ADDR_VAR 0 2
67040: PUSH
67041: DOUBLE
67042: LD_INT 1
67044: DEC
67045: ST_TO_ADDR
67046: LD_EXP 43
67050: PUSH
67051: FOR_TO
67052: IFFALSE 67656
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
67054: LD_EXP 78
67058: PUSH
67059: LD_VAR 0 2
67063: ARRAY
67064: NOT
67065: PUSH
67066: LD_INT 38
67068: PPUSH
67069: LD_EXP 69
67073: PUSH
67074: LD_VAR 0 2
67078: ARRAY
67079: PPUSH
67080: CALL_OW 321
67084: PUSH
67085: LD_INT 2
67087: NONEQUAL
67088: OR
67089: IFFALSE 67093
// continue ;
67091: GO 67051
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67093: LD_ADDR_VAR 0 8
67097: PUSH
67098: LD_EXP 43
67102: PUSH
67103: LD_VAR 0 2
67107: ARRAY
67108: PPUSH
67109: LD_INT 30
67111: PUSH
67112: LD_INT 34
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PPUSH
67119: CALL_OW 72
67123: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67124: LD_ADDR_VAR 0 9
67128: PUSH
67129: LD_EXP 43
67133: PUSH
67134: LD_VAR 0 2
67138: ARRAY
67139: PPUSH
67140: LD_INT 25
67142: PUSH
67143: LD_INT 4
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PPUSH
67150: CALL_OW 72
67154: PPUSH
67155: LD_INT 0
67157: PPUSH
67158: CALL 43370 0 2
67162: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67163: LD_VAR 0 9
67167: NOT
67168: PUSH
67169: LD_VAR 0 8
67173: NOT
67174: OR
67175: PUSH
67176: LD_EXP 43
67180: PUSH
67181: LD_VAR 0 2
67185: ARRAY
67186: PPUSH
67187: LD_INT 124
67189: PPUSH
67190: CALL 43370 0 2
67194: OR
67195: IFFALSE 67199
// continue ;
67197: GO 67051
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67199: LD_EXP 79
67203: PUSH
67204: LD_VAR 0 2
67208: ARRAY
67209: PUSH
67210: LD_EXP 78
67214: PUSH
67215: LD_VAR 0 2
67219: ARRAY
67220: LESS
67221: PUSH
67222: LD_EXP 79
67226: PUSH
67227: LD_VAR 0 2
67231: ARRAY
67232: PUSH
67233: LD_VAR 0 8
67237: LESS
67238: AND
67239: IFFALSE 67654
// begin tmp := sci [ 1 ] ;
67241: LD_ADDR_VAR 0 7
67245: PUSH
67246: LD_VAR 0 9
67250: PUSH
67251: LD_INT 1
67253: ARRAY
67254: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67255: LD_VAR 0 7
67259: PPUSH
67260: LD_INT 124
67262: PPUSH
67263: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67267: LD_ADDR_VAR 0 3
67271: PUSH
67272: DOUBLE
67273: LD_EXP 78
67277: PUSH
67278: LD_VAR 0 2
67282: ARRAY
67283: INC
67284: ST_TO_ADDR
67285: LD_EXP 78
67289: PUSH
67290: LD_VAR 0 2
67294: ARRAY
67295: PUSH
67296: FOR_DOWNTO
67297: IFFALSE 67640
// begin if IsInUnit ( tmp ) then
67299: LD_VAR 0 7
67303: PPUSH
67304: CALL_OW 310
67308: IFFALSE 67319
// ComExitBuilding ( tmp ) ;
67310: LD_VAR 0 7
67314: PPUSH
67315: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67319: LD_INT 35
67321: PPUSH
67322: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67326: LD_VAR 0 7
67330: PPUSH
67331: CALL_OW 310
67335: NOT
67336: PUSH
67337: LD_VAR 0 7
67341: PPUSH
67342: CALL_OW 314
67346: NOT
67347: AND
67348: IFFALSE 67319
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67350: LD_ADDR_VAR 0 6
67354: PUSH
67355: LD_VAR 0 7
67359: PPUSH
67360: CALL_OW 250
67364: PUSH
67365: LD_VAR 0 7
67369: PPUSH
67370: CALL_OW 251
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67379: LD_INT 35
67381: PPUSH
67382: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67386: LD_ADDR_VAR 0 4
67390: PUSH
67391: LD_EXP 78
67395: PUSH
67396: LD_VAR 0 2
67400: ARRAY
67401: PUSH
67402: LD_VAR 0 3
67406: ARRAY
67407: PUSH
67408: LD_INT 1
67410: ARRAY
67411: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67412: LD_ADDR_VAR 0 5
67416: PUSH
67417: LD_EXP 78
67421: PUSH
67422: LD_VAR 0 2
67426: ARRAY
67427: PUSH
67428: LD_VAR 0 3
67432: ARRAY
67433: PUSH
67434: LD_INT 2
67436: ARRAY
67437: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67438: LD_VAR 0 7
67442: PPUSH
67443: LD_INT 10
67445: PPUSH
67446: CALL 17390 0 2
67450: PUSH
67451: LD_INT 4
67453: ARRAY
67454: IFFALSE 67492
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67456: LD_VAR 0 7
67460: PPUSH
67461: LD_VAR 0 6
67465: PUSH
67466: LD_INT 1
67468: ARRAY
67469: PPUSH
67470: LD_VAR 0 6
67474: PUSH
67475: LD_INT 2
67477: ARRAY
67478: PPUSH
67479: CALL_OW 111
// wait ( 0 0$10 ) ;
67483: LD_INT 350
67485: PPUSH
67486: CALL_OW 67
// end else
67490: GO 67518
// begin ComMoveXY ( tmp , x , y ) ;
67492: LD_VAR 0 7
67496: PPUSH
67497: LD_VAR 0 4
67501: PPUSH
67502: LD_VAR 0 5
67506: PPUSH
67507: CALL_OW 111
// wait ( 0 0$3 ) ;
67511: LD_INT 105
67513: PPUSH
67514: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67518: LD_VAR 0 7
67522: PPUSH
67523: LD_VAR 0 4
67527: PPUSH
67528: LD_VAR 0 5
67532: PPUSH
67533: CALL_OW 307
67537: IFFALSE 67379
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67539: LD_VAR 0 7
67543: PPUSH
67544: LD_VAR 0 4
67548: PPUSH
67549: LD_VAR 0 5
67553: PPUSH
67554: LD_VAR 0 8
67558: PUSH
67559: LD_VAR 0 3
67563: ARRAY
67564: PPUSH
67565: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67569: LD_INT 35
67571: PPUSH
67572: CALL_OW 67
// until not HasTask ( tmp ) ;
67576: LD_VAR 0 7
67580: PPUSH
67581: CALL_OW 314
67585: NOT
67586: IFFALSE 67569
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67588: LD_ADDR_EXP 79
67592: PUSH
67593: LD_EXP 79
67597: PPUSH
67598: LD_VAR 0 2
67602: PUSH
67603: LD_EXP 79
67607: PUSH
67608: LD_VAR 0 2
67612: ARRAY
67613: PUSH
67614: LD_INT 1
67616: PLUS
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PPUSH
67622: LD_VAR 0 8
67626: PUSH
67627: LD_VAR 0 3
67631: ARRAY
67632: PPUSH
67633: CALL 14797 0 3
67637: ST_TO_ADDR
// end ;
67638: GO 67296
67640: POP
67641: POP
// MC_Reset ( i , 124 ) ;
67642: LD_VAR 0 2
67646: PPUSH
67647: LD_INT 124
67649: PPUSH
67650: CALL 51220 0 2
// end ; end ;
67654: GO 67051
67656: POP
67657: POP
// end ;
67658: LD_VAR 0 1
67662: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67663: LD_INT 0
67665: PPUSH
67666: PPUSH
67667: PPUSH
// if not mc_bases then
67668: LD_EXP 43
67672: NOT
67673: IFFALSE 67677
// exit ;
67675: GO 68283
// for i = 1 to mc_bases do
67677: LD_ADDR_VAR 0 2
67681: PUSH
67682: DOUBLE
67683: LD_INT 1
67685: DEC
67686: ST_TO_ADDR
67687: LD_EXP 43
67691: PUSH
67692: FOR_TO
67693: IFFALSE 68281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67695: LD_ADDR_VAR 0 3
67699: PUSH
67700: LD_EXP 43
67704: PUSH
67705: LD_VAR 0 2
67709: ARRAY
67710: PPUSH
67711: LD_INT 25
67713: PUSH
67714: LD_INT 4
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PPUSH
67721: CALL_OW 72
67725: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67726: LD_VAR 0 3
67730: NOT
67731: PUSH
67732: LD_EXP 80
67736: PUSH
67737: LD_VAR 0 2
67741: ARRAY
67742: NOT
67743: OR
67744: PUSH
67745: LD_EXP 43
67749: PUSH
67750: LD_VAR 0 2
67754: ARRAY
67755: PPUSH
67756: LD_INT 2
67758: PUSH
67759: LD_INT 30
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 30
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: LIST
67783: PPUSH
67784: CALL_OW 72
67788: NOT
67789: OR
67790: IFFALSE 67840
// begin if mc_deposits_finder [ i ] then
67792: LD_EXP 81
67796: PUSH
67797: LD_VAR 0 2
67801: ARRAY
67802: IFFALSE 67838
// begin MC_Reset ( i , 125 ) ;
67804: LD_VAR 0 2
67808: PPUSH
67809: LD_INT 125
67811: PPUSH
67812: CALL 51220 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67816: LD_ADDR_EXP 81
67820: PUSH
67821: LD_EXP 81
67825: PPUSH
67826: LD_VAR 0 2
67830: PPUSH
67831: EMPTY
67832: PPUSH
67833: CALL_OW 1
67837: ST_TO_ADDR
// end ; continue ;
67838: GO 67692
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
67840: LD_EXP 80
67844: PUSH
67845: LD_VAR 0 2
67849: ARRAY
67850: PUSH
67851: LD_INT 1
67853: ARRAY
67854: PUSH
67855: LD_INT 3
67857: ARRAY
67858: PUSH
67859: LD_INT 1
67861: EQUAL
67862: PUSH
67863: LD_INT 20
67865: PPUSH
67866: LD_EXP 69
67870: PUSH
67871: LD_VAR 0 2
67875: ARRAY
67876: PPUSH
67877: CALL_OW 321
67881: PUSH
67882: LD_INT 2
67884: NONEQUAL
67885: AND
67886: IFFALSE 67936
// begin if mc_deposits_finder [ i ] then
67888: LD_EXP 81
67892: PUSH
67893: LD_VAR 0 2
67897: ARRAY
67898: IFFALSE 67934
// begin MC_Reset ( i , 125 ) ;
67900: LD_VAR 0 2
67904: PPUSH
67905: LD_INT 125
67907: PPUSH
67908: CALL 51220 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67912: LD_ADDR_EXP 81
67916: PUSH
67917: LD_EXP 81
67921: PPUSH
67922: LD_VAR 0 2
67926: PPUSH
67927: EMPTY
67928: PPUSH
67929: CALL_OW 1
67933: ST_TO_ADDR
// end ; continue ;
67934: GO 67692
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
67936: LD_EXP 80
67940: PUSH
67941: LD_VAR 0 2
67945: ARRAY
67946: PUSH
67947: LD_INT 1
67949: ARRAY
67950: PUSH
67951: LD_INT 1
67953: ARRAY
67954: PPUSH
67955: LD_EXP 80
67959: PUSH
67960: LD_VAR 0 2
67964: ARRAY
67965: PUSH
67966: LD_INT 1
67968: ARRAY
67969: PUSH
67970: LD_INT 2
67972: ARRAY
67973: PPUSH
67974: LD_EXP 69
67978: PUSH
67979: LD_VAR 0 2
67983: ARRAY
67984: PPUSH
67985: CALL_OW 440
67989: IFFALSE 68032
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
67991: LD_ADDR_EXP 80
67995: PUSH
67996: LD_EXP 80
68000: PPUSH
68001: LD_VAR 0 2
68005: PPUSH
68006: LD_EXP 80
68010: PUSH
68011: LD_VAR 0 2
68015: ARRAY
68016: PPUSH
68017: LD_INT 1
68019: PPUSH
68020: CALL_OW 3
68024: PPUSH
68025: CALL_OW 1
68029: ST_TO_ADDR
68030: GO 68279
// begin if not mc_deposits_finder [ i ] then
68032: LD_EXP 81
68036: PUSH
68037: LD_VAR 0 2
68041: ARRAY
68042: NOT
68043: IFFALSE 68095
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
68045: LD_ADDR_EXP 81
68049: PUSH
68050: LD_EXP 81
68054: PPUSH
68055: LD_VAR 0 2
68059: PPUSH
68060: LD_VAR 0 3
68064: PUSH
68065: LD_INT 1
68067: ARRAY
68068: PUSH
68069: EMPTY
68070: LIST
68071: PPUSH
68072: CALL_OW 1
68076: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68077: LD_VAR 0 3
68081: PUSH
68082: LD_INT 1
68084: ARRAY
68085: PPUSH
68086: LD_INT 125
68088: PPUSH
68089: CALL_OW 109
// end else
68093: GO 68279
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68095: LD_EXP 81
68099: PUSH
68100: LD_VAR 0 2
68104: ARRAY
68105: PUSH
68106: LD_INT 1
68108: ARRAY
68109: PPUSH
68110: CALL_OW 310
68114: IFFALSE 68137
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68116: LD_EXP 81
68120: PUSH
68121: LD_VAR 0 2
68125: ARRAY
68126: PUSH
68127: LD_INT 1
68129: ARRAY
68130: PPUSH
68131: CALL_OW 122
68135: GO 68279
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68137: LD_EXP 81
68141: PUSH
68142: LD_VAR 0 2
68146: ARRAY
68147: PUSH
68148: LD_INT 1
68150: ARRAY
68151: PPUSH
68152: CALL_OW 314
68156: NOT
68157: PUSH
68158: LD_EXP 81
68162: PUSH
68163: LD_VAR 0 2
68167: ARRAY
68168: PUSH
68169: LD_INT 1
68171: ARRAY
68172: PPUSH
68173: LD_EXP 80
68177: PUSH
68178: LD_VAR 0 2
68182: ARRAY
68183: PUSH
68184: LD_INT 1
68186: ARRAY
68187: PUSH
68188: LD_INT 1
68190: ARRAY
68191: PPUSH
68192: LD_EXP 80
68196: PUSH
68197: LD_VAR 0 2
68201: ARRAY
68202: PUSH
68203: LD_INT 1
68205: ARRAY
68206: PUSH
68207: LD_INT 2
68209: ARRAY
68210: PPUSH
68211: CALL_OW 297
68215: PUSH
68216: LD_INT 6
68218: GREATER
68219: AND
68220: IFFALSE 68279
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68222: LD_EXP 81
68226: PUSH
68227: LD_VAR 0 2
68231: ARRAY
68232: PUSH
68233: LD_INT 1
68235: ARRAY
68236: PPUSH
68237: LD_EXP 80
68241: PUSH
68242: LD_VAR 0 2
68246: ARRAY
68247: PUSH
68248: LD_INT 1
68250: ARRAY
68251: PUSH
68252: LD_INT 1
68254: ARRAY
68255: PPUSH
68256: LD_EXP 80
68260: PUSH
68261: LD_VAR 0 2
68265: ARRAY
68266: PUSH
68267: LD_INT 1
68269: ARRAY
68270: PUSH
68271: LD_INT 2
68273: ARRAY
68274: PPUSH
68275: CALL_OW 111
// end ; end ; end ;
68279: GO 67692
68281: POP
68282: POP
// end ;
68283: LD_VAR 0 1
68287: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68288: LD_INT 0
68290: PPUSH
68291: PPUSH
68292: PPUSH
68293: PPUSH
68294: PPUSH
68295: PPUSH
68296: PPUSH
68297: PPUSH
68298: PPUSH
68299: PPUSH
68300: PPUSH
// if not mc_bases then
68301: LD_EXP 43
68305: NOT
68306: IFFALSE 68310
// exit ;
68308: GO 69250
// for i = 1 to mc_bases do
68310: LD_ADDR_VAR 0 2
68314: PUSH
68315: DOUBLE
68316: LD_INT 1
68318: DEC
68319: ST_TO_ADDR
68320: LD_EXP 43
68324: PUSH
68325: FOR_TO
68326: IFFALSE 69248
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68328: LD_EXP 43
68332: PUSH
68333: LD_VAR 0 2
68337: ARRAY
68338: NOT
68339: PUSH
68340: LD_EXP 66
68344: PUSH
68345: LD_VAR 0 2
68349: ARRAY
68350: OR
68351: IFFALSE 68355
// continue ;
68353: GO 68325
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68355: LD_ADDR_VAR 0 7
68359: PUSH
68360: LD_EXP 43
68364: PUSH
68365: LD_VAR 0 2
68369: ARRAY
68370: PUSH
68371: LD_INT 1
68373: ARRAY
68374: PPUSH
68375: CALL_OW 248
68379: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68380: LD_VAR 0 7
68384: PUSH
68385: LD_INT 3
68387: EQUAL
68388: PUSH
68389: LD_EXP 62
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: PUSH
68400: LD_EXP 65
68404: PUSH
68405: LD_VAR 0 2
68409: ARRAY
68410: UNION
68411: PPUSH
68412: LD_INT 33
68414: PUSH
68415: LD_INT 2
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PPUSH
68422: CALL_OW 72
68426: NOT
68427: OR
68428: IFFALSE 68432
// continue ;
68430: GO 68325
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68432: LD_ADDR_VAR 0 9
68436: PUSH
68437: LD_EXP 43
68441: PUSH
68442: LD_VAR 0 2
68446: ARRAY
68447: PPUSH
68448: LD_INT 30
68450: PUSH
68451: LD_INT 36
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PPUSH
68458: CALL_OW 72
68462: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68463: LD_ADDR_VAR 0 10
68467: PUSH
68468: LD_EXP 62
68472: PUSH
68473: LD_VAR 0 2
68477: ARRAY
68478: PPUSH
68479: LD_INT 34
68481: PUSH
68482: LD_INT 31
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PPUSH
68489: CALL_OW 72
68493: ST_TO_ADDR
// if not cts and not mcts then
68494: LD_VAR 0 9
68498: NOT
68499: PUSH
68500: LD_VAR 0 10
68504: NOT
68505: AND
68506: IFFALSE 68510
// continue ;
68508: GO 68325
// x := cts ;
68510: LD_ADDR_VAR 0 11
68514: PUSH
68515: LD_VAR 0 9
68519: ST_TO_ADDR
// if not x then
68520: LD_VAR 0 11
68524: NOT
68525: IFFALSE 68537
// x := mcts ;
68527: LD_ADDR_VAR 0 11
68531: PUSH
68532: LD_VAR 0 10
68536: ST_TO_ADDR
// if not x then
68537: LD_VAR 0 11
68541: NOT
68542: IFFALSE 68546
// continue ;
68544: GO 68325
// if mc_remote_driver [ i ] then
68546: LD_EXP 83
68550: PUSH
68551: LD_VAR 0 2
68555: ARRAY
68556: IFFALSE 68943
// for j in mc_remote_driver [ i ] do
68558: LD_ADDR_VAR 0 3
68562: PUSH
68563: LD_EXP 83
68567: PUSH
68568: LD_VAR 0 2
68572: ARRAY
68573: PUSH
68574: FOR_IN
68575: IFFALSE 68941
// begin if GetClass ( j ) <> 3 then
68577: LD_VAR 0 3
68581: PPUSH
68582: CALL_OW 257
68586: PUSH
68587: LD_INT 3
68589: NONEQUAL
68590: IFFALSE 68643
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68592: LD_ADDR_EXP 83
68596: PUSH
68597: LD_EXP 83
68601: PPUSH
68602: LD_VAR 0 2
68606: PPUSH
68607: LD_EXP 83
68611: PUSH
68612: LD_VAR 0 2
68616: ARRAY
68617: PUSH
68618: LD_VAR 0 3
68622: DIFF
68623: PPUSH
68624: CALL_OW 1
68628: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68629: LD_VAR 0 3
68633: PPUSH
68634: LD_INT 0
68636: PPUSH
68637: CALL_OW 109
// continue ;
68641: GO 68574
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68643: LD_EXP 62
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PPUSH
68654: LD_INT 34
68656: PUSH
68657: LD_INT 31
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 58
68666: PUSH
68667: EMPTY
68668: LIST
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PPUSH
68674: CALL_OW 72
68678: PUSH
68679: LD_VAR 0 3
68683: PPUSH
68684: CALL 43458 0 1
68688: NOT
68689: AND
68690: IFFALSE 68761
// begin if IsInUnit ( j ) then
68692: LD_VAR 0 3
68696: PPUSH
68697: CALL_OW 310
68701: IFFALSE 68712
// ComExitBuilding ( j ) ;
68703: LD_VAR 0 3
68707: PPUSH
68708: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68712: LD_VAR 0 3
68716: PPUSH
68717: LD_EXP 62
68721: PUSH
68722: LD_VAR 0 2
68726: ARRAY
68727: PPUSH
68728: LD_INT 34
68730: PUSH
68731: LD_INT 31
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 58
68740: PUSH
68741: EMPTY
68742: LIST
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PPUSH
68748: CALL_OW 72
68752: PUSH
68753: LD_INT 1
68755: ARRAY
68756: PPUSH
68757: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68761: LD_VAR 0 3
68765: PPUSH
68766: CALL_OW 310
68770: NOT
68771: PUSH
68772: LD_VAR 0 3
68776: PPUSH
68777: CALL_OW 310
68781: PPUSH
68782: CALL_OW 266
68786: PUSH
68787: LD_INT 36
68789: NONEQUAL
68790: PUSH
68791: LD_VAR 0 3
68795: PPUSH
68796: CALL 43458 0 1
68800: NOT
68801: AND
68802: OR
68803: IFFALSE 68939
// begin if IsInUnit ( j ) then
68805: LD_VAR 0 3
68809: PPUSH
68810: CALL_OW 310
68814: IFFALSE 68825
// ComExitBuilding ( j ) ;
68816: LD_VAR 0 3
68820: PPUSH
68821: CALL_OW 122
// ct := 0 ;
68825: LD_ADDR_VAR 0 8
68829: PUSH
68830: LD_INT 0
68832: ST_TO_ADDR
// for k in x do
68833: LD_ADDR_VAR 0 4
68837: PUSH
68838: LD_VAR 0 11
68842: PUSH
68843: FOR_IN
68844: IFFALSE 68917
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
68846: LD_VAR 0 4
68850: PPUSH
68851: CALL_OW 264
68855: PUSH
68856: LD_INT 31
68858: EQUAL
68859: PUSH
68860: LD_VAR 0 4
68864: PPUSH
68865: CALL_OW 311
68869: NOT
68870: AND
68871: PUSH
68872: LD_VAR 0 4
68876: PPUSH
68877: CALL_OW 266
68881: PUSH
68882: LD_INT 36
68884: EQUAL
68885: PUSH
68886: LD_VAR 0 4
68890: PPUSH
68891: CALL_OW 313
68895: PUSH
68896: LD_INT 3
68898: LESS
68899: AND
68900: OR
68901: IFFALSE 68915
// begin ct := k ;
68903: LD_ADDR_VAR 0 8
68907: PUSH
68908: LD_VAR 0 4
68912: ST_TO_ADDR
// break ;
68913: GO 68917
// end ;
68915: GO 68843
68917: POP
68918: POP
// if ct then
68919: LD_VAR 0 8
68923: IFFALSE 68939
// ComEnterUnit ( j , ct ) ;
68925: LD_VAR 0 3
68929: PPUSH
68930: LD_VAR 0 8
68934: PPUSH
68935: CALL_OW 120
// end ; end ;
68939: GO 68574
68941: POP
68942: POP
// places := 0 ;
68943: LD_ADDR_VAR 0 5
68947: PUSH
68948: LD_INT 0
68950: ST_TO_ADDR
// for j = 1 to x do
68951: LD_ADDR_VAR 0 3
68955: PUSH
68956: DOUBLE
68957: LD_INT 1
68959: DEC
68960: ST_TO_ADDR
68961: LD_VAR 0 11
68965: PUSH
68966: FOR_TO
68967: IFFALSE 69043
// if GetWeapon ( x [ j ] ) = ar_control_tower then
68969: LD_VAR 0 11
68973: PUSH
68974: LD_VAR 0 3
68978: ARRAY
68979: PPUSH
68980: CALL_OW 264
68984: PUSH
68985: LD_INT 31
68987: EQUAL
68988: IFFALSE 69006
// places := places + 1 else
68990: LD_ADDR_VAR 0 5
68994: PUSH
68995: LD_VAR 0 5
68999: PUSH
69000: LD_INT 1
69002: PLUS
69003: ST_TO_ADDR
69004: GO 69041
// if GetBType ( x [ j ] ) = b_control_tower then
69006: LD_VAR 0 11
69010: PUSH
69011: LD_VAR 0 3
69015: ARRAY
69016: PPUSH
69017: CALL_OW 266
69021: PUSH
69022: LD_INT 36
69024: EQUAL
69025: IFFALSE 69041
// places := places + 3 ;
69027: LD_ADDR_VAR 0 5
69031: PUSH
69032: LD_VAR 0 5
69036: PUSH
69037: LD_INT 3
69039: PLUS
69040: ST_TO_ADDR
69041: GO 68966
69043: POP
69044: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
69045: LD_VAR 0 5
69049: PUSH
69050: LD_INT 0
69052: EQUAL
69053: PUSH
69054: LD_VAR 0 5
69058: PUSH
69059: LD_EXP 83
69063: PUSH
69064: LD_VAR 0 2
69068: ARRAY
69069: LESSEQUAL
69070: OR
69071: IFFALSE 69075
// continue ;
69073: GO 68325
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69075: LD_ADDR_VAR 0 6
69079: PUSH
69080: LD_EXP 43
69084: PUSH
69085: LD_VAR 0 2
69089: ARRAY
69090: PPUSH
69091: LD_INT 25
69093: PUSH
69094: LD_INT 3
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PPUSH
69101: CALL_OW 72
69105: PUSH
69106: LD_EXP 83
69110: PUSH
69111: LD_VAR 0 2
69115: ARRAY
69116: DIFF
69117: PPUSH
69118: LD_INT 3
69120: PPUSH
69121: CALL 44358 0 2
69125: ST_TO_ADDR
// for j in tmp do
69126: LD_ADDR_VAR 0 3
69130: PUSH
69131: LD_VAR 0 6
69135: PUSH
69136: FOR_IN
69137: IFFALSE 69172
// if GetTag ( j ) > 0 then
69139: LD_VAR 0 3
69143: PPUSH
69144: CALL_OW 110
69148: PUSH
69149: LD_INT 0
69151: GREATER
69152: IFFALSE 69170
// tmp := tmp diff j ;
69154: LD_ADDR_VAR 0 6
69158: PUSH
69159: LD_VAR 0 6
69163: PUSH
69164: LD_VAR 0 3
69168: DIFF
69169: ST_TO_ADDR
69170: GO 69136
69172: POP
69173: POP
// if not tmp then
69174: LD_VAR 0 6
69178: NOT
69179: IFFALSE 69183
// continue ;
69181: GO 68325
// if places then
69183: LD_VAR 0 5
69187: IFFALSE 69246
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69189: LD_ADDR_EXP 83
69193: PUSH
69194: LD_EXP 83
69198: PPUSH
69199: LD_VAR 0 2
69203: PPUSH
69204: LD_EXP 83
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PUSH
69215: LD_VAR 0 6
69219: PUSH
69220: LD_INT 1
69222: ARRAY
69223: UNION
69224: PPUSH
69225: CALL_OW 1
69229: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69230: LD_VAR 0 6
69234: PUSH
69235: LD_INT 1
69237: ARRAY
69238: PPUSH
69239: LD_INT 126
69241: PPUSH
69242: CALL_OW 109
// end ; end ;
69246: GO 68325
69248: POP
69249: POP
// end ;
69250: LD_VAR 0 1
69254: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69255: LD_INT 0
69257: PPUSH
69258: PPUSH
69259: PPUSH
69260: PPUSH
69261: PPUSH
69262: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69263: LD_VAR 0 1
69267: NOT
69268: PUSH
69269: LD_VAR 0 2
69273: NOT
69274: OR
69275: PUSH
69276: LD_VAR 0 3
69280: NOT
69281: OR
69282: PUSH
69283: LD_VAR 0 4
69287: PUSH
69288: LD_INT 1
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: LD_INT 3
69296: PUSH
69297: LD_INT 4
69299: PUSH
69300: LD_INT 5
69302: PUSH
69303: LD_INT 8
69305: PUSH
69306: LD_INT 9
69308: PUSH
69309: LD_INT 15
69311: PUSH
69312: LD_INT 16
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: IN
69326: NOT
69327: OR
69328: IFFALSE 69332
// exit ;
69330: GO 70232
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69332: LD_ADDR_VAR 0 2
69336: PUSH
69337: LD_VAR 0 2
69341: PPUSH
69342: LD_INT 21
69344: PUSH
69345: LD_INT 3
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 24
69354: PUSH
69355: LD_INT 250
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PPUSH
69366: CALL_OW 72
69370: ST_TO_ADDR
// case class of 1 , 15 :
69371: LD_VAR 0 4
69375: PUSH
69376: LD_INT 1
69378: DOUBLE
69379: EQUAL
69380: IFTRUE 69390
69382: LD_INT 15
69384: DOUBLE
69385: EQUAL
69386: IFTRUE 69390
69388: GO 69475
69390: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69391: LD_ADDR_VAR 0 8
69395: PUSH
69396: LD_VAR 0 2
69400: PPUSH
69401: LD_INT 2
69403: PUSH
69404: LD_INT 30
69406: PUSH
69407: LD_INT 32
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 30
69416: PUSH
69417: LD_INT 31
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: LIST
69428: PPUSH
69429: CALL_OW 72
69433: PUSH
69434: LD_VAR 0 2
69438: PPUSH
69439: LD_INT 2
69441: PUSH
69442: LD_INT 30
69444: PUSH
69445: LD_INT 4
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 30
69454: PUSH
69455: LD_INT 5
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: LIST
69466: PPUSH
69467: CALL_OW 72
69471: ADD
69472: ST_TO_ADDR
69473: GO 69721
69475: LD_INT 2
69477: DOUBLE
69478: EQUAL
69479: IFTRUE 69489
69481: LD_INT 16
69483: DOUBLE
69484: EQUAL
69485: IFTRUE 69489
69487: GO 69535
69489: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69490: LD_ADDR_VAR 0 8
69494: PUSH
69495: LD_VAR 0 2
69499: PPUSH
69500: LD_INT 2
69502: PUSH
69503: LD_INT 30
69505: PUSH
69506: LD_INT 0
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 30
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: LIST
69527: PPUSH
69528: CALL_OW 72
69532: ST_TO_ADDR
69533: GO 69721
69535: LD_INT 3
69537: DOUBLE
69538: EQUAL
69539: IFTRUE 69543
69541: GO 69589
69543: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69544: LD_ADDR_VAR 0 8
69548: PUSH
69549: LD_VAR 0 2
69553: PPUSH
69554: LD_INT 2
69556: PUSH
69557: LD_INT 30
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 30
69569: PUSH
69570: LD_INT 3
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: LIST
69581: PPUSH
69582: CALL_OW 72
69586: ST_TO_ADDR
69587: GO 69721
69589: LD_INT 4
69591: DOUBLE
69592: EQUAL
69593: IFTRUE 69597
69595: GO 69654
69597: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69598: LD_ADDR_VAR 0 8
69602: PUSH
69603: LD_VAR 0 2
69607: PPUSH
69608: LD_INT 2
69610: PUSH
69611: LD_INT 30
69613: PUSH
69614: LD_INT 6
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: LD_INT 30
69623: PUSH
69624: LD_INT 7
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 30
69633: PUSH
69634: LD_INT 8
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: PPUSH
69647: CALL_OW 72
69651: ST_TO_ADDR
69652: GO 69721
69654: LD_INT 5
69656: DOUBLE
69657: EQUAL
69658: IFTRUE 69674
69660: LD_INT 8
69662: DOUBLE
69663: EQUAL
69664: IFTRUE 69674
69666: LD_INT 9
69668: DOUBLE
69669: EQUAL
69670: IFTRUE 69674
69672: GO 69720
69674: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69675: LD_ADDR_VAR 0 8
69679: PUSH
69680: LD_VAR 0 2
69684: PPUSH
69685: LD_INT 2
69687: PUSH
69688: LD_INT 30
69690: PUSH
69691: LD_INT 4
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 30
69700: PUSH
69701: LD_INT 5
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: LIST
69712: PPUSH
69713: CALL_OW 72
69717: ST_TO_ADDR
69718: GO 69721
69720: POP
// if not tmp then
69721: LD_VAR 0 8
69725: NOT
69726: IFFALSE 69730
// exit ;
69728: GO 70232
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69730: LD_VAR 0 4
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: LD_INT 15
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: IN
69745: PUSH
69746: LD_EXP 52
69750: PUSH
69751: LD_VAR 0 1
69755: ARRAY
69756: AND
69757: IFFALSE 69913
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69759: LD_ADDR_VAR 0 9
69763: PUSH
69764: LD_EXP 52
69768: PUSH
69769: LD_VAR 0 1
69773: ARRAY
69774: PUSH
69775: LD_INT 1
69777: ARRAY
69778: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69779: LD_VAR 0 9
69783: PUSH
69784: LD_EXP 53
69788: PUSH
69789: LD_VAR 0 1
69793: ARRAY
69794: IN
69795: NOT
69796: IFFALSE 69911
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69798: LD_ADDR_EXP 53
69802: PUSH
69803: LD_EXP 53
69807: PPUSH
69808: LD_VAR 0 1
69812: PUSH
69813: LD_EXP 53
69817: PUSH
69818: LD_VAR 0 1
69822: ARRAY
69823: PUSH
69824: LD_INT 1
69826: PLUS
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PPUSH
69832: LD_VAR 0 9
69836: PPUSH
69837: CALL 14797 0 3
69841: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
69842: LD_ADDR_EXP 52
69846: PUSH
69847: LD_EXP 52
69851: PPUSH
69852: LD_VAR 0 1
69856: PPUSH
69857: LD_EXP 52
69861: PUSH
69862: LD_VAR 0 1
69866: ARRAY
69867: PUSH
69868: LD_VAR 0 9
69872: DIFF
69873: PPUSH
69874: CALL_OW 1
69878: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
69879: LD_VAR 0 3
69883: PPUSH
69884: LD_EXP 53
69888: PUSH
69889: LD_VAR 0 1
69893: ARRAY
69894: PUSH
69895: LD_EXP 53
69899: PUSH
69900: LD_VAR 0 1
69904: ARRAY
69905: ARRAY
69906: PPUSH
69907: CALL_OW 120
// end ; exit ;
69911: GO 70232
// end ; if tmp > 1 then
69913: LD_VAR 0 8
69917: PUSH
69918: LD_INT 1
69920: GREATER
69921: IFFALSE 70025
// for i = 2 to tmp do
69923: LD_ADDR_VAR 0 6
69927: PUSH
69928: DOUBLE
69929: LD_INT 2
69931: DEC
69932: ST_TO_ADDR
69933: LD_VAR 0 8
69937: PUSH
69938: FOR_TO
69939: IFFALSE 70023
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
69941: LD_VAR 0 8
69945: PUSH
69946: LD_VAR 0 6
69950: ARRAY
69951: PPUSH
69952: CALL_OW 461
69956: PUSH
69957: LD_INT 6
69959: EQUAL
69960: IFFALSE 70021
// begin x := tmp [ i ] ;
69962: LD_ADDR_VAR 0 9
69966: PUSH
69967: LD_VAR 0 8
69971: PUSH
69972: LD_VAR 0 6
69976: ARRAY
69977: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
69978: LD_ADDR_VAR 0 8
69982: PUSH
69983: LD_VAR 0 8
69987: PPUSH
69988: LD_VAR 0 6
69992: PPUSH
69993: CALL_OW 3
69997: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
69998: LD_ADDR_VAR 0 8
70002: PUSH
70003: LD_VAR 0 8
70007: PPUSH
70008: LD_INT 1
70010: PPUSH
70011: LD_VAR 0 9
70015: PPUSH
70016: CALL_OW 2
70020: ST_TO_ADDR
// end ;
70021: GO 69938
70023: POP
70024: POP
// for i in tmp do
70025: LD_ADDR_VAR 0 6
70029: PUSH
70030: LD_VAR 0 8
70034: PUSH
70035: FOR_IN
70036: IFFALSE 70105
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
70038: LD_VAR 0 6
70042: PPUSH
70043: CALL_OW 313
70047: PUSH
70048: LD_INT 6
70050: LESS
70051: PUSH
70052: LD_VAR 0 6
70056: PPUSH
70057: CALL_OW 266
70061: PUSH
70062: LD_INT 31
70064: PUSH
70065: LD_INT 32
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: IN
70072: NOT
70073: AND
70074: PUSH
70075: LD_VAR 0 6
70079: PPUSH
70080: CALL_OW 313
70084: PUSH
70085: LD_INT 0
70087: EQUAL
70088: OR
70089: IFFALSE 70103
// begin j := i ;
70091: LD_ADDR_VAR 0 7
70095: PUSH
70096: LD_VAR 0 6
70100: ST_TO_ADDR
// break ;
70101: GO 70105
// end ; end ;
70103: GO 70035
70105: POP
70106: POP
// if j then
70107: LD_VAR 0 7
70111: IFFALSE 70129
// ComEnterUnit ( unit , j ) else
70113: LD_VAR 0 3
70117: PPUSH
70118: LD_VAR 0 7
70122: PPUSH
70123: CALL_OW 120
70127: GO 70232
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70129: LD_ADDR_VAR 0 10
70133: PUSH
70134: LD_VAR 0 2
70138: PPUSH
70139: LD_INT 2
70141: PUSH
70142: LD_INT 30
70144: PUSH
70145: LD_INT 0
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 30
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: LIST
70166: PPUSH
70167: CALL_OW 72
70171: ST_TO_ADDR
// if depot then
70172: LD_VAR 0 10
70176: IFFALSE 70232
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70178: LD_ADDR_VAR 0 10
70182: PUSH
70183: LD_VAR 0 10
70187: PPUSH
70188: LD_VAR 0 3
70192: PPUSH
70193: CALL_OW 74
70197: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70198: LD_VAR 0 3
70202: PPUSH
70203: LD_VAR 0 10
70207: PPUSH
70208: CALL_OW 296
70212: PUSH
70213: LD_INT 10
70215: GREATER
70216: IFFALSE 70232
// ComStandNearbyBuilding ( unit , depot ) ;
70218: LD_VAR 0 3
70222: PPUSH
70223: LD_VAR 0 10
70227: PPUSH
70228: CALL 11411 0 2
// end ; end ; end ;
70232: LD_VAR 0 5
70236: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70237: LD_INT 0
70239: PPUSH
70240: PPUSH
70241: PPUSH
70242: PPUSH
// if not mc_bases then
70243: LD_EXP 43
70247: NOT
70248: IFFALSE 70252
// exit ;
70250: GO 70491
// for i = 1 to mc_bases do
70252: LD_ADDR_VAR 0 2
70256: PUSH
70257: DOUBLE
70258: LD_INT 1
70260: DEC
70261: ST_TO_ADDR
70262: LD_EXP 43
70266: PUSH
70267: FOR_TO
70268: IFFALSE 70489
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70270: LD_ADDR_VAR 0 4
70274: PUSH
70275: LD_EXP 43
70279: PUSH
70280: LD_VAR 0 2
70284: ARRAY
70285: PPUSH
70286: LD_INT 21
70288: PUSH
70289: LD_INT 1
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PPUSH
70296: CALL_OW 72
70300: PUSH
70301: LD_EXP 72
70305: PUSH
70306: LD_VAR 0 2
70310: ARRAY
70311: UNION
70312: ST_TO_ADDR
// if not tmp then
70313: LD_VAR 0 4
70317: NOT
70318: IFFALSE 70322
// continue ;
70320: GO 70267
// for j in tmp do
70322: LD_ADDR_VAR 0 3
70326: PUSH
70327: LD_VAR 0 4
70331: PUSH
70332: FOR_IN
70333: IFFALSE 70485
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70335: LD_VAR 0 3
70339: PPUSH
70340: CALL_OW 110
70344: NOT
70345: PUSH
70346: LD_VAR 0 3
70350: PPUSH
70351: CALL_OW 314
70355: NOT
70356: AND
70357: PUSH
70358: LD_VAR 0 3
70362: PPUSH
70363: CALL_OW 311
70367: NOT
70368: AND
70369: PUSH
70370: LD_VAR 0 3
70374: PPUSH
70375: CALL_OW 310
70379: NOT
70380: AND
70381: PUSH
70382: LD_VAR 0 3
70386: PUSH
70387: LD_EXP 46
70391: PUSH
70392: LD_VAR 0 2
70396: ARRAY
70397: PUSH
70398: LD_INT 1
70400: ARRAY
70401: IN
70402: NOT
70403: AND
70404: PUSH
70405: LD_VAR 0 3
70409: PUSH
70410: LD_EXP 46
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PUSH
70421: LD_INT 2
70423: ARRAY
70424: IN
70425: NOT
70426: AND
70427: PUSH
70428: LD_VAR 0 3
70432: PUSH
70433: LD_EXP 55
70437: PUSH
70438: LD_VAR 0 2
70442: ARRAY
70443: IN
70444: NOT
70445: AND
70446: IFFALSE 70483
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70448: LD_VAR 0 2
70452: PPUSH
70453: LD_EXP 43
70457: PUSH
70458: LD_VAR 0 2
70462: ARRAY
70463: PPUSH
70464: LD_VAR 0 3
70468: PPUSH
70469: LD_VAR 0 3
70473: PPUSH
70474: CALL_OW 257
70478: PPUSH
70479: CALL 69255 0 4
// end ;
70483: GO 70332
70485: POP
70486: POP
// end ;
70487: GO 70267
70489: POP
70490: POP
// end ;
70491: LD_VAR 0 1
70495: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70496: LD_INT 0
70498: PPUSH
70499: PPUSH
70500: PPUSH
70501: PPUSH
70502: PPUSH
70503: PPUSH
// if not mc_bases [ base ] then
70504: LD_EXP 43
70508: PUSH
70509: LD_VAR 0 1
70513: ARRAY
70514: NOT
70515: IFFALSE 70519
// exit ;
70517: GO 70701
// tmp := [ ] ;
70519: LD_ADDR_VAR 0 6
70523: PUSH
70524: EMPTY
70525: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70526: LD_ADDR_VAR 0 7
70530: PUSH
70531: LD_VAR 0 3
70535: PPUSH
70536: LD_INT 0
70538: PPUSH
70539: CALL_OW 517
70543: ST_TO_ADDR
// if not list then
70544: LD_VAR 0 7
70548: NOT
70549: IFFALSE 70553
// exit ;
70551: GO 70701
// for i = 1 to amount do
70553: LD_ADDR_VAR 0 5
70557: PUSH
70558: DOUBLE
70559: LD_INT 1
70561: DEC
70562: ST_TO_ADDR
70563: LD_VAR 0 2
70567: PUSH
70568: FOR_TO
70569: IFFALSE 70649
// begin x := rand ( 1 , list [ 1 ] ) ;
70571: LD_ADDR_VAR 0 8
70575: PUSH
70576: LD_INT 1
70578: PPUSH
70579: LD_VAR 0 7
70583: PUSH
70584: LD_INT 1
70586: ARRAY
70587: PPUSH
70588: CALL_OW 12
70592: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70593: LD_ADDR_VAR 0 6
70597: PUSH
70598: LD_VAR 0 6
70602: PPUSH
70603: LD_VAR 0 5
70607: PPUSH
70608: LD_VAR 0 7
70612: PUSH
70613: LD_INT 1
70615: ARRAY
70616: PUSH
70617: LD_VAR 0 8
70621: ARRAY
70622: PUSH
70623: LD_VAR 0 7
70627: PUSH
70628: LD_INT 2
70630: ARRAY
70631: PUSH
70632: LD_VAR 0 8
70636: ARRAY
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PPUSH
70642: CALL_OW 1
70646: ST_TO_ADDR
// end ;
70647: GO 70568
70649: POP
70650: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70651: LD_ADDR_EXP 56
70655: PUSH
70656: LD_EXP 56
70660: PPUSH
70661: LD_VAR 0 1
70665: PPUSH
70666: LD_VAR 0 6
70670: PPUSH
70671: CALL_OW 1
70675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70676: LD_ADDR_EXP 58
70680: PUSH
70681: LD_EXP 58
70685: PPUSH
70686: LD_VAR 0 1
70690: PPUSH
70691: LD_VAR 0 3
70695: PPUSH
70696: CALL_OW 1
70700: ST_TO_ADDR
// end ;
70701: LD_VAR 0 4
70705: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70706: LD_INT 0
70708: PPUSH
// if not mc_bases [ base ] then
70709: LD_EXP 43
70713: PUSH
70714: LD_VAR 0 1
70718: ARRAY
70719: NOT
70720: IFFALSE 70724
// exit ;
70722: GO 70749
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70724: LD_ADDR_EXP 48
70728: PUSH
70729: LD_EXP 48
70733: PPUSH
70734: LD_VAR 0 1
70738: PPUSH
70739: LD_VAR 0 2
70743: PPUSH
70744: CALL_OW 1
70748: ST_TO_ADDR
// end ;
70749: LD_VAR 0 3
70753: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70754: LD_INT 0
70756: PPUSH
// if not mc_bases [ base ] then
70757: LD_EXP 43
70761: PUSH
70762: LD_VAR 0 1
70766: ARRAY
70767: NOT
70768: IFFALSE 70772
// exit ;
70770: GO 70809
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70772: LD_ADDR_EXP 48
70776: PUSH
70777: LD_EXP 48
70781: PPUSH
70782: LD_VAR 0 1
70786: PPUSH
70787: LD_EXP 48
70791: PUSH
70792: LD_VAR 0 1
70796: ARRAY
70797: PUSH
70798: LD_VAR 0 2
70802: UNION
70803: PPUSH
70804: CALL_OW 1
70808: ST_TO_ADDR
// end ;
70809: LD_VAR 0 3
70813: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70814: LD_INT 0
70816: PPUSH
// if not mc_bases [ base ] then
70817: LD_EXP 43
70821: PUSH
70822: LD_VAR 0 1
70826: ARRAY
70827: NOT
70828: IFFALSE 70832
// exit ;
70830: GO 70857
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70832: LD_ADDR_EXP 64
70836: PUSH
70837: LD_EXP 64
70841: PPUSH
70842: LD_VAR 0 1
70846: PPUSH
70847: LD_VAR 0 2
70851: PPUSH
70852: CALL_OW 1
70856: ST_TO_ADDR
// end ;
70857: LD_VAR 0 3
70861: RET
// export function MC_InsertProduceList ( base , components ) ; begin
70862: LD_INT 0
70864: PPUSH
// if not mc_bases [ base ] then
70865: LD_EXP 43
70869: PUSH
70870: LD_VAR 0 1
70874: ARRAY
70875: NOT
70876: IFFALSE 70880
// exit ;
70878: GO 70917
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
70880: LD_ADDR_EXP 64
70884: PUSH
70885: LD_EXP 64
70889: PPUSH
70890: LD_VAR 0 1
70894: PPUSH
70895: LD_EXP 64
70899: PUSH
70900: LD_VAR 0 1
70904: ARRAY
70905: PUSH
70906: LD_VAR 0 2
70910: ADD
70911: PPUSH
70912: CALL_OW 1
70916: ST_TO_ADDR
// end ;
70917: LD_VAR 0 3
70921: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
70922: LD_INT 0
70924: PPUSH
// if not mc_bases [ base ] then
70925: LD_EXP 43
70929: PUSH
70930: LD_VAR 0 1
70934: ARRAY
70935: NOT
70936: IFFALSE 70940
// exit ;
70938: GO 70994
// mc_defender := Replace ( mc_defender , base , deflist ) ;
70940: LD_ADDR_EXP 65
70944: PUSH
70945: LD_EXP 65
70949: PPUSH
70950: LD_VAR 0 1
70954: PPUSH
70955: LD_VAR 0 2
70959: PPUSH
70960: CALL_OW 1
70964: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
70965: LD_ADDR_EXP 54
70969: PUSH
70970: LD_EXP 54
70974: PPUSH
70975: LD_VAR 0 1
70979: PPUSH
70980: LD_VAR 0 2
70984: PUSH
70985: LD_INT 0
70987: PLUS
70988: PPUSH
70989: CALL_OW 1
70993: ST_TO_ADDR
// end ;
70994: LD_VAR 0 3
70998: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
70999: LD_INT 0
71001: PPUSH
// if not mc_bases [ base ] then
71002: LD_EXP 43
71006: PUSH
71007: LD_VAR 0 1
71011: ARRAY
71012: NOT
71013: IFFALSE 71017
// exit ;
71015: GO 71042
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
71017: LD_ADDR_EXP 54
71021: PUSH
71022: LD_EXP 54
71026: PPUSH
71027: LD_VAR 0 1
71031: PPUSH
71032: LD_VAR 0 2
71036: PPUSH
71037: CALL_OW 1
71041: ST_TO_ADDR
// end ;
71042: LD_VAR 0 3
71046: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
71047: LD_INT 0
71049: PPUSH
71050: PPUSH
71051: PPUSH
71052: PPUSH
// if not mc_bases [ base ] then
71053: LD_EXP 43
71057: PUSH
71058: LD_VAR 0 1
71062: ARRAY
71063: NOT
71064: IFFALSE 71068
// exit ;
71066: GO 71133
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
71068: LD_ADDR_EXP 63
71072: PUSH
71073: LD_EXP 63
71077: PPUSH
71078: LD_VAR 0 1
71082: PUSH
71083: LD_EXP 63
71087: PUSH
71088: LD_VAR 0 1
71092: ARRAY
71093: PUSH
71094: LD_INT 1
71096: PLUS
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PPUSH
71102: LD_VAR 0 1
71106: PUSH
71107: LD_VAR 0 2
71111: PUSH
71112: LD_VAR 0 3
71116: PUSH
71117: LD_VAR 0 4
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: PPUSH
71128: CALL 14797 0 3
71132: ST_TO_ADDR
// end ;
71133: LD_VAR 0 5
71137: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71138: LD_INT 0
71140: PPUSH
// if not mc_bases [ base ] then
71141: LD_EXP 43
71145: PUSH
71146: LD_VAR 0 1
71150: ARRAY
71151: NOT
71152: IFFALSE 71156
// exit ;
71154: GO 71181
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71156: LD_ADDR_EXP 80
71160: PUSH
71161: LD_EXP 80
71165: PPUSH
71166: LD_VAR 0 1
71170: PPUSH
71171: LD_VAR 0 2
71175: PPUSH
71176: CALL_OW 1
71180: ST_TO_ADDR
// end ;
71181: LD_VAR 0 3
71185: RET
// export function MC_GetMinesField ( base ) ; begin
71186: LD_INT 0
71188: PPUSH
// result := mc_mines [ base ] ;
71189: LD_ADDR_VAR 0 2
71193: PUSH
71194: LD_EXP 56
71198: PUSH
71199: LD_VAR 0 1
71203: ARRAY
71204: ST_TO_ADDR
// end ;
71205: LD_VAR 0 2
71209: RET
// export function MC_GetProduceList ( base ) ; begin
71210: LD_INT 0
71212: PPUSH
// result := mc_produce [ base ] ;
71213: LD_ADDR_VAR 0 2
71217: PUSH
71218: LD_EXP 64
71222: PUSH
71223: LD_VAR 0 1
71227: ARRAY
71228: ST_TO_ADDR
// end ;
71229: LD_VAR 0 2
71233: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71234: LD_INT 0
71236: PPUSH
71237: PPUSH
// if not mc_bases then
71238: LD_EXP 43
71242: NOT
71243: IFFALSE 71247
// exit ;
71245: GO 71312
// if mc_bases [ base ] then
71247: LD_EXP 43
71251: PUSH
71252: LD_VAR 0 1
71256: ARRAY
71257: IFFALSE 71312
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71259: LD_ADDR_VAR 0 3
71263: PUSH
71264: LD_EXP 43
71268: PUSH
71269: LD_VAR 0 1
71273: ARRAY
71274: PPUSH
71275: LD_INT 30
71277: PUSH
71278: LD_VAR 0 2
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PPUSH
71287: CALL_OW 72
71291: ST_TO_ADDR
// if result then
71292: LD_VAR 0 3
71296: IFFALSE 71312
// result := result [ 1 ] ;
71298: LD_ADDR_VAR 0 3
71302: PUSH
71303: LD_VAR 0 3
71307: PUSH
71308: LD_INT 1
71310: ARRAY
71311: ST_TO_ADDR
// end ; end ;
71312: LD_VAR 0 3
71316: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71317: LD_INT 0
71319: PPUSH
71320: PPUSH
// if not mc_bases then
71321: LD_EXP 43
71325: NOT
71326: IFFALSE 71330
// exit ;
71328: GO 71375
// if mc_bases [ base ] then
71330: LD_EXP 43
71334: PUSH
71335: LD_VAR 0 1
71339: ARRAY
71340: IFFALSE 71375
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71342: LD_ADDR_VAR 0 3
71346: PUSH
71347: LD_EXP 43
71351: PUSH
71352: LD_VAR 0 1
71356: ARRAY
71357: PPUSH
71358: LD_INT 30
71360: PUSH
71361: LD_VAR 0 2
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PPUSH
71370: CALL_OW 72
71374: ST_TO_ADDR
// end ;
71375: LD_VAR 0 3
71379: RET
// export function MC_SetTame ( base , area ) ; begin
71380: LD_INT 0
71382: PPUSH
// if not mc_bases or not base then
71383: LD_EXP 43
71387: NOT
71388: PUSH
71389: LD_VAR 0 1
71393: NOT
71394: OR
71395: IFFALSE 71399
// exit ;
71397: GO 71424
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71399: LD_ADDR_EXP 71
71403: PUSH
71404: LD_EXP 71
71408: PPUSH
71409: LD_VAR 0 1
71413: PPUSH
71414: LD_VAR 0 2
71418: PPUSH
71419: CALL_OW 1
71423: ST_TO_ADDR
// end ;
71424: LD_VAR 0 3
71428: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71429: LD_INT 0
71431: PPUSH
71432: PPUSH
// if not mc_bases or not base then
71433: LD_EXP 43
71437: NOT
71438: PUSH
71439: LD_VAR 0 1
71443: NOT
71444: OR
71445: IFFALSE 71449
// exit ;
71447: GO 71551
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71449: LD_ADDR_VAR 0 4
71453: PUSH
71454: LD_EXP 43
71458: PUSH
71459: LD_VAR 0 1
71463: ARRAY
71464: PPUSH
71465: LD_INT 30
71467: PUSH
71468: LD_VAR 0 2
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PPUSH
71477: CALL_OW 72
71481: ST_TO_ADDR
// if not tmp then
71482: LD_VAR 0 4
71486: NOT
71487: IFFALSE 71491
// exit ;
71489: GO 71551
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71491: LD_ADDR_EXP 75
71495: PUSH
71496: LD_EXP 75
71500: PPUSH
71501: LD_VAR 0 1
71505: PPUSH
71506: LD_EXP 75
71510: PUSH
71511: LD_VAR 0 1
71515: ARRAY
71516: PPUSH
71517: LD_EXP 75
71521: PUSH
71522: LD_VAR 0 1
71526: ARRAY
71527: PUSH
71528: LD_INT 1
71530: PLUS
71531: PPUSH
71532: LD_VAR 0 4
71536: PUSH
71537: LD_INT 1
71539: ARRAY
71540: PPUSH
71541: CALL_OW 2
71545: PPUSH
71546: CALL_OW 1
71550: ST_TO_ADDR
// end ;
71551: LD_VAR 0 3
71555: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71556: LD_INT 0
71558: PPUSH
71559: PPUSH
// if not mc_bases or not base or not kinds then
71560: LD_EXP 43
71564: NOT
71565: PUSH
71566: LD_VAR 0 1
71570: NOT
71571: OR
71572: PUSH
71573: LD_VAR 0 2
71577: NOT
71578: OR
71579: IFFALSE 71583
// exit ;
71581: GO 71644
// for i in kinds do
71583: LD_ADDR_VAR 0 4
71587: PUSH
71588: LD_VAR 0 2
71592: PUSH
71593: FOR_IN
71594: IFFALSE 71642
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71596: LD_ADDR_EXP 77
71600: PUSH
71601: LD_EXP 77
71605: PPUSH
71606: LD_VAR 0 1
71610: PUSH
71611: LD_EXP 77
71615: PUSH
71616: LD_VAR 0 1
71620: ARRAY
71621: PUSH
71622: LD_INT 1
71624: PLUS
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PPUSH
71630: LD_VAR 0 4
71634: PPUSH
71635: CALL 14797 0 3
71639: ST_TO_ADDR
71640: GO 71593
71642: POP
71643: POP
// end ;
71644: LD_VAR 0 3
71648: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71649: LD_INT 0
71651: PPUSH
// if not mc_bases or not base or not areas then
71652: LD_EXP 43
71656: NOT
71657: PUSH
71658: LD_VAR 0 1
71662: NOT
71663: OR
71664: PUSH
71665: LD_VAR 0 2
71669: NOT
71670: OR
71671: IFFALSE 71675
// exit ;
71673: GO 71700
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71675: LD_ADDR_EXP 61
71679: PUSH
71680: LD_EXP 61
71684: PPUSH
71685: LD_VAR 0 1
71689: PPUSH
71690: LD_VAR 0 2
71694: PPUSH
71695: CALL_OW 1
71699: ST_TO_ADDR
// end ;
71700: LD_VAR 0 3
71704: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71705: LD_INT 0
71707: PPUSH
// if not mc_bases or not base or not teleports_exit then
71708: LD_EXP 43
71712: NOT
71713: PUSH
71714: LD_VAR 0 1
71718: NOT
71719: OR
71720: PUSH
71721: LD_VAR 0 2
71725: NOT
71726: OR
71727: IFFALSE 71731
// exit ;
71729: GO 71756
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71731: LD_ADDR_EXP 78
71735: PUSH
71736: LD_EXP 78
71740: PPUSH
71741: LD_VAR 0 1
71745: PPUSH
71746: LD_VAR 0 2
71750: PPUSH
71751: CALL_OW 1
71755: ST_TO_ADDR
// end ;
71756: LD_VAR 0 3
71760: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71761: LD_INT 0
71763: PPUSH
71764: PPUSH
71765: PPUSH
// if not mc_bases or not base or not ext_list then
71766: LD_EXP 43
71770: NOT
71771: PUSH
71772: LD_VAR 0 1
71776: NOT
71777: OR
71778: PUSH
71779: LD_VAR 0 5
71783: NOT
71784: OR
71785: IFFALSE 71789
// exit ;
71787: GO 71962
// tmp := GetFacExtXYD ( x , y , d ) ;
71789: LD_ADDR_VAR 0 8
71793: PUSH
71794: LD_VAR 0 2
71798: PPUSH
71799: LD_VAR 0 3
71803: PPUSH
71804: LD_VAR 0 4
71808: PPUSH
71809: CALL 43488 0 3
71813: ST_TO_ADDR
// if not tmp then
71814: LD_VAR 0 8
71818: NOT
71819: IFFALSE 71823
// exit ;
71821: GO 71962
// for i in tmp do
71823: LD_ADDR_VAR 0 7
71827: PUSH
71828: LD_VAR 0 8
71832: PUSH
71833: FOR_IN
71834: IFFALSE 71960
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
71836: LD_ADDR_EXP 48
71840: PUSH
71841: LD_EXP 48
71845: PPUSH
71846: LD_VAR 0 1
71850: PPUSH
71851: LD_EXP 48
71855: PUSH
71856: LD_VAR 0 1
71860: ARRAY
71861: PPUSH
71862: LD_EXP 48
71866: PUSH
71867: LD_VAR 0 1
71871: ARRAY
71872: PUSH
71873: LD_INT 1
71875: PLUS
71876: PPUSH
71877: LD_VAR 0 5
71881: PUSH
71882: LD_INT 1
71884: ARRAY
71885: PUSH
71886: LD_VAR 0 7
71890: PUSH
71891: LD_INT 1
71893: ARRAY
71894: PUSH
71895: LD_VAR 0 7
71899: PUSH
71900: LD_INT 2
71902: ARRAY
71903: PUSH
71904: LD_VAR 0 7
71908: PUSH
71909: LD_INT 3
71911: ARRAY
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: LIST
71917: LIST
71918: PPUSH
71919: CALL_OW 2
71923: PPUSH
71924: CALL_OW 1
71928: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
71929: LD_ADDR_VAR 0 5
71933: PUSH
71934: LD_VAR 0 5
71938: PPUSH
71939: LD_INT 1
71941: PPUSH
71942: CALL_OW 3
71946: ST_TO_ADDR
// if not ext_list then
71947: LD_VAR 0 5
71951: NOT
71952: IFFALSE 71958
// exit ;
71954: POP
71955: POP
71956: GO 71962
// end ;
71958: GO 71833
71960: POP
71961: POP
// end ;
71962: LD_VAR 0 6
71966: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
71967: LD_INT 0
71969: PPUSH
// if not mc_bases or not base or not weapon_list then
71970: LD_EXP 43
71974: NOT
71975: PUSH
71976: LD_VAR 0 1
71980: NOT
71981: OR
71982: PUSH
71983: LD_VAR 0 2
71987: NOT
71988: OR
71989: IFFALSE 71993
// exit ;
71991: GO 72018
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
71993: LD_ADDR_EXP 82
71997: PUSH
71998: LD_EXP 82
72002: PPUSH
72003: LD_VAR 0 1
72007: PPUSH
72008: LD_VAR 0 2
72012: PPUSH
72013: CALL_OW 1
72017: ST_TO_ADDR
// end ;
72018: LD_VAR 0 3
72022: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
72023: LD_INT 0
72025: PPUSH
// if not mc_bases or not base or not tech_list then
72026: LD_EXP 43
72030: NOT
72031: PUSH
72032: LD_VAR 0 1
72036: NOT
72037: OR
72038: PUSH
72039: LD_VAR 0 2
72043: NOT
72044: OR
72045: IFFALSE 72049
// exit ;
72047: GO 72074
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
72049: LD_ADDR_EXP 70
72053: PUSH
72054: LD_EXP 70
72058: PPUSH
72059: LD_VAR 0 1
72063: PPUSH
72064: LD_VAR 0 2
72068: PPUSH
72069: CALL_OW 1
72073: ST_TO_ADDR
// end ;
72074: LD_VAR 0 3
72078: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72079: LD_INT 0
72081: PPUSH
// if not mc_bases or not parking_area or not base then
72082: LD_EXP 43
72086: NOT
72087: PUSH
72088: LD_VAR 0 2
72092: NOT
72093: OR
72094: PUSH
72095: LD_VAR 0 1
72099: NOT
72100: OR
72101: IFFALSE 72105
// exit ;
72103: GO 72130
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72105: LD_ADDR_EXP 67
72109: PUSH
72110: LD_EXP 67
72114: PPUSH
72115: LD_VAR 0 1
72119: PPUSH
72120: LD_VAR 0 2
72124: PPUSH
72125: CALL_OW 1
72129: ST_TO_ADDR
// end ;
72130: LD_VAR 0 3
72134: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72135: LD_INT 0
72137: PPUSH
// if not mc_bases or not base or not scan_area then
72138: LD_EXP 43
72142: NOT
72143: PUSH
72144: LD_VAR 0 1
72148: NOT
72149: OR
72150: PUSH
72151: LD_VAR 0 2
72155: NOT
72156: OR
72157: IFFALSE 72161
// exit ;
72159: GO 72186
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72161: LD_ADDR_EXP 68
72165: PUSH
72166: LD_EXP 68
72170: PPUSH
72171: LD_VAR 0 1
72175: PPUSH
72176: LD_VAR 0 2
72180: PPUSH
72181: CALL_OW 1
72185: ST_TO_ADDR
// end ;
72186: LD_VAR 0 3
72190: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72191: LD_INT 0
72193: PPUSH
72194: PPUSH
// if not mc_bases or not base then
72195: LD_EXP 43
72199: NOT
72200: PUSH
72201: LD_VAR 0 1
72205: NOT
72206: OR
72207: IFFALSE 72211
// exit ;
72209: GO 72275
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72211: LD_ADDR_VAR 0 3
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 2
72221: PUSH
72222: LD_INT 3
72224: PUSH
72225: LD_INT 4
72227: PUSH
72228: LD_INT 11
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72238: LD_ADDR_EXP 70
72242: PUSH
72243: LD_EXP 70
72247: PPUSH
72248: LD_VAR 0 1
72252: PPUSH
72253: LD_EXP 70
72257: PUSH
72258: LD_VAR 0 1
72262: ARRAY
72263: PUSH
72264: LD_VAR 0 3
72268: DIFF
72269: PPUSH
72270: CALL_OW 1
72274: ST_TO_ADDR
// end ;
72275: LD_VAR 0 2
72279: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72280: LD_INT 0
72282: PPUSH
// result := mc_vehicles [ base ] ;
72283: LD_ADDR_VAR 0 3
72287: PUSH
72288: LD_EXP 62
72292: PUSH
72293: LD_VAR 0 1
72297: ARRAY
72298: ST_TO_ADDR
// if onlyCombat then
72299: LD_VAR 0 2
72303: IFFALSE 72481
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72305: LD_ADDR_VAR 0 3
72309: PUSH
72310: LD_VAR 0 3
72314: PUSH
72315: LD_VAR 0 3
72319: PPUSH
72320: LD_INT 2
72322: PUSH
72323: LD_INT 34
72325: PUSH
72326: LD_INT 12
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 34
72335: PUSH
72336: LD_INT 51
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 34
72345: PUSH
72346: LD_EXP 87
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 34
72357: PUSH
72358: LD_INT 32
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 34
72367: PUSH
72368: LD_INT 13
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 34
72377: PUSH
72378: LD_INT 52
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 34
72387: PUSH
72388: LD_EXP 92
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 34
72399: PUSH
72400: LD_INT 14
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 34
72409: PUSH
72410: LD_INT 53
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 34
72419: PUSH
72420: LD_EXP 86
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 34
72431: PUSH
72432: LD_INT 31
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 34
72441: PUSH
72442: LD_INT 48
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 34
72451: PUSH
72452: LD_INT 8
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: PPUSH
72475: CALL_OW 72
72479: DIFF
72480: ST_TO_ADDR
// end ; end_of_file
72481: LD_VAR 0 3
72485: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72486: LD_INT 0
72488: PPUSH
72489: PPUSH
72490: PPUSH
// if not mc_bases or not skirmish then
72491: LD_EXP 43
72495: NOT
72496: PUSH
72497: LD_EXP 41
72501: NOT
72502: OR
72503: IFFALSE 72507
// exit ;
72505: GO 72672
// for i = 1 to mc_bases do
72507: LD_ADDR_VAR 0 4
72511: PUSH
72512: DOUBLE
72513: LD_INT 1
72515: DEC
72516: ST_TO_ADDR
72517: LD_EXP 43
72521: PUSH
72522: FOR_TO
72523: IFFALSE 72670
// begin if sci in mc_bases [ i ] then
72525: LD_VAR 0 2
72529: PUSH
72530: LD_EXP 43
72534: PUSH
72535: LD_VAR 0 4
72539: ARRAY
72540: IN
72541: IFFALSE 72668
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72543: LD_ADDR_EXP 72
72547: PUSH
72548: LD_EXP 72
72552: PPUSH
72553: LD_VAR 0 4
72557: PUSH
72558: LD_EXP 72
72562: PUSH
72563: LD_VAR 0 4
72567: ARRAY
72568: PUSH
72569: LD_INT 1
72571: PLUS
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PPUSH
72577: LD_VAR 0 1
72581: PPUSH
72582: CALL 14797 0 3
72586: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72587: LD_ADDR_VAR 0 5
72591: PUSH
72592: LD_EXP 43
72596: PUSH
72597: LD_VAR 0 4
72601: ARRAY
72602: PPUSH
72603: LD_INT 2
72605: PUSH
72606: LD_INT 30
72608: PUSH
72609: LD_INT 0
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 30
72618: PUSH
72619: LD_INT 1
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: LIST
72630: PPUSH
72631: CALL_OW 72
72635: PPUSH
72636: LD_VAR 0 1
72640: PPUSH
72641: CALL_OW 74
72645: ST_TO_ADDR
// if tmp then
72646: LD_VAR 0 5
72650: IFFALSE 72666
// ComStandNearbyBuilding ( ape , tmp ) ;
72652: LD_VAR 0 1
72656: PPUSH
72657: LD_VAR 0 5
72661: PPUSH
72662: CALL 11411 0 2
// break ;
72666: GO 72670
// end ; end ;
72668: GO 72522
72670: POP
72671: POP
// end ;
72672: LD_VAR 0 3
72676: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72677: LD_INT 0
72679: PPUSH
72680: PPUSH
72681: PPUSH
// if not mc_bases or not skirmish then
72682: LD_EXP 43
72686: NOT
72687: PUSH
72688: LD_EXP 41
72692: NOT
72693: OR
72694: IFFALSE 72698
// exit ;
72696: GO 72787
// for i = 1 to mc_bases do
72698: LD_ADDR_VAR 0 4
72702: PUSH
72703: DOUBLE
72704: LD_INT 1
72706: DEC
72707: ST_TO_ADDR
72708: LD_EXP 43
72712: PUSH
72713: FOR_TO
72714: IFFALSE 72785
// begin if building in mc_busy_turret_list [ i ] then
72716: LD_VAR 0 1
72720: PUSH
72721: LD_EXP 53
72725: PUSH
72726: LD_VAR 0 4
72730: ARRAY
72731: IN
72732: IFFALSE 72783
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72734: LD_ADDR_VAR 0 5
72738: PUSH
72739: LD_EXP 53
72743: PUSH
72744: LD_VAR 0 4
72748: ARRAY
72749: PUSH
72750: LD_VAR 0 1
72754: DIFF
72755: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72756: LD_ADDR_EXP 53
72760: PUSH
72761: LD_EXP 53
72765: PPUSH
72766: LD_VAR 0 4
72770: PPUSH
72771: LD_VAR 0 5
72775: PPUSH
72776: CALL_OW 1
72780: ST_TO_ADDR
// break ;
72781: GO 72785
// end ; end ;
72783: GO 72713
72785: POP
72786: POP
// end ;
72787: LD_VAR 0 3
72791: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72792: LD_INT 0
72794: PPUSH
72795: PPUSH
72796: PPUSH
// if not mc_bases or not skirmish then
72797: LD_EXP 43
72801: NOT
72802: PUSH
72803: LD_EXP 41
72807: NOT
72808: OR
72809: IFFALSE 72813
// exit ;
72811: GO 73012
// for i = 1 to mc_bases do
72813: LD_ADDR_VAR 0 5
72817: PUSH
72818: DOUBLE
72819: LD_INT 1
72821: DEC
72822: ST_TO_ADDR
72823: LD_EXP 43
72827: PUSH
72828: FOR_TO
72829: IFFALSE 73010
// if building in mc_bases [ i ] then
72831: LD_VAR 0 1
72835: PUSH
72836: LD_EXP 43
72840: PUSH
72841: LD_VAR 0 5
72845: ARRAY
72846: IN
72847: IFFALSE 73008
// begin tmp := mc_bases [ i ] diff building ;
72849: LD_ADDR_VAR 0 6
72853: PUSH
72854: LD_EXP 43
72858: PUSH
72859: LD_VAR 0 5
72863: ARRAY
72864: PUSH
72865: LD_VAR 0 1
72869: DIFF
72870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
72871: LD_ADDR_EXP 43
72875: PUSH
72876: LD_EXP 43
72880: PPUSH
72881: LD_VAR 0 5
72885: PPUSH
72886: LD_VAR 0 6
72890: PPUSH
72891: CALL_OW 1
72895: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
72896: LD_VAR 0 1
72900: PUSH
72901: LD_EXP 51
72905: PUSH
72906: LD_VAR 0 5
72910: ARRAY
72911: IN
72912: IFFALSE 72951
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
72914: LD_ADDR_EXP 51
72918: PUSH
72919: LD_EXP 51
72923: PPUSH
72924: LD_VAR 0 5
72928: PPUSH
72929: LD_EXP 51
72933: PUSH
72934: LD_VAR 0 5
72938: ARRAY
72939: PUSH
72940: LD_VAR 0 1
72944: DIFF
72945: PPUSH
72946: CALL_OW 1
72950: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
72951: LD_VAR 0 1
72955: PUSH
72956: LD_EXP 52
72960: PUSH
72961: LD_VAR 0 5
72965: ARRAY
72966: IN
72967: IFFALSE 73006
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
72969: LD_ADDR_EXP 52
72973: PUSH
72974: LD_EXP 52
72978: PPUSH
72979: LD_VAR 0 5
72983: PPUSH
72984: LD_EXP 52
72988: PUSH
72989: LD_VAR 0 5
72993: ARRAY
72994: PUSH
72995: LD_VAR 0 1
72999: DIFF
73000: PPUSH
73001: CALL_OW 1
73005: ST_TO_ADDR
// break ;
73006: GO 73010
// end ;
73008: GO 72828
73010: POP
73011: POP
// end ;
73012: LD_VAR 0 4
73016: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
73017: LD_INT 0
73019: PPUSH
73020: PPUSH
73021: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
73022: LD_EXP 43
73026: NOT
73027: PUSH
73028: LD_EXP 41
73032: NOT
73033: OR
73034: PUSH
73035: LD_VAR 0 3
73039: PUSH
73040: LD_EXP 69
73044: IN
73045: NOT
73046: OR
73047: IFFALSE 73051
// exit ;
73049: GO 73174
// for i = 1 to mc_vehicles do
73051: LD_ADDR_VAR 0 6
73055: PUSH
73056: DOUBLE
73057: LD_INT 1
73059: DEC
73060: ST_TO_ADDR
73061: LD_EXP 62
73065: PUSH
73066: FOR_TO
73067: IFFALSE 73172
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
73069: LD_VAR 0 2
73073: PUSH
73074: LD_EXP 62
73078: PUSH
73079: LD_VAR 0 6
73083: ARRAY
73084: IN
73085: PUSH
73086: LD_VAR 0 1
73090: PUSH
73091: LD_EXP 62
73095: PUSH
73096: LD_VAR 0 6
73100: ARRAY
73101: IN
73102: OR
73103: IFFALSE 73170
// begin tmp := mc_vehicles [ i ] diff old ;
73105: LD_ADDR_VAR 0 7
73109: PUSH
73110: LD_EXP 62
73114: PUSH
73115: LD_VAR 0 6
73119: ARRAY
73120: PUSH
73121: LD_VAR 0 2
73125: DIFF
73126: ST_TO_ADDR
// tmp := tmp diff new ;
73127: LD_ADDR_VAR 0 7
73131: PUSH
73132: LD_VAR 0 7
73136: PUSH
73137: LD_VAR 0 1
73141: DIFF
73142: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73143: LD_ADDR_EXP 62
73147: PUSH
73148: LD_EXP 62
73152: PPUSH
73153: LD_VAR 0 6
73157: PPUSH
73158: LD_VAR 0 7
73162: PPUSH
73163: CALL_OW 1
73167: ST_TO_ADDR
// break ;
73168: GO 73172
// end ;
73170: GO 73066
73172: POP
73173: POP
// end ;
73174: LD_VAR 0 5
73178: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73179: LD_INT 0
73181: PPUSH
73182: PPUSH
73183: PPUSH
73184: PPUSH
// if not mc_bases or not skirmish then
73185: LD_EXP 43
73189: NOT
73190: PUSH
73191: LD_EXP 41
73195: NOT
73196: OR
73197: IFFALSE 73201
// exit ;
73199: GO 73584
// side := GetSide ( vehicle ) ;
73201: LD_ADDR_VAR 0 5
73205: PUSH
73206: LD_VAR 0 1
73210: PPUSH
73211: CALL_OW 255
73215: ST_TO_ADDR
// for i = 1 to mc_bases do
73216: LD_ADDR_VAR 0 4
73220: PUSH
73221: DOUBLE
73222: LD_INT 1
73224: DEC
73225: ST_TO_ADDR
73226: LD_EXP 43
73230: PUSH
73231: FOR_TO
73232: IFFALSE 73582
// begin if factory in mc_bases [ i ] then
73234: LD_VAR 0 2
73238: PUSH
73239: LD_EXP 43
73243: PUSH
73244: LD_VAR 0 4
73248: ARRAY
73249: IN
73250: IFFALSE 73580
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73252: LD_EXP 65
73256: PUSH
73257: LD_VAR 0 4
73261: ARRAY
73262: PUSH
73263: LD_EXP 54
73267: PUSH
73268: LD_VAR 0 4
73272: ARRAY
73273: LESS
73274: PUSH
73275: LD_VAR 0 1
73279: PPUSH
73280: CALL_OW 264
73284: PUSH
73285: LD_INT 31
73287: PUSH
73288: LD_INT 32
73290: PUSH
73291: LD_INT 51
73293: PUSH
73294: LD_EXP 87
73298: PUSH
73299: LD_INT 12
73301: PUSH
73302: LD_INT 30
73304: PUSH
73305: LD_EXP 86
73309: PUSH
73310: LD_INT 11
73312: PUSH
73313: LD_INT 53
73315: PUSH
73316: LD_INT 14
73318: PUSH
73319: LD_EXP 90
73323: PUSH
73324: LD_INT 29
73326: PUSH
73327: LD_EXP 88
73331: PUSH
73332: LD_INT 13
73334: PUSH
73335: LD_INT 52
73337: PUSH
73338: LD_EXP 92
73342: PUSH
73343: LD_INT 48
73345: PUSH
73346: LD_INT 8
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: IN
73369: NOT
73370: AND
73371: IFFALSE 73419
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73373: LD_ADDR_EXP 65
73377: PUSH
73378: LD_EXP 65
73382: PPUSH
73383: LD_VAR 0 4
73387: PUSH
73388: LD_EXP 65
73392: PUSH
73393: LD_VAR 0 4
73397: ARRAY
73398: PUSH
73399: LD_INT 1
73401: PLUS
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PPUSH
73407: LD_VAR 0 1
73411: PPUSH
73412: CALL 14797 0 3
73416: ST_TO_ADDR
73417: GO 73463
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73419: LD_ADDR_EXP 62
73423: PUSH
73424: LD_EXP 62
73428: PPUSH
73429: LD_VAR 0 4
73433: PUSH
73434: LD_EXP 62
73438: PUSH
73439: LD_VAR 0 4
73443: ARRAY
73444: PUSH
73445: LD_INT 1
73447: PLUS
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PPUSH
73453: LD_VAR 0 1
73457: PPUSH
73458: CALL 14797 0 3
73462: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73463: LD_VAR 0 1
73467: PPUSH
73468: CALL_OW 263
73472: PUSH
73473: LD_INT 2
73475: EQUAL
73476: IFFALSE 73496
// begin repeat wait ( 0 0$1 ) ;
73478: LD_INT 35
73480: PPUSH
73481: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73485: LD_VAR 0 1
73489: PPUSH
73490: CALL_OW 312
73494: IFFALSE 73478
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73496: LD_VAR 0 1
73500: PPUSH
73501: LD_EXP 67
73505: PUSH
73506: LD_VAR 0 4
73510: ARRAY
73511: PPUSH
73512: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73516: LD_VAR 0 1
73520: PPUSH
73521: CALL_OW 263
73525: PUSH
73526: LD_INT 1
73528: NONEQUAL
73529: IFFALSE 73533
// break ;
73531: GO 73582
// repeat wait ( 0 0$1 ) ;
73533: LD_INT 35
73535: PPUSH
73536: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73540: LD_VAR 0 1
73544: PPUSH
73545: LD_EXP 67
73549: PUSH
73550: LD_VAR 0 4
73554: ARRAY
73555: PPUSH
73556: CALL_OW 308
73560: IFFALSE 73533
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73562: LD_VAR 0 1
73566: PPUSH
73567: CALL_OW 311
73571: PPUSH
73572: CALL_OW 121
// exit ;
73576: POP
73577: POP
73578: GO 73584
// end ; end ;
73580: GO 73231
73582: POP
73583: POP
// end ;
73584: LD_VAR 0 3
73588: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73589: LD_INT 0
73591: PPUSH
73592: PPUSH
73593: PPUSH
73594: PPUSH
// if not mc_bases or not skirmish then
73595: LD_EXP 43
73599: NOT
73600: PUSH
73601: LD_EXP 41
73605: NOT
73606: OR
73607: IFFALSE 73611
// exit ;
73609: GO 73964
// repeat wait ( 0 0$1 ) ;
73611: LD_INT 35
73613: PPUSH
73614: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73618: LD_VAR 0 2
73622: PPUSH
73623: LD_VAR 0 3
73627: PPUSH
73628: CALL_OW 284
73632: IFFALSE 73611
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73634: LD_VAR 0 2
73638: PPUSH
73639: LD_VAR 0 3
73643: PPUSH
73644: CALL_OW 283
73648: PUSH
73649: LD_INT 4
73651: EQUAL
73652: IFFALSE 73656
// exit ;
73654: GO 73964
// for i = 1 to mc_bases do
73656: LD_ADDR_VAR 0 7
73660: PUSH
73661: DOUBLE
73662: LD_INT 1
73664: DEC
73665: ST_TO_ADDR
73666: LD_EXP 43
73670: PUSH
73671: FOR_TO
73672: IFFALSE 73962
// begin if mc_crates_area [ i ] then
73674: LD_EXP 61
73678: PUSH
73679: LD_VAR 0 7
73683: ARRAY
73684: IFFALSE 73795
// for j in mc_crates_area [ i ] do
73686: LD_ADDR_VAR 0 8
73690: PUSH
73691: LD_EXP 61
73695: PUSH
73696: LD_VAR 0 7
73700: ARRAY
73701: PUSH
73702: FOR_IN
73703: IFFALSE 73793
// if InArea ( x , y , j ) then
73705: LD_VAR 0 2
73709: PPUSH
73710: LD_VAR 0 3
73714: PPUSH
73715: LD_VAR 0 8
73719: PPUSH
73720: CALL_OW 309
73724: IFFALSE 73791
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73726: LD_ADDR_EXP 59
73730: PUSH
73731: LD_EXP 59
73735: PPUSH
73736: LD_VAR 0 7
73740: PUSH
73741: LD_EXP 59
73745: PUSH
73746: LD_VAR 0 7
73750: ARRAY
73751: PUSH
73752: LD_INT 1
73754: PLUS
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PPUSH
73760: LD_VAR 0 4
73764: PUSH
73765: LD_VAR 0 2
73769: PUSH
73770: LD_VAR 0 3
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: LIST
73779: PPUSH
73780: CALL 14797 0 3
73784: ST_TO_ADDR
// exit ;
73785: POP
73786: POP
73787: POP
73788: POP
73789: GO 73964
// end ;
73791: GO 73702
73793: POP
73794: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73795: LD_ADDR_VAR 0 9
73799: PUSH
73800: LD_EXP 43
73804: PUSH
73805: LD_VAR 0 7
73809: ARRAY
73810: PPUSH
73811: LD_INT 2
73813: PUSH
73814: LD_INT 30
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 30
73826: PUSH
73827: LD_INT 1
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: LIST
73838: PPUSH
73839: CALL_OW 72
73843: ST_TO_ADDR
// if not depot then
73844: LD_VAR 0 9
73848: NOT
73849: IFFALSE 73853
// continue ;
73851: GO 73671
// for j in depot do
73853: LD_ADDR_VAR 0 8
73857: PUSH
73858: LD_VAR 0 9
73862: PUSH
73863: FOR_IN
73864: IFFALSE 73958
// if GetDistUnitXY ( j , x , y ) < 30 then
73866: LD_VAR 0 8
73870: PPUSH
73871: LD_VAR 0 2
73875: PPUSH
73876: LD_VAR 0 3
73880: PPUSH
73881: CALL_OW 297
73885: PUSH
73886: LD_INT 30
73888: LESS
73889: IFFALSE 73956
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73891: LD_ADDR_EXP 59
73895: PUSH
73896: LD_EXP 59
73900: PPUSH
73901: LD_VAR 0 7
73905: PUSH
73906: LD_EXP 59
73910: PUSH
73911: LD_VAR 0 7
73915: ARRAY
73916: PUSH
73917: LD_INT 1
73919: PLUS
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PPUSH
73925: LD_VAR 0 4
73929: PUSH
73930: LD_VAR 0 2
73934: PUSH
73935: LD_VAR 0 3
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: LIST
73944: PPUSH
73945: CALL 14797 0 3
73949: ST_TO_ADDR
// exit ;
73950: POP
73951: POP
73952: POP
73953: POP
73954: GO 73964
// end ;
73956: GO 73863
73958: POP
73959: POP
// end ;
73960: GO 73671
73962: POP
73963: POP
// end ;
73964: LD_VAR 0 6
73968: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
73969: LD_INT 0
73971: PPUSH
73972: PPUSH
73973: PPUSH
73974: PPUSH
// if not mc_bases or not skirmish then
73975: LD_EXP 43
73979: NOT
73980: PUSH
73981: LD_EXP 41
73985: NOT
73986: OR
73987: IFFALSE 73991
// exit ;
73989: GO 74268
// side := GetSide ( lab ) ;
73991: LD_ADDR_VAR 0 4
73995: PUSH
73996: LD_VAR 0 2
74000: PPUSH
74001: CALL_OW 255
74005: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
74006: LD_VAR 0 4
74010: PUSH
74011: LD_EXP 69
74015: IN
74016: NOT
74017: PUSH
74018: LD_EXP 70
74022: NOT
74023: OR
74024: PUSH
74025: LD_EXP 43
74029: NOT
74030: OR
74031: IFFALSE 74035
// exit ;
74033: GO 74268
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
74035: LD_ADDR_EXP 70
74039: PUSH
74040: LD_EXP 70
74044: PPUSH
74045: LD_VAR 0 4
74049: PPUSH
74050: LD_EXP 70
74054: PUSH
74055: LD_VAR 0 4
74059: ARRAY
74060: PUSH
74061: LD_VAR 0 1
74065: DIFF
74066: PPUSH
74067: CALL_OW 1
74071: ST_TO_ADDR
// for i = 1 to mc_bases do
74072: LD_ADDR_VAR 0 5
74076: PUSH
74077: DOUBLE
74078: LD_INT 1
74080: DEC
74081: ST_TO_ADDR
74082: LD_EXP 43
74086: PUSH
74087: FOR_TO
74088: IFFALSE 74266
// begin if lab in mc_bases [ i ] then
74090: LD_VAR 0 2
74094: PUSH
74095: LD_EXP 43
74099: PUSH
74100: LD_VAR 0 5
74104: ARRAY
74105: IN
74106: IFFALSE 74264
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74108: LD_VAR 0 1
74112: PUSH
74113: LD_INT 11
74115: PUSH
74116: LD_INT 4
74118: PUSH
74119: LD_INT 3
74121: PUSH
74122: LD_INT 2
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: IN
74131: PUSH
74132: LD_EXP 73
74136: PUSH
74137: LD_VAR 0 5
74141: ARRAY
74142: AND
74143: IFFALSE 74264
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74145: LD_ADDR_VAR 0 6
74149: PUSH
74150: LD_EXP 73
74154: PUSH
74155: LD_VAR 0 5
74159: ARRAY
74160: PUSH
74161: LD_INT 1
74163: ARRAY
74164: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74165: LD_ADDR_EXP 73
74169: PUSH
74170: LD_EXP 73
74174: PPUSH
74175: LD_VAR 0 5
74179: PPUSH
74180: EMPTY
74181: PPUSH
74182: CALL_OW 1
74186: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74187: LD_VAR 0 6
74191: PPUSH
74192: LD_INT 0
74194: PPUSH
74195: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74199: LD_VAR 0 6
74203: PPUSH
74204: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74208: LD_ADDR_EXP 72
74212: PUSH
74213: LD_EXP 72
74217: PPUSH
74218: LD_VAR 0 5
74222: PPUSH
74223: LD_EXP 72
74227: PUSH
74228: LD_VAR 0 5
74232: ARRAY
74233: PPUSH
74234: LD_INT 1
74236: PPUSH
74237: LD_VAR 0 6
74241: PPUSH
74242: CALL_OW 2
74246: PPUSH
74247: CALL_OW 1
74251: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74252: LD_VAR 0 5
74256: PPUSH
74257: LD_INT 112
74259: PPUSH
74260: CALL 51220 0 2
// end ; end ; end ;
74264: GO 74087
74266: POP
74267: POP
// end ;
74268: LD_VAR 0 3
74272: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74273: LD_INT 0
74275: PPUSH
74276: PPUSH
74277: PPUSH
74278: PPUSH
74279: PPUSH
74280: PPUSH
74281: PPUSH
74282: PPUSH
// if not mc_bases or not skirmish then
74283: LD_EXP 43
74287: NOT
74288: PUSH
74289: LD_EXP 41
74293: NOT
74294: OR
74295: IFFALSE 74299
// exit ;
74297: GO 75670
// for i = 1 to mc_bases do
74299: LD_ADDR_VAR 0 3
74303: PUSH
74304: DOUBLE
74305: LD_INT 1
74307: DEC
74308: ST_TO_ADDR
74309: LD_EXP 43
74313: PUSH
74314: FOR_TO
74315: IFFALSE 75668
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74317: LD_VAR 0 1
74321: PUSH
74322: LD_EXP 43
74326: PUSH
74327: LD_VAR 0 3
74331: ARRAY
74332: IN
74333: PUSH
74334: LD_VAR 0 1
74338: PUSH
74339: LD_EXP 50
74343: PUSH
74344: LD_VAR 0 3
74348: ARRAY
74349: IN
74350: OR
74351: PUSH
74352: LD_VAR 0 1
74356: PUSH
74357: LD_EXP 65
74361: PUSH
74362: LD_VAR 0 3
74366: ARRAY
74367: IN
74368: OR
74369: PUSH
74370: LD_VAR 0 1
74374: PUSH
74375: LD_EXP 62
74379: PUSH
74380: LD_VAR 0 3
74384: ARRAY
74385: IN
74386: OR
74387: PUSH
74388: LD_VAR 0 1
74392: PUSH
74393: LD_EXP 72
74397: PUSH
74398: LD_VAR 0 3
74402: ARRAY
74403: IN
74404: OR
74405: PUSH
74406: LD_VAR 0 1
74410: PUSH
74411: LD_EXP 73
74415: PUSH
74416: LD_VAR 0 3
74420: ARRAY
74421: IN
74422: OR
74423: IFFALSE 75666
// begin if un in mc_ape [ i ] then
74425: LD_VAR 0 1
74429: PUSH
74430: LD_EXP 72
74434: PUSH
74435: LD_VAR 0 3
74439: ARRAY
74440: IN
74441: IFFALSE 74480
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74443: LD_ADDR_EXP 72
74447: PUSH
74448: LD_EXP 72
74452: PPUSH
74453: LD_VAR 0 3
74457: PPUSH
74458: LD_EXP 72
74462: PUSH
74463: LD_VAR 0 3
74467: ARRAY
74468: PUSH
74469: LD_VAR 0 1
74473: DIFF
74474: PPUSH
74475: CALL_OW 1
74479: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74480: LD_VAR 0 1
74484: PUSH
74485: LD_EXP 73
74489: PUSH
74490: LD_VAR 0 3
74494: ARRAY
74495: IN
74496: IFFALSE 74520
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74498: LD_ADDR_EXP 73
74502: PUSH
74503: LD_EXP 73
74507: PPUSH
74508: LD_VAR 0 3
74512: PPUSH
74513: EMPTY
74514: PPUSH
74515: CALL_OW 1
74519: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74520: LD_VAR 0 1
74524: PPUSH
74525: CALL_OW 247
74529: PUSH
74530: LD_INT 2
74532: EQUAL
74533: PUSH
74534: LD_VAR 0 1
74538: PPUSH
74539: CALL_OW 110
74543: PUSH
74544: LD_INT 20
74546: EQUAL
74547: PUSH
74548: LD_VAR 0 1
74552: PUSH
74553: LD_EXP 65
74557: PUSH
74558: LD_VAR 0 3
74562: ARRAY
74563: IN
74564: OR
74565: PUSH
74566: LD_VAR 0 1
74570: PPUSH
74571: CALL_OW 264
74575: PUSH
74576: LD_INT 12
74578: PUSH
74579: LD_INT 51
74581: PUSH
74582: LD_EXP 87
74586: PUSH
74587: LD_INT 32
74589: PUSH
74590: LD_INT 13
74592: PUSH
74593: LD_INT 52
74595: PUSH
74596: LD_INT 31
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: IN
74608: OR
74609: AND
74610: IFFALSE 74918
// begin if un in mc_defender [ i ] then
74612: LD_VAR 0 1
74616: PUSH
74617: LD_EXP 65
74621: PUSH
74622: LD_VAR 0 3
74626: ARRAY
74627: IN
74628: IFFALSE 74667
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74630: LD_ADDR_EXP 65
74634: PUSH
74635: LD_EXP 65
74639: PPUSH
74640: LD_VAR 0 3
74644: PPUSH
74645: LD_EXP 65
74649: PUSH
74650: LD_VAR 0 3
74654: ARRAY
74655: PUSH
74656: LD_VAR 0 1
74660: DIFF
74661: PPUSH
74662: CALL_OW 1
74666: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74667: LD_ADDR_VAR 0 8
74671: PUSH
74672: LD_VAR 0 3
74676: PPUSH
74677: LD_INT 3
74679: PPUSH
74680: CALL 71317 0 2
74684: ST_TO_ADDR
// if fac then
74685: LD_VAR 0 8
74689: IFFALSE 74918
// begin for j in fac do
74691: LD_ADDR_VAR 0 4
74695: PUSH
74696: LD_VAR 0 8
74700: PUSH
74701: FOR_IN
74702: IFFALSE 74916
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74704: LD_ADDR_VAR 0 9
74708: PUSH
74709: LD_VAR 0 8
74713: PPUSH
74714: LD_VAR 0 1
74718: PPUSH
74719: CALL_OW 265
74723: PPUSH
74724: LD_VAR 0 1
74728: PPUSH
74729: CALL_OW 262
74733: PPUSH
74734: LD_VAR 0 1
74738: PPUSH
74739: CALL_OW 263
74743: PPUSH
74744: LD_VAR 0 1
74748: PPUSH
74749: CALL_OW 264
74753: PPUSH
74754: CALL 12329 0 5
74758: ST_TO_ADDR
// if components then
74759: LD_VAR 0 9
74763: IFFALSE 74914
// begin if GetWeapon ( un ) = ar_control_tower then
74765: LD_VAR 0 1
74769: PPUSH
74770: CALL_OW 264
74774: PUSH
74775: LD_INT 31
74777: EQUAL
74778: IFFALSE 74895
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74780: LD_VAR 0 1
74784: PPUSH
74785: CALL_OW 311
74789: PPUSH
74790: LD_INT 0
74792: PPUSH
74793: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74797: LD_ADDR_EXP 83
74801: PUSH
74802: LD_EXP 83
74806: PPUSH
74807: LD_VAR 0 3
74811: PPUSH
74812: LD_EXP 83
74816: PUSH
74817: LD_VAR 0 3
74821: ARRAY
74822: PUSH
74823: LD_VAR 0 1
74827: PPUSH
74828: CALL_OW 311
74832: DIFF
74833: PPUSH
74834: CALL_OW 1
74838: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
74839: LD_ADDR_VAR 0 7
74843: PUSH
74844: LD_EXP 64
74848: PUSH
74849: LD_VAR 0 3
74853: ARRAY
74854: PPUSH
74855: LD_INT 1
74857: PPUSH
74858: LD_VAR 0 9
74862: PPUSH
74863: CALL_OW 2
74867: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74868: LD_ADDR_EXP 64
74872: PUSH
74873: LD_EXP 64
74877: PPUSH
74878: LD_VAR 0 3
74882: PPUSH
74883: LD_VAR 0 7
74887: PPUSH
74888: CALL_OW 1
74892: ST_TO_ADDR
// end else
74893: GO 74912
// MC_InsertProduceList ( i , [ components ] ) ;
74895: LD_VAR 0 3
74899: PPUSH
74900: LD_VAR 0 9
74904: PUSH
74905: EMPTY
74906: LIST
74907: PPUSH
74908: CALL 70862 0 2
// break ;
74912: GO 74916
// end ; end ;
74914: GO 74701
74916: POP
74917: POP
// end ; end ; if GetType ( un ) = unit_building then
74918: LD_VAR 0 1
74922: PPUSH
74923: CALL_OW 247
74927: PUSH
74928: LD_INT 3
74930: EQUAL
74931: IFFALSE 75334
// begin btype := GetBType ( un ) ;
74933: LD_ADDR_VAR 0 5
74937: PUSH
74938: LD_VAR 0 1
74942: PPUSH
74943: CALL_OW 266
74947: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
74948: LD_VAR 0 5
74952: PUSH
74953: LD_INT 29
74955: PUSH
74956: LD_INT 30
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: IN
74963: IFFALSE 75036
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
74965: LD_VAR 0 1
74969: PPUSH
74970: CALL_OW 250
74974: PPUSH
74975: LD_VAR 0 1
74979: PPUSH
74980: CALL_OW 251
74984: PPUSH
74985: LD_VAR 0 1
74989: PPUSH
74990: CALL_OW 255
74994: PPUSH
74995: CALL_OW 440
74999: NOT
75000: IFFALSE 75036
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
75002: LD_VAR 0 1
75006: PPUSH
75007: CALL_OW 250
75011: PPUSH
75012: LD_VAR 0 1
75016: PPUSH
75017: CALL_OW 251
75021: PPUSH
75022: LD_VAR 0 1
75026: PPUSH
75027: CALL_OW 255
75031: PPUSH
75032: CALL_OW 441
// end ; if btype = b_warehouse then
75036: LD_VAR 0 5
75040: PUSH
75041: LD_INT 1
75043: EQUAL
75044: IFFALSE 75062
// begin btype := b_depot ;
75046: LD_ADDR_VAR 0 5
75050: PUSH
75051: LD_INT 0
75053: ST_TO_ADDR
// pos := 1 ;
75054: LD_ADDR_VAR 0 6
75058: PUSH
75059: LD_INT 1
75061: ST_TO_ADDR
// end ; if btype = b_factory then
75062: LD_VAR 0 5
75066: PUSH
75067: LD_INT 3
75069: EQUAL
75070: IFFALSE 75088
// begin btype := b_workshop ;
75072: LD_ADDR_VAR 0 5
75076: PUSH
75077: LD_INT 2
75079: ST_TO_ADDR
// pos := 1 ;
75080: LD_ADDR_VAR 0 6
75084: PUSH
75085: LD_INT 1
75087: ST_TO_ADDR
// end ; if btype = b_barracks then
75088: LD_VAR 0 5
75092: PUSH
75093: LD_INT 5
75095: EQUAL
75096: IFFALSE 75106
// btype := b_armoury ;
75098: LD_ADDR_VAR 0 5
75102: PUSH
75103: LD_INT 4
75105: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75106: LD_VAR 0 5
75110: PUSH
75111: LD_INT 7
75113: PUSH
75114: LD_INT 8
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: IN
75121: IFFALSE 75131
// btype := b_lab ;
75123: LD_ADDR_VAR 0 5
75127: PUSH
75128: LD_INT 6
75130: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75131: LD_ADDR_EXP 48
75135: PUSH
75136: LD_EXP 48
75140: PPUSH
75141: LD_VAR 0 3
75145: PUSH
75146: LD_EXP 48
75150: PUSH
75151: LD_VAR 0 3
75155: ARRAY
75156: PUSH
75157: LD_INT 1
75159: PLUS
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PPUSH
75165: LD_VAR 0 5
75169: PUSH
75170: LD_VAR 0 1
75174: PPUSH
75175: CALL_OW 250
75179: PUSH
75180: LD_VAR 0 1
75184: PPUSH
75185: CALL_OW 251
75189: PUSH
75190: LD_VAR 0 1
75194: PPUSH
75195: CALL_OW 254
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: PPUSH
75206: CALL 14797 0 3
75210: ST_TO_ADDR
// if pos = 1 then
75211: LD_VAR 0 6
75215: PUSH
75216: LD_INT 1
75218: EQUAL
75219: IFFALSE 75334
// begin tmp := mc_build_list [ i ] ;
75221: LD_ADDR_VAR 0 7
75225: PUSH
75226: LD_EXP 48
75230: PUSH
75231: LD_VAR 0 3
75235: ARRAY
75236: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75237: LD_VAR 0 7
75241: PPUSH
75242: LD_INT 2
75244: PUSH
75245: LD_INT 30
75247: PUSH
75248: LD_INT 0
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 30
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: LIST
75269: PPUSH
75270: CALL_OW 72
75274: IFFALSE 75284
// pos := 2 ;
75276: LD_ADDR_VAR 0 6
75280: PUSH
75281: LD_INT 2
75283: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75284: LD_ADDR_VAR 0 7
75288: PUSH
75289: LD_VAR 0 7
75293: PPUSH
75294: LD_VAR 0 6
75298: PPUSH
75299: LD_VAR 0 7
75303: PPUSH
75304: CALL 15123 0 3
75308: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75309: LD_ADDR_EXP 48
75313: PUSH
75314: LD_EXP 48
75318: PPUSH
75319: LD_VAR 0 3
75323: PPUSH
75324: LD_VAR 0 7
75328: PPUSH
75329: CALL_OW 1
75333: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75334: LD_VAR 0 1
75338: PUSH
75339: LD_EXP 43
75343: PUSH
75344: LD_VAR 0 3
75348: ARRAY
75349: IN
75350: IFFALSE 75389
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75352: LD_ADDR_EXP 43
75356: PUSH
75357: LD_EXP 43
75361: PPUSH
75362: LD_VAR 0 3
75366: PPUSH
75367: LD_EXP 43
75371: PUSH
75372: LD_VAR 0 3
75376: ARRAY
75377: PUSH
75378: LD_VAR 0 1
75382: DIFF
75383: PPUSH
75384: CALL_OW 1
75388: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75389: LD_VAR 0 1
75393: PUSH
75394: LD_EXP 50
75398: PUSH
75399: LD_VAR 0 3
75403: ARRAY
75404: IN
75405: IFFALSE 75444
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75407: LD_ADDR_EXP 50
75411: PUSH
75412: LD_EXP 50
75416: PPUSH
75417: LD_VAR 0 3
75421: PPUSH
75422: LD_EXP 50
75426: PUSH
75427: LD_VAR 0 3
75431: ARRAY
75432: PUSH
75433: LD_VAR 0 1
75437: DIFF
75438: PPUSH
75439: CALL_OW 1
75443: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75444: LD_VAR 0 1
75448: PUSH
75449: LD_EXP 62
75453: PUSH
75454: LD_VAR 0 3
75458: ARRAY
75459: IN
75460: IFFALSE 75499
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75462: LD_ADDR_EXP 62
75466: PUSH
75467: LD_EXP 62
75471: PPUSH
75472: LD_VAR 0 3
75476: PPUSH
75477: LD_EXP 62
75481: PUSH
75482: LD_VAR 0 3
75486: ARRAY
75487: PUSH
75488: LD_VAR 0 1
75492: DIFF
75493: PPUSH
75494: CALL_OW 1
75498: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75499: LD_VAR 0 1
75503: PUSH
75504: LD_EXP 65
75508: PUSH
75509: LD_VAR 0 3
75513: ARRAY
75514: IN
75515: IFFALSE 75554
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75517: LD_ADDR_EXP 65
75521: PUSH
75522: LD_EXP 65
75526: PPUSH
75527: LD_VAR 0 3
75531: PPUSH
75532: LD_EXP 65
75536: PUSH
75537: LD_VAR 0 3
75541: ARRAY
75542: PUSH
75543: LD_VAR 0 1
75547: DIFF
75548: PPUSH
75549: CALL_OW 1
75553: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75554: LD_VAR 0 1
75558: PUSH
75559: LD_EXP 52
75563: PUSH
75564: LD_VAR 0 3
75568: ARRAY
75569: IN
75570: IFFALSE 75609
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75572: LD_ADDR_EXP 52
75576: PUSH
75577: LD_EXP 52
75581: PPUSH
75582: LD_VAR 0 3
75586: PPUSH
75587: LD_EXP 52
75591: PUSH
75592: LD_VAR 0 3
75596: ARRAY
75597: PUSH
75598: LD_VAR 0 1
75602: DIFF
75603: PPUSH
75604: CALL_OW 1
75608: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75609: LD_VAR 0 1
75613: PUSH
75614: LD_EXP 51
75618: PUSH
75619: LD_VAR 0 3
75623: ARRAY
75624: IN
75625: IFFALSE 75664
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75627: LD_ADDR_EXP 51
75631: PUSH
75632: LD_EXP 51
75636: PPUSH
75637: LD_VAR 0 3
75641: PPUSH
75642: LD_EXP 51
75646: PUSH
75647: LD_VAR 0 3
75651: ARRAY
75652: PUSH
75653: LD_VAR 0 1
75657: DIFF
75658: PPUSH
75659: CALL_OW 1
75663: ST_TO_ADDR
// end ; break ;
75664: GO 75668
// end ;
75666: GO 74314
75668: POP
75669: POP
// end ;
75670: LD_VAR 0 2
75674: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75675: LD_INT 0
75677: PPUSH
75678: PPUSH
75679: PPUSH
// if not mc_bases or not skirmish then
75680: LD_EXP 43
75684: NOT
75685: PUSH
75686: LD_EXP 41
75690: NOT
75691: OR
75692: IFFALSE 75696
// exit ;
75694: GO 75911
// for i = 1 to mc_bases do
75696: LD_ADDR_VAR 0 3
75700: PUSH
75701: DOUBLE
75702: LD_INT 1
75704: DEC
75705: ST_TO_ADDR
75706: LD_EXP 43
75710: PUSH
75711: FOR_TO
75712: IFFALSE 75909
// begin if building in mc_construct_list [ i ] then
75714: LD_VAR 0 1
75718: PUSH
75719: LD_EXP 50
75723: PUSH
75724: LD_VAR 0 3
75728: ARRAY
75729: IN
75730: IFFALSE 75907
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75732: LD_ADDR_EXP 50
75736: PUSH
75737: LD_EXP 50
75741: PPUSH
75742: LD_VAR 0 3
75746: PPUSH
75747: LD_EXP 50
75751: PUSH
75752: LD_VAR 0 3
75756: ARRAY
75757: PUSH
75758: LD_VAR 0 1
75762: DIFF
75763: PPUSH
75764: CALL_OW 1
75768: ST_TO_ADDR
// if building in mc_lab [ i ] then
75769: LD_VAR 0 1
75773: PUSH
75774: LD_EXP 76
75778: PUSH
75779: LD_VAR 0 3
75783: ARRAY
75784: IN
75785: IFFALSE 75840
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75787: LD_ADDR_EXP 77
75791: PUSH
75792: LD_EXP 77
75796: PPUSH
75797: LD_VAR 0 3
75801: PPUSH
75802: LD_EXP 77
75806: PUSH
75807: LD_VAR 0 3
75811: ARRAY
75812: PPUSH
75813: LD_INT 1
75815: PPUSH
75816: LD_EXP 77
75820: PUSH
75821: LD_VAR 0 3
75825: ARRAY
75826: PPUSH
75827: LD_INT 0
75829: PPUSH
75830: CALL 14215 0 4
75834: PPUSH
75835: CALL_OW 1
75839: ST_TO_ADDR
// if not building in mc_bases [ i ] then
75840: LD_VAR 0 1
75844: PUSH
75845: LD_EXP 43
75849: PUSH
75850: LD_VAR 0 3
75854: ARRAY
75855: IN
75856: NOT
75857: IFFALSE 75903
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75859: LD_ADDR_EXP 43
75863: PUSH
75864: LD_EXP 43
75868: PPUSH
75869: LD_VAR 0 3
75873: PUSH
75874: LD_EXP 43
75878: PUSH
75879: LD_VAR 0 3
75883: ARRAY
75884: PUSH
75885: LD_INT 1
75887: PLUS
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PPUSH
75893: LD_VAR 0 1
75897: PPUSH
75898: CALL 14797 0 3
75902: ST_TO_ADDR
// exit ;
75903: POP
75904: POP
75905: GO 75911
// end ; end ;
75907: GO 75711
75909: POP
75910: POP
// end ;
75911: LD_VAR 0 2
75915: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
75916: LD_INT 0
75918: PPUSH
75919: PPUSH
75920: PPUSH
75921: PPUSH
75922: PPUSH
75923: PPUSH
75924: PPUSH
// if not mc_bases or not skirmish then
75925: LD_EXP 43
75929: NOT
75930: PUSH
75931: LD_EXP 41
75935: NOT
75936: OR
75937: IFFALSE 75941
// exit ;
75939: GO 76602
// for i = 1 to mc_bases do
75941: LD_ADDR_VAR 0 3
75945: PUSH
75946: DOUBLE
75947: LD_INT 1
75949: DEC
75950: ST_TO_ADDR
75951: LD_EXP 43
75955: PUSH
75956: FOR_TO
75957: IFFALSE 76600
// begin if building in mc_construct_list [ i ] then
75959: LD_VAR 0 1
75963: PUSH
75964: LD_EXP 50
75968: PUSH
75969: LD_VAR 0 3
75973: ARRAY
75974: IN
75975: IFFALSE 76598
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75977: LD_ADDR_EXP 50
75981: PUSH
75982: LD_EXP 50
75986: PPUSH
75987: LD_VAR 0 3
75991: PPUSH
75992: LD_EXP 50
75996: PUSH
75997: LD_VAR 0 3
76001: ARRAY
76002: PUSH
76003: LD_VAR 0 1
76007: DIFF
76008: PPUSH
76009: CALL_OW 1
76013: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76014: LD_ADDR_EXP 43
76018: PUSH
76019: LD_EXP 43
76023: PPUSH
76024: LD_VAR 0 3
76028: PUSH
76029: LD_EXP 43
76033: PUSH
76034: LD_VAR 0 3
76038: ARRAY
76039: PUSH
76040: LD_INT 1
76042: PLUS
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PPUSH
76048: LD_VAR 0 1
76052: PPUSH
76053: CALL 14797 0 3
76057: ST_TO_ADDR
// btype := GetBType ( building ) ;
76058: LD_ADDR_VAR 0 5
76062: PUSH
76063: LD_VAR 0 1
76067: PPUSH
76068: CALL_OW 266
76072: ST_TO_ADDR
// side := GetSide ( building ) ;
76073: LD_ADDR_VAR 0 8
76077: PUSH
76078: LD_VAR 0 1
76082: PPUSH
76083: CALL_OW 255
76087: ST_TO_ADDR
// if btype = b_lab then
76088: LD_VAR 0 5
76092: PUSH
76093: LD_INT 6
76095: EQUAL
76096: IFFALSE 76146
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76098: LD_ADDR_EXP 76
76102: PUSH
76103: LD_EXP 76
76107: PPUSH
76108: LD_VAR 0 3
76112: PUSH
76113: LD_EXP 76
76117: PUSH
76118: LD_VAR 0 3
76122: ARRAY
76123: PUSH
76124: LD_INT 1
76126: PLUS
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PPUSH
76132: LD_VAR 0 1
76136: PPUSH
76137: CALL 14797 0 3
76141: ST_TO_ADDR
// exit ;
76142: POP
76143: POP
76144: GO 76602
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76146: LD_VAR 0 5
76150: PUSH
76151: LD_INT 0
76153: PUSH
76154: LD_INT 2
76156: PUSH
76157: LD_INT 4
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: LIST
76164: IN
76165: IFFALSE 76289
// begin if btype = b_armoury then
76167: LD_VAR 0 5
76171: PUSH
76172: LD_INT 4
76174: EQUAL
76175: IFFALSE 76185
// btype := b_barracks ;
76177: LD_ADDR_VAR 0 5
76181: PUSH
76182: LD_INT 5
76184: ST_TO_ADDR
// if btype = b_depot then
76185: LD_VAR 0 5
76189: PUSH
76190: LD_INT 0
76192: EQUAL
76193: IFFALSE 76203
// btype := b_warehouse ;
76195: LD_ADDR_VAR 0 5
76199: PUSH
76200: LD_INT 1
76202: ST_TO_ADDR
// if btype = b_workshop then
76203: LD_VAR 0 5
76207: PUSH
76208: LD_INT 2
76210: EQUAL
76211: IFFALSE 76221
// btype := b_factory ;
76213: LD_ADDR_VAR 0 5
76217: PUSH
76218: LD_INT 3
76220: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76221: LD_VAR 0 5
76225: PPUSH
76226: LD_VAR 0 8
76230: PPUSH
76231: CALL_OW 323
76235: PUSH
76236: LD_INT 1
76238: EQUAL
76239: IFFALSE 76285
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76241: LD_ADDR_EXP 75
76245: PUSH
76246: LD_EXP 75
76250: PPUSH
76251: LD_VAR 0 3
76255: PUSH
76256: LD_EXP 75
76260: PUSH
76261: LD_VAR 0 3
76265: ARRAY
76266: PUSH
76267: LD_INT 1
76269: PLUS
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PPUSH
76275: LD_VAR 0 1
76279: PPUSH
76280: CALL 14797 0 3
76284: ST_TO_ADDR
// exit ;
76285: POP
76286: POP
76287: GO 76602
// end ; if btype in [ b_bunker , b_turret ] then
76289: LD_VAR 0 5
76293: PUSH
76294: LD_INT 32
76296: PUSH
76297: LD_INT 33
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: IN
76304: IFFALSE 76594
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76306: LD_ADDR_EXP 51
76310: PUSH
76311: LD_EXP 51
76315: PPUSH
76316: LD_VAR 0 3
76320: PUSH
76321: LD_EXP 51
76325: PUSH
76326: LD_VAR 0 3
76330: ARRAY
76331: PUSH
76332: LD_INT 1
76334: PLUS
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: PPUSH
76340: LD_VAR 0 1
76344: PPUSH
76345: CALL 14797 0 3
76349: ST_TO_ADDR
// if btype = b_bunker then
76350: LD_VAR 0 5
76354: PUSH
76355: LD_INT 32
76357: EQUAL
76358: IFFALSE 76594
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76360: LD_ADDR_EXP 52
76364: PUSH
76365: LD_EXP 52
76369: PPUSH
76370: LD_VAR 0 3
76374: PUSH
76375: LD_EXP 52
76379: PUSH
76380: LD_VAR 0 3
76384: ARRAY
76385: PUSH
76386: LD_INT 1
76388: PLUS
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PPUSH
76394: LD_VAR 0 1
76398: PPUSH
76399: CALL 14797 0 3
76403: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76404: LD_ADDR_VAR 0 6
76408: PUSH
76409: LD_EXP 43
76413: PUSH
76414: LD_VAR 0 3
76418: ARRAY
76419: PPUSH
76420: LD_INT 25
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 3
76432: PUSH
76433: LD_INT 54
76435: PUSH
76436: EMPTY
76437: LIST
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PPUSH
76447: CALL_OW 72
76451: ST_TO_ADDR
// if tmp then
76452: LD_VAR 0 6
76456: IFFALSE 76462
// exit ;
76458: POP
76459: POP
76460: GO 76602
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76462: LD_ADDR_VAR 0 6
76466: PUSH
76467: LD_EXP 43
76471: PUSH
76472: LD_VAR 0 3
76476: ARRAY
76477: PPUSH
76478: LD_INT 2
76480: PUSH
76481: LD_INT 30
76483: PUSH
76484: LD_INT 4
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: LD_INT 30
76493: PUSH
76494: LD_INT 5
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: LIST
76505: PPUSH
76506: CALL_OW 72
76510: ST_TO_ADDR
// if not tmp then
76511: LD_VAR 0 6
76515: NOT
76516: IFFALSE 76522
// exit ;
76518: POP
76519: POP
76520: GO 76602
// for j in tmp do
76522: LD_ADDR_VAR 0 4
76526: PUSH
76527: LD_VAR 0 6
76531: PUSH
76532: FOR_IN
76533: IFFALSE 76592
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76535: LD_ADDR_VAR 0 7
76539: PUSH
76540: LD_VAR 0 4
76544: PPUSH
76545: CALL_OW 313
76549: PPUSH
76550: LD_INT 25
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PPUSH
76560: CALL_OW 72
76564: ST_TO_ADDR
// if units then
76565: LD_VAR 0 7
76569: IFFALSE 76590
// begin ComExitBuilding ( units [ 1 ] ) ;
76571: LD_VAR 0 7
76575: PUSH
76576: LD_INT 1
76578: ARRAY
76579: PPUSH
76580: CALL_OW 122
// exit ;
76584: POP
76585: POP
76586: POP
76587: POP
76588: GO 76602
// end ; end ;
76590: GO 76532
76592: POP
76593: POP
// end ; end ; exit ;
76594: POP
76595: POP
76596: GO 76602
// end ; end ;
76598: GO 75956
76600: POP
76601: POP
// end ;
76602: LD_VAR 0 2
76606: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76607: LD_INT 0
76609: PPUSH
76610: PPUSH
76611: PPUSH
76612: PPUSH
76613: PPUSH
76614: PPUSH
76615: PPUSH
// if not mc_bases or not skirmish then
76616: LD_EXP 43
76620: NOT
76621: PUSH
76622: LD_EXP 41
76626: NOT
76627: OR
76628: IFFALSE 76632
// exit ;
76630: GO 76863
// btype := GetBType ( building ) ;
76632: LD_ADDR_VAR 0 6
76636: PUSH
76637: LD_VAR 0 1
76641: PPUSH
76642: CALL_OW 266
76646: ST_TO_ADDR
// x := GetX ( building ) ;
76647: LD_ADDR_VAR 0 7
76651: PUSH
76652: LD_VAR 0 1
76656: PPUSH
76657: CALL_OW 250
76661: ST_TO_ADDR
// y := GetY ( building ) ;
76662: LD_ADDR_VAR 0 8
76666: PUSH
76667: LD_VAR 0 1
76671: PPUSH
76672: CALL_OW 251
76676: ST_TO_ADDR
// d := GetDir ( building ) ;
76677: LD_ADDR_VAR 0 9
76681: PUSH
76682: LD_VAR 0 1
76686: PPUSH
76687: CALL_OW 254
76691: ST_TO_ADDR
// for i = 1 to mc_bases do
76692: LD_ADDR_VAR 0 4
76696: PUSH
76697: DOUBLE
76698: LD_INT 1
76700: DEC
76701: ST_TO_ADDR
76702: LD_EXP 43
76706: PUSH
76707: FOR_TO
76708: IFFALSE 76861
// begin if not mc_build_list [ i ] then
76710: LD_EXP 48
76714: PUSH
76715: LD_VAR 0 4
76719: ARRAY
76720: NOT
76721: IFFALSE 76725
// continue ;
76723: GO 76707
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
76725: LD_VAR 0 6
76729: PUSH
76730: LD_VAR 0 7
76734: PUSH
76735: LD_VAR 0 8
76739: PUSH
76740: LD_VAR 0 9
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: PPUSH
76751: LD_EXP 48
76755: PUSH
76756: LD_VAR 0 4
76760: ARRAY
76761: PUSH
76762: LD_INT 1
76764: ARRAY
76765: PPUSH
76766: CALL 20978 0 2
76770: IFFALSE 76859
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
76772: LD_ADDR_EXP 48
76776: PUSH
76777: LD_EXP 48
76781: PPUSH
76782: LD_VAR 0 4
76786: PPUSH
76787: LD_EXP 48
76791: PUSH
76792: LD_VAR 0 4
76796: ARRAY
76797: PPUSH
76798: LD_INT 1
76800: PPUSH
76801: CALL_OW 3
76805: PPUSH
76806: CALL_OW 1
76810: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
76811: LD_ADDR_EXP 50
76815: PUSH
76816: LD_EXP 50
76820: PPUSH
76821: LD_VAR 0 4
76825: PUSH
76826: LD_EXP 50
76830: PUSH
76831: LD_VAR 0 4
76835: ARRAY
76836: PUSH
76837: LD_INT 1
76839: PLUS
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PPUSH
76845: LD_VAR 0 1
76849: PPUSH
76850: CALL 14797 0 3
76854: ST_TO_ADDR
// exit ;
76855: POP
76856: POP
76857: GO 76863
// end ; end ;
76859: GO 76707
76861: POP
76862: POP
// end ;
76863: LD_VAR 0 3
76867: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
76868: LD_INT 0
76870: PPUSH
76871: PPUSH
76872: PPUSH
// if not mc_bases or not skirmish then
76873: LD_EXP 43
76877: NOT
76878: PUSH
76879: LD_EXP 41
76883: NOT
76884: OR
76885: IFFALSE 76889
// exit ;
76887: GO 77079
// for i = 1 to mc_bases do
76889: LD_ADDR_VAR 0 4
76893: PUSH
76894: DOUBLE
76895: LD_INT 1
76897: DEC
76898: ST_TO_ADDR
76899: LD_EXP 43
76903: PUSH
76904: FOR_TO
76905: IFFALSE 76992
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
76907: LD_VAR 0 1
76911: PUSH
76912: LD_EXP 51
76916: PUSH
76917: LD_VAR 0 4
76921: ARRAY
76922: IN
76923: PUSH
76924: LD_VAR 0 1
76928: PUSH
76929: LD_EXP 52
76933: PUSH
76934: LD_VAR 0 4
76938: ARRAY
76939: IN
76940: NOT
76941: AND
76942: IFFALSE 76990
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76944: LD_ADDR_EXP 52
76948: PUSH
76949: LD_EXP 52
76953: PPUSH
76954: LD_VAR 0 4
76958: PUSH
76959: LD_EXP 52
76963: PUSH
76964: LD_VAR 0 4
76968: ARRAY
76969: PUSH
76970: LD_INT 1
76972: PLUS
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PPUSH
76978: LD_VAR 0 1
76982: PPUSH
76983: CALL 14797 0 3
76987: ST_TO_ADDR
// break ;
76988: GO 76992
// end ; end ;
76990: GO 76904
76992: POP
76993: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
76994: LD_VAR 0 1
76998: PPUSH
76999: CALL_OW 257
77003: PUSH
77004: LD_EXP 69
77008: IN
77009: PUSH
77010: LD_VAR 0 1
77014: PPUSH
77015: CALL_OW 266
77019: PUSH
77020: LD_INT 5
77022: EQUAL
77023: AND
77024: PUSH
77025: LD_VAR 0 2
77029: PPUSH
77030: CALL_OW 110
77034: PUSH
77035: LD_INT 18
77037: NONEQUAL
77038: AND
77039: IFFALSE 77079
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
77041: LD_VAR 0 2
77045: PPUSH
77046: CALL_OW 257
77050: PUSH
77051: LD_INT 5
77053: PUSH
77054: LD_INT 8
77056: PUSH
77057: LD_INT 9
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: LIST
77064: IN
77065: IFFALSE 77079
// SetClass ( unit , 1 ) ;
77067: LD_VAR 0 2
77071: PPUSH
77072: LD_INT 1
77074: PPUSH
77075: CALL_OW 336
// end ;
77079: LD_VAR 0 3
77083: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77084: LD_INT 0
77086: PPUSH
77087: PPUSH
// if not mc_bases or not skirmish then
77088: LD_EXP 43
77092: NOT
77093: PUSH
77094: LD_EXP 41
77098: NOT
77099: OR
77100: IFFALSE 77104
// exit ;
77102: GO 77220
// if GetLives ( abandoned_vehicle ) > 250 then
77104: LD_VAR 0 2
77108: PPUSH
77109: CALL_OW 256
77113: PUSH
77114: LD_INT 250
77116: GREATER
77117: IFFALSE 77121
// exit ;
77119: GO 77220
// for i = 1 to mc_bases do
77121: LD_ADDR_VAR 0 6
77125: PUSH
77126: DOUBLE
77127: LD_INT 1
77129: DEC
77130: ST_TO_ADDR
77131: LD_EXP 43
77135: PUSH
77136: FOR_TO
77137: IFFALSE 77218
// begin if driver in mc_bases [ i ] then
77139: LD_VAR 0 1
77143: PUSH
77144: LD_EXP 43
77148: PUSH
77149: LD_VAR 0 6
77153: ARRAY
77154: IN
77155: IFFALSE 77216
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77157: LD_VAR 0 1
77161: PPUSH
77162: LD_EXP 43
77166: PUSH
77167: LD_VAR 0 6
77171: ARRAY
77172: PPUSH
77173: LD_INT 2
77175: PUSH
77176: LD_INT 30
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 30
77188: PUSH
77189: LD_INT 1
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: LIST
77200: PPUSH
77201: CALL_OW 72
77205: PUSH
77206: LD_INT 1
77208: ARRAY
77209: PPUSH
77210: CALL 46675 0 2
// break ;
77214: GO 77218
// end ; end ;
77216: GO 77136
77218: POP
77219: POP
// end ; end_of_file
77220: LD_VAR 0 5
77224: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77225: LD_INT 0
77227: PPUSH
// ar_miner := 81 ;
77228: LD_ADDR_EXP 93
77232: PUSH
77233: LD_INT 81
77235: ST_TO_ADDR
// ar_crane := 88 ;
77236: LD_ADDR_EXP 92
77240: PUSH
77241: LD_INT 88
77243: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77244: LD_ADDR_EXP 87
77248: PUSH
77249: LD_INT 89
77251: ST_TO_ADDR
// us_hack := 99 ;
77252: LD_ADDR_EXP 88
77256: PUSH
77257: LD_INT 99
77259: ST_TO_ADDR
// us_artillery := 97 ;
77260: LD_ADDR_EXP 89
77264: PUSH
77265: LD_INT 97
77267: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77268: LD_ADDR_EXP 90
77272: PUSH
77273: LD_INT 91
77275: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77276: LD_ADDR_EXP 91
77280: PUSH
77281: LD_INT 92
77283: ST_TO_ADDR
// ru_radar := 98 ;
77284: LD_ADDR_EXP 86
77288: PUSH
77289: LD_INT 98
77291: ST_TO_ADDR
// tech_Artillery := 80 ;
77292: LD_ADDR_EXP 94
77296: PUSH
77297: LD_INT 80
77299: ST_TO_ADDR
// tech_RadMat := 81 ;
77300: LD_ADDR_EXP 95
77304: PUSH
77305: LD_INT 81
77307: ST_TO_ADDR
// tech_BasicTools := 82 ;
77308: LD_ADDR_EXP 96
77312: PUSH
77313: LD_INT 82
77315: ST_TO_ADDR
// tech_Cargo := 83 ;
77316: LD_ADDR_EXP 97
77320: PUSH
77321: LD_INT 83
77323: ST_TO_ADDR
// tech_Track := 84 ;
77324: LD_ADDR_EXP 98
77328: PUSH
77329: LD_INT 84
77331: ST_TO_ADDR
// tech_Crane := 85 ;
77332: LD_ADDR_EXP 99
77336: PUSH
77337: LD_INT 85
77339: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77340: LD_ADDR_EXP 100
77344: PUSH
77345: LD_INT 86
77347: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77348: LD_ADDR_EXP 101
77352: PUSH
77353: LD_INT 87
77355: ST_TO_ADDR
// end ;
77356: LD_VAR 0 1
77360: RET
// every 1 do
77361: GO 77363
77363: DISABLE
// InitGlobalVariables ; end_of_file
77364: CALL 77225 0 0
77368: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77369: LD_INT 0
77371: PPUSH
77372: PPUSH
77373: PPUSH
77374: PPUSH
77375: PPUSH
77376: PPUSH
77377: PPUSH
77378: PPUSH
77379: PPUSH
77380: PPUSH
77381: PPUSH
77382: PPUSH
77383: PPUSH
77384: PPUSH
77385: PPUSH
77386: PPUSH
77387: PPUSH
77388: PPUSH
77389: PPUSH
77390: PPUSH
77391: PPUSH
77392: PPUSH
77393: PPUSH
77394: PPUSH
77395: PPUSH
77396: PPUSH
77397: PPUSH
77398: PPUSH
77399: PPUSH
77400: PPUSH
77401: PPUSH
77402: PPUSH
77403: PPUSH
77404: PPUSH
// if not list then
77405: LD_VAR 0 1
77409: NOT
77410: IFFALSE 77414
// exit ;
77412: GO 82073
// base := list [ 1 ] ;
77414: LD_ADDR_VAR 0 3
77418: PUSH
77419: LD_VAR 0 1
77423: PUSH
77424: LD_INT 1
77426: ARRAY
77427: ST_TO_ADDR
// group := list [ 2 ] ;
77428: LD_ADDR_VAR 0 4
77432: PUSH
77433: LD_VAR 0 1
77437: PUSH
77438: LD_INT 2
77440: ARRAY
77441: ST_TO_ADDR
// path := list [ 3 ] ;
77442: LD_ADDR_VAR 0 5
77446: PUSH
77447: LD_VAR 0 1
77451: PUSH
77452: LD_INT 3
77454: ARRAY
77455: ST_TO_ADDR
// flags := list [ 4 ] ;
77456: LD_ADDR_VAR 0 6
77460: PUSH
77461: LD_VAR 0 1
77465: PUSH
77466: LD_INT 4
77468: ARRAY
77469: ST_TO_ADDR
// mined := [ ] ;
77470: LD_ADDR_VAR 0 27
77474: PUSH
77475: EMPTY
77476: ST_TO_ADDR
// bombed := [ ] ;
77477: LD_ADDR_VAR 0 28
77481: PUSH
77482: EMPTY
77483: ST_TO_ADDR
// healers := [ ] ;
77484: LD_ADDR_VAR 0 31
77488: PUSH
77489: EMPTY
77490: ST_TO_ADDR
// to_heal := [ ] ;
77491: LD_ADDR_VAR 0 30
77495: PUSH
77496: EMPTY
77497: ST_TO_ADDR
// repairs := [ ] ;
77498: LD_ADDR_VAR 0 33
77502: PUSH
77503: EMPTY
77504: ST_TO_ADDR
// to_repair := [ ] ;
77505: LD_ADDR_VAR 0 32
77509: PUSH
77510: EMPTY
77511: ST_TO_ADDR
// if not group or not path then
77512: LD_VAR 0 4
77516: NOT
77517: PUSH
77518: LD_VAR 0 5
77522: NOT
77523: OR
77524: IFFALSE 77528
// exit ;
77526: GO 82073
// side := GetSide ( group [ 1 ] ) ;
77528: LD_ADDR_VAR 0 35
77532: PUSH
77533: LD_VAR 0 4
77537: PUSH
77538: LD_INT 1
77540: ARRAY
77541: PPUSH
77542: CALL_OW 255
77546: ST_TO_ADDR
// if flags then
77547: LD_VAR 0 6
77551: IFFALSE 77695
// begin f_ignore_area := flags [ 1 ] ;
77553: LD_ADDR_VAR 0 17
77557: PUSH
77558: LD_VAR 0 6
77562: PUSH
77563: LD_INT 1
77565: ARRAY
77566: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77567: LD_ADDR_VAR 0 18
77571: PUSH
77572: LD_VAR 0 6
77576: PUSH
77577: LD_INT 2
77579: ARRAY
77580: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77581: LD_ADDR_VAR 0 19
77585: PUSH
77586: LD_VAR 0 6
77590: PUSH
77591: LD_INT 3
77593: ARRAY
77594: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77595: LD_ADDR_VAR 0 20
77599: PUSH
77600: LD_VAR 0 6
77604: PUSH
77605: LD_INT 4
77607: ARRAY
77608: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77609: LD_ADDR_VAR 0 21
77613: PUSH
77614: LD_VAR 0 6
77618: PUSH
77619: LD_INT 5
77621: ARRAY
77622: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77623: LD_ADDR_VAR 0 22
77627: PUSH
77628: LD_VAR 0 6
77632: PUSH
77633: LD_INT 6
77635: ARRAY
77636: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77637: LD_ADDR_VAR 0 23
77641: PUSH
77642: LD_VAR 0 6
77646: PUSH
77647: LD_INT 7
77649: ARRAY
77650: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77651: LD_ADDR_VAR 0 24
77655: PUSH
77656: LD_VAR 0 6
77660: PUSH
77661: LD_INT 8
77663: ARRAY
77664: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77665: LD_ADDR_VAR 0 25
77669: PUSH
77670: LD_VAR 0 6
77674: PUSH
77675: LD_INT 9
77677: ARRAY
77678: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77679: LD_ADDR_VAR 0 26
77683: PUSH
77684: LD_VAR 0 6
77688: PUSH
77689: LD_INT 10
77691: ARRAY
77692: ST_TO_ADDR
// end else
77693: GO 77775
// begin f_ignore_area := false ;
77695: LD_ADDR_VAR 0 17
77699: PUSH
77700: LD_INT 0
77702: ST_TO_ADDR
// f_capture := false ;
77703: LD_ADDR_VAR 0 18
77707: PUSH
77708: LD_INT 0
77710: ST_TO_ADDR
// f_ignore_civ := false ;
77711: LD_ADDR_VAR 0 19
77715: PUSH
77716: LD_INT 0
77718: ST_TO_ADDR
// f_murder := false ;
77719: LD_ADDR_VAR 0 20
77723: PUSH
77724: LD_INT 0
77726: ST_TO_ADDR
// f_mines := false ;
77727: LD_ADDR_VAR 0 21
77731: PUSH
77732: LD_INT 0
77734: ST_TO_ADDR
// f_repair := false ;
77735: LD_ADDR_VAR 0 22
77739: PUSH
77740: LD_INT 0
77742: ST_TO_ADDR
// f_heal := false ;
77743: LD_ADDR_VAR 0 23
77747: PUSH
77748: LD_INT 0
77750: ST_TO_ADDR
// f_spacetime := false ;
77751: LD_ADDR_VAR 0 24
77755: PUSH
77756: LD_INT 0
77758: ST_TO_ADDR
// f_attack_depot := false ;
77759: LD_ADDR_VAR 0 25
77763: PUSH
77764: LD_INT 0
77766: ST_TO_ADDR
// f_crawl := false ;
77767: LD_ADDR_VAR 0 26
77771: PUSH
77772: LD_INT 0
77774: ST_TO_ADDR
// end ; if f_heal then
77775: LD_VAR 0 23
77779: IFFALSE 77806
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77781: LD_ADDR_VAR 0 31
77785: PUSH
77786: LD_VAR 0 4
77790: PPUSH
77791: LD_INT 25
77793: PUSH
77794: LD_INT 4
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PPUSH
77801: CALL_OW 72
77805: ST_TO_ADDR
// if f_repair then
77806: LD_VAR 0 22
77810: IFFALSE 77837
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77812: LD_ADDR_VAR 0 33
77816: PUSH
77817: LD_VAR 0 4
77821: PPUSH
77822: LD_INT 25
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PPUSH
77832: CALL_OW 72
77836: ST_TO_ADDR
// units_path := [ ] ;
77837: LD_ADDR_VAR 0 16
77841: PUSH
77842: EMPTY
77843: ST_TO_ADDR
// for i = 1 to group do
77844: LD_ADDR_VAR 0 7
77848: PUSH
77849: DOUBLE
77850: LD_INT 1
77852: DEC
77853: ST_TO_ADDR
77854: LD_VAR 0 4
77858: PUSH
77859: FOR_TO
77860: IFFALSE 77889
// units_path := Replace ( units_path , i , path ) ;
77862: LD_ADDR_VAR 0 16
77866: PUSH
77867: LD_VAR 0 16
77871: PPUSH
77872: LD_VAR 0 7
77876: PPUSH
77877: LD_VAR 0 5
77881: PPUSH
77882: CALL_OW 1
77886: ST_TO_ADDR
77887: GO 77859
77889: POP
77890: POP
// repeat for i = group downto 1 do
77891: LD_ADDR_VAR 0 7
77895: PUSH
77896: DOUBLE
77897: LD_VAR 0 4
77901: INC
77902: ST_TO_ADDR
77903: LD_INT 1
77905: PUSH
77906: FOR_DOWNTO
77907: IFFALSE 82029
// begin wait ( 5 ) ;
77909: LD_INT 5
77911: PPUSH
77912: CALL_OW 67
// tmp := [ ] ;
77916: LD_ADDR_VAR 0 14
77920: PUSH
77921: EMPTY
77922: ST_TO_ADDR
// attacking := false ;
77923: LD_ADDR_VAR 0 29
77927: PUSH
77928: LD_INT 0
77930: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77931: LD_VAR 0 4
77935: PUSH
77936: LD_VAR 0 7
77940: ARRAY
77941: PPUSH
77942: CALL_OW 301
77946: PUSH
77947: LD_VAR 0 4
77951: PUSH
77952: LD_VAR 0 7
77956: ARRAY
77957: NOT
77958: OR
77959: IFFALSE 78068
// begin if GetType ( group [ i ] ) = unit_human then
77961: LD_VAR 0 4
77965: PUSH
77966: LD_VAR 0 7
77970: ARRAY
77971: PPUSH
77972: CALL_OW 247
77976: PUSH
77977: LD_INT 1
77979: EQUAL
77980: IFFALSE 78026
// begin to_heal := to_heal diff group [ i ] ;
77982: LD_ADDR_VAR 0 30
77986: PUSH
77987: LD_VAR 0 30
77991: PUSH
77992: LD_VAR 0 4
77996: PUSH
77997: LD_VAR 0 7
78001: ARRAY
78002: DIFF
78003: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78004: LD_ADDR_VAR 0 31
78008: PUSH
78009: LD_VAR 0 31
78013: PUSH
78014: LD_VAR 0 4
78018: PUSH
78019: LD_VAR 0 7
78023: ARRAY
78024: DIFF
78025: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78026: LD_ADDR_VAR 0 4
78030: PUSH
78031: LD_VAR 0 4
78035: PPUSH
78036: LD_VAR 0 7
78040: PPUSH
78041: CALL_OW 3
78045: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78046: LD_ADDR_VAR 0 16
78050: PUSH
78051: LD_VAR 0 16
78055: PPUSH
78056: LD_VAR 0 7
78060: PPUSH
78061: CALL_OW 3
78065: ST_TO_ADDR
// continue ;
78066: GO 77906
// end ; if f_repair then
78068: LD_VAR 0 22
78072: IFFALSE 78561
// begin if GetType ( group [ i ] ) = unit_vehicle then
78074: LD_VAR 0 4
78078: PUSH
78079: LD_VAR 0 7
78083: ARRAY
78084: PPUSH
78085: CALL_OW 247
78089: PUSH
78090: LD_INT 2
78092: EQUAL
78093: IFFALSE 78283
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78095: LD_VAR 0 4
78099: PUSH
78100: LD_VAR 0 7
78104: ARRAY
78105: PPUSH
78106: CALL_OW 256
78110: PUSH
78111: LD_INT 700
78113: LESS
78114: PUSH
78115: LD_VAR 0 4
78119: PUSH
78120: LD_VAR 0 7
78124: ARRAY
78125: PUSH
78126: LD_VAR 0 32
78130: IN
78131: NOT
78132: AND
78133: IFFALSE 78157
// to_repair := to_repair union group [ i ] ;
78135: LD_ADDR_VAR 0 32
78139: PUSH
78140: LD_VAR 0 32
78144: PUSH
78145: LD_VAR 0 4
78149: PUSH
78150: LD_VAR 0 7
78154: ARRAY
78155: UNION
78156: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78157: LD_VAR 0 4
78161: PUSH
78162: LD_VAR 0 7
78166: ARRAY
78167: PPUSH
78168: CALL_OW 256
78172: PUSH
78173: LD_INT 1000
78175: EQUAL
78176: PUSH
78177: LD_VAR 0 4
78181: PUSH
78182: LD_VAR 0 7
78186: ARRAY
78187: PUSH
78188: LD_VAR 0 32
78192: IN
78193: AND
78194: IFFALSE 78218
// to_repair := to_repair diff group [ i ] ;
78196: LD_ADDR_VAR 0 32
78200: PUSH
78201: LD_VAR 0 32
78205: PUSH
78206: LD_VAR 0 4
78210: PUSH
78211: LD_VAR 0 7
78215: ARRAY
78216: DIFF
78217: ST_TO_ADDR
// if group [ i ] in to_repair then
78218: LD_VAR 0 4
78222: PUSH
78223: LD_VAR 0 7
78227: ARRAY
78228: PUSH
78229: LD_VAR 0 32
78233: IN
78234: IFFALSE 78281
// begin if not IsInArea ( group [ i ] , f_repair ) then
78236: LD_VAR 0 4
78240: PUSH
78241: LD_VAR 0 7
78245: ARRAY
78246: PPUSH
78247: LD_VAR 0 22
78251: PPUSH
78252: CALL_OW 308
78256: NOT
78257: IFFALSE 78279
// ComMoveToArea ( group [ i ] , f_repair ) ;
78259: LD_VAR 0 4
78263: PUSH
78264: LD_VAR 0 7
78268: ARRAY
78269: PPUSH
78270: LD_VAR 0 22
78274: PPUSH
78275: CALL_OW 113
// continue ;
78279: GO 77906
// end ; end else
78281: GO 78561
// if group [ i ] in repairs then
78283: LD_VAR 0 4
78287: PUSH
78288: LD_VAR 0 7
78292: ARRAY
78293: PUSH
78294: LD_VAR 0 33
78298: IN
78299: IFFALSE 78561
// begin if IsInUnit ( group [ i ] ) then
78301: LD_VAR 0 4
78305: PUSH
78306: LD_VAR 0 7
78310: ARRAY
78311: PPUSH
78312: CALL_OW 310
78316: IFFALSE 78384
// begin z := IsInUnit ( group [ i ] ) ;
78318: LD_ADDR_VAR 0 13
78322: PUSH
78323: LD_VAR 0 4
78327: PUSH
78328: LD_VAR 0 7
78332: ARRAY
78333: PPUSH
78334: CALL_OW 310
78338: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78339: LD_VAR 0 13
78343: PUSH
78344: LD_VAR 0 32
78348: IN
78349: PUSH
78350: LD_VAR 0 13
78354: PPUSH
78355: LD_VAR 0 22
78359: PPUSH
78360: CALL_OW 308
78364: AND
78365: IFFALSE 78382
// ComExitVehicle ( group [ i ] ) ;
78367: LD_VAR 0 4
78371: PUSH
78372: LD_VAR 0 7
78376: ARRAY
78377: PPUSH
78378: CALL_OW 121
// end else
78382: GO 78561
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78384: LD_ADDR_VAR 0 13
78388: PUSH
78389: LD_VAR 0 4
78393: PPUSH
78394: LD_INT 95
78396: PUSH
78397: LD_VAR 0 22
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 58
78408: PUSH
78409: EMPTY
78410: LIST
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PPUSH
78416: CALL_OW 72
78420: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78421: LD_VAR 0 4
78425: PUSH
78426: LD_VAR 0 7
78430: ARRAY
78431: PPUSH
78432: CALL_OW 314
78436: NOT
78437: IFFALSE 78559
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78439: LD_ADDR_VAR 0 10
78443: PUSH
78444: LD_VAR 0 13
78448: PPUSH
78449: LD_VAR 0 4
78453: PUSH
78454: LD_VAR 0 7
78458: ARRAY
78459: PPUSH
78460: CALL_OW 74
78464: ST_TO_ADDR
// if not x then
78465: LD_VAR 0 10
78469: NOT
78470: IFFALSE 78474
// continue ;
78472: GO 77906
// if GetLives ( x ) < 1000 then
78474: LD_VAR 0 10
78478: PPUSH
78479: CALL_OW 256
78483: PUSH
78484: LD_INT 1000
78486: LESS
78487: IFFALSE 78511
// ComRepairVehicle ( group [ i ] , x ) else
78489: LD_VAR 0 4
78493: PUSH
78494: LD_VAR 0 7
78498: ARRAY
78499: PPUSH
78500: LD_VAR 0 10
78504: PPUSH
78505: CALL_OW 129
78509: GO 78559
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78511: LD_VAR 0 23
78515: PUSH
78516: LD_VAR 0 4
78520: PUSH
78521: LD_VAR 0 7
78525: ARRAY
78526: PPUSH
78527: CALL_OW 256
78531: PUSH
78532: LD_INT 1000
78534: LESS
78535: AND
78536: NOT
78537: IFFALSE 78559
// ComEnterUnit ( group [ i ] , x ) ;
78539: LD_VAR 0 4
78543: PUSH
78544: LD_VAR 0 7
78548: ARRAY
78549: PPUSH
78550: LD_VAR 0 10
78554: PPUSH
78555: CALL_OW 120
// end ; continue ;
78559: GO 77906
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78561: LD_VAR 0 23
78565: PUSH
78566: LD_VAR 0 4
78570: PUSH
78571: LD_VAR 0 7
78575: ARRAY
78576: PPUSH
78577: CALL_OW 247
78581: PUSH
78582: LD_INT 1
78584: EQUAL
78585: AND
78586: IFFALSE 79064
// begin if group [ i ] in healers then
78588: LD_VAR 0 4
78592: PUSH
78593: LD_VAR 0 7
78597: ARRAY
78598: PUSH
78599: LD_VAR 0 31
78603: IN
78604: IFFALSE 78877
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78606: LD_VAR 0 4
78610: PUSH
78611: LD_VAR 0 7
78615: ARRAY
78616: PPUSH
78617: LD_VAR 0 23
78621: PPUSH
78622: CALL_OW 308
78626: NOT
78627: PUSH
78628: LD_VAR 0 4
78632: PUSH
78633: LD_VAR 0 7
78637: ARRAY
78638: PPUSH
78639: CALL_OW 314
78643: NOT
78644: AND
78645: IFFALSE 78669
// ComMoveToArea ( group [ i ] , f_heal ) else
78647: LD_VAR 0 4
78651: PUSH
78652: LD_VAR 0 7
78656: ARRAY
78657: PPUSH
78658: LD_VAR 0 23
78662: PPUSH
78663: CALL_OW 113
78667: GO 78875
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78669: LD_VAR 0 4
78673: PUSH
78674: LD_VAR 0 7
78678: ARRAY
78679: PPUSH
78680: CALL 43181 0 1
78684: PPUSH
78685: CALL_OW 256
78689: PUSH
78690: LD_INT 1000
78692: EQUAL
78693: IFFALSE 78712
// ComStop ( group [ i ] ) else
78695: LD_VAR 0 4
78699: PUSH
78700: LD_VAR 0 7
78704: ARRAY
78705: PPUSH
78706: CALL_OW 141
78710: GO 78875
// if not HasTask ( group [ i ] ) and to_heal then
78712: LD_VAR 0 4
78716: PUSH
78717: LD_VAR 0 7
78721: ARRAY
78722: PPUSH
78723: CALL_OW 314
78727: NOT
78728: PUSH
78729: LD_VAR 0 30
78733: AND
78734: IFFALSE 78875
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78736: LD_ADDR_VAR 0 13
78740: PUSH
78741: LD_VAR 0 30
78745: PPUSH
78746: LD_INT 3
78748: PUSH
78749: LD_INT 54
78751: PUSH
78752: EMPTY
78753: LIST
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PPUSH
78759: CALL_OW 72
78763: PPUSH
78764: LD_VAR 0 4
78768: PUSH
78769: LD_VAR 0 7
78773: ARRAY
78774: PPUSH
78775: CALL_OW 74
78779: ST_TO_ADDR
// if z then
78780: LD_VAR 0 13
78784: IFFALSE 78875
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78786: LD_INT 91
78788: PUSH
78789: LD_VAR 0 13
78793: PUSH
78794: LD_INT 10
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 81
78804: PUSH
78805: LD_VAR 0 13
78809: PPUSH
78810: CALL_OW 255
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PPUSH
78823: CALL_OW 69
78827: PUSH
78828: LD_INT 0
78830: EQUAL
78831: IFFALSE 78855
// ComHeal ( group [ i ] , z ) else
78833: LD_VAR 0 4
78837: PUSH
78838: LD_VAR 0 7
78842: ARRAY
78843: PPUSH
78844: LD_VAR 0 13
78848: PPUSH
78849: CALL_OW 128
78853: GO 78875
// ComMoveToArea ( group [ i ] , f_heal ) ;
78855: LD_VAR 0 4
78859: PUSH
78860: LD_VAR 0 7
78864: ARRAY
78865: PPUSH
78866: LD_VAR 0 23
78870: PPUSH
78871: CALL_OW 113
// end ; continue ;
78875: GO 77906
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78877: LD_VAR 0 4
78881: PUSH
78882: LD_VAR 0 7
78886: ARRAY
78887: PPUSH
78888: CALL_OW 256
78892: PUSH
78893: LD_INT 700
78895: LESS
78896: PUSH
78897: LD_VAR 0 4
78901: PUSH
78902: LD_VAR 0 7
78906: ARRAY
78907: PUSH
78908: LD_VAR 0 30
78912: IN
78913: NOT
78914: AND
78915: IFFALSE 78939
// to_heal := to_heal union group [ i ] ;
78917: LD_ADDR_VAR 0 30
78921: PUSH
78922: LD_VAR 0 30
78926: PUSH
78927: LD_VAR 0 4
78931: PUSH
78932: LD_VAR 0 7
78936: ARRAY
78937: UNION
78938: ST_TO_ADDR
// if group [ i ] in to_heal then
78939: LD_VAR 0 4
78943: PUSH
78944: LD_VAR 0 7
78948: ARRAY
78949: PUSH
78950: LD_VAR 0 30
78954: IN
78955: IFFALSE 79064
// begin if GetLives ( group [ i ] ) = 1000 then
78957: LD_VAR 0 4
78961: PUSH
78962: LD_VAR 0 7
78966: ARRAY
78967: PPUSH
78968: CALL_OW 256
78972: PUSH
78973: LD_INT 1000
78975: EQUAL
78976: IFFALSE 79002
// to_heal := to_heal diff group [ i ] else
78978: LD_ADDR_VAR 0 30
78982: PUSH
78983: LD_VAR 0 30
78987: PUSH
78988: LD_VAR 0 4
78992: PUSH
78993: LD_VAR 0 7
78997: ARRAY
78998: DIFF
78999: ST_TO_ADDR
79000: GO 79064
// begin if not IsInArea ( group [ i ] , to_heal ) then
79002: LD_VAR 0 4
79006: PUSH
79007: LD_VAR 0 7
79011: ARRAY
79012: PPUSH
79013: LD_VAR 0 30
79017: PPUSH
79018: CALL_OW 308
79022: NOT
79023: IFFALSE 79047
// ComMoveToArea ( group [ i ] , f_heal ) else
79025: LD_VAR 0 4
79029: PUSH
79030: LD_VAR 0 7
79034: ARRAY
79035: PPUSH
79036: LD_VAR 0 23
79040: PPUSH
79041: CALL_OW 113
79045: GO 79062
// ComHold ( group [ i ] ) ;
79047: LD_VAR 0 4
79051: PUSH
79052: LD_VAR 0 7
79056: ARRAY
79057: PPUSH
79058: CALL_OW 140
// continue ;
79062: GO 77906
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79064: LD_VAR 0 4
79068: PUSH
79069: LD_VAR 0 7
79073: ARRAY
79074: PPUSH
79075: LD_INT 10
79077: PPUSH
79078: CALL 41601 0 2
79082: NOT
79083: PUSH
79084: LD_VAR 0 16
79088: PUSH
79089: LD_VAR 0 7
79093: ARRAY
79094: PUSH
79095: EMPTY
79096: EQUAL
79097: NOT
79098: AND
79099: IFFALSE 79365
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79101: LD_VAR 0 4
79105: PUSH
79106: LD_VAR 0 7
79110: ARRAY
79111: PPUSH
79112: CALL_OW 262
79116: PUSH
79117: LD_INT 1
79119: PUSH
79120: LD_INT 2
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: IN
79127: IFFALSE 79168
// if GetFuel ( group [ i ] ) < 10 then
79129: LD_VAR 0 4
79133: PUSH
79134: LD_VAR 0 7
79138: ARRAY
79139: PPUSH
79140: CALL_OW 261
79144: PUSH
79145: LD_INT 10
79147: LESS
79148: IFFALSE 79168
// SetFuel ( group [ i ] , 12 ) ;
79150: LD_VAR 0 4
79154: PUSH
79155: LD_VAR 0 7
79159: ARRAY
79160: PPUSH
79161: LD_INT 12
79163: PPUSH
79164: CALL_OW 240
// if units_path [ i ] then
79168: LD_VAR 0 16
79172: PUSH
79173: LD_VAR 0 7
79177: ARRAY
79178: IFFALSE 79363
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79180: LD_VAR 0 4
79184: PUSH
79185: LD_VAR 0 7
79189: ARRAY
79190: PPUSH
79191: LD_VAR 0 16
79195: PUSH
79196: LD_VAR 0 7
79200: ARRAY
79201: PUSH
79202: LD_INT 1
79204: ARRAY
79205: PUSH
79206: LD_INT 1
79208: ARRAY
79209: PPUSH
79210: LD_VAR 0 16
79214: PUSH
79215: LD_VAR 0 7
79219: ARRAY
79220: PUSH
79221: LD_INT 1
79223: ARRAY
79224: PUSH
79225: LD_INT 2
79227: ARRAY
79228: PPUSH
79229: CALL_OW 297
79233: PUSH
79234: LD_INT 6
79236: GREATER
79237: IFFALSE 79312
// begin if not HasTask ( group [ i ] ) then
79239: LD_VAR 0 4
79243: PUSH
79244: LD_VAR 0 7
79248: ARRAY
79249: PPUSH
79250: CALL_OW 314
79254: NOT
79255: IFFALSE 79310
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79257: LD_VAR 0 4
79261: PUSH
79262: LD_VAR 0 7
79266: ARRAY
79267: PPUSH
79268: LD_VAR 0 16
79272: PUSH
79273: LD_VAR 0 7
79277: ARRAY
79278: PUSH
79279: LD_INT 1
79281: ARRAY
79282: PUSH
79283: LD_INT 1
79285: ARRAY
79286: PPUSH
79287: LD_VAR 0 16
79291: PUSH
79292: LD_VAR 0 7
79296: ARRAY
79297: PUSH
79298: LD_INT 1
79300: ARRAY
79301: PUSH
79302: LD_INT 2
79304: ARRAY
79305: PPUSH
79306: CALL_OW 114
// end else
79310: GO 79363
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79312: LD_ADDR_VAR 0 15
79316: PUSH
79317: LD_VAR 0 16
79321: PUSH
79322: LD_VAR 0 7
79326: ARRAY
79327: PPUSH
79328: LD_INT 1
79330: PPUSH
79331: CALL_OW 3
79335: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79336: LD_ADDR_VAR 0 16
79340: PUSH
79341: LD_VAR 0 16
79345: PPUSH
79346: LD_VAR 0 7
79350: PPUSH
79351: LD_VAR 0 15
79355: PPUSH
79356: CALL_OW 1
79360: ST_TO_ADDR
// continue ;
79361: GO 77906
// end ; end ; end else
79363: GO 82027
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79365: LD_ADDR_VAR 0 14
79369: PUSH
79370: LD_INT 81
79372: PUSH
79373: LD_VAR 0 4
79377: PUSH
79378: LD_VAR 0 7
79382: ARRAY
79383: PPUSH
79384: CALL_OW 255
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PPUSH
79393: CALL_OW 69
79397: ST_TO_ADDR
// if not tmp then
79398: LD_VAR 0 14
79402: NOT
79403: IFFALSE 79407
// continue ;
79405: GO 77906
// if f_ignore_area then
79407: LD_VAR 0 17
79411: IFFALSE 79499
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79413: LD_ADDR_VAR 0 15
79417: PUSH
79418: LD_VAR 0 14
79422: PPUSH
79423: LD_INT 3
79425: PUSH
79426: LD_INT 92
79428: PUSH
79429: LD_VAR 0 17
79433: PUSH
79434: LD_INT 1
79436: ARRAY
79437: PUSH
79438: LD_VAR 0 17
79442: PUSH
79443: LD_INT 2
79445: ARRAY
79446: PUSH
79447: LD_VAR 0 17
79451: PUSH
79452: LD_INT 3
79454: ARRAY
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PPUSH
79466: CALL_OW 72
79470: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79471: LD_VAR 0 14
79475: PUSH
79476: LD_VAR 0 15
79480: DIFF
79481: IFFALSE 79499
// tmp := tmp diff tmp2 ;
79483: LD_ADDR_VAR 0 14
79487: PUSH
79488: LD_VAR 0 14
79492: PUSH
79493: LD_VAR 0 15
79497: DIFF
79498: ST_TO_ADDR
// end ; if not f_murder then
79499: LD_VAR 0 20
79503: NOT
79504: IFFALSE 79562
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79506: LD_ADDR_VAR 0 15
79510: PUSH
79511: LD_VAR 0 14
79515: PPUSH
79516: LD_INT 3
79518: PUSH
79519: LD_INT 50
79521: PUSH
79522: EMPTY
79523: LIST
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PPUSH
79529: CALL_OW 72
79533: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79534: LD_VAR 0 14
79538: PUSH
79539: LD_VAR 0 15
79543: DIFF
79544: IFFALSE 79562
// tmp := tmp diff tmp2 ;
79546: LD_ADDR_VAR 0 14
79550: PUSH
79551: LD_VAR 0 14
79555: PUSH
79556: LD_VAR 0 15
79560: DIFF
79561: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79562: LD_ADDR_VAR 0 14
79566: PUSH
79567: LD_VAR 0 4
79571: PUSH
79572: LD_VAR 0 7
79576: ARRAY
79577: PPUSH
79578: LD_VAR 0 14
79582: PPUSH
79583: LD_INT 1
79585: PPUSH
79586: LD_INT 1
79588: PPUSH
79589: CALL 15232 0 4
79593: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79594: LD_VAR 0 4
79598: PUSH
79599: LD_VAR 0 7
79603: ARRAY
79604: PPUSH
79605: CALL_OW 257
79609: PUSH
79610: LD_INT 1
79612: EQUAL
79613: IFFALSE 80061
// begin if WantPlant ( group [ i ] ) then
79615: LD_VAR 0 4
79619: PUSH
79620: LD_VAR 0 7
79624: ARRAY
79625: PPUSH
79626: CALL 14733 0 1
79630: IFFALSE 79634
// continue ;
79632: GO 77906
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79634: LD_VAR 0 18
79638: PUSH
79639: LD_VAR 0 4
79643: PUSH
79644: LD_VAR 0 7
79648: ARRAY
79649: PPUSH
79650: CALL_OW 310
79654: NOT
79655: AND
79656: PUSH
79657: LD_VAR 0 14
79661: PUSH
79662: LD_INT 1
79664: ARRAY
79665: PUSH
79666: LD_VAR 0 14
79670: PPUSH
79671: LD_INT 21
79673: PUSH
79674: LD_INT 2
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 58
79683: PUSH
79684: EMPTY
79685: LIST
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PPUSH
79691: CALL_OW 72
79695: IN
79696: AND
79697: IFFALSE 79733
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79699: LD_VAR 0 4
79703: PUSH
79704: LD_VAR 0 7
79708: ARRAY
79709: PPUSH
79710: LD_VAR 0 14
79714: PUSH
79715: LD_INT 1
79717: ARRAY
79718: PPUSH
79719: CALL_OW 120
// attacking := true ;
79723: LD_ADDR_VAR 0 29
79727: PUSH
79728: LD_INT 1
79730: ST_TO_ADDR
// continue ;
79731: GO 77906
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79733: LD_VAR 0 26
79737: PUSH
79738: LD_VAR 0 4
79742: PUSH
79743: LD_VAR 0 7
79747: ARRAY
79748: PPUSH
79749: CALL_OW 257
79753: PUSH
79754: LD_INT 1
79756: EQUAL
79757: AND
79758: PUSH
79759: LD_VAR 0 4
79763: PUSH
79764: LD_VAR 0 7
79768: ARRAY
79769: PPUSH
79770: CALL_OW 256
79774: PUSH
79775: LD_INT 800
79777: LESS
79778: AND
79779: PUSH
79780: LD_VAR 0 4
79784: PUSH
79785: LD_VAR 0 7
79789: ARRAY
79790: PPUSH
79791: CALL_OW 318
79795: NOT
79796: AND
79797: IFFALSE 79814
// ComCrawl ( group [ i ] ) ;
79799: LD_VAR 0 4
79803: PUSH
79804: LD_VAR 0 7
79808: ARRAY
79809: PPUSH
79810: CALL_OW 137
// if f_mines then
79814: LD_VAR 0 21
79818: IFFALSE 80061
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79820: LD_VAR 0 14
79824: PUSH
79825: LD_INT 1
79827: ARRAY
79828: PPUSH
79829: CALL_OW 247
79833: PUSH
79834: LD_INT 3
79836: EQUAL
79837: PUSH
79838: LD_VAR 0 14
79842: PUSH
79843: LD_INT 1
79845: ARRAY
79846: PUSH
79847: LD_VAR 0 27
79851: IN
79852: NOT
79853: AND
79854: IFFALSE 80061
// begin x := GetX ( tmp [ 1 ] ) ;
79856: LD_ADDR_VAR 0 10
79860: PUSH
79861: LD_VAR 0 14
79865: PUSH
79866: LD_INT 1
79868: ARRAY
79869: PPUSH
79870: CALL_OW 250
79874: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79875: LD_ADDR_VAR 0 11
79879: PUSH
79880: LD_VAR 0 14
79884: PUSH
79885: LD_INT 1
79887: ARRAY
79888: PPUSH
79889: CALL_OW 251
79893: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79894: LD_ADDR_VAR 0 12
79898: PUSH
79899: LD_VAR 0 4
79903: PUSH
79904: LD_VAR 0 7
79908: ARRAY
79909: PPUSH
79910: CALL 41686 0 1
79914: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79915: LD_VAR 0 4
79919: PUSH
79920: LD_VAR 0 7
79924: ARRAY
79925: PPUSH
79926: LD_VAR 0 10
79930: PPUSH
79931: LD_VAR 0 11
79935: PPUSH
79936: LD_VAR 0 14
79940: PUSH
79941: LD_INT 1
79943: ARRAY
79944: PPUSH
79945: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79949: LD_VAR 0 4
79953: PUSH
79954: LD_VAR 0 7
79958: ARRAY
79959: PPUSH
79960: LD_VAR 0 10
79964: PPUSH
79965: LD_VAR 0 12
79969: PPUSH
79970: LD_INT 7
79972: PPUSH
79973: CALL_OW 272
79977: PPUSH
79978: LD_VAR 0 11
79982: PPUSH
79983: LD_VAR 0 12
79987: PPUSH
79988: LD_INT 7
79990: PPUSH
79991: CALL_OW 273
79995: PPUSH
79996: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80000: LD_VAR 0 4
80004: PUSH
80005: LD_VAR 0 7
80009: ARRAY
80010: PPUSH
80011: LD_INT 71
80013: PPUSH
80014: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80018: LD_ADDR_VAR 0 27
80022: PUSH
80023: LD_VAR 0 27
80027: PPUSH
80028: LD_VAR 0 27
80032: PUSH
80033: LD_INT 1
80035: PLUS
80036: PPUSH
80037: LD_VAR 0 14
80041: PUSH
80042: LD_INT 1
80044: ARRAY
80045: PPUSH
80046: CALL_OW 1
80050: ST_TO_ADDR
// attacking := true ;
80051: LD_ADDR_VAR 0 29
80055: PUSH
80056: LD_INT 1
80058: ST_TO_ADDR
// continue ;
80059: GO 77906
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80061: LD_VAR 0 4
80065: PUSH
80066: LD_VAR 0 7
80070: ARRAY
80071: PPUSH
80072: CALL_OW 257
80076: PUSH
80077: LD_INT 17
80079: EQUAL
80080: PUSH
80081: LD_VAR 0 4
80085: PUSH
80086: LD_VAR 0 7
80090: ARRAY
80091: PPUSH
80092: CALL_OW 110
80096: PUSH
80097: LD_INT 71
80099: EQUAL
80100: NOT
80101: AND
80102: IFFALSE 80248
// begin attacking := false ;
80104: LD_ADDR_VAR 0 29
80108: PUSH
80109: LD_INT 0
80111: ST_TO_ADDR
// k := 5 ;
80112: LD_ADDR_VAR 0 9
80116: PUSH
80117: LD_INT 5
80119: ST_TO_ADDR
// if tmp < k then
80120: LD_VAR 0 14
80124: PUSH
80125: LD_VAR 0 9
80129: LESS
80130: IFFALSE 80142
// k := tmp ;
80132: LD_ADDR_VAR 0 9
80136: PUSH
80137: LD_VAR 0 14
80141: ST_TO_ADDR
// for j = 1 to k do
80142: LD_ADDR_VAR 0 8
80146: PUSH
80147: DOUBLE
80148: LD_INT 1
80150: DEC
80151: ST_TO_ADDR
80152: LD_VAR 0 9
80156: PUSH
80157: FOR_TO
80158: IFFALSE 80246
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80160: LD_VAR 0 14
80164: PUSH
80165: LD_VAR 0 8
80169: ARRAY
80170: PUSH
80171: LD_VAR 0 14
80175: PPUSH
80176: LD_INT 58
80178: PUSH
80179: EMPTY
80180: LIST
80181: PPUSH
80182: CALL_OW 72
80186: IN
80187: NOT
80188: IFFALSE 80244
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80190: LD_VAR 0 4
80194: PUSH
80195: LD_VAR 0 7
80199: ARRAY
80200: PPUSH
80201: LD_VAR 0 14
80205: PUSH
80206: LD_VAR 0 8
80210: ARRAY
80211: PPUSH
80212: CALL_OW 115
// attacking := true ;
80216: LD_ADDR_VAR 0 29
80220: PUSH
80221: LD_INT 1
80223: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80224: LD_VAR 0 4
80228: PUSH
80229: LD_VAR 0 7
80233: ARRAY
80234: PPUSH
80235: LD_INT 71
80237: PPUSH
80238: CALL_OW 109
// continue ;
80242: GO 80157
// end ; end ;
80244: GO 80157
80246: POP
80247: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80248: LD_VAR 0 4
80252: PUSH
80253: LD_VAR 0 7
80257: ARRAY
80258: PPUSH
80259: CALL_OW 257
80263: PUSH
80264: LD_INT 8
80266: EQUAL
80267: PUSH
80268: LD_VAR 0 4
80272: PUSH
80273: LD_VAR 0 7
80277: ARRAY
80278: PPUSH
80279: CALL_OW 264
80283: PUSH
80284: LD_INT 28
80286: PUSH
80287: LD_INT 45
80289: PUSH
80290: LD_INT 7
80292: PUSH
80293: LD_INT 47
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: LIST
80300: LIST
80301: IN
80302: OR
80303: IFFALSE 80559
// begin attacking := false ;
80305: LD_ADDR_VAR 0 29
80309: PUSH
80310: LD_INT 0
80312: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80313: LD_VAR 0 14
80317: PUSH
80318: LD_INT 1
80320: ARRAY
80321: PPUSH
80322: CALL_OW 266
80326: PUSH
80327: LD_INT 32
80329: PUSH
80330: LD_INT 31
80332: PUSH
80333: LD_INT 33
80335: PUSH
80336: LD_INT 4
80338: PUSH
80339: LD_INT 5
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: IN
80349: IFFALSE 80535
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80351: LD_ADDR_VAR 0 9
80355: PUSH
80356: LD_VAR 0 14
80360: PUSH
80361: LD_INT 1
80363: ARRAY
80364: PPUSH
80365: CALL_OW 266
80369: PPUSH
80370: LD_VAR 0 14
80374: PUSH
80375: LD_INT 1
80377: ARRAY
80378: PPUSH
80379: CALL_OW 250
80383: PPUSH
80384: LD_VAR 0 14
80388: PUSH
80389: LD_INT 1
80391: ARRAY
80392: PPUSH
80393: CALL_OW 251
80397: PPUSH
80398: LD_VAR 0 14
80402: PUSH
80403: LD_INT 1
80405: ARRAY
80406: PPUSH
80407: CALL_OW 254
80411: PPUSH
80412: LD_VAR 0 14
80416: PUSH
80417: LD_INT 1
80419: ARRAY
80420: PPUSH
80421: CALL_OW 248
80425: PPUSH
80426: LD_INT 0
80428: PPUSH
80429: CALL 23056 0 6
80433: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80434: LD_ADDR_VAR 0 8
80438: PUSH
80439: LD_VAR 0 4
80443: PUSH
80444: LD_VAR 0 7
80448: ARRAY
80449: PPUSH
80450: LD_VAR 0 9
80454: PPUSH
80455: CALL 41726 0 2
80459: ST_TO_ADDR
// if j then
80460: LD_VAR 0 8
80464: IFFALSE 80533
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80466: LD_VAR 0 8
80470: PUSH
80471: LD_INT 1
80473: ARRAY
80474: PPUSH
80475: LD_VAR 0 8
80479: PUSH
80480: LD_INT 2
80482: ARRAY
80483: PPUSH
80484: CALL_OW 488
80488: IFFALSE 80533
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80490: LD_VAR 0 4
80494: PUSH
80495: LD_VAR 0 7
80499: ARRAY
80500: PPUSH
80501: LD_VAR 0 8
80505: PUSH
80506: LD_INT 1
80508: ARRAY
80509: PPUSH
80510: LD_VAR 0 8
80514: PUSH
80515: LD_INT 2
80517: ARRAY
80518: PPUSH
80519: CALL_OW 116
// attacking := true ;
80523: LD_ADDR_VAR 0 29
80527: PUSH
80528: LD_INT 1
80530: ST_TO_ADDR
// continue ;
80531: GO 77906
// end ; end else
80533: GO 80559
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80535: LD_VAR 0 4
80539: PUSH
80540: LD_VAR 0 7
80544: ARRAY
80545: PPUSH
80546: LD_VAR 0 14
80550: PUSH
80551: LD_INT 1
80553: ARRAY
80554: PPUSH
80555: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80559: LD_VAR 0 4
80563: PUSH
80564: LD_VAR 0 7
80568: ARRAY
80569: PPUSH
80570: CALL_OW 265
80574: PUSH
80575: LD_INT 11
80577: EQUAL
80578: IFFALSE 80856
// begin k := 10 ;
80580: LD_ADDR_VAR 0 9
80584: PUSH
80585: LD_INT 10
80587: ST_TO_ADDR
// x := 0 ;
80588: LD_ADDR_VAR 0 10
80592: PUSH
80593: LD_INT 0
80595: ST_TO_ADDR
// if tmp < k then
80596: LD_VAR 0 14
80600: PUSH
80601: LD_VAR 0 9
80605: LESS
80606: IFFALSE 80618
// k := tmp ;
80608: LD_ADDR_VAR 0 9
80612: PUSH
80613: LD_VAR 0 14
80617: ST_TO_ADDR
// for j = k downto 1 do
80618: LD_ADDR_VAR 0 8
80622: PUSH
80623: DOUBLE
80624: LD_VAR 0 9
80628: INC
80629: ST_TO_ADDR
80630: LD_INT 1
80632: PUSH
80633: FOR_DOWNTO
80634: IFFALSE 80709
// begin if GetType ( tmp [ j ] ) = unit_human then
80636: LD_VAR 0 14
80640: PUSH
80641: LD_VAR 0 8
80645: ARRAY
80646: PPUSH
80647: CALL_OW 247
80651: PUSH
80652: LD_INT 1
80654: EQUAL
80655: IFFALSE 80707
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80657: LD_VAR 0 4
80661: PUSH
80662: LD_VAR 0 7
80666: ARRAY
80667: PPUSH
80668: LD_VAR 0 14
80672: PUSH
80673: LD_VAR 0 8
80677: ARRAY
80678: PPUSH
80679: CALL 41997 0 2
// x := tmp [ j ] ;
80683: LD_ADDR_VAR 0 10
80687: PUSH
80688: LD_VAR 0 14
80692: PUSH
80693: LD_VAR 0 8
80697: ARRAY
80698: ST_TO_ADDR
// attacking := true ;
80699: LD_ADDR_VAR 0 29
80703: PUSH
80704: LD_INT 1
80706: ST_TO_ADDR
// end ; end ;
80707: GO 80633
80709: POP
80710: POP
// if not x then
80711: LD_VAR 0 10
80715: NOT
80716: IFFALSE 80856
// begin attacking := true ;
80718: LD_ADDR_VAR 0 29
80722: PUSH
80723: LD_INT 1
80725: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80726: LD_VAR 0 4
80730: PUSH
80731: LD_VAR 0 7
80735: ARRAY
80736: PPUSH
80737: CALL_OW 250
80741: PPUSH
80742: LD_VAR 0 4
80746: PUSH
80747: LD_VAR 0 7
80751: ARRAY
80752: PPUSH
80753: CALL_OW 251
80757: PPUSH
80758: CALL_OW 546
80762: PUSH
80763: LD_INT 2
80765: ARRAY
80766: PUSH
80767: LD_VAR 0 14
80771: PUSH
80772: LD_INT 1
80774: ARRAY
80775: PPUSH
80776: CALL_OW 250
80780: PPUSH
80781: LD_VAR 0 14
80785: PUSH
80786: LD_INT 1
80788: ARRAY
80789: PPUSH
80790: CALL_OW 251
80794: PPUSH
80795: CALL_OW 546
80799: PUSH
80800: LD_INT 2
80802: ARRAY
80803: EQUAL
80804: IFFALSE 80832
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80806: LD_VAR 0 4
80810: PUSH
80811: LD_VAR 0 7
80815: ARRAY
80816: PPUSH
80817: LD_VAR 0 14
80821: PUSH
80822: LD_INT 1
80824: ARRAY
80825: PPUSH
80826: CALL 41997 0 2
80830: GO 80856
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80832: LD_VAR 0 4
80836: PUSH
80837: LD_VAR 0 7
80841: ARRAY
80842: PPUSH
80843: LD_VAR 0 14
80847: PUSH
80848: LD_INT 1
80850: ARRAY
80851: PPUSH
80852: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80856: LD_VAR 0 4
80860: PUSH
80861: LD_VAR 0 7
80865: ARRAY
80866: PPUSH
80867: CALL_OW 264
80871: PUSH
80872: LD_INT 29
80874: EQUAL
80875: IFFALSE 81241
// begin if WantsToAttack ( group [ i ] ) in bombed then
80877: LD_VAR 0 4
80881: PUSH
80882: LD_VAR 0 7
80886: ARRAY
80887: PPUSH
80888: CALL_OW 319
80892: PUSH
80893: LD_VAR 0 28
80897: IN
80898: IFFALSE 80902
// continue ;
80900: GO 77906
// k := 8 ;
80902: LD_ADDR_VAR 0 9
80906: PUSH
80907: LD_INT 8
80909: ST_TO_ADDR
// x := 0 ;
80910: LD_ADDR_VAR 0 10
80914: PUSH
80915: LD_INT 0
80917: ST_TO_ADDR
// if tmp < k then
80918: LD_VAR 0 14
80922: PUSH
80923: LD_VAR 0 9
80927: LESS
80928: IFFALSE 80940
// k := tmp ;
80930: LD_ADDR_VAR 0 9
80934: PUSH
80935: LD_VAR 0 14
80939: ST_TO_ADDR
// for j = 1 to k do
80940: LD_ADDR_VAR 0 8
80944: PUSH
80945: DOUBLE
80946: LD_INT 1
80948: DEC
80949: ST_TO_ADDR
80950: LD_VAR 0 9
80954: PUSH
80955: FOR_TO
80956: IFFALSE 81088
// begin if GetType ( tmp [ j ] ) = unit_building then
80958: LD_VAR 0 14
80962: PUSH
80963: LD_VAR 0 8
80967: ARRAY
80968: PPUSH
80969: CALL_OW 247
80973: PUSH
80974: LD_INT 3
80976: EQUAL
80977: IFFALSE 81086
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80979: LD_VAR 0 14
80983: PUSH
80984: LD_VAR 0 8
80988: ARRAY
80989: PUSH
80990: LD_VAR 0 28
80994: IN
80995: NOT
80996: PUSH
80997: LD_VAR 0 14
81001: PUSH
81002: LD_VAR 0 8
81006: ARRAY
81007: PPUSH
81008: CALL_OW 313
81012: AND
81013: IFFALSE 81086
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81015: LD_VAR 0 4
81019: PUSH
81020: LD_VAR 0 7
81024: ARRAY
81025: PPUSH
81026: LD_VAR 0 14
81030: PUSH
81031: LD_VAR 0 8
81035: ARRAY
81036: PPUSH
81037: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81041: LD_ADDR_VAR 0 28
81045: PUSH
81046: LD_VAR 0 28
81050: PPUSH
81051: LD_VAR 0 28
81055: PUSH
81056: LD_INT 1
81058: PLUS
81059: PPUSH
81060: LD_VAR 0 14
81064: PUSH
81065: LD_VAR 0 8
81069: ARRAY
81070: PPUSH
81071: CALL_OW 1
81075: ST_TO_ADDR
// attacking := true ;
81076: LD_ADDR_VAR 0 29
81080: PUSH
81081: LD_INT 1
81083: ST_TO_ADDR
// break ;
81084: GO 81088
// end ; end ;
81086: GO 80955
81088: POP
81089: POP
// if not attacking and f_attack_depot then
81090: LD_VAR 0 29
81094: NOT
81095: PUSH
81096: LD_VAR 0 25
81100: AND
81101: IFFALSE 81196
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81103: LD_ADDR_VAR 0 13
81107: PUSH
81108: LD_VAR 0 14
81112: PPUSH
81113: LD_INT 2
81115: PUSH
81116: LD_INT 30
81118: PUSH
81119: LD_INT 0
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 30
81128: PUSH
81129: LD_INT 1
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: LIST
81140: PPUSH
81141: CALL_OW 72
81145: ST_TO_ADDR
// if z then
81146: LD_VAR 0 13
81150: IFFALSE 81196
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81152: LD_VAR 0 4
81156: PUSH
81157: LD_VAR 0 7
81161: ARRAY
81162: PPUSH
81163: LD_VAR 0 13
81167: PPUSH
81168: LD_VAR 0 4
81172: PUSH
81173: LD_VAR 0 7
81177: ARRAY
81178: PPUSH
81179: CALL_OW 74
81183: PPUSH
81184: CALL_OW 115
// attacking := true ;
81188: LD_ADDR_VAR 0 29
81192: PUSH
81193: LD_INT 1
81195: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81196: LD_VAR 0 4
81200: PUSH
81201: LD_VAR 0 7
81205: ARRAY
81206: PPUSH
81207: CALL_OW 256
81211: PUSH
81212: LD_INT 500
81214: LESS
81215: IFFALSE 81241
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81217: LD_VAR 0 4
81221: PUSH
81222: LD_VAR 0 7
81226: ARRAY
81227: PPUSH
81228: LD_VAR 0 14
81232: PUSH
81233: LD_INT 1
81235: ARRAY
81236: PPUSH
81237: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81241: LD_VAR 0 4
81245: PUSH
81246: LD_VAR 0 7
81250: ARRAY
81251: PPUSH
81252: CALL_OW 264
81256: PUSH
81257: LD_INT 49
81259: EQUAL
81260: IFFALSE 81381
// begin if not HasTask ( group [ i ] ) then
81262: LD_VAR 0 4
81266: PUSH
81267: LD_VAR 0 7
81271: ARRAY
81272: PPUSH
81273: CALL_OW 314
81277: NOT
81278: IFFALSE 81381
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81280: LD_ADDR_VAR 0 9
81284: PUSH
81285: LD_INT 81
81287: PUSH
81288: LD_VAR 0 4
81292: PUSH
81293: LD_VAR 0 7
81297: ARRAY
81298: PPUSH
81299: CALL_OW 255
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PPUSH
81308: CALL_OW 69
81312: PPUSH
81313: LD_VAR 0 4
81317: PUSH
81318: LD_VAR 0 7
81322: ARRAY
81323: PPUSH
81324: CALL_OW 74
81328: ST_TO_ADDR
// if k then
81329: LD_VAR 0 9
81333: IFFALSE 81381
// if GetDistUnits ( group [ i ] , k ) > 10 then
81335: LD_VAR 0 4
81339: PUSH
81340: LD_VAR 0 7
81344: ARRAY
81345: PPUSH
81346: LD_VAR 0 9
81350: PPUSH
81351: CALL_OW 296
81355: PUSH
81356: LD_INT 10
81358: GREATER
81359: IFFALSE 81381
// ComMoveUnit ( group [ i ] , k ) ;
81361: LD_VAR 0 4
81365: PUSH
81366: LD_VAR 0 7
81370: ARRAY
81371: PPUSH
81372: LD_VAR 0 9
81376: PPUSH
81377: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81381: LD_VAR 0 4
81385: PUSH
81386: LD_VAR 0 7
81390: ARRAY
81391: PPUSH
81392: CALL_OW 256
81396: PUSH
81397: LD_INT 250
81399: LESS
81400: PUSH
81401: LD_VAR 0 4
81405: PUSH
81406: LD_VAR 0 7
81410: ARRAY
81411: PUSH
81412: LD_INT 21
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 23
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PPUSH
81436: CALL_OW 69
81440: IN
81441: AND
81442: IFFALSE 81567
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81444: LD_ADDR_VAR 0 9
81448: PUSH
81449: LD_OWVAR 3
81453: PUSH
81454: LD_VAR 0 4
81458: PUSH
81459: LD_VAR 0 7
81463: ARRAY
81464: DIFF
81465: PPUSH
81466: LD_VAR 0 4
81470: PUSH
81471: LD_VAR 0 7
81475: ARRAY
81476: PPUSH
81477: CALL_OW 74
81481: ST_TO_ADDR
// if not k then
81482: LD_VAR 0 9
81486: NOT
81487: IFFALSE 81491
// continue ;
81489: GO 77906
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81491: LD_VAR 0 9
81495: PUSH
81496: LD_INT 81
81498: PUSH
81499: LD_VAR 0 4
81503: PUSH
81504: LD_VAR 0 7
81508: ARRAY
81509: PPUSH
81510: CALL_OW 255
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PPUSH
81519: CALL_OW 69
81523: IN
81524: PUSH
81525: LD_VAR 0 9
81529: PPUSH
81530: LD_VAR 0 4
81534: PUSH
81535: LD_VAR 0 7
81539: ARRAY
81540: PPUSH
81541: CALL_OW 296
81545: PUSH
81546: LD_INT 5
81548: LESS
81549: AND
81550: IFFALSE 81567
// ComAutodestruct ( group [ i ] ) ;
81552: LD_VAR 0 4
81556: PUSH
81557: LD_VAR 0 7
81561: ARRAY
81562: PPUSH
81563: CALL 41895 0 1
// end ; if f_attack_depot then
81567: LD_VAR 0 25
81571: IFFALSE 81683
// begin k := 6 ;
81573: LD_ADDR_VAR 0 9
81577: PUSH
81578: LD_INT 6
81580: ST_TO_ADDR
// if tmp < k then
81581: LD_VAR 0 14
81585: PUSH
81586: LD_VAR 0 9
81590: LESS
81591: IFFALSE 81603
// k := tmp ;
81593: LD_ADDR_VAR 0 9
81597: PUSH
81598: LD_VAR 0 14
81602: ST_TO_ADDR
// for j = 1 to k do
81603: LD_ADDR_VAR 0 8
81607: PUSH
81608: DOUBLE
81609: LD_INT 1
81611: DEC
81612: ST_TO_ADDR
81613: LD_VAR 0 9
81617: PUSH
81618: FOR_TO
81619: IFFALSE 81681
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81621: LD_VAR 0 8
81625: PPUSH
81626: CALL_OW 266
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: IN
81641: IFFALSE 81679
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81643: LD_VAR 0 4
81647: PUSH
81648: LD_VAR 0 7
81652: ARRAY
81653: PPUSH
81654: LD_VAR 0 14
81658: PUSH
81659: LD_VAR 0 8
81663: ARRAY
81664: PPUSH
81665: CALL_OW 115
// attacking := true ;
81669: LD_ADDR_VAR 0 29
81673: PUSH
81674: LD_INT 1
81676: ST_TO_ADDR
// break ;
81677: GO 81681
// end ;
81679: GO 81618
81681: POP
81682: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81683: LD_VAR 0 4
81687: PUSH
81688: LD_VAR 0 7
81692: ARRAY
81693: PPUSH
81694: CALL_OW 302
81698: PUSH
81699: LD_VAR 0 29
81703: NOT
81704: AND
81705: IFFALSE 82027
// begin if GetTag ( group [ i ] ) = 71 then
81707: LD_VAR 0 4
81711: PUSH
81712: LD_VAR 0 7
81716: ARRAY
81717: PPUSH
81718: CALL_OW 110
81722: PUSH
81723: LD_INT 71
81725: EQUAL
81726: IFFALSE 81767
// begin if HasTask ( group [ i ] ) then
81728: LD_VAR 0 4
81732: PUSH
81733: LD_VAR 0 7
81737: ARRAY
81738: PPUSH
81739: CALL_OW 314
81743: IFFALSE 81749
// continue else
81745: GO 77906
81747: GO 81767
// SetTag ( group [ i ] , 0 ) ;
81749: LD_VAR 0 4
81753: PUSH
81754: LD_VAR 0 7
81758: ARRAY
81759: PPUSH
81760: LD_INT 0
81762: PPUSH
81763: CALL_OW 109
// end ; k := 8 ;
81767: LD_ADDR_VAR 0 9
81771: PUSH
81772: LD_INT 8
81774: ST_TO_ADDR
// x := 0 ;
81775: LD_ADDR_VAR 0 10
81779: PUSH
81780: LD_INT 0
81782: ST_TO_ADDR
// if tmp < k then
81783: LD_VAR 0 14
81787: PUSH
81788: LD_VAR 0 9
81792: LESS
81793: IFFALSE 81805
// k := tmp ;
81795: LD_ADDR_VAR 0 9
81799: PUSH
81800: LD_VAR 0 14
81804: ST_TO_ADDR
// for j = 1 to k do
81805: LD_ADDR_VAR 0 8
81809: PUSH
81810: DOUBLE
81811: LD_INT 1
81813: DEC
81814: ST_TO_ADDR
81815: LD_VAR 0 9
81819: PUSH
81820: FOR_TO
81821: IFFALSE 81919
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81823: LD_VAR 0 14
81827: PUSH
81828: LD_VAR 0 8
81832: ARRAY
81833: PPUSH
81834: CALL_OW 247
81838: PUSH
81839: LD_INT 1
81841: EQUAL
81842: PUSH
81843: LD_VAR 0 14
81847: PUSH
81848: LD_VAR 0 8
81852: ARRAY
81853: PPUSH
81854: CALL_OW 256
81858: PUSH
81859: LD_INT 250
81861: LESS
81862: PUSH
81863: LD_VAR 0 20
81867: AND
81868: PUSH
81869: LD_VAR 0 20
81873: NOT
81874: PUSH
81875: LD_VAR 0 14
81879: PUSH
81880: LD_VAR 0 8
81884: ARRAY
81885: PPUSH
81886: CALL_OW 256
81890: PUSH
81891: LD_INT 250
81893: GREATEREQUAL
81894: AND
81895: OR
81896: AND
81897: IFFALSE 81917
// begin x := tmp [ j ] ;
81899: LD_ADDR_VAR 0 10
81903: PUSH
81904: LD_VAR 0 14
81908: PUSH
81909: LD_VAR 0 8
81913: ARRAY
81914: ST_TO_ADDR
// break ;
81915: GO 81919
// end ;
81917: GO 81820
81919: POP
81920: POP
// if x then
81921: LD_VAR 0 10
81925: IFFALSE 81949
// ComAttackUnit ( group [ i ] , x ) else
81927: LD_VAR 0 4
81931: PUSH
81932: LD_VAR 0 7
81936: ARRAY
81937: PPUSH
81938: LD_VAR 0 10
81942: PPUSH
81943: CALL_OW 115
81947: GO 81973
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81949: LD_VAR 0 4
81953: PUSH
81954: LD_VAR 0 7
81958: ARRAY
81959: PPUSH
81960: LD_VAR 0 14
81964: PUSH
81965: LD_INT 1
81967: ARRAY
81968: PPUSH
81969: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81973: LD_VAR 0 4
81977: PUSH
81978: LD_VAR 0 7
81982: ARRAY
81983: PPUSH
81984: CALL_OW 314
81988: NOT
81989: IFFALSE 82027
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81991: LD_VAR 0 4
81995: PUSH
81996: LD_VAR 0 7
82000: ARRAY
82001: PPUSH
82002: LD_VAR 0 14
82006: PPUSH
82007: LD_VAR 0 4
82011: PUSH
82012: LD_VAR 0 7
82016: ARRAY
82017: PPUSH
82018: CALL_OW 74
82022: PPUSH
82023: CALL_OW 115
// end ; end ; end ;
82027: GO 77906
82029: POP
82030: POP
// wait ( 0 0$2 ) ;
82031: LD_INT 70
82033: PPUSH
82034: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82038: LD_VAR 0 4
82042: NOT
82043: PUSH
82044: LD_VAR 0 4
82048: PUSH
82049: EMPTY
82050: EQUAL
82051: OR
82052: PUSH
82053: LD_INT 81
82055: PUSH
82056: LD_VAR 0 35
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PPUSH
82065: CALL_OW 69
82069: NOT
82070: OR
82071: IFFALSE 77891
// end ;
82073: LD_VAR 0 2
82077: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82078: LD_INT 0
82080: PPUSH
82081: PPUSH
82082: PPUSH
82083: PPUSH
82084: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82085: LD_VAR 0 1
82089: NOT
82090: PUSH
82091: LD_EXP 43
82095: PUSH
82096: LD_VAR 0 1
82100: ARRAY
82101: NOT
82102: OR
82103: PUSH
82104: LD_VAR 0 2
82108: NOT
82109: OR
82110: PUSH
82111: LD_VAR 0 3
82115: NOT
82116: OR
82117: IFFALSE 82121
// exit ;
82119: GO 82634
// side := mc_sides [ base ] ;
82121: LD_ADDR_VAR 0 6
82125: PUSH
82126: LD_EXP 69
82130: PUSH
82131: LD_VAR 0 1
82135: ARRAY
82136: ST_TO_ADDR
// if not side then
82137: LD_VAR 0 6
82141: NOT
82142: IFFALSE 82146
// exit ;
82144: GO 82634
// for i in solds do
82146: LD_ADDR_VAR 0 7
82150: PUSH
82151: LD_VAR 0 2
82155: PUSH
82156: FOR_IN
82157: IFFALSE 82218
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82159: LD_VAR 0 7
82163: PPUSH
82164: CALL_OW 310
82168: PPUSH
82169: CALL_OW 266
82173: PUSH
82174: LD_INT 32
82176: PUSH
82177: LD_INT 31
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: IN
82184: IFFALSE 82204
// solds := solds diff i else
82186: LD_ADDR_VAR 0 2
82190: PUSH
82191: LD_VAR 0 2
82195: PUSH
82196: LD_VAR 0 7
82200: DIFF
82201: ST_TO_ADDR
82202: GO 82216
// SetTag ( i , 18 ) ;
82204: LD_VAR 0 7
82208: PPUSH
82209: LD_INT 18
82211: PPUSH
82212: CALL_OW 109
82216: GO 82156
82218: POP
82219: POP
// if not solds then
82220: LD_VAR 0 2
82224: NOT
82225: IFFALSE 82229
// exit ;
82227: GO 82634
// repeat wait ( 0 0$2 ) ;
82229: LD_INT 70
82231: PPUSH
82232: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82236: LD_ADDR_VAR 0 5
82240: PUSH
82241: LD_VAR 0 6
82245: PPUSH
82246: LD_VAR 0 3
82250: PPUSH
82251: CALL 11598 0 2
82255: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82256: LD_EXP 43
82260: PUSH
82261: LD_VAR 0 1
82265: ARRAY
82266: NOT
82267: PUSH
82268: LD_EXP 43
82272: PUSH
82273: LD_VAR 0 1
82277: ARRAY
82278: PUSH
82279: EMPTY
82280: EQUAL
82281: OR
82282: IFFALSE 82319
// begin for i in solds do
82284: LD_ADDR_VAR 0 7
82288: PUSH
82289: LD_VAR 0 2
82293: PUSH
82294: FOR_IN
82295: IFFALSE 82308
// ComStop ( i ) ;
82297: LD_VAR 0 7
82301: PPUSH
82302: CALL_OW 141
82306: GO 82294
82308: POP
82309: POP
// solds := [ ] ;
82310: LD_ADDR_VAR 0 2
82314: PUSH
82315: EMPTY
82316: ST_TO_ADDR
// exit ;
82317: GO 82634
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82319: LD_VAR 0 5
82323: NOT
82324: PUSH
82325: LD_VAR 0 5
82329: PUSH
82330: LD_INT 3
82332: GREATER
82333: OR
82334: PUSH
82335: LD_EXP 65
82339: PUSH
82340: LD_VAR 0 1
82344: ARRAY
82345: OR
82346: IFFALSE 82387
// begin for i in solds do
82348: LD_ADDR_VAR 0 7
82352: PUSH
82353: LD_VAR 0 2
82357: PUSH
82358: FOR_IN
82359: IFFALSE 82383
// if HasTask ( i ) then
82361: LD_VAR 0 7
82365: PPUSH
82366: CALL_OW 314
82370: IFFALSE 82381
// ComStop ( i ) ;
82372: LD_VAR 0 7
82376: PPUSH
82377: CALL_OW 141
82381: GO 82358
82383: POP
82384: POP
// break ;
82385: GO 82622
// end ; for i in solds do
82387: LD_ADDR_VAR 0 7
82391: PUSH
82392: LD_VAR 0 2
82396: PUSH
82397: FOR_IN
82398: IFFALSE 82614
// begin if IsInUnit ( i ) then
82400: LD_VAR 0 7
82404: PPUSH
82405: CALL_OW 310
82409: IFFALSE 82420
// ComExitBuilding ( i ) ;
82411: LD_VAR 0 7
82415: PPUSH
82416: CALL_OW 122
// if GetLives ( i ) > 333 then
82420: LD_VAR 0 7
82424: PPUSH
82425: CALL_OW 256
82429: PUSH
82430: LD_INT 333
82432: GREATER
82433: IFFALSE 82461
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82435: LD_VAR 0 7
82439: PPUSH
82440: LD_VAR 0 5
82444: PPUSH
82445: LD_VAR 0 7
82449: PPUSH
82450: CALL_OW 74
82454: PPUSH
82455: CALL_OW 115
82459: GO 82612
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82461: LD_ADDR_VAR 0 8
82465: PUSH
82466: LD_EXP 43
82470: PUSH
82471: LD_VAR 0 1
82475: ARRAY
82476: PPUSH
82477: LD_INT 2
82479: PUSH
82480: LD_INT 30
82482: PUSH
82483: LD_INT 0
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 30
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 30
82502: PUSH
82503: LD_INT 6
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: PPUSH
82516: CALL_OW 72
82520: PPUSH
82521: LD_VAR 0 7
82525: PPUSH
82526: CALL_OW 74
82530: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82531: LD_VAR 0 7
82535: PPUSH
82536: LD_VAR 0 8
82540: PPUSH
82541: CALL_OW 250
82545: PPUSH
82546: LD_INT 3
82548: PPUSH
82549: LD_INT 5
82551: PPUSH
82552: CALL_OW 272
82556: PPUSH
82557: LD_VAR 0 8
82561: PPUSH
82562: CALL_OW 251
82566: PPUSH
82567: LD_INT 3
82569: PPUSH
82570: LD_INT 5
82572: PPUSH
82573: CALL_OW 273
82577: PPUSH
82578: CALL_OW 111
// SetTag ( i , 0 ) ;
82582: LD_VAR 0 7
82586: PPUSH
82587: LD_INT 0
82589: PPUSH
82590: CALL_OW 109
// solds := solds diff i ;
82594: LD_ADDR_VAR 0 2
82598: PUSH
82599: LD_VAR 0 2
82603: PUSH
82604: LD_VAR 0 7
82608: DIFF
82609: ST_TO_ADDR
// continue ;
82610: GO 82397
// end ; end ;
82612: GO 82397
82614: POP
82615: POP
// until solds ;
82616: LD_VAR 0 2
82620: IFFALSE 82229
// MC_Reset ( base , 18 ) ;
82622: LD_VAR 0 1
82626: PPUSH
82627: LD_INT 18
82629: PPUSH
82630: CALL 51220 0 2
// end ;
82634: LD_VAR 0 4
82638: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82639: LD_INT 0
82641: PPUSH
82642: PPUSH
82643: PPUSH
82644: PPUSH
82645: PPUSH
82646: PPUSH
82647: PPUSH
82648: PPUSH
82649: PPUSH
82650: PPUSH
82651: PPUSH
82652: PPUSH
82653: PPUSH
82654: PPUSH
82655: PPUSH
82656: PPUSH
82657: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82658: LD_ADDR_VAR 0 13
82662: PUSH
82663: LD_EXP 43
82667: PUSH
82668: LD_VAR 0 1
82672: ARRAY
82673: PPUSH
82674: LD_INT 25
82676: PUSH
82677: LD_INT 3
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PPUSH
82684: CALL_OW 72
82688: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82689: LD_EXP 83
82693: PUSH
82694: LD_VAR 0 1
82698: ARRAY
82699: IFFALSE 82723
// mechs := mechs diff mc_remote_driver [ base ] ;
82701: LD_ADDR_VAR 0 13
82705: PUSH
82706: LD_VAR 0 13
82710: PUSH
82711: LD_EXP 83
82715: PUSH
82716: LD_VAR 0 1
82720: ARRAY
82721: DIFF
82722: ST_TO_ADDR
// for i in mechs do
82723: LD_ADDR_VAR 0 5
82727: PUSH
82728: LD_VAR 0 13
82732: PUSH
82733: FOR_IN
82734: IFFALSE 82769
// if GetTag ( i ) > 0 then
82736: LD_VAR 0 5
82740: PPUSH
82741: CALL_OW 110
82745: PUSH
82746: LD_INT 0
82748: GREATER
82749: IFFALSE 82767
// mechs := mechs diff i ;
82751: LD_ADDR_VAR 0 13
82755: PUSH
82756: LD_VAR 0 13
82760: PUSH
82761: LD_VAR 0 5
82765: DIFF
82766: ST_TO_ADDR
82767: GO 82733
82769: POP
82770: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82771: LD_ADDR_VAR 0 9
82775: PUSH
82776: LD_EXP 43
82780: PUSH
82781: LD_VAR 0 1
82785: ARRAY
82786: PPUSH
82787: LD_INT 2
82789: PUSH
82790: LD_INT 25
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 25
82802: PUSH
82803: LD_INT 5
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 25
82812: PUSH
82813: LD_INT 8
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 25
82822: PUSH
82823: LD_INT 9
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: PPUSH
82837: CALL_OW 72
82841: ST_TO_ADDR
// if not defenders and not solds then
82842: LD_VAR 0 2
82846: NOT
82847: PUSH
82848: LD_VAR 0 9
82852: NOT
82853: AND
82854: IFFALSE 82858
// exit ;
82856: GO 84548
// depot_under_attack := false ;
82858: LD_ADDR_VAR 0 17
82862: PUSH
82863: LD_INT 0
82865: ST_TO_ADDR
// sold_defenders := [ ] ;
82866: LD_ADDR_VAR 0 18
82870: PUSH
82871: EMPTY
82872: ST_TO_ADDR
// if mechs then
82873: LD_VAR 0 13
82877: IFFALSE 83030
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82879: LD_ADDR_VAR 0 5
82883: PUSH
82884: LD_VAR 0 2
82888: PPUSH
82889: LD_INT 21
82891: PUSH
82892: LD_INT 2
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PPUSH
82899: CALL_OW 72
82903: PUSH
82904: FOR_IN
82905: IFFALSE 83028
// begin if GetTag ( i ) <> 20 then
82907: LD_VAR 0 5
82911: PPUSH
82912: CALL_OW 110
82916: PUSH
82917: LD_INT 20
82919: NONEQUAL
82920: IFFALSE 82934
// SetTag ( i , 20 ) ;
82922: LD_VAR 0 5
82926: PPUSH
82927: LD_INT 20
82929: PPUSH
82930: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82934: LD_VAR 0 5
82938: PPUSH
82939: CALL_OW 263
82943: PUSH
82944: LD_INT 1
82946: EQUAL
82947: PUSH
82948: LD_VAR 0 5
82952: PPUSH
82953: CALL_OW 311
82957: NOT
82958: AND
82959: IFFALSE 83026
// begin un := mechs [ 1 ] ;
82961: LD_ADDR_VAR 0 11
82965: PUSH
82966: LD_VAR 0 13
82970: PUSH
82971: LD_INT 1
82973: ARRAY
82974: ST_TO_ADDR
// ComExit ( un ) ;
82975: LD_VAR 0 11
82979: PPUSH
82980: CALL 46240 0 1
// AddComEnterUnit ( un , i ) ;
82984: LD_VAR 0 11
82988: PPUSH
82989: LD_VAR 0 5
82993: PPUSH
82994: CALL_OW 180
// SetTag ( un , 19 ) ;
82998: LD_VAR 0 11
83002: PPUSH
83003: LD_INT 19
83005: PPUSH
83006: CALL_OW 109
// mechs := mechs diff un ;
83010: LD_ADDR_VAR 0 13
83014: PUSH
83015: LD_VAR 0 13
83019: PUSH
83020: LD_VAR 0 11
83024: DIFF
83025: ST_TO_ADDR
// end ; end ;
83026: GO 82904
83028: POP
83029: POP
// if solds then
83030: LD_VAR 0 9
83034: IFFALSE 83093
// for i in solds do
83036: LD_ADDR_VAR 0 5
83040: PUSH
83041: LD_VAR 0 9
83045: PUSH
83046: FOR_IN
83047: IFFALSE 83091
// if not GetTag ( i ) then
83049: LD_VAR 0 5
83053: PPUSH
83054: CALL_OW 110
83058: NOT
83059: IFFALSE 83089
// begin defenders := defenders union i ;
83061: LD_ADDR_VAR 0 2
83065: PUSH
83066: LD_VAR 0 2
83070: PUSH
83071: LD_VAR 0 5
83075: UNION
83076: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83077: LD_VAR 0 5
83081: PPUSH
83082: LD_INT 18
83084: PPUSH
83085: CALL_OW 109
// end ;
83089: GO 83046
83091: POP
83092: POP
// repeat wait ( 0 0$2 ) ;
83093: LD_INT 70
83095: PPUSH
83096: CALL_OW 67
// enemy := mc_scan [ base ] ;
83100: LD_ADDR_VAR 0 3
83104: PUSH
83105: LD_EXP 66
83109: PUSH
83110: LD_VAR 0 1
83114: ARRAY
83115: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83116: LD_EXP 43
83120: PUSH
83121: LD_VAR 0 1
83125: ARRAY
83126: NOT
83127: PUSH
83128: LD_EXP 43
83132: PUSH
83133: LD_VAR 0 1
83137: ARRAY
83138: PUSH
83139: EMPTY
83140: EQUAL
83141: OR
83142: IFFALSE 83179
// begin for i in defenders do
83144: LD_ADDR_VAR 0 5
83148: PUSH
83149: LD_VAR 0 2
83153: PUSH
83154: FOR_IN
83155: IFFALSE 83168
// ComStop ( i ) ;
83157: LD_VAR 0 5
83161: PPUSH
83162: CALL_OW 141
83166: GO 83154
83168: POP
83169: POP
// defenders := [ ] ;
83170: LD_ADDR_VAR 0 2
83174: PUSH
83175: EMPTY
83176: ST_TO_ADDR
// exit ;
83177: GO 84548
// end ; for i in defenders do
83179: LD_ADDR_VAR 0 5
83183: PUSH
83184: LD_VAR 0 2
83188: PUSH
83189: FOR_IN
83190: IFFALSE 84008
// begin e := NearestUnitToUnit ( enemy , i ) ;
83192: LD_ADDR_VAR 0 14
83196: PUSH
83197: LD_VAR 0 3
83201: PPUSH
83202: LD_VAR 0 5
83206: PPUSH
83207: CALL_OW 74
83211: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83212: LD_ADDR_VAR 0 8
83216: PUSH
83217: LD_EXP 43
83221: PUSH
83222: LD_VAR 0 1
83226: ARRAY
83227: PPUSH
83228: LD_INT 2
83230: PUSH
83231: LD_INT 30
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 30
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: LIST
83255: PPUSH
83256: CALL_OW 72
83260: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83261: LD_ADDR_VAR 0 17
83265: PUSH
83266: LD_VAR 0 8
83270: NOT
83271: PUSH
83272: LD_VAR 0 8
83276: PPUSH
83277: LD_INT 3
83279: PUSH
83280: LD_INT 24
83282: PUSH
83283: LD_INT 600
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PPUSH
83294: CALL_OW 72
83298: OR
83299: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83300: LD_VAR 0 5
83304: PPUSH
83305: CALL_OW 247
83309: PUSH
83310: LD_INT 2
83312: DOUBLE
83313: EQUAL
83314: IFTRUE 83318
83316: GO 83714
83318: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83319: LD_VAR 0 5
83323: PPUSH
83324: CALL_OW 256
83328: PUSH
83329: LD_INT 650
83331: GREATER
83332: PUSH
83333: LD_VAR 0 5
83337: PPUSH
83338: LD_VAR 0 14
83342: PPUSH
83343: CALL_OW 296
83347: PUSH
83348: LD_INT 40
83350: LESS
83351: PUSH
83352: LD_VAR 0 14
83356: PPUSH
83357: LD_EXP 68
83361: PUSH
83362: LD_VAR 0 1
83366: ARRAY
83367: PPUSH
83368: CALL_OW 308
83372: OR
83373: AND
83374: IFFALSE 83496
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83376: LD_VAR 0 5
83380: PPUSH
83381: CALL_OW 262
83385: PUSH
83386: LD_INT 1
83388: EQUAL
83389: PUSH
83390: LD_VAR 0 5
83394: PPUSH
83395: CALL_OW 261
83399: PUSH
83400: LD_INT 30
83402: LESS
83403: AND
83404: PUSH
83405: LD_VAR 0 8
83409: AND
83410: IFFALSE 83480
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83412: LD_VAR 0 5
83416: PPUSH
83417: LD_VAR 0 8
83421: PPUSH
83422: LD_VAR 0 5
83426: PPUSH
83427: CALL_OW 74
83431: PPUSH
83432: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83436: LD_VAR 0 5
83440: PPUSH
83441: LD_VAR 0 8
83445: PPUSH
83446: LD_VAR 0 5
83450: PPUSH
83451: CALL_OW 74
83455: PPUSH
83456: CALL_OW 296
83460: PUSH
83461: LD_INT 6
83463: LESS
83464: IFFALSE 83478
// SetFuel ( i , 100 ) ;
83466: LD_VAR 0 5
83470: PPUSH
83471: LD_INT 100
83473: PPUSH
83474: CALL_OW 240
// end else
83478: GO 83494
// ComAttackUnit ( i , e ) ;
83480: LD_VAR 0 5
83484: PPUSH
83485: LD_VAR 0 14
83489: PPUSH
83490: CALL_OW 115
// end else
83494: GO 83597
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83496: LD_VAR 0 14
83500: PPUSH
83501: LD_EXP 68
83505: PUSH
83506: LD_VAR 0 1
83510: ARRAY
83511: PPUSH
83512: CALL_OW 308
83516: NOT
83517: PUSH
83518: LD_VAR 0 5
83522: PPUSH
83523: LD_VAR 0 14
83527: PPUSH
83528: CALL_OW 296
83532: PUSH
83533: LD_INT 40
83535: GREATEREQUAL
83536: AND
83537: PUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: CALL_OW 256
83547: PUSH
83548: LD_INT 650
83550: LESSEQUAL
83551: OR
83552: PUSH
83553: LD_VAR 0 5
83557: PPUSH
83558: LD_EXP 67
83562: PUSH
83563: LD_VAR 0 1
83567: ARRAY
83568: PPUSH
83569: CALL_OW 308
83573: NOT
83574: AND
83575: IFFALSE 83597
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83577: LD_VAR 0 5
83581: PPUSH
83582: LD_EXP 67
83586: PUSH
83587: LD_VAR 0 1
83591: ARRAY
83592: PPUSH
83593: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83597: LD_VAR 0 5
83601: PPUSH
83602: CALL_OW 256
83606: PUSH
83607: LD_INT 998
83609: LESS
83610: PUSH
83611: LD_VAR 0 5
83615: PPUSH
83616: CALL_OW 263
83620: PUSH
83621: LD_INT 1
83623: EQUAL
83624: AND
83625: PUSH
83626: LD_VAR 0 5
83630: PPUSH
83631: CALL_OW 311
83635: AND
83636: PUSH
83637: LD_VAR 0 5
83641: PPUSH
83642: LD_EXP 67
83646: PUSH
83647: LD_VAR 0 1
83651: ARRAY
83652: PPUSH
83653: CALL_OW 308
83657: AND
83658: IFFALSE 83712
// begin mech := IsDrivenBy ( i ) ;
83660: LD_ADDR_VAR 0 10
83664: PUSH
83665: LD_VAR 0 5
83669: PPUSH
83670: CALL_OW 311
83674: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83675: LD_VAR 0 10
83679: PPUSH
83680: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83684: LD_VAR 0 10
83688: PPUSH
83689: LD_VAR 0 5
83693: PPUSH
83694: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83698: LD_VAR 0 10
83702: PPUSH
83703: LD_VAR 0 5
83707: PPUSH
83708: CALL_OW 180
// end ; end ; unit_human :
83712: GO 83979
83714: LD_INT 1
83716: DOUBLE
83717: EQUAL
83718: IFTRUE 83722
83720: GO 83978
83722: POP
// begin b := IsInUnit ( i ) ;
83723: LD_ADDR_VAR 0 19
83727: PUSH
83728: LD_VAR 0 5
83732: PPUSH
83733: CALL_OW 310
83737: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83738: LD_ADDR_VAR 0 20
83742: PUSH
83743: LD_VAR 0 19
83747: NOT
83748: PUSH
83749: LD_VAR 0 19
83753: PPUSH
83754: CALL_OW 266
83758: PUSH
83759: LD_INT 32
83761: PUSH
83762: LD_INT 31
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: IN
83769: OR
83770: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83771: LD_VAR 0 17
83775: PUSH
83776: LD_VAR 0 2
83780: PPUSH
83781: LD_INT 21
83783: PUSH
83784: LD_INT 2
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PPUSH
83791: CALL_OW 72
83795: PUSH
83796: LD_INT 1
83798: LESSEQUAL
83799: OR
83800: PUSH
83801: LD_VAR 0 20
83805: AND
83806: PUSH
83807: LD_VAR 0 5
83811: PUSH
83812: LD_VAR 0 18
83816: IN
83817: NOT
83818: AND
83819: IFFALSE 83912
// begin if b then
83821: LD_VAR 0 19
83825: IFFALSE 83874
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83827: LD_VAR 0 19
83831: PPUSH
83832: LD_VAR 0 3
83836: PPUSH
83837: LD_VAR 0 19
83841: PPUSH
83842: CALL_OW 74
83846: PPUSH
83847: CALL_OW 296
83851: PUSH
83852: LD_INT 10
83854: LESS
83855: PUSH
83856: LD_VAR 0 19
83860: PPUSH
83861: CALL_OW 461
83865: PUSH
83866: LD_INT 7
83868: NONEQUAL
83869: AND
83870: IFFALSE 83874
// continue ;
83872: GO 83189
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83874: LD_ADDR_VAR 0 18
83878: PUSH
83879: LD_VAR 0 18
83883: PPUSH
83884: LD_VAR 0 18
83888: PUSH
83889: LD_INT 1
83891: PLUS
83892: PPUSH
83893: LD_VAR 0 5
83897: PPUSH
83898: CALL_OW 1
83902: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83903: LD_VAR 0 5
83907: PPUSH
83908: CALL_OW 122
// end ; if sold_defenders then
83912: LD_VAR 0 18
83916: IFFALSE 83976
// if i in sold_defenders then
83918: LD_VAR 0 5
83922: PUSH
83923: LD_VAR 0 18
83927: IN
83928: IFFALSE 83976
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83930: LD_VAR 0 5
83934: PPUSH
83935: CALL_OW 314
83939: NOT
83940: PUSH
83941: LD_VAR 0 5
83945: PPUSH
83946: LD_VAR 0 14
83950: PPUSH
83951: CALL_OW 296
83955: PUSH
83956: LD_INT 30
83958: LESS
83959: AND
83960: IFFALSE 83976
// ComAttackUnit ( i , e ) ;
83962: LD_VAR 0 5
83966: PPUSH
83967: LD_VAR 0 14
83971: PPUSH
83972: CALL_OW 115
// end ; end ; end ;
83976: GO 83979
83978: POP
// if IsDead ( i ) then
83979: LD_VAR 0 5
83983: PPUSH
83984: CALL_OW 301
83988: IFFALSE 84006
// defenders := defenders diff i ;
83990: LD_ADDR_VAR 0 2
83994: PUSH
83995: LD_VAR 0 2
83999: PUSH
84000: LD_VAR 0 5
84004: DIFF
84005: ST_TO_ADDR
// end ;
84006: GO 83189
84008: POP
84009: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84010: LD_VAR 0 3
84014: NOT
84015: PUSH
84016: LD_VAR 0 2
84020: NOT
84021: OR
84022: PUSH
84023: LD_EXP 43
84027: PUSH
84028: LD_VAR 0 1
84032: ARRAY
84033: NOT
84034: OR
84035: IFFALSE 83093
// MC_Reset ( base , 18 ) ;
84037: LD_VAR 0 1
84041: PPUSH
84042: LD_INT 18
84044: PPUSH
84045: CALL 51220 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84049: LD_ADDR_VAR 0 2
84053: PUSH
84054: LD_VAR 0 2
84058: PUSH
84059: LD_VAR 0 2
84063: PPUSH
84064: LD_INT 2
84066: PUSH
84067: LD_INT 25
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 25
84079: PUSH
84080: LD_INT 5
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 25
84089: PUSH
84090: LD_INT 8
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 25
84099: PUSH
84100: LD_INT 9
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: PPUSH
84114: CALL_OW 72
84118: DIFF
84119: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84120: LD_VAR 0 3
84124: NOT
84125: PUSH
84126: LD_VAR 0 2
84130: PPUSH
84131: LD_INT 21
84133: PUSH
84134: LD_INT 2
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PPUSH
84141: CALL_OW 72
84145: AND
84146: IFFALSE 84484
// begin tmp := FilterByTag ( defenders , 19 ) ;
84148: LD_ADDR_VAR 0 12
84152: PUSH
84153: LD_VAR 0 2
84157: PPUSH
84158: LD_INT 19
84160: PPUSH
84161: CALL 43370 0 2
84165: ST_TO_ADDR
// if tmp then
84166: LD_VAR 0 12
84170: IFFALSE 84240
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84172: LD_ADDR_VAR 0 12
84176: PUSH
84177: LD_VAR 0 12
84181: PPUSH
84182: LD_INT 25
84184: PUSH
84185: LD_INT 3
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PPUSH
84192: CALL_OW 72
84196: ST_TO_ADDR
// if tmp then
84197: LD_VAR 0 12
84201: IFFALSE 84240
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84203: LD_ADDR_EXP 55
84207: PUSH
84208: LD_EXP 55
84212: PPUSH
84213: LD_VAR 0 1
84217: PPUSH
84218: LD_EXP 55
84222: PUSH
84223: LD_VAR 0 1
84227: ARRAY
84228: PUSH
84229: LD_VAR 0 12
84233: UNION
84234: PPUSH
84235: CALL_OW 1
84239: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84240: LD_VAR 0 1
84244: PPUSH
84245: LD_INT 19
84247: PPUSH
84248: CALL 51220 0 2
// repeat wait ( 0 0$1 ) ;
84252: LD_INT 35
84254: PPUSH
84255: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84259: LD_EXP 43
84263: PUSH
84264: LD_VAR 0 1
84268: ARRAY
84269: NOT
84270: PUSH
84271: LD_EXP 43
84275: PUSH
84276: LD_VAR 0 1
84280: ARRAY
84281: PUSH
84282: EMPTY
84283: EQUAL
84284: OR
84285: IFFALSE 84322
// begin for i in defenders do
84287: LD_ADDR_VAR 0 5
84291: PUSH
84292: LD_VAR 0 2
84296: PUSH
84297: FOR_IN
84298: IFFALSE 84311
// ComStop ( i ) ;
84300: LD_VAR 0 5
84304: PPUSH
84305: CALL_OW 141
84309: GO 84297
84311: POP
84312: POP
// defenders := [ ] ;
84313: LD_ADDR_VAR 0 2
84317: PUSH
84318: EMPTY
84319: ST_TO_ADDR
// exit ;
84320: GO 84548
// end ; for i in defenders do
84322: LD_ADDR_VAR 0 5
84326: PUSH
84327: LD_VAR 0 2
84331: PUSH
84332: FOR_IN
84333: IFFALSE 84422
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84335: LD_VAR 0 5
84339: PPUSH
84340: LD_EXP 67
84344: PUSH
84345: LD_VAR 0 1
84349: ARRAY
84350: PPUSH
84351: CALL_OW 308
84355: NOT
84356: IFFALSE 84380
// ComMoveToArea ( i , mc_parking [ base ] ) else
84358: LD_VAR 0 5
84362: PPUSH
84363: LD_EXP 67
84367: PUSH
84368: LD_VAR 0 1
84372: ARRAY
84373: PPUSH
84374: CALL_OW 113
84378: GO 84420
// if GetControl ( i ) = control_manual then
84380: LD_VAR 0 5
84384: PPUSH
84385: CALL_OW 263
84389: PUSH
84390: LD_INT 1
84392: EQUAL
84393: IFFALSE 84420
// if IsDrivenBy ( i ) then
84395: LD_VAR 0 5
84399: PPUSH
84400: CALL_OW 311
84404: IFFALSE 84420
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84406: LD_VAR 0 5
84410: PPUSH
84411: CALL_OW 311
84415: PPUSH
84416: CALL_OW 121
// end ;
84420: GO 84332
84422: POP
84423: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84424: LD_VAR 0 2
84428: PPUSH
84429: LD_INT 95
84431: PUSH
84432: LD_EXP 67
84436: PUSH
84437: LD_VAR 0 1
84441: ARRAY
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PPUSH
84447: CALL_OW 72
84451: PUSH
84452: LD_VAR 0 2
84456: EQUAL
84457: PUSH
84458: LD_EXP 66
84462: PUSH
84463: LD_VAR 0 1
84467: ARRAY
84468: OR
84469: PUSH
84470: LD_EXP 43
84474: PUSH
84475: LD_VAR 0 1
84479: ARRAY
84480: NOT
84481: OR
84482: IFFALSE 84252
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84484: LD_ADDR_EXP 65
84488: PUSH
84489: LD_EXP 65
84493: PPUSH
84494: LD_VAR 0 1
84498: PPUSH
84499: LD_VAR 0 2
84503: PPUSH
84504: LD_INT 21
84506: PUSH
84507: LD_INT 2
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PPUSH
84514: CALL_OW 72
84518: PPUSH
84519: CALL_OW 1
84523: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84524: LD_VAR 0 1
84528: PPUSH
84529: LD_INT 19
84531: PPUSH
84532: CALL 51220 0 2
// MC_Reset ( base , 20 ) ;
84536: LD_VAR 0 1
84540: PPUSH
84541: LD_INT 20
84543: PPUSH
84544: CALL 51220 0 2
// end ; end_of_file
84548: LD_VAR 0 4
84552: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84553: LD_INT 0
84555: PPUSH
84556: PPUSH
84557: PPUSH
84558: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84559: LD_VAR 0 1
84563: PPUSH
84564: CALL_OW 264
84568: PUSH
84569: LD_EXP 90
84573: EQUAL
84574: IFFALSE 84646
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84576: LD_INT 68
84578: PPUSH
84579: LD_VAR 0 1
84583: PPUSH
84584: CALL_OW 255
84588: PPUSH
84589: CALL_OW 321
84593: PUSH
84594: LD_INT 2
84596: EQUAL
84597: IFFALSE 84609
// eff := 70 else
84599: LD_ADDR_VAR 0 4
84603: PUSH
84604: LD_INT 70
84606: ST_TO_ADDR
84607: GO 84617
// eff := 30 ;
84609: LD_ADDR_VAR 0 4
84613: PUSH
84614: LD_INT 30
84616: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84617: LD_VAR 0 1
84621: PPUSH
84622: CALL_OW 250
84626: PPUSH
84627: LD_VAR 0 1
84631: PPUSH
84632: CALL_OW 251
84636: PPUSH
84637: LD_VAR 0 4
84641: PPUSH
84642: CALL_OW 495
// end ; end ;
84646: LD_VAR 0 2
84650: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84651: LD_INT 0
84653: PPUSH
// end ;
84654: LD_VAR 0 4
84658: RET
// export function SOS_Command ( cmd ) ; begin
84659: LD_INT 0
84661: PPUSH
// end ;
84662: LD_VAR 0 2
84666: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84667: LD_INT 0
84669: PPUSH
// if cmd = 121 then
84670: LD_VAR 0 1
84674: PUSH
84675: LD_INT 121
84677: EQUAL
84678: IFFALSE 84680
// end ;
84680: LD_VAR 0 6
84684: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84685: LD_INT 0
84687: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84688: LD_VAR 0 1
84692: PUSH
84693: LD_INT 250
84695: EQUAL
84696: PUSH
84697: LD_VAR 0 2
84701: PPUSH
84702: CALL_OW 264
84706: PUSH
84707: LD_EXP 93
84711: EQUAL
84712: AND
84713: IFFALSE 84734
// MinerPlaceMine ( unit , x , y ) ;
84715: LD_VAR 0 2
84719: PPUSH
84720: LD_VAR 0 4
84724: PPUSH
84725: LD_VAR 0 5
84729: PPUSH
84730: CALL 87083 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84734: LD_VAR 0 1
84738: PUSH
84739: LD_INT 251
84741: EQUAL
84742: PUSH
84743: LD_VAR 0 2
84747: PPUSH
84748: CALL_OW 264
84752: PUSH
84753: LD_EXP 93
84757: EQUAL
84758: AND
84759: IFFALSE 84780
// MinerDetonateMine ( unit , x , y ) ;
84761: LD_VAR 0 2
84765: PPUSH
84766: LD_VAR 0 4
84770: PPUSH
84771: LD_VAR 0 5
84775: PPUSH
84776: CALL 87360 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
84780: LD_VAR 0 1
84784: PUSH
84785: LD_INT 252
84787: EQUAL
84788: PUSH
84789: LD_VAR 0 2
84793: PPUSH
84794: CALL_OW 264
84798: PUSH
84799: LD_EXP 93
84803: EQUAL
84804: AND
84805: IFFALSE 84826
// MinerCreateMinefield ( unit , x , y ) ;
84807: LD_VAR 0 2
84811: PPUSH
84812: LD_VAR 0 4
84816: PPUSH
84817: LD_VAR 0 5
84821: PPUSH
84822: CALL 87777 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
84826: LD_VAR 0 1
84830: PUSH
84831: LD_INT 253
84833: EQUAL
84834: PUSH
84835: LD_VAR 0 2
84839: PPUSH
84840: CALL_OW 257
84844: PUSH
84845: LD_INT 5
84847: EQUAL
84848: AND
84849: IFFALSE 84870
// ComBinocular ( unit , x , y ) ;
84851: LD_VAR 0 2
84855: PPUSH
84856: LD_VAR 0 4
84860: PPUSH
84861: LD_VAR 0 5
84865: PPUSH
84866: CALL 88148 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
84870: LD_VAR 0 1
84874: PUSH
84875: LD_INT 254
84877: EQUAL
84878: PUSH
84879: LD_VAR 0 2
84883: PPUSH
84884: CALL_OW 264
84888: PUSH
84889: LD_EXP 88
84893: EQUAL
84894: AND
84895: PUSH
84896: LD_VAR 0 3
84900: PPUSH
84901: CALL_OW 263
84905: PUSH
84906: LD_INT 3
84908: EQUAL
84909: AND
84910: IFFALSE 84926
// HackDestroyVehicle ( unit , selectedUnit ) ;
84912: LD_VAR 0 2
84916: PPUSH
84917: LD_VAR 0 3
84921: PPUSH
84922: CALL 86443 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
84926: LD_VAR 0 1
84930: PUSH
84931: LD_INT 255
84933: EQUAL
84934: PUSH
84935: LD_VAR 0 2
84939: PPUSH
84940: CALL_OW 264
84944: PUSH
84945: LD_INT 14
84947: PUSH
84948: LD_INT 53
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: IN
84955: AND
84956: PUSH
84957: LD_VAR 0 4
84961: PPUSH
84962: LD_VAR 0 5
84966: PPUSH
84967: CALL_OW 488
84971: AND
84972: IFFALSE 84996
// CutTreeXYR ( unit , x , y , 12 ) ;
84974: LD_VAR 0 2
84978: PPUSH
84979: LD_VAR 0 4
84983: PPUSH
84984: LD_VAR 0 5
84988: PPUSH
84989: LD_INT 12
84991: PPUSH
84992: CALL 85009 0 4
// end ;
84996: LD_VAR 0 6
85000: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
85001: LD_INT 0
85003: PPUSH
// end ;
85004: LD_VAR 0 4
85008: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
85009: LD_INT 0
85011: PPUSH
85012: PPUSH
85013: PPUSH
85014: PPUSH
85015: PPUSH
85016: PPUSH
85017: PPUSH
85018: PPUSH
85019: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
85020: LD_VAR 0 1
85024: NOT
85025: PUSH
85026: LD_VAR 0 2
85030: PPUSH
85031: LD_VAR 0 3
85035: PPUSH
85036: CALL_OW 488
85040: NOT
85041: OR
85042: PUSH
85043: LD_VAR 0 4
85047: NOT
85048: OR
85049: IFFALSE 85053
// exit ;
85051: GO 85393
// list := [ ] ;
85053: LD_ADDR_VAR 0 13
85057: PUSH
85058: EMPTY
85059: ST_TO_ADDR
// if x - r < 0 then
85060: LD_VAR 0 2
85064: PUSH
85065: LD_VAR 0 4
85069: MINUS
85070: PUSH
85071: LD_INT 0
85073: LESS
85074: IFFALSE 85086
// min_x := 0 else
85076: LD_ADDR_VAR 0 7
85080: PUSH
85081: LD_INT 0
85083: ST_TO_ADDR
85084: GO 85102
// min_x := x - r ;
85086: LD_ADDR_VAR 0 7
85090: PUSH
85091: LD_VAR 0 2
85095: PUSH
85096: LD_VAR 0 4
85100: MINUS
85101: ST_TO_ADDR
// if y - r < 0 then
85102: LD_VAR 0 3
85106: PUSH
85107: LD_VAR 0 4
85111: MINUS
85112: PUSH
85113: LD_INT 0
85115: LESS
85116: IFFALSE 85128
// min_y := 0 else
85118: LD_ADDR_VAR 0 8
85122: PUSH
85123: LD_INT 0
85125: ST_TO_ADDR
85126: GO 85144
// min_y := y - r ;
85128: LD_ADDR_VAR 0 8
85132: PUSH
85133: LD_VAR 0 3
85137: PUSH
85138: LD_VAR 0 4
85142: MINUS
85143: ST_TO_ADDR
// max_x := x + r ;
85144: LD_ADDR_VAR 0 9
85148: PUSH
85149: LD_VAR 0 2
85153: PUSH
85154: LD_VAR 0 4
85158: PLUS
85159: ST_TO_ADDR
// max_y := y + r ;
85160: LD_ADDR_VAR 0 10
85164: PUSH
85165: LD_VAR 0 3
85169: PUSH
85170: LD_VAR 0 4
85174: PLUS
85175: ST_TO_ADDR
// for _x = min_x to max_x do
85176: LD_ADDR_VAR 0 11
85180: PUSH
85181: DOUBLE
85182: LD_VAR 0 7
85186: DEC
85187: ST_TO_ADDR
85188: LD_VAR 0 9
85192: PUSH
85193: FOR_TO
85194: IFFALSE 85311
// for _y = min_y to max_y do
85196: LD_ADDR_VAR 0 12
85200: PUSH
85201: DOUBLE
85202: LD_VAR 0 8
85206: DEC
85207: ST_TO_ADDR
85208: LD_VAR 0 10
85212: PUSH
85213: FOR_TO
85214: IFFALSE 85307
// begin if not ValidHex ( _x , _y ) then
85216: LD_VAR 0 11
85220: PPUSH
85221: LD_VAR 0 12
85225: PPUSH
85226: CALL_OW 488
85230: NOT
85231: IFFALSE 85235
// continue ;
85233: GO 85213
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85235: LD_VAR 0 11
85239: PPUSH
85240: LD_VAR 0 12
85244: PPUSH
85245: CALL_OW 351
85249: PUSH
85250: LD_VAR 0 11
85254: PPUSH
85255: LD_VAR 0 12
85259: PPUSH
85260: CALL_OW 554
85264: AND
85265: IFFALSE 85305
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85267: LD_ADDR_VAR 0 13
85271: PUSH
85272: LD_VAR 0 13
85276: PPUSH
85277: LD_VAR 0 13
85281: PUSH
85282: LD_INT 1
85284: PLUS
85285: PPUSH
85286: LD_VAR 0 11
85290: PUSH
85291: LD_VAR 0 12
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PPUSH
85300: CALL_OW 2
85304: ST_TO_ADDR
// end ;
85305: GO 85213
85307: POP
85308: POP
85309: GO 85193
85311: POP
85312: POP
// if not list then
85313: LD_VAR 0 13
85317: NOT
85318: IFFALSE 85322
// exit ;
85320: GO 85393
// for i in list do
85322: LD_ADDR_VAR 0 6
85326: PUSH
85327: LD_VAR 0 13
85331: PUSH
85332: FOR_IN
85333: IFFALSE 85391
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85335: LD_VAR 0 1
85339: PPUSH
85340: LD_STRING M
85342: PUSH
85343: LD_VAR 0 6
85347: PUSH
85348: LD_INT 1
85350: ARRAY
85351: PUSH
85352: LD_VAR 0 6
85356: PUSH
85357: LD_INT 2
85359: ARRAY
85360: PUSH
85361: LD_INT 0
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: LD_INT 0
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: PUSH
85382: EMPTY
85383: LIST
85384: PPUSH
85385: CALL_OW 447
85389: GO 85332
85391: POP
85392: POP
// end ;
85393: LD_VAR 0 5
85397: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85398: LD_EXP 104
85402: NOT
85403: IFFALSE 85453
85405: GO 85407
85407: DISABLE
// begin initHack := true ;
85408: LD_ADDR_EXP 104
85412: PUSH
85413: LD_INT 1
85415: ST_TO_ADDR
// hackTanks := [ ] ;
85416: LD_ADDR_EXP 105
85420: PUSH
85421: EMPTY
85422: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85423: LD_ADDR_EXP 106
85427: PUSH
85428: EMPTY
85429: ST_TO_ADDR
// hackLimit := 3 ;
85430: LD_ADDR_EXP 107
85434: PUSH
85435: LD_INT 3
85437: ST_TO_ADDR
// hackDist := 12 ;
85438: LD_ADDR_EXP 108
85442: PUSH
85443: LD_INT 12
85445: ST_TO_ADDR
// hackCounter := [ ] ;
85446: LD_ADDR_EXP 109
85450: PUSH
85451: EMPTY
85452: ST_TO_ADDR
// end ;
85453: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85454: LD_EXP 104
85458: PUSH
85459: LD_INT 34
85461: PUSH
85462: LD_EXP 88
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: PPUSH
85471: CALL_OW 69
85475: AND
85476: IFFALSE 85731
85478: GO 85480
85480: DISABLE
85481: LD_INT 0
85483: PPUSH
85484: PPUSH
// begin enable ;
85485: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85486: LD_ADDR_VAR 0 1
85490: PUSH
85491: LD_INT 34
85493: PUSH
85494: LD_EXP 88
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PPUSH
85503: CALL_OW 69
85507: PUSH
85508: FOR_IN
85509: IFFALSE 85729
// begin if not i in hackTanks then
85511: LD_VAR 0 1
85515: PUSH
85516: LD_EXP 105
85520: IN
85521: NOT
85522: IFFALSE 85605
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85524: LD_ADDR_EXP 105
85528: PUSH
85529: LD_EXP 105
85533: PPUSH
85534: LD_EXP 105
85538: PUSH
85539: LD_INT 1
85541: PLUS
85542: PPUSH
85543: LD_VAR 0 1
85547: PPUSH
85548: CALL_OW 1
85552: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85553: LD_ADDR_EXP 106
85557: PUSH
85558: LD_EXP 106
85562: PPUSH
85563: LD_EXP 106
85567: PUSH
85568: LD_INT 1
85570: PLUS
85571: PPUSH
85572: EMPTY
85573: PPUSH
85574: CALL_OW 1
85578: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85579: LD_ADDR_EXP 109
85583: PUSH
85584: LD_EXP 109
85588: PPUSH
85589: LD_EXP 109
85593: PUSH
85594: LD_INT 1
85596: PLUS
85597: PPUSH
85598: EMPTY
85599: PPUSH
85600: CALL_OW 1
85604: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85605: LD_VAR 0 1
85609: PPUSH
85610: CALL_OW 302
85614: NOT
85615: IFFALSE 85628
// begin HackUnlinkAll ( i ) ;
85617: LD_VAR 0 1
85621: PPUSH
85622: CALL 85734 0 1
// continue ;
85626: GO 85508
// end ; HackCheckCapturedStatus ( i ) ;
85628: LD_VAR 0 1
85632: PPUSH
85633: CALL 86177 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85637: LD_ADDR_VAR 0 2
85641: PUSH
85642: LD_INT 81
85644: PUSH
85645: LD_VAR 0 1
85649: PPUSH
85650: CALL_OW 255
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 33
85661: PUSH
85662: LD_INT 3
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 91
85671: PUSH
85672: LD_VAR 0 1
85676: PUSH
85677: LD_EXP 108
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 50
85689: PUSH
85690: EMPTY
85691: LIST
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: PPUSH
85699: CALL_OW 69
85703: ST_TO_ADDR
// if not tmp then
85704: LD_VAR 0 2
85708: NOT
85709: IFFALSE 85713
// continue ;
85711: GO 85508
// HackLink ( i , tmp ) ;
85713: LD_VAR 0 1
85717: PPUSH
85718: LD_VAR 0 2
85722: PPUSH
85723: CALL 85870 0 2
// end ;
85727: GO 85508
85729: POP
85730: POP
// end ;
85731: PPOPN 2
85733: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85734: LD_INT 0
85736: PPUSH
85737: PPUSH
85738: PPUSH
// if not hack in hackTanks then
85739: LD_VAR 0 1
85743: PUSH
85744: LD_EXP 105
85748: IN
85749: NOT
85750: IFFALSE 85754
// exit ;
85752: GO 85865
// index := GetElementIndex ( hackTanks , hack ) ;
85754: LD_ADDR_VAR 0 4
85758: PUSH
85759: LD_EXP 105
85763: PPUSH
85764: LD_VAR 0 1
85768: PPUSH
85769: CALL 14582 0 2
85773: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85774: LD_EXP 106
85778: PUSH
85779: LD_VAR 0 4
85783: ARRAY
85784: IFFALSE 85865
// begin for i in hackTanksCaptured [ index ] do
85786: LD_ADDR_VAR 0 3
85790: PUSH
85791: LD_EXP 106
85795: PUSH
85796: LD_VAR 0 4
85800: ARRAY
85801: PUSH
85802: FOR_IN
85803: IFFALSE 85829
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
85805: LD_VAR 0 3
85809: PUSH
85810: LD_INT 1
85812: ARRAY
85813: PPUSH
85814: LD_VAR 0 3
85818: PUSH
85819: LD_INT 2
85821: ARRAY
85822: PPUSH
85823: CALL_OW 235
85827: GO 85802
85829: POP
85830: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
85831: LD_ADDR_EXP 106
85835: PUSH
85836: LD_EXP 106
85840: PPUSH
85841: LD_VAR 0 4
85845: PPUSH
85846: EMPTY
85847: PPUSH
85848: CALL_OW 1
85852: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
85853: LD_VAR 0 1
85857: PPUSH
85858: LD_INT 0
85860: PPUSH
85861: CALL_OW 505
// end ; end ;
85865: LD_VAR 0 2
85869: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
85870: LD_INT 0
85872: PPUSH
85873: PPUSH
85874: PPUSH
// if not hack in hackTanks or not vehicles then
85875: LD_VAR 0 1
85879: PUSH
85880: LD_EXP 105
85884: IN
85885: NOT
85886: PUSH
85887: LD_VAR 0 2
85891: NOT
85892: OR
85893: IFFALSE 85897
// exit ;
85895: GO 86172
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
85897: LD_ADDR_VAR 0 2
85901: PUSH
85902: LD_VAR 0 1
85906: PPUSH
85907: LD_VAR 0 2
85911: PPUSH
85912: LD_INT 1
85914: PPUSH
85915: LD_INT 1
85917: PPUSH
85918: CALL 15232 0 4
85922: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
85923: LD_ADDR_VAR 0 5
85927: PUSH
85928: LD_EXP 105
85932: PPUSH
85933: LD_VAR 0 1
85937: PPUSH
85938: CALL 14582 0 2
85942: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
85943: LD_EXP 106
85947: PUSH
85948: LD_VAR 0 5
85952: ARRAY
85953: PUSH
85954: LD_EXP 107
85958: LESS
85959: IFFALSE 86148
// begin for i := 1 to vehicles do
85961: LD_ADDR_VAR 0 4
85965: PUSH
85966: DOUBLE
85967: LD_INT 1
85969: DEC
85970: ST_TO_ADDR
85971: LD_VAR 0 2
85975: PUSH
85976: FOR_TO
85977: IFFALSE 86146
// begin if hackTanksCaptured [ index ] = hackLimit then
85979: LD_EXP 106
85983: PUSH
85984: LD_VAR 0 5
85988: ARRAY
85989: PUSH
85990: LD_EXP 107
85994: EQUAL
85995: IFFALSE 85999
// break ;
85997: GO 86146
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
85999: LD_ADDR_EXP 109
86003: PUSH
86004: LD_EXP 109
86008: PPUSH
86009: LD_VAR 0 5
86013: PPUSH
86014: LD_EXP 109
86018: PUSH
86019: LD_VAR 0 5
86023: ARRAY
86024: PUSH
86025: LD_INT 1
86027: PLUS
86028: PPUSH
86029: CALL_OW 1
86033: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
86034: LD_ADDR_EXP 106
86038: PUSH
86039: LD_EXP 106
86043: PPUSH
86044: LD_VAR 0 5
86048: PUSH
86049: LD_EXP 106
86053: PUSH
86054: LD_VAR 0 5
86058: ARRAY
86059: PUSH
86060: LD_INT 1
86062: PLUS
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PPUSH
86068: LD_VAR 0 2
86072: PUSH
86073: LD_VAR 0 4
86077: ARRAY
86078: PUSH
86079: LD_VAR 0 2
86083: PUSH
86084: LD_VAR 0 4
86088: ARRAY
86089: PPUSH
86090: CALL_OW 255
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PPUSH
86099: CALL 14797 0 3
86103: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86104: LD_VAR 0 2
86108: PUSH
86109: LD_VAR 0 4
86113: ARRAY
86114: PPUSH
86115: LD_VAR 0 1
86119: PPUSH
86120: CALL_OW 255
86124: PPUSH
86125: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86129: LD_VAR 0 2
86133: PUSH
86134: LD_VAR 0 4
86138: ARRAY
86139: PPUSH
86140: CALL_OW 141
// end ;
86144: GO 85976
86146: POP
86147: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86148: LD_VAR 0 1
86152: PPUSH
86153: LD_EXP 106
86157: PUSH
86158: LD_VAR 0 5
86162: ARRAY
86163: PUSH
86164: LD_INT 0
86166: PLUS
86167: PPUSH
86168: CALL_OW 505
// end ;
86172: LD_VAR 0 3
86176: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86177: LD_INT 0
86179: PPUSH
86180: PPUSH
86181: PPUSH
86182: PPUSH
// if not hack in hackTanks then
86183: LD_VAR 0 1
86187: PUSH
86188: LD_EXP 105
86192: IN
86193: NOT
86194: IFFALSE 86198
// exit ;
86196: GO 86438
// index := GetElementIndex ( hackTanks , hack ) ;
86198: LD_ADDR_VAR 0 4
86202: PUSH
86203: LD_EXP 105
86207: PPUSH
86208: LD_VAR 0 1
86212: PPUSH
86213: CALL 14582 0 2
86217: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86218: LD_ADDR_VAR 0 3
86222: PUSH
86223: DOUBLE
86224: LD_EXP 106
86228: PUSH
86229: LD_VAR 0 4
86233: ARRAY
86234: INC
86235: ST_TO_ADDR
86236: LD_INT 1
86238: PUSH
86239: FOR_DOWNTO
86240: IFFALSE 86412
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86242: LD_ADDR_VAR 0 5
86246: PUSH
86247: LD_EXP 106
86251: PUSH
86252: LD_VAR 0 4
86256: ARRAY
86257: PUSH
86258: LD_VAR 0 3
86262: ARRAY
86263: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86264: LD_VAR 0 5
86268: PUSH
86269: LD_INT 1
86271: ARRAY
86272: PPUSH
86273: CALL_OW 302
86277: NOT
86278: PUSH
86279: LD_VAR 0 5
86283: PUSH
86284: LD_INT 1
86286: ARRAY
86287: PPUSH
86288: CALL_OW 255
86292: PUSH
86293: LD_VAR 0 1
86297: PPUSH
86298: CALL_OW 255
86302: NONEQUAL
86303: OR
86304: IFFALSE 86410
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86306: LD_VAR 0 5
86310: PUSH
86311: LD_INT 1
86313: ARRAY
86314: PPUSH
86315: CALL_OW 305
86319: PUSH
86320: LD_VAR 0 5
86324: PUSH
86325: LD_INT 1
86327: ARRAY
86328: PPUSH
86329: CALL_OW 255
86333: PUSH
86334: LD_VAR 0 1
86338: PPUSH
86339: CALL_OW 255
86343: EQUAL
86344: AND
86345: IFFALSE 86369
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86347: LD_VAR 0 5
86351: PUSH
86352: LD_INT 1
86354: ARRAY
86355: PPUSH
86356: LD_VAR 0 5
86360: PUSH
86361: LD_INT 2
86363: ARRAY
86364: PPUSH
86365: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86369: LD_ADDR_EXP 106
86373: PUSH
86374: LD_EXP 106
86378: PPUSH
86379: LD_VAR 0 4
86383: PPUSH
86384: LD_EXP 106
86388: PUSH
86389: LD_VAR 0 4
86393: ARRAY
86394: PPUSH
86395: LD_VAR 0 3
86399: PPUSH
86400: CALL_OW 3
86404: PPUSH
86405: CALL_OW 1
86409: ST_TO_ADDR
// end ; end ;
86410: GO 86239
86412: POP
86413: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86414: LD_VAR 0 1
86418: PPUSH
86419: LD_EXP 106
86423: PUSH
86424: LD_VAR 0 4
86428: ARRAY
86429: PUSH
86430: LD_INT 0
86432: PLUS
86433: PPUSH
86434: CALL_OW 505
// end ;
86438: LD_VAR 0 2
86442: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86443: LD_INT 0
86445: PPUSH
86446: PPUSH
86447: PPUSH
86448: PPUSH
// if not hack in hackTanks then
86449: LD_VAR 0 1
86453: PUSH
86454: LD_EXP 105
86458: IN
86459: NOT
86460: IFFALSE 86464
// exit ;
86462: GO 86549
// index := GetElementIndex ( hackTanks , hack ) ;
86464: LD_ADDR_VAR 0 5
86468: PUSH
86469: LD_EXP 105
86473: PPUSH
86474: LD_VAR 0 1
86478: PPUSH
86479: CALL 14582 0 2
86483: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86484: LD_ADDR_VAR 0 4
86488: PUSH
86489: DOUBLE
86490: LD_INT 1
86492: DEC
86493: ST_TO_ADDR
86494: LD_EXP 106
86498: PUSH
86499: LD_VAR 0 5
86503: ARRAY
86504: PUSH
86505: FOR_TO
86506: IFFALSE 86547
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86508: LD_EXP 106
86512: PUSH
86513: LD_VAR 0 5
86517: ARRAY
86518: PUSH
86519: LD_VAR 0 4
86523: ARRAY
86524: PUSH
86525: LD_INT 1
86527: ARRAY
86528: PUSH
86529: LD_VAR 0 2
86533: EQUAL
86534: IFFALSE 86545
// KillUnit ( vehicle ) ;
86536: LD_VAR 0 2
86540: PPUSH
86541: CALL_OW 66
86545: GO 86505
86547: POP
86548: POP
// end ;
86549: LD_VAR 0 3
86553: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86554: LD_EXP 110
86558: NOT
86559: IFFALSE 86594
86561: GO 86563
86563: DISABLE
// begin initMiner := true ;
86564: LD_ADDR_EXP 110
86568: PUSH
86569: LD_INT 1
86571: ST_TO_ADDR
// minersList := [ ] ;
86572: LD_ADDR_EXP 111
86576: PUSH
86577: EMPTY
86578: ST_TO_ADDR
// minerMinesList := [ ] ;
86579: LD_ADDR_EXP 112
86583: PUSH
86584: EMPTY
86585: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86586: LD_ADDR_EXP 113
86590: PUSH
86591: LD_INT 5
86593: ST_TO_ADDR
// end ;
86594: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86595: LD_EXP 110
86599: PUSH
86600: LD_INT 34
86602: PUSH
86603: LD_EXP 93
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PPUSH
86612: CALL_OW 69
86616: AND
86617: IFFALSE 87080
86619: GO 86621
86621: DISABLE
86622: LD_INT 0
86624: PPUSH
86625: PPUSH
86626: PPUSH
86627: PPUSH
// begin enable ;
86628: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86629: LD_ADDR_VAR 0 1
86633: PUSH
86634: LD_INT 34
86636: PUSH
86637: LD_EXP 93
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PPUSH
86646: CALL_OW 69
86650: PUSH
86651: FOR_IN
86652: IFFALSE 86724
// begin if not i in minersList then
86654: LD_VAR 0 1
86658: PUSH
86659: LD_EXP 111
86663: IN
86664: NOT
86665: IFFALSE 86722
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86667: LD_ADDR_EXP 111
86671: PUSH
86672: LD_EXP 111
86676: PPUSH
86677: LD_EXP 111
86681: PUSH
86682: LD_INT 1
86684: PLUS
86685: PPUSH
86686: LD_VAR 0 1
86690: PPUSH
86691: CALL_OW 1
86695: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86696: LD_ADDR_EXP 112
86700: PUSH
86701: LD_EXP 112
86705: PPUSH
86706: LD_EXP 112
86710: PUSH
86711: LD_INT 1
86713: PLUS
86714: PPUSH
86715: EMPTY
86716: PPUSH
86717: CALL_OW 1
86721: ST_TO_ADDR
// end end ;
86722: GO 86651
86724: POP
86725: POP
// for i := minerMinesList downto 1 do
86726: LD_ADDR_VAR 0 1
86730: PUSH
86731: DOUBLE
86732: LD_EXP 112
86736: INC
86737: ST_TO_ADDR
86738: LD_INT 1
86740: PUSH
86741: FOR_DOWNTO
86742: IFFALSE 87078
// begin if IsLive ( minersList [ i ] ) then
86744: LD_EXP 111
86748: PUSH
86749: LD_VAR 0 1
86753: ARRAY
86754: PPUSH
86755: CALL_OW 300
86759: IFFALSE 86787
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86761: LD_EXP 111
86765: PUSH
86766: LD_VAR 0 1
86770: ARRAY
86771: PPUSH
86772: LD_EXP 112
86776: PUSH
86777: LD_VAR 0 1
86781: ARRAY
86782: PPUSH
86783: CALL_OW 505
// if not minerMinesList [ i ] then
86787: LD_EXP 112
86791: PUSH
86792: LD_VAR 0 1
86796: ARRAY
86797: NOT
86798: IFFALSE 86802
// continue ;
86800: GO 86741
// for j := minerMinesList [ i ] downto 1 do
86802: LD_ADDR_VAR 0 2
86806: PUSH
86807: DOUBLE
86808: LD_EXP 112
86812: PUSH
86813: LD_VAR 0 1
86817: ARRAY
86818: INC
86819: ST_TO_ADDR
86820: LD_INT 1
86822: PUSH
86823: FOR_DOWNTO
86824: IFFALSE 87074
// begin side := GetSide ( minersList [ i ] ) ;
86826: LD_ADDR_VAR 0 3
86830: PUSH
86831: LD_EXP 111
86835: PUSH
86836: LD_VAR 0 1
86840: ARRAY
86841: PPUSH
86842: CALL_OW 255
86846: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
86847: LD_ADDR_VAR 0 4
86851: PUSH
86852: LD_EXP 112
86856: PUSH
86857: LD_VAR 0 1
86861: ARRAY
86862: PUSH
86863: LD_VAR 0 2
86867: ARRAY
86868: PUSH
86869: LD_INT 1
86871: ARRAY
86872: PPUSH
86873: LD_EXP 112
86877: PUSH
86878: LD_VAR 0 1
86882: ARRAY
86883: PUSH
86884: LD_VAR 0 2
86888: ARRAY
86889: PUSH
86890: LD_INT 2
86892: ARRAY
86893: PPUSH
86894: CALL_OW 428
86898: ST_TO_ADDR
// if not tmp then
86899: LD_VAR 0 4
86903: NOT
86904: IFFALSE 86908
// continue ;
86906: GO 86823
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
86908: LD_VAR 0 4
86912: PUSH
86913: LD_INT 81
86915: PUSH
86916: LD_VAR 0 3
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PPUSH
86925: CALL_OW 69
86929: IN
86930: PUSH
86931: LD_EXP 112
86935: PUSH
86936: LD_VAR 0 1
86940: ARRAY
86941: PUSH
86942: LD_VAR 0 2
86946: ARRAY
86947: PUSH
86948: LD_INT 1
86950: ARRAY
86951: PPUSH
86952: LD_EXP 112
86956: PUSH
86957: LD_VAR 0 1
86961: ARRAY
86962: PUSH
86963: LD_VAR 0 2
86967: ARRAY
86968: PUSH
86969: LD_INT 2
86971: ARRAY
86972: PPUSH
86973: CALL_OW 458
86977: AND
86978: IFFALSE 87072
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
86980: LD_EXP 112
86984: PUSH
86985: LD_VAR 0 1
86989: ARRAY
86990: PUSH
86991: LD_VAR 0 2
86995: ARRAY
86996: PUSH
86997: LD_INT 1
86999: ARRAY
87000: PPUSH
87001: LD_EXP 112
87005: PUSH
87006: LD_VAR 0 1
87010: ARRAY
87011: PUSH
87012: LD_VAR 0 2
87016: ARRAY
87017: PUSH
87018: LD_INT 2
87020: ARRAY
87021: PPUSH
87022: LD_VAR 0 3
87026: PPUSH
87027: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
87031: LD_ADDR_EXP 112
87035: PUSH
87036: LD_EXP 112
87040: PPUSH
87041: LD_VAR 0 1
87045: PPUSH
87046: LD_EXP 112
87050: PUSH
87051: LD_VAR 0 1
87055: ARRAY
87056: PPUSH
87057: LD_VAR 0 2
87061: PPUSH
87062: CALL_OW 3
87066: PPUSH
87067: CALL_OW 1
87071: ST_TO_ADDR
// end ; end ;
87072: GO 86823
87074: POP
87075: POP
// end ;
87076: GO 86741
87078: POP
87079: POP
// end ;
87080: PPOPN 4
87082: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87083: LD_INT 0
87085: PPUSH
87086: PPUSH
// result := false ;
87087: LD_ADDR_VAR 0 4
87091: PUSH
87092: LD_INT 0
87094: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87095: LD_VAR 0 1
87099: PPUSH
87100: CALL_OW 264
87104: PUSH
87105: LD_EXP 93
87109: EQUAL
87110: NOT
87111: IFFALSE 87115
// exit ;
87113: GO 87355
// index := GetElementIndex ( minersList , unit ) ;
87115: LD_ADDR_VAR 0 5
87119: PUSH
87120: LD_EXP 111
87124: PPUSH
87125: LD_VAR 0 1
87129: PPUSH
87130: CALL 14582 0 2
87134: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87135: LD_EXP 112
87139: PUSH
87140: LD_VAR 0 5
87144: ARRAY
87145: PUSH
87146: LD_EXP 113
87150: GREATEREQUAL
87151: IFFALSE 87155
// exit ;
87153: GO 87355
// ComMoveXY ( unit , x , y ) ;
87155: LD_VAR 0 1
87159: PPUSH
87160: LD_VAR 0 2
87164: PPUSH
87165: LD_VAR 0 3
87169: PPUSH
87170: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87174: LD_INT 35
87176: PPUSH
87177: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87181: LD_VAR 0 1
87185: PPUSH
87186: LD_VAR 0 2
87190: PPUSH
87191: LD_VAR 0 3
87195: PPUSH
87196: CALL 44658 0 3
87200: NOT
87201: PUSH
87202: LD_VAR 0 1
87206: PPUSH
87207: CALL_OW 314
87211: AND
87212: IFFALSE 87216
// exit ;
87214: GO 87355
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87216: LD_VAR 0 2
87220: PPUSH
87221: LD_VAR 0 3
87225: PPUSH
87226: CALL_OW 428
87230: PUSH
87231: LD_VAR 0 1
87235: EQUAL
87236: PUSH
87237: LD_VAR 0 1
87241: PPUSH
87242: CALL_OW 314
87246: NOT
87247: AND
87248: IFFALSE 87174
// PlaySoundXY ( x , y , PlantMine ) ;
87250: LD_VAR 0 2
87254: PPUSH
87255: LD_VAR 0 3
87259: PPUSH
87260: LD_STRING PlantMine
87262: PPUSH
87263: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87267: LD_VAR 0 2
87271: PPUSH
87272: LD_VAR 0 3
87276: PPUSH
87277: LD_VAR 0 1
87281: PPUSH
87282: CALL_OW 255
87286: PPUSH
87287: LD_INT 0
87289: PPUSH
87290: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87294: LD_ADDR_EXP 112
87298: PUSH
87299: LD_EXP 112
87303: PPUSH
87304: LD_VAR 0 5
87308: PUSH
87309: LD_EXP 112
87313: PUSH
87314: LD_VAR 0 5
87318: ARRAY
87319: PUSH
87320: LD_INT 1
87322: PLUS
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PPUSH
87328: LD_VAR 0 2
87332: PUSH
87333: LD_VAR 0 3
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PPUSH
87342: CALL 14797 0 3
87346: ST_TO_ADDR
// result := true ;
87347: LD_ADDR_VAR 0 4
87351: PUSH
87352: LD_INT 1
87354: ST_TO_ADDR
// end ;
87355: LD_VAR 0 4
87359: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87360: LD_INT 0
87362: PPUSH
87363: PPUSH
87364: PPUSH
// if not unit in minersList then
87365: LD_VAR 0 1
87369: PUSH
87370: LD_EXP 111
87374: IN
87375: NOT
87376: IFFALSE 87380
// exit ;
87378: GO 87772
// index := GetElementIndex ( minersList , unit ) ;
87380: LD_ADDR_VAR 0 6
87384: PUSH
87385: LD_EXP 111
87389: PPUSH
87390: LD_VAR 0 1
87394: PPUSH
87395: CALL 14582 0 2
87399: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87400: LD_ADDR_VAR 0 5
87404: PUSH
87405: DOUBLE
87406: LD_EXP 112
87410: PUSH
87411: LD_VAR 0 6
87415: ARRAY
87416: INC
87417: ST_TO_ADDR
87418: LD_INT 1
87420: PUSH
87421: FOR_DOWNTO
87422: IFFALSE 87583
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87424: LD_EXP 112
87428: PUSH
87429: LD_VAR 0 6
87433: ARRAY
87434: PUSH
87435: LD_VAR 0 5
87439: ARRAY
87440: PUSH
87441: LD_INT 1
87443: ARRAY
87444: PUSH
87445: LD_VAR 0 2
87449: EQUAL
87450: PUSH
87451: LD_EXP 112
87455: PUSH
87456: LD_VAR 0 6
87460: ARRAY
87461: PUSH
87462: LD_VAR 0 5
87466: ARRAY
87467: PUSH
87468: LD_INT 2
87470: ARRAY
87471: PUSH
87472: LD_VAR 0 3
87476: EQUAL
87477: AND
87478: IFFALSE 87581
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87480: LD_EXP 112
87484: PUSH
87485: LD_VAR 0 6
87489: ARRAY
87490: PUSH
87491: LD_VAR 0 5
87495: ARRAY
87496: PUSH
87497: LD_INT 1
87499: ARRAY
87500: PPUSH
87501: LD_EXP 112
87505: PUSH
87506: LD_VAR 0 6
87510: ARRAY
87511: PUSH
87512: LD_VAR 0 5
87516: ARRAY
87517: PUSH
87518: LD_INT 2
87520: ARRAY
87521: PPUSH
87522: LD_VAR 0 1
87526: PPUSH
87527: CALL_OW 255
87531: PPUSH
87532: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87536: LD_ADDR_EXP 112
87540: PUSH
87541: LD_EXP 112
87545: PPUSH
87546: LD_VAR 0 6
87550: PPUSH
87551: LD_EXP 112
87555: PUSH
87556: LD_VAR 0 6
87560: ARRAY
87561: PPUSH
87562: LD_VAR 0 5
87566: PPUSH
87567: CALL_OW 3
87571: PPUSH
87572: CALL_OW 1
87576: ST_TO_ADDR
// exit ;
87577: POP
87578: POP
87579: GO 87772
// end ; end ;
87581: GO 87421
87583: POP
87584: POP
// for i := minerMinesList [ index ] downto 1 do
87585: LD_ADDR_VAR 0 5
87589: PUSH
87590: DOUBLE
87591: LD_EXP 112
87595: PUSH
87596: LD_VAR 0 6
87600: ARRAY
87601: INC
87602: ST_TO_ADDR
87603: LD_INT 1
87605: PUSH
87606: FOR_DOWNTO
87607: IFFALSE 87770
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87609: LD_EXP 112
87613: PUSH
87614: LD_VAR 0 6
87618: ARRAY
87619: PUSH
87620: LD_VAR 0 5
87624: ARRAY
87625: PUSH
87626: LD_INT 1
87628: ARRAY
87629: PPUSH
87630: LD_EXP 112
87634: PUSH
87635: LD_VAR 0 6
87639: ARRAY
87640: PUSH
87641: LD_VAR 0 5
87645: ARRAY
87646: PUSH
87647: LD_INT 2
87649: ARRAY
87650: PPUSH
87651: LD_VAR 0 2
87655: PPUSH
87656: LD_VAR 0 3
87660: PPUSH
87661: CALL_OW 298
87665: PUSH
87666: LD_INT 6
87668: LESS
87669: IFFALSE 87768
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87671: LD_EXP 112
87675: PUSH
87676: LD_VAR 0 6
87680: ARRAY
87681: PUSH
87682: LD_VAR 0 5
87686: ARRAY
87687: PUSH
87688: LD_INT 1
87690: ARRAY
87691: PPUSH
87692: LD_EXP 112
87696: PUSH
87697: LD_VAR 0 6
87701: ARRAY
87702: PUSH
87703: LD_VAR 0 5
87707: ARRAY
87708: PUSH
87709: LD_INT 2
87711: ARRAY
87712: PPUSH
87713: LD_VAR 0 1
87717: PPUSH
87718: CALL_OW 255
87722: PPUSH
87723: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87727: LD_ADDR_EXP 112
87731: PUSH
87732: LD_EXP 112
87736: PPUSH
87737: LD_VAR 0 6
87741: PPUSH
87742: LD_EXP 112
87746: PUSH
87747: LD_VAR 0 6
87751: ARRAY
87752: PPUSH
87753: LD_VAR 0 5
87757: PPUSH
87758: CALL_OW 3
87762: PPUSH
87763: CALL_OW 1
87767: ST_TO_ADDR
// end ; end ;
87768: GO 87606
87770: POP
87771: POP
// end ;
87772: LD_VAR 0 4
87776: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87777: LD_INT 0
87779: PPUSH
87780: PPUSH
87781: PPUSH
87782: PPUSH
87783: PPUSH
87784: PPUSH
87785: PPUSH
87786: PPUSH
87787: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
87788: LD_VAR 0 1
87792: PPUSH
87793: CALL_OW 264
87797: PUSH
87798: LD_EXP 93
87802: EQUAL
87803: NOT
87804: PUSH
87805: LD_VAR 0 1
87809: PUSH
87810: LD_EXP 111
87814: IN
87815: NOT
87816: OR
87817: IFFALSE 87821
// exit ;
87819: GO 88143
// index := GetElementIndex ( minersList , unit ) ;
87821: LD_ADDR_VAR 0 6
87825: PUSH
87826: LD_EXP 111
87830: PPUSH
87831: LD_VAR 0 1
87835: PPUSH
87836: CALL 14582 0 2
87840: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
87841: LD_ADDR_VAR 0 8
87845: PUSH
87846: LD_EXP 113
87850: PUSH
87851: LD_EXP 112
87855: PUSH
87856: LD_VAR 0 6
87860: ARRAY
87861: MINUS
87862: ST_TO_ADDR
// if not minesFreeAmount then
87863: LD_VAR 0 8
87867: NOT
87868: IFFALSE 87872
// exit ;
87870: GO 88143
// tmp := [ ] ;
87872: LD_ADDR_VAR 0 7
87876: PUSH
87877: EMPTY
87878: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
87879: LD_ADDR_VAR 0 5
87883: PUSH
87884: DOUBLE
87885: LD_INT 1
87887: DEC
87888: ST_TO_ADDR
87889: LD_VAR 0 8
87893: PUSH
87894: FOR_TO
87895: IFFALSE 88090
// begin _d := rand ( 0 , 5 ) ;
87897: LD_ADDR_VAR 0 11
87901: PUSH
87902: LD_INT 0
87904: PPUSH
87905: LD_INT 5
87907: PPUSH
87908: CALL_OW 12
87912: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
87913: LD_ADDR_VAR 0 12
87917: PUSH
87918: LD_INT 2
87920: PPUSH
87921: LD_INT 6
87923: PPUSH
87924: CALL_OW 12
87928: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
87929: LD_ADDR_VAR 0 9
87933: PUSH
87934: LD_VAR 0 2
87938: PPUSH
87939: LD_VAR 0 11
87943: PPUSH
87944: LD_VAR 0 12
87948: PPUSH
87949: CALL_OW 272
87953: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
87954: LD_ADDR_VAR 0 10
87958: PUSH
87959: LD_VAR 0 3
87963: PPUSH
87964: LD_VAR 0 11
87968: PPUSH
87969: LD_VAR 0 12
87973: PPUSH
87974: CALL_OW 273
87978: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
87979: LD_VAR 0 9
87983: PPUSH
87984: LD_VAR 0 10
87988: PPUSH
87989: CALL_OW 488
87993: PUSH
87994: LD_VAR 0 9
87998: PUSH
87999: LD_VAR 0 10
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_VAR 0 7
88012: IN
88013: NOT
88014: AND
88015: PUSH
88016: LD_VAR 0 9
88020: PPUSH
88021: LD_VAR 0 10
88025: PPUSH
88026: CALL_OW 458
88030: NOT
88031: AND
88032: IFFALSE 88074
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
88034: LD_ADDR_VAR 0 7
88038: PUSH
88039: LD_VAR 0 7
88043: PPUSH
88044: LD_VAR 0 7
88048: PUSH
88049: LD_INT 1
88051: PLUS
88052: PPUSH
88053: LD_VAR 0 9
88057: PUSH
88058: LD_VAR 0 10
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PPUSH
88067: CALL_OW 1
88071: ST_TO_ADDR
88072: GO 88088
// i := i - 1 ;
88074: LD_ADDR_VAR 0 5
88078: PUSH
88079: LD_VAR 0 5
88083: PUSH
88084: LD_INT 1
88086: MINUS
88087: ST_TO_ADDR
// end ;
88088: GO 87894
88090: POP
88091: POP
// for i in tmp do
88092: LD_ADDR_VAR 0 5
88096: PUSH
88097: LD_VAR 0 7
88101: PUSH
88102: FOR_IN
88103: IFFALSE 88141
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88105: LD_VAR 0 1
88109: PPUSH
88110: LD_VAR 0 5
88114: PUSH
88115: LD_INT 1
88117: ARRAY
88118: PPUSH
88119: LD_VAR 0 5
88123: PUSH
88124: LD_INT 2
88126: ARRAY
88127: PPUSH
88128: CALL 87083 0 3
88132: NOT
88133: IFFALSE 88139
// exit ;
88135: POP
88136: POP
88137: GO 88143
88139: GO 88102
88141: POP
88142: POP
// end ;
88143: LD_VAR 0 4
88147: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88148: LD_INT 0
88150: PPUSH
88151: PPUSH
88152: PPUSH
88153: PPUSH
88154: PPUSH
88155: PPUSH
88156: PPUSH
// if not GetClass ( unit ) = class_sniper then
88157: LD_VAR 0 1
88161: PPUSH
88162: CALL_OW 257
88166: PUSH
88167: LD_INT 5
88169: EQUAL
88170: NOT
88171: IFFALSE 88175
// exit ;
88173: GO 88563
// dist := 8 ;
88175: LD_ADDR_VAR 0 5
88179: PUSH
88180: LD_INT 8
88182: ST_TO_ADDR
// viewRange := 12 ;
88183: LD_ADDR_VAR 0 7
88187: PUSH
88188: LD_INT 12
88190: ST_TO_ADDR
// side := GetSide ( unit ) ;
88191: LD_ADDR_VAR 0 6
88195: PUSH
88196: LD_VAR 0 1
88200: PPUSH
88201: CALL_OW 255
88205: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88206: LD_INT 61
88208: PPUSH
88209: LD_VAR 0 6
88213: PPUSH
88214: CALL_OW 321
88218: PUSH
88219: LD_INT 2
88221: EQUAL
88222: IFFALSE 88232
// viewRange := 16 ;
88224: LD_ADDR_VAR 0 7
88228: PUSH
88229: LD_INT 16
88231: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88232: LD_VAR 0 1
88236: PPUSH
88237: LD_VAR 0 2
88241: PPUSH
88242: LD_VAR 0 3
88246: PPUSH
88247: CALL_OW 297
88251: PUSH
88252: LD_VAR 0 5
88256: GREATER
88257: IFFALSE 88336
// begin ComMoveXY ( unit , x , y ) ;
88259: LD_VAR 0 1
88263: PPUSH
88264: LD_VAR 0 2
88268: PPUSH
88269: LD_VAR 0 3
88273: PPUSH
88274: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88278: LD_INT 35
88280: PPUSH
88281: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88285: LD_VAR 0 1
88289: PPUSH
88290: LD_VAR 0 2
88294: PPUSH
88295: LD_VAR 0 3
88299: PPUSH
88300: CALL 44658 0 3
88304: NOT
88305: IFFALSE 88309
// exit ;
88307: GO 88563
// until GetDistUnitXY ( unit , x , y ) < dist ;
88309: LD_VAR 0 1
88313: PPUSH
88314: LD_VAR 0 2
88318: PPUSH
88319: LD_VAR 0 3
88323: PPUSH
88324: CALL_OW 297
88328: PUSH
88329: LD_VAR 0 5
88333: LESS
88334: IFFALSE 88278
// end ; ComTurnXY ( unit , x , y ) ;
88336: LD_VAR 0 1
88340: PPUSH
88341: LD_VAR 0 2
88345: PPUSH
88346: LD_VAR 0 3
88350: PPUSH
88351: CALL_OW 118
// wait ( 5 ) ;
88355: LD_INT 5
88357: PPUSH
88358: CALL_OW 67
// _d := GetDir ( unit ) ;
88362: LD_ADDR_VAR 0 10
88366: PUSH
88367: LD_VAR 0 1
88371: PPUSH
88372: CALL_OW 254
88376: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88377: LD_ADDR_VAR 0 8
88381: PUSH
88382: LD_VAR 0 1
88386: PPUSH
88387: CALL_OW 250
88391: PPUSH
88392: LD_VAR 0 10
88396: PPUSH
88397: LD_VAR 0 5
88401: PPUSH
88402: CALL_OW 272
88406: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88407: LD_ADDR_VAR 0 9
88411: PUSH
88412: LD_VAR 0 1
88416: PPUSH
88417: CALL_OW 251
88421: PPUSH
88422: LD_VAR 0 10
88426: PPUSH
88427: LD_VAR 0 5
88431: PPUSH
88432: CALL_OW 273
88436: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88437: LD_VAR 0 8
88441: PPUSH
88442: LD_VAR 0 9
88446: PPUSH
88447: CALL_OW 488
88451: NOT
88452: IFFALSE 88456
// exit ;
88454: GO 88563
// ComAnimCustom ( unit , 1 ) ;
88456: LD_VAR 0 1
88460: PPUSH
88461: LD_INT 1
88463: PPUSH
88464: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88468: LD_VAR 0 8
88472: PPUSH
88473: LD_VAR 0 9
88477: PPUSH
88478: LD_VAR 0 6
88482: PPUSH
88483: LD_VAR 0 7
88487: PPUSH
88488: CALL_OW 330
// repeat wait ( 1 ) ;
88492: LD_INT 1
88494: PPUSH
88495: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88499: LD_VAR 0 1
88503: PPUSH
88504: CALL_OW 316
88508: PUSH
88509: LD_VAR 0 1
88513: PPUSH
88514: CALL_OW 314
88518: OR
88519: PUSH
88520: LD_VAR 0 1
88524: PPUSH
88525: CALL_OW 302
88529: NOT
88530: OR
88531: PUSH
88532: LD_VAR 0 1
88536: PPUSH
88537: CALL_OW 301
88541: OR
88542: IFFALSE 88492
// RemoveSeeing ( _x , _y , side ) ;
88544: LD_VAR 0 8
88548: PPUSH
88549: LD_VAR 0 9
88553: PPUSH
88554: LD_VAR 0 6
88558: PPUSH
88559: CALL_OW 331
// end ; end_of_file
88563: LD_VAR 0 4
88567: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88568: LD_VAR 0 1
88572: PUSH
88573: LD_INT 200
88575: DOUBLE
88576: GREATEREQUAL
88577: IFFALSE 88585
88579: LD_INT 299
88581: DOUBLE
88582: LESSEQUAL
88583: IFTRUE 88587
88585: GO 88619
88587: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
88588: LD_VAR 0 1
88592: PPUSH
88593: LD_VAR 0 2
88597: PPUSH
88598: LD_VAR 0 3
88602: PPUSH
88603: LD_VAR 0 4
88607: PPUSH
88608: LD_VAR 0 5
88612: PPUSH
88613: CALL 84685 0 5
88617: GO 88620
88619: POP
// end ;
88620: PPOPN 11
88622: END
