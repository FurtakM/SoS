// every 0 0$1 do
   0: GO 2
   2: DISABLE
// IqAttack ( [ a1 ] , [ [ 19 , 13 ] , [ 32 , 21 ] ] ) ;
   3: LD_INT 4
   5: PUSH
   6: EMPTY
   7: LIST
   8: PPUSH
   9: LD_INT 19
  11: PUSH
  12: LD_INT 13
  14: PUSH
  15: EMPTY
  16: LIST
  17: LIST
  18: PUSH
  19: LD_INT 32
  21: PUSH
  22: LD_INT 21
  24: PUSH
  25: EMPTY
  26: LIST
  27: LIST
  28: PUSH
  29: EMPTY
  30: LIST
  31: LIST
  32: PPUSH
  33: CALL 56 0 2
  37: END
// every 1 do
  38: GO 40
  40: DISABLE
// begin enable ;
  41: ENABLE
// display_strings := GetTaskList ( a1 ) ;
  42: LD_ADDR_OWVAR 47
  46: PUSH
  47: LD_INT 4
  49: PPUSH
  50: CALL_OW 437
  54: ST_TO_ADDR
// end ;
  55: END
// export function IqAttack ( units , path ) ; var i , cr , enemy , tag , side ; begin
  56: LD_INT 0
  58: PPUSH
  59: PPUSH
  60: PPUSH
  61: PPUSH
  62: PPUSH
  63: PPUSH
// if not units or not path then
  64: LD_VAR 0 1
  68: NOT
  69: PUSH
  70: LD_VAR 0 2
  74: NOT
  75: OR
  76: IFFALSE 80
// exit ;
  78: GO 446
// side := GetSide ( units [ 1 ] ) ;
  80: LD_ADDR_VAR 0 8
  84: PUSH
  85: LD_VAR 0 1
  89: PUSH
  90: LD_INT 1
  92: ARRAY
  93: PPUSH
  94: CALL_OW 255
  98: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
  99: LD_INT 35
 101: PPUSH
 102: CALL_OW 67
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
 106: LD_ADDR_VAR 0 6
 110: PUSH
 111: LD_INT 81
 113: PUSH
 114: LD_VAR 0 8
 118: PUSH
 119: EMPTY
 120: LIST
 121: LIST
 122: PPUSH
 123: CALL_OW 69
 127: ST_TO_ADDR
// for i in units do
 128: LD_ADDR_VAR 0 4
 132: PUSH
 133: LD_VAR 0 1
 137: PUSH
 138: FOR_IN
 139: IFFALSE 437
// begin if IsDead ( i ) then
 141: LD_VAR 0 4
 145: PPUSH
 146: CALL_OW 301
 150: IFFALSE 168
// units := units diff i ;
 152: LD_ADDR_VAR 0 1
 156: PUSH
 157: LD_VAR 0 1
 161: PUSH
 162: LD_VAR 0 4
 166: DIFF
 167: ST_TO_ADDR
// if not HasTask ( i ) then
 168: LD_VAR 0 4
 172: PPUSH
 173: CALL_OW 314
 177: NOT
 178: IFFALSE 435
// begin tag := GetTag ( i ) ;
 180: LD_ADDR_VAR 0 7
 184: PUSH
 185: LD_VAR 0 4
 189: PPUSH
 190: CALL_OW 110
 194: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
 195: LD_ADDR_VAR 0 5
 199: PUSH
 200: LD_VAR 0 4
 204: PPUSH
 205: CALL_OW 250
 209: PPUSH
 210: LD_VAR 0 4
 214: PPUSH
 215: CALL_OW 251
 219: PPUSH
 220: LD_INT 6
 222: PPUSH
 223: CALL 451 0 3
 227: ST_TO_ADDR
// if cr then
 228: LD_VAR 0 5
 232: IFFALSE 271
// ComAgressiveMove ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
 234: LD_VAR 0 4
 238: PPUSH
 239: LD_VAR 0 5
 243: PUSH
 244: LD_INT 1
 246: ARRAY
 247: PUSH
 248: LD_INT 1
 250: ARRAY
 251: PPUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_INT 1
 259: ARRAY
 260: PUSH
 261: LD_INT 2
 263: ARRAY
 264: PPUSH
 265: CALL_OW 114
 269: GO 435
// if tag < path then
 271: LD_VAR 0 7
 275: PUSH
 276: LD_VAR 0 2
 280: LESS
 281: IFFALSE 405
// begin if GetDistUnitXY ( i , path [ tag + 1 ] [ 1 ] , path [ tag + 1 ] [ 2 ] ) > 3 then
 283: LD_VAR 0 4
 287: PPUSH
 288: LD_VAR 0 2
 292: PUSH
 293: LD_VAR 0 7
 297: PUSH
 298: LD_INT 1
 300: PLUS
 301: ARRAY
 302: PUSH
 303: LD_INT 1
 305: ARRAY
 306: PPUSH
 307: LD_VAR 0 2
 311: PUSH
 312: LD_VAR 0 7
 316: PUSH
 317: LD_INT 1
 319: PLUS
 320: ARRAY
 321: PUSH
 322: LD_INT 2
 324: ARRAY
 325: PPUSH
 326: CALL_OW 297
 330: PUSH
 331: LD_INT 3
 333: GREATER
 334: IFFALSE 385
// ComAgressiveMove ( i , path [ tag + 1 ] [ 1 ] , path [ tag + 1 ] [ 2 ] ) else
 336: LD_VAR 0 4
 340: PPUSH
 341: LD_VAR 0 2
 345: PUSH
 346: LD_VAR 0 7
 350: PUSH
 351: LD_INT 1
 353: PLUS
 354: ARRAY
 355: PUSH
 356: LD_INT 1
 358: ARRAY
 359: PPUSH
 360: LD_VAR 0 2
 364: PUSH
 365: LD_VAR 0 7
 369: PUSH
 370: LD_INT 1
 372: PLUS
 373: ARRAY
 374: PUSH
 375: LD_INT 2
 377: ARRAY
 378: PPUSH
 379: CALL_OW 114
 383: GO 403
// SetTag ( i , tag + 1 ) ;
 385: LD_VAR 0 4
 389: PPUSH
 390: LD_VAR 0 7
 394: PUSH
 395: LD_INT 1
 397: PLUS
 398: PPUSH
 399: CALL_OW 109
// end else
 403: GO 435
// begin if enemy then
 405: LD_VAR 0 6
 409: IFFALSE 435
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
 411: LD_VAR 0 4
 415: PPUSH
 416: LD_VAR 0 6
 420: PPUSH
 421: LD_VAR 0 4
 425: PPUSH
 426: CALL_OW 74
 430: PPUSH
 431: CALL_OW 115
// end ; end ; end ;
 435: GO 138
 437: POP
 438: POP
// until not units ;
 439: LD_VAR 0 1
 443: NOT
 444: IFFALSE 99
// end ;
 446: LD_VAR 0 3
 450: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
 455: PPUSH
 456: PPUSH
 457: PPUSH
 458: PPUSH
 459: PPUSH
// result := [ ] ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: EMPTY
 466: ST_TO_ADDR
// if x - r < 0 then
 467: LD_VAR 0 1
 471: PUSH
 472: LD_VAR 0 3
 476: MINUS
 477: PUSH
 478: LD_INT 0
 480: LESS
 481: IFFALSE 493
// min_x := 0 else
 483: LD_ADDR_VAR 0 8
 487: PUSH
 488: LD_INT 0
 490: ST_TO_ADDR
 491: GO 509
// min_x := x - r ;
 493: LD_ADDR_VAR 0 8
 497: PUSH
 498: LD_VAR 0 1
 502: PUSH
 503: LD_VAR 0 3
 507: MINUS
 508: ST_TO_ADDR
// if y - r < 0 then
 509: LD_VAR 0 2
 513: PUSH
 514: LD_VAR 0 3
 518: MINUS
 519: PUSH
 520: LD_INT 0
 522: LESS
 523: IFFALSE 535
// min_y := 0 else
 525: LD_ADDR_VAR 0 7
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
 533: GO 551
// min_y := y - r ;
 535: LD_ADDR_VAR 0 7
 539: PUSH
 540: LD_VAR 0 2
 544: PUSH
 545: LD_VAR 0 3
 549: MINUS
 550: ST_TO_ADDR
// max_x := x + r ;
 551: LD_ADDR_VAR 0 9
 555: PUSH
 556: LD_VAR 0 1
 560: PUSH
 561: LD_VAR 0 3
 565: PLUS
 566: ST_TO_ADDR
// max_y := y + r ;
 567: LD_ADDR_VAR 0 10
 571: PUSH
 572: LD_VAR 0 2
 576: PUSH
 577: LD_VAR 0 3
 581: PLUS
 582: ST_TO_ADDR
// for _x = min_x to max_x do
 583: LD_ADDR_VAR 0 5
 587: PUSH
 588: DOUBLE
 589: LD_VAR 0 8
 593: DEC
 594: ST_TO_ADDR
 595: LD_VAR 0 9
 599: PUSH
 600: FOR_TO
 601: IFFALSE 702
// for _y = min_y to max_y do
 603: LD_ADDR_VAR 0 6
 607: PUSH
 608: DOUBLE
 609: LD_VAR 0 7
 613: DEC
 614: ST_TO_ADDR
 615: LD_VAR 0 10
 619: PUSH
 620: FOR_TO
 621: IFFALSE 698
// begin if not ValidHex ( _x , _y ) then
 623: LD_VAR 0 5
 627: PPUSH
 628: LD_VAR 0 6
 632: PPUSH
 633: CALL_OW 488
 637: NOT
 638: IFFALSE 642
// continue ;
 640: GO 620
// if GetResourceTypeXY ( _x , _y ) then
 642: LD_VAR 0 5
 646: PPUSH
 647: LD_VAR 0 6
 651: PPUSH
 652: CALL_OW 283
 656: IFFALSE 696
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
 658: LD_ADDR_VAR 0 4
 662: PUSH
 663: LD_VAR 0 4
 667: PPUSH
 668: LD_VAR 0 4
 672: PUSH
 673: LD_INT 1
 675: PLUS
 676: PPUSH
 677: LD_VAR 0 5
 681: PUSH
 682: LD_VAR 0 6
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: PPUSH
 691: CALL_OW 1
 695: ST_TO_ADDR
// end ;
 696: GO 620
 698: POP
 699: POP
 700: GO 600
 702: POP
 703: POP
// end ;
 704: LD_VAR 0 4
 708: RET
// export function ComAttackPlaceForce ( unit , x , y ) ; begin
 709: LD_INT 0
 711: PPUSH
// if not unit then
 712: LD_VAR 0 1
 716: NOT
 717: IFFALSE 721
// exit ;
 719: GO 768
// SetTaskList ( unit , [ [ A , x , y , - 1 , 0 , 0 , 0 ] ] ) ;
 721: LD_VAR 0 1
 725: PPUSH
 726: LD_STRING A
 728: PUSH
 729: LD_VAR 0 2
 733: PUSH
 734: LD_VAR 0 3
 738: PUSH
 739: LD_INT 1
 741: NEG
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: LD_INT 0
 748: PUSH
 749: LD_INT 0
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: LIST
 760: PUSH
 761: EMPTY
 762: LIST
 763: PPUSH
 764: CALL_OW 446
// end ;
 768: LD_VAR 0 4
 772: RET
