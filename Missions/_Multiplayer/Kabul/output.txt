// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3708 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 405
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 2 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 2
 265: ST_TO_ADDR
// Side_Positions := [ 0 , 1 , 0 , 0 , 2 , 0 , 0 , 3 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 0
 273: PUSH
 274: LD_INT 1
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 0
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 3
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 0
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 0
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 1
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 0 , 3 , 0 , 0 , 3 , 0 , 0 , 3 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 0
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 0
 360: PUSH
 361: LD_INT 3
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 3
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 2 , 5 , 8 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 5
 393: PUSH
 394: LD_INT 8
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: EMPTY
 403: LIST
 404: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 405: LD_ADDR_EXP 7
 409: PUSH
 410: LD_INT 203
 412: PUSH
 413: LD_INT 174
 415: PUSH
 416: EMPTY
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 114
 422: PUSH
 423: LD_INT 171
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 26
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: PUSH
 448: EMPTY
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: ST_TO_ADDR
// Bot_Side := 2 ;
 460: LD_ADDR_EXP 8
 464: PUSH
 465: LD_INT 2
 467: ST_TO_ADDR
// for i = 1 to 8 do
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: DOUBLE
 474: LD_INT 1
 476: DEC
 477: ST_TO_ADDR
 478: LD_INT 8
 480: PUSH
 481: FOR_TO
 482: IFFALSE 625
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 484: LD_VAR 0 2
 488: PPUSH
 489: CALL_OW 530
 493: PUSH
 494: LD_VAR 0 2
 498: PPUSH
 499: CALL_OW 532
 503: OR
 504: IFFALSE 578
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 506: LD_ADDR_EXP 2
 510: PUSH
 511: LD_EXP 2
 515: PPUSH
 516: LD_VAR 0 2
 520: PPUSH
 521: LD_INT 0
 523: PPUSH
 524: CALL_OW 1
 528: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 529: LD_ADDR_EXP 5
 533: PUSH
 534: LD_EXP 5
 538: PPUSH
 539: LD_EXP 3
 543: PUSH
 544: LD_VAR 0 2
 548: ARRAY
 549: PPUSH
 550: LD_EXP 5
 554: PUSH
 555: LD_EXP 3
 559: PUSH
 560: LD_VAR 0 2
 564: ARRAY
 565: ARRAY
 566: PUSH
 567: LD_VAR 0 2
 571: DIFF
 572: PPUSH
 573: CALL_OW 1
 577: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 578: LD_EXP 4
 582: PUSH
 583: LD_VAR 0 2
 587: ARRAY
 588: PUSH
 589: LD_EXP 4
 593: PUSH
 594: LD_INT 3
 596: NONEQUAL
 597: AND
 598: IFFALSE 623
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 600: LD_ADDR_EXP 4
 604: PUSH
 605: LD_EXP 4
 609: PPUSH
 610: LD_VAR 0 2
 614: PPUSH
 615: LD_INT 3
 617: PPUSH
 618: CALL_OW 1
 622: ST_TO_ADDR
// end ;
 623: GO 481
 625: POP
 626: POP
// for i = 1 to 8 do
 627: LD_ADDR_VAR 0 2
 631: PUSH
 632: DOUBLE
 633: LD_INT 1
 635: DEC
 636: ST_TO_ADDR
 637: LD_INT 8
 639: PUSH
 640: FOR_TO
 641: IFFALSE 670
// if not Side_Positions [ i ] then
 643: LD_EXP 2
 647: PUSH
 648: LD_VAR 0 2
 652: ARRAY
 653: NOT
 654: IFFALSE 668
// begin bot_side := i ;
 656: LD_ADDR_EXP 8
 660: PUSH
 661: LD_VAR 0 2
 665: ST_TO_ADDR
// break ;
 666: GO 670
// end ;
 668: GO 640
 670: POP
 671: POP
// Team_Game := false ;
 672: LD_ADDR_EXP 6
 676: PUSH
 677: LD_INT 0
 679: ST_TO_ADDR
// for i = 1 to 8 do
 680: LD_ADDR_VAR 0 2
 684: PUSH
 685: DOUBLE
 686: LD_INT 1
 688: DEC
 689: ST_TO_ADDR
 690: LD_INT 8
 692: PUSH
 693: FOR_TO
 694: IFFALSE 720
// if Side_Teams [ i ] then
 696: LD_EXP 3
 700: PUSH
 701: LD_VAR 0 2
 705: ARRAY
 706: IFFALSE 718
// begin Team_Game := true ;
 708: LD_ADDR_EXP 6
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// break ;
 716: GO 720
// end ;
 718: GO 693
 720: POP
 721: POP
// for i = 1 to 8 do
 722: LD_ADDR_VAR 0 2
 726: PUSH
 727: DOUBLE
 728: LD_INT 1
 730: DEC
 731: ST_TO_ADDR
 732: LD_INT 8
 734: PUSH
 735: FOR_TO
 736: IFFALSE 772
// if i <> bot_side then
 738: LD_VAR 0 2
 742: PUSH
 743: LD_EXP 8
 747: NONEQUAL
 748: IFFALSE 770
// SetAttitude ( i , bot_side , att_enemy , true ) ;
 750: LD_VAR 0 2
 754: PPUSH
 755: LD_EXP 8
 759: PPUSH
 760: LD_INT 2
 762: PPUSH
 763: LD_INT 1
 765: PPUSH
 766: CALL_OW 80
 770: GO 735
 772: POP
 773: POP
// for i in Teams do
 774: LD_ADDR_VAR 0 2
 778: PUSH
 779: LD_EXP 5
 783: PUSH
 784: FOR_IN
 785: IFFALSE 865
// for j = 2 to i do
 787: LD_ADDR_VAR 0 3
 791: PUSH
 792: DOUBLE
 793: LD_INT 2
 795: DEC
 796: ST_TO_ADDR
 797: LD_VAR 0 2
 801: PUSH
 802: FOR_TO
 803: IFFALSE 861
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 805: LD_VAR 0 2
 809: PUSH
 810: LD_VAR 0 3
 814: ARRAY
 815: PPUSH
 816: LD_VAR 0 2
 820: PUSH
 821: LD_INT 1
 823: ARRAY
 824: PPUSH
 825: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 829: LD_VAR 0 2
 833: PUSH
 834: LD_VAR 0 3
 838: ARRAY
 839: PPUSH
 840: LD_VAR 0 2
 844: PUSH
 845: LD_INT 1
 847: ARRAY
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// end ;
 859: GO 802
 861: POP
 862: POP
 863: GO 784
 865: POP
 866: POP
// if not Multiplayer then
 867: LD_OWVAR 4
 871: NOT
 872: IFFALSE 909
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 874: LD_ADDR_EXP 16
 878: PUSH
 879: LD_INT 1
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 1
 890: PUSH
 891: LD_INT 2
 893: PUSH
 894: LD_INT 3
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 909: LD_ADDR_EXP 10
 913: PUSH
 914: LD_INT 9
 916: PUSH
 917: LD_INT 12
 919: PUSH
 920: LD_INT 15
 922: PUSH
 923: LD_INT 24
 925: PUSH
 926: EMPTY
 927: LIST
 928: LIST
 929: LIST
 930: LIST
 931: PUSH
 932: LD_EXP 16
 936: PUSH
 937: LD_INT 1
 939: ARRAY
 940: ARRAY
 941: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 942: LD_ADDR_EXP 11
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 4
 952: PUSH
 953: LD_INT 6
 955: PUSH
 956: LD_INT 8
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: LIST
 964: PUSH
 965: LD_EXP 16
 969: PUSH
 970: LD_INT 2
 972: ARRAY
 973: ARRAY
 974: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 975: LD_ADDR_EXP 12
 979: PUSH
 980: LD_INT 1050
 982: PUSH
 983: LD_INT 875
 985: PUSH
 986: LD_INT 700
 988: PUSH
 989: LD_INT 595
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_EXP 16
1002: PUSH
1003: LD_INT 3
1005: ARRAY
1006: ARRAY
1007: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
1008: LD_ADDR_EXP 13
1012: PUSH
1013: LD_INT 0
1015: PUSH
1016: LD_INT 10500
1018: PUSH
1019: LD_INT 6300
1021: PUSH
1022: EMPTY
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_EXP 16
1031: PUSH
1032: LD_INT 4
1034: ARRAY
1035: ARRAY
1036: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 31500
1047: PUSH
1048: LD_INT 10500
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: PUSH
1056: LD_EXP 16
1060: PUSH
1061: LD_INT 4
1063: ARRAY
1064: ARRAY
1065: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1066: LD_ADDR_EXP 15
1070: PUSH
1071: LD_INT 0
1073: PUSH
1074: LD_INT 3
1076: PUSH
1077: LD_INT 5
1079: PUSH
1080: LD_INT 7
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: LD_EXP 16
1093: PUSH
1094: LD_INT 5
1096: ARRAY
1097: ARRAY
1098: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1099: LD_ADDR_OWVAR 67
1103: PUSH
1104: LD_INT 1
1106: PUSH
1107: LD_INT 2
1109: PUSH
1110: LD_INT 3
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_EXP 16
1122: PUSH
1123: LD_INT 6
1125: ARRAY
1126: ARRAY
1127: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1128: LD_ADDR_EXP 26
1132: PUSH
1133: LD_INT 0
1135: PUSH
1136: LD_INT 1
1138: PUSH
1139: LD_INT 2
1141: PUSH
1142: EMPTY
1143: LIST
1144: LIST
1145: LIST
1146: PUSH
1147: LD_EXP 16
1151: PUSH
1152: LD_INT 7
1154: ARRAY
1155: ARRAY
1156: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1157: LD_ADDR_EXP 23
1161: PUSH
1162: LD_INT 11353
1164: PUSH
1165: LD_INT 12244
1167: PUSH
1168: LD_INT 44444
1170: PUSH
1171: LD_INT 12345
1173: PUSH
1174: LD_INT 43413
1176: PUSH
1177: LD_INT 14152
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1188: LD_ADDR_EXP 24
1192: PUSH
1193: LD_INT 1
1195: PPUSH
1196: LD_INT 6
1198: PPUSH
1199: CALL_OW 12
1203: ST_TO_ADDR
// if bot_side <> 2 then
1204: LD_EXP 8
1208: PUSH
1209: LD_INT 2
1211: NONEQUAL
1212: IFFALSE 1255
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1214: LD_ADDR_VAR 0 2
1218: PUSH
1219: LD_INT 22
1221: PUSH
1222: LD_INT 2
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: PUSH
1234: FOR_IN
1235: IFFALSE 1253
// SetSide ( i , bot_side ) ;
1237: LD_VAR 0 2
1241: PPUSH
1242: LD_EXP 8
1246: PPUSH
1247: CALL_OW 235
1251: GO 1234
1253: POP
1254: POP
// ResetFog ;
1255: CALL_OW 335
// PreparePeople ( ) ;
1259: CALL 2089 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1263: LD_ADDR_EXP 18
1267: PUSH
1268: LD_INT 14
1270: PUSH
1271: LD_INT 15
1273: PUSH
1274: LD_INT 16
1276: PUSH
1277: EMPTY
1278: LIST
1279: LIST
1280: LIST
1281: ST_TO_ADDR
// if amount_of_apeman then
1282: LD_EXP 15
1286: IFFALSE 1336
// for j in apeman_areas do
1288: LD_ADDR_VAR 0 3
1292: PUSH
1293: LD_EXP 18
1297: PUSH
1298: FOR_IN
1299: IFFALSE 1334
// for i = 1 to amount_of_apeman do
1301: LD_ADDR_VAR 0 2
1305: PUSH
1306: DOUBLE
1307: LD_INT 1
1309: DEC
1310: ST_TO_ADDR
1311: LD_EXP 15
1315: PUSH
1316: FOR_TO
1317: IFFALSE 1330
// AddApeman ( j ) ;
1319: LD_VAR 0 3
1323: PPUSH
1324: CALL 3038 0 1
1328: GO 1316
1330: POP
1331: POP
1332: GO 1298
1334: POP
1335: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1336: LD_INT 22
1338: PUSH
1339: LD_OWVAR 2
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: PPUSH
1348: CALL_OW 69
1352: PUSH
1353: LD_INT 1
1355: ARRAY
1356: PPUSH
1357: CALL_OW 87
// disable ( 17 ) ;
1361: LD_INT 17
1363: DISABLE_MARKED
// end ;
1364: LD_VAR 0 1
1368: RET
// every 3 3$40 trigger game_start do
1369: LD_EXP 9
1373: IFFALSE 1429
1375: GO 1377
1377: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1378: LD_OWVAR 1
1382: PUSH
1383: LD_INT 5
1385: MOD
1386: PUSH
1387: LD_INT 1
1389: PLUS
1390: PPUSH
1391: LD_INT 13
1393: PPUSH
1394: LD_INT 1
1396: PPUSH
1397: CALL_OW 55
// Wait ( 0 0$15 ) ;
1401: LD_INT 525
1403: PPUSH
1404: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1408: LD_OWVAR 1
1412: PUSH
1413: LD_INT 5
1415: MOD
1416: PUSH
1417: LD_INT 1
1419: PLUS
1420: PPUSH
1421: LD_INT 1
1423: PPUSH
1424: CALL_OW 57
// enable ;
1428: ENABLE
// end ;
1429: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1430: LD_EXP 9
1434: IFFALSE 2086
1436: GO 1438
1438: DISABLE
1439: LD_INT 0
1441: PPUSH
1442: PPUSH
// begin cr := 1 ;
1443: LD_ADDR_VAR 0 1
1447: PUSH
1448: LD_INT 1
1450: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1451: LD_ADDR_VAR 0 2
1455: PUSH
1456: LD_INT 1
1458: PPUSH
1459: LD_INT 3
1461: PPUSH
1462: CALL_OW 12
1466: PUSH
1467: LD_INT 2
1469: PPUSH
1470: LD_INT 4
1472: PPUSH
1473: CALL_OW 12
1477: PUSH
1478: LD_INT 3
1480: PPUSH
1481: LD_INT 5
1483: PPUSH
1484: CALL_OW 12
1488: PUSH
1489: LD_INT 3
1491: PPUSH
1492: LD_INT 5
1494: PPUSH
1495: CALL_OW 12
1499: PUSH
1500: LD_INT 2
1502: PPUSH
1503: LD_INT 5
1505: PPUSH
1506: CALL_OW 12
1510: PUSH
1511: LD_INT 1
1513: PPUSH
1514: LD_INT 5
1516: PPUSH
1517: CALL_OW 12
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: ST_TO_ADDR
// while ( true ) do
1530: LD_INT 1
1532: IFFALSE 2086
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1534: LD_EXP 12
1538: PUSH
1539: LD_OWVAR 1
1543: PUSH
1544: LD_INT 35
1546: MOD
1547: PUSH
1548: LD_INT 60
1550: MUL
1551: PLUS
1552: PPUSH
1553: CALL_OW 67
// if cr mod 3 = 0 then
1557: LD_VAR 0 1
1561: PUSH
1562: LD_INT 3
1564: MOD
1565: PUSH
1566: LD_INT 0
1568: EQUAL
1569: IFFALSE 1722
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1571: LD_VAR 0 2
1575: PUSH
1576: LD_VAR 0 1
1580: PUSH
1581: LD_VAR 0 2
1585: MOD
1586: PUSH
1587: LD_INT 1
1589: PLUS
1590: ARRAY
1591: PPUSH
1592: LD_INT 17
1594: PPUSH
1595: LD_INT 1
1597: PPUSH
1598: CALL_OW 55
// Wait ( crates_spawn ) ;
1602: LD_EXP 12
1606: PPUSH
1607: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1611: LD_VAR 0 2
1615: PUSH
1616: LD_VAR 0 1
1620: PUSH
1621: LD_VAR 0 2
1625: MOD
1626: PUSH
1627: LD_INT 1
1629: PLUS
1630: ARRAY
1631: PPUSH
1632: LD_INT 18
1634: PPUSH
1635: LD_INT 1
1637: PPUSH
1638: CALL_OW 55
// Wait ( crates_spawn ) ;
1642: LD_EXP 12
1646: PPUSH
1647: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1651: LD_VAR 0 2
1655: PUSH
1656: LD_VAR 0 1
1660: PUSH
1661: LD_VAR 0 2
1665: MOD
1666: PUSH
1667: LD_INT 1
1669: PLUS
1670: ARRAY
1671: PPUSH
1672: LD_INT 19
1674: PPUSH
1675: LD_INT 1
1677: PPUSH
1678: CALL_OW 55
// Wait ( crates_spawn ) ;
1682: LD_EXP 12
1686: PPUSH
1687: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1691: LD_VAR 0 2
1695: PUSH
1696: LD_VAR 0 1
1700: PUSH
1701: LD_VAR 0 2
1705: MOD
1706: PUSH
1707: LD_INT 1
1709: PLUS
1710: ARRAY
1711: PPUSH
1712: LD_INT 17
1714: PPUSH
1715: LD_INT 1
1717: PPUSH
1718: CALL_OW 55
// end ; if cr mod 3 = 1 then
1722: LD_VAR 0 1
1726: PUSH
1727: LD_INT 3
1729: MOD
1730: PUSH
1731: LD_INT 1
1733: EQUAL
1734: IFFALSE 1887
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1736: LD_VAR 0 2
1740: PUSH
1741: LD_VAR 0 1
1745: PUSH
1746: LD_VAR 0 2
1750: MOD
1751: PUSH
1752: LD_INT 1
1754: PLUS
1755: ARRAY
1756: PPUSH
1757: LD_INT 18
1759: PPUSH
1760: LD_INT 1
1762: PPUSH
1763: CALL_OW 55
// Wait ( crates_spawn ) ;
1767: LD_EXP 12
1771: PPUSH
1772: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1776: LD_VAR 0 2
1780: PUSH
1781: LD_VAR 0 1
1785: PUSH
1786: LD_VAR 0 2
1790: MOD
1791: PUSH
1792: LD_INT 1
1794: PLUS
1795: ARRAY
1796: PPUSH
1797: LD_INT 17
1799: PPUSH
1800: LD_INT 1
1802: PPUSH
1803: CALL_OW 55
// Wait ( crates_spawn ) ;
1807: LD_EXP 12
1811: PPUSH
1812: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1816: LD_VAR 0 2
1820: PUSH
1821: LD_VAR 0 1
1825: PUSH
1826: LD_VAR 0 2
1830: MOD
1831: PUSH
1832: LD_INT 1
1834: PLUS
1835: ARRAY
1836: PPUSH
1837: LD_INT 19
1839: PPUSH
1840: LD_INT 1
1842: PPUSH
1843: CALL_OW 55
// Wait ( crates_spawn ) ;
1847: LD_EXP 12
1851: PPUSH
1852: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1856: LD_VAR 0 2
1860: PUSH
1861: LD_VAR 0 1
1865: PUSH
1866: LD_VAR 0 2
1870: MOD
1871: PUSH
1872: LD_INT 1
1874: PLUS
1875: ARRAY
1876: PPUSH
1877: LD_INT 18
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: CALL_OW 55
// end ; if cr mod 3 = 2 then
1887: LD_VAR 0 1
1891: PUSH
1892: LD_INT 3
1894: MOD
1895: PUSH
1896: LD_INT 2
1898: EQUAL
1899: IFFALSE 2052
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1901: LD_VAR 0 2
1905: PUSH
1906: LD_VAR 0 1
1910: PUSH
1911: LD_VAR 0 2
1915: MOD
1916: PUSH
1917: LD_INT 1
1919: PLUS
1920: ARRAY
1921: PPUSH
1922: LD_INT 19
1924: PPUSH
1925: LD_INT 1
1927: PPUSH
1928: CALL_OW 55
// Wait ( crates_spawn ) ;
1932: LD_EXP 12
1936: PPUSH
1937: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1941: LD_VAR 0 2
1945: PUSH
1946: LD_VAR 0 1
1950: PUSH
1951: LD_VAR 0 2
1955: MOD
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: ARRAY
1961: PPUSH
1962: LD_INT 18
1964: PPUSH
1965: LD_INT 1
1967: PPUSH
1968: CALL_OW 55
// Wait ( crates_spawn ) ;
1972: LD_EXP 12
1976: PPUSH
1977: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1981: LD_VAR 0 2
1985: PUSH
1986: LD_VAR 0 1
1990: PUSH
1991: LD_VAR 0 2
1995: MOD
1996: PUSH
1997: LD_INT 1
1999: PLUS
2000: ARRAY
2001: PPUSH
2002: LD_INT 17
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: CALL_OW 55
// Wait ( crates_spawn ) ;
2012: LD_EXP 12
2016: PPUSH
2017: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
2021: LD_VAR 0 2
2025: PUSH
2026: LD_VAR 0 1
2030: PUSH
2031: LD_VAR 0 2
2035: MOD
2036: PUSH
2037: LD_INT 1
2039: PLUS
2040: ARRAY
2041: PPUSH
2042: LD_INT 19
2044: PPUSH
2045: LD_INT 1
2047: PPUSH
2048: CALL_OW 55
// end ; cr := cr + 1 ;
2052: LD_ADDR_VAR 0 1
2056: PUSH
2057: LD_VAR 0 1
2061: PUSH
2062: LD_INT 1
2064: PLUS
2065: ST_TO_ADDR
// if cr > 150 then
2066: LD_VAR 0 1
2070: PUSH
2071: LD_INT 150
2073: GREATER
2074: IFFALSE 2084
// cr := 43 ;
2076: LD_ADDR_VAR 0 1
2080: PUSH
2081: LD_INT 43
2083: ST_TO_ADDR
// end ;
2084: GO 1530
// end ; end_of_file
2086: PPOPN 2
2088: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2089: LD_INT 0
2091: PPUSH
2092: PPUSH
2093: PPUSH
2094: PPUSH
2095: PPUSH
2096: PPUSH
2097: PPUSH
2098: PPUSH
2099: PPUSH
// to_copy := [ ] ;
2100: LD_ADDR_VAR 0 5
2104: PUSH
2105: EMPTY
2106: ST_TO_ADDR
// for i = 1 to 8 do
2107: LD_ADDR_VAR 0 2
2111: PUSH
2112: DOUBLE
2113: LD_INT 1
2115: DEC
2116: ST_TO_ADDR
2117: LD_INT 8
2119: PUSH
2120: FOR_TO
2121: IFFALSE 3031
// begin if Side_Positions [ i ] then
2123: LD_EXP 2
2127: PUSH
2128: LD_VAR 0 2
2132: ARRAY
2133: IFFALSE 3029
// begin uc_side := i ;
2135: LD_ADDR_OWVAR 20
2139: PUSH
2140: LD_VAR 0 2
2144: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2145: LD_ADDR_OWVAR 21
2149: PUSH
2150: LD_EXP 4
2154: PUSH
2155: LD_VAR 0 2
2159: ARRAY
2160: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2161: LD_ADDR_VAR 0 6
2165: PUSH
2166: LD_EXP 7
2170: PUSH
2171: LD_EXP 2
2175: PUSH
2176: LD_VAR 0 2
2180: ARRAY
2181: ARRAY
2182: PUSH
2183: LD_INT 1
2185: ARRAY
2186: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2187: LD_ADDR_VAR 0 7
2191: PUSH
2192: LD_EXP 7
2196: PUSH
2197: LD_EXP 2
2201: PUSH
2202: LD_VAR 0 2
2206: ARRAY
2207: ARRAY
2208: PUSH
2209: LD_INT 2
2211: ARRAY
2212: ST_TO_ADDR
// hc_importance := 100 ;
2213: LD_ADDR_OWVAR 32
2217: PUSH
2218: LD_INT 100
2220: ST_TO_ADDR
// if Multiplayer then
2221: LD_OWVAR 4
2225: IFFALSE 2283
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2227: LD_ADDR_OWVAR 26
2231: PUSH
2232: LD_OWVAR 19
2236: PUSH
2237: LD_OWVAR 20
2241: ARRAY
2242: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2243: LD_ADDR_OWVAR 33
2247: PUSH
2248: LD_STRING MULTIAVATARS
2250: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2251: LD_ADDR_OWVAR 34
2255: PUSH
2256: LD_OWVAR 20
2260: PPUSH
2261: CALL_OW 525
2265: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2266: LD_ADDR_OWVAR 27
2270: PUSH
2271: LD_OWVAR 20
2275: PPUSH
2276: CALL_OW 526
2280: ST_TO_ADDR
// end else
2281: GO 2315
// begin hc_name :=  ;
2283: LD_ADDR_OWVAR 26
2287: PUSH
2288: LD_STRING 
2290: ST_TO_ADDR
// hc_gallery :=  ;
2291: LD_ADDR_OWVAR 33
2295: PUSH
2296: LD_STRING 
2298: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2299: LD_ADDR_OWVAR 27
2303: PUSH
2304: LD_INT 1
2306: PPUSH
2307: LD_INT 2
2309: PPUSH
2310: CALL_OW 12
2314: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2315: LD_OWVAR 27
2319: PPUSH
2320: LD_INT 1
2322: PPUSH
2323: LD_EXP 11
2327: PPUSH
2328: CALL_OW 380
// un := CreateHuman ;
2332: LD_ADDR_VAR 0 4
2336: PUSH
2337: CALL_OW 44
2341: ST_TO_ADDR
// if not to_copy then
2342: LD_VAR 0 5
2346: NOT
2347: IFFALSE 2374
// to_copy := Replace ( to_copy , 1 , un ) else
2349: LD_ADDR_VAR 0 5
2353: PUSH
2354: LD_VAR 0 5
2358: PPUSH
2359: LD_INT 1
2361: PPUSH
2362: LD_VAR 0 4
2366: PPUSH
2367: CALL_OW 1
2371: ST_TO_ADDR
2372: GO 2450
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2374: LD_VAR 0 5
2378: PUSH
2379: LD_INT 1
2381: ARRAY
2382: PPUSH
2383: LD_VAR 0 4
2387: PPUSH
2388: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2392: LD_VAR 0 4
2396: PPUSH
2397: LD_INT 2
2399: PPUSH
2400: LD_VAR 0 5
2404: PUSH
2405: LD_INT 1
2407: ARRAY
2408: PPUSH
2409: LD_INT 2
2411: PPUSH
2412: CALL_OW 260
2416: PPUSH
2417: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2421: LD_VAR 0 4
2425: PPUSH
2426: LD_INT 1
2428: PPUSH
2429: LD_VAR 0 5
2433: PUSH
2434: LD_INT 1
2436: ARRAY
2437: PPUSH
2438: LD_INT 1
2440: PPUSH
2441: CALL_OW 260
2445: PPUSH
2446: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2450: LD_VAR 0 4
2454: PPUSH
2455: LD_VAR 0 6
2459: PPUSH
2460: LD_VAR 0 7
2464: PPUSH
2465: LD_INT 10
2467: PPUSH
2468: LD_INT 0
2470: PPUSH
2471: CALL_OW 50
// hc_importance := 0 ;
2475: LD_ADDR_OWVAR 32
2479: PUSH
2480: LD_INT 0
2482: ST_TO_ADDR
// hc_name :=  ;
2483: LD_ADDR_OWVAR 26
2487: PUSH
2488: LD_STRING 
2490: ST_TO_ADDR
// hc_gallery :=  ;
2491: LD_ADDR_OWVAR 33
2495: PUSH
2496: LD_STRING 
2498: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2499: LD_ADDR_VAR 0 9
2503: PUSH
2504: LD_EXP 10
2508: PUSH
2509: LD_INT 1
2511: MINUS
2512: PUSH
2513: LD_INT 4
2515: DIVREAL
2516: ST_TO_ADDR
// c := 1 ;
2517: LD_ADDR_VAR 0 8
2521: PUSH
2522: LD_INT 1
2524: ST_TO_ADDR
// for j = 2 to number_of_people do
2525: LD_ADDR_VAR 0 3
2529: PUSH
2530: DOUBLE
2531: LD_INT 2
2533: DEC
2534: ST_TO_ADDR
2535: LD_EXP 10
2539: PUSH
2540: FOR_TO
2541: IFFALSE 2752
// begin PrepareHuman ( false , c , skill_level ) ;
2543: LD_INT 0
2545: PPUSH
2546: LD_VAR 0 8
2550: PPUSH
2551: LD_EXP 11
2555: PPUSH
2556: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2560: LD_VAR 0 3
2564: PUSH
2565: LD_INT 1
2567: MINUS
2568: PUSH
2569: LD_VAR 0 9
2573: MOD
2574: PUSH
2575: LD_INT 0
2577: EQUAL
2578: IFFALSE 2594
// c := c + 1 ;
2580: LD_ADDR_VAR 0 8
2584: PUSH
2585: LD_VAR 0 8
2589: PUSH
2590: LD_INT 1
2592: PLUS
2593: ST_TO_ADDR
// un := CreateHuman ;
2594: LD_ADDR_VAR 0 4
2598: PUSH
2599: CALL_OW 44
2603: ST_TO_ADDR
// if to_copy < j then
2604: LD_VAR 0 5
2608: PUSH
2609: LD_VAR 0 3
2613: LESS
2614: IFFALSE 2643
// to_copy := Replace ( to_copy , j , un ) else
2616: LD_ADDR_VAR 0 5
2620: PUSH
2621: LD_VAR 0 5
2625: PPUSH
2626: LD_VAR 0 3
2630: PPUSH
2631: LD_VAR 0 4
2635: PPUSH
2636: CALL_OW 1
2640: ST_TO_ADDR
2641: GO 2725
// begin CopySkills ( to_copy [ j ] , un ) ;
2643: LD_VAR 0 5
2647: PUSH
2648: LD_VAR 0 3
2652: ARRAY
2653: PPUSH
2654: LD_VAR 0 4
2658: PPUSH
2659: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2663: LD_VAR 0 4
2667: PPUSH
2668: LD_INT 2
2670: PPUSH
2671: LD_VAR 0 5
2675: PUSH
2676: LD_VAR 0 3
2680: ARRAY
2681: PPUSH
2682: LD_INT 2
2684: PPUSH
2685: CALL_OW 260
2689: PPUSH
2690: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2694: LD_VAR 0 4
2698: PPUSH
2699: LD_INT 1
2701: PPUSH
2702: LD_VAR 0 5
2706: PUSH
2707: LD_VAR 0 3
2711: ARRAY
2712: PPUSH
2713: LD_INT 1
2715: PPUSH
2716: CALL_OW 260
2720: PPUSH
2721: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2725: LD_VAR 0 4
2729: PPUSH
2730: LD_VAR 0 6
2734: PPUSH
2735: LD_VAR 0 7
2739: PPUSH
2740: LD_INT 10
2742: PPUSH
2743: LD_INT 0
2745: PPUSH
2746: CALL_OW 50
// end ;
2750: GO 2540
2752: POP
2753: POP
// if handicap then
2754: LD_EXP 26
2758: IFFALSE 3029
// begin if handicap = 1 then
2760: LD_EXP 26
2764: PUSH
2765: LD_INT 1
2767: EQUAL
2768: IFFALSE 2847
// for j = 1 to 2 do
2770: LD_ADDR_VAR 0 3
2774: PUSH
2775: DOUBLE
2776: LD_INT 1
2778: DEC
2779: ST_TO_ADDR
2780: LD_INT 2
2782: PUSH
2783: FOR_TO
2784: IFFALSE 2845
// begin vc_chassis := ru_medium_tracked ;
2786: LD_ADDR_OWVAR 37
2790: PUSH
2791: LD_INT 22
2793: ST_TO_ADDR
// vc_engine := engine_combustion ;
2794: LD_ADDR_OWVAR 39
2798: PUSH
2799: LD_INT 1
2801: ST_TO_ADDR
// vc_control := control_manual ;
2802: LD_ADDR_OWVAR 38
2806: PUSH
2807: LD_INT 1
2809: ST_TO_ADDR
// vc_weapon := ru_gun ;
2810: LD_ADDR_OWVAR 40
2814: PUSH
2815: LD_INT 44
2817: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2818: CALL_OW 45
2822: PPUSH
2823: LD_VAR 0 6
2827: PPUSH
2828: LD_VAR 0 7
2832: PPUSH
2833: LD_INT 13
2835: PPUSH
2836: LD_INT 0
2838: PPUSH
2839: CALL_OW 50
// end ;
2843: GO 2783
2845: POP
2846: POP
// if handicap = 2 then
2847: LD_EXP 26
2851: PUSH
2852: LD_INT 2
2854: EQUAL
2855: IFFALSE 3029
// begin for j = 1 to 2 do
2857: LD_ADDR_VAR 0 3
2861: PUSH
2862: DOUBLE
2863: LD_INT 1
2865: DEC
2866: ST_TO_ADDR
2867: LD_INT 2
2869: PUSH
2870: FOR_TO
2871: IFFALSE 2945
// begin vc_chassis := ru_heavy_tracked ;
2873: LD_ADDR_OWVAR 37
2877: PUSH
2878: LD_INT 24
2880: ST_TO_ADDR
// vc_engine := engine_combustion ;
2881: LD_ADDR_OWVAR 39
2885: PUSH
2886: LD_INT 1
2888: ST_TO_ADDR
// vc_control := control_manual ;
2889: LD_ADDR_OWVAR 38
2893: PUSH
2894: LD_INT 1
2896: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_heavy_gun ] [ j ] ;
2897: LD_ADDR_OWVAR 40
2901: PUSH
2902: LD_INT 43
2904: PUSH
2905: LD_INT 46
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PUSH
2912: LD_VAR 0 3
2916: ARRAY
2917: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2918: CALL_OW 45
2922: PPUSH
2923: LD_VAR 0 6
2927: PPUSH
2928: LD_VAR 0 7
2932: PPUSH
2933: LD_INT 13
2935: PPUSH
2936: LD_INT 0
2938: PPUSH
2939: CALL_OW 50
// end ;
2943: GO 2870
2945: POP
2946: POP
// vc_chassis := ru_medium_tracked ;
2947: LD_ADDR_OWVAR 37
2951: PUSH
2952: LD_INT 22
2954: ST_TO_ADDR
// vc_engine := engine_siberite ;
2955: LD_ADDR_OWVAR 39
2959: PUSH
2960: LD_INT 3
2962: ST_TO_ADDR
// vc_control := control_computer ;
2963: LD_ADDR_OWVAR 38
2967: PUSH
2968: LD_INT 3
2970: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2971: LD_ADDR_OWVAR 40
2975: PUSH
2976: LD_INT 51
2978: ST_TO_ADDR
// un := CreateVehicle ;
2979: LD_ADDR_VAR 0 4
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2989: LD_VAR 0 4
2993: PPUSH
2994: LD_VAR 0 6
2998: PPUSH
2999: LD_VAR 0 7
3003: PPUSH
3004: LD_INT 13
3006: PPUSH
3007: LD_INT 0
3009: PPUSH
3010: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
3014: LD_VAR 0 4
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 100
3024: PPUSH
3025: CALL_OW 290
// end ; end ; end ; end ;
3029: GO 2120
3031: POP
3032: POP
// end ;
3033: LD_VAR 0 1
3037: RET
// export function AddApeman ( area ) ; begin
3038: LD_INT 0
3040: PPUSH
// uc_nation := 0 ;
3041: LD_ADDR_OWVAR 21
3045: PUSH
3046: LD_INT 0
3048: ST_TO_ADDR
// uc_side := 0 ;
3049: LD_ADDR_OWVAR 20
3053: PUSH
3054: LD_INT 0
3056: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
3057: LD_ADDR_OWVAR 35
3061: PUSH
3062: LD_INT 10
3064: NEG
3065: PPUSH
3066: LD_INT 15
3068: PPUSH
3069: CALL_OW 12
3073: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3074: LD_INT 0
3076: PPUSH
3077: LD_INT 12
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3087: LD_ADDR_OWVAR 29
3091: PUSH
3092: LD_INT 10
3094: PUSH
3095: LD_INT 12
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3102: CALL_OW 44
3106: PPUSH
3107: LD_VAR 0 1
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 49
// end ;
3119: LD_VAR 0 2
3123: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3124: LD_INT 0
3126: PPUSH
3127: PPUSH
3128: PPUSH
3129: PPUSH
// r := 100 ;
3130: LD_ADDR_VAR 0 5
3134: PUSH
3135: LD_INT 100
3137: ST_TO_ADDR
// x := 0 ;
3138: LD_ADDR_VAR 0 6
3142: PUSH
3143: LD_INT 0
3145: ST_TO_ADDR
// while ( x < n ) do
3146: LD_VAR 0 6
3150: PUSH
3151: LD_VAR 0 2
3155: LESS
3156: IFFALSE 3471
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3158: LD_ADDR_VAR 0 4
3162: PUSH
3163: DOUBLE
3164: LD_INT 1
3166: DEC
3167: ST_TO_ADDR
3168: LD_VAR 0 1
3172: PPUSH
3173: LD_INT 0
3175: PPUSH
3176: CALL_OW 517
3180: PUSH
3181: LD_INT 1
3183: ARRAY
3184: PUSH
3185: FOR_TO
3186: IFFALSE 3467
// begin if r > 50 then
3188: LD_VAR 0 5
3192: PUSH
3193: LD_INT 50
3195: GREATER
3196: IFFALSE 3443
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 0
3205: PPUSH
3206: CALL_OW 517
3210: PUSH
3211: LD_INT 1
3213: ARRAY
3214: PUSH
3215: LD_VAR 0 4
3219: ARRAY
3220: PPUSH
3221: LD_VAR 0 1
3225: PPUSH
3226: LD_INT 0
3228: PPUSH
3229: CALL_OW 517
3233: PUSH
3234: LD_INT 2
3236: ARRAY
3237: PUSH
3238: LD_VAR 0 4
3242: ARRAY
3243: PPUSH
3244: CALL_OW 458
3248: NOT
3249: IFFALSE 3427
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3251: LD_VAR 0 1
3255: PPUSH
3256: LD_INT 0
3258: PPUSH
3259: CALL_OW 517
3263: PUSH
3264: LD_INT 1
3266: ARRAY
3267: PUSH
3268: LD_VAR 0 4
3272: ARRAY
3273: PPUSH
3274: LD_VAR 0 1
3278: PPUSH
3279: LD_INT 0
3281: PPUSH
3282: CALL_OW 517
3286: PUSH
3287: LD_INT 2
3289: ARRAY
3290: PUSH
3291: LD_VAR 0 4
3295: ARRAY
3296: PPUSH
3297: LD_EXP 8
3301: PPUSH
3302: LD_INT 0
3304: PPUSH
3305: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3309: LD_ADDR_EXP 17
3313: PUSH
3314: LD_EXP 17
3318: PPUSH
3319: LD_EXP 17
3323: PUSH
3324: LD_INT 1
3326: PLUS
3327: PPUSH
3328: LD_VAR 0 1
3332: PPUSH
3333: LD_INT 0
3335: PPUSH
3336: CALL_OW 517
3340: PUSH
3341: LD_INT 1
3343: ARRAY
3344: PUSH
3345: LD_VAR 0 4
3349: ARRAY
3350: PPUSH
3351: CALL_OW 2
3355: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3356: LD_ADDR_EXP 17
3360: PUSH
3361: LD_EXP 17
3365: PPUSH
3366: LD_EXP 17
3370: PUSH
3371: LD_INT 1
3373: PLUS
3374: PPUSH
3375: LD_VAR 0 1
3379: PPUSH
3380: LD_INT 0
3382: PPUSH
3383: CALL_OW 517
3387: PUSH
3388: LD_INT 2
3390: ARRAY
3391: PUSH
3392: LD_VAR 0 4
3396: ARRAY
3397: PPUSH
3398: CALL_OW 2
3402: ST_TO_ADDR
// r := 0 ;
3403: LD_ADDR_VAR 0 5
3407: PUSH
3408: LD_INT 0
3410: ST_TO_ADDR
// x := x + 1 ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: LD_INT 1
3423: PLUS
3424: ST_TO_ADDR
// end else
3425: GO 3441
// r := r + 35 ;
3427: LD_ADDR_VAR 0 5
3431: PUSH
3432: LD_VAR 0 5
3436: PUSH
3437: LD_INT 35
3439: PLUS
3440: ST_TO_ADDR
// end else
3441: GO 3465
// r := r + rand ( 10 , 25 ) ;
3443: LD_ADDR_VAR 0 5
3447: PUSH
3448: LD_VAR 0 5
3452: PUSH
3453: LD_INT 10
3455: PPUSH
3456: LD_INT 25
3458: PPUSH
3459: CALL_OW 12
3463: PLUS
3464: ST_TO_ADDR
// end ;
3465: GO 3185
3467: POP
3468: POP
3469: GO 3146
// end ;
3471: LD_VAR 0 3
3475: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3476: LD_INT 0
3478: PPUSH
3479: PPUSH
3480: PPUSH
// if not GetControl ( veh ) = control_manual then
3481: LD_VAR 0 1
3485: PPUSH
3486: CALL_OW 263
3490: PUSH
3491: LD_INT 1
3493: EQUAL
3494: NOT
3495: IFFALSE 3507
// result := false else
3497: LD_ADDR_VAR 0 2
3501: PUSH
3502: LD_INT 0
3504: ST_TO_ADDR
3505: GO 3652
// if veh in FilterAllUnits ( [ f_empty ] ) then
3507: LD_VAR 0 1
3511: PUSH
3512: LD_INT 58
3514: PUSH
3515: EMPTY
3516: LIST
3517: PPUSH
3518: CALL_OW 69
3522: IN
3523: IFFALSE 3535
// result := false else
3525: LD_ADDR_VAR 0 2
3529: PUSH
3530: LD_INT 0
3532: ST_TO_ADDR
3533: GO 3652
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3535: LD_ADDR_VAR 0 4
3539: PUSH
3540: LD_INT 22
3542: PUSH
3543: LD_VAR 0 1
3547: PPUSH
3548: CALL_OW 255
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: PUSH
3557: LD_INT 55
3559: PUSH
3560: EMPTY
3561: LIST
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 69
3571: ST_TO_ADDR
// if not filter then
3572: LD_VAR 0 4
3576: NOT
3577: IFFALSE 3589
// result := false else
3579: LD_ADDR_VAR 0 2
3583: PUSH
3584: LD_INT 0
3586: ST_TO_ADDR
3587: GO 3652
// for i = 1 to filter do
3589: LD_ADDR_VAR 0 3
3593: PUSH
3594: DOUBLE
3595: LD_INT 1
3597: DEC
3598: ST_TO_ADDR
3599: LD_VAR 0 4
3603: PUSH
3604: FOR_TO
3605: IFFALSE 3650
// if IsDriver ( filter [ i ] ) = veh then
3607: LD_VAR 0 4
3611: PUSH
3612: LD_VAR 0 3
3616: ARRAY
3617: PPUSH
3618: CALL 3657 0 1
3622: PUSH
3623: LD_VAR 0 1
3627: EQUAL
3628: IFFALSE 3648
// begin result := filter [ i ] ;
3630: LD_ADDR_VAR 0 2
3634: PUSH
3635: LD_VAR 0 4
3639: PUSH
3640: LD_VAR 0 3
3644: ARRAY
3645: ST_TO_ADDR
// break ;
3646: GO 3650
// end ;
3648: GO 3604
3650: POP
3651: POP
// end ; end ;
3652: LD_VAR 0 2
3656: RET
// export function IsDriver ( unit ) ; begin
3657: LD_INT 0
3659: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3660: LD_VAR 0 1
3664: PUSH
3665: LD_INT 55
3667: PUSH
3668: EMPTY
3669: LIST
3670: PPUSH
3671: CALL_OW 69
3675: IN
3676: IFFALSE 3695
// result := IsInUnit ( unit ) else
3678: LD_ADDR_VAR 0 2
3682: PUSH
3683: LD_VAR 0 1
3687: PPUSH
3688: CALL_OW 310
3692: ST_TO_ADDR
3693: GO 3703
// result := false ;
3695: LD_ADDR_VAR 0 2
3699: PUSH
3700: LD_INT 0
3702: ST_TO_ADDR
// end ; end_of_file
3703: LD_VAR 0 2
3707: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3708: LD_INT 0
3710: PPUSH
3711: PPUSH
3712: PPUSH
3713: PPUSH
3714: PPUSH
3715: PPUSH
3716: PPUSH
3717: PPUSH
3718: PPUSH
// side := Bot_Side ;
3719: LD_ADDR_VAR 0 5
3723: PUSH
3724: LD_EXP 8
3728: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3729: LD_ADDR_VAR 0 9
3733: PUSH
3734: LD_INT 4
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: LD_INT 8
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: LIST
3747: PUSH
3748: LD_OWVAR 67
3752: ARRAY
3753: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3754: LD_ADDR_VAR 0 8
3758: PUSH
3759: LD_INT 27
3761: PUSH
3762: LD_INT 28
3764: PUSH
3765: LD_INT 25
3767: PUSH
3768: LD_INT 26
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3777: LD_ADDR_EXP 22
3781: PUSH
3782: LD_INT 4
3784: PUSH
3785: LD_INT 5
3787: PUSH
3788: LD_INT 6
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: PUSH
3796: LD_OWVAR 67
3800: ARRAY
3801: ST_TO_ADDR
// ct := [ ] ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: EMPTY
3808: ST_TO_ADDR
// patrols := [ ] ;
3809: LD_ADDR_EXP 19
3813: PUSH
3814: EMPTY
3815: ST_TO_ADDR
// attackers := [ ] ;
3816: LD_ADDR_EXP 20
3820: PUSH
3821: EMPTY
3822: ST_TO_ADDR
// attackers_tmp := [ ] ;
3823: LD_ADDR_EXP 27
3827: PUSH
3828: EMPTY
3829: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
3830: LD_ADDR_EXP 21
3834: PUSH
3835: LD_INT 14
3837: PUSH
3838: LD_INT 1
3840: PUSH
3841: LD_INT 2
3843: PUSH
3844: LD_INT 27
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 14
3855: PUSH
3856: LD_INT 1
3858: PUSH
3859: LD_INT 2
3861: PUSH
3862: LD_INT 25
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: LIST
3869: LIST
3870: PUSH
3871: LD_INT 14
3873: PUSH
3874: LD_INT 1
3876: PUSH
3877: LD_INT 2
3879: PUSH
3880: LD_INT 28
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: PUSH
3889: LD_INT 14
3891: PUSH
3892: LD_INT 1
3894: PUSH
3895: LD_INT 2
3897: PUSH
3898: LD_INT 29
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: LIST
3905: LIST
3906: PUSH
3907: LD_INT 14
3909: PUSH
3910: LD_INT 1
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: LD_INT 27
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: PUSH
3925: EMPTY
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3932: LD_INT 2
3934: PPUSH
3935: LD_STRING newkabul
3937: PPUSH
3938: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3942: LD_INT 2
3944: PPUSH
3945: CALL_OW 274
3949: PPUSH
3950: LD_INT 1
3952: PPUSH
3953: LD_INT 90000
3955: PPUSH
3956: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3960: LD_INT 2
3962: PPUSH
3963: CALL_OW 274
3967: PPUSH
3968: LD_INT 2
3970: PPUSH
3971: LD_INT 9000
3973: PPUSH
3974: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3978: LD_INT 2
3980: PPUSH
3981: CALL_OW 274
3985: PPUSH
3986: LD_INT 3
3988: PPUSH
3989: LD_INT 3000
3991: PPUSH
3992: CALL_OW 277
// if Difficulty > 1 then
3996: LD_OWVAR 67
4000: PUSH
4001: LD_INT 1
4003: GREATER
4004: IFFALSE 4021
// SetTech ( 5 , side , state_researched ) ;
4006: LD_INT 5
4008: PPUSH
4009: LD_VAR 0 5
4013: PPUSH
4014: LD_INT 2
4016: PPUSH
4017: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
4021: LD_INT 41
4023: PPUSH
4024: LD_VAR 0 5
4028: PPUSH
4029: LD_INT 2
4031: PPUSH
4032: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
4036: LD_INT 51
4038: PPUSH
4039: LD_VAR 0 5
4043: PPUSH
4044: LD_INT 2
4046: PPUSH
4047: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
4051: LD_INT 52
4053: PPUSH
4054: LD_VAR 0 5
4058: PPUSH
4059: LD_INT 2
4061: PPUSH
4062: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4066: LD_INT 53
4068: PPUSH
4069: LD_VAR 0 5
4073: PPUSH
4074: LD_INT 2
4076: PPUSH
4077: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4081: LD_INT 60
4083: PPUSH
4084: LD_VAR 0 5
4088: PPUSH
4089: LD_INT 2
4091: PPUSH
4092: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4096: LD_INT 61
4098: PPUSH
4099: LD_VAR 0 5
4103: PPUSH
4104: LD_INT 2
4106: PPUSH
4107: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4111: LD_INT 62
4113: PPUSH
4114: LD_VAR 0 5
4118: PPUSH
4119: LD_INT 2
4121: PPUSH
4122: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: LD_INT 22
4133: PUSH
4134: LD_VAR 0 5
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: PUSH
4143: LD_INT 21
4145: PUSH
4146: LD_INT 3
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PPUSH
4157: CALL_OW 69
4161: PUSH
4162: FOR_IN
4163: IFFALSE 4196
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4165: LD_VAR 0 2
4169: PPUSH
4170: LD_INT 6
4172: PUSH
4173: LD_INT 8
4175: PUSH
4176: LD_INT 10
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: LIST
4183: PUSH
4184: LD_OWVAR 67
4188: ARRAY
4189: PPUSH
4190: CALL_OW 241
4194: GO 4162
4196: POP
4197: POP
// if Difficulty > 1 then
4198: LD_OWVAR 67
4202: PUSH
4203: LD_INT 1
4205: GREATER
4206: IFFALSE 4215
// RemoveEnvironmentArea ( forest_road ) ;
4208: LD_INT 11
4210: PPUSH
4211: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 7 , 12 , 15 ] [ Difficulty ] ) ;
4215: LD_INT 4
4217: PPUSH
4218: LD_INT 7
4220: PUSH
4221: LD_INT 12
4223: PUSH
4224: LD_INT 15
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_OWVAR 67
4236: ARRAY
4237: PPUSH
4238: CALL 3124 0 2
// PlaceMines ( mine_east_zone , [ 5 , 10 , 13 ] [ Difficulty ] ) ;
4242: LD_INT 5
4244: PPUSH
4245: LD_INT 5
4247: PUSH
4248: LD_INT 10
4250: PUSH
4251: LD_INT 13
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: LIST
4258: PUSH
4259: LD_OWVAR 67
4263: ARRAY
4264: PPUSH
4265: CALL 3124 0 2
// PlaceMines ( mine_south_zone , [ 3 , 8 , 13 ] [ Difficulty ] ) ;
4269: LD_INT 7
4271: PPUSH
4272: LD_INT 3
4274: PUSH
4275: LD_INT 8
4277: PUSH
4278: LD_INT 13
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: LIST
4285: PUSH
4286: LD_OWVAR 67
4290: ARRAY
4291: PPUSH
4292: CALL 3124 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4296: LD_INT 6
4298: PPUSH
4299: LD_INT 0
4301: PUSH
4302: LD_INT 3
4304: PUSH
4305: LD_INT 5
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: LIST
4312: PUSH
4313: LD_OWVAR 67
4317: ARRAY
4318: PPUSH
4319: CALL 3124 0 2
// PlaceMines ( mine_road_zone , [ 2 , 4 , 6 ] [ Difficulty ] ) ;
4323: LD_INT 8
4325: PPUSH
4326: LD_INT 2
4328: PUSH
4329: LD_INT 4
4331: PUSH
4332: LD_INT 6
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_OWVAR 67
4344: ARRAY
4345: PPUSH
4346: CALL 3124 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4350: LD_INT 9
4352: PPUSH
4353: LD_INT 0
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: LD_INT 4
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: PPUSH
4373: CALL 3124 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4377: LD_INT 10
4379: PPUSH
4380: LD_INT 0
4382: PUSH
4383: LD_INT 1
4385: PUSH
4386: LD_INT 1
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_OWVAR 67
4398: ARRAY
4399: PPUSH
4400: CALL 3124 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4404: LD_INT 12
4406: PPUSH
4407: LD_INT 0
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: LD_INT 1
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: CALL 3124 0 2
// for i = 1 to [ 5 , 8 , 11 ] [ Difficulty ] do
4431: LD_ADDR_VAR 0 2
4435: PUSH
4436: DOUBLE
4437: LD_INT 1
4439: DEC
4440: ST_TO_ADDR
4441: LD_INT 5
4443: PUSH
4444: LD_INT 8
4446: PUSH
4447: LD_INT 11
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: LIST
4454: PUSH
4455: LD_OWVAR 67
4459: ARRAY
4460: PUSH
4461: FOR_TO
4462: IFFALSE 4637
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4464: LD_ADDR_VAR 0 4
4468: PUSH
4469: LD_INT 134
4471: PPUSH
4472: LD_INT 73
4474: PPUSH
4475: LD_INT 10
4477: PPUSH
4478: LD_INT 0
4480: PPUSH
4481: CALL_OW 17
4485: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4486: LD_VAR 0 4
4490: PUSH
4491: LD_INT 1
4493: ARRAY
4494: PPUSH
4495: LD_VAR 0 4
4499: PUSH
4500: LD_INT 2
4502: ARRAY
4503: PPUSH
4504: CALL_OW 428
4508: PUSH
4509: LD_INT 0
4511: EQUAL
4512: PUSH
4513: LD_VAR 0 4
4517: PUSH
4518: LD_INT 1
4520: ARRAY
4521: PPUSH
4522: LD_VAR 0 4
4526: PUSH
4527: LD_INT 2
4529: ARRAY
4530: PPUSH
4531: CALL_OW 458
4535: NOT
4536: AND
4537: IFFALSE 4635
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4539: LD_ADDR_EXP 17
4543: PUSH
4544: LD_EXP 17
4548: PPUSH
4549: LD_EXP 17
4553: PUSH
4554: LD_INT 1
4556: PLUS
4557: PPUSH
4558: LD_VAR 0 4
4562: PUSH
4563: LD_INT 1
4565: ARRAY
4566: PPUSH
4567: CALL_OW 2
4571: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4572: LD_ADDR_EXP 17
4576: PUSH
4577: LD_EXP 17
4581: PPUSH
4582: LD_EXP 17
4586: PUSH
4587: LD_INT 1
4589: PLUS
4590: PPUSH
4591: LD_VAR 0 4
4595: PUSH
4596: LD_INT 2
4598: ARRAY
4599: PPUSH
4600: CALL_OW 2
4604: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4605: LD_VAR 0 4
4609: PUSH
4610: LD_INT 1
4612: ARRAY
4613: PPUSH
4614: LD_VAR 0 4
4618: PUSH
4619: LD_INT 2
4621: ARRAY
4622: PPUSH
4623: LD_EXP 8
4627: PPUSH
4628: LD_INT 0
4630: PPUSH
4631: CALL_OW 454
// end ; end ;
4635: GO 4461
4637: POP
4638: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4639: LD_ADDR_VAR 0 2
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: LD_VAR 0 5
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: LD_INT 30
4658: PUSH
4659: LD_INT 32
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PPUSH
4670: CALL_OW 69
4674: PUSH
4675: FOR_IN
4676: IFFALSE 4708
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4678: LD_VAR 0 2
4682: PPUSH
4683: LD_VAR 0 8
4687: PUSH
4688: LD_INT 1
4690: PPUSH
4691: LD_VAR 0 8
4695: PPUSH
4696: CALL_OW 12
4700: ARRAY
4701: PPUSH
4702: CALL_OW 431
4706: GO 4675
4708: POP
4709: POP
// uc_side := side ;
4710: LD_ADDR_OWVAR 20
4714: PUSH
4715: LD_VAR 0 5
4719: ST_TO_ADDR
// uc_nation := 2 ;
4720: LD_ADDR_OWVAR 21
4724: PUSH
4725: LD_INT 2
4727: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: DOUBLE
4734: LD_INT 1
4736: DEC
4737: ST_TO_ADDR
4738: LD_INT 1
4740: PUSH
4741: LD_OWVAR 67
4745: PLUS
4746: PUSH
4747: FOR_TO
4748: IFFALSE 4838
// begin vc_chassis := ar_half_tracked ;
4750: LD_ADDR_OWVAR 37
4754: PUSH
4755: LD_INT 14
4757: ST_TO_ADDR
// vc_engine := engine_combustion ;
4758: LD_ADDR_OWVAR 39
4762: PUSH
4763: LD_INT 1
4765: ST_TO_ADDR
// vc_control := control_manual ;
4766: LD_ADDR_OWVAR 38
4770: PUSH
4771: LD_INT 1
4773: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4774: LD_ADDR_OWVAR 40
4778: PUSH
4779: LD_INT 31
4781: ST_TO_ADDR
// veh := CreateVehicle ;
4782: LD_ADDR_VAR 0 7
4786: PUSH
4787: CALL_OW 45
4791: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4792: LD_VAR 0 7
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 0
4802: PPUSH
4803: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4807: LD_INT 0
4809: PPUSH
4810: LD_INT 3
4812: PPUSH
4813: LD_VAR 0 9
4817: PPUSH
4818: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4822: CALL_OW 44
4826: PPUSH
4827: LD_VAR 0 7
4831: PPUSH
4832: CALL_OW 52
// end ;
4836: GO 4747
4838: POP
4839: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4840: LD_ADDR_VAR 0 2
4844: PUSH
4845: LD_INT 22
4847: PUSH
4848: LD_VAR 0 5
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PUSH
4857: LD_INT 30
4859: PUSH
4860: LD_INT 32
4862: PUSH
4863: EMPTY
4864: LIST
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL_OW 69
4875: PUSH
4876: FOR_IN
4877: IFFALSE 4910
// begin PrepareHuman ( false , 1 , skill ) ;
4879: LD_INT 0
4881: PPUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_VAR 0 9
4889: PPUSH
4890: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4894: CALL_OW 44
4898: PPUSH
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 52
// end ;
4908: GO 4876
4910: POP
4911: POP
// for i = 1 to 4 do
4912: LD_ADDR_VAR 0 2
4916: PUSH
4917: DOUBLE
4918: LD_INT 1
4920: DEC
4921: ST_TO_ADDR
4922: LD_INT 4
4924: PUSH
4925: FOR_TO
4926: IFFALSE 4957
// begin PrepareHuman ( false , 2 , skill ) ;
4928: LD_INT 0
4930: PPUSH
4931: LD_INT 2
4933: PPUSH
4934: LD_VAR 0 9
4938: PPUSH
4939: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4943: CALL_OW 44
4947: PPUSH
4948: LD_INT 2
4950: PPUSH
4951: CALL_OW 52
// end ;
4955: GO 4925
4957: POP
4958: POP
// for i = 1 to 6 do
4959: LD_ADDR_VAR 0 2
4963: PUSH
4964: DOUBLE
4965: LD_INT 1
4967: DEC
4968: ST_TO_ADDR
4969: LD_INT 6
4971: PUSH
4972: FOR_TO
4973: IFFALSE 5004
// begin PrepareHuman ( false , 3 , skill ) ;
4975: LD_INT 0
4977: PPUSH
4978: LD_INT 3
4980: PPUSH
4981: LD_VAR 0 9
4985: PPUSH
4986: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4990: CALL_OW 44
4994: PPUSH
4995: LD_INT 12
4997: PPUSH
4998: CALL_OW 52
// end ;
5002: GO 4972
5004: POP
5005: POP
// for i = 1 to 4 do
5006: LD_ADDR_VAR 0 2
5010: PUSH
5011: DOUBLE
5012: LD_INT 1
5014: DEC
5015: ST_TO_ADDR
5016: LD_INT 4
5018: PUSH
5019: FOR_TO
5020: IFFALSE 5077
// begin PrepareHuman ( false , 4 , skill ) ;
5022: LD_INT 0
5024: PPUSH
5025: LD_INT 4
5027: PPUSH
5028: LD_VAR 0 9
5032: PPUSH
5033: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
5037: CALL_OW 44
5041: PPUSH
5042: LD_INT 30
5044: PUSH
5045: LD_INT 8
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 69
5056: PUSH
5057: LD_VAR 0 2
5061: PUSH
5062: LD_INT 2
5064: MOD
5065: PUSH
5066: LD_INT 1
5068: PLUS
5069: ARRAY
5070: PPUSH
5071: CALL_OW 52
// end ;
5075: GO 5019
5077: POP
5078: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5079: LD_INT 0
5081: PPUSH
5082: LD_INT 8
5084: PPUSH
5085: LD_VAR 0 9
5089: PPUSH
5090: CALL_OW 380
// un := CreateHuman ;
5094: LD_ADDR_VAR 0 6
5098: PUSH
5099: CALL_OW 44
5103: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5104: LD_VAR 0 6
5108: PPUSH
5109: LD_INT 2
5111: PPUSH
5112: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5116: LD_VAR 0 6
5120: PPUSH
5121: LD_INT 31
5123: PPUSH
5124: CALL_OW 52
// for i = 1 to 4 do
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: DOUBLE
5134: LD_INT 1
5136: DEC
5137: ST_TO_ADDR
5138: LD_INT 4
5140: PUSH
5141: FOR_TO
5142: IFFALSE 5198
// begin uc_nation := 0 ;
5144: LD_ADDR_OWVAR 21
5148: PUSH
5149: LD_INT 0
5151: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_INT 16
5157: PPUSH
5158: LD_INT 1
5160: PPUSH
5161: CALL_OW 380
// un := CreateHuman ;
5165: LD_ADDR_VAR 0 6
5169: PUSH
5170: CALL_OW 44
5174: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5175: LD_VAR 0 6
5179: PPUSH
5180: LD_INT 106
5182: PPUSH
5183: LD_INT 46
5185: PPUSH
5186: LD_INT 8
5188: PPUSH
5189: LD_INT 0
5191: PPUSH
5192: CALL_OW 50
// end ;
5196: GO 5141
5198: POP
5199: POP
// for i = 1 to 2 * Difficulty do
5200: LD_ADDR_VAR 0 2
5204: PUSH
5205: DOUBLE
5206: LD_INT 1
5208: DEC
5209: ST_TO_ADDR
5210: LD_INT 2
5212: PUSH
5213: LD_OWVAR 67
5217: MUL
5218: PUSH
5219: FOR_TO
5220: IFFALSE 5260
// begin uc_nation := 0 ;
5222: LD_ADDR_OWVAR 21
5226: PUSH
5227: LD_INT 0
5229: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5230: LD_INT 0
5232: PPUSH
5233: LD_INT 15
5235: PPUSH
5236: LD_INT 3
5238: PPUSH
5239: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5243: CALL_OW 44
5247: PPUSH
5248: LD_INT 20
5250: PPUSH
5251: LD_INT 0
5253: PPUSH
5254: CALL_OW 49
// end ;
5258: GO 5219
5260: POP
5261: POP
// for i = 1 to 4 * Difficulty do
5262: LD_ADDR_VAR 0 2
5266: PUSH
5267: DOUBLE
5268: LD_INT 1
5270: DEC
5271: ST_TO_ADDR
5272: LD_INT 4
5274: PUSH
5275: LD_OWVAR 67
5279: MUL
5280: PUSH
5281: FOR_TO
5282: IFFALSE 5356
// begin uc_nation := 0 ;
5284: LD_ADDR_OWVAR 21
5288: PUSH
5289: LD_INT 0
5291: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5292: LD_INT 0
5294: PPUSH
5295: LD_INT 17
5297: PPUSH
5298: LD_INT 3
5300: PPUSH
5301: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5305: LD_ADDR_OWVAR 29
5309: PUSH
5310: LD_INT 11
5312: PUSH
5313: LD_INT 13
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: ST_TO_ADDR
// un := CreateHuman ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: CALL_OW 44
5329: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5330: LD_VAR 0 6
5334: PPUSH
5335: LD_INT 21
5337: PPUSH
5338: LD_INT 0
5340: PPUSH
5341: CALL_OW 49
// ComHold ( un ) ;
5345: LD_VAR 0 6
5349: PPUSH
5350: CALL_OW 140
// end ;
5354: GO 5281
5356: POP
5357: POP
// end ;
5358: LD_VAR 0 1
5362: RET
// every 12 12$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5363: LD_INT 22
5365: PUSH
5366: LD_EXP 8
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: LD_INT 30
5377: PUSH
5378: LD_INT 3
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PPUSH
5389: CALL_OW 69
5393: IFFALSE 5661
5395: GO 5397
5397: DISABLE
5398: LD_INT 0
5400: PPUSH
5401: PPUSH
5402: PPUSH
// begin enable ;
5403: ENABLE
// tmp := queue_codes [ rng ] ;
5404: LD_ADDR_VAR 0 2
5408: PUSH
5409: LD_EXP 23
5413: PUSH
5414: LD_EXP 24
5418: ARRAY
5419: ST_TO_ADDR
// p := 1 ;
5420: LD_ADDR_VAR 0 3
5424: PUSH
5425: LD_INT 1
5427: ST_TO_ADDR
// for i = 1 to veh_counter do
5428: LD_ADDR_VAR 0 1
5432: PUSH
5433: DOUBLE
5434: LD_INT 1
5436: DEC
5437: ST_TO_ADDR
5438: LD_EXP 22
5442: PUSH
5443: FOR_TO
5444: IFFALSE 5625
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5446: LD_INT 22
5448: PUSH
5449: LD_EXP 8
5453: PUSH
5454: EMPTY
5455: LIST
5456: LIST
5457: PUSH
5458: LD_INT 30
5460: PUSH
5461: LD_INT 3
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PPUSH
5472: CALL_OW 69
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_EXP 21
5485: PUSH
5486: LD_VAR 0 2
5490: PUSH
5491: LD_INT 10
5493: MOD
5494: ARRAY
5495: PUSH
5496: LD_INT 1
5498: ARRAY
5499: PPUSH
5500: LD_EXP 21
5504: PUSH
5505: LD_VAR 0 2
5509: PUSH
5510: LD_INT 10
5512: MOD
5513: ARRAY
5514: PUSH
5515: LD_INT 2
5517: ARRAY
5518: PPUSH
5519: LD_EXP 21
5523: PUSH
5524: LD_VAR 0 2
5528: PUSH
5529: LD_INT 10
5531: MOD
5532: ARRAY
5533: PUSH
5534: LD_INT 3
5536: ARRAY
5537: PPUSH
5538: LD_EXP 21
5542: PUSH
5543: LD_VAR 0 2
5547: PUSH
5548: LD_INT 10
5550: MOD
5551: ARRAY
5552: PUSH
5553: LD_INT 4
5555: ARRAY
5556: PPUSH
5557: CALL_OW 185
// tmp := tmp / 10 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_VAR 0 2
5570: PUSH
5571: LD_INT 10
5573: DIVREAL
5574: ST_TO_ADDR
// p := p + 1 ;
5575: LD_ADDR_VAR 0 3
5579: PUSH
5580: LD_VAR 0 3
5584: PUSH
5585: LD_INT 1
5587: PLUS
5588: ST_TO_ADDR
// if p > 5 then
5589: LD_VAR 0 3
5593: PUSH
5594: LD_INT 5
5596: GREATER
5597: IFFALSE 5623
// begin p := 1 ;
5599: LD_ADDR_VAR 0 3
5603: PUSH
5604: LD_INT 1
5606: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5607: LD_ADDR_VAR 0 2
5611: PUSH
5612: LD_EXP 23
5616: PUSH
5617: LD_EXP 24
5621: ARRAY
5622: ST_TO_ADDR
// end ; end ;
5623: GO 5443
5625: POP
5626: POP
// rng := rng + 1 ;
5627: LD_ADDR_EXP 24
5631: PUSH
5632: LD_EXP 24
5636: PUSH
5637: LD_INT 1
5639: PLUS
5640: ST_TO_ADDR
// if rng > queue_codes then
5641: LD_EXP 24
5645: PUSH
5646: LD_EXP 23
5650: GREATER
5651: IFFALSE 5661
// rng := 1 ;
5653: LD_ADDR_EXP 24
5657: PUSH
5658: LD_INT 1
5660: ST_TO_ADDR
// end ;
5661: PPOPN 3
5663: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5664: LD_INT 25
5666: PUSH
5667: LD_INT 17
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PPUSH
5674: CALL_OW 69
5678: IFFALSE 5781
5680: GO 5682
5682: DISABLE
5683: LD_INT 0
5685: PPUSH
5686: PPUSH
// begin enable ;
5687: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5688: LD_ADDR_VAR 0 1
5692: PUSH
5693: LD_INT 25
5695: PUSH
5696: LD_INT 17
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 69
5707: PUSH
5708: FOR_IN
5709: IFFALSE 5779
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5711: LD_ADDR_VAR 0 2
5715: PUSH
5716: LD_INT 81
5718: PUSH
5719: LD_EXP 8
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PPUSH
5728: CALL_OW 69
5732: PPUSH
5733: LD_VAR 0 1
5737: PPUSH
5738: CALL_OW 74
5742: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5743: LD_VAR 0 1
5747: PPUSH
5748: LD_VAR 0 2
5752: PPUSH
5753: CALL_OW 296
5757: PUSH
5758: LD_INT 15
5760: LESS
5761: IFFALSE 5777
// ComAttackUnit ( i , un ) ;
5763: LD_VAR 0 1
5767: PPUSH
5768: LD_VAR 0 2
5772: PPUSH
5773: CALL_OW 115
// end ;
5777: GO 5708
5779: POP
5780: POP
// end ;
5781: PPOPN 2
5783: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5784: LD_EXP 20
5788: IFFALSE 5855
5790: GO 5792
5792: DISABLE
5793: LD_INT 0
5795: PPUSH
// begin enable ;
5796: ENABLE
// for i in attackers do
5797: LD_ADDR_VAR 0 1
5801: PUSH
5802: LD_EXP 20
5806: PUSH
5807: FOR_IN
5808: IFFALSE 5853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
5810: LD_VAR 0 1
5814: PPUSH
5815: LD_INT 81
5817: PUSH
5818: LD_VAR 0 1
5822: PPUSH
5823: CALL_OW 255
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL_OW 69
5836: PPUSH
5837: LD_VAR 0 1
5841: PPUSH
5842: CALL_OW 74
5846: PPUSH
5847: CALL_OW 115
5851: GO 5807
5853: POP
5854: POP
// end ;
5855: PPOPN 1
5857: END
// every 0 0$01 trigger not attackers marked 17 do
5858: LD_EXP 20
5862: NOT
5863: IFFALSE 5872
5865: GO 5867
5867: DISABLE
// begin enable ;
5868: ENABLE
// disable ( 17 ) ;
5869: LD_INT 17
5871: DISABLE_MARKED
// end ;
5872: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5873: LD_EXP 22
5877: PUSH
5878: LD_EXP 20
5882: LESSEQUAL
5883: IFFALSE 5992
5885: GO 5887
5887: DISABLE
5888: LD_INT 0
5890: PPUSH
5891: PPUSH
// begin enable ;
5892: ENABLE
// enable ( 17 ) ;
5893: LD_INT 17
5895: ENABLE_MARKED
// max := 1 ;
5896: LD_ADDR_VAR 0 1
5900: PUSH
5901: LD_INT 1
5903: ST_TO_ADDR
// for i = 1 to 8 do
5904: LD_ADDR_VAR 0 2
5908: PUSH
5909: DOUBLE
5910: LD_INT 1
5912: DEC
5913: ST_TO_ADDR
5914: LD_INT 8
5916: PUSH
5917: FOR_TO
5918: IFFALSE 5990
// if i <> bot_side then
5920: LD_VAR 0 2
5924: PUSH
5925: LD_EXP 8
5929: NONEQUAL
5930: IFFALSE 5988
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5932: LD_VAR 0 1
5936: PUSH
5937: LD_INT 22
5939: PUSH
5940: LD_VAR 0 2
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: PPUSH
5949: CALL_OW 69
5953: LESS
5954: IFFALSE 5988
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5956: LD_ADDR_VAR 0 1
5960: PUSH
5961: LD_INT 22
5963: PUSH
5964: LD_VAR 0 2
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PPUSH
5973: CALL_OW 69
5977: ST_TO_ADDR
// target := i ;
5978: LD_ADDR_EXP 25
5982: PUSH
5983: LD_VAR 0 2
5987: ST_TO_ADDR
// end ; end ;
5988: GO 5917
5990: POP
5991: POP
// end ;
5992: PPOPN 2
5994: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5995: LD_EXP 9
5999: PUSH
6000: LD_OWVAR 1
6004: PUSH
6005: LD_INT 63000
6007: GREATEREQUAL
6008: AND
6009: IFFALSE 6028
6011: GO 6013
6013: DISABLE
// begin veh_counter := veh_counter + 1 ;
6014: LD_ADDR_EXP 22
6018: PUSH
6019: LD_EXP 22
6023: PUSH
6024: LD_INT 1
6026: PLUS
6027: ST_TO_ADDR
// end ;
6028: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
6029: LD_EXP 9
6033: PUSH
6034: LD_OWVAR 1
6038: PUSH
6039: LD_INT 105000
6041: GREATEREQUAL
6042: AND
6043: IFFALSE 6062
6045: GO 6047
6047: DISABLE
// begin veh_counter := veh_counter + 2 ;
6048: LD_ADDR_EXP 22
6052: PUSH
6053: LD_EXP 22
6057: PUSH
6058: LD_INT 2
6060: PLUS
6061: ST_TO_ADDR
// end ;
6062: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
6063: LD_EXP 9
6067: PUSH
6068: LD_OWVAR 1
6072: PUSH
6073: LD_INT 168000
6075: GREATEREQUAL
6076: AND
6077: IFFALSE 6096
6079: GO 6081
6081: DISABLE
// begin veh_counter := veh_counter + 3 ;
6082: LD_ADDR_EXP 22
6086: PUSH
6087: LD_EXP 22
6091: PUSH
6092: LD_INT 3
6094: PLUS
6095: ST_TO_ADDR
// end ;
6096: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
6097: LD_INT 22
6099: PUSH
6100: LD_EXP 8
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 33
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 69
6127: IFFALSE 6343
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
6135: PPUSH
6136: PPUSH
6137: PPUSH
6138: PPUSH
6139: PPUSH
6140: PPUSH
// begin enable ;
6141: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6142: LD_ADDR_VAR 0 4
6146: PUSH
6147: LD_INT 22
6149: PUSH
6150: LD_EXP 8
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PUSH
6159: LD_INT 33
6161: PUSH
6162: LD_INT 2
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 3
6171: PUSH
6172: LD_INT 61
6174: PUSH
6175: EMPTY
6176: LIST
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: PPUSH
6187: CALL_OW 69
6191: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6192: LD_ADDR_VAR 0 3
6196: PUSH
6197: LD_INT 22
6199: PUSH
6200: LD_EXP 8
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 34
6211: PUSH
6212: LD_INT 31
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PPUSH
6223: CALL_OW 69
6227: ST_TO_ADDR
// best := 10 ;
6228: LD_ADDR_VAR 0 5
6232: PUSH
6233: LD_INT 10
6235: ST_TO_ADDR
// best_mechanic := - 1 ;
6236: LD_ADDR_VAR 0 6
6240: PUSH
6241: LD_INT 1
6243: NEG
6244: ST_TO_ADDR
// if vehs then
6245: LD_VAR 0 4
6249: IFFALSE 6343
// begin for j in cts do
6251: LD_ADDR_VAR 0 2
6255: PUSH
6256: LD_VAR 0 3
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6323
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6264: LD_ADDR_VAR 0 7
6268: PUSH
6269: LD_VAR 0 2
6273: PPUSH
6274: CALL 3476 0 1
6278: PPUSH
6279: CALL_OW 432
6283: ST_TO_ADDR
// if p < best then
6284: LD_VAR 0 7
6288: PUSH
6289: LD_VAR 0 5
6293: LESS
6294: IFFALSE 6321
// begin best := p ;
6296: LD_ADDR_VAR 0 5
6300: PUSH
6301: LD_VAR 0 7
6305: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6306: LD_ADDR_VAR 0 6
6310: PUSH
6311: LD_VAR 0 2
6315: PPUSH
6316: CALL 3476 0 1
6320: ST_TO_ADDR
// end ; end ;
6321: GO 6261
6323: POP
6324: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6325: LD_VAR 0 4
6329: PUSH
6330: LD_INT 1
6332: ARRAY
6333: PPUSH
6334: LD_VAR 0 6
6338: PPUSH
6339: CALL_OW 135
// end ; end ;
6343: PPOPN 7
6345: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6346: GO 6348
6348: DISABLE
6349: LD_INT 0
6351: PPUSH
6352: PPUSH
6353: PPUSH
6354: PPUSH
6355: PPUSH
6356: PPUSH
6357: PPUSH
// begin enable ;
6358: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6359: LD_ADDR_VAR 0 6
6363: PUSH
6364: LD_INT 22
6366: PUSH
6367: LD_EXP 8
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 21
6378: PUSH
6379: LD_INT 3
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 3
6388: PUSH
6389: LD_INT 24
6391: PUSH
6392: LD_INT 1000
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: PPUSH
6408: CALL_OW 69
6412: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6413: LD_ADDR_VAR 0 3
6417: PUSH
6418: LD_INT 22
6420: PUSH
6421: LD_EXP 8
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: LD_INT 25
6435: PUSH
6436: LD_INT 1
6438: PUSH
6439: EMPTY
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 25
6445: PUSH
6446: LD_INT 2
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: PUSH
6453: LD_INT 25
6455: PUSH
6456: LD_INT 3
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 3
6471: PUSH
6472: LD_INT 24
6474: PUSH
6475: LD_INT 750
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: LIST
6490: PPUSH
6491: CALL_OW 69
6495: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6496: LD_ADDR_VAR 0 4
6500: PUSH
6501: LD_INT 22
6503: PUSH
6504: LD_EXP 8
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 25
6515: PUSH
6516: LD_INT 4
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: PPUSH
6527: CALL_OW 69
6531: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6532: LD_ADDR_VAR 0 5
6536: PUSH
6537: LD_INT 22
6539: PUSH
6540: LD_EXP 8
6544: PUSH
6545: EMPTY
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 25
6551: PUSH
6552: LD_INT 2
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: PPUSH
6563: CALL_OW 69
6567: ST_TO_ADDR
// if not h and not b then
6568: LD_VAR 0 3
6572: NOT
6573: PUSH
6574: LD_VAR 0 6
6578: NOT
6579: AND
6580: IFFALSE 6864
// begin if sci then
6582: LD_VAR 0 4
6586: IFFALSE 6723
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6588: LD_VAR 0 4
6592: PPUSH
6593: LD_INT 3
6595: PUSH
6596: LD_INT 54
6598: PUSH
6599: EMPTY
6600: LIST
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PPUSH
6606: CALL_OW 72
6610: PUSH
6611: LD_INT 22
6613: PUSH
6614: LD_EXP 8
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: PUSH
6623: LD_INT 30
6625: PUSH
6626: LD_INT 8
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PUSH
6633: EMPTY
6634: LIST
6635: LIST
6636: PPUSH
6637: CALL_OW 69
6641: AND
6642: IFFALSE 6723
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6644: LD_ADDR_VAR 0 2
6648: PUSH
6649: LD_VAR 0 4
6653: PPUSH
6654: LD_INT 3
6656: PUSH
6657: LD_INT 54
6659: PUSH
6660: EMPTY
6661: LIST
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 72
6671: PUSH
6672: FOR_IN
6673: IFFALSE 6721
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6675: LD_VAR 0 2
6679: PPUSH
6680: LD_INT 22
6682: PUSH
6683: LD_EXP 8
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: LD_INT 30
6694: PUSH
6695: LD_INT 8
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: PPUSH
6706: CALL_OW 69
6710: PUSH
6711: LD_INT 1
6713: ARRAY
6714: PPUSH
6715: CALL_OW 120
6719: GO 6672
6721: POP
6722: POP
// if eng then
6723: LD_VAR 0 5
6727: IFFALSE 6864
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6729: LD_VAR 0 5
6733: PPUSH
6734: LD_INT 3
6736: PUSH
6737: LD_INT 54
6739: PUSH
6740: EMPTY
6741: LIST
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: PPUSH
6747: CALL_OW 72
6751: PUSH
6752: LD_INT 22
6754: PUSH
6755: LD_EXP 8
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 30
6766: PUSH
6767: LD_INT 1
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PUSH
6774: EMPTY
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 69
6782: AND
6783: IFFALSE 6864
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 5
6794: PPUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 54
6800: PUSH
6801: EMPTY
6802: LIST
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PPUSH
6808: CALL_OW 72
6812: PUSH
6813: FOR_IN
6814: IFFALSE 6862
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6816: LD_VAR 0 2
6820: PPUSH
6821: LD_INT 22
6823: PUSH
6824: LD_EXP 8
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: PUSH
6833: LD_INT 30
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL_OW 69
6851: PUSH
6852: LD_INT 1
6854: ARRAY
6855: PPUSH
6856: CALL_OW 120
6860: GO 6813
6862: POP
6863: POP
// end ; p := 1 ;
6864: LD_ADDR_VAR 0 7
6868: PUSH
6869: LD_INT 1
6871: ST_TO_ADDR
// if b and eng then
6872: LD_VAR 0 6
6876: PUSH
6877: LD_VAR 0 5
6881: AND
6882: IFFALSE 7016
// for j in eng do
6884: LD_ADDR_VAR 0 2
6888: PUSH
6889: LD_VAR 0 5
6893: PUSH
6894: FOR_IN
6895: IFFALSE 7014
// begin if IsInUnit ( j ) then
6897: LD_VAR 0 2
6901: PPUSH
6902: CALL_OW 310
6906: IFFALSE 6919
// ComExitBuilding ( j ) else
6908: LD_VAR 0 2
6912: PPUSH
6913: CALL_OW 122
6917: GO 7012
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6919: LD_VAR 0 2
6923: PPUSH
6924: CALL_OW 314
6928: NOT
6929: PUSH
6930: LD_VAR 0 2
6934: PPUSH
6935: CALL_OW 256
6939: PUSH
6940: LD_INT 750
6942: GREATER
6943: AND
6944: IFFALSE 7012
// begin if b > p then
6946: LD_VAR 0 6
6950: PUSH
6951: LD_VAR 0 7
6955: GREATER
6956: IFFALSE 6994
// begin ComRepairBuilding ( j , b [ p ] ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_VAR 0 6
6967: PUSH
6968: LD_VAR 0 7
6972: ARRAY
6973: PPUSH
6974: CALL_OW 130
// p := p + 1 ;
6978: LD_ADDR_VAR 0 7
6982: PUSH
6983: LD_VAR 0 7
6987: PUSH
6988: LD_INT 1
6990: PLUS
6991: ST_TO_ADDR
// end else
6992: GO 7012
// ComRepairBuilding ( j , b [ 1 ] ) ;
6994: LD_VAR 0 2
6998: PPUSH
6999: LD_VAR 0 6
7003: PUSH
7004: LD_INT 1
7006: ARRAY
7007: PPUSH
7008: CALL_OW 130
// end ; end ;
7012: GO 6894
7014: POP
7015: POP
// if h and sci then
7016: LD_VAR 0 3
7020: PUSH
7021: LD_VAR 0 4
7025: AND
7026: IFFALSE 7165
// for i in h do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: LD_VAR 0 3
7037: PUSH
7038: FOR_IN
7039: IFFALSE 7163
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
7041: LD_VAR 0 1
7045: PPUSH
7046: LD_INT 108
7048: PPUSH
7049: LD_INT 42
7051: PPUSH
7052: CALL_OW 297
7056: PUSH
7057: LD_INT 10
7059: GREATER
7060: IFFALSE 7079
// ComMoveXY ( i , 108 , 42 ) else
7062: LD_VAR 0 1
7066: PPUSH
7067: LD_INT 108
7069: PPUSH
7070: LD_INT 42
7072: PPUSH
7073: CALL_OW 111
7077: GO 7161
// begin for j in sci do
7079: LD_ADDR_VAR 0 2
7083: PUSH
7084: LD_VAR 0 4
7088: PUSH
7089: FOR_IN
7090: IFFALSE 7159
// begin if GetTag ( j ) > 0 then
7092: LD_VAR 0 2
7096: PPUSH
7097: CALL_OW 110
7101: PUSH
7102: LD_INT 0
7104: GREATER
7105: IFFALSE 7109
// continue ;
7107: GO 7089
// if IsInUnit ( j ) then
7109: LD_VAR 0 2
7113: PPUSH
7114: CALL_OW 310
7118: IFFALSE 7131
// ComExitBuilding ( j ) else
7120: LD_VAR 0 2
7124: PPUSH
7125: CALL_OW 122
7129: GO 7157
// if not HasTask ( j ) then
7131: LD_VAR 0 2
7135: PPUSH
7136: CALL_OW 314
7140: NOT
7141: IFFALSE 7157
// ComHeal ( j , h ) ;
7143: LD_VAR 0 2
7147: PPUSH
7148: LD_VAR 0 3
7152: PPUSH
7153: CALL_OW 128
// end ;
7157: GO 7089
7159: POP
7160: POP
// end ;
7161: GO 7038
7163: POP
7164: POP
// end ;
7165: PPOPN 7
7167: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7168: LD_INT 155
7170: PPUSH
7171: LD_INT 88
7173: PPUSH
7174: CALL_OW 428
7178: PUSH
7179: LD_INT 155
7181: PPUSH
7182: LD_INT 88
7184: PPUSH
7185: CALL_OW 428
7189: PUSH
7190: LD_INT 30
7192: EQUAL
7193: PPUSH
7194: CALL_OW 266
7198: AND
7199: IFFALSE 7448
7201: GO 7203
7203: DISABLE
7204: LD_INT 0
7206: PPUSH
7207: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7208: LD_ADDR_VAR 0 2
7212: PUSH
7213: LD_INT 155
7215: PPUSH
7216: LD_INT 88
7218: PPUSH
7219: CALL_OW 428
7223: PPUSH
7224: CALL_OW 255
7228: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7229: LD_INT 11550
7231: PUSH
7232: LD_INT 13755
7234: PUSH
7235: LD_INT 13335
7237: PUSH
7238: LD_INT 18340
7240: PUSH
7241: LD_INT 19985
7243: PUSH
7244: LD_INT 9555
7246: PUSH
7247: LD_INT 18935
7249: PUSH
7250: LD_INT 10535
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: LIST
7262: PUSH
7263: LD_VAR 0 2
7267: ARRAY
7268: PPUSH
7269: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7273: LD_INT 22
7275: PUSH
7276: LD_EXP 8
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: LD_INT 25
7287: PUSH
7288: LD_INT 4
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PPUSH
7299: CALL_OW 69
7303: PUSH
7304: LD_INT 0
7306: EQUAL
7307: IFFALSE 7311
// exit ;
7309: GO 7448
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7311: LD_ADDR_VAR 0 1
7315: PUSH
7316: LD_INT 22
7318: PUSH
7319: LD_EXP 8
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 25
7330: PUSH
7331: LD_INT 4
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: PUSH
7338: EMPTY
7339: LIST
7340: LIST
7341: PPUSH
7342: CALL_OW 69
7346: PUSH
7347: LD_INT 1
7349: ARRAY
7350: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7351: LD_VAR 0 1
7355: PPUSH
7356: LD_INT 1
7358: PPUSH
7359: CALL_OW 109
// ComExitBuilding ( sci ) ;
7363: LD_VAR 0 1
7367: PPUSH
7368: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7372: LD_VAR 0 1
7376: PPUSH
7377: LD_INT 126
7379: PPUSH
7380: LD_INT 59
7382: PPUSH
7383: CALL_OW 171
// if p mod 2 = 0 then
7387: LD_VAR 0 2
7391: PUSH
7392: LD_INT 2
7394: MOD
7395: PUSH
7396: LD_INT 0
7398: EQUAL
7399: IFFALSE 7418
// AddComMoveXY ( sci , 148 , 66 ) else
7401: LD_VAR 0 1
7405: PPUSH
7406: LD_INT 148
7408: PPUSH
7409: LD_INT 66
7411: PPUSH
7412: CALL_OW 171
7416: GO 7433
// AddComMoveXY ( sci , 135 , 84 ) ;
7418: LD_VAR 0 1
7422: PPUSH
7423: LD_INT 135
7425: PPUSH
7426: LD_INT 84
7428: PPUSH
7429: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7433: LD_VAR 0 1
7437: PPUSH
7438: LD_INT 155
7440: PPUSH
7441: LD_INT 88
7443: PPUSH
7444: CALL_OW 218
// end ;
7448: PPOPN 2
7450: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7451: LD_INT 33
7453: PPUSH
7454: LD_INT 10
7456: PPUSH
7457: CALL_OW 428
7461: PUSH
7462: LD_INT 33
7464: PPUSH
7465: LD_INT 10
7467: PPUSH
7468: CALL_OW 428
7472: PUSH
7473: LD_INT 30
7475: EQUAL
7476: PPUSH
7477: CALL_OW 266
7481: AND
7482: IFFALSE 7733
7484: GO 7486
7486: DISABLE
7487: LD_INT 0
7489: PPUSH
7490: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7491: LD_ADDR_VAR 0 2
7495: PUSH
7496: LD_INT 33
7498: PPUSH
7499: LD_INT 10
7501: PPUSH
7502: CALL_OW 428
7506: PPUSH
7507: CALL_OW 255
7511: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7512: LD_INT 9450
7514: PUSH
7515: LD_INT 11655
7517: PUSH
7518: LD_INT 7035
7520: PUSH
7521: LD_INT 9940
7523: PUSH
7524: LD_INT 7385
7526: PUSH
7527: LD_INT 11655
7529: PUSH
7530: LD_INT 6335
7532: PUSH
7533: LD_INT 16835
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: PUSH
7546: LD_VAR 0 2
7550: ARRAY
7551: PPUSH
7552: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7556: LD_INT 22
7558: PUSH
7559: LD_EXP 8
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PUSH
7568: LD_INT 25
7570: PUSH
7571: LD_INT 4
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PPUSH
7582: CALL_OW 69
7586: PUSH
7587: LD_INT 0
7589: EQUAL
7590: IFFALSE 7594
// exit ;
7592: GO 7733
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7594: LD_ADDR_VAR 0 1
7598: PUSH
7599: LD_INT 22
7601: PUSH
7602: LD_EXP 8
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 25
7613: PUSH
7614: LD_INT 4
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PPUSH
7625: CALL_OW 69
7629: PUSH
7630: LD_VAR 0 1
7634: ARRAY
7635: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7636: LD_VAR 0 1
7640: PPUSH
7641: LD_INT 1
7643: PPUSH
7644: CALL_OW 109
// ComExitBuilding ( sci ) ;
7648: LD_VAR 0 1
7652: PPUSH
7653: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7657: LD_VAR 0 1
7661: PPUSH
7662: LD_INT 67
7664: PPUSH
7665: LD_INT 13
7667: PPUSH
7668: CALL_OW 171
// if p mod 2 = 0 then
7672: LD_VAR 0 2
7676: PUSH
7677: LD_INT 2
7679: MOD
7680: PUSH
7681: LD_INT 0
7683: EQUAL
7684: IFFALSE 7703
// AddComMoveXY ( sci , 37 , 3 ) else
7686: LD_VAR 0 1
7690: PPUSH
7691: LD_INT 37
7693: PPUSH
7694: LD_INT 3
7696: PPUSH
7697: CALL_OW 171
7701: GO 7718
// AddComMoveXY ( sci , 45 , 20 ) ;
7703: LD_VAR 0 1
7707: PPUSH
7708: LD_INT 45
7710: PPUSH
7711: LD_INT 20
7713: PPUSH
7714: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7718: LD_VAR 0 1
7722: PPUSH
7723: LD_INT 33
7725: PPUSH
7726: LD_INT 10
7728: PPUSH
7729: CALL_OW 218
// end ;
7733: PPOPN 2
7735: END
// every 0 0$01 trigger mines_list do var i , p ;
7736: LD_EXP 17
7740: IFFALSE 7966
7742: GO 7744
7744: DISABLE
7745: LD_INT 0
7747: PPUSH
7748: PPUSH
// begin enable ;
7749: ENABLE
// p := 1 ;
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: LD_INT 1
7757: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7758: LD_ADDR_VAR 0 1
7762: PUSH
7763: DOUBLE
7764: LD_INT 1
7766: DEC
7767: ST_TO_ADDR
7768: LD_EXP 17
7772: PUSH
7773: LD_INT 2
7775: DIVREAL
7776: PUSH
7777: FOR_TO
7778: IFFALSE 7964
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7780: LD_EXP 17
7784: PUSH
7785: LD_VAR 0 2
7789: ARRAY
7790: PPUSH
7791: LD_EXP 17
7795: PUSH
7796: LD_VAR 0 2
7800: PUSH
7801: LD_INT 1
7803: PLUS
7804: ARRAY
7805: PPUSH
7806: CALL_OW 428
7810: PUSH
7811: LD_INT 0
7813: GREATER
7814: IFFALSE 7948
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7816: LD_EXP 17
7820: PUSH
7821: LD_VAR 0 2
7825: ARRAY
7826: PPUSH
7827: LD_EXP 17
7831: PUSH
7832: LD_VAR 0 2
7836: PUSH
7837: LD_INT 1
7839: PLUS
7840: ARRAY
7841: PPUSH
7842: CALL_OW 428
7846: PPUSH
7847: CALL_OW 255
7851: PUSH
7852: LD_EXP 8
7856: NONEQUAL
7857: IFFALSE 7948
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7859: LD_EXP 17
7863: PUSH
7864: LD_VAR 0 2
7868: ARRAY
7869: PPUSH
7870: LD_EXP 17
7874: PUSH
7875: LD_VAR 0 2
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ARRAY
7884: PPUSH
7885: LD_EXP 8
7889: PPUSH
7890: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7894: LD_ADDR_EXP 17
7898: PUSH
7899: LD_EXP 17
7903: PPUSH
7904: LD_VAR 0 2
7908: PPUSH
7909: CALL_OW 3
7913: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7914: LD_ADDR_EXP 17
7918: PUSH
7919: LD_EXP 17
7923: PPUSH
7924: LD_VAR 0 2
7928: PPUSH
7929: CALL_OW 3
7933: ST_TO_ADDR
// p := p - 2 ;
7934: LD_ADDR_VAR 0 2
7938: PUSH
7939: LD_VAR 0 2
7943: PUSH
7944: LD_INT 2
7946: MINUS
7947: ST_TO_ADDR
// end ; p := p + 2 ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_VAR 0 2
7957: PUSH
7958: LD_INT 2
7960: PLUS
7961: ST_TO_ADDR
// end ;
7962: GO 7777
7964: POP
7965: POP
// end ;
7966: PPOPN 2
7968: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7969: GO 7971
7971: DISABLE
7972: LD_INT 0
7974: PPUSH
7975: PPUSH
7976: PPUSH
7977: PPUSH
7978: PPUSH
// begin enable ;
7979: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7980: LD_ADDR_VAR 0 4
7984: PUSH
7985: LD_INT 50
7987: PUSH
7988: EMPTY
7989: LIST
7990: PUSH
7991: LD_INT 22
7993: PUSH
7994: LD_EXP 8
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 25
8005: PUSH
8006: LD_INT 16
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: LIST
8017: PPUSH
8018: CALL_OW 69
8022: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8023: LD_ADDR_VAR 0 5
8027: PUSH
8028: LD_INT 22
8030: PUSH
8031: LD_EXP 8
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 2
8042: PUSH
8043: LD_INT 30
8045: PUSH
8046: LD_INT 0
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PUSH
8053: LD_INT 30
8055: PUSH
8056: LD_INT 1
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PUSH
8063: EMPTY
8064: LIST
8065: LIST
8066: LIST
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PPUSH
8072: CALL_OW 69
8076: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
8077: LD_ADDR_VAR 0 3
8081: PUSH
8082: LD_INT 13
8084: PPUSH
8085: CALL_OW 435
8089: ST_TO_ADDR
// if filter and skr then
8090: LD_VAR 0 4
8094: PUSH
8095: LD_VAR 0 3
8099: AND
8100: IFFALSE 8157
// for i = 1 to filter do
8102: LD_ADDR_VAR 0 1
8106: PUSH
8107: DOUBLE
8108: LD_INT 1
8110: DEC
8111: ST_TO_ADDR
8112: LD_VAR 0 4
8116: PUSH
8117: FOR_TO
8118: IFFALSE 8155
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8120: LD_VAR 0 4
8124: PUSH
8125: LD_VAR 0 1
8129: ARRAY
8130: PPUSH
8131: LD_VAR 0 3
8135: PUSH
8136: LD_INT 1
8138: ARRAY
8139: PPUSH
8140: LD_VAR 0 3
8144: PUSH
8145: LD_INT 2
8147: ARRAY
8148: PPUSH
8149: CALL_OW 117
8153: GO 8117
8155: POP
8156: POP
// end ; end_of_file
8157: PPOPN 5
8159: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8160: LD_INT 0
8162: PPUSH
8163: PPUSH
8164: PPUSH
8165: PPUSH
// begin if un in attackers then
8166: LD_VAR 0 1
8170: PUSH
8171: LD_EXP 20
8175: IN
8176: IFFALSE 8194
// attackers := attackers diff un ;
8178: LD_ADDR_EXP 20
8182: PUSH
8183: LD_EXP 20
8187: PUSH
8188: LD_VAR 0 1
8192: DIFF
8193: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 255
8203: PUSH
8204: LD_EXP 8
8208: NONEQUAL
8209: PUSH
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL_OW 255
8219: PUSH
8220: LD_INT 0
8222: GREATER
8223: AND
8224: PUSH
8225: LD_VAR 0 1
8229: PUSH
8230: LD_INT 21
8232: PUSH
8233: LD_INT 1
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PPUSH
8240: CALL_OW 69
8244: IN
8245: AND
8246: IFFALSE 8430
// begin if respawning_time_min > 0 0$00 then
8248: LD_EXP 13
8252: PUSH
8253: LD_INT 0
8255: GREATER
8256: IFFALSE 8430
// begin s := GetSide ( un ) ;
8258: LD_ADDR_VAR 0 4
8262: PUSH
8263: LD_VAR 0 1
8267: PPUSH
8268: CALL_OW 255
8272: ST_TO_ADDR
// n := GetNation ( un ) ;
8273: LD_ADDR_VAR 0 5
8277: PUSH
8278: LD_VAR 0 1
8282: PPUSH
8283: CALL_OW 248
8287: ST_TO_ADDR
// cl := GetClass ( un ) ;
8288: LD_ADDR_VAR 0 3
8292: PUSH
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 257
8302: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8303: LD_EXP 13
8307: PPUSH
8308: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) * cl ) ;
8312: LD_EXP 14
8316: PUSH
8317: LD_INT 350
8319: PUSH
8320: LD_OWVAR 1
8324: MUL
8325: PUSH
8326: LD_INT 10
8328: MOD
8329: PUSH
8330: LD_INT 1
8332: PLUS
8333: PUSH
8334: LD_VAR 0 3
8338: MUL
8339: MINUS
8340: PPUSH
8341: CALL_OW 67
// uc_side := s ;
8345: LD_ADDR_OWVAR 20
8349: PUSH
8350: LD_VAR 0 4
8354: ST_TO_ADDR
// uc_nation := n ;
8355: LD_ADDR_OWVAR 21
8359: PUSH
8360: LD_VAR 0 5
8364: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8365: LD_INT 0
8367: PPUSH
8368: LD_VAR 0 3
8372: PPUSH
8373: LD_EXP 11
8377: PUSH
8378: LD_INT 2
8380: MINUS
8381: PPUSH
8382: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8386: CALL_OW 44
8390: PPUSH
8391: LD_INT 17
8393: PUSH
8394: LD_INT 19
8396: PUSH
8397: LD_INT 18
8399: PUSH
8400: LD_INT 19
8402: PUSH
8403: EMPTY
8404: LIST
8405: LIST
8406: LIST
8407: LIST
8408: PUSH
8409: LD_VAR 0 3
8413: PUSH
8414: LD_INT 4
8416: MOD
8417: PUSH
8418: LD_INT 1
8420: PLUS
8421: ARRAY
8422: PPUSH
8423: LD_INT 1
8425: PPUSH
8426: CALL_OW 49
// end ; end ; end ;
8430: PPOPN 5
8432: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 255
8442: PUSH
8443: LD_EXP 8
8447: EQUAL
8448: PUSH
8449: LD_VAR 0 1
8453: PUSH
8454: LD_INT 33
8456: PUSH
8457: LD_INT 2
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: PUSH
8464: LD_INT 21
8466: PUSH
8467: LD_INT 2
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PPUSH
8478: CALL_OW 69
8482: IN
8483: AND
8484: IFFALSE 8607
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
8486: LD_OWVAR 3
8490: PUSH
8491: LD_VAR 0 1
8495: DIFF
8496: PPUSH
8497: LD_VAR 0 1
8501: PPUSH
8502: CALL_OW 74
8506: PPUSH
8507: CALL_OW 255
8511: PUSH
8512: LD_EXP 8
8516: NONEQUAL
8517: IFFALSE 8607
// begin Wait ( 0 0$1.3 ) ;
8519: LD_INT 46
8521: PPUSH
8522: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8526: LD_VAR 0 1
8530: PPUSH
8531: CALL_OW 250
8535: PPUSH
8536: LD_VAR 0 1
8540: PPUSH
8541: CALL_OW 251
8545: PPUSH
8546: LD_INT 1
8548: PPUSH
8549: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8553: LD_VAR 0 1
8557: PPUSH
8558: CALL_OW 250
8562: PPUSH
8563: LD_VAR 0 1
8567: PPUSH
8568: CALL_OW 251
8572: PPUSH
8573: LD_INT 1
8575: PPUSH
8576: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8580: LD_VAR 0 1
8584: PPUSH
8585: CALL_OW 250
8589: PPUSH
8590: LD_VAR 0 1
8594: PPUSH
8595: CALL_OW 251
8599: PPUSH
8600: LD_INT 1
8602: PPUSH
8603: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
8607: LD_VAR 0 1
8611: PPUSH
8612: CALL_OW 263
8616: PUSH
8617: LD_INT 2
8619: EQUAL
8620: IFFALSE 8631
// ComUnlink ( un ) ;
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 136
// end ;
8631: PPOPN 1
8633: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8634: LD_VAR 0 1
8638: PPUSH
8639: CALL_OW 255
8643: PUSH
8644: LD_EXP 8
8648: EQUAL
8649: IFFALSE 8680
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8651: LD_ADDR_EXP 20
8655: PUSH
8656: LD_EXP 20
8660: PPUSH
8661: LD_EXP 20
8665: PUSH
8666: LD_INT 1
8668: PLUS
8669: PPUSH
8670: LD_VAR 0 1
8674: PPUSH
8675: CALL_OW 2
8679: ST_TO_ADDR
// end ;
8680: PPOPN 2
8682: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8683: LD_INT 0
8685: PPUSH
8686: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8687: LD_VAR 0 1
8691: PPUSH
8692: CALL_OW 255
8696: PUSH
8697: LD_EXP 8
8701: EQUAL
8702: PUSH
8703: LD_VAR 0 1
8707: PPUSH
8708: CALL_OW 266
8712: PUSH
8713: LD_INT 32
8715: EQUAL
8716: AND
8717: IFFALSE 8815
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 22
8726: PUSH
8727: LD_EXP 8
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PUSH
8736: LD_INT 30
8738: PUSH
8739: LD_INT 5
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PPUSH
8750: CALL_OW 69
8754: ST_TO_ADDR
// for i in arm do
8755: LD_ADDR_VAR 0 3
8759: PUSH
8760: LD_VAR 0 4
8764: PUSH
8765: FOR_IN
8766: IFFALSE 8813
// if UnitsInside ( i ) < 6 then
8768: LD_VAR 0 3
8772: PPUSH
8773: CALL_OW 313
8777: PUSH
8778: LD_INT 6
8780: LESS
8781: IFFALSE 8811
// begin ComEnterUnit ( un , i ) ;
8783: LD_VAR 0 2
8787: PPUSH
8788: LD_VAR 0 3
8792: PPUSH
8793: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8797: LD_VAR 0 2
8801: PPUSH
8802: LD_INT 8
8804: PPUSH
8805: CALL_OW 183
// break ;
8809: GO 8813
// end ;
8811: GO 8765
8813: POP
8814: POP
// end ; end ; end_of_file
8815: PPOPN 4
8817: END
// every 2 2$0 do
8818: GO 8820
8820: DISABLE
// begin Anticheatcheck ;
8821: CALL_OW 514
// enable ;
8825: ENABLE
// end ; end_of_file
8826: END
// every 10 do
8827: GO 8829
8829: DISABLE
// begin if not multiplayer then
8830: LD_OWVAR 4
8834: NOT
8835: IFFALSE 8839
// exit ;
8837: GO 8924
// if tick < 100 then
8839: LD_OWVAR 1
8843: PUSH
8844: LD_INT 100
8846: LESS
8847: IFFALSE 8867
// begin if tick mod 10 = 0 then
8849: LD_OWVAR 1
8853: PUSH
8854: LD_INT 10
8856: MOD
8857: PUSH
8858: LD_INT 0
8860: EQUAL
8861: IFFALSE 8867
// MultiplayerCRC ;
8863: CALL_OW 361
// end ; if ( tick >= 100 ) then
8867: LD_OWVAR 1
8871: PUSH
8872: LD_INT 100
8874: GREATEREQUAL
8875: IFFALSE 8895
// if tick mod 20 = 0 then
8877: LD_OWVAR 1
8881: PUSH
8882: LD_INT 20
8884: MOD
8885: PUSH
8886: LD_INT 0
8888: EQUAL
8889: IFFALSE 8895
// MultiplayerCRC ;
8891: CALL_OW 361
// if ( tick >= 100 ) then
8895: LD_OWVAR 1
8899: PUSH
8900: LD_INT 100
8902: GREATEREQUAL
8903: IFFALSE 8923
// if tick mod 30 = 0 then
8905: LD_OWVAR 1
8909: PUSH
8910: LD_INT 30
8912: MOD
8913: PUSH
8914: LD_INT 0
8916: EQUAL
8917: IFFALSE 8923
// DebugLogAll ;
8919: CALL_OW 360
// enable ;
8923: ENABLE
// end ; end_of_file
8924: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
8925: LD_INT 0
8927: PPUSH
8928: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
8929: LD_ADDR_VAR 0 2
8933: PUSH
8934: LD_STRING #Multi1x1-Time
8936: PUSH
8937: LD_OWVAR 1
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: ST_TO_ADDR
// if ( ExtraStrings ) then
8946: LD_EXP 28
8950: IFFALSE 8972
// AllStrings := AllStrings ^  ^ ExtraStrings ;
8952: LD_ADDR_VAR 0 2
8956: PUSH
8957: LD_VAR 0 2
8961: PUSH
8962: LD_STRING 
8964: ADD
8965: PUSH
8966: LD_EXP 28
8970: ADD
8971: ST_TO_ADDR
// Display_Strings := AllStrings ;
8972: LD_ADDR_OWVAR 47
8976: PUSH
8977: LD_VAR 0 2
8981: ST_TO_ADDR
// end ;
8982: LD_VAR 0 1
8986: RET
// every 0 0$1 do
8987: GO 8989
8989: DISABLE
// begin ShowTimer ;
8990: CALL 8925 0 0
// enable ;
8994: ENABLE
// end ;
8995: END
