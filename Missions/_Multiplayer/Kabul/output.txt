// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3634 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 304
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := [ [ ] ] ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: EMPTY
 186: PUSH
 187: EMPTY
 188: LIST
 189: ST_TO_ADDR
// for i in mp_teams do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: LD_OWVAR 12
 199: PUSH
 200: FOR_IN
 201: IFFALSE 242
// Teams := Replace ( Teams , 1 , Teams [ 1 ] union i [ 1 ] ) ;
 203: LD_ADDR_EXP 5
 207: PUSH
 208: LD_EXP 5
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_EXP 5
 220: PUSH
 221: LD_INT 1
 223: ARRAY
 224: PUSH
 225: LD_VAR 0 2
 229: PUSH
 230: LD_INT 1
 232: ARRAY
 233: UNION
 234: PPUSH
 235: CALL_OW 1
 239: ST_TO_ADDR
 240: GO 200
 242: POP
 243: POP
// for i = 0 to 6 do
 244: LD_ADDR_VAR 0 2
 248: PUSH
 249: DOUBLE
 250: LD_INT 0
 252: DEC
 253: ST_TO_ADDR
 254: LD_INT 6
 256: PUSH
 257: FOR_TO
 258: IFFALSE 300
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 260: LD_ADDR_EXP 16
 264: PUSH
 265: LD_EXP 16
 269: PPUSH
 270: LD_EXP 16
 274: PUSH
 275: LD_INT 1
 277: PLUS
 278: PPUSH
 279: LD_VAR 0 2
 283: PPUSH
 284: CALL_OW 426
 288: PUSH
 289: LD_INT 1
 291: PLUS
 292: PPUSH
 293: CALL_OW 2
 297: ST_TO_ADDR
 298: GO 257
 300: POP
 301: POP
// end else
 302: GO 459
// begin Game_Type := 1 ;
 304: LD_ADDR_EXP 1
 308: PUSH
 309: LD_INT 1
 311: ST_TO_ADDR
// Your_Side := 2 ;
 312: LD_ADDR_OWVAR 2
 316: PUSH
 317: LD_INT 2
 319: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 0 , 2 , 0 , 3 , 0 ] ;
 320: LD_ADDR_EXP 2
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: LD_INT 0
 336: PUSH
 337: LD_INT 2
 339: PUSH
 340: LD_INT 0
 342: PUSH
 343: LD_INT 3
 345: PUSH
 346: LD_INT 0
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: LIST
 358: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 ] ;
 359: LD_ADDR_EXP 3
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: LD_INT 0
 375: PUSH
 376: LD_INT 1
 378: PUSH
 379: LD_INT 0
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 0
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: ST_TO_ADDR
// Side_Nations := [ 3 , 0 , 0 , 0 , 3 , 0 , 3 , 0 ] ;
 398: LD_ADDR_EXP 4
 402: PUSH
 403: LD_INT 3
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: LD_INT 0
 414: PUSH
 415: LD_INT 3
 417: PUSH
 418: LD_INT 0
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 0
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: LIST
 436: ST_TO_ADDR
// Teams := [ [ 1 , 5 , 7 ] ] ;
 437: LD_ADDR_EXP 5
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 5
 447: PUSH
 448: LD_INT 7
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 459: LD_ADDR_EXP 7
 463: PUSH
 464: LD_INT 203
 466: PUSH
 467: LD_INT 174
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 114
 476: PUSH
 477: LD_INT 171
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: PUSH
 484: LD_INT 26
 486: PUSH
 487: LD_INT 44
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: PUSH
 494: EMPTY
 495: PUSH
 496: EMPTY
 497: PUSH
 498: EMPTY
 499: PUSH
 500: EMPTY
 501: PUSH
 502: EMPTY
 503: PUSH
 504: EMPTY
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: ST_TO_ADDR
// Bot_Side := 2 ;
 514: LD_ADDR_EXP 8
 518: PUSH
 519: LD_INT 2
 521: ST_TO_ADDR
// for i = 1 to 8 do
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: DOUBLE
 528: LD_INT 1
 530: DEC
 531: ST_TO_ADDR
 532: LD_INT 8
 534: PUSH
 535: FOR_TO
 536: IFFALSE 630
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 538: LD_VAR 0 2
 542: PPUSH
 543: CALL_OW 530
 547: PUSH
 548: LD_VAR 0 2
 552: PPUSH
 553: CALL_OW 532
 557: OR
 558: IFFALSE 583
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 560: LD_ADDR_EXP 2
 564: PUSH
 565: LD_EXP 2
 569: PPUSH
 570: LD_VAR 0 2
 574: PPUSH
 575: LD_INT 0
 577: PPUSH
 578: CALL_OW 1
 582: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 583: LD_EXP 4
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PUSH
 594: LD_EXP 4
 598: PUSH
 599: LD_INT 3
 601: NONEQUAL
 602: AND
 603: IFFALSE 628
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 605: LD_ADDR_EXP 4
 609: PUSH
 610: LD_EXP 4
 614: PPUSH
 615: LD_VAR 0 2
 619: PPUSH
 620: LD_INT 3
 622: PPUSH
 623: CALL_OW 1
 627: ST_TO_ADDR
// end ;
 628: GO 535
 630: POP
 631: POP
// if bot_side = 2 and Side_Positions [ 2 ] then
 632: LD_EXP 8
 636: PUSH
 637: LD_INT 2
 639: EQUAL
 640: PUSH
 641: LD_EXP 2
 645: PUSH
 646: LD_INT 2
 648: ARRAY
 649: AND
 650: IFFALSE 660
// bot_side := 5 ;
 652: LD_ADDR_EXP 8
 656: PUSH
 657: LD_INT 5
 659: ST_TO_ADDR
// if bot_side = 5 and Side_Positions [ 5 ] then
 660: LD_EXP 8
 664: PUSH
 665: LD_INT 5
 667: EQUAL
 668: PUSH
 669: LD_EXP 2
 673: PUSH
 674: LD_INT 5
 676: ARRAY
 677: AND
 678: IFFALSE 688
// bot_side := 8 ;
 680: LD_ADDR_EXP 8
 684: PUSH
 685: LD_INT 8
 687: ST_TO_ADDR
// Team_Game := true ;
 688: LD_ADDR_EXP 6
 692: PUSH
 693: LD_INT 1
 695: ST_TO_ADDR
// for i = 1 to 8 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 8
 708: PUSH
 709: FOR_TO
 710: IFFALSE 746
// if i <> bot_side then
 712: LD_VAR 0 2
 716: PUSH
 717: LD_EXP 8
 721: NONEQUAL
 722: IFFALSE 744
// SetAttitude ( i , bot_side , att_enemy , true ) ;
 724: LD_VAR 0 2
 728: PPUSH
 729: LD_EXP 8
 733: PPUSH
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 1
 739: PPUSH
 740: CALL_OW 80
 744: GO 709
 746: POP
 747: POP
// for i := 2 to Teams [ 1 ] do
 748: LD_ADDR_VAR 0 2
 752: PUSH
 753: DOUBLE
 754: LD_INT 2
 756: DEC
 757: ST_TO_ADDR
 758: LD_EXP 5
 762: PUSH
 763: LD_INT 1
 765: ARRAY
 766: PUSH
 767: FOR_TO
 768: IFFALSE 842
// begin ChangeSideFog ( Teams [ 1 ] [ i ] , Teams [ 1 ] [ 1 ] ) ;
 770: LD_EXP 5
 774: PUSH
 775: LD_INT 1
 777: ARRAY
 778: PUSH
 779: LD_VAR 0 2
 783: ARRAY
 784: PPUSH
 785: LD_EXP 5
 789: PUSH
 790: LD_INT 1
 792: ARRAY
 793: PUSH
 794: LD_INT 1
 796: ARRAY
 797: PPUSH
 798: CALL_OW 343
// SetAttitude ( Teams [ 1 ] [ i ] , Teams [ 1 ] [ 1 ] , att_friend , true ) ;
 802: LD_EXP 5
 806: PUSH
 807: LD_INT 1
 809: ARRAY
 810: PUSH
 811: LD_VAR 0 2
 815: ARRAY
 816: PPUSH
 817: LD_EXP 5
 821: PUSH
 822: LD_INT 1
 824: ARRAY
 825: PUSH
 826: LD_INT 1
 828: ARRAY
 829: PPUSH
 830: LD_INT 1
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: CALL_OW 80
// end ;
 840: GO 767
 842: POP
 843: POP
// if not Multiplayer then
 844: LD_OWVAR 4
 848: NOT
 849: IFFALSE 886
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 851: LD_ADDR_EXP 16
 855: PUSH
 856: LD_INT 1
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 1
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 3
 873: PUSH
 874: LD_INT 3
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 886: LD_ADDR_EXP 10
 890: PUSH
 891: LD_INT 9
 893: PUSH
 894: LD_INT 12
 896: PUSH
 897: LD_INT 15
 899: PUSH
 900: LD_INT 24
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: PUSH
 909: LD_EXP 16
 913: PUSH
 914: LD_INT 1
 916: ARRAY
 917: ARRAY
 918: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 919: LD_ADDR_EXP 11
 923: PUSH
 924: LD_INT 2
 926: PUSH
 927: LD_INT 4
 929: PUSH
 930: LD_INT 6
 932: PUSH
 933: LD_INT 8
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: LD_EXP 16
 946: PUSH
 947: LD_INT 2
 949: ARRAY
 950: ARRAY
 951: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 952: LD_ADDR_EXP 12
 956: PUSH
 957: LD_INT 1050
 959: PUSH
 960: LD_INT 875
 962: PUSH
 963: LD_INT 700
 965: PUSH
 966: LD_INT 595
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_EXP 16
 979: PUSH
 980: LD_INT 3
 982: ARRAY
 983: ARRAY
 984: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
 985: LD_ADDR_EXP 13
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 10500
 995: PUSH
 996: LD_INT 6300
 998: PUSH
 999: EMPTY
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_EXP 16
1008: PUSH
1009: LD_INT 4
1011: ARRAY
1012: ARRAY
1013: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
1014: LD_ADDR_EXP 14
1018: PUSH
1019: LD_INT 0
1021: PUSH
1022: LD_INT 31500
1024: PUSH
1025: LD_INT 10500
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_EXP 16
1037: PUSH
1038: LD_INT 4
1040: ARRAY
1041: ARRAY
1042: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1043: LD_ADDR_EXP 15
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 5
1056: PUSH
1057: LD_INT 7
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_EXP 16
1070: PUSH
1071: LD_INT 5
1073: ARRAY
1074: ARRAY
1075: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1076: LD_ADDR_OWVAR 67
1080: PUSH
1081: LD_INT 1
1083: PUSH
1084: LD_INT 2
1086: PUSH
1087: LD_INT 3
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: PUSH
1095: LD_EXP 16
1099: PUSH
1100: LD_INT 6
1102: ARRAY
1103: ARRAY
1104: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1105: LD_ADDR_EXP 26
1109: PUSH
1110: LD_INT 0
1112: PUSH
1113: LD_INT 1
1115: PUSH
1116: LD_INT 2
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_EXP 16
1128: PUSH
1129: LD_INT 7
1131: ARRAY
1132: ARRAY
1133: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1134: LD_ADDR_EXP 23
1138: PUSH
1139: LD_INT 11353
1141: PUSH
1142: LD_INT 12244
1144: PUSH
1145: LD_INT 44444
1147: PUSH
1148: LD_INT 12345
1150: PUSH
1151: LD_INT 43413
1153: PUSH
1154: LD_INT 14152
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1165: LD_ADDR_EXP 24
1169: PUSH
1170: LD_INT 1
1172: PPUSH
1173: LD_INT 6
1175: PPUSH
1176: CALL_OW 12
1180: ST_TO_ADDR
// if bot_side <> 2 then
1181: LD_EXP 8
1185: PUSH
1186: LD_INT 2
1188: NONEQUAL
1189: IFFALSE 1232
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: LD_INT 22
1198: PUSH
1199: LD_INT 2
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PPUSH
1206: CALL_OW 69
1210: PUSH
1211: FOR_IN
1212: IFFALSE 1230
// SetSide ( i , bot_side ) ;
1214: LD_VAR 0 2
1218: PPUSH
1219: LD_EXP 8
1223: PPUSH
1224: CALL_OW 235
1228: GO 1211
1230: POP
1231: POP
// ResetFog ;
1232: CALL_OW 335
// PreparePeople ( ) ;
1236: CALL 2066 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1240: LD_ADDR_EXP 18
1244: PUSH
1245: LD_INT 14
1247: PUSH
1248: LD_INT 15
1250: PUSH
1251: LD_INT 16
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// if amount_of_apeman then
1259: LD_EXP 15
1263: IFFALSE 1313
// for j in apeman_areas do
1265: LD_ADDR_VAR 0 3
1269: PUSH
1270: LD_EXP 18
1274: PUSH
1275: FOR_IN
1276: IFFALSE 1311
// for i = 1 to amount_of_apeman do
1278: LD_ADDR_VAR 0 2
1282: PUSH
1283: DOUBLE
1284: LD_INT 1
1286: DEC
1287: ST_TO_ADDR
1288: LD_EXP 15
1292: PUSH
1293: FOR_TO
1294: IFFALSE 1307
// AddApeman ( j ) ;
1296: LD_VAR 0 3
1300: PPUSH
1301: CALL 3015 0 1
1305: GO 1293
1307: POP
1308: POP
1309: GO 1275
1311: POP
1312: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1313: LD_INT 22
1315: PUSH
1316: LD_OWVAR 2
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PPUSH
1325: CALL_OW 69
1329: PUSH
1330: LD_INT 1
1332: ARRAY
1333: PPUSH
1334: CALL_OW 87
// disable ( 17 ) ;
1338: LD_INT 17
1340: DISABLE_MARKED
// end ;
1341: LD_VAR 0 1
1345: RET
// every 3 3$40 trigger game_start do
1346: LD_EXP 9
1350: IFFALSE 1406
1352: GO 1354
1354: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1355: LD_OWVAR 1
1359: PUSH
1360: LD_INT 5
1362: MOD
1363: PUSH
1364: LD_INT 1
1366: PLUS
1367: PPUSH
1368: LD_INT 13
1370: PPUSH
1371: LD_INT 1
1373: PPUSH
1374: CALL_OW 55
// Wait ( 0 0$15 ) ;
1378: LD_INT 525
1380: PPUSH
1381: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1385: LD_OWVAR 1
1389: PUSH
1390: LD_INT 5
1392: MOD
1393: PUSH
1394: LD_INT 1
1396: PLUS
1397: PPUSH
1398: LD_INT 1
1400: PPUSH
1401: CALL_OW 57
// enable ;
1405: ENABLE
// end ;
1406: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1407: LD_EXP 9
1411: IFFALSE 2063
1413: GO 1415
1415: DISABLE
1416: LD_INT 0
1418: PPUSH
1419: PPUSH
// begin cr := 1 ;
1420: LD_ADDR_VAR 0 1
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1428: LD_ADDR_VAR 0 2
1432: PUSH
1433: LD_INT 1
1435: PPUSH
1436: LD_INT 3
1438: PPUSH
1439: CALL_OW 12
1443: PUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_INT 4
1449: PPUSH
1450: CALL_OW 12
1454: PUSH
1455: LD_INT 3
1457: PPUSH
1458: LD_INT 5
1460: PPUSH
1461: CALL_OW 12
1465: PUSH
1466: LD_INT 3
1468: PPUSH
1469: LD_INT 5
1471: PPUSH
1472: CALL_OW 12
1476: PUSH
1477: LD_INT 2
1479: PPUSH
1480: LD_INT 5
1482: PPUSH
1483: CALL_OW 12
1487: PUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_INT 5
1493: PPUSH
1494: CALL_OW 12
1498: PUSH
1499: EMPTY
1500: LIST
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: ST_TO_ADDR
// while ( true ) do
1507: LD_INT 1
1509: IFFALSE 2063
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1511: LD_EXP 12
1515: PUSH
1516: LD_OWVAR 1
1520: PUSH
1521: LD_INT 35
1523: MOD
1524: PUSH
1525: LD_INT 60
1527: MUL
1528: PLUS
1529: PPUSH
1530: CALL_OW 67
// if cr mod 3 = 0 then
1534: LD_VAR 0 1
1538: PUSH
1539: LD_INT 3
1541: MOD
1542: PUSH
1543: LD_INT 0
1545: EQUAL
1546: IFFALSE 1699
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1548: LD_VAR 0 2
1552: PUSH
1553: LD_VAR 0 1
1557: PUSH
1558: LD_VAR 0 2
1562: MOD
1563: PUSH
1564: LD_INT 1
1566: PLUS
1567: ARRAY
1568: PPUSH
1569: LD_INT 17
1571: PPUSH
1572: LD_INT 1
1574: PPUSH
1575: CALL_OW 55
// Wait ( crates_spawn ) ;
1579: LD_EXP 12
1583: PPUSH
1584: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 1
1597: PUSH
1598: LD_VAR 0 2
1602: MOD
1603: PUSH
1604: LD_INT 1
1606: PLUS
1607: ARRAY
1608: PPUSH
1609: LD_INT 18
1611: PPUSH
1612: LD_INT 1
1614: PPUSH
1615: CALL_OW 55
// Wait ( crates_spawn ) ;
1619: LD_EXP 12
1623: PPUSH
1624: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1628: LD_VAR 0 2
1632: PUSH
1633: LD_VAR 0 1
1637: PUSH
1638: LD_VAR 0 2
1642: MOD
1643: PUSH
1644: LD_INT 1
1646: PLUS
1647: ARRAY
1648: PPUSH
1649: LD_INT 19
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: CALL_OW 55
// Wait ( crates_spawn ) ;
1659: LD_EXP 12
1663: PPUSH
1664: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1668: LD_VAR 0 2
1672: PUSH
1673: LD_VAR 0 1
1677: PUSH
1678: LD_VAR 0 2
1682: MOD
1683: PUSH
1684: LD_INT 1
1686: PLUS
1687: ARRAY
1688: PPUSH
1689: LD_INT 17
1691: PPUSH
1692: LD_INT 1
1694: PPUSH
1695: CALL_OW 55
// end ; if cr mod 3 = 1 then
1699: LD_VAR 0 1
1703: PUSH
1704: LD_INT 3
1706: MOD
1707: PUSH
1708: LD_INT 1
1710: EQUAL
1711: IFFALSE 1864
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1713: LD_VAR 0 2
1717: PUSH
1718: LD_VAR 0 1
1722: PUSH
1723: LD_VAR 0 2
1727: MOD
1728: PUSH
1729: LD_INT 1
1731: PLUS
1732: ARRAY
1733: PPUSH
1734: LD_INT 18
1736: PPUSH
1737: LD_INT 1
1739: PPUSH
1740: CALL_OW 55
// Wait ( crates_spawn ) ;
1744: LD_EXP 12
1748: PPUSH
1749: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1753: LD_VAR 0 2
1757: PUSH
1758: LD_VAR 0 1
1762: PUSH
1763: LD_VAR 0 2
1767: MOD
1768: PUSH
1769: LD_INT 1
1771: PLUS
1772: ARRAY
1773: PPUSH
1774: LD_INT 17
1776: PPUSH
1777: LD_INT 1
1779: PPUSH
1780: CALL_OW 55
// Wait ( crates_spawn ) ;
1784: LD_EXP 12
1788: PPUSH
1789: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1793: LD_VAR 0 2
1797: PUSH
1798: LD_VAR 0 1
1802: PUSH
1803: LD_VAR 0 2
1807: MOD
1808: PUSH
1809: LD_INT 1
1811: PLUS
1812: ARRAY
1813: PPUSH
1814: LD_INT 19
1816: PPUSH
1817: LD_INT 1
1819: PPUSH
1820: CALL_OW 55
// Wait ( crates_spawn ) ;
1824: LD_EXP 12
1828: PPUSH
1829: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1833: LD_VAR 0 2
1837: PUSH
1838: LD_VAR 0 1
1842: PUSH
1843: LD_VAR 0 2
1847: MOD
1848: PUSH
1849: LD_INT 1
1851: PLUS
1852: ARRAY
1853: PPUSH
1854: LD_INT 18
1856: PPUSH
1857: LD_INT 1
1859: PPUSH
1860: CALL_OW 55
// end ; if cr mod 3 = 2 then
1864: LD_VAR 0 1
1868: PUSH
1869: LD_INT 3
1871: MOD
1872: PUSH
1873: LD_INT 2
1875: EQUAL
1876: IFFALSE 2029
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1878: LD_VAR 0 2
1882: PUSH
1883: LD_VAR 0 1
1887: PUSH
1888: LD_VAR 0 2
1892: MOD
1893: PUSH
1894: LD_INT 1
1896: PLUS
1897: ARRAY
1898: PPUSH
1899: LD_INT 19
1901: PPUSH
1902: LD_INT 1
1904: PPUSH
1905: CALL_OW 55
// Wait ( crates_spawn ) ;
1909: LD_EXP 12
1913: PPUSH
1914: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1918: LD_VAR 0 2
1922: PUSH
1923: LD_VAR 0 1
1927: PUSH
1928: LD_VAR 0 2
1932: MOD
1933: PUSH
1934: LD_INT 1
1936: PLUS
1937: ARRAY
1938: PPUSH
1939: LD_INT 18
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: CALL_OW 55
// Wait ( crates_spawn ) ;
1949: LD_EXP 12
1953: PPUSH
1954: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1958: LD_VAR 0 2
1962: PUSH
1963: LD_VAR 0 1
1967: PUSH
1968: LD_VAR 0 2
1972: MOD
1973: PUSH
1974: LD_INT 1
1976: PLUS
1977: ARRAY
1978: PPUSH
1979: LD_INT 17
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: CALL_OW 55
// Wait ( crates_spawn ) ;
1989: LD_EXP 12
1993: PPUSH
1994: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1998: LD_VAR 0 2
2002: PUSH
2003: LD_VAR 0 1
2007: PUSH
2008: LD_VAR 0 2
2012: MOD
2013: PUSH
2014: LD_INT 1
2016: PLUS
2017: ARRAY
2018: PPUSH
2019: LD_INT 19
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: CALL_OW 55
// end ; cr := cr + 1 ;
2029: LD_ADDR_VAR 0 1
2033: PUSH
2034: LD_VAR 0 1
2038: PUSH
2039: LD_INT 1
2041: PLUS
2042: ST_TO_ADDR
// if cr > 150 then
2043: LD_VAR 0 1
2047: PUSH
2048: LD_INT 150
2050: GREATER
2051: IFFALSE 2061
// cr := 43 ;
2053: LD_ADDR_VAR 0 1
2057: PUSH
2058: LD_INT 43
2060: ST_TO_ADDR
// end ;
2061: GO 1507
// end ; end_of_file
2063: PPOPN 2
2065: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2066: LD_INT 0
2068: PPUSH
2069: PPUSH
2070: PPUSH
2071: PPUSH
2072: PPUSH
2073: PPUSH
2074: PPUSH
2075: PPUSH
2076: PPUSH
// to_copy := [ ] ;
2077: LD_ADDR_VAR 0 5
2081: PUSH
2082: EMPTY
2083: ST_TO_ADDR
// for i = 1 to 8 do
2084: LD_ADDR_VAR 0 2
2088: PUSH
2089: DOUBLE
2090: LD_INT 1
2092: DEC
2093: ST_TO_ADDR
2094: LD_INT 8
2096: PUSH
2097: FOR_TO
2098: IFFALSE 3008
// begin if Side_Positions [ i ] then
2100: LD_EXP 2
2104: PUSH
2105: LD_VAR 0 2
2109: ARRAY
2110: IFFALSE 3006
// begin uc_side := i ;
2112: LD_ADDR_OWVAR 20
2116: PUSH
2117: LD_VAR 0 2
2121: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2122: LD_ADDR_OWVAR 21
2126: PUSH
2127: LD_EXP 4
2131: PUSH
2132: LD_VAR 0 2
2136: ARRAY
2137: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2138: LD_ADDR_VAR 0 6
2142: PUSH
2143: LD_EXP 7
2147: PUSH
2148: LD_EXP 2
2152: PUSH
2153: LD_VAR 0 2
2157: ARRAY
2158: ARRAY
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2164: LD_ADDR_VAR 0 7
2168: PUSH
2169: LD_EXP 7
2173: PUSH
2174: LD_EXP 2
2178: PUSH
2179: LD_VAR 0 2
2183: ARRAY
2184: ARRAY
2185: PUSH
2186: LD_INT 2
2188: ARRAY
2189: ST_TO_ADDR
// hc_importance := 100 ;
2190: LD_ADDR_OWVAR 32
2194: PUSH
2195: LD_INT 100
2197: ST_TO_ADDR
// if Multiplayer then
2198: LD_OWVAR 4
2202: IFFALSE 2260
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2204: LD_ADDR_OWVAR 26
2208: PUSH
2209: LD_OWVAR 19
2213: PUSH
2214: LD_OWVAR 20
2218: ARRAY
2219: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2220: LD_ADDR_OWVAR 33
2224: PUSH
2225: LD_STRING MULTIAVATARS
2227: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2228: LD_ADDR_OWVAR 34
2232: PUSH
2233: LD_OWVAR 20
2237: PPUSH
2238: CALL_OW 525
2242: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2243: LD_ADDR_OWVAR 27
2247: PUSH
2248: LD_OWVAR 20
2252: PPUSH
2253: CALL_OW 526
2257: ST_TO_ADDR
// end else
2258: GO 2292
// begin hc_name :=  ;
2260: LD_ADDR_OWVAR 26
2264: PUSH
2265: LD_STRING 
2267: ST_TO_ADDR
// hc_gallery :=  ;
2268: LD_ADDR_OWVAR 33
2272: PUSH
2273: LD_STRING 
2275: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2276: LD_ADDR_OWVAR 27
2280: PUSH
2281: LD_INT 1
2283: PPUSH
2284: LD_INT 2
2286: PPUSH
2287: CALL_OW 12
2291: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2292: LD_OWVAR 27
2296: PPUSH
2297: LD_INT 1
2299: PPUSH
2300: LD_EXP 11
2304: PPUSH
2305: CALL_OW 380
// un := CreateHuman ;
2309: LD_ADDR_VAR 0 4
2313: PUSH
2314: CALL_OW 44
2318: ST_TO_ADDR
// if not to_copy then
2319: LD_VAR 0 5
2323: NOT
2324: IFFALSE 2351
// to_copy := Replace ( to_copy , 1 , un ) else
2326: LD_ADDR_VAR 0 5
2330: PUSH
2331: LD_VAR 0 5
2335: PPUSH
2336: LD_INT 1
2338: PPUSH
2339: LD_VAR 0 4
2343: PPUSH
2344: CALL_OW 1
2348: ST_TO_ADDR
2349: GO 2427
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2351: LD_VAR 0 5
2355: PUSH
2356: LD_INT 1
2358: ARRAY
2359: PPUSH
2360: LD_VAR 0 4
2364: PPUSH
2365: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2369: LD_VAR 0 4
2373: PPUSH
2374: LD_INT 2
2376: PPUSH
2377: LD_VAR 0 5
2381: PUSH
2382: LD_INT 1
2384: ARRAY
2385: PPUSH
2386: LD_INT 2
2388: PPUSH
2389: CALL_OW 260
2393: PPUSH
2394: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2398: LD_VAR 0 4
2402: PPUSH
2403: LD_INT 1
2405: PPUSH
2406: LD_VAR 0 5
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 1
2417: PPUSH
2418: CALL_OW 260
2422: PPUSH
2423: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2427: LD_VAR 0 4
2431: PPUSH
2432: LD_VAR 0 6
2436: PPUSH
2437: LD_VAR 0 7
2441: PPUSH
2442: LD_INT 10
2444: PPUSH
2445: LD_INT 0
2447: PPUSH
2448: CALL_OW 50
// hc_importance := 0 ;
2452: LD_ADDR_OWVAR 32
2456: PUSH
2457: LD_INT 0
2459: ST_TO_ADDR
// hc_name :=  ;
2460: LD_ADDR_OWVAR 26
2464: PUSH
2465: LD_STRING 
2467: ST_TO_ADDR
// hc_gallery :=  ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING 
2475: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2476: LD_ADDR_VAR 0 9
2480: PUSH
2481: LD_EXP 10
2485: PUSH
2486: LD_INT 1
2488: MINUS
2489: PUSH
2490: LD_INT 4
2492: DIVREAL
2493: ST_TO_ADDR
// c := 1 ;
2494: LD_ADDR_VAR 0 8
2498: PUSH
2499: LD_INT 1
2501: ST_TO_ADDR
// for j = 2 to number_of_people do
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: DOUBLE
2508: LD_INT 2
2510: DEC
2511: ST_TO_ADDR
2512: LD_EXP 10
2516: PUSH
2517: FOR_TO
2518: IFFALSE 2729
// begin PrepareHuman ( false , c , skill_level ) ;
2520: LD_INT 0
2522: PPUSH
2523: LD_VAR 0 8
2527: PPUSH
2528: LD_EXP 11
2532: PPUSH
2533: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2537: LD_VAR 0 3
2541: PUSH
2542: LD_INT 1
2544: MINUS
2545: PUSH
2546: LD_VAR 0 9
2550: MOD
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: IFFALSE 2571
// c := c + 1 ;
2557: LD_ADDR_VAR 0 8
2561: PUSH
2562: LD_VAR 0 8
2566: PUSH
2567: LD_INT 1
2569: PLUS
2570: ST_TO_ADDR
// un := CreateHuman ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 44
2580: ST_TO_ADDR
// if to_copy < j then
2581: LD_VAR 0 5
2585: PUSH
2586: LD_VAR 0 3
2590: LESS
2591: IFFALSE 2620
// to_copy := Replace ( to_copy , j , un ) else
2593: LD_ADDR_VAR 0 5
2597: PUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: LD_VAR 0 3
2607: PPUSH
2608: LD_VAR 0 4
2612: PPUSH
2613: CALL_OW 1
2617: ST_TO_ADDR
2618: GO 2702
// begin CopySkills ( to_copy [ j ] , un ) ;
2620: LD_VAR 0 5
2624: PUSH
2625: LD_VAR 0 3
2629: ARRAY
2630: PPUSH
2631: LD_VAR 0 4
2635: PPUSH
2636: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2640: LD_VAR 0 4
2644: PPUSH
2645: LD_INT 2
2647: PPUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_VAR 0 3
2657: ARRAY
2658: PPUSH
2659: LD_INT 2
2661: PPUSH
2662: CALL_OW 260
2666: PPUSH
2667: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2671: LD_VAR 0 4
2675: PPUSH
2676: LD_INT 1
2678: PPUSH
2679: LD_VAR 0 5
2683: PUSH
2684: LD_VAR 0 3
2688: ARRAY
2689: PPUSH
2690: LD_INT 1
2692: PPUSH
2693: CALL_OW 260
2697: PPUSH
2698: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2702: LD_VAR 0 4
2706: PPUSH
2707: LD_VAR 0 6
2711: PPUSH
2712: LD_VAR 0 7
2716: PPUSH
2717: LD_INT 10
2719: PPUSH
2720: LD_INT 0
2722: PPUSH
2723: CALL_OW 50
// end ;
2727: GO 2517
2729: POP
2730: POP
// if handicap then
2731: LD_EXP 26
2735: IFFALSE 3006
// begin if handicap = 1 then
2737: LD_EXP 26
2741: PUSH
2742: LD_INT 1
2744: EQUAL
2745: IFFALSE 2824
// for j = 1 to 2 do
2747: LD_ADDR_VAR 0 3
2751: PUSH
2752: DOUBLE
2753: LD_INT 1
2755: DEC
2756: ST_TO_ADDR
2757: LD_INT 2
2759: PUSH
2760: FOR_TO
2761: IFFALSE 2822
// begin vc_chassis := ru_medium_tracked ;
2763: LD_ADDR_OWVAR 37
2767: PUSH
2768: LD_INT 22
2770: ST_TO_ADDR
// vc_engine := engine_combustion ;
2771: LD_ADDR_OWVAR 39
2775: PUSH
2776: LD_INT 1
2778: ST_TO_ADDR
// vc_control := control_manual ;
2779: LD_ADDR_OWVAR 38
2783: PUSH
2784: LD_INT 1
2786: ST_TO_ADDR
// vc_weapon := ru_gun ;
2787: LD_ADDR_OWVAR 40
2791: PUSH
2792: LD_INT 44
2794: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2795: CALL_OW 45
2799: PPUSH
2800: LD_VAR 0 6
2804: PPUSH
2805: LD_VAR 0 7
2809: PPUSH
2810: LD_INT 13
2812: PPUSH
2813: LD_INT 0
2815: PPUSH
2816: CALL_OW 50
// end ;
2820: GO 2760
2822: POP
2823: POP
// if handicap = 2 then
2824: LD_EXP 26
2828: PUSH
2829: LD_INT 2
2831: EQUAL
2832: IFFALSE 3006
// begin for j = 1 to 2 do
2834: LD_ADDR_VAR 0 3
2838: PUSH
2839: DOUBLE
2840: LD_INT 1
2842: DEC
2843: ST_TO_ADDR
2844: LD_INT 2
2846: PUSH
2847: FOR_TO
2848: IFFALSE 2922
// begin vc_chassis := ru_heavy_tracked ;
2850: LD_ADDR_OWVAR 37
2854: PUSH
2855: LD_INT 24
2857: ST_TO_ADDR
// vc_engine := engine_combustion ;
2858: LD_ADDR_OWVAR 39
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_control := control_manual ;
2866: LD_ADDR_OWVAR 38
2870: PUSH
2871: LD_INT 1
2873: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_heavy_gun ] [ j ] ;
2874: LD_ADDR_OWVAR 40
2878: PUSH
2879: LD_INT 43
2881: PUSH
2882: LD_INT 46
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: LD_VAR 0 3
2893: ARRAY
2894: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2895: CALL_OW 45
2899: PPUSH
2900: LD_VAR 0 6
2904: PPUSH
2905: LD_VAR 0 7
2909: PPUSH
2910: LD_INT 13
2912: PPUSH
2913: LD_INT 0
2915: PPUSH
2916: CALL_OW 50
// end ;
2920: GO 2847
2922: POP
2923: POP
// vc_chassis := ru_medium_tracked ;
2924: LD_ADDR_OWVAR 37
2928: PUSH
2929: LD_INT 22
2931: ST_TO_ADDR
// vc_engine := engine_siberite ;
2932: LD_ADDR_OWVAR 39
2936: PUSH
2937: LD_INT 3
2939: ST_TO_ADDR
// vc_control := control_computer ;
2940: LD_ADDR_OWVAR 38
2944: PUSH
2945: LD_INT 3
2947: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2948: LD_ADDR_OWVAR 40
2952: PUSH
2953: LD_INT 51
2955: ST_TO_ADDR
// un := CreateVehicle ;
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: CALL_OW 45
2965: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2966: LD_VAR 0 4
2970: PPUSH
2971: LD_VAR 0 6
2975: PPUSH
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 13
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
2991: LD_VAR 0 4
2995: PPUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 100
3001: PPUSH
3002: CALL_OW 290
// end ; end ; end ; end ;
3006: GO 2097
3008: POP
3009: POP
// end ;
3010: LD_VAR 0 1
3014: RET
// export function AddApeman ( area ) ; begin
3015: LD_INT 0
3017: PPUSH
// uc_nation := 0 ;
3018: LD_ADDR_OWVAR 21
3022: PUSH
3023: LD_INT 0
3025: ST_TO_ADDR
// uc_side := 0 ;
3026: LD_ADDR_OWVAR 20
3030: PUSH
3031: LD_INT 0
3033: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
3034: LD_ADDR_OWVAR 35
3038: PUSH
3039: LD_INT 10
3041: NEG
3042: PPUSH
3043: LD_INT 15
3045: PPUSH
3046: CALL_OW 12
3050: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3051: LD_INT 0
3053: PPUSH
3054: LD_INT 12
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3064: LD_ADDR_OWVAR 29
3068: PUSH
3069: LD_INT 10
3071: PUSH
3072: LD_INT 12
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3079: CALL_OW 44
3083: PPUSH
3084: LD_VAR 0 1
3088: PPUSH
3089: LD_INT 0
3091: PPUSH
3092: CALL_OW 49
// end ;
3096: LD_VAR 0 2
3100: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3101: LD_INT 0
3103: PPUSH
3104: PPUSH
3105: PPUSH
3106: PPUSH
// r := 100 ;
3107: LD_ADDR_VAR 0 5
3111: PUSH
3112: LD_INT 100
3114: ST_TO_ADDR
// x := 0 ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_INT 0
3122: ST_TO_ADDR
// while ( x < n ) do
3123: LD_VAR 0 6
3127: PUSH
3128: LD_VAR 0 2
3132: LESS
3133: IFFALSE 3448
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3135: LD_ADDR_VAR 0 4
3139: PUSH
3140: DOUBLE
3141: LD_INT 1
3143: DEC
3144: ST_TO_ADDR
3145: LD_VAR 0 1
3149: PPUSH
3150: LD_INT 0
3152: PPUSH
3153: CALL_OW 517
3157: PUSH
3158: LD_INT 1
3160: ARRAY
3161: PUSH
3162: FOR_TO
3163: IFFALSE 3444
// begin if r > 50 then
3165: LD_VAR 0 5
3169: PUSH
3170: LD_INT 50
3172: GREATER
3173: IFFALSE 3420
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3175: LD_VAR 0 1
3179: PPUSH
3180: LD_INT 0
3182: PPUSH
3183: CALL_OW 517
3187: PUSH
3188: LD_INT 1
3190: ARRAY
3191: PUSH
3192: LD_VAR 0 4
3196: ARRAY
3197: PPUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 0
3205: PPUSH
3206: CALL_OW 517
3210: PUSH
3211: LD_INT 2
3213: ARRAY
3214: PUSH
3215: LD_VAR 0 4
3219: ARRAY
3220: PPUSH
3221: CALL_OW 458
3225: NOT
3226: IFFALSE 3404
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3228: LD_VAR 0 1
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 517
3240: PUSH
3241: LD_INT 1
3243: ARRAY
3244: PUSH
3245: LD_VAR 0 4
3249: ARRAY
3250: PPUSH
3251: LD_VAR 0 1
3255: PPUSH
3256: LD_INT 0
3258: PPUSH
3259: CALL_OW 517
3263: PUSH
3264: LD_INT 2
3266: ARRAY
3267: PUSH
3268: LD_VAR 0 4
3272: ARRAY
3273: PPUSH
3274: LD_EXP 8
3278: PPUSH
3279: LD_INT 0
3281: PPUSH
3282: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3286: LD_ADDR_EXP 17
3290: PUSH
3291: LD_EXP 17
3295: PPUSH
3296: LD_EXP 17
3300: PUSH
3301: LD_INT 1
3303: PLUS
3304: PPUSH
3305: LD_VAR 0 1
3309: PPUSH
3310: LD_INT 0
3312: PPUSH
3313: CALL_OW 517
3317: PUSH
3318: LD_INT 1
3320: ARRAY
3321: PUSH
3322: LD_VAR 0 4
3326: ARRAY
3327: PPUSH
3328: CALL_OW 2
3332: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3333: LD_ADDR_EXP 17
3337: PUSH
3338: LD_EXP 17
3342: PPUSH
3343: LD_EXP 17
3347: PUSH
3348: LD_INT 1
3350: PLUS
3351: PPUSH
3352: LD_VAR 0 1
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: CALL_OW 517
3364: PUSH
3365: LD_INT 2
3367: ARRAY
3368: PUSH
3369: LD_VAR 0 4
3373: ARRAY
3374: PPUSH
3375: CALL_OW 2
3379: ST_TO_ADDR
// r := 0 ;
3380: LD_ADDR_VAR 0 5
3384: PUSH
3385: LD_INT 0
3387: ST_TO_ADDR
// x := x + 1 ;
3388: LD_ADDR_VAR 0 6
3392: PUSH
3393: LD_VAR 0 6
3397: PUSH
3398: LD_INT 1
3400: PLUS
3401: ST_TO_ADDR
// end else
3402: GO 3418
// r := r + 35 ;
3404: LD_ADDR_VAR 0 5
3408: PUSH
3409: LD_VAR 0 5
3413: PUSH
3414: LD_INT 35
3416: PLUS
3417: ST_TO_ADDR
// end else
3418: GO 3442
// r := r + rand ( 10 , 25 ) ;
3420: LD_ADDR_VAR 0 5
3424: PUSH
3425: LD_VAR 0 5
3429: PUSH
3430: LD_INT 10
3432: PPUSH
3433: LD_INT 25
3435: PPUSH
3436: CALL_OW 12
3440: PLUS
3441: ST_TO_ADDR
// end ;
3442: GO 3162
3444: POP
3445: POP
3446: GO 3123
// end ;
3448: LD_VAR 0 3
3452: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3453: LD_INT 0
3455: PPUSH
3456: PPUSH
3457: PPUSH
// if not GetControl ( veh ) = control_manual then
3458: LD_VAR 0 1
3462: PPUSH
3463: CALL_OW 263
3467: PUSH
3468: LD_INT 1
3470: EQUAL
3471: NOT
3472: IFFALSE 3484
// result := false else
3474: LD_ADDR_VAR 0 2
3478: PUSH
3479: LD_INT 0
3481: ST_TO_ADDR
3482: GO 3629
// if veh in FilterAllUnits ( [ f_empty ] ) then
3484: LD_VAR 0 1
3488: PUSH
3489: LD_INT 58
3491: PUSH
3492: EMPTY
3493: LIST
3494: PPUSH
3495: CALL_OW 69
3499: IN
3500: IFFALSE 3512
// result := false else
3502: LD_ADDR_VAR 0 2
3506: PUSH
3507: LD_INT 0
3509: ST_TO_ADDR
3510: GO 3629
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3512: LD_ADDR_VAR 0 4
3516: PUSH
3517: LD_INT 22
3519: PUSH
3520: LD_VAR 0 1
3524: PPUSH
3525: CALL_OW 255
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 55
3536: PUSH
3537: EMPTY
3538: LIST
3539: PUSH
3540: EMPTY
3541: LIST
3542: LIST
3543: PPUSH
3544: CALL_OW 69
3548: ST_TO_ADDR
// if not filter then
3549: LD_VAR 0 4
3553: NOT
3554: IFFALSE 3566
// result := false else
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_INT 0
3563: ST_TO_ADDR
3564: GO 3629
// for i = 1 to filter do
3566: LD_ADDR_VAR 0 3
3570: PUSH
3571: DOUBLE
3572: LD_INT 1
3574: DEC
3575: ST_TO_ADDR
3576: LD_VAR 0 4
3580: PUSH
3581: FOR_TO
3582: IFFALSE 3627
// if IsDriver ( filter [ i ] ) = veh then
3584: LD_VAR 0 4
3588: PUSH
3589: LD_VAR 0 3
3593: ARRAY
3594: PPUSH
3595: NOP4
3599: PUSH
3600: LD_VAR 0 1
3604: EQUAL
3605: IFFALSE 3625
// begin result := filter [ i ] ;
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_VAR 0 4
3616: PUSH
3617: LD_VAR 0 3
3621: ARRAY
3622: ST_TO_ADDR
// break ;
3623: GO 3627
// end ;
3625: GO 3581
3627: POP
3628: POP
// end ; end ; end_of_file
3629: LD_VAR 0 2
3633: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3634: LD_INT 0
3636: PPUSH
3637: PPUSH
3638: PPUSH
3639: PPUSH
3640: PPUSH
3641: PPUSH
3642: PPUSH
3643: PPUSH
3644: PPUSH
// side := Bot_Side ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_EXP 8
3654: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3655: LD_ADDR_VAR 0 9
3659: PUSH
3660: LD_INT 4
3662: PUSH
3663: LD_INT 6
3665: PUSH
3666: LD_INT 8
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: LIST
3673: PUSH
3674: LD_OWVAR 67
3678: ARRAY
3679: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3680: LD_ADDR_VAR 0 8
3684: PUSH
3685: LD_INT 27
3687: PUSH
3688: LD_INT 28
3690: PUSH
3691: LD_INT 25
3693: PUSH
3694: LD_INT 26
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3703: LD_ADDR_EXP 22
3707: PUSH
3708: LD_INT 4
3710: PUSH
3711: LD_INT 5
3713: PUSH
3714: LD_INT 6
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: LIST
3721: PUSH
3722: LD_OWVAR 67
3726: ARRAY
3727: ST_TO_ADDR
// ct := [ ] ;
3728: LD_ADDR_VAR 0 3
3732: PUSH
3733: EMPTY
3734: ST_TO_ADDR
// patrols := [ ] ;
3735: LD_ADDR_EXP 19
3739: PUSH
3740: EMPTY
3741: ST_TO_ADDR
// attackers := [ ] ;
3742: LD_ADDR_EXP 20
3746: PUSH
3747: EMPTY
3748: ST_TO_ADDR
// attackers_tmp := [ ] ;
3749: LD_ADDR_EXP 27
3753: PUSH
3754: EMPTY
3755: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_siberite , control_remote , ar_selfpropelled_bomb ] ] ;
3756: LD_ADDR_EXP 21
3760: PUSH
3761: LD_INT 14
3763: PUSH
3764: LD_INT 1
3766: PUSH
3767: LD_INT 2
3769: PUSH
3770: LD_INT 27
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_INT 14
3781: PUSH
3782: LD_INT 1
3784: PUSH
3785: LD_INT 2
3787: PUSH
3788: LD_INT 25
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: PUSH
3797: LD_INT 14
3799: PUSH
3800: LD_INT 1
3802: PUSH
3803: LD_INT 2
3805: PUSH
3806: LD_INT 28
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 14
3817: PUSH
3818: LD_INT 1
3820: PUSH
3821: LD_INT 2
3823: PUSH
3824: LD_INT 29
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: PUSH
3833: LD_INT 14
3835: PUSH
3836: LD_INT 1
3838: PUSH
3839: LD_INT 2
3841: PUSH
3842: LD_INT 27
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 13
3853: PUSH
3854: LD_INT 3
3856: PUSH
3857: LD_INT 2
3859: PUSH
3860: LD_INT 29
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3877: LD_INT 2
3879: PPUSH
3880: LD_STRING newkabul
3882: PPUSH
3883: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3887: LD_INT 2
3889: PPUSH
3890: CALL_OW 274
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 90000
3900: PPUSH
3901: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 274
3912: PPUSH
3913: LD_INT 2
3915: PPUSH
3916: LD_INT 9000
3918: PPUSH
3919: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3923: LD_INT 2
3925: PPUSH
3926: CALL_OW 274
3930: PPUSH
3931: LD_INT 3
3933: PPUSH
3934: LD_INT 3000
3936: PPUSH
3937: CALL_OW 277
// if Difficulty > 1 then
3941: LD_OWVAR 67
3945: PUSH
3946: LD_INT 1
3948: GREATER
3949: IFFALSE 3966
// SetTech ( 5 , side , state_researched ) ;
3951: LD_INT 5
3953: PPUSH
3954: LD_VAR 0 5
3958: PPUSH
3959: LD_INT 2
3961: PPUSH
3962: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
3966: LD_INT 41
3968: PPUSH
3969: LD_VAR 0 5
3973: PPUSH
3974: LD_INT 2
3976: PPUSH
3977: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3981: LD_INT 51
3983: PPUSH
3984: LD_VAR 0 5
3988: PPUSH
3989: LD_INT 2
3991: PPUSH
3992: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3996: LD_INT 52
3998: PPUSH
3999: LD_VAR 0 5
4003: PPUSH
4004: LD_INT 2
4006: PPUSH
4007: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4011: LD_INT 53
4013: PPUSH
4014: LD_VAR 0 5
4018: PPUSH
4019: LD_INT 2
4021: PPUSH
4022: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4026: LD_INT 60
4028: PPUSH
4029: LD_VAR 0 5
4033: PPUSH
4034: LD_INT 2
4036: PPUSH
4037: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4041: LD_INT 61
4043: PPUSH
4044: LD_VAR 0 5
4048: PPUSH
4049: LD_INT 2
4051: PPUSH
4052: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4056: LD_INT 62
4058: PPUSH
4059: LD_VAR 0 5
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4071: LD_ADDR_VAR 0 2
4075: PUSH
4076: LD_INT 22
4078: PUSH
4079: LD_VAR 0 5
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: PUSH
4088: LD_INT 21
4090: PUSH
4091: LD_INT 3
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: PPUSH
4102: CALL_OW 69
4106: PUSH
4107: FOR_IN
4108: IFFALSE 4141
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4110: LD_VAR 0 2
4114: PPUSH
4115: LD_INT 6
4117: PUSH
4118: LD_INT 8
4120: PUSH
4121: LD_INT 10
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: LIST
4128: PUSH
4129: LD_OWVAR 67
4133: ARRAY
4134: PPUSH
4135: CALL_OW 241
4139: GO 4107
4141: POP
4142: POP
// if Difficulty > 1 then
4143: LD_OWVAR 67
4147: PUSH
4148: LD_INT 1
4150: GREATER
4151: IFFALSE 4160
// RemoveEnvironmentArea ( forest_road ) ;
4153: LD_INT 11
4155: PPUSH
4156: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4160: LD_INT 4
4162: PPUSH
4163: LD_INT 10
4165: PUSH
4166: LD_INT 15
4168: PUSH
4169: LD_INT 20
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: LIST
4176: PUSH
4177: LD_OWVAR 67
4181: ARRAY
4182: PPUSH
4183: CALL 3101 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4187: LD_INT 5
4189: PPUSH
4190: LD_INT 7
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: LD_INT 18
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 67
4208: ARRAY
4209: PPUSH
4210: CALL 3101 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4214: LD_INT 7
4216: PPUSH
4217: LD_INT 5
4219: PUSH
4220: LD_INT 11
4222: PUSH
4223: LD_INT 17
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: LIST
4230: PUSH
4231: LD_OWVAR 67
4235: ARRAY
4236: PPUSH
4237: CALL 3101 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4241: LD_INT 6
4243: PPUSH
4244: LD_INT 0
4246: PUSH
4247: LD_INT 3
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: PUSH
4258: LD_OWVAR 67
4262: ARRAY
4263: PPUSH
4264: CALL 3101 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4268: LD_INT 8
4270: PPUSH
4271: LD_INT 2
4273: PUSH
4274: LD_INT 5
4276: PUSH
4277: LD_INT 8
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: LIST
4284: PUSH
4285: LD_OWVAR 67
4289: ARRAY
4290: PPUSH
4291: CALL 3101 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4295: LD_INT 9
4297: PPUSH
4298: LD_INT 0
4300: PUSH
4301: LD_INT 2
4303: PUSH
4304: LD_INT 4
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: LD_OWVAR 67
4316: ARRAY
4317: PPUSH
4318: CALL 3101 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4322: LD_INT 10
4324: PPUSH
4325: LD_INT 0
4327: PUSH
4328: LD_INT 1
4330: PUSH
4331: LD_INT 1
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: PUSH
4339: LD_OWVAR 67
4343: ARRAY
4344: PPUSH
4345: CALL 3101 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4349: LD_INT 12
4351: PPUSH
4352: LD_INT 0
4354: PUSH
4355: LD_INT 1
4357: PUSH
4358: LD_INT 1
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: LD_OWVAR 67
4370: ARRAY
4371: PPUSH
4372: CALL 3101 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4376: LD_ADDR_VAR 0 2
4380: PUSH
4381: DOUBLE
4382: LD_INT 1
4384: DEC
4385: ST_TO_ADDR
4386: LD_INT 8
4388: PUSH
4389: LD_INT 11
4391: PUSH
4392: LD_INT 14
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PUSH
4406: FOR_TO
4407: IFFALSE 4582
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4409: LD_ADDR_VAR 0 4
4413: PUSH
4414: LD_INT 134
4416: PPUSH
4417: LD_INT 73
4419: PPUSH
4420: LD_INT 10
4422: PPUSH
4423: LD_INT 0
4425: PPUSH
4426: CALL_OW 17
4430: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4431: LD_VAR 0 4
4435: PUSH
4436: LD_INT 1
4438: ARRAY
4439: PPUSH
4440: LD_VAR 0 4
4444: PUSH
4445: LD_INT 2
4447: ARRAY
4448: PPUSH
4449: CALL_OW 428
4453: PUSH
4454: LD_INT 0
4456: EQUAL
4457: PUSH
4458: LD_VAR 0 4
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_VAR 0 4
4471: PUSH
4472: LD_INT 2
4474: ARRAY
4475: PPUSH
4476: CALL_OW 458
4480: NOT
4481: AND
4482: IFFALSE 4580
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4484: LD_ADDR_EXP 17
4488: PUSH
4489: LD_EXP 17
4493: PPUSH
4494: LD_EXP 17
4498: PUSH
4499: LD_INT 1
4501: PLUS
4502: PPUSH
4503: LD_VAR 0 4
4507: PUSH
4508: LD_INT 1
4510: ARRAY
4511: PPUSH
4512: CALL_OW 2
4516: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4517: LD_ADDR_EXP 17
4521: PUSH
4522: LD_EXP 17
4526: PPUSH
4527: LD_EXP 17
4531: PUSH
4532: LD_INT 1
4534: PLUS
4535: PPUSH
4536: LD_VAR 0 4
4540: PUSH
4541: LD_INT 2
4543: ARRAY
4544: PPUSH
4545: CALL_OW 2
4549: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 2
4566: ARRAY
4567: PPUSH
4568: LD_EXP 8
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 454
// end ; end ;
4580: GO 4406
4582: POP
4583: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4584: LD_ADDR_VAR 0 2
4588: PUSH
4589: LD_INT 22
4591: PUSH
4592: LD_VAR 0 5
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 30
4603: PUSH
4604: LD_INT 32
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PPUSH
4615: CALL_OW 69
4619: PUSH
4620: FOR_IN
4621: IFFALSE 4653
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4623: LD_VAR 0 2
4627: PPUSH
4628: LD_VAR 0 8
4632: PUSH
4633: LD_INT 1
4635: PPUSH
4636: LD_VAR 0 8
4640: PPUSH
4641: CALL_OW 12
4645: ARRAY
4646: PPUSH
4647: CALL_OW 431
4651: GO 4620
4653: POP
4654: POP
// uc_side := side ;
4655: LD_ADDR_OWVAR 20
4659: PUSH
4660: LD_VAR 0 5
4664: ST_TO_ADDR
// uc_nation := 2 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 2
4672: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4673: LD_ADDR_VAR 0 2
4677: PUSH
4678: DOUBLE
4679: LD_INT 1
4681: DEC
4682: ST_TO_ADDR
4683: LD_INT 1
4685: PUSH
4686: LD_OWVAR 67
4690: PLUS
4691: PUSH
4692: FOR_TO
4693: IFFALSE 4783
// begin vc_chassis := ar_half_tracked ;
4695: LD_ADDR_OWVAR 37
4699: PUSH
4700: LD_INT 14
4702: ST_TO_ADDR
// vc_engine := engine_combustion ;
4703: LD_ADDR_OWVAR 39
4707: PUSH
4708: LD_INT 1
4710: ST_TO_ADDR
// vc_control := control_manual ;
4711: LD_ADDR_OWVAR 38
4715: PUSH
4716: LD_INT 1
4718: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4719: LD_ADDR_OWVAR 40
4723: PUSH
4724: LD_INT 31
4726: ST_TO_ADDR
// veh := CreateVehicle ;
4727: LD_ADDR_VAR 0 7
4731: PUSH
4732: CALL_OW 45
4736: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4737: LD_VAR 0 7
4741: PPUSH
4742: LD_INT 3
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4752: LD_INT 0
4754: PPUSH
4755: LD_INT 3
4757: PPUSH
4758: LD_VAR 0 9
4762: PPUSH
4763: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4767: CALL_OW 44
4771: PPUSH
4772: LD_VAR 0 7
4776: PPUSH
4777: CALL_OW 52
// end ;
4781: GO 4692
4783: POP
4784: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4785: LD_ADDR_VAR 0 2
4789: PUSH
4790: LD_INT 22
4792: PUSH
4793: LD_VAR 0 5
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PUSH
4802: LD_INT 30
4804: PUSH
4805: LD_INT 32
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PPUSH
4816: CALL_OW 69
4820: PUSH
4821: FOR_IN
4822: IFFALSE 4855
// begin PrepareHuman ( false , 1 , skill ) ;
4824: LD_INT 0
4826: PPUSH
4827: LD_INT 1
4829: PPUSH
4830: LD_VAR 0 9
4834: PPUSH
4835: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4839: CALL_OW 44
4843: PPUSH
4844: LD_VAR 0 2
4848: PPUSH
4849: CALL_OW 52
// end ;
4853: GO 4821
4855: POP
4856: POP
// for i = 1 to 4 do
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: DOUBLE
4863: LD_INT 1
4865: DEC
4866: ST_TO_ADDR
4867: LD_INT 4
4869: PUSH
4870: FOR_TO
4871: IFFALSE 4902
// begin PrepareHuman ( false , 2 , skill ) ;
4873: LD_INT 0
4875: PPUSH
4876: LD_INT 2
4878: PPUSH
4879: LD_VAR 0 9
4883: PPUSH
4884: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4888: CALL_OW 44
4892: PPUSH
4893: LD_INT 2
4895: PPUSH
4896: CALL_OW 52
// end ;
4900: GO 4870
4902: POP
4903: POP
// for i = 1 to 6 do
4904: LD_ADDR_VAR 0 2
4908: PUSH
4909: DOUBLE
4910: LD_INT 1
4912: DEC
4913: ST_TO_ADDR
4914: LD_INT 6
4916: PUSH
4917: FOR_TO
4918: IFFALSE 4949
// begin PrepareHuman ( false , 3 , skill ) ;
4920: LD_INT 0
4922: PPUSH
4923: LD_INT 3
4925: PPUSH
4926: LD_VAR 0 9
4930: PPUSH
4931: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4935: CALL_OW 44
4939: PPUSH
4940: LD_INT 12
4942: PPUSH
4943: CALL_OW 52
// end ;
4947: GO 4917
4949: POP
4950: POP
// for i = 1 to 4 do
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_INT 4
4963: PUSH
4964: FOR_TO
4965: IFFALSE 5022
// begin PrepareHuman ( false , 4 , skill ) ;
4967: LD_INT 0
4969: PPUSH
4970: LD_INT 4
4972: PPUSH
4973: LD_VAR 0 9
4977: PPUSH
4978: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4982: CALL_OW 44
4986: PPUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 8
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PPUSH
4997: CALL_OW 69
5001: PUSH
5002: LD_VAR 0 2
5006: PUSH
5007: LD_INT 2
5009: MOD
5010: PUSH
5011: LD_INT 1
5013: PLUS
5014: ARRAY
5015: PPUSH
5016: CALL_OW 52
// end ;
5020: GO 4964
5022: POP
5023: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5024: LD_INT 0
5026: PPUSH
5027: LD_INT 8
5029: PPUSH
5030: LD_VAR 0 9
5034: PPUSH
5035: CALL_OW 380
// un := CreateHuman ;
5039: LD_ADDR_VAR 0 6
5043: PUSH
5044: CALL_OW 44
5048: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5049: LD_VAR 0 6
5053: PPUSH
5054: LD_INT 2
5056: PPUSH
5057: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5061: LD_VAR 0 6
5065: PPUSH
5066: LD_INT 31
5068: PPUSH
5069: CALL_OW 52
// for i = 1 to 4 do
5073: LD_ADDR_VAR 0 2
5077: PUSH
5078: DOUBLE
5079: LD_INT 1
5081: DEC
5082: ST_TO_ADDR
5083: LD_INT 4
5085: PUSH
5086: FOR_TO
5087: IFFALSE 5143
// begin uc_nation := 0 ;
5089: LD_ADDR_OWVAR 21
5093: PUSH
5094: LD_INT 0
5096: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5097: LD_INT 0
5099: PPUSH
5100: LD_INT 16
5102: PPUSH
5103: LD_INT 1
5105: PPUSH
5106: CALL_OW 380
// un := CreateHuman ;
5110: LD_ADDR_VAR 0 6
5114: PUSH
5115: CALL_OW 44
5119: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5120: LD_VAR 0 6
5124: PPUSH
5125: LD_INT 106
5127: PPUSH
5128: LD_INT 46
5130: PPUSH
5131: LD_INT 8
5133: PPUSH
5134: LD_INT 0
5136: PPUSH
5137: CALL_OW 50
// end ;
5141: GO 5086
5143: POP
5144: POP
// for i = 1 to 2 * Difficulty do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 2
5157: PUSH
5158: LD_OWVAR 67
5162: MUL
5163: PUSH
5164: FOR_TO
5165: IFFALSE 5205
// begin uc_nation := 0 ;
5167: LD_ADDR_OWVAR 21
5171: PUSH
5172: LD_INT 0
5174: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5175: LD_INT 0
5177: PPUSH
5178: LD_INT 15
5180: PPUSH
5181: LD_INT 3
5183: PPUSH
5184: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5188: CALL_OW 44
5192: PPUSH
5193: LD_INT 20
5195: PPUSH
5196: LD_INT 0
5198: PPUSH
5199: CALL_OW 49
// end ;
5203: GO 5164
5205: POP
5206: POP
// for i = 1 to 4 * Difficulty do
5207: LD_ADDR_VAR 0 2
5211: PUSH
5212: DOUBLE
5213: LD_INT 1
5215: DEC
5216: ST_TO_ADDR
5217: LD_INT 4
5219: PUSH
5220: LD_OWVAR 67
5224: MUL
5225: PUSH
5226: FOR_TO
5227: IFFALSE 5301
// begin uc_nation := 0 ;
5229: LD_ADDR_OWVAR 21
5233: PUSH
5234: LD_INT 0
5236: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5237: LD_INT 0
5239: PPUSH
5240: LD_INT 17
5242: PPUSH
5243: LD_INT 3
5245: PPUSH
5246: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5250: LD_ADDR_OWVAR 29
5254: PUSH
5255: LD_INT 11
5257: PUSH
5258: LD_INT 13
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: ST_TO_ADDR
// un := CreateHuman ;
5265: LD_ADDR_VAR 0 6
5269: PUSH
5270: CALL_OW 44
5274: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5275: LD_VAR 0 6
5279: PPUSH
5280: LD_INT 21
5282: PPUSH
5283: LD_INT 0
5285: PPUSH
5286: CALL_OW 49
// ComHold ( un ) ;
5290: LD_VAR 0 6
5294: PPUSH
5295: CALL_OW 140
// end ;
5299: GO 5226
5301: POP
5302: POP
// end ;
5303: LD_VAR 0 1
5307: RET
// every 12 12$00 + 2 2$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5308: LD_INT 22
5310: PUSH
5311: LD_EXP 8
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PUSH
5320: LD_INT 30
5322: PUSH
5323: LD_INT 3
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: PPUSH
5334: CALL_OW 69
5338: IFFALSE 5645
5340: GO 5342
5342: DISABLE
5343: LD_INT 0
5345: PPUSH
5346: PPUSH
5347: PPUSH
// begin enable ;
5348: ENABLE
// if Difficulty < 3 then
5349: LD_OWVAR 67
5353: PUSH
5354: LD_INT 3
5356: LESS
5357: IFFALSE 5366
// wait ( 1 1$00 ) ;
5359: LD_INT 2100
5361: PPUSH
5362: CALL_OW 67
// tmp := queue_codes [ rng ] ;
5366: LD_ADDR_VAR 0 2
5370: PUSH
5371: LD_EXP 23
5375: PUSH
5376: LD_EXP 24
5380: ARRAY
5381: ST_TO_ADDR
// p := 1 ;
5382: LD_ADDR_VAR 0 3
5386: PUSH
5387: LD_INT 1
5389: ST_TO_ADDR
// for i = 1 to veh_counter + [ - 1 , 0 , 1 ] [ Difficulty ] do
5390: LD_ADDR_VAR 0 1
5394: PUSH
5395: DOUBLE
5396: LD_INT 1
5398: DEC
5399: ST_TO_ADDR
5400: LD_EXP 22
5404: PUSH
5405: LD_INT 1
5407: NEG
5408: PUSH
5409: LD_INT 0
5411: PUSH
5412: LD_INT 1
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: PUSH
5420: LD_OWVAR 67
5424: ARRAY
5425: PLUS
5426: PUSH
5427: FOR_TO
5428: IFFALSE 5609
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5430: LD_INT 22
5432: PUSH
5433: LD_EXP 8
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: LD_INT 30
5444: PUSH
5445: LD_INT 3
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: PPUSH
5456: CALL_OW 69
5460: PUSH
5461: LD_INT 1
5463: ARRAY
5464: PPUSH
5465: LD_EXP 21
5469: PUSH
5470: LD_VAR 0 2
5474: PUSH
5475: LD_INT 10
5477: MOD
5478: ARRAY
5479: PUSH
5480: LD_INT 1
5482: ARRAY
5483: PPUSH
5484: LD_EXP 21
5488: PUSH
5489: LD_VAR 0 2
5493: PUSH
5494: LD_INT 10
5496: MOD
5497: ARRAY
5498: PUSH
5499: LD_INT 2
5501: ARRAY
5502: PPUSH
5503: LD_EXP 21
5507: PUSH
5508: LD_VAR 0 2
5512: PUSH
5513: LD_INT 10
5515: MOD
5516: ARRAY
5517: PUSH
5518: LD_INT 3
5520: ARRAY
5521: PPUSH
5522: LD_EXP 21
5526: PUSH
5527: LD_VAR 0 2
5531: PUSH
5532: LD_INT 10
5534: MOD
5535: ARRAY
5536: PUSH
5537: LD_INT 4
5539: ARRAY
5540: PPUSH
5541: CALL_OW 185
// tmp := tmp / 10 ;
5545: LD_ADDR_VAR 0 2
5549: PUSH
5550: LD_VAR 0 2
5554: PUSH
5555: LD_INT 10
5557: DIVREAL
5558: ST_TO_ADDR
// p := p + 1 ;
5559: LD_ADDR_VAR 0 3
5563: PUSH
5564: LD_VAR 0 3
5568: PUSH
5569: LD_INT 1
5571: PLUS
5572: ST_TO_ADDR
// if p > 5 then
5573: LD_VAR 0 3
5577: PUSH
5578: LD_INT 5
5580: GREATER
5581: IFFALSE 5607
// begin p := 1 ;
5583: LD_ADDR_VAR 0 3
5587: PUSH
5588: LD_INT 1
5590: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5591: LD_ADDR_VAR 0 2
5595: PUSH
5596: LD_EXP 23
5600: PUSH
5601: LD_EXP 24
5605: ARRAY
5606: ST_TO_ADDR
// end ; end ;
5607: GO 5427
5609: POP
5610: POP
// rng := rng + 1 ;
5611: LD_ADDR_EXP 24
5615: PUSH
5616: LD_EXP 24
5620: PUSH
5621: LD_INT 1
5623: PLUS
5624: ST_TO_ADDR
// if rng > queue_codes then
5625: LD_EXP 24
5629: PUSH
5630: LD_EXP 23
5634: GREATER
5635: IFFALSE 5645
// rng := 1 ;
5637: LD_ADDR_EXP 24
5641: PUSH
5642: LD_INT 1
5644: ST_TO_ADDR
// end ;
5645: PPOPN 3
5647: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5648: LD_INT 25
5650: PUSH
5651: LD_INT 17
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PPUSH
5658: CALL_OW 69
5662: IFFALSE 5765
5664: GO 5666
5666: DISABLE
5667: LD_INT 0
5669: PPUSH
5670: PPUSH
// begin enable ;
5671: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5672: LD_ADDR_VAR 0 1
5676: PUSH
5677: LD_INT 25
5679: PUSH
5680: LD_INT 17
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PPUSH
5687: CALL_OW 69
5691: PUSH
5692: FOR_IN
5693: IFFALSE 5763
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5695: LD_ADDR_VAR 0 2
5699: PUSH
5700: LD_INT 81
5702: PUSH
5703: LD_EXP 8
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL_OW 69
5716: PPUSH
5717: LD_VAR 0 1
5721: PPUSH
5722: CALL_OW 74
5726: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5727: LD_VAR 0 1
5731: PPUSH
5732: LD_VAR 0 2
5736: PPUSH
5737: CALL_OW 296
5741: PUSH
5742: LD_INT 15
5744: LESS
5745: IFFALSE 5761
// ComAttackUnit ( i , un ) ;
5747: LD_VAR 0 1
5751: PPUSH
5752: LD_VAR 0 2
5756: PPUSH
5757: CALL_OW 115
// end ;
5761: GO 5692
5763: POP
5764: POP
// end ;
5765: PPOPN 2
5767: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5768: LD_EXP 20
5772: IFFALSE 5839
5774: GO 5776
5776: DISABLE
5777: LD_INT 0
5779: PPUSH
// begin enable ;
5780: ENABLE
// for i in attackers do
5781: LD_ADDR_VAR 0 1
5785: PUSH
5786: LD_EXP 20
5790: PUSH
5791: FOR_IN
5792: IFFALSE 5837
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
5794: LD_VAR 0 1
5798: PPUSH
5799: LD_INT 81
5801: PUSH
5802: LD_VAR 0 1
5806: PPUSH
5807: CALL_OW 255
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 69
5820: PPUSH
5821: LD_VAR 0 1
5825: PPUSH
5826: CALL_OW 74
5830: PPUSH
5831: CALL_OW 115
5835: GO 5791
5837: POP
5838: POP
// end ;
5839: PPOPN 1
5841: END
// every 0 0$01 trigger not attackers marked 17 do
5842: LD_EXP 20
5846: NOT
5847: IFFALSE 5856
5849: GO 5851
5851: DISABLE
// begin enable ;
5852: ENABLE
// disable ( 17 ) ;
5853: LD_INT 17
5855: DISABLE_MARKED
// end ;
5856: END
// every 1 1$00 trigger veh_counter <= attackers do var max , i ;
5857: LD_EXP 22
5861: PUSH
5862: LD_EXP 20
5866: LESSEQUAL
5867: IFFALSE 5880
5869: GO 5871
5871: DISABLE
5872: LD_INT 0
5874: PPUSH
5875: PPUSH
// begin enable ;
5876: ENABLE
// enable ( 17 ) ;
5877: LD_INT 17
5879: ENABLE_MARKED
// end ;
5880: PPOPN 2
5882: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5883: LD_EXP 9
5887: PUSH
5888: LD_OWVAR 1
5892: PUSH
5893: LD_INT 63000
5895: GREATEREQUAL
5896: AND
5897: IFFALSE 5916
5899: GO 5901
5901: DISABLE
// begin veh_counter := veh_counter + 1 ;
5902: LD_ADDR_EXP 22
5906: PUSH
5907: LD_EXP 22
5911: PUSH
5912: LD_INT 1
5914: PLUS
5915: ST_TO_ADDR
// end ;
5916: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
5917: LD_EXP 9
5921: PUSH
5922: LD_OWVAR 1
5926: PUSH
5927: LD_INT 105000
5929: GREATEREQUAL
5930: AND
5931: IFFALSE 5950
5933: GO 5935
5935: DISABLE
// begin veh_counter := veh_counter + 2 ;
5936: LD_ADDR_EXP 22
5940: PUSH
5941: LD_EXP 22
5945: PUSH
5946: LD_INT 2
5948: PLUS
5949: ST_TO_ADDR
// end ;
5950: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
5951: LD_EXP 9
5955: PUSH
5956: LD_OWVAR 1
5960: PUSH
5961: LD_INT 168000
5963: GREATEREQUAL
5964: AND
5965: IFFALSE 5984
5967: GO 5969
5969: DISABLE
// begin veh_counter := veh_counter + 3 ;
5970: LD_ADDR_EXP 22
5974: PUSH
5975: LD_EXP 22
5979: PUSH
5980: LD_INT 3
5982: PLUS
5983: ST_TO_ADDR
// end ;
5984: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
5985: LD_INT 22
5987: PUSH
5988: LD_EXP 8
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 33
5999: PUSH
6000: LD_INT 2
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 69
6015: IFFALSE 6231
6017: GO 6019
6019: DISABLE
6020: LD_INT 0
6022: PPUSH
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
6027: PPUSH
6028: PPUSH
// begin enable ;
6029: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6030: LD_ADDR_VAR 0 4
6034: PUSH
6035: LD_INT 22
6037: PUSH
6038: LD_EXP 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 33
6049: PUSH
6050: LD_INT 2
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: PUSH
6057: LD_INT 3
6059: PUSH
6060: LD_INT 61
6062: PUSH
6063: EMPTY
6064: LIST
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 69
6079: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 22
6087: PUSH
6088: LD_EXP 8
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 34
6099: PUSH
6100: LD_INT 31
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PPUSH
6111: CALL_OW 69
6115: ST_TO_ADDR
// best := 10 ;
6116: LD_ADDR_VAR 0 5
6120: PUSH
6121: LD_INT 10
6123: ST_TO_ADDR
// best_mechanic := - 1 ;
6124: LD_ADDR_VAR 0 6
6128: PUSH
6129: LD_INT 1
6131: NEG
6132: ST_TO_ADDR
// if vehs then
6133: LD_VAR 0 4
6137: IFFALSE 6231
// begin for j in cts do
6139: LD_ADDR_VAR 0 2
6143: PUSH
6144: LD_VAR 0 3
6148: PUSH
6149: FOR_IN
6150: IFFALSE 6211
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6152: LD_ADDR_VAR 0 7
6156: PUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL 3453 0 1
6166: PPUSH
6167: CALL_OW 432
6171: ST_TO_ADDR
// if p < best then
6172: LD_VAR 0 7
6176: PUSH
6177: LD_VAR 0 5
6181: LESS
6182: IFFALSE 6209
// begin best := p ;
6184: LD_ADDR_VAR 0 5
6188: PUSH
6189: LD_VAR 0 7
6193: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6194: LD_ADDR_VAR 0 6
6198: PUSH
6199: LD_VAR 0 2
6203: PPUSH
6204: CALL 3453 0 1
6208: ST_TO_ADDR
// end ; end ;
6209: GO 6149
6211: POP
6212: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6213: LD_VAR 0 4
6217: PUSH
6218: LD_INT 1
6220: ARRAY
6221: PPUSH
6222: LD_VAR 0 6
6226: PPUSH
6227: CALL_OW 135
// end ; end ;
6231: PPOPN 7
6233: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6234: GO 6236
6236: DISABLE
6237: LD_INT 0
6239: PPUSH
6240: PPUSH
6241: PPUSH
6242: PPUSH
6243: PPUSH
6244: PPUSH
6245: PPUSH
// begin enable ;
6246: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6247: LD_ADDR_VAR 0 6
6251: PUSH
6252: LD_INT 22
6254: PUSH
6255: LD_EXP 8
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 21
6266: PUSH
6267: LD_INT 3
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: PUSH
6274: LD_INT 3
6276: PUSH
6277: LD_INT 24
6279: PUSH
6280: LD_INT 1000
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PUSH
6287: EMPTY
6288: LIST
6289: LIST
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL_OW 69
6300: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6301: LD_ADDR_VAR 0 3
6305: PUSH
6306: LD_INT 22
6308: PUSH
6309: LD_EXP 8
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 2
6320: PUSH
6321: LD_INT 25
6323: PUSH
6324: LD_INT 1
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 25
6333: PUSH
6334: LD_INT 2
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 25
6343: PUSH
6344: LD_INT 3
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 3
6359: PUSH
6360: LD_INT 24
6362: PUSH
6363: LD_INT 750
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PPUSH
6379: CALL_OW 69
6383: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_EXP 8
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PUSH
6401: LD_INT 25
6403: PUSH
6404: LD_INT 4
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: PPUSH
6415: CALL_OW 69
6419: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6420: LD_ADDR_VAR 0 5
6424: PUSH
6425: LD_INT 22
6427: PUSH
6428: LD_EXP 8
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: LD_INT 2
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PPUSH
6451: CALL_OW 69
6455: ST_TO_ADDR
// if not h and not b then
6456: LD_VAR 0 3
6460: NOT
6461: PUSH
6462: LD_VAR 0 6
6466: NOT
6467: AND
6468: IFFALSE 6752
// begin if sci then
6470: LD_VAR 0 4
6474: IFFALSE 6611
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6476: LD_VAR 0 4
6480: PPUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 54
6486: PUSH
6487: EMPTY
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PPUSH
6494: CALL_OW 72
6498: PUSH
6499: LD_INT 22
6501: PUSH
6502: LD_EXP 8
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: LD_INT 30
6513: PUSH
6514: LD_INT 8
6516: PUSH
6517: EMPTY
6518: LIST
6519: LIST
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PPUSH
6525: CALL_OW 69
6529: AND
6530: IFFALSE 6611
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6532: LD_ADDR_VAR 0 2
6536: PUSH
6537: LD_VAR 0 4
6541: PPUSH
6542: LD_INT 3
6544: PUSH
6545: LD_INT 54
6547: PUSH
6548: EMPTY
6549: LIST
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: PPUSH
6555: CALL_OW 72
6559: PUSH
6560: FOR_IN
6561: IFFALSE 6609
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6563: LD_VAR 0 2
6567: PPUSH
6568: LD_INT 22
6570: PUSH
6571: LD_EXP 8
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 30
6582: PUSH
6583: LD_INT 8
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PPUSH
6594: CALL_OW 69
6598: PUSH
6599: LD_INT 1
6601: ARRAY
6602: PPUSH
6603: CALL_OW 120
6607: GO 6560
6609: POP
6610: POP
// if eng then
6611: LD_VAR 0 5
6615: IFFALSE 6752
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6617: LD_VAR 0 5
6621: PPUSH
6622: LD_INT 3
6624: PUSH
6625: LD_INT 54
6627: PUSH
6628: EMPTY
6629: LIST
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PPUSH
6635: CALL_OW 72
6639: PUSH
6640: LD_INT 22
6642: PUSH
6643: LD_EXP 8
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 30
6654: PUSH
6655: LD_INT 1
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PPUSH
6666: CALL_OW 69
6670: AND
6671: IFFALSE 6752
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_VAR 0 5
6682: PPUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 54
6688: PUSH
6689: EMPTY
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PPUSH
6696: CALL_OW 72
6700: PUSH
6701: FOR_IN
6702: IFFALSE 6750
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6704: LD_VAR 0 2
6708: PPUSH
6709: LD_INT 22
6711: PUSH
6712: LD_EXP 8
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 30
6723: PUSH
6724: LD_INT 1
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 69
6739: PUSH
6740: LD_INT 1
6742: ARRAY
6743: PPUSH
6744: CALL_OW 120
6748: GO 6701
6750: POP
6751: POP
// end ; p := 1 ;
6752: LD_ADDR_VAR 0 7
6756: PUSH
6757: LD_INT 1
6759: ST_TO_ADDR
// if b and eng then
6760: LD_VAR 0 6
6764: PUSH
6765: LD_VAR 0 5
6769: AND
6770: IFFALSE 6904
// for j in eng do
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_VAR 0 5
6781: PUSH
6782: FOR_IN
6783: IFFALSE 6902
// begin if IsInUnit ( j ) then
6785: LD_VAR 0 2
6789: PPUSH
6790: CALL_OW 310
6794: IFFALSE 6807
// ComExitBuilding ( j ) else
6796: LD_VAR 0 2
6800: PPUSH
6801: CALL_OW 122
6805: GO 6900
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6807: LD_VAR 0 2
6811: PPUSH
6812: CALL_OW 314
6816: NOT
6817: PUSH
6818: LD_VAR 0 2
6822: PPUSH
6823: CALL_OW 256
6827: PUSH
6828: LD_INT 750
6830: GREATER
6831: AND
6832: IFFALSE 6900
// begin if b > p then
6834: LD_VAR 0 6
6838: PUSH
6839: LD_VAR 0 7
6843: GREATER
6844: IFFALSE 6882
// begin ComRepairBuilding ( j , b [ p ] ) ;
6846: LD_VAR 0 2
6850: PPUSH
6851: LD_VAR 0 6
6855: PUSH
6856: LD_VAR 0 7
6860: ARRAY
6861: PPUSH
6862: CALL_OW 130
// p := p + 1 ;
6866: LD_ADDR_VAR 0 7
6870: PUSH
6871: LD_VAR 0 7
6875: PUSH
6876: LD_INT 1
6878: PLUS
6879: ST_TO_ADDR
// end else
6880: GO 6900
// ComRepairBuilding ( j , b [ 1 ] ) ;
6882: LD_VAR 0 2
6886: PPUSH
6887: LD_VAR 0 6
6891: PUSH
6892: LD_INT 1
6894: ARRAY
6895: PPUSH
6896: CALL_OW 130
// end ; end ;
6900: GO 6782
6902: POP
6903: POP
// if h and sci then
6904: LD_VAR 0 3
6908: PUSH
6909: LD_VAR 0 4
6913: AND
6914: IFFALSE 7053
// for i in h do
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_VAR 0 3
6925: PUSH
6926: FOR_IN
6927: IFFALSE 7051
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_INT 108
6936: PPUSH
6937: LD_INT 42
6939: PPUSH
6940: CALL_OW 297
6944: PUSH
6945: LD_INT 10
6947: GREATER
6948: IFFALSE 6967
// ComMoveXY ( i , 108 , 42 ) else
6950: LD_VAR 0 1
6954: PPUSH
6955: LD_INT 108
6957: PPUSH
6958: LD_INT 42
6960: PPUSH
6961: CALL_OW 111
6965: GO 7049
// begin for j in sci do
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 4
6976: PUSH
6977: FOR_IN
6978: IFFALSE 7047
// begin if GetTag ( j ) > 0 then
6980: LD_VAR 0 2
6984: PPUSH
6985: CALL_OW 110
6989: PUSH
6990: LD_INT 0
6992: GREATER
6993: IFFALSE 6997
// continue ;
6995: GO 6977
// if IsInUnit ( j ) then
6997: LD_VAR 0 2
7001: PPUSH
7002: CALL_OW 310
7006: IFFALSE 7019
// ComExitBuilding ( j ) else
7008: LD_VAR 0 2
7012: PPUSH
7013: CALL_OW 122
7017: GO 7045
// if not HasTask ( j ) then
7019: LD_VAR 0 2
7023: PPUSH
7024: CALL_OW 314
7028: NOT
7029: IFFALSE 7045
// ComHeal ( j , h ) ;
7031: LD_VAR 0 2
7035: PPUSH
7036: LD_VAR 0 3
7040: PPUSH
7041: CALL_OW 128
// end ;
7045: GO 6977
7047: POP
7048: POP
// end ;
7049: GO 6926
7051: POP
7052: POP
// end ;
7053: PPOPN 7
7055: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7056: LD_INT 155
7058: PPUSH
7059: LD_INT 88
7061: PPUSH
7062: CALL_OW 428
7066: PUSH
7067: LD_INT 155
7069: PPUSH
7070: LD_INT 88
7072: PPUSH
7073: CALL_OW 428
7077: PUSH
7078: LD_INT 30
7080: EQUAL
7081: PPUSH
7082: CALL_OW 266
7086: AND
7087: IFFALSE 7336
7089: GO 7091
7091: DISABLE
7092: LD_INT 0
7094: PPUSH
7095: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7096: LD_ADDR_VAR 0 2
7100: PUSH
7101: LD_INT 155
7103: PPUSH
7104: LD_INT 88
7106: PPUSH
7107: CALL_OW 428
7111: PPUSH
7112: CALL_OW 255
7116: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7117: LD_INT 11550
7119: PUSH
7120: LD_INT 13755
7122: PUSH
7123: LD_INT 13335
7125: PUSH
7126: LD_INT 18340
7128: PUSH
7129: LD_INT 19985
7131: PUSH
7132: LD_INT 9555
7134: PUSH
7135: LD_INT 18935
7137: PUSH
7138: LD_INT 10535
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: PUSH
7151: LD_VAR 0 2
7155: ARRAY
7156: PPUSH
7157: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7161: LD_INT 22
7163: PUSH
7164: LD_EXP 8
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 25
7175: PUSH
7176: LD_INT 4
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 69
7191: PUSH
7192: LD_INT 0
7194: EQUAL
7195: IFFALSE 7199
// exit ;
7197: GO 7336
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7199: LD_ADDR_VAR 0 1
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_EXP 8
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: LD_INT 25
7218: PUSH
7219: LD_INT 4
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: PPUSH
7230: CALL_OW 69
7234: PUSH
7235: LD_INT 1
7237: ARRAY
7238: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7239: LD_VAR 0 1
7243: PPUSH
7244: LD_INT 1
7246: PPUSH
7247: CALL_OW 109
// ComExitBuilding ( sci ) ;
7251: LD_VAR 0 1
7255: PPUSH
7256: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7260: LD_VAR 0 1
7264: PPUSH
7265: LD_INT 126
7267: PPUSH
7268: LD_INT 59
7270: PPUSH
7271: CALL_OW 171
// if p mod 2 = 0 then
7275: LD_VAR 0 2
7279: PUSH
7280: LD_INT 2
7282: MOD
7283: PUSH
7284: LD_INT 0
7286: EQUAL
7287: IFFALSE 7306
// AddComMoveXY ( sci , 148 , 66 ) else
7289: LD_VAR 0 1
7293: PPUSH
7294: LD_INT 148
7296: PPUSH
7297: LD_INT 66
7299: PPUSH
7300: CALL_OW 171
7304: GO 7321
// AddComMoveXY ( sci , 135 , 84 ) ;
7306: LD_VAR 0 1
7310: PPUSH
7311: LD_INT 135
7313: PPUSH
7314: LD_INT 84
7316: PPUSH
7317: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7321: LD_VAR 0 1
7325: PPUSH
7326: LD_INT 155
7328: PPUSH
7329: LD_INT 88
7331: PPUSH
7332: CALL_OW 218
// end ;
7336: PPOPN 2
7338: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7339: LD_INT 33
7341: PPUSH
7342: LD_INT 10
7344: PPUSH
7345: CALL_OW 428
7349: PUSH
7350: LD_INT 33
7352: PPUSH
7353: LD_INT 10
7355: PPUSH
7356: CALL_OW 428
7360: PUSH
7361: LD_INT 30
7363: EQUAL
7364: PPUSH
7365: CALL_OW 266
7369: AND
7370: IFFALSE 7621
7372: GO 7374
7374: DISABLE
7375: LD_INT 0
7377: PPUSH
7378: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7379: LD_ADDR_VAR 0 2
7383: PUSH
7384: LD_INT 33
7386: PPUSH
7387: LD_INT 10
7389: PPUSH
7390: CALL_OW 428
7394: PPUSH
7395: CALL_OW 255
7399: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7400: LD_INT 9450
7402: PUSH
7403: LD_INT 11655
7405: PUSH
7406: LD_INT 7035
7408: PUSH
7409: LD_INT 9940
7411: PUSH
7412: LD_INT 7385
7414: PUSH
7415: LD_INT 11655
7417: PUSH
7418: LD_INT 6335
7420: PUSH
7421: LD_INT 16835
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: LD_VAR 0 2
7438: ARRAY
7439: PPUSH
7440: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7444: LD_INT 22
7446: PUSH
7447: LD_EXP 8
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 25
7458: PUSH
7459: LD_INT 4
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: LD_INT 0
7477: EQUAL
7478: IFFALSE 7482
// exit ;
7480: GO 7621
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_EXP 8
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 25
7501: PUSH
7502: LD_INT 4
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PPUSH
7513: CALL_OW 69
7517: PUSH
7518: LD_VAR 0 1
7522: ARRAY
7523: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7524: LD_VAR 0 1
7528: PPUSH
7529: LD_INT 1
7531: PPUSH
7532: CALL_OW 109
// ComExitBuilding ( sci ) ;
7536: LD_VAR 0 1
7540: PPUSH
7541: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7545: LD_VAR 0 1
7549: PPUSH
7550: LD_INT 67
7552: PPUSH
7553: LD_INT 13
7555: PPUSH
7556: CALL_OW 171
// if p mod 2 = 0 then
7560: LD_VAR 0 2
7564: PUSH
7565: LD_INT 2
7567: MOD
7568: PUSH
7569: LD_INT 0
7571: EQUAL
7572: IFFALSE 7591
// AddComMoveXY ( sci , 37 , 3 ) else
7574: LD_VAR 0 1
7578: PPUSH
7579: LD_INT 37
7581: PPUSH
7582: LD_INT 3
7584: PPUSH
7585: CALL_OW 171
7589: GO 7606
// AddComMoveXY ( sci , 45 , 20 ) ;
7591: LD_VAR 0 1
7595: PPUSH
7596: LD_INT 45
7598: PPUSH
7599: LD_INT 20
7601: PPUSH
7602: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7606: LD_VAR 0 1
7610: PPUSH
7611: LD_INT 33
7613: PPUSH
7614: LD_INT 10
7616: PPUSH
7617: CALL_OW 218
// end ;
7621: PPOPN 2
7623: END
// every 0 0$01 trigger mines_list do var i , p ;
7624: LD_EXP 17
7628: IFFALSE 7854
7630: GO 7632
7632: DISABLE
7633: LD_INT 0
7635: PPUSH
7636: PPUSH
// begin enable ;
7637: ENABLE
// p := 1 ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 1
7645: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7646: LD_ADDR_VAR 0 1
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_EXP 17
7660: PUSH
7661: LD_INT 2
7663: DIVREAL
7664: PUSH
7665: FOR_TO
7666: IFFALSE 7852
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7668: LD_EXP 17
7672: PUSH
7673: LD_VAR 0 2
7677: ARRAY
7678: PPUSH
7679: LD_EXP 17
7683: PUSH
7684: LD_VAR 0 2
7688: PUSH
7689: LD_INT 1
7691: PLUS
7692: ARRAY
7693: PPUSH
7694: CALL_OW 428
7698: PUSH
7699: LD_INT 0
7701: GREATER
7702: IFFALSE 7836
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7704: LD_EXP 17
7708: PUSH
7709: LD_VAR 0 2
7713: ARRAY
7714: PPUSH
7715: LD_EXP 17
7719: PUSH
7720: LD_VAR 0 2
7724: PUSH
7725: LD_INT 1
7727: PLUS
7728: ARRAY
7729: PPUSH
7730: CALL_OW 428
7734: PPUSH
7735: CALL_OW 255
7739: PUSH
7740: LD_EXP 8
7744: NONEQUAL
7745: IFFALSE 7836
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7747: LD_EXP 17
7751: PUSH
7752: LD_VAR 0 2
7756: ARRAY
7757: PPUSH
7758: LD_EXP 17
7762: PUSH
7763: LD_VAR 0 2
7767: PUSH
7768: LD_INT 1
7770: PLUS
7771: ARRAY
7772: PPUSH
7773: LD_EXP 8
7777: PPUSH
7778: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7782: LD_ADDR_EXP 17
7786: PUSH
7787: LD_EXP 17
7791: PPUSH
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 3
7801: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7802: LD_ADDR_EXP 17
7806: PUSH
7807: LD_EXP 17
7811: PPUSH
7812: LD_VAR 0 2
7816: PPUSH
7817: CALL_OW 3
7821: ST_TO_ADDR
// p := p - 2 ;
7822: LD_ADDR_VAR 0 2
7826: PUSH
7827: LD_VAR 0 2
7831: PUSH
7832: LD_INT 2
7834: MINUS
7835: ST_TO_ADDR
// end ; p := p + 2 ;
7836: LD_ADDR_VAR 0 2
7840: PUSH
7841: LD_VAR 0 2
7845: PUSH
7846: LD_INT 2
7848: PLUS
7849: ST_TO_ADDR
// end ;
7850: GO 7665
7852: POP
7853: POP
// end ;
7854: PPOPN 2
7856: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7857: GO 7859
7859: DISABLE
7860: LD_INT 0
7862: PPUSH
7863: PPUSH
7864: PPUSH
7865: PPUSH
7866: PPUSH
// begin enable ;
7867: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 50
7875: PUSH
7876: EMPTY
7877: LIST
7878: PUSH
7879: LD_INT 22
7881: PUSH
7882: LD_EXP 8
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: PUSH
7891: LD_INT 25
7893: PUSH
7894: LD_INT 16
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL_OW 69
7910: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7911: LD_ADDR_VAR 0 5
7915: PUSH
7916: LD_INT 22
7918: PUSH
7919: LD_EXP 8
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: LD_INT 2
7930: PUSH
7931: LD_INT 30
7933: PUSH
7934: LD_INT 0
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 30
7943: PUSH
7944: LD_INT 1
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 69
7964: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
7965: LD_ADDR_VAR 0 3
7969: PUSH
7970: LD_INT 13
7972: PPUSH
7973: CALL_OW 435
7977: ST_TO_ADDR
// if filter and skr then
7978: LD_VAR 0 4
7982: PUSH
7983: LD_VAR 0 3
7987: AND
7988: IFFALSE 8063
// for i = 1 to filter do
7990: LD_ADDR_VAR 0 1
7994: PUSH
7995: DOUBLE
7996: LD_INT 1
7998: DEC
7999: ST_TO_ADDR
8000: LD_VAR 0 4
8004: PUSH
8005: FOR_TO
8006: IFFALSE 8061
// if not HasTask ( filter [ i ] ) then
8008: LD_VAR 0 4
8012: PUSH
8013: LD_VAR 0 1
8017: ARRAY
8018: PPUSH
8019: CALL_OW 314
8023: NOT
8024: IFFALSE 8059
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8026: LD_VAR 0 4
8030: PUSH
8031: LD_VAR 0 1
8035: ARRAY
8036: PPUSH
8037: LD_VAR 0 3
8041: PUSH
8042: LD_INT 1
8044: ARRAY
8045: PPUSH
8046: LD_VAR 0 3
8050: PUSH
8051: LD_INT 2
8053: ARRAY
8054: PPUSH
8055: CALL_OW 117
8059: GO 8005
8061: POP
8062: POP
// end ; end_of_file
8063: PPOPN 5
8065: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8066: LD_INT 0
8068: PPUSH
8069: PPUSH
8070: PPUSH
8071: PPUSH
// begin if un in attackers then
8072: LD_VAR 0 1
8076: PUSH
8077: LD_EXP 20
8081: IN
8082: IFFALSE 8100
// attackers := attackers diff un ;
8084: LD_ADDR_EXP 20
8088: PUSH
8089: LD_EXP 20
8093: PUSH
8094: LD_VAR 0 1
8098: DIFF
8099: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 255
8109: PUSH
8110: LD_EXP 8
8114: NONEQUAL
8115: PUSH
8116: LD_VAR 0 1
8120: PPUSH
8121: CALL_OW 255
8125: PUSH
8126: LD_INT 0
8128: GREATER
8129: AND
8130: PUSH
8131: LD_VAR 0 1
8135: PUSH
8136: LD_INT 21
8138: PUSH
8139: LD_INT 1
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PPUSH
8146: CALL_OW 69
8150: IN
8151: AND
8152: IFFALSE 8336
// begin if respawning_time_min > 0 0$00 then
8154: LD_EXP 13
8158: PUSH
8159: LD_INT 0
8161: GREATER
8162: IFFALSE 8336
// begin s := GetSide ( un ) ;
8164: LD_ADDR_VAR 0 4
8168: PUSH
8169: LD_VAR 0 1
8173: PPUSH
8174: CALL_OW 255
8178: ST_TO_ADDR
// n := GetNation ( un ) ;
8179: LD_ADDR_VAR 0 5
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 248
8193: ST_TO_ADDR
// cl := GetClass ( un ) ;
8194: LD_ADDR_VAR 0 3
8198: PUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: CALL_OW 257
8208: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8209: LD_EXP 13
8213: PPUSH
8214: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) * cl ) ;
8218: LD_EXP 14
8222: PUSH
8223: LD_INT 350
8225: PUSH
8226: LD_OWVAR 1
8230: MUL
8231: PUSH
8232: LD_INT 10
8234: MOD
8235: PUSH
8236: LD_INT 1
8238: PLUS
8239: PUSH
8240: LD_VAR 0 3
8244: MUL
8245: MINUS
8246: PPUSH
8247: CALL_OW 67
// uc_side := s ;
8251: LD_ADDR_OWVAR 20
8255: PUSH
8256: LD_VAR 0 4
8260: ST_TO_ADDR
// uc_nation := n ;
8261: LD_ADDR_OWVAR 21
8265: PUSH
8266: LD_VAR 0 5
8270: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8271: LD_INT 0
8273: PPUSH
8274: LD_VAR 0 3
8278: PPUSH
8279: LD_EXP 11
8283: PUSH
8284: LD_INT 2
8286: MINUS
8287: PPUSH
8288: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8292: CALL_OW 44
8296: PPUSH
8297: LD_INT 17
8299: PUSH
8300: LD_INT 19
8302: PUSH
8303: LD_INT 18
8305: PUSH
8306: LD_INT 19
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: LD_VAR 0 3
8319: PUSH
8320: LD_INT 4
8322: MOD
8323: PUSH
8324: LD_INT 1
8326: PLUS
8327: ARRAY
8328: PPUSH
8329: LD_INT 1
8331: PPUSH
8332: CALL_OW 49
// end ; end ; end ;
8336: PPOPN 5
8338: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 255
8348: PUSH
8349: LD_EXP 8
8353: EQUAL
8354: PUSH
8355: LD_VAR 0 1
8359: PUSH
8360: LD_INT 33
8362: PUSH
8363: LD_INT 2
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: PUSH
8370: LD_INT 21
8372: PUSH
8373: LD_INT 2
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: IN
8389: AND
8390: IFFALSE 8513
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
8392: LD_OWVAR 3
8396: PUSH
8397: LD_VAR 0 1
8401: DIFF
8402: PPUSH
8403: LD_VAR 0 1
8407: PPUSH
8408: CALL_OW 74
8412: PPUSH
8413: CALL_OW 255
8417: PUSH
8418: LD_EXP 8
8422: NONEQUAL
8423: IFFALSE 8513
// begin Wait ( 0 0$1.3 ) ;
8425: LD_INT 46
8427: PPUSH
8428: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8432: LD_VAR 0 1
8436: PPUSH
8437: CALL_OW 250
8441: PPUSH
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL_OW 251
8451: PPUSH
8452: LD_INT 1
8454: PPUSH
8455: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8459: LD_VAR 0 1
8463: PPUSH
8464: CALL_OW 250
8468: PPUSH
8469: LD_VAR 0 1
8473: PPUSH
8474: CALL_OW 251
8478: PPUSH
8479: LD_INT 1
8481: PPUSH
8482: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8486: LD_VAR 0 1
8490: PPUSH
8491: CALL_OW 250
8495: PPUSH
8496: LD_VAR 0 1
8500: PPUSH
8501: CALL_OW 251
8505: PPUSH
8506: LD_INT 1
8508: PPUSH
8509: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 263
8522: PUSH
8523: LD_INT 2
8525: EQUAL
8526: IFFALSE 8537
// ComUnlink ( un ) ;
8528: LD_VAR 0 1
8532: PPUSH
8533: CALL_OW 136
// end ;
8537: PPOPN 1
8539: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8540: LD_VAR 0 1
8544: PPUSH
8545: CALL_OW 255
8549: PUSH
8550: LD_EXP 8
8554: EQUAL
8555: IFFALSE 8586
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8557: LD_ADDR_EXP 20
8561: PUSH
8562: LD_EXP 20
8566: PPUSH
8567: LD_EXP 20
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: PPUSH
8576: LD_VAR 0 1
8580: PPUSH
8581: CALL_OW 2
8585: ST_TO_ADDR
// end ;
8586: PPOPN 2
8588: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8589: LD_INT 0
8591: PPUSH
8592: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8593: LD_VAR 0 1
8597: PPUSH
8598: CALL_OW 255
8602: PUSH
8603: LD_EXP 8
8607: EQUAL
8608: PUSH
8609: LD_VAR 0 1
8613: PPUSH
8614: CALL_OW 266
8618: PUSH
8619: LD_INT 32
8621: EQUAL
8622: AND
8623: IFFALSE 8721
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8625: LD_ADDR_VAR 0 4
8629: PUSH
8630: LD_INT 22
8632: PUSH
8633: LD_EXP 8
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 5
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PPUSH
8656: CALL_OW 69
8660: ST_TO_ADDR
// for i in arm do
8661: LD_ADDR_VAR 0 3
8665: PUSH
8666: LD_VAR 0 4
8670: PUSH
8671: FOR_IN
8672: IFFALSE 8719
// if UnitsInside ( i ) < 6 then
8674: LD_VAR 0 3
8678: PPUSH
8679: CALL_OW 313
8683: PUSH
8684: LD_INT 6
8686: LESS
8687: IFFALSE 8717
// begin ComEnterUnit ( un , i ) ;
8689: LD_VAR 0 2
8693: PPUSH
8694: LD_VAR 0 3
8698: PPUSH
8699: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8703: LD_VAR 0 2
8707: PPUSH
8708: LD_INT 8
8710: PPUSH
8711: CALL_OW 183
// break ;
8715: GO 8719
// end ;
8717: GO 8671
8719: POP
8720: POP
// end ; end ; end_of_file
8721: PPOPN 4
8723: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
8724: LD_VAR 0 1
8728: PUSH
8729: LD_INT 200
8731: DOUBLE
8732: GREATEREQUAL
8733: IFFALSE 8741
8735: LD_INT 299
8737: DOUBLE
8738: LESSEQUAL
8739: IFTRUE 8743
8741: GO 8775
8743: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
8744: LD_VAR 0 1
8748: PPUSH
8749: LD_VAR 0 2
8753: PPUSH
8754: LD_VAR 0 3
8758: PPUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_VAR 0 5
8768: PPUSH
8769: CALL 37045 0 5
8773: GO 8852
8775: LD_INT 300
8777: DOUBLE
8778: GREATEREQUAL
8779: IFFALSE 8787
8781: LD_INT 399
8783: DOUBLE
8784: LESSEQUAL
8785: IFTRUE 8789
8787: GO 8851
8789: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
8790: LD_VAR 0 1
8794: PPUSH
8795: LD_VAR 0 2
8799: PPUSH
8800: LD_VAR 0 3
8804: PPUSH
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_VAR 0 5
8814: PPUSH
8815: LD_VAR 0 6
8819: PPUSH
8820: LD_VAR 0 7
8824: PPUSH
8825: LD_VAR 0 8
8829: PPUSH
8830: LD_VAR 0 9
8834: PPUSH
8835: LD_VAR 0 10
8839: PPUSH
8840: LD_VAR 0 11
8844: PPUSH
8845: CALL 33378 0 11
8849: GO 8852
8851: POP
// end ;
8852: PPOPN 11
8854: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
8855: LD_VAR 0 1
8859: PPUSH
8860: LD_VAR 0 2
8864: PPUSH
8865: LD_VAR 0 3
8869: PPUSH
8870: LD_VAR 0 4
8874: PPUSH
8875: LD_VAR 0 5
8879: PPUSH
8880: CALL 36781 0 5
// end ; end_of_file
8884: PPOPN 5
8886: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
8887: LD_INT 0
8889: PPUSH
8890: PPUSH
// if exist_mode then
8891: LD_VAR 0 2
8895: IFFALSE 8920
// unit := CreateCharacter ( prefix & ident ) else
8897: LD_ADDR_VAR 0 5
8901: PUSH
8902: LD_VAR 0 3
8906: PUSH
8907: LD_VAR 0 1
8911: STR
8912: PPUSH
8913: CALL_OW 34
8917: ST_TO_ADDR
8918: GO 8935
// unit := NewCharacter ( ident ) ;
8920: LD_ADDR_VAR 0 5
8924: PUSH
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 25
8934: ST_TO_ADDR
// result := unit ;
8935: LD_ADDR_VAR 0 4
8939: PUSH
8940: LD_VAR 0 5
8944: ST_TO_ADDR
// end ;
8945: LD_VAR 0 4
8949: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
8950: LD_INT 0
8952: PPUSH
8953: PPUSH
// if not side or not nation then
8954: LD_VAR 0 1
8958: NOT
8959: PUSH
8960: LD_VAR 0 2
8964: NOT
8965: OR
8966: IFFALSE 8970
// exit ;
8968: GO 9738
// case nation of nation_american :
8970: LD_VAR 0 2
8974: PUSH
8975: LD_INT 1
8977: DOUBLE
8978: EQUAL
8979: IFTRUE 8983
8981: GO 9197
8983: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
8984: LD_ADDR_VAR 0 4
8988: PUSH
8989: LD_INT 35
8991: PUSH
8992: LD_INT 45
8994: PUSH
8995: LD_INT 46
8997: PUSH
8998: LD_INT 47
9000: PUSH
9001: LD_INT 82
9003: PUSH
9004: LD_INT 83
9006: PUSH
9007: LD_INT 84
9009: PUSH
9010: LD_INT 85
9012: PUSH
9013: LD_INT 86
9015: PUSH
9016: LD_INT 1
9018: PUSH
9019: LD_INT 2
9021: PUSH
9022: LD_INT 6
9024: PUSH
9025: LD_INT 15
9027: PUSH
9028: LD_INT 16
9030: PUSH
9031: LD_INT 7
9033: PUSH
9034: LD_INT 12
9036: PUSH
9037: LD_INT 13
9039: PUSH
9040: LD_INT 10
9042: PUSH
9043: LD_INT 14
9045: PUSH
9046: LD_INT 20
9048: PUSH
9049: LD_INT 21
9051: PUSH
9052: LD_INT 22
9054: PUSH
9055: LD_INT 25
9057: PUSH
9058: LD_INT 32
9060: PUSH
9061: LD_INT 27
9063: PUSH
9064: LD_INT 36
9066: PUSH
9067: LD_INT 69
9069: PUSH
9070: LD_INT 39
9072: PUSH
9073: LD_INT 34
9075: PUSH
9076: LD_INT 40
9078: PUSH
9079: LD_INT 48
9081: PUSH
9082: LD_INT 49
9084: PUSH
9085: LD_INT 50
9087: PUSH
9088: LD_INT 51
9090: PUSH
9091: LD_INT 52
9093: PUSH
9094: LD_INT 53
9096: PUSH
9097: LD_INT 54
9099: PUSH
9100: LD_INT 55
9102: PUSH
9103: LD_INT 56
9105: PUSH
9106: LD_INT 57
9108: PUSH
9109: LD_INT 58
9111: PUSH
9112: LD_INT 59
9114: PUSH
9115: LD_INT 60
9117: PUSH
9118: LD_INT 61
9120: PUSH
9121: LD_INT 62
9123: PUSH
9124: LD_INT 80
9126: PUSH
9127: LD_INT 82
9129: PUSH
9130: LD_INT 83
9132: PUSH
9133: LD_INT 84
9135: PUSH
9136: LD_INT 85
9138: PUSH
9139: LD_INT 86
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: LIST
9180: LIST
9181: LIST
9182: LIST
9183: LIST
9184: LIST
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: LIST
9193: LIST
9194: ST_TO_ADDR
9195: GO 9662
9197: LD_INT 2
9199: DOUBLE
9200: EQUAL
9201: IFTRUE 9205
9203: GO 9431
9205: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
9206: LD_ADDR_VAR 0 4
9210: PUSH
9211: LD_INT 35
9213: PUSH
9214: LD_INT 45
9216: PUSH
9217: LD_INT 46
9219: PUSH
9220: LD_INT 47
9222: PUSH
9223: LD_INT 82
9225: PUSH
9226: LD_INT 83
9228: PUSH
9229: LD_INT 84
9231: PUSH
9232: LD_INT 85
9234: PUSH
9235: LD_INT 87
9237: PUSH
9238: LD_INT 70
9240: PUSH
9241: LD_INT 1
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: LD_INT 4
9252: PUSH
9253: LD_INT 5
9255: PUSH
9256: LD_INT 6
9258: PUSH
9259: LD_INT 15
9261: PUSH
9262: LD_INT 18
9264: PUSH
9265: LD_INT 7
9267: PUSH
9268: LD_INT 17
9270: PUSH
9271: LD_INT 8
9273: PUSH
9274: LD_INT 20
9276: PUSH
9277: LD_INT 21
9279: PUSH
9280: LD_INT 22
9282: PUSH
9283: LD_INT 72
9285: PUSH
9286: LD_INT 26
9288: PUSH
9289: LD_INT 69
9291: PUSH
9292: LD_INT 39
9294: PUSH
9295: LD_INT 40
9297: PUSH
9298: LD_INT 41
9300: PUSH
9301: LD_INT 42
9303: PUSH
9304: LD_INT 43
9306: PUSH
9307: LD_INT 48
9309: PUSH
9310: LD_INT 49
9312: PUSH
9313: LD_INT 50
9315: PUSH
9316: LD_INT 51
9318: PUSH
9319: LD_INT 52
9321: PUSH
9322: LD_INT 53
9324: PUSH
9325: LD_INT 54
9327: PUSH
9328: LD_INT 55
9330: PUSH
9331: LD_INT 56
9333: PUSH
9334: LD_INT 60
9336: PUSH
9337: LD_INT 61
9339: PUSH
9340: LD_INT 62
9342: PUSH
9343: LD_INT 66
9345: PUSH
9346: LD_INT 67
9348: PUSH
9349: LD_INT 68
9351: PUSH
9352: LD_INT 81
9354: PUSH
9355: LD_INT 82
9357: PUSH
9358: LD_INT 83
9360: PUSH
9361: LD_INT 84
9363: PUSH
9364: LD_INT 85
9366: PUSH
9367: LD_INT 87
9369: PUSH
9370: LD_INT 88
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: LIST
9407: LIST
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: LIST
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: ST_TO_ADDR
9429: GO 9662
9431: LD_INT 3
9433: DOUBLE
9434: EQUAL
9435: IFTRUE 9439
9437: GO 9661
9439: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
9440: LD_ADDR_VAR 0 4
9444: PUSH
9445: LD_INT 46
9447: PUSH
9448: LD_INT 47
9450: PUSH
9451: LD_INT 1
9453: PUSH
9454: LD_INT 2
9456: PUSH
9457: LD_INT 82
9459: PUSH
9460: LD_INT 83
9462: PUSH
9463: LD_INT 84
9465: PUSH
9466: LD_INT 85
9468: PUSH
9469: LD_INT 86
9471: PUSH
9472: LD_INT 11
9474: PUSH
9475: LD_INT 9
9477: PUSH
9478: LD_INT 20
9480: PUSH
9481: LD_INT 19
9483: PUSH
9484: LD_INT 21
9486: PUSH
9487: LD_INT 24
9489: PUSH
9490: LD_INT 22
9492: PUSH
9493: LD_INT 25
9495: PUSH
9496: LD_INT 28
9498: PUSH
9499: LD_INT 29
9501: PUSH
9502: LD_INT 30
9504: PUSH
9505: LD_INT 31
9507: PUSH
9508: LD_INT 37
9510: PUSH
9511: LD_INT 38
9513: PUSH
9514: LD_INT 32
9516: PUSH
9517: LD_INT 27
9519: PUSH
9520: LD_INT 33
9522: PUSH
9523: LD_INT 69
9525: PUSH
9526: LD_INT 39
9528: PUSH
9529: LD_INT 34
9531: PUSH
9532: LD_INT 40
9534: PUSH
9535: LD_INT 71
9537: PUSH
9538: LD_INT 23
9540: PUSH
9541: LD_INT 44
9543: PUSH
9544: LD_INT 48
9546: PUSH
9547: LD_INT 49
9549: PUSH
9550: LD_INT 50
9552: PUSH
9553: LD_INT 51
9555: PUSH
9556: LD_INT 52
9558: PUSH
9559: LD_INT 53
9561: PUSH
9562: LD_INT 54
9564: PUSH
9565: LD_INT 55
9567: PUSH
9568: LD_INT 56
9570: PUSH
9571: LD_INT 57
9573: PUSH
9574: LD_INT 58
9576: PUSH
9577: LD_INT 59
9579: PUSH
9580: LD_INT 63
9582: PUSH
9583: LD_INT 64
9585: PUSH
9586: LD_INT 65
9588: PUSH
9589: LD_INT 82
9591: PUSH
9592: LD_INT 83
9594: PUSH
9595: LD_INT 84
9597: PUSH
9598: LD_INT 85
9600: PUSH
9601: LD_INT 86
9603: PUSH
9604: EMPTY
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: ST_TO_ADDR
9659: GO 9662
9661: POP
// if state > - 1 and state < 3 then
9662: LD_VAR 0 3
9666: PUSH
9667: LD_INT 1
9669: NEG
9670: GREATER
9671: PUSH
9672: LD_VAR 0 3
9676: PUSH
9677: LD_INT 3
9679: LESS
9680: AND
9681: IFFALSE 9738
// for i in result do
9683: LD_ADDR_VAR 0 5
9687: PUSH
9688: LD_VAR 0 4
9692: PUSH
9693: FOR_IN
9694: IFFALSE 9736
// if GetTech ( i , side ) <> state then
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 321
9710: PUSH
9711: LD_VAR 0 3
9715: NONEQUAL
9716: IFFALSE 9734
// result := result diff i ;
9718: LD_ADDR_VAR 0 4
9722: PUSH
9723: LD_VAR 0 4
9727: PUSH
9728: LD_VAR 0 5
9732: DIFF
9733: ST_TO_ADDR
9734: GO 9693
9736: POP
9737: POP
// end ;
9738: LD_VAR 0 4
9742: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
9743: LD_INT 0
9745: PPUSH
9746: PPUSH
9747: PPUSH
// result := true ;
9748: LD_ADDR_VAR 0 3
9752: PUSH
9753: LD_INT 1
9755: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
9756: LD_ADDR_VAR 0 5
9760: PUSH
9761: LD_VAR 0 2
9765: PPUSH
9766: CALL_OW 480
9770: ST_TO_ADDR
// if not tmp then
9771: LD_VAR 0 5
9775: NOT
9776: IFFALSE 9780
// exit ;
9778: GO 9829
// for i in tmp do
9780: LD_ADDR_VAR 0 4
9784: PUSH
9785: LD_VAR 0 5
9789: PUSH
9790: FOR_IN
9791: IFFALSE 9827
// if GetTech ( i , side ) <> state_researched then
9793: LD_VAR 0 4
9797: PPUSH
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 321
9807: PUSH
9808: LD_INT 2
9810: NONEQUAL
9811: IFFALSE 9825
// begin result := false ;
9813: LD_ADDR_VAR 0 3
9817: PUSH
9818: LD_INT 0
9820: ST_TO_ADDR
// exit ;
9821: POP
9822: POP
9823: GO 9829
// end ;
9825: GO 9790
9827: POP
9828: POP
// end ;
9829: LD_VAR 0 3
9833: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
9834: LD_INT 0
9836: PPUSH
9837: PPUSH
9838: PPUSH
9839: PPUSH
9840: PPUSH
9841: PPUSH
9842: PPUSH
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
9848: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
9849: LD_VAR 0 1
9853: NOT
9854: PUSH
9855: LD_VAR 0 1
9859: PPUSH
9860: CALL_OW 257
9864: PUSH
9865: LD_INT 9
9867: NONEQUAL
9868: OR
9869: IFFALSE 9873
// exit ;
9871: GO 10446
// side := GetSide ( unit ) ;
9873: LD_ADDR_VAR 0 9
9877: PUSH
9878: LD_VAR 0 1
9882: PPUSH
9883: CALL_OW 255
9887: ST_TO_ADDR
// tech_space := tech_spacanom ;
9888: LD_ADDR_VAR 0 12
9892: PUSH
9893: LD_INT 29
9895: ST_TO_ADDR
// tech_time := tech_taurad ;
9896: LD_ADDR_VAR 0 13
9900: PUSH
9901: LD_INT 28
9903: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
9904: LD_ADDR_VAR 0 11
9908: PUSH
9909: LD_VAR 0 1
9913: PPUSH
9914: CALL_OW 310
9918: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
9919: LD_VAR 0 11
9923: PPUSH
9924: CALL_OW 247
9928: PUSH
9929: LD_INT 2
9931: EQUAL
9932: IFFALSE 9936
// exit ;
9934: GO 10446
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9936: LD_ADDR_VAR 0 8
9940: PUSH
9941: LD_INT 81
9943: PUSH
9944: LD_VAR 0 9
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: PUSH
9953: LD_INT 3
9955: PUSH
9956: LD_INT 21
9958: PUSH
9959: LD_INT 3
9961: PUSH
9962: EMPTY
9963: LIST
9964: LIST
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PPUSH
9974: CALL_OW 69
9978: ST_TO_ADDR
// if not tmp then
9979: LD_VAR 0 8
9983: NOT
9984: IFFALSE 9988
// exit ;
9986: GO 10446
// if in_unit then
9988: LD_VAR 0 11
9992: IFFALSE 10016
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
9994: LD_ADDR_VAR 0 10
9998: PUSH
9999: LD_VAR 0 8
10003: PPUSH
10004: LD_VAR 0 11
10008: PPUSH
10009: CALL_OW 74
10013: ST_TO_ADDR
10014: GO 10036
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10016: LD_ADDR_VAR 0 10
10020: PUSH
10021: LD_VAR 0 8
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: ST_TO_ADDR
// if not enemy then
10036: LD_VAR 0 10
10040: NOT
10041: IFFALSE 10045
// exit ;
10043: GO 10446
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10045: LD_VAR 0 11
10049: PUSH
10050: LD_VAR 0 11
10054: PPUSH
10055: LD_VAR 0 10
10059: PPUSH
10060: CALL_OW 296
10064: PUSH
10065: LD_INT 13
10067: GREATER
10068: AND
10069: PUSH
10070: LD_VAR 0 1
10074: PPUSH
10075: LD_VAR 0 10
10079: PPUSH
10080: CALL_OW 296
10084: PUSH
10085: LD_INT 12
10087: GREATER
10088: OR
10089: IFFALSE 10093
// exit ;
10091: GO 10446
// missile := [ 1 ] ;
10093: LD_ADDR_VAR 0 14
10097: PUSH
10098: LD_INT 1
10100: PUSH
10101: EMPTY
10102: LIST
10103: ST_TO_ADDR
// if Researched ( side , tech_space ) then
10104: LD_VAR 0 9
10108: PPUSH
10109: LD_VAR 0 12
10113: PPUSH
10114: CALL_OW 325
10118: IFFALSE 10147
// missile := Replace ( missile , missile + 1 , 2 ) ;
10120: LD_ADDR_VAR 0 14
10124: PUSH
10125: LD_VAR 0 14
10129: PPUSH
10130: LD_VAR 0 14
10134: PUSH
10135: LD_INT 1
10137: PLUS
10138: PPUSH
10139: LD_INT 2
10141: PPUSH
10142: CALL_OW 1
10146: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
10147: LD_VAR 0 9
10151: PPUSH
10152: LD_VAR 0 13
10156: PPUSH
10157: CALL_OW 325
10161: PUSH
10162: LD_VAR 0 10
10166: PPUSH
10167: CALL_OW 255
10171: PPUSH
10172: LD_VAR 0 13
10176: PPUSH
10177: CALL_OW 325
10181: NOT
10182: AND
10183: IFFALSE 10212
// missile := Replace ( missile , missile + 1 , 3 ) ;
10185: LD_ADDR_VAR 0 14
10189: PUSH
10190: LD_VAR 0 14
10194: PPUSH
10195: LD_VAR 0 14
10199: PUSH
10200: LD_INT 1
10202: PLUS
10203: PPUSH
10204: LD_INT 3
10206: PPUSH
10207: CALL_OW 1
10211: ST_TO_ADDR
// if missile < 2 then
10212: LD_VAR 0 14
10216: PUSH
10217: LD_INT 2
10219: LESS
10220: IFFALSE 10224
// exit ;
10222: GO 10446
// x := GetX ( enemy ) ;
10224: LD_ADDR_VAR 0 4
10228: PUSH
10229: LD_VAR 0 10
10233: PPUSH
10234: CALL_OW 250
10238: ST_TO_ADDR
// y := GetY ( enemy ) ;
10239: LD_ADDR_VAR 0 5
10243: PUSH
10244: LD_VAR 0 10
10248: PPUSH
10249: CALL_OW 251
10253: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
10254: LD_ADDR_VAR 0 6
10258: PUSH
10259: LD_VAR 0 4
10263: PUSH
10264: LD_INT 1
10266: NEG
10267: PPUSH
10268: LD_INT 1
10270: PPUSH
10271: CALL_OW 12
10275: PLUS
10276: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
10277: LD_ADDR_VAR 0 7
10281: PUSH
10282: LD_VAR 0 5
10286: PUSH
10287: LD_INT 1
10289: NEG
10290: PPUSH
10291: LD_INT 1
10293: PPUSH
10294: CALL_OW 12
10298: PLUS
10299: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10300: LD_VAR 0 6
10304: PPUSH
10305: LD_VAR 0 7
10309: PPUSH
10310: CALL_OW 488
10314: NOT
10315: IFFALSE 10337
// begin _x := x ;
10317: LD_ADDR_VAR 0 6
10321: PUSH
10322: LD_VAR 0 4
10326: ST_TO_ADDR
// _y := y ;
10327: LD_ADDR_VAR 0 7
10331: PUSH
10332: LD_VAR 0 5
10336: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
10337: LD_ADDR_VAR 0 3
10341: PUSH
10342: LD_INT 1
10344: PPUSH
10345: LD_VAR 0 14
10349: PPUSH
10350: CALL_OW 12
10354: ST_TO_ADDR
// case i of 1 :
10355: LD_VAR 0 3
10359: PUSH
10360: LD_INT 1
10362: DOUBLE
10363: EQUAL
10364: IFTRUE 10368
10366: GO 10385
10368: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
10369: LD_VAR 0 1
10373: PPUSH
10374: LD_VAR 0 10
10378: PPUSH
10379: CALL_OW 115
10383: GO 10446
10385: LD_INT 2
10387: DOUBLE
10388: EQUAL
10389: IFTRUE 10393
10391: GO 10415
10393: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_VAR 0 6
10403: PPUSH
10404: LD_VAR 0 7
10408: PPUSH
10409: CALL_OW 153
10413: GO 10446
10415: LD_INT 3
10417: DOUBLE
10418: EQUAL
10419: IFTRUE 10423
10421: GO 10445
10423: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
10424: LD_VAR 0 1
10428: PPUSH
10429: LD_VAR 0 6
10433: PPUSH
10434: LD_VAR 0 7
10438: PPUSH
10439: CALL_OW 154
10443: GO 10446
10445: POP
// end ;
10446: LD_VAR 0 2
10450: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
10451: LD_INT 0
10453: PPUSH
10454: PPUSH
10455: PPUSH
10456: PPUSH
10457: PPUSH
10458: PPUSH
// if not unit or not building then
10459: LD_VAR 0 1
10463: NOT
10464: PUSH
10465: LD_VAR 0 2
10469: NOT
10470: OR
10471: IFFALSE 10475
// exit ;
10473: GO 10633
// x := GetX ( building ) ;
10475: LD_ADDR_VAR 0 5
10479: PUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: CALL_OW 250
10489: ST_TO_ADDR
// y := GetY ( building ) ;
10490: LD_ADDR_VAR 0 6
10494: PUSH
10495: LD_VAR 0 2
10499: PPUSH
10500: CALL_OW 251
10504: ST_TO_ADDR
// for i = 0 to 5 do
10505: LD_ADDR_VAR 0 4
10509: PUSH
10510: DOUBLE
10511: LD_INT 0
10513: DEC
10514: ST_TO_ADDR
10515: LD_INT 5
10517: PUSH
10518: FOR_TO
10519: IFFALSE 10631
// begin _x := ShiftX ( x , i , 3 ) ;
10521: LD_ADDR_VAR 0 7
10525: PUSH
10526: LD_VAR 0 5
10530: PPUSH
10531: LD_VAR 0 4
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: CALL_OW 272
10543: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
10544: LD_ADDR_VAR 0 8
10548: PUSH
10549: LD_VAR 0 6
10553: PPUSH
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 3
10561: PPUSH
10562: CALL_OW 273
10566: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10567: LD_VAR 0 7
10571: PPUSH
10572: LD_VAR 0 8
10576: PPUSH
10577: CALL_OW 488
10581: NOT
10582: IFFALSE 10586
// continue ;
10584: GO 10518
// if HexInfo ( _x , _y ) = 0 then
10586: LD_VAR 0 7
10590: PPUSH
10591: LD_VAR 0 8
10595: PPUSH
10596: CALL_OW 428
10600: PUSH
10601: LD_INT 0
10603: EQUAL
10604: IFFALSE 10629
// begin ComMoveXY ( unit , _x , _y ) ;
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_VAR 0 7
10615: PPUSH
10616: LD_VAR 0 8
10620: PPUSH
10621: CALL_OW 111
// exit ;
10625: POP
10626: POP
10627: GO 10633
// end ; end ;
10629: GO 10518
10631: POP
10632: POP
// end ;
10633: LD_VAR 0 3
10637: RET
// export function ScanBase ( side , base_area ) ; begin
10638: LD_INT 0
10640: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
10641: LD_ADDR_VAR 0 3
10645: PUSH
10646: LD_VAR 0 2
10650: PPUSH
10651: LD_INT 81
10653: PUSH
10654: LD_VAR 0 1
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 70
10667: ST_TO_ADDR
// end ;
10668: LD_VAR 0 3
10672: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
10673: LD_INT 0
10675: PPUSH
10676: PPUSH
10677: PPUSH
10678: PPUSH
// result := false ;
10679: LD_ADDR_VAR 0 2
10683: PUSH
10684: LD_INT 0
10686: ST_TO_ADDR
// side := GetSide ( unit ) ;
10687: LD_ADDR_VAR 0 3
10691: PUSH
10692: LD_VAR 0 1
10696: PPUSH
10697: CALL_OW 255
10701: ST_TO_ADDR
// nat := GetNation ( unit ) ;
10702: LD_ADDR_VAR 0 4
10706: PUSH
10707: LD_VAR 0 1
10711: PPUSH
10712: CALL_OW 248
10716: ST_TO_ADDR
// case nat of 1 :
10717: LD_VAR 0 4
10721: PUSH
10722: LD_INT 1
10724: DOUBLE
10725: EQUAL
10726: IFTRUE 10730
10728: GO 10741
10730: POP
// tech := tech_lassight ; 2 :
10731: LD_ADDR_VAR 0 5
10735: PUSH
10736: LD_INT 12
10738: ST_TO_ADDR
10739: GO 10780
10741: LD_INT 2
10743: DOUBLE
10744: EQUAL
10745: IFTRUE 10749
10747: GO 10760
10749: POP
// tech := tech_mortar ; 3 :
10750: LD_ADDR_VAR 0 5
10754: PUSH
10755: LD_INT 41
10757: ST_TO_ADDR
10758: GO 10780
10760: LD_INT 3
10762: DOUBLE
10763: EQUAL
10764: IFTRUE 10768
10766: GO 10779
10768: POP
// tech := tech_bazooka ; end ;
10769: LD_ADDR_VAR 0 5
10773: PUSH
10774: LD_INT 44
10776: ST_TO_ADDR
10777: GO 10780
10779: POP
// if Researched ( side , tech ) then
10780: LD_VAR 0 3
10784: PPUSH
10785: LD_VAR 0 5
10789: PPUSH
10790: CALL_OW 325
10794: IFFALSE 10821
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
10796: LD_ADDR_VAR 0 2
10800: PUSH
10801: LD_INT 5
10803: PUSH
10804: LD_INT 8
10806: PUSH
10807: LD_INT 9
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: LIST
10814: PUSH
10815: LD_VAR 0 4
10819: ARRAY
10820: ST_TO_ADDR
// end ;
10821: LD_VAR 0 2
10825: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
10826: LD_INT 0
10828: PPUSH
10829: PPUSH
10830: PPUSH
// if not mines then
10831: LD_VAR 0 2
10835: NOT
10836: IFFALSE 10840
// exit ;
10838: GO 10984
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10840: LD_ADDR_VAR 0 5
10844: PUSH
10845: LD_INT 81
10847: PUSH
10848: LD_VAR 0 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 3
10859: PUSH
10860: LD_INT 21
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PUSH
10870: EMPTY
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PPUSH
10878: CALL_OW 69
10882: ST_TO_ADDR
// for i in mines do
10883: LD_ADDR_VAR 0 4
10887: PUSH
10888: LD_VAR 0 2
10892: PUSH
10893: FOR_IN
10894: IFFALSE 10982
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
10896: LD_VAR 0 4
10900: PUSH
10901: LD_INT 1
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 4
10909: PUSH
10910: LD_INT 2
10912: ARRAY
10913: PPUSH
10914: CALL_OW 458
10918: NOT
10919: IFFALSE 10923
// continue ;
10921: GO 10893
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
10923: LD_VAR 0 4
10927: PUSH
10928: LD_INT 1
10930: ARRAY
10931: PPUSH
10932: LD_VAR 0 4
10936: PUSH
10937: LD_INT 2
10939: ARRAY
10940: PPUSH
10941: CALL_OW 428
10945: PUSH
10946: LD_VAR 0 5
10950: IN
10951: IFFALSE 10980
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
10953: LD_VAR 0 4
10957: PUSH
10958: LD_INT 1
10960: ARRAY
10961: PPUSH
10962: LD_VAR 0 4
10966: PUSH
10967: LD_INT 2
10969: ARRAY
10970: PPUSH
10971: LD_VAR 0 1
10975: PPUSH
10976: CALL_OW 456
// end ;
10980: GO 10893
10982: POP
10983: POP
// end ;
10984: LD_VAR 0 3
10988: RET
// export function Count ( array ) ; var i ; begin
10989: LD_INT 0
10991: PPUSH
10992: PPUSH
// result := 0 ;
10993: LD_ADDR_VAR 0 2
10997: PUSH
10998: LD_INT 0
11000: ST_TO_ADDR
// for i in array do
11001: LD_ADDR_VAR 0 3
11005: PUSH
11006: LD_VAR 0 1
11010: PUSH
11011: FOR_IN
11012: IFFALSE 11036
// if i then
11014: LD_VAR 0 3
11018: IFFALSE 11034
// result := result + 1 ;
11020: LD_ADDR_VAR 0 2
11024: PUSH
11025: LD_VAR 0 2
11029: PUSH
11030: LD_INT 1
11032: PLUS
11033: ST_TO_ADDR
11034: GO 11011
11036: POP
11037: POP
// end ;
11038: LD_VAR 0 2
11042: RET
// export function IsEmpty ( building ) ; begin
11043: LD_INT 0
11045: PPUSH
// if not building then
11046: LD_VAR 0 1
11050: NOT
11051: IFFALSE 11055
// exit ;
11053: GO 11098
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11055: LD_ADDR_VAR 0 2
11059: PUSH
11060: LD_VAR 0 1
11064: PUSH
11065: LD_INT 22
11067: PUSH
11068: LD_VAR 0 1
11072: PPUSH
11073: CALL_OW 255
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: LD_INT 58
11084: PUSH
11085: EMPTY
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: IN
11097: ST_TO_ADDR
// end ;
11098: LD_VAR 0 2
11102: RET
// export function IsNotFull ( building ) ; var places ; begin
11103: LD_INT 0
11105: PPUSH
11106: PPUSH
// if not building then
11107: LD_VAR 0 1
11111: NOT
11112: IFFALSE 11116
// exit ;
11114: GO 11287
// result := false ;
11116: LD_ADDR_VAR 0 2
11120: PUSH
11121: LD_INT 0
11123: ST_TO_ADDR
// places := 0 ;
11124: LD_ADDR_VAR 0 3
11128: PUSH
11129: LD_INT 0
11131: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
11132: LD_VAR 0 1
11136: PPUSH
11137: CALL_OW 266
11141: PUSH
11142: LD_INT 0
11144: DOUBLE
11145: EQUAL
11146: IFTRUE 11204
11148: LD_INT 1
11150: DOUBLE
11151: EQUAL
11152: IFTRUE 11204
11154: LD_INT 6
11156: DOUBLE
11157: EQUAL
11158: IFTRUE 11204
11160: LD_INT 7
11162: DOUBLE
11163: EQUAL
11164: IFTRUE 11204
11166: LD_INT 8
11168: DOUBLE
11169: EQUAL
11170: IFTRUE 11204
11172: LD_INT 4
11174: DOUBLE
11175: EQUAL
11176: IFTRUE 11204
11178: LD_INT 5
11180: DOUBLE
11181: EQUAL
11182: IFTRUE 11204
11184: LD_INT 2
11186: DOUBLE
11187: EQUAL
11188: IFTRUE 11204
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11204
11196: LD_INT 35
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11215
11204: POP
// places := 6 ; b_bunker , b_breastwork :
11205: LD_ADDR_VAR 0 3
11209: PUSH
11210: LD_INT 6
11212: ST_TO_ADDR
11213: GO 11260
11215: LD_INT 32
11217: DOUBLE
11218: EQUAL
11219: IFTRUE 11229
11221: LD_INT 31
11223: DOUBLE
11224: EQUAL
11225: IFTRUE 11229
11227: GO 11240
11229: POP
// places := 1 ; b_control_tower :
11230: LD_ADDR_VAR 0 3
11234: PUSH
11235: LD_INT 1
11237: ST_TO_ADDR
11238: GO 11260
11240: LD_INT 36
11242: DOUBLE
11243: EQUAL
11244: IFTRUE 11248
11246: GO 11259
11248: POP
// places := 3 ; end ;
11249: LD_ADDR_VAR 0 3
11253: PUSH
11254: LD_INT 3
11256: ST_TO_ADDR
11257: GO 11260
11259: POP
// if places then
11260: LD_VAR 0 3
11264: IFFALSE 11287
// result := UnitsInside ( building ) < places ;
11266: LD_ADDR_VAR 0 2
11270: PUSH
11271: LD_VAR 0 1
11275: PPUSH
11276: CALL_OW 313
11280: PUSH
11281: LD_VAR 0 3
11285: LESS
11286: ST_TO_ADDR
// end ;
11287: LD_VAR 0 2
11291: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
11292: LD_INT 0
11294: PPUSH
11295: PPUSH
11296: PPUSH
11297: PPUSH
// tmp := [ ] ;
11298: LD_ADDR_VAR 0 3
11302: PUSH
11303: EMPTY
11304: ST_TO_ADDR
// list := [ ] ;
11305: LD_ADDR_VAR 0 5
11309: PUSH
11310: EMPTY
11311: ST_TO_ADDR
// for i = 16 to 25 do
11312: LD_ADDR_VAR 0 4
11316: PUSH
11317: DOUBLE
11318: LD_INT 16
11320: DEC
11321: ST_TO_ADDR
11322: LD_INT 25
11324: PUSH
11325: FOR_TO
11326: IFFALSE 11399
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
11328: LD_ADDR_VAR 0 3
11332: PUSH
11333: LD_VAR 0 3
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PPUSH
11346: CALL_OW 255
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: PUSH
11355: LD_INT 91
11357: PUSH
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 6
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: LIST
11370: PUSH
11371: LD_INT 30
11373: PUSH
11374: LD_VAR 0 4
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: PPUSH
11391: CALL_OW 69
11395: ADD
11396: ST_TO_ADDR
11397: GO 11325
11399: POP
11400: POP
// for i = 1 to tmp do
11401: LD_ADDR_VAR 0 4
11405: PUSH
11406: DOUBLE
11407: LD_INT 1
11409: DEC
11410: ST_TO_ADDR
11411: LD_VAR 0 3
11415: PUSH
11416: FOR_TO
11417: IFFALSE 11505
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11419: LD_ADDR_VAR 0 5
11423: PUSH
11424: LD_VAR 0 5
11428: PUSH
11429: LD_VAR 0 3
11433: PUSH
11434: LD_VAR 0 4
11438: ARRAY
11439: PPUSH
11440: CALL_OW 266
11444: PUSH
11445: LD_VAR 0 3
11449: PUSH
11450: LD_VAR 0 4
11454: ARRAY
11455: PPUSH
11456: CALL_OW 250
11460: PUSH
11461: LD_VAR 0 3
11465: PUSH
11466: LD_VAR 0 4
11470: ARRAY
11471: PPUSH
11472: CALL_OW 251
11476: PUSH
11477: LD_VAR 0 3
11481: PUSH
11482: LD_VAR 0 4
11486: ARRAY
11487: PPUSH
11488: CALL_OW 254
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: ADD
11502: ST_TO_ADDR
11503: GO 11416
11505: POP
11506: POP
// result := list ;
11507: LD_ADDR_VAR 0 2
11511: PUSH
11512: LD_VAR 0 5
11516: ST_TO_ADDR
// end ;
11517: LD_VAR 0 2
11521: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
11522: LD_INT 0
11524: PPUSH
11525: PPUSH
11526: PPUSH
11527: PPUSH
11528: PPUSH
11529: PPUSH
11530: PPUSH
// if not factory then
11531: LD_VAR 0 1
11535: NOT
11536: IFFALSE 11540
// exit ;
11538: GO 12133
// if control = control_apeman then
11540: LD_VAR 0 4
11544: PUSH
11545: LD_INT 5
11547: EQUAL
11548: IFFALSE 11657
// begin tmp := UnitsInside ( factory ) ;
11550: LD_ADDR_VAR 0 8
11554: PUSH
11555: LD_VAR 0 1
11559: PPUSH
11560: CALL_OW 313
11564: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
11565: LD_VAR 0 8
11569: PPUSH
11570: LD_INT 25
11572: PUSH
11573: LD_INT 12
11575: PUSH
11576: EMPTY
11577: LIST
11578: LIST
11579: PPUSH
11580: CALL_OW 72
11584: NOT
11585: IFFALSE 11595
// control := control_manual ;
11587: LD_ADDR_VAR 0 4
11591: PUSH
11592: LD_INT 1
11594: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
11595: LD_ADDR_VAR 0 8
11599: PUSH
11600: LD_VAR 0 1
11604: PPUSH
11605: CALL 11292 0 1
11609: ST_TO_ADDR
// if tmp then
11610: LD_VAR 0 8
11614: IFFALSE 11657
// begin for i in tmp do
11616: LD_ADDR_VAR 0 7
11620: PUSH
11621: LD_VAR 0 8
11625: PUSH
11626: FOR_IN
11627: IFFALSE 11655
// if i [ 1 ] = b_ext_radio then
11629: LD_VAR 0 7
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PUSH
11638: LD_INT 22
11640: EQUAL
11641: IFFALSE 11653
// begin control := control_remote ;
11643: LD_ADDR_VAR 0 4
11647: PUSH
11648: LD_INT 2
11650: ST_TO_ADDR
// break ;
11651: GO 11655
// end ;
11653: GO 11626
11655: POP
11656: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11657: LD_VAR 0 1
11661: PPUSH
11662: LD_VAR 0 2
11666: PPUSH
11667: LD_VAR 0 3
11671: PPUSH
11672: LD_VAR 0 4
11676: PPUSH
11677: LD_VAR 0 5
11681: PPUSH
11682: CALL_OW 448
11686: IFFALSE 11721
// begin result := [ chassis , engine , control , weapon ] ;
11688: LD_ADDR_VAR 0 6
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_VAR 0 4
11707: PUSH
11708: LD_VAR 0 5
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: ST_TO_ADDR
// exit ;
11719: GO 12133
// end ; _chassis := AvailableChassisList ( factory ) ;
11721: LD_ADDR_VAR 0 9
11725: PUSH
11726: LD_VAR 0 1
11730: PPUSH
11731: CALL_OW 475
11735: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
11736: LD_ADDR_VAR 0 11
11740: PUSH
11741: LD_VAR 0 1
11745: PPUSH
11746: CALL_OW 476
11750: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
11751: LD_ADDR_VAR 0 12
11755: PUSH
11756: LD_VAR 0 1
11760: PPUSH
11761: CALL_OW 477
11765: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
11766: LD_ADDR_VAR 0 10
11770: PUSH
11771: LD_VAR 0 1
11775: PPUSH
11776: CALL_OW 478
11780: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
11781: LD_VAR 0 9
11785: NOT
11786: PUSH
11787: LD_VAR 0 11
11791: NOT
11792: OR
11793: PUSH
11794: LD_VAR 0 12
11798: NOT
11799: OR
11800: PUSH
11801: LD_VAR 0 10
11805: NOT
11806: OR
11807: IFFALSE 11842
// begin result := [ chassis , engine , control , weapon ] ;
11809: LD_ADDR_VAR 0 6
11813: PUSH
11814: LD_VAR 0 2
11818: PUSH
11819: LD_VAR 0 3
11823: PUSH
11824: LD_VAR 0 4
11828: PUSH
11829: LD_VAR 0 5
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: ST_TO_ADDR
// exit ;
11840: GO 12133
// end ; if not chassis in _chassis then
11842: LD_VAR 0 2
11846: PUSH
11847: LD_VAR 0 9
11851: IN
11852: NOT
11853: IFFALSE 11879
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
11855: LD_ADDR_VAR 0 2
11859: PUSH
11860: LD_VAR 0 9
11864: PUSH
11865: LD_INT 1
11867: PPUSH
11868: LD_VAR 0 9
11872: PPUSH
11873: CALL_OW 12
11877: ARRAY
11878: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
11879: LD_VAR 0 2
11883: PPUSH
11884: LD_VAR 0 3
11888: PPUSH
11889: CALL 12138 0 2
11893: NOT
11894: IFFALSE 11953
// repeat engine := _engine [ 1 ] ;
11896: LD_ADDR_VAR 0 3
11900: PUSH
11901: LD_VAR 0 11
11905: PUSH
11906: LD_INT 1
11908: ARRAY
11909: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
11910: LD_ADDR_VAR 0 11
11914: PUSH
11915: LD_VAR 0 11
11919: PPUSH
11920: LD_INT 1
11922: PPUSH
11923: CALL_OW 3
11927: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
11928: LD_VAR 0 2
11932: PPUSH
11933: LD_VAR 0 3
11937: PPUSH
11938: CALL 12138 0 2
11942: PUSH
11943: LD_VAR 0 11
11947: PUSH
11948: EMPTY
11949: EQUAL
11950: OR
11951: IFFALSE 11896
// if not control in _control then
11953: LD_VAR 0 4
11957: PUSH
11958: LD_VAR 0 12
11962: IN
11963: NOT
11964: IFFALSE 11990
// control := _control [ rand ( 1 , _control ) ] ;
11966: LD_ADDR_VAR 0 4
11970: PUSH
11971: LD_VAR 0 12
11975: PUSH
11976: LD_INT 1
11978: PPUSH
11979: LD_VAR 0 12
11983: PPUSH
11984: CALL_OW 12
11988: ARRAY
11989: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
11990: LD_VAR 0 2
11994: PPUSH
11995: LD_VAR 0 5
11999: PPUSH
12000: CALL 12358 0 2
12004: NOT
12005: IFFALSE 12064
// repeat weapon := _weapon [ 1 ] ;
12007: LD_ADDR_VAR 0 5
12011: PUSH
12012: LD_VAR 0 10
12016: PUSH
12017: LD_INT 1
12019: ARRAY
12020: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12021: LD_ADDR_VAR 0 10
12025: PUSH
12026: LD_VAR 0 10
12030: PPUSH
12031: LD_INT 1
12033: PPUSH
12034: CALL_OW 3
12038: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12039: LD_VAR 0 2
12043: PPUSH
12044: LD_VAR 0 5
12048: PPUSH
12049: CALL 12358 0 2
12053: PUSH
12054: LD_VAR 0 10
12058: PUSH
12059: EMPTY
12060: EQUAL
12061: OR
12062: IFFALSE 12007
// result := [ ] ;
12064: LD_ADDR_VAR 0 6
12068: PUSH
12069: EMPTY
12070: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_VAR 0 2
12080: PPUSH
12081: LD_VAR 0 3
12085: PPUSH
12086: LD_VAR 0 4
12090: PPUSH
12091: LD_VAR 0 5
12095: PPUSH
12096: CALL_OW 448
12100: IFFALSE 12133
// result := [ chassis , engine , control , weapon ] ;
12102: LD_ADDR_VAR 0 6
12106: PUSH
12107: LD_VAR 0 2
12111: PUSH
12112: LD_VAR 0 3
12116: PUSH
12117: LD_VAR 0 4
12121: PUSH
12122: LD_VAR 0 5
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: ST_TO_ADDR
// end ;
12133: LD_VAR 0 6
12137: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12138: LD_INT 0
12140: PPUSH
// if not chassis or not engine then
12141: LD_VAR 0 1
12145: NOT
12146: PUSH
12147: LD_VAR 0 2
12151: NOT
12152: OR
12153: IFFALSE 12157
// exit ;
12155: GO 12353
// case engine of engine_solar :
12157: LD_VAR 0 2
12161: PUSH
12162: LD_INT 2
12164: DOUBLE
12165: EQUAL
12166: IFTRUE 12170
12168: GO 12208
12170: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12171: LD_ADDR_VAR 0 3
12175: PUSH
12176: LD_INT 11
12178: PUSH
12179: LD_INT 12
12181: PUSH
12182: LD_INT 13
12184: PUSH
12185: LD_INT 14
12187: PUSH
12188: LD_INT 1
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: ST_TO_ADDR
12206: GO 12337
12208: LD_INT 1
12210: DOUBLE
12211: EQUAL
12212: IFTRUE 12216
12214: GO 12278
12216: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_INT 11
12224: PUSH
12225: LD_INT 12
12227: PUSH
12228: LD_INT 13
12230: PUSH
12231: LD_INT 14
12233: PUSH
12234: LD_INT 1
12236: PUSH
12237: LD_INT 2
12239: PUSH
12240: LD_INT 3
12242: PUSH
12243: LD_INT 4
12245: PUSH
12246: LD_INT 5
12248: PUSH
12249: LD_INT 21
12251: PUSH
12252: LD_INT 23
12254: PUSH
12255: LD_INT 22
12257: PUSH
12258: LD_INT 24
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: LIST
12274: LIST
12275: ST_TO_ADDR
12276: GO 12337
12278: LD_INT 3
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12336
12286: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
12287: LD_ADDR_VAR 0 3
12291: PUSH
12292: LD_INT 13
12294: PUSH
12295: LD_INT 14
12297: PUSH
12298: LD_INT 2
12300: PUSH
12301: LD_INT 3
12303: PUSH
12304: LD_INT 4
12306: PUSH
12307: LD_INT 5
12309: PUSH
12310: LD_INT 21
12312: PUSH
12313: LD_INT 22
12315: PUSH
12316: LD_INT 23
12318: PUSH
12319: LD_INT 24
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: ST_TO_ADDR
12334: GO 12337
12336: POP
// result := ( chassis in result ) ;
12337: LD_ADDR_VAR 0 3
12341: PUSH
12342: LD_VAR 0 1
12346: PUSH
12347: LD_VAR 0 3
12351: IN
12352: ST_TO_ADDR
// end ;
12353: LD_VAR 0 3
12357: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
12358: LD_INT 0
12360: PPUSH
// if not chassis or not weapon then
12361: LD_VAR 0 1
12365: NOT
12366: PUSH
12367: LD_VAR 0 2
12371: NOT
12372: OR
12373: IFFALSE 12377
// exit ;
12375: GO 13437
// case weapon of us_machine_gun :
12377: LD_VAR 0 2
12381: PUSH
12382: LD_INT 2
12384: DOUBLE
12385: EQUAL
12386: IFTRUE 12390
12388: GO 12420
12390: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
12391: LD_ADDR_VAR 0 3
12395: PUSH
12396: LD_INT 1
12398: PUSH
12399: LD_INT 2
12401: PUSH
12402: LD_INT 3
12404: PUSH
12405: LD_INT 4
12407: PUSH
12408: LD_INT 5
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: ST_TO_ADDR
12418: GO 13421
12420: LD_INT 3
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12458
12428: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
12429: LD_ADDR_VAR 0 3
12433: PUSH
12434: LD_INT 1
12436: PUSH
12437: LD_INT 2
12439: PUSH
12440: LD_INT 3
12442: PUSH
12443: LD_INT 4
12445: PUSH
12446: LD_INT 5
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: ST_TO_ADDR
12456: GO 13421
12458: LD_INT 11
12460: DOUBLE
12461: EQUAL
12462: IFTRUE 12466
12464: GO 12496
12466: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
12467: LD_ADDR_VAR 0 3
12471: PUSH
12472: LD_INT 1
12474: PUSH
12475: LD_INT 2
12477: PUSH
12478: LD_INT 3
12480: PUSH
12481: LD_INT 4
12483: PUSH
12484: LD_INT 5
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: ST_TO_ADDR
12494: GO 13421
12496: LD_INT 4
12498: DOUBLE
12499: EQUAL
12500: IFTRUE 12504
12502: GO 12530
12504: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
12505: LD_ADDR_VAR 0 3
12509: PUSH
12510: LD_INT 2
12512: PUSH
12513: LD_INT 3
12515: PUSH
12516: LD_INT 4
12518: PUSH
12519: LD_INT 5
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: ST_TO_ADDR
12528: GO 13421
12530: LD_INT 5
12532: DOUBLE
12533: EQUAL
12534: IFTRUE 12538
12536: GO 12564
12538: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_INT 2
12546: PUSH
12547: LD_INT 3
12549: PUSH
12550: LD_INT 4
12552: PUSH
12553: LD_INT 5
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: ST_TO_ADDR
12562: GO 13421
12564: LD_INT 9
12566: DOUBLE
12567: EQUAL
12568: IFTRUE 12572
12570: GO 12598
12572: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
12573: LD_ADDR_VAR 0 3
12577: PUSH
12578: LD_INT 2
12580: PUSH
12581: LD_INT 3
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: LD_INT 5
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: ST_TO_ADDR
12596: GO 13421
12598: LD_INT 7
12600: DOUBLE
12601: EQUAL
12602: IFTRUE 12606
12604: GO 12632
12606: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: LD_INT 2
12614: PUSH
12615: LD_INT 3
12617: PUSH
12618: LD_INT 4
12620: PUSH
12621: LD_INT 5
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: ST_TO_ADDR
12630: GO 13421
12632: LD_INT 12
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12666
12640: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: LD_INT 2
12648: PUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: LD_INT 5
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: ST_TO_ADDR
12664: GO 13421
12666: LD_INT 13
12668: DOUBLE
12669: EQUAL
12670: IFTRUE 12674
12672: GO 12700
12674: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
12675: LD_ADDR_VAR 0 3
12679: PUSH
12680: LD_INT 2
12682: PUSH
12683: LD_INT 3
12685: PUSH
12686: LD_INT 4
12688: PUSH
12689: LD_INT 5
12691: PUSH
12692: EMPTY
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: ST_TO_ADDR
12698: GO 13421
12700: LD_INT 14
12702: DOUBLE
12703: EQUAL
12704: IFTRUE 12708
12706: GO 12726
12708: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
12709: LD_ADDR_VAR 0 3
12713: PUSH
12714: LD_INT 4
12716: PUSH
12717: LD_INT 5
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: ST_TO_ADDR
12724: GO 13421
12726: LD_INT 6
12728: DOUBLE
12729: EQUAL
12730: IFTRUE 12734
12732: GO 12752
12734: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
12735: LD_ADDR_VAR 0 3
12739: PUSH
12740: LD_INT 4
12742: PUSH
12743: LD_INT 5
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: ST_TO_ADDR
12750: GO 13421
12752: LD_INT 10
12754: DOUBLE
12755: EQUAL
12756: IFTRUE 12760
12758: GO 12778
12760: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: LD_INT 4
12768: PUSH
12769: LD_INT 5
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: ST_TO_ADDR
12776: GO 13421
12778: LD_INT 22
12780: DOUBLE
12781: EQUAL
12782: IFTRUE 12786
12784: GO 12812
12786: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
12787: LD_ADDR_VAR 0 3
12791: PUSH
12792: LD_INT 11
12794: PUSH
12795: LD_INT 12
12797: PUSH
12798: LD_INT 13
12800: PUSH
12801: LD_INT 14
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: ST_TO_ADDR
12810: GO 13421
12812: LD_INT 23
12814: DOUBLE
12815: EQUAL
12816: IFTRUE 12820
12818: GO 12846
12820: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
12821: LD_ADDR_VAR 0 3
12825: PUSH
12826: LD_INT 11
12828: PUSH
12829: LD_INT 12
12831: PUSH
12832: LD_INT 13
12834: PUSH
12835: LD_INT 14
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: ST_TO_ADDR
12844: GO 13421
12846: LD_INT 24
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12880
12854: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
12855: LD_ADDR_VAR 0 3
12859: PUSH
12860: LD_INT 11
12862: PUSH
12863: LD_INT 12
12865: PUSH
12866: LD_INT 13
12868: PUSH
12869: LD_INT 14
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: ST_TO_ADDR
12878: GO 13421
12880: LD_INT 30
12882: DOUBLE
12883: EQUAL
12884: IFTRUE 12888
12886: GO 12914
12888: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
12889: LD_ADDR_VAR 0 3
12893: PUSH
12894: LD_INT 11
12896: PUSH
12897: LD_INT 12
12899: PUSH
12900: LD_INT 13
12902: PUSH
12903: LD_INT 14
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: ST_TO_ADDR
12912: GO 13421
12914: LD_INT 25
12916: DOUBLE
12917: EQUAL
12918: IFTRUE 12922
12920: GO 12940
12922: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
12923: LD_ADDR_VAR 0 3
12927: PUSH
12928: LD_INT 13
12930: PUSH
12931: LD_INT 14
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: ST_TO_ADDR
12938: GO 13421
12940: LD_INT 27
12942: DOUBLE
12943: EQUAL
12944: IFTRUE 12948
12946: GO 12966
12948: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
12949: LD_ADDR_VAR 0 3
12953: PUSH
12954: LD_INT 13
12956: PUSH
12957: LD_INT 14
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: ST_TO_ADDR
12964: GO 13421
12966: LD_INT 92
12968: DOUBLE
12969: EQUAL
12970: IFTRUE 12974
12972: GO 13000
12974: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
12975: LD_ADDR_VAR 0 3
12979: PUSH
12980: LD_INT 11
12982: PUSH
12983: LD_INT 12
12985: PUSH
12986: LD_INT 13
12988: PUSH
12989: LD_INT 14
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: ST_TO_ADDR
12998: GO 13421
13000: LD_INT 28
13002: DOUBLE
13003: EQUAL
13004: IFTRUE 13008
13006: GO 13026
13008: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13009: LD_ADDR_VAR 0 3
13013: PUSH
13014: LD_INT 13
13016: PUSH
13017: LD_INT 14
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: ST_TO_ADDR
13024: GO 13421
13026: LD_INT 29
13028: DOUBLE
13029: EQUAL
13030: IFTRUE 13034
13032: GO 13052
13034: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13035: LD_ADDR_VAR 0 3
13039: PUSH
13040: LD_INT 13
13042: PUSH
13043: LD_INT 14
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: ST_TO_ADDR
13050: GO 13421
13052: LD_INT 31
13054: DOUBLE
13055: EQUAL
13056: IFTRUE 13060
13058: GO 13078
13060: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: LD_INT 13
13068: PUSH
13069: LD_INT 14
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: ST_TO_ADDR
13076: GO 13421
13078: LD_INT 26
13080: DOUBLE
13081: EQUAL
13082: IFTRUE 13086
13084: GO 13104
13086: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_INT 13
13094: PUSH
13095: LD_INT 14
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: ST_TO_ADDR
13102: GO 13421
13104: LD_INT 42
13106: DOUBLE
13107: EQUAL
13108: IFTRUE 13112
13110: GO 13138
13112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13113: LD_ADDR_VAR 0 3
13117: PUSH
13118: LD_INT 21
13120: PUSH
13121: LD_INT 22
13123: PUSH
13124: LD_INT 23
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: ST_TO_ADDR
13136: GO 13421
13138: LD_INT 43
13140: DOUBLE
13141: EQUAL
13142: IFTRUE 13146
13144: GO 13172
13146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13147: LD_ADDR_VAR 0 3
13151: PUSH
13152: LD_INT 21
13154: PUSH
13155: LD_INT 22
13157: PUSH
13158: LD_INT 23
13160: PUSH
13161: LD_INT 24
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13421
13172: LD_INT 44
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13206
13180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13181: LD_ADDR_VAR 0 3
13185: PUSH
13186: LD_INT 21
13188: PUSH
13189: LD_INT 22
13191: PUSH
13192: LD_INT 23
13194: PUSH
13195: LD_INT 24
13197: PUSH
13198: EMPTY
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: ST_TO_ADDR
13204: GO 13421
13206: LD_INT 45
13208: DOUBLE
13209: EQUAL
13210: IFTRUE 13214
13212: GO 13240
13214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13215: LD_ADDR_VAR 0 3
13219: PUSH
13220: LD_INT 21
13222: PUSH
13223: LD_INT 22
13225: PUSH
13226: LD_INT 23
13228: PUSH
13229: LD_INT 24
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: ST_TO_ADDR
13238: GO 13421
13240: LD_INT 49
13242: DOUBLE
13243: EQUAL
13244: IFTRUE 13248
13246: GO 13274
13248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13249: LD_ADDR_VAR 0 3
13253: PUSH
13254: LD_INT 21
13256: PUSH
13257: LD_INT 22
13259: PUSH
13260: LD_INT 23
13262: PUSH
13263: LD_INT 24
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: ST_TO_ADDR
13272: GO 13421
13274: LD_INT 51
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13282
13280: GO 13308
13282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
13283: LD_ADDR_VAR 0 3
13287: PUSH
13288: LD_INT 21
13290: PUSH
13291: LD_INT 22
13293: PUSH
13294: LD_INT 23
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: ST_TO_ADDR
13306: GO 13421
13308: LD_INT 52
13310: DOUBLE
13311: EQUAL
13312: IFTRUE 13316
13314: GO 13342
13316: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_INT 21
13324: PUSH
13325: LD_INT 22
13327: PUSH
13328: LD_INT 23
13330: PUSH
13331: LD_INT 24
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: ST_TO_ADDR
13340: GO 13421
13342: LD_INT 53
13344: DOUBLE
13345: EQUAL
13346: IFTRUE 13350
13348: GO 13368
13350: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: LD_INT 23
13358: PUSH
13359: LD_INT 24
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: ST_TO_ADDR
13366: GO 13421
13368: LD_INT 46
13370: DOUBLE
13371: EQUAL
13372: IFTRUE 13376
13374: GO 13394
13376: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
13377: LD_ADDR_VAR 0 3
13381: PUSH
13382: LD_INT 23
13384: PUSH
13385: LD_INT 24
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: ST_TO_ADDR
13392: GO 13421
13394: LD_INT 47
13396: DOUBLE
13397: EQUAL
13398: IFTRUE 13402
13400: GO 13420
13402: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 23
13410: PUSH
13411: LD_INT 24
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: ST_TO_ADDR
13418: GO 13421
13420: POP
// result := ( chassis in result ) ;
13421: LD_ADDR_VAR 0 3
13425: PUSH
13426: LD_VAR 0 1
13430: PUSH
13431: LD_VAR 0 3
13435: IN
13436: ST_TO_ADDR
// end ;
13437: LD_VAR 0 3
13441: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
13442: LD_INT 0
13444: PPUSH
13445: PPUSH
13446: PPUSH
13447: PPUSH
13448: PPUSH
13449: PPUSH
13450: PPUSH
// result := array ;
13451: LD_ADDR_VAR 0 5
13455: PUSH
13456: LD_VAR 0 1
13460: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
13461: LD_VAR 0 1
13465: NOT
13466: PUSH
13467: LD_VAR 0 2
13471: NOT
13472: OR
13473: PUSH
13474: LD_VAR 0 3
13478: NOT
13479: OR
13480: PUSH
13481: LD_VAR 0 2
13485: PUSH
13486: LD_VAR 0 1
13490: GREATER
13491: OR
13492: PUSH
13493: LD_VAR 0 3
13497: PUSH
13498: LD_VAR 0 1
13502: GREATER
13503: OR
13504: IFFALSE 13508
// exit ;
13506: GO 13804
// if direction then
13508: LD_VAR 0 4
13512: IFFALSE 13576
// begin d := 1 ;
13514: LD_ADDR_VAR 0 9
13518: PUSH
13519: LD_INT 1
13521: ST_TO_ADDR
// if i_from > i_to then
13522: LD_VAR 0 2
13526: PUSH
13527: LD_VAR 0 3
13531: GREATER
13532: IFFALSE 13558
// length := ( array - i_from ) + i_to else
13534: LD_ADDR_VAR 0 11
13538: PUSH
13539: LD_VAR 0 1
13543: PUSH
13544: LD_VAR 0 2
13548: MINUS
13549: PUSH
13550: LD_VAR 0 3
13554: PLUS
13555: ST_TO_ADDR
13556: GO 13574
// length := i_to - i_from ;
13558: LD_ADDR_VAR 0 11
13562: PUSH
13563: LD_VAR 0 3
13567: PUSH
13568: LD_VAR 0 2
13572: MINUS
13573: ST_TO_ADDR
// end else
13574: GO 13637
// begin d := - 1 ;
13576: LD_ADDR_VAR 0 9
13580: PUSH
13581: LD_INT 1
13583: NEG
13584: ST_TO_ADDR
// if i_from > i_to then
13585: LD_VAR 0 2
13589: PUSH
13590: LD_VAR 0 3
13594: GREATER
13595: IFFALSE 13615
// length := i_from - i_to else
13597: LD_ADDR_VAR 0 11
13601: PUSH
13602: LD_VAR 0 2
13606: PUSH
13607: LD_VAR 0 3
13611: MINUS
13612: ST_TO_ADDR
13613: GO 13637
// length := ( array - i_to ) + i_from ;
13615: LD_ADDR_VAR 0 11
13619: PUSH
13620: LD_VAR 0 1
13624: PUSH
13625: LD_VAR 0 3
13629: MINUS
13630: PUSH
13631: LD_VAR 0 2
13635: PLUS
13636: ST_TO_ADDR
// end ; if not length then
13637: LD_VAR 0 11
13641: NOT
13642: IFFALSE 13646
// exit ;
13644: GO 13804
// tmp := array ;
13646: LD_ADDR_VAR 0 10
13650: PUSH
13651: LD_VAR 0 1
13655: ST_TO_ADDR
// for i = 1 to length do
13656: LD_ADDR_VAR 0 6
13660: PUSH
13661: DOUBLE
13662: LD_INT 1
13664: DEC
13665: ST_TO_ADDR
13666: LD_VAR 0 11
13670: PUSH
13671: FOR_TO
13672: IFFALSE 13792
// begin for j = 1 to array do
13674: LD_ADDR_VAR 0 7
13678: PUSH
13679: DOUBLE
13680: LD_INT 1
13682: DEC
13683: ST_TO_ADDR
13684: LD_VAR 0 1
13688: PUSH
13689: FOR_TO
13690: IFFALSE 13778
// begin k := j + d ;
13692: LD_ADDR_VAR 0 8
13696: PUSH
13697: LD_VAR 0 7
13701: PUSH
13702: LD_VAR 0 9
13706: PLUS
13707: ST_TO_ADDR
// if k > array then
13708: LD_VAR 0 8
13712: PUSH
13713: LD_VAR 0 1
13717: GREATER
13718: IFFALSE 13728
// k := 1 ;
13720: LD_ADDR_VAR 0 8
13724: PUSH
13725: LD_INT 1
13727: ST_TO_ADDR
// if not k then
13728: LD_VAR 0 8
13732: NOT
13733: IFFALSE 13745
// k := array ;
13735: LD_ADDR_VAR 0 8
13739: PUSH
13740: LD_VAR 0 1
13744: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
13745: LD_ADDR_VAR 0 10
13749: PUSH
13750: LD_VAR 0 10
13754: PPUSH
13755: LD_VAR 0 8
13759: PPUSH
13760: LD_VAR 0 1
13764: PUSH
13765: LD_VAR 0 7
13769: ARRAY
13770: PPUSH
13771: CALL_OW 1
13775: ST_TO_ADDR
// end ;
13776: GO 13689
13778: POP
13779: POP
// array := tmp ;
13780: LD_ADDR_VAR 0 1
13784: PUSH
13785: LD_VAR 0 10
13789: ST_TO_ADDR
// end ;
13790: GO 13671
13792: POP
13793: POP
// result := array ;
13794: LD_ADDR_VAR 0 5
13798: PUSH
13799: LD_VAR 0 1
13803: ST_TO_ADDR
// end ;
13804: LD_VAR 0 5
13808: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
13809: LD_INT 0
13811: PPUSH
13812: PPUSH
// result := 0 ;
13813: LD_ADDR_VAR 0 3
13817: PUSH
13818: LD_INT 0
13820: ST_TO_ADDR
// if not array or not value in array then
13821: LD_VAR 0 1
13825: NOT
13826: PUSH
13827: LD_VAR 0 2
13831: PUSH
13832: LD_VAR 0 1
13836: IN
13837: NOT
13838: OR
13839: IFFALSE 13843
// exit ;
13841: GO 13897
// for i = 1 to array do
13843: LD_ADDR_VAR 0 4
13847: PUSH
13848: DOUBLE
13849: LD_INT 1
13851: DEC
13852: ST_TO_ADDR
13853: LD_VAR 0 1
13857: PUSH
13858: FOR_TO
13859: IFFALSE 13895
// if value = array [ i ] then
13861: LD_VAR 0 2
13865: PUSH
13866: LD_VAR 0 1
13870: PUSH
13871: LD_VAR 0 4
13875: ARRAY
13876: EQUAL
13877: IFFALSE 13893
// begin result := i ;
13879: LD_ADDR_VAR 0 3
13883: PUSH
13884: LD_VAR 0 4
13888: ST_TO_ADDR
// exit ;
13889: POP
13890: POP
13891: GO 13897
// end ;
13893: GO 13858
13895: POP
13896: POP
// end ;
13897: LD_VAR 0 3
13901: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
13902: LD_INT 0
13904: PPUSH
// vc_chassis := chassis ;
13905: LD_ADDR_OWVAR 37
13909: PUSH
13910: LD_VAR 0 1
13914: ST_TO_ADDR
// vc_engine := engine ;
13915: LD_ADDR_OWVAR 39
13919: PUSH
13920: LD_VAR 0 2
13924: ST_TO_ADDR
// vc_control := control ;
13925: LD_ADDR_OWVAR 38
13929: PUSH
13930: LD_VAR 0 3
13934: ST_TO_ADDR
// vc_weapon := weapon ;
13935: LD_ADDR_OWVAR 40
13939: PUSH
13940: LD_VAR 0 4
13944: ST_TO_ADDR
// vc_fuel_battery := fuel ;
13945: LD_ADDR_OWVAR 41
13949: PUSH
13950: LD_VAR 0 5
13954: ST_TO_ADDR
// end ;
13955: LD_VAR 0 6
13959: RET
// export function WantPlant ( unit ) ; var task ; begin
13960: LD_INT 0
13962: PPUSH
13963: PPUSH
// result := false ;
13964: LD_ADDR_VAR 0 2
13968: PUSH
13969: LD_INT 0
13971: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
13972: LD_ADDR_VAR 0 3
13976: PUSH
13977: LD_VAR 0 1
13981: PPUSH
13982: CALL_OW 437
13986: ST_TO_ADDR
// if task then
13987: LD_VAR 0 3
13991: IFFALSE 14019
// if task [ 1 ] [ 1 ] = p then
13993: LD_VAR 0 3
13997: PUSH
13998: LD_INT 1
14000: ARRAY
14001: PUSH
14002: LD_INT 1
14004: ARRAY
14005: PUSH
14006: LD_STRING p
14008: EQUAL
14009: IFFALSE 14019
// result := true ;
14011: LD_ADDR_VAR 0 2
14015: PUSH
14016: LD_INT 1
14018: ST_TO_ADDR
// end ;
14019: LD_VAR 0 2
14023: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14024: LD_INT 0
14026: PPUSH
14027: PPUSH
14028: PPUSH
14029: PPUSH
// if pos < 1 then
14030: LD_VAR 0 2
14034: PUSH
14035: LD_INT 1
14037: LESS
14038: IFFALSE 14042
// exit ;
14040: GO 14345
// if pos = 1 then
14042: LD_VAR 0 2
14046: PUSH
14047: LD_INT 1
14049: EQUAL
14050: IFFALSE 14083
// result := Replace ( arr , pos [ 1 ] , value ) else
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: LD_VAR 0 1
14061: PPUSH
14062: LD_VAR 0 2
14066: PUSH
14067: LD_INT 1
14069: ARRAY
14070: PPUSH
14071: LD_VAR 0 3
14075: PPUSH
14076: CALL_OW 1
14080: ST_TO_ADDR
14081: GO 14345
// begin tmp := arr ;
14083: LD_ADDR_VAR 0 6
14087: PUSH
14088: LD_VAR 0 1
14092: ST_TO_ADDR
// s_arr := [ tmp ] ;
14093: LD_ADDR_VAR 0 7
14097: PUSH
14098: LD_VAR 0 6
14102: PUSH
14103: EMPTY
14104: LIST
14105: ST_TO_ADDR
// for i = 1 to pos - 1 do
14106: LD_ADDR_VAR 0 5
14110: PUSH
14111: DOUBLE
14112: LD_INT 1
14114: DEC
14115: ST_TO_ADDR
14116: LD_VAR 0 2
14120: PUSH
14121: LD_INT 1
14123: MINUS
14124: PUSH
14125: FOR_TO
14126: IFFALSE 14171
// begin tmp := tmp [ pos [ i ] ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_VAR 0 6
14137: PUSH
14138: LD_VAR 0 2
14142: PUSH
14143: LD_VAR 0 5
14147: ARRAY
14148: ARRAY
14149: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14150: LD_ADDR_VAR 0 7
14154: PUSH
14155: LD_VAR 0 7
14159: PUSH
14160: LD_VAR 0 6
14164: PUSH
14165: EMPTY
14166: LIST
14167: ADD
14168: ST_TO_ADDR
// end ;
14169: GO 14125
14171: POP
14172: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14173: LD_ADDR_VAR 0 6
14177: PUSH
14178: LD_VAR 0 6
14182: PPUSH
14183: LD_VAR 0 2
14187: PUSH
14188: LD_VAR 0 2
14192: ARRAY
14193: PPUSH
14194: LD_VAR 0 3
14198: PPUSH
14199: CALL_OW 1
14203: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14204: LD_ADDR_VAR 0 7
14208: PUSH
14209: LD_VAR 0 7
14213: PPUSH
14214: LD_VAR 0 7
14218: PPUSH
14219: LD_VAR 0 6
14223: PPUSH
14224: CALL_OW 1
14228: ST_TO_ADDR
// for i = s_arr downto 2 do
14229: LD_ADDR_VAR 0 5
14233: PUSH
14234: DOUBLE
14235: LD_VAR 0 7
14239: INC
14240: ST_TO_ADDR
14241: LD_INT 2
14243: PUSH
14244: FOR_DOWNTO
14245: IFFALSE 14329
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14247: LD_ADDR_VAR 0 6
14251: PUSH
14252: LD_VAR 0 7
14256: PUSH
14257: LD_VAR 0 5
14261: PUSH
14262: LD_INT 1
14264: MINUS
14265: ARRAY
14266: PPUSH
14267: LD_VAR 0 2
14271: PUSH
14272: LD_VAR 0 5
14276: PUSH
14277: LD_INT 1
14279: MINUS
14280: ARRAY
14281: PPUSH
14282: LD_VAR 0 7
14286: PUSH
14287: LD_VAR 0 5
14291: ARRAY
14292: PPUSH
14293: CALL_OW 1
14297: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
14298: LD_ADDR_VAR 0 7
14302: PUSH
14303: LD_VAR 0 7
14307: PPUSH
14308: LD_VAR 0 5
14312: PUSH
14313: LD_INT 1
14315: MINUS
14316: PPUSH
14317: LD_VAR 0 6
14321: PPUSH
14322: CALL_OW 1
14326: ST_TO_ADDR
// end ;
14327: GO 14244
14329: POP
14330: POP
// result := s_arr [ 1 ] ;
14331: LD_ADDR_VAR 0 4
14335: PUSH
14336: LD_VAR 0 7
14340: PUSH
14341: LD_INT 1
14343: ARRAY
14344: ST_TO_ADDR
// end ; end ;
14345: LD_VAR 0 4
14349: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
14350: LD_INT 0
14352: PPUSH
14353: PPUSH
// if not list then
14354: LD_VAR 0 1
14358: NOT
14359: IFFALSE 14363
// exit ;
14361: GO 14454
// i := list [ pos1 ] ;
14363: LD_ADDR_VAR 0 5
14367: PUSH
14368: LD_VAR 0 1
14372: PUSH
14373: LD_VAR 0 2
14377: ARRAY
14378: ST_TO_ADDR
// if not i then
14379: LD_VAR 0 5
14383: NOT
14384: IFFALSE 14388
// exit ;
14386: GO 14454
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
14388: LD_ADDR_VAR 0 1
14392: PUSH
14393: LD_VAR 0 1
14397: PPUSH
14398: LD_VAR 0 2
14402: PPUSH
14403: LD_VAR 0 1
14407: PUSH
14408: LD_VAR 0 3
14412: ARRAY
14413: PPUSH
14414: CALL_OW 1
14418: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
14419: LD_ADDR_VAR 0 1
14423: PUSH
14424: LD_VAR 0 1
14428: PPUSH
14429: LD_VAR 0 3
14433: PPUSH
14434: LD_VAR 0 5
14438: PPUSH
14439: CALL_OW 1
14443: ST_TO_ADDR
// result := list ;
14444: LD_ADDR_VAR 0 4
14448: PUSH
14449: LD_VAR 0 1
14453: ST_TO_ADDR
// end ;
14454: LD_VAR 0 4
14458: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
14459: LD_INT 0
14461: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
14462: LD_ADDR_VAR 0 5
14466: PUSH
14467: LD_VAR 0 1
14471: PPUSH
14472: CALL_OW 250
14476: PPUSH
14477: LD_VAR 0 1
14481: PPUSH
14482: CALL_OW 251
14486: PPUSH
14487: LD_VAR 0 2
14491: PPUSH
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_VAR 0 4
14501: PPUSH
14502: CALL 14512 0 5
14506: ST_TO_ADDR
// end ;
14507: LD_VAR 0 5
14511: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
14512: LD_INT 0
14514: PPUSH
14515: PPUSH
14516: PPUSH
14517: PPUSH
// if not list then
14518: LD_VAR 0 3
14522: NOT
14523: IFFALSE 14527
// exit ;
14525: GO 14915
// result := [ ] ;
14527: LD_ADDR_VAR 0 6
14531: PUSH
14532: EMPTY
14533: ST_TO_ADDR
// for i in list do
14534: LD_ADDR_VAR 0 7
14538: PUSH
14539: LD_VAR 0 3
14543: PUSH
14544: FOR_IN
14545: IFFALSE 14747
// begin tmp := GetDistUnitXY ( i , x , y ) ;
14547: LD_ADDR_VAR 0 9
14551: PUSH
14552: LD_VAR 0 7
14556: PPUSH
14557: LD_VAR 0 1
14561: PPUSH
14562: LD_VAR 0 2
14566: PPUSH
14567: CALL_OW 297
14571: ST_TO_ADDR
// if not result then
14572: LD_VAR 0 6
14576: NOT
14577: IFFALSE 14603
// result := [ [ i , tmp ] ] else
14579: LD_ADDR_VAR 0 6
14583: PUSH
14584: LD_VAR 0 7
14588: PUSH
14589: LD_VAR 0 9
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: EMPTY
14599: LIST
14600: ST_TO_ADDR
14601: GO 14745
// begin if result [ result ] [ 2 ] < tmp then
14603: LD_VAR 0 6
14607: PUSH
14608: LD_VAR 0 6
14612: ARRAY
14613: PUSH
14614: LD_INT 2
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 9
14622: LESS
14623: IFFALSE 14665
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
14625: LD_ADDR_VAR 0 6
14629: PUSH
14630: LD_VAR 0 6
14634: PPUSH
14635: LD_VAR 0 6
14639: PUSH
14640: LD_INT 1
14642: PLUS
14643: PPUSH
14644: LD_VAR 0 7
14648: PUSH
14649: LD_VAR 0 9
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PPUSH
14658: CALL_OW 2
14662: ST_TO_ADDR
14663: GO 14745
// for j = 1 to result do
14665: LD_ADDR_VAR 0 8
14669: PUSH
14670: DOUBLE
14671: LD_INT 1
14673: DEC
14674: ST_TO_ADDR
14675: LD_VAR 0 6
14679: PUSH
14680: FOR_TO
14681: IFFALSE 14743
// begin if tmp < result [ j ] [ 2 ] then
14683: LD_VAR 0 9
14687: PUSH
14688: LD_VAR 0 6
14692: PUSH
14693: LD_VAR 0 8
14697: ARRAY
14698: PUSH
14699: LD_INT 2
14701: ARRAY
14702: LESS
14703: IFFALSE 14741
// begin result := Insert ( result , j , [ i , tmp ] ) ;
14705: LD_ADDR_VAR 0 6
14709: PUSH
14710: LD_VAR 0 6
14714: PPUSH
14715: LD_VAR 0 8
14719: PPUSH
14720: LD_VAR 0 7
14724: PUSH
14725: LD_VAR 0 9
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: PPUSH
14734: CALL_OW 2
14738: ST_TO_ADDR
// break ;
14739: GO 14743
// end ; end ;
14741: GO 14680
14743: POP
14744: POP
// end ; end ;
14745: GO 14544
14747: POP
14748: POP
// if result and not asc then
14749: LD_VAR 0 6
14753: PUSH
14754: LD_VAR 0 4
14758: NOT
14759: AND
14760: IFFALSE 14835
// begin tmp := result ;
14762: LD_ADDR_VAR 0 9
14766: PUSH
14767: LD_VAR 0 6
14771: ST_TO_ADDR
// for i = tmp downto 1 do
14772: LD_ADDR_VAR 0 7
14776: PUSH
14777: DOUBLE
14778: LD_VAR 0 9
14782: INC
14783: ST_TO_ADDR
14784: LD_INT 1
14786: PUSH
14787: FOR_DOWNTO
14788: IFFALSE 14833
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
14790: LD_ADDR_VAR 0 6
14794: PUSH
14795: LD_VAR 0 6
14799: PPUSH
14800: LD_VAR 0 9
14804: PUSH
14805: LD_VAR 0 7
14809: MINUS
14810: PUSH
14811: LD_INT 1
14813: PLUS
14814: PPUSH
14815: LD_VAR 0 9
14819: PUSH
14820: LD_VAR 0 7
14824: ARRAY
14825: PPUSH
14826: CALL_OW 1
14830: ST_TO_ADDR
14831: GO 14787
14833: POP
14834: POP
// end ; tmp := [ ] ;
14835: LD_ADDR_VAR 0 9
14839: PUSH
14840: EMPTY
14841: ST_TO_ADDR
// if mode then
14842: LD_VAR 0 5
14846: IFFALSE 14915
// begin for i = 1 to result do
14848: LD_ADDR_VAR 0 7
14852: PUSH
14853: DOUBLE
14854: LD_INT 1
14856: DEC
14857: ST_TO_ADDR
14858: LD_VAR 0 6
14862: PUSH
14863: FOR_TO
14864: IFFALSE 14903
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
14866: LD_ADDR_VAR 0 9
14870: PUSH
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 7
14880: PPUSH
14881: LD_VAR 0 6
14885: PUSH
14886: LD_VAR 0 7
14890: ARRAY
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: CALL_OW 1
14900: ST_TO_ADDR
14901: GO 14863
14903: POP
14904: POP
// result := tmp ;
14905: LD_ADDR_VAR 0 6
14909: PUSH
14910: LD_VAR 0 9
14914: ST_TO_ADDR
// end ; end ;
14915: LD_VAR 0 6
14919: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
14920: LD_INT 0
14922: PPUSH
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
14928: LD_ADDR_VAR 0 5
14932: PUSH
14933: LD_INT 0
14935: PUSH
14936: LD_INT 0
14938: PUSH
14939: LD_INT 0
14941: PUSH
14942: EMPTY
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: ST_TO_ADDR
// if not x or not y then
14950: LD_VAR 0 2
14954: NOT
14955: PUSH
14956: LD_VAR 0 3
14960: NOT
14961: OR
14962: IFFALSE 14966
// exit ;
14964: GO 16616
// if not range then
14966: LD_VAR 0 4
14970: NOT
14971: IFFALSE 14981
// range := 10 ;
14973: LD_ADDR_VAR 0 4
14977: PUSH
14978: LD_INT 10
14980: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14981: LD_ADDR_VAR 0 8
14985: PUSH
14986: LD_INT 81
14988: PUSH
14989: LD_VAR 0 1
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 92
15000: PUSH
15001: LD_VAR 0 2
15005: PUSH
15006: LD_VAR 0 3
15010: PUSH
15011: LD_VAR 0 4
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: PUSH
15022: LD_INT 3
15024: PUSH
15025: LD_INT 21
15027: PUSH
15028: LD_INT 3
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: EMPTY
15040: LIST
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: ST_TO_ADDR
// if not tmp then
15049: LD_VAR 0 8
15053: NOT
15054: IFFALSE 15058
// exit ;
15056: GO 16616
// for i in tmp do
15058: LD_ADDR_VAR 0 6
15062: PUSH
15063: LD_VAR 0 8
15067: PUSH
15068: FOR_IN
15069: IFFALSE 16591
// begin points := [ 0 , 0 , 0 ] ;
15071: LD_ADDR_VAR 0 9
15075: PUSH
15076: LD_INT 0
15078: PUSH
15079: LD_INT 0
15081: PUSH
15082: LD_INT 0
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: LIST
15089: ST_TO_ADDR
// bpoints := 1 ;
15090: LD_ADDR_VAR 0 10
15094: PUSH
15095: LD_INT 1
15097: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15098: LD_VAR 0 6
15102: PPUSH
15103: CALL_OW 247
15107: PUSH
15108: LD_INT 1
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15694
15116: POP
// begin if GetClass ( i ) = 1 then
15117: LD_VAR 0 6
15121: PPUSH
15122: CALL_OW 257
15126: PUSH
15127: LD_INT 1
15129: EQUAL
15130: IFFALSE 15151
// points := [ 10 , 5 , 3 ] ;
15132: LD_ADDR_VAR 0 9
15136: PUSH
15137: LD_INT 10
15139: PUSH
15140: LD_INT 5
15142: PUSH
15143: LD_INT 3
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: LIST
15150: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15151: LD_VAR 0 6
15155: PPUSH
15156: CALL_OW 257
15160: PUSH
15161: LD_INT 2
15163: PUSH
15164: LD_INT 3
15166: PUSH
15167: LD_INT 4
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: IN
15175: IFFALSE 15196
// points := [ 3 , 2 , 1 ] ;
15177: LD_ADDR_VAR 0 9
15181: PUSH
15182: LD_INT 3
15184: PUSH
15185: LD_INT 2
15187: PUSH
15188: LD_INT 1
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: LIST
15195: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15196: LD_VAR 0 6
15200: PPUSH
15201: CALL_OW 257
15205: PUSH
15206: LD_INT 5
15208: EQUAL
15209: IFFALSE 15230
// points := [ 130 , 5 , 2 ] ;
15211: LD_ADDR_VAR 0 9
15215: PUSH
15216: LD_INT 130
15218: PUSH
15219: LD_INT 5
15221: PUSH
15222: LD_INT 2
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: LIST
15229: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15230: LD_VAR 0 6
15234: PPUSH
15235: CALL_OW 257
15239: PUSH
15240: LD_INT 8
15242: EQUAL
15243: IFFALSE 15264
// points := [ 35 , 35 , 30 ] ;
15245: LD_ADDR_VAR 0 9
15249: PUSH
15250: LD_INT 35
15252: PUSH
15253: LD_INT 35
15255: PUSH
15256: LD_INT 30
15258: PUSH
15259: EMPTY
15260: LIST
15261: LIST
15262: LIST
15263: ST_TO_ADDR
// if GetClass ( i ) = 9 then
15264: LD_VAR 0 6
15268: PPUSH
15269: CALL_OW 257
15273: PUSH
15274: LD_INT 9
15276: EQUAL
15277: IFFALSE 15298
// points := [ 20 , 55 , 40 ] ;
15279: LD_ADDR_VAR 0 9
15283: PUSH
15284: LD_INT 20
15286: PUSH
15287: LD_INT 55
15289: PUSH
15290: LD_INT 40
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: LIST
15297: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
15298: LD_VAR 0 6
15302: PPUSH
15303: CALL_OW 257
15307: PUSH
15308: LD_INT 12
15310: PUSH
15311: LD_INT 16
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: IN
15318: IFFALSE 15339
// points := [ 5 , 3 , 2 ] ;
15320: LD_ADDR_VAR 0 9
15324: PUSH
15325: LD_INT 5
15327: PUSH
15328: LD_INT 3
15330: PUSH
15331: LD_INT 2
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: ST_TO_ADDR
// if GetClass ( i ) = 17 then
15339: LD_VAR 0 6
15343: PPUSH
15344: CALL_OW 257
15348: PUSH
15349: LD_INT 17
15351: EQUAL
15352: IFFALSE 15373
// points := [ 100 , 50 , 75 ] ;
15354: LD_ADDR_VAR 0 9
15358: PUSH
15359: LD_INT 100
15361: PUSH
15362: LD_INT 50
15364: PUSH
15365: LD_INT 75
15367: PUSH
15368: EMPTY
15369: LIST
15370: LIST
15371: LIST
15372: ST_TO_ADDR
// if GetClass ( i ) = 15 then
15373: LD_VAR 0 6
15377: PPUSH
15378: CALL_OW 257
15382: PUSH
15383: LD_INT 15
15385: EQUAL
15386: IFFALSE 15407
// points := [ 10 , 5 , 3 ] ;
15388: LD_ADDR_VAR 0 9
15392: PUSH
15393: LD_INT 10
15395: PUSH
15396: LD_INT 5
15398: PUSH
15399: LD_INT 3
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: LIST
15406: ST_TO_ADDR
// if GetClass ( i ) = 14 then
15407: LD_VAR 0 6
15411: PPUSH
15412: CALL_OW 257
15416: PUSH
15417: LD_INT 14
15419: EQUAL
15420: IFFALSE 15441
// points := [ 10 , 0 , 0 ] ;
15422: LD_ADDR_VAR 0 9
15426: PUSH
15427: LD_INT 10
15429: PUSH
15430: LD_INT 0
15432: PUSH
15433: LD_INT 0
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: LIST
15440: ST_TO_ADDR
// if GetClass ( i ) = 11 then
15441: LD_VAR 0 6
15445: PPUSH
15446: CALL_OW 257
15450: PUSH
15451: LD_INT 11
15453: EQUAL
15454: IFFALSE 15475
// points := [ 30 , 10 , 5 ] ;
15456: LD_ADDR_VAR 0 9
15460: PUSH
15461: LD_INT 30
15463: PUSH
15464: LD_INT 10
15466: PUSH
15467: LD_INT 5
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: LIST
15474: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
15475: LD_VAR 0 1
15479: PPUSH
15480: LD_INT 5
15482: PPUSH
15483: CALL_OW 321
15487: PUSH
15488: LD_INT 2
15490: EQUAL
15491: IFFALSE 15508
// bpoints := bpoints * 1.8 ;
15493: LD_ADDR_VAR 0 10
15497: PUSH
15498: LD_VAR 0 10
15502: PUSH
15503: LD_REAL  1.80000000000000E+0000
15506: MUL
15507: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
15508: LD_VAR 0 6
15512: PPUSH
15513: CALL_OW 257
15517: PUSH
15518: LD_INT 1
15520: PUSH
15521: LD_INT 2
15523: PUSH
15524: LD_INT 3
15526: PUSH
15527: LD_INT 4
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: IN
15536: PUSH
15537: LD_VAR 0 1
15541: PPUSH
15542: LD_INT 51
15544: PPUSH
15545: CALL_OW 321
15549: PUSH
15550: LD_INT 2
15552: EQUAL
15553: AND
15554: IFFALSE 15571
// bpoints := bpoints * 1.2 ;
15556: LD_ADDR_VAR 0 10
15560: PUSH
15561: LD_VAR 0 10
15565: PUSH
15566: LD_REAL  1.20000000000000E+0000
15569: MUL
15570: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
15571: LD_VAR 0 6
15575: PPUSH
15576: CALL_OW 257
15580: PUSH
15581: LD_INT 5
15583: PUSH
15584: LD_INT 7
15586: PUSH
15587: LD_INT 9
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: LIST
15594: IN
15595: PUSH
15596: LD_VAR 0 1
15600: PPUSH
15601: LD_INT 52
15603: PPUSH
15604: CALL_OW 321
15608: PUSH
15609: LD_INT 2
15611: EQUAL
15612: AND
15613: IFFALSE 15630
// bpoints := bpoints * 1.5 ;
15615: LD_ADDR_VAR 0 10
15619: PUSH
15620: LD_VAR 0 10
15624: PUSH
15625: LD_REAL  1.50000000000000E+0000
15628: MUL
15629: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
15630: LD_VAR 0 1
15634: PPUSH
15635: LD_INT 66
15637: PPUSH
15638: CALL_OW 321
15642: PUSH
15643: LD_INT 2
15645: EQUAL
15646: IFFALSE 15663
// bpoints := bpoints * 1.1 ;
15648: LD_ADDR_VAR 0 10
15652: PUSH
15653: LD_VAR 0 10
15657: PUSH
15658: LD_REAL  1.10000000000000E+0000
15661: MUL
15662: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
15663: LD_ADDR_VAR 0 10
15667: PUSH
15668: LD_VAR 0 10
15672: PUSH
15673: LD_VAR 0 6
15677: PPUSH
15678: LD_INT 1
15680: PPUSH
15681: CALL_OW 259
15685: PUSH
15686: LD_REAL  1.15000000000000E+0000
15689: MUL
15690: MUL
15691: ST_TO_ADDR
// end ; unit_vehicle :
15692: GO 16520
15694: LD_INT 2
15696: DOUBLE
15697: EQUAL
15698: IFTRUE 15702
15700: GO 16508
15702: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
15703: LD_VAR 0 6
15707: PPUSH
15708: CALL_OW 264
15712: PUSH
15713: LD_INT 2
15715: PUSH
15716: LD_INT 42
15718: PUSH
15719: LD_INT 24
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: LIST
15726: IN
15727: IFFALSE 15748
// points := [ 25 , 5 , 3 ] ;
15729: LD_ADDR_VAR 0 9
15733: PUSH
15734: LD_INT 25
15736: PUSH
15737: LD_INT 5
15739: PUSH
15740: LD_INT 3
15742: PUSH
15743: EMPTY
15744: LIST
15745: LIST
15746: LIST
15747: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
15748: LD_VAR 0 6
15752: PPUSH
15753: CALL_OW 264
15757: PUSH
15758: LD_INT 4
15760: PUSH
15761: LD_INT 43
15763: PUSH
15764: LD_INT 25
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: IN
15772: IFFALSE 15793
// points := [ 40 , 15 , 5 ] ;
15774: LD_ADDR_VAR 0 9
15778: PUSH
15779: LD_INT 40
15781: PUSH
15782: LD_INT 15
15784: PUSH
15785: LD_INT 5
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: LIST
15792: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
15793: LD_VAR 0 6
15797: PPUSH
15798: CALL_OW 264
15802: PUSH
15803: LD_INT 3
15805: PUSH
15806: LD_INT 23
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: IN
15813: IFFALSE 15834
// points := [ 7 , 25 , 8 ] ;
15815: LD_ADDR_VAR 0 9
15819: PUSH
15820: LD_INT 7
15822: PUSH
15823: LD_INT 25
15825: PUSH
15826: LD_INT 8
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
15834: LD_VAR 0 6
15838: PPUSH
15839: CALL_OW 264
15843: PUSH
15844: LD_INT 5
15846: PUSH
15847: LD_INT 27
15849: PUSH
15850: LD_INT 44
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: LIST
15857: IN
15858: IFFALSE 15879
// points := [ 14 , 50 , 16 ] ;
15860: LD_ADDR_VAR 0 9
15864: PUSH
15865: LD_INT 14
15867: PUSH
15868: LD_INT 50
15870: PUSH
15871: LD_INT 16
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: LIST
15878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
15879: LD_VAR 0 6
15883: PPUSH
15884: CALL_OW 264
15888: PUSH
15889: LD_INT 6
15891: PUSH
15892: LD_INT 46
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: IN
15899: IFFALSE 15920
// points := [ 32 , 120 , 70 ] ;
15901: LD_ADDR_VAR 0 9
15905: PUSH
15906: LD_INT 32
15908: PUSH
15909: LD_INT 120
15911: PUSH
15912: LD_INT 70
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: LIST
15919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
15920: LD_VAR 0 6
15924: PPUSH
15925: CALL_OW 264
15929: PUSH
15930: LD_INT 7
15932: PUSH
15933: LD_INT 28
15935: PUSH
15936: LD_INT 45
15938: PUSH
15939: LD_INT 92
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 35 , 20 , 45 ] ;
15950: LD_ADDR_VAR 0 9
15954: PUSH
15955: LD_INT 35
15957: PUSH
15958: LD_INT 20
15960: PUSH
15961: LD_INT 45
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
15969: LD_VAR 0 6
15973: PPUSH
15974: CALL_OW 264
15978: PUSH
15979: LD_INT 47
15981: PUSH
15982: EMPTY
15983: LIST
15984: IN
15985: IFFALSE 16006
// points := [ 67 , 45 , 75 ] ;
15987: LD_ADDR_VAR 0 9
15991: PUSH
15992: LD_INT 67
15994: PUSH
15995: LD_INT 45
15997: PUSH
15998: LD_INT 75
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: LIST
16005: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16006: LD_VAR 0 6
16010: PPUSH
16011: CALL_OW 264
16015: PUSH
16016: LD_INT 26
16018: PUSH
16019: EMPTY
16020: LIST
16021: IN
16022: IFFALSE 16043
// points := [ 120 , 30 , 80 ] ;
16024: LD_ADDR_VAR 0 9
16028: PUSH
16029: LD_INT 120
16031: PUSH
16032: LD_INT 30
16034: PUSH
16035: LD_INT 80
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16043: LD_VAR 0 6
16047: PPUSH
16048: CALL_OW 264
16052: PUSH
16053: LD_INT 22
16055: PUSH
16056: EMPTY
16057: LIST
16058: IN
16059: IFFALSE 16080
// points := [ 40 , 1 , 1 ] ;
16061: LD_ADDR_VAR 0 9
16065: PUSH
16066: LD_INT 40
16068: PUSH
16069: LD_INT 1
16071: PUSH
16072: LD_INT 1
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16080: LD_VAR 0 6
16084: PPUSH
16085: CALL_OW 264
16089: PUSH
16090: LD_INT 29
16092: PUSH
16093: EMPTY
16094: LIST
16095: IN
16096: IFFALSE 16117
// points := [ 70 , 200 , 400 ] ;
16098: LD_ADDR_VAR 0 9
16102: PUSH
16103: LD_INT 70
16105: PUSH
16106: LD_INT 200
16108: PUSH
16109: LD_INT 400
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16117: LD_VAR 0 6
16121: PPUSH
16122: CALL_OW 264
16126: PUSH
16127: LD_INT 14
16129: PUSH
16130: LD_INT 53
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: IN
16137: IFFALSE 16158
// points := [ 40 , 10 , 20 ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: LD_INT 40
16146: PUSH
16147: LD_INT 10
16149: PUSH
16150: LD_INT 20
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: LIST
16157: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 264
16167: PUSH
16168: LD_INT 9
16170: PUSH
16171: EMPTY
16172: LIST
16173: IN
16174: IFFALSE 16195
// points := [ 5 , 70 , 20 ] ;
16176: LD_ADDR_VAR 0 9
16180: PUSH
16181: LD_INT 5
16183: PUSH
16184: LD_INT 70
16186: PUSH
16187: LD_INT 20
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: LIST
16194: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16195: LD_VAR 0 6
16199: PPUSH
16200: CALL_OW 264
16204: PUSH
16205: LD_INT 10
16207: PUSH
16208: EMPTY
16209: LIST
16210: IN
16211: IFFALSE 16232
// points := [ 35 , 110 , 70 ] ;
16213: LD_ADDR_VAR 0 9
16217: PUSH
16218: LD_INT 35
16220: PUSH
16221: LD_INT 110
16223: PUSH
16224: LD_INT 70
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: LIST
16231: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16232: LD_VAR 0 6
16236: PPUSH
16237: CALL_OW 265
16241: PUSH
16242: LD_INT 25
16244: EQUAL
16245: IFFALSE 16266
// points := [ 80 , 65 , 100 ] ;
16247: LD_ADDR_VAR 0 9
16251: PUSH
16252: LD_INT 80
16254: PUSH
16255: LD_INT 65
16257: PUSH
16258: LD_INT 100
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: LIST
16265: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
16266: LD_VAR 0 6
16270: PPUSH
16271: CALL_OW 263
16275: PUSH
16276: LD_INT 1
16278: EQUAL
16279: IFFALSE 16314
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
16281: LD_ADDR_VAR 0 10
16285: PUSH
16286: LD_VAR 0 10
16290: PUSH
16291: LD_VAR 0 6
16295: PPUSH
16296: CALL_OW 311
16300: PPUSH
16301: LD_INT 3
16303: PPUSH
16304: CALL_OW 259
16308: PUSH
16309: LD_INT 4
16311: MUL
16312: MUL
16313: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
16314: LD_VAR 0 6
16318: PPUSH
16319: CALL_OW 263
16323: PUSH
16324: LD_INT 2
16326: EQUAL
16327: IFFALSE 16378
// begin j := IsControledBy ( i ) ;
16329: LD_ADDR_VAR 0 7
16333: PUSH
16334: LD_VAR 0 6
16338: PPUSH
16339: CALL_OW 312
16343: ST_TO_ADDR
// if j then
16344: LD_VAR 0 7
16348: IFFALSE 16378
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
16350: LD_ADDR_VAR 0 10
16354: PUSH
16355: LD_VAR 0 10
16359: PUSH
16360: LD_VAR 0 7
16364: PPUSH
16365: LD_INT 3
16367: PPUSH
16368: CALL_OW 259
16372: PUSH
16373: LD_INT 3
16375: MUL
16376: MUL
16377: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
16378: LD_VAR 0 6
16382: PPUSH
16383: CALL_OW 264
16387: PUSH
16388: LD_INT 5
16390: PUSH
16391: LD_INT 6
16393: PUSH
16394: LD_INT 46
16396: PUSH
16397: LD_INT 44
16399: PUSH
16400: LD_INT 47
16402: PUSH
16403: LD_INT 45
16405: PUSH
16406: LD_INT 28
16408: PUSH
16409: LD_INT 7
16411: PUSH
16412: LD_INT 27
16414: PUSH
16415: LD_INT 29
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: LIST
16422: LIST
16423: LIST
16424: LIST
16425: LIST
16426: LIST
16427: LIST
16428: LIST
16429: IN
16430: PUSH
16431: LD_VAR 0 1
16435: PPUSH
16436: LD_INT 52
16438: PPUSH
16439: CALL_OW 321
16443: PUSH
16444: LD_INT 2
16446: EQUAL
16447: AND
16448: IFFALSE 16465
// bpoints := bpoints * 1.2 ;
16450: LD_ADDR_VAR 0 10
16454: PUSH
16455: LD_VAR 0 10
16459: PUSH
16460: LD_REAL  1.20000000000000E+0000
16463: MUL
16464: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
16465: LD_VAR 0 6
16469: PPUSH
16470: CALL_OW 264
16474: PUSH
16475: LD_INT 6
16477: PUSH
16478: LD_INT 46
16480: PUSH
16481: LD_INT 47
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: LIST
16488: IN
16489: IFFALSE 16506
// bpoints := bpoints * 1.2 ;
16491: LD_ADDR_VAR 0 10
16495: PUSH
16496: LD_VAR 0 10
16500: PUSH
16501: LD_REAL  1.20000000000000E+0000
16504: MUL
16505: ST_TO_ADDR
// end ; unit_building :
16506: GO 16520
16508: LD_INT 3
16510: DOUBLE
16511: EQUAL
16512: IFTRUE 16516
16514: GO 16519
16516: POP
// ; end ;
16517: GO 16520
16519: POP
// for j = 1 to 3 do
16520: LD_ADDR_VAR 0 7
16524: PUSH
16525: DOUBLE
16526: LD_INT 1
16528: DEC
16529: ST_TO_ADDR
16530: LD_INT 3
16532: PUSH
16533: FOR_TO
16534: IFFALSE 16587
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
16536: LD_ADDR_VAR 0 5
16540: PUSH
16541: LD_VAR 0 5
16545: PPUSH
16546: LD_VAR 0 7
16550: PPUSH
16551: LD_VAR 0 5
16555: PUSH
16556: LD_VAR 0 7
16560: ARRAY
16561: PUSH
16562: LD_VAR 0 9
16566: PUSH
16567: LD_VAR 0 7
16571: ARRAY
16572: PUSH
16573: LD_VAR 0 10
16577: MUL
16578: PLUS
16579: PPUSH
16580: CALL_OW 1
16584: ST_TO_ADDR
16585: GO 16533
16587: POP
16588: POP
// end ;
16589: GO 15068
16591: POP
16592: POP
// result := Replace ( result , 4 , tmp ) ;
16593: LD_ADDR_VAR 0 5
16597: PUSH
16598: LD_VAR 0 5
16602: PPUSH
16603: LD_INT 4
16605: PPUSH
16606: LD_VAR 0 8
16610: PPUSH
16611: CALL_OW 1
16615: ST_TO_ADDR
// end ;
16616: LD_VAR 0 5
16620: RET
// export function DangerAtRange ( unit , range ) ; begin
16621: LD_INT 0
16623: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
16624: LD_ADDR_VAR 0 3
16628: PUSH
16629: LD_VAR 0 1
16633: PPUSH
16634: CALL_OW 255
16638: PPUSH
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL_OW 250
16648: PPUSH
16649: LD_VAR 0 1
16653: PPUSH
16654: CALL_OW 251
16658: PPUSH
16659: LD_VAR 0 2
16663: PPUSH
16664: CALL 14920 0 4
16668: ST_TO_ADDR
// end ;
16669: LD_VAR 0 3
16673: RET
// export function DangerInArea ( side , area ) ; begin
16674: LD_INT 0
16676: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
16677: LD_ADDR_VAR 0 3
16681: PUSH
16682: LD_VAR 0 2
16686: PPUSH
16687: LD_INT 81
16689: PUSH
16690: LD_VAR 0 1
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PPUSH
16699: CALL_OW 70
16703: ST_TO_ADDR
// end ;
16704: LD_VAR 0 3
16708: RET
// export function IsExtension ( b ) ; begin
16709: LD_INT 0
16711: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
16712: LD_ADDR_VAR 0 2
16716: PUSH
16717: LD_VAR 0 1
16721: PUSH
16722: LD_INT 23
16724: PUSH
16725: LD_INT 20
16727: PUSH
16728: LD_INT 22
16730: PUSH
16731: LD_INT 17
16733: PUSH
16734: LD_INT 24
16736: PUSH
16737: LD_INT 21
16739: PUSH
16740: LD_INT 19
16742: PUSH
16743: LD_INT 16
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 18
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: IN
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
// result := [ ] ;
16775: LD_ADDR_VAR 0 4
16779: PUSH
16780: EMPTY
16781: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
16782: LD_ADDR_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: PPUSH
16792: LD_INT 21
16794: PUSH
16795: LD_INT 3
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PPUSH
16802: CALL_OW 70
16806: ST_TO_ADDR
// if not tmp then
16807: LD_VAR 0 5
16811: NOT
16812: IFFALSE 16816
// exit ;
16814: GO 16880
// if checkLink then
16816: LD_VAR 0 3
16820: IFFALSE 16870
// begin for i in tmp do
16822: LD_ADDR_VAR 0 6
16826: PUSH
16827: LD_VAR 0 5
16831: PUSH
16832: FOR_IN
16833: IFFALSE 16868
// if GetBase ( i ) <> base then
16835: LD_VAR 0 6
16839: PPUSH
16840: CALL_OW 274
16844: PUSH
16845: LD_VAR 0 1
16849: NONEQUAL
16850: IFFALSE 16866
// ComLinkToBase ( base , i ) ;
16852: LD_VAR 0 1
16856: PPUSH
16857: LD_VAR 0 6
16861: PPUSH
16862: CALL_OW 169
16866: GO 16832
16868: POP
16869: POP
// end ; result := tmp ;
16870: LD_ADDR_VAR 0 4
16874: PUSH
16875: LD_VAR 0 5
16879: ST_TO_ADDR
// end ;
16880: LD_VAR 0 4
16884: RET
// export function ComComplete ( units , b ) ; var i ; begin
16885: LD_INT 0
16887: PPUSH
16888: PPUSH
// if not units then
16889: LD_VAR 0 1
16893: NOT
16894: IFFALSE 16898
// exit ;
16896: GO 16988
// for i in units do
16898: LD_ADDR_VAR 0 4
16902: PUSH
16903: LD_VAR 0 1
16907: PUSH
16908: FOR_IN
16909: IFFALSE 16986
// if BuildingStatus ( b ) = bs_build then
16911: LD_VAR 0 2
16915: PPUSH
16916: CALL_OW 461
16920: PUSH
16921: LD_INT 1
16923: EQUAL
16924: IFFALSE 16984
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
16926: LD_VAR 0 4
16930: PPUSH
16931: LD_STRING h
16933: PUSH
16934: LD_VAR 0 2
16938: PPUSH
16939: CALL_OW 250
16943: PUSH
16944: LD_VAR 0 2
16948: PPUSH
16949: CALL_OW 251
16953: PUSH
16954: LD_VAR 0 2
16958: PUSH
16959: LD_INT 0
16961: PUSH
16962: LD_INT 0
16964: PUSH
16965: LD_INT 0
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PUSH
16977: EMPTY
16978: LIST
16979: PPUSH
16980: CALL_OW 446
16984: GO 16908
16986: POP
16987: POP
// end ;
16988: LD_VAR 0 3
16992: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
16993: LD_INT 0
16995: PPUSH
16996: PPUSH
16997: PPUSH
16998: PPUSH
16999: PPUSH
17000: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17001: LD_VAR 0 1
17005: NOT
17006: PUSH
17007: LD_VAR 0 1
17011: PPUSH
17012: CALL_OW 263
17016: PUSH
17017: LD_INT 2
17019: NONEQUAL
17020: OR
17021: IFFALSE 17025
// exit ;
17023: GO 17341
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17025: LD_ADDR_VAR 0 6
17029: PUSH
17030: LD_INT 22
17032: PUSH
17033: LD_VAR 0 1
17037: PPUSH
17038: CALL_OW 255
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: PUSH
17047: LD_INT 2
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_INT 36
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: LD_INT 34
17062: PUSH
17063: LD_INT 31
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: LIST
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PPUSH
17079: CALL_OW 69
17083: ST_TO_ADDR
// if not tmp then
17084: LD_VAR 0 6
17088: NOT
17089: IFFALSE 17093
// exit ;
17091: GO 17341
// result := [ ] ;
17093: LD_ADDR_VAR 0 2
17097: PUSH
17098: EMPTY
17099: ST_TO_ADDR
// for i in tmp do
17100: LD_ADDR_VAR 0 3
17104: PUSH
17105: LD_VAR 0 6
17109: PUSH
17110: FOR_IN
17111: IFFALSE 17182
// begin t := UnitsInside ( i ) ;
17113: LD_ADDR_VAR 0 4
17117: PUSH
17118: LD_VAR 0 3
17122: PPUSH
17123: CALL_OW 313
17127: ST_TO_ADDR
// if t then
17128: LD_VAR 0 4
17132: IFFALSE 17180
// for j in t do
17134: LD_ADDR_VAR 0 7
17138: PUSH
17139: LD_VAR 0 4
17143: PUSH
17144: FOR_IN
17145: IFFALSE 17178
// result := Replace ( result , result + 1 , j ) ;
17147: LD_ADDR_VAR 0 2
17151: PUSH
17152: LD_VAR 0 2
17156: PPUSH
17157: LD_VAR 0 2
17161: PUSH
17162: LD_INT 1
17164: PLUS
17165: PPUSH
17166: LD_VAR 0 7
17170: PPUSH
17171: CALL_OW 1
17175: ST_TO_ADDR
17176: GO 17144
17178: POP
17179: POP
// end ;
17180: GO 17110
17182: POP
17183: POP
// if not result then
17184: LD_VAR 0 2
17188: NOT
17189: IFFALSE 17193
// exit ;
17191: GO 17341
// mech := result [ 1 ] ;
17193: LD_ADDR_VAR 0 5
17197: PUSH
17198: LD_VAR 0 2
17202: PUSH
17203: LD_INT 1
17205: ARRAY
17206: ST_TO_ADDR
// if result > 1 then
17207: LD_VAR 0 2
17211: PUSH
17212: LD_INT 1
17214: GREATER
17215: IFFALSE 17327
// begin for i = 2 to result do
17217: LD_ADDR_VAR 0 3
17221: PUSH
17222: DOUBLE
17223: LD_INT 2
17225: DEC
17226: ST_TO_ADDR
17227: LD_VAR 0 2
17231: PUSH
17232: FOR_TO
17233: IFFALSE 17325
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17235: LD_ADDR_VAR 0 4
17239: PUSH
17240: LD_VAR 0 2
17244: PUSH
17245: LD_VAR 0 3
17249: ARRAY
17250: PPUSH
17251: LD_INT 3
17253: PPUSH
17254: CALL_OW 259
17258: PUSH
17259: LD_VAR 0 2
17263: PUSH
17264: LD_VAR 0 3
17268: ARRAY
17269: PPUSH
17270: CALL_OW 432
17274: MINUS
17275: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
17276: LD_VAR 0 4
17280: PUSH
17281: LD_VAR 0 5
17285: PPUSH
17286: LD_INT 3
17288: PPUSH
17289: CALL_OW 259
17293: PUSH
17294: LD_VAR 0 5
17298: PPUSH
17299: CALL_OW 432
17303: MINUS
17304: GREATEREQUAL
17305: IFFALSE 17323
// mech := result [ i ] ;
17307: LD_ADDR_VAR 0 5
17311: PUSH
17312: LD_VAR 0 2
17316: PUSH
17317: LD_VAR 0 3
17321: ARRAY
17322: ST_TO_ADDR
// end ;
17323: GO 17232
17325: POP
17326: POP
// end ; ComLinkTo ( vehicle , mech ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: LD_VAR 0 5
17336: PPUSH
17337: CALL_OW 135
// end ;
17341: LD_VAR 0 2
17345: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
17346: LD_INT 0
17348: PPUSH
17349: PPUSH
17350: PPUSH
17351: PPUSH
17352: PPUSH
17353: PPUSH
17354: PPUSH
17355: PPUSH
17356: PPUSH
17357: PPUSH
17358: PPUSH
17359: PPUSH
17360: PPUSH
// result := [ ] ;
17361: LD_ADDR_VAR 0 7
17365: PUSH
17366: EMPTY
17367: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
17368: LD_VAR 0 1
17372: PPUSH
17373: CALL_OW 266
17377: PUSH
17378: LD_INT 0
17380: PUSH
17381: LD_INT 1
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: IN
17388: NOT
17389: IFFALSE 17393
// exit ;
17391: GO 19027
// if name then
17393: LD_VAR 0 3
17397: IFFALSE 17413
// SetBName ( base_dep , name ) ;
17399: LD_VAR 0 1
17403: PPUSH
17404: LD_VAR 0 3
17408: PPUSH
17409: CALL_OW 500
// base := GetBase ( base_dep ) ;
17413: LD_ADDR_VAR 0 15
17417: PUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: CALL_OW 274
17427: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
17428: LD_ADDR_VAR 0 16
17432: PUSH
17433: LD_VAR 0 1
17437: PPUSH
17438: CALL_OW 255
17442: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
17443: LD_ADDR_VAR 0 17
17447: PUSH
17448: LD_VAR 0 1
17452: PPUSH
17453: CALL_OW 248
17457: ST_TO_ADDR
// if sources then
17458: LD_VAR 0 5
17462: IFFALSE 17509
// for i = 1 to 3 do
17464: LD_ADDR_VAR 0 8
17468: PUSH
17469: DOUBLE
17470: LD_INT 1
17472: DEC
17473: ST_TO_ADDR
17474: LD_INT 3
17476: PUSH
17477: FOR_TO
17478: IFFALSE 17507
// AddResourceType ( base , i , sources [ i ] ) ;
17480: LD_VAR 0 15
17484: PPUSH
17485: LD_VAR 0 8
17489: PPUSH
17490: LD_VAR 0 5
17494: PUSH
17495: LD_VAR 0 8
17499: ARRAY
17500: PPUSH
17501: CALL_OW 276
17505: GO 17477
17507: POP
17508: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
17509: LD_ADDR_VAR 0 18
17513: PUSH
17514: LD_VAR 0 15
17518: PPUSH
17519: LD_VAR 0 2
17523: PPUSH
17524: LD_INT 1
17526: PPUSH
17527: CALL 16770 0 3
17531: ST_TO_ADDR
// InitHc ;
17532: CALL_OW 19
// InitUc ;
17536: CALL_OW 18
// uc_side := side ;
17540: LD_ADDR_OWVAR 20
17544: PUSH
17545: LD_VAR 0 16
17549: ST_TO_ADDR
// uc_nation := nation ;
17550: LD_ADDR_OWVAR 21
17554: PUSH
17555: LD_VAR 0 17
17559: ST_TO_ADDR
// if buildings then
17560: LD_VAR 0 18
17564: IFFALSE 18886
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
17566: LD_ADDR_VAR 0 19
17570: PUSH
17571: LD_VAR 0 18
17575: PPUSH
17576: LD_INT 2
17578: PUSH
17579: LD_INT 30
17581: PUSH
17582: LD_INT 29
17584: PUSH
17585: EMPTY
17586: LIST
17587: LIST
17588: PUSH
17589: LD_INT 30
17591: PUSH
17592: LD_INT 30
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: LIST
17603: PPUSH
17604: CALL_OW 72
17608: ST_TO_ADDR
// if tmp then
17609: LD_VAR 0 19
17613: IFFALSE 17661
// for i in tmp do
17615: LD_ADDR_VAR 0 8
17619: PUSH
17620: LD_VAR 0 19
17624: PUSH
17625: FOR_IN
17626: IFFALSE 17659
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
17628: LD_VAR 0 8
17632: PPUSH
17633: CALL_OW 250
17637: PPUSH
17638: LD_VAR 0 8
17642: PPUSH
17643: CALL_OW 251
17647: PPUSH
17648: LD_VAR 0 16
17652: PPUSH
17653: CALL_OW 441
17657: GO 17625
17659: POP
17660: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
17661: LD_VAR 0 18
17665: PPUSH
17666: LD_INT 2
17668: PUSH
17669: LD_INT 30
17671: PUSH
17672: LD_INT 32
17674: PUSH
17675: EMPTY
17676: LIST
17677: LIST
17678: PUSH
17679: LD_INT 30
17681: PUSH
17682: LD_INT 33
17684: PUSH
17685: EMPTY
17686: LIST
17687: LIST
17688: PUSH
17689: EMPTY
17690: LIST
17691: LIST
17692: LIST
17693: PPUSH
17694: CALL_OW 72
17698: IFFALSE 17786
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
17700: LD_ADDR_VAR 0 8
17704: PUSH
17705: LD_VAR 0 18
17709: PPUSH
17710: LD_INT 2
17712: PUSH
17713: LD_INT 30
17715: PUSH
17716: LD_INT 32
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: PUSH
17723: LD_INT 30
17725: PUSH
17726: LD_INT 33
17728: PUSH
17729: EMPTY
17730: LIST
17731: LIST
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: PPUSH
17738: CALL_OW 72
17742: PUSH
17743: FOR_IN
17744: IFFALSE 17784
// begin if not GetBWeapon ( i ) then
17746: LD_VAR 0 8
17750: PPUSH
17751: CALL_OW 269
17755: NOT
17756: IFFALSE 17782
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
17758: LD_VAR 0 8
17762: PPUSH
17763: LD_VAR 0 8
17767: PPUSH
17768: LD_VAR 0 2
17772: PPUSH
17773: CALL 19032 0 2
17777: PPUSH
17778: CALL_OW 431
// end ;
17782: GO 17743
17784: POP
17785: POP
// end ; for i = 1 to personel do
17786: LD_ADDR_VAR 0 8
17790: PUSH
17791: DOUBLE
17792: LD_INT 1
17794: DEC
17795: ST_TO_ADDR
17796: LD_VAR 0 6
17800: PUSH
17801: FOR_TO
17802: IFFALSE 18866
// begin if i > 4 then
17804: LD_VAR 0 8
17808: PUSH
17809: LD_INT 4
17811: GREATER
17812: IFFALSE 17816
// break ;
17814: GO 18866
// case i of 1 :
17816: LD_VAR 0 8
17820: PUSH
17821: LD_INT 1
17823: DOUBLE
17824: EQUAL
17825: IFTRUE 17829
17827: GO 17909
17829: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
17830: LD_ADDR_VAR 0 12
17834: PUSH
17835: LD_VAR 0 18
17839: PPUSH
17840: LD_INT 22
17842: PUSH
17843: LD_VAR 0 16
17847: PUSH
17848: EMPTY
17849: LIST
17850: LIST
17851: PUSH
17852: LD_INT 58
17854: PUSH
17855: EMPTY
17856: LIST
17857: PUSH
17858: LD_INT 2
17860: PUSH
17861: LD_INT 30
17863: PUSH
17864: LD_INT 32
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PUSH
17871: LD_INT 30
17873: PUSH
17874: LD_INT 4
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PUSH
17881: LD_INT 30
17883: PUSH
17884: LD_INT 5
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: PPUSH
17902: CALL_OW 72
17906: ST_TO_ADDR
17907: GO 18131
17909: LD_INT 2
17911: DOUBLE
17912: EQUAL
17913: IFTRUE 17917
17915: GO 17979
17917: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
17918: LD_ADDR_VAR 0 12
17922: PUSH
17923: LD_VAR 0 18
17927: PPUSH
17928: LD_INT 22
17930: PUSH
17931: LD_VAR 0 16
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: PUSH
17940: LD_INT 2
17942: PUSH
17943: LD_INT 30
17945: PUSH
17946: LD_INT 0
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: PUSH
17953: LD_INT 30
17955: PUSH
17956: LD_INT 1
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PPUSH
17972: CALL_OW 72
17976: ST_TO_ADDR
17977: GO 18131
17979: LD_INT 3
17981: DOUBLE
17982: EQUAL
17983: IFTRUE 17987
17985: GO 18049
17987: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
17988: LD_ADDR_VAR 0 12
17992: PUSH
17993: LD_VAR 0 18
17997: PPUSH
17998: LD_INT 22
18000: PUSH
18001: LD_VAR 0 16
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PUSH
18010: LD_INT 2
18012: PUSH
18013: LD_INT 30
18015: PUSH
18016: LD_INT 2
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 30
18025: PUSH
18026: LD_INT 3
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: LIST
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: PPUSH
18042: CALL_OW 72
18046: ST_TO_ADDR
18047: GO 18131
18049: LD_INT 4
18051: DOUBLE
18052: EQUAL
18053: IFTRUE 18057
18055: GO 18130
18057: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18058: LD_ADDR_VAR 0 12
18062: PUSH
18063: LD_VAR 0 18
18067: PPUSH
18068: LD_INT 22
18070: PUSH
18071: LD_VAR 0 16
18075: PUSH
18076: EMPTY
18077: LIST
18078: LIST
18079: PUSH
18080: LD_INT 2
18082: PUSH
18083: LD_INT 30
18085: PUSH
18086: LD_INT 6
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 30
18095: PUSH
18096: LD_INT 7
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 30
18105: PUSH
18106: LD_INT 8
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: EMPTY
18114: LIST
18115: LIST
18116: LIST
18117: LIST
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PPUSH
18123: CALL_OW 72
18127: ST_TO_ADDR
18128: GO 18131
18130: POP
// if i = 1 then
18131: LD_VAR 0 8
18135: PUSH
18136: LD_INT 1
18138: EQUAL
18139: IFFALSE 18250
// begin tmp := [ ] ;
18141: LD_ADDR_VAR 0 19
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// for j in f do
18148: LD_ADDR_VAR 0 9
18152: PUSH
18153: LD_VAR 0 12
18157: PUSH
18158: FOR_IN
18159: IFFALSE 18232
// if GetBType ( j ) = b_bunker then
18161: LD_VAR 0 9
18165: PPUSH
18166: CALL_OW 266
18170: PUSH
18171: LD_INT 32
18173: EQUAL
18174: IFFALSE 18201
// tmp := Insert ( tmp , 1 , j ) else
18176: LD_ADDR_VAR 0 19
18180: PUSH
18181: LD_VAR 0 19
18185: PPUSH
18186: LD_INT 1
18188: PPUSH
18189: LD_VAR 0 9
18193: PPUSH
18194: CALL_OW 2
18198: ST_TO_ADDR
18199: GO 18230
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18201: LD_ADDR_VAR 0 19
18205: PUSH
18206: LD_VAR 0 19
18210: PPUSH
18211: LD_VAR 0 19
18215: PUSH
18216: LD_INT 1
18218: PLUS
18219: PPUSH
18220: LD_VAR 0 9
18224: PPUSH
18225: CALL_OW 2
18229: ST_TO_ADDR
18230: GO 18158
18232: POP
18233: POP
// if tmp then
18234: LD_VAR 0 19
18238: IFFALSE 18250
// f := tmp ;
18240: LD_ADDR_VAR 0 12
18244: PUSH
18245: LD_VAR 0 19
18249: ST_TO_ADDR
// end ; x := personel [ i ] ;
18250: LD_ADDR_VAR 0 13
18254: PUSH
18255: LD_VAR 0 6
18259: PUSH
18260: LD_VAR 0 8
18264: ARRAY
18265: ST_TO_ADDR
// if x = - 1 then
18266: LD_VAR 0 13
18270: PUSH
18271: LD_INT 1
18273: NEG
18274: EQUAL
18275: IFFALSE 18484
// begin for j in f do
18277: LD_ADDR_VAR 0 9
18281: PUSH
18282: LD_VAR 0 12
18286: PUSH
18287: FOR_IN
18288: IFFALSE 18480
// repeat InitHc ;
18290: CALL_OW 19
// if GetBType ( j ) = b_barracks then
18294: LD_VAR 0 9
18298: PPUSH
18299: CALL_OW 266
18303: PUSH
18304: LD_INT 5
18306: EQUAL
18307: IFFALSE 18377
// begin if UnitsInside ( j ) < 3 then
18309: LD_VAR 0 9
18313: PPUSH
18314: CALL_OW 313
18318: PUSH
18319: LD_INT 3
18321: LESS
18322: IFFALSE 18358
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18324: LD_INT 0
18326: PPUSH
18327: LD_INT 5
18329: PUSH
18330: LD_INT 8
18332: PUSH
18333: LD_INT 9
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: PUSH
18341: LD_VAR 0 17
18345: ARRAY
18346: PPUSH
18347: LD_VAR 0 4
18351: PPUSH
18352: CALL_OW 380
18356: GO 18375
// PrepareHuman ( false , i , skill ) ;
18358: LD_INT 0
18360: PPUSH
18361: LD_VAR 0 8
18365: PPUSH
18366: LD_VAR 0 4
18370: PPUSH
18371: CALL_OW 380
// end else
18375: GO 18394
// PrepareHuman ( false , i , skill ) ;
18377: LD_INT 0
18379: PPUSH
18380: LD_VAR 0 8
18384: PPUSH
18385: LD_VAR 0 4
18389: PPUSH
18390: CALL_OW 380
// un := CreateHuman ;
18394: LD_ADDR_VAR 0 14
18398: PUSH
18399: CALL_OW 44
18403: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18404: LD_ADDR_VAR 0 7
18408: PUSH
18409: LD_VAR 0 7
18413: PPUSH
18414: LD_INT 1
18416: PPUSH
18417: LD_VAR 0 14
18421: PPUSH
18422: CALL_OW 2
18426: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
18427: LD_VAR 0 14
18431: PPUSH
18432: LD_VAR 0 9
18436: PPUSH
18437: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
18441: LD_VAR 0 9
18445: PPUSH
18446: CALL_OW 313
18450: PUSH
18451: LD_INT 6
18453: EQUAL
18454: PUSH
18455: LD_VAR 0 9
18459: PPUSH
18460: CALL_OW 266
18464: PUSH
18465: LD_INT 32
18467: PUSH
18468: LD_INT 31
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: IN
18475: OR
18476: IFFALSE 18290
18478: GO 18287
18480: POP
18481: POP
// end else
18482: GO 18864
// for j = 1 to x do
18484: LD_ADDR_VAR 0 9
18488: PUSH
18489: DOUBLE
18490: LD_INT 1
18492: DEC
18493: ST_TO_ADDR
18494: LD_VAR 0 13
18498: PUSH
18499: FOR_TO
18500: IFFALSE 18862
// begin InitHc ;
18502: CALL_OW 19
// if not f then
18506: LD_VAR 0 12
18510: NOT
18511: IFFALSE 18600
// begin PrepareHuman ( false , i , skill ) ;
18513: LD_INT 0
18515: PPUSH
18516: LD_VAR 0 8
18520: PPUSH
18521: LD_VAR 0 4
18525: PPUSH
18526: CALL_OW 380
// un := CreateHuman ;
18530: LD_ADDR_VAR 0 14
18534: PUSH
18535: CALL_OW 44
18539: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18540: LD_ADDR_VAR 0 7
18544: PUSH
18545: LD_VAR 0 7
18549: PPUSH
18550: LD_INT 1
18552: PPUSH
18553: LD_VAR 0 14
18557: PPUSH
18558: CALL_OW 2
18562: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18563: LD_VAR 0 14
18567: PPUSH
18568: LD_VAR 0 1
18572: PPUSH
18573: CALL_OW 250
18577: PPUSH
18578: LD_VAR 0 1
18582: PPUSH
18583: CALL_OW 251
18587: PPUSH
18588: LD_INT 10
18590: PPUSH
18591: LD_INT 0
18593: PPUSH
18594: CALL_OW 50
// continue ;
18598: GO 18499
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
18600: LD_VAR 0 12
18604: PUSH
18605: LD_INT 1
18607: ARRAY
18608: PPUSH
18609: CALL_OW 313
18613: PUSH
18614: LD_VAR 0 12
18618: PUSH
18619: LD_INT 1
18621: ARRAY
18622: PPUSH
18623: CALL_OW 266
18627: PUSH
18628: LD_INT 32
18630: PUSH
18631: LD_INT 31
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: IN
18638: AND
18639: PUSH
18640: LD_VAR 0 12
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 313
18653: PUSH
18654: LD_INT 6
18656: EQUAL
18657: OR
18658: IFFALSE 18678
// f := Delete ( f , 1 ) ;
18660: LD_ADDR_VAR 0 12
18664: PUSH
18665: LD_VAR 0 12
18669: PPUSH
18670: LD_INT 1
18672: PPUSH
18673: CALL_OW 3
18677: ST_TO_ADDR
// if not f then
18678: LD_VAR 0 12
18682: NOT
18683: IFFALSE 18701
// begin x := x + 2 ;
18685: LD_ADDR_VAR 0 13
18689: PUSH
18690: LD_VAR 0 13
18694: PUSH
18695: LD_INT 2
18697: PLUS
18698: ST_TO_ADDR
// continue ;
18699: GO 18499
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
18701: LD_VAR 0 12
18705: PUSH
18706: LD_INT 1
18708: ARRAY
18709: PPUSH
18710: CALL_OW 266
18714: PUSH
18715: LD_INT 5
18717: EQUAL
18718: IFFALSE 18792
// begin if UnitsInside ( f [ 1 ] ) < 3 then
18720: LD_VAR 0 12
18724: PUSH
18725: LD_INT 1
18727: ARRAY
18728: PPUSH
18729: CALL_OW 313
18733: PUSH
18734: LD_INT 3
18736: LESS
18737: IFFALSE 18773
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18739: LD_INT 0
18741: PPUSH
18742: LD_INT 5
18744: PUSH
18745: LD_INT 8
18747: PUSH
18748: LD_INT 9
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: LIST
18755: PUSH
18756: LD_VAR 0 17
18760: ARRAY
18761: PPUSH
18762: LD_VAR 0 4
18766: PPUSH
18767: CALL_OW 380
18771: GO 18790
// PrepareHuman ( false , i , skill ) ;
18773: LD_INT 0
18775: PPUSH
18776: LD_VAR 0 8
18780: PPUSH
18781: LD_VAR 0 4
18785: PPUSH
18786: CALL_OW 380
// end else
18790: GO 18809
// PrepareHuman ( false , i , skill ) ;
18792: LD_INT 0
18794: PPUSH
18795: LD_VAR 0 8
18799: PPUSH
18800: LD_VAR 0 4
18804: PPUSH
18805: CALL_OW 380
// un := CreateHuman ;
18809: LD_ADDR_VAR 0 14
18813: PUSH
18814: CALL_OW 44
18818: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18819: LD_ADDR_VAR 0 7
18823: PUSH
18824: LD_VAR 0 7
18828: PPUSH
18829: LD_INT 1
18831: PPUSH
18832: LD_VAR 0 14
18836: PPUSH
18837: CALL_OW 2
18841: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
18842: LD_VAR 0 14
18846: PPUSH
18847: LD_VAR 0 12
18851: PUSH
18852: LD_INT 1
18854: ARRAY
18855: PPUSH
18856: CALL_OW 52
// end ;
18860: GO 18499
18862: POP
18863: POP
// end ;
18864: GO 17801
18866: POP
18867: POP
// result := result ^ buildings ;
18868: LD_ADDR_VAR 0 7
18872: PUSH
18873: LD_VAR 0 7
18877: PUSH
18878: LD_VAR 0 18
18882: ADD
18883: ST_TO_ADDR
// end else
18884: GO 19027
// begin for i = 1 to personel do
18886: LD_ADDR_VAR 0 8
18890: PUSH
18891: DOUBLE
18892: LD_INT 1
18894: DEC
18895: ST_TO_ADDR
18896: LD_VAR 0 6
18900: PUSH
18901: FOR_TO
18902: IFFALSE 19025
// begin if i > 4 then
18904: LD_VAR 0 8
18908: PUSH
18909: LD_INT 4
18911: GREATER
18912: IFFALSE 18916
// break ;
18914: GO 19025
// x := personel [ i ] ;
18916: LD_ADDR_VAR 0 13
18920: PUSH
18921: LD_VAR 0 6
18925: PUSH
18926: LD_VAR 0 8
18930: ARRAY
18931: ST_TO_ADDR
// if x = - 1 then
18932: LD_VAR 0 13
18936: PUSH
18937: LD_INT 1
18939: NEG
18940: EQUAL
18941: IFFALSE 18945
// continue ;
18943: GO 18901
// PrepareHuman ( false , i , skill ) ;
18945: LD_INT 0
18947: PPUSH
18948: LD_VAR 0 8
18952: PPUSH
18953: LD_VAR 0 4
18957: PPUSH
18958: CALL_OW 380
// un := CreateHuman ;
18962: LD_ADDR_VAR 0 14
18966: PUSH
18967: CALL_OW 44
18971: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18972: LD_VAR 0 14
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: CALL_OW 250
18986: PPUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: CALL_OW 251
18996: PPUSH
18997: LD_INT 10
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: CALL_OW 50
// result := result ^ un ;
19007: LD_ADDR_VAR 0 7
19011: PUSH
19012: LD_VAR 0 7
19016: PUSH
19017: LD_VAR 0 14
19021: ADD
19022: ST_TO_ADDR
// end ;
19023: GO 18901
19025: POP
19026: POP
// end ; end ;
19027: LD_VAR 0 7
19031: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19032: LD_INT 0
19034: PPUSH
19035: PPUSH
19036: PPUSH
19037: PPUSH
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
19042: PPUSH
19043: PPUSH
19044: PPUSH
19045: PPUSH
19046: PPUSH
19047: PPUSH
19048: PPUSH
19049: PPUSH
// result := false ;
19050: LD_ADDR_VAR 0 3
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19058: LD_VAR 0 1
19062: NOT
19063: PUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: CALL_OW 266
19073: PUSH
19074: LD_INT 32
19076: PUSH
19077: LD_INT 33
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: IN
19084: NOT
19085: OR
19086: IFFALSE 19090
// exit ;
19088: GO 20199
// nat := GetNation ( tower ) ;
19090: LD_ADDR_VAR 0 12
19094: PUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: CALL_OW 248
19104: ST_TO_ADDR
// side := GetSide ( tower ) ;
19105: LD_ADDR_VAR 0 16
19109: PUSH
19110: LD_VAR 0 1
19114: PPUSH
19115: CALL_OW 255
19119: ST_TO_ADDR
// x := GetX ( tower ) ;
19120: LD_ADDR_VAR 0 10
19124: PUSH
19125: LD_VAR 0 1
19129: PPUSH
19130: CALL_OW 250
19134: ST_TO_ADDR
// y := GetY ( tower ) ;
19135: LD_ADDR_VAR 0 11
19139: PUSH
19140: LD_VAR 0 1
19144: PPUSH
19145: CALL_OW 251
19149: ST_TO_ADDR
// if not x or not y then
19150: LD_VAR 0 10
19154: NOT
19155: PUSH
19156: LD_VAR 0 11
19160: NOT
19161: OR
19162: IFFALSE 19166
// exit ;
19164: GO 20199
// weapon := 0 ;
19166: LD_ADDR_VAR 0 18
19170: PUSH
19171: LD_INT 0
19173: ST_TO_ADDR
// fac_list := [ ] ;
19174: LD_ADDR_VAR 0 17
19178: PUSH
19179: EMPTY
19180: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19181: LD_ADDR_VAR 0 6
19185: PUSH
19186: LD_VAR 0 1
19190: PPUSH
19191: CALL_OW 274
19195: PPUSH
19196: LD_VAR 0 2
19200: PPUSH
19201: LD_INT 0
19203: PPUSH
19204: CALL 16770 0 3
19208: PPUSH
19209: LD_INT 30
19211: PUSH
19212: LD_INT 3
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PPUSH
19219: CALL_OW 72
19223: ST_TO_ADDR
// if not factories then
19224: LD_VAR 0 6
19228: NOT
19229: IFFALSE 19233
// exit ;
19231: GO 20199
// for i in factories do
19233: LD_ADDR_VAR 0 8
19237: PUSH
19238: LD_VAR 0 6
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19269
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19246: LD_ADDR_VAR 0 17
19250: PUSH
19251: LD_VAR 0 17
19255: PUSH
19256: LD_VAR 0 8
19260: PPUSH
19261: CALL_OW 478
19265: UNION
19266: ST_TO_ADDR
19267: GO 19243
19269: POP
19270: POP
// if not fac_list then
19271: LD_VAR 0 17
19275: NOT
19276: IFFALSE 19280
// exit ;
19278: GO 20199
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
19280: LD_ADDR_VAR 0 5
19284: PUSH
19285: LD_INT 4
19287: PUSH
19288: LD_INT 5
19290: PUSH
19291: LD_INT 9
19293: PUSH
19294: LD_INT 10
19296: PUSH
19297: LD_INT 6
19299: PUSH
19300: LD_INT 7
19302: PUSH
19303: LD_INT 11
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: PUSH
19315: LD_INT 27
19317: PUSH
19318: LD_INT 28
19320: PUSH
19321: LD_INT 26
19323: PUSH
19324: LD_INT 30
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 43
19335: PUSH
19336: LD_INT 44
19338: PUSH
19339: LD_INT 46
19341: PUSH
19342: LD_INT 45
19344: PUSH
19345: LD_INT 47
19347: PUSH
19348: LD_INT 49
19350: PUSH
19351: EMPTY
19352: LIST
19353: LIST
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: PUSH
19359: EMPTY
19360: LIST
19361: LIST
19362: LIST
19363: PUSH
19364: LD_VAR 0 12
19368: ARRAY
19369: ST_TO_ADDR
// list := list isect fac_list ;
19370: LD_ADDR_VAR 0 5
19374: PUSH
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 17
19384: ISECT
19385: ST_TO_ADDR
// if not list then
19386: LD_VAR 0 5
19390: NOT
19391: IFFALSE 19395
// exit ;
19393: GO 20199
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
19395: LD_VAR 0 12
19399: PUSH
19400: LD_INT 3
19402: EQUAL
19403: PUSH
19404: LD_INT 49
19406: PUSH
19407: LD_VAR 0 5
19411: IN
19412: AND
19413: PUSH
19414: LD_INT 31
19416: PPUSH
19417: LD_VAR 0 16
19421: PPUSH
19422: CALL_OW 321
19426: PUSH
19427: LD_INT 2
19429: EQUAL
19430: AND
19431: IFFALSE 19491
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
19433: LD_INT 22
19435: PUSH
19436: LD_VAR 0 16
19440: PUSH
19441: EMPTY
19442: LIST
19443: LIST
19444: PUSH
19445: LD_INT 35
19447: PUSH
19448: LD_INT 49
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 91
19457: PUSH
19458: LD_VAR 0 1
19462: PUSH
19463: LD_INT 10
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: LIST
19475: PPUSH
19476: CALL_OW 69
19480: NOT
19481: IFFALSE 19491
// weapon := ru_time_lapser ;
19483: LD_ADDR_VAR 0 18
19487: PUSH
19488: LD_INT 49
19490: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
19491: LD_VAR 0 12
19495: PUSH
19496: LD_INT 1
19498: PUSH
19499: LD_INT 2
19501: PUSH
19502: EMPTY
19503: LIST
19504: LIST
19505: IN
19506: PUSH
19507: LD_INT 11
19509: PUSH
19510: LD_VAR 0 5
19514: IN
19515: PUSH
19516: LD_INT 30
19518: PUSH
19519: LD_VAR 0 5
19523: IN
19524: OR
19525: AND
19526: PUSH
19527: LD_INT 6
19529: PPUSH
19530: LD_VAR 0 16
19534: PPUSH
19535: CALL_OW 321
19539: PUSH
19540: LD_INT 2
19542: EQUAL
19543: AND
19544: IFFALSE 19709
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
19546: LD_INT 22
19548: PUSH
19549: LD_VAR 0 16
19553: PUSH
19554: EMPTY
19555: LIST
19556: LIST
19557: PUSH
19558: LD_INT 2
19560: PUSH
19561: LD_INT 35
19563: PUSH
19564: LD_INT 11
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 35
19573: PUSH
19574: LD_INT 30
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 91
19588: PUSH
19589: LD_VAR 0 1
19593: PUSH
19594: LD_INT 18
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: LIST
19606: PPUSH
19607: CALL_OW 69
19611: NOT
19612: PUSH
19613: LD_INT 22
19615: PUSH
19616: LD_VAR 0 16
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 2
19627: PUSH
19628: LD_INT 30
19630: PUSH
19631: LD_INT 32
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 30
19640: PUSH
19641: LD_INT 33
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PUSH
19653: LD_INT 91
19655: PUSH
19656: LD_VAR 0 1
19660: PUSH
19661: LD_INT 12
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: LIST
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: LIST
19673: PUSH
19674: EMPTY
19675: LIST
19676: PPUSH
19677: CALL_OW 69
19681: PUSH
19682: LD_INT 2
19684: GREATER
19685: AND
19686: IFFALSE 19709
// weapon := [ us_radar , ar_radar ] [ nat ] ;
19688: LD_ADDR_VAR 0 18
19692: PUSH
19693: LD_INT 11
19695: PUSH
19696: LD_INT 30
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_VAR 0 12
19707: ARRAY
19708: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
19709: LD_VAR 0 18
19713: NOT
19714: PUSH
19715: LD_INT 40
19717: PPUSH
19718: LD_VAR 0 16
19722: PPUSH
19723: CALL_OW 321
19727: PUSH
19728: LD_INT 2
19730: EQUAL
19731: AND
19732: PUSH
19733: LD_INT 7
19735: PUSH
19736: LD_VAR 0 5
19740: IN
19741: PUSH
19742: LD_INT 28
19744: PUSH
19745: LD_VAR 0 5
19749: IN
19750: OR
19751: PUSH
19752: LD_INT 45
19754: PUSH
19755: LD_VAR 0 5
19759: IN
19760: OR
19761: AND
19762: IFFALSE 20016
// begin hex := GetHexInfo ( x , y ) ;
19764: LD_ADDR_VAR 0 4
19768: PUSH
19769: LD_VAR 0 10
19773: PPUSH
19774: LD_VAR 0 11
19778: PPUSH
19779: CALL_OW 546
19783: ST_TO_ADDR
// if hex [ 1 ] then
19784: LD_VAR 0 4
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: IFFALSE 19796
// exit ;
19794: GO 20199
// height := hex [ 2 ] ;
19796: LD_ADDR_VAR 0 15
19800: PUSH
19801: LD_VAR 0 4
19805: PUSH
19806: LD_INT 2
19808: ARRAY
19809: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
19810: LD_ADDR_VAR 0 14
19814: PUSH
19815: LD_INT 0
19817: PUSH
19818: LD_INT 2
19820: PUSH
19821: LD_INT 3
19823: PUSH
19824: LD_INT 5
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: LIST
19831: LIST
19832: ST_TO_ADDR
// for i in tmp do
19833: LD_ADDR_VAR 0 8
19837: PUSH
19838: LD_VAR 0 14
19842: PUSH
19843: FOR_IN
19844: IFFALSE 20014
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
19846: LD_ADDR_VAR 0 9
19850: PUSH
19851: LD_VAR 0 10
19855: PPUSH
19856: LD_VAR 0 8
19860: PPUSH
19861: LD_INT 5
19863: PPUSH
19864: CALL_OW 272
19868: PUSH
19869: LD_VAR 0 11
19873: PPUSH
19874: LD_VAR 0 8
19878: PPUSH
19879: LD_INT 5
19881: PPUSH
19882: CALL_OW 273
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
19891: LD_VAR 0 9
19895: PUSH
19896: LD_INT 1
19898: ARRAY
19899: PPUSH
19900: LD_VAR 0 9
19904: PUSH
19905: LD_INT 2
19907: ARRAY
19908: PPUSH
19909: CALL_OW 488
19913: IFFALSE 20012
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
19915: LD_ADDR_VAR 0 4
19919: PUSH
19920: LD_VAR 0 9
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PPUSH
19929: LD_VAR 0 9
19933: PUSH
19934: LD_INT 2
19936: ARRAY
19937: PPUSH
19938: CALL_OW 546
19942: ST_TO_ADDR
// if hex [ 1 ] then
19943: LD_VAR 0 4
19947: PUSH
19948: LD_INT 1
19950: ARRAY
19951: IFFALSE 19955
// continue ;
19953: GO 19843
// h := hex [ 2 ] ;
19955: LD_ADDR_VAR 0 13
19959: PUSH
19960: LD_VAR 0 4
19964: PUSH
19965: LD_INT 2
19967: ARRAY
19968: ST_TO_ADDR
// if h + 7 < height then
19969: LD_VAR 0 13
19973: PUSH
19974: LD_INT 7
19976: PLUS
19977: PUSH
19978: LD_VAR 0 15
19982: LESS
19983: IFFALSE 20012
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
19985: LD_ADDR_VAR 0 18
19989: PUSH
19990: LD_INT 7
19992: PUSH
19993: LD_INT 28
19995: PUSH
19996: LD_INT 45
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: LIST
20003: PUSH
20004: LD_VAR 0 12
20008: ARRAY
20009: ST_TO_ADDR
// break ;
20010: GO 20014
// end ; end ; end ;
20012: GO 19843
20014: POP
20015: POP
// end ; if not weapon then
20016: LD_VAR 0 18
20020: NOT
20021: IFFALSE 20081
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20023: LD_ADDR_VAR 0 5
20027: PUSH
20028: LD_VAR 0 5
20032: PUSH
20033: LD_INT 11
20035: PUSH
20036: LD_INT 30
20038: PUSH
20039: LD_INT 49
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: LIST
20046: DIFF
20047: ST_TO_ADDR
// if not list then
20048: LD_VAR 0 5
20052: NOT
20053: IFFALSE 20057
// exit ;
20055: GO 20199
// weapon := list [ rand ( 1 , list ) ] ;
20057: LD_ADDR_VAR 0 18
20061: PUSH
20062: LD_VAR 0 5
20066: PUSH
20067: LD_INT 1
20069: PPUSH
20070: LD_VAR 0 5
20074: PPUSH
20075: CALL_OW 12
20079: ARRAY
20080: ST_TO_ADDR
// end ; if weapon then
20081: LD_VAR 0 18
20085: IFFALSE 20199
// begin tmp := CostOfWeapon ( weapon ) ;
20087: LD_ADDR_VAR 0 14
20091: PUSH
20092: LD_VAR 0 18
20096: PPUSH
20097: CALL_OW 451
20101: ST_TO_ADDR
// j := GetBase ( tower ) ;
20102: LD_ADDR_VAR 0 9
20106: PUSH
20107: LD_VAR 0 1
20111: PPUSH
20112: CALL_OW 274
20116: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20117: LD_VAR 0 9
20121: PPUSH
20122: LD_INT 1
20124: PPUSH
20125: CALL_OW 275
20129: PUSH
20130: LD_VAR 0 14
20134: PUSH
20135: LD_INT 1
20137: ARRAY
20138: GREATEREQUAL
20139: PUSH
20140: LD_VAR 0 9
20144: PPUSH
20145: LD_INT 2
20147: PPUSH
20148: CALL_OW 275
20152: PUSH
20153: LD_VAR 0 14
20157: PUSH
20158: LD_INT 2
20160: ARRAY
20161: GREATEREQUAL
20162: AND
20163: PUSH
20164: LD_VAR 0 9
20168: PPUSH
20169: LD_INT 3
20171: PPUSH
20172: CALL_OW 275
20176: PUSH
20177: LD_VAR 0 14
20181: PUSH
20182: LD_INT 3
20184: ARRAY
20185: GREATEREQUAL
20186: AND
20187: IFFALSE 20199
// result := weapon ;
20189: LD_ADDR_VAR 0 3
20193: PUSH
20194: LD_VAR 0 18
20198: ST_TO_ADDR
// end ; end ;
20199: LD_VAR 0 3
20203: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20204: LD_INT 0
20206: PPUSH
20207: PPUSH
// result := true ;
20208: LD_ADDR_VAR 0 3
20212: PUSH
20213: LD_INT 1
20215: ST_TO_ADDR
// if array1 = array2 then
20216: LD_VAR 0 1
20220: PUSH
20221: LD_VAR 0 2
20225: EQUAL
20226: IFFALSE 20286
// begin for i = 1 to array1 do
20228: LD_ADDR_VAR 0 4
20232: PUSH
20233: DOUBLE
20234: LD_INT 1
20236: DEC
20237: ST_TO_ADDR
20238: LD_VAR 0 1
20242: PUSH
20243: FOR_TO
20244: IFFALSE 20282
// if array1 [ i ] <> array2 [ i ] then
20246: LD_VAR 0 1
20250: PUSH
20251: LD_VAR 0 4
20255: ARRAY
20256: PUSH
20257: LD_VAR 0 2
20261: PUSH
20262: LD_VAR 0 4
20266: ARRAY
20267: NONEQUAL
20268: IFFALSE 20280
// begin result := false ;
20270: LD_ADDR_VAR 0 3
20274: PUSH
20275: LD_INT 0
20277: ST_TO_ADDR
// break ;
20278: GO 20282
// end ;
20280: GO 20243
20282: POP
20283: POP
// end else
20284: GO 20294
// result := false ;
20286: LD_ADDR_VAR 0 3
20290: PUSH
20291: LD_INT 0
20293: ST_TO_ADDR
// end ;
20294: LD_VAR 0 3
20298: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
20299: LD_INT 0
20301: PPUSH
20302: PPUSH
// if not array1 or not array2 then
20303: LD_VAR 0 1
20307: NOT
20308: PUSH
20309: LD_VAR 0 2
20313: NOT
20314: OR
20315: IFFALSE 20319
// exit ;
20317: GO 20383
// result := true ;
20319: LD_ADDR_VAR 0 3
20323: PUSH
20324: LD_INT 1
20326: ST_TO_ADDR
// for i = 1 to array1 do
20327: LD_ADDR_VAR 0 4
20331: PUSH
20332: DOUBLE
20333: LD_INT 1
20335: DEC
20336: ST_TO_ADDR
20337: LD_VAR 0 1
20341: PUSH
20342: FOR_TO
20343: IFFALSE 20381
// if array1 [ i ] <> array2 [ i ] then
20345: LD_VAR 0 1
20349: PUSH
20350: LD_VAR 0 4
20354: ARRAY
20355: PUSH
20356: LD_VAR 0 2
20360: PUSH
20361: LD_VAR 0 4
20365: ARRAY
20366: NONEQUAL
20367: IFFALSE 20379
// begin result := false ;
20369: LD_ADDR_VAR 0 3
20373: PUSH
20374: LD_INT 0
20376: ST_TO_ADDR
// break ;
20377: GO 20381
// end ;
20379: GO 20342
20381: POP
20382: POP
// end ;
20383: LD_VAR 0 3
20387: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
20388: LD_INT 0
20390: PPUSH
20391: PPUSH
20392: PPUSH
// pom := GetBase ( fac ) ;
20393: LD_ADDR_VAR 0 5
20397: PUSH
20398: LD_VAR 0 1
20402: PPUSH
20403: CALL_OW 274
20407: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
20408: LD_ADDR_VAR 0 4
20412: PUSH
20413: LD_VAR 0 2
20417: PUSH
20418: LD_INT 1
20420: ARRAY
20421: PPUSH
20422: LD_VAR 0 2
20426: PUSH
20427: LD_INT 2
20429: ARRAY
20430: PPUSH
20431: LD_VAR 0 2
20435: PUSH
20436: LD_INT 3
20438: ARRAY
20439: PPUSH
20440: LD_VAR 0 2
20444: PUSH
20445: LD_INT 4
20447: ARRAY
20448: PPUSH
20449: CALL_OW 449
20453: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_VAR 0 5
20463: PPUSH
20464: LD_INT 1
20466: PPUSH
20467: CALL_OW 275
20471: PUSH
20472: LD_VAR 0 4
20476: PUSH
20477: LD_INT 1
20479: ARRAY
20480: GREATEREQUAL
20481: PUSH
20482: LD_VAR 0 5
20486: PPUSH
20487: LD_INT 2
20489: PPUSH
20490: CALL_OW 275
20494: PUSH
20495: LD_VAR 0 4
20499: PUSH
20500: LD_INT 2
20502: ARRAY
20503: GREATEREQUAL
20504: AND
20505: PUSH
20506: LD_VAR 0 5
20510: PPUSH
20511: LD_INT 3
20513: PPUSH
20514: CALL_OW 275
20518: PUSH
20519: LD_VAR 0 4
20523: PUSH
20524: LD_INT 3
20526: ARRAY
20527: GREATEREQUAL
20528: AND
20529: ST_TO_ADDR
// end ;
20530: LD_VAR 0 3
20534: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
20535: LD_INT 0
20537: PPUSH
20538: PPUSH
20539: PPUSH
20540: PPUSH
// pom := GetBase ( building ) ;
20541: LD_ADDR_VAR 0 3
20545: PUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 274
20555: ST_TO_ADDR
// if not pom then
20556: LD_VAR 0 3
20560: NOT
20561: IFFALSE 20565
// exit ;
20563: GO 20735
// btype := GetBType ( building ) ;
20565: LD_ADDR_VAR 0 5
20569: PUSH
20570: LD_VAR 0 1
20574: PPUSH
20575: CALL_OW 266
20579: ST_TO_ADDR
// if btype = b_armoury then
20580: LD_VAR 0 5
20584: PUSH
20585: LD_INT 4
20587: EQUAL
20588: IFFALSE 20598
// btype := b_barracks ;
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: LD_INT 5
20597: ST_TO_ADDR
// if btype = b_depot then
20598: LD_VAR 0 5
20602: PUSH
20603: LD_INT 0
20605: EQUAL
20606: IFFALSE 20616
// btype := b_warehouse ;
20608: LD_ADDR_VAR 0 5
20612: PUSH
20613: LD_INT 1
20615: ST_TO_ADDR
// if btype = b_workshop then
20616: LD_VAR 0 5
20620: PUSH
20621: LD_INT 2
20623: EQUAL
20624: IFFALSE 20634
// btype := b_factory ;
20626: LD_ADDR_VAR 0 5
20630: PUSH
20631: LD_INT 3
20633: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20634: LD_ADDR_VAR 0 4
20638: PUSH
20639: LD_VAR 0 5
20643: PPUSH
20644: LD_VAR 0 1
20648: PPUSH
20649: CALL_OW 248
20653: PPUSH
20654: CALL_OW 450
20658: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20659: LD_ADDR_VAR 0 2
20663: PUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: LD_INT 1
20671: PPUSH
20672: CALL_OW 275
20676: PUSH
20677: LD_VAR 0 4
20681: PUSH
20682: LD_INT 1
20684: ARRAY
20685: GREATEREQUAL
20686: PUSH
20687: LD_VAR 0 3
20691: PPUSH
20692: LD_INT 2
20694: PPUSH
20695: CALL_OW 275
20699: PUSH
20700: LD_VAR 0 4
20704: PUSH
20705: LD_INT 2
20707: ARRAY
20708: GREATEREQUAL
20709: AND
20710: PUSH
20711: LD_VAR 0 3
20715: PPUSH
20716: LD_INT 3
20718: PPUSH
20719: CALL_OW 275
20723: PUSH
20724: LD_VAR 0 4
20728: PUSH
20729: LD_INT 3
20731: ARRAY
20732: GREATEREQUAL
20733: AND
20734: ST_TO_ADDR
// end ;
20735: LD_VAR 0 2
20739: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// pom := GetBase ( building ) ;
20745: LD_ADDR_VAR 0 4
20749: PUSH
20750: LD_VAR 0 1
20754: PPUSH
20755: CALL_OW 274
20759: ST_TO_ADDR
// if not pom then
20760: LD_VAR 0 4
20764: NOT
20765: IFFALSE 20769
// exit ;
20767: GO 20870
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20769: LD_ADDR_VAR 0 5
20773: PUSH
20774: LD_VAR 0 2
20778: PPUSH
20779: LD_VAR 0 1
20783: PPUSH
20784: CALL_OW 248
20788: PPUSH
20789: CALL_OW 450
20793: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20794: LD_ADDR_VAR 0 3
20798: PUSH
20799: LD_VAR 0 4
20803: PPUSH
20804: LD_INT 1
20806: PPUSH
20807: CALL_OW 275
20811: PUSH
20812: LD_VAR 0 5
20816: PUSH
20817: LD_INT 1
20819: ARRAY
20820: GREATEREQUAL
20821: PUSH
20822: LD_VAR 0 4
20826: PPUSH
20827: LD_INT 2
20829: PPUSH
20830: CALL_OW 275
20834: PUSH
20835: LD_VAR 0 5
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: GREATEREQUAL
20844: AND
20845: PUSH
20846: LD_VAR 0 4
20850: PPUSH
20851: LD_INT 3
20853: PPUSH
20854: CALL_OW 275
20858: PUSH
20859: LD_VAR 0 5
20863: PUSH
20864: LD_INT 3
20866: ARRAY
20867: GREATEREQUAL
20868: AND
20869: ST_TO_ADDR
// end ;
20870: LD_VAR 0 3
20874: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking export globalGameSaveCounter ; every 0 0$1 do
20875: GO 20877
20877: DISABLE
// begin enable ;
20878: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
20879: LD_STRING updateTimer(
20881: PUSH
20882: LD_OWVAR 1
20886: STR
20887: PUSH
20888: LD_STRING );
20890: STR
20891: PPUSH
20892: CALL_OW 559
// end ;
20896: END
// every 0 0$1 do
20897: GO 20899
20899: DISABLE
// begin globalGameSaveCounter := 0 ;
20900: LD_ADDR_EXP 28
20904: PUSH
20905: LD_INT 0
20907: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
20908: LD_STRING setGameSaveCounter(0)
20910: PPUSH
20911: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
20915: LD_STRING initStreamRollete();
20917: PPUSH
20918: CALL_OW 559
// InitStreamMode ;
20922: CALL 22248 0 0
// DefineStreamItems ( false ) ;
20926: LD_INT 0
20928: PPUSH
20929: CALL 22712 0 1
// end ;
20933: END
// export function SOS_MapStart ( ) ; begin
20934: LD_INT 0
20936: PPUSH
// if streamModeActive then
20937: LD_EXP 29
20941: IFFALSE 20950
// DefineStreamItems ( true ) ;
20943: LD_INT 1
20945: PPUSH
20946: CALL 22712 0 1
// UpdateLuaVariables ( ) ;
20950: CALL 20967 0 0
// UpdateFactoryWaypoints ( ) ;
20954: CALL 35573 0 0
// UpdateWarehouseGatheringPoints ( ) ;
20958: CALL 35830 0 0
// end ;
20962: LD_VAR 0 1
20966: RET
// function UpdateLuaVariables ( ) ; begin
20967: LD_INT 0
20969: PPUSH
// if globalGameSaveCounter then
20970: LD_EXP 28
20974: IFFALSE 21008
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
20976: LD_ADDR_EXP 28
20980: PUSH
20981: LD_EXP 28
20985: PPUSH
20986: NOP4
20990: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
20991: LD_STRING setGameSaveCounter(
20993: PUSH
20994: LD_EXP 28
20998: STR
20999: PUSH
21000: LD_STRING )
21002: STR
21003: PPUSH
21004: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
21008: LD_STRING setGameDifficulty(
21010: PUSH
21011: LD_OWVAR 67
21015: STR
21016: PUSH
21017: LD_STRING )
21019: STR
21020: PPUSH
21021: CALL_OW 559
// end ;
21025: LD_VAR 0 1
21029: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
21030: LD_INT 0
21032: PPUSH
// if p2 = stream_mode then
21033: LD_VAR 0 2
21037: PUSH
21038: LD_INT 100
21040: EQUAL
21041: IFFALSE 22044
// begin if not StreamModeActive then
21043: LD_EXP 29
21047: NOT
21048: IFFALSE 21058
// StreamModeActive := true ;
21050: LD_ADDR_EXP 29
21054: PUSH
21055: LD_INT 1
21057: ST_TO_ADDR
// if p3 = 0 then
21058: LD_VAR 0 3
21062: PUSH
21063: LD_INT 0
21065: EQUAL
21066: IFFALSE 21072
// InitStreamMode ;
21068: CALL 22248 0 0
// if p3 = 1 then
21072: LD_VAR 0 3
21076: PUSH
21077: LD_INT 1
21079: EQUAL
21080: IFFALSE 21090
// sRocket := true ;
21082: LD_ADDR_EXP 34
21086: PUSH
21087: LD_INT 1
21089: ST_TO_ADDR
// if p3 = 2 then
21090: LD_VAR 0 3
21094: PUSH
21095: LD_INT 2
21097: EQUAL
21098: IFFALSE 21108
// sSpeed := true ;
21100: LD_ADDR_EXP 33
21104: PUSH
21105: LD_INT 1
21107: ST_TO_ADDR
// if p3 = 3 then
21108: LD_VAR 0 3
21112: PUSH
21113: LD_INT 3
21115: EQUAL
21116: IFFALSE 21126
// sEngine := true ;
21118: LD_ADDR_EXP 35
21122: PUSH
21123: LD_INT 1
21125: ST_TO_ADDR
// if p3 = 4 then
21126: LD_VAR 0 3
21130: PUSH
21131: LD_INT 4
21133: EQUAL
21134: IFFALSE 21144
// sSpec := true ;
21136: LD_ADDR_EXP 32
21140: PUSH
21141: LD_INT 1
21143: ST_TO_ADDR
// if p3 = 5 then
21144: LD_VAR 0 3
21148: PUSH
21149: LD_INT 5
21151: EQUAL
21152: IFFALSE 21162
// sLevel := true ;
21154: LD_ADDR_EXP 36
21158: PUSH
21159: LD_INT 1
21161: ST_TO_ADDR
// if p3 = 6 then
21162: LD_VAR 0 3
21166: PUSH
21167: LD_INT 6
21169: EQUAL
21170: IFFALSE 21180
// sArmoury := true ;
21172: LD_ADDR_EXP 37
21176: PUSH
21177: LD_INT 1
21179: ST_TO_ADDR
// if p3 = 7 then
21180: LD_VAR 0 3
21184: PUSH
21185: LD_INT 7
21187: EQUAL
21188: IFFALSE 21198
// sRadar := true ;
21190: LD_ADDR_EXP 38
21194: PUSH
21195: LD_INT 1
21197: ST_TO_ADDR
// if p3 = 8 then
21198: LD_VAR 0 3
21202: PUSH
21203: LD_INT 8
21205: EQUAL
21206: IFFALSE 21216
// sBunker := true ;
21208: LD_ADDR_EXP 39
21212: PUSH
21213: LD_INT 1
21215: ST_TO_ADDR
// if p3 = 9 then
21216: LD_VAR 0 3
21220: PUSH
21221: LD_INT 9
21223: EQUAL
21224: IFFALSE 21234
// sHack := true ;
21226: LD_ADDR_EXP 40
21230: PUSH
21231: LD_INT 1
21233: ST_TO_ADDR
// if p3 = 10 then
21234: LD_VAR 0 3
21238: PUSH
21239: LD_INT 10
21241: EQUAL
21242: IFFALSE 21252
// sFire := true ;
21244: LD_ADDR_EXP 41
21248: PUSH
21249: LD_INT 1
21251: ST_TO_ADDR
// if p3 = 11 then
21252: LD_VAR 0 3
21256: PUSH
21257: LD_INT 11
21259: EQUAL
21260: IFFALSE 21270
// sRefresh := true ;
21262: LD_ADDR_EXP 42
21266: PUSH
21267: LD_INT 1
21269: ST_TO_ADDR
// if p3 = 12 then
21270: LD_VAR 0 3
21274: PUSH
21275: LD_INT 12
21277: EQUAL
21278: IFFALSE 21288
// sExp := true ;
21280: LD_ADDR_EXP 43
21284: PUSH
21285: LD_INT 1
21287: ST_TO_ADDR
// if p3 = 13 then
21288: LD_VAR 0 3
21292: PUSH
21293: LD_INT 13
21295: EQUAL
21296: IFFALSE 21306
// sDepot := true ;
21298: LD_ADDR_EXP 44
21302: PUSH
21303: LD_INT 1
21305: ST_TO_ADDR
// if p3 = 14 then
21306: LD_VAR 0 3
21310: PUSH
21311: LD_INT 14
21313: EQUAL
21314: IFFALSE 21324
// sFlag := true ;
21316: LD_ADDR_EXP 45
21320: PUSH
21321: LD_INT 1
21323: ST_TO_ADDR
// if p3 = 15 then
21324: LD_VAR 0 3
21328: PUSH
21329: LD_INT 15
21331: EQUAL
21332: IFFALSE 21342
// sKamikadze := true ;
21334: LD_ADDR_EXP 53
21338: PUSH
21339: LD_INT 1
21341: ST_TO_ADDR
// if p3 = 16 then
21342: LD_VAR 0 3
21346: PUSH
21347: LD_INT 16
21349: EQUAL
21350: IFFALSE 21360
// sTroll := true ;
21352: LD_ADDR_EXP 54
21356: PUSH
21357: LD_INT 1
21359: ST_TO_ADDR
// if p3 = 17 then
21360: LD_VAR 0 3
21364: PUSH
21365: LD_INT 17
21367: EQUAL
21368: IFFALSE 21378
// sSlow := true ;
21370: LD_ADDR_EXP 55
21374: PUSH
21375: LD_INT 1
21377: ST_TO_ADDR
// if p3 = 18 then
21378: LD_VAR 0 3
21382: PUSH
21383: LD_INT 18
21385: EQUAL
21386: IFFALSE 21396
// sLack := true ;
21388: LD_ADDR_EXP 56
21392: PUSH
21393: LD_INT 1
21395: ST_TO_ADDR
// if p3 = 19 then
21396: LD_VAR 0 3
21400: PUSH
21401: LD_INT 19
21403: EQUAL
21404: IFFALSE 21414
// sTank := true ;
21406: LD_ADDR_EXP 58
21410: PUSH
21411: LD_INT 1
21413: ST_TO_ADDR
// if p3 = 20 then
21414: LD_VAR 0 3
21418: PUSH
21419: LD_INT 20
21421: EQUAL
21422: IFFALSE 21432
// sRemote := true ;
21424: LD_ADDR_EXP 59
21428: PUSH
21429: LD_INT 1
21431: ST_TO_ADDR
// if p3 = 21 then
21432: LD_VAR 0 3
21436: PUSH
21437: LD_INT 21
21439: EQUAL
21440: IFFALSE 21450
// sPowell := true ;
21442: LD_ADDR_EXP 60
21446: PUSH
21447: LD_INT 1
21449: ST_TO_ADDR
// if p3 = 22 then
21450: LD_VAR 0 3
21454: PUSH
21455: LD_INT 22
21457: EQUAL
21458: IFFALSE 21468
// sTeleport := true ;
21460: LD_ADDR_EXP 63
21464: PUSH
21465: LD_INT 1
21467: ST_TO_ADDR
// if p3 = 23 then
21468: LD_VAR 0 3
21472: PUSH
21473: LD_INT 23
21475: EQUAL
21476: IFFALSE 21486
// sOilTower := true ;
21478: LD_ADDR_EXP 65
21482: PUSH
21483: LD_INT 1
21485: ST_TO_ADDR
// if p3 = 24 then
21486: LD_VAR 0 3
21490: PUSH
21491: LD_INT 24
21493: EQUAL
21494: IFFALSE 21504
// sShovel := true ;
21496: LD_ADDR_EXP 66
21500: PUSH
21501: LD_INT 1
21503: ST_TO_ADDR
// if p3 = 25 then
21504: LD_VAR 0 3
21508: PUSH
21509: LD_INT 25
21511: EQUAL
21512: IFFALSE 21522
// sSheik := true ;
21514: LD_ADDR_EXP 67
21518: PUSH
21519: LD_INT 1
21521: ST_TO_ADDR
// if p3 = 26 then
21522: LD_VAR 0 3
21526: PUSH
21527: LD_INT 26
21529: EQUAL
21530: IFFALSE 21540
// sEarthquake := true ;
21532: LD_ADDR_EXP 69
21536: PUSH
21537: LD_INT 1
21539: ST_TO_ADDR
// if p3 = 27 then
21540: LD_VAR 0 3
21544: PUSH
21545: LD_INT 27
21547: EQUAL
21548: IFFALSE 21558
// sAI := true ;
21550: LD_ADDR_EXP 70
21554: PUSH
21555: LD_INT 1
21557: ST_TO_ADDR
// if p3 = 28 then
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 28
21565: EQUAL
21566: IFFALSE 21576
// sCargo := true ;
21568: LD_ADDR_EXP 73
21572: PUSH
21573: LD_INT 1
21575: ST_TO_ADDR
// if p3 = 29 then
21576: LD_VAR 0 3
21580: PUSH
21581: LD_INT 29
21583: EQUAL
21584: IFFALSE 21594
// sDLaser := true ;
21586: LD_ADDR_EXP 74
21590: PUSH
21591: LD_INT 1
21593: ST_TO_ADDR
// if p3 = 30 then
21594: LD_VAR 0 3
21598: PUSH
21599: LD_INT 30
21601: EQUAL
21602: IFFALSE 21612
// sExchange := true ;
21604: LD_ADDR_EXP 75
21608: PUSH
21609: LD_INT 1
21611: ST_TO_ADDR
// if p3 = 31 then
21612: LD_VAR 0 3
21616: PUSH
21617: LD_INT 31
21619: EQUAL
21620: IFFALSE 21630
// sFac := true ;
21622: LD_ADDR_EXP 76
21626: PUSH
21627: LD_INT 1
21629: ST_TO_ADDR
// if p3 = 32 then
21630: LD_VAR 0 3
21634: PUSH
21635: LD_INT 32
21637: EQUAL
21638: IFFALSE 21648
// sPower := true ;
21640: LD_ADDR_EXP 77
21644: PUSH
21645: LD_INT 1
21647: ST_TO_ADDR
// if p3 = 33 then
21648: LD_VAR 0 3
21652: PUSH
21653: LD_INT 33
21655: EQUAL
21656: IFFALSE 21666
// sRandom := true ;
21658: LD_ADDR_EXP 78
21662: PUSH
21663: LD_INT 1
21665: ST_TO_ADDR
// if p3 = 34 then
21666: LD_VAR 0 3
21670: PUSH
21671: LD_INT 34
21673: EQUAL
21674: IFFALSE 21684
// sShield := true ;
21676: LD_ADDR_EXP 79
21680: PUSH
21681: LD_INT 1
21683: ST_TO_ADDR
// if p3 = 35 then
21684: LD_VAR 0 3
21688: PUSH
21689: LD_INT 35
21691: EQUAL
21692: IFFALSE 21702
// sTime := true ;
21694: LD_ADDR_EXP 80
21698: PUSH
21699: LD_INT 1
21701: ST_TO_ADDR
// if p3 = 36 then
21702: LD_VAR 0 3
21706: PUSH
21707: LD_INT 36
21709: EQUAL
21710: IFFALSE 21720
// sTools := true ;
21712: LD_ADDR_EXP 81
21716: PUSH
21717: LD_INT 1
21719: ST_TO_ADDR
// if p3 = 101 then
21720: LD_VAR 0 3
21724: PUSH
21725: LD_INT 101
21727: EQUAL
21728: IFFALSE 21738
// sSold := true ;
21730: LD_ADDR_EXP 46
21734: PUSH
21735: LD_INT 1
21737: ST_TO_ADDR
// if p3 = 102 then
21738: LD_VAR 0 3
21742: PUSH
21743: LD_INT 102
21745: EQUAL
21746: IFFALSE 21756
// sDiff := true ;
21748: LD_ADDR_EXP 47
21752: PUSH
21753: LD_INT 1
21755: ST_TO_ADDR
// if p3 = 103 then
21756: LD_VAR 0 3
21760: PUSH
21761: LD_INT 103
21763: EQUAL
21764: IFFALSE 21774
// sFog := true ;
21766: LD_ADDR_EXP 50
21770: PUSH
21771: LD_INT 1
21773: ST_TO_ADDR
// if p3 = 104 then
21774: LD_VAR 0 3
21778: PUSH
21779: LD_INT 104
21781: EQUAL
21782: IFFALSE 21792
// sReset := true ;
21784: LD_ADDR_EXP 51
21788: PUSH
21789: LD_INT 1
21791: ST_TO_ADDR
// if p3 = 105 then
21792: LD_VAR 0 3
21796: PUSH
21797: LD_INT 105
21799: EQUAL
21800: IFFALSE 21810
// sSun := true ;
21802: LD_ADDR_EXP 52
21806: PUSH
21807: LD_INT 1
21809: ST_TO_ADDR
// if p3 = 106 then
21810: LD_VAR 0 3
21814: PUSH
21815: LD_INT 106
21817: EQUAL
21818: IFFALSE 21828
// sTiger := true ;
21820: LD_ADDR_EXP 48
21824: PUSH
21825: LD_INT 1
21827: ST_TO_ADDR
// if p3 = 107 then
21828: LD_VAR 0 3
21832: PUSH
21833: LD_INT 107
21835: EQUAL
21836: IFFALSE 21846
// sBomb := true ;
21838: LD_ADDR_EXP 49
21842: PUSH
21843: LD_INT 1
21845: ST_TO_ADDR
// if p3 = 108 then
21846: LD_VAR 0 3
21850: PUSH
21851: LD_INT 108
21853: EQUAL
21854: IFFALSE 21864
// sWound := true ;
21856: LD_ADDR_EXP 57
21860: PUSH
21861: LD_INT 1
21863: ST_TO_ADDR
// if p3 = 109 then
21864: LD_VAR 0 3
21868: PUSH
21869: LD_INT 109
21871: EQUAL
21872: IFFALSE 21882
// sBetray := true ;
21874: LD_ADDR_EXP 61
21878: PUSH
21879: LD_INT 1
21881: ST_TO_ADDR
// if p3 = 110 then
21882: LD_VAR 0 3
21886: PUSH
21887: LD_INT 110
21889: EQUAL
21890: IFFALSE 21900
// sContamin := true ;
21892: LD_ADDR_EXP 62
21896: PUSH
21897: LD_INT 1
21899: ST_TO_ADDR
// if p3 = 111 then
21900: LD_VAR 0 3
21904: PUSH
21905: LD_INT 111
21907: EQUAL
21908: IFFALSE 21918
// sOil := true ;
21910: LD_ADDR_EXP 64
21914: PUSH
21915: LD_INT 1
21917: ST_TO_ADDR
// if p3 = 112 then
21918: LD_VAR 0 3
21922: PUSH
21923: LD_INT 112
21925: EQUAL
21926: IFFALSE 21936
// sStu := true ;
21928: LD_ADDR_EXP 68
21932: PUSH
21933: LD_INT 1
21935: ST_TO_ADDR
// if p3 = 113 then
21936: LD_VAR 0 3
21940: PUSH
21941: LD_INT 113
21943: EQUAL
21944: IFFALSE 21954
// sBazooka := true ;
21946: LD_ADDR_EXP 71
21950: PUSH
21951: LD_INT 1
21953: ST_TO_ADDR
// if p3 = 114 then
21954: LD_VAR 0 3
21958: PUSH
21959: LD_INT 114
21961: EQUAL
21962: IFFALSE 21972
// sMortar := true ;
21964: LD_ADDR_EXP 72
21968: PUSH
21969: LD_INT 1
21971: ST_TO_ADDR
// if p3 = 115 then
21972: LD_VAR 0 3
21976: PUSH
21977: LD_INT 115
21979: EQUAL
21980: IFFALSE 21990
// sRanger := true ;
21982: LD_ADDR_EXP 82
21986: PUSH
21987: LD_INT 1
21989: ST_TO_ADDR
// if p3 = 116 then
21990: LD_VAR 0 3
21994: PUSH
21995: LD_INT 116
21997: EQUAL
21998: IFFALSE 22008
// sComputer := true ;
22000: LD_ADDR_EXP 83
22004: PUSH
22005: LD_INT 1
22007: ST_TO_ADDR
// if p3 = 117 then
22008: LD_VAR 0 3
22012: PUSH
22013: LD_INT 117
22015: EQUAL
22016: IFFALSE 22026
// s30 := true ;
22018: LD_ADDR_EXP 84
22022: PUSH
22023: LD_INT 1
22025: ST_TO_ADDR
// if p3 = 118 then
22026: LD_VAR 0 3
22030: PUSH
22031: LD_INT 118
22033: EQUAL
22034: IFFALSE 22044
// s60 := true ;
22036: LD_ADDR_EXP 85
22040: PUSH
22041: LD_INT 1
22043: ST_TO_ADDR
// end ; if p2 = hack_mode then
22044: LD_VAR 0 2
22048: PUSH
22049: LD_INT 101
22051: EQUAL
22052: IFFALSE 22180
// begin case p3 of 1 :
22054: LD_VAR 0 3
22058: PUSH
22059: LD_INT 1
22061: DOUBLE
22062: EQUAL
22063: IFTRUE 22067
22065: GO 22074
22067: POP
// hHackUnlimitedResources ; 2 :
22068: CALL 34319 0 0
22072: GO 22180
22074: LD_INT 2
22076: DOUBLE
22077: EQUAL
22078: IFTRUE 22082
22080: GO 22089
22082: POP
// hHackSetLevel10 ; 3 :
22083: CALL 34452 0 0
22087: GO 22180
22089: LD_INT 3
22091: DOUBLE
22092: EQUAL
22093: IFTRUE 22097
22095: GO 22104
22097: POP
// hHackSetLevel10YourUnits ; 4 :
22098: CALL 34537 0 0
22102: GO 22180
22104: LD_INT 4
22106: DOUBLE
22107: EQUAL
22108: IFTRUE 22112
22110: GO 22119
22112: POP
// hHackInvincible ; 5 :
22113: CALL 34985 0 0
22117: GO 22180
22119: LD_INT 5
22121: DOUBLE
22122: EQUAL
22123: IFTRUE 22127
22125: GO 22134
22127: POP
// hHackInvisible ; 6 :
22128: CALL 35096 0 0
22132: GO 22180
22134: LD_INT 6
22136: DOUBLE
22137: EQUAL
22138: IFTRUE 22142
22140: GO 22149
22142: POP
// hHackChangeYourSide ; 7 :
22143: CALL 35153 0 0
22147: GO 22180
22149: LD_INT 7
22151: DOUBLE
22152: EQUAL
22153: IFTRUE 22157
22155: GO 22164
22157: POP
// hHackChangeUnitSide ; 8 :
22158: CALL 35195 0 0
22162: GO 22180
22164: LD_INT 8
22166: DOUBLE
22167: EQUAL
22168: IFTRUE 22172
22170: GO 22179
22172: POP
// hHackFog ; end ;
22173: CALL 35296 0 0
22177: GO 22180
22179: POP
// end ; if p2 = game_save_mode then
22180: LD_VAR 0 2
22184: PUSH
22185: LD_INT 102
22187: EQUAL
22188: IFFALSE 22243
// begin if p3 = 1 then
22190: LD_VAR 0 3
22194: PUSH
22195: LD_INT 1
22197: EQUAL
22198: IFFALSE 22210
// globalGameSaveCounter := p4 ;
22200: LD_ADDR_EXP 28
22204: PUSH
22205: LD_VAR 0 4
22209: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
22210: LD_VAR 0 3
22214: PUSH
22215: LD_INT 2
22217: EQUAL
22218: PUSH
22219: LD_EXP 28
22223: AND
22224: IFFALSE 22243
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
22226: LD_STRING setGameSaveCounter(
22228: PUSH
22229: LD_EXP 28
22233: STR
22234: PUSH
22235: LD_STRING )
22237: STR
22238: PPUSH
22239: CALL_OW 559
// end ; end ;
22243: LD_VAR 0 7
22247: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
22248: LD_INT 0
22250: PPUSH
// streamModeActive := false ;
22251: LD_ADDR_EXP 29
22255: PUSH
22256: LD_INT 0
22258: ST_TO_ADDR
// normalCounter := 36 ;
22259: LD_ADDR_EXP 30
22263: PUSH
22264: LD_INT 36
22266: ST_TO_ADDR
// hardcoreCounter := 18 ;
22267: LD_ADDR_EXP 31
22271: PUSH
22272: LD_INT 18
22274: ST_TO_ADDR
// sRocket := false ;
22275: LD_ADDR_EXP 34
22279: PUSH
22280: LD_INT 0
22282: ST_TO_ADDR
// sSpeed := false ;
22283: LD_ADDR_EXP 33
22287: PUSH
22288: LD_INT 0
22290: ST_TO_ADDR
// sEngine := false ;
22291: LD_ADDR_EXP 35
22295: PUSH
22296: LD_INT 0
22298: ST_TO_ADDR
// sSpec := false ;
22299: LD_ADDR_EXP 32
22303: PUSH
22304: LD_INT 0
22306: ST_TO_ADDR
// sLevel := false ;
22307: LD_ADDR_EXP 36
22311: PUSH
22312: LD_INT 0
22314: ST_TO_ADDR
// sArmoury := false ;
22315: LD_ADDR_EXP 37
22319: PUSH
22320: LD_INT 0
22322: ST_TO_ADDR
// sRadar := false ;
22323: LD_ADDR_EXP 38
22327: PUSH
22328: LD_INT 0
22330: ST_TO_ADDR
// sBunker := false ;
22331: LD_ADDR_EXP 39
22335: PUSH
22336: LD_INT 0
22338: ST_TO_ADDR
// sHack := false ;
22339: LD_ADDR_EXP 40
22343: PUSH
22344: LD_INT 0
22346: ST_TO_ADDR
// sFire := false ;
22347: LD_ADDR_EXP 41
22351: PUSH
22352: LD_INT 0
22354: ST_TO_ADDR
// sRefresh := false ;
22355: LD_ADDR_EXP 42
22359: PUSH
22360: LD_INT 0
22362: ST_TO_ADDR
// sExp := false ;
22363: LD_ADDR_EXP 43
22367: PUSH
22368: LD_INT 0
22370: ST_TO_ADDR
// sDepot := false ;
22371: LD_ADDR_EXP 44
22375: PUSH
22376: LD_INT 0
22378: ST_TO_ADDR
// sFlag := false ;
22379: LD_ADDR_EXP 45
22383: PUSH
22384: LD_INT 0
22386: ST_TO_ADDR
// sKamikadze := false ;
22387: LD_ADDR_EXP 53
22391: PUSH
22392: LD_INT 0
22394: ST_TO_ADDR
// sTroll := false ;
22395: LD_ADDR_EXP 54
22399: PUSH
22400: LD_INT 0
22402: ST_TO_ADDR
// sSlow := false ;
22403: LD_ADDR_EXP 55
22407: PUSH
22408: LD_INT 0
22410: ST_TO_ADDR
// sLack := false ;
22411: LD_ADDR_EXP 56
22415: PUSH
22416: LD_INT 0
22418: ST_TO_ADDR
// sTank := false ;
22419: LD_ADDR_EXP 58
22423: PUSH
22424: LD_INT 0
22426: ST_TO_ADDR
// sRemote := false ;
22427: LD_ADDR_EXP 59
22431: PUSH
22432: LD_INT 0
22434: ST_TO_ADDR
// sPowell := false ;
22435: LD_ADDR_EXP 60
22439: PUSH
22440: LD_INT 0
22442: ST_TO_ADDR
// sTeleport := false ;
22443: LD_ADDR_EXP 63
22447: PUSH
22448: LD_INT 0
22450: ST_TO_ADDR
// sOilTower := false ;
22451: LD_ADDR_EXP 65
22455: PUSH
22456: LD_INT 0
22458: ST_TO_ADDR
// sShovel := false ;
22459: LD_ADDR_EXP 66
22463: PUSH
22464: LD_INT 0
22466: ST_TO_ADDR
// sSheik := false ;
22467: LD_ADDR_EXP 67
22471: PUSH
22472: LD_INT 0
22474: ST_TO_ADDR
// sEarthquake := false ;
22475: LD_ADDR_EXP 69
22479: PUSH
22480: LD_INT 0
22482: ST_TO_ADDR
// sAI := false ;
22483: LD_ADDR_EXP 70
22487: PUSH
22488: LD_INT 0
22490: ST_TO_ADDR
// sCargo := false ;
22491: LD_ADDR_EXP 73
22495: PUSH
22496: LD_INT 0
22498: ST_TO_ADDR
// sDLaser := false ;
22499: LD_ADDR_EXP 74
22503: PUSH
22504: LD_INT 0
22506: ST_TO_ADDR
// sExchange := false ;
22507: LD_ADDR_EXP 75
22511: PUSH
22512: LD_INT 0
22514: ST_TO_ADDR
// sFac := false ;
22515: LD_ADDR_EXP 76
22519: PUSH
22520: LD_INT 0
22522: ST_TO_ADDR
// sPower := false ;
22523: LD_ADDR_EXP 77
22527: PUSH
22528: LD_INT 0
22530: ST_TO_ADDR
// sRandom := false ;
22531: LD_ADDR_EXP 78
22535: PUSH
22536: LD_INT 0
22538: ST_TO_ADDR
// sShield := false ;
22539: LD_ADDR_EXP 79
22543: PUSH
22544: LD_INT 0
22546: ST_TO_ADDR
// sTime := false ;
22547: LD_ADDR_EXP 80
22551: PUSH
22552: LD_INT 0
22554: ST_TO_ADDR
// sTools := false ;
22555: LD_ADDR_EXP 81
22559: PUSH
22560: LD_INT 0
22562: ST_TO_ADDR
// sSold := false ;
22563: LD_ADDR_EXP 46
22567: PUSH
22568: LD_INT 0
22570: ST_TO_ADDR
// sDiff := false ;
22571: LD_ADDR_EXP 47
22575: PUSH
22576: LD_INT 0
22578: ST_TO_ADDR
// sFog := false ;
22579: LD_ADDR_EXP 50
22583: PUSH
22584: LD_INT 0
22586: ST_TO_ADDR
// sReset := false ;
22587: LD_ADDR_EXP 51
22591: PUSH
22592: LD_INT 0
22594: ST_TO_ADDR
// sSun := false ;
22595: LD_ADDR_EXP 52
22599: PUSH
22600: LD_INT 0
22602: ST_TO_ADDR
// sTiger := false ;
22603: LD_ADDR_EXP 48
22607: PUSH
22608: LD_INT 0
22610: ST_TO_ADDR
// sBomb := false ;
22611: LD_ADDR_EXP 49
22615: PUSH
22616: LD_INT 0
22618: ST_TO_ADDR
// sWound := false ;
22619: LD_ADDR_EXP 57
22623: PUSH
22624: LD_INT 0
22626: ST_TO_ADDR
// sBetray := false ;
22627: LD_ADDR_EXP 61
22631: PUSH
22632: LD_INT 0
22634: ST_TO_ADDR
// sContamin := false ;
22635: LD_ADDR_EXP 62
22639: PUSH
22640: LD_INT 0
22642: ST_TO_ADDR
// sOil := false ;
22643: LD_ADDR_EXP 64
22647: PUSH
22648: LD_INT 0
22650: ST_TO_ADDR
// sStu := false ;
22651: LD_ADDR_EXP 68
22655: PUSH
22656: LD_INT 0
22658: ST_TO_ADDR
// sBazooka := false ;
22659: LD_ADDR_EXP 71
22663: PUSH
22664: LD_INT 0
22666: ST_TO_ADDR
// sMortar := false ;
22667: LD_ADDR_EXP 72
22671: PUSH
22672: LD_INT 0
22674: ST_TO_ADDR
// sRanger := false ;
22675: LD_ADDR_EXP 82
22679: PUSH
22680: LD_INT 0
22682: ST_TO_ADDR
// sComputer := false ;
22683: LD_ADDR_EXP 83
22687: PUSH
22688: LD_INT 0
22690: ST_TO_ADDR
// s30 := false ;
22691: LD_ADDR_EXP 84
22695: PUSH
22696: LD_INT 0
22698: ST_TO_ADDR
// s60 := false ;
22699: LD_ADDR_EXP 85
22703: PUSH
22704: LD_INT 0
22706: ST_TO_ADDR
// end ;
22707: LD_VAR 0 1
22711: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
22712: LD_INT 0
22714: PPUSH
22715: PPUSH
22716: PPUSH
22717: PPUSH
22718: PPUSH
22719: PPUSH
22720: PPUSH
// result := [ ] ;
22721: LD_ADDR_VAR 0 2
22725: PUSH
22726: EMPTY
22727: ST_TO_ADDR
// if campaign_id = 1 then
22728: LD_OWVAR 69
22732: PUSH
22733: LD_INT 1
22735: EQUAL
22736: IFFALSE 25902
// begin case mission_number of 1 :
22738: LD_OWVAR 70
22742: PUSH
22743: LD_INT 1
22745: DOUBLE
22746: EQUAL
22747: IFTRUE 22751
22749: GO 22827
22751: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
22752: LD_ADDR_VAR 0 2
22756: PUSH
22757: LD_INT 2
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: LD_INT 11
22765: PUSH
22766: LD_INT 12
22768: PUSH
22769: LD_INT 15
22771: PUSH
22772: LD_INT 16
22774: PUSH
22775: LD_INT 22
22777: PUSH
22778: LD_INT 23
22780: PUSH
22781: LD_INT 26
22783: PUSH
22784: EMPTY
22785: LIST
22786: LIST
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: LIST
22794: PUSH
22795: LD_INT 101
22797: PUSH
22798: LD_INT 102
22800: PUSH
22801: LD_INT 106
22803: PUSH
22804: LD_INT 116
22806: PUSH
22807: LD_INT 117
22809: PUSH
22810: LD_INT 118
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: LIST
22817: LIST
22818: LIST
22819: LIST
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: ST_TO_ADDR
22825: GO 25900
22827: LD_INT 2
22829: DOUBLE
22830: EQUAL
22831: IFTRUE 22835
22833: GO 22919
22835: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
22836: LD_ADDR_VAR 0 2
22840: PUSH
22841: LD_INT 2
22843: PUSH
22844: LD_INT 4
22846: PUSH
22847: LD_INT 11
22849: PUSH
22850: LD_INT 12
22852: PUSH
22853: LD_INT 15
22855: PUSH
22856: LD_INT 16
22858: PUSH
22859: LD_INT 22
22861: PUSH
22862: LD_INT 23
22864: PUSH
22865: LD_INT 26
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: PUSH
22879: LD_INT 101
22881: PUSH
22882: LD_INT 102
22884: PUSH
22885: LD_INT 105
22887: PUSH
22888: LD_INT 106
22890: PUSH
22891: LD_INT 108
22893: PUSH
22894: LD_INT 116
22896: PUSH
22897: LD_INT 117
22899: PUSH
22900: LD_INT 118
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: LIST
22910: LIST
22911: LIST
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: ST_TO_ADDR
22917: GO 25900
22919: LD_INT 3
22921: DOUBLE
22922: EQUAL
22923: IFTRUE 22927
22925: GO 23015
22927: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
22928: LD_ADDR_VAR 0 2
22932: PUSH
22933: LD_INT 2
22935: PUSH
22936: LD_INT 4
22938: PUSH
22939: LD_INT 5
22941: PUSH
22942: LD_INT 11
22944: PUSH
22945: LD_INT 12
22947: PUSH
22948: LD_INT 15
22950: PUSH
22951: LD_INT 16
22953: PUSH
22954: LD_INT 22
22956: PUSH
22957: LD_INT 26
22959: PUSH
22960: LD_INT 36
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: LIST
22967: LIST
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: LIST
22974: PUSH
22975: LD_INT 101
22977: PUSH
22978: LD_INT 102
22980: PUSH
22981: LD_INT 105
22983: PUSH
22984: LD_INT 106
22986: PUSH
22987: LD_INT 108
22989: PUSH
22990: LD_INT 116
22992: PUSH
22993: LD_INT 117
22995: PUSH
22996: LD_INT 118
22998: PUSH
22999: EMPTY
23000: LIST
23001: LIST
23002: LIST
23003: LIST
23004: LIST
23005: LIST
23006: LIST
23007: LIST
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: ST_TO_ADDR
23013: GO 25900
23015: LD_INT 4
23017: DOUBLE
23018: EQUAL
23019: IFTRUE 23023
23021: GO 23119
23023: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
23024: LD_ADDR_VAR 0 2
23028: PUSH
23029: LD_INT 2
23031: PUSH
23032: LD_INT 4
23034: PUSH
23035: LD_INT 5
23037: PUSH
23038: LD_INT 8
23040: PUSH
23041: LD_INT 11
23043: PUSH
23044: LD_INT 12
23046: PUSH
23047: LD_INT 15
23049: PUSH
23050: LD_INT 16
23052: PUSH
23053: LD_INT 22
23055: PUSH
23056: LD_INT 23
23058: PUSH
23059: LD_INT 26
23061: PUSH
23062: LD_INT 36
23064: PUSH
23065: EMPTY
23066: LIST
23067: LIST
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 101
23081: PUSH
23082: LD_INT 102
23084: PUSH
23085: LD_INT 105
23087: PUSH
23088: LD_INT 106
23090: PUSH
23091: LD_INT 108
23093: PUSH
23094: LD_INT 116
23096: PUSH
23097: LD_INT 117
23099: PUSH
23100: LD_INT 118
23102: PUSH
23103: EMPTY
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: LIST
23110: LIST
23111: LIST
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: ST_TO_ADDR
23117: GO 25900
23119: LD_INT 5
23121: DOUBLE
23122: EQUAL
23123: IFTRUE 23127
23125: GO 23239
23127: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
23128: LD_ADDR_VAR 0 2
23132: PUSH
23133: LD_INT 2
23135: PUSH
23136: LD_INT 4
23138: PUSH
23139: LD_INT 5
23141: PUSH
23142: LD_INT 6
23144: PUSH
23145: LD_INT 8
23147: PUSH
23148: LD_INT 11
23150: PUSH
23151: LD_INT 12
23153: PUSH
23154: LD_INT 15
23156: PUSH
23157: LD_INT 16
23159: PUSH
23160: LD_INT 22
23162: PUSH
23163: LD_INT 23
23165: PUSH
23166: LD_INT 25
23168: PUSH
23169: LD_INT 26
23171: PUSH
23172: LD_INT 36
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: PUSH
23191: LD_INT 101
23193: PUSH
23194: LD_INT 102
23196: PUSH
23197: LD_INT 105
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 108
23205: PUSH
23206: LD_INT 109
23208: PUSH
23209: LD_INT 112
23211: PUSH
23212: LD_INT 116
23214: PUSH
23215: LD_INT 117
23217: PUSH
23218: LD_INT 118
23220: PUSH
23221: EMPTY
23222: LIST
23223: LIST
23224: LIST
23225: LIST
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: ST_TO_ADDR
23237: GO 25900
23239: LD_INT 6
23241: DOUBLE
23242: EQUAL
23243: IFTRUE 23247
23245: GO 23379
23247: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
23248: LD_ADDR_VAR 0 2
23252: PUSH
23253: LD_INT 2
23255: PUSH
23256: LD_INT 4
23258: PUSH
23259: LD_INT 5
23261: PUSH
23262: LD_INT 6
23264: PUSH
23265: LD_INT 8
23267: PUSH
23268: LD_INT 11
23270: PUSH
23271: LD_INT 12
23273: PUSH
23274: LD_INT 15
23276: PUSH
23277: LD_INT 16
23279: PUSH
23280: LD_INT 20
23282: PUSH
23283: LD_INT 21
23285: PUSH
23286: LD_INT 22
23288: PUSH
23289: LD_INT 23
23291: PUSH
23292: LD_INT 25
23294: PUSH
23295: LD_INT 26
23297: PUSH
23298: LD_INT 30
23300: PUSH
23301: LD_INT 31
23303: PUSH
23304: LD_INT 32
23306: PUSH
23307: LD_INT 36
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: PUSH
23331: LD_INT 101
23333: PUSH
23334: LD_INT 102
23336: PUSH
23337: LD_INT 105
23339: PUSH
23340: LD_INT 106
23342: PUSH
23343: LD_INT 108
23345: PUSH
23346: LD_INT 109
23348: PUSH
23349: LD_INT 112
23351: PUSH
23352: LD_INT 116
23354: PUSH
23355: LD_INT 117
23357: PUSH
23358: LD_INT 118
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: LIST
23365: LIST
23366: LIST
23367: LIST
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: ST_TO_ADDR
23377: GO 25900
23379: LD_INT 7
23381: DOUBLE
23382: EQUAL
23383: IFTRUE 23387
23385: GO 23499
23387: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
23388: LD_ADDR_VAR 0 2
23392: PUSH
23393: LD_INT 2
23395: PUSH
23396: LD_INT 4
23398: PUSH
23399: LD_INT 5
23401: PUSH
23402: LD_INT 7
23404: PUSH
23405: LD_INT 11
23407: PUSH
23408: LD_INT 12
23410: PUSH
23411: LD_INT 15
23413: PUSH
23414: LD_INT 16
23416: PUSH
23417: LD_INT 20
23419: PUSH
23420: LD_INT 21
23422: PUSH
23423: LD_INT 22
23425: PUSH
23426: LD_INT 23
23428: PUSH
23429: LD_INT 25
23431: PUSH
23432: LD_INT 26
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: LIST
23439: LIST
23440: LIST
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: PUSH
23451: LD_INT 101
23453: PUSH
23454: LD_INT 102
23456: PUSH
23457: LD_INT 103
23459: PUSH
23460: LD_INT 105
23462: PUSH
23463: LD_INT 106
23465: PUSH
23466: LD_INT 108
23468: PUSH
23469: LD_INT 112
23471: PUSH
23472: LD_INT 116
23474: PUSH
23475: LD_INT 117
23477: PUSH
23478: LD_INT 118
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: LIST
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: PUSH
23493: EMPTY
23494: LIST
23495: LIST
23496: ST_TO_ADDR
23497: GO 25900
23499: LD_INT 8
23501: DOUBLE
23502: EQUAL
23503: IFTRUE 23507
23505: GO 23647
23507: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
23508: LD_ADDR_VAR 0 2
23512: PUSH
23513: LD_INT 2
23515: PUSH
23516: LD_INT 4
23518: PUSH
23519: LD_INT 5
23521: PUSH
23522: LD_INT 6
23524: PUSH
23525: LD_INT 7
23527: PUSH
23528: LD_INT 8
23530: PUSH
23531: LD_INT 11
23533: PUSH
23534: LD_INT 12
23536: PUSH
23537: LD_INT 15
23539: PUSH
23540: LD_INT 16
23542: PUSH
23543: LD_INT 20
23545: PUSH
23546: LD_INT 21
23548: PUSH
23549: LD_INT 22
23551: PUSH
23552: LD_INT 23
23554: PUSH
23555: LD_INT 25
23557: PUSH
23558: LD_INT 26
23560: PUSH
23561: LD_INT 30
23563: PUSH
23564: LD_INT 31
23566: PUSH
23567: LD_INT 32
23569: PUSH
23570: LD_INT 36
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: LIST
23593: LIST
23594: PUSH
23595: LD_INT 101
23597: PUSH
23598: LD_INT 102
23600: PUSH
23601: LD_INT 103
23603: PUSH
23604: LD_INT 105
23606: PUSH
23607: LD_INT 106
23609: PUSH
23610: LD_INT 108
23612: PUSH
23613: LD_INT 109
23615: PUSH
23616: LD_INT 112
23618: PUSH
23619: LD_INT 116
23621: PUSH
23622: LD_INT 117
23624: PUSH
23625: LD_INT 118
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: LIST
23632: LIST
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: ST_TO_ADDR
23645: GO 25900
23647: LD_INT 9
23649: DOUBLE
23650: EQUAL
23651: IFTRUE 23655
23653: GO 23803
23655: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
23656: LD_ADDR_VAR 0 2
23660: PUSH
23661: LD_INT 2
23663: PUSH
23664: LD_INT 4
23666: PUSH
23667: LD_INT 5
23669: PUSH
23670: LD_INT 6
23672: PUSH
23673: LD_INT 7
23675: PUSH
23676: LD_INT 8
23678: PUSH
23679: LD_INT 11
23681: PUSH
23682: LD_INT 12
23684: PUSH
23685: LD_INT 15
23687: PUSH
23688: LD_INT 16
23690: PUSH
23691: LD_INT 20
23693: PUSH
23694: LD_INT 21
23696: PUSH
23697: LD_INT 22
23699: PUSH
23700: LD_INT 23
23702: PUSH
23703: LD_INT 25
23705: PUSH
23706: LD_INT 26
23708: PUSH
23709: LD_INT 28
23711: PUSH
23712: LD_INT 30
23714: PUSH
23715: LD_INT 31
23717: PUSH
23718: LD_INT 32
23720: PUSH
23721: LD_INT 36
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: LIST
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: LIST
23744: LIST
23745: LIST
23746: PUSH
23747: LD_INT 101
23749: PUSH
23750: LD_INT 102
23752: PUSH
23753: LD_INT 103
23755: PUSH
23756: LD_INT 105
23758: PUSH
23759: LD_INT 106
23761: PUSH
23762: LD_INT 108
23764: PUSH
23765: LD_INT 109
23767: PUSH
23768: LD_INT 112
23770: PUSH
23771: LD_INT 114
23773: PUSH
23774: LD_INT 116
23776: PUSH
23777: LD_INT 117
23779: PUSH
23780: LD_INT 118
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: ST_TO_ADDR
23801: GO 25900
23803: LD_INT 10
23805: DOUBLE
23806: EQUAL
23807: IFTRUE 23811
23809: GO 24007
23811: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
23812: LD_ADDR_VAR 0 2
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: LD_INT 4
23822: PUSH
23823: LD_INT 5
23825: PUSH
23826: LD_INT 6
23828: PUSH
23829: LD_INT 7
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: LD_INT 9
23837: PUSH
23838: LD_INT 10
23840: PUSH
23841: LD_INT 11
23843: PUSH
23844: LD_INT 12
23846: PUSH
23847: LD_INT 13
23849: PUSH
23850: LD_INT 14
23852: PUSH
23853: LD_INT 15
23855: PUSH
23856: LD_INT 16
23858: PUSH
23859: LD_INT 17
23861: PUSH
23862: LD_INT 18
23864: PUSH
23865: LD_INT 19
23867: PUSH
23868: LD_INT 20
23870: PUSH
23871: LD_INT 21
23873: PUSH
23874: LD_INT 22
23876: PUSH
23877: LD_INT 23
23879: PUSH
23880: LD_INT 24
23882: PUSH
23883: LD_INT 25
23885: PUSH
23886: LD_INT 26
23888: PUSH
23889: LD_INT 28
23891: PUSH
23892: LD_INT 30
23894: PUSH
23895: LD_INT 31
23897: PUSH
23898: LD_INT 32
23900: PUSH
23901: LD_INT 36
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: LIST
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 101
23937: PUSH
23938: LD_INT 102
23940: PUSH
23941: LD_INT 103
23943: PUSH
23944: LD_INT 104
23946: PUSH
23947: LD_INT 105
23949: PUSH
23950: LD_INT 106
23952: PUSH
23953: LD_INT 107
23955: PUSH
23956: LD_INT 108
23958: PUSH
23959: LD_INT 109
23961: PUSH
23962: LD_INT 110
23964: PUSH
23965: LD_INT 111
23967: PUSH
23968: LD_INT 112
23970: PUSH
23971: LD_INT 114
23973: PUSH
23974: LD_INT 116
23976: PUSH
23977: LD_INT 117
23979: PUSH
23980: LD_INT 118
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: LIST
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: LIST
23995: LIST
23996: LIST
23997: LIST
23998: LIST
23999: LIST
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: ST_TO_ADDR
24005: GO 25900
24007: LD_INT 11
24009: DOUBLE
24010: EQUAL
24011: IFTRUE 24015
24013: GO 24219
24015: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
24016: LD_ADDR_VAR 0 2
24020: PUSH
24021: LD_INT 2
24023: PUSH
24024: LD_INT 3
24026: PUSH
24027: LD_INT 4
24029: PUSH
24030: LD_INT 5
24032: PUSH
24033: LD_INT 6
24035: PUSH
24036: LD_INT 7
24038: PUSH
24039: LD_INT 8
24041: PUSH
24042: LD_INT 9
24044: PUSH
24045: LD_INT 10
24047: PUSH
24048: LD_INT 11
24050: PUSH
24051: LD_INT 12
24053: PUSH
24054: LD_INT 13
24056: PUSH
24057: LD_INT 14
24059: PUSH
24060: LD_INT 15
24062: PUSH
24063: LD_INT 16
24065: PUSH
24066: LD_INT 17
24068: PUSH
24069: LD_INT 18
24071: PUSH
24072: LD_INT 19
24074: PUSH
24075: LD_INT 20
24077: PUSH
24078: LD_INT 21
24080: PUSH
24081: LD_INT 22
24083: PUSH
24084: LD_INT 23
24086: PUSH
24087: LD_INT 24
24089: PUSH
24090: LD_INT 25
24092: PUSH
24093: LD_INT 26
24095: PUSH
24096: LD_INT 28
24098: PUSH
24099: LD_INT 30
24101: PUSH
24102: LD_INT 31
24104: PUSH
24105: LD_INT 32
24107: PUSH
24108: LD_INT 34
24110: PUSH
24111: LD_INT 36
24113: PUSH
24114: EMPTY
24115: LIST
24116: LIST
24117: LIST
24118: LIST
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: LIST
24146: PUSH
24147: LD_INT 101
24149: PUSH
24150: LD_INT 102
24152: PUSH
24153: LD_INT 103
24155: PUSH
24156: LD_INT 104
24158: PUSH
24159: LD_INT 105
24161: PUSH
24162: LD_INT 106
24164: PUSH
24165: LD_INT 107
24167: PUSH
24168: LD_INT 108
24170: PUSH
24171: LD_INT 109
24173: PUSH
24174: LD_INT 110
24176: PUSH
24177: LD_INT 111
24179: PUSH
24180: LD_INT 112
24182: PUSH
24183: LD_INT 114
24185: PUSH
24186: LD_INT 116
24188: PUSH
24189: LD_INT 117
24191: PUSH
24192: LD_INT 118
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: ST_TO_ADDR
24217: GO 25900
24219: LD_INT 12
24221: DOUBLE
24222: EQUAL
24223: IFTRUE 24227
24225: GO 24447
24227: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
24228: LD_ADDR_VAR 0 2
24232: PUSH
24233: LD_INT 1
24235: PUSH
24236: LD_INT 2
24238: PUSH
24239: LD_INT 3
24241: PUSH
24242: LD_INT 4
24244: PUSH
24245: LD_INT 5
24247: PUSH
24248: LD_INT 6
24250: PUSH
24251: LD_INT 7
24253: PUSH
24254: LD_INT 8
24256: PUSH
24257: LD_INT 9
24259: PUSH
24260: LD_INT 10
24262: PUSH
24263: LD_INT 11
24265: PUSH
24266: LD_INT 12
24268: PUSH
24269: LD_INT 13
24271: PUSH
24272: LD_INT 14
24274: PUSH
24275: LD_INT 15
24277: PUSH
24278: LD_INT 16
24280: PUSH
24281: LD_INT 17
24283: PUSH
24284: LD_INT 18
24286: PUSH
24287: LD_INT 19
24289: PUSH
24290: LD_INT 20
24292: PUSH
24293: LD_INT 21
24295: PUSH
24296: LD_INT 22
24298: PUSH
24299: LD_INT 23
24301: PUSH
24302: LD_INT 24
24304: PUSH
24305: LD_INT 25
24307: PUSH
24308: LD_INT 26
24310: PUSH
24311: LD_INT 27
24313: PUSH
24314: LD_INT 28
24316: PUSH
24317: LD_INT 30
24319: PUSH
24320: LD_INT 31
24322: PUSH
24323: LD_INT 32
24325: PUSH
24326: LD_INT 33
24328: PUSH
24329: LD_INT 34
24331: PUSH
24332: LD_INT 36
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: LIST
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: PUSH
24371: LD_INT 101
24373: PUSH
24374: LD_INT 102
24376: PUSH
24377: LD_INT 103
24379: PUSH
24380: LD_INT 104
24382: PUSH
24383: LD_INT 105
24385: PUSH
24386: LD_INT 106
24388: PUSH
24389: LD_INT 107
24391: PUSH
24392: LD_INT 108
24394: PUSH
24395: LD_INT 109
24397: PUSH
24398: LD_INT 110
24400: PUSH
24401: LD_INT 111
24403: PUSH
24404: LD_INT 112
24406: PUSH
24407: LD_INT 113
24409: PUSH
24410: LD_INT 114
24412: PUSH
24413: LD_INT 116
24415: PUSH
24416: LD_INT 117
24418: PUSH
24419: LD_INT 118
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: LIST
24426: LIST
24427: LIST
24428: LIST
24429: LIST
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: LIST
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: ST_TO_ADDR
24445: GO 25900
24447: LD_INT 13
24449: DOUBLE
24450: EQUAL
24451: IFTRUE 24455
24453: GO 24663
24455: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
24456: LD_ADDR_VAR 0 2
24460: PUSH
24461: LD_INT 1
24463: PUSH
24464: LD_INT 2
24466: PUSH
24467: LD_INT 3
24469: PUSH
24470: LD_INT 4
24472: PUSH
24473: LD_INT 5
24475: PUSH
24476: LD_INT 8
24478: PUSH
24479: LD_INT 9
24481: PUSH
24482: LD_INT 10
24484: PUSH
24485: LD_INT 11
24487: PUSH
24488: LD_INT 12
24490: PUSH
24491: LD_INT 14
24493: PUSH
24494: LD_INT 15
24496: PUSH
24497: LD_INT 16
24499: PUSH
24500: LD_INT 17
24502: PUSH
24503: LD_INT 18
24505: PUSH
24506: LD_INT 19
24508: PUSH
24509: LD_INT 20
24511: PUSH
24512: LD_INT 21
24514: PUSH
24515: LD_INT 22
24517: PUSH
24518: LD_INT 23
24520: PUSH
24521: LD_INT 24
24523: PUSH
24524: LD_INT 25
24526: PUSH
24527: LD_INT 26
24529: PUSH
24530: LD_INT 27
24532: PUSH
24533: LD_INT 28
24535: PUSH
24536: LD_INT 30
24538: PUSH
24539: LD_INT 31
24541: PUSH
24542: LD_INT 32
24544: PUSH
24545: LD_INT 33
24547: PUSH
24548: LD_INT 34
24550: PUSH
24551: LD_INT 36
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: LIST
24558: LIST
24559: LIST
24560: LIST
24561: LIST
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: LIST
24575: LIST
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: PUSH
24587: LD_INT 101
24589: PUSH
24590: LD_INT 102
24592: PUSH
24593: LD_INT 103
24595: PUSH
24596: LD_INT 104
24598: PUSH
24599: LD_INT 105
24601: PUSH
24602: LD_INT 106
24604: PUSH
24605: LD_INT 107
24607: PUSH
24608: LD_INT 108
24610: PUSH
24611: LD_INT 109
24613: PUSH
24614: LD_INT 110
24616: PUSH
24617: LD_INT 111
24619: PUSH
24620: LD_INT 112
24622: PUSH
24623: LD_INT 113
24625: PUSH
24626: LD_INT 114
24628: PUSH
24629: LD_INT 116
24631: PUSH
24632: LD_INT 117
24634: PUSH
24635: LD_INT 118
24637: PUSH
24638: EMPTY
24639: LIST
24640: LIST
24641: LIST
24642: LIST
24643: LIST
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: ST_TO_ADDR
24661: GO 25900
24663: LD_INT 14
24665: DOUBLE
24666: EQUAL
24667: IFTRUE 24671
24669: GO 24895
24671: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
24672: LD_ADDR_VAR 0 2
24676: PUSH
24677: LD_INT 1
24679: PUSH
24680: LD_INT 2
24682: PUSH
24683: LD_INT 3
24685: PUSH
24686: LD_INT 4
24688: PUSH
24689: LD_INT 5
24691: PUSH
24692: LD_INT 6
24694: PUSH
24695: LD_INT 7
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: LD_INT 9
24703: PUSH
24704: LD_INT 10
24706: PUSH
24707: LD_INT 11
24709: PUSH
24710: LD_INT 12
24712: PUSH
24713: LD_INT 13
24715: PUSH
24716: LD_INT 14
24718: PUSH
24719: LD_INT 15
24721: PUSH
24722: LD_INT 16
24724: PUSH
24725: LD_INT 17
24727: PUSH
24728: LD_INT 18
24730: PUSH
24731: LD_INT 19
24733: PUSH
24734: LD_INT 20
24736: PUSH
24737: LD_INT 21
24739: PUSH
24740: LD_INT 22
24742: PUSH
24743: LD_INT 23
24745: PUSH
24746: LD_INT 24
24748: PUSH
24749: LD_INT 25
24751: PUSH
24752: LD_INT 26
24754: PUSH
24755: LD_INT 27
24757: PUSH
24758: LD_INT 28
24760: PUSH
24761: LD_INT 29
24763: PUSH
24764: LD_INT 30
24766: PUSH
24767: LD_INT 31
24769: PUSH
24770: LD_INT 32
24772: PUSH
24773: LD_INT 33
24775: PUSH
24776: LD_INT 34
24778: PUSH
24779: LD_INT 36
24781: PUSH
24782: EMPTY
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: LIST
24800: LIST
24801: LIST
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: LIST
24811: LIST
24812: LIST
24813: LIST
24814: LIST
24815: LIST
24816: LIST
24817: LIST
24818: PUSH
24819: LD_INT 101
24821: PUSH
24822: LD_INT 102
24824: PUSH
24825: LD_INT 103
24827: PUSH
24828: LD_INT 104
24830: PUSH
24831: LD_INT 105
24833: PUSH
24834: LD_INT 106
24836: PUSH
24837: LD_INT 107
24839: PUSH
24840: LD_INT 108
24842: PUSH
24843: LD_INT 109
24845: PUSH
24846: LD_INT 110
24848: PUSH
24849: LD_INT 111
24851: PUSH
24852: LD_INT 112
24854: PUSH
24855: LD_INT 113
24857: PUSH
24858: LD_INT 114
24860: PUSH
24861: LD_INT 116
24863: PUSH
24864: LD_INT 117
24866: PUSH
24867: LD_INT 118
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: LIST
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: LIST
24885: LIST
24886: LIST
24887: LIST
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: ST_TO_ADDR
24893: GO 25900
24895: LD_INT 15
24897: DOUBLE
24898: EQUAL
24899: IFTRUE 24903
24901: GO 25127
24903: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
24904: LD_ADDR_VAR 0 2
24908: PUSH
24909: LD_INT 1
24911: PUSH
24912: LD_INT 2
24914: PUSH
24915: LD_INT 3
24917: PUSH
24918: LD_INT 4
24920: PUSH
24921: LD_INT 5
24923: PUSH
24924: LD_INT 6
24926: PUSH
24927: LD_INT 7
24929: PUSH
24930: LD_INT 8
24932: PUSH
24933: LD_INT 9
24935: PUSH
24936: LD_INT 10
24938: PUSH
24939: LD_INT 11
24941: PUSH
24942: LD_INT 12
24944: PUSH
24945: LD_INT 13
24947: PUSH
24948: LD_INT 14
24950: PUSH
24951: LD_INT 15
24953: PUSH
24954: LD_INT 16
24956: PUSH
24957: LD_INT 17
24959: PUSH
24960: LD_INT 18
24962: PUSH
24963: LD_INT 19
24965: PUSH
24966: LD_INT 20
24968: PUSH
24969: LD_INT 21
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 23
24977: PUSH
24978: LD_INT 24
24980: PUSH
24981: LD_INT 25
24983: PUSH
24984: LD_INT 26
24986: PUSH
24987: LD_INT 27
24989: PUSH
24990: LD_INT 28
24992: PUSH
24993: LD_INT 29
24995: PUSH
24996: LD_INT 30
24998: PUSH
24999: LD_INT 31
25001: PUSH
25002: LD_INT 32
25004: PUSH
25005: LD_INT 33
25007: PUSH
25008: LD_INT 34
25010: PUSH
25011: LD_INT 36
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: LIST
25018: LIST
25019: LIST
25020: LIST
25021: LIST
25022: LIST
25023: LIST
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: LIST
25029: LIST
25030: LIST
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: LIST
25041: LIST
25042: LIST
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: PUSH
25051: LD_INT 101
25053: PUSH
25054: LD_INT 102
25056: PUSH
25057: LD_INT 103
25059: PUSH
25060: LD_INT 104
25062: PUSH
25063: LD_INT 105
25065: PUSH
25066: LD_INT 106
25068: PUSH
25069: LD_INT 107
25071: PUSH
25072: LD_INT 108
25074: PUSH
25075: LD_INT 109
25077: PUSH
25078: LD_INT 110
25080: PUSH
25081: LD_INT 111
25083: PUSH
25084: LD_INT 112
25086: PUSH
25087: LD_INT 113
25089: PUSH
25090: LD_INT 114
25092: PUSH
25093: LD_INT 116
25095: PUSH
25096: LD_INT 117
25098: PUSH
25099: LD_INT 118
25101: PUSH
25102: EMPTY
25103: LIST
25104: LIST
25105: LIST
25106: LIST
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: LIST
25115: LIST
25116: LIST
25117: LIST
25118: LIST
25119: LIST
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: ST_TO_ADDR
25125: GO 25900
25127: LD_INT 16
25129: DOUBLE
25130: EQUAL
25131: IFTRUE 25135
25133: GO 25271
25135: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
25136: LD_ADDR_VAR 0 2
25140: PUSH
25141: LD_INT 2
25143: PUSH
25144: LD_INT 4
25146: PUSH
25147: LD_INT 5
25149: PUSH
25150: LD_INT 7
25152: PUSH
25153: LD_INT 11
25155: PUSH
25156: LD_INT 12
25158: PUSH
25159: LD_INT 15
25161: PUSH
25162: LD_INT 16
25164: PUSH
25165: LD_INT 20
25167: PUSH
25168: LD_INT 21
25170: PUSH
25171: LD_INT 22
25173: PUSH
25174: LD_INT 23
25176: PUSH
25177: LD_INT 25
25179: PUSH
25180: LD_INT 26
25182: PUSH
25183: LD_INT 30
25185: PUSH
25186: LD_INT 31
25188: PUSH
25189: LD_INT 32
25191: PUSH
25192: LD_INT 33
25194: PUSH
25195: LD_INT 34
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: PUSH
25219: LD_INT 101
25221: PUSH
25222: LD_INT 102
25224: PUSH
25225: LD_INT 103
25227: PUSH
25228: LD_INT 106
25230: PUSH
25231: LD_INT 108
25233: PUSH
25234: LD_INT 112
25236: PUSH
25237: LD_INT 113
25239: PUSH
25240: LD_INT 114
25242: PUSH
25243: LD_INT 116
25245: PUSH
25246: LD_INT 117
25248: PUSH
25249: LD_INT 118
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: ST_TO_ADDR
25269: GO 25900
25271: LD_INT 17
25273: DOUBLE
25274: EQUAL
25275: IFTRUE 25279
25277: GO 25503
25279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
25280: LD_ADDR_VAR 0 2
25284: PUSH
25285: LD_INT 1
25287: PUSH
25288: LD_INT 2
25290: PUSH
25291: LD_INT 3
25293: PUSH
25294: LD_INT 4
25296: PUSH
25297: LD_INT 5
25299: PUSH
25300: LD_INT 6
25302: PUSH
25303: LD_INT 7
25305: PUSH
25306: LD_INT 8
25308: PUSH
25309: LD_INT 9
25311: PUSH
25312: LD_INT 10
25314: PUSH
25315: LD_INT 11
25317: PUSH
25318: LD_INT 12
25320: PUSH
25321: LD_INT 13
25323: PUSH
25324: LD_INT 14
25326: PUSH
25327: LD_INT 15
25329: PUSH
25330: LD_INT 16
25332: PUSH
25333: LD_INT 17
25335: PUSH
25336: LD_INT 18
25338: PUSH
25339: LD_INT 19
25341: PUSH
25342: LD_INT 20
25344: PUSH
25345: LD_INT 21
25347: PUSH
25348: LD_INT 22
25350: PUSH
25351: LD_INT 23
25353: PUSH
25354: LD_INT 24
25356: PUSH
25357: LD_INT 25
25359: PUSH
25360: LD_INT 26
25362: PUSH
25363: LD_INT 27
25365: PUSH
25366: LD_INT 28
25368: PUSH
25369: LD_INT 29
25371: PUSH
25372: LD_INT 30
25374: PUSH
25375: LD_INT 31
25377: PUSH
25378: LD_INT 32
25380: PUSH
25381: LD_INT 33
25383: PUSH
25384: LD_INT 34
25386: PUSH
25387: LD_INT 36
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: LIST
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: LIST
25405: LIST
25406: LIST
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: LIST
25412: LIST
25413: LIST
25414: LIST
25415: LIST
25416: LIST
25417: LIST
25418: LIST
25419: LIST
25420: LIST
25421: LIST
25422: LIST
25423: LIST
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 101
25429: PUSH
25430: LD_INT 102
25432: PUSH
25433: LD_INT 103
25435: PUSH
25436: LD_INT 104
25438: PUSH
25439: LD_INT 105
25441: PUSH
25442: LD_INT 106
25444: PUSH
25445: LD_INT 107
25447: PUSH
25448: LD_INT 108
25450: PUSH
25451: LD_INT 109
25453: PUSH
25454: LD_INT 110
25456: PUSH
25457: LD_INT 111
25459: PUSH
25460: LD_INT 112
25462: PUSH
25463: LD_INT 113
25465: PUSH
25466: LD_INT 114
25468: PUSH
25469: LD_INT 116
25471: PUSH
25472: LD_INT 117
25474: PUSH
25475: LD_INT 118
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: LIST
25491: LIST
25492: LIST
25493: LIST
25494: LIST
25495: LIST
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: ST_TO_ADDR
25501: GO 25900
25503: LD_INT 18
25505: DOUBLE
25506: EQUAL
25507: IFTRUE 25511
25509: GO 25659
25511: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
25512: LD_ADDR_VAR 0 2
25516: PUSH
25517: LD_INT 2
25519: PUSH
25520: LD_INT 4
25522: PUSH
25523: LD_INT 5
25525: PUSH
25526: LD_INT 7
25528: PUSH
25529: LD_INT 11
25531: PUSH
25532: LD_INT 12
25534: PUSH
25535: LD_INT 15
25537: PUSH
25538: LD_INT 16
25540: PUSH
25541: LD_INT 20
25543: PUSH
25544: LD_INT 21
25546: PUSH
25547: LD_INT 22
25549: PUSH
25550: LD_INT 23
25552: PUSH
25553: LD_INT 25
25555: PUSH
25556: LD_INT 26
25558: PUSH
25559: LD_INT 30
25561: PUSH
25562: LD_INT 31
25564: PUSH
25565: LD_INT 32
25567: PUSH
25568: LD_INT 33
25570: PUSH
25571: LD_INT 34
25573: PUSH
25574: LD_INT 35
25576: PUSH
25577: LD_INT 36
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 101
25605: PUSH
25606: LD_INT 102
25608: PUSH
25609: LD_INT 103
25611: PUSH
25612: LD_INT 106
25614: PUSH
25615: LD_INT 108
25617: PUSH
25618: LD_INT 112
25620: PUSH
25621: LD_INT 113
25623: PUSH
25624: LD_INT 114
25626: PUSH
25627: LD_INT 115
25629: PUSH
25630: LD_INT 116
25632: PUSH
25633: LD_INT 117
25635: PUSH
25636: LD_INT 118
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: LIST
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: ST_TO_ADDR
25657: GO 25900
25659: LD_INT 19
25661: DOUBLE
25662: EQUAL
25663: IFTRUE 25667
25665: GO 25899
25667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
25668: LD_ADDR_VAR 0 2
25672: PUSH
25673: LD_INT 1
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: LD_INT 3
25681: PUSH
25682: LD_INT 4
25684: PUSH
25685: LD_INT 5
25687: PUSH
25688: LD_INT 6
25690: PUSH
25691: LD_INT 7
25693: PUSH
25694: LD_INT 8
25696: PUSH
25697: LD_INT 9
25699: PUSH
25700: LD_INT 10
25702: PUSH
25703: LD_INT 11
25705: PUSH
25706: LD_INT 12
25708: PUSH
25709: LD_INT 13
25711: PUSH
25712: LD_INT 14
25714: PUSH
25715: LD_INT 15
25717: PUSH
25718: LD_INT 16
25720: PUSH
25721: LD_INT 17
25723: PUSH
25724: LD_INT 18
25726: PUSH
25727: LD_INT 19
25729: PUSH
25730: LD_INT 20
25732: PUSH
25733: LD_INT 21
25735: PUSH
25736: LD_INT 22
25738: PUSH
25739: LD_INT 23
25741: PUSH
25742: LD_INT 24
25744: PUSH
25745: LD_INT 25
25747: PUSH
25748: LD_INT 26
25750: PUSH
25751: LD_INT 27
25753: PUSH
25754: LD_INT 28
25756: PUSH
25757: LD_INT 29
25759: PUSH
25760: LD_INT 30
25762: PUSH
25763: LD_INT 31
25765: PUSH
25766: LD_INT 32
25768: PUSH
25769: LD_INT 33
25771: PUSH
25772: LD_INT 34
25774: PUSH
25775: LD_INT 35
25777: PUSH
25778: LD_INT 36
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: LIST
25785: LIST
25786: LIST
25787: LIST
25788: LIST
25789: LIST
25790: LIST
25791: LIST
25792: LIST
25793: LIST
25794: LIST
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: LIST
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: LIST
25806: LIST
25807: LIST
25808: LIST
25809: LIST
25810: LIST
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: LIST
25817: LIST
25818: PUSH
25819: LD_INT 101
25821: PUSH
25822: LD_INT 102
25824: PUSH
25825: LD_INT 103
25827: PUSH
25828: LD_INT 104
25830: PUSH
25831: LD_INT 105
25833: PUSH
25834: LD_INT 106
25836: PUSH
25837: LD_INT 107
25839: PUSH
25840: LD_INT 108
25842: PUSH
25843: LD_INT 109
25845: PUSH
25846: LD_INT 110
25848: PUSH
25849: LD_INT 111
25851: PUSH
25852: LD_INT 112
25854: PUSH
25855: LD_INT 113
25857: PUSH
25858: LD_INT 114
25860: PUSH
25861: LD_INT 115
25863: PUSH
25864: LD_INT 116
25866: PUSH
25867: LD_INT 117
25869: PUSH
25870: LD_INT 118
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: LIST
25877: LIST
25878: LIST
25879: LIST
25880: LIST
25881: LIST
25882: LIST
25883: LIST
25884: LIST
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: ST_TO_ADDR
25897: GO 25900
25899: POP
// end else
25900: GO 26131
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
25902: LD_ADDR_VAR 0 2
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 2
25912: PUSH
25913: LD_INT 3
25915: PUSH
25916: LD_INT 4
25918: PUSH
25919: LD_INT 5
25921: PUSH
25922: LD_INT 6
25924: PUSH
25925: LD_INT 7
25927: PUSH
25928: LD_INT 8
25930: PUSH
25931: LD_INT 9
25933: PUSH
25934: LD_INT 10
25936: PUSH
25937: LD_INT 11
25939: PUSH
25940: LD_INT 12
25942: PUSH
25943: LD_INT 13
25945: PUSH
25946: LD_INT 14
25948: PUSH
25949: LD_INT 15
25951: PUSH
25952: LD_INT 16
25954: PUSH
25955: LD_INT 17
25957: PUSH
25958: LD_INT 18
25960: PUSH
25961: LD_INT 19
25963: PUSH
25964: LD_INT 20
25966: PUSH
25967: LD_INT 21
25969: PUSH
25970: LD_INT 22
25972: PUSH
25973: LD_INT 23
25975: PUSH
25976: LD_INT 24
25978: PUSH
25979: LD_INT 25
25981: PUSH
25982: LD_INT 26
25984: PUSH
25985: LD_INT 27
25987: PUSH
25988: LD_INT 28
25990: PUSH
25991: LD_INT 29
25993: PUSH
25994: LD_INT 30
25996: PUSH
25997: LD_INT 31
25999: PUSH
26000: LD_INT 32
26002: PUSH
26003: LD_INT 33
26005: PUSH
26006: LD_INT 34
26008: PUSH
26009: LD_INT 35
26011: PUSH
26012: LD_INT 36
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: LIST
26030: LIST
26031: LIST
26032: LIST
26033: LIST
26034: LIST
26035: LIST
26036: LIST
26037: LIST
26038: LIST
26039: LIST
26040: LIST
26041: LIST
26042: LIST
26043: LIST
26044: LIST
26045: LIST
26046: LIST
26047: LIST
26048: LIST
26049: LIST
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 101
26055: PUSH
26056: LD_INT 102
26058: PUSH
26059: LD_INT 103
26061: PUSH
26062: LD_INT 104
26064: PUSH
26065: LD_INT 105
26067: PUSH
26068: LD_INT 106
26070: PUSH
26071: LD_INT 107
26073: PUSH
26074: LD_INT 108
26076: PUSH
26077: LD_INT 109
26079: PUSH
26080: LD_INT 110
26082: PUSH
26083: LD_INT 111
26085: PUSH
26086: LD_INT 112
26088: PUSH
26089: LD_INT 113
26091: PUSH
26092: LD_INT 114
26094: PUSH
26095: LD_INT 115
26097: PUSH
26098: LD_INT 116
26100: PUSH
26101: LD_INT 117
26103: PUSH
26104: LD_INT 118
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: LIST
26111: LIST
26112: LIST
26113: LIST
26114: LIST
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: ST_TO_ADDR
// if result then
26131: LD_VAR 0 2
26135: IFFALSE 26921
// begin normal :=  ;
26137: LD_ADDR_VAR 0 5
26141: PUSH
26142: LD_STRING 
26144: ST_TO_ADDR
// hardcore :=  ;
26145: LD_ADDR_VAR 0 6
26149: PUSH
26150: LD_STRING 
26152: ST_TO_ADDR
// active :=  ;
26153: LD_ADDR_VAR 0 7
26157: PUSH
26158: LD_STRING 
26160: ST_TO_ADDR
// for i = 1 to normalCounter do
26161: LD_ADDR_VAR 0 8
26165: PUSH
26166: DOUBLE
26167: LD_INT 1
26169: DEC
26170: ST_TO_ADDR
26171: LD_EXP 30
26175: PUSH
26176: FOR_TO
26177: IFFALSE 26278
// begin tmp := 0 ;
26179: LD_ADDR_VAR 0 3
26183: PUSH
26184: LD_STRING 0
26186: ST_TO_ADDR
// if result [ 1 ] then
26187: LD_VAR 0 2
26191: PUSH
26192: LD_INT 1
26194: ARRAY
26195: IFFALSE 26260
// if result [ 1 ] [ 1 ] = i then
26197: LD_VAR 0 2
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: PUSH
26206: LD_INT 1
26208: ARRAY
26209: PUSH
26210: LD_VAR 0 8
26214: EQUAL
26215: IFFALSE 26260
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
26217: LD_ADDR_VAR 0 2
26221: PUSH
26222: LD_VAR 0 2
26226: PPUSH
26227: LD_INT 1
26229: PPUSH
26230: LD_VAR 0 2
26234: PUSH
26235: LD_INT 1
26237: ARRAY
26238: PPUSH
26239: LD_INT 1
26241: PPUSH
26242: CALL_OW 3
26246: PPUSH
26247: CALL_OW 1
26251: ST_TO_ADDR
// tmp := 1 ;
26252: LD_ADDR_VAR 0 3
26256: PUSH
26257: LD_STRING 1
26259: ST_TO_ADDR
// end ; normal := normal & tmp ;
26260: LD_ADDR_VAR 0 5
26264: PUSH
26265: LD_VAR 0 5
26269: PUSH
26270: LD_VAR 0 3
26274: STR
26275: ST_TO_ADDR
// end ;
26276: GO 26176
26278: POP
26279: POP
// for i = 1 to hardcoreCounter do
26280: LD_ADDR_VAR 0 8
26284: PUSH
26285: DOUBLE
26286: LD_INT 1
26288: DEC
26289: ST_TO_ADDR
26290: LD_EXP 31
26294: PUSH
26295: FOR_TO
26296: IFFALSE 26401
// begin tmp := 0 ;
26298: LD_ADDR_VAR 0 3
26302: PUSH
26303: LD_STRING 0
26305: ST_TO_ADDR
// if result [ 2 ] then
26306: LD_VAR 0 2
26310: PUSH
26311: LD_INT 2
26313: ARRAY
26314: IFFALSE 26383
// if result [ 2 ] [ 1 ] = 100 + i then
26316: LD_VAR 0 2
26320: PUSH
26321: LD_INT 2
26323: ARRAY
26324: PUSH
26325: LD_INT 1
26327: ARRAY
26328: PUSH
26329: LD_INT 100
26331: PUSH
26332: LD_VAR 0 8
26336: PLUS
26337: EQUAL
26338: IFFALSE 26383
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
26340: LD_ADDR_VAR 0 2
26344: PUSH
26345: LD_VAR 0 2
26349: PPUSH
26350: LD_INT 2
26352: PPUSH
26353: LD_VAR 0 2
26357: PUSH
26358: LD_INT 2
26360: ARRAY
26361: PPUSH
26362: LD_INT 1
26364: PPUSH
26365: CALL_OW 3
26369: PPUSH
26370: CALL_OW 1
26374: ST_TO_ADDR
// tmp := 1 ;
26375: LD_ADDR_VAR 0 3
26379: PUSH
26380: LD_STRING 1
26382: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
26383: LD_ADDR_VAR 0 6
26387: PUSH
26388: LD_VAR 0 6
26392: PUSH
26393: LD_VAR 0 3
26397: STR
26398: ST_TO_ADDR
// end ;
26399: GO 26295
26401: POP
26402: POP
// if isGameLoad then
26403: LD_VAR 0 1
26407: IFFALSE 26882
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
26409: LD_ADDR_VAR 0 4
26413: PUSH
26414: LD_EXP 34
26418: PUSH
26419: LD_EXP 33
26423: PUSH
26424: LD_EXP 35
26428: PUSH
26429: LD_EXP 32
26433: PUSH
26434: LD_EXP 36
26438: PUSH
26439: LD_EXP 37
26443: PUSH
26444: LD_EXP 38
26448: PUSH
26449: LD_EXP 39
26453: PUSH
26454: LD_EXP 40
26458: PUSH
26459: LD_EXP 41
26463: PUSH
26464: LD_EXP 42
26468: PUSH
26469: LD_EXP 43
26473: PUSH
26474: LD_EXP 44
26478: PUSH
26479: LD_EXP 45
26483: PUSH
26484: LD_EXP 53
26488: PUSH
26489: LD_EXP 54
26493: PUSH
26494: LD_EXP 55
26498: PUSH
26499: LD_EXP 56
26503: PUSH
26504: LD_EXP 58
26508: PUSH
26509: LD_EXP 59
26513: PUSH
26514: LD_EXP 60
26518: PUSH
26519: LD_EXP 63
26523: PUSH
26524: LD_EXP 65
26528: PUSH
26529: LD_EXP 66
26533: PUSH
26534: LD_EXP 67
26538: PUSH
26539: LD_EXP 69
26543: PUSH
26544: LD_EXP 70
26548: PUSH
26549: LD_EXP 73
26553: PUSH
26554: LD_EXP 74
26558: PUSH
26559: LD_EXP 75
26563: PUSH
26564: LD_EXP 76
26568: PUSH
26569: LD_EXP 77
26573: PUSH
26574: LD_EXP 78
26578: PUSH
26579: LD_EXP 79
26583: PUSH
26584: LD_EXP 80
26588: PUSH
26589: LD_EXP 81
26593: PUSH
26594: LD_EXP 46
26598: PUSH
26599: LD_EXP 47
26603: PUSH
26604: LD_EXP 50
26608: PUSH
26609: LD_EXP 51
26613: PUSH
26614: LD_EXP 52
26618: PUSH
26619: LD_EXP 48
26623: PUSH
26624: LD_EXP 49
26628: PUSH
26629: LD_EXP 57
26633: PUSH
26634: LD_EXP 61
26638: PUSH
26639: LD_EXP 62
26643: PUSH
26644: LD_EXP 64
26648: PUSH
26649: LD_EXP 68
26653: PUSH
26654: LD_EXP 71
26658: PUSH
26659: LD_EXP 72
26663: PUSH
26664: LD_EXP 82
26668: PUSH
26669: LD_EXP 83
26673: PUSH
26674: LD_EXP 84
26678: PUSH
26679: LD_EXP 85
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: LIST
26688: LIST
26689: LIST
26690: LIST
26691: LIST
26692: LIST
26693: LIST
26694: LIST
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: LIST
26706: LIST
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: LIST
26712: LIST
26713: LIST
26714: LIST
26715: LIST
26716: LIST
26717: LIST
26718: LIST
26719: LIST
26720: LIST
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: ST_TO_ADDR
// tmp :=  ;
26740: LD_ADDR_VAR 0 3
26744: PUSH
26745: LD_STRING 
26747: ST_TO_ADDR
// for i = 1 to normalCounter do
26748: LD_ADDR_VAR 0 8
26752: PUSH
26753: DOUBLE
26754: LD_INT 1
26756: DEC
26757: ST_TO_ADDR
26758: LD_EXP 30
26762: PUSH
26763: FOR_TO
26764: IFFALSE 26800
// begin if flags [ i ] then
26766: LD_VAR 0 4
26770: PUSH
26771: LD_VAR 0 8
26775: ARRAY
26776: IFFALSE 26798
// tmp := tmp & i & ; ;
26778: LD_ADDR_VAR 0 3
26782: PUSH
26783: LD_VAR 0 3
26787: PUSH
26788: LD_VAR 0 8
26792: STR
26793: PUSH
26794: LD_STRING ;
26796: STR
26797: ST_TO_ADDR
// end ;
26798: GO 26763
26800: POP
26801: POP
// for i = 1 to hardcoreCounter do
26802: LD_ADDR_VAR 0 8
26806: PUSH
26807: DOUBLE
26808: LD_INT 1
26810: DEC
26811: ST_TO_ADDR
26812: LD_EXP 31
26816: PUSH
26817: FOR_TO
26818: IFFALSE 26864
// begin if flags [ normalCounter + i ] then
26820: LD_VAR 0 4
26824: PUSH
26825: LD_EXP 30
26829: PUSH
26830: LD_VAR 0 8
26834: PLUS
26835: ARRAY
26836: IFFALSE 26862
// tmp := tmp & ( 100 + i ) & ; ;
26838: LD_ADDR_VAR 0 3
26842: PUSH
26843: LD_VAR 0 3
26847: PUSH
26848: LD_INT 100
26850: PUSH
26851: LD_VAR 0 8
26855: PLUS
26856: STR
26857: PUSH
26858: LD_STRING ;
26860: STR
26861: ST_TO_ADDR
// end ;
26862: GO 26817
26864: POP
26865: POP
// if tmp then
26866: LD_VAR 0 3
26870: IFFALSE 26882
// active := tmp ;
26872: LD_ADDR_VAR 0 7
26876: PUSH
26877: LD_VAR 0 3
26881: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
26882: LD_STRING getStreamItemsFromMission("
26884: PUSH
26885: LD_VAR 0 5
26889: STR
26890: PUSH
26891: LD_STRING ","
26893: STR
26894: PUSH
26895: LD_VAR 0 6
26899: STR
26900: PUSH
26901: LD_STRING ","
26903: STR
26904: PUSH
26905: LD_VAR 0 7
26909: STR
26910: PUSH
26911: LD_STRING ")
26913: STR
26914: PPUSH
26915: CALL_OW 559
// end else
26919: GO 26928
// ToLua ( getStreamItemsFromMission("","","") ) ;
26921: LD_STRING getStreamItemsFromMission("","","")
26923: PPUSH
26924: CALL_OW 559
// end ;
26928: LD_VAR 0 2
26932: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
26933: LD_EXP 29
26937: PUSH
26938: LD_EXP 34
26942: AND
26943: IFFALSE 27067
26945: GO 26947
26947: DISABLE
26948: LD_INT 0
26950: PPUSH
26951: PPUSH
// begin enable ;
26952: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
26953: LD_ADDR_VAR 0 2
26957: PUSH
26958: LD_INT 22
26960: PUSH
26961: LD_OWVAR 2
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: LD_INT 2
26972: PUSH
26973: LD_INT 34
26975: PUSH
26976: LD_INT 7
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: PUSH
26983: LD_INT 34
26985: PUSH
26986: LD_INT 45
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PUSH
26993: LD_INT 34
26995: PUSH
26996: LD_INT 28
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 34
27005: PUSH
27006: LD_INT 47
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 69
27028: ST_TO_ADDR
// if not tmp then
27029: LD_VAR 0 2
27033: NOT
27034: IFFALSE 27038
// exit ;
27036: GO 27067
// for i in tmp do
27038: LD_ADDR_VAR 0 1
27042: PUSH
27043: LD_VAR 0 2
27047: PUSH
27048: FOR_IN
27049: IFFALSE 27065
// begin SetLives ( i , 0 ) ;
27051: LD_VAR 0 1
27055: PPUSH
27056: LD_INT 0
27058: PPUSH
27059: CALL_OW 234
// end ;
27063: GO 27048
27065: POP
27066: POP
// end ;
27067: PPOPN 2
27069: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
27070: LD_EXP 29
27074: PUSH
27075: LD_EXP 35
27079: AND
27080: IFFALSE 27164
27082: GO 27084
27084: DISABLE
27085: LD_INT 0
27087: PPUSH
27088: PPUSH
// begin enable ;
27089: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
27090: LD_ADDR_VAR 0 2
27094: PUSH
27095: LD_INT 22
27097: PUSH
27098: LD_OWVAR 2
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: LD_INT 32
27109: PUSH
27110: LD_INT 3
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PPUSH
27121: CALL_OW 69
27125: ST_TO_ADDR
// if not tmp then
27126: LD_VAR 0 2
27130: NOT
27131: IFFALSE 27135
// exit ;
27133: GO 27164
// for i in tmp do
27135: LD_ADDR_VAR 0 1
27139: PUSH
27140: LD_VAR 0 2
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27162
// begin SetLives ( i , 0 ) ;
27148: LD_VAR 0 1
27152: PPUSH
27153: LD_INT 0
27155: PPUSH
27156: CALL_OW 234
// end ;
27160: GO 27145
27162: POP
27163: POP
// end ;
27164: PPOPN 2
27166: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
27167: LD_EXP 29
27171: PUSH
27172: LD_EXP 32
27176: AND
27177: IFFALSE 27270
27179: GO 27181
27181: DISABLE
27182: LD_INT 0
27184: PPUSH
// begin enable ;
27185: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
27186: LD_ADDR_VAR 0 1
27190: PUSH
27191: LD_INT 22
27193: PUSH
27194: LD_OWVAR 2
27198: PUSH
27199: EMPTY
27200: LIST
27201: LIST
27202: PUSH
27203: LD_INT 2
27205: PUSH
27206: LD_INT 25
27208: PUSH
27209: LD_INT 5
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 25
27218: PUSH
27219: LD_INT 9
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 25
27228: PUSH
27229: LD_INT 8
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: LIST
27240: LIST
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PPUSH
27246: CALL_OW 69
27250: PUSH
27251: FOR_IN
27252: IFFALSE 27268
// begin SetClass ( i , 1 ) ;
27254: LD_VAR 0 1
27258: PPUSH
27259: LD_INT 1
27261: PPUSH
27262: CALL_OW 336
// end ;
27266: GO 27251
27268: POP
27269: POP
// end ;
27270: PPOPN 1
27272: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
27273: LD_EXP 29
27277: PUSH
27278: LD_EXP 33
27282: AND
27283: PUSH
27284: LD_OWVAR 65
27288: PUSH
27289: LD_INT 7
27291: LESS
27292: AND
27293: IFFALSE 27307
27295: GO 27297
27297: DISABLE
// begin enable ;
27298: ENABLE
// game_speed := 7 ;
27299: LD_ADDR_OWVAR 65
27303: PUSH
27304: LD_INT 7
27306: ST_TO_ADDR
// end ;
27307: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
27308: LD_EXP 29
27312: PUSH
27313: LD_EXP 36
27317: AND
27318: IFFALSE 27520
27320: GO 27322
27322: DISABLE
27323: LD_INT 0
27325: PPUSH
27326: PPUSH
27327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
27328: LD_ADDR_VAR 0 3
27332: PUSH
27333: LD_INT 81
27335: PUSH
27336: LD_OWVAR 2
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 21
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PPUSH
27359: CALL_OW 69
27363: ST_TO_ADDR
// if not tmp then
27364: LD_VAR 0 3
27368: NOT
27369: IFFALSE 27373
// exit ;
27371: GO 27520
// if tmp > 5 then
27373: LD_VAR 0 3
27377: PUSH
27378: LD_INT 5
27380: GREATER
27381: IFFALSE 27393
// k := 5 else
27383: LD_ADDR_VAR 0 2
27387: PUSH
27388: LD_INT 5
27390: ST_TO_ADDR
27391: GO 27403
// k := tmp ;
27393: LD_ADDR_VAR 0 2
27397: PUSH
27398: LD_VAR 0 3
27402: ST_TO_ADDR
// for i := 1 to k do
27403: LD_ADDR_VAR 0 1
27407: PUSH
27408: DOUBLE
27409: LD_INT 1
27411: DEC
27412: ST_TO_ADDR
27413: LD_VAR 0 2
27417: PUSH
27418: FOR_TO
27419: IFFALSE 27518
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
27421: LD_VAR 0 3
27425: PUSH
27426: LD_VAR 0 1
27430: ARRAY
27431: PPUSH
27432: LD_VAR 0 1
27436: PUSH
27437: LD_INT 4
27439: MOD
27440: PUSH
27441: LD_INT 1
27443: PLUS
27444: PPUSH
27445: CALL_OW 259
27449: PUSH
27450: LD_INT 10
27452: LESS
27453: IFFALSE 27516
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
27455: LD_VAR 0 3
27459: PUSH
27460: LD_VAR 0 1
27464: ARRAY
27465: PPUSH
27466: LD_VAR 0 1
27470: PUSH
27471: LD_INT 4
27473: MOD
27474: PUSH
27475: LD_INT 1
27477: PLUS
27478: PPUSH
27479: LD_VAR 0 3
27483: PUSH
27484: LD_VAR 0 1
27488: ARRAY
27489: PPUSH
27490: LD_VAR 0 1
27494: PUSH
27495: LD_INT 4
27497: MOD
27498: PUSH
27499: LD_INT 1
27501: PLUS
27502: PPUSH
27503: CALL_OW 259
27507: PUSH
27508: LD_INT 1
27510: PLUS
27511: PPUSH
27512: CALL_OW 237
27516: GO 27418
27518: POP
27519: POP
// end ;
27520: PPOPN 3
27522: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
27523: LD_EXP 29
27527: PUSH
27528: LD_EXP 37
27532: AND
27533: IFFALSE 27553
27535: GO 27537
27537: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
27538: LD_INT 4
27540: PPUSH
27541: LD_OWVAR 2
27545: PPUSH
27546: LD_INT 0
27548: PPUSH
27549: CALL_OW 324
27553: END
// every 0 0$1 trigger StreamModeActive and sShovel do
27554: LD_EXP 29
27558: PUSH
27559: LD_EXP 66
27563: AND
27564: IFFALSE 27584
27566: GO 27568
27568: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
27569: LD_INT 19
27571: PPUSH
27572: LD_OWVAR 2
27576: PPUSH
27577: LD_INT 0
27579: PPUSH
27580: CALL_OW 324
27584: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
27585: LD_EXP 29
27589: PUSH
27590: LD_EXP 38
27594: AND
27595: IFFALSE 27697
27597: GO 27599
27599: DISABLE
27600: LD_INT 0
27602: PPUSH
27603: PPUSH
// begin enable ;
27604: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
27605: LD_ADDR_VAR 0 2
27609: PUSH
27610: LD_INT 22
27612: PUSH
27613: LD_OWVAR 2
27617: PUSH
27618: EMPTY
27619: LIST
27620: LIST
27621: PUSH
27622: LD_INT 2
27624: PUSH
27625: LD_INT 34
27627: PUSH
27628: LD_INT 11
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 34
27637: PUSH
27638: LD_INT 30
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: LIST
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: PPUSH
27654: CALL_OW 69
27658: ST_TO_ADDR
// if not tmp then
27659: LD_VAR 0 2
27663: NOT
27664: IFFALSE 27668
// exit ;
27666: GO 27697
// for i in tmp do
27668: LD_ADDR_VAR 0 1
27672: PUSH
27673: LD_VAR 0 2
27677: PUSH
27678: FOR_IN
27679: IFFALSE 27695
// begin SetLives ( i , 0 ) ;
27681: LD_VAR 0 1
27685: PPUSH
27686: LD_INT 0
27688: PPUSH
27689: CALL_OW 234
// end ;
27693: GO 27678
27695: POP
27696: POP
// end ;
27697: PPOPN 2
27699: END
// every 0 0$1 trigger StreamModeActive and sBunker do
27700: LD_EXP 29
27704: PUSH
27705: LD_EXP 39
27709: AND
27710: IFFALSE 27730
27712: GO 27714
27714: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
27715: LD_INT 32
27717: PPUSH
27718: LD_OWVAR 2
27722: PPUSH
27723: LD_INT 0
27725: PPUSH
27726: CALL_OW 324
27730: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
27731: LD_EXP 29
27735: PUSH
27736: LD_EXP 40
27740: AND
27741: IFFALSE 27922
27743: GO 27745
27745: DISABLE
27746: LD_INT 0
27748: PPUSH
27749: PPUSH
27750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
27751: LD_ADDR_VAR 0 2
27755: PUSH
27756: LD_INT 22
27758: PUSH
27759: LD_OWVAR 2
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 33
27770: PUSH
27771: LD_INT 3
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PPUSH
27782: CALL_OW 69
27786: ST_TO_ADDR
// if not tmp then
27787: LD_VAR 0 2
27791: NOT
27792: IFFALSE 27796
// exit ;
27794: GO 27922
// side := 0 ;
27796: LD_ADDR_VAR 0 3
27800: PUSH
27801: LD_INT 0
27803: ST_TO_ADDR
// for i := 1 to 8 do
27804: LD_ADDR_VAR 0 1
27808: PUSH
27809: DOUBLE
27810: LD_INT 1
27812: DEC
27813: ST_TO_ADDR
27814: LD_INT 8
27816: PUSH
27817: FOR_TO
27818: IFFALSE 27866
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
27820: LD_OWVAR 2
27824: PUSH
27825: LD_VAR 0 1
27829: NONEQUAL
27830: PUSH
27831: LD_OWVAR 2
27835: PPUSH
27836: LD_VAR 0 1
27840: PPUSH
27841: CALL_OW 81
27845: PUSH
27846: LD_INT 2
27848: EQUAL
27849: AND
27850: IFFALSE 27864
// begin side := i ;
27852: LD_ADDR_VAR 0 3
27856: PUSH
27857: LD_VAR 0 1
27861: ST_TO_ADDR
// break ;
27862: GO 27866
// end ;
27864: GO 27817
27866: POP
27867: POP
// if not side then
27868: LD_VAR 0 3
27872: NOT
27873: IFFALSE 27877
// exit ;
27875: GO 27922
// for i := 1 to tmp do
27877: LD_ADDR_VAR 0 1
27881: PUSH
27882: DOUBLE
27883: LD_INT 1
27885: DEC
27886: ST_TO_ADDR
27887: LD_VAR 0 2
27891: PUSH
27892: FOR_TO
27893: IFFALSE 27920
// if Prob ( 60 ) then
27895: LD_INT 60
27897: PPUSH
27898: CALL_OW 13
27902: IFFALSE 27918
// SetSide ( i , side ) ;
27904: LD_VAR 0 1
27908: PPUSH
27909: LD_VAR 0 3
27913: PPUSH
27914: CALL_OW 235
27918: GO 27892
27920: POP
27921: POP
// end ;
27922: PPOPN 3
27924: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
27925: LD_EXP 29
27929: PUSH
27930: LD_EXP 42
27934: AND
27935: IFFALSE 28054
27937: GO 27939
27939: DISABLE
27940: LD_INT 0
27942: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
27943: LD_ADDR_VAR 0 1
27947: PUSH
27948: LD_INT 22
27950: PUSH
27951: LD_OWVAR 2
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 21
27962: PUSH
27963: LD_INT 1
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 3
27972: PUSH
27973: LD_INT 23
27975: PUSH
27976: LD_INT 0
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: LIST
27991: PPUSH
27992: CALL_OW 69
27996: PUSH
27997: FOR_IN
27998: IFFALSE 28052
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
28000: LD_VAR 0 1
28004: PPUSH
28005: CALL_OW 257
28009: PUSH
28010: LD_INT 1
28012: PUSH
28013: LD_INT 2
28015: PUSH
28016: LD_INT 3
28018: PUSH
28019: LD_INT 4
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: LIST
28026: LIST
28027: IN
28028: IFFALSE 28050
// SetClass ( un , rand ( 1 , 4 ) ) ;
28030: LD_VAR 0 1
28034: PPUSH
28035: LD_INT 1
28037: PPUSH
28038: LD_INT 4
28040: PPUSH
28041: CALL_OW 12
28045: PPUSH
28046: CALL_OW 336
28050: GO 27997
28052: POP
28053: POP
// end ;
28054: PPOPN 1
28056: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
28057: LD_EXP 29
28061: PUSH
28062: LD_EXP 41
28066: AND
28067: IFFALSE 28146
28069: GO 28071
28071: DISABLE
28072: LD_INT 0
28074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
28075: LD_ADDR_VAR 0 1
28079: PUSH
28080: LD_INT 22
28082: PUSH
28083: LD_OWVAR 2
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 21
28094: PUSH
28095: LD_INT 3
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PPUSH
28106: CALL_OW 69
28110: ST_TO_ADDR
// if not tmp then
28111: LD_VAR 0 1
28115: NOT
28116: IFFALSE 28120
// exit ;
28118: GO 28146
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
28120: LD_VAR 0 1
28124: PUSH
28125: LD_INT 1
28127: PPUSH
28128: LD_VAR 0 1
28132: PPUSH
28133: CALL_OW 12
28137: ARRAY
28138: PPUSH
28139: LD_INT 100
28141: PPUSH
28142: CALL_OW 234
// end ;
28146: PPOPN 1
28148: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
28149: LD_EXP 29
28153: PUSH
28154: LD_EXP 43
28158: AND
28159: IFFALSE 28257
28161: GO 28163
28163: DISABLE
28164: LD_INT 0
28166: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28167: LD_ADDR_VAR 0 1
28171: PUSH
28172: LD_INT 22
28174: PUSH
28175: LD_OWVAR 2
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 21
28186: PUSH
28187: LD_INT 1
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PPUSH
28198: CALL_OW 69
28202: ST_TO_ADDR
// if not tmp then
28203: LD_VAR 0 1
28207: NOT
28208: IFFALSE 28212
// exit ;
28210: GO 28257
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
28212: LD_VAR 0 1
28216: PUSH
28217: LD_INT 1
28219: PPUSH
28220: LD_VAR 0 1
28224: PPUSH
28225: CALL_OW 12
28229: ARRAY
28230: PPUSH
28231: LD_INT 1
28233: PPUSH
28234: LD_INT 4
28236: PPUSH
28237: CALL_OW 12
28241: PPUSH
28242: LD_INT 3000
28244: PPUSH
28245: LD_INT 9000
28247: PPUSH
28248: CALL_OW 12
28252: PPUSH
28253: CALL_OW 492
// end ;
28257: PPOPN 1
28259: END
// every 0 0$1 trigger StreamModeActive and sDepot do
28260: LD_EXP 29
28264: PUSH
28265: LD_EXP 44
28269: AND
28270: IFFALSE 28290
28272: GO 28274
28274: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
28275: LD_INT 1
28277: PPUSH
28278: LD_OWVAR 2
28282: PPUSH
28283: LD_INT 0
28285: PPUSH
28286: CALL_OW 324
28290: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
28291: LD_EXP 29
28295: PUSH
28296: LD_EXP 45
28300: AND
28301: IFFALSE 28384
28303: GO 28305
28305: DISABLE
28306: LD_INT 0
28308: PPUSH
28309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
28310: LD_ADDR_VAR 0 2
28314: PUSH
28315: LD_INT 22
28317: PUSH
28318: LD_OWVAR 2
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 21
28329: PUSH
28330: LD_INT 3
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PPUSH
28341: CALL_OW 69
28345: ST_TO_ADDR
// if not tmp then
28346: LD_VAR 0 2
28350: NOT
28351: IFFALSE 28355
// exit ;
28353: GO 28384
// for i in tmp do
28355: LD_ADDR_VAR 0 1
28359: PUSH
28360: LD_VAR 0 2
28364: PUSH
28365: FOR_IN
28366: IFFALSE 28382
// SetBLevel ( i , 10 ) ;
28368: LD_VAR 0 1
28372: PPUSH
28373: LD_INT 10
28375: PPUSH
28376: CALL_OW 241
28380: GO 28365
28382: POP
28383: POP
// end ;
28384: PPOPN 2
28386: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
28387: LD_EXP 29
28391: PUSH
28392: LD_EXP 46
28396: AND
28397: IFFALSE 28508
28399: GO 28401
28401: DISABLE
28402: LD_INT 0
28404: PPUSH
28405: PPUSH
28406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28407: LD_ADDR_VAR 0 3
28411: PUSH
28412: LD_INT 22
28414: PUSH
28415: LD_OWVAR 2
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 25
28426: PUSH
28427: LD_INT 1
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PPUSH
28438: CALL_OW 69
28442: ST_TO_ADDR
// if not tmp then
28443: LD_VAR 0 3
28447: NOT
28448: IFFALSE 28452
// exit ;
28450: GO 28508
// un := tmp [ rand ( 1 , tmp ) ] ;
28452: LD_ADDR_VAR 0 2
28456: PUSH
28457: LD_VAR 0 3
28461: PUSH
28462: LD_INT 1
28464: PPUSH
28465: LD_VAR 0 3
28469: PPUSH
28470: CALL_OW 12
28474: ARRAY
28475: ST_TO_ADDR
// if Crawls ( un ) then
28476: LD_VAR 0 2
28480: PPUSH
28481: CALL_OW 318
28485: IFFALSE 28496
// ComWalk ( un ) ;
28487: LD_VAR 0 2
28491: PPUSH
28492: CALL_OW 138
// SetClass ( un , class_sniper ) ;
28496: LD_VAR 0 2
28500: PPUSH
28501: LD_INT 5
28503: PPUSH
28504: CALL_OW 336
// end ;
28508: PPOPN 3
28510: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
28511: LD_EXP 29
28515: PUSH
28516: LD_EXP 47
28520: AND
28521: PUSH
28522: LD_OWVAR 67
28526: PUSH
28527: LD_INT 4
28529: LESS
28530: AND
28531: IFFALSE 28550
28533: GO 28535
28535: DISABLE
// begin Difficulty := Difficulty + 1 ;
28536: LD_ADDR_OWVAR 67
28540: PUSH
28541: LD_OWVAR 67
28545: PUSH
28546: LD_INT 1
28548: PLUS
28549: ST_TO_ADDR
// end ;
28550: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
28551: LD_EXP 29
28555: PUSH
28556: LD_EXP 48
28560: AND
28561: IFFALSE 28664
28563: GO 28565
28565: DISABLE
28566: LD_INT 0
28568: PPUSH
// begin for i := 1 to 5 do
28569: LD_ADDR_VAR 0 1
28573: PUSH
28574: DOUBLE
28575: LD_INT 1
28577: DEC
28578: ST_TO_ADDR
28579: LD_INT 5
28581: PUSH
28582: FOR_TO
28583: IFFALSE 28662
// begin uc_nation := nation_nature ;
28585: LD_ADDR_OWVAR 21
28589: PUSH
28590: LD_INT 0
28592: ST_TO_ADDR
// uc_side := 0 ;
28593: LD_ADDR_OWVAR 20
28597: PUSH
28598: LD_INT 0
28600: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
28601: LD_ADDR_OWVAR 29
28605: PUSH
28606: LD_INT 12
28608: PUSH
28609: LD_INT 12
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: ST_TO_ADDR
// hc_agressivity := 20 ;
28616: LD_ADDR_OWVAR 35
28620: PUSH
28621: LD_INT 20
28623: ST_TO_ADDR
// hc_class := class_tiger ;
28624: LD_ADDR_OWVAR 28
28628: PUSH
28629: LD_INT 14
28631: ST_TO_ADDR
// hc_gallery :=  ;
28632: LD_ADDR_OWVAR 33
28636: PUSH
28637: LD_STRING 
28639: ST_TO_ADDR
// hc_name :=  ;
28640: LD_ADDR_OWVAR 26
28644: PUSH
28645: LD_STRING 
28647: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
28648: CALL_OW 44
28652: PPUSH
28653: LD_INT 0
28655: PPUSH
28656: CALL_OW 51
// end ;
28660: GO 28582
28662: POP
28663: POP
// end ;
28664: PPOPN 1
28666: END
// every 0 0$1 trigger StreamModeActive and sBomb do
28667: LD_EXP 29
28671: PUSH
28672: LD_EXP 49
28676: AND
28677: IFFALSE 28686
28679: GO 28681
28681: DISABLE
// StreamSibBomb ;
28682: CALL 28687 0 0
28686: END
// export function StreamSibBomb ; var i , x , y ; begin
28687: LD_INT 0
28689: PPUSH
28690: PPUSH
28691: PPUSH
28692: PPUSH
// result := false ;
28693: LD_ADDR_VAR 0 1
28697: PUSH
28698: LD_INT 0
28700: ST_TO_ADDR
// for i := 1 to 16 do
28701: LD_ADDR_VAR 0 2
28705: PUSH
28706: DOUBLE
28707: LD_INT 1
28709: DEC
28710: ST_TO_ADDR
28711: LD_INT 16
28713: PUSH
28714: FOR_TO
28715: IFFALSE 28914
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
28717: LD_ADDR_VAR 0 3
28721: PUSH
28722: LD_INT 10
28724: PUSH
28725: LD_INT 20
28727: PUSH
28728: LD_INT 30
28730: PUSH
28731: LD_INT 40
28733: PUSH
28734: LD_INT 50
28736: PUSH
28737: LD_INT 60
28739: PUSH
28740: LD_INT 70
28742: PUSH
28743: LD_INT 80
28745: PUSH
28746: LD_INT 90
28748: PUSH
28749: LD_INT 100
28751: PUSH
28752: LD_INT 110
28754: PUSH
28755: LD_INT 120
28757: PUSH
28758: LD_INT 130
28760: PUSH
28761: LD_INT 140
28763: PUSH
28764: LD_INT 150
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 1
28786: PPUSH
28787: LD_INT 15
28789: PPUSH
28790: CALL_OW 12
28794: ARRAY
28795: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
28796: LD_ADDR_VAR 0 4
28800: PUSH
28801: LD_INT 10
28803: PUSH
28804: LD_INT 20
28806: PUSH
28807: LD_INT 30
28809: PUSH
28810: LD_INT 40
28812: PUSH
28813: LD_INT 50
28815: PUSH
28816: LD_INT 60
28818: PUSH
28819: LD_INT 70
28821: PUSH
28822: LD_INT 80
28824: PUSH
28825: LD_INT 90
28827: PUSH
28828: LD_INT 100
28830: PUSH
28831: LD_INT 110
28833: PUSH
28834: LD_INT 120
28836: PUSH
28837: LD_INT 130
28839: PUSH
28840: LD_INT 140
28842: PUSH
28843: LD_INT 150
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PPUSH
28866: LD_INT 15
28868: PPUSH
28869: CALL_OW 12
28873: ARRAY
28874: ST_TO_ADDR
// if ValidHex ( x , y ) then
28875: LD_VAR 0 3
28879: PPUSH
28880: LD_VAR 0 4
28884: PPUSH
28885: CALL_OW 488
28889: IFFALSE 28912
// begin result := [ x , y ] ;
28891: LD_ADDR_VAR 0 1
28895: PUSH
28896: LD_VAR 0 3
28900: PUSH
28901: LD_VAR 0 4
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: ST_TO_ADDR
// break ;
28910: GO 28914
// end ; end ;
28912: GO 28714
28914: POP
28915: POP
// if result then
28916: LD_VAR 0 1
28920: IFFALSE 28980
// begin ToLua ( playSibBomb() ) ;
28922: LD_STRING playSibBomb()
28924: PPUSH
28925: CALL_OW 559
// wait ( 0 0$14 ) ;
28929: LD_INT 490
28931: PPUSH
28932: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
28936: LD_VAR 0 1
28940: PUSH
28941: LD_INT 1
28943: ARRAY
28944: PPUSH
28945: LD_VAR 0 1
28949: PUSH
28950: LD_INT 2
28952: ARRAY
28953: PPUSH
28954: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
28958: LD_VAR 0 1
28962: PUSH
28963: LD_INT 1
28965: ARRAY
28966: PPUSH
28967: LD_VAR 0 1
28971: PUSH
28972: LD_INT 2
28974: ARRAY
28975: PPUSH
28976: CALL_OW 429
// end ; end ;
28980: LD_VAR 0 1
28984: RET
// every 0 0$1 trigger StreamModeActive and sReset do
28985: LD_EXP 29
28989: PUSH
28990: LD_EXP 51
28994: AND
28995: IFFALSE 29007
28997: GO 28999
28999: DISABLE
// YouLost (  ) ;
29000: LD_STRING 
29002: PPUSH
29003: CALL_OW 104
29007: END
// every 0 0$1 trigger StreamModeActive and sFog do
29008: LD_EXP 29
29012: PUSH
29013: LD_EXP 50
29017: AND
29018: IFFALSE 29032
29020: GO 29022
29022: DISABLE
// FogOff ( your_side ) ;
29023: LD_OWVAR 2
29027: PPUSH
29028: CALL_OW 344
29032: END
// every 0 0$1 trigger StreamModeActive and sSun do
29033: LD_EXP 29
29037: PUSH
29038: LD_EXP 52
29042: AND
29043: IFFALSE 29071
29045: GO 29047
29047: DISABLE
// begin solar_recharge_percent := 0 ;
29048: LD_ADDR_OWVAR 79
29052: PUSH
29053: LD_INT 0
29055: ST_TO_ADDR
// wait ( 5 5$00 ) ;
29056: LD_INT 10500
29058: PPUSH
29059: CALL_OW 67
// solar_recharge_percent := 100 ;
29063: LD_ADDR_OWVAR 79
29067: PUSH
29068: LD_INT 100
29070: ST_TO_ADDR
// end ;
29071: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
29072: LD_EXP 29
29076: PUSH
29077: LD_EXP 53
29081: AND
29082: IFFALSE 29321
29084: GO 29086
29086: DISABLE
29087: LD_INT 0
29089: PPUSH
29090: PPUSH
29091: PPUSH
// begin tmp := [ ] ;
29092: LD_ADDR_VAR 0 3
29096: PUSH
29097: EMPTY
29098: ST_TO_ADDR
// for i := 1 to 6 do
29099: LD_ADDR_VAR 0 1
29103: PUSH
29104: DOUBLE
29105: LD_INT 1
29107: DEC
29108: ST_TO_ADDR
29109: LD_INT 6
29111: PUSH
29112: FOR_TO
29113: IFFALSE 29218
// begin uc_nation := nation_nature ;
29115: LD_ADDR_OWVAR 21
29119: PUSH
29120: LD_INT 0
29122: ST_TO_ADDR
// uc_side := 0 ;
29123: LD_ADDR_OWVAR 20
29127: PUSH
29128: LD_INT 0
29130: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
29131: LD_ADDR_OWVAR 29
29135: PUSH
29136: LD_INT 12
29138: PUSH
29139: LD_INT 12
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: ST_TO_ADDR
// hc_agressivity := 20 ;
29146: LD_ADDR_OWVAR 35
29150: PUSH
29151: LD_INT 20
29153: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
29154: LD_ADDR_OWVAR 28
29158: PUSH
29159: LD_INT 17
29161: ST_TO_ADDR
// hc_gallery :=  ;
29162: LD_ADDR_OWVAR 33
29166: PUSH
29167: LD_STRING 
29169: ST_TO_ADDR
// hc_name :=  ;
29170: LD_ADDR_OWVAR 26
29174: PUSH
29175: LD_STRING 
29177: ST_TO_ADDR
// un := CreateHuman ;
29178: LD_ADDR_VAR 0 2
29182: PUSH
29183: CALL_OW 44
29187: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
29188: LD_VAR 0 2
29192: PPUSH
29193: LD_INT 1
29195: PPUSH
29196: CALL_OW 51
// tmp := tmp ^ un ;
29200: LD_ADDR_VAR 0 3
29204: PUSH
29205: LD_VAR 0 3
29209: PUSH
29210: LD_VAR 0 2
29214: ADD
29215: ST_TO_ADDR
// end ;
29216: GO 29112
29218: POP
29219: POP
// repeat wait ( 0 0$1 ) ;
29220: LD_INT 35
29222: PPUSH
29223: CALL_OW 67
// for un in tmp do
29227: LD_ADDR_VAR 0 2
29231: PUSH
29232: LD_VAR 0 3
29236: PUSH
29237: FOR_IN
29238: IFFALSE 29312
// begin if IsDead ( un ) then
29240: LD_VAR 0 2
29244: PPUSH
29245: CALL_OW 301
29249: IFFALSE 29269
// begin tmp := tmp diff un ;
29251: LD_ADDR_VAR 0 3
29255: PUSH
29256: LD_VAR 0 3
29260: PUSH
29261: LD_VAR 0 2
29265: DIFF
29266: ST_TO_ADDR
// continue ;
29267: GO 29237
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
29269: LD_VAR 0 2
29273: PPUSH
29274: LD_INT 3
29276: PUSH
29277: LD_INT 22
29279: PUSH
29280: LD_INT 0
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PPUSH
29291: CALL_OW 69
29295: PPUSH
29296: LD_VAR 0 2
29300: PPUSH
29301: CALL_OW 74
29305: PPUSH
29306: CALL_OW 115
// end ;
29310: GO 29237
29312: POP
29313: POP
// until not tmp ;
29314: LD_VAR 0 3
29318: NOT
29319: IFFALSE 29220
// end ;
29321: PPOPN 3
29323: END
// every 0 0$1 trigger StreamModeActive and sTroll do
29324: LD_EXP 29
29328: PUSH
29329: LD_EXP 54
29333: AND
29334: IFFALSE 29388
29336: GO 29338
29338: DISABLE
// begin ToLua ( displayTroll(); ) ;
29339: LD_STRING displayTroll();
29341: PPUSH
29342: CALL_OW 559
// wait ( 3 3$00 ) ;
29346: LD_INT 6300
29348: PPUSH
29349: CALL_OW 67
// ToLua ( hideTroll(); ) ;
29353: LD_STRING hideTroll();
29355: PPUSH
29356: CALL_OW 559
// wait ( 1 1$00 ) ;
29360: LD_INT 2100
29362: PPUSH
29363: CALL_OW 67
// ToLua ( displayTroll(); ) ;
29367: LD_STRING displayTroll();
29369: PPUSH
29370: CALL_OW 559
// wait ( 1 1$00 ) ;
29374: LD_INT 2100
29376: PPUSH
29377: CALL_OW 67
// ToLua ( hideTroll(); ) ;
29381: LD_STRING hideTroll();
29383: PPUSH
29384: CALL_OW 559
// end ;
29388: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
29389: LD_EXP 29
29393: PUSH
29394: LD_EXP 55
29398: AND
29399: IFFALSE 29462
29401: GO 29403
29403: DISABLE
29404: LD_INT 0
29406: PPUSH
// begin p := 0 ;
29407: LD_ADDR_VAR 0 1
29411: PUSH
29412: LD_INT 0
29414: ST_TO_ADDR
// repeat game_speed := 1 ;
29415: LD_ADDR_OWVAR 65
29419: PUSH
29420: LD_INT 1
29422: ST_TO_ADDR
// wait ( 0 0$1 ) ;
29423: LD_INT 35
29425: PPUSH
29426: CALL_OW 67
// p := p + 1 ;
29430: LD_ADDR_VAR 0 1
29434: PUSH
29435: LD_VAR 0 1
29439: PUSH
29440: LD_INT 1
29442: PLUS
29443: ST_TO_ADDR
// until p >= 60 ;
29444: LD_VAR 0 1
29448: PUSH
29449: LD_INT 60
29451: GREATEREQUAL
29452: IFFALSE 29415
// game_speed := 4 ;
29454: LD_ADDR_OWVAR 65
29458: PUSH
29459: LD_INT 4
29461: ST_TO_ADDR
// end ;
29462: PPOPN 1
29464: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
29465: LD_EXP 29
29469: PUSH
29470: LD_EXP 56
29474: AND
29475: IFFALSE 29621
29477: GO 29479
29479: DISABLE
29480: LD_INT 0
29482: PPUSH
29483: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29484: LD_ADDR_VAR 0 1
29488: PUSH
29489: LD_INT 22
29491: PUSH
29492: LD_OWVAR 2
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 2
29503: PUSH
29504: LD_INT 30
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 30
29516: PUSH
29517: LD_INT 1
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: CALL_OW 69
29537: ST_TO_ADDR
// if not depot then
29538: LD_VAR 0 1
29542: NOT
29543: IFFALSE 29547
// exit ;
29545: GO 29621
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
29547: LD_ADDR_VAR 0 2
29551: PUSH
29552: LD_VAR 0 1
29556: PUSH
29557: LD_INT 1
29559: PPUSH
29560: LD_VAR 0 1
29564: PPUSH
29565: CALL_OW 12
29569: ARRAY
29570: PPUSH
29571: CALL_OW 274
29575: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
29576: LD_VAR 0 2
29580: PPUSH
29581: LD_INT 1
29583: PPUSH
29584: LD_INT 0
29586: PPUSH
29587: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
29591: LD_VAR 0 2
29595: PPUSH
29596: LD_INT 2
29598: PPUSH
29599: LD_INT 0
29601: PPUSH
29602: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
29606: LD_VAR 0 2
29610: PPUSH
29611: LD_INT 3
29613: PPUSH
29614: LD_INT 0
29616: PPUSH
29617: CALL_OW 277
// end ;
29621: PPOPN 2
29623: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
29624: LD_EXP 29
29628: PUSH
29629: LD_EXP 57
29633: AND
29634: IFFALSE 29731
29636: GO 29638
29638: DISABLE
29639: LD_INT 0
29641: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29642: LD_ADDR_VAR 0 1
29646: PUSH
29647: LD_INT 22
29649: PUSH
29650: LD_OWVAR 2
29654: PUSH
29655: EMPTY
29656: LIST
29657: LIST
29658: PUSH
29659: LD_INT 21
29661: PUSH
29662: LD_INT 1
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 3
29671: PUSH
29672: LD_INT 23
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: LIST
29690: PPUSH
29691: CALL_OW 69
29695: ST_TO_ADDR
// if not tmp then
29696: LD_VAR 0 1
29700: NOT
29701: IFFALSE 29705
// exit ;
29703: GO 29731
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
29705: LD_VAR 0 1
29709: PUSH
29710: LD_INT 1
29712: PPUSH
29713: LD_VAR 0 1
29717: PPUSH
29718: CALL_OW 12
29722: ARRAY
29723: PPUSH
29724: LD_INT 200
29726: PPUSH
29727: CALL_OW 234
// end ;
29731: PPOPN 1
29733: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
29734: LD_EXP 29
29738: PUSH
29739: LD_EXP 58
29743: AND
29744: IFFALSE 29823
29746: GO 29748
29748: DISABLE
29749: LD_INT 0
29751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
29752: LD_ADDR_VAR 0 1
29756: PUSH
29757: LD_INT 22
29759: PUSH
29760: LD_OWVAR 2
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: LD_INT 21
29771: PUSH
29772: LD_INT 2
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PPUSH
29783: CALL_OW 69
29787: ST_TO_ADDR
// if not tmp then
29788: LD_VAR 0 1
29792: NOT
29793: IFFALSE 29797
// exit ;
29795: GO 29823
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
29797: LD_VAR 0 1
29801: PUSH
29802: LD_INT 1
29804: PPUSH
29805: LD_VAR 0 1
29809: PPUSH
29810: CALL_OW 12
29814: ARRAY
29815: PPUSH
29816: LD_INT 60
29818: PPUSH
29819: CALL_OW 234
// end ;
29823: PPOPN 1
29825: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
29826: LD_EXP 29
29830: PUSH
29831: LD_EXP 59
29835: AND
29836: IFFALSE 29935
29838: GO 29840
29840: DISABLE
29841: LD_INT 0
29843: PPUSH
29844: PPUSH
// begin enable ;
29845: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
29846: LD_ADDR_VAR 0 1
29850: PUSH
29851: LD_INT 22
29853: PUSH
29854: LD_OWVAR 2
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 61
29865: PUSH
29866: EMPTY
29867: LIST
29868: PUSH
29869: LD_INT 33
29871: PUSH
29872: LD_INT 2
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: LIST
29883: PPUSH
29884: CALL_OW 69
29888: ST_TO_ADDR
// if not tmp then
29889: LD_VAR 0 1
29893: NOT
29894: IFFALSE 29898
// exit ;
29896: GO 29935
// for i in tmp do
29898: LD_ADDR_VAR 0 2
29902: PUSH
29903: LD_VAR 0 1
29907: PUSH
29908: FOR_IN
29909: IFFALSE 29933
// if IsControledBy ( i ) then
29911: LD_VAR 0 2
29915: PPUSH
29916: CALL_OW 312
29920: IFFALSE 29931
// ComUnlink ( i ) ;
29922: LD_VAR 0 2
29926: PPUSH
29927: CALL_OW 136
29931: GO 29908
29933: POP
29934: POP
// end ;
29935: PPOPN 2
29937: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
29938: LD_EXP 29
29942: PUSH
29943: LD_EXP 60
29947: AND
29948: IFFALSE 30088
29950: GO 29952
29952: DISABLE
29953: LD_INT 0
29955: PPUSH
29956: PPUSH
// begin ToLua ( displayPowell(); ) ;
29957: LD_STRING displayPowell();
29959: PPUSH
29960: CALL_OW 559
// uc_side := 0 ;
29964: LD_ADDR_OWVAR 20
29968: PUSH
29969: LD_INT 0
29971: ST_TO_ADDR
// uc_nation := 2 ;
29972: LD_ADDR_OWVAR 21
29976: PUSH
29977: LD_INT 2
29979: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
29980: LD_ADDR_OWVAR 37
29984: PUSH
29985: LD_INT 14
29987: ST_TO_ADDR
// vc_engine := engine_siberite ;
29988: LD_ADDR_OWVAR 39
29992: PUSH
29993: LD_INT 3
29995: ST_TO_ADDR
// vc_control := control_apeman ;
29996: LD_ADDR_OWVAR 38
30000: PUSH
30001: LD_INT 5
30003: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
30004: LD_ADDR_OWVAR 40
30008: PUSH
30009: LD_INT 29
30011: ST_TO_ADDR
// un := CreateVehicle ;
30012: LD_ADDR_VAR 0 2
30016: PUSH
30017: CALL_OW 45
30021: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30022: LD_VAR 0 2
30026: PPUSH
30027: LD_INT 1
30029: PPUSH
30030: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
30034: LD_INT 35
30036: PPUSH
30037: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
30041: LD_VAR 0 2
30045: PPUSH
30046: LD_INT 22
30048: PUSH
30049: LD_OWVAR 2
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PPUSH
30058: CALL_OW 69
30062: PPUSH
30063: LD_VAR 0 2
30067: PPUSH
30068: CALL_OW 74
30072: PPUSH
30073: CALL_OW 115
// until IsDead ( un ) ;
30077: LD_VAR 0 2
30081: PPUSH
30082: CALL_OW 301
30086: IFFALSE 30034
// end ;
30088: PPOPN 2
30090: END
// every 0 0$1 trigger StreamModeActive and sStu do
30091: LD_EXP 29
30095: PUSH
30096: LD_EXP 68
30100: AND
30101: IFFALSE 30117
30103: GO 30105
30105: DISABLE
// begin ToLua ( displayStucuk(); ) ;
30106: LD_STRING displayStucuk();
30108: PPUSH
30109: CALL_OW 559
// ResetFog ;
30113: CALL_OW 335
// end ;
30117: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
30118: LD_EXP 29
30122: PUSH
30123: LD_EXP 61
30127: AND
30128: IFFALSE 30269
30130: GO 30132
30132: DISABLE
30133: LD_INT 0
30135: PPUSH
30136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
30137: LD_ADDR_VAR 0 2
30141: PUSH
30142: LD_INT 22
30144: PUSH
30145: LD_OWVAR 2
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: LD_INT 21
30156: PUSH
30157: LD_INT 1
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PPUSH
30168: CALL_OW 69
30172: ST_TO_ADDR
// if not tmp then
30173: LD_VAR 0 2
30177: NOT
30178: IFFALSE 30182
// exit ;
30180: GO 30269
// un := tmp [ rand ( 1 , tmp ) ] ;
30182: LD_ADDR_VAR 0 1
30186: PUSH
30187: LD_VAR 0 2
30191: PUSH
30192: LD_INT 1
30194: PPUSH
30195: LD_VAR 0 2
30199: PPUSH
30200: CALL_OW 12
30204: ARRAY
30205: ST_TO_ADDR
// SetSide ( un , 0 ) ;
30206: LD_VAR 0 1
30210: PPUSH
30211: LD_INT 0
30213: PPUSH
30214: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
30218: LD_VAR 0 1
30222: PPUSH
30223: LD_OWVAR 3
30227: PUSH
30228: LD_VAR 0 1
30232: DIFF
30233: PPUSH
30234: LD_VAR 0 1
30238: PPUSH
30239: CALL_OW 74
30243: PPUSH
30244: CALL_OW 115
// wait ( 0 0$20 ) ;
30248: LD_INT 700
30250: PPUSH
30251: CALL_OW 67
// SetSide ( un , your_side ) ;
30255: LD_VAR 0 1
30259: PPUSH
30260: LD_OWVAR 2
30264: PPUSH
30265: CALL_OW 235
// end ;
30269: PPOPN 2
30271: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
30272: LD_EXP 29
30276: PUSH
30277: LD_EXP 62
30281: AND
30282: IFFALSE 30388
30284: GO 30286
30286: DISABLE
30287: LD_INT 0
30289: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
30290: LD_ADDR_VAR 0 1
30294: PUSH
30295: LD_INT 22
30297: PUSH
30298: LD_OWVAR 2
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: PUSH
30310: LD_INT 30
30312: PUSH
30313: LD_INT 0
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 30
30322: PUSH
30323: LD_INT 1
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: LIST
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PPUSH
30339: CALL_OW 69
30343: ST_TO_ADDR
// if not depot then
30344: LD_VAR 0 1
30348: NOT
30349: IFFALSE 30353
// exit ;
30351: GO 30388
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
30353: LD_VAR 0 1
30357: PUSH
30358: LD_INT 1
30360: ARRAY
30361: PPUSH
30362: CALL_OW 250
30366: PPUSH
30367: LD_VAR 0 1
30371: PUSH
30372: LD_INT 1
30374: ARRAY
30375: PPUSH
30376: CALL_OW 251
30380: PPUSH
30381: LD_INT 70
30383: PPUSH
30384: CALL_OW 495
// end ;
30388: PPOPN 1
30390: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
30391: LD_EXP 29
30395: PUSH
30396: LD_EXP 63
30400: AND
30401: IFFALSE 30612
30403: GO 30405
30405: DISABLE
30406: LD_INT 0
30408: PPUSH
30409: PPUSH
30410: PPUSH
30411: PPUSH
30412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
30413: LD_ADDR_VAR 0 5
30417: PUSH
30418: LD_INT 22
30420: PUSH
30421: LD_OWVAR 2
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 21
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PPUSH
30444: CALL_OW 69
30448: ST_TO_ADDR
// if not tmp then
30449: LD_VAR 0 5
30453: NOT
30454: IFFALSE 30458
// exit ;
30456: GO 30612
// for i in tmp do
30458: LD_ADDR_VAR 0 1
30462: PUSH
30463: LD_VAR 0 5
30467: PUSH
30468: FOR_IN
30469: IFFALSE 30610
// begin d := rand ( 0 , 5 ) ;
30471: LD_ADDR_VAR 0 4
30475: PUSH
30476: LD_INT 0
30478: PPUSH
30479: LD_INT 5
30481: PPUSH
30482: CALL_OW 12
30486: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
30487: LD_ADDR_VAR 0 2
30491: PUSH
30492: LD_VAR 0 1
30496: PPUSH
30497: CALL_OW 250
30501: PPUSH
30502: LD_VAR 0 4
30506: PPUSH
30507: LD_INT 3
30509: PPUSH
30510: LD_INT 12
30512: PPUSH
30513: CALL_OW 12
30517: PPUSH
30518: CALL_OW 272
30522: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
30523: LD_ADDR_VAR 0 3
30527: PUSH
30528: LD_VAR 0 1
30532: PPUSH
30533: CALL_OW 251
30537: PPUSH
30538: LD_VAR 0 4
30542: PPUSH
30543: LD_INT 3
30545: PPUSH
30546: LD_INT 12
30548: PPUSH
30549: CALL_OW 12
30553: PPUSH
30554: CALL_OW 273
30558: ST_TO_ADDR
// if ValidHex ( x , y ) then
30559: LD_VAR 0 2
30563: PPUSH
30564: LD_VAR 0 3
30568: PPUSH
30569: CALL_OW 488
30573: IFFALSE 30608
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
30575: LD_VAR 0 1
30579: PPUSH
30580: LD_VAR 0 2
30584: PPUSH
30585: LD_VAR 0 3
30589: PPUSH
30590: LD_INT 3
30592: PPUSH
30593: LD_INT 6
30595: PPUSH
30596: CALL_OW 12
30600: PPUSH
30601: LD_INT 1
30603: PPUSH
30604: CALL_OW 483
// end ;
30608: GO 30468
30610: POP
30611: POP
// end ;
30612: PPOPN 5
30614: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
30615: LD_EXP 29
30619: PUSH
30620: LD_EXP 64
30624: AND
30625: IFFALSE 30719
30627: GO 30629
30629: DISABLE
30630: LD_INT 0
30632: PPUSH
30633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
30634: LD_ADDR_VAR 0 2
30638: PUSH
30639: LD_INT 22
30641: PUSH
30642: LD_OWVAR 2
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 32
30653: PUSH
30654: LD_INT 1
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 21
30663: PUSH
30664: LD_INT 2
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: LIST
30675: PPUSH
30676: CALL_OW 69
30680: ST_TO_ADDR
// if not tmp then
30681: LD_VAR 0 2
30685: NOT
30686: IFFALSE 30690
// exit ;
30688: GO 30719
// for i in tmp do
30690: LD_ADDR_VAR 0 1
30694: PUSH
30695: LD_VAR 0 2
30699: PUSH
30700: FOR_IN
30701: IFFALSE 30717
// SetFuel ( i , 0 ) ;
30703: LD_VAR 0 1
30707: PPUSH
30708: LD_INT 0
30710: PPUSH
30711: CALL_OW 240
30715: GO 30700
30717: POP
30718: POP
// end ;
30719: PPOPN 2
30721: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
30722: LD_EXP 29
30726: PUSH
30727: LD_EXP 65
30731: AND
30732: IFFALSE 30798
30734: GO 30736
30736: DISABLE
30737: LD_INT 0
30739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30740: LD_ADDR_VAR 0 1
30744: PUSH
30745: LD_INT 22
30747: PUSH
30748: LD_OWVAR 2
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 30
30759: PUSH
30760: LD_INT 29
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PPUSH
30771: CALL_OW 69
30775: ST_TO_ADDR
// if not tmp then
30776: LD_VAR 0 1
30780: NOT
30781: IFFALSE 30785
// exit ;
30783: GO 30798
// DestroyUnit ( tmp [ 1 ] ) ;
30785: LD_VAR 0 1
30789: PUSH
30790: LD_INT 1
30792: ARRAY
30793: PPUSH
30794: CALL_OW 65
// end ;
30798: PPOPN 1
30800: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
30801: LD_EXP 29
30805: PUSH
30806: LD_EXP 67
30810: AND
30811: IFFALSE 30940
30813: GO 30815
30815: DISABLE
30816: LD_INT 0
30818: PPUSH
// begin uc_side := 0 ;
30819: LD_ADDR_OWVAR 20
30823: PUSH
30824: LD_INT 0
30826: ST_TO_ADDR
// uc_nation := nation_arabian ;
30827: LD_ADDR_OWVAR 21
30831: PUSH
30832: LD_INT 2
30834: ST_TO_ADDR
// hc_gallery :=  ;
30835: LD_ADDR_OWVAR 33
30839: PUSH
30840: LD_STRING 
30842: ST_TO_ADDR
// hc_name :=  ;
30843: LD_ADDR_OWVAR 26
30847: PUSH
30848: LD_STRING 
30850: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
30851: LD_INT 1
30853: PPUSH
30854: LD_INT 11
30856: PPUSH
30857: LD_INT 10
30859: PPUSH
30860: CALL_OW 380
// un := CreateHuman ;
30864: LD_ADDR_VAR 0 1
30868: PUSH
30869: CALL_OW 44
30873: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30874: LD_VAR 0 1
30878: PPUSH
30879: LD_INT 1
30881: PPUSH
30882: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
30886: LD_INT 35
30888: PPUSH
30889: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
30893: LD_VAR 0 1
30897: PPUSH
30898: LD_INT 22
30900: PUSH
30901: LD_OWVAR 2
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PPUSH
30910: CALL_OW 69
30914: PPUSH
30915: LD_VAR 0 1
30919: PPUSH
30920: CALL_OW 74
30924: PPUSH
30925: CALL_OW 115
// until IsDead ( un ) ;
30929: LD_VAR 0 1
30933: PPUSH
30934: CALL_OW 301
30938: IFFALSE 30886
// end ;
30940: PPOPN 1
30942: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
30943: LD_EXP 29
30947: PUSH
30948: LD_EXP 69
30952: AND
30953: IFFALSE 30965
30955: GO 30957
30957: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
30958: LD_STRING earthquake(getX(game), 0, 32)
30960: PPUSH
30961: CALL_OW 559
30965: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
30966: LD_EXP 29
30970: PUSH
30971: LD_EXP 70
30975: AND
30976: IFFALSE 31067
30978: GO 30980
30980: DISABLE
30981: LD_INT 0
30983: PPUSH
// begin enable ;
30984: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
30985: LD_ADDR_VAR 0 1
30989: PUSH
30990: LD_INT 22
30992: PUSH
30993: LD_OWVAR 2
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 21
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 33
31014: PUSH
31015: LD_INT 3
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: LIST
31026: PPUSH
31027: CALL_OW 69
31031: ST_TO_ADDR
// if not tmp then
31032: LD_VAR 0 1
31036: NOT
31037: IFFALSE 31041
// exit ;
31039: GO 31067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
31041: LD_VAR 0 1
31045: PUSH
31046: LD_INT 1
31048: PPUSH
31049: LD_VAR 0 1
31053: PPUSH
31054: CALL_OW 12
31058: ARRAY
31059: PPUSH
31060: LD_INT 1
31062: PPUSH
31063: CALL_OW 234
// end ;
31067: PPOPN 1
31069: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
31070: LD_EXP 29
31074: PUSH
31075: LD_EXP 71
31079: AND
31080: IFFALSE 31221
31082: GO 31084
31084: DISABLE
31085: LD_INT 0
31087: PPUSH
31088: PPUSH
31089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31090: LD_ADDR_VAR 0 3
31094: PUSH
31095: LD_INT 22
31097: PUSH
31098: LD_OWVAR 2
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 25
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PPUSH
31121: CALL_OW 69
31125: ST_TO_ADDR
// if not tmp then
31126: LD_VAR 0 3
31130: NOT
31131: IFFALSE 31135
// exit ;
31133: GO 31221
// un := tmp [ rand ( 1 , tmp ) ] ;
31135: LD_ADDR_VAR 0 2
31139: PUSH
31140: LD_VAR 0 3
31144: PUSH
31145: LD_INT 1
31147: PPUSH
31148: LD_VAR 0 3
31152: PPUSH
31153: CALL_OW 12
31157: ARRAY
31158: ST_TO_ADDR
// if Crawls ( un ) then
31159: LD_VAR 0 2
31163: PPUSH
31164: CALL_OW 318
31168: IFFALSE 31179
// ComWalk ( un ) ;
31170: LD_VAR 0 2
31174: PPUSH
31175: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
31179: LD_VAR 0 2
31183: PPUSH
31184: LD_INT 9
31186: PPUSH
31187: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
31191: LD_INT 28
31193: PPUSH
31194: LD_OWVAR 2
31198: PPUSH
31199: LD_INT 2
31201: PPUSH
31202: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
31206: LD_INT 29
31208: PPUSH
31209: LD_OWVAR 2
31213: PPUSH
31214: LD_INT 2
31216: PPUSH
31217: CALL_OW 322
// end ;
31221: PPOPN 3
31223: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
31224: LD_EXP 29
31228: PUSH
31229: LD_EXP 72
31233: AND
31234: IFFALSE 31345
31236: GO 31238
31238: DISABLE
31239: LD_INT 0
31241: PPUSH
31242: PPUSH
31243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31244: LD_ADDR_VAR 0 3
31248: PUSH
31249: LD_INT 22
31251: PUSH
31252: LD_OWVAR 2
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 25
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PPUSH
31275: CALL_OW 69
31279: ST_TO_ADDR
// if not tmp then
31280: LD_VAR 0 3
31284: NOT
31285: IFFALSE 31289
// exit ;
31287: GO 31345
// un := tmp [ rand ( 1 , tmp ) ] ;
31289: LD_ADDR_VAR 0 2
31293: PUSH
31294: LD_VAR 0 3
31298: PUSH
31299: LD_INT 1
31301: PPUSH
31302: LD_VAR 0 3
31306: PPUSH
31307: CALL_OW 12
31311: ARRAY
31312: ST_TO_ADDR
// if Crawls ( un ) then
31313: LD_VAR 0 2
31317: PPUSH
31318: CALL_OW 318
31322: IFFALSE 31333
// ComWalk ( un ) ;
31324: LD_VAR 0 2
31328: PPUSH
31329: CALL_OW 138
// SetClass ( un , class_mortar ) ;
31333: LD_VAR 0 2
31337: PPUSH
31338: LD_INT 8
31340: PPUSH
31341: CALL_OW 336
// end ;
31345: PPOPN 3
31347: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
31348: LD_EXP 29
31352: PUSH
31353: LD_EXP 73
31357: AND
31358: IFFALSE 31502
31360: GO 31362
31362: DISABLE
31363: LD_INT 0
31365: PPUSH
31366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
31367: LD_ADDR_VAR 0 2
31371: PUSH
31372: LD_INT 22
31374: PUSH
31375: LD_OWVAR 2
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 21
31386: PUSH
31387: LD_INT 2
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 2
31396: PUSH
31397: LD_INT 34
31399: PUSH
31400: LD_INT 12
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 34
31409: PUSH
31410: LD_INT 51
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 34
31419: PUSH
31420: LD_INT 32
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: LIST
31437: PPUSH
31438: CALL_OW 69
31442: ST_TO_ADDR
// if not tmp then
31443: LD_VAR 0 2
31447: NOT
31448: IFFALSE 31452
// exit ;
31450: GO 31502
// for i in tmp do
31452: LD_ADDR_VAR 0 1
31456: PUSH
31457: LD_VAR 0 2
31461: PUSH
31462: FOR_IN
31463: IFFALSE 31500
// if GetCargo ( i , mat_artifact ) = 0 then
31465: LD_VAR 0 1
31469: PPUSH
31470: LD_INT 4
31472: PPUSH
31473: CALL_OW 289
31477: PUSH
31478: LD_INT 0
31480: EQUAL
31481: IFFALSE 31498
// SetCargo ( i , mat_siberit , 100 ) ;
31483: LD_VAR 0 1
31487: PPUSH
31488: LD_INT 3
31490: PPUSH
31491: LD_INT 100
31493: PPUSH
31494: CALL_OW 290
31498: GO 31462
31500: POP
31501: POP
// end ;
31502: PPOPN 2
31504: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
31505: LD_EXP 29
31509: PUSH
31510: LD_EXP 74
31514: AND
31515: IFFALSE 31698
31517: GO 31519
31519: DISABLE
31520: LD_INT 0
31522: PPUSH
31523: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
31524: LD_ADDR_VAR 0 2
31528: PUSH
31529: LD_INT 22
31531: PUSH
31532: LD_OWVAR 2
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PPUSH
31541: CALL_OW 69
31545: ST_TO_ADDR
// if not tmp then
31546: LD_VAR 0 2
31550: NOT
31551: IFFALSE 31555
// exit ;
31553: GO 31698
// for i := 1 to 2 do
31555: LD_ADDR_VAR 0 1
31559: PUSH
31560: DOUBLE
31561: LD_INT 1
31563: DEC
31564: ST_TO_ADDR
31565: LD_INT 2
31567: PUSH
31568: FOR_TO
31569: IFFALSE 31696
// begin uc_side := your_side ;
31571: LD_ADDR_OWVAR 20
31575: PUSH
31576: LD_OWVAR 2
31580: ST_TO_ADDR
// uc_nation := nation_american ;
31581: LD_ADDR_OWVAR 21
31585: PUSH
31586: LD_INT 1
31588: ST_TO_ADDR
// vc_chassis := us_morphling ;
31589: LD_ADDR_OWVAR 37
31593: PUSH
31594: LD_INT 5
31596: ST_TO_ADDR
// vc_engine := engine_siberite ;
31597: LD_ADDR_OWVAR 39
31601: PUSH
31602: LD_INT 3
31604: ST_TO_ADDR
// vc_control := control_computer ;
31605: LD_ADDR_OWVAR 38
31609: PUSH
31610: LD_INT 3
31612: ST_TO_ADDR
// vc_weapon := us_double_laser ;
31613: LD_ADDR_OWVAR 40
31617: PUSH
31618: LD_INT 10
31620: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
31621: LD_VAR 0 2
31625: PUSH
31626: LD_INT 1
31628: ARRAY
31629: PPUSH
31630: CALL_OW 310
31634: NOT
31635: IFFALSE 31682
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
31637: CALL_OW 45
31641: PPUSH
31642: LD_VAR 0 2
31646: PUSH
31647: LD_INT 1
31649: ARRAY
31650: PPUSH
31651: CALL_OW 250
31655: PPUSH
31656: LD_VAR 0 2
31660: PUSH
31661: LD_INT 1
31663: ARRAY
31664: PPUSH
31665: CALL_OW 251
31669: PPUSH
31670: LD_INT 12
31672: PPUSH
31673: LD_INT 1
31675: PPUSH
31676: CALL_OW 50
31680: GO 31694
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31682: CALL_OW 45
31686: PPUSH
31687: LD_INT 1
31689: PPUSH
31690: CALL_OW 51
// end ;
31694: GO 31568
31696: POP
31697: POP
// end ;
31698: PPOPN 2
31700: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
31701: LD_EXP 29
31705: PUSH
31706: LD_EXP 75
31710: AND
31711: IFFALSE 31933
31713: GO 31715
31715: DISABLE
31716: LD_INT 0
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
31724: LD_ADDR_VAR 0 6
31728: PUSH
31729: LD_INT 22
31731: PUSH
31732: LD_OWVAR 2
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 21
31743: PUSH
31744: LD_INT 1
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 3
31753: PUSH
31754: LD_INT 23
31756: PUSH
31757: LD_INT 0
31759: PUSH
31760: EMPTY
31761: LIST
31762: LIST
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: LIST
31772: PPUSH
31773: CALL_OW 69
31777: ST_TO_ADDR
// if not tmp then
31778: LD_VAR 0 6
31782: NOT
31783: IFFALSE 31787
// exit ;
31785: GO 31933
// s1 := rand ( 1 , 4 ) ;
31787: LD_ADDR_VAR 0 2
31791: PUSH
31792: LD_INT 1
31794: PPUSH
31795: LD_INT 4
31797: PPUSH
31798: CALL_OW 12
31802: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
31803: LD_ADDR_VAR 0 4
31807: PUSH
31808: LD_VAR 0 6
31812: PUSH
31813: LD_INT 1
31815: ARRAY
31816: PPUSH
31817: LD_VAR 0 2
31821: PPUSH
31822: CALL_OW 259
31826: ST_TO_ADDR
// if s1 = 1 then
31827: LD_VAR 0 2
31831: PUSH
31832: LD_INT 1
31834: EQUAL
31835: IFFALSE 31855
// s2 := rand ( 2 , 4 ) else
31837: LD_ADDR_VAR 0 3
31841: PUSH
31842: LD_INT 2
31844: PPUSH
31845: LD_INT 4
31847: PPUSH
31848: CALL_OW 12
31852: ST_TO_ADDR
31853: GO 31863
// s2 := 1 ;
31855: LD_ADDR_VAR 0 3
31859: PUSH
31860: LD_INT 1
31862: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
31863: LD_ADDR_VAR 0 5
31867: PUSH
31868: LD_VAR 0 6
31872: PUSH
31873: LD_INT 1
31875: ARRAY
31876: PPUSH
31877: LD_VAR 0 3
31881: PPUSH
31882: CALL_OW 259
31886: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
31887: LD_VAR 0 6
31891: PUSH
31892: LD_INT 1
31894: ARRAY
31895: PPUSH
31896: LD_VAR 0 2
31900: PPUSH
31901: LD_VAR 0 5
31905: PPUSH
31906: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
31910: LD_VAR 0 6
31914: PUSH
31915: LD_INT 1
31917: ARRAY
31918: PPUSH
31919: LD_VAR 0 3
31923: PPUSH
31924: LD_VAR 0 4
31928: PPUSH
31929: CALL_OW 237
// end ;
31933: PPOPN 6
31935: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
31936: LD_EXP 29
31940: PUSH
31941: LD_EXP 76
31945: AND
31946: IFFALSE 32025
31948: GO 31950
31950: DISABLE
31951: LD_INT 0
31953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
31954: LD_ADDR_VAR 0 1
31958: PUSH
31959: LD_INT 22
31961: PUSH
31962: LD_OWVAR 2
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 30
31973: PUSH
31974: LD_INT 3
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PPUSH
31985: CALL_OW 69
31989: ST_TO_ADDR
// if not tmp then
31990: LD_VAR 0 1
31994: NOT
31995: IFFALSE 31999
// exit ;
31997: GO 32025
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
31999: LD_VAR 0 1
32003: PUSH
32004: LD_INT 1
32006: PPUSH
32007: LD_VAR 0 1
32011: PPUSH
32012: CALL_OW 12
32016: ARRAY
32017: PPUSH
32018: LD_INT 1
32020: PPUSH
32021: CALL_OW 234
// end ;
32025: PPOPN 1
32027: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
32028: LD_EXP 29
32032: PUSH
32033: LD_EXP 77
32037: AND
32038: IFFALSE 32150
32040: GO 32042
32042: DISABLE
32043: LD_INT 0
32045: PPUSH
32046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
32047: LD_ADDR_VAR 0 2
32051: PUSH
32052: LD_INT 22
32054: PUSH
32055: LD_OWVAR 2
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 2
32066: PUSH
32067: LD_INT 30
32069: PUSH
32070: LD_INT 27
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 30
32079: PUSH
32080: LD_INT 26
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 30
32089: PUSH
32090: LD_INT 28
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PPUSH
32107: CALL_OW 69
32111: ST_TO_ADDR
// if not tmp then
32112: LD_VAR 0 2
32116: NOT
32117: IFFALSE 32121
// exit ;
32119: GO 32150
// for i in tmp do
32121: LD_ADDR_VAR 0 1
32125: PUSH
32126: LD_VAR 0 2
32130: PUSH
32131: FOR_IN
32132: IFFALSE 32148
// SetLives ( i , 1 ) ;
32134: LD_VAR 0 1
32138: PPUSH
32139: LD_INT 1
32141: PPUSH
32142: CALL_OW 234
32146: GO 32131
32148: POP
32149: POP
// end ;
32150: PPOPN 2
32152: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
32153: LD_EXP 29
32157: PUSH
32158: LD_EXP 78
32162: AND
32163: IFFALSE 32450
32165: GO 32167
32167: DISABLE
32168: LD_INT 0
32170: PPUSH
32171: PPUSH
32172: PPUSH
// begin i := rand ( 1 , 7 ) ;
32173: LD_ADDR_VAR 0 1
32177: PUSH
32178: LD_INT 1
32180: PPUSH
32181: LD_INT 7
32183: PPUSH
32184: CALL_OW 12
32188: ST_TO_ADDR
// case i of 1 :
32189: LD_VAR 0 1
32193: PUSH
32194: LD_INT 1
32196: DOUBLE
32197: EQUAL
32198: IFTRUE 32202
32200: GO 32212
32202: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
32203: LD_STRING earthquake(getX(game), 0, 32)
32205: PPUSH
32206: CALL_OW 559
32210: GO 32450
32212: LD_INT 2
32214: DOUBLE
32215: EQUAL
32216: IFTRUE 32220
32218: GO 32234
32220: POP
// begin ToLua ( displayStucuk(); ) ;
32221: LD_STRING displayStucuk();
32223: PPUSH
32224: CALL_OW 559
// ResetFog ;
32228: CALL_OW 335
// end ; 3 :
32232: GO 32450
32234: LD_INT 3
32236: DOUBLE
32237: EQUAL
32238: IFTRUE 32242
32240: GO 32346
32242: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
32243: LD_ADDR_VAR 0 2
32247: PUSH
32248: LD_INT 22
32250: PUSH
32251: LD_OWVAR 2
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 25
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 69
32278: ST_TO_ADDR
// if not tmp then
32279: LD_VAR 0 2
32283: NOT
32284: IFFALSE 32288
// exit ;
32286: GO 32450
// un := tmp [ rand ( 1 , tmp ) ] ;
32288: LD_ADDR_VAR 0 3
32292: PUSH
32293: LD_VAR 0 2
32297: PUSH
32298: LD_INT 1
32300: PPUSH
32301: LD_VAR 0 2
32305: PPUSH
32306: CALL_OW 12
32310: ARRAY
32311: ST_TO_ADDR
// if Crawls ( un ) then
32312: LD_VAR 0 3
32316: PPUSH
32317: CALL_OW 318
32321: IFFALSE 32332
// ComWalk ( un ) ;
32323: LD_VAR 0 3
32327: PPUSH
32328: CALL_OW 138
// SetClass ( un , class_mortar ) ;
32332: LD_VAR 0 3
32336: PPUSH
32337: LD_INT 8
32339: PPUSH
32340: CALL_OW 336
// end ; 4 :
32344: GO 32450
32346: LD_INT 4
32348: DOUBLE
32349: EQUAL
32350: IFTRUE 32354
32352: GO 32428
32354: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
32355: LD_ADDR_VAR 0 2
32359: PUSH
32360: LD_INT 22
32362: PUSH
32363: LD_OWVAR 2
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 30
32374: PUSH
32375: LD_INT 29
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PPUSH
32386: CALL_OW 69
32390: ST_TO_ADDR
// if not tmp then
32391: LD_VAR 0 2
32395: NOT
32396: IFFALSE 32400
// exit ;
32398: GO 32450
// CenterNowOnUnits ( tmp [ 1 ] ) ;
32400: LD_VAR 0 2
32404: PUSH
32405: LD_INT 1
32407: ARRAY
32408: PPUSH
32409: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
32413: LD_VAR 0 2
32417: PUSH
32418: LD_INT 1
32420: ARRAY
32421: PPUSH
32422: CALL_OW 65
// end ; 5 .. 7 :
32426: GO 32450
32428: LD_INT 5
32430: DOUBLE
32431: GREATEREQUAL
32432: IFFALSE 32440
32434: LD_INT 7
32436: DOUBLE
32437: LESSEQUAL
32438: IFTRUE 32442
32440: GO 32449
32442: POP
// StreamSibBomb ; end ;
32443: CALL 28687 0 0
32447: GO 32450
32449: POP
// end ;
32450: PPOPN 3
32452: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
32453: LD_EXP 29
32457: PUSH
32458: LD_EXP 79
32462: AND
32463: IFFALSE 32619
32465: GO 32467
32467: DISABLE
32468: LD_INT 0
32470: PPUSH
32471: PPUSH
32472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
32473: LD_ADDR_VAR 0 2
32477: PUSH
32478: LD_INT 81
32480: PUSH
32481: LD_OWVAR 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 2
32492: PUSH
32493: LD_INT 21
32495: PUSH
32496: LD_INT 1
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 21
32505: PUSH
32506: LD_INT 2
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: LIST
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PPUSH
32522: CALL_OW 69
32526: ST_TO_ADDR
// if not tmp then
32527: LD_VAR 0 2
32531: NOT
32532: IFFALSE 32536
// exit ;
32534: GO 32619
// p := 0 ;
32536: LD_ADDR_VAR 0 3
32540: PUSH
32541: LD_INT 0
32543: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32544: LD_INT 35
32546: PPUSH
32547: CALL_OW 67
// p := p + 1 ;
32551: LD_ADDR_VAR 0 3
32555: PUSH
32556: LD_VAR 0 3
32560: PUSH
32561: LD_INT 1
32563: PLUS
32564: ST_TO_ADDR
// for i in tmp do
32565: LD_ADDR_VAR 0 1
32569: PUSH
32570: LD_VAR 0 2
32574: PUSH
32575: FOR_IN
32576: IFFALSE 32607
// if GetLives ( i ) < 1000 then
32578: LD_VAR 0 1
32582: PPUSH
32583: CALL_OW 256
32587: PUSH
32588: LD_INT 1000
32590: LESS
32591: IFFALSE 32605
// SetLives ( i , 1000 ) ;
32593: LD_VAR 0 1
32597: PPUSH
32598: LD_INT 1000
32600: PPUSH
32601: CALL_OW 234
32605: GO 32575
32607: POP
32608: POP
// until p > 20 ;
32609: LD_VAR 0 3
32613: PUSH
32614: LD_INT 20
32616: GREATER
32617: IFFALSE 32544
// end ;
32619: PPOPN 3
32621: END
// every 0 0$1 trigger StreamModeActive and sTime do
32622: LD_EXP 29
32626: PUSH
32627: LD_EXP 80
32631: AND
32632: IFFALSE 32667
32634: GO 32636
32636: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
32637: LD_INT 28
32639: PPUSH
32640: LD_OWVAR 2
32644: PPUSH
32645: LD_INT 2
32647: PPUSH
32648: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
32652: LD_INT 30
32654: PPUSH
32655: LD_OWVAR 2
32659: PPUSH
32660: LD_INT 2
32662: PPUSH
32663: CALL_OW 322
// end ;
32667: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
32668: LD_EXP 29
32672: PUSH
32673: LD_EXP 81
32677: AND
32678: IFFALSE 32799
32680: GO 32682
32682: DISABLE
32683: LD_INT 0
32685: PPUSH
32686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
32687: LD_ADDR_VAR 0 2
32691: PUSH
32692: LD_INT 22
32694: PUSH
32695: LD_OWVAR 2
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 21
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 3
32716: PUSH
32717: LD_INT 23
32719: PUSH
32720: LD_INT 0
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: LIST
32735: PPUSH
32736: CALL_OW 69
32740: ST_TO_ADDR
// if not tmp then
32741: LD_VAR 0 2
32745: NOT
32746: IFFALSE 32750
// exit ;
32748: GO 32799
// for i in tmp do
32750: LD_ADDR_VAR 0 1
32754: PUSH
32755: LD_VAR 0 2
32759: PUSH
32760: FOR_IN
32761: IFFALSE 32797
// begin if Crawls ( i ) then
32763: LD_VAR 0 1
32767: PPUSH
32768: CALL_OW 318
32772: IFFALSE 32783
// ComWalk ( i ) ;
32774: LD_VAR 0 1
32778: PPUSH
32779: CALL_OW 138
// SetClass ( i , 2 ) ;
32783: LD_VAR 0 1
32787: PPUSH
32788: LD_INT 2
32790: PPUSH
32791: CALL_OW 336
// end ;
32795: GO 32760
32797: POP
32798: POP
// end ;
32799: PPOPN 2
32801: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
32802: LD_EXP 29
32806: PUSH
32807: LD_EXP 82
32811: AND
32812: IFFALSE 33100
32814: GO 32816
32816: DISABLE
32817: LD_INT 0
32819: PPUSH
32820: PPUSH
32821: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
32822: LD_OWVAR 2
32826: PPUSH
32827: LD_INT 9
32829: PPUSH
32830: LD_INT 1
32832: PPUSH
32833: LD_INT 1
32835: PPUSH
32836: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
32840: LD_INT 9
32842: PPUSH
32843: LD_OWVAR 2
32847: PPUSH
32848: CALL_OW 343
// uc_side := 9 ;
32852: LD_ADDR_OWVAR 20
32856: PUSH
32857: LD_INT 9
32859: ST_TO_ADDR
// uc_nation := 2 ;
32860: LD_ADDR_OWVAR 21
32864: PUSH
32865: LD_INT 2
32867: ST_TO_ADDR
// hc_name := Dark Warrior ;
32868: LD_ADDR_OWVAR 26
32872: PUSH
32873: LD_STRING Dark Warrior
32875: ST_TO_ADDR
// hc_gallery :=  ;
32876: LD_ADDR_OWVAR 33
32880: PUSH
32881: LD_STRING 
32883: ST_TO_ADDR
// hc_noskilllimit := true ;
32884: LD_ADDR_OWVAR 76
32888: PUSH
32889: LD_INT 1
32891: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
32892: LD_ADDR_OWVAR 31
32896: PUSH
32897: LD_INT 30
32899: PUSH
32900: LD_INT 30
32902: PUSH
32903: LD_INT 30
32905: PUSH
32906: LD_INT 30
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: ST_TO_ADDR
// un := CreateHuman ;
32915: LD_ADDR_VAR 0 3
32919: PUSH
32920: CALL_OW 44
32924: ST_TO_ADDR
// hc_noskilllimit := false ;
32925: LD_ADDR_OWVAR 76
32929: PUSH
32930: LD_INT 0
32932: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
32933: LD_VAR 0 3
32937: PPUSH
32938: LD_INT 1
32940: PPUSH
32941: CALL_OW 51
// ToLua ( playRanger() ) ;
32945: LD_STRING playRanger()
32947: PPUSH
32948: CALL_OW 559
// p := 0 ;
32952: LD_ADDR_VAR 0 2
32956: PUSH
32957: LD_INT 0
32959: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32960: LD_INT 35
32962: PPUSH
32963: CALL_OW 67
// p := p + 1 ;
32967: LD_ADDR_VAR 0 2
32971: PUSH
32972: LD_VAR 0 2
32976: PUSH
32977: LD_INT 1
32979: PLUS
32980: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
32981: LD_VAR 0 3
32985: PPUSH
32986: CALL_OW 256
32990: PUSH
32991: LD_INT 1000
32993: LESS
32994: IFFALSE 33008
// SetLives ( un , 1000 ) ;
32996: LD_VAR 0 3
33000: PPUSH
33001: LD_INT 1000
33003: PPUSH
33004: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
33008: LD_VAR 0 3
33012: PPUSH
33013: LD_INT 81
33015: PUSH
33016: LD_OWVAR 2
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 91
33027: PUSH
33028: LD_VAR 0 3
33032: PUSH
33033: LD_INT 30
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: LIST
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PPUSH
33045: CALL_OW 69
33049: PPUSH
33050: LD_VAR 0 3
33054: PPUSH
33055: CALL_OW 74
33059: PPUSH
33060: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
33064: LD_VAR 0 2
33068: PUSH
33069: LD_INT 80
33071: GREATER
33072: PUSH
33073: LD_VAR 0 3
33077: PPUSH
33078: CALL_OW 301
33082: OR
33083: IFFALSE 32960
// if un then
33085: LD_VAR 0 3
33089: IFFALSE 33100
// RemoveUnit ( un ) ;
33091: LD_VAR 0 3
33095: PPUSH
33096: CALL_OW 64
// end ;
33100: PPOPN 3
33102: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
33103: LD_EXP 83
33107: IFFALSE 33223
33109: GO 33111
33111: DISABLE
33112: LD_INT 0
33114: PPUSH
33115: PPUSH
33116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
33117: LD_ADDR_VAR 0 2
33121: PUSH
33122: LD_INT 81
33124: PUSH
33125: LD_OWVAR 2
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 21
33136: PUSH
33137: LD_INT 1
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PPUSH
33148: CALL_OW 69
33152: ST_TO_ADDR
// ToLua ( playComputer() ) ;
33153: LD_STRING playComputer()
33155: PPUSH
33156: CALL_OW 559
// if not tmp then
33160: LD_VAR 0 2
33164: NOT
33165: IFFALSE 33169
// exit ;
33167: GO 33223
// for i in tmp do
33169: LD_ADDR_VAR 0 1
33173: PUSH
33174: LD_VAR 0 2
33178: PUSH
33179: FOR_IN
33180: IFFALSE 33221
// for j := 1 to 4 do
33182: LD_ADDR_VAR 0 3
33186: PUSH
33187: DOUBLE
33188: LD_INT 1
33190: DEC
33191: ST_TO_ADDR
33192: LD_INT 4
33194: PUSH
33195: FOR_TO
33196: IFFALSE 33217
// SetSkill ( i , j , 10 ) ;
33198: LD_VAR 0 1
33202: PPUSH
33203: LD_VAR 0 3
33207: PPUSH
33208: LD_INT 10
33210: PPUSH
33211: CALL_OW 237
33215: GO 33195
33217: POP
33218: POP
33219: GO 33179
33221: POP
33222: POP
// end ;
33223: PPOPN 3
33225: END
// every 0 0$1 trigger s30 do var i , tmp ;
33226: LD_EXP 84
33230: IFFALSE 33299
33232: GO 33234
33234: DISABLE
33235: LD_INT 0
33237: PPUSH
33238: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
33239: LD_ADDR_VAR 0 2
33243: PUSH
33244: LD_INT 22
33246: PUSH
33247: LD_OWVAR 2
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PPUSH
33256: CALL_OW 69
33260: ST_TO_ADDR
// if not tmp then
33261: LD_VAR 0 2
33265: NOT
33266: IFFALSE 33270
// exit ;
33268: GO 33299
// for i in tmp do
33270: LD_ADDR_VAR 0 1
33274: PUSH
33275: LD_VAR 0 2
33279: PUSH
33280: FOR_IN
33281: IFFALSE 33297
// SetLives ( i , 300 ) ;
33283: LD_VAR 0 1
33287: PPUSH
33288: LD_INT 300
33290: PPUSH
33291: CALL_OW 234
33295: GO 33280
33297: POP
33298: POP
// end ;
33299: PPOPN 2
33301: END
// every 0 0$1 trigger s60 do var i , tmp ;
33302: LD_EXP 85
33306: IFFALSE 33375
33308: GO 33310
33310: DISABLE
33311: LD_INT 0
33313: PPUSH
33314: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
33315: LD_ADDR_VAR 0 2
33319: PUSH
33320: LD_INT 22
33322: PUSH
33323: LD_OWVAR 2
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PPUSH
33332: CALL_OW 69
33336: ST_TO_ADDR
// if not tmp then
33337: LD_VAR 0 2
33341: NOT
33342: IFFALSE 33346
// exit ;
33344: GO 33375
// for i in tmp do
33346: LD_ADDR_VAR 0 1
33350: PUSH
33351: LD_VAR 0 2
33355: PUSH
33356: FOR_IN
33357: IFFALSE 33373
// SetLives ( i , 600 ) ;
33359: LD_VAR 0 1
33363: PPUSH
33364: LD_INT 600
33366: PPUSH
33367: CALL_OW 234
33371: GO 33356
33373: POP
33374: POP
// end ;
33375: PPOPN 2
33377: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
33378: LD_INT 0
33380: PPUSH
// case cmd of 301 :
33381: LD_VAR 0 1
33385: PUSH
33386: LD_INT 301
33388: DOUBLE
33389: EQUAL
33390: IFTRUE 33394
33392: GO 33426
33394: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
33395: LD_VAR 0 6
33399: PPUSH
33400: LD_VAR 0 7
33404: PPUSH
33405: LD_VAR 0 8
33409: PPUSH
33410: LD_VAR 0 4
33414: PPUSH
33415: LD_VAR 0 5
33419: PPUSH
33420: CALL 34627 0 5
33424: GO 33547
33426: LD_INT 302
33428: DOUBLE
33429: EQUAL
33430: IFTRUE 33434
33432: GO 33471
33434: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
33435: LD_VAR 0 6
33439: PPUSH
33440: LD_VAR 0 7
33444: PPUSH
33445: LD_VAR 0 8
33449: PPUSH
33450: LD_VAR 0 9
33454: PPUSH
33455: LD_VAR 0 4
33459: PPUSH
33460: LD_VAR 0 5
33464: PPUSH
33465: CALL 34718 0 6
33469: GO 33547
33471: LD_INT 303
33473: DOUBLE
33474: EQUAL
33475: IFTRUE 33479
33477: GO 33516
33479: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
33480: LD_VAR 0 6
33484: PPUSH
33485: LD_VAR 0 7
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: LD_VAR 0 9
33499: PPUSH
33500: LD_VAR 0 4
33504: PPUSH
33505: LD_VAR 0 5
33509: PPUSH
33510: CALL 33552 0 6
33514: GO 33547
33516: LD_INT 304
33518: DOUBLE
33519: EQUAL
33520: IFTRUE 33524
33522: GO 33546
33524: POP
// hHackTeleport ( unit , x , y ) ; end ;
33525: LD_VAR 0 2
33529: PPUSH
33530: LD_VAR 0 4
33534: PPUSH
33535: LD_VAR 0 5
33539: PPUSH
33540: CALL 35311 0 3
33544: GO 33547
33546: POP
// end ;
33547: LD_VAR 0 12
33551: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
33552: LD_INT 0
33554: PPUSH
33555: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
33556: LD_VAR 0 1
33560: PUSH
33561: LD_INT 1
33563: LESS
33564: PUSH
33565: LD_VAR 0 1
33569: PUSH
33570: LD_INT 3
33572: GREATER
33573: OR
33574: PUSH
33575: LD_VAR 0 5
33579: PPUSH
33580: LD_VAR 0 6
33584: PPUSH
33585: CALL_OW 428
33589: OR
33590: IFFALSE 33594
// exit ;
33592: GO 34314
// uc_side := your_side ;
33594: LD_ADDR_OWVAR 20
33598: PUSH
33599: LD_OWVAR 2
33603: ST_TO_ADDR
// uc_nation := nation ;
33604: LD_ADDR_OWVAR 21
33608: PUSH
33609: LD_VAR 0 1
33613: ST_TO_ADDR
// bc_level = 1 ;
33614: LD_ADDR_OWVAR 43
33618: PUSH
33619: LD_INT 1
33621: ST_TO_ADDR
// case btype of 1 :
33622: LD_VAR 0 2
33626: PUSH
33627: LD_INT 1
33629: DOUBLE
33630: EQUAL
33631: IFTRUE 33635
33633: GO 33646
33635: POP
// bc_type := b_depot ; 2 :
33636: LD_ADDR_OWVAR 42
33640: PUSH
33641: LD_INT 0
33643: ST_TO_ADDR
33644: GO 34258
33646: LD_INT 2
33648: DOUBLE
33649: EQUAL
33650: IFTRUE 33654
33652: GO 33665
33654: POP
// bc_type := b_warehouse ; 3 :
33655: LD_ADDR_OWVAR 42
33659: PUSH
33660: LD_INT 1
33662: ST_TO_ADDR
33663: GO 34258
33665: LD_INT 3
33667: DOUBLE
33668: EQUAL
33669: IFTRUE 33673
33671: GO 33684
33673: POP
// bc_type := b_lab ; 4 .. 9 :
33674: LD_ADDR_OWVAR 42
33678: PUSH
33679: LD_INT 6
33681: ST_TO_ADDR
33682: GO 34258
33684: LD_INT 4
33686: DOUBLE
33687: GREATEREQUAL
33688: IFFALSE 33696
33690: LD_INT 9
33692: DOUBLE
33693: LESSEQUAL
33694: IFTRUE 33698
33696: GO 33750
33698: POP
// begin bc_type := b_lab_half ;
33699: LD_ADDR_OWVAR 42
33703: PUSH
33704: LD_INT 7
33706: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
33707: LD_ADDR_OWVAR 44
33711: PUSH
33712: LD_INT 10
33714: PUSH
33715: LD_INT 11
33717: PUSH
33718: LD_INT 12
33720: PUSH
33721: LD_INT 15
33723: PUSH
33724: LD_INT 14
33726: PUSH
33727: LD_INT 13
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: PUSH
33738: LD_VAR 0 2
33742: PUSH
33743: LD_INT 3
33745: MINUS
33746: ARRAY
33747: ST_TO_ADDR
// end ; 10 .. 13 :
33748: GO 34258
33750: LD_INT 10
33752: DOUBLE
33753: GREATEREQUAL
33754: IFFALSE 33762
33756: LD_INT 13
33758: DOUBLE
33759: LESSEQUAL
33760: IFTRUE 33764
33762: GO 33841
33764: POP
// begin bc_type := b_lab_full ;
33765: LD_ADDR_OWVAR 42
33769: PUSH
33770: LD_INT 8
33772: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
33773: LD_ADDR_OWVAR 44
33777: PUSH
33778: LD_INT 10
33780: PUSH
33781: LD_INT 12
33783: PUSH
33784: LD_INT 14
33786: PUSH
33787: LD_INT 13
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: PUSH
33796: LD_VAR 0 2
33800: PUSH
33801: LD_INT 9
33803: MINUS
33804: ARRAY
33805: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
33806: LD_ADDR_OWVAR 45
33810: PUSH
33811: LD_INT 11
33813: PUSH
33814: LD_INT 15
33816: PUSH
33817: LD_INT 12
33819: PUSH
33820: LD_INT 15
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: PUSH
33829: LD_VAR 0 2
33833: PUSH
33834: LD_INT 9
33836: MINUS
33837: ARRAY
33838: ST_TO_ADDR
// end ; 14 :
33839: GO 34258
33841: LD_INT 14
33843: DOUBLE
33844: EQUAL
33845: IFTRUE 33849
33847: GO 33860
33849: POP
// bc_type := b_workshop ; 15 :
33850: LD_ADDR_OWVAR 42
33854: PUSH
33855: LD_INT 2
33857: ST_TO_ADDR
33858: GO 34258
33860: LD_INT 15
33862: DOUBLE
33863: EQUAL
33864: IFTRUE 33868
33866: GO 33879
33868: POP
// bc_type := b_factory ; 16 :
33869: LD_ADDR_OWVAR 42
33873: PUSH
33874: LD_INT 3
33876: ST_TO_ADDR
33877: GO 34258
33879: LD_INT 16
33881: DOUBLE
33882: EQUAL
33883: IFTRUE 33887
33885: GO 33898
33887: POP
// bc_type := b_ext_gun ; 17 :
33888: LD_ADDR_OWVAR 42
33892: PUSH
33893: LD_INT 17
33895: ST_TO_ADDR
33896: GO 34258
33898: LD_INT 17
33900: DOUBLE
33901: EQUAL
33902: IFTRUE 33906
33904: GO 33934
33906: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
33907: LD_ADDR_OWVAR 42
33911: PUSH
33912: LD_INT 19
33914: PUSH
33915: LD_INT 23
33917: PUSH
33918: LD_INT 19
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: LIST
33925: PUSH
33926: LD_VAR 0 1
33930: ARRAY
33931: ST_TO_ADDR
33932: GO 34258
33934: LD_INT 18
33936: DOUBLE
33937: EQUAL
33938: IFTRUE 33942
33940: GO 33953
33942: POP
// bc_type := b_ext_radar ; 19 :
33943: LD_ADDR_OWVAR 42
33947: PUSH
33948: LD_INT 20
33950: ST_TO_ADDR
33951: GO 34258
33953: LD_INT 19
33955: DOUBLE
33956: EQUAL
33957: IFTRUE 33961
33959: GO 33972
33961: POP
// bc_type := b_ext_radio ; 20 :
33962: LD_ADDR_OWVAR 42
33966: PUSH
33967: LD_INT 22
33969: ST_TO_ADDR
33970: GO 34258
33972: LD_INT 20
33974: DOUBLE
33975: EQUAL
33976: IFTRUE 33980
33978: GO 33991
33980: POP
// bc_type := b_ext_siberium ; 21 :
33981: LD_ADDR_OWVAR 42
33985: PUSH
33986: LD_INT 21
33988: ST_TO_ADDR
33989: GO 34258
33991: LD_INT 21
33993: DOUBLE
33994: EQUAL
33995: IFTRUE 33999
33997: GO 34010
33999: POP
// bc_type := b_ext_computer ; 22 :
34000: LD_ADDR_OWVAR 42
34004: PUSH
34005: LD_INT 24
34007: ST_TO_ADDR
34008: GO 34258
34010: LD_INT 22
34012: DOUBLE
34013: EQUAL
34014: IFTRUE 34018
34016: GO 34029
34018: POP
// bc_type := b_ext_track ; 23 :
34019: LD_ADDR_OWVAR 42
34023: PUSH
34024: LD_INT 16
34026: ST_TO_ADDR
34027: GO 34258
34029: LD_INT 23
34031: DOUBLE
34032: EQUAL
34033: IFTRUE 34037
34035: GO 34048
34037: POP
// bc_type := b_ext_laser ; 24 :
34038: LD_ADDR_OWVAR 42
34042: PUSH
34043: LD_INT 25
34045: ST_TO_ADDR
34046: GO 34258
34048: LD_INT 24
34050: DOUBLE
34051: EQUAL
34052: IFTRUE 34056
34054: GO 34067
34056: POP
// bc_type := b_control_tower ; 25 :
34057: LD_ADDR_OWVAR 42
34061: PUSH
34062: LD_INT 36
34064: ST_TO_ADDR
34065: GO 34258
34067: LD_INT 25
34069: DOUBLE
34070: EQUAL
34071: IFTRUE 34075
34073: GO 34086
34075: POP
// bc_type := b_breastwork ; 26 :
34076: LD_ADDR_OWVAR 42
34080: PUSH
34081: LD_INT 31
34083: ST_TO_ADDR
34084: GO 34258
34086: LD_INT 26
34088: DOUBLE
34089: EQUAL
34090: IFTRUE 34094
34092: GO 34105
34094: POP
// bc_type := b_bunker ; 27 :
34095: LD_ADDR_OWVAR 42
34099: PUSH
34100: LD_INT 32
34102: ST_TO_ADDR
34103: GO 34258
34105: LD_INT 27
34107: DOUBLE
34108: EQUAL
34109: IFTRUE 34113
34111: GO 34124
34113: POP
// bc_type := b_turret ; 28 :
34114: LD_ADDR_OWVAR 42
34118: PUSH
34119: LD_INT 33
34121: ST_TO_ADDR
34122: GO 34258
34124: LD_INT 28
34126: DOUBLE
34127: EQUAL
34128: IFTRUE 34132
34130: GO 34143
34132: POP
// bc_type := b_armoury ; 29 :
34133: LD_ADDR_OWVAR 42
34137: PUSH
34138: LD_INT 4
34140: ST_TO_ADDR
34141: GO 34258
34143: LD_INT 29
34145: DOUBLE
34146: EQUAL
34147: IFTRUE 34151
34149: GO 34162
34151: POP
// bc_type := b_barracks ; 30 :
34152: LD_ADDR_OWVAR 42
34156: PUSH
34157: LD_INT 5
34159: ST_TO_ADDR
34160: GO 34258
34162: LD_INT 30
34164: DOUBLE
34165: EQUAL
34166: IFTRUE 34170
34168: GO 34181
34170: POP
// bc_type := b_solar_power ; 31 :
34171: LD_ADDR_OWVAR 42
34175: PUSH
34176: LD_INT 27
34178: ST_TO_ADDR
34179: GO 34258
34181: LD_INT 31
34183: DOUBLE
34184: EQUAL
34185: IFTRUE 34189
34187: GO 34200
34189: POP
// bc_type := b_oil_power ; 32 :
34190: LD_ADDR_OWVAR 42
34194: PUSH
34195: LD_INT 26
34197: ST_TO_ADDR
34198: GO 34258
34200: LD_INT 32
34202: DOUBLE
34203: EQUAL
34204: IFTRUE 34208
34206: GO 34219
34208: POP
// bc_type := b_siberite_power ; 33 :
34209: LD_ADDR_OWVAR 42
34213: PUSH
34214: LD_INT 28
34216: ST_TO_ADDR
34217: GO 34258
34219: LD_INT 33
34221: DOUBLE
34222: EQUAL
34223: IFTRUE 34227
34225: GO 34238
34227: POP
// bc_type := b_oil_mine ; 34 :
34228: LD_ADDR_OWVAR 42
34232: PUSH
34233: LD_INT 29
34235: ST_TO_ADDR
34236: GO 34258
34238: LD_INT 34
34240: DOUBLE
34241: EQUAL
34242: IFTRUE 34246
34244: GO 34257
34246: POP
// bc_type := b_siberite_mine ; end ;
34247: LD_ADDR_OWVAR 42
34251: PUSH
34252: LD_INT 30
34254: ST_TO_ADDR
34255: GO 34258
34257: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
34258: LD_ADDR_VAR 0 8
34262: PUSH
34263: LD_VAR 0 5
34267: PPUSH
34268: LD_VAR 0 6
34272: PPUSH
34273: LD_VAR 0 3
34277: PPUSH
34278: CALL_OW 47
34282: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
34283: LD_OWVAR 42
34287: PUSH
34288: LD_INT 32
34290: PUSH
34291: LD_INT 33
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: IN
34298: IFFALSE 34314
// PlaceWeaponTurret ( b , weapon ) ;
34300: LD_VAR 0 8
34304: PPUSH
34305: LD_VAR 0 4
34309: PPUSH
34310: CALL_OW 431
// end ;
34314: LD_VAR 0 7
34318: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
34319: LD_INT 0
34321: PPUSH
34322: PPUSH
34323: PPUSH
34324: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
34325: LD_ADDR_VAR 0 4
34329: PUSH
34330: LD_INT 22
34332: PUSH
34333: LD_OWVAR 2
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 2
34344: PUSH
34345: LD_INT 30
34347: PUSH
34348: LD_INT 0
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 30
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: LIST
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PPUSH
34374: CALL_OW 69
34378: ST_TO_ADDR
// if not tmp then
34379: LD_VAR 0 4
34383: NOT
34384: IFFALSE 34388
// exit ;
34386: GO 34447
// for i in tmp do
34388: LD_ADDR_VAR 0 2
34392: PUSH
34393: LD_VAR 0 4
34397: PUSH
34398: FOR_IN
34399: IFFALSE 34445
// for j = 1 to 3 do
34401: LD_ADDR_VAR 0 3
34405: PUSH
34406: DOUBLE
34407: LD_INT 1
34409: DEC
34410: ST_TO_ADDR
34411: LD_INT 3
34413: PUSH
34414: FOR_TO
34415: IFFALSE 34441
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
34417: LD_VAR 0 2
34421: PPUSH
34422: CALL_OW 274
34426: PPUSH
34427: LD_VAR 0 3
34431: PPUSH
34432: LD_INT 99999
34434: PPUSH
34435: CALL_OW 277
34439: GO 34414
34441: POP
34442: POP
34443: GO 34398
34445: POP
34446: POP
// end ;
34447: LD_VAR 0 1
34451: RET
// export function hHackSetLevel10 ; var i , j ; begin
34452: LD_INT 0
34454: PPUSH
34455: PPUSH
34456: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
34457: LD_ADDR_VAR 0 2
34461: PUSH
34462: LD_INT 21
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PPUSH
34472: CALL_OW 69
34476: PUSH
34477: FOR_IN
34478: IFFALSE 34530
// if IsSelected ( i ) then
34480: LD_VAR 0 2
34484: PPUSH
34485: CALL_OW 306
34489: IFFALSE 34528
// begin for j := 1 to 4 do
34491: LD_ADDR_VAR 0 3
34495: PUSH
34496: DOUBLE
34497: LD_INT 1
34499: DEC
34500: ST_TO_ADDR
34501: LD_INT 4
34503: PUSH
34504: FOR_TO
34505: IFFALSE 34526
// SetSkill ( i , j , 10 ) ;
34507: LD_VAR 0 2
34511: PPUSH
34512: LD_VAR 0 3
34516: PPUSH
34517: LD_INT 10
34519: PPUSH
34520: CALL_OW 237
34524: GO 34504
34526: POP
34527: POP
// end ;
34528: GO 34477
34530: POP
34531: POP
// end ;
34532: LD_VAR 0 1
34536: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
34537: LD_INT 0
34539: PPUSH
34540: PPUSH
34541: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
34542: LD_ADDR_VAR 0 2
34546: PUSH
34547: LD_INT 22
34549: PUSH
34550: LD_OWVAR 2
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 21
34561: PUSH
34562: LD_INT 1
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PPUSH
34573: CALL_OW 69
34577: PUSH
34578: FOR_IN
34579: IFFALSE 34620
// begin for j := 1 to 4 do
34581: LD_ADDR_VAR 0 3
34585: PUSH
34586: DOUBLE
34587: LD_INT 1
34589: DEC
34590: ST_TO_ADDR
34591: LD_INT 4
34593: PUSH
34594: FOR_TO
34595: IFFALSE 34616
// SetSkill ( i , j , 10 ) ;
34597: LD_VAR 0 2
34601: PPUSH
34602: LD_VAR 0 3
34606: PPUSH
34607: LD_INT 10
34609: PPUSH
34610: CALL_OW 237
34614: GO 34594
34616: POP
34617: POP
// end ;
34618: GO 34578
34620: POP
34621: POP
// end ;
34622: LD_VAR 0 1
34626: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
34627: LD_INT 0
34629: PPUSH
// uc_side := your_side ;
34630: LD_ADDR_OWVAR 20
34634: PUSH
34635: LD_OWVAR 2
34639: ST_TO_ADDR
// uc_nation := nation ;
34640: LD_ADDR_OWVAR 21
34644: PUSH
34645: LD_VAR 0 1
34649: ST_TO_ADDR
// InitHc ;
34650: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
34654: LD_INT 0
34656: PPUSH
34657: LD_VAR 0 2
34661: PPUSH
34662: LD_VAR 0 3
34666: PPUSH
34667: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
34671: LD_VAR 0 4
34675: PPUSH
34676: LD_VAR 0 5
34680: PPUSH
34681: CALL_OW 428
34685: PUSH
34686: LD_INT 0
34688: EQUAL
34689: IFFALSE 34713
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
34691: CALL_OW 44
34695: PPUSH
34696: LD_VAR 0 4
34700: PPUSH
34701: LD_VAR 0 5
34705: PPUSH
34706: LD_INT 1
34708: PPUSH
34709: CALL_OW 48
// end ;
34713: LD_VAR 0 6
34717: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
34718: LD_INT 0
34720: PPUSH
34721: PPUSH
// uc_side := your_side ;
34722: LD_ADDR_OWVAR 20
34726: PUSH
34727: LD_OWVAR 2
34731: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
34732: LD_VAR 0 1
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: LD_INT 2
34742: PUSH
34743: LD_INT 3
34745: PUSH
34746: LD_INT 4
34748: PUSH
34749: LD_INT 5
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: IN
34759: IFFALSE 34771
// uc_nation := nation_american else
34761: LD_ADDR_OWVAR 21
34765: PUSH
34766: LD_INT 1
34768: ST_TO_ADDR
34769: GO 34814
// if chassis in [ 11 , 12 , 13 , 14 ] then
34771: LD_VAR 0 1
34775: PUSH
34776: LD_INT 11
34778: PUSH
34779: LD_INT 12
34781: PUSH
34782: LD_INT 13
34784: PUSH
34785: LD_INT 14
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: IN
34794: IFFALSE 34806
// uc_nation := nation_arabian else
34796: LD_ADDR_OWVAR 21
34800: PUSH
34801: LD_INT 2
34803: ST_TO_ADDR
34804: GO 34814
// uc_nation := nation_russian ;
34806: LD_ADDR_OWVAR 21
34810: PUSH
34811: LD_INT 3
34813: ST_TO_ADDR
// vc_chassis := chassis ;
34814: LD_ADDR_OWVAR 37
34818: PUSH
34819: LD_VAR 0 1
34823: ST_TO_ADDR
// vc_engine := engine ;
34824: LD_ADDR_OWVAR 39
34828: PUSH
34829: LD_VAR 0 2
34833: ST_TO_ADDR
// vc_control := control ;
34834: LD_ADDR_OWVAR 38
34838: PUSH
34839: LD_VAR 0 3
34843: ST_TO_ADDR
// vc_weapon := weapon ;
34844: LD_ADDR_OWVAR 40
34848: PUSH
34849: LD_VAR 0 4
34853: ST_TO_ADDR
// un := CreateVehicle ;
34854: LD_ADDR_VAR 0 8
34858: PUSH
34859: CALL_OW 45
34863: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
34864: LD_VAR 0 8
34868: PPUSH
34869: LD_INT 0
34871: PPUSH
34872: LD_INT 5
34874: PPUSH
34875: CALL_OW 12
34879: PPUSH
34880: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
34884: LD_VAR 0 8
34888: PPUSH
34889: LD_VAR 0 5
34893: PPUSH
34894: LD_VAR 0 6
34898: PPUSH
34899: LD_INT 1
34901: PPUSH
34902: CALL_OW 48
// end ;
34906: LD_VAR 0 7
34910: RET
// export hInvincible ; every 1 do
34911: GO 34913
34913: DISABLE
// hInvincible := [ ] ;
34914: LD_ADDR_EXP 86
34918: PUSH
34919: EMPTY
34920: ST_TO_ADDR
34921: END
// every 10 do var i ;
34922: GO 34924
34924: DISABLE
34925: LD_INT 0
34927: PPUSH
// begin enable ;
34928: ENABLE
// if not hInvincible then
34929: LD_EXP 86
34933: NOT
34934: IFFALSE 34938
// exit ;
34936: GO 34982
// for i in hInvincible do
34938: LD_ADDR_VAR 0 1
34942: PUSH
34943: LD_EXP 86
34947: PUSH
34948: FOR_IN
34949: IFFALSE 34980
// if GetLives ( i ) < 1000 then
34951: LD_VAR 0 1
34955: PPUSH
34956: CALL_OW 256
34960: PUSH
34961: LD_INT 1000
34963: LESS
34964: IFFALSE 34978
// SetLives ( i , 1000 ) ;
34966: LD_VAR 0 1
34970: PPUSH
34971: LD_INT 1000
34973: PPUSH
34974: CALL_OW 234
34978: GO 34948
34980: POP
34981: POP
// end ;
34982: PPOPN 1
34984: END
// export function hHackInvincible ; var i ; begin
34985: LD_INT 0
34987: PPUSH
34988: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
34989: LD_ADDR_VAR 0 2
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: LD_INT 21
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 21
35009: PUSH
35010: LD_INT 2
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: LIST
35021: PPUSH
35022: CALL_OW 69
35026: PUSH
35027: FOR_IN
35028: IFFALSE 35089
// if IsSelected ( i ) then
35030: LD_VAR 0 2
35034: PPUSH
35035: CALL_OW 306
35039: IFFALSE 35087
// begin if i in hInvincible then
35041: LD_VAR 0 2
35045: PUSH
35046: LD_EXP 86
35050: IN
35051: IFFALSE 35071
// hInvincible := hInvincible diff i else
35053: LD_ADDR_EXP 86
35057: PUSH
35058: LD_EXP 86
35062: PUSH
35063: LD_VAR 0 2
35067: DIFF
35068: ST_TO_ADDR
35069: GO 35087
// hInvincible := hInvincible union i ;
35071: LD_ADDR_EXP 86
35075: PUSH
35076: LD_EXP 86
35080: PUSH
35081: LD_VAR 0 2
35085: UNION
35086: ST_TO_ADDR
// end ;
35087: GO 35027
35089: POP
35090: POP
// end ;
35091: LD_VAR 0 1
35095: RET
// export function hHackInvisible ; var i , j ; begin
35096: LD_INT 0
35098: PPUSH
35099: PPUSH
35100: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
35101: LD_ADDR_VAR 0 2
35105: PUSH
35106: LD_INT 21
35108: PUSH
35109: LD_INT 1
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PPUSH
35116: CALL_OW 69
35120: PUSH
35121: FOR_IN
35122: IFFALSE 35146
// if IsSelected ( i ) then
35124: LD_VAR 0 2
35128: PPUSH
35129: CALL_OW 306
35133: IFFALSE 35144
// ComForceInvisible ( i ) ;
35135: LD_VAR 0 2
35139: PPUSH
35140: CALL_OW 496
35144: GO 35121
35146: POP
35147: POP
// end ;
35148: LD_VAR 0 1
35152: RET
// export function hHackChangeYourSide ; begin
35153: LD_INT 0
35155: PPUSH
// if your_side = 8 then
35156: LD_OWVAR 2
35160: PUSH
35161: LD_INT 8
35163: EQUAL
35164: IFFALSE 35176
// your_side := 0 else
35166: LD_ADDR_OWVAR 2
35170: PUSH
35171: LD_INT 0
35173: ST_TO_ADDR
35174: GO 35190
// your_side := your_side + 1 ;
35176: LD_ADDR_OWVAR 2
35180: PUSH
35181: LD_OWVAR 2
35185: PUSH
35186: LD_INT 1
35188: PLUS
35189: ST_TO_ADDR
// end ;
35190: LD_VAR 0 1
35194: RET
// export function hHackChangeUnitSide ; var i , j ; begin
35195: LD_INT 0
35197: PPUSH
35198: PPUSH
35199: PPUSH
// for i in all_units do
35200: LD_ADDR_VAR 0 2
35204: PUSH
35205: LD_OWVAR 3
35209: PUSH
35210: FOR_IN
35211: IFFALSE 35289
// if IsSelected ( i ) then
35213: LD_VAR 0 2
35217: PPUSH
35218: CALL_OW 306
35222: IFFALSE 35287
// begin j := GetSide ( i ) ;
35224: LD_ADDR_VAR 0 3
35228: PUSH
35229: LD_VAR 0 2
35233: PPUSH
35234: CALL_OW 255
35238: ST_TO_ADDR
// if j = 8 then
35239: LD_VAR 0 3
35243: PUSH
35244: LD_INT 8
35246: EQUAL
35247: IFFALSE 35259
// j := 0 else
35249: LD_ADDR_VAR 0 3
35253: PUSH
35254: LD_INT 0
35256: ST_TO_ADDR
35257: GO 35273
// j := j + 1 ;
35259: LD_ADDR_VAR 0 3
35263: PUSH
35264: LD_VAR 0 3
35268: PUSH
35269: LD_INT 1
35271: PLUS
35272: ST_TO_ADDR
// SetSide ( i , j ) ;
35273: LD_VAR 0 2
35277: PPUSH
35278: LD_VAR 0 3
35282: PPUSH
35283: CALL_OW 235
// end ;
35287: GO 35210
35289: POP
35290: POP
// end ;
35291: LD_VAR 0 1
35295: RET
// export function hHackFog ; begin
35296: LD_INT 0
35298: PPUSH
// FogOff ( true ) ;
35299: LD_INT 1
35301: PPUSH
35302: CALL_OW 344
// end ;
35306: LD_VAR 0 1
35310: RET
// export function hHackTeleport ( unit , x , y ) ; begin
35311: LD_INT 0
35313: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
35314: LD_VAR 0 1
35318: PPUSH
35319: LD_VAR 0 2
35323: PPUSH
35324: LD_VAR 0 3
35328: PPUSH
35329: LD_INT 1
35331: PPUSH
35332: LD_INT 1
35334: PPUSH
35335: CALL_OW 483
// CenterOnXY ( x , y ) ;
35339: LD_VAR 0 2
35343: PPUSH
35344: LD_VAR 0 3
35348: PPUSH
35349: CALL_OW 84
// end ;
35353: LD_VAR 0 4
35357: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
35358: LD_INT 0
35360: PPUSH
35361: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
35362: LD_VAR 0 1
35366: NOT
35367: PUSH
35368: LD_VAR 0 2
35372: PPUSH
35373: LD_VAR 0 3
35377: PPUSH
35378: CALL_OW 488
35382: NOT
35383: OR
35384: PUSH
35385: LD_VAR 0 1
35389: PPUSH
35390: CALL_OW 266
35394: PUSH
35395: LD_INT 3
35397: NONEQUAL
35398: PUSH
35399: LD_VAR 0 1
35403: PPUSH
35404: CALL_OW 247
35408: PUSH
35409: LD_INT 1
35411: EQUAL
35412: NOT
35413: AND
35414: OR
35415: IFFALSE 35419
// exit ;
35417: GO 35568
// if GetType ( factory ) = unit_human then
35419: LD_VAR 0 1
35423: PPUSH
35424: CALL_OW 247
35428: PUSH
35429: LD_INT 1
35431: EQUAL
35432: IFFALSE 35449
// factory := IsInUnit ( factory ) ;
35434: LD_ADDR_VAR 0 1
35438: PUSH
35439: LD_VAR 0 1
35443: PPUSH
35444: CALL_OW 310
35448: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
35449: LD_VAR 0 1
35453: PPUSH
35454: CALL_OW 266
35458: PUSH
35459: LD_INT 3
35461: NONEQUAL
35462: IFFALSE 35466
// exit ;
35464: GO 35568
// if HexInfo ( x , y ) = factory then
35466: LD_VAR 0 2
35470: PPUSH
35471: LD_VAR 0 3
35475: PPUSH
35476: CALL_OW 428
35480: PUSH
35481: LD_VAR 0 1
35485: EQUAL
35486: IFFALSE 35513
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
35488: LD_ADDR_EXP 87
35492: PUSH
35493: LD_EXP 87
35497: PPUSH
35498: LD_VAR 0 1
35502: PPUSH
35503: LD_INT 0
35505: PPUSH
35506: CALL_OW 1
35510: ST_TO_ADDR
35511: GO 35564
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
35513: LD_ADDR_EXP 87
35517: PUSH
35518: LD_EXP 87
35522: PPUSH
35523: LD_VAR 0 1
35527: PPUSH
35528: LD_VAR 0 1
35532: PPUSH
35533: CALL_OW 255
35537: PUSH
35538: LD_VAR 0 1
35542: PUSH
35543: LD_VAR 0 2
35547: PUSH
35548: LD_VAR 0 3
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// UpdateFactoryWaypoints ;
35564: CALL 35573 0 0
// end ;
35568: LD_VAR 0 4
35572: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
35573: LD_INT 0
35575: PPUSH
35576: PPUSH
35577: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
35578: LD_STRING resetFactoryWaypoint();
35580: PPUSH
35581: CALL_OW 559
// if factoryWaypoints then
35585: LD_EXP 87
35589: IFFALSE 35715
// begin list := PrepareArray ( factoryWaypoints ) ;
35591: LD_ADDR_VAR 0 3
35595: PUSH
35596: LD_EXP 87
35600: PPUSH
35601: NOP4
35605: ST_TO_ADDR
// for i := 1 to list do
35606: LD_ADDR_VAR 0 2
35610: PUSH
35611: DOUBLE
35612: LD_INT 1
35614: DEC
35615: ST_TO_ADDR
35616: LD_VAR 0 3
35620: PUSH
35621: FOR_TO
35622: IFFALSE 35713
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
35624: LD_STRING setFactoryWaypointXY(
35626: PUSH
35627: LD_VAR 0 3
35631: PUSH
35632: LD_VAR 0 2
35636: ARRAY
35637: PUSH
35638: LD_INT 1
35640: ARRAY
35641: STR
35642: PUSH
35643: LD_STRING ,
35645: STR
35646: PUSH
35647: LD_VAR 0 3
35651: PUSH
35652: LD_VAR 0 2
35656: ARRAY
35657: PUSH
35658: LD_INT 2
35660: ARRAY
35661: STR
35662: PUSH
35663: LD_STRING ,
35665: STR
35666: PUSH
35667: LD_VAR 0 3
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 3
35680: ARRAY
35681: STR
35682: PUSH
35683: LD_STRING ,
35685: STR
35686: PUSH
35687: LD_VAR 0 3
35691: PUSH
35692: LD_VAR 0 2
35696: ARRAY
35697: PUSH
35698: LD_INT 4
35700: ARRAY
35701: STR
35702: PUSH
35703: LD_STRING )
35705: STR
35706: PPUSH
35707: CALL_OW 559
35711: GO 35621
35713: POP
35714: POP
// end ; end ;
35715: LD_VAR 0 1
35719: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
35720: LD_INT 0
35722: PPUSH
// if HexInfo ( x , y ) = warehouse then
35723: LD_VAR 0 2
35727: PPUSH
35728: LD_VAR 0 3
35732: PPUSH
35733: CALL_OW 428
35737: PUSH
35738: LD_VAR 0 1
35742: EQUAL
35743: IFFALSE 35770
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
35745: LD_ADDR_EXP 88
35749: PUSH
35750: LD_EXP 88
35754: PPUSH
35755: LD_VAR 0 1
35759: PPUSH
35760: LD_INT 0
35762: PPUSH
35763: CALL_OW 1
35767: ST_TO_ADDR
35768: GO 35821
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
35770: LD_ADDR_EXP 88
35774: PUSH
35775: LD_EXP 88
35779: PPUSH
35780: LD_VAR 0 1
35784: PPUSH
35785: LD_VAR 0 1
35789: PPUSH
35790: CALL_OW 255
35794: PUSH
35795: LD_VAR 0 1
35799: PUSH
35800: LD_VAR 0 2
35804: PUSH
35805: LD_VAR 0 3
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: PPUSH
35816: CALL_OW 1
35820: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
35821: CALL 35830 0 0
// end ;
35825: LD_VAR 0 4
35829: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
35830: LD_INT 0
35832: PPUSH
35833: PPUSH
35834: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
35835: LD_STRING resetWarehouseGatheringPoints();
35837: PPUSH
35838: CALL_OW 559
// if warehouseGatheringPoints then
35842: LD_EXP 88
35846: IFFALSE 35972
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
35848: LD_ADDR_VAR 0 3
35852: PUSH
35853: LD_EXP 88
35857: PPUSH
35858: NOP4
35862: ST_TO_ADDR
// for i := 1 to list do
35863: LD_ADDR_VAR 0 2
35867: PUSH
35868: DOUBLE
35869: LD_INT 1
35871: DEC
35872: ST_TO_ADDR
35873: LD_VAR 0 3
35877: PUSH
35878: FOR_TO
35879: IFFALSE 35970
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
35881: LD_STRING setWarehouseGatheringPointXY(
35883: PUSH
35884: LD_VAR 0 3
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PUSH
35895: LD_INT 1
35897: ARRAY
35898: STR
35899: PUSH
35900: LD_STRING ,
35902: STR
35903: PUSH
35904: LD_VAR 0 3
35908: PUSH
35909: LD_VAR 0 2
35913: ARRAY
35914: PUSH
35915: LD_INT 2
35917: ARRAY
35918: STR
35919: PUSH
35920: LD_STRING ,
35922: STR
35923: PUSH
35924: LD_VAR 0 3
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PUSH
35935: LD_INT 3
35937: ARRAY
35938: STR
35939: PUSH
35940: LD_STRING ,
35942: STR
35943: PUSH
35944: LD_VAR 0 3
35948: PUSH
35949: LD_VAR 0 2
35953: ARRAY
35954: PUSH
35955: LD_INT 4
35957: ARRAY
35958: STR
35959: PUSH
35960: LD_STRING )
35962: STR
35963: PPUSH
35964: CALL_OW 559
35968: GO 35878
35970: POP
35971: POP
// end ; end ;
35972: LD_VAR 0 1
35976: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
35977: LD_EXP 88
35981: IFFALSE 36666
35983: GO 35985
35985: DISABLE
35986: LD_INT 0
35988: PPUSH
35989: PPUSH
35990: PPUSH
35991: PPUSH
35992: PPUSH
35993: PPUSH
35994: PPUSH
35995: PPUSH
35996: PPUSH
// begin enable ;
35997: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
35998: LD_ADDR_VAR 0 3
36002: PUSH
36003: LD_EXP 88
36007: PPUSH
36008: NOP4
36012: ST_TO_ADDR
// if not list then
36013: LD_VAR 0 3
36017: NOT
36018: IFFALSE 36022
// exit ;
36020: GO 36666
// for i := 1 to list do
36022: LD_ADDR_VAR 0 1
36026: PUSH
36027: DOUBLE
36028: LD_INT 1
36030: DEC
36031: ST_TO_ADDR
36032: LD_VAR 0 3
36036: PUSH
36037: FOR_TO
36038: IFFALSE 36664
// begin depot := list [ i ] [ 2 ] ;
36040: LD_ADDR_VAR 0 8
36044: PUSH
36045: LD_VAR 0 3
36049: PUSH
36050: LD_VAR 0 1
36054: ARRAY
36055: PUSH
36056: LD_INT 2
36058: ARRAY
36059: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
36060: LD_ADDR_VAR 0 5
36064: PUSH
36065: LD_VAR 0 3
36069: PUSH
36070: LD_VAR 0 1
36074: ARRAY
36075: PUSH
36076: LD_INT 1
36078: ARRAY
36079: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
36080: LD_VAR 0 8
36084: PPUSH
36085: CALL_OW 301
36089: PUSH
36090: LD_VAR 0 5
36094: PUSH
36095: LD_VAR 0 8
36099: PPUSH
36100: CALL_OW 255
36104: NONEQUAL
36105: OR
36106: IFFALSE 36135
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
36108: LD_ADDR_EXP 88
36112: PUSH
36113: LD_EXP 88
36117: PPUSH
36118: LD_VAR 0 8
36122: PPUSH
36123: LD_INT 0
36125: PPUSH
36126: CALL_OW 1
36130: ST_TO_ADDR
// exit ;
36131: POP
36132: POP
36133: GO 36666
// end ; x := list [ i ] [ 3 ] ;
36135: LD_ADDR_VAR 0 6
36139: PUSH
36140: LD_VAR 0 3
36144: PUSH
36145: LD_VAR 0 1
36149: ARRAY
36150: PUSH
36151: LD_INT 3
36153: ARRAY
36154: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
36155: LD_ADDR_VAR 0 7
36159: PUSH
36160: LD_VAR 0 3
36164: PUSH
36165: LD_VAR 0 1
36169: ARRAY
36170: PUSH
36171: LD_INT 4
36173: ARRAY
36174: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
36175: LD_ADDR_VAR 0 9
36179: PUSH
36180: LD_VAR 0 6
36184: PPUSH
36185: LD_VAR 0 7
36189: PPUSH
36190: LD_INT 16
36192: PPUSH
36193: NOP4
36197: ST_TO_ADDR
// if not cratesNearbyPoint then
36198: LD_VAR 0 9
36202: NOT
36203: IFFALSE 36209
// exit ;
36205: POP
36206: POP
36207: GO 36666
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
36209: LD_ADDR_VAR 0 4
36213: PUSH
36214: LD_INT 22
36216: PUSH
36217: LD_VAR 0 5
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 3
36228: PUSH
36229: LD_INT 60
36231: PUSH
36232: EMPTY
36233: LIST
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 91
36241: PUSH
36242: LD_VAR 0 8
36246: PUSH
36247: LD_INT 6
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 2
36257: PUSH
36258: LD_INT 25
36260: PUSH
36261: LD_INT 2
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 25
36270: PUSH
36271: LD_INT 16
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: LIST
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: PPUSH
36289: CALL_OW 69
36293: PUSH
36294: LD_VAR 0 8
36298: PPUSH
36299: CALL_OW 313
36303: PPUSH
36304: LD_INT 3
36306: PUSH
36307: LD_INT 60
36309: PUSH
36310: EMPTY
36311: LIST
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 2
36319: PUSH
36320: LD_INT 25
36322: PUSH
36323: LD_INT 2
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 25
36332: PUSH
36333: LD_INT 16
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: LIST
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PPUSH
36349: CALL_OW 72
36353: UNION
36354: ST_TO_ADDR
// if tmp then
36355: LD_VAR 0 4
36359: IFFALSE 36439
// begin tmp := ShrinkArray ( tmp , 3 ) ;
36361: LD_ADDR_VAR 0 4
36365: PUSH
36366: LD_VAR 0 4
36370: PPUSH
36371: LD_INT 3
36373: PPUSH
36374: NOP4
36378: ST_TO_ADDR
// for j in tmp do
36379: LD_ADDR_VAR 0 2
36383: PUSH
36384: LD_VAR 0 4
36388: PUSH
36389: FOR_IN
36390: IFFALSE 36433
// begin if IsInUnit ( j ) then
36392: LD_VAR 0 2
36396: PPUSH
36397: CALL_OW 310
36401: IFFALSE 36412
// ComExit ( j ) ;
36403: LD_VAR 0 2
36407: PPUSH
36408: NOP4
// AddComCollect ( j , x , y ) ;
36412: LD_VAR 0 2
36416: PPUSH
36417: LD_VAR 0 6
36421: PPUSH
36422: LD_VAR 0 7
36426: PPUSH
36427: CALL_OW 177
// end ;
36431: GO 36389
36433: POP
36434: POP
// exit ;
36435: POP
36436: POP
36437: GO 36666
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
36439: LD_ADDR_VAR 0 4
36443: PUSH
36444: LD_INT 22
36446: PUSH
36447: LD_VAR 0 5
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 91
36458: PUSH
36459: LD_VAR 0 8
36463: PUSH
36464: LD_INT 8
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 2
36474: PUSH
36475: LD_INT 34
36477: PUSH
36478: LD_INT 12
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 34
36487: PUSH
36488: LD_INT 51
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 34
36497: PUSH
36498: LD_INT 32
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 34
36507: PUSH
36508: LD_INT 89
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: LIST
36526: PPUSH
36527: CALL_OW 69
36531: ST_TO_ADDR
// if tmp then
36532: LD_VAR 0 4
36536: IFFALSE 36662
// begin for j in tmp do
36538: LD_ADDR_VAR 0 2
36542: PUSH
36543: LD_VAR 0 4
36547: PUSH
36548: FOR_IN
36549: IFFALSE 36660
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
36551: LD_VAR 0 2
36555: PPUSH
36556: CALL_OW 262
36560: PUSH
36561: LD_INT 3
36563: EQUAL
36564: PUSH
36565: LD_VAR 0 2
36569: PPUSH
36570: CALL_OW 261
36574: PUSH
36575: LD_INT 20
36577: GREATER
36578: OR
36579: PUSH
36580: LD_VAR 0 2
36584: PPUSH
36585: CALL_OW 314
36589: NOT
36590: AND
36591: PUSH
36592: LD_VAR 0 2
36596: PPUSH
36597: CALL_OW 263
36601: PUSH
36602: LD_INT 1
36604: NONEQUAL
36605: PUSH
36606: LD_VAR 0 2
36610: PPUSH
36611: CALL_OW 311
36615: OR
36616: AND
36617: IFFALSE 36658
// begin ComCollect ( j , x , y ) ;
36619: LD_VAR 0 2
36623: PPUSH
36624: LD_VAR 0 6
36628: PPUSH
36629: LD_VAR 0 7
36633: PPUSH
36634: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
36638: LD_VAR 0 2
36642: PPUSH
36643: LD_VAR 0 8
36647: PPUSH
36648: CALL_OW 172
// exit ;
36652: POP
36653: POP
36654: POP
36655: POP
36656: GO 36666
// end ;
36658: GO 36548
36660: POP
36661: POP
// end ; end ;
36662: GO 36037
36664: POP
36665: POP
// end ; end_of_file
36666: PPOPN 9
36668: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
36669: LD_INT 0
36671: PPUSH
36672: PPUSH
36673: PPUSH
36674: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
36675: LD_VAR 0 1
36679: PPUSH
36680: CALL_OW 264
36684: PUSH
36685: LD_INT 91
36687: EQUAL
36688: IFFALSE 36760
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
36690: LD_INT 68
36692: PPUSH
36693: LD_VAR 0 1
36697: PPUSH
36698: CALL_OW 255
36702: PPUSH
36703: CALL_OW 321
36707: PUSH
36708: LD_INT 2
36710: EQUAL
36711: IFFALSE 36723
// eff := 70 else
36713: LD_ADDR_VAR 0 4
36717: PUSH
36718: LD_INT 70
36720: ST_TO_ADDR
36721: GO 36731
// eff := 30 ;
36723: LD_ADDR_VAR 0 4
36727: PUSH
36728: LD_INT 30
36730: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
36731: LD_VAR 0 1
36735: PPUSH
36736: CALL_OW 250
36740: PPUSH
36741: LD_VAR 0 1
36745: PPUSH
36746: CALL_OW 251
36750: PPUSH
36751: LD_VAR 0 4
36755: PPUSH
36756: CALL_OW 495
// end ; end ;
36760: LD_VAR 0 2
36764: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
36765: LD_INT 0
36767: PPUSH
// end ;
36768: LD_VAR 0 4
36772: RET
// export function SOS_Command ( cmd ) ; begin
36773: LD_INT 0
36775: PPUSH
// end ;
36776: LD_VAR 0 2
36780: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
36781: LD_INT 0
36783: PPUSH
// end ;
36784: LD_VAR 0 6
36788: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
36789: LD_INT 0
36791: PPUSH
36792: PPUSH
// if not vehicle or not factory then
36793: LD_VAR 0 1
36797: NOT
36798: PUSH
36799: LD_VAR 0 2
36803: NOT
36804: OR
36805: IFFALSE 36809
// exit ;
36807: GO 37040
// if factoryWaypoints >= factory then
36809: LD_EXP 87
36813: PUSH
36814: LD_VAR 0 2
36818: GREATEREQUAL
36819: IFFALSE 37040
// if factoryWaypoints [ factory ] then
36821: LD_EXP 87
36825: PUSH
36826: LD_VAR 0 2
36830: ARRAY
36831: IFFALSE 37040
// begin if GetControl ( vehicle ) = control_manual then
36833: LD_VAR 0 1
36837: PPUSH
36838: CALL_OW 263
36842: PUSH
36843: LD_INT 1
36845: EQUAL
36846: IFFALSE 36927
// begin driver := IsDrivenBy ( vehicle ) ;
36848: LD_ADDR_VAR 0 4
36852: PUSH
36853: LD_VAR 0 1
36857: PPUSH
36858: CALL_OW 311
36862: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
36863: LD_VAR 0 4
36867: PPUSH
36868: LD_EXP 87
36872: PUSH
36873: LD_VAR 0 2
36877: ARRAY
36878: PUSH
36879: LD_INT 3
36881: ARRAY
36882: PPUSH
36883: LD_EXP 87
36887: PUSH
36888: LD_VAR 0 2
36892: ARRAY
36893: PUSH
36894: LD_INT 4
36896: ARRAY
36897: PPUSH
36898: CALL_OW 171
// AddComExitVehicle ( driver ) ;
36902: LD_VAR 0 4
36906: PPUSH
36907: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
36911: LD_VAR 0 4
36915: PPUSH
36916: LD_VAR 0 2
36920: PPUSH
36921: CALL_OW 180
// end else
36925: GO 37040
// if GetControl ( vehicle ) = control_remote then
36927: LD_VAR 0 1
36931: PPUSH
36932: CALL_OW 263
36936: PUSH
36937: LD_INT 2
36939: EQUAL
36940: IFFALSE 37001
// begin wait ( 0 0$2 ) ;
36942: LD_INT 70
36944: PPUSH
36945: CALL_OW 67
// if Connect ( vehicle ) then
36949: LD_VAR 0 1
36953: PPUSH
36954: CALL 16993 0 1
36958: IFFALSE 36999
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_EXP 87
36969: PUSH
36970: LD_VAR 0 2
36974: ARRAY
36975: PUSH
36976: LD_INT 3
36978: ARRAY
36979: PPUSH
36980: LD_EXP 87
36984: PUSH
36985: LD_VAR 0 2
36989: ARRAY
36990: PUSH
36991: LD_INT 4
36993: ARRAY
36994: PPUSH
36995: CALL_OW 171
// end else
36999: GO 37040
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
37001: LD_VAR 0 1
37005: PPUSH
37006: LD_EXP 87
37010: PUSH
37011: LD_VAR 0 2
37015: ARRAY
37016: PUSH
37017: LD_INT 3
37019: ARRAY
37020: PPUSH
37021: LD_EXP 87
37025: PUSH
37026: LD_VAR 0 2
37030: ARRAY
37031: PUSH
37032: LD_INT 4
37034: ARRAY
37035: PPUSH
37036: CALL_OW 171
// end ; end ;
37040: LD_VAR 0 3
37044: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
37045: LD_INT 0
37047: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
37048: LD_VAR 0 1
37052: PUSH
37053: LD_INT 250
37055: EQUAL
37056: PUSH
37057: LD_VAR 0 2
37061: PPUSH
37062: CALL_OW 264
37066: PUSH
37067: LD_INT 81
37069: EQUAL
37070: AND
37071: IFFALSE 37092
// MinerPlaceMine ( unit , x , y ) ;
37073: LD_VAR 0 2
37077: PPUSH
37078: LD_VAR 0 4
37082: PPUSH
37083: LD_VAR 0 5
37087: PPUSH
37088: CALL 39477 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
37092: LD_VAR 0 1
37096: PUSH
37097: LD_INT 251
37099: EQUAL
37100: PUSH
37101: LD_VAR 0 2
37105: PPUSH
37106: CALL_OW 264
37110: PUSH
37111: LD_INT 81
37113: EQUAL
37114: AND
37115: IFFALSE 37136
// MinerDetonateMine ( unit , x , y ) ;
37117: LD_VAR 0 2
37121: PPUSH
37122: LD_VAR 0 4
37126: PPUSH
37127: LD_VAR 0 5
37131: PPUSH
37132: CALL 39752 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
37136: LD_VAR 0 1
37140: PUSH
37141: LD_INT 252
37143: EQUAL
37144: PUSH
37145: LD_VAR 0 2
37149: PPUSH
37150: CALL_OW 264
37154: PUSH
37155: LD_INT 81
37157: EQUAL
37158: AND
37159: IFFALSE 37180
// MinerCreateMinefield ( unit , x , y ) ;
37161: LD_VAR 0 2
37165: PPUSH
37166: LD_VAR 0 4
37170: PPUSH
37171: LD_VAR 0 5
37175: PPUSH
37176: CALL 40169 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
37180: LD_VAR 0 1
37184: PUSH
37185: LD_INT 253
37187: EQUAL
37188: PUSH
37189: LD_VAR 0 2
37193: PPUSH
37194: CALL_OW 257
37198: PUSH
37199: LD_INT 5
37201: EQUAL
37202: AND
37203: IFFALSE 37224
// ComBinocular ( unit , x , y ) ;
37205: LD_VAR 0 2
37209: PPUSH
37210: LD_VAR 0 4
37214: PPUSH
37215: LD_VAR 0 5
37219: PPUSH
37220: CALL 40538 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
37224: LD_VAR 0 1
37228: PUSH
37229: LD_INT 254
37231: EQUAL
37232: PUSH
37233: LD_VAR 0 2
37237: PPUSH
37238: CALL_OW 264
37242: PUSH
37243: LD_INT 99
37245: EQUAL
37246: AND
37247: PUSH
37248: LD_VAR 0 3
37252: PPUSH
37253: CALL_OW 263
37257: PUSH
37258: LD_INT 3
37260: EQUAL
37261: AND
37262: IFFALSE 37278
// HackDestroyVehicle ( unit , selectedUnit ) ;
37264: LD_VAR 0 2
37268: PPUSH
37269: LD_VAR 0 3
37273: PPUSH
37274: CALL 38841 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
37278: LD_VAR 0 1
37282: PUSH
37283: LD_INT 255
37285: EQUAL
37286: PUSH
37287: LD_VAR 0 2
37291: PPUSH
37292: CALL_OW 264
37296: PUSH
37297: LD_INT 14
37299: PUSH
37300: LD_INT 53
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: IN
37307: AND
37308: PUSH
37309: LD_VAR 0 4
37313: PPUSH
37314: LD_VAR 0 5
37318: PPUSH
37319: CALL_OW 488
37323: AND
37324: IFFALSE 37348
// CutTreeXYR ( unit , x , y , 12 ) ;
37326: LD_VAR 0 2
37330: PPUSH
37331: LD_VAR 0 4
37335: PPUSH
37336: LD_VAR 0 5
37340: PPUSH
37341: LD_INT 12
37343: PPUSH
37344: CALL 37411 0 4
// if cmd = 256 then
37348: LD_VAR 0 1
37352: PUSH
37353: LD_INT 256
37355: EQUAL
37356: IFFALSE 37377
// SetFactoryWaypoint ( unit , x , y ) ;
37358: LD_VAR 0 2
37362: PPUSH
37363: LD_VAR 0 4
37367: PPUSH
37368: LD_VAR 0 5
37372: PPUSH
37373: CALL 35358 0 3
// if cmd = 257 then
37377: LD_VAR 0 1
37381: PUSH
37382: LD_INT 257
37384: EQUAL
37385: IFFALSE 37406
// SetWarehouseGatheringPoint ( unit , x , y ) ;
37387: LD_VAR 0 2
37391: PPUSH
37392: LD_VAR 0 4
37396: PPUSH
37397: LD_VAR 0 5
37401: PPUSH
37402: CALL 35720 0 3
// end ;
37406: LD_VAR 0 6
37410: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
37411: LD_INT 0
37413: PPUSH
37414: PPUSH
37415: PPUSH
37416: PPUSH
37417: PPUSH
37418: PPUSH
37419: PPUSH
37420: PPUSH
37421: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
37422: LD_VAR 0 1
37426: NOT
37427: PUSH
37428: LD_VAR 0 2
37432: PPUSH
37433: LD_VAR 0 3
37437: PPUSH
37438: CALL_OW 488
37442: NOT
37443: OR
37444: PUSH
37445: LD_VAR 0 4
37449: NOT
37450: OR
37451: IFFALSE 37455
// exit ;
37453: GO 37795
// list := [ ] ;
37455: LD_ADDR_VAR 0 13
37459: PUSH
37460: EMPTY
37461: ST_TO_ADDR
// if x - r < 0 then
37462: LD_VAR 0 2
37466: PUSH
37467: LD_VAR 0 4
37471: MINUS
37472: PUSH
37473: LD_INT 0
37475: LESS
37476: IFFALSE 37488
// min_x := 0 else
37478: LD_ADDR_VAR 0 7
37482: PUSH
37483: LD_INT 0
37485: ST_TO_ADDR
37486: GO 37504
// min_x := x - r ;
37488: LD_ADDR_VAR 0 7
37492: PUSH
37493: LD_VAR 0 2
37497: PUSH
37498: LD_VAR 0 4
37502: MINUS
37503: ST_TO_ADDR
// if y - r < 0 then
37504: LD_VAR 0 3
37508: PUSH
37509: LD_VAR 0 4
37513: MINUS
37514: PUSH
37515: LD_INT 0
37517: LESS
37518: IFFALSE 37530
// min_y := 0 else
37520: LD_ADDR_VAR 0 8
37524: PUSH
37525: LD_INT 0
37527: ST_TO_ADDR
37528: GO 37546
// min_y := y - r ;
37530: LD_ADDR_VAR 0 8
37534: PUSH
37535: LD_VAR 0 3
37539: PUSH
37540: LD_VAR 0 4
37544: MINUS
37545: ST_TO_ADDR
// max_x := x + r ;
37546: LD_ADDR_VAR 0 9
37550: PUSH
37551: LD_VAR 0 2
37555: PUSH
37556: LD_VAR 0 4
37560: PLUS
37561: ST_TO_ADDR
// max_y := y + r ;
37562: LD_ADDR_VAR 0 10
37566: PUSH
37567: LD_VAR 0 3
37571: PUSH
37572: LD_VAR 0 4
37576: PLUS
37577: ST_TO_ADDR
// for _x = min_x to max_x do
37578: LD_ADDR_VAR 0 11
37582: PUSH
37583: DOUBLE
37584: LD_VAR 0 7
37588: DEC
37589: ST_TO_ADDR
37590: LD_VAR 0 9
37594: PUSH
37595: FOR_TO
37596: IFFALSE 37713
// for _y = min_y to max_y do
37598: LD_ADDR_VAR 0 12
37602: PUSH
37603: DOUBLE
37604: LD_VAR 0 8
37608: DEC
37609: ST_TO_ADDR
37610: LD_VAR 0 10
37614: PUSH
37615: FOR_TO
37616: IFFALSE 37709
// begin if not ValidHex ( _x , _y ) then
37618: LD_VAR 0 11
37622: PPUSH
37623: LD_VAR 0 12
37627: PPUSH
37628: CALL_OW 488
37632: NOT
37633: IFFALSE 37637
// continue ;
37635: GO 37615
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
37637: LD_VAR 0 11
37641: PPUSH
37642: LD_VAR 0 12
37646: PPUSH
37647: CALL_OW 351
37651: PUSH
37652: LD_VAR 0 11
37656: PPUSH
37657: LD_VAR 0 12
37661: PPUSH
37662: CALL_OW 554
37666: AND
37667: IFFALSE 37707
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
37669: LD_ADDR_VAR 0 13
37673: PUSH
37674: LD_VAR 0 13
37678: PPUSH
37679: LD_VAR 0 13
37683: PUSH
37684: LD_INT 1
37686: PLUS
37687: PPUSH
37688: LD_VAR 0 11
37692: PUSH
37693: LD_VAR 0 12
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PPUSH
37702: CALL_OW 2
37706: ST_TO_ADDR
// end ;
37707: GO 37615
37709: POP
37710: POP
37711: GO 37595
37713: POP
37714: POP
// if not list then
37715: LD_VAR 0 13
37719: NOT
37720: IFFALSE 37724
// exit ;
37722: GO 37795
// for i in list do
37724: LD_ADDR_VAR 0 6
37728: PUSH
37729: LD_VAR 0 13
37733: PUSH
37734: FOR_IN
37735: IFFALSE 37793
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
37737: LD_VAR 0 1
37741: PPUSH
37742: LD_STRING M
37744: PUSH
37745: LD_VAR 0 6
37749: PUSH
37750: LD_INT 1
37752: ARRAY
37753: PUSH
37754: LD_VAR 0 6
37758: PUSH
37759: LD_INT 2
37761: ARRAY
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: LD_INT 0
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: LD_INT 0
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: LIST
37781: LIST
37782: LIST
37783: PUSH
37784: EMPTY
37785: LIST
37786: PPUSH
37787: CALL_OW 447
37791: GO 37734
37793: POP
37794: POP
// end ;
37795: LD_VAR 0 5
37799: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
37800: LD_EXP 90
37804: NOT
37805: IFFALSE 37855
37807: GO 37809
37809: DISABLE
// begin initHack := true ;
37810: LD_ADDR_EXP 90
37814: PUSH
37815: LD_INT 1
37817: ST_TO_ADDR
// hackTanks := [ ] ;
37818: LD_ADDR_EXP 91
37822: PUSH
37823: EMPTY
37824: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
37825: LD_ADDR_EXP 92
37829: PUSH
37830: EMPTY
37831: ST_TO_ADDR
// hackLimit := 3 ;
37832: LD_ADDR_EXP 93
37836: PUSH
37837: LD_INT 3
37839: ST_TO_ADDR
// hackDist := 12 ;
37840: LD_ADDR_EXP 94
37844: PUSH
37845: LD_INT 12
37847: ST_TO_ADDR
// hackCounter := [ ] ;
37848: LD_ADDR_EXP 95
37852: PUSH
37853: EMPTY
37854: ST_TO_ADDR
// end ;
37855: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
37856: LD_EXP 90
37860: PUSH
37861: LD_INT 34
37863: PUSH
37864: LD_INT 99
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PPUSH
37871: CALL_OW 69
37875: AND
37876: IFFALSE 38129
37878: GO 37880
37880: DISABLE
37881: LD_INT 0
37883: PPUSH
37884: PPUSH
// begin enable ;
37885: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
37886: LD_ADDR_VAR 0 1
37890: PUSH
37891: LD_INT 34
37893: PUSH
37894: LD_INT 99
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PPUSH
37901: CALL_OW 69
37905: PUSH
37906: FOR_IN
37907: IFFALSE 38127
// begin if not i in hackTanks then
37909: LD_VAR 0 1
37913: PUSH
37914: LD_EXP 91
37918: IN
37919: NOT
37920: IFFALSE 38003
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
37922: LD_ADDR_EXP 91
37926: PUSH
37927: LD_EXP 91
37931: PPUSH
37932: LD_EXP 91
37936: PUSH
37937: LD_INT 1
37939: PLUS
37940: PPUSH
37941: LD_VAR 0 1
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
37951: LD_ADDR_EXP 92
37955: PUSH
37956: LD_EXP 92
37960: PPUSH
37961: LD_EXP 92
37965: PUSH
37966: LD_INT 1
37968: PLUS
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL_OW 1
37976: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
37977: LD_ADDR_EXP 95
37981: PUSH
37982: LD_EXP 95
37986: PPUSH
37987: LD_EXP 95
37991: PUSH
37992: LD_INT 1
37994: PLUS
37995: PPUSH
37996: EMPTY
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// end ; if not IsOk ( i ) then
38003: LD_VAR 0 1
38007: PPUSH
38008: CALL_OW 302
38012: NOT
38013: IFFALSE 38026
// begin HackUnlinkAll ( i ) ;
38015: LD_VAR 0 1
38019: PPUSH
38020: CALL 38132 0 1
// continue ;
38024: GO 37906
// end ; HackCheckCapturedStatus ( i ) ;
38026: LD_VAR 0 1
38030: PPUSH
38031: CALL 38575 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
38035: LD_ADDR_VAR 0 2
38039: PUSH
38040: LD_INT 81
38042: PUSH
38043: LD_VAR 0 1
38047: PPUSH
38048: CALL_OW 255
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 33
38059: PUSH
38060: LD_INT 3
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 91
38069: PUSH
38070: LD_VAR 0 1
38074: PUSH
38075: LD_EXP 94
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 50
38087: PUSH
38088: EMPTY
38089: LIST
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: PPUSH
38097: CALL_OW 69
38101: ST_TO_ADDR
// if not tmp then
38102: LD_VAR 0 2
38106: NOT
38107: IFFALSE 38111
// continue ;
38109: GO 37906
// HackLink ( i , tmp ) ;
38111: LD_VAR 0 1
38115: PPUSH
38116: LD_VAR 0 2
38120: PPUSH
38121: CALL 38268 0 2
// end ;
38125: GO 37906
38127: POP
38128: POP
// end ;
38129: PPOPN 2
38131: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
38132: LD_INT 0
38134: PPUSH
38135: PPUSH
38136: PPUSH
// if not hack in hackTanks then
38137: LD_VAR 0 1
38141: PUSH
38142: LD_EXP 91
38146: IN
38147: NOT
38148: IFFALSE 38152
// exit ;
38150: GO 38263
// index := GetElementIndex ( hackTanks , hack ) ;
38152: LD_ADDR_VAR 0 4
38156: PUSH
38157: LD_EXP 91
38161: PPUSH
38162: LD_VAR 0 1
38166: PPUSH
38167: CALL 13809 0 2
38171: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
38172: LD_EXP 92
38176: PUSH
38177: LD_VAR 0 4
38181: ARRAY
38182: IFFALSE 38263
// begin for i in hackTanksCaptured [ index ] do
38184: LD_ADDR_VAR 0 3
38188: PUSH
38189: LD_EXP 92
38193: PUSH
38194: LD_VAR 0 4
38198: ARRAY
38199: PUSH
38200: FOR_IN
38201: IFFALSE 38227
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
38203: LD_VAR 0 3
38207: PUSH
38208: LD_INT 1
38210: ARRAY
38211: PPUSH
38212: LD_VAR 0 3
38216: PUSH
38217: LD_INT 2
38219: ARRAY
38220: PPUSH
38221: CALL_OW 235
38225: GO 38200
38227: POP
38228: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
38229: LD_ADDR_EXP 92
38233: PUSH
38234: LD_EXP 92
38238: PPUSH
38239: LD_VAR 0 4
38243: PPUSH
38244: EMPTY
38245: PPUSH
38246: CALL_OW 1
38250: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
38251: LD_VAR 0 1
38255: PPUSH
38256: LD_INT 0
38258: PPUSH
38259: CALL_OW 505
// end ; end ;
38263: LD_VAR 0 2
38267: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
38268: LD_INT 0
38270: PPUSH
38271: PPUSH
38272: PPUSH
// if not hack in hackTanks or not vehicles then
38273: LD_VAR 0 1
38277: PUSH
38278: LD_EXP 91
38282: IN
38283: NOT
38284: PUSH
38285: LD_VAR 0 2
38289: NOT
38290: OR
38291: IFFALSE 38295
// exit ;
38293: GO 38570
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
38295: LD_ADDR_VAR 0 2
38299: PUSH
38300: LD_VAR 0 1
38304: PPUSH
38305: LD_VAR 0 2
38309: PPUSH
38310: LD_INT 1
38312: PPUSH
38313: LD_INT 1
38315: PPUSH
38316: CALL 14459 0 4
38320: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
38321: LD_ADDR_VAR 0 5
38325: PUSH
38326: LD_EXP 91
38330: PPUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: CALL 13809 0 2
38340: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
38341: LD_EXP 92
38345: PUSH
38346: LD_VAR 0 5
38350: ARRAY
38351: PUSH
38352: LD_EXP 93
38356: LESS
38357: IFFALSE 38546
// begin for i := 1 to vehicles do
38359: LD_ADDR_VAR 0 4
38363: PUSH
38364: DOUBLE
38365: LD_INT 1
38367: DEC
38368: ST_TO_ADDR
38369: LD_VAR 0 2
38373: PUSH
38374: FOR_TO
38375: IFFALSE 38544
// begin if hackTanksCaptured [ index ] = hackLimit then
38377: LD_EXP 92
38381: PUSH
38382: LD_VAR 0 5
38386: ARRAY
38387: PUSH
38388: LD_EXP 93
38392: EQUAL
38393: IFFALSE 38397
// break ;
38395: GO 38544
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
38397: LD_ADDR_EXP 95
38401: PUSH
38402: LD_EXP 95
38406: PPUSH
38407: LD_VAR 0 5
38411: PPUSH
38412: LD_EXP 95
38416: PUSH
38417: LD_VAR 0 5
38421: ARRAY
38422: PUSH
38423: LD_INT 1
38425: PLUS
38426: PPUSH
38427: CALL_OW 1
38431: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
38432: LD_ADDR_EXP 92
38436: PUSH
38437: LD_EXP 92
38441: PPUSH
38442: LD_VAR 0 5
38446: PUSH
38447: LD_EXP 92
38451: PUSH
38452: LD_VAR 0 5
38456: ARRAY
38457: PUSH
38458: LD_INT 1
38460: PLUS
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PPUSH
38466: LD_VAR 0 2
38470: PUSH
38471: LD_VAR 0 4
38475: ARRAY
38476: PUSH
38477: LD_VAR 0 2
38481: PUSH
38482: LD_VAR 0 4
38486: ARRAY
38487: PPUSH
38488: CALL_OW 255
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PPUSH
38497: CALL 14024 0 3
38501: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
38502: LD_VAR 0 2
38506: PUSH
38507: LD_VAR 0 4
38511: ARRAY
38512: PPUSH
38513: LD_VAR 0 1
38517: PPUSH
38518: CALL_OW 255
38522: PPUSH
38523: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
38527: LD_VAR 0 2
38531: PUSH
38532: LD_VAR 0 4
38536: ARRAY
38537: PPUSH
38538: CALL_OW 141
// end ;
38542: GO 38374
38544: POP
38545: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
38546: LD_VAR 0 1
38550: PPUSH
38551: LD_EXP 92
38555: PUSH
38556: LD_VAR 0 5
38560: ARRAY
38561: PUSH
38562: LD_INT 0
38564: PLUS
38565: PPUSH
38566: CALL_OW 505
// end ;
38570: LD_VAR 0 3
38574: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
38575: LD_INT 0
38577: PPUSH
38578: PPUSH
38579: PPUSH
38580: PPUSH
// if not hack in hackTanks then
38581: LD_VAR 0 1
38585: PUSH
38586: LD_EXP 91
38590: IN
38591: NOT
38592: IFFALSE 38596
// exit ;
38594: GO 38836
// index := GetElementIndex ( hackTanks , hack ) ;
38596: LD_ADDR_VAR 0 4
38600: PUSH
38601: LD_EXP 91
38605: PPUSH
38606: LD_VAR 0 1
38610: PPUSH
38611: CALL 13809 0 2
38615: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
38616: LD_ADDR_VAR 0 3
38620: PUSH
38621: DOUBLE
38622: LD_EXP 92
38626: PUSH
38627: LD_VAR 0 4
38631: ARRAY
38632: INC
38633: ST_TO_ADDR
38634: LD_INT 1
38636: PUSH
38637: FOR_DOWNTO
38638: IFFALSE 38810
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
38640: LD_ADDR_VAR 0 5
38644: PUSH
38645: LD_EXP 92
38649: PUSH
38650: LD_VAR 0 4
38654: ARRAY
38655: PUSH
38656: LD_VAR 0 3
38660: ARRAY
38661: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
38662: LD_VAR 0 5
38666: PUSH
38667: LD_INT 1
38669: ARRAY
38670: PPUSH
38671: CALL_OW 302
38675: NOT
38676: PUSH
38677: LD_VAR 0 5
38681: PUSH
38682: LD_INT 1
38684: ARRAY
38685: PPUSH
38686: CALL_OW 255
38690: PUSH
38691: LD_VAR 0 1
38695: PPUSH
38696: CALL_OW 255
38700: NONEQUAL
38701: OR
38702: IFFALSE 38808
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
38704: LD_VAR 0 5
38708: PUSH
38709: LD_INT 1
38711: ARRAY
38712: PPUSH
38713: CALL_OW 305
38717: PUSH
38718: LD_VAR 0 5
38722: PUSH
38723: LD_INT 1
38725: ARRAY
38726: PPUSH
38727: CALL_OW 255
38731: PUSH
38732: LD_VAR 0 1
38736: PPUSH
38737: CALL_OW 255
38741: EQUAL
38742: AND
38743: IFFALSE 38767
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
38745: LD_VAR 0 5
38749: PUSH
38750: LD_INT 1
38752: ARRAY
38753: PPUSH
38754: LD_VAR 0 5
38758: PUSH
38759: LD_INT 2
38761: ARRAY
38762: PPUSH
38763: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
38767: LD_ADDR_EXP 92
38771: PUSH
38772: LD_EXP 92
38776: PPUSH
38777: LD_VAR 0 4
38781: PPUSH
38782: LD_EXP 92
38786: PUSH
38787: LD_VAR 0 4
38791: ARRAY
38792: PPUSH
38793: LD_VAR 0 3
38797: PPUSH
38798: CALL_OW 3
38802: PPUSH
38803: CALL_OW 1
38807: ST_TO_ADDR
// end ; end ;
38808: GO 38637
38810: POP
38811: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
38812: LD_VAR 0 1
38816: PPUSH
38817: LD_EXP 92
38821: PUSH
38822: LD_VAR 0 4
38826: ARRAY
38827: PUSH
38828: LD_INT 0
38830: PLUS
38831: PPUSH
38832: CALL_OW 505
// end ;
38836: LD_VAR 0 2
38840: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
38841: LD_INT 0
38843: PPUSH
38844: PPUSH
38845: PPUSH
38846: PPUSH
// if not hack in hackTanks then
38847: LD_VAR 0 1
38851: PUSH
38852: LD_EXP 91
38856: IN
38857: NOT
38858: IFFALSE 38862
// exit ;
38860: GO 38947
// index := GetElementIndex ( hackTanks , hack ) ;
38862: LD_ADDR_VAR 0 5
38866: PUSH
38867: LD_EXP 91
38871: PPUSH
38872: LD_VAR 0 1
38876: PPUSH
38877: CALL 13809 0 2
38881: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
38882: LD_ADDR_VAR 0 4
38886: PUSH
38887: DOUBLE
38888: LD_INT 1
38890: DEC
38891: ST_TO_ADDR
38892: LD_EXP 92
38896: PUSH
38897: LD_VAR 0 5
38901: ARRAY
38902: PUSH
38903: FOR_TO
38904: IFFALSE 38945
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
38906: LD_EXP 92
38910: PUSH
38911: LD_VAR 0 5
38915: ARRAY
38916: PUSH
38917: LD_VAR 0 4
38921: ARRAY
38922: PUSH
38923: LD_INT 1
38925: ARRAY
38926: PUSH
38927: LD_VAR 0 2
38931: EQUAL
38932: IFFALSE 38943
// KillUnit ( vehicle ) ;
38934: LD_VAR 0 2
38938: PPUSH
38939: CALL_OW 66
38943: GO 38903
38945: POP
38946: POP
// end ;
38947: LD_VAR 0 3
38951: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
38952: LD_EXP 96
38956: NOT
38957: IFFALSE 38992
38959: GO 38961
38961: DISABLE
// begin initMiner := true ;
38962: LD_ADDR_EXP 96
38966: PUSH
38967: LD_INT 1
38969: ST_TO_ADDR
// minersList := [ ] ;
38970: LD_ADDR_EXP 97
38974: PUSH
38975: EMPTY
38976: ST_TO_ADDR
// minerMinesList := [ ] ;
38977: LD_ADDR_EXP 98
38981: PUSH
38982: EMPTY
38983: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
38984: LD_ADDR_EXP 99
38988: PUSH
38989: LD_INT 5
38991: ST_TO_ADDR
// end ;
38992: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
38993: LD_EXP 96
38997: PUSH
38998: LD_INT 34
39000: PUSH
39001: LD_INT 81
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PPUSH
39008: CALL_OW 69
39012: AND
39013: IFFALSE 39474
39015: GO 39017
39017: DISABLE
39018: LD_INT 0
39020: PPUSH
39021: PPUSH
39022: PPUSH
39023: PPUSH
// begin enable ;
39024: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
39025: LD_ADDR_VAR 0 1
39029: PUSH
39030: LD_INT 34
39032: PUSH
39033: LD_INT 81
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PPUSH
39040: CALL_OW 69
39044: PUSH
39045: FOR_IN
39046: IFFALSE 39118
// begin if not i in minersList then
39048: LD_VAR 0 1
39052: PUSH
39053: LD_EXP 97
39057: IN
39058: NOT
39059: IFFALSE 39116
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
39061: LD_ADDR_EXP 97
39065: PUSH
39066: LD_EXP 97
39070: PPUSH
39071: LD_EXP 97
39075: PUSH
39076: LD_INT 1
39078: PLUS
39079: PPUSH
39080: LD_VAR 0 1
39084: PPUSH
39085: CALL_OW 1
39089: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
39090: LD_ADDR_EXP 98
39094: PUSH
39095: LD_EXP 98
39099: PPUSH
39100: LD_EXP 98
39104: PUSH
39105: LD_INT 1
39107: PLUS
39108: PPUSH
39109: EMPTY
39110: PPUSH
39111: CALL_OW 1
39115: ST_TO_ADDR
// end end ;
39116: GO 39045
39118: POP
39119: POP
// for i := minerMinesList downto 1 do
39120: LD_ADDR_VAR 0 1
39124: PUSH
39125: DOUBLE
39126: LD_EXP 98
39130: INC
39131: ST_TO_ADDR
39132: LD_INT 1
39134: PUSH
39135: FOR_DOWNTO
39136: IFFALSE 39472
// begin if IsLive ( minersList [ i ] ) then
39138: LD_EXP 97
39142: PUSH
39143: LD_VAR 0 1
39147: ARRAY
39148: PPUSH
39149: CALL_OW 300
39153: IFFALSE 39181
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
39155: LD_EXP 97
39159: PUSH
39160: LD_VAR 0 1
39164: ARRAY
39165: PPUSH
39166: LD_EXP 98
39170: PUSH
39171: LD_VAR 0 1
39175: ARRAY
39176: PPUSH
39177: CALL_OW 505
// if not minerMinesList [ i ] then
39181: LD_EXP 98
39185: PUSH
39186: LD_VAR 0 1
39190: ARRAY
39191: NOT
39192: IFFALSE 39196
// continue ;
39194: GO 39135
// for j := minerMinesList [ i ] downto 1 do
39196: LD_ADDR_VAR 0 2
39200: PUSH
39201: DOUBLE
39202: LD_EXP 98
39206: PUSH
39207: LD_VAR 0 1
39211: ARRAY
39212: INC
39213: ST_TO_ADDR
39214: LD_INT 1
39216: PUSH
39217: FOR_DOWNTO
39218: IFFALSE 39468
// begin side := GetSide ( minersList [ i ] ) ;
39220: LD_ADDR_VAR 0 3
39224: PUSH
39225: LD_EXP 97
39229: PUSH
39230: LD_VAR 0 1
39234: ARRAY
39235: PPUSH
39236: CALL_OW 255
39240: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
39241: LD_ADDR_VAR 0 4
39245: PUSH
39246: LD_EXP 98
39250: PUSH
39251: LD_VAR 0 1
39255: ARRAY
39256: PUSH
39257: LD_VAR 0 2
39261: ARRAY
39262: PUSH
39263: LD_INT 1
39265: ARRAY
39266: PPUSH
39267: LD_EXP 98
39271: PUSH
39272: LD_VAR 0 1
39276: ARRAY
39277: PUSH
39278: LD_VAR 0 2
39282: ARRAY
39283: PUSH
39284: LD_INT 2
39286: ARRAY
39287: PPUSH
39288: CALL_OW 428
39292: ST_TO_ADDR
// if not tmp then
39293: LD_VAR 0 4
39297: NOT
39298: IFFALSE 39302
// continue ;
39300: GO 39217
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
39302: LD_VAR 0 4
39306: PUSH
39307: LD_INT 81
39309: PUSH
39310: LD_VAR 0 3
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PPUSH
39319: CALL_OW 69
39323: IN
39324: PUSH
39325: LD_EXP 98
39329: PUSH
39330: LD_VAR 0 1
39334: ARRAY
39335: PUSH
39336: LD_VAR 0 2
39340: ARRAY
39341: PUSH
39342: LD_INT 1
39344: ARRAY
39345: PPUSH
39346: LD_EXP 98
39350: PUSH
39351: LD_VAR 0 1
39355: ARRAY
39356: PUSH
39357: LD_VAR 0 2
39361: ARRAY
39362: PUSH
39363: LD_INT 2
39365: ARRAY
39366: PPUSH
39367: CALL_OW 458
39371: AND
39372: IFFALSE 39466
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
39374: LD_EXP 98
39378: PUSH
39379: LD_VAR 0 1
39383: ARRAY
39384: PUSH
39385: LD_VAR 0 2
39389: ARRAY
39390: PUSH
39391: LD_INT 1
39393: ARRAY
39394: PPUSH
39395: LD_EXP 98
39399: PUSH
39400: LD_VAR 0 1
39404: ARRAY
39405: PUSH
39406: LD_VAR 0 2
39410: ARRAY
39411: PUSH
39412: LD_INT 2
39414: ARRAY
39415: PPUSH
39416: LD_VAR 0 3
39420: PPUSH
39421: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
39425: LD_ADDR_EXP 98
39429: PUSH
39430: LD_EXP 98
39434: PPUSH
39435: LD_VAR 0 1
39439: PPUSH
39440: LD_EXP 98
39444: PUSH
39445: LD_VAR 0 1
39449: ARRAY
39450: PPUSH
39451: LD_VAR 0 2
39455: PPUSH
39456: CALL_OW 3
39460: PPUSH
39461: CALL_OW 1
39465: ST_TO_ADDR
// end ; end ;
39466: GO 39217
39468: POP
39469: POP
// end ;
39470: GO 39135
39472: POP
39473: POP
// end ;
39474: PPOPN 4
39476: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
39477: LD_INT 0
39479: PPUSH
39480: PPUSH
// result := false ;
39481: LD_ADDR_VAR 0 4
39485: PUSH
39486: LD_INT 0
39488: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
39489: LD_VAR 0 1
39493: PPUSH
39494: CALL_OW 264
39498: PUSH
39499: LD_INT 81
39501: EQUAL
39502: NOT
39503: IFFALSE 39507
// exit ;
39505: GO 39747
// index := GetElementIndex ( minersList , unit ) ;
39507: LD_ADDR_VAR 0 5
39511: PUSH
39512: LD_EXP 97
39516: PPUSH
39517: LD_VAR 0 1
39521: PPUSH
39522: CALL 13809 0 2
39526: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
39527: LD_EXP 98
39531: PUSH
39532: LD_VAR 0 5
39536: ARRAY
39537: PUSH
39538: LD_EXP 99
39542: GREATEREQUAL
39543: IFFALSE 39547
// exit ;
39545: GO 39747
// ComMoveXY ( unit , x , y ) ;
39547: LD_VAR 0 1
39551: PPUSH
39552: LD_VAR 0 2
39556: PPUSH
39557: LD_VAR 0 3
39561: PPUSH
39562: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
39566: LD_INT 35
39568: PPUSH
39569: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
39573: LD_VAR 0 1
39577: PPUSH
39578: LD_VAR 0 2
39582: PPUSH
39583: LD_VAR 0 3
39587: PPUSH
39588: NOP4
39592: NOT
39593: PUSH
39594: LD_VAR 0 1
39598: PPUSH
39599: CALL_OW 314
39603: AND
39604: IFFALSE 39608
// exit ;
39606: GO 39747
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
39608: LD_VAR 0 2
39612: PPUSH
39613: LD_VAR 0 3
39617: PPUSH
39618: CALL_OW 428
39622: PUSH
39623: LD_VAR 0 1
39627: EQUAL
39628: PUSH
39629: LD_VAR 0 1
39633: PPUSH
39634: CALL_OW 314
39638: NOT
39639: AND
39640: IFFALSE 39566
// PlaySoundXY ( x , y , PlantMine ) ;
39642: LD_VAR 0 2
39646: PPUSH
39647: LD_VAR 0 3
39651: PPUSH
39652: LD_STRING PlantMine
39654: PPUSH
39655: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
39659: LD_VAR 0 2
39663: PPUSH
39664: LD_VAR 0 3
39668: PPUSH
39669: LD_VAR 0 1
39673: PPUSH
39674: CALL_OW 255
39678: PPUSH
39679: LD_INT 0
39681: PPUSH
39682: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
39686: LD_ADDR_EXP 98
39690: PUSH
39691: LD_EXP 98
39695: PPUSH
39696: LD_VAR 0 5
39700: PUSH
39701: LD_EXP 98
39705: PUSH
39706: LD_VAR 0 5
39710: ARRAY
39711: PUSH
39712: LD_INT 1
39714: PLUS
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PPUSH
39720: LD_VAR 0 2
39724: PUSH
39725: LD_VAR 0 3
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PPUSH
39734: CALL 14024 0 3
39738: ST_TO_ADDR
// result := true ;
39739: LD_ADDR_VAR 0 4
39743: PUSH
39744: LD_INT 1
39746: ST_TO_ADDR
// end ;
39747: LD_VAR 0 4
39751: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
39752: LD_INT 0
39754: PPUSH
39755: PPUSH
39756: PPUSH
// if not unit in minersList then
39757: LD_VAR 0 1
39761: PUSH
39762: LD_EXP 97
39766: IN
39767: NOT
39768: IFFALSE 39772
// exit ;
39770: GO 40164
// index := GetElementIndex ( minersList , unit ) ;
39772: LD_ADDR_VAR 0 6
39776: PUSH
39777: LD_EXP 97
39781: PPUSH
39782: LD_VAR 0 1
39786: PPUSH
39787: CALL 13809 0 2
39791: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
39792: LD_ADDR_VAR 0 5
39796: PUSH
39797: DOUBLE
39798: LD_EXP 98
39802: PUSH
39803: LD_VAR 0 6
39807: ARRAY
39808: INC
39809: ST_TO_ADDR
39810: LD_INT 1
39812: PUSH
39813: FOR_DOWNTO
39814: IFFALSE 39975
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
39816: LD_EXP 98
39820: PUSH
39821: LD_VAR 0 6
39825: ARRAY
39826: PUSH
39827: LD_VAR 0 5
39831: ARRAY
39832: PUSH
39833: LD_INT 1
39835: ARRAY
39836: PUSH
39837: LD_VAR 0 2
39841: EQUAL
39842: PUSH
39843: LD_EXP 98
39847: PUSH
39848: LD_VAR 0 6
39852: ARRAY
39853: PUSH
39854: LD_VAR 0 5
39858: ARRAY
39859: PUSH
39860: LD_INT 2
39862: ARRAY
39863: PUSH
39864: LD_VAR 0 3
39868: EQUAL
39869: AND
39870: IFFALSE 39973
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
39872: LD_EXP 98
39876: PUSH
39877: LD_VAR 0 6
39881: ARRAY
39882: PUSH
39883: LD_VAR 0 5
39887: ARRAY
39888: PUSH
39889: LD_INT 1
39891: ARRAY
39892: PPUSH
39893: LD_EXP 98
39897: PUSH
39898: LD_VAR 0 6
39902: ARRAY
39903: PUSH
39904: LD_VAR 0 5
39908: ARRAY
39909: PUSH
39910: LD_INT 2
39912: ARRAY
39913: PPUSH
39914: LD_VAR 0 1
39918: PPUSH
39919: CALL_OW 255
39923: PPUSH
39924: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
39928: LD_ADDR_EXP 98
39932: PUSH
39933: LD_EXP 98
39937: PPUSH
39938: LD_VAR 0 6
39942: PPUSH
39943: LD_EXP 98
39947: PUSH
39948: LD_VAR 0 6
39952: ARRAY
39953: PPUSH
39954: LD_VAR 0 5
39958: PPUSH
39959: CALL_OW 3
39963: PPUSH
39964: CALL_OW 1
39968: ST_TO_ADDR
// exit ;
39969: POP
39970: POP
39971: GO 40164
// end ; end ;
39973: GO 39813
39975: POP
39976: POP
// for i := minerMinesList [ index ] downto 1 do
39977: LD_ADDR_VAR 0 5
39981: PUSH
39982: DOUBLE
39983: LD_EXP 98
39987: PUSH
39988: LD_VAR 0 6
39992: ARRAY
39993: INC
39994: ST_TO_ADDR
39995: LD_INT 1
39997: PUSH
39998: FOR_DOWNTO
39999: IFFALSE 40162
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
40001: LD_EXP 98
40005: PUSH
40006: LD_VAR 0 6
40010: ARRAY
40011: PUSH
40012: LD_VAR 0 5
40016: ARRAY
40017: PUSH
40018: LD_INT 1
40020: ARRAY
40021: PPUSH
40022: LD_EXP 98
40026: PUSH
40027: LD_VAR 0 6
40031: ARRAY
40032: PUSH
40033: LD_VAR 0 5
40037: ARRAY
40038: PUSH
40039: LD_INT 2
40041: ARRAY
40042: PPUSH
40043: LD_VAR 0 2
40047: PPUSH
40048: LD_VAR 0 3
40052: PPUSH
40053: CALL_OW 298
40057: PUSH
40058: LD_INT 6
40060: LESS
40061: IFFALSE 40160
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
40063: LD_EXP 98
40067: PUSH
40068: LD_VAR 0 6
40072: ARRAY
40073: PUSH
40074: LD_VAR 0 5
40078: ARRAY
40079: PUSH
40080: LD_INT 1
40082: ARRAY
40083: PPUSH
40084: LD_EXP 98
40088: PUSH
40089: LD_VAR 0 6
40093: ARRAY
40094: PUSH
40095: LD_VAR 0 5
40099: ARRAY
40100: PUSH
40101: LD_INT 2
40103: ARRAY
40104: PPUSH
40105: LD_VAR 0 1
40109: PPUSH
40110: CALL_OW 255
40114: PPUSH
40115: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
40119: LD_ADDR_EXP 98
40123: PUSH
40124: LD_EXP 98
40128: PPUSH
40129: LD_VAR 0 6
40133: PPUSH
40134: LD_EXP 98
40138: PUSH
40139: LD_VAR 0 6
40143: ARRAY
40144: PPUSH
40145: LD_VAR 0 5
40149: PPUSH
40150: CALL_OW 3
40154: PPUSH
40155: CALL_OW 1
40159: ST_TO_ADDR
// end ; end ;
40160: GO 39998
40162: POP
40163: POP
// end ;
40164: LD_VAR 0 4
40168: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
40169: LD_INT 0
40171: PPUSH
40172: PPUSH
40173: PPUSH
40174: PPUSH
40175: PPUSH
40176: PPUSH
40177: PPUSH
40178: PPUSH
40179: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
40180: LD_VAR 0 1
40184: PPUSH
40185: CALL_OW 264
40189: PUSH
40190: LD_INT 81
40192: EQUAL
40193: NOT
40194: PUSH
40195: LD_VAR 0 1
40199: PUSH
40200: LD_EXP 97
40204: IN
40205: NOT
40206: OR
40207: IFFALSE 40211
// exit ;
40209: GO 40533
// index := GetElementIndex ( minersList , unit ) ;
40211: LD_ADDR_VAR 0 6
40215: PUSH
40216: LD_EXP 97
40220: PPUSH
40221: LD_VAR 0 1
40225: PPUSH
40226: CALL 13809 0 2
40230: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
40231: LD_ADDR_VAR 0 8
40235: PUSH
40236: LD_EXP 99
40240: PUSH
40241: LD_EXP 98
40245: PUSH
40246: LD_VAR 0 6
40250: ARRAY
40251: MINUS
40252: ST_TO_ADDR
// if not minesFreeAmount then
40253: LD_VAR 0 8
40257: NOT
40258: IFFALSE 40262
// exit ;
40260: GO 40533
// tmp := [ ] ;
40262: LD_ADDR_VAR 0 7
40266: PUSH
40267: EMPTY
40268: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
40269: LD_ADDR_VAR 0 5
40273: PUSH
40274: DOUBLE
40275: LD_INT 1
40277: DEC
40278: ST_TO_ADDR
40279: LD_VAR 0 8
40283: PUSH
40284: FOR_TO
40285: IFFALSE 40480
// begin _d := rand ( 0 , 5 ) ;
40287: LD_ADDR_VAR 0 11
40291: PUSH
40292: LD_INT 0
40294: PPUSH
40295: LD_INT 5
40297: PPUSH
40298: CALL_OW 12
40302: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
40303: LD_ADDR_VAR 0 12
40307: PUSH
40308: LD_INT 2
40310: PPUSH
40311: LD_INT 6
40313: PPUSH
40314: CALL_OW 12
40318: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
40319: LD_ADDR_VAR 0 9
40323: PUSH
40324: LD_VAR 0 2
40328: PPUSH
40329: LD_VAR 0 11
40333: PPUSH
40334: LD_VAR 0 12
40338: PPUSH
40339: CALL_OW 272
40343: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
40344: LD_ADDR_VAR 0 10
40348: PUSH
40349: LD_VAR 0 3
40353: PPUSH
40354: LD_VAR 0 11
40358: PPUSH
40359: LD_VAR 0 12
40363: PPUSH
40364: CALL_OW 273
40368: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
40369: LD_VAR 0 9
40373: PPUSH
40374: LD_VAR 0 10
40378: PPUSH
40379: CALL_OW 488
40383: PUSH
40384: LD_VAR 0 9
40388: PUSH
40389: LD_VAR 0 10
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_VAR 0 7
40402: IN
40403: NOT
40404: AND
40405: PUSH
40406: LD_VAR 0 9
40410: PPUSH
40411: LD_VAR 0 10
40415: PPUSH
40416: CALL_OW 458
40420: NOT
40421: AND
40422: IFFALSE 40464
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
40424: LD_ADDR_VAR 0 7
40428: PUSH
40429: LD_VAR 0 7
40433: PPUSH
40434: LD_VAR 0 7
40438: PUSH
40439: LD_INT 1
40441: PLUS
40442: PPUSH
40443: LD_VAR 0 9
40447: PUSH
40448: LD_VAR 0 10
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PPUSH
40457: CALL_OW 1
40461: ST_TO_ADDR
40462: GO 40478
// i := i - 1 ;
40464: LD_ADDR_VAR 0 5
40468: PUSH
40469: LD_VAR 0 5
40473: PUSH
40474: LD_INT 1
40476: MINUS
40477: ST_TO_ADDR
// end ;
40478: GO 40284
40480: POP
40481: POP
// for i in tmp do
40482: LD_ADDR_VAR 0 5
40486: PUSH
40487: LD_VAR 0 7
40491: PUSH
40492: FOR_IN
40493: IFFALSE 40531
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
40495: LD_VAR 0 1
40499: PPUSH
40500: LD_VAR 0 5
40504: PUSH
40505: LD_INT 1
40507: ARRAY
40508: PPUSH
40509: LD_VAR 0 5
40513: PUSH
40514: LD_INT 2
40516: ARRAY
40517: PPUSH
40518: CALL 39477 0 3
40522: NOT
40523: IFFALSE 40529
// exit ;
40525: POP
40526: POP
40527: GO 40533
40529: GO 40492
40531: POP
40532: POP
// end ;
40533: LD_VAR 0 4
40537: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
40538: LD_INT 0
40540: PPUSH
40541: PPUSH
40542: PPUSH
40543: PPUSH
40544: PPUSH
40545: PPUSH
40546: PPUSH
// if not GetClass ( unit ) = class_sniper then
40547: LD_VAR 0 1
40551: PPUSH
40552: CALL_OW 257
40556: PUSH
40557: LD_INT 5
40559: EQUAL
40560: NOT
40561: IFFALSE 40565
// exit ;
40563: GO 40953
// dist := 8 ;
40565: LD_ADDR_VAR 0 5
40569: PUSH
40570: LD_INT 8
40572: ST_TO_ADDR
// viewRange := 12 ;
40573: LD_ADDR_VAR 0 7
40577: PUSH
40578: LD_INT 12
40580: ST_TO_ADDR
// side := GetSide ( unit ) ;
40581: LD_ADDR_VAR 0 6
40585: PUSH
40586: LD_VAR 0 1
40590: PPUSH
40591: CALL_OW 255
40595: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
40596: LD_INT 61
40598: PPUSH
40599: LD_VAR 0 6
40603: PPUSH
40604: CALL_OW 321
40608: PUSH
40609: LD_INT 2
40611: EQUAL
40612: IFFALSE 40622
// viewRange := 16 ;
40614: LD_ADDR_VAR 0 7
40618: PUSH
40619: LD_INT 16
40621: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
40622: LD_VAR 0 1
40626: PPUSH
40627: LD_VAR 0 2
40631: PPUSH
40632: LD_VAR 0 3
40636: PPUSH
40637: CALL_OW 297
40641: PUSH
40642: LD_VAR 0 5
40646: GREATER
40647: IFFALSE 40726
// begin ComMoveXY ( unit , x , y ) ;
40649: LD_VAR 0 1
40653: PPUSH
40654: LD_VAR 0 2
40658: PPUSH
40659: LD_VAR 0 3
40663: PPUSH
40664: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
40668: LD_INT 35
40670: PPUSH
40671: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
40675: LD_VAR 0 1
40679: PPUSH
40680: LD_VAR 0 2
40684: PPUSH
40685: LD_VAR 0 3
40689: PPUSH
40690: NOP4
40694: NOT
40695: IFFALSE 40699
// exit ;
40697: GO 40953
// until GetDistUnitXY ( unit , x , y ) < dist ;
40699: LD_VAR 0 1
40703: PPUSH
40704: LD_VAR 0 2
40708: PPUSH
40709: LD_VAR 0 3
40713: PPUSH
40714: CALL_OW 297
40718: PUSH
40719: LD_VAR 0 5
40723: LESS
40724: IFFALSE 40668
// end ; ComTurnXY ( unit , x , y ) ;
40726: LD_VAR 0 1
40730: PPUSH
40731: LD_VAR 0 2
40735: PPUSH
40736: LD_VAR 0 3
40740: PPUSH
40741: CALL_OW 118
// wait ( 5 ) ;
40745: LD_INT 5
40747: PPUSH
40748: CALL_OW 67
// _d := GetDir ( unit ) ;
40752: LD_ADDR_VAR 0 10
40756: PUSH
40757: LD_VAR 0 1
40761: PPUSH
40762: CALL_OW 254
40766: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
40767: LD_ADDR_VAR 0 8
40771: PUSH
40772: LD_VAR 0 1
40776: PPUSH
40777: CALL_OW 250
40781: PPUSH
40782: LD_VAR 0 10
40786: PPUSH
40787: LD_VAR 0 5
40791: PPUSH
40792: CALL_OW 272
40796: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
40797: LD_ADDR_VAR 0 9
40801: PUSH
40802: LD_VAR 0 1
40806: PPUSH
40807: CALL_OW 251
40811: PPUSH
40812: LD_VAR 0 10
40816: PPUSH
40817: LD_VAR 0 5
40821: PPUSH
40822: CALL_OW 273
40826: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
40827: LD_VAR 0 8
40831: PPUSH
40832: LD_VAR 0 9
40836: PPUSH
40837: CALL_OW 488
40841: NOT
40842: IFFALSE 40846
// exit ;
40844: GO 40953
// ComAnimCustom ( unit , 1 ) ;
40846: LD_VAR 0 1
40850: PPUSH
40851: LD_INT 1
40853: PPUSH
40854: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
40858: LD_VAR 0 8
40862: PPUSH
40863: LD_VAR 0 9
40867: PPUSH
40868: LD_VAR 0 6
40872: PPUSH
40873: LD_VAR 0 7
40877: PPUSH
40878: CALL_OW 330
// repeat wait ( 1 ) ;
40882: LD_INT 1
40884: PPUSH
40885: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
40889: LD_VAR 0 1
40893: PPUSH
40894: CALL_OW 316
40898: PUSH
40899: LD_VAR 0 1
40903: PPUSH
40904: CALL_OW 314
40908: OR
40909: PUSH
40910: LD_VAR 0 1
40914: PPUSH
40915: CALL_OW 302
40919: NOT
40920: OR
40921: PUSH
40922: LD_VAR 0 1
40926: PPUSH
40927: CALL_OW 301
40931: OR
40932: IFFALSE 40882
// RemoveSeeing ( _x , _y , side ) ;
40934: LD_VAR 0 8
40938: PPUSH
40939: LD_VAR 0 9
40943: PPUSH
40944: LD_VAR 0 6
40948: PPUSH
40949: CALL_OW 331
// end ; end_of_file
40953: LD_VAR 0 4
40957: RET
