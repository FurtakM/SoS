// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3634 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 304
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := [ [ ] ] ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: EMPTY
 186: PUSH
 187: EMPTY
 188: LIST
 189: ST_TO_ADDR
// for i in mp_teams do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: LD_OWVAR 12
 199: PUSH
 200: FOR_IN
 201: IFFALSE 242
// Teams := Replace ( Teams , 1 , Teams [ 1 ] union i [ 1 ] ) ;
 203: LD_ADDR_EXP 5
 207: PUSH
 208: LD_EXP 5
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_EXP 5
 220: PUSH
 221: LD_INT 1
 223: ARRAY
 224: PUSH
 225: LD_VAR 0 2
 229: PUSH
 230: LD_INT 1
 232: ARRAY
 233: UNION
 234: PPUSH
 235: CALL_OW 1
 239: ST_TO_ADDR
 240: GO 200
 242: POP
 243: POP
// for i = 0 to 6 do
 244: LD_ADDR_VAR 0 2
 248: PUSH
 249: DOUBLE
 250: LD_INT 0
 252: DEC
 253: ST_TO_ADDR
 254: LD_INT 6
 256: PUSH
 257: FOR_TO
 258: IFFALSE 300
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 260: LD_ADDR_EXP 16
 264: PUSH
 265: LD_EXP 16
 269: PPUSH
 270: LD_EXP 16
 274: PUSH
 275: LD_INT 1
 277: PLUS
 278: PPUSH
 279: LD_VAR 0 2
 283: PPUSH
 284: CALL_OW 426
 288: PUSH
 289: LD_INT 1
 291: PLUS
 292: PPUSH
 293: CALL_OW 2
 297: ST_TO_ADDR
 298: GO 257
 300: POP
 301: POP
// end else
 302: GO 459
// begin Game_Type := 1 ;
 304: LD_ADDR_EXP 1
 308: PUSH
 309: LD_INT 1
 311: ST_TO_ADDR
// Your_Side := 2 ;
 312: LD_ADDR_OWVAR 2
 316: PUSH
 317: LD_INT 2
 319: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 0 , 2 , 0 , 3 , 0 ] ;
 320: LD_ADDR_EXP 2
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: LD_INT 0
 336: PUSH
 337: LD_INT 2
 339: PUSH
 340: LD_INT 0
 342: PUSH
 343: LD_INT 3
 345: PUSH
 346: LD_INT 0
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: LIST
 358: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 ] ;
 359: LD_ADDR_EXP 3
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: LD_INT 0
 375: PUSH
 376: LD_INT 1
 378: PUSH
 379: LD_INT 0
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 0
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: ST_TO_ADDR
// Side_Nations := [ 3 , 0 , 0 , 0 , 3 , 0 , 3 , 0 ] ;
 398: LD_ADDR_EXP 4
 402: PUSH
 403: LD_INT 3
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: LD_INT 0
 414: PUSH
 415: LD_INT 3
 417: PUSH
 418: LD_INT 0
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 0
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: LIST
 436: ST_TO_ADDR
// Teams := [ [ 1 , 5 , 7 ] ] ;
 437: LD_ADDR_EXP 5
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 5
 447: PUSH
 448: LD_INT 7
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 459: LD_ADDR_EXP 7
 463: PUSH
 464: LD_INT 203
 466: PUSH
 467: LD_INT 174
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 114
 476: PUSH
 477: LD_INT 171
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: PUSH
 484: LD_INT 26
 486: PUSH
 487: LD_INT 44
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: PUSH
 494: EMPTY
 495: PUSH
 496: EMPTY
 497: PUSH
 498: EMPTY
 499: PUSH
 500: EMPTY
 501: PUSH
 502: EMPTY
 503: PUSH
 504: EMPTY
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: ST_TO_ADDR
// Bot_Side := 2 ;
 514: LD_ADDR_EXP 8
 518: PUSH
 519: LD_INT 2
 521: ST_TO_ADDR
// for i = 1 to 8 do
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: DOUBLE
 528: LD_INT 1
 530: DEC
 531: ST_TO_ADDR
 532: LD_INT 8
 534: PUSH
 535: FOR_TO
 536: IFFALSE 630
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 538: LD_VAR 0 2
 542: PPUSH
 543: CALL_OW 530
 547: PUSH
 548: LD_VAR 0 2
 552: PPUSH
 553: CALL_OW 532
 557: OR
 558: IFFALSE 583
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 560: LD_ADDR_EXP 2
 564: PUSH
 565: LD_EXP 2
 569: PPUSH
 570: LD_VAR 0 2
 574: PPUSH
 575: LD_INT 0
 577: PPUSH
 578: CALL_OW 1
 582: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 583: LD_EXP 4
 587: PUSH
 588: LD_VAR 0 2
 592: ARRAY
 593: PUSH
 594: LD_EXP 4
 598: PUSH
 599: LD_INT 3
 601: NONEQUAL
 602: AND
 603: IFFALSE 628
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 605: LD_ADDR_EXP 4
 609: PUSH
 610: LD_EXP 4
 614: PPUSH
 615: LD_VAR 0 2
 619: PPUSH
 620: LD_INT 3
 622: PPUSH
 623: CALL_OW 1
 627: ST_TO_ADDR
// end ;
 628: GO 535
 630: POP
 631: POP
// if bot_side = 2 and Side_Positions [ 2 ] then
 632: LD_EXP 8
 636: PUSH
 637: LD_INT 2
 639: EQUAL
 640: PUSH
 641: LD_EXP 2
 645: PUSH
 646: LD_INT 2
 648: ARRAY
 649: AND
 650: IFFALSE 660
// bot_side := 5 ;
 652: LD_ADDR_EXP 8
 656: PUSH
 657: LD_INT 5
 659: ST_TO_ADDR
// if bot_side = 5 and Side_Positions [ 5 ] then
 660: LD_EXP 8
 664: PUSH
 665: LD_INT 5
 667: EQUAL
 668: PUSH
 669: LD_EXP 2
 673: PUSH
 674: LD_INT 5
 676: ARRAY
 677: AND
 678: IFFALSE 688
// bot_side := 8 ;
 680: LD_ADDR_EXP 8
 684: PUSH
 685: LD_INT 8
 687: ST_TO_ADDR
// Team_Game := true ;
 688: LD_ADDR_EXP 6
 692: PUSH
 693: LD_INT 1
 695: ST_TO_ADDR
// for i = 1 to 8 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 8
 708: PUSH
 709: FOR_TO
 710: IFFALSE 746
// if i <> bot_side then
 712: LD_VAR 0 2
 716: PUSH
 717: LD_EXP 8
 721: NONEQUAL
 722: IFFALSE 744
// SetAttitude ( i , bot_side , att_enemy , true ) ;
 724: LD_VAR 0 2
 728: PPUSH
 729: LD_EXP 8
 733: PPUSH
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 1
 739: PPUSH
 740: CALL_OW 80
 744: GO 709
 746: POP
 747: POP
// for i := 2 to Teams [ 1 ] do
 748: LD_ADDR_VAR 0 2
 752: PUSH
 753: DOUBLE
 754: LD_INT 2
 756: DEC
 757: ST_TO_ADDR
 758: LD_EXP 5
 762: PUSH
 763: LD_INT 1
 765: ARRAY
 766: PUSH
 767: FOR_TO
 768: IFFALSE 842
// begin ChangeSideFog ( Teams [ 1 ] [ i ] , Teams [ 1 ] [ 1 ] ) ;
 770: LD_EXP 5
 774: PUSH
 775: LD_INT 1
 777: ARRAY
 778: PUSH
 779: LD_VAR 0 2
 783: ARRAY
 784: PPUSH
 785: LD_EXP 5
 789: PUSH
 790: LD_INT 1
 792: ARRAY
 793: PUSH
 794: LD_INT 1
 796: ARRAY
 797: PPUSH
 798: CALL_OW 343
// SetAttitude ( Teams [ 1 ] [ i ] , Teams [ 1 ] [ 1 ] , att_friend , true ) ;
 802: LD_EXP 5
 806: PUSH
 807: LD_INT 1
 809: ARRAY
 810: PUSH
 811: LD_VAR 0 2
 815: ARRAY
 816: PPUSH
 817: LD_EXP 5
 821: PUSH
 822: LD_INT 1
 824: ARRAY
 825: PUSH
 826: LD_INT 1
 828: ARRAY
 829: PPUSH
 830: LD_INT 1
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: CALL_OW 80
// end ;
 840: GO 767
 842: POP
 843: POP
// if not Multiplayer then
 844: LD_OWVAR 4
 848: NOT
 849: IFFALSE 886
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 851: LD_ADDR_EXP 16
 855: PUSH
 856: LD_INT 1
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 1
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 3
 873: PUSH
 874: LD_INT 3
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 886: LD_ADDR_EXP 10
 890: PUSH
 891: LD_INT 9
 893: PUSH
 894: LD_INT 12
 896: PUSH
 897: LD_INT 15
 899: PUSH
 900: LD_INT 24
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: PUSH
 909: LD_EXP 16
 913: PUSH
 914: LD_INT 1
 916: ARRAY
 917: ARRAY
 918: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 919: LD_ADDR_EXP 11
 923: PUSH
 924: LD_INT 2
 926: PUSH
 927: LD_INT 4
 929: PUSH
 930: LD_INT 6
 932: PUSH
 933: LD_INT 8
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: LD_EXP 16
 946: PUSH
 947: LD_INT 2
 949: ARRAY
 950: ARRAY
 951: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 952: LD_ADDR_EXP 12
 956: PUSH
 957: LD_INT 1050
 959: PUSH
 960: LD_INT 875
 962: PUSH
 963: LD_INT 700
 965: PUSH
 966: LD_INT 595
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_EXP 16
 979: PUSH
 980: LD_INT 3
 982: ARRAY
 983: ARRAY
 984: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
 985: LD_ADDR_EXP 13
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 10500
 995: PUSH
 996: LD_INT 6300
 998: PUSH
 999: EMPTY
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_EXP 16
1008: PUSH
1009: LD_INT 4
1011: ARRAY
1012: ARRAY
1013: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
1014: LD_ADDR_EXP 14
1018: PUSH
1019: LD_INT 0
1021: PUSH
1022: LD_INT 31500
1024: PUSH
1025: LD_INT 10500
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_EXP 16
1037: PUSH
1038: LD_INT 4
1040: ARRAY
1041: ARRAY
1042: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1043: LD_ADDR_EXP 15
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 5
1056: PUSH
1057: LD_INT 7
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_EXP 16
1070: PUSH
1071: LD_INT 5
1073: ARRAY
1074: ARRAY
1075: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1076: LD_ADDR_OWVAR 67
1080: PUSH
1081: LD_INT 1
1083: PUSH
1084: LD_INT 2
1086: PUSH
1087: LD_INT 3
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: PUSH
1095: LD_EXP 16
1099: PUSH
1100: LD_INT 6
1102: ARRAY
1103: ARRAY
1104: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1105: LD_ADDR_EXP 26
1109: PUSH
1110: LD_INT 0
1112: PUSH
1113: LD_INT 1
1115: PUSH
1116: LD_INT 2
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_EXP 16
1128: PUSH
1129: LD_INT 7
1131: ARRAY
1132: ARRAY
1133: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1134: LD_ADDR_EXP 23
1138: PUSH
1139: LD_INT 11353
1141: PUSH
1142: LD_INT 12244
1144: PUSH
1145: LD_INT 44444
1147: PUSH
1148: LD_INT 12345
1150: PUSH
1151: LD_INT 43413
1153: PUSH
1154: LD_INT 14152
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1165: LD_ADDR_EXP 24
1169: PUSH
1170: LD_INT 1
1172: PPUSH
1173: LD_INT 6
1175: PPUSH
1176: CALL_OW 12
1180: ST_TO_ADDR
// if bot_side <> 2 then
1181: LD_EXP 8
1185: PUSH
1186: LD_INT 2
1188: NONEQUAL
1189: IFFALSE 1232
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1191: LD_ADDR_VAR 0 2
1195: PUSH
1196: LD_INT 22
1198: PUSH
1199: LD_INT 2
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PPUSH
1206: CALL_OW 69
1210: PUSH
1211: FOR_IN
1212: IFFALSE 1230
// SetSide ( i , bot_side ) ;
1214: LD_VAR 0 2
1218: PPUSH
1219: LD_EXP 8
1223: PPUSH
1224: CALL_OW 235
1228: GO 1211
1230: POP
1231: POP
// ResetFog ;
1232: CALL_OW 335
// PreparePeople ( ) ;
1236: CALL 2066 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1240: LD_ADDR_EXP 18
1244: PUSH
1245: LD_INT 14
1247: PUSH
1248: LD_INT 15
1250: PUSH
1251: LD_INT 16
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// if amount_of_apeman then
1259: LD_EXP 15
1263: IFFALSE 1313
// for j in apeman_areas do
1265: LD_ADDR_VAR 0 3
1269: PUSH
1270: LD_EXP 18
1274: PUSH
1275: FOR_IN
1276: IFFALSE 1311
// for i = 1 to amount_of_apeman do
1278: LD_ADDR_VAR 0 2
1282: PUSH
1283: DOUBLE
1284: LD_INT 1
1286: DEC
1287: ST_TO_ADDR
1288: LD_EXP 15
1292: PUSH
1293: FOR_TO
1294: IFFALSE 1307
// AddApeman ( j ) ;
1296: LD_VAR 0 3
1300: PPUSH
1301: CALL 3015 0 1
1305: GO 1293
1307: POP
1308: POP
1309: GO 1275
1311: POP
1312: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1313: LD_INT 22
1315: PUSH
1316: LD_OWVAR 2
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PPUSH
1325: CALL_OW 69
1329: PUSH
1330: LD_INT 1
1332: ARRAY
1333: PPUSH
1334: CALL_OW 87
// disable ( 17 ) ;
1338: LD_INT 17
1340: DISABLE_MARKED
// end ;
1341: LD_VAR 0 1
1345: RET
// every 3 3$40 trigger game_start do
1346: LD_EXP 9
1350: IFFALSE 1406
1352: GO 1354
1354: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1355: LD_OWVAR 1
1359: PUSH
1360: LD_INT 5
1362: MOD
1363: PUSH
1364: LD_INT 1
1366: PLUS
1367: PPUSH
1368: LD_INT 13
1370: PPUSH
1371: LD_INT 1
1373: PPUSH
1374: CALL_OW 55
// Wait ( 0 0$15 ) ;
1378: LD_INT 525
1380: PPUSH
1381: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1385: LD_OWVAR 1
1389: PUSH
1390: LD_INT 5
1392: MOD
1393: PUSH
1394: LD_INT 1
1396: PLUS
1397: PPUSH
1398: LD_INT 1
1400: PPUSH
1401: CALL_OW 57
// enable ;
1405: ENABLE
// end ;
1406: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1407: LD_EXP 9
1411: IFFALSE 2063
1413: GO 1415
1415: DISABLE
1416: LD_INT 0
1418: PPUSH
1419: PPUSH
// begin cr := 1 ;
1420: LD_ADDR_VAR 0 1
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1428: LD_ADDR_VAR 0 2
1432: PUSH
1433: LD_INT 1
1435: PPUSH
1436: LD_INT 3
1438: PPUSH
1439: CALL_OW 12
1443: PUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_INT 4
1449: PPUSH
1450: CALL_OW 12
1454: PUSH
1455: LD_INT 3
1457: PPUSH
1458: LD_INT 5
1460: PPUSH
1461: CALL_OW 12
1465: PUSH
1466: LD_INT 3
1468: PPUSH
1469: LD_INT 5
1471: PPUSH
1472: CALL_OW 12
1476: PUSH
1477: LD_INT 2
1479: PPUSH
1480: LD_INT 5
1482: PPUSH
1483: CALL_OW 12
1487: PUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_INT 5
1493: PPUSH
1494: CALL_OW 12
1498: PUSH
1499: EMPTY
1500: LIST
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: ST_TO_ADDR
// while ( true ) do
1507: LD_INT 1
1509: IFFALSE 2063
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1511: LD_EXP 12
1515: PUSH
1516: LD_OWVAR 1
1520: PUSH
1521: LD_INT 35
1523: MOD
1524: PUSH
1525: LD_INT 60
1527: MUL
1528: PLUS
1529: PPUSH
1530: CALL_OW 67
// if cr mod 3 = 0 then
1534: LD_VAR 0 1
1538: PUSH
1539: LD_INT 3
1541: MOD
1542: PUSH
1543: LD_INT 0
1545: EQUAL
1546: IFFALSE 1699
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1548: LD_VAR 0 2
1552: PUSH
1553: LD_VAR 0 1
1557: PUSH
1558: LD_VAR 0 2
1562: MOD
1563: PUSH
1564: LD_INT 1
1566: PLUS
1567: ARRAY
1568: PPUSH
1569: LD_INT 17
1571: PPUSH
1572: LD_INT 1
1574: PPUSH
1575: CALL_OW 55
// Wait ( crates_spawn ) ;
1579: LD_EXP 12
1583: PPUSH
1584: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 1
1597: PUSH
1598: LD_VAR 0 2
1602: MOD
1603: PUSH
1604: LD_INT 1
1606: PLUS
1607: ARRAY
1608: PPUSH
1609: LD_INT 18
1611: PPUSH
1612: LD_INT 1
1614: PPUSH
1615: CALL_OW 55
// Wait ( crates_spawn ) ;
1619: LD_EXP 12
1623: PPUSH
1624: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1628: LD_VAR 0 2
1632: PUSH
1633: LD_VAR 0 1
1637: PUSH
1638: LD_VAR 0 2
1642: MOD
1643: PUSH
1644: LD_INT 1
1646: PLUS
1647: ARRAY
1648: PPUSH
1649: LD_INT 19
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: CALL_OW 55
// Wait ( crates_spawn ) ;
1659: LD_EXP 12
1663: PPUSH
1664: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1668: LD_VAR 0 2
1672: PUSH
1673: LD_VAR 0 1
1677: PUSH
1678: LD_VAR 0 2
1682: MOD
1683: PUSH
1684: LD_INT 1
1686: PLUS
1687: ARRAY
1688: PPUSH
1689: LD_INT 17
1691: PPUSH
1692: LD_INT 1
1694: PPUSH
1695: CALL_OW 55
// end ; if cr mod 3 = 1 then
1699: LD_VAR 0 1
1703: PUSH
1704: LD_INT 3
1706: MOD
1707: PUSH
1708: LD_INT 1
1710: EQUAL
1711: IFFALSE 1864
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1713: LD_VAR 0 2
1717: PUSH
1718: LD_VAR 0 1
1722: PUSH
1723: LD_VAR 0 2
1727: MOD
1728: PUSH
1729: LD_INT 1
1731: PLUS
1732: ARRAY
1733: PPUSH
1734: LD_INT 18
1736: PPUSH
1737: LD_INT 1
1739: PPUSH
1740: CALL_OW 55
// Wait ( crates_spawn ) ;
1744: LD_EXP 12
1748: PPUSH
1749: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1753: LD_VAR 0 2
1757: PUSH
1758: LD_VAR 0 1
1762: PUSH
1763: LD_VAR 0 2
1767: MOD
1768: PUSH
1769: LD_INT 1
1771: PLUS
1772: ARRAY
1773: PPUSH
1774: LD_INT 17
1776: PPUSH
1777: LD_INT 1
1779: PPUSH
1780: CALL_OW 55
// Wait ( crates_spawn ) ;
1784: LD_EXP 12
1788: PPUSH
1789: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1793: LD_VAR 0 2
1797: PUSH
1798: LD_VAR 0 1
1802: PUSH
1803: LD_VAR 0 2
1807: MOD
1808: PUSH
1809: LD_INT 1
1811: PLUS
1812: ARRAY
1813: PPUSH
1814: LD_INT 19
1816: PPUSH
1817: LD_INT 1
1819: PPUSH
1820: CALL_OW 55
// Wait ( crates_spawn ) ;
1824: LD_EXP 12
1828: PPUSH
1829: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1833: LD_VAR 0 2
1837: PUSH
1838: LD_VAR 0 1
1842: PUSH
1843: LD_VAR 0 2
1847: MOD
1848: PUSH
1849: LD_INT 1
1851: PLUS
1852: ARRAY
1853: PPUSH
1854: LD_INT 18
1856: PPUSH
1857: LD_INT 1
1859: PPUSH
1860: CALL_OW 55
// end ; if cr mod 3 = 2 then
1864: LD_VAR 0 1
1868: PUSH
1869: LD_INT 3
1871: MOD
1872: PUSH
1873: LD_INT 2
1875: EQUAL
1876: IFFALSE 2029
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1878: LD_VAR 0 2
1882: PUSH
1883: LD_VAR 0 1
1887: PUSH
1888: LD_VAR 0 2
1892: MOD
1893: PUSH
1894: LD_INT 1
1896: PLUS
1897: ARRAY
1898: PPUSH
1899: LD_INT 19
1901: PPUSH
1902: LD_INT 1
1904: PPUSH
1905: CALL_OW 55
// Wait ( crates_spawn ) ;
1909: LD_EXP 12
1913: PPUSH
1914: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1918: LD_VAR 0 2
1922: PUSH
1923: LD_VAR 0 1
1927: PUSH
1928: LD_VAR 0 2
1932: MOD
1933: PUSH
1934: LD_INT 1
1936: PLUS
1937: ARRAY
1938: PPUSH
1939: LD_INT 18
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: CALL_OW 55
// Wait ( crates_spawn ) ;
1949: LD_EXP 12
1953: PPUSH
1954: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1958: LD_VAR 0 2
1962: PUSH
1963: LD_VAR 0 1
1967: PUSH
1968: LD_VAR 0 2
1972: MOD
1973: PUSH
1974: LD_INT 1
1976: PLUS
1977: ARRAY
1978: PPUSH
1979: LD_INT 17
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: CALL_OW 55
// Wait ( crates_spawn ) ;
1989: LD_EXP 12
1993: PPUSH
1994: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1998: LD_VAR 0 2
2002: PUSH
2003: LD_VAR 0 1
2007: PUSH
2008: LD_VAR 0 2
2012: MOD
2013: PUSH
2014: LD_INT 1
2016: PLUS
2017: ARRAY
2018: PPUSH
2019: LD_INT 19
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: CALL_OW 55
// end ; cr := cr + 1 ;
2029: LD_ADDR_VAR 0 1
2033: PUSH
2034: LD_VAR 0 1
2038: PUSH
2039: LD_INT 1
2041: PLUS
2042: ST_TO_ADDR
// if cr > 150 then
2043: LD_VAR 0 1
2047: PUSH
2048: LD_INT 150
2050: GREATER
2051: IFFALSE 2061
// cr := 43 ;
2053: LD_ADDR_VAR 0 1
2057: PUSH
2058: LD_INT 43
2060: ST_TO_ADDR
// end ;
2061: GO 1507
// end ; end_of_file
2063: PPOPN 2
2065: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2066: LD_INT 0
2068: PPUSH
2069: PPUSH
2070: PPUSH
2071: PPUSH
2072: PPUSH
2073: PPUSH
2074: PPUSH
2075: PPUSH
2076: PPUSH
// to_copy := [ ] ;
2077: LD_ADDR_VAR 0 5
2081: PUSH
2082: EMPTY
2083: ST_TO_ADDR
// for i = 1 to 8 do
2084: LD_ADDR_VAR 0 2
2088: PUSH
2089: DOUBLE
2090: LD_INT 1
2092: DEC
2093: ST_TO_ADDR
2094: LD_INT 8
2096: PUSH
2097: FOR_TO
2098: IFFALSE 3008
// begin if Side_Positions [ i ] then
2100: LD_EXP 2
2104: PUSH
2105: LD_VAR 0 2
2109: ARRAY
2110: IFFALSE 3006
// begin uc_side := i ;
2112: LD_ADDR_OWVAR 20
2116: PUSH
2117: LD_VAR 0 2
2121: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2122: LD_ADDR_OWVAR 21
2126: PUSH
2127: LD_EXP 4
2131: PUSH
2132: LD_VAR 0 2
2136: ARRAY
2137: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2138: LD_ADDR_VAR 0 6
2142: PUSH
2143: LD_EXP 7
2147: PUSH
2148: LD_EXP 2
2152: PUSH
2153: LD_VAR 0 2
2157: ARRAY
2158: ARRAY
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2164: LD_ADDR_VAR 0 7
2168: PUSH
2169: LD_EXP 7
2173: PUSH
2174: LD_EXP 2
2178: PUSH
2179: LD_VAR 0 2
2183: ARRAY
2184: ARRAY
2185: PUSH
2186: LD_INT 2
2188: ARRAY
2189: ST_TO_ADDR
// hc_importance := 100 ;
2190: LD_ADDR_OWVAR 32
2194: PUSH
2195: LD_INT 100
2197: ST_TO_ADDR
// if Multiplayer then
2198: LD_OWVAR 4
2202: IFFALSE 2260
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2204: LD_ADDR_OWVAR 26
2208: PUSH
2209: LD_OWVAR 19
2213: PUSH
2214: LD_OWVAR 20
2218: ARRAY
2219: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2220: LD_ADDR_OWVAR 33
2224: PUSH
2225: LD_STRING MULTIAVATARS
2227: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2228: LD_ADDR_OWVAR 34
2232: PUSH
2233: LD_OWVAR 20
2237: PPUSH
2238: CALL_OW 525
2242: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2243: LD_ADDR_OWVAR 27
2247: PUSH
2248: LD_OWVAR 20
2252: PPUSH
2253: CALL_OW 526
2257: ST_TO_ADDR
// end else
2258: GO 2292
// begin hc_name :=  ;
2260: LD_ADDR_OWVAR 26
2264: PUSH
2265: LD_STRING 
2267: ST_TO_ADDR
// hc_gallery :=  ;
2268: LD_ADDR_OWVAR 33
2272: PUSH
2273: LD_STRING 
2275: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2276: LD_ADDR_OWVAR 27
2280: PUSH
2281: LD_INT 1
2283: PPUSH
2284: LD_INT 2
2286: PPUSH
2287: CALL_OW 12
2291: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2292: LD_OWVAR 27
2296: PPUSH
2297: LD_INT 1
2299: PPUSH
2300: LD_EXP 11
2304: PPUSH
2305: CALL_OW 380
// un := CreateHuman ;
2309: LD_ADDR_VAR 0 4
2313: PUSH
2314: CALL_OW 44
2318: ST_TO_ADDR
// if not to_copy then
2319: LD_VAR 0 5
2323: NOT
2324: IFFALSE 2351
// to_copy := Replace ( to_copy , 1 , un ) else
2326: LD_ADDR_VAR 0 5
2330: PUSH
2331: LD_VAR 0 5
2335: PPUSH
2336: LD_INT 1
2338: PPUSH
2339: LD_VAR 0 4
2343: PPUSH
2344: CALL_OW 1
2348: ST_TO_ADDR
2349: GO 2427
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2351: LD_VAR 0 5
2355: PUSH
2356: LD_INT 1
2358: ARRAY
2359: PPUSH
2360: LD_VAR 0 4
2364: PPUSH
2365: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2369: LD_VAR 0 4
2373: PPUSH
2374: LD_INT 2
2376: PPUSH
2377: LD_VAR 0 5
2381: PUSH
2382: LD_INT 1
2384: ARRAY
2385: PPUSH
2386: LD_INT 2
2388: PPUSH
2389: CALL_OW 260
2393: PPUSH
2394: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2398: LD_VAR 0 4
2402: PPUSH
2403: LD_INT 1
2405: PPUSH
2406: LD_VAR 0 5
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 1
2417: PPUSH
2418: CALL_OW 260
2422: PPUSH
2423: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2427: LD_VAR 0 4
2431: PPUSH
2432: LD_VAR 0 6
2436: PPUSH
2437: LD_VAR 0 7
2441: PPUSH
2442: LD_INT 10
2444: PPUSH
2445: LD_INT 0
2447: PPUSH
2448: CALL_OW 50
// hc_importance := 0 ;
2452: LD_ADDR_OWVAR 32
2456: PUSH
2457: LD_INT 0
2459: ST_TO_ADDR
// hc_name :=  ;
2460: LD_ADDR_OWVAR 26
2464: PUSH
2465: LD_STRING 
2467: ST_TO_ADDR
// hc_gallery :=  ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING 
2475: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2476: LD_ADDR_VAR 0 9
2480: PUSH
2481: LD_EXP 10
2485: PUSH
2486: LD_INT 1
2488: MINUS
2489: PUSH
2490: LD_INT 4
2492: DIVREAL
2493: ST_TO_ADDR
// c := 1 ;
2494: LD_ADDR_VAR 0 8
2498: PUSH
2499: LD_INT 1
2501: ST_TO_ADDR
// for j = 2 to number_of_people do
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: DOUBLE
2508: LD_INT 2
2510: DEC
2511: ST_TO_ADDR
2512: LD_EXP 10
2516: PUSH
2517: FOR_TO
2518: IFFALSE 2729
// begin PrepareHuman ( false , c , skill_level ) ;
2520: LD_INT 0
2522: PPUSH
2523: LD_VAR 0 8
2527: PPUSH
2528: LD_EXP 11
2532: PPUSH
2533: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2537: LD_VAR 0 3
2541: PUSH
2542: LD_INT 1
2544: MINUS
2545: PUSH
2546: LD_VAR 0 9
2550: MOD
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: IFFALSE 2571
// c := c + 1 ;
2557: LD_ADDR_VAR 0 8
2561: PUSH
2562: LD_VAR 0 8
2566: PUSH
2567: LD_INT 1
2569: PLUS
2570: ST_TO_ADDR
// un := CreateHuman ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 44
2580: ST_TO_ADDR
// if to_copy < j then
2581: LD_VAR 0 5
2585: PUSH
2586: LD_VAR 0 3
2590: LESS
2591: IFFALSE 2620
// to_copy := Replace ( to_copy , j , un ) else
2593: LD_ADDR_VAR 0 5
2597: PUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: LD_VAR 0 3
2607: PPUSH
2608: LD_VAR 0 4
2612: PPUSH
2613: CALL_OW 1
2617: ST_TO_ADDR
2618: GO 2702
// begin CopySkills ( to_copy [ j ] , un ) ;
2620: LD_VAR 0 5
2624: PUSH
2625: LD_VAR 0 3
2629: ARRAY
2630: PPUSH
2631: LD_VAR 0 4
2635: PPUSH
2636: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2640: LD_VAR 0 4
2644: PPUSH
2645: LD_INT 2
2647: PPUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_VAR 0 3
2657: ARRAY
2658: PPUSH
2659: LD_INT 2
2661: PPUSH
2662: CALL_OW 260
2666: PPUSH
2667: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2671: LD_VAR 0 4
2675: PPUSH
2676: LD_INT 1
2678: PPUSH
2679: LD_VAR 0 5
2683: PUSH
2684: LD_VAR 0 3
2688: ARRAY
2689: PPUSH
2690: LD_INT 1
2692: PPUSH
2693: CALL_OW 260
2697: PPUSH
2698: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2702: LD_VAR 0 4
2706: PPUSH
2707: LD_VAR 0 6
2711: PPUSH
2712: LD_VAR 0 7
2716: PPUSH
2717: LD_INT 10
2719: PPUSH
2720: LD_INT 0
2722: PPUSH
2723: CALL_OW 50
// end ;
2727: GO 2517
2729: POP
2730: POP
// if handicap then
2731: LD_EXP 26
2735: IFFALSE 3006
// begin if handicap = 1 then
2737: LD_EXP 26
2741: PUSH
2742: LD_INT 1
2744: EQUAL
2745: IFFALSE 2824
// for j = 1 to 2 do
2747: LD_ADDR_VAR 0 3
2751: PUSH
2752: DOUBLE
2753: LD_INT 1
2755: DEC
2756: ST_TO_ADDR
2757: LD_INT 2
2759: PUSH
2760: FOR_TO
2761: IFFALSE 2822
// begin vc_chassis := ru_medium_tracked ;
2763: LD_ADDR_OWVAR 37
2767: PUSH
2768: LD_INT 22
2770: ST_TO_ADDR
// vc_engine := engine_combustion ;
2771: LD_ADDR_OWVAR 39
2775: PUSH
2776: LD_INT 1
2778: ST_TO_ADDR
// vc_control := control_manual ;
2779: LD_ADDR_OWVAR 38
2783: PUSH
2784: LD_INT 1
2786: ST_TO_ADDR
// vc_weapon := ru_gun ;
2787: LD_ADDR_OWVAR 40
2791: PUSH
2792: LD_INT 44
2794: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2795: CALL_OW 45
2799: PPUSH
2800: LD_VAR 0 6
2804: PPUSH
2805: LD_VAR 0 7
2809: PPUSH
2810: LD_INT 13
2812: PPUSH
2813: LD_INT 0
2815: PPUSH
2816: CALL_OW 50
// end ;
2820: GO 2760
2822: POP
2823: POP
// if handicap = 2 then
2824: LD_EXP 26
2828: PUSH
2829: LD_INT 2
2831: EQUAL
2832: IFFALSE 3006
// begin for j = 1 to 2 do
2834: LD_ADDR_VAR 0 3
2838: PUSH
2839: DOUBLE
2840: LD_INT 1
2842: DEC
2843: ST_TO_ADDR
2844: LD_INT 2
2846: PUSH
2847: FOR_TO
2848: IFFALSE 2922
// begin vc_chassis := ru_heavy_tracked ;
2850: LD_ADDR_OWVAR 37
2854: PUSH
2855: LD_INT 24
2857: ST_TO_ADDR
// vc_engine := engine_combustion ;
2858: LD_ADDR_OWVAR 39
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_control := control_manual ;
2866: LD_ADDR_OWVAR 38
2870: PUSH
2871: LD_INT 1
2873: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_heavy_gun ] [ j ] ;
2874: LD_ADDR_OWVAR 40
2878: PUSH
2879: LD_INT 43
2881: PUSH
2882: LD_INT 46
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: LD_VAR 0 3
2893: ARRAY
2894: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2895: CALL_OW 45
2899: PPUSH
2900: LD_VAR 0 6
2904: PPUSH
2905: LD_VAR 0 7
2909: PPUSH
2910: LD_INT 13
2912: PPUSH
2913: LD_INT 0
2915: PPUSH
2916: CALL_OW 50
// end ;
2920: GO 2847
2922: POP
2923: POP
// vc_chassis := ru_medium_tracked ;
2924: LD_ADDR_OWVAR 37
2928: PUSH
2929: LD_INT 22
2931: ST_TO_ADDR
// vc_engine := engine_siberite ;
2932: LD_ADDR_OWVAR 39
2936: PUSH
2937: LD_INT 3
2939: ST_TO_ADDR
// vc_control := control_computer ;
2940: LD_ADDR_OWVAR 38
2944: PUSH
2945: LD_INT 3
2947: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2948: LD_ADDR_OWVAR 40
2952: PUSH
2953: LD_INT 51
2955: ST_TO_ADDR
// un := CreateVehicle ;
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: CALL_OW 45
2965: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2966: LD_VAR 0 4
2970: PPUSH
2971: LD_VAR 0 6
2975: PPUSH
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 13
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
2991: LD_VAR 0 4
2995: PPUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 100
3001: PPUSH
3002: CALL_OW 290
// end ; end ; end ; end ;
3006: GO 2097
3008: POP
3009: POP
// end ;
3010: LD_VAR 0 1
3014: RET
// export function AddApeman ( area ) ; begin
3015: LD_INT 0
3017: PPUSH
// uc_nation := 0 ;
3018: LD_ADDR_OWVAR 21
3022: PUSH
3023: LD_INT 0
3025: ST_TO_ADDR
// uc_side := 0 ;
3026: LD_ADDR_OWVAR 20
3030: PUSH
3031: LD_INT 0
3033: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
3034: LD_ADDR_OWVAR 35
3038: PUSH
3039: LD_INT 10
3041: NEG
3042: PPUSH
3043: LD_INT 15
3045: PPUSH
3046: CALL_OW 12
3050: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3051: LD_INT 0
3053: PPUSH
3054: LD_INT 12
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3064: LD_ADDR_OWVAR 29
3068: PUSH
3069: LD_INT 10
3071: PUSH
3072: LD_INT 12
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3079: CALL_OW 44
3083: PPUSH
3084: LD_VAR 0 1
3088: PPUSH
3089: LD_INT 0
3091: PPUSH
3092: CALL_OW 49
// end ;
3096: LD_VAR 0 2
3100: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3101: LD_INT 0
3103: PPUSH
3104: PPUSH
3105: PPUSH
3106: PPUSH
// r := 100 ;
3107: LD_ADDR_VAR 0 5
3111: PUSH
3112: LD_INT 100
3114: ST_TO_ADDR
// x := 0 ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_INT 0
3122: ST_TO_ADDR
// while ( x < n ) do
3123: LD_VAR 0 6
3127: PUSH
3128: LD_VAR 0 2
3132: LESS
3133: IFFALSE 3448
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3135: LD_ADDR_VAR 0 4
3139: PUSH
3140: DOUBLE
3141: LD_INT 1
3143: DEC
3144: ST_TO_ADDR
3145: LD_VAR 0 1
3149: PPUSH
3150: LD_INT 0
3152: PPUSH
3153: CALL_OW 517
3157: PUSH
3158: LD_INT 1
3160: ARRAY
3161: PUSH
3162: FOR_TO
3163: IFFALSE 3444
// begin if r > 50 then
3165: LD_VAR 0 5
3169: PUSH
3170: LD_INT 50
3172: GREATER
3173: IFFALSE 3420
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3175: LD_VAR 0 1
3179: PPUSH
3180: LD_INT 0
3182: PPUSH
3183: CALL_OW 517
3187: PUSH
3188: LD_INT 1
3190: ARRAY
3191: PUSH
3192: LD_VAR 0 4
3196: ARRAY
3197: PPUSH
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 0
3205: PPUSH
3206: CALL_OW 517
3210: PUSH
3211: LD_INT 2
3213: ARRAY
3214: PUSH
3215: LD_VAR 0 4
3219: ARRAY
3220: PPUSH
3221: CALL_OW 458
3225: NOT
3226: IFFALSE 3404
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3228: LD_VAR 0 1
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 517
3240: PUSH
3241: LD_INT 1
3243: ARRAY
3244: PUSH
3245: LD_VAR 0 4
3249: ARRAY
3250: PPUSH
3251: LD_VAR 0 1
3255: PPUSH
3256: LD_INT 0
3258: PPUSH
3259: CALL_OW 517
3263: PUSH
3264: LD_INT 2
3266: ARRAY
3267: PUSH
3268: LD_VAR 0 4
3272: ARRAY
3273: PPUSH
3274: LD_EXP 8
3278: PPUSH
3279: LD_INT 0
3281: PPUSH
3282: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3286: LD_ADDR_EXP 17
3290: PUSH
3291: LD_EXP 17
3295: PPUSH
3296: LD_EXP 17
3300: PUSH
3301: LD_INT 1
3303: PLUS
3304: PPUSH
3305: LD_VAR 0 1
3309: PPUSH
3310: LD_INT 0
3312: PPUSH
3313: CALL_OW 517
3317: PUSH
3318: LD_INT 1
3320: ARRAY
3321: PUSH
3322: LD_VAR 0 4
3326: ARRAY
3327: PPUSH
3328: CALL_OW 2
3332: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3333: LD_ADDR_EXP 17
3337: PUSH
3338: LD_EXP 17
3342: PPUSH
3343: LD_EXP 17
3347: PUSH
3348: LD_INT 1
3350: PLUS
3351: PPUSH
3352: LD_VAR 0 1
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: CALL_OW 517
3364: PUSH
3365: LD_INT 2
3367: ARRAY
3368: PUSH
3369: LD_VAR 0 4
3373: ARRAY
3374: PPUSH
3375: CALL_OW 2
3379: ST_TO_ADDR
// r := 0 ;
3380: LD_ADDR_VAR 0 5
3384: PUSH
3385: LD_INT 0
3387: ST_TO_ADDR
// x := x + 1 ;
3388: LD_ADDR_VAR 0 6
3392: PUSH
3393: LD_VAR 0 6
3397: PUSH
3398: LD_INT 1
3400: PLUS
3401: ST_TO_ADDR
// end else
3402: GO 3418
// r := r + 35 ;
3404: LD_ADDR_VAR 0 5
3408: PUSH
3409: LD_VAR 0 5
3413: PUSH
3414: LD_INT 35
3416: PLUS
3417: ST_TO_ADDR
// end else
3418: GO 3442
// r := r + rand ( 10 , 25 ) ;
3420: LD_ADDR_VAR 0 5
3424: PUSH
3425: LD_VAR 0 5
3429: PUSH
3430: LD_INT 10
3432: PPUSH
3433: LD_INT 25
3435: PPUSH
3436: CALL_OW 12
3440: PLUS
3441: ST_TO_ADDR
// end ;
3442: GO 3162
3444: POP
3445: POP
3446: GO 3123
// end ;
3448: LD_VAR 0 3
3452: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3453: LD_INT 0
3455: PPUSH
3456: PPUSH
3457: PPUSH
// if not GetControl ( veh ) = control_manual then
3458: LD_VAR 0 1
3462: PPUSH
3463: CALL_OW 263
3467: PUSH
3468: LD_INT 1
3470: EQUAL
3471: NOT
3472: IFFALSE 3484
// result := false else
3474: LD_ADDR_VAR 0 2
3478: PUSH
3479: LD_INT 0
3481: ST_TO_ADDR
3482: GO 3629
// if veh in FilterAllUnits ( [ f_empty ] ) then
3484: LD_VAR 0 1
3488: PUSH
3489: LD_INT 58
3491: PUSH
3492: EMPTY
3493: LIST
3494: PPUSH
3495: CALL_OW 69
3499: IN
3500: IFFALSE 3512
// result := false else
3502: LD_ADDR_VAR 0 2
3506: PUSH
3507: LD_INT 0
3509: ST_TO_ADDR
3510: GO 3629
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3512: LD_ADDR_VAR 0 4
3516: PUSH
3517: LD_INT 22
3519: PUSH
3520: LD_VAR 0 1
3524: PPUSH
3525: CALL_OW 255
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 55
3536: PUSH
3537: EMPTY
3538: LIST
3539: PUSH
3540: EMPTY
3541: LIST
3542: LIST
3543: PPUSH
3544: CALL_OW 69
3548: ST_TO_ADDR
// if not filter then
3549: LD_VAR 0 4
3553: NOT
3554: IFFALSE 3566
// result := false else
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_INT 0
3563: ST_TO_ADDR
3564: GO 3629
// for i = 1 to filter do
3566: LD_ADDR_VAR 0 3
3570: PUSH
3571: DOUBLE
3572: LD_INT 1
3574: DEC
3575: ST_TO_ADDR
3576: LD_VAR 0 4
3580: PUSH
3581: FOR_TO
3582: IFFALSE 3627
// if IsDriver ( filter [ i ] ) = veh then
3584: LD_VAR 0 4
3588: PUSH
3589: LD_VAR 0 3
3593: ARRAY
3594: PPUSH
3595: NOP4
3599: PUSH
3600: LD_VAR 0 1
3604: EQUAL
3605: IFFALSE 3625
// begin result := filter [ i ] ;
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_VAR 0 4
3616: PUSH
3617: LD_VAR 0 3
3621: ARRAY
3622: ST_TO_ADDR
// break ;
3623: GO 3627
// end ;
3625: GO 3581
3627: POP
3628: POP
// end ; end ; end_of_file
3629: LD_VAR 0 2
3633: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3634: LD_INT 0
3636: PPUSH
3637: PPUSH
3638: PPUSH
3639: PPUSH
3640: PPUSH
3641: PPUSH
3642: PPUSH
3643: PPUSH
3644: PPUSH
// side := Bot_Side ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_EXP 8
3654: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3655: LD_ADDR_VAR 0 9
3659: PUSH
3660: LD_INT 4
3662: PUSH
3663: LD_INT 6
3665: PUSH
3666: LD_INT 8
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: LIST
3673: PUSH
3674: LD_OWVAR 67
3678: ARRAY
3679: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3680: LD_ADDR_VAR 0 8
3684: PUSH
3685: LD_INT 27
3687: PUSH
3688: LD_INT 28
3690: PUSH
3691: LD_INT 25
3693: PUSH
3694: LD_INT 26
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3703: LD_ADDR_EXP 22
3707: PUSH
3708: LD_INT 4
3710: PUSH
3711: LD_INT 5
3713: PUSH
3714: LD_INT 6
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: LIST
3721: PUSH
3722: LD_OWVAR 67
3726: ARRAY
3727: ST_TO_ADDR
// ct := [ ] ;
3728: LD_ADDR_VAR 0 3
3732: PUSH
3733: EMPTY
3734: ST_TO_ADDR
// patrols := [ ] ;
3735: LD_ADDR_EXP 19
3739: PUSH
3740: EMPTY
3741: ST_TO_ADDR
// attackers := [ ] ;
3742: LD_ADDR_EXP 20
3746: PUSH
3747: EMPTY
3748: ST_TO_ADDR
// attackers_tmp := [ ] ;
3749: LD_ADDR_EXP 27
3753: PUSH
3754: EMPTY
3755: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_siberite , control_remote , ar_selfpropelled_bomb ] ] ;
3756: LD_ADDR_EXP 21
3760: PUSH
3761: LD_INT 14
3763: PUSH
3764: LD_INT 1
3766: PUSH
3767: LD_INT 2
3769: PUSH
3770: LD_INT 27
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_INT 14
3781: PUSH
3782: LD_INT 1
3784: PUSH
3785: LD_INT 2
3787: PUSH
3788: LD_INT 25
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: PUSH
3797: LD_INT 14
3799: PUSH
3800: LD_INT 1
3802: PUSH
3803: LD_INT 2
3805: PUSH
3806: LD_INT 28
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 14
3817: PUSH
3818: LD_INT 1
3820: PUSH
3821: LD_INT 2
3823: PUSH
3824: LD_INT 29
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: PUSH
3833: LD_INT 14
3835: PUSH
3836: LD_INT 1
3838: PUSH
3839: LD_INT 2
3841: PUSH
3842: LD_INT 27
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 13
3853: PUSH
3854: LD_INT 3
3856: PUSH
3857: LD_INT 2
3859: PUSH
3860: LD_INT 29
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3877: LD_INT 2
3879: PPUSH
3880: LD_STRING newkabul
3882: PPUSH
3883: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3887: LD_INT 2
3889: PPUSH
3890: CALL_OW 274
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 90000
3900: PPUSH
3901: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 274
3912: PPUSH
3913: LD_INT 2
3915: PPUSH
3916: LD_INT 9000
3918: PPUSH
3919: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3923: LD_INT 2
3925: PPUSH
3926: CALL_OW 274
3930: PPUSH
3931: LD_INT 3
3933: PPUSH
3934: LD_INT 3000
3936: PPUSH
3937: CALL_OW 277
// if Difficulty > 1 then
3941: LD_OWVAR 67
3945: PUSH
3946: LD_INT 1
3948: GREATER
3949: IFFALSE 3966
// SetTech ( 5 , side , state_researched ) ;
3951: LD_INT 5
3953: PPUSH
3954: LD_VAR 0 5
3958: PPUSH
3959: LD_INT 2
3961: PPUSH
3962: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
3966: LD_INT 41
3968: PPUSH
3969: LD_VAR 0 5
3973: PPUSH
3974: LD_INT 2
3976: PPUSH
3977: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3981: LD_INT 51
3983: PPUSH
3984: LD_VAR 0 5
3988: PPUSH
3989: LD_INT 2
3991: PPUSH
3992: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
3996: LD_INT 52
3998: PPUSH
3999: LD_VAR 0 5
4003: PPUSH
4004: LD_INT 2
4006: PPUSH
4007: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4011: LD_INT 53
4013: PPUSH
4014: LD_VAR 0 5
4018: PPUSH
4019: LD_INT 2
4021: PPUSH
4022: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4026: LD_INT 60
4028: PPUSH
4029: LD_VAR 0 5
4033: PPUSH
4034: LD_INT 2
4036: PPUSH
4037: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4041: LD_INT 61
4043: PPUSH
4044: LD_VAR 0 5
4048: PPUSH
4049: LD_INT 2
4051: PPUSH
4052: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4056: LD_INT 62
4058: PPUSH
4059: LD_VAR 0 5
4063: PPUSH
4064: LD_INT 2
4066: PPUSH
4067: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4071: LD_ADDR_VAR 0 2
4075: PUSH
4076: LD_INT 22
4078: PUSH
4079: LD_VAR 0 5
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: PUSH
4088: LD_INT 21
4090: PUSH
4091: LD_INT 3
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: PPUSH
4102: CALL_OW 69
4106: PUSH
4107: FOR_IN
4108: IFFALSE 4141
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4110: LD_VAR 0 2
4114: PPUSH
4115: LD_INT 6
4117: PUSH
4118: LD_INT 8
4120: PUSH
4121: LD_INT 10
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: LIST
4128: PUSH
4129: LD_OWVAR 67
4133: ARRAY
4134: PPUSH
4135: CALL_OW 241
4139: GO 4107
4141: POP
4142: POP
// if Difficulty > 1 then
4143: LD_OWVAR 67
4147: PUSH
4148: LD_INT 1
4150: GREATER
4151: IFFALSE 4160
// RemoveEnvironmentArea ( forest_road ) ;
4153: LD_INT 11
4155: PPUSH
4156: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4160: LD_INT 4
4162: PPUSH
4163: LD_INT 10
4165: PUSH
4166: LD_INT 15
4168: PUSH
4169: LD_INT 20
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: LIST
4176: PUSH
4177: LD_OWVAR 67
4181: ARRAY
4182: PPUSH
4183: CALL 3101 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4187: LD_INT 5
4189: PPUSH
4190: LD_INT 7
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: LD_INT 18
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 67
4208: ARRAY
4209: PPUSH
4210: CALL 3101 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4214: LD_INT 7
4216: PPUSH
4217: LD_INT 5
4219: PUSH
4220: LD_INT 11
4222: PUSH
4223: LD_INT 17
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: LIST
4230: PUSH
4231: LD_OWVAR 67
4235: ARRAY
4236: PPUSH
4237: CALL 3101 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4241: LD_INT 6
4243: PPUSH
4244: LD_INT 0
4246: PUSH
4247: LD_INT 3
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: PUSH
4258: LD_OWVAR 67
4262: ARRAY
4263: PPUSH
4264: CALL 3101 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4268: LD_INT 8
4270: PPUSH
4271: LD_INT 2
4273: PUSH
4274: LD_INT 5
4276: PUSH
4277: LD_INT 8
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: LIST
4284: PUSH
4285: LD_OWVAR 67
4289: ARRAY
4290: PPUSH
4291: CALL 3101 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4295: LD_INT 9
4297: PPUSH
4298: LD_INT 0
4300: PUSH
4301: LD_INT 2
4303: PUSH
4304: LD_INT 4
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: LD_OWVAR 67
4316: ARRAY
4317: PPUSH
4318: CALL 3101 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4322: LD_INT 10
4324: PPUSH
4325: LD_INT 0
4327: PUSH
4328: LD_INT 1
4330: PUSH
4331: LD_INT 1
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: PUSH
4339: LD_OWVAR 67
4343: ARRAY
4344: PPUSH
4345: CALL 3101 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4349: LD_INT 12
4351: PPUSH
4352: LD_INT 0
4354: PUSH
4355: LD_INT 1
4357: PUSH
4358: LD_INT 1
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: LD_OWVAR 67
4370: ARRAY
4371: PPUSH
4372: CALL 3101 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4376: LD_ADDR_VAR 0 2
4380: PUSH
4381: DOUBLE
4382: LD_INT 1
4384: DEC
4385: ST_TO_ADDR
4386: LD_INT 8
4388: PUSH
4389: LD_INT 11
4391: PUSH
4392: LD_INT 14
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PUSH
4406: FOR_TO
4407: IFFALSE 4582
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4409: LD_ADDR_VAR 0 4
4413: PUSH
4414: LD_INT 134
4416: PPUSH
4417: LD_INT 73
4419: PPUSH
4420: LD_INT 10
4422: PPUSH
4423: LD_INT 0
4425: PPUSH
4426: CALL_OW 17
4430: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4431: LD_VAR 0 4
4435: PUSH
4436: LD_INT 1
4438: ARRAY
4439: PPUSH
4440: LD_VAR 0 4
4444: PUSH
4445: LD_INT 2
4447: ARRAY
4448: PPUSH
4449: CALL_OW 428
4453: PUSH
4454: LD_INT 0
4456: EQUAL
4457: PUSH
4458: LD_VAR 0 4
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_VAR 0 4
4471: PUSH
4472: LD_INT 2
4474: ARRAY
4475: PPUSH
4476: CALL_OW 458
4480: NOT
4481: AND
4482: IFFALSE 4580
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4484: LD_ADDR_EXP 17
4488: PUSH
4489: LD_EXP 17
4493: PPUSH
4494: LD_EXP 17
4498: PUSH
4499: LD_INT 1
4501: PLUS
4502: PPUSH
4503: LD_VAR 0 4
4507: PUSH
4508: LD_INT 1
4510: ARRAY
4511: PPUSH
4512: CALL_OW 2
4516: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4517: LD_ADDR_EXP 17
4521: PUSH
4522: LD_EXP 17
4526: PPUSH
4527: LD_EXP 17
4531: PUSH
4532: LD_INT 1
4534: PLUS
4535: PPUSH
4536: LD_VAR 0 4
4540: PUSH
4541: LD_INT 2
4543: ARRAY
4544: PPUSH
4545: CALL_OW 2
4549: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 2
4566: ARRAY
4567: PPUSH
4568: LD_EXP 8
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 454
// end ; end ;
4580: GO 4406
4582: POP
4583: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4584: LD_ADDR_VAR 0 2
4588: PUSH
4589: LD_INT 22
4591: PUSH
4592: LD_VAR 0 5
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 30
4603: PUSH
4604: LD_INT 32
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PPUSH
4615: CALL_OW 69
4619: PUSH
4620: FOR_IN
4621: IFFALSE 4653
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4623: LD_VAR 0 2
4627: PPUSH
4628: LD_VAR 0 8
4632: PUSH
4633: LD_INT 1
4635: PPUSH
4636: LD_VAR 0 8
4640: PPUSH
4641: CALL_OW 12
4645: ARRAY
4646: PPUSH
4647: CALL_OW 431
4651: GO 4620
4653: POP
4654: POP
// uc_side := side ;
4655: LD_ADDR_OWVAR 20
4659: PUSH
4660: LD_VAR 0 5
4664: ST_TO_ADDR
// uc_nation := 2 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 2
4672: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4673: LD_ADDR_VAR 0 2
4677: PUSH
4678: DOUBLE
4679: LD_INT 1
4681: DEC
4682: ST_TO_ADDR
4683: LD_INT 1
4685: PUSH
4686: LD_OWVAR 67
4690: PLUS
4691: PUSH
4692: FOR_TO
4693: IFFALSE 4783
// begin vc_chassis := ar_half_tracked ;
4695: LD_ADDR_OWVAR 37
4699: PUSH
4700: LD_INT 14
4702: ST_TO_ADDR
// vc_engine := engine_combustion ;
4703: LD_ADDR_OWVAR 39
4707: PUSH
4708: LD_INT 1
4710: ST_TO_ADDR
// vc_control := control_manual ;
4711: LD_ADDR_OWVAR 38
4715: PUSH
4716: LD_INT 1
4718: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4719: LD_ADDR_OWVAR 40
4723: PUSH
4724: LD_INT 31
4726: ST_TO_ADDR
// veh := CreateVehicle ;
4727: LD_ADDR_VAR 0 7
4731: PUSH
4732: CALL_OW 45
4736: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4737: LD_VAR 0 7
4741: PPUSH
4742: LD_INT 3
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4752: LD_INT 0
4754: PPUSH
4755: LD_INT 3
4757: PPUSH
4758: LD_VAR 0 9
4762: PPUSH
4763: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4767: CALL_OW 44
4771: PPUSH
4772: LD_VAR 0 7
4776: PPUSH
4777: CALL_OW 52
// end ;
4781: GO 4692
4783: POP
4784: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4785: LD_ADDR_VAR 0 2
4789: PUSH
4790: LD_INT 22
4792: PUSH
4793: LD_VAR 0 5
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PUSH
4802: LD_INT 30
4804: PUSH
4805: LD_INT 32
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PPUSH
4816: CALL_OW 69
4820: PUSH
4821: FOR_IN
4822: IFFALSE 4855
// begin PrepareHuman ( false , 1 , skill ) ;
4824: LD_INT 0
4826: PPUSH
4827: LD_INT 1
4829: PPUSH
4830: LD_VAR 0 9
4834: PPUSH
4835: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4839: CALL_OW 44
4843: PPUSH
4844: LD_VAR 0 2
4848: PPUSH
4849: CALL_OW 52
// end ;
4853: GO 4821
4855: POP
4856: POP
// for i = 1 to 4 do
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: DOUBLE
4863: LD_INT 1
4865: DEC
4866: ST_TO_ADDR
4867: LD_INT 4
4869: PUSH
4870: FOR_TO
4871: IFFALSE 4902
// begin PrepareHuman ( false , 2 , skill ) ;
4873: LD_INT 0
4875: PPUSH
4876: LD_INT 2
4878: PPUSH
4879: LD_VAR 0 9
4883: PPUSH
4884: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4888: CALL_OW 44
4892: PPUSH
4893: LD_INT 2
4895: PPUSH
4896: CALL_OW 52
// end ;
4900: GO 4870
4902: POP
4903: POP
// for i = 1 to 6 do
4904: LD_ADDR_VAR 0 2
4908: PUSH
4909: DOUBLE
4910: LD_INT 1
4912: DEC
4913: ST_TO_ADDR
4914: LD_INT 6
4916: PUSH
4917: FOR_TO
4918: IFFALSE 4949
// begin PrepareHuman ( false , 3 , skill ) ;
4920: LD_INT 0
4922: PPUSH
4923: LD_INT 3
4925: PPUSH
4926: LD_VAR 0 9
4930: PPUSH
4931: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4935: CALL_OW 44
4939: PPUSH
4940: LD_INT 12
4942: PPUSH
4943: CALL_OW 52
// end ;
4947: GO 4917
4949: POP
4950: POP
// for i = 1 to 4 do
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_INT 4
4963: PUSH
4964: FOR_TO
4965: IFFALSE 5022
// begin PrepareHuman ( false , 4 , skill ) ;
4967: LD_INT 0
4969: PPUSH
4970: LD_INT 4
4972: PPUSH
4973: LD_VAR 0 9
4977: PPUSH
4978: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4982: CALL_OW 44
4986: PPUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 8
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PPUSH
4997: CALL_OW 69
5001: PUSH
5002: LD_VAR 0 2
5006: PUSH
5007: LD_INT 2
5009: MOD
5010: PUSH
5011: LD_INT 1
5013: PLUS
5014: ARRAY
5015: PPUSH
5016: CALL_OW 52
// end ;
5020: GO 4964
5022: POP
5023: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5024: LD_INT 0
5026: PPUSH
5027: LD_INT 8
5029: PPUSH
5030: LD_VAR 0 9
5034: PPUSH
5035: CALL_OW 380
// un := CreateHuman ;
5039: LD_ADDR_VAR 0 6
5043: PUSH
5044: CALL_OW 44
5048: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5049: LD_VAR 0 6
5053: PPUSH
5054: LD_INT 2
5056: PPUSH
5057: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5061: LD_VAR 0 6
5065: PPUSH
5066: LD_INT 31
5068: PPUSH
5069: CALL_OW 52
// for i = 1 to 4 do
5073: LD_ADDR_VAR 0 2
5077: PUSH
5078: DOUBLE
5079: LD_INT 1
5081: DEC
5082: ST_TO_ADDR
5083: LD_INT 4
5085: PUSH
5086: FOR_TO
5087: IFFALSE 5143
// begin uc_nation := 0 ;
5089: LD_ADDR_OWVAR 21
5093: PUSH
5094: LD_INT 0
5096: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5097: LD_INT 0
5099: PPUSH
5100: LD_INT 16
5102: PPUSH
5103: LD_INT 1
5105: PPUSH
5106: CALL_OW 380
// un := CreateHuman ;
5110: LD_ADDR_VAR 0 6
5114: PUSH
5115: CALL_OW 44
5119: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5120: LD_VAR 0 6
5124: PPUSH
5125: LD_INT 106
5127: PPUSH
5128: LD_INT 46
5130: PPUSH
5131: LD_INT 8
5133: PPUSH
5134: LD_INT 0
5136: PPUSH
5137: CALL_OW 50
// end ;
5141: GO 5086
5143: POP
5144: POP
// for i = 1 to 2 * Difficulty do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: DOUBLE
5151: LD_INT 1
5153: DEC
5154: ST_TO_ADDR
5155: LD_INT 2
5157: PUSH
5158: LD_OWVAR 67
5162: MUL
5163: PUSH
5164: FOR_TO
5165: IFFALSE 5205
// begin uc_nation := 0 ;
5167: LD_ADDR_OWVAR 21
5171: PUSH
5172: LD_INT 0
5174: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5175: LD_INT 0
5177: PPUSH
5178: LD_INT 15
5180: PPUSH
5181: LD_INT 3
5183: PPUSH
5184: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5188: CALL_OW 44
5192: PPUSH
5193: LD_INT 20
5195: PPUSH
5196: LD_INT 0
5198: PPUSH
5199: CALL_OW 49
// end ;
5203: GO 5164
5205: POP
5206: POP
// for i = 1 to 4 * Difficulty do
5207: LD_ADDR_VAR 0 2
5211: PUSH
5212: DOUBLE
5213: LD_INT 1
5215: DEC
5216: ST_TO_ADDR
5217: LD_INT 4
5219: PUSH
5220: LD_OWVAR 67
5224: MUL
5225: PUSH
5226: FOR_TO
5227: IFFALSE 5301
// begin uc_nation := 0 ;
5229: LD_ADDR_OWVAR 21
5233: PUSH
5234: LD_INT 0
5236: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5237: LD_INT 0
5239: PPUSH
5240: LD_INT 17
5242: PPUSH
5243: LD_INT 3
5245: PPUSH
5246: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5250: LD_ADDR_OWVAR 29
5254: PUSH
5255: LD_INT 11
5257: PUSH
5258: LD_INT 13
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: ST_TO_ADDR
// un := CreateHuman ;
5265: LD_ADDR_VAR 0 6
5269: PUSH
5270: CALL_OW 44
5274: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5275: LD_VAR 0 6
5279: PPUSH
5280: LD_INT 21
5282: PPUSH
5283: LD_INT 0
5285: PPUSH
5286: CALL_OW 49
// ComHold ( un ) ;
5290: LD_VAR 0 6
5294: PPUSH
5295: CALL_OW 140
// end ;
5299: GO 5226
5301: POP
5302: POP
// end ;
5303: LD_VAR 0 1
5307: RET
// every 12 12$00 + 2 2$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5308: LD_INT 22
5310: PUSH
5311: LD_EXP 8
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PUSH
5320: LD_INT 30
5322: PUSH
5323: LD_INT 3
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: PPUSH
5334: CALL_OW 69
5338: IFFALSE 5645
5340: GO 5342
5342: DISABLE
5343: LD_INT 0
5345: PPUSH
5346: PPUSH
5347: PPUSH
// begin enable ;
5348: ENABLE
// if Difficulty < 3 then
5349: LD_OWVAR 67
5353: PUSH
5354: LD_INT 3
5356: LESS
5357: IFFALSE 5366
// wait ( 1 1$00 ) ;
5359: LD_INT 2100
5361: PPUSH
5362: CALL_OW 67
// tmp := queue_codes [ rng ] ;
5366: LD_ADDR_VAR 0 2
5370: PUSH
5371: LD_EXP 23
5375: PUSH
5376: LD_EXP 24
5380: ARRAY
5381: ST_TO_ADDR
// p := 1 ;
5382: LD_ADDR_VAR 0 3
5386: PUSH
5387: LD_INT 1
5389: ST_TO_ADDR
// for i = 1 to veh_counter + [ - 1 , 0 , 1 ] [ Difficulty ] do
5390: LD_ADDR_VAR 0 1
5394: PUSH
5395: DOUBLE
5396: LD_INT 1
5398: DEC
5399: ST_TO_ADDR
5400: LD_EXP 22
5404: PUSH
5405: LD_INT 1
5407: NEG
5408: PUSH
5409: LD_INT 0
5411: PUSH
5412: LD_INT 1
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: PUSH
5420: LD_OWVAR 67
5424: ARRAY
5425: PLUS
5426: PUSH
5427: FOR_TO
5428: IFFALSE 5609
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5430: LD_INT 22
5432: PUSH
5433: LD_EXP 8
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: LD_INT 30
5444: PUSH
5445: LD_INT 3
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: PPUSH
5456: CALL_OW 69
5460: PUSH
5461: LD_INT 1
5463: ARRAY
5464: PPUSH
5465: LD_EXP 21
5469: PUSH
5470: LD_VAR 0 2
5474: PUSH
5475: LD_INT 10
5477: MOD
5478: ARRAY
5479: PUSH
5480: LD_INT 1
5482: ARRAY
5483: PPUSH
5484: LD_EXP 21
5488: PUSH
5489: LD_VAR 0 2
5493: PUSH
5494: LD_INT 10
5496: MOD
5497: ARRAY
5498: PUSH
5499: LD_INT 2
5501: ARRAY
5502: PPUSH
5503: LD_EXP 21
5507: PUSH
5508: LD_VAR 0 2
5512: PUSH
5513: LD_INT 10
5515: MOD
5516: ARRAY
5517: PUSH
5518: LD_INT 3
5520: ARRAY
5521: PPUSH
5522: LD_EXP 21
5526: PUSH
5527: LD_VAR 0 2
5531: PUSH
5532: LD_INT 10
5534: MOD
5535: ARRAY
5536: PUSH
5537: LD_INT 4
5539: ARRAY
5540: PPUSH
5541: CALL_OW 185
// tmp := tmp / 10 ;
5545: LD_ADDR_VAR 0 2
5549: PUSH
5550: LD_VAR 0 2
5554: PUSH
5555: LD_INT 10
5557: DIVREAL
5558: ST_TO_ADDR
// p := p + 1 ;
5559: LD_ADDR_VAR 0 3
5563: PUSH
5564: LD_VAR 0 3
5568: PUSH
5569: LD_INT 1
5571: PLUS
5572: ST_TO_ADDR
// if p > 5 then
5573: LD_VAR 0 3
5577: PUSH
5578: LD_INT 5
5580: GREATER
5581: IFFALSE 5607
// begin p := 1 ;
5583: LD_ADDR_VAR 0 3
5587: PUSH
5588: LD_INT 1
5590: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5591: LD_ADDR_VAR 0 2
5595: PUSH
5596: LD_EXP 23
5600: PUSH
5601: LD_EXP 24
5605: ARRAY
5606: ST_TO_ADDR
// end ; end ;
5607: GO 5427
5609: POP
5610: POP
// rng := rng + 1 ;
5611: LD_ADDR_EXP 24
5615: PUSH
5616: LD_EXP 24
5620: PUSH
5621: LD_INT 1
5623: PLUS
5624: ST_TO_ADDR
// if rng > queue_codes then
5625: LD_EXP 24
5629: PUSH
5630: LD_EXP 23
5634: GREATER
5635: IFFALSE 5645
// rng := 1 ;
5637: LD_ADDR_EXP 24
5641: PUSH
5642: LD_INT 1
5644: ST_TO_ADDR
// end ;
5645: PPOPN 3
5647: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5648: LD_INT 25
5650: PUSH
5651: LD_INT 17
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PPUSH
5658: CALL_OW 69
5662: IFFALSE 5765
5664: GO 5666
5666: DISABLE
5667: LD_INT 0
5669: PPUSH
5670: PPUSH
// begin enable ;
5671: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5672: LD_ADDR_VAR 0 1
5676: PUSH
5677: LD_INT 25
5679: PUSH
5680: LD_INT 17
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PPUSH
5687: CALL_OW 69
5691: PUSH
5692: FOR_IN
5693: IFFALSE 5763
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5695: LD_ADDR_VAR 0 2
5699: PUSH
5700: LD_INT 81
5702: PUSH
5703: LD_EXP 8
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL_OW 69
5716: PPUSH
5717: LD_VAR 0 1
5721: PPUSH
5722: CALL_OW 74
5726: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5727: LD_VAR 0 1
5731: PPUSH
5732: LD_VAR 0 2
5736: PPUSH
5737: CALL_OW 296
5741: PUSH
5742: LD_INT 15
5744: LESS
5745: IFFALSE 5761
// ComAttackUnit ( i , un ) ;
5747: LD_VAR 0 1
5751: PPUSH
5752: LD_VAR 0 2
5756: PPUSH
5757: CALL_OW 115
// end ;
5761: GO 5692
5763: POP
5764: POP
// end ;
5765: PPOPN 2
5767: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5768: LD_EXP 20
5772: IFFALSE 5839
5774: GO 5776
5776: DISABLE
5777: LD_INT 0
5779: PPUSH
// begin enable ;
5780: ENABLE
// for i in attackers do
5781: LD_ADDR_VAR 0 1
5785: PUSH
5786: LD_EXP 20
5790: PUSH
5791: FOR_IN
5792: IFFALSE 5837
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
5794: LD_VAR 0 1
5798: PPUSH
5799: LD_INT 81
5801: PUSH
5802: LD_VAR 0 1
5806: PPUSH
5807: CALL_OW 255
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 69
5820: PPUSH
5821: LD_VAR 0 1
5825: PPUSH
5826: CALL_OW 74
5830: PPUSH
5831: CALL_OW 115
5835: GO 5791
5837: POP
5838: POP
// end ;
5839: PPOPN 1
5841: END
// every 0 0$01 trigger not attackers marked 17 do
5842: LD_EXP 20
5846: NOT
5847: IFFALSE 5856
5849: GO 5851
5851: DISABLE
// begin enable ;
5852: ENABLE
// disable ( 17 ) ;
5853: LD_INT 17
5855: DISABLE_MARKED
// end ;
5856: END
// every 1 1$00 trigger veh_counter <= attackers do var max , i ;
5857: LD_EXP 22
5861: PUSH
5862: LD_EXP 20
5866: LESSEQUAL
5867: IFFALSE 5880
5869: GO 5871
5871: DISABLE
5872: LD_INT 0
5874: PPUSH
5875: PPUSH
// begin enable ;
5876: ENABLE
// enable ( 17 ) ;
5877: LD_INT 17
5879: ENABLE_MARKED
// end ;
5880: PPOPN 2
5882: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5883: LD_EXP 9
5887: PUSH
5888: LD_OWVAR 1
5892: PUSH
5893: LD_INT 63000
5895: GREATEREQUAL
5896: AND
5897: IFFALSE 5916
5899: GO 5901
5901: DISABLE
// begin veh_counter := veh_counter + 1 ;
5902: LD_ADDR_EXP 22
5906: PUSH
5907: LD_EXP 22
5911: PUSH
5912: LD_INT 1
5914: PLUS
5915: ST_TO_ADDR
// end ;
5916: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
5917: LD_EXP 9
5921: PUSH
5922: LD_OWVAR 1
5926: PUSH
5927: LD_INT 105000
5929: GREATEREQUAL
5930: AND
5931: IFFALSE 5950
5933: GO 5935
5935: DISABLE
// begin veh_counter := veh_counter + 2 ;
5936: LD_ADDR_EXP 22
5940: PUSH
5941: LD_EXP 22
5945: PUSH
5946: LD_INT 2
5948: PLUS
5949: ST_TO_ADDR
// end ;
5950: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
5951: LD_EXP 9
5955: PUSH
5956: LD_OWVAR 1
5960: PUSH
5961: LD_INT 168000
5963: GREATEREQUAL
5964: AND
5965: IFFALSE 5984
5967: GO 5969
5969: DISABLE
// begin veh_counter := veh_counter + 3 ;
5970: LD_ADDR_EXP 22
5974: PUSH
5975: LD_EXP 22
5979: PUSH
5980: LD_INT 3
5982: PLUS
5983: ST_TO_ADDR
// end ;
5984: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
5985: LD_INT 22
5987: PUSH
5988: LD_EXP 8
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 33
5999: PUSH
6000: LD_INT 2
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 69
6015: IFFALSE 6231
6017: GO 6019
6019: DISABLE
6020: LD_INT 0
6022: PPUSH
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
6027: PPUSH
6028: PPUSH
// begin enable ;
6029: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6030: LD_ADDR_VAR 0 4
6034: PUSH
6035: LD_INT 22
6037: PUSH
6038: LD_EXP 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 33
6049: PUSH
6050: LD_INT 2
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: PUSH
6057: LD_INT 3
6059: PUSH
6060: LD_INT 61
6062: PUSH
6063: EMPTY
6064: LIST
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 69
6079: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 22
6087: PUSH
6088: LD_EXP 8
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 34
6099: PUSH
6100: LD_INT 31
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PPUSH
6111: CALL_OW 69
6115: ST_TO_ADDR
// best := 10 ;
6116: LD_ADDR_VAR 0 5
6120: PUSH
6121: LD_INT 10
6123: ST_TO_ADDR
// best_mechanic := - 1 ;
6124: LD_ADDR_VAR 0 6
6128: PUSH
6129: LD_INT 1
6131: NEG
6132: ST_TO_ADDR
// if vehs then
6133: LD_VAR 0 4
6137: IFFALSE 6231
// begin for j in cts do
6139: LD_ADDR_VAR 0 2
6143: PUSH
6144: LD_VAR 0 3
6148: PUSH
6149: FOR_IN
6150: IFFALSE 6211
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6152: LD_ADDR_VAR 0 7
6156: PUSH
6157: LD_VAR 0 2
6161: PPUSH
6162: CALL 3453 0 1
6166: PPUSH
6167: CALL_OW 432
6171: ST_TO_ADDR
// if p < best then
6172: LD_VAR 0 7
6176: PUSH
6177: LD_VAR 0 5
6181: LESS
6182: IFFALSE 6209
// begin best := p ;
6184: LD_ADDR_VAR 0 5
6188: PUSH
6189: LD_VAR 0 7
6193: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6194: LD_ADDR_VAR 0 6
6198: PUSH
6199: LD_VAR 0 2
6203: PPUSH
6204: CALL 3453 0 1
6208: ST_TO_ADDR
// end ; end ;
6209: GO 6149
6211: POP
6212: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6213: LD_VAR 0 4
6217: PUSH
6218: LD_INT 1
6220: ARRAY
6221: PPUSH
6222: LD_VAR 0 6
6226: PPUSH
6227: CALL_OW 135
// end ; end ;
6231: PPOPN 7
6233: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6234: GO 6236
6236: DISABLE
6237: LD_INT 0
6239: PPUSH
6240: PPUSH
6241: PPUSH
6242: PPUSH
6243: PPUSH
6244: PPUSH
6245: PPUSH
// begin enable ;
6246: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6247: LD_ADDR_VAR 0 6
6251: PUSH
6252: LD_INT 22
6254: PUSH
6255: LD_EXP 8
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 21
6266: PUSH
6267: LD_INT 3
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: PUSH
6274: LD_INT 3
6276: PUSH
6277: LD_INT 24
6279: PUSH
6280: LD_INT 1000
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PUSH
6287: EMPTY
6288: LIST
6289: LIST
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL_OW 69
6300: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6301: LD_ADDR_VAR 0 3
6305: PUSH
6306: LD_INT 22
6308: PUSH
6309: LD_EXP 8
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 2
6320: PUSH
6321: LD_INT 25
6323: PUSH
6324: LD_INT 1
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 25
6333: PUSH
6334: LD_INT 2
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 25
6343: PUSH
6344: LD_INT 3
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 3
6359: PUSH
6360: LD_INT 24
6362: PUSH
6363: LD_INT 750
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PPUSH
6379: CALL_OW 69
6383: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_EXP 8
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PUSH
6401: LD_INT 25
6403: PUSH
6404: LD_INT 4
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: PPUSH
6415: CALL_OW 69
6419: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6420: LD_ADDR_VAR 0 5
6424: PUSH
6425: LD_INT 22
6427: PUSH
6428: LD_EXP 8
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: LD_INT 2
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PPUSH
6451: CALL_OW 69
6455: ST_TO_ADDR
// if not h and not b then
6456: LD_VAR 0 3
6460: NOT
6461: PUSH
6462: LD_VAR 0 6
6466: NOT
6467: AND
6468: IFFALSE 6752
// begin if sci then
6470: LD_VAR 0 4
6474: IFFALSE 6611
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6476: LD_VAR 0 4
6480: PPUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 54
6486: PUSH
6487: EMPTY
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PPUSH
6494: CALL_OW 72
6498: PUSH
6499: LD_INT 22
6501: PUSH
6502: LD_EXP 8
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: LD_INT 30
6513: PUSH
6514: LD_INT 8
6516: PUSH
6517: EMPTY
6518: LIST
6519: LIST
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PPUSH
6525: CALL_OW 69
6529: AND
6530: IFFALSE 6611
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6532: LD_ADDR_VAR 0 2
6536: PUSH
6537: LD_VAR 0 4
6541: PPUSH
6542: LD_INT 3
6544: PUSH
6545: LD_INT 54
6547: PUSH
6548: EMPTY
6549: LIST
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: PPUSH
6555: CALL_OW 72
6559: PUSH
6560: FOR_IN
6561: IFFALSE 6609
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6563: LD_VAR 0 2
6567: PPUSH
6568: LD_INT 22
6570: PUSH
6571: LD_EXP 8
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 30
6582: PUSH
6583: LD_INT 8
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PPUSH
6594: CALL_OW 69
6598: PUSH
6599: LD_INT 1
6601: ARRAY
6602: PPUSH
6603: CALL_OW 120
6607: GO 6560
6609: POP
6610: POP
// if eng then
6611: LD_VAR 0 5
6615: IFFALSE 6752
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6617: LD_VAR 0 5
6621: PPUSH
6622: LD_INT 3
6624: PUSH
6625: LD_INT 54
6627: PUSH
6628: EMPTY
6629: LIST
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PPUSH
6635: CALL_OW 72
6639: PUSH
6640: LD_INT 22
6642: PUSH
6643: LD_EXP 8
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 30
6654: PUSH
6655: LD_INT 1
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PPUSH
6666: CALL_OW 69
6670: AND
6671: IFFALSE 6752
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_VAR 0 5
6682: PPUSH
6683: LD_INT 3
6685: PUSH
6686: LD_INT 54
6688: PUSH
6689: EMPTY
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PPUSH
6696: CALL_OW 72
6700: PUSH
6701: FOR_IN
6702: IFFALSE 6750
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6704: LD_VAR 0 2
6708: PPUSH
6709: LD_INT 22
6711: PUSH
6712: LD_EXP 8
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 30
6723: PUSH
6724: LD_INT 1
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 69
6739: PUSH
6740: LD_INT 1
6742: ARRAY
6743: PPUSH
6744: CALL_OW 120
6748: GO 6701
6750: POP
6751: POP
// end ; p := 1 ;
6752: LD_ADDR_VAR 0 7
6756: PUSH
6757: LD_INT 1
6759: ST_TO_ADDR
// if b and eng then
6760: LD_VAR 0 6
6764: PUSH
6765: LD_VAR 0 5
6769: AND
6770: IFFALSE 6904
// for j in eng do
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_VAR 0 5
6781: PUSH
6782: FOR_IN
6783: IFFALSE 6902
// begin if IsInUnit ( j ) then
6785: LD_VAR 0 2
6789: PPUSH
6790: CALL_OW 310
6794: IFFALSE 6807
// ComExitBuilding ( j ) else
6796: LD_VAR 0 2
6800: PPUSH
6801: CALL_OW 122
6805: GO 6900
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6807: LD_VAR 0 2
6811: PPUSH
6812: CALL_OW 314
6816: NOT
6817: PUSH
6818: LD_VAR 0 2
6822: PPUSH
6823: CALL_OW 256
6827: PUSH
6828: LD_INT 750
6830: GREATER
6831: AND
6832: IFFALSE 6900
// begin if b > p then
6834: LD_VAR 0 6
6838: PUSH
6839: LD_VAR 0 7
6843: GREATER
6844: IFFALSE 6882
// begin ComRepairBuilding ( j , b [ p ] ) ;
6846: LD_VAR 0 2
6850: PPUSH
6851: LD_VAR 0 6
6855: PUSH
6856: LD_VAR 0 7
6860: ARRAY
6861: PPUSH
6862: CALL_OW 130
// p := p + 1 ;
6866: LD_ADDR_VAR 0 7
6870: PUSH
6871: LD_VAR 0 7
6875: PUSH
6876: LD_INT 1
6878: PLUS
6879: ST_TO_ADDR
// end else
6880: GO 6900
// ComRepairBuilding ( j , b [ 1 ] ) ;
6882: LD_VAR 0 2
6886: PPUSH
6887: LD_VAR 0 6
6891: PUSH
6892: LD_INT 1
6894: ARRAY
6895: PPUSH
6896: CALL_OW 130
// end ; end ;
6900: GO 6782
6902: POP
6903: POP
// if h and sci then
6904: LD_VAR 0 3
6908: PUSH
6909: LD_VAR 0 4
6913: AND
6914: IFFALSE 7053
// for i in h do
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_VAR 0 3
6925: PUSH
6926: FOR_IN
6927: IFFALSE 7051
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_INT 108
6936: PPUSH
6937: LD_INT 42
6939: PPUSH
6940: CALL_OW 297
6944: PUSH
6945: LD_INT 10
6947: GREATER
6948: IFFALSE 6967
// ComMoveXY ( i , 108 , 42 ) else
6950: LD_VAR 0 1
6954: PPUSH
6955: LD_INT 108
6957: PPUSH
6958: LD_INT 42
6960: PPUSH
6961: CALL_OW 111
6965: GO 7049
// begin for j in sci do
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 4
6976: PUSH
6977: FOR_IN
6978: IFFALSE 7047
// begin if GetTag ( j ) > 0 then
6980: LD_VAR 0 2
6984: PPUSH
6985: CALL_OW 110
6989: PUSH
6990: LD_INT 0
6992: GREATER
6993: IFFALSE 6997
// continue ;
6995: GO 6977
// if IsInUnit ( j ) then
6997: LD_VAR 0 2
7001: PPUSH
7002: CALL_OW 310
7006: IFFALSE 7019
// ComExitBuilding ( j ) else
7008: LD_VAR 0 2
7012: PPUSH
7013: CALL_OW 122
7017: GO 7045
// if not HasTask ( j ) then
7019: LD_VAR 0 2
7023: PPUSH
7024: CALL_OW 314
7028: NOT
7029: IFFALSE 7045
// ComHeal ( j , h ) ;
7031: LD_VAR 0 2
7035: PPUSH
7036: LD_VAR 0 3
7040: PPUSH
7041: CALL_OW 128
// end ;
7045: GO 6977
7047: POP
7048: POP
// end ;
7049: GO 6926
7051: POP
7052: POP
// end ;
7053: PPOPN 7
7055: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7056: LD_INT 155
7058: PPUSH
7059: LD_INT 88
7061: PPUSH
7062: CALL_OW 428
7066: PUSH
7067: LD_INT 155
7069: PPUSH
7070: LD_INT 88
7072: PPUSH
7073: CALL_OW 428
7077: PUSH
7078: LD_INT 30
7080: EQUAL
7081: PPUSH
7082: CALL_OW 266
7086: AND
7087: IFFALSE 7336
7089: GO 7091
7091: DISABLE
7092: LD_INT 0
7094: PPUSH
7095: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7096: LD_ADDR_VAR 0 2
7100: PUSH
7101: LD_INT 155
7103: PPUSH
7104: LD_INT 88
7106: PPUSH
7107: CALL_OW 428
7111: PPUSH
7112: CALL_OW 255
7116: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7117: LD_INT 11550
7119: PUSH
7120: LD_INT 13755
7122: PUSH
7123: LD_INT 13335
7125: PUSH
7126: LD_INT 18340
7128: PUSH
7129: LD_INT 19985
7131: PUSH
7132: LD_INT 9555
7134: PUSH
7135: LD_INT 18935
7137: PUSH
7138: LD_INT 10535
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: PUSH
7151: LD_VAR 0 2
7155: ARRAY
7156: PPUSH
7157: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7161: LD_INT 22
7163: PUSH
7164: LD_EXP 8
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 25
7175: PUSH
7176: LD_INT 4
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 69
7191: PUSH
7192: LD_INT 0
7194: EQUAL
7195: IFFALSE 7199
// exit ;
7197: GO 7336
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7199: LD_ADDR_VAR 0 1
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_EXP 8
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: LD_INT 25
7218: PUSH
7219: LD_INT 4
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: PPUSH
7230: CALL_OW 69
7234: PUSH
7235: LD_INT 1
7237: ARRAY
7238: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7239: LD_VAR 0 1
7243: PPUSH
7244: LD_INT 1
7246: PPUSH
7247: CALL_OW 109
// ComExitBuilding ( sci ) ;
7251: LD_VAR 0 1
7255: PPUSH
7256: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7260: LD_VAR 0 1
7264: PPUSH
7265: LD_INT 126
7267: PPUSH
7268: LD_INT 59
7270: PPUSH
7271: CALL_OW 171
// if p mod 2 = 0 then
7275: LD_VAR 0 2
7279: PUSH
7280: LD_INT 2
7282: MOD
7283: PUSH
7284: LD_INT 0
7286: EQUAL
7287: IFFALSE 7306
// AddComMoveXY ( sci , 148 , 66 ) else
7289: LD_VAR 0 1
7293: PPUSH
7294: LD_INT 148
7296: PPUSH
7297: LD_INT 66
7299: PPUSH
7300: CALL_OW 171
7304: GO 7321
// AddComMoveXY ( sci , 135 , 84 ) ;
7306: LD_VAR 0 1
7310: PPUSH
7311: LD_INT 135
7313: PPUSH
7314: LD_INT 84
7316: PPUSH
7317: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7321: LD_VAR 0 1
7325: PPUSH
7326: LD_INT 155
7328: PPUSH
7329: LD_INT 88
7331: PPUSH
7332: CALL_OW 218
// end ;
7336: PPOPN 2
7338: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7339: LD_INT 33
7341: PPUSH
7342: LD_INT 10
7344: PPUSH
7345: CALL_OW 428
7349: PUSH
7350: LD_INT 33
7352: PPUSH
7353: LD_INT 10
7355: PPUSH
7356: CALL_OW 428
7360: PUSH
7361: LD_INT 30
7363: EQUAL
7364: PPUSH
7365: CALL_OW 266
7369: AND
7370: IFFALSE 7621
7372: GO 7374
7374: DISABLE
7375: LD_INT 0
7377: PPUSH
7378: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7379: LD_ADDR_VAR 0 2
7383: PUSH
7384: LD_INT 33
7386: PPUSH
7387: LD_INT 10
7389: PPUSH
7390: CALL_OW 428
7394: PPUSH
7395: CALL_OW 255
7399: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7400: LD_INT 9450
7402: PUSH
7403: LD_INT 11655
7405: PUSH
7406: LD_INT 7035
7408: PUSH
7409: LD_INT 9940
7411: PUSH
7412: LD_INT 7385
7414: PUSH
7415: LD_INT 11655
7417: PUSH
7418: LD_INT 6335
7420: PUSH
7421: LD_INT 16835
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: LD_VAR 0 2
7438: ARRAY
7439: PPUSH
7440: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7444: LD_INT 22
7446: PUSH
7447: LD_EXP 8
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 25
7458: PUSH
7459: LD_INT 4
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: LD_INT 0
7477: EQUAL
7478: IFFALSE 7482
// exit ;
7480: GO 7621
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_EXP 8
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 25
7501: PUSH
7502: LD_INT 4
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PPUSH
7513: CALL_OW 69
7517: PUSH
7518: LD_VAR 0 1
7522: ARRAY
7523: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7524: LD_VAR 0 1
7528: PPUSH
7529: LD_INT 1
7531: PPUSH
7532: CALL_OW 109
// ComExitBuilding ( sci ) ;
7536: LD_VAR 0 1
7540: PPUSH
7541: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7545: LD_VAR 0 1
7549: PPUSH
7550: LD_INT 67
7552: PPUSH
7553: LD_INT 13
7555: PPUSH
7556: CALL_OW 171
// if p mod 2 = 0 then
7560: LD_VAR 0 2
7564: PUSH
7565: LD_INT 2
7567: MOD
7568: PUSH
7569: LD_INT 0
7571: EQUAL
7572: IFFALSE 7591
// AddComMoveXY ( sci , 37 , 3 ) else
7574: LD_VAR 0 1
7578: PPUSH
7579: LD_INT 37
7581: PPUSH
7582: LD_INT 3
7584: PPUSH
7585: CALL_OW 171
7589: GO 7606
// AddComMoveXY ( sci , 45 , 20 ) ;
7591: LD_VAR 0 1
7595: PPUSH
7596: LD_INT 45
7598: PPUSH
7599: LD_INT 20
7601: PPUSH
7602: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7606: LD_VAR 0 1
7610: PPUSH
7611: LD_INT 33
7613: PPUSH
7614: LD_INT 10
7616: PPUSH
7617: CALL_OW 218
// end ;
7621: PPOPN 2
7623: END
// every 0 0$01 trigger mines_list do var i , p ;
7624: LD_EXP 17
7628: IFFALSE 7854
7630: GO 7632
7632: DISABLE
7633: LD_INT 0
7635: PPUSH
7636: PPUSH
// begin enable ;
7637: ENABLE
// p := 1 ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 1
7645: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7646: LD_ADDR_VAR 0 1
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_EXP 17
7660: PUSH
7661: LD_INT 2
7663: DIVREAL
7664: PUSH
7665: FOR_TO
7666: IFFALSE 7852
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7668: LD_EXP 17
7672: PUSH
7673: LD_VAR 0 2
7677: ARRAY
7678: PPUSH
7679: LD_EXP 17
7683: PUSH
7684: LD_VAR 0 2
7688: PUSH
7689: LD_INT 1
7691: PLUS
7692: ARRAY
7693: PPUSH
7694: CALL_OW 428
7698: PUSH
7699: LD_INT 0
7701: GREATER
7702: IFFALSE 7836
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7704: LD_EXP 17
7708: PUSH
7709: LD_VAR 0 2
7713: ARRAY
7714: PPUSH
7715: LD_EXP 17
7719: PUSH
7720: LD_VAR 0 2
7724: PUSH
7725: LD_INT 1
7727: PLUS
7728: ARRAY
7729: PPUSH
7730: CALL_OW 428
7734: PPUSH
7735: CALL_OW 255
7739: PUSH
7740: LD_EXP 8
7744: NONEQUAL
7745: IFFALSE 7836
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7747: LD_EXP 17
7751: PUSH
7752: LD_VAR 0 2
7756: ARRAY
7757: PPUSH
7758: LD_EXP 17
7762: PUSH
7763: LD_VAR 0 2
7767: PUSH
7768: LD_INT 1
7770: PLUS
7771: ARRAY
7772: PPUSH
7773: LD_EXP 8
7777: PPUSH
7778: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7782: LD_ADDR_EXP 17
7786: PUSH
7787: LD_EXP 17
7791: PPUSH
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 3
7801: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7802: LD_ADDR_EXP 17
7806: PUSH
7807: LD_EXP 17
7811: PPUSH
7812: LD_VAR 0 2
7816: PPUSH
7817: CALL_OW 3
7821: ST_TO_ADDR
// p := p - 2 ;
7822: LD_ADDR_VAR 0 2
7826: PUSH
7827: LD_VAR 0 2
7831: PUSH
7832: LD_INT 2
7834: MINUS
7835: ST_TO_ADDR
// end ; p := p + 2 ;
7836: LD_ADDR_VAR 0 2
7840: PUSH
7841: LD_VAR 0 2
7845: PUSH
7846: LD_INT 2
7848: PLUS
7849: ST_TO_ADDR
// end ;
7850: GO 7665
7852: POP
7853: POP
// end ;
7854: PPOPN 2
7856: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7857: GO 7859
7859: DISABLE
7860: LD_INT 0
7862: PPUSH
7863: PPUSH
7864: PPUSH
7865: PPUSH
7866: PPUSH
// begin enable ;
7867: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 50
7875: PUSH
7876: EMPTY
7877: LIST
7878: PUSH
7879: LD_INT 22
7881: PUSH
7882: LD_EXP 8
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: PUSH
7891: LD_INT 25
7893: PUSH
7894: LD_INT 16
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL_OW 69
7910: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7911: LD_ADDR_VAR 0 5
7915: PUSH
7916: LD_INT 22
7918: PUSH
7919: LD_EXP 8
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: LD_INT 2
7930: PUSH
7931: LD_INT 30
7933: PUSH
7934: LD_INT 0
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 30
7943: PUSH
7944: LD_INT 1
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 69
7964: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
7965: LD_ADDR_VAR 0 3
7969: PUSH
7970: LD_INT 13
7972: PPUSH
7973: CALL_OW 435
7977: ST_TO_ADDR
// if filter and skr then
7978: LD_VAR 0 4
7982: PUSH
7983: LD_VAR 0 3
7987: AND
7988: IFFALSE 8063
// for i = 1 to filter do
7990: LD_ADDR_VAR 0 1
7994: PUSH
7995: DOUBLE
7996: LD_INT 1
7998: DEC
7999: ST_TO_ADDR
8000: LD_VAR 0 4
8004: PUSH
8005: FOR_TO
8006: IFFALSE 8061
// if not HasTask ( filter [ i ] ) then
8008: LD_VAR 0 4
8012: PUSH
8013: LD_VAR 0 1
8017: ARRAY
8018: PPUSH
8019: CALL_OW 314
8023: NOT
8024: IFFALSE 8059
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8026: LD_VAR 0 4
8030: PUSH
8031: LD_VAR 0 1
8035: ARRAY
8036: PPUSH
8037: LD_VAR 0 3
8041: PUSH
8042: LD_INT 1
8044: ARRAY
8045: PPUSH
8046: LD_VAR 0 3
8050: PUSH
8051: LD_INT 2
8053: ARRAY
8054: PPUSH
8055: CALL_OW 117
8059: GO 8005
8061: POP
8062: POP
// end ; end_of_file
8063: PPOPN 5
8065: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8066: LD_INT 0
8068: PPUSH
8069: PPUSH
8070: PPUSH
8071: PPUSH
// begin if un in attackers then
8072: LD_VAR 0 1
8076: PUSH
8077: LD_EXP 20
8081: IN
8082: IFFALSE 8100
// attackers := attackers diff un ;
8084: LD_ADDR_EXP 20
8088: PUSH
8089: LD_EXP 20
8093: PUSH
8094: LD_VAR 0 1
8098: DIFF
8099: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 255
8109: PUSH
8110: LD_EXP 8
8114: NONEQUAL
8115: PUSH
8116: LD_VAR 0 1
8120: PPUSH
8121: CALL_OW 255
8125: PUSH
8126: LD_INT 0
8128: GREATER
8129: AND
8130: PUSH
8131: LD_VAR 0 1
8135: PUSH
8136: LD_INT 21
8138: PUSH
8139: LD_INT 1
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PPUSH
8146: CALL_OW 69
8150: IN
8151: AND
8152: IFFALSE 8336
// begin if respawning_time_min > 0 0$00 then
8154: LD_EXP 13
8158: PUSH
8159: LD_INT 0
8161: GREATER
8162: IFFALSE 8336
// begin s := GetSide ( un ) ;
8164: LD_ADDR_VAR 0 4
8168: PUSH
8169: LD_VAR 0 1
8173: PPUSH
8174: CALL_OW 255
8178: ST_TO_ADDR
// n := GetNation ( un ) ;
8179: LD_ADDR_VAR 0 5
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 248
8193: ST_TO_ADDR
// cl := GetClass ( un ) ;
8194: LD_ADDR_VAR 0 3
8198: PUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: CALL_OW 257
8208: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8209: LD_EXP 13
8213: PPUSH
8214: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) * cl ) ;
8218: LD_EXP 14
8222: PUSH
8223: LD_INT 350
8225: PUSH
8226: LD_OWVAR 1
8230: MUL
8231: PUSH
8232: LD_INT 10
8234: MOD
8235: PUSH
8236: LD_INT 1
8238: PLUS
8239: PUSH
8240: LD_VAR 0 3
8244: MUL
8245: MINUS
8246: PPUSH
8247: CALL_OW 67
// uc_side := s ;
8251: LD_ADDR_OWVAR 20
8255: PUSH
8256: LD_VAR 0 4
8260: ST_TO_ADDR
// uc_nation := n ;
8261: LD_ADDR_OWVAR 21
8265: PUSH
8266: LD_VAR 0 5
8270: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8271: LD_INT 0
8273: PPUSH
8274: LD_VAR 0 3
8278: PPUSH
8279: LD_EXP 11
8283: PUSH
8284: LD_INT 2
8286: MINUS
8287: PPUSH
8288: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8292: CALL_OW 44
8296: PPUSH
8297: LD_INT 17
8299: PUSH
8300: LD_INT 19
8302: PUSH
8303: LD_INT 18
8305: PUSH
8306: LD_INT 19
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: LD_VAR 0 3
8319: PUSH
8320: LD_INT 4
8322: MOD
8323: PUSH
8324: LD_INT 1
8326: PLUS
8327: ARRAY
8328: PPUSH
8329: LD_INT 1
8331: PPUSH
8332: CALL_OW 49
// end ; end ; end ;
8336: PPOPN 5
8338: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 255
8348: PUSH
8349: LD_EXP 8
8353: EQUAL
8354: PUSH
8355: LD_VAR 0 1
8359: PUSH
8360: LD_INT 33
8362: PUSH
8363: LD_INT 2
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: PUSH
8370: LD_INT 21
8372: PUSH
8373: LD_INT 2
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: IN
8389: AND
8390: IFFALSE 8513
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
8392: LD_OWVAR 3
8396: PUSH
8397: LD_VAR 0 1
8401: DIFF
8402: PPUSH
8403: LD_VAR 0 1
8407: PPUSH
8408: CALL_OW 74
8412: PPUSH
8413: CALL_OW 255
8417: PUSH
8418: LD_EXP 8
8422: NONEQUAL
8423: IFFALSE 8513
// begin Wait ( 0 0$1.3 ) ;
8425: LD_INT 46
8427: PPUSH
8428: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8432: LD_VAR 0 1
8436: PPUSH
8437: CALL_OW 250
8441: PPUSH
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL_OW 251
8451: PPUSH
8452: LD_INT 1
8454: PPUSH
8455: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8459: LD_VAR 0 1
8463: PPUSH
8464: CALL_OW 250
8468: PPUSH
8469: LD_VAR 0 1
8473: PPUSH
8474: CALL_OW 251
8478: PPUSH
8479: LD_INT 1
8481: PPUSH
8482: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8486: LD_VAR 0 1
8490: PPUSH
8491: CALL_OW 250
8495: PPUSH
8496: LD_VAR 0 1
8500: PPUSH
8501: CALL_OW 251
8505: PPUSH
8506: LD_INT 1
8508: PPUSH
8509: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 263
8522: PUSH
8523: LD_INT 2
8525: EQUAL
8526: IFFALSE 8537
// ComUnlink ( un ) ;
8528: LD_VAR 0 1
8532: PPUSH
8533: CALL_OW 136
// end ;
8537: PPOPN 1
8539: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8540: LD_VAR 0 1
8544: PPUSH
8545: CALL_OW 255
8549: PUSH
8550: LD_EXP 8
8554: EQUAL
8555: IFFALSE 8586
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8557: LD_ADDR_EXP 20
8561: PUSH
8562: LD_EXP 20
8566: PPUSH
8567: LD_EXP 20
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: PPUSH
8576: LD_VAR 0 1
8580: PPUSH
8581: CALL_OW 2
8585: ST_TO_ADDR
// end ;
8586: PPOPN 2
8588: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8589: LD_INT 0
8591: PPUSH
8592: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8593: LD_VAR 0 1
8597: PPUSH
8598: CALL_OW 255
8602: PUSH
8603: LD_EXP 8
8607: EQUAL
8608: PUSH
8609: LD_VAR 0 1
8613: PPUSH
8614: CALL_OW 266
8618: PUSH
8619: LD_INT 32
8621: EQUAL
8622: AND
8623: IFFALSE 8721
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8625: LD_ADDR_VAR 0 4
8629: PUSH
8630: LD_INT 22
8632: PUSH
8633: LD_EXP 8
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 5
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PPUSH
8656: CALL_OW 69
8660: ST_TO_ADDR
// for i in arm do
8661: LD_ADDR_VAR 0 3
8665: PUSH
8666: LD_VAR 0 4
8670: PUSH
8671: FOR_IN
8672: IFFALSE 8719
// if UnitsInside ( i ) < 6 then
8674: LD_VAR 0 3
8678: PPUSH
8679: CALL_OW 313
8683: PUSH
8684: LD_INT 6
8686: LESS
8687: IFFALSE 8717
// begin ComEnterUnit ( un , i ) ;
8689: LD_VAR 0 2
8693: PPUSH
8694: LD_VAR 0 3
8698: PPUSH
8699: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8703: LD_VAR 0 2
8707: PPUSH
8708: LD_INT 8
8710: PPUSH
8711: CALL_OW 183
// break ;
8715: GO 8719
// end ;
8717: GO 8671
8719: POP
8720: POP
// end ; end ; end_of_file
8721: PPOPN 4
8723: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
8724: LD_VAR 0 1
8728: PUSH
8729: LD_INT 200
8731: DOUBLE
8732: GREATEREQUAL
8733: IFFALSE 8741
8735: LD_INT 299
8737: DOUBLE
8738: LESSEQUAL
8739: IFTRUE 8743
8741: GO 8775
8743: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
8744: LD_VAR 0 1
8748: PPUSH
8749: LD_VAR 0 2
8753: PPUSH
8754: LD_VAR 0 3
8758: PPUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_VAR 0 5
8768: PPUSH
8769: CALL 37050 0 5
8773: GO 8852
8775: LD_INT 300
8777: DOUBLE
8778: GREATEREQUAL
8779: IFFALSE 8787
8781: LD_INT 399
8783: DOUBLE
8784: LESSEQUAL
8785: IFTRUE 8789
8787: GO 8851
8789: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
8790: LD_VAR 0 1
8794: PPUSH
8795: LD_VAR 0 2
8799: PPUSH
8800: LD_VAR 0 3
8804: PPUSH
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_VAR 0 5
8814: PPUSH
8815: LD_VAR 0 6
8819: PPUSH
8820: LD_VAR 0 7
8824: PPUSH
8825: LD_VAR 0 8
8829: PPUSH
8830: LD_VAR 0 9
8834: PPUSH
8835: LD_VAR 0 10
8839: PPUSH
8840: LD_VAR 0 11
8844: PPUSH
8845: CALL 33383 0 11
8849: GO 8852
8851: POP
// end ;
8852: PPOPN 11
8854: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
8855: LD_VAR 0 1
8859: PPUSH
8860: LD_VAR 0 2
8864: PPUSH
8865: LD_VAR 0 3
8869: PPUSH
8870: LD_VAR 0 4
8874: PPUSH
8875: LD_VAR 0 5
8879: PPUSH
8880: CALL 36786 0 5
// end ; end_of_file
8884: PPOPN 5
8886: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
8887: LD_INT 0
8889: PPUSH
8890: PPUSH
// if exist_mode then
8891: LD_VAR 0 2
8895: IFFALSE 8920
// unit := CreateCharacter ( prefix & ident ) else
8897: LD_ADDR_VAR 0 5
8901: PUSH
8902: LD_VAR 0 3
8906: PUSH
8907: LD_VAR 0 1
8911: STR
8912: PPUSH
8913: CALL_OW 34
8917: ST_TO_ADDR
8918: GO 8935
// unit := NewCharacter ( ident ) ;
8920: LD_ADDR_VAR 0 5
8924: PUSH
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 25
8934: ST_TO_ADDR
// result := unit ;
8935: LD_ADDR_VAR 0 4
8939: PUSH
8940: LD_VAR 0 5
8944: ST_TO_ADDR
// end ;
8945: LD_VAR 0 4
8949: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
8950: LD_INT 0
8952: PPUSH
8953: PPUSH
// if not side or not nation then
8954: LD_VAR 0 1
8958: NOT
8959: PUSH
8960: LD_VAR 0 2
8964: NOT
8965: OR
8966: IFFALSE 8970
// exit ;
8968: GO 9738
// case nation of nation_american :
8970: LD_VAR 0 2
8974: PUSH
8975: LD_INT 1
8977: DOUBLE
8978: EQUAL
8979: IFTRUE 8983
8981: GO 9197
8983: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
8984: LD_ADDR_VAR 0 4
8988: PUSH
8989: LD_INT 35
8991: PUSH
8992: LD_INT 45
8994: PUSH
8995: LD_INT 46
8997: PUSH
8998: LD_INT 47
9000: PUSH
9001: LD_INT 82
9003: PUSH
9004: LD_INT 83
9006: PUSH
9007: LD_INT 84
9009: PUSH
9010: LD_INT 85
9012: PUSH
9013: LD_INT 86
9015: PUSH
9016: LD_INT 1
9018: PUSH
9019: LD_INT 2
9021: PUSH
9022: LD_INT 6
9024: PUSH
9025: LD_INT 15
9027: PUSH
9028: LD_INT 16
9030: PUSH
9031: LD_INT 7
9033: PUSH
9034: LD_INT 12
9036: PUSH
9037: LD_INT 13
9039: PUSH
9040: LD_INT 10
9042: PUSH
9043: LD_INT 14
9045: PUSH
9046: LD_INT 20
9048: PUSH
9049: LD_INT 21
9051: PUSH
9052: LD_INT 22
9054: PUSH
9055: LD_INT 25
9057: PUSH
9058: LD_INT 32
9060: PUSH
9061: LD_INT 27
9063: PUSH
9064: LD_INT 36
9066: PUSH
9067: LD_INT 69
9069: PUSH
9070: LD_INT 39
9072: PUSH
9073: LD_INT 34
9075: PUSH
9076: LD_INT 40
9078: PUSH
9079: LD_INT 48
9081: PUSH
9082: LD_INT 49
9084: PUSH
9085: LD_INT 50
9087: PUSH
9088: LD_INT 51
9090: PUSH
9091: LD_INT 52
9093: PUSH
9094: LD_INT 53
9096: PUSH
9097: LD_INT 54
9099: PUSH
9100: LD_INT 55
9102: PUSH
9103: LD_INT 56
9105: PUSH
9106: LD_INT 57
9108: PUSH
9109: LD_INT 58
9111: PUSH
9112: LD_INT 59
9114: PUSH
9115: LD_INT 60
9117: PUSH
9118: LD_INT 61
9120: PUSH
9121: LD_INT 62
9123: PUSH
9124: LD_INT 80
9126: PUSH
9127: LD_INT 82
9129: PUSH
9130: LD_INT 83
9132: PUSH
9133: LD_INT 84
9135: PUSH
9136: LD_INT 85
9138: PUSH
9139: LD_INT 86
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: LIST
9180: LIST
9181: LIST
9182: LIST
9183: LIST
9184: LIST
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: LIST
9193: LIST
9194: ST_TO_ADDR
9195: GO 9662
9197: LD_INT 2
9199: DOUBLE
9200: EQUAL
9201: IFTRUE 9205
9203: GO 9431
9205: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
9206: LD_ADDR_VAR 0 4
9210: PUSH
9211: LD_INT 35
9213: PUSH
9214: LD_INT 45
9216: PUSH
9217: LD_INT 46
9219: PUSH
9220: LD_INT 47
9222: PUSH
9223: LD_INT 82
9225: PUSH
9226: LD_INT 83
9228: PUSH
9229: LD_INT 84
9231: PUSH
9232: LD_INT 85
9234: PUSH
9235: LD_INT 87
9237: PUSH
9238: LD_INT 70
9240: PUSH
9241: LD_INT 1
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: LD_INT 4
9252: PUSH
9253: LD_INT 5
9255: PUSH
9256: LD_INT 6
9258: PUSH
9259: LD_INT 15
9261: PUSH
9262: LD_INT 18
9264: PUSH
9265: LD_INT 7
9267: PUSH
9268: LD_INT 17
9270: PUSH
9271: LD_INT 8
9273: PUSH
9274: LD_INT 20
9276: PUSH
9277: LD_INT 21
9279: PUSH
9280: LD_INT 22
9282: PUSH
9283: LD_INT 72
9285: PUSH
9286: LD_INT 26
9288: PUSH
9289: LD_INT 69
9291: PUSH
9292: LD_INT 39
9294: PUSH
9295: LD_INT 40
9297: PUSH
9298: LD_INT 41
9300: PUSH
9301: LD_INT 42
9303: PUSH
9304: LD_INT 43
9306: PUSH
9307: LD_INT 48
9309: PUSH
9310: LD_INT 49
9312: PUSH
9313: LD_INT 50
9315: PUSH
9316: LD_INT 51
9318: PUSH
9319: LD_INT 52
9321: PUSH
9322: LD_INT 53
9324: PUSH
9325: LD_INT 54
9327: PUSH
9328: LD_INT 55
9330: PUSH
9331: LD_INT 56
9333: PUSH
9334: LD_INT 60
9336: PUSH
9337: LD_INT 61
9339: PUSH
9340: LD_INT 62
9342: PUSH
9343: LD_INT 66
9345: PUSH
9346: LD_INT 67
9348: PUSH
9349: LD_INT 68
9351: PUSH
9352: LD_INT 81
9354: PUSH
9355: LD_INT 82
9357: PUSH
9358: LD_INT 83
9360: PUSH
9361: LD_INT 84
9363: PUSH
9364: LD_INT 85
9366: PUSH
9367: LD_INT 87
9369: PUSH
9370: LD_INT 88
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: LIST
9407: LIST
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: LIST
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: ST_TO_ADDR
9429: GO 9662
9431: LD_INT 3
9433: DOUBLE
9434: EQUAL
9435: IFTRUE 9439
9437: GO 9661
9439: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
9440: LD_ADDR_VAR 0 4
9444: PUSH
9445: LD_INT 46
9447: PUSH
9448: LD_INT 47
9450: PUSH
9451: LD_INT 1
9453: PUSH
9454: LD_INT 2
9456: PUSH
9457: LD_INT 82
9459: PUSH
9460: LD_INT 83
9462: PUSH
9463: LD_INT 84
9465: PUSH
9466: LD_INT 85
9468: PUSH
9469: LD_INT 86
9471: PUSH
9472: LD_INT 11
9474: PUSH
9475: LD_INT 9
9477: PUSH
9478: LD_INT 20
9480: PUSH
9481: LD_INT 19
9483: PUSH
9484: LD_INT 21
9486: PUSH
9487: LD_INT 24
9489: PUSH
9490: LD_INT 22
9492: PUSH
9493: LD_INT 25
9495: PUSH
9496: LD_INT 28
9498: PUSH
9499: LD_INT 29
9501: PUSH
9502: LD_INT 30
9504: PUSH
9505: LD_INT 31
9507: PUSH
9508: LD_INT 37
9510: PUSH
9511: LD_INT 38
9513: PUSH
9514: LD_INT 32
9516: PUSH
9517: LD_INT 27
9519: PUSH
9520: LD_INT 33
9522: PUSH
9523: LD_INT 69
9525: PUSH
9526: LD_INT 39
9528: PUSH
9529: LD_INT 34
9531: PUSH
9532: LD_INT 40
9534: PUSH
9535: LD_INT 71
9537: PUSH
9538: LD_INT 23
9540: PUSH
9541: LD_INT 44
9543: PUSH
9544: LD_INT 48
9546: PUSH
9547: LD_INT 49
9549: PUSH
9550: LD_INT 50
9552: PUSH
9553: LD_INT 51
9555: PUSH
9556: LD_INT 52
9558: PUSH
9559: LD_INT 53
9561: PUSH
9562: LD_INT 54
9564: PUSH
9565: LD_INT 55
9567: PUSH
9568: LD_INT 56
9570: PUSH
9571: LD_INT 57
9573: PUSH
9574: LD_INT 58
9576: PUSH
9577: LD_INT 59
9579: PUSH
9580: LD_INT 63
9582: PUSH
9583: LD_INT 64
9585: PUSH
9586: LD_INT 65
9588: PUSH
9589: LD_INT 82
9591: PUSH
9592: LD_INT 83
9594: PUSH
9595: LD_INT 84
9597: PUSH
9598: LD_INT 85
9600: PUSH
9601: LD_INT 86
9603: PUSH
9604: EMPTY
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: ST_TO_ADDR
9659: GO 9662
9661: POP
// if state > - 1 and state < 3 then
9662: LD_VAR 0 3
9666: PUSH
9667: LD_INT 1
9669: NEG
9670: GREATER
9671: PUSH
9672: LD_VAR 0 3
9676: PUSH
9677: LD_INT 3
9679: LESS
9680: AND
9681: IFFALSE 9738
// for i in result do
9683: LD_ADDR_VAR 0 5
9687: PUSH
9688: LD_VAR 0 4
9692: PUSH
9693: FOR_IN
9694: IFFALSE 9736
// if GetTech ( i , side ) <> state then
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 321
9710: PUSH
9711: LD_VAR 0 3
9715: NONEQUAL
9716: IFFALSE 9734
// result := result diff i ;
9718: LD_ADDR_VAR 0 4
9722: PUSH
9723: LD_VAR 0 4
9727: PUSH
9728: LD_VAR 0 5
9732: DIFF
9733: ST_TO_ADDR
9734: GO 9693
9736: POP
9737: POP
// end ;
9738: LD_VAR 0 4
9742: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
9743: LD_INT 0
9745: PPUSH
9746: PPUSH
9747: PPUSH
// result := true ;
9748: LD_ADDR_VAR 0 3
9752: PUSH
9753: LD_INT 1
9755: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
9756: LD_ADDR_VAR 0 5
9760: PUSH
9761: LD_VAR 0 2
9765: PPUSH
9766: CALL_OW 480
9770: ST_TO_ADDR
// if not tmp then
9771: LD_VAR 0 5
9775: NOT
9776: IFFALSE 9780
// exit ;
9778: GO 9829
// for i in tmp do
9780: LD_ADDR_VAR 0 4
9784: PUSH
9785: LD_VAR 0 5
9789: PUSH
9790: FOR_IN
9791: IFFALSE 9827
// if GetTech ( i , side ) <> state_researched then
9793: LD_VAR 0 4
9797: PPUSH
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 321
9807: PUSH
9808: LD_INT 2
9810: NONEQUAL
9811: IFFALSE 9825
// begin result := false ;
9813: LD_ADDR_VAR 0 3
9817: PUSH
9818: LD_INT 0
9820: ST_TO_ADDR
// exit ;
9821: POP
9822: POP
9823: GO 9829
// end ;
9825: GO 9790
9827: POP
9828: POP
// end ;
9829: LD_VAR 0 3
9833: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
9834: LD_INT 0
9836: PPUSH
9837: PPUSH
9838: PPUSH
9839: PPUSH
9840: PPUSH
9841: PPUSH
9842: PPUSH
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
9848: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
9849: LD_VAR 0 1
9853: NOT
9854: PUSH
9855: LD_VAR 0 1
9859: PPUSH
9860: CALL_OW 257
9864: PUSH
9865: LD_INT 9
9867: NONEQUAL
9868: OR
9869: IFFALSE 9873
// exit ;
9871: GO 10446
// side := GetSide ( unit ) ;
9873: LD_ADDR_VAR 0 9
9877: PUSH
9878: LD_VAR 0 1
9882: PPUSH
9883: CALL_OW 255
9887: ST_TO_ADDR
// tech_space := tech_spacanom ;
9888: LD_ADDR_VAR 0 12
9892: PUSH
9893: LD_INT 29
9895: ST_TO_ADDR
// tech_time := tech_taurad ;
9896: LD_ADDR_VAR 0 13
9900: PUSH
9901: LD_INT 28
9903: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
9904: LD_ADDR_VAR 0 11
9908: PUSH
9909: LD_VAR 0 1
9913: PPUSH
9914: CALL_OW 310
9918: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
9919: LD_VAR 0 11
9923: PPUSH
9924: CALL_OW 247
9928: PUSH
9929: LD_INT 2
9931: EQUAL
9932: IFFALSE 9936
// exit ;
9934: GO 10446
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9936: LD_ADDR_VAR 0 8
9940: PUSH
9941: LD_INT 81
9943: PUSH
9944: LD_VAR 0 9
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: PUSH
9953: LD_INT 3
9955: PUSH
9956: LD_INT 21
9958: PUSH
9959: LD_INT 3
9961: PUSH
9962: EMPTY
9963: LIST
9964: LIST
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PPUSH
9974: CALL_OW 69
9978: ST_TO_ADDR
// if not tmp then
9979: LD_VAR 0 8
9983: NOT
9984: IFFALSE 9988
// exit ;
9986: GO 10446
// if in_unit then
9988: LD_VAR 0 11
9992: IFFALSE 10016
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
9994: LD_ADDR_VAR 0 10
9998: PUSH
9999: LD_VAR 0 8
10003: PPUSH
10004: LD_VAR 0 11
10008: PPUSH
10009: CALL_OW 74
10013: ST_TO_ADDR
10014: GO 10036
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10016: LD_ADDR_VAR 0 10
10020: PUSH
10021: LD_VAR 0 8
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: ST_TO_ADDR
// if not enemy then
10036: LD_VAR 0 10
10040: NOT
10041: IFFALSE 10045
// exit ;
10043: GO 10446
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10045: LD_VAR 0 11
10049: PUSH
10050: LD_VAR 0 11
10054: PPUSH
10055: LD_VAR 0 10
10059: PPUSH
10060: CALL_OW 296
10064: PUSH
10065: LD_INT 13
10067: GREATER
10068: AND
10069: PUSH
10070: LD_VAR 0 1
10074: PPUSH
10075: LD_VAR 0 10
10079: PPUSH
10080: CALL_OW 296
10084: PUSH
10085: LD_INT 12
10087: GREATER
10088: OR
10089: IFFALSE 10093
// exit ;
10091: GO 10446
// missile := [ 1 ] ;
10093: LD_ADDR_VAR 0 14
10097: PUSH
10098: LD_INT 1
10100: PUSH
10101: EMPTY
10102: LIST
10103: ST_TO_ADDR
// if Researched ( side , tech_space ) then
10104: LD_VAR 0 9
10108: PPUSH
10109: LD_VAR 0 12
10113: PPUSH
10114: CALL_OW 325
10118: IFFALSE 10147
// missile := Replace ( missile , missile + 1 , 2 ) ;
10120: LD_ADDR_VAR 0 14
10124: PUSH
10125: LD_VAR 0 14
10129: PPUSH
10130: LD_VAR 0 14
10134: PUSH
10135: LD_INT 1
10137: PLUS
10138: PPUSH
10139: LD_INT 2
10141: PPUSH
10142: CALL_OW 1
10146: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
10147: LD_VAR 0 9
10151: PPUSH
10152: LD_VAR 0 13
10156: PPUSH
10157: CALL_OW 325
10161: PUSH
10162: LD_VAR 0 10
10166: PPUSH
10167: CALL_OW 255
10171: PPUSH
10172: LD_VAR 0 13
10176: PPUSH
10177: CALL_OW 325
10181: NOT
10182: AND
10183: IFFALSE 10212
// missile := Replace ( missile , missile + 1 , 3 ) ;
10185: LD_ADDR_VAR 0 14
10189: PUSH
10190: LD_VAR 0 14
10194: PPUSH
10195: LD_VAR 0 14
10199: PUSH
10200: LD_INT 1
10202: PLUS
10203: PPUSH
10204: LD_INT 3
10206: PPUSH
10207: CALL_OW 1
10211: ST_TO_ADDR
// if missile < 2 then
10212: LD_VAR 0 14
10216: PUSH
10217: LD_INT 2
10219: LESS
10220: IFFALSE 10224
// exit ;
10222: GO 10446
// x := GetX ( enemy ) ;
10224: LD_ADDR_VAR 0 4
10228: PUSH
10229: LD_VAR 0 10
10233: PPUSH
10234: CALL_OW 250
10238: ST_TO_ADDR
// y := GetY ( enemy ) ;
10239: LD_ADDR_VAR 0 5
10243: PUSH
10244: LD_VAR 0 10
10248: PPUSH
10249: CALL_OW 251
10253: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
10254: LD_ADDR_VAR 0 6
10258: PUSH
10259: LD_VAR 0 4
10263: PUSH
10264: LD_INT 1
10266: NEG
10267: PPUSH
10268: LD_INT 1
10270: PPUSH
10271: CALL_OW 12
10275: PLUS
10276: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
10277: LD_ADDR_VAR 0 7
10281: PUSH
10282: LD_VAR 0 5
10286: PUSH
10287: LD_INT 1
10289: NEG
10290: PPUSH
10291: LD_INT 1
10293: PPUSH
10294: CALL_OW 12
10298: PLUS
10299: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10300: LD_VAR 0 6
10304: PPUSH
10305: LD_VAR 0 7
10309: PPUSH
10310: CALL_OW 488
10314: NOT
10315: IFFALSE 10337
// begin _x := x ;
10317: LD_ADDR_VAR 0 6
10321: PUSH
10322: LD_VAR 0 4
10326: ST_TO_ADDR
// _y := y ;
10327: LD_ADDR_VAR 0 7
10331: PUSH
10332: LD_VAR 0 5
10336: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
10337: LD_ADDR_VAR 0 3
10341: PUSH
10342: LD_INT 1
10344: PPUSH
10345: LD_VAR 0 14
10349: PPUSH
10350: CALL_OW 12
10354: ST_TO_ADDR
// case i of 1 :
10355: LD_VAR 0 3
10359: PUSH
10360: LD_INT 1
10362: DOUBLE
10363: EQUAL
10364: IFTRUE 10368
10366: GO 10385
10368: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
10369: LD_VAR 0 1
10373: PPUSH
10374: LD_VAR 0 10
10378: PPUSH
10379: CALL_OW 115
10383: GO 10446
10385: LD_INT 2
10387: DOUBLE
10388: EQUAL
10389: IFTRUE 10393
10391: GO 10415
10393: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_VAR 0 6
10403: PPUSH
10404: LD_VAR 0 7
10408: PPUSH
10409: CALL_OW 153
10413: GO 10446
10415: LD_INT 3
10417: DOUBLE
10418: EQUAL
10419: IFTRUE 10423
10421: GO 10445
10423: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
10424: LD_VAR 0 1
10428: PPUSH
10429: LD_VAR 0 6
10433: PPUSH
10434: LD_VAR 0 7
10438: PPUSH
10439: CALL_OW 154
10443: GO 10446
10445: POP
// end ;
10446: LD_VAR 0 2
10450: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
10451: LD_INT 0
10453: PPUSH
10454: PPUSH
10455: PPUSH
10456: PPUSH
10457: PPUSH
10458: PPUSH
// if not unit or not building then
10459: LD_VAR 0 1
10463: NOT
10464: PUSH
10465: LD_VAR 0 2
10469: NOT
10470: OR
10471: IFFALSE 10475
// exit ;
10473: GO 10633
// x := GetX ( building ) ;
10475: LD_ADDR_VAR 0 5
10479: PUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: CALL_OW 250
10489: ST_TO_ADDR
// y := GetY ( building ) ;
10490: LD_ADDR_VAR 0 6
10494: PUSH
10495: LD_VAR 0 2
10499: PPUSH
10500: CALL_OW 251
10504: ST_TO_ADDR
// for i = 0 to 5 do
10505: LD_ADDR_VAR 0 4
10509: PUSH
10510: DOUBLE
10511: LD_INT 0
10513: DEC
10514: ST_TO_ADDR
10515: LD_INT 5
10517: PUSH
10518: FOR_TO
10519: IFFALSE 10631
// begin _x := ShiftX ( x , i , 3 ) ;
10521: LD_ADDR_VAR 0 7
10525: PUSH
10526: LD_VAR 0 5
10530: PPUSH
10531: LD_VAR 0 4
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: CALL_OW 272
10543: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
10544: LD_ADDR_VAR 0 8
10548: PUSH
10549: LD_VAR 0 6
10553: PPUSH
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 3
10561: PPUSH
10562: CALL_OW 273
10566: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10567: LD_VAR 0 7
10571: PPUSH
10572: LD_VAR 0 8
10576: PPUSH
10577: CALL_OW 488
10581: NOT
10582: IFFALSE 10586
// continue ;
10584: GO 10518
// if HexInfo ( _x , _y ) = 0 then
10586: LD_VAR 0 7
10590: PPUSH
10591: LD_VAR 0 8
10595: PPUSH
10596: CALL_OW 428
10600: PUSH
10601: LD_INT 0
10603: EQUAL
10604: IFFALSE 10629
// begin ComMoveXY ( unit , _x , _y ) ;
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_VAR 0 7
10615: PPUSH
10616: LD_VAR 0 8
10620: PPUSH
10621: CALL_OW 111
// exit ;
10625: POP
10626: POP
10627: GO 10633
// end ; end ;
10629: GO 10518
10631: POP
10632: POP
// end ;
10633: LD_VAR 0 3
10637: RET
// export function ScanBase ( side , base_area ) ; begin
10638: LD_INT 0
10640: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
10641: LD_ADDR_VAR 0 3
10645: PUSH
10646: LD_VAR 0 2
10650: PPUSH
10651: LD_INT 81
10653: PUSH
10654: LD_VAR 0 1
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 70
10667: ST_TO_ADDR
// end ;
10668: LD_VAR 0 3
10672: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
10673: LD_INT 0
10675: PPUSH
10676: PPUSH
10677: PPUSH
10678: PPUSH
// result := false ;
10679: LD_ADDR_VAR 0 2
10683: PUSH
10684: LD_INT 0
10686: ST_TO_ADDR
// side := GetSide ( unit ) ;
10687: LD_ADDR_VAR 0 3
10691: PUSH
10692: LD_VAR 0 1
10696: PPUSH
10697: CALL_OW 255
10701: ST_TO_ADDR
// nat := GetNation ( unit ) ;
10702: LD_ADDR_VAR 0 4
10706: PUSH
10707: LD_VAR 0 1
10711: PPUSH
10712: CALL_OW 248
10716: ST_TO_ADDR
// case nat of 1 :
10717: LD_VAR 0 4
10721: PUSH
10722: LD_INT 1
10724: DOUBLE
10725: EQUAL
10726: IFTRUE 10730
10728: GO 10741
10730: POP
// tech := tech_lassight ; 2 :
10731: LD_ADDR_VAR 0 5
10735: PUSH
10736: LD_INT 12
10738: ST_TO_ADDR
10739: GO 10780
10741: LD_INT 2
10743: DOUBLE
10744: EQUAL
10745: IFTRUE 10749
10747: GO 10760
10749: POP
// tech := tech_mortar ; 3 :
10750: LD_ADDR_VAR 0 5
10754: PUSH
10755: LD_INT 41
10757: ST_TO_ADDR
10758: GO 10780
10760: LD_INT 3
10762: DOUBLE
10763: EQUAL
10764: IFTRUE 10768
10766: GO 10779
10768: POP
// tech := tech_bazooka ; end ;
10769: LD_ADDR_VAR 0 5
10773: PUSH
10774: LD_INT 44
10776: ST_TO_ADDR
10777: GO 10780
10779: POP
// if Researched ( side , tech ) then
10780: LD_VAR 0 3
10784: PPUSH
10785: LD_VAR 0 5
10789: PPUSH
10790: CALL_OW 325
10794: IFFALSE 10821
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
10796: LD_ADDR_VAR 0 2
10800: PUSH
10801: LD_INT 5
10803: PUSH
10804: LD_INT 8
10806: PUSH
10807: LD_INT 9
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: LIST
10814: PUSH
10815: LD_VAR 0 4
10819: ARRAY
10820: ST_TO_ADDR
// end ;
10821: LD_VAR 0 2
10825: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
10826: LD_INT 0
10828: PPUSH
10829: PPUSH
10830: PPUSH
// if not mines then
10831: LD_VAR 0 2
10835: NOT
10836: IFFALSE 10840
// exit ;
10838: GO 10984
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10840: LD_ADDR_VAR 0 5
10844: PUSH
10845: LD_INT 81
10847: PUSH
10848: LD_VAR 0 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 3
10859: PUSH
10860: LD_INT 21
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PUSH
10870: EMPTY
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PPUSH
10878: CALL_OW 69
10882: ST_TO_ADDR
// for i in mines do
10883: LD_ADDR_VAR 0 4
10887: PUSH
10888: LD_VAR 0 2
10892: PUSH
10893: FOR_IN
10894: IFFALSE 10982
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
10896: LD_VAR 0 4
10900: PUSH
10901: LD_INT 1
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 4
10909: PUSH
10910: LD_INT 2
10912: ARRAY
10913: PPUSH
10914: CALL_OW 458
10918: NOT
10919: IFFALSE 10923
// continue ;
10921: GO 10893
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
10923: LD_VAR 0 4
10927: PUSH
10928: LD_INT 1
10930: ARRAY
10931: PPUSH
10932: LD_VAR 0 4
10936: PUSH
10937: LD_INT 2
10939: ARRAY
10940: PPUSH
10941: CALL_OW 428
10945: PUSH
10946: LD_VAR 0 5
10950: IN
10951: IFFALSE 10980
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
10953: LD_VAR 0 4
10957: PUSH
10958: LD_INT 1
10960: ARRAY
10961: PPUSH
10962: LD_VAR 0 4
10966: PUSH
10967: LD_INT 2
10969: ARRAY
10970: PPUSH
10971: LD_VAR 0 1
10975: PPUSH
10976: CALL_OW 456
// end ;
10980: GO 10893
10982: POP
10983: POP
// end ;
10984: LD_VAR 0 3
10988: RET
// export function Count ( array ) ; var i ; begin
10989: LD_INT 0
10991: PPUSH
10992: PPUSH
// result := 0 ;
10993: LD_ADDR_VAR 0 2
10997: PUSH
10998: LD_INT 0
11000: ST_TO_ADDR
// for i in array do
11001: LD_ADDR_VAR 0 3
11005: PUSH
11006: LD_VAR 0 1
11010: PUSH
11011: FOR_IN
11012: IFFALSE 11036
// if i then
11014: LD_VAR 0 3
11018: IFFALSE 11034
// result := result + 1 ;
11020: LD_ADDR_VAR 0 2
11024: PUSH
11025: LD_VAR 0 2
11029: PUSH
11030: LD_INT 1
11032: PLUS
11033: ST_TO_ADDR
11034: GO 11011
11036: POP
11037: POP
// end ;
11038: LD_VAR 0 2
11042: RET
// export function IsEmpty ( building ) ; begin
11043: LD_INT 0
11045: PPUSH
// if not building then
11046: LD_VAR 0 1
11050: NOT
11051: IFFALSE 11055
// exit ;
11053: GO 11098
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11055: LD_ADDR_VAR 0 2
11059: PUSH
11060: LD_VAR 0 1
11064: PUSH
11065: LD_INT 22
11067: PUSH
11068: LD_VAR 0 1
11072: PPUSH
11073: CALL_OW 255
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: LD_INT 58
11084: PUSH
11085: EMPTY
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: IN
11097: ST_TO_ADDR
// end ;
11098: LD_VAR 0 2
11102: RET
// export function IsNotFull ( building ) ; var places ; begin
11103: LD_INT 0
11105: PPUSH
11106: PPUSH
// if not building then
11107: LD_VAR 0 1
11111: NOT
11112: IFFALSE 11116
// exit ;
11114: GO 11287
// result := false ;
11116: LD_ADDR_VAR 0 2
11120: PUSH
11121: LD_INT 0
11123: ST_TO_ADDR
// places := 0 ;
11124: LD_ADDR_VAR 0 3
11128: PUSH
11129: LD_INT 0
11131: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
11132: LD_VAR 0 1
11136: PPUSH
11137: CALL_OW 266
11141: PUSH
11142: LD_INT 0
11144: DOUBLE
11145: EQUAL
11146: IFTRUE 11204
11148: LD_INT 1
11150: DOUBLE
11151: EQUAL
11152: IFTRUE 11204
11154: LD_INT 6
11156: DOUBLE
11157: EQUAL
11158: IFTRUE 11204
11160: LD_INT 7
11162: DOUBLE
11163: EQUAL
11164: IFTRUE 11204
11166: LD_INT 8
11168: DOUBLE
11169: EQUAL
11170: IFTRUE 11204
11172: LD_INT 4
11174: DOUBLE
11175: EQUAL
11176: IFTRUE 11204
11178: LD_INT 5
11180: DOUBLE
11181: EQUAL
11182: IFTRUE 11204
11184: LD_INT 2
11186: DOUBLE
11187: EQUAL
11188: IFTRUE 11204
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11204
11196: LD_INT 35
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11215
11204: POP
// places := 6 ; b_bunker , b_breastwork :
11205: LD_ADDR_VAR 0 3
11209: PUSH
11210: LD_INT 6
11212: ST_TO_ADDR
11213: GO 11260
11215: LD_INT 32
11217: DOUBLE
11218: EQUAL
11219: IFTRUE 11229
11221: LD_INT 31
11223: DOUBLE
11224: EQUAL
11225: IFTRUE 11229
11227: GO 11240
11229: POP
// places := 1 ; b_control_tower :
11230: LD_ADDR_VAR 0 3
11234: PUSH
11235: LD_INT 1
11237: ST_TO_ADDR
11238: GO 11260
11240: LD_INT 36
11242: DOUBLE
11243: EQUAL
11244: IFTRUE 11248
11246: GO 11259
11248: POP
// places := 3 ; end ;
11249: LD_ADDR_VAR 0 3
11253: PUSH
11254: LD_INT 3
11256: ST_TO_ADDR
11257: GO 11260
11259: POP
// if places then
11260: LD_VAR 0 3
11264: IFFALSE 11287
// result := UnitsInside ( building ) < places ;
11266: LD_ADDR_VAR 0 2
11270: PUSH
11271: LD_VAR 0 1
11275: PPUSH
11276: CALL_OW 313
11280: PUSH
11281: LD_VAR 0 3
11285: LESS
11286: ST_TO_ADDR
// end ;
11287: LD_VAR 0 2
11291: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
11292: LD_INT 0
11294: PPUSH
11295: PPUSH
11296: PPUSH
11297: PPUSH
// tmp := [ ] ;
11298: LD_ADDR_VAR 0 3
11302: PUSH
11303: EMPTY
11304: ST_TO_ADDR
// list := [ ] ;
11305: LD_ADDR_VAR 0 5
11309: PUSH
11310: EMPTY
11311: ST_TO_ADDR
// for i = 16 to 25 do
11312: LD_ADDR_VAR 0 4
11316: PUSH
11317: DOUBLE
11318: LD_INT 16
11320: DEC
11321: ST_TO_ADDR
11322: LD_INT 25
11324: PUSH
11325: FOR_TO
11326: IFFALSE 11399
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
11328: LD_ADDR_VAR 0 3
11332: PUSH
11333: LD_VAR 0 3
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PPUSH
11346: CALL_OW 255
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: PUSH
11355: LD_INT 91
11357: PUSH
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 6
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: LIST
11370: PUSH
11371: LD_INT 30
11373: PUSH
11374: LD_VAR 0 4
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: PPUSH
11391: CALL_OW 69
11395: ADD
11396: ST_TO_ADDR
11397: GO 11325
11399: POP
11400: POP
// for i = 1 to tmp do
11401: LD_ADDR_VAR 0 4
11405: PUSH
11406: DOUBLE
11407: LD_INT 1
11409: DEC
11410: ST_TO_ADDR
11411: LD_VAR 0 3
11415: PUSH
11416: FOR_TO
11417: IFFALSE 11505
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11419: LD_ADDR_VAR 0 5
11423: PUSH
11424: LD_VAR 0 5
11428: PUSH
11429: LD_VAR 0 3
11433: PUSH
11434: LD_VAR 0 4
11438: ARRAY
11439: PPUSH
11440: CALL_OW 266
11444: PUSH
11445: LD_VAR 0 3
11449: PUSH
11450: LD_VAR 0 4
11454: ARRAY
11455: PPUSH
11456: CALL_OW 250
11460: PUSH
11461: LD_VAR 0 3
11465: PUSH
11466: LD_VAR 0 4
11470: ARRAY
11471: PPUSH
11472: CALL_OW 251
11476: PUSH
11477: LD_VAR 0 3
11481: PUSH
11482: LD_VAR 0 4
11486: ARRAY
11487: PPUSH
11488: CALL_OW 254
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: ADD
11502: ST_TO_ADDR
11503: GO 11416
11505: POP
11506: POP
// result := list ;
11507: LD_ADDR_VAR 0 2
11511: PUSH
11512: LD_VAR 0 5
11516: ST_TO_ADDR
// end ;
11517: LD_VAR 0 2
11521: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
11522: LD_INT 0
11524: PPUSH
11525: PPUSH
11526: PPUSH
11527: PPUSH
11528: PPUSH
11529: PPUSH
11530: PPUSH
// if not factory then
11531: LD_VAR 0 1
11535: NOT
11536: IFFALSE 11540
// exit ;
11538: GO 12133
// if control = control_apeman then
11540: LD_VAR 0 4
11544: PUSH
11545: LD_INT 5
11547: EQUAL
11548: IFFALSE 11657
// begin tmp := UnitsInside ( factory ) ;
11550: LD_ADDR_VAR 0 8
11554: PUSH
11555: LD_VAR 0 1
11559: PPUSH
11560: CALL_OW 313
11564: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
11565: LD_VAR 0 8
11569: PPUSH
11570: LD_INT 25
11572: PUSH
11573: LD_INT 12
11575: PUSH
11576: EMPTY
11577: LIST
11578: LIST
11579: PPUSH
11580: CALL_OW 72
11584: NOT
11585: IFFALSE 11595
// control := control_manual ;
11587: LD_ADDR_VAR 0 4
11591: PUSH
11592: LD_INT 1
11594: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
11595: LD_ADDR_VAR 0 8
11599: PUSH
11600: LD_VAR 0 1
11604: PPUSH
11605: CALL 11292 0 1
11609: ST_TO_ADDR
// if tmp then
11610: LD_VAR 0 8
11614: IFFALSE 11657
// begin for i in tmp do
11616: LD_ADDR_VAR 0 7
11620: PUSH
11621: LD_VAR 0 8
11625: PUSH
11626: FOR_IN
11627: IFFALSE 11655
// if i [ 1 ] = b_ext_radio then
11629: LD_VAR 0 7
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PUSH
11638: LD_INT 22
11640: EQUAL
11641: IFFALSE 11653
// begin control := control_remote ;
11643: LD_ADDR_VAR 0 4
11647: PUSH
11648: LD_INT 2
11650: ST_TO_ADDR
// break ;
11651: GO 11655
// end ;
11653: GO 11626
11655: POP
11656: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11657: LD_VAR 0 1
11661: PPUSH
11662: LD_VAR 0 2
11666: PPUSH
11667: LD_VAR 0 3
11671: PPUSH
11672: LD_VAR 0 4
11676: PPUSH
11677: LD_VAR 0 5
11681: PPUSH
11682: CALL_OW 448
11686: IFFALSE 11721
// begin result := [ chassis , engine , control , weapon ] ;
11688: LD_ADDR_VAR 0 6
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_VAR 0 4
11707: PUSH
11708: LD_VAR 0 5
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: ST_TO_ADDR
// exit ;
11719: GO 12133
// end ; _chassis := AvailableChassisList ( factory ) ;
11721: LD_ADDR_VAR 0 9
11725: PUSH
11726: LD_VAR 0 1
11730: PPUSH
11731: CALL_OW 475
11735: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
11736: LD_ADDR_VAR 0 11
11740: PUSH
11741: LD_VAR 0 1
11745: PPUSH
11746: CALL_OW 476
11750: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
11751: LD_ADDR_VAR 0 12
11755: PUSH
11756: LD_VAR 0 1
11760: PPUSH
11761: CALL_OW 477
11765: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
11766: LD_ADDR_VAR 0 10
11770: PUSH
11771: LD_VAR 0 1
11775: PPUSH
11776: CALL_OW 478
11780: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
11781: LD_VAR 0 9
11785: NOT
11786: PUSH
11787: LD_VAR 0 11
11791: NOT
11792: OR
11793: PUSH
11794: LD_VAR 0 12
11798: NOT
11799: OR
11800: PUSH
11801: LD_VAR 0 10
11805: NOT
11806: OR
11807: IFFALSE 11842
// begin result := [ chassis , engine , control , weapon ] ;
11809: LD_ADDR_VAR 0 6
11813: PUSH
11814: LD_VAR 0 2
11818: PUSH
11819: LD_VAR 0 3
11823: PUSH
11824: LD_VAR 0 4
11828: PUSH
11829: LD_VAR 0 5
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: ST_TO_ADDR
// exit ;
11840: GO 12133
// end ; if not chassis in _chassis then
11842: LD_VAR 0 2
11846: PUSH
11847: LD_VAR 0 9
11851: IN
11852: NOT
11853: IFFALSE 11879
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
11855: LD_ADDR_VAR 0 2
11859: PUSH
11860: LD_VAR 0 9
11864: PUSH
11865: LD_INT 1
11867: PPUSH
11868: LD_VAR 0 9
11872: PPUSH
11873: CALL_OW 12
11877: ARRAY
11878: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
11879: LD_VAR 0 2
11883: PPUSH
11884: LD_VAR 0 3
11888: PPUSH
11889: CALL 12138 0 2
11893: NOT
11894: IFFALSE 11953
// repeat engine := _engine [ 1 ] ;
11896: LD_ADDR_VAR 0 3
11900: PUSH
11901: LD_VAR 0 11
11905: PUSH
11906: LD_INT 1
11908: ARRAY
11909: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
11910: LD_ADDR_VAR 0 11
11914: PUSH
11915: LD_VAR 0 11
11919: PPUSH
11920: LD_INT 1
11922: PPUSH
11923: CALL_OW 3
11927: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
11928: LD_VAR 0 2
11932: PPUSH
11933: LD_VAR 0 3
11937: PPUSH
11938: CALL 12138 0 2
11942: PUSH
11943: LD_VAR 0 11
11947: PUSH
11948: EMPTY
11949: EQUAL
11950: OR
11951: IFFALSE 11896
// if not control in _control then
11953: LD_VAR 0 4
11957: PUSH
11958: LD_VAR 0 12
11962: IN
11963: NOT
11964: IFFALSE 11990
// control := _control [ rand ( 1 , _control ) ] ;
11966: LD_ADDR_VAR 0 4
11970: PUSH
11971: LD_VAR 0 12
11975: PUSH
11976: LD_INT 1
11978: PPUSH
11979: LD_VAR 0 12
11983: PPUSH
11984: CALL_OW 12
11988: ARRAY
11989: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
11990: LD_VAR 0 2
11994: PPUSH
11995: LD_VAR 0 5
11999: PPUSH
12000: CALL 12358 0 2
12004: NOT
12005: IFFALSE 12064
// repeat weapon := _weapon [ 1 ] ;
12007: LD_ADDR_VAR 0 5
12011: PUSH
12012: LD_VAR 0 10
12016: PUSH
12017: LD_INT 1
12019: ARRAY
12020: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12021: LD_ADDR_VAR 0 10
12025: PUSH
12026: LD_VAR 0 10
12030: PPUSH
12031: LD_INT 1
12033: PPUSH
12034: CALL_OW 3
12038: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12039: LD_VAR 0 2
12043: PPUSH
12044: LD_VAR 0 5
12048: PPUSH
12049: CALL 12358 0 2
12053: PUSH
12054: LD_VAR 0 10
12058: PUSH
12059: EMPTY
12060: EQUAL
12061: OR
12062: IFFALSE 12007
// result := [ ] ;
12064: LD_ADDR_VAR 0 6
12068: PUSH
12069: EMPTY
12070: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_VAR 0 2
12080: PPUSH
12081: LD_VAR 0 3
12085: PPUSH
12086: LD_VAR 0 4
12090: PPUSH
12091: LD_VAR 0 5
12095: PPUSH
12096: CALL_OW 448
12100: IFFALSE 12133
// result := [ chassis , engine , control , weapon ] ;
12102: LD_ADDR_VAR 0 6
12106: PUSH
12107: LD_VAR 0 2
12111: PUSH
12112: LD_VAR 0 3
12116: PUSH
12117: LD_VAR 0 4
12121: PUSH
12122: LD_VAR 0 5
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: ST_TO_ADDR
// end ;
12133: LD_VAR 0 6
12137: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12138: LD_INT 0
12140: PPUSH
// if not chassis or not engine then
12141: LD_VAR 0 1
12145: NOT
12146: PUSH
12147: LD_VAR 0 2
12151: NOT
12152: OR
12153: IFFALSE 12157
// exit ;
12155: GO 12353
// case engine of engine_solar :
12157: LD_VAR 0 2
12161: PUSH
12162: LD_INT 2
12164: DOUBLE
12165: EQUAL
12166: IFTRUE 12170
12168: GO 12208
12170: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12171: LD_ADDR_VAR 0 3
12175: PUSH
12176: LD_INT 11
12178: PUSH
12179: LD_INT 12
12181: PUSH
12182: LD_INT 13
12184: PUSH
12185: LD_INT 14
12187: PUSH
12188: LD_INT 1
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: ST_TO_ADDR
12206: GO 12337
12208: LD_INT 1
12210: DOUBLE
12211: EQUAL
12212: IFTRUE 12216
12214: GO 12278
12216: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_INT 11
12224: PUSH
12225: LD_INT 12
12227: PUSH
12228: LD_INT 13
12230: PUSH
12231: LD_INT 14
12233: PUSH
12234: LD_INT 1
12236: PUSH
12237: LD_INT 2
12239: PUSH
12240: LD_INT 3
12242: PUSH
12243: LD_INT 4
12245: PUSH
12246: LD_INT 5
12248: PUSH
12249: LD_INT 21
12251: PUSH
12252: LD_INT 23
12254: PUSH
12255: LD_INT 22
12257: PUSH
12258: LD_INT 24
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: LIST
12274: LIST
12275: ST_TO_ADDR
12276: GO 12337
12278: LD_INT 3
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12336
12286: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
12287: LD_ADDR_VAR 0 3
12291: PUSH
12292: LD_INT 13
12294: PUSH
12295: LD_INT 14
12297: PUSH
12298: LD_INT 2
12300: PUSH
12301: LD_INT 3
12303: PUSH
12304: LD_INT 4
12306: PUSH
12307: LD_INT 5
12309: PUSH
12310: LD_INT 21
12312: PUSH
12313: LD_INT 22
12315: PUSH
12316: LD_INT 23
12318: PUSH
12319: LD_INT 24
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: ST_TO_ADDR
12334: GO 12337
12336: POP
// result := ( chassis in result ) ;
12337: LD_ADDR_VAR 0 3
12341: PUSH
12342: LD_VAR 0 1
12346: PUSH
12347: LD_VAR 0 3
12351: IN
12352: ST_TO_ADDR
// end ;
12353: LD_VAR 0 3
12357: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
12358: LD_INT 0
12360: PPUSH
// if not chassis or not weapon then
12361: LD_VAR 0 1
12365: NOT
12366: PUSH
12367: LD_VAR 0 2
12371: NOT
12372: OR
12373: IFFALSE 12377
// exit ;
12375: GO 13437
// case weapon of us_machine_gun :
12377: LD_VAR 0 2
12381: PUSH
12382: LD_INT 2
12384: DOUBLE
12385: EQUAL
12386: IFTRUE 12390
12388: GO 12420
12390: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
12391: LD_ADDR_VAR 0 3
12395: PUSH
12396: LD_INT 1
12398: PUSH
12399: LD_INT 2
12401: PUSH
12402: LD_INT 3
12404: PUSH
12405: LD_INT 4
12407: PUSH
12408: LD_INT 5
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: ST_TO_ADDR
12418: GO 13421
12420: LD_INT 3
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12458
12428: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
12429: LD_ADDR_VAR 0 3
12433: PUSH
12434: LD_INT 1
12436: PUSH
12437: LD_INT 2
12439: PUSH
12440: LD_INT 3
12442: PUSH
12443: LD_INT 4
12445: PUSH
12446: LD_INT 5
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: ST_TO_ADDR
12456: GO 13421
12458: LD_INT 11
12460: DOUBLE
12461: EQUAL
12462: IFTRUE 12466
12464: GO 12496
12466: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
12467: LD_ADDR_VAR 0 3
12471: PUSH
12472: LD_INT 1
12474: PUSH
12475: LD_INT 2
12477: PUSH
12478: LD_INT 3
12480: PUSH
12481: LD_INT 4
12483: PUSH
12484: LD_INT 5
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: ST_TO_ADDR
12494: GO 13421
12496: LD_INT 4
12498: DOUBLE
12499: EQUAL
12500: IFTRUE 12504
12502: GO 12530
12504: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
12505: LD_ADDR_VAR 0 3
12509: PUSH
12510: LD_INT 2
12512: PUSH
12513: LD_INT 3
12515: PUSH
12516: LD_INT 4
12518: PUSH
12519: LD_INT 5
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: ST_TO_ADDR
12528: GO 13421
12530: LD_INT 5
12532: DOUBLE
12533: EQUAL
12534: IFTRUE 12538
12536: GO 12564
12538: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_INT 2
12546: PUSH
12547: LD_INT 3
12549: PUSH
12550: LD_INT 4
12552: PUSH
12553: LD_INT 5
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: ST_TO_ADDR
12562: GO 13421
12564: LD_INT 9
12566: DOUBLE
12567: EQUAL
12568: IFTRUE 12572
12570: GO 12598
12572: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
12573: LD_ADDR_VAR 0 3
12577: PUSH
12578: LD_INT 2
12580: PUSH
12581: LD_INT 3
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: LD_INT 5
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: ST_TO_ADDR
12596: GO 13421
12598: LD_INT 7
12600: DOUBLE
12601: EQUAL
12602: IFTRUE 12606
12604: GO 12632
12606: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: LD_INT 2
12614: PUSH
12615: LD_INT 3
12617: PUSH
12618: LD_INT 4
12620: PUSH
12621: LD_INT 5
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: ST_TO_ADDR
12630: GO 13421
12632: LD_INT 12
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12666
12640: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: LD_INT 2
12648: PUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: LD_INT 5
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: ST_TO_ADDR
12664: GO 13421
12666: LD_INT 13
12668: DOUBLE
12669: EQUAL
12670: IFTRUE 12674
12672: GO 12700
12674: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
12675: LD_ADDR_VAR 0 3
12679: PUSH
12680: LD_INT 2
12682: PUSH
12683: LD_INT 3
12685: PUSH
12686: LD_INT 4
12688: PUSH
12689: LD_INT 5
12691: PUSH
12692: EMPTY
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: ST_TO_ADDR
12698: GO 13421
12700: LD_INT 14
12702: DOUBLE
12703: EQUAL
12704: IFTRUE 12708
12706: GO 12726
12708: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
12709: LD_ADDR_VAR 0 3
12713: PUSH
12714: LD_INT 4
12716: PUSH
12717: LD_INT 5
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: ST_TO_ADDR
12724: GO 13421
12726: LD_INT 6
12728: DOUBLE
12729: EQUAL
12730: IFTRUE 12734
12732: GO 12752
12734: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
12735: LD_ADDR_VAR 0 3
12739: PUSH
12740: LD_INT 4
12742: PUSH
12743: LD_INT 5
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: ST_TO_ADDR
12750: GO 13421
12752: LD_INT 10
12754: DOUBLE
12755: EQUAL
12756: IFTRUE 12760
12758: GO 12778
12760: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: LD_INT 4
12768: PUSH
12769: LD_INT 5
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: ST_TO_ADDR
12776: GO 13421
12778: LD_INT 22
12780: DOUBLE
12781: EQUAL
12782: IFTRUE 12786
12784: GO 12812
12786: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
12787: LD_ADDR_VAR 0 3
12791: PUSH
12792: LD_INT 11
12794: PUSH
12795: LD_INT 12
12797: PUSH
12798: LD_INT 13
12800: PUSH
12801: LD_INT 14
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: ST_TO_ADDR
12810: GO 13421
12812: LD_INT 23
12814: DOUBLE
12815: EQUAL
12816: IFTRUE 12820
12818: GO 12846
12820: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
12821: LD_ADDR_VAR 0 3
12825: PUSH
12826: LD_INT 11
12828: PUSH
12829: LD_INT 12
12831: PUSH
12832: LD_INT 13
12834: PUSH
12835: LD_INT 14
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: ST_TO_ADDR
12844: GO 13421
12846: LD_INT 24
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12880
12854: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
12855: LD_ADDR_VAR 0 3
12859: PUSH
12860: LD_INT 11
12862: PUSH
12863: LD_INT 12
12865: PUSH
12866: LD_INT 13
12868: PUSH
12869: LD_INT 14
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: ST_TO_ADDR
12878: GO 13421
12880: LD_INT 30
12882: DOUBLE
12883: EQUAL
12884: IFTRUE 12888
12886: GO 12914
12888: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
12889: LD_ADDR_VAR 0 3
12893: PUSH
12894: LD_INT 11
12896: PUSH
12897: LD_INT 12
12899: PUSH
12900: LD_INT 13
12902: PUSH
12903: LD_INT 14
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: ST_TO_ADDR
12912: GO 13421
12914: LD_INT 25
12916: DOUBLE
12917: EQUAL
12918: IFTRUE 12922
12920: GO 12940
12922: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
12923: LD_ADDR_VAR 0 3
12927: PUSH
12928: LD_INT 13
12930: PUSH
12931: LD_INT 14
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: ST_TO_ADDR
12938: GO 13421
12940: LD_INT 27
12942: DOUBLE
12943: EQUAL
12944: IFTRUE 12948
12946: GO 12966
12948: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
12949: LD_ADDR_VAR 0 3
12953: PUSH
12954: LD_INT 13
12956: PUSH
12957: LD_INT 14
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: ST_TO_ADDR
12964: GO 13421
12966: LD_INT 92
12968: DOUBLE
12969: EQUAL
12970: IFTRUE 12974
12972: GO 13000
12974: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
12975: LD_ADDR_VAR 0 3
12979: PUSH
12980: LD_INT 11
12982: PUSH
12983: LD_INT 12
12985: PUSH
12986: LD_INT 13
12988: PUSH
12989: LD_INT 14
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: ST_TO_ADDR
12998: GO 13421
13000: LD_INT 28
13002: DOUBLE
13003: EQUAL
13004: IFTRUE 13008
13006: GO 13026
13008: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13009: LD_ADDR_VAR 0 3
13013: PUSH
13014: LD_INT 13
13016: PUSH
13017: LD_INT 14
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: ST_TO_ADDR
13024: GO 13421
13026: LD_INT 29
13028: DOUBLE
13029: EQUAL
13030: IFTRUE 13034
13032: GO 13052
13034: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13035: LD_ADDR_VAR 0 3
13039: PUSH
13040: LD_INT 13
13042: PUSH
13043: LD_INT 14
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: ST_TO_ADDR
13050: GO 13421
13052: LD_INT 31
13054: DOUBLE
13055: EQUAL
13056: IFTRUE 13060
13058: GO 13078
13060: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: LD_INT 13
13068: PUSH
13069: LD_INT 14
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: ST_TO_ADDR
13076: GO 13421
13078: LD_INT 26
13080: DOUBLE
13081: EQUAL
13082: IFTRUE 13086
13084: GO 13104
13086: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_INT 13
13094: PUSH
13095: LD_INT 14
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: ST_TO_ADDR
13102: GO 13421
13104: LD_INT 42
13106: DOUBLE
13107: EQUAL
13108: IFTRUE 13112
13110: GO 13138
13112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13113: LD_ADDR_VAR 0 3
13117: PUSH
13118: LD_INT 21
13120: PUSH
13121: LD_INT 22
13123: PUSH
13124: LD_INT 23
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: ST_TO_ADDR
13136: GO 13421
13138: LD_INT 43
13140: DOUBLE
13141: EQUAL
13142: IFTRUE 13146
13144: GO 13172
13146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13147: LD_ADDR_VAR 0 3
13151: PUSH
13152: LD_INT 21
13154: PUSH
13155: LD_INT 22
13157: PUSH
13158: LD_INT 23
13160: PUSH
13161: LD_INT 24
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13421
13172: LD_INT 44
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13206
13180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13181: LD_ADDR_VAR 0 3
13185: PUSH
13186: LD_INT 21
13188: PUSH
13189: LD_INT 22
13191: PUSH
13192: LD_INT 23
13194: PUSH
13195: LD_INT 24
13197: PUSH
13198: EMPTY
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: ST_TO_ADDR
13204: GO 13421
13206: LD_INT 45
13208: DOUBLE
13209: EQUAL
13210: IFTRUE 13214
13212: GO 13240
13214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13215: LD_ADDR_VAR 0 3
13219: PUSH
13220: LD_INT 21
13222: PUSH
13223: LD_INT 22
13225: PUSH
13226: LD_INT 23
13228: PUSH
13229: LD_INT 24
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: ST_TO_ADDR
13238: GO 13421
13240: LD_INT 49
13242: DOUBLE
13243: EQUAL
13244: IFTRUE 13248
13246: GO 13274
13248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13249: LD_ADDR_VAR 0 3
13253: PUSH
13254: LD_INT 21
13256: PUSH
13257: LD_INT 22
13259: PUSH
13260: LD_INT 23
13262: PUSH
13263: LD_INT 24
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: ST_TO_ADDR
13272: GO 13421
13274: LD_INT 51
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13282
13280: GO 13308
13282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
13283: LD_ADDR_VAR 0 3
13287: PUSH
13288: LD_INT 21
13290: PUSH
13291: LD_INT 22
13293: PUSH
13294: LD_INT 23
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: ST_TO_ADDR
13306: GO 13421
13308: LD_INT 52
13310: DOUBLE
13311: EQUAL
13312: IFTRUE 13316
13314: GO 13342
13316: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_INT 21
13324: PUSH
13325: LD_INT 22
13327: PUSH
13328: LD_INT 23
13330: PUSH
13331: LD_INT 24
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: ST_TO_ADDR
13340: GO 13421
13342: LD_INT 53
13344: DOUBLE
13345: EQUAL
13346: IFTRUE 13350
13348: GO 13368
13350: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: LD_INT 23
13358: PUSH
13359: LD_INT 24
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: ST_TO_ADDR
13366: GO 13421
13368: LD_INT 46
13370: DOUBLE
13371: EQUAL
13372: IFTRUE 13376
13374: GO 13394
13376: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
13377: LD_ADDR_VAR 0 3
13381: PUSH
13382: LD_INT 23
13384: PUSH
13385: LD_INT 24
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: ST_TO_ADDR
13392: GO 13421
13394: LD_INT 47
13396: DOUBLE
13397: EQUAL
13398: IFTRUE 13402
13400: GO 13420
13402: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 23
13410: PUSH
13411: LD_INT 24
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: ST_TO_ADDR
13418: GO 13421
13420: POP
// result := ( chassis in result ) ;
13421: LD_ADDR_VAR 0 3
13425: PUSH
13426: LD_VAR 0 1
13430: PUSH
13431: LD_VAR 0 3
13435: IN
13436: ST_TO_ADDR
// end ;
13437: LD_VAR 0 3
13441: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
13442: LD_INT 0
13444: PPUSH
13445: PPUSH
13446: PPUSH
13447: PPUSH
13448: PPUSH
13449: PPUSH
13450: PPUSH
// result := array ;
13451: LD_ADDR_VAR 0 5
13455: PUSH
13456: LD_VAR 0 1
13460: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
13461: LD_VAR 0 1
13465: NOT
13466: PUSH
13467: LD_VAR 0 2
13471: NOT
13472: OR
13473: PUSH
13474: LD_VAR 0 3
13478: NOT
13479: OR
13480: PUSH
13481: LD_VAR 0 2
13485: PUSH
13486: LD_VAR 0 1
13490: GREATER
13491: OR
13492: PUSH
13493: LD_VAR 0 3
13497: PUSH
13498: LD_VAR 0 1
13502: GREATER
13503: OR
13504: IFFALSE 13508
// exit ;
13506: GO 13804
// if direction then
13508: LD_VAR 0 4
13512: IFFALSE 13576
// begin d := 1 ;
13514: LD_ADDR_VAR 0 9
13518: PUSH
13519: LD_INT 1
13521: ST_TO_ADDR
// if i_from > i_to then
13522: LD_VAR 0 2
13526: PUSH
13527: LD_VAR 0 3
13531: GREATER
13532: IFFALSE 13558
// length := ( array - i_from ) + i_to else
13534: LD_ADDR_VAR 0 11
13538: PUSH
13539: LD_VAR 0 1
13543: PUSH
13544: LD_VAR 0 2
13548: MINUS
13549: PUSH
13550: LD_VAR 0 3
13554: PLUS
13555: ST_TO_ADDR
13556: GO 13574
// length := i_to - i_from ;
13558: LD_ADDR_VAR 0 11
13562: PUSH
13563: LD_VAR 0 3
13567: PUSH
13568: LD_VAR 0 2
13572: MINUS
13573: ST_TO_ADDR
// end else
13574: GO 13637
// begin d := - 1 ;
13576: LD_ADDR_VAR 0 9
13580: PUSH
13581: LD_INT 1
13583: NEG
13584: ST_TO_ADDR
// if i_from > i_to then
13585: LD_VAR 0 2
13589: PUSH
13590: LD_VAR 0 3
13594: GREATER
13595: IFFALSE 13615
// length := i_from - i_to else
13597: LD_ADDR_VAR 0 11
13601: PUSH
13602: LD_VAR 0 2
13606: PUSH
13607: LD_VAR 0 3
13611: MINUS
13612: ST_TO_ADDR
13613: GO 13637
// length := ( array - i_to ) + i_from ;
13615: LD_ADDR_VAR 0 11
13619: PUSH
13620: LD_VAR 0 1
13624: PUSH
13625: LD_VAR 0 3
13629: MINUS
13630: PUSH
13631: LD_VAR 0 2
13635: PLUS
13636: ST_TO_ADDR
// end ; if not length then
13637: LD_VAR 0 11
13641: NOT
13642: IFFALSE 13646
// exit ;
13644: GO 13804
// tmp := array ;
13646: LD_ADDR_VAR 0 10
13650: PUSH
13651: LD_VAR 0 1
13655: ST_TO_ADDR
// for i = 1 to length do
13656: LD_ADDR_VAR 0 6
13660: PUSH
13661: DOUBLE
13662: LD_INT 1
13664: DEC
13665: ST_TO_ADDR
13666: LD_VAR 0 11
13670: PUSH
13671: FOR_TO
13672: IFFALSE 13792
// begin for j = 1 to array do
13674: LD_ADDR_VAR 0 7
13678: PUSH
13679: DOUBLE
13680: LD_INT 1
13682: DEC
13683: ST_TO_ADDR
13684: LD_VAR 0 1
13688: PUSH
13689: FOR_TO
13690: IFFALSE 13778
// begin k := j + d ;
13692: LD_ADDR_VAR 0 8
13696: PUSH
13697: LD_VAR 0 7
13701: PUSH
13702: LD_VAR 0 9
13706: PLUS
13707: ST_TO_ADDR
// if k > array then
13708: LD_VAR 0 8
13712: PUSH
13713: LD_VAR 0 1
13717: GREATER
13718: IFFALSE 13728
// k := 1 ;
13720: LD_ADDR_VAR 0 8
13724: PUSH
13725: LD_INT 1
13727: ST_TO_ADDR
// if not k then
13728: LD_VAR 0 8
13732: NOT
13733: IFFALSE 13745
// k := array ;
13735: LD_ADDR_VAR 0 8
13739: PUSH
13740: LD_VAR 0 1
13744: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
13745: LD_ADDR_VAR 0 10
13749: PUSH
13750: LD_VAR 0 10
13754: PPUSH
13755: LD_VAR 0 8
13759: PPUSH
13760: LD_VAR 0 1
13764: PUSH
13765: LD_VAR 0 7
13769: ARRAY
13770: PPUSH
13771: CALL_OW 1
13775: ST_TO_ADDR
// end ;
13776: GO 13689
13778: POP
13779: POP
// array := tmp ;
13780: LD_ADDR_VAR 0 1
13784: PUSH
13785: LD_VAR 0 10
13789: ST_TO_ADDR
// end ;
13790: GO 13671
13792: POP
13793: POP
// result := array ;
13794: LD_ADDR_VAR 0 5
13798: PUSH
13799: LD_VAR 0 1
13803: ST_TO_ADDR
// end ;
13804: LD_VAR 0 5
13808: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
13809: LD_INT 0
13811: PPUSH
13812: PPUSH
// result := 0 ;
13813: LD_ADDR_VAR 0 3
13817: PUSH
13818: LD_INT 0
13820: ST_TO_ADDR
// if not array or not value in array then
13821: LD_VAR 0 1
13825: NOT
13826: PUSH
13827: LD_VAR 0 2
13831: PUSH
13832: LD_VAR 0 1
13836: IN
13837: NOT
13838: OR
13839: IFFALSE 13843
// exit ;
13841: GO 13897
// for i = 1 to array do
13843: LD_ADDR_VAR 0 4
13847: PUSH
13848: DOUBLE
13849: LD_INT 1
13851: DEC
13852: ST_TO_ADDR
13853: LD_VAR 0 1
13857: PUSH
13858: FOR_TO
13859: IFFALSE 13895
// if value = array [ i ] then
13861: LD_VAR 0 2
13865: PUSH
13866: LD_VAR 0 1
13870: PUSH
13871: LD_VAR 0 4
13875: ARRAY
13876: EQUAL
13877: IFFALSE 13893
// begin result := i ;
13879: LD_ADDR_VAR 0 3
13883: PUSH
13884: LD_VAR 0 4
13888: ST_TO_ADDR
// exit ;
13889: POP
13890: POP
13891: GO 13897
// end ;
13893: GO 13858
13895: POP
13896: POP
// end ;
13897: LD_VAR 0 3
13901: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
13902: LD_INT 0
13904: PPUSH
// vc_chassis := chassis ;
13905: LD_ADDR_OWVAR 37
13909: PUSH
13910: LD_VAR 0 1
13914: ST_TO_ADDR
// vc_engine := engine ;
13915: LD_ADDR_OWVAR 39
13919: PUSH
13920: LD_VAR 0 2
13924: ST_TO_ADDR
// vc_control := control ;
13925: LD_ADDR_OWVAR 38
13929: PUSH
13930: LD_VAR 0 3
13934: ST_TO_ADDR
// vc_weapon := weapon ;
13935: LD_ADDR_OWVAR 40
13939: PUSH
13940: LD_VAR 0 4
13944: ST_TO_ADDR
// vc_fuel_battery := fuel ;
13945: LD_ADDR_OWVAR 41
13949: PUSH
13950: LD_VAR 0 5
13954: ST_TO_ADDR
// end ;
13955: LD_VAR 0 6
13959: RET
// export function WantPlant ( unit ) ; var task ; begin
13960: LD_INT 0
13962: PPUSH
13963: PPUSH
// result := false ;
13964: LD_ADDR_VAR 0 2
13968: PUSH
13969: LD_INT 0
13971: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
13972: LD_ADDR_VAR 0 3
13976: PUSH
13977: LD_VAR 0 1
13981: PPUSH
13982: CALL_OW 437
13986: ST_TO_ADDR
// if task then
13987: LD_VAR 0 3
13991: IFFALSE 14019
// if task [ 1 ] [ 1 ] = p then
13993: LD_VAR 0 3
13997: PUSH
13998: LD_INT 1
14000: ARRAY
14001: PUSH
14002: LD_INT 1
14004: ARRAY
14005: PUSH
14006: LD_STRING p
14008: EQUAL
14009: IFFALSE 14019
// result := true ;
14011: LD_ADDR_VAR 0 2
14015: PUSH
14016: LD_INT 1
14018: ST_TO_ADDR
// end ;
14019: LD_VAR 0 2
14023: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14024: LD_INT 0
14026: PPUSH
14027: PPUSH
14028: PPUSH
14029: PPUSH
// if pos < 1 then
14030: LD_VAR 0 2
14034: PUSH
14035: LD_INT 1
14037: LESS
14038: IFFALSE 14042
// exit ;
14040: GO 14345
// if pos = 1 then
14042: LD_VAR 0 2
14046: PUSH
14047: LD_INT 1
14049: EQUAL
14050: IFFALSE 14083
// result := Replace ( arr , pos [ 1 ] , value ) else
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: LD_VAR 0 1
14061: PPUSH
14062: LD_VAR 0 2
14066: PUSH
14067: LD_INT 1
14069: ARRAY
14070: PPUSH
14071: LD_VAR 0 3
14075: PPUSH
14076: CALL_OW 1
14080: ST_TO_ADDR
14081: GO 14345
// begin tmp := arr ;
14083: LD_ADDR_VAR 0 6
14087: PUSH
14088: LD_VAR 0 1
14092: ST_TO_ADDR
// s_arr := [ tmp ] ;
14093: LD_ADDR_VAR 0 7
14097: PUSH
14098: LD_VAR 0 6
14102: PUSH
14103: EMPTY
14104: LIST
14105: ST_TO_ADDR
// for i = 1 to pos - 1 do
14106: LD_ADDR_VAR 0 5
14110: PUSH
14111: DOUBLE
14112: LD_INT 1
14114: DEC
14115: ST_TO_ADDR
14116: LD_VAR 0 2
14120: PUSH
14121: LD_INT 1
14123: MINUS
14124: PUSH
14125: FOR_TO
14126: IFFALSE 14171
// begin tmp := tmp [ pos [ i ] ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_VAR 0 6
14137: PUSH
14138: LD_VAR 0 2
14142: PUSH
14143: LD_VAR 0 5
14147: ARRAY
14148: ARRAY
14149: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14150: LD_ADDR_VAR 0 7
14154: PUSH
14155: LD_VAR 0 7
14159: PUSH
14160: LD_VAR 0 6
14164: PUSH
14165: EMPTY
14166: LIST
14167: ADD
14168: ST_TO_ADDR
// end ;
14169: GO 14125
14171: POP
14172: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14173: LD_ADDR_VAR 0 6
14177: PUSH
14178: LD_VAR 0 6
14182: PPUSH
14183: LD_VAR 0 2
14187: PUSH
14188: LD_VAR 0 2
14192: ARRAY
14193: PPUSH
14194: LD_VAR 0 3
14198: PPUSH
14199: CALL_OW 1
14203: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14204: LD_ADDR_VAR 0 7
14208: PUSH
14209: LD_VAR 0 7
14213: PPUSH
14214: LD_VAR 0 7
14218: PPUSH
14219: LD_VAR 0 6
14223: PPUSH
14224: CALL_OW 1
14228: ST_TO_ADDR
// for i = s_arr downto 2 do
14229: LD_ADDR_VAR 0 5
14233: PUSH
14234: DOUBLE
14235: LD_VAR 0 7
14239: INC
14240: ST_TO_ADDR
14241: LD_INT 2
14243: PUSH
14244: FOR_DOWNTO
14245: IFFALSE 14329
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14247: LD_ADDR_VAR 0 6
14251: PUSH
14252: LD_VAR 0 7
14256: PUSH
14257: LD_VAR 0 5
14261: PUSH
14262: LD_INT 1
14264: MINUS
14265: ARRAY
14266: PPUSH
14267: LD_VAR 0 2
14271: PUSH
14272: LD_VAR 0 5
14276: PUSH
14277: LD_INT 1
14279: MINUS
14280: ARRAY
14281: PPUSH
14282: LD_VAR 0 7
14286: PUSH
14287: LD_VAR 0 5
14291: ARRAY
14292: PPUSH
14293: CALL_OW 1
14297: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
14298: LD_ADDR_VAR 0 7
14302: PUSH
14303: LD_VAR 0 7
14307: PPUSH
14308: LD_VAR 0 5
14312: PUSH
14313: LD_INT 1
14315: MINUS
14316: PPUSH
14317: LD_VAR 0 6
14321: PPUSH
14322: CALL_OW 1
14326: ST_TO_ADDR
// end ;
14327: GO 14244
14329: POP
14330: POP
// result := s_arr [ 1 ] ;
14331: LD_ADDR_VAR 0 4
14335: PUSH
14336: LD_VAR 0 7
14340: PUSH
14341: LD_INT 1
14343: ARRAY
14344: ST_TO_ADDR
// end ; end ;
14345: LD_VAR 0 4
14349: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
14350: LD_INT 0
14352: PPUSH
14353: PPUSH
// if not list then
14354: LD_VAR 0 1
14358: NOT
14359: IFFALSE 14363
// exit ;
14361: GO 14454
// i := list [ pos1 ] ;
14363: LD_ADDR_VAR 0 5
14367: PUSH
14368: LD_VAR 0 1
14372: PUSH
14373: LD_VAR 0 2
14377: ARRAY
14378: ST_TO_ADDR
// if not i then
14379: LD_VAR 0 5
14383: NOT
14384: IFFALSE 14388
// exit ;
14386: GO 14454
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
14388: LD_ADDR_VAR 0 1
14392: PUSH
14393: LD_VAR 0 1
14397: PPUSH
14398: LD_VAR 0 2
14402: PPUSH
14403: LD_VAR 0 1
14407: PUSH
14408: LD_VAR 0 3
14412: ARRAY
14413: PPUSH
14414: CALL_OW 1
14418: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
14419: LD_ADDR_VAR 0 1
14423: PUSH
14424: LD_VAR 0 1
14428: PPUSH
14429: LD_VAR 0 3
14433: PPUSH
14434: LD_VAR 0 5
14438: PPUSH
14439: CALL_OW 1
14443: ST_TO_ADDR
// result := list ;
14444: LD_ADDR_VAR 0 4
14448: PUSH
14449: LD_VAR 0 1
14453: ST_TO_ADDR
// end ;
14454: LD_VAR 0 4
14458: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
14459: LD_INT 0
14461: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
14462: LD_ADDR_VAR 0 5
14466: PUSH
14467: LD_VAR 0 1
14471: PPUSH
14472: CALL_OW 250
14476: PPUSH
14477: LD_VAR 0 1
14481: PPUSH
14482: CALL_OW 251
14486: PPUSH
14487: LD_VAR 0 2
14491: PPUSH
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_VAR 0 4
14501: PPUSH
14502: CALL 14512 0 5
14506: ST_TO_ADDR
// end ;
14507: LD_VAR 0 5
14511: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
14512: LD_INT 0
14514: PPUSH
14515: PPUSH
14516: PPUSH
14517: PPUSH
// if not list then
14518: LD_VAR 0 3
14522: NOT
14523: IFFALSE 14527
// exit ;
14525: GO 14915
// result := [ ] ;
14527: LD_ADDR_VAR 0 6
14531: PUSH
14532: EMPTY
14533: ST_TO_ADDR
// for i in list do
14534: LD_ADDR_VAR 0 7
14538: PUSH
14539: LD_VAR 0 3
14543: PUSH
14544: FOR_IN
14545: IFFALSE 14747
// begin tmp := GetDistUnitXY ( i , x , y ) ;
14547: LD_ADDR_VAR 0 9
14551: PUSH
14552: LD_VAR 0 7
14556: PPUSH
14557: LD_VAR 0 1
14561: PPUSH
14562: LD_VAR 0 2
14566: PPUSH
14567: CALL_OW 297
14571: ST_TO_ADDR
// if not result then
14572: LD_VAR 0 6
14576: NOT
14577: IFFALSE 14603
// result := [ [ i , tmp ] ] else
14579: LD_ADDR_VAR 0 6
14583: PUSH
14584: LD_VAR 0 7
14588: PUSH
14589: LD_VAR 0 9
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: EMPTY
14599: LIST
14600: ST_TO_ADDR
14601: GO 14745
// begin if result [ result ] [ 2 ] < tmp then
14603: LD_VAR 0 6
14607: PUSH
14608: LD_VAR 0 6
14612: ARRAY
14613: PUSH
14614: LD_INT 2
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 9
14622: LESS
14623: IFFALSE 14665
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
14625: LD_ADDR_VAR 0 6
14629: PUSH
14630: LD_VAR 0 6
14634: PPUSH
14635: LD_VAR 0 6
14639: PUSH
14640: LD_INT 1
14642: PLUS
14643: PPUSH
14644: LD_VAR 0 7
14648: PUSH
14649: LD_VAR 0 9
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PPUSH
14658: CALL_OW 2
14662: ST_TO_ADDR
14663: GO 14745
// for j = 1 to result do
14665: LD_ADDR_VAR 0 8
14669: PUSH
14670: DOUBLE
14671: LD_INT 1
14673: DEC
14674: ST_TO_ADDR
14675: LD_VAR 0 6
14679: PUSH
14680: FOR_TO
14681: IFFALSE 14743
// begin if tmp < result [ j ] [ 2 ] then
14683: LD_VAR 0 9
14687: PUSH
14688: LD_VAR 0 6
14692: PUSH
14693: LD_VAR 0 8
14697: ARRAY
14698: PUSH
14699: LD_INT 2
14701: ARRAY
14702: LESS
14703: IFFALSE 14741
// begin result := Insert ( result , j , [ i , tmp ] ) ;
14705: LD_ADDR_VAR 0 6
14709: PUSH
14710: LD_VAR 0 6
14714: PPUSH
14715: LD_VAR 0 8
14719: PPUSH
14720: LD_VAR 0 7
14724: PUSH
14725: LD_VAR 0 9
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: PPUSH
14734: CALL_OW 2
14738: ST_TO_ADDR
// break ;
14739: GO 14743
// end ; end ;
14741: GO 14680
14743: POP
14744: POP
// end ; end ;
14745: GO 14544
14747: POP
14748: POP
// if result and not asc then
14749: LD_VAR 0 6
14753: PUSH
14754: LD_VAR 0 4
14758: NOT
14759: AND
14760: IFFALSE 14835
// begin tmp := result ;
14762: LD_ADDR_VAR 0 9
14766: PUSH
14767: LD_VAR 0 6
14771: ST_TO_ADDR
// for i = tmp downto 1 do
14772: LD_ADDR_VAR 0 7
14776: PUSH
14777: DOUBLE
14778: LD_VAR 0 9
14782: INC
14783: ST_TO_ADDR
14784: LD_INT 1
14786: PUSH
14787: FOR_DOWNTO
14788: IFFALSE 14833
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
14790: LD_ADDR_VAR 0 6
14794: PUSH
14795: LD_VAR 0 6
14799: PPUSH
14800: LD_VAR 0 9
14804: PUSH
14805: LD_VAR 0 7
14809: MINUS
14810: PUSH
14811: LD_INT 1
14813: PLUS
14814: PPUSH
14815: LD_VAR 0 9
14819: PUSH
14820: LD_VAR 0 7
14824: ARRAY
14825: PPUSH
14826: CALL_OW 1
14830: ST_TO_ADDR
14831: GO 14787
14833: POP
14834: POP
// end ; tmp := [ ] ;
14835: LD_ADDR_VAR 0 9
14839: PUSH
14840: EMPTY
14841: ST_TO_ADDR
// if mode then
14842: LD_VAR 0 5
14846: IFFALSE 14915
// begin for i = 1 to result do
14848: LD_ADDR_VAR 0 7
14852: PUSH
14853: DOUBLE
14854: LD_INT 1
14856: DEC
14857: ST_TO_ADDR
14858: LD_VAR 0 6
14862: PUSH
14863: FOR_TO
14864: IFFALSE 14903
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
14866: LD_ADDR_VAR 0 9
14870: PUSH
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 7
14880: PPUSH
14881: LD_VAR 0 6
14885: PUSH
14886: LD_VAR 0 7
14890: ARRAY
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: CALL_OW 1
14900: ST_TO_ADDR
14901: GO 14863
14903: POP
14904: POP
// result := tmp ;
14905: LD_ADDR_VAR 0 6
14909: PUSH
14910: LD_VAR 0 9
14914: ST_TO_ADDR
// end ; end ;
14915: LD_VAR 0 6
14919: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
14920: LD_INT 0
14922: PPUSH
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
14928: LD_ADDR_VAR 0 5
14932: PUSH
14933: LD_INT 0
14935: PUSH
14936: LD_INT 0
14938: PUSH
14939: LD_INT 0
14941: PUSH
14942: EMPTY
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: ST_TO_ADDR
// if not x or not y then
14950: LD_VAR 0 2
14954: NOT
14955: PUSH
14956: LD_VAR 0 3
14960: NOT
14961: OR
14962: IFFALSE 14966
// exit ;
14964: GO 16616
// if not range then
14966: LD_VAR 0 4
14970: NOT
14971: IFFALSE 14981
// range := 10 ;
14973: LD_ADDR_VAR 0 4
14977: PUSH
14978: LD_INT 10
14980: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14981: LD_ADDR_VAR 0 8
14985: PUSH
14986: LD_INT 81
14988: PUSH
14989: LD_VAR 0 1
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 92
15000: PUSH
15001: LD_VAR 0 2
15005: PUSH
15006: LD_VAR 0 3
15010: PUSH
15011: LD_VAR 0 4
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: PUSH
15022: LD_INT 3
15024: PUSH
15025: LD_INT 21
15027: PUSH
15028: LD_INT 3
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: EMPTY
15040: LIST
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: ST_TO_ADDR
// if not tmp then
15049: LD_VAR 0 8
15053: NOT
15054: IFFALSE 15058
// exit ;
15056: GO 16616
// for i in tmp do
15058: LD_ADDR_VAR 0 6
15062: PUSH
15063: LD_VAR 0 8
15067: PUSH
15068: FOR_IN
15069: IFFALSE 16591
// begin points := [ 0 , 0 , 0 ] ;
15071: LD_ADDR_VAR 0 9
15075: PUSH
15076: LD_INT 0
15078: PUSH
15079: LD_INT 0
15081: PUSH
15082: LD_INT 0
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: LIST
15089: ST_TO_ADDR
// bpoints := 1 ;
15090: LD_ADDR_VAR 0 10
15094: PUSH
15095: LD_INT 1
15097: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15098: LD_VAR 0 6
15102: PPUSH
15103: CALL_OW 247
15107: PUSH
15108: LD_INT 1
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15694
15116: POP
// begin if GetClass ( i ) = 1 then
15117: LD_VAR 0 6
15121: PPUSH
15122: CALL_OW 257
15126: PUSH
15127: LD_INT 1
15129: EQUAL
15130: IFFALSE 15151
// points := [ 10 , 5 , 3 ] ;
15132: LD_ADDR_VAR 0 9
15136: PUSH
15137: LD_INT 10
15139: PUSH
15140: LD_INT 5
15142: PUSH
15143: LD_INT 3
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: LIST
15150: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15151: LD_VAR 0 6
15155: PPUSH
15156: CALL_OW 257
15160: PUSH
15161: LD_INT 2
15163: PUSH
15164: LD_INT 3
15166: PUSH
15167: LD_INT 4
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: IN
15175: IFFALSE 15196
// points := [ 3 , 2 , 1 ] ;
15177: LD_ADDR_VAR 0 9
15181: PUSH
15182: LD_INT 3
15184: PUSH
15185: LD_INT 2
15187: PUSH
15188: LD_INT 1
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: LIST
15195: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15196: LD_VAR 0 6
15200: PPUSH
15201: CALL_OW 257
15205: PUSH
15206: LD_INT 5
15208: EQUAL
15209: IFFALSE 15230
// points := [ 130 , 5 , 2 ] ;
15211: LD_ADDR_VAR 0 9
15215: PUSH
15216: LD_INT 130
15218: PUSH
15219: LD_INT 5
15221: PUSH
15222: LD_INT 2
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: LIST
15229: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15230: LD_VAR 0 6
15234: PPUSH
15235: CALL_OW 257
15239: PUSH
15240: LD_INT 8
15242: EQUAL
15243: IFFALSE 15264
// points := [ 35 , 35 , 30 ] ;
15245: LD_ADDR_VAR 0 9
15249: PUSH
15250: LD_INT 35
15252: PUSH
15253: LD_INT 35
15255: PUSH
15256: LD_INT 30
15258: PUSH
15259: EMPTY
15260: LIST
15261: LIST
15262: LIST
15263: ST_TO_ADDR
// if GetClass ( i ) = 9 then
15264: LD_VAR 0 6
15268: PPUSH
15269: CALL_OW 257
15273: PUSH
15274: LD_INT 9
15276: EQUAL
15277: IFFALSE 15298
// points := [ 20 , 55 , 40 ] ;
15279: LD_ADDR_VAR 0 9
15283: PUSH
15284: LD_INT 20
15286: PUSH
15287: LD_INT 55
15289: PUSH
15290: LD_INT 40
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: LIST
15297: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
15298: LD_VAR 0 6
15302: PPUSH
15303: CALL_OW 257
15307: PUSH
15308: LD_INT 12
15310: PUSH
15311: LD_INT 16
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: IN
15318: IFFALSE 15339
// points := [ 5 , 3 , 2 ] ;
15320: LD_ADDR_VAR 0 9
15324: PUSH
15325: LD_INT 5
15327: PUSH
15328: LD_INT 3
15330: PUSH
15331: LD_INT 2
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: ST_TO_ADDR
// if GetClass ( i ) = 17 then
15339: LD_VAR 0 6
15343: PPUSH
15344: CALL_OW 257
15348: PUSH
15349: LD_INT 17
15351: EQUAL
15352: IFFALSE 15373
// points := [ 100 , 50 , 75 ] ;
15354: LD_ADDR_VAR 0 9
15358: PUSH
15359: LD_INT 100
15361: PUSH
15362: LD_INT 50
15364: PUSH
15365: LD_INT 75
15367: PUSH
15368: EMPTY
15369: LIST
15370: LIST
15371: LIST
15372: ST_TO_ADDR
// if GetClass ( i ) = 15 then
15373: LD_VAR 0 6
15377: PPUSH
15378: CALL_OW 257
15382: PUSH
15383: LD_INT 15
15385: EQUAL
15386: IFFALSE 15407
// points := [ 10 , 5 , 3 ] ;
15388: LD_ADDR_VAR 0 9
15392: PUSH
15393: LD_INT 10
15395: PUSH
15396: LD_INT 5
15398: PUSH
15399: LD_INT 3
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: LIST
15406: ST_TO_ADDR
// if GetClass ( i ) = 14 then
15407: LD_VAR 0 6
15411: PPUSH
15412: CALL_OW 257
15416: PUSH
15417: LD_INT 14
15419: EQUAL
15420: IFFALSE 15441
// points := [ 10 , 0 , 0 ] ;
15422: LD_ADDR_VAR 0 9
15426: PUSH
15427: LD_INT 10
15429: PUSH
15430: LD_INT 0
15432: PUSH
15433: LD_INT 0
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: LIST
15440: ST_TO_ADDR
// if GetClass ( i ) = 11 then
15441: LD_VAR 0 6
15445: PPUSH
15446: CALL_OW 257
15450: PUSH
15451: LD_INT 11
15453: EQUAL
15454: IFFALSE 15475
// points := [ 30 , 10 , 5 ] ;
15456: LD_ADDR_VAR 0 9
15460: PUSH
15461: LD_INT 30
15463: PUSH
15464: LD_INT 10
15466: PUSH
15467: LD_INT 5
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: LIST
15474: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
15475: LD_VAR 0 1
15479: PPUSH
15480: LD_INT 5
15482: PPUSH
15483: CALL_OW 321
15487: PUSH
15488: LD_INT 2
15490: EQUAL
15491: IFFALSE 15508
// bpoints := bpoints * 1.8 ;
15493: LD_ADDR_VAR 0 10
15497: PUSH
15498: LD_VAR 0 10
15502: PUSH
15503: LD_REAL  1.80000000000000E+0000
15506: MUL
15507: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
15508: LD_VAR 0 6
15512: PPUSH
15513: CALL_OW 257
15517: PUSH
15518: LD_INT 1
15520: PUSH
15521: LD_INT 2
15523: PUSH
15524: LD_INT 3
15526: PUSH
15527: LD_INT 4
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: IN
15536: PUSH
15537: LD_VAR 0 1
15541: PPUSH
15542: LD_INT 51
15544: PPUSH
15545: CALL_OW 321
15549: PUSH
15550: LD_INT 2
15552: EQUAL
15553: AND
15554: IFFALSE 15571
// bpoints := bpoints * 1.2 ;
15556: LD_ADDR_VAR 0 10
15560: PUSH
15561: LD_VAR 0 10
15565: PUSH
15566: LD_REAL  1.20000000000000E+0000
15569: MUL
15570: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
15571: LD_VAR 0 6
15575: PPUSH
15576: CALL_OW 257
15580: PUSH
15581: LD_INT 5
15583: PUSH
15584: LD_INT 7
15586: PUSH
15587: LD_INT 9
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: LIST
15594: IN
15595: PUSH
15596: LD_VAR 0 1
15600: PPUSH
15601: LD_INT 52
15603: PPUSH
15604: CALL_OW 321
15608: PUSH
15609: LD_INT 2
15611: EQUAL
15612: AND
15613: IFFALSE 15630
// bpoints := bpoints * 1.5 ;
15615: LD_ADDR_VAR 0 10
15619: PUSH
15620: LD_VAR 0 10
15624: PUSH
15625: LD_REAL  1.50000000000000E+0000
15628: MUL
15629: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
15630: LD_VAR 0 1
15634: PPUSH
15635: LD_INT 66
15637: PPUSH
15638: CALL_OW 321
15642: PUSH
15643: LD_INT 2
15645: EQUAL
15646: IFFALSE 15663
// bpoints := bpoints * 1.1 ;
15648: LD_ADDR_VAR 0 10
15652: PUSH
15653: LD_VAR 0 10
15657: PUSH
15658: LD_REAL  1.10000000000000E+0000
15661: MUL
15662: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
15663: LD_ADDR_VAR 0 10
15667: PUSH
15668: LD_VAR 0 10
15672: PUSH
15673: LD_VAR 0 6
15677: PPUSH
15678: LD_INT 1
15680: PPUSH
15681: CALL_OW 259
15685: PUSH
15686: LD_REAL  1.15000000000000E+0000
15689: MUL
15690: MUL
15691: ST_TO_ADDR
// end ; unit_vehicle :
15692: GO 16520
15694: LD_INT 2
15696: DOUBLE
15697: EQUAL
15698: IFTRUE 15702
15700: GO 16508
15702: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
15703: LD_VAR 0 6
15707: PPUSH
15708: CALL_OW 264
15712: PUSH
15713: LD_INT 2
15715: PUSH
15716: LD_INT 42
15718: PUSH
15719: LD_INT 24
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: LIST
15726: IN
15727: IFFALSE 15748
// points := [ 25 , 5 , 3 ] ;
15729: LD_ADDR_VAR 0 9
15733: PUSH
15734: LD_INT 25
15736: PUSH
15737: LD_INT 5
15739: PUSH
15740: LD_INT 3
15742: PUSH
15743: EMPTY
15744: LIST
15745: LIST
15746: LIST
15747: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
15748: LD_VAR 0 6
15752: PPUSH
15753: CALL_OW 264
15757: PUSH
15758: LD_INT 4
15760: PUSH
15761: LD_INT 43
15763: PUSH
15764: LD_INT 25
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: IN
15772: IFFALSE 15793
// points := [ 40 , 15 , 5 ] ;
15774: LD_ADDR_VAR 0 9
15778: PUSH
15779: LD_INT 40
15781: PUSH
15782: LD_INT 15
15784: PUSH
15785: LD_INT 5
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: LIST
15792: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
15793: LD_VAR 0 6
15797: PPUSH
15798: CALL_OW 264
15802: PUSH
15803: LD_INT 3
15805: PUSH
15806: LD_INT 23
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: IN
15813: IFFALSE 15834
// points := [ 7 , 25 , 8 ] ;
15815: LD_ADDR_VAR 0 9
15819: PUSH
15820: LD_INT 7
15822: PUSH
15823: LD_INT 25
15825: PUSH
15826: LD_INT 8
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
15834: LD_VAR 0 6
15838: PPUSH
15839: CALL_OW 264
15843: PUSH
15844: LD_INT 5
15846: PUSH
15847: LD_INT 27
15849: PUSH
15850: LD_INT 44
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: LIST
15857: IN
15858: IFFALSE 15879
// points := [ 14 , 50 , 16 ] ;
15860: LD_ADDR_VAR 0 9
15864: PUSH
15865: LD_INT 14
15867: PUSH
15868: LD_INT 50
15870: PUSH
15871: LD_INT 16
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: LIST
15878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
15879: LD_VAR 0 6
15883: PPUSH
15884: CALL_OW 264
15888: PUSH
15889: LD_INT 6
15891: PUSH
15892: LD_INT 46
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: IN
15899: IFFALSE 15920
// points := [ 32 , 120 , 70 ] ;
15901: LD_ADDR_VAR 0 9
15905: PUSH
15906: LD_INT 32
15908: PUSH
15909: LD_INT 120
15911: PUSH
15912: LD_INT 70
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: LIST
15919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
15920: LD_VAR 0 6
15924: PPUSH
15925: CALL_OW 264
15929: PUSH
15930: LD_INT 7
15932: PUSH
15933: LD_INT 28
15935: PUSH
15936: LD_INT 45
15938: PUSH
15939: LD_INT 92
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 35 , 20 , 45 ] ;
15950: LD_ADDR_VAR 0 9
15954: PUSH
15955: LD_INT 35
15957: PUSH
15958: LD_INT 20
15960: PUSH
15961: LD_INT 45
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
15969: LD_VAR 0 6
15973: PPUSH
15974: CALL_OW 264
15978: PUSH
15979: LD_INT 47
15981: PUSH
15982: EMPTY
15983: LIST
15984: IN
15985: IFFALSE 16006
// points := [ 67 , 45 , 75 ] ;
15987: LD_ADDR_VAR 0 9
15991: PUSH
15992: LD_INT 67
15994: PUSH
15995: LD_INT 45
15997: PUSH
15998: LD_INT 75
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: LIST
16005: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16006: LD_VAR 0 6
16010: PPUSH
16011: CALL_OW 264
16015: PUSH
16016: LD_INT 26
16018: PUSH
16019: EMPTY
16020: LIST
16021: IN
16022: IFFALSE 16043
// points := [ 120 , 30 , 80 ] ;
16024: LD_ADDR_VAR 0 9
16028: PUSH
16029: LD_INT 120
16031: PUSH
16032: LD_INT 30
16034: PUSH
16035: LD_INT 80
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16043: LD_VAR 0 6
16047: PPUSH
16048: CALL_OW 264
16052: PUSH
16053: LD_INT 22
16055: PUSH
16056: EMPTY
16057: LIST
16058: IN
16059: IFFALSE 16080
// points := [ 40 , 1 , 1 ] ;
16061: LD_ADDR_VAR 0 9
16065: PUSH
16066: LD_INT 40
16068: PUSH
16069: LD_INT 1
16071: PUSH
16072: LD_INT 1
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16080: LD_VAR 0 6
16084: PPUSH
16085: CALL_OW 264
16089: PUSH
16090: LD_INT 29
16092: PUSH
16093: EMPTY
16094: LIST
16095: IN
16096: IFFALSE 16117
// points := [ 70 , 200 , 400 ] ;
16098: LD_ADDR_VAR 0 9
16102: PUSH
16103: LD_INT 70
16105: PUSH
16106: LD_INT 200
16108: PUSH
16109: LD_INT 400
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16117: LD_VAR 0 6
16121: PPUSH
16122: CALL_OW 264
16126: PUSH
16127: LD_INT 14
16129: PUSH
16130: LD_INT 53
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: IN
16137: IFFALSE 16158
// points := [ 40 , 10 , 20 ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: LD_INT 40
16146: PUSH
16147: LD_INT 10
16149: PUSH
16150: LD_INT 20
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: LIST
16157: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 264
16167: PUSH
16168: LD_INT 9
16170: PUSH
16171: EMPTY
16172: LIST
16173: IN
16174: IFFALSE 16195
// points := [ 5 , 70 , 20 ] ;
16176: LD_ADDR_VAR 0 9
16180: PUSH
16181: LD_INT 5
16183: PUSH
16184: LD_INT 70
16186: PUSH
16187: LD_INT 20
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: LIST
16194: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16195: LD_VAR 0 6
16199: PPUSH
16200: CALL_OW 264
16204: PUSH
16205: LD_INT 10
16207: PUSH
16208: EMPTY
16209: LIST
16210: IN
16211: IFFALSE 16232
// points := [ 35 , 110 , 70 ] ;
16213: LD_ADDR_VAR 0 9
16217: PUSH
16218: LD_INT 35
16220: PUSH
16221: LD_INT 110
16223: PUSH
16224: LD_INT 70
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: LIST
16231: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16232: LD_VAR 0 6
16236: PPUSH
16237: CALL_OW 265
16241: PUSH
16242: LD_INT 25
16244: EQUAL
16245: IFFALSE 16266
// points := [ 80 , 65 , 100 ] ;
16247: LD_ADDR_VAR 0 9
16251: PUSH
16252: LD_INT 80
16254: PUSH
16255: LD_INT 65
16257: PUSH
16258: LD_INT 100
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: LIST
16265: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
16266: LD_VAR 0 6
16270: PPUSH
16271: CALL_OW 263
16275: PUSH
16276: LD_INT 1
16278: EQUAL
16279: IFFALSE 16314
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
16281: LD_ADDR_VAR 0 10
16285: PUSH
16286: LD_VAR 0 10
16290: PUSH
16291: LD_VAR 0 6
16295: PPUSH
16296: CALL_OW 311
16300: PPUSH
16301: LD_INT 3
16303: PPUSH
16304: CALL_OW 259
16308: PUSH
16309: LD_INT 4
16311: MUL
16312: MUL
16313: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
16314: LD_VAR 0 6
16318: PPUSH
16319: CALL_OW 263
16323: PUSH
16324: LD_INT 2
16326: EQUAL
16327: IFFALSE 16378
// begin j := IsControledBy ( i ) ;
16329: LD_ADDR_VAR 0 7
16333: PUSH
16334: LD_VAR 0 6
16338: PPUSH
16339: CALL_OW 312
16343: ST_TO_ADDR
// if j then
16344: LD_VAR 0 7
16348: IFFALSE 16378
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
16350: LD_ADDR_VAR 0 10
16354: PUSH
16355: LD_VAR 0 10
16359: PUSH
16360: LD_VAR 0 7
16364: PPUSH
16365: LD_INT 3
16367: PPUSH
16368: CALL_OW 259
16372: PUSH
16373: LD_INT 3
16375: MUL
16376: MUL
16377: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
16378: LD_VAR 0 6
16382: PPUSH
16383: CALL_OW 264
16387: PUSH
16388: LD_INT 5
16390: PUSH
16391: LD_INT 6
16393: PUSH
16394: LD_INT 46
16396: PUSH
16397: LD_INT 44
16399: PUSH
16400: LD_INT 47
16402: PUSH
16403: LD_INT 45
16405: PUSH
16406: LD_INT 28
16408: PUSH
16409: LD_INT 7
16411: PUSH
16412: LD_INT 27
16414: PUSH
16415: LD_INT 29
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: LIST
16422: LIST
16423: LIST
16424: LIST
16425: LIST
16426: LIST
16427: LIST
16428: LIST
16429: IN
16430: PUSH
16431: LD_VAR 0 1
16435: PPUSH
16436: LD_INT 52
16438: PPUSH
16439: CALL_OW 321
16443: PUSH
16444: LD_INT 2
16446: EQUAL
16447: AND
16448: IFFALSE 16465
// bpoints := bpoints * 1.2 ;
16450: LD_ADDR_VAR 0 10
16454: PUSH
16455: LD_VAR 0 10
16459: PUSH
16460: LD_REAL  1.20000000000000E+0000
16463: MUL
16464: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
16465: LD_VAR 0 6
16469: PPUSH
16470: CALL_OW 264
16474: PUSH
16475: LD_INT 6
16477: PUSH
16478: LD_INT 46
16480: PUSH
16481: LD_INT 47
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: LIST
16488: IN
16489: IFFALSE 16506
// bpoints := bpoints * 1.2 ;
16491: LD_ADDR_VAR 0 10
16495: PUSH
16496: LD_VAR 0 10
16500: PUSH
16501: LD_REAL  1.20000000000000E+0000
16504: MUL
16505: ST_TO_ADDR
// end ; unit_building :
16506: GO 16520
16508: LD_INT 3
16510: DOUBLE
16511: EQUAL
16512: IFTRUE 16516
16514: GO 16519
16516: POP
// ; end ;
16517: GO 16520
16519: POP
// for j = 1 to 3 do
16520: LD_ADDR_VAR 0 7
16524: PUSH
16525: DOUBLE
16526: LD_INT 1
16528: DEC
16529: ST_TO_ADDR
16530: LD_INT 3
16532: PUSH
16533: FOR_TO
16534: IFFALSE 16587
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
16536: LD_ADDR_VAR 0 5
16540: PUSH
16541: LD_VAR 0 5
16545: PPUSH
16546: LD_VAR 0 7
16550: PPUSH
16551: LD_VAR 0 5
16555: PUSH
16556: LD_VAR 0 7
16560: ARRAY
16561: PUSH
16562: LD_VAR 0 9
16566: PUSH
16567: LD_VAR 0 7
16571: ARRAY
16572: PUSH
16573: LD_VAR 0 10
16577: MUL
16578: PLUS
16579: PPUSH
16580: CALL_OW 1
16584: ST_TO_ADDR
16585: GO 16533
16587: POP
16588: POP
// end ;
16589: GO 15068
16591: POP
16592: POP
// result := Replace ( result , 4 , tmp ) ;
16593: LD_ADDR_VAR 0 5
16597: PUSH
16598: LD_VAR 0 5
16602: PPUSH
16603: LD_INT 4
16605: PPUSH
16606: LD_VAR 0 8
16610: PPUSH
16611: CALL_OW 1
16615: ST_TO_ADDR
// end ;
16616: LD_VAR 0 5
16620: RET
// export function DangerAtRange ( unit , range ) ; begin
16621: LD_INT 0
16623: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
16624: LD_ADDR_VAR 0 3
16628: PUSH
16629: LD_VAR 0 1
16633: PPUSH
16634: CALL_OW 255
16638: PPUSH
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL_OW 250
16648: PPUSH
16649: LD_VAR 0 1
16653: PPUSH
16654: CALL_OW 251
16658: PPUSH
16659: LD_VAR 0 2
16663: PPUSH
16664: CALL 14920 0 4
16668: ST_TO_ADDR
// end ;
16669: LD_VAR 0 3
16673: RET
// export function DangerInArea ( side , area ) ; begin
16674: LD_INT 0
16676: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
16677: LD_ADDR_VAR 0 3
16681: PUSH
16682: LD_VAR 0 2
16686: PPUSH
16687: LD_INT 81
16689: PUSH
16690: LD_VAR 0 1
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PPUSH
16699: CALL_OW 70
16703: ST_TO_ADDR
// end ;
16704: LD_VAR 0 3
16708: RET
// export function IsExtension ( b ) ; begin
16709: LD_INT 0
16711: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
16712: LD_ADDR_VAR 0 2
16716: PUSH
16717: LD_VAR 0 1
16721: PUSH
16722: LD_INT 23
16724: PUSH
16725: LD_INT 20
16727: PUSH
16728: LD_INT 22
16730: PUSH
16731: LD_INT 17
16733: PUSH
16734: LD_INT 24
16736: PUSH
16737: LD_INT 21
16739: PUSH
16740: LD_INT 19
16742: PUSH
16743: LD_INT 16
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 18
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: IN
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
// result := [ ] ;
16775: LD_ADDR_VAR 0 4
16779: PUSH
16780: EMPTY
16781: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
16782: LD_ADDR_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: PPUSH
16792: LD_INT 21
16794: PUSH
16795: LD_INT 3
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PPUSH
16802: CALL_OW 70
16806: ST_TO_ADDR
// if not tmp then
16807: LD_VAR 0 5
16811: NOT
16812: IFFALSE 16816
// exit ;
16814: GO 16880
// if checkLink then
16816: LD_VAR 0 3
16820: IFFALSE 16870
// begin for i in tmp do
16822: LD_ADDR_VAR 0 6
16826: PUSH
16827: LD_VAR 0 5
16831: PUSH
16832: FOR_IN
16833: IFFALSE 16868
// if GetBase ( i ) <> base then
16835: LD_VAR 0 6
16839: PPUSH
16840: CALL_OW 274
16844: PUSH
16845: LD_VAR 0 1
16849: NONEQUAL
16850: IFFALSE 16866
// ComLinkToBase ( base , i ) ;
16852: LD_VAR 0 1
16856: PPUSH
16857: LD_VAR 0 6
16861: PPUSH
16862: CALL_OW 169
16866: GO 16832
16868: POP
16869: POP
// end ; result := tmp ;
16870: LD_ADDR_VAR 0 4
16874: PUSH
16875: LD_VAR 0 5
16879: ST_TO_ADDR
// end ;
16880: LD_VAR 0 4
16884: RET
// export function ComComplete ( units , b ) ; var i ; begin
16885: LD_INT 0
16887: PPUSH
16888: PPUSH
// if not units then
16889: LD_VAR 0 1
16893: NOT
16894: IFFALSE 16898
// exit ;
16896: GO 16988
// for i in units do
16898: LD_ADDR_VAR 0 4
16902: PUSH
16903: LD_VAR 0 1
16907: PUSH
16908: FOR_IN
16909: IFFALSE 16986
// if BuildingStatus ( b ) = bs_build then
16911: LD_VAR 0 2
16915: PPUSH
16916: CALL_OW 461
16920: PUSH
16921: LD_INT 1
16923: EQUAL
16924: IFFALSE 16984
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
16926: LD_VAR 0 4
16930: PPUSH
16931: LD_STRING h
16933: PUSH
16934: LD_VAR 0 2
16938: PPUSH
16939: CALL_OW 250
16943: PUSH
16944: LD_VAR 0 2
16948: PPUSH
16949: CALL_OW 251
16953: PUSH
16954: LD_VAR 0 2
16958: PUSH
16959: LD_INT 0
16961: PUSH
16962: LD_INT 0
16964: PUSH
16965: LD_INT 0
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PUSH
16977: EMPTY
16978: LIST
16979: PPUSH
16980: CALL_OW 446
16984: GO 16908
16986: POP
16987: POP
// end ;
16988: LD_VAR 0 3
16992: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
16993: LD_INT 0
16995: PPUSH
16996: PPUSH
16997: PPUSH
16998: PPUSH
16999: PPUSH
17000: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17001: LD_VAR 0 1
17005: NOT
17006: PUSH
17007: LD_VAR 0 1
17011: PPUSH
17012: CALL_OW 263
17016: PUSH
17017: LD_INT 2
17019: NONEQUAL
17020: OR
17021: IFFALSE 17025
// exit ;
17023: GO 17341
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17025: LD_ADDR_VAR 0 6
17029: PUSH
17030: LD_INT 22
17032: PUSH
17033: LD_VAR 0 1
17037: PPUSH
17038: CALL_OW 255
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: PUSH
17047: LD_INT 2
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_INT 36
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: LD_INT 34
17062: PUSH
17063: LD_INT 31
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: LIST
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PPUSH
17079: CALL_OW 69
17083: ST_TO_ADDR
// if not tmp then
17084: LD_VAR 0 6
17088: NOT
17089: IFFALSE 17093
// exit ;
17091: GO 17341
// result := [ ] ;
17093: LD_ADDR_VAR 0 2
17097: PUSH
17098: EMPTY
17099: ST_TO_ADDR
// for i in tmp do
17100: LD_ADDR_VAR 0 3
17104: PUSH
17105: LD_VAR 0 6
17109: PUSH
17110: FOR_IN
17111: IFFALSE 17182
// begin t := UnitsInside ( i ) ;
17113: LD_ADDR_VAR 0 4
17117: PUSH
17118: LD_VAR 0 3
17122: PPUSH
17123: CALL_OW 313
17127: ST_TO_ADDR
// if t then
17128: LD_VAR 0 4
17132: IFFALSE 17180
// for j in t do
17134: LD_ADDR_VAR 0 7
17138: PUSH
17139: LD_VAR 0 4
17143: PUSH
17144: FOR_IN
17145: IFFALSE 17178
// result := Replace ( result , result + 1 , j ) ;
17147: LD_ADDR_VAR 0 2
17151: PUSH
17152: LD_VAR 0 2
17156: PPUSH
17157: LD_VAR 0 2
17161: PUSH
17162: LD_INT 1
17164: PLUS
17165: PPUSH
17166: LD_VAR 0 7
17170: PPUSH
17171: CALL_OW 1
17175: ST_TO_ADDR
17176: GO 17144
17178: POP
17179: POP
// end ;
17180: GO 17110
17182: POP
17183: POP
// if not result then
17184: LD_VAR 0 2
17188: NOT
17189: IFFALSE 17193
// exit ;
17191: GO 17341
// mech := result [ 1 ] ;
17193: LD_ADDR_VAR 0 5
17197: PUSH
17198: LD_VAR 0 2
17202: PUSH
17203: LD_INT 1
17205: ARRAY
17206: ST_TO_ADDR
// if result > 1 then
17207: LD_VAR 0 2
17211: PUSH
17212: LD_INT 1
17214: GREATER
17215: IFFALSE 17327
// begin for i = 2 to result do
17217: LD_ADDR_VAR 0 3
17221: PUSH
17222: DOUBLE
17223: LD_INT 2
17225: DEC
17226: ST_TO_ADDR
17227: LD_VAR 0 2
17231: PUSH
17232: FOR_TO
17233: IFFALSE 17325
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17235: LD_ADDR_VAR 0 4
17239: PUSH
17240: LD_VAR 0 2
17244: PUSH
17245: LD_VAR 0 3
17249: ARRAY
17250: PPUSH
17251: LD_INT 3
17253: PPUSH
17254: CALL_OW 259
17258: PUSH
17259: LD_VAR 0 2
17263: PUSH
17264: LD_VAR 0 3
17268: ARRAY
17269: PPUSH
17270: CALL_OW 432
17274: MINUS
17275: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
17276: LD_VAR 0 4
17280: PUSH
17281: LD_VAR 0 5
17285: PPUSH
17286: LD_INT 3
17288: PPUSH
17289: CALL_OW 259
17293: PUSH
17294: LD_VAR 0 5
17298: PPUSH
17299: CALL_OW 432
17303: MINUS
17304: GREATEREQUAL
17305: IFFALSE 17323
// mech := result [ i ] ;
17307: LD_ADDR_VAR 0 5
17311: PUSH
17312: LD_VAR 0 2
17316: PUSH
17317: LD_VAR 0 3
17321: ARRAY
17322: ST_TO_ADDR
// end ;
17323: GO 17232
17325: POP
17326: POP
// end ; ComLinkTo ( vehicle , mech ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: LD_VAR 0 5
17336: PPUSH
17337: CALL_OW 135
// end ;
17341: LD_VAR 0 2
17345: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
17346: LD_INT 0
17348: PPUSH
17349: PPUSH
17350: PPUSH
17351: PPUSH
17352: PPUSH
17353: PPUSH
17354: PPUSH
17355: PPUSH
17356: PPUSH
17357: PPUSH
17358: PPUSH
17359: PPUSH
17360: PPUSH
// result := [ ] ;
17361: LD_ADDR_VAR 0 7
17365: PUSH
17366: EMPTY
17367: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
17368: LD_VAR 0 1
17372: PPUSH
17373: CALL_OW 266
17377: PUSH
17378: LD_INT 0
17380: PUSH
17381: LD_INT 1
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: IN
17388: NOT
17389: IFFALSE 17393
// exit ;
17391: GO 19027
// if name then
17393: LD_VAR 0 3
17397: IFFALSE 17413
// SetBName ( base_dep , name ) ;
17399: LD_VAR 0 1
17403: PPUSH
17404: LD_VAR 0 3
17408: PPUSH
17409: CALL_OW 500
// base := GetBase ( base_dep ) ;
17413: LD_ADDR_VAR 0 15
17417: PUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: CALL_OW 274
17427: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
17428: LD_ADDR_VAR 0 16
17432: PUSH
17433: LD_VAR 0 1
17437: PPUSH
17438: CALL_OW 255
17442: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
17443: LD_ADDR_VAR 0 17
17447: PUSH
17448: LD_VAR 0 1
17452: PPUSH
17453: CALL_OW 248
17457: ST_TO_ADDR
// if sources then
17458: LD_VAR 0 5
17462: IFFALSE 17509
// for i = 1 to 3 do
17464: LD_ADDR_VAR 0 8
17468: PUSH
17469: DOUBLE
17470: LD_INT 1
17472: DEC
17473: ST_TO_ADDR
17474: LD_INT 3
17476: PUSH
17477: FOR_TO
17478: IFFALSE 17507
// AddResourceType ( base , i , sources [ i ] ) ;
17480: LD_VAR 0 15
17484: PPUSH
17485: LD_VAR 0 8
17489: PPUSH
17490: LD_VAR 0 5
17494: PUSH
17495: LD_VAR 0 8
17499: ARRAY
17500: PPUSH
17501: CALL_OW 276
17505: GO 17477
17507: POP
17508: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
17509: LD_ADDR_VAR 0 18
17513: PUSH
17514: LD_VAR 0 15
17518: PPUSH
17519: LD_VAR 0 2
17523: PPUSH
17524: LD_INT 1
17526: PPUSH
17527: CALL 16770 0 3
17531: ST_TO_ADDR
// InitHc ;
17532: CALL_OW 19
// InitUc ;
17536: CALL_OW 18
// uc_side := side ;
17540: LD_ADDR_OWVAR 20
17544: PUSH
17545: LD_VAR 0 16
17549: ST_TO_ADDR
// uc_nation := nation ;
17550: LD_ADDR_OWVAR 21
17554: PUSH
17555: LD_VAR 0 17
17559: ST_TO_ADDR
// if buildings then
17560: LD_VAR 0 18
17564: IFFALSE 18886
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
17566: LD_ADDR_VAR 0 19
17570: PUSH
17571: LD_VAR 0 18
17575: PPUSH
17576: LD_INT 2
17578: PUSH
17579: LD_INT 30
17581: PUSH
17582: LD_INT 29
17584: PUSH
17585: EMPTY
17586: LIST
17587: LIST
17588: PUSH
17589: LD_INT 30
17591: PUSH
17592: LD_INT 30
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: LIST
17603: PPUSH
17604: CALL_OW 72
17608: ST_TO_ADDR
// if tmp then
17609: LD_VAR 0 19
17613: IFFALSE 17661
// for i in tmp do
17615: LD_ADDR_VAR 0 8
17619: PUSH
17620: LD_VAR 0 19
17624: PUSH
17625: FOR_IN
17626: IFFALSE 17659
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
17628: LD_VAR 0 8
17632: PPUSH
17633: CALL_OW 250
17637: PPUSH
17638: LD_VAR 0 8
17642: PPUSH
17643: CALL_OW 251
17647: PPUSH
17648: LD_VAR 0 16
17652: PPUSH
17653: CALL_OW 441
17657: GO 17625
17659: POP
17660: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
17661: LD_VAR 0 18
17665: PPUSH
17666: LD_INT 2
17668: PUSH
17669: LD_INT 30
17671: PUSH
17672: LD_INT 32
17674: PUSH
17675: EMPTY
17676: LIST
17677: LIST
17678: PUSH
17679: LD_INT 30
17681: PUSH
17682: LD_INT 33
17684: PUSH
17685: EMPTY
17686: LIST
17687: LIST
17688: PUSH
17689: EMPTY
17690: LIST
17691: LIST
17692: LIST
17693: PPUSH
17694: CALL_OW 72
17698: IFFALSE 17786
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
17700: LD_ADDR_VAR 0 8
17704: PUSH
17705: LD_VAR 0 18
17709: PPUSH
17710: LD_INT 2
17712: PUSH
17713: LD_INT 30
17715: PUSH
17716: LD_INT 32
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: PUSH
17723: LD_INT 30
17725: PUSH
17726: LD_INT 33
17728: PUSH
17729: EMPTY
17730: LIST
17731: LIST
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: PPUSH
17738: CALL_OW 72
17742: PUSH
17743: FOR_IN
17744: IFFALSE 17784
// begin if not GetBWeapon ( i ) then
17746: LD_VAR 0 8
17750: PPUSH
17751: CALL_OW 269
17755: NOT
17756: IFFALSE 17782
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
17758: LD_VAR 0 8
17762: PPUSH
17763: LD_VAR 0 8
17767: PPUSH
17768: LD_VAR 0 2
17772: PPUSH
17773: CALL 19032 0 2
17777: PPUSH
17778: CALL_OW 431
// end ;
17782: GO 17743
17784: POP
17785: POP
// end ; for i = 1 to personel do
17786: LD_ADDR_VAR 0 8
17790: PUSH
17791: DOUBLE
17792: LD_INT 1
17794: DEC
17795: ST_TO_ADDR
17796: LD_VAR 0 6
17800: PUSH
17801: FOR_TO
17802: IFFALSE 18866
// begin if i > 4 then
17804: LD_VAR 0 8
17808: PUSH
17809: LD_INT 4
17811: GREATER
17812: IFFALSE 17816
// break ;
17814: GO 18866
// case i of 1 :
17816: LD_VAR 0 8
17820: PUSH
17821: LD_INT 1
17823: DOUBLE
17824: EQUAL
17825: IFTRUE 17829
17827: GO 17909
17829: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
17830: LD_ADDR_VAR 0 12
17834: PUSH
17835: LD_VAR 0 18
17839: PPUSH
17840: LD_INT 22
17842: PUSH
17843: LD_VAR 0 16
17847: PUSH
17848: EMPTY
17849: LIST
17850: LIST
17851: PUSH
17852: LD_INT 58
17854: PUSH
17855: EMPTY
17856: LIST
17857: PUSH
17858: LD_INT 2
17860: PUSH
17861: LD_INT 30
17863: PUSH
17864: LD_INT 32
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PUSH
17871: LD_INT 30
17873: PUSH
17874: LD_INT 4
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PUSH
17881: LD_INT 30
17883: PUSH
17884: LD_INT 5
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: PPUSH
17902: CALL_OW 72
17906: ST_TO_ADDR
17907: GO 18131
17909: LD_INT 2
17911: DOUBLE
17912: EQUAL
17913: IFTRUE 17917
17915: GO 17979
17917: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
17918: LD_ADDR_VAR 0 12
17922: PUSH
17923: LD_VAR 0 18
17927: PPUSH
17928: LD_INT 22
17930: PUSH
17931: LD_VAR 0 16
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: PUSH
17940: LD_INT 2
17942: PUSH
17943: LD_INT 30
17945: PUSH
17946: LD_INT 0
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: PUSH
17953: LD_INT 30
17955: PUSH
17956: LD_INT 1
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PPUSH
17972: CALL_OW 72
17976: ST_TO_ADDR
17977: GO 18131
17979: LD_INT 3
17981: DOUBLE
17982: EQUAL
17983: IFTRUE 17987
17985: GO 18049
17987: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
17988: LD_ADDR_VAR 0 12
17992: PUSH
17993: LD_VAR 0 18
17997: PPUSH
17998: LD_INT 22
18000: PUSH
18001: LD_VAR 0 16
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PUSH
18010: LD_INT 2
18012: PUSH
18013: LD_INT 30
18015: PUSH
18016: LD_INT 2
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 30
18025: PUSH
18026: LD_INT 3
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: LIST
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: PPUSH
18042: CALL_OW 72
18046: ST_TO_ADDR
18047: GO 18131
18049: LD_INT 4
18051: DOUBLE
18052: EQUAL
18053: IFTRUE 18057
18055: GO 18130
18057: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18058: LD_ADDR_VAR 0 12
18062: PUSH
18063: LD_VAR 0 18
18067: PPUSH
18068: LD_INT 22
18070: PUSH
18071: LD_VAR 0 16
18075: PUSH
18076: EMPTY
18077: LIST
18078: LIST
18079: PUSH
18080: LD_INT 2
18082: PUSH
18083: LD_INT 30
18085: PUSH
18086: LD_INT 6
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 30
18095: PUSH
18096: LD_INT 7
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 30
18105: PUSH
18106: LD_INT 8
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: EMPTY
18114: LIST
18115: LIST
18116: LIST
18117: LIST
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PPUSH
18123: CALL_OW 72
18127: ST_TO_ADDR
18128: GO 18131
18130: POP
// if i = 1 then
18131: LD_VAR 0 8
18135: PUSH
18136: LD_INT 1
18138: EQUAL
18139: IFFALSE 18250
// begin tmp := [ ] ;
18141: LD_ADDR_VAR 0 19
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// for j in f do
18148: LD_ADDR_VAR 0 9
18152: PUSH
18153: LD_VAR 0 12
18157: PUSH
18158: FOR_IN
18159: IFFALSE 18232
// if GetBType ( j ) = b_bunker then
18161: LD_VAR 0 9
18165: PPUSH
18166: CALL_OW 266
18170: PUSH
18171: LD_INT 32
18173: EQUAL
18174: IFFALSE 18201
// tmp := Insert ( tmp , 1 , j ) else
18176: LD_ADDR_VAR 0 19
18180: PUSH
18181: LD_VAR 0 19
18185: PPUSH
18186: LD_INT 1
18188: PPUSH
18189: LD_VAR 0 9
18193: PPUSH
18194: CALL_OW 2
18198: ST_TO_ADDR
18199: GO 18230
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18201: LD_ADDR_VAR 0 19
18205: PUSH
18206: LD_VAR 0 19
18210: PPUSH
18211: LD_VAR 0 19
18215: PUSH
18216: LD_INT 1
18218: PLUS
18219: PPUSH
18220: LD_VAR 0 9
18224: PPUSH
18225: CALL_OW 2
18229: ST_TO_ADDR
18230: GO 18158
18232: POP
18233: POP
// if tmp then
18234: LD_VAR 0 19
18238: IFFALSE 18250
// f := tmp ;
18240: LD_ADDR_VAR 0 12
18244: PUSH
18245: LD_VAR 0 19
18249: ST_TO_ADDR
// end ; x := personel [ i ] ;
18250: LD_ADDR_VAR 0 13
18254: PUSH
18255: LD_VAR 0 6
18259: PUSH
18260: LD_VAR 0 8
18264: ARRAY
18265: ST_TO_ADDR
// if x = - 1 then
18266: LD_VAR 0 13
18270: PUSH
18271: LD_INT 1
18273: NEG
18274: EQUAL
18275: IFFALSE 18484
// begin for j in f do
18277: LD_ADDR_VAR 0 9
18281: PUSH
18282: LD_VAR 0 12
18286: PUSH
18287: FOR_IN
18288: IFFALSE 18480
// repeat InitHc ;
18290: CALL_OW 19
// if GetBType ( j ) = b_barracks then
18294: LD_VAR 0 9
18298: PPUSH
18299: CALL_OW 266
18303: PUSH
18304: LD_INT 5
18306: EQUAL
18307: IFFALSE 18377
// begin if UnitsInside ( j ) < 3 then
18309: LD_VAR 0 9
18313: PPUSH
18314: CALL_OW 313
18318: PUSH
18319: LD_INT 3
18321: LESS
18322: IFFALSE 18358
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18324: LD_INT 0
18326: PPUSH
18327: LD_INT 5
18329: PUSH
18330: LD_INT 8
18332: PUSH
18333: LD_INT 9
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: PUSH
18341: LD_VAR 0 17
18345: ARRAY
18346: PPUSH
18347: LD_VAR 0 4
18351: PPUSH
18352: CALL_OW 380
18356: GO 18375
// PrepareHuman ( false , i , skill ) ;
18358: LD_INT 0
18360: PPUSH
18361: LD_VAR 0 8
18365: PPUSH
18366: LD_VAR 0 4
18370: PPUSH
18371: CALL_OW 380
// end else
18375: GO 18394
// PrepareHuman ( false , i , skill ) ;
18377: LD_INT 0
18379: PPUSH
18380: LD_VAR 0 8
18384: PPUSH
18385: LD_VAR 0 4
18389: PPUSH
18390: CALL_OW 380
// un := CreateHuman ;
18394: LD_ADDR_VAR 0 14
18398: PUSH
18399: CALL_OW 44
18403: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18404: LD_ADDR_VAR 0 7
18408: PUSH
18409: LD_VAR 0 7
18413: PPUSH
18414: LD_INT 1
18416: PPUSH
18417: LD_VAR 0 14
18421: PPUSH
18422: CALL_OW 2
18426: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
18427: LD_VAR 0 14
18431: PPUSH
18432: LD_VAR 0 9
18436: PPUSH
18437: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
18441: LD_VAR 0 9
18445: PPUSH
18446: CALL_OW 313
18450: PUSH
18451: LD_INT 6
18453: EQUAL
18454: PUSH
18455: LD_VAR 0 9
18459: PPUSH
18460: CALL_OW 266
18464: PUSH
18465: LD_INT 32
18467: PUSH
18468: LD_INT 31
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: IN
18475: OR
18476: IFFALSE 18290
18478: GO 18287
18480: POP
18481: POP
// end else
18482: GO 18864
// for j = 1 to x do
18484: LD_ADDR_VAR 0 9
18488: PUSH
18489: DOUBLE
18490: LD_INT 1
18492: DEC
18493: ST_TO_ADDR
18494: LD_VAR 0 13
18498: PUSH
18499: FOR_TO
18500: IFFALSE 18862
// begin InitHc ;
18502: CALL_OW 19
// if not f then
18506: LD_VAR 0 12
18510: NOT
18511: IFFALSE 18600
// begin PrepareHuman ( false , i , skill ) ;
18513: LD_INT 0
18515: PPUSH
18516: LD_VAR 0 8
18520: PPUSH
18521: LD_VAR 0 4
18525: PPUSH
18526: CALL_OW 380
// un := CreateHuman ;
18530: LD_ADDR_VAR 0 14
18534: PUSH
18535: CALL_OW 44
18539: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18540: LD_ADDR_VAR 0 7
18544: PUSH
18545: LD_VAR 0 7
18549: PPUSH
18550: LD_INT 1
18552: PPUSH
18553: LD_VAR 0 14
18557: PPUSH
18558: CALL_OW 2
18562: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18563: LD_VAR 0 14
18567: PPUSH
18568: LD_VAR 0 1
18572: PPUSH
18573: CALL_OW 250
18577: PPUSH
18578: LD_VAR 0 1
18582: PPUSH
18583: CALL_OW 251
18587: PPUSH
18588: LD_INT 10
18590: PPUSH
18591: LD_INT 0
18593: PPUSH
18594: CALL_OW 50
// continue ;
18598: GO 18499
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
18600: LD_VAR 0 12
18604: PUSH
18605: LD_INT 1
18607: ARRAY
18608: PPUSH
18609: CALL_OW 313
18613: PUSH
18614: LD_VAR 0 12
18618: PUSH
18619: LD_INT 1
18621: ARRAY
18622: PPUSH
18623: CALL_OW 266
18627: PUSH
18628: LD_INT 32
18630: PUSH
18631: LD_INT 31
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: IN
18638: AND
18639: PUSH
18640: LD_VAR 0 12
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 313
18653: PUSH
18654: LD_INT 6
18656: EQUAL
18657: OR
18658: IFFALSE 18678
// f := Delete ( f , 1 ) ;
18660: LD_ADDR_VAR 0 12
18664: PUSH
18665: LD_VAR 0 12
18669: PPUSH
18670: LD_INT 1
18672: PPUSH
18673: CALL_OW 3
18677: ST_TO_ADDR
// if not f then
18678: LD_VAR 0 12
18682: NOT
18683: IFFALSE 18701
// begin x := x + 2 ;
18685: LD_ADDR_VAR 0 13
18689: PUSH
18690: LD_VAR 0 13
18694: PUSH
18695: LD_INT 2
18697: PLUS
18698: ST_TO_ADDR
// continue ;
18699: GO 18499
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
18701: LD_VAR 0 12
18705: PUSH
18706: LD_INT 1
18708: ARRAY
18709: PPUSH
18710: CALL_OW 266
18714: PUSH
18715: LD_INT 5
18717: EQUAL
18718: IFFALSE 18792
// begin if UnitsInside ( f [ 1 ] ) < 3 then
18720: LD_VAR 0 12
18724: PUSH
18725: LD_INT 1
18727: ARRAY
18728: PPUSH
18729: CALL_OW 313
18733: PUSH
18734: LD_INT 3
18736: LESS
18737: IFFALSE 18773
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18739: LD_INT 0
18741: PPUSH
18742: LD_INT 5
18744: PUSH
18745: LD_INT 8
18747: PUSH
18748: LD_INT 9
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: LIST
18755: PUSH
18756: LD_VAR 0 17
18760: ARRAY
18761: PPUSH
18762: LD_VAR 0 4
18766: PPUSH
18767: CALL_OW 380
18771: GO 18790
// PrepareHuman ( false , i , skill ) ;
18773: LD_INT 0
18775: PPUSH
18776: LD_VAR 0 8
18780: PPUSH
18781: LD_VAR 0 4
18785: PPUSH
18786: CALL_OW 380
// end else
18790: GO 18809
// PrepareHuman ( false , i , skill ) ;
18792: LD_INT 0
18794: PPUSH
18795: LD_VAR 0 8
18799: PPUSH
18800: LD_VAR 0 4
18804: PPUSH
18805: CALL_OW 380
// un := CreateHuman ;
18809: LD_ADDR_VAR 0 14
18813: PUSH
18814: CALL_OW 44
18818: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18819: LD_ADDR_VAR 0 7
18823: PUSH
18824: LD_VAR 0 7
18828: PPUSH
18829: LD_INT 1
18831: PPUSH
18832: LD_VAR 0 14
18836: PPUSH
18837: CALL_OW 2
18841: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
18842: LD_VAR 0 14
18846: PPUSH
18847: LD_VAR 0 12
18851: PUSH
18852: LD_INT 1
18854: ARRAY
18855: PPUSH
18856: CALL_OW 52
// end ;
18860: GO 18499
18862: POP
18863: POP
// end ;
18864: GO 17801
18866: POP
18867: POP
// result := result ^ buildings ;
18868: LD_ADDR_VAR 0 7
18872: PUSH
18873: LD_VAR 0 7
18877: PUSH
18878: LD_VAR 0 18
18882: ADD
18883: ST_TO_ADDR
// end else
18884: GO 19027
// begin for i = 1 to personel do
18886: LD_ADDR_VAR 0 8
18890: PUSH
18891: DOUBLE
18892: LD_INT 1
18894: DEC
18895: ST_TO_ADDR
18896: LD_VAR 0 6
18900: PUSH
18901: FOR_TO
18902: IFFALSE 19025
// begin if i > 4 then
18904: LD_VAR 0 8
18908: PUSH
18909: LD_INT 4
18911: GREATER
18912: IFFALSE 18916
// break ;
18914: GO 19025
// x := personel [ i ] ;
18916: LD_ADDR_VAR 0 13
18920: PUSH
18921: LD_VAR 0 6
18925: PUSH
18926: LD_VAR 0 8
18930: ARRAY
18931: ST_TO_ADDR
// if x = - 1 then
18932: LD_VAR 0 13
18936: PUSH
18937: LD_INT 1
18939: NEG
18940: EQUAL
18941: IFFALSE 18945
// continue ;
18943: GO 18901
// PrepareHuman ( false , i , skill ) ;
18945: LD_INT 0
18947: PPUSH
18948: LD_VAR 0 8
18952: PPUSH
18953: LD_VAR 0 4
18957: PPUSH
18958: CALL_OW 380
// un := CreateHuman ;
18962: LD_ADDR_VAR 0 14
18966: PUSH
18967: CALL_OW 44
18971: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18972: LD_VAR 0 14
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: CALL_OW 250
18986: PPUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: CALL_OW 251
18996: PPUSH
18997: LD_INT 10
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: CALL_OW 50
// result := result ^ un ;
19007: LD_ADDR_VAR 0 7
19011: PUSH
19012: LD_VAR 0 7
19016: PUSH
19017: LD_VAR 0 14
19021: ADD
19022: ST_TO_ADDR
// end ;
19023: GO 18901
19025: POP
19026: POP
// end ; end ;
19027: LD_VAR 0 7
19031: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19032: LD_INT 0
19034: PPUSH
19035: PPUSH
19036: PPUSH
19037: PPUSH
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
19042: PPUSH
19043: PPUSH
19044: PPUSH
19045: PPUSH
19046: PPUSH
19047: PPUSH
19048: PPUSH
19049: PPUSH
// result := false ;
19050: LD_ADDR_VAR 0 3
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19058: LD_VAR 0 1
19062: NOT
19063: PUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: CALL_OW 266
19073: PUSH
19074: LD_INT 32
19076: PUSH
19077: LD_INT 33
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: IN
19084: NOT
19085: OR
19086: IFFALSE 19090
// exit ;
19088: GO 20199
// nat := GetNation ( tower ) ;
19090: LD_ADDR_VAR 0 12
19094: PUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: CALL_OW 248
19104: ST_TO_ADDR
// side := GetSide ( tower ) ;
19105: LD_ADDR_VAR 0 16
19109: PUSH
19110: LD_VAR 0 1
19114: PPUSH
19115: CALL_OW 255
19119: ST_TO_ADDR
// x := GetX ( tower ) ;
19120: LD_ADDR_VAR 0 10
19124: PUSH
19125: LD_VAR 0 1
19129: PPUSH
19130: CALL_OW 250
19134: ST_TO_ADDR
// y := GetY ( tower ) ;
19135: LD_ADDR_VAR 0 11
19139: PUSH
19140: LD_VAR 0 1
19144: PPUSH
19145: CALL_OW 251
19149: ST_TO_ADDR
// if not x or not y then
19150: LD_VAR 0 10
19154: NOT
19155: PUSH
19156: LD_VAR 0 11
19160: NOT
19161: OR
19162: IFFALSE 19166
// exit ;
19164: GO 20199
// weapon := 0 ;
19166: LD_ADDR_VAR 0 18
19170: PUSH
19171: LD_INT 0
19173: ST_TO_ADDR
// fac_list := [ ] ;
19174: LD_ADDR_VAR 0 17
19178: PUSH
19179: EMPTY
19180: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19181: LD_ADDR_VAR 0 6
19185: PUSH
19186: LD_VAR 0 1
19190: PPUSH
19191: CALL_OW 274
19195: PPUSH
19196: LD_VAR 0 2
19200: PPUSH
19201: LD_INT 0
19203: PPUSH
19204: CALL 16770 0 3
19208: PPUSH
19209: LD_INT 30
19211: PUSH
19212: LD_INT 3
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PPUSH
19219: CALL_OW 72
19223: ST_TO_ADDR
// if not factories then
19224: LD_VAR 0 6
19228: NOT
19229: IFFALSE 19233
// exit ;
19231: GO 20199
// for i in factories do
19233: LD_ADDR_VAR 0 8
19237: PUSH
19238: LD_VAR 0 6
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19269
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19246: LD_ADDR_VAR 0 17
19250: PUSH
19251: LD_VAR 0 17
19255: PUSH
19256: LD_VAR 0 8
19260: PPUSH
19261: CALL_OW 478
19265: UNION
19266: ST_TO_ADDR
19267: GO 19243
19269: POP
19270: POP
// if not fac_list then
19271: LD_VAR 0 17
19275: NOT
19276: IFFALSE 19280
// exit ;
19278: GO 20199
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
19280: LD_ADDR_VAR 0 5
19284: PUSH
19285: LD_INT 4
19287: PUSH
19288: LD_INT 5
19290: PUSH
19291: LD_INT 9
19293: PUSH
19294: LD_INT 10
19296: PUSH
19297: LD_INT 6
19299: PUSH
19300: LD_INT 7
19302: PUSH
19303: LD_INT 11
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: PUSH
19315: LD_INT 27
19317: PUSH
19318: LD_INT 28
19320: PUSH
19321: LD_INT 26
19323: PUSH
19324: LD_INT 30
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 43
19335: PUSH
19336: LD_INT 44
19338: PUSH
19339: LD_INT 46
19341: PUSH
19342: LD_INT 45
19344: PUSH
19345: LD_INT 47
19347: PUSH
19348: LD_INT 49
19350: PUSH
19351: EMPTY
19352: LIST
19353: LIST
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: PUSH
19359: EMPTY
19360: LIST
19361: LIST
19362: LIST
19363: PUSH
19364: LD_VAR 0 12
19368: ARRAY
19369: ST_TO_ADDR
// list := list isect fac_list ;
19370: LD_ADDR_VAR 0 5
19374: PUSH
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 17
19384: ISECT
19385: ST_TO_ADDR
// if not list then
19386: LD_VAR 0 5
19390: NOT
19391: IFFALSE 19395
// exit ;
19393: GO 20199
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
19395: LD_VAR 0 12
19399: PUSH
19400: LD_INT 3
19402: EQUAL
19403: PUSH
19404: LD_INT 49
19406: PUSH
19407: LD_VAR 0 5
19411: IN
19412: AND
19413: PUSH
19414: LD_INT 31
19416: PPUSH
19417: LD_VAR 0 16
19421: PPUSH
19422: CALL_OW 321
19426: PUSH
19427: LD_INT 2
19429: EQUAL
19430: AND
19431: IFFALSE 19491
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
19433: LD_INT 22
19435: PUSH
19436: LD_VAR 0 16
19440: PUSH
19441: EMPTY
19442: LIST
19443: LIST
19444: PUSH
19445: LD_INT 35
19447: PUSH
19448: LD_INT 49
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 91
19457: PUSH
19458: LD_VAR 0 1
19462: PUSH
19463: LD_INT 10
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: LIST
19475: PPUSH
19476: CALL_OW 69
19480: NOT
19481: IFFALSE 19491
// weapon := ru_time_lapser ;
19483: LD_ADDR_VAR 0 18
19487: PUSH
19488: LD_INT 49
19490: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
19491: LD_VAR 0 12
19495: PUSH
19496: LD_INT 1
19498: PUSH
19499: LD_INT 2
19501: PUSH
19502: EMPTY
19503: LIST
19504: LIST
19505: IN
19506: PUSH
19507: LD_INT 11
19509: PUSH
19510: LD_VAR 0 5
19514: IN
19515: PUSH
19516: LD_INT 30
19518: PUSH
19519: LD_VAR 0 5
19523: IN
19524: OR
19525: AND
19526: PUSH
19527: LD_INT 6
19529: PPUSH
19530: LD_VAR 0 16
19534: PPUSH
19535: CALL_OW 321
19539: PUSH
19540: LD_INT 2
19542: EQUAL
19543: AND
19544: IFFALSE 19709
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
19546: LD_INT 22
19548: PUSH
19549: LD_VAR 0 16
19553: PUSH
19554: EMPTY
19555: LIST
19556: LIST
19557: PUSH
19558: LD_INT 2
19560: PUSH
19561: LD_INT 35
19563: PUSH
19564: LD_INT 11
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 35
19573: PUSH
19574: LD_INT 30
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 91
19588: PUSH
19589: LD_VAR 0 1
19593: PUSH
19594: LD_INT 18
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: LIST
19606: PPUSH
19607: CALL_OW 69
19611: NOT
19612: PUSH
19613: LD_INT 22
19615: PUSH
19616: LD_VAR 0 16
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 2
19627: PUSH
19628: LD_INT 30
19630: PUSH
19631: LD_INT 32
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 30
19640: PUSH
19641: LD_INT 33
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PUSH
19653: LD_INT 91
19655: PUSH
19656: LD_VAR 0 1
19660: PUSH
19661: LD_INT 12
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: LIST
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: LIST
19673: PUSH
19674: EMPTY
19675: LIST
19676: PPUSH
19677: CALL_OW 69
19681: PUSH
19682: LD_INT 2
19684: GREATER
19685: AND
19686: IFFALSE 19709
// weapon := [ us_radar , ar_radar ] [ nat ] ;
19688: LD_ADDR_VAR 0 18
19692: PUSH
19693: LD_INT 11
19695: PUSH
19696: LD_INT 30
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_VAR 0 12
19707: ARRAY
19708: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
19709: LD_VAR 0 18
19713: NOT
19714: PUSH
19715: LD_INT 40
19717: PPUSH
19718: LD_VAR 0 16
19722: PPUSH
19723: CALL_OW 321
19727: PUSH
19728: LD_INT 2
19730: EQUAL
19731: AND
19732: PUSH
19733: LD_INT 7
19735: PUSH
19736: LD_VAR 0 5
19740: IN
19741: PUSH
19742: LD_INT 28
19744: PUSH
19745: LD_VAR 0 5
19749: IN
19750: OR
19751: PUSH
19752: LD_INT 45
19754: PUSH
19755: LD_VAR 0 5
19759: IN
19760: OR
19761: AND
19762: IFFALSE 20016
// begin hex := GetHexInfo ( x , y ) ;
19764: LD_ADDR_VAR 0 4
19768: PUSH
19769: LD_VAR 0 10
19773: PPUSH
19774: LD_VAR 0 11
19778: PPUSH
19779: CALL_OW 546
19783: ST_TO_ADDR
// if hex [ 1 ] then
19784: LD_VAR 0 4
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: IFFALSE 19796
// exit ;
19794: GO 20199
// height := hex [ 2 ] ;
19796: LD_ADDR_VAR 0 15
19800: PUSH
19801: LD_VAR 0 4
19805: PUSH
19806: LD_INT 2
19808: ARRAY
19809: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
19810: LD_ADDR_VAR 0 14
19814: PUSH
19815: LD_INT 0
19817: PUSH
19818: LD_INT 2
19820: PUSH
19821: LD_INT 3
19823: PUSH
19824: LD_INT 5
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: LIST
19831: LIST
19832: ST_TO_ADDR
// for i in tmp do
19833: LD_ADDR_VAR 0 8
19837: PUSH
19838: LD_VAR 0 14
19842: PUSH
19843: FOR_IN
19844: IFFALSE 20014
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
19846: LD_ADDR_VAR 0 9
19850: PUSH
19851: LD_VAR 0 10
19855: PPUSH
19856: LD_VAR 0 8
19860: PPUSH
19861: LD_INT 5
19863: PPUSH
19864: CALL_OW 272
19868: PUSH
19869: LD_VAR 0 11
19873: PPUSH
19874: LD_VAR 0 8
19878: PPUSH
19879: LD_INT 5
19881: PPUSH
19882: CALL_OW 273
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
19891: LD_VAR 0 9
19895: PUSH
19896: LD_INT 1
19898: ARRAY
19899: PPUSH
19900: LD_VAR 0 9
19904: PUSH
19905: LD_INT 2
19907: ARRAY
19908: PPUSH
19909: CALL_OW 488
19913: IFFALSE 20012
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
19915: LD_ADDR_VAR 0 4
19919: PUSH
19920: LD_VAR 0 9
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PPUSH
19929: LD_VAR 0 9
19933: PUSH
19934: LD_INT 2
19936: ARRAY
19937: PPUSH
19938: CALL_OW 546
19942: ST_TO_ADDR
// if hex [ 1 ] then
19943: LD_VAR 0 4
19947: PUSH
19948: LD_INT 1
19950: ARRAY
19951: IFFALSE 19955
// continue ;
19953: GO 19843
// h := hex [ 2 ] ;
19955: LD_ADDR_VAR 0 13
19959: PUSH
19960: LD_VAR 0 4
19964: PUSH
19965: LD_INT 2
19967: ARRAY
19968: ST_TO_ADDR
// if h + 7 < height then
19969: LD_VAR 0 13
19973: PUSH
19974: LD_INT 7
19976: PLUS
19977: PUSH
19978: LD_VAR 0 15
19982: LESS
19983: IFFALSE 20012
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
19985: LD_ADDR_VAR 0 18
19989: PUSH
19990: LD_INT 7
19992: PUSH
19993: LD_INT 28
19995: PUSH
19996: LD_INT 45
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: LIST
20003: PUSH
20004: LD_VAR 0 12
20008: ARRAY
20009: ST_TO_ADDR
// break ;
20010: GO 20014
// end ; end ; end ;
20012: GO 19843
20014: POP
20015: POP
// end ; if not weapon then
20016: LD_VAR 0 18
20020: NOT
20021: IFFALSE 20081
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20023: LD_ADDR_VAR 0 5
20027: PUSH
20028: LD_VAR 0 5
20032: PUSH
20033: LD_INT 11
20035: PUSH
20036: LD_INT 30
20038: PUSH
20039: LD_INT 49
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: LIST
20046: DIFF
20047: ST_TO_ADDR
// if not list then
20048: LD_VAR 0 5
20052: NOT
20053: IFFALSE 20057
// exit ;
20055: GO 20199
// weapon := list [ rand ( 1 , list ) ] ;
20057: LD_ADDR_VAR 0 18
20061: PUSH
20062: LD_VAR 0 5
20066: PUSH
20067: LD_INT 1
20069: PPUSH
20070: LD_VAR 0 5
20074: PPUSH
20075: CALL_OW 12
20079: ARRAY
20080: ST_TO_ADDR
// end ; if weapon then
20081: LD_VAR 0 18
20085: IFFALSE 20199
// begin tmp := CostOfWeapon ( weapon ) ;
20087: LD_ADDR_VAR 0 14
20091: PUSH
20092: LD_VAR 0 18
20096: PPUSH
20097: CALL_OW 451
20101: ST_TO_ADDR
// j := GetBase ( tower ) ;
20102: LD_ADDR_VAR 0 9
20106: PUSH
20107: LD_VAR 0 1
20111: PPUSH
20112: CALL_OW 274
20116: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20117: LD_VAR 0 9
20121: PPUSH
20122: LD_INT 1
20124: PPUSH
20125: CALL_OW 275
20129: PUSH
20130: LD_VAR 0 14
20134: PUSH
20135: LD_INT 1
20137: ARRAY
20138: GREATEREQUAL
20139: PUSH
20140: LD_VAR 0 9
20144: PPUSH
20145: LD_INT 2
20147: PPUSH
20148: CALL_OW 275
20152: PUSH
20153: LD_VAR 0 14
20157: PUSH
20158: LD_INT 2
20160: ARRAY
20161: GREATEREQUAL
20162: AND
20163: PUSH
20164: LD_VAR 0 9
20168: PPUSH
20169: LD_INT 3
20171: PPUSH
20172: CALL_OW 275
20176: PUSH
20177: LD_VAR 0 14
20181: PUSH
20182: LD_INT 3
20184: ARRAY
20185: GREATEREQUAL
20186: AND
20187: IFFALSE 20199
// result := weapon ;
20189: LD_ADDR_VAR 0 3
20193: PUSH
20194: LD_VAR 0 18
20198: ST_TO_ADDR
// end ; end ;
20199: LD_VAR 0 3
20203: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20204: LD_INT 0
20206: PPUSH
20207: PPUSH
// result := true ;
20208: LD_ADDR_VAR 0 3
20212: PUSH
20213: LD_INT 1
20215: ST_TO_ADDR
// if array1 = array2 then
20216: LD_VAR 0 1
20220: PUSH
20221: LD_VAR 0 2
20225: EQUAL
20226: IFFALSE 20286
// begin for i = 1 to array1 do
20228: LD_ADDR_VAR 0 4
20232: PUSH
20233: DOUBLE
20234: LD_INT 1
20236: DEC
20237: ST_TO_ADDR
20238: LD_VAR 0 1
20242: PUSH
20243: FOR_TO
20244: IFFALSE 20282
// if array1 [ i ] <> array2 [ i ] then
20246: LD_VAR 0 1
20250: PUSH
20251: LD_VAR 0 4
20255: ARRAY
20256: PUSH
20257: LD_VAR 0 2
20261: PUSH
20262: LD_VAR 0 4
20266: ARRAY
20267: NONEQUAL
20268: IFFALSE 20280
// begin result := false ;
20270: LD_ADDR_VAR 0 3
20274: PUSH
20275: LD_INT 0
20277: ST_TO_ADDR
// break ;
20278: GO 20282
// end ;
20280: GO 20243
20282: POP
20283: POP
// end else
20284: GO 20294
// result := false ;
20286: LD_ADDR_VAR 0 3
20290: PUSH
20291: LD_INT 0
20293: ST_TO_ADDR
// end ;
20294: LD_VAR 0 3
20298: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
20299: LD_INT 0
20301: PPUSH
20302: PPUSH
// if not array1 or not array2 then
20303: LD_VAR 0 1
20307: NOT
20308: PUSH
20309: LD_VAR 0 2
20313: NOT
20314: OR
20315: IFFALSE 20319
// exit ;
20317: GO 20383
// result := true ;
20319: LD_ADDR_VAR 0 3
20323: PUSH
20324: LD_INT 1
20326: ST_TO_ADDR
// for i = 1 to array1 do
20327: LD_ADDR_VAR 0 4
20331: PUSH
20332: DOUBLE
20333: LD_INT 1
20335: DEC
20336: ST_TO_ADDR
20337: LD_VAR 0 1
20341: PUSH
20342: FOR_TO
20343: IFFALSE 20381
// if array1 [ i ] <> array2 [ i ] then
20345: LD_VAR 0 1
20349: PUSH
20350: LD_VAR 0 4
20354: ARRAY
20355: PUSH
20356: LD_VAR 0 2
20360: PUSH
20361: LD_VAR 0 4
20365: ARRAY
20366: NONEQUAL
20367: IFFALSE 20379
// begin result := false ;
20369: LD_ADDR_VAR 0 3
20373: PUSH
20374: LD_INT 0
20376: ST_TO_ADDR
// break ;
20377: GO 20381
// end ;
20379: GO 20342
20381: POP
20382: POP
// end ;
20383: LD_VAR 0 3
20387: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
20388: LD_INT 0
20390: PPUSH
20391: PPUSH
20392: PPUSH
// pom := GetBase ( fac ) ;
20393: LD_ADDR_VAR 0 5
20397: PUSH
20398: LD_VAR 0 1
20402: PPUSH
20403: CALL_OW 274
20407: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
20408: LD_ADDR_VAR 0 4
20412: PUSH
20413: LD_VAR 0 2
20417: PUSH
20418: LD_INT 1
20420: ARRAY
20421: PPUSH
20422: LD_VAR 0 2
20426: PUSH
20427: LD_INT 2
20429: ARRAY
20430: PPUSH
20431: LD_VAR 0 2
20435: PUSH
20436: LD_INT 3
20438: ARRAY
20439: PPUSH
20440: LD_VAR 0 2
20444: PUSH
20445: LD_INT 4
20447: ARRAY
20448: PPUSH
20449: CALL_OW 449
20453: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_VAR 0 5
20463: PPUSH
20464: LD_INT 1
20466: PPUSH
20467: CALL_OW 275
20471: PUSH
20472: LD_VAR 0 4
20476: PUSH
20477: LD_INT 1
20479: ARRAY
20480: GREATEREQUAL
20481: PUSH
20482: LD_VAR 0 5
20486: PPUSH
20487: LD_INT 2
20489: PPUSH
20490: CALL_OW 275
20494: PUSH
20495: LD_VAR 0 4
20499: PUSH
20500: LD_INT 2
20502: ARRAY
20503: GREATEREQUAL
20504: AND
20505: PUSH
20506: LD_VAR 0 5
20510: PPUSH
20511: LD_INT 3
20513: PPUSH
20514: CALL_OW 275
20518: PUSH
20519: LD_VAR 0 4
20523: PUSH
20524: LD_INT 3
20526: ARRAY
20527: GREATEREQUAL
20528: AND
20529: ST_TO_ADDR
// end ;
20530: LD_VAR 0 3
20534: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
20535: LD_INT 0
20537: PPUSH
20538: PPUSH
20539: PPUSH
20540: PPUSH
// pom := GetBase ( building ) ;
20541: LD_ADDR_VAR 0 3
20545: PUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 274
20555: ST_TO_ADDR
// if not pom then
20556: LD_VAR 0 3
20560: NOT
20561: IFFALSE 20565
// exit ;
20563: GO 20735
// btype := GetBType ( building ) ;
20565: LD_ADDR_VAR 0 5
20569: PUSH
20570: LD_VAR 0 1
20574: PPUSH
20575: CALL_OW 266
20579: ST_TO_ADDR
// if btype = b_armoury then
20580: LD_VAR 0 5
20584: PUSH
20585: LD_INT 4
20587: EQUAL
20588: IFFALSE 20598
// btype := b_barracks ;
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: LD_INT 5
20597: ST_TO_ADDR
// if btype = b_depot then
20598: LD_VAR 0 5
20602: PUSH
20603: LD_INT 0
20605: EQUAL
20606: IFFALSE 20616
// btype := b_warehouse ;
20608: LD_ADDR_VAR 0 5
20612: PUSH
20613: LD_INT 1
20615: ST_TO_ADDR
// if btype = b_workshop then
20616: LD_VAR 0 5
20620: PUSH
20621: LD_INT 2
20623: EQUAL
20624: IFFALSE 20634
// btype := b_factory ;
20626: LD_ADDR_VAR 0 5
20630: PUSH
20631: LD_INT 3
20633: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20634: LD_ADDR_VAR 0 4
20638: PUSH
20639: LD_VAR 0 5
20643: PPUSH
20644: LD_VAR 0 1
20648: PPUSH
20649: CALL_OW 248
20653: PPUSH
20654: CALL_OW 450
20658: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20659: LD_ADDR_VAR 0 2
20663: PUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: LD_INT 1
20671: PPUSH
20672: CALL_OW 275
20676: PUSH
20677: LD_VAR 0 4
20681: PUSH
20682: LD_INT 1
20684: ARRAY
20685: GREATEREQUAL
20686: PUSH
20687: LD_VAR 0 3
20691: PPUSH
20692: LD_INT 2
20694: PPUSH
20695: CALL_OW 275
20699: PUSH
20700: LD_VAR 0 4
20704: PUSH
20705: LD_INT 2
20707: ARRAY
20708: GREATEREQUAL
20709: AND
20710: PUSH
20711: LD_VAR 0 3
20715: PPUSH
20716: LD_INT 3
20718: PPUSH
20719: CALL_OW 275
20723: PUSH
20724: LD_VAR 0 4
20728: PUSH
20729: LD_INT 3
20731: ARRAY
20732: GREATEREQUAL
20733: AND
20734: ST_TO_ADDR
// end ;
20735: LD_VAR 0 2
20739: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// pom := GetBase ( building ) ;
20745: LD_ADDR_VAR 0 4
20749: PUSH
20750: LD_VAR 0 1
20754: PPUSH
20755: CALL_OW 274
20759: ST_TO_ADDR
// if not pom then
20760: LD_VAR 0 4
20764: NOT
20765: IFFALSE 20769
// exit ;
20767: GO 20870
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20769: LD_ADDR_VAR 0 5
20773: PUSH
20774: LD_VAR 0 2
20778: PPUSH
20779: LD_VAR 0 1
20783: PPUSH
20784: CALL_OW 248
20788: PPUSH
20789: CALL_OW 450
20793: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20794: LD_ADDR_VAR 0 3
20798: PUSH
20799: LD_VAR 0 4
20803: PPUSH
20804: LD_INT 1
20806: PPUSH
20807: CALL_OW 275
20811: PUSH
20812: LD_VAR 0 5
20816: PUSH
20817: LD_INT 1
20819: ARRAY
20820: GREATEREQUAL
20821: PUSH
20822: LD_VAR 0 4
20826: PPUSH
20827: LD_INT 2
20829: PPUSH
20830: CALL_OW 275
20834: PUSH
20835: LD_VAR 0 5
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: GREATEREQUAL
20844: AND
20845: PUSH
20846: LD_VAR 0 4
20850: PPUSH
20851: LD_INT 3
20853: PPUSH
20854: CALL_OW 275
20858: PUSH
20859: LD_VAR 0 5
20863: PUSH
20864: LD_INT 3
20866: ARRAY
20867: GREATEREQUAL
20868: AND
20869: ST_TO_ADDR
// end ;
20870: LD_VAR 0 3
20874: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking every 0 0$1 do
20875: GO 20877
20877: DISABLE
// begin enable ;
20878: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
20879: LD_STRING updateTimer(
20881: PUSH
20882: LD_OWVAR 1
20886: STR
20887: PUSH
20888: LD_STRING );
20890: STR
20891: PPUSH
20892: CALL_OW 559
// end ;
20896: END
// export function SOS_MapStart ( ) ; begin
20897: LD_INT 0
20899: PPUSH
// if streamModeActive then
20900: LD_EXP 29
20904: IFFALSE 20913
// DefineStreamItems ( true ) ;
20906: LD_INT 1
20908: PPUSH
20909: CALL 22717 0 1
// UpdateLuaVariables ( ) ;
20913: CALL 20930 0 0
// UpdateFactoryWaypoints ( ) ;
20917: CALL 35578 0 0
// UpdateWarehouseGatheringPoints ( ) ;
20921: CALL 35835 0 0
// end ;
20925: LD_VAR 0 1
20929: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
20930: LD_INT 0
20932: PPUSH
// if not globalGameSaveCounter then
20933: LD_EXP 28
20937: NOT
20938: IFFALSE 20949
// ToLua ( setGameSaveCounter(0) ) else
20940: LD_STRING setGameSaveCounter(0)
20942: PPUSH
20943: CALL_OW 559
20947: GO 20981
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
20949: LD_ADDR_EXP 28
20953: PUSH
20954: LD_EXP 28
20958: PPUSH
20959: NOP4
20963: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
20964: LD_STRING setGameSaveCounter(
20966: PUSH
20967: LD_EXP 28
20971: STR
20972: PUSH
20973: LD_STRING )
20975: STR
20976: PPUSH
20977: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
20981: LD_STRING setGameDifficulty(
20983: PUSH
20984: LD_OWVAR 67
20988: STR
20989: PUSH
20990: LD_STRING )
20992: STR
20993: PPUSH
20994: CALL_OW 559
// end ;
20998: LD_VAR 0 1
21002: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
21003: LD_INT 0
21005: PPUSH
// if p2 = stream_mode then
21006: LD_VAR 0 2
21010: PUSH
21011: LD_INT 100
21013: EQUAL
21014: IFFALSE 22017
// begin if not StreamModeActive then
21016: LD_EXP 29
21020: NOT
21021: IFFALSE 21031
// StreamModeActive := true ;
21023: LD_ADDR_EXP 29
21027: PUSH
21028: LD_INT 1
21030: ST_TO_ADDR
// if p3 = 0 then
21031: LD_VAR 0 3
21035: PUSH
21036: LD_INT 0
21038: EQUAL
21039: IFFALSE 21045
// InitStreamMode ;
21041: CALL 22253 0 0
// if p3 = 1 then
21045: LD_VAR 0 3
21049: PUSH
21050: LD_INT 1
21052: EQUAL
21053: IFFALSE 21063
// sRocket := true ;
21055: LD_ADDR_EXP 34
21059: PUSH
21060: LD_INT 1
21062: ST_TO_ADDR
// if p3 = 2 then
21063: LD_VAR 0 3
21067: PUSH
21068: LD_INT 2
21070: EQUAL
21071: IFFALSE 21081
// sSpeed := true ;
21073: LD_ADDR_EXP 33
21077: PUSH
21078: LD_INT 1
21080: ST_TO_ADDR
// if p3 = 3 then
21081: LD_VAR 0 3
21085: PUSH
21086: LD_INT 3
21088: EQUAL
21089: IFFALSE 21099
// sEngine := true ;
21091: LD_ADDR_EXP 35
21095: PUSH
21096: LD_INT 1
21098: ST_TO_ADDR
// if p3 = 4 then
21099: LD_VAR 0 3
21103: PUSH
21104: LD_INT 4
21106: EQUAL
21107: IFFALSE 21117
// sSpec := true ;
21109: LD_ADDR_EXP 32
21113: PUSH
21114: LD_INT 1
21116: ST_TO_ADDR
// if p3 = 5 then
21117: LD_VAR 0 3
21121: PUSH
21122: LD_INT 5
21124: EQUAL
21125: IFFALSE 21135
// sLevel := true ;
21127: LD_ADDR_EXP 36
21131: PUSH
21132: LD_INT 1
21134: ST_TO_ADDR
// if p3 = 6 then
21135: LD_VAR 0 3
21139: PUSH
21140: LD_INT 6
21142: EQUAL
21143: IFFALSE 21153
// sArmoury := true ;
21145: LD_ADDR_EXP 37
21149: PUSH
21150: LD_INT 1
21152: ST_TO_ADDR
// if p3 = 7 then
21153: LD_VAR 0 3
21157: PUSH
21158: LD_INT 7
21160: EQUAL
21161: IFFALSE 21171
// sRadar := true ;
21163: LD_ADDR_EXP 38
21167: PUSH
21168: LD_INT 1
21170: ST_TO_ADDR
// if p3 = 8 then
21171: LD_VAR 0 3
21175: PUSH
21176: LD_INT 8
21178: EQUAL
21179: IFFALSE 21189
// sBunker := true ;
21181: LD_ADDR_EXP 39
21185: PUSH
21186: LD_INT 1
21188: ST_TO_ADDR
// if p3 = 9 then
21189: LD_VAR 0 3
21193: PUSH
21194: LD_INT 9
21196: EQUAL
21197: IFFALSE 21207
// sHack := true ;
21199: LD_ADDR_EXP 40
21203: PUSH
21204: LD_INT 1
21206: ST_TO_ADDR
// if p3 = 10 then
21207: LD_VAR 0 3
21211: PUSH
21212: LD_INT 10
21214: EQUAL
21215: IFFALSE 21225
// sFire := true ;
21217: LD_ADDR_EXP 41
21221: PUSH
21222: LD_INT 1
21224: ST_TO_ADDR
// if p3 = 11 then
21225: LD_VAR 0 3
21229: PUSH
21230: LD_INT 11
21232: EQUAL
21233: IFFALSE 21243
// sRefresh := true ;
21235: LD_ADDR_EXP 42
21239: PUSH
21240: LD_INT 1
21242: ST_TO_ADDR
// if p3 = 12 then
21243: LD_VAR 0 3
21247: PUSH
21248: LD_INT 12
21250: EQUAL
21251: IFFALSE 21261
// sExp := true ;
21253: LD_ADDR_EXP 43
21257: PUSH
21258: LD_INT 1
21260: ST_TO_ADDR
// if p3 = 13 then
21261: LD_VAR 0 3
21265: PUSH
21266: LD_INT 13
21268: EQUAL
21269: IFFALSE 21279
// sDepot := true ;
21271: LD_ADDR_EXP 44
21275: PUSH
21276: LD_INT 1
21278: ST_TO_ADDR
// if p3 = 14 then
21279: LD_VAR 0 3
21283: PUSH
21284: LD_INT 14
21286: EQUAL
21287: IFFALSE 21297
// sFlag := true ;
21289: LD_ADDR_EXP 45
21293: PUSH
21294: LD_INT 1
21296: ST_TO_ADDR
// if p3 = 15 then
21297: LD_VAR 0 3
21301: PUSH
21302: LD_INT 15
21304: EQUAL
21305: IFFALSE 21315
// sKamikadze := true ;
21307: LD_ADDR_EXP 53
21311: PUSH
21312: LD_INT 1
21314: ST_TO_ADDR
// if p3 = 16 then
21315: LD_VAR 0 3
21319: PUSH
21320: LD_INT 16
21322: EQUAL
21323: IFFALSE 21333
// sTroll := true ;
21325: LD_ADDR_EXP 54
21329: PUSH
21330: LD_INT 1
21332: ST_TO_ADDR
// if p3 = 17 then
21333: LD_VAR 0 3
21337: PUSH
21338: LD_INT 17
21340: EQUAL
21341: IFFALSE 21351
// sSlow := true ;
21343: LD_ADDR_EXP 55
21347: PUSH
21348: LD_INT 1
21350: ST_TO_ADDR
// if p3 = 18 then
21351: LD_VAR 0 3
21355: PUSH
21356: LD_INT 18
21358: EQUAL
21359: IFFALSE 21369
// sLack := true ;
21361: LD_ADDR_EXP 56
21365: PUSH
21366: LD_INT 1
21368: ST_TO_ADDR
// if p3 = 19 then
21369: LD_VAR 0 3
21373: PUSH
21374: LD_INT 19
21376: EQUAL
21377: IFFALSE 21387
// sTank := true ;
21379: LD_ADDR_EXP 58
21383: PUSH
21384: LD_INT 1
21386: ST_TO_ADDR
// if p3 = 20 then
21387: LD_VAR 0 3
21391: PUSH
21392: LD_INT 20
21394: EQUAL
21395: IFFALSE 21405
// sRemote := true ;
21397: LD_ADDR_EXP 59
21401: PUSH
21402: LD_INT 1
21404: ST_TO_ADDR
// if p3 = 21 then
21405: LD_VAR 0 3
21409: PUSH
21410: LD_INT 21
21412: EQUAL
21413: IFFALSE 21423
// sPowell := true ;
21415: LD_ADDR_EXP 60
21419: PUSH
21420: LD_INT 1
21422: ST_TO_ADDR
// if p3 = 22 then
21423: LD_VAR 0 3
21427: PUSH
21428: LD_INT 22
21430: EQUAL
21431: IFFALSE 21441
// sTeleport := true ;
21433: LD_ADDR_EXP 63
21437: PUSH
21438: LD_INT 1
21440: ST_TO_ADDR
// if p3 = 23 then
21441: LD_VAR 0 3
21445: PUSH
21446: LD_INT 23
21448: EQUAL
21449: IFFALSE 21459
// sOilTower := true ;
21451: LD_ADDR_EXP 65
21455: PUSH
21456: LD_INT 1
21458: ST_TO_ADDR
// if p3 = 24 then
21459: LD_VAR 0 3
21463: PUSH
21464: LD_INT 24
21466: EQUAL
21467: IFFALSE 21477
// sShovel := true ;
21469: LD_ADDR_EXP 66
21473: PUSH
21474: LD_INT 1
21476: ST_TO_ADDR
// if p3 = 25 then
21477: LD_VAR 0 3
21481: PUSH
21482: LD_INT 25
21484: EQUAL
21485: IFFALSE 21495
// sSheik := true ;
21487: LD_ADDR_EXP 67
21491: PUSH
21492: LD_INT 1
21494: ST_TO_ADDR
// if p3 = 26 then
21495: LD_VAR 0 3
21499: PUSH
21500: LD_INT 26
21502: EQUAL
21503: IFFALSE 21513
// sEarthquake := true ;
21505: LD_ADDR_EXP 69
21509: PUSH
21510: LD_INT 1
21512: ST_TO_ADDR
// if p3 = 27 then
21513: LD_VAR 0 3
21517: PUSH
21518: LD_INT 27
21520: EQUAL
21521: IFFALSE 21531
// sAI := true ;
21523: LD_ADDR_EXP 70
21527: PUSH
21528: LD_INT 1
21530: ST_TO_ADDR
// if p3 = 28 then
21531: LD_VAR 0 3
21535: PUSH
21536: LD_INT 28
21538: EQUAL
21539: IFFALSE 21549
// sCargo := true ;
21541: LD_ADDR_EXP 73
21545: PUSH
21546: LD_INT 1
21548: ST_TO_ADDR
// if p3 = 29 then
21549: LD_VAR 0 3
21553: PUSH
21554: LD_INT 29
21556: EQUAL
21557: IFFALSE 21567
// sDLaser := true ;
21559: LD_ADDR_EXP 74
21563: PUSH
21564: LD_INT 1
21566: ST_TO_ADDR
// if p3 = 30 then
21567: LD_VAR 0 3
21571: PUSH
21572: LD_INT 30
21574: EQUAL
21575: IFFALSE 21585
// sExchange := true ;
21577: LD_ADDR_EXP 75
21581: PUSH
21582: LD_INT 1
21584: ST_TO_ADDR
// if p3 = 31 then
21585: LD_VAR 0 3
21589: PUSH
21590: LD_INT 31
21592: EQUAL
21593: IFFALSE 21603
// sFac := true ;
21595: LD_ADDR_EXP 76
21599: PUSH
21600: LD_INT 1
21602: ST_TO_ADDR
// if p3 = 32 then
21603: LD_VAR 0 3
21607: PUSH
21608: LD_INT 32
21610: EQUAL
21611: IFFALSE 21621
// sPower := true ;
21613: LD_ADDR_EXP 77
21617: PUSH
21618: LD_INT 1
21620: ST_TO_ADDR
// if p3 = 33 then
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 33
21628: EQUAL
21629: IFFALSE 21639
// sRandom := true ;
21631: LD_ADDR_EXP 78
21635: PUSH
21636: LD_INT 1
21638: ST_TO_ADDR
// if p3 = 34 then
21639: LD_VAR 0 3
21643: PUSH
21644: LD_INT 34
21646: EQUAL
21647: IFFALSE 21657
// sShield := true ;
21649: LD_ADDR_EXP 79
21653: PUSH
21654: LD_INT 1
21656: ST_TO_ADDR
// if p3 = 35 then
21657: LD_VAR 0 3
21661: PUSH
21662: LD_INT 35
21664: EQUAL
21665: IFFALSE 21675
// sTime := true ;
21667: LD_ADDR_EXP 80
21671: PUSH
21672: LD_INT 1
21674: ST_TO_ADDR
// if p3 = 36 then
21675: LD_VAR 0 3
21679: PUSH
21680: LD_INT 36
21682: EQUAL
21683: IFFALSE 21693
// sTools := true ;
21685: LD_ADDR_EXP 81
21689: PUSH
21690: LD_INT 1
21692: ST_TO_ADDR
// if p3 = 101 then
21693: LD_VAR 0 3
21697: PUSH
21698: LD_INT 101
21700: EQUAL
21701: IFFALSE 21711
// sSold := true ;
21703: LD_ADDR_EXP 46
21707: PUSH
21708: LD_INT 1
21710: ST_TO_ADDR
// if p3 = 102 then
21711: LD_VAR 0 3
21715: PUSH
21716: LD_INT 102
21718: EQUAL
21719: IFFALSE 21729
// sDiff := true ;
21721: LD_ADDR_EXP 47
21725: PUSH
21726: LD_INT 1
21728: ST_TO_ADDR
// if p3 = 103 then
21729: LD_VAR 0 3
21733: PUSH
21734: LD_INT 103
21736: EQUAL
21737: IFFALSE 21747
// sFog := true ;
21739: LD_ADDR_EXP 50
21743: PUSH
21744: LD_INT 1
21746: ST_TO_ADDR
// if p3 = 104 then
21747: LD_VAR 0 3
21751: PUSH
21752: LD_INT 104
21754: EQUAL
21755: IFFALSE 21765
// sReset := true ;
21757: LD_ADDR_EXP 51
21761: PUSH
21762: LD_INT 1
21764: ST_TO_ADDR
// if p3 = 105 then
21765: LD_VAR 0 3
21769: PUSH
21770: LD_INT 105
21772: EQUAL
21773: IFFALSE 21783
// sSun := true ;
21775: LD_ADDR_EXP 52
21779: PUSH
21780: LD_INT 1
21782: ST_TO_ADDR
// if p3 = 106 then
21783: LD_VAR 0 3
21787: PUSH
21788: LD_INT 106
21790: EQUAL
21791: IFFALSE 21801
// sTiger := true ;
21793: LD_ADDR_EXP 48
21797: PUSH
21798: LD_INT 1
21800: ST_TO_ADDR
// if p3 = 107 then
21801: LD_VAR 0 3
21805: PUSH
21806: LD_INT 107
21808: EQUAL
21809: IFFALSE 21819
// sBomb := true ;
21811: LD_ADDR_EXP 49
21815: PUSH
21816: LD_INT 1
21818: ST_TO_ADDR
// if p3 = 108 then
21819: LD_VAR 0 3
21823: PUSH
21824: LD_INT 108
21826: EQUAL
21827: IFFALSE 21837
// sWound := true ;
21829: LD_ADDR_EXP 57
21833: PUSH
21834: LD_INT 1
21836: ST_TO_ADDR
// if p3 = 109 then
21837: LD_VAR 0 3
21841: PUSH
21842: LD_INT 109
21844: EQUAL
21845: IFFALSE 21855
// sBetray := true ;
21847: LD_ADDR_EXP 61
21851: PUSH
21852: LD_INT 1
21854: ST_TO_ADDR
// if p3 = 110 then
21855: LD_VAR 0 3
21859: PUSH
21860: LD_INT 110
21862: EQUAL
21863: IFFALSE 21873
// sContamin := true ;
21865: LD_ADDR_EXP 62
21869: PUSH
21870: LD_INT 1
21872: ST_TO_ADDR
// if p3 = 111 then
21873: LD_VAR 0 3
21877: PUSH
21878: LD_INT 111
21880: EQUAL
21881: IFFALSE 21891
// sOil := true ;
21883: LD_ADDR_EXP 64
21887: PUSH
21888: LD_INT 1
21890: ST_TO_ADDR
// if p3 = 112 then
21891: LD_VAR 0 3
21895: PUSH
21896: LD_INT 112
21898: EQUAL
21899: IFFALSE 21909
// sStu := true ;
21901: LD_ADDR_EXP 68
21905: PUSH
21906: LD_INT 1
21908: ST_TO_ADDR
// if p3 = 113 then
21909: LD_VAR 0 3
21913: PUSH
21914: LD_INT 113
21916: EQUAL
21917: IFFALSE 21927
// sBazooka := true ;
21919: LD_ADDR_EXP 71
21923: PUSH
21924: LD_INT 1
21926: ST_TO_ADDR
// if p3 = 114 then
21927: LD_VAR 0 3
21931: PUSH
21932: LD_INT 114
21934: EQUAL
21935: IFFALSE 21945
// sMortar := true ;
21937: LD_ADDR_EXP 72
21941: PUSH
21942: LD_INT 1
21944: ST_TO_ADDR
// if p3 = 115 then
21945: LD_VAR 0 3
21949: PUSH
21950: LD_INT 115
21952: EQUAL
21953: IFFALSE 21963
// sRanger := true ;
21955: LD_ADDR_EXP 82
21959: PUSH
21960: LD_INT 1
21962: ST_TO_ADDR
// if p3 = 116 then
21963: LD_VAR 0 3
21967: PUSH
21968: LD_INT 116
21970: EQUAL
21971: IFFALSE 21981
// sComputer := true ;
21973: LD_ADDR_EXP 83
21977: PUSH
21978: LD_INT 1
21980: ST_TO_ADDR
// if p3 = 117 then
21981: LD_VAR 0 3
21985: PUSH
21986: LD_INT 117
21988: EQUAL
21989: IFFALSE 21999
// s30 := true ;
21991: LD_ADDR_EXP 84
21995: PUSH
21996: LD_INT 1
21998: ST_TO_ADDR
// if p3 = 118 then
21999: LD_VAR 0 3
22003: PUSH
22004: LD_INT 118
22006: EQUAL
22007: IFFALSE 22017
// s60 := true ;
22009: LD_ADDR_EXP 85
22013: PUSH
22014: LD_INT 1
22016: ST_TO_ADDR
// end ; if p2 = hack_mode then
22017: LD_VAR 0 2
22021: PUSH
22022: LD_INT 101
22024: EQUAL
22025: IFFALSE 22153
// begin case p3 of 1 :
22027: LD_VAR 0 3
22031: PUSH
22032: LD_INT 1
22034: DOUBLE
22035: EQUAL
22036: IFTRUE 22040
22038: GO 22047
22040: POP
// hHackUnlimitedResources ; 2 :
22041: CALL 34324 0 0
22045: GO 22153
22047: LD_INT 2
22049: DOUBLE
22050: EQUAL
22051: IFTRUE 22055
22053: GO 22062
22055: POP
// hHackSetLevel10 ; 3 :
22056: CALL 34457 0 0
22060: GO 22153
22062: LD_INT 3
22064: DOUBLE
22065: EQUAL
22066: IFTRUE 22070
22068: GO 22077
22070: POP
// hHackSetLevel10YourUnits ; 4 :
22071: CALL 34542 0 0
22075: GO 22153
22077: LD_INT 4
22079: DOUBLE
22080: EQUAL
22081: IFTRUE 22085
22083: GO 22092
22085: POP
// hHackInvincible ; 5 :
22086: CALL 34990 0 0
22090: GO 22153
22092: LD_INT 5
22094: DOUBLE
22095: EQUAL
22096: IFTRUE 22100
22098: GO 22107
22100: POP
// hHackInvisible ; 6 :
22101: CALL 35101 0 0
22105: GO 22153
22107: LD_INT 6
22109: DOUBLE
22110: EQUAL
22111: IFTRUE 22115
22113: GO 22122
22115: POP
// hHackChangeYourSide ; 7 :
22116: CALL 35158 0 0
22120: GO 22153
22122: LD_INT 7
22124: DOUBLE
22125: EQUAL
22126: IFTRUE 22130
22128: GO 22137
22130: POP
// hHackChangeUnitSide ; 8 :
22131: CALL 35200 0 0
22135: GO 22153
22137: LD_INT 8
22139: DOUBLE
22140: EQUAL
22141: IFTRUE 22145
22143: GO 22152
22145: POP
// hHackFog ; end ;
22146: CALL 35301 0 0
22150: GO 22153
22152: POP
// end ; if p2 = game_save_mode then
22153: LD_VAR 0 2
22157: PUSH
22158: LD_INT 102
22160: EQUAL
22161: IFFALSE 22226
// begin if p3 = 1 then
22163: LD_VAR 0 3
22167: PUSH
22168: LD_INT 1
22170: EQUAL
22171: IFFALSE 22183
// globalGameSaveCounter := p4 ;
22173: LD_ADDR_EXP 28
22177: PUSH
22178: LD_VAR 0 4
22182: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: EQUAL
22191: PUSH
22192: LD_EXP 28
22196: AND
22197: IFFALSE 22216
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
22199: LD_STRING setGameSaveCounter(
22201: PUSH
22202: LD_EXP 28
22206: STR
22207: PUSH
22208: LD_STRING )
22210: STR
22211: PPUSH
22212: CALL_OW 559
// display_strings := globalGameSaveCounter ;
22216: LD_ADDR_OWVAR 47
22220: PUSH
22221: LD_EXP 28
22225: ST_TO_ADDR
// end ; end ;
22226: LD_VAR 0 7
22230: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
22231: GO 22233
22233: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
22234: LD_STRING initStreamRollete();
22236: PPUSH
22237: CALL_OW 559
// InitStreamMode ;
22241: CALL 22253 0 0
// DefineStreamItems ( false ) ;
22245: LD_INT 0
22247: PPUSH
22248: CALL 22717 0 1
// end ;
22252: END
// function InitStreamMode ; begin
22253: LD_INT 0
22255: PPUSH
// streamModeActive := false ;
22256: LD_ADDR_EXP 29
22260: PUSH
22261: LD_INT 0
22263: ST_TO_ADDR
// normalCounter := 36 ;
22264: LD_ADDR_EXP 30
22268: PUSH
22269: LD_INT 36
22271: ST_TO_ADDR
// hardcoreCounter := 18 ;
22272: LD_ADDR_EXP 31
22276: PUSH
22277: LD_INT 18
22279: ST_TO_ADDR
// sRocket := false ;
22280: LD_ADDR_EXP 34
22284: PUSH
22285: LD_INT 0
22287: ST_TO_ADDR
// sSpeed := false ;
22288: LD_ADDR_EXP 33
22292: PUSH
22293: LD_INT 0
22295: ST_TO_ADDR
// sEngine := false ;
22296: LD_ADDR_EXP 35
22300: PUSH
22301: LD_INT 0
22303: ST_TO_ADDR
// sSpec := false ;
22304: LD_ADDR_EXP 32
22308: PUSH
22309: LD_INT 0
22311: ST_TO_ADDR
// sLevel := false ;
22312: LD_ADDR_EXP 36
22316: PUSH
22317: LD_INT 0
22319: ST_TO_ADDR
// sArmoury := false ;
22320: LD_ADDR_EXP 37
22324: PUSH
22325: LD_INT 0
22327: ST_TO_ADDR
// sRadar := false ;
22328: LD_ADDR_EXP 38
22332: PUSH
22333: LD_INT 0
22335: ST_TO_ADDR
// sBunker := false ;
22336: LD_ADDR_EXP 39
22340: PUSH
22341: LD_INT 0
22343: ST_TO_ADDR
// sHack := false ;
22344: LD_ADDR_EXP 40
22348: PUSH
22349: LD_INT 0
22351: ST_TO_ADDR
// sFire := false ;
22352: LD_ADDR_EXP 41
22356: PUSH
22357: LD_INT 0
22359: ST_TO_ADDR
// sRefresh := false ;
22360: LD_ADDR_EXP 42
22364: PUSH
22365: LD_INT 0
22367: ST_TO_ADDR
// sExp := false ;
22368: LD_ADDR_EXP 43
22372: PUSH
22373: LD_INT 0
22375: ST_TO_ADDR
// sDepot := false ;
22376: LD_ADDR_EXP 44
22380: PUSH
22381: LD_INT 0
22383: ST_TO_ADDR
// sFlag := false ;
22384: LD_ADDR_EXP 45
22388: PUSH
22389: LD_INT 0
22391: ST_TO_ADDR
// sKamikadze := false ;
22392: LD_ADDR_EXP 53
22396: PUSH
22397: LD_INT 0
22399: ST_TO_ADDR
// sTroll := false ;
22400: LD_ADDR_EXP 54
22404: PUSH
22405: LD_INT 0
22407: ST_TO_ADDR
// sSlow := false ;
22408: LD_ADDR_EXP 55
22412: PUSH
22413: LD_INT 0
22415: ST_TO_ADDR
// sLack := false ;
22416: LD_ADDR_EXP 56
22420: PUSH
22421: LD_INT 0
22423: ST_TO_ADDR
// sTank := false ;
22424: LD_ADDR_EXP 58
22428: PUSH
22429: LD_INT 0
22431: ST_TO_ADDR
// sRemote := false ;
22432: LD_ADDR_EXP 59
22436: PUSH
22437: LD_INT 0
22439: ST_TO_ADDR
// sPowell := false ;
22440: LD_ADDR_EXP 60
22444: PUSH
22445: LD_INT 0
22447: ST_TO_ADDR
// sTeleport := false ;
22448: LD_ADDR_EXP 63
22452: PUSH
22453: LD_INT 0
22455: ST_TO_ADDR
// sOilTower := false ;
22456: LD_ADDR_EXP 65
22460: PUSH
22461: LD_INT 0
22463: ST_TO_ADDR
// sShovel := false ;
22464: LD_ADDR_EXP 66
22468: PUSH
22469: LD_INT 0
22471: ST_TO_ADDR
// sSheik := false ;
22472: LD_ADDR_EXP 67
22476: PUSH
22477: LD_INT 0
22479: ST_TO_ADDR
// sEarthquake := false ;
22480: LD_ADDR_EXP 69
22484: PUSH
22485: LD_INT 0
22487: ST_TO_ADDR
// sAI := false ;
22488: LD_ADDR_EXP 70
22492: PUSH
22493: LD_INT 0
22495: ST_TO_ADDR
// sCargo := false ;
22496: LD_ADDR_EXP 73
22500: PUSH
22501: LD_INT 0
22503: ST_TO_ADDR
// sDLaser := false ;
22504: LD_ADDR_EXP 74
22508: PUSH
22509: LD_INT 0
22511: ST_TO_ADDR
// sExchange := false ;
22512: LD_ADDR_EXP 75
22516: PUSH
22517: LD_INT 0
22519: ST_TO_ADDR
// sFac := false ;
22520: LD_ADDR_EXP 76
22524: PUSH
22525: LD_INT 0
22527: ST_TO_ADDR
// sPower := false ;
22528: LD_ADDR_EXP 77
22532: PUSH
22533: LD_INT 0
22535: ST_TO_ADDR
// sRandom := false ;
22536: LD_ADDR_EXP 78
22540: PUSH
22541: LD_INT 0
22543: ST_TO_ADDR
// sShield := false ;
22544: LD_ADDR_EXP 79
22548: PUSH
22549: LD_INT 0
22551: ST_TO_ADDR
// sTime := false ;
22552: LD_ADDR_EXP 80
22556: PUSH
22557: LD_INT 0
22559: ST_TO_ADDR
// sTools := false ;
22560: LD_ADDR_EXP 81
22564: PUSH
22565: LD_INT 0
22567: ST_TO_ADDR
// sSold := false ;
22568: LD_ADDR_EXP 46
22572: PUSH
22573: LD_INT 0
22575: ST_TO_ADDR
// sDiff := false ;
22576: LD_ADDR_EXP 47
22580: PUSH
22581: LD_INT 0
22583: ST_TO_ADDR
// sFog := false ;
22584: LD_ADDR_EXP 50
22588: PUSH
22589: LD_INT 0
22591: ST_TO_ADDR
// sReset := false ;
22592: LD_ADDR_EXP 51
22596: PUSH
22597: LD_INT 0
22599: ST_TO_ADDR
// sSun := false ;
22600: LD_ADDR_EXP 52
22604: PUSH
22605: LD_INT 0
22607: ST_TO_ADDR
// sTiger := false ;
22608: LD_ADDR_EXP 48
22612: PUSH
22613: LD_INT 0
22615: ST_TO_ADDR
// sBomb := false ;
22616: LD_ADDR_EXP 49
22620: PUSH
22621: LD_INT 0
22623: ST_TO_ADDR
// sWound := false ;
22624: LD_ADDR_EXP 57
22628: PUSH
22629: LD_INT 0
22631: ST_TO_ADDR
// sBetray := false ;
22632: LD_ADDR_EXP 61
22636: PUSH
22637: LD_INT 0
22639: ST_TO_ADDR
// sContamin := false ;
22640: LD_ADDR_EXP 62
22644: PUSH
22645: LD_INT 0
22647: ST_TO_ADDR
// sOil := false ;
22648: LD_ADDR_EXP 64
22652: PUSH
22653: LD_INT 0
22655: ST_TO_ADDR
// sStu := false ;
22656: LD_ADDR_EXP 68
22660: PUSH
22661: LD_INT 0
22663: ST_TO_ADDR
// sBazooka := false ;
22664: LD_ADDR_EXP 71
22668: PUSH
22669: LD_INT 0
22671: ST_TO_ADDR
// sMortar := false ;
22672: LD_ADDR_EXP 72
22676: PUSH
22677: LD_INT 0
22679: ST_TO_ADDR
// sRanger := false ;
22680: LD_ADDR_EXP 82
22684: PUSH
22685: LD_INT 0
22687: ST_TO_ADDR
// sComputer := false ;
22688: LD_ADDR_EXP 83
22692: PUSH
22693: LD_INT 0
22695: ST_TO_ADDR
// s30 := false ;
22696: LD_ADDR_EXP 84
22700: PUSH
22701: LD_INT 0
22703: ST_TO_ADDR
// s60 := false ;
22704: LD_ADDR_EXP 85
22708: PUSH
22709: LD_INT 0
22711: ST_TO_ADDR
// end ;
22712: LD_VAR 0 1
22716: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
22717: LD_INT 0
22719: PPUSH
22720: PPUSH
22721: PPUSH
22722: PPUSH
22723: PPUSH
22724: PPUSH
22725: PPUSH
// result := [ ] ;
22726: LD_ADDR_VAR 0 2
22730: PUSH
22731: EMPTY
22732: ST_TO_ADDR
// if campaign_id = 1 then
22733: LD_OWVAR 69
22737: PUSH
22738: LD_INT 1
22740: EQUAL
22741: IFFALSE 25907
// begin case mission_number of 1 :
22743: LD_OWVAR 70
22747: PUSH
22748: LD_INT 1
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22832
22756: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
22757: LD_ADDR_VAR 0 2
22761: PUSH
22762: LD_INT 2
22764: PUSH
22765: LD_INT 4
22767: PUSH
22768: LD_INT 11
22770: PUSH
22771: LD_INT 12
22773: PUSH
22774: LD_INT 15
22776: PUSH
22777: LD_INT 16
22779: PUSH
22780: LD_INT 22
22782: PUSH
22783: LD_INT 23
22785: PUSH
22786: LD_INT 26
22788: PUSH
22789: EMPTY
22790: LIST
22791: LIST
22792: LIST
22793: LIST
22794: LIST
22795: LIST
22796: LIST
22797: LIST
22798: LIST
22799: PUSH
22800: LD_INT 101
22802: PUSH
22803: LD_INT 102
22805: PUSH
22806: LD_INT 106
22808: PUSH
22809: LD_INT 116
22811: PUSH
22812: LD_INT 117
22814: PUSH
22815: LD_INT 118
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: ST_TO_ADDR
22830: GO 25905
22832: LD_INT 2
22834: DOUBLE
22835: EQUAL
22836: IFTRUE 22840
22838: GO 22924
22840: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
22841: LD_ADDR_VAR 0 2
22845: PUSH
22846: LD_INT 2
22848: PUSH
22849: LD_INT 4
22851: PUSH
22852: LD_INT 11
22854: PUSH
22855: LD_INT 12
22857: PUSH
22858: LD_INT 15
22860: PUSH
22861: LD_INT 16
22863: PUSH
22864: LD_INT 22
22866: PUSH
22867: LD_INT 23
22869: PUSH
22870: LD_INT 26
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: LIST
22882: LIST
22883: PUSH
22884: LD_INT 101
22886: PUSH
22887: LD_INT 102
22889: PUSH
22890: LD_INT 105
22892: PUSH
22893: LD_INT 106
22895: PUSH
22896: LD_INT 108
22898: PUSH
22899: LD_INT 116
22901: PUSH
22902: LD_INT 117
22904: PUSH
22905: LD_INT 118
22907: PUSH
22908: EMPTY
22909: LIST
22910: LIST
22911: LIST
22912: LIST
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: PUSH
22918: EMPTY
22919: LIST
22920: LIST
22921: ST_TO_ADDR
22922: GO 25905
22924: LD_INT 3
22926: DOUBLE
22927: EQUAL
22928: IFTRUE 22932
22930: GO 23020
22932: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
22933: LD_ADDR_VAR 0 2
22937: PUSH
22938: LD_INT 2
22940: PUSH
22941: LD_INT 4
22943: PUSH
22944: LD_INT 5
22946: PUSH
22947: LD_INT 11
22949: PUSH
22950: LD_INT 12
22952: PUSH
22953: LD_INT 15
22955: PUSH
22956: LD_INT 16
22958: PUSH
22959: LD_INT 22
22961: PUSH
22962: LD_INT 26
22964: PUSH
22965: LD_INT 36
22967: PUSH
22968: EMPTY
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: LIST
22974: LIST
22975: LIST
22976: LIST
22977: LIST
22978: LIST
22979: PUSH
22980: LD_INT 101
22982: PUSH
22983: LD_INT 102
22985: PUSH
22986: LD_INT 105
22988: PUSH
22989: LD_INT 106
22991: PUSH
22992: LD_INT 108
22994: PUSH
22995: LD_INT 116
22997: PUSH
22998: LD_INT 117
23000: PUSH
23001: LD_INT 118
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: LIST
23008: LIST
23009: LIST
23010: LIST
23011: LIST
23012: LIST
23013: PUSH
23014: EMPTY
23015: LIST
23016: LIST
23017: ST_TO_ADDR
23018: GO 25905
23020: LD_INT 4
23022: DOUBLE
23023: EQUAL
23024: IFTRUE 23028
23026: GO 23124
23028: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
23029: LD_ADDR_VAR 0 2
23033: PUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 4
23039: PUSH
23040: LD_INT 5
23042: PUSH
23043: LD_INT 8
23045: PUSH
23046: LD_INT 11
23048: PUSH
23049: LD_INT 12
23051: PUSH
23052: LD_INT 15
23054: PUSH
23055: LD_INT 16
23057: PUSH
23058: LD_INT 22
23060: PUSH
23061: LD_INT 23
23063: PUSH
23064: LD_INT 26
23066: PUSH
23067: LD_INT 36
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: LIST
23079: LIST
23080: LIST
23081: LIST
23082: LIST
23083: PUSH
23084: LD_INT 101
23086: PUSH
23087: LD_INT 102
23089: PUSH
23090: LD_INT 105
23092: PUSH
23093: LD_INT 106
23095: PUSH
23096: LD_INT 108
23098: PUSH
23099: LD_INT 116
23101: PUSH
23102: LD_INT 117
23104: PUSH
23105: LD_INT 118
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: LIST
23115: LIST
23116: LIST
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 25905
23124: LD_INT 5
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23244
23132: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
23133: LD_ADDR_VAR 0 2
23137: PUSH
23138: LD_INT 2
23140: PUSH
23141: LD_INT 4
23143: PUSH
23144: LD_INT 5
23146: PUSH
23147: LD_INT 6
23149: PUSH
23150: LD_INT 8
23152: PUSH
23153: LD_INT 11
23155: PUSH
23156: LD_INT 12
23158: PUSH
23159: LD_INT 15
23161: PUSH
23162: LD_INT 16
23164: PUSH
23165: LD_INT 22
23167: PUSH
23168: LD_INT 23
23170: PUSH
23171: LD_INT 25
23173: PUSH
23174: LD_INT 26
23176: PUSH
23177: LD_INT 36
23179: PUSH
23180: EMPTY
23181: LIST
23182: LIST
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 101
23198: PUSH
23199: LD_INT 102
23201: PUSH
23202: LD_INT 105
23204: PUSH
23205: LD_INT 106
23207: PUSH
23208: LD_INT 108
23210: PUSH
23211: LD_INT 109
23213: PUSH
23214: LD_INT 112
23216: PUSH
23217: LD_INT 116
23219: PUSH
23220: LD_INT 117
23222: PUSH
23223: LD_INT 118
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: LIST
23235: LIST
23236: LIST
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: ST_TO_ADDR
23242: GO 25905
23244: LD_INT 6
23246: DOUBLE
23247: EQUAL
23248: IFTRUE 23252
23250: GO 23384
23252: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
23253: LD_ADDR_VAR 0 2
23257: PUSH
23258: LD_INT 2
23260: PUSH
23261: LD_INT 4
23263: PUSH
23264: LD_INT 5
23266: PUSH
23267: LD_INT 6
23269: PUSH
23270: LD_INT 8
23272: PUSH
23273: LD_INT 11
23275: PUSH
23276: LD_INT 12
23278: PUSH
23279: LD_INT 15
23281: PUSH
23282: LD_INT 16
23284: PUSH
23285: LD_INT 20
23287: PUSH
23288: LD_INT 21
23290: PUSH
23291: LD_INT 22
23293: PUSH
23294: LD_INT 23
23296: PUSH
23297: LD_INT 25
23299: PUSH
23300: LD_INT 26
23302: PUSH
23303: LD_INT 30
23305: PUSH
23306: LD_INT 31
23308: PUSH
23309: LD_INT 32
23311: PUSH
23312: LD_INT 36
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: PUSH
23336: LD_INT 101
23338: PUSH
23339: LD_INT 102
23341: PUSH
23342: LD_INT 105
23344: PUSH
23345: LD_INT 106
23347: PUSH
23348: LD_INT 108
23350: PUSH
23351: LD_INT 109
23353: PUSH
23354: LD_INT 112
23356: PUSH
23357: LD_INT 116
23359: PUSH
23360: LD_INT 117
23362: PUSH
23363: LD_INT 118
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: LIST
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: ST_TO_ADDR
23382: GO 25905
23384: LD_INT 7
23386: DOUBLE
23387: EQUAL
23388: IFTRUE 23392
23390: GO 23504
23392: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
23393: LD_ADDR_VAR 0 2
23397: PUSH
23398: LD_INT 2
23400: PUSH
23401: LD_INT 4
23403: PUSH
23404: LD_INT 5
23406: PUSH
23407: LD_INT 7
23409: PUSH
23410: LD_INT 11
23412: PUSH
23413: LD_INT 12
23415: PUSH
23416: LD_INT 15
23418: PUSH
23419: LD_INT 16
23421: PUSH
23422: LD_INT 20
23424: PUSH
23425: LD_INT 21
23427: PUSH
23428: LD_INT 22
23430: PUSH
23431: LD_INT 23
23433: PUSH
23434: LD_INT 25
23436: PUSH
23437: LD_INT 26
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: LIST
23455: PUSH
23456: LD_INT 101
23458: PUSH
23459: LD_INT 102
23461: PUSH
23462: LD_INT 103
23464: PUSH
23465: LD_INT 105
23467: PUSH
23468: LD_INT 106
23470: PUSH
23471: LD_INT 108
23473: PUSH
23474: LD_INT 112
23476: PUSH
23477: LD_INT 116
23479: PUSH
23480: LD_INT 117
23482: PUSH
23483: LD_INT 118
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: LIST
23494: LIST
23495: LIST
23496: LIST
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: ST_TO_ADDR
23502: GO 25905
23504: LD_INT 8
23506: DOUBLE
23507: EQUAL
23508: IFTRUE 23512
23510: GO 23652
23512: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
23513: LD_ADDR_VAR 0 2
23517: PUSH
23518: LD_INT 2
23520: PUSH
23521: LD_INT 4
23523: PUSH
23524: LD_INT 5
23526: PUSH
23527: LD_INT 6
23529: PUSH
23530: LD_INT 7
23532: PUSH
23533: LD_INT 8
23535: PUSH
23536: LD_INT 11
23538: PUSH
23539: LD_INT 12
23541: PUSH
23542: LD_INT 15
23544: PUSH
23545: LD_INT 16
23547: PUSH
23548: LD_INT 20
23550: PUSH
23551: LD_INT 21
23553: PUSH
23554: LD_INT 22
23556: PUSH
23557: LD_INT 23
23559: PUSH
23560: LD_INT 25
23562: PUSH
23563: LD_INT 26
23565: PUSH
23566: LD_INT 30
23568: PUSH
23569: LD_INT 31
23571: PUSH
23572: LD_INT 32
23574: PUSH
23575: LD_INT 36
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: LIST
23593: LIST
23594: LIST
23595: LIST
23596: LIST
23597: LIST
23598: LIST
23599: PUSH
23600: LD_INT 101
23602: PUSH
23603: LD_INT 102
23605: PUSH
23606: LD_INT 103
23608: PUSH
23609: LD_INT 105
23611: PUSH
23612: LD_INT 106
23614: PUSH
23615: LD_INT 108
23617: PUSH
23618: LD_INT 109
23620: PUSH
23621: LD_INT 112
23623: PUSH
23624: LD_INT 116
23626: PUSH
23627: LD_INT 117
23629: PUSH
23630: LD_INT 118
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: ST_TO_ADDR
23650: GO 25905
23652: LD_INT 9
23654: DOUBLE
23655: EQUAL
23656: IFTRUE 23660
23658: GO 23808
23660: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
23661: LD_ADDR_VAR 0 2
23665: PUSH
23666: LD_INT 2
23668: PUSH
23669: LD_INT 4
23671: PUSH
23672: LD_INT 5
23674: PUSH
23675: LD_INT 6
23677: PUSH
23678: LD_INT 7
23680: PUSH
23681: LD_INT 8
23683: PUSH
23684: LD_INT 11
23686: PUSH
23687: LD_INT 12
23689: PUSH
23690: LD_INT 15
23692: PUSH
23693: LD_INT 16
23695: PUSH
23696: LD_INT 20
23698: PUSH
23699: LD_INT 21
23701: PUSH
23702: LD_INT 22
23704: PUSH
23705: LD_INT 23
23707: PUSH
23708: LD_INT 25
23710: PUSH
23711: LD_INT 26
23713: PUSH
23714: LD_INT 28
23716: PUSH
23717: LD_INT 30
23719: PUSH
23720: LD_INT 31
23722: PUSH
23723: LD_INT 32
23725: PUSH
23726: LD_INT 36
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: LIST
23744: LIST
23745: LIST
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: PUSH
23752: LD_INT 101
23754: PUSH
23755: LD_INT 102
23757: PUSH
23758: LD_INT 103
23760: PUSH
23761: LD_INT 105
23763: PUSH
23764: LD_INT 106
23766: PUSH
23767: LD_INT 108
23769: PUSH
23770: LD_INT 109
23772: PUSH
23773: LD_INT 112
23775: PUSH
23776: LD_INT 114
23778: PUSH
23779: LD_INT 116
23781: PUSH
23782: LD_INT 117
23784: PUSH
23785: LD_INT 118
23787: PUSH
23788: EMPTY
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: LIST
23798: LIST
23799: LIST
23800: LIST
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: ST_TO_ADDR
23806: GO 25905
23808: LD_INT 10
23810: DOUBLE
23811: EQUAL
23812: IFTRUE 23816
23814: GO 24012
23816: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
23817: LD_ADDR_VAR 0 2
23821: PUSH
23822: LD_INT 2
23824: PUSH
23825: LD_INT 4
23827: PUSH
23828: LD_INT 5
23830: PUSH
23831: LD_INT 6
23833: PUSH
23834: LD_INT 7
23836: PUSH
23837: LD_INT 8
23839: PUSH
23840: LD_INT 9
23842: PUSH
23843: LD_INT 10
23845: PUSH
23846: LD_INT 11
23848: PUSH
23849: LD_INT 12
23851: PUSH
23852: LD_INT 13
23854: PUSH
23855: LD_INT 14
23857: PUSH
23858: LD_INT 15
23860: PUSH
23861: LD_INT 16
23863: PUSH
23864: LD_INT 17
23866: PUSH
23867: LD_INT 18
23869: PUSH
23870: LD_INT 19
23872: PUSH
23873: LD_INT 20
23875: PUSH
23876: LD_INT 21
23878: PUSH
23879: LD_INT 22
23881: PUSH
23882: LD_INT 23
23884: PUSH
23885: LD_INT 24
23887: PUSH
23888: LD_INT 25
23890: PUSH
23891: LD_INT 26
23893: PUSH
23894: LD_INT 28
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 31
23902: PUSH
23903: LD_INT 32
23905: PUSH
23906: LD_INT 36
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: PUSH
23940: LD_INT 101
23942: PUSH
23943: LD_INT 102
23945: PUSH
23946: LD_INT 103
23948: PUSH
23949: LD_INT 104
23951: PUSH
23952: LD_INT 105
23954: PUSH
23955: LD_INT 106
23957: PUSH
23958: LD_INT 107
23960: PUSH
23961: LD_INT 108
23963: PUSH
23964: LD_INT 109
23966: PUSH
23967: LD_INT 110
23969: PUSH
23970: LD_INT 111
23972: PUSH
23973: LD_INT 112
23975: PUSH
23976: LD_INT 114
23978: PUSH
23979: LD_INT 116
23981: PUSH
23982: LD_INT 117
23984: PUSH
23985: LD_INT 118
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: LIST
23995: LIST
23996: LIST
23997: LIST
23998: LIST
23999: LIST
24000: LIST
24001: LIST
24002: LIST
24003: LIST
24004: LIST
24005: PUSH
24006: EMPTY
24007: LIST
24008: LIST
24009: ST_TO_ADDR
24010: GO 25905
24012: LD_INT 11
24014: DOUBLE
24015: EQUAL
24016: IFTRUE 24020
24018: GO 24224
24020: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
24021: LD_ADDR_VAR 0 2
24025: PUSH
24026: LD_INT 2
24028: PUSH
24029: LD_INT 3
24031: PUSH
24032: LD_INT 4
24034: PUSH
24035: LD_INT 5
24037: PUSH
24038: LD_INT 6
24040: PUSH
24041: LD_INT 7
24043: PUSH
24044: LD_INT 8
24046: PUSH
24047: LD_INT 9
24049: PUSH
24050: LD_INT 10
24052: PUSH
24053: LD_INT 11
24055: PUSH
24056: LD_INT 12
24058: PUSH
24059: LD_INT 13
24061: PUSH
24062: LD_INT 14
24064: PUSH
24065: LD_INT 15
24067: PUSH
24068: LD_INT 16
24070: PUSH
24071: LD_INT 17
24073: PUSH
24074: LD_INT 18
24076: PUSH
24077: LD_INT 19
24079: PUSH
24080: LD_INT 20
24082: PUSH
24083: LD_INT 21
24085: PUSH
24086: LD_INT 22
24088: PUSH
24089: LD_INT 23
24091: PUSH
24092: LD_INT 24
24094: PUSH
24095: LD_INT 25
24097: PUSH
24098: LD_INT 26
24100: PUSH
24101: LD_INT 28
24103: PUSH
24104: LD_INT 30
24106: PUSH
24107: LD_INT 31
24109: PUSH
24110: LD_INT 32
24112: PUSH
24113: LD_INT 34
24115: PUSH
24116: LD_INT 36
24118: PUSH
24119: EMPTY
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: LIST
24146: LIST
24147: LIST
24148: LIST
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 101
24154: PUSH
24155: LD_INT 102
24157: PUSH
24158: LD_INT 103
24160: PUSH
24161: LD_INT 104
24163: PUSH
24164: LD_INT 105
24166: PUSH
24167: LD_INT 106
24169: PUSH
24170: LD_INT 107
24172: PUSH
24173: LD_INT 108
24175: PUSH
24176: LD_INT 109
24178: PUSH
24179: LD_INT 110
24181: PUSH
24182: LD_INT 111
24184: PUSH
24185: LD_INT 112
24187: PUSH
24188: LD_INT 114
24190: PUSH
24191: LD_INT 116
24193: PUSH
24194: LD_INT 117
24196: PUSH
24197: LD_INT 118
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: PUSH
24218: EMPTY
24219: LIST
24220: LIST
24221: ST_TO_ADDR
24222: GO 25905
24224: LD_INT 12
24226: DOUBLE
24227: EQUAL
24228: IFTRUE 24232
24230: GO 24452
24232: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
24233: LD_ADDR_VAR 0 2
24237: PUSH
24238: LD_INT 1
24240: PUSH
24241: LD_INT 2
24243: PUSH
24244: LD_INT 3
24246: PUSH
24247: LD_INT 4
24249: PUSH
24250: LD_INT 5
24252: PUSH
24253: LD_INT 6
24255: PUSH
24256: LD_INT 7
24258: PUSH
24259: LD_INT 8
24261: PUSH
24262: LD_INT 9
24264: PUSH
24265: LD_INT 10
24267: PUSH
24268: LD_INT 11
24270: PUSH
24271: LD_INT 12
24273: PUSH
24274: LD_INT 13
24276: PUSH
24277: LD_INT 14
24279: PUSH
24280: LD_INT 15
24282: PUSH
24283: LD_INT 16
24285: PUSH
24286: LD_INT 17
24288: PUSH
24289: LD_INT 18
24291: PUSH
24292: LD_INT 19
24294: PUSH
24295: LD_INT 20
24297: PUSH
24298: LD_INT 21
24300: PUSH
24301: LD_INT 22
24303: PUSH
24304: LD_INT 23
24306: PUSH
24307: LD_INT 24
24309: PUSH
24310: LD_INT 25
24312: PUSH
24313: LD_INT 26
24315: PUSH
24316: LD_INT 27
24318: PUSH
24319: LD_INT 28
24321: PUSH
24322: LD_INT 30
24324: PUSH
24325: LD_INT 31
24327: PUSH
24328: LD_INT 32
24330: PUSH
24331: LD_INT 33
24333: PUSH
24334: LD_INT 34
24336: PUSH
24337: LD_INT 36
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: LIST
24371: LIST
24372: LIST
24373: LIST
24374: LIST
24375: PUSH
24376: LD_INT 101
24378: PUSH
24379: LD_INT 102
24381: PUSH
24382: LD_INT 103
24384: PUSH
24385: LD_INT 104
24387: PUSH
24388: LD_INT 105
24390: PUSH
24391: LD_INT 106
24393: PUSH
24394: LD_INT 107
24396: PUSH
24397: LD_INT 108
24399: PUSH
24400: LD_INT 109
24402: PUSH
24403: LD_INT 110
24405: PUSH
24406: LD_INT 111
24408: PUSH
24409: LD_INT 112
24411: PUSH
24412: LD_INT 113
24414: PUSH
24415: LD_INT 114
24417: PUSH
24418: LD_INT 116
24420: PUSH
24421: LD_INT 117
24423: PUSH
24424: LD_INT 118
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: LIST
24442: LIST
24443: LIST
24444: LIST
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: ST_TO_ADDR
24450: GO 25905
24452: LD_INT 13
24454: DOUBLE
24455: EQUAL
24456: IFTRUE 24460
24458: GO 24668
24460: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
24461: LD_ADDR_VAR 0 2
24465: PUSH
24466: LD_INT 1
24468: PUSH
24469: LD_INT 2
24471: PUSH
24472: LD_INT 3
24474: PUSH
24475: LD_INT 4
24477: PUSH
24478: LD_INT 5
24480: PUSH
24481: LD_INT 8
24483: PUSH
24484: LD_INT 9
24486: PUSH
24487: LD_INT 10
24489: PUSH
24490: LD_INT 11
24492: PUSH
24493: LD_INT 12
24495: PUSH
24496: LD_INT 14
24498: PUSH
24499: LD_INT 15
24501: PUSH
24502: LD_INT 16
24504: PUSH
24505: LD_INT 17
24507: PUSH
24508: LD_INT 18
24510: PUSH
24511: LD_INT 19
24513: PUSH
24514: LD_INT 20
24516: PUSH
24517: LD_INT 21
24519: PUSH
24520: LD_INT 22
24522: PUSH
24523: LD_INT 23
24525: PUSH
24526: LD_INT 24
24528: PUSH
24529: LD_INT 25
24531: PUSH
24532: LD_INT 26
24534: PUSH
24535: LD_INT 27
24537: PUSH
24538: LD_INT 28
24540: PUSH
24541: LD_INT 30
24543: PUSH
24544: LD_INT 31
24546: PUSH
24547: LD_INT 32
24549: PUSH
24550: LD_INT 33
24552: PUSH
24553: LD_INT 34
24555: PUSH
24556: LD_INT 36
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: LIST
24575: LIST
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: LIST
24590: LIST
24591: PUSH
24592: LD_INT 101
24594: PUSH
24595: LD_INT 102
24597: PUSH
24598: LD_INT 103
24600: PUSH
24601: LD_INT 104
24603: PUSH
24604: LD_INT 105
24606: PUSH
24607: LD_INT 106
24609: PUSH
24610: LD_INT 107
24612: PUSH
24613: LD_INT 108
24615: PUSH
24616: LD_INT 109
24618: PUSH
24619: LD_INT 110
24621: PUSH
24622: LD_INT 111
24624: PUSH
24625: LD_INT 112
24627: PUSH
24628: LD_INT 113
24630: PUSH
24631: LD_INT 114
24633: PUSH
24634: LD_INT 116
24636: PUSH
24637: LD_INT 117
24639: PUSH
24640: LD_INT 118
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: ST_TO_ADDR
24666: GO 25905
24668: LD_INT 14
24670: DOUBLE
24671: EQUAL
24672: IFTRUE 24676
24674: GO 24900
24676: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
24677: LD_ADDR_VAR 0 2
24681: PUSH
24682: LD_INT 1
24684: PUSH
24685: LD_INT 2
24687: PUSH
24688: LD_INT 3
24690: PUSH
24691: LD_INT 4
24693: PUSH
24694: LD_INT 5
24696: PUSH
24697: LD_INT 6
24699: PUSH
24700: LD_INT 7
24702: PUSH
24703: LD_INT 8
24705: PUSH
24706: LD_INT 9
24708: PUSH
24709: LD_INT 10
24711: PUSH
24712: LD_INT 11
24714: PUSH
24715: LD_INT 12
24717: PUSH
24718: LD_INT 13
24720: PUSH
24721: LD_INT 14
24723: PUSH
24724: LD_INT 15
24726: PUSH
24727: LD_INT 16
24729: PUSH
24730: LD_INT 17
24732: PUSH
24733: LD_INT 18
24735: PUSH
24736: LD_INT 19
24738: PUSH
24739: LD_INT 20
24741: PUSH
24742: LD_INT 21
24744: PUSH
24745: LD_INT 22
24747: PUSH
24748: LD_INT 23
24750: PUSH
24751: LD_INT 24
24753: PUSH
24754: LD_INT 25
24756: PUSH
24757: LD_INT 26
24759: PUSH
24760: LD_INT 27
24762: PUSH
24763: LD_INT 28
24765: PUSH
24766: LD_INT 29
24768: PUSH
24769: LD_INT 30
24771: PUSH
24772: LD_INT 31
24774: PUSH
24775: LD_INT 32
24777: PUSH
24778: LD_INT 33
24780: PUSH
24781: LD_INT 34
24783: PUSH
24784: LD_INT 36
24786: PUSH
24787: EMPTY
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: LIST
24800: LIST
24801: LIST
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: LIST
24811: LIST
24812: LIST
24813: LIST
24814: LIST
24815: LIST
24816: LIST
24817: LIST
24818: LIST
24819: LIST
24820: LIST
24821: LIST
24822: LIST
24823: PUSH
24824: LD_INT 101
24826: PUSH
24827: LD_INT 102
24829: PUSH
24830: LD_INT 103
24832: PUSH
24833: LD_INT 104
24835: PUSH
24836: LD_INT 105
24838: PUSH
24839: LD_INT 106
24841: PUSH
24842: LD_INT 107
24844: PUSH
24845: LD_INT 108
24847: PUSH
24848: LD_INT 109
24850: PUSH
24851: LD_INT 110
24853: PUSH
24854: LD_INT 111
24856: PUSH
24857: LD_INT 112
24859: PUSH
24860: LD_INT 113
24862: PUSH
24863: LD_INT 114
24865: PUSH
24866: LD_INT 116
24868: PUSH
24869: LD_INT 117
24871: PUSH
24872: LD_INT 118
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: LIST
24885: LIST
24886: LIST
24887: LIST
24888: LIST
24889: LIST
24890: LIST
24891: LIST
24892: LIST
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: ST_TO_ADDR
24898: GO 25905
24900: LD_INT 15
24902: DOUBLE
24903: EQUAL
24904: IFTRUE 24908
24906: GO 25132
24908: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
24909: LD_ADDR_VAR 0 2
24913: PUSH
24914: LD_INT 1
24916: PUSH
24917: LD_INT 2
24919: PUSH
24920: LD_INT 3
24922: PUSH
24923: LD_INT 4
24925: PUSH
24926: LD_INT 5
24928: PUSH
24929: LD_INT 6
24931: PUSH
24932: LD_INT 7
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: LD_INT 9
24940: PUSH
24941: LD_INT 10
24943: PUSH
24944: LD_INT 11
24946: PUSH
24947: LD_INT 12
24949: PUSH
24950: LD_INT 13
24952: PUSH
24953: LD_INT 14
24955: PUSH
24956: LD_INT 15
24958: PUSH
24959: LD_INT 16
24961: PUSH
24962: LD_INT 17
24964: PUSH
24965: LD_INT 18
24967: PUSH
24968: LD_INT 19
24970: PUSH
24971: LD_INT 20
24973: PUSH
24974: LD_INT 21
24976: PUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 23
24982: PUSH
24983: LD_INT 24
24985: PUSH
24986: LD_INT 25
24988: PUSH
24989: LD_INT 26
24991: PUSH
24992: LD_INT 27
24994: PUSH
24995: LD_INT 28
24997: PUSH
24998: LD_INT 29
25000: PUSH
25001: LD_INT 30
25003: PUSH
25004: LD_INT 31
25006: PUSH
25007: LD_INT 32
25009: PUSH
25010: LD_INT 33
25012: PUSH
25013: LD_INT 34
25015: PUSH
25016: LD_INT 36
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: LIST
25023: LIST
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: LIST
25029: LIST
25030: LIST
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: LIST
25041: LIST
25042: LIST
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 101
25058: PUSH
25059: LD_INT 102
25061: PUSH
25062: LD_INT 103
25064: PUSH
25065: LD_INT 104
25067: PUSH
25068: LD_INT 105
25070: PUSH
25071: LD_INT 106
25073: PUSH
25074: LD_INT 107
25076: PUSH
25077: LD_INT 108
25079: PUSH
25080: LD_INT 109
25082: PUSH
25083: LD_INT 110
25085: PUSH
25086: LD_INT 111
25088: PUSH
25089: LD_INT 112
25091: PUSH
25092: LD_INT 113
25094: PUSH
25095: LD_INT 114
25097: PUSH
25098: LD_INT 116
25100: PUSH
25101: LD_INT 117
25103: PUSH
25104: LD_INT 118
25106: PUSH
25107: EMPTY
25108: LIST
25109: LIST
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: LIST
25115: LIST
25116: LIST
25117: LIST
25118: LIST
25119: LIST
25120: LIST
25121: LIST
25122: LIST
25123: LIST
25124: LIST
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: ST_TO_ADDR
25130: GO 25905
25132: LD_INT 16
25134: DOUBLE
25135: EQUAL
25136: IFTRUE 25140
25138: GO 25276
25140: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
25141: LD_ADDR_VAR 0 2
25145: PUSH
25146: LD_INT 2
25148: PUSH
25149: LD_INT 4
25151: PUSH
25152: LD_INT 5
25154: PUSH
25155: LD_INT 7
25157: PUSH
25158: LD_INT 11
25160: PUSH
25161: LD_INT 12
25163: PUSH
25164: LD_INT 15
25166: PUSH
25167: LD_INT 16
25169: PUSH
25170: LD_INT 20
25172: PUSH
25173: LD_INT 21
25175: PUSH
25176: LD_INT 22
25178: PUSH
25179: LD_INT 23
25181: PUSH
25182: LD_INT 25
25184: PUSH
25185: LD_INT 26
25187: PUSH
25188: LD_INT 30
25190: PUSH
25191: LD_INT 31
25193: PUSH
25194: LD_INT 32
25196: PUSH
25197: LD_INT 33
25199: PUSH
25200: LD_INT 34
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: PUSH
25224: LD_INT 101
25226: PUSH
25227: LD_INT 102
25229: PUSH
25230: LD_INT 103
25232: PUSH
25233: LD_INT 106
25235: PUSH
25236: LD_INT 108
25238: PUSH
25239: LD_INT 112
25241: PUSH
25242: LD_INT 113
25244: PUSH
25245: LD_INT 114
25247: PUSH
25248: LD_INT 116
25250: PUSH
25251: LD_INT 117
25253: PUSH
25254: LD_INT 118
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: ST_TO_ADDR
25274: GO 25905
25276: LD_INT 17
25278: DOUBLE
25279: EQUAL
25280: IFTRUE 25284
25282: GO 25508
25284: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
25285: LD_ADDR_VAR 0 2
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: LD_INT 2
25295: PUSH
25296: LD_INT 3
25298: PUSH
25299: LD_INT 4
25301: PUSH
25302: LD_INT 5
25304: PUSH
25305: LD_INT 6
25307: PUSH
25308: LD_INT 7
25310: PUSH
25311: LD_INT 8
25313: PUSH
25314: LD_INT 9
25316: PUSH
25317: LD_INT 10
25319: PUSH
25320: LD_INT 11
25322: PUSH
25323: LD_INT 12
25325: PUSH
25326: LD_INT 13
25328: PUSH
25329: LD_INT 14
25331: PUSH
25332: LD_INT 15
25334: PUSH
25335: LD_INT 16
25337: PUSH
25338: LD_INT 17
25340: PUSH
25341: LD_INT 18
25343: PUSH
25344: LD_INT 19
25346: PUSH
25347: LD_INT 20
25349: PUSH
25350: LD_INT 21
25352: PUSH
25353: LD_INT 22
25355: PUSH
25356: LD_INT 23
25358: PUSH
25359: LD_INT 24
25361: PUSH
25362: LD_INT 25
25364: PUSH
25365: LD_INT 26
25367: PUSH
25368: LD_INT 27
25370: PUSH
25371: LD_INT 28
25373: PUSH
25374: LD_INT 29
25376: PUSH
25377: LD_INT 30
25379: PUSH
25380: LD_INT 31
25382: PUSH
25383: LD_INT 32
25385: PUSH
25386: LD_INT 33
25388: PUSH
25389: LD_INT 34
25391: PUSH
25392: LD_INT 36
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: LIST
25405: LIST
25406: LIST
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: LIST
25412: LIST
25413: LIST
25414: LIST
25415: LIST
25416: LIST
25417: LIST
25418: LIST
25419: LIST
25420: LIST
25421: LIST
25422: LIST
25423: LIST
25424: LIST
25425: LIST
25426: LIST
25427: LIST
25428: LIST
25429: LIST
25430: LIST
25431: PUSH
25432: LD_INT 101
25434: PUSH
25435: LD_INT 102
25437: PUSH
25438: LD_INT 103
25440: PUSH
25441: LD_INT 104
25443: PUSH
25444: LD_INT 105
25446: PUSH
25447: LD_INT 106
25449: PUSH
25450: LD_INT 107
25452: PUSH
25453: LD_INT 108
25455: PUSH
25456: LD_INT 109
25458: PUSH
25459: LD_INT 110
25461: PUSH
25462: LD_INT 111
25464: PUSH
25465: LD_INT 112
25467: PUSH
25468: LD_INT 113
25470: PUSH
25471: LD_INT 114
25473: PUSH
25474: LD_INT 116
25476: PUSH
25477: LD_INT 117
25479: PUSH
25480: LD_INT 118
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: LIST
25491: LIST
25492: LIST
25493: LIST
25494: LIST
25495: LIST
25496: LIST
25497: LIST
25498: LIST
25499: LIST
25500: LIST
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: ST_TO_ADDR
25506: GO 25905
25508: LD_INT 18
25510: DOUBLE
25511: EQUAL
25512: IFTRUE 25516
25514: GO 25664
25516: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
25517: LD_ADDR_VAR 0 2
25521: PUSH
25522: LD_INT 2
25524: PUSH
25525: LD_INT 4
25527: PUSH
25528: LD_INT 5
25530: PUSH
25531: LD_INT 7
25533: PUSH
25534: LD_INT 11
25536: PUSH
25537: LD_INT 12
25539: PUSH
25540: LD_INT 15
25542: PUSH
25543: LD_INT 16
25545: PUSH
25546: LD_INT 20
25548: PUSH
25549: LD_INT 21
25551: PUSH
25552: LD_INT 22
25554: PUSH
25555: LD_INT 23
25557: PUSH
25558: LD_INT 25
25560: PUSH
25561: LD_INT 26
25563: PUSH
25564: LD_INT 30
25566: PUSH
25567: LD_INT 31
25569: PUSH
25570: LD_INT 32
25572: PUSH
25573: LD_INT 33
25575: PUSH
25576: LD_INT 34
25578: PUSH
25579: LD_INT 35
25581: PUSH
25582: LD_INT 36
25584: PUSH
25585: EMPTY
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 101
25610: PUSH
25611: LD_INT 102
25613: PUSH
25614: LD_INT 103
25616: PUSH
25617: LD_INT 106
25619: PUSH
25620: LD_INT 108
25622: PUSH
25623: LD_INT 112
25625: PUSH
25626: LD_INT 113
25628: PUSH
25629: LD_INT 114
25631: PUSH
25632: LD_INT 115
25634: PUSH
25635: LD_INT 116
25637: PUSH
25638: LD_INT 117
25640: PUSH
25641: LD_INT 118
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: LIST
25652: LIST
25653: LIST
25654: LIST
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: ST_TO_ADDR
25662: GO 25905
25664: LD_INT 19
25666: DOUBLE
25667: EQUAL
25668: IFTRUE 25672
25670: GO 25904
25672: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
25673: LD_ADDR_VAR 0 2
25677: PUSH
25678: LD_INT 1
25680: PUSH
25681: LD_INT 2
25683: PUSH
25684: LD_INT 3
25686: PUSH
25687: LD_INT 4
25689: PUSH
25690: LD_INT 5
25692: PUSH
25693: LD_INT 6
25695: PUSH
25696: LD_INT 7
25698: PUSH
25699: LD_INT 8
25701: PUSH
25702: LD_INT 9
25704: PUSH
25705: LD_INT 10
25707: PUSH
25708: LD_INT 11
25710: PUSH
25711: LD_INT 12
25713: PUSH
25714: LD_INT 13
25716: PUSH
25717: LD_INT 14
25719: PUSH
25720: LD_INT 15
25722: PUSH
25723: LD_INT 16
25725: PUSH
25726: LD_INT 17
25728: PUSH
25729: LD_INT 18
25731: PUSH
25732: LD_INT 19
25734: PUSH
25735: LD_INT 20
25737: PUSH
25738: LD_INT 21
25740: PUSH
25741: LD_INT 22
25743: PUSH
25744: LD_INT 23
25746: PUSH
25747: LD_INT 24
25749: PUSH
25750: LD_INT 25
25752: PUSH
25753: LD_INT 26
25755: PUSH
25756: LD_INT 27
25758: PUSH
25759: LD_INT 28
25761: PUSH
25762: LD_INT 29
25764: PUSH
25765: LD_INT 30
25767: PUSH
25768: LD_INT 31
25770: PUSH
25771: LD_INT 32
25773: PUSH
25774: LD_INT 33
25776: PUSH
25777: LD_INT 34
25779: PUSH
25780: LD_INT 35
25782: PUSH
25783: LD_INT 36
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: LIST
25790: LIST
25791: LIST
25792: LIST
25793: LIST
25794: LIST
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: LIST
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: LIST
25806: LIST
25807: LIST
25808: LIST
25809: LIST
25810: LIST
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: PUSH
25824: LD_INT 101
25826: PUSH
25827: LD_INT 102
25829: PUSH
25830: LD_INT 103
25832: PUSH
25833: LD_INT 104
25835: PUSH
25836: LD_INT 105
25838: PUSH
25839: LD_INT 106
25841: PUSH
25842: LD_INT 107
25844: PUSH
25845: LD_INT 108
25847: PUSH
25848: LD_INT 109
25850: PUSH
25851: LD_INT 110
25853: PUSH
25854: LD_INT 111
25856: PUSH
25857: LD_INT 112
25859: PUSH
25860: LD_INT 113
25862: PUSH
25863: LD_INT 114
25865: PUSH
25866: LD_INT 115
25868: PUSH
25869: LD_INT 116
25871: PUSH
25872: LD_INT 117
25874: PUSH
25875: LD_INT 118
25877: PUSH
25878: EMPTY
25879: LIST
25880: LIST
25881: LIST
25882: LIST
25883: LIST
25884: LIST
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: ST_TO_ADDR
25902: GO 25905
25904: POP
// end else
25905: GO 26136
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
25907: LD_ADDR_VAR 0 2
25911: PUSH
25912: LD_INT 1
25914: PUSH
25915: LD_INT 2
25917: PUSH
25918: LD_INT 3
25920: PUSH
25921: LD_INT 4
25923: PUSH
25924: LD_INT 5
25926: PUSH
25927: LD_INT 6
25929: PUSH
25930: LD_INT 7
25932: PUSH
25933: LD_INT 8
25935: PUSH
25936: LD_INT 9
25938: PUSH
25939: LD_INT 10
25941: PUSH
25942: LD_INT 11
25944: PUSH
25945: LD_INT 12
25947: PUSH
25948: LD_INT 13
25950: PUSH
25951: LD_INT 14
25953: PUSH
25954: LD_INT 15
25956: PUSH
25957: LD_INT 16
25959: PUSH
25960: LD_INT 17
25962: PUSH
25963: LD_INT 18
25965: PUSH
25966: LD_INT 19
25968: PUSH
25969: LD_INT 20
25971: PUSH
25972: LD_INT 21
25974: PUSH
25975: LD_INT 22
25977: PUSH
25978: LD_INT 23
25980: PUSH
25981: LD_INT 24
25983: PUSH
25984: LD_INT 25
25986: PUSH
25987: LD_INT 26
25989: PUSH
25990: LD_INT 27
25992: PUSH
25993: LD_INT 28
25995: PUSH
25996: LD_INT 29
25998: PUSH
25999: LD_INT 30
26001: PUSH
26002: LD_INT 31
26004: PUSH
26005: LD_INT 32
26007: PUSH
26008: LD_INT 33
26010: PUSH
26011: LD_INT 34
26013: PUSH
26014: LD_INT 35
26016: PUSH
26017: LD_INT 36
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: LIST
26030: LIST
26031: LIST
26032: LIST
26033: LIST
26034: LIST
26035: LIST
26036: LIST
26037: LIST
26038: LIST
26039: LIST
26040: LIST
26041: LIST
26042: LIST
26043: LIST
26044: LIST
26045: LIST
26046: LIST
26047: LIST
26048: LIST
26049: LIST
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: PUSH
26058: LD_INT 101
26060: PUSH
26061: LD_INT 102
26063: PUSH
26064: LD_INT 103
26066: PUSH
26067: LD_INT 104
26069: PUSH
26070: LD_INT 105
26072: PUSH
26073: LD_INT 106
26075: PUSH
26076: LD_INT 107
26078: PUSH
26079: LD_INT 108
26081: PUSH
26082: LD_INT 109
26084: PUSH
26085: LD_INT 110
26087: PUSH
26088: LD_INT 111
26090: PUSH
26091: LD_INT 112
26093: PUSH
26094: LD_INT 113
26096: PUSH
26097: LD_INT 114
26099: PUSH
26100: LD_INT 115
26102: PUSH
26103: LD_INT 116
26105: PUSH
26106: LD_INT 117
26108: PUSH
26109: LD_INT 118
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: ST_TO_ADDR
// if result then
26136: LD_VAR 0 2
26140: IFFALSE 26926
// begin normal :=  ;
26142: LD_ADDR_VAR 0 5
26146: PUSH
26147: LD_STRING 
26149: ST_TO_ADDR
// hardcore :=  ;
26150: LD_ADDR_VAR 0 6
26154: PUSH
26155: LD_STRING 
26157: ST_TO_ADDR
// active :=  ;
26158: LD_ADDR_VAR 0 7
26162: PUSH
26163: LD_STRING 
26165: ST_TO_ADDR
// for i = 1 to normalCounter do
26166: LD_ADDR_VAR 0 8
26170: PUSH
26171: DOUBLE
26172: LD_INT 1
26174: DEC
26175: ST_TO_ADDR
26176: LD_EXP 30
26180: PUSH
26181: FOR_TO
26182: IFFALSE 26283
// begin tmp := 0 ;
26184: LD_ADDR_VAR 0 3
26188: PUSH
26189: LD_STRING 0
26191: ST_TO_ADDR
// if result [ 1 ] then
26192: LD_VAR 0 2
26196: PUSH
26197: LD_INT 1
26199: ARRAY
26200: IFFALSE 26265
// if result [ 1 ] [ 1 ] = i then
26202: LD_VAR 0 2
26206: PUSH
26207: LD_INT 1
26209: ARRAY
26210: PUSH
26211: LD_INT 1
26213: ARRAY
26214: PUSH
26215: LD_VAR 0 8
26219: EQUAL
26220: IFFALSE 26265
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
26222: LD_ADDR_VAR 0 2
26226: PUSH
26227: LD_VAR 0 2
26231: PPUSH
26232: LD_INT 1
26234: PPUSH
26235: LD_VAR 0 2
26239: PUSH
26240: LD_INT 1
26242: ARRAY
26243: PPUSH
26244: LD_INT 1
26246: PPUSH
26247: CALL_OW 3
26251: PPUSH
26252: CALL_OW 1
26256: ST_TO_ADDR
// tmp := 1 ;
26257: LD_ADDR_VAR 0 3
26261: PUSH
26262: LD_STRING 1
26264: ST_TO_ADDR
// end ; normal := normal & tmp ;
26265: LD_ADDR_VAR 0 5
26269: PUSH
26270: LD_VAR 0 5
26274: PUSH
26275: LD_VAR 0 3
26279: STR
26280: ST_TO_ADDR
// end ;
26281: GO 26181
26283: POP
26284: POP
// for i = 1 to hardcoreCounter do
26285: LD_ADDR_VAR 0 8
26289: PUSH
26290: DOUBLE
26291: LD_INT 1
26293: DEC
26294: ST_TO_ADDR
26295: LD_EXP 31
26299: PUSH
26300: FOR_TO
26301: IFFALSE 26406
// begin tmp := 0 ;
26303: LD_ADDR_VAR 0 3
26307: PUSH
26308: LD_STRING 0
26310: ST_TO_ADDR
// if result [ 2 ] then
26311: LD_VAR 0 2
26315: PUSH
26316: LD_INT 2
26318: ARRAY
26319: IFFALSE 26388
// if result [ 2 ] [ 1 ] = 100 + i then
26321: LD_VAR 0 2
26325: PUSH
26326: LD_INT 2
26328: ARRAY
26329: PUSH
26330: LD_INT 1
26332: ARRAY
26333: PUSH
26334: LD_INT 100
26336: PUSH
26337: LD_VAR 0 8
26341: PLUS
26342: EQUAL
26343: IFFALSE 26388
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
26345: LD_ADDR_VAR 0 2
26349: PUSH
26350: LD_VAR 0 2
26354: PPUSH
26355: LD_INT 2
26357: PPUSH
26358: LD_VAR 0 2
26362: PUSH
26363: LD_INT 2
26365: ARRAY
26366: PPUSH
26367: LD_INT 1
26369: PPUSH
26370: CALL_OW 3
26374: PPUSH
26375: CALL_OW 1
26379: ST_TO_ADDR
// tmp := 1 ;
26380: LD_ADDR_VAR 0 3
26384: PUSH
26385: LD_STRING 1
26387: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
26388: LD_ADDR_VAR 0 6
26392: PUSH
26393: LD_VAR 0 6
26397: PUSH
26398: LD_VAR 0 3
26402: STR
26403: ST_TO_ADDR
// end ;
26404: GO 26300
26406: POP
26407: POP
// if isGameLoad then
26408: LD_VAR 0 1
26412: IFFALSE 26887
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
26414: LD_ADDR_VAR 0 4
26418: PUSH
26419: LD_EXP 34
26423: PUSH
26424: LD_EXP 33
26428: PUSH
26429: LD_EXP 35
26433: PUSH
26434: LD_EXP 32
26438: PUSH
26439: LD_EXP 36
26443: PUSH
26444: LD_EXP 37
26448: PUSH
26449: LD_EXP 38
26453: PUSH
26454: LD_EXP 39
26458: PUSH
26459: LD_EXP 40
26463: PUSH
26464: LD_EXP 41
26468: PUSH
26469: LD_EXP 42
26473: PUSH
26474: LD_EXP 43
26478: PUSH
26479: LD_EXP 44
26483: PUSH
26484: LD_EXP 45
26488: PUSH
26489: LD_EXP 53
26493: PUSH
26494: LD_EXP 54
26498: PUSH
26499: LD_EXP 55
26503: PUSH
26504: LD_EXP 56
26508: PUSH
26509: LD_EXP 58
26513: PUSH
26514: LD_EXP 59
26518: PUSH
26519: LD_EXP 60
26523: PUSH
26524: LD_EXP 63
26528: PUSH
26529: LD_EXP 65
26533: PUSH
26534: LD_EXP 66
26538: PUSH
26539: LD_EXP 67
26543: PUSH
26544: LD_EXP 69
26548: PUSH
26549: LD_EXP 70
26553: PUSH
26554: LD_EXP 73
26558: PUSH
26559: LD_EXP 74
26563: PUSH
26564: LD_EXP 75
26568: PUSH
26569: LD_EXP 76
26573: PUSH
26574: LD_EXP 77
26578: PUSH
26579: LD_EXP 78
26583: PUSH
26584: LD_EXP 79
26588: PUSH
26589: LD_EXP 80
26593: PUSH
26594: LD_EXP 81
26598: PUSH
26599: LD_EXP 46
26603: PUSH
26604: LD_EXP 47
26608: PUSH
26609: LD_EXP 50
26613: PUSH
26614: LD_EXP 51
26618: PUSH
26619: LD_EXP 52
26623: PUSH
26624: LD_EXP 48
26628: PUSH
26629: LD_EXP 49
26633: PUSH
26634: LD_EXP 57
26638: PUSH
26639: LD_EXP 61
26643: PUSH
26644: LD_EXP 62
26648: PUSH
26649: LD_EXP 64
26653: PUSH
26654: LD_EXP 68
26658: PUSH
26659: LD_EXP 71
26663: PUSH
26664: LD_EXP 72
26668: PUSH
26669: LD_EXP 82
26673: PUSH
26674: LD_EXP 83
26678: PUSH
26679: LD_EXP 84
26683: PUSH
26684: LD_EXP 85
26688: PUSH
26689: EMPTY
26690: LIST
26691: LIST
26692: LIST
26693: LIST
26694: LIST
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: LIST
26706: LIST
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: LIST
26712: LIST
26713: LIST
26714: LIST
26715: LIST
26716: LIST
26717: LIST
26718: LIST
26719: LIST
26720: LIST
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: LIST
26740: LIST
26741: LIST
26742: LIST
26743: LIST
26744: ST_TO_ADDR
// tmp :=  ;
26745: LD_ADDR_VAR 0 3
26749: PUSH
26750: LD_STRING 
26752: ST_TO_ADDR
// for i = 1 to normalCounter do
26753: LD_ADDR_VAR 0 8
26757: PUSH
26758: DOUBLE
26759: LD_INT 1
26761: DEC
26762: ST_TO_ADDR
26763: LD_EXP 30
26767: PUSH
26768: FOR_TO
26769: IFFALSE 26805
// begin if flags [ i ] then
26771: LD_VAR 0 4
26775: PUSH
26776: LD_VAR 0 8
26780: ARRAY
26781: IFFALSE 26803
// tmp := tmp & i & ; ;
26783: LD_ADDR_VAR 0 3
26787: PUSH
26788: LD_VAR 0 3
26792: PUSH
26793: LD_VAR 0 8
26797: STR
26798: PUSH
26799: LD_STRING ;
26801: STR
26802: ST_TO_ADDR
// end ;
26803: GO 26768
26805: POP
26806: POP
// for i = 1 to hardcoreCounter do
26807: LD_ADDR_VAR 0 8
26811: PUSH
26812: DOUBLE
26813: LD_INT 1
26815: DEC
26816: ST_TO_ADDR
26817: LD_EXP 31
26821: PUSH
26822: FOR_TO
26823: IFFALSE 26869
// begin if flags [ normalCounter + i ] then
26825: LD_VAR 0 4
26829: PUSH
26830: LD_EXP 30
26834: PUSH
26835: LD_VAR 0 8
26839: PLUS
26840: ARRAY
26841: IFFALSE 26867
// tmp := tmp & ( 100 + i ) & ; ;
26843: LD_ADDR_VAR 0 3
26847: PUSH
26848: LD_VAR 0 3
26852: PUSH
26853: LD_INT 100
26855: PUSH
26856: LD_VAR 0 8
26860: PLUS
26861: STR
26862: PUSH
26863: LD_STRING ;
26865: STR
26866: ST_TO_ADDR
// end ;
26867: GO 26822
26869: POP
26870: POP
// if tmp then
26871: LD_VAR 0 3
26875: IFFALSE 26887
// active := tmp ;
26877: LD_ADDR_VAR 0 7
26881: PUSH
26882: LD_VAR 0 3
26886: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
26887: LD_STRING getStreamItemsFromMission("
26889: PUSH
26890: LD_VAR 0 5
26894: STR
26895: PUSH
26896: LD_STRING ","
26898: STR
26899: PUSH
26900: LD_VAR 0 6
26904: STR
26905: PUSH
26906: LD_STRING ","
26908: STR
26909: PUSH
26910: LD_VAR 0 7
26914: STR
26915: PUSH
26916: LD_STRING ")
26918: STR
26919: PPUSH
26920: CALL_OW 559
// end else
26924: GO 26933
// ToLua ( getStreamItemsFromMission("","","") ) ;
26926: LD_STRING getStreamItemsFromMission("","","")
26928: PPUSH
26929: CALL_OW 559
// end ;
26933: LD_VAR 0 2
26937: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
26938: LD_EXP 29
26942: PUSH
26943: LD_EXP 34
26947: AND
26948: IFFALSE 27072
26950: GO 26952
26952: DISABLE
26953: LD_INT 0
26955: PPUSH
26956: PPUSH
// begin enable ;
26957: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
26958: LD_ADDR_VAR 0 2
26962: PUSH
26963: LD_INT 22
26965: PUSH
26966: LD_OWVAR 2
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 2
26977: PUSH
26978: LD_INT 34
26980: PUSH
26981: LD_INT 7
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: LD_INT 34
26990: PUSH
26991: LD_INT 45
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 34
27000: PUSH
27001: LD_INT 28
27003: PUSH
27004: EMPTY
27005: LIST
27006: LIST
27007: PUSH
27008: LD_INT 34
27010: PUSH
27011: LD_INT 47
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PPUSH
27029: CALL_OW 69
27033: ST_TO_ADDR
// if not tmp then
27034: LD_VAR 0 2
27038: NOT
27039: IFFALSE 27043
// exit ;
27041: GO 27072
// for i in tmp do
27043: LD_ADDR_VAR 0 1
27047: PUSH
27048: LD_VAR 0 2
27052: PUSH
27053: FOR_IN
27054: IFFALSE 27070
// begin SetLives ( i , 0 ) ;
27056: LD_VAR 0 1
27060: PPUSH
27061: LD_INT 0
27063: PPUSH
27064: CALL_OW 234
// end ;
27068: GO 27053
27070: POP
27071: POP
// end ;
27072: PPOPN 2
27074: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
27075: LD_EXP 29
27079: PUSH
27080: LD_EXP 35
27084: AND
27085: IFFALSE 27169
27087: GO 27089
27089: DISABLE
27090: LD_INT 0
27092: PPUSH
27093: PPUSH
// begin enable ;
27094: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
27095: LD_ADDR_VAR 0 2
27099: PUSH
27100: LD_INT 22
27102: PUSH
27103: LD_OWVAR 2
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 32
27114: PUSH
27115: LD_INT 3
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PPUSH
27126: CALL_OW 69
27130: ST_TO_ADDR
// if not tmp then
27131: LD_VAR 0 2
27135: NOT
27136: IFFALSE 27140
// exit ;
27138: GO 27169
// for i in tmp do
27140: LD_ADDR_VAR 0 1
27144: PUSH
27145: LD_VAR 0 2
27149: PUSH
27150: FOR_IN
27151: IFFALSE 27167
// begin SetLives ( i , 0 ) ;
27153: LD_VAR 0 1
27157: PPUSH
27158: LD_INT 0
27160: PPUSH
27161: CALL_OW 234
// end ;
27165: GO 27150
27167: POP
27168: POP
// end ;
27169: PPOPN 2
27171: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
27172: LD_EXP 29
27176: PUSH
27177: LD_EXP 32
27181: AND
27182: IFFALSE 27275
27184: GO 27186
27186: DISABLE
27187: LD_INT 0
27189: PPUSH
// begin enable ;
27190: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
27191: LD_ADDR_VAR 0 1
27195: PUSH
27196: LD_INT 22
27198: PUSH
27199: LD_OWVAR 2
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 2
27210: PUSH
27211: LD_INT 25
27213: PUSH
27214: LD_INT 5
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 25
27223: PUSH
27224: LD_INT 9
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 25
27233: PUSH
27234: LD_INT 8
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PPUSH
27251: CALL_OW 69
27255: PUSH
27256: FOR_IN
27257: IFFALSE 27273
// begin SetClass ( i , 1 ) ;
27259: LD_VAR 0 1
27263: PPUSH
27264: LD_INT 1
27266: PPUSH
27267: CALL_OW 336
// end ;
27271: GO 27256
27273: POP
27274: POP
// end ;
27275: PPOPN 1
27277: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
27278: LD_EXP 29
27282: PUSH
27283: LD_EXP 33
27287: AND
27288: PUSH
27289: LD_OWVAR 65
27293: PUSH
27294: LD_INT 7
27296: LESS
27297: AND
27298: IFFALSE 27312
27300: GO 27302
27302: DISABLE
// begin enable ;
27303: ENABLE
// game_speed := 7 ;
27304: LD_ADDR_OWVAR 65
27308: PUSH
27309: LD_INT 7
27311: ST_TO_ADDR
// end ;
27312: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
27313: LD_EXP 29
27317: PUSH
27318: LD_EXP 36
27322: AND
27323: IFFALSE 27525
27325: GO 27327
27327: DISABLE
27328: LD_INT 0
27330: PPUSH
27331: PPUSH
27332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
27333: LD_ADDR_VAR 0 3
27337: PUSH
27338: LD_INT 81
27340: PUSH
27341: LD_OWVAR 2
27345: PUSH
27346: EMPTY
27347: LIST
27348: LIST
27349: PUSH
27350: LD_INT 21
27352: PUSH
27353: LD_INT 1
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PPUSH
27364: CALL_OW 69
27368: ST_TO_ADDR
// if not tmp then
27369: LD_VAR 0 3
27373: NOT
27374: IFFALSE 27378
// exit ;
27376: GO 27525
// if tmp > 5 then
27378: LD_VAR 0 3
27382: PUSH
27383: LD_INT 5
27385: GREATER
27386: IFFALSE 27398
// k := 5 else
27388: LD_ADDR_VAR 0 2
27392: PUSH
27393: LD_INT 5
27395: ST_TO_ADDR
27396: GO 27408
// k := tmp ;
27398: LD_ADDR_VAR 0 2
27402: PUSH
27403: LD_VAR 0 3
27407: ST_TO_ADDR
// for i := 1 to k do
27408: LD_ADDR_VAR 0 1
27412: PUSH
27413: DOUBLE
27414: LD_INT 1
27416: DEC
27417: ST_TO_ADDR
27418: LD_VAR 0 2
27422: PUSH
27423: FOR_TO
27424: IFFALSE 27523
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
27426: LD_VAR 0 3
27430: PUSH
27431: LD_VAR 0 1
27435: ARRAY
27436: PPUSH
27437: LD_VAR 0 1
27441: PUSH
27442: LD_INT 4
27444: MOD
27445: PUSH
27446: LD_INT 1
27448: PLUS
27449: PPUSH
27450: CALL_OW 259
27454: PUSH
27455: LD_INT 10
27457: LESS
27458: IFFALSE 27521
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
27460: LD_VAR 0 3
27464: PUSH
27465: LD_VAR 0 1
27469: ARRAY
27470: PPUSH
27471: LD_VAR 0 1
27475: PUSH
27476: LD_INT 4
27478: MOD
27479: PUSH
27480: LD_INT 1
27482: PLUS
27483: PPUSH
27484: LD_VAR 0 3
27488: PUSH
27489: LD_VAR 0 1
27493: ARRAY
27494: PPUSH
27495: LD_VAR 0 1
27499: PUSH
27500: LD_INT 4
27502: MOD
27503: PUSH
27504: LD_INT 1
27506: PLUS
27507: PPUSH
27508: CALL_OW 259
27512: PUSH
27513: LD_INT 1
27515: PLUS
27516: PPUSH
27517: CALL_OW 237
27521: GO 27423
27523: POP
27524: POP
// end ;
27525: PPOPN 3
27527: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
27528: LD_EXP 29
27532: PUSH
27533: LD_EXP 37
27537: AND
27538: IFFALSE 27558
27540: GO 27542
27542: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
27543: LD_INT 4
27545: PPUSH
27546: LD_OWVAR 2
27550: PPUSH
27551: LD_INT 0
27553: PPUSH
27554: CALL_OW 324
27558: END
// every 0 0$1 trigger StreamModeActive and sShovel do
27559: LD_EXP 29
27563: PUSH
27564: LD_EXP 66
27568: AND
27569: IFFALSE 27589
27571: GO 27573
27573: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
27574: LD_INT 19
27576: PPUSH
27577: LD_OWVAR 2
27581: PPUSH
27582: LD_INT 0
27584: PPUSH
27585: CALL_OW 324
27589: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
27590: LD_EXP 29
27594: PUSH
27595: LD_EXP 38
27599: AND
27600: IFFALSE 27702
27602: GO 27604
27604: DISABLE
27605: LD_INT 0
27607: PPUSH
27608: PPUSH
// begin enable ;
27609: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
27610: LD_ADDR_VAR 0 2
27614: PUSH
27615: LD_INT 22
27617: PUSH
27618: LD_OWVAR 2
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: PUSH
27627: LD_INT 2
27629: PUSH
27630: LD_INT 34
27632: PUSH
27633: LD_INT 11
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 34
27642: PUSH
27643: LD_INT 30
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: LIST
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PPUSH
27659: CALL_OW 69
27663: ST_TO_ADDR
// if not tmp then
27664: LD_VAR 0 2
27668: NOT
27669: IFFALSE 27673
// exit ;
27671: GO 27702
// for i in tmp do
27673: LD_ADDR_VAR 0 1
27677: PUSH
27678: LD_VAR 0 2
27682: PUSH
27683: FOR_IN
27684: IFFALSE 27700
// begin SetLives ( i , 0 ) ;
27686: LD_VAR 0 1
27690: PPUSH
27691: LD_INT 0
27693: PPUSH
27694: CALL_OW 234
// end ;
27698: GO 27683
27700: POP
27701: POP
// end ;
27702: PPOPN 2
27704: END
// every 0 0$1 trigger StreamModeActive and sBunker do
27705: LD_EXP 29
27709: PUSH
27710: LD_EXP 39
27714: AND
27715: IFFALSE 27735
27717: GO 27719
27719: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
27720: LD_INT 32
27722: PPUSH
27723: LD_OWVAR 2
27727: PPUSH
27728: LD_INT 0
27730: PPUSH
27731: CALL_OW 324
27735: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
27736: LD_EXP 29
27740: PUSH
27741: LD_EXP 40
27745: AND
27746: IFFALSE 27927
27748: GO 27750
27750: DISABLE
27751: LD_INT 0
27753: PPUSH
27754: PPUSH
27755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
27756: LD_ADDR_VAR 0 2
27760: PUSH
27761: LD_INT 22
27763: PUSH
27764: LD_OWVAR 2
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 33
27775: PUSH
27776: LD_INT 3
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL_OW 69
27791: ST_TO_ADDR
// if not tmp then
27792: LD_VAR 0 2
27796: NOT
27797: IFFALSE 27801
// exit ;
27799: GO 27927
// side := 0 ;
27801: LD_ADDR_VAR 0 3
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// for i := 1 to 8 do
27809: LD_ADDR_VAR 0 1
27813: PUSH
27814: DOUBLE
27815: LD_INT 1
27817: DEC
27818: ST_TO_ADDR
27819: LD_INT 8
27821: PUSH
27822: FOR_TO
27823: IFFALSE 27871
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
27825: LD_OWVAR 2
27829: PUSH
27830: LD_VAR 0 1
27834: NONEQUAL
27835: PUSH
27836: LD_OWVAR 2
27840: PPUSH
27841: LD_VAR 0 1
27845: PPUSH
27846: CALL_OW 81
27850: PUSH
27851: LD_INT 2
27853: EQUAL
27854: AND
27855: IFFALSE 27869
// begin side := i ;
27857: LD_ADDR_VAR 0 3
27861: PUSH
27862: LD_VAR 0 1
27866: ST_TO_ADDR
// break ;
27867: GO 27871
// end ;
27869: GO 27822
27871: POP
27872: POP
// if not side then
27873: LD_VAR 0 3
27877: NOT
27878: IFFALSE 27882
// exit ;
27880: GO 27927
// for i := 1 to tmp do
27882: LD_ADDR_VAR 0 1
27886: PUSH
27887: DOUBLE
27888: LD_INT 1
27890: DEC
27891: ST_TO_ADDR
27892: LD_VAR 0 2
27896: PUSH
27897: FOR_TO
27898: IFFALSE 27925
// if Prob ( 60 ) then
27900: LD_INT 60
27902: PPUSH
27903: CALL_OW 13
27907: IFFALSE 27923
// SetSide ( i , side ) ;
27909: LD_VAR 0 1
27913: PPUSH
27914: LD_VAR 0 3
27918: PPUSH
27919: CALL_OW 235
27923: GO 27897
27925: POP
27926: POP
// end ;
27927: PPOPN 3
27929: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
27930: LD_EXP 29
27934: PUSH
27935: LD_EXP 42
27939: AND
27940: IFFALSE 28059
27942: GO 27944
27944: DISABLE
27945: LD_INT 0
27947: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
27948: LD_ADDR_VAR 0 1
27952: PUSH
27953: LD_INT 22
27955: PUSH
27956: LD_OWVAR 2
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 21
27967: PUSH
27968: LD_INT 1
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: LD_INT 3
27977: PUSH
27978: LD_INT 23
27980: PUSH
27981: LD_INT 0
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: LIST
27996: PPUSH
27997: CALL_OW 69
28001: PUSH
28002: FOR_IN
28003: IFFALSE 28057
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
28005: LD_VAR 0 1
28009: PPUSH
28010: CALL_OW 257
28014: PUSH
28015: LD_INT 1
28017: PUSH
28018: LD_INT 2
28020: PUSH
28021: LD_INT 3
28023: PUSH
28024: LD_INT 4
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: IN
28033: IFFALSE 28055
// SetClass ( un , rand ( 1 , 4 ) ) ;
28035: LD_VAR 0 1
28039: PPUSH
28040: LD_INT 1
28042: PPUSH
28043: LD_INT 4
28045: PPUSH
28046: CALL_OW 12
28050: PPUSH
28051: CALL_OW 336
28055: GO 28002
28057: POP
28058: POP
// end ;
28059: PPOPN 1
28061: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
28062: LD_EXP 29
28066: PUSH
28067: LD_EXP 41
28071: AND
28072: IFFALSE 28151
28074: GO 28076
28076: DISABLE
28077: LD_INT 0
28079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
28080: LD_ADDR_VAR 0 1
28084: PUSH
28085: LD_INT 22
28087: PUSH
28088: LD_OWVAR 2
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 21
28099: PUSH
28100: LD_INT 3
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PPUSH
28111: CALL_OW 69
28115: ST_TO_ADDR
// if not tmp then
28116: LD_VAR 0 1
28120: NOT
28121: IFFALSE 28125
// exit ;
28123: GO 28151
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
28125: LD_VAR 0 1
28129: PUSH
28130: LD_INT 1
28132: PPUSH
28133: LD_VAR 0 1
28137: PPUSH
28138: CALL_OW 12
28142: ARRAY
28143: PPUSH
28144: LD_INT 100
28146: PPUSH
28147: CALL_OW 234
// end ;
28151: PPOPN 1
28153: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
28154: LD_EXP 29
28158: PUSH
28159: LD_EXP 43
28163: AND
28164: IFFALSE 28262
28166: GO 28168
28168: DISABLE
28169: LD_INT 0
28171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28172: LD_ADDR_VAR 0 1
28176: PUSH
28177: LD_INT 22
28179: PUSH
28180: LD_OWVAR 2
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 21
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PPUSH
28203: CALL_OW 69
28207: ST_TO_ADDR
// if not tmp then
28208: LD_VAR 0 1
28212: NOT
28213: IFFALSE 28217
// exit ;
28215: GO 28262
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
28217: LD_VAR 0 1
28221: PUSH
28222: LD_INT 1
28224: PPUSH
28225: LD_VAR 0 1
28229: PPUSH
28230: CALL_OW 12
28234: ARRAY
28235: PPUSH
28236: LD_INT 1
28238: PPUSH
28239: LD_INT 4
28241: PPUSH
28242: CALL_OW 12
28246: PPUSH
28247: LD_INT 3000
28249: PPUSH
28250: LD_INT 9000
28252: PPUSH
28253: CALL_OW 12
28257: PPUSH
28258: CALL_OW 492
// end ;
28262: PPOPN 1
28264: END
// every 0 0$1 trigger StreamModeActive and sDepot do
28265: LD_EXP 29
28269: PUSH
28270: LD_EXP 44
28274: AND
28275: IFFALSE 28295
28277: GO 28279
28279: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
28280: LD_INT 1
28282: PPUSH
28283: LD_OWVAR 2
28287: PPUSH
28288: LD_INT 0
28290: PPUSH
28291: CALL_OW 324
28295: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
28296: LD_EXP 29
28300: PUSH
28301: LD_EXP 45
28305: AND
28306: IFFALSE 28389
28308: GO 28310
28310: DISABLE
28311: LD_INT 0
28313: PPUSH
28314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
28315: LD_ADDR_VAR 0 2
28319: PUSH
28320: LD_INT 22
28322: PUSH
28323: LD_OWVAR 2
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 21
28334: PUSH
28335: LD_INT 3
28337: PUSH
28338: EMPTY
28339: LIST
28340: LIST
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PPUSH
28346: CALL_OW 69
28350: ST_TO_ADDR
// if not tmp then
28351: LD_VAR 0 2
28355: NOT
28356: IFFALSE 28360
// exit ;
28358: GO 28389
// for i in tmp do
28360: LD_ADDR_VAR 0 1
28364: PUSH
28365: LD_VAR 0 2
28369: PUSH
28370: FOR_IN
28371: IFFALSE 28387
// SetBLevel ( i , 10 ) ;
28373: LD_VAR 0 1
28377: PPUSH
28378: LD_INT 10
28380: PPUSH
28381: CALL_OW 241
28385: GO 28370
28387: POP
28388: POP
// end ;
28389: PPOPN 2
28391: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
28392: LD_EXP 29
28396: PUSH
28397: LD_EXP 46
28401: AND
28402: IFFALSE 28513
28404: GO 28406
28406: DISABLE
28407: LD_INT 0
28409: PPUSH
28410: PPUSH
28411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28412: LD_ADDR_VAR 0 3
28416: PUSH
28417: LD_INT 22
28419: PUSH
28420: LD_OWVAR 2
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: LD_INT 25
28431: PUSH
28432: LD_INT 1
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PPUSH
28443: CALL_OW 69
28447: ST_TO_ADDR
// if not tmp then
28448: LD_VAR 0 3
28452: NOT
28453: IFFALSE 28457
// exit ;
28455: GO 28513
// un := tmp [ rand ( 1 , tmp ) ] ;
28457: LD_ADDR_VAR 0 2
28461: PUSH
28462: LD_VAR 0 3
28466: PUSH
28467: LD_INT 1
28469: PPUSH
28470: LD_VAR 0 3
28474: PPUSH
28475: CALL_OW 12
28479: ARRAY
28480: ST_TO_ADDR
// if Crawls ( un ) then
28481: LD_VAR 0 2
28485: PPUSH
28486: CALL_OW 318
28490: IFFALSE 28501
// ComWalk ( un ) ;
28492: LD_VAR 0 2
28496: PPUSH
28497: CALL_OW 138
// SetClass ( un , class_sniper ) ;
28501: LD_VAR 0 2
28505: PPUSH
28506: LD_INT 5
28508: PPUSH
28509: CALL_OW 336
// end ;
28513: PPOPN 3
28515: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
28516: LD_EXP 29
28520: PUSH
28521: LD_EXP 47
28525: AND
28526: PUSH
28527: LD_OWVAR 67
28531: PUSH
28532: LD_INT 4
28534: LESS
28535: AND
28536: IFFALSE 28555
28538: GO 28540
28540: DISABLE
// begin Difficulty := Difficulty + 1 ;
28541: LD_ADDR_OWVAR 67
28545: PUSH
28546: LD_OWVAR 67
28550: PUSH
28551: LD_INT 1
28553: PLUS
28554: ST_TO_ADDR
// end ;
28555: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
28556: LD_EXP 29
28560: PUSH
28561: LD_EXP 48
28565: AND
28566: IFFALSE 28669
28568: GO 28570
28570: DISABLE
28571: LD_INT 0
28573: PPUSH
// begin for i := 1 to 5 do
28574: LD_ADDR_VAR 0 1
28578: PUSH
28579: DOUBLE
28580: LD_INT 1
28582: DEC
28583: ST_TO_ADDR
28584: LD_INT 5
28586: PUSH
28587: FOR_TO
28588: IFFALSE 28667
// begin uc_nation := nation_nature ;
28590: LD_ADDR_OWVAR 21
28594: PUSH
28595: LD_INT 0
28597: ST_TO_ADDR
// uc_side := 0 ;
28598: LD_ADDR_OWVAR 20
28602: PUSH
28603: LD_INT 0
28605: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
28606: LD_ADDR_OWVAR 29
28610: PUSH
28611: LD_INT 12
28613: PUSH
28614: LD_INT 12
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: ST_TO_ADDR
// hc_agressivity := 20 ;
28621: LD_ADDR_OWVAR 35
28625: PUSH
28626: LD_INT 20
28628: ST_TO_ADDR
// hc_class := class_tiger ;
28629: LD_ADDR_OWVAR 28
28633: PUSH
28634: LD_INT 14
28636: ST_TO_ADDR
// hc_gallery :=  ;
28637: LD_ADDR_OWVAR 33
28641: PUSH
28642: LD_STRING 
28644: ST_TO_ADDR
// hc_name :=  ;
28645: LD_ADDR_OWVAR 26
28649: PUSH
28650: LD_STRING 
28652: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
28653: CALL_OW 44
28657: PPUSH
28658: LD_INT 0
28660: PPUSH
28661: CALL_OW 51
// end ;
28665: GO 28587
28667: POP
28668: POP
// end ;
28669: PPOPN 1
28671: END
// every 0 0$1 trigger StreamModeActive and sBomb do
28672: LD_EXP 29
28676: PUSH
28677: LD_EXP 49
28681: AND
28682: IFFALSE 28691
28684: GO 28686
28686: DISABLE
// StreamSibBomb ;
28687: CALL 28692 0 0
28691: END
// export function StreamSibBomb ; var i , x , y ; begin
28692: LD_INT 0
28694: PPUSH
28695: PPUSH
28696: PPUSH
28697: PPUSH
// result := false ;
28698: LD_ADDR_VAR 0 1
28702: PUSH
28703: LD_INT 0
28705: ST_TO_ADDR
// for i := 1 to 16 do
28706: LD_ADDR_VAR 0 2
28710: PUSH
28711: DOUBLE
28712: LD_INT 1
28714: DEC
28715: ST_TO_ADDR
28716: LD_INT 16
28718: PUSH
28719: FOR_TO
28720: IFFALSE 28919
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
28722: LD_ADDR_VAR 0 3
28726: PUSH
28727: LD_INT 10
28729: PUSH
28730: LD_INT 20
28732: PUSH
28733: LD_INT 30
28735: PUSH
28736: LD_INT 40
28738: PUSH
28739: LD_INT 50
28741: PUSH
28742: LD_INT 60
28744: PUSH
28745: LD_INT 70
28747: PUSH
28748: LD_INT 80
28750: PUSH
28751: LD_INT 90
28753: PUSH
28754: LD_INT 100
28756: PUSH
28757: LD_INT 110
28759: PUSH
28760: LD_INT 120
28762: PUSH
28763: LD_INT 130
28765: PUSH
28766: LD_INT 140
28768: PUSH
28769: LD_INT 150
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 1
28791: PPUSH
28792: LD_INT 15
28794: PPUSH
28795: CALL_OW 12
28799: ARRAY
28800: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
28801: LD_ADDR_VAR 0 4
28805: PUSH
28806: LD_INT 10
28808: PUSH
28809: LD_INT 20
28811: PUSH
28812: LD_INT 30
28814: PUSH
28815: LD_INT 40
28817: PUSH
28818: LD_INT 50
28820: PUSH
28821: LD_INT 60
28823: PUSH
28824: LD_INT 70
28826: PUSH
28827: LD_INT 80
28829: PUSH
28830: LD_INT 90
28832: PUSH
28833: LD_INT 100
28835: PUSH
28836: LD_INT 110
28838: PUSH
28839: LD_INT 120
28841: PUSH
28842: LD_INT 130
28844: PUSH
28845: LD_INT 140
28847: PUSH
28848: LD_INT 150
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 1
28870: PPUSH
28871: LD_INT 15
28873: PPUSH
28874: CALL_OW 12
28878: ARRAY
28879: ST_TO_ADDR
// if ValidHex ( x , y ) then
28880: LD_VAR 0 3
28884: PPUSH
28885: LD_VAR 0 4
28889: PPUSH
28890: CALL_OW 488
28894: IFFALSE 28917
// begin result := [ x , y ] ;
28896: LD_ADDR_VAR 0 1
28900: PUSH
28901: LD_VAR 0 3
28905: PUSH
28906: LD_VAR 0 4
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: ST_TO_ADDR
// break ;
28915: GO 28919
// end ; end ;
28917: GO 28719
28919: POP
28920: POP
// if result then
28921: LD_VAR 0 1
28925: IFFALSE 28985
// begin ToLua ( playSibBomb() ) ;
28927: LD_STRING playSibBomb()
28929: PPUSH
28930: CALL_OW 559
// wait ( 0 0$14 ) ;
28934: LD_INT 490
28936: PPUSH
28937: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
28941: LD_VAR 0 1
28945: PUSH
28946: LD_INT 1
28948: ARRAY
28949: PPUSH
28950: LD_VAR 0 1
28954: PUSH
28955: LD_INT 2
28957: ARRAY
28958: PPUSH
28959: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
28963: LD_VAR 0 1
28967: PUSH
28968: LD_INT 1
28970: ARRAY
28971: PPUSH
28972: LD_VAR 0 1
28976: PUSH
28977: LD_INT 2
28979: ARRAY
28980: PPUSH
28981: CALL_OW 429
// end ; end ;
28985: LD_VAR 0 1
28989: RET
// every 0 0$1 trigger StreamModeActive and sReset do
28990: LD_EXP 29
28994: PUSH
28995: LD_EXP 51
28999: AND
29000: IFFALSE 29012
29002: GO 29004
29004: DISABLE
// YouLost (  ) ;
29005: LD_STRING 
29007: PPUSH
29008: CALL_OW 104
29012: END
// every 0 0$1 trigger StreamModeActive and sFog do
29013: LD_EXP 29
29017: PUSH
29018: LD_EXP 50
29022: AND
29023: IFFALSE 29037
29025: GO 29027
29027: DISABLE
// FogOff ( your_side ) ;
29028: LD_OWVAR 2
29032: PPUSH
29033: CALL_OW 344
29037: END
// every 0 0$1 trigger StreamModeActive and sSun do
29038: LD_EXP 29
29042: PUSH
29043: LD_EXP 52
29047: AND
29048: IFFALSE 29076
29050: GO 29052
29052: DISABLE
// begin solar_recharge_percent := 0 ;
29053: LD_ADDR_OWVAR 79
29057: PUSH
29058: LD_INT 0
29060: ST_TO_ADDR
// wait ( 5 5$00 ) ;
29061: LD_INT 10500
29063: PPUSH
29064: CALL_OW 67
// solar_recharge_percent := 100 ;
29068: LD_ADDR_OWVAR 79
29072: PUSH
29073: LD_INT 100
29075: ST_TO_ADDR
// end ;
29076: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
29077: LD_EXP 29
29081: PUSH
29082: LD_EXP 53
29086: AND
29087: IFFALSE 29326
29089: GO 29091
29091: DISABLE
29092: LD_INT 0
29094: PPUSH
29095: PPUSH
29096: PPUSH
// begin tmp := [ ] ;
29097: LD_ADDR_VAR 0 3
29101: PUSH
29102: EMPTY
29103: ST_TO_ADDR
// for i := 1 to 6 do
29104: LD_ADDR_VAR 0 1
29108: PUSH
29109: DOUBLE
29110: LD_INT 1
29112: DEC
29113: ST_TO_ADDR
29114: LD_INT 6
29116: PUSH
29117: FOR_TO
29118: IFFALSE 29223
// begin uc_nation := nation_nature ;
29120: LD_ADDR_OWVAR 21
29124: PUSH
29125: LD_INT 0
29127: ST_TO_ADDR
// uc_side := 0 ;
29128: LD_ADDR_OWVAR 20
29132: PUSH
29133: LD_INT 0
29135: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
29136: LD_ADDR_OWVAR 29
29140: PUSH
29141: LD_INT 12
29143: PUSH
29144: LD_INT 12
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: ST_TO_ADDR
// hc_agressivity := 20 ;
29151: LD_ADDR_OWVAR 35
29155: PUSH
29156: LD_INT 20
29158: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
29159: LD_ADDR_OWVAR 28
29163: PUSH
29164: LD_INT 17
29166: ST_TO_ADDR
// hc_gallery :=  ;
29167: LD_ADDR_OWVAR 33
29171: PUSH
29172: LD_STRING 
29174: ST_TO_ADDR
// hc_name :=  ;
29175: LD_ADDR_OWVAR 26
29179: PUSH
29180: LD_STRING 
29182: ST_TO_ADDR
// un := CreateHuman ;
29183: LD_ADDR_VAR 0 2
29187: PUSH
29188: CALL_OW 44
29192: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
29193: LD_VAR 0 2
29197: PPUSH
29198: LD_INT 1
29200: PPUSH
29201: CALL_OW 51
// tmp := tmp ^ un ;
29205: LD_ADDR_VAR 0 3
29209: PUSH
29210: LD_VAR 0 3
29214: PUSH
29215: LD_VAR 0 2
29219: ADD
29220: ST_TO_ADDR
// end ;
29221: GO 29117
29223: POP
29224: POP
// repeat wait ( 0 0$1 ) ;
29225: LD_INT 35
29227: PPUSH
29228: CALL_OW 67
// for un in tmp do
29232: LD_ADDR_VAR 0 2
29236: PUSH
29237: LD_VAR 0 3
29241: PUSH
29242: FOR_IN
29243: IFFALSE 29317
// begin if IsDead ( un ) then
29245: LD_VAR 0 2
29249: PPUSH
29250: CALL_OW 301
29254: IFFALSE 29274
// begin tmp := tmp diff un ;
29256: LD_ADDR_VAR 0 3
29260: PUSH
29261: LD_VAR 0 3
29265: PUSH
29266: LD_VAR 0 2
29270: DIFF
29271: ST_TO_ADDR
// continue ;
29272: GO 29242
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
29274: LD_VAR 0 2
29278: PPUSH
29279: LD_INT 3
29281: PUSH
29282: LD_INT 22
29284: PUSH
29285: LD_INT 0
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PPUSH
29296: CALL_OW 69
29300: PPUSH
29301: LD_VAR 0 2
29305: PPUSH
29306: CALL_OW 74
29310: PPUSH
29311: CALL_OW 115
// end ;
29315: GO 29242
29317: POP
29318: POP
// until not tmp ;
29319: LD_VAR 0 3
29323: NOT
29324: IFFALSE 29225
// end ;
29326: PPOPN 3
29328: END
// every 0 0$1 trigger StreamModeActive and sTroll do
29329: LD_EXP 29
29333: PUSH
29334: LD_EXP 54
29338: AND
29339: IFFALSE 29393
29341: GO 29343
29343: DISABLE
// begin ToLua ( displayTroll(); ) ;
29344: LD_STRING displayTroll();
29346: PPUSH
29347: CALL_OW 559
// wait ( 3 3$00 ) ;
29351: LD_INT 6300
29353: PPUSH
29354: CALL_OW 67
// ToLua ( hideTroll(); ) ;
29358: LD_STRING hideTroll();
29360: PPUSH
29361: CALL_OW 559
// wait ( 1 1$00 ) ;
29365: LD_INT 2100
29367: PPUSH
29368: CALL_OW 67
// ToLua ( displayTroll(); ) ;
29372: LD_STRING displayTroll();
29374: PPUSH
29375: CALL_OW 559
// wait ( 1 1$00 ) ;
29379: LD_INT 2100
29381: PPUSH
29382: CALL_OW 67
// ToLua ( hideTroll(); ) ;
29386: LD_STRING hideTroll();
29388: PPUSH
29389: CALL_OW 559
// end ;
29393: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
29394: LD_EXP 29
29398: PUSH
29399: LD_EXP 55
29403: AND
29404: IFFALSE 29467
29406: GO 29408
29408: DISABLE
29409: LD_INT 0
29411: PPUSH
// begin p := 0 ;
29412: LD_ADDR_VAR 0 1
29416: PUSH
29417: LD_INT 0
29419: ST_TO_ADDR
// repeat game_speed := 1 ;
29420: LD_ADDR_OWVAR 65
29424: PUSH
29425: LD_INT 1
29427: ST_TO_ADDR
// wait ( 0 0$1 ) ;
29428: LD_INT 35
29430: PPUSH
29431: CALL_OW 67
// p := p + 1 ;
29435: LD_ADDR_VAR 0 1
29439: PUSH
29440: LD_VAR 0 1
29444: PUSH
29445: LD_INT 1
29447: PLUS
29448: ST_TO_ADDR
// until p >= 60 ;
29449: LD_VAR 0 1
29453: PUSH
29454: LD_INT 60
29456: GREATEREQUAL
29457: IFFALSE 29420
// game_speed := 4 ;
29459: LD_ADDR_OWVAR 65
29463: PUSH
29464: LD_INT 4
29466: ST_TO_ADDR
// end ;
29467: PPOPN 1
29469: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
29470: LD_EXP 29
29474: PUSH
29475: LD_EXP 56
29479: AND
29480: IFFALSE 29626
29482: GO 29484
29484: DISABLE
29485: LD_INT 0
29487: PPUSH
29488: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29489: LD_ADDR_VAR 0 1
29493: PUSH
29494: LD_INT 22
29496: PUSH
29497: LD_OWVAR 2
29501: PUSH
29502: EMPTY
29503: LIST
29504: LIST
29505: PUSH
29506: LD_INT 2
29508: PUSH
29509: LD_INT 30
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 30
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: LIST
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PPUSH
29538: CALL_OW 69
29542: ST_TO_ADDR
// if not depot then
29543: LD_VAR 0 1
29547: NOT
29548: IFFALSE 29552
// exit ;
29550: GO 29626
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
29552: LD_ADDR_VAR 0 2
29556: PUSH
29557: LD_VAR 0 1
29561: PUSH
29562: LD_INT 1
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 12
29574: ARRAY
29575: PPUSH
29576: CALL_OW 274
29580: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
29581: LD_VAR 0 2
29585: PPUSH
29586: LD_INT 1
29588: PPUSH
29589: LD_INT 0
29591: PPUSH
29592: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
29596: LD_VAR 0 2
29600: PPUSH
29601: LD_INT 2
29603: PPUSH
29604: LD_INT 0
29606: PPUSH
29607: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
29611: LD_VAR 0 2
29615: PPUSH
29616: LD_INT 3
29618: PPUSH
29619: LD_INT 0
29621: PPUSH
29622: CALL_OW 277
// end ;
29626: PPOPN 2
29628: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
29629: LD_EXP 29
29633: PUSH
29634: LD_EXP 57
29638: AND
29639: IFFALSE 29736
29641: GO 29643
29643: DISABLE
29644: LD_INT 0
29646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29647: LD_ADDR_VAR 0 1
29651: PUSH
29652: LD_INT 22
29654: PUSH
29655: LD_OWVAR 2
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 21
29666: PUSH
29667: LD_INT 1
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 3
29676: PUSH
29677: LD_INT 23
29679: PUSH
29680: LD_INT 0
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: LIST
29695: PPUSH
29696: CALL_OW 69
29700: ST_TO_ADDR
// if not tmp then
29701: LD_VAR 0 1
29705: NOT
29706: IFFALSE 29710
// exit ;
29708: GO 29736
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
29710: LD_VAR 0 1
29714: PUSH
29715: LD_INT 1
29717: PPUSH
29718: LD_VAR 0 1
29722: PPUSH
29723: CALL_OW 12
29727: ARRAY
29728: PPUSH
29729: LD_INT 200
29731: PPUSH
29732: CALL_OW 234
// end ;
29736: PPOPN 1
29738: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
29739: LD_EXP 29
29743: PUSH
29744: LD_EXP 58
29748: AND
29749: IFFALSE 29828
29751: GO 29753
29753: DISABLE
29754: LD_INT 0
29756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
29757: LD_ADDR_VAR 0 1
29761: PUSH
29762: LD_INT 22
29764: PUSH
29765: LD_OWVAR 2
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 21
29776: PUSH
29777: LD_INT 2
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PPUSH
29788: CALL_OW 69
29792: ST_TO_ADDR
// if not tmp then
29793: LD_VAR 0 1
29797: NOT
29798: IFFALSE 29802
// exit ;
29800: GO 29828
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
29802: LD_VAR 0 1
29806: PUSH
29807: LD_INT 1
29809: PPUSH
29810: LD_VAR 0 1
29814: PPUSH
29815: CALL_OW 12
29819: ARRAY
29820: PPUSH
29821: LD_INT 60
29823: PPUSH
29824: CALL_OW 234
// end ;
29828: PPOPN 1
29830: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
29831: LD_EXP 29
29835: PUSH
29836: LD_EXP 59
29840: AND
29841: IFFALSE 29940
29843: GO 29845
29845: DISABLE
29846: LD_INT 0
29848: PPUSH
29849: PPUSH
// begin enable ;
29850: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
29851: LD_ADDR_VAR 0 1
29855: PUSH
29856: LD_INT 22
29858: PUSH
29859: LD_OWVAR 2
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 61
29870: PUSH
29871: EMPTY
29872: LIST
29873: PUSH
29874: LD_INT 33
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: LIST
29888: PPUSH
29889: CALL_OW 69
29893: ST_TO_ADDR
// if not tmp then
29894: LD_VAR 0 1
29898: NOT
29899: IFFALSE 29903
// exit ;
29901: GO 29940
// for i in tmp do
29903: LD_ADDR_VAR 0 2
29907: PUSH
29908: LD_VAR 0 1
29912: PUSH
29913: FOR_IN
29914: IFFALSE 29938
// if IsControledBy ( i ) then
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL_OW 312
29925: IFFALSE 29936
// ComUnlink ( i ) ;
29927: LD_VAR 0 2
29931: PPUSH
29932: CALL_OW 136
29936: GO 29913
29938: POP
29939: POP
// end ;
29940: PPOPN 2
29942: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
29943: LD_EXP 29
29947: PUSH
29948: LD_EXP 60
29952: AND
29953: IFFALSE 30093
29955: GO 29957
29957: DISABLE
29958: LD_INT 0
29960: PPUSH
29961: PPUSH
// begin ToLua ( displayPowell(); ) ;
29962: LD_STRING displayPowell();
29964: PPUSH
29965: CALL_OW 559
// uc_side := 0 ;
29969: LD_ADDR_OWVAR 20
29973: PUSH
29974: LD_INT 0
29976: ST_TO_ADDR
// uc_nation := 2 ;
29977: LD_ADDR_OWVAR 21
29981: PUSH
29982: LD_INT 2
29984: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
29985: LD_ADDR_OWVAR 37
29989: PUSH
29990: LD_INT 14
29992: ST_TO_ADDR
// vc_engine := engine_siberite ;
29993: LD_ADDR_OWVAR 39
29997: PUSH
29998: LD_INT 3
30000: ST_TO_ADDR
// vc_control := control_apeman ;
30001: LD_ADDR_OWVAR 38
30005: PUSH
30006: LD_INT 5
30008: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
30009: LD_ADDR_OWVAR 40
30013: PUSH
30014: LD_INT 29
30016: ST_TO_ADDR
// un := CreateVehicle ;
30017: LD_ADDR_VAR 0 2
30021: PUSH
30022: CALL_OW 45
30026: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30027: LD_VAR 0 2
30031: PPUSH
30032: LD_INT 1
30034: PPUSH
30035: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
30039: LD_INT 35
30041: PPUSH
30042: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
30046: LD_VAR 0 2
30050: PPUSH
30051: LD_INT 22
30053: PUSH
30054: LD_OWVAR 2
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PPUSH
30063: CALL_OW 69
30067: PPUSH
30068: LD_VAR 0 2
30072: PPUSH
30073: CALL_OW 74
30077: PPUSH
30078: CALL_OW 115
// until IsDead ( un ) ;
30082: LD_VAR 0 2
30086: PPUSH
30087: CALL_OW 301
30091: IFFALSE 30039
// end ;
30093: PPOPN 2
30095: END
// every 0 0$1 trigger StreamModeActive and sStu do
30096: LD_EXP 29
30100: PUSH
30101: LD_EXP 68
30105: AND
30106: IFFALSE 30122
30108: GO 30110
30110: DISABLE
// begin ToLua ( displayStucuk(); ) ;
30111: LD_STRING displayStucuk();
30113: PPUSH
30114: CALL_OW 559
// ResetFog ;
30118: CALL_OW 335
// end ;
30122: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
30123: LD_EXP 29
30127: PUSH
30128: LD_EXP 61
30132: AND
30133: IFFALSE 30274
30135: GO 30137
30137: DISABLE
30138: LD_INT 0
30140: PPUSH
30141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
30142: LD_ADDR_VAR 0 2
30146: PUSH
30147: LD_INT 22
30149: PUSH
30150: LD_OWVAR 2
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 21
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PPUSH
30173: CALL_OW 69
30177: ST_TO_ADDR
// if not tmp then
30178: LD_VAR 0 2
30182: NOT
30183: IFFALSE 30187
// exit ;
30185: GO 30274
// un := tmp [ rand ( 1 , tmp ) ] ;
30187: LD_ADDR_VAR 0 1
30191: PUSH
30192: LD_VAR 0 2
30196: PUSH
30197: LD_INT 1
30199: PPUSH
30200: LD_VAR 0 2
30204: PPUSH
30205: CALL_OW 12
30209: ARRAY
30210: ST_TO_ADDR
// SetSide ( un , 0 ) ;
30211: LD_VAR 0 1
30215: PPUSH
30216: LD_INT 0
30218: PPUSH
30219: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
30223: LD_VAR 0 1
30227: PPUSH
30228: LD_OWVAR 3
30232: PUSH
30233: LD_VAR 0 1
30237: DIFF
30238: PPUSH
30239: LD_VAR 0 1
30243: PPUSH
30244: CALL_OW 74
30248: PPUSH
30249: CALL_OW 115
// wait ( 0 0$20 ) ;
30253: LD_INT 700
30255: PPUSH
30256: CALL_OW 67
// SetSide ( un , your_side ) ;
30260: LD_VAR 0 1
30264: PPUSH
30265: LD_OWVAR 2
30269: PPUSH
30270: CALL_OW 235
// end ;
30274: PPOPN 2
30276: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
30277: LD_EXP 29
30281: PUSH
30282: LD_EXP 62
30286: AND
30287: IFFALSE 30393
30289: GO 30291
30291: DISABLE
30292: LD_INT 0
30294: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
30295: LD_ADDR_VAR 0 1
30299: PUSH
30300: LD_INT 22
30302: PUSH
30303: LD_OWVAR 2
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 2
30314: PUSH
30315: LD_INT 30
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 30
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: LIST
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PPUSH
30344: CALL_OW 69
30348: ST_TO_ADDR
// if not depot then
30349: LD_VAR 0 1
30353: NOT
30354: IFFALSE 30358
// exit ;
30356: GO 30393
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
30358: LD_VAR 0 1
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PPUSH
30367: CALL_OW 250
30371: PPUSH
30372: LD_VAR 0 1
30376: PUSH
30377: LD_INT 1
30379: ARRAY
30380: PPUSH
30381: CALL_OW 251
30385: PPUSH
30386: LD_INT 70
30388: PPUSH
30389: CALL_OW 495
// end ;
30393: PPOPN 1
30395: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
30396: LD_EXP 29
30400: PUSH
30401: LD_EXP 63
30405: AND
30406: IFFALSE 30617
30408: GO 30410
30410: DISABLE
30411: LD_INT 0
30413: PPUSH
30414: PPUSH
30415: PPUSH
30416: PPUSH
30417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
30418: LD_ADDR_VAR 0 5
30422: PUSH
30423: LD_INT 22
30425: PUSH
30426: LD_OWVAR 2
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 21
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PPUSH
30449: CALL_OW 69
30453: ST_TO_ADDR
// if not tmp then
30454: LD_VAR 0 5
30458: NOT
30459: IFFALSE 30463
// exit ;
30461: GO 30617
// for i in tmp do
30463: LD_ADDR_VAR 0 1
30467: PUSH
30468: LD_VAR 0 5
30472: PUSH
30473: FOR_IN
30474: IFFALSE 30615
// begin d := rand ( 0 , 5 ) ;
30476: LD_ADDR_VAR 0 4
30480: PUSH
30481: LD_INT 0
30483: PPUSH
30484: LD_INT 5
30486: PPUSH
30487: CALL_OW 12
30491: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
30492: LD_ADDR_VAR 0 2
30496: PUSH
30497: LD_VAR 0 1
30501: PPUSH
30502: CALL_OW 250
30506: PPUSH
30507: LD_VAR 0 4
30511: PPUSH
30512: LD_INT 3
30514: PPUSH
30515: LD_INT 12
30517: PPUSH
30518: CALL_OW 12
30522: PPUSH
30523: CALL_OW 272
30527: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
30528: LD_ADDR_VAR 0 3
30532: PUSH
30533: LD_VAR 0 1
30537: PPUSH
30538: CALL_OW 251
30542: PPUSH
30543: LD_VAR 0 4
30547: PPUSH
30548: LD_INT 3
30550: PPUSH
30551: LD_INT 12
30553: PPUSH
30554: CALL_OW 12
30558: PPUSH
30559: CALL_OW 273
30563: ST_TO_ADDR
// if ValidHex ( x , y ) then
30564: LD_VAR 0 2
30568: PPUSH
30569: LD_VAR 0 3
30573: PPUSH
30574: CALL_OW 488
30578: IFFALSE 30613
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
30580: LD_VAR 0 1
30584: PPUSH
30585: LD_VAR 0 2
30589: PPUSH
30590: LD_VAR 0 3
30594: PPUSH
30595: LD_INT 3
30597: PPUSH
30598: LD_INT 6
30600: PPUSH
30601: CALL_OW 12
30605: PPUSH
30606: LD_INT 1
30608: PPUSH
30609: CALL_OW 483
// end ;
30613: GO 30473
30615: POP
30616: POP
// end ;
30617: PPOPN 5
30619: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
30620: LD_EXP 29
30624: PUSH
30625: LD_EXP 64
30629: AND
30630: IFFALSE 30724
30632: GO 30634
30634: DISABLE
30635: LD_INT 0
30637: PPUSH
30638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
30639: LD_ADDR_VAR 0 2
30643: PUSH
30644: LD_INT 22
30646: PUSH
30647: LD_OWVAR 2
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 32
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 21
30668: PUSH
30669: LD_INT 2
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: PPUSH
30681: CALL_OW 69
30685: ST_TO_ADDR
// if not tmp then
30686: LD_VAR 0 2
30690: NOT
30691: IFFALSE 30695
// exit ;
30693: GO 30724
// for i in tmp do
30695: LD_ADDR_VAR 0 1
30699: PUSH
30700: LD_VAR 0 2
30704: PUSH
30705: FOR_IN
30706: IFFALSE 30722
// SetFuel ( i , 0 ) ;
30708: LD_VAR 0 1
30712: PPUSH
30713: LD_INT 0
30715: PPUSH
30716: CALL_OW 240
30720: GO 30705
30722: POP
30723: POP
// end ;
30724: PPOPN 2
30726: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
30727: LD_EXP 29
30731: PUSH
30732: LD_EXP 65
30736: AND
30737: IFFALSE 30803
30739: GO 30741
30741: DISABLE
30742: LD_INT 0
30744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30745: LD_ADDR_VAR 0 1
30749: PUSH
30750: LD_INT 22
30752: PUSH
30753: LD_OWVAR 2
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 30
30764: PUSH
30765: LD_INT 29
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PPUSH
30776: CALL_OW 69
30780: ST_TO_ADDR
// if not tmp then
30781: LD_VAR 0 1
30785: NOT
30786: IFFALSE 30790
// exit ;
30788: GO 30803
// DestroyUnit ( tmp [ 1 ] ) ;
30790: LD_VAR 0 1
30794: PUSH
30795: LD_INT 1
30797: ARRAY
30798: PPUSH
30799: CALL_OW 65
// end ;
30803: PPOPN 1
30805: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
30806: LD_EXP 29
30810: PUSH
30811: LD_EXP 67
30815: AND
30816: IFFALSE 30945
30818: GO 30820
30820: DISABLE
30821: LD_INT 0
30823: PPUSH
// begin uc_side := 0 ;
30824: LD_ADDR_OWVAR 20
30828: PUSH
30829: LD_INT 0
30831: ST_TO_ADDR
// uc_nation := nation_arabian ;
30832: LD_ADDR_OWVAR 21
30836: PUSH
30837: LD_INT 2
30839: ST_TO_ADDR
// hc_gallery :=  ;
30840: LD_ADDR_OWVAR 33
30844: PUSH
30845: LD_STRING 
30847: ST_TO_ADDR
// hc_name :=  ;
30848: LD_ADDR_OWVAR 26
30852: PUSH
30853: LD_STRING 
30855: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
30856: LD_INT 1
30858: PPUSH
30859: LD_INT 11
30861: PPUSH
30862: LD_INT 10
30864: PPUSH
30865: CALL_OW 380
// un := CreateHuman ;
30869: LD_ADDR_VAR 0 1
30873: PUSH
30874: CALL_OW 44
30878: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30879: LD_VAR 0 1
30883: PPUSH
30884: LD_INT 1
30886: PPUSH
30887: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
30891: LD_INT 35
30893: PPUSH
30894: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
30898: LD_VAR 0 1
30902: PPUSH
30903: LD_INT 22
30905: PUSH
30906: LD_OWVAR 2
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PPUSH
30915: CALL_OW 69
30919: PPUSH
30920: LD_VAR 0 1
30924: PPUSH
30925: CALL_OW 74
30929: PPUSH
30930: CALL_OW 115
// until IsDead ( un ) ;
30934: LD_VAR 0 1
30938: PPUSH
30939: CALL_OW 301
30943: IFFALSE 30891
// end ;
30945: PPOPN 1
30947: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
30948: LD_EXP 29
30952: PUSH
30953: LD_EXP 69
30957: AND
30958: IFFALSE 30970
30960: GO 30962
30962: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
30963: LD_STRING earthquake(getX(game), 0, 32)
30965: PPUSH
30966: CALL_OW 559
30970: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
30971: LD_EXP 29
30975: PUSH
30976: LD_EXP 70
30980: AND
30981: IFFALSE 31072
30983: GO 30985
30985: DISABLE
30986: LD_INT 0
30988: PPUSH
// begin enable ;
30989: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
30990: LD_ADDR_VAR 0 1
30994: PUSH
30995: LD_INT 22
30997: PUSH
30998: LD_OWVAR 2
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 21
31009: PUSH
31010: LD_INT 2
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 33
31019: PUSH
31020: LD_INT 3
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: LIST
31031: PPUSH
31032: CALL_OW 69
31036: ST_TO_ADDR
// if not tmp then
31037: LD_VAR 0 1
31041: NOT
31042: IFFALSE 31046
// exit ;
31044: GO 31072
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
31046: LD_VAR 0 1
31050: PUSH
31051: LD_INT 1
31053: PPUSH
31054: LD_VAR 0 1
31058: PPUSH
31059: CALL_OW 12
31063: ARRAY
31064: PPUSH
31065: LD_INT 1
31067: PPUSH
31068: CALL_OW 234
// end ;
31072: PPOPN 1
31074: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
31075: LD_EXP 29
31079: PUSH
31080: LD_EXP 71
31084: AND
31085: IFFALSE 31226
31087: GO 31089
31089: DISABLE
31090: LD_INT 0
31092: PPUSH
31093: PPUSH
31094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31095: LD_ADDR_VAR 0 3
31099: PUSH
31100: LD_INT 22
31102: PUSH
31103: LD_OWVAR 2
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 25
31114: PUSH
31115: LD_INT 1
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PPUSH
31126: CALL_OW 69
31130: ST_TO_ADDR
// if not tmp then
31131: LD_VAR 0 3
31135: NOT
31136: IFFALSE 31140
// exit ;
31138: GO 31226
// un := tmp [ rand ( 1 , tmp ) ] ;
31140: LD_ADDR_VAR 0 2
31144: PUSH
31145: LD_VAR 0 3
31149: PUSH
31150: LD_INT 1
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: CALL_OW 12
31162: ARRAY
31163: ST_TO_ADDR
// if Crawls ( un ) then
31164: LD_VAR 0 2
31168: PPUSH
31169: CALL_OW 318
31173: IFFALSE 31184
// ComWalk ( un ) ;
31175: LD_VAR 0 2
31179: PPUSH
31180: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
31184: LD_VAR 0 2
31188: PPUSH
31189: LD_INT 9
31191: PPUSH
31192: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
31196: LD_INT 28
31198: PPUSH
31199: LD_OWVAR 2
31203: PPUSH
31204: LD_INT 2
31206: PPUSH
31207: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
31211: LD_INT 29
31213: PPUSH
31214: LD_OWVAR 2
31218: PPUSH
31219: LD_INT 2
31221: PPUSH
31222: CALL_OW 322
// end ;
31226: PPOPN 3
31228: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
31229: LD_EXP 29
31233: PUSH
31234: LD_EXP 72
31238: AND
31239: IFFALSE 31350
31241: GO 31243
31243: DISABLE
31244: LD_INT 0
31246: PPUSH
31247: PPUSH
31248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31249: LD_ADDR_VAR 0 3
31253: PUSH
31254: LD_INT 22
31256: PUSH
31257: LD_OWVAR 2
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 25
31268: PUSH
31269: LD_INT 1
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PPUSH
31280: CALL_OW 69
31284: ST_TO_ADDR
// if not tmp then
31285: LD_VAR 0 3
31289: NOT
31290: IFFALSE 31294
// exit ;
31292: GO 31350
// un := tmp [ rand ( 1 , tmp ) ] ;
31294: LD_ADDR_VAR 0 2
31298: PUSH
31299: LD_VAR 0 3
31303: PUSH
31304: LD_INT 1
31306: PPUSH
31307: LD_VAR 0 3
31311: PPUSH
31312: CALL_OW 12
31316: ARRAY
31317: ST_TO_ADDR
// if Crawls ( un ) then
31318: LD_VAR 0 2
31322: PPUSH
31323: CALL_OW 318
31327: IFFALSE 31338
// ComWalk ( un ) ;
31329: LD_VAR 0 2
31333: PPUSH
31334: CALL_OW 138
// SetClass ( un , class_mortar ) ;
31338: LD_VAR 0 2
31342: PPUSH
31343: LD_INT 8
31345: PPUSH
31346: CALL_OW 336
// end ;
31350: PPOPN 3
31352: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
31353: LD_EXP 29
31357: PUSH
31358: LD_EXP 73
31362: AND
31363: IFFALSE 31507
31365: GO 31367
31367: DISABLE
31368: LD_INT 0
31370: PPUSH
31371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
31372: LD_ADDR_VAR 0 2
31376: PUSH
31377: LD_INT 22
31379: PUSH
31380: LD_OWVAR 2
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 21
31391: PUSH
31392: LD_INT 2
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: PUSH
31402: LD_INT 34
31404: PUSH
31405: LD_INT 12
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 34
31414: PUSH
31415: LD_INT 51
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 34
31424: PUSH
31425: LD_INT 32
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: LIST
31442: PPUSH
31443: CALL_OW 69
31447: ST_TO_ADDR
// if not tmp then
31448: LD_VAR 0 2
31452: NOT
31453: IFFALSE 31457
// exit ;
31455: GO 31507
// for i in tmp do
31457: LD_ADDR_VAR 0 1
31461: PUSH
31462: LD_VAR 0 2
31466: PUSH
31467: FOR_IN
31468: IFFALSE 31505
// if GetCargo ( i , mat_artifact ) = 0 then
31470: LD_VAR 0 1
31474: PPUSH
31475: LD_INT 4
31477: PPUSH
31478: CALL_OW 289
31482: PUSH
31483: LD_INT 0
31485: EQUAL
31486: IFFALSE 31503
// SetCargo ( i , mat_siberit , 100 ) ;
31488: LD_VAR 0 1
31492: PPUSH
31493: LD_INT 3
31495: PPUSH
31496: LD_INT 100
31498: PPUSH
31499: CALL_OW 290
31503: GO 31467
31505: POP
31506: POP
// end ;
31507: PPOPN 2
31509: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
31510: LD_EXP 29
31514: PUSH
31515: LD_EXP 74
31519: AND
31520: IFFALSE 31703
31522: GO 31524
31524: DISABLE
31525: LD_INT 0
31527: PPUSH
31528: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
31529: LD_ADDR_VAR 0 2
31533: PUSH
31534: LD_INT 22
31536: PUSH
31537: LD_OWVAR 2
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PPUSH
31546: CALL_OW 69
31550: ST_TO_ADDR
// if not tmp then
31551: LD_VAR 0 2
31555: NOT
31556: IFFALSE 31560
// exit ;
31558: GO 31703
// for i := 1 to 2 do
31560: LD_ADDR_VAR 0 1
31564: PUSH
31565: DOUBLE
31566: LD_INT 1
31568: DEC
31569: ST_TO_ADDR
31570: LD_INT 2
31572: PUSH
31573: FOR_TO
31574: IFFALSE 31701
// begin uc_side := your_side ;
31576: LD_ADDR_OWVAR 20
31580: PUSH
31581: LD_OWVAR 2
31585: ST_TO_ADDR
// uc_nation := nation_american ;
31586: LD_ADDR_OWVAR 21
31590: PUSH
31591: LD_INT 1
31593: ST_TO_ADDR
// vc_chassis := us_morphling ;
31594: LD_ADDR_OWVAR 37
31598: PUSH
31599: LD_INT 5
31601: ST_TO_ADDR
// vc_engine := engine_siberite ;
31602: LD_ADDR_OWVAR 39
31606: PUSH
31607: LD_INT 3
31609: ST_TO_ADDR
// vc_control := control_computer ;
31610: LD_ADDR_OWVAR 38
31614: PUSH
31615: LD_INT 3
31617: ST_TO_ADDR
// vc_weapon := us_double_laser ;
31618: LD_ADDR_OWVAR 40
31622: PUSH
31623: LD_INT 10
31625: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
31626: LD_VAR 0 2
31630: PUSH
31631: LD_INT 1
31633: ARRAY
31634: PPUSH
31635: CALL_OW 310
31639: NOT
31640: IFFALSE 31687
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
31642: CALL_OW 45
31646: PPUSH
31647: LD_VAR 0 2
31651: PUSH
31652: LD_INT 1
31654: ARRAY
31655: PPUSH
31656: CALL_OW 250
31660: PPUSH
31661: LD_VAR 0 2
31665: PUSH
31666: LD_INT 1
31668: ARRAY
31669: PPUSH
31670: CALL_OW 251
31674: PPUSH
31675: LD_INT 12
31677: PPUSH
31678: LD_INT 1
31680: PPUSH
31681: CALL_OW 50
31685: GO 31699
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31687: CALL_OW 45
31691: PPUSH
31692: LD_INT 1
31694: PPUSH
31695: CALL_OW 51
// end ;
31699: GO 31573
31701: POP
31702: POP
// end ;
31703: PPOPN 2
31705: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
31706: LD_EXP 29
31710: PUSH
31711: LD_EXP 75
31715: AND
31716: IFFALSE 31938
31718: GO 31720
31720: DISABLE
31721: LD_INT 0
31723: PPUSH
31724: PPUSH
31725: PPUSH
31726: PPUSH
31727: PPUSH
31728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
31729: LD_ADDR_VAR 0 6
31733: PUSH
31734: LD_INT 22
31736: PUSH
31737: LD_OWVAR 2
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 21
31748: PUSH
31749: LD_INT 1
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 3
31758: PUSH
31759: LD_INT 23
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: LIST
31777: PPUSH
31778: CALL_OW 69
31782: ST_TO_ADDR
// if not tmp then
31783: LD_VAR 0 6
31787: NOT
31788: IFFALSE 31792
// exit ;
31790: GO 31938
// s1 := rand ( 1 , 4 ) ;
31792: LD_ADDR_VAR 0 2
31796: PUSH
31797: LD_INT 1
31799: PPUSH
31800: LD_INT 4
31802: PPUSH
31803: CALL_OW 12
31807: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
31808: LD_ADDR_VAR 0 4
31812: PUSH
31813: LD_VAR 0 6
31817: PUSH
31818: LD_INT 1
31820: ARRAY
31821: PPUSH
31822: LD_VAR 0 2
31826: PPUSH
31827: CALL_OW 259
31831: ST_TO_ADDR
// if s1 = 1 then
31832: LD_VAR 0 2
31836: PUSH
31837: LD_INT 1
31839: EQUAL
31840: IFFALSE 31860
// s2 := rand ( 2 , 4 ) else
31842: LD_ADDR_VAR 0 3
31846: PUSH
31847: LD_INT 2
31849: PPUSH
31850: LD_INT 4
31852: PPUSH
31853: CALL_OW 12
31857: ST_TO_ADDR
31858: GO 31868
// s2 := 1 ;
31860: LD_ADDR_VAR 0 3
31864: PUSH
31865: LD_INT 1
31867: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
31868: LD_ADDR_VAR 0 5
31872: PUSH
31873: LD_VAR 0 6
31877: PUSH
31878: LD_INT 1
31880: ARRAY
31881: PPUSH
31882: LD_VAR 0 3
31886: PPUSH
31887: CALL_OW 259
31891: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
31892: LD_VAR 0 6
31896: PUSH
31897: LD_INT 1
31899: ARRAY
31900: PPUSH
31901: LD_VAR 0 2
31905: PPUSH
31906: LD_VAR 0 5
31910: PPUSH
31911: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
31915: LD_VAR 0 6
31919: PUSH
31920: LD_INT 1
31922: ARRAY
31923: PPUSH
31924: LD_VAR 0 3
31928: PPUSH
31929: LD_VAR 0 4
31933: PPUSH
31934: CALL_OW 237
// end ;
31938: PPOPN 6
31940: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
31941: LD_EXP 29
31945: PUSH
31946: LD_EXP 76
31950: AND
31951: IFFALSE 32030
31953: GO 31955
31955: DISABLE
31956: LD_INT 0
31958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
31959: LD_ADDR_VAR 0 1
31963: PUSH
31964: LD_INT 22
31966: PUSH
31967: LD_OWVAR 2
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 30
31978: PUSH
31979: LD_INT 3
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PPUSH
31990: CALL_OW 69
31994: ST_TO_ADDR
// if not tmp then
31995: LD_VAR 0 1
31999: NOT
32000: IFFALSE 32004
// exit ;
32002: GO 32030
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
32004: LD_VAR 0 1
32008: PUSH
32009: LD_INT 1
32011: PPUSH
32012: LD_VAR 0 1
32016: PPUSH
32017: CALL_OW 12
32021: ARRAY
32022: PPUSH
32023: LD_INT 1
32025: PPUSH
32026: CALL_OW 234
// end ;
32030: PPOPN 1
32032: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
32033: LD_EXP 29
32037: PUSH
32038: LD_EXP 77
32042: AND
32043: IFFALSE 32155
32045: GO 32047
32047: DISABLE
32048: LD_INT 0
32050: PPUSH
32051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
32052: LD_ADDR_VAR 0 2
32056: PUSH
32057: LD_INT 22
32059: PUSH
32060: LD_OWVAR 2
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 2
32071: PUSH
32072: LD_INT 30
32074: PUSH
32075: LD_INT 27
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: LD_INT 30
32084: PUSH
32085: LD_INT 26
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 30
32094: PUSH
32095: LD_INT 28
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PPUSH
32112: CALL_OW 69
32116: ST_TO_ADDR
// if not tmp then
32117: LD_VAR 0 2
32121: NOT
32122: IFFALSE 32126
// exit ;
32124: GO 32155
// for i in tmp do
32126: LD_ADDR_VAR 0 1
32130: PUSH
32131: LD_VAR 0 2
32135: PUSH
32136: FOR_IN
32137: IFFALSE 32153
// SetLives ( i , 1 ) ;
32139: LD_VAR 0 1
32143: PPUSH
32144: LD_INT 1
32146: PPUSH
32147: CALL_OW 234
32151: GO 32136
32153: POP
32154: POP
// end ;
32155: PPOPN 2
32157: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
32158: LD_EXP 29
32162: PUSH
32163: LD_EXP 78
32167: AND
32168: IFFALSE 32455
32170: GO 32172
32172: DISABLE
32173: LD_INT 0
32175: PPUSH
32176: PPUSH
32177: PPUSH
// begin i := rand ( 1 , 7 ) ;
32178: LD_ADDR_VAR 0 1
32182: PUSH
32183: LD_INT 1
32185: PPUSH
32186: LD_INT 7
32188: PPUSH
32189: CALL_OW 12
32193: ST_TO_ADDR
// case i of 1 :
32194: LD_VAR 0 1
32198: PUSH
32199: LD_INT 1
32201: DOUBLE
32202: EQUAL
32203: IFTRUE 32207
32205: GO 32217
32207: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
32208: LD_STRING earthquake(getX(game), 0, 32)
32210: PPUSH
32211: CALL_OW 559
32215: GO 32455
32217: LD_INT 2
32219: DOUBLE
32220: EQUAL
32221: IFTRUE 32225
32223: GO 32239
32225: POP
// begin ToLua ( displayStucuk(); ) ;
32226: LD_STRING displayStucuk();
32228: PPUSH
32229: CALL_OW 559
// ResetFog ;
32233: CALL_OW 335
// end ; 3 :
32237: GO 32455
32239: LD_INT 3
32241: DOUBLE
32242: EQUAL
32243: IFTRUE 32247
32245: GO 32351
32247: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
32248: LD_ADDR_VAR 0 2
32252: PUSH
32253: LD_INT 22
32255: PUSH
32256: LD_OWVAR 2
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 25
32267: PUSH
32268: LD_INT 1
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PPUSH
32279: CALL_OW 69
32283: ST_TO_ADDR
// if not tmp then
32284: LD_VAR 0 2
32288: NOT
32289: IFFALSE 32293
// exit ;
32291: GO 32455
// un := tmp [ rand ( 1 , tmp ) ] ;
32293: LD_ADDR_VAR 0 3
32297: PUSH
32298: LD_VAR 0 2
32302: PUSH
32303: LD_INT 1
32305: PPUSH
32306: LD_VAR 0 2
32310: PPUSH
32311: CALL_OW 12
32315: ARRAY
32316: ST_TO_ADDR
// if Crawls ( un ) then
32317: LD_VAR 0 3
32321: PPUSH
32322: CALL_OW 318
32326: IFFALSE 32337
// ComWalk ( un ) ;
32328: LD_VAR 0 3
32332: PPUSH
32333: CALL_OW 138
// SetClass ( un , class_mortar ) ;
32337: LD_VAR 0 3
32341: PPUSH
32342: LD_INT 8
32344: PPUSH
32345: CALL_OW 336
// end ; 4 :
32349: GO 32455
32351: LD_INT 4
32353: DOUBLE
32354: EQUAL
32355: IFTRUE 32359
32357: GO 32433
32359: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
32360: LD_ADDR_VAR 0 2
32364: PUSH
32365: LD_INT 22
32367: PUSH
32368: LD_OWVAR 2
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 30
32379: PUSH
32380: LD_INT 29
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PPUSH
32391: CALL_OW 69
32395: ST_TO_ADDR
// if not tmp then
32396: LD_VAR 0 2
32400: NOT
32401: IFFALSE 32405
// exit ;
32403: GO 32455
// CenterNowOnUnits ( tmp [ 1 ] ) ;
32405: LD_VAR 0 2
32409: PUSH
32410: LD_INT 1
32412: ARRAY
32413: PPUSH
32414: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
32418: LD_VAR 0 2
32422: PUSH
32423: LD_INT 1
32425: ARRAY
32426: PPUSH
32427: CALL_OW 65
// end ; 5 .. 7 :
32431: GO 32455
32433: LD_INT 5
32435: DOUBLE
32436: GREATEREQUAL
32437: IFFALSE 32445
32439: LD_INT 7
32441: DOUBLE
32442: LESSEQUAL
32443: IFTRUE 32447
32445: GO 32454
32447: POP
// StreamSibBomb ; end ;
32448: CALL 28692 0 0
32452: GO 32455
32454: POP
// end ;
32455: PPOPN 3
32457: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
32458: LD_EXP 29
32462: PUSH
32463: LD_EXP 79
32467: AND
32468: IFFALSE 32624
32470: GO 32472
32472: DISABLE
32473: LD_INT 0
32475: PPUSH
32476: PPUSH
32477: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
32478: LD_ADDR_VAR 0 2
32482: PUSH
32483: LD_INT 81
32485: PUSH
32486: LD_OWVAR 2
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: PUSH
32498: LD_INT 21
32500: PUSH
32501: LD_INT 1
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 21
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: LIST
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PPUSH
32527: CALL_OW 69
32531: ST_TO_ADDR
// if not tmp then
32532: LD_VAR 0 2
32536: NOT
32537: IFFALSE 32541
// exit ;
32539: GO 32624
// p := 0 ;
32541: LD_ADDR_VAR 0 3
32545: PUSH
32546: LD_INT 0
32548: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32549: LD_INT 35
32551: PPUSH
32552: CALL_OW 67
// p := p + 1 ;
32556: LD_ADDR_VAR 0 3
32560: PUSH
32561: LD_VAR 0 3
32565: PUSH
32566: LD_INT 1
32568: PLUS
32569: ST_TO_ADDR
// for i in tmp do
32570: LD_ADDR_VAR 0 1
32574: PUSH
32575: LD_VAR 0 2
32579: PUSH
32580: FOR_IN
32581: IFFALSE 32612
// if GetLives ( i ) < 1000 then
32583: LD_VAR 0 1
32587: PPUSH
32588: CALL_OW 256
32592: PUSH
32593: LD_INT 1000
32595: LESS
32596: IFFALSE 32610
// SetLives ( i , 1000 ) ;
32598: LD_VAR 0 1
32602: PPUSH
32603: LD_INT 1000
32605: PPUSH
32606: CALL_OW 234
32610: GO 32580
32612: POP
32613: POP
// until p > 20 ;
32614: LD_VAR 0 3
32618: PUSH
32619: LD_INT 20
32621: GREATER
32622: IFFALSE 32549
// end ;
32624: PPOPN 3
32626: END
// every 0 0$1 trigger StreamModeActive and sTime do
32627: LD_EXP 29
32631: PUSH
32632: LD_EXP 80
32636: AND
32637: IFFALSE 32672
32639: GO 32641
32641: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
32642: LD_INT 28
32644: PPUSH
32645: LD_OWVAR 2
32649: PPUSH
32650: LD_INT 2
32652: PPUSH
32653: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
32657: LD_INT 30
32659: PPUSH
32660: LD_OWVAR 2
32664: PPUSH
32665: LD_INT 2
32667: PPUSH
32668: CALL_OW 322
// end ;
32672: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
32673: LD_EXP 29
32677: PUSH
32678: LD_EXP 81
32682: AND
32683: IFFALSE 32804
32685: GO 32687
32687: DISABLE
32688: LD_INT 0
32690: PPUSH
32691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
32692: LD_ADDR_VAR 0 2
32696: PUSH
32697: LD_INT 22
32699: PUSH
32700: LD_OWVAR 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 21
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 3
32721: PUSH
32722: LD_INT 23
32724: PUSH
32725: LD_INT 0
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: LIST
32740: PPUSH
32741: CALL_OW 69
32745: ST_TO_ADDR
// if not tmp then
32746: LD_VAR 0 2
32750: NOT
32751: IFFALSE 32755
// exit ;
32753: GO 32804
// for i in tmp do
32755: LD_ADDR_VAR 0 1
32759: PUSH
32760: LD_VAR 0 2
32764: PUSH
32765: FOR_IN
32766: IFFALSE 32802
// begin if Crawls ( i ) then
32768: LD_VAR 0 1
32772: PPUSH
32773: CALL_OW 318
32777: IFFALSE 32788
// ComWalk ( i ) ;
32779: LD_VAR 0 1
32783: PPUSH
32784: CALL_OW 138
// SetClass ( i , 2 ) ;
32788: LD_VAR 0 1
32792: PPUSH
32793: LD_INT 2
32795: PPUSH
32796: CALL_OW 336
// end ;
32800: GO 32765
32802: POP
32803: POP
// end ;
32804: PPOPN 2
32806: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
32807: LD_EXP 29
32811: PUSH
32812: LD_EXP 82
32816: AND
32817: IFFALSE 33105
32819: GO 32821
32821: DISABLE
32822: LD_INT 0
32824: PPUSH
32825: PPUSH
32826: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
32827: LD_OWVAR 2
32831: PPUSH
32832: LD_INT 9
32834: PPUSH
32835: LD_INT 1
32837: PPUSH
32838: LD_INT 1
32840: PPUSH
32841: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
32845: LD_INT 9
32847: PPUSH
32848: LD_OWVAR 2
32852: PPUSH
32853: CALL_OW 343
// uc_side := 9 ;
32857: LD_ADDR_OWVAR 20
32861: PUSH
32862: LD_INT 9
32864: ST_TO_ADDR
// uc_nation := 2 ;
32865: LD_ADDR_OWVAR 21
32869: PUSH
32870: LD_INT 2
32872: ST_TO_ADDR
// hc_name := Dark Warrior ;
32873: LD_ADDR_OWVAR 26
32877: PUSH
32878: LD_STRING Dark Warrior
32880: ST_TO_ADDR
// hc_gallery :=  ;
32881: LD_ADDR_OWVAR 33
32885: PUSH
32886: LD_STRING 
32888: ST_TO_ADDR
// hc_noskilllimit := true ;
32889: LD_ADDR_OWVAR 76
32893: PUSH
32894: LD_INT 1
32896: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
32897: LD_ADDR_OWVAR 31
32901: PUSH
32902: LD_INT 30
32904: PUSH
32905: LD_INT 30
32907: PUSH
32908: LD_INT 30
32910: PUSH
32911: LD_INT 30
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: ST_TO_ADDR
// un := CreateHuman ;
32920: LD_ADDR_VAR 0 3
32924: PUSH
32925: CALL_OW 44
32929: ST_TO_ADDR
// hc_noskilllimit := false ;
32930: LD_ADDR_OWVAR 76
32934: PUSH
32935: LD_INT 0
32937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
32938: LD_VAR 0 3
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: CALL_OW 51
// ToLua ( playRanger() ) ;
32950: LD_STRING playRanger()
32952: PPUSH
32953: CALL_OW 559
// p := 0 ;
32957: LD_ADDR_VAR 0 2
32961: PUSH
32962: LD_INT 0
32964: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32965: LD_INT 35
32967: PPUSH
32968: CALL_OW 67
// p := p + 1 ;
32972: LD_ADDR_VAR 0 2
32976: PUSH
32977: LD_VAR 0 2
32981: PUSH
32982: LD_INT 1
32984: PLUS
32985: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
32986: LD_VAR 0 3
32990: PPUSH
32991: CALL_OW 256
32995: PUSH
32996: LD_INT 1000
32998: LESS
32999: IFFALSE 33013
// SetLives ( un , 1000 ) ;
33001: LD_VAR 0 3
33005: PPUSH
33006: LD_INT 1000
33008: PPUSH
33009: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
33013: LD_VAR 0 3
33017: PPUSH
33018: LD_INT 81
33020: PUSH
33021: LD_OWVAR 2
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 91
33032: PUSH
33033: LD_VAR 0 3
33037: PUSH
33038: LD_INT 30
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: LIST
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PPUSH
33050: CALL_OW 69
33054: PPUSH
33055: LD_VAR 0 3
33059: PPUSH
33060: CALL_OW 74
33064: PPUSH
33065: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
33069: LD_VAR 0 2
33073: PUSH
33074: LD_INT 80
33076: GREATER
33077: PUSH
33078: LD_VAR 0 3
33082: PPUSH
33083: CALL_OW 301
33087: OR
33088: IFFALSE 32965
// if un then
33090: LD_VAR 0 3
33094: IFFALSE 33105
// RemoveUnit ( un ) ;
33096: LD_VAR 0 3
33100: PPUSH
33101: CALL_OW 64
// end ;
33105: PPOPN 3
33107: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
33108: LD_EXP 83
33112: IFFALSE 33228
33114: GO 33116
33116: DISABLE
33117: LD_INT 0
33119: PPUSH
33120: PPUSH
33121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
33122: LD_ADDR_VAR 0 2
33126: PUSH
33127: LD_INT 81
33129: PUSH
33130: LD_OWVAR 2
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 21
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PPUSH
33153: CALL_OW 69
33157: ST_TO_ADDR
// ToLua ( playComputer() ) ;
33158: LD_STRING playComputer()
33160: PPUSH
33161: CALL_OW 559
// if not tmp then
33165: LD_VAR 0 2
33169: NOT
33170: IFFALSE 33174
// exit ;
33172: GO 33228
// for i in tmp do
33174: LD_ADDR_VAR 0 1
33178: PUSH
33179: LD_VAR 0 2
33183: PUSH
33184: FOR_IN
33185: IFFALSE 33226
// for j := 1 to 4 do
33187: LD_ADDR_VAR 0 3
33191: PUSH
33192: DOUBLE
33193: LD_INT 1
33195: DEC
33196: ST_TO_ADDR
33197: LD_INT 4
33199: PUSH
33200: FOR_TO
33201: IFFALSE 33222
// SetSkill ( i , j , 10 ) ;
33203: LD_VAR 0 1
33207: PPUSH
33208: LD_VAR 0 3
33212: PPUSH
33213: LD_INT 10
33215: PPUSH
33216: CALL_OW 237
33220: GO 33200
33222: POP
33223: POP
33224: GO 33184
33226: POP
33227: POP
// end ;
33228: PPOPN 3
33230: END
// every 0 0$1 trigger s30 do var i , tmp ;
33231: LD_EXP 84
33235: IFFALSE 33304
33237: GO 33239
33239: DISABLE
33240: LD_INT 0
33242: PPUSH
33243: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
33244: LD_ADDR_VAR 0 2
33248: PUSH
33249: LD_INT 22
33251: PUSH
33252: LD_OWVAR 2
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PPUSH
33261: CALL_OW 69
33265: ST_TO_ADDR
// if not tmp then
33266: LD_VAR 0 2
33270: NOT
33271: IFFALSE 33275
// exit ;
33273: GO 33304
// for i in tmp do
33275: LD_ADDR_VAR 0 1
33279: PUSH
33280: LD_VAR 0 2
33284: PUSH
33285: FOR_IN
33286: IFFALSE 33302
// SetLives ( i , 300 ) ;
33288: LD_VAR 0 1
33292: PPUSH
33293: LD_INT 300
33295: PPUSH
33296: CALL_OW 234
33300: GO 33285
33302: POP
33303: POP
// end ;
33304: PPOPN 2
33306: END
// every 0 0$1 trigger s60 do var i , tmp ;
33307: LD_EXP 85
33311: IFFALSE 33380
33313: GO 33315
33315: DISABLE
33316: LD_INT 0
33318: PPUSH
33319: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
33320: LD_ADDR_VAR 0 2
33324: PUSH
33325: LD_INT 22
33327: PUSH
33328: LD_OWVAR 2
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PPUSH
33337: CALL_OW 69
33341: ST_TO_ADDR
// if not tmp then
33342: LD_VAR 0 2
33346: NOT
33347: IFFALSE 33351
// exit ;
33349: GO 33380
// for i in tmp do
33351: LD_ADDR_VAR 0 1
33355: PUSH
33356: LD_VAR 0 2
33360: PUSH
33361: FOR_IN
33362: IFFALSE 33378
// SetLives ( i , 600 ) ;
33364: LD_VAR 0 1
33368: PPUSH
33369: LD_INT 600
33371: PPUSH
33372: CALL_OW 234
33376: GO 33361
33378: POP
33379: POP
// end ;
33380: PPOPN 2
33382: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
33383: LD_INT 0
33385: PPUSH
// case cmd of 301 :
33386: LD_VAR 0 1
33390: PUSH
33391: LD_INT 301
33393: DOUBLE
33394: EQUAL
33395: IFTRUE 33399
33397: GO 33431
33399: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
33400: LD_VAR 0 6
33404: PPUSH
33405: LD_VAR 0 7
33409: PPUSH
33410: LD_VAR 0 8
33414: PPUSH
33415: LD_VAR 0 4
33419: PPUSH
33420: LD_VAR 0 5
33424: PPUSH
33425: CALL 34632 0 5
33429: GO 33552
33431: LD_INT 302
33433: DOUBLE
33434: EQUAL
33435: IFTRUE 33439
33437: GO 33476
33439: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
33440: LD_VAR 0 6
33444: PPUSH
33445: LD_VAR 0 7
33449: PPUSH
33450: LD_VAR 0 8
33454: PPUSH
33455: LD_VAR 0 9
33459: PPUSH
33460: LD_VAR 0 4
33464: PPUSH
33465: LD_VAR 0 5
33469: PPUSH
33470: CALL 34723 0 6
33474: GO 33552
33476: LD_INT 303
33478: DOUBLE
33479: EQUAL
33480: IFTRUE 33484
33482: GO 33521
33484: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
33485: LD_VAR 0 6
33489: PPUSH
33490: LD_VAR 0 7
33494: PPUSH
33495: LD_VAR 0 8
33499: PPUSH
33500: LD_VAR 0 9
33504: PPUSH
33505: LD_VAR 0 4
33509: PPUSH
33510: LD_VAR 0 5
33514: PPUSH
33515: CALL 33557 0 6
33519: GO 33552
33521: LD_INT 304
33523: DOUBLE
33524: EQUAL
33525: IFTRUE 33529
33527: GO 33551
33529: POP
// hHackTeleport ( unit , x , y ) ; end ;
33530: LD_VAR 0 2
33534: PPUSH
33535: LD_VAR 0 4
33539: PPUSH
33540: LD_VAR 0 5
33544: PPUSH
33545: CALL 35316 0 3
33549: GO 33552
33551: POP
// end ;
33552: LD_VAR 0 12
33556: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
33557: LD_INT 0
33559: PPUSH
33560: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
33561: LD_VAR 0 1
33565: PUSH
33566: LD_INT 1
33568: LESS
33569: PUSH
33570: LD_VAR 0 1
33574: PUSH
33575: LD_INT 3
33577: GREATER
33578: OR
33579: PUSH
33580: LD_VAR 0 5
33584: PPUSH
33585: LD_VAR 0 6
33589: PPUSH
33590: CALL_OW 428
33594: OR
33595: IFFALSE 33599
// exit ;
33597: GO 34319
// uc_side := your_side ;
33599: LD_ADDR_OWVAR 20
33603: PUSH
33604: LD_OWVAR 2
33608: ST_TO_ADDR
// uc_nation := nation ;
33609: LD_ADDR_OWVAR 21
33613: PUSH
33614: LD_VAR 0 1
33618: ST_TO_ADDR
// bc_level = 1 ;
33619: LD_ADDR_OWVAR 43
33623: PUSH
33624: LD_INT 1
33626: ST_TO_ADDR
// case btype of 1 :
33627: LD_VAR 0 2
33631: PUSH
33632: LD_INT 1
33634: DOUBLE
33635: EQUAL
33636: IFTRUE 33640
33638: GO 33651
33640: POP
// bc_type := b_depot ; 2 :
33641: LD_ADDR_OWVAR 42
33645: PUSH
33646: LD_INT 0
33648: ST_TO_ADDR
33649: GO 34263
33651: LD_INT 2
33653: DOUBLE
33654: EQUAL
33655: IFTRUE 33659
33657: GO 33670
33659: POP
// bc_type := b_warehouse ; 3 :
33660: LD_ADDR_OWVAR 42
33664: PUSH
33665: LD_INT 1
33667: ST_TO_ADDR
33668: GO 34263
33670: LD_INT 3
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33689
33678: POP
// bc_type := b_lab ; 4 .. 9 :
33679: LD_ADDR_OWVAR 42
33683: PUSH
33684: LD_INT 6
33686: ST_TO_ADDR
33687: GO 34263
33689: LD_INT 4
33691: DOUBLE
33692: GREATEREQUAL
33693: IFFALSE 33701
33695: LD_INT 9
33697: DOUBLE
33698: LESSEQUAL
33699: IFTRUE 33703
33701: GO 33755
33703: POP
// begin bc_type := b_lab_half ;
33704: LD_ADDR_OWVAR 42
33708: PUSH
33709: LD_INT 7
33711: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
33712: LD_ADDR_OWVAR 44
33716: PUSH
33717: LD_INT 10
33719: PUSH
33720: LD_INT 11
33722: PUSH
33723: LD_INT 12
33725: PUSH
33726: LD_INT 15
33728: PUSH
33729: LD_INT 14
33731: PUSH
33732: LD_INT 13
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: PUSH
33743: LD_VAR 0 2
33747: PUSH
33748: LD_INT 3
33750: MINUS
33751: ARRAY
33752: ST_TO_ADDR
// end ; 10 .. 13 :
33753: GO 34263
33755: LD_INT 10
33757: DOUBLE
33758: GREATEREQUAL
33759: IFFALSE 33767
33761: LD_INT 13
33763: DOUBLE
33764: LESSEQUAL
33765: IFTRUE 33769
33767: GO 33846
33769: POP
// begin bc_type := b_lab_full ;
33770: LD_ADDR_OWVAR 42
33774: PUSH
33775: LD_INT 8
33777: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
33778: LD_ADDR_OWVAR 44
33782: PUSH
33783: LD_INT 10
33785: PUSH
33786: LD_INT 12
33788: PUSH
33789: LD_INT 14
33791: PUSH
33792: LD_INT 13
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: PUSH
33801: LD_VAR 0 2
33805: PUSH
33806: LD_INT 9
33808: MINUS
33809: ARRAY
33810: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
33811: LD_ADDR_OWVAR 45
33815: PUSH
33816: LD_INT 11
33818: PUSH
33819: LD_INT 15
33821: PUSH
33822: LD_INT 12
33824: PUSH
33825: LD_INT 15
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: PUSH
33834: LD_VAR 0 2
33838: PUSH
33839: LD_INT 9
33841: MINUS
33842: ARRAY
33843: ST_TO_ADDR
// end ; 14 :
33844: GO 34263
33846: LD_INT 14
33848: DOUBLE
33849: EQUAL
33850: IFTRUE 33854
33852: GO 33865
33854: POP
// bc_type := b_workshop ; 15 :
33855: LD_ADDR_OWVAR 42
33859: PUSH
33860: LD_INT 2
33862: ST_TO_ADDR
33863: GO 34263
33865: LD_INT 15
33867: DOUBLE
33868: EQUAL
33869: IFTRUE 33873
33871: GO 33884
33873: POP
// bc_type := b_factory ; 16 :
33874: LD_ADDR_OWVAR 42
33878: PUSH
33879: LD_INT 3
33881: ST_TO_ADDR
33882: GO 34263
33884: LD_INT 16
33886: DOUBLE
33887: EQUAL
33888: IFTRUE 33892
33890: GO 33903
33892: POP
// bc_type := b_ext_gun ; 17 :
33893: LD_ADDR_OWVAR 42
33897: PUSH
33898: LD_INT 17
33900: ST_TO_ADDR
33901: GO 34263
33903: LD_INT 17
33905: DOUBLE
33906: EQUAL
33907: IFTRUE 33911
33909: GO 33939
33911: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
33912: LD_ADDR_OWVAR 42
33916: PUSH
33917: LD_INT 19
33919: PUSH
33920: LD_INT 23
33922: PUSH
33923: LD_INT 19
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: PUSH
33931: LD_VAR 0 1
33935: ARRAY
33936: ST_TO_ADDR
33937: GO 34263
33939: LD_INT 18
33941: DOUBLE
33942: EQUAL
33943: IFTRUE 33947
33945: GO 33958
33947: POP
// bc_type := b_ext_radar ; 19 :
33948: LD_ADDR_OWVAR 42
33952: PUSH
33953: LD_INT 20
33955: ST_TO_ADDR
33956: GO 34263
33958: LD_INT 19
33960: DOUBLE
33961: EQUAL
33962: IFTRUE 33966
33964: GO 33977
33966: POP
// bc_type := b_ext_radio ; 20 :
33967: LD_ADDR_OWVAR 42
33971: PUSH
33972: LD_INT 22
33974: ST_TO_ADDR
33975: GO 34263
33977: LD_INT 20
33979: DOUBLE
33980: EQUAL
33981: IFTRUE 33985
33983: GO 33996
33985: POP
// bc_type := b_ext_siberium ; 21 :
33986: LD_ADDR_OWVAR 42
33990: PUSH
33991: LD_INT 21
33993: ST_TO_ADDR
33994: GO 34263
33996: LD_INT 21
33998: DOUBLE
33999: EQUAL
34000: IFTRUE 34004
34002: GO 34015
34004: POP
// bc_type := b_ext_computer ; 22 :
34005: LD_ADDR_OWVAR 42
34009: PUSH
34010: LD_INT 24
34012: ST_TO_ADDR
34013: GO 34263
34015: LD_INT 22
34017: DOUBLE
34018: EQUAL
34019: IFTRUE 34023
34021: GO 34034
34023: POP
// bc_type := b_ext_track ; 23 :
34024: LD_ADDR_OWVAR 42
34028: PUSH
34029: LD_INT 16
34031: ST_TO_ADDR
34032: GO 34263
34034: LD_INT 23
34036: DOUBLE
34037: EQUAL
34038: IFTRUE 34042
34040: GO 34053
34042: POP
// bc_type := b_ext_laser ; 24 :
34043: LD_ADDR_OWVAR 42
34047: PUSH
34048: LD_INT 25
34050: ST_TO_ADDR
34051: GO 34263
34053: LD_INT 24
34055: DOUBLE
34056: EQUAL
34057: IFTRUE 34061
34059: GO 34072
34061: POP
// bc_type := b_control_tower ; 25 :
34062: LD_ADDR_OWVAR 42
34066: PUSH
34067: LD_INT 36
34069: ST_TO_ADDR
34070: GO 34263
34072: LD_INT 25
34074: DOUBLE
34075: EQUAL
34076: IFTRUE 34080
34078: GO 34091
34080: POP
// bc_type := b_breastwork ; 26 :
34081: LD_ADDR_OWVAR 42
34085: PUSH
34086: LD_INT 31
34088: ST_TO_ADDR
34089: GO 34263
34091: LD_INT 26
34093: DOUBLE
34094: EQUAL
34095: IFTRUE 34099
34097: GO 34110
34099: POP
// bc_type := b_bunker ; 27 :
34100: LD_ADDR_OWVAR 42
34104: PUSH
34105: LD_INT 32
34107: ST_TO_ADDR
34108: GO 34263
34110: LD_INT 27
34112: DOUBLE
34113: EQUAL
34114: IFTRUE 34118
34116: GO 34129
34118: POP
// bc_type := b_turret ; 28 :
34119: LD_ADDR_OWVAR 42
34123: PUSH
34124: LD_INT 33
34126: ST_TO_ADDR
34127: GO 34263
34129: LD_INT 28
34131: DOUBLE
34132: EQUAL
34133: IFTRUE 34137
34135: GO 34148
34137: POP
// bc_type := b_armoury ; 29 :
34138: LD_ADDR_OWVAR 42
34142: PUSH
34143: LD_INT 4
34145: ST_TO_ADDR
34146: GO 34263
34148: LD_INT 29
34150: DOUBLE
34151: EQUAL
34152: IFTRUE 34156
34154: GO 34167
34156: POP
// bc_type := b_barracks ; 30 :
34157: LD_ADDR_OWVAR 42
34161: PUSH
34162: LD_INT 5
34164: ST_TO_ADDR
34165: GO 34263
34167: LD_INT 30
34169: DOUBLE
34170: EQUAL
34171: IFTRUE 34175
34173: GO 34186
34175: POP
// bc_type := b_solar_power ; 31 :
34176: LD_ADDR_OWVAR 42
34180: PUSH
34181: LD_INT 27
34183: ST_TO_ADDR
34184: GO 34263
34186: LD_INT 31
34188: DOUBLE
34189: EQUAL
34190: IFTRUE 34194
34192: GO 34205
34194: POP
// bc_type := b_oil_power ; 32 :
34195: LD_ADDR_OWVAR 42
34199: PUSH
34200: LD_INT 26
34202: ST_TO_ADDR
34203: GO 34263
34205: LD_INT 32
34207: DOUBLE
34208: EQUAL
34209: IFTRUE 34213
34211: GO 34224
34213: POP
// bc_type := b_siberite_power ; 33 :
34214: LD_ADDR_OWVAR 42
34218: PUSH
34219: LD_INT 28
34221: ST_TO_ADDR
34222: GO 34263
34224: LD_INT 33
34226: DOUBLE
34227: EQUAL
34228: IFTRUE 34232
34230: GO 34243
34232: POP
// bc_type := b_oil_mine ; 34 :
34233: LD_ADDR_OWVAR 42
34237: PUSH
34238: LD_INT 29
34240: ST_TO_ADDR
34241: GO 34263
34243: LD_INT 34
34245: DOUBLE
34246: EQUAL
34247: IFTRUE 34251
34249: GO 34262
34251: POP
// bc_type := b_siberite_mine ; end ;
34252: LD_ADDR_OWVAR 42
34256: PUSH
34257: LD_INT 30
34259: ST_TO_ADDR
34260: GO 34263
34262: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
34263: LD_ADDR_VAR 0 8
34267: PUSH
34268: LD_VAR 0 5
34272: PPUSH
34273: LD_VAR 0 6
34277: PPUSH
34278: LD_VAR 0 3
34282: PPUSH
34283: CALL_OW 47
34287: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
34288: LD_OWVAR 42
34292: PUSH
34293: LD_INT 32
34295: PUSH
34296: LD_INT 33
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: IN
34303: IFFALSE 34319
// PlaceWeaponTurret ( b , weapon ) ;
34305: LD_VAR 0 8
34309: PPUSH
34310: LD_VAR 0 4
34314: PPUSH
34315: CALL_OW 431
// end ;
34319: LD_VAR 0 7
34323: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
34324: LD_INT 0
34326: PPUSH
34327: PPUSH
34328: PPUSH
34329: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
34330: LD_ADDR_VAR 0 4
34334: PUSH
34335: LD_INT 22
34337: PUSH
34338: LD_OWVAR 2
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 2
34349: PUSH
34350: LD_INT 30
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 30
34362: PUSH
34363: LD_INT 1
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: LIST
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PPUSH
34379: CALL_OW 69
34383: ST_TO_ADDR
// if not tmp then
34384: LD_VAR 0 4
34388: NOT
34389: IFFALSE 34393
// exit ;
34391: GO 34452
// for i in tmp do
34393: LD_ADDR_VAR 0 2
34397: PUSH
34398: LD_VAR 0 4
34402: PUSH
34403: FOR_IN
34404: IFFALSE 34450
// for j = 1 to 3 do
34406: LD_ADDR_VAR 0 3
34410: PUSH
34411: DOUBLE
34412: LD_INT 1
34414: DEC
34415: ST_TO_ADDR
34416: LD_INT 3
34418: PUSH
34419: FOR_TO
34420: IFFALSE 34446
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
34422: LD_VAR 0 2
34426: PPUSH
34427: CALL_OW 274
34431: PPUSH
34432: LD_VAR 0 3
34436: PPUSH
34437: LD_INT 99999
34439: PPUSH
34440: CALL_OW 277
34444: GO 34419
34446: POP
34447: POP
34448: GO 34403
34450: POP
34451: POP
// end ;
34452: LD_VAR 0 1
34456: RET
// export function hHackSetLevel10 ; var i , j ; begin
34457: LD_INT 0
34459: PPUSH
34460: PPUSH
34461: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
34462: LD_ADDR_VAR 0 2
34466: PUSH
34467: LD_INT 21
34469: PUSH
34470: LD_INT 1
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PPUSH
34477: CALL_OW 69
34481: PUSH
34482: FOR_IN
34483: IFFALSE 34535
// if IsSelected ( i ) then
34485: LD_VAR 0 2
34489: PPUSH
34490: CALL_OW 306
34494: IFFALSE 34533
// begin for j := 1 to 4 do
34496: LD_ADDR_VAR 0 3
34500: PUSH
34501: DOUBLE
34502: LD_INT 1
34504: DEC
34505: ST_TO_ADDR
34506: LD_INT 4
34508: PUSH
34509: FOR_TO
34510: IFFALSE 34531
// SetSkill ( i , j , 10 ) ;
34512: LD_VAR 0 2
34516: PPUSH
34517: LD_VAR 0 3
34521: PPUSH
34522: LD_INT 10
34524: PPUSH
34525: CALL_OW 237
34529: GO 34509
34531: POP
34532: POP
// end ;
34533: GO 34482
34535: POP
34536: POP
// end ;
34537: LD_VAR 0 1
34541: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
34542: LD_INT 0
34544: PPUSH
34545: PPUSH
34546: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
34547: LD_ADDR_VAR 0 2
34551: PUSH
34552: LD_INT 22
34554: PUSH
34555: LD_OWVAR 2
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 21
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PPUSH
34578: CALL_OW 69
34582: PUSH
34583: FOR_IN
34584: IFFALSE 34625
// begin for j := 1 to 4 do
34586: LD_ADDR_VAR 0 3
34590: PUSH
34591: DOUBLE
34592: LD_INT 1
34594: DEC
34595: ST_TO_ADDR
34596: LD_INT 4
34598: PUSH
34599: FOR_TO
34600: IFFALSE 34621
// SetSkill ( i , j , 10 ) ;
34602: LD_VAR 0 2
34606: PPUSH
34607: LD_VAR 0 3
34611: PPUSH
34612: LD_INT 10
34614: PPUSH
34615: CALL_OW 237
34619: GO 34599
34621: POP
34622: POP
// end ;
34623: GO 34583
34625: POP
34626: POP
// end ;
34627: LD_VAR 0 1
34631: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
34632: LD_INT 0
34634: PPUSH
// uc_side := your_side ;
34635: LD_ADDR_OWVAR 20
34639: PUSH
34640: LD_OWVAR 2
34644: ST_TO_ADDR
// uc_nation := nation ;
34645: LD_ADDR_OWVAR 21
34649: PUSH
34650: LD_VAR 0 1
34654: ST_TO_ADDR
// InitHc ;
34655: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
34659: LD_INT 0
34661: PPUSH
34662: LD_VAR 0 2
34666: PPUSH
34667: LD_VAR 0 3
34671: PPUSH
34672: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
34676: LD_VAR 0 4
34680: PPUSH
34681: LD_VAR 0 5
34685: PPUSH
34686: CALL_OW 428
34690: PUSH
34691: LD_INT 0
34693: EQUAL
34694: IFFALSE 34718
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
34696: CALL_OW 44
34700: PPUSH
34701: LD_VAR 0 4
34705: PPUSH
34706: LD_VAR 0 5
34710: PPUSH
34711: LD_INT 1
34713: PPUSH
34714: CALL_OW 48
// end ;
34718: LD_VAR 0 6
34722: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
34723: LD_INT 0
34725: PPUSH
34726: PPUSH
// uc_side := your_side ;
34727: LD_ADDR_OWVAR 20
34731: PUSH
34732: LD_OWVAR 2
34736: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
34737: LD_VAR 0 1
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: LD_INT 2
34747: PUSH
34748: LD_INT 3
34750: PUSH
34751: LD_INT 4
34753: PUSH
34754: LD_INT 5
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: IN
34764: IFFALSE 34776
// uc_nation := nation_american else
34766: LD_ADDR_OWVAR 21
34770: PUSH
34771: LD_INT 1
34773: ST_TO_ADDR
34774: GO 34819
// if chassis in [ 11 , 12 , 13 , 14 ] then
34776: LD_VAR 0 1
34780: PUSH
34781: LD_INT 11
34783: PUSH
34784: LD_INT 12
34786: PUSH
34787: LD_INT 13
34789: PUSH
34790: LD_INT 14
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: IN
34799: IFFALSE 34811
// uc_nation := nation_arabian else
34801: LD_ADDR_OWVAR 21
34805: PUSH
34806: LD_INT 2
34808: ST_TO_ADDR
34809: GO 34819
// uc_nation := nation_russian ;
34811: LD_ADDR_OWVAR 21
34815: PUSH
34816: LD_INT 3
34818: ST_TO_ADDR
// vc_chassis := chassis ;
34819: LD_ADDR_OWVAR 37
34823: PUSH
34824: LD_VAR 0 1
34828: ST_TO_ADDR
// vc_engine := engine ;
34829: LD_ADDR_OWVAR 39
34833: PUSH
34834: LD_VAR 0 2
34838: ST_TO_ADDR
// vc_control := control ;
34839: LD_ADDR_OWVAR 38
34843: PUSH
34844: LD_VAR 0 3
34848: ST_TO_ADDR
// vc_weapon := weapon ;
34849: LD_ADDR_OWVAR 40
34853: PUSH
34854: LD_VAR 0 4
34858: ST_TO_ADDR
// un := CreateVehicle ;
34859: LD_ADDR_VAR 0 8
34863: PUSH
34864: CALL_OW 45
34868: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
34869: LD_VAR 0 8
34873: PPUSH
34874: LD_INT 0
34876: PPUSH
34877: LD_INT 5
34879: PPUSH
34880: CALL_OW 12
34884: PPUSH
34885: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
34889: LD_VAR 0 8
34893: PPUSH
34894: LD_VAR 0 5
34898: PPUSH
34899: LD_VAR 0 6
34903: PPUSH
34904: LD_INT 1
34906: PPUSH
34907: CALL_OW 48
// end ;
34911: LD_VAR 0 7
34915: RET
// export hInvincible ; every 1 do
34916: GO 34918
34918: DISABLE
// hInvincible := [ ] ;
34919: LD_ADDR_EXP 86
34923: PUSH
34924: EMPTY
34925: ST_TO_ADDR
34926: END
// every 10 do var i ;
34927: GO 34929
34929: DISABLE
34930: LD_INT 0
34932: PPUSH
// begin enable ;
34933: ENABLE
// if not hInvincible then
34934: LD_EXP 86
34938: NOT
34939: IFFALSE 34943
// exit ;
34941: GO 34987
// for i in hInvincible do
34943: LD_ADDR_VAR 0 1
34947: PUSH
34948: LD_EXP 86
34952: PUSH
34953: FOR_IN
34954: IFFALSE 34985
// if GetLives ( i ) < 1000 then
34956: LD_VAR 0 1
34960: PPUSH
34961: CALL_OW 256
34965: PUSH
34966: LD_INT 1000
34968: LESS
34969: IFFALSE 34983
// SetLives ( i , 1000 ) ;
34971: LD_VAR 0 1
34975: PPUSH
34976: LD_INT 1000
34978: PPUSH
34979: CALL_OW 234
34983: GO 34953
34985: POP
34986: POP
// end ;
34987: PPOPN 1
34989: END
// export function hHackInvincible ; var i ; begin
34990: LD_INT 0
34992: PPUSH
34993: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
34994: LD_ADDR_VAR 0 2
34998: PUSH
34999: LD_INT 2
35001: PUSH
35002: LD_INT 21
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: EMPTY
35009: LIST
35010: LIST
35011: PUSH
35012: LD_INT 21
35014: PUSH
35015: LD_INT 2
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: LIST
35026: PPUSH
35027: CALL_OW 69
35031: PUSH
35032: FOR_IN
35033: IFFALSE 35094
// if IsSelected ( i ) then
35035: LD_VAR 0 2
35039: PPUSH
35040: CALL_OW 306
35044: IFFALSE 35092
// begin if i in hInvincible then
35046: LD_VAR 0 2
35050: PUSH
35051: LD_EXP 86
35055: IN
35056: IFFALSE 35076
// hInvincible := hInvincible diff i else
35058: LD_ADDR_EXP 86
35062: PUSH
35063: LD_EXP 86
35067: PUSH
35068: LD_VAR 0 2
35072: DIFF
35073: ST_TO_ADDR
35074: GO 35092
// hInvincible := hInvincible union i ;
35076: LD_ADDR_EXP 86
35080: PUSH
35081: LD_EXP 86
35085: PUSH
35086: LD_VAR 0 2
35090: UNION
35091: ST_TO_ADDR
// end ;
35092: GO 35032
35094: POP
35095: POP
// end ;
35096: LD_VAR 0 1
35100: RET
// export function hHackInvisible ; var i , j ; begin
35101: LD_INT 0
35103: PPUSH
35104: PPUSH
35105: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
35106: LD_ADDR_VAR 0 2
35110: PUSH
35111: LD_INT 21
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PPUSH
35121: CALL_OW 69
35125: PUSH
35126: FOR_IN
35127: IFFALSE 35151
// if IsSelected ( i ) then
35129: LD_VAR 0 2
35133: PPUSH
35134: CALL_OW 306
35138: IFFALSE 35149
// ComForceInvisible ( i ) ;
35140: LD_VAR 0 2
35144: PPUSH
35145: CALL_OW 496
35149: GO 35126
35151: POP
35152: POP
// end ;
35153: LD_VAR 0 1
35157: RET
// export function hHackChangeYourSide ; begin
35158: LD_INT 0
35160: PPUSH
// if your_side = 8 then
35161: LD_OWVAR 2
35165: PUSH
35166: LD_INT 8
35168: EQUAL
35169: IFFALSE 35181
// your_side := 0 else
35171: LD_ADDR_OWVAR 2
35175: PUSH
35176: LD_INT 0
35178: ST_TO_ADDR
35179: GO 35195
// your_side := your_side + 1 ;
35181: LD_ADDR_OWVAR 2
35185: PUSH
35186: LD_OWVAR 2
35190: PUSH
35191: LD_INT 1
35193: PLUS
35194: ST_TO_ADDR
// end ;
35195: LD_VAR 0 1
35199: RET
// export function hHackChangeUnitSide ; var i , j ; begin
35200: LD_INT 0
35202: PPUSH
35203: PPUSH
35204: PPUSH
// for i in all_units do
35205: LD_ADDR_VAR 0 2
35209: PUSH
35210: LD_OWVAR 3
35214: PUSH
35215: FOR_IN
35216: IFFALSE 35294
// if IsSelected ( i ) then
35218: LD_VAR 0 2
35222: PPUSH
35223: CALL_OW 306
35227: IFFALSE 35292
// begin j := GetSide ( i ) ;
35229: LD_ADDR_VAR 0 3
35233: PUSH
35234: LD_VAR 0 2
35238: PPUSH
35239: CALL_OW 255
35243: ST_TO_ADDR
// if j = 8 then
35244: LD_VAR 0 3
35248: PUSH
35249: LD_INT 8
35251: EQUAL
35252: IFFALSE 35264
// j := 0 else
35254: LD_ADDR_VAR 0 3
35258: PUSH
35259: LD_INT 0
35261: ST_TO_ADDR
35262: GO 35278
// j := j + 1 ;
35264: LD_ADDR_VAR 0 3
35268: PUSH
35269: LD_VAR 0 3
35273: PUSH
35274: LD_INT 1
35276: PLUS
35277: ST_TO_ADDR
// SetSide ( i , j ) ;
35278: LD_VAR 0 2
35282: PPUSH
35283: LD_VAR 0 3
35287: PPUSH
35288: CALL_OW 235
// end ;
35292: GO 35215
35294: POP
35295: POP
// end ;
35296: LD_VAR 0 1
35300: RET
// export function hHackFog ; begin
35301: LD_INT 0
35303: PPUSH
// FogOff ( true ) ;
35304: LD_INT 1
35306: PPUSH
35307: CALL_OW 344
// end ;
35311: LD_VAR 0 1
35315: RET
// export function hHackTeleport ( unit , x , y ) ; begin
35316: LD_INT 0
35318: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
35319: LD_VAR 0 1
35323: PPUSH
35324: LD_VAR 0 2
35328: PPUSH
35329: LD_VAR 0 3
35333: PPUSH
35334: LD_INT 1
35336: PPUSH
35337: LD_INT 1
35339: PPUSH
35340: CALL_OW 483
// CenterOnXY ( x , y ) ;
35344: LD_VAR 0 2
35348: PPUSH
35349: LD_VAR 0 3
35353: PPUSH
35354: CALL_OW 84
// end ;
35358: LD_VAR 0 4
35362: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
35363: LD_INT 0
35365: PPUSH
35366: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
35367: LD_VAR 0 1
35371: NOT
35372: PUSH
35373: LD_VAR 0 2
35377: PPUSH
35378: LD_VAR 0 3
35382: PPUSH
35383: CALL_OW 488
35387: NOT
35388: OR
35389: PUSH
35390: LD_VAR 0 1
35394: PPUSH
35395: CALL_OW 266
35399: PUSH
35400: LD_INT 3
35402: NONEQUAL
35403: PUSH
35404: LD_VAR 0 1
35408: PPUSH
35409: CALL_OW 247
35413: PUSH
35414: LD_INT 1
35416: EQUAL
35417: NOT
35418: AND
35419: OR
35420: IFFALSE 35424
// exit ;
35422: GO 35573
// if GetType ( factory ) = unit_human then
35424: LD_VAR 0 1
35428: PPUSH
35429: CALL_OW 247
35433: PUSH
35434: LD_INT 1
35436: EQUAL
35437: IFFALSE 35454
// factory := IsInUnit ( factory ) ;
35439: LD_ADDR_VAR 0 1
35443: PUSH
35444: LD_VAR 0 1
35448: PPUSH
35449: CALL_OW 310
35453: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
35454: LD_VAR 0 1
35458: PPUSH
35459: CALL_OW 266
35463: PUSH
35464: LD_INT 3
35466: NONEQUAL
35467: IFFALSE 35471
// exit ;
35469: GO 35573
// if HexInfo ( x , y ) = factory then
35471: LD_VAR 0 2
35475: PPUSH
35476: LD_VAR 0 3
35480: PPUSH
35481: CALL_OW 428
35485: PUSH
35486: LD_VAR 0 1
35490: EQUAL
35491: IFFALSE 35518
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
35493: LD_ADDR_EXP 87
35497: PUSH
35498: LD_EXP 87
35502: PPUSH
35503: LD_VAR 0 1
35507: PPUSH
35508: LD_INT 0
35510: PPUSH
35511: CALL_OW 1
35515: ST_TO_ADDR
35516: GO 35569
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
35518: LD_ADDR_EXP 87
35522: PUSH
35523: LD_EXP 87
35527: PPUSH
35528: LD_VAR 0 1
35532: PPUSH
35533: LD_VAR 0 1
35537: PPUSH
35538: CALL_OW 255
35542: PUSH
35543: LD_VAR 0 1
35547: PUSH
35548: LD_VAR 0 2
35552: PUSH
35553: LD_VAR 0 3
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// UpdateFactoryWaypoints ;
35569: CALL 35578 0 0
// end ;
35573: LD_VAR 0 4
35577: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
35578: LD_INT 0
35580: PPUSH
35581: PPUSH
35582: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
35583: LD_STRING resetFactoryWaypoint();
35585: PPUSH
35586: CALL_OW 559
// if factoryWaypoints then
35590: LD_EXP 87
35594: IFFALSE 35720
// begin list := PrepareArray ( factoryWaypoints ) ;
35596: LD_ADDR_VAR 0 3
35600: PUSH
35601: LD_EXP 87
35605: PPUSH
35606: NOP4
35610: ST_TO_ADDR
// for i := 1 to list do
35611: LD_ADDR_VAR 0 2
35615: PUSH
35616: DOUBLE
35617: LD_INT 1
35619: DEC
35620: ST_TO_ADDR
35621: LD_VAR 0 3
35625: PUSH
35626: FOR_TO
35627: IFFALSE 35718
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
35629: LD_STRING setFactoryWaypointXY(
35631: PUSH
35632: LD_VAR 0 3
35636: PUSH
35637: LD_VAR 0 2
35641: ARRAY
35642: PUSH
35643: LD_INT 1
35645: ARRAY
35646: STR
35647: PUSH
35648: LD_STRING ,
35650: STR
35651: PUSH
35652: LD_VAR 0 3
35656: PUSH
35657: LD_VAR 0 2
35661: ARRAY
35662: PUSH
35663: LD_INT 2
35665: ARRAY
35666: STR
35667: PUSH
35668: LD_STRING ,
35670: STR
35671: PUSH
35672: LD_VAR 0 3
35676: PUSH
35677: LD_VAR 0 2
35681: ARRAY
35682: PUSH
35683: LD_INT 3
35685: ARRAY
35686: STR
35687: PUSH
35688: LD_STRING ,
35690: STR
35691: PUSH
35692: LD_VAR 0 3
35696: PUSH
35697: LD_VAR 0 2
35701: ARRAY
35702: PUSH
35703: LD_INT 4
35705: ARRAY
35706: STR
35707: PUSH
35708: LD_STRING )
35710: STR
35711: PPUSH
35712: CALL_OW 559
35716: GO 35626
35718: POP
35719: POP
// end ; end ;
35720: LD_VAR 0 1
35724: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
35725: LD_INT 0
35727: PPUSH
// if HexInfo ( x , y ) = warehouse then
35728: LD_VAR 0 2
35732: PPUSH
35733: LD_VAR 0 3
35737: PPUSH
35738: CALL_OW 428
35742: PUSH
35743: LD_VAR 0 1
35747: EQUAL
35748: IFFALSE 35775
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
35750: LD_ADDR_EXP 88
35754: PUSH
35755: LD_EXP 88
35759: PPUSH
35760: LD_VAR 0 1
35764: PPUSH
35765: LD_INT 0
35767: PPUSH
35768: CALL_OW 1
35772: ST_TO_ADDR
35773: GO 35826
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
35775: LD_ADDR_EXP 88
35779: PUSH
35780: LD_EXP 88
35784: PPUSH
35785: LD_VAR 0 1
35789: PPUSH
35790: LD_VAR 0 1
35794: PPUSH
35795: CALL_OW 255
35799: PUSH
35800: LD_VAR 0 1
35804: PUSH
35805: LD_VAR 0 2
35809: PUSH
35810: LD_VAR 0 3
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
35826: CALL 35835 0 0
// end ;
35830: LD_VAR 0 4
35834: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
35835: LD_INT 0
35837: PPUSH
35838: PPUSH
35839: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
35840: LD_STRING resetWarehouseGatheringPoints();
35842: PPUSH
35843: CALL_OW 559
// if warehouseGatheringPoints then
35847: LD_EXP 88
35851: IFFALSE 35977
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
35853: LD_ADDR_VAR 0 3
35857: PUSH
35858: LD_EXP 88
35862: PPUSH
35863: NOP4
35867: ST_TO_ADDR
// for i := 1 to list do
35868: LD_ADDR_VAR 0 2
35872: PUSH
35873: DOUBLE
35874: LD_INT 1
35876: DEC
35877: ST_TO_ADDR
35878: LD_VAR 0 3
35882: PUSH
35883: FOR_TO
35884: IFFALSE 35975
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
35886: LD_STRING setWarehouseGatheringPointXY(
35888: PUSH
35889: LD_VAR 0 3
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 1
35902: ARRAY
35903: STR
35904: PUSH
35905: LD_STRING ,
35907: STR
35908: PUSH
35909: LD_VAR 0 3
35913: PUSH
35914: LD_VAR 0 2
35918: ARRAY
35919: PUSH
35920: LD_INT 2
35922: ARRAY
35923: STR
35924: PUSH
35925: LD_STRING ,
35927: STR
35928: PUSH
35929: LD_VAR 0 3
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_INT 3
35942: ARRAY
35943: STR
35944: PUSH
35945: LD_STRING ,
35947: STR
35948: PUSH
35949: LD_VAR 0 3
35953: PUSH
35954: LD_VAR 0 2
35958: ARRAY
35959: PUSH
35960: LD_INT 4
35962: ARRAY
35963: STR
35964: PUSH
35965: LD_STRING )
35967: STR
35968: PPUSH
35969: CALL_OW 559
35973: GO 35883
35975: POP
35976: POP
// end ; end ;
35977: LD_VAR 0 1
35981: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
35982: LD_EXP 88
35986: IFFALSE 36671
35988: GO 35990
35990: DISABLE
35991: LD_INT 0
35993: PPUSH
35994: PPUSH
35995: PPUSH
35996: PPUSH
35997: PPUSH
35998: PPUSH
35999: PPUSH
36000: PPUSH
36001: PPUSH
// begin enable ;
36002: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
36003: LD_ADDR_VAR 0 3
36007: PUSH
36008: LD_EXP 88
36012: PPUSH
36013: NOP4
36017: ST_TO_ADDR
// if not list then
36018: LD_VAR 0 3
36022: NOT
36023: IFFALSE 36027
// exit ;
36025: GO 36671
// for i := 1 to list do
36027: LD_ADDR_VAR 0 1
36031: PUSH
36032: DOUBLE
36033: LD_INT 1
36035: DEC
36036: ST_TO_ADDR
36037: LD_VAR 0 3
36041: PUSH
36042: FOR_TO
36043: IFFALSE 36669
// begin depot := list [ i ] [ 2 ] ;
36045: LD_ADDR_VAR 0 8
36049: PUSH
36050: LD_VAR 0 3
36054: PUSH
36055: LD_VAR 0 1
36059: ARRAY
36060: PUSH
36061: LD_INT 2
36063: ARRAY
36064: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
36065: LD_ADDR_VAR 0 5
36069: PUSH
36070: LD_VAR 0 3
36074: PUSH
36075: LD_VAR 0 1
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
36085: LD_VAR 0 8
36089: PPUSH
36090: CALL_OW 301
36094: PUSH
36095: LD_VAR 0 5
36099: PUSH
36100: LD_VAR 0 8
36104: PPUSH
36105: CALL_OW 255
36109: NONEQUAL
36110: OR
36111: IFFALSE 36140
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
36113: LD_ADDR_EXP 88
36117: PUSH
36118: LD_EXP 88
36122: PPUSH
36123: LD_VAR 0 8
36127: PPUSH
36128: LD_INT 0
36130: PPUSH
36131: CALL_OW 1
36135: ST_TO_ADDR
// exit ;
36136: POP
36137: POP
36138: GO 36671
// end ; x := list [ i ] [ 3 ] ;
36140: LD_ADDR_VAR 0 6
36144: PUSH
36145: LD_VAR 0 3
36149: PUSH
36150: LD_VAR 0 1
36154: ARRAY
36155: PUSH
36156: LD_INT 3
36158: ARRAY
36159: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
36160: LD_ADDR_VAR 0 7
36164: PUSH
36165: LD_VAR 0 3
36169: PUSH
36170: LD_VAR 0 1
36174: ARRAY
36175: PUSH
36176: LD_INT 4
36178: ARRAY
36179: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
36180: LD_ADDR_VAR 0 9
36184: PUSH
36185: LD_VAR 0 6
36189: PPUSH
36190: LD_VAR 0 7
36194: PPUSH
36195: LD_INT 16
36197: PPUSH
36198: NOP4
36202: ST_TO_ADDR
// if not cratesNearbyPoint then
36203: LD_VAR 0 9
36207: NOT
36208: IFFALSE 36214
// exit ;
36210: POP
36211: POP
36212: GO 36671
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
36214: LD_ADDR_VAR 0 4
36218: PUSH
36219: LD_INT 22
36221: PUSH
36222: LD_VAR 0 5
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 3
36233: PUSH
36234: LD_INT 60
36236: PUSH
36237: EMPTY
36238: LIST
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 91
36246: PUSH
36247: LD_VAR 0 8
36251: PUSH
36252: LD_INT 6
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: LD_INT 25
36265: PUSH
36266: LD_INT 2
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 25
36275: PUSH
36276: LD_INT 16
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: LIST
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 69
36298: PUSH
36299: LD_VAR 0 8
36303: PPUSH
36304: CALL_OW 313
36308: PPUSH
36309: LD_INT 3
36311: PUSH
36312: LD_INT 60
36314: PUSH
36315: EMPTY
36316: LIST
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: PUSH
36325: LD_INT 25
36327: PUSH
36328: LD_INT 2
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: LD_INT 25
36337: PUSH
36338: LD_INT 16
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: LIST
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PPUSH
36354: CALL_OW 72
36358: UNION
36359: ST_TO_ADDR
// if tmp then
36360: LD_VAR 0 4
36364: IFFALSE 36444
// begin tmp := ShrinkArray ( tmp , 3 ) ;
36366: LD_ADDR_VAR 0 4
36370: PUSH
36371: LD_VAR 0 4
36375: PPUSH
36376: LD_INT 3
36378: PPUSH
36379: NOP4
36383: ST_TO_ADDR
// for j in tmp do
36384: LD_ADDR_VAR 0 2
36388: PUSH
36389: LD_VAR 0 4
36393: PUSH
36394: FOR_IN
36395: IFFALSE 36438
// begin if IsInUnit ( j ) then
36397: LD_VAR 0 2
36401: PPUSH
36402: CALL_OW 310
36406: IFFALSE 36417
// ComExit ( j ) ;
36408: LD_VAR 0 2
36412: PPUSH
36413: NOP4
// AddComCollect ( j , x , y ) ;
36417: LD_VAR 0 2
36421: PPUSH
36422: LD_VAR 0 6
36426: PPUSH
36427: LD_VAR 0 7
36431: PPUSH
36432: CALL_OW 177
// end ;
36436: GO 36394
36438: POP
36439: POP
// exit ;
36440: POP
36441: POP
36442: GO 36671
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
36444: LD_ADDR_VAR 0 4
36448: PUSH
36449: LD_INT 22
36451: PUSH
36452: LD_VAR 0 5
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 91
36463: PUSH
36464: LD_VAR 0 8
36468: PUSH
36469: LD_INT 8
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 2
36479: PUSH
36480: LD_INT 34
36482: PUSH
36483: LD_INT 12
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 34
36492: PUSH
36493: LD_INT 51
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 34
36502: PUSH
36503: LD_INT 32
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 34
36512: PUSH
36513: LD_INT 89
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: LIST
36531: PPUSH
36532: CALL_OW 69
36536: ST_TO_ADDR
// if tmp then
36537: LD_VAR 0 4
36541: IFFALSE 36667
// begin for j in tmp do
36543: LD_ADDR_VAR 0 2
36547: PUSH
36548: LD_VAR 0 4
36552: PUSH
36553: FOR_IN
36554: IFFALSE 36665
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
36556: LD_VAR 0 2
36560: PPUSH
36561: CALL_OW 262
36565: PUSH
36566: LD_INT 3
36568: EQUAL
36569: PUSH
36570: LD_VAR 0 2
36574: PPUSH
36575: CALL_OW 261
36579: PUSH
36580: LD_INT 20
36582: GREATER
36583: OR
36584: PUSH
36585: LD_VAR 0 2
36589: PPUSH
36590: CALL_OW 314
36594: NOT
36595: AND
36596: PUSH
36597: LD_VAR 0 2
36601: PPUSH
36602: CALL_OW 263
36606: PUSH
36607: LD_INT 1
36609: NONEQUAL
36610: PUSH
36611: LD_VAR 0 2
36615: PPUSH
36616: CALL_OW 311
36620: OR
36621: AND
36622: IFFALSE 36663
// begin ComCollect ( j , x , y ) ;
36624: LD_VAR 0 2
36628: PPUSH
36629: LD_VAR 0 6
36633: PPUSH
36634: LD_VAR 0 7
36638: PPUSH
36639: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
36643: LD_VAR 0 2
36647: PPUSH
36648: LD_VAR 0 8
36652: PPUSH
36653: CALL_OW 172
// exit ;
36657: POP
36658: POP
36659: POP
36660: POP
36661: GO 36671
// end ;
36663: GO 36553
36665: POP
36666: POP
// end ; end ;
36667: GO 36042
36669: POP
36670: POP
// end ; end_of_file
36671: PPOPN 9
36673: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
36674: LD_INT 0
36676: PPUSH
36677: PPUSH
36678: PPUSH
36679: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
36680: LD_VAR 0 1
36684: PPUSH
36685: CALL_OW 264
36689: PUSH
36690: LD_INT 91
36692: EQUAL
36693: IFFALSE 36765
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
36695: LD_INT 68
36697: PPUSH
36698: LD_VAR 0 1
36702: PPUSH
36703: CALL_OW 255
36707: PPUSH
36708: CALL_OW 321
36712: PUSH
36713: LD_INT 2
36715: EQUAL
36716: IFFALSE 36728
// eff := 70 else
36718: LD_ADDR_VAR 0 4
36722: PUSH
36723: LD_INT 70
36725: ST_TO_ADDR
36726: GO 36736
// eff := 30 ;
36728: LD_ADDR_VAR 0 4
36732: PUSH
36733: LD_INT 30
36735: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
36736: LD_VAR 0 1
36740: PPUSH
36741: CALL_OW 250
36745: PPUSH
36746: LD_VAR 0 1
36750: PPUSH
36751: CALL_OW 251
36755: PPUSH
36756: LD_VAR 0 4
36760: PPUSH
36761: CALL_OW 495
// end ; end ;
36765: LD_VAR 0 2
36769: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
36770: LD_INT 0
36772: PPUSH
// end ;
36773: LD_VAR 0 4
36777: RET
// export function SOS_Command ( cmd ) ; begin
36778: LD_INT 0
36780: PPUSH
// end ;
36781: LD_VAR 0 2
36785: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
36786: LD_INT 0
36788: PPUSH
// end ;
36789: LD_VAR 0 6
36793: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
36794: LD_INT 0
36796: PPUSH
36797: PPUSH
// if not vehicle or not factory then
36798: LD_VAR 0 1
36802: NOT
36803: PUSH
36804: LD_VAR 0 2
36808: NOT
36809: OR
36810: IFFALSE 36814
// exit ;
36812: GO 37045
// if factoryWaypoints >= factory then
36814: LD_EXP 87
36818: PUSH
36819: LD_VAR 0 2
36823: GREATEREQUAL
36824: IFFALSE 37045
// if factoryWaypoints [ factory ] then
36826: LD_EXP 87
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: IFFALSE 37045
// begin if GetControl ( vehicle ) = control_manual then
36838: LD_VAR 0 1
36842: PPUSH
36843: CALL_OW 263
36847: PUSH
36848: LD_INT 1
36850: EQUAL
36851: IFFALSE 36932
// begin driver := IsDrivenBy ( vehicle ) ;
36853: LD_ADDR_VAR 0 4
36857: PUSH
36858: LD_VAR 0 1
36862: PPUSH
36863: CALL_OW 311
36867: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
36868: LD_VAR 0 4
36872: PPUSH
36873: LD_EXP 87
36877: PUSH
36878: LD_VAR 0 2
36882: ARRAY
36883: PUSH
36884: LD_INT 3
36886: ARRAY
36887: PPUSH
36888: LD_EXP 87
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: PUSH
36899: LD_INT 4
36901: ARRAY
36902: PPUSH
36903: CALL_OW 171
// AddComExitVehicle ( driver ) ;
36907: LD_VAR 0 4
36911: PPUSH
36912: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
36916: LD_VAR 0 4
36920: PPUSH
36921: LD_VAR 0 2
36925: PPUSH
36926: CALL_OW 180
// end else
36930: GO 37045
// if GetControl ( vehicle ) = control_remote then
36932: LD_VAR 0 1
36936: PPUSH
36937: CALL_OW 263
36941: PUSH
36942: LD_INT 2
36944: EQUAL
36945: IFFALSE 37006
// begin wait ( 0 0$2 ) ;
36947: LD_INT 70
36949: PPUSH
36950: CALL_OW 67
// if Connect ( vehicle ) then
36954: LD_VAR 0 1
36958: PPUSH
36959: CALL 16993 0 1
36963: IFFALSE 37004
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
36965: LD_VAR 0 1
36969: PPUSH
36970: LD_EXP 87
36974: PUSH
36975: LD_VAR 0 2
36979: ARRAY
36980: PUSH
36981: LD_INT 3
36983: ARRAY
36984: PPUSH
36985: LD_EXP 87
36989: PUSH
36990: LD_VAR 0 2
36994: ARRAY
36995: PUSH
36996: LD_INT 4
36998: ARRAY
36999: PPUSH
37000: CALL_OW 171
// end else
37004: GO 37045
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
37006: LD_VAR 0 1
37010: PPUSH
37011: LD_EXP 87
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PUSH
37022: LD_INT 3
37024: ARRAY
37025: PPUSH
37026: LD_EXP 87
37030: PUSH
37031: LD_VAR 0 2
37035: ARRAY
37036: PUSH
37037: LD_INT 4
37039: ARRAY
37040: PPUSH
37041: CALL_OW 171
// end ; end ;
37045: LD_VAR 0 3
37049: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
37050: LD_INT 0
37052: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
37053: LD_VAR 0 1
37057: PUSH
37058: LD_INT 250
37060: EQUAL
37061: PUSH
37062: LD_VAR 0 2
37066: PPUSH
37067: CALL_OW 264
37071: PUSH
37072: LD_INT 81
37074: EQUAL
37075: AND
37076: IFFALSE 37097
// MinerPlaceMine ( unit , x , y ) ;
37078: LD_VAR 0 2
37082: PPUSH
37083: LD_VAR 0 4
37087: PPUSH
37088: LD_VAR 0 5
37092: PPUSH
37093: CALL 39482 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
37097: LD_VAR 0 1
37101: PUSH
37102: LD_INT 251
37104: EQUAL
37105: PUSH
37106: LD_VAR 0 2
37110: PPUSH
37111: CALL_OW 264
37115: PUSH
37116: LD_INT 81
37118: EQUAL
37119: AND
37120: IFFALSE 37141
// MinerDetonateMine ( unit , x , y ) ;
37122: LD_VAR 0 2
37126: PPUSH
37127: LD_VAR 0 4
37131: PPUSH
37132: LD_VAR 0 5
37136: PPUSH
37137: CALL 39757 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
37141: LD_VAR 0 1
37145: PUSH
37146: LD_INT 252
37148: EQUAL
37149: PUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: CALL_OW 264
37159: PUSH
37160: LD_INT 81
37162: EQUAL
37163: AND
37164: IFFALSE 37185
// MinerCreateMinefield ( unit , x , y ) ;
37166: LD_VAR 0 2
37170: PPUSH
37171: LD_VAR 0 4
37175: PPUSH
37176: LD_VAR 0 5
37180: PPUSH
37181: CALL 40174 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
37185: LD_VAR 0 1
37189: PUSH
37190: LD_INT 253
37192: EQUAL
37193: PUSH
37194: LD_VAR 0 2
37198: PPUSH
37199: CALL_OW 257
37203: PUSH
37204: LD_INT 5
37206: EQUAL
37207: AND
37208: IFFALSE 37229
// ComBinocular ( unit , x , y ) ;
37210: LD_VAR 0 2
37214: PPUSH
37215: LD_VAR 0 4
37219: PPUSH
37220: LD_VAR 0 5
37224: PPUSH
37225: CALL 40543 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
37229: LD_VAR 0 1
37233: PUSH
37234: LD_INT 254
37236: EQUAL
37237: PUSH
37238: LD_VAR 0 2
37242: PPUSH
37243: CALL_OW 264
37247: PUSH
37248: LD_INT 99
37250: EQUAL
37251: AND
37252: PUSH
37253: LD_VAR 0 3
37257: PPUSH
37258: CALL_OW 263
37262: PUSH
37263: LD_INT 3
37265: EQUAL
37266: AND
37267: IFFALSE 37283
// HackDestroyVehicle ( unit , selectedUnit ) ;
37269: LD_VAR 0 2
37273: PPUSH
37274: LD_VAR 0 3
37278: PPUSH
37279: CALL 38846 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
37283: LD_VAR 0 1
37287: PUSH
37288: LD_INT 255
37290: EQUAL
37291: PUSH
37292: LD_VAR 0 2
37296: PPUSH
37297: CALL_OW 264
37301: PUSH
37302: LD_INT 14
37304: PUSH
37305: LD_INT 53
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: IN
37312: AND
37313: PUSH
37314: LD_VAR 0 4
37318: PPUSH
37319: LD_VAR 0 5
37323: PPUSH
37324: CALL_OW 488
37328: AND
37329: IFFALSE 37353
// CutTreeXYR ( unit , x , y , 12 ) ;
37331: LD_VAR 0 2
37335: PPUSH
37336: LD_VAR 0 4
37340: PPUSH
37341: LD_VAR 0 5
37345: PPUSH
37346: LD_INT 12
37348: PPUSH
37349: CALL 37416 0 4
// if cmd = 256 then
37353: LD_VAR 0 1
37357: PUSH
37358: LD_INT 256
37360: EQUAL
37361: IFFALSE 37382
// SetFactoryWaypoint ( unit , x , y ) ;
37363: LD_VAR 0 2
37367: PPUSH
37368: LD_VAR 0 4
37372: PPUSH
37373: LD_VAR 0 5
37377: PPUSH
37378: CALL 35363 0 3
// if cmd = 257 then
37382: LD_VAR 0 1
37386: PUSH
37387: LD_INT 257
37389: EQUAL
37390: IFFALSE 37411
// SetWarehouseGatheringPoint ( unit , x , y ) ;
37392: LD_VAR 0 2
37396: PPUSH
37397: LD_VAR 0 4
37401: PPUSH
37402: LD_VAR 0 5
37406: PPUSH
37407: CALL 35725 0 3
// end ;
37411: LD_VAR 0 6
37415: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
37416: LD_INT 0
37418: PPUSH
37419: PPUSH
37420: PPUSH
37421: PPUSH
37422: PPUSH
37423: PPUSH
37424: PPUSH
37425: PPUSH
37426: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
37427: LD_VAR 0 1
37431: NOT
37432: PUSH
37433: LD_VAR 0 2
37437: PPUSH
37438: LD_VAR 0 3
37442: PPUSH
37443: CALL_OW 488
37447: NOT
37448: OR
37449: PUSH
37450: LD_VAR 0 4
37454: NOT
37455: OR
37456: IFFALSE 37460
// exit ;
37458: GO 37800
// list := [ ] ;
37460: LD_ADDR_VAR 0 13
37464: PUSH
37465: EMPTY
37466: ST_TO_ADDR
// if x - r < 0 then
37467: LD_VAR 0 2
37471: PUSH
37472: LD_VAR 0 4
37476: MINUS
37477: PUSH
37478: LD_INT 0
37480: LESS
37481: IFFALSE 37493
// min_x := 0 else
37483: LD_ADDR_VAR 0 7
37487: PUSH
37488: LD_INT 0
37490: ST_TO_ADDR
37491: GO 37509
// min_x := x - r ;
37493: LD_ADDR_VAR 0 7
37497: PUSH
37498: LD_VAR 0 2
37502: PUSH
37503: LD_VAR 0 4
37507: MINUS
37508: ST_TO_ADDR
// if y - r < 0 then
37509: LD_VAR 0 3
37513: PUSH
37514: LD_VAR 0 4
37518: MINUS
37519: PUSH
37520: LD_INT 0
37522: LESS
37523: IFFALSE 37535
// min_y := 0 else
37525: LD_ADDR_VAR 0 8
37529: PUSH
37530: LD_INT 0
37532: ST_TO_ADDR
37533: GO 37551
// min_y := y - r ;
37535: LD_ADDR_VAR 0 8
37539: PUSH
37540: LD_VAR 0 3
37544: PUSH
37545: LD_VAR 0 4
37549: MINUS
37550: ST_TO_ADDR
// max_x := x + r ;
37551: LD_ADDR_VAR 0 9
37555: PUSH
37556: LD_VAR 0 2
37560: PUSH
37561: LD_VAR 0 4
37565: PLUS
37566: ST_TO_ADDR
// max_y := y + r ;
37567: LD_ADDR_VAR 0 10
37571: PUSH
37572: LD_VAR 0 3
37576: PUSH
37577: LD_VAR 0 4
37581: PLUS
37582: ST_TO_ADDR
// for _x = min_x to max_x do
37583: LD_ADDR_VAR 0 11
37587: PUSH
37588: DOUBLE
37589: LD_VAR 0 7
37593: DEC
37594: ST_TO_ADDR
37595: LD_VAR 0 9
37599: PUSH
37600: FOR_TO
37601: IFFALSE 37718
// for _y = min_y to max_y do
37603: LD_ADDR_VAR 0 12
37607: PUSH
37608: DOUBLE
37609: LD_VAR 0 8
37613: DEC
37614: ST_TO_ADDR
37615: LD_VAR 0 10
37619: PUSH
37620: FOR_TO
37621: IFFALSE 37714
// begin if not ValidHex ( _x , _y ) then
37623: LD_VAR 0 11
37627: PPUSH
37628: LD_VAR 0 12
37632: PPUSH
37633: CALL_OW 488
37637: NOT
37638: IFFALSE 37642
// continue ;
37640: GO 37620
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
37642: LD_VAR 0 11
37646: PPUSH
37647: LD_VAR 0 12
37651: PPUSH
37652: CALL_OW 351
37656: PUSH
37657: LD_VAR 0 11
37661: PPUSH
37662: LD_VAR 0 12
37666: PPUSH
37667: CALL_OW 554
37671: AND
37672: IFFALSE 37712
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
37674: LD_ADDR_VAR 0 13
37678: PUSH
37679: LD_VAR 0 13
37683: PPUSH
37684: LD_VAR 0 13
37688: PUSH
37689: LD_INT 1
37691: PLUS
37692: PPUSH
37693: LD_VAR 0 11
37697: PUSH
37698: LD_VAR 0 12
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PPUSH
37707: CALL_OW 2
37711: ST_TO_ADDR
// end ;
37712: GO 37620
37714: POP
37715: POP
37716: GO 37600
37718: POP
37719: POP
// if not list then
37720: LD_VAR 0 13
37724: NOT
37725: IFFALSE 37729
// exit ;
37727: GO 37800
// for i in list do
37729: LD_ADDR_VAR 0 6
37733: PUSH
37734: LD_VAR 0 13
37738: PUSH
37739: FOR_IN
37740: IFFALSE 37798
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
37742: LD_VAR 0 1
37746: PPUSH
37747: LD_STRING M
37749: PUSH
37750: LD_VAR 0 6
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: PUSH
37759: LD_VAR 0 6
37763: PUSH
37764: LD_INT 2
37766: ARRAY
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: LD_INT 0
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: PUSH
37789: EMPTY
37790: LIST
37791: PPUSH
37792: CALL_OW 447
37796: GO 37739
37798: POP
37799: POP
// end ;
37800: LD_VAR 0 5
37804: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
37805: LD_EXP 90
37809: NOT
37810: IFFALSE 37860
37812: GO 37814
37814: DISABLE
// begin initHack := true ;
37815: LD_ADDR_EXP 90
37819: PUSH
37820: LD_INT 1
37822: ST_TO_ADDR
// hackTanks := [ ] ;
37823: LD_ADDR_EXP 91
37827: PUSH
37828: EMPTY
37829: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
37830: LD_ADDR_EXP 92
37834: PUSH
37835: EMPTY
37836: ST_TO_ADDR
// hackLimit := 3 ;
37837: LD_ADDR_EXP 93
37841: PUSH
37842: LD_INT 3
37844: ST_TO_ADDR
// hackDist := 12 ;
37845: LD_ADDR_EXP 94
37849: PUSH
37850: LD_INT 12
37852: ST_TO_ADDR
// hackCounter := [ ] ;
37853: LD_ADDR_EXP 95
37857: PUSH
37858: EMPTY
37859: ST_TO_ADDR
// end ;
37860: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
37861: LD_EXP 90
37865: PUSH
37866: LD_INT 34
37868: PUSH
37869: LD_INT 99
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PPUSH
37876: CALL_OW 69
37880: AND
37881: IFFALSE 38134
37883: GO 37885
37885: DISABLE
37886: LD_INT 0
37888: PPUSH
37889: PPUSH
// begin enable ;
37890: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
37891: LD_ADDR_VAR 0 1
37895: PUSH
37896: LD_INT 34
37898: PUSH
37899: LD_INT 99
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PPUSH
37906: CALL_OW 69
37910: PUSH
37911: FOR_IN
37912: IFFALSE 38132
// begin if not i in hackTanks then
37914: LD_VAR 0 1
37918: PUSH
37919: LD_EXP 91
37923: IN
37924: NOT
37925: IFFALSE 38008
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
37927: LD_ADDR_EXP 91
37931: PUSH
37932: LD_EXP 91
37936: PPUSH
37937: LD_EXP 91
37941: PUSH
37942: LD_INT 1
37944: PLUS
37945: PPUSH
37946: LD_VAR 0 1
37950: PPUSH
37951: CALL_OW 1
37955: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
37956: LD_ADDR_EXP 92
37960: PUSH
37961: LD_EXP 92
37965: PPUSH
37966: LD_EXP 92
37970: PUSH
37971: LD_INT 1
37973: PLUS
37974: PPUSH
37975: EMPTY
37976: PPUSH
37977: CALL_OW 1
37981: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
37982: LD_ADDR_EXP 95
37986: PUSH
37987: LD_EXP 95
37991: PPUSH
37992: LD_EXP 95
37996: PUSH
37997: LD_INT 1
37999: PLUS
38000: PPUSH
38001: EMPTY
38002: PPUSH
38003: CALL_OW 1
38007: ST_TO_ADDR
// end ; if not IsOk ( i ) then
38008: LD_VAR 0 1
38012: PPUSH
38013: CALL_OW 302
38017: NOT
38018: IFFALSE 38031
// begin HackUnlinkAll ( i ) ;
38020: LD_VAR 0 1
38024: PPUSH
38025: CALL 38137 0 1
// continue ;
38029: GO 37911
// end ; HackCheckCapturedStatus ( i ) ;
38031: LD_VAR 0 1
38035: PPUSH
38036: CALL 38580 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
38040: LD_ADDR_VAR 0 2
38044: PUSH
38045: LD_INT 81
38047: PUSH
38048: LD_VAR 0 1
38052: PPUSH
38053: CALL_OW 255
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 33
38064: PUSH
38065: LD_INT 3
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 91
38074: PUSH
38075: LD_VAR 0 1
38079: PUSH
38080: LD_EXP 94
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 50
38092: PUSH
38093: EMPTY
38094: LIST
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: PPUSH
38102: CALL_OW 69
38106: ST_TO_ADDR
// if not tmp then
38107: LD_VAR 0 2
38111: NOT
38112: IFFALSE 38116
// continue ;
38114: GO 37911
// HackLink ( i , tmp ) ;
38116: LD_VAR 0 1
38120: PPUSH
38121: LD_VAR 0 2
38125: PPUSH
38126: CALL 38273 0 2
// end ;
38130: GO 37911
38132: POP
38133: POP
// end ;
38134: PPOPN 2
38136: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
38137: LD_INT 0
38139: PPUSH
38140: PPUSH
38141: PPUSH
// if not hack in hackTanks then
38142: LD_VAR 0 1
38146: PUSH
38147: LD_EXP 91
38151: IN
38152: NOT
38153: IFFALSE 38157
// exit ;
38155: GO 38268
// index := GetElementIndex ( hackTanks , hack ) ;
38157: LD_ADDR_VAR 0 4
38161: PUSH
38162: LD_EXP 91
38166: PPUSH
38167: LD_VAR 0 1
38171: PPUSH
38172: CALL 13809 0 2
38176: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
38177: LD_EXP 92
38181: PUSH
38182: LD_VAR 0 4
38186: ARRAY
38187: IFFALSE 38268
// begin for i in hackTanksCaptured [ index ] do
38189: LD_ADDR_VAR 0 3
38193: PUSH
38194: LD_EXP 92
38198: PUSH
38199: LD_VAR 0 4
38203: ARRAY
38204: PUSH
38205: FOR_IN
38206: IFFALSE 38232
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
38208: LD_VAR 0 3
38212: PUSH
38213: LD_INT 1
38215: ARRAY
38216: PPUSH
38217: LD_VAR 0 3
38221: PUSH
38222: LD_INT 2
38224: ARRAY
38225: PPUSH
38226: CALL_OW 235
38230: GO 38205
38232: POP
38233: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
38234: LD_ADDR_EXP 92
38238: PUSH
38239: LD_EXP 92
38243: PPUSH
38244: LD_VAR 0 4
38248: PPUSH
38249: EMPTY
38250: PPUSH
38251: CALL_OW 1
38255: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
38256: LD_VAR 0 1
38260: PPUSH
38261: LD_INT 0
38263: PPUSH
38264: CALL_OW 505
// end ; end ;
38268: LD_VAR 0 2
38272: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
38273: LD_INT 0
38275: PPUSH
38276: PPUSH
38277: PPUSH
// if not hack in hackTanks or not vehicles then
38278: LD_VAR 0 1
38282: PUSH
38283: LD_EXP 91
38287: IN
38288: NOT
38289: PUSH
38290: LD_VAR 0 2
38294: NOT
38295: OR
38296: IFFALSE 38300
// exit ;
38298: GO 38575
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
38300: LD_ADDR_VAR 0 2
38304: PUSH
38305: LD_VAR 0 1
38309: PPUSH
38310: LD_VAR 0 2
38314: PPUSH
38315: LD_INT 1
38317: PPUSH
38318: LD_INT 1
38320: PPUSH
38321: CALL 14459 0 4
38325: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
38326: LD_ADDR_VAR 0 5
38330: PUSH
38331: LD_EXP 91
38335: PPUSH
38336: LD_VAR 0 1
38340: PPUSH
38341: CALL 13809 0 2
38345: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
38346: LD_EXP 92
38350: PUSH
38351: LD_VAR 0 5
38355: ARRAY
38356: PUSH
38357: LD_EXP 93
38361: LESS
38362: IFFALSE 38551
// begin for i := 1 to vehicles do
38364: LD_ADDR_VAR 0 4
38368: PUSH
38369: DOUBLE
38370: LD_INT 1
38372: DEC
38373: ST_TO_ADDR
38374: LD_VAR 0 2
38378: PUSH
38379: FOR_TO
38380: IFFALSE 38549
// begin if hackTanksCaptured [ index ] = hackLimit then
38382: LD_EXP 92
38386: PUSH
38387: LD_VAR 0 5
38391: ARRAY
38392: PUSH
38393: LD_EXP 93
38397: EQUAL
38398: IFFALSE 38402
// break ;
38400: GO 38549
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
38402: LD_ADDR_EXP 95
38406: PUSH
38407: LD_EXP 95
38411: PPUSH
38412: LD_VAR 0 5
38416: PPUSH
38417: LD_EXP 95
38421: PUSH
38422: LD_VAR 0 5
38426: ARRAY
38427: PUSH
38428: LD_INT 1
38430: PLUS
38431: PPUSH
38432: CALL_OW 1
38436: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
38437: LD_ADDR_EXP 92
38441: PUSH
38442: LD_EXP 92
38446: PPUSH
38447: LD_VAR 0 5
38451: PUSH
38452: LD_EXP 92
38456: PUSH
38457: LD_VAR 0 5
38461: ARRAY
38462: PUSH
38463: LD_INT 1
38465: PLUS
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PPUSH
38471: LD_VAR 0 2
38475: PUSH
38476: LD_VAR 0 4
38480: ARRAY
38481: PUSH
38482: LD_VAR 0 2
38486: PUSH
38487: LD_VAR 0 4
38491: ARRAY
38492: PPUSH
38493: CALL_OW 255
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PPUSH
38502: CALL 14024 0 3
38506: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
38507: LD_VAR 0 2
38511: PUSH
38512: LD_VAR 0 4
38516: ARRAY
38517: PPUSH
38518: LD_VAR 0 1
38522: PPUSH
38523: CALL_OW 255
38527: PPUSH
38528: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
38532: LD_VAR 0 2
38536: PUSH
38537: LD_VAR 0 4
38541: ARRAY
38542: PPUSH
38543: CALL_OW 141
// end ;
38547: GO 38379
38549: POP
38550: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
38551: LD_VAR 0 1
38555: PPUSH
38556: LD_EXP 92
38560: PUSH
38561: LD_VAR 0 5
38565: ARRAY
38566: PUSH
38567: LD_INT 0
38569: PLUS
38570: PPUSH
38571: CALL_OW 505
// end ;
38575: LD_VAR 0 3
38579: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
38580: LD_INT 0
38582: PPUSH
38583: PPUSH
38584: PPUSH
38585: PPUSH
// if not hack in hackTanks then
38586: LD_VAR 0 1
38590: PUSH
38591: LD_EXP 91
38595: IN
38596: NOT
38597: IFFALSE 38601
// exit ;
38599: GO 38841
// index := GetElementIndex ( hackTanks , hack ) ;
38601: LD_ADDR_VAR 0 4
38605: PUSH
38606: LD_EXP 91
38610: PPUSH
38611: LD_VAR 0 1
38615: PPUSH
38616: CALL 13809 0 2
38620: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
38621: LD_ADDR_VAR 0 3
38625: PUSH
38626: DOUBLE
38627: LD_EXP 92
38631: PUSH
38632: LD_VAR 0 4
38636: ARRAY
38637: INC
38638: ST_TO_ADDR
38639: LD_INT 1
38641: PUSH
38642: FOR_DOWNTO
38643: IFFALSE 38815
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
38645: LD_ADDR_VAR 0 5
38649: PUSH
38650: LD_EXP 92
38654: PUSH
38655: LD_VAR 0 4
38659: ARRAY
38660: PUSH
38661: LD_VAR 0 3
38665: ARRAY
38666: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
38667: LD_VAR 0 5
38671: PUSH
38672: LD_INT 1
38674: ARRAY
38675: PPUSH
38676: CALL_OW 302
38680: NOT
38681: PUSH
38682: LD_VAR 0 5
38686: PUSH
38687: LD_INT 1
38689: ARRAY
38690: PPUSH
38691: CALL_OW 255
38695: PUSH
38696: LD_VAR 0 1
38700: PPUSH
38701: CALL_OW 255
38705: NONEQUAL
38706: OR
38707: IFFALSE 38813
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
38709: LD_VAR 0 5
38713: PUSH
38714: LD_INT 1
38716: ARRAY
38717: PPUSH
38718: CALL_OW 305
38722: PUSH
38723: LD_VAR 0 5
38727: PUSH
38728: LD_INT 1
38730: ARRAY
38731: PPUSH
38732: CALL_OW 255
38736: PUSH
38737: LD_VAR 0 1
38741: PPUSH
38742: CALL_OW 255
38746: EQUAL
38747: AND
38748: IFFALSE 38772
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
38750: LD_VAR 0 5
38754: PUSH
38755: LD_INT 1
38757: ARRAY
38758: PPUSH
38759: LD_VAR 0 5
38763: PUSH
38764: LD_INT 2
38766: ARRAY
38767: PPUSH
38768: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
38772: LD_ADDR_EXP 92
38776: PUSH
38777: LD_EXP 92
38781: PPUSH
38782: LD_VAR 0 4
38786: PPUSH
38787: LD_EXP 92
38791: PUSH
38792: LD_VAR 0 4
38796: ARRAY
38797: PPUSH
38798: LD_VAR 0 3
38802: PPUSH
38803: CALL_OW 3
38807: PPUSH
38808: CALL_OW 1
38812: ST_TO_ADDR
// end ; end ;
38813: GO 38642
38815: POP
38816: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
38817: LD_VAR 0 1
38821: PPUSH
38822: LD_EXP 92
38826: PUSH
38827: LD_VAR 0 4
38831: ARRAY
38832: PUSH
38833: LD_INT 0
38835: PLUS
38836: PPUSH
38837: CALL_OW 505
// end ;
38841: LD_VAR 0 2
38845: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
38846: LD_INT 0
38848: PPUSH
38849: PPUSH
38850: PPUSH
38851: PPUSH
// if not hack in hackTanks then
38852: LD_VAR 0 1
38856: PUSH
38857: LD_EXP 91
38861: IN
38862: NOT
38863: IFFALSE 38867
// exit ;
38865: GO 38952
// index := GetElementIndex ( hackTanks , hack ) ;
38867: LD_ADDR_VAR 0 5
38871: PUSH
38872: LD_EXP 91
38876: PPUSH
38877: LD_VAR 0 1
38881: PPUSH
38882: CALL 13809 0 2
38886: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
38887: LD_ADDR_VAR 0 4
38891: PUSH
38892: DOUBLE
38893: LD_INT 1
38895: DEC
38896: ST_TO_ADDR
38897: LD_EXP 92
38901: PUSH
38902: LD_VAR 0 5
38906: ARRAY
38907: PUSH
38908: FOR_TO
38909: IFFALSE 38950
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
38911: LD_EXP 92
38915: PUSH
38916: LD_VAR 0 5
38920: ARRAY
38921: PUSH
38922: LD_VAR 0 4
38926: ARRAY
38927: PUSH
38928: LD_INT 1
38930: ARRAY
38931: PUSH
38932: LD_VAR 0 2
38936: EQUAL
38937: IFFALSE 38948
// KillUnit ( vehicle ) ;
38939: LD_VAR 0 2
38943: PPUSH
38944: CALL_OW 66
38948: GO 38908
38950: POP
38951: POP
// end ;
38952: LD_VAR 0 3
38956: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
38957: LD_EXP 96
38961: NOT
38962: IFFALSE 38997
38964: GO 38966
38966: DISABLE
// begin initMiner := true ;
38967: LD_ADDR_EXP 96
38971: PUSH
38972: LD_INT 1
38974: ST_TO_ADDR
// minersList := [ ] ;
38975: LD_ADDR_EXP 97
38979: PUSH
38980: EMPTY
38981: ST_TO_ADDR
// minerMinesList := [ ] ;
38982: LD_ADDR_EXP 98
38986: PUSH
38987: EMPTY
38988: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
38989: LD_ADDR_EXP 99
38993: PUSH
38994: LD_INT 5
38996: ST_TO_ADDR
// end ;
38997: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
38998: LD_EXP 96
39002: PUSH
39003: LD_INT 34
39005: PUSH
39006: LD_INT 81
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PPUSH
39013: CALL_OW 69
39017: AND
39018: IFFALSE 39479
39020: GO 39022
39022: DISABLE
39023: LD_INT 0
39025: PPUSH
39026: PPUSH
39027: PPUSH
39028: PPUSH
// begin enable ;
39029: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
39030: LD_ADDR_VAR 0 1
39034: PUSH
39035: LD_INT 34
39037: PUSH
39038: LD_INT 81
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PPUSH
39045: CALL_OW 69
39049: PUSH
39050: FOR_IN
39051: IFFALSE 39123
// begin if not i in minersList then
39053: LD_VAR 0 1
39057: PUSH
39058: LD_EXP 97
39062: IN
39063: NOT
39064: IFFALSE 39121
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
39066: LD_ADDR_EXP 97
39070: PUSH
39071: LD_EXP 97
39075: PPUSH
39076: LD_EXP 97
39080: PUSH
39081: LD_INT 1
39083: PLUS
39084: PPUSH
39085: LD_VAR 0 1
39089: PPUSH
39090: CALL_OW 1
39094: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
39095: LD_ADDR_EXP 98
39099: PUSH
39100: LD_EXP 98
39104: PPUSH
39105: LD_EXP 98
39109: PUSH
39110: LD_INT 1
39112: PLUS
39113: PPUSH
39114: EMPTY
39115: PPUSH
39116: CALL_OW 1
39120: ST_TO_ADDR
// end end ;
39121: GO 39050
39123: POP
39124: POP
// for i := minerMinesList downto 1 do
39125: LD_ADDR_VAR 0 1
39129: PUSH
39130: DOUBLE
39131: LD_EXP 98
39135: INC
39136: ST_TO_ADDR
39137: LD_INT 1
39139: PUSH
39140: FOR_DOWNTO
39141: IFFALSE 39477
// begin if IsLive ( minersList [ i ] ) then
39143: LD_EXP 97
39147: PUSH
39148: LD_VAR 0 1
39152: ARRAY
39153: PPUSH
39154: CALL_OW 300
39158: IFFALSE 39186
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
39160: LD_EXP 97
39164: PUSH
39165: LD_VAR 0 1
39169: ARRAY
39170: PPUSH
39171: LD_EXP 98
39175: PUSH
39176: LD_VAR 0 1
39180: ARRAY
39181: PPUSH
39182: CALL_OW 505
// if not minerMinesList [ i ] then
39186: LD_EXP 98
39190: PUSH
39191: LD_VAR 0 1
39195: ARRAY
39196: NOT
39197: IFFALSE 39201
// continue ;
39199: GO 39140
// for j := minerMinesList [ i ] downto 1 do
39201: LD_ADDR_VAR 0 2
39205: PUSH
39206: DOUBLE
39207: LD_EXP 98
39211: PUSH
39212: LD_VAR 0 1
39216: ARRAY
39217: INC
39218: ST_TO_ADDR
39219: LD_INT 1
39221: PUSH
39222: FOR_DOWNTO
39223: IFFALSE 39473
// begin side := GetSide ( minersList [ i ] ) ;
39225: LD_ADDR_VAR 0 3
39229: PUSH
39230: LD_EXP 97
39234: PUSH
39235: LD_VAR 0 1
39239: ARRAY
39240: PPUSH
39241: CALL_OW 255
39245: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
39246: LD_ADDR_VAR 0 4
39250: PUSH
39251: LD_EXP 98
39255: PUSH
39256: LD_VAR 0 1
39260: ARRAY
39261: PUSH
39262: LD_VAR 0 2
39266: ARRAY
39267: PUSH
39268: LD_INT 1
39270: ARRAY
39271: PPUSH
39272: LD_EXP 98
39276: PUSH
39277: LD_VAR 0 1
39281: ARRAY
39282: PUSH
39283: LD_VAR 0 2
39287: ARRAY
39288: PUSH
39289: LD_INT 2
39291: ARRAY
39292: PPUSH
39293: CALL_OW 428
39297: ST_TO_ADDR
// if not tmp then
39298: LD_VAR 0 4
39302: NOT
39303: IFFALSE 39307
// continue ;
39305: GO 39222
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
39307: LD_VAR 0 4
39311: PUSH
39312: LD_INT 81
39314: PUSH
39315: LD_VAR 0 3
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PPUSH
39324: CALL_OW 69
39328: IN
39329: PUSH
39330: LD_EXP 98
39334: PUSH
39335: LD_VAR 0 1
39339: ARRAY
39340: PUSH
39341: LD_VAR 0 2
39345: ARRAY
39346: PUSH
39347: LD_INT 1
39349: ARRAY
39350: PPUSH
39351: LD_EXP 98
39355: PUSH
39356: LD_VAR 0 1
39360: ARRAY
39361: PUSH
39362: LD_VAR 0 2
39366: ARRAY
39367: PUSH
39368: LD_INT 2
39370: ARRAY
39371: PPUSH
39372: CALL_OW 458
39376: AND
39377: IFFALSE 39471
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
39379: LD_EXP 98
39383: PUSH
39384: LD_VAR 0 1
39388: ARRAY
39389: PUSH
39390: LD_VAR 0 2
39394: ARRAY
39395: PUSH
39396: LD_INT 1
39398: ARRAY
39399: PPUSH
39400: LD_EXP 98
39404: PUSH
39405: LD_VAR 0 1
39409: ARRAY
39410: PUSH
39411: LD_VAR 0 2
39415: ARRAY
39416: PUSH
39417: LD_INT 2
39419: ARRAY
39420: PPUSH
39421: LD_VAR 0 3
39425: PPUSH
39426: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
39430: LD_ADDR_EXP 98
39434: PUSH
39435: LD_EXP 98
39439: PPUSH
39440: LD_VAR 0 1
39444: PPUSH
39445: LD_EXP 98
39449: PUSH
39450: LD_VAR 0 1
39454: ARRAY
39455: PPUSH
39456: LD_VAR 0 2
39460: PPUSH
39461: CALL_OW 3
39465: PPUSH
39466: CALL_OW 1
39470: ST_TO_ADDR
// end ; end ;
39471: GO 39222
39473: POP
39474: POP
// end ;
39475: GO 39140
39477: POP
39478: POP
// end ;
39479: PPOPN 4
39481: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
39482: LD_INT 0
39484: PPUSH
39485: PPUSH
// result := false ;
39486: LD_ADDR_VAR 0 4
39490: PUSH
39491: LD_INT 0
39493: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
39494: LD_VAR 0 1
39498: PPUSH
39499: CALL_OW 264
39503: PUSH
39504: LD_INT 81
39506: EQUAL
39507: NOT
39508: IFFALSE 39512
// exit ;
39510: GO 39752
// index := GetElementIndex ( minersList , unit ) ;
39512: LD_ADDR_VAR 0 5
39516: PUSH
39517: LD_EXP 97
39521: PPUSH
39522: LD_VAR 0 1
39526: PPUSH
39527: CALL 13809 0 2
39531: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
39532: LD_EXP 98
39536: PUSH
39537: LD_VAR 0 5
39541: ARRAY
39542: PUSH
39543: LD_EXP 99
39547: GREATEREQUAL
39548: IFFALSE 39552
// exit ;
39550: GO 39752
// ComMoveXY ( unit , x , y ) ;
39552: LD_VAR 0 1
39556: PPUSH
39557: LD_VAR 0 2
39561: PPUSH
39562: LD_VAR 0 3
39566: PPUSH
39567: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
39571: LD_INT 35
39573: PPUSH
39574: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
39578: LD_VAR 0 1
39582: PPUSH
39583: LD_VAR 0 2
39587: PPUSH
39588: LD_VAR 0 3
39592: PPUSH
39593: NOP4
39597: NOT
39598: PUSH
39599: LD_VAR 0 1
39603: PPUSH
39604: CALL_OW 314
39608: AND
39609: IFFALSE 39613
// exit ;
39611: GO 39752
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
39613: LD_VAR 0 2
39617: PPUSH
39618: LD_VAR 0 3
39622: PPUSH
39623: CALL_OW 428
39627: PUSH
39628: LD_VAR 0 1
39632: EQUAL
39633: PUSH
39634: LD_VAR 0 1
39638: PPUSH
39639: CALL_OW 314
39643: NOT
39644: AND
39645: IFFALSE 39571
// PlaySoundXY ( x , y , PlantMine ) ;
39647: LD_VAR 0 2
39651: PPUSH
39652: LD_VAR 0 3
39656: PPUSH
39657: LD_STRING PlantMine
39659: PPUSH
39660: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
39664: LD_VAR 0 2
39668: PPUSH
39669: LD_VAR 0 3
39673: PPUSH
39674: LD_VAR 0 1
39678: PPUSH
39679: CALL_OW 255
39683: PPUSH
39684: LD_INT 0
39686: PPUSH
39687: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
39691: LD_ADDR_EXP 98
39695: PUSH
39696: LD_EXP 98
39700: PPUSH
39701: LD_VAR 0 5
39705: PUSH
39706: LD_EXP 98
39710: PUSH
39711: LD_VAR 0 5
39715: ARRAY
39716: PUSH
39717: LD_INT 1
39719: PLUS
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PPUSH
39725: LD_VAR 0 2
39729: PUSH
39730: LD_VAR 0 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PPUSH
39739: CALL 14024 0 3
39743: ST_TO_ADDR
// result := true ;
39744: LD_ADDR_VAR 0 4
39748: PUSH
39749: LD_INT 1
39751: ST_TO_ADDR
// end ;
39752: LD_VAR 0 4
39756: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
39757: LD_INT 0
39759: PPUSH
39760: PPUSH
39761: PPUSH
// if not unit in minersList then
39762: LD_VAR 0 1
39766: PUSH
39767: LD_EXP 97
39771: IN
39772: NOT
39773: IFFALSE 39777
// exit ;
39775: GO 40169
// index := GetElementIndex ( minersList , unit ) ;
39777: LD_ADDR_VAR 0 6
39781: PUSH
39782: LD_EXP 97
39786: PPUSH
39787: LD_VAR 0 1
39791: PPUSH
39792: CALL 13809 0 2
39796: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
39797: LD_ADDR_VAR 0 5
39801: PUSH
39802: DOUBLE
39803: LD_EXP 98
39807: PUSH
39808: LD_VAR 0 6
39812: ARRAY
39813: INC
39814: ST_TO_ADDR
39815: LD_INT 1
39817: PUSH
39818: FOR_DOWNTO
39819: IFFALSE 39980
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
39821: LD_EXP 98
39825: PUSH
39826: LD_VAR 0 6
39830: ARRAY
39831: PUSH
39832: LD_VAR 0 5
39836: ARRAY
39837: PUSH
39838: LD_INT 1
39840: ARRAY
39841: PUSH
39842: LD_VAR 0 2
39846: EQUAL
39847: PUSH
39848: LD_EXP 98
39852: PUSH
39853: LD_VAR 0 6
39857: ARRAY
39858: PUSH
39859: LD_VAR 0 5
39863: ARRAY
39864: PUSH
39865: LD_INT 2
39867: ARRAY
39868: PUSH
39869: LD_VAR 0 3
39873: EQUAL
39874: AND
39875: IFFALSE 39978
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
39877: LD_EXP 98
39881: PUSH
39882: LD_VAR 0 6
39886: ARRAY
39887: PUSH
39888: LD_VAR 0 5
39892: ARRAY
39893: PUSH
39894: LD_INT 1
39896: ARRAY
39897: PPUSH
39898: LD_EXP 98
39902: PUSH
39903: LD_VAR 0 6
39907: ARRAY
39908: PUSH
39909: LD_VAR 0 5
39913: ARRAY
39914: PUSH
39915: LD_INT 2
39917: ARRAY
39918: PPUSH
39919: LD_VAR 0 1
39923: PPUSH
39924: CALL_OW 255
39928: PPUSH
39929: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
39933: LD_ADDR_EXP 98
39937: PUSH
39938: LD_EXP 98
39942: PPUSH
39943: LD_VAR 0 6
39947: PPUSH
39948: LD_EXP 98
39952: PUSH
39953: LD_VAR 0 6
39957: ARRAY
39958: PPUSH
39959: LD_VAR 0 5
39963: PPUSH
39964: CALL_OW 3
39968: PPUSH
39969: CALL_OW 1
39973: ST_TO_ADDR
// exit ;
39974: POP
39975: POP
39976: GO 40169
// end ; end ;
39978: GO 39818
39980: POP
39981: POP
// for i := minerMinesList [ index ] downto 1 do
39982: LD_ADDR_VAR 0 5
39986: PUSH
39987: DOUBLE
39988: LD_EXP 98
39992: PUSH
39993: LD_VAR 0 6
39997: ARRAY
39998: INC
39999: ST_TO_ADDR
40000: LD_INT 1
40002: PUSH
40003: FOR_DOWNTO
40004: IFFALSE 40167
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
40006: LD_EXP 98
40010: PUSH
40011: LD_VAR 0 6
40015: ARRAY
40016: PUSH
40017: LD_VAR 0 5
40021: ARRAY
40022: PUSH
40023: LD_INT 1
40025: ARRAY
40026: PPUSH
40027: LD_EXP 98
40031: PUSH
40032: LD_VAR 0 6
40036: ARRAY
40037: PUSH
40038: LD_VAR 0 5
40042: ARRAY
40043: PUSH
40044: LD_INT 2
40046: ARRAY
40047: PPUSH
40048: LD_VAR 0 2
40052: PPUSH
40053: LD_VAR 0 3
40057: PPUSH
40058: CALL_OW 298
40062: PUSH
40063: LD_INT 6
40065: LESS
40066: IFFALSE 40165
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
40068: LD_EXP 98
40072: PUSH
40073: LD_VAR 0 6
40077: ARRAY
40078: PUSH
40079: LD_VAR 0 5
40083: ARRAY
40084: PUSH
40085: LD_INT 1
40087: ARRAY
40088: PPUSH
40089: LD_EXP 98
40093: PUSH
40094: LD_VAR 0 6
40098: ARRAY
40099: PUSH
40100: LD_VAR 0 5
40104: ARRAY
40105: PUSH
40106: LD_INT 2
40108: ARRAY
40109: PPUSH
40110: LD_VAR 0 1
40114: PPUSH
40115: CALL_OW 255
40119: PPUSH
40120: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
40124: LD_ADDR_EXP 98
40128: PUSH
40129: LD_EXP 98
40133: PPUSH
40134: LD_VAR 0 6
40138: PPUSH
40139: LD_EXP 98
40143: PUSH
40144: LD_VAR 0 6
40148: ARRAY
40149: PPUSH
40150: LD_VAR 0 5
40154: PPUSH
40155: CALL_OW 3
40159: PPUSH
40160: CALL_OW 1
40164: ST_TO_ADDR
// end ; end ;
40165: GO 40003
40167: POP
40168: POP
// end ;
40169: LD_VAR 0 4
40173: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
40174: LD_INT 0
40176: PPUSH
40177: PPUSH
40178: PPUSH
40179: PPUSH
40180: PPUSH
40181: PPUSH
40182: PPUSH
40183: PPUSH
40184: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
40185: LD_VAR 0 1
40189: PPUSH
40190: CALL_OW 264
40194: PUSH
40195: LD_INT 81
40197: EQUAL
40198: NOT
40199: PUSH
40200: LD_VAR 0 1
40204: PUSH
40205: LD_EXP 97
40209: IN
40210: NOT
40211: OR
40212: IFFALSE 40216
// exit ;
40214: GO 40538
// index := GetElementIndex ( minersList , unit ) ;
40216: LD_ADDR_VAR 0 6
40220: PUSH
40221: LD_EXP 97
40225: PPUSH
40226: LD_VAR 0 1
40230: PPUSH
40231: CALL 13809 0 2
40235: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
40236: LD_ADDR_VAR 0 8
40240: PUSH
40241: LD_EXP 99
40245: PUSH
40246: LD_EXP 98
40250: PUSH
40251: LD_VAR 0 6
40255: ARRAY
40256: MINUS
40257: ST_TO_ADDR
// if not minesFreeAmount then
40258: LD_VAR 0 8
40262: NOT
40263: IFFALSE 40267
// exit ;
40265: GO 40538
// tmp := [ ] ;
40267: LD_ADDR_VAR 0 7
40271: PUSH
40272: EMPTY
40273: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
40274: LD_ADDR_VAR 0 5
40278: PUSH
40279: DOUBLE
40280: LD_INT 1
40282: DEC
40283: ST_TO_ADDR
40284: LD_VAR 0 8
40288: PUSH
40289: FOR_TO
40290: IFFALSE 40485
// begin _d := rand ( 0 , 5 ) ;
40292: LD_ADDR_VAR 0 11
40296: PUSH
40297: LD_INT 0
40299: PPUSH
40300: LD_INT 5
40302: PPUSH
40303: CALL_OW 12
40307: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
40308: LD_ADDR_VAR 0 12
40312: PUSH
40313: LD_INT 2
40315: PPUSH
40316: LD_INT 6
40318: PPUSH
40319: CALL_OW 12
40323: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
40324: LD_ADDR_VAR 0 9
40328: PUSH
40329: LD_VAR 0 2
40333: PPUSH
40334: LD_VAR 0 11
40338: PPUSH
40339: LD_VAR 0 12
40343: PPUSH
40344: CALL_OW 272
40348: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
40349: LD_ADDR_VAR 0 10
40353: PUSH
40354: LD_VAR 0 3
40358: PPUSH
40359: LD_VAR 0 11
40363: PPUSH
40364: LD_VAR 0 12
40368: PPUSH
40369: CALL_OW 273
40373: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
40374: LD_VAR 0 9
40378: PPUSH
40379: LD_VAR 0 10
40383: PPUSH
40384: CALL_OW 488
40388: PUSH
40389: LD_VAR 0 9
40393: PUSH
40394: LD_VAR 0 10
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_VAR 0 7
40407: IN
40408: NOT
40409: AND
40410: PUSH
40411: LD_VAR 0 9
40415: PPUSH
40416: LD_VAR 0 10
40420: PPUSH
40421: CALL_OW 458
40425: NOT
40426: AND
40427: IFFALSE 40469
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
40429: LD_ADDR_VAR 0 7
40433: PUSH
40434: LD_VAR 0 7
40438: PPUSH
40439: LD_VAR 0 7
40443: PUSH
40444: LD_INT 1
40446: PLUS
40447: PPUSH
40448: LD_VAR 0 9
40452: PUSH
40453: LD_VAR 0 10
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PPUSH
40462: CALL_OW 1
40466: ST_TO_ADDR
40467: GO 40483
// i := i - 1 ;
40469: LD_ADDR_VAR 0 5
40473: PUSH
40474: LD_VAR 0 5
40478: PUSH
40479: LD_INT 1
40481: MINUS
40482: ST_TO_ADDR
// end ;
40483: GO 40289
40485: POP
40486: POP
// for i in tmp do
40487: LD_ADDR_VAR 0 5
40491: PUSH
40492: LD_VAR 0 7
40496: PUSH
40497: FOR_IN
40498: IFFALSE 40536
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
40500: LD_VAR 0 1
40504: PPUSH
40505: LD_VAR 0 5
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: PPUSH
40514: LD_VAR 0 5
40518: PUSH
40519: LD_INT 2
40521: ARRAY
40522: PPUSH
40523: CALL 39482 0 3
40527: NOT
40528: IFFALSE 40534
// exit ;
40530: POP
40531: POP
40532: GO 40538
40534: GO 40497
40536: POP
40537: POP
// end ;
40538: LD_VAR 0 4
40542: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
40543: LD_INT 0
40545: PPUSH
40546: PPUSH
40547: PPUSH
40548: PPUSH
40549: PPUSH
40550: PPUSH
40551: PPUSH
// if not GetClass ( unit ) = class_sniper then
40552: LD_VAR 0 1
40556: PPUSH
40557: CALL_OW 257
40561: PUSH
40562: LD_INT 5
40564: EQUAL
40565: NOT
40566: IFFALSE 40570
// exit ;
40568: GO 40958
// dist := 8 ;
40570: LD_ADDR_VAR 0 5
40574: PUSH
40575: LD_INT 8
40577: ST_TO_ADDR
// viewRange := 12 ;
40578: LD_ADDR_VAR 0 7
40582: PUSH
40583: LD_INT 12
40585: ST_TO_ADDR
// side := GetSide ( unit ) ;
40586: LD_ADDR_VAR 0 6
40590: PUSH
40591: LD_VAR 0 1
40595: PPUSH
40596: CALL_OW 255
40600: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
40601: LD_INT 61
40603: PPUSH
40604: LD_VAR 0 6
40608: PPUSH
40609: CALL_OW 321
40613: PUSH
40614: LD_INT 2
40616: EQUAL
40617: IFFALSE 40627
// viewRange := 16 ;
40619: LD_ADDR_VAR 0 7
40623: PUSH
40624: LD_INT 16
40626: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
40627: LD_VAR 0 1
40631: PPUSH
40632: LD_VAR 0 2
40636: PPUSH
40637: LD_VAR 0 3
40641: PPUSH
40642: CALL_OW 297
40646: PUSH
40647: LD_VAR 0 5
40651: GREATER
40652: IFFALSE 40731
// begin ComMoveXY ( unit , x , y ) ;
40654: LD_VAR 0 1
40658: PPUSH
40659: LD_VAR 0 2
40663: PPUSH
40664: LD_VAR 0 3
40668: PPUSH
40669: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
40673: LD_INT 35
40675: PPUSH
40676: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
40680: LD_VAR 0 1
40684: PPUSH
40685: LD_VAR 0 2
40689: PPUSH
40690: LD_VAR 0 3
40694: PPUSH
40695: NOP4
40699: NOT
40700: IFFALSE 40704
// exit ;
40702: GO 40958
// until GetDistUnitXY ( unit , x , y ) < dist ;
40704: LD_VAR 0 1
40708: PPUSH
40709: LD_VAR 0 2
40713: PPUSH
40714: LD_VAR 0 3
40718: PPUSH
40719: CALL_OW 297
40723: PUSH
40724: LD_VAR 0 5
40728: LESS
40729: IFFALSE 40673
// end ; ComTurnXY ( unit , x , y ) ;
40731: LD_VAR 0 1
40735: PPUSH
40736: LD_VAR 0 2
40740: PPUSH
40741: LD_VAR 0 3
40745: PPUSH
40746: CALL_OW 118
// wait ( 5 ) ;
40750: LD_INT 5
40752: PPUSH
40753: CALL_OW 67
// _d := GetDir ( unit ) ;
40757: LD_ADDR_VAR 0 10
40761: PUSH
40762: LD_VAR 0 1
40766: PPUSH
40767: CALL_OW 254
40771: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
40772: LD_ADDR_VAR 0 8
40776: PUSH
40777: LD_VAR 0 1
40781: PPUSH
40782: CALL_OW 250
40786: PPUSH
40787: LD_VAR 0 10
40791: PPUSH
40792: LD_VAR 0 5
40796: PPUSH
40797: CALL_OW 272
40801: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
40802: LD_ADDR_VAR 0 9
40806: PUSH
40807: LD_VAR 0 1
40811: PPUSH
40812: CALL_OW 251
40816: PPUSH
40817: LD_VAR 0 10
40821: PPUSH
40822: LD_VAR 0 5
40826: PPUSH
40827: CALL_OW 273
40831: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
40832: LD_VAR 0 8
40836: PPUSH
40837: LD_VAR 0 9
40841: PPUSH
40842: CALL_OW 488
40846: NOT
40847: IFFALSE 40851
// exit ;
40849: GO 40958
// ComAnimCustom ( unit , 1 ) ;
40851: LD_VAR 0 1
40855: PPUSH
40856: LD_INT 1
40858: PPUSH
40859: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
40863: LD_VAR 0 8
40867: PPUSH
40868: LD_VAR 0 9
40872: PPUSH
40873: LD_VAR 0 6
40877: PPUSH
40878: LD_VAR 0 7
40882: PPUSH
40883: CALL_OW 330
// repeat wait ( 1 ) ;
40887: LD_INT 1
40889: PPUSH
40890: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
40894: LD_VAR 0 1
40898: PPUSH
40899: CALL_OW 316
40903: PUSH
40904: LD_VAR 0 1
40908: PPUSH
40909: CALL_OW 314
40913: OR
40914: PUSH
40915: LD_VAR 0 1
40919: PPUSH
40920: CALL_OW 302
40924: NOT
40925: OR
40926: PUSH
40927: LD_VAR 0 1
40931: PPUSH
40932: CALL_OW 301
40936: OR
40937: IFFALSE 40887
// RemoveSeeing ( _x , _y , side ) ;
40939: LD_VAR 0 8
40943: PPUSH
40944: LD_VAR 0 9
40948: PPUSH
40949: LD_VAR 0 6
40953: PPUSH
40954: CALL_OW 331
// end ; end_of_file
40958: LD_VAR 0 4
40962: RET
