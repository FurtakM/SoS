// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3719 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 405
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 2 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 2
 265: ST_TO_ADDR
// Side_Positions := [ 0 , 1 , 0 , 0 , 2 , 0 , 3 , 0 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 0
 273: PUSH
 274: LD_INT 1
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 0
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 0
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 0
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 0 , 3 , 0 , 0 , 3 , 0 , 3 , 0 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 0
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 0
 360: PUSH
 361: LD_INT 3
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 3
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 2 , 5 , 7 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 5
 393: PUSH
 394: LD_INT 7
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: EMPTY
 403: LIST
 404: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 405: LD_ADDR_EXP 7
 409: PUSH
 410: LD_INT 203
 412: PUSH
 413: LD_INT 174
 415: PUSH
 416: EMPTY
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 114
 422: PUSH
 423: LD_INT 171
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 26
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: PUSH
 448: EMPTY
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: ST_TO_ADDR
// Bot_Side := 2 ;
 460: LD_ADDR_EXP 8
 464: PUSH
 465: LD_INT 2
 467: ST_TO_ADDR
// for i = 1 to 8 do
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: DOUBLE
 474: LD_INT 1
 476: DEC
 477: ST_TO_ADDR
 478: LD_INT 8
 480: PUSH
 481: FOR_TO
 482: IFFALSE 625
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 484: LD_VAR 0 2
 488: PPUSH
 489: CALL_OW 530
 493: PUSH
 494: LD_VAR 0 2
 498: PPUSH
 499: CALL_OW 532
 503: OR
 504: IFFALSE 578
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 506: LD_ADDR_EXP 2
 510: PUSH
 511: LD_EXP 2
 515: PPUSH
 516: LD_VAR 0 2
 520: PPUSH
 521: LD_INT 0
 523: PPUSH
 524: CALL_OW 1
 528: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 529: LD_ADDR_EXP 5
 533: PUSH
 534: LD_EXP 5
 538: PPUSH
 539: LD_EXP 3
 543: PUSH
 544: LD_VAR 0 2
 548: ARRAY
 549: PPUSH
 550: LD_EXP 5
 554: PUSH
 555: LD_EXP 3
 559: PUSH
 560: LD_VAR 0 2
 564: ARRAY
 565: ARRAY
 566: PUSH
 567: LD_VAR 0 2
 571: DIFF
 572: PPUSH
 573: CALL_OW 1
 577: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 578: LD_EXP 4
 582: PUSH
 583: LD_VAR 0 2
 587: ARRAY
 588: PUSH
 589: LD_EXP 4
 593: PUSH
 594: LD_INT 3
 596: NONEQUAL
 597: AND
 598: IFFALSE 623
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 600: LD_ADDR_EXP 4
 604: PUSH
 605: LD_EXP 4
 609: PPUSH
 610: LD_VAR 0 2
 614: PPUSH
 615: LD_INT 3
 617: PPUSH
 618: CALL_OW 1
 622: ST_TO_ADDR
// end ;
 623: GO 481
 625: POP
 626: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 627: LD_INT 2
 629: PUSH
 630: LD_EXP 8
 634: EQUAL
 635: PUSH
 636: LD_EXP 2
 640: PUSH
 641: LD_INT 2
 643: ARRAY
 644: AND
 645: IFFALSE 655
// bot_side := 5 ;
 647: LD_ADDR_EXP 8
 651: PUSH
 652: LD_INT 5
 654: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 655: LD_INT 5
 657: PUSH
 658: LD_EXP 8
 662: EQUAL
 663: PUSH
 664: LD_EXP 2
 668: PUSH
 669: LD_INT 5
 671: ARRAY
 672: AND
 673: IFFALSE 683
// bot_side := 8 ;
 675: LD_ADDR_EXP 8
 679: PUSH
 680: LD_INT 8
 682: ST_TO_ADDR
// Team_Game := false ;
 683: LD_ADDR_EXP 6
 687: PUSH
 688: LD_INT 0
 690: ST_TO_ADDR
// for i = 1 to 8 do
 691: LD_ADDR_VAR 0 2
 695: PUSH
 696: DOUBLE
 697: LD_INT 1
 699: DEC
 700: ST_TO_ADDR
 701: LD_INT 8
 703: PUSH
 704: FOR_TO
 705: IFFALSE 731
// if Side_Teams [ i ] then
 707: LD_EXP 3
 711: PUSH
 712: LD_VAR 0 2
 716: ARRAY
 717: IFFALSE 729
// begin Team_Game := true ;
 719: LD_ADDR_EXP 6
 723: PUSH
 724: LD_INT 1
 726: ST_TO_ADDR
// break ;
 727: GO 731
// end ;
 729: GO 704
 731: POP
 732: POP
// for i = 1 to 8 do
 733: LD_ADDR_VAR 0 2
 737: PUSH
 738: DOUBLE
 739: LD_INT 1
 741: DEC
 742: ST_TO_ADDR
 743: LD_INT 8
 745: PUSH
 746: FOR_TO
 747: IFFALSE 783
// if i <> bot_side then
 749: LD_VAR 0 2
 753: PUSH
 754: LD_EXP 8
 758: NONEQUAL
 759: IFFALSE 781
// SetAttitude ( i , bot_side , att_enemy , true ) ;
 761: LD_VAR 0 2
 765: PPUSH
 766: LD_EXP 8
 770: PPUSH
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 1
 776: PPUSH
 777: CALL_OW 80
 781: GO 746
 783: POP
 784: POP
// for i in Teams do
 785: LD_ADDR_VAR 0 2
 789: PUSH
 790: LD_EXP 5
 794: PUSH
 795: FOR_IN
 796: IFFALSE 876
// for j = 2 to i do
 798: LD_ADDR_VAR 0 3
 802: PUSH
 803: DOUBLE
 804: LD_INT 2
 806: DEC
 807: ST_TO_ADDR
 808: LD_VAR 0 2
 812: PUSH
 813: FOR_TO
 814: IFFALSE 872
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 816: LD_VAR 0 2
 820: PUSH
 821: LD_VAR 0 3
 825: ARRAY
 826: PPUSH
 827: LD_VAR 0 2
 831: PUSH
 832: LD_INT 1
 834: ARRAY
 835: PPUSH
 836: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 840: LD_VAR 0 2
 844: PUSH
 845: LD_VAR 0 3
 849: ARRAY
 850: PPUSH
 851: LD_VAR 0 2
 855: PUSH
 856: LD_INT 1
 858: ARRAY
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 1
 865: PPUSH
 866: CALL_OW 80
// end ;
 870: GO 813
 872: POP
 873: POP
 874: GO 795
 876: POP
 877: POP
// if not Multiplayer then
 878: LD_OWVAR 4
 882: NOT
 883: IFFALSE 920
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 885: LD_ADDR_EXP 16
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 1
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: LD_INT 3
 907: PUSH
 908: LD_INT 3
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 920: LD_ADDR_EXP 10
 924: PUSH
 925: LD_INT 9
 927: PUSH
 928: LD_INT 12
 930: PUSH
 931: LD_INT 15
 933: PUSH
 934: LD_INT 24
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_EXP 16
 947: PUSH
 948: LD_INT 1
 950: ARRAY
 951: ARRAY
 952: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 953: LD_ADDR_EXP 11
 957: PUSH
 958: LD_INT 2
 960: PUSH
 961: LD_INT 4
 963: PUSH
 964: LD_INT 6
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_EXP 16
 980: PUSH
 981: LD_INT 2
 983: ARRAY
 984: ARRAY
 985: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 986: LD_ADDR_EXP 12
 990: PUSH
 991: LD_INT 1050
 993: PUSH
 994: LD_INT 875
 996: PUSH
 997: LD_INT 700
 999: PUSH
1000: LD_INT 595
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_EXP 16
1013: PUSH
1014: LD_INT 3
1016: ARRAY
1017: ARRAY
1018: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
1019: LD_ADDR_EXP 13
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: LD_INT 10500
1029: PUSH
1030: LD_INT 6300
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: PUSH
1038: LD_EXP 16
1042: PUSH
1043: LD_INT 4
1045: ARRAY
1046: ARRAY
1047: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
1048: LD_ADDR_EXP 14
1052: PUSH
1053: LD_INT 0
1055: PUSH
1056: LD_INT 31500
1058: PUSH
1059: LD_INT 10500
1061: PUSH
1062: EMPTY
1063: LIST
1064: LIST
1065: LIST
1066: PUSH
1067: LD_EXP 16
1071: PUSH
1072: LD_INT 4
1074: ARRAY
1075: ARRAY
1076: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1077: LD_ADDR_EXP 15
1081: PUSH
1082: LD_INT 0
1084: PUSH
1085: LD_INT 3
1087: PUSH
1088: LD_INT 5
1090: PUSH
1091: LD_INT 7
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_EXP 16
1104: PUSH
1105: LD_INT 5
1107: ARRAY
1108: ARRAY
1109: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1110: LD_ADDR_OWVAR 67
1114: PUSH
1115: LD_INT 1
1117: PUSH
1118: LD_INT 2
1120: PUSH
1121: LD_INT 3
1123: PUSH
1124: EMPTY
1125: LIST
1126: LIST
1127: LIST
1128: PUSH
1129: LD_EXP 16
1133: PUSH
1134: LD_INT 6
1136: ARRAY
1137: ARRAY
1138: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1139: LD_ADDR_EXP 26
1143: PUSH
1144: LD_INT 0
1146: PUSH
1147: LD_INT 1
1149: PUSH
1150: LD_INT 2
1152: PUSH
1153: EMPTY
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_EXP 16
1162: PUSH
1163: LD_INT 7
1165: ARRAY
1166: ARRAY
1167: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1168: LD_ADDR_EXP 23
1172: PUSH
1173: LD_INT 11353
1175: PUSH
1176: LD_INT 12244
1178: PUSH
1179: LD_INT 44444
1181: PUSH
1182: LD_INT 12345
1184: PUSH
1185: LD_INT 43413
1187: PUSH
1188: LD_INT 14152
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1199: LD_ADDR_EXP 24
1203: PUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_INT 6
1209: PPUSH
1210: CALL_OW 12
1214: ST_TO_ADDR
// if bot_side <> 2 then
1215: LD_EXP 8
1219: PUSH
1220: LD_INT 2
1222: NONEQUAL
1223: IFFALSE 1266
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1225: LD_ADDR_VAR 0 2
1229: PUSH
1230: LD_INT 22
1232: PUSH
1233: LD_INT 2
1235: PUSH
1236: EMPTY
1237: LIST
1238: LIST
1239: PPUSH
1240: CALL_OW 69
1244: PUSH
1245: FOR_IN
1246: IFFALSE 1264
// SetSide ( i , bot_side ) ;
1248: LD_VAR 0 2
1252: PPUSH
1253: LD_EXP 8
1257: PPUSH
1258: CALL_OW 235
1262: GO 1245
1264: POP
1265: POP
// ResetFog ;
1266: CALL_OW 335
// PreparePeople ( ) ;
1270: CALL 2100 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1274: LD_ADDR_EXP 18
1278: PUSH
1279: LD_INT 14
1281: PUSH
1282: LD_INT 15
1284: PUSH
1285: LD_INT 16
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: ST_TO_ADDR
// if amount_of_apeman then
1293: LD_EXP 15
1297: IFFALSE 1347
// for j in apeman_areas do
1299: LD_ADDR_VAR 0 3
1303: PUSH
1304: LD_EXP 18
1308: PUSH
1309: FOR_IN
1310: IFFALSE 1345
// for i = 1 to amount_of_apeman do
1312: LD_ADDR_VAR 0 2
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_EXP 15
1326: PUSH
1327: FOR_TO
1328: IFFALSE 1341
// AddApeman ( j ) ;
1330: LD_VAR 0 3
1334: PPUSH
1335: CALL 3049 0 1
1339: GO 1327
1341: POP
1342: POP
1343: GO 1309
1345: POP
1346: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1347: LD_INT 22
1349: PUSH
1350: LD_OWVAR 2
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PPUSH
1359: CALL_OW 69
1363: PUSH
1364: LD_INT 1
1366: ARRAY
1367: PPUSH
1368: CALL_OW 87
// disable ( 17 ) ;
1372: LD_INT 17
1374: DISABLE_MARKED
// end ;
1375: LD_VAR 0 1
1379: RET
// every 3 3$40 trigger game_start do
1380: LD_EXP 9
1384: IFFALSE 1440
1386: GO 1388
1388: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1389: LD_OWVAR 1
1393: PUSH
1394: LD_INT 5
1396: MOD
1397: PUSH
1398: LD_INT 1
1400: PLUS
1401: PPUSH
1402: LD_INT 13
1404: PPUSH
1405: LD_INT 1
1407: PPUSH
1408: CALL_OW 55
// Wait ( 0 0$15 ) ;
1412: LD_INT 525
1414: PPUSH
1415: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1419: LD_OWVAR 1
1423: PUSH
1424: LD_INT 5
1426: MOD
1427: PUSH
1428: LD_INT 1
1430: PLUS
1431: PPUSH
1432: LD_INT 1
1434: PPUSH
1435: CALL_OW 57
// enable ;
1439: ENABLE
// end ;
1440: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1441: LD_EXP 9
1445: IFFALSE 2097
1447: GO 1449
1449: DISABLE
1450: LD_INT 0
1452: PPUSH
1453: PPUSH
// begin cr := 1 ;
1454: LD_ADDR_VAR 0 1
1458: PUSH
1459: LD_INT 1
1461: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1462: LD_ADDR_VAR 0 2
1466: PUSH
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 3
1472: PPUSH
1473: CALL_OW 12
1477: PUSH
1478: LD_INT 2
1480: PPUSH
1481: LD_INT 4
1483: PPUSH
1484: CALL_OW 12
1488: PUSH
1489: LD_INT 3
1491: PPUSH
1492: LD_INT 5
1494: PPUSH
1495: CALL_OW 12
1499: PUSH
1500: LD_INT 3
1502: PPUSH
1503: LD_INT 5
1505: PPUSH
1506: CALL_OW 12
1510: PUSH
1511: LD_INT 2
1513: PPUSH
1514: LD_INT 5
1516: PPUSH
1517: CALL_OW 12
1521: PUSH
1522: LD_INT 1
1524: PPUSH
1525: LD_INT 5
1527: PPUSH
1528: CALL_OW 12
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: LIST
1540: ST_TO_ADDR
// while ( true ) do
1541: LD_INT 1
1543: IFFALSE 2097
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1545: LD_EXP 12
1549: PUSH
1550: LD_OWVAR 1
1554: PUSH
1555: LD_INT 35
1557: MOD
1558: PUSH
1559: LD_INT 60
1561: MUL
1562: PLUS
1563: PPUSH
1564: CALL_OW 67
// if cr mod 3 = 0 then
1568: LD_VAR 0 1
1572: PUSH
1573: LD_INT 3
1575: MOD
1576: PUSH
1577: LD_INT 0
1579: EQUAL
1580: IFFALSE 1733
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1582: LD_VAR 0 2
1586: PUSH
1587: LD_VAR 0 1
1591: PUSH
1592: LD_VAR 0 2
1596: MOD
1597: PUSH
1598: LD_INT 1
1600: PLUS
1601: ARRAY
1602: PPUSH
1603: LD_INT 17
1605: PPUSH
1606: LD_INT 1
1608: PPUSH
1609: CALL_OW 55
// Wait ( crates_spawn ) ;
1613: LD_EXP 12
1617: PPUSH
1618: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1622: LD_VAR 0 2
1626: PUSH
1627: LD_VAR 0 1
1631: PUSH
1632: LD_VAR 0 2
1636: MOD
1637: PUSH
1638: LD_INT 1
1640: PLUS
1641: ARRAY
1642: PPUSH
1643: LD_INT 18
1645: PPUSH
1646: LD_INT 1
1648: PPUSH
1649: CALL_OW 55
// Wait ( crates_spawn ) ;
1653: LD_EXP 12
1657: PPUSH
1658: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1662: LD_VAR 0 2
1666: PUSH
1667: LD_VAR 0 1
1671: PUSH
1672: LD_VAR 0 2
1676: MOD
1677: PUSH
1678: LD_INT 1
1680: PLUS
1681: ARRAY
1682: PPUSH
1683: LD_INT 19
1685: PPUSH
1686: LD_INT 1
1688: PPUSH
1689: CALL_OW 55
// Wait ( crates_spawn ) ;
1693: LD_EXP 12
1697: PPUSH
1698: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1702: LD_VAR 0 2
1706: PUSH
1707: LD_VAR 0 1
1711: PUSH
1712: LD_VAR 0 2
1716: MOD
1717: PUSH
1718: LD_INT 1
1720: PLUS
1721: ARRAY
1722: PPUSH
1723: LD_INT 17
1725: PPUSH
1726: LD_INT 1
1728: PPUSH
1729: CALL_OW 55
// end ; if cr mod 3 = 1 then
1733: LD_VAR 0 1
1737: PUSH
1738: LD_INT 3
1740: MOD
1741: PUSH
1742: LD_INT 1
1744: EQUAL
1745: IFFALSE 1898
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1747: LD_VAR 0 2
1751: PUSH
1752: LD_VAR 0 1
1756: PUSH
1757: LD_VAR 0 2
1761: MOD
1762: PUSH
1763: LD_INT 1
1765: PLUS
1766: ARRAY
1767: PPUSH
1768: LD_INT 18
1770: PPUSH
1771: LD_INT 1
1773: PPUSH
1774: CALL_OW 55
// Wait ( crates_spawn ) ;
1778: LD_EXP 12
1782: PPUSH
1783: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1787: LD_VAR 0 2
1791: PUSH
1792: LD_VAR 0 1
1796: PUSH
1797: LD_VAR 0 2
1801: MOD
1802: PUSH
1803: LD_INT 1
1805: PLUS
1806: ARRAY
1807: PPUSH
1808: LD_INT 17
1810: PPUSH
1811: LD_INT 1
1813: PPUSH
1814: CALL_OW 55
// Wait ( crates_spawn ) ;
1818: LD_EXP 12
1822: PPUSH
1823: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1827: LD_VAR 0 2
1831: PUSH
1832: LD_VAR 0 1
1836: PUSH
1837: LD_VAR 0 2
1841: MOD
1842: PUSH
1843: LD_INT 1
1845: PLUS
1846: ARRAY
1847: PPUSH
1848: LD_INT 19
1850: PPUSH
1851: LD_INT 1
1853: PPUSH
1854: CALL_OW 55
// Wait ( crates_spawn ) ;
1858: LD_EXP 12
1862: PPUSH
1863: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1867: LD_VAR 0 2
1871: PUSH
1872: LD_VAR 0 1
1876: PUSH
1877: LD_VAR 0 2
1881: MOD
1882: PUSH
1883: LD_INT 1
1885: PLUS
1886: ARRAY
1887: PPUSH
1888: LD_INT 18
1890: PPUSH
1891: LD_INT 1
1893: PPUSH
1894: CALL_OW 55
// end ; if cr mod 3 = 2 then
1898: LD_VAR 0 1
1902: PUSH
1903: LD_INT 3
1905: MOD
1906: PUSH
1907: LD_INT 2
1909: EQUAL
1910: IFFALSE 2063
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1912: LD_VAR 0 2
1916: PUSH
1917: LD_VAR 0 1
1921: PUSH
1922: LD_VAR 0 2
1926: MOD
1927: PUSH
1928: LD_INT 1
1930: PLUS
1931: ARRAY
1932: PPUSH
1933: LD_INT 19
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: CALL_OW 55
// Wait ( crates_spawn ) ;
1943: LD_EXP 12
1947: PPUSH
1948: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1952: LD_VAR 0 2
1956: PUSH
1957: LD_VAR 0 1
1961: PUSH
1962: LD_VAR 0 2
1966: MOD
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: ARRAY
1972: PPUSH
1973: LD_INT 18
1975: PPUSH
1976: LD_INT 1
1978: PPUSH
1979: CALL_OW 55
// Wait ( crates_spawn ) ;
1983: LD_EXP 12
1987: PPUSH
1988: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1992: LD_VAR 0 2
1996: PUSH
1997: LD_VAR 0 1
2001: PUSH
2002: LD_VAR 0 2
2006: MOD
2007: PUSH
2008: LD_INT 1
2010: PLUS
2011: ARRAY
2012: PPUSH
2013: LD_INT 17
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: CALL_OW 55
// Wait ( crates_spawn ) ;
2023: LD_EXP 12
2027: PPUSH
2028: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
2032: LD_VAR 0 2
2036: PUSH
2037: LD_VAR 0 1
2041: PUSH
2042: LD_VAR 0 2
2046: MOD
2047: PUSH
2048: LD_INT 1
2050: PLUS
2051: ARRAY
2052: PPUSH
2053: LD_INT 19
2055: PPUSH
2056: LD_INT 1
2058: PPUSH
2059: CALL_OW 55
// end ; cr := cr + 1 ;
2063: LD_ADDR_VAR 0 1
2067: PUSH
2068: LD_VAR 0 1
2072: PUSH
2073: LD_INT 1
2075: PLUS
2076: ST_TO_ADDR
// if cr > 150 then
2077: LD_VAR 0 1
2081: PUSH
2082: LD_INT 150
2084: GREATER
2085: IFFALSE 2095
// cr := 43 ;
2087: LD_ADDR_VAR 0 1
2091: PUSH
2092: LD_INT 43
2094: ST_TO_ADDR
// end ;
2095: GO 1541
// end ; end_of_file
2097: PPOPN 2
2099: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2100: LD_INT 0
2102: PPUSH
2103: PPUSH
2104: PPUSH
2105: PPUSH
2106: PPUSH
2107: PPUSH
2108: PPUSH
2109: PPUSH
2110: PPUSH
// to_copy := [ ] ;
2111: LD_ADDR_VAR 0 5
2115: PUSH
2116: EMPTY
2117: ST_TO_ADDR
// for i = 1 to 8 do
2118: LD_ADDR_VAR 0 2
2122: PUSH
2123: DOUBLE
2124: LD_INT 1
2126: DEC
2127: ST_TO_ADDR
2128: LD_INT 8
2130: PUSH
2131: FOR_TO
2132: IFFALSE 3042
// begin if Side_Positions [ i ] then
2134: LD_EXP 2
2138: PUSH
2139: LD_VAR 0 2
2143: ARRAY
2144: IFFALSE 3040
// begin uc_side := i ;
2146: LD_ADDR_OWVAR 20
2150: PUSH
2151: LD_VAR 0 2
2155: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2156: LD_ADDR_OWVAR 21
2160: PUSH
2161: LD_EXP 4
2165: PUSH
2166: LD_VAR 0 2
2170: ARRAY
2171: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2172: LD_ADDR_VAR 0 6
2176: PUSH
2177: LD_EXP 7
2181: PUSH
2182: LD_EXP 2
2186: PUSH
2187: LD_VAR 0 2
2191: ARRAY
2192: ARRAY
2193: PUSH
2194: LD_INT 1
2196: ARRAY
2197: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2198: LD_ADDR_VAR 0 7
2202: PUSH
2203: LD_EXP 7
2207: PUSH
2208: LD_EXP 2
2212: PUSH
2213: LD_VAR 0 2
2217: ARRAY
2218: ARRAY
2219: PUSH
2220: LD_INT 2
2222: ARRAY
2223: ST_TO_ADDR
// hc_importance := 100 ;
2224: LD_ADDR_OWVAR 32
2228: PUSH
2229: LD_INT 100
2231: ST_TO_ADDR
// if Multiplayer then
2232: LD_OWVAR 4
2236: IFFALSE 2294
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2238: LD_ADDR_OWVAR 26
2242: PUSH
2243: LD_OWVAR 19
2247: PUSH
2248: LD_OWVAR 20
2252: ARRAY
2253: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2254: LD_ADDR_OWVAR 33
2258: PUSH
2259: LD_STRING MULTIAVATARS
2261: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2262: LD_ADDR_OWVAR 34
2266: PUSH
2267: LD_OWVAR 20
2271: PPUSH
2272: CALL_OW 525
2276: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2277: LD_ADDR_OWVAR 27
2281: PUSH
2282: LD_OWVAR 20
2286: PPUSH
2287: CALL_OW 526
2291: ST_TO_ADDR
// end else
2292: GO 2326
// begin hc_name :=  ;
2294: LD_ADDR_OWVAR 26
2298: PUSH
2299: LD_STRING 
2301: ST_TO_ADDR
// hc_gallery :=  ;
2302: LD_ADDR_OWVAR 33
2306: PUSH
2307: LD_STRING 
2309: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2310: LD_ADDR_OWVAR 27
2314: PUSH
2315: LD_INT 1
2317: PPUSH
2318: LD_INT 2
2320: PPUSH
2321: CALL_OW 12
2325: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2326: LD_OWVAR 27
2330: PPUSH
2331: LD_INT 1
2333: PPUSH
2334: LD_EXP 11
2338: PPUSH
2339: CALL_OW 380
// un := CreateHuman ;
2343: LD_ADDR_VAR 0 4
2347: PUSH
2348: CALL_OW 44
2352: ST_TO_ADDR
// if not to_copy then
2353: LD_VAR 0 5
2357: NOT
2358: IFFALSE 2385
// to_copy := Replace ( to_copy , 1 , un ) else
2360: LD_ADDR_VAR 0 5
2364: PUSH
2365: LD_VAR 0 5
2369: PPUSH
2370: LD_INT 1
2372: PPUSH
2373: LD_VAR 0 4
2377: PPUSH
2378: CALL_OW 1
2382: ST_TO_ADDR
2383: GO 2461
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2385: LD_VAR 0 5
2389: PUSH
2390: LD_INT 1
2392: ARRAY
2393: PPUSH
2394: LD_VAR 0 4
2398: PPUSH
2399: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2403: LD_VAR 0 4
2407: PPUSH
2408: LD_INT 2
2410: PPUSH
2411: LD_VAR 0 5
2415: PUSH
2416: LD_INT 1
2418: ARRAY
2419: PPUSH
2420: LD_INT 2
2422: PPUSH
2423: CALL_OW 260
2427: PPUSH
2428: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2432: LD_VAR 0 4
2436: PPUSH
2437: LD_INT 1
2439: PPUSH
2440: LD_VAR 0 5
2444: PUSH
2445: LD_INT 1
2447: ARRAY
2448: PPUSH
2449: LD_INT 1
2451: PPUSH
2452: CALL_OW 260
2456: PPUSH
2457: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_VAR 0 6
2470: PPUSH
2471: LD_VAR 0 7
2475: PPUSH
2476: LD_INT 10
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL_OW 50
// hc_importance := 0 ;
2486: LD_ADDR_OWVAR 32
2490: PUSH
2491: LD_INT 0
2493: ST_TO_ADDR
// hc_name :=  ;
2494: LD_ADDR_OWVAR 26
2498: PUSH
2499: LD_STRING 
2501: ST_TO_ADDR
// hc_gallery :=  ;
2502: LD_ADDR_OWVAR 33
2506: PUSH
2507: LD_STRING 
2509: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2510: LD_ADDR_VAR 0 9
2514: PUSH
2515: LD_EXP 10
2519: PUSH
2520: LD_INT 1
2522: MINUS
2523: PUSH
2524: LD_INT 4
2526: DIVREAL
2527: ST_TO_ADDR
// c := 1 ;
2528: LD_ADDR_VAR 0 8
2532: PUSH
2533: LD_INT 1
2535: ST_TO_ADDR
// for j = 2 to number_of_people do
2536: LD_ADDR_VAR 0 3
2540: PUSH
2541: DOUBLE
2542: LD_INT 2
2544: DEC
2545: ST_TO_ADDR
2546: LD_EXP 10
2550: PUSH
2551: FOR_TO
2552: IFFALSE 2763
// begin PrepareHuman ( false , c , skill_level ) ;
2554: LD_INT 0
2556: PPUSH
2557: LD_VAR 0 8
2561: PPUSH
2562: LD_EXP 11
2566: PPUSH
2567: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2571: LD_VAR 0 3
2575: PUSH
2576: LD_INT 1
2578: MINUS
2579: PUSH
2580: LD_VAR 0 9
2584: MOD
2585: PUSH
2586: LD_INT 0
2588: EQUAL
2589: IFFALSE 2605
// c := c + 1 ;
2591: LD_ADDR_VAR 0 8
2595: PUSH
2596: LD_VAR 0 8
2600: PUSH
2601: LD_INT 1
2603: PLUS
2604: ST_TO_ADDR
// un := CreateHuman ;
2605: LD_ADDR_VAR 0 4
2609: PUSH
2610: CALL_OW 44
2614: ST_TO_ADDR
// if to_copy < j then
2615: LD_VAR 0 5
2619: PUSH
2620: LD_VAR 0 3
2624: LESS
2625: IFFALSE 2654
// to_copy := Replace ( to_copy , j , un ) else
2627: LD_ADDR_VAR 0 5
2631: PUSH
2632: LD_VAR 0 5
2636: PPUSH
2637: LD_VAR 0 3
2641: PPUSH
2642: LD_VAR 0 4
2646: PPUSH
2647: CALL_OW 1
2651: ST_TO_ADDR
2652: GO 2736
// begin CopySkills ( to_copy [ j ] , un ) ;
2654: LD_VAR 0 5
2658: PUSH
2659: LD_VAR 0 3
2663: ARRAY
2664: PPUSH
2665: LD_VAR 0 4
2669: PPUSH
2670: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2674: LD_VAR 0 4
2678: PPUSH
2679: LD_INT 2
2681: PPUSH
2682: LD_VAR 0 5
2686: PUSH
2687: LD_VAR 0 3
2691: ARRAY
2692: PPUSH
2693: LD_INT 2
2695: PPUSH
2696: CALL_OW 260
2700: PPUSH
2701: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2705: LD_VAR 0 4
2709: PPUSH
2710: LD_INT 1
2712: PPUSH
2713: LD_VAR 0 5
2717: PUSH
2718: LD_VAR 0 3
2722: ARRAY
2723: PPUSH
2724: LD_INT 1
2726: PPUSH
2727: CALL_OW 260
2731: PPUSH
2732: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2736: LD_VAR 0 4
2740: PPUSH
2741: LD_VAR 0 6
2745: PPUSH
2746: LD_VAR 0 7
2750: PPUSH
2751: LD_INT 10
2753: PPUSH
2754: LD_INT 0
2756: PPUSH
2757: CALL_OW 50
// end ;
2761: GO 2551
2763: POP
2764: POP
// if handicap then
2765: LD_EXP 26
2769: IFFALSE 3040
// begin if handicap = 1 then
2771: LD_EXP 26
2775: PUSH
2776: LD_INT 1
2778: EQUAL
2779: IFFALSE 2858
// for j = 1 to 2 do
2781: LD_ADDR_VAR 0 3
2785: PUSH
2786: DOUBLE
2787: LD_INT 1
2789: DEC
2790: ST_TO_ADDR
2791: LD_INT 2
2793: PUSH
2794: FOR_TO
2795: IFFALSE 2856
// begin vc_chassis := ru_medium_tracked ;
2797: LD_ADDR_OWVAR 37
2801: PUSH
2802: LD_INT 22
2804: ST_TO_ADDR
// vc_engine := engine_combustion ;
2805: LD_ADDR_OWVAR 39
2809: PUSH
2810: LD_INT 1
2812: ST_TO_ADDR
// vc_control := control_manual ;
2813: LD_ADDR_OWVAR 38
2817: PUSH
2818: LD_INT 1
2820: ST_TO_ADDR
// vc_weapon := ru_gun ;
2821: LD_ADDR_OWVAR 40
2825: PUSH
2826: LD_INT 44
2828: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2829: CALL_OW 45
2833: PPUSH
2834: LD_VAR 0 6
2838: PPUSH
2839: LD_VAR 0 7
2843: PPUSH
2844: LD_INT 13
2846: PPUSH
2847: LD_INT 0
2849: PPUSH
2850: CALL_OW 50
// end ;
2854: GO 2794
2856: POP
2857: POP
// if handicap = 2 then
2858: LD_EXP 26
2862: PUSH
2863: LD_INT 2
2865: EQUAL
2866: IFFALSE 3040
// begin for j = 1 to 2 do
2868: LD_ADDR_VAR 0 3
2872: PUSH
2873: DOUBLE
2874: LD_INT 1
2876: DEC
2877: ST_TO_ADDR
2878: LD_INT 2
2880: PUSH
2881: FOR_TO
2882: IFFALSE 2956
// begin vc_chassis := ru_heavy_tracked ;
2884: LD_ADDR_OWVAR 37
2888: PUSH
2889: LD_INT 24
2891: ST_TO_ADDR
// vc_engine := engine_combustion ;
2892: LD_ADDR_OWVAR 39
2896: PUSH
2897: LD_INT 1
2899: ST_TO_ADDR
// vc_control := control_manual ;
2900: LD_ADDR_OWVAR 38
2904: PUSH
2905: LD_INT 1
2907: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_heavy_gun ] [ j ] ;
2908: LD_ADDR_OWVAR 40
2912: PUSH
2913: LD_INT 43
2915: PUSH
2916: LD_INT 46
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PUSH
2923: LD_VAR 0 3
2927: ARRAY
2928: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2929: CALL_OW 45
2933: PPUSH
2934: LD_VAR 0 6
2938: PPUSH
2939: LD_VAR 0 7
2943: PPUSH
2944: LD_INT 13
2946: PPUSH
2947: LD_INT 0
2949: PPUSH
2950: CALL_OW 50
// end ;
2954: GO 2881
2956: POP
2957: POP
// vc_chassis := ru_medium_tracked ;
2958: LD_ADDR_OWVAR 37
2962: PUSH
2963: LD_INT 22
2965: ST_TO_ADDR
// vc_engine := engine_siberite ;
2966: LD_ADDR_OWVAR 39
2970: PUSH
2971: LD_INT 3
2973: ST_TO_ADDR
// vc_control := control_computer ;
2974: LD_ADDR_OWVAR 38
2978: PUSH
2979: LD_INT 3
2981: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2982: LD_ADDR_OWVAR 40
2986: PUSH
2987: LD_INT 51
2989: ST_TO_ADDR
// un := CreateVehicle ;
2990: LD_ADDR_VAR 0 4
2994: PUSH
2995: CALL_OW 45
2999: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
3000: LD_VAR 0 4
3004: PPUSH
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_VAR 0 7
3014: PPUSH
3015: LD_INT 13
3017: PPUSH
3018: LD_INT 0
3020: PPUSH
3021: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
3025: LD_VAR 0 4
3029: PPUSH
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 100
3035: PPUSH
3036: CALL_OW 290
// end ; end ; end ; end ;
3040: GO 2131
3042: POP
3043: POP
// end ;
3044: LD_VAR 0 1
3048: RET
// export function AddApeman ( area ) ; begin
3049: LD_INT 0
3051: PPUSH
// uc_nation := 0 ;
3052: LD_ADDR_OWVAR 21
3056: PUSH
3057: LD_INT 0
3059: ST_TO_ADDR
// uc_side := 0 ;
3060: LD_ADDR_OWVAR 20
3064: PUSH
3065: LD_INT 0
3067: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
3068: LD_ADDR_OWVAR 35
3072: PUSH
3073: LD_INT 10
3075: NEG
3076: PPUSH
3077: LD_INT 15
3079: PPUSH
3080: CALL_OW 12
3084: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3085: LD_INT 0
3087: PPUSH
3088: LD_INT 12
3090: PPUSH
3091: LD_INT 0
3093: PPUSH
3094: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3098: LD_ADDR_OWVAR 29
3102: PUSH
3103: LD_INT 10
3105: PUSH
3106: LD_INT 12
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3113: CALL_OW 44
3117: PPUSH
3118: LD_VAR 0 1
3122: PPUSH
3123: LD_INT 0
3125: PPUSH
3126: CALL_OW 49
// end ;
3130: LD_VAR 0 2
3134: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3135: LD_INT 0
3137: PPUSH
3138: PPUSH
3139: PPUSH
3140: PPUSH
// r := 100 ;
3141: LD_ADDR_VAR 0 5
3145: PUSH
3146: LD_INT 100
3148: ST_TO_ADDR
// x := 0 ;
3149: LD_ADDR_VAR 0 6
3153: PUSH
3154: LD_INT 0
3156: ST_TO_ADDR
// while ( x < n ) do
3157: LD_VAR 0 6
3161: PUSH
3162: LD_VAR 0 2
3166: LESS
3167: IFFALSE 3482
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3169: LD_ADDR_VAR 0 4
3173: PUSH
3174: DOUBLE
3175: LD_INT 1
3177: DEC
3178: ST_TO_ADDR
3179: LD_VAR 0 1
3183: PPUSH
3184: LD_INT 0
3186: PPUSH
3187: CALL_OW 517
3191: PUSH
3192: LD_INT 1
3194: ARRAY
3195: PUSH
3196: FOR_TO
3197: IFFALSE 3478
// begin if r > 50 then
3199: LD_VAR 0 5
3203: PUSH
3204: LD_INT 50
3206: GREATER
3207: IFFALSE 3454
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3209: LD_VAR 0 1
3213: PPUSH
3214: LD_INT 0
3216: PPUSH
3217: CALL_OW 517
3221: PUSH
3222: LD_INT 1
3224: ARRAY
3225: PUSH
3226: LD_VAR 0 4
3230: ARRAY
3231: PPUSH
3232: LD_VAR 0 1
3236: PPUSH
3237: LD_INT 0
3239: PPUSH
3240: CALL_OW 517
3244: PUSH
3245: LD_INT 2
3247: ARRAY
3248: PUSH
3249: LD_VAR 0 4
3253: ARRAY
3254: PPUSH
3255: CALL_OW 458
3259: NOT
3260: IFFALSE 3438
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3262: LD_VAR 0 1
3266: PPUSH
3267: LD_INT 0
3269: PPUSH
3270: CALL_OW 517
3274: PUSH
3275: LD_INT 1
3277: ARRAY
3278: PUSH
3279: LD_VAR 0 4
3283: ARRAY
3284: PPUSH
3285: LD_VAR 0 1
3289: PPUSH
3290: LD_INT 0
3292: PPUSH
3293: CALL_OW 517
3297: PUSH
3298: LD_INT 2
3300: ARRAY
3301: PUSH
3302: LD_VAR 0 4
3306: ARRAY
3307: PPUSH
3308: LD_EXP 8
3312: PPUSH
3313: LD_INT 0
3315: PPUSH
3316: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3320: LD_ADDR_EXP 17
3324: PUSH
3325: LD_EXP 17
3329: PPUSH
3330: LD_EXP 17
3334: PUSH
3335: LD_INT 1
3337: PLUS
3338: PPUSH
3339: LD_VAR 0 1
3343: PPUSH
3344: LD_INT 0
3346: PPUSH
3347: CALL_OW 517
3351: PUSH
3352: LD_INT 1
3354: ARRAY
3355: PUSH
3356: LD_VAR 0 4
3360: ARRAY
3361: PPUSH
3362: CALL_OW 2
3366: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3367: LD_ADDR_EXP 17
3371: PUSH
3372: LD_EXP 17
3376: PPUSH
3377: LD_EXP 17
3381: PUSH
3382: LD_INT 1
3384: PLUS
3385: PPUSH
3386: LD_VAR 0 1
3390: PPUSH
3391: LD_INT 0
3393: PPUSH
3394: CALL_OW 517
3398: PUSH
3399: LD_INT 2
3401: ARRAY
3402: PUSH
3403: LD_VAR 0 4
3407: ARRAY
3408: PPUSH
3409: CALL_OW 2
3413: ST_TO_ADDR
// r := 0 ;
3414: LD_ADDR_VAR 0 5
3418: PUSH
3419: LD_INT 0
3421: ST_TO_ADDR
// x := x + 1 ;
3422: LD_ADDR_VAR 0 6
3426: PUSH
3427: LD_VAR 0 6
3431: PUSH
3432: LD_INT 1
3434: PLUS
3435: ST_TO_ADDR
// end else
3436: GO 3452
// r := r + 35 ;
3438: LD_ADDR_VAR 0 5
3442: PUSH
3443: LD_VAR 0 5
3447: PUSH
3448: LD_INT 35
3450: PLUS
3451: ST_TO_ADDR
// end else
3452: GO 3476
// r := r + rand ( 10 , 25 ) ;
3454: LD_ADDR_VAR 0 5
3458: PUSH
3459: LD_VAR 0 5
3463: PUSH
3464: LD_INT 10
3466: PPUSH
3467: LD_INT 25
3469: PPUSH
3470: CALL_OW 12
3474: PLUS
3475: ST_TO_ADDR
// end ;
3476: GO 3196
3478: POP
3479: POP
3480: GO 3157
// end ;
3482: LD_VAR 0 3
3486: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3487: LD_INT 0
3489: PPUSH
3490: PPUSH
3491: PPUSH
// if not GetControl ( veh ) = control_manual then
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 263
3501: PUSH
3502: LD_INT 1
3504: EQUAL
3505: NOT
3506: IFFALSE 3518
// result := false else
3508: LD_ADDR_VAR 0 2
3512: PUSH
3513: LD_INT 0
3515: ST_TO_ADDR
3516: GO 3663
// if veh in FilterAllUnits ( [ f_empty ] ) then
3518: LD_VAR 0 1
3522: PUSH
3523: LD_INT 58
3525: PUSH
3526: EMPTY
3527: LIST
3528: PPUSH
3529: CALL_OW 69
3533: IN
3534: IFFALSE 3546
// result := false else
3536: LD_ADDR_VAR 0 2
3540: PUSH
3541: LD_INT 0
3543: ST_TO_ADDR
3544: GO 3663
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3546: LD_ADDR_VAR 0 4
3550: PUSH
3551: LD_INT 22
3553: PUSH
3554: LD_VAR 0 1
3558: PPUSH
3559: CALL_OW 255
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: PUSH
3568: LD_INT 55
3570: PUSH
3571: EMPTY
3572: LIST
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: PPUSH
3578: CALL_OW 69
3582: ST_TO_ADDR
// if not filter then
3583: LD_VAR 0 4
3587: NOT
3588: IFFALSE 3600
// result := false else
3590: LD_ADDR_VAR 0 2
3594: PUSH
3595: LD_INT 0
3597: ST_TO_ADDR
3598: GO 3663
// for i = 1 to filter do
3600: LD_ADDR_VAR 0 3
3604: PUSH
3605: DOUBLE
3606: LD_INT 1
3608: DEC
3609: ST_TO_ADDR
3610: LD_VAR 0 4
3614: PUSH
3615: FOR_TO
3616: IFFALSE 3661
// if IsDriver ( filter [ i ] ) = veh then
3618: LD_VAR 0 4
3622: PUSH
3623: LD_VAR 0 3
3627: ARRAY
3628: PPUSH
3629: CALL 3668 0 1
3633: PUSH
3634: LD_VAR 0 1
3638: EQUAL
3639: IFFALSE 3659
// begin result := filter [ i ] ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_VAR 0 4
3650: PUSH
3651: LD_VAR 0 3
3655: ARRAY
3656: ST_TO_ADDR
// break ;
3657: GO 3661
// end ;
3659: GO 3615
3661: POP
3662: POP
// end ; end ;
3663: LD_VAR 0 2
3667: RET
// export function IsDriver ( unit ) ; begin
3668: LD_INT 0
3670: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3671: LD_VAR 0 1
3675: PUSH
3676: LD_INT 55
3678: PUSH
3679: EMPTY
3680: LIST
3681: PPUSH
3682: CALL_OW 69
3686: IN
3687: IFFALSE 3706
// result := IsInUnit ( unit ) else
3689: LD_ADDR_VAR 0 2
3693: PUSH
3694: LD_VAR 0 1
3698: PPUSH
3699: CALL_OW 310
3703: ST_TO_ADDR
3704: GO 3714
// result := false ;
3706: LD_ADDR_VAR 0 2
3710: PUSH
3711: LD_INT 0
3713: ST_TO_ADDR
// end ; end_of_file
3714: LD_VAR 0 2
3718: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3719: LD_INT 0
3721: PPUSH
3722: PPUSH
3723: PPUSH
3724: PPUSH
3725: PPUSH
3726: PPUSH
3727: PPUSH
3728: PPUSH
3729: PPUSH
// side := Bot_Side ;
3730: LD_ADDR_VAR 0 5
3734: PUSH
3735: LD_EXP 8
3739: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3740: LD_ADDR_VAR 0 9
3744: PUSH
3745: LD_INT 4
3747: PUSH
3748: LD_INT 6
3750: PUSH
3751: LD_INT 8
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: PUSH
3759: LD_OWVAR 67
3763: ARRAY
3764: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3765: LD_ADDR_VAR 0 8
3769: PUSH
3770: LD_INT 27
3772: PUSH
3773: LD_INT 28
3775: PUSH
3776: LD_INT 25
3778: PUSH
3779: LD_INT 26
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: LIST
3786: LIST
3787: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3788: LD_ADDR_EXP 22
3792: PUSH
3793: LD_INT 4
3795: PUSH
3796: LD_INT 5
3798: PUSH
3799: LD_INT 6
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: PUSH
3807: LD_OWVAR 67
3811: ARRAY
3812: ST_TO_ADDR
// ct := [ ] ;
3813: LD_ADDR_VAR 0 3
3817: PUSH
3818: EMPTY
3819: ST_TO_ADDR
// patrols := [ ] ;
3820: LD_ADDR_EXP 19
3824: PUSH
3825: EMPTY
3826: ST_TO_ADDR
// attackers := [ ] ;
3827: LD_ADDR_EXP 20
3831: PUSH
3832: EMPTY
3833: ST_TO_ADDR
// attackers_tmp := [ ] ;
3834: LD_ADDR_EXP 27
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
3841: LD_ADDR_EXP 21
3845: PUSH
3846: LD_INT 14
3848: PUSH
3849: LD_INT 1
3851: PUSH
3852: LD_INT 2
3854: PUSH
3855: LD_INT 27
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 14
3866: PUSH
3867: LD_INT 1
3869: PUSH
3870: LD_INT 2
3872: PUSH
3873: LD_INT 25
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: PUSH
3882: LD_INT 14
3884: PUSH
3885: LD_INT 1
3887: PUSH
3888: LD_INT 2
3890: PUSH
3891: LD_INT 28
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: PUSH
3900: LD_INT 14
3902: PUSH
3903: LD_INT 1
3905: PUSH
3906: LD_INT 2
3908: PUSH
3909: LD_INT 29
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: LIST
3916: LIST
3917: PUSH
3918: LD_INT 14
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: LD_INT 2
3926: PUSH
3927: LD_INT 27
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: LIST
3942: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3943: LD_INT 2
3945: PPUSH
3946: LD_STRING newkabul
3948: PPUSH
3949: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3953: LD_INT 2
3955: PPUSH
3956: CALL_OW 274
3960: PPUSH
3961: LD_INT 1
3963: PPUSH
3964: LD_INT 90000
3966: PPUSH
3967: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3971: LD_INT 2
3973: PPUSH
3974: CALL_OW 274
3978: PPUSH
3979: LD_INT 2
3981: PPUSH
3982: LD_INT 9000
3984: PPUSH
3985: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3989: LD_INT 2
3991: PPUSH
3992: CALL_OW 274
3996: PPUSH
3997: LD_INT 3
3999: PPUSH
4000: LD_INT 3000
4002: PPUSH
4003: CALL_OW 277
// if Difficulty > 1 then
4007: LD_OWVAR 67
4011: PUSH
4012: LD_INT 1
4014: GREATER
4015: IFFALSE 4032
// SetTech ( 5 , side , state_researched ) ;
4017: LD_INT 5
4019: PPUSH
4020: LD_VAR 0 5
4024: PPUSH
4025: LD_INT 2
4027: PPUSH
4028: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
4032: LD_INT 41
4034: PPUSH
4035: LD_VAR 0 5
4039: PPUSH
4040: LD_INT 2
4042: PPUSH
4043: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
4047: LD_INT 51
4049: PPUSH
4050: LD_VAR 0 5
4054: PPUSH
4055: LD_INT 2
4057: PPUSH
4058: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
4062: LD_INT 52
4064: PPUSH
4065: LD_VAR 0 5
4069: PPUSH
4070: LD_INT 2
4072: PPUSH
4073: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4077: LD_INT 53
4079: PPUSH
4080: LD_VAR 0 5
4084: PPUSH
4085: LD_INT 2
4087: PPUSH
4088: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4092: LD_INT 60
4094: PPUSH
4095: LD_VAR 0 5
4099: PPUSH
4100: LD_INT 2
4102: PPUSH
4103: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4107: LD_INT 61
4109: PPUSH
4110: LD_VAR 0 5
4114: PPUSH
4115: LD_INT 2
4117: PPUSH
4118: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4122: LD_INT 62
4124: PPUSH
4125: LD_VAR 0 5
4129: PPUSH
4130: LD_INT 2
4132: PPUSH
4133: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4137: LD_ADDR_VAR 0 2
4141: PUSH
4142: LD_INT 22
4144: PUSH
4145: LD_VAR 0 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: LD_INT 21
4156: PUSH
4157: LD_INT 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PPUSH
4168: CALL_OW 69
4172: PUSH
4173: FOR_IN
4174: IFFALSE 4207
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4176: LD_VAR 0 2
4180: PPUSH
4181: LD_INT 6
4183: PUSH
4184: LD_INT 8
4186: PUSH
4187: LD_INT 10
4189: PUSH
4190: EMPTY
4191: LIST
4192: LIST
4193: LIST
4194: PUSH
4195: LD_OWVAR 67
4199: ARRAY
4200: PPUSH
4201: CALL_OW 241
4205: GO 4173
4207: POP
4208: POP
// if Difficulty > 1 then
4209: LD_OWVAR 67
4213: PUSH
4214: LD_INT 1
4216: GREATER
4217: IFFALSE 4226
// RemoveEnvironmentArea ( forest_road ) ;
4219: LD_INT 11
4221: PPUSH
4222: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4226: LD_INT 4
4228: PPUSH
4229: LD_INT 10
4231: PUSH
4232: LD_INT 15
4234: PUSH
4235: LD_INT 20
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: LIST
4242: PUSH
4243: LD_OWVAR 67
4247: ARRAY
4248: PPUSH
4249: CALL 3135 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4253: LD_INT 5
4255: PPUSH
4256: LD_INT 7
4258: PUSH
4259: LD_INT 14
4261: PUSH
4262: LD_INT 18
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_OWVAR 67
4274: ARRAY
4275: PPUSH
4276: CALL 3135 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4280: LD_INT 7
4282: PPUSH
4283: LD_INT 5
4285: PUSH
4286: LD_INT 11
4288: PUSH
4289: LD_INT 17
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: LIST
4296: PUSH
4297: LD_OWVAR 67
4301: ARRAY
4302: PPUSH
4303: CALL 3135 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4307: LD_INT 6
4309: PPUSH
4310: LD_INT 0
4312: PUSH
4313: LD_INT 3
4315: PUSH
4316: LD_INT 5
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: LIST
4323: PUSH
4324: LD_OWVAR 67
4328: ARRAY
4329: PPUSH
4330: CALL 3135 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4334: LD_INT 8
4336: PPUSH
4337: LD_INT 2
4339: PUSH
4340: LD_INT 5
4342: PUSH
4343: LD_INT 8
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: LIST
4350: PUSH
4351: LD_OWVAR 67
4355: ARRAY
4356: PPUSH
4357: CALL 3135 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4361: LD_INT 9
4363: PPUSH
4364: LD_INT 0
4366: PUSH
4367: LD_INT 2
4369: PUSH
4370: LD_INT 4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: LIST
4377: PUSH
4378: LD_OWVAR 67
4382: ARRAY
4383: PPUSH
4384: CALL 3135 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4388: LD_INT 10
4390: PPUSH
4391: LD_INT 0
4393: PUSH
4394: LD_INT 1
4396: PUSH
4397: LD_INT 1
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PUSH
4405: LD_OWVAR 67
4409: ARRAY
4410: PPUSH
4411: CALL 3135 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4415: LD_INT 12
4417: PPUSH
4418: LD_INT 0
4420: PUSH
4421: LD_INT 1
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: LIST
4431: PUSH
4432: LD_OWVAR 67
4436: ARRAY
4437: PPUSH
4438: CALL 3135 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: DOUBLE
4448: LD_INT 1
4450: DEC
4451: ST_TO_ADDR
4452: LD_INT 8
4454: PUSH
4455: LD_INT 11
4457: PUSH
4458: LD_INT 14
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: PUSH
4472: FOR_TO
4473: IFFALSE 4648
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4475: LD_ADDR_VAR 0 4
4479: PUSH
4480: LD_INT 134
4482: PPUSH
4483: LD_INT 73
4485: PPUSH
4486: LD_INT 10
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 17
4496: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4497: LD_VAR 0 4
4501: PUSH
4502: LD_INT 1
4504: ARRAY
4505: PPUSH
4506: LD_VAR 0 4
4510: PUSH
4511: LD_INT 2
4513: ARRAY
4514: PPUSH
4515: CALL_OW 428
4519: PUSH
4520: LD_INT 0
4522: EQUAL
4523: PUSH
4524: LD_VAR 0 4
4528: PUSH
4529: LD_INT 1
4531: ARRAY
4532: PPUSH
4533: LD_VAR 0 4
4537: PUSH
4538: LD_INT 2
4540: ARRAY
4541: PPUSH
4542: CALL_OW 458
4546: NOT
4547: AND
4548: IFFALSE 4646
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4550: LD_ADDR_EXP 17
4554: PUSH
4555: LD_EXP 17
4559: PPUSH
4560: LD_EXP 17
4564: PUSH
4565: LD_INT 1
4567: PLUS
4568: PPUSH
4569: LD_VAR 0 4
4573: PUSH
4574: LD_INT 1
4576: ARRAY
4577: PPUSH
4578: CALL_OW 2
4582: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4583: LD_ADDR_EXP 17
4587: PUSH
4588: LD_EXP 17
4592: PPUSH
4593: LD_EXP 17
4597: PUSH
4598: LD_INT 1
4600: PLUS
4601: PPUSH
4602: LD_VAR 0 4
4606: PUSH
4607: LD_INT 2
4609: ARRAY
4610: PPUSH
4611: CALL_OW 2
4615: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4616: LD_VAR 0 4
4620: PUSH
4621: LD_INT 1
4623: ARRAY
4624: PPUSH
4625: LD_VAR 0 4
4629: PUSH
4630: LD_INT 2
4632: ARRAY
4633: PPUSH
4634: LD_EXP 8
4638: PPUSH
4639: LD_INT 0
4641: PPUSH
4642: CALL_OW 454
// end ; end ;
4646: GO 4472
4648: POP
4649: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4650: LD_ADDR_VAR 0 2
4654: PUSH
4655: LD_INT 22
4657: PUSH
4658: LD_VAR 0 5
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: PUSH
4667: LD_INT 30
4669: PUSH
4670: LD_INT 32
4672: PUSH
4673: EMPTY
4674: LIST
4675: LIST
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PPUSH
4681: CALL_OW 69
4685: PUSH
4686: FOR_IN
4687: IFFALSE 4719
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4689: LD_VAR 0 2
4693: PPUSH
4694: LD_VAR 0 8
4698: PUSH
4699: LD_INT 1
4701: PPUSH
4702: LD_VAR 0 8
4706: PPUSH
4707: CALL_OW 12
4711: ARRAY
4712: PPUSH
4713: CALL_OW 431
4717: GO 4686
4719: POP
4720: POP
// uc_side := side ;
4721: LD_ADDR_OWVAR 20
4725: PUSH
4726: LD_VAR 0 5
4730: ST_TO_ADDR
// uc_nation := 2 ;
4731: LD_ADDR_OWVAR 21
4735: PUSH
4736: LD_INT 2
4738: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4739: LD_ADDR_VAR 0 2
4743: PUSH
4744: DOUBLE
4745: LD_INT 1
4747: DEC
4748: ST_TO_ADDR
4749: LD_INT 1
4751: PUSH
4752: LD_OWVAR 67
4756: PLUS
4757: PUSH
4758: FOR_TO
4759: IFFALSE 4849
// begin vc_chassis := ar_half_tracked ;
4761: LD_ADDR_OWVAR 37
4765: PUSH
4766: LD_INT 14
4768: ST_TO_ADDR
// vc_engine := engine_combustion ;
4769: LD_ADDR_OWVAR 39
4773: PUSH
4774: LD_INT 1
4776: ST_TO_ADDR
// vc_control := control_manual ;
4777: LD_ADDR_OWVAR 38
4781: PUSH
4782: LD_INT 1
4784: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4785: LD_ADDR_OWVAR 40
4789: PUSH
4790: LD_INT 31
4792: ST_TO_ADDR
// veh := CreateVehicle ;
4793: LD_ADDR_VAR 0 7
4797: PUSH
4798: CALL_OW 45
4802: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4803: LD_VAR 0 7
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 0
4813: PPUSH
4814: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4818: LD_INT 0
4820: PPUSH
4821: LD_INT 3
4823: PPUSH
4824: LD_VAR 0 9
4828: PPUSH
4829: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4833: CALL_OW 44
4837: PPUSH
4838: LD_VAR 0 7
4842: PPUSH
4843: CALL_OW 52
// end ;
4847: GO 4758
4849: POP
4850: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4851: LD_ADDR_VAR 0 2
4855: PUSH
4856: LD_INT 22
4858: PUSH
4859: LD_VAR 0 5
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 30
4870: PUSH
4871: LD_INT 32
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PPUSH
4882: CALL_OW 69
4886: PUSH
4887: FOR_IN
4888: IFFALSE 4921
// begin PrepareHuman ( false , 1 , skill ) ;
4890: LD_INT 0
4892: PPUSH
4893: LD_INT 1
4895: PPUSH
4896: LD_VAR 0 9
4900: PPUSH
4901: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4905: CALL_OW 44
4909: PPUSH
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 52
// end ;
4919: GO 4887
4921: POP
4922: POP
// for i = 1 to 4 do
4923: LD_ADDR_VAR 0 2
4927: PUSH
4928: DOUBLE
4929: LD_INT 1
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 4968
// begin PrepareHuman ( false , 2 , skill ) ;
4939: LD_INT 0
4941: PPUSH
4942: LD_INT 2
4944: PPUSH
4945: LD_VAR 0 9
4949: PPUSH
4950: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4954: CALL_OW 44
4958: PPUSH
4959: LD_INT 2
4961: PPUSH
4962: CALL_OW 52
// end ;
4966: GO 4936
4968: POP
4969: POP
// for i = 1 to 6 do
4970: LD_ADDR_VAR 0 2
4974: PUSH
4975: DOUBLE
4976: LD_INT 1
4978: DEC
4979: ST_TO_ADDR
4980: LD_INT 6
4982: PUSH
4983: FOR_TO
4984: IFFALSE 5015
// begin PrepareHuman ( false , 3 , skill ) ;
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 3
4991: PPUSH
4992: LD_VAR 0 9
4996: PPUSH
4997: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
5001: CALL_OW 44
5005: PPUSH
5006: LD_INT 12
5008: PPUSH
5009: CALL_OW 52
// end ;
5013: GO 4983
5015: POP
5016: POP
// for i = 1 to 4 do
5017: LD_ADDR_VAR 0 2
5021: PUSH
5022: DOUBLE
5023: LD_INT 1
5025: DEC
5026: ST_TO_ADDR
5027: LD_INT 4
5029: PUSH
5030: FOR_TO
5031: IFFALSE 5088
// begin PrepareHuman ( false , 4 , skill ) ;
5033: LD_INT 0
5035: PPUSH
5036: LD_INT 4
5038: PPUSH
5039: LD_VAR 0 9
5043: PPUSH
5044: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
5048: CALL_OW 44
5052: PPUSH
5053: LD_INT 30
5055: PUSH
5056: LD_INT 8
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: PUSH
5068: LD_VAR 0 2
5072: PUSH
5073: LD_INT 2
5075: MOD
5076: PUSH
5077: LD_INT 1
5079: PLUS
5080: ARRAY
5081: PPUSH
5082: CALL_OW 52
// end ;
5086: GO 5030
5088: POP
5089: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5090: LD_INT 0
5092: PPUSH
5093: LD_INT 8
5095: PPUSH
5096: LD_VAR 0 9
5100: PPUSH
5101: CALL_OW 380
// un := CreateHuman ;
5105: LD_ADDR_VAR 0 6
5109: PUSH
5110: CALL_OW 44
5114: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5115: LD_VAR 0 6
5119: PPUSH
5120: LD_INT 2
5122: PPUSH
5123: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5127: LD_VAR 0 6
5131: PPUSH
5132: LD_INT 31
5134: PPUSH
5135: CALL_OW 52
// for i = 1 to 4 do
5139: LD_ADDR_VAR 0 2
5143: PUSH
5144: DOUBLE
5145: LD_INT 1
5147: DEC
5148: ST_TO_ADDR
5149: LD_INT 4
5151: PUSH
5152: FOR_TO
5153: IFFALSE 5209
// begin uc_nation := 0 ;
5155: LD_ADDR_OWVAR 21
5159: PUSH
5160: LD_INT 0
5162: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5163: LD_INT 0
5165: PPUSH
5166: LD_INT 16
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 380
// un := CreateHuman ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: CALL_OW 44
5185: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5186: LD_VAR 0 6
5190: PPUSH
5191: LD_INT 106
5193: PPUSH
5194: LD_INT 46
5196: PPUSH
5197: LD_INT 8
5199: PPUSH
5200: LD_INT 0
5202: PPUSH
5203: CALL_OW 50
// end ;
5207: GO 5152
5209: POP
5210: POP
// for i = 1 to 2 * Difficulty do
5211: LD_ADDR_VAR 0 2
5215: PUSH
5216: DOUBLE
5217: LD_INT 1
5219: DEC
5220: ST_TO_ADDR
5221: LD_INT 2
5223: PUSH
5224: LD_OWVAR 67
5228: MUL
5229: PUSH
5230: FOR_TO
5231: IFFALSE 5271
// begin uc_nation := 0 ;
5233: LD_ADDR_OWVAR 21
5237: PUSH
5238: LD_INT 0
5240: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5241: LD_INT 0
5243: PPUSH
5244: LD_INT 15
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5254: CALL_OW 44
5258: PPUSH
5259: LD_INT 20
5261: PPUSH
5262: LD_INT 0
5264: PPUSH
5265: CALL_OW 49
// end ;
5269: GO 5230
5271: POP
5272: POP
// for i = 1 to 4 * Difficulty do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 4
5285: PUSH
5286: LD_OWVAR 67
5290: MUL
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5367
// begin uc_nation := 0 ;
5295: LD_ADDR_OWVAR 21
5299: PUSH
5300: LD_INT 0
5302: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5303: LD_INT 0
5305: PPUSH
5306: LD_INT 17
5308: PPUSH
5309: LD_INT 3
5311: PPUSH
5312: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5316: LD_ADDR_OWVAR 29
5320: PUSH
5321: LD_INT 11
5323: PUSH
5324: LD_INT 13
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: ST_TO_ADDR
// un := CreateHuman ;
5331: LD_ADDR_VAR 0 6
5335: PUSH
5336: CALL_OW 44
5340: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5341: LD_VAR 0 6
5345: PPUSH
5346: LD_INT 21
5348: PPUSH
5349: LD_INT 0
5351: PPUSH
5352: CALL_OW 49
// ComHold ( un ) ;
5356: LD_VAR 0 6
5360: PPUSH
5361: CALL_OW 140
// end ;
5365: GO 5292
5367: POP
5368: POP
// end ;
5369: LD_VAR 0 1
5373: RET
// every 12 12$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5374: LD_INT 22
5376: PUSH
5377: LD_EXP 8
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 30
5388: PUSH
5389: LD_INT 3
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: IFFALSE 5672
5406: GO 5408
5408: DISABLE
5409: LD_INT 0
5411: PPUSH
5412: PPUSH
5413: PPUSH
// begin enable ;
5414: ENABLE
// tmp := queue_codes [ rng ] ;
5415: LD_ADDR_VAR 0 2
5419: PUSH
5420: LD_EXP 23
5424: PUSH
5425: LD_EXP 24
5429: ARRAY
5430: ST_TO_ADDR
// p := 1 ;
5431: LD_ADDR_VAR 0 3
5435: PUSH
5436: LD_INT 1
5438: ST_TO_ADDR
// for i = 1 to veh_counter do
5439: LD_ADDR_VAR 0 1
5443: PUSH
5444: DOUBLE
5445: LD_INT 1
5447: DEC
5448: ST_TO_ADDR
5449: LD_EXP 22
5453: PUSH
5454: FOR_TO
5455: IFFALSE 5636
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5457: LD_INT 22
5459: PUSH
5460: LD_EXP 8
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 30
5471: PUSH
5472: LD_INT 3
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PPUSH
5483: CALL_OW 69
5487: PUSH
5488: LD_INT 1
5490: ARRAY
5491: PPUSH
5492: LD_EXP 21
5496: PUSH
5497: LD_VAR 0 2
5501: PUSH
5502: LD_INT 10
5504: MOD
5505: ARRAY
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: LD_EXP 21
5515: PUSH
5516: LD_VAR 0 2
5520: PUSH
5521: LD_INT 10
5523: MOD
5524: ARRAY
5525: PUSH
5526: LD_INT 2
5528: ARRAY
5529: PPUSH
5530: LD_EXP 21
5534: PUSH
5535: LD_VAR 0 2
5539: PUSH
5540: LD_INT 10
5542: MOD
5543: ARRAY
5544: PUSH
5545: LD_INT 3
5547: ARRAY
5548: PPUSH
5549: LD_EXP 21
5553: PUSH
5554: LD_VAR 0 2
5558: PUSH
5559: LD_INT 10
5561: MOD
5562: ARRAY
5563: PUSH
5564: LD_INT 4
5566: ARRAY
5567: PPUSH
5568: CALL_OW 185
// tmp := tmp / 10 ;
5572: LD_ADDR_VAR 0 2
5576: PUSH
5577: LD_VAR 0 2
5581: PUSH
5582: LD_INT 10
5584: DIVREAL
5585: ST_TO_ADDR
// p := p + 1 ;
5586: LD_ADDR_VAR 0 3
5590: PUSH
5591: LD_VAR 0 3
5595: PUSH
5596: LD_INT 1
5598: PLUS
5599: ST_TO_ADDR
// if p > 5 then
5600: LD_VAR 0 3
5604: PUSH
5605: LD_INT 5
5607: GREATER
5608: IFFALSE 5634
// begin p := 1 ;
5610: LD_ADDR_VAR 0 3
5614: PUSH
5615: LD_INT 1
5617: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5618: LD_ADDR_VAR 0 2
5622: PUSH
5623: LD_EXP 23
5627: PUSH
5628: LD_EXP 24
5632: ARRAY
5633: ST_TO_ADDR
// end ; end ;
5634: GO 5454
5636: POP
5637: POP
// rng := rng + 1 ;
5638: LD_ADDR_EXP 24
5642: PUSH
5643: LD_EXP 24
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: ST_TO_ADDR
// if rng > queue_codes then
5652: LD_EXP 24
5656: PUSH
5657: LD_EXP 23
5661: GREATER
5662: IFFALSE 5672
// rng := 1 ;
5664: LD_ADDR_EXP 24
5668: PUSH
5669: LD_INT 1
5671: ST_TO_ADDR
// end ;
5672: PPOPN 3
5674: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5675: LD_INT 25
5677: PUSH
5678: LD_INT 17
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PPUSH
5685: CALL_OW 69
5689: IFFALSE 5792
5691: GO 5693
5693: DISABLE
5694: LD_INT 0
5696: PPUSH
5697: PPUSH
// begin enable ;
5698: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5699: LD_ADDR_VAR 0 1
5703: PUSH
5704: LD_INT 25
5706: PUSH
5707: LD_INT 17
5709: PUSH
5710: EMPTY
5711: LIST
5712: LIST
5713: PPUSH
5714: CALL_OW 69
5718: PUSH
5719: FOR_IN
5720: IFFALSE 5790
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5722: LD_ADDR_VAR 0 2
5726: PUSH
5727: LD_INT 81
5729: PUSH
5730: LD_EXP 8
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: PPUSH
5739: CALL_OW 69
5743: PPUSH
5744: LD_VAR 0 1
5748: PPUSH
5749: CALL_OW 74
5753: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5754: LD_VAR 0 1
5758: PPUSH
5759: LD_VAR 0 2
5763: PPUSH
5764: CALL_OW 296
5768: PUSH
5769: LD_INT 15
5771: LESS
5772: IFFALSE 5788
// ComAttackUnit ( i , un ) ;
5774: LD_VAR 0 1
5778: PPUSH
5779: LD_VAR 0 2
5783: PPUSH
5784: CALL_OW 115
// end ;
5788: GO 5719
5790: POP
5791: POP
// end ;
5792: PPOPN 2
5794: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5795: LD_EXP 20
5799: IFFALSE 5866
5801: GO 5803
5803: DISABLE
5804: LD_INT 0
5806: PPUSH
// begin enable ;
5807: ENABLE
// for i in attackers do
5808: LD_ADDR_VAR 0 1
5812: PUSH
5813: LD_EXP 20
5817: PUSH
5818: FOR_IN
5819: IFFALSE 5864
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
5821: LD_VAR 0 1
5825: PPUSH
5826: LD_INT 81
5828: PUSH
5829: LD_VAR 0 1
5833: PPUSH
5834: CALL_OW 255
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PPUSH
5843: CALL_OW 69
5847: PPUSH
5848: LD_VAR 0 1
5852: PPUSH
5853: CALL_OW 74
5857: PPUSH
5858: CALL_OW 115
5862: GO 5818
5864: POP
5865: POP
// end ;
5866: PPOPN 1
5868: END
// every 0 0$01 trigger not attackers marked 17 do
5869: LD_EXP 20
5873: NOT
5874: IFFALSE 5883
5876: GO 5878
5878: DISABLE
// begin enable ;
5879: ENABLE
// disable ( 17 ) ;
5880: LD_INT 17
5882: DISABLE_MARKED
// end ;
5883: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5884: LD_EXP 22
5888: PUSH
5889: LD_EXP 20
5893: LESSEQUAL
5894: IFFALSE 6003
5896: GO 5898
5898: DISABLE
5899: LD_INT 0
5901: PPUSH
5902: PPUSH
// begin enable ;
5903: ENABLE
// enable ( 17 ) ;
5904: LD_INT 17
5906: ENABLE_MARKED
// max := 1 ;
5907: LD_ADDR_VAR 0 1
5911: PUSH
5912: LD_INT 1
5914: ST_TO_ADDR
// for i = 1 to 8 do
5915: LD_ADDR_VAR 0 2
5919: PUSH
5920: DOUBLE
5921: LD_INT 1
5923: DEC
5924: ST_TO_ADDR
5925: LD_INT 8
5927: PUSH
5928: FOR_TO
5929: IFFALSE 6001
// if i <> bot_side then
5931: LD_VAR 0 2
5935: PUSH
5936: LD_EXP 8
5940: NONEQUAL
5941: IFFALSE 5999
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5943: LD_VAR 0 1
5947: PUSH
5948: LD_INT 22
5950: PUSH
5951: LD_VAR 0 2
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PPUSH
5960: CALL_OW 69
5964: LESS
5965: IFFALSE 5999
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5967: LD_ADDR_VAR 0 1
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_VAR 0 2
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: PPUSH
5984: CALL_OW 69
5988: ST_TO_ADDR
// target := i ;
5989: LD_ADDR_EXP 25
5993: PUSH
5994: LD_VAR 0 2
5998: ST_TO_ADDR
// end ; end ;
5999: GO 5928
6001: POP
6002: POP
// end ;
6003: PPOPN 2
6005: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
6006: LD_EXP 9
6010: PUSH
6011: LD_OWVAR 1
6015: PUSH
6016: LD_INT 63000
6018: GREATEREQUAL
6019: AND
6020: IFFALSE 6039
6022: GO 6024
6024: DISABLE
// begin veh_counter := veh_counter + 1 ;
6025: LD_ADDR_EXP 22
6029: PUSH
6030: LD_EXP 22
6034: PUSH
6035: LD_INT 1
6037: PLUS
6038: ST_TO_ADDR
// end ;
6039: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
6040: LD_EXP 9
6044: PUSH
6045: LD_OWVAR 1
6049: PUSH
6050: LD_INT 105000
6052: GREATEREQUAL
6053: AND
6054: IFFALSE 6073
6056: GO 6058
6058: DISABLE
// begin veh_counter := veh_counter + 2 ;
6059: LD_ADDR_EXP 22
6063: PUSH
6064: LD_EXP 22
6068: PUSH
6069: LD_INT 2
6071: PLUS
6072: ST_TO_ADDR
// end ;
6073: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
6074: LD_EXP 9
6078: PUSH
6079: LD_OWVAR 1
6083: PUSH
6084: LD_INT 168000
6086: GREATEREQUAL
6087: AND
6088: IFFALSE 6107
6090: GO 6092
6092: DISABLE
// begin veh_counter := veh_counter + 3 ;
6093: LD_ADDR_EXP 22
6097: PUSH
6098: LD_EXP 22
6102: PUSH
6103: LD_INT 3
6105: PLUS
6106: ST_TO_ADDR
// end ;
6107: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
6108: LD_INT 22
6110: PUSH
6111: LD_EXP 8
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 33
6122: PUSH
6123: LD_INT 2
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: PPUSH
6134: CALL_OW 69
6138: IFFALSE 6354
6140: GO 6142
6142: DISABLE
6143: LD_INT 0
6145: PPUSH
6146: PPUSH
6147: PPUSH
6148: PPUSH
6149: PPUSH
6150: PPUSH
6151: PPUSH
// begin enable ;
6152: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6153: LD_ADDR_VAR 0 4
6157: PUSH
6158: LD_INT 22
6160: PUSH
6161: LD_EXP 8
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 33
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: LD_INT 3
6182: PUSH
6183: LD_INT 61
6185: PUSH
6186: EMPTY
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL_OW 69
6202: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_INT 22
6210: PUSH
6211: LD_EXP 8
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 34
6222: PUSH
6223: LD_INT 31
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PPUSH
6234: CALL_OW 69
6238: ST_TO_ADDR
// best := 10 ;
6239: LD_ADDR_VAR 0 5
6243: PUSH
6244: LD_INT 10
6246: ST_TO_ADDR
// best_mechanic := - 1 ;
6247: LD_ADDR_VAR 0 6
6251: PUSH
6252: LD_INT 1
6254: NEG
6255: ST_TO_ADDR
// if vehs then
6256: LD_VAR 0 4
6260: IFFALSE 6354
// begin for j in cts do
6262: LD_ADDR_VAR 0 2
6266: PUSH
6267: LD_VAR 0 3
6271: PUSH
6272: FOR_IN
6273: IFFALSE 6334
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6275: LD_ADDR_VAR 0 7
6279: PUSH
6280: LD_VAR 0 2
6284: PPUSH
6285: CALL 3487 0 1
6289: PPUSH
6290: CALL_OW 432
6294: ST_TO_ADDR
// if p < best then
6295: LD_VAR 0 7
6299: PUSH
6300: LD_VAR 0 5
6304: LESS
6305: IFFALSE 6332
// begin best := p ;
6307: LD_ADDR_VAR 0 5
6311: PUSH
6312: LD_VAR 0 7
6316: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6317: LD_ADDR_VAR 0 6
6321: PUSH
6322: LD_VAR 0 2
6326: PPUSH
6327: CALL 3487 0 1
6331: ST_TO_ADDR
// end ; end ;
6332: GO 6272
6334: POP
6335: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6336: LD_VAR 0 4
6340: PUSH
6341: LD_INT 1
6343: ARRAY
6344: PPUSH
6345: LD_VAR 0 6
6349: PPUSH
6350: CALL_OW 135
// end ; end ;
6354: PPOPN 7
6356: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6357: GO 6359
6359: DISABLE
6360: LD_INT 0
6362: PPUSH
6363: PPUSH
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
6368: PPUSH
// begin enable ;
6369: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6370: LD_ADDR_VAR 0 6
6374: PUSH
6375: LD_INT 22
6377: PUSH
6378: LD_EXP 8
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: LD_INT 21
6389: PUSH
6390: LD_INT 3
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: PUSH
6397: LD_INT 3
6399: PUSH
6400: LD_INT 24
6402: PUSH
6403: LD_INT 1000
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: LIST
6418: PPUSH
6419: CALL_OW 69
6423: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6424: LD_ADDR_VAR 0 3
6428: PUSH
6429: LD_INT 22
6431: PUSH
6432: LD_EXP 8
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: PUSH
6441: LD_INT 2
6443: PUSH
6444: LD_INT 25
6446: PUSH
6447: LD_INT 1
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 25
6456: PUSH
6457: LD_INT 2
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 25
6466: PUSH
6467: LD_INT 3
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: PUSH
6480: LD_INT 3
6482: PUSH
6483: LD_INT 24
6485: PUSH
6486: LD_INT 750
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: EMPTY
6494: LIST
6495: LIST
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: LIST
6501: PPUSH
6502: CALL_OW 69
6506: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6507: LD_ADDR_VAR 0 4
6511: PUSH
6512: LD_INT 22
6514: PUSH
6515: LD_EXP 8
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 25
6526: PUSH
6527: LD_INT 4
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PPUSH
6538: CALL_OW 69
6542: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6543: LD_ADDR_VAR 0 5
6547: PUSH
6548: LD_INT 22
6550: PUSH
6551: LD_EXP 8
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: PUSH
6560: LD_INT 25
6562: PUSH
6563: LD_INT 2
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PPUSH
6574: CALL_OW 69
6578: ST_TO_ADDR
// if not h and not b then
6579: LD_VAR 0 3
6583: NOT
6584: PUSH
6585: LD_VAR 0 6
6589: NOT
6590: AND
6591: IFFALSE 6875
// begin if sci then
6593: LD_VAR 0 4
6597: IFFALSE 6734
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6599: LD_VAR 0 4
6603: PPUSH
6604: LD_INT 3
6606: PUSH
6607: LD_INT 54
6609: PUSH
6610: EMPTY
6611: LIST
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PPUSH
6617: CALL_OW 72
6621: PUSH
6622: LD_INT 22
6624: PUSH
6625: LD_EXP 8
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 30
6636: PUSH
6637: LD_INT 8
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PPUSH
6648: CALL_OW 69
6652: AND
6653: IFFALSE 6734
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6655: LD_ADDR_VAR 0 2
6659: PUSH
6660: LD_VAR 0 4
6664: PPUSH
6665: LD_INT 3
6667: PUSH
6668: LD_INT 54
6670: PUSH
6671: EMPTY
6672: LIST
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: PPUSH
6678: CALL_OW 72
6682: PUSH
6683: FOR_IN
6684: IFFALSE 6732
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6686: LD_VAR 0 2
6690: PPUSH
6691: LD_INT 22
6693: PUSH
6694: LD_EXP 8
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 30
6705: PUSH
6706: LD_INT 8
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: PPUSH
6717: CALL_OW 69
6721: PUSH
6722: LD_INT 1
6724: ARRAY
6725: PPUSH
6726: CALL_OW 120
6730: GO 6683
6732: POP
6733: POP
// if eng then
6734: LD_VAR 0 5
6738: IFFALSE 6875
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6740: LD_VAR 0 5
6744: PPUSH
6745: LD_INT 3
6747: PUSH
6748: LD_INT 54
6750: PUSH
6751: EMPTY
6752: LIST
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: PPUSH
6758: CALL_OW 72
6762: PUSH
6763: LD_INT 22
6765: PUSH
6766: LD_EXP 8
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 30
6777: PUSH
6778: LD_INT 1
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: PPUSH
6789: CALL_OW 69
6793: AND
6794: IFFALSE 6875
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6796: LD_ADDR_VAR 0 2
6800: PUSH
6801: LD_VAR 0 5
6805: PPUSH
6806: LD_INT 3
6808: PUSH
6809: LD_INT 54
6811: PUSH
6812: EMPTY
6813: LIST
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: PUSH
6824: FOR_IN
6825: IFFALSE 6873
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6827: LD_VAR 0 2
6831: PPUSH
6832: LD_INT 22
6834: PUSH
6835: LD_EXP 8
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PUSH
6844: LD_INT 30
6846: PUSH
6847: LD_INT 1
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PPUSH
6858: CALL_OW 69
6862: PUSH
6863: LD_INT 1
6865: ARRAY
6866: PPUSH
6867: CALL_OW 120
6871: GO 6824
6873: POP
6874: POP
// end ; p := 1 ;
6875: LD_ADDR_VAR 0 7
6879: PUSH
6880: LD_INT 1
6882: ST_TO_ADDR
// if b and eng then
6883: LD_VAR 0 6
6887: PUSH
6888: LD_VAR 0 5
6892: AND
6893: IFFALSE 7027
// for j in eng do
6895: LD_ADDR_VAR 0 2
6899: PUSH
6900: LD_VAR 0 5
6904: PUSH
6905: FOR_IN
6906: IFFALSE 7025
// begin if IsInUnit ( j ) then
6908: LD_VAR 0 2
6912: PPUSH
6913: CALL_OW 310
6917: IFFALSE 6930
// ComExitBuilding ( j ) else
6919: LD_VAR 0 2
6923: PPUSH
6924: CALL_OW 122
6928: GO 7023
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6930: LD_VAR 0 2
6934: PPUSH
6935: CALL_OW 314
6939: NOT
6940: PUSH
6941: LD_VAR 0 2
6945: PPUSH
6946: CALL_OW 256
6950: PUSH
6951: LD_INT 750
6953: GREATER
6954: AND
6955: IFFALSE 7023
// begin if b > p then
6957: LD_VAR 0 6
6961: PUSH
6962: LD_VAR 0 7
6966: GREATER
6967: IFFALSE 7005
// begin ComRepairBuilding ( j , b [ p ] ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_VAR 0 6
6978: PUSH
6979: LD_VAR 0 7
6983: ARRAY
6984: PPUSH
6985: CALL_OW 130
// p := p + 1 ;
6989: LD_ADDR_VAR 0 7
6993: PUSH
6994: LD_VAR 0 7
6998: PUSH
6999: LD_INT 1
7001: PLUS
7002: ST_TO_ADDR
// end else
7003: GO 7023
// ComRepairBuilding ( j , b [ 1 ] ) ;
7005: LD_VAR 0 2
7009: PPUSH
7010: LD_VAR 0 6
7014: PUSH
7015: LD_INT 1
7017: ARRAY
7018: PPUSH
7019: CALL_OW 130
// end ; end ;
7023: GO 6905
7025: POP
7026: POP
// if h and sci then
7027: LD_VAR 0 3
7031: PUSH
7032: LD_VAR 0 4
7036: AND
7037: IFFALSE 7176
// for i in h do
7039: LD_ADDR_VAR 0 1
7043: PUSH
7044: LD_VAR 0 3
7048: PUSH
7049: FOR_IN
7050: IFFALSE 7174
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
7052: LD_VAR 0 1
7056: PPUSH
7057: LD_INT 108
7059: PPUSH
7060: LD_INT 42
7062: PPUSH
7063: CALL_OW 297
7067: PUSH
7068: LD_INT 10
7070: GREATER
7071: IFFALSE 7090
// ComMoveXY ( i , 108 , 42 ) else
7073: LD_VAR 0 1
7077: PPUSH
7078: LD_INT 108
7080: PPUSH
7081: LD_INT 42
7083: PPUSH
7084: CALL_OW 111
7088: GO 7172
// begin for j in sci do
7090: LD_ADDR_VAR 0 2
7094: PUSH
7095: LD_VAR 0 4
7099: PUSH
7100: FOR_IN
7101: IFFALSE 7170
// begin if GetTag ( j ) > 0 then
7103: LD_VAR 0 2
7107: PPUSH
7108: CALL_OW 110
7112: PUSH
7113: LD_INT 0
7115: GREATER
7116: IFFALSE 7120
// continue ;
7118: GO 7100
// if IsInUnit ( j ) then
7120: LD_VAR 0 2
7124: PPUSH
7125: CALL_OW 310
7129: IFFALSE 7142
// ComExitBuilding ( j ) else
7131: LD_VAR 0 2
7135: PPUSH
7136: CALL_OW 122
7140: GO 7168
// if not HasTask ( j ) then
7142: LD_VAR 0 2
7146: PPUSH
7147: CALL_OW 314
7151: NOT
7152: IFFALSE 7168
// ComHeal ( j , h ) ;
7154: LD_VAR 0 2
7158: PPUSH
7159: LD_VAR 0 3
7163: PPUSH
7164: CALL_OW 128
// end ;
7168: GO 7100
7170: POP
7171: POP
// end ;
7172: GO 7049
7174: POP
7175: POP
// end ;
7176: PPOPN 7
7178: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7179: LD_INT 155
7181: PPUSH
7182: LD_INT 88
7184: PPUSH
7185: CALL_OW 428
7189: PUSH
7190: LD_INT 155
7192: PPUSH
7193: LD_INT 88
7195: PPUSH
7196: CALL_OW 428
7200: PUSH
7201: LD_INT 30
7203: EQUAL
7204: PPUSH
7205: CALL_OW 266
7209: AND
7210: IFFALSE 7459
7212: GO 7214
7214: DISABLE
7215: LD_INT 0
7217: PPUSH
7218: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7219: LD_ADDR_VAR 0 2
7223: PUSH
7224: LD_INT 155
7226: PPUSH
7227: LD_INT 88
7229: PPUSH
7230: CALL_OW 428
7234: PPUSH
7235: CALL_OW 255
7239: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7240: LD_INT 11550
7242: PUSH
7243: LD_INT 13755
7245: PUSH
7246: LD_INT 13335
7248: PUSH
7249: LD_INT 18340
7251: PUSH
7252: LD_INT 19985
7254: PUSH
7255: LD_INT 9555
7257: PUSH
7258: LD_INT 18935
7260: PUSH
7261: LD_INT 10535
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: PUSH
7274: LD_VAR 0 2
7278: ARRAY
7279: PPUSH
7280: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7284: LD_INT 22
7286: PUSH
7287: LD_EXP 8
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 25
7298: PUSH
7299: LD_INT 4
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PPUSH
7310: CALL_OW 69
7314: PUSH
7315: LD_INT 0
7317: EQUAL
7318: IFFALSE 7322
// exit ;
7320: GO 7459
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7322: LD_ADDR_VAR 0 1
7326: PUSH
7327: LD_INT 22
7329: PUSH
7330: LD_EXP 8
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: LD_INT 25
7341: PUSH
7342: LD_INT 4
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: PPUSH
7353: CALL_OW 69
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7362: LD_VAR 0 1
7366: PPUSH
7367: LD_INT 1
7369: PPUSH
7370: CALL_OW 109
// ComExitBuilding ( sci ) ;
7374: LD_VAR 0 1
7378: PPUSH
7379: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7383: LD_VAR 0 1
7387: PPUSH
7388: LD_INT 126
7390: PPUSH
7391: LD_INT 59
7393: PPUSH
7394: CALL_OW 171
// if p mod 2 = 0 then
7398: LD_VAR 0 2
7402: PUSH
7403: LD_INT 2
7405: MOD
7406: PUSH
7407: LD_INT 0
7409: EQUAL
7410: IFFALSE 7429
// AddComMoveXY ( sci , 148 , 66 ) else
7412: LD_VAR 0 1
7416: PPUSH
7417: LD_INT 148
7419: PPUSH
7420: LD_INT 66
7422: PPUSH
7423: CALL_OW 171
7427: GO 7444
// AddComMoveXY ( sci , 135 , 84 ) ;
7429: LD_VAR 0 1
7433: PPUSH
7434: LD_INT 135
7436: PPUSH
7437: LD_INT 84
7439: PPUSH
7440: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7444: LD_VAR 0 1
7448: PPUSH
7449: LD_INT 155
7451: PPUSH
7452: LD_INT 88
7454: PPUSH
7455: CALL_OW 218
// end ;
7459: PPOPN 2
7461: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7462: LD_INT 33
7464: PPUSH
7465: LD_INT 10
7467: PPUSH
7468: CALL_OW 428
7472: PUSH
7473: LD_INT 33
7475: PPUSH
7476: LD_INT 10
7478: PPUSH
7479: CALL_OW 428
7483: PUSH
7484: LD_INT 30
7486: EQUAL
7487: PPUSH
7488: CALL_OW 266
7492: AND
7493: IFFALSE 7744
7495: GO 7497
7497: DISABLE
7498: LD_INT 0
7500: PPUSH
7501: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7502: LD_ADDR_VAR 0 2
7506: PUSH
7507: LD_INT 33
7509: PPUSH
7510: LD_INT 10
7512: PPUSH
7513: CALL_OW 428
7517: PPUSH
7518: CALL_OW 255
7522: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7523: LD_INT 9450
7525: PUSH
7526: LD_INT 11655
7528: PUSH
7529: LD_INT 7035
7531: PUSH
7532: LD_INT 9940
7534: PUSH
7535: LD_INT 7385
7537: PUSH
7538: LD_INT 11655
7540: PUSH
7541: LD_INT 6335
7543: PUSH
7544: LD_INT 16835
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_VAR 0 2
7561: ARRAY
7562: PPUSH
7563: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7567: LD_INT 22
7569: PUSH
7570: LD_EXP 8
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 25
7581: PUSH
7582: LD_INT 4
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: PPUSH
7593: CALL_OW 69
7597: PUSH
7598: LD_INT 0
7600: EQUAL
7601: IFFALSE 7605
// exit ;
7603: GO 7744
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7605: LD_ADDR_VAR 0 1
7609: PUSH
7610: LD_INT 22
7612: PUSH
7613: LD_EXP 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 25
7624: PUSH
7625: LD_INT 4
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PPUSH
7636: CALL_OW 69
7640: PUSH
7641: LD_VAR 0 1
7645: ARRAY
7646: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7647: LD_VAR 0 1
7651: PPUSH
7652: LD_INT 1
7654: PPUSH
7655: CALL_OW 109
// ComExitBuilding ( sci ) ;
7659: LD_VAR 0 1
7663: PPUSH
7664: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7668: LD_VAR 0 1
7672: PPUSH
7673: LD_INT 67
7675: PPUSH
7676: LD_INT 13
7678: PPUSH
7679: CALL_OW 171
// if p mod 2 = 0 then
7683: LD_VAR 0 2
7687: PUSH
7688: LD_INT 2
7690: MOD
7691: PUSH
7692: LD_INT 0
7694: EQUAL
7695: IFFALSE 7714
// AddComMoveXY ( sci , 37 , 3 ) else
7697: LD_VAR 0 1
7701: PPUSH
7702: LD_INT 37
7704: PPUSH
7705: LD_INT 3
7707: PPUSH
7708: CALL_OW 171
7712: GO 7729
// AddComMoveXY ( sci , 45 , 20 ) ;
7714: LD_VAR 0 1
7718: PPUSH
7719: LD_INT 45
7721: PPUSH
7722: LD_INT 20
7724: PPUSH
7725: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7729: LD_VAR 0 1
7733: PPUSH
7734: LD_INT 33
7736: PPUSH
7737: LD_INT 10
7739: PPUSH
7740: CALL_OW 218
// end ;
7744: PPOPN 2
7746: END
// every 0 0$01 trigger mines_list do var i , p ;
7747: LD_EXP 17
7751: IFFALSE 7977
7753: GO 7755
7755: DISABLE
7756: LD_INT 0
7758: PPUSH
7759: PPUSH
// begin enable ;
7760: ENABLE
// p := 1 ;
7761: LD_ADDR_VAR 0 2
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7769: LD_ADDR_VAR 0 1
7773: PUSH
7774: DOUBLE
7775: LD_INT 1
7777: DEC
7778: ST_TO_ADDR
7779: LD_EXP 17
7783: PUSH
7784: LD_INT 2
7786: DIVREAL
7787: PUSH
7788: FOR_TO
7789: IFFALSE 7975
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7791: LD_EXP 17
7795: PUSH
7796: LD_VAR 0 2
7800: ARRAY
7801: PPUSH
7802: LD_EXP 17
7806: PUSH
7807: LD_VAR 0 2
7811: PUSH
7812: LD_INT 1
7814: PLUS
7815: ARRAY
7816: PPUSH
7817: CALL_OW 428
7821: PUSH
7822: LD_INT 0
7824: GREATER
7825: IFFALSE 7959
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7827: LD_EXP 17
7831: PUSH
7832: LD_VAR 0 2
7836: ARRAY
7837: PPUSH
7838: LD_EXP 17
7842: PUSH
7843: LD_VAR 0 2
7847: PUSH
7848: LD_INT 1
7850: PLUS
7851: ARRAY
7852: PPUSH
7853: CALL_OW 428
7857: PPUSH
7858: CALL_OW 255
7862: PUSH
7863: LD_EXP 8
7867: NONEQUAL
7868: IFFALSE 7959
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7870: LD_EXP 17
7874: PUSH
7875: LD_VAR 0 2
7879: ARRAY
7880: PPUSH
7881: LD_EXP 17
7885: PUSH
7886: LD_VAR 0 2
7890: PUSH
7891: LD_INT 1
7893: PLUS
7894: ARRAY
7895: PPUSH
7896: LD_EXP 8
7900: PPUSH
7901: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7905: LD_ADDR_EXP 17
7909: PUSH
7910: LD_EXP 17
7914: PPUSH
7915: LD_VAR 0 2
7919: PPUSH
7920: CALL_OW 3
7924: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7925: LD_ADDR_EXP 17
7929: PUSH
7930: LD_EXP 17
7934: PPUSH
7935: LD_VAR 0 2
7939: PPUSH
7940: CALL_OW 3
7944: ST_TO_ADDR
// p := p - 2 ;
7945: LD_ADDR_VAR 0 2
7949: PUSH
7950: LD_VAR 0 2
7954: PUSH
7955: LD_INT 2
7957: MINUS
7958: ST_TO_ADDR
// end ; p := p + 2 ;
7959: LD_ADDR_VAR 0 2
7963: PUSH
7964: LD_VAR 0 2
7968: PUSH
7969: LD_INT 2
7971: PLUS
7972: ST_TO_ADDR
// end ;
7973: GO 7788
7975: POP
7976: POP
// end ;
7977: PPOPN 2
7979: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7980: GO 7982
7982: DISABLE
7983: LD_INT 0
7985: PPUSH
7986: PPUSH
7987: PPUSH
7988: PPUSH
7989: PPUSH
// begin enable ;
7990: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7991: LD_ADDR_VAR 0 4
7995: PUSH
7996: LD_INT 50
7998: PUSH
7999: EMPTY
8000: LIST
8001: PUSH
8002: LD_INT 22
8004: PUSH
8005: LD_EXP 8
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PUSH
8014: LD_INT 25
8016: PUSH
8017: LD_INT 16
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: LIST
8028: PPUSH
8029: CALL_OW 69
8033: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8034: LD_ADDR_VAR 0 5
8038: PUSH
8039: LD_INT 22
8041: PUSH
8042: LD_EXP 8
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: LD_INT 2
8053: PUSH
8054: LD_INT 30
8056: PUSH
8057: LD_INT 0
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: LD_INT 30
8066: PUSH
8067: LD_INT 1
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: LIST
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PPUSH
8083: CALL_OW 69
8087: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
8088: LD_ADDR_VAR 0 3
8092: PUSH
8093: LD_INT 13
8095: PPUSH
8096: CALL_OW 435
8100: ST_TO_ADDR
// if filter and skr then
8101: LD_VAR 0 4
8105: PUSH
8106: LD_VAR 0 3
8110: AND
8111: IFFALSE 8168
// for i = 1 to filter do
8113: LD_ADDR_VAR 0 1
8117: PUSH
8118: DOUBLE
8119: LD_INT 1
8121: DEC
8122: ST_TO_ADDR
8123: LD_VAR 0 4
8127: PUSH
8128: FOR_TO
8129: IFFALSE 8166
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8131: LD_VAR 0 4
8135: PUSH
8136: LD_VAR 0 1
8140: ARRAY
8141: PPUSH
8142: LD_VAR 0 3
8146: PUSH
8147: LD_INT 1
8149: ARRAY
8150: PPUSH
8151: LD_VAR 0 3
8155: PUSH
8156: LD_INT 2
8158: ARRAY
8159: PPUSH
8160: CALL_OW 117
8164: GO 8128
8166: POP
8167: POP
// end ; end_of_file
8168: PPOPN 5
8170: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8171: LD_INT 0
8173: PPUSH
8174: PPUSH
8175: PPUSH
8176: PPUSH
// begin if un in attackers then
8177: LD_VAR 0 1
8181: PUSH
8182: LD_EXP 20
8186: IN
8187: IFFALSE 8205
// attackers := attackers diff un ;
8189: LD_ADDR_EXP 20
8193: PUSH
8194: LD_EXP 20
8198: PUSH
8199: LD_VAR 0 1
8203: DIFF
8204: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8205: LD_VAR 0 1
8209: PPUSH
8210: CALL_OW 255
8214: PUSH
8215: LD_EXP 8
8219: NONEQUAL
8220: PUSH
8221: LD_VAR 0 1
8225: PPUSH
8226: CALL_OW 255
8230: PUSH
8231: LD_INT 0
8233: GREATER
8234: AND
8235: PUSH
8236: LD_VAR 0 1
8240: PUSH
8241: LD_INT 21
8243: PUSH
8244: LD_INT 1
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PPUSH
8251: CALL_OW 69
8255: IN
8256: AND
8257: IFFALSE 8441
// begin if respawning_time_min > 0 0$00 then
8259: LD_EXP 13
8263: PUSH
8264: LD_INT 0
8266: GREATER
8267: IFFALSE 8441
// begin s := GetSide ( un ) ;
8269: LD_ADDR_VAR 0 4
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 255
8283: ST_TO_ADDR
// n := GetNation ( un ) ;
8284: LD_ADDR_VAR 0 5
8288: PUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL_OW 248
8298: ST_TO_ADDR
// cl := GetClass ( un ) ;
8299: LD_ADDR_VAR 0 3
8303: PUSH
8304: LD_VAR 0 1
8308: PPUSH
8309: CALL_OW 257
8313: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8314: LD_EXP 13
8318: PPUSH
8319: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) * cl ) ;
8323: LD_EXP 14
8327: PUSH
8328: LD_INT 350
8330: PUSH
8331: LD_OWVAR 1
8335: MUL
8336: PUSH
8337: LD_INT 10
8339: MOD
8340: PUSH
8341: LD_INT 1
8343: PLUS
8344: PUSH
8345: LD_VAR 0 3
8349: MUL
8350: MINUS
8351: PPUSH
8352: CALL_OW 67
// uc_side := s ;
8356: LD_ADDR_OWVAR 20
8360: PUSH
8361: LD_VAR 0 4
8365: ST_TO_ADDR
// uc_nation := n ;
8366: LD_ADDR_OWVAR 21
8370: PUSH
8371: LD_VAR 0 5
8375: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8376: LD_INT 0
8378: PPUSH
8379: LD_VAR 0 3
8383: PPUSH
8384: LD_EXP 11
8388: PUSH
8389: LD_INT 2
8391: MINUS
8392: PPUSH
8393: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8397: CALL_OW 44
8401: PPUSH
8402: LD_INT 17
8404: PUSH
8405: LD_INT 19
8407: PUSH
8408: LD_INT 18
8410: PUSH
8411: LD_INT 19
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: LIST
8418: LIST
8419: PUSH
8420: LD_VAR 0 3
8424: PUSH
8425: LD_INT 4
8427: MOD
8428: PUSH
8429: LD_INT 1
8431: PLUS
8432: ARRAY
8433: PPUSH
8434: LD_INT 1
8436: PPUSH
8437: CALL_OW 49
// end ; end ; end ;
8441: PPOPN 5
8443: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
8444: LD_VAR 0 1
8448: PPUSH
8449: CALL_OW 255
8453: PUSH
8454: LD_EXP 8
8458: EQUAL
8459: PUSH
8460: LD_VAR 0 1
8464: PUSH
8465: LD_INT 33
8467: PUSH
8468: LD_INT 2
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: LD_INT 21
8477: PUSH
8478: LD_INT 2
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: IN
8494: AND
8495: IFFALSE 8618
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
8497: LD_OWVAR 3
8501: PUSH
8502: LD_VAR 0 1
8506: DIFF
8507: PPUSH
8508: LD_VAR 0 1
8512: PPUSH
8513: CALL_OW 74
8517: PPUSH
8518: CALL_OW 255
8522: PUSH
8523: LD_EXP 8
8527: NONEQUAL
8528: IFFALSE 8618
// begin Wait ( 0 0$1.3 ) ;
8530: LD_INT 46
8532: PPUSH
8533: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8537: LD_VAR 0 1
8541: PPUSH
8542: CALL_OW 250
8546: PPUSH
8547: LD_VAR 0 1
8551: PPUSH
8552: CALL_OW 251
8556: PPUSH
8557: LD_INT 1
8559: PPUSH
8560: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8564: LD_VAR 0 1
8568: PPUSH
8569: CALL_OW 250
8573: PPUSH
8574: LD_VAR 0 1
8578: PPUSH
8579: CALL_OW 251
8583: PPUSH
8584: LD_INT 1
8586: PPUSH
8587: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8591: LD_VAR 0 1
8595: PPUSH
8596: CALL_OW 250
8600: PPUSH
8601: LD_VAR 0 1
8605: PPUSH
8606: CALL_OW 251
8610: PPUSH
8611: LD_INT 1
8613: PPUSH
8614: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
8618: LD_VAR 0 1
8622: PPUSH
8623: CALL_OW 263
8627: PUSH
8628: LD_INT 2
8630: EQUAL
8631: IFFALSE 8642
// ComUnlink ( un ) ;
8633: LD_VAR 0 1
8637: PPUSH
8638: CALL_OW 136
// end ;
8642: PPOPN 1
8644: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8645: LD_VAR 0 1
8649: PPUSH
8650: CALL_OW 255
8654: PUSH
8655: LD_EXP 8
8659: EQUAL
8660: IFFALSE 8691
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8662: LD_ADDR_EXP 20
8666: PUSH
8667: LD_EXP 20
8671: PPUSH
8672: LD_EXP 20
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 1
8685: PPUSH
8686: CALL_OW 2
8690: ST_TO_ADDR
// end ;
8691: PPOPN 2
8693: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8694: LD_INT 0
8696: PPUSH
8697: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8698: LD_VAR 0 1
8702: PPUSH
8703: CALL_OW 255
8707: PUSH
8708: LD_EXP 8
8712: EQUAL
8713: PUSH
8714: LD_VAR 0 1
8718: PPUSH
8719: CALL_OW 266
8723: PUSH
8724: LD_INT 32
8726: EQUAL
8727: AND
8728: IFFALSE 8826
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8730: LD_ADDR_VAR 0 4
8734: PUSH
8735: LD_INT 22
8737: PUSH
8738: LD_EXP 8
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: PUSH
8747: LD_INT 30
8749: PUSH
8750: LD_INT 5
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: PPUSH
8761: CALL_OW 69
8765: ST_TO_ADDR
// for i in arm do
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 4
8775: PUSH
8776: FOR_IN
8777: IFFALSE 8824
// if UnitsInside ( i ) < 6 then
8779: LD_VAR 0 3
8783: PPUSH
8784: CALL_OW 313
8788: PUSH
8789: LD_INT 6
8791: LESS
8792: IFFALSE 8822
// begin ComEnterUnit ( un , i ) ;
8794: LD_VAR 0 2
8798: PPUSH
8799: LD_VAR 0 3
8803: PPUSH
8804: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8808: LD_VAR 0 2
8812: PPUSH
8813: LD_INT 8
8815: PPUSH
8816: CALL_OW 183
// break ;
8820: GO 8824
// end ;
8822: GO 8776
8824: POP
8825: POP
// end ; end ; end_of_file
8826: PPOPN 4
8828: END
// every 2 2$0 do
8829: GO 8831
8831: DISABLE
// begin Anticheatcheck ;
8832: CALL_OW 514
// enable ;
8836: ENABLE
// end ; end_of_file
8837: END
// every 10 do
8838: GO 8840
8840: DISABLE
// begin if not multiplayer then
8841: LD_OWVAR 4
8845: NOT
8846: IFFALSE 8850
// exit ;
8848: GO 8935
// if tick < 100 then
8850: LD_OWVAR 1
8854: PUSH
8855: LD_INT 100
8857: LESS
8858: IFFALSE 8878
// begin if tick mod 10 = 0 then
8860: LD_OWVAR 1
8864: PUSH
8865: LD_INT 10
8867: MOD
8868: PUSH
8869: LD_INT 0
8871: EQUAL
8872: IFFALSE 8878
// MultiplayerCRC ;
8874: CALL_OW 361
// end ; if ( tick >= 100 ) then
8878: LD_OWVAR 1
8882: PUSH
8883: LD_INT 100
8885: GREATEREQUAL
8886: IFFALSE 8906
// if tick mod 20 = 0 then
8888: LD_OWVAR 1
8892: PUSH
8893: LD_INT 20
8895: MOD
8896: PUSH
8897: LD_INT 0
8899: EQUAL
8900: IFFALSE 8906
// MultiplayerCRC ;
8902: CALL_OW 361
// if ( tick >= 100 ) then
8906: LD_OWVAR 1
8910: PUSH
8911: LD_INT 100
8913: GREATEREQUAL
8914: IFFALSE 8934
// if tick mod 30 = 0 then
8916: LD_OWVAR 1
8920: PUSH
8921: LD_INT 30
8923: MOD
8924: PUSH
8925: LD_INT 0
8927: EQUAL
8928: IFFALSE 8934
// DebugLogAll ;
8930: CALL_OW 360
// enable ;
8934: ENABLE
// end ; end_of_file
8935: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
8936: LD_INT 0
8938: PPUSH
8939: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
8940: LD_ADDR_VAR 0 2
8944: PUSH
8945: LD_STRING #Multi1x1-Time
8947: PUSH
8948: LD_OWVAR 1
8952: PUSH
8953: EMPTY
8954: LIST
8955: LIST
8956: ST_TO_ADDR
// if ( ExtraStrings ) then
8957: LD_EXP 28
8961: IFFALSE 8983
// AllStrings := AllStrings ^  ^ ExtraStrings ;
8963: LD_ADDR_VAR 0 2
8967: PUSH
8968: LD_VAR 0 2
8972: PUSH
8973: LD_STRING 
8975: ADD
8976: PUSH
8977: LD_EXP 28
8981: ADD
8982: ST_TO_ADDR
// Display_Strings := AllStrings ;
8983: LD_ADDR_OWVAR 47
8987: PUSH
8988: LD_VAR 0 2
8992: ST_TO_ADDR
// end ;
8993: LD_VAR 0 1
8997: RET
// every 0 0$1 do
8998: GO 9000
9000: DISABLE
// begin ShowTimer ;
9001: CALL 8936 0 0
// enable ;
9005: ENABLE
// end ;
9006: END
