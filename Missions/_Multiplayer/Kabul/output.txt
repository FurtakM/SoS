// starting begin Game_Start := false ;
   0: LD_ADDR_EXP 9
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: CALL_OW 10
// Init ( ) ;
  12: CALL 112 0 0
// InitBot ( ) ;
  16: CALL 3663 0 0
// Game_Start := true ;
  20: LD_ADDR_EXP 9
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: LD_EXP 9
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: LD_EXP 8
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: CALL_OW 69
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: CALL_OW 106
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: LD_EXP 9
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: LD_OWVAR 2
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: CALL_OW 69
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: CALL_OW 521
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: CALL_OW 67
// YouLostInMultiplayer ;
 107: CALL_OW 107
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , attackers_tmp ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: LD_ADDR_EXP 16
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// if Multiplayer then
 124: LD_OWVAR 4
 128: IFFALSE 250
// begin Game_Type := mp_game_type ;
 130: LD_ADDR_EXP 1
 134: PUSH
 135: LD_OWVAR 6
 139: ST_TO_ADDR
// Your_Side := mp_player_side ;
 140: LD_ADDR_OWVAR 2
 144: PUSH
 145: LD_OWVAR 7
 149: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 150: LD_ADDR_EXP 2
 154: PUSH
 155: LD_OWVAR 17
 159: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 160: LD_ADDR_EXP 3
 164: PUSH
 165: LD_OWVAR 15
 169: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 170: LD_ADDR_EXP 4
 174: PUSH
 175: LD_OWVAR 16
 179: ST_TO_ADDR
// Teams := mp_teams ;
 180: LD_ADDR_EXP 5
 184: PUSH
 185: LD_OWVAR 12
 189: ST_TO_ADDR
// for i = 0 to 6 do
 190: LD_ADDR_VAR 0 2
 194: PUSH
 195: DOUBLE
 196: LD_INT 0
 198: DEC
 199: ST_TO_ADDR
 200: LD_INT 6
 202: PUSH
 203: FOR_TO
 204: IFFALSE 246
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_EXP 16
 215: PPUSH
 216: LD_EXP 16
 220: PUSH
 221: LD_INT 1
 223: PLUS
 224: PPUSH
 225: LD_VAR 0 2
 229: PPUSH
 230: CALL_OW 426
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: CALL_OW 2
 243: ST_TO_ADDR
 244: GO 203
 246: POP
 247: POP
// end else
 248: GO 401
// begin Game_Type := 1 ;
 250: LD_ADDR_EXP 1
 254: PUSH
 255: LD_INT 1
 257: ST_TO_ADDR
// Your_Side := 2 ;
 258: LD_ADDR_OWVAR 2
 262: PUSH
 263: LD_INT 2
 265: ST_TO_ADDR
// Side_Positions := [ 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 ] ;
 266: LD_ADDR_EXP 2
 270: PUSH
 271: LD_INT 0
 273: PUSH
 274: LD_INT 1
 276: PUSH
 277: LD_INT 0
 279: PUSH
 280: LD_INT 0
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// Side_Teams := [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 ] ;
 305: LD_ADDR_EXP 3
 309: PUSH
 310: LD_INT 0
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 0
 318: PUSH
 319: LD_INT 0
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 0
 327: PUSH
 328: LD_INT 0
 330: PUSH
 331: LD_INT 0
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: ST_TO_ADDR
// Side_Nations := [ 0 , 3 , 0 , 0 , 3 , 0 , 0 , 0 ] ;
 344: LD_ADDR_EXP 4
 348: PUSH
 349: LD_INT 0
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: LD_INT 0
 357: PUSH
 358: LD_INT 0
 360: PUSH
 361: LD_INT 3
 363: PUSH
 364: LD_INT 0
 366: PUSH
 367: LD_INT 0
 369: PUSH
 370: LD_INT 0
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: ST_TO_ADDR
// Teams := [ [ 2 , 5 ] ] ;
 383: LD_ADDR_EXP 5
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 5
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: PUSH
 398: EMPTY
 399: LIST
 400: ST_TO_ADDR
// end ; Side_Start := [ [ 203 , 174 ] , [ 114 , 171 ] , [ 26 , 44 ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 401: LD_ADDR_EXP 7
 405: PUSH
 406: LD_INT 203
 408: PUSH
 409: LD_INT 174
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 114
 418: PUSH
 419: LD_INT 171
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: PUSH
 426: LD_INT 26
 428: PUSH
 429: LD_INT 44
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: PUSH
 436: EMPTY
 437: PUSH
 438: EMPTY
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: ST_TO_ADDR
// Bot_Side := 2 ;
 456: LD_ADDR_EXP 8
 460: PUSH
 461: LD_INT 2
 463: ST_TO_ADDR
// for i = 1 to 8 do
 464: LD_ADDR_VAR 0 2
 468: PUSH
 469: DOUBLE
 470: LD_INT 1
 472: DEC
 473: ST_TO_ADDR
 474: LD_INT 8
 476: PUSH
 477: FOR_TO
 478: IFFALSE 621
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 480: LD_VAR 0 2
 484: PPUSH
 485: CALL_OW 530
 489: PUSH
 490: LD_VAR 0 2
 494: PPUSH
 495: CALL_OW 532
 499: OR
 500: IFFALSE 574
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 502: LD_ADDR_EXP 2
 506: PUSH
 507: LD_EXP 2
 511: PPUSH
 512: LD_VAR 0 2
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: CALL_OW 1
 524: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 525: LD_ADDR_EXP 5
 529: PUSH
 530: LD_EXP 5
 534: PPUSH
 535: LD_EXP 3
 539: PUSH
 540: LD_VAR 0 2
 544: ARRAY
 545: PPUSH
 546: LD_EXP 5
 550: PUSH
 551: LD_EXP 3
 555: PUSH
 556: LD_VAR 0 2
 560: ARRAY
 561: ARRAY
 562: PUSH
 563: LD_VAR 0 2
 567: DIFF
 568: PPUSH
 569: CALL_OW 1
 573: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 3 then
 574: LD_EXP 4
 578: PUSH
 579: LD_VAR 0 2
 583: ARRAY
 584: PUSH
 585: LD_EXP 4
 589: PUSH
 590: LD_INT 3
 592: NONEQUAL
 593: AND
 594: IFFALSE 619
// Side_Nations := Replace ( Side_Nations , i , 3 ) ;
 596: LD_ADDR_EXP 4
 600: PUSH
 601: LD_EXP 4
 605: PPUSH
 606: LD_VAR 0 2
 610: PPUSH
 611: LD_INT 3
 613: PPUSH
 614: CALL_OW 1
 618: ST_TO_ADDR
// end ;
 619: GO 477
 621: POP
 622: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 623: LD_INT 2
 625: PUSH
 626: LD_EXP 8
 630: EQUAL
 631: PUSH
 632: LD_EXP 2
 636: PUSH
 637: LD_INT 2
 639: ARRAY
 640: AND
 641: IFFALSE 651
// bot_side := 5 ;
 643: LD_ADDR_EXP 8
 647: PUSH
 648: LD_INT 5
 650: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 651: LD_INT 5
 653: PUSH
 654: LD_EXP 8
 658: EQUAL
 659: PUSH
 660: LD_EXP 2
 664: PUSH
 665: LD_INT 5
 667: ARRAY
 668: AND
 669: IFFALSE 679
// bot_side := 8 ;
 671: LD_ADDR_EXP 8
 675: PUSH
 676: LD_INT 8
 678: ST_TO_ADDR
// Team_Game := false ;
 679: LD_ADDR_EXP 6
 683: PUSH
 684: LD_INT 0
 686: ST_TO_ADDR
// for i = 1 to 8 do
 687: LD_ADDR_VAR 0 2
 691: PUSH
 692: DOUBLE
 693: LD_INT 1
 695: DEC
 696: ST_TO_ADDR
 697: LD_INT 8
 699: PUSH
 700: FOR_TO
 701: IFFALSE 727
// if Side_Teams [ i ] then
 703: LD_EXP 3
 707: PUSH
 708: LD_VAR 0 2
 712: ARRAY
 713: IFFALSE 725
// begin Team_Game := true ;
 715: LD_ADDR_EXP 6
 719: PUSH
 720: LD_INT 1
 722: ST_TO_ADDR
// break ;
 723: GO 727
// end ;
 725: GO 700
 727: POP
 728: POP
// for i in Teams do
 729: LD_ADDR_VAR 0 2
 733: PUSH
 734: LD_EXP 5
 738: PUSH
 739: FOR_IN
 740: IFFALSE 820
// for j = 2 to i do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 2
 750: DEC
 751: ST_TO_ADDR
 752: LD_VAR 0 2
 756: PUSH
 757: FOR_TO
 758: IFFALSE 816
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 760: LD_VAR 0 2
 764: PUSH
 765: LD_VAR 0 3
 769: ARRAY
 770: PPUSH
 771: LD_VAR 0 2
 775: PUSH
 776: LD_INT 1
 778: ARRAY
 779: PPUSH
 780: CALL_OW 343
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 784: LD_VAR 0 2
 788: PUSH
 789: LD_VAR 0 3
 793: ARRAY
 794: PPUSH
 795: LD_VAR 0 2
 799: PUSH
 800: LD_INT 1
 802: ARRAY
 803: PPUSH
 804: LD_INT 1
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: CALL_OW 80
// end ;
 814: GO 757
 816: POP
 817: POP
 818: GO 739
 820: POP
 821: POP
// if not Multiplayer then
 822: LD_OWVAR 4
 826: NOT
 827: IFFALSE 864
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 829: LD_ADDR_EXP 16
 833: PUSH
 834: LD_INT 1
 836: PUSH
 837: LD_INT 1
 839: PUSH
 840: LD_INT 1
 842: PUSH
 843: LD_INT 1
 845: PUSH
 846: LD_INT 2
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 3
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: ST_TO_ADDR
// number_of_people := [ 9 , 12 , 15 , 24 ] [ definitions [ 1 ] ] ;
 864: LD_ADDR_EXP 10
 868: PUSH
 869: LD_INT 9
 871: PUSH
 872: LD_INT 12
 874: PUSH
 875: LD_INT 15
 877: PUSH
 878: LD_INT 24
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: LIST
 885: LIST
 886: PUSH
 887: LD_EXP 16
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: ARRAY
 896: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 897: LD_ADDR_EXP 11
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: LD_INT 4
 907: PUSH
 908: LD_INT 6
 910: PUSH
 911: LD_INT 8
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: PUSH
 920: LD_EXP 16
 924: PUSH
 925: LD_INT 2
 927: ARRAY
 928: ARRAY
 929: ST_TO_ADDR
// crates_spawn := [ 0 0$30 , 0 0$25 , 0 0$20 , 0 0$17 ] [ definitions [ 3 ] ] ;
 930: LD_ADDR_EXP 12
 934: PUSH
 935: LD_INT 1050
 937: PUSH
 938: LD_INT 875
 940: PUSH
 941: LD_INT 700
 943: PUSH
 944: LD_INT 595
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: LIST
 951: LIST
 952: PUSH
 953: LD_EXP 16
 957: PUSH
 958: LD_INT 3
 960: ARRAY
 961: ARRAY
 962: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ definitions [ 4 ] ] ;
 963: LD_ADDR_EXP 13
 967: PUSH
 968: LD_INT 0
 970: PUSH
 971: LD_INT 10500
 973: PUSH
 974: LD_INT 6300
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_EXP 16
 986: PUSH
 987: LD_INT 4
 989: ARRAY
 990: ARRAY
 991: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ definitions [ 4 ] ] ;
 992: LD_ADDR_EXP 14
 996: PUSH
 997: LD_INT 0
 999: PUSH
1000: LD_INT 31500
1002: PUSH
1003: LD_INT 10500
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_EXP 16
1015: PUSH
1016: LD_INT 4
1018: ARRAY
1019: ARRAY
1020: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 5 ] ] ;
1021: LD_ADDR_EXP 15
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 3
1031: PUSH
1032: LD_INT 5
1034: PUSH
1035: LD_INT 7
1037: PUSH
1038: EMPTY
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_EXP 16
1048: PUSH
1049: LD_INT 5
1051: ARRAY
1052: ARRAY
1053: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 6 ] ] ;
1054: LD_ADDR_OWVAR 67
1058: PUSH
1059: LD_INT 1
1061: PUSH
1062: LD_INT 2
1064: PUSH
1065: LD_INT 3
1067: PUSH
1068: EMPTY
1069: LIST
1070: LIST
1071: LIST
1072: PUSH
1073: LD_EXP 16
1077: PUSH
1078: LD_INT 6
1080: ARRAY
1081: ARRAY
1082: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 7 ] ] ;
1083: LD_ADDR_EXP 26
1087: PUSH
1088: LD_INT 0
1090: PUSH
1091: LD_INT 1
1093: PUSH
1094: LD_INT 2
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PUSH
1102: LD_EXP 16
1106: PUSH
1107: LD_INT 7
1109: ARRAY
1110: ARRAY
1111: ST_TO_ADDR
// queue_codes := [ 11353 , 12244 , 44444 , 12345 , 43413 , 14152 ] ;
1112: LD_ADDR_EXP 23
1116: PUSH
1117: LD_INT 11353
1119: PUSH
1120: LD_INT 12244
1122: PUSH
1123: LD_INT 44444
1125: PUSH
1126: LD_INT 12345
1128: PUSH
1129: LD_INT 43413
1131: PUSH
1132: LD_INT 14152
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: ST_TO_ADDR
// rng := Rand ( 1 , 6 ) ;
1143: LD_ADDR_EXP 24
1147: PUSH
1148: LD_INT 1
1150: PPUSH
1151: LD_INT 6
1153: PPUSH
1154: CALL_OW 12
1158: ST_TO_ADDR
// if bot_side <> 2 then
1159: LD_EXP 8
1163: PUSH
1164: LD_INT 2
1166: NONEQUAL
1167: IFFALSE 1210
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1169: LD_ADDR_VAR 0 2
1173: PUSH
1174: LD_INT 22
1176: PUSH
1177: LD_INT 2
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: PPUSH
1184: CALL_OW 69
1188: PUSH
1189: FOR_IN
1190: IFFALSE 1208
// SetSide ( i , bot_side ) ;
1192: LD_VAR 0 2
1196: PPUSH
1197: LD_EXP 8
1201: PPUSH
1202: CALL_OW 235
1206: GO 1189
1208: POP
1209: POP
// ResetFog ;
1210: CALL_OW 335
// PreparePeople ( ) ;
1214: CALL 2044 0 0
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1218: LD_ADDR_EXP 18
1222: PUSH
1223: LD_INT 14
1225: PUSH
1226: LD_INT 15
1228: PUSH
1229: LD_INT 16
1231: PUSH
1232: EMPTY
1233: LIST
1234: LIST
1235: LIST
1236: ST_TO_ADDR
// if amount_of_apeman then
1237: LD_EXP 15
1241: IFFALSE 1291
// for j in apeman_areas do
1243: LD_ADDR_VAR 0 3
1247: PUSH
1248: LD_EXP 18
1252: PUSH
1253: FOR_IN
1254: IFFALSE 1289
// for i = 1 to amount_of_apeman do
1256: LD_ADDR_VAR 0 2
1260: PUSH
1261: DOUBLE
1262: LD_INT 1
1264: DEC
1265: ST_TO_ADDR
1266: LD_EXP 15
1270: PUSH
1271: FOR_TO
1272: IFFALSE 1285
// AddApeman ( j ) ;
1274: LD_VAR 0 3
1278: PPUSH
1279: CALL 2993 0 1
1283: GO 1271
1285: POP
1286: POP
1287: GO 1253
1289: POP
1290: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1291: LD_INT 22
1293: PUSH
1294: LD_OWVAR 2
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PUSH
1308: LD_INT 1
1310: ARRAY
1311: PPUSH
1312: CALL_OW 87
// disable ( 17 ) ;
1316: LD_INT 17
1318: DISABLE_MARKED
// end ;
1319: LD_VAR 0 1
1323: RET
// every 3 3$40 trigger game_start do
1324: LD_EXP 9
1328: IFFALSE 1384
1330: GO 1332
1332: DISABLE
// begin CreateCratesArea ( tick mod 5 + 1 , kabul_crates , true ) ;
1333: LD_OWVAR 1
1337: PUSH
1338: LD_INT 5
1340: MOD
1341: PUSH
1342: LD_INT 1
1344: PLUS
1345: PPUSH
1346: LD_INT 13
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: CALL_OW 55
// Wait ( 0 0$15 ) ;
1356: LD_INT 525
1358: PPUSH
1359: CALL_OW 67
// CreateCratesAnywhere ( tick mod 5 + 1 , true ) ;
1363: LD_OWVAR 1
1367: PUSH
1368: LD_INT 5
1370: MOD
1371: PUSH
1372: LD_INT 1
1374: PLUS
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL_OW 57
// enable ;
1383: ENABLE
// end ;
1384: END
// every 0 0$01 + 0 0$10 trigger game_start do var cr , cr_queue ;
1385: LD_EXP 9
1389: IFFALSE 2041
1391: GO 1393
1393: DISABLE
1394: LD_INT 0
1396: PPUSH
1397: PPUSH
// begin cr := 1 ;
1398: LD_ADDR_VAR 0 1
1402: PUSH
1403: LD_INT 1
1405: ST_TO_ADDR
// cr_queue := [ rand ( 1 , 3 ) , rand ( 2 , 4 ) , rand ( 3 , 5 ) , rand ( 3 , 5 ) , rand ( 2 , 5 ) , rand ( 1 , 5 ) ] ;
1406: LD_ADDR_VAR 0 2
1410: PUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 3
1416: PPUSH
1417: CALL_OW 12
1421: PUSH
1422: LD_INT 2
1424: PPUSH
1425: LD_INT 4
1427: PPUSH
1428: CALL_OW 12
1432: PUSH
1433: LD_INT 3
1435: PPUSH
1436: LD_INT 5
1438: PPUSH
1439: CALL_OW 12
1443: PUSH
1444: LD_INT 3
1446: PPUSH
1447: LD_INT 5
1449: PPUSH
1450: CALL_OW 12
1454: PUSH
1455: LD_INT 2
1457: PPUSH
1458: LD_INT 5
1460: PPUSH
1461: CALL_OW 12
1465: PUSH
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 5
1471: PPUSH
1472: CALL_OW 12
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: ST_TO_ADDR
// while ( true ) do
1485: LD_INT 1
1487: IFFALSE 2041
// begin Wait ( crates_spawn + ( tick mod 35 * 60 ) ) ;
1489: LD_EXP 12
1493: PUSH
1494: LD_OWVAR 1
1498: PUSH
1499: LD_INT 35
1501: MOD
1502: PUSH
1503: LD_INT 60
1505: MUL
1506: PLUS
1507: PPUSH
1508: CALL_OW 67
// if cr mod 3 = 0 then
1512: LD_VAR 0 1
1516: PUSH
1517: LD_INT 3
1519: MOD
1520: PUSH
1521: LD_INT 0
1523: EQUAL
1524: IFFALSE 1677
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1526: LD_VAR 0 2
1530: PUSH
1531: LD_VAR 0 1
1535: PUSH
1536: LD_VAR 0 2
1540: MOD
1541: PUSH
1542: LD_INT 1
1544: PLUS
1545: ARRAY
1546: PPUSH
1547: LD_INT 17
1549: PPUSH
1550: LD_INT 1
1552: PPUSH
1553: CALL_OW 55
// Wait ( crates_spawn ) ;
1557: LD_EXP 12
1561: PPUSH
1562: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1566: LD_VAR 0 2
1570: PUSH
1571: LD_VAR 0 1
1575: PUSH
1576: LD_VAR 0 2
1580: MOD
1581: PUSH
1582: LD_INT 1
1584: PLUS
1585: ARRAY
1586: PPUSH
1587: LD_INT 18
1589: PPUSH
1590: LD_INT 1
1592: PPUSH
1593: CALL_OW 55
// Wait ( crates_spawn ) ;
1597: LD_EXP 12
1601: PPUSH
1602: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1606: LD_VAR 0 2
1610: PUSH
1611: LD_VAR 0 1
1615: PUSH
1616: LD_VAR 0 2
1620: MOD
1621: PUSH
1622: LD_INT 1
1624: PLUS
1625: ARRAY
1626: PPUSH
1627: LD_INT 19
1629: PPUSH
1630: LD_INT 1
1632: PPUSH
1633: CALL_OW 55
// Wait ( crates_spawn ) ;
1637: LD_EXP 12
1641: PPUSH
1642: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1646: LD_VAR 0 2
1650: PUSH
1651: LD_VAR 0 1
1655: PUSH
1656: LD_VAR 0 2
1660: MOD
1661: PUSH
1662: LD_INT 1
1664: PLUS
1665: ARRAY
1666: PPUSH
1667: LD_INT 17
1669: PPUSH
1670: LD_INT 1
1672: PPUSH
1673: CALL_OW 55
// end ; if cr mod 3 = 1 then
1677: LD_VAR 0 1
1681: PUSH
1682: LD_INT 3
1684: MOD
1685: PUSH
1686: LD_INT 1
1688: EQUAL
1689: IFFALSE 1842
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1691: LD_VAR 0 2
1695: PUSH
1696: LD_VAR 0 1
1700: PUSH
1701: LD_VAR 0 2
1705: MOD
1706: PUSH
1707: LD_INT 1
1709: PLUS
1710: ARRAY
1711: PPUSH
1712: LD_INT 18
1714: PPUSH
1715: LD_INT 1
1717: PPUSH
1718: CALL_OW 55
// Wait ( crates_spawn ) ;
1722: LD_EXP 12
1726: PPUSH
1727: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1731: LD_VAR 0 2
1735: PUSH
1736: LD_VAR 0 1
1740: PUSH
1741: LD_VAR 0 2
1745: MOD
1746: PUSH
1747: LD_INT 1
1749: PLUS
1750: ARRAY
1751: PPUSH
1752: LD_INT 17
1754: PPUSH
1755: LD_INT 1
1757: PPUSH
1758: CALL_OW 55
// Wait ( crates_spawn ) ;
1762: LD_EXP 12
1766: PPUSH
1767: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1771: LD_VAR 0 2
1775: PUSH
1776: LD_VAR 0 1
1780: PUSH
1781: LD_VAR 0 2
1785: MOD
1786: PUSH
1787: LD_INT 1
1789: PLUS
1790: ARRAY
1791: PPUSH
1792: LD_INT 19
1794: PPUSH
1795: LD_INT 1
1797: PPUSH
1798: CALL_OW 55
// Wait ( crates_spawn ) ;
1802: LD_EXP 12
1806: PPUSH
1807: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1811: LD_VAR 0 2
1815: PUSH
1816: LD_VAR 0 1
1820: PUSH
1821: LD_VAR 0 2
1825: MOD
1826: PUSH
1827: LD_INT 1
1829: PLUS
1830: ARRAY
1831: PPUSH
1832: LD_INT 18
1834: PPUSH
1835: LD_INT 1
1837: PPUSH
1838: CALL_OW 55
// end ; if cr mod 3 = 2 then
1842: LD_VAR 0 1
1846: PUSH
1847: LD_INT 3
1849: MOD
1850: PUSH
1851: LD_INT 2
1853: EQUAL
1854: IFFALSE 2007
// begin CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1856: LD_VAR 0 2
1860: PUSH
1861: LD_VAR 0 1
1865: PUSH
1866: LD_VAR 0 2
1870: MOD
1871: PUSH
1872: LD_INT 1
1874: PLUS
1875: ARRAY
1876: PPUSH
1877: LD_INT 19
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: CALL_OW 55
// Wait ( crates_spawn ) ;
1887: LD_EXP 12
1891: PPUSH
1892: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr2 , true ) ;
1896: LD_VAR 0 2
1900: PUSH
1901: LD_VAR 0 1
1905: PUSH
1906: LD_VAR 0 2
1910: MOD
1911: PUSH
1912: LD_INT 1
1914: PLUS
1915: ARRAY
1916: PPUSH
1917: LD_INT 18
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: CALL_OW 55
// Wait ( crates_spawn ) ;
1927: LD_EXP 12
1931: PPUSH
1932: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr1 , true ) ;
1936: LD_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PUSH
1946: LD_VAR 0 2
1950: MOD
1951: PUSH
1952: LD_INT 1
1954: PLUS
1955: ARRAY
1956: PPUSH
1957: LD_INT 17
1959: PPUSH
1960: LD_INT 1
1962: PPUSH
1963: CALL_OW 55
// Wait ( crates_spawn ) ;
1967: LD_EXP 12
1971: PPUSH
1972: CALL_OW 67
// CreateCratesArea ( cr_queue [ cr mod cr_queue + 1 ] , cr3 , true ) ;
1976: LD_VAR 0 2
1980: PUSH
1981: LD_VAR 0 1
1985: PUSH
1986: LD_VAR 0 2
1990: MOD
1991: PUSH
1992: LD_INT 1
1994: PLUS
1995: ARRAY
1996: PPUSH
1997: LD_INT 19
1999: PPUSH
2000: LD_INT 1
2002: PPUSH
2003: CALL_OW 55
// end ; cr := cr + 1 ;
2007: LD_ADDR_VAR 0 1
2011: PUSH
2012: LD_VAR 0 1
2016: PUSH
2017: LD_INT 1
2019: PLUS
2020: ST_TO_ADDR
// if cr > 150 then
2021: LD_VAR 0 1
2025: PUSH
2026: LD_INT 150
2028: GREATER
2029: IFFALSE 2039
// cr := 43 ;
2031: LD_ADDR_VAR 0 1
2035: PUSH
2036: LD_INT 43
2038: ST_TO_ADDR
// end ;
2039: GO 1485
// end ; end_of_file
2041: PPOPN 2
2043: END
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
2044: LD_INT 0
2046: PPUSH
2047: PPUSH
2048: PPUSH
2049: PPUSH
2050: PPUSH
2051: PPUSH
2052: PPUSH
2053: PPUSH
2054: PPUSH
// to_copy := [ ] ;
2055: LD_ADDR_VAR 0 5
2059: PUSH
2060: EMPTY
2061: ST_TO_ADDR
// for i = 1 to 8 do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: DOUBLE
2068: LD_INT 1
2070: DEC
2071: ST_TO_ADDR
2072: LD_INT 8
2074: PUSH
2075: FOR_TO
2076: IFFALSE 2986
// begin if Side_Positions [ i ] then
2078: LD_EXP 2
2082: PUSH
2083: LD_VAR 0 2
2087: ARRAY
2088: IFFALSE 2984
// begin uc_side := i ;
2090: LD_ADDR_OWVAR 20
2094: PUSH
2095: LD_VAR 0 2
2099: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
2100: LD_ADDR_OWVAR 21
2104: PUSH
2105: LD_EXP 4
2109: PUSH
2110: LD_VAR 0 2
2114: ARRAY
2115: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
2116: LD_ADDR_VAR 0 6
2120: PUSH
2121: LD_EXP 7
2125: PUSH
2126: LD_EXP 2
2130: PUSH
2131: LD_VAR 0 2
2135: ARRAY
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
2142: LD_ADDR_VAR 0 7
2146: PUSH
2147: LD_EXP 7
2151: PUSH
2152: LD_EXP 2
2156: PUSH
2157: LD_VAR 0 2
2161: ARRAY
2162: ARRAY
2163: PUSH
2164: LD_INT 2
2166: ARRAY
2167: ST_TO_ADDR
// hc_importance := 100 ;
2168: LD_ADDR_OWVAR 32
2172: PUSH
2173: LD_INT 100
2175: ST_TO_ADDR
// if Multiplayer then
2176: LD_OWVAR 4
2180: IFFALSE 2238
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2182: LD_ADDR_OWVAR 26
2186: PUSH
2187: LD_OWVAR 19
2191: PUSH
2192: LD_OWVAR 20
2196: ARRAY
2197: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2198: LD_ADDR_OWVAR 33
2202: PUSH
2203: LD_STRING MULTIAVATARS
2205: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2206: LD_ADDR_OWVAR 34
2210: PUSH
2211: LD_OWVAR 20
2215: PPUSH
2216: CALL_OW 525
2220: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2221: LD_ADDR_OWVAR 27
2225: PUSH
2226: LD_OWVAR 20
2230: PPUSH
2231: CALL_OW 526
2235: ST_TO_ADDR
// end else
2236: GO 2270
// begin hc_name :=  ;
2238: LD_ADDR_OWVAR 26
2242: PUSH
2243: LD_STRING 
2245: ST_TO_ADDR
// hc_gallery :=  ;
2246: LD_ADDR_OWVAR 33
2250: PUSH
2251: LD_STRING 
2253: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
2254: LD_ADDR_OWVAR 27
2258: PUSH
2259: LD_INT 1
2261: PPUSH
2262: LD_INT 2
2264: PPUSH
2265: CALL_OW 12
2269: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
2270: LD_OWVAR 27
2274: PPUSH
2275: LD_INT 1
2277: PPUSH
2278: LD_EXP 11
2282: PPUSH
2283: CALL_OW 380
// un := CreateHuman ;
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: CALL_OW 44
2296: ST_TO_ADDR
// if not to_copy then
2297: LD_VAR 0 5
2301: NOT
2302: IFFALSE 2329
// to_copy := Replace ( to_copy , 1 , un ) else
2304: LD_ADDR_VAR 0 5
2308: PUSH
2309: LD_VAR 0 5
2313: PPUSH
2314: LD_INT 1
2316: PPUSH
2317: LD_VAR 0 4
2321: PPUSH
2322: CALL_OW 1
2326: ST_TO_ADDR
2327: GO 2405
// begin CopySkills ( to_copy [ 1 ] , un ) ;
2329: LD_VAR 0 5
2333: PUSH
2334: LD_INT 1
2336: ARRAY
2337: PPUSH
2338: LD_VAR 0 4
2342: PPUSH
2343: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
2347: LD_VAR 0 4
2351: PPUSH
2352: LD_INT 2
2354: PPUSH
2355: LD_VAR 0 5
2359: PUSH
2360: LD_INT 1
2362: ARRAY
2363: PPUSH
2364: LD_INT 2
2366: PPUSH
2367: CALL_OW 260
2371: PPUSH
2372: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
2376: LD_VAR 0 4
2380: PPUSH
2381: LD_INT 1
2383: PPUSH
2384: LD_VAR 0 5
2388: PUSH
2389: LD_INT 1
2391: ARRAY
2392: PPUSH
2393: LD_INT 1
2395: PPUSH
2396: CALL_OW 260
2400: PPUSH
2401: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2405: LD_VAR 0 4
2409: PPUSH
2410: LD_VAR 0 6
2414: PPUSH
2415: LD_VAR 0 7
2419: PPUSH
2420: LD_INT 10
2422: PPUSH
2423: LD_INT 0
2425: PPUSH
2426: CALL_OW 50
// hc_importance := 0 ;
2430: LD_ADDR_OWVAR 32
2434: PUSH
2435: LD_INT 0
2437: ST_TO_ADDR
// hc_name :=  ;
2438: LD_ADDR_OWVAR 26
2442: PUSH
2443: LD_STRING 
2445: ST_TO_ADDR
// hc_gallery :=  ;
2446: LD_ADDR_OWVAR 33
2450: PUSH
2451: LD_STRING 
2453: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
2454: LD_ADDR_VAR 0 9
2458: PUSH
2459: LD_EXP 10
2463: PUSH
2464: LD_INT 1
2466: MINUS
2467: PUSH
2468: LD_INT 4
2470: DIVREAL
2471: ST_TO_ADDR
// c := 1 ;
2472: LD_ADDR_VAR 0 8
2476: PUSH
2477: LD_INT 1
2479: ST_TO_ADDR
// for j = 2 to number_of_people do
2480: LD_ADDR_VAR 0 3
2484: PUSH
2485: DOUBLE
2486: LD_INT 2
2488: DEC
2489: ST_TO_ADDR
2490: LD_EXP 10
2494: PUSH
2495: FOR_TO
2496: IFFALSE 2707
// begin PrepareHuman ( false , c , skill_level ) ;
2498: LD_INT 0
2500: PPUSH
2501: LD_VAR 0 8
2505: PPUSH
2506: LD_EXP 11
2510: PPUSH
2511: CALL_OW 380
// if ( j - 1 ) mod d = 0 then
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 1
2522: MINUS
2523: PUSH
2524: LD_VAR 0 9
2528: MOD
2529: PUSH
2530: LD_INT 0
2532: EQUAL
2533: IFFALSE 2549
// c := c + 1 ;
2535: LD_ADDR_VAR 0 8
2539: PUSH
2540: LD_VAR 0 8
2544: PUSH
2545: LD_INT 1
2547: PLUS
2548: ST_TO_ADDR
// un := CreateHuman ;
2549: LD_ADDR_VAR 0 4
2553: PUSH
2554: CALL_OW 44
2558: ST_TO_ADDR
// if to_copy < j then
2559: LD_VAR 0 5
2563: PUSH
2564: LD_VAR 0 3
2568: LESS
2569: IFFALSE 2598
// to_copy := Replace ( to_copy , j , un ) else
2571: LD_ADDR_VAR 0 5
2575: PUSH
2576: LD_VAR 0 5
2580: PPUSH
2581: LD_VAR 0 3
2585: PPUSH
2586: LD_VAR 0 4
2590: PPUSH
2591: CALL_OW 1
2595: ST_TO_ADDR
2596: GO 2680
// begin CopySkills ( to_copy [ j ] , un ) ;
2598: LD_VAR 0 5
2602: PUSH
2603: LD_VAR 0 3
2607: ARRAY
2608: PPUSH
2609: LD_VAR 0 4
2613: PPUSH
2614: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
2618: LD_VAR 0 4
2622: PPUSH
2623: LD_INT 2
2625: PPUSH
2626: LD_VAR 0 5
2630: PUSH
2631: LD_VAR 0 3
2635: ARRAY
2636: PPUSH
2637: LD_INT 2
2639: PPUSH
2640: CALL_OW 260
2644: PPUSH
2645: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
2649: LD_VAR 0 4
2653: PPUSH
2654: LD_INT 1
2656: PPUSH
2657: LD_VAR 0 5
2661: PUSH
2662: LD_VAR 0 3
2666: ARRAY
2667: PPUSH
2668: LD_INT 1
2670: PPUSH
2671: CALL_OW 260
2675: PPUSH
2676: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
2680: LD_VAR 0 4
2684: PPUSH
2685: LD_VAR 0 6
2689: PPUSH
2690: LD_VAR 0 7
2694: PPUSH
2695: LD_INT 10
2697: PPUSH
2698: LD_INT 0
2700: PPUSH
2701: CALL_OW 50
// end ;
2705: GO 2495
2707: POP
2708: POP
// if handicap then
2709: LD_EXP 26
2713: IFFALSE 2984
// begin if handicap = 1 then
2715: LD_EXP 26
2719: PUSH
2720: LD_INT 1
2722: EQUAL
2723: IFFALSE 2802
// for j = 1 to 2 do
2725: LD_ADDR_VAR 0 3
2729: PUSH
2730: DOUBLE
2731: LD_INT 1
2733: DEC
2734: ST_TO_ADDR
2735: LD_INT 2
2737: PUSH
2738: FOR_TO
2739: IFFALSE 2800
// begin vc_chassis := ru_medium_tracked ;
2741: LD_ADDR_OWVAR 37
2745: PUSH
2746: LD_INT 22
2748: ST_TO_ADDR
// vc_engine := engine_combustion ;
2749: LD_ADDR_OWVAR 39
2753: PUSH
2754: LD_INT 1
2756: ST_TO_ADDR
// vc_control := control_manual ;
2757: LD_ADDR_OWVAR 38
2761: PUSH
2762: LD_INT 1
2764: ST_TO_ADDR
// vc_weapon := ru_gun ;
2765: LD_ADDR_OWVAR 40
2769: PUSH
2770: LD_INT 44
2772: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2773: CALL_OW 45
2777: PPUSH
2778: LD_VAR 0 6
2782: PPUSH
2783: LD_VAR 0 7
2787: PPUSH
2788: LD_INT 13
2790: PPUSH
2791: LD_INT 0
2793: PPUSH
2794: CALL_OW 50
// end ;
2798: GO 2738
2800: POP
2801: POP
// if handicap = 2 then
2802: LD_EXP 26
2806: PUSH
2807: LD_INT 2
2809: EQUAL
2810: IFFALSE 2984
// begin for j = 1 to 2 do
2812: LD_ADDR_VAR 0 3
2816: PUSH
2817: DOUBLE
2818: LD_INT 1
2820: DEC
2821: ST_TO_ADDR
2822: LD_INT 2
2824: PUSH
2825: FOR_TO
2826: IFFALSE 2900
// begin vc_chassis := ru_heavy_tracked ;
2828: LD_ADDR_OWVAR 37
2832: PUSH
2833: LD_INT 24
2835: ST_TO_ADDR
// vc_engine := engine_combustion ;
2836: LD_ADDR_OWVAR 39
2840: PUSH
2841: LD_INT 1
2843: ST_TO_ADDR
// vc_control := control_manual ;
2844: LD_ADDR_OWVAR 38
2848: PUSH
2849: LD_INT 1
2851: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_heavy_gun ] [ j ] ;
2852: LD_ADDR_OWVAR 40
2856: PUSH
2857: LD_INT 43
2859: PUSH
2860: LD_INT 46
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: PUSH
2867: LD_VAR 0 3
2871: ARRAY
2872: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2873: CALL_OW 45
2877: PPUSH
2878: LD_VAR 0 6
2882: PPUSH
2883: LD_VAR 0 7
2887: PPUSH
2888: LD_INT 13
2890: PPUSH
2891: LD_INT 0
2893: PPUSH
2894: CALL_OW 50
// end ;
2898: GO 2825
2900: POP
2901: POP
// vc_chassis := ru_medium_tracked ;
2902: LD_ADDR_OWVAR 37
2906: PUSH
2907: LD_INT 22
2909: ST_TO_ADDR
// vc_engine := engine_siberite ;
2910: LD_ADDR_OWVAR 39
2914: PUSH
2915: LD_INT 3
2917: ST_TO_ADDR
// vc_control := control_computer ;
2918: LD_ADDR_OWVAR 38
2922: PUSH
2923: LD_INT 3
2925: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2926: LD_ADDR_OWVAR 40
2930: PUSH
2931: LD_INT 51
2933: ST_TO_ADDR
// un := CreateVehicle ;
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: CALL_OW 45
2943: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , 13 , false ) ;
2944: LD_VAR 0 4
2948: PPUSH
2949: LD_VAR 0 6
2953: PPUSH
2954: LD_VAR 0 7
2958: PPUSH
2959: LD_INT 13
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 50
// SetCargo ( un , mat_cans , 100 ) ;
2969: LD_VAR 0 4
2973: PPUSH
2974: LD_INT 1
2976: PPUSH
2977: LD_INT 100
2979: PPUSH
2980: CALL_OW 290
// end ; end ; end ; end ;
2984: GO 2075
2986: POP
2987: POP
// end ;
2988: LD_VAR 0 1
2992: RET
// export function AddApeman ( area ) ; begin
2993: LD_INT 0
2995: PPUSH
// uc_nation := 0 ;
2996: LD_ADDR_OWVAR 21
3000: PUSH
3001: LD_INT 0
3003: ST_TO_ADDR
// uc_side := 0 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 0
3011: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
3012: LD_ADDR_OWVAR 35
3016: PUSH
3017: LD_INT 10
3019: NEG
3020: PPUSH
3021: LD_INT 15
3023: PPUSH
3024: CALL_OW 12
3028: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3029: LD_INT 0
3031: PPUSH
3032: LD_INT 12
3034: PPUSH
3035: LD_INT 0
3037: PPUSH
3038: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3042: LD_ADDR_OWVAR 29
3046: PUSH
3047: LD_INT 10
3049: PUSH
3050: LD_INT 12
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
3057: CALL_OW 44
3061: PPUSH
3062: LD_VAR 0 1
3066: PPUSH
3067: LD_INT 0
3069: PPUSH
3070: CALL_OW 49
// end ;
3074: LD_VAR 0 2
3078: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
3079: LD_INT 0
3081: PPUSH
3082: PPUSH
3083: PPUSH
3084: PPUSH
// r := 100 ;
3085: LD_ADDR_VAR 0 5
3089: PUSH
3090: LD_INT 100
3092: ST_TO_ADDR
// x := 0 ;
3093: LD_ADDR_VAR 0 6
3097: PUSH
3098: LD_INT 0
3100: ST_TO_ADDR
// while ( x < n ) do
3101: LD_VAR 0 6
3105: PUSH
3106: LD_VAR 0 2
3110: LESS
3111: IFFALSE 3426
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
3113: LD_ADDR_VAR 0 4
3117: PUSH
3118: DOUBLE
3119: LD_INT 1
3121: DEC
3122: ST_TO_ADDR
3123: LD_VAR 0 1
3127: PPUSH
3128: LD_INT 0
3130: PPUSH
3131: CALL_OW 517
3135: PUSH
3136: LD_INT 1
3138: ARRAY
3139: PUSH
3140: FOR_TO
3141: IFFALSE 3422
// begin if r > 50 then
3143: LD_VAR 0 5
3147: PUSH
3148: LD_INT 50
3150: GREATER
3151: IFFALSE 3398
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
3153: LD_VAR 0 1
3157: PPUSH
3158: LD_INT 0
3160: PPUSH
3161: CALL_OW 517
3165: PUSH
3166: LD_INT 1
3168: ARRAY
3169: PUSH
3170: LD_VAR 0 4
3174: ARRAY
3175: PPUSH
3176: LD_VAR 0 1
3180: PPUSH
3181: LD_INT 0
3183: PPUSH
3184: CALL_OW 517
3188: PUSH
3189: LD_INT 2
3191: ARRAY
3192: PUSH
3193: LD_VAR 0 4
3197: ARRAY
3198: PPUSH
3199: CALL_OW 458
3203: NOT
3204: IFFALSE 3382
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
3206: LD_VAR 0 1
3210: PPUSH
3211: LD_INT 0
3213: PPUSH
3214: CALL_OW 517
3218: PUSH
3219: LD_INT 1
3221: ARRAY
3222: PUSH
3223: LD_VAR 0 4
3227: ARRAY
3228: PPUSH
3229: LD_VAR 0 1
3233: PPUSH
3234: LD_INT 0
3236: PPUSH
3237: CALL_OW 517
3241: PUSH
3242: LD_INT 2
3244: ARRAY
3245: PUSH
3246: LD_VAR 0 4
3250: ARRAY
3251: PPUSH
3252: LD_EXP 8
3256: PPUSH
3257: LD_INT 0
3259: PPUSH
3260: CALL_OW 454
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
3264: LD_ADDR_EXP 17
3268: PUSH
3269: LD_EXP 17
3273: PPUSH
3274: LD_EXP 17
3278: PUSH
3279: LD_INT 1
3281: PLUS
3282: PPUSH
3283: LD_VAR 0 1
3287: PPUSH
3288: LD_INT 0
3290: PPUSH
3291: CALL_OW 517
3295: PUSH
3296: LD_INT 1
3298: ARRAY
3299: PUSH
3300: LD_VAR 0 4
3304: ARRAY
3305: PPUSH
3306: CALL_OW 2
3310: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
3311: LD_ADDR_EXP 17
3315: PUSH
3316: LD_EXP 17
3320: PPUSH
3321: LD_EXP 17
3325: PUSH
3326: LD_INT 1
3328: PLUS
3329: PPUSH
3330: LD_VAR 0 1
3334: PPUSH
3335: LD_INT 0
3337: PPUSH
3338: CALL_OW 517
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PUSH
3347: LD_VAR 0 4
3351: ARRAY
3352: PPUSH
3353: CALL_OW 2
3357: ST_TO_ADDR
// r := 0 ;
3358: LD_ADDR_VAR 0 5
3362: PUSH
3363: LD_INT 0
3365: ST_TO_ADDR
// x := x + 1 ;
3366: LD_ADDR_VAR 0 6
3370: PUSH
3371: LD_VAR 0 6
3375: PUSH
3376: LD_INT 1
3378: PLUS
3379: ST_TO_ADDR
// end else
3380: GO 3396
// r := r + 35 ;
3382: LD_ADDR_VAR 0 5
3386: PUSH
3387: LD_VAR 0 5
3391: PUSH
3392: LD_INT 35
3394: PLUS
3395: ST_TO_ADDR
// end else
3396: GO 3420
// r := r + rand ( 10 , 25 ) ;
3398: LD_ADDR_VAR 0 5
3402: PUSH
3403: LD_VAR 0 5
3407: PUSH
3408: LD_INT 10
3410: PPUSH
3411: LD_INT 25
3413: PPUSH
3414: CALL_OW 12
3418: PLUS
3419: ST_TO_ADDR
// end ;
3420: GO 3140
3422: POP
3423: POP
3424: GO 3101
// end ;
3426: LD_VAR 0 3
3430: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
3431: LD_INT 0
3433: PPUSH
3434: PPUSH
3435: PPUSH
// if not GetControl ( veh ) = control_manual then
3436: LD_VAR 0 1
3440: PPUSH
3441: CALL_OW 263
3445: PUSH
3446: LD_INT 1
3448: EQUAL
3449: NOT
3450: IFFALSE 3462
// result := false else
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_INT 0
3459: ST_TO_ADDR
3460: GO 3607
// if veh in FilterAllUnits ( [ f_empty ] ) then
3462: LD_VAR 0 1
3466: PUSH
3467: LD_INT 58
3469: PUSH
3470: EMPTY
3471: LIST
3472: PPUSH
3473: CALL_OW 69
3477: IN
3478: IFFALSE 3490
// result := false else
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_INT 0
3487: ST_TO_ADDR
3488: GO 3607
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3490: LD_ADDR_VAR 0 4
3494: PUSH
3495: LD_INT 22
3497: PUSH
3498: LD_VAR 0 1
3502: PPUSH
3503: CALL_OW 255
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: PUSH
3512: LD_INT 55
3514: PUSH
3515: EMPTY
3516: LIST
3517: PUSH
3518: EMPTY
3519: LIST
3520: LIST
3521: PPUSH
3522: CALL_OW 69
3526: ST_TO_ADDR
// if not filter then
3527: LD_VAR 0 4
3531: NOT
3532: IFFALSE 3544
// result := false else
3534: LD_ADDR_VAR 0 2
3538: PUSH
3539: LD_INT 0
3541: ST_TO_ADDR
3542: GO 3607
// for i = 1 to filter do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_VAR 0 4
3558: PUSH
3559: FOR_TO
3560: IFFALSE 3605
// if IsDriver ( filter [ i ] ) = veh then
3562: LD_VAR 0 4
3566: PUSH
3567: LD_VAR 0 3
3571: ARRAY
3572: PPUSH
3573: CALL 3612 0 1
3577: PUSH
3578: LD_VAR 0 1
3582: EQUAL
3583: IFFALSE 3603
// begin result := filter [ i ] ;
3585: LD_ADDR_VAR 0 2
3589: PUSH
3590: LD_VAR 0 4
3594: PUSH
3595: LD_VAR 0 3
3599: ARRAY
3600: ST_TO_ADDR
// break ;
3601: GO 3605
// end ;
3603: GO 3559
3605: POP
3606: POP
// end ; end ;
3607: LD_VAR 0 2
3611: RET
// export function IsDriver ( unit ) ; begin
3612: LD_INT 0
3614: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3615: LD_VAR 0 1
3619: PUSH
3620: LD_INT 55
3622: PUSH
3623: EMPTY
3624: LIST
3625: PPUSH
3626: CALL_OW 69
3630: IN
3631: IFFALSE 3650
// result := IsInUnit ( unit ) else
3633: LD_ADDR_VAR 0 2
3637: PUSH
3638: LD_VAR 0 1
3642: PPUSH
3643: CALL_OW 310
3647: ST_TO_ADDR
3648: GO 3658
// result := false ;
3650: LD_ADDR_VAR 0 2
3654: PUSH
3655: LD_INT 0
3657: ST_TO_ADDR
// end ; end_of_file
3658: LD_VAR 0 2
3662: RET
// export function InitBot ; var i , ct , hex , side , un , veh , weapons , skill ; begin
3663: LD_INT 0
3665: PPUSH
3666: PPUSH
3667: PPUSH
3668: PPUSH
3669: PPUSH
3670: PPUSH
3671: PPUSH
3672: PPUSH
3673: PPUSH
// side := Bot_Side ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_EXP 8
3683: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
3684: LD_ADDR_VAR 0 9
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: LD_INT 6
3694: PUSH
3695: LD_INT 8
3697: PUSH
3698: EMPTY
3699: LIST
3700: LIST
3701: LIST
3702: PUSH
3703: LD_OWVAR 67
3707: ARRAY
3708: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
3709: LD_ADDR_VAR 0 8
3713: PUSH
3714: LD_INT 27
3716: PUSH
3717: LD_INT 28
3719: PUSH
3720: LD_INT 25
3722: PUSH
3723: LD_INT 26
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: LIST
3730: LIST
3731: ST_TO_ADDR
// veh_counter := [ 4 , 5 , 6 ] [ Difficulty ] ;
3732: LD_ADDR_EXP 22
3736: PUSH
3737: LD_INT 4
3739: PUSH
3740: LD_INT 5
3742: PUSH
3743: LD_INT 6
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: LIST
3750: PUSH
3751: LD_OWVAR 67
3755: ARRAY
3756: ST_TO_ADDR
// ct := [ ] ;
3757: LD_ADDR_VAR 0 3
3761: PUSH
3762: EMPTY
3763: ST_TO_ADDR
// patrols := [ ] ;
3764: LD_ADDR_EXP 19
3768: PUSH
3769: EMPTY
3770: ST_TO_ADDR
// attackers := [ ] ;
3771: LD_ADDR_EXP 20
3775: PUSH
3776: EMPTY
3777: ST_TO_ADDR
// attackers_tmp := [ ] ;
3778: LD_ADDR_EXP 27
3782: PUSH
3783: EMPTY
3784: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
3785: LD_ADDR_EXP 21
3789: PUSH
3790: LD_INT 14
3792: PUSH
3793: LD_INT 1
3795: PUSH
3796: LD_INT 2
3798: PUSH
3799: LD_INT 27
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: PUSH
3808: LD_INT 14
3810: PUSH
3811: LD_INT 1
3813: PUSH
3814: LD_INT 2
3816: PUSH
3817: LD_INT 25
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 14
3828: PUSH
3829: LD_INT 1
3831: PUSH
3832: LD_INT 2
3834: PUSH
3835: LD_INT 28
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_INT 14
3846: PUSH
3847: LD_INT 1
3849: PUSH
3850: LD_INT 2
3852: PUSH
3853: LD_INT 29
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: PUSH
3862: LD_INT 14
3864: PUSH
3865: LD_INT 1
3867: PUSH
3868: LD_INT 2
3870: PUSH
3871: LD_INT 27
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: ST_TO_ADDR
// SetBName ( ar_dep , newkabul ) ;
3887: LD_INT 2
3889: PPUSH
3890: LD_STRING newkabul
3892: PPUSH
3893: CALL_OW 500
// SetResourceType ( GetBase ( ar_dep ) , mat_cans , 90000 ) ;
3897: LD_INT 2
3899: PPUSH
3900: CALL_OW 274
3904: PPUSH
3905: LD_INT 1
3907: PPUSH
3908: LD_INT 90000
3910: PPUSH
3911: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_oil , 9000 ) ;
3915: LD_INT 2
3917: PPUSH
3918: CALL_OW 274
3922: PPUSH
3923: LD_INT 2
3925: PPUSH
3926: LD_INT 9000
3928: PPUSH
3929: CALL_OW 277
// SetResourceType ( GetBase ( ar_dep ) , mat_siberit , 3000 ) ;
3933: LD_INT 2
3935: PPUSH
3936: CALL_OW 274
3940: PPUSH
3941: LD_INT 3
3943: PPUSH
3944: LD_INT 3000
3946: PPUSH
3947: CALL_OW 277
// if Difficulty > 1 then
3951: LD_OWVAR 67
3955: PUSH
3956: LD_INT 1
3958: GREATER
3959: IFFALSE 3976
// SetTech ( 5 , side , state_researched ) ;
3961: LD_INT 5
3963: PPUSH
3964: LD_VAR 0 5
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 322
// SetTech ( tech_mortar , side , state_researched ) ;
3976: LD_INT 41
3978: PPUSH
3979: LD_VAR 0 5
3983: PPUSH
3984: LD_INT 2
3986: PPUSH
3987: CALL_OW 322
// SetTech ( tech_weap1 , side , state_researched ) ;
3991: LD_INT 51
3993: PPUSH
3994: LD_VAR 0 5
3998: PPUSH
3999: LD_INT 2
4001: PPUSH
4002: CALL_OW 322
// SetTech ( tech_weap2 , side , state_researched ) ;
4006: LD_INT 52
4008: PPUSH
4009: LD_VAR 0 5
4013: PPUSH
4014: LD_INT 2
4016: PPUSH
4017: CALL_OW 322
// SetTech ( tech_weap3 , side , state_researched ) ;
4021: LD_INT 53
4023: PPUSH
4024: LD_VAR 0 5
4028: PPUSH
4029: LD_INT 2
4031: PPUSH
4032: CALL_OW 322
// SetTech ( tech_opto1 , side , state_researched ) ;
4036: LD_INT 60
4038: PPUSH
4039: LD_VAR 0 5
4043: PPUSH
4044: LD_INT 2
4046: PPUSH
4047: CALL_OW 322
// SetTech ( tech_opto2 , side , state_researched ) ;
4051: LD_INT 61
4053: PPUSH
4054: LD_VAR 0 5
4058: PPUSH
4059: LD_INT 2
4061: PPUSH
4062: CALL_OW 322
// SetTech ( tech_opto3 , side , state_researched ) ;
4066: LD_INT 62
4068: PPUSH
4069: LD_VAR 0 5
4073: PPUSH
4074: LD_INT 2
4076: PPUSH
4077: CALL_OW 322
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4081: LD_ADDR_VAR 0 2
4085: PUSH
4086: LD_INT 22
4088: PUSH
4089: LD_VAR 0 5
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: PUSH
4098: LD_INT 21
4100: PUSH
4101: LD_INT 3
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PPUSH
4112: CALL_OW 69
4116: PUSH
4117: FOR_IN
4118: IFFALSE 4151
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4120: LD_VAR 0 2
4124: PPUSH
4125: LD_INT 6
4127: PUSH
4128: LD_INT 8
4130: PUSH
4131: LD_INT 10
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: LIST
4138: PUSH
4139: LD_OWVAR 67
4143: ARRAY
4144: PPUSH
4145: CALL_OW 241
4149: GO 4117
4151: POP
4152: POP
// if Difficulty > 1 then
4153: LD_OWVAR 67
4157: PUSH
4158: LD_INT 1
4160: GREATER
4161: IFFALSE 4170
// RemoveEnvironmentArea ( forest_road ) ;
4163: LD_INT 11
4165: PPUSH
4166: CALL_OW 355
// PlaceMines ( mine_west_zone , [ 10 , 15 , 20 ] [ Difficulty ] ) ;
4170: LD_INT 4
4172: PPUSH
4173: LD_INT 10
4175: PUSH
4176: LD_INT 15
4178: PUSH
4179: LD_INT 20
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 67
4191: ARRAY
4192: PPUSH
4193: CALL 3079 0 2
// PlaceMines ( mine_east_zone , [ 7 , 14 , 18 ] [ Difficulty ] ) ;
4197: LD_INT 5
4199: PPUSH
4200: LD_INT 7
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: LD_INT 18
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: LIST
4213: PUSH
4214: LD_OWVAR 67
4218: ARRAY
4219: PPUSH
4220: CALL 3079 0 2
// PlaceMines ( mine_south_zone , [ 5 , 11 , 17 ] [ Difficulty ] ) ;
4224: LD_INT 7
4226: PPUSH
4227: LD_INT 5
4229: PUSH
4230: LD_INT 11
4232: PUSH
4233: LD_INT 17
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_OWVAR 67
4245: ARRAY
4246: PPUSH
4247: CALL 3079 0 2
// PlaceMines ( mine_high_zone , [ 0 , 3 , 5 ] [ Difficulty ] ) ;
4251: LD_INT 6
4253: PPUSH
4254: LD_INT 0
4256: PUSH
4257: LD_INT 3
4259: PUSH
4260: LD_INT 5
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 67
4272: ARRAY
4273: PPUSH
4274: CALL 3079 0 2
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
4278: LD_INT 8
4280: PPUSH
4281: LD_INT 2
4283: PUSH
4284: LD_INT 5
4286: PUSH
4287: LD_INT 8
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: LIST
4294: PUSH
4295: LD_OWVAR 67
4299: ARRAY
4300: PPUSH
4301: CALL 3079 0 2
// PlaceMines ( mine_southpass_zone , [ 0 , 2 , 4 ] [ Difficulty ] ) ;
4305: LD_INT 9
4307: PPUSH
4308: LD_INT 0
4310: PUSH
4311: LD_INT 2
4313: PUSH
4314: LD_INT 4
4316: PUSH
4317: EMPTY
4318: LIST
4319: LIST
4320: LIST
4321: PUSH
4322: LD_OWVAR 67
4326: ARRAY
4327: PPUSH
4328: CALL 3079 0 2
// PlaceMines ( mine_oileast_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4332: LD_INT 10
4334: PPUSH
4335: LD_INT 0
4337: PUSH
4338: LD_INT 1
4340: PUSH
4341: LD_INT 1
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: LIST
4348: PUSH
4349: LD_OWVAR 67
4353: ARRAY
4354: PPUSH
4355: CALL 3079 0 2
// PlaceMines ( mine_oilwest_zone , [ 0 , 1 , 1 ] [ Difficulty ] ) ;
4359: LD_INT 12
4361: PPUSH
4362: LD_INT 0
4364: PUSH
4365: LD_INT 1
4367: PUSH
4368: LD_INT 1
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: LIST
4375: PUSH
4376: LD_OWVAR 67
4380: ARRAY
4381: PPUSH
4382: CALL 3079 0 2
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
4386: LD_ADDR_VAR 0 2
4390: PUSH
4391: DOUBLE
4392: LD_INT 1
4394: DEC
4395: ST_TO_ADDR
4396: LD_INT 8
4398: PUSH
4399: LD_INT 11
4401: PUSH
4402: LD_INT 14
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_OWVAR 67
4414: ARRAY
4415: PUSH
4416: FOR_TO
4417: IFFALSE 4592
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
4419: LD_ADDR_VAR 0 4
4423: PUSH
4424: LD_INT 134
4426: PPUSH
4427: LD_INT 73
4429: PPUSH
4430: LD_INT 10
4432: PPUSH
4433: LD_INT 0
4435: PPUSH
4436: CALL_OW 17
4440: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
4441: LD_VAR 0 4
4445: PUSH
4446: LD_INT 1
4448: ARRAY
4449: PPUSH
4450: LD_VAR 0 4
4454: PUSH
4455: LD_INT 2
4457: ARRAY
4458: PPUSH
4459: CALL_OW 428
4463: PUSH
4464: LD_INT 0
4466: EQUAL
4467: PUSH
4468: LD_VAR 0 4
4472: PUSH
4473: LD_INT 1
4475: ARRAY
4476: PPUSH
4477: LD_VAR 0 4
4481: PUSH
4482: LD_INT 2
4484: ARRAY
4485: PPUSH
4486: CALL_OW 458
4490: NOT
4491: AND
4492: IFFALSE 4590
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
4494: LD_ADDR_EXP 17
4498: PUSH
4499: LD_EXP 17
4503: PPUSH
4504: LD_EXP 17
4508: PUSH
4509: LD_INT 1
4511: PLUS
4512: PPUSH
4513: LD_VAR 0 4
4517: PUSH
4518: LD_INT 1
4520: ARRAY
4521: PPUSH
4522: CALL_OW 2
4526: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
4527: LD_ADDR_EXP 17
4531: PUSH
4532: LD_EXP 17
4536: PPUSH
4537: LD_EXP 17
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PPUSH
4546: LD_VAR 0 4
4550: PUSH
4551: LD_INT 2
4553: ARRAY
4554: PPUSH
4555: CALL_OW 2
4559: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
4560: LD_VAR 0 4
4564: PUSH
4565: LD_INT 1
4567: ARRAY
4568: PPUSH
4569: LD_VAR 0 4
4573: PUSH
4574: LD_INT 2
4576: ARRAY
4577: PPUSH
4578: LD_EXP 8
4582: PPUSH
4583: LD_INT 0
4585: PPUSH
4586: CALL_OW 454
// end ; end ;
4590: GO 4416
4592: POP
4593: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4594: LD_ADDR_VAR 0 2
4598: PUSH
4599: LD_INT 22
4601: PUSH
4602: LD_VAR 0 5
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 30
4613: PUSH
4614: LD_INT 32
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PPUSH
4625: CALL_OW 69
4629: PUSH
4630: FOR_IN
4631: IFFALSE 4663
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
4633: LD_VAR 0 2
4637: PPUSH
4638: LD_VAR 0 8
4642: PUSH
4643: LD_INT 1
4645: PPUSH
4646: LD_VAR 0 8
4650: PPUSH
4651: CALL_OW 12
4655: ARRAY
4656: PPUSH
4657: CALL_OW 431
4661: GO 4630
4663: POP
4664: POP
// uc_side := side ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_VAR 0 5
4674: ST_TO_ADDR
// uc_nation := 2 ;
4675: LD_ADDR_OWVAR 21
4679: PUSH
4680: LD_INT 2
4682: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
4683: LD_ADDR_VAR 0 2
4687: PUSH
4688: DOUBLE
4689: LD_INT 1
4691: DEC
4692: ST_TO_ADDR
4693: LD_INT 1
4695: PUSH
4696: LD_OWVAR 67
4700: PLUS
4701: PUSH
4702: FOR_TO
4703: IFFALSE 4793
// begin vc_chassis := ar_half_tracked ;
4705: LD_ADDR_OWVAR 37
4709: PUSH
4710: LD_INT 14
4712: ST_TO_ADDR
// vc_engine := engine_combustion ;
4713: LD_ADDR_OWVAR 39
4717: PUSH
4718: LD_INT 1
4720: ST_TO_ADDR
// vc_control := control_manual ;
4721: LD_ADDR_OWVAR 38
4725: PUSH
4726: LD_INT 1
4728: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4729: LD_ADDR_OWVAR 40
4733: PUSH
4734: LD_INT 31
4736: ST_TO_ADDR
// veh := CreateVehicle ;
4737: LD_ADDR_VAR 0 7
4741: PUSH
4742: CALL_OW 45
4746: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
4747: LD_VAR 0 7
4751: PPUSH
4752: LD_INT 3
4754: PPUSH
4755: LD_INT 0
4757: PPUSH
4758: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
4762: LD_INT 0
4764: PPUSH
4765: LD_INT 3
4767: PPUSH
4768: LD_VAR 0 9
4772: PPUSH
4773: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4777: CALL_OW 44
4781: PPUSH
4782: LD_VAR 0 7
4786: PPUSH
4787: CALL_OW 52
// end ;
4791: GO 4702
4793: POP
4794: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
4795: LD_ADDR_VAR 0 2
4799: PUSH
4800: LD_INT 22
4802: PUSH
4803: LD_VAR 0 5
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: LD_INT 30
4814: PUSH
4815: LD_INT 32
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PPUSH
4826: CALL_OW 69
4830: PUSH
4831: FOR_IN
4832: IFFALSE 4865
// begin PrepareHuman ( false , 1 , skill ) ;
4834: LD_INT 0
4836: PPUSH
4837: LD_INT 1
4839: PPUSH
4840: LD_VAR 0 9
4844: PPUSH
4845: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4849: CALL_OW 44
4853: PPUSH
4854: LD_VAR 0 2
4858: PPUSH
4859: CALL_OW 52
// end ;
4863: GO 4831
4865: POP
4866: POP
// for i = 1 to 4 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 4
4879: PUSH
4880: FOR_TO
4881: IFFALSE 4912
// begin PrepareHuman ( false , 2 , skill ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: LD_VAR 0 9
4893: PPUSH
4894: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_dep ) ;
4898: CALL_OW 44
4902: PPUSH
4903: LD_INT 2
4905: PPUSH
4906: CALL_OW 52
// end ;
4910: GO 4880
4912: POP
4913: POP
// for i = 1 to 6 do
4914: LD_ADDR_VAR 0 2
4918: PUSH
4919: DOUBLE
4920: LD_INT 1
4922: DEC
4923: ST_TO_ADDR
4924: LD_INT 6
4926: PUSH
4927: FOR_TO
4928: IFFALSE 4959
// begin PrepareHuman ( false , 3 , skill ) ;
4930: LD_INT 0
4932: PPUSH
4933: LD_INT 3
4935: PPUSH
4936: LD_VAR 0 9
4940: PPUSH
4941: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ar_fac ) ;
4945: CALL_OW 44
4949: PPUSH
4950: LD_INT 12
4952: PPUSH
4953: CALL_OW 52
// end ;
4957: GO 4927
4959: POP
4960: POP
// for i = 1 to 4 do
4961: LD_ADDR_VAR 0 2
4965: PUSH
4966: DOUBLE
4967: LD_INT 1
4969: DEC
4970: ST_TO_ADDR
4971: LD_INT 4
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5032
// begin PrepareHuman ( false , 4 , skill ) ;
4977: LD_INT 0
4979: PPUSH
4980: LD_INT 4
4982: PPUSH
4983: LD_VAR 0 9
4987: PPUSH
4988: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
4992: CALL_OW 44
4996: PPUSH
4997: LD_INT 30
4999: PUSH
5000: LD_INT 8
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 69
5011: PUSH
5012: LD_VAR 0 2
5016: PUSH
5017: LD_INT 2
5019: MOD
5020: PUSH
5021: LD_INT 1
5023: PLUS
5024: ARRAY
5025: PPUSH
5026: CALL_OW 52
// end ;
5030: GO 4974
5032: POP
5033: POP
// PrepareHuman ( false , class_mortar , skill ) ;
5034: LD_INT 0
5036: PPUSH
5037: LD_INT 8
5039: PPUSH
5040: LD_VAR 0 9
5044: PPUSH
5045: CALL_OW 380
// un := CreateHuman ;
5049: LD_ADDR_VAR 0 6
5053: PUSH
5054: CALL_OW 44
5058: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5059: LD_VAR 0 6
5063: PPUSH
5064: LD_INT 2
5066: PPUSH
5067: CALL_OW 233
// PlaceHumanInUnit ( un , bun1 ) ;
5071: LD_VAR 0 6
5075: PPUSH
5076: LD_INT 31
5078: PPUSH
5079: CALL_OW 52
// for i = 1 to 4 do
5083: LD_ADDR_VAR 0 2
5087: PUSH
5088: DOUBLE
5089: LD_INT 1
5091: DEC
5092: ST_TO_ADDR
5093: LD_INT 4
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5153
// begin uc_nation := 0 ;
5099: LD_ADDR_OWVAR 21
5103: PUSH
5104: LD_INT 0
5106: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
5107: LD_INT 0
5109: PPUSH
5110: LD_INT 16
5112: PPUSH
5113: LD_INT 1
5115: PPUSH
5116: CALL_OW 380
// un := CreateHuman ;
5120: LD_ADDR_VAR 0 6
5124: PUSH
5125: CALL_OW 44
5129: ST_TO_ADDR
// PlaceUnitXYR ( un , 106 , 46 , 8 , false ) ;
5130: LD_VAR 0 6
5134: PPUSH
5135: LD_INT 106
5137: PPUSH
5138: LD_INT 46
5140: PPUSH
5141: LD_INT 8
5143: PPUSH
5144: LD_INT 0
5146: PPUSH
5147: CALL_OW 50
// end ;
5151: GO 5096
5153: POP
5154: POP
// for i = 1 to 2 * Difficulty do
5155: LD_ADDR_VAR 0 2
5159: PUSH
5160: DOUBLE
5161: LD_INT 1
5163: DEC
5164: ST_TO_ADDR
5165: LD_INT 2
5167: PUSH
5168: LD_OWVAR 67
5172: MUL
5173: PUSH
5174: FOR_TO
5175: IFFALSE 5215
// begin uc_nation := 0 ;
5177: LD_ADDR_OWVAR 21
5181: PUSH
5182: LD_INT 0
5184: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_soldier , 3 ) ;
5185: LD_INT 0
5187: PPUSH
5188: LD_INT 15
5190: PPUSH
5191: LD_INT 3
5193: PPUSH
5194: CALL_OW 380
// PlaceUnitArea ( CreateHuman , ap1 , false ) ;
5198: CALL_OW 44
5202: PPUSH
5203: LD_INT 20
5205: PPUSH
5206: LD_INT 0
5208: PPUSH
5209: CALL_OW 49
// end ;
5213: GO 5174
5215: POP
5216: POP
// for i = 1 to 4 * Difficulty do
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: DOUBLE
5223: LD_INT 1
5225: DEC
5226: ST_TO_ADDR
5227: LD_INT 4
5229: PUSH
5230: LD_OWVAR 67
5234: MUL
5235: PUSH
5236: FOR_TO
5237: IFFALSE 5311
// begin uc_nation := 0 ;
5239: LD_ADDR_OWVAR 21
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
5247: LD_INT 0
5249: PPUSH
5250: LD_INT 17
5252: PPUSH
5253: LD_INT 3
5255: PPUSH
5256: CALL_OW 380
// hc_attr := [ 11 , 13 ] ;
5260: LD_ADDR_OWVAR 29
5264: PUSH
5265: LD_INT 11
5267: PUSH
5268: LD_INT 13
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: ST_TO_ADDR
// un := CreateHuman ;
5275: LD_ADDR_VAR 0 6
5279: PUSH
5280: CALL_OW 44
5284: ST_TO_ADDR
// PlaceUnitArea ( un , ap2 , false ) ;
5285: LD_VAR 0 6
5289: PPUSH
5290: LD_INT 21
5292: PPUSH
5293: LD_INT 0
5295: PPUSH
5296: CALL_OW 49
// ComHold ( un ) ;
5300: LD_VAR 0 6
5304: PPUSH
5305: CALL_OW 140
// end ;
5309: GO 5236
5311: POP
5312: POP
// end ;
5313: LD_VAR 0 1
5317: RET
// every 12 12$00 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) do var i , tmp , p ;
5318: LD_INT 22
5320: PUSH
5321: LD_EXP 8
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 30
5332: PUSH
5333: LD_INT 3
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: IFFALSE 5616
5350: GO 5352
5352: DISABLE
5353: LD_INT 0
5355: PPUSH
5356: PPUSH
5357: PPUSH
// begin enable ;
5358: ENABLE
// tmp := queue_codes [ rng ] ;
5359: LD_ADDR_VAR 0 2
5363: PUSH
5364: LD_EXP 23
5368: PUSH
5369: LD_EXP 24
5373: ARRAY
5374: ST_TO_ADDR
// p := 1 ;
5375: LD_ADDR_VAR 0 3
5379: PUSH
5380: LD_INT 1
5382: ST_TO_ADDR
// for i = 1 to veh_counter do
5383: LD_ADDR_VAR 0 1
5387: PUSH
5388: DOUBLE
5389: LD_INT 1
5391: DEC
5392: ST_TO_ADDR
5393: LD_EXP 22
5397: PUSH
5398: FOR_TO
5399: IFFALSE 5580
// begin AddComConstruct ( FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_factory ] ] ) [ 1 ] , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
5401: LD_INT 22
5403: PUSH
5404: LD_EXP 8
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: PUSH
5413: LD_INT 30
5415: PUSH
5416: LD_INT 3
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL_OW 69
5431: PUSH
5432: LD_INT 1
5434: ARRAY
5435: PPUSH
5436: LD_EXP 21
5440: PUSH
5441: LD_VAR 0 2
5445: PUSH
5446: LD_INT 10
5448: MOD
5449: ARRAY
5450: PUSH
5451: LD_INT 1
5453: ARRAY
5454: PPUSH
5455: LD_EXP 21
5459: PUSH
5460: LD_VAR 0 2
5464: PUSH
5465: LD_INT 10
5467: MOD
5468: ARRAY
5469: PUSH
5470: LD_INT 2
5472: ARRAY
5473: PPUSH
5474: LD_EXP 21
5478: PUSH
5479: LD_VAR 0 2
5483: PUSH
5484: LD_INT 10
5486: MOD
5487: ARRAY
5488: PUSH
5489: LD_INT 3
5491: ARRAY
5492: PPUSH
5493: LD_EXP 21
5497: PUSH
5498: LD_VAR 0 2
5502: PUSH
5503: LD_INT 10
5505: MOD
5506: ARRAY
5507: PUSH
5508: LD_INT 4
5510: ARRAY
5511: PPUSH
5512: CALL_OW 185
// tmp := tmp / 10 ;
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: LD_VAR 0 2
5525: PUSH
5526: LD_INT 10
5528: DIVREAL
5529: ST_TO_ADDR
// p := p + 1 ;
5530: LD_ADDR_VAR 0 3
5534: PUSH
5535: LD_VAR 0 3
5539: PUSH
5540: LD_INT 1
5542: PLUS
5543: ST_TO_ADDR
// if p > 5 then
5544: LD_VAR 0 3
5548: PUSH
5549: LD_INT 5
5551: GREATER
5552: IFFALSE 5578
// begin p := 1 ;
5554: LD_ADDR_VAR 0 3
5558: PUSH
5559: LD_INT 1
5561: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
5562: LD_ADDR_VAR 0 2
5566: PUSH
5567: LD_EXP 23
5571: PUSH
5572: LD_EXP 24
5576: ARRAY
5577: ST_TO_ADDR
// end ; end ;
5578: GO 5398
5580: POP
5581: POP
// rng := rng + 1 ;
5582: LD_ADDR_EXP 24
5586: PUSH
5587: LD_EXP 24
5591: PUSH
5592: LD_INT 1
5594: PLUS
5595: ST_TO_ADDR
// if rng > queue_codes then
5596: LD_EXP 24
5600: PUSH
5601: LD_EXP 23
5605: GREATER
5606: IFFALSE 5616
// rng := 1 ;
5608: LD_ADDR_EXP 24
5612: PUSH
5613: LD_INT 1
5615: ST_TO_ADDR
// end ;
5616: PPOPN 3
5618: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
5619: LD_INT 25
5621: PUSH
5622: LD_INT 17
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: PPUSH
5629: CALL_OW 69
5633: IFFALSE 5736
5635: GO 5637
5637: DISABLE
5638: LD_INT 0
5640: PPUSH
5641: PPUSH
// begin enable ;
5642: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
5643: LD_ADDR_VAR 0 1
5647: PUSH
5648: LD_INT 25
5650: PUSH
5651: LD_INT 17
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PPUSH
5658: CALL_OW 69
5662: PUSH
5663: FOR_IN
5664: IFFALSE 5734
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
5666: LD_ADDR_VAR 0 2
5670: PUSH
5671: LD_INT 81
5673: PUSH
5674: LD_EXP 8
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: PPUSH
5683: CALL_OW 69
5687: PPUSH
5688: LD_VAR 0 1
5692: PPUSH
5693: CALL_OW 74
5697: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
5698: LD_VAR 0 1
5702: PPUSH
5703: LD_VAR 0 2
5707: PPUSH
5708: CALL_OW 296
5712: PUSH
5713: LD_INT 15
5715: LESS
5716: IFFALSE 5732
// ComAttackUnit ( i , un ) ;
5718: LD_VAR 0 1
5722: PPUSH
5723: LD_VAR 0 2
5727: PPUSH
5728: CALL_OW 115
// end ;
5732: GO 5663
5734: POP
5735: POP
// end ;
5736: PPOPN 2
5738: END
// every 0 0$01 trigger attackers marked 17 do var i ;
5739: LD_EXP 20
5743: IFFALSE 5837
5745: GO 5747
5747: DISABLE
5748: LD_INT 0
5750: PPUSH
// begin enable ;
5751: ENABLE
// if target = 0 then
5752: LD_EXP 25
5756: PUSH
5757: LD_INT 0
5759: EQUAL
5760: IFFALSE 5784
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
5762: LD_ADDR_EXP 25
5766: PUSH
5767: LD_INT 81
5769: PUSH
5770: LD_EXP 8
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PPUSH
5779: CALL_OW 69
5783: ST_TO_ADDR
// for i in attackers do
5784: LD_ADDR_VAR 0 1
5788: PUSH
5789: LD_EXP 20
5793: PUSH
5794: FOR_IN
5795: IFFALSE 5835
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
5797: LD_VAR 0 1
5801: PPUSH
5802: LD_INT 22
5804: PUSH
5805: LD_EXP 25
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: PPUSH
5814: CALL_OW 69
5818: PPUSH
5819: LD_VAR 0 1
5823: PPUSH
5824: CALL_OW 74
5828: PPUSH
5829: CALL_OW 115
5833: GO 5794
5835: POP
5836: POP
// end ;
5837: PPOPN 1
5839: END
// every 0 0$01 trigger not attackers marked 17 do
5840: LD_EXP 20
5844: NOT
5845: IFFALSE 5854
5847: GO 5849
5849: DISABLE
// begin enable ;
5850: ENABLE
// disable ( 17 ) ;
5851: LD_INT 17
5853: DISABLE_MARKED
// end ;
5854: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i ;
5855: LD_EXP 22
5859: PUSH
5860: LD_EXP 20
5864: LESSEQUAL
5865: IFFALSE 5974
5867: GO 5869
5869: DISABLE
5870: LD_INT 0
5872: PPUSH
5873: PPUSH
// begin enable ;
5874: ENABLE
// enable ( 17 ) ;
5875: LD_INT 17
5877: ENABLE_MARKED
// max := 1 ;
5878: LD_ADDR_VAR 0 1
5882: PUSH
5883: LD_INT 1
5885: ST_TO_ADDR
// for i = 1 to 8 do
5886: LD_ADDR_VAR 0 2
5890: PUSH
5891: DOUBLE
5892: LD_INT 1
5894: DEC
5895: ST_TO_ADDR
5896: LD_INT 8
5898: PUSH
5899: FOR_TO
5900: IFFALSE 5972
// if i <> bot_side then
5902: LD_VAR 0 2
5906: PUSH
5907: LD_EXP 8
5911: NONEQUAL
5912: IFFALSE 5970
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
5914: LD_VAR 0 1
5918: PUSH
5919: LD_INT 22
5921: PUSH
5922: LD_VAR 0 2
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: PPUSH
5931: CALL_OW 69
5935: LESS
5936: IFFALSE 5970
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
5938: LD_ADDR_VAR 0 1
5942: PUSH
5943: LD_INT 22
5945: PUSH
5946: LD_VAR 0 2
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PPUSH
5955: CALL_OW 69
5959: ST_TO_ADDR
// target := i ;
5960: LD_ADDR_EXP 25
5964: PUSH
5965: LD_VAR 0 2
5969: ST_TO_ADDR
// end ; end ;
5970: GO 5899
5972: POP
5973: POP
// end ;
5974: PPOPN 2
5976: END
// every 0 0$01 trigger game_start and tick >= 30 30$00 do
5977: LD_EXP 9
5981: PUSH
5982: LD_OWVAR 1
5986: PUSH
5987: LD_INT 63000
5989: GREATEREQUAL
5990: AND
5991: IFFALSE 6010
5993: GO 5995
5995: DISABLE
// begin veh_counter := veh_counter + 1 ;
5996: LD_ADDR_EXP 22
6000: PUSH
6001: LD_EXP 22
6005: PUSH
6006: LD_INT 1
6008: PLUS
6009: ST_TO_ADDR
// end ;
6010: END
// every 0 0$01 trigger game_start and tick >= 50 50$00 do
6011: LD_EXP 9
6015: PUSH
6016: LD_OWVAR 1
6020: PUSH
6021: LD_INT 105000
6023: GREATEREQUAL
6024: AND
6025: IFFALSE 6044
6027: GO 6029
6029: DISABLE
// begin veh_counter := veh_counter + 2 ;
6030: LD_ADDR_EXP 22
6034: PUSH
6035: LD_EXP 22
6039: PUSH
6040: LD_INT 2
6042: PLUS
6043: ST_TO_ADDR
// end ;
6044: END
// every 0 0$01 trigger game_start and tick >= 80 80$00 do
6045: LD_EXP 9
6049: PUSH
6050: LD_OWVAR 1
6054: PUSH
6055: LD_INT 168000
6057: GREATEREQUAL
6058: AND
6059: IFFALSE 6078
6061: GO 6063
6063: DISABLE
// begin veh_counter := veh_counter + 3 ;
6064: LD_ADDR_EXP 22
6068: PUSH
6069: LD_EXP 22
6073: PUSH
6074: LD_INT 3
6076: PLUS
6077: ST_TO_ADDR
// end ;
6078: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
6079: LD_INT 22
6081: PUSH
6082: LD_EXP 8
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PUSH
6091: LD_INT 33
6093: PUSH
6094: LD_INT 2
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 69
6109: IFFALSE 6325
6111: GO 6113
6113: DISABLE
6114: LD_INT 0
6116: PPUSH
6117: PPUSH
6118: PPUSH
6119: PPUSH
6120: PPUSH
6121: PPUSH
6122: PPUSH
// begin enable ;
6123: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
6124: LD_ADDR_VAR 0 4
6128: PUSH
6129: LD_INT 22
6131: PUSH
6132: LD_EXP 8
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 33
6143: PUSH
6144: LD_INT 2
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: LD_INT 3
6153: PUSH
6154: LD_INT 61
6156: PUSH
6157: EMPTY
6158: LIST
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PPUSH
6169: CALL_OW 69
6173: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
6174: LD_ADDR_VAR 0 3
6178: PUSH
6179: LD_INT 22
6181: PUSH
6182: LD_EXP 8
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 34
6193: PUSH
6194: LD_INT 31
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: PPUSH
6205: CALL_OW 69
6209: ST_TO_ADDR
// best := 10 ;
6210: LD_ADDR_VAR 0 5
6214: PUSH
6215: LD_INT 10
6217: ST_TO_ADDR
// best_mechanic := - 1 ;
6218: LD_ADDR_VAR 0 6
6222: PUSH
6223: LD_INT 1
6225: NEG
6226: ST_TO_ADDR
// if vehs then
6227: LD_VAR 0 4
6231: IFFALSE 6325
// begin for j in cts do
6233: LD_ADDR_VAR 0 2
6237: PUSH
6238: LD_VAR 0 3
6242: PUSH
6243: FOR_IN
6244: IFFALSE 6305
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
6246: LD_ADDR_VAR 0 7
6250: PUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: CALL 3431 0 1
6260: PPUSH
6261: CALL_OW 432
6265: ST_TO_ADDR
// if p < best then
6266: LD_VAR 0 7
6270: PUSH
6271: LD_VAR 0 5
6275: LESS
6276: IFFALSE 6303
// begin best := p ;
6278: LD_ADDR_VAR 0 5
6282: PUSH
6283: LD_VAR 0 7
6287: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
6288: LD_ADDR_VAR 0 6
6292: PUSH
6293: LD_VAR 0 2
6297: PPUSH
6298: CALL 3431 0 1
6302: ST_TO_ADDR
// end ; end ;
6303: GO 6243
6305: POP
6306: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
6307: LD_VAR 0 4
6311: PUSH
6312: LD_INT 1
6314: ARRAY
6315: PPUSH
6316: LD_VAR 0 6
6320: PPUSH
6321: CALL_OW 135
// end ; end ;
6325: PPOPN 7
6327: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
6328: GO 6330
6330: DISABLE
6331: LD_INT 0
6333: PPUSH
6334: PPUSH
6335: PPUSH
6336: PPUSH
6337: PPUSH
6338: PPUSH
6339: PPUSH
// begin enable ;
6340: ENABLE
// b := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6341: LD_ADDR_VAR 0 6
6345: PUSH
6346: LD_INT 22
6348: PUSH
6349: LD_EXP 8
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 21
6360: PUSH
6361: LD_INT 3
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 3
6370: PUSH
6371: LD_INT 24
6373: PUSH
6374: LD_INT 1000
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: PPUSH
6390: CALL_OW 69
6394: ST_TO_ADDR
// h := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6395: LD_ADDR_VAR 0 3
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: LD_EXP 8
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: PUSH
6412: LD_INT 2
6414: PUSH
6415: LD_INT 25
6417: PUSH
6418: LD_INT 1
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 25
6427: PUSH
6428: LD_INT 2
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 25
6437: PUSH
6438: LD_INT 3
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: LIST
6449: LIST
6450: PUSH
6451: LD_INT 3
6453: PUSH
6454: LD_INT 24
6456: PUSH
6457: LD_INT 750
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PPUSH
6473: CALL_OW 69
6477: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ;
6478: LD_ADDR_VAR 0 4
6482: PUSH
6483: LD_INT 22
6485: PUSH
6486: LD_EXP 8
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 25
6497: PUSH
6498: LD_INT 4
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PPUSH
6509: CALL_OW 69
6513: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
6514: LD_ADDR_VAR 0 5
6518: PUSH
6519: LD_INT 22
6521: PUSH
6522: LD_EXP 8
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: PUSH
6531: LD_INT 25
6533: PUSH
6534: LD_INT 2
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 69
6549: ST_TO_ADDR
// if not h and not b then
6550: LD_VAR 0 3
6554: NOT
6555: PUSH
6556: LD_VAR 0 6
6560: NOT
6561: AND
6562: IFFALSE 6846
// begin if sci then
6564: LD_VAR 0 4
6568: IFFALSE 6705
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
6570: LD_VAR 0 4
6574: PPUSH
6575: LD_INT 3
6577: PUSH
6578: LD_INT 54
6580: PUSH
6581: EMPTY
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PPUSH
6588: CALL_OW 72
6592: PUSH
6593: LD_INT 22
6595: PUSH
6596: LD_EXP 8
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PUSH
6605: LD_INT 30
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PPUSH
6619: CALL_OW 69
6623: AND
6624: IFFALSE 6705
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
6626: LD_ADDR_VAR 0 2
6630: PUSH
6631: LD_VAR 0 4
6635: PPUSH
6636: LD_INT 3
6638: PUSH
6639: LD_INT 54
6641: PUSH
6642: EMPTY
6643: LIST
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: PPUSH
6649: CALL_OW 72
6653: PUSH
6654: FOR_IN
6655: IFFALSE 6703
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6657: LD_VAR 0 2
6661: PPUSH
6662: LD_INT 22
6664: PUSH
6665: LD_EXP 8
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 30
6676: PUSH
6677: LD_INT 8
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PPUSH
6688: CALL_OW 69
6692: PUSH
6693: LD_INT 1
6695: ARRAY
6696: PPUSH
6697: CALL_OW 120
6701: GO 6654
6703: POP
6704: POP
// if eng then
6705: LD_VAR 0 5
6709: IFFALSE 6846
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
6711: LD_VAR 0 5
6715: PPUSH
6716: LD_INT 3
6718: PUSH
6719: LD_INT 54
6721: PUSH
6722: EMPTY
6723: LIST
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: PPUSH
6729: CALL_OW 72
6733: PUSH
6734: LD_INT 22
6736: PUSH
6737: LD_EXP 8
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: PUSH
6746: LD_INT 30
6748: PUSH
6749: LD_INT 1
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: PPUSH
6760: CALL_OW 69
6764: AND
6765: IFFALSE 6846
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
6767: LD_ADDR_VAR 0 2
6771: PUSH
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 3
6779: PUSH
6780: LD_INT 54
6782: PUSH
6783: EMPTY
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 72
6794: PUSH
6795: FOR_IN
6796: IFFALSE 6844
// ComEnterUnit ( j , FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 22
6805: PUSH
6806: LD_EXP 8
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PUSH
6815: LD_INT 30
6817: PUSH
6818: LD_INT 1
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PPUSH
6829: CALL_OW 69
6833: PUSH
6834: LD_INT 1
6836: ARRAY
6837: PPUSH
6838: CALL_OW 120
6842: GO 6795
6844: POP
6845: POP
// end ; p := 1 ;
6846: LD_ADDR_VAR 0 7
6850: PUSH
6851: LD_INT 1
6853: ST_TO_ADDR
// if b and eng then
6854: LD_VAR 0 6
6858: PUSH
6859: LD_VAR 0 5
6863: AND
6864: IFFALSE 6998
// for j in eng do
6866: LD_ADDR_VAR 0 2
6870: PUSH
6871: LD_VAR 0 5
6875: PUSH
6876: FOR_IN
6877: IFFALSE 6996
// begin if IsInUnit ( j ) then
6879: LD_VAR 0 2
6883: PPUSH
6884: CALL_OW 310
6888: IFFALSE 6901
// ComExitBuilding ( j ) else
6890: LD_VAR 0 2
6894: PPUSH
6895: CALL_OW 122
6899: GO 6994
// if not HasTask ( j ) and GetLives ( j ) > 750 then
6901: LD_VAR 0 2
6905: PPUSH
6906: CALL_OW 314
6910: NOT
6911: PUSH
6912: LD_VAR 0 2
6916: PPUSH
6917: CALL_OW 256
6921: PUSH
6922: LD_INT 750
6924: GREATER
6925: AND
6926: IFFALSE 6994
// begin if b > p then
6928: LD_VAR 0 6
6932: PUSH
6933: LD_VAR 0 7
6937: GREATER
6938: IFFALSE 6976
// begin ComRepairBuilding ( j , b [ p ] ) ;
6940: LD_VAR 0 2
6944: PPUSH
6945: LD_VAR 0 6
6949: PUSH
6950: LD_VAR 0 7
6954: ARRAY
6955: PPUSH
6956: CALL_OW 130
// p := p + 1 ;
6960: LD_ADDR_VAR 0 7
6964: PUSH
6965: LD_VAR 0 7
6969: PUSH
6970: LD_INT 1
6972: PLUS
6973: ST_TO_ADDR
// end else
6974: GO 6994
// ComRepairBuilding ( j , b [ 1 ] ) ;
6976: LD_VAR 0 2
6980: PPUSH
6981: LD_VAR 0 6
6985: PUSH
6986: LD_INT 1
6988: ARRAY
6989: PPUSH
6990: CALL_OW 130
// end ; end ;
6994: GO 6876
6996: POP
6997: POP
// if h and sci then
6998: LD_VAR 0 3
7002: PUSH
7003: LD_VAR 0 4
7007: AND
7008: IFFALSE 7147
// for i in h do
7010: LD_ADDR_VAR 0 1
7014: PUSH
7015: LD_VAR 0 3
7019: PUSH
7020: FOR_IN
7021: IFFALSE 7145
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
7023: LD_VAR 0 1
7027: PPUSH
7028: LD_INT 108
7030: PPUSH
7031: LD_INT 42
7033: PPUSH
7034: CALL_OW 297
7038: PUSH
7039: LD_INT 10
7041: GREATER
7042: IFFALSE 7061
// ComMoveXY ( i , 108 , 42 ) else
7044: LD_VAR 0 1
7048: PPUSH
7049: LD_INT 108
7051: PPUSH
7052: LD_INT 42
7054: PPUSH
7055: CALL_OW 111
7059: GO 7143
// begin for j in sci do
7061: LD_ADDR_VAR 0 2
7065: PUSH
7066: LD_VAR 0 4
7070: PUSH
7071: FOR_IN
7072: IFFALSE 7141
// begin if GetTag ( j ) > 0 then
7074: LD_VAR 0 2
7078: PPUSH
7079: CALL_OW 110
7083: PUSH
7084: LD_INT 0
7086: GREATER
7087: IFFALSE 7091
// continue ;
7089: GO 7071
// if IsInUnit ( j ) then
7091: LD_VAR 0 2
7095: PPUSH
7096: CALL_OW 310
7100: IFFALSE 7113
// ComExitBuilding ( j ) else
7102: LD_VAR 0 2
7106: PPUSH
7107: CALL_OW 122
7111: GO 7139
// if not HasTask ( j ) then
7113: LD_VAR 0 2
7117: PPUSH
7118: CALL_OW 314
7122: NOT
7123: IFFALSE 7139
// ComHeal ( j , h ) ;
7125: LD_VAR 0 2
7129: PPUSH
7130: LD_VAR 0 3
7134: PPUSH
7135: CALL_OW 128
// end ;
7139: GO 7071
7141: POP
7142: POP
// end ;
7143: GO 7020
7145: POP
7146: POP
// end ;
7147: PPOPN 7
7149: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 155 , 88 ) and GetBType ( HexInfo ( 155 , 88 ) = b_siberite_mine ) do var sci , p ;
7150: LD_INT 155
7152: PPUSH
7153: LD_INT 88
7155: PPUSH
7156: CALL_OW 428
7160: PUSH
7161: LD_INT 155
7163: PPUSH
7164: LD_INT 88
7166: PPUSH
7167: CALL_OW 428
7171: PUSH
7172: LD_INT 30
7174: EQUAL
7175: PPUSH
7176: CALL_OW 266
7180: AND
7181: IFFALSE 7430
7183: GO 7185
7185: DISABLE
7186: LD_INT 0
7188: PPUSH
7189: PPUSH
// begin p := GetSide ( HexInfo ( 155 , 88 ) ) ;
7190: LD_ADDR_VAR 0 2
7194: PUSH
7195: LD_INT 155
7197: PPUSH
7198: LD_INT 88
7200: PPUSH
7201: CALL_OW 428
7205: PPUSH
7206: CALL_OW 255
7210: ST_TO_ADDR
// Wait ( [ 5 5$30 , 6 6$33 , 6 6$21 , 8 8$44 , 9 9$31 , 4 4$33 , 9 9$01 , 5 5$01 ] [ p ] ) ;
7211: LD_INT 11550
7213: PUSH
7214: LD_INT 13755
7216: PUSH
7217: LD_INT 13335
7219: PUSH
7220: LD_INT 18340
7222: PUSH
7223: LD_INT 19985
7225: PUSH
7226: LD_INT 9555
7228: PUSH
7229: LD_INT 18935
7231: PUSH
7232: LD_INT 10535
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: LIST
7244: PUSH
7245: LD_VAR 0 2
7249: ARRAY
7250: PPUSH
7251: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7255: LD_INT 22
7257: PUSH
7258: LD_EXP 8
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: PUSH
7267: LD_INT 25
7269: PUSH
7270: LD_INT 4
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL_OW 69
7285: PUSH
7286: LD_INT 0
7288: EQUAL
7289: IFFALSE 7293
// exit ;
7291: GO 7430
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ 1 ] ;
7293: LD_ADDR_VAR 0 1
7297: PUSH
7298: LD_INT 22
7300: PUSH
7301: LD_EXP 8
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: LD_INT 25
7312: PUSH
7313: LD_INT 4
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: PPUSH
7324: CALL_OW 69
7328: PUSH
7329: LD_INT 1
7331: ARRAY
7332: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7333: LD_VAR 0 1
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: CALL_OW 109
// ComExitBuilding ( sci ) ;
7345: LD_VAR 0 1
7349: PPUSH
7350: CALL_OW 122
// AddComMoveXY ( sci , 126 , 59 ) ;
7354: LD_VAR 0 1
7358: PPUSH
7359: LD_INT 126
7361: PPUSH
7362: LD_INT 59
7364: PPUSH
7365: CALL_OW 171
// if p mod 2 = 0 then
7369: LD_VAR 0 2
7373: PUSH
7374: LD_INT 2
7376: MOD
7377: PUSH
7378: LD_INT 0
7380: EQUAL
7381: IFFALSE 7400
// AddComMoveXY ( sci , 148 , 66 ) else
7383: LD_VAR 0 1
7387: PPUSH
7388: LD_INT 148
7390: PPUSH
7391: LD_INT 66
7393: PPUSH
7394: CALL_OW 171
7398: GO 7415
// AddComMoveXY ( sci , 135 , 84 ) ;
7400: LD_VAR 0 1
7404: PPUSH
7405: LD_INT 135
7407: PPUSH
7408: LD_INT 84
7410: PPUSH
7411: CALL_OW 171
// AddComContaminate ( sci , 155 , 88 ) ;
7415: LD_VAR 0 1
7419: PPUSH
7420: LD_INT 155
7422: PPUSH
7423: LD_INT 88
7425: PPUSH
7426: CALL_OW 218
// end ;
7430: PPOPN 2
7432: END
// every 0 0$01 + 0 0$10 trigger HexInfo ( 33 , 10 ) and GetBType ( HexInfo ( 33 , 10 ) = b_siberite_mine ) do var sci , p ;
7433: LD_INT 33
7435: PPUSH
7436: LD_INT 10
7438: PPUSH
7439: CALL_OW 428
7443: PUSH
7444: LD_INT 33
7446: PPUSH
7447: LD_INT 10
7449: PPUSH
7450: CALL_OW 428
7454: PUSH
7455: LD_INT 30
7457: EQUAL
7458: PPUSH
7459: CALL_OW 266
7463: AND
7464: IFFALSE 7715
7466: GO 7468
7468: DISABLE
7469: LD_INT 0
7471: PPUSH
7472: PPUSH
// begin p := GetSide ( HexInfo ( 33 , 10 ) ) ;
7473: LD_ADDR_VAR 0 2
7477: PUSH
7478: LD_INT 33
7480: PPUSH
7481: LD_INT 10
7483: PPUSH
7484: CALL_OW 428
7488: PPUSH
7489: CALL_OW 255
7493: ST_TO_ADDR
// Wait ( [ 4 4$30 , 5 5$33 , 3 3$21 , 4 4$44 , 3 3$31 , 5 5$33 , 3 3$01 , 8 8$01 ] [ p ] ) ;
7494: LD_INT 9450
7496: PUSH
7497: LD_INT 11655
7499: PUSH
7500: LD_INT 7035
7502: PUSH
7503: LD_INT 9940
7505: PUSH
7506: LD_INT 7385
7508: PUSH
7509: LD_INT 11655
7511: PUSH
7512: LD_INT 6335
7514: PUSH
7515: LD_INT 16835
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: LIST
7525: LIST
7526: LIST
7527: PUSH
7528: LD_VAR 0 2
7532: ARRAY
7533: PPUSH
7534: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) = 0 then
7538: LD_INT 22
7540: PUSH
7541: LD_EXP 8
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: PUSH
7550: LD_INT 25
7552: PUSH
7553: LD_INT 4
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 69
7568: PUSH
7569: LD_INT 0
7571: EQUAL
7572: IFFALSE 7576
// exit ;
7574: GO 7715
// sci := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) [ sci ] ;
7576: LD_ADDR_VAR 0 1
7580: PUSH
7581: LD_INT 22
7583: PUSH
7584: LD_EXP 8
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: PUSH
7593: LD_INT 25
7595: PUSH
7596: LD_INT 4
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL_OW 69
7611: PUSH
7612: LD_VAR 0 1
7616: ARRAY
7617: ST_TO_ADDR
// SetTag ( sci , 1 ) ;
7618: LD_VAR 0 1
7622: PPUSH
7623: LD_INT 1
7625: PPUSH
7626: CALL_OW 109
// ComExitBuilding ( sci ) ;
7630: LD_VAR 0 1
7634: PPUSH
7635: CALL_OW 122
// AddComMoveXY ( sci , 67 , 13 ) ;
7639: LD_VAR 0 1
7643: PPUSH
7644: LD_INT 67
7646: PPUSH
7647: LD_INT 13
7649: PPUSH
7650: CALL_OW 171
// if p mod 2 = 0 then
7654: LD_VAR 0 2
7658: PUSH
7659: LD_INT 2
7661: MOD
7662: PUSH
7663: LD_INT 0
7665: EQUAL
7666: IFFALSE 7685
// AddComMoveXY ( sci , 37 , 3 ) else
7668: LD_VAR 0 1
7672: PPUSH
7673: LD_INT 37
7675: PPUSH
7676: LD_INT 3
7678: PPUSH
7679: CALL_OW 171
7683: GO 7700
// AddComMoveXY ( sci , 45 , 20 ) ;
7685: LD_VAR 0 1
7689: PPUSH
7690: LD_INT 45
7692: PPUSH
7693: LD_INT 20
7695: PPUSH
7696: CALL_OW 171
// AddComContaminate ( sci , 33 , 10 ) ;
7700: LD_VAR 0 1
7704: PPUSH
7705: LD_INT 33
7707: PPUSH
7708: LD_INT 10
7710: PPUSH
7711: CALL_OW 218
// end ;
7715: PPOPN 2
7717: END
// every 0 0$01 trigger mines_list do var i , p ;
7718: LD_EXP 17
7722: IFFALSE 7948
7724: GO 7726
7726: DISABLE
7727: LD_INT 0
7729: PPUSH
7730: PPUSH
// begin enable ;
7731: ENABLE
// p := 1 ;
7732: LD_ADDR_VAR 0 2
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
7740: LD_ADDR_VAR 0 1
7744: PUSH
7745: DOUBLE
7746: LD_INT 1
7748: DEC
7749: ST_TO_ADDR
7750: LD_EXP 17
7754: PUSH
7755: LD_INT 2
7757: DIVREAL
7758: PUSH
7759: FOR_TO
7760: IFFALSE 7946
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
7762: LD_EXP 17
7766: PUSH
7767: LD_VAR 0 2
7771: ARRAY
7772: PPUSH
7773: LD_EXP 17
7777: PUSH
7778: LD_VAR 0 2
7782: PUSH
7783: LD_INT 1
7785: PLUS
7786: ARRAY
7787: PPUSH
7788: CALL_OW 428
7792: PUSH
7793: LD_INT 0
7795: GREATER
7796: IFFALSE 7930
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
7798: LD_EXP 17
7802: PUSH
7803: LD_VAR 0 2
7807: ARRAY
7808: PPUSH
7809: LD_EXP 17
7813: PUSH
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 1
7821: PLUS
7822: ARRAY
7823: PPUSH
7824: CALL_OW 428
7828: PPUSH
7829: CALL_OW 255
7833: PUSH
7834: LD_EXP 8
7838: NONEQUAL
7839: IFFALSE 7930
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
7841: LD_EXP 17
7845: PUSH
7846: LD_VAR 0 2
7850: ARRAY
7851: PPUSH
7852: LD_EXP 17
7856: PUSH
7857: LD_VAR 0 2
7861: PUSH
7862: LD_INT 1
7864: PLUS
7865: ARRAY
7866: PPUSH
7867: LD_EXP 8
7871: PPUSH
7872: CALL_OW 456
// mines_list := Delete ( mines_list , p ) ;
7876: LD_ADDR_EXP 17
7880: PUSH
7881: LD_EXP 17
7885: PPUSH
7886: LD_VAR 0 2
7890: PPUSH
7891: CALL_OW 3
7895: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
7896: LD_ADDR_EXP 17
7900: PUSH
7901: LD_EXP 17
7905: PPUSH
7906: LD_VAR 0 2
7910: PPUSH
7911: CALL_OW 3
7915: ST_TO_ADDR
// p := p - 2 ;
7916: LD_ADDR_VAR 0 2
7920: PUSH
7921: LD_VAR 0 2
7925: PUSH
7926: LD_INT 2
7928: MINUS
7929: ST_TO_ADDR
// end ; p := p + 2 ;
7930: LD_ADDR_VAR 0 2
7934: PUSH
7935: LD_VAR 0 2
7939: PUSH
7940: LD_INT 2
7942: PLUS
7943: ST_TO_ADDR
// end ;
7944: GO 7759
7946: POP
7947: POP
// end ;
7948: PPOPN 2
7950: END
// every 0 0$03 do var i , p , skr , filter , dep ;
7951: GO 7953
7953: DISABLE
7954: LD_INT 0
7956: PPUSH
7957: PPUSH
7958: PPUSH
7959: PPUSH
7960: PPUSH
// begin enable ;
7961: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) ;
7962: LD_ADDR_VAR 0 4
7966: PUSH
7967: LD_INT 50
7969: PUSH
7970: EMPTY
7971: LIST
7972: PUSH
7973: LD_INT 22
7975: PUSH
7976: LD_EXP 8
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PUSH
7985: LD_INT 25
7987: PUSH
7988: LD_INT 16
7990: PUSH
7991: EMPTY
7992: LIST
7993: LIST
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: LIST
7999: PPUSH
8000: CALL_OW 69
8004: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8005: LD_ADDR_VAR 0 5
8009: PUSH
8010: LD_INT 22
8012: PUSH
8013: LD_EXP 8
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 2
8024: PUSH
8025: LD_INT 30
8027: PUSH
8028: LD_INT 0
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: PUSH
8035: LD_INT 30
8037: PUSH
8038: LD_INT 1
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: LIST
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: PPUSH
8054: CALL_OW 69
8058: ST_TO_ADDR
// skr := GetListOfCratesInArea ( kabul_crates ) ;
8059: LD_ADDR_VAR 0 3
8063: PUSH
8064: LD_INT 13
8066: PPUSH
8067: CALL_OW 435
8071: ST_TO_ADDR
// if filter and skr then
8072: LD_VAR 0 4
8076: PUSH
8077: LD_VAR 0 3
8081: AND
8082: IFFALSE 8139
// for i = 1 to filter do
8084: LD_ADDR_VAR 0 1
8088: PUSH
8089: DOUBLE
8090: LD_INT 1
8092: DEC
8093: ST_TO_ADDR
8094: LD_VAR 0 4
8098: PUSH
8099: FOR_TO
8100: IFFALSE 8137
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
8102: LD_VAR 0 4
8106: PUSH
8107: LD_VAR 0 1
8111: ARRAY
8112: PPUSH
8113: LD_VAR 0 3
8117: PUSH
8118: LD_INT 1
8120: ARRAY
8121: PPUSH
8122: LD_VAR 0 3
8126: PUSH
8127: LD_INT 2
8129: ARRAY
8130: PPUSH
8131: CALL_OW 117
8135: GO 8099
8137: POP
8138: POP
// end ; end_of_file
8139: PPOPN 5
8141: END
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
8142: LD_INT 0
8144: PPUSH
8145: PPUSH
8146: PPUSH
8147: PPUSH
// begin if un in attackers then
8148: LD_VAR 0 1
8152: PUSH
8153: LD_EXP 20
8157: IN
8158: IFFALSE 8176
// attackers := attackers diff un ;
8160: LD_ADDR_EXP 20
8164: PUSH
8165: LD_EXP 20
8169: PUSH
8170: LD_VAR 0 1
8174: DIFF
8175: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
8176: LD_VAR 0 1
8180: PPUSH
8181: CALL_OW 255
8185: PUSH
8186: LD_EXP 8
8190: NONEQUAL
8191: PUSH
8192: LD_VAR 0 1
8196: PPUSH
8197: CALL_OW 255
8201: PUSH
8202: LD_INT 0
8204: GREATER
8205: AND
8206: PUSH
8207: LD_VAR 0 1
8211: PUSH
8212: LD_INT 21
8214: PUSH
8215: LD_INT 1
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: IN
8227: AND
8228: IFFALSE 8412
// begin if respawning_time_min > 0 0$00 then
8230: LD_EXP 13
8234: PUSH
8235: LD_INT 0
8237: GREATER
8238: IFFALSE 8412
// begin s := GetSide ( un ) ;
8240: LD_ADDR_VAR 0 4
8244: PUSH
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 255
8254: ST_TO_ADDR
// n := GetNation ( un ) ;
8255: LD_ADDR_VAR 0 5
8259: PUSH
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 248
8269: ST_TO_ADDR
// cl := GetClass ( un ) ;
8270: LD_ADDR_VAR 0 3
8274: PUSH
8275: LD_VAR 0 1
8279: PPUSH
8280: CALL_OW 257
8284: ST_TO_ADDR
// wait ( respawning_time_min ) ;
8285: LD_EXP 13
8289: PPUSH
8290: CALL_OW 67
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) * cl ) ;
8294: LD_EXP 14
8298: PUSH
8299: LD_INT 350
8301: PUSH
8302: LD_OWVAR 1
8306: MUL
8307: PUSH
8308: LD_INT 10
8310: MOD
8311: PUSH
8312: LD_INT 1
8314: PLUS
8315: PUSH
8316: LD_VAR 0 3
8320: MUL
8321: MINUS
8322: PPUSH
8323: CALL_OW 67
// uc_side := s ;
8327: LD_ADDR_OWVAR 20
8331: PUSH
8332: LD_VAR 0 4
8336: ST_TO_ADDR
// uc_nation := n ;
8337: LD_ADDR_OWVAR 21
8341: PUSH
8342: LD_VAR 0 5
8346: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
8347: LD_INT 0
8349: PPUSH
8350: LD_VAR 0 3
8354: PPUSH
8355: LD_EXP 11
8359: PUSH
8360: LD_INT 2
8362: MINUS
8363: PPUSH
8364: CALL_OW 380
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
8368: CALL_OW 44
8372: PPUSH
8373: LD_INT 17
8375: PUSH
8376: LD_INT 19
8378: PUSH
8379: LD_INT 18
8381: PUSH
8382: LD_INT 19
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: LIST
8389: LIST
8390: PUSH
8391: LD_VAR 0 3
8395: PUSH
8396: LD_INT 4
8398: MOD
8399: PUSH
8400: LD_INT 1
8402: PLUS
8403: ARRAY
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 49
// end ; end ; end ;
8412: PPOPN 5
8414: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
8415: LD_VAR 0 1
8419: PPUSH
8420: CALL_OW 255
8424: PUSH
8425: LD_EXP 8
8429: EQUAL
8430: PUSH
8431: LD_VAR 0 1
8435: PUSH
8436: LD_INT 33
8438: PUSH
8439: LD_INT 2
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: LD_INT 21
8448: PUSH
8449: LD_INT 2
8451: PUSH
8452: EMPTY
8453: LIST
8454: LIST
8455: PUSH
8456: EMPTY
8457: LIST
8458: LIST
8459: PPUSH
8460: CALL_OW 69
8464: IN
8465: AND
8466: IFFALSE 8589
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
8468: LD_OWVAR 3
8472: PUSH
8473: LD_VAR 0 1
8477: DIFF
8478: PPUSH
8479: LD_VAR 0 1
8483: PPUSH
8484: CALL_OW 74
8488: PPUSH
8489: CALL_OW 255
8493: PUSH
8494: LD_EXP 8
8498: NONEQUAL
8499: IFFALSE 8589
// begin Wait ( 0 0$1.3 ) ;
8501: LD_INT 46
8503: PPUSH
8504: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8508: LD_VAR 0 1
8512: PPUSH
8513: CALL_OW 250
8517: PPUSH
8518: LD_VAR 0 1
8522: PPUSH
8523: CALL_OW 251
8527: PPUSH
8528: LD_INT 1
8530: PPUSH
8531: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8535: LD_VAR 0 1
8539: PPUSH
8540: CALL_OW 250
8544: PPUSH
8545: LD_VAR 0 1
8549: PPUSH
8550: CALL_OW 251
8554: PPUSH
8555: LD_INT 1
8557: PPUSH
8558: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
8562: LD_VAR 0 1
8566: PPUSH
8567: CALL_OW 250
8571: PPUSH
8572: LD_VAR 0 1
8576: PPUSH
8577: CALL_OW 251
8581: PPUSH
8582: LD_INT 1
8584: PPUSH
8585: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
8589: LD_VAR 0 1
8593: PPUSH
8594: CALL_OW 263
8598: PUSH
8599: LD_INT 2
8601: EQUAL
8602: IFFALSE 8613
// ComUnlink ( un ) ;
8604: LD_VAR 0 1
8608: PPUSH
8609: CALL_OW 136
// end ;
8613: PPOPN 1
8615: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
8616: LD_VAR 0 1
8620: PPUSH
8621: CALL_OW 255
8625: PUSH
8626: LD_EXP 8
8630: EQUAL
8631: IFFALSE 8662
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
8633: LD_ADDR_EXP 20
8637: PUSH
8638: LD_EXP 20
8642: PPUSH
8643: LD_EXP 20
8647: PUSH
8648: LD_INT 1
8650: PLUS
8651: PPUSH
8652: LD_VAR 0 1
8656: PPUSH
8657: CALL_OW 2
8661: ST_TO_ADDR
// end ;
8662: PPOPN 2
8664: END
// on LeaveBuilding ( b , un ) do var i , arm ;
8665: LD_INT 0
8667: PPUSH
8668: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
8669: LD_VAR 0 1
8673: PPUSH
8674: CALL_OW 255
8678: PUSH
8679: LD_EXP 8
8683: EQUAL
8684: PUSH
8685: LD_VAR 0 1
8689: PPUSH
8690: CALL_OW 266
8694: PUSH
8695: LD_INT 32
8697: EQUAL
8698: AND
8699: IFFALSE 8797
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
8701: LD_ADDR_VAR 0 4
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_EXP 8
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PUSH
8718: LD_INT 30
8720: PUSH
8721: LD_INT 5
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: PPUSH
8732: CALL_OW 69
8736: ST_TO_ADDR
// for i in arm do
8737: LD_ADDR_VAR 0 3
8741: PUSH
8742: LD_VAR 0 4
8746: PUSH
8747: FOR_IN
8748: IFFALSE 8795
// if UnitsInside ( i ) < 6 then
8750: LD_VAR 0 3
8754: PPUSH
8755: CALL_OW 313
8759: PUSH
8760: LD_INT 6
8762: LESS
8763: IFFALSE 8793
// begin ComEnterUnit ( un , i ) ;
8765: LD_VAR 0 2
8769: PPUSH
8770: LD_VAR 0 3
8774: PPUSH
8775: CALL_OW 120
// AddComChangeProfession ( un , class_mortar ) ;
8779: LD_VAR 0 2
8783: PPUSH
8784: LD_INT 8
8786: PPUSH
8787: CALL_OW 183
// break ;
8791: GO 8795
// end ;
8793: GO 8747
8795: POP
8796: POP
// end ; end ; end_of_file
8797: PPOPN 4
8799: END
// every 2 2$0 do
8800: GO 8802
8802: DISABLE
// begin Anticheatcheck ;
8803: CALL_OW 514
// enable ;
8807: ENABLE
// end ; end_of_file
8808: END
// every 10 do
8809: GO 8811
8811: DISABLE
// begin if not multiplayer then
8812: LD_OWVAR 4
8816: NOT
8817: IFFALSE 8821
// exit ;
8819: GO 8906
// if tick < 100 then
8821: LD_OWVAR 1
8825: PUSH
8826: LD_INT 100
8828: LESS
8829: IFFALSE 8849
// begin if tick mod 10 = 0 then
8831: LD_OWVAR 1
8835: PUSH
8836: LD_INT 10
8838: MOD
8839: PUSH
8840: LD_INT 0
8842: EQUAL
8843: IFFALSE 8849
// MultiplayerCRC ;
8845: CALL_OW 361
// end ; if ( tick >= 100 ) then
8849: LD_OWVAR 1
8853: PUSH
8854: LD_INT 100
8856: GREATEREQUAL
8857: IFFALSE 8877
// if tick mod 20 = 0 then
8859: LD_OWVAR 1
8863: PUSH
8864: LD_INT 20
8866: MOD
8867: PUSH
8868: LD_INT 0
8870: EQUAL
8871: IFFALSE 8877
// MultiplayerCRC ;
8873: CALL_OW 361
// if ( tick >= 100 ) then
8877: LD_OWVAR 1
8881: PUSH
8882: LD_INT 100
8884: GREATEREQUAL
8885: IFFALSE 8905
// if tick mod 30 = 0 then
8887: LD_OWVAR 1
8891: PUSH
8892: LD_INT 30
8894: MOD
8895: PUSH
8896: LD_INT 0
8898: EQUAL
8899: IFFALSE 8905
// DebugLogAll ;
8901: CALL_OW 360
// enable ;
8905: ENABLE
// end ; end_of_file
8906: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
8907: LD_INT 0
8909: PPUSH
8910: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_STRING #Multi1x1-Time
8918: PUSH
8919: LD_OWVAR 1
8923: PUSH
8924: EMPTY
8925: LIST
8926: LIST
8927: ST_TO_ADDR
// if ( ExtraStrings ) then
8928: LD_EXP 28
8932: IFFALSE 8954
// AllStrings := AllStrings ^  ^ ExtraStrings ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_VAR 0 2
8943: PUSH
8944: LD_STRING 
8946: ADD
8947: PUSH
8948: LD_EXP 28
8952: ADD
8953: ST_TO_ADDR
// Display_Strings := AllStrings ;
8954: LD_ADDR_OWVAR 47
8958: PUSH
8959: LD_VAR 0 2
8963: ST_TO_ADDR
// end ;
8964: LD_VAR 0 1
8968: RET
// every 0 0$1 do
8969: GO 8971
8971: DISABLE
// begin ShowTimer ;
8972: CALL 8907 0 0
// enable ;
8976: ENABLE
// end ;
8977: END
