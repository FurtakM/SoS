// starting begin Game_Start := false ;
   0: NOP4
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// Randomize ;
   8: NOP4
// Init ( ) ;
  12: NOP4
// InitBot ( ) ;
  16: NOP4
// Game_Start := true ;
  20: NOP4
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// end ;
  28: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , bot_side ] ) = 0 do
  29: NOP4
  33: PUSH
  34: LD_INT 22
  36: PUSH
  37: NOP4
  41: PUSH
  42: EMPTY
  43: LIST
  44: LIST
  45: PPUSH
  46: NOP4
  50: PUSH
  51: LD_INT 0
  53: EQUAL
  54: AND
  55: IFFALSE 64
  57: GO 59
  59: DISABLE
// YouWinInMultiplayer ;
  60: NOP4
  64: END
// every 0 0$01 trigger game_start and FilterAllUnits ( [ f_side , your_side ] ) = 0 do
  65: NOP4
  69: PUSH
  70: LD_INT 22
  72: PUSH
  73: NOP4
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PPUSH
  82: NOP4
  86: PUSH
  87: LD_INT 0
  89: EQUAL
  90: AND
  91: IFFALSE 111
  93: GO 95
  95: DISABLE
// begin Multiplayer_Loose_Message ;
  96: NOP4
// Wait ( 0 0$03 ) ;
 100: LD_INT 105
 102: PPUSH
 103: NOP4
// YouLostInMultiplayer ;
 107: NOP4
// end ;
 111: END
// export Game_Type , Side_Positions , Side_Teams , Side_Nations , Teams ; export Team_Game , Side_Start , Bot_Side , Game_Start ; export number_of_people , skill_level , crates_spawn , respawning_time_min , respawning_time_max , amount_of_apeman ; export definitions , mines_list , apeman_areas , patrols , attackers , to_produce , veh_counter , queue_codes , rng , target , handicap , rforce , rforce2 , att_counter ; export function Init ( ) ; var i , j ; begin
 112: LD_INT 0
 114: PPUSH
 115: PPUSH
 116: PPUSH
// definitions := [ ] ;
 117: NOP4
 121: PUSH
 122: EMPTY
 123: ST_TO_ADDR
// rforce := [ ] ;
 124: NOP4
 128: PUSH
 129: EMPTY
 130: ST_TO_ADDR
// rforce2 := [ ] ;
 131: NOP4
 135: PUSH
 136: EMPTY
 137: ST_TO_ADDR
// if Multiplayer then
 138: NOP4
 142: IFFALSE 264
// begin Game_Type := mp_game_type ;
 144: NOP4
 148: PUSH
 149: NOP4
 153: ST_TO_ADDR
// Your_Side := mp_player_side ;
 154: LD_ADDR_OWVAR 2
 158: PUSH
 159: NOP4
 163: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
 164: NOP4
 168: PUSH
 169: NOP4
 173: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
 174: NOP4
 178: PUSH
 179: NOP4
 183: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
 184: NOP4
 188: PUSH
 189: NOP4
 193: ST_TO_ADDR
// Teams := mp_teams ;
 194: NOP4
 198: PUSH
 199: NOP4
 203: ST_TO_ADDR
// for i = 0 to 6 do
 204: NOP4
 208: PUSH
 209: DOUBLE
 210: LD_INT 0
 212: DEC
 213: ST_TO_ADDR
 214: LD_INT 6
 216: PUSH
 217: FOR_TO
 218: IFFALSE 260
// definitions := Insert ( definitions , definitions + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 220: NOP4
 224: PUSH
 225: NOP4
 229: PPUSH
 230: NOP4
 234: PUSH
 235: LD_INT 1
 237: PLUS
 238: PPUSH
 239: NOP4
 243: PPUSH
 244: NOP4
 248: PUSH
 249: LD_INT 1
 251: PLUS
 252: PPUSH
 253: NOP4
 257: ST_TO_ADDR
 258: GO 217
 260: POP
 261: POP
// end else
 262: GO 415
// begin Game_Type := 1 ;
 264: NOP4
 268: PUSH
 269: LD_INT 1
 271: ST_TO_ADDR
// Your_Side := 1 ;
 272: LD_ADDR_OWVAR 2
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// Side_Positions := [ 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ;
 280: NOP4
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 0
 299: PUSH
 300: LD_INT 0
 302: PUSH
 303: LD_INT 0
 305: PUSH
 306: LD_INT 0
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: LIST
 317: LIST
 318: ST_TO_ADDR
// Side_Teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 319: NOP4
 323: PUSH
 324: LD_INT 1
 326: PUSH
 327: LD_INT 0
 329: PUSH
 330: LD_INT 0
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 0
 338: PUSH
 339: LD_INT 0
 341: PUSH
 342: LD_INT 0
 344: PUSH
 345: LD_INT 0
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: ST_TO_ADDR
// Side_Nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] ;
 358: NOP4
 362: PUSH
 363: LD_INT 1
 365: PUSH
 366: LD_INT 0
 368: PUSH
 369: LD_INT 0
 371: PUSH
 372: LD_INT 1
 374: PUSH
 375: LD_INT 0
 377: PUSH
 378: LD_INT 0
 380: PUSH
 381: LD_INT 0
 383: PUSH
 384: LD_INT 0
 386: PUSH
 387: EMPTY
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: ST_TO_ADDR
// Teams := [ [ 1 , 4 ] ] ;
 397: NOP4
 401: PUSH
 402: LD_INT 1
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: PUSH
 412: EMPTY
 413: LIST
 414: ST_TO_ADDR
// end ; Side_Start := [ [ 83 , 148 ] , [ 187 , 144 ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
 415: NOP4
 419: PUSH
 420: LD_INT 83
 422: PUSH
 423: LD_INT 148
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 187
 432: PUSH
 433: LD_INT 144
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: PUSH
 440: EMPTY
 441: PUSH
 442: EMPTY
 443: PUSH
 444: EMPTY
 445: PUSH
 446: EMPTY
 447: PUSH
 448: EMPTY
 449: PUSH
 450: EMPTY
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: ST_TO_ADDR
// Bot_Side := 2 ;
 462: NOP4
 466: PUSH
 467: LD_INT 2
 469: ST_TO_ADDR
// for i = 1 to 8 do
 470: NOP4
 474: PUSH
 475: DOUBLE
 476: LD_INT 1
 478: DEC
 479: ST_TO_ADDR
 480: LD_INT 8
 482: PUSH
 483: FOR_TO
 484: IFFALSE 627
// begin if Multiplayer_GetPlayerIsSpec ( i ) or Multiplayer_GetPlayerIsComp ( i ) then
 486: NOP4
 490: PPUSH
 491: NOP4
 495: PUSH
 496: NOP4
 500: PPUSH
 501: NOP4
 505: OR
 506: IFFALSE 580
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 508: NOP4
 512: PUSH
 513: NOP4
 517: PPUSH
 518: NOP4
 522: PPUSH
 523: LD_INT 0
 525: PPUSH
 526: NOP4
 530: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 531: NOP4
 535: PUSH
 536: NOP4
 540: PPUSH
 541: NOP4
 545: PUSH
 546: NOP4
 550: ARRAY
 551: PPUSH
 552: NOP4
 556: PUSH
 557: NOP4
 561: PUSH
 562: NOP4
 566: ARRAY
 567: ARRAY
 568: PUSH
 569: NOP4
 573: DIFF
 574: PPUSH
 575: NOP4
 579: ST_TO_ADDR
// end ; if Side_Nations [ i ] and Side_Nations <> 1 then
 580: NOP4
 584: PUSH
 585: NOP4
 589: ARRAY
 590: PUSH
 591: NOP4
 595: PUSH
 596: LD_INT 1
 598: NONEQUAL
 599: AND
 600: IFFALSE 625
// Side_Nations := Replace ( Side_Nations , i , 1 ) ;
 602: NOP4
 606: PUSH
 607: NOP4
 611: PPUSH
 612: NOP4
 616: PPUSH
 617: LD_INT 1
 619: PPUSH
 620: NOP4
 624: ST_TO_ADDR
// end ;
 625: GO 483
 627: POP
 628: POP
// if 2 = bot_side and Side_Positions [ 2 ] then
 629: LD_INT 2
 631: PUSH
 632: NOP4
 636: EQUAL
 637: PUSH
 638: NOP4
 642: PUSH
 643: LD_INT 2
 645: ARRAY
 646: AND
 647: IFFALSE 657
// bot_side := 5 ;
 649: NOP4
 653: PUSH
 654: LD_INT 5
 656: ST_TO_ADDR
// if 5 = bot_side and Side_Positions [ 5 ] then
 657: LD_INT 5
 659: PUSH
 660: NOP4
 664: EQUAL
 665: PUSH
 666: NOP4
 670: PUSH
 671: LD_INT 5
 673: ARRAY
 674: AND
 675: IFFALSE 685
// bot_side := 8 ;
 677: NOP4
 681: PUSH
 682: LD_INT 8
 684: ST_TO_ADDR
// Team_Game := false ;
 685: NOP4
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// for i = 1 to 8 do
 693: NOP4
 697: PUSH
 698: DOUBLE
 699: LD_INT 1
 701: DEC
 702: ST_TO_ADDR
 703: LD_INT 8
 705: PUSH
 706: FOR_TO
 707: IFFALSE 733
// if Side_Teams [ i ] then
 709: NOP4
 713: PUSH
 714: NOP4
 718: ARRAY
 719: IFFALSE 731
// begin Team_Game := true ;
 721: NOP4
 725: PUSH
 726: LD_INT 1
 728: ST_TO_ADDR
// break ;
 729: GO 733
// end ;
 731: GO 706
 733: POP
 734: POP
// for i in Teams do
 735: NOP4
 739: PUSH
 740: NOP4
 744: PUSH
 745: FOR_IN
 746: IFFALSE 826
// for j = 2 to i do
 748: NOP4
 752: PUSH
 753: DOUBLE
 754: LD_INT 2
 756: DEC
 757: ST_TO_ADDR
 758: NOP4
 762: PUSH
 763: FOR_TO
 764: IFFALSE 822
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
 766: NOP4
 770: PUSH
 771: NOP4
 775: ARRAY
 776: PPUSH
 777: NOP4
 781: PUSH
 782: LD_INT 1
 784: ARRAY
 785: PPUSH
 786: NOP4
// SetAttitude ( i [ j ] , i [ 1 ] , att_friend , true ) ;
 790: NOP4
 794: PUSH
 795: NOP4
 799: ARRAY
 800: PPUSH
 801: NOP4
 805: PUSH
 806: LD_INT 1
 808: ARRAY
 809: PPUSH
 810: LD_INT 1
 812: PPUSH
 813: LD_INT 1
 815: PPUSH
 816: NOP4
// end ;
 820: GO 763
 822: POP
 823: POP
 824: GO 745
 826: POP
 827: POP
// if not Multiplayer then
 828: NOP4
 832: NOT
 833: IFFALSE 870
// definitions := [ 1 , 1 , 1 , 1 , 2 , 3 , 3 ] ;
 835: NOP4
 839: PUSH
 840: LD_INT 1
 842: PUSH
 843: LD_INT 1
 845: PUSH
 846: LD_INT 1
 848: PUSH
 849: LD_INT 1
 851: PUSH
 852: LD_INT 2
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: LD_INT 3
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: ST_TO_ADDR
// number_of_people := [ 5 , 9 , 12 , 15 ] [ definitions [ 1 ] ] ;
 870: NOP4
 874: PUSH
 875: LD_INT 5
 877: PUSH
 878: LD_INT 9
 880: PUSH
 881: LD_INT 12
 883: PUSH
 884: LD_INT 15
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: NOP4
 897: PUSH
 898: LD_INT 1
 900: ARRAY
 901: ARRAY
 902: ST_TO_ADDR
// skill_level := [ 2 , 4 , 6 , 8 ] [ definitions [ 2 ] ] ;
 903: NOP4
 907: PUSH
 908: LD_INT 2
 910: PUSH
 911: LD_INT 4
 913: PUSH
 914: LD_INT 6
 916: PUSH
 917: LD_INT 8
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: NOP4
 930: PUSH
 931: LD_INT 2
 933: ARRAY
 934: ARRAY
 935: ST_TO_ADDR
// crates_spawn := [ 0 0$55 , 0 0$45 , 0 0$31 , 0 0$21 ] [ definitions [ 3 ] ] ;
 936: NOP4
 940: PUSH
 941: LD_INT 1925
 943: PUSH
 944: LD_INT 1575
 946: PUSH
 947: LD_INT 1085
 949: PUSH
 950: LD_INT 735
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: PUSH
 959: NOP4
 963: PUSH
 964: LD_INT 3
 966: ARRAY
 967: ARRAY
 968: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 ] [ 1 ] ;
 969: NOP4
 973: PUSH
 974: LD_INT 0
 976: PUSH
 977: EMPTY
 978: LIST
 979: PUSH
 980: LD_INT 1
 982: ARRAY
 983: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 ] [ 1 ] ;
 984: NOP4
 988: PUSH
 989: LD_INT 0
 991: PUSH
 992: EMPTY
 993: LIST
 994: PUSH
 995: LD_INT 1
 997: ARRAY
 998: ST_TO_ADDR
// amount_of_apeman := [ 0 , 3 , 5 , 7 ] [ definitions [ 4 ] ] ;
 999: NOP4
1003: PUSH
1004: LD_INT 0
1006: PUSH
1007: LD_INT 3
1009: PUSH
1010: LD_INT 5
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: NOP4
1026: PUSH
1027: LD_INT 4
1029: ARRAY
1030: ARRAY
1031: ST_TO_ADDR
// difficulty := [ 1 , 2 , 3 ] [ definitions [ 5 ] ] ;
1032: LD_ADDR_OWVAR 67
1036: PUSH
1037: LD_INT 1
1039: PUSH
1040: LD_INT 2
1042: PUSH
1043: LD_INT 3
1045: PUSH
1046: EMPTY
1047: LIST
1048: LIST
1049: LIST
1050: PUSH
1051: NOP4
1055: PUSH
1056: LD_INT 5
1058: ARRAY
1059: ARRAY
1060: ST_TO_ADDR
// handicap := [ 0 , 1 , 2 ] [ definitions [ 6 ] ] ;
1061: NOP4
1065: PUSH
1066: LD_INT 0
1068: PUSH
1069: LD_INT 1
1071: PUSH
1072: LD_INT 2
1074: PUSH
1075: EMPTY
1076: LIST
1077: LIST
1078: LIST
1079: PUSH
1080: NOP4
1084: PUSH
1085: LD_INT 6
1087: ARRAY
1088: ARRAY
1089: ST_TO_ADDR
// queue_codes := [ 11353 , 12644 , 44646 , 12345 , 43411 , 14652 , 23441 ] ;
1090: NOP4
1094: PUSH
1095: LD_INT 11353
1097: PUSH
1098: LD_INT 12644
1100: PUSH
1101: LD_INT 44646
1103: PUSH
1104: LD_INT 12345
1106: PUSH
1107: LD_INT 43411
1109: PUSH
1110: LD_INT 14652
1112: PUSH
1113: LD_INT 23441
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: LIST
1124: ST_TO_ADDR
// rng := Rand ( 1 , 7 ) ;
1125: NOP4
1129: PUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 7
1135: PPUSH
1136: NOP4
1140: ST_TO_ADDR
// if bot_side <> 2 then
1141: NOP4
1145: PUSH
1146: LD_INT 2
1148: NONEQUAL
1149: IFFALSE 1192
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
1151: NOP4
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: LD_INT 2
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: PPUSH
1166: NOP4
1170: PUSH
1171: FOR_IN
1172: IFFALSE 1190
// SetSide ( i , bot_side ) ;
1174: NOP4
1178: PPUSH
1179: NOP4
1183: PPUSH
1184: NOP4
1188: GO 1171
1190: POP
1191: POP
// ResetFog ;
1192: NOP4
// PreparePeople ( ) ;
1196: NOP4
// apeman_areas := [ ape1 , ape2 , ape3 ] ;
1200: NOP4
1204: PUSH
1205: LD_INT 1
1207: PUSH
1208: LD_INT 2
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: LIST
1218: ST_TO_ADDR
// if amount_of_apeman then
1219: NOP4
1223: IFFALSE 1273
// for j in apeman_areas do
1225: NOP4
1229: PUSH
1230: NOP4
1234: PUSH
1235: FOR_IN
1236: IFFALSE 1271
// for i = 1 to amount_of_apeman do
1238: NOP4
1242: PUSH
1243: DOUBLE
1244: LD_INT 1
1246: DEC
1247: ST_TO_ADDR
1248: NOP4
1252: PUSH
1253: FOR_TO
1254: IFFALSE 1267
// AddApeman ( j ) ;
1256: NOP4
1260: PPUSH
1261: NOP4
1265: GO 1253
1267: POP
1268: POP
1269: GO 1235
1271: POP
1272: POP
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
1273: LD_INT 22
1275: PUSH
1276: NOP4
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: PPUSH
1285: NOP4
1289: PUSH
1290: LD_INT 1
1292: ARRAY
1293: PPUSH
1294: NOP4
// disable ( 17 ) ;
1298: LD_INT 17
1300: DISABLE_MARKED
// end ; end_of_file
1301: LD_VAR 0 1
1305: RET
// export function PreparePeople ( ) ; var i , j , un , to_copy , x , y , c , d ; begin
1306: LD_INT 0
1308: PPUSH
1309: PPUSH
1310: PPUSH
1311: PPUSH
1312: PPUSH
1313: PPUSH
1314: PPUSH
1315: PPUSH
1316: PPUSH
// to_copy := [ ] ;
1317: NOP4
1321: PUSH
1322: EMPTY
1323: ST_TO_ADDR
// for i = 1 to 8 do
1324: NOP4
1328: PUSH
1329: DOUBLE
1330: LD_INT 1
1332: DEC
1333: ST_TO_ADDR
1334: LD_INT 8
1336: PUSH
1337: FOR_TO
1338: IFFALSE 2537
// begin if Side_Positions [ i ] then
1340: NOP4
1344: PUSH
1345: NOP4
1349: ARRAY
1350: IFFALSE 2535
// begin uc_side := i ;
1352: LD_ADDR_OWVAR 20
1356: PUSH
1357: NOP4
1361: ST_TO_ADDR
// uc_nation := Side_Nations [ i ] ;
1362: LD_ADDR_OWVAR 21
1366: PUSH
1367: NOP4
1371: PUSH
1372: NOP4
1376: ARRAY
1377: ST_TO_ADDR
// x := Side_Start [ Side_Positions [ i ] ] [ 1 ] ;
1378: NOP4
1382: PUSH
1383: NOP4
1387: PUSH
1388: NOP4
1392: PUSH
1393: NOP4
1397: ARRAY
1398: ARRAY
1399: PUSH
1400: LD_INT 1
1402: ARRAY
1403: ST_TO_ADDR
// y := Side_Start [ Side_Positions [ i ] ] [ 2 ] ;
1404: NOP4
1408: PUSH
1409: NOP4
1413: PUSH
1414: NOP4
1418: PUSH
1419: NOP4
1423: ARRAY
1424: ARRAY
1425: PUSH
1426: LD_INT 2
1428: ARRAY
1429: ST_TO_ADDR
// hc_importance := 100 ;
1430: LD_ADDR_OWVAR 32
1434: PUSH
1435: LD_INT 100
1437: ST_TO_ADDR
// if Multiplayer then
1438: NOP4
1442: IFFALSE 1500
// begin hc_name := mp_sides_players_names [ uc_side ] ;
1444: LD_ADDR_OWVAR 26
1448: PUSH
1449: NOP4
1453: PUSH
1454: NOP4
1458: ARRAY
1459: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
1460: LD_ADDR_OWVAR 33
1464: PUSH
1465: LD_STRING MULTIAVATARS
1467: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
1468: LD_ADDR_OWVAR 34
1472: PUSH
1473: NOP4
1477: PPUSH
1478: NOP4
1482: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
1483: LD_ADDR_OWVAR 27
1487: PUSH
1488: NOP4
1492: PPUSH
1493: NOP4
1497: ST_TO_ADDR
// end else
1498: GO 1532
// begin hc_name :=  ;
1500: LD_ADDR_OWVAR 26
1504: PUSH
1505: LD_STRING 
1507: ST_TO_ADDR
// hc_gallery :=  ;
1508: LD_ADDR_OWVAR 33
1512: PUSH
1513: LD_STRING 
1515: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
1516: LD_ADDR_OWVAR 27
1520: PUSH
1521: LD_INT 1
1523: PPUSH
1524: LD_INT 2
1526: PPUSH
1527: NOP4
1531: ST_TO_ADDR
// end ; PrepareHuman ( hc_sex , 1 , skill_level ) ;
1532: NOP4
1536: PPUSH
1537: LD_INT 1
1539: PPUSH
1540: NOP4
1544: PPUSH
1545: NOP4
// un := CreateHuman ;
1549: NOP4
1553: PUSH
1554: NOP4
1558: ST_TO_ADDR
// if not to_copy then
1559: NOP4
1563: NOT
1564: IFFALSE 1591
// to_copy := Replace ( to_copy , 1 , un ) else
1566: NOP4
1570: PUSH
1571: NOP4
1575: PPUSH
1576: LD_INT 1
1578: PPUSH
1579: NOP4
1583: PPUSH
1584: NOP4
1588: ST_TO_ADDR
1589: GO 1667
// begin CopySkills ( to_copy [ 1 ] , un ) ;
1591: NOP4
1595: PUSH
1596: LD_INT 1
1598: ARRAY
1599: PPUSH
1600: NOP4
1604: PPUSH
1605: NOP4
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ 1 ] , attr_speed ) ) ;
1609: NOP4
1613: PPUSH
1614: LD_INT 2
1616: PPUSH
1617: NOP4
1621: PUSH
1622: LD_INT 1
1624: ARRAY
1625: PPUSH
1626: LD_INT 2
1628: PPUSH
1629: NOP4
1633: PPUSH
1634: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ 1 ] , attr_stamina ) ) ;
1638: NOP4
1642: PPUSH
1643: LD_INT 1
1645: PPUSH
1646: NOP4
1650: PUSH
1651: LD_INT 1
1653: ARRAY
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: NOP4
1662: PPUSH
1663: NOP4
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
1667: NOP4
1671: PPUSH
1672: NOP4
1676: PPUSH
1677: NOP4
1681: PPUSH
1682: LD_INT 10
1684: PPUSH
1685: LD_INT 0
1687: PPUSH
1688: NOP4
// hc_importance := 0 ;
1692: LD_ADDR_OWVAR 32
1696: PUSH
1697: LD_INT 0
1699: ST_TO_ADDR
// hc_name :=  ;
1700: LD_ADDR_OWVAR 26
1704: PUSH
1705: LD_STRING 
1707: ST_TO_ADDR
// hc_gallery :=  ;
1708: LD_ADDR_OWVAR 33
1712: PUSH
1713: LD_STRING 
1715: ST_TO_ADDR
// d := ( number_of_people - 1 ) / 4 ;
1716: NOP4
1720: PUSH
1721: NOP4
1725: PUSH
1726: LD_INT 1
1728: MINUS
1729: PUSH
1730: LD_INT 4
1732: DIVREAL
1733: ST_TO_ADDR
// c := 1 ;
1734: NOP4
1738: PUSH
1739: LD_INT 1
1741: ST_TO_ADDR
// for j = 2 to number_of_people do
1742: NOP4
1746: PUSH
1747: DOUBLE
1748: LD_INT 2
1750: DEC
1751: ST_TO_ADDR
1752: NOP4
1756: PUSH
1757: FOR_TO
1758: IFFALSE 2006
// begin PrepareHuman ( false , c , skill_level ) ;
1760: LD_INT 0
1762: PPUSH
1763: NOP4
1767: PPUSH
1768: NOP4
1772: PPUSH
1773: NOP4
// if ( j - 1 ) mod d = 0 then
1777: NOP4
1781: PUSH
1782: LD_INT 1
1784: MINUS
1785: PUSH
1786: NOP4
1790: MOD
1791: PUSH
1792: LD_INT 0
1794: EQUAL
1795: IFFALSE 1811
// c := c + 1 ;
1797: NOP4
1801: PUSH
1802: NOP4
1806: PUSH
1807: LD_INT 1
1809: PLUS
1810: ST_TO_ADDR
// un := CreateHuman ;
1811: NOP4
1815: PUSH
1816: NOP4
1820: ST_TO_ADDR
// if to_copy < j then
1821: NOP4
1825: PUSH
1826: NOP4
1830: LESS
1831: IFFALSE 1860
// to_copy := Replace ( to_copy , j , un ) else
1833: NOP4
1837: PUSH
1838: NOP4
1842: PPUSH
1843: NOP4
1847: PPUSH
1848: NOP4
1852: PPUSH
1853: NOP4
1857: ST_TO_ADDR
1858: GO 1942
// begin CopySkills ( to_copy [ j ] , un ) ;
1860: NOP4
1864: PUSH
1865: NOP4
1869: ARRAY
1870: PPUSH
1871: NOP4
1875: PPUSH
1876: NOP4
// SetAttr ( un , attr_speed , GetAttr ( to_copy [ j ] , attr_speed ) ) ;
1880: NOP4
1884: PPUSH
1885: LD_INT 2
1887: PPUSH
1888: NOP4
1892: PUSH
1893: NOP4
1897: ARRAY
1898: PPUSH
1899: LD_INT 2
1901: PPUSH
1902: NOP4
1906: PPUSH
1907: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( to_copy [ j ] , attr_stamina ) ) ;
1911: NOP4
1915: PPUSH
1916: LD_INT 1
1918: PPUSH
1919: NOP4
1923: PUSH
1924: NOP4
1928: ARRAY
1929: PPUSH
1930: LD_INT 1
1932: PPUSH
1933: NOP4
1937: PPUSH
1938: NOP4
// end ; PlaceUnitXYR ( un , x , y , 10 , false ) ;
1942: NOP4
1946: PPUSH
1947: NOP4
1951: PPUSH
1952: NOP4
1956: PPUSH
1957: LD_INT 10
1959: PPUSH
1960: LD_INT 0
1962: PPUSH
1963: NOP4
// if GetClass ( un ) = 3 and handicap < 2 then
1967: NOP4
1971: PPUSH
1972: NOP4
1976: PUSH
1977: LD_INT 3
1979: EQUAL
1980: PUSH
1981: NOP4
1985: PUSH
1986: LD_INT 2
1988: LESS
1989: AND
1990: IFFALSE 2004
// SetClass ( un , 1 ) ;
1992: NOP4
1996: PPUSH
1997: LD_INT 1
1999: PPUSH
2000: NOP4
// end ;
2004: GO 1757
2006: POP
2007: POP
// if handicap then
2008: NOP4
2012: IFFALSE 2535
// begin for j = 1 to 2 do
2014: NOP4
2018: PUSH
2019: DOUBLE
2020: LD_INT 1
2022: DEC
2023: ST_TO_ADDR
2024: LD_INT 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2112
// begin vc_chassis := us_medium_wheeled ;
2030: LD_ADDR_OWVAR 37
2034: PUSH
2035: LD_INT 2
2037: ST_TO_ADDR
// vc_engine := engine_siberite ;
2038: LD_ADDR_OWVAR 39
2042: PUSH
2043: LD_INT 3
2045: ST_TO_ADDR
// vc_control := control_computer ;
2046: LD_ADDR_OWVAR 38
2050: PUSH
2051: LD_INT 3
2053: ST_TO_ADDR
// vc_weapon := us_rocket_launcher ;
2054: LD_ADDR_OWVAR 40
2058: PUSH
2059: LD_INT 7
2061: ST_TO_ADDR
// un := CreateVehicle ;
2062: NOP4
2066: PUSH
2067: NOP4
2071: ST_TO_ADDR
// rforce := Insert ( rforce , 1 , [ un , x , y ] ) ;
2072: NOP4
2076: PUSH
2077: NOP4
2081: PPUSH
2082: LD_INT 1
2084: PPUSH
2085: NOP4
2089: PUSH
2090: NOP4
2094: PUSH
2095: NOP4
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: PPUSH
2105: NOP4
2109: ST_TO_ADDR
// end ;
2110: GO 2027
2112: POP
2113: POP
// vc_chassis := us_medium_wheeled ;
2114: LD_ADDR_OWVAR 37
2118: PUSH
2119: LD_INT 2
2121: ST_TO_ADDR
// vc_engine := engine_siberite ;
2122: LD_ADDR_OWVAR 39
2126: PUSH
2127: LD_INT 3
2129: ST_TO_ADDR
// vc_control := control_computer ;
2130: LD_ADDR_OWVAR 38
2134: PUSH
2135: LD_INT 3
2137: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
2138: LD_ADDR_OWVAR 40
2142: PUSH
2143: LD_INT 12
2145: ST_TO_ADDR
// un := CreateVehicle ;
2146: NOP4
2150: PUSH
2151: NOP4
2155: ST_TO_ADDR
// rforce := Insert ( rforce , 1 , [ un , x , y ] ) ;
2156: NOP4
2160: PUSH
2161: NOP4
2165: PPUSH
2166: LD_INT 1
2168: PPUSH
2169: NOP4
2173: PUSH
2174: NOP4
2178: PUSH
2179: NOP4
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: LIST
2188: PPUSH
2189: NOP4
2193: ST_TO_ADDR
// for j = 1 to 3 do
2194: NOP4
2198: PUSH
2199: DOUBLE
2200: LD_INT 1
2202: DEC
2203: ST_TO_ADDR
2204: LD_INT 3
2206: PUSH
2207: FOR_TO
2208: IFFALSE 2309
// begin vc_chassis := us_heavy_tracked ;
2210: LD_ADDR_OWVAR 37
2214: PUSH
2215: LD_INT 4
2217: ST_TO_ADDR
// vc_engine := engine_siberite ;
2218: LD_ADDR_OWVAR 39
2222: PUSH
2223: LD_INT 3
2225: ST_TO_ADDR
// vc_control := control_computer ;
2226: LD_ADDR_OWVAR 38
2230: PUSH
2231: LD_INT 3
2233: ST_TO_ADDR
// vc_weapon := [ us_heavy_gun , us_heavy_gun , us_laser ] [ j ] ;
2234: LD_ADDR_OWVAR 40
2238: PUSH
2239: LD_INT 6
2241: PUSH
2242: LD_INT 6
2244: PUSH
2245: LD_INT 9
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: LIST
2252: PUSH
2253: NOP4
2257: ARRAY
2258: ST_TO_ADDR
// un := CreateVehicle ;
2259: NOP4
2263: PUSH
2264: NOP4
2268: ST_TO_ADDR
// rforce2 := Insert ( rforce2 , 1 , [ un , x , y ] ) ;
2269: NOP4
2273: PUSH
2274: NOP4
2278: PPUSH
2279: LD_INT 1
2281: PPUSH
2282: NOP4
2286: PUSH
2287: NOP4
2291: PUSH
2292: NOP4
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: PPUSH
2302: NOP4
2306: ST_TO_ADDR
// end ;
2307: GO 2207
2309: POP
2310: POP
// if handicap = 1 then
2311: NOP4
2315: PUSH
2316: LD_INT 1
2318: EQUAL
2319: IFFALSE 2378
// begin vc_chassis := us_medium_tracked ;
2321: LD_ADDR_OWVAR 37
2325: PUSH
2326: LD_INT 3
2328: ST_TO_ADDR
// vc_engine := engine_solar ;
2329: LD_ADDR_OWVAR 39
2333: PUSH
2334: LD_INT 2
2336: ST_TO_ADDR
// vc_control := control_computer ;
2337: LD_ADDR_OWVAR 38
2341: PUSH
2342: LD_INT 3
2344: ST_TO_ADDR
// vc_weapon := us_radar ;
2345: LD_ADDR_OWVAR 40
2349: PUSH
2350: LD_INT 11
2352: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2353: NOP4
2357: PPUSH
2358: NOP4
2362: PPUSH
2363: NOP4
2367: PPUSH
2368: LD_INT 13
2370: PPUSH
2371: LD_INT 0
2373: PPUSH
2374: NOP4
// end ; if handicap = 2 then
2378: NOP4
2382: PUSH
2383: LD_INT 2
2385: EQUAL
2386: IFFALSE 2535
// begin for j = 1 to 2 do
2388: NOP4
2392: PUSH
2393: DOUBLE
2394: LD_INT 1
2396: DEC
2397: ST_TO_ADDR
2398: LD_INT 2
2400: PUSH
2401: FOR_TO
2402: IFFALSE 2476
// begin vc_chassis := us_medium_tracked ;
2404: LD_ADDR_OWVAR 37
2408: PUSH
2409: LD_INT 3
2411: ST_TO_ADDR
// vc_engine := engine_siberite ;
2412: LD_ADDR_OWVAR 39
2416: PUSH
2417: LD_INT 3
2419: ST_TO_ADDR
// vc_control := control_manual ;
2420: LD_ADDR_OWVAR 38
2424: PUSH
2425: LD_INT 1
2427: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ j ] ;
2428: LD_ADDR_OWVAR 40
2432: PUSH
2433: LD_INT 4
2435: PUSH
2436: LD_INT 5
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PUSH
2443: NOP4
2447: ARRAY
2448: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2449: NOP4
2453: PPUSH
2454: NOP4
2458: PPUSH
2459: NOP4
2463: PPUSH
2464: LD_INT 13
2466: PPUSH
2467: LD_INT 0
2469: PPUSH
2470: NOP4
// end ;
2474: GO 2401
2476: POP
2477: POP
// vc_chassis := us_medium_tracked ;
2478: LD_ADDR_OWVAR 37
2482: PUSH
2483: LD_INT 3
2485: ST_TO_ADDR
// vc_engine := engine_solar ;
2486: LD_ADDR_OWVAR 39
2490: PUSH
2491: LD_INT 2
2493: ST_TO_ADDR
// vc_control := control_computer ;
2494: LD_ADDR_OWVAR 38
2498: PUSH
2499: LD_INT 3
2501: ST_TO_ADDR
// vc_weapon := us_radar ;
2502: LD_ADDR_OWVAR 40
2506: PUSH
2507: LD_INT 11
2509: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , x , y , 13 , false ) ;
2510: NOP4
2514: PPUSH
2515: NOP4
2519: PPUSH
2520: NOP4
2524: PPUSH
2525: LD_INT 13
2527: PPUSH
2528: LD_INT 0
2530: PPUSH
2531: NOP4
// end ; end ; end ; end ;
2535: GO 1337
2537: POP
2538: POP
// end ;
2539: LD_VAR 0 1
2543: RET
// export function AddApeman ( area ) ; begin
2544: LD_INT 0
2546: PPUSH
// uc_nation := 0 ;
2547: LD_ADDR_OWVAR 21
2551: PUSH
2552: LD_INT 0
2554: ST_TO_ADDR
// uc_side := 0 ;
2555: LD_ADDR_OWVAR 20
2559: PUSH
2560: LD_INT 0
2562: ST_TO_ADDR
// hc_agressivity := rand ( - 10 , 15 ) ;
2563: LD_ADDR_OWVAR 35
2567: PUSH
2568: LD_INT 10
2570: NEG
2571: PPUSH
2572: LD_INT 15
2574: PPUSH
2575: NOP4
2579: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2580: LD_INT 0
2582: PPUSH
2583: LD_INT 12
2585: PPUSH
2586: LD_INT 0
2588: PPUSH
2589: NOP4
// hc_attr := [ 10 , 12 ] ;
2593: LD_ADDR_OWVAR 29
2597: PUSH
2598: LD_INT 10
2600: PUSH
2601: LD_INT 12
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , area , false ) ;
2608: NOP4
2612: PPUSH
2613: NOP4
2617: PPUSH
2618: LD_INT 0
2620: PPUSH
2621: NOP4
// end ;
2625: LD_VAR 0 2
2629: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
2630: LD_INT 0
2632: PPUSH
2633: PPUSH
2634: PPUSH
2635: PPUSH
// r := 100 ;
2636: NOP4
2640: PUSH
2641: LD_INT 100
2643: ST_TO_ADDR
// x := 0 ;
2644: NOP4
2648: PUSH
2649: LD_INT 0
2651: ST_TO_ADDR
// while ( x < n ) do
2652: NOP4
2656: PUSH
2657: NOP4
2661: LESS
2662: IFFALSE 2977
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
2664: NOP4
2668: PUSH
2669: DOUBLE
2670: LD_INT 1
2672: DEC
2673: ST_TO_ADDR
2674: NOP4
2678: PPUSH
2679: LD_INT 0
2681: PPUSH
2682: NOP4
2686: PUSH
2687: LD_INT 1
2689: ARRAY
2690: PUSH
2691: FOR_TO
2692: IFFALSE 2973
// begin if r > 50 then
2694: NOP4
2698: PUSH
2699: LD_INT 50
2701: GREATER
2702: IFFALSE 2949
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
2704: NOP4
2708: PPUSH
2709: LD_INT 0
2711: PPUSH
2712: NOP4
2716: PUSH
2717: LD_INT 1
2719: ARRAY
2720: PUSH
2721: NOP4
2725: ARRAY
2726: PPUSH
2727: NOP4
2731: PPUSH
2732: LD_INT 0
2734: PPUSH
2735: NOP4
2739: PUSH
2740: LD_INT 2
2742: ARRAY
2743: PUSH
2744: NOP4
2748: ARRAY
2749: PPUSH
2750: NOP4
2754: NOT
2755: IFFALSE 2933
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , bot_side , 0 ) ;
2757: NOP4
2761: PPUSH
2762: LD_INT 0
2764: PPUSH
2765: NOP4
2769: PUSH
2770: LD_INT 1
2772: ARRAY
2773: PUSH
2774: NOP4
2778: ARRAY
2779: PPUSH
2780: NOP4
2784: PPUSH
2785: LD_INT 0
2787: PPUSH
2788: NOP4
2792: PUSH
2793: LD_INT 2
2795: ARRAY
2796: PUSH
2797: NOP4
2801: ARRAY
2802: PPUSH
2803: NOP4
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: NOP4
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
2815: NOP4
2819: PUSH
2820: NOP4
2824: PPUSH
2825: NOP4
2829: PUSH
2830: LD_INT 1
2832: PLUS
2833: PPUSH
2834: NOP4
2838: PPUSH
2839: LD_INT 0
2841: PPUSH
2842: NOP4
2846: PUSH
2847: LD_INT 1
2849: ARRAY
2850: PUSH
2851: NOP4
2855: ARRAY
2856: PPUSH
2857: NOP4
2861: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
2862: NOP4
2866: PUSH
2867: NOP4
2871: PPUSH
2872: NOP4
2876: PUSH
2877: LD_INT 1
2879: PLUS
2880: PPUSH
2881: NOP4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: NOP4
2893: PUSH
2894: LD_INT 2
2896: ARRAY
2897: PUSH
2898: NOP4
2902: ARRAY
2903: PPUSH
2904: NOP4
2908: ST_TO_ADDR
// r := 0 ;
2909: NOP4
2913: PUSH
2914: LD_INT 0
2916: ST_TO_ADDR
// x := x + 1 ;
2917: NOP4
2921: PUSH
2922: NOP4
2926: PUSH
2927: LD_INT 1
2929: PLUS
2930: ST_TO_ADDR
// end else
2931: GO 2947
// r := r + 35 ;
2933: NOP4
2937: PUSH
2938: NOP4
2942: PUSH
2943: LD_INT 35
2945: PLUS
2946: ST_TO_ADDR
// end else
2947: GO 2971
// r := r + rand ( 10 , 25 ) ;
2949: NOP4
2953: PUSH
2954: NOP4
2958: PUSH
2959: LD_INT 10
2961: PPUSH
2962: LD_INT 25
2964: PPUSH
2965: NOP4
2969: PLUS
2970: ST_TO_ADDR
// end ;
2971: GO 2691
2973: POP
2974: POP
2975: GO 2652
// end ;
2977: LD_VAR 0 3
2981: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
2982: LD_INT 0
2984: PPUSH
2985: PPUSH
2986: PPUSH
// if not GetControl ( veh ) = control_manual then
2987: NOP4
2991: PPUSH
2992: NOP4
2996: PUSH
2997: LD_INT 1
2999: EQUAL
3000: NOT
3001: IFFALSE 3013
// result := false else
3003: NOP4
3007: PUSH
3008: LD_INT 0
3010: ST_TO_ADDR
3011: GO 3158
// if veh in FilterAllUnits ( [ f_empty ] ) then
3013: NOP4
3017: PUSH
3018: LD_INT 58
3020: PUSH
3021: EMPTY
3022: LIST
3023: PPUSH
3024: NOP4
3028: IN
3029: IFFALSE 3041
// result := false else
3031: NOP4
3035: PUSH
3036: LD_INT 0
3038: ST_TO_ADDR
3039: GO 3158
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3041: NOP4
3045: PUSH
3046: LD_INT 22
3048: PUSH
3049: NOP4
3053: PPUSH
3054: NOP4
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: PUSH
3063: LD_INT 55
3065: PUSH
3066: EMPTY
3067: LIST
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: PPUSH
3073: NOP4
3077: ST_TO_ADDR
// if not filter then
3078: NOP4
3082: NOT
3083: IFFALSE 3095
// result := false else
3085: NOP4
3089: PUSH
3090: LD_INT 0
3092: ST_TO_ADDR
3093: GO 3158
// for i = 1 to filter do
3095: NOP4
3099: PUSH
3100: DOUBLE
3101: LD_INT 1
3103: DEC
3104: ST_TO_ADDR
3105: NOP4
3109: PUSH
3110: FOR_TO
3111: IFFALSE 3156
// if IsDriver ( filter [ i ] ) = veh then
3113: NOP4
3117: PUSH
3118: NOP4
3122: ARRAY
3123: PPUSH
3124: NOP4
3128: PUSH
3129: NOP4
3133: EQUAL
3134: IFFALSE 3154
// begin result := filter [ i ] ;
3136: NOP4
3140: PUSH
3141: NOP4
3145: PUSH
3146: NOP4
3150: ARRAY
3151: ST_TO_ADDR
// break ;
3152: GO 3156
// end ;
3154: GO 3110
3156: POP
3157: POP
// end ; end ;
3158: LD_VAR 0 2
3162: RET
// export function IsDriver ( unit ) ; begin
3163: LD_INT 0
3165: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3166: NOP4
3170: PUSH
3171: LD_INT 55
3173: PUSH
3174: EMPTY
3175: LIST
3176: PPUSH
3177: NOP4
3181: IN
3182: IFFALSE 3201
// result := IsInUnit ( unit ) else
3184: NOP4
3188: PUSH
3189: NOP4
3193: PPUSH
3194: NOP4
3198: ST_TO_ADDR
3199: GO 3209
// result := false ;
3201: NOP4
3205: PUSH
3206: LD_INT 0
3208: ST_TO_ADDR
// end ; end_of_file
3209: LD_VAR 0 2
3213: RET
// on UnitDestroyed ( un ) do var shooter , cl , s , n ;
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
// begin if un in FilterAllUnits ( [ f_weapon , 91 ] ) then
3220: NOP4
3224: PUSH
3225: LD_INT 34
3227: PUSH
3228: LD_INT 91
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PPUSH
3235: NOP4
3239: IN
3240: IFFALSE 3269
// begin ArtContamination ( GetX ( un ) , GetY ( un ) , 10 ) ;
3242: NOP4
3246: PPUSH
3247: NOP4
3251: PPUSH
3252: NOP4
3256: PPUSH
3257: NOP4
3261: PPUSH
3262: LD_INT 10
3264: PPUSH
3265: NOP4
// end ; if un in attackers then
3269: NOP4
3273: PUSH
3274: NOP4
3278: IN
3279: IFFALSE 3297
// attackers := attackers diff un ;
3281: NOP4
3285: PUSH
3286: NOP4
3290: PUSH
3291: NOP4
3295: DIFF
3296: ST_TO_ADDR
// if GetSide ( un ) <> bot_side and GetSide ( un ) > 0 and un in FilterAllUnits ( [ f_type , unit_human ] ) then
3297: NOP4
3301: PPUSH
3302: NOP4
3306: PUSH
3307: NOP4
3311: NONEQUAL
3312: PUSH
3313: NOP4
3317: PPUSH
3318: NOP4
3322: PUSH
3323: LD_INT 0
3325: GREATER
3326: AND
3327: PUSH
3328: NOP4
3332: PUSH
3333: LD_INT 21
3335: PUSH
3336: LD_INT 1
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: NOP4
3347: IN
3348: AND
3349: IFFALSE 3535
// begin if respawning_time_min > 0 0$00 then
3351: NOP4
3355: PUSH
3356: LD_INT 0
3358: GREATER
3359: IFFALSE 3535
// begin s := GetSide ( un ) ;
3361: NOP4
3365: PUSH
3366: NOP4
3370: PPUSH
3371: NOP4
3375: ST_TO_ADDR
// n := GetNation ( un ) ;
3376: NOP4
3380: PUSH
3381: NOP4
3385: PPUSH
3386: NOP4
3390: ST_TO_ADDR
// cl := GetClass ( un ) ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PPUSH
3401: NOP4
3405: ST_TO_ADDR
// wait ( respawning_time_min ) ;
3406: NOP4
3410: PPUSH
3411: NOP4
// wait ( respawning_time_max - ( 0 0$10 * tick mod 10 + 1 ) ) ;
3415: NOP4
3419: PUSH
3420: LD_INT 350
3422: PUSH
3423: NOP4
3427: MUL
3428: PUSH
3429: LD_INT 10
3431: MOD
3432: PUSH
3433: LD_INT 1
3435: PLUS
3436: MINUS
3437: PPUSH
3438: NOP4
// uc_side := s ;
3442: LD_ADDR_OWVAR 20
3446: PUSH
3447: NOP4
3451: ST_TO_ADDR
// uc_nation := n ;
3452: LD_ADDR_OWVAR 21
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// PrepareHuman ( false , cl , skill_level - 2 ) ;
3462: LD_INT 0
3464: PPUSH
3465: NOP4
3469: PPUSH
3470: NOP4
3474: PUSH
3475: LD_INT 2
3477: MINUS
3478: PPUSH
3479: NOP4
// PlaceUnitArea ( CreateHuman , [ cr1 , cr3 , cr2 , cr3 ] [ ( cl mod 4 ) + 1 ] , true ) ;
3483: NOP4
3487: PPUSH
3488: NOP4
3492: PUSH
3493: NOP4
3497: PUSH
3498: NOP4
3502: PUSH
3503: NOP4
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: LIST
3512: LIST
3513: PUSH
3514: NOP4
3518: PUSH
3519: LD_INT 4
3521: MOD
3522: PUSH
3523: LD_INT 1
3525: PLUS
3526: ARRAY
3527: PPUSH
3528: LD_INT 1
3530: PPUSH
3531: NOP4
// end ; end ; end ;
3535: PPOPN 5
3537: END
// on UnitGoesToRed ( un ) do var tmp , i ;
3538: LD_INT 0
3540: PPUSH
3541: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) and GetLives ( ar_lab_main ) > 500 then
3542: NOP4
3546: PUSH
3547: LD_INT 22
3549: PUSH
3550: NOP4
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 30
3561: PUSH
3562: LD_INT 8
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: PPUSH
3573: NOP4
3577: IN
3578: PUSH
3579: NOP4
3583: PPUSH
3584: NOP4
3588: PUSH
3589: LD_INT 500
3591: GREATER
3592: AND
3593: IFFALSE 3676
// begin Wait ( 0 0$02 ) ;
3595: LD_INT 70
3597: PPUSH
3598: NOP4
// for i in FilterAllUnits ( [ [ [ f_side , bot_side ] , [ f_class , 4 ] , [ f_not , [ f_inside ] ] ] ] ) do
3602: NOP4
3606: PUSH
3607: LD_INT 22
3609: PUSH
3610: NOP4
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: PUSH
3619: LD_INT 25
3621: PUSH
3622: LD_INT 4
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: PUSH
3629: LD_INT 3
3631: PUSH
3632: LD_INT 54
3634: PUSH
3635: EMPTY
3636: LIST
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: PPUSH
3650: NOP4
3654: PUSH
3655: FOR_IN
3656: IFFALSE 3674
// ComEnterUnit ( i , ar_lab_main ) ;
3658: NOP4
3662: PPUSH
3663: NOP4
3667: PPUSH
3668: NOP4
3672: GO 3655
3674: POP
3675: POP
// end ; if GetSide ( un ) = bot_side and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
3676: NOP4
3680: PPUSH
3681: NOP4
3685: PUSH
3686: NOP4
3690: EQUAL
3691: PUSH
3692: NOP4
3696: PUSH
3697: LD_INT 33
3699: PUSH
3700: LD_INT 2
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 21
3709: PUSH
3710: LD_INT 2
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PPUSH
3721: NOP4
3725: IN
3726: AND
3727: IFFALSE 3850
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> bot_side then
3729: NOP4
3733: PUSH
3734: NOP4
3738: DIFF
3739: PPUSH
3740: NOP4
3744: PPUSH
3745: NOP4
3749: PPUSH
3750: NOP4
3754: PUSH
3755: NOP4
3759: NONEQUAL
3760: IFFALSE 3850
// begin Wait ( 0 0$1.3 ) ;
3762: LD_INT 46
3764: PPUSH
3765: NOP4
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3769: NOP4
3773: PPUSH
3774: NOP4
3778: PPUSH
3779: NOP4
3783: PPUSH
3784: NOP4
3788: PPUSH
3789: LD_INT 1
3791: PPUSH
3792: NOP4
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3796: NOP4
3800: PPUSH
3801: NOP4
3805: PPUSH
3806: NOP4
3810: PPUSH
3811: NOP4
3815: PPUSH
3816: LD_INT 1
3818: PPUSH
3819: NOP4
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3823: NOP4
3827: PPUSH
3828: NOP4
3832: PPUSH
3833: NOP4
3837: PPUSH
3838: NOP4
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: NOP4
// end ; if GetControl ( un ) = control_remote then
3850: NOP4
3854: PPUSH
3855: NOP4
3859: PUSH
3860: LD_INT 2
3862: EQUAL
3863: IFFALSE 3874
// ComUnlink ( un ) ;
3865: NOP4
3869: PPUSH
3870: NOP4
// end ;
3874: PPOPN 3
3876: END
// on VehicleConstructed ( veh , b ) do begin if GetSide ( veh ) = bot_side then
3877: NOP4
3881: PPUSH
3882: NOP4
3886: PUSH
3887: NOP4
3891: EQUAL
3892: IFFALSE 3923
// attackers := Insert ( attackers , attackers + 1 , veh ) ;
3894: NOP4
3898: PUSH
3899: NOP4
3903: PPUSH
3904: NOP4
3908: PUSH
3909: LD_INT 1
3911: PLUS
3912: PPUSH
3913: NOP4
3917: PPUSH
3918: NOP4
3922: ST_TO_ADDR
// end ;
3923: PPOPN 2
3925: END
// on LeaveBuilding ( b , un ) do var i , arm , tmp ;
3926: LD_INT 0
3928: PPUSH
3929: PPUSH
3930: PPUSH
// begin if GetSide ( b ) = bot_side and GetBType ( b ) = b_bunker then
3931: NOP4
3935: PPUSH
3936: NOP4
3940: PUSH
3941: NOP4
3945: EQUAL
3946: PUSH
3947: NOP4
3951: PPUSH
3952: NOP4
3956: PUSH
3957: LD_INT 32
3959: EQUAL
3960: AND
3961: IFFALSE 4051
// begin arm := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_btype , b_barracks ] ] ) ;
3963: NOP4
3967: PUSH
3968: LD_INT 22
3970: PUSH
3971: NOP4
3975: PUSH
3976: EMPTY
3977: LIST
3978: LIST
3979: PUSH
3980: LD_INT 30
3982: PUSH
3983: LD_INT 5
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PUSH
3990: EMPTY
3991: LIST
3992: LIST
3993: PPUSH
3994: NOP4
3998: ST_TO_ADDR
// tmp := NearestUnitToUnit ( arm , un ) ;
3999: NOP4
4003: PUSH
4004: NOP4
4008: PPUSH
4009: NOP4
4013: PPUSH
4014: NOP4
4018: ST_TO_ADDR
// if tmp then
4019: NOP4
4023: IFFALSE 4051
// begin ComEnterUnit ( un , tmp ) ;
4025: NOP4
4029: PPUSH
4030: NOP4
4034: PPUSH
4035: NOP4
// AddComChangeProfession ( un , class_mortar ) ;
4039: NOP4
4043: PPUSH
4044: LD_INT 8
4046: PPUSH
4047: NOP4
// end ; end ; end ; end_of_file
4051: PPOPN 5
4053: END
// export south_force , north_force , east_force , river_guard , apek , ar_collectors , sup_attack ; export function InitBot ; var i , j , ct , hex , side , un , veh , weapons , skill ; begin
4054: LD_INT 0
4056: PPUSH
4057: PPUSH
4058: PPUSH
4059: PPUSH
4060: PPUSH
4061: PPUSH
4062: PPUSH
4063: PPUSH
4064: PPUSH
4065: PPUSH
// side := Bot_Side ;
4066: NOP4
4070: PUSH
4071: NOP4
4075: ST_TO_ADDR
// skill := [ 4 , 6 , 8 ] [ Difficulty ] ;
4076: NOP4
4080: PUSH
4081: LD_INT 4
4083: PUSH
4084: LD_INT 6
4086: PUSH
4087: LD_INT 8
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: PUSH
4095: NOP4
4099: ARRAY
4100: ST_TO_ADDR
// weapons := [ ar_gun , ar_rocket_launcher , ar_gatling_gun , ar_flame_thrower ] ;
4101: NOP4
4105: PUSH
4106: LD_INT 27
4108: PUSH
4109: LD_INT 28
4111: PUSH
4112: LD_INT 25
4114: PUSH
4115: LD_INT 26
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: LIST
4122: LIST
4123: ST_TO_ADDR
// veh_counter := [ 6 , 7 , 8 ] [ Difficulty ] ;
4124: NOP4
4128: PUSH
4129: LD_INT 6
4131: PUSH
4132: LD_INT 7
4134: PUSH
4135: LD_INT 8
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: NOP4
4147: ARRAY
4148: ST_TO_ADDR
// ct := [ ] ;
4149: NOP4
4153: PUSH
4154: EMPTY
4155: ST_TO_ADDR
// patrols := [ ] ;
4156: NOP4
4160: PUSH
4161: EMPTY
4162: ST_TO_ADDR
// attackers := [ ] ;
4163: NOP4
4167: PUSH
4168: EMPTY
4169: ST_TO_ADDR
// river_guard := [ ] ;
4170: NOP4
4174: PUSH
4175: EMPTY
4176: ST_TO_ADDR
// apek := [ ] ;
4177: NOP4
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// ar_collectors := [ ] ;
4184: NOP4
4188: PUSH
4189: EMPTY
4190: ST_TO_ADDR
// sup_attack := [ ] ;
4191: NOP4
4195: PUSH
4196: EMPTY
4197: ST_TO_ADDR
// att_counter := 0 ;
4198: NOP4
4202: PUSH
4203: LD_INT 0
4205: ST_TO_ADDR
// south_force := Defcon ( [ 3 , 3 , 4 ] [ Difficulty ] , 118 , 130 , false ) ;
4206: NOP4
4210: PUSH
4211: LD_INT 3
4213: PUSH
4214: LD_INT 3
4216: PUSH
4217: LD_INT 4
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: LIST
4224: PUSH
4225: NOP4
4229: ARRAY
4230: PPUSH
4231: LD_INT 118
4233: PPUSH
4234: LD_INT 130
4236: PPUSH
4237: LD_INT 0
4239: PPUSH
4240: NOP4
4244: ST_TO_ADDR
// north_force := Defcon ( [ 4 , 5 , 6 ] [ Difficulty ] , 21 , 16 , false ) ;
4245: NOP4
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 5
4255: PUSH
4256: LD_INT 6
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: NOP4
4268: ARRAY
4269: PPUSH
4270: LD_INT 21
4272: PPUSH
4273: LD_INT 16
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: NOP4
4283: ST_TO_ADDR
// east_force := Defcon ( [ 4 , 5 , 5 ] [ Difficulty ] , 111 , 21 , true ) ;
4284: NOP4
4288: PUSH
4289: LD_INT 4
4291: PUSH
4292: LD_INT 5
4294: PUSH
4295: LD_INT 5
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: NOP4
4307: ARRAY
4308: PPUSH
4309: LD_INT 111
4311: PPUSH
4312: LD_INT 21
4314: PPUSH
4315: LD_INT 1
4317: PPUSH
4318: NOP4
4322: ST_TO_ADDR
// to_produce := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , 91 ] ] ;
4323: NOP4
4327: PUSH
4328: LD_INT 14
4330: PUSH
4331: LD_INT 1
4333: PUSH
4334: LD_INT 2
4336: PUSH
4337: LD_INT 27
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: PUSH
4346: LD_INT 14
4348: PUSH
4349: LD_INT 1
4351: PUSH
4352: LD_INT 2
4354: PUSH
4355: LD_INT 25
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: LIST
4362: LIST
4363: PUSH
4364: LD_INT 14
4366: PUSH
4367: LD_INT 1
4369: PUSH
4370: LD_INT 2
4372: PUSH
4373: LD_INT 28
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 14
4384: PUSH
4385: LD_INT 1
4387: PUSH
4388: LD_INT 2
4390: PUSH
4391: LD_INT 29
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 14
4402: PUSH
4403: LD_INT 1
4405: PUSH
4406: LD_INT 2
4408: PUSH
4409: LD_INT 27
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 14
4420: PUSH
4421: LD_INT 1
4423: PUSH
4424: LD_INT 2
4426: PUSH
4427: LD_INT 91
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: ST_TO_ADDR
// SetResourceType ( GetBase ( ar_base_east ) , mat_cans , 90000 ) ;
4444: NOP4
4448: PPUSH
4449: NOP4
4453: PPUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 90000
4459: PPUSH
4460: NOP4
// SetResourceType ( GetBase ( ar_base_east ) , mat_oil , 9000 ) ;
4464: NOP4
4468: PPUSH
4469: NOP4
4473: PPUSH
4474: LD_INT 2
4476: PPUSH
4477: LD_INT 9000
4479: PPUSH
4480: NOP4
// SetResourceType ( GetBase ( ar_base_east ) , mat_siberit , 3000 ) ;
4484: NOP4
4488: PPUSH
4489: NOP4
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 3000
4499: PPUSH
4500: NOP4
// SetResourceType ( GetBase ( ar_base_nort ) , mat_cans , 90000 ) ;
4504: NOP4
4508: PPUSH
4509: NOP4
4513: PPUSH
4514: LD_INT 1
4516: PPUSH
4517: LD_INT 90000
4519: PPUSH
4520: NOP4
// SetResourceType ( GetBase ( ar_base_nort ) , mat_oil , 9000 ) ;
4524: NOP4
4528: PPUSH
4529: NOP4
4533: PPUSH
4534: LD_INT 2
4536: PPUSH
4537: LD_INT 9000
4539: PPUSH
4540: NOP4
// SetResourceType ( GetBase ( ar_base_nort ) , mat_siberit , 1000 ) ;
4544: NOP4
4548: PPUSH
4549: NOP4
4553: PPUSH
4554: LD_INT 3
4556: PPUSH
4557: LD_INT 1000
4559: PPUSH
4560: NOP4
// SetResourceType ( GetBase ( ar_base_sout ) , mat_cans , [ 2000 , 1500 , 1000 ] [ Difficulty ] ) ;
4564: NOP4
4568: PPUSH
4569: NOP4
4573: PPUSH
4574: LD_INT 1
4576: PPUSH
4577: LD_INT 2000
4579: PUSH
4580: LD_INT 1500
4582: PUSH
4583: LD_INT 1000
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: LIST
4590: PUSH
4591: NOP4
4595: ARRAY
4596: PPUSH
4597: NOP4
// SetResourceType ( GetBase ( ar_base_sout ) , mat_oil , 1000 ) ;
4601: NOP4
4605: PPUSH
4606: NOP4
4610: PPUSH
4611: LD_INT 2
4613: PPUSH
4614: LD_INT 1000
4616: PPUSH
4617: NOP4
// SetResourceType ( GetBase ( ar_base_sout ) , mat_siberit , 100 ) ;
4621: NOP4
4625: PPUSH
4626: NOP4
4630: PPUSH
4631: LD_INT 3
4633: PPUSH
4634: LD_INT 100
4636: PPUSH
4637: NOP4
// if Difficulty > 1 then
4641: NOP4
4645: PUSH
4646: LD_INT 1
4648: GREATER
4649: IFFALSE 4666
// SetTech ( 5 , side , state_researched ) ;
4651: LD_INT 5
4653: PPUSH
4654: NOP4
4658: PPUSH
4659: LD_INT 2
4661: PPUSH
4662: NOP4
// SetTech ( tech_weap1 , side , state_researched ) ;
4666: LD_INT 51
4668: PPUSH
4669: NOP4
4673: PPUSH
4674: LD_INT 2
4676: PPUSH
4677: NOP4
// SetTech ( tech_weap2 , side , state_researched ) ;
4681: LD_INT 52
4683: PPUSH
4684: NOP4
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: NOP4
// SetTech ( tech_weap3 , side , state_researched ) ;
4696: LD_INT 53
4698: PPUSH
4699: NOP4
4703: PPUSH
4704: LD_INT 2
4706: PPUSH
4707: NOP4
// SetTech ( tech_opto1 , side , state_researched ) ;
4711: LD_INT 60
4713: PPUSH
4714: NOP4
4718: PPUSH
4719: LD_INT 2
4721: PPUSH
4722: NOP4
// SetTech ( tech_opto2 , side , state_researched ) ;
4726: LD_INT 61
4728: PPUSH
4729: NOP4
4733: PPUSH
4734: LD_INT 2
4736: PPUSH
4737: NOP4
// SetTech ( tech_opto3 , side , state_researched ) ;
4741: LD_INT 62
4743: PPUSH
4744: NOP4
4748: PPUSH
4749: LD_INT 2
4751: PPUSH
4752: NOP4
// SetTech ( tech_bio1 , side , state_researched ) ;
4756: LD_INT 66
4758: PPUSH
4759: NOP4
4763: PPUSH
4764: LD_INT 2
4766: PPUSH
4767: NOP4
// if Difficulty > 1 then
4771: NOP4
4775: PUSH
4776: LD_INT 1
4778: GREATER
4779: IFFALSE 4796
// SetTech ( tech_bio2 , side , state_researched ) ;
4781: LD_INT 67
4783: PPUSH
4784: NOP4
4788: PPUSH
4789: LD_INT 2
4791: PPUSH
4792: NOP4
// if Difficulty > 2 then
4796: NOP4
4800: PUSH
4801: LD_INT 2
4803: GREATER
4804: IFFALSE 4821
// SetTech ( tech_bio3 , side , state_researched ) ;
4806: LD_INT 68
4808: PPUSH
4809: NOP4
4813: PPUSH
4814: LD_INT 2
4816: PPUSH
4817: NOP4
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4821: NOP4
4825: PUSH
4826: LD_INT 22
4828: PUSH
4829: NOP4
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 21
4840: PUSH
4841: LD_INT 3
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PPUSH
4852: NOP4
4856: PUSH
4857: FOR_IN
4858: IFFALSE 4891
// SetBLevel ( i , [ 6 , 8 , 10 ] [ Difficulty ] ) ;
4860: NOP4
4864: PPUSH
4865: LD_INT 6
4867: PUSH
4868: LD_INT 8
4870: PUSH
4871: LD_INT 10
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: PUSH
4879: NOP4
4883: ARRAY
4884: PPUSH
4885: NOP4
4889: GO 4857
4891: POP
4892: POP
// PlaceMines ( mine_west_zone , [ 5 , 7 , 9 ] [ Difficulty ] ) ;
4893: NOP4
4897: PPUSH
4898: LD_INT 5
4900: PUSH
4901: LD_INT 7
4903: PUSH
4904: LD_INT 9
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: PUSH
4912: NOP4
4916: ARRAY
4917: PPUSH
4918: NOP4
// PlaceMines ( mine_east_zone , [ 20 , 25 , 30 ] [ Difficulty ] ) ;
4922: NOP4
4926: PPUSH
4927: LD_INT 20
4929: PUSH
4930: LD_INT 25
4932: PUSH
4933: LD_INT 30
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: LIST
4940: PUSH
4941: NOP4
4945: ARRAY
4946: PPUSH
4947: NOP4
// PlaceMines ( mine_center_zone , [ 6 , 8 , 9 ] [ Difficulty ] ) ;
4951: NOP4
4955: PPUSH
4956: LD_INT 6
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: LD_INT 9
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: NOP4
4974: ARRAY
4975: PPUSH
4976: NOP4
// PlaceMines ( mine_pass_zone , [ 4 , 6 , 9 ] [ Difficulty ] ) ;
4980: NOP4
4984: PPUSH
4985: LD_INT 4
4987: PUSH
4988: LD_INT 6
4990: PUSH
4991: LD_INT 9
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: LIST
4998: PUSH
4999: NOP4
5003: ARRAY
5004: PPUSH
5005: NOP4
// PlaceMines ( mine_road_zone , [ 2 , 5 , 8 ] [ Difficulty ] ) ;
5009: NOP4
5013: PPUSH
5014: LD_INT 2
5016: PUSH
5017: LD_INT 5
5019: PUSH
5020: LD_INT 8
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: LIST
5027: PUSH
5028: NOP4
5032: ARRAY
5033: PPUSH
5034: NOP4
// PlaceMines ( mine_southpass_zone , [ 2 , 4 , 6 ] [ Difficulty ] ) ;
5038: NOP4
5042: PPUSH
5043: LD_INT 2
5045: PUSH
5046: LD_INT 4
5048: PUSH
5049: LD_INT 6
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: LIST
5056: PUSH
5057: NOP4
5061: ARRAY
5062: PPUSH
5063: NOP4
// for i = 1 to [ 8 , 11 , 14 ] [ Difficulty ] do
5067: NOP4
5071: PUSH
5072: DOUBLE
5073: LD_INT 1
5075: DEC
5076: ST_TO_ADDR
5077: LD_INT 8
5079: PUSH
5080: LD_INT 11
5082: PUSH
5083: LD_INT 14
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: PUSH
5091: NOP4
5095: ARRAY
5096: PUSH
5097: FOR_TO
5098: IFFALSE 5273
// begin hex := RandHexXYR ( 134 , 73 , 10 , false ) ;
5100: NOP4
5104: PUSH
5105: LD_INT 134
5107: PPUSH
5108: LD_INT 73
5110: PPUSH
5111: LD_INT 10
5113: PPUSH
5114: LD_INT 0
5116: PPUSH
5117: NOP4
5121: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 and not MineAtPos ( hex [ 1 ] , hex [ 2 ] ) then
5122: NOP4
5126: PUSH
5127: LD_INT 1
5129: ARRAY
5130: PPUSH
5131: NOP4
5135: PUSH
5136: LD_INT 2
5138: ARRAY
5139: PPUSH
5140: NOP4
5144: PUSH
5145: LD_INT 0
5147: EQUAL
5148: PUSH
5149: NOP4
5153: PUSH
5154: LD_INT 1
5156: ARRAY
5157: PPUSH
5158: NOP4
5162: PUSH
5163: LD_INT 2
5165: ARRAY
5166: PPUSH
5167: NOP4
5171: NOT
5172: AND
5173: IFFALSE 5271
// begin mines_list := Insert ( mines_list , mines_list + 1 , hex [ 1 ] ) ;
5175: NOP4
5179: PUSH
5180: NOP4
5184: PPUSH
5185: NOP4
5189: PUSH
5190: LD_INT 1
5192: PLUS
5193: PPUSH
5194: NOP4
5198: PUSH
5199: LD_INT 1
5201: ARRAY
5202: PPUSH
5203: NOP4
5207: ST_TO_ADDR
// mines_list := Insert ( mines_list , mines_list + 1 , hex [ 2 ] ) ;
5208: NOP4
5212: PUSH
5213: NOP4
5217: PPUSH
5218: NOP4
5222: PUSH
5223: LD_INT 1
5225: PLUS
5226: PPUSH
5227: NOP4
5231: PUSH
5232: LD_INT 2
5234: ARRAY
5235: PPUSH
5236: NOP4
5240: ST_TO_ADDR
// PlaceMine ( hex [ 1 ] , hex [ 2 ] , bot_side , 0 ) ;
5241: NOP4
5245: PUSH
5246: LD_INT 1
5248: ARRAY
5249: PPUSH
5250: NOP4
5254: PUSH
5255: LD_INT 2
5257: ARRAY
5258: PPUSH
5259: NOP4
5263: PPUSH
5264: LD_INT 0
5266: PPUSH
5267: NOP4
// end ; end ;
5271: GO 5097
5273: POP
5274: POP
// for i = 1 to 12 do
5275: NOP4
5279: PUSH
5280: DOUBLE
5281: LD_INT 1
5283: DEC
5284: ST_TO_ADDR
5285: LD_INT 12
5287: PUSH
5288: FOR_TO
5289: IFFALSE 5347
// begin uc_nation := 0 ;
5291: LD_ADDR_OWVAR 21
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 2 ) ;
5299: LD_INT 0
5301: PPUSH
5302: LD_INT 17
5304: PPUSH
5305: LD_INT 2
5307: PPUSH
5308: NOP4
// un := CreateHuman ;
5312: NOP4
5316: PUSH
5317: NOP4
5321: ST_TO_ADDR
// apek := Insert ( apek , 1 , un ) ;
5322: NOP4
5326: PUSH
5327: NOP4
5331: PPUSH
5332: LD_INT 1
5334: PPUSH
5335: NOP4
5339: PPUSH
5340: NOP4
5344: ST_TO_ADDR
// end ;
5345: GO 5288
5347: POP
5348: POP
// uc_nation := 2 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 2
5356: ST_TO_ADDR
// if Difficulty > 1 then
5357: NOP4
5361: PUSH
5362: LD_INT 1
5364: GREATER
5365: IFFALSE 5396
// begin bc_type := b_bunker ;
5367: LD_ADDR_OWVAR 42
5371: PUSH
5372: LD_INT 32
5374: ST_TO_ADDR
// bc_level := 5 ;
5375: LD_ADDR_OWVAR 43
5379: PUSH
5380: LD_INT 5
5382: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 99 , 131 , 1 ) ;
5383: LD_INT 99
5385: PPUSH
5386: LD_INT 131
5388: PPUSH
5389: LD_INT 1
5391: PPUSH
5392: NOP4
// end ; for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
5396: NOP4
5400: PUSH
5401: LD_INT 22
5403: PUSH
5404: NOP4
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: PUSH
5413: LD_INT 30
5415: PUSH
5416: LD_INT 32
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: NOP4
5431: PUSH
5432: FOR_IN
5433: IFFALSE 5465
// PlaceWeaponTurret ( i , weapons [ Rand ( 1 , weapons ) ] ) ;
5435: NOP4
5439: PPUSH
5440: NOP4
5444: PUSH
5445: LD_INT 1
5447: PPUSH
5448: NOP4
5452: PPUSH
5453: NOP4
5457: ARRAY
5458: PPUSH
5459: NOP4
5463: GO 5432
5465: POP
5466: POP
// uc_side := side ;
5467: LD_ADDR_OWVAR 20
5471: PUSH
5472: NOP4
5476: ST_TO_ADDR
// uc_nation := 2 ;
5477: LD_ADDR_OWVAR 21
5481: PUSH
5482: LD_INT 2
5484: ST_TO_ADDR
// for i = 1 to 1 + Difficulty do
5485: NOP4
5489: PUSH
5490: DOUBLE
5491: LD_INT 1
5493: DEC
5494: ST_TO_ADDR
5495: LD_INT 1
5497: PUSH
5498: NOP4
5502: PLUS
5503: PUSH
5504: FOR_TO
5505: IFFALSE 5597
// begin vc_chassis := ar_half_tracked ;
5507: LD_ADDR_OWVAR 37
5511: PUSH
5512: LD_INT 14
5514: ST_TO_ADDR
// vc_engine := engine_combustion ;
5515: LD_ADDR_OWVAR 39
5519: PUSH
5520: LD_INT 1
5522: ST_TO_ADDR
// vc_control := control_manual ;
5523: LD_ADDR_OWVAR 38
5527: PUSH
5528: LD_INT 1
5530: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5531: LD_ADDR_OWVAR 40
5535: PUSH
5536: LD_INT 31
5538: ST_TO_ADDR
// veh := CreateVehicle ;
5539: NOP4
5543: PUSH
5544: NOP4
5548: ST_TO_ADDR
// PlaceUnitArea ( veh , ct_area , false ) ;
5549: NOP4
5553: PPUSH
5554: NOP4
5558: PPUSH
5559: LD_INT 0
5561: PPUSH
5562: NOP4
// PrepareHuman ( false , 3 , skill ) ;
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 3
5571: PPUSH
5572: NOP4
5576: PPUSH
5577: NOP4
// PlaceHumanInUnit ( CreateHuman , veh ) ;
5581: NOP4
5585: PPUSH
5586: NOP4
5590: PPUSH
5591: NOP4
// end ;
5595: GO 5504
5597: POP
5598: POP
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
5599: NOP4
5603: PUSH
5604: LD_INT 22
5606: PUSH
5607: NOP4
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: LD_INT 30
5618: PUSH
5619: LD_INT 32
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: PPUSH
5630: NOP4
5634: PUSH
5635: FOR_IN
5636: IFFALSE 5669
// begin PrepareHuman ( false , 1 , skill ) ;
5638: LD_INT 0
5640: PPUSH
5641: LD_INT 1
5643: PPUSH
5644: NOP4
5648: PPUSH
5649: NOP4
// PlaceHumanInUnit ( CreateHuman , i ) ;
5653: NOP4
5657: PPUSH
5658: NOP4
5662: PPUSH
5663: NOP4
// end ;
5667: GO 5635
5669: POP
5670: POP
// for i = 1 to 4 do
5671: NOP4
5675: PUSH
5676: DOUBLE
5677: LD_INT 1
5679: DEC
5680: ST_TO_ADDR
5681: LD_INT 4
5683: PUSH
5684: FOR_TO
5685: IFFALSE 5718
// begin PrepareHuman ( false , 2 , skill ) ;
5687: LD_INT 0
5689: PPUSH
5690: LD_INT 2
5692: PPUSH
5693: NOP4
5697: PPUSH
5698: NOP4
// PlaceHumanInUnit ( CreateHuman , ar_base_east ) ;
5702: NOP4
5706: PPUSH
5707: NOP4
5711: PPUSH
5712: NOP4
// end ;
5716: GO 5684
5718: POP
5719: POP
// for i = 1 to 6 do
5720: NOP4
5724: PUSH
5725: DOUBLE
5726: LD_INT 1
5728: DEC
5729: ST_TO_ADDR
5730: LD_INT 6
5732: PUSH
5733: FOR_TO
5734: IFFALSE 5767
// begin PrepareHuman ( false , 3 , skill ) ;
5736: LD_INT 0
5738: PPUSH
5739: LD_INT 3
5741: PPUSH
5742: NOP4
5746: PPUSH
5747: NOP4
// PlaceHumanInUnit ( CreateHuman , ar_fac_east ) ;
5751: NOP4
5755: PPUSH
5756: NOP4
5760: PPUSH
5761: NOP4
// end ;
5765: GO 5733
5767: POP
5768: POP
// for i = 1 to 4 do
5769: NOP4
5773: PUSH
5774: DOUBLE
5775: LD_INT 1
5777: DEC
5778: ST_TO_ADDR
5779: LD_INT 4
5781: PUSH
5782: FOR_TO
5783: IFFALSE 5816
// begin PrepareHuman ( false , 3 , skill ) ;
5785: LD_INT 0
5787: PPUSH
5788: LD_INT 3
5790: PPUSH
5791: NOP4
5795: PPUSH
5796: NOP4
// PlaceHumanInUnit ( CreateHuman , ar_fac_north ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PPUSH
5810: NOP4
// end ;
5814: GO 5782
5816: POP
5817: POP
// for i = 1 to 6 do
5818: NOP4
5822: PUSH
5823: DOUBLE
5824: LD_INT 1
5826: DEC
5827: ST_TO_ADDR
5828: LD_INT 6
5830: PUSH
5831: FOR_TO
5832: IFFALSE 5928
// begin PrepareHuman ( false , 4 , skill ) ;
5834: LD_INT 0
5836: PPUSH
5837: LD_INT 4
5839: PPUSH
5840: NOP4
5844: PPUSH
5845: NOP4
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] ) ;
5849: NOP4
5853: PPUSH
5854: LD_INT 30
5856: PUSH
5857: LD_INT 8
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PPUSH
5864: NOP4
5868: PUSH
5869: NOP4
5873: PUSH
5874: LD_INT 2
5876: MOD
5877: PUSH
5878: LD_INT 1
5880: PLUS
5881: ARRAY
5882: PPUSH
5883: NOP4
// SetSpecResearch ( FilterAllUnits ( [ f_btype , b_lab_full ] ) [ ( i mod 2 ) + 1 ] , 2000 , false ) ;
5887: LD_INT 30
5889: PUSH
5890: LD_INT 8
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: PPUSH
5897: NOP4
5901: PUSH
5902: NOP4
5906: PUSH
5907: LD_INT 2
5909: MOD
5910: PUSH
5911: LD_INT 1
5913: PLUS
5914: ARRAY
5915: PPUSH
5916: LD_INT 2000
5918: PPUSH
5919: LD_INT 0
5921: PPUSH
5922: NOP4
// end ;
5926: GO 5831
5928: POP
5929: POP
// PrepareHuman ( false , class_sniper , skill ) ;
5930: LD_INT 0
5932: PPUSH
5933: LD_INT 5
5935: PPUSH
5936: NOP4
5940: PPUSH
5941: NOP4
// un := CreateHuman ;
5945: NOP4
5949: PUSH
5950: NOP4
5954: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5955: NOP4
5959: PPUSH
5960: LD_INT 3
5962: PPUSH
5963: NOP4
// PlaceHumanInUnit ( un , bun1 ) ;
5967: NOP4
5971: PPUSH
5972: NOP4
5976: PPUSH
5977: NOP4
// for i = 1 to 4 do
5981: NOP4
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 4
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6051
// begin uc_nation := 0 ;
5997: LD_ADDR_OWVAR 21
6001: PUSH
6002: LD_INT 0
6004: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
6005: LD_INT 0
6007: PPUSH
6008: LD_INT 16
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: NOP4
// un := CreateHuman ;
6018: NOP4
6022: PUSH
6023: NOP4
6027: ST_TO_ADDR
// PlaceUnitXYR ( un , 116 , 128 , 8 , false ) ;
6028: NOP4
6032: PPUSH
6033: LD_INT 116
6035: PPUSH
6036: LD_INT 128
6038: PPUSH
6039: LD_INT 8
6041: PPUSH
6042: LD_INT 0
6044: PPUSH
6045: NOP4
// end ;
6049: GO 5994
6051: POP
6052: POP
// for i = 1 to 3 do
6053: NOP4
6057: PUSH
6058: DOUBLE
6059: LD_INT 1
6061: DEC
6062: ST_TO_ADDR
6063: LD_INT 3
6065: PUSH
6066: FOR_TO
6067: IFFALSE 6123
// begin uc_nation := 0 ;
6069: LD_ADDR_OWVAR 21
6073: PUSH
6074: LD_INT 0
6076: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
6077: LD_INT 0
6079: PPUSH
6080: LD_INT 16
6082: PPUSH
6083: LD_INT 1
6085: PPUSH
6086: NOP4
// un := CreateHuman ;
6090: NOP4
6094: PUSH
6095: NOP4
6099: ST_TO_ADDR
// PlaceUnitXYR ( un , 23 , 19 , 8 , false ) ;
6100: NOP4
6104: PPUSH
6105: LD_INT 23
6107: PPUSH
6108: LD_INT 19
6110: PPUSH
6111: LD_INT 8
6113: PPUSH
6114: LD_INT 0
6116: PPUSH
6117: NOP4
// end ;
6121: GO 6066
6123: POP
6124: POP
// for i = 1 to 3 do
6125: NOP4
6129: PUSH
6130: DOUBLE
6131: LD_INT 1
6133: DEC
6134: ST_TO_ADDR
6135: LD_INT 3
6137: PUSH
6138: FOR_TO
6139: IFFALSE 6195
// begin uc_nation := 0 ;
6141: LD_ADDR_OWVAR 21
6145: PUSH
6146: LD_INT 0
6148: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
6149: LD_INT 0
6151: PPUSH
6152: LD_INT 16
6154: PPUSH
6155: LD_INT 1
6157: PPUSH
6158: NOP4
// un := CreateHuman ;
6162: NOP4
6166: PUSH
6167: NOP4
6171: ST_TO_ADDR
// PlaceUnitXYR ( un , 154 , 89 , 8 , false ) ;
6172: NOP4
6176: PPUSH
6177: LD_INT 154
6179: PPUSH
6180: LD_INT 89
6182: PPUSH
6183: LD_INT 8
6185: PPUSH
6186: LD_INT 0
6188: PPUSH
6189: NOP4
// end ;
6193: GO 6138
6195: POP
6196: POP
// for i = 1 to 3 do
6197: NOP4
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_INT 3
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6283
// begin uc_nation := 0 ;
6213: LD_ADDR_OWVAR 21
6217: PUSH
6218: LD_INT 0
6220: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_engineer , 1 ) ;
6221: LD_INT 0
6223: PPUSH
6224: LD_INT 16
6226: PPUSH
6227: LD_INT 1
6229: PPUSH
6230: NOP4
// un := CreateHuman ;
6234: NOP4
6238: PUSH
6239: NOP4
6243: ST_TO_ADDR
// ar_collectors := ar_collectors ^ un ;
6244: NOP4
6248: PUSH
6249: NOP4
6253: PUSH
6254: NOP4
6258: ADD
6259: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 17 , 8 , false ) ;
6260: NOP4
6264: PPUSH
6265: LD_INT 112
6267: PPUSH
6268: LD_INT 17
6270: PPUSH
6271: LD_INT 8
6273: PPUSH
6274: LD_INT 0
6276: PPUSH
6277: NOP4
// end ;
6281: GO 6210
6283: POP
6284: POP
// for i = 1 to 3 * Difficulty do
6285: NOP4
6289: PUSH
6290: DOUBLE
6291: LD_INT 1
6293: DEC
6294: ST_TO_ADDR
6295: LD_INT 3
6297: PUSH
6298: NOP4
6302: MUL
6303: PUSH
6304: FOR_TO
6305: IFFALSE 6381
// begin uc_nation := 0 ;
6307: LD_ADDR_OWVAR 21
6311: PUSH
6312: LD_INT 0
6314: ST_TO_ADDR
// PrepareHuman ( false , class_apeman_kamikaze , 3 ) ;
6315: LD_INT 0
6317: PPUSH
6318: LD_INT 17
6320: PPUSH
6321: LD_INT 3
6323: PPUSH
6324: NOP4
// hc_attr := [ 11 , 13 ] ;
6328: LD_ADDR_OWVAR 29
6332: PUSH
6333: LD_INT 11
6335: PUSH
6336: LD_INT 13
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: ST_TO_ADDR
// un := CreateHuman ;
6343: NOP4
6347: PUSH
6348: NOP4
6352: ST_TO_ADDR
// PlaceUnitArea ( un , ap1 , false ) ;
6353: NOP4
6357: PPUSH
6358: NOP4
6362: PPUSH
6363: LD_INT 0
6365: PPUSH
6366: NOP4
// ComHold ( un ) ;
6370: NOP4
6374: PPUSH
6375: NOP4
// end ;
6379: GO 6304
6381: POP
6382: POP
// for i = 1 to Difficulty do
6383: NOP4
6387: PUSH
6388: DOUBLE
6389: LD_INT 1
6391: DEC
6392: ST_TO_ADDR
6393: NOP4
6397: PUSH
6398: FOR_TO
6399: IFFALSE 6493
// begin uc_nation := nation_arabian ;
6401: LD_ADDR_OWVAR 21
6405: PUSH
6406: LD_INT 2
6408: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
6409: LD_ADDR_OWVAR 37
6413: PUSH
6414: LD_INT 11
6416: ST_TO_ADDR
// vc_engine := engine_solar ;
6417: LD_ADDR_OWVAR 39
6421: PUSH
6422: LD_INT 2
6424: ST_TO_ADDR
// vc_control := control_remote ;
6425: LD_ADDR_OWVAR 38
6429: PUSH
6430: LD_INT 2
6432: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
6433: LD_ADDR_OWVAR 40
6437: PUSH
6438: LD_INT 24
6440: ST_TO_ADDR
// veh := CreateVehicle ;
6441: NOP4
6445: PUSH
6446: NOP4
6450: ST_TO_ADDR
// river_guard := Insert ( river_guard , 1 , veh ) ;
6451: NOP4
6455: PUSH
6456: NOP4
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: NOP4
6468: PPUSH
6469: NOP4
6473: ST_TO_ADDR
// PlaceUnitArea ( veh , river_spawn , false ) ;
6474: NOP4
6478: PPUSH
6479: NOP4
6483: PPUSH
6484: LD_INT 0
6486: PPUSH
6487: NOP4
// end ;
6491: GO 6398
6493: POP
6494: POP
// for i = 1 to Difficulty do
6495: NOP4
6499: PUSH
6500: DOUBLE
6501: LD_INT 1
6503: DEC
6504: ST_TO_ADDR
6505: NOP4
6509: PUSH
6510: FOR_TO
6511: IFFALSE 6857
// begin uc_nation := nation_arabian ;
6513: LD_ADDR_OWVAR 21
6517: PUSH
6518: LD_INT 2
6520: ST_TO_ADDR
// for j = 1 to 5 do
6521: NOP4
6525: PUSH
6526: DOUBLE
6527: LD_INT 1
6529: DEC
6530: ST_TO_ADDR
6531: LD_INT 5
6533: PUSH
6534: FOR_TO
6535: IFFALSE 6604
// begin PrepareHuman ( false , class_mortar , skill ) ;
6537: LD_INT 0
6539: PPUSH
6540: LD_INT 8
6542: PPUSH
6543: NOP4
6547: PPUSH
6548: NOP4
// un := CreateHuman ;
6552: NOP4
6556: PUSH
6557: NOP4
6561: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 54 , 102 ] ) ;
6562: NOP4
6566: PUSH
6567: NOP4
6571: PPUSH
6572: NOP4
6576: PUSH
6577: LD_INT 1
6579: PLUS
6580: PPUSH
6581: NOP4
6585: PUSH
6586: LD_INT 54
6588: PUSH
6589: LD_INT 102
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: LIST
6596: PPUSH
6597: NOP4
6601: ST_TO_ADDR
// end ;
6602: GO 6534
6604: POP
6605: POP
// for j = 1 to 3 do
6606: NOP4
6610: PUSH
6611: DOUBLE
6612: LD_INT 1
6614: DEC
6615: ST_TO_ADDR
6616: LD_INT 3
6618: PUSH
6619: FOR_TO
6620: IFFALSE 6768
// begin uc_nation := 0 ;
6622: LD_ADDR_OWVAR 21
6626: PUSH
6627: LD_INT 0
6629: ST_TO_ADDR
// vc_chassis := 15 ;
6630: LD_ADDR_OWVAR 37
6634: PUSH
6635: LD_INT 15
6637: ST_TO_ADDR
// vc_control := control_rider ;
6638: LD_ADDR_OWVAR 38
6642: PUSH
6643: LD_INT 4
6645: ST_TO_ADDR
// un := CreateVehicle ;
6646: NOP4
6650: PUSH
6651: NOP4
6655: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 188 , 145 ] ) ;
6656: NOP4
6660: PUSH
6661: NOP4
6665: PPUSH
6666: NOP4
6670: PUSH
6671: LD_INT 1
6673: PLUS
6674: PPUSH
6675: NOP4
6679: PUSH
6680: LD_INT 188
6682: PUSH
6683: LD_INT 145
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: LIST
6690: PPUSH
6691: NOP4
6695: ST_TO_ADDR
// uc_nation := nation_arabian ;
6696: LD_ADDR_OWVAR 21
6700: PUSH
6701: LD_INT 2
6703: ST_TO_ADDR
// PrepareHuman ( false , class_desert_warior , skill ) ;
6704: LD_INT 0
6706: PPUSH
6707: LD_INT 11
6709: PPUSH
6710: NOP4
6714: PPUSH
6715: NOP4
// un := CreateHuman ;
6719: NOP4
6723: PUSH
6724: NOP4
6728: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , - 1 ] ) ;
6729: NOP4
6733: PUSH
6734: NOP4
6738: PPUSH
6739: NOP4
6743: PUSH
6744: LD_INT 1
6746: PLUS
6747: PPUSH
6748: NOP4
6752: PUSH
6753: LD_INT 1
6755: NEG
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: PPUSH
6761: NOP4
6765: ST_TO_ADDR
// end ;
6766: GO 6619
6768: POP
6769: POP
// for j = 1 to 3 do
6770: NOP4
6774: PUSH
6775: DOUBLE
6776: LD_INT 1
6778: DEC
6779: ST_TO_ADDR
6780: LD_INT 3
6782: PUSH
6783: FOR_TO
6784: IFFALSE 6853
// begin PrepareHuman ( false , class_mortar , skill ) ;
6786: LD_INT 0
6788: PPUSH
6789: LD_INT 8
6791: PPUSH
6792: NOP4
6796: PPUSH
6797: NOP4
// un := CreateHuman ;
6801: NOP4
6805: PUSH
6806: NOP4
6810: ST_TO_ADDR
// sup_attack := Insert ( sup_attack , sup_attack + 1 , [ un , 188 , 145 ] ) ;
6811: NOP4
6815: PUSH
6816: NOP4
6820: PPUSH
6821: NOP4
6825: PUSH
6826: LD_INT 1
6828: PLUS
6829: PPUSH
6830: NOP4
6834: PUSH
6835: LD_INT 188
6837: PUSH
6838: LD_INT 145
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: PPUSH
6846: NOP4
6850: ST_TO_ADDR
// end ;
6851: GO 6783
6853: POP
6854: POP
// end ;
6855: GO 6510
6857: POP
6858: POP
// end ;
6859: LD_VAR 0 1
6863: RET
// export function Defcon ( n , x , y , type ) ; var i , un , veh , list ; begin
6864: LD_INT 0
6866: PPUSH
6867: PPUSH
6868: PPUSH
6869: PPUSH
6870: PPUSH
// list := [ ] ;
6871: NOP4
6875: PUSH
6876: EMPTY
6877: ST_TO_ADDR
// uc_side := bot_side ;
6878: LD_ADDR_OWVAR 20
6882: PUSH
6883: NOP4
6887: ST_TO_ADDR
// uc_nation := nation_arabian ;
6888: LD_ADDR_OWVAR 21
6892: PUSH
6893: LD_INT 2
6895: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6896: LD_ADDR_OWVAR 37
6900: PUSH
6901: LD_INT 14
6903: ST_TO_ADDR
// vc_engine := engine_siberite ;
6904: LD_ADDR_OWVAR 39
6908: PUSH
6909: LD_INT 3
6911: ST_TO_ADDR
// if type then
6912: NOP4
6916: IFFALSE 6928
// vc_control := control_manual else
6918: LD_ADDR_OWVAR 38
6922: PUSH
6923: LD_INT 1
6925: ST_TO_ADDR
6926: GO 6936
// vc_control := control_apeman ;
6928: LD_ADDR_OWVAR 38
6932: PUSH
6933: LD_INT 5
6935: ST_TO_ADDR
// for i = 1 to n do
6936: NOP4
6940: PUSH
6941: DOUBLE
6942: LD_INT 1
6944: DEC
6945: ST_TO_ADDR
6946: NOP4
6950: PUSH
6951: FOR_TO
6952: IFFALSE 7095
// begin vc_weapon := [ ar_rocket_launcher , ar_flame_thrower , ar_gun ] [ Rand ( 1 , 3 ) ] ;
6954: LD_ADDR_OWVAR 40
6958: PUSH
6959: LD_INT 28
6961: PUSH
6962: LD_INT 26
6964: PUSH
6965: LD_INT 27
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: LIST
6972: PUSH
6973: LD_INT 1
6975: PPUSH
6976: LD_INT 3
6978: PPUSH
6979: NOP4
6983: ARRAY
6984: ST_TO_ADDR
// veh := CreateVehicle ;
6985: NOP4
6989: PUSH
6990: NOP4
6994: ST_TO_ADDR
// PlaceUnitXYR ( veh , x , y , 13 , false ) ;
6995: NOP4
6999: PPUSH
7000: NOP4
7004: PPUSH
7005: NOP4
7009: PPUSH
7010: LD_INT 13
7012: PPUSH
7013: LD_INT 0
7015: PPUSH
7016: NOP4
// if type then
7020: NOP4
7024: IFFALSE 7070
// begin PrepareHuman ( false , 3 , [ 4 , 6 , 8 ] [ Difficulty ] ) ;
7026: LD_INT 0
7028: PPUSH
7029: LD_INT 3
7031: PPUSH
7032: LD_INT 4
7034: PUSH
7035: LD_INT 6
7037: PUSH
7038: LD_INT 8
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: LIST
7045: PUSH
7046: NOP4
7050: ARRAY
7051: PPUSH
7052: NOP4
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7056: NOP4
7060: PPUSH
7061: NOP4
7065: PPUSH
7066: NOP4
// end ; list := Insert ( list , 1 , veh ) ;
7070: NOP4
7074: PUSH
7075: NOP4
7079: PPUSH
7080: LD_INT 1
7082: PPUSH
7083: NOP4
7087: PPUSH
7088: NOP4
7092: ST_TO_ADDR
// end ;
7093: GO 6951
7095: POP
7096: POP
// result := list ;
7097: NOP4
7101: PUSH
7102: NOP4
7106: ST_TO_ADDR
// end ;
7107: LD_VAR 0 5
7111: RET
// every 0 0$03 trigger FilterUnitsInArea ( pass_guard , [ f_enemy , bot_side ] ) do var i ;
7112: NOP4
7116: PPUSH
7117: LD_INT 81
7119: PUSH
7120: NOP4
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PPUSH
7129: NOP4
7133: IFFALSE 7211
7135: GO 7137
7137: DISABLE
7138: LD_INT 0
7140: PPUSH
// begin if not north_force then
7141: NOP4
7145: NOT
7146: IFFALSE 7150
// exit ;
7148: GO 7211
// for i = 1 to north_force do
7150: NOP4
7154: PUSH
7155: DOUBLE
7156: LD_INT 1
7158: DEC
7159: ST_TO_ADDR
7160: NOP4
7164: PUSH
7165: FOR_TO
7166: IFFALSE 7191
// begin ComMoveXY ( north_force [ i ] , 38 , 57 ) ;
7168: NOP4
7172: PUSH
7173: NOP4
7177: ARRAY
7178: PPUSH
7179: LD_INT 38
7181: PPUSH
7182: LD_INT 57
7184: PPUSH
7185: NOP4
// end ;
7189: GO 7165
7191: POP
7192: POP
// PlaceSeeing ( 54 , 69 , bot_side , 10 ) ;
7193: LD_INT 54
7195: PPUSH
7196: LD_INT 69
7198: PPUSH
7199: NOP4
7203: PPUSH
7204: LD_INT 10
7206: PPUSH
7207: NOP4
// end ;
7211: PPOPN 1
7213: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge_protect , [ f_enemy , bot_side ] ) do var i ;
7214: NOP4
7218: PPUSH
7219: LD_INT 81
7221: PUSH
7222: NOP4
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PPUSH
7231: NOP4
7235: IFFALSE 7295
7237: GO 7239
7239: DISABLE
7240: LD_INT 0
7242: PPUSH
// begin if not south_force then
7243: NOP4
7247: NOT
7248: IFFALSE 7252
// exit ;
7250: GO 7295
// for i = 1 to south_force do
7252: NOP4
7256: PUSH
7257: DOUBLE
7258: LD_INT 1
7260: DEC
7261: ST_TO_ADDR
7262: NOP4
7266: PUSH
7267: FOR_TO
7268: IFFALSE 7293
// begin ComMoveXY ( south_force [ i ] , 157 , 140 ) ;
7270: NOP4
7274: PUSH
7275: NOP4
7279: ARRAY
7280: PPUSH
7281: LD_INT 157
7283: PPUSH
7284: LD_INT 140
7286: PPUSH
7287: NOP4
// end ;
7291: GO 7267
7293: POP
7294: POP
// end ;
7295: PPOPN 1
7297: END
// every 11 11$00 trigger ar_fac_east and FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_btype , b_warehouse ] ] ) do var i , tmp , p , fac ;
7298: NOP4
7302: PUSH
7303: LD_INT 81
7305: PUSH
7306: NOP4
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 30
7317: PUSH
7318: LD_INT 1
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PPUSH
7329: NOP4
7333: AND
7334: IFFALSE 7679
7336: GO 7338
7338: DISABLE
7339: LD_INT 0
7341: PPUSH
7342: PPUSH
7343: PPUSH
7344: PPUSH
// begin enable ;
7345: ENABLE
// tmp := queue_codes [ rng ] ;
7346: NOP4
7350: PUSH
7351: NOP4
7355: PUSH
7356: NOP4
7360: ARRAY
7361: ST_TO_ADDR
// p := 1 ;
7362: NOP4
7366: PUSH
7367: LD_INT 1
7369: ST_TO_ADDR
// for i = 1 to veh_counter do
7370: NOP4
7374: PUSH
7375: DOUBLE
7376: LD_INT 1
7378: DEC
7379: ST_TO_ADDR
7380: NOP4
7384: PUSH
7385: FOR_TO
7386: IFFALSE 7643
// begin fac := [ ar_fac_east , ar_fac_north ] [ i mod 2 + 1 ] ;
7388: NOP4
7392: PUSH
7393: NOP4
7397: PUSH
7398: NOP4
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: NOP4
7411: PUSH
7412: LD_INT 2
7414: MOD
7415: PUSH
7416: LD_INT 1
7418: PLUS
7419: ARRAY
7420: ST_TO_ADDR
// if fac = ar_fac_north and ( GetSide ( ar_fac_north ) <> bot_side or IsDead ( ar_fac_north ) or GetResourceType ( GetBase ( ar_base_nort ) , mat_cans ) < 100 ) then
7421: NOP4
7425: PUSH
7426: NOP4
7430: EQUAL
7431: PUSH
7432: NOP4
7436: PPUSH
7437: NOP4
7441: PUSH
7442: NOP4
7446: NONEQUAL
7447: PUSH
7448: NOP4
7452: PPUSH
7453: NOP4
7457: OR
7458: PUSH
7459: NOP4
7463: PPUSH
7464: NOP4
7468: PPUSH
7469: LD_INT 1
7471: PPUSH
7472: NOP4
7476: PUSH
7477: LD_INT 100
7479: LESS
7480: OR
7481: AND
7482: IFFALSE 7494
// fac := ar_fac_east ;
7484: NOP4
7488: PUSH
7489: NOP4
7493: ST_TO_ADDR
// AddComConstruct ( fac , to_produce [ tmp mod 10 ] [ 1 ] , to_produce [ tmp mod 10 ] [ 2 ] , to_produce [ tmp mod 10 ] [ 3 ] , to_produce [ tmp mod 10 ] [ 4 ] ) ;
7494: NOP4
7498: PPUSH
7499: NOP4
7503: PUSH
7504: NOP4
7508: PUSH
7509: LD_INT 10
7511: MOD
7512: ARRAY
7513: PUSH
7514: LD_INT 1
7516: ARRAY
7517: PPUSH
7518: NOP4
7522: PUSH
7523: NOP4
7527: PUSH
7528: LD_INT 10
7530: MOD
7531: ARRAY
7532: PUSH
7533: LD_INT 2
7535: ARRAY
7536: PPUSH
7537: NOP4
7541: PUSH
7542: NOP4
7546: PUSH
7547: LD_INT 10
7549: MOD
7550: ARRAY
7551: PUSH
7552: LD_INT 3
7554: ARRAY
7555: PPUSH
7556: NOP4
7560: PUSH
7561: NOP4
7565: PUSH
7566: LD_INT 10
7568: MOD
7569: ARRAY
7570: PUSH
7571: LD_INT 4
7573: ARRAY
7574: PPUSH
7575: NOP4
// tmp := tmp / 10 ;
7579: NOP4
7583: PUSH
7584: NOP4
7588: PUSH
7589: LD_INT 10
7591: DIVREAL
7592: ST_TO_ADDR
// p := p + 1 ;
7593: NOP4
7597: PUSH
7598: NOP4
7602: PUSH
7603: LD_INT 1
7605: PLUS
7606: ST_TO_ADDR
// if p > 5 then
7607: NOP4
7611: PUSH
7612: LD_INT 5
7614: GREATER
7615: IFFALSE 7641
// begin p := 1 ;
7617: NOP4
7621: PUSH
7622: LD_INT 1
7624: ST_TO_ADDR
// tmp := queue_codes [ rng ] ;
7625: NOP4
7629: PUSH
7630: NOP4
7634: PUSH
7635: NOP4
7639: ARRAY
7640: ST_TO_ADDR
// end ; end ;
7641: GO 7385
7643: POP
7644: POP
// rng := rng + 1 ;
7645: NOP4
7649: PUSH
7650: NOP4
7654: PUSH
7655: LD_INT 1
7657: PLUS
7658: ST_TO_ADDR
// if rng > queue_codes then
7659: NOP4
7663: PUSH
7664: NOP4
7668: GREATER
7669: IFFALSE 7679
// rng := 1 ;
7671: NOP4
7675: PUSH
7676: LD_INT 1
7678: ST_TO_ADDR
// end ;
7679: PPOPN 4
7681: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , 17 ] ) do var i , un ;
7682: LD_INT 25
7684: PUSH
7685: LD_INT 17
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PPUSH
7692: NOP4
7696: IFFALSE 7799
7698: GO 7700
7700: DISABLE
7701: LD_INT 0
7703: PPUSH
7704: PPUSH
// begin enable ;
7705: ENABLE
// for i in FilterAllUnits ( [ f_class , 17 ] ) do
7706: NOP4
7710: PUSH
7711: LD_INT 25
7713: PUSH
7714: LD_INT 17
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PPUSH
7721: NOP4
7725: PUSH
7726: FOR_IN
7727: IFFALSE 7797
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , i ) ;
7729: NOP4
7733: PUSH
7734: LD_INT 81
7736: PUSH
7737: NOP4
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: PPUSH
7746: NOP4
7750: PPUSH
7751: NOP4
7755: PPUSH
7756: NOP4
7760: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 15 then
7761: NOP4
7765: PPUSH
7766: NOP4
7770: PPUSH
7771: NOP4
7775: PUSH
7776: LD_INT 15
7778: LESS
7779: IFFALSE 7795
// ComAttackUnit ( i , un ) ;
7781: NOP4
7785: PPUSH
7786: NOP4
7790: PPUSH
7791: NOP4
// end ;
7795: GO 7726
7797: POP
7798: POP
// end ;
7799: PPOPN 2
7801: END
// every 0 0$01 trigger attackers marked 17 do var i ;
7802: NOP4
7806: IFFALSE 7900
7808: GO 7810
7810: DISABLE
7811: LD_INT 0
7813: PPUSH
// begin enable ;
7814: ENABLE
// if target = 0 then
7815: NOP4
7819: PUSH
7820: LD_INT 0
7822: EQUAL
7823: IFFALSE 7847
// target := FilterAllUnits ( [ f_enemy , bot_side ] ) ;
7825: NOP4
7829: PUSH
7830: LD_INT 81
7832: PUSH
7833: NOP4
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: NOP4
7846: ST_TO_ADDR
// for i in attackers do
7847: NOP4
7851: PUSH
7852: NOP4
7856: PUSH
7857: FOR_IN
7858: IFFALSE 7898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , target ] ) , i ) ) ;
7860: NOP4
7864: PPUSH
7865: LD_INT 22
7867: PUSH
7868: NOP4
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PPUSH
7877: NOP4
7881: PPUSH
7882: NOP4
7886: PPUSH
7887: NOP4
7891: PPUSH
7892: NOP4
7896: GO 7857
7898: POP
7899: POP
// end ;
7900: PPOPN 1
7902: END
// every 0 0$01 trigger not attackers marked 17 do
7903: NOP4
7907: NOT
7908: IFFALSE 7917
7910: GO 7912
7912: DISABLE
// begin enable ;
7913: ENABLE
// disable ( 17 ) ;
7914: LD_INT 17
7916: DISABLE_MARKED
// end ;
7917: END
// every 3 3$00 trigger veh_counter <= attackers do var max , i , j , x ;
7918: NOP4
7922: PUSH
7923: NOP4
7927: LESSEQUAL
7928: IFFALSE 8290
7930: GO 7932
7932: DISABLE
7933: LD_INT 0
7935: PPUSH
7936: PPUSH
7937: PPUSH
7938: PPUSH
// begin enable ;
7939: ENABLE
// enable ( 17 ) ;
7940: LD_INT 17
7942: ENABLE_MARKED
// max := 1 ;
7943: NOP4
7947: PUSH
7948: LD_INT 1
7950: ST_TO_ADDR
// for i = 1 to 8 do
7951: NOP4
7955: PUSH
7956: DOUBLE
7957: LD_INT 1
7959: DEC
7960: ST_TO_ADDR
7961: LD_INT 8
7963: PUSH
7964: FOR_TO
7965: IFFALSE 8037
// if i <> bot_side then
7967: NOP4
7971: PUSH
7972: NOP4
7976: NONEQUAL
7977: IFFALSE 8035
// begin if max < FilterAllUnits ( [ f_side , i ] ) then
7979: NOP4
7983: PUSH
7984: LD_INT 22
7986: PUSH
7987: NOP4
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: PPUSH
7996: NOP4
8000: LESS
8001: IFFALSE 8035
// begin max := FilterAllUnits ( [ f_side , i ] ) ;
8003: NOP4
8007: PUSH
8008: LD_INT 22
8010: PUSH
8011: NOP4
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PPUSH
8020: NOP4
8024: ST_TO_ADDR
// target := i ;
8025: NOP4
8029: PUSH
8030: NOP4
8034: ST_TO_ADDR
// end ; end ;
8035: GO 7964
8037: POP
8038: POP
// att_counter := att_counter + 1 ;
8039: NOP4
8043: PUSH
8044: NOP4
8048: PUSH
8049: LD_INT 1
8051: PLUS
8052: ST_TO_ADDR
// if att_counter mod [ 8 , 7 , 6 ] [ Difficulty ] = 0 and att_counter > 0 then
8053: NOP4
8057: PUSH
8058: LD_INT 8
8060: PUSH
8061: LD_INT 7
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: PUSH
8072: NOP4
8076: ARRAY
8077: MOD
8078: PUSH
8079: LD_INT 0
8081: EQUAL
8082: PUSH
8083: NOP4
8087: PUSH
8088: LD_INT 0
8090: GREATER
8091: AND
8092: IFFALSE 8290
// begin x := 1 ;
8094: NOP4
8098: PUSH
8099: LD_INT 1
8101: ST_TO_ADDR
// for j = 1 to 14 do
8102: NOP4
8106: PUSH
8107: DOUBLE
8108: LD_INT 1
8110: DEC
8111: ST_TO_ADDR
8112: LD_INT 14
8114: PUSH
8115: FOR_TO
8116: IFFALSE 8288
// begin if GetClass ( sup_attack [ 1 ] [ 1 ] ) = class_desert_warior then
8118: NOP4
8122: PUSH
8123: LD_INT 1
8125: ARRAY
8126: PUSH
8127: LD_INT 1
8129: ARRAY
8130: PPUSH
8131: NOP4
8135: PUSH
8136: LD_INT 11
8138: EQUAL
8139: IFFALSE 8195
// begin PlaceHumanInUnit ( sup_attack [ 1 ] [ 1 ] , FilterAllUnits ( [ f_control , control_rider ] ) [ x ] ) ;
8141: NOP4
8145: PUSH
8146: LD_INT 1
8148: ARRAY
8149: PUSH
8150: LD_INT 1
8152: ARRAY
8153: PPUSH
8154: LD_INT 33
8156: PUSH
8157: LD_INT 4
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PPUSH
8164: NOP4
8168: PUSH
8169: NOP4
8173: ARRAY
8174: PPUSH
8175: NOP4
// x := x + 1 ;
8179: NOP4
8183: PUSH
8184: NOP4
8188: PUSH
8189: LD_INT 1
8191: PLUS
8192: ST_TO_ADDR
// end else
8193: GO 8244
// PlaceUnitXYR ( sup_attack [ 1 ] [ 1 ] , sup_attack [ 1 ] [ 2 ] , sup_attack [ 1 ] [ 3 ] , 8 , false ) ;
8195: NOP4
8199: PUSH
8200: LD_INT 1
8202: ARRAY
8203: PUSH
8204: LD_INT 1
8206: ARRAY
8207: PPUSH
8208: NOP4
8212: PUSH
8213: LD_INT 1
8215: ARRAY
8216: PUSH
8217: LD_INT 2
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PUSH
8226: LD_INT 1
8228: ARRAY
8229: PUSH
8230: LD_INT 3
8232: ARRAY
8233: PPUSH
8234: LD_INT 8
8236: PPUSH
8237: LD_INT 0
8239: PPUSH
8240: NOP4
// attackers := attackers ^ sup_attack [ 1 ] [ 1 ] ;
8244: NOP4
8248: PUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: PUSH
8259: LD_INT 1
8261: ARRAY
8262: PUSH
8263: LD_INT 1
8265: ARRAY
8266: ADD
8267: ST_TO_ADDR
// sup_attack := Delete ( sup_attack , 1 ) ;
8268: NOP4
8272: PUSH
8273: NOP4
8277: PPUSH
8278: LD_INT 1
8280: PPUSH
8281: NOP4
8285: ST_TO_ADDR
// end ;
8286: GO 8115
8288: POP
8289: POP
// end ; end ;
8290: PPOPN 4
8292: END
// every 0 0$01 trigger game_start and tick >= 20 20$00 do
8293: NOP4
8297: PUSH
8298: NOP4
8302: PUSH
8303: LD_INT 42000
8305: GREATEREQUAL
8306: AND
8307: IFFALSE 8326
8309: GO 8311
8311: DISABLE
// begin veh_counter := veh_counter + 1 ;
8312: NOP4
8316: PUSH
8317: NOP4
8321: PUSH
8322: LD_INT 1
8324: PLUS
8325: ST_TO_ADDR
// end ;
8326: END
// every 0 0$01 trigger game_start and tick >= 40 40$00 do
8327: NOP4
8331: PUSH
8332: NOP4
8336: PUSH
8337: LD_INT 84000
8339: GREATEREQUAL
8340: AND
8341: IFFALSE 8360
8343: GO 8345
8345: DISABLE
// begin veh_counter := veh_counter + 2 ;
8346: NOP4
8350: PUSH
8351: NOP4
8355: PUSH
8356: LD_INT 2
8358: PLUS
8359: ST_TO_ADDR
// end ;
8360: END
// every 0 0$01 trigger game_start and tick >= 60 60$00 do
8361: NOP4
8365: PUSH
8366: NOP4
8370: PUSH
8371: LD_INT 126000
8373: GREATEREQUAL
8374: AND
8375: IFFALSE 8394
8377: GO 8379
8379: DISABLE
// begin veh_counter := veh_counter + 3 ;
8380: NOP4
8384: PUSH
8385: NOP4
8389: PUSH
8390: LD_INT 3
8392: PLUS
8393: ST_TO_ADDR
// end ;
8394: END
// every 0 0$03 trigger FilterUnitsInArea ( bridge2_protect , [ f_enemy , bot_side ] ) do var i ;
8395: NOP4
8399: PPUSH
8400: LD_INT 81
8402: PUSH
8403: NOP4
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: PPUSH
8412: NOP4
8416: IFFALSE 8466
8418: GO 8420
8420: DISABLE
8421: LD_INT 0
8423: PPUSH
// begin for i = 1 to river_guard do
8424: NOP4
8428: PUSH
8429: DOUBLE
8430: LD_INT 1
8432: DEC
8433: ST_TO_ADDR
8434: NOP4
8438: PUSH
8439: FOR_TO
8440: IFFALSE 8464
// ComMoveToArea ( river_guard [ i ] , bridge2_protect ) ;
8442: NOP4
8446: PUSH
8447: NOP4
8451: ARRAY
8452: PPUSH
8453: NOP4
8457: PPUSH
8458: NOP4
8462: GO 8439
8464: POP
8465: POP
// end ;
8466: PPOPN 1
8468: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
8469: LD_INT 22
8471: PUSH
8472: NOP4
8476: PUSH
8477: EMPTY
8478: LIST
8479: LIST
8480: PUSH
8481: LD_INT 33
8483: PUSH
8484: LD_INT 2
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PPUSH
8495: NOP4
8499: IFFALSE 8715
8501: GO 8503
8503: DISABLE
8504: LD_INT 0
8506: PPUSH
8507: PPUSH
8508: PPUSH
8509: PPUSH
8510: PPUSH
8511: PPUSH
8512: PPUSH
// begin enable ;
8513: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
8514: NOP4
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: NOP4
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PUSH
8531: LD_INT 33
8533: PUSH
8534: LD_INT 2
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: PUSH
8541: LD_INT 3
8543: PUSH
8544: LD_INT 61
8546: PUSH
8547: EMPTY
8548: LIST
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PPUSH
8559: NOP4
8563: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_weapon , ar_control_tower ] ] ) ;
8564: NOP4
8568: PUSH
8569: LD_INT 22
8571: PUSH
8572: NOP4
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 34
8583: PUSH
8584: LD_INT 31
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PPUSH
8595: NOP4
8599: ST_TO_ADDR
// best := 10 ;
8600: NOP4
8604: PUSH
8605: LD_INT 10
8607: ST_TO_ADDR
// best_mechanic := - 1 ;
8608: NOP4
8612: PUSH
8613: LD_INT 1
8615: NEG
8616: ST_TO_ADDR
// if vehs then
8617: NOP4
8621: IFFALSE 8715
// begin for j in cts do
8623: NOP4
8627: PUSH
8628: NOP4
8632: PUSH
8633: FOR_IN
8634: IFFALSE 8695
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
8636: NOP4
8640: PUSH
8641: NOP4
8645: PPUSH
8646: NOP4
8650: PPUSH
8651: NOP4
8655: ST_TO_ADDR
// if p < best then
8656: NOP4
8660: PUSH
8661: NOP4
8665: LESS
8666: IFFALSE 8693
// begin best := p ;
8668: NOP4
8672: PUSH
8673: NOP4
8677: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
8678: NOP4
8682: PUSH
8683: NOP4
8687: PPUSH
8688: NOP4
8692: ST_TO_ADDR
// end ; end ;
8693: GO 8633
8695: POP
8696: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
8697: NOP4
8701: PUSH
8702: LD_INT 1
8704: ARRAY
8705: PPUSH
8706: NOP4
8710: PPUSH
8711: NOP4
// end ; end ;
8715: PPOPN 7
8717: END
// every 0 0$01 do var i , j , h , sci , eng , b , p ;
8718: GO 8720
8720: DISABLE
8721: LD_INT 0
8723: PPUSH
8724: PPUSH
8725: PPUSH
8726: PPUSH
8727: PPUSH
8728: PPUSH
8729: PPUSH
// begin enable ;
8730: ENABLE
// b := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
8731: NOP4
8735: PUSH
8736: NOP4
8740: PPUSH
8741: LD_INT 22
8743: PUSH
8744: NOP4
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PUSH
8753: LD_INT 21
8755: PUSH
8756: LD_INT 3
8758: PUSH
8759: EMPTY
8760: LIST
8761: LIST
8762: PUSH
8763: LD_INT 3
8765: PUSH
8766: LD_INT 24
8768: PUSH
8769: LD_INT 1000
8771: PUSH
8772: EMPTY
8773: LIST
8774: LIST
8775: PUSH
8776: EMPTY
8777: LIST
8778: LIST
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: LIST
8784: PPUSH
8785: NOP4
8789: ST_TO_ADDR
// h := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
8790: NOP4
8794: PUSH
8795: NOP4
8799: PPUSH
8800: LD_INT 22
8802: PUSH
8803: NOP4
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: PUSH
8812: LD_INT 2
8814: PUSH
8815: LD_INT 25
8817: PUSH
8818: LD_INT 1
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PUSH
8825: LD_INT 25
8827: PUSH
8828: LD_INT 2
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 25
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 3
8853: PUSH
8854: LD_INT 24
8856: PUSH
8857: LD_INT 750
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: NOP4
8877: ST_TO_ADDR
// sci := FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_class , 4 ] ] ) ^ UnitsInside ( ar_lab_main ) ;
8878: NOP4
8882: PUSH
8883: NOP4
8887: PPUSH
8888: LD_INT 22
8890: PUSH
8891: NOP4
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 25
8902: PUSH
8903: LD_INT 4
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PPUSH
8914: NOP4
8918: PUSH
8919: NOP4
8923: PPUSH
8924: NOP4
8928: ADD
8929: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_class , 2 ] ] ) ;
8930: NOP4
8934: PUSH
8935: LD_INT 22
8937: PUSH
8938: NOP4
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: PUSH
8947: LD_INT 25
8949: PUSH
8950: LD_INT 2
8952: PUSH
8953: EMPTY
8954: LIST
8955: LIST
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PPUSH
8961: NOP4
8965: ST_TO_ADDR
// if not h and not b then
8966: NOP4
8970: NOT
8971: PUSH
8972: NOP4
8976: NOT
8977: AND
8978: IFFALSE 9282
// begin if sci then
8980: NOP4
8984: IFFALSE 9131
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) then
8986: NOP4
8990: PPUSH
8991: LD_INT 3
8993: PUSH
8994: LD_INT 54
8996: PUSH
8997: EMPTY
8998: LIST
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PPUSH
9004: NOP4
9008: PUSH
9009: NOP4
9013: PPUSH
9014: LD_INT 22
9016: PUSH
9017: NOP4
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PUSH
9026: LD_INT 30
9028: PUSH
9029: LD_INT 8
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PPUSH
9040: NOP4
9044: AND
9045: IFFALSE 9131
// for j in UnitFilter ( sci , [ f_not , [ f_inside ] ] ) do
9047: NOP4
9051: PUSH
9052: NOP4
9056: PPUSH
9057: LD_INT 3
9059: PUSH
9060: LD_INT 54
9062: PUSH
9063: EMPTY
9064: LIST
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PPUSH
9070: NOP4
9074: PUSH
9075: FOR_IN
9076: IFFALSE 9129
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
9078: NOP4
9082: PPUSH
9083: NOP4
9087: PPUSH
9088: LD_INT 22
9090: PUSH
9091: NOP4
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: PUSH
9100: LD_INT 30
9102: PUSH
9103: LD_INT 8
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PPUSH
9114: NOP4
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: NOP4
9127: GO 9075
9129: POP
9130: POP
// if eng then
9131: NOP4
9135: IFFALSE 9282
// if UnitFilter ( eng , [ f_not , [ f_inside ] ] ) and FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) then
9137: NOP4
9141: PPUSH
9142: LD_INT 3
9144: PUSH
9145: LD_INT 54
9147: PUSH
9148: EMPTY
9149: LIST
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: PPUSH
9155: NOP4
9159: PUSH
9160: NOP4
9164: PPUSH
9165: LD_INT 22
9167: PUSH
9168: NOP4
9172: PUSH
9173: EMPTY
9174: LIST
9175: LIST
9176: PUSH
9177: LD_INT 30
9179: PUSH
9180: LD_INT 1
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: PPUSH
9191: NOP4
9195: AND
9196: IFFALSE 9282
// for j in UnitFilter ( eng , [ f_not , [ f_inside ] ] ) do
9198: NOP4
9202: PUSH
9203: NOP4
9207: PPUSH
9208: LD_INT 3
9210: PUSH
9211: LD_INT 54
9213: PUSH
9214: EMPTY
9215: LIST
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PPUSH
9221: NOP4
9225: PUSH
9226: FOR_IN
9227: IFFALSE 9280
// ComEnterUnit ( j , FilterUnitsInArea ( main_base , [ [ f_side , bot_side ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
9229: NOP4
9233: PPUSH
9234: NOP4
9238: PPUSH
9239: LD_INT 22
9241: PUSH
9242: NOP4
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PUSH
9251: LD_INT 30
9253: PUSH
9254: LD_INT 1
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: PPUSH
9265: NOP4
9269: PUSH
9270: LD_INT 1
9272: ARRAY
9273: PPUSH
9274: NOP4
9278: GO 9226
9280: POP
9281: POP
// end ; p := 1 ;
9282: NOP4
9286: PUSH
9287: LD_INT 1
9289: ST_TO_ADDR
// if b and eng then
9290: NOP4
9294: PUSH
9295: NOP4
9299: AND
9300: IFFALSE 9434
// for j in eng do
9302: NOP4
9306: PUSH
9307: NOP4
9311: PUSH
9312: FOR_IN
9313: IFFALSE 9432
// begin if IsInUnit ( j ) then
9315: NOP4
9319: PPUSH
9320: NOP4
9324: IFFALSE 9337
// ComExitBuilding ( j ) else
9326: NOP4
9330: PPUSH
9331: NOP4
9335: GO 9430
// if not HasTask ( j ) and GetLives ( j ) > 750 then
9337: NOP4
9341: PPUSH
9342: NOP4
9346: NOT
9347: PUSH
9348: NOP4
9352: PPUSH
9353: NOP4
9357: PUSH
9358: LD_INT 750
9360: GREATER
9361: AND
9362: IFFALSE 9430
// begin if b > p then
9364: NOP4
9368: PUSH
9369: NOP4
9373: GREATER
9374: IFFALSE 9412
// begin ComRepairBuilding ( j , b [ p ] ) ;
9376: NOP4
9380: PPUSH
9381: NOP4
9385: PUSH
9386: NOP4
9390: ARRAY
9391: PPUSH
9392: NOP4
// p := p + 1 ;
9396: NOP4
9400: PUSH
9401: NOP4
9405: PUSH
9406: LD_INT 1
9408: PLUS
9409: ST_TO_ADDR
// end else
9410: GO 9430
// ComRepairBuilding ( j , b [ 1 ] ) ;
9412: NOP4
9416: PPUSH
9417: NOP4
9421: PUSH
9422: LD_INT 1
9424: ARRAY
9425: PPUSH
9426: NOP4
// end ; end ;
9430: GO 9312
9432: POP
9433: POP
// if h and sci then
9434: NOP4
9438: PUSH
9439: NOP4
9443: AND
9444: IFFALSE 9583
// for i in h do
9446: NOP4
9450: PUSH
9451: NOP4
9455: PUSH
9456: FOR_IN
9457: IFFALSE 9581
// if GetDistUnitXY ( i , 108 , 42 ) > 10 then
9459: NOP4
9463: PPUSH
9464: LD_INT 108
9466: PPUSH
9467: LD_INT 42
9469: PPUSH
9470: NOP4
9474: PUSH
9475: LD_INT 10
9477: GREATER
9478: IFFALSE 9497
// ComMoveXY ( i , 108 , 42 ) else
9480: NOP4
9484: PPUSH
9485: LD_INT 108
9487: PPUSH
9488: LD_INT 42
9490: PPUSH
9491: NOP4
9495: GO 9579
// begin for j in sci do
9497: NOP4
9501: PUSH
9502: NOP4
9506: PUSH
9507: FOR_IN
9508: IFFALSE 9577
// begin if GetTag ( j ) > 0 then
9510: NOP4
9514: PPUSH
9515: NOP4
9519: PUSH
9520: LD_INT 0
9522: GREATER
9523: IFFALSE 9527
// continue ;
9525: GO 9507
// if IsInUnit ( j ) then
9527: NOP4
9531: PPUSH
9532: NOP4
9536: IFFALSE 9549
// ComExitBuilding ( j ) else
9538: NOP4
9542: PPUSH
9543: NOP4
9547: GO 9575
// if not HasTask ( j ) then
9549: NOP4
9553: PPUSH
9554: NOP4
9558: NOT
9559: IFFALSE 9575
// ComHeal ( j , h ) ;
9561: NOP4
9565: PPUSH
9566: NOP4
9570: PPUSH
9571: NOP4
// end ;
9575: GO 9507
9577: POP
9578: POP
// end ;
9579: GO 9456
9581: POP
9582: POP
// end ;
9583: PPOPN 7
9585: END
// every 0 0$01 trigger mines_list do var i , p ;
9586: NOP4
9590: IFFALSE 9816
9592: GO 9594
9594: DISABLE
9595: LD_INT 0
9597: PPUSH
9598: PPUSH
// begin enable ;
9599: ENABLE
// p := 1 ;
9600: NOP4
9604: PUSH
9605: LD_INT 1
9607: ST_TO_ADDR
// for i = 1 to mines_list / 2 do
9608: NOP4
9612: PUSH
9613: DOUBLE
9614: LD_INT 1
9616: DEC
9617: ST_TO_ADDR
9618: NOP4
9622: PUSH
9623: LD_INT 2
9625: DIVREAL
9626: PUSH
9627: FOR_TO
9628: IFFALSE 9814
// begin if HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) > 0 then
9630: NOP4
9634: PUSH
9635: NOP4
9639: ARRAY
9640: PPUSH
9641: NOP4
9645: PUSH
9646: NOP4
9650: PUSH
9651: LD_INT 1
9653: PLUS
9654: ARRAY
9655: PPUSH
9656: NOP4
9660: PUSH
9661: LD_INT 0
9663: GREATER
9664: IFFALSE 9798
// if GetSide ( HexInfo ( mines_list [ p ] , mines_list [ p + 1 ] ) ) <> bot_side then
9666: NOP4
9670: PUSH
9671: NOP4
9675: ARRAY
9676: PPUSH
9677: NOP4
9681: PUSH
9682: NOP4
9686: PUSH
9687: LD_INT 1
9689: PLUS
9690: ARRAY
9691: PPUSH
9692: NOP4
9696: PPUSH
9697: NOP4
9701: PUSH
9702: NOP4
9706: NONEQUAL
9707: IFFALSE 9798
// begin LaunchMineAtPos ( mines_list [ p ] , mines_list [ p + 1 ] , bot_side ) ;
9709: NOP4
9713: PUSH
9714: NOP4
9718: ARRAY
9719: PPUSH
9720: NOP4
9724: PUSH
9725: NOP4
9729: PUSH
9730: LD_INT 1
9732: PLUS
9733: ARRAY
9734: PPUSH
9735: NOP4
9739: PPUSH
9740: NOP4
// mines_list := Delete ( mines_list , p ) ;
9744: NOP4
9748: PUSH
9749: NOP4
9753: PPUSH
9754: NOP4
9758: PPUSH
9759: NOP4
9763: ST_TO_ADDR
// mines_list := Delete ( mines_list , p ) ;
9764: NOP4
9768: PUSH
9769: NOP4
9773: PPUSH
9774: NOP4
9778: PPUSH
9779: NOP4
9783: ST_TO_ADDR
// p := p - 2 ;
9784: NOP4
9788: PUSH
9789: NOP4
9793: PUSH
9794: LD_INT 2
9796: MINUS
9797: ST_TO_ADDR
// end ; p := p + 2 ;
9798: NOP4
9802: PUSH
9803: NOP4
9807: PUSH
9808: LD_INT 2
9810: PLUS
9811: ST_TO_ADDR
// end ;
9812: GO 9627
9814: POP
9815: POP
// end ;
9816: PPOPN 2
9818: END
// every 13 13$00 trigger FilterAllUnits ( [ [ f_enemy , bot_side ] , [ f_type , unit_building ] ] ) and apek do var i ;
9819: LD_INT 81
9821: PUSH
9822: NOP4
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: PUSH
9831: LD_INT 21
9833: PUSH
9834: LD_INT 3
9836: PUSH
9837: EMPTY
9838: LIST
9839: LIST
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PPUSH
9845: NOP4
9849: PUSH
9850: NOP4
9854: AND
9855: IFFALSE 9973
9857: GO 9859
9859: DISABLE
9860: LD_INT 0
9862: PPUSH
// begin enable ;
9863: ENABLE
// for i = 1 to 3 do
9864: NOP4
9868: PUSH
9869: DOUBLE
9870: LD_INT 1
9872: DEC
9873: ST_TO_ADDR
9874: LD_INT 3
9876: PUSH
9877: FOR_TO
9878: IFFALSE 9971
// begin PlaceUnitArea ( apek [ i ] , ape_kami , false ) ;
9880: NOP4
9884: PUSH
9885: NOP4
9889: ARRAY
9890: PPUSH
9891: NOP4
9895: PPUSH
9896: LD_INT 0
9898: PPUSH
9899: NOP4
// ComAttackUnit ( apek [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , bot_side ] ) , apek [ i ] ) ) ;
9903: NOP4
9907: PUSH
9908: NOP4
9912: ARRAY
9913: PPUSH
9914: LD_INT 81
9916: PUSH
9917: NOP4
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PPUSH
9926: NOP4
9930: PPUSH
9931: NOP4
9935: PUSH
9936: NOP4
9940: ARRAY
9941: PPUSH
9942: NOP4
9946: PPUSH
9947: NOP4
// apek := Delete ( apek , 1 ) ;
9951: NOP4
9955: PUSH
9956: NOP4
9960: PPUSH
9961: LD_INT 1
9963: PPUSH
9964: NOP4
9968: ST_TO_ADDR
// end ;
9969: GO 9877
9971: POP
9972: POP
// end ;
9973: PPOPN 1
9975: END
// every 0 0$02 trigger GetSide ( ar_base_nort ) <> bot_side do
9976: NOP4
9980: PPUSH
9981: NOP4
9985: PUSH
9986: NOP4
9990: NONEQUAL
9991: IFFALSE 10131
9993: GO 9995
9995: DISABLE
// begin MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
9996: NOP4
10000: PPUSH
10001: NOP4
10005: PPUSH
10006: NOP4
10010: PPUSH
10011: NOP4
10015: PPUSH
10016: LD_INT 1
10018: PPUSH
10019: NOP4
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
10023: NOP4
10027: PPUSH
10028: NOP4
10032: PPUSH
10033: NOP4
10037: PPUSH
10038: NOP4
10042: PPUSH
10043: LD_INT 1
10045: PPUSH
10046: NOP4
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
10050: NOP4
10054: PPUSH
10055: NOP4
10059: PPUSH
10060: NOP4
10064: PPUSH
10065: NOP4
10069: PPUSH
10070: LD_INT 1
10072: PPUSH
10073: NOP4
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
10077: NOP4
10081: PPUSH
10082: NOP4
10086: PPUSH
10087: NOP4
10091: PPUSH
10092: NOP4
10096: PPUSH
10097: LD_INT 1
10099: PPUSH
10100: NOP4
// MineExplosion ( GetX ( ar_base_nort ) , GetY ( ar_base_nort ) , 1 ) ;
10104: NOP4
10108: PPUSH
10109: NOP4
10113: PPUSH
10114: NOP4
10118: PPUSH
10119: NOP4
10123: PPUSH
10124: LD_INT 1
10126: PPUSH
10127: NOP4
// end ;
10131: END
// every 0 0$03 do var i , p , skr , filter , dep ;
10132: GO 10134
10134: DISABLE
10135: LD_INT 0
10137: PPUSH
10138: PPUSH
10139: PPUSH
10140: PPUSH
10141: PPUSH
// begin enable ;
10142: ENABLE
// if not ar_collectors then
10143: NOP4
10147: NOT
10148: IFFALSE 10195
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , bot_side ] , [ f_class , class_apeman_engineer ] ] ) else
10150: NOP4
10154: PUSH
10155: LD_INT 50
10157: PUSH
10158: EMPTY
10159: LIST
10160: PUSH
10161: LD_INT 22
10163: PUSH
10164: NOP4
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 25
10175: PUSH
10176: LD_INT 16
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: LIST
10187: PPUSH
10188: NOP4
10192: ST_TO_ADDR
10193: GO 10205
// filter := ar_collectors ;
10195: NOP4
10199: PUSH
10200: NOP4
10204: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , bot_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10205: NOP4
10209: PUSH
10210: LD_INT 22
10212: PUSH
10213: NOP4
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 2
10224: PUSH
10225: LD_INT 30
10227: PUSH
10228: LD_INT 0
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 30
10237: PUSH
10238: LD_INT 1
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: LIST
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: PPUSH
10254: NOP4
10258: ST_TO_ADDR
// skr := GetListOfCratesInArea ( collect_crates ) ;
10259: NOP4
10263: PUSH
10264: NOP4
10268: PPUSH
10269: NOP4
10273: ST_TO_ADDR
// if not filter then
10274: NOP4
10278: NOT
10279: IFFALSE 10283
// exit ;
10281: GO 10350
// if filter and skr then
10283: NOP4
10287: PUSH
10288: NOP4
10292: AND
10293: IFFALSE 10350
// for i = 1 to filter do
10295: NOP4
10299: PUSH
10300: DOUBLE
10301: LD_INT 1
10303: DEC
10304: ST_TO_ADDR
10305: NOP4
10309: PUSH
10310: FOR_TO
10311: IFFALSE 10348
// ComCollect ( filter [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
10313: NOP4
10317: PUSH
10318: NOP4
10322: ARRAY
10323: PPUSH
10324: NOP4
10328: PUSH
10329: LD_INT 1
10331: ARRAY
10332: PPUSH
10333: NOP4
10337: PUSH
10338: LD_INT 2
10340: ARRAY
10341: PPUSH
10342: NOP4
10346: GO 10310
10348: POP
10349: POP
// end ;
10350: PPOPN 5
10352: END
