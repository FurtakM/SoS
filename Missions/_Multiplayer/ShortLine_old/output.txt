// export you , russians , neutral ; export Bobby , Cyrus , Lisa , MacMillan , Cornell , Powell , Khatam , Frank ; export Kobra1 , other_survivors , cornells , yours ; export atack , saved_units ; export mrtvi_lide ; export JMMinvehicle , Cyrusinvehicle ; export Mikhail , rus_vehicle ; export rus_south , rus_guard1 , rus_guard2 , rus_guard3 , rus_guard4 ; export South_russian_patrol , forest_force1 , forest_force2 ; export grass_force1 , grass_force2 , grass_force3 ; export Cornell_group , amtruck1 , amtruck2 , cans , cans1 ; export Dialogue_wait , time_to_return , time_to_attack , solar_constructed , solar_saved , Meet_Frank , base_reached , cornell_lost , Frank_Query ; var time_crates ; function prepare_units ; var un , i , JMM_group , cornell_limit ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
// JMM_group := [ ] ;
   7: LD_ADDR_VAR 0 4
  11: PUSH
  12: EMPTY
  13: ST_TO_ADDR
// cornell_limit := 0 ;
  14: LD_ADDR_VAR 0 5
  18: PUSH
  19: LD_INT 0
  21: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
  22: LD_ADDR_OWVAR 24
  26: PUSH
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 5
  32: PPUSH
  33: CALL_OW 12
  37: ST_TO_ADDR
// uc_nation = nation_american ;
  38: LD_ADDR_OWVAR 21
  42: PUSH
  43: LD_INT 1
  45: ST_TO_ADDR
// uc_side = you ;
  46: LD_ADDR_OWVAR 20
  50: PUSH
  51: LD_EXP 1
  55: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  56: LD_ADDR_EXP 7
  60: PUSH
  61: LD_STRING JMM
  63: PPUSH
  64: CALL_OW 34
  68: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
  69: LD_ADDR_EXP 6
  73: PUSH
  74: LD_STRING Lisa
  76: PPUSH
  77: CALL_OW 34
  81: ST_TO_ADDR
// Bobby := CreateCharacter ( Bobby ) ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_STRING Bobby
  89: PPUSH
  90: CALL_OW 34
  94: ST_TO_ADDR
// Cyrus := CreateCharacter ( Cyrus ) ;
  95: LD_ADDR_EXP 5
  99: PUSH
 100: LD_STRING Cyrus
 102: PPUSH
 103: CALL_OW 34
 107: ST_TO_ADDR
// Khatam := CreateCharacter ( Khatam ) ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_STRING Khatam
 115: PPUSH
 116: CALL_OW 34
 120: ST_TO_ADDR
// Frank := NewCharacter ( Frank ) ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_STRING Frank
 128: PPUSH
 129: CALL_OW 25
 133: ST_TO_ADDR
// Cornell := NewCharacter ( Cornell ) ;
 134: LD_ADDR_EXP 8
 138: PUSH
 139: LD_STRING Cornell
 141: PPUSH
 142: CALL_OW 25
 146: ST_TO_ADDR
// JMM_group := [ Lisa , Bobby , Cyrus , Khatam ] diff 0 ;
 147: LD_ADDR_VAR 0 4
 151: PUSH
 152: LD_EXP 6
 156: PUSH
 157: LD_EXP 4
 161: PUSH
 162: LD_EXP 5
 166: PUSH
 167: LD_EXP 10
 171: PUSH
 172: EMPTY
 173: LIST
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 0
 180: DIFF
 181: ST_TO_ADDR
// PlaceUnitXY ( Cornell , 163 , 100 , false ) ;
 182: LD_EXP 8
 186: PPUSH
 187: LD_INT 163
 189: PPUSH
 190: LD_INT 100
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 48
// Powell := NewCharacter ( Powell ) ;
 200: LD_ADDR_EXP 9
 204: PUSH
 205: LD_STRING Powell
 207: PPUSH
 208: CALL_OW 25
 212: ST_TO_ADDR
// hc_gallery :=  ;
 213: LD_ADDR_OWVAR 33
 217: PUSH
 218: LD_STRING 
 220: ST_TO_ADDR
// hc_importance := 0 ;
 221: LD_ADDR_OWVAR 32
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// cornells := [ ] ;
 229: LD_ADDR_EXP 14
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// cornell_limit := 5 + ( 4 - JMM_group ) ;
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_INT 5
 243: PUSH
 244: LD_INT 4
 246: PUSH
 247: LD_VAR 0 4
 251: MINUS
 252: PLUS
 253: ST_TO_ADDR
// for i := 1 to cornell_limit do
 254: LD_ADDR_VAR 0 3
 258: PUSH
 259: DOUBLE
 260: LD_INT 1
 262: DEC
 263: ST_TO_ADDR
 264: LD_VAR 0 5
 268: PUSH
 269: FOR_TO
 270: IFFALSE 346
// begin PrepareHuman ( 2 - i mod 2 , 0 , 2 ) ;
 272: LD_INT 2
 274: PUSH
 275: LD_VAR 0 3
 279: PUSH
 280: LD_INT 2
 282: MOD
 283: MINUS
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: LD_INT 2
 290: PPUSH
 291: CALL_OW 380
// hc_class := class_soldier ;
 295: LD_ADDR_OWVAR 28
 299: PUSH
 300: LD_INT 1
 302: ST_TO_ADDR
// un := CreateHuman ;
 303: LD_ADDR_VAR 0 2
 307: PUSH
 308: CALL_OW 44
 312: ST_TO_ADDR
// cornells := cornells ^ un ;
 313: LD_ADDR_EXP 14
 317: PUSH
 318: LD_EXP 14
 322: PUSH
 323: LD_VAR 0 2
 327: ADD
 328: ST_TO_ADDR
// PlaceUnitArea ( un , cornellsarea , false ) ;
 329: LD_VAR 0 2
 333: PPUSH
 334: LD_INT 20
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 49
// end ;
 344: GO 269
 346: POP
 347: POP
// if TestCharacters ( other_survivors ) then
 348: LD_STRING other_survivors
 350: PPUSH
 351: CALL_OW 28
 355: IFFALSE 372
// other_survivors := CreateCharacterSet ( other_survivors ) else
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING other_survivors
 364: PPUSH
 365: CALL_OW 31
 369: ST_TO_ADDR
 370: GO 379
// other_survivors := [ ] ;
 372: LD_ADDR_EXP 13
 376: PUSH
 377: EMPTY
 378: ST_TO_ADDR
// uc_nation = nation_russian ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// uc_side = russians ;
 387: LD_ADDR_OWVAR 20
 391: PUSH
 392: LD_EXP 2
 396: ST_TO_ADDR
// if ( LoadVariable ( us2mikhail_state , 0 ) = 5 ) and TestCharacters ( Mikhail ) and CheckCharacterSet ( Mikhail ) then
 397: LD_STRING us2mikhail_state
 399: PPUSH
 400: LD_INT 0
 402: PPUSH
 403: CALL_OW 30
 407: PUSH
 408: LD_INT 5
 410: EQUAL
 411: PUSH
 412: LD_STRING Mikhail
 414: PPUSH
 415: CALL_OW 28
 419: AND
 420: PUSH
 421: LD_STRING Mikhail
 423: PPUSH
 424: CALL_OW 29
 428: AND
 429: IFFALSE 444
// Mikhail := CreateCharacter ( Mikhail ) ;
 431: LD_ADDR_EXP 21
 435: PUSH
 436: LD_STRING Mikhail
 438: PPUSH
 439: CALL_OW 34
 443: ST_TO_ADDR
// JMMinvehicle := LoadVariable ( us2JMMInVehicle , false ) ;
 444: LD_ADDR_EXP 19
 448: PUSH
 449: LD_STRING us2JMMInVehicle
 451: PPUSH
 452: LD_INT 0
 454: PPUSH
 455: CALL_OW 30
 459: ST_TO_ADDR
// Cyrusinvehicle := LoadVariable ( us2CyrusInVehicle , false ) ;
 460: LD_ADDR_EXP 20
 464: PUSH
 465: LD_STRING us2CyrusInVehicle
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: CALL_OW 30
 475: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
 476: LD_INT 2
 478: PUSH
 479: LD_INT 3
 481: PUSH
 482: LD_INT 1
 484: PUSH
 485: LD_INT 4
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: PPUSH
 494: CALL_OW 139
// Kobra1 := [ MacMillan , Bobby , Lisa , Cyrus , Mikhail , Khatam ] ^ other_survivors diff [ 0 ] ;
 498: LD_ADDR_EXP 12
 502: PUSH
 503: LD_EXP 7
 507: PUSH
 508: LD_EXP 4
 512: PUSH
 513: LD_EXP 6
 517: PUSH
 518: LD_EXP 5
 522: PUSH
 523: LD_EXP 21
 527: PUSH
 528: LD_EXP 10
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_EXP 13
 545: ADD
 546: PUSH
 547: LD_INT 0
 549: PUSH
 550: EMPTY
 551: LIST
 552: DIFF
 553: ST_TO_ADDR
// SetClass ( Kobra1 diff Mikhail , class_soldier ) ;
 554: LD_EXP 12
 558: PUSH
 559: LD_EXP 21
 563: DIFF
 564: PPUSH
 565: LD_INT 1
 567: PPUSH
 568: CALL_OW 336
// Kobra1 := Kobra1 diff [ 0 ] ;
 572: LD_ADDR_EXP 12
 576: PUSH
 577: LD_EXP 12
 581: PUSH
 582: LD_INT 0
 584: PUSH
 585: EMPTY
 586: LIST
 587: DIFF
 588: ST_TO_ADDR
// cans := LoadVariable ( us2cans , 60 ) ;
 589: LD_ADDR_EXP 37
 593: PUSH
 594: LD_STRING us2cans
 596: PPUSH
 597: LD_INT 60
 599: PPUSH
 600: CALL_OW 30
 604: ST_TO_ADDR
// if cans > 200 then
 605: LD_EXP 37
 609: PUSH
 610: LD_INT 200
 612: GREATER
 613: IFFALSE 623
// cans := 200 ;
 615: LD_ADDR_EXP 37
 619: PUSH
 620: LD_INT 200
 622: ST_TO_ADDR
// cans1 := 30 ;
 623: LD_ADDR_EXP 38
 627: PUSH
 628: LD_INT 30
 630: ST_TO_ADDR
// cans1 := cans1 + ( ( cans - 30 + 10 ) div 30 ) * 10 ;
 631: LD_ADDR_EXP 38
 635: PUSH
 636: LD_EXP 38
 640: PUSH
 641: LD_EXP 37
 645: PUSH
 646: LD_INT 30
 648: MINUS
 649: PUSH
 650: LD_INT 10
 652: PLUS
 653: PUSH
 654: LD_INT 30
 656: DIV
 657: PUSH
 658: LD_INT 10
 660: MUL
 661: PLUS
 662: ST_TO_ADDR
// if cans1 > 100 then
 663: LD_EXP 38
 667: PUSH
 668: LD_INT 100
 670: GREATER
 671: IFFALSE 681
// cans1 := 100 ;
 673: LD_ADDR_EXP 38
 677: PUSH
 678: LD_INT 100
 680: ST_TO_ADDR
// cans := cans - cans1 ;
 681: LD_ADDR_EXP 37
 685: PUSH
 686: LD_EXP 37
 690: PUSH
 691: LD_EXP 38
 695: MINUS
 696: ST_TO_ADDR
// if cans > 100 then
 697: LD_EXP 37
 701: PUSH
 702: LD_INT 100
 704: GREATER
 705: IFFALSE 715
// cans := 100 ;
 707: LD_ADDR_EXP 37
 711: PUSH
 712: LD_INT 100
 714: ST_TO_ADDR
// uc_side := you ;
 715: LD_ADDR_OWVAR 20
 719: PUSH
 720: LD_EXP 1
 724: ST_TO_ADDR
// uc_nation := nation_russian ;
 725: LD_ADDR_OWVAR 21
 729: PUSH
 730: LD_INT 3
 732: ST_TO_ADDR
// uc_direction := 5 ;
 733: LD_ADDR_OWVAR 24
 737: PUSH
 738: LD_INT 5
 740: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
 741: LD_ADDR_OWVAR 37
 745: PUSH
 746: LD_INT 22
 748: ST_TO_ADDR
// vc_engine := engine_combustion ;
 749: LD_ADDR_OWVAR 39
 753: PUSH
 754: LD_INT 1
 756: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
 757: LD_ADDR_OWVAR 40
 761: PUSH
 762: LD_INT 51
 764: ST_TO_ADDR
// vc_control := control_manual ;
 765: LD_ADDR_OWVAR 38
 769: PUSH
 770: LD_INT 1
 772: ST_TO_ADDR
// if cans1 > 0 then
 773: LD_EXP 38
 777: PUSH
 778: LD_INT 0
 780: GREATER
 781: IFFALSE 856
// begin amtruck1 := CreateVehicle ;
 783: LD_ADDR_EXP 35
 787: PUSH
 788: CALL_OW 45
 792: ST_TO_ADDR
// PlaceHumanInUnit ( Macmillan , amtruck1 ) ;
 793: LD_EXP 7
 797: PPUSH
 798: LD_EXP 35
 802: PPUSH
 803: CALL_OW 52
// SetCargo ( amtruck1 , mat_cans , cans1 ) ;
 807: LD_EXP 35
 811: PPUSH
 812: LD_INT 1
 814: PPUSH
 815: LD_EXP 38
 819: PPUSH
 820: CALL_OW 290
// SetFuel ( amtruck1 , 50 ) ;
 824: LD_EXP 35
 828: PPUSH
 829: LD_INT 50
 831: PPUSH
 832: CALL_OW 240
// PlaceUnitXY ( amtruck1 , 174 , 115 , false ) ;
 836: LD_EXP 35
 840: PPUSH
 841: LD_INT 174
 843: PPUSH
 844: LD_INT 115
 846: PPUSH
 847: LD_INT 0
 849: PPUSH
 850: CALL_OW 48
// end else
 854: GO 874
// PlaceUnitXY ( MacMillan , 174 , 115 , false ) ;
 856: LD_EXP 7
 860: PPUSH
 861: LD_INT 174
 863: PPUSH
 864: LD_INT 115
 866: PPUSH
 867: LD_INT 0
 869: PPUSH
 870: CALL_OW 48
// if ( cans > 0 ) and ( Kobra1 > 1 ) then
 874: LD_EXP 37
 878: PUSH
 879: LD_INT 0
 881: GREATER
 882: PUSH
 883: LD_EXP 12
 887: PUSH
 888: LD_INT 1
 890: GREATER
 891: AND
 892: IFFALSE 969
// begin amtruck2 := CreateVehicle ;
 894: LD_ADDR_EXP 36
 898: PUSH
 899: CALL_OW 45
 903: ST_TO_ADDR
// PlaceHumanInUnit ( Kobra1 [ 2 ] , amtruck2 ) ;
 904: LD_EXP 12
 908: PUSH
 909: LD_INT 2
 911: ARRAY
 912: PPUSH
 913: LD_EXP 36
 917: PPUSH
 918: CALL_OW 52
// SetCargo ( amtruck2 , mat_cans , cans ) ;
 922: LD_EXP 36
 926: PPUSH
 927: LD_INT 1
 929: PPUSH
 930: LD_EXP 37
 934: PPUSH
 935: CALL_OW 290
// SetFuel ( amtruck2 , 50 ) ;
 939: LD_EXP 36
 943: PPUSH
 944: LD_INT 50
 946: PPUSH
 947: CALL_OW 240
// PlaceUnitXY ( amtruck2 , 171 , 115 , false ) ;
 951: LD_EXP 36
 955: PPUSH
 956: LD_INT 171
 958: PPUSH
 959: LD_INT 115
 961: PPUSH
 962: LD_INT 0
 964: PPUSH
 965: CALL_OW 48
// end ; for un in Kobra1 do
 969: LD_ADDR_VAR 0 2
 973: PUSH
 974: LD_EXP 12
 978: PUSH
 979: FOR_IN
 980: IFFALSE 1011
// if not IsInUnit ( un ) then
 982: LD_VAR 0 2
 986: PPUSH
 987: CALL_OW 310
 991: NOT
 992: IFFALSE 1009
// PlaceUnitArea ( un , enterarea , false ) ;
 994: LD_VAR 0 2
 998: PPUSH
 999: LD_INT 19
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
1009: GO 979
1011: POP
1012: POP
// end ;
1013: LD_VAR 0 1
1017: RET
// function prepare_sides ; begin
1018: LD_INT 0
1020: PPUSH
// you = 1 ;
1021: LD_ADDR_EXP 1
1025: PUSH
1026: LD_INT 1
1028: ST_TO_ADDR
// neutral = 4 ;
1029: LD_ADDR_EXP 3
1033: PUSH
1034: LD_INT 4
1036: ST_TO_ADDR
// russians = 3 ;
1037: LD_ADDR_EXP 2
1041: PUSH
1042: LD_INT 3
1044: ST_TO_ADDR
// atack = 0 ;
1045: LD_ADDR_EXP 16
1049: PUSH
1050: LD_INT 0
1052: ST_TO_ADDR
// time_to_return := [ 25 25$0 , 12 12$0 , 2 2$0 ] [ difficulty ] ;
1053: LD_ADDR_EXP 40
1057: PUSH
1058: LD_INT 52500
1060: PUSH
1061: LD_INT 25200
1063: PUSH
1064: LD_INT 4200
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_OWVAR 67
1076: ARRAY
1077: ST_TO_ADDR
// time_to_attack := [ 40 40$0 , 25 25$0 , 15 15$0 ] [ difficulty ] ;
1078: LD_ADDR_EXP 41
1082: PUSH
1083: LD_INT 84000
1085: PUSH
1086: LD_INT 52500
1088: PUSH
1089: LD_INT 31500
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: PUSH
1097: LD_OWVAR 67
1101: ARRAY
1102: ST_TO_ADDR
// solar_constructed := false ;
1103: LD_ADDR_EXP 42
1107: PUSH
1108: LD_INT 0
1110: ST_TO_ADDR
// solar_saved := true ;
1111: LD_ADDR_EXP 43
1115: PUSH
1116: LD_INT 1
1118: ST_TO_ADDR
// saved_units = [ ] ;
1119: LD_ADDR_EXP 17
1123: PUSH
1124: EMPTY
1125: ST_TO_ADDR
// time_crates := Rand ( 0 0$20 , 0 0$40 ) ;
1126: LD_ADDR_LOC 1
1130: PUSH
1131: LD_INT 700
1133: PPUSH
1134: LD_INT 1400
1136: PPUSH
1137: CALL_OW 12
1141: ST_TO_ADDR
// mrtvi_lide := 0 ;
1142: LD_ADDR_EXP 18
1146: PUSH
1147: LD_INT 0
1149: ST_TO_ADDR
// Meet_Frank := false ;
1150: LD_ADDR_EXP 44
1154: PUSH
1155: LD_INT 0
1157: ST_TO_ADDR
// base_reached := false ;
1158: LD_ADDR_EXP 45
1162: PUSH
1163: LD_INT 0
1165: ST_TO_ADDR
// cornell_lost := false ;
1166: LD_ADDR_EXP 46
1170: PUSH
1171: LD_INT 0
1173: ST_TO_ADDR
// Dialogue_wait := false ;
1174: LD_ADDR_EXP 39
1178: PUSH
1179: LD_INT 0
1181: ST_TO_ADDR
// forest_force1 = [ forest11 , forest12 ] ;
1182: LD_ADDR_EXP 29
1186: PUSH
1187: LD_INT 26
1189: PUSH
1190: LD_INT 25
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: ST_TO_ADDR
// forest_force2 = [ forest21 , forest22 ] ;
1197: LD_ADDR_EXP 30
1201: PUSH
1202: LD_INT 41
1204: PUSH
1205: LD_INT 42
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// ComEnterUnit ( guard1 , bunker1 ) ;
1212: LD_INT 30
1214: PPUSH
1215: LD_INT 28
1217: PPUSH
1218: CALL_OW 120
// ComEnterUnit ( guard2 , bunker2 ) ;
1222: LD_INT 29
1224: PPUSH
1225: LD_INT 27
1227: PPUSH
1228: CALL_OW 120
// ComEnterUnit ( guard3 , bunker3 ) ;
1232: LD_INT 48
1234: PPUSH
1235: LD_INT 34
1237: PPUSH
1238: CALL_OW 120
// ComEnterUnit ( guard4 , bunker4 ) ;
1242: LD_INT 47
1244: PPUSH
1245: LD_INT 33
1247: PPUSH
1248: CALL_OW 120
// ComEnterUnit ( guard5 , bunker5 ) ;
1252: LD_INT 49
1254: PPUSH
1255: LD_INT 32
1257: PPUSH
1258: CALL_OW 120
// ComEnterUnit ( guard6 , bunker6 ) ;
1262: LD_INT 20
1264: PPUSH
1265: LD_INT 31
1267: PPUSH
1268: CALL_OW 120
// ComEnterUnit ( guard7 , bunker7 ) ;
1272: LD_INT 53
1274: PPUSH
1275: LD_INT 52
1277: PPUSH
1278: CALL_OW 120
// ComEnterUnit ( maker_1 , factory1 ) ;
1282: LD_INT 16
1284: PPUSH
1285: LD_INT 11
1287: PPUSH
1288: CALL_OW 120
// ComEnterUnit ( maker_2 , factory2 ) ;
1292: LD_INT 46
1294: PPUSH
1295: LD_INT 10
1297: PPUSH
1298: CALL_OW 120
// ComEnterUnit ( sci1 , labor1 ) ;
1302: LD_INT 18
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: CALL_OW 120
// ComHold ( am1 ) ;
1312: LD_INT 2
1314: PPUSH
1315: CALL_OW 140
// SetAttitude ( russians , you , att_friend , true ) ;
1319: LD_EXP 2
1323: PPUSH
1324: LD_EXP 1
1328: PPUSH
1329: LD_INT 1
1331: PPUSH
1332: LD_INT 1
1334: PPUSH
1335: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
1339: LD_EXP 1
1343: PPUSH
1344: LD_EXP 3
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: LD_INT 1
1354: PPUSH
1355: CALL_OW 80
// SetAttitude ( russians , neutral , att_friend , true ) ;
1359: LD_EXP 2
1363: PPUSH
1364: LD_EXP 3
1368: PPUSH
1369: LD_INT 1
1371: PPUSH
1372: LD_INT 1
1374: PPUSH
1375: CALL_OW 80
// disable ( 1 ) ;
1379: LD_INT 1
1381: DISABLE_MARKED
// disable ( 2 ) ;
1382: LD_INT 2
1384: DISABLE_MARKED
// disable ( 3 ) ;
1385: LD_INT 3
1387: DISABLE_MARKED
// disable ( 4 ) ;
1388: LD_INT 4
1390: DISABLE_MARKED
// disable ( 5 ) ;
1391: LD_INT 5
1393: DISABLE_MARKED
// disable ( 7 ) ;
1394: LD_INT 7
1396: DISABLE_MARKED
// disable ( 8 ) ;
1397: LD_INT 8
1399: DISABLE_MARKED
// disable ( 10 ) ;
1400: LD_INT 10
1402: DISABLE_MARKED
// enable ( 11 ) ;
1403: LD_INT 11
1405: ENABLE_MARKED
// end ;
1406: LD_VAR 0 1
1410: RET
// starting begin interface_hidden := true ;
1411: LD_ADDR_OWVAR 54
1415: PUSH
1416: LD_INT 1
1418: ST_TO_ADDR
// RandomizeAll ;
1419: CALL_OW 11
// prepare_sides ;
1423: CALL 1018 0 0
// prepare_russian_side ;
1427: CALL 12868 0 0
// fix_difficulty ;
1431: CALL 14381 0 0
// prepare_units ;
1435: CALL 0 0 0
// starting_scene ;
1439: CALL 8426 0 0
// init_hints ;
1443: CALL 14734 0 0
// run_ru_guarding ;
1447: CALL 3954 0 0
// end ;
1451: END
// every 0 0$5 trigger TICK >= time_crates do
1452: LD_OWVAR 1
1456: PUSH
1457: LD_LOC 1
1461: GREATEREQUAL
1462: IFFALSE 1511
1464: GO 1466
1466: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 3 ) , Am_Base , true ) ;
1467: LD_INT 2
1469: PPUSH
1470: LD_INT 3
1472: PPUSH
1473: CALL_OW 12
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: CALL_OW 55
// time_crates := TICK + Rand ( 0 0$50 , 0 0$100 ) ;
1488: LD_ADDR_LOC 1
1492: PUSH
1493: LD_OWVAR 1
1497: PUSH
1498: LD_INT 1750
1500: PPUSH
1501: LD_INT 3500
1503: PPUSH
1504: CALL_OW 12
1508: PLUS
1509: ST_TO_ADDR
// enable ;
1510: ENABLE
// end ;
1511: END
// function Konec_Mise ; var m1 , m2 , m3 , dying_units , units_for_save ; begin
1512: LD_INT 0
1514: PPUSH
1515: PPUSH
1516: PPUSH
1517: PPUSH
1518: PPUSH
1519: PPUSH
// wait ( 5 ) ;
1520: LD_INT 5
1522: PPUSH
1523: CALL_OW 67
// gained_medals := [ ] ;
1527: LD_ADDR_OWVAR 61
1531: PUSH
1532: EMPTY
1533: ST_TO_ADDR
// missing_medals := [ ] ;
1534: LD_ADDR_OWVAR 62
1538: PUSH
1539: EMPTY
1540: ST_TO_ADDR
// dying_units := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_ok ] ] ) diff MacMillan ;
1541: LD_ADDR_VAR 0 5
1545: PUSH
1546: LD_INT 22
1548: PUSH
1549: LD_EXP 1
1553: PUSH
1554: EMPTY
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: LD_INT 3
1570: PUSH
1571: LD_INT 50
1573: PUSH
1574: EMPTY
1575: LIST
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: PPUSH
1583: CALL_OW 69
1587: PUSH
1588: LD_EXP 7
1592: DIFF
1593: ST_TO_ADDR
// mrtvi_lide := mrtvi_lide + dying_units ;
1594: LD_ADDR_EXP 18
1598: PUSH
1599: LD_EXP 18
1603: PUSH
1604: LD_VAR 0 5
1608: PLUS
1609: ST_TO_ADDR
// saved_units := saved_units diff mrtvi_lide ;
1610: LD_ADDR_EXP 17
1614: PUSH
1615: LD_EXP 17
1619: PUSH
1620: LD_EXP 18
1624: DIFF
1625: ST_TO_ADDR
// if IsDead ( MacMillan ) or IsDying ( MacMillan ) then
1626: LD_EXP 7
1630: PPUSH
1631: CALL_OW 301
1635: PUSH
1636: LD_EXP 7
1640: PPUSH
1641: CALL_OW 303
1645: OR
1646: IFFALSE 1657
// begin YouLost ( 0 ) ;
1648: LD_STRING 0
1650: PPUSH
1651: CALL_OW 104
// exit ;
1655: GO 2108
// end ; if saved_units and not base_reached then
1657: LD_EXP 17
1661: PUSH
1662: LD_EXP 45
1666: NOT
1667: AND
1668: IFFALSE 1679
// begin YouLost ( 4 ) ;
1670: LD_STRING 4
1672: PPUSH
1673: CALL_OW 104
// exit ;
1677: GO 2108
// end ; if saved_units < 4 then
1679: LD_EXP 17
1683: PUSH
1684: LD_INT 4
1686: LESS
1687: IFFALSE 1698
// begin YouLost ( 1 ) ;
1689: LD_STRING 1
1691: PPUSH
1692: CALL_OW 104
// exit ;
1696: GO 2108
// end ; if IsOK ( MacMillan ) then
1698: LD_EXP 7
1702: PPUSH
1703: CALL_OW 302
1707: IFFALSE 1755
// begin m1 := IsInUnit ( MacMillan ) ;
1709: LD_ADDR_VAR 0 2
1713: PUSH
1714: LD_EXP 7
1718: PPUSH
1719: CALL_OW 310
1723: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
1724: LD_EXP 7
1728: PPUSH
1729: CALL_OW 64
// if m1 then
1733: LD_VAR 0 2
1737: IFFALSE 1748
// RemoveUnit ( m1 ) ;
1739: LD_VAR 0 2
1743: PPUSH
1744: CALL_OW 64
// wait ( 20 ) ;
1748: LD_INT 20
1750: PPUSH
1751: CALL_OW 67
// end ; AddMedal ( No , not mrtvi_lide ) ;
1755: LD_STRING No
1757: PPUSH
1758: LD_EXP 18
1762: NOT
1763: PPUSH
1764: CALL_OW 101
// AddMedal ( Solar1 , solar_constructed ) ;
1768: LD_STRING Solar1
1770: PPUSH
1771: LD_EXP 42
1775: PPUSH
1776: CALL_OW 101
// if solar_constructed then
1780: LD_EXP 42
1784: IFFALSE 1817
// begin if solar_saved then
1786: LD_EXP 43
1790: IFFALSE 1804
// AddMedal ( Solar2 , 1 ) else
1792: LD_STRING Solar2
1794: PPUSH
1795: LD_INT 1
1797: PPUSH
1798: CALL_OW 101
1802: GO 1815
// AddMedal ( Solar2 , - 2 ) ;
1804: LD_STRING Solar2
1806: PPUSH
1807: LD_INT 2
1809: NEG
1810: PPUSH
1811: CALL_OW 101
// end else
1815: GO 1828
// AddMedal ( Solar2 , - 1 ) ;
1817: LD_STRING Solar2
1819: PPUSH
1820: LD_INT 1
1822: NEG
1823: PPUSH
1824: CALL_OW 101
// GiveMedals ( Main ) ;
1828: LD_STRING Main
1830: PPUSH
1831: CALL_OW 102
// saved_units := saved_units diff 0 ;
1835: LD_ADDR_EXP 17
1839: PUSH
1840: LD_EXP 17
1844: PUSH
1845: LD_INT 0
1847: DIFF
1848: ST_TO_ADDR
// if Meet_Frank then
1849: LD_EXP 44
1853: IFFALSE 1871
// saved_units := saved_units union Frank ;
1855: LD_ADDR_EXP 17
1859: PUSH
1860: LD_EXP 17
1864: PUSH
1865: LD_EXP 11
1869: UNION
1870: ST_TO_ADDR
// RewardPeople ( saved_units union MacMillan ) ;
1871: LD_EXP 17
1875: PUSH
1876: LD_EXP 7
1880: UNION
1881: PPUSH
1882: CALL_OW 43
// DeleteVariable ( us2cans ) ;
1886: LD_STRING us2cans
1888: PPUSH
1889: CALL_OW 41
// DeleteVariable ( us2JMMInVehicle ) ;
1893: LD_STRING us2JMMInVehicle
1895: PPUSH
1896: CALL_OW 41
// DeleteVariable ( us2CyrusInVehicle ) ;
1900: LD_STRING us2CyrusInVehicle
1902: PPUSH
1903: CALL_OW 41
// SaveCharacters ( MacMillan , JMM ) ;
1907: LD_EXP 7
1911: PPUSH
1912: LD_STRING JMM
1914: PPUSH
1915: CALL_OW 38
// SaveCharacters ( Cyrus , Cyrus ) ;
1919: LD_EXP 5
1923: PPUSH
1924: LD_STRING Cyrus
1926: PPUSH
1927: CALL_OW 38
// SaveCharacters ( Bobby , Bobby ) ;
1931: LD_EXP 4
1935: PPUSH
1936: LD_STRING Bobby
1938: PPUSH
1939: CALL_OW 38
// SaveCharacters ( Lisa , Lisa ) ;
1943: LD_EXP 6
1947: PPUSH
1948: LD_STRING Lisa
1950: PPUSH
1951: CALL_OW 38
// SaveCharacters ( Khatam , Khatam ) ;
1955: LD_EXP 10
1959: PPUSH
1960: LD_STRING Khatam
1962: PPUSH
1963: CALL_OW 38
// if Meet_Frank then
1967: LD_EXP 44
1971: IFFALSE 1985
// SaveCharacters ( Frank , Frank ) ;
1973: LD_EXP 11
1977: PPUSH
1978: LD_STRING Frank
1980: PPUSH
1981: CALL_OW 38
// SaveCharacters ( Mikhail , Mikhail ) ;
1985: LD_EXP 21
1989: PPUSH
1990: LD_STRING Mikhail
1992: PPUSH
1993: CALL_OW 38
// SaveCharacters ( Cornell , Cornell ) ;
1997: LD_EXP 8
2001: PPUSH
2002: LD_STRING Cornell
2004: PPUSH
2005: CALL_OW 38
// units_for_save := other_survivors ^ saved_units ;
2009: LD_ADDR_VAR 0 6
2013: PUSH
2014: LD_EXP 13
2018: PUSH
2019: LD_EXP 17
2023: ADD
2024: ST_TO_ADDR
// units_for_save := units_for_save diff [ MacMillan , Frank , Cyrus , Bobby , Lisa , Khatam ] ;
2025: LD_ADDR_VAR 0 6
2029: PUSH
2030: LD_VAR 0 6
2034: PUSH
2035: LD_EXP 7
2039: PUSH
2040: LD_EXP 11
2044: PUSH
2045: LD_EXP 5
2049: PUSH
2050: LD_EXP 4
2054: PUSH
2055: LD_EXP 6
2059: PUSH
2060: LD_EXP 10
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: LIST
2071: LIST
2072: DIFF
2073: ST_TO_ADDR
// units_for_save := units_for_save union units_for_save ;
2074: LD_ADDR_VAR 0 6
2078: PUSH
2079: LD_VAR 0 6
2083: PUSH
2084: LD_VAR 0 6
2088: UNION
2089: ST_TO_ADDR
// SaveCharacters ( units_for_save , other_survivors ) ;
2090: LD_VAR 0 6
2094: PPUSH
2095: LD_STRING other_survivors
2097: PPUSH
2098: CALL_OW 38
// YouWin ;
2102: CALL_OW 103
// exit ;
2106: GO 2108
// end ;
2108: LD_VAR 0 1
2112: RET
// function return_of_frank ; var koncova_area ; begin
2113: LD_INT 0
2115: PPUSH
2116: PPUSH
// koncova_area := true ;
2117: LD_ADDR_VAR 0 2
2121: PUSH
2122: LD_INT 1
2124: ST_TO_ADDR
// SetSide ( Frank , you ) ;
2125: LD_EXP 11
2129: PPUSH
2130: LD_EXP 1
2134: PPUSH
2135: CALL_OW 235
// case koncova_area of IsInArea ( MacMillan , Top_1 ) :
2139: LD_VAR 0 2
2143: PUSH
2144: LD_EXP 7
2148: PPUSH
2149: LD_INT 13
2151: PPUSH
2152: CALL_OW 308
2156: DOUBLE
2157: EQUAL
2158: IFTRUE 2162
2160: GO 2180
2162: POP
// PlaceUnitArea ( Frank , frank_1 , false ) ; IsInArea ( MacMillan , Top_2 ) :
2163: LD_EXP 11
2167: PPUSH
2168: LD_INT 21
2170: PPUSH
2171: LD_INT 0
2173: PPUSH
2174: CALL_OW 49
2178: GO 2361
2180: LD_EXP 7
2184: PPUSH
2185: LD_INT 14
2187: PPUSH
2188: CALL_OW 308
2192: DOUBLE
2193: EQUAL
2194: IFTRUE 2198
2196: GO 2216
2198: POP
// PlaceUnitArea ( Frank , frank_2 , false ) ; IsInArea ( MacMillan , Top_3 ) :
2199: LD_EXP 11
2203: PPUSH
2204: LD_INT 22
2206: PPUSH
2207: LD_INT 0
2209: PPUSH
2210: CALL_OW 49
2214: GO 2361
2216: LD_EXP 7
2220: PPUSH
2221: LD_INT 15
2223: PPUSH
2224: CALL_OW 308
2228: DOUBLE
2229: EQUAL
2230: IFTRUE 2234
2232: GO 2252
2234: POP
// PlaceUnitArea ( Frank , frank_3 , false ) ; IsInArea ( MacMillan , Top_4 ) :
2235: LD_EXP 11
2239: PPUSH
2240: LD_INT 23
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
2250: GO 2361
2252: LD_EXP 7
2256: PPUSH
2257: LD_INT 16
2259: PPUSH
2260: CALL_OW 308
2264: DOUBLE
2265: EQUAL
2266: IFTRUE 2270
2268: GO 2288
2270: POP
// PlaceUnitArea ( Frank , frank_4 , false ) ; IsInArea ( MacMillan , Top_5 ) :
2271: LD_EXP 11
2275: PPUSH
2276: LD_INT 24
2278: PPUSH
2279: LD_INT 0
2281: PPUSH
2282: CALL_OW 49
2286: GO 2361
2288: LD_EXP 7
2292: PPUSH
2293: LD_INT 17
2295: PPUSH
2296: CALL_OW 308
2300: DOUBLE
2301: EQUAL
2302: IFTRUE 2306
2304: GO 2324
2306: POP
// PlaceUnitArea ( Frank , frank_5 , false ) ; IsInArea ( MacMillan , Top_6 ) :
2307: LD_EXP 11
2311: PPUSH
2312: LD_INT 25
2314: PPUSH
2315: LD_INT 0
2317: PPUSH
2318: CALL_OW 49
2322: GO 2361
2324: LD_EXP 7
2328: PPUSH
2329: LD_INT 18
2331: PPUSH
2332: CALL_OW 308
2336: DOUBLE
2337: EQUAL
2338: IFTRUE 2342
2340: GO 2360
2342: POP
// PlaceUnitArea ( Frank , frank_6 , false ) ; end ;
2343: LD_EXP 11
2347: PPUSH
2348: LD_INT 26
2350: PPUSH
2351: LD_INT 0
2353: PPUSH
2354: CALL_OW 49
2358: GO 2361
2360: POP
// wait ( 10 ) ;
2361: LD_INT 10
2363: PPUSH
2364: CALL_OW 67
// ComRemember ( Frank ) ;
2368: LD_EXP 11
2372: PPUSH
2373: CALL_OW 143
// ComMoveUnit ( Frank , MacMillan ) ;
2377: LD_EXP 11
2381: PPUSH
2382: LD_EXP 7
2386: PPUSH
2387: CALL_OW 112
// Wait ( 0 0$2 ) ;
2391: LD_INT 70
2393: PPUSH
2394: CALL_OW 67
// ComStop ( Frank ) ;
2398: LD_EXP 11
2402: PPUSH
2403: CALL_OW 141
// ComTurnUnit ( Frank , MacMillan ) ;
2407: LD_EXP 11
2411: PPUSH
2412: LD_EXP 7
2416: PPUSH
2417: CALL_OW 119
// CenterOnUnits ( Frank ) ;
2421: LD_EXP 11
2425: PPUSH
2426: CALL_OW 85
// wait ( 20 ) ;
2430: LD_INT 20
2432: PPUSH
2433: CALL_OW 67
// DialogueOn ;
2437: CALL_OW 6
// interface_hidden := true ;
2441: LD_ADDR_OWVAR 54
2445: PUSH
2446: LD_INT 1
2448: ST_TO_ADDR
// Say ( Frank , D6a-Frank-1 ) ;
2449: LD_EXP 11
2453: PPUSH
2454: LD_STRING D6a-Frank-1
2456: PPUSH
2457: CALL_OW 88
// interface_hidden := false ;
2461: LD_ADDR_OWVAR 54
2465: PUSH
2466: LD_INT 0
2468: ST_TO_ADDR
// DialogueOff ;
2469: CALL_OW 7
// ComReturn ( Frank ) ;
2473: LD_EXP 11
2477: PPUSH
2478: CALL_OW 144
// repeat wait ( 10 ) ;
2482: LD_INT 10
2484: PPUSH
2485: CALL_OW 67
// if GetLives ( Frank ) < 900 then
2489: LD_EXP 11
2493: PPUSH
2494: CALL_OW 256
2498: PUSH
2499: LD_INT 900
2501: LESS
2502: IFFALSE 2527
// SetLives ( Frank , GetLives ( Frank ) + 50 ) ;
2504: LD_EXP 11
2508: PPUSH
2509: LD_EXP 11
2513: PPUSH
2514: CALL_OW 256
2518: PUSH
2519: LD_INT 50
2521: PLUS
2522: PPUSH
2523: CALL_OW 234
// until not HasTask ( Frank ) ;
2527: LD_EXP 11
2531: PPUSH
2532: CALL_OW 314
2536: NOT
2537: IFFALSE 2482
// RemoveUnit ( Frank ) ;
2539: LD_EXP 11
2543: PPUSH
2544: CALL_OW 64
// end ;
2548: LD_VAR 0 1
2552: RET
// export function GridY ( un ) ; var veh , grid ; begin
2553: LD_INT 0
2555: PPUSH
2556: PPUSH
2557: PPUSH
// veh := false ;
2558: LD_ADDR_VAR 0 3
2562: PUSH
2563: LD_INT 0
2565: ST_TO_ADDR
// veh := IsInUnit ( un ) ;
2566: LD_ADDR_VAR 0 3
2570: PUSH
2571: LD_VAR 0 1
2575: PPUSH
2576: CALL_OW 310
2580: ST_TO_ADDR
// if veh then
2581: LD_VAR 0 3
2585: IFFALSE 2604
// grid := GetY ( veh ) else
2587: LD_ADDR_VAR 0 4
2591: PUSH
2592: LD_VAR 0 3
2596: PPUSH
2597: CALL_OW 251
2601: ST_TO_ADDR
2602: GO 2619
// grid := GetY ( un ) ;
2604: LD_ADDR_VAR 0 4
2608: PUSH
2609: LD_VAR 0 1
2613: PPUSH
2614: CALL_OW 251
2618: ST_TO_ADDR
// result := grid ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_VAR 0 4
2628: ST_TO_ADDR
// end ;
2629: LD_VAR 0 2
2633: RET
// every 0 0$1 trigger GridY ( MacMillan ) < 18 do var un ;
2634: LD_EXP 7
2638: PPUSH
2639: CALL 2553 0 1
2643: PUSH
2644: LD_INT 18
2646: LESS
2647: IFFALSE 2676
2649: GO 2651
2651: DISABLE
2652: LD_INT 0
2654: PPUSH
// begin if GetSide ( Frank ) = neutral then
2655: LD_EXP 11
2659: PPUSH
2660: CALL_OW 255
2664: PUSH
2665: LD_EXP 3
2669: EQUAL
2670: IFFALSE 2676
// return_of_frank ;
2672: CALL 2113 0 0
// end ;
2676: PPOPN 1
2678: END
// on UnitDestroyed ( un ) do begin if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_human ) then
2679: LD_VAR 0 1
2683: PPUSH
2684: CALL_OW 255
2688: PUSH
2689: LD_EXP 1
2693: EQUAL
2694: PUSH
2695: LD_VAR 0 1
2699: PPUSH
2700: CALL_OW 247
2704: PUSH
2705: LD_INT 1
2707: EQUAL
2708: AND
2709: IFFALSE 2725
// mrtvi_lide := mrtvi_lide + 1 ;
2711: LD_ADDR_EXP 18
2715: PUSH
2716: LD_EXP 18
2720: PUSH
2721: LD_INT 1
2723: PLUS
2724: ST_TO_ADDR
// if un = MacMillan then
2725: LD_VAR 0 1
2729: PUSH
2730: LD_EXP 7
2734: EQUAL
2735: IFFALSE 2741
// Konec_Mise ;
2737: CALL 1512 0 0
// if un = sklad then
2741: LD_VAR 0 1
2745: PUSH
2746: LD_INT 5
2748: EQUAL
2749: IFFALSE 2760
// begin YouLost ( 2 ) ;
2751: LD_STRING 2
2753: PPUSH
2754: CALL_OW 104
// exit ;
2758: GO 2776
// end ; ru_trucks := ru_trucks diff un ;
2760: LD_ADDR_EXP 48
2764: PUSH
2765: LD_EXP 48
2769: PUSH
2770: LD_VAR 0 1
2774: DIFF
2775: ST_TO_ADDR
// end ;
2776: PPOPN 1
2778: END
// every 0 0$5.1 do
2779: GO 2781
2781: DISABLE
// begin if ( ( FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_ok ] , [ f_type , unit_human ] ] ) diff MacMillan ) + saved_units ) < 4 then
2782: LD_INT 23
2784: PUSH
2785: LD_INT 1
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: LD_INT 50
2794: PUSH
2795: EMPTY
2796: LIST
2797: PUSH
2798: LD_INT 21
2800: PUSH
2801: LD_INT 1
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: LIST
2812: PPUSH
2813: CALL_OW 69
2817: PUSH
2818: LD_EXP 7
2822: DIFF
2823: PUSH
2824: LD_EXP 17
2828: PLUS
2829: PUSH
2830: LD_INT 4
2832: LESS
2833: IFFALSE 2839
// Konec_Mise ;
2835: CALL 1512 0 0
// enable ;
2839: ENABLE
// end ;
2840: END
// every 0 0$1 trigger IsInArea ( MacMillan , TopBorder ) or IsInArea ( IsInUnit ( MacMillan ) , TopBorder ) do var un , list , car , isin , living ;
2841: LD_EXP 7
2845: PPUSH
2846: LD_INT 1
2848: PPUSH
2849: CALL_OW 308
2853: PUSH
2854: LD_EXP 7
2858: PPUSH
2859: CALL_OW 310
2863: PPUSH
2864: LD_INT 1
2866: PPUSH
2867: CALL_OW 308
2871: OR
2872: IFFALSE 3405
2874: GO 2876
2876: DISABLE
2877: LD_INT 0
2879: PPUSH
2880: PPUSH
2881: PPUSH
2882: PPUSH
2883: PPUSH
// begin living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
2884: LD_ADDR_VAR 0 5
2888: PUSH
2889: LD_INT 22
2891: PUSH
2892: LD_EXP 1
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 21
2903: PUSH
2904: LD_INT 1
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PUSH
2911: LD_INT 50
2913: PUSH
2914: EMPTY
2915: LIST
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: LIST
2921: PPUSH
2922: CALL_OW 69
2926: PUSH
2927: LD_EXP 7
2931: DIFF
2932: ST_TO_ADDR
// car := IsInUnit ( MacMillan ) ;
2933: LD_ADDR_VAR 0 3
2937: PUSH
2938: LD_EXP 7
2942: PPUSH
2943: CALL_OW 310
2947: ST_TO_ADDR
// if not living then
2948: LD_VAR 0 5
2952: NOT
2953: IFFALSE 3010
// begin RemoveUnit ( MacMillan ) ;
2955: LD_EXP 7
2959: PPUSH
2960: CALL_OW 64
// if car then
2964: LD_VAR 0 3
2968: IFFALSE 3002
// begin if GetEngine ( car ) = engine_solar then
2970: LD_VAR 0 3
2974: PPUSH
2975: CALL_OW 262
2979: PUSH
2980: LD_INT 2
2982: EQUAL
2983: IFFALSE 2993
// solar_saved := true ;
2985: LD_ADDR_EXP 43
2989: PUSH
2990: LD_INT 1
2992: ST_TO_ADDR
// RemoveUnit ( car ) ;
2993: LD_VAR 0 3
2997: PPUSH
2998: CALL_OW 64
// end ; Konec_mise ;
3002: CALL 1512 0 0
// exit ;
3006: GO 3405
// end else
3008: GO 3404
// if Query ( Q2 ) = 1 then
3010: LD_STRING Q2
3012: PPUSH
3013: CALL_OW 97
3017: PUSH
3018: LD_INT 1
3020: EQUAL
3021: IFFALSE 3186
// begin repeat wait ( 0 0$1 ) ;
3023: LD_INT 35
3025: PPUSH
3026: CALL_OW 67
// living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
3030: LD_ADDR_VAR 0 5
3034: PUSH
3035: LD_INT 22
3037: PUSH
3038: LD_EXP 1
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: PUSH
3047: LD_INT 21
3049: PUSH
3050: LD_INT 1
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 50
3059: PUSH
3060: EMPTY
3061: LIST
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PPUSH
3068: CALL_OW 69
3072: PUSH
3073: LD_EXP 7
3077: DIFF
3078: ST_TO_ADDR
// isin := IsInArea ( MacMillan , TopBorder ) ;
3079: LD_ADDR_VAR 0 4
3083: PUSH
3084: LD_EXP 7
3088: PPUSH
3089: LD_INT 1
3091: PPUSH
3092: CALL_OW 308
3096: ST_TO_ADDR
// until not ( living and isin ) ;
3097: LD_VAR 0 5
3101: PUSH
3102: LD_VAR 0 4
3106: AND
3107: NOT
3108: IFFALSE 3023
// if isin then
3110: LD_VAR 0 4
3114: IFFALSE 3184
// begin car := IsInUnit ( MacMillan ) ;
3116: LD_ADDR_VAR 0 3
3120: PUSH
3121: LD_EXP 7
3125: PPUSH
3126: CALL_OW 310
3130: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
3131: LD_EXP 7
3135: PPUSH
3136: CALL_OW 64
// if car then
3140: LD_VAR 0 3
3144: IFFALSE 3178
// begin if GetEngine ( car ) = engine_solar then
3146: LD_VAR 0 3
3150: PPUSH
3151: CALL_OW 262
3155: PUSH
3156: LD_INT 2
3158: EQUAL
3159: IFFALSE 3169
// solar_saved := true ;
3161: LD_ADDR_EXP 43
3165: PUSH
3166: LD_INT 1
3168: ST_TO_ADDR
// RemoveUnit ( car ) ;
3169: LD_VAR 0 3
3173: PPUSH
3174: CALL_OW 64
// end ; Konec_mise ;
3178: CALL 1512 0 0
// exit ;
3182: GO 3405
// end ; end else
3184: GO 3404
// begin RemoveUnit ( MacMillan ) ;
3186: LD_EXP 7
3190: PPUSH
3191: CALL_OW 64
// if car then
3195: LD_VAR 0 3
3199: IFFALSE 3233
// begin if GetEngine ( car ) = engine_solar then
3201: LD_VAR 0 3
3205: PPUSH
3206: CALL_OW 262
3210: PUSH
3211: LD_INT 2
3213: EQUAL
3214: IFFALSE 3224
// solar_saved := true ;
3216: LD_ADDR_EXP 43
3220: PUSH
3221: LD_INT 1
3223: ST_TO_ADDR
// RemoveUnit ( car ) ;
3224: LD_VAR 0 3
3228: PPUSH
3229: CALL_OW 64
// end ; ingame_video := true ;
3233: LD_ADDR_OWVAR 52
3237: PUSH
3238: LD_INT 1
3240: ST_TO_ADDR
// interface_hidden := true ;
3241: LD_ADDR_OWVAR 54
3245: PUSH
3246: LD_INT 1
3248: ST_TO_ADDR
// repeat living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3249: LD_ADDR_VAR 0 5
3253: PUSH
3254: LD_INT 22
3256: PUSH
3257: LD_EXP 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 21
3268: PUSH
3269: LD_INT 1
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 50
3278: PUSH
3279: EMPTY
3280: LIST
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: PPUSH
3287: CALL_OW 69
3291: ST_TO_ADDR
// CenterOnNorthestUnit ( living ) ;
3292: LD_VAR 0 5
3296: PPUSH
3297: CALL 3408 0 1
// for un in living do
3301: LD_ADDR_VAR 0 1
3305: PUSH
3306: LD_VAR 0 5
3310: PUSH
3311: FOR_IN
3312: IFFALSE 3374
// ComMoveXY ( un , GetX ( un ) - ( GetY ( un ) div 2 ) + Rand ( - 3 , 3 ) , Rand ( 1 , 2 ) ) ;
3314: LD_VAR 0 1
3318: PPUSH
3319: LD_VAR 0 1
3323: PPUSH
3324: CALL_OW 250
3328: PUSH
3329: LD_VAR 0 1
3333: PPUSH
3334: CALL_OW 251
3338: PUSH
3339: LD_INT 2
3341: DIV
3342: MINUS
3343: PUSH
3344: LD_INT 3
3346: NEG
3347: PPUSH
3348: LD_INT 3
3350: PPUSH
3351: CALL_OW 12
3355: PLUS
3356: PPUSH
3357: LD_INT 1
3359: PPUSH
3360: LD_INT 2
3362: PPUSH
3363: CALL_OW 12
3367: PPUSH
3368: CALL_OW 111
3372: GO 3311
3374: POP
3375: POP
// wait ( 0 0$3 ) ;
3376: LD_INT 105
3378: PPUSH
3379: CALL_OW 67
// until not living ;
3383: LD_VAR 0 5
3387: NOT
3388: IFFALSE 3249
// ingame_video := false ;
3390: LD_ADDR_OWVAR 52
3394: PUSH
3395: LD_INT 0
3397: ST_TO_ADDR
// Konec_mise ;
3398: CALL 1512 0 0
// exit ;
3402: GO 3405
// end ; enable ;
3404: ENABLE
// end ;
3405: PPOPN 5
3407: END
// function CenterOnNorthestUnit ( list ) ; var un , north , x , y , car ; begin
3408: LD_INT 0
3410: PPUSH
3411: PPUSH
3412: PPUSH
3413: PPUSH
3414: PPUSH
3415: PPUSH
// north := 200 ;
3416: LD_ADDR_VAR 0 4
3420: PUSH
3421: LD_INT 200
3423: ST_TO_ADDR
// for un in list do
3424: LD_ADDR_VAR 0 3
3428: PUSH
3429: LD_VAR 0 1
3433: PUSH
3434: FOR_IN
3435: IFFALSE 3544
// begin car := IsInUnit ( un ) ;
3437: LD_ADDR_VAR 0 7
3441: PUSH
3442: LD_VAR 0 3
3446: PPUSH
3447: CALL_OW 310
3451: ST_TO_ADDR
// if car then
3452: LD_VAR 0 7
3456: IFFALSE 3490
// begin x := GetX ( car ) ;
3458: LD_ADDR_VAR 0 5
3462: PUSH
3463: LD_VAR 0 7
3467: PPUSH
3468: CALL_OW 250
3472: ST_TO_ADDR
// y := GetY ( car ) ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 7
3482: PPUSH
3483: CALL_OW 251
3487: ST_TO_ADDR
// end else
3488: GO 3520
// begin x := GetX ( un ) ;
3490: LD_ADDR_VAR 0 5
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: CALL_OW 250
3504: ST_TO_ADDR
// y := GetY ( un ) ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 3
3514: PPUSH
3515: CALL_OW 251
3519: ST_TO_ADDR
// end ; if y < north then
3520: LD_VAR 0 6
3524: PUSH
3525: LD_VAR 0 4
3529: LESS
3530: IFFALSE 3542
// north := un ;
3532: LD_ADDR_VAR 0 4
3536: PUSH
3537: LD_VAR 0 3
3541: ST_TO_ADDR
// end ;
3542: GO 3434
3544: POP
3545: POP
// CenterOnXY ( x - 2 , y - 4 ) ;
3546: LD_VAR 0 5
3550: PUSH
3551: LD_INT 2
3553: MINUS
3554: PPUSH
3555: LD_VAR 0 6
3559: PUSH
3560: LD_INT 4
3562: MINUS
3563: PPUSH
3564: CALL_OW 84
// end ;
3568: LD_VAR 0 2
3572: RET
// every 0 0$1 trigger FilterUnitsInArea ( TopBorder , [ [ f_side , you ] ] ) do var un , car , list ;
3573: LD_INT 1
3575: PPUSH
3576: LD_INT 22
3578: PUSH
3579: LD_EXP 1
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PUSH
3588: EMPTY
3589: LIST
3590: PPUSH
3591: CALL_OW 70
3595: IFFALSE 3951
3597: GO 3599
3599: DISABLE
3600: LD_INT 0
3602: PPUSH
3603: PPUSH
3604: PPUSH
// begin list := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3605: LD_ADDR_VAR 0 3
3609: PUSH
3610: LD_INT 1
3612: PPUSH
3613: LD_INT 22
3615: PUSH
3616: LD_EXP 1
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 21
3627: PUSH
3628: LD_INT 1
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 50
3637: PUSH
3638: EMPTY
3639: LIST
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: LIST
3645: PPUSH
3646: CALL_OW 70
3650: ST_TO_ADDR
// car := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
3651: LD_ADDR_VAR 0 2
3655: PUSH
3656: LD_INT 1
3658: PPUSH
3659: LD_INT 22
3661: PUSH
3662: LD_EXP 1
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: PUSH
3671: LD_INT 21
3673: PUSH
3674: LD_INT 2
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 50
3683: PUSH
3684: EMPTY
3685: LIST
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: PPUSH
3692: CALL_OW 70
3696: ST_TO_ADDR
// for un in car do
3697: LD_ADDR_VAR 0 1
3701: PUSH
3702: LD_VAR 0 2
3706: PUSH
3707: FOR_IN
3708: IFFALSE 3744
// if IsDrivenBy ( un ) then
3710: LD_VAR 0 1
3714: PPUSH
3715: CALL_OW 311
3719: IFFALSE 3742
// list := list ^ IsDrivenBy ( un ) ;
3721: LD_ADDR_VAR 0 3
3725: PUSH
3726: LD_VAR 0 3
3730: PUSH
3731: LD_VAR 0 1
3735: PPUSH
3736: CALL_OW 311
3740: ADD
3741: ST_TO_ADDR
3742: GO 3707
3744: POP
3745: POP
// list := list union list ;
3746: LD_ADDR_VAR 0 3
3750: PUSH
3751: LD_VAR 0 3
3755: PUSH
3756: LD_VAR 0 3
3760: UNION
3761: ST_TO_ADDR
// list := list diff [ 0 , MacMillan ] ;
3762: LD_ADDR_VAR 0 3
3766: PUSH
3767: LD_VAR 0 3
3771: PUSH
3772: LD_INT 0
3774: PUSH
3775: LD_EXP 7
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: DIFF
3784: ST_TO_ADDR
// if Frank_Query = 1 then
3785: LD_EXP 47
3789: PUSH
3790: LD_INT 1
3792: EQUAL
3793: IFFALSE 3811
// list := list diff Frank ;
3795: LD_ADDR_VAR 0 3
3799: PUSH
3800: LD_VAR 0 3
3804: PUSH
3805: LD_EXP 11
3809: DIFF
3810: ST_TO_ADDR
// for un in list do
3811: LD_ADDR_VAR 0 1
3815: PUSH
3816: LD_VAR 0 3
3820: PUSH
3821: FOR_IN
3822: IFFALSE 3904
// begin car := IsInUnit ( un ) ;
3824: LD_ADDR_VAR 0 2
3828: PUSH
3829: LD_VAR 0 1
3833: PPUSH
3834: CALL_OW 310
3838: ST_TO_ADDR
// RemoveUnit ( un ) ;
3839: LD_VAR 0 1
3843: PPUSH
3844: CALL_OW 64
// if car then
3848: LD_VAR 0 2
3852: IFFALSE 3886
// begin if GetEngine ( car ) = engine_solar then
3854: LD_VAR 0 2
3858: PPUSH
3859: CALL_OW 262
3863: PUSH
3864: LD_INT 2
3866: EQUAL
3867: IFFALSE 3877
// solar_saved := true ;
3869: LD_ADDR_EXP 43
3873: PUSH
3874: LD_INT 1
3876: ST_TO_ADDR
// RemoveUnit ( car ) ;
3877: LD_VAR 0 2
3881: PPUSH
3882: CALL_OW 64
// end ; saved_units := saved_units union un ;
3886: LD_ADDR_EXP 17
3890: PUSH
3891: LD_EXP 17
3895: PUSH
3896: LD_VAR 0 1
3900: UNION
3901: ST_TO_ADDR
// end ;
3902: GO 3821
3904: POP
3905: POP
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) then
3906: LD_INT 22
3908: PUSH
3909: LD_EXP 1
3913: PUSH
3914: EMPTY
3915: LIST
3916: LIST
3917: PUSH
3918: LD_INT 21
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 50
3930: PUSH
3931: EMPTY
3932: LIST
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: LIST
3938: PPUSH
3939: CALL_OW 69
3943: NOT
3944: IFFALSE 3950
// Konec_mise ;
3946: CALL 1512 0 0
// enable ;
3950: ENABLE
// end ; end_of_file
3951: PPOPN 3
3953: END
// export function run_ru_guarding ; begin
3954: LD_INT 0
3956: PPUSH
// enable ( 1 ) ;
3957: LD_INT 1
3959: ENABLE_MARKED
// end ;
3960: LD_VAR 0 1
3964: RET
// every 0 0$1 marked 1 do var i , south_guard_way ;
3965: GO 3967
3967: DISABLE
3968: LD_INT 0
3970: PPUSH
3971: PPUSH
// begin south_guard_way = [ 119 , 105 , 102 , 88 , 109 , 106 ] ;
3972: LD_ADDR_VAR 0 2
3976: PUSH
3977: LD_INT 119
3979: PUSH
3980: LD_INT 105
3982: PUSH
3983: LD_INT 102
3985: PUSH
3986: LD_INT 88
3988: PUSH
3989: LD_INT 109
3991: PUSH
3992: LD_INT 106
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: LIST
4002: ST_TO_ADDR
// South_russian_patrol := [ s_guard1 , s_guard2 , s_guard3 , s_guard4 ] diff 0 ;
4003: LD_ADDR_EXP 28
4007: PUSH
4008: LD_EXP 50
4012: PUSH
4013: LD_EXP 51
4017: PUSH
4018: LD_EXP 52
4022: PUSH
4023: LD_EXP 53
4027: PUSH
4028: EMPTY
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: PUSH
4034: LD_INT 0
4036: DIFF
4037: ST_TO_ADDR
// repeat for i = 1 to ( south_guard_way div 2 ) do
4038: LD_ADDR_VAR 0 1
4042: PUSH
4043: DOUBLE
4044: LD_INT 1
4046: DEC
4047: ST_TO_ADDR
4048: LD_VAR 0 2
4052: PUSH
4053: LD_INT 2
4055: DIV
4056: PUSH
4057: FOR_TO
4058: IFFALSE 4117
// begin AddComAgressiveMove ( South_russian_patrol , south_guard_way [ ( i * 2 ) - 1 ] , south_guard_way [ ( i * 2 ) ] ) ;
4060: LD_EXP 28
4064: PPUSH
4065: LD_VAR 0 2
4069: PUSH
4070: LD_VAR 0 1
4074: PUSH
4075: LD_INT 2
4077: MUL
4078: PUSH
4079: LD_INT 1
4081: MINUS
4082: ARRAY
4083: PPUSH
4084: LD_VAR 0 2
4088: PUSH
4089: LD_VAR 0 1
4093: PUSH
4094: LD_INT 2
4096: MUL
4097: ARRAY
4098: PPUSH
4099: CALL_OW 174
// AddComWait ( South_russian_patrol , 0 0$2 ) ;
4103: LD_EXP 28
4107: PPUSH
4108: LD_INT 70
4110: PPUSH
4111: CALL_OW 202
// end ;
4115: GO 4057
4117: POP
4118: POP
// repeat wait ( 0 0$2 ) ;
4119: LD_INT 70
4121: PPUSH
4122: CALL_OW 67
// until not ( IsBusy ( s_guard1 ) or IsBusy ( s_guard2 ) or IsBusy ( s_guard3 ) or IsBusy ( s_guard4 ) ) ;
4126: LD_EXP 50
4130: PPUSH
4131: CALL_OW 315
4135: PUSH
4136: LD_EXP 51
4140: PPUSH
4141: CALL_OW 315
4145: OR
4146: PUSH
4147: LD_EXP 52
4151: PPUSH
4152: CALL_OW 315
4156: OR
4157: PUSH
4158: LD_EXP 53
4162: PPUSH
4163: CALL_OW 315
4167: OR
4168: NOT
4169: IFFALSE 4119
// until not ( IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) ) ;
4171: LD_EXP 50
4175: PPUSH
4176: CALL_OW 302
4180: PUSH
4181: LD_EXP 50
4185: PPUSH
4186: CALL_OW 302
4190: OR
4191: PUSH
4192: LD_EXP 50
4196: PPUSH
4197: CALL_OW 302
4201: OR
4202: PUSH
4203: LD_EXP 50
4207: PPUSH
4208: CALL_OW 302
4212: OR
4213: NOT
4214: IFFALSE 4038
// end ;
4216: PPOPN 2
4218: END
// every 0 0$1 marked 1 do var x , y , truck_way , patroll ;
4219: GO 4221
4221: DISABLE
4222: LD_INT 0
4224: PPUSH
4225: PPUSH
4226: PPUSH
4227: PPUSH
// begin truck_way = [ 149 , 116 , 148 , 110 , 146 , 107 , 141 , 102 , 132 , 96 , 127 , 91 , 123 , 85 , 122 , 80 , 127 , 76 , 130 , 68 , 129 , 63 , 124 , 55 , 117 , 47 , 116 , 36 , 114 , 28 , 0 , 114 , 28 , 116 , 36 , 117 , 47 , 124 , 55 , 129 , 63 , 130 , 68 , 127 , 76 , 122 , 80 , 123 , 85 , 127 , 91 , 132 , 96 , 141 , 102 , 146 , 107 , 148 , 110 , - 1 ] ;
4228: LD_ADDR_VAR 0 3
4232: PUSH
4233: LD_INT 149
4235: PUSH
4236: LD_INT 116
4238: PUSH
4239: LD_INT 148
4241: PUSH
4242: LD_INT 110
4244: PUSH
4245: LD_INT 146
4247: PUSH
4248: LD_INT 107
4250: PUSH
4251: LD_INT 141
4253: PUSH
4254: LD_INT 102
4256: PUSH
4257: LD_INT 132
4259: PUSH
4260: LD_INT 96
4262: PUSH
4263: LD_INT 127
4265: PUSH
4266: LD_INT 91
4268: PUSH
4269: LD_INT 123
4271: PUSH
4272: LD_INT 85
4274: PUSH
4275: LD_INT 122
4277: PUSH
4278: LD_INT 80
4280: PUSH
4281: LD_INT 127
4283: PUSH
4284: LD_INT 76
4286: PUSH
4287: LD_INT 130
4289: PUSH
4290: LD_INT 68
4292: PUSH
4293: LD_INT 129
4295: PUSH
4296: LD_INT 63
4298: PUSH
4299: LD_INT 124
4301: PUSH
4302: LD_INT 55
4304: PUSH
4305: LD_INT 117
4307: PUSH
4308: LD_INT 47
4310: PUSH
4311: LD_INT 116
4313: PUSH
4314: LD_INT 36
4316: PUSH
4317: LD_INT 114
4319: PUSH
4320: LD_INT 28
4322: PUSH
4323: LD_INT 0
4325: PUSH
4326: LD_INT 114
4328: PUSH
4329: LD_INT 28
4331: PUSH
4332: LD_INT 116
4334: PUSH
4335: LD_INT 36
4337: PUSH
4338: LD_INT 117
4340: PUSH
4341: LD_INT 47
4343: PUSH
4344: LD_INT 124
4346: PUSH
4347: LD_INT 55
4349: PUSH
4350: LD_INT 129
4352: PUSH
4353: LD_INT 63
4355: PUSH
4356: LD_INT 130
4358: PUSH
4359: LD_INT 68
4361: PUSH
4362: LD_INT 127
4364: PUSH
4365: LD_INT 76
4367: PUSH
4368: LD_INT 122
4370: PUSH
4371: LD_INT 80
4373: PUSH
4374: LD_INT 123
4376: PUSH
4377: LD_INT 85
4379: PUSH
4380: LD_INT 127
4382: PUSH
4383: LD_INT 91
4385: PUSH
4386: LD_INT 132
4388: PUSH
4389: LD_INT 96
4391: PUSH
4392: LD_INT 141
4394: PUSH
4395: LD_INT 102
4397: PUSH
4398: LD_INT 146
4400: PUSH
4401: LD_INT 107
4403: PUSH
4404: LD_INT 148
4406: PUSH
4407: LD_INT 110
4409: PUSH
4410: LD_INT 1
4412: NEG
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: LIST
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: ST_TO_ADDR
// patroll := ru_trucks [ 8 ] ;
4476: LD_ADDR_VAR 0 4
4480: PUSH
4481: LD_EXP 48
4485: PUSH
4486: LD_INT 8
4488: ARRAY
4489: ST_TO_ADDR
// repeat x := - 1 ;
4490: LD_ADDR_VAR 0 1
4494: PUSH
4495: LD_INT 1
4497: NEG
4498: ST_TO_ADDR
// for y in truck_way do
4499: LD_ADDR_VAR 0 2
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: FOR_IN
4510: IFFALSE 4601
// case y of - 1 , 0 :
4512: LD_VAR 0 2
4516: PUSH
4517: LD_INT 1
4519: NEG
4520: DOUBLE
4521: EQUAL
4522: IFTRUE 4532
4524: LD_INT 0
4526: DOUBLE
4527: EQUAL
4528: IFTRUE 4532
4530: GO 4547
4532: POP
// AddComWait ( patroll , 0 0$5 ) ; else
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 175
4540: PPUSH
4541: CALL_OW 202
4545: GO 4599
4547: POP
// if x = - 1 then
4548: LD_VAR 0 1
4552: PUSH
4553: LD_INT 1
4555: NEG
4556: EQUAL
4557: IFFALSE 4571
// x := y else
4559: LD_ADDR_VAR 0 1
4563: PUSH
4564: LD_VAR 0 2
4568: ST_TO_ADDR
4569: GO 4599
// begin AddComAgressiveMove ( patroll , x , y ) ;
4571: LD_VAR 0 4
4575: PPUSH
4576: LD_VAR 0 1
4580: PPUSH
4581: LD_VAR 0 2
4585: PPUSH
4586: CALL_OW 174
// x := - 1 ;
4590: LD_ADDR_VAR 0 1
4594: PUSH
4595: LD_INT 1
4597: NEG
4598: ST_TO_ADDR
// end ; end ;
4599: GO 4509
4601: POP
4602: POP
// repeat if See ( you , patroll ) and See ( russians , MacMillan ) then
4603: LD_EXP 1
4607: PPUSH
4608: LD_VAR 0 4
4612: PPUSH
4613: CALL_OW 292
4617: PUSH
4618: LD_EXP 2
4622: PPUSH
4623: LD_EXP 7
4627: PPUSH
4628: CALL_OW 292
4632: AND
4633: IFFALSE 4720
// repeat if See ( russians , MacMillan ) then
4635: LD_EXP 2
4639: PPUSH
4640: LD_EXP 7
4644: PPUSH
4645: CALL_OW 292
4649: IFFALSE 4680
// ComAgressiveMove ( patroll , GetX ( MacMillan ) , GetY ( MacMillan ) ) ;
4651: LD_VAR 0 4
4655: PPUSH
4656: LD_EXP 7
4660: PPUSH
4661: CALL_OW 250
4665: PPUSH
4666: LD_EXP 7
4670: PPUSH
4671: CALL_OW 251
4675: PPUSH
4676: CALL_OW 114
// wait ( 0 0$1 ) ;
4680: LD_INT 35
4682: PPUSH
4683: CALL_OW 67
// until not ( See ( russians , MacMillan ) or See ( russians , Bobby ) ) ;
4687: LD_EXP 2
4691: PPUSH
4692: LD_EXP 7
4696: PPUSH
4697: CALL_OW 292
4701: PUSH
4702: LD_EXP 2
4706: PPUSH
4707: LD_EXP 4
4711: PPUSH
4712: CALL_OW 292
4716: OR
4717: NOT
4718: IFFALSE 4635
// wait ( 0 0$1 ) ;
4720: LD_INT 35
4722: PPUSH
4723: CALL_OW 67
// until not IsBusy ( patroll ) ;
4727: LD_VAR 0 4
4731: PPUSH
4732: CALL_OW 315
4736: NOT
4737: IFFALSE 4603
// if ( atack = 1 and GetSide ( patroll ) = russians ) then
4739: LD_EXP 16
4743: PUSH
4744: LD_INT 1
4746: EQUAL
4747: PUSH
4748: LD_VAR 0 4
4752: PPUSH
4753: CALL_OW 255
4757: PUSH
4758: LD_EXP 2
4762: EQUAL
4763: AND
4764: IFFALSE 4783
// repeat wait ( 0 0$2 ) ;
4766: LD_INT 70
4768: PPUSH
4769: CALL_OW 67
// until atack = 0 ;
4773: LD_EXP 16
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4766
// until not IsOK ( patroll ) ;
4783: LD_VAR 0 4
4787: PPUSH
4788: CALL_OW 302
4792: NOT
4793: IFFALSE 4490
// end ;
4795: PPOPN 4
4797: END
// every 0 0$1 marked 1 do var x , y , forest_way1 ;
4798: GO 4800
4800: DISABLE
4801: LD_INT 0
4803: PPUSH
4804: PPUSH
4805: PPUSH
// begin forest_way1 = [ 27 , 45 , - 1 , 38 , 49 , 40 , 34 , - 1 , - 1 , 38 , 49 , 27 , 45 , - 1 ] ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: LD_INT 27
4813: PUSH
4814: LD_INT 45
4816: PUSH
4817: LD_INT 1
4819: NEG
4820: PUSH
4821: LD_INT 38
4823: PUSH
4824: LD_INT 49
4826: PUSH
4827: LD_INT 40
4829: PUSH
4830: LD_INT 34
4832: PUSH
4833: LD_INT 1
4835: NEG
4836: PUSH
4837: LD_INT 1
4839: NEG
4840: PUSH
4841: LD_INT 38
4843: PUSH
4844: LD_INT 49
4846: PUSH
4847: LD_INT 27
4849: PUSH
4850: LD_INT 45
4852: PUSH
4853: LD_INT 1
4855: NEG
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: ST_TO_ADDR
// repeat x := - 1 ;
4873: LD_ADDR_VAR 0 1
4877: PUSH
4878: LD_INT 1
4880: NEG
4881: ST_TO_ADDR
// for y in forest_way1 do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: LD_VAR 0 3
4891: PUSH
4892: FOR_IN
4893: IFFALSE 4978
// case y of - 1 :
4895: LD_VAR 0 2
4899: PUSH
4900: LD_INT 1
4902: NEG
4903: DOUBLE
4904: EQUAL
4905: IFTRUE 4909
4907: GO 4924
4909: POP
// AddComWait ( forest_force1 , 0 0$2 ) ; else
4910: LD_EXP 29
4914: PPUSH
4915: LD_INT 70
4917: PPUSH
4918: CALL_OW 202
4922: GO 4976
4924: POP
// if x = - 1 then
4925: LD_VAR 0 1
4929: PUSH
4930: LD_INT 1
4932: NEG
4933: EQUAL
4934: IFFALSE 4948
// x := y else
4936: LD_ADDR_VAR 0 1
4940: PUSH
4941: LD_VAR 0 2
4945: ST_TO_ADDR
4946: GO 4976
// begin AddComAgressiveMove ( forest_force1 , x , y ) ;
4948: LD_EXP 29
4952: PPUSH
4953: LD_VAR 0 1
4957: PPUSH
4958: LD_VAR 0 2
4962: PPUSH
4963: CALL_OW 174
// x := - 1 ;
4967: LD_ADDR_VAR 0 1
4971: PUSH
4972: LD_INT 1
4974: NEG
4975: ST_TO_ADDR
// end ; end ;
4976: GO 4892
4978: POP
4979: POP
// repeat wait ( 0 0$2 ) ;
4980: LD_INT 70
4982: PPUSH
4983: CALL_OW 67
// until not ( IsBusy ( forest11 ) or IsBusy ( forest12 ) ) ;
4987: LD_INT 26
4989: PPUSH
4990: CALL_OW 315
4994: PUSH
4995: LD_INT 25
4997: PPUSH
4998: CALL_OW 315
5002: OR
5003: NOT
5004: IFFALSE 4980
// until not ( IsOK ( forest11 ) or IsOK ( forest12 ) ) ;
5006: LD_INT 26
5008: PPUSH
5009: CALL_OW 302
5013: PUSH
5014: LD_INT 25
5016: PPUSH
5017: CALL_OW 302
5021: OR
5022: NOT
5023: IFFALSE 4873
// end ;
5025: PPOPN 3
5027: END
// every 0 0$1 marked 1 do var x , y , forest_way2 ;
5028: GO 5030
5030: DISABLE
5031: LD_INT 0
5033: PPUSH
5034: PPUSH
5035: PPUSH
// begin forest_way2 = [ 38 , 29 , - 1 , 39 , 50 , 53 , 57 , 55 , 39 , - 1 ] ;
5036: LD_ADDR_VAR 0 3
5040: PUSH
5041: LD_INT 38
5043: PUSH
5044: LD_INT 29
5046: PUSH
5047: LD_INT 1
5049: NEG
5050: PUSH
5051: LD_INT 39
5053: PUSH
5054: LD_INT 50
5056: PUSH
5057: LD_INT 53
5059: PUSH
5060: LD_INT 57
5062: PUSH
5063: LD_INT 55
5065: PUSH
5066: LD_INT 39
5068: PUSH
5069: LD_INT 1
5071: NEG
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: LIST
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: ST_TO_ADDR
// repeat x := - 1 ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 1
5092: NEG
5093: ST_TO_ADDR
// for y in forest_way2 do
5094: LD_ADDR_VAR 0 2
5098: PUSH
5099: LD_VAR 0 3
5103: PUSH
5104: FOR_IN
5105: IFFALSE 5190
// case y of - 1 :
5107: LD_VAR 0 2
5111: PUSH
5112: LD_INT 1
5114: NEG
5115: DOUBLE
5116: EQUAL
5117: IFTRUE 5121
5119: GO 5136
5121: POP
// AddComWait ( forest_force2 , 0 0$2 ) ; else
5122: LD_EXP 30
5126: PPUSH
5127: LD_INT 70
5129: PPUSH
5130: CALL_OW 202
5134: GO 5188
5136: POP
// if x = - 1 then
5137: LD_VAR 0 1
5141: PUSH
5142: LD_INT 1
5144: NEG
5145: EQUAL
5146: IFFALSE 5160
// x := y else
5148: LD_ADDR_VAR 0 1
5152: PUSH
5153: LD_VAR 0 2
5157: ST_TO_ADDR
5158: GO 5188
// begin AddComAgressiveMove ( forest_force2 , x , y ) ;
5160: LD_EXP 30
5164: PPUSH
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 174
// x := - 1 ;
5179: LD_ADDR_VAR 0 1
5183: PUSH
5184: LD_INT 1
5186: NEG
5187: ST_TO_ADDR
// end ; end ;
5188: GO 5104
5190: POP
5191: POP
// repeat Wait ( 0 0$2 ) ;
5192: LD_INT 70
5194: PPUSH
5195: CALL_OW 67
// until not ( IsBusy ( forest21 ) or IsBusy ( forest22 ) ) ;
5199: LD_INT 41
5201: PPUSH
5202: CALL_OW 315
5206: PUSH
5207: LD_INT 42
5209: PPUSH
5210: CALL_OW 315
5214: OR
5215: NOT
5216: IFFALSE 5192
// until not ( IsOK ( forest21 ) or IsOK ( forest22 ) ) ;
5218: LD_INT 41
5220: PPUSH
5221: CALL_OW 302
5225: PUSH
5226: LD_INT 42
5228: PPUSH
5229: CALL_OW 302
5233: OR
5234: NOT
5235: IFFALSE 5085
// end ;
5237: PPOPN 3
5239: END
// every 0 0$1 marked 1 do var x , y , grass_way1 ;
5240: GO 5242
5242: DISABLE
5243: LD_INT 0
5245: PPUSH
5246: PPUSH
5247: PPUSH
// begin grass_force1 = [ grass_11 , grass_12 ] ;
5248: LD_ADDR_EXP 31
5252: PUSH
5253: LD_INT 21
5255: PUSH
5256: LD_INT 22
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: ST_TO_ADDR
// grass_way1 = [ 77 , 67 , - 1 , 83 , 56 , - 1 , 65 , 49 , - 1 ] ;
5263: LD_ADDR_VAR 0 3
5267: PUSH
5268: LD_INT 77
5270: PUSH
5271: LD_INT 67
5273: PUSH
5274: LD_INT 1
5276: NEG
5277: PUSH
5278: LD_INT 83
5280: PUSH
5281: LD_INT 56
5283: PUSH
5284: LD_INT 1
5286: NEG
5287: PUSH
5288: LD_INT 65
5290: PUSH
5291: LD_INT 49
5293: PUSH
5294: LD_INT 1
5296: NEG
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: LIST
5307: LIST
5308: ST_TO_ADDR
// repeat x := - 1 ;
5309: LD_ADDR_VAR 0 1
5313: PUSH
5314: LD_INT 1
5316: NEG
5317: ST_TO_ADDR
// for y in grass_way1 do
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_VAR 0 3
5327: PUSH
5328: FOR_IN
5329: IFFALSE 5440
// case y of - 1 :
5331: LD_VAR 0 2
5335: PUSH
5336: LD_INT 1
5338: NEG
5339: DOUBLE
5340: EQUAL
5341: IFTRUE 5345
5343: GO 5360
5345: POP
// AddComWait ( grass_force1 , 0 0$2 ) ; else
5346: LD_EXP 31
5350: PPUSH
5351: LD_INT 70
5353: PPUSH
5354: CALL_OW 202
5358: GO 5438
5360: POP
// if x = - 1 then
5361: LD_VAR 0 1
5365: PUSH
5366: LD_INT 1
5368: NEG
5369: EQUAL
5370: IFFALSE 5384
// x := y else
5372: LD_ADDR_VAR 0 1
5376: PUSH
5377: LD_VAR 0 2
5381: ST_TO_ADDR
5382: GO 5438
// begin AddComAgressiveMove ( grass_force1 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5384: LD_EXP 31
5388: PPUSH
5389: LD_VAR 0 1
5393: PUSH
5394: LD_INT 1
5396: NEG
5397: PPUSH
5398: LD_INT 1
5400: PPUSH
5401: CALL_OW 12
5405: PLUS
5406: PPUSH
5407: LD_VAR 0 2
5411: PUSH
5412: LD_INT 1
5414: NEG
5415: PPUSH
5416: LD_INT 1
5418: PPUSH
5419: CALL_OW 12
5423: PLUS
5424: PPUSH
5425: CALL_OW 174
// x := - 1 ;
5429: LD_ADDR_VAR 0 1
5433: PUSH
5434: LD_INT 1
5436: NEG
5437: ST_TO_ADDR
// end ; end ;
5438: GO 5328
5440: POP
5441: POP
// repeat Wait ( 0 0$2 ) ;
5442: LD_INT 70
5444: PPUSH
5445: CALL_OW 67
// until not ( IsBusy ( grass_11 ) or IsBusy ( grass_12 ) ) ;
5449: LD_INT 21
5451: PPUSH
5452: CALL_OW 315
5456: PUSH
5457: LD_INT 22
5459: PPUSH
5460: CALL_OW 315
5464: OR
5465: NOT
5466: IFFALSE 5442
// until not ( IsOK ( grass_11 ) or IsOK ( grass_12 ) ) ;
5468: LD_INT 21
5470: PPUSH
5471: CALL_OW 302
5475: PUSH
5476: LD_INT 22
5478: PPUSH
5479: CALL_OW 302
5483: OR
5484: NOT
5485: IFFALSE 5309
// end ;
5487: PPOPN 3
5489: END
// every 0 0$1 marked 1 do var x , y , grass_way2 ;
5490: GO 5492
5492: DISABLE
5493: LD_INT 0
5495: PPUSH
5496: PPUSH
5497: PPUSH
// begin grass_force2 = [ grass_21 , grass_22 ] ;
5498: LD_ADDR_EXP 32
5502: PUSH
5503: LD_INT 23
5505: PUSH
5506: LD_INT 24
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: ST_TO_ADDR
// grass_way2 = [ 129 , 64 , - 1 , 127 , 75 , - 1 , 104 , 62 , - 1 ] ;
5513: LD_ADDR_VAR 0 3
5517: PUSH
5518: LD_INT 129
5520: PUSH
5521: LD_INT 64
5523: PUSH
5524: LD_INT 1
5526: NEG
5527: PUSH
5528: LD_INT 127
5530: PUSH
5531: LD_INT 75
5533: PUSH
5534: LD_INT 1
5536: NEG
5537: PUSH
5538: LD_INT 104
5540: PUSH
5541: LD_INT 62
5543: PUSH
5544: LD_INT 1
5546: NEG
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: LIST
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// repeat x := - 1 ;
5559: LD_ADDR_VAR 0 1
5563: PUSH
5564: LD_INT 1
5566: NEG
5567: ST_TO_ADDR
// for y in grass_way2 do
5568: LD_ADDR_VAR 0 2
5572: PUSH
5573: LD_VAR 0 3
5577: PUSH
5578: FOR_IN
5579: IFFALSE 5690
// case y of - 1 :
5581: LD_VAR 0 2
5585: PUSH
5586: LD_INT 1
5588: NEG
5589: DOUBLE
5590: EQUAL
5591: IFTRUE 5595
5593: GO 5610
5595: POP
// AddComWait ( grass_force2 , 0 0$2 ) ; else
5596: LD_EXP 32
5600: PPUSH
5601: LD_INT 70
5603: PPUSH
5604: CALL_OW 202
5608: GO 5688
5610: POP
// if x = - 1 then
5611: LD_VAR 0 1
5615: PUSH
5616: LD_INT 1
5618: NEG
5619: EQUAL
5620: IFFALSE 5634
// x := y else
5622: LD_ADDR_VAR 0 1
5626: PUSH
5627: LD_VAR 0 2
5631: ST_TO_ADDR
5632: GO 5688
// begin AddComAgressiveMove ( grass_force2 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5634: LD_EXP 32
5638: PPUSH
5639: LD_VAR 0 1
5643: PUSH
5644: LD_INT 1
5646: NEG
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 12
5655: PLUS
5656: PPUSH
5657: LD_VAR 0 2
5661: PUSH
5662: LD_INT 1
5664: NEG
5665: PPUSH
5666: LD_INT 1
5668: PPUSH
5669: CALL_OW 12
5673: PLUS
5674: PPUSH
5675: CALL_OW 174
// x := - 1 ;
5679: LD_ADDR_VAR 0 1
5683: PUSH
5684: LD_INT 1
5686: NEG
5687: ST_TO_ADDR
// end ; end ;
5688: GO 5578
5690: POP
5691: POP
// repeat Wait ( 0 0$2 ) ;
5692: LD_INT 70
5694: PPUSH
5695: CALL_OW 67
// until not ( IsBusy ( grass_21 ) or IsBusy ( grass_22 ) ) ;
5699: LD_INT 23
5701: PPUSH
5702: CALL_OW 315
5706: PUSH
5707: LD_INT 24
5709: PPUSH
5710: CALL_OW 315
5714: OR
5715: NOT
5716: IFFALSE 5692
// until not ( IsOK ( grass_21 ) or IsOK ( grass_22 ) ) ;
5718: LD_INT 23
5720: PPUSH
5721: CALL_OW 302
5725: PUSH
5726: LD_INT 24
5728: PPUSH
5729: CALL_OW 302
5733: OR
5734: NOT
5735: IFFALSE 5559
// end ;
5737: PPOPN 3
5739: END
// every 0 0$1 marked 1 do var x , y , grass_way3 ;
5740: GO 5742
5742: DISABLE
5743: LD_INT 0
5745: PPUSH
5746: PPUSH
5747: PPUSH
// begin grass_force3 = [ grass_31 , grass_32 , grass_33 ] ;
5748: LD_ADDR_EXP 33
5752: PUSH
5753: LD_EXP 60
5757: PUSH
5758: LD_EXP 61
5762: PUSH
5763: LD_EXP 62
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: ST_TO_ADDR
// grass_way3 = [ 73 , 39 , - 1 , 81 , 50 , 88 , 37 , - 1 ] ;
5773: LD_ADDR_VAR 0 3
5777: PUSH
5778: LD_INT 73
5780: PUSH
5781: LD_INT 39
5783: PUSH
5784: LD_INT 1
5786: NEG
5787: PUSH
5788: LD_INT 81
5790: PUSH
5791: LD_INT 50
5793: PUSH
5794: LD_INT 88
5796: PUSH
5797: LD_INT 37
5799: PUSH
5800: LD_INT 1
5802: NEG
5803: PUSH
5804: EMPTY
5805: LIST
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: ST_TO_ADDR
// repeat x := - 1 ;
5814: LD_ADDR_VAR 0 1
5818: PUSH
5819: LD_INT 1
5821: NEG
5822: ST_TO_ADDR
// for y in grass_way3 do
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: LD_VAR 0 3
5832: PUSH
5833: FOR_IN
5834: IFFALSE 5945
// case y of - 1 :
5836: LD_VAR 0 2
5840: PUSH
5841: LD_INT 1
5843: NEG
5844: DOUBLE
5845: EQUAL
5846: IFTRUE 5850
5848: GO 5865
5850: POP
// AddComWait ( grass_force3 , 0 0$2 ) ; else
5851: LD_EXP 33
5855: PPUSH
5856: LD_INT 70
5858: PPUSH
5859: CALL_OW 202
5863: GO 5943
5865: POP
// if x = - 1 then
5866: LD_VAR 0 1
5870: PUSH
5871: LD_INT 1
5873: NEG
5874: EQUAL
5875: IFFALSE 5889
// x := y else
5877: LD_ADDR_VAR 0 1
5881: PUSH
5882: LD_VAR 0 2
5886: ST_TO_ADDR
5887: GO 5943
// begin AddComMoveXY ( grass_force3 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5889: LD_EXP 33
5893: PPUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 1
5901: NEG
5902: PPUSH
5903: LD_INT 1
5905: PPUSH
5906: CALL_OW 12
5910: PLUS
5911: PPUSH
5912: LD_VAR 0 2
5916: PUSH
5917: LD_INT 1
5919: NEG
5920: PPUSH
5921: LD_INT 1
5923: PPUSH
5924: CALL_OW 12
5928: PLUS
5929: PPUSH
5930: CALL_OW 171
// x := - 1 ;
5934: LD_ADDR_VAR 0 1
5938: PUSH
5939: LD_INT 1
5941: NEG
5942: ST_TO_ADDR
// end ; end ;
5943: GO 5833
5945: POP
5946: POP
// repeat Wait ( 0 0$2 ) ;
5947: LD_INT 70
5949: PPUSH
5950: CALL_OW 67
// until not ( IsBusy ( grass_31 ) or IsBusy ( grass_32 ) or IsBusy ( grass_33 ) ) ;
5954: LD_EXP 60
5958: PPUSH
5959: CALL_OW 315
5963: PUSH
5964: LD_EXP 61
5968: PPUSH
5969: CALL_OW 315
5973: OR
5974: PUSH
5975: LD_EXP 62
5979: PPUSH
5980: CALL_OW 315
5984: OR
5985: NOT
5986: IFFALSE 5947
// until not ( IsOK ( grass_31 ) or IsOK ( grass_32 ) or IsOK ( grass_33 ) ) ;
5988: LD_EXP 60
5992: PPUSH
5993: CALL_OW 302
5997: PUSH
5998: LD_EXP 61
6002: PPUSH
6003: CALL_OW 302
6007: OR
6008: PUSH
6009: LD_EXP 62
6013: PPUSH
6014: CALL_OW 302
6018: OR
6019: NOT
6020: IFFALSE 5814
// end ;
6022: PPOPN 3
6024: END
// export function attack_began ; var i , truck_in_battle , russians_trucks , vozidlo ; begin
6025: LD_INT 0
6027: PPUSH
6028: PPUSH
6029: PPUSH
6030: PPUSH
6031: PPUSH
// ComRemember ( ru_trucks ) ;
6032: LD_EXP 48
6036: PPUSH
6037: CALL_OW 143
// ComAgressiveMove ( ru_trucks , 118 , 3 ) ;
6041: LD_EXP 48
6045: PPUSH
6046: LD_INT 118
6048: PPUSH
6049: LD_INT 3
6051: PPUSH
6052: CALL_OW 114
// repeat truck_in_battle := FilterUnitsInArea ( battlefield , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6056: LD_ADDR_VAR 0 3
6060: PUSH
6061: LD_INT 6
6063: PPUSH
6064: LD_INT 22
6066: PUSH
6067: LD_EXP 2
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: LD_INT 21
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: PPUSH
6090: CALL_OW 70
6094: ST_TO_ADDR
// for vozidlo in truck_in_battle do
6095: LD_ADDR_VAR 0 5
6099: PUSH
6100: LD_VAR 0 3
6104: PUSH
6105: FOR_IN
6106: IFFALSE 6119
// RemoveUnit ( vozidlo ) ;
6108: LD_VAR 0 5
6112: PPUSH
6113: CALL_OW 64
6117: GO 6105
6119: POP
6120: POP
// wait ( 0 0$1 ) ;
6121: LD_INT 35
6123: PPUSH
6124: CALL_OW 67
// i := false ;
6128: LD_ADDR_VAR 0 2
6132: PUSH
6133: LD_INT 0
6135: ST_TO_ADDR
// for vozidlo in ru_trucks do
6136: LD_ADDR_VAR 0 5
6140: PUSH
6141: LD_EXP 48
6145: PUSH
6146: FOR_IN
6147: IFFALSE 6172
// i := i or IsOK ( vozidlo ) ;
6149: LD_ADDR_VAR 0 2
6153: PUSH
6154: LD_VAR 0 2
6158: PUSH
6159: LD_VAR 0 5
6163: PPUSH
6164: CALL_OW 302
6168: OR
6169: ST_TO_ADDR
6170: GO 6146
6172: POP
6173: POP
// until not i ;
6174: LD_VAR 0 2
6178: NOT
6179: IFFALSE 6056
// repeat Wait ( 0 0$10 ) ;
6181: LD_INT 350
6183: PPUSH
6184: CALL_OW 67
// until not atack ;
6188: LD_EXP 16
6192: NOT
6193: IFFALSE 6181
// repeat for vozidlo in ru_trucks do
6195: LD_ADDR_VAR 0 5
6199: PUSH
6200: LD_EXP 48
6204: PUSH
6205: FOR_IN
6206: IFFALSE 6237
// if not IsOK ( vozidlo ) then
6208: LD_VAR 0 5
6212: PPUSH
6213: CALL_OW 302
6217: NOT
6218: IFFALSE 6235
// PlaceUnitArea ( vozidlo , battlefield , false ) ;
6220: LD_VAR 0 5
6224: PPUSH
6225: LD_INT 6
6227: PPUSH
6228: LD_INT 0
6230: PPUSH
6231: CALL_OW 49
6235: GO 6205
6237: POP
6238: POP
// ComReturn ( ru_trucks ) ;
6239: LD_EXP 48
6243: PPUSH
6244: CALL_OW 144
// wait ( 0 0$1 ) ;
6248: LD_INT 35
6250: PPUSH
6251: CALL_OW 67
// i := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: LD_INT 22
6262: PUSH
6263: LD_EXP 2
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 21
6274: PUSH
6275: LD_INT 2
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PPUSH
6286: CALL_OW 69
6290: ST_TO_ADDR
// until not ( ru_trucks diff i ) ;
6291: LD_EXP 48
6295: PUSH
6296: LD_VAR 0 2
6300: DIFF
6301: NOT
6302: IFFALSE 6195
// end ;
6304: LD_VAR 0 1
6308: RET
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) or ( TICK > [ 15 15$0 , 10 10$0 , 5 5$0 ] [ difficulty ] ) marked 2 do var liv , ran , list , un , agresors , min_time , max_time ;
6309: LD_EXP 7
6313: PPUSH
6314: LD_INT 2
6316: PPUSH
6317: CALL_OW 308
6321: PUSH
6322: LD_OWVAR 1
6326: PUSH
6327: LD_INT 31500
6329: PUSH
6330: LD_INT 21000
6332: PUSH
6333: LD_INT 10500
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: LIST
6340: PUSH
6341: LD_OWVAR 67
6345: ARRAY
6346: GREATER
6347: OR
6348: IFFALSE 7304
6350: GO 6352
6352: DISABLE
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
6358: PPUSH
6359: PPUSH
6360: PPUSH
6361: PPUSH
// begin min_time := [ 4 4$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
6362: LD_ADDR_VAR 0 6
6366: PUSH
6367: LD_INT 8400
6369: PUSH
6370: LD_INT 4200
6372: PUSH
6373: LD_INT 0
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: PUSH
6381: LD_OWVAR 67
6385: ARRAY
6386: ST_TO_ADDR
// max_time := [ 8 8$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
6387: LD_ADDR_VAR 0 7
6391: PUSH
6392: LD_INT 16800
6394: PUSH
6395: LD_INT 8400
6397: PUSH
6398: LD_INT 4200
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_OWVAR 67
6410: ARRAY
6411: ST_TO_ADDR
// ran := Rand ( min_time , max_time ) ;
6412: LD_ADDR_VAR 0 2
6416: PUSH
6417: LD_VAR 0 6
6421: PPUSH
6422: LD_VAR 0 7
6426: PPUSH
6427: CALL_OW 12
6431: ST_TO_ADDR
// Wait ( ran ) ;
6432: LD_VAR 0 2
6436: PPUSH
6437: CALL_OW 67
// ComAgressiveMove ( [ patrol1 , patrol2 ] , 130 , 68 ) ;
6441: LD_INT 14
6443: PUSH
6444: LD_INT 15
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PPUSH
6451: LD_INT 130
6453: PPUSH
6454: LD_INT 68
6456: PPUSH
6457: CALL_OW 114
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 124 , 102 ) ;
6461: LD_INT 14
6463: PUSH
6464: LD_INT 15
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PPUSH
6471: LD_INT 124
6473: PPUSH
6474: LD_INT 102
6476: PPUSH
6477: CALL_OW 174
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 66 , 100 ) ;
6481: LD_INT 14
6483: PUSH
6484: LD_INT 15
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PPUSH
6491: LD_INT 66
6493: PPUSH
6494: LD_INT 100
6496: PPUSH
6497: CALL_OW 174
// wait ( 0 0$15 ) ;
6501: LD_INT 525
6503: PPUSH
6504: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , [ f_class , class_soldier ] , f_not , [ f_side , russians ] ] ) ;
6508: LD_ADDR_VAR 0 3
6512: PUSH
6513: LD_INT 4
6515: PPUSH
6516: LD_INT 21
6518: PUSH
6519: LD_INT 1
6521: PUSH
6522: EMPTY
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 25
6528: PUSH
6529: LD_INT 1
6531: PUSH
6532: EMPTY
6533: LIST
6534: LIST
6535: PUSH
6536: LD_INT 3
6538: PUSH
6539: LD_INT 22
6541: PUSH
6542: LD_EXP 2
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: PPUSH
6557: CALL_OW 70
6561: ST_TO_ADDR
// for un in list do
6562: LD_ADDR_VAR 0 4
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: FOR_IN
6573: IFFALSE 6591
// PriorityAttack ( russians , un ) ;
6575: LD_EXP 2
6579: PPUSH
6580: LD_VAR 0 4
6584: PPUSH
6585: CALL_OW 470
6589: GO 6572
6591: POP
6592: POP
// repeat wait ( 15 ) ;
6593: LD_INT 15
6595: PPUSH
6596: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , f_not , [ f_side , russians ] , f_not , [ f_nation , nation_nature ] ] ) ;
6600: LD_ADDR_VAR 0 3
6604: PUSH
6605: LD_INT 4
6607: PPUSH
6608: LD_INT 21
6610: PUSH
6611: LD_INT 1
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 22
6623: PUSH
6624: LD_EXP 2
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: LD_INT 23
6638: PUSH
6639: LD_INT 0
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: PPUSH
6653: CALL_OW 70
6657: ST_TO_ADDR
// agresors := [ ] ;
6658: LD_ADDR_VAR 0 5
6662: PUSH
6663: EMPTY
6664: ST_TO_ADDR
// if IsOK ( patrol1 ) then
6665: LD_INT 14
6667: PPUSH
6668: CALL_OW 302
6672: IFFALSE 6688
// agresors := agresors ^ patrol1 ;
6674: LD_ADDR_VAR 0 5
6678: PUSH
6679: LD_VAR 0 5
6683: PUSH
6684: LD_INT 14
6686: ADD
6687: ST_TO_ADDR
// if IsOK ( patrol2 ) then
6688: LD_INT 15
6690: PPUSH
6691: CALL_OW 302
6695: IFFALSE 6711
// agresors := agresors ^ patrol2 ;
6697: LD_ADDR_VAR 0 5
6701: PUSH
6702: LD_VAR 0 5
6706: PUSH
6707: LD_INT 15
6709: ADD
6710: ST_TO_ADDR
// if not agresors then
6711: LD_VAR 0 5
6715: NOT
6716: IFFALSE 6720
// exit ;
6718: GO 7304
// if list then
6720: LD_VAR 0 3
6724: IFFALSE 6765
// ComAgressiveMove ( agresors , GetX ( list [ 1 ] ) , GetY ( list [ 1 ] ) ) else
6726: LD_VAR 0 5
6730: PPUSH
6731: LD_VAR 0 3
6735: PUSH
6736: LD_INT 1
6738: ARRAY
6739: PPUSH
6740: CALL_OW 250
6744: PPUSH
6745: LD_VAR 0 3
6749: PUSH
6750: LD_INT 1
6752: ARRAY
6753: PPUSH
6754: CALL_OW 251
6758: PPUSH
6759: CALL_OW 114
6763: GO 6857
// begin list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_building ] ] ) ;
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_INT 4
6772: PPUSH
6773: LD_INT 21
6775: PUSH
6776: LD_INT 3
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: PUSH
6783: EMPTY
6784: LIST
6785: PPUSH
6786: CALL_OW 70
6790: ST_TO_ADDR
// for un in list do
6791: LD_ADDR_VAR 0 4
6795: PUSH
6796: LD_VAR 0 3
6800: PUSH
6801: FOR_IN
6802: IFFALSE 6820
// PriorityAttack ( russians , un ) ;
6804: LD_EXP 2
6808: PPUSH
6809: LD_VAR 0 4
6813: PPUSH
6814: CALL_OW 470
6818: GO 6801
6820: POP
6821: POP
// if list then
6822: LD_VAR 0 3
6826: IFFALSE 6848
// ComAttackUnit ( agresors , list [ 1 ] ) else
6828: LD_VAR 0 5
6832: PPUSH
6833: LD_VAR 0 3
6837: PUSH
6838: LD_INT 1
6840: ARRAY
6841: PPUSH
6842: CALL_OW 115
6846: GO 6857
// begin YouLost ( 2 ) ;
6848: LD_STRING 2
6850: PPUSH
6851: CALL_OW 104
// exit ;
6855: GO 7304
// end ; end ; until ( GetDistUnits ( NearestUnitToUnit ( list , patrol1 ) , patrol1 ) < 9 ) or ( GetDistUnits ( NearestUnitToUnit ( list , patrol2 ) , patrol2 ) < 9 ) or ( GetLives ( patrol1 ) < 1000 ) or ( GetLives ( patrol2 ) < 1000 ) ;
6857: LD_VAR 0 3
6861: PPUSH
6862: LD_INT 14
6864: PPUSH
6865: CALL_OW 74
6869: PPUSH
6870: LD_INT 14
6872: PPUSH
6873: CALL_OW 296
6877: PUSH
6878: LD_INT 9
6880: LESS
6881: PUSH
6882: LD_VAR 0 3
6886: PPUSH
6887: LD_INT 15
6889: PPUSH
6890: CALL_OW 74
6894: PPUSH
6895: LD_INT 15
6897: PPUSH
6898: CALL_OW 296
6902: PUSH
6903: LD_INT 9
6905: LESS
6906: OR
6907: PUSH
6908: LD_INT 14
6910: PPUSH
6911: CALL_OW 256
6915: PUSH
6916: LD_INT 1000
6918: LESS
6919: OR
6920: PUSH
6921: LD_INT 15
6923: PPUSH
6924: CALL_OW 256
6928: PUSH
6929: LD_INT 1000
6931: LESS
6932: OR
6933: IFFALSE 6593
// CenterOnUnits ( [ patrol1 , patrol2 ] ) ;
6935: LD_INT 14
6937: PUSH
6938: LD_INT 15
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PPUSH
6945: CALL_OW 85
// wait ( 200 - ( difficulty * 45 ) ) ;
6949: LD_INT 200
6951: PUSH
6952: LD_OWVAR 67
6956: PUSH
6957: LD_INT 45
6959: MUL
6960: MINUS
6961: PPUSH
6962: CALL_OW 67
// ComStop ( [ patrol1 , patrol2 ] ) ;
6966: LD_INT 14
6968: PUSH
6969: LD_INT 15
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 141
// AddComMoveXY ( [ patrol1 , patrol2 ] , 84 , 71 ) ;
6980: LD_INT 14
6982: PUSH
6983: LD_INT 15
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PPUSH
6990: LD_INT 84
6992: PPUSH
6993: LD_INT 71
6995: PPUSH
6996: CALL_OW 171
// AddComWait ( [ patrol1 , patrol2 ] , [ 0 0$6 , 0 0$4 , 0 0$2 ] [ difficulty ] ) ;
7000: LD_INT 14
7002: PUSH
7003: LD_INT 15
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PPUSH
7010: LD_INT 210
7012: PUSH
7013: LD_INT 140
7015: PUSH
7016: LD_INT 70
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: LIST
7023: PUSH
7024: LD_OWVAR 67
7028: ARRAY
7029: PPUSH
7030: CALL_OW 202
// AddComMoveXY ( [ patrol1 , patrol2 ] , 80 , 67 ) ;
7034: LD_INT 14
7036: PUSH
7037: LD_INT 15
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PPUSH
7044: LD_INT 80
7046: PPUSH
7047: LD_INT 67
7049: PPUSH
7050: CALL_OW 171
// AddComMoveXY ( [ patrol1 , patrol2 ] , 45 , 22 ) ;
7054: LD_INT 14
7056: PUSH
7057: LD_INT 15
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: LD_INT 45
7066: PPUSH
7067: LD_INT 22
7069: PPUSH
7070: CALL_OW 171
// DialogueOn ;
7074: CALL_OW 6
// if IsOK ( patrol1 ) then
7078: LD_INT 14
7080: PPUSH
7081: CALL_OW 302
7085: IFFALSE 7099
// Say ( patrol1 , D8-Rus1-1 ) else
7087: LD_INT 14
7089: PPUSH
7090: LD_STRING D8-Rus1-1
7092: PPUSH
7093: CALL_OW 88
7097: GO 7109
// Say ( patrol2 , D8-Rus1-1 ) ;
7099: LD_INT 15
7101: PPUSH
7102: LD_STRING D8-Rus1-1
7104: PPUSH
7105: CALL_OW 88
// Say ( MacMillan , D8-JMM-1 ) ;
7109: LD_EXP 7
7113: PPUSH
7114: LD_STRING D8-JMM-1
7116: PPUSH
7117: CALL_OW 88
// DialogueOff ;
7121: CALL_OW 7
// ran := false ;
7125: LD_ADDR_VAR 0 2
7129: PUSH
7130: LD_INT 0
7132: ST_TO_ADDR
// repeat if ( not ran ) and ( ( IsOK ( patrol1 ) and ( GetY ( patrol1 ) < 60 ) ) or ( IsOK ( patrol2 ) and ( GetY ( patrol2 ) < 60 ) ) ) then
7133: LD_VAR 0 2
7137: NOT
7138: PUSH
7139: LD_INT 14
7141: PPUSH
7142: CALL_OW 302
7146: PUSH
7147: LD_INT 14
7149: PPUSH
7150: CALL_OW 251
7154: PUSH
7155: LD_INT 60
7157: LESS
7158: AND
7159: PUSH
7160: LD_INT 15
7162: PPUSH
7163: CALL_OW 302
7167: PUSH
7168: LD_INT 15
7170: PPUSH
7171: CALL_OW 251
7175: PUSH
7176: LD_INT 60
7178: LESS
7179: AND
7180: OR
7181: AND
7182: IFFALSE 7196
// begin ran := true ;
7184: LD_ADDR_VAR 0 2
7188: PUSH
7189: LD_INT 1
7191: ST_TO_ADDR
// talk_about_attack ;
7192: CALL 12684 0 0
// end ; Wait ( 0 0$1 ) ;
7196: LD_INT 35
7198: PPUSH
7199: CALL_OW 67
// until ( not ( IsOK ( patrol1 ) or IsOK ( patrol2 ) ) ) or ( IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) ) ;
7203: LD_INT 14
7205: PPUSH
7206: CALL_OW 302
7210: PUSH
7211: LD_INT 15
7213: PPUSH
7214: CALL_OW 302
7218: OR
7219: NOT
7220: PUSH
7221: LD_INT 14
7223: PPUSH
7224: LD_INT 7
7226: PPUSH
7227: CALL_OW 308
7231: PUSH
7232: LD_INT 15
7234: PPUSH
7235: LD_INT 7
7237: PPUSH
7238: CALL_OW 308
7242: OR
7243: OR
7244: IFFALSE 7133
// Dialogue_wait := true ;
7246: LD_ADDR_EXP 39
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// if IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) then
7254: LD_INT 14
7256: PPUSH
7257: LD_INT 7
7259: PPUSH
7260: CALL_OW 308
7264: PUSH
7265: LD_INT 15
7267: PPUSH
7268: LD_INT 7
7270: PPUSH
7271: CALL_OW 308
7275: OR
7276: IFFALSE 7284
// lets_destroy_americans else
7278: CALL 7307 0 0
7282: GO 7296
// Say ( MacMillan , D8a-JMM-1 ) ;
7284: LD_EXP 7
7288: PPUSH
7289: LD_STRING D8a-JMM-1
7291: PPUSH
7292: CALL_OW 88
// Dialogue_wait := false ;
7296: LD_ADDR_EXP 39
7300: PUSH
7301: LD_INT 0
7303: ST_TO_ADDR
// end ;
7304: PPOPN 7
7306: END
// function lets_destroy_americans ; var i , attackers1 , attackers2 ; begin
7307: LD_INT 0
7309: PPUSH
7310: PPUSH
7311: PPUSH
7312: PPUSH
// PriorityAttack ( russians , sklad ) ;
7313: LD_EXP 2
7317: PPUSH
7318: LD_INT 5
7320: PPUSH
7321: CALL_OW 470
// attackers1 := [ ] ;
7325: LD_ADDR_VAR 0 3
7329: PUSH
7330: EMPTY
7331: ST_TO_ADDR
// attackers2 := [ ] ;
7332: LD_ADDR_VAR 0 4
7336: PUSH
7337: EMPTY
7338: ST_TO_ADDR
// for i in ru_trucks do
7339: LD_ADDR_VAR 0 2
7343: PUSH
7344: LD_EXP 48
7348: PUSH
7349: FOR_IN
7350: IFFALSE 7408
// if ( 0 + attackers1 ) > ( 0 + attackers2 ) then
7352: LD_INT 0
7354: PUSH
7355: LD_VAR 0 3
7359: PLUS
7360: PUSH
7361: LD_INT 0
7363: PUSH
7364: LD_VAR 0 4
7368: PLUS
7369: GREATER
7370: IFFALSE 7390
// attackers2 := attackers2 ^ i else
7372: LD_ADDR_VAR 0 4
7376: PUSH
7377: LD_VAR 0 4
7381: PUSH
7382: LD_VAR 0 2
7386: ADD
7387: ST_TO_ADDR
7388: GO 7406
// attackers1 := attackers1 ^ i ;
7390: LD_ADDR_VAR 0 3
7394: PUSH
7395: LD_VAR 0 3
7399: PUSH
7400: LD_VAR 0 2
7404: ADD
7405: ST_TO_ADDR
7406: GO 7349
7408: POP
7409: POP
// ComRemember ( attackers1 ) ;
7410: LD_VAR 0 3
7414: PPUSH
7415: CALL_OW 143
// ComRemember ( attackers2 ) ;
7419: LD_VAR 0 4
7423: PPUSH
7424: CALL_OW 143
// Attack_US_Base ( attackers1 , attackers2 ) ;
7428: LD_VAR 0 3
7432: PPUSH
7433: LD_VAR 0 4
7437: PPUSH
7438: CALL 7576 0 2
// wait ( 0 0$4 ) ;
7442: LD_INT 140
7444: PPUSH
7445: CALL_OW 67
// ComReturn ( attackers1 ) ;
7449: LD_VAR 0 3
7453: PPUSH
7454: CALL_OW 144
// ComReturn ( attackers2 ) ;
7458: LD_VAR 0 4
7462: PPUSH
7463: CALL_OW 144
// end ;
7467: LD_VAR 0 1
7471: RET
// every 0 0$15 do var un ;
7472: GO 7474
7474: DISABLE
7475: LD_INT 0
7477: PPUSH
// begin for un in ru_trucks do
7478: LD_ADDR_VAR 0 1
7482: PUSH
7483: LD_EXP 48
7487: PUSH
7488: FOR_IN
7489: IFFALSE 7570
// if ( GetFuel ( un ) < 80 ) and ( not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , un , 10 ] ] ) ) then
7491: LD_VAR 0 1
7495: PPUSH
7496: CALL_OW 261
7500: PUSH
7501: LD_INT 80
7503: LESS
7504: PUSH
7505: LD_INT 22
7507: PUSH
7508: LD_EXP 1
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 21
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 91
7529: PUSH
7530: LD_VAR 0 1
7534: PUSH
7535: LD_INT 10
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: NOT
7553: AND
7554: IFFALSE 7568
// SetFuel ( un , 100 ) ;
7556: LD_VAR 0 1
7560: PPUSH
7561: LD_INT 100
7563: PPUSH
7564: CALL_OW 240
7568: GO 7488
7570: POP
7571: POP
// enable ;
7572: ENABLE
// end ;
7573: PPOPN 1
7575: END
// function Attack_US_Base ( forces , backup ) ; var un , list , danger , time , driver , attack , retreat , repair ; begin
7576: LD_INT 0
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
7584: PPUSH
7585: PPUSH
7586: PPUSH
// ComAgressiveMove ( forces , 97 , 69 ) ;
7587: LD_VAR 0 1
7591: PPUSH
7592: LD_INT 97
7594: PPUSH
7595: LD_INT 69
7597: PPUSH
7598: CALL_OW 114
// wait ( 0 0$15 ) ;
7602: LD_INT 525
7604: PPUSH
7605: CALL_OW 67
// attack := forces ;
7609: LD_ADDR_VAR 0 9
7613: PUSH
7614: LD_VAR 0 1
7618: ST_TO_ADDR
// driver := [ ] ;
7619: LD_ADDR_VAR 0 8
7623: PUSH
7624: EMPTY
7625: ST_TO_ADDR
// repair := [ ] ;
7626: LD_ADDR_VAR 0 11
7630: PUSH
7631: EMPTY
7632: ST_TO_ADDR
// danger := false ;
7633: LD_ADDR_VAR 0 6
7637: PUSH
7638: LD_INT 0
7640: ST_TO_ADDR
// time := TICK ;
7641: LD_ADDR_VAR 0 7
7645: PUSH
7646: LD_OWVAR 1
7650: ST_TO_ADDR
// repeat ComAgressiveMove ( attack , 65 , 100 ) ;
7651: LD_VAR 0 9
7655: PPUSH
7656: LD_INT 65
7658: PPUSH
7659: LD_INT 100
7661: PPUSH
7662: CALL_OW 114
// for un in forces do
7666: LD_ADDR_VAR 0 4
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: FOR_IN
7677: IFFALSE 7780
// begin if ( GetLives ( un ) < 600 ) and ( un in attack ) then
7679: LD_VAR 0 4
7683: PPUSH
7684: CALL_OW 256
7688: PUSH
7689: LD_INT 600
7691: LESS
7692: PUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 9
7702: IN
7703: AND
7704: IFFALSE 7750
// begin attack := attack diff un ;
7706: LD_ADDR_VAR 0 9
7710: PUSH
7711: LD_VAR 0 9
7715: PUSH
7716: LD_VAR 0 4
7720: DIFF
7721: ST_TO_ADDR
// retreat := retreat ^ un ;
7722: LD_ADDR_VAR 0 10
7726: PUSH
7727: LD_VAR 0 10
7731: PUSH
7732: LD_VAR 0 4
7736: ADD
7737: ST_TO_ADDR
// ComMoveToArea ( un , ru_repair ) ;
7738: LD_VAR 0 4
7742: PPUSH
7743: LD_INT 27
7745: PPUSH
7746: CALL_OW 113
// end ; if not IsLive ( un ) then
7750: LD_VAR 0 4
7754: PPUSH
7755: CALL_OW 300
7759: NOT
7760: IFFALSE 7778
// forces := forces diff un ;
7762: LD_ADDR_VAR 0 1
7766: PUSH
7767: LD_VAR 0 1
7771: PUSH
7772: LD_VAR 0 4
7776: DIFF
7777: ST_TO_ADDR
// end ;
7778: GO 7676
7780: POP
7781: POP
// for un in retreat do
7782: LD_ADDR_VAR 0 4
7786: PUSH
7787: LD_VAR 0 10
7791: PUSH
7792: FOR_IN
7793: IFFALSE 7857
// if IsInArea ( un , ru_repair ) then
7795: LD_VAR 0 4
7799: PPUSH
7800: LD_INT 27
7802: PPUSH
7803: CALL_OW 308
7807: IFFALSE 7843
// begin retreat := retreat diff un ;
7809: LD_ADDR_VAR 0 10
7813: PUSH
7814: LD_VAR 0 10
7818: PUSH
7819: LD_VAR 0 4
7823: DIFF
7824: ST_TO_ADDR
// repair := repair ^ un ;
7825: LD_ADDR_VAR 0 11
7829: PUSH
7830: LD_VAR 0 11
7834: PUSH
7835: LD_VAR 0 4
7839: ADD
7840: ST_TO_ADDR
// end else
7841: GO 7855
// ComMoveToArea ( un , ru_repair ) ;
7843: LD_VAR 0 4
7847: PPUSH
7848: LD_INT 27
7850: PPUSH
7851: CALL_OW 113
7855: GO 7792
7857: POP
7858: POP
// for un in repair do
7859: LD_ADDR_VAR 0 4
7863: PUSH
7864: LD_VAR 0 11
7868: PUSH
7869: FOR_IN
7870: IFFALSE 7909
// if ( GetLives ( un ) < 1000 ) and IsDrivenBy ( un ) then
7872: LD_VAR 0 4
7876: PPUSH
7877: CALL_OW 256
7881: PUSH
7882: LD_INT 1000
7884: LESS
7885: PUSH
7886: LD_VAR 0 4
7890: PPUSH
7891: CALL_OW 311
7895: AND
7896: IFFALSE 7907
// ComExitVehicle ( un ) ;
7898: LD_VAR 0 4
7902: PPUSH
7903: CALL_OW 121
7907: GO 7869
7909: POP
7910: POP
// list = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] , f_not , [ f_lives , 1000 ] ] ) ;
7911: LD_ADDR_VAR 0 5
7915: PUSH
7916: LD_INT 28
7918: PPUSH
7919: LD_INT 22
7921: PUSH
7922: LD_EXP 2
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PUSH
7931: LD_INT 21
7933: PUSH
7934: LD_INT 2
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 3
7943: PUSH
7944: LD_INT 24
7946: PUSH
7947: LD_INT 1000
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 70
7964: ST_TO_ADDR
// driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
7965: LD_ADDR_VAR 0 8
7969: PUSH
7970: LD_INT 28
7972: PPUSH
7973: LD_INT 22
7975: PUSH
7976: LD_EXP 2
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PUSH
7985: LD_INT 21
7987: PUSH
7988: LD_INT 1
7990: PUSH
7991: EMPTY
7992: LIST
7993: LIST
7994: PUSH
7995: LD_INT 25
7997: PUSH
7998: LD_INT 3
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: LIST
8009: PPUSH
8010: CALL_OW 70
8014: ST_TO_ADDR
// danger = FilterUnitsInArea ( repair_around , [ [ f_side , you ] , [ f_ok ] ] ) ;
8015: LD_ADDR_VAR 0 6
8019: PUSH
8020: LD_INT 28
8022: PPUSH
8023: LD_INT 22
8025: PUSH
8026: LD_EXP 1
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: PUSH
8035: LD_INT 50
8037: PUSH
8038: EMPTY
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PPUSH
8045: CALL_OW 70
8049: ST_TO_ADDR
// if list and not danger then
8050: LD_VAR 0 5
8054: PUSH
8055: LD_VAR 0 6
8059: NOT
8060: AND
8061: IFFALSE 8083
// ComRepairVehicle ( driver , list [ 1 ] ) else
8063: LD_VAR 0 8
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_INT 1
8075: ARRAY
8076: PPUSH
8077: CALL_OW 129
8081: GO 8205
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8083: LD_ADDR_VAR 0 5
8087: PUSH
8088: LD_INT 28
8090: PPUSH
8091: LD_INT 22
8093: PUSH
8094: LD_EXP 2
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PUSH
8103: LD_INT 21
8105: PUSH
8106: LD_INT 2
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: PPUSH
8117: CALL_OW 70
8121: ST_TO_ADDR
// for un = 1 to driver do
8122: LD_ADDR_VAR 0 4
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_VAR 0 8
8136: PUSH
8137: FOR_TO
8138: IFFALSE 8180
// if un <= list then
8140: LD_VAR 0 4
8144: PUSH
8145: LD_VAR 0 5
8149: LESSEQUAL
8150: IFFALSE 8178
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8152: LD_VAR 0 8
8156: PUSH
8157: LD_VAR 0 4
8161: ARRAY
8162: PPUSH
8163: LD_VAR 0 5
8167: PUSH
8168: LD_VAR 0 4
8172: ARRAY
8173: PPUSH
8174: CALL_OW 120
8178: GO 8137
8180: POP
8181: POP
// attack := attack union repair ;
8182: LD_ADDR_VAR 0 9
8186: PUSH
8187: LD_VAR 0 9
8191: PUSH
8192: LD_VAR 0 11
8196: UNION
8197: ST_TO_ADDR
// repair := [ ] ;
8198: LD_ADDR_VAR 0 11
8202: PUSH
8203: EMPTY
8204: ST_TO_ADDR
// end ; if not repair then
8205: LD_VAR 0 11
8209: NOT
8210: IFFALSE 8367
// begin driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
8212: LD_ADDR_VAR 0 8
8216: PUSH
8217: LD_INT 28
8219: PPUSH
8220: LD_INT 22
8222: PUSH
8223: LD_EXP 2
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 21
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: LD_INT 25
8244: PUSH
8245: LD_INT 3
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 70
8261: ST_TO_ADDR
// if driver then
8262: LD_VAR 0 8
8266: IFFALSE 8367
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8268: LD_ADDR_VAR 0 5
8272: PUSH
8273: LD_INT 28
8275: PPUSH
8276: LD_INT 22
8278: PUSH
8279: LD_EXP 2
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 21
8290: PUSH
8291: LD_INT 2
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PPUSH
8302: CALL_OW 70
8306: ST_TO_ADDR
// for un = 1 to driver do
8307: LD_ADDR_VAR 0 4
8311: PUSH
8312: DOUBLE
8313: LD_INT 1
8315: DEC
8316: ST_TO_ADDR
8317: LD_VAR 0 8
8321: PUSH
8322: FOR_TO
8323: IFFALSE 8365
// if un <= list then
8325: LD_VAR 0 4
8329: PUSH
8330: LD_VAR 0 5
8334: LESSEQUAL
8335: IFFALSE 8363
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8337: LD_VAR 0 8
8341: PUSH
8342: LD_VAR 0 4
8346: ARRAY
8347: PPUSH
8348: LD_VAR 0 5
8352: PUSH
8353: LD_VAR 0 4
8357: ARRAY
8358: PPUSH
8359: CALL_OW 120
8363: GO 8322
8365: POP
8366: POP
// end ; end ; if ( TICK > ( time + 5 5$0 ) ) and backup then
8367: LD_OWVAR 1
8371: PUSH
8372: LD_VAR 0 7
8376: PUSH
8377: LD_INT 10500
8379: PLUS
8380: GREATER
8381: PUSH
8382: LD_VAR 0 2
8386: AND
8387: IFFALSE 8407
// begin attack := backup ;
8389: LD_ADDR_VAR 0 9
8393: PUSH
8394: LD_VAR 0 2
8398: ST_TO_ADDR
// backup := false ;
8399: LD_ADDR_VAR 0 2
8403: PUSH
8404: LD_INT 0
8406: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
8407: LD_INT 35
8409: PPUSH
8410: CALL_OW 67
// until not forces ;
8414: LD_VAR 0 1
8418: NOT
8419: IFFALSE 7651
// end ; end_of_file
8421: LD_VAR 0 3
8425: RET
// export function starting_scene ; var sol1 , time ; begin
8426: LD_INT 0
8428: PPUSH
8429: PPUSH
8430: PPUSH
// time := TICK ;
8431: LD_ADDR_VAR 0 3
8435: PUSH
8436: LD_OWVAR 1
8440: ST_TO_ADDR
// wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// if amtruck1 then
8448: LD_EXP 35
8452: IFFALSE 8465
// CenterOnUnits ( amtruck1 ) else
8454: LD_EXP 35
8458: PPUSH
8459: CALL_OW 85
8463: GO 8474
// CenterOnUnits ( MacMillan ) ;
8465: LD_EXP 7
8469: PPUSH
8470: CALL_OW 85
// InGameOn ;
8474: CALL_OW 8
// ComWait ( Kobra1 diff MacMillan , 0 0$0.8 ) ;
8478: LD_EXP 12
8482: PUSH
8483: LD_EXP 7
8487: DIFF
8488: PPUSH
8489: LD_INT 28
8491: PPUSH
8492: CALL_OW 142
// if amtruck1 then
8496: LD_EXP 35
8500: IFFALSE 8553
// begin ComMoveXY ( amtruck1 , 172 , 112 ) ;
8502: LD_EXP 35
8506: PPUSH
8507: LD_INT 172
8509: PPUSH
8510: LD_INT 112
8512: PPUSH
8513: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8517: LD_EXP 12
8521: PUSH
8522: LD_EXP 7
8526: DIFF
8527: PPUSH
8528: LD_EXP 35
8532: PPUSH
8533: CALL_OW 172
// ComTurnUnit ( cornells , amtruck1 ) ;
8537: LD_EXP 14
8541: PPUSH
8542: LD_EXP 35
8546: PPUSH
8547: CALL_OW 119
// end else
8551: GO 8602
// begin ComMoveXY ( MacMillan , 168 , 109 ) ;
8553: LD_EXP 7
8557: PPUSH
8558: LD_INT 168
8560: PPUSH
8561: LD_INT 109
8563: PPUSH
8564: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8568: LD_EXP 12
8572: PUSH
8573: LD_EXP 7
8577: DIFF
8578: PPUSH
8579: LD_EXP 35
8583: PPUSH
8584: CALL_OW 172
// ComTurnUnit ( cornells , MacMillan ) ;
8588: LD_EXP 14
8592: PPUSH
8593: LD_EXP 7
8597: PPUSH
8598: CALL_OW 119
// end ; if amtruck2 then
8602: LD_EXP 36
8606: IFFALSE 8632
// begin ComMoveXY ( amtruck2 , 164 , 110 ) ;
8608: LD_EXP 36
8612: PPUSH
8613: LD_INT 164
8615: PPUSH
8616: LD_INT 110
8618: PPUSH
8619: CALL_OW 111
// AddComExitVehicle ( amtruck2 ) ;
8623: LD_EXP 36
8627: PPUSH
8628: CALL_OW 181
// end ; ComMoveXY ( Cornell , 165 , 105 ) ;
8632: LD_EXP 8
8636: PPUSH
8637: LD_INT 165
8639: PPUSH
8640: LD_INT 105
8642: PPUSH
8643: CALL_OW 111
// wait ( 0 0$1.5 ) ;
8647: LD_INT 52
8649: PPUSH
8650: CALL_OW 67
// ComHold ( Kobra1 diff MacMillan ) ;
8654: LD_EXP 12
8658: PUSH
8659: LD_EXP 7
8663: DIFF
8664: PPUSH
8665: CALL_OW 140
// if amtruck1 then
8669: LD_EXP 35
8673: IFFALSE 8725
// begin repeat Wait ( 0 0$0.5 ) ;
8675: LD_INT 18
8677: PPUSH
8678: CALL_OW 67
// until not IsBusy ( amtruck1 ) ;
8682: LD_EXP 35
8686: PPUSH
8687: CALL_OW 315
8691: NOT
8692: IFFALSE 8675
// ComExitVehicle ( amtruck1 ) ;
8694: LD_EXP 35
8698: PPUSH
8699: CALL_OW 121
// wait ( 0 0$0.2 ) ;
8703: LD_INT 7
8705: PPUSH
8706: CALL_OW 67
// ComMoveXY ( MacMillan , 168 , 109 ) ;
8710: LD_EXP 7
8714: PPUSH
8715: LD_INT 168
8717: PPUSH
8718: LD_INT 109
8720: PPUSH
8721: CALL_OW 111
// end ; repeat Wait ( 0 0$0.5 ) ;
8725: LD_INT 18
8727: PPUSH
8728: CALL_OW 67
// until not IsBusy ( MacMillan ) ;
8732: LD_EXP 7
8736: PPUSH
8737: CALL_OW 315
8741: NOT
8742: IFFALSE 8725
// ComHold ( Kobra1 ) ;
8744: LD_EXP 12
8748: PPUSH
8749: CALL_OW 140
// ComTurnUnit ( MacMillan , Cornell ) ;
8753: LD_EXP 7
8757: PPUSH
8758: LD_EXP 8
8762: PPUSH
8763: CALL_OW 119
// ComTurnUnit ( Cornell , MacMillan ) ;
8767: LD_EXP 8
8771: PPUSH
8772: LD_EXP 7
8776: PPUSH
8777: CALL_OW 119
// Wait ( 0 0$1 ) ;
8781: LD_INT 35
8783: PPUSH
8784: CALL_OW 67
// InGameOff ;
8788: CALL_OW 9
// DialogueOn ;
8792: CALL_OW 6
// interface_hidden := true ;
8796: LD_ADDR_OWVAR 54
8800: PUSH
8801: LD_INT 1
8803: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
8804: LD_EXP 7
8808: PPUSH
8809: LD_STRING D1-JMM-1
8811: PPUSH
8812: CALL_OW 88
// Say ( Cornell , D1-Corn-1 ) ;
8816: LD_EXP 8
8820: PPUSH
8821: LD_STRING D1-Corn-1
8823: PPUSH
8824: CALL_OW 88
// ComStop ( cornells ) ;
8828: LD_EXP 14
8832: PPUSH
8833: CALL_OW 141
// Say ( MacMillan , D1-JMM-2 ) ;
8837: LD_EXP 7
8841: PPUSH
8842: LD_STRING D1-JMM-2
8844: PPUSH
8845: CALL_OW 88
// Say ( MacMillan , D1-JMM-2a ) ;
8849: LD_EXP 7
8853: PPUSH
8854: LD_STRING D1-JMM-2a
8856: PPUSH
8857: CALL_OW 88
// Say ( Cornell , D1-Corn-2 ) ;
8861: LD_EXP 8
8865: PPUSH
8866: LD_STRING D1-Corn-2
8868: PPUSH
8869: CALL_OW 88
// if IsOK ( Mikhail ) then
8873: LD_EXP 21
8877: PPUSH
8878: CALL_OW 302
8882: IFFALSE 9007
// begin Say ( Cornell , D1a-Corn-1 ) ;
8884: LD_EXP 8
8888: PPUSH
8889: LD_STRING D1a-Corn-1
8891: PPUSH
8892: CALL_OW 88
// Say ( MacMillan , D1a-JMM-1 ) ;
8896: LD_EXP 7
8900: PPUSH
8901: LD_STRING D1a-JMM-1
8903: PPUSH
8904: CALL_OW 88
// ComMoveXY ( Mikhail , 169 , 107 ) ;
8908: LD_EXP 21
8912: PPUSH
8913: LD_INT 169
8915: PPUSH
8916: LD_INT 107
8918: PPUSH
8919: CALL_OW 111
// Say ( Cornell , D1a-Corn-2 ) ;
8923: LD_EXP 8
8927: PPUSH
8928: LD_STRING D1a-Corn-2
8930: PPUSH
8931: CALL_OW 88
// Say ( MacMillan , D1a-JMM-2 ) ;
8935: LD_EXP 7
8939: PPUSH
8940: LD_STRING D1a-JMM-2
8942: PPUSH
8943: CALL_OW 88
// Say ( Cornell , D1a-Corn-3 ) ;
8947: LD_EXP 8
8951: PPUSH
8952: LD_STRING D1a-Corn-3
8954: PPUSH
8955: CALL_OW 88
// Say ( MacMillan , D1a-JMM-3 ) ;
8959: LD_EXP 7
8963: PPUSH
8964: LD_STRING D1a-JMM-3
8966: PPUSH
8967: CALL_OW 88
// Say ( Cornell , D1a-Corn-4 ) ;
8971: LD_EXP 8
8975: PPUSH
8976: LD_STRING D1a-Corn-4
8978: PPUSH
8979: CALL_OW 88
// Say ( MacMillan , D1a-JMM-4 ) ;
8983: LD_EXP 7
8987: PPUSH
8988: LD_STRING D1a-JMM-4
8990: PPUSH
8991: CALL_OW 88
// Say ( Cornell , D1a-Corn-5 ) ;
8995: LD_EXP 8
8999: PPUSH
9000: LD_STRING D1a-Corn-5
9002: PPUSH
9003: CALL_OW 88
// end ; Say ( MacMillan , D1b-JMM-1 ) ;
9007: LD_EXP 7
9011: PPUSH
9012: LD_STRING D1b-JMM-1
9014: PPUSH
9015: CALL_OW 88
// Say ( Cornell , D1b-Corn-1 ) ;
9019: LD_EXP 8
9023: PPUSH
9024: LD_STRING D1b-Corn-1
9026: PPUSH
9027: CALL_OW 88
// Say ( MacMillan , D1b-JMM-2 ) ;
9031: LD_EXP 7
9035: PPUSH
9036: LD_STRING D1b-JMM-2
9038: PPUSH
9039: CALL_OW 88
// Say ( Cornell , D1b-Corn-2 ) ;
9043: LD_EXP 8
9047: PPUSH
9048: LD_STRING D1b-Corn-2
9050: PPUSH
9051: CALL_OW 88
// Say ( MacMillan , D1b-JMM-3 ) ;
9055: LD_EXP 7
9059: PPUSH
9060: LD_STRING D1b-JMM-3
9062: PPUSH
9063: CALL_OW 88
// SayRadio ( Powell , D1b-Pow-3 ) ;
9067: LD_EXP 9
9071: PPUSH
9072: LD_STRING D1b-Pow-3
9074: PPUSH
9075: CALL_OW 94
// Say ( MacMillan , D1b-JMM-4 ) ;
9079: LD_EXP 7
9083: PPUSH
9084: LD_STRING D1b-JMM-4
9086: PPUSH
9087: CALL_OW 88
// Say ( Cornell , D1b-Corn-4 ) ;
9091: LD_EXP 8
9095: PPUSH
9096: LD_STRING D1b-Corn-4
9098: PPUSH
9099: CALL_OW 88
// if IsOK ( Khatam ) then
9103: LD_EXP 10
9107: PPUSH
9108: CALL_OW 302
9112: IFFALSE 9128
// Say ( Khatam , D1b-Khat-4 ) else
9114: LD_EXP 10
9118: PPUSH
9119: LD_STRING D1b-Khat-4
9121: PPUSH
9122: CALL_OW 88
9126: GO 9175
// begin sol1 := UnitFilter ( cornells , [ f_sex , sex_male ] ) ;
9128: LD_ADDR_VAR 0 2
9132: PUSH
9133: LD_EXP 14
9137: PPUSH
9138: LD_INT 26
9140: PUSH
9141: LD_INT 1
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PPUSH
9148: CALL_OW 72
9152: ST_TO_ADDR
// if sol1 then
9153: LD_VAR 0 2
9157: IFFALSE 9175
// Say ( sol1 [ 1 ] , D1b-Sol1-4 ) ;
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 1
9166: ARRAY
9167: PPUSH
9168: LD_STRING D1b-Sol1-4
9170: PPUSH
9171: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
9175: LD_EXP 5
9179: PPUSH
9180: CALL_OW 302
9184: IFFALSE 9233
// begin Say ( Cyrus , D1b-Cyrus-4 ) ;
9186: LD_EXP 5
9190: PPUSH
9191: LD_STRING D1b-Cyrus-4
9193: PPUSH
9194: CALL_OW 88
// if IsOK ( Lisa ) then
9198: LD_EXP 6
9202: PPUSH
9203: CALL_OW 302
9207: IFFALSE 9233
// begin Say ( Lisa , D1b-Lisa-4 ) ;
9209: LD_EXP 6
9213: PPUSH
9214: LD_STRING D1b-Lisa-4
9216: PPUSH
9217: CALL_OW 88
// Say ( Cyrus , D1b-Cyrus-5 ) ;
9221: LD_EXP 5
9225: PPUSH
9226: LD_STRING D1b-Cyrus-5
9228: PPUSH
9229: CALL_OW 88
// end ; end ; SelectGroup ;
9233: CALL 9475 0 0
// interface_hidden := false ;
9237: LD_ADDR_OWVAR 54
9241: PUSH
9242: LD_INT 0
9244: ST_TO_ADDR
// DialogueOff ;
9245: CALL_OW 7
// InGameOn ;
9249: CALL_OW 8
// enable ( 4 ) ;
9253: LD_INT 4
9255: ENABLE_MARKED
// Say ( MacMillan , D1d-JMM-1 ) ;
9256: LD_EXP 7
9260: PPUSH
9261: LD_STRING D1d-JMM-1
9263: PPUSH
9264: CALL_OW 88
// Say ( Cornell , D1d-Corn-1 ) ;
9268: LD_EXP 8
9272: PPUSH
9273: LD_STRING D1d-Corn-1
9275: PPUSH
9276: CALL_OW 88
// SetSide ( Cornell , neutral ) ;
9280: LD_EXP 8
9284: PPUSH
9285: LD_EXP 3
9289: PPUSH
9290: CALL_OW 235
// if amtruck2 then
9294: LD_EXP 36
9298: IFFALSE 9349
// begin ComEnterUnit ( Cornell , amtruck2 ) ;
9300: LD_EXP 8
9304: PPUSH
9305: LD_EXP 36
9309: PPUSH
9310: CALL_OW 120
// repeat wait ( 0 0$1 ) until IsInUnit ( Cornell ) ;
9314: LD_INT 35
9316: PPUSH
9317: CALL_OW 67
9321: LD_EXP 8
9325: PPUSH
9326: CALL_OW 310
9330: IFFALSE 9314
// ComMoveXY ( amtruck2 , 166 , 95 ) ;
9332: LD_EXP 36
9336: PPUSH
9337: LD_INT 166
9339: PPUSH
9340: LD_INT 95
9342: PPUSH
9343: CALL_OW 111
// end else
9347: GO 9373
// begin ComStop ( Cornell ) ;
9349: LD_EXP 8
9353: PPUSH
9354: CALL_OW 141
// ComMoveXY ( Cornell , 166 , 95 ) ;
9358: LD_EXP 8
9362: PPUSH
9363: LD_INT 166
9365: PPUSH
9366: LD_INT 95
9368: PPUSH
9369: CALL_OW 111
// end ; SaveForQuickRestart ;
9373: CALL_OW 22
// enable ( 8 ) ;
9377: LD_INT 8
9379: ENABLE_MARKED
// enable ( 3 ) ;
9380: LD_INT 3
9382: ENABLE_MARKED
// wait ( 0 0$0.5 ) ;
9383: LD_INT 18
9385: PPUSH
9386: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
9390: LD_STRING M1
9392: PPUSH
9393: CALL_OW 337
// TICK := time ;
9397: LD_ADDR_OWVAR 1
9401: PUSH
9402: LD_VAR 0 3
9406: ST_TO_ADDR
// ComFree ( [ yours ] ) ;
9407: LD_EXP 15
9411: PUSH
9412: EMPTY
9413: LIST
9414: PPUSH
9415: CALL_OW 139
// InGameOff ;
9419: CALL_OW 9
// Wait ( 0 0$5 ) ;
9423: LD_INT 175
9425: PPUSH
9426: CALL_OW 67
// SetAttitude ( russians , you , att_enemy , true ) ;
9430: LD_EXP 2
9434: PPUSH
9435: LD_EXP 1
9439: PPUSH
9440: LD_INT 2
9442: PPUSH
9443: LD_INT 1
9445: PPUSH
9446: CALL_OW 80
// SetAttitude ( russians , neutral , att_enemy , true ) ;
9450: LD_EXP 2
9454: PPUSH
9455: LD_EXP 3
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: LD_INT 1
9465: PPUSH
9466: CALL_OW 80
// end ;
9470: LD_VAR 0 1
9474: RET
// function SelectGroup ; var units ; begin
9475: LD_INT 0
9477: PPUSH
9478: PPUSH
// units := [ MacMillan , sel_changeable ] ^ ( Kobra1 diff [ MacMillan , Mikhail ] ) ^ [ sel_not_hired , sel_not_changeable , Cornell , Mikhail ] ^ [ sel_changeable ] ^ cornells ;
9479: LD_ADDR_VAR 0 2
9483: PUSH
9484: LD_EXP 7
9488: PUSH
9489: LD_INT -3
9491: PUSH
9492: EMPTY
9493: LIST
9494: LIST
9495: PUSH
9496: LD_EXP 12
9500: PUSH
9501: LD_EXP 7
9505: PUSH
9506: LD_EXP 21
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: DIFF
9515: ADD
9516: PUSH
9517: LD_INT -2
9519: PUSH
9520: LD_INT -4
9522: PUSH
9523: LD_EXP 8
9527: PUSH
9528: LD_EXP 21
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: ADD
9539: PUSH
9540: LD_INT -3
9542: PUSH
9543: EMPTY
9544: LIST
9545: ADD
9546: PUSH
9547: LD_EXP 14
9551: ADD
9552: ST_TO_ADDR
// yours := MacMillan ^ CharacterSelection ( Select five characters to go with you , 5 , 5 , units , [ ] ) ;
9553: LD_ADDR_EXP 15
9557: PUSH
9558: LD_EXP 7
9562: PUSH
9563: LD_STRING Select five characters to go with you
9565: PPUSH
9566: LD_INT 5
9568: PPUSH
9569: LD_INT 5
9571: PPUSH
9572: LD_VAR 0 2
9576: PPUSH
9577: EMPTY
9578: PPUSH
9579: CALL_OW 42
9583: ADD
9584: ST_TO_ADDR
// Cornell_group := Kobra1 union cornells diff yours ;
9585: LD_ADDR_EXP 34
9589: PUSH
9590: LD_EXP 12
9594: PUSH
9595: LD_EXP 14
9599: UNION
9600: PUSH
9601: LD_EXP 15
9605: DIFF
9606: ST_TO_ADDR
// end ;
9607: LD_VAR 0 1
9611: RET
// every 0 0$0.5 marked 4 do var pom_replace , lidi_mimo , group_out ;
9612: GO 9614
9614: DISABLE
9615: LD_INT 0
9617: PPUSH
9618: PPUSH
9619: PPUSH
// begin group_out := Cornell_group diff Cornell ;
9620: LD_ADDR_VAR 0 3
9624: PUSH
9625: LD_EXP 34
9629: PUSH
9630: LD_EXP 8
9634: DIFF
9635: ST_TO_ADDR
// SetSide ( Cornell_group , neutral ) ;
9636: LD_EXP 34
9640: PPUSH
9641: LD_EXP 3
9645: PPUSH
9646: CALL_OW 235
// ComMoveXY ( Cornell_group diff Cornell , 165 , 93 ) ;
9650: LD_EXP 34
9654: PUSH
9655: LD_EXP 8
9659: DIFF
9660: PPUSH
9661: LD_INT 165
9663: PPUSH
9664: LD_INT 93
9666: PPUSH
9667: CALL_OW 111
// repeat lidi_mimo := FilterUnitsInArea ( Leaving , [ [ f_side , neutral ] ] ) ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_INT 3
9678: PPUSH
9679: LD_INT 22
9681: PUSH
9682: LD_EXP 3
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: EMPTY
9692: LIST
9693: PPUSH
9694: CALL_OW 70
9698: ST_TO_ADDR
// group_out := group_out diff lidi_mimo ;
9699: LD_ADDR_VAR 0 3
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_VAR 0 2
9713: DIFF
9714: ST_TO_ADDR
// if lidi_mimo then
9715: LD_VAR 0 2
9719: IFFALSE 9747
// for pom_replace in lidi_mimo do
9721: LD_ADDR_VAR 0 1
9725: PUSH
9726: LD_VAR 0 2
9730: PUSH
9731: FOR_IN
9732: IFFALSE 9745
// RemoveUnit ( pom_replace ) ;
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 64
9743: GO 9731
9745: POP
9746: POP
// Wait ( 0 0$0.5 ) ;
9747: LD_INT 18
9749: PPUSH
9750: CALL_OW 67
// until not group_out ;
9754: LD_VAR 0 3
9758: NOT
9759: IFFALSE 9671
// end ;
9761: PPOPN 3
9763: END
// every 0 0$0.5 marked 8 do
9764: GO 9766
9766: DISABLE
// begin repeat if IsInUnit ( Cornell ) then
9767: LD_EXP 8
9771: PPUSH
9772: CALL_OW 310
9776: IFFALSE 9800
// ComMoveXY ( IsInUnit ( Cornell ) , 166 , 95 ) else
9778: LD_EXP 8
9782: PPUSH
9783: CALL_OW 310
9787: PPUSH
9788: LD_INT 166
9790: PPUSH
9791: LD_INT 95
9793: PPUSH
9794: CALL_OW 111
9798: GO 9815
// ComMoveXY ( Cornell , 166 , 95 ) ;
9800: LD_EXP 8
9804: PPUSH
9805: LD_INT 166
9807: PPUSH
9808: LD_INT 95
9810: PPUSH
9811: CALL_OW 111
// Wait ( 0 0$0.5 ) ;
9815: LD_INT 18
9817: PPUSH
9818: CALL_OW 67
// until not ( IsBusy ( Cornell ) or IsBusy ( IsInUnit ( Cornell ) ) ) ;
9822: LD_EXP 8
9826: PPUSH
9827: CALL_OW 315
9831: PUSH
9832: LD_EXP 8
9836: PPUSH
9837: CALL_OW 310
9841: PPUSH
9842: CALL_OW 315
9846: OR
9847: NOT
9848: IFFALSE 9767
// if IsInUnit ( Cornell ) then
9850: LD_EXP 8
9854: PPUSH
9855: CALL_OW 310
9859: IFFALSE 9877
// RemoveUnit ( IsInUnit ( Cornell ) ) else
9861: LD_EXP 8
9865: PPUSH
9866: CALL_OW 310
9870: PPUSH
9871: CALL_OW 64
9875: GO 9886
// RemoveUnit ( Cornell ) ;
9877: LD_EXP 8
9881: PPUSH
9882: CALL_OW 64
// enable ( 3 ) ;
9886: LD_INT 3
9888: ENABLE_MARKED
// end ;
9889: END
// var tick_after ; every 0 0$1 trigger IsInArea ( MacMillan , Meeting ) do
9890: LD_EXP 7
9894: PPUSH
9895: LD_INT 4
9897: PPUSH
9898: CALL_OW 308
9902: IFFALSE 10455
9904: GO 9906
9906: DISABLE
// begin SetSideBase ( GetBase ( sklad ) , you ) ;
9907: LD_INT 5
9909: PPUSH
9910: CALL_OW 274
9914: PPUSH
9915: LD_EXP 1
9919: PPUSH
9920: CALL_OW 236
// SetSide ( [ am1 , am2 , am4 , am5 ] , you ) ;
9924: LD_INT 2
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: LD_INT 1
9932: PUSH
9933: LD_INT 4
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: PPUSH
9942: LD_EXP 1
9946: PPUSH
9947: CALL_OW 235
// RevealFogArea ( you , Am_Base ) ;
9951: LD_EXP 1
9955: PPUSH
9956: LD_INT 2
9958: PPUSH
9959: CALL_OW 332
// ComMoveUnit ( MacMillan , am1 ) ;
9963: LD_EXP 7
9967: PPUSH
9968: LD_INT 2
9970: PPUSH
9971: CALL_OW 112
// ComMoveUnit ( am1 , MacMillan ) ;
9975: LD_INT 2
9977: PPUSH
9978: LD_EXP 7
9982: PPUSH
9983: CALL_OW 112
// repeat Wait ( 0 0$0.5 ) ;
9987: LD_INT 18
9989: PPUSH
9990: CALL_OW 67
// until GetDistUnits ( MacMillan , am1 ) < 5 ;
9994: LD_EXP 7
9998: PPUSH
9999: LD_INT 2
10001: PPUSH
10002: CALL_OW 296
10006: PUSH
10007: LD_INT 5
10009: LESS
10010: IFFALSE 9987
// ComStop ( [ MacMillan , am1 ] ) ;
10012: LD_EXP 7
10016: PUSH
10017: LD_INT 2
10019: PUSH
10020: EMPTY
10021: LIST
10022: LIST
10023: PPUSH
10024: CALL_OW 141
// CenterOnUnits ( am1 ) ;
10028: LD_INT 2
10030: PPUSH
10031: CALL_OW 85
// ComTurnUnit ( MacMillan , am1 ) ;
10035: LD_EXP 7
10039: PPUSH
10040: LD_INT 2
10042: PPUSH
10043: CALL_OW 119
// ComTurnUnit ( am1 , MacMillan ) ;
10047: LD_INT 2
10049: PPUSH
10050: LD_EXP 7
10054: PPUSH
10055: CALL_OW 119
// ComHold ( [ am1 , am2 , am4 , am5 ] ) ;
10059: LD_INT 2
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 1
10067: PUSH
10068: LD_INT 4
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: PPUSH
10077: CALL_OW 140
// Wait ( 0 0$1 ) ;
10081: LD_INT 35
10083: PPUSH
10084: CALL_OW 67
// DialogueOn ;
10088: CALL_OW 6
// interface_hidden := true ;
10092: LD_ADDR_OWVAR 54
10096: PUSH
10097: LD_INT 1
10099: ST_TO_ADDR
// Say ( MacMillan , D2-JMM-1 ) ;
10100: LD_EXP 7
10104: PPUSH
10105: LD_STRING D2-JMM-1
10107: PPUSH
10108: CALL_OW 88
// Say ( am1 , D2-Sol1-1 ) ;
10112: LD_INT 2
10114: PPUSH
10115: LD_STRING D2-Sol1-1
10117: PPUSH
10118: CALL_OW 88
// Say ( MacMillan , D2-JMM-2 ) ;
10122: LD_EXP 7
10126: PPUSH
10127: LD_STRING D2-JMM-2
10129: PPUSH
10130: CALL_OW 88
// Say ( am1 , D2-Sol1-2 ) ;
10134: LD_INT 2
10136: PPUSH
10137: LD_STRING D2-Sol1-2
10139: PPUSH
10140: CALL_OW 88
// Say ( MacMillan , D2-JMM-3 ) ;
10144: LD_EXP 7
10148: PPUSH
10149: LD_STRING D2-JMM-3
10151: PPUSH
10152: CALL_OW 88
// Say ( am1 , D2-Sol1-3 ) ;
10156: LD_INT 2
10158: PPUSH
10159: LD_STRING D2-Sol1-3
10161: PPUSH
10162: CALL_OW 88
// Say ( MacMillan , D2-JMM-4 ) ;
10166: LD_EXP 7
10170: PPUSH
10171: LD_STRING D2-JMM-4
10173: PPUSH
10174: CALL_OW 88
// Say ( am1 , D2-Sol1-4 ) ;
10178: LD_INT 2
10180: PPUSH
10181: LD_STRING D2-Sol1-4
10183: PPUSH
10184: CALL_OW 88
// Say ( MacMillan , D2-JMM-5 ) ;
10188: LD_EXP 7
10192: PPUSH
10193: LD_STRING D2-JMM-5
10195: PPUSH
10196: CALL_OW 88
// async ;
10200: ASYNC
// Say ( am1 , D2-Sol1-5 ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_STRING D2-Sol1-5
10206: PPUSH
10207: CALL_OW 88
// sync ;
10211: SYNC
// RevealFogArea ( you , panika_1 ) ;
10212: LD_EXP 1
10216: PPUSH
10217: LD_INT 9
10219: PPUSH
10220: CALL_OW 332
// CenterOnXY ( 121 , 51 ) ;
10224: LD_INT 121
10226: PPUSH
10227: LD_INT 51
10229: PPUSH
10230: CALL_OW 84
// DWait ( 0 0$6 ) ;
10234: LD_INT 210
10236: PPUSH
10237: CALL_OW 68
// RevealFogArea ( you , panika_2 ) ;
10241: LD_EXP 1
10245: PPUSH
10246: LD_INT 10
10248: PPUSH
10249: CALL_OW 332
// CenterOnXY ( 90 , 36 ) ;
10253: LD_INT 90
10255: PPUSH
10256: LD_INT 36
10258: PPUSH
10259: CALL_OW 84
// DWait ( 0 0$3 ) ;
10263: LD_INT 105
10265: PPUSH
10266: CALL_OW 68
// async ;
10270: ASYNC
// Say ( MacMillan , D2-JMM-6 ) ;
10271: LD_EXP 7
10275: PPUSH
10276: LD_STRING D2-JMM-6
10278: PPUSH
10279: CALL_OW 88
// sync ;
10283: SYNC
// RevealFogArea ( you , panika_3 ) ;
10284: LD_EXP 1
10288: PPUSH
10289: LD_INT 11
10291: PPUSH
10292: CALL_OW 332
// CenterOnXY ( 58 , 33 ) ;
10296: LD_INT 58
10298: PPUSH
10299: LD_INT 33
10301: PPUSH
10302: CALL_OW 84
// DWait ( 0 0$3 ) ;
10306: LD_INT 105
10308: PPUSH
10309: CALL_OW 68
// RevealFogArea ( you , panika_4 ) ;
10313: LD_EXP 1
10317: PPUSH
10318: LD_INT 12
10320: PPUSH
10321: CALL_OW 332
// CenterOnXY ( 36 , 42 ) ;
10325: LD_INT 36
10327: PPUSH
10328: LD_INT 42
10330: PPUSH
10331: CALL_OW 84
// Say ( am1 , D2-Sol1-6 ) ;
10335: LD_INT 2
10337: PPUSH
10338: LD_STRING D2-Sol1-6
10340: PPUSH
10341: CALL_OW 88
// CenterOnUnits ( MacMillan ) ;
10345: LD_EXP 7
10349: PPUSH
10350: CALL_OW 85
// Say ( MacMillan , D2-JMM-7 ) ;
10354: LD_EXP 7
10358: PPUSH
10359: LD_STRING D2-JMM-7
10361: PPUSH
10362: CALL_OW 88
// Say ( am1 , D2-Sol1-7 ) ;
10366: LD_INT 2
10368: PPUSH
10369: LD_STRING D2-Sol1-7
10371: PPUSH
10372: CALL_OW 88
// Say ( MacMillan , D2-JMM-8 ) ;
10376: LD_EXP 7
10380: PPUSH
10381: LD_STRING D2-JMM-8
10383: PPUSH
10384: CALL_OW 88
// DialogueOff ;
10388: CALL_OW 7
// interface_hidden := false ;
10392: LD_ADDR_OWVAR 54
10396: PUSH
10397: LD_INT 0
10399: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
10400: LD_INT 2
10402: PUSH
10403: LD_INT 3
10405: PUSH
10406: LD_INT 1
10408: PUSH
10409: LD_INT 4
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: PPUSH
10418: CALL_OW 139
// ChangeMissionObjectives ( MOutCap ) ;
10422: LD_STRING MOutCap
10424: PPUSH
10425: CALL_OW 337
// ChangeMissionObjectives ( MSolar1 ) ;
10429: LD_STRING MSolar1
10431: PPUSH
10432: CALL_OW 337
// Hint ( BuildingBase ) ;
10436: LD_STRING BuildingBase
10438: PPUSH
10439: CALL_OW 339
// base_reached := true ;
10443: LD_ADDR_EXP 45
10447: PUSH
10448: LD_INT 1
10450: ST_TO_ADDR
// talk_about_shipments ;
10451: CALL 10456 0 0
// end ;
10455: END
// function talk_about_shipments ; var fin , m , n ; begin
10456: LD_INT 0
10458: PPUSH
10459: PPUSH
10460: PPUSH
10461: PPUSH
// fin := false ;
10462: LD_ADDR_VAR 0 2
10466: PUSH
10467: LD_INT 0
10469: ST_TO_ADDR
// while not GetResourceArea ( am_base , mat_cans ) do
10470: LD_INT 2
10472: PPUSH
10473: LD_INT 1
10475: PPUSH
10476: CALL_OW 287
10480: NOT
10481: IFFALSE 10492
// wait ( 0 0$3 ) ;
10483: LD_INT 105
10485: PPUSH
10486: CALL_OW 67
10490: GO 10470
// Hint ( Crates ) ;
10492: LD_STRING Crates
10494: PPUSH
10495: CALL_OW 339
// m := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10499: LD_ADDR_VAR 0 3
10503: PUSH
10504: LD_INT 5
10506: PPUSH
10507: CALL_OW 274
10511: PPUSH
10512: LD_INT 1
10514: PPUSH
10515: CALL_OW 275
10519: ST_TO_ADDR
// repeat n := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10520: LD_ADDR_VAR 0 4
10524: PUSH
10525: LD_INT 5
10527: PPUSH
10528: CALL_OW 274
10532: PPUSH
10533: LD_INT 1
10535: PPUSH
10536: CALL_OW 275
10540: ST_TO_ADDR
// if n > m then
10541: LD_VAR 0 4
10545: PUSH
10546: LD_VAR 0 3
10550: GREATER
10551: IFFALSE 10563
// fin := true else
10553: LD_ADDR_VAR 0 2
10557: PUSH
10558: LD_INT 1
10560: ST_TO_ADDR
10561: GO 10573
// m := n ;
10563: LD_ADDR_VAR 0 3
10567: PUSH
10568: LD_VAR 0 4
10572: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10573: LD_INT 35
10575: PPUSH
10576: CALL_OW 67
// until fin ;
10580: LD_VAR 0 2
10584: IFFALSE 10520
// wait ( 0 0$2 ) ;
10586: LD_INT 70
10588: PPUSH
10589: CALL_OW 67
// DisableExclamations ;
10593: CALL_OW 474
// DialogueOn ;
10597: CALL_OW 6
// interface_hidden := true ;
10601: LD_ADDR_OWVAR 54
10605: PUSH
10606: LD_INT 1
10608: ST_TO_ADDR
// Say ( MacMillan , D2a-JMM-1 ) ;
10609: LD_EXP 7
10613: PPUSH
10614: LD_STRING D2a-JMM-1
10616: PPUSH
10617: CALL_OW 88
// Say ( am5 , D2a-Sci1-1 ) ;
10621: LD_INT 4
10623: PPUSH
10624: LD_STRING D2a-Sci1-1
10626: PPUSH
10627: CALL_OW 88
// Say ( MacMillan , D2a-JMM-2 ) ;
10631: LD_EXP 7
10635: PPUSH
10636: LD_STRING D2a-JMM-2
10638: PPUSH
10639: CALL_OW 88
// Say ( am5 , D2a-Sci1-2 ) ;
10643: LD_INT 4
10645: PPUSH
10646: LD_STRING D2a-Sci1-2
10648: PPUSH
10649: CALL_OW 88
// Say ( MacMillan , D2a-JMM-3 ) ;
10653: LD_EXP 7
10657: PPUSH
10658: LD_STRING D2a-JMM-3
10660: PPUSH
10661: CALL_OW 88
// Say ( am5 , D2a-Sci1-3 ) ;
10665: LD_INT 4
10667: PPUSH
10668: LD_STRING D2a-Sci1-3
10670: PPUSH
10671: CALL_OW 88
// interface_hidden := false ;
10675: LD_ADDR_OWVAR 54
10679: PUSH
10680: LD_INT 0
10682: ST_TO_ADDR
// DialogueOff ;
10683: CALL_OW 7
// EnableExclamations ;
10687: CALL_OW 473
// enable ( 10 ) ;
10691: LD_INT 10
10693: ENABLE_MARKED
// enable ( 2 ) ;
10694: LD_INT 2
10696: ENABLE_MARKED
// end ;
10697: LD_VAR 0 1
10701: RET
// on VehicleConstructed ( vyrobene_auto , tovarna ) marked 10 do begin talk_about_first_car ;
10702: CALL 10727 0 0
// solar_constructed := true ;
10706: LD_ADDR_EXP 42
10710: PUSH
10711: LD_INT 1
10713: ST_TO_ADDR
// ChangeMissionObjectives ( MOutSol ) ;
10714: LD_STRING MOutSol
10716: PPUSH
10717: CALL_OW 337
// disable ( 10 ) ;
10721: LD_INT 10
10723: DISABLE_MARKED
// end ;
10724: PPOPN 2
10726: END
// function talk_about_first_car ; begin
10727: LD_INT 0
10729: PPUSH
// repeat wait ( 0 0$1 ) ;
10730: LD_INT 35
10732: PPUSH
10733: CALL_OW 67
// until not Dialogue_wait ;
10737: LD_EXP 39
10741: NOT
10742: IFFALSE 10730
// Wait ( 0 0$3 ) ;
10744: LD_INT 105
10746: PPUSH
10747: CALL_OW 67
// DialogueOn ;
10751: CALL_OW 6
// interface_hidden := true ;
10755: LD_ADDR_OWVAR 54
10759: PUSH
10760: LD_INT 1
10762: ST_TO_ADDR
// Hint ( Vehicle ) ;
10763: LD_STRING Vehicle
10765: PPUSH
10766: CALL_OW 339
// Say ( MacMillan , D2b-JMM-1 ) ;
10770: LD_EXP 7
10774: PPUSH
10775: LD_STRING D2b-JMM-1
10777: PPUSH
10778: CALL_OW 88
// if IsOK ( am5 ) then
10782: LD_INT 4
10784: PPUSH
10785: CALL_OW 302
10789: IFFALSE 10803
// Say ( am5 , D2b-Sci1-1 ) else
10791: LD_INT 4
10793: PPUSH
10794: LD_STRING D2b-Sci1-1
10796: PPUSH
10797: CALL_OW 88
10801: GO 10815
// Say ( Khatam , D2b-Sci1-1 ) ;
10803: LD_EXP 10
10807: PPUSH
10808: LD_STRING D2b-Sci1-1
10810: PPUSH
10811: CALL_OW 88
// Say ( MacMillan , D2b-JMM-2 ) ;
10815: LD_EXP 7
10819: PPUSH
10820: LD_STRING D2b-JMM-2
10822: PPUSH
10823: CALL_OW 88
// if IsOK ( am5 ) then
10827: LD_INT 4
10829: PPUSH
10830: CALL_OW 302
10834: IFFALSE 10848
// Say ( am5 , D2b-Sci1-2 ) else
10836: LD_INT 4
10838: PPUSH
10839: LD_STRING D2b-Sci1-2
10841: PPUSH
10842: CALL_OW 88
10846: GO 10860
// Say ( Khatam , D2b-Sci1-2 ) ;
10848: LD_EXP 10
10852: PPUSH
10853: LD_STRING D2b-Sci1-2
10855: PPUSH
10856: CALL_OW 88
// Say ( MacMillan , D2b-JMM-3 ) ;
10860: LD_EXP 7
10864: PPUSH
10865: LD_STRING D2b-JMM-3
10867: PPUSH
10868: CALL_OW 88
// interface_hidden := false ;
10872: LD_ADDR_OWVAR 54
10876: PUSH
10877: LD_INT 0
10879: ST_TO_ADDR
// DialogueOff ;
10880: CALL_OW 7
// enable ( 7 ) ;
10884: LD_INT 7
10886: ENABLE_MARKED
// end ;
10887: LD_VAR 0 1
10891: RET
// every 0 0$2 trigger GetEngine ( IsInUnit ( MacMillan ) ) = engine_solar marked 7 do
10892: LD_EXP 7
10896: PPUSH
10897: CALL_OW 310
10901: PPUSH
10902: CALL_OW 262
10906: PUSH
10907: LD_INT 2
10909: EQUAL
10910: IFFALSE 10953
10912: GO 10914
10914: DISABLE
// begin DisableExclamations ;
10915: CALL_OW 474
// Say ( MacMillan , D2c-JMM-1 ) ;
10919: LD_EXP 7
10923: PPUSH
10924: LD_STRING D2c-JMM-1
10926: PPUSH
10927: CALL_OW 88
// if JMMinvehicle then
10931: LD_EXP 19
10935: IFFALSE 10949
// Say ( MacMillan , D2c-JMM-1a ) ;
10937: LD_EXP 7
10941: PPUSH
10942: LD_STRING D2c-JMM-1a
10944: PPUSH
10945: CALL_OW 88
// EnableExclamations ;
10949: CALL_OW 473
// end ;
10953: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Lisa ) ) = engine_solar marked 7 do
10954: LD_EXP 6
10958: PPUSH
10959: CALL_OW 310
10963: PPUSH
10964: CALL_OW 262
10968: PUSH
10969: LD_INT 2
10971: EQUAL
10972: IFFALSE 11146
10974: GO 10976
10976: DISABLE
// begin Wait ( 0 0$2 ) ;
10977: LD_INT 70
10979: PPUSH
10980: CALL_OW 67
// EnableExclamations ;
10984: CALL_OW 473
// async ;
10988: ASYNC
// Say ( Lisa , D2c-Lisa-1 ) ;
10989: LD_EXP 6
10993: PPUSH
10994: LD_STRING D2c-Lisa-1
10996: PPUSH
10997: CALL_OW 88
// sync ;
11001: SYNC
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) - 2 ) ;
11002: LD_EXP 6
11006: PPUSH
11007: LD_EXP 6
11011: PPUSH
11012: CALL_OW 250
11016: PPUSH
11017: LD_EXP 6
11021: PPUSH
11022: CALL_OW 251
11026: PUSH
11027: LD_INT 2
11029: MINUS
11030: PPUSH
11031: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) + 2 , GetY ( Lisa ) + 2 ) ;
11035: LD_EXP 6
11039: PPUSH
11040: LD_EXP 6
11044: PPUSH
11045: CALL_OW 250
11049: PUSH
11050: LD_INT 2
11052: PLUS
11053: PPUSH
11054: LD_EXP 6
11058: PPUSH
11059: CALL_OW 251
11063: PUSH
11064: LD_INT 2
11066: PLUS
11067: PPUSH
11068: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) + 2 ) ;
11072: LD_EXP 6
11076: PPUSH
11077: LD_EXP 6
11081: PPUSH
11082: CALL_OW 250
11086: PPUSH
11087: LD_EXP 6
11091: PPUSH
11092: CALL_OW 251
11096: PUSH
11097: LD_INT 2
11099: PLUS
11100: PPUSH
11101: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) - 2 , GetY ( Lisa ) - 2 ) ;
11105: LD_EXP 6
11109: PPUSH
11110: LD_EXP 6
11114: PPUSH
11115: CALL_OW 250
11119: PUSH
11120: LD_INT 2
11122: MINUS
11123: PPUSH
11124: LD_EXP 6
11128: PPUSH
11129: CALL_OW 251
11133: PUSH
11134: LD_INT 2
11136: MINUS
11137: PPUSH
11138: CALL_OW 171
// DisableExclamations ;
11142: CALL_OW 474
// end ;
11146: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Cyrus ) ) = engine_solar marked 7 do
11147: LD_EXP 5
11151: PPUSH
11152: CALL_OW 310
11156: PPUSH
11157: CALL_OW 262
11161: PUSH
11162: LD_INT 2
11164: EQUAL
11165: IFFALSE 11208
11167: GO 11169
11169: DISABLE
// begin DisableExclamations ;
11170: CALL_OW 474
// Say ( Cyrus , D2c-Cyrus-1 ) ;
11174: LD_EXP 5
11178: PPUSH
11179: LD_STRING D2c-Cyrus-1
11181: PPUSH
11182: CALL_OW 88
// if Cyrusinvehicle then
11186: LD_EXP 20
11190: IFFALSE 11204
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11192: LD_EXP 5
11196: PPUSH
11197: LD_STRING D2c-Cyrus-1a
11199: PPUSH
11200: CALL_OW 88
// EnableExclamations ;
11204: CALL_OW 473
// end ;
11208: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Bobby ) ) = engine_solar marked 7 do
11209: LD_EXP 4
11213: PPUSH
11214: CALL_OW 310
11218: PPUSH
11219: CALL_OW 262
11223: PUSH
11224: LD_INT 2
11226: EQUAL
11227: IFFALSE 11252
11229: GO 11231
11231: DISABLE
// begin EnableExclamations ;
11232: CALL_OW 473
// Say ( Bobby , D2c-Bobby-1 ) ;
11236: LD_EXP 4
11240: PPUSH
11241: LD_STRING D2c-Bobby-1
11243: PPUSH
11244: CALL_OW 88
// DisableExclamations ;
11248: CALL_OW 474
// end ;
11252: END
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) marked 2 do var hold_list ;
11253: LD_EXP 7
11257: PPUSH
11258: LD_INT 2
11260: PPUSH
11261: CALL_OW 308
11265: IFFALSE 12121
11267: GO 11269
11269: DISABLE
11270: LD_INT 0
11272: PPUSH
// begin PlaceUnitXY ( Frank , 34 , 65 , false ) ;
11273: LD_EXP 11
11277: PPUSH
11278: LD_INT 34
11280: PPUSH
11281: LD_INT 65
11283: PPUSH
11284: LD_INT 0
11286: PPUSH
11287: CALL_OW 48
// ComMoveXY ( Frank , 50 , 74 ) ;
11291: LD_EXP 11
11295: PPUSH
11296: LD_INT 50
11298: PPUSH
11299: LD_INT 74
11301: PPUSH
11302: CALL_OW 111
// AddComMoveXY ( Frank , 60 , 87 ) ;
11306: LD_EXP 11
11310: PPUSH
11311: LD_INT 60
11313: PPUSH
11314: LD_INT 87
11316: PPUSH
11317: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11321: LD_INT 35
11323: PPUSH
11324: CALL_OW 67
// until not IsBusy ( Frank ) ;
11328: LD_EXP 11
11332: PPUSH
11333: CALL_OW 315
11337: NOT
11338: IFFALSE 11321
// CenterOnUnits ( Frank ) ;
11340: LD_EXP 11
11344: PPUSH
11345: CALL_OW 85
// InGameOn ;
11349: CALL_OW 8
// hold_list := [ Frank ] ;
11353: LD_ADDR_VAR 0 1
11357: PUSH
11358: LD_EXP 11
11362: PUSH
11363: EMPTY
11364: LIST
11365: ST_TO_ADDR
// if IsInArea ( MacMillan , Am_Base ) and not ( GetType ( IsInUnit ( MacMillan ) ) = unit_building ) then
11366: LD_EXP 7
11370: PPUSH
11371: LD_INT 2
11373: PPUSH
11374: CALL_OW 308
11378: PUSH
11379: LD_EXP 7
11383: PPUSH
11384: CALL_OW 310
11388: PPUSH
11389: CALL_OW 247
11393: PUSH
11394: LD_INT 3
11396: EQUAL
11397: NOT
11398: AND
11399: IFFALSE 11432
// begin ComMoveXY ( MacMillan , 62 , 91 ) ;
11401: LD_EXP 7
11405: PPUSH
11406: LD_INT 62
11408: PPUSH
11409: LD_INT 91
11411: PPUSH
11412: CALL_OW 111
// hold_list := hold_list ^ MacMillan ;
11416: LD_ADDR_VAR 0 1
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: LD_EXP 7
11430: ADD
11431: ST_TO_ADDR
// end ; if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11432: LD_EXP 6
11436: PPUSH
11437: LD_INT 2
11439: PPUSH
11440: CALL_OW 308
11444: PUSH
11445: LD_EXP 6
11449: PPUSH
11450: CALL_OW 310
11454: PPUSH
11455: CALL_OW 247
11459: PUSH
11460: LD_INT 3
11462: EQUAL
11463: NOT
11464: AND
11465: IFFALSE 11498
// begin ComMoveXY ( Lisa , 59 , 90 ) ;
11467: LD_EXP 6
11471: PPUSH
11472: LD_INT 59
11474: PPUSH
11475: LD_INT 90
11477: PPUSH
11478: CALL_OW 111
// hold_list := hold_list ^ Lisa ;
11482: LD_ADDR_VAR 0 1
11486: PUSH
11487: LD_VAR 0 1
11491: PUSH
11492: LD_EXP 6
11496: ADD
11497: ST_TO_ADDR
// end ; if IsInArea ( am1 , Am_Base ) and not ( GetType ( IsInUnit ( am1 ) ) = unit_building ) then
11498: LD_INT 2
11500: PPUSH
11501: LD_INT 2
11503: PPUSH
11504: CALL_OW 308
11508: PUSH
11509: LD_INT 2
11511: PPUSH
11512: CALL_OW 310
11516: PPUSH
11517: CALL_OW 247
11521: PUSH
11522: LD_INT 3
11524: EQUAL
11525: NOT
11526: AND
11527: IFFALSE 11556
// begin ComMoveXY ( am1 , 65 , 91 ) ;
11529: LD_INT 2
11531: PPUSH
11532: LD_INT 65
11534: PPUSH
11535: LD_INT 91
11537: PPUSH
11538: CALL_OW 111
// hold_list := hold_list ^ am1 ;
11542: LD_ADDR_VAR 0 1
11546: PUSH
11547: LD_VAR 0 1
11551: PUSH
11552: LD_INT 2
11554: ADD
11555: ST_TO_ADDR
// end ; Wait ( 0 0$2 ) ;
11556: LD_INT 70
11558: PPUSH
11559: CALL_OW 67
// InGameOff ;
11563: CALL_OW 9
// interface_hidden := true ;
11567: LD_ADDR_OWVAR 54
11571: PUSH
11572: LD_INT 1
11574: ST_TO_ADDR
// DialogueOn ;
11575: CALL_OW 6
// Meet_Frank := true ;
11579: LD_ADDR_EXP 44
11583: PUSH
11584: LD_INT 1
11586: ST_TO_ADDR
// ComHold ( hold_list ) ;
11587: LD_VAR 0 1
11591: PPUSH
11592: CALL_OW 140
// AddComTurnUnit ( Frank , MacMillan ) ;
11596: LD_EXP 11
11600: PPUSH
11601: LD_EXP 7
11605: PPUSH
11606: CALL_OW 179
// AddComTurnUnit ( hold_list diff Frank , Frank ) ;
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 11
11619: DIFF
11620: PPUSH
11621: LD_EXP 11
11625: PPUSH
11626: CALL_OW 179
// Say ( MacMillan , D6-JMM-1 ) ;
11630: LD_EXP 7
11634: PPUSH
11635: LD_STRING D6-JMM-1
11637: PPUSH
11638: CALL_OW 88
// Say ( Frank , D6-Frank-1 ) ;
11642: LD_EXP 11
11646: PPUSH
11647: LD_STRING D6-Frank-1
11649: PPUSH
11650: CALL_OW 88
// RevealFogArea ( you , odkryj_mapu ) ;
11654: LD_EXP 1
11658: PPUSH
11659: LD_INT 5
11661: PPUSH
11662: CALL_OW 332
// CenterOnXY ( 33 , 12 ) ;
11666: LD_INT 33
11668: PPUSH
11669: LD_INT 12
11671: PPUSH
11672: CALL_OW 84
// DWait ( 0 0$4 ) ;
11676: LD_INT 140
11678: PPUSH
11679: CALL_OW 68
// CenterOnXY ( 65 , 18 ) ;
11683: LD_INT 65
11685: PPUSH
11686: LD_INT 18
11688: PPUSH
11689: CALL_OW 84
// DWait ( 0 0$3 ) ;
11693: LD_INT 105
11695: PPUSH
11696: CALL_OW 68
// CenterOnUnits ( Frank ) ;
11700: LD_EXP 11
11704: PPUSH
11705: CALL_OW 85
// DWait ( 0 0$4 ) ;
11709: LD_INT 140
11711: PPUSH
11712: CALL_OW 68
// DialogueOff ;
11716: CALL_OW 7
// InGameOn ;
11720: CALL_OW 8
// if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11724: LD_EXP 6
11728: PPUSH
11729: LD_INT 2
11731: PPUSH
11732: CALL_OW 308
11736: PUSH
11737: LD_EXP 6
11741: PPUSH
11742: CALL_OW 310
11746: PPUSH
11747: CALL_OW 247
11751: PUSH
11752: LD_INT 3
11754: EQUAL
11755: NOT
11756: AND
11757: IFFALSE 11813
// begin ComMoveUnit ( Lisa , Frank ) ;
11759: LD_EXP 6
11763: PPUSH
11764: LD_EXP 11
11768: PPUSH
11769: CALL_OW 112
// Wait ( 40 ) ;
11773: LD_INT 40
11775: PPUSH
11776: CALL_OW 67
// Say ( Lisa , D6-Lisa-1 ) ;
11780: LD_EXP 6
11784: PPUSH
11785: LD_STRING D6-Lisa-1
11787: PPUSH
11788: CALL_OW 88
// Say ( Frank , D6-Frank-2 ) ;
11792: LD_EXP 11
11796: PPUSH
11797: LD_STRING D6-Frank-2
11799: PPUSH
11800: CALL_OW 88
// ComHold ( Lisa ) ;
11804: LD_EXP 6
11808: PPUSH
11809: CALL_OW 140
// end ; InGameOff ;
11813: CALL_OW 9
// DialogueOn ;
11817: CALL_OW 6
// interface_hidden := true ;
11821: LD_ADDR_OWVAR 54
11825: PUSH
11826: LD_INT 1
11828: ST_TO_ADDR
// Say ( am1 , D6-Sol1-2 ) ;
11829: LD_INT 2
11831: PPUSH
11832: LD_STRING D6-Sol1-2
11834: PPUSH
11835: CALL_OW 88
// Say ( MacMillan , D6-JMM-2 ) ;
11839: LD_EXP 7
11843: PPUSH
11844: LD_STRING D6-JMM-2
11846: PPUSH
11847: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
11851: LD_EXP 11
11855: PPUSH
11856: LD_STRING D6-Frank-3
11858: PPUSH
11859: CALL_OW 88
// Say ( MacMillan , D6-JMM-3 ) ;
11863: LD_EXP 7
11867: PPUSH
11868: LD_STRING D6-JMM-3
11870: PPUSH
11871: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
11875: LD_EXP 11
11879: PPUSH
11880: LD_STRING D6-Frank-4
11882: PPUSH
11883: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
11887: LD_EXP 11
11891: PPUSH
11892: LD_STRING D6-Frank-4a
11894: PPUSH
11895: CALL_OW 88
// Say ( MacMillan , D6-JMM-4 ) ;
11899: LD_EXP 7
11903: PPUSH
11904: LD_STRING D6-JMM-4
11906: PPUSH
11907: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
11911: LD_EXP 11
11915: PPUSH
11916: LD_STRING D6-Frank-5
11918: PPUSH
11919: CALL_OW 88
// if IsOK ( Lisa ) then
11923: LD_EXP 6
11927: PPUSH
11928: CALL_OW 302
11932: IFFALSE 11946
// Say ( Lisa , D6-Lisa-5 ) ;
11934: LD_EXP 6
11938: PPUSH
11939: LD_STRING D6-Lisa-5
11941: PPUSH
11942: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
11946: LD_EXP 11
11950: PPUSH
11951: LD_STRING D6-Frank-6
11953: PPUSH
11954: CALL_OW 88
// Say ( MacMillan , D6-JMM-6 ) ;
11958: LD_EXP 7
11962: PPUSH
11963: LD_STRING D6-JMM-6
11965: PPUSH
11966: CALL_OW 88
// Frank_Query := Query ( Q1 ) ;
11970: LD_ADDR_EXP 47
11974: PUSH
11975: LD_STRING Q1
11977: PPUSH
11978: CALL_OW 97
11982: ST_TO_ADDR
// if Frank_Query = 1 then
11983: LD_EXP 47
11987: PUSH
11988: LD_INT 1
11990: EQUAL
11991: IFFALSE 12085
// begin SetSide ( Frank , neutral ) ;
11993: LD_EXP 11
11997: PPUSH
11998: LD_EXP 3
12002: PPUSH
12003: CALL_OW 235
// ComStop ( Lisa ) ;
12007: LD_EXP 6
12011: PPUSH
12012: CALL_OW 141
// ComMoveXY ( Frank , 35 , 68 ) ;
12016: LD_EXP 11
12020: PPUSH
12021: LD_INT 35
12023: PPUSH
12024: LD_INT 68
12026: PPUSH
12027: CALL_OW 111
// Wait ( 0 0$2 ) ;
12031: LD_INT 70
12033: PPUSH
12034: CALL_OW 67
// DialogueOff ;
12038: CALL_OW 7
// interface_hidden := false ;
12042: LD_ADDR_OWVAR 54
12046: PUSH
12047: LD_INT 0
12049: ST_TO_ADDR
// repeat Wait ( 0 0$0.5 ) ;
12050: LD_INT 18
12052: PPUSH
12053: CALL_OW 67
// until IsAt ( Frank , 35 , 68 ) ;
12057: LD_EXP 11
12061: PPUSH
12062: LD_INT 35
12064: PPUSH
12065: LD_INT 68
12067: PPUSH
12068: CALL_OW 307
12072: IFFALSE 12050
// RemoveUnit ( Frank ) ;
12074: LD_EXP 11
12078: PPUSH
12079: CALL_OW 64
// end else
12083: GO 12097
// begin DialogueOff ;
12085: CALL_OW 7
// interface_hidden := false ;
12089: LD_ADDR_OWVAR 54
12093: PUSH
12094: LD_INT 0
12096: ST_TO_ADDR
// end ; ComStop ( hold_list diff Frank ) ;
12097: LD_VAR 0 1
12101: PUSH
12102: LD_EXP 11
12106: DIFF
12107: PPUSH
12108: CALL_OW 141
// ComFree ( hold_list ) ;
12112: LD_VAR 0 1
12116: PPUSH
12117: CALL_OW 139
// end ;
12121: PPOPN 1
12123: END
// every 0 0$5 marked 5 do
12124: GO 12126
12126: DISABLE
// begin wait ( 0 0$10 ) ;
12127: LD_INT 350
12129: PPUSH
12130: CALL_OW 67
// RevealFogArea ( you , odkryj_mapu2 ) ;
12134: LD_EXP 1
12138: PPUSH
12139: LD_INT 8
12141: PPUSH
12142: CALL_OW 332
// SayRadio ( Frank , D3b-Frank-1 ) ;
12146: LD_EXP 11
12150: PPUSH
12151: LD_STRING D3b-Frank-1
12153: PPUSH
12154: CALL_OW 94
// end ;
12158: END
// every 0 0$10 trigger ( TICK > ( time_to_attack - 2 2$30 ) ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) > 5 ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) >= FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ) do
12159: LD_OWVAR 1
12163: PUSH
12164: LD_EXP 41
12168: PUSH
12169: LD_INT 5250
12171: MINUS
12172: GREATER
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_EXP 1
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: LD_INT 21
12188: PUSH
12189: LD_INT 2
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 2
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: PPUSH
12211: CALL_OW 69
12215: PUSH
12216: LD_INT 5
12218: GREATER
12219: OR
12220: PUSH
12221: LD_INT 22
12223: PUSH
12224: LD_EXP 1
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 21
12235: PUSH
12236: LD_INT 2
12238: PUSH
12239: EMPTY
12240: LIST
12241: LIST
12242: PUSH
12243: LD_INT 32
12245: PUSH
12246: LD_INT 2
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: LIST
12257: PPUSH
12258: CALL_OW 69
12262: PUSH
12263: LD_INT 22
12265: PUSH
12266: LD_EXP 1
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 21
12277: PUSH
12278: LD_INT 1
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 50
12287: PUSH
12288: EMPTY
12289: LIST
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 69
12300: GREATEREQUAL
12301: OR
12302: IFFALSE 12341
12304: GO 12306
12306: DISABLE
// begin if cornell_lost then
12307: LD_EXP 46
12311: IFFALSE 12315
// exit ;
12313: GO 12341
// time_to_attack := TICK + 2 2$30 ;
12315: LD_ADDR_EXP 41
12319: PUSH
12320: LD_OWVAR 1
12324: PUSH
12325: LD_INT 5250
12327: PLUS
12328: ST_TO_ADDR
// SayRadio ( Cornell , D3-Corn-1 ) ;
12329: LD_EXP 8
12333: PPUSH
12334: LD_STRING D3-Corn-1
12336: PPUSH
12337: CALL_OW 94
// end ;
12341: END
// every 0 0$10 trigger TICK > ( time_to_attack ) do
12342: LD_OWVAR 1
12346: PUSH
12347: LD_EXP 41
12351: GREATER
12352: IFFALSE 12557
12354: GO 12356
12356: DISABLE
// begin if cornell_lost then
12357: LD_EXP 46
12361: IFFALSE 12365
// exit ;
12363: GO 12557
// CenterOnUnits ( MacMillan ) ;
12365: LD_EXP 7
12369: PPUSH
12370: CALL_OW 85
// DisableExclamations ;
12374: CALL_OW 474
// DialogueOn ;
12378: CALL_OW 6
// interface_hidden := true ;
12382: LD_ADDR_OWVAR 54
12386: PUSH
12387: LD_INT 1
12389: ST_TO_ADDR
// SayRadio ( Cornell , D3a-Corn-1 ) ;
12390: LD_EXP 8
12394: PPUSH
12395: LD_STRING D3a-Corn-1
12397: PPUSH
12398: CALL_OW 94
// Say ( MacMillan , D3a-JMM-1 ) ;
12402: LD_EXP 7
12406: PPUSH
12407: LD_STRING D3a-JMM-1
12409: PPUSH
12410: CALL_OW 88
// SayRadio ( Cornell , D3a-Corn-2 ) ;
12414: LD_EXP 8
12418: PPUSH
12419: LD_STRING D3a-Corn-2
12421: PPUSH
12422: CALL_OW 94
// interface_hidden := false ;
12426: LD_ADDR_OWVAR 54
12430: PUSH
12431: LD_INT 0
12433: ST_TO_ADDR
// DialogueOff ;
12434: CALL_OW 7
// EnableExclamations ;
12438: CALL_OW 473
// ChangeMissionObjectives ( MOutWait ) ;
12442: LD_STRING MOutWait
12444: PPUSH
12445: CALL_OW 337
// ChangeMissionObjectives ( M2 ) ;
12449: LD_STRING M2
12451: PPUSH
12452: CALL_OW 337
// SetAreaMapShow ( TopBorder , 1 ) ;
12456: LD_INT 1
12458: PPUSH
12459: LD_INT 1
12461: PPUSH
12462: CALL_OW 424
// if FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_nation , nation_american ] ] ) then
12466: LD_INT 22
12468: PUSH
12469: LD_EXP 1
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 21
12480: PUSH
12481: LD_INT 2
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 23
12490: PUSH
12491: LD_INT 1
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: PPUSH
12503: CALL_OW 69
12507: IFFALSE 12518
// Hint ( Skills1 ) else
12509: LD_STRING Skills1
12511: PPUSH
12512: CALL_OW 339
12516: GO 12525
// Hint ( Skills2 ) ;
12518: LD_STRING Skills2
12520: PPUSH
12521: CALL_OW 339
// if ( GetSide ( Frank ) = neutral ) then
12525: LD_EXP 11
12529: PPUSH
12530: CALL_OW 255
12534: PUSH
12535: LD_EXP 3
12539: EQUAL
12540: IFFALSE 12545
// enable ( 5 ) ;
12542: LD_INT 5
12544: ENABLE_MARKED
// atack := 1 ;
12545: LD_ADDR_EXP 16
12549: PUSH
12550: LD_INT 1
12552: ST_TO_ADDR
// attack_began ;
12553: CALL 6025 0 0
// end ;
12557: END
// every 0 0$10 trigger TICK > ( time_to_attack + time_to_return - 1 1$0 ) do
12558: LD_OWVAR 1
12562: PUSH
12563: LD_EXP 41
12567: PUSH
12568: LD_EXP 40
12572: PLUS
12573: PUSH
12574: LD_INT 2100
12576: MINUS
12577: GREATER
12578: IFFALSE 12602
12580: GO 12582
12582: DISABLE
// begin if not cornell_lost then
12583: LD_EXP 46
12587: NOT
12588: IFFALSE 12602
// SayRadio ( Cornell , D4-Corn-1 ) ;
12590: LD_EXP 8
12594: PPUSH
12595: LD_STRING D4-Corn-1
12597: PPUSH
12598: CALL_OW 94
// end ;
12602: END
// every 0 0$1 trigger GridY ( MacMillan ) < 10 or TICK > ( time_to_attack + time_to_return ) marked 3 do
12603: LD_EXP 7
12607: PPUSH
12608: CALL 2553 0 1
12612: PUSH
12613: LD_INT 10
12615: LESS
12616: PUSH
12617: LD_OWVAR 1
12621: PUSH
12622: LD_EXP 41
12626: PUSH
12627: LD_EXP 40
12631: PLUS
12632: GREATER
12633: OR
12634: IFFALSE 12683
12636: GO 12638
12638: DISABLE
// begin SayRadio ( Cornell , D5-Corn-1 ) ;
12639: LD_EXP 8
12643: PPUSH
12644: LD_STRING D5-Corn-1
12646: PPUSH
12647: CALL_OW 94
// if TICK < ( 15 15$0 + time_to_return ) then
12651: LD_OWVAR 1
12655: PUSH
12656: LD_INT 31500
12658: PUSH
12659: LD_EXP 40
12663: PLUS
12664: LESS
12665: IFFALSE 12675
// atack := 0 ;
12667: LD_ADDR_EXP 16
12671: PUSH
12672: LD_INT 0
12674: ST_TO_ADDR
// cornell_lost := true ;
12675: LD_ADDR_EXP 46
12679: PUSH
12680: LD_INT 1
12682: ST_TO_ADDR
// end ;
12683: END
// export function talk_about_attack ; begin
12684: LD_INT 0
12686: PPUSH
// DisableExclamations ;
12687: CALL_OW 474
// if IsOK ( patrol1 ) and IsOK ( patrol2 ) then
12691: LD_INT 14
12693: PPUSH
12694: CALL_OW 302
12698: PUSH
12699: LD_INT 15
12701: PPUSH
12702: CALL_OW 302
12706: AND
12707: IFFALSE 12723
// Say ( MacMillan , D8b-JMM-1a ) else
12709: LD_EXP 7
12713: PPUSH
12714: LD_STRING D8b-JMM-1a
12716: PPUSH
12717: CALL_OW 88
12721: GO 12735
// Say ( MacMillan , D8b-JMM-1 ) ;
12723: LD_EXP 7
12727: PPUSH
12728: LD_STRING D8b-JMM-1
12730: PPUSH
12731: CALL_OW 88
// Say ( am1 , D8b-Sol1-1 ) ;
12735: LD_INT 2
12737: PPUSH
12738: LD_STRING D8b-Sol1-1
12740: PPUSH
12741: CALL_OW 88
// if IsOK ( Cyrus ) then
12745: LD_EXP 5
12749: PPUSH
12750: CALL_OW 302
12754: IFFALSE 12768
// Say ( Cyrus , D8b-Cyrus-1 ) ;
12756: LD_EXP 5
12760: PPUSH
12761: LD_STRING D8b-Cyrus-1
12763: PPUSH
12764: CALL_OW 88
// if IsOK ( Bobby ) then
12768: LD_EXP 4
12772: PPUSH
12773: CALL_OW 302
12777: IFFALSE 12791
// Say ( Bobby , D8b-Bobby-1 ) ;
12779: LD_EXP 4
12783: PPUSH
12784: LD_STRING D8b-Bobby-1
12786: PPUSH
12787: CALL_OW 88
// if not ( IsOK ( Cyrus ) or IsOK ( Bobby ) ) then
12791: LD_EXP 5
12795: PPUSH
12796: CALL_OW 302
12800: PUSH
12801: LD_EXP 4
12805: PPUSH
12806: CALL_OW 302
12810: OR
12811: NOT
12812: IFFALSE 12824
// Say ( am2 , D8b-Sol2-1 ) ;
12814: LD_INT 3
12816: PPUSH
12817: LD_STRING D8b-Sol2-1
12819: PPUSH
12820: CALL_OW 88
// Say ( MacMillan , D8b-JMM-2 ) ;
12824: LD_EXP 7
12828: PPUSH
12829: LD_STRING D8b-JMM-2
12831: PPUSH
12832: CALL_OW 88
// if IsOK ( Lisa ) then
12836: LD_EXP 6
12840: PPUSH
12841: CALL_OW 302
12845: IFFALSE 12859
// Say ( Lisa , D8b-Lisa-2 ) ;
12847: LD_EXP 6
12851: PPUSH
12852: LD_STRING D8b-Lisa-2
12854: PPUSH
12855: CALL_OW 88
// EnableExclamations ;
12859: CALL_OW 473
// end ; end_of_file
12863: LD_VAR 0 1
12867: RET
// export ru_trucks , ru_drivers ; var levels , positions ; export s_guard1 , s_guard2 , s_guard3 , s_guard4 , home_11 , home_12 , home_21 , home_22 , home_31 , home_32 , grass_31 , grass_32 , grass_33 ; export function prepare_russian_side ; begin
12868: LD_INT 0
12870: PPUSH
// levels := [ 1 , 3 , 6 ] [ difficulty ] ;
12871: LD_ADDR_LOC 3
12875: PUSH
12876: LD_INT 1
12878: PUSH
12879: LD_INT 3
12881: PUSH
12882: LD_INT 6
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: LIST
12889: PUSH
12890: LD_OWVAR 67
12894: ARRAY
12895: ST_TO_ADDR
// positions := [ 21 , 14 , 29 , 8 , 49 , 23 , 55 , 13 , 75 , 22 , 93 , 20 , 106 , 20 , 145 , 106 ] ;
12896: LD_ADDR_LOC 4
12900: PUSH
12901: LD_INT 21
12903: PUSH
12904: LD_INT 14
12906: PUSH
12907: LD_INT 29
12909: PUSH
12910: LD_INT 8
12912: PUSH
12913: LD_INT 49
12915: PUSH
12916: LD_INT 23
12918: PUSH
12919: LD_INT 55
12921: PUSH
12922: LD_INT 13
12924: PUSH
12925: LD_INT 75
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 93
12933: PUSH
12934: LD_INT 20
12936: PUSH
12937: LD_INT 106
12939: PUSH
12940: LD_INT 20
12942: PUSH
12943: LD_INT 145
12945: PUSH
12946: LD_INT 106
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: ST_TO_ADDR
// if difficulty > 1 then
12967: LD_OWVAR 67
12971: PUSH
12972: LD_INT 1
12974: GREATER
12975: IFFALSE 12989
// begin prepare_home1 ;
12977: CALL 13018 0 0
// prepare_home2 ;
12981: CALL 13170 0 0
// prepare_home3 ;
12985: CALL 13322 0 0
// end ; prepare_s_guard ;
12989: CALL 13474 0 0
// prepare_grass3 ;
12993: CALL 13668 0 0
// prepare_drivers ;
12997: CALL 13925 0 0
// prepare_vehicles ;
13001: CALL 14030 0 0
// drivers_into_vehicles ;
13005: CALL 14300 0 0
// place_russian_batery ;
13009: CALL 13837 0 0
// end ;
13013: LD_VAR 0 1
13017: RET
// function prepare_home1 ; var un , sol ; begin
13018: LD_INT 0
13020: PPUSH
13021: PPUSH
13022: PPUSH
// uc_side := russians ;
13023: LD_ADDR_OWVAR 20
13027: PUSH
13028: LD_EXP 2
13032: ST_TO_ADDR
// uc_nation := nation_russian ;
13033: LD_ADDR_OWVAR 21
13037: PUSH
13038: LD_INT 3
13040: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13041: LD_ADDR_VAR 0 2
13045: PUSH
13046: DOUBLE
13047: LD_INT 1
13049: DEC
13050: ST_TO_ADDR
13051: LD_OWVAR 67
13055: PUSH
13056: LD_INT 1
13058: MINUS
13059: PUSH
13060: FOR_TO
13061: IFFALSE 13163
// begin PrepareSoldier ( 0 , levels ) ;
13063: LD_INT 0
13065: PPUSH
13066: LD_LOC 3
13070: PPUSH
13071: CALL_OW 381
// sol := CreateHuman ;
13075: LD_ADDR_VAR 0 3
13079: PUSH
13080: CALL_OW 44
13084: ST_TO_ADDR
// case un of 1 :
13085: LD_VAR 0 2
13089: PUSH
13090: LD_INT 1
13092: DOUBLE
13093: EQUAL
13094: IFTRUE 13098
13096: GO 13111
13098: POP
// home_11 := sol ; 2 :
13099: LD_ADDR_EXP 54
13103: PUSH
13104: LD_VAR 0 3
13108: ST_TO_ADDR
13109: GO 13133
13111: LD_INT 2
13113: DOUBLE
13114: EQUAL
13115: IFTRUE 13119
13117: GO 13132
13119: POP
// home_12 := sol ; end ;
13120: LD_ADDR_EXP 55
13124: PUSH
13125: LD_VAR 0 3
13129: ST_TO_ADDR
13130: GO 13133
13132: POP
// PlaceUnitXYR ( sol , 88 , 23 , 3 , false ) ;
13133: LD_VAR 0 3
13137: PPUSH
13138: LD_INT 88
13140: PPUSH
13141: LD_INT 23
13143: PPUSH
13144: LD_INT 3
13146: PPUSH
13147: LD_INT 0
13149: PPUSH
13150: CALL_OW 50
// wait ( 1 ) ;
13154: LD_INT 1
13156: PPUSH
13157: CALL_OW 67
// end ;
13161: GO 13060
13163: POP
13164: POP
// end ;
13165: LD_VAR 0 1
13169: RET
// function prepare_home2 ; var un , sol ; begin
13170: LD_INT 0
13172: PPUSH
13173: PPUSH
13174: PPUSH
// uc_side := russians ;
13175: LD_ADDR_OWVAR 20
13179: PUSH
13180: LD_EXP 2
13184: ST_TO_ADDR
// uc_nation := nation_russian ;
13185: LD_ADDR_OWVAR 21
13189: PUSH
13190: LD_INT 3
13192: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13193: LD_ADDR_VAR 0 2
13197: PUSH
13198: DOUBLE
13199: LD_INT 1
13201: DEC
13202: ST_TO_ADDR
13203: LD_OWVAR 67
13207: PUSH
13208: LD_INT 1
13210: MINUS
13211: PUSH
13212: FOR_TO
13213: IFFALSE 13315
// begin PrepareSoldier ( 0 , levels ) ;
13215: LD_INT 0
13217: PPUSH
13218: LD_LOC 3
13222: PPUSH
13223: CALL_OW 381
// sol := CreateHuman ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: CALL_OW 44
13236: ST_TO_ADDR
// case un of 1 :
13237: LD_VAR 0 2
13241: PUSH
13242: LD_INT 1
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13263
13250: POP
// home_21 := sol ; 2 :
13251: LD_ADDR_EXP 56
13255: PUSH
13256: LD_VAR 0 3
13260: ST_TO_ADDR
13261: GO 13285
13263: LD_INT 2
13265: DOUBLE
13266: EQUAL
13267: IFTRUE 13271
13269: GO 13284
13271: POP
// home_22 := sol ; end ;
13272: LD_ADDR_EXP 57
13276: PUSH
13277: LD_VAR 0 3
13281: ST_TO_ADDR
13282: GO 13285
13284: POP
// PlaceUnitXYR ( sol , 69 , 19 , 3 , false ) ;
13285: LD_VAR 0 3
13289: PPUSH
13290: LD_INT 69
13292: PPUSH
13293: LD_INT 19
13295: PPUSH
13296: LD_INT 3
13298: PPUSH
13299: LD_INT 0
13301: PPUSH
13302: CALL_OW 50
// wait ( 1 ) ;
13306: LD_INT 1
13308: PPUSH
13309: CALL_OW 67
// end ;
13313: GO 13212
13315: POP
13316: POP
// end ;
13317: LD_VAR 0 1
13321: RET
// function prepare_home3 ; var un , sol ; begin
13322: LD_INT 0
13324: PPUSH
13325: PPUSH
13326: PPUSH
// uc_side := russians ;
13327: LD_ADDR_OWVAR 20
13331: PUSH
13332: LD_EXP 2
13336: ST_TO_ADDR
// uc_nation := nation_russian ;
13337: LD_ADDR_OWVAR 21
13341: PUSH
13342: LD_INT 3
13344: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13345: LD_ADDR_VAR 0 2
13349: PUSH
13350: DOUBLE
13351: LD_INT 1
13353: DEC
13354: ST_TO_ADDR
13355: LD_OWVAR 67
13359: PUSH
13360: LD_INT 1
13362: MINUS
13363: PUSH
13364: FOR_TO
13365: IFFALSE 13467
// begin PrepareSoldier ( 0 , levels ) ;
13367: LD_INT 0
13369: PPUSH
13370: LD_LOC 3
13374: PPUSH
13375: CALL_OW 381
// sol := CreateHuman ;
13379: LD_ADDR_VAR 0 3
13383: PUSH
13384: CALL_OW 44
13388: ST_TO_ADDR
// case un of 1 :
13389: LD_VAR 0 2
13393: PUSH
13394: LD_INT 1
13396: DOUBLE
13397: EQUAL
13398: IFTRUE 13402
13400: GO 13415
13402: POP
// home_31 := sol ; 2 :
13403: LD_ADDR_EXP 58
13407: PUSH
13408: LD_VAR 0 3
13412: ST_TO_ADDR
13413: GO 13437
13415: LD_INT 2
13417: DOUBLE
13418: EQUAL
13419: IFTRUE 13423
13421: GO 13436
13423: POP
// home_32 := sol ; end ;
13424: LD_ADDR_EXP 59
13428: PUSH
13429: LD_VAR 0 3
13433: ST_TO_ADDR
13434: GO 13437
13436: POP
// PlaceUnitXYR ( sol , 17 , 10 , 3 , false ) ;
13437: LD_VAR 0 3
13441: PPUSH
13442: LD_INT 17
13444: PPUSH
13445: LD_INT 10
13447: PPUSH
13448: LD_INT 3
13450: PPUSH
13451: LD_INT 0
13453: PPUSH
13454: CALL_OW 50
// wait ( 1 ) ;
13458: LD_INT 1
13460: PPUSH
13461: CALL_OW 67
// end ;
13465: GO 13364
13467: POP
13468: POP
// end ;
13469: LD_VAR 0 1
13473: RET
// function prepare_s_guard ; var un , sol ; begin
13474: LD_INT 0
13476: PPUSH
13477: PPUSH
13478: PPUSH
// uc_side := russians ;
13479: LD_ADDR_OWVAR 20
13483: PUSH
13484: LD_EXP 2
13488: ST_TO_ADDR
// uc_nation := nation_russian ;
13489: LD_ADDR_OWVAR 21
13493: PUSH
13494: LD_INT 3
13496: ST_TO_ADDR
// for un = 1 to ( difficulty + 1 ) do
13497: LD_ADDR_VAR 0 2
13501: PUSH
13502: DOUBLE
13503: LD_INT 1
13505: DEC
13506: ST_TO_ADDR
13507: LD_OWVAR 67
13511: PUSH
13512: LD_INT 1
13514: PLUS
13515: PUSH
13516: FOR_TO
13517: IFFALSE 13661
// begin PrepareSoldier ( 0 , levels ) ;
13519: LD_INT 0
13521: PPUSH
13522: LD_LOC 3
13526: PPUSH
13527: CALL_OW 381
// sol := CreateHuman ;
13531: LD_ADDR_VAR 0 3
13535: PUSH
13536: CALL_OW 44
13540: ST_TO_ADDR
// case un of 1 :
13541: LD_VAR 0 2
13545: PUSH
13546: LD_INT 1
13548: DOUBLE
13549: EQUAL
13550: IFTRUE 13554
13552: GO 13567
13554: POP
// s_guard1 := sol ; 2 :
13555: LD_ADDR_EXP 50
13559: PUSH
13560: LD_VAR 0 3
13564: ST_TO_ADDR
13565: GO 13631
13567: LD_INT 2
13569: DOUBLE
13570: EQUAL
13571: IFTRUE 13575
13573: GO 13588
13575: POP
// s_guard2 := sol ; 3 :
13576: LD_ADDR_EXP 51
13580: PUSH
13581: LD_VAR 0 3
13585: ST_TO_ADDR
13586: GO 13631
13588: LD_INT 3
13590: DOUBLE
13591: EQUAL
13592: IFTRUE 13596
13594: GO 13609
13596: POP
// s_guard3 := sol ; 4 :
13597: LD_ADDR_EXP 52
13601: PUSH
13602: LD_VAR 0 3
13606: ST_TO_ADDR
13607: GO 13631
13609: LD_INT 4
13611: DOUBLE
13612: EQUAL
13613: IFTRUE 13617
13615: GO 13630
13617: POP
// s_guard4 := sol ; end ;
13618: LD_ADDR_EXP 53
13622: PUSH
13623: LD_VAR 0 3
13627: ST_TO_ADDR
13628: GO 13631
13630: POP
// PlaceUnitXYR ( sol , 118 , 105 , 3 , false ) ;
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_INT 118
13638: PPUSH
13639: LD_INT 105
13641: PPUSH
13642: LD_INT 3
13644: PPUSH
13645: LD_INT 0
13647: PPUSH
13648: CALL_OW 50
// wait ( 1 ) ;
13652: LD_INT 1
13654: PPUSH
13655: CALL_OW 67
// end ;
13659: GO 13516
13661: POP
13662: POP
// end ;
13663: LD_VAR 0 1
13667: RET
// function prepare_grass3 ; var un , sol ; begin
13668: LD_INT 0
13670: PPUSH
13671: PPUSH
13672: PPUSH
// uc_side := russians ;
13673: LD_ADDR_OWVAR 20
13677: PUSH
13678: LD_EXP 2
13682: ST_TO_ADDR
// uc_nation := nation_russian ;
13683: LD_ADDR_OWVAR 21
13687: PUSH
13688: LD_INT 3
13690: ST_TO_ADDR
// for un = 1 to difficulty do
13691: LD_ADDR_VAR 0 2
13695: PUSH
13696: DOUBLE
13697: LD_INT 1
13699: DEC
13700: ST_TO_ADDR
13701: LD_OWVAR 67
13705: PUSH
13706: FOR_TO
13707: IFFALSE 13830
// begin PrepareSoldier ( 0 , levels ) ;
13709: LD_INT 0
13711: PPUSH
13712: LD_LOC 3
13716: PPUSH
13717: CALL_OW 381
// sol := CreateHuman ;
13721: LD_ADDR_VAR 0 3
13725: PUSH
13726: CALL_OW 44
13730: ST_TO_ADDR
// case un of 1 :
13731: LD_VAR 0 2
13735: PUSH
13736: LD_INT 1
13738: DOUBLE
13739: EQUAL
13740: IFTRUE 13744
13742: GO 13757
13744: POP
// grass_31 := sol ; 2 :
13745: LD_ADDR_EXP 60
13749: PUSH
13750: LD_VAR 0 3
13754: ST_TO_ADDR
13755: GO 13800
13757: LD_INT 2
13759: DOUBLE
13760: EQUAL
13761: IFTRUE 13765
13763: GO 13778
13765: POP
// grass_32 := sol ; 3 :
13766: LD_ADDR_EXP 61
13770: PUSH
13771: LD_VAR 0 3
13775: ST_TO_ADDR
13776: GO 13800
13778: LD_INT 3
13780: DOUBLE
13781: EQUAL
13782: IFTRUE 13786
13784: GO 13799
13786: POP
// grass_33 := sol ; end ;
13787: LD_ADDR_EXP 62
13791: PUSH
13792: LD_VAR 0 3
13796: ST_TO_ADDR
13797: GO 13800
13799: POP
// PlaceUnitXYR ( sol , 73 , 38 , 3 , false ) ;
13800: LD_VAR 0 3
13804: PPUSH
13805: LD_INT 73
13807: PPUSH
13808: LD_INT 38
13810: PPUSH
13811: LD_INT 3
13813: PPUSH
13814: LD_INT 0
13816: PPUSH
13817: CALL_OW 50
// wait ( 1 ) ;
13821: LD_INT 1
13823: PPUSH
13824: CALL_OW 67
// end ;
13828: GO 13706
13830: POP
13831: POP
// end ;
13832: LD_VAR 0 1
13836: RET
// function place_russian_batery ; var i ; begin
13837: LD_INT 0
13839: PPUSH
13840: PPUSH
// for i = 1 to 8 do
13841: LD_ADDR_VAR 0 2
13845: PUSH
13846: DOUBLE
13847: LD_INT 1
13849: DEC
13850: ST_TO_ADDR
13851: LD_INT 8
13853: PUSH
13854: FOR_TO
13855: IFFALSE 13918
// begin PlaceUnitXY ( ru_trucks [ i ] , positions [ ( i * 2 ) - 1 ] , positions [ ( i * 2 ) ] , false ) ;
13857: LD_EXP 48
13861: PUSH
13862: LD_VAR 0 2
13866: ARRAY
13867: PPUSH
13868: LD_LOC 4
13872: PUSH
13873: LD_VAR 0 2
13877: PUSH
13878: LD_INT 2
13880: MUL
13881: PUSH
13882: LD_INT 1
13884: MINUS
13885: ARRAY
13886: PPUSH
13887: LD_LOC 4
13891: PUSH
13892: LD_VAR 0 2
13896: PUSH
13897: LD_INT 2
13899: MUL
13900: ARRAY
13901: PPUSH
13902: LD_INT 0
13904: PPUSH
13905: CALL_OW 48
// wait ( 1 ) ;
13909: LD_INT 1
13911: PPUSH
13912: CALL_OW 67
// end ;
13916: GO 13854
13918: POP
13919: POP
// end ;
13920: LD_VAR 0 1
13924: RET
// function prepare_drivers ; var i ; begin
13925: LD_INT 0
13927: PPUSH
13928: PPUSH
// ru_drivers := [ ] ;
13929: LD_ADDR_EXP 49
13933: PUSH
13934: EMPTY
13935: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
13936: LD_ADDR_OWVAR 24
13940: PUSH
13941: LD_INT 0
13943: PPUSH
13944: LD_INT 5
13946: PPUSH
13947: CALL_OW 12
13951: ST_TO_ADDR
// uc_nation = nation_russian ;
13952: LD_ADDR_OWVAR 21
13956: PUSH
13957: LD_INT 3
13959: ST_TO_ADDR
// uc_side = russians ;
13960: LD_ADDR_OWVAR 20
13964: PUSH
13965: LD_EXP 2
13969: ST_TO_ADDR
// for i = 1 to 8 do
13970: LD_ADDR_VAR 0 2
13974: PUSH
13975: DOUBLE
13976: LD_INT 1
13978: DEC
13979: ST_TO_ADDR
13980: LD_INT 8
13982: PUSH
13983: FOR_TO
13984: IFFALSE 14023
// begin PrepareMechanic ( 0 , levels ) ;
13986: LD_INT 0
13988: PPUSH
13989: LD_LOC 3
13993: PPUSH
13994: CALL_OW 383
// ru_drivers := ru_drivers ^ CreateHuman ;
13998: LD_ADDR_EXP 49
14002: PUSH
14003: LD_EXP 49
14007: PUSH
14008: CALL_OW 44
14012: ADD
14013: ST_TO_ADDR
// wait ( 1 ) ;
14014: LD_INT 1
14016: PPUSH
14017: CALL_OW 67
// end ;
14021: GO 13983
14023: POP
14024: POP
// end ;
14025: LD_VAR 0 1
14029: RET
// function prepare_vehicles ; var i , weapon ; begin
14030: LD_INT 0
14032: PPUSH
14033: PPUSH
14034: PPUSH
// ru_trucks := [ ] ;
14035: LD_ADDR_EXP 48
14039: PUSH
14040: EMPTY
14041: ST_TO_ADDR
// weapon := [ 1 , 0 , 0 ] ;
14042: LD_ADDR_VAR 0 3
14046: PUSH
14047: LD_INT 1
14049: PUSH
14050: LD_INT 0
14052: PUSH
14053: LD_INT 0
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: LIST
14060: ST_TO_ADDR
// uc_nation = nation_russian ;
14061: LD_ADDR_OWVAR 21
14065: PUSH
14066: LD_INT 3
14068: ST_TO_ADDR
// uc_side = russians ;
14069: LD_ADDR_OWVAR 20
14073: PUSH
14074: LD_EXP 2
14078: ST_TO_ADDR
// for i = 1 to 8 do
14079: LD_ADDR_VAR 0 2
14083: PUSH
14084: DOUBLE
14085: LD_INT 1
14087: DEC
14088: ST_TO_ADDR
14089: LD_INT 8
14091: PUSH
14092: FOR_TO
14093: IFFALSE 14293
// begin uc_direction = rand ( 0 , 5 ) ;
14095: LD_ADDR_OWVAR 24
14099: PUSH
14100: LD_INT 0
14102: PPUSH
14103: LD_INT 5
14105: PPUSH
14106: CALL_OW 12
14110: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
14111: LD_ADDR_OWVAR 37
14115: PUSH
14116: LD_INT 21
14118: ST_TO_ADDR
// vc_engine := engine_combustion ;
14119: LD_ADDR_OWVAR 39
14123: PUSH
14124: LD_INT 1
14126: ST_TO_ADDR
// vc_control := control_manual ;
14127: LD_ADDR_OWVAR 38
14131: PUSH
14132: LD_INT 1
14134: ST_TO_ADDR
// case ( i mod difficulty ) + 1 of 1 :
14135: LD_VAR 0 2
14139: PUSH
14140: LD_OWVAR 67
14144: MOD
14145: PUSH
14146: LD_INT 1
14148: PLUS
14149: PUSH
14150: LD_INT 1
14152: DOUBLE
14153: EQUAL
14154: IFTRUE 14158
14156: GO 14189
14158: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 3 ) + 1 ] ; 2 :
14159: LD_ADDR_OWVAR 40
14163: PUSH
14164: LD_INT 42
14166: PUSH
14167: LD_VAR 0 3
14171: PUSH
14172: LD_VAR 0 2
14176: PUSH
14177: LD_INT 3
14179: MOD
14180: PUSH
14181: LD_INT 1
14183: PLUS
14184: ARRAY
14185: PLUS
14186: ST_TO_ADDR
14187: GO 14268
14189: LD_INT 2
14191: DOUBLE
14192: EQUAL
14193: IFTRUE 14197
14195: GO 14228
14197: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 2 ) + 1 ] ; 3 :
14198: LD_ADDR_OWVAR 40
14202: PUSH
14203: LD_INT 42
14205: PUSH
14206: LD_VAR 0 3
14210: PUSH
14211: LD_VAR 0 2
14215: PUSH
14216: LD_INT 2
14218: MOD
14219: PUSH
14220: LD_INT 1
14222: PLUS
14223: ARRAY
14224: PLUS
14225: ST_TO_ADDR
14226: GO 14268
14228: LD_INT 3
14230: DOUBLE
14231: EQUAL
14232: IFTRUE 14236
14234: GO 14267
14236: POP
// vc_weapon := ru_gatling_gun - weapon [ ( i mod 3 ) + 1 ] ; end ;
14237: LD_ADDR_OWVAR 40
14241: PUSH
14242: LD_INT 43
14244: PUSH
14245: LD_VAR 0 3
14249: PUSH
14250: LD_VAR 0 2
14254: PUSH
14255: LD_INT 3
14257: MOD
14258: PUSH
14259: LD_INT 1
14261: PLUS
14262: ARRAY
14263: MINUS
14264: ST_TO_ADDR
14265: GO 14268
14267: POP
// ru_trucks := ru_trucks ^ CreateVehicle ;
14268: LD_ADDR_EXP 48
14272: PUSH
14273: LD_EXP 48
14277: PUSH
14278: CALL_OW 45
14282: ADD
14283: ST_TO_ADDR
// wait ( 1 ) ;
14284: LD_INT 1
14286: PPUSH
14287: CALL_OW 67
// end ;
14291: GO 14092
14293: POP
14294: POP
// end ;
14295: LD_VAR 0 1
14299: RET
// function drivers_into_vehicles ; var i ; begin
14300: LD_INT 0
14302: PPUSH
14303: PPUSH
// for i = 1 to 8 do
14304: LD_ADDR_VAR 0 2
14308: PUSH
14309: DOUBLE
14310: LD_INT 1
14312: DEC
14313: ST_TO_ADDR
14314: LD_INT 8
14316: PUSH
14317: FOR_TO
14318: IFFALSE 14355
// begin PlaceHumanInUnit ( ru_drivers [ i ] , ru_trucks [ i ] ) ;
14320: LD_EXP 49
14324: PUSH
14325: LD_VAR 0 2
14329: ARRAY
14330: PPUSH
14331: LD_EXP 48
14335: PUSH
14336: LD_VAR 0 2
14340: ARRAY
14341: PPUSH
14342: CALL_OW 52
// wait ( 1 ) ;
14346: LD_INT 1
14348: PPUSH
14349: CALL_OW 67
// end ;
14353: GO 14317
14355: POP
14356: POP
// end ; end_of_file
14357: LD_VAR 0 1
14361: RET
// on VehicleCaptured ( v_new , v_old , o_side , hum ) do begin ru_trucks := ru_trucks diff v_old ;
14362: LD_ADDR_EXP 48
14366: PUSH
14367: LD_EXP 48
14371: PUSH
14372: LD_VAR 0 2
14376: DIFF
14377: ST_TO_ADDR
// end ; end_of_file
14378: PPOPN 4
14380: END
// var remove_bunkers , remove_soldiers , remove_drivers , remove_vehicles ; export function fix_difficulty ; begin
14381: LD_INT 0
14383: PPUSH
// remove_bunkers := [ [ bunker2 , bunker3 , bunker5 , bunker6 ] , [ bunker2 , bunker5 ] ] ;
14384: LD_ADDR_LOC 5
14388: PUSH
14389: LD_INT 27
14391: PUSH
14392: LD_INT 34
14394: PUSH
14395: LD_INT 32
14397: PUSH
14398: LD_INT 31
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: PUSH
14407: LD_INT 27
14409: PUSH
14410: LD_INT 32
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: ST_TO_ADDR
// remove_soldiers := [ [ guard2 , guard3 , guard5 , guard6 ] , [ guard2 , guard5 ] ] ;
14421: LD_ADDR_LOC 6
14425: PUSH
14426: LD_INT 29
14428: PUSH
14429: LD_INT 48
14431: PUSH
14432: LD_INT 49
14434: PUSH
14435: LD_INT 20
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: LIST
14442: LIST
14443: PUSH
14444: LD_INT 29
14446: PUSH
14447: LD_INT 49
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: ST_TO_ADDR
// remove_drivers := [ [ ru_drivers [ 1 ] , ru_drivers [ 3 ] , ru_drivers [ 5 ] , ru_drivers [ 7 ] , ] , [ ru_drivers [ 2 ] , ru_drivers [ 4 ] , ru_drivers [ 6 ] ] ] ;
14458: LD_ADDR_LOC 7
14462: PUSH
14463: LD_EXP 49
14467: PUSH
14468: LD_INT 1
14470: ARRAY
14471: PUSH
14472: LD_EXP 49
14476: PUSH
14477: LD_INT 3
14479: ARRAY
14480: PUSH
14481: LD_EXP 49
14485: PUSH
14486: LD_INT 5
14488: ARRAY
14489: PUSH
14490: LD_EXP 49
14494: PUSH
14495: LD_INT 7
14497: ARRAY
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: PUSH
14505: LD_EXP 49
14509: PUSH
14510: LD_INT 2
14512: ARRAY
14513: PUSH
14514: LD_EXP 49
14518: PUSH
14519: LD_INT 4
14521: ARRAY
14522: PUSH
14523: LD_EXP 49
14527: PUSH
14528: LD_INT 6
14530: ARRAY
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: LIST
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: ST_TO_ADDR
// remove_vehicles := [ [ ru_trucks [ 1 ] , ru_trucks [ 3 ] , ru_trucks [ 5 ] , ru_trucks [ 7 ] , ] , [ ru_trucks [ 2 ] , ru_trucks [ 4 ] , ru_trucks [ 6 ] ] ] ;
14541: LD_ADDR_LOC 8
14545: PUSH
14546: LD_EXP 48
14550: PUSH
14551: LD_INT 1
14553: ARRAY
14554: PUSH
14555: LD_EXP 48
14559: PUSH
14560: LD_INT 3
14562: ARRAY
14563: PUSH
14564: LD_EXP 48
14568: PUSH
14569: LD_INT 5
14571: ARRAY
14572: PUSH
14573: LD_EXP 48
14577: PUSH
14578: LD_INT 7
14580: ARRAY
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: PUSH
14588: LD_EXP 48
14592: PUSH
14593: LD_INT 2
14595: ARRAY
14596: PUSH
14597: LD_EXP 48
14601: PUSH
14602: LD_INT 4
14604: ARRAY
14605: PUSH
14606: LD_EXP 48
14610: PUSH
14611: LD_INT 6
14613: ARRAY
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: LIST
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: ST_TO_ADDR
// if difficulty < 3 then
14624: LD_OWVAR 67
14628: PUSH
14629: LD_INT 3
14631: LESS
14632: IFFALSE 14694
// begin fce_remove_units ( remove_soldiers [ difficulty ] ) ;
14634: LD_LOC 6
14638: PUSH
14639: LD_OWVAR 67
14643: ARRAY
14644: PPUSH
14645: CALL 14699 0 1
// fce_remove_units ( remove_bunkers [ difficulty ] ) ;
14649: LD_LOC 5
14653: PUSH
14654: LD_OWVAR 67
14658: ARRAY
14659: PPUSH
14660: CALL 14699 0 1
// fce_remove_units ( remove_drivers [ difficulty ] ) ;
14664: LD_LOC 7
14668: PUSH
14669: LD_OWVAR 67
14673: ARRAY
14674: PPUSH
14675: CALL 14699 0 1
// fce_remove_units ( remove_vehicles [ difficulty ] ) ;
14679: LD_LOC 8
14683: PUSH
14684: LD_OWVAR 67
14688: ARRAY
14689: PPUSH
14690: CALL 14699 0 1
// end ; end ;
14694: LD_VAR 0 1
14698: RET
// function fce_remove_units ( list ) ; var un ; begin
14699: LD_INT 0
14701: PPUSH
14702: PPUSH
// for un in list do
14703: LD_ADDR_VAR 0 3
14707: PUSH
14708: LD_VAR 0 1
14712: PUSH
14713: FOR_IN
14714: IFFALSE 14727
// RemoveUnit ( un ) ;
14716: LD_VAR 0 3
14720: PPUSH
14721: CALL_OW 64
14725: GO 14713
14727: POP
14728: POP
// end ; end_of_file
14729: LD_VAR 0 2
14733: RET
// var h_workshop , h_lab ; export function init_hints ; begin
14734: LD_INT 0
14736: PPUSH
// h_workshop := true ;
14737: LD_ADDR_LOC 9
14741: PUSH
14742: LD_INT 1
14744: ST_TO_ADDR
// h_lab := true ;
14745: LD_ADDR_LOC 10
14749: PUSH
14750: LD_INT 1
14752: ST_TO_ADDR
// end ;
14753: LD_VAR 0 1
14757: RET
// on BuildingComplete ( un ) do begin if ( GetBType ( un ) = b_workshop ) and ( h_workshop ) then
14758: LD_VAR 0 1
14762: PPUSH
14763: CALL_OW 266
14767: PUSH
14768: LD_INT 2
14770: EQUAL
14771: PUSH
14772: LD_LOC 9
14776: AND
14777: IFFALSE 14828
// begin h_workshop := false ;
14779: LD_ADDR_LOC 9
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// if GetTech ( tech_SolEng , you ) = state_researched then
14787: LD_INT 45
14789: PPUSH
14790: LD_EXP 1
14794: PPUSH
14795: CALL_OW 321
14799: PUSH
14800: LD_INT 2
14802: EQUAL
14803: IFFALSE 14821
// begin Hint ( Workshop2 ) ;
14805: LD_STRING Workshop2
14807: PPUSH
14808: CALL_OW 339
// Hint ( BuildingVehicles ) ;
14812: LD_STRING BuildingVehicles
14814: PPUSH
14815: CALL_OW 339
// end else
14819: GO 14828
// Hint ( Workshop1 ) ;
14821: LD_STRING Workshop1
14823: PPUSH
14824: CALL_OW 339
// end ; if ( GetBType ( un ) = b_lab ) and ( h_lab ) then
14828: LD_VAR 0 1
14832: PPUSH
14833: CALL_OW 266
14837: PUSH
14838: LD_INT 6
14840: EQUAL
14841: PUSH
14842: LD_LOC 10
14846: AND
14847: IFFALSE 14864
// begin h_lab := false ;
14849: LD_ADDR_LOC 10
14853: PUSH
14854: LD_INT 0
14856: ST_TO_ADDR
// Hint ( Laboratory ) ;
14857: LD_STRING Laboratory
14859: PPUSH
14860: CALL_OW 339
// end ; end ;
14864: PPOPN 1
14866: END
// on Contact ( side1 , side2 ) marked 11 do begin Hint ( Shift ) ;
14867: LD_STRING Shift
14869: PPUSH
14870: CALL_OW 339
// disable ( 11 ) ;
14874: LD_INT 11
14876: DISABLE_MARKED
// end ;
14877: PPOPN 2
14879: END
