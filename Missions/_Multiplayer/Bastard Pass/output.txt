// export is_depot , add_depot , number_of_breastworks , number_of_people , skill_level , starting_crates , starting_resources , shipments_density , morale_decreasing_time , amount_of_apemen , amount_of_siberit , respawning_time_min , respawning_time_max ; export Side_Teams , Teams , Game_Type ; export Side_Positions , Side_Nations , Team_Game ; export Position_Sides ; export depot_def , breastworks_def , start_def , oil_deposits_locations , sib_deposits_locations ; export def_main_base_level , def_add_base_level , def_defence_level , def_amount_of_people , def_skill_level , def_deposits , def_extra_deposits , def_siberite_detection , def_starting_resources , def_shipments_density , def_support_units , def_loyality , def_info , def_morale_flags , def_siberite_bomb , def_builduptime , def_respawn , def_amount_of_apemen ; var commander ; var global_units , global_defined , soldiers_created ; var neng , nsci , nmech , nsol ; function read_multiplayer_and_game_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// if Multiplayer then
   4: NOP4
   8: IFFALSE 72
// begin Game_Type := mp_game_type ;
  10: NOP4
  14: PUSH
  15: NOP4
  19: ST_TO_ADDR
// Your_Side := mp_player_side ;
  20: LD_ADDR_OWVAR 2
  24: PUSH
  25: NOP4
  29: ST_TO_ADDR
// Side_Positions := mp_sides_positions ;
  30: NOP4
  34: PUSH
  35: NOP4
  39: ST_TO_ADDR
// Side_Teams := mp_sides_teams ;
  40: NOP4
  44: PUSH
  45: NOP4
  49: ST_TO_ADDR
// Side_Nations := mp_sides_nations ;
  50: NOP4
  54: PUSH
  55: NOP4
  59: ST_TO_ADDR
// Teams := mp_teams ;
  60: NOP4
  64: PUSH
  65: NOP4
  69: ST_TO_ADDR
// end else
  70: GO 254
// begin Game_Type := 1 ;
  72: NOP4
  76: PUSH
  77: LD_INT 1
  79: ST_TO_ADDR
// Your_Side := 3 ;
  80: LD_ADDR_OWVAR 2
  84: PUSH
  85: LD_INT 3
  87: ST_TO_ADDR
// Side_Positions := [ 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
  88: NOP4
  92: PUSH
  93: LD_INT 1
  95: PUSH
  96: LD_INT 2
  98: PUSH
  99: LD_INT 0
 101: PUSH
 102: LD_INT 0
 104: PUSH
 105: LD_INT 0
 107: PUSH
 108: LD_INT 0
 110: PUSH
 111: LD_INT 0
 113: PUSH
 114: LD_INT 0
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: LIST
 121: LIST
 122: LIST
 123: LIST
 124: LIST
 125: LIST
 126: ST_TO_ADDR
// Side_Teams := [ 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 127: NOP4
 131: PUSH
 132: LD_INT 1
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: LD_INT 0
 140: PUSH
 141: LD_INT 0
 143: PUSH
 144: LD_INT 0
 146: PUSH
 147: LD_INT 0
 149: PUSH
 150: LD_INT 0
 152: PUSH
 153: LD_INT 0
 155: PUSH
 156: EMPTY
 157: LIST
 158: LIST
 159: LIST
 160: LIST
 161: LIST
 162: LIST
 163: LIST
 164: LIST
 165: ST_TO_ADDR
// Side_Nations := [ 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 166: NOP4
 170: PUSH
 171: LD_INT 1
 173: PUSH
 174: LD_INT 2
 176: PUSH
 177: LD_INT 0
 179: PUSH
 180: LD_INT 0
 182: PUSH
 183: LD_INT 0
 185: PUSH
 186: LD_INT 0
 188: PUSH
 189: LD_INT 0
 191: PUSH
 192: LD_INT 0
 194: PUSH
 195: EMPTY
 196: LIST
 197: LIST
 198: LIST
 199: LIST
 200: LIST
 201: LIST
 202: LIST
 203: LIST
 204: ST_TO_ADDR
// Teams := [ [ 1 ] , [ 2 ] , [ 3 ] , [ 4 ] , [ 5 ] , [ 6 ] ] ;
 205: NOP4
 209: PUSH
 210: LD_INT 1
 212: PUSH
 213: EMPTY
 214: LIST
 215: PUSH
 216: LD_INT 2
 218: PUSH
 219: EMPTY
 220: LIST
 221: PUSH
 222: LD_INT 3
 224: PUSH
 225: EMPTY
 226: LIST
 227: PUSH
 228: LD_INT 4
 230: PUSH
 231: EMPTY
 232: LIST
 233: PUSH
 234: LD_INT 5
 236: PUSH
 237: EMPTY
 238: LIST
 239: PUSH
 240: LD_INT 6
 242: PUSH
 243: EMPTY
 244: LIST
 245: PUSH
 246: EMPTY
 247: LIST
 248: LIST
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// end ; for i := 1 to 8 do
 254: NOP4
 258: PUSH
 259: DOUBLE
 260: LD_INT 1
 262: DEC
 263: ST_TO_ADDR
 264: LD_INT 8
 266: PUSH
 267: FOR_TO
 268: IFFALSE 355
// if Multiplayer_GetPlayerIsSpec ( i ) then
 270: NOP4
 274: PPUSH
 275: NOP4
 279: IFFALSE 353
// begin Side_Positions := Replace ( Side_Positions , i , 0 ) ;
 281: NOP4
 285: PUSH
 286: NOP4
 290: PPUSH
 291: NOP4
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: NOP4
 303: ST_TO_ADDR
// Teams := Replace ( Teams , Side_Teams [ i ] , Teams [ Side_Teams [ i ] ] diff i ) ;
 304: NOP4
 308: PUSH
 309: NOP4
 313: PPUSH
 314: NOP4
 318: PUSH
 319: NOP4
 323: ARRAY
 324: PPUSH
 325: NOP4
 329: PUSH
 330: NOP4
 334: PUSH
 335: NOP4
 339: ARRAY
 340: ARRAY
 341: PUSH
 342: NOP4
 346: DIFF
 347: PPUSH
 348: NOP4
 352: ST_TO_ADDR
// end ;
 353: GO 267
 355: POP
 356: POP
// Position_Sides := [ 0 , 0 , 0 , 0 , 0 , 0 ] ;
 357: NOP4
 361: PUSH
 362: LD_INT 0
 364: PUSH
 365: LD_INT 0
 367: PUSH
 368: LD_INT 0
 370: PUSH
 371: LD_INT 0
 373: PUSH
 374: LD_INT 0
 376: PUSH
 377: LD_INT 0
 379: PUSH
 380: EMPTY
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: ST_TO_ADDR
// for i := 1 to 8 do
 388: NOP4
 392: PUSH
 393: DOUBLE
 394: LD_INT 1
 396: DEC
 397: ST_TO_ADDR
 398: LD_INT 8
 400: PUSH
 401: FOR_TO
 402: IFFALSE 449
// if Side_Positions [ i ] then
 404: NOP4
 408: PUSH
 409: NOP4
 413: ARRAY
 414: IFFALSE 447
// Position_Sides := Replace ( Position_Sides , Side_Positions [ i ] , i ) ;
 416: NOP4
 420: PUSH
 421: NOP4
 425: PPUSH
 426: NOP4
 430: PUSH
 431: NOP4
 435: ARRAY
 436: PPUSH
 437: NOP4
 441: PPUSH
 442: NOP4
 446: ST_TO_ADDR
 447: GO 401
 449: POP
 450: POP
// Team_Game := Side_Teams [ your_side ] ;
 451: NOP4
 455: PUSH
 456: NOP4
 460: PUSH
 461: NOP4
 465: ARRAY
 466: ST_TO_ADDR
// if Multiplayer then
 467: NOP4
 471: IFFALSE 709
// begin def_main_base_level := GetMultiplayerSetting ( 0 ) ;
 473: NOP4
 477: PUSH
 478: LD_INT 0
 480: PPUSH
 481: NOP4
 485: ST_TO_ADDR
// def_add_base_level := GetMultiplayerSetting ( 1 ) ;
 486: NOP4
 490: PUSH
 491: LD_INT 1
 493: PPUSH
 494: NOP4
 498: ST_TO_ADDR
// def_defence_level := GetMultiplayerSetting ( 2 ) ;
 499: NOP4
 503: PUSH
 504: LD_INT 2
 506: PPUSH
 507: NOP4
 511: ST_TO_ADDR
// def_amount_of_people := GetMultiplayerSetting ( 3 ) ;
 512: NOP4
 516: PUSH
 517: LD_INT 3
 519: PPUSH
 520: NOP4
 524: ST_TO_ADDR
// def_skill_level := GetMultiplayerSetting ( 4 ) ;
 525: NOP4
 529: PUSH
 530: LD_INT 4
 532: PPUSH
 533: NOP4
 537: ST_TO_ADDR
// def_deposits := GetMultiplayerSetting ( 5 ) ;
 538: NOP4
 542: PUSH
 543: LD_INT 5
 545: PPUSH
 546: NOP4
 550: ST_TO_ADDR
// def_extra_deposits := GetMultiplayerSetting ( 6 ) ;
 551: NOP4
 555: PUSH
 556: LD_INT 6
 558: PPUSH
 559: NOP4
 563: ST_TO_ADDR
// def_siberite_detection := GetMultiplayerSetting ( 7 ) ;
 564: NOP4
 568: PUSH
 569: LD_INT 7
 571: PPUSH
 572: NOP4
 576: ST_TO_ADDR
// def_starting_resources := GetMultiplayerSetting ( 8 ) ;
 577: NOP4
 581: PUSH
 582: LD_INT 8
 584: PPUSH
 585: NOP4
 589: ST_TO_ADDR
// def_shipments_density := GetMultiplayerSetting ( 9 ) ;
 590: NOP4
 594: PUSH
 595: LD_INT 9
 597: PPUSH
 598: NOP4
 602: ST_TO_ADDR
// def_support_units := GetMultiplayerSetting ( 10 ) ;
 603: NOP4
 607: PUSH
 608: LD_INT 10
 610: PPUSH
 611: NOP4
 615: ST_TO_ADDR
// def_loyality := GetMultiplayerSetting ( 11 ) ;
 616: NOP4
 620: PUSH
 621: LD_INT 11
 623: PPUSH
 624: NOP4
 628: ST_TO_ADDR
// def_info := GetMultiplayerSetting ( 12 ) ;
 629: NOP4
 633: PUSH
 634: LD_INT 12
 636: PPUSH
 637: NOP4
 641: ST_TO_ADDR
// def_respawn := GetMultiplayerSetting ( 13 ) ;
 642: NOP4
 646: PUSH
 647: LD_INT 13
 649: PPUSH
 650: NOP4
 654: ST_TO_ADDR
// def_amount_of_apemen := GetMultiplayerSetting ( 14 ) ;
 655: NOP4
 659: PUSH
 660: LD_INT 14
 662: PPUSH
 663: NOP4
 667: ST_TO_ADDR
// def_morale_flags := GetMultiplayerSetting ( 15 ) ;
 668: NOP4
 672: PUSH
 673: LD_INT 15
 675: PPUSH
 676: NOP4
 680: ST_TO_ADDR
// def_siberite_bomb := GetMultiplayerSetting ( 16 ) ;
 681: NOP4
 685: PUSH
 686: LD_INT 16
 688: PPUSH
 689: NOP4
 693: ST_TO_ADDR
// def_builduptime := GetMultiplayerSetting ( 20 ) ;
 694: NOP4
 698: PUSH
 699: LD_INT 20
 701: PPUSH
 702: NOP4
 706: ST_TO_ADDR
// end else
 707: GO 857
// begin Randomize ;
 709: NOP4
// def_main_base_level := 2 ;
 713: NOP4
 717: PUSH
 718: LD_INT 2
 720: ST_TO_ADDR
// def_add_base_level := 1 ;
 721: NOP4
 725: PUSH
 726: LD_INT 1
 728: ST_TO_ADDR
// def_defence_level := 1 ;
 729: NOP4
 733: PUSH
 734: LD_INT 1
 736: ST_TO_ADDR
// def_amount_of_people := 1 ;
 737: NOP4
 741: PUSH
 742: LD_INT 1
 744: ST_TO_ADDR
// def_skill_level := 1 ;
 745: NOP4
 749: PUSH
 750: LD_INT 1
 752: ST_TO_ADDR
// def_deposits := 1 ;
 753: NOP4
 757: PUSH
 758: LD_INT 1
 760: ST_TO_ADDR
// def_extra_deposits := 1 ;
 761: NOP4
 765: PUSH
 766: LD_INT 1
 768: ST_TO_ADDR
// def_siberite_detection := 1 ;
 769: NOP4
 773: PUSH
 774: LD_INT 1
 776: ST_TO_ADDR
// def_starting_resources := 1 ;
 777: NOP4
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// def_shipments_density := 1 ;
 785: NOP4
 789: PUSH
 790: LD_INT 1
 792: ST_TO_ADDR
// def_support_units := 1 ;
 793: NOP4
 797: PUSH
 798: LD_INT 1
 800: ST_TO_ADDR
// def_loyality := 1 ;
 801: NOP4
 805: PUSH
 806: LD_INT 1
 808: ST_TO_ADDR
// def_info := 1 ;
 809: NOP4
 813: PUSH
 814: LD_INT 1
 816: ST_TO_ADDR
// def_respawn := 0 ;
 817: NOP4
 821: PUSH
 822: LD_INT 0
 824: ST_TO_ADDR
// def_amount_of_apemen := 1 ;
 825: NOP4
 829: PUSH
 830: LD_INT 1
 832: ST_TO_ADDR
// def_morale_flags := 1 ;
 833: NOP4
 837: PUSH
 838: LD_INT 1
 840: ST_TO_ADDR
// def_siberite_bomb := 1 ;
 841: NOP4
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// def_builduptime := 1 ;
 849: NOP4
 853: PUSH
 854: LD_INT 1
 856: ST_TO_ADDR
// end ; is_depot := [ 0 , 1 , 1 , 1 , 1 ] [ def_main_base_level + 1 ] ;
 857: NOP4
 861: PUSH
 862: LD_INT 0
 864: PUSH
 865: LD_INT 1
 867: PUSH
 868: LD_INT 1
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 1
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: PUSH
 884: NOP4
 888: PUSH
 889: LD_INT 1
 891: PLUS
 892: ARRAY
 893: ST_TO_ADDR
// add_depot := [ 0 , 1 , 1 ] [ def_add_base_level + 1 ] ;
 894: NOP4
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 1
 904: PUSH
 905: LD_INT 1
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: NOP4
 917: PUSH
 918: LD_INT 1
 920: PLUS
 921: ARRAY
 922: ST_TO_ADDR
// number_of_breastworks := [ 0 , 3 , 7 ] [ def_defence_level + 1 ] ;
 923: NOP4
 927: PUSH
 928: LD_INT 0
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 7
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: NOP4
 946: PUSH
 947: LD_INT 1
 949: PLUS
 950: ARRAY
 951: ST_TO_ADDR
// number_of_people := [ 7 , 11 , 15 ] [ def_amount_of_people + 1 ] ;
 952: NOP4
 956: PUSH
 957: LD_INT 7
 959: PUSH
 960: LD_INT 11
 962: PUSH
 963: LD_INT 15
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: PUSH
 971: NOP4
 975: PUSH
 976: LD_INT 1
 978: PLUS
 979: ARRAY
 980: ST_TO_ADDR
// skill_level := [ 2 , 3 , 5 , 8 ] [ def_skill_level + 1 ] ;
 981: NOP4
 985: PUSH
 986: LD_INT 2
 988: PUSH
 989: LD_INT 3
 991: PUSH
 992: LD_INT 5
 994: PUSH
 995: LD_INT 8
 997: PUSH
 998: EMPTY
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: NOP4
1008: PUSH
1009: LD_INT 1
1011: PLUS
1012: ARRAY
1013: ST_TO_ADDR
// shipments_density := [ 150 , 125 , 100 , 50 ] [ def_shipments_density + 1 ] ;
1014: NOP4
1018: PUSH
1019: LD_INT 150
1021: PUSH
1022: LD_INT 125
1024: PUSH
1025: LD_INT 100
1027: PUSH
1028: LD_INT 50
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: NOP4
1041: PUSH
1042: LD_INT 1
1044: PLUS
1045: ARRAY
1046: ST_TO_ADDR
// respawning_time_min := [ 0 0$0 , 5 5$00 , 3 3$0 ] [ def_respawn + 1 ] ;
1047: NOP4
1051: PUSH
1052: LD_INT 0
1054: PUSH
1055: LD_INT 10500
1057: PUSH
1058: LD_INT 6300
1060: PUSH
1061: EMPTY
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: NOP4
1070: PUSH
1071: LD_INT 1
1073: PLUS
1074: ARRAY
1075: ST_TO_ADDR
// respawning_time_max := [ 0 0$0 , 15 15$00 , 5 5$0 ] [ def_respawn + 1 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 31500
1086: PUSH
1087: LD_INT 10500
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: PUSH
1095: NOP4
1099: PUSH
1100: LD_INT 1
1102: PLUS
1103: ARRAY
1104: ST_TO_ADDR
// amount_of_apemen := [ 0 , 3 , 6 , 9 ] [ def_amount_of_apemen + 1 ] ;
1105: NOP4
1109: PUSH
1110: LD_INT 0
1112: PUSH
1113: LD_INT 3
1115: PUSH
1116: LD_INT 6
1118: PUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: NOP4
1132: PUSH
1133: LD_INT 1
1135: PLUS
1136: ARRAY
1137: ST_TO_ADDR
// morale_decreasing_time := [ - 1 , 0 0$10 , 0 0$20 , 0 0$40 , 0 0$0 ] [ def_morale_flags + 1 ] ;
1138: NOP4
1142: PUSH
1143: LD_INT 1
1145: NEG
1146: PUSH
1147: LD_INT 350
1149: PUSH
1150: LD_INT 700
1152: PUSH
1153: LD_INT 1400
1155: PUSH
1156: LD_INT 0
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PUSH
1166: NOP4
1170: PUSH
1171: LD_INT 1
1173: PLUS
1174: ARRAY
1175: ST_TO_ADDR
// BuildUpAreas := [ BuildUp1 , BuildUp2 ] ;
1176: NOP4
1180: PUSH
1181: LD_INT 26
1183: PUSH
1184: LD_INT 27
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: ST_TO_ADDR
// end ;
1191: LD_VAR 0 1
1195: RET
// function init_map ; var i , j ; begin
1196: LD_INT 0
1198: PPUSH
1199: PPUSH
1200: PPUSH
// oil_deposits_locations := [ [ [ 74 , 116 ] , [ 57 , 109 ] ] , [ [ 172 , 31 ] , [ 133 , 16 ] ] ] ;
1201: NOP4
1205: PUSH
1206: LD_INT 74
1208: PUSH
1209: LD_INT 116
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 57
1218: PUSH
1219: LD_INT 109
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 172
1232: PUSH
1233: LD_INT 31
1235: PUSH
1236: EMPTY
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 133
1242: PUSH
1243: LD_INT 16
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: ST_TO_ADDR
// sib_deposits_locations := [ [ [ 27 , 39 ] , [ 132 , 96 ] ] , [ [ 148 , 9 ] , [ 94 , 12 ] ] ] ;
1258: NOP4
1262: PUSH
1263: LD_INT 27
1265: PUSH
1266: LD_INT 39
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PUSH
1273: LD_INT 132
1275: PUSH
1276: LD_INT 96
1278: PUSH
1279: EMPTY
1280: LIST
1281: LIST
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: PUSH
1287: LD_INT 148
1289: PUSH
1290: LD_INT 9
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: PUSH
1297: LD_INT 94
1299: PUSH
1300: LD_INT 12
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// depot_def := [ [ 59 , 97 , 0 ] , [ 156 , 19 , 3 ] ] ;
1315: NOP4
1319: PUSH
1320: LD_INT 59
1322: PUSH
1323: LD_INT 97
1325: PUSH
1326: LD_INT 0
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 156
1336: PUSH
1337: LD_INT 19
1339: PUSH
1340: LD_INT 3
1342: PUSH
1343: EMPTY
1344: LIST
1345: LIST
1346: LIST
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: ST_TO_ADDR
// for i in depot_def do
1352: NOP4
1356: PUSH
1357: NOP4
1361: PUSH
1362: FOR_IN
1363: IFFALSE 1437
// start_def := start_def ^ [ [ ShiftX ( i [ 1 ] , i [ 3 ] , 10 ) , ShiftY ( i [ 2 ] , i [ 3 ] , 10 ) ] ] ;
1365: NOP4
1369: PUSH
1370: NOP4
1374: PUSH
1375: NOP4
1379: PUSH
1380: LD_INT 1
1382: ARRAY
1383: PPUSH
1384: NOP4
1388: PUSH
1389: LD_INT 3
1391: ARRAY
1392: PPUSH
1393: LD_INT 10
1395: PPUSH
1396: NOP4
1400: PUSH
1401: NOP4
1405: PUSH
1406: LD_INT 2
1408: ARRAY
1409: PPUSH
1410: NOP4
1414: PUSH
1415: LD_INT 3
1417: ARRAY
1418: PPUSH
1419: LD_INT 10
1421: PPUSH
1422: NOP4
1426: PUSH
1427: EMPTY
1428: LIST
1429: LIST
1430: PUSH
1431: EMPTY
1432: LIST
1433: ADD
1434: ST_TO_ADDR
1435: GO 1362
1437: POP
1438: POP
// breastworks_def := [ [ [ 65 , 53 , 5 ] , [ 65 , 40 , 4 ] ] , [ [ 76 , 28 , 0 ] , [ 89 , 28 , 5 ] ] , [ [ 115 , 41 , 1 ] , [ 128 , 54 , 0 ] ] , [ [ 143 , 82 , 2 ] , [ 143 , 95 , 1 ] ] , [ [ 131 , 108 , 3 ] , [ 118 , 108 , 2 ] ] , [ [ 80 , 85 , 3 ] , [ 92 , 97 , 4 ] ] ] ;
1439: NOP4
1443: PUSH
1444: LD_INT 65
1446: PUSH
1447: LD_INT 53
1449: PUSH
1450: LD_INT 5
1452: PUSH
1453: EMPTY
1454: LIST
1455: LIST
1456: LIST
1457: PUSH
1458: LD_INT 65
1460: PUSH
1461: LD_INT 40
1463: PUSH
1464: LD_INT 4
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: PUSH
1472: EMPTY
1473: LIST
1474: LIST
1475: PUSH
1476: LD_INT 76
1478: PUSH
1479: LD_INT 28
1481: PUSH
1482: LD_INT 0
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: PUSH
1490: LD_INT 89
1492: PUSH
1493: LD_INT 28
1495: PUSH
1496: LD_INT 5
1498: PUSH
1499: EMPTY
1500: LIST
1501: LIST
1502: LIST
1503: PUSH
1504: EMPTY
1505: LIST
1506: LIST
1507: PUSH
1508: LD_INT 115
1510: PUSH
1511: LD_INT 41
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: PUSH
1522: LD_INT 128
1524: PUSH
1525: LD_INT 54
1527: PUSH
1528: LD_INT 0
1530: PUSH
1531: EMPTY
1532: LIST
1533: LIST
1534: LIST
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 143
1542: PUSH
1543: LD_INT 82
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: PUSH
1554: LD_INT 143
1556: PUSH
1557: LD_INT 95
1559: PUSH
1560: LD_INT 1
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 131
1574: PUSH
1575: LD_INT 108
1577: PUSH
1578: LD_INT 3
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 118
1588: PUSH
1589: LD_INT 108
1591: PUSH
1592: LD_INT 2
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: LIST
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: LD_INT 80
1606: PUSH
1607: LD_INT 85
1609: PUSH
1610: LD_INT 3
1612: PUSH
1613: EMPTY
1614: LIST
1615: LIST
1616: LIST
1617: PUSH
1618: LD_INT 92
1620: PUSH
1621: LD_INT 97
1623: PUSH
1624: LD_INT 4
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: ST_TO_ADDR
// for i in ( Side_Positions diff [ 0 ] ) do
1644: NOP4
1648: PUSH
1649: NOP4
1653: PUSH
1654: LD_INT 0
1656: PUSH
1657: EMPTY
1658: LIST
1659: DIFF
1660: PUSH
1661: FOR_IN
1662: IFFALSE 1759
// if def_deposits then
1664: NOP4
1668: IFFALSE 1720
// for j in extra_oil_deposits_locations [ i ] do
1670: NOP4
1674: PUSH
1675: NOP4
1679: PUSH
1680: NOP4
1684: ARRAY
1685: PUSH
1686: FOR_IN
1687: IFFALSE 1716
// CreateDepositXY ( j [ 1 ] , j [ 2 ] , mat_oil ) else
1689: NOP4
1693: PUSH
1694: LD_INT 1
1696: ARRAY
1697: PPUSH
1698: NOP4
1702: PUSH
1703: LD_INT 2
1705: ARRAY
1706: PPUSH
1707: LD_INT 2
1709: PPUSH
1710: NOP4
1714: GO 1686
1716: POP
1717: POP
1718: GO 1757
// CreateDepositXY ( normal_oil_deposits_locations [ i ] [ 1 ] , normal_oil_deposits_locations [ i ] [ 2 ] , mat_oil ) ;
1720: NOP4
1724: PUSH
1725: NOP4
1729: ARRAY
1730: PUSH
1731: LD_INT 1
1733: ARRAY
1734: PPUSH
1735: NOP4
1739: PUSH
1740: NOP4
1744: ARRAY
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: NOP4
1757: GO 1661
1759: POP
1760: POP
// if def_extra_sib_deposits then
1761: NOP4
1765: IFFALSE 1888
// for i in ( Side_Positions diff [ 0 ] ) do
1767: NOP4
1771: PUSH
1772: NOP4
1776: PUSH
1777: LD_INT 0
1779: PUSH
1780: EMPTY
1781: LIST
1782: DIFF
1783: PUSH
1784: FOR_IN
1785: IFFALSE 1886
// if def_extra_sib_deposits = 2 then
1787: NOP4
1791: PUSH
1792: LD_INT 2
1794: EQUAL
1795: IFFALSE 1847
// for j in extra_sib_deposits_locations [ i ] do
1797: NOP4
1801: PUSH
1802: NOP4
1806: PUSH
1807: NOP4
1811: ARRAY
1812: PUSH
1813: FOR_IN
1814: IFFALSE 1843
// CreateDepositXY ( j [ 1 ] , j [ 2 ] , mat_siberit ) else
1816: NOP4
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: NOP4
1829: PUSH
1830: LD_INT 2
1832: ARRAY
1833: PPUSH
1834: LD_INT 3
1836: PPUSH
1837: NOP4
1841: GO 1813
1843: POP
1844: POP
1845: GO 1884
// CreateDepositXY ( normal_sib_deposits_locations [ i ] [ 1 ] , normal_sib_deposits_locations [ i ] [ 2 ] , mat_siberit ) ;
1847: NOP4
1851: PUSH
1852: NOP4
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: NOP4
1866: PUSH
1867: NOP4
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: LD_INT 3
1879: PPUSH
1880: NOP4
1884: GO 1784
1886: POP
1887: POP
// end ;
1888: LD_VAR 0 1
1892: RET
// function set_shared_visions_and_alliances ; var i , j ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
1897: PPUSH
// if not Team_Game then
1898: NOP4
1902: NOT
1903: IFFALSE 2001
// begin for i = 1 to 8 do
1905: NOP4
1909: PUSH
1910: DOUBLE
1911: LD_INT 1
1913: DEC
1914: ST_TO_ADDR
1915: LD_INT 8
1917: PUSH
1918: FOR_TO
1919: IFFALSE 1997
// for j = 1 to 8 do
1921: NOP4
1925: PUSH
1926: DOUBLE
1927: LD_INT 1
1929: DEC
1930: ST_TO_ADDR
1931: LD_INT 8
1933: PUSH
1934: FOR_TO
1935: IFFALSE 1993
// if i <> j then
1937: NOP4
1941: PUSH
1942: NOP4
1946: NONEQUAL
1947: IFFALSE 1971
// SetAttitude ( i , j , att_neutral , true ) else
1949: NOP4
1953: PPUSH
1954: NOP4
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: LD_INT 1
1964: PPUSH
1965: NOP4
1969: GO 1991
// SetAttitude ( i , j , att_friend , true ) ;
1971: NOP4
1975: PPUSH
1976: NOP4
1980: PPUSH
1981: LD_INT 1
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: NOP4
1991: GO 1934
1993: POP
1994: POP
1995: GO 1918
1997: POP
1998: POP
// end else
1999: GO 2176
// begin if def_shared_vision then
2001: NOP4
2005: IFFALSE 2070
// begin for i in Teams do
2007: NOP4
2011: PUSH
2012: NOP4
2016: PUSH
2017: FOR_IN
2018: IFFALSE 2068
// for j = 2 to i do
2020: NOP4
2024: PUSH
2025: DOUBLE
2026: LD_INT 2
2028: DEC
2029: ST_TO_ADDR
2030: NOP4
2034: PUSH
2035: FOR_TO
2036: IFFALSE 2064
// ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
2038: NOP4
2042: PUSH
2043: NOP4
2047: ARRAY
2048: PPUSH
2049: NOP4
2053: PUSH
2054: LD_INT 1
2056: ARRAY
2057: PPUSH
2058: NOP4
2062: GO 2035
2064: POP
2065: POP
2066: GO 2017
2068: POP
2069: POP
// end ; for i = 1 to 8 do
2070: NOP4
2074: PUSH
2075: DOUBLE
2076: LD_INT 1
2078: DEC
2079: ST_TO_ADDR
2080: LD_INT 8
2082: PUSH
2083: FOR_TO
2084: IFFALSE 2174
// for j = 1 to 8 do
2086: NOP4
2090: PUSH
2091: DOUBLE
2092: LD_INT 1
2094: DEC
2095: ST_TO_ADDR
2096: LD_INT 8
2098: PUSH
2099: FOR_TO
2100: IFFALSE 2170
// if Side_Teams [ i ] = Side_Teams [ j ] then
2102: NOP4
2106: PUSH
2107: NOP4
2111: ARRAY
2112: PUSH
2113: NOP4
2117: PUSH
2118: NOP4
2122: ARRAY
2123: EQUAL
2124: IFFALSE 2148
// SetAttitude ( i , j , att_friend , true ) else
2126: NOP4
2130: PPUSH
2131: NOP4
2135: PPUSH
2136: LD_INT 1
2138: PPUSH
2139: LD_INT 1
2141: PPUSH
2142: NOP4
2146: GO 2168
// SetAttitude ( i , j , att_enemy , true ) ;
2148: NOP4
2152: PPUSH
2153: NOP4
2157: PPUSH
2158: LD_INT 2
2160: PPUSH
2161: LD_INT 1
2163: PPUSH
2164: NOP4
2168: GO 2099
2170: POP
2171: POP
2172: GO 2083
2174: POP
2175: POP
// end ; end ;
2176: LD_VAR 0 1
2180: RET
// function prepare_people ( count , cl , x , y , r , building ) ; var i , j , un ; begin
2181: LD_INT 0
2183: PPUSH
2184: PPUSH
2185: PPUSH
2186: PPUSH
// result := [ ] ;
2187: NOP4
2191: PUSH
2192: EMPTY
2193: ST_TO_ADDR
// for i := 1 to count do
2194: NOP4
2198: PUSH
2199: DOUBLE
2200: LD_INT 1
2202: DEC
2203: ST_TO_ADDR
2204: NOP4
2208: PUSH
2209: FOR_TO
2210: IFFALSE 2628
// begin uc_direction := Rand ( 0 , 5 ) ;
2212: LD_ADDR_OWVAR 24
2216: PUSH
2217: LD_INT 0
2219: PPUSH
2220: LD_INT 5
2222: PPUSH
2223: NOP4
2227: ST_TO_ADDR
// if commander then
2228: NOP4
2232: IFFALSE 2341
// begin hc_name := mp_sides_players_names [ uc_side ] ;
2234: LD_ADDR_OWVAR 26
2238: PUSH
2239: NOP4
2243: PUSH
2244: NOP4
2248: ARRAY
2249: ST_TO_ADDR
// PrepareHuman ( Rand ( 1 , 2 ) , cl , skill_level + 2 ) ;
2250: LD_INT 1
2252: PPUSH
2253: LD_INT 2
2255: PPUSH
2256: NOP4
2260: PPUSH
2261: NOP4
2265: PPUSH
2266: NOP4
2270: PUSH
2271: LD_INT 2
2273: PLUS
2274: PPUSH
2275: NOP4
// hc_importance := 105 ;
2279: LD_ADDR_OWVAR 32
2283: PUSH
2284: LD_INT 105
2286: ST_TO_ADDR
// commander := false ;
2287: NOP4
2291: PUSH
2292: LD_INT 0
2294: ST_TO_ADDR
// if Multiplayer then
2295: NOP4
2299: IFFALSE 2339
// begin hc_gallery := MULTIAVATARS ;
2301: LD_ADDR_OWVAR 33
2305: PUSH
2306: LD_STRING MULTIAVATARS
2308: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( uc_side ) ;
2309: LD_ADDR_OWVAR 34
2313: PUSH
2314: NOP4
2318: PPUSH
2319: NOP4
2323: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( uc_side ) ;
2324: LD_ADDR_OWVAR 27
2328: PUSH
2329: NOP4
2333: PPUSH
2334: NOP4
2338: ST_TO_ADDR
// end ; end else
2339: GO 2404
// begin hc_name :=  ;
2341: LD_ADDR_OWVAR 26
2345: PUSH
2346: LD_STRING 
2348: ST_TO_ADDR
// PrepareHuman ( rand ( 1 , 2 ) , cl , skill_level ) ;
2349: LD_INT 1
2351: PPUSH
2352: LD_INT 2
2354: PPUSH
2355: NOP4
2359: PPUSH
2360: NOP4
2364: PPUSH
2365: NOP4
2369: PPUSH
2370: NOP4
// hc_importance := 0 ;
2374: LD_ADDR_OWVAR 32
2378: PUSH
2379: LD_INT 0
2381: ST_TO_ADDR
// if Multiplayer then
2382: NOP4
2386: IFFALSE 2404
// begin hc_gallery :=  ;
2388: LD_ADDR_OWVAR 33
2392: PUSH
2393: LD_STRING 
2395: ST_TO_ADDR
// hc_face_number := 0 ;
2396: LD_ADDR_OWVAR 34
2400: PUSH
2401: LD_INT 0
2403: ST_TO_ADDR
// end ; end ; un := CreateHuman ;
2404: NOP4
2408: PUSH
2409: NOP4
2413: ST_TO_ADDR
// if global_defined then
2414: NOP4
2418: IFFALSE 2558
// begin if ( cl = class_soldier ) then
2420: NOP4
2424: PUSH
2425: LD_INT 1
2427: EQUAL
2428: IFFALSE 2448
// j := i + soldiers_created else
2430: NOP4
2434: PUSH
2435: NOP4
2439: PUSH
2440: NOP4
2444: PLUS
2445: ST_TO_ADDR
2446: GO 2458
// j := i ;
2448: NOP4
2452: PUSH
2453: NOP4
2457: ST_TO_ADDR
// CopySkills ( global_units [ cl ] [ j ] , un ) ;
2458: NOP4
2462: PUSH
2463: NOP4
2467: ARRAY
2468: PUSH
2469: NOP4
2473: ARRAY
2474: PPUSH
2475: NOP4
2479: PPUSH
2480: NOP4
// SetAttr ( un , attr_speed , GetAttr ( global_units [ cl ] [ j ] , attr_speed ) ) ;
2484: NOP4
2488: PPUSH
2489: LD_INT 2
2491: PPUSH
2492: NOP4
2496: PUSH
2497: NOP4
2501: ARRAY
2502: PUSH
2503: NOP4
2507: ARRAY
2508: PPUSH
2509: LD_INT 2
2511: PPUSH
2512: NOP4
2516: PPUSH
2517: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( global_units [ cl ] [ j ] , attr_stamina ) ) ;
2521: NOP4
2525: PPUSH
2526: LD_INT 1
2528: PPUSH
2529: NOP4
2533: PUSH
2534: NOP4
2538: ARRAY
2539: PUSH
2540: NOP4
2544: ARRAY
2545: PPUSH
2546: LD_INT 1
2548: PPUSH
2549: NOP4
2553: PPUSH
2554: NOP4
// end ; if building then
2558: NOP4
2562: IFFALSE 2580
// PlaceHumanInUnit ( un , building ) else
2564: NOP4
2568: PPUSH
2569: NOP4
2573: PPUSH
2574: NOP4
2578: GO 2607
// PlaceUnitXYR ( un , x , y , r , false ) ;
2580: NOP4
2584: PPUSH
2585: NOP4
2589: PPUSH
2590: NOP4
2594: PPUSH
2595: NOP4
2599: PPUSH
2600: LD_INT 0
2602: PPUSH
2603: NOP4
// result := result ^ [ un ] ;
2607: NOP4
2611: PUSH
2612: NOP4
2616: PUSH
2617: NOP4
2621: PUSH
2622: EMPTY
2623: LIST
2624: ADD
2625: ST_TO_ADDR
// end ;
2626: GO 2209
2628: POP
2629: POP
// if not global_defined then
2630: NOP4
2634: NOT
2635: IFFALSE 2713
// if ( global_units >= cl ) then
2637: NOP4
2641: PUSH
2642: NOP4
2646: GREATEREQUAL
2647: IFFALSE 2688
// global_units := Replace ( global_units , cl , global_units [ cl ] ^ result ) else
2649: NOP4
2653: PUSH
2654: NOP4
2658: PPUSH
2659: NOP4
2663: PPUSH
2664: NOP4
2668: PUSH
2669: NOP4
2673: ARRAY
2674: PUSH
2675: NOP4
2679: ADD
2680: PPUSH
2681: NOP4
2685: ST_TO_ADDR
2686: GO 2713
// global_units := Replace ( global_units , cl , result ) ;
2688: NOP4
2692: PUSH
2693: NOP4
2697: PPUSH
2698: NOP4
2702: PPUSH
2703: NOP4
2707: PPUSH
2708: NOP4
2712: ST_TO_ADDR
// end ;
2713: LD_VAR 0 7
2717: RET
// function prepare_side ( side ) ; var pos , x , y , dir , i , r , br , dep ; begin
2718: LD_INT 0
2720: PPUSH
2721: PPUSH
2722: PPUSH
2723: PPUSH
2724: PPUSH
2725: PPUSH
2726: PPUSH
2727: PPUSH
2728: PPUSH
// pos := Side_Positions [ side ] ;
2729: NOP4
2733: PUSH
2734: NOP4
2738: PUSH
2739: NOP4
2743: ARRAY
2744: ST_TO_ADDR
// uc_nation := Side_Nations [ side ] ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: NOP4
2754: PUSH
2755: NOP4
2759: ARRAY
2760: ST_TO_ADDR
// uc_side := side ;
2761: LD_ADDR_OWVAR 20
2765: PUSH
2766: NOP4
2770: ST_TO_ADDR
// x := depot_def [ pos ] [ 1 ] ;
2771: NOP4
2775: PUSH
2776: NOP4
2780: PUSH
2781: NOP4
2785: ARRAY
2786: PUSH
2787: LD_INT 1
2789: ARRAY
2790: ST_TO_ADDR
// y := depot_def [ pos ] [ 2 ] ;
2791: NOP4
2795: PUSH
2796: NOP4
2800: PUSH
2801: NOP4
2805: ARRAY
2806: PUSH
2807: LD_INT 2
2809: ARRAY
2810: ST_TO_ADDR
// dir := depot_def [ pos ] [ 3 ] ;
2811: NOP4
2815: PUSH
2816: NOP4
2820: PUSH
2821: NOP4
2825: ARRAY
2826: PUSH
2827: LD_INT 3
2829: ARRAY
2830: ST_TO_ADDR
// if is_depot then
2831: NOP4
2835: IFFALSE 2968
// begin bc_type = b_depot ;
2837: LD_ADDR_OWVAR 42
2841: PUSH
2842: LD_INT 0
2844: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
2845: NOP4
2849: PUSH
2850: NOP4
2854: PPUSH
2855: NOP4
2859: PPUSH
2860: NOP4
2864: PPUSH
2865: NOP4
2869: ST_TO_ADDR
// SetBName ( dep , @ & side ) ;
2870: NOP4
2874: PPUSH
2875: LD_STRING @
2877: PUSH
2878: NOP4
2882: STR
2883: PPUSH
2884: NOP4
// SetResourceType ( GetBase ( dep ) , mat_cans , starting_resources [ mat_cans ] ) ;
2888: NOP4
2892: PPUSH
2893: NOP4
2897: PPUSH
2898: LD_INT 1
2900: PPUSH
2901: NOP4
2905: PUSH
2906: LD_INT 1
2908: ARRAY
2909: PPUSH
2910: NOP4
// SetResourceType ( GetBase ( dep ) , mat_oil , starting_resources [ mat_oil ] ) ;
2914: NOP4
2918: PPUSH
2919: NOP4
2923: PPUSH
2924: LD_INT 2
2926: PPUSH
2927: NOP4
2931: PUSH
2932: LD_INT 2
2934: ARRAY
2935: PPUSH
2936: NOP4
// SetResourceType ( GetBase ( dep ) , mat_siberit , starting_resources [ mat_siberit ] ) ;
2940: NOP4
2944: PPUSH
2945: NOP4
2949: PPUSH
2950: LD_INT 3
2952: PPUSH
2953: NOP4
2957: PUSH
2958: LD_INT 3
2960: ARRAY
2961: PPUSH
2962: NOP4
// end else
2966: GO 3112
// begin for i := 1 to 3 do
2968: NOP4
2972: PUSH
2973: DOUBLE
2974: LD_INT 1
2976: DEC
2977: ST_TO_ADDR
2978: LD_INT 3
2980: PUSH
2981: FOR_TO
2982: IFFALSE 3110
// begin r := starting_resources [ i ] ;
2984: NOP4
2988: PUSH
2989: NOP4
2993: PUSH
2994: NOP4
2998: ARRAY
2999: ST_TO_ADDR
// while r >= 10 do
3000: NOP4
3004: PUSH
3005: LD_INT 10
3007: GREATEREQUAL
3008: IFFALSE 3108
// if r > 50 then
3010: NOP4
3014: PUSH
3015: LD_INT 50
3017: GREATER
3018: IFFALSE 3064
// begin CreateResourcesXYR ( i , 5 , x , y , 4 , false ) ;
3020: NOP4
3024: PPUSH
3025: LD_INT 5
3027: PPUSH
3028: NOP4
3032: PPUSH
3033: NOP4
3037: PPUSH
3038: LD_INT 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: NOP4
// r := r - 50 ;
3048: NOP4
3052: PUSH
3053: NOP4
3057: PUSH
3058: LD_INT 50
3060: MINUS
3061: ST_TO_ADDR
// end else
3062: GO 3106
// begin CreateResourcesXYR ( i , r div 10 , x , y , 4 , false ) ;
3064: NOP4
3068: PPUSH
3069: NOP4
3073: PUSH
3074: LD_INT 10
3076: DIV
3077: PPUSH
3078: NOP4
3082: PPUSH
3083: NOP4
3087: PPUSH
3088: LD_INT 4
3090: PPUSH
3091: LD_INT 0
3093: PPUSH
3094: NOP4
// r := 0 ;
3098: NOP4
3102: PUSH
3103: LD_INT 0
3105: ST_TO_ADDR
// end ;
3106: GO 3000
// end ;
3108: GO 2981
3110: POP
3111: POP
// end ; for r in starting_crates do
3112: NOP4
3116: PUSH
3117: NOP4
3121: PUSH
3122: FOR_IN
3123: IFFALSE 3155
// CreateResourcesXYR ( mat_cans , 5 , x , y , r , false ) ;
3125: LD_INT 1
3127: PPUSH
3128: LD_INT 5
3130: PPUSH
3131: NOP4
3135: PPUSH
3136: NOP4
3140: PPUSH
3141: NOP4
3145: PPUSH
3146: LD_INT 0
3148: PPUSH
3149: NOP4
3153: GO 3122
3155: POP
3156: POP
// if def_morale_flags then
3157: NOP4
3161: IFFALSE 3300
// begin x := start_def [ pos ] [ 1 ] ;
3163: NOP4
3167: PUSH
3168: NOP4
3172: PUSH
3173: NOP4
3177: ARRAY
3178: PUSH
3179: LD_INT 1
3181: ARRAY
3182: ST_TO_ADDR
// y := start_def [ pos ] [ 2 ] ;
3183: NOP4
3187: PUSH
3188: NOP4
3192: PUSH
3193: NOP4
3197: ARRAY
3198: PUSH
3199: LD_INT 2
3201: ARRAY
3202: ST_TO_ADDR
// PlaceEnvironment ( x , y , 12 , 2 ) ;
3203: NOP4
3207: PPUSH
3208: NOP4
3212: PPUSH
3213: LD_INT 12
3215: PPUSH
3216: LD_INT 2
3218: PPUSH
3219: NOP4
// battle_flags_id := battle_flags_id ^ SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , 100 ] , [ bfo_defend_bonus_vehicle , 50 ] , [ bfo_defend_bonus_building , 20 ] , [ bfo_height , 100 ] ] ) ;
3223: NOP4
3227: PUSH
3228: NOP4
3232: PUSH
3233: NOP4
3237: PPUSH
3238: NOP4
3242: PPUSH
3243: NOP4
3247: PPUSH
3248: LD_INT 1
3250: PUSH
3251: LD_INT 100
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 2
3260: PUSH
3261: LD_INT 50
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: LD_INT 3
3270: PUSH
3271: LD_INT 20
3273: PUSH
3274: EMPTY
3275: LIST
3276: LIST
3277: PUSH
3278: LD_INT 20
3280: PUSH
3281: LD_INT 100
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: PPUSH
3294: NOP4
3298: ADD
3299: ST_TO_ADDR
// end ; commander := true ;
3300: NOP4
3304: PUSH
3305: LD_INT 1
3307: ST_TO_ADDR
// soldiers_created := 0 ;
3308: NOP4
3312: PUSH
3313: LD_INT 0
3315: ST_TO_ADDR
// for i := 1 to number_of_breastworks do
3316: NOP4
3320: PUSH
3321: DOUBLE
3322: LD_INT 1
3324: DEC
3325: ST_TO_ADDR
3326: NOP4
3330: PUSH
3331: FOR_TO
3332: IFFALSE 3485
// begin x := breastworks_def [ pos ] [ i ] [ 1 ] ;
3334: NOP4
3338: PUSH
3339: NOP4
3343: PUSH
3344: NOP4
3348: ARRAY
3349: PUSH
3350: NOP4
3354: ARRAY
3355: PUSH
3356: LD_INT 1
3358: ARRAY
3359: ST_TO_ADDR
// y := breastworks_def [ pos ] [ i ] [ 2 ] ;
3360: NOP4
3364: PUSH
3365: NOP4
3369: PUSH
3370: NOP4
3374: ARRAY
3375: PUSH
3376: NOP4
3380: ARRAY
3381: PUSH
3382: LD_INT 2
3384: ARRAY
3385: ST_TO_ADDR
// dir := breastworks_def [ pos ] [ i ] [ 3 ] ;
3386: NOP4
3390: PUSH
3391: NOP4
3395: PUSH
3396: NOP4
3400: ARRAY
3401: PUSH
3402: NOP4
3406: ARRAY
3407: PUSH
3408: LD_INT 3
3410: ARRAY
3411: ST_TO_ADDR
// bc_type := b_breastwork ;
3412: LD_ADDR_OWVAR 42
3416: PUSH
3417: LD_INT 31
3419: ST_TO_ADDR
// br := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
3420: NOP4
3424: PUSH
3425: NOP4
3429: PPUSH
3430: NOP4
3434: PPUSH
3435: NOP4
3439: PPUSH
3440: NOP4
3444: ST_TO_ADDR
// prepare_people ( 1 , class_soldier , 0 , 0 , 0 , br ) ;
3445: LD_INT 1
3447: PPUSH
3448: LD_INT 1
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: LD_INT 0
3456: PPUSH
3457: LD_INT 0
3459: PPUSH
3460: NOP4
3464: PPUSH
3465: NOP4
// soldiers_created := soldiers_created + 1 ;
3469: NOP4
3473: PUSH
3474: NOP4
3478: PUSH
3479: LD_INT 1
3481: PLUS
3482: ST_TO_ADDR
// end ;
3483: GO 3331
3485: POP
3486: POP
// x := start_def [ pos ] [ 1 ] ;
3487: NOP4
3491: PUSH
3492: NOP4
3496: PUSH
3497: NOP4
3501: ARRAY
3502: PUSH
3503: LD_INT 1
3505: ARRAY
3506: ST_TO_ADDR
// y := start_def [ pos ] [ 2 ] ;
3507: NOP4
3511: PUSH
3512: NOP4
3516: PUSH
3517: NOP4
3521: ARRAY
3522: PUSH
3523: LD_INT 2
3525: ARRAY
3526: ST_TO_ADDR
// prepare_people ( nsol - number_of_breastworks , class_soldier , x , y , 5 , 0 ) ;
3527: NOP4
3531: PUSH
3532: NOP4
3536: MINUS
3537: PPUSH
3538: LD_INT 1
3540: PPUSH
3541: NOP4
3545: PPUSH
3546: NOP4
3550: PPUSH
3551: LD_INT 5
3553: PPUSH
3554: LD_INT 0
3556: PPUSH
3557: NOP4
// prepare_people ( neng , class_engineer , x , y , 5 , 0 ) ;
3561: NOP4
3565: PPUSH
3566: LD_INT 2
3568: PPUSH
3569: NOP4
3573: PPUSH
3574: NOP4
3578: PPUSH
3579: LD_INT 5
3581: PPUSH
3582: LD_INT 0
3584: PPUSH
3585: NOP4
// prepare_people ( nmech , class_mechanic , x , y , 5 , 0 ) ;
3589: NOP4
3593: PPUSH
3594: LD_INT 3
3596: PPUSH
3597: NOP4
3601: PPUSH
3602: NOP4
3606: PPUSH
3607: LD_INT 5
3609: PPUSH
3610: LD_INT 0
3612: PPUSH
3613: NOP4
// prepare_people ( nsci , class_scientistic , x , y , 5 , 0 ) ;
3617: NOP4
3621: PPUSH
3622: LD_INT 4
3624: PPUSH
3625: NOP4
3629: PPUSH
3630: NOP4
3634: PPUSH
3635: LD_INT 5
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: NOP4
// if def_siberite_detection then
3645: NOP4
3649: IFFALSE 3666
// SetTech ( tech_SibDet , side , state_researched ) ;
3651: LD_INT 20
3653: PPUSH
3654: NOP4
3658: PPUSH
3659: LD_INT 2
3661: PPUSH
3662: NOP4
// if def_siberite_bomb <> 1 then
3666: NOP4
3670: PUSH
3671: LD_INT 1
3673: NONEQUAL
3674: IFFALSE 3691
// SetTech ( tech_SibFiss , side , state_disabled ) ;
3676: LD_INT 25
3678: PPUSH
3679: NOP4
3683: PPUSH
3684: LD_INT 0
3686: PPUSH
3687: NOP4
// global_defined := true ;
3691: NOP4
3695: PUSH
3696: LD_INT 1
3698: ST_TO_ADDR
// end ;
3699: LD_VAR 0 2
3703: RET
// function EnableSibFiss ; var i ; begin
3704: LD_INT 0
3706: PPUSH
3707: PPUSH
// for i := 1 to 8 do
3708: NOP4
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 8
3720: PUSH
3721: FOR_TO
3722: IFFALSE 3753
// if Side_Positions [ i ] then
3724: NOP4
3728: PUSH
3729: NOP4
3733: ARRAY
3734: IFFALSE 3751
// SetTech ( tech_SibFiss , i , state_enabled ) ;
3736: LD_INT 25
3738: PPUSH
3739: NOP4
3743: PPUSH
3744: LD_INT 1
3746: PPUSH
3747: NOP4
3751: GO 3721
3753: POP
3754: POP
// end ;
3755: LD_VAR 0 1
3759: RET
// every 30 30$0 do
3760: GO 3762
3762: DISABLE
// if ( def_siberite_bomb = 2 ) then
3763: NOP4
3767: PUSH
3768: LD_INT 2
3770: EQUAL
3771: IFFALSE 3777
// EnableSibFiss ;
3773: NOP4
3777: END
// every 60 60$0 do
3778: GO 3780
3780: DISABLE
// if ( def_siberite_bomb = 3 ) then
3781: NOP4
3785: PUSH
3786: LD_INT 3
3788: EQUAL
3789: IFFALSE 3795
// EnableSibFiss ;
3791: NOP4
3795: END
// every 90 90$0 do
3796: GO 3798
3798: DISABLE
// if ( def_siberite_bomb = 4 ) then
3799: NOP4
3803: PUSH
3804: LD_INT 4
3806: EQUAL
3807: IFFALSE 3813
// EnableSibFiss ;
3809: NOP4
3813: END
// every 120 120$0 do
3814: GO 3816
3816: DISABLE
// if ( def_siberite_bomb = 5 ) then
3817: NOP4
3821: PUSH
3822: LD_INT 5
3824: EQUAL
3825: IFFALSE 3831
// EnableSibFiss ;
3827: NOP4
3831: END
// function prepare_sides ; var i ; begin
3832: LD_INT 0
3834: PPUSH
3835: PPUSH
// global_units := [ ] ;
3836: NOP4
3840: PUSH
3841: EMPTY
3842: ST_TO_ADDR
// global_defined := false ;
3843: NOP4
3847: PUSH
3848: LD_INT 0
3850: ST_TO_ADDR
// CountClassMembers ;
3851: NOP4
// for i := 1 to 8 do
3855: NOP4
3859: PUSH
3860: DOUBLE
3861: LD_INT 1
3863: DEC
3864: ST_TO_ADDR
3865: LD_INT 8
3867: PUSH
3868: FOR_TO
3869: IFFALSE 3894
// if Side_Positions [ i ] then
3871: NOP4
3875: PUSH
3876: NOP4
3880: ARRAY
3881: IFFALSE 3892
// prepare_side ( i ) ;
3883: NOP4
3887: PPUSH
3888: NOP4
3892: GO 3868
3894: POP
3895: POP
// end ;
3896: LD_VAR 0 1
3900: RET
// function CountClassMembers ; var Mode ; begin
3901: LD_INT 0
3903: PPUSH
3904: PPUSH
// if No_Mechs then
3905: NOP4
3909: IFFALSE 3921
// Mode := 2 else
3911: NOP4
3915: PUSH
3916: LD_INT 2
3918: ST_TO_ADDR
3919: GO 3929
// Mode := 1 ;
3921: NOP4
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// neng := number_of_people ;
3929: NOP4
3933: PUSH
3934: NOP4
3938: ST_TO_ADDR
// nsol := neng div [ 4 , 3 ] [ Mode ] ;
3939: NOP4
3943: PUSH
3944: NOP4
3948: PUSH
3949: LD_INT 4
3951: PUSH
3952: LD_INT 3
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PUSH
3959: NOP4
3963: ARRAY
3964: DIV
3965: ST_TO_ADDR
// if ( nsol < number_of_breastworks ) then
3966: NOP4
3970: PUSH
3971: NOP4
3975: LESS
3976: IFFALSE 3988
// nsol := number_of_breastworks ;
3978: NOP4
3982: PUSH
3983: NOP4
3987: ST_TO_ADDR
// neng := neng - nsol ;
3988: NOP4
3992: PUSH
3993: NOP4
3997: PUSH
3998: NOP4
4002: MINUS
4003: ST_TO_ADDR
// nsci := neng div [ 3 , 2 ] [ Mode ] ;
4004: NOP4
4008: PUSH
4009: NOP4
4013: PUSH
4014: LD_INT 3
4016: PUSH
4017: LD_INT 2
4019: PUSH
4020: EMPTY
4021: LIST
4022: LIST
4023: PUSH
4024: NOP4
4028: ARRAY
4029: DIV
4030: ST_TO_ADDR
// if ( nsci < 1 ) then
4031: NOP4
4035: PUSH
4036: LD_INT 1
4038: LESS
4039: IFFALSE 4049
// nsci := 1 ;
4041: NOP4
4045: PUSH
4046: LD_INT 1
4048: ST_TO_ADDR
// neng := neng - nsci ;
4049: NOP4
4053: PUSH
4054: NOP4
4058: PUSH
4059: NOP4
4063: MINUS
4064: ST_TO_ADDR
// nmech := [ neng div 2 , 0 ] [ Mode ] ;
4065: NOP4
4069: PUSH
4070: NOP4
4074: PUSH
4075: LD_INT 2
4077: DIV
4078: PUSH
4079: LD_INT 0
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: NOP4
4090: ARRAY
4091: ST_TO_ADDR
// neng := neng - nmech ;
4092: NOP4
4096: PUSH
4097: NOP4
4101: PUSH
4102: NOP4
4106: MINUS
4107: ST_TO_ADDR
// if ( neng < 1 ) then
4108: NOP4
4112: PUSH
4113: LD_INT 1
4115: LESS
4116: IFFALSE 4126
// neng := 1 ;
4118: NOP4
4122: PUSH
4123: LD_INT 1
4125: ST_TO_ADDR
// end ;
4126: LD_VAR 0 1
4130: RET
// function Init_Win_Condition ; begin
4131: LD_INT 0
4133: PPUSH
// if Team_Game then
4134: NOP4
4138: IFFALSE 4145
// enable ( 98 ) else
4140: LD_INT 98
4142: ENABLE_MARKED
4143: GO 4148
// enable ( 99 ) ;
4145: LD_INT 99
4147: ENABLE_MARKED
// case Game_Type of 3 :
4148: NOP4
4152: PUSH
4153: LD_INT 3
4155: DOUBLE
4156: EQUAL
4157: IFTRUE 4161
4159: GO 4167
4161: POP
// enable ( 100 ) ; end ;
4162: LD_INT 100
4164: ENABLE_MARKED
4165: GO 4168
4167: POP
// end ;
4168: LD_VAR 0 1
4172: RET
// starting begin disable ( 98 ) ;
4173: LD_INT 98
4175: DISABLE_MARKED
// disable ( 99 ) ;
4176: LD_INT 99
4178: DISABLE_MARKED
// disable ( 100 ) ;
4179: LD_INT 100
4181: DISABLE_MARKED
// disable ( 200 ) ;
4182: LD_INT 200
4184: DISABLE_MARKED
// disable ( 400 ) ;
4185: LD_INT 400
4187: DISABLE_MARKED
// disable ( 401 ) ;
4188: LD_INT 401
4190: DISABLE_MARKED
// disable ( 600 ) ;
4191: LD_INT 600
4193: DISABLE_MARKED
// mp_selectmsg := true ;
4194: LD_ADDR_OWVAR 13
4198: PUSH
4199: LD_INT 1
4201: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
4202: NOP4
// init_map ;
4206: NOP4
// init_respawning ;
4210: NOP4
// set_shared_visions_and_alliances ;
4214: NOP4
// prepare_sides ;
4218: NOP4
// InitLimits ;
4222: NOP4
// ShowTimer ;
4226: NOP4
// music_nat := Side_Nations [ your_side ] ;
4230: LD_ADDR_OWVAR 71
4234: PUSH
4235: NOP4
4239: PUSH
4240: NOP4
4244: ARRAY
4245: ST_TO_ADDR
// if IAmSpec then
4246: NOP4
4250: IFFALSE 4286
// begin PlaceSeeing ( 0 , 0 , Your_Side , - 32767 ) ;
4252: LD_INT 0
4254: PPUSH
4255: LD_INT 0
4257: PPUSH
4258: NOP4
4262: PPUSH
4263: LD_INT 32767
4265: NEG
4266: PPUSH
4267: NOP4
// CenterNowOnXY ( 104 , 69 ) ;
4271: LD_INT 104
4273: PPUSH
4274: LD_INT 69
4276: PPUSH
4277: NOP4
// enable ( 400 ) ;
4281: LD_INT 400
4283: ENABLE_MARKED
// end else
4284: GO 4340
// begin ResetFog ;
4286: NOP4
// CenterNowOnXY ( start_def [ Side_Positions [ your_side ] ] [ 1 ] , start_def [ Side_Positions [ your_side ] ] [ 2 ] ) ;
4290: NOP4
4294: PUSH
4295: NOP4
4299: PUSH
4300: NOP4
4304: ARRAY
4305: ARRAY
4306: PUSH
4307: LD_INT 1
4309: ARRAY
4310: PPUSH
4311: NOP4
4315: PUSH
4316: NOP4
4320: PUSH
4321: NOP4
4325: ARRAY
4326: ARRAY
4327: PUSH
4328: LD_INT 2
4330: ARRAY
4331: PPUSH
4332: NOP4
// Init_Win_Condition ;
4336: NOP4
// end ; if def_builduptime then
4340: NOP4
4344: IFFALSE 4350
// BeginBuildUp ;
4346: NOP4
// end ; end_of_file
4350: END
// every 1 1$0 + 0 0$0.3 marked 10 do
4351: GO 4353
4353: DISABLE
// begin CreateCratesAnywhere ( Rand ( 4 , 5 ) , true ) ;
4354: LD_INT 4
4356: PPUSH
4357: LD_INT 5
4359: PPUSH
4360: NOP4
4364: PPUSH
4365: LD_INT 1
4367: PPUSH
4368: NOP4
// enable ;
4372: ENABLE
// end ;
4373: END
// every 0 0$1 + 0 0$0.6 marked 10 do var i , amount ;
4374: GO 4376
4376: DISABLE
4377: LD_INT 0
4379: PPUSH
4380: PPUSH
// begin case tick of 1 .. 1 1$0 :
4381: NOP4
4385: PUSH
4386: LD_INT 1
4388: DOUBLE
4389: GREATEREQUAL
4390: IFFALSE 4398
4392: LD_INT 2100
4394: DOUBLE
4395: LESSEQUAL
4396: IFTRUE 4400
4398: GO 4428
4400: POP
// Wait ( shipments_density / 100 * Rand ( 0 0$10 , 0 0$30 ) ) ; 1 1$0 + 1 .. 5 5$0 :
4401: NOP4
4405: PUSH
4406: LD_INT 100
4408: DIVREAL
4409: PUSH
4410: LD_INT 350
4412: PPUSH
4413: LD_INT 1050
4415: PPUSH
4416: NOP4
4420: MUL
4421: PPUSH
4422: NOP4
4426: GO 4730
4428: LD_INT 2100
4430: PUSH
4431: LD_INT 1
4433: PLUS
4434: DOUBLE
4435: GREATEREQUAL
4436: IFFALSE 4444
4438: LD_INT 10500
4440: DOUBLE
4441: LESSEQUAL
4442: IFTRUE 4446
4444: GO 4474
4446: POP
// Wait ( shipments_density / 100 * Rand ( 0 0$30 , 0 0$45 ) ) ; 5 5$0 + 1 .. 10 10$0 :
4447: NOP4
4451: PUSH
4452: LD_INT 100
4454: DIVREAL
4455: PUSH
4456: LD_INT 1050
4458: PPUSH
4459: LD_INT 1575
4461: PPUSH
4462: NOP4
4466: MUL
4467: PPUSH
4468: NOP4
4472: GO 4730
4474: LD_INT 10500
4476: PUSH
4477: LD_INT 1
4479: PLUS
4480: DOUBLE
4481: GREATEREQUAL
4482: IFFALSE 4490
4484: LD_INT 21000
4486: DOUBLE
4487: LESSEQUAL
4488: IFTRUE 4492
4490: GO 4520
4492: POP
// Wait ( shipments_density / 100 * Rand ( 0 0$45 , 1 1$0 ) ) ; 10 10$0 + 1 .. 20 20$0 :
4493: NOP4
4497: PUSH
4498: LD_INT 100
4500: DIVREAL
4501: PUSH
4502: LD_INT 1575
4504: PPUSH
4505: LD_INT 2100
4507: PPUSH
4508: NOP4
4512: MUL
4513: PPUSH
4514: NOP4
4518: GO 4730
4520: LD_INT 21000
4522: PUSH
4523: LD_INT 1
4525: PLUS
4526: DOUBLE
4527: GREATEREQUAL
4528: IFFALSE 4536
4530: LD_INT 42000
4532: DOUBLE
4533: LESSEQUAL
4534: IFTRUE 4538
4536: GO 4566
4538: POP
// Wait ( shipments_density / 100 * Rand ( 1 1$0 , 1 1$15 ) ) ; 20 20$0 + 1 .. 30 30$0 :
4539: NOP4
4543: PUSH
4544: LD_INT 100
4546: DIVREAL
4547: PUSH
4548: LD_INT 2100
4550: PPUSH
4551: LD_INT 2625
4553: PPUSH
4554: NOP4
4558: MUL
4559: PPUSH
4560: NOP4
4564: GO 4730
4566: LD_INT 42000
4568: PUSH
4569: LD_INT 1
4571: PLUS
4572: DOUBLE
4573: GREATEREQUAL
4574: IFFALSE 4582
4576: LD_INT 63000
4578: DOUBLE
4579: LESSEQUAL
4580: IFTRUE 4584
4582: GO 4612
4584: POP
// Wait ( shipments_density / 100 * Rand ( 1 1$15 , 1 1$30 ) ) ; 30 30$0 + 1 .. 50 50$0 :
4585: NOP4
4589: PUSH
4590: LD_INT 100
4592: DIVREAL
4593: PUSH
4594: LD_INT 2625
4596: PPUSH
4597: LD_INT 3150
4599: PPUSH
4600: NOP4
4604: MUL
4605: PPUSH
4606: NOP4
4610: GO 4730
4612: LD_INT 63000
4614: PUSH
4615: LD_INT 1
4617: PLUS
4618: DOUBLE
4619: GREATEREQUAL
4620: IFFALSE 4628
4622: LD_INT 105000
4624: DOUBLE
4625: LESSEQUAL
4626: IFTRUE 4630
4628: GO 4658
4630: POP
// Wait ( shipments_density / 100 * Rand ( 1 1$30 , 1 1$45 ) ) ; 50 50$0 + 1 .. 300 300$0 :
4631: NOP4
4635: PUSH
4636: LD_INT 100
4638: DIVREAL
4639: PUSH
4640: LD_INT 3150
4642: PPUSH
4643: LD_INT 3675
4645: PPUSH
4646: NOP4
4650: MUL
4651: PPUSH
4652: NOP4
4656: GO 4730
4658: LD_INT 105000
4660: PUSH
4661: LD_INT 1
4663: PLUS
4664: DOUBLE
4665: GREATEREQUAL
4666: IFFALSE 4674
4668: LD_INT 630000
4670: DOUBLE
4671: LESSEQUAL
4672: IFTRUE 4676
4674: GO 4704
4676: POP
// Wait ( shipments_density / 100 * Rand ( 1 1$45 , 2 2$0 ) ) ; else
4677: NOP4
4681: PUSH
4682: LD_INT 100
4684: DIVREAL
4685: PUSH
4686: LD_INT 3675
4688: PPUSH
4689: LD_INT 4200
4691: PPUSH
4692: NOP4
4696: MUL
4697: PPUSH
4698: NOP4
4702: GO 4730
4704: POP
// Wait ( shipments_density / 100 * Rand ( 2 2$0 , 2 2$30 ) ) ; end ;
4705: NOP4
4709: PUSH
4710: LD_INT 100
4712: DIVREAL
4713: PUSH
4714: LD_INT 4200
4716: PPUSH
4717: LD_INT 5250
4719: PPUSH
4720: NOP4
4724: MUL
4725: PPUSH
4726: NOP4
// amount := Rand ( 3 , 5 ) ;
4730: NOP4
4734: PUSH
4735: LD_INT 3
4737: PPUSH
4738: LD_INT 5
4740: PPUSH
4741: NOP4
4745: ST_TO_ADDR
// for i in ( Side_Positions diff [ 0 ] ) do
4746: NOP4
4750: PUSH
4751: NOP4
4755: PUSH
4756: LD_INT 0
4758: PUSH
4759: EMPTY
4760: LIST
4761: DIFF
4762: PUSH
4763: FOR_IN
4764: IFFALSE 4813
// CreateCratesXYR ( amount , start_def [ i ] [ 1 ] , start_def [ i ] [ 2 ] , 20 , true ) ;
4766: NOP4
4770: PPUSH
4771: NOP4
4775: PUSH
4776: NOP4
4780: ARRAY
4781: PUSH
4782: LD_INT 1
4784: ARRAY
4785: PPUSH
4786: NOP4
4790: PUSH
4791: NOP4
4795: ARRAY
4796: PUSH
4797: LD_INT 2
4799: ARRAY
4800: PPUSH
4801: LD_INT 20
4803: PPUSH
4804: LD_INT 1
4806: PPUSH
4807: NOP4
4811: GO 4763
4813: POP
4814: POP
// enable ;
4815: ENABLE
// end ;
4816: PPOPN 2
4818: END
// every 0 0$20 + 0 0$0.9 marked 10 do var i , filter ;
4819: GO 4821
4821: DISABLE
4822: LD_INT 0
4824: PPUSH
4825: PPUSH
// begin if GetResourceArea ( MZBaseArea , mat_cans ) < ( ( 200 - shipments_density ) / 100 * 5 ) then
4826: NOP4
4830: PPUSH
4831: LD_INT 1
4833: PPUSH
4834: NOP4
4838: PUSH
4839: LD_INT 200
4841: PUSH
4842: NOP4
4846: MINUS
4847: PUSH
4848: LD_INT 100
4850: DIVREAL
4851: PUSH
4852: LD_INT 5
4854: MUL
4855: LESS
4856: IFFALSE 4881
// CreateCratesArea ( Rand ( 3 , 5 ) , MZBaseArea , true ) ;
4858: LD_INT 3
4860: PPUSH
4861: LD_INT 5
4863: PPUSH
4864: NOP4
4868: PPUSH
4869: NOP4
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: NOP4
// enable ;
4881: ENABLE
// end ; end_of_file
4882: PPOPN 2
4884: END
// function apeman_init ; begin
4885: LD_INT 0
4887: PPUSH
// uc_side := 0 ;
4888: LD_ADDR_OWVAR 20
4892: PUSH
4893: LD_INT 0
4895: ST_TO_ADDR
// uc_nation := nation_nature ;
4896: LD_ADDR_OWVAR 21
4900: PUSH
4901: LD_INT 0
4903: ST_TO_ADDR
// hc_class := class_apeman ;
4904: LD_ADDR_OWVAR 28
4908: PUSH
4909: LD_INT 12
4911: ST_TO_ADDR
// hc_basic_skills := [ 1 , 1 , 1 , 1 ] ;
4912: LD_ADDR_OWVAR 30
4916: PUSH
4917: LD_INT 1
4919: PUSH
4920: LD_INT 1
4922: PUSH
4923: LD_INT 1
4925: PUSH
4926: LD_INT 1
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 1 , 1 ] ;
4935: LD_ADDR_OWVAR 31
4939: PUSH
4940: LD_INT 1
4942: PUSH
4943: LD_INT 1
4945: PUSH
4946: LD_INT 1
4948: PUSH
4949: LD_INT 1
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: LIST
4956: LIST
4957: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
4958: LD_ADDR_OWVAR 29
4962: PUSH
4963: LD_INT 10
4965: PUSH
4966: LD_INT 12
4968: PUSH
4969: EMPTY
4970: LIST
4971: LIST
4972: ST_TO_ADDR
// hc_sex := sex_male ;
4973: LD_ADDR_OWVAR 27
4977: PUSH
4978: LD_INT 1
4980: ST_TO_ADDR
// hc_importance := 0 ;
4981: LD_ADDR_OWVAR 32
4985: PUSH
4986: LD_INT 0
4988: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
4989: LD_ADDR_OWVAR 35
4993: PUSH
4994: LD_INT 20
4996: NEG
4997: PPUSH
4998: LD_INT 20
5000: PPUSH
5001: NOP4
5005: ST_TO_ADDR
// end ;
5006: LD_VAR 0 1
5010: RET
// function prepare_apemen ; var i , j , un , ape , first , d1 , d2 ; begin
5011: LD_INT 0
5013: PPUSH
5014: PPUSH
5015: PPUSH
5016: PPUSH
5017: PPUSH
5018: PPUSH
5019: PPUSH
5020: PPUSH
// if not amount_of_apemen then
5021: NOP4
5025: NOT
5026: IFFALSE 5030
// exit ;
5028: GO 5202
// ape := 0 ;
5030: NOP4
5034: PUSH
5035: LD_INT 0
5037: ST_TO_ADDR
// repeat Wait ( ( ape + 1 ) * Rand ( 0 0$10 , 1 1$0 ) ) ;
5038: NOP4
5042: PUSH
5043: LD_INT 1
5045: PLUS
5046: PUSH
5047: LD_INT 350
5049: PPUSH
5050: LD_INT 2100
5052: PPUSH
5053: NOP4
5057: MUL
5058: PPUSH
5059: NOP4
// apeman_init ;
5063: NOP4
// PlaceUnitArea ( CreateHuman , Base1ApeArea , false ) ;
5067: NOP4
5071: PPUSH
5072: NOP4
5076: PPUSH
5077: LD_INT 0
5079: PPUSH
5080: NOP4
// PlaceUnitArea ( CreateHuman , Base2ApeArea , false ) ;
5084: NOP4
5088: PPUSH
5089: NOP4
5093: PPUSH
5094: LD_INT 0
5096: PPUSH
5097: NOP4
// PlaceUnitArea ( CreateHuman , Base3ApeArea , false ) ;
5101: NOP4
5105: PPUSH
5106: NOP4
5110: PPUSH
5111: LD_INT 0
5113: PPUSH
5114: NOP4
// PlaceUnitArea ( CreateHuman , Base4ApeArea , false ) ;
5118: NOP4
5122: PPUSH
5123: NOP4
5127: PPUSH
5128: LD_INT 0
5130: PPUSH
5131: NOP4
// PlaceUnitArea ( CreateHuman , Base5ApeArea , false ) ;
5135: NOP4
5139: PPUSH
5140: NOP4
5144: PPUSH
5145: LD_INT 0
5147: PPUSH
5148: NOP4
// PlaceUnitArea ( CreateHuman , Base6ApeArea , false ) ;
5152: NOP4
5156: PPUSH
5157: NOP4
5161: PPUSH
5162: LD_INT 0
5164: PPUSH
5165: NOP4
// Wait ( 3 ) ;
5169: LD_INT 3
5171: PPUSH
5172: NOP4
// ape := ape + 1 ;
5176: NOP4
5180: PUSH
5181: NOP4
5185: PUSH
5186: LD_INT 1
5188: PLUS
5189: ST_TO_ADDR
// until ape >= amount_of_apemen ;
5190: NOP4
5194: PUSH
5195: NOP4
5199: GREATEREQUAL
5200: IFFALSE 5038
// end ;
5202: LD_VAR 0 1
5206: RET
// every 0 0$15 do
5207: GO 5209
5209: DISABLE
// begin prepare_apemen ;
5210: NOP4
// end ; end_of_file
5214: END
// var respawn , inqueue ; export function init_respawning ; begin
5215: LD_INT 0
5217: PPUSH
// respawn := Rand ( 1 , 8 ) ;
5218: NOP4
5222: PUSH
5223: LD_INT 1
5225: PPUSH
5226: LD_INT 8
5228: PPUSH
5229: NOP4
5233: ST_TO_ADDR
// inqueue := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
5234: NOP4
5238: PUSH
5239: LD_INT 0
5241: PUSH
5242: LD_INT 0
5244: PUSH
5245: LD_INT 0
5247: PUSH
5248: LD_INT 0
5250: PUSH
5251: LD_INT 0
5253: PUSH
5254: LD_INT 0
5256: PUSH
5257: LD_INT 0
5259: PUSH
5260: LD_INT 0
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: LIST
5268: LIST
5269: LIST
5270: LIST
5271: LIST
5272: ST_TO_ADDR
// end ;
5273: LD_VAR 0 1
5277: RET
// every 0 0$1 + 0 0$0.5 do var n , dep , aktresp ;
5278: GO 5280
5280: DISABLE
5281: LD_INT 0
5283: PPUSH
5284: PPUSH
5285: PPUSH
// begin if respawning_time_max = 0 then
5286: NOP4
5290: PUSH
5291: LD_INT 0
5293: EQUAL
5294: IFFALSE 5298
// exit ;
5296: GO 5703
// if respawn = 8 then
5298: NOP4
5302: PUSH
5303: LD_INT 8
5305: EQUAL
5306: IFFALSE 5318
// respawn := 1 else
5308: NOP4
5312: PUSH
5313: LD_INT 1
5315: ST_TO_ADDR
5316: GO 5332
// respawn := respawn + 1 ;
5318: NOP4
5322: PUSH
5323: NOP4
5327: PUSH
5328: LD_INT 1
5330: PLUS
5331: ST_TO_ADDR
// if Side_Positions [ respawn ] and not inqueue [ respawn ] then
5332: NOP4
5336: PUSH
5337: NOP4
5341: ARRAY
5342: PUSH
5343: NOP4
5347: PUSH
5348: NOP4
5352: ARRAY
5353: NOT
5354: AND
5355: IFFALSE 5702
// begin n := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , respawn ] , f_not , [ f_nation , nation_nature ] ] ) ;
5357: NOP4
5361: PUSH
5362: LD_INT 21
5364: PUSH
5365: LD_INT 1
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: PUSH
5372: LD_INT 22
5374: PUSH
5375: NOP4
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: PUSH
5384: LD_INT 3
5386: PUSH
5387: LD_INT 23
5389: PUSH
5390: LD_INT 0
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: LIST
5401: LIST
5402: PPUSH
5403: NOP4
5407: ST_TO_ADDR
// if n < number_of_people then
5408: NOP4
5412: PUSH
5413: NOP4
5417: LESS
5418: IFFALSE 5699
// begin dep := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] , [ f_side , respawn ] ] ) ;
5420: NOP4
5424: PUSH
5425: LD_INT 21
5427: PUSH
5428: LD_INT 3
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 2
5437: PUSH
5438: LD_INT 30
5440: PUSH
5441: LD_INT 0
5443: PUSH
5444: EMPTY
5445: LIST
5446: LIST
5447: PUSH
5448: LD_INT 30
5450: PUSH
5451: LD_INT 1
5453: PUSH
5454: EMPTY
5455: LIST
5456: LIST
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: LIST
5462: PUSH
5463: LD_INT 50
5465: PUSH
5466: EMPTY
5467: LIST
5468: PUSH
5469: LD_INT 22
5471: PUSH
5472: NOP4
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: LIST
5485: LIST
5486: PPUSH
5487: NOP4
5491: ST_TO_ADDR
// if dep then
5492: NOP4
5496: IFFALSE 5696
// begin aktresp := respawn ;
5498: NOP4
5502: PUSH
5503: NOP4
5507: ST_TO_ADDR
// inqueue := Replace ( inqueue , aktresp , true ) ;
5508: NOP4
5512: PUSH
5513: NOP4
5517: PPUSH
5518: NOP4
5522: PPUSH
5523: LD_INT 1
5525: PPUSH
5526: NOP4
5530: ST_TO_ADDR
// enable ;
5531: ENABLE
// wait ( rand ( respawning_time_min , respawning_time_max ) ) ;
5532: NOP4
5536: PPUSH
5537: NOP4
5541: PPUSH
5542: NOP4
5546: PPUSH
5547: NOP4
// inqueue := Replace ( inqueue , aktresp , false ) ;
5551: NOP4
5555: PUSH
5556: NOP4
5560: PPUSH
5561: NOP4
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: NOP4
5573: ST_TO_ADDR
// hc_name :=  ;
5574: LD_ADDR_OWVAR 26
5578: PUSH
5579: LD_STRING 
5581: ST_TO_ADDR
// hc_importance := 0 ;
5582: LD_ADDR_OWVAR 32
5586: PUSH
5587: LD_INT 0
5589: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , skill_level div 2 ) ;
5590: LD_INT 0
5592: PPUSH
5593: LD_INT 0
5595: PPUSH
5596: NOP4
5600: PUSH
5601: LD_INT 2
5603: DIV
5604: PPUSH
5605: NOP4
// uc_nation := Side_Nations [ aktresp ] ;
5609: LD_ADDR_OWVAR 21
5613: PUSH
5614: NOP4
5618: PUSH
5619: NOP4
5623: ARRAY
5624: ST_TO_ADDR
// uc_side := aktresp ;
5625: LD_ADDR_OWVAR 20
5629: PUSH
5630: NOP4
5634: ST_TO_ADDR
// dep := dep [ Rand ( 1 , dep ) ] ;
5635: NOP4
5639: PUSH
5640: NOP4
5644: PUSH
5645: LD_INT 1
5647: PPUSH
5648: NOP4
5652: PPUSH
5653: NOP4
5657: ARRAY
5658: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , GetX ( dep ) , GetY ( dep ) , 7 , true ) ;
5659: NOP4
5663: PPUSH
5664: NOP4
5668: PPUSH
5669: NOP4
5673: PPUSH
5674: NOP4
5678: PPUSH
5679: NOP4
5683: PPUSH
5684: LD_INT 7
5686: PPUSH
5687: LD_INT 1
5689: PPUSH
5690: NOP4
// end else
5694: GO 5697
// enable ;
5696: ENABLE
// end else
5697: GO 5700
// enable ;
5699: ENABLE
// end else
5700: GO 5703
// enable ;
5702: ENABLE
// end ; end_of_file
5703: PPOPN 3
5705: END
// on BuildingStarted ( b , u ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
5706: NOP4
5710: PPUSH
5711: NOP4
5715: PUSH
5716: LD_INT 0
5718: PUSH
5719: LD_INT 1
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: IN
5726: IFFALSE 5751
// SetBName ( b , @ & GetSide ( b ) ) ;
5728: NOP4
5732: PPUSH
5733: LD_STRING @
5735: PUSH
5736: NOP4
5740: PPUSH
5741: NOP4
5745: STR
5746: PPUSH
5747: NOP4
// if def_game_rules then
5751: NOP4
5755: IFFALSE 5792
// ExecuteLimits ( b , GetBType ( b ) , GetSide ( b ) , 0 , 1 ) ;
5757: NOP4
5761: PPUSH
5762: NOP4
5766: PPUSH
5767: NOP4
5771: PPUSH
5772: NOP4
5776: PPUSH
5777: NOP4
5781: PPUSH
5782: LD_INT 0
5784: PPUSH
5785: LD_INT 1
5787: PPUSH
5788: NOP4
// end ;
5792: PPOPN 2
5794: END
// on BuildingCaptured ( b , o , e ) do begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
5795: NOP4
5799: PPUSH
5800: NOP4
5804: PUSH
5805: LD_INT 0
5807: PUSH
5808: LD_INT 1
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: IN
5815: IFFALSE 5840
// SetBName ( b , @ & GetSide ( b ) ) ;
5817: NOP4
5821: PPUSH
5822: LD_STRING @
5824: PUSH
5825: NOP4
5829: PPUSH
5830: NOP4
5834: STR
5835: PPUSH
5836: NOP4
// if def_game_rules then
5840: NOP4
5844: IFFALSE 5883
// ExecuteLimits ( b , GetBType ( b ) , GetSide ( b ) , o , 1 ) ;
5846: NOP4
5850: PPUSH
5851: NOP4
5855: PPUSH
5856: NOP4
5860: PPUSH
5861: NOP4
5865: PPUSH
5866: NOP4
5870: PPUSH
5871: NOP4
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: NOP4
// end ;
5883: PPOPN 3
5885: END
// on UnitDestroyed ( j ) do var x , y , pos , dir ;
5886: LD_INT 0
5888: PPUSH
5889: PPUSH
5890: PPUSH
5891: PPUSH
// begin if GetBType ( j ) in [ b_depot , b_warehouse ] then
5892: NOP4
5896: PPUSH
5897: NOP4
5901: PUSH
5902: LD_INT 0
5904: PUSH
5905: LD_INT 1
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: IN
5912: IFFALSE 5994
// begin pos := Side_Positions [ GetSide ( j ) ] ;
5914: NOP4
5918: PUSH
5919: NOP4
5923: PUSH
5924: NOP4
5928: PPUSH
5929: NOP4
5933: ARRAY
5934: ST_TO_ADDR
// x := start_def [ pos ] [ 1 ] ;
5935: NOP4
5939: PUSH
5940: NOP4
5944: PUSH
5945: NOP4
5949: ARRAY
5950: PUSH
5951: LD_INT 1
5953: ARRAY
5954: ST_TO_ADDR
// y := start_def [ pos ] [ 2 ] ;
5955: NOP4
5959: PUSH
5960: NOP4
5964: PUSH
5965: NOP4
5969: ARRAY
5970: PUSH
5971: LD_INT 2
5973: ARRAY
5974: ST_TO_ADDR
// KillBattleFlag ( FindBattleFlag ( x , y ) ) ;
5975: NOP4
5979: PPUSH
5980: NOP4
5984: PPUSH
5985: NOP4
5989: PPUSH
5990: NOP4
// end ; if def_game_rules then
5994: NOP4
5998: IFFALSE 6097
// if ( GetType ( j ) = 3 ) then
6000: NOP4
6004: PPUSH
6005: NOP4
6009: PUSH
6010: LD_INT 3
6012: EQUAL
6013: IFFALSE 6053
// ExecuteLimits ( j , GetBType ( j ) , GetSide ( j ) , 0 , - 1 ) else
6015: NOP4
6019: PPUSH
6020: NOP4
6024: PPUSH
6025: NOP4
6029: PPUSH
6030: NOP4
6034: PPUSH
6035: NOP4
6039: PPUSH
6040: LD_INT 0
6042: PPUSH
6043: LD_INT 1
6045: NEG
6046: PPUSH
6047: NOP4
6051: GO 6097
// if ( GetChassis ( j ) = 25 ) then
6053: NOP4
6057: PPUSH
6058: NOP4
6062: PUSH
6063: LD_INT 25
6065: EQUAL
6066: IFFALSE 6097
// ExecuteLimits ( j , b_behemoth , GetSide ( j ) , 0 , - 1 ) ;
6068: NOP4
6072: PPUSH
6073: LD_INT 37
6075: PPUSH
6076: NOP4
6080: PPUSH
6081: NOP4
6085: PPUSH
6086: LD_INT 0
6088: PPUSH
6089: LD_INT 1
6091: NEG
6092: PPUSH
6093: NOP4
// end ;
6097: PPOPN 5
6099: END
// on VehicleCaptured ( j , i1 , o , i2 ) do begin if def_game_rules and ( GetChassis ( j ) = 25 ) then
6100: NOP4
6104: PUSH
6105: NOP4
6109: PPUSH
6110: NOP4
6114: PUSH
6115: LD_INT 25
6117: EQUAL
6118: AND
6119: IFFALSE 6151
// ExecuteLimits ( j , b_behemoth , GetSide ( j ) , o , 1 ) ;
6121: NOP4
6125: PPUSH
6126: LD_INT 37
6128: PPUSH
6129: NOP4
6133: PPUSH
6134: NOP4
6138: PPUSH
6139: NOP4
6143: PPUSH
6144: LD_INT 1
6146: PPUSH
6147: NOP4
// end ; end_of_file
6151: PPOPN 4
6153: END
// function CanWinLoose ; begin
6154: LD_INT 0
6156: PPUSH
// Result := true ;
6157: NOP4
6161: PUSH
6162: LD_INT 1
6164: ST_TO_ADDR
// if IAmServer and PlayerCount > 0 then
6165: NOP4
6169: PUSH
6170: NOP4
6174: PUSH
6175: LD_INT 0
6177: GREATER
6178: AND
6179: IFFALSE 6189
// Result := false ;
6181: NOP4
6185: PUSH
6186: LD_INT 0
6188: ST_TO_ADDR
// if IAmSpec and PlayerCount > 1 then
6189: NOP4
6193: PUSH
6194: NOP4
6198: PUSH
6199: LD_INT 1
6201: GREATER
6202: AND
6203: IFFALSE 6213
// Result := false ;
6205: NOP4
6209: PUSH
6210: LD_INT 0
6212: ST_TO_ADDR
// end ;
6213: LD_VAR 0 1
6217: RET
// function HasPower ( i ) ; begin
6218: LD_INT 0
6220: PPUSH
// if def_people_respawning then
6221: NOP4
6225: IFFALSE 6316
// Result := FilterAllUnits ( [ [ f_side , i ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_computer ] , [ f_control , control_apeman ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) else
6227: NOP4
6231: PUSH
6232: LD_INT 22
6234: PUSH
6235: NOP4
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 2
6246: PUSH
6247: LD_INT 21
6249: PUSH
6250: LD_INT 1
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: PUSH
6257: LD_INT 33
6259: PUSH
6260: LD_INT 3
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: LD_INT 33
6269: PUSH
6270: LD_INT 5
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PUSH
6277: LD_INT 30
6279: PUSH
6280: LD_INT 0
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PUSH
6287: LD_INT 30
6289: PUSH
6290: LD_INT 1
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: LIST
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PPUSH
6309: NOP4
6313: ST_TO_ADDR
6314: GO 6381
// Result := FilterAllUnits ( [ [ f_side , i ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_computer ] , [ f_control , control_apeman ] ] ] ) ;
6316: NOP4
6320: PUSH
6321: LD_INT 22
6323: PUSH
6324: NOP4
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 2
6335: PUSH
6336: LD_INT 21
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PUSH
6346: LD_INT 33
6348: PUSH
6349: LD_INT 3
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 33
6358: PUSH
6359: LD_INT 5
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PPUSH
6376: NOP4
6380: ST_TO_ADDR
// end ;
6381: LD_VAR 0 2
6385: RET
// function AlliedSides ( i , j ) ; begin
6386: LD_INT 0
6388: PPUSH
// Result := false ;
6389: NOP4
6393: PUSH
6394: LD_INT 0
6396: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
6397: NOP4
6401: PPUSH
6402: NOP4
6406: PPUSH
6407: NOP4
6411: PUSH
6412: LD_INT 1
6414: EQUAL
6415: PUSH
6416: NOP4
6420: PPUSH
6421: NOP4
6425: PPUSH
6426: NOP4
6430: PUSH
6431: LD_INT 1
6433: EQUAL
6434: AND
6435: PUSH
6436: NOP4
6440: PPUSH
6441: NOP4
6445: AND
6446: PUSH
6447: NOP4
6451: PPUSH
6452: NOP4
6456: AND
6457: IFFALSE 6467
// Result := true ;
6459: NOP4
6463: PUSH
6464: LD_INT 1
6466: ST_TO_ADDR
// end ;
6467: LD_VAR 0 3
6471: RET
// every 0 0$3 trigger CanWinLoose marked 400 do
6472: NOP4
6476: IFFALSE 6485
6478: GO 6480
6480: DISABLE
// YouLostInMultiplayer ;
6481: NOP4
6485: END
// every 0 0$3 trigger CanWinLoose marked 401 do
6486: NOP4
6490: IFFALSE 6499
6492: GO 6494
6494: DISABLE
// YouWinInMultiplayer ;
6495: NOP4
6499: END
// every 0 0$3 marked 98 do var i , CanWin ;
6500: GO 6502
6502: DISABLE
6503: LD_INT 0
6505: PPUSH
6506: PPUSH
// begin if not HasPower ( your_side ) then
6507: NOP4
6511: PPUSH
6512: NOP4
6516: NOT
6517: IFFALSE 6528
// begin Multiplayer_Loose_Message ;
6519: NOP4
// enable ( 400 ) ;
6523: LD_INT 400
6525: ENABLE_MARKED
// end else
6526: GO 6661
// begin CanWin := true ;
6528: NOP4
6532: PUSH
6533: LD_INT 1
6535: ST_TO_ADDR
// for i := 1 to 8 do
6536: NOP4
6540: PUSH
6541: DOUBLE
6542: LD_INT 1
6544: DEC
6545: ST_TO_ADDR
6546: LD_INT 8
6548: PUSH
6549: FOR_TO
6550: IFFALSE 6647
// if Side_Positions [ i ] and MultiplayerSideAlive ( i ) and ( i <> your_side ) then
6552: NOP4
6556: PUSH
6557: NOP4
6561: ARRAY
6562: PUSH
6563: NOP4
6567: PPUSH
6568: NOP4
6572: AND
6573: PUSH
6574: NOP4
6578: PUSH
6579: NOP4
6583: NONEQUAL
6584: AND
6585: IFFALSE 6645
// if not Side_Teams [ i ] or ( Side_Teams [ i ] <> Side_Teams [ your_side ] ) then
6587: NOP4
6591: PUSH
6592: NOP4
6596: ARRAY
6597: NOT
6598: PUSH
6599: NOP4
6603: PUSH
6604: NOP4
6608: ARRAY
6609: PUSH
6610: NOP4
6614: PUSH
6615: NOP4
6619: ARRAY
6620: NONEQUAL
6621: OR
6622: IFFALSE 6645
// if HasPower ( i ) then
6624: NOP4
6628: PPUSH
6629: NOP4
6633: IFFALSE 6645
// begin CanWin := false ;
6635: NOP4
6639: PUSH
6640: LD_INT 0
6642: ST_TO_ADDR
// break ;
6643: GO 6647
// end ;
6645: GO 6549
6647: POP
6648: POP
// if CanWin then
6649: NOP4
6653: IFFALSE 6660
// enable ( 401 ) else
6655: LD_INT 401
6657: ENABLE_MARKED
6658: GO 6661
// enable ;
6660: ENABLE
// end ; end ;
6661: PPOPN 2
6663: END
// every 0 0$3 marked 99 do var i , CanWin ;
6664: GO 6666
6666: DISABLE
6667: LD_INT 0
6669: PPUSH
6670: PPUSH
// begin if not HasPower ( your_side ) then
6671: NOP4
6675: PPUSH
6676: NOP4
6680: NOT
6681: IFFALSE 6692
// begin Multiplayer_Loose_Message ;
6683: NOP4
// enable ( 400 ) ;
6687: LD_INT 400
6689: ENABLE_MARKED
// end else
6690: GO 6805
// begin CanWin := true ;
6692: NOP4
6696: PUSH
6697: LD_INT 1
6699: ST_TO_ADDR
// for i := 1 to 8 do
6700: NOP4
6704: PUSH
6705: DOUBLE
6706: LD_INT 1
6708: DEC
6709: ST_TO_ADDR
6710: LD_INT 8
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6791
// if Side_Positions [ i ] and MultiplayerSideAlive ( i ) and ( i <> your_side ) then
6716: NOP4
6720: PUSH
6721: NOP4
6725: ARRAY
6726: PUSH
6727: NOP4
6731: PPUSH
6732: NOP4
6736: AND
6737: PUSH
6738: NOP4
6742: PUSH
6743: NOP4
6747: NONEQUAL
6748: AND
6749: IFFALSE 6789
// if not AlliedSides ( i , your_side ) then
6751: NOP4
6755: PPUSH
6756: NOP4
6760: PPUSH
6761: NOP4
6765: NOT
6766: IFFALSE 6789
// if HasPower ( i ) then
6768: NOP4
6772: PPUSH
6773: NOP4
6777: IFFALSE 6789
// begin CanWin := false ;
6779: NOP4
6783: PUSH
6784: LD_INT 0
6786: ST_TO_ADDR
// break ;
6787: GO 6791
// end ;
6789: GO 6713
6791: POP
6792: POP
// if CanWin then
6793: NOP4
6797: IFFALSE 6804
// enable ( 401 ) else
6799: LD_INT 401
6801: ENABLE_MARKED
6802: GO 6805
// enable ;
6804: ENABLE
// end ; end ; end_of_file
6805: PPOPN 2
6807: END
// var strength , lastxwin , lastywin , lastxlost , lastylost ; function Update_Flags ; var un ; begin
6808: LD_INT 0
6810: PPUSH
6811: PPUSH
// for un in battle_flags_id do
6812: NOP4
6816: PUSH
6817: NOP4
6821: PUSH
6822: FOR_IN
6823: IFFALSE 6898
// ChangeBattleFlagOptions ( un , [ [ bfo_defend_bonus_human , strength ] , [ bfo_defend_bonus_vehicle , strength div 2 ] , [ bfo_defend_bonus_building , strength div 5 ] , [ bfo_height , strength ] ] ) ;
6825: NOP4
6829: PPUSH
6830: LD_INT 1
6832: PUSH
6833: NOP4
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: PUSH
6842: LD_INT 2
6844: PUSH
6845: NOP4
6849: PUSH
6850: LD_INT 2
6852: DIV
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: NOP4
6865: PUSH
6866: LD_INT 5
6868: DIV
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 20
6876: PUSH
6877: NOP4
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: PPUSH
6892: NOP4
6896: GO 6822
6898: POP
6899: POP
// end ;
6900: LD_VAR 0 1
6904: RET
// every 1 do var un ;
6905: GO 6907
6907: DISABLE
6908: LD_INT 0
6910: PPUSH
// begin if not def_morale_flags then
6911: NOP4
6915: NOT
6916: IFFALSE 6920
// exit ;
6918: GO 6997
// if not morale_decreasing_time then
6920: NOP4
6924: NOT
6925: IFFALSE 6929
// exit ;
6927: GO 6997
// strength = 100 ;
6929: NOP4
6933: PUSH
6934: LD_INT 100
6936: ST_TO_ADDR
// repeat wait ( morale_decreasing_time ) ;
6937: NOP4
6941: PPUSH
6942: NOP4
// strength := strength - 1 ;
6946: NOP4
6950: PUSH
6951: NOP4
6955: PUSH
6956: LD_INT 1
6958: MINUS
6959: ST_TO_ADDR
// Update_Flags ;
6960: NOP4
// until not strength ;
6964: NOP4
6968: NOT
6969: IFFALSE 6937
// for un in battle_flags_id do
6971: NOP4
6975: PUSH
6976: NOP4
6980: PUSH
6981: FOR_IN
6982: IFFALSE 6995
// KillBattleFlag ( un ) ;
6984: NOP4
6988: PPUSH
6989: NOP4
6993: GO 6981
6995: POP
6996: POP
// end ; end_of_file
6997: PPOPN 1
6999: END
// export BuildUpAreas ; export function BeginBuildUp ; var i , j ; begin
7000: LD_INT 0
7002: PPUSH
7003: PPUSH
7004: PPUSH
// enable ( 600 ) ;
7005: LD_INT 600
7007: ENABLE_MARKED
// for i := 1 to BuildUpAreas do
7008: NOP4
7012: PUSH
7013: DOUBLE
7014: LD_INT 1
7016: DEC
7017: ST_TO_ADDR
7018: NOP4
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7179
// if Position_Sides [ i ] then
7026: NOP4
7030: PUSH
7031: NOP4
7035: ARRAY
7036: IFFALSE 7177
// for j := 1 to 8 do
7038: NOP4
7042: PUSH
7043: DOUBLE
7044: LD_INT 1
7046: DEC
7047: ST_TO_ADDR
7048: LD_INT 8
7050: PUSH
7051: FOR_TO
7052: IFFALSE 7175
// if Side_Positions [ j ] and ( ( Side_Teams [ Position_Sides [ i ] ] <> Side_Teams [ j ] ) or ( not Team_Game ) and ( Position_Sides [ i ] <> j ) ) then
7054: NOP4
7058: PUSH
7059: NOP4
7063: ARRAY
7064: PUSH
7065: NOP4
7069: PUSH
7070: NOP4
7074: PUSH
7075: NOP4
7079: ARRAY
7080: ARRAY
7081: PUSH
7082: NOP4
7086: PUSH
7087: NOP4
7091: ARRAY
7092: NONEQUAL
7093: PUSH
7094: NOP4
7098: NOT
7099: PUSH
7100: NOP4
7104: PUSH
7105: NOP4
7109: ARRAY
7110: PUSH
7111: NOP4
7115: NONEQUAL
7116: AND
7117: OR
7118: AND
7119: IFFALSE 7143
// HideArea ( j , BuildUpAreas [ i ] ) else
7121: NOP4
7125: PPUSH
7126: NOP4
7130: PUSH
7131: NOP4
7135: ARRAY
7136: PPUSH
7137: NOP4
7141: GO 7173
// if ( j = your_side ) then
7143: NOP4
7147: PUSH
7148: NOP4
7152: EQUAL
7153: IFFALSE 7173
// SetAreaMapShow ( BuildUpAreas [ i ] , 5 ) ;
7155: NOP4
7159: PUSH
7160: NOP4
7164: ARRAY
7165: PPUSH
7166: LD_INT 5
7168: PPUSH
7169: NOP4
7173: GO 7051
7175: POP
7176: POP
7177: GO 7023
7179: POP
7180: POP
// end ;
7181: LD_VAR 0 1
7185: RET
// export function EndBuildUp ; var i , j ; begin
7186: LD_INT 0
7188: PPUSH
7189: PPUSH
7190: PPUSH
// disable ( 600 ) ;
7191: LD_INT 600
7193: DISABLE_MARKED
// for i := 1 to BuildUpAreas do
7194: NOP4
7198: PUSH
7199: DOUBLE
7200: LD_INT 1
7202: DEC
7203: ST_TO_ADDR
7204: NOP4
7208: PUSH
7209: FOR_TO
7210: IFFALSE 7365
// if Position_Sides [ i ] then
7212: NOP4
7216: PUSH
7217: NOP4
7221: ARRAY
7222: IFFALSE 7363
// for j := 1 to 8 do
7224: NOP4
7228: PUSH
7229: DOUBLE
7230: LD_INT 1
7232: DEC
7233: ST_TO_ADDR
7234: LD_INT 8
7236: PUSH
7237: FOR_TO
7238: IFFALSE 7361
// if Side_Positions [ j ] and ( ( Side_Teams [ Position_Sides [ i ] ] <> Side_Teams [ j ] ) or ( not Team_Game ) and ( Position_Sides [ i ] <> j ) ) then
7240: NOP4
7244: PUSH
7245: NOP4
7249: ARRAY
7250: PUSH
7251: NOP4
7255: PUSH
7256: NOP4
7260: PUSH
7261: NOP4
7265: ARRAY
7266: ARRAY
7267: PUSH
7268: NOP4
7272: PUSH
7273: NOP4
7277: ARRAY
7278: NONEQUAL
7279: PUSH
7280: NOP4
7284: NOT
7285: PUSH
7286: NOP4
7290: PUSH
7291: NOP4
7295: ARRAY
7296: PUSH
7297: NOP4
7301: NONEQUAL
7302: AND
7303: OR
7304: AND
7305: IFFALSE 7329
// ShowArea ( j , BuildUpAreas [ i ] ) else
7307: NOP4
7311: PPUSH
7312: NOP4
7316: PUSH
7317: NOP4
7321: ARRAY
7322: PPUSH
7323: NOP4
7327: GO 7359
// if ( j = your_side ) then
7329: NOP4
7333: PUSH
7334: NOP4
7338: EQUAL
7339: IFFALSE 7359
// SetAreaMapShow ( BuildUpAreas [ i ] , 0 ) ;
7341: NOP4
7345: PUSH
7346: NOP4
7350: ARRAY
7351: PPUSH
7352: LD_INT 0
7354: PPUSH
7355: NOP4
7359: GO 7237
7361: POP
7362: POP
7363: GO 7209
7365: POP
7366: POP
// end ;
7367: LD_VAR 0 1
7371: RET
// every 5 marked 600 do var i , un ;
7372: GO 7374
7374: DISABLE
7375: LD_INT 0
7377: PPUSH
7378: PPUSH
// begin for i := 1 to BuildUpAreas do
7379: NOP4
7383: PUSH
7384: DOUBLE
7385: LD_INT 1
7387: DEC
7388: ST_TO_ADDR
7389: NOP4
7393: PUSH
7394: FOR_TO
7395: IFFALSE 7550
// if Position_Sides [ i ] then
7397: NOP4
7401: PUSH
7402: NOP4
7406: ARRAY
7407: IFFALSE 7548
// for un in FilterUnitsInArea ( BuildUpAreas [ i ] , [ [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_side , Your_Side ] ] ) do
7409: NOP4
7413: PUSH
7414: NOP4
7418: PUSH
7419: NOP4
7423: ARRAY
7424: PPUSH
7425: LD_INT 2
7427: PUSH
7428: LD_INT 21
7430: PUSH
7431: LD_INT 1
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: LD_INT 21
7440: PUSH
7441: LD_INT 2
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 22
7455: PUSH
7456: NOP4
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PPUSH
7469: NOP4
7473: PUSH
7474: FOR_IN
7475: IFFALSE 7546
// if ( ( Side_Teams [ Position_Sides [ i ] ] <> Side_Teams [ Your_Side ] ) or ( not Team_Game ) and ( Position_Sides [ i ] <> Your_Side ) ) then
7477: NOP4
7481: PUSH
7482: NOP4
7486: PUSH
7487: NOP4
7491: ARRAY
7492: ARRAY
7493: PUSH
7494: NOP4
7498: PUSH
7499: NOP4
7503: ARRAY
7504: NONEQUAL
7505: PUSH
7506: NOP4
7510: NOT
7511: PUSH
7512: NOP4
7516: PUSH
7517: NOP4
7521: ARRAY
7522: PUSH
7523: NOP4
7527: NONEQUAL
7528: AND
7529: OR
7530: IFFALSE 7544
// ComMoveToArea ( un , BuildUpEscape ) ;
7532: NOP4
7536: PPUSH
7537: LD_INT 28
7539: PPUSH
7540: NOP4
7544: GO 7474
7546: POP
7547: POP
7548: GO 7394
7550: POP
7551: POP
// enable ;
7552: ENABLE
// end ;
7553: PPOPN 2
7555: END
// every 5 5$00 do
7556: GO 7558
7558: DISABLE
// if ( def_builduptime = 1 ) then
7559: NOP4
7563: PUSH
7564: LD_INT 1
7566: EQUAL
7567: IFFALSE 7573
// EndBuildUp ;
7569: NOP4
7573: END
// every 10 10$00 do
7574: GO 7576
7576: DISABLE
// if ( def_builduptime = 2 ) then
7577: NOP4
7581: PUSH
7582: LD_INT 2
7584: EQUAL
7585: IFFALSE 7591
// EndBuildUp ;
7587: NOP4
7591: END
// every 15 15$00 do
7592: GO 7594
7594: DISABLE
// if ( def_builduptime = 3 ) then
7595: NOP4
7599: PUSH
7600: LD_INT 3
7602: EQUAL
7603: IFFALSE 7609
// EndBuildUp ; end_of_file
7605: NOP4
7609: END
// export ExtraStrings ; export function ShowTimer ; var AllStrings ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
// AllStrings := [ #Multi1x1-Time , tick ] ;
7614: NOP4
7618: PUSH
7619: LD_STRING #Multi1x1-Time
7621: PUSH
7622: NOP4
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: ST_TO_ADDR
// if ( ExtraStrings ) then
7631: NOP4
7635: IFFALSE 7657
// AllStrings := AllStrings ^  ^ ExtraStrings ;
7637: NOP4
7641: PUSH
7642: NOP4
7646: PUSH
7647: LD_STRING 
7649: ADD
7650: PUSH
7651: NOP4
7655: ADD
7656: ST_TO_ADDR
// if ( LimitsStrings ) then
7657: NOP4
7661: IFFALSE 7683
// AllStrings := AllStrings ^  ^ LimitsStrings ;
7663: NOP4
7667: PUSH
7668: NOP4
7672: PUSH
7673: LD_STRING 
7675: ADD
7676: PUSH
7677: NOP4
7681: ADD
7682: ST_TO_ADDR
// Display_Strings := AllStrings ;
7683: LD_ADDR_OWVAR 47
7687: PUSH
7688: NOP4
7692: ST_TO_ADDR
// end ;
7693: LD_VAR 0 1
7697: RET
// every 0 0$1 do
7698: GO 7700
7700: DISABLE
// begin ShowTimer ;
7701: NOP4
// enable ;
7705: ENABLE
// end ;
7706: END
