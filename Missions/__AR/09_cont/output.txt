// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareAmerican ;
   4: CALL 17 0 0
// LoadVehicles ;
   8: CALL 7200 0 0
// Action ;
  12: CALL 7810 0 0
// end ; end_of_file
  16: END
// export am ; export us_depot , us_lab1 , us_lab2 , us_barracks , us_factory , us_ct , us_towers , us_bunkers , us_force ; export us_sold , us_eng , us_mech , us_sci , us_snip ; export us_buildings , us_vehicles , us_humans ; export us_blist , us_vlist , us_hlist ; export us_skill , us_attack , us_contact ; export us_comander ; export function PrepareAmerican ; var i , p , un , veh , b ; begin
  17: LD_INT 0
  19: PPUSH
  20: PPUSH
  21: PPUSH
  22: PPUSH
  23: PPUSH
  24: PPUSH
// uc_side := 1 ;
  25: LD_ADDR_OWVAR 20
  29: PUSH
  30: LD_INT 1
  32: ST_TO_ADDR
// uc_nation := 1 ;
  33: LD_ADDR_OWVAR 21
  37: PUSH
  38: LD_INT 1
  40: ST_TO_ADDR
// am := 1 ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 1
  48: ST_TO_ADDR
// us_skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
  49: LD_ADDR_EXP 22
  53: PUSH
  54: LD_INT 6
  56: PUSH
  57: LD_INT 7
  59: PUSH
  60: LD_INT 8
  62: PUSH
  63: EMPTY
  64: LIST
  65: LIST
  66: LIST
  67: PUSH
  68: LD_OWVAR 67
  72: ARRAY
  73: ST_TO_ADDR
// us_force := [ ] ;
  74: LD_ADDR_EXP 10
  78: PUSH
  79: EMPTY
  80: ST_TO_ADDR
// us_attack := 0 ;
  81: LD_ADDR_EXP 23
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// us_contact := false ;
  89: LD_ADDR_EXP 24
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// case difficulty of 1 :
  97: LD_OWVAR 67
 101: PUSH
 102: LD_INT 1
 104: DOUBLE
 105: EQUAL
 106: IFTRUE 110
 108: GO 120
 110: POP
// us_blist := [ ] ; 2 :
 111: LD_ADDR_EXP 19
 115: PUSH
 116: EMPTY
 117: ST_TO_ADDR
 118: GO 221
 120: LD_INT 2
 122: DOUBLE
 123: EQUAL
 124: IFTRUE 128
 126: GO 154
 128: POP
// us_blist := [ b_turret , 145 , 42 , 5 ] ; 3 :
 129: LD_ADDR_EXP 19
 133: PUSH
 134: LD_INT 33
 136: PUSH
 137: LD_INT 145
 139: PUSH
 140: LD_INT 42
 142: PUSH
 143: LD_INT 5
 145: PUSH
 146: EMPTY
 147: LIST
 148: LIST
 149: LIST
 150: LIST
 151: ST_TO_ADDR
 152: GO 221
 154: LD_INT 3
 156: DOUBLE
 157: EQUAL
 158: IFTRUE 162
 160: GO 220
 162: POP
// us_blist := [ b_turret , 123 , 33 , 5 , b_turret , 123 , 33 , 5 , b_turret , 145 , 42 , 5 ] ; end ;
 163: LD_ADDR_EXP 19
 167: PUSH
 168: LD_INT 33
 170: PUSH
 171: LD_INT 123
 173: PUSH
 174: LD_INT 33
 176: PUSH
 177: LD_INT 5
 179: PUSH
 180: LD_INT 33
 182: PUSH
 183: LD_INT 123
 185: PUSH
 186: LD_INT 33
 188: PUSH
 189: LD_INT 5
 191: PUSH
 192: LD_INT 33
 194: PUSH
 195: LD_INT 145
 197: PUSH
 198: LD_INT 42
 200: PUSH
 201: LD_INT 5
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: LIST
 209: LIST
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: LIST
 215: LIST
 216: LIST
 217: ST_TO_ADDR
 218: GO 221
 220: POP
// FilterUS ( ) ;
 221: CALL 3058 0 0
// SetBName ( us_depot , Dzeta ) ;
 225: LD_EXP 2
 229: PPUSH
 230: LD_STRING Dzeta
 232: PPUSH
 233: CALL_OW 500
// AddComResearch ( us_lab1 , tech_tech3 ) ;
 237: LD_EXP 3
 241: PPUSH
 242: LD_INT 50
 244: PPUSH
 245: CALL_OW 184
// AddComResearch ( us_lab2 , tech_comp1 ) ;
 249: LD_EXP 4
 253: PPUSH
 254: LD_INT 57
 256: PPUSH
 257: CALL_OW 184
// AddComResearch ( us_lab2 , tech_ai ) ;
 261: LD_EXP 4
 265: PPUSH
 266: LD_INT 32
 268: PPUSH
 269: CALL_OW 184
// AddComResearch ( us_lab2 , tech_sib1 ) ;
 273: LD_EXP 4
 277: PPUSH
 278: LD_INT 54
 280: PPUSH
 281: CALL_OW 184
// AddComResearch ( us_lab2 , tech_comp2 ) ;
 285: LD_EXP 4
 289: PPUSH
 290: LD_INT 58
 292: PPUSH
 293: CALL_OW 184
// AddComResearch ( us_lab2 , tech_advai ) ;
 297: LD_EXP 4
 301: PPUSH
 302: LD_INT 27
 304: PPUSH
 305: CALL_OW 184
// us_vlist := [ us_medium_wheeled , engine_combustion , control_remote , us_cargo_bay , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ;
 309: LD_ADDR_EXP 20
 313: PUSH
 314: LD_INT 2
 316: PUSH
 317: LD_INT 1
 319: PUSH
 320: LD_INT 2
 322: PUSH
 323: LD_INT 12
 325: PUSH
 326: LD_INT 3
 328: PUSH
 329: LD_INT 1
 331: PUSH
 332: LD_INT 2
 334: PUSH
 335: LD_INT 5
 337: PUSH
 338: EMPTY
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: LIST
 344: LIST
 345: LIST
 346: LIST
 347: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , us_skill ) ;
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: LD_EXP 22
 358: PPUSH
 359: CALL_OW 380
// hc_name := Dominic A. Comer ;
 363: LD_ADDR_OWVAR 26
 367: PUSH
 368: LD_STRING Dominic A. Comer
 370: ST_TO_ADDR
// hc_gallery := sandar ;
 371: LD_ADDR_OWVAR 33
 375: PUSH
 376: LD_STRING sandar
 378: ST_TO_ADDR
// hc_face_number := 38 ;
 379: LD_ADDR_OWVAR 34
 383: PUSH
 384: LD_INT 38
 386: ST_TO_ADDR
// hc_importance := 0 ;
 387: LD_ADDR_OWVAR 32
 391: PUSH
 392: LD_INT 0
 394: ST_TO_ADDR
// us_comander := CreateHuman ;
 395: LD_ADDR_EXP 25
 399: PUSH
 400: CALL_OW 44
 404: ST_TO_ADDR
// PlaceHumanInUnit ( us_comander , us_depot ) ;
 405: LD_EXP 25
 409: PPUSH
 410: LD_EXP 2
 414: PPUSH
 415: CALL_OW 52
// RandFacesAndNames ( ) ;
 419: CALL 4060 0 0
// for i = 1 to us_towers do
 423: LD_ADDR_VAR 0 2
 427: PUSH
 428: DOUBLE
 429: LD_INT 1
 431: DEC
 432: ST_TO_ADDR
 433: LD_EXP 8
 437: PUSH
 438: FOR_TO
 439: IFFALSE 478
// begin PrepareHuman ( false , 1 , us_skill ) ;
 441: LD_INT 0
 443: PPUSH
 444: LD_INT 1
 446: PPUSH
 447: LD_EXP 22
 451: PPUSH
 452: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_towers [ i ] ) ;
 456: CALL_OW 44
 460: PPUSH
 461: LD_EXP 8
 465: PUSH
 466: LD_VAR 0 2
 470: ARRAY
 471: PPUSH
 472: CALL_OW 52
// end ;
 476: GO 438
 478: POP
 479: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
 480: LD_ADDR_VAR 0 2
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_INT 4
 492: PUSH
 493: LD_INT 5
 495: PUSH
 496: LD_INT 6
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: PUSH
 510: FOR_TO
 511: IFFALSE 544
// begin PrepareHuman ( false , 5 , us_skill ) ;
 513: LD_INT 0
 515: PPUSH
 516: LD_INT 5
 518: PPUSH
 519: LD_EXP 22
 523: PPUSH
 524: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_barracks ) ;
 528: CALL_OW 44
 532: PPUSH
 533: LD_EXP 5
 537: PPUSH
 538: CALL_OW 52
// end ;
 542: GO 510
 544: POP
 545: POP
// for i = 1 to 4 do
 546: LD_ADDR_VAR 0 2
 550: PUSH
 551: DOUBLE
 552: LD_INT 1
 554: DEC
 555: ST_TO_ADDR
 556: LD_INT 4
 558: PUSH
 559: FOR_TO
 560: IFFALSE 607
// begin PrepareHuman ( false , 4 , us_skill ) ;
 562: LD_INT 0
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: LD_EXP 22
 572: PPUSH
 573: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab1 ) ;
 577: CALL_OW 44
 581: PPUSH
 582: LD_EXP 3
 586: PPUSH
 587: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_lab2 ) ;
 591: CALL_OW 44
 595: PPUSH
 596: LD_EXP 4
 600: PPUSH
 601: CALL_OW 52
// end ;
 605: GO 559
 607: POP
 608: POP
// for i = 1 to 6 do
 609: LD_ADDR_VAR 0 2
 613: PUSH
 614: DOUBLE
 615: LD_INT 1
 617: DEC
 618: ST_TO_ADDR
 619: LD_INT 6
 621: PUSH
 622: FOR_TO
 623: IFFALSE 680
// begin PrepareHuman ( false , 3 , us_skill ) ;
 625: LD_INT 0
 627: PPUSH
 628: LD_INT 3
 630: PPUSH
 631: LD_EXP 22
 635: PPUSH
 636: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_factory ) ;
 640: CALL_OW 44
 644: PPUSH
 645: LD_EXP 6
 649: PPUSH
 650: CALL_OW 52
// if i < 4 then
 654: LD_VAR 0 2
 658: PUSH
 659: LD_INT 4
 661: LESS
 662: IFFALSE 678
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
 664: CALL_OW 44
 668: PPUSH
 669: LD_EXP 7
 673: PPUSH
 674: CALL_OW 52
// end ;
 678: GO 622
 680: POP
 681: POP
// for i = 1 to 6 do
 682: LD_ADDR_VAR 0 2
 686: PUSH
 687: DOUBLE
 688: LD_INT 1
 690: DEC
 691: ST_TO_ADDR
 692: LD_INT 6
 694: PUSH
 695: FOR_TO
 696: IFFALSE 729
// begin PrepareHuman ( false , 2 , us_skill ) ;
 698: LD_INT 0
 700: PPUSH
 701: LD_INT 2
 703: PPUSH
 704: LD_EXP 22
 708: PPUSH
 709: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
 713: CALL_OW 44
 717: PPUSH
 718: LD_EXP 2
 722: PPUSH
 723: CALL_OW 52
// end ;
 727: GO 695
 729: POP
 730: POP
// end ;
 731: LD_VAR 0 1
 735: RET
// every 0 0$01 trigger AmBuilding ( b_warehouse ) do var i , b , p , v , filter , un ;
 736: LD_INT 1
 738: PPUSH
 739: CALL 3010 0 1
 743: IFFALSE 2424
 745: GO 747
 747: DISABLE
 748: LD_INT 0
 750: PPUSH
 751: PPUSH
 752: PPUSH
 753: PPUSH
 754: PPUSH
 755: PPUSH
// begin enable ;
 756: ENABLE
// FilterUS ( ) ;
 757: CALL 3058 0 0
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] ] ) and GetDistUnitToSide ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] , 2 ) > 21 then
 761: LD_INT 22
 763: PUSH
 764: LD_INT 1
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 34
 773: PUSH
 774: LD_INT 12
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PPUSH
 785: CALL_OW 69
 789: PUSH
 790: LD_INT 22
 792: PUSH
 793: LD_INT 1
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: PUSH
 800: LD_INT 34
 802: PUSH
 803: LD_INT 12
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PPUSH
 814: CALL_OW 69
 818: PUSH
 819: LD_INT 1
 821: ARRAY
 822: PPUSH
 823: LD_INT 2
 825: PPUSH
 826: CALL 10337 0 2
 830: PUSH
 831: LD_INT 21
 833: GREATER
 834: AND
 835: IFFALSE 844
// CollectCrates ( am_crates_spawn ) ;
 837: LD_INT 3
 839: PPUSH
 840: CALL 3552 0 1
// if UnitFilter ( us_buildings , [ f_not , [ f_lives , 1000 ] ] ) diff us_force and us_eng > 0 then
 844: LD_EXP 16
 848: PPUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 1000
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: PPUSH
 866: CALL_OW 72
 870: PUSH
 871: LD_EXP 10
 875: DIFF
 876: PUSH
 877: LD_EXP 12
 881: PUSH
 882: LD_INT 0
 884: GREATER
 885: AND
 886: IFFALSE 1010
// begin for i = 1 to us_eng do
 888: LD_ADDR_VAR 0 1
 892: PUSH
 893: DOUBLE
 894: LD_INT 1
 896: DEC
 897: ST_TO_ADDR
 898: LD_EXP 12
 902: PUSH
 903: FOR_TO
 904: IFFALSE 1006
// begin if IsInUnit ( us_eng [ i ] ) then
 906: LD_EXP 12
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 310
 921: IFFALSE 940
// ComExitBuilding ( us_eng [ i ] ) else
 923: LD_EXP 12
 927: PUSH
 928: LD_VAR 0 1
 932: ARRAY
 933: PPUSH
 934: CALL_OW 122
 938: GO 1004
// if not HasTask ( us_eng [ i ] ) then
 940: LD_EXP 12
 944: PUSH
 945: LD_VAR 0 1
 949: ARRAY
 950: PPUSH
 951: CALL_OW 314
 955: NOT
 956: IFFALSE 1004
// ComRepairBuilding ( us_eng [ i ] , UnitFilter ( us_buildings , [ f_not , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
 958: LD_EXP 12
 962: PUSH
 963: LD_VAR 0 1
 967: ARRAY
 968: PPUSH
 969: LD_EXP 16
 973: PPUSH
 974: LD_INT 3
 976: PUSH
 977: LD_INT 24
 979: PUSH
 980: LD_INT 1000
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: PPUSH
 991: CALL_OW 72
 995: PUSH
 996: LD_INT 1
 998: ARRAY
 999: PPUSH
1000: CALL_OW 130
// end ;
1004: GO 903
1006: POP
1007: POP
// end else
1008: GO 1185
// begin for i = 1 to us_eng do
1010: LD_ADDR_VAR 0 1
1014: PUSH
1015: DOUBLE
1016: LD_INT 1
1018: DEC
1019: ST_TO_ADDR
1020: LD_EXP 12
1024: PUSH
1025: FOR_TO
1026: IFFALSE 1183
// begin if us_blist = 0 and not HasTask ( us_eng [ i ] ) and not IsInUnit ( us_eng [ i ] ) then
1028: LD_EXP 19
1032: PUSH
1033: LD_INT 0
1035: EQUAL
1036: PUSH
1037: LD_EXP 12
1041: PUSH
1042: LD_VAR 0 1
1046: ARRAY
1047: PPUSH
1048: CALL_OW 314
1052: NOT
1053: AND
1054: PUSH
1055: LD_EXP 12
1059: PUSH
1060: LD_VAR 0 1
1064: ARRAY
1065: PPUSH
1066: CALL_OW 310
1070: NOT
1071: AND
1072: IFFALSE 1096
// ComEnterUnit ( us_eng [ i ] , us_depot ) else
1074: LD_EXP 12
1078: PUSH
1079: LD_VAR 0 1
1083: ARRAY
1084: PPUSH
1085: LD_EXP 2
1089: PPUSH
1090: CALL_OW 120
1094: GO 1181
// if us_blist > 0 and GetDistUnitToSide ( us_eng [ i ] , 2 ) > 20 then
1096: LD_EXP 19
1100: PUSH
1101: LD_INT 0
1103: GREATER
1104: PUSH
1105: LD_EXP 12
1109: PUSH
1110: LD_VAR 0 1
1114: ARRAY
1115: PPUSH
1116: LD_INT 2
1118: PPUSH
1119: CALL 10337 0 2
1123: PUSH
1124: LD_INT 20
1126: GREATER
1127: AND
1128: IFFALSE 1181
// ComBuild ( us_eng [ i ] , us_blist [ 1 ] , us_blist [ 2 ] , us_blist [ 3 ] , us_blist [ 4 ] ) ;
1130: LD_EXP 12
1134: PUSH
1135: LD_VAR 0 1
1139: ARRAY
1140: PPUSH
1141: LD_EXP 19
1145: PUSH
1146: LD_INT 1
1148: ARRAY
1149: PPUSH
1150: LD_EXP 19
1154: PUSH
1155: LD_INT 2
1157: ARRAY
1158: PPUSH
1159: LD_EXP 19
1163: PUSH
1164: LD_INT 3
1166: ARRAY
1167: PPUSH
1168: LD_EXP 19
1172: PUSH
1173: LD_INT 4
1175: ARRAY
1176: PPUSH
1177: CALL_OW 145
// end ;
1181: GO 1025
1183: POP
1184: POP
// end ; if UnitFilter ( us_humans , [ f_not , [ f_lives , 800 ] ] ) diff us_force and us_sci > 0 then
1185: LD_EXP 18
1189: PPUSH
1190: LD_INT 3
1192: PUSH
1193: LD_INT 24
1195: PUSH
1196: LD_INT 800
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PPUSH
1207: CALL_OW 72
1211: PUSH
1212: LD_EXP 10
1216: DIFF
1217: PUSH
1218: LD_EXP 14
1222: PUSH
1223: LD_INT 0
1225: GREATER
1226: AND
1227: IFFALSE 1502
// begin if GetDistUnits ( us_depot , UnitFilter ( us_humans , [ f_not , [ f_lives , 800 ] ] ) [ 1 ] ) > 10 then
1229: LD_EXP 2
1233: PPUSH
1234: LD_EXP 18
1238: PPUSH
1239: LD_INT 3
1241: PUSH
1242: LD_INT 24
1244: PUSH
1245: LD_INT 800
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: PPUSH
1256: CALL_OW 72
1260: PUSH
1261: LD_INT 1
1263: ARRAY
1264: PPUSH
1265: CALL_OW 296
1269: PUSH
1270: LD_INT 10
1272: GREATER
1273: IFFALSE 1334
// ComMoveXY ( UnitFilter ( us_humans , [ f_not , [ f_lives , 800 ] ] ) [ 1 ] , GetX ( us_depot ) - 2 , GetY ( us_depot ) ) ;
1275: LD_EXP 18
1279: PPUSH
1280: LD_INT 3
1282: PUSH
1283: LD_INT 24
1285: PUSH
1286: LD_INT 800
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: PPUSH
1297: CALL_OW 72
1301: PUSH
1302: LD_INT 1
1304: ARRAY
1305: PPUSH
1306: LD_EXP 2
1310: PPUSH
1311: CALL_OW 250
1315: PUSH
1316: LD_INT 2
1318: MINUS
1319: PPUSH
1320: LD_EXP 2
1324: PPUSH
1325: CALL_OW 251
1329: PPUSH
1330: CALL_OW 111
// if us_sci < 4 then
1334: LD_EXP 14
1338: PUSH
1339: LD_INT 4
1341: LESS
1342: IFFALSE 1356
// p := us_sci else
1344: LD_ADDR_VAR 0 3
1348: PUSH
1349: LD_EXP 14
1353: ST_TO_ADDR
1354: GO 1380
// if us_sci >= 4 then
1356: LD_EXP 14
1360: PUSH
1361: LD_INT 4
1363: GREATEREQUAL
1364: IFFALSE 1380
// p := us_sci / 2 ;
1366: LD_ADDR_VAR 0 3
1370: PUSH
1371: LD_EXP 14
1375: PUSH
1376: LD_INT 2
1378: DIVREAL
1379: ST_TO_ADDR
// for i = 1 to p do
1380: LD_ADDR_VAR 0 1
1384: PUSH
1385: DOUBLE
1386: LD_INT 1
1388: DEC
1389: ST_TO_ADDR
1390: LD_VAR 0 3
1394: PUSH
1395: FOR_TO
1396: IFFALSE 1498
// begin if IsInUnit ( us_sci [ i ] ) then
1398: LD_EXP 14
1402: PUSH
1403: LD_VAR 0 1
1407: ARRAY
1408: PPUSH
1409: CALL_OW 310
1413: IFFALSE 1432
// ComExitBuilding ( us_sci [ i ] ) else
1415: LD_EXP 14
1419: PUSH
1420: LD_VAR 0 1
1424: ARRAY
1425: PPUSH
1426: CALL_OW 122
1430: GO 1496
// if not HasTask ( us_sci [ i ] ) then
1432: LD_EXP 14
1436: PUSH
1437: LD_VAR 0 1
1441: ARRAY
1442: PPUSH
1443: CALL_OW 314
1447: NOT
1448: IFFALSE 1496
// ComHeal ( us_sci [ i ] , UnitFilter ( us_humans , [ f_not , [ f_lives , 800 ] ] ) [ 1 ] ) ;
1450: LD_EXP 14
1454: PUSH
1455: LD_VAR 0 1
1459: ARRAY
1460: PPUSH
1461: LD_EXP 18
1465: PPUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 24
1471: PUSH
1472: LD_INT 800
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: PPUSH
1483: CALL_OW 72
1487: PUSH
1488: LD_INT 1
1490: ARRAY
1491: PPUSH
1492: CALL_OW 128
// end ;
1496: GO 1395
1498: POP
1499: POP
// end else
1500: GO 1601
// begin for i = 1 to us_sci do
1502: LD_ADDR_VAR 0 1
1506: PUSH
1507: DOUBLE
1508: LD_INT 1
1510: DEC
1511: ST_TO_ADDR
1512: LD_EXP 14
1516: PUSH
1517: FOR_TO
1518: IFFALSE 1599
// if not HasTask ( us_sci [ i ] ) and not IsInUnit ( us_sci [ i ] ) then
1520: LD_EXP 14
1524: PUSH
1525: LD_VAR 0 1
1529: ARRAY
1530: PPUSH
1531: CALL_OW 314
1535: NOT
1536: PUSH
1537: LD_EXP 14
1541: PUSH
1542: LD_VAR 0 1
1546: ARRAY
1547: PPUSH
1548: CALL_OW 310
1552: NOT
1553: AND
1554: IFFALSE 1597
// ComEnterUnit ( us_sci [ i ] , [ us_lab1 , us_lab2 ] [ Rand ( 1 , 2 ) ] ) ;
1556: LD_EXP 14
1560: PUSH
1561: LD_VAR 0 1
1565: ARRAY
1566: PPUSH
1567: LD_EXP 3
1571: PUSH
1572: LD_EXP 4
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: PUSH
1581: LD_INT 1
1583: PPUSH
1584: LD_INT 2
1586: PPUSH
1587: CALL_OW 12
1591: ARRAY
1592: PPUSH
1593: CALL_OW 120
1597: GO 1517
1599: POP
1600: POP
// end ; if UnitsInside ( us_ct ) < 3 then
1601: LD_EXP 7
1605: PPUSH
1606: CALL_OW 313
1610: PUSH
1611: LD_INT 3
1613: LESS
1614: IFFALSE 1722
// begin filter := us_mech diff UnitsInside ( us_ct ) ;
1616: LD_ADDR_VAR 0 5
1620: PUSH
1621: LD_EXP 13
1625: PUSH
1626: LD_EXP 7
1630: PPUSH
1631: CALL_OW 313
1635: DIFF
1636: ST_TO_ADDR
// for i = 1 to ( 3 - UnitsInside ( us_ct ) ) do
1637: LD_ADDR_VAR 0 1
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_INT 3
1649: PUSH
1650: LD_EXP 7
1654: PPUSH
1655: CALL_OW 313
1659: MINUS
1660: PUSH
1661: FOR_TO
1662: IFFALSE 1720
// if IsInUnit ( filter [ i ] ) then
1664: LD_VAR 0 5
1668: PUSH
1669: LD_VAR 0 1
1673: ARRAY
1674: PPUSH
1675: CALL_OW 310
1679: IFFALSE 1698
// ComExitBuilding ( filter [ i ] ) else
1681: LD_VAR 0 5
1685: PUSH
1686: LD_VAR 0 1
1690: ARRAY
1691: PPUSH
1692: CALL_OW 122
1696: GO 1718
// ComEnterUnit ( filter [ i ] , us_ct ) ;
1698: LD_VAR 0 5
1702: PUSH
1703: LD_VAR 0 1
1707: ARRAY
1708: PPUSH
1709: LD_EXP 7
1713: PPUSH
1714: CALL_OW 120
1718: GO 1661
1720: POP
1721: POP
// end ; if UnitFilter ( us_vehicles , [ f_control , control_remote ] ) and us_ct then
1722: LD_EXP 17
1726: PPUSH
1727: LD_INT 33
1729: PUSH
1730: LD_INT 2
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: PPUSH
1737: CALL_OW 72
1741: PUSH
1742: LD_EXP 7
1746: AND
1747: IFFALSE 1985
// begin filter = FilterAllUnits ( [ [ f_side , 1 ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_INT 22
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: EMPTY
1761: LIST
1762: LIST
1763: PUSH
1764: LD_INT 33
1766: PUSH
1767: LD_INT 2
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_INT 50
1776: PUSH
1777: EMPTY
1778: LIST
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: PPUSH
1785: CALL_OW 69
1789: ST_TO_ADDR
// for v in filter do
1790: LD_ADDR_VAR 0 4
1794: PUSH
1795: LD_VAR 0 5
1799: PUSH
1800: FOR_IN
1801: IFFALSE 1983
// begin if not IsControledBy ( v ) and IsOk ( v ) then
1803: LD_VAR 0 4
1807: PPUSH
1808: CALL_OW 312
1812: NOT
1813: PUSH
1814: LD_VAR 0 4
1818: PPUSH
1819: CALL_OW 302
1823: AND
1824: IFFALSE 1849
// ComLinkTo ( v , UnitsInside ( us_ct ) [ 1 ] ) ;
1826: LD_VAR 0 4
1830: PPUSH
1831: LD_EXP 7
1835: PPUSH
1836: CALL_OW 313
1840: PUSH
1841: LD_INT 1
1843: ARRAY
1844: PPUSH
1845: CALL_OW 135
// if UnitsLinked ( UnitsInside ( us_ct ) [ 1 ] ) >= GetSkill ( UnitsInside ( us_ct ) [ 1 ] , 3 ) then
1849: LD_EXP 7
1853: PPUSH
1854: CALL_OW 313
1858: PUSH
1859: LD_INT 1
1861: ARRAY
1862: PPUSH
1863: CALL_OW 432
1867: PUSH
1868: LD_EXP 7
1872: PPUSH
1873: CALL_OW 313
1877: PUSH
1878: LD_INT 1
1880: ARRAY
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: CALL_OW 259
1889: GREATEREQUAL
1890: IFFALSE 1915
// ComLinkTo ( v , UnitsInside ( us_ct ) [ 2 ] ) ;
1892: LD_VAR 0 4
1896: PPUSH
1897: LD_EXP 7
1901: PPUSH
1902: CALL_OW 313
1906: PUSH
1907: LD_INT 2
1909: ARRAY
1910: PPUSH
1911: CALL_OW 135
// if UnitsLinked ( UnitsInside ( us_ct ) [ 2 ] ) >= GetSkill ( UnitsInside ( us_ct ) [ 2 ] , 3 ) then
1915: LD_EXP 7
1919: PPUSH
1920: CALL_OW 313
1924: PUSH
1925: LD_INT 2
1927: ARRAY
1928: PPUSH
1929: CALL_OW 432
1933: PUSH
1934: LD_EXP 7
1938: PPUSH
1939: CALL_OW 313
1943: PUSH
1944: LD_INT 2
1946: ARRAY
1947: PPUSH
1948: LD_INT 3
1950: PPUSH
1951: CALL_OW 259
1955: GREATEREQUAL
1956: IFFALSE 1981
// ComLinkTo ( v , UnitsInside ( us_ct ) [ 3 ] ) ;
1958: LD_VAR 0 4
1962: PPUSH
1963: LD_EXP 7
1967: PPUSH
1968: CALL_OW 313
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PPUSH
1977: CALL_OW 135
// end ;
1981: GO 1800
1983: POP
1984: POP
// end ; if us_factory then
1985: LD_EXP 6
1989: IFFALSE 2147
// begin if us_vlist > 0 and BuildingStatus ( us_factory ) = bs_idle then
1991: LD_EXP 20
1995: PUSH
1996: LD_INT 0
1998: GREATER
1999: PUSH
2000: LD_EXP 6
2004: PPUSH
2005: CALL_OW 461
2009: PUSH
2010: LD_INT 2
2012: EQUAL
2013: AND
2014: IFFALSE 2061
// ComConstruct ( us_factory , us_vlist [ 1 ] , us_vlist [ 2 ] , us_vlist [ 3 ] , us_vlist [ 4 ] ) ;
2016: LD_EXP 6
2020: PPUSH
2021: LD_EXP 20
2025: PUSH
2026: LD_INT 1
2028: ARRAY
2029: PPUSH
2030: LD_EXP 20
2034: PUSH
2035: LD_INT 2
2037: ARRAY
2038: PPUSH
2039: LD_EXP 20
2043: PUSH
2044: LD_INT 3
2046: ARRAY
2047: PPUSH
2048: LD_EXP 20
2052: PUSH
2053: LD_INT 4
2055: ARRAY
2056: PPUSH
2057: CALL_OW 125
// if UnitFilter ( us_towers , [ f_bweapon , 0 ] ) and BuildingStatus ( us_factory ) = bs_idle then
2061: LD_EXP 8
2065: PPUSH
2066: LD_INT 35
2068: PUSH
2069: LD_INT 0
2071: PUSH
2072: EMPTY
2073: LIST
2074: LIST
2075: PPUSH
2076: CALL_OW 72
2080: PUSH
2081: LD_EXP 6
2085: PPUSH
2086: CALL_OW 461
2090: PUSH
2091: LD_INT 2
2093: EQUAL
2094: AND
2095: IFFALSE 2147
// ComPlaceWeapon ( UnitFilter ( us_towers , [ f_bweapon , 0 ] ) [ 1 ] , [ us_heavy_gun , us_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
2097: LD_EXP 8
2101: PPUSH
2102: LD_INT 35
2104: PUSH
2105: LD_INT 0
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: PPUSH
2112: CALL_OW 72
2116: PUSH
2117: LD_INT 1
2119: ARRAY
2120: PPUSH
2121: LD_INT 6
2123: PUSH
2124: LD_INT 7
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 1
2133: PPUSH
2134: LD_INT 2
2136: PPUSH
2137: CALL_OW 12
2141: ARRAY
2142: PPUSH
2143: CALL_OW 148
// end ; if UnitFilter ( us_sold , [ f_not , [ f_inside ] ] ) diff us_force then
2147: LD_EXP 11
2151: PPUSH
2152: LD_INT 3
2154: PUSH
2155: LD_INT 54
2157: PUSH
2158: EMPTY
2159: LIST
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: PPUSH
2165: CALL_OW 72
2169: PUSH
2170: LD_EXP 10
2174: DIFF
2175: IFFALSE 2424
// begin filter := UnitFilter ( us_sold , [ f_not , [ f_inside ] ] ) diff us_force ;
2177: LD_ADDR_VAR 0 5
2181: PUSH
2182: LD_EXP 11
2186: PPUSH
2187: LD_INT 3
2189: PUSH
2190: LD_INT 54
2192: PUSH
2193: EMPTY
2194: LIST
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: PPUSH
2200: CALL_OW 72
2204: PUSH
2205: LD_EXP 10
2209: DIFF
2210: ST_TO_ADDR
// for i = 1 to filter do
2211: LD_ADDR_VAR 0 1
2215: PUSH
2216: DOUBLE
2217: LD_INT 1
2219: DEC
2220: ST_TO_ADDR
2221: LD_VAR 0 5
2225: PUSH
2226: FOR_TO
2227: IFFALSE 2422
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) = 0 then
2229: LD_INT 22
2231: PUSH
2232: LD_INT 1
2234: PUSH
2235: EMPTY
2236: LIST
2237: LIST
2238: PUSH
2239: LD_INT 30
2241: PUSH
2242: LD_INT 32
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: LD_INT 50
2251: PUSH
2252: EMPTY
2253: LIST
2254: PUSH
2255: LD_INT 58
2257: PUSH
2258: EMPTY
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: LIST
2265: LIST
2266: PPUSH
2267: CALL_OW 69
2271: PUSH
2272: LD_INT 0
2274: EQUAL
2275: IFFALSE 2344
// begin if GetDistUnits ( filter [ i ] , us_depot ) > 10 then
2277: LD_VAR 0 5
2281: PUSH
2282: LD_VAR 0 1
2286: ARRAY
2287: PPUSH
2288: LD_EXP 2
2292: PPUSH
2293: CALL_OW 296
2297: PUSH
2298: LD_INT 10
2300: GREATER
2301: IFFALSE 2342
// ComMoveXY ( filter [ i ] , GetX ( us_depot ) - 2 , GetY ( us_depot ) ) ;
2303: LD_VAR 0 5
2307: PUSH
2308: LD_VAR 0 1
2312: ARRAY
2313: PPUSH
2314: LD_EXP 2
2318: PPUSH
2319: CALL_OW 250
2323: PUSH
2324: LD_INT 2
2326: MINUS
2327: PPUSH
2328: LD_EXP 2
2332: PPUSH
2333: CALL_OW 251
2337: PPUSH
2338: CALL_OW 111
// end else
2342: GO 2420
// if not HasTask ( filter [ 1 ] ) then
2344: LD_VAR 0 5
2348: PUSH
2349: LD_INT 1
2351: ARRAY
2352: PPUSH
2353: CALL_OW 314
2357: NOT
2358: IFFALSE 2420
// ComEnterUnit ( filter [ 1 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) [ 1 ] ) ;
2360: LD_VAR 0 5
2364: PUSH
2365: LD_INT 1
2367: ARRAY
2368: PPUSH
2369: LD_INT 22
2371: PUSH
2372: LD_INT 1
2374: PUSH
2375: EMPTY
2376: LIST
2377: LIST
2378: PUSH
2379: LD_INT 30
2381: PUSH
2382: LD_INT 32
2384: PUSH
2385: EMPTY
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 50
2391: PUSH
2392: EMPTY
2393: LIST
2394: PUSH
2395: LD_INT 58
2397: PUSH
2398: EMPTY
2399: LIST
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 69
2411: PUSH
2412: LD_INT 1
2414: ARRAY
2415: PPUSH
2416: CALL_OW 120
2420: GO 2226
2422: POP
2423: POP
// end ; end ;
2424: PPOPN 6
2426: END
// every 0 0$01 trigger us_force do var i , un , filter , x , y , r ;
2427: LD_EXP 10
2431: IFFALSE 3007
2433: GO 2435
2435: DISABLE
2436: LD_INT 0
2438: PPUSH
2439: PPUSH
2440: PPUSH
2441: PPUSH
2442: PPUSH
2443: PPUSH
// begin enable ;
2444: ENABLE
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
2445: LD_ADDR_VAR 0 3
2449: PUSH
2450: LD_INT 22
2452: PUSH
2453: LD_INT 2
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: PPUSH
2460: CALL_OW 69
2464: ST_TO_ADDR
// x := [ 77 , 59 , 43 , 27 ] ;
2465: LD_ADDR_VAR 0 4
2469: PUSH
2470: LD_INT 77
2472: PUSH
2473: LD_INT 59
2475: PUSH
2476: LD_INT 43
2478: PUSH
2479: LD_INT 27
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// y := [ 41 , 31 , 28 , 28 ] ;
2488: LD_ADDR_VAR 0 5
2492: PUSH
2493: LD_INT 41
2495: PUSH
2496: LD_INT 31
2498: PUSH
2499: LD_INT 28
2501: PUSH
2502: LD_INT 28
2504: PUSH
2505: EMPTY
2506: LIST
2507: LIST
2508: LIST
2509: LIST
2510: ST_TO_ADDR
// if us_attack = 0 then
2511: LD_EXP 23
2515: PUSH
2516: LD_INT 0
2518: EQUAL
2519: IFFALSE 2579
// begin for i = 1 to us_force do
2521: LD_ADDR_VAR 0 1
2525: PUSH
2526: DOUBLE
2527: LD_INT 1
2529: DEC
2530: ST_TO_ADDR
2531: LD_EXP 10
2535: PUSH
2536: FOR_TO
2537: IFFALSE 2577
// if not HasTask ( us_force [ i ] ) then
2539: LD_EXP 10
2543: PUSH
2544: LD_VAR 0 1
2548: ARRAY
2549: PPUSH
2550: CALL_OW 314
2554: NOT
2555: IFFALSE 2575
// ComMoveToArea ( us_force [ i ] , standby ) ;
2557: LD_EXP 10
2561: PUSH
2562: LD_VAR 0 1
2566: ARRAY
2567: PPUSH
2568: LD_INT 9
2570: PPUSH
2571: CALL_OW 113
2575: GO 2536
2577: POP
2578: POP
// end ; if us_attack = 1 then
2579: LD_EXP 23
2583: PUSH
2584: LD_INT 1
2586: EQUAL
2587: IFFALSE 2664
// begin for i = 1 to us_force do
2589: LD_ADDR_VAR 0 1
2593: PUSH
2594: DOUBLE
2595: LD_INT 1
2597: DEC
2598: ST_TO_ADDR
2599: LD_EXP 10
2603: PUSH
2604: FOR_TO
2605: IFFALSE 2662
// if IsOk ( us_force [ i ] ) then
2607: LD_EXP 10
2611: PUSH
2612: LD_VAR 0 1
2616: ARRAY
2617: PPUSH
2618: CALL_OW 302
2622: IFFALSE 2660
// ComAttackUnit ( us_force [ i ] , NearestUnitToUnit ( filter , us_force [ i ] ) ) ;
2624: LD_EXP 10
2628: PUSH
2629: LD_VAR 0 1
2633: ARRAY
2634: PPUSH
2635: LD_VAR 0 3
2639: PPUSH
2640: LD_EXP 10
2644: PUSH
2645: LD_VAR 0 1
2649: ARRAY
2650: PPUSH
2651: CALL_OW 74
2655: PPUSH
2656: CALL_OW 115
2660: GO 2604
2662: POP
2663: POP
// end ; if us_attack = 2 then
2664: LD_EXP 23
2668: PUSH
2669: LD_INT 2
2671: EQUAL
2672: IFFALSE 3007
// begin for i = 1 to us_force do
2674: LD_ADDR_VAR 0 1
2678: PUSH
2679: DOUBLE
2680: LD_INT 1
2682: DEC
2683: ST_TO_ADDR
2684: LD_EXP 10
2688: PUSH
2689: FOR_TO
2690: IFFALSE 3005
// begin if not IsInArea ( us_force [ i ] , defff ) and not HasTask ( us_force [ i ] ) then
2692: LD_EXP 10
2696: PUSH
2697: LD_VAR 0 1
2701: ARRAY
2702: PPUSH
2703: LD_INT 10
2705: PPUSH
2706: CALL_OW 308
2710: NOT
2711: PUSH
2712: LD_EXP 10
2716: PUSH
2717: LD_VAR 0 1
2721: ARRAY
2722: PPUSH
2723: CALL_OW 314
2727: NOT
2728: AND
2729: IFFALSE 2749
// ComMoveToArea ( us_force [ i ] , defff ) ;
2731: LD_EXP 10
2735: PUSH
2736: LD_VAR 0 1
2740: ARRAY
2741: PPUSH
2742: LD_INT 10
2744: PPUSH
2745: CALL_OW 113
// if IsInArea ( us_force [ i ] , defff ) and not HasTask ( us_force [ i ] ) and ( GetDir ( us_force [ i ] ) < 2 and GetDir ( us_force [ i ] ) > 3 ) then
2749: LD_EXP 10
2753: PUSH
2754: LD_VAR 0 1
2758: ARRAY
2759: PPUSH
2760: LD_INT 10
2762: PPUSH
2763: CALL_OW 308
2767: PUSH
2768: LD_EXP 10
2772: PUSH
2773: LD_VAR 0 1
2777: ARRAY
2778: PPUSH
2779: CALL_OW 314
2783: NOT
2784: AND
2785: PUSH
2786: LD_EXP 10
2790: PUSH
2791: LD_VAR 0 1
2795: ARRAY
2796: PPUSH
2797: CALL_OW 254
2801: PUSH
2802: LD_INT 2
2804: LESS
2805: PUSH
2806: LD_EXP 10
2810: PUSH
2811: LD_VAR 0 1
2815: ARRAY
2816: PPUSH
2817: CALL_OW 254
2821: PUSH
2822: LD_INT 3
2824: GREATER
2825: AND
2826: AND
2827: IFFALSE 2850
// begin ComTurnXY ( us_force [ i ] , 86 , 117 ) ;
2829: LD_EXP 10
2833: PUSH
2834: LD_VAR 0 1
2838: ARRAY
2839: PPUSH
2840: LD_INT 86
2842: PPUSH
2843: LD_INT 117
2845: PPUSH
2846: CALL_OW 118
// end ; if GetDistUnitArea ( us_force [ i ] , defff ) > 10 then
2850: LD_EXP 10
2854: PUSH
2855: LD_VAR 0 1
2859: ARRAY
2860: PPUSH
2861: LD_INT 10
2863: PPUSH
2864: CALL_OW 299
2868: PUSH
2869: LD_INT 10
2871: GREATER
2872: IFFALSE 2929
// begin r := Rand ( 1 , 4 ) ;
2874: LD_ADDR_VAR 0 6
2878: PUSH
2879: LD_INT 1
2881: PPUSH
2882: LD_INT 4
2884: PPUSH
2885: CALL_OW 12
2889: ST_TO_ADDR
// ComMoveXY ( us_force [ i ] , x [ r ] , y [ r ] ) ;
2890: LD_EXP 10
2894: PUSH
2895: LD_VAR 0 1
2899: ARRAY
2900: PPUSH
2901: LD_VAR 0 4
2905: PUSH
2906: LD_VAR 0 6
2910: ARRAY
2911: PPUSH
2912: LD_VAR 0 5
2916: PUSH
2917: LD_VAR 0 6
2921: ARRAY
2922: PPUSH
2923: CALL_OW 111
// end else
2927: GO 3003
// if See ( 2 , us_force [ i ] ) and not HasTask ( us_force [ i ] ) then
2929: LD_INT 2
2931: PPUSH
2932: LD_EXP 10
2936: PUSH
2937: LD_VAR 0 1
2941: ARRAY
2942: PPUSH
2943: CALL_OW 292
2947: PUSH
2948: LD_EXP 10
2952: PUSH
2953: LD_VAR 0 1
2957: ARRAY
2958: PPUSH
2959: CALL_OW 314
2963: NOT
2964: AND
2965: IFFALSE 3003
// ComAttackUnit ( us_force [ i ] , NearestUnitToUnit ( filter , us_force [ i ] ) ) ;
2967: LD_EXP 10
2971: PUSH
2972: LD_VAR 0 1
2976: ARRAY
2977: PPUSH
2978: LD_VAR 0 3
2982: PPUSH
2983: LD_EXP 10
2987: PUSH
2988: LD_VAR 0 1
2992: ARRAY
2993: PPUSH
2994: CALL_OW 74
2998: PPUSH
2999: CALL_OW 115
// end ;
3003: GO 2689
3005: POP
3006: POP
// end ; end ;
3007: PPOPN 6
3009: END
// function AmBuilding ( btype ) ; begin
3010: LD_INT 0
3012: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , btype ] ] ) [ 1 ] ;
3013: LD_ADDR_VAR 0 2
3017: PUSH
3018: LD_INT 22
3020: PUSH
3021: LD_INT 1
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: PUSH
3028: LD_INT 30
3030: PUSH
3031: LD_VAR 0 1
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PPUSH
3044: CALL_OW 69
3048: PUSH
3049: LD_INT 1
3051: ARRAY
3052: ST_TO_ADDR
// end ;
3053: LD_VAR 0 2
3057: RET
// function FilterUS ( ) ; begin
3058: LD_INT 0
3060: PPUSH
// us_humans := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
3061: LD_ADDR_EXP 18
3065: PUSH
3066: LD_INT 22
3068: PUSH
3069: LD_INT 1
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: PUSH
3076: LD_INT 21
3078: PUSH
3079: LD_INT 1
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL_OW 69
3094: ST_TO_ADDR
// us_vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
3095: LD_ADDR_EXP 17
3099: PUSH
3100: LD_INT 22
3102: PUSH
3103: LD_INT 1
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: LD_INT 21
3112: PUSH
3113: LD_INT 2
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: PPUSH
3124: CALL_OW 69
3128: ST_TO_ADDR
// us_buildings := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) ;
3129: LD_ADDR_EXP 16
3133: PUSH
3134: LD_INT 22
3136: PUSH
3137: LD_INT 1
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 21
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: PPUSH
3158: CALL_OW 69
3162: ST_TO_ADDR
// us_depot := AmBuilding ( b_warehouse ) ;
3163: LD_ADDR_EXP 2
3167: PUSH
3168: LD_INT 1
3170: PPUSH
3171: CALL 3010 0 1
3175: ST_TO_ADDR
// us_factory := AmBuilding ( b_factory ) ;
3176: LD_ADDR_EXP 6
3180: PUSH
3181: LD_INT 3
3183: PPUSH
3184: CALL 3010 0 1
3188: ST_TO_ADDR
// us_ct := AmBuilding ( b_control_tower ) ;
3189: LD_ADDR_EXP 7
3193: PUSH
3194: LD_INT 36
3196: PPUSH
3197: CALL 3010 0 1
3201: ST_TO_ADDR
// us_barracks := AmBuilding ( b_barracks ) ;
3202: LD_ADDR_EXP 5
3206: PUSH
3207: LD_INT 5
3209: PPUSH
3210: CALL 3010 0 1
3214: ST_TO_ADDR
// us_towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
3215: LD_ADDR_EXP 8
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 2
3232: PUSH
3233: LD_INT 30
3235: PUSH
3236: LD_INT 33
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: PUSH
3243: LD_INT 30
3245: PUSH
3246: LD_INT 32
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PPUSH
3262: CALL_OW 69
3266: ST_TO_ADDR
// us_bunkers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
3267: LD_ADDR_EXP 9
3271: PUSH
3272: LD_INT 22
3274: PUSH
3275: LD_INT 1
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 30
3284: PUSH
3285: LD_INT 31
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PPUSH
3296: CALL_OW 69
3300: ST_TO_ADDR
// us_lab1 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
3301: LD_ADDR_EXP 3
3305: PUSH
3306: LD_INT 22
3308: PUSH
3309: LD_INT 1
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: LD_INT 30
3318: PUSH
3319: LD_INT 8
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PPUSH
3330: CALL_OW 69
3334: PUSH
3335: LD_INT 1
3337: ARRAY
3338: ST_TO_ADDR
// us_lab2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_lab_full ] ] ) [ 2 ] ;
3339: LD_ADDR_EXP 4
3343: PUSH
3344: LD_INT 22
3346: PUSH
3347: LD_INT 1
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: LD_INT 30
3356: PUSH
3357: LD_INT 8
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: PUSH
3364: EMPTY
3365: LIST
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: PUSH
3373: LD_INT 2
3375: ARRAY
3376: ST_TO_ADDR
// us_sold := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
3377: LD_ADDR_EXP 11
3381: PUSH
3382: LD_INT 22
3384: PUSH
3385: LD_INT 1
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 25
3394: PUSH
3395: LD_INT 1
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: PPUSH
3406: CALL_OW 69
3410: ST_TO_ADDR
// us_eng := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
3411: LD_ADDR_EXP 12
3415: PUSH
3416: LD_INT 22
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 25
3428: PUSH
3429: LD_INT 2
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: PPUSH
3440: CALL_OW 69
3444: ST_TO_ADDR
// us_mech := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] ] ) ;
3445: LD_ADDR_EXP 13
3449: PUSH
3450: LD_INT 22
3452: PUSH
3453: LD_INT 1
3455: PUSH
3456: EMPTY
3457: LIST
3458: LIST
3459: PUSH
3460: LD_INT 25
3462: PUSH
3463: LD_INT 3
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: PUSH
3470: EMPTY
3471: LIST
3472: LIST
3473: PPUSH
3474: CALL_OW 69
3478: ST_TO_ADDR
// us_sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3479: LD_ADDR_EXP 14
3483: PUSH
3484: LD_INT 22
3486: PUSH
3487: LD_INT 1
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: PUSH
3494: LD_INT 25
3496: PUSH
3497: LD_INT 4
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: PPUSH
3508: CALL_OW 69
3512: ST_TO_ADDR
// us_snip := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 5 ] ] ) ;
3513: LD_ADDR_EXP 15
3517: PUSH
3518: LD_INT 22
3520: PUSH
3521: LD_INT 1
3523: PUSH
3524: EMPTY
3525: LIST
3526: LIST
3527: PUSH
3528: LD_INT 25
3530: PUSH
3531: LD_INT 5
3533: PUSH
3534: EMPTY
3535: LIST
3536: LIST
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: PPUSH
3542: CALL_OW 69
3546: ST_TO_ADDR
// end ;
3547: LD_VAR 0 1
3551: RET
// function CollectCrates ( area ) ; var c , skr , p , cargo , filter ; begin
3552: LD_INT 0
3554: PPUSH
3555: PPUSH
3556: PPUSH
3557: PPUSH
3558: PPUSH
3559: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
3560: LD_ADDR_VAR 0 4
3564: PUSH
3565: LD_VAR 0 1
3569: PPUSH
3570: CALL_OW 435
3574: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] ] ) ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 22
3582: PUSH
3583: LD_INT 1
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PUSH
3590: LD_INT 34
3592: PUSH
3593: LD_INT 12
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PPUSH
3604: CALL_OW 69
3608: ST_TO_ADDR
// c = 1 ;
3609: LD_ADDR_VAR 0 3
3613: PUSH
3614: LD_INT 1
3616: ST_TO_ADDR
// while c < skr do
3617: LD_VAR 0 3
3621: PUSH
3622: LD_VAR 0 4
3626: LESS
3627: IFFALSE 4055
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] ] ) = 0 then
3629: LD_INT 22
3631: PUSH
3632: LD_INT 1
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 34
3641: PUSH
3642: LD_INT 12
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 69
3657: PUSH
3658: LD_INT 0
3660: EQUAL
3661: IFFALSE 3842
// begin for p = 1 to 2 do
3663: LD_ADDR_VAR 0 5
3667: PUSH
3668: DOUBLE
3669: LD_INT 1
3671: DEC
3672: ST_TO_ADDR
3673: LD_INT 2
3675: PUSH
3676: FOR_TO
3677: IFFALSE 3826
// if not HasTask ( filter [ p ] ) and GetDistUnitXY ( filter [ p ] , skr [ c ] , skr [ c + 1 ] ) <= 40 and GetDistXYToSide ( skr [ c ] , skr [ c + 1 ] , 2 ) > 20 then
3679: LD_VAR 0 7
3683: PUSH
3684: LD_VAR 0 5
3688: ARRAY
3689: PPUSH
3690: CALL_OW 314
3694: NOT
3695: PUSH
3696: LD_VAR 0 7
3700: PUSH
3701: LD_VAR 0 5
3705: ARRAY
3706: PPUSH
3707: LD_VAR 0 4
3711: PUSH
3712: LD_VAR 0 3
3716: ARRAY
3717: PPUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 3
3727: PUSH
3728: LD_INT 1
3730: PLUS
3731: ARRAY
3732: PPUSH
3733: CALL_OW 297
3737: PUSH
3738: LD_INT 40
3740: LESSEQUAL
3741: AND
3742: PUSH
3743: LD_VAR 0 4
3747: PUSH
3748: LD_VAR 0 3
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 4
3758: PUSH
3759: LD_VAR 0 3
3763: PUSH
3764: LD_INT 1
3766: PLUS
3767: ARRAY
3768: PPUSH
3769: LD_INT 2
3771: PPUSH
3772: CALL 10430 0 3
3776: PUSH
3777: LD_INT 20
3779: GREATER
3780: AND
3781: IFFALSE 3824
// ComCollect ( filter [ p ] , skr [ c ] , skr [ c + 1 ] ) ;
3783: LD_VAR 0 7
3787: PUSH
3788: LD_VAR 0 5
3792: ARRAY
3793: PPUSH
3794: LD_VAR 0 4
3798: PUSH
3799: LD_VAR 0 3
3803: ARRAY
3804: PPUSH
3805: LD_VAR 0 4
3809: PUSH
3810: LD_VAR 0 3
3814: PUSH
3815: LD_INT 1
3817: PLUS
3818: ARRAY
3819: PPUSH
3820: CALL_OW 117
3824: GO 3676
3826: POP
3827: POP
// c = c + 2 ;
3828: LD_ADDR_VAR 0 3
3832: PUSH
3833: LD_VAR 0 3
3837: PUSH
3838: LD_INT 2
3840: PLUS
3841: ST_TO_ADDR
// end ; if cargo > 0 then
3842: LD_VAR 0 6
3846: PUSH
3847: LD_INT 0
3849: GREATER
3850: IFFALSE 4053
// begin if GetFuel ( cargo [ 1 ] ) > 40 then
3852: LD_VAR 0 6
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: CALL_OW 261
3865: PUSH
3866: LD_INT 40
3868: GREATER
3869: IFFALSE 3951
// begin if GetDistXYToSide ( skr [ c ] , skr [ c + 1 ] , 2 ) > 20 then
3871: LD_VAR 0 4
3875: PUSH
3876: LD_VAR 0 3
3880: ARRAY
3881: PPUSH
3882: LD_VAR 0 4
3886: PUSH
3887: LD_VAR 0 3
3891: PUSH
3892: LD_INT 1
3894: PLUS
3895: ARRAY
3896: PPUSH
3897: LD_INT 2
3899: PPUSH
3900: CALL 10430 0 3
3904: PUSH
3905: LD_INT 20
3907: GREATER
3908: IFFALSE 3949
// ComCollect ( cargo [ 1 ] , skr [ c ] , skr [ c + 1 ] ) ;
3910: LD_VAR 0 6
3914: PUSH
3915: LD_INT 1
3917: ARRAY
3918: PPUSH
3919: LD_VAR 0 4
3923: PUSH
3924: LD_VAR 0 3
3928: ARRAY
3929: PPUSH
3930: LD_VAR 0 4
3934: PUSH
3935: LD_VAR 0 3
3939: PUSH
3940: LD_INT 1
3942: PLUS
3943: ARRAY
3944: PPUSH
3945: CALL_OW 117
// end else
3949: GO 4039
// begin repeat begin ComMoveXY ( cargo [ 1 ] , GetX ( us_depot [ 1 ] ) , GetY ( us_depot [ 1 ] ) ) ;
3951: LD_VAR 0 6
3955: PUSH
3956: LD_INT 1
3958: ARRAY
3959: PPUSH
3960: LD_EXP 2
3964: PUSH
3965: LD_INT 1
3967: ARRAY
3968: PPUSH
3969: CALL_OW 250
3973: PPUSH
3974: LD_EXP 2
3978: PUSH
3979: LD_INT 1
3981: ARRAY
3982: PPUSH
3983: CALL_OW 251
3987: PPUSH
3988: CALL_OW 111
// Wait ( 0 0$01 ) ;
3992: LD_INT 35
3994: PPUSH
3995: CALL_OW 67
// end until GetDistUnits ( cargo [ 1 ] , us_depot ) < 7 ;
3999: LD_VAR 0 6
4003: PUSH
4004: LD_INT 1
4006: ARRAY
4007: PPUSH
4008: LD_EXP 2
4012: PPUSH
4013: CALL_OW 296
4017: PUSH
4018: LD_INT 7
4020: LESS
4021: IFFALSE 3951
// SetFuel ( cargo [ 1 ] , 100 ) ;
4023: LD_VAR 0 6
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_INT 100
4034: PPUSH
4035: CALL_OW 240
// end ; c = c + 2 ;
4039: LD_ADDR_VAR 0 3
4043: PUSH
4044: LD_VAR 0 3
4048: PUSH
4049: LD_INT 2
4051: PLUS
4052: ST_TO_ADDR
// end ; end ;
4053: GO 3617
// end ;
4055: LD_VAR 0 2
4059: RET
// export function RandFacesAndNames ( ) ; begin
4060: LD_INT 0
4062: PPUSH
// hc_gallery :=  ;
4063: LD_ADDR_OWVAR 33
4067: PUSH
4068: LD_STRING 
4070: ST_TO_ADDR
// hc_name :=  ;
4071: LD_ADDR_OWVAR 26
4075: PUSH
4076: LD_STRING 
4078: ST_TO_ADDR
// hc_importance := 0 ;
4079: LD_ADDR_OWVAR 32
4083: PUSH
4084: LD_INT 0
4086: ST_TO_ADDR
// result := true ;
4087: LD_ADDR_VAR 0 1
4091: PUSH
4092: LD_INT 1
4094: ST_TO_ADDR
// end ;
4095: LD_VAR 0 1
4099: RET
// export function SpawnUSF ( num ) ; var un , i , filter , c ; begin
4100: LD_INT 0
4102: PPUSH
4103: PPUSH
4104: PPUSH
4105: PPUSH
4106: PPUSH
// uc_side := 1 ;
4107: LD_ADDR_OWVAR 20
4111: PUSH
4112: LD_INT 1
4114: ST_TO_ADDR
// uc_nation := 1 ;
4115: LD_ADDR_OWVAR 21
4119: PUSH
4120: LD_INT 1
4122: ST_TO_ADDR
// c := [ 5 , 7 , 9 ] [ Difficulty ] ;
4123: LD_ADDR_VAR 0 6
4127: PUSH
4128: LD_INT 5
4130: PUSH
4131: LD_INT 7
4133: PUSH
4134: LD_INT 9
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PUSH
4142: LD_OWVAR 67
4146: ARRAY
4147: ST_TO_ADDR
// case num of 0 :
4148: LD_VAR 0 1
4152: PUSH
4153: LD_INT 0
4155: DOUBLE
4156: EQUAL
4157: IFTRUE 4161
4159: GO 4427
4161: POP
// begin for i = 1 to c do
4162: LD_ADDR_VAR 0 4
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_VAR 0 6
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4423
// begin if i <= ( c / 2 ) then
4180: LD_VAR 0 4
4184: PUSH
4185: LD_VAR 0 6
4189: PUSH
4190: LD_INT 2
4192: DIVREAL
4193: LESSEQUAL
4194: IFFALSE 4256
// begin RandFacesAndNames ( ) ;
4196: CALL 4060 0 0
// PrepareHuman ( false , class_sniper , us_skill ) ;
4200: LD_INT 0
4202: PPUSH
4203: LD_INT 5
4205: PPUSH
4206: LD_EXP 22
4210: PPUSH
4211: CALL_OW 380
// un := CreateHuman ;
4215: LD_ADDR_VAR 0 3
4219: PUSH
4220: CALL_OW 44
4224: ST_TO_ADDR
// us_force := us_force ^ un ;
4225: LD_ADDR_EXP 10
4229: PUSH
4230: LD_EXP 10
4234: PUSH
4235: LD_VAR 0 3
4239: ADD
4240: ST_TO_ADDR
// PlaceUnitArea ( un , am_main_area , false ) ;
4241: LD_VAR 0 3
4245: PPUSH
4246: LD_INT 8
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 49
// end ; vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
4256: LD_ADDR_OWVAR 37
4260: PUSH
4261: LD_INT 2
4263: PUSH
4264: LD_INT 3
4266: PUSH
4267: LD_INT 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: LIST
4274: PUSH
4275: LD_INT 1
4277: PPUSH
4278: LD_INT 3
4280: PPUSH
4281: CALL_OW 12
4285: ARRAY
4286: ST_TO_ADDR
// vc_engine := engine_combustion ;
4287: LD_ADDR_OWVAR 39
4291: PUSH
4292: LD_INT 1
4294: ST_TO_ADDR
// vc_control := control_computer ;
4295: LD_ADDR_OWVAR 38
4299: PUSH
4300: LD_INT 3
4302: ST_TO_ADDR
// if vc_chassis = us_heavy_tracked then
4303: LD_OWVAR 37
4307: PUSH
4308: LD_INT 4
4310: EQUAL
4311: IFFALSE 4346
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 5
4320: PUSH
4321: LD_INT 6
4323: PUSH
4324: LD_INT 7
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: LD_INT 1
4334: PPUSH
4335: LD_INT 3
4337: PPUSH
4338: CALL_OW 12
4342: ARRAY
4343: ST_TO_ADDR
4344: GO 4373
// vc_weapon := [ us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 2 ) ] ;
4346: LD_ADDR_OWVAR 40
4350: PUSH
4351: LD_INT 5
4353: PUSH
4354: LD_INT 7
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PUSH
4361: LD_INT 1
4363: PPUSH
4364: LD_INT 2
4366: PPUSH
4367: CALL_OW 12
4371: ARRAY
4372: ST_TO_ADDR
// un := CreateVehicle ;
4373: LD_ADDR_VAR 0 3
4377: PUSH
4378: CALL_OW 45
4382: ST_TO_ADDR
// us_force := us_force ^ un ;
4383: LD_ADDR_EXP 10
4387: PUSH
4388: LD_EXP 10
4392: PUSH
4393: LD_VAR 0 3
4397: ADD
4398: ST_TO_ADDR
// PlaceUnitArea ( un , am_main_area , false ) ;
4399: LD_VAR 0 3
4403: PPUSH
4404: LD_INT 8
4406: PPUSH
4407: LD_INT 0
4409: PPUSH
4410: CALL_OW 49
// Wait ( 0 0$02 ) ;
4414: LD_INT 70
4416: PPUSH
4417: CALL_OW 67
// end ;
4421: GO 4177
4423: POP
4424: POP
// end ; 1 :
4425: GO 4833
4427: LD_INT 1
4429: DOUBLE
4430: EQUAL
4431: IFTRUE 4435
4433: GO 4536
4435: POP
// begin for i = 1 to c do
4436: LD_ADDR_VAR 0 4
4440: PUSH
4441: DOUBLE
4442: LD_INT 1
4444: DEC
4445: ST_TO_ADDR
4446: LD_VAR 0 6
4450: PUSH
4451: FOR_TO
4452: IFFALSE 4532
// begin if i <= ( c / 2 ) then
4454: LD_VAR 0 4
4458: PUSH
4459: LD_VAR 0 6
4463: PUSH
4464: LD_INT 2
4466: DIVREAL
4467: LESSEQUAL
4468: IFFALSE 4530
// begin RandFacesAndNames ( ) ;
4470: CALL 4060 0 0
// PrepareHuman ( false , class_sniper , us_skill ) ;
4474: LD_INT 0
4476: PPUSH
4477: LD_INT 5
4479: PPUSH
4480: LD_EXP 22
4484: PPUSH
4485: CALL_OW 380
// un := CreateHuman ;
4489: LD_ADDR_VAR 0 3
4493: PUSH
4494: CALL_OW 44
4498: ST_TO_ADDR
// us_force := us_force ^ un ;
4499: LD_ADDR_EXP 10
4503: PUSH
4504: LD_EXP 10
4508: PUSH
4509: LD_VAR 0 3
4513: ADD
4514: ST_TO_ADDR
// PlaceUnitArea ( un , am_main_area , false ) ;
4515: LD_VAR 0 3
4519: PPUSH
4520: LD_INT 8
4522: PPUSH
4523: LD_INT 0
4525: PPUSH
4526: CALL_OW 49
// end ; end ;
4530: GO 4451
4532: POP
4533: POP
// end ; 2 :
4534: GO 4833
4536: LD_INT 2
4538: DOUBLE
4539: EQUAL
4540: IFTRUE 4544
4542: GO 4734
4544: POP
// begin for i = 1 to c do
4545: LD_ADDR_VAR 0 4
4549: PUSH
4550: DOUBLE
4551: LD_INT 1
4553: DEC
4554: ST_TO_ADDR
4555: LD_VAR 0 6
4559: PUSH
4560: FOR_TO
4561: IFFALSE 4730
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
4563: LD_ADDR_OWVAR 37
4567: PUSH
4568: LD_INT 2
4570: PUSH
4571: LD_INT 3
4573: PUSH
4574: LD_INT 4
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: LIST
4581: PUSH
4582: LD_INT 1
4584: PPUSH
4585: LD_INT 3
4587: PPUSH
4588: CALL_OW 12
4592: ARRAY
4593: ST_TO_ADDR
// vc_engine := engine_combustion ;
4594: LD_ADDR_OWVAR 39
4598: PUSH
4599: LD_INT 1
4601: ST_TO_ADDR
// vc_control := control_computer ;
4602: LD_ADDR_OWVAR 38
4606: PUSH
4607: LD_INT 3
4609: ST_TO_ADDR
// if vc_chassis = us_heavy_tracked then
4610: LD_OWVAR 37
4614: PUSH
4615: LD_INT 4
4617: EQUAL
4618: IFFALSE 4653
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] else
4620: LD_ADDR_OWVAR 40
4624: PUSH
4625: LD_INT 5
4627: PUSH
4628: LD_INT 6
4630: PUSH
4631: LD_INT 7
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: LIST
4638: PUSH
4639: LD_INT 1
4641: PPUSH
4642: LD_INT 3
4644: PPUSH
4645: CALL_OW 12
4649: ARRAY
4650: ST_TO_ADDR
4651: GO 4680
// vc_weapon := [ us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 2 ) ] ;
4653: LD_ADDR_OWVAR 40
4657: PUSH
4658: LD_INT 5
4660: PUSH
4661: LD_INT 7
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: PUSH
4668: LD_INT 1
4670: PPUSH
4671: LD_INT 2
4673: PPUSH
4674: CALL_OW 12
4678: ARRAY
4679: ST_TO_ADDR
// un := CreateVehicle ;
4680: LD_ADDR_VAR 0 3
4684: PUSH
4685: CALL_OW 45
4689: ST_TO_ADDR
// us_force := us_force ^ un ;
4690: LD_ADDR_EXP 10
4694: PUSH
4695: LD_EXP 10
4699: PUSH
4700: LD_VAR 0 3
4704: ADD
4705: ST_TO_ADDR
// PlaceUnitArea ( un , am_main_area , false ) ;
4706: LD_VAR 0 3
4710: PPUSH
4711: LD_INT 8
4713: PPUSH
4714: LD_INT 0
4716: PPUSH
4717: CALL_OW 49
// Wait ( 0 0$02 ) ;
4721: LD_INT 70
4723: PPUSH
4724: CALL_OW 67
// end ;
4728: GO 4560
4730: POP
4731: POP
// end ; 3 :
4732: GO 4833
4734: LD_INT 3
4736: DOUBLE
4737: EQUAL
4738: IFTRUE 4742
4740: GO 4832
4742: POP
// begin for i = 1 to 3 do
4743: LD_ADDR_VAR 0 4
4747: PUSH
4748: DOUBLE
4749: LD_INT 1
4751: DEC
4752: ST_TO_ADDR
4753: LD_INT 3
4755: PUSH
4756: FOR_TO
4757: IFFALSE 4828
// us_vlist := us_vlist ^ [ [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_double_gun , us_rocket_launcher ] [ Rand ( 1 , 2 ) ] ] ;
4759: LD_ADDR_EXP 20
4763: PUSH
4764: LD_EXP 20
4768: PUSH
4769: LD_INT 3
4771: PUSH
4772: LD_INT 4
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PUSH
4779: LD_INT 1
4781: PPUSH
4782: LD_INT 2
4784: PPUSH
4785: CALL_OW 12
4789: ARRAY
4790: PUSH
4791: LD_INT 1
4793: PUSH
4794: LD_INT 2
4796: PUSH
4797: LD_INT 5
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: ADD
4825: ST_TO_ADDR
4826: GO 4756
4828: POP
4829: POP
// end ; end ;
4830: GO 4833
4832: POP
// end ;
4833: LD_VAR 0 2
4837: RET
// every 0 0$01 trigger GetDistUnitToSide ( AmBuilding ( b_warehouse ) , 2 ) < 14 do var i ;
4838: LD_INT 1
4840: PPUSH
4841: CALL 3010 0 1
4845: PPUSH
4846: LD_INT 2
4848: PPUSH
4849: CALL 10337 0 2
4853: PUSH
4854: LD_INT 14
4856: LESS
4857: IFFALSE 4935
4859: GO 4861
4861: DISABLE
4862: LD_INT 0
4864: PPUSH
// begin SpawnUSF ( 1 ) ;
4865: LD_INT 1
4867: PPUSH
4868: CALL 4100 0 1
// us_attack := 0 ;
4872: LD_ADDR_EXP 23
4876: PUSH
4877: LD_INT 0
4879: ST_TO_ADDR
// for i = 1 to us_snip do
4880: LD_ADDR_VAR 0 1
4884: PUSH
4885: DOUBLE
4886: LD_INT 1
4888: DEC
4889: ST_TO_ADDR
4890: LD_EXP 15
4894: PUSH
4895: FOR_TO
4896: IFFALSE 4933
// if not IsInUnit ( us_snip [ i ] ) then
4898: LD_EXP 15
4902: PUSH
4903: LD_VAR 0 1
4907: ARRAY
4908: PPUSH
4909: CALL_OW 310
4913: NOT
4914: IFFALSE 4931
// ComMoveXY ( us_snip , 104 , 4 ) ;
4916: LD_EXP 15
4920: PPUSH
4921: LD_INT 104
4923: PPUSH
4924: LD_INT 4
4926: PPUSH
4927: CALL_OW 111
4931: GO 4895
4933: POP
4934: POP
// end ;
4935: PPOPN 1
4937: END
// export us_cts ; every 1 do
4938: GO 4940
4940: DISABLE
// us_cts := 1 ;
4941: LD_ADDR_EXP 26
4945: PUSH
4946: LD_INT 1
4948: ST_TO_ADDR
4949: END
// every 5 5$00 trigger us_contact do var i ;
4950: LD_EXP 24
4954: IFFALSE 5025
4956: GO 4958
4958: DISABLE
4959: LD_INT 0
4961: PPUSH
// begin enable ;
4962: ENABLE
// for i = 1 to us_cts do
4963: LD_ADDR_VAR 0 1
4967: PUSH
4968: DOUBLE
4969: LD_INT 1
4971: DEC
4972: ST_TO_ADDR
4973: LD_EXP 26
4977: PUSH
4978: FOR_TO
4979: IFFALSE 4990
// SpawnUSF ( 3 ) ;
4981: LD_INT 3
4983: PPUSH
4984: CALL 4100 0 1
4988: GO 4978
4990: POP
4991: POP
// Wait ( 3 3$30 ) ;
4992: LD_INT 7350
4994: PPUSH
4995: CALL_OW 67
// if us_cts <= Difficulty then
4999: LD_EXP 26
5003: PUSH
5004: LD_OWVAR 67
5008: LESSEQUAL
5009: IFFALSE 5025
// us_cts := us_cts + 1 ;
5011: LD_ADDR_EXP 26
5015: PUSH
5016: LD_EXP 26
5020: PUSH
5021: LD_INT 1
5023: PLUS
5024: ST_TO_ADDR
// end ;
5025: PPOPN 1
5027: END
// every 0 0$25 trigger us_contact and tick > 12 12$00 do var i ;
5028: LD_EXP 24
5032: PUSH
5033: LD_OWVAR 1
5037: PUSH
5038: LD_INT 25200
5040: GREATER
5041: AND
5042: IFFALSE 5123
5044: GO 5046
5046: DISABLE
5047: LD_INT 0
5049: PPUSH
// begin enable ;
5050: ENABLE
// if us_force < 10 then
5051: LD_EXP 10
5055: PUSH
5056: LD_INT 10
5058: LESS
5059: IFFALSE 5071
// us_attack := 0 else
5061: LD_ADDR_EXP 23
5065: PUSH
5066: LD_INT 0
5068: ST_TO_ADDR
5069: GO 5079
// us_attack := 1 ;
5071: LD_ADDR_EXP 23
5075: PUSH
5076: LD_INT 1
5078: ST_TO_ADDR
// if awp = false and See ( 1 , Gali ) then
5079: LD_EXP 41
5083: PUSH
5084: LD_INT 0
5086: EQUAL
5087: PUSH
5088: LD_INT 1
5090: PPUSH
5091: LD_EXP 33
5095: PPUSH
5096: CALL_OW 292
5100: AND
5101: IFFALSE 5123
// begin awp := true ;
5103: LD_ADDR_EXP 41
5107: PUSH
5108: LD_INT 1
5110: ST_TO_ADDR
// Say ( Gali , 09_DG-usattack ) ;
5111: LD_EXP 33
5115: PPUSH
5116: LD_STRING 09_DG-usattack
5118: PPUSH
5119: CALL_OW 88
// end ; end ; end_of_file
5123: PPOPN 1
5125: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_weapon , ar_cargo_bay ] ] ) then
5126: LD_VAR 0 1
5130: PUSH
5131: LD_INT 22
5133: PUSH
5134: LD_INT 5
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: LD_INT 34
5143: PUSH
5144: LD_INT 32
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PPUSH
5155: CALL_OW 69
5159: IN
5160: IFFALSE 5169
// YouLost ( cargolost ) ;
5162: LD_STRING cargolost
5164: PPUSH
5165: CALL_OW 104
// if un = Louis then
5169: LD_VAR 0 1
5173: PUSH
5174: LD_EXP 27
5178: EQUAL
5179: IFFALSE 5188
// YouLost ( louisdead ) ;
5181: LD_STRING louisdead
5183: PPUSH
5184: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
5188: LD_VAR 0 1
5192: PUSH
5193: LD_INT 22
5195: PUSH
5196: LD_INT 1
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: LD_INT 21
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: EMPTY
5214: LIST
5215: LIST
5216: PPUSH
5217: CALL_OW 69
5221: IN
5222: IFFALSE 5283
// begin if us_attack <> 1 then
5224: LD_EXP 23
5228: PUSH
5229: LD_INT 1
5231: NONEQUAL
5232: IFFALSE 5283
// begin us_attack := 1 ;
5234: LD_ADDR_EXP 23
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// if IsLive ( Gali ) and awp = false then
5242: LD_EXP 33
5246: PPUSH
5247: CALL_OW 300
5251: PUSH
5252: LD_EXP 41
5256: PUSH
5257: LD_INT 0
5259: EQUAL
5260: AND
5261: IFFALSE 5283
// begin awp := true ;
5263: LD_ADDR_EXP 41
5267: PUSH
5268: LD_INT 1
5270: ST_TO_ADDR
// Say ( Gali , 09_DG-usattack ) ;
5271: LD_EXP 33
5275: PPUSH
5276: LD_STRING 09_DG-usattack
5278: PPUSH
5279: CALL_OW 88
// end ; end ; end ; if un in us_buildings then
5283: LD_VAR 0 1
5287: PUSH
5288: LD_EXP 16
5292: IN
5293: IFFALSE 5472
// begin if GetBType ( un ) = b_barracks then
5295: LD_VAR 0 1
5299: PPUSH
5300: CALL_OW 266
5304: PUSH
5305: LD_INT 5
5307: EQUAL
5308: IFFALSE 5326
// us_blist := us_blist ^ b_armoury else
5310: LD_ADDR_EXP 19
5314: PUSH
5315: LD_EXP 19
5319: PUSH
5320: LD_INT 4
5322: ADD
5323: ST_TO_ADDR
5324: GO 5409
// if GetBType ( un ) = b_factory then
5326: LD_VAR 0 1
5330: PPUSH
5331: CALL_OW 266
5335: PUSH
5336: LD_INT 3
5338: EQUAL
5339: IFFALSE 5357
// us_blist := us_blist ^ b_workshop else
5341: LD_ADDR_EXP 19
5345: PUSH
5346: LD_EXP 19
5350: PUSH
5351: LD_INT 2
5353: ADD
5354: ST_TO_ADDR
5355: GO 5409
// if GetBType ( un ) = b_lab_full then
5357: LD_VAR 0 1
5361: PPUSH
5362: CALL_OW 266
5366: PUSH
5367: LD_INT 8
5369: EQUAL
5370: IFFALSE 5388
// us_blist := us_blist ^ b_lab else
5372: LD_ADDR_EXP 19
5376: PUSH
5377: LD_EXP 19
5381: PUSH
5382: LD_INT 6
5384: ADD
5385: ST_TO_ADDR
5386: GO 5409
// us_blist := us_blist ^ GetBType ( un ) ;
5388: LD_ADDR_EXP 19
5392: PUSH
5393: LD_EXP 19
5397: PUSH
5398: LD_VAR 0 1
5402: PPUSH
5403: CALL_OW 266
5407: ADD
5408: ST_TO_ADDR
// us_blist := us_blist ^ GetX ( un ) ;
5409: LD_ADDR_EXP 19
5413: PUSH
5414: LD_EXP 19
5418: PUSH
5419: LD_VAR 0 1
5423: PPUSH
5424: CALL_OW 250
5428: ADD
5429: ST_TO_ADDR
// us_blist := us_blist ^ GetY ( un ) ;
5430: LD_ADDR_EXP 19
5434: PUSH
5435: LD_EXP 19
5439: PUSH
5440: LD_VAR 0 1
5444: PPUSH
5445: CALL_OW 251
5449: ADD
5450: ST_TO_ADDR
// us_blist := us_blist ^ GetDir ( un ) ;
5451: LD_ADDR_EXP 19
5455: PUSH
5456: LD_EXP 19
5460: PUSH
5461: LD_VAR 0 1
5465: PPUSH
5466: CALL_OW 254
5470: ADD
5471: ST_TO_ADDR
// end ; if un in us_vehicles then
5472: LD_VAR 0 1
5476: PUSH
5477: LD_EXP 17
5481: IN
5482: IFFALSE 5561
// begin us_vlist := us_vlist ^ GetChassis ( un ) ;
5484: LD_ADDR_EXP 20
5488: PUSH
5489: LD_EXP 20
5493: PUSH
5494: LD_VAR 0 1
5498: PPUSH
5499: CALL_OW 265
5503: ADD
5504: ST_TO_ADDR
// us_vlist := us_vlist ^ GetEngine ( un ) ;
5505: LD_ADDR_EXP 20
5509: PUSH
5510: LD_EXP 20
5514: PUSH
5515: LD_VAR 0 1
5519: PPUSH
5520: CALL_OW 262
5524: ADD
5525: ST_TO_ADDR
// us_vlist := us_vlist ^ control_remote ;
5526: LD_ADDR_EXP 20
5530: PUSH
5531: LD_EXP 20
5535: PUSH
5536: LD_INT 2
5538: ADD
5539: ST_TO_ADDR
// us_vlist := us_vlist ^ GetWeapon ( un ) ;
5540: LD_ADDR_EXP 20
5544: PUSH
5545: LD_EXP 20
5549: PUSH
5550: LD_VAR 0 1
5554: PPUSH
5555: CALL_OW 264
5559: ADD
5560: ST_TO_ADDR
// end ; end ;
5561: PPOPN 1
5563: END
// on VehicleConstructed ( fac , veh ) do var i ;
5564: LD_INT 0
5566: PPUSH
// begin if GetSide ( veh ) = 1 and not GetWeapon ( veh ) = us_cargo_bay and not GetWeapon ( veh ) = us_crane then
5567: LD_VAR 0 2
5571: PPUSH
5572: CALL_OW 255
5576: PUSH
5577: LD_INT 1
5579: EQUAL
5580: PUSH
5581: LD_VAR 0 2
5585: PPUSH
5586: CALL_OW 264
5590: PUSH
5591: LD_INT 12
5593: EQUAL
5594: NOT
5595: AND
5596: PUSH
5597: LD_VAR 0 2
5601: PPUSH
5602: CALL_OW 264
5606: PUSH
5607: LD_INT 13
5609: EQUAL
5610: NOT
5611: AND
5612: IFFALSE 5684
// us_force := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
5614: LD_ADDR_EXP 10
5618: PUSH
5619: LD_INT 22
5621: PUSH
5622: LD_INT 1
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: PUSH
5629: LD_INT 21
5631: PUSH
5632: LD_INT 2
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: LD_INT 34
5644: PUSH
5645: LD_INT 13
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 3
5658: PUSH
5659: LD_INT 34
5661: PUSH
5662: LD_INT 12
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: ST_TO_ADDR
// if GetSide ( fac ) = am then
5684: LD_VAR 0 1
5688: PPUSH
5689: CALL_OW 255
5693: PUSH
5694: LD_EXP 1
5698: EQUAL
5699: IFFALSE 5739
// for i = 1 to 4 do
5701: LD_ADDR_VAR 0 3
5705: PUSH
5706: DOUBLE
5707: LD_INT 1
5709: DEC
5710: ST_TO_ADDR
5711: LD_INT 4
5713: PUSH
5714: FOR_TO
5715: IFFALSE 5737
// us_vlist := Delete ( us_vlist , 1 ) ;
5717: LD_ADDR_EXP 20
5721: PUSH
5722: LD_EXP 20
5726: PPUSH
5727: LD_INT 1
5729: PPUSH
5730: CALL_OW 3
5734: ST_TO_ADDR
5735: GO 5714
5737: POP
5738: POP
// end ;
5739: PPOPN 3
5741: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ f_side , 1 ] ) and us_contact = false then
5742: LD_VAR 0 1
5746: PUSH
5747: LD_INT 22
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: PPUSH
5757: CALL_OW 69
5761: IN
5762: PUSH
5763: LD_EXP 24
5767: PUSH
5768: LD_INT 0
5770: EQUAL
5771: AND
5772: IFFALSE 5782
// us_contact := true ;
5774: LD_ADDR_EXP 24
5778: PUSH
5779: LD_INT 1
5781: ST_TO_ADDR
// end ;
5782: PPOPN 1
5784: END
// on BuildingComplete ( b ) do var i ;
5785: LD_INT 0
5787: PPUSH
// begin if GetSide ( b ) = am then
5788: LD_VAR 0 1
5792: PPUSH
5793: CALL_OW 255
5797: PUSH
5798: LD_EXP 1
5802: EQUAL
5803: IFFALSE 5843
// for i = 1 to 4 do
5805: LD_ADDR_VAR 0 2
5809: PUSH
5810: DOUBLE
5811: LD_INT 1
5813: DEC
5814: ST_TO_ADDR
5815: LD_INT 4
5817: PUSH
5818: FOR_TO
5819: IFFALSE 5841
// us_blist := Delete ( us_blist , 1 ) ;
5821: LD_ADDR_EXP 19
5825: PUSH
5826: LD_EXP 19
5830: PPUSH
5831: LD_INT 1
5833: PPUSH
5834: CALL_OW 3
5838: ST_TO_ADDR
5839: GO 5818
5841: POP
5842: POP
// end ;
5843: PPOPN 2
5845: END
// every 1 1$10 trigger tick < 35 * 60 * 60 do var i , chance ;
5846: LD_OWVAR 1
5850: PUSH
5851: LD_INT 35
5853: PUSH
5854: LD_INT 60
5856: MUL
5857: PUSH
5858: LD_INT 60
5860: MUL
5861: LESS
5862: IFFALSE 6018
5864: GO 5866
5866: DISABLE
5867: LD_INT 0
5869: PPUSH
5870: PPUSH
// begin enable ;
5871: ENABLE
// chance := Rand ( 0 , 100 ) ;
5872: LD_ADDR_VAR 0 2
5876: PUSH
5877: LD_INT 0
5879: PPUSH
5880: LD_INT 100
5882: PPUSH
5883: CALL_OW 12
5887: ST_TO_ADDR
// if chance >= [ 40 , 50 , 60 ] then
5888: LD_VAR 0 2
5892: PUSH
5893: LD_INT 40
5895: PUSH
5896: LD_INT 50
5898: PUSH
5899: LD_INT 60
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: LIST
5906: GREATEREQUAL
5907: IFFALSE 5930
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
5909: LD_INT 1
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: CALL_OW 12
5919: PPUSH
5920: LD_INT 2
5922: PPUSH
5923: LD_INT 1
5925: PPUSH
5926: CALL_OW 55
// Wait ( Rand ( 0 0$01 , 0 0$11 ) ) ;
5930: LD_INT 35
5932: PPUSH
5933: LD_INT 385
5935: PPUSH
5936: CALL_OW 12
5940: PPUSH
5941: CALL_OW 67
// if chance >= [ 20 , 13 , 10 ] then
5945: LD_VAR 0 2
5949: PUSH
5950: LD_INT 20
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 10
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: LIST
5963: GREATEREQUAL
5964: IFFALSE 5987
// CreateCratesArea ( Rand ( 1 , 5 ) , am_crates_spawn , true ) ;
5966: LD_INT 1
5968: PPUSH
5969: LD_INT 5
5971: PPUSH
5972: CALL_OW 12
5976: PPUSH
5977: LD_INT 3
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL_OW 55
// if game_counter < 1340 then
5987: LD_EXP 40
5991: PUSH
5992: LD_INT 1340
5994: LESS
5995: IFFALSE 6018
// CreateCratesArea ( Rand ( 2 , 5 ) , ar_crates_spawn , true ) ;
5997: LD_INT 2
5999: PPUSH
6000: LD_INT 5
6002: PPUSH
6003: CALL_OW 12
6007: PPUSH
6008: LD_INT 12
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL_OW 55
// end ; end_of_file
6018: PPOPN 2
6020: END
// export Louis , Rolf , Jenna , Nicolas , Rick , Mike , Gali ; export ar_pep , ar_pep2 , pnames ; export cargos , rus_var , cargo_chassis , game_counter , awp , dday_event , prison_event ; export function LoadPeople ; var i , names , veh , un , pom , p , tmp , name , k , ammo ; begin
6021: LD_INT 0
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
6027: PPUSH
6028: PPUSH
6029: PPUSH
6030: PPUSH
6031: PPUSH
6032: PPUSH
6033: PPUSH
// uc_side := 2 ;
6034: LD_ADDR_OWVAR 20
6038: PUSH
6039: LD_INT 2
6041: ST_TO_ADDR
// uc_nation := 2 ;
6042: LD_ADDR_OWVAR 21
6046: PUSH
6047: LD_INT 2
6049: ST_TO_ADDR
// ar_pep := [ ] ;
6050: LD_ADDR_EXP 34
6054: PUSH
6055: EMPTY
6056: ST_TO_ADDR
// pnames := [ ] ;
6057: LD_ADDR_EXP 36
6061: PUSH
6062: EMPTY
6063: ST_TO_ADDR
// awp := false ;
6064: LD_ADDR_EXP 41
6068: PUSH
6069: LD_INT 0
6071: ST_TO_ADDR
// dday_event := false ;
6072: LD_ADDR_EXP 42
6076: PUSH
6077: LD_INT 0
6079: ST_TO_ADDR
// prison_event := false ;
6080: LD_ADDR_EXP 43
6084: PUSH
6085: LD_INT 0
6087: ST_TO_ADDR
// tmp := [ ] ;
6088: LD_ADDR_VAR 0 8
6092: PUSH
6093: EMPTY
6094: ST_TO_ADDR
// cargos := [ car_1 , car_2 , car_3 , car_4 ] ;
6095: LD_ADDR_EXP 37
6099: PUSH
6100: LD_STRING car_1
6102: PUSH
6103: LD_STRING car_2
6105: PUSH
6106: LD_STRING car_3
6108: PUSH
6109: LD_STRING car_4
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: ST_TO_ADDR
// k := 0 ;
6118: LD_ADDR_VAR 0 10
6122: PUSH
6123: LD_INT 0
6125: ST_TO_ADDR
// game_counter := 0 ;
6126: LD_ADDR_EXP 40
6130: PUSH
6131: LD_INT 0
6133: ST_TO_ADDR
// ammo := LoadVariable ( var_ammo , 0 ) ;
6134: LD_ADDR_VAR 0 11
6138: PUSH
6139: LD_STRING var_ammo
6141: PPUSH
6142: LD_INT 0
6144: PPUSH
6145: CALL_OW 30
6149: ST_TO_ADDR
// if ammo = 1 then
6150: LD_VAR 0 11
6154: PUSH
6155: LD_INT 1
6157: EQUAL
6158: IFFALSE 6173
// SetTech ( 29 , 2 , state_researched ) ;
6160: LD_INT 29
6162: PPUSH
6163: LD_INT 2
6165: PPUSH
6166: LD_INT 2
6168: PPUSH
6169: CALL_OW 322
// cargo_chassis := LoadVariable ( cargo_chassis , 0 ) ;
6173: LD_ADDR_EXP 39
6177: PUSH
6178: LD_STRING cargo_chassis
6180: PPUSH
6181: LD_INT 0
6183: PPUSH
6184: CALL_OW 30
6188: ST_TO_ADDR
// rus_var := LoadVariable ( var_rus , 0 ) ;
6189: LD_ADDR_EXP 38
6193: PUSH
6194: LD_STRING var_rus
6196: PPUSH
6197: LD_INT 0
6199: PPUSH
6200: CALL_OW 30
6204: ST_TO_ADDR
// Louis := CreateCharacter ( Louis ) ;
6205: LD_ADDR_EXP 27
6209: PUSH
6210: LD_STRING Louis
6212: PPUSH
6213: CALL_OW 34
6217: ST_TO_ADDR
// ar_pep := Louis ;
6218: LD_ADDR_EXP 34
6222: PUSH
6223: LD_EXP 27
6227: ST_TO_ADDR
// if rus_var = 0 then
6228: LD_EXP 38
6232: PUSH
6233: LD_INT 0
6235: EQUAL
6236: IFFALSE 6884
// begin uc_side := 5 ;
6238: LD_ADDR_OWVAR 20
6242: PUSH
6243: LD_INT 5
6245: ST_TO_ADDR
// for i = 1 to cargo_chassis do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_EXP 39
6260: PUSH
6261: FOR_TO
6262: IFFALSE 6427
// begin if cargo_chassis [ i ] in [ ar_medium_trike , ar_half_tracked ] then
6264: LD_EXP 39
6268: PUSH
6269: LD_VAR 0 2
6273: ARRAY
6274: PUSH
6275: LD_INT 13
6277: PUSH
6278: LD_INT 14
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: IN
6285: IFFALSE 6305
// begin uc_nation := nation_arabian ;
6287: LD_ADDR_OWVAR 21
6291: PUSH
6292: LD_INT 2
6294: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
6295: LD_ADDR_OWVAR 40
6299: PUSH
6300: LD_INT 32
6302: ST_TO_ADDR
// end else
6303: GO 6321
// begin uc_nation := nation_russian ;
6305: LD_ADDR_OWVAR 21
6309: PUSH
6310: LD_INT 3
6312: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6313: LD_ADDR_OWVAR 40
6317: PUSH
6318: LD_INT 51
6320: ST_TO_ADDR
// end ; vc_chassis := cargo_chassis [ i ] ;
6321: LD_ADDR_OWVAR 37
6325: PUSH
6326: LD_EXP 39
6330: PUSH
6331: LD_VAR 0 2
6335: ARRAY
6336: ST_TO_ADDR
// vc_engine := engine_combustion ;
6337: LD_ADDR_OWVAR 39
6341: PUSH
6342: LD_INT 1
6344: ST_TO_ADDR
// vc_control := control_manual ;
6345: LD_ADDR_OWVAR 38
6349: PUSH
6350: LD_INT 1
6352: ST_TO_ADDR
// veh := CreateVehicle ;
6353: LD_ADDR_VAR 0 4
6357: PUSH
6358: CALL_OW 45
6362: ST_TO_ADDR
// SetDir ( veh , Rand ( 0 , 5 ) ) ;
6363: LD_VAR 0 4
6367: PPUSH
6368: LD_INT 0
6370: PPUSH
6371: LD_INT 5
6373: PPUSH
6374: CALL_OW 12
6378: PPUSH
6379: CALL_OW 233
// PlaceUnitArea ( veh , prison_area , false ) ;
6383: LD_VAR 0 4
6387: PPUSH
6388: LD_INT 5
6390: PPUSH
6391: LD_INT 0
6393: PPUSH
6394: CALL_OW 49
// SetFuel ( veh , 1 ) ;
6398: LD_VAR 0 4
6402: PPUSH
6403: LD_INT 1
6405: PPUSH
6406: CALL_OW 240
// SetCargo ( veh , 3 , 100 ) ;
6410: LD_VAR 0 4
6414: PPUSH
6415: LD_INT 3
6417: PPUSH
6418: LD_INT 100
6420: PPUSH
6421: CALL_OW 290
// end ;
6425: GO 6261
6427: POP
6428: POP
// uc_side := 2 ;
6429: LD_ADDR_OWVAR 20
6433: PUSH
6434: LD_INT 2
6436: ST_TO_ADDR
// uc_nation := 2 ;
6437: LD_ADDR_OWVAR 21
6441: PUSH
6442: LD_INT 2
6444: ST_TO_ADDR
// Rolf := CreateCharacter ( Rolf_09 ) ;
6445: LD_ADDR_EXP 28
6449: PUSH
6450: LD_STRING Rolf_09
6452: PPUSH
6453: CALL_OW 34
6457: ST_TO_ADDR
// ar_pep := ar_pep ^ Rolf ;
6458: LD_ADDR_EXP 34
6462: PUSH
6463: LD_EXP 34
6467: PUSH
6468: LD_EXP 28
6472: ADD
6473: ST_TO_ADDR
// Gali := CreateCharacter ( Gali_09 ) ;
6474: LD_ADDR_EXP 33
6478: PUSH
6479: LD_STRING Gali_09
6481: PPUSH
6482: CALL_OW 34
6486: ST_TO_ADDR
// ar_pep := ar_pep ^ Gali ;
6487: LD_ADDR_EXP 34
6491: PUSH
6492: LD_EXP 34
6496: PUSH
6497: LD_EXP 33
6501: ADD
6502: ST_TO_ADDR
// Mike := CreateCharacter ( Mike_09 ) ;
6503: LD_ADDR_EXP 32
6507: PUSH
6508: LD_STRING Mike_09
6510: PPUSH
6511: CALL_OW 34
6515: ST_TO_ADDR
// ar_pep := ar_pep ^ Mike ;
6516: LD_ADDR_EXP 34
6520: PUSH
6521: LD_EXP 34
6525: PUSH
6526: LD_EXP 32
6530: ADD
6531: ST_TO_ADDR
// Nicolas := CreateCharacter ( Nicolas_09 ) ;
6532: LD_ADDR_EXP 30
6536: PUSH
6537: LD_STRING Nicolas_09
6539: PPUSH
6540: CALL_OW 34
6544: ST_TO_ADDR
// ar_pep := ar_pep ^ Nicolas ;
6545: LD_ADDR_EXP 34
6549: PUSH
6550: LD_EXP 34
6554: PUSH
6555: LD_EXP 30
6559: ADD
6560: ST_TO_ADDR
// Jenna := CreateCharacter ( Jenna_09 ) ;
6561: LD_ADDR_EXP 29
6565: PUSH
6566: LD_STRING Jenna_09
6568: PPUSH
6569: CALL_OW 34
6573: ST_TO_ADDR
// ar_pep := ar_pep ^ Jenna ;
6574: LD_ADDR_EXP 34
6578: PUSH
6579: LD_EXP 34
6583: PUSH
6584: LD_EXP 29
6588: ADD
6589: ST_TO_ADDR
// Rick := CreateCharacter ( Rick_09 ) ;
6590: LD_ADDR_EXP 31
6594: PUSH
6595: LD_STRING Rick_09
6597: PPUSH
6598: CALL_OW 34
6602: ST_TO_ADDR
// ar_pep := ar_pep ^ Rick ;
6603: LD_ADDR_EXP 34
6607: PUSH
6608: LD_EXP 34
6612: PUSH
6613: LD_EXP 31
6617: ADD
6618: ST_TO_ADDR
// names := [ a_09 , b_09 , c_09 , d_09 , e_09 , f_09 , g_09 , h_09 , i_09 , j_09 , k_09 , l_09 , m_09 , n_09 , o_09 , p_09 ] ;
6619: LD_ADDR_VAR 0 3
6623: PUSH
6624: LD_STRING a_09
6626: PUSH
6627: LD_STRING b_09
6629: PUSH
6630: LD_STRING c_09
6632: PUSH
6633: LD_STRING d_09
6635: PUSH
6636: LD_STRING e_09
6638: PUSH
6639: LD_STRING f_09
6641: PUSH
6642: LD_STRING g_09
6644: PUSH
6645: LD_STRING h_09
6647: PUSH
6648: LD_STRING i_09
6650: PUSH
6651: LD_STRING j_09
6653: PUSH
6654: LD_STRING k_09
6656: PUSH
6657: LD_STRING l_09
6659: PUSH
6660: LD_STRING m_09
6662: PUSH
6663: LD_STRING n_09
6665: PUSH
6666: LD_STRING o_09
6668: PUSH
6669: LD_STRING p_09
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: ST_TO_ADDR
// for i = 1 to names do
6690: LD_ADDR_VAR 0 2
6694: PUSH
6695: DOUBLE
6696: LD_INT 1
6698: DEC
6699: ST_TO_ADDR
6700: LD_VAR 0 3
6704: PUSH
6705: FOR_TO
6706: IFFALSE 6747
// begin un := CreateCharacter ( names [ i ] ) ;
6708: LD_ADDR_VAR 0 5
6712: PUSH
6713: LD_VAR 0 3
6717: PUSH
6718: LD_VAR 0 2
6722: ARRAY
6723: PPUSH
6724: CALL_OW 34
6728: ST_TO_ADDR
// ar_pep := ar_pep ^ un ;
6729: LD_ADDR_EXP 34
6733: PUSH
6734: LD_EXP 34
6738: PUSH
6739: LD_VAR 0 5
6743: ADD
6744: ST_TO_ADDR
// end ;
6745: GO 6705
6747: POP
6748: POP
// uc_side := 5 ;
6749: LD_ADDR_OWVAR 20
6753: PUSH
6754: LD_INT 5
6756: ST_TO_ADDR
// for i = 1 to 2 do
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: DOUBLE
6763: LD_INT 1
6765: DEC
6766: ST_TO_ADDR
6767: LD_INT 2
6769: PUSH
6770: FOR_TO
6771: IFFALSE 6870
// begin name := LoadVariable ( host & i , 0 ) ;
6773: LD_ADDR_VAR 0 9
6777: PUSH
6778: LD_STRING host
6780: PUSH
6781: LD_VAR 0 2
6785: STR
6786: PPUSH
6787: LD_INT 0
6789: PPUSH
6790: CALL_OW 30
6794: ST_TO_ADDR
// un := CreateCharacter ( cargos [ i ] ) ;
6795: LD_ADDR_VAR 0 5
6799: PUSH
6800: LD_EXP 37
6804: PUSH
6805: LD_VAR 0 2
6809: ARRAY
6810: PPUSH
6811: CALL_OW 34
6815: ST_TO_ADDR
// SetTag ( un , name ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 9
6825: PPUSH
6826: CALL_OW 109
// tmp := tmp ^ un ;
6830: LD_ADDR_VAR 0 8
6834: PUSH
6835: LD_VAR 0 8
6839: PUSH
6840: LD_VAR 0 5
6844: ADD
6845: ST_TO_ADDR
// if name > 0 then
6846: LD_VAR 0 9
6850: PUSH
6851: LD_INT 0
6853: GREATER
6854: IFFALSE 6868
// PlaceHumanInUnit ( un , us_prison ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 63
6863: PPUSH
6864: CALL_OW 52
// end ;
6868: GO 6770
6870: POP
6871: POP
// ar_pep2 = tmp ;
6872: LD_ADDR_EXP 35
6876: PUSH
6877: LD_VAR 0 8
6881: ST_TO_ADDR
// end else
6882: GO 7195
// begin RemoveUnit ( us_prison ) ;
6884: LD_INT 63
6886: PPUSH
6887: CALL_OW 64
// Rolf := CreateCharacter ( Rolf_08 ) ;
6891: LD_ADDR_EXP 28
6895: PUSH
6896: LD_STRING Rolf_08
6898: PPUSH
6899: CALL_OW 34
6903: ST_TO_ADDR
// ar_pep := ar_pep ^ Rolf ;
6904: LD_ADDR_EXP 34
6908: PUSH
6909: LD_EXP 34
6913: PUSH
6914: LD_EXP 28
6918: ADD
6919: ST_TO_ADDR
// Gali := CreateCharacter ( Gali_08 ) ;
6920: LD_ADDR_EXP 33
6924: PUSH
6925: LD_STRING Gali_08
6927: PPUSH
6928: CALL_OW 34
6932: ST_TO_ADDR
// ar_pep := ar_pep ^ Gali ;
6933: LD_ADDR_EXP 34
6937: PUSH
6938: LD_EXP 34
6942: PUSH
6943: LD_EXP 33
6947: ADD
6948: ST_TO_ADDR
// Mike := CreateCharacter ( Mike_08 ) ;
6949: LD_ADDR_EXP 32
6953: PUSH
6954: LD_STRING Mike_08
6956: PPUSH
6957: CALL_OW 34
6961: ST_TO_ADDR
// ar_pep := ar_pep ^ Mike ;
6962: LD_ADDR_EXP 34
6966: PUSH
6967: LD_EXP 34
6971: PUSH
6972: LD_EXP 32
6976: ADD
6977: ST_TO_ADDR
// Nicolas := CreateCharacter ( Nicolas_08 ) ;
6978: LD_ADDR_EXP 30
6982: PUSH
6983: LD_STRING Nicolas_08
6985: PPUSH
6986: CALL_OW 34
6990: ST_TO_ADDR
// ar_pep := ar_pep ^ Nicolas ;
6991: LD_ADDR_EXP 34
6995: PUSH
6996: LD_EXP 34
7000: PUSH
7001: LD_EXP 30
7005: ADD
7006: ST_TO_ADDR
// Jenna := CreateCharacter ( Jenna_08 ) ;
7007: LD_ADDR_EXP 29
7011: PUSH
7012: LD_STRING Jenna_08
7014: PPUSH
7015: CALL_OW 34
7019: ST_TO_ADDR
// ar_pep := ar_pep ^ Jenna ;
7020: LD_ADDR_EXP 34
7024: PUSH
7025: LD_EXP 34
7029: PUSH
7030: LD_EXP 29
7034: ADD
7035: ST_TO_ADDR
// Rick := CreateCharacter ( Rick_08 ) ;
7036: LD_ADDR_EXP 31
7040: PUSH
7041: LD_STRING Rick_08
7043: PPUSH
7044: CALL_OW 34
7048: ST_TO_ADDR
// ar_pep := ar_pep ^ Rick ;
7049: LD_ADDR_EXP 34
7053: PUSH
7054: LD_EXP 34
7058: PUSH
7059: LD_EXP 31
7063: ADD
7064: ST_TO_ADDR
// names := [ a_08 , b_08 , c_08 , d_08 , e_08 , f_08 , g_08 , h_08 , i_08 , j_08 , k_08 , l_08 , m_08 , n_08 , o_08 , p_08 ] ;
7065: LD_ADDR_VAR 0 3
7069: PUSH
7070: LD_STRING a_08
7072: PUSH
7073: LD_STRING b_08
7075: PUSH
7076: LD_STRING c_08
7078: PUSH
7079: LD_STRING d_08
7081: PUSH
7082: LD_STRING e_08
7084: PUSH
7085: LD_STRING f_08
7087: PUSH
7088: LD_STRING g_08
7090: PUSH
7091: LD_STRING h_08
7093: PUSH
7094: LD_STRING i_08
7096: PUSH
7097: LD_STRING j_08
7099: PUSH
7100: LD_STRING k_08
7102: PUSH
7103: LD_STRING l_08
7105: PUSH
7106: LD_STRING m_08
7108: PUSH
7109: LD_STRING n_08
7111: PUSH
7112: LD_STRING o_08
7114: PUSH
7115: LD_STRING p_08
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: LIST
7135: ST_TO_ADDR
// for i = 1 to names do
7136: LD_ADDR_VAR 0 2
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 3
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7193
// begin un := CreateCharacter ( names [ i ] ) ;
7154: LD_ADDR_VAR 0 5
7158: PUSH
7159: LD_VAR 0 3
7163: PUSH
7164: LD_VAR 0 2
7168: ARRAY
7169: PPUSH
7170: CALL_OW 34
7174: ST_TO_ADDR
// ar_pep := ar_pep ^ un ;
7175: LD_ADDR_EXP 34
7179: PUSH
7180: LD_EXP 34
7184: PUSH
7185: LD_VAR 0 5
7189: ADD
7190: ST_TO_ADDR
// end ;
7191: GO 7151
7193: POP
7194: POP
// end ; end ;
7195: LD_VAR 0 1
7199: RET
// export ar_vehicles ; export function LoadVehicles ; var tab , i , p , veh , filter ; begin
7200: LD_INT 0
7202: PPUSH
7203: PPUSH
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
// uc_side := 2 ;
7208: LD_ADDR_OWVAR 20
7212: PUSH
7213: LD_INT 2
7215: ST_TO_ADDR
// tab := LoadVariable ( unit_vehs , [ ] ) ;
7216: LD_ADDR_VAR 0 2
7220: PUSH
7221: LD_STRING unit_vehs
7223: PPUSH
7224: EMPTY
7225: PPUSH
7226: CALL_OW 30
7230: ST_TO_ADDR
// i := 1 ;
7231: LD_ADDR_VAR 0 3
7235: PUSH
7236: LD_INT 1
7238: ST_TO_ADDR
// p := 1 ;
7239: LD_ADDR_VAR 0 4
7243: PUSH
7244: LD_INT 1
7246: ST_TO_ADDR
// if tab > 0 then
7247: LD_VAR 0 2
7251: PUSH
7252: LD_INT 0
7254: GREATER
7255: IFFALSE 7557
// while ( i <= tab ) do
7257: LD_VAR 0 3
7261: PUSH
7262: LD_VAR 0 2
7266: LESSEQUAL
7267: IFFALSE 7557
// begin if tab [ i ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
7269: LD_VAR 0 2
7273: PUSH
7274: LD_VAR 0 3
7278: ARRAY
7279: PUSH
7280: LD_INT 21
7282: PUSH
7283: LD_INT 22
7285: PUSH
7286: LD_INT 23
7288: PUSH
7289: LD_INT 24
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: LIST
7296: LIST
7297: IN
7298: IFFALSE 7310
// uc_nation := nation_russian else
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 3
7307: ST_TO_ADDR
7308: GO 7318
// uc_nation := nation_arabian ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 2
7317: ST_TO_ADDR
// vc_chassis := tab [ i ] ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_VAR 0 2
7327: PUSH
7328: LD_VAR 0 3
7332: ARRAY
7333: ST_TO_ADDR
// vc_engine := tab [ i + 1 ] ;
7334: LD_ADDR_OWVAR 39
7338: PUSH
7339: LD_VAR 0 2
7343: PUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: PLUS
7352: ARRAY
7353: ST_TO_ADDR
// vc_control := tab [ i + 2 ] ;
7354: LD_ADDR_OWVAR 38
7358: PUSH
7359: LD_VAR 0 2
7363: PUSH
7364: LD_VAR 0 3
7368: PUSH
7369: LD_INT 2
7371: PLUS
7372: ARRAY
7373: ST_TO_ADDR
// vc_weapon := tab [ i + 3 ] ;
7374: LD_ADDR_OWVAR 40
7378: PUSH
7379: LD_VAR 0 2
7383: PUSH
7384: LD_VAR 0 3
7388: PUSH
7389: LD_INT 3
7391: PLUS
7392: ARRAY
7393: ST_TO_ADDR
// veh := CreateVehicle ;
7394: LD_ADDR_VAR 0 5
7398: PUSH
7399: CALL_OW 45
7403: ST_TO_ADDR
// if GetControl ( veh ) = control_manual then
7404: LD_VAR 0 5
7408: PPUSH
7409: CALL_OW 263
7413: PUSH
7414: LD_INT 1
7416: EQUAL
7417: IFFALSE 7435
// ar_vehicles := ar_vehicles ^ veh ;
7419: LD_ADDR_EXP 44
7423: PUSH
7424: LD_EXP 44
7428: PUSH
7429: LD_VAR 0 5
7433: ADD
7434: ST_TO_ADDR
// SetDir ( veh , 0 ) ;
7435: LD_VAR 0 5
7439: PPUSH
7440: LD_INT 0
7442: PPUSH
7443: CALL_OW 233
// PlaceUnitArea ( veh , veh_start , false ) ;
7447: LD_VAR 0 5
7451: PPUSH
7452: LD_INT 6
7454: PPUSH
7455: LD_INT 0
7457: PPUSH
7458: CALL_OW 49
// SetFuel ( veh , Rand ( 1 , 11 ) ) ;
7462: LD_VAR 0 5
7466: PPUSH
7467: LD_INT 1
7469: PPUSH
7470: LD_INT 11
7472: PPUSH
7473: CALL_OW 12
7477: PPUSH
7478: CALL_OW 240
// if GetWeapon ( veh ) = ar_cargo_bay or GetWeapon ( veh ) = ru_cargo_bay then
7482: LD_VAR 0 5
7486: PPUSH
7487: CALL_OW 264
7491: PUSH
7492: LD_INT 32
7494: EQUAL
7495: PUSH
7496: LD_VAR 0 5
7500: PPUSH
7501: CALL_OW 264
7505: PUSH
7506: LD_INT 51
7508: EQUAL
7509: OR
7510: IFFALSE 7527
// SetCargo ( veh , 3 , 100 ) ;
7512: LD_VAR 0 5
7516: PPUSH
7517: LD_INT 3
7519: PPUSH
7520: LD_INT 100
7522: PPUSH
7523: CALL_OW 290
// p := p + 1 ;
7527: LD_ADDR_VAR 0 4
7531: PUSH
7532: LD_VAR 0 4
7536: PUSH
7537: LD_INT 1
7539: PLUS
7540: ST_TO_ADDR
// i := i + 4 ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PUSH
7551: LD_INT 4
7553: PLUS
7554: ST_TO_ADDR
// end ;
7555: GO 7257
// if FilterAllUnits ( [ f_weapon , ar_control_tower ] ) = 0 then
7557: LD_INT 34
7559: PUSH
7560: LD_INT 31
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PPUSH
7567: CALL_OW 69
7571: PUSH
7572: LD_INT 0
7574: EQUAL
7575: IFFALSE 7624
// begin while ( FilterAllUnits ( [ f_control , control_remote ] ) > 0 ) do
7577: LD_INT 33
7579: PUSH
7580: LD_INT 2
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 69
7591: PUSH
7592: LD_INT 0
7594: GREATER
7595: IFFALSE 7622
// RemoveUnit ( FilterAllUnits ( [ f_control , control_remote ] ) [ 1 ] ) ;
7597: LD_INT 33
7599: PUSH
7600: LD_INT 2
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL_OW 69
7611: PUSH
7612: LD_INT 1
7614: ARRAY
7615: PPUSH
7616: CALL_OW 64
7620: GO 7577
// end else
7622: GO 7689
// if FilterAllUnits ( [ f_control , control_remote ] ) > 3 then
7624: LD_INT 33
7626: PUSH
7627: LD_INT 2
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PPUSH
7634: CALL_OW 69
7638: PUSH
7639: LD_INT 3
7641: GREATER
7642: IFFALSE 7689
// while ( FilterAllUnits ( [ f_control , control_remote ] ) > 3 ) do
7644: LD_INT 33
7646: PUSH
7647: LD_INT 2
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: CALL_OW 69
7658: PUSH
7659: LD_INT 3
7661: GREATER
7662: IFFALSE 7689
// RemoveUnit ( FilterAllUnits ( [ f_control , control_remote ] ) [ 1 ] ) ;
7664: LD_INT 33
7666: PUSH
7667: LD_INT 2
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PPUSH
7674: CALL_OW 69
7678: PUSH
7679: LD_INT 1
7681: ARRAY
7682: PPUSH
7683: CALL_OW 64
7687: GO 7644
// LoadPeople ;
7689: CALL 6021 0 0
// PlaceUnitArea ( Louis , hum_start , false ) ;
7693: LD_EXP 27
7697: PPUSH
7698: LD_INT 7
7700: PPUSH
7701: LD_INT 0
7703: PPUSH
7704: CALL_OW 49
// for i = 2 to ar_pep do
7708: LD_ADDR_VAR 0 3
7712: PUSH
7713: DOUBLE
7714: LD_INT 2
7716: DEC
7717: ST_TO_ADDR
7718: LD_EXP 34
7722: PUSH
7723: FOR_TO
7724: IFFALSE 7803
// begin if UnitFilter ( ar_vehicles , [ f_empty ] ) then
7726: LD_EXP 44
7730: PPUSH
7731: LD_INT 58
7733: PUSH
7734: EMPTY
7735: LIST
7736: PPUSH
7737: CALL_OW 72
7741: IFFALSE 7780
// PlaceHumanInUnit ( ar_pep [ i ] , UnitFilter ( ar_vehicles , [ f_empty ] ) [ 1 ] ) else
7743: LD_EXP 34
7747: PUSH
7748: LD_VAR 0 3
7752: ARRAY
7753: PPUSH
7754: LD_EXP 44
7758: PPUSH
7759: LD_INT 58
7761: PUSH
7762: EMPTY
7763: LIST
7764: PPUSH
7765: CALL_OW 72
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: CALL_OW 52
7778: GO 7801
// PlaceUnitArea ( ar_pep [ i ] , hum_start , false ) ;
7780: LD_EXP 34
7784: PUSH
7785: LD_VAR 0 3
7789: ARRAY
7790: PPUSH
7791: LD_INT 7
7793: PPUSH
7794: LD_INT 0
7796: PPUSH
7797: CALL_OW 49
// end ;
7801: GO 7723
7803: POP
7804: POP
// end ; end_of_file
7805: LD_VAR 0 1
7809: RET
// export Shariff ; export function Action ; var un , un2 , filter ; begin
7810: LD_INT 0
7812: PPUSH
7813: PPUSH
7814: PPUSH
7815: PPUSH
// uc_side := 5 ;
7816: LD_ADDR_OWVAR 20
7820: PUSH
7821: LD_INT 5
7823: ST_TO_ADDR
// Shariff := NewCharacter ( Abdul ) ;
7824: LD_ADDR_EXP 45
7828: PUSH
7829: LD_STRING Abdul
7831: PPUSH
7832: CALL_OW 25
7836: ST_TO_ADDR
// SetClass ( Shariff , class_desert_warior ) ;
7837: LD_EXP 45
7841: PPUSH
7842: LD_INT 11
7844: PPUSH
7845: CALL_OW 336
// CenterNowOnUnits ( Louis ) ;
7849: LD_EXP 27
7853: PPUSH
7854: CALL_OW 87
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
7858: LD_ADDR_VAR 0 4
7862: PUSH
7863: LD_INT 22
7865: PUSH
7866: LD_INT 2
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: LD_INT 21
7875: PUSH
7876: LD_INT 1
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 69
7891: ST_TO_ADDR
// if not IsLive ( Rolf ) then
7892: LD_EXP 28
7896: PPUSH
7897: CALL_OW 300
7901: NOT
7902: IFFALSE 7920
// un := filter [ 1 ] else
7904: LD_ADDR_VAR 0 2
7908: PUSH
7909: LD_VAR 0 4
7913: PUSH
7914: LD_INT 1
7916: ARRAY
7917: ST_TO_ADDR
7918: GO 7930
// un := Rolf ;
7920: LD_ADDR_VAR 0 2
7924: PUSH
7925: LD_EXP 28
7929: ST_TO_ADDR
// if not IsLive ( Gali ) then
7930: LD_EXP 33
7934: PPUSH
7935: CALL_OW 300
7939: NOT
7940: IFFALSE 7958
// un2 := filter [ 2 ] else
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_VAR 0 4
7951: PUSH
7952: LD_INT 2
7954: ARRAY
7955: ST_TO_ADDR
7956: GO 7968
// un2 := Gali ;
7958: LD_ADDR_VAR 0 3
7962: PUSH
7963: LD_EXP 33
7967: ST_TO_ADDR
// InGameOn ;
7968: CALL_OW 8
// ComTurnUnit ( Louis , un ) ;
7972: LD_EXP 27
7976: PPUSH
7977: LD_VAR 0 2
7981: PPUSH
7982: CALL_OW 119
// ComTurnUnit ( un , Louis ) ;
7986: LD_VAR 0 2
7990: PPUSH
7991: LD_EXP 27
7995: PPUSH
7996: CALL_OW 119
// Say ( un , 09_DRolf1 ) ;
8000: LD_VAR 0 2
8004: PPUSH
8005: LD_STRING 09_DRolf1
8007: PPUSH
8008: CALL_OW 88
// Say ( Louis , 09_DLouis1 ) ;
8012: LD_EXP 27
8016: PPUSH
8017: LD_STRING 09_DLouis1
8019: PPUSH
8020: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
8024: LD_INT 18
8026: PPUSH
8027: CALL_OW 67
// SayRadio ( Shariff , 09_DShariff1 ) ;
8031: LD_EXP 45
8035: PPUSH
8036: LD_STRING 09_DShariff1
8038: PPUSH
8039: CALL_OW 94
// Say ( Louis , 09_DLouis2 ) ;
8043: LD_EXP 27
8047: PPUSH
8048: LD_STRING 09_DLouis2
8050: PPUSH
8051: CALL_OW 88
// SayRadio ( Shariff , 09_DShariff2 ) ;
8055: LD_EXP 45
8059: PPUSH
8060: LD_STRING 09_DShariff2
8062: PPUSH
8063: CALL_OW 94
// Say ( Louis , 09_DLouis3 ) ;
8067: LD_EXP 27
8071: PPUSH
8072: LD_STRING 09_DLouis3
8074: PPUSH
8075: CALL_OW 88
// SayRadio ( Shariff , 09_DShariff3 ) ;
8079: LD_EXP 45
8083: PPUSH
8084: LD_STRING 09_DShariff3
8086: PPUSH
8087: CALL_OW 94
// Say ( un , 09_DRolf2 ) ;
8091: LD_VAR 0 2
8095: PPUSH
8096: LD_STRING 09_DRolf2
8098: PPUSH
8099: CALL_OW 88
// Say ( un2 , 09_DGali1 ) ;
8103: LD_VAR 0 3
8107: PPUSH
8108: LD_STRING 09_DGali1
8110: PPUSH
8111: CALL_OW 88
// Say ( un , 09_DRolf3 ) ;
8115: LD_VAR 0 2
8119: PPUSH
8120: LD_STRING 09_DRolf3
8122: PPUSH
8123: CALL_OW 88
// Say ( Louis , 09_DLouis4 ) ;
8127: LD_EXP 27
8131: PPUSH
8132: LD_STRING 09_DLouis4
8134: PPUSH
8135: CALL_OW 88
// if rus_var = 0 then
8139: LD_EXP 38
8143: PUSH
8144: LD_INT 0
8146: EQUAL
8147: IFFALSE 8161
// Say ( Louis , 09_DLouis-cargo ) ;
8149: LD_EXP 27
8153: PPUSH
8154: LD_STRING 09_DLouis-cargo
8156: PPUSH
8157: CALL_OW 88
// InGameOff ;
8161: CALL_OW 9
// if rus_var = 0 then
8165: LD_EXP 38
8169: PUSH
8170: LD_INT 0
8172: EQUAL
8173: IFFALSE 8184
// ChangeMissionObjectives ( UsACar ) else
8175: LD_STRING UsACar
8177: PPUSH
8178: CALL_OW 337
8182: GO 8191
// ChangeMissionObjectives ( Us ) ;
8184: LD_STRING Us
8186: PPUSH
8187: CALL_OW 337
// game_counter := 1 ;
8191: LD_ADDR_EXP 40
8195: PUSH
8196: LD_INT 1
8198: ST_TO_ADDR
// SaveForQuickRestart ;
8199: CALL_OW 22
// end ;
8203: LD_VAR 0 1
8207: RET
// every 0 0$01 trigger game_counter > 0 do
8208: LD_EXP 40
8212: PUSH
8213: LD_INT 0
8215: GREATER
8216: IFFALSE 8236
8218: GO 8220
8220: DISABLE
// begin enable ;
8221: ENABLE
// game_counter := game_counter + 1 ;
8222: LD_ADDR_EXP 40
8226: PUSH
8227: LD_EXP 40
8231: PUSH
8232: LD_INT 1
8234: PLUS
8235: ST_TO_ADDR
// end ;
8236: END
// every 0 0$01 trigger ( rus_var = 0 and game_counter >= Rand ( 86 , 120 ) ) or ( us_contact ) do
8237: LD_EXP 38
8241: PUSH
8242: LD_INT 0
8244: EQUAL
8245: PUSH
8246: LD_EXP 40
8250: PUSH
8251: LD_INT 86
8253: PPUSH
8254: LD_INT 120
8256: PPUSH
8257: CALL_OW 12
8261: GREATEREQUAL
8262: AND
8263: PUSH
8264: LD_EXP 24
8268: OR
8269: IFFALSE 8309
8271: GO 8273
8273: DISABLE
// begin DialogueOn ;
8274: CALL_OW 6
// SayRadio ( us_comander , 09_DUs1 ) ;
8278: LD_EXP 25
8282: PPUSH
8283: LD_STRING 09_DUs1
8285: PPUSH
8286: CALL_OW 94
// DialogueOff ;
8290: CALL_OW 7
// SpawnUSF ( 0 ) ;
8294: LD_INT 0
8296: PPUSH
8297: CALL 4100 0 1
// us_attack := 2 ;
8301: LD_ADDR_EXP 23
8305: PUSH
8306: LD_INT 2
8308: ST_TO_ADDR
// end ;
8309: END
// every 0 0$01 trigger tick > 5 5$00 and us_contact = false do var tmp ;
8310: LD_OWVAR 1
8314: PUSH
8315: LD_INT 10500
8317: GREATER
8318: PUSH
8319: LD_EXP 24
8323: PUSH
8324: LD_INT 0
8326: EQUAL
8327: AND
8328: IFFALSE 8430
8330: GO 8332
8332: DISABLE
8333: LD_INT 0
8335: PPUSH
// begin DialogueOn ;
8336: CALL_OW 6
// if IsLive ( Gali ) then
8340: LD_EXP 33
8344: PPUSH
8345: CALL_OW 300
8349: IFFALSE 8363
// tmp := Gali else
8351: LD_ADDR_VAR 0 1
8355: PUSH
8356: LD_EXP 33
8360: ST_TO_ADDR
8361: GO 8377
// tmp := ar_pep [ 3 ] ;
8363: LD_ADDR_VAR 0 1
8367: PUSH
8368: LD_EXP 34
8372: PUSH
8373: LD_INT 3
8375: ARRAY
8376: ST_TO_ADDR
// Say ( tmp , 09_usnotattack ) ;
8377: LD_VAR 0 1
8381: PPUSH
8382: LD_STRING 09_usnotattack
8384: PPUSH
8385: CALL_OW 88
// if IsLive ( Rolf ) then
8389: LD_EXP 28
8393: PPUSH
8394: CALL_OW 300
8398: IFFALSE 8414
// Say ( Rolf , 09_DRusno ) else
8400: LD_EXP 28
8404: PPUSH
8405: LD_STRING 09_DRusno
8407: PPUSH
8408: CALL_OW 88
8412: GO 8426
// Say ( Louis , 09_DLusno ) ;
8414: LD_EXP 27
8418: PPUSH
8419: LD_STRING 09_DLusno
8421: PPUSH
8422: CALL_OW 88
// DialogueOff ;
8426: CALL_OW 7
// end ;
8430: PPOPN 1
8432: END
// every 0 0$01 trigger tick > [ 13 13$00 , 12 12$00 , 11 11$00 ] [ Difficulty ] and us_contact = false do
8433: LD_OWVAR 1
8437: PUSH
8438: LD_INT 27300
8440: PUSH
8441: LD_INT 25200
8443: PUSH
8444: LD_INT 23100
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_OWVAR 67
8456: ARRAY
8457: GREATER
8458: PUSH
8459: LD_EXP 24
8463: PUSH
8464: LD_INT 0
8466: EQUAL
8467: AND
8468: IFFALSE 8481
8470: GO 8472
8472: DISABLE
// begin us_contact := true ;
8473: LD_ADDR_EXP 24
8477: PUSH
8478: LD_INT 1
8480: ST_TO_ADDR
// end ;
8481: END
// every 0 0$01 trigger SeeSniper ( 1 ) do
8482: LD_INT 1
8484: PPUSH
8485: CALL 10512 0 1
8489: IFFALSE 8506
8491: GO 8493
8493: DISABLE
// begin Say ( Louis , 09_DLsniper ) ;
8494: LD_EXP 27
8498: PPUSH
8499: LD_STRING 09_DLsniper
8501: PPUSH
8502: CALL_OW 88
// end ;
8506: END
// every 0 0$01 trigger game_counter >= 62 do var i , un , veh , filter ;
8507: LD_EXP 40
8511: PUSH
8512: LD_INT 62
8514: GREATEREQUAL
8515: IFFALSE 9124
8517: GO 8519
8519: DISABLE
8520: LD_INT 0
8522: PPUSH
8523: PPUSH
8524: PPUSH
8525: PPUSH
// begin uc_side := 5 ;
8526: LD_ADDR_OWVAR 20
8530: PUSH
8531: LD_INT 5
8533: ST_TO_ADDR
// uc_nation := nation_arabian ;
8534: LD_ADDR_OWVAR 21
8538: PUSH
8539: LD_INT 2
8541: ST_TO_ADDR
// filter := [ ] ;
8542: LD_ADDR_VAR 0 4
8546: PUSH
8547: EMPTY
8548: ST_TO_ADDR
// for i = 1 to 2 do
8549: LD_ADDR_VAR 0 1
8553: PUSH
8554: DOUBLE
8555: LD_INT 1
8557: DEC
8558: ST_TO_ADDR
8559: LD_INT 2
8561: PUSH
8562: FOR_TO
8563: IFFALSE 8723
// begin PrepareHuman ( sex_male , i , 6 ) ;
8565: LD_INT 1
8567: PPUSH
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 6
8575: PPUSH
8576: CALL_OW 380
// RandFacesAndNames ( ) ;
8580: CALL 4060 0 0
// un := CreateHuman ;
8584: LD_ADDR_VAR 0 2
8588: PUSH
8589: CALL_OW 44
8593: ST_TO_ADDR
// filter := filter ^ un ;
8594: LD_ADDR_VAR 0 4
8598: PUSH
8599: LD_VAR 0 4
8603: PUSH
8604: LD_VAR 0 2
8608: ADD
8609: ST_TO_ADDR
// vc_chassis := ar_hovercraft ;
8610: LD_ADDR_OWVAR 37
8614: PUSH
8615: LD_INT 11
8617: ST_TO_ADDR
// vc_engine := engine_combustion ;
8618: LD_ADDR_OWVAR 39
8622: PUSH
8623: LD_INT 1
8625: ST_TO_ADDR
// vc_control := control_manual ;
8626: LD_ADDR_OWVAR 38
8630: PUSH
8631: LD_INT 1
8633: ST_TO_ADDR
// vc_weapon := ar_light_gun ;
8634: LD_ADDR_OWVAR 40
8638: PUSH
8639: LD_INT 23
8641: ST_TO_ADDR
// veh := CreateVehicle ;
8642: LD_ADDR_VAR 0 3
8646: PUSH
8647: CALL_OW 45
8651: ST_TO_ADDR
// filter := filter ^ veh ;
8652: LD_ADDR_VAR 0 4
8656: PUSH
8657: LD_VAR 0 4
8661: PUSH
8662: LD_VAR 0 3
8666: ADD
8667: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_INT 4
8675: PPUSH
8676: CALL_OW 233
// PlaceUnitArea ( veh , ar_water , false ) ;
8680: LD_VAR 0 3
8684: PPUSH
8685: LD_INT 11
8687: PPUSH
8688: LD_INT 0
8690: PPUSH
8691: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
8695: LD_VAR 0 2
8699: PPUSH
8700: LD_VAR 0 3
8704: PPUSH
8705: CALL_OW 52
// SetFuel ( veh , 44 ) ;
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_INT 44
8716: PPUSH
8717: CALL_OW 240
// end ;
8721: GO 8562
8723: POP
8724: POP
// repeat begin Wait ( 0 0$01 ) ;
8725: LD_INT 35
8727: PPUSH
8728: CALL_OW 67
// for i = 1 to filter do
8732: LD_ADDR_VAR 0 1
8736: PUSH
8737: DOUBLE
8738: LD_INT 1
8740: DEC
8741: ST_TO_ADDR
8742: LD_VAR 0 4
8746: PUSH
8747: FOR_TO
8748: IFFALSE 8805
// if not HasTask ( filter [ i ] ) then
8750: LD_VAR 0 4
8754: PUSH
8755: LD_VAR 0 1
8759: ARRAY
8760: PPUSH
8761: CALL_OW 314
8765: NOT
8766: IFFALSE 8803
// ComMoveXY ( filter [ i ] , GetX ( Louis ) , GetY ( Louis ) ) ;
8768: LD_VAR 0 4
8772: PUSH
8773: LD_VAR 0 1
8777: ARRAY
8778: PPUSH
8779: LD_EXP 27
8783: PPUSH
8784: CALL_OW 250
8788: PPUSH
8789: LD_EXP 27
8793: PPUSH
8794: CALL_OW 251
8798: PPUSH
8799: CALL_OW 111
8803: GO 8747
8805: POP
8806: POP
// end until GetDistUnits ( filter [ 1 ] , Louis ) < 7 ;
8807: LD_VAR 0 4
8811: PUSH
8812: LD_INT 1
8814: ARRAY
8815: PPUSH
8816: LD_EXP 27
8820: PPUSH
8821: CALL_OW 296
8825: PUSH
8826: LD_INT 7
8828: LESS
8829: IFFALSE 8725
// Say ( ar_pep [ Rand ( 2 , 4 ) ] , 09_dwarn ) ;
8831: LD_EXP 34
8835: PUSH
8836: LD_INT 2
8838: PPUSH
8839: LD_INT 4
8841: PPUSH
8842: CALL_OW 12
8846: ARRAY
8847: PPUSH
8848: LD_STRING 09_dwarn
8850: PPUSH
8851: CALL_OW 88
// Wait ( 0 0$01 ) ;
8855: LD_INT 35
8857: PPUSH
8858: CALL_OW 67
// SetSide ( filter , 2 ) ;
8862: LD_VAR 0 4
8866: PPUSH
8867: LD_INT 2
8869: PPUSH
8870: CALL_OW 235
// CenterNowOnUnits ( filter [ 1 ] ) ;
8874: LD_VAR 0 4
8878: PUSH
8879: LD_INT 1
8881: ARRAY
8882: PPUSH
8883: CALL_OW 87
// DialogueOn ;
8887: CALL_OW 6
// Say ( filter [ 1 ] , 09_DArR ) ;
8891: LD_VAR 0 4
8895: PUSH
8896: LD_INT 1
8898: ARRAY
8899: PPUSH
8900: LD_STRING 09_DArR
8902: PPUSH
8903: CALL_OW 88
// DWait ( 0 0$0.2 ) ;
8907: LD_INT 7
8909: PPUSH
8910: CALL_OW 68
// Say ( Louis , 09_DL-hov1 ) ;
8914: LD_EXP 27
8918: PPUSH
8919: LD_STRING 09_DL-hov1
8921: PPUSH
8922: CALL_OW 88
// Say ( filter [ 1 ] , 09_DI-hov1 ) ;
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: ARRAY
8934: PPUSH
8935: LD_STRING 09_DI-hov1
8937: PPUSH
8938: CALL_OW 88
// Say ( Louis , 09_DL-hov2 ) ;
8942: LD_EXP 27
8946: PPUSH
8947: LD_STRING 09_DL-hov2
8949: PPUSH
8950: CALL_OW 88
// if IsLive ( Rolf ) then
8954: LD_EXP 28
8958: PPUSH
8959: CALL_OW 300
8963: IFFALSE 8979
// Say ( Rolf , 09_DR-hov1 ) else
8965: LD_EXP 28
8969: PPUSH
8970: LD_STRING 09_DR-hov1
8972: PPUSH
8973: CALL_OW 88
8977: GO 8995
// Say ( ar_pep [ 3 ] , 09_DR-hov1 ) ;
8979: LD_EXP 34
8983: PUSH
8984: LD_INT 3
8986: ARRAY
8987: PPUSH
8988: LD_STRING 09_DR-hov1
8990: PPUSH
8991: CALL_OW 88
// Say ( Louis , 09_DL-hov3 ) ;
8995: LD_EXP 27
8999: PPUSH
9000: LD_STRING 09_DL-hov3
9002: PPUSH
9003: CALL_OW 88
// if IsLive ( Mike ) then
9007: LD_EXP 32
9011: PPUSH
9012: CALL_OW 300
9016: IFFALSE 9030
// Say ( Mike , 09_DI-hov2 ) ;
9018: LD_EXP 32
9022: PPUSH
9023: LD_STRING 09_DI-hov2
9025: PPUSH
9026: CALL_OW 88
// Say ( Louis , 09_DL-hov4 ) ;
9030: LD_EXP 27
9034: PPUSH
9035: LD_STRING 09_DL-hov4
9037: PPUSH
9038: CALL_OW 88
// if IsLive ( Rolf ) then
9042: LD_EXP 28
9046: PPUSH
9047: CALL_OW 300
9051: IFFALSE 9067
// Say ( Rolf , 09_DR-hov2 ) else
9053: LD_EXP 28
9057: PPUSH
9058: LD_STRING 09_DR-hov2
9060: PPUSH
9061: CALL_OW 88
9065: GO 9083
// Say ( ar_pep [ 3 ] , 09_DR-hov2 ) ;
9067: LD_EXP 34
9071: PUSH
9072: LD_INT 3
9074: ARRAY
9075: PPUSH
9076: LD_STRING 09_DR-hov2
9078: PPUSH
9079: CALL_OW 88
// if IsLive ( Gali ) then
9083: LD_EXP 33
9087: PPUSH
9088: CALL_OW 300
9092: IFFALSE 9106
// Say ( Gali , 09_DI-hov3 ) ;
9094: LD_EXP 33
9098: PPUSH
9099: LD_STRING 09_DI-hov3
9101: PPUSH
9102: CALL_OW 88
// DialogueOff ;
9106: CALL_OW 7
// ChangeMissionObjectives ( hover ) ;
9110: LD_STRING hover
9112: PPUSH
9113: CALL_OW 337
// Hint ( hovercraft ) ;
9117: LD_STRING hovercraft
9119: PPUSH
9120: CALL_OW 339
// end ;
9124: PPOPN 4
9126: END
// export prisons ; every 0 0$01 trigger GetDistUnits ( Louis , us_prison ) < 6 do
9127: LD_EXP 27
9131: PPUSH
9132: LD_INT 63
9134: PPUSH
9135: CALL_OW 296
9139: PUSH
9140: LD_INT 6
9142: LESS
9143: IFFALSE 9265
9145: GO 9147
9147: DISABLE
// begin prisons := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) ;
9148: LD_ADDR_EXP 46
9152: PUSH
9153: LD_INT 22
9155: PUSH
9156: LD_INT 5
9158: PUSH
9159: EMPTY
9160: LIST
9161: LIST
9162: PUSH
9163: LD_INT 21
9165: PUSH
9166: LD_INT 1
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: PUSH
9173: EMPTY
9174: LIST
9175: LIST
9176: PPUSH
9177: CALL_OW 69
9181: ST_TO_ADDR
// if GetSex ( prisons [ 1 ] ) = sex_male then
9182: LD_EXP 46
9186: PUSH
9187: LD_INT 1
9189: ARRAY
9190: PPUSH
9191: CALL_OW 258
9195: PUSH
9196: LD_INT 1
9198: EQUAL
9199: IFFALSE 9219
// Say ( prisons [ 1 ] , 09_DPrm ) else
9201: LD_EXP 46
9205: PUSH
9206: LD_INT 1
9208: ARRAY
9209: PPUSH
9210: LD_STRING 09_DPrm
9212: PPUSH
9213: CALL_OW 88
9217: GO 9235
// Say ( prisons [ 1 ] , 09_DPrw ) ;
9219: LD_EXP 46
9223: PUSH
9224: LD_INT 1
9226: ARRAY
9227: PPUSH
9228: LD_STRING 09_DPrw
9230: PPUSH
9231: CALL_OW 88
// SetSide ( FilterAllUnits ( [ f_side , 5 ] ) , 2 ) ;
9235: LD_INT 22
9237: PUSH
9238: LD_INT 5
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 69
9249: PPUSH
9250: LD_INT 2
9252: PPUSH
9253: CALL_OW 235
// prison_event := true ;
9257: LD_ADDR_EXP 43
9261: PUSH
9262: LD_INT 1
9264: ST_TO_ADDR
// end ;
9265: END
// every 0 0$01 trigger FilterUnitsInArea ( beach , [ f_chassis , ar_hovercraft ] ) > 0 do
9266: LD_INT 13
9268: PPUSH
9269: LD_INT 31
9271: PUSH
9272: LD_INT 11
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: PPUSH
9279: CALL_OW 70
9283: PUSH
9284: LD_INT 0
9286: GREATER
9287: IFFALSE 9300
9289: GO 9291
9291: DISABLE
// dday_event := true ;
9292: LD_ADDR_EXP 42
9296: PUSH
9297: LD_INT 1
9299: ST_TO_ADDR
9300: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
9301: LD_INT 22
9303: PUSH
9304: LD_INT 1
9306: PUSH
9307: EMPTY
9308: LIST
9309: LIST
9310: PPUSH
9311: CALL_OW 69
9315: PUSH
9316: LD_INT 0
9318: EQUAL
9319: IFFALSE 9371
9321: GO 9323
9323: DISABLE
// begin InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// Say ( Louis , 09_DL-win ) ;
9332: LD_EXP 27
9336: PPUSH
9337: LD_STRING 09_DL-win
9339: PPUSH
9340: CALL_OW 88
// if IsLive ( Rolf ) then
9344: LD_EXP 28
9348: PPUSH
9349: CALL_OW 300
9353: IFFALSE 9367
// Say ( Rolf , 09_DR-win ) ;
9355: LD_EXP 28
9359: PPUSH
9360: LD_STRING 09_DR-win
9362: PPUSH
9363: CALL_OW 88
// END_MISSION ;
9367: CALL 9372 0 0
// end ; end_of_file
9371: END
// export function END_MISSION ; var names , filter , i , tab , name ; begin
9372: LD_INT 0
9374: PPUSH
9375: PPUSH
9376: PPUSH
9377: PPUSH
9378: PPUSH
9379: PPUSH
// tab := [ ] ;
9380: LD_ADDR_VAR 0 5
9384: PUSH
9385: EMPTY
9386: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
9387: LD_ADDR_VAR 0 3
9391: PUSH
9392: LD_INT 22
9394: PUSH
9395: LD_INT 2
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 21
9404: PUSH
9405: LD_INT 2
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 3
9414: PUSH
9415: LD_INT 58
9417: PUSH
9418: EMPTY
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: LIST
9429: PPUSH
9430: CALL_OW 69
9434: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_cargo_bay ] ] ) >= 2 then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 2
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 34
9447: PUSH
9448: LD_INT 32
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: PUSH
9464: LD_INT 2
9466: GREATEREQUAL
9467: IFFALSE 9481
// AddMedal ( med1 , 1 ) else
9469: LD_STRING med1
9471: PPUSH
9472: LD_INT 1
9474: PPUSH
9475: CALL_OW 101
9479: GO 9492
// AddMedal ( med1 , - 1 ) ;
9481: LD_STRING med1
9483: PPUSH
9484: LD_INT 1
9486: NEG
9487: PPUSH
9488: CALL_OW 101
// if dday_event then
9492: LD_EXP 42
9496: IFFALSE 9510
// AddMedal ( med2 , 1 ) else
9498: LD_STRING med2
9500: PPUSH
9501: LD_INT 1
9503: PPUSH
9504: CALL_OW 101
9508: GO 9521
// AddMedal ( med2 , - 1 ) ;
9510: LD_STRING med2
9512: PPUSH
9513: LD_INT 1
9515: NEG
9516: PPUSH
9517: CALL_OW 101
// if prison_event then
9521: LD_EXP 43
9525: IFFALSE 9539
// AddMedal ( med3 , 1 ) else
9527: LD_STRING med3
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: CALL_OW 101
9537: GO 9550
// AddMedal ( med3 , - 1 ) ;
9539: LD_STRING med3
9541: PPUSH
9542: LD_INT 1
9544: NEG
9545: PPUSH
9546: CALL_OW 101
// GiveMedals ( MAIN ) ;
9550: LD_STRING MAIN
9552: PPUSH
9553: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ) ;
9557: LD_INT 22
9559: PUSH
9560: LD_INT 2
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: PUSH
9567: LD_INT 21
9569: PUSH
9570: LD_INT 1
9572: PUSH
9573: EMPTY
9574: LIST
9575: LIST
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PPUSH
9581: CALL_OW 69
9585: PPUSH
9586: CALL_OW 43
// SaveCharacters ( Louis , Louis ) ;
9590: LD_EXP 27
9594: PPUSH
9595: LD_STRING Louis
9597: PPUSH
9598: CALL_OW 38
// if Rolf then
9602: LD_EXP 28
9606: IFFALSE 9620
// begin SaveCharacters ( Rolf , Rolf_09c ) ;
9608: LD_EXP 28
9612: PPUSH
9613: LD_STRING Rolf_09c
9615: PPUSH
9616: CALL_OW 38
// end ; if Jenna then
9620: LD_EXP 29
9624: IFFALSE 9638
// begin SaveCharacters ( Jenna , Jenna_09c ) ;
9626: LD_EXP 29
9630: PPUSH
9631: LD_STRING Jenna_09c
9633: PPUSH
9634: CALL_OW 38
// end ; if Rick then
9638: LD_EXP 31
9642: IFFALSE 9656
// begin SaveCharacters ( Rick , Rick_09c ) ;
9644: LD_EXP 31
9648: PPUSH
9649: LD_STRING Rick_09c
9651: PPUSH
9652: CALL_OW 38
// end ; if Mike then
9656: LD_EXP 32
9660: IFFALSE 9674
// begin SaveCharacters ( Mike , Mike_09c ) ;
9662: LD_EXP 32
9666: PPUSH
9667: LD_STRING Mike_09c
9669: PPUSH
9670: CALL_OW 38
// end ; if IsLive ( Nicolas ) then
9674: LD_EXP 30
9678: PPUSH
9679: CALL_OW 300
9683: IFFALSE 9697
// begin SaveCharacters ( Nicolas , Nicolas_09c ) ;
9685: LD_EXP 30
9689: PPUSH
9690: LD_STRING Nicolas_09c
9692: PPUSH
9693: CALL_OW 38
// end ; if Gali then
9697: LD_EXP 33
9701: IFFALSE 9715
// begin SaveCharacters ( Gali , Gali_09c ) ;
9703: LD_EXP 33
9707: PPUSH
9708: LD_STRING Gali_09c
9710: PPUSH
9711: CALL_OW 38
// end ; for i = 1 to 2 do
9715: LD_ADDR_VAR 0 4
9719: PUSH
9720: DOUBLE
9721: LD_INT 1
9723: DEC
9724: ST_TO_ADDR
9725: LD_INT 2
9727: PUSH
9728: FOR_TO
9729: IFFALSE 9924
// begin case GetTag ( ar_pep2 [ i ] ) of 1000 :
9731: LD_EXP 35
9735: PUSH
9736: LD_VAR 0 4
9740: ARRAY
9741: PPUSH
9742: CALL_OW 110
9746: PUSH
9747: LD_INT 1000
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9776
9755: POP
// SaveCharacters ( ar_pep2 [ i ] , Rolf_09c ) ; 1004 :
9756: LD_EXP 35
9760: PUSH
9761: LD_VAR 0 4
9765: ARRAY
9766: PPUSH
9767: LD_STRING Rolf_09c
9769: PPUSH
9770: CALL_OW 38
9774: GO 9922
9776: LD_INT 1004
9778: DOUBLE
9779: EQUAL
9780: IFTRUE 9784
9782: GO 9805
9784: POP
// SaveCharacters ( ar_pep2 [ i ] , Jenna_09c ) ; 1002 :
9785: LD_EXP 35
9789: PUSH
9790: LD_VAR 0 4
9794: ARRAY
9795: PPUSH
9796: LD_STRING Jenna_09c
9798: PPUSH
9799: CALL_OW 38
9803: GO 9922
9805: LD_INT 1002
9807: DOUBLE
9808: EQUAL
9809: IFTRUE 9813
9811: GO 9834
9813: POP
// SaveCharacters ( ar_pep2 [ i ] , Mike_09c ) ; 1001 :
9814: LD_EXP 35
9818: PUSH
9819: LD_VAR 0 4
9823: ARRAY
9824: PPUSH
9825: LD_STRING Mike_09c
9827: PPUSH
9828: CALL_OW 38
9832: GO 9922
9834: LD_INT 1001
9836: DOUBLE
9837: EQUAL
9838: IFTRUE 9842
9840: GO 9863
9842: POP
// SaveCharacters ( ar_pep2 [ i ] , Gali_09c ) ; 1005 :
9843: LD_EXP 35
9847: PUSH
9848: LD_VAR 0 4
9852: ARRAY
9853: PPUSH
9854: LD_STRING Gali_09c
9856: PPUSH
9857: CALL_OW 38
9861: GO 9922
9863: LD_INT 1005
9865: DOUBLE
9866: EQUAL
9867: IFTRUE 9871
9869: GO 9892
9871: POP
// SaveCharacters ( ar_pep2 [ i ] , Rick_09c ) ; 1003 :
9872: LD_EXP 35
9876: PUSH
9877: LD_VAR 0 4
9881: ARRAY
9882: PPUSH
9883: LD_STRING Rick_09c
9885: PPUSH
9886: CALL_OW 38
9890: GO 9922
9892: LD_INT 1003
9894: DOUBLE
9895: EQUAL
9896: IFTRUE 9900
9898: GO 9921
9900: POP
// SaveCharacters ( ar_pep2 [ i ] , Nicolas_09c ) ; end ;
9901: LD_EXP 35
9905: PUSH
9906: LD_VAR 0 4
9910: ARRAY
9911: PPUSH
9912: LD_STRING Nicolas_09c
9914: PPUSH
9915: CALL_OW 38
9919: GO 9922
9921: POP
// end ;
9922: GO 9728
9924: POP
9925: POP
// SetSide ( [ Louis , Rolf , Gali , Nicolas , Jenna , Rick , Mike ] , 5 ) ;
9926: LD_EXP 27
9930: PUSH
9931: LD_EXP 28
9935: PUSH
9936: LD_EXP 33
9940: PUSH
9941: LD_EXP 30
9945: PUSH
9946: LD_EXP 29
9950: PUSH
9951: LD_EXP 31
9955: PUSH
9956: LD_EXP 32
9960: PUSH
9961: EMPTY
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: PPUSH
9970: LD_INT 5
9972: PPUSH
9973: CALL_OW 235
// RemoveUnit ( ar_pep2 [ 1 ] ) ;
9977: LD_EXP 35
9981: PUSH
9982: LD_INT 1
9984: ARRAY
9985: PPUSH
9986: CALL_OW 64
// RemoveUnit ( ar_pep2 [ 2 ] ) ;
9990: LD_EXP 35
9994: PUSH
9995: LD_INT 2
9997: ARRAY
9998: PPUSH
9999: CALL_OW 64
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff ar_pep2 ;
10003: LD_ADDR_VAR 0 3
10007: PUSH
10008: LD_INT 22
10010: PUSH
10011: LD_INT 2
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PUSH
10018: LD_INT 21
10020: PUSH
10021: LD_INT 1
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PPUSH
10032: CALL_OW 69
10036: PUSH
10037: LD_EXP 35
10041: DIFF
10042: ST_TO_ADDR
// names := [ a_09c , b_09c , c_09c , d_09c , e_09c , f_09c , g_09c , h_09c , i_09c , j_09c , k_09c , l_09c , m_09c , n_09c , o_09c , p_09c ] ;
10043: LD_ADDR_VAR 0 2
10047: PUSH
10048: LD_STRING a_09c
10050: PUSH
10051: LD_STRING b_09c
10053: PUSH
10054: LD_STRING c_09c
10056: PUSH
10057: LD_STRING d_09c
10059: PUSH
10060: LD_STRING e_09c
10062: PUSH
10063: LD_STRING f_09c
10065: PUSH
10066: LD_STRING g_09c
10068: PUSH
10069: LD_STRING h_09c
10071: PUSH
10072: LD_STRING i_09c
10074: PUSH
10075: LD_STRING j_09c
10077: PUSH
10078: LD_STRING k_09c
10080: PUSH
10081: LD_STRING l_09c
10083: PUSH
10084: LD_STRING m_09c
10086: PUSH
10087: LD_STRING n_09c
10089: PUSH
10090: LD_STRING o_09c
10092: PUSH
10093: LD_STRING p_09c
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: ST_TO_ADDR
// for i = 1 to filter do
10114: LD_ADDR_VAR 0 4
10118: PUSH
10119: DOUBLE
10120: LD_INT 1
10122: DEC
10123: ST_TO_ADDR
10124: LD_VAR 0 3
10128: PUSH
10129: FOR_TO
10130: IFFALSE 10198
// if IsLive ( filter [ i ] ) and GetClass ( filter [ i ] ) < 11 then
10132: LD_VAR 0 3
10136: PUSH
10137: LD_VAR 0 4
10141: ARRAY
10142: PPUSH
10143: CALL_OW 300
10147: PUSH
10148: LD_VAR 0 3
10152: PUSH
10153: LD_VAR 0 4
10157: ARRAY
10158: PPUSH
10159: CALL_OW 257
10163: PUSH
10164: LD_INT 11
10166: LESS
10167: AND
10168: IFFALSE 10196
// SaveCharacters ( filter [ i ] , names [ i ] ) ;
10170: LD_VAR 0 3
10174: PUSH
10175: LD_VAR 0 4
10179: ARRAY
10180: PPUSH
10181: LD_VAR 0 2
10185: PUSH
10186: LD_VAR 0 4
10190: ARRAY
10191: PPUSH
10192: CALL_OW 38
10196: GO 10129
10198: POP
10199: POP
// YouWin ;
10200: CALL_OW 103
// SetNextMission ( 1 ) ;
10204: LD_INT 1
10206: PPUSH
10207: CALL_OW 536
// end ; end_of_file
10211: LD_VAR 0 1
10215: RET
// export function NearestUnitToSide ( plist , side ) ; var i , tmp , unit ; begin
10216: LD_INT 0
10218: PPUSH
10219: PPUSH
10220: PPUSH
10221: PPUSH
// tmp := 9999 ;
10222: LD_ADDR_VAR 0 5
10226: PUSH
10227: LD_INT 9999
10229: ST_TO_ADDR
// for i = 1 to plist do
10230: LD_ADDR_VAR 0 4
10234: PUSH
10235: DOUBLE
10236: LD_INT 1
10238: DEC
10239: ST_TO_ADDR
10240: LD_VAR 0 1
10244: PUSH
10245: FOR_TO
10246: IFFALSE 10320
// if GetDistUnitToSide ( plist [ i ] , side ) < tmp then
10248: LD_VAR 0 1
10252: PUSH
10253: LD_VAR 0 4
10257: ARRAY
10258: PPUSH
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL 10337 0 2
10268: PUSH
10269: LD_VAR 0 5
10273: LESS
10274: IFFALSE 10318
// begin tmp := GetDistUnitToSide ( plist [ i ] , side ) ;
10276: LD_ADDR_VAR 0 5
10280: PUSH
10281: LD_VAR 0 1
10285: PUSH
10286: LD_VAR 0 4
10290: ARRAY
10291: PPUSH
10292: LD_VAR 0 2
10296: PPUSH
10297: CALL 10337 0 2
10301: ST_TO_ADDR
// unit := plist [ i ] ;
10302: LD_ADDR_VAR 0 6
10306: PUSH
10307: LD_VAR 0 1
10311: PUSH
10312: LD_VAR 0 4
10316: ARRAY
10317: ST_TO_ADDR
// end ;
10318: GO 10245
10320: POP
10321: POP
// result := unit ;
10322: LD_ADDR_VAR 0 3
10326: PUSH
10327: LD_VAR 0 6
10331: ST_TO_ADDR
// end ;
10332: LD_VAR 0 3
10336: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
10342: LD_ADDR_VAR 0 4
10346: PUSH
10347: LD_INT 22
10349: PUSH
10350: LD_VAR 0 2
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PPUSH
10359: CALL_OW 69
10363: PPUSH
10364: LD_VAR 0 1
10368: PPUSH
10369: CALL_OW 74
10373: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
10374: LD_ADDR_VAR 0 5
10378: PUSH
10379: LD_VAR 0 1
10383: PPUSH
10384: LD_VAR 0 4
10388: PPUSH
10389: CALL_OW 296
10393: ST_TO_ADDR
// if dist >= 9999 then
10394: LD_VAR 0 5
10398: PUSH
10399: LD_INT 9999
10401: GREATEREQUAL
10402: IFFALSE 10415
// result := - 1 else
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: NEG
10412: ST_TO_ADDR
10413: GO 10425
// result := dist ;
10415: LD_ADDR_VAR 0 3
10419: PUSH
10420: LD_VAR 0 5
10424: ST_TO_ADDR
// end ;
10425: LD_VAR 0 3
10429: RET
// export function GetDistXYToSide ( x , y , side ) ; var tmp , dist ; begin
10430: LD_INT 0
10432: PPUSH
10433: PPUSH
10434: PPUSH
// tmp := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
10435: LD_ADDR_VAR 0 5
10439: PUSH
10440: LD_INT 22
10442: PUSH
10443: LD_VAR 0 3
10447: PUSH
10448: EMPTY
10449: LIST
10450: LIST
10451: PPUSH
10452: CALL_OW 69
10456: PPUSH
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 2
10466: PPUSH
10467: CALL_OW 73
10471: ST_TO_ADDR
// dist := GetDistUnitXY ( tmp , x , y ) ;
10472: LD_ADDR_VAR 0 6
10476: PUSH
10477: LD_VAR 0 5
10481: PPUSH
10482: LD_VAR 0 1
10486: PPUSH
10487: LD_VAR 0 2
10491: PPUSH
10492: CALL_OW 297
10496: ST_TO_ADDR
// result := dist ;
10497: LD_ADDR_VAR 0 4
10501: PUSH
10502: LD_VAR 0 6
10506: ST_TO_ADDR
// end ;
10507: LD_VAR 0 4
10511: RET
// export function SeeSniper ( side ) ; var i , filter , sniper ; begin
10512: LD_INT 0
10514: PPUSH
10515: PPUSH
10516: PPUSH
10517: PPUSH
// filter := FilterAllUnits ( [ f_side , 2 ] ) ;
10518: LD_ADDR_VAR 0 4
10522: PUSH
10523: LD_INT 22
10525: PUSH
10526: LD_INT 2
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PPUSH
10533: CALL_OW 69
10537: ST_TO_ADDR
// sniper := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] ] ) ;
10538: LD_ADDR_VAR 0 5
10542: PUSH
10543: LD_INT 22
10545: PUSH
10546: LD_INT 1
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: PUSH
10553: LD_INT 25
10555: PUSH
10556: LD_INT 5
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: PPUSH
10567: CALL_OW 69
10571: ST_TO_ADDR
// for i = 1 to filter do
10572: LD_ADDR_VAR 0 3
10576: PUSH
10577: DOUBLE
10578: LD_INT 1
10580: DEC
10581: ST_TO_ADDR
10582: LD_VAR 0 4
10586: PUSH
10587: FOR_TO
10588: IFFALSE 10635
// if UnitShoot ( filter [ i ] ) in sniper then
10590: LD_VAR 0 4
10594: PUSH
10595: LD_VAR 0 3
10599: ARRAY
10600: PPUSH
10601: CALL_OW 504
10605: PUSH
10606: LD_VAR 0 5
10610: IN
10611: IFFALSE 10625
// begin result := true ;
10613: LD_ADDR_VAR 0 2
10617: PUSH
10618: LD_INT 1
10620: ST_TO_ADDR
// break ;
10621: GO 10635
// end else
10623: GO 10633
// result := false ;
10625: LD_ADDR_VAR 0 2
10629: PUSH
10630: LD_INT 0
10632: ST_TO_ADDR
10633: GO 10587
10635: POP
10636: POP
// end ;
10637: LD_VAR 0 2
10641: RET
