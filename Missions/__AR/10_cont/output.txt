// starting var tmp , tmp2 , i ; begin ResetFog ;
   0: CALL_OW 335
// debug := false ;
   4: LD_ADDR_EXP 3
   8: PUSH
   9: LD_INT 0
  11: ST_TO_ADDR
// game := false ;
  12: LD_ADDR_EXP 1
  16: PUSH
  17: LD_INT 0
  19: ST_TO_ADDR
// mines := false ;
  20: LD_ADDR_EXP 2
  24: PUSH
  25: LD_INT 0
  27: ST_TO_ADDR
// ChangeSideFog ( 5 , 2 ) ;
  28: LD_INT 5
  30: PPUSH
  31: LD_INT 2
  33: PPUSH
  34: CALL_OW 343
// CreateApemans ( 6 , west_ape ) ;
  38: LD_INT 6
  40: PPUSH
  41: LD_INT 3
  43: PPUSH
  44: CALL 5163 0 2
// PrepareSouthBase ;
  48: CALL 1769 0 0
// LoadPeople ;
  52: CALL 157 0 0
// PrepareBase ;
  56: CALL 1232 0 0
// PrepareMainCharacters ;
  60: CALL 1575 0 0
// Action ;
  64: CALL 7312 0 0
// if debug then
  68: LD_EXP 3
  72: IFFALSE 103
// begin FogOff ( 2 ) ;
  74: LD_INT 2
  76: PPUSH
  77: CALL_OW 344
// CreateApemans ( 6 , west_ape ) ;
  81: LD_INT 6
  83: PPUSH
  84: LD_INT 3
  86: PPUSH
  87: CALL 5163 0 2
// PrepareMines ( ) ;
  91: CALL 6623 0 0
// Your_Side := 5 ;
  95: LD_ADDR_OWVAR 2
  99: PUSH
 100: LD_INT 5
 102: ST_TO_ADDR
// end ; tmp := [ ] ;
 103: LD_ADDR_VAR 0 1
 107: PUSH
 108: EMPTY
 109: ST_TO_ADDR
// for i = 1 to tmp do
 110: LD_ADDR_VAR 0 3
 114: PUSH
 115: DOUBLE
 116: LD_INT 1
 118: DEC
 119: ST_TO_ADDR
 120: LD_VAR 0 1
 124: PUSH
 125: FOR_TO
 126: IFFALSE 154
// if tmp [ i ] = tmp2 [ i ] then
 128: LD_VAR 0 1
 132: PUSH
 133: LD_VAR 0 3
 137: ARRAY
 138: PUSH
 139: LD_VAR 0 2
 143: PUSH
 144: LD_VAR 0 3
 148: ARRAY
 149: EQUAL
 150: IFFALSE 152
// end ;
 152: GO 125
 154: POP
 155: POP
 156: END
// export game , mines ; export debug ; end_of_file export Louis , Rolf , Jenna , Nicolas , Rick , Mike , Gali , Martin , Karla , Dwein , Joachim , Olaf , Mmark , Herczeg , Mia , Kantor , Ronn , Gunther ; export function LoadPeople ; var p , i , un , names , names2 , filter , main_filter , others , team , ftp , list , veh ; begin
 157: LD_INT 0
 159: PPUSH
 160: PPUSH
 161: PPUSH
 162: PPUSH
 163: PPUSH
 164: PPUSH
 165: PPUSH
 166: PPUSH
 167: PPUSH
 168: PPUSH
 169: PPUSH
 170: PPUSH
 171: PPUSH
// uc_side := 2 ;
 172: LD_ADDR_OWVAR 20
 176: PUSH
 177: LD_INT 2
 179: ST_TO_ADDR
// uc_nation := nation_arabian ;
 180: LD_ADDR_OWVAR 21
 184: PUSH
 185: LD_INT 2
 187: ST_TO_ADDR
// names := [ Louis , Jenna_09c , Gali_09c , Nicolas_09c , Rick_09c , Mike_09c , Rolf_09c , Martin_07 , Karla_07 , Dwein_07 , Joachim_07 , Olaf_07 , Mmark_07 , Herczeg_07 , Kantor_07 , Mia_07 , Ronn_07 , Gunther_07 ] ;
 188: LD_ADDR_VAR 0 5
 192: PUSH
 193: LD_STRING Louis
 195: PUSH
 196: LD_STRING Jenna_09c
 198: PUSH
 199: LD_STRING Gali_09c
 201: PUSH
 202: LD_STRING Nicolas_09c
 204: PUSH
 205: LD_STRING Rick_09c
 207: PUSH
 208: LD_STRING Mike_09c
 210: PUSH
 211: LD_STRING Rolf_09c
 213: PUSH
 214: LD_STRING Martin_07
 216: PUSH
 217: LD_STRING Karla_07
 219: PUSH
 220: LD_STRING Dwein_07
 222: PUSH
 223: LD_STRING Joachim_07
 225: PUSH
 226: LD_STRING Olaf_07
 228: PUSH
 229: LD_STRING Mmark_07
 231: PUSH
 232: LD_STRING Herczeg_07
 234: PUSH
 235: LD_STRING Kantor_07
 237: PUSH
 238: LD_STRING Mia_07
 240: PUSH
 241: LD_STRING Ronn_07
 243: PUSH
 244: LD_STRING Gunther_07
 246: PUSH
 247: EMPTY
 248: LIST
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: LIST
 266: ST_TO_ADDR
// names2 := [ a_09c , b_09c , c_09c , d_09c , e_09c , f_09c , g_09c , h_09c , i_09c , j_09c , k_09c , l_09c , m_09c , n_09c , o_09c , p_09c ] ;
 267: LD_ADDR_VAR 0 6
 271: PUSH
 272: LD_STRING a_09c
 274: PUSH
 275: LD_STRING b_09c
 277: PUSH
 278: LD_STRING c_09c
 280: PUSH
 281: LD_STRING d_09c
 283: PUSH
 284: LD_STRING e_09c
 286: PUSH
 287: LD_STRING f_09c
 289: PUSH
 290: LD_STRING g_09c
 292: PUSH
 293: LD_STRING h_09c
 295: PUSH
 296: LD_STRING i_09c
 298: PUSH
 299: LD_STRING j_09c
 301: PUSH
 302: LD_STRING k_09c
 304: PUSH
 305: LD_STRING l_09c
 307: PUSH
 308: LD_STRING m_09c
 310: PUSH
 311: LD_STRING n_09c
 313: PUSH
 314: LD_STRING o_09c
 316: PUSH
 317: LD_STRING p_09c
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: LIST
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: LIST
 336: LIST
 337: ST_TO_ADDR
// filter := 0 ;
 338: LD_ADDR_VAR 0 7
 342: PUSH
 343: LD_INT 0
 345: ST_TO_ADDR
// ftp := [ ] ;
 346: LD_ADDR_VAR 0 11
 350: PUSH
 351: EMPTY
 352: ST_TO_ADDR
// others := [ ] ;
 353: LD_ADDR_VAR 0 9
 357: PUSH
 358: EMPTY
 359: ST_TO_ADDR
// Louis := CreateCharacter ( Louis ) ;
 360: LD_ADDR_EXP 4
 364: PUSH
 365: LD_STRING Louis
 367: PPUSH
 368: CALL_OW 34
 372: ST_TO_ADDR
// Jenna := CreateCharacter ( Jenna_09c ) ;
 373: LD_ADDR_EXP 6
 377: PUSH
 378: LD_STRING Jenna_09c
 380: PPUSH
 381: CALL_OW 34
 385: ST_TO_ADDR
// Gali := CreateCharacter ( Gali_09c ) ;
 386: LD_ADDR_EXP 10
 390: PUSH
 391: LD_STRING Gali_09c
 393: PPUSH
 394: CALL_OW 34
 398: ST_TO_ADDR
// Rick := CreateCharacter ( Rick_09c ) ;
 399: LD_ADDR_EXP 8
 403: PUSH
 404: LD_STRING Rick_09c
 406: PPUSH
 407: CALL_OW 34
 411: ST_TO_ADDR
// Rolf := CreateCharacter ( Rolf_09c ) ;
 412: LD_ADDR_EXP 5
 416: PUSH
 417: LD_STRING Rolf_09c
 419: PPUSH
 420: CALL_OW 34
 424: ST_TO_ADDR
// Nicolas := CreateCharacter ( Nicolas_09c ) ;
 425: LD_ADDR_EXP 7
 429: PUSH
 430: LD_STRING Nicolas_09c
 432: PPUSH
 433: CALL_OW 34
 437: ST_TO_ADDR
// Mike := CreateCharacter ( Mike_09c ) ;
 438: LD_ADDR_EXP 9
 442: PUSH
 443: LD_STRING Mike_09c
 445: PPUSH
 446: CALL_OW 34
 450: ST_TO_ADDR
// Martin := CreateCharacter ( Martin_07 ) ;
 451: LD_ADDR_EXP 11
 455: PUSH
 456: LD_STRING Martin_07
 458: PPUSH
 459: CALL_OW 34
 463: ST_TO_ADDR
// Karla := CreateCharacter ( Karla_07 ) ;
 464: LD_ADDR_EXP 12
 468: PUSH
 469: LD_STRING Karla_07
 471: PPUSH
 472: CALL_OW 34
 476: ST_TO_ADDR
// Dwein := CreateCharacter ( Dwein_07 ) ;
 477: LD_ADDR_EXP 13
 481: PUSH
 482: LD_STRING Dwein_07
 484: PPUSH
 485: CALL_OW 34
 489: ST_TO_ADDR
// Joachim := CreateCharacter ( Joachim_07 ) ;
 490: LD_ADDR_EXP 14
 494: PUSH
 495: LD_STRING Joachim_07
 497: PPUSH
 498: CALL_OW 34
 502: ST_TO_ADDR
// Olaf := CreateCharacter ( Olaf_07 ) ;
 503: LD_ADDR_EXP 15
 507: PUSH
 508: LD_STRING Olaf_07
 510: PPUSH
 511: CALL_OW 34
 515: ST_TO_ADDR
// Mmark := CreateCharacter ( Mmark_07 ) ;
 516: LD_ADDR_EXP 16
 520: PUSH
 521: LD_STRING Mmark_07
 523: PPUSH
 524: CALL_OW 34
 528: ST_TO_ADDR
// Herczeg := CreateCharacter ( Herczeg_07 ) ;
 529: LD_ADDR_EXP 17
 533: PUSH
 534: LD_STRING Herczeg_07
 536: PPUSH
 537: CALL_OW 34
 541: ST_TO_ADDR
// Mia := CreateCharacter ( Mia_07 ) ;
 542: LD_ADDR_EXP 18
 546: PUSH
 547: LD_STRING Mia_07
 549: PPUSH
 550: CALL_OW 34
 554: ST_TO_ADDR
// Kantor := CreateCharacter ( Kantor_07 ) ;
 555: LD_ADDR_EXP 19
 559: PUSH
 560: LD_STRING Kantor_07
 562: PPUSH
 563: CALL_OW 34
 567: ST_TO_ADDR
// Gunther := CreateCharacter ( Gunther_07 ) ;
 568: LD_ADDR_EXP 21
 572: PUSH
 573: LD_STRING Gunther_07
 575: PPUSH
 576: CALL_OW 34
 580: ST_TO_ADDR
// Ronn := CreateCharacter ( Ronn_07 ) ;
 581: LD_ADDR_EXP 20
 585: PUSH
 586: LD_STRING Ronn_07
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
// main_filter := [ Rolf , Jenna , Nicolas , Rick , Mike , Gali , Martin , Karla , Dwein , Joachim , Olaf , Mmark , Herczeg , Mia , Kantor , Ronn , Gunther ] ;
 594: LD_ADDR_VAR 0 8
 598: PUSH
 599: LD_EXP 5
 603: PUSH
 604: LD_EXP 6
 608: PUSH
 609: LD_EXP 7
 613: PUSH
 614: LD_EXP 8
 618: PUSH
 619: LD_EXP 9
 623: PUSH
 624: LD_EXP 10
 628: PUSH
 629: LD_EXP 11
 633: PUSH
 634: LD_EXP 12
 638: PUSH
 639: LD_EXP 13
 643: PUSH
 644: LD_EXP 14
 648: PUSH
 649: LD_EXP 15
 653: PUSH
 654: LD_EXP 16
 658: PUSH
 659: LD_EXP 17
 663: PUSH
 664: LD_EXP 18
 668: PUSH
 669: LD_EXP 19
 673: PUSH
 674: LD_EXP 20
 678: PUSH
 679: LD_EXP 21
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: ST_TO_ADDR
// for i = 1 to main_filter do
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: DOUBLE
 709: LD_INT 1
 711: DEC
 712: ST_TO_ADDR
 713: LD_VAR 0 8
 717: PUSH
 718: FOR_TO
 719: IFFALSE 754
// if IsLive ( main_filter [ i ] ) then
 721: LD_VAR 0 8
 725: PUSH
 726: LD_VAR 0 3
 730: ARRAY
 731: PPUSH
 732: CALL_OW 300
 736: IFFALSE 752
// begin filter := filter + 1 ;
 738: LD_ADDR_VAR 0 7
 742: PUSH
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 1
 750: PLUS
 751: ST_TO_ADDR
// end ;
 752: GO 718
 754: POP
 755: POP
// p := 1 ;
 756: LD_ADDR_VAR 0 2
 760: PUSH
 761: LD_INT 1
 763: ST_TO_ADDR
// if filter < 16 then
 764: LD_VAR 0 7
 768: PUSH
 769: LD_INT 16
 771: LESS
 772: IFFALSE 861
// for i = filter to 16 do
 774: LD_ADDR_VAR 0 3
 778: PUSH
 779: DOUBLE
 780: LD_VAR 0 7
 784: DEC
 785: ST_TO_ADDR
 786: LD_INT 16
 788: PUSH
 789: FOR_TO
 790: IFFALSE 859
// begin if p > 7 then
 792: LD_VAR 0 2
 796: PUSH
 797: LD_INT 7
 799: GREATER
 800: IFFALSE 804
// break ;
 802: GO 859
// un := CreateCharacter ( ot & p & _07 ) ;
 804: LD_ADDR_VAR 0 4
 808: PUSH
 809: LD_STRING ot
 811: PUSH
 812: LD_VAR 0 2
 816: STR
 817: PUSH
 818: LD_STRING _07
 820: STR
 821: PPUSH
 822: CALL_OW 34
 826: ST_TO_ADDR
// others := others ^ un ;
 827: LD_ADDR_VAR 0 9
 831: PUSH
 832: LD_VAR 0 9
 836: PUSH
 837: LD_VAR 0 4
 841: ADD
 842: ST_TO_ADDR
// p := p + 1 ;
 843: LD_ADDR_VAR 0 2
 847: PUSH
 848: LD_VAR 0 2
 852: PUSH
 853: LD_INT 1
 855: PLUS
 856: ST_TO_ADDR
// end ;
 857: GO 789
 859: POP
 860: POP
// for i = 1 to names2 do
 861: LD_ADDR_VAR 0 3
 865: PUSH
 866: DOUBLE
 867: LD_INT 1
 869: DEC
 870: ST_TO_ADDR
 871: LD_VAR 0 6
 875: PUSH
 876: FOR_TO
 877: IFFALSE 918
// begin un := CreateCharacter ( names2 [ i ] ) ;
 879: LD_ADDR_VAR 0 4
 883: PUSH
 884: LD_VAR 0 6
 888: PUSH
 889: LD_VAR 0 3
 893: ARRAY
 894: PPUSH
 895: CALL_OW 34
 899: ST_TO_ADDR
// others := others ^ un ;
 900: LD_ADDR_VAR 0 9
 904: PUSH
 905: LD_VAR 0 9
 909: PUSH
 910: LD_VAR 0 4
 914: ADD
 915: ST_TO_ADDR
// end ;
 916: GO 876
 918: POP
 919: POP
// ftp := main_filter ^ others ;
 920: LD_ADDR_VAR 0 11
 924: PUSH
 925: LD_VAR 0 8
 929: PUSH
 930: LD_VAR 0 9
 934: ADD
 935: ST_TO_ADDR
// for i = 1 to ftp do
 936: LD_ADDR_VAR 0 3
 940: PUSH
 941: DOUBLE
 942: LD_INT 1
 944: DEC
 945: ST_TO_ADDR
 946: LD_VAR 0 11
 950: PUSH
 951: FOR_TO
 952: IFFALSE 995
// if GetClass ( ftp [ i ] ) > 4 then
 954: LD_VAR 0 11
 958: PUSH
 959: LD_VAR 0 3
 963: ARRAY
 964: PPUSH
 965: CALL_OW 257
 969: PUSH
 970: LD_INT 4
 972: GREATER
 973: IFFALSE 993
// SetClass ( ftp [ i ] , 1 ) ;
 975: LD_VAR 0 11
 979: PUSH
 980: LD_VAR 0 3
 984: ARRAY
 985: PPUSH
 986: LD_INT 1
 988: PPUSH
 989: CALL_OW 336
 993: GO 951
 995: POP
 996: POP
// team := CharacterSelection ( text , 11 , 11 , [ sel_change_class , Louis , sel_changeable , sel_not_hired ] ^ ftp , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 2 ] ] ) ;
 997: LD_ADDR_VAR 0 10
1001: PUSH
1002: LD_STRING text
1004: PPUSH
1005: LD_INT 11
1007: PPUSH
1008: LD_INT 11
1010: PPUSH
1011: LD_INT -5
1013: PUSH
1014: LD_EXP 4
1018: PUSH
1019: LD_INT -3
1021: PUSH
1022: LD_INT -2
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: LIST
1029: LIST
1030: PUSH
1031: LD_VAR 0 11
1035: ADD
1036: PPUSH
1037: LD_INT 1
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 1
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 4
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: PUSH
1063: EMPTY
1064: LIST
1065: LIST
1066: LIST
1067: LIST
1068: PPUSH
1069: CALL_OW 42
1073: ST_TO_ADDR
// for i = 1 to team do
1074: LD_ADDR_VAR 0 3
1078: PUSH
1079: DOUBLE
1080: LD_INT 1
1082: DEC
1083: ST_TO_ADDR
1084: LD_VAR 0 10
1088: PUSH
1089: FOR_TO
1090: IFFALSE 1115
// begin PlaceUnitArea ( team [ i ] , ar_north_base , false ) ;
1092: LD_VAR 0 10
1096: PUSH
1097: LD_VAR 0 3
1101: ARRAY
1102: PPUSH
1103: LD_INT 1
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// end ;
1113: GO 1089
1115: POP
1116: POP
// vc_chassis := ar_half_tracked ;
1117: LD_ADDR_OWVAR 37
1121: PUSH
1122: LD_INT 14
1124: ST_TO_ADDR
// vc_engine := engine_combustion ;
1125: LD_ADDR_OWVAR 39
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// vc_control := control_manual ;
1133: LD_ADDR_OWVAR 38
1137: PUSH
1138: LD_INT 1
1140: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
1141: LD_ADDR_OWVAR 40
1145: PUSH
1146: LD_INT 25
1148: ST_TO_ADDR
// veh := CreateVehicle ;
1149: LD_ADDR_VAR 0 13
1153: PUSH
1154: CALL_OW 45
1158: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
1159: LD_VAR 0 13
1163: PPUSH
1164: LD_INT 5
1166: PPUSH
1167: CALL_OW 233
// PlaceUnitXY ( veh , 70 , 60 , false ) ;
1171: LD_VAR 0 13
1175: PPUSH
1176: LD_INT 70
1178: PPUSH
1179: LD_INT 60
1181: PPUSH
1182: LD_INT 0
1184: PPUSH
1185: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
1189: LD_EXP 4
1193: PPUSH
1194: LD_VAR 0 13
1198: PPUSH
1199: CALL_OW 52
// ComMoveXY ( Louis , 50 , 29 ) ;
1203: LD_EXP 4
1207: PPUSH
1208: LD_INT 50
1210: PPUSH
1211: LD_INT 29
1213: PPUSH
1214: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
1218: LD_EXP 4
1222: PPUSH
1223: CALL_OW 181
// end ;
1227: LD_VAR 0 1
1231: RET
// export function PrepareBase ; var i , veh ; begin
1232: LD_INT 0
1234: PPUSH
1235: PPUSH
1236: PPUSH
// for i = 1 to [ 4 , 3 , 2 ] [ Difficulty ] do
1237: LD_ADDR_VAR 0 2
1241: PUSH
1242: DOUBLE
1243: LD_INT 1
1245: DEC
1246: ST_TO_ADDR
1247: LD_INT 4
1249: PUSH
1250: LD_INT 3
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_OWVAR 67
1265: ARRAY
1266: PUSH
1267: FOR_TO
1268: IFFALSE 1423
// begin vc_chassis := ar_medium_trike ;
1270: LD_ADDR_OWVAR 37
1274: PUSH
1275: LD_INT 13
1277: ST_TO_ADDR
// vc_engine := engine_solar ;
1278: LD_ADDR_OWVAR 39
1282: PUSH
1283: LD_INT 2
1285: ST_TO_ADDR
// vc_control := control_manual ;
1286: LD_ADDR_OWVAR 38
1290: PUSH
1291: LD_INT 1
1293: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1294: LD_ADDR_OWVAR 40
1298: PUSH
1299: LD_INT 32
1301: ST_TO_ADDR
// veh := CreateVehicle ;
1302: LD_ADDR_VAR 0 3
1306: PUSH
1307: CALL_OW 45
1311: ST_TO_ADDR
// SetDir ( veh , Rand ( 0 , 5 ) ) ;
1312: LD_VAR 0 3
1316: PPUSH
1317: LD_INT 0
1319: PPUSH
1320: LD_INT 5
1322: PPUSH
1323: CALL_OW 12
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitArea ( veh , north_parking , false ) ;
1332: LD_VAR 0 3
1336: PPUSH
1337: LD_INT 10
1339: PPUSH
1340: LD_INT 0
1342: PPUSH
1343: CALL_OW 49
// SetCargo ( veh , [ mat_cans , mat_oil ] [ i mod 2 + 1 ] , [ 30 , 50 , 70 ] [ Rand ( 1 , 3 ) ] ) ;
1347: LD_VAR 0 3
1351: PPUSH
1352: LD_INT 1
1354: PUSH
1355: LD_INT 2
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 2
1369: MOD
1370: PUSH
1371: LD_INT 1
1373: PLUS
1374: ARRAY
1375: PPUSH
1376: LD_INT 30
1378: PUSH
1379: LD_INT 50
1381: PUSH
1382: LD_INT 70
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 1
1392: PPUSH
1393: LD_INT 3
1395: PPUSH
1396: CALL_OW 12
1400: ARRAY
1401: PPUSH
1402: CALL_OW 290
// AddCargo ( veh , 3 , 30 ) ;
1406: LD_VAR 0 3
1410: PPUSH
1411: LD_INT 3
1413: PPUSH
1414: LD_INT 30
1416: PPUSH
1417: CALL_OW 291
// end ;
1421: GO 1267
1423: POP
1424: POP
// end ;
1425: LD_VAR 0 1
1429: RET
// export Kunt ; export function PrepareDoc ; begin
1430: LD_INT 0
1432: PPUSH
// uc_side := 6 ;
1433: LD_ADDR_OWVAR 20
1437: PUSH
1438: LD_INT 6
1440: ST_TO_ADDR
// uc_nation := 2 ;
1441: LD_ADDR_OWVAR 21
1445: PUSH
1446: LD_INT 2
1448: ST_TO_ADDR
// hc_name := Jan Kunt ;
1449: LD_ADDR_OWVAR 26
1453: PUSH
1454: LD_STRING Jan Kunt
1456: ST_TO_ADDR
// hc_gallery := sandar ;
1457: LD_ADDR_OWVAR 33
1461: PUSH
1462: LD_STRING sandar
1464: ST_TO_ADDR
// hc_face_number := 30 ;
1465: LD_ADDR_OWVAR 34
1469: PUSH
1470: LD_INT 30
1472: ST_TO_ADDR
// hc_sex := sex_male ;
1473: LD_ADDR_OWVAR 27
1477: PUSH
1478: LD_INT 1
1480: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 8 ] ;
1481: LD_ADDR_OWVAR 31
1485: PUSH
1486: LD_INT 3
1488: PUSH
1489: LD_INT 4
1491: PUSH
1492: LD_INT 2
1494: PUSH
1495: LD_INT 8
1497: PUSH
1498: EMPTY
1499: LIST
1500: LIST
1501: LIST
1502: LIST
1503: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1504: LD_ADDR_OWVAR 29
1508: PUSH
1509: LD_INT 10
1511: PUSH
1512: LD_INT 10
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_class := 4 ;
1519: LD_ADDR_OWVAR 28
1523: PUSH
1524: LD_INT 4
1526: ST_TO_ADDR
// Kunt := CreateHuman ;
1527: LD_ADDR_EXP 22
1531: PUSH
1532: CALL_OW 44
1536: ST_TO_ADDR
// PlaceUnitXY ( Kunt , 136 , 131 , false ) ;
1537: LD_EXP 22
1541: PPUSH
1542: LD_INT 136
1544: PPUSH
1545: LD_INT 131
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 48
// ComMoveXY ( Kunt , 48 , 28 ) ;
1555: LD_EXP 22
1559: PPUSH
1560: LD_INT 48
1562: PPUSH
1563: LD_INT 28
1565: PPUSH
1566: CALL_OW 111
// end ; end_of_file
1570: LD_VAR 0 1
1574: RET
// export Sheik , Shariff , Gensher , Omar , Kurt ; export function PrepareMainCharacters ; begin
1575: LD_INT 0
1577: PPUSH
// uc_side := 5 ;
1578: LD_ADDR_OWVAR 20
1582: PUSH
1583: LD_INT 5
1585: ST_TO_ADDR
// uc_nation := nation_arabian ;
1586: LD_ADDR_OWVAR 21
1590: PUSH
1591: LD_INT 2
1593: ST_TO_ADDR
// Shariff := NewCharacter ( Abdul ) ;
1594: LD_ADDR_EXP 24
1598: PUSH
1599: LD_STRING Abdul
1601: PPUSH
1602: CALL_OW 25
1606: ST_TO_ADDR
// SetClass ( Shariff , class_desert_warior ) ;
1607: LD_EXP 24
1611: PPUSH
1612: LD_INT 11
1614: PPUSH
1615: CALL_OW 336
// Gensher := CreateCharacter ( Dietrich ) ;
1619: LD_ADDR_EXP 25
1623: PUSH
1624: LD_STRING Dietrich
1626: PPUSH
1627: CALL_OW 34
1631: ST_TO_ADDR
// Omar := CreateCharacter ( Omar ) ;
1632: LD_ADDR_EXP 26
1636: PUSH
1637: LD_STRING Omar
1639: PPUSH
1640: CALL_OW 34
1644: ST_TO_ADDR
// uc_side := 8 ;
1645: LD_ADDR_OWVAR 20
1649: PUSH
1650: LD_INT 8
1652: ST_TO_ADDR
// hc_class = 1 ;
1653: LD_ADDR_OWVAR 28
1657: PUSH
1658: LD_INT 1
1660: ST_TO_ADDR
// hc_name = Kurt Schmidt ;
1661: LD_ADDR_OWVAR 26
1665: PUSH
1666: LD_STRING Kurt Schmidt
1668: ST_TO_ADDR
// hc_gallery = us ;
1669: LD_ADDR_OWVAR 33
1673: PUSH
1674: LD_STRING us
1676: ST_TO_ADDR
// hc_face_number = 18 ;
1677: LD_ADDR_OWVAR 34
1681: PUSH
1682: LD_INT 18
1684: ST_TO_ADDR
// hc_basic_skills := [ 2 , 0 , 1 , 1 ] ;
1685: LD_ADDR_OWVAR 30
1689: PUSH
1690: LD_INT 2
1692: PUSH
1693: LD_INT 0
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: LD_INT 1
1701: PUSH
1702: EMPTY
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: ST_TO_ADDR
// hc_skills = [ 7 , 4 , 3 , 1 ] ;
1708: LD_ADDR_OWVAR 31
1712: PUSH
1713: LD_INT 7
1715: PUSH
1716: LD_INT 4
1718: PUSH
1719: LD_INT 3
1721: PUSH
1722: LD_INT 1
1724: PUSH
1725: EMPTY
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: ST_TO_ADDR
// hc_sex = sex_male ;
1731: LD_ADDR_OWVAR 27
1735: PUSH
1736: LD_INT 1
1738: ST_TO_ADDR
// hc_attr = [ 9 , 10 ] ;
1739: LD_ADDR_OWVAR 29
1743: PUSH
1744: LD_INT 9
1746: PUSH
1747: LD_INT 10
1749: PUSH
1750: EMPTY
1751: LIST
1752: LIST
1753: ST_TO_ADDR
// Kurt = CreateHuman ;
1754: LD_ADDR_EXP 27
1758: PUSH
1759: CALL_OW 44
1763: ST_TO_ADDR
// end ; end_of_file
1764: LD_VAR 0 1
1768: RET
// export function PrepareSouthBase ; var i , p , un , skill ; begin
1769: LD_INT 0
1771: PPUSH
1772: PPUSH
1773: PPUSH
1774: PPUSH
1775: PPUSH
// uc_side := 5 ;
1776: LD_ADDR_OWVAR 20
1780: PUSH
1781: LD_INT 5
1783: ST_TO_ADDR
// uc_nation := 2 ;
1784: LD_ADDR_OWVAR 21
1788: PUSH
1789: LD_INT 2
1791: ST_TO_ADDR
// SetBName ( ar_depot , tunis ) ;
1792: LD_INT 2
1794: PPUSH
1795: LD_STRING tunis
1797: PPUSH
1798: CALL_OW 500
// SetBName ( ar2_depot , rabat ) ;
1802: LD_INT 5
1804: PPUSH
1805: LD_STRING rabat
1807: PPUSH
1808: CALL_OW 500
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_INT 6
1819: PUSH
1820: LD_INT 7
1822: PUSH
1823: LD_INT 8
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: PUSH
1831: LD_OWVAR 67
1835: ARRAY
1836: ST_TO_ADDR
// SetResourceType ( GetBase ( ar2_depot ) , mat_cans , 3000 ) ;
1837: LD_INT 5
1839: PPUSH
1840: CALL_OW 274
1844: PPUSH
1845: LD_INT 1
1847: PPUSH
1848: LD_INT 3000
1850: PPUSH
1851: CALL_OW 277
// SetResourceType ( GetBase ( ar2_depot ) , mat_oil , 100 ) ;
1855: LD_INT 5
1857: PPUSH
1858: CALL_OW 274
1862: PPUSH
1863: LD_INT 2
1865: PPUSH
1866: LD_INT 100
1868: PPUSH
1869: CALL_OW 277
// for i = 1 to 7 do
1873: LD_ADDR_VAR 0 2
1877: PUSH
1878: DOUBLE
1879: LD_INT 1
1881: DEC
1882: ST_TO_ADDR
1883: LD_INT 7
1885: PUSH
1886: FOR_TO
1887: IFFALSE 1965
// begin PrepareHuman ( false , 1 , skill ) ;
1889: LD_INT 0
1891: PPUSH
1892: LD_INT 1
1894: PPUSH
1895: LD_VAR 0 5
1899: PPUSH
1900: CALL_OW 380
// un := CreateHuman ;
1904: LD_ADDR_VAR 0 4
1908: PUSH
1909: CALL_OW 44
1913: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 5 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
1914: LD_VAR 0 4
1918: PPUSH
1919: LD_INT 22
1921: PUSH
1922: LD_INT 5
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: PUSH
1929: LD_INT 58
1931: PUSH
1932: EMPTY
1933: LIST
1934: PUSH
1935: LD_INT 30
1937: PUSH
1938: LD_INT 32
1940: PUSH
1941: EMPTY
1942: LIST
1943: LIST
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: LIST
1949: PPUSH
1950: CALL_OW 69
1954: PUSH
1955: LD_INT 1
1957: ARRAY
1958: PPUSH
1959: CALL_OW 52
// end ;
1963: GO 1886
1965: POP
1966: POP
// for i = 1 to 3 do
1967: LD_ADDR_VAR 0 2
1971: PUSH
1972: DOUBLE
1973: LD_INT 1
1975: DEC
1976: ST_TO_ADDR
1977: LD_INT 3
1979: PUSH
1980: FOR_TO
1981: IFFALSE 2022
// begin PrepareHuman ( false , 4 , skill ) ;
1983: LD_INT 0
1985: PPUSH
1986: LD_INT 4
1988: PPUSH
1989: LD_VAR 0 5
1993: PPUSH
1994: CALL_OW 380
// un := CreateHuman ;
1998: LD_ADDR_VAR 0 4
2002: PUSH
2003: CALL_OW 44
2007: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_lab ) ;
2008: LD_VAR 0 4
2012: PPUSH
2013: LD_INT 8
2015: PPUSH
2016: CALL_OW 52
// end ;
2020: GO 1980
2022: POP
2023: POP
// for i = 1 to Difficulty + 1 do
2024: LD_ADDR_VAR 0 2
2028: PUSH
2029: DOUBLE
2030: LD_INT 1
2032: DEC
2033: ST_TO_ADDR
2034: LD_OWVAR 67
2038: PUSH
2039: LD_INT 1
2041: PLUS
2042: PUSH
2043: FOR_TO
2044: IFFALSE 2137
// begin PrepareHuman ( false , class_mortar , skill ) ;
2046: LD_INT 0
2048: PPUSH
2049: LD_INT 8
2051: PPUSH
2052: LD_VAR 0 5
2056: PPUSH
2057: CALL_OW 380
// for p = 1 to 2 do
2061: LD_ADDR_VAR 0 3
2065: PUSH
2066: DOUBLE
2067: LD_INT 1
2069: DEC
2070: ST_TO_ADDR
2071: LD_INT 2
2073: PUSH
2074: FOR_TO
2075: IFFALSE 2133
// begin un := CreateHuman ;
2077: LD_ADDR_VAR 0 4
2081: PUSH
2082: CALL_OW 44
2086: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
2087: LD_VAR 0 4
2091: PPUSH
2092: LD_INT 22
2094: PUSH
2095: LD_INT 5
2097: PUSH
2098: EMPTY
2099: LIST
2100: LIST
2101: PUSH
2102: LD_INT 30
2104: PUSH
2105: LD_INT 5
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: PUSH
2112: EMPTY
2113: LIST
2114: LIST
2115: PPUSH
2116: CALL_OW 69
2120: PUSH
2121: LD_VAR 0 3
2125: ARRAY
2126: PPUSH
2127: CALL_OW 52
// end ;
2131: GO 2074
2133: POP
2134: POP
// end ;
2135: GO 2043
2137: POP
2138: POP
// for i = 1 to 6 do
2139: LD_ADDR_VAR 0 2
2143: PUSH
2144: DOUBLE
2145: LD_INT 1
2147: DEC
2148: ST_TO_ADDR
2149: LD_INT 6
2151: PUSH
2152: FOR_TO
2153: IFFALSE 2194
// begin PrepareHuman ( false , 3 , skill ) ;
2155: LD_INT 0
2157: PPUSH
2158: LD_INT 3
2160: PPUSH
2161: LD_VAR 0 5
2165: PPUSH
2166: CALL_OW 380
// un := CreateHuman ;
2170: LD_ADDR_VAR 0 4
2174: PUSH
2175: CALL_OW 44
2179: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_fac ) ;
2180: LD_VAR 0 4
2184: PPUSH
2185: LD_INT 10
2187: PPUSH
2188: CALL_OW 52
// end ;
2192: GO 2152
2194: POP
2195: POP
// for i = 1 to 4 do
2196: LD_ADDR_VAR 0 2
2200: PUSH
2201: DOUBLE
2202: LD_INT 1
2204: DEC
2205: ST_TO_ADDR
2206: LD_INT 4
2208: PUSH
2209: FOR_TO
2210: IFFALSE 2251
// begin PrepareHuman ( false , 2 , skill ) ;
2212: LD_INT 0
2214: PPUSH
2215: LD_INT 2
2217: PPUSH
2218: LD_VAR 0 5
2222: PPUSH
2223: CALL_OW 380
// un := CreateHuman ;
2227: LD_ADDR_VAR 0 4
2231: PUSH
2232: CALL_OW 44
2236: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar2_depot ) ;
2237: LD_VAR 0 4
2241: PPUSH
2242: LD_INT 5
2244: PPUSH
2245: CALL_OW 52
// end ;
2249: GO 2209
2251: POP
2252: POP
// SetBunkers ( 2 ) ;
2253: LD_INT 2
2255: PPUSH
2256: CALL 2350 0 1
// for i = 1 to 7 do
2260: LD_ADDR_VAR 0 2
2264: PUSH
2265: DOUBLE
2266: LD_INT 1
2268: DEC
2269: ST_TO_ADDR
2270: LD_INT 7
2272: PUSH
2273: FOR_TO
2274: IFFALSE 2343
// AddComPlaceWeapon ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] ] ) [ i ] , [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ Rand ( 1 , 3 ) ] ) ;
2276: LD_INT 22
2278: PUSH
2279: LD_INT 5
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: PUSH
2286: LD_INT 30
2288: PUSH
2289: LD_INT 32
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: PPUSH
2300: CALL_OW 69
2304: PUSH
2305: LD_VAR 0 2
2309: ARRAY
2310: PPUSH
2311: LD_INT 28
2313: PUSH
2314: LD_INT 27
2316: PUSH
2317: LD_INT 25
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: LIST
2324: PUSH
2325: LD_INT 1
2327: PPUSH
2328: LD_INT 3
2330: PPUSH
2331: CALL_OW 12
2335: ARRAY
2336: PPUSH
2337: CALL_OW 208
2341: GO 2273
2343: POP
2344: POP
// end ;
2345: LD_VAR 0 1
2349: RET
// export ar_bunkers_list ; export function SetBunkers ( n ) ; var i , b , un , xyd , p ; begin
2350: LD_INT 0
2352: PPUSH
2353: PPUSH
2354: PPUSH
2355: PPUSH
2356: PPUSH
2357: PPUSH
// uc_side := 5 ;
2358: LD_ADDR_OWVAR 20
2362: PUSH
2363: LD_INT 5
2365: ST_TO_ADDR
// bc_type := b_breastwork ;
2366: LD_ADDR_OWVAR 42
2370: PUSH
2371: LD_INT 31
2373: ST_TO_ADDR
// bc_level := 5 ;
2374: LD_ADDR_OWVAR 43
2378: PUSH
2379: LD_INT 5
2381: ST_TO_ADDR
// ar_bunkers_list := [ ] ;
2382: LD_ADDR_EXP 28
2386: PUSH
2387: EMPTY
2388: ST_TO_ADDR
// xyd := [ 178 , 133 , 3 , 148 , 104 , 3 ] ;
2389: LD_ADDR_VAR 0 6
2393: PUSH
2394: LD_INT 178
2396: PUSH
2397: LD_INT 133
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 148
2405: PUSH
2406: LD_INT 104
2408: PUSH
2409: LD_INT 3
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: LIST
2418: LIST
2419: ST_TO_ADDR
// p := 1 ;
2420: LD_ADDR_VAR 0 7
2424: PUSH
2425: LD_INT 1
2427: ST_TO_ADDR
// for i = 1 to n do
2428: LD_ADDR_VAR 0 3
2432: PUSH
2433: DOUBLE
2434: LD_INT 1
2436: DEC
2437: ST_TO_ADDR
2438: LD_VAR 0 1
2442: PUSH
2443: FOR_TO
2444: IFFALSE 2529
// begin b := CreateAndPlaceBuildingXYD ( xyd [ p ] , xyd [ p + 1 ] , xyd [ p + 2 ] ) ;
2446: LD_ADDR_VAR 0 4
2450: PUSH
2451: LD_VAR 0 6
2455: PUSH
2456: LD_VAR 0 7
2460: ARRAY
2461: PPUSH
2462: LD_VAR 0 6
2466: PUSH
2467: LD_VAR 0 7
2471: PUSH
2472: LD_INT 1
2474: PLUS
2475: ARRAY
2476: PPUSH
2477: LD_VAR 0 6
2481: PUSH
2482: LD_VAR 0 7
2486: PUSH
2487: LD_INT 2
2489: PLUS
2490: ARRAY
2491: PPUSH
2492: CALL_OW 47
2496: ST_TO_ADDR
// ar_bunkers_list := ar_bunkers_list ^ b ;
2497: LD_ADDR_EXP 28
2501: PUSH
2502: LD_EXP 28
2506: PUSH
2507: LD_VAR 0 4
2511: ADD
2512: ST_TO_ADDR
// p := p + 3 ;
2513: LD_ADDR_VAR 0 7
2517: PUSH
2518: LD_VAR 0 7
2522: PUSH
2523: LD_INT 3
2525: PLUS
2526: ST_TO_ADDR
// end ;
2527: GO 2443
2529: POP
2530: POP
// end ;
2531: LD_VAR 0 2
2535: RET
// export ar_veh_list , control_towers , ar_vehs , ar_tasks ; every 1 do
2536: GO 2538
2538: DISABLE
// begin ar_veh_list := [ ] ;
2539: LD_ADDR_EXP 29
2543: PUSH
2544: EMPTY
2545: ST_TO_ADDR
// control_towers := [ ] ;
2546: LD_ADDR_EXP 30
2550: PUSH
2551: EMPTY
2552: ST_TO_ADDR
// ar_vehs := [ ] ;
2553: LD_ADDR_EXP 31
2557: PUSH
2558: EMPTY
2559: ST_TO_ADDR
// ar_tasks := back ;
2560: LD_ADDR_EXP 32
2564: PUSH
2565: LD_STRING back
2567: ST_TO_ADDR
// end ;
2568: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_factory ] ] ) do var i , un , fac ;
2569: LD_INT 22
2571: PUSH
2572: LD_INT 5
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: PUSH
2579: LD_INT 30
2581: PUSH
2582: LD_INT 3
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: IFFALSE 3069
2599: GO 2601
2601: DISABLE
2602: LD_INT 0
2604: PPUSH
2605: PPUSH
2606: PPUSH
// begin enable ;
2607: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
2608: LD_ADDR_VAR 0 3
2612: PUSH
2613: LD_INT 22
2615: PUSH
2616: LD_INT 5
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: LD_INT 30
2625: PUSH
2626: LD_INT 3
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PPUSH
2637: CALL_OW 69
2641: PUSH
2642: LD_INT 1
2644: ARRAY
2645: ST_TO_ADDR
// if ar_veh_list then
2646: LD_EXP 29
2650: IFFALSE 2756
// begin if BuildingStatus ( fac ) = bs_idle and control_towers then
2652: LD_VAR 0 3
2656: PPUSH
2657: CALL_OW 461
2661: PUSH
2662: LD_INT 2
2664: EQUAL
2665: PUSH
2666: LD_EXP 30
2670: AND
2671: IFFALSE 2756
// begin ComConstruct ( fac , ar_veh_list [ 1 ] , ar_veh_list [ 2 ] , ar_veh_list [ 3 ] , ar_veh_list [ 4 ] ) ;
2673: LD_VAR 0 3
2677: PPUSH
2678: LD_EXP 29
2682: PUSH
2683: LD_INT 1
2685: ARRAY
2686: PPUSH
2687: LD_EXP 29
2691: PUSH
2692: LD_INT 2
2694: ARRAY
2695: PPUSH
2696: LD_EXP 29
2700: PUSH
2701: LD_INT 3
2703: ARRAY
2704: PPUSH
2705: LD_EXP 29
2709: PUSH
2710: LD_INT 4
2712: ARRAY
2713: PPUSH
2714: CALL_OW 125
// for i = 1 to 4 do
2718: LD_ADDR_VAR 0 1
2722: PUSH
2723: DOUBLE
2724: LD_INT 1
2726: DEC
2727: ST_TO_ADDR
2728: LD_INT 4
2730: PUSH
2731: FOR_TO
2732: IFFALSE 2754
// ar_veh_list := Delete ( ar_veh_list , 1 ) ;
2734: LD_ADDR_EXP 29
2738: PUSH
2739: LD_EXP 29
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: CALL_OW 3
2751: ST_TO_ADDR
2752: GO 2731
2754: POP
2755: POP
// end ; end ; if GetTech ( tech_remcont , 5 ) = state_researched and FilterAllUnits ( [ [ f_side , 5 ] , [ f_weapon , ar_control_tower ] ] ) < 2 then
2756: LD_INT 15
2758: PPUSH
2759: LD_INT 5
2761: PPUSH
2762: CALL_OW 321
2766: PUSH
2767: LD_INT 2
2769: EQUAL
2770: PUSH
2771: LD_INT 22
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: PUSH
2781: LD_INT 34
2783: PUSH
2784: LD_INT 31
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PPUSH
2795: CALL_OW 69
2799: PUSH
2800: LD_INT 2
2802: LESS
2803: AND
2804: IFFALSE 2842
// begin if BuildingStatus ( fac ) = bs_idle then
2806: LD_VAR 0 3
2810: PPUSH
2811: CALL_OW 461
2815: PUSH
2816: LD_INT 2
2818: EQUAL
2819: IFFALSE 2842
// ComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2821: LD_VAR 0 3
2825: PPUSH
2826: LD_INT 14
2828: PPUSH
2829: LD_INT 2
2831: PPUSH
2832: LD_INT 1
2834: PPUSH
2835: LD_INT 31
2837: PPUSH
2838: CALL_OW 125
// end ; if control_towers then
2842: LD_EXP 30
2846: IFFALSE 2909
// begin for i = 1 to control_towers do
2848: LD_ADDR_VAR 0 1
2852: PUSH
2853: DOUBLE
2854: LD_INT 1
2856: DEC
2857: ST_TO_ADDR
2858: LD_EXP 30
2862: PUSH
2863: FOR_TO
2864: IFFALSE 2907
// if not IsInArea ( control_towers [ i ] , control_parking ) then
2866: LD_EXP 30
2870: PUSH
2871: LD_VAR 0 1
2875: ARRAY
2876: PPUSH
2877: LD_INT 8
2879: PPUSH
2880: CALL_OW 308
2884: NOT
2885: IFFALSE 2905
// ComMoveToArea ( control_towers [ i ] , control_parking ) ;
2887: LD_EXP 30
2891: PUSH
2892: LD_VAR 0 1
2896: ARRAY
2897: PPUSH
2898: LD_INT 8
2900: PPUSH
2901: CALL_OW 113
2905: GO 2863
2907: POP
2908: POP
// end ; if FilterAllUnits ( [ [ f_side , 5 ] , [ f_control , control_remote ] ] ) and FilterAllUnits ( [ [ f_side , 5 ] , [ f_not , [ f_linked ] ] ] ) and control_towers then
2909: LD_INT 22
2911: PUSH
2912: LD_INT 5
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 33
2921: PUSH
2922: LD_INT 2
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: EMPTY
2930: LIST
2931: LIST
2932: PPUSH
2933: CALL_OW 69
2937: PUSH
2938: LD_INT 22
2940: PUSH
2941: LD_INT 5
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 61
2953: PUSH
2954: EMPTY
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PPUSH
2965: CALL_OW 69
2969: AND
2970: PUSH
2971: LD_EXP 30
2975: AND
2976: IFFALSE 3069
// begin for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_control , control_remote ] ] ) do
2978: LD_ADDR_VAR 0 1
2982: PUSH
2983: LD_INT 22
2985: PUSH
2986: LD_INT 5
2988: PUSH
2989: EMPTY
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 33
2995: PUSH
2996: LD_INT 2
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: PPUSH
3007: CALL_OW 69
3011: PUSH
3012: FOR_IN
3013: IFFALSE 3067
// if UnitFilter ( i , [ f_not , [ f_linked ] ] ) then
3015: LD_VAR 0 1
3019: PPUSH
3020: LD_INT 3
3022: PUSH
3023: LD_INT 61
3025: PUSH
3026: EMPTY
3027: LIST
3028: PUSH
3029: EMPTY
3030: LIST
3031: LIST
3032: PPUSH
3033: CALL_OW 72
3037: IFFALSE 3065
// ComLinkTo ( i , control_towers [ Rand ( 1 , 2 ) ] ) ;
3039: LD_VAR 0 1
3043: PPUSH
3044: LD_EXP 30
3048: PUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 12
3059: ARRAY
3060: PPUSH
3061: CALL_OW 135
3065: GO 3012
3067: POP
3068: POP
// end ; end ;
3069: PPOPN 3
3071: END
// every 0 0$01 trigger ar_vehs and ar_tasks do var i , enemy , enemyA , parking ;
3072: LD_EXP 31
3076: PUSH
3077: LD_EXP 32
3081: AND
3082: IFFALSE 3475
3084: GO 3086
3086: DISABLE
3087: LD_INT 0
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
// begin enable ;
3093: ENABLE
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
3094: LD_ADDR_VAR 0 2
3098: PUSH
3099: LD_INT 22
3101: PUSH
3102: LD_INT 2
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PPUSH
3109: CALL_OW 69
3113: ST_TO_ADDR
// enemyA := FilterAllUnits ( [ f_side , 1 ] ) ;
3114: LD_ADDR_VAR 0 3
3118: PUSH
3119: LD_INT 22
3121: PUSH
3122: LD_INT 1
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL_OW 69
3133: ST_TO_ADDR
// parking := mobile_defense ;
3134: LD_ADDR_VAR 0 4
3138: PUSH
3139: LD_INT 9
3141: ST_TO_ADDR
// for i = 1 to ar_vehs do
3142: LD_ADDR_VAR 0 1
3146: PUSH
3147: DOUBLE
3148: LD_INT 1
3150: DEC
3151: ST_TO_ADDR
3152: LD_EXP 31
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3473
// begin if not HasTask ( ar_vehs [ i ] ) then
3160: LD_EXP 31
3164: PUSH
3165: LD_VAR 0 1
3169: ARRAY
3170: PPUSH
3171: CALL_OW 314
3175: NOT
3176: IFFALSE 3471
// case ar_tasks of defend :
3178: LD_EXP 32
3182: PUSH
3183: LD_STRING defend
3185: DOUBLE
3186: EQUAL
3187: IFTRUE 3191
3189: GO 3319
3191: POP
// begin if GetDistUnitArea ( ar_vehs [ i ] , parking ) > 6 and not See ( 2 , ar_vehs [ i ] ) then
3192: LD_EXP 31
3196: PUSH
3197: LD_VAR 0 1
3201: ARRAY
3202: PPUSH
3203: LD_VAR 0 4
3207: PPUSH
3208: CALL_OW 299
3212: PUSH
3213: LD_INT 6
3215: GREATER
3216: PUSH
3217: LD_INT 2
3219: PPUSH
3220: LD_EXP 31
3224: PUSH
3225: LD_VAR 0 1
3229: ARRAY
3230: PPUSH
3231: CALL_OW 292
3235: NOT
3236: AND
3237: IFFALSE 3261
// ComMoveToArea ( ar_vehs [ i ] , parking ) else
3239: LD_EXP 31
3243: PUSH
3244: LD_VAR 0 1
3248: ARRAY
3249: PPUSH
3250: LD_VAR 0 4
3254: PPUSH
3255: CALL_OW 113
3259: GO 3317
// if See ( 2 , ar_vehs [ i ] ) then
3261: LD_INT 2
3263: PPUSH
3264: LD_EXP 31
3268: PUSH
3269: LD_VAR 0 1
3273: ARRAY
3274: PPUSH
3275: CALL_OW 292
3279: IFFALSE 3317
// ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemy , ar_vehs [ i ] ) ) ;
3281: LD_EXP 31
3285: PUSH
3286: LD_VAR 0 1
3290: ARRAY
3291: PPUSH
3292: LD_VAR 0 2
3296: PPUSH
3297: LD_EXP 31
3301: PUSH
3302: LD_VAR 0 1
3306: ARRAY
3307: PPUSH
3308: CALL_OW 74
3312: PPUSH
3313: CALL_OW 115
// end ; attack_player :
3317: GO 3471
3319: LD_STRING attack_player
3321: DOUBLE
3322: EQUAL
3323: IFTRUE 3327
3325: GO 3366
3327: POP
// begin ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemy , ar_vehs [ i ] ) ) ;
3328: LD_EXP 31
3332: PUSH
3333: LD_VAR 0 1
3337: ARRAY
3338: PPUSH
3339: LD_VAR 0 2
3343: PPUSH
3344: LD_EXP 31
3348: PUSH
3349: LD_VAR 0 1
3353: ARRAY
3354: PPUSH
3355: CALL_OW 74
3359: PPUSH
3360: CALL_OW 115
// end ; support_player :
3364: GO 3471
3366: LD_STRING support_player
3368: DOUBLE
3369: EQUAL
3370: IFTRUE 3374
3372: GO 3413
3374: POP
// begin ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemyA , ar_vehs [ i ] ) ) ;
3375: LD_EXP 31
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PPUSH
3386: LD_VAR 0 3
3390: PPUSH
3391: LD_EXP 31
3395: PUSH
3396: LD_VAR 0 1
3400: ARRAY
3401: PPUSH
3402: CALL_OW 74
3406: PPUSH
3407: CALL_OW 115
// end ; back :
3411: GO 3471
3413: LD_STRING back
3415: DOUBLE
3416: EQUAL
3417: IFTRUE 3421
3419: GO 3470
3421: POP
// begin if GetDistUnitArea ( ar_vehs [ i ] , parking ) > 6 then
3422: LD_EXP 31
3426: PUSH
3427: LD_VAR 0 1
3431: ARRAY
3432: PPUSH
3433: LD_VAR 0 4
3437: PPUSH
3438: CALL_OW 299
3442: PUSH
3443: LD_INT 6
3445: GREATER
3446: IFFALSE 3468
// ComMoveToArea ( ar_vehs [ i ] , parking ) ;
3448: LD_EXP 31
3452: PUSH
3453: LD_VAR 0 1
3457: ARRAY
3458: PPUSH
3459: LD_VAR 0 4
3463: PPUSH
3464: CALL_OW 113
// end ; end ;
3468: GO 3471
3470: POP
// end ;
3471: GO 3157
3473: POP
3474: POP
// end ;
3475: PPOPN 4
3477: END
// every 5 5$00 do
3478: GO 3480
3480: DISABLE
// begin case Difficulty of 1 :
3481: LD_OWVAR 67
3485: PUSH
3486: LD_INT 1
3488: DOUBLE
3489: EQUAL
3490: IFTRUE 3494
3492: GO 3510
3494: POP
// ar_veh_list := InitVehicle ( 5 ) ; 2 :
3495: LD_ADDR_EXP 29
3499: PUSH
3500: LD_INT 5
3502: PPUSH
3503: CALL 6724 0 1
3507: ST_TO_ADDR
3508: GO 3559
3510: LD_INT 2
3512: DOUBLE
3513: EQUAL
3514: IFTRUE 3518
3516: GO 3534
3518: POP
// ar_veh_list := InitVehicle ( 6 ) ; 3 :
3519: LD_ADDR_EXP 29
3523: PUSH
3524: LD_INT 6
3526: PPUSH
3527: CALL 6724 0 1
3531: ST_TO_ADDR
3532: GO 3559
3534: LD_INT 3
3536: DOUBLE
3537: EQUAL
3538: IFTRUE 3542
3540: GO 3558
3542: POP
// ar_veh_list := InitVehicle ( 8 ) ; end ;
3543: LD_ADDR_EXP 29
3547: PUSH
3548: LD_INT 8
3550: PPUSH
3551: CALL 6724 0 1
3555: ST_TO_ADDR
3556: GO 3559
3558: POP
// end ;
3559: END
// every 0 0$01 do var i , filter , b ;
3560: GO 3562
3562: DISABLE
3563: LD_INT 0
3565: PPUSH
3566: PPUSH
3567: PPUSH
// begin enable ;
3568: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , 2 ] ] ) ;
3569: LD_ADDR_VAR 0 2
3573: PUSH
3574: LD_INT 22
3576: PUSH
3577: LD_INT 5
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 25
3586: PUSH
3587: LD_INT 2
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PPUSH
3598: CALL_OW 69
3602: ST_TO_ADDR
// b := FilterAllUnits ( [ [ [ f_side , 5 ] , [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ] ) ;
3603: LD_ADDR_VAR 0 3
3607: PUSH
3608: LD_INT 22
3610: PUSH
3611: LD_INT 5
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PUSH
3618: LD_INT 3
3620: PUSH
3621: LD_INT 24
3623: PUSH
3624: LD_INT 1000
3626: PUSH
3627: EMPTY
3628: LIST
3629: LIST
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 21
3637: PUSH
3638: LD_INT 3
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: PPUSH
3653: CALL_OW 69
3657: ST_TO_ADDR
// if b then
3658: LD_VAR 0 3
3662: IFFALSE 3774
// for i = 1 to filter do
3664: LD_ADDR_VAR 0 1
3668: PUSH
3669: DOUBLE
3670: LD_INT 1
3672: DEC
3673: ST_TO_ADDR
3674: LD_VAR 0 2
3678: PUSH
3679: FOR_TO
3680: IFFALSE 3772
// begin if IsInUnit ( filter [ i ] ) then
3682: LD_VAR 0 2
3686: PUSH
3687: LD_VAR 0 1
3691: ARRAY
3692: PPUSH
3693: CALL_OW 310
3697: IFFALSE 3716
// ComExitBuilding ( filter [ i ] ) else
3699: LD_VAR 0 2
3703: PUSH
3704: LD_VAR 0 1
3708: ARRAY
3709: PPUSH
3710: CALL_OW 122
3714: GO 3770
// if not HasTask ( filter [ i ] ) then
3716: LD_VAR 0 2
3720: PUSH
3721: LD_VAR 0 1
3725: ARRAY
3726: PPUSH
3727: CALL_OW 314
3731: NOT
3732: IFFALSE 3770
// ComRepairBuilding ( filter [ i ] , NearestUnitToUnit ( b , filter [ i ] ) ) ;
3734: LD_VAR 0 2
3738: PUSH
3739: LD_VAR 0 1
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 3
3749: PPUSH
3750: LD_VAR 0 2
3754: PUSH
3755: LD_VAR 0 1
3759: ARRAY
3760: PPUSH
3761: CALL_OW 74
3765: PPUSH
3766: CALL_OW 130
// end ;
3770: GO 3679
3772: POP
3773: POP
// if not b then
3774: LD_VAR 0 3
3778: NOT
3779: IFFALSE 3839
// for i = 1 to filter do
3781: LD_ADDR_VAR 0 1
3785: PUSH
3786: DOUBLE
3787: LD_INT 1
3789: DEC
3790: ST_TO_ADDR
3791: LD_VAR 0 2
3795: PUSH
3796: FOR_TO
3797: IFFALSE 3837
// if not HasTask ( filter [ i ] ) then
3799: LD_VAR 0 2
3803: PUSH
3804: LD_VAR 0 1
3808: ARRAY
3809: PPUSH
3810: CALL_OW 314
3814: NOT
3815: IFFALSE 3835
// ComEnterUnit ( filter [ i ] , ar2_depot ) ;
3817: LD_VAR 0 2
3821: PUSH
3822: LD_VAR 0 1
3826: ARRAY
3827: PPUSH
3828: LD_INT 5
3830: PPUSH
3831: CALL_OW 120
3835: GO 3796
3837: POP
3838: POP
// end ;
3839: PPOPN 3
3841: END
// export ar_tech_list ; every 1 do
3842: GO 3844
3844: DISABLE
// ar_tech_list := [ tech_solpow , tech_tech1 , tech_tech2 , tech_soleng , tech_oilpow , tech_oileng , tech_apeagres ] ;
3845: LD_ADDR_EXP 33
3849: PUSH
3850: LD_INT 35
3852: PUSH
3853: LD_INT 48
3855: PUSH
3856: LD_INT 49
3858: PUSH
3859: LD_INT 45
3861: PUSH
3862: LD_INT 46
3864: PUSH
3865: LD_INT 47
3867: PUSH
3868: LD_INT 11
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: ST_TO_ADDR
3880: END
// every 0 0$01 trigger game do var i , side , techs , sci ;
3881: LD_EXP 1
3885: IFFALSE 4137
3887: GO 3889
3889: DISABLE
3890: LD_INT 0
3892: PPUSH
3893: PPUSH
3894: PPUSH
3895: PPUSH
// begin side := 5 ;
3896: LD_ADDR_VAR 0 2
3900: PUSH
3901: LD_INT 5
3903: ST_TO_ADDR
// techs := ar_tech_list ;
3904: LD_ADDR_VAR 0 3
3908: PUSH
3909: LD_EXP 33
3913: ST_TO_ADDR
// repeat begin if CheckTechList ( side , techs ) then
3914: LD_VAR 0 2
3918: PPUSH
3919: LD_VAR 0 3
3923: PPUSH
3924: CALL 6085 0 2
3928: IFFALSE 3944
// ResearchTechList ( side , techs ) ;
3930: LD_VAR 0 2
3934: PPUSH
3935: LD_VAR 0 3
3939: PPUSH
3940: CALL 6160 0 2
// Wait ( 0 0$01 ) ;
3944: LD_INT 35
3946: PPUSH
3947: CALL_OW 67
// end until CheckTechList ( side , techs ) = 0 ;
3951: LD_VAR 0 2
3955: PPUSH
3956: LD_VAR 0 3
3960: PPUSH
3961: CALL 6085 0 2
3965: PUSH
3966: LD_INT 0
3968: EQUAL
3969: IFFALSE 3914
// if not GetLabKinds ( GetLabs ( 5 ) [ 1 ] ) in [ b_lab_weapon , b_lab_opto ] then
3971: LD_INT 5
3973: PPUSH
3974: CALL 5944 0 1
3978: PUSH
3979: LD_INT 1
3981: ARRAY
3982: PPUSH
3983: CALL 6020 0 1
3987: PUSH
3988: LD_INT 10
3990: PUSH
3991: LD_INT 15
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: IN
3998: NOT
3999: IFFALSE 4080
// begin ComBuildLabKind ( GetLabs ( 5 ) [ 1 ] , b_lab_weapon , b_lab_opto ) ;
4001: LD_INT 5
4003: PPUSH
4004: CALL 5944 0 1
4008: PUSH
4009: LD_INT 1
4011: ARRAY
4012: PPUSH
4013: LD_INT 10
4015: PPUSH
4016: LD_INT 15
4018: PPUSH
4019: CALL 6435 0 3
// techs := techs ^ [ tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_flame , tech_explos , tech_opto1 , tech_opto2 , tech_radar , tech_remcont , tech_remcharge ] ;
4023: LD_ADDR_VAR 0 3
4027: PUSH
4028: LD_VAR 0 3
4032: PUSH
4033: LD_INT 51
4035: PUSH
4036: LD_INT 52
4038: PUSH
4039: LD_INT 69
4041: PUSH
4042: LD_INT 39
4044: PUSH
4045: LD_INT 70
4047: PUSH
4048: LD_INT 42
4050: PUSH
4051: LD_INT 60
4053: PUSH
4054: LD_INT 61
4056: PUSH
4057: LD_INT 6
4059: PUSH
4060: LD_INT 15
4062: PUSH
4063: LD_INT 18
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: LIST
4078: ADD
4079: ST_TO_ADDR
// end ; repeat begin if CheckTechList ( side , techs ) then
4080: LD_VAR 0 2
4084: PPUSH
4085: LD_VAR 0 3
4089: PPUSH
4090: CALL 6085 0 2
4094: IFFALSE 4110
// ResearchTechList ( side , techs ) ;
4096: LD_VAR 0 2
4100: PPUSH
4101: LD_VAR 0 3
4105: PPUSH
4106: CALL 6160 0 2
// Wait ( 0 0$01 ) ;
4110: LD_INT 35
4112: PPUSH
4113: CALL_OW 67
// end until CheckTechList ( side , techs ) = 0 ;
4117: LD_VAR 0 2
4121: PPUSH
4122: LD_VAR 0 3
4126: PPUSH
4127: CALL 6085 0 2
4131: PUSH
4132: LD_INT 0
4134: EQUAL
4135: IFFALSE 4080
// end ;
4137: PPOPN 4
4139: END
// every 0 0$10 do var sci ;
4140: GO 4142
4142: DISABLE
4143: LD_INT 0
4145: PPUSH
// begin enable ;
4146: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , 4 ] ] ) ;
4147: LD_ADDR_VAR 0 1
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_INT 5
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: PUSH
4162: LD_INT 25
4164: PUSH
4165: LD_INT 4
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PPUSH
4176: CALL_OW 69
4180: ST_TO_ADDR
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) then
4181: LD_VAR 0 1
4185: PPUSH
4186: LD_INT 3
4188: PUSH
4189: LD_INT 54
4191: PUSH
4192: EMPTY
4193: LIST
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: PPUSH
4199: CALL_OW 72
4203: IFFALSE 4273
// if not HasTask ( UnitFilter ( sci , [ f_not , [ f_inside ] ] ) [ 1 ] ) then
4205: LD_VAR 0 1
4209: PPUSH
4210: LD_INT 3
4212: PUSH
4213: LD_INT 54
4215: PUSH
4216: EMPTY
4217: LIST
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PPUSH
4223: CALL_OW 72
4227: PUSH
4228: LD_INT 1
4230: ARRAY
4231: PPUSH
4232: CALL_OW 314
4236: NOT
4237: IFFALSE 4273
// ComEnterUnit ( UnitFilter ( sci , [ f_not , [ f_inside ] ] ) [ 1 ] , ar_lab ) ;
4239: LD_VAR 0 1
4243: PPUSH
4244: LD_INT 3
4246: PUSH
4247: LD_INT 54
4249: PUSH
4250: EMPTY
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 72
4261: PUSH
4262: LD_INT 1
4264: ARRAY
4265: PPUSH
4266: LD_INT 8
4268: PPUSH
4269: CALL_OW 120
// end ;
4273: PPOPN 1
4275: END
// every 0 0$01 do var i , tmp , filter , apes ;
4276: GO 4278
4278: DISABLE
4279: LD_INT 0
4281: PPUSH
4282: PPUSH
4283: PPUSH
4284: PPUSH
// begin while ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_warehouse ] ] ) ) do
4285: LD_INT 22
4287: PUSH
4288: LD_INT 5
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 30
4297: PUSH
4298: LD_INT 1
4300: PUSH
4301: EMPTY
4302: LIST
4303: LIST
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PPUSH
4309: CALL_OW 69
4313: IFFALSE 4439
// begin filter := FilterAllUnits ( [ [ [ f_side , 5 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] ] ] ] ) ;
4315: LD_ADDR_VAR 0 3
4319: PUSH
4320: LD_INT 22
4322: PUSH
4323: LD_INT 5
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 2
4332: PUSH
4333: LD_INT 25
4335: PUSH
4336: LD_INT 12
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: PUSH
4343: LD_INT 25
4345: PUSH
4346: LD_INT 15
4348: PUSH
4349: EMPTY
4350: LIST
4351: LIST
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: LIST
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: PUSH
4362: EMPTY
4363: LIST
4364: PPUSH
4365: CALL_OW 69
4369: ST_TO_ADDR
// if filter < 6 then
4370: LD_VAR 0 3
4374: PUSH
4375: LD_INT 6
4377: LESS
4378: IFFALSE 4430
// begin apes := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
4380: LD_ADDR_VAR 0 4
4384: PUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 0
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 12
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PPUSH
4409: CALL_OW 69
4413: ST_TO_ADDR
// if apes then
4414: LD_VAR 0 4
4418: IFFALSE 4430
// TameApeman ( 5 , 1 ) ;
4420: LD_INT 5
4422: PPUSH
4423: LD_INT 1
4425: PPUSH
4426: CALL 5439 0 2
// end ; Wait ( 4 4$45 ) ;
4430: LD_INT 9975
4432: PPUSH
4433: CALL_OW 67
// end ;
4437: GO 4285
// end ;
4439: PPOPN 4
4441: END
// every 0 0$01 trigger GetTech ( tech_apeagres , 5 ) = state_researched do var un , tmp , filter , filter2 , i , b ;
4442: LD_INT 11
4444: PPUSH
4445: LD_INT 5
4447: PPUSH
4448: CALL_OW 321
4452: PUSH
4453: LD_INT 2
4455: EQUAL
4456: IFFALSE 5020
4458: GO 4460
4460: DISABLE
4461: LD_INT 0
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
4467: PPUSH
4468: PPUSH
// begin enable ;
4469: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , class_apeman ] ] ) ;
4470: LD_ADDR_VAR 0 3
4474: PUSH
4475: LD_INT 22
4477: PUSH
4478: LD_INT 5
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 12
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PPUSH
4499: CALL_OW 69
4503: ST_TO_ADDR
// filter2 := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , class_apeman_soldier ] ] ) ;
4504: LD_ADDR_VAR 0 4
4508: PUSH
4509: LD_INT 22
4511: PUSH
4512: LD_INT 5
4514: PUSH
4515: EMPTY
4516: LIST
4517: LIST
4518: PUSH
4519: LD_INT 25
4521: PUSH
4522: LD_INT 15
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PPUSH
4533: CALL_OW 69
4537: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_barracks ] ] ) ;
4538: LD_ADDR_VAR 0 2
4542: PUSH
4543: LD_INT 22
4545: PUSH
4546: LD_INT 5
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 30
4555: PUSH
4556: LD_INT 5
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PPUSH
4567: CALL_OW 69
4571: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) ;
4572: LD_ADDR_VAR 0 6
4576: PUSH
4577: LD_INT 22
4579: PUSH
4580: LD_INT 5
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: LD_INT 30
4589: PUSH
4590: LD_INT 31
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: PUSH
4597: LD_INT 58
4599: PUSH
4600: EMPTY
4601: LIST
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: ST_TO_ADDR
// if filter then
4613: LD_VAR 0 3
4617: IFFALSE 4774
// for i = 1 to filter do
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: DOUBLE
4625: LD_INT 1
4627: DEC
4628: ST_TO_ADDR
4629: LD_VAR 0 3
4633: PUSH
4634: FOR_TO
4635: IFFALSE 4772
// begin if not HasTask ( filter [ i ] ) then
4637: LD_VAR 0 3
4641: PUSH
4642: LD_VAR 0 5
4646: ARRAY
4647: PPUSH
4648: CALL_OW 314
4652: NOT
4653: IFFALSE 4738
// begin if BuildingFull ( tmp [ 2 ] ) then
4655: LD_VAR 0 2
4659: PUSH
4660: LD_INT 2
4662: ARRAY
4663: PPUSH
4664: CALL 6582 0 1
4668: IFFALSE 4696
// ComEnterUnit ( filter [ i ] , tmp [ 1 ] ) else
4670: LD_VAR 0 3
4674: PUSH
4675: LD_VAR 0 5
4679: ARRAY
4680: PPUSH
4681: LD_VAR 0 2
4685: PUSH
4686: LD_INT 1
4688: ARRAY
4689: PPUSH
4690: CALL_OW 120
4694: GO 4720
// ComEnterUnit ( filter [ i ] , tmp [ 2 ] ) ;
4696: LD_VAR 0 3
4700: PUSH
4701: LD_VAR 0 5
4705: ARRAY
4706: PPUSH
4707: LD_VAR 0 2
4711: PUSH
4712: LD_INT 2
4714: ARRAY
4715: PPUSH
4716: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , class_apeman_soldier ) ;
4720: LD_VAR 0 3
4724: PUSH
4725: LD_VAR 0 5
4729: ARRAY
4730: PPUSH
4731: LD_INT 15
4733: PPUSH
4734: CALL_OW 183
// end ; if IsInUnit ( filter [ i ] ) then
4738: LD_VAR 0 3
4742: PUSH
4743: LD_VAR 0 5
4747: ARRAY
4748: PPUSH
4749: CALL_OW 310
4753: IFFALSE 4770
// ComExitBuilding ( filter [ i ] ) ;
4755: LD_VAR 0 3
4759: PUSH
4760: LD_VAR 0 5
4764: ARRAY
4765: PPUSH
4766: CALL_OW 122
// end ;
4770: GO 4634
4772: POP
4773: POP
// if filter2 then
4774: LD_VAR 0 4
4778: IFFALSE 5020
// for i = 1 to filter2 do
4780: LD_ADDR_VAR 0 5
4784: PUSH
4785: DOUBLE
4786: LD_INT 1
4788: DEC
4789: ST_TO_ADDR
4790: LD_VAR 0 4
4794: PUSH
4795: FOR_TO
4796: IFFALSE 5018
// begin if b then
4798: LD_VAR 0 6
4802: IFFALSE 4933
// begin if not IsInUnit ( filter2 [ i ] ) in b and i <= b then
4804: LD_VAR 0 4
4808: PUSH
4809: LD_VAR 0 5
4813: ARRAY
4814: PPUSH
4815: CALL_OW 310
4819: PUSH
4820: LD_VAR 0 6
4824: IN
4825: NOT
4826: PUSH
4827: LD_VAR 0 5
4831: PUSH
4832: LD_VAR 0 6
4836: LESSEQUAL
4837: AND
4838: IFFALSE 4855
// ComExitBuilding ( filter2 [ i ] ) ;
4840: LD_VAR 0 4
4844: PUSH
4845: LD_VAR 0 5
4849: ARRAY
4850: PPUSH
4851: CALL_OW 122
// if i <= b then
4855: LD_VAR 0 5
4859: PUSH
4860: LD_VAR 0 6
4864: LESSEQUAL
4865: IFFALSE 4895
// ComEnterUnit ( filter2 [ i ] , b [ i ] ) else
4867: LD_VAR 0 4
4871: PUSH
4872: LD_VAR 0 5
4876: ARRAY
4877: PPUSH
4878: LD_VAR 0 6
4882: PUSH
4883: LD_VAR 0 5
4887: ARRAY
4888: PPUSH
4889: CALL_OW 120
4893: GO 4931
// ComEnterUnit ( filter2 [ i ] , NearestUnitToUnit ( tmp , filter2 [ i ] ) ) ;
4895: LD_VAR 0 4
4899: PUSH
4900: LD_VAR 0 5
4904: ARRAY
4905: PPUSH
4906: LD_VAR 0 2
4910: PPUSH
4911: LD_VAR 0 4
4915: PUSH
4916: LD_VAR 0 5
4920: ARRAY
4921: PPUSH
4922: CALL_OW 74
4926: PPUSH
4927: CALL_OW 120
// end else
4931: GO 5016
// if not IsInUnit ( filter2 [ i ] ) then
4933: LD_VAR 0 4
4937: PUSH
4938: LD_VAR 0 5
4942: ARRAY
4943: PPUSH
4944: CALL_OW 310
4948: NOT
4949: IFFALSE 5016
// if BuildingFull ( tmp [ 2 ] ) then
4951: LD_VAR 0 2
4955: PUSH
4956: LD_INT 2
4958: ARRAY
4959: PPUSH
4960: CALL 6582 0 1
4964: IFFALSE 4992
// ComEnterUnit ( filter2 [ i ] , tmp [ 2 ] ) else
4966: LD_VAR 0 4
4970: PUSH
4971: LD_VAR 0 5
4975: ARRAY
4976: PPUSH
4977: LD_VAR 0 2
4981: PUSH
4982: LD_INT 2
4984: ARRAY
4985: PPUSH
4986: CALL_OW 120
4990: GO 5016
// ComEnterUnit ( filter2 [ i ] , tmp [ 1 ] ) ;
4992: LD_VAR 0 4
4996: PUSH
4997: LD_VAR 0 5
5001: ARRAY
5002: PPUSH
5003: LD_VAR 0 2
5007: PUSH
5008: LD_INT 1
5010: ARRAY
5011: PPUSH
5012: CALL_OW 120
// end ;
5016: GO 4795
5018: POP
5019: POP
// end ;
5020: PPOPN 6
5022: END
// every 0 0$0.3 trigger mines do var i , un , filter ;
5023: LD_EXP 2
5027: IFFALSE 5160
5029: GO 5031
5031: DISABLE
5032: LD_INT 0
5034: PPUSH
5035: PPUSH
5036: PPUSH
// begin enable ;
5037: ENABLE
// filter := FilterUnitsInArea ( area_mines , [ f_enemy , 5 ] ) ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: LD_INT 7
5045: PPUSH
5046: LD_INT 81
5048: PUSH
5049: LD_INT 5
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 70
5060: ST_TO_ADDR
// for i = 1 to filter do
5061: LD_ADDR_VAR 0 1
5065: PUSH
5066: DOUBLE
5067: LD_INT 1
5069: DEC
5070: ST_TO_ADDR
5071: LD_VAR 0 3
5075: PUSH
5076: FOR_TO
5077: IFFALSE 5158
// if MineAtPos ( GetX ( filter [ i ] ) , GetY ( filter [ i ] ) ) then
5079: LD_VAR 0 3
5083: PUSH
5084: LD_VAR 0 1
5088: ARRAY
5089: PPUSH
5090: CALL_OW 250
5094: PPUSH
5095: LD_VAR 0 3
5099: PUSH
5100: LD_VAR 0 1
5104: ARRAY
5105: PPUSH
5106: CALL_OW 251
5110: PPUSH
5111: CALL_OW 458
5115: IFFALSE 5156
// LaunchMineAtPos ( GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , 5 ) ;
5117: LD_VAR 0 3
5121: PUSH
5122: LD_VAR 0 1
5126: ARRAY
5127: PPUSH
5128: CALL_OW 250
5132: PPUSH
5133: LD_VAR 0 3
5137: PUSH
5138: LD_VAR 0 1
5142: ARRAY
5143: PPUSH
5144: CALL_OW 251
5148: PPUSH
5149: LD_INT 5
5151: PPUSH
5152: CALL_OW 456
5156: GO 5076
5158: POP
5159: POP
// end ; end_of_file
5160: PPOPN 3
5162: END
// export function CreateApemans ( n , area ) ; var un , i ; begin
5163: LD_INT 0
5165: PPUSH
5166: PPUSH
5167: PPUSH
// uc_side := 0 ;
5168: LD_ADDR_OWVAR 20
5172: PUSH
5173: LD_INT 0
5175: ST_TO_ADDR
// uc_nation := 0 ;
5176: LD_ADDR_OWVAR 21
5180: PUSH
5181: LD_INT 0
5183: ST_TO_ADDR
// for i = 1 to n do
5184: LD_ADDR_VAR 0 5
5188: PUSH
5189: DOUBLE
5190: LD_INT 1
5192: DEC
5193: ST_TO_ADDR
5194: LD_VAR 0 1
5198: PUSH
5199: FOR_TO
5200: IFFALSE 5309
// begin hc_gallery :=  ;
5202: LD_ADDR_OWVAR 33
5206: PUSH
5207: LD_STRING 
5209: ST_TO_ADDR
// hc_name :=  ;
5210: LD_ADDR_OWVAR 26
5214: PUSH
5215: LD_STRING 
5217: ST_TO_ADDR
// hc_attr := [ Rand ( 10 , 12 ) , Rand ( 10 , 11 ) ] ;
5218: LD_ADDR_OWVAR 29
5222: PUSH
5223: LD_INT 10
5225: PPUSH
5226: LD_INT 12
5228: PPUSH
5229: CALL_OW 12
5233: PUSH
5234: LD_INT 10
5236: PPUSH
5237: LD_INT 11
5239: PPUSH
5240: CALL_OW 12
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: ST_TO_ADDR
// hc_class := class_apeman ;
5249: LD_ADDR_OWVAR 28
5253: PUSH
5254: LD_INT 12
5256: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
5257: LD_ADDR_OWVAR 31
5261: PUSH
5262: LD_INT 0
5264: PUSH
5265: LD_INT 0
5267: PUSH
5268: LD_INT 0
5270: PUSH
5271: LD_INT 0
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: LIST
5278: LIST
5279: ST_TO_ADDR
// un := CreateHuman ;
5280: LD_ADDR_VAR 0 4
5284: PUSH
5285: CALL_OW 44
5289: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 2
5299: PPUSH
5300: LD_INT 0
5302: PPUSH
5303: CALL_OW 49
// end ;
5307: GO 5199
5309: POP
5310: POP
// end ;
5311: LD_VAR 0 3
5315: RET
// export function CreateTigers ( n , area , agres ) ; var i , animal ; begin
5316: LD_INT 0
5318: PPUSH
5319: PPUSH
5320: PPUSH
// uc_side := 0 ;
5321: LD_ADDR_OWVAR 20
5325: PUSH
5326: LD_INT 0
5328: ST_TO_ADDR
// uc_nation := 0 ;
5329: LD_ADDR_OWVAR 21
5333: PUSH
5334: LD_INT 0
5336: ST_TO_ADDR
// for i = 1 to n do
5337: LD_ADDR_VAR 0 5
5341: PUSH
5342: DOUBLE
5343: LD_INT 1
5345: DEC
5346: ST_TO_ADDR
5347: LD_VAR 0 1
5351: PUSH
5352: FOR_TO
5353: IFFALSE 5432
// begin hc_class = class_tiger ;
5355: LD_ADDR_OWVAR 28
5359: PUSH
5360: LD_INT 14
5362: ST_TO_ADDR
// hc_gallery = sandnature ;
5363: LD_ADDR_OWVAR 33
5367: PUSH
5368: LD_STRING sandnature
5370: ST_TO_ADDR
// hc_agressivity = Rand ( agres , agres + 30 ) ;
5371: LD_ADDR_OWVAR 35
5375: PUSH
5376: LD_VAR 0 3
5380: PPUSH
5381: LD_VAR 0 3
5385: PUSH
5386: LD_INT 30
5388: PLUS
5389: PPUSH
5390: CALL_OW 12
5394: ST_TO_ADDR
// hc_face_number = 3 ;
5395: LD_ADDR_OWVAR 34
5399: PUSH
5400: LD_INT 3
5402: ST_TO_ADDR
// animal := CreateHuman ;
5403: LD_ADDR_VAR 0 6
5407: PUSH
5408: CALL_OW 44
5412: ST_TO_ADDR
// PlaceUnitArea ( animal , area , false ) ;
5413: LD_VAR 0 6
5417: PPUSH
5418: LD_VAR 0 2
5422: PPUSH
5423: LD_INT 0
5425: PPUSH
5426: CALL_OW 49
// end ;
5430: GO 5352
5432: POP
5433: POP
// end ;
5434: LD_VAR 0 4
5438: RET
// export function TameApeman ( side , n ) ; var i , filter , apes , ape , b , x , y ; begin
5439: LD_INT 0
5441: PPUSH
5442: PPUSH
5443: PPUSH
5444: PPUSH
5445: PPUSH
5446: PPUSH
5447: PPUSH
5448: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
5449: LD_ADDR_VAR 0 5
5453: PUSH
5454: LD_INT 22
5456: PUSH
5457: LD_VAR 0 1
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: PUSH
5466: LD_INT 25
5468: PUSH
5469: LD_INT 4
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PPUSH
5480: CALL_OW 69
5484: ST_TO_ADDR
// apes := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
5485: LD_ADDR_VAR 0 6
5489: PUSH
5490: LD_INT 22
5492: PUSH
5493: LD_INT 0
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PUSH
5500: LD_INT 25
5502: PUSH
5503: LD_INT 12
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: PPUSH
5514: CALL_OW 69
5518: ST_TO_ADDR
// if n > apes then
5519: LD_VAR 0 2
5523: PUSH
5524: LD_VAR 0 6
5528: GREATER
5529: IFFALSE 5541
// n = apes ;
5531: LD_ADDR_VAR 0 2
5535: PUSH
5536: LD_VAR 0 6
5540: ST_TO_ADDR
// for i = 1 to n do
5541: LD_ADDR_VAR 0 4
5545: PUSH
5546: DOUBLE
5547: LD_INT 1
5549: DEC
5550: ST_TO_ADDR
5551: LD_VAR 0 2
5555: PUSH
5556: FOR_TO
5557: IFFALSE 5821
// begin if IsInUnit ( filter [ i ] ) then
5559: LD_VAR 0 5
5563: PUSH
5564: LD_VAR 0 4
5568: ARRAY
5569: PPUSH
5570: CALL_OW 310
5574: IFFALSE 5612
// begin b := IsInUnit ( filter [ i ] ) ;
5576: LD_ADDR_VAR 0 8
5580: PUSH
5581: LD_VAR 0 5
5585: PUSH
5586: LD_VAR 0 4
5590: ARRAY
5591: PPUSH
5592: CALL_OW 310
5596: ST_TO_ADDR
// ComExitBuilding ( filter [ i ] ) ;
5597: LD_VAR 0 5
5601: PUSH
5602: LD_VAR 0 4
5606: ARRAY
5607: PPUSH
5608: CALL_OW 122
// end ; Wait ( 0 0$0.3 ) ;
5612: LD_INT 10
5614: PPUSH
5615: CALL_OW 67
// SetRememberedX ( filter [ i ] , GetX ( filter [ i ] ) ) ;
5619: LD_VAR 0 5
5623: PUSH
5624: LD_VAR 0 4
5628: ARRAY
5629: PPUSH
5630: LD_VAR 0 5
5634: PUSH
5635: LD_VAR 0 4
5639: ARRAY
5640: PPUSH
5641: CALL_OW 250
5645: PPUSH
5646: CALL_OW 231
// SetRememberedY ( filter [ i ] , GetY ( filter [ i ] ) ) ;
5650: LD_VAR 0 5
5654: PUSH
5655: LD_VAR 0 4
5659: ARRAY
5660: PPUSH
5661: LD_VAR 0 5
5665: PUSH
5666: LD_VAR 0 4
5670: ARRAY
5671: PPUSH
5672: CALL_OW 251
5676: PPUSH
5677: CALL_OW 232
// ape := NearestUnitToUnit ( apes , filter [ i ] ) ;
5681: LD_ADDR_VAR 0 7
5685: PUSH
5686: LD_VAR 0 6
5690: PPUSH
5691: LD_VAR 0 5
5695: PUSH
5696: LD_VAR 0 4
5700: ARRAY
5701: PPUSH
5702: CALL_OW 74
5706: ST_TO_ADDR
// ComHold ( ape ) ;
5707: LD_VAR 0 7
5711: PPUSH
5712: CALL_OW 140
// ComTameXY ( filter [ i ] , GetX ( ape ) , GetY ( ape ) ) ;
5716: LD_VAR 0 5
5720: PUSH
5721: LD_VAR 0 4
5725: ARRAY
5726: PPUSH
5727: LD_VAR 0 7
5731: PPUSH
5732: CALL_OW 250
5736: PPUSH
5737: LD_VAR 0 7
5741: PPUSH
5742: CALL_OW 251
5746: PPUSH
5747: CALL_OW 131
// repeat Wait ( 0 0$01 ) ;
5751: LD_INT 35
5753: PPUSH
5754: CALL_OW 67
// until not HasTask ( filter [ i ] ) ;
5758: LD_VAR 0 5
5762: PUSH
5763: LD_VAR 0 4
5767: ARRAY
5768: PPUSH
5769: CALL_OW 314
5773: NOT
5774: IFFALSE 5751
// if b then
5776: LD_VAR 0 8
5780: IFFALSE 5804
// AddComEnterUnit ( filter [ i ] , b ) else
5782: LD_VAR 0 5
5786: PUSH
5787: LD_VAR 0 4
5791: ARRAY
5792: PPUSH
5793: LD_VAR 0 8
5797: PPUSH
5798: CALL_OW 180
5802: GO 5819
// AddComReturn ( filter [ i ] ) ;
5804: LD_VAR 0 5
5808: PUSH
5809: LD_VAR 0 4
5813: ARRAY
5814: PPUSH
5815: CALL_OW 204
// end ;
5819: GO 5556
5821: POP
5822: POP
// end ;
5823: LD_VAR 0 3
5827: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5828: LD_INT 0
5830: PPUSH
5831: PPUSH
5832: PPUSH
// pom := GetBase ( bdepot ) ;
5833: LD_ADDR_VAR 0 4
5837: PUSH
5838: LD_VAR 0 1
5842: PPUSH
5843: CALL_OW 274
5847: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5848: LD_ADDR_VAR 0 5
5852: PUSH
5853: LD_VAR 0 2
5857: PPUSH
5858: LD_VAR 0 1
5862: PPUSH
5863: CALL_OW 248
5867: PPUSH
5868: CALL_OW 450
5872: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5873: LD_VAR 0 4
5877: PPUSH
5878: LD_INT 1
5880: PPUSH
5881: CALL_OW 275
5885: PUSH
5886: LD_VAR 0 5
5890: PUSH
5891: LD_INT 1
5893: ARRAY
5894: GREATEREQUAL
5895: PUSH
5896: LD_VAR 0 4
5900: PPUSH
5901: LD_INT 3
5903: PPUSH
5904: CALL_OW 275
5908: PUSH
5909: LD_VAR 0 5
5913: PUSH
5914: LD_INT 3
5916: ARRAY
5917: GREATEREQUAL
5918: AND
5919: IFFALSE 5931
// result := true else
5921: LD_ADDR_VAR 0 3
5925: PUSH
5926: LD_INT 1
5928: ST_TO_ADDR
5929: GO 5939
// result := false ;
5931: LD_ADDR_VAR 0 3
5935: PUSH
5936: LD_INT 0
5938: ST_TO_ADDR
// end ;
5939: LD_VAR 0 3
5943: RET
// export function GetLabs ( side ) ; begin
5944: LD_INT 0
5946: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
5947: LD_ADDR_VAR 0 2
5951: PUSH
5952: LD_INT 22
5954: PUSH
5955: LD_VAR 0 1
5959: PUSH
5960: EMPTY
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 2
5966: PUSH
5967: LD_INT 30
5969: PUSH
5970: LD_INT 6
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 30
5979: PUSH
5980: LD_INT 8
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 30
5989: PUSH
5990: LD_INT 7
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: EMPTY
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// end ;
6015: LD_VAR 0 2
6019: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6020: LD_INT 0
6022: PPUSH
6023: PPUSH
6024: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_VAR 0 1
6034: PPUSH
6035: LD_INT 1
6037: PPUSH
6038: CALL_OW 268
6042: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6043: LD_ADDR_VAR 0 4
6047: PUSH
6048: LD_VAR 0 1
6052: PPUSH
6053: LD_INT 2
6055: PPUSH
6056: CALL_OW 268
6060: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6061: LD_ADDR_VAR 0 2
6065: PUSH
6066: LD_VAR 0 3
6070: PUSH
6071: LD_VAR 0 4
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: ST_TO_ADDR
// end ;
6080: LD_VAR 0 2
6084: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6085: LD_INT 0
6087: PPUSH
6088: PPUSH
// result := false ;
6089: LD_ADDR_VAR 0 3
6093: PUSH
6094: LD_INT 0
6096: ST_TO_ADDR
// for i = 1 to tlist do
6097: LD_ADDR_VAR 0 4
6101: PUSH
6102: DOUBLE
6103: LD_INT 1
6105: DEC
6106: ST_TO_ADDR
6107: LD_VAR 0 2
6111: PUSH
6112: FOR_TO
6113: IFFALSE 6153
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6115: LD_VAR 0 2
6119: PUSH
6120: LD_VAR 0 4
6124: ARRAY
6125: PPUSH
6126: LD_VAR 0 1
6130: PPUSH
6131: CALL_OW 321
6135: PUSH
6136: LD_INT 2
6138: NONEQUAL
6139: IFFALSE 6151
// begin result := true ;
6141: LD_ADDR_VAR 0 3
6145: PUSH
6146: LD_INT 1
6148: ST_TO_ADDR
// break ;
6149: GO 6153
// end ;
6151: GO 6112
6153: POP
6154: POP
// end ;
6155: LD_VAR 0 3
6159: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab ; begin
6160: LD_INT 0
6162: PPUSH
6163: PPUSH
6164: PPUSH
6165: PPUSH
6166: PPUSH
6167: PPUSH
6168: PPUSH
// lab := GetLabs ( side ) ;
6169: LD_ADDR_VAR 0 5
6173: PUSH
6174: LD_VAR 0 1
6178: PPUSH
6179: CALL 5944 0 1
6183: ST_TO_ADDR
// tmp := 0 ;
6184: LD_ADDR_VAR 0 7
6188: PUSH
6189: LD_INT 0
6191: ST_TO_ADDR
// list := [ ] ;
6192: LD_ADDR_VAR 0 8
6196: PUSH
6197: EMPTY
6198: ST_TO_ADDR
// for i = 1 to tlist do
6199: LD_ADDR_VAR 0 4
6203: PUSH
6204: DOUBLE
6205: LD_INT 1
6207: DEC
6208: ST_TO_ADDR
6209: LD_VAR 0 2
6213: PUSH
6214: FOR_TO
6215: IFFALSE 6267
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6217: LD_VAR 0 2
6221: PUSH
6222: LD_VAR 0 4
6226: ARRAY
6227: PPUSH
6228: LD_VAR 0 1
6232: PPUSH
6233: CALL_OW 321
6237: PUSH
6238: LD_INT 2
6240: NONEQUAL
6241: IFFALSE 6265
// list := list ^ tlist [ i ] ;
6243: LD_ADDR_VAR 0 8
6247: PUSH
6248: LD_VAR 0 8
6252: PUSH
6253: LD_VAR 0 2
6257: PUSH
6258: LD_VAR 0 4
6262: ARRAY
6263: ADD
6264: ST_TO_ADDR
6265: GO 6214
6267: POP
6268: POP
// if list then
6269: LD_VAR 0 8
6273: IFFALSE 6422
// begin for i = 1 to lab do
6275: LD_ADDR_VAR 0 4
6279: PUSH
6280: DOUBLE
6281: LD_INT 1
6283: DEC
6284: ST_TO_ADDR
6285: LD_VAR 0 5
6289: PUSH
6290: FOR_TO
6291: IFFALSE 6345
// if GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) then
6293: LD_VAR 0 8
6297: PUSH
6298: LD_INT 1
6300: ARRAY
6301: PPUSH
6302: CALL_OW 481
6306: PUSH
6307: LD_VAR 0 5
6311: PUSH
6312: LD_VAR 0 4
6316: ARRAY
6317: PPUSH
6318: CALL 6020 0 1
6322: IN
6323: IFFALSE 6343
// begin mylab := lab [ i ] ;
6325: LD_ADDR_VAR 0 9
6329: PUSH
6330: LD_VAR 0 5
6334: PUSH
6335: LD_VAR 0 4
6339: ARRAY
6340: ST_TO_ADDR
// break ;
6341: GO 6345
// end ;
6343: GO 6290
6345: POP
6346: POP
// if mylab then
6347: LD_VAR 0 9
6351: IFFALSE 6412
// begin if BuildingStatus ( mylab ) = bs_idle then
6353: LD_VAR 0 9
6357: PPUSH
6358: CALL_OW 461
6362: PUSH
6363: LD_INT 2
6365: EQUAL
6366: IFFALSE 6410
// for i = 1 to list do
6368: LD_ADDR_VAR 0 4
6372: PUSH
6373: DOUBLE
6374: LD_INT 1
6376: DEC
6377: ST_TO_ADDR
6378: LD_VAR 0 8
6382: PUSH
6383: FOR_TO
6384: IFFALSE 6408
// AddComResearch ( mylab , list [ i ] ) ;
6386: LD_VAR 0 9
6390: PPUSH
6391: LD_VAR 0 8
6395: PUSH
6396: LD_VAR 0 4
6400: ARRAY
6401: PPUSH
6402: CALL_OW 184
6406: GO 6383
6408: POP
6409: POP
// end else
6410: GO 6420
// result := false ;
6412: LD_ADDR_VAR 0 3
6416: PUSH
6417: LD_INT 0
6419: ST_TO_ADDR
// end else
6420: GO 6430
// result := false ;
6422: LD_ADDR_VAR 0 3
6426: PUSH
6427: LD_INT 0
6429: ST_TO_ADDR
// end ;
6430: LD_VAR 0 3
6434: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
6435: LD_INT 0
6437: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
6438: LD_VAR 0 1
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: CALL_OW 268
6450: PUSH
6451: LD_INT 9
6453: EQUAL
6454: PUSH
6455: LD_VAR 0 1
6459: PPUSH
6460: LD_INT 2
6462: PPUSH
6463: CALL_OW 268
6467: PUSH
6468: LD_INT 9
6470: EQUAL
6471: AND
6472: IFFALSE 6569
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
6474: LD_VAR 0 1
6478: PPUSH
6479: LD_VAR 0 2
6483: PPUSH
6484: CALL 5828 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PPUSH
6494: LD_VAR 0 3
6498: PPUSH
6499: CALL 5828 0 2
6503: AND
6504: PUSH
6505: LD_VAR 0 1
6509: PPUSH
6510: CALL_OW 461
6514: PUSH
6515: LD_INT 2
6517: EQUAL
6518: AND
6519: IFFALSE 6559
// begin ComUpgradeLab ( lab , bkind1 ) ;
6521: LD_VAR 0 1
6525: PPUSH
6526: LD_VAR 0 2
6530: PPUSH
6531: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
6535: LD_VAR 0 1
6539: PPUSH
6540: LD_VAR 0 3
6544: PPUSH
6545: CALL_OW 207
// result := true ;
6549: LD_ADDR_VAR 0 4
6553: PUSH
6554: LD_INT 1
6556: ST_TO_ADDR
// end else
6557: GO 6567
// result := false ;
6559: LD_ADDR_VAR 0 4
6563: PUSH
6564: LD_INT 0
6566: ST_TO_ADDR
// end else
6567: GO 6577
// result := false ;
6569: LD_ADDR_VAR 0 4
6573: PUSH
6574: LD_INT 0
6576: ST_TO_ADDR
// end ;
6577: LD_VAR 0 4
6581: RET
// export function BuildingFull ( building ) ; begin
6582: LD_INT 0
6584: PPUSH
// if UnitsInside ( building ) = 6 then
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 313
6594: PUSH
6595: LD_INT 6
6597: EQUAL
6598: IFFALSE 6610
// result := true else
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_INT 1
6607: ST_TO_ADDR
6608: GO 6618
// result := false ;
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_INT 0
6617: ST_TO_ADDR
// end ;
6618: LD_VAR 0 2
6622: RET
// export function PrepareMines ( ) ; begin
6623: LD_INT 0
6625: PPUSH
// Randomize ;
6626: CALL_OW 10
// PlaceMinesToArea ( west_mines , Rand ( 39 , 53 ) , 0 , 5 , 0 ) ;
6630: LD_INT 4
6632: PPUSH
6633: LD_INT 39
6635: PPUSH
6636: LD_INT 53
6638: PPUSH
6639: CALL_OW 12
6643: PPUSH
6644: LD_INT 0
6646: PPUSH
6647: LD_INT 5
6649: PPUSH
6650: LD_INT 0
6652: PPUSH
6653: CALL_OW 511
// PlaceMinesToArea ( center_mines , Rand ( 61 , 74 ) , 0 , 5 , 0 ) ;
6657: LD_INT 5
6659: PPUSH
6660: LD_INT 61
6662: PPUSH
6663: LD_INT 74
6665: PPUSH
6666: CALL_OW 12
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: LD_INT 5
6676: PPUSH
6677: LD_INT 0
6679: PPUSH
6680: CALL_OW 511
// PlaceMinesToArea ( east_mines , Rand ( 36 , 59 ) , 0 , 5 , 0 ) ;
6684: LD_INT 6
6686: PPUSH
6687: LD_INT 36
6689: PPUSH
6690: LD_INT 59
6692: PPUSH
6693: CALL_OW 12
6697: PPUSH
6698: LD_INT 0
6700: PPUSH
6701: LD_INT 5
6703: PPUSH
6704: LD_INT 0
6706: PPUSH
6707: CALL_OW 511
// mines := true ;
6711: LD_ADDR_EXP 2
6715: PUSH
6716: LD_INT 1
6718: ST_TO_ADDR
// end ;
6719: LD_VAR 0 1
6723: RET
// export function InitVehicle ( n ) ; var i , list ; begin
6724: LD_INT 0
6726: PPUSH
6727: PPUSH
6728: PPUSH
// list := [ ] ;
6729: LD_ADDR_VAR 0 4
6733: PUSH
6734: EMPTY
6735: ST_TO_ADDR
// for i = 1 to n do
6736: LD_ADDR_VAR 0 3
6740: PUSH
6741: DOUBLE
6742: LD_INT 1
6744: DEC
6745: ST_TO_ADDR
6746: LD_VAR 0 1
6750: PUSH
6751: FOR_TO
6752: IFFALSE 6831
// list := list ^ [ [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_gun , ar_gatling_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ] ;
6754: LD_ADDR_VAR 0 4
6758: PUSH
6759: LD_VAR 0 4
6763: PUSH
6764: LD_INT 13
6766: PUSH
6767: LD_INT 14
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 1
6776: PPUSH
6777: LD_INT 2
6779: PPUSH
6780: CALL_OW 12
6784: ARRAY
6785: PUSH
6786: LD_INT 1
6788: PUSH
6789: LD_INT 2
6791: PUSH
6792: LD_INT 27
6794: PUSH
6795: LD_INT 25
6797: PUSH
6798: LD_INT 28
6800: PUSH
6801: LD_INT 26
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_INT 1
6812: PPUSH
6813: LD_INT 4
6815: PPUSH
6816: CALL_OW 12
6820: ARRAY
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: LIST
6826: LIST
6827: ADD
6828: ST_TO_ADDR
6829: GO 6751
6831: POP
6832: POP
// result := list ;
6833: LD_ADDR_VAR 0 2
6837: PUSH
6838: LD_VAR 0 4
6842: ST_TO_ADDR
// end ;
6843: LD_VAR 0 2
6847: RET
// export function sci ( side , spec ) ; var sci ; begin
6848: LD_INT 0
6850: PPUSH
6851: PPUSH
// sci := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) diff spec ;
6852: LD_ADDR_VAR 0 4
6856: PUSH
6857: LD_INT 22
6859: PUSH
6860: LD_VAR 0 1
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: PUSH
6869: LD_INT 25
6871: PUSH
6872: LD_INT 4
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PPUSH
6883: CALL_OW 69
6887: PUSH
6888: LD_VAR 0 2
6892: DIFF
6893: ST_TO_ADDR
// result := sci ;
6894: LD_ADDR_VAR 0 3
6898: PUSH
6899: LD_VAR 0 4
6903: ST_TO_ADDR
// end ;
6904: LD_VAR 0 3
6908: RET
// export function m ( side , spec ) ; var m ; begin
6909: LD_INT 0
6911: PPUSH
6912: PPUSH
// m := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) diff spec ;
6913: LD_ADDR_VAR 0 4
6917: PUSH
6918: LD_INT 22
6920: PUSH
6921: LD_VAR 0 1
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: LD_INT 25
6932: PUSH
6933: LD_INT 3
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: PPUSH
6944: CALL_OW 69
6948: PUSH
6949: LD_VAR 0 2
6953: DIFF
6954: ST_TO_ADDR
// result := m ;
6955: LD_ADDR_VAR 0 3
6959: PUSH
6960: LD_VAR 0 4
6964: ST_TO_ADDR
// end ;
6965: LD_VAR 0 3
6969: RET
// export function GetVehicle ( side , engine ) ; begin
6970: LD_INT 0
6972: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_engine , engine ] ] ) ;
6973: LD_ADDR_VAR 0 3
6977: PUSH
6978: LD_INT 22
6980: PUSH
6981: LD_VAR 0 1
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PUSH
6990: LD_INT 32
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PPUSH
7006: CALL_OW 69
7010: ST_TO_ADDR
// end ;
7011: LD_VAR 0 3
7015: RET
// export function FindLab ( side , kind ) ; var labs , i , j , mode ; begin
7016: LD_INT 0
7018: PPUSH
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
// mode := false ;
7023: LD_ADDR_VAR 0 7
7027: PUSH
7028: LD_INT 0
7030: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 6 ] , [ f_btype , 7 ] , [ f_btype , 8 ] ] ] ) ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: LD_INT 22
7038: PUSH
7039: LD_VAR 0 1
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 2
7050: PUSH
7051: LD_INT 30
7053: PUSH
7054: LD_INT 6
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PUSH
7061: LD_INT 30
7063: PUSH
7064: LD_INT 7
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 30
7073: PUSH
7074: LD_INT 8
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PPUSH
7091: CALL_OW 69
7095: ST_TO_ADDR
// for i = 1 to labs do
7096: LD_ADDR_VAR 0 5
7100: PUSH
7101: DOUBLE
7102: LD_INT 1
7104: DEC
7105: ST_TO_ADDR
7106: LD_VAR 0 4
7110: PUSH
7111: FOR_TO
7112: IFFALSE 7174
// for j = 1 to 2 do
7114: LD_ADDR_VAR 0 6
7118: PUSH
7119: DOUBLE
7120: LD_INT 1
7122: DEC
7123: ST_TO_ADDR
7124: LD_INT 2
7126: PUSH
7127: FOR_TO
7128: IFFALSE 7170
// if GetLabKind ( labs [ i ] , j ) = kind then
7130: LD_VAR 0 4
7134: PUSH
7135: LD_VAR 0 5
7139: ARRAY
7140: PPUSH
7141: LD_VAR 0 6
7145: PPUSH
7146: CALL_OW 268
7150: PUSH
7151: LD_VAR 0 2
7155: EQUAL
7156: IFFALSE 7168
// begin mode := true ;
7158: LD_ADDR_VAR 0 7
7162: PUSH
7163: LD_INT 1
7165: ST_TO_ADDR
// break ;
7166: GO 7170
// end ;
7168: GO 7127
7170: POP
7171: POP
7172: GO 7111
7174: POP
7175: POP
// result := mode ;
7176: LD_ADDR_VAR 0 3
7180: PUSH
7181: LD_VAR 0 7
7185: ST_TO_ADDR
// end ; end_of_file end_of_file
7186: LD_VAR 0 3
7190: RET
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 5 then
7191: LD_VAR 0 2
7195: PPUSH
7196: CALL_OW 255
7200: PUSH
7201: LD_INT 5
7203: EQUAL
7204: IFFALSE 7270
// if GetWeapon ( veh ) = ar_control_tower then
7206: LD_VAR 0 1
7210: PPUSH
7211: CALL_OW 264
7215: PUSH
7216: LD_INT 31
7218: EQUAL
7219: IFFALSE 7239
// control_towers := control_towers ^ veh else
7221: LD_ADDR_EXP 30
7225: PUSH
7226: LD_EXP 30
7230: PUSH
7231: LD_VAR 0 1
7235: ADD
7236: ST_TO_ADDR
7237: GO 7270
// if GetWeapon ( veh ) <> ar_cargo_bay then
7239: LD_VAR 0 1
7243: PPUSH
7244: CALL_OW 264
7248: PUSH
7249: LD_INT 32
7251: NONEQUAL
7252: IFFALSE 7270
// ar_vehs := ar_vehs ^ veh ;
7254: LD_ADDR_EXP 31
7258: PUSH
7259: LD_EXP 31
7263: PUSH
7264: LD_VAR 0 1
7268: ADD
7269: ST_TO_ADDR
// end ;
7270: PPOPN 2
7272: END
// on ResearchStarted ( tech , lab ) do begin if tech = 3 then
7273: LD_VAR 0 1
7277: PUSH
7278: LD_INT 3
7280: EQUAL
7281: IFFALSE 7291
// ape_brain := true ;
7283: LD_ADDR_EXP 35
7287: PUSH
7288: LD_INT 1
7290: ST_TO_ADDR
// if tech = 4 then
7291: LD_VAR 0 1
7295: PUSH
7296: LD_INT 4
7298: EQUAL
7299: IFFALSE 7309
// ape_neut := true ;
7301: LD_ADDR_EXP 36
7305: PUSH
7306: LD_INT 1
7308: ST_TO_ADDR
// end ; end_of_file
7309: PPOPN 2
7311: END
// export need_bio_lab , ape_brain , ape_neut , gensher_arrive , join_to_legion ; export function Action ; var un , str ; begin
7312: LD_INT 0
7314: PPUSH
7315: PPUSH
7316: PPUSH
// need_bio_lab := false ;
7317: LD_ADDR_EXP 34
7321: PUSH
7322: LD_INT 0
7324: ST_TO_ADDR
// ape_brain := false ;
7325: LD_ADDR_EXP 35
7329: PUSH
7330: LD_INT 0
7332: ST_TO_ADDR
// ape_neut := false ;
7333: LD_ADDR_EXP 36
7337: PUSH
7338: LD_INT 0
7340: ST_TO_ADDR
// gensher_arrive := false ;
7341: LD_ADDR_EXP 37
7345: PUSH
7346: LD_INT 0
7348: ST_TO_ADDR
// join_to_legion := false ;
7349: LD_ADDR_EXP 38
7353: PUSH
7354: LD_INT 0
7356: ST_TO_ADDR
// InGameOn ;
7357: CALL_OW 8
// CenterNowOnXY ( 49 , 30 ) ;
7361: LD_INT 49
7363: PPUSH
7364: LD_INT 30
7366: PPUSH
7367: CALL_OW 86
// if IsPlaced ( Rolf ) then
7371: LD_EXP 5
7375: PPUSH
7376: CALL_OW 305
7380: IFFALSE 7402
// begin un := Rolf ;
7382: LD_ADDR_VAR 0 2
7386: PUSH
7387: LD_EXP 5
7391: ST_TO_ADDR
// str := RL ;
7392: LD_ADDR_VAR 0 3
7396: PUSH
7397: LD_STRING RL
7399: ST_TO_ADDR
// end else
7400: GO 7487
// if IsPlaced ( Karla ) then
7402: LD_EXP 12
7406: PPUSH
7407: CALL_OW 305
7411: IFFALSE 7433
// begin un := Karla ;
7413: LD_ADDR_VAR 0 2
7417: PUSH
7418: LD_EXP 12
7422: ST_TO_ADDR
// str := KR ;
7423: LD_ADDR_VAR 0 3
7427: PUSH
7428: LD_STRING KR
7430: ST_TO_ADDR
// end else
7431: GO 7487
// begin un := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) [ Rand ( 2 , 8 ) ] ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: LD_INT 22
7440: PUSH
7441: LD_INT 2
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 21
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PPUSH
7462: CALL_OW 69
7466: PUSH
7467: LD_INT 2
7469: PPUSH
7470: LD_INT 8
7472: PPUSH
7473: CALL_OW 12
7477: ARRAY
7478: ST_TO_ADDR
// str := RG ;
7479: LD_ADDR_VAR 0 3
7483: PUSH
7484: LD_STRING RG
7486: ST_TO_ADDR
// end ; repeat Wait ( 0 0$01 ) ;
7487: LD_INT 35
7489: PPUSH
7490: CALL_OW 67
// until not IsInUnit ( Louis ) ;
7494: LD_EXP 4
7498: PPUSH
7499: CALL_OW 310
7503: NOT
7504: IFFALSE 7487
// ComExitVehicle ( Louis ) ;
7506: LD_EXP 4
7510: PPUSH
7511: CALL_OW 121
// ComTurnUnit ( Louis , un ) ;
7515: LD_EXP 4
7519: PPUSH
7520: LD_VAR 0 2
7524: PPUSH
7525: CALL_OW 119
// ComTurnUnit ( un , Louis ) ;
7529: LD_VAR 0 2
7533: PPUSH
7534: LD_EXP 4
7538: PPUSH
7539: CALL_OW 119
// Say ( Louis , 10c_DL1 ) ;
7543: LD_EXP 4
7547: PPUSH
7548: LD_STRING 10c_DL1
7550: PPUSH
7551: CALL_OW 88
// Say ( un , 10c_ & str & 1 ) ;
7555: LD_VAR 0 2
7559: PPUSH
7560: LD_STRING 10c_
7562: PUSH
7563: LD_VAR 0 3
7567: STR
7568: PUSH
7569: LD_STRING 1
7571: STR
7572: PPUSH
7573: CALL_OW 88
// Say ( Louis , 10c_DL2 ) ;
7577: LD_EXP 4
7581: PPUSH
7582: LD_STRING 10c_DL2
7584: PPUSH
7585: CALL_OW 88
// Say ( un , 10c_ & str & 2 ) ;
7589: LD_VAR 0 2
7593: PPUSH
7594: LD_STRING 10c_
7596: PUSH
7597: LD_VAR 0 3
7601: STR
7602: PUSH
7603: LD_STRING 2
7605: STR
7606: PPUSH
7607: CALL_OW 88
// Say ( Louis , 10c_DL3 ) ;
7611: LD_EXP 4
7615: PPUSH
7616: LD_STRING 10c_DL3
7618: PPUSH
7619: CALL_OW 88
// Say ( un , 10c_ & str & 3 ) ;
7623: LD_VAR 0 2
7627: PPUSH
7628: LD_STRING 10c_
7630: PUSH
7631: LD_VAR 0 3
7635: STR
7636: PUSH
7637: LD_STRING 3
7639: STR
7640: PPUSH
7641: CALL_OW 88
// SayRadio ( Shariff , 10c_DS1 ) ;
7645: LD_EXP 24
7649: PPUSH
7650: LD_STRING 10c_DS1
7652: PPUSH
7653: CALL_OW 94
// Say ( Louis , 10c_DL4 ) ;
7657: LD_EXP 4
7661: PPUSH
7662: LD_STRING 10c_DL4
7664: PPUSH
7665: CALL_OW 88
// SayRadio ( Shariff , 10c_DS2 ) ;
7669: LD_EXP 24
7673: PPUSH
7674: LD_STRING 10c_DS2
7676: PPUSH
7677: CALL_OW 94
// Say ( Louis , 10c_DL5 ) ;
7681: LD_EXP 4
7685: PPUSH
7686: LD_STRING 10c_DL5
7688: PPUSH
7689: CALL_OW 88
// SayRadio ( Shariff , 10c_DS3 ) ;
7693: LD_EXP 24
7697: PPUSH
7698: LD_STRING 10c_DS3
7700: PPUSH
7701: CALL_OW 94
// Say ( Louis , 10c_DL6 ) ;
7705: LD_EXP 4
7709: PPUSH
7710: LD_STRING 10c_DL6
7712: PPUSH
7713: CALL_OW 88
// SayRadio ( Shariff , 10c_DS4 ) ;
7717: LD_EXP 24
7721: PPUSH
7722: LD_STRING 10c_DS4
7724: PPUSH
7725: CALL_OW 94
// Say ( Louis , 10c_DL7 ) ;
7729: LD_EXP 4
7733: PPUSH
7734: LD_STRING 10c_DL7
7736: PPUSH
7737: CALL_OW 88
// SayRadio ( Shariff , 10c_DS5 ) ;
7741: LD_EXP 24
7745: PPUSH
7746: LD_STRING 10c_DS5
7748: PPUSH
7749: CALL_OW 94
// Say ( un , 10c_ & str & 4 ) ;
7753: LD_VAR 0 2
7757: PPUSH
7758: LD_STRING 10c_
7760: PUSH
7761: LD_VAR 0 3
7765: STR
7766: PUSH
7767: LD_STRING 4
7769: STR
7770: PPUSH
7771: CALL_OW 88
// Say ( Louis , 10c_DL8 ) ;
7775: LD_EXP 4
7779: PPUSH
7780: LD_STRING 10c_DL8
7782: PPUSH
7783: CALL_OW 88
// Say ( un , 10c_ & str & 5 ) ;
7787: LD_VAR 0 2
7791: PPUSH
7792: LD_STRING 10c_
7794: PUSH
7795: LD_VAR 0 3
7799: STR
7800: PUSH
7801: LD_STRING 5
7803: STR
7804: PPUSH
7805: CALL_OW 88
// Say ( Louis , 10c_DL9 ) ;
7809: LD_EXP 4
7813: PPUSH
7814: LD_STRING 10c_DL9
7816: PPUSH
7817: CALL_OW 88
// InGameOff ;
7821: CALL_OW 9
// game := true ;
7825: LD_ADDR_EXP 1
7829: PUSH
7830: LD_INT 1
7832: ST_TO_ADDR
// ChangeMissionObjectives ( Res ) ;
7833: LD_STRING Res
7835: PPUSH
7836: CALL_OW 337
// Wait ( 0 0$30 ) ;
7840: LD_INT 1050
7842: PPUSH
7843: CALL_OW 67
// PrepareDoc ;
7847: CALL 1430 0 0
// repeat Wait ( 0 0$01 ) ;
7851: LD_INT 35
7853: PPUSH
7854: CALL_OW 67
// until GetDistUnits ( Louis , Kunt ) < 9 ;
7858: LD_EXP 4
7862: PPUSH
7863: LD_EXP 22
7867: PPUSH
7868: CALL_OW 296
7872: PUSH
7873: LD_INT 9
7875: LESS
7876: IFFALSE 7851
// DialogueOn ;
7878: CALL_OW 6
// CenterOnUnits ( Kunt ) ;
7882: LD_EXP 22
7886: PPUSH
7887: CALL_OW 85
// SetSide ( Kunt , 2 ) ;
7891: LD_EXP 22
7895: PPUSH
7896: LD_INT 2
7898: PPUSH
7899: CALL_OW 235
// ComTurnUnit ( Kunt , Louis ) ;
7903: LD_EXP 22
7907: PPUSH
7908: LD_EXP 4
7912: PPUSH
7913: CALL_OW 119
// ComTurnUnit ( Louis , Kunt ) ;
7917: LD_EXP 4
7921: PPUSH
7922: LD_EXP 22
7926: PPUSH
7927: CALL_OW 119
// Say ( Kunt , 10c_KN1 ) ;
7931: LD_EXP 22
7935: PPUSH
7936: LD_STRING 10c_KN1
7938: PPUSH
7939: CALL_OW 88
// Say ( Louis , 10c_DL10 ) ;
7943: LD_EXP 4
7947: PPUSH
7948: LD_STRING 10c_DL10
7950: PPUSH
7951: CALL_OW 88
// Say ( Kunt , 10c_KN2 ) ;
7955: LD_EXP 22
7959: PPUSH
7960: LD_STRING 10c_KN2
7962: PPUSH
7963: CALL_OW 88
// if FindLab ( 2 , 13 ) then
7967: LD_INT 2
7969: PPUSH
7970: LD_INT 13
7972: PPUSH
7973: CALL 7016 0 2
7977: IFFALSE 8005
// begin Say ( Louis , 10c_DL11a ) ;
7979: LD_EXP 4
7983: PPUSH
7984: LD_STRING 10c_DL11a
7986: PPUSH
7987: CALL_OW 88
// Say ( Kunt , 10c_KN3a ) ;
7991: LD_EXP 22
7995: PPUSH
7996: LD_STRING 10c_KN3a
7998: PPUSH
7999: CALL_OW 88
// end else
8003: GO 8111
// begin Say ( Louis , 10c_DL11b ) ;
8005: LD_EXP 4
8009: PPUSH
8010: LD_STRING 10c_DL11b
8012: PPUSH
8013: CALL_OW 88
// Say ( Kunt , 10c_KN3b ) ;
8017: LD_EXP 22
8021: PPUSH
8022: LD_STRING 10c_KN3b
8024: PPUSH
8025: CALL_OW 88
// if IsPlaced ( Rolf ) then
8029: LD_EXP 5
8033: PPUSH
8034: CALL_OW 305
8038: IFFALSE 8100
// begin Say ( Rolf , 10c_RF_doc1 ) ;
8040: LD_EXP 5
8044: PPUSH
8045: LD_STRING 10c_RF_doc1
8047: PPUSH
8048: CALL_OW 88
// Say ( Kunt , 10c_KN_doc1 ) ;
8052: LD_EXP 22
8056: PPUSH
8057: LD_STRING 10c_KN_doc1
8059: PPUSH
8060: CALL_OW 88
// Say ( Rolf , 10c_RF_doc2 ) ;
8064: LD_EXP 5
8068: PPUSH
8069: LD_STRING 10c_RF_doc2
8071: PPUSH
8072: CALL_OW 88
// Say ( Louis , 10c_DL_doc1 ) ;
8076: LD_EXP 4
8080: PPUSH
8081: LD_STRING 10c_DL_doc1
8083: PPUSH
8084: CALL_OW 88
// Say ( Kunt , 10c_KN_doc2 ) ;
8088: LD_EXP 22
8092: PPUSH
8093: LD_STRING 10c_KN_doc2
8095: PPUSH
8096: CALL_OW 88
// end ; DialogueOff ;
8100: CALL_OW 7
// ChangeMissionObjectives ( BioLab ) ;
8104: LD_STRING BioLab
8106: PPUSH
8107: CALL_OW 337
// end ; DialogueOff ;
8111: CALL_OW 7
// end ;
8115: LD_VAR 0 1
8119: RET
// every 0 0$01 trigger need_bio_lab and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , 13 ] ] ) do
8120: LD_EXP 34
8124: PUSH
8125: LD_INT 22
8127: PUSH
8128: LD_INT 2
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PUSH
8135: LD_INT 30
8137: PUSH
8138: LD_INT 13
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 69
8153: AND
8154: IFFALSE 8166
8156: GO 8158
8158: DISABLE
// ChangeMissionObjectives ( DesBioLab ) ;
8159: LD_STRING DesBioLab
8161: PPUSH
8162: CALL_OW 337
8166: END
// every 0 0$01 trigger GetTech ( tech_apelang , 2 ) = state_researched and GetSide ( Kunt ) = 2 do
8167: LD_INT 1
8169: PPUSH
8170: LD_INT 2
8172: PPUSH
8173: CALL_OW 321
8177: PUSH
8178: LD_INT 2
8180: EQUAL
8181: PUSH
8182: LD_EXP 22
8186: PPUSH
8187: CALL_OW 255
8191: PUSH
8192: LD_INT 2
8194: EQUAL
8195: AND
8196: IFFALSE 8259
8198: GO 8200
8200: DISABLE
// begin Say ( Kunt , 10c_KN-ape-1 ) ;
8201: LD_EXP 22
8205: PPUSH
8206: LD_STRING 10c_KN-ape-1
8208: PPUSH
8209: CALL_OW 88
// CreateApemans ( 5 , east_ape ) ;
8213: LD_INT 5
8215: PPUSH
8216: LD_INT 13
8218: PPUSH
8219: CALL 5163 0 2
// CreateTigers ( 1 + Difficulty , east_ape , [ 10 , 20 , 30 ] [ Difficulty ] ) ;
8223: LD_INT 1
8225: PUSH
8226: LD_OWVAR 67
8230: PLUS
8231: PPUSH
8232: LD_INT 13
8234: PPUSH
8235: LD_INT 10
8237: PUSH
8238: LD_INT 20
8240: PUSH
8241: LD_INT 30
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: PUSH
8249: LD_OWVAR 67
8253: ARRAY
8254: PPUSH
8255: CALL 5316 0 3
// end ;
8259: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman ] ] ) do
8260: LD_INT 22
8262: PUSH
8263: LD_INT 2
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 25
8272: PUSH
8273: LD_INT 12
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: PPUSH
8284: CALL_OW 69
8288: IFFALSE 8331
8290: GO 8292
8292: DISABLE
// begin Say ( Kunt , 10c_KN-ape2 ) ;
8293: LD_EXP 22
8297: PPUSH
8298: LD_STRING 10c_KN-ape2
8300: PPUSH
8301: CALL_OW 88
// SetTech ( 3 , 2 , state_enabled ) ;
8305: LD_INT 3
8307: PPUSH
8308: LD_INT 2
8310: PPUSH
8311: LD_INT 1
8313: PPUSH
8314: CALL_OW 322
// SetTech ( 4 , 2 , state_enabled ) ;
8318: LD_INT 4
8320: PPUSH
8321: LD_INT 2
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: CALL_OW 322
// end ;
8331: END
// every 0 0$01 trigger ape_brain do
8332: LD_EXP 35
8336: IFFALSE 8432
8338: GO 8340
8340: DISABLE
// begin DialogueOn ;
8341: CALL_OW 6
// Say ( Louis , 10c_DL-apbrain1 ) ;
8345: LD_EXP 4
8349: PPUSH
8350: LD_STRING 10c_DL-apbrain1
8352: PPUSH
8353: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain1 ) ;
8357: LD_EXP 22
8361: PPUSH
8362: LD_STRING 10c_KN-apbrain1
8364: PPUSH
8365: CALL_OW 88
// Say ( Louis , 10c_DL-apbrain2 ) ;
8369: LD_EXP 4
8373: PPUSH
8374: LD_STRING 10c_DL-apbrain2
8376: PPUSH
8377: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain2 ) ;
8381: LD_EXP 22
8385: PPUSH
8386: LD_STRING 10c_KN-apbrain2
8388: PPUSH
8389: CALL_OW 88
// if IsLive ( Rolf ) then
8393: LD_EXP 5
8397: PPUSH
8398: CALL_OW 300
8402: IFFALSE 8428
// begin Say ( Rolf , 10c_RF-apbrain1 ) ;
8404: LD_EXP 5
8408: PPUSH
8409: LD_STRING 10c_RF-apbrain1
8411: PPUSH
8412: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain3 ) ;
8416: LD_EXP 22
8420: PPUSH
8421: LD_STRING 10c_KN-apbrain3
8423: PPUSH
8424: CALL_OW 88
// end ; DialogueOff ;
8428: CALL_OW 7
// end ;
8432: END
// every 0 0$01 trigger ape_neut do
8433: LD_EXP 36
8437: IFFALSE 8597
8439: GO 8441
8441: DISABLE
// begin DialogueOn ;
8442: CALL_OW 6
// Say ( Louis , 10c_DL-apenatur1 ) ;
8446: LD_EXP 4
8450: PPUSH
8451: LD_STRING 10c_DL-apenatur1
8453: PPUSH
8454: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur1 ) ;
8458: LD_EXP 22
8462: PPUSH
8463: LD_STRING 10c_KN-apenatur1
8465: PPUSH
8466: CALL_OW 88
// Say ( Louis , 10c_DL-apenatur2 ) ;
8470: LD_EXP 4
8474: PPUSH
8475: LD_STRING 10c_DL-apenatur2
8477: PPUSH
8478: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur2 ) ;
8482: LD_EXP 22
8486: PPUSH
8487: LD_STRING 10c_KN-apenatur2
8489: PPUSH
8490: CALL_OW 88
// Say ( Louis , 10c_DL-apenatur3 ) ;
8494: LD_EXP 4
8498: PPUSH
8499: LD_STRING 10c_DL-apenatur3
8501: PPUSH
8502: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur3 ) ;
8506: LD_EXP 22
8510: PPUSH
8511: LD_STRING 10c_KN-apenatur3
8513: PPUSH
8514: CALL_OW 88
// DialogueOff ;
8518: CALL_OW 7
// Wait ( Rand ( 0 0$14 , 0 0$37 ) ) ;
8522: LD_INT 490
8524: PPUSH
8525: LD_INT 1295
8527: PPUSH
8528: CALL_OW 12
8532: PPUSH
8533: CALL_OW 67
// InGameOn ;
8537: CALL_OW 8
// CenterOnUnits ( Kunt ) ;
8541: LD_EXP 22
8545: PPUSH
8546: CALL_OW 85
// Wait ( 0 0$02 ) ;
8550: LD_INT 70
8552: PPUSH
8553: CALL_OW 67
// SetLives ( IsInUnit ( Kunt ) , 1 ) ;
8557: LD_EXP 22
8561: PPUSH
8562: CALL_OW 310
8566: PPUSH
8567: LD_INT 1
8569: PPUSH
8570: CALL_OW 234
// Wait ( 0 0$01 ) ;
8574: LD_INT 35
8576: PPUSH
8577: CALL_OW 67
// Say ( Kunt , 10c_KN-labruin1 ) ;
8581: LD_EXP 22
8585: PPUSH
8586: LD_STRING 10c_KN-labruin1
8588: PPUSH
8589: CALL_OW 88
// InGameOff ;
8593: CALL_OW 9
// end ;
8597: END
// every 0 0$01 trigger GetTech ( 2 , tech_sibPow ) = state_researched do
8598: LD_INT 2
8600: PPUSH
8601: LD_INT 21
8603: PPUSH
8604: CALL_OW 321
8608: PUSH
8609: LD_INT 2
8611: EQUAL
8612: IFFALSE 8641
8614: GO 8616
8616: DISABLE
// begin Say ( sci ( 2 , Kunt ) [ 1 ] , 10c_DS-SibEng1 ) ;
8617: LD_INT 2
8619: PPUSH
8620: LD_EXP 22
8624: PPUSH
8625: CALL 6848 0 2
8629: PUSH
8630: LD_INT 1
8632: ARRAY
8633: PPUSH
8634: LD_STRING 10c_DS-SibEng1
8636: PPUSH
8637: CALL_OW 88
// end ;
8641: END
// every 0 0$01 trigger GetTech ( 2 , tech_sibEng ) = state_researched do
8642: LD_INT 2
8644: PPUSH
8645: LD_INT 22
8647: PPUSH
8648: CALL_OW 321
8652: PUSH
8653: LD_INT 2
8655: EQUAL
8656: IFFALSE 8713
8658: GO 8660
8660: DISABLE
// begin Say ( sci ( 2 , [ Kunt , Louis ] ) [ 1 ] , 10c_DS-SibEng2 ) ;
8661: LD_INT 2
8663: PPUSH
8664: LD_EXP 22
8668: PUSH
8669: LD_EXP 4
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL 6848 0 2
8682: PUSH
8683: LD_INT 1
8685: ARRAY
8686: PPUSH
8687: LD_STRING 10c_DS-SibEng2
8689: PPUSH
8690: CALL_OW 88
// Say ( Louis , 10c_DL-SibEng1 ) ;
8694: LD_EXP 4
8698: PPUSH
8699: LD_STRING 10c_DL-SibEng1
8701: PPUSH
8702: CALL_OW 88
// ChangeMissionObjectives ( SibEng ) ;
8706: LD_STRING SibEng
8708: PPUSH
8709: CALL_OW 337
// end ;
8713: END
// every 0 0$01 trigger GetVehicle ( 2 , engine_siberite ) do
8714: LD_INT 2
8716: PPUSH
8717: LD_INT 3
8719: PPUSH
8720: CALL 6970 0 2
8724: IFFALSE 8767
8726: GO 8728
8728: DISABLE
// begin Say ( m ( 2 , Louis ) [ 1 ] , 10c_DS-SibEng3 ) ;
8729: LD_INT 2
8731: PPUSH
8732: LD_EXP 4
8736: PPUSH
8737: CALL 6909 0 2
8741: PUSH
8742: LD_INT 1
8744: ARRAY
8745: PPUSH
8746: LD_STRING 10c_DS-SibEng3
8748: PPUSH
8749: CALL_OW 88
// Wait ( 0 0$44 ) ;
8753: LD_INT 1540
8755: PPUSH
8756: CALL_OW 67
// ChangeMissionObjectives ( SibEngOut ) ;
8760: LD_STRING SibEngOut
8762: PPUSH
8763: CALL_OW 337
// end ;
8767: END
// every 18 18$19 do
8768: GO 8770
8770: DISABLE
// begin SayRadio ( Shariff , 10c_DS-Cm1 ) ;
8771: LD_EXP 24
8775: PPUSH
8776: LD_STRING 10c_DS-Cm1
8778: PPUSH
8779: CALL_OW 94
// end ;
8783: END
// every 27 27$12 do
8784: GO 8786
8786: DISABLE
// begin SayRadio ( Gensher , 10c_DG-Cm1 ) ;
8787: LD_EXP 25
8791: PPUSH
8792: LD_STRING 10c_DG-Cm1
8794: PPUSH
8795: CALL_OW 94
// end ;
8799: END
// every 30 30$00 trigger join_to_legion = false do
8800: LD_EXP 38
8804: PUSH
8805: LD_INT 0
8807: EQUAL
8808: IFFALSE 8817
8810: GO 8812
8812: DISABLE
// begin PrepareAttack ( ) ;
8813: CALL 9254 0 0
// end ;
8817: END
// every 29 29$00 do
8818: GO 8820
8820: DISABLE
// begin InGameOn ;
8821: CALL_OW 8
// SayRadio ( Kurt , 10c_DK-LegionOffer1 ) ;
8825: LD_EXP 27
8829: PPUSH
8830: LD_STRING 10c_DK-LegionOffer1
8832: PPUSH
8833: CALL_OW 94
// InGameOff ;
8837: CALL_OW 9
// ChangeMissionObjectives ( Legion ) ;
8841: LD_STRING Legion
8843: PPUSH
8844: CALL_OW 337
// end ; end_of_file
8848: END
// every 1 1$00 + 0 0$25 trigger game do var amount , time , p ;
8849: LD_EXP 1
8853: IFFALSE 9251
8855: GO 8857
8857: DISABLE
8858: LD_INT 0
8860: PPUSH
8861: PPUSH
8862: PPUSH
// begin time := [ 1 1$30 , 2 2$00 , 2 2$40 ] [ Difficulty ] ;
8863: LD_ADDR_VAR 0 2
8867: PUSH
8868: LD_INT 3150
8870: PUSH
8871: LD_INT 4200
8873: PUSH
8874: LD_INT 5600
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: LIST
8881: PUSH
8882: LD_OWVAR 67
8886: ARRAY
8887: ST_TO_ADDR
// case Difficulty of 1 :
8888: LD_OWVAR 67
8892: PUSH
8893: LD_INT 1
8895: DOUBLE
8896: EQUAL
8897: IFTRUE 8901
8899: GO 8912
8901: POP
// amount := 3000 ; 2 :
8902: LD_ADDR_VAR 0 1
8906: PUSH
8907: LD_INT 3000
8909: ST_TO_ADDR
8910: GO 8951
8912: LD_INT 2
8914: DOUBLE
8915: EQUAL
8916: IFTRUE 8920
8918: GO 8931
8920: POP
// amount := 2400 ; 3 :
8921: LD_ADDR_VAR 0 1
8925: PUSH
8926: LD_INT 2400
8928: ST_TO_ADDR
8929: GO 8951
8931: LD_INT 3
8933: DOUBLE
8934: EQUAL
8935: IFTRUE 8939
8937: GO 8950
8939: POP
// amount := 1900 ; end ;
8940: LD_ADDR_VAR 0 1
8944: PUSH
8945: LD_INT 1900
8947: ST_TO_ADDR
8948: GO 8951
8950: POP
// repeat begin p := Rand ( 1 , 5 ) ;
8951: LD_ADDR_VAR 0 3
8955: PUSH
8956: LD_INT 1
8958: PPUSH
8959: LD_INT 5
8961: PPUSH
8962: CALL_OW 12
8966: ST_TO_ADDR
// amount := amount - ( p * 10 ) ;
8967: LD_ADDR_VAR 0 1
8971: PUSH
8972: LD_VAR 0 1
8976: PUSH
8977: LD_VAR 0 3
8981: PUSH
8982: LD_INT 10
8984: MUL
8985: MINUS
8986: ST_TO_ADDR
// CreateCratesArea ( p , first_spawn , true ) ;
8987: LD_VAR 0 3
8991: PPUSH
8992: LD_INT 11
8994: PPUSH
8995: LD_INT 1
8997: PPUSH
8998: CALL_OW 55
// Wait ( time + Rand ( - 0 0$10 , 0 0$15 ) ) ;
9002: LD_VAR 0 2
9006: PUSH
9007: LD_INT 350
9009: NEG
9010: PPUSH
9011: LD_INT 525
9013: PPUSH
9014: CALL_OW 12
9018: PLUS
9019: PPUSH
9020: CALL_OW 67
// end until amount > 0 ;
9024: LD_VAR 0 1
9028: PUSH
9029: LD_INT 0
9031: GREATER
9032: IFFALSE 8951
// time := [ 2 2$30 , 3 3$00 , 3 3$40 ] [ Difficulty ] ;
9034: LD_ADDR_VAR 0 2
9038: PUSH
9039: LD_INT 5250
9041: PUSH
9042: LD_INT 6300
9044: PUSH
9045: LD_INT 7700
9047: PUSH
9048: EMPTY
9049: LIST
9050: LIST
9051: LIST
9052: PUSH
9053: LD_OWVAR 67
9057: ARRAY
9058: ST_TO_ADDR
// case Difficulty of 1 :
9059: LD_OWVAR 67
9063: PUSH
9064: LD_INT 1
9066: DOUBLE
9067: EQUAL
9068: IFTRUE 9072
9070: GO 9083
9072: POP
// amount := 9000 ; 2 :
9073: LD_ADDR_VAR 0 1
9077: PUSH
9078: LD_INT 9000
9080: ST_TO_ADDR
9081: GO 9122
9083: LD_INT 2
9085: DOUBLE
9086: EQUAL
9087: IFTRUE 9091
9089: GO 9102
9091: POP
// amount := 7400 ; 3 :
9092: LD_ADDR_VAR 0 1
9096: PUSH
9097: LD_INT 7400
9099: ST_TO_ADDR
9100: GO 9122
9102: LD_INT 3
9104: DOUBLE
9105: EQUAL
9106: IFTRUE 9110
9108: GO 9121
9110: POP
// amount := 5900 ; end ;
9111: LD_ADDR_VAR 0 1
9115: PUSH
9116: LD_INT 5900
9118: ST_TO_ADDR
9119: GO 9122
9121: POP
// repeat begin p := Rand ( 1 , 5 ) ;
9122: LD_ADDR_VAR 0 3
9126: PUSH
9127: LD_INT 1
9129: PPUSH
9130: LD_INT 5
9132: PPUSH
9133: CALL_OW 12
9137: ST_TO_ADDR
// amount := amount - ( p * 10 ) ;
9138: LD_ADDR_VAR 0 1
9142: PUSH
9143: LD_VAR 0 1
9147: PUSH
9148: LD_VAR 0 3
9152: PUSH
9153: LD_INT 10
9155: MUL
9156: MINUS
9157: ST_TO_ADDR
// CreateCratesArea ( p , second_spawn , true ) ;
9158: LD_VAR 0 3
9162: PPUSH
9163: LD_INT 12
9165: PPUSH
9166: LD_INT 1
9168: PPUSH
9169: CALL_OW 55
// Wait ( time + Rand ( - 0 0$10 , 0 0$25 ) ) ;
9173: LD_VAR 0 2
9177: PUSH
9178: LD_INT 350
9180: NEG
9181: PPUSH
9182: LD_INT 875
9184: PPUSH
9185: CALL_OW 12
9189: PLUS
9190: PPUSH
9191: CALL_OW 67
// end until amount > 0 ;
9195: LD_VAR 0 1
9199: PUSH
9200: LD_INT 0
9202: GREATER
9203: IFFALSE 9122
// while ( true ) do
9205: LD_INT 1
9207: IFFALSE 9251
// begin Wait ( time + Rand ( - 0 0$10 , 0 0$25 ) ) ;
9209: LD_VAR 0 2
9213: PUSH
9214: LD_INT 350
9216: NEG
9217: PPUSH
9218: LD_INT 875
9220: PPUSH
9221: CALL_OW 12
9225: PLUS
9226: PPUSH
9227: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9231: LD_INT 1
9233: PPUSH
9234: LD_INT 5
9236: PPUSH
9237: CALL_OW 12
9241: PPUSH
9242: LD_INT 1
9244: PPUSH
9245: CALL_OW 57
// end ;
9249: GO 9205
// end ; end_of_file
9251: PPOPN 3
9253: END
// export function PrepareAttack ( ) ; var i , un , east_tab , west_tab , skill , veh ; begin
9254: LD_INT 0
9256: PPUSH
9257: PPUSH
9258: PPUSH
9259: PPUSH
9260: PPUSH
9261: PPUSH
9262: PPUSH
// Randomize ;
9263: CALL_OW 10
// east_tab := [ ] ;
9267: LD_ADDR_VAR 0 4
9271: PUSH
9272: EMPTY
9273: ST_TO_ADDR
// west_tab := [ ] ;
9274: LD_ADDR_VAR 0 5
9278: PUSH
9279: EMPTY
9280: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
9281: LD_ADDR_VAR 0 6
9285: PUSH
9286: LD_INT 7
9288: PUSH
9289: LD_INT 8
9291: PUSH
9292: LD_INT 9
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: LIST
9299: PUSH
9300: LD_OWVAR 67
9304: ARRAY
9305: ST_TO_ADDR
// uc_side := 1 ;
9306: LD_ADDR_OWVAR 20
9310: PUSH
9311: LD_INT 1
9313: ST_TO_ADDR
// uc_nation := 1 ;
9314: LD_ADDR_OWVAR 21
9318: PUSH
9319: LD_INT 1
9321: ST_TO_ADDR
// hc_name :=  ;
9322: LD_ADDR_OWVAR 26
9326: PUSH
9327: LD_STRING 
9329: ST_TO_ADDR
// hc_gallery :=  ;
9330: LD_ADDR_OWVAR 33
9334: PUSH
9335: LD_STRING 
9337: ST_TO_ADDR
// vc_chassis := us_medium_tracked ;
9338: LD_ADDR_OWVAR 37
9342: PUSH
9343: LD_INT 3
9345: ST_TO_ADDR
// vc_engine := engine_combustion ;
9346: LD_ADDR_OWVAR 39
9350: PUSH
9351: LD_INT 1
9353: ST_TO_ADDR
// vc_control := control_manual ;
9354: LD_ADDR_OWVAR 38
9358: PUSH
9359: LD_INT 1
9361: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
9362: LD_ADDR_VAR 0 2
9366: PUSH
9367: DOUBLE
9368: LD_INT 1
9370: DEC
9371: ST_TO_ADDR
9372: LD_INT 5
9374: PUSH
9375: LD_INT 6
9377: PUSH
9378: LD_INT 7
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_OWVAR 67
9390: ARRAY
9391: PUSH
9392: FOR_TO
9393: IFFALSE 9518
// begin vc_weapon := [ us_rocket_launcher , us_double_gun , us_rocket_launcher , us_double_gun , us_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
9395: LD_ADDR_OWVAR 40
9399: PUSH
9400: LD_INT 7
9402: PUSH
9403: LD_INT 5
9405: PUSH
9406: LD_INT 7
9408: PUSH
9409: LD_INT 5
9411: PUSH
9412: LD_INT 4
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_INT 1
9424: PPUSH
9425: LD_INT 5
9427: PPUSH
9428: CALL_OW 12
9432: ARRAY
9433: ST_TO_ADDR
// veh := CreateVehicle ;
9434: LD_ADDR_VAR 0 7
9438: PUSH
9439: CALL_OW 45
9443: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
9444: LD_VAR 0 7
9448: PPUSH
9449: LD_INT 3
9451: PPUSH
9452: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9456: LD_VAR 0 7
9460: PPUSH
9461: LD_INT 15
9463: PPUSH
9464: LD_INT 0
9466: PPUSH
9467: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
9471: LD_INT 0
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: LD_VAR 0 6
9481: PPUSH
9482: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
9486: CALL_OW 44
9490: PPUSH
9491: LD_VAR 0 7
9495: PPUSH
9496: CALL_OW 52
// east_tab := east_tab ^ veh ;
9500: LD_ADDR_VAR 0 4
9504: PUSH
9505: LD_VAR 0 4
9509: PUSH
9510: LD_VAR 0 7
9514: ADD
9515: ST_TO_ADDR
// end ;
9516: GO 9392
9518: POP
9519: POP
// end ;
9520: LD_VAR 0 1
9524: RET
