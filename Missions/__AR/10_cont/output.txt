// starting begin ResetFog ;
   0: CALL_OW 335
// debug := false ;
   4: LD_ADDR_EXP 3
   8: PUSH
   9: LD_INT 0
  11: ST_TO_ADDR
// game := false ;
  12: LD_ADDR_EXP 1
  16: PUSH
  17: LD_INT 0
  19: ST_TO_ADDR
// mines := false ;
  20: LD_ADDR_EXP 2
  24: PUSH
  25: LD_INT 0
  27: ST_TO_ADDR
// ChangeSideFog ( 5 , 2 ) ;
  28: LD_INT 5
  30: PPUSH
  31: LD_INT 2
  33: PPUSH
  34: CALL_OW 343
// CreateApemans ( 6 , west_ape ) ;
  38: LD_INT 6
  40: PPUSH
  41: LD_INT 3
  43: PPUSH
  44: CALL 5110 0 2
// PrepareSouthBase ;
  48: CALL 1716 0 0
// LoadPeople ;
  52: CALL 104 0 0
// PrepareBase ;
  56: CALL 1179 0 0
// PrepareMainCharacters ;
  60: CALL 1522 0 0
// Action ;
  64: CALL 7259 0 0
// if debug then
  68: LD_EXP 3
  72: IFFALSE 103
// begin FogOff ( 2 ) ;
  74: LD_INT 2
  76: PPUSH
  77: CALL_OW 344
// CreateApemans ( 6 , west_ape ) ;
  81: LD_INT 6
  83: PPUSH
  84: LD_INT 3
  86: PPUSH
  87: CALL 5110 0 2
// PrepareMines ( ) ;
  91: CALL 6570 0 0
// Your_Side := 5 ;
  95: LD_ADDR_OWVAR 2
  99: PUSH
 100: LD_INT 5
 102: ST_TO_ADDR
// end ; end ;
 103: END
// export game , mines ; export debug ; end_of_file export Louis , Rolf , Jenna , Nicolas , Rick , Mike , Gali , Martin , Karla , Dwein , Joachim , Olaf , Mmark , Herczeg , Mia , Kantor , Ronn , Gunther ; export function LoadPeople ; var p , i , un , names , names2 , filter , main_filter , others , team , ftp , list , veh ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// uc_side := 2 ;
 119: LD_ADDR_OWVAR 20
 123: PUSH
 124: LD_INT 2
 126: ST_TO_ADDR
// uc_nation := nation_arabian ;
 127: LD_ADDR_OWVAR 21
 131: PUSH
 132: LD_INT 2
 134: ST_TO_ADDR
// names := [ Louis , Jenna_09c , Gali_09c , Nicolas_09c , Rick_09c , Mike_09c , Rolf_09c , Martin_07 , Karla_07 , Dwein_07 , Joachim_07 , Olaf_07 , Mmark_07 , Herczeg_07 , Kantor_07 , Mia_07 , Ronn_07 , Gunther_07 ] ;
 135: LD_ADDR_VAR 0 5
 139: PUSH
 140: LD_STRING Louis
 142: PUSH
 143: LD_STRING Jenna_09c
 145: PUSH
 146: LD_STRING Gali_09c
 148: PUSH
 149: LD_STRING Nicolas_09c
 151: PUSH
 152: LD_STRING Rick_09c
 154: PUSH
 155: LD_STRING Mike_09c
 157: PUSH
 158: LD_STRING Rolf_09c
 160: PUSH
 161: LD_STRING Martin_07
 163: PUSH
 164: LD_STRING Karla_07
 166: PUSH
 167: LD_STRING Dwein_07
 169: PUSH
 170: LD_STRING Joachim_07
 172: PUSH
 173: LD_STRING Olaf_07
 175: PUSH
 176: LD_STRING Mmark_07
 178: PUSH
 179: LD_STRING Herczeg_07
 181: PUSH
 182: LD_STRING Kantor_07
 184: PUSH
 185: LD_STRING Mia_07
 187: PUSH
 188: LD_STRING Ronn_07
 190: PUSH
 191: LD_STRING Gunther_07
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: LIST
 200: LIST
 201: LIST
 202: LIST
 203: LIST
 204: LIST
 205: LIST
 206: LIST
 207: LIST
 208: LIST
 209: LIST
 210: LIST
 211: LIST
 212: LIST
 213: ST_TO_ADDR
// names2 := [ a_09c , b_09c , c_09c , d_09c , e_09c , f_09c , g_09c , h_09c , i_09c , j_09c , k_09c , l_09c , m_09c , n_09c , o_09c , p_09c ] ;
 214: LD_ADDR_VAR 0 6
 218: PUSH
 219: LD_STRING a_09c
 221: PUSH
 222: LD_STRING b_09c
 224: PUSH
 225: LD_STRING c_09c
 227: PUSH
 228: LD_STRING d_09c
 230: PUSH
 231: LD_STRING e_09c
 233: PUSH
 234: LD_STRING f_09c
 236: PUSH
 237: LD_STRING g_09c
 239: PUSH
 240: LD_STRING h_09c
 242: PUSH
 243: LD_STRING i_09c
 245: PUSH
 246: LD_STRING j_09c
 248: PUSH
 249: LD_STRING k_09c
 251: PUSH
 252: LD_STRING l_09c
 254: PUSH
 255: LD_STRING m_09c
 257: PUSH
 258: LD_STRING n_09c
 260: PUSH
 261: LD_STRING o_09c
 263: PUSH
 264: LD_STRING p_09c
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: LIST
 281: LIST
 282: LIST
 283: LIST
 284: ST_TO_ADDR
// filter := 0 ;
 285: LD_ADDR_VAR 0 7
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// ftp := [ ] ;
 293: LD_ADDR_VAR 0 11
 297: PUSH
 298: EMPTY
 299: ST_TO_ADDR
// others := [ ] ;
 300: LD_ADDR_VAR 0 9
 304: PUSH
 305: EMPTY
 306: ST_TO_ADDR
// Louis := CreateCharacter ( Louis ) ;
 307: LD_ADDR_EXP 4
 311: PUSH
 312: LD_STRING Louis
 314: PPUSH
 315: CALL_OW 34
 319: ST_TO_ADDR
// Jenna := CreateCharacter ( Jenna_09c ) ;
 320: LD_ADDR_EXP 6
 324: PUSH
 325: LD_STRING Jenna_09c
 327: PPUSH
 328: CALL_OW 34
 332: ST_TO_ADDR
// Gali := CreateCharacter ( Gali_09c ) ;
 333: LD_ADDR_EXP 10
 337: PUSH
 338: LD_STRING Gali_09c
 340: PPUSH
 341: CALL_OW 34
 345: ST_TO_ADDR
// Rick := CreateCharacter ( Rick_09c ) ;
 346: LD_ADDR_EXP 8
 350: PUSH
 351: LD_STRING Rick_09c
 353: PPUSH
 354: CALL_OW 34
 358: ST_TO_ADDR
// Rolf := CreateCharacter ( Rolf_09c ) ;
 359: LD_ADDR_EXP 5
 363: PUSH
 364: LD_STRING Rolf_09c
 366: PPUSH
 367: CALL_OW 34
 371: ST_TO_ADDR
// Nicolas := CreateCharacter ( Nicolas_09c ) ;
 372: LD_ADDR_EXP 7
 376: PUSH
 377: LD_STRING Nicolas_09c
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
// Mike := CreateCharacter ( Mike_09c ) ;
 385: LD_ADDR_EXP 9
 389: PUSH
 390: LD_STRING Mike_09c
 392: PPUSH
 393: CALL_OW 34
 397: ST_TO_ADDR
// Martin := CreateCharacter ( Martin_07 ) ;
 398: LD_ADDR_EXP 11
 402: PUSH
 403: LD_STRING Martin_07
 405: PPUSH
 406: CALL_OW 34
 410: ST_TO_ADDR
// Karla := CreateCharacter ( Karla_07 ) ;
 411: LD_ADDR_EXP 12
 415: PUSH
 416: LD_STRING Karla_07
 418: PPUSH
 419: CALL_OW 34
 423: ST_TO_ADDR
// Dwein := CreateCharacter ( Dwein_07 ) ;
 424: LD_ADDR_EXP 13
 428: PUSH
 429: LD_STRING Dwein_07
 431: PPUSH
 432: CALL_OW 34
 436: ST_TO_ADDR
// Joachim := CreateCharacter ( Joachim_07 ) ;
 437: LD_ADDR_EXP 14
 441: PUSH
 442: LD_STRING Joachim_07
 444: PPUSH
 445: CALL_OW 34
 449: ST_TO_ADDR
// Olaf := CreateCharacter ( Olaf_07 ) ;
 450: LD_ADDR_EXP 15
 454: PUSH
 455: LD_STRING Olaf_07
 457: PPUSH
 458: CALL_OW 34
 462: ST_TO_ADDR
// Mmark := CreateCharacter ( Mmark_07 ) ;
 463: LD_ADDR_EXP 16
 467: PUSH
 468: LD_STRING Mmark_07
 470: PPUSH
 471: CALL_OW 34
 475: ST_TO_ADDR
// Herczeg := CreateCharacter ( Herczeg_07 ) ;
 476: LD_ADDR_EXP 17
 480: PUSH
 481: LD_STRING Herczeg_07
 483: PPUSH
 484: CALL_OW 34
 488: ST_TO_ADDR
// Mia := CreateCharacter ( Mia_07 ) ;
 489: LD_ADDR_EXP 18
 493: PUSH
 494: LD_STRING Mia_07
 496: PPUSH
 497: CALL_OW 34
 501: ST_TO_ADDR
// Kantor := CreateCharacter ( Kantor_07 ) ;
 502: LD_ADDR_EXP 19
 506: PUSH
 507: LD_STRING Kantor_07
 509: PPUSH
 510: CALL_OW 34
 514: ST_TO_ADDR
// Gunther := CreateCharacter ( Gunther_07 ) ;
 515: LD_ADDR_EXP 21
 519: PUSH
 520: LD_STRING Gunther_07
 522: PPUSH
 523: CALL_OW 34
 527: ST_TO_ADDR
// Ronn := CreateCharacter ( Ronn_07 ) ;
 528: LD_ADDR_EXP 20
 532: PUSH
 533: LD_STRING Ronn_07
 535: PPUSH
 536: CALL_OW 34
 540: ST_TO_ADDR
// main_filter := [ Rolf , Jenna , Nicolas , Rick , Mike , Gali , Martin , Karla , Dwein , Joachim , Olaf , Mmark , Herczeg , Mia , Kantor , Ronn , Gunther ] ;
 541: LD_ADDR_VAR 0 8
 545: PUSH
 546: LD_EXP 5
 550: PUSH
 551: LD_EXP 6
 555: PUSH
 556: LD_EXP 7
 560: PUSH
 561: LD_EXP 8
 565: PUSH
 566: LD_EXP 9
 570: PUSH
 571: LD_EXP 10
 575: PUSH
 576: LD_EXP 11
 580: PUSH
 581: LD_EXP 12
 585: PUSH
 586: LD_EXP 13
 590: PUSH
 591: LD_EXP 14
 595: PUSH
 596: LD_EXP 15
 600: PUSH
 601: LD_EXP 16
 605: PUSH
 606: LD_EXP 17
 610: PUSH
 611: LD_EXP 18
 615: PUSH
 616: LD_EXP 19
 620: PUSH
 621: LD_EXP 20
 625: PUSH
 626: LD_EXP 21
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// for i = 1 to main_filter do
 650: LD_ADDR_VAR 0 3
 654: PUSH
 655: DOUBLE
 656: LD_INT 1
 658: DEC
 659: ST_TO_ADDR
 660: LD_VAR 0 8
 664: PUSH
 665: FOR_TO
 666: IFFALSE 701
// if IsLive ( main_filter [ i ] ) then
 668: LD_VAR 0 8
 672: PUSH
 673: LD_VAR 0 3
 677: ARRAY
 678: PPUSH
 679: CALL_OW 300
 683: IFFALSE 699
// begin filter := filter + 1 ;
 685: LD_ADDR_VAR 0 7
 689: PUSH
 690: LD_VAR 0 7
 694: PUSH
 695: LD_INT 1
 697: PLUS
 698: ST_TO_ADDR
// end ;
 699: GO 665
 701: POP
 702: POP
// p := 1 ;
 703: LD_ADDR_VAR 0 2
 707: PUSH
 708: LD_INT 1
 710: ST_TO_ADDR
// if filter < 16 then
 711: LD_VAR 0 7
 715: PUSH
 716: LD_INT 16
 718: LESS
 719: IFFALSE 808
// for i = filter to 16 do
 721: LD_ADDR_VAR 0 3
 725: PUSH
 726: DOUBLE
 727: LD_VAR 0 7
 731: DEC
 732: ST_TO_ADDR
 733: LD_INT 16
 735: PUSH
 736: FOR_TO
 737: IFFALSE 806
// begin if p > 7 then
 739: LD_VAR 0 2
 743: PUSH
 744: LD_INT 7
 746: GREATER
 747: IFFALSE 751
// break ;
 749: GO 806
// un := CreateCharacter ( ot & p & _07 ) ;
 751: LD_ADDR_VAR 0 4
 755: PUSH
 756: LD_STRING ot
 758: PUSH
 759: LD_VAR 0 2
 763: STR
 764: PUSH
 765: LD_STRING _07
 767: STR
 768: PPUSH
 769: CALL_OW 34
 773: ST_TO_ADDR
// others := others ^ un ;
 774: LD_ADDR_VAR 0 9
 778: PUSH
 779: LD_VAR 0 9
 783: PUSH
 784: LD_VAR 0 4
 788: ADD
 789: ST_TO_ADDR
// p := p + 1 ;
 790: LD_ADDR_VAR 0 2
 794: PUSH
 795: LD_VAR 0 2
 799: PUSH
 800: LD_INT 1
 802: PLUS
 803: ST_TO_ADDR
// end ;
 804: GO 736
 806: POP
 807: POP
// for i = 1 to names2 do
 808: LD_ADDR_VAR 0 3
 812: PUSH
 813: DOUBLE
 814: LD_INT 1
 816: DEC
 817: ST_TO_ADDR
 818: LD_VAR 0 6
 822: PUSH
 823: FOR_TO
 824: IFFALSE 865
// begin un := CreateCharacter ( names2 [ i ] ) ;
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: LD_VAR 0 6
 835: PUSH
 836: LD_VAR 0 3
 840: ARRAY
 841: PPUSH
 842: CALL_OW 34
 846: ST_TO_ADDR
// others := others ^ un ;
 847: LD_ADDR_VAR 0 9
 851: PUSH
 852: LD_VAR 0 9
 856: PUSH
 857: LD_VAR 0 4
 861: ADD
 862: ST_TO_ADDR
// end ;
 863: GO 823
 865: POP
 866: POP
// ftp := main_filter ^ others ;
 867: LD_ADDR_VAR 0 11
 871: PUSH
 872: LD_VAR 0 8
 876: PUSH
 877: LD_VAR 0 9
 881: ADD
 882: ST_TO_ADDR
// for i = 1 to ftp do
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: DOUBLE
 889: LD_INT 1
 891: DEC
 892: ST_TO_ADDR
 893: LD_VAR 0 11
 897: PUSH
 898: FOR_TO
 899: IFFALSE 942
// if GetClass ( ftp [ i ] ) > 4 then
 901: LD_VAR 0 11
 905: PUSH
 906: LD_VAR 0 3
 910: ARRAY
 911: PPUSH
 912: CALL_OW 257
 916: PUSH
 917: LD_INT 4
 919: GREATER
 920: IFFALSE 940
// SetClass ( ftp [ i ] , 1 ) ;
 922: LD_VAR 0 11
 926: PUSH
 927: LD_VAR 0 3
 931: ARRAY
 932: PPUSH
 933: LD_INT 1
 935: PPUSH
 936: CALL_OW 336
 940: GO 898
 942: POP
 943: POP
// team := CharacterSelection ( text , 11 , 11 , [ sel_change_class , Louis , sel_changeable , sel_not_hired ] ^ ftp , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 2 ] ] ) ;
 944: LD_ADDR_VAR 0 10
 948: PUSH
 949: LD_STRING text
 951: PPUSH
 952: LD_INT 11
 954: PPUSH
 955: LD_INT 11
 957: PPUSH
 958: LD_INT -5
 960: PUSH
 961: LD_EXP 4
 965: PUSH
 966: LD_INT -3
 968: PUSH
 969: LD_INT -2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_VAR 0 11
 982: ADD
 983: PPUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 3
 989: PUSH
 990: LD_INT 2
 992: PUSH
 993: LD_INT 1
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 4
1002: PUSH
1003: LD_INT 2
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL_OW 42
1020: ST_TO_ADDR
// for i = 1 to team do
1021: LD_ADDR_VAR 0 3
1025: PUSH
1026: DOUBLE
1027: LD_INT 1
1029: DEC
1030: ST_TO_ADDR
1031: LD_VAR 0 10
1035: PUSH
1036: FOR_TO
1037: IFFALSE 1062
// begin PlaceUnitArea ( team [ i ] , ar_north_base , false ) ;
1039: LD_VAR 0 10
1043: PUSH
1044: LD_VAR 0 3
1048: ARRAY
1049: PPUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 0
1055: PPUSH
1056: CALL_OW 49
// end ;
1060: GO 1036
1062: POP
1063: POP
// vc_chassis := ar_half_tracked ;
1064: LD_ADDR_OWVAR 37
1068: PUSH
1069: LD_INT 14
1071: ST_TO_ADDR
// vc_engine := engine_combustion ;
1072: LD_ADDR_OWVAR 39
1076: PUSH
1077: LD_INT 1
1079: ST_TO_ADDR
// vc_control := control_manual ;
1080: LD_ADDR_OWVAR 38
1084: PUSH
1085: LD_INT 1
1087: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
1088: LD_ADDR_OWVAR 40
1092: PUSH
1093: LD_INT 25
1095: ST_TO_ADDR
// veh := CreateVehicle ;
1096: LD_ADDR_VAR 0 13
1100: PUSH
1101: CALL_OW 45
1105: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
1106: LD_VAR 0 13
1110: PPUSH
1111: LD_INT 5
1113: PPUSH
1114: CALL_OW 233
// PlaceUnitXY ( veh , 70 , 60 , false ) ;
1118: LD_VAR 0 13
1122: PPUSH
1123: LD_INT 70
1125: PPUSH
1126: LD_INT 60
1128: PPUSH
1129: LD_INT 0
1131: PPUSH
1132: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
1136: LD_EXP 4
1140: PPUSH
1141: LD_VAR 0 13
1145: PPUSH
1146: CALL_OW 52
// ComMoveXY ( Louis , 50 , 29 ) ;
1150: LD_EXP 4
1154: PPUSH
1155: LD_INT 50
1157: PPUSH
1158: LD_INT 29
1160: PPUSH
1161: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
1165: LD_EXP 4
1169: PPUSH
1170: CALL_OW 181
// end ;
1174: LD_VAR 0 1
1178: RET
// export function PrepareBase ; var i , veh ; begin
1179: LD_INT 0
1181: PPUSH
1182: PPUSH
1183: PPUSH
// for i = 1 to [ 4 , 3 , 2 ] [ Difficulty ] do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: DOUBLE
1190: LD_INT 1
1192: DEC
1193: ST_TO_ADDR
1194: LD_INT 4
1196: PUSH
1197: LD_INT 3
1199: PUSH
1200: LD_INT 2
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: PUSH
1208: LD_OWVAR 67
1212: ARRAY
1213: PUSH
1214: FOR_TO
1215: IFFALSE 1370
// begin vc_chassis := ar_medium_trike ;
1217: LD_ADDR_OWVAR 37
1221: PUSH
1222: LD_INT 13
1224: ST_TO_ADDR
// vc_engine := engine_solar ;
1225: LD_ADDR_OWVAR 39
1229: PUSH
1230: LD_INT 2
1232: ST_TO_ADDR
// vc_control := control_manual ;
1233: LD_ADDR_OWVAR 38
1237: PUSH
1238: LD_INT 1
1240: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1241: LD_ADDR_OWVAR 40
1245: PUSH
1246: LD_INT 32
1248: ST_TO_ADDR
// veh := CreateVehicle ;
1249: LD_ADDR_VAR 0 3
1253: PUSH
1254: CALL_OW 45
1258: ST_TO_ADDR
// SetDir ( veh , Rand ( 0 , 5 ) ) ;
1259: LD_VAR 0 3
1263: PPUSH
1264: LD_INT 0
1266: PPUSH
1267: LD_INT 5
1269: PPUSH
1270: CALL_OW 12
1274: PPUSH
1275: CALL_OW 233
// PlaceUnitArea ( veh , north_parking , false ) ;
1279: LD_VAR 0 3
1283: PPUSH
1284: LD_INT 10
1286: PPUSH
1287: LD_INT 0
1289: PPUSH
1290: CALL_OW 49
// SetCargo ( veh , [ mat_cans , mat_oil ] [ i mod 2 + 1 ] , [ 30 , 50 , 70 ] [ Rand ( 1 , 3 ) ] ) ;
1294: LD_VAR 0 3
1298: PPUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 2
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: PUSH
1309: LD_VAR 0 2
1313: PUSH
1314: LD_INT 2
1316: MOD
1317: PUSH
1318: LD_INT 1
1320: PLUS
1321: ARRAY
1322: PPUSH
1323: LD_INT 30
1325: PUSH
1326: LD_INT 50
1328: PUSH
1329: LD_INT 70
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: PUSH
1337: LD_INT 1
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: CALL_OW 12
1347: ARRAY
1348: PPUSH
1349: CALL_OW 290
// AddCargo ( veh , 3 , 30 ) ;
1353: LD_VAR 0 3
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: LD_INT 30
1363: PPUSH
1364: CALL_OW 291
// end ;
1368: GO 1214
1370: POP
1371: POP
// end ;
1372: LD_VAR 0 1
1376: RET
// export Kunt ; export function PrepareDoc ; begin
1377: LD_INT 0
1379: PPUSH
// uc_side := 6 ;
1380: LD_ADDR_OWVAR 20
1384: PUSH
1385: LD_INT 6
1387: ST_TO_ADDR
// uc_nation := 2 ;
1388: LD_ADDR_OWVAR 21
1392: PUSH
1393: LD_INT 2
1395: ST_TO_ADDR
// hc_name := Jan Kunt ;
1396: LD_ADDR_OWVAR 26
1400: PUSH
1401: LD_STRING Jan Kunt
1403: ST_TO_ADDR
// hc_gallery := sandar ;
1404: LD_ADDR_OWVAR 33
1408: PUSH
1409: LD_STRING sandar
1411: ST_TO_ADDR
// hc_face_number := 30 ;
1412: LD_ADDR_OWVAR 34
1416: PUSH
1417: LD_INT 30
1419: ST_TO_ADDR
// hc_sex := sex_male ;
1420: LD_ADDR_OWVAR 27
1424: PUSH
1425: LD_INT 1
1427: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 8 ] ;
1428: LD_ADDR_OWVAR 31
1432: PUSH
1433: LD_INT 3
1435: PUSH
1436: LD_INT 4
1438: PUSH
1439: LD_INT 2
1441: PUSH
1442: LD_INT 8
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1451: LD_ADDR_OWVAR 29
1455: PUSH
1456: LD_INT 10
1458: PUSH
1459: LD_INT 10
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: ST_TO_ADDR
// hc_class := 4 ;
1466: LD_ADDR_OWVAR 28
1470: PUSH
1471: LD_INT 4
1473: ST_TO_ADDR
// Kunt := CreateHuman ;
1474: LD_ADDR_EXP 22
1478: PUSH
1479: CALL_OW 44
1483: ST_TO_ADDR
// PlaceUnitXY ( Kunt , 136 , 131 , false ) ;
1484: LD_EXP 22
1488: PPUSH
1489: LD_INT 136
1491: PPUSH
1492: LD_INT 131
1494: PPUSH
1495: LD_INT 0
1497: PPUSH
1498: CALL_OW 48
// ComMoveXY ( Kunt , 48 , 28 ) ;
1502: LD_EXP 22
1506: PPUSH
1507: LD_INT 48
1509: PPUSH
1510: LD_INT 28
1512: PPUSH
1513: CALL_OW 111
// end ; end_of_file
1517: LD_VAR 0 1
1521: RET
// export Sheik , Shariff , Gensher , Omar , Kurt ; export function PrepareMainCharacters ; begin
1522: LD_INT 0
1524: PPUSH
// uc_side := 5 ;
1525: LD_ADDR_OWVAR 20
1529: PUSH
1530: LD_INT 5
1532: ST_TO_ADDR
// uc_nation := nation_arabian ;
1533: LD_ADDR_OWVAR 21
1537: PUSH
1538: LD_INT 2
1540: ST_TO_ADDR
// Shariff := NewCharacter ( Abdul ) ;
1541: LD_ADDR_EXP 24
1545: PUSH
1546: LD_STRING Abdul
1548: PPUSH
1549: CALL_OW 25
1553: ST_TO_ADDR
// SetClass ( Shariff , class_desert_warior ) ;
1554: LD_EXP 24
1558: PPUSH
1559: LD_INT 11
1561: PPUSH
1562: CALL_OW 336
// Gensher := CreateCharacter ( Dietrich ) ;
1566: LD_ADDR_EXP 25
1570: PUSH
1571: LD_STRING Dietrich
1573: PPUSH
1574: CALL_OW 34
1578: ST_TO_ADDR
// Omar := CreateCharacter ( Omar ) ;
1579: LD_ADDR_EXP 26
1583: PUSH
1584: LD_STRING Omar
1586: PPUSH
1587: CALL_OW 34
1591: ST_TO_ADDR
// uc_side := 8 ;
1592: LD_ADDR_OWVAR 20
1596: PUSH
1597: LD_INT 8
1599: ST_TO_ADDR
// hc_class = 1 ;
1600: LD_ADDR_OWVAR 28
1604: PUSH
1605: LD_INT 1
1607: ST_TO_ADDR
// hc_name = Kurt Schmidt ;
1608: LD_ADDR_OWVAR 26
1612: PUSH
1613: LD_STRING Kurt Schmidt
1615: ST_TO_ADDR
// hc_gallery = us ;
1616: LD_ADDR_OWVAR 33
1620: PUSH
1621: LD_STRING us
1623: ST_TO_ADDR
// hc_face_number = 18 ;
1624: LD_ADDR_OWVAR 34
1628: PUSH
1629: LD_INT 18
1631: ST_TO_ADDR
// hc_basic_skills := [ 2 , 0 , 1 , 1 ] ;
1632: LD_ADDR_OWVAR 30
1636: PUSH
1637: LD_INT 2
1639: PUSH
1640: LD_INT 0
1642: PUSH
1643: LD_INT 1
1645: PUSH
1646: LD_INT 1
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: ST_TO_ADDR
// hc_skills = [ 7 , 4 , 3 , 1 ] ;
1655: LD_ADDR_OWVAR 31
1659: PUSH
1660: LD_INT 7
1662: PUSH
1663: LD_INT 4
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 1
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: ST_TO_ADDR
// hc_sex = sex_male ;
1678: LD_ADDR_OWVAR 27
1682: PUSH
1683: LD_INT 1
1685: ST_TO_ADDR
// hc_attr = [ 9 , 10 ] ;
1686: LD_ADDR_OWVAR 29
1690: PUSH
1691: LD_INT 9
1693: PUSH
1694: LD_INT 10
1696: PUSH
1697: EMPTY
1698: LIST
1699: LIST
1700: ST_TO_ADDR
// Kurt = CreateHuman ;
1701: LD_ADDR_EXP 27
1705: PUSH
1706: CALL_OW 44
1710: ST_TO_ADDR
// end ; end_of_file
1711: LD_VAR 0 1
1715: RET
// export function PrepareSouthBase ; var i , p , un , skill ; begin
1716: LD_INT 0
1718: PPUSH
1719: PPUSH
1720: PPUSH
1721: PPUSH
1722: PPUSH
// uc_side := 5 ;
1723: LD_ADDR_OWVAR 20
1727: PUSH
1728: LD_INT 5
1730: ST_TO_ADDR
// uc_nation := 2 ;
1731: LD_ADDR_OWVAR 21
1735: PUSH
1736: LD_INT 2
1738: ST_TO_ADDR
// SetBName ( ar_depot , tunis ) ;
1739: LD_INT 2
1741: PPUSH
1742: LD_STRING tunis
1744: PPUSH
1745: CALL_OW 500
// SetBName ( ar2_depot , rabat ) ;
1749: LD_INT 5
1751: PPUSH
1752: LD_STRING rabat
1754: PPUSH
1755: CALL_OW 500
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
1759: LD_ADDR_VAR 0 5
1763: PUSH
1764: LD_INT 6
1766: PUSH
1767: LD_INT 7
1769: PUSH
1770: LD_INT 8
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: LIST
1777: PUSH
1778: LD_OWVAR 67
1782: ARRAY
1783: ST_TO_ADDR
// SetResourceType ( GetBase ( ar2_depot ) , mat_cans , 3000 ) ;
1784: LD_INT 5
1786: PPUSH
1787: CALL_OW 274
1791: PPUSH
1792: LD_INT 1
1794: PPUSH
1795: LD_INT 3000
1797: PPUSH
1798: CALL_OW 277
// SetResourceType ( GetBase ( ar2_depot ) , mat_oil , 100 ) ;
1802: LD_INT 5
1804: PPUSH
1805: CALL_OW 274
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 100
1815: PPUSH
1816: CALL_OW 277
// for i = 1 to 7 do
1820: LD_ADDR_VAR 0 2
1824: PUSH
1825: DOUBLE
1826: LD_INT 1
1828: DEC
1829: ST_TO_ADDR
1830: LD_INT 7
1832: PUSH
1833: FOR_TO
1834: IFFALSE 1912
// begin PrepareHuman ( false , 1 , skill ) ;
1836: LD_INT 0
1838: PPUSH
1839: LD_INT 1
1841: PPUSH
1842: LD_VAR 0 5
1846: PPUSH
1847: CALL_OW 380
// un := CreateHuman ;
1851: LD_ADDR_VAR 0 4
1855: PUSH
1856: CALL_OW 44
1860: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 5 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
1861: LD_VAR 0 4
1865: PPUSH
1866: LD_INT 22
1868: PUSH
1869: LD_INT 5
1871: PUSH
1872: EMPTY
1873: LIST
1874: LIST
1875: PUSH
1876: LD_INT 58
1878: PUSH
1879: EMPTY
1880: LIST
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 32
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: LIST
1896: PPUSH
1897: CALL_OW 69
1901: PUSH
1902: LD_INT 1
1904: ARRAY
1905: PPUSH
1906: CALL_OW 52
// end ;
1910: GO 1833
1912: POP
1913: POP
// for i = 1 to 3 do
1914: LD_ADDR_VAR 0 2
1918: PUSH
1919: DOUBLE
1920: LD_INT 1
1922: DEC
1923: ST_TO_ADDR
1924: LD_INT 3
1926: PUSH
1927: FOR_TO
1928: IFFALSE 1969
// begin PrepareHuman ( false , 4 , skill ) ;
1930: LD_INT 0
1932: PPUSH
1933: LD_INT 4
1935: PPUSH
1936: LD_VAR 0 5
1940: PPUSH
1941: CALL_OW 380
// un := CreateHuman ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: CALL_OW 44
1954: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_lab ) ;
1955: LD_VAR 0 4
1959: PPUSH
1960: LD_INT 8
1962: PPUSH
1963: CALL_OW 52
// end ;
1967: GO 1927
1969: POP
1970: POP
// for i = 1 to Difficulty + 1 do
1971: LD_ADDR_VAR 0 2
1975: PUSH
1976: DOUBLE
1977: LD_INT 1
1979: DEC
1980: ST_TO_ADDR
1981: LD_OWVAR 67
1985: PUSH
1986: LD_INT 1
1988: PLUS
1989: PUSH
1990: FOR_TO
1991: IFFALSE 2084
// begin PrepareHuman ( false , class_mortar , skill ) ;
1993: LD_INT 0
1995: PPUSH
1996: LD_INT 8
1998: PPUSH
1999: LD_VAR 0 5
2003: PPUSH
2004: CALL_OW 380
// for p = 1 to 2 do
2008: LD_ADDR_VAR 0 3
2012: PUSH
2013: DOUBLE
2014: LD_INT 1
2016: DEC
2017: ST_TO_ADDR
2018: LD_INT 2
2020: PUSH
2021: FOR_TO
2022: IFFALSE 2080
// begin un := CreateHuman ;
2024: LD_ADDR_VAR 0 4
2028: PUSH
2029: CALL_OW 44
2033: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
2034: LD_VAR 0 4
2038: PPUSH
2039: LD_INT 22
2041: PUSH
2042: LD_INT 5
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: PUSH
2049: LD_INT 30
2051: PUSH
2052: LD_INT 5
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: PPUSH
2063: CALL_OW 69
2067: PUSH
2068: LD_VAR 0 3
2072: ARRAY
2073: PPUSH
2074: CALL_OW 52
// end ;
2078: GO 2021
2080: POP
2081: POP
// end ;
2082: GO 1990
2084: POP
2085: POP
// for i = 1 to 6 do
2086: LD_ADDR_VAR 0 2
2090: PUSH
2091: DOUBLE
2092: LD_INT 1
2094: DEC
2095: ST_TO_ADDR
2096: LD_INT 6
2098: PUSH
2099: FOR_TO
2100: IFFALSE 2141
// begin PrepareHuman ( false , 3 , skill ) ;
2102: LD_INT 0
2104: PPUSH
2105: LD_INT 3
2107: PPUSH
2108: LD_VAR 0 5
2112: PPUSH
2113: CALL_OW 380
// un := CreateHuman ;
2117: LD_ADDR_VAR 0 4
2121: PUSH
2122: CALL_OW 44
2126: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_fac ) ;
2127: LD_VAR 0 4
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 52
// end ;
2139: GO 2099
2141: POP
2142: POP
// for i = 1 to 4 do
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: DOUBLE
2149: LD_INT 1
2151: DEC
2152: ST_TO_ADDR
2153: LD_INT 4
2155: PUSH
2156: FOR_TO
2157: IFFALSE 2198
// begin PrepareHuman ( false , 2 , skill ) ;
2159: LD_INT 0
2161: PPUSH
2162: LD_INT 2
2164: PPUSH
2165: LD_VAR 0 5
2169: PPUSH
2170: CALL_OW 380
// un := CreateHuman ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: CALL_OW 44
2183: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar2_depot ) ;
2184: LD_VAR 0 4
2188: PPUSH
2189: LD_INT 5
2191: PPUSH
2192: CALL_OW 52
// end ;
2196: GO 2156
2198: POP
2199: POP
// SetBunkers ( 2 ) ;
2200: LD_INT 2
2202: PPUSH
2203: CALL 2297 0 1
// for i = 1 to 7 do
2207: LD_ADDR_VAR 0 2
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_INT 7
2219: PUSH
2220: FOR_TO
2221: IFFALSE 2290
// AddComPlaceWeapon ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_bunker ] ] ) [ i ] , [ ar_rocket_launcher , ar_gun , ar_gatling_gun ] [ Rand ( 1 , 3 ) ] ) ;
2223: LD_INT 22
2225: PUSH
2226: LD_INT 5
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PUSH
2233: LD_INT 30
2235: PUSH
2236: LD_INT 32
2238: PUSH
2239: EMPTY
2240: LIST
2241: LIST
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PPUSH
2247: CALL_OW 69
2251: PUSH
2252: LD_VAR 0 2
2256: ARRAY
2257: PPUSH
2258: LD_INT 28
2260: PUSH
2261: LD_INT 27
2263: PUSH
2264: LD_INT 25
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 1
2274: PPUSH
2275: LD_INT 3
2277: PPUSH
2278: CALL_OW 12
2282: ARRAY
2283: PPUSH
2284: CALL_OW 208
2288: GO 2220
2290: POP
2291: POP
// end ;
2292: LD_VAR 0 1
2296: RET
// export ar_bunkers_list ; export function SetBunkers ( n ) ; var i , b , un , xyd , p ; begin
2297: LD_INT 0
2299: PPUSH
2300: PPUSH
2301: PPUSH
2302: PPUSH
2303: PPUSH
2304: PPUSH
// uc_side := 5 ;
2305: LD_ADDR_OWVAR 20
2309: PUSH
2310: LD_INT 5
2312: ST_TO_ADDR
// bc_type := b_breastwork ;
2313: LD_ADDR_OWVAR 42
2317: PUSH
2318: LD_INT 31
2320: ST_TO_ADDR
// bc_level := 5 ;
2321: LD_ADDR_OWVAR 43
2325: PUSH
2326: LD_INT 5
2328: ST_TO_ADDR
// ar_bunkers_list := [ ] ;
2329: LD_ADDR_EXP 28
2333: PUSH
2334: EMPTY
2335: ST_TO_ADDR
// xyd := [ 178 , 133 , 3 , 148 , 104 , 3 ] ;
2336: LD_ADDR_VAR 0 6
2340: PUSH
2341: LD_INT 178
2343: PUSH
2344: LD_INT 133
2346: PUSH
2347: LD_INT 3
2349: PUSH
2350: LD_INT 148
2352: PUSH
2353: LD_INT 104
2355: PUSH
2356: LD_INT 3
2358: PUSH
2359: EMPTY
2360: LIST
2361: LIST
2362: LIST
2363: LIST
2364: LIST
2365: LIST
2366: ST_TO_ADDR
// p := 1 ;
2367: LD_ADDR_VAR 0 7
2371: PUSH
2372: LD_INT 1
2374: ST_TO_ADDR
// for i = 1 to n do
2375: LD_ADDR_VAR 0 3
2379: PUSH
2380: DOUBLE
2381: LD_INT 1
2383: DEC
2384: ST_TO_ADDR
2385: LD_VAR 0 1
2389: PUSH
2390: FOR_TO
2391: IFFALSE 2476
// begin b := CreateAndPlaceBuildingXYD ( xyd [ p ] , xyd [ p + 1 ] , xyd [ p + 2 ] ) ;
2393: LD_ADDR_VAR 0 4
2397: PUSH
2398: LD_VAR 0 6
2402: PUSH
2403: LD_VAR 0 7
2407: ARRAY
2408: PPUSH
2409: LD_VAR 0 6
2413: PUSH
2414: LD_VAR 0 7
2418: PUSH
2419: LD_INT 1
2421: PLUS
2422: ARRAY
2423: PPUSH
2424: LD_VAR 0 6
2428: PUSH
2429: LD_VAR 0 7
2433: PUSH
2434: LD_INT 2
2436: PLUS
2437: ARRAY
2438: PPUSH
2439: CALL_OW 47
2443: ST_TO_ADDR
// ar_bunkers_list := ar_bunkers_list ^ b ;
2444: LD_ADDR_EXP 28
2448: PUSH
2449: LD_EXP 28
2453: PUSH
2454: LD_VAR 0 4
2458: ADD
2459: ST_TO_ADDR
// p := p + 3 ;
2460: LD_ADDR_VAR 0 7
2464: PUSH
2465: LD_VAR 0 7
2469: PUSH
2470: LD_INT 3
2472: PLUS
2473: ST_TO_ADDR
// end ;
2474: GO 2390
2476: POP
2477: POP
// end ;
2478: LD_VAR 0 2
2482: RET
// export ar_veh_list , control_towers , ar_vehs , ar_tasks ; every 1 do
2483: GO 2485
2485: DISABLE
// begin ar_veh_list := [ ] ;
2486: LD_ADDR_EXP 29
2490: PUSH
2491: EMPTY
2492: ST_TO_ADDR
// control_towers := [ ] ;
2493: LD_ADDR_EXP 30
2497: PUSH
2498: EMPTY
2499: ST_TO_ADDR
// ar_vehs := [ ] ;
2500: LD_ADDR_EXP 31
2504: PUSH
2505: EMPTY
2506: ST_TO_ADDR
// ar_tasks := back ;
2507: LD_ADDR_EXP 32
2511: PUSH
2512: LD_STRING back
2514: ST_TO_ADDR
// end ;
2515: END
// every 0 0$03 trigger FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_factory ] ] ) do var i , un , fac ;
2516: LD_INT 22
2518: PUSH
2519: LD_INT 5
2521: PUSH
2522: EMPTY
2523: LIST
2524: LIST
2525: PUSH
2526: LD_INT 30
2528: PUSH
2529: LD_INT 3
2531: PUSH
2532: EMPTY
2533: LIST
2534: LIST
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: PPUSH
2540: CALL_OW 69
2544: IFFALSE 3016
2546: GO 2548
2548: DISABLE
2549: LD_INT 0
2551: PPUSH
2552: PPUSH
2553: PPUSH
// begin enable ;
2554: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
2555: LD_ADDR_VAR 0 3
2559: PUSH
2560: LD_INT 22
2562: PUSH
2563: LD_INT 5
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PUSH
2570: LD_INT 30
2572: PUSH
2573: LD_INT 3
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PUSH
2580: EMPTY
2581: LIST
2582: LIST
2583: PPUSH
2584: CALL_OW 69
2588: PUSH
2589: LD_INT 1
2591: ARRAY
2592: ST_TO_ADDR
// if ar_veh_list then
2593: LD_EXP 29
2597: IFFALSE 2703
// begin if BuildingStatus ( fac ) = bs_idle and control_towers then
2599: LD_VAR 0 3
2603: PPUSH
2604: CALL_OW 461
2608: PUSH
2609: LD_INT 2
2611: EQUAL
2612: PUSH
2613: LD_EXP 30
2617: AND
2618: IFFALSE 2703
// begin ComConstruct ( fac , ar_veh_list [ 1 ] , ar_veh_list [ 2 ] , ar_veh_list [ 3 ] , ar_veh_list [ 4 ] ) ;
2620: LD_VAR 0 3
2624: PPUSH
2625: LD_EXP 29
2629: PUSH
2630: LD_INT 1
2632: ARRAY
2633: PPUSH
2634: LD_EXP 29
2638: PUSH
2639: LD_INT 2
2641: ARRAY
2642: PPUSH
2643: LD_EXP 29
2647: PUSH
2648: LD_INT 3
2650: ARRAY
2651: PPUSH
2652: LD_EXP 29
2656: PUSH
2657: LD_INT 4
2659: ARRAY
2660: PPUSH
2661: CALL_OW 125
// for i = 1 to 4 do
2665: LD_ADDR_VAR 0 1
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_INT 4
2677: PUSH
2678: FOR_TO
2679: IFFALSE 2701
// ar_veh_list := Delete ( ar_veh_list , 1 ) ;
2681: LD_ADDR_EXP 29
2685: PUSH
2686: LD_EXP 29
2690: PPUSH
2691: LD_INT 1
2693: PPUSH
2694: CALL_OW 3
2698: ST_TO_ADDR
2699: GO 2678
2701: POP
2702: POP
// end ; end ; if GetTech ( tech_remcont , 5 ) = state_researched and FilterAllUnits ( [ [ f_side , 5 ] , [ f_weapon , ar_control_tower ] ] ) < 2 then
2703: LD_INT 15
2705: PPUSH
2706: LD_INT 5
2708: PPUSH
2709: CALL_OW 321
2713: PUSH
2714: LD_INT 2
2716: EQUAL
2717: PUSH
2718: LD_INT 22
2720: PUSH
2721: LD_INT 5
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: LD_INT 34
2730: PUSH
2731: LD_INT 31
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: PUSH
2747: LD_INT 2
2749: LESS
2750: AND
2751: IFFALSE 2789
// begin if BuildingStatus ( fac ) = bs_idle then
2753: LD_VAR 0 3
2757: PPUSH
2758: CALL_OW 461
2762: PUSH
2763: LD_INT 2
2765: EQUAL
2766: IFFALSE 2789
// ComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2768: LD_VAR 0 3
2772: PPUSH
2773: LD_INT 14
2775: PPUSH
2776: LD_INT 2
2778: PPUSH
2779: LD_INT 1
2781: PPUSH
2782: LD_INT 31
2784: PPUSH
2785: CALL_OW 125
// end ; if control_towers then
2789: LD_EXP 30
2793: IFFALSE 2856
// begin for i = 1 to control_towers do
2795: LD_ADDR_VAR 0 1
2799: PUSH
2800: DOUBLE
2801: LD_INT 1
2803: DEC
2804: ST_TO_ADDR
2805: LD_EXP 30
2809: PUSH
2810: FOR_TO
2811: IFFALSE 2854
// if not IsInArea ( control_towers [ i ] , control_parking ) then
2813: LD_EXP 30
2817: PUSH
2818: LD_VAR 0 1
2822: ARRAY
2823: PPUSH
2824: LD_INT 8
2826: PPUSH
2827: CALL_OW 308
2831: NOT
2832: IFFALSE 2852
// ComMoveToArea ( control_towers [ i ] , control_parking ) ;
2834: LD_EXP 30
2838: PUSH
2839: LD_VAR 0 1
2843: ARRAY
2844: PPUSH
2845: LD_INT 8
2847: PPUSH
2848: CALL_OW 113
2852: GO 2810
2854: POP
2855: POP
// end ; if FilterAllUnits ( [ [ f_side , 5 ] , [ f_control , control_remote ] ] ) and FilterAllUnits ( [ [ f_side , 5 ] , [ f_not , [ f_linked ] ] ] ) and control_towers then
2856: LD_INT 22
2858: PUSH
2859: LD_INT 5
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: PUSH
2866: LD_INT 33
2868: PUSH
2869: LD_INT 2
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PPUSH
2880: CALL_OW 69
2884: PUSH
2885: LD_INT 22
2887: PUSH
2888: LD_INT 5
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: LD_INT 61
2900: PUSH
2901: EMPTY
2902: LIST
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PPUSH
2912: CALL_OW 69
2916: AND
2917: PUSH
2918: LD_EXP 30
2922: AND
2923: IFFALSE 3016
// begin for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_control , control_remote ] ] ) do
2925: LD_ADDR_VAR 0 1
2929: PUSH
2930: LD_INT 22
2932: PUSH
2933: LD_INT 5
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_INT 33
2942: PUSH
2943: LD_INT 2
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PUSH
2950: EMPTY
2951: LIST
2952: LIST
2953: PPUSH
2954: CALL_OW 69
2958: PUSH
2959: FOR_IN
2960: IFFALSE 3014
// if UnitFilter ( i , [ f_not , [ f_linked ] ] ) then
2962: LD_VAR 0 1
2966: PPUSH
2967: LD_INT 3
2969: PUSH
2970: LD_INT 61
2972: PUSH
2973: EMPTY
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL_OW 72
2984: IFFALSE 3012
// ComLinkTo ( i , control_towers [ Rand ( 1 , 2 ) ] ) ;
2986: LD_VAR 0 1
2990: PPUSH
2991: LD_EXP 30
2995: PUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 2
3001: PPUSH
3002: CALL_OW 12
3006: ARRAY
3007: PPUSH
3008: CALL_OW 135
3012: GO 2959
3014: POP
3015: POP
// end ; end ;
3016: PPOPN 3
3018: END
// every 0 0$01 trigger ar_vehs and ar_tasks do var i , enemy , enemyA , parking ;
3019: LD_EXP 31
3023: PUSH
3024: LD_EXP 32
3028: AND
3029: IFFALSE 3422
3031: GO 3033
3033: DISABLE
3034: LD_INT 0
3036: PPUSH
3037: PPUSH
3038: PPUSH
3039: PPUSH
// begin enable ;
3040: ENABLE
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
3041: LD_ADDR_VAR 0 2
3045: PUSH
3046: LD_INT 22
3048: PUSH
3049: LD_INT 2
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PPUSH
3056: CALL_OW 69
3060: ST_TO_ADDR
// enemyA := FilterAllUnits ( [ f_side , 1 ] ) ;
3061: LD_ADDR_VAR 0 3
3065: PUSH
3066: LD_INT 22
3068: PUSH
3069: LD_INT 1
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: PPUSH
3076: CALL_OW 69
3080: ST_TO_ADDR
// parking := mobile_defense ;
3081: LD_ADDR_VAR 0 4
3085: PUSH
3086: LD_INT 9
3088: ST_TO_ADDR
// for i = 1 to ar_vehs do
3089: LD_ADDR_VAR 0 1
3093: PUSH
3094: DOUBLE
3095: LD_INT 1
3097: DEC
3098: ST_TO_ADDR
3099: LD_EXP 31
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3420
// begin if not HasTask ( ar_vehs [ i ] ) then
3107: LD_EXP 31
3111: PUSH
3112: LD_VAR 0 1
3116: ARRAY
3117: PPUSH
3118: CALL_OW 314
3122: NOT
3123: IFFALSE 3418
// case ar_tasks of defend :
3125: LD_EXP 32
3129: PUSH
3130: LD_STRING defend
3132: DOUBLE
3133: EQUAL
3134: IFTRUE 3138
3136: GO 3266
3138: POP
// begin if GetDistUnitArea ( ar_vehs [ i ] , parking ) > 6 and not See ( 2 , ar_vehs [ i ] ) then
3139: LD_EXP 31
3143: PUSH
3144: LD_VAR 0 1
3148: ARRAY
3149: PPUSH
3150: LD_VAR 0 4
3154: PPUSH
3155: CALL_OW 299
3159: PUSH
3160: LD_INT 6
3162: GREATER
3163: PUSH
3164: LD_INT 2
3166: PPUSH
3167: LD_EXP 31
3171: PUSH
3172: LD_VAR 0 1
3176: ARRAY
3177: PPUSH
3178: CALL_OW 292
3182: NOT
3183: AND
3184: IFFALSE 3208
// ComMoveToArea ( ar_vehs [ i ] , parking ) else
3186: LD_EXP 31
3190: PUSH
3191: LD_VAR 0 1
3195: ARRAY
3196: PPUSH
3197: LD_VAR 0 4
3201: PPUSH
3202: CALL_OW 113
3206: GO 3264
// if See ( 2 , ar_vehs [ i ] ) then
3208: LD_INT 2
3210: PPUSH
3211: LD_EXP 31
3215: PUSH
3216: LD_VAR 0 1
3220: ARRAY
3221: PPUSH
3222: CALL_OW 292
3226: IFFALSE 3264
// ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemy , ar_vehs [ i ] ) ) ;
3228: LD_EXP 31
3232: PUSH
3233: LD_VAR 0 1
3237: ARRAY
3238: PPUSH
3239: LD_VAR 0 2
3243: PPUSH
3244: LD_EXP 31
3248: PUSH
3249: LD_VAR 0 1
3253: ARRAY
3254: PPUSH
3255: CALL_OW 74
3259: PPUSH
3260: CALL_OW 115
// end ; attack_player :
3264: GO 3418
3266: LD_STRING attack_player
3268: DOUBLE
3269: EQUAL
3270: IFTRUE 3274
3272: GO 3313
3274: POP
// begin ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemy , ar_vehs [ i ] ) ) ;
3275: LD_EXP 31
3279: PUSH
3280: LD_VAR 0 1
3284: ARRAY
3285: PPUSH
3286: LD_VAR 0 2
3290: PPUSH
3291: LD_EXP 31
3295: PUSH
3296: LD_VAR 0 1
3300: ARRAY
3301: PPUSH
3302: CALL_OW 74
3306: PPUSH
3307: CALL_OW 115
// end ; support_player :
3311: GO 3418
3313: LD_STRING support_player
3315: DOUBLE
3316: EQUAL
3317: IFTRUE 3321
3319: GO 3360
3321: POP
// begin ComAttackUnit ( ar_vehs [ i ] , NearestUnitToUnit ( enemyA , ar_vehs [ i ] ) ) ;
3322: LD_EXP 31
3326: PUSH
3327: LD_VAR 0 1
3331: ARRAY
3332: PPUSH
3333: LD_VAR 0 3
3337: PPUSH
3338: LD_EXP 31
3342: PUSH
3343: LD_VAR 0 1
3347: ARRAY
3348: PPUSH
3349: CALL_OW 74
3353: PPUSH
3354: CALL_OW 115
// end ; back :
3358: GO 3418
3360: LD_STRING back
3362: DOUBLE
3363: EQUAL
3364: IFTRUE 3368
3366: GO 3417
3368: POP
// begin if GetDistUnitArea ( ar_vehs [ i ] , parking ) > 6 then
3369: LD_EXP 31
3373: PUSH
3374: LD_VAR 0 1
3378: ARRAY
3379: PPUSH
3380: LD_VAR 0 4
3384: PPUSH
3385: CALL_OW 299
3389: PUSH
3390: LD_INT 6
3392: GREATER
3393: IFFALSE 3415
// ComMoveToArea ( ar_vehs [ i ] , parking ) ;
3395: LD_EXP 31
3399: PUSH
3400: LD_VAR 0 1
3404: ARRAY
3405: PPUSH
3406: LD_VAR 0 4
3410: PPUSH
3411: CALL_OW 113
// end ; end ;
3415: GO 3418
3417: POP
// end ;
3418: GO 3104
3420: POP
3421: POP
// end ;
3422: PPOPN 4
3424: END
// every 5 5$00 do
3425: GO 3427
3427: DISABLE
// begin case Difficulty of 1 :
3428: LD_OWVAR 67
3432: PUSH
3433: LD_INT 1
3435: DOUBLE
3436: EQUAL
3437: IFTRUE 3441
3439: GO 3457
3441: POP
// ar_veh_list := InitVehicle ( 5 ) ; 2 :
3442: LD_ADDR_EXP 29
3446: PUSH
3447: LD_INT 5
3449: PPUSH
3450: CALL 6671 0 1
3454: ST_TO_ADDR
3455: GO 3506
3457: LD_INT 2
3459: DOUBLE
3460: EQUAL
3461: IFTRUE 3465
3463: GO 3481
3465: POP
// ar_veh_list := InitVehicle ( 6 ) ; 3 :
3466: LD_ADDR_EXP 29
3470: PUSH
3471: LD_INT 6
3473: PPUSH
3474: CALL 6671 0 1
3478: ST_TO_ADDR
3479: GO 3506
3481: LD_INT 3
3483: DOUBLE
3484: EQUAL
3485: IFTRUE 3489
3487: GO 3505
3489: POP
// ar_veh_list := InitVehicle ( 8 ) ; end ;
3490: LD_ADDR_EXP 29
3494: PUSH
3495: LD_INT 8
3497: PPUSH
3498: CALL 6671 0 1
3502: ST_TO_ADDR
3503: GO 3506
3505: POP
// end ;
3506: END
// every 0 0$01 do var i , filter , b ;
3507: GO 3509
3509: DISABLE
3510: LD_INT 0
3512: PPUSH
3513: PPUSH
3514: PPUSH
// begin enable ;
3515: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , 2 ] ] ) ;
3516: LD_ADDR_VAR 0 2
3520: PUSH
3521: LD_INT 22
3523: PUSH
3524: LD_INT 5
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: LD_INT 25
3533: PUSH
3534: LD_INT 2
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 69
3549: ST_TO_ADDR
// b := FilterAllUnits ( [ [ [ f_side , 5 ] , [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ] ) ;
3550: LD_ADDR_VAR 0 3
3554: PUSH
3555: LD_INT 22
3557: PUSH
3558: LD_INT 5
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 3
3567: PUSH
3568: LD_INT 24
3570: PUSH
3571: LD_INT 1000
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 21
3584: PUSH
3585: LD_INT 3
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: LIST
3596: PUSH
3597: EMPTY
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// if b then
3605: LD_VAR 0 3
3609: IFFALSE 3721
// for i = 1 to filter do
3611: LD_ADDR_VAR 0 1
3615: PUSH
3616: DOUBLE
3617: LD_INT 1
3619: DEC
3620: ST_TO_ADDR
3621: LD_VAR 0 2
3625: PUSH
3626: FOR_TO
3627: IFFALSE 3719
// begin if IsInUnit ( filter [ i ] ) then
3629: LD_VAR 0 2
3633: PUSH
3634: LD_VAR 0 1
3638: ARRAY
3639: PPUSH
3640: CALL_OW 310
3644: IFFALSE 3663
// ComExitBuilding ( filter [ i ] ) else
3646: LD_VAR 0 2
3650: PUSH
3651: LD_VAR 0 1
3655: ARRAY
3656: PPUSH
3657: CALL_OW 122
3661: GO 3717
// if not HasTask ( filter [ i ] ) then
3663: LD_VAR 0 2
3667: PUSH
3668: LD_VAR 0 1
3672: ARRAY
3673: PPUSH
3674: CALL_OW 314
3678: NOT
3679: IFFALSE 3717
// ComRepairBuilding ( filter [ i ] , NearestUnitToUnit ( b , filter [ i ] ) ) ;
3681: LD_VAR 0 2
3685: PUSH
3686: LD_VAR 0 1
3690: ARRAY
3691: PPUSH
3692: LD_VAR 0 3
3696: PPUSH
3697: LD_VAR 0 2
3701: PUSH
3702: LD_VAR 0 1
3706: ARRAY
3707: PPUSH
3708: CALL_OW 74
3712: PPUSH
3713: CALL_OW 130
// end ;
3717: GO 3626
3719: POP
3720: POP
// if not b then
3721: LD_VAR 0 3
3725: NOT
3726: IFFALSE 3786
// for i = 1 to filter do
3728: LD_ADDR_VAR 0 1
3732: PUSH
3733: DOUBLE
3734: LD_INT 1
3736: DEC
3737: ST_TO_ADDR
3738: LD_VAR 0 2
3742: PUSH
3743: FOR_TO
3744: IFFALSE 3784
// if not HasTask ( filter [ i ] ) then
3746: LD_VAR 0 2
3750: PUSH
3751: LD_VAR 0 1
3755: ARRAY
3756: PPUSH
3757: CALL_OW 314
3761: NOT
3762: IFFALSE 3782
// ComEnterUnit ( filter [ i ] , ar2_depot ) ;
3764: LD_VAR 0 2
3768: PUSH
3769: LD_VAR 0 1
3773: ARRAY
3774: PPUSH
3775: LD_INT 5
3777: PPUSH
3778: CALL_OW 120
3782: GO 3743
3784: POP
3785: POP
// end ;
3786: PPOPN 3
3788: END
// export ar_tech_list ; every 1 do
3789: GO 3791
3791: DISABLE
// ar_tech_list := [ tech_solpow , tech_tech1 , tech_tech2 , tech_soleng , tech_oilpow , tech_oileng , tech_apeagres ] ;
3792: LD_ADDR_EXP 33
3796: PUSH
3797: LD_INT 35
3799: PUSH
3800: LD_INT 48
3802: PUSH
3803: LD_INT 49
3805: PUSH
3806: LD_INT 45
3808: PUSH
3809: LD_INT 46
3811: PUSH
3812: LD_INT 47
3814: PUSH
3815: LD_INT 11
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: ST_TO_ADDR
3827: END
// every 0 0$01 trigger game do var i , side , techs , sci ;
3828: LD_EXP 1
3832: IFFALSE 4084
3834: GO 3836
3836: DISABLE
3837: LD_INT 0
3839: PPUSH
3840: PPUSH
3841: PPUSH
3842: PPUSH
// begin side := 5 ;
3843: LD_ADDR_VAR 0 2
3847: PUSH
3848: LD_INT 5
3850: ST_TO_ADDR
// techs := ar_tech_list ;
3851: LD_ADDR_VAR 0 3
3855: PUSH
3856: LD_EXP 33
3860: ST_TO_ADDR
// repeat begin if CheckTechList ( side , techs ) then
3861: LD_VAR 0 2
3865: PPUSH
3866: LD_VAR 0 3
3870: PPUSH
3871: CALL 6032 0 2
3875: IFFALSE 3891
// ResearchTechList ( side , techs ) ;
3877: LD_VAR 0 2
3881: PPUSH
3882: LD_VAR 0 3
3886: PPUSH
3887: CALL 6107 0 2
// Wait ( 0 0$01 ) ;
3891: LD_INT 35
3893: PPUSH
3894: CALL_OW 67
// end until CheckTechList ( side , techs ) = 0 ;
3898: LD_VAR 0 2
3902: PPUSH
3903: LD_VAR 0 3
3907: PPUSH
3908: CALL 6032 0 2
3912: PUSH
3913: LD_INT 0
3915: EQUAL
3916: IFFALSE 3861
// if not GetLabKinds ( GetLabs ( 5 ) [ 1 ] ) in [ b_lab_weapon , b_lab_opto ] then
3918: LD_INT 5
3920: PPUSH
3921: CALL 5891 0 1
3925: PUSH
3926: LD_INT 1
3928: ARRAY
3929: PPUSH
3930: CALL 5967 0 1
3934: PUSH
3935: LD_INT 10
3937: PUSH
3938: LD_INT 15
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: IN
3945: NOT
3946: IFFALSE 4027
// begin ComBuildLabKind ( GetLabs ( 5 ) [ 1 ] , b_lab_weapon , b_lab_opto ) ;
3948: LD_INT 5
3950: PPUSH
3951: CALL 5891 0 1
3955: PUSH
3956: LD_INT 1
3958: ARRAY
3959: PPUSH
3960: LD_INT 10
3962: PPUSH
3963: LD_INT 15
3965: PPUSH
3966: CALL 6382 0 3
// techs := techs ^ [ tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_flame , tech_explos , tech_opto1 , tech_opto2 , tech_radar , tech_remcont , tech_remcharge ] ;
3970: LD_ADDR_VAR 0 3
3974: PUSH
3975: LD_VAR 0 3
3979: PUSH
3980: LD_INT 51
3982: PUSH
3983: LD_INT 52
3985: PUSH
3986: LD_INT 69
3988: PUSH
3989: LD_INT 39
3991: PUSH
3992: LD_INT 70
3994: PUSH
3995: LD_INT 42
3997: PUSH
3998: LD_INT 60
4000: PUSH
4001: LD_INT 61
4003: PUSH
4004: LD_INT 6
4006: PUSH
4007: LD_INT 15
4009: PUSH
4010: LD_INT 18
4012: PUSH
4013: EMPTY
4014: LIST
4015: LIST
4016: LIST
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: ADD
4026: ST_TO_ADDR
// end ; repeat begin if CheckTechList ( side , techs ) then
4027: LD_VAR 0 2
4031: PPUSH
4032: LD_VAR 0 3
4036: PPUSH
4037: CALL 6032 0 2
4041: IFFALSE 4057
// ResearchTechList ( side , techs ) ;
4043: LD_VAR 0 2
4047: PPUSH
4048: LD_VAR 0 3
4052: PPUSH
4053: CALL 6107 0 2
// Wait ( 0 0$01 ) ;
4057: LD_INT 35
4059: PPUSH
4060: CALL_OW 67
// end until CheckTechList ( side , techs ) = 0 ;
4064: LD_VAR 0 2
4068: PPUSH
4069: LD_VAR 0 3
4073: PPUSH
4074: CALL 6032 0 2
4078: PUSH
4079: LD_INT 0
4081: EQUAL
4082: IFFALSE 4027
// end ;
4084: PPOPN 4
4086: END
// every 0 0$10 do var sci ;
4087: GO 4089
4089: DISABLE
4090: LD_INT 0
4092: PPUSH
// begin enable ;
4093: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , 4 ] ] ) ;
4094: LD_ADDR_VAR 0 1
4098: PUSH
4099: LD_INT 22
4101: PUSH
4102: LD_INT 5
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PUSH
4109: LD_INT 25
4111: PUSH
4112: LD_INT 4
4114: PUSH
4115: EMPTY
4116: LIST
4117: LIST
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 69
4127: ST_TO_ADDR
// if UnitFilter ( sci , [ f_not , [ f_inside ] ] ) then
4128: LD_VAR 0 1
4132: PPUSH
4133: LD_INT 3
4135: PUSH
4136: LD_INT 54
4138: PUSH
4139: EMPTY
4140: LIST
4141: PUSH
4142: EMPTY
4143: LIST
4144: LIST
4145: PPUSH
4146: CALL_OW 72
4150: IFFALSE 4220
// if not HasTask ( UnitFilter ( sci , [ f_not , [ f_inside ] ] ) [ 1 ] ) then
4152: LD_VAR 0 1
4156: PPUSH
4157: LD_INT 3
4159: PUSH
4160: LD_INT 54
4162: PUSH
4163: EMPTY
4164: LIST
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: PPUSH
4170: CALL_OW 72
4174: PUSH
4175: LD_INT 1
4177: ARRAY
4178: PPUSH
4179: CALL_OW 314
4183: NOT
4184: IFFALSE 4220
// ComEnterUnit ( UnitFilter ( sci , [ f_not , [ f_inside ] ] ) [ 1 ] , ar_lab ) ;
4186: LD_VAR 0 1
4190: PPUSH
4191: LD_INT 3
4193: PUSH
4194: LD_INT 54
4196: PUSH
4197: EMPTY
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PPUSH
4204: CALL_OW 72
4208: PUSH
4209: LD_INT 1
4211: ARRAY
4212: PPUSH
4213: LD_INT 8
4215: PPUSH
4216: CALL_OW 120
// end ;
4220: PPOPN 1
4222: END
// every 0 0$01 do var i , tmp , filter , apes ;
4223: GO 4225
4225: DISABLE
4226: LD_INT 0
4228: PPUSH
4229: PPUSH
4230: PPUSH
4231: PPUSH
// begin while ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_warehouse ] ] ) ) do
4232: LD_INT 22
4234: PUSH
4235: LD_INT 5
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 1
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: IFFALSE 4386
// begin filter := FilterAllUnits ( [ [ [ f_side , 5 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] ] ] ] ) ;
4262: LD_ADDR_VAR 0 3
4266: PUSH
4267: LD_INT 22
4269: PUSH
4270: LD_INT 5
4272: PUSH
4273: EMPTY
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 2
4279: PUSH
4280: LD_INT 25
4282: PUSH
4283: LD_INT 12
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 25
4292: PUSH
4293: LD_INT 15
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: LIST
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: EMPTY
4310: LIST
4311: PPUSH
4312: CALL_OW 69
4316: ST_TO_ADDR
// if filter < 6 then
4317: LD_VAR 0 3
4321: PUSH
4322: LD_INT 6
4324: LESS
4325: IFFALSE 4377
// begin apes := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
4327: LD_ADDR_VAR 0 4
4331: PUSH
4332: LD_INT 22
4334: PUSH
4335: LD_INT 0
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: LD_INT 25
4344: PUSH
4345: LD_INT 12
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PPUSH
4356: CALL_OW 69
4360: ST_TO_ADDR
// if apes then
4361: LD_VAR 0 4
4365: IFFALSE 4377
// TameApeman ( 5 , 1 ) ;
4367: LD_INT 5
4369: PPUSH
4370: LD_INT 1
4372: PPUSH
4373: CALL 5386 0 2
// end ; Wait ( 4 4$45 ) ;
4377: LD_INT 9975
4379: PPUSH
4380: CALL_OW 67
// end ;
4384: GO 4232
// end ;
4386: PPOPN 4
4388: END
// every 0 0$01 trigger GetTech ( tech_apeagres , 5 ) = state_researched do var un , tmp , filter , filter2 , i , b ;
4389: LD_INT 11
4391: PPUSH
4392: LD_INT 5
4394: PPUSH
4395: CALL_OW 321
4399: PUSH
4400: LD_INT 2
4402: EQUAL
4403: IFFALSE 4967
4405: GO 4407
4407: DISABLE
4408: LD_INT 0
4410: PPUSH
4411: PPUSH
4412: PPUSH
4413: PPUSH
4414: PPUSH
4415: PPUSH
// begin enable ;
4416: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , class_apeman ] ] ) ;
4417: LD_ADDR_VAR 0 3
4421: PUSH
4422: LD_INT 22
4424: PUSH
4425: LD_INT 5
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 12
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 69
4450: ST_TO_ADDR
// filter2 := FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , class_apeman_soldier ] ] ) ;
4451: LD_ADDR_VAR 0 4
4455: PUSH
4456: LD_INT 22
4458: PUSH
4459: LD_INT 5
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 25
4468: PUSH
4469: LD_INT 15
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PPUSH
4480: CALL_OW 69
4484: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_barracks ] ] ) ;
4485: LD_ADDR_VAR 0 2
4489: PUSH
4490: LD_INT 22
4492: PUSH
4493: LD_INT 5
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PUSH
4500: LD_INT 30
4502: PUSH
4503: LD_INT 5
4505: PUSH
4506: EMPTY
4507: LIST
4508: LIST
4509: PUSH
4510: EMPTY
4511: LIST
4512: LIST
4513: PPUSH
4514: CALL_OW 69
4518: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) ;
4519: LD_ADDR_VAR 0 6
4523: PUSH
4524: LD_INT 22
4526: PUSH
4527: LD_INT 5
4529: PUSH
4530: EMPTY
4531: LIST
4532: LIST
4533: PUSH
4534: LD_INT 30
4536: PUSH
4537: LD_INT 31
4539: PUSH
4540: EMPTY
4541: LIST
4542: LIST
4543: PUSH
4544: LD_INT 58
4546: PUSH
4547: EMPTY
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: PPUSH
4555: CALL_OW 69
4559: ST_TO_ADDR
// if filter then
4560: LD_VAR 0 3
4564: IFFALSE 4721
// for i = 1 to filter do
4566: LD_ADDR_VAR 0 5
4570: PUSH
4571: DOUBLE
4572: LD_INT 1
4574: DEC
4575: ST_TO_ADDR
4576: LD_VAR 0 3
4580: PUSH
4581: FOR_TO
4582: IFFALSE 4719
// begin if not HasTask ( filter [ i ] ) then
4584: LD_VAR 0 3
4588: PUSH
4589: LD_VAR 0 5
4593: ARRAY
4594: PPUSH
4595: CALL_OW 314
4599: NOT
4600: IFFALSE 4685
// begin if BuildingFull ( tmp [ 2 ] ) then
4602: LD_VAR 0 2
4606: PUSH
4607: LD_INT 2
4609: ARRAY
4610: PPUSH
4611: CALL 6529 0 1
4615: IFFALSE 4643
// ComEnterUnit ( filter [ i ] , tmp [ 1 ] ) else
4617: LD_VAR 0 3
4621: PUSH
4622: LD_VAR 0 5
4626: ARRAY
4627: PPUSH
4628: LD_VAR 0 2
4632: PUSH
4633: LD_INT 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 120
4641: GO 4667
// ComEnterUnit ( filter [ i ] , tmp [ 2 ] ) ;
4643: LD_VAR 0 3
4647: PUSH
4648: LD_VAR 0 5
4652: ARRAY
4653: PPUSH
4654: LD_VAR 0 2
4658: PUSH
4659: LD_INT 2
4661: ARRAY
4662: PPUSH
4663: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , class_apeman_soldier ) ;
4667: LD_VAR 0 3
4671: PUSH
4672: LD_VAR 0 5
4676: ARRAY
4677: PPUSH
4678: LD_INT 15
4680: PPUSH
4681: CALL_OW 183
// end ; if IsInUnit ( filter [ i ] ) then
4685: LD_VAR 0 3
4689: PUSH
4690: LD_VAR 0 5
4694: ARRAY
4695: PPUSH
4696: CALL_OW 310
4700: IFFALSE 4717
// ComExitBuilding ( filter [ i ] ) ;
4702: LD_VAR 0 3
4706: PUSH
4707: LD_VAR 0 5
4711: ARRAY
4712: PPUSH
4713: CALL_OW 122
// end ;
4717: GO 4581
4719: POP
4720: POP
// if filter2 then
4721: LD_VAR 0 4
4725: IFFALSE 4967
// for i = 1 to filter2 do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: DOUBLE
4733: LD_INT 1
4735: DEC
4736: ST_TO_ADDR
4737: LD_VAR 0 4
4741: PUSH
4742: FOR_TO
4743: IFFALSE 4965
// begin if b then
4745: LD_VAR 0 6
4749: IFFALSE 4880
// begin if not IsInUnit ( filter2 [ i ] ) in b and i <= b then
4751: LD_VAR 0 4
4755: PUSH
4756: LD_VAR 0 5
4760: ARRAY
4761: PPUSH
4762: CALL_OW 310
4766: PUSH
4767: LD_VAR 0 6
4771: IN
4772: NOT
4773: PUSH
4774: LD_VAR 0 5
4778: PUSH
4779: LD_VAR 0 6
4783: LESSEQUAL
4784: AND
4785: IFFALSE 4802
// ComExitBuilding ( filter2 [ i ] ) ;
4787: LD_VAR 0 4
4791: PUSH
4792: LD_VAR 0 5
4796: ARRAY
4797: PPUSH
4798: CALL_OW 122
// if i <= b then
4802: LD_VAR 0 5
4806: PUSH
4807: LD_VAR 0 6
4811: LESSEQUAL
4812: IFFALSE 4842
// ComEnterUnit ( filter2 [ i ] , b [ i ] ) else
4814: LD_VAR 0 4
4818: PUSH
4819: LD_VAR 0 5
4823: ARRAY
4824: PPUSH
4825: LD_VAR 0 6
4829: PUSH
4830: LD_VAR 0 5
4834: ARRAY
4835: PPUSH
4836: CALL_OW 120
4840: GO 4878
// ComEnterUnit ( filter2 [ i ] , NearestUnitToUnit ( tmp , filter2 [ i ] ) ) ;
4842: LD_VAR 0 4
4846: PUSH
4847: LD_VAR 0 5
4851: ARRAY
4852: PPUSH
4853: LD_VAR 0 2
4857: PPUSH
4858: LD_VAR 0 4
4862: PUSH
4863: LD_VAR 0 5
4867: ARRAY
4868: PPUSH
4869: CALL_OW 74
4873: PPUSH
4874: CALL_OW 120
// end else
4878: GO 4963
// if not IsInUnit ( filter2 [ i ] ) then
4880: LD_VAR 0 4
4884: PUSH
4885: LD_VAR 0 5
4889: ARRAY
4890: PPUSH
4891: CALL_OW 310
4895: NOT
4896: IFFALSE 4963
// if BuildingFull ( tmp [ 2 ] ) then
4898: LD_VAR 0 2
4902: PUSH
4903: LD_INT 2
4905: ARRAY
4906: PPUSH
4907: CALL 6529 0 1
4911: IFFALSE 4939
// ComEnterUnit ( filter2 [ i ] , tmp [ 2 ] ) else
4913: LD_VAR 0 4
4917: PUSH
4918: LD_VAR 0 5
4922: ARRAY
4923: PPUSH
4924: LD_VAR 0 2
4928: PUSH
4929: LD_INT 2
4931: ARRAY
4932: PPUSH
4933: CALL_OW 120
4937: GO 4963
// ComEnterUnit ( filter2 [ i ] , tmp [ 1 ] ) ;
4939: LD_VAR 0 4
4943: PUSH
4944: LD_VAR 0 5
4948: ARRAY
4949: PPUSH
4950: LD_VAR 0 2
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: CALL_OW 120
// end ;
4963: GO 4742
4965: POP
4966: POP
// end ;
4967: PPOPN 6
4969: END
// every 0 0$0.3 trigger mines do var i , un , filter ;
4970: LD_EXP 2
4974: IFFALSE 5107
4976: GO 4978
4978: DISABLE
4979: LD_INT 0
4981: PPUSH
4982: PPUSH
4983: PPUSH
// begin enable ;
4984: ENABLE
// filter := FilterUnitsInArea ( area_mines , [ f_enemy , 5 ] ) ;
4985: LD_ADDR_VAR 0 3
4989: PUSH
4990: LD_INT 7
4992: PPUSH
4993: LD_INT 81
4995: PUSH
4996: LD_INT 5
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PPUSH
5003: CALL_OW 70
5007: ST_TO_ADDR
// for i = 1 to filter do
5008: LD_ADDR_VAR 0 1
5012: PUSH
5013: DOUBLE
5014: LD_INT 1
5016: DEC
5017: ST_TO_ADDR
5018: LD_VAR 0 3
5022: PUSH
5023: FOR_TO
5024: IFFALSE 5105
// if MineAtPos ( GetX ( filter [ i ] ) , GetY ( filter [ i ] ) ) then
5026: LD_VAR 0 3
5030: PUSH
5031: LD_VAR 0 1
5035: ARRAY
5036: PPUSH
5037: CALL_OW 250
5041: PPUSH
5042: LD_VAR 0 3
5046: PUSH
5047: LD_VAR 0 1
5051: ARRAY
5052: PPUSH
5053: CALL_OW 251
5057: PPUSH
5058: CALL_OW 458
5062: IFFALSE 5103
// LaunchMineAtPos ( GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , 5 ) ;
5064: LD_VAR 0 3
5068: PUSH
5069: LD_VAR 0 1
5073: ARRAY
5074: PPUSH
5075: CALL_OW 250
5079: PPUSH
5080: LD_VAR 0 3
5084: PUSH
5085: LD_VAR 0 1
5089: ARRAY
5090: PPUSH
5091: CALL_OW 251
5095: PPUSH
5096: LD_INT 5
5098: PPUSH
5099: CALL_OW 456
5103: GO 5023
5105: POP
5106: POP
// end ; end_of_file
5107: PPOPN 3
5109: END
// export function CreateApemans ( n , area ) ; var un , i ; begin
5110: LD_INT 0
5112: PPUSH
5113: PPUSH
5114: PPUSH
// uc_side := 0 ;
5115: LD_ADDR_OWVAR 20
5119: PUSH
5120: LD_INT 0
5122: ST_TO_ADDR
// uc_nation := 0 ;
5123: LD_ADDR_OWVAR 21
5127: PUSH
5128: LD_INT 0
5130: ST_TO_ADDR
// for i = 1 to n do
5131: LD_ADDR_VAR 0 5
5135: PUSH
5136: DOUBLE
5137: LD_INT 1
5139: DEC
5140: ST_TO_ADDR
5141: LD_VAR 0 1
5145: PUSH
5146: FOR_TO
5147: IFFALSE 5256
// begin hc_gallery :=  ;
5149: LD_ADDR_OWVAR 33
5153: PUSH
5154: LD_STRING 
5156: ST_TO_ADDR
// hc_name :=  ;
5157: LD_ADDR_OWVAR 26
5161: PUSH
5162: LD_STRING 
5164: ST_TO_ADDR
// hc_attr := [ Rand ( 10 , 12 ) , Rand ( 10 , 11 ) ] ;
5165: LD_ADDR_OWVAR 29
5169: PUSH
5170: LD_INT 10
5172: PPUSH
5173: LD_INT 12
5175: PPUSH
5176: CALL_OW 12
5180: PUSH
5181: LD_INT 10
5183: PPUSH
5184: LD_INT 11
5186: PPUSH
5187: CALL_OW 12
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: ST_TO_ADDR
// hc_class := class_apeman ;
5196: LD_ADDR_OWVAR 28
5200: PUSH
5201: LD_INT 12
5203: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
5204: LD_ADDR_OWVAR 31
5208: PUSH
5209: LD_INT 0
5211: PUSH
5212: LD_INT 0
5214: PUSH
5215: LD_INT 0
5217: PUSH
5218: LD_INT 0
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: ST_TO_ADDR
// un := CreateHuman ;
5227: LD_ADDR_VAR 0 4
5231: PUSH
5232: CALL_OW 44
5236: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5237: LD_VAR 0 4
5241: PPUSH
5242: LD_VAR 0 2
5246: PPUSH
5247: LD_INT 0
5249: PPUSH
5250: CALL_OW 49
// end ;
5254: GO 5146
5256: POP
5257: POP
// end ;
5258: LD_VAR 0 3
5262: RET
// export function CreateTigers ( n , area , agres ) ; var i , animal ; begin
5263: LD_INT 0
5265: PPUSH
5266: PPUSH
5267: PPUSH
// uc_side := 0 ;
5268: LD_ADDR_OWVAR 20
5272: PUSH
5273: LD_INT 0
5275: ST_TO_ADDR
// uc_nation := 0 ;
5276: LD_ADDR_OWVAR 21
5280: PUSH
5281: LD_INT 0
5283: ST_TO_ADDR
// for i = 1 to n do
5284: LD_ADDR_VAR 0 5
5288: PUSH
5289: DOUBLE
5290: LD_INT 1
5292: DEC
5293: ST_TO_ADDR
5294: LD_VAR 0 1
5298: PUSH
5299: FOR_TO
5300: IFFALSE 5379
// begin hc_class = class_tiger ;
5302: LD_ADDR_OWVAR 28
5306: PUSH
5307: LD_INT 14
5309: ST_TO_ADDR
// hc_gallery = sandnature ;
5310: LD_ADDR_OWVAR 33
5314: PUSH
5315: LD_STRING sandnature
5317: ST_TO_ADDR
// hc_agressivity = Rand ( agres , agres + 30 ) ;
5318: LD_ADDR_OWVAR 35
5322: PUSH
5323: LD_VAR 0 3
5327: PPUSH
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 30
5335: PLUS
5336: PPUSH
5337: CALL_OW 12
5341: ST_TO_ADDR
// hc_face_number = 3 ;
5342: LD_ADDR_OWVAR 34
5346: PUSH
5347: LD_INT 3
5349: ST_TO_ADDR
// animal := CreateHuman ;
5350: LD_ADDR_VAR 0 6
5354: PUSH
5355: CALL_OW 44
5359: ST_TO_ADDR
// PlaceUnitArea ( animal , area , false ) ;
5360: LD_VAR 0 6
5364: PPUSH
5365: LD_VAR 0 2
5369: PPUSH
5370: LD_INT 0
5372: PPUSH
5373: CALL_OW 49
// end ;
5377: GO 5299
5379: POP
5380: POP
// end ;
5381: LD_VAR 0 4
5385: RET
// export function TameApeman ( side , n ) ; var i , filter , apes , ape , b , x , y ; begin
5386: LD_INT 0
5388: PPUSH
5389: PPUSH
5390: PPUSH
5391: PPUSH
5392: PPUSH
5393: PPUSH
5394: PPUSH
5395: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
5396: LD_ADDR_VAR 0 5
5400: PUSH
5401: LD_INT 22
5403: PUSH
5404: LD_VAR 0 1
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: PUSH
5413: LD_INT 25
5415: PUSH
5416: LD_INT 4
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL_OW 69
5431: ST_TO_ADDR
// apes := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
5432: LD_ADDR_VAR 0 6
5436: PUSH
5437: LD_INT 22
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PUSH
5447: LD_INT 25
5449: PUSH
5450: LD_INT 12
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: CALL_OW 69
5465: ST_TO_ADDR
// if n > apes then
5466: LD_VAR 0 2
5470: PUSH
5471: LD_VAR 0 6
5475: GREATER
5476: IFFALSE 5488
// n = apes ;
5478: LD_ADDR_VAR 0 2
5482: PUSH
5483: LD_VAR 0 6
5487: ST_TO_ADDR
// for i = 1 to n do
5488: LD_ADDR_VAR 0 4
5492: PUSH
5493: DOUBLE
5494: LD_INT 1
5496: DEC
5497: ST_TO_ADDR
5498: LD_VAR 0 2
5502: PUSH
5503: FOR_TO
5504: IFFALSE 5768
// begin if IsInUnit ( filter [ i ] ) then
5506: LD_VAR 0 5
5510: PUSH
5511: LD_VAR 0 4
5515: ARRAY
5516: PPUSH
5517: CALL_OW 310
5521: IFFALSE 5559
// begin b := IsInUnit ( filter [ i ] ) ;
5523: LD_ADDR_VAR 0 8
5527: PUSH
5528: LD_VAR 0 5
5532: PUSH
5533: LD_VAR 0 4
5537: ARRAY
5538: PPUSH
5539: CALL_OW 310
5543: ST_TO_ADDR
// ComExitBuilding ( filter [ i ] ) ;
5544: LD_VAR 0 5
5548: PUSH
5549: LD_VAR 0 4
5553: ARRAY
5554: PPUSH
5555: CALL_OW 122
// end ; Wait ( 0 0$0.3 ) ;
5559: LD_INT 10
5561: PPUSH
5562: CALL_OW 67
// SetRememberedX ( filter [ i ] , GetX ( filter [ i ] ) ) ;
5566: LD_VAR 0 5
5570: PUSH
5571: LD_VAR 0 4
5575: ARRAY
5576: PPUSH
5577: LD_VAR 0 5
5581: PUSH
5582: LD_VAR 0 4
5586: ARRAY
5587: PPUSH
5588: CALL_OW 250
5592: PPUSH
5593: CALL_OW 231
// SetRememberedY ( filter [ i ] , GetY ( filter [ i ] ) ) ;
5597: LD_VAR 0 5
5601: PUSH
5602: LD_VAR 0 4
5606: ARRAY
5607: PPUSH
5608: LD_VAR 0 5
5612: PUSH
5613: LD_VAR 0 4
5617: ARRAY
5618: PPUSH
5619: CALL_OW 251
5623: PPUSH
5624: CALL_OW 232
// ape := NearestUnitToUnit ( apes , filter [ i ] ) ;
5628: LD_ADDR_VAR 0 7
5632: PUSH
5633: LD_VAR 0 6
5637: PPUSH
5638: LD_VAR 0 5
5642: PUSH
5643: LD_VAR 0 4
5647: ARRAY
5648: PPUSH
5649: CALL_OW 74
5653: ST_TO_ADDR
// ComHold ( ape ) ;
5654: LD_VAR 0 7
5658: PPUSH
5659: CALL_OW 140
// ComTameXY ( filter [ i ] , GetX ( ape ) , GetY ( ape ) ) ;
5663: LD_VAR 0 5
5667: PUSH
5668: LD_VAR 0 4
5672: ARRAY
5673: PPUSH
5674: LD_VAR 0 7
5678: PPUSH
5679: CALL_OW 250
5683: PPUSH
5684: LD_VAR 0 7
5688: PPUSH
5689: CALL_OW 251
5693: PPUSH
5694: CALL_OW 131
// repeat Wait ( 0 0$01 ) ;
5698: LD_INT 35
5700: PPUSH
5701: CALL_OW 67
// until not HasTask ( filter [ i ] ) ;
5705: LD_VAR 0 5
5709: PUSH
5710: LD_VAR 0 4
5714: ARRAY
5715: PPUSH
5716: CALL_OW 314
5720: NOT
5721: IFFALSE 5698
// if b then
5723: LD_VAR 0 8
5727: IFFALSE 5751
// AddComEnterUnit ( filter [ i ] , b ) else
5729: LD_VAR 0 5
5733: PUSH
5734: LD_VAR 0 4
5738: ARRAY
5739: PPUSH
5740: LD_VAR 0 8
5744: PPUSH
5745: CALL_OW 180
5749: GO 5766
// AddComReturn ( filter [ i ] ) ;
5751: LD_VAR 0 5
5755: PUSH
5756: LD_VAR 0 4
5760: ARRAY
5761: PPUSH
5762: CALL_OW 204
// end ;
5766: GO 5503
5768: POP
5769: POP
// end ;
5770: LD_VAR 0 3
5774: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5775: LD_INT 0
5777: PPUSH
5778: PPUSH
5779: PPUSH
// pom := GetBase ( bdepot ) ;
5780: LD_ADDR_VAR 0 4
5784: PUSH
5785: LD_VAR 0 1
5789: PPUSH
5790: CALL_OW 274
5794: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5795: LD_ADDR_VAR 0 5
5799: PUSH
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 1
5809: PPUSH
5810: CALL_OW 248
5814: PPUSH
5815: CALL_OW 450
5819: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5820: LD_VAR 0 4
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: CALL_OW 275
5832: PUSH
5833: LD_VAR 0 5
5837: PUSH
5838: LD_INT 1
5840: ARRAY
5841: GREATEREQUAL
5842: PUSH
5843: LD_VAR 0 4
5847: PPUSH
5848: LD_INT 3
5850: PPUSH
5851: CALL_OW 275
5855: PUSH
5856: LD_VAR 0 5
5860: PUSH
5861: LD_INT 3
5863: ARRAY
5864: GREATEREQUAL
5865: AND
5866: IFFALSE 5878
// result := true else
5868: LD_ADDR_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ST_TO_ADDR
5876: GO 5886
// result := false ;
5878: LD_ADDR_VAR 0 3
5882: PUSH
5883: LD_INT 0
5885: ST_TO_ADDR
// end ;
5886: LD_VAR 0 3
5890: RET
// export function GetLabs ( side ) ; begin
5891: LD_INT 0
5893: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
5894: LD_ADDR_VAR 0 2
5898: PUSH
5899: LD_INT 22
5901: PUSH
5902: LD_VAR 0 1
5906: PUSH
5907: EMPTY
5908: LIST
5909: LIST
5910: PUSH
5911: LD_INT 2
5913: PUSH
5914: LD_INT 30
5916: PUSH
5917: LD_INT 6
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: LD_INT 30
5926: PUSH
5927: LD_INT 8
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PUSH
5934: LD_INT 30
5936: PUSH
5937: LD_INT 7
5939: PUSH
5940: EMPTY
5941: LIST
5942: LIST
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: LIST
5948: LIST
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: PUSH
5954: EMPTY
5955: LIST
5956: PPUSH
5957: CALL_OW 69
5961: ST_TO_ADDR
// end ;
5962: LD_VAR 0 2
5966: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
5967: LD_INT 0
5969: PPUSH
5970: PPUSH
5971: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
5972: LD_ADDR_VAR 0 3
5976: PUSH
5977: LD_VAR 0 1
5981: PPUSH
5982: LD_INT 1
5984: PPUSH
5985: CALL_OW 268
5989: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
5990: LD_ADDR_VAR 0 4
5994: PUSH
5995: LD_VAR 0 1
5999: PPUSH
6000: LD_INT 2
6002: PPUSH
6003: CALL_OW 268
6007: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6008: LD_ADDR_VAR 0 2
6012: PUSH
6013: LD_VAR 0 3
6017: PUSH
6018: LD_VAR 0 4
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: ST_TO_ADDR
// end ;
6027: LD_VAR 0 2
6031: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6032: LD_INT 0
6034: PPUSH
6035: PPUSH
// result := false ;
6036: LD_ADDR_VAR 0 3
6040: PUSH
6041: LD_INT 0
6043: ST_TO_ADDR
// for i = 1 to tlist do
6044: LD_ADDR_VAR 0 4
6048: PUSH
6049: DOUBLE
6050: LD_INT 1
6052: DEC
6053: ST_TO_ADDR
6054: LD_VAR 0 2
6058: PUSH
6059: FOR_TO
6060: IFFALSE 6100
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6062: LD_VAR 0 2
6066: PUSH
6067: LD_VAR 0 4
6071: ARRAY
6072: PPUSH
6073: LD_VAR 0 1
6077: PPUSH
6078: CALL_OW 321
6082: PUSH
6083: LD_INT 2
6085: NONEQUAL
6086: IFFALSE 6098
// begin result := true ;
6088: LD_ADDR_VAR 0 3
6092: PUSH
6093: LD_INT 1
6095: ST_TO_ADDR
// break ;
6096: GO 6100
// end ;
6098: GO 6059
6100: POP
6101: POP
// end ;
6102: LD_VAR 0 3
6106: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab ; begin
6107: LD_INT 0
6109: PPUSH
6110: PPUSH
6111: PPUSH
6112: PPUSH
6113: PPUSH
6114: PPUSH
6115: PPUSH
// lab := GetLabs ( side ) ;
6116: LD_ADDR_VAR 0 5
6120: PUSH
6121: LD_VAR 0 1
6125: PPUSH
6126: CALL 5891 0 1
6130: ST_TO_ADDR
// tmp := 0 ;
6131: LD_ADDR_VAR 0 7
6135: PUSH
6136: LD_INT 0
6138: ST_TO_ADDR
// list := [ ] ;
6139: LD_ADDR_VAR 0 8
6143: PUSH
6144: EMPTY
6145: ST_TO_ADDR
// for i = 1 to tlist do
6146: LD_ADDR_VAR 0 4
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_VAR 0 2
6160: PUSH
6161: FOR_TO
6162: IFFALSE 6214
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6164: LD_VAR 0 2
6168: PUSH
6169: LD_VAR 0 4
6173: ARRAY
6174: PPUSH
6175: LD_VAR 0 1
6179: PPUSH
6180: CALL_OW 321
6184: PUSH
6185: LD_INT 2
6187: NONEQUAL
6188: IFFALSE 6212
// list := list ^ tlist [ i ] ;
6190: LD_ADDR_VAR 0 8
6194: PUSH
6195: LD_VAR 0 8
6199: PUSH
6200: LD_VAR 0 2
6204: PUSH
6205: LD_VAR 0 4
6209: ARRAY
6210: ADD
6211: ST_TO_ADDR
6212: GO 6161
6214: POP
6215: POP
// if list then
6216: LD_VAR 0 8
6220: IFFALSE 6369
// begin for i = 1 to lab do
6222: LD_ADDR_VAR 0 4
6226: PUSH
6227: DOUBLE
6228: LD_INT 1
6230: DEC
6231: ST_TO_ADDR
6232: LD_VAR 0 5
6236: PUSH
6237: FOR_TO
6238: IFFALSE 6292
// if GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) then
6240: LD_VAR 0 8
6244: PUSH
6245: LD_INT 1
6247: ARRAY
6248: PPUSH
6249: CALL_OW 481
6253: PUSH
6254: LD_VAR 0 5
6258: PUSH
6259: LD_VAR 0 4
6263: ARRAY
6264: PPUSH
6265: CALL 5967 0 1
6269: IN
6270: IFFALSE 6290
// begin mylab := lab [ i ] ;
6272: LD_ADDR_VAR 0 9
6276: PUSH
6277: LD_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: ARRAY
6287: ST_TO_ADDR
// break ;
6288: GO 6292
// end ;
6290: GO 6237
6292: POP
6293: POP
// if mylab then
6294: LD_VAR 0 9
6298: IFFALSE 6359
// begin if BuildingStatus ( mylab ) = bs_idle then
6300: LD_VAR 0 9
6304: PPUSH
6305: CALL_OW 461
6309: PUSH
6310: LD_INT 2
6312: EQUAL
6313: IFFALSE 6357
// for i = 1 to list do
6315: LD_ADDR_VAR 0 4
6319: PUSH
6320: DOUBLE
6321: LD_INT 1
6323: DEC
6324: ST_TO_ADDR
6325: LD_VAR 0 8
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6355
// AddComResearch ( mylab , list [ i ] ) ;
6333: LD_VAR 0 9
6337: PPUSH
6338: LD_VAR 0 8
6342: PUSH
6343: LD_VAR 0 4
6347: ARRAY
6348: PPUSH
6349: CALL_OW 184
6353: GO 6330
6355: POP
6356: POP
// end else
6357: GO 6367
// result := false ;
6359: LD_ADDR_VAR 0 3
6363: PUSH
6364: LD_INT 0
6366: ST_TO_ADDR
// end else
6367: GO 6377
// result := false ;
6369: LD_ADDR_VAR 0 3
6373: PUSH
6374: LD_INT 0
6376: ST_TO_ADDR
// end ;
6377: LD_VAR 0 3
6381: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
6382: LD_INT 0
6384: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
6385: LD_VAR 0 1
6389: PPUSH
6390: LD_INT 1
6392: PPUSH
6393: CALL_OW 268
6397: PUSH
6398: LD_INT 9
6400: EQUAL
6401: PUSH
6402: LD_VAR 0 1
6406: PPUSH
6407: LD_INT 2
6409: PPUSH
6410: CALL_OW 268
6414: PUSH
6415: LD_INT 9
6417: EQUAL
6418: AND
6419: IFFALSE 6516
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
6421: LD_VAR 0 1
6425: PPUSH
6426: LD_VAR 0 2
6430: PPUSH
6431: CALL 5775 0 2
6435: PUSH
6436: LD_VAR 0 1
6440: PPUSH
6441: LD_VAR 0 3
6445: PPUSH
6446: CALL 5775 0 2
6450: AND
6451: PUSH
6452: LD_VAR 0 1
6456: PPUSH
6457: CALL_OW 461
6461: PUSH
6462: LD_INT 2
6464: EQUAL
6465: AND
6466: IFFALSE 6506
// begin ComUpgradeLab ( lab , bkind1 ) ;
6468: LD_VAR 0 1
6472: PPUSH
6473: LD_VAR 0 2
6477: PPUSH
6478: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
6482: LD_VAR 0 1
6486: PPUSH
6487: LD_VAR 0 3
6491: PPUSH
6492: CALL_OW 207
// result := true ;
6496: LD_ADDR_VAR 0 4
6500: PUSH
6501: LD_INT 1
6503: ST_TO_ADDR
// end else
6504: GO 6514
// result := false ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_INT 0
6513: ST_TO_ADDR
// end else
6514: GO 6524
// result := false ;
6516: LD_ADDR_VAR 0 4
6520: PUSH
6521: LD_INT 0
6523: ST_TO_ADDR
// end ;
6524: LD_VAR 0 4
6528: RET
// export function BuildingFull ( building ) ; begin
6529: LD_INT 0
6531: PPUSH
// if UnitsInside ( building ) = 6 then
6532: LD_VAR 0 1
6536: PPUSH
6537: CALL_OW 313
6541: PUSH
6542: LD_INT 6
6544: EQUAL
6545: IFFALSE 6557
// result := true else
6547: LD_ADDR_VAR 0 2
6551: PUSH
6552: LD_INT 1
6554: ST_TO_ADDR
6555: GO 6565
// result := false ;
6557: LD_ADDR_VAR 0 2
6561: PUSH
6562: LD_INT 0
6564: ST_TO_ADDR
// end ;
6565: LD_VAR 0 2
6569: RET
// export function PrepareMines ( ) ; begin
6570: LD_INT 0
6572: PPUSH
// Randomize ;
6573: CALL_OW 10
// PlaceMinesToArea ( west_mines , Rand ( 39 , 53 ) , 0 , 5 , 0 ) ;
6577: LD_INT 4
6579: PPUSH
6580: LD_INT 39
6582: PPUSH
6583: LD_INT 53
6585: PPUSH
6586: CALL_OW 12
6590: PPUSH
6591: LD_INT 0
6593: PPUSH
6594: LD_INT 5
6596: PPUSH
6597: LD_INT 0
6599: PPUSH
6600: CALL_OW 511
// PlaceMinesToArea ( center_mines , Rand ( 61 , 74 ) , 0 , 5 , 0 ) ;
6604: LD_INT 5
6606: PPUSH
6607: LD_INT 61
6609: PPUSH
6610: LD_INT 74
6612: PPUSH
6613: CALL_OW 12
6617: PPUSH
6618: LD_INT 0
6620: PPUSH
6621: LD_INT 5
6623: PPUSH
6624: LD_INT 0
6626: PPUSH
6627: CALL_OW 511
// PlaceMinesToArea ( east_mines , Rand ( 36 , 59 ) , 0 , 5 , 0 ) ;
6631: LD_INT 6
6633: PPUSH
6634: LD_INT 36
6636: PPUSH
6637: LD_INT 59
6639: PPUSH
6640: CALL_OW 12
6644: PPUSH
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 5
6650: PPUSH
6651: LD_INT 0
6653: PPUSH
6654: CALL_OW 511
// mines := true ;
6658: LD_ADDR_EXP 2
6662: PUSH
6663: LD_INT 1
6665: ST_TO_ADDR
// end ;
6666: LD_VAR 0 1
6670: RET
// export function InitVehicle ( n ) ; var i , list ; begin
6671: LD_INT 0
6673: PPUSH
6674: PPUSH
6675: PPUSH
// list := [ ] ;
6676: LD_ADDR_VAR 0 4
6680: PUSH
6681: EMPTY
6682: ST_TO_ADDR
// for i = 1 to n do
6683: LD_ADDR_VAR 0 3
6687: PUSH
6688: DOUBLE
6689: LD_INT 1
6691: DEC
6692: ST_TO_ADDR
6693: LD_VAR 0 1
6697: PUSH
6698: FOR_TO
6699: IFFALSE 6778
// list := list ^ [ [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_gun , ar_gatling_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ] ;
6701: LD_ADDR_VAR 0 4
6705: PUSH
6706: LD_VAR 0 4
6710: PUSH
6711: LD_INT 13
6713: PUSH
6714: LD_INT 14
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 1
6723: PPUSH
6724: LD_INT 2
6726: PPUSH
6727: CALL_OW 12
6731: ARRAY
6732: PUSH
6733: LD_INT 1
6735: PUSH
6736: LD_INT 2
6738: PUSH
6739: LD_INT 27
6741: PUSH
6742: LD_INT 25
6744: PUSH
6745: LD_INT 28
6747: PUSH
6748: LD_INT 26
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: LD_INT 1
6759: PPUSH
6760: LD_INT 4
6762: PPUSH
6763: CALL_OW 12
6767: ARRAY
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: LIST
6773: LIST
6774: ADD
6775: ST_TO_ADDR
6776: GO 6698
6778: POP
6779: POP
// result := list ;
6780: LD_ADDR_VAR 0 2
6784: PUSH
6785: LD_VAR 0 4
6789: ST_TO_ADDR
// end ;
6790: LD_VAR 0 2
6794: RET
// export function sci ( side , spec ) ; var sci ; begin
6795: LD_INT 0
6797: PPUSH
6798: PPUSH
// sci := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) diff spec ;
6799: LD_ADDR_VAR 0 4
6803: PUSH
6804: LD_INT 22
6806: PUSH
6807: LD_VAR 0 1
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: LD_INT 25
6818: PUSH
6819: LD_INT 4
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: PPUSH
6830: CALL_OW 69
6834: PUSH
6835: LD_VAR 0 2
6839: DIFF
6840: ST_TO_ADDR
// result := sci ;
6841: LD_ADDR_VAR 0 3
6845: PUSH
6846: LD_VAR 0 4
6850: ST_TO_ADDR
// end ;
6851: LD_VAR 0 3
6855: RET
// export function m ( side , spec ) ; var m ; begin
6856: LD_INT 0
6858: PPUSH
6859: PPUSH
// m := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) diff spec ;
6860: LD_ADDR_VAR 0 4
6864: PUSH
6865: LD_INT 22
6867: PUSH
6868: LD_VAR 0 1
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PUSH
6877: LD_INT 25
6879: PUSH
6880: LD_INT 3
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PPUSH
6891: CALL_OW 69
6895: PUSH
6896: LD_VAR 0 2
6900: DIFF
6901: ST_TO_ADDR
// result := m ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 4
6911: ST_TO_ADDR
// end ;
6912: LD_VAR 0 3
6916: RET
// export function GetVehicle ( side , engine ) ; begin
6917: LD_INT 0
6919: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_engine , engine ] ] ) ;
6920: LD_ADDR_VAR 0 3
6924: PUSH
6925: LD_INT 22
6927: PUSH
6928: LD_VAR 0 1
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: LD_INT 32
6939: PUSH
6940: LD_VAR 0 2
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PPUSH
6953: CALL_OW 69
6957: ST_TO_ADDR
// end ;
6958: LD_VAR 0 3
6962: RET
// export function FindLab ( side , kind ) ; var labs , i , j , mode ; begin
6963: LD_INT 0
6965: PPUSH
6966: PPUSH
6967: PPUSH
6968: PPUSH
6969: PPUSH
// mode := false ;
6970: LD_ADDR_VAR 0 7
6974: PUSH
6975: LD_INT 0
6977: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 6 ] , [ f_btype , 7 ] , [ f_btype , 8 ] ] ] ) ;
6978: LD_ADDR_VAR 0 4
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 1
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 2
6997: PUSH
6998: LD_INT 30
7000: PUSH
7001: LD_INT 6
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PUSH
7008: LD_INT 30
7010: PUSH
7011: LD_INT 7
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: PUSH
7018: LD_INT 30
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 69
7042: ST_TO_ADDR
// for i = 1 to labs do
7043: LD_ADDR_VAR 0 5
7047: PUSH
7048: DOUBLE
7049: LD_INT 1
7051: DEC
7052: ST_TO_ADDR
7053: LD_VAR 0 4
7057: PUSH
7058: FOR_TO
7059: IFFALSE 7121
// for j = 1 to 2 do
7061: LD_ADDR_VAR 0 6
7065: PUSH
7066: DOUBLE
7067: LD_INT 1
7069: DEC
7070: ST_TO_ADDR
7071: LD_INT 2
7073: PUSH
7074: FOR_TO
7075: IFFALSE 7117
// if GetLabKind ( labs [ i ] , j ) = kind then
7077: LD_VAR 0 4
7081: PUSH
7082: LD_VAR 0 5
7086: ARRAY
7087: PPUSH
7088: LD_VAR 0 6
7092: PPUSH
7093: CALL_OW 268
7097: PUSH
7098: LD_VAR 0 2
7102: EQUAL
7103: IFFALSE 7115
// begin mode := true ;
7105: LD_ADDR_VAR 0 7
7109: PUSH
7110: LD_INT 1
7112: ST_TO_ADDR
// break ;
7113: GO 7117
// end ;
7115: GO 7074
7117: POP
7118: POP
7119: GO 7058
7121: POP
7122: POP
// result := mode ;
7123: LD_ADDR_VAR 0 3
7127: PUSH
7128: LD_VAR 0 7
7132: ST_TO_ADDR
// end ; end_of_file end_of_file
7133: LD_VAR 0 3
7137: RET
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 5 then
7138: LD_VAR 0 2
7142: PPUSH
7143: CALL_OW 255
7147: PUSH
7148: LD_INT 5
7150: EQUAL
7151: IFFALSE 7217
// if GetWeapon ( veh ) = ar_control_tower then
7153: LD_VAR 0 1
7157: PPUSH
7158: CALL_OW 264
7162: PUSH
7163: LD_INT 31
7165: EQUAL
7166: IFFALSE 7186
// control_towers := control_towers ^ veh else
7168: LD_ADDR_EXP 30
7172: PUSH
7173: LD_EXP 30
7177: PUSH
7178: LD_VAR 0 1
7182: ADD
7183: ST_TO_ADDR
7184: GO 7217
// if GetWeapon ( veh ) <> ar_cargo_bay then
7186: LD_VAR 0 1
7190: PPUSH
7191: CALL_OW 264
7195: PUSH
7196: LD_INT 32
7198: NONEQUAL
7199: IFFALSE 7217
// ar_vehs := ar_vehs ^ veh ;
7201: LD_ADDR_EXP 31
7205: PUSH
7206: LD_EXP 31
7210: PUSH
7211: LD_VAR 0 1
7215: ADD
7216: ST_TO_ADDR
// end ;
7217: PPOPN 2
7219: END
// on ResearchStarted ( tech , lab ) do begin if tech = 3 then
7220: LD_VAR 0 1
7224: PUSH
7225: LD_INT 3
7227: EQUAL
7228: IFFALSE 7238
// ape_brain := true ;
7230: LD_ADDR_EXP 35
7234: PUSH
7235: LD_INT 1
7237: ST_TO_ADDR
// if tech = 4 then
7238: LD_VAR 0 1
7242: PUSH
7243: LD_INT 4
7245: EQUAL
7246: IFFALSE 7256
// ape_neut := true ;
7248: LD_ADDR_EXP 36
7252: PUSH
7253: LD_INT 1
7255: ST_TO_ADDR
// end ; end_of_file
7256: PPOPN 2
7258: END
// export need_bio_lab , ape_brain , ape_neut , gensher_arrive , join_to_legion ; export function Action ; var un , str ; begin
7259: LD_INT 0
7261: PPUSH
7262: PPUSH
7263: PPUSH
// need_bio_lab := false ;
7264: LD_ADDR_EXP 34
7268: PUSH
7269: LD_INT 0
7271: ST_TO_ADDR
// ape_brain := false ;
7272: LD_ADDR_EXP 35
7276: PUSH
7277: LD_INT 0
7279: ST_TO_ADDR
// ape_neut := false ;
7280: LD_ADDR_EXP 36
7284: PUSH
7285: LD_INT 0
7287: ST_TO_ADDR
// gensher_arrive := false ;
7288: LD_ADDR_EXP 37
7292: PUSH
7293: LD_INT 0
7295: ST_TO_ADDR
// join_to_legion := false ;
7296: LD_ADDR_EXP 38
7300: PUSH
7301: LD_INT 0
7303: ST_TO_ADDR
// InGameOn ;
7304: CALL_OW 8
// CenterNowOnXY ( 49 , 30 ) ;
7308: LD_INT 49
7310: PPUSH
7311: LD_INT 30
7313: PPUSH
7314: CALL_OW 86
// if IsPlaced ( Rolf ) then
7318: LD_EXP 5
7322: PPUSH
7323: CALL_OW 305
7327: IFFALSE 7349
// begin un := Rolf ;
7329: LD_ADDR_VAR 0 2
7333: PUSH
7334: LD_EXP 5
7338: ST_TO_ADDR
// str := RL ;
7339: LD_ADDR_VAR 0 3
7343: PUSH
7344: LD_STRING RL
7346: ST_TO_ADDR
// end else
7347: GO 7434
// if IsPlaced ( Karla ) then
7349: LD_EXP 12
7353: PPUSH
7354: CALL_OW 305
7358: IFFALSE 7380
// begin un := Karla ;
7360: LD_ADDR_VAR 0 2
7364: PUSH
7365: LD_EXP 12
7369: ST_TO_ADDR
// str := KR ;
7370: LD_ADDR_VAR 0 3
7374: PUSH
7375: LD_STRING KR
7377: ST_TO_ADDR
// end else
7378: GO 7434
// begin un := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) [ Rand ( 2 , 8 ) ] ;
7380: LD_ADDR_VAR 0 2
7384: PUSH
7385: LD_INT 22
7387: PUSH
7388: LD_INT 2
7390: PUSH
7391: EMPTY
7392: LIST
7393: LIST
7394: PUSH
7395: LD_INT 21
7397: PUSH
7398: LD_INT 1
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: PPUSH
7409: CALL_OW 69
7413: PUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 8
7419: PPUSH
7420: CALL_OW 12
7424: ARRAY
7425: ST_TO_ADDR
// str := RG ;
7426: LD_ADDR_VAR 0 3
7430: PUSH
7431: LD_STRING RG
7433: ST_TO_ADDR
// end ; repeat Wait ( 0 0$01 ) ;
7434: LD_INT 35
7436: PPUSH
7437: CALL_OW 67
// until not IsInUnit ( Louis ) ;
7441: LD_EXP 4
7445: PPUSH
7446: CALL_OW 310
7450: NOT
7451: IFFALSE 7434
// ComExitVehicle ( Louis ) ;
7453: LD_EXP 4
7457: PPUSH
7458: CALL_OW 121
// ComTurnUnit ( Louis , un ) ;
7462: LD_EXP 4
7466: PPUSH
7467: LD_VAR 0 2
7471: PPUSH
7472: CALL_OW 119
// ComTurnUnit ( un , Louis ) ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_EXP 4
7485: PPUSH
7486: CALL_OW 119
// Say ( Louis , 10c_DL1 ) ;
7490: LD_EXP 4
7494: PPUSH
7495: LD_STRING 10c_DL1
7497: PPUSH
7498: CALL_OW 88
// Say ( un , 10c_ & str & 1 ) ;
7502: LD_VAR 0 2
7506: PPUSH
7507: LD_STRING 10c_
7509: PUSH
7510: LD_VAR 0 3
7514: STR
7515: PUSH
7516: LD_STRING 1
7518: STR
7519: PPUSH
7520: CALL_OW 88
// Say ( Louis , 10c_DL2 ) ;
7524: LD_EXP 4
7528: PPUSH
7529: LD_STRING 10c_DL2
7531: PPUSH
7532: CALL_OW 88
// Say ( un , 10c_ & str & 2 ) ;
7536: LD_VAR 0 2
7540: PPUSH
7541: LD_STRING 10c_
7543: PUSH
7544: LD_VAR 0 3
7548: STR
7549: PUSH
7550: LD_STRING 2
7552: STR
7553: PPUSH
7554: CALL_OW 88
// Say ( Louis , 10c_DL3 ) ;
7558: LD_EXP 4
7562: PPUSH
7563: LD_STRING 10c_DL3
7565: PPUSH
7566: CALL_OW 88
// Say ( un , 10c_ & str & 3 ) ;
7570: LD_VAR 0 2
7574: PPUSH
7575: LD_STRING 10c_
7577: PUSH
7578: LD_VAR 0 3
7582: STR
7583: PUSH
7584: LD_STRING 3
7586: STR
7587: PPUSH
7588: CALL_OW 88
// SayRadio ( Shariff , 10c_DS1 ) ;
7592: LD_EXP 24
7596: PPUSH
7597: LD_STRING 10c_DS1
7599: PPUSH
7600: CALL_OW 94
// Say ( Louis , 10c_DL4 ) ;
7604: LD_EXP 4
7608: PPUSH
7609: LD_STRING 10c_DL4
7611: PPUSH
7612: CALL_OW 88
// SayRadio ( Shariff , 10c_DS2 ) ;
7616: LD_EXP 24
7620: PPUSH
7621: LD_STRING 10c_DS2
7623: PPUSH
7624: CALL_OW 94
// Say ( Louis , 10c_DL5 ) ;
7628: LD_EXP 4
7632: PPUSH
7633: LD_STRING 10c_DL5
7635: PPUSH
7636: CALL_OW 88
// SayRadio ( Shariff , 10c_DS3 ) ;
7640: LD_EXP 24
7644: PPUSH
7645: LD_STRING 10c_DS3
7647: PPUSH
7648: CALL_OW 94
// Say ( Louis , 10c_DL6 ) ;
7652: LD_EXP 4
7656: PPUSH
7657: LD_STRING 10c_DL6
7659: PPUSH
7660: CALL_OW 88
// SayRadio ( Shariff , 10c_DS4 ) ;
7664: LD_EXP 24
7668: PPUSH
7669: LD_STRING 10c_DS4
7671: PPUSH
7672: CALL_OW 94
// Say ( Louis , 10c_DL7 ) ;
7676: LD_EXP 4
7680: PPUSH
7681: LD_STRING 10c_DL7
7683: PPUSH
7684: CALL_OW 88
// SayRadio ( Shariff , 10c_DS5 ) ;
7688: LD_EXP 24
7692: PPUSH
7693: LD_STRING 10c_DS5
7695: PPUSH
7696: CALL_OW 94
// Say ( un , 10c_ & str & 4 ) ;
7700: LD_VAR 0 2
7704: PPUSH
7705: LD_STRING 10c_
7707: PUSH
7708: LD_VAR 0 3
7712: STR
7713: PUSH
7714: LD_STRING 4
7716: STR
7717: PPUSH
7718: CALL_OW 88
// Say ( Louis , 10c_DL8 ) ;
7722: LD_EXP 4
7726: PPUSH
7727: LD_STRING 10c_DL8
7729: PPUSH
7730: CALL_OW 88
// Say ( un , 10c_ & str & 5 ) ;
7734: LD_VAR 0 2
7738: PPUSH
7739: LD_STRING 10c_
7741: PUSH
7742: LD_VAR 0 3
7746: STR
7747: PUSH
7748: LD_STRING 5
7750: STR
7751: PPUSH
7752: CALL_OW 88
// Say ( Louis , 10c_DL9 ) ;
7756: LD_EXP 4
7760: PPUSH
7761: LD_STRING 10c_DL9
7763: PPUSH
7764: CALL_OW 88
// InGameOff ;
7768: CALL_OW 9
// game := true ;
7772: LD_ADDR_EXP 1
7776: PUSH
7777: LD_INT 1
7779: ST_TO_ADDR
// ChangeMissionObjectives ( Res ) ;
7780: LD_STRING Res
7782: PPUSH
7783: CALL_OW 337
// Wait ( 0 0$30 ) ;
7787: LD_INT 1050
7789: PPUSH
7790: CALL_OW 67
// PrepareDoc ;
7794: CALL 1377 0 0
// repeat Wait ( 0 0$01 ) ;
7798: LD_INT 35
7800: PPUSH
7801: CALL_OW 67
// until GetDistUnits ( Louis , Kunt ) < 9 ;
7805: LD_EXP 4
7809: PPUSH
7810: LD_EXP 22
7814: PPUSH
7815: CALL_OW 296
7819: PUSH
7820: LD_INT 9
7822: LESS
7823: IFFALSE 7798
// DialogueOn ;
7825: CALL_OW 6
// CenterOnUnits ( Kunt ) ;
7829: LD_EXP 22
7833: PPUSH
7834: CALL_OW 85
// SetSide ( Kunt , 2 ) ;
7838: LD_EXP 22
7842: PPUSH
7843: LD_INT 2
7845: PPUSH
7846: CALL_OW 235
// ComTurnUnit ( Kunt , Louis ) ;
7850: LD_EXP 22
7854: PPUSH
7855: LD_EXP 4
7859: PPUSH
7860: CALL_OW 119
// ComTurnUnit ( Louis , Kunt ) ;
7864: LD_EXP 4
7868: PPUSH
7869: LD_EXP 22
7873: PPUSH
7874: CALL_OW 119
// Say ( Kunt , 10c_KN1 ) ;
7878: LD_EXP 22
7882: PPUSH
7883: LD_STRING 10c_KN1
7885: PPUSH
7886: CALL_OW 88
// Say ( Louis , 10c_DL10 ) ;
7890: LD_EXP 4
7894: PPUSH
7895: LD_STRING 10c_DL10
7897: PPUSH
7898: CALL_OW 88
// Say ( Kunt , 10c_KN2 ) ;
7902: LD_EXP 22
7906: PPUSH
7907: LD_STRING 10c_KN2
7909: PPUSH
7910: CALL_OW 88
// if FindLab ( 2 , 13 ) then
7914: LD_INT 2
7916: PPUSH
7917: LD_INT 13
7919: PPUSH
7920: CALL 6963 0 2
7924: IFFALSE 7952
// begin Say ( Louis , 10c_DL11a ) ;
7926: LD_EXP 4
7930: PPUSH
7931: LD_STRING 10c_DL11a
7933: PPUSH
7934: CALL_OW 88
// Say ( Kunt , 10c_KN3a ) ;
7938: LD_EXP 22
7942: PPUSH
7943: LD_STRING 10c_KN3a
7945: PPUSH
7946: CALL_OW 88
// end else
7950: GO 8058
// begin Say ( Louis , 10c_DL11b ) ;
7952: LD_EXP 4
7956: PPUSH
7957: LD_STRING 10c_DL11b
7959: PPUSH
7960: CALL_OW 88
// Say ( Kunt , 10c_KN3b ) ;
7964: LD_EXP 22
7968: PPUSH
7969: LD_STRING 10c_KN3b
7971: PPUSH
7972: CALL_OW 88
// if IsPlaced ( Rolf ) then
7976: LD_EXP 5
7980: PPUSH
7981: CALL_OW 305
7985: IFFALSE 8047
// begin Say ( Rolf , 10c_RF_doc1 ) ;
7987: LD_EXP 5
7991: PPUSH
7992: LD_STRING 10c_RF_doc1
7994: PPUSH
7995: CALL_OW 88
// Say ( Kunt , 10c_KN_doc1 ) ;
7999: LD_EXP 22
8003: PPUSH
8004: LD_STRING 10c_KN_doc1
8006: PPUSH
8007: CALL_OW 88
// Say ( Rolf , 10c_RF_doc2 ) ;
8011: LD_EXP 5
8015: PPUSH
8016: LD_STRING 10c_RF_doc2
8018: PPUSH
8019: CALL_OW 88
// Say ( Louis , 10c_DL_doc1 ) ;
8023: LD_EXP 4
8027: PPUSH
8028: LD_STRING 10c_DL_doc1
8030: PPUSH
8031: CALL_OW 88
// Say ( Kunt , 10c_KN_doc2 ) ;
8035: LD_EXP 22
8039: PPUSH
8040: LD_STRING 10c_KN_doc2
8042: PPUSH
8043: CALL_OW 88
// end ; DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( BioLab ) ;
8051: LD_STRING BioLab
8053: PPUSH
8054: CALL_OW 337
// end ; DialogueOff ;
8058: CALL_OW 7
// end ;
8062: LD_VAR 0 1
8066: RET
// every 0 0$01 trigger need_bio_lab and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , 13 ] ] ) do
8067: LD_EXP 34
8071: PUSH
8072: LD_INT 22
8074: PUSH
8075: LD_INT 2
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 30
8084: PUSH
8085: LD_INT 13
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: AND
8101: IFFALSE 8113
8103: GO 8105
8105: DISABLE
// ChangeMissionObjectives ( DesBioLab ) ;
8106: LD_STRING DesBioLab
8108: PPUSH
8109: CALL_OW 337
8113: END
// every 0 0$01 trigger GetTech ( tech_apelang , 2 ) = state_researched and GetSide ( Kunt ) = 2 do
8114: LD_INT 1
8116: PPUSH
8117: LD_INT 2
8119: PPUSH
8120: CALL_OW 321
8124: PUSH
8125: LD_INT 2
8127: EQUAL
8128: PUSH
8129: LD_EXP 22
8133: PPUSH
8134: CALL_OW 255
8138: PUSH
8139: LD_INT 2
8141: EQUAL
8142: AND
8143: IFFALSE 8206
8145: GO 8147
8147: DISABLE
// begin Say ( Kunt , 10c_KN-ape-1 ) ;
8148: LD_EXP 22
8152: PPUSH
8153: LD_STRING 10c_KN-ape-1
8155: PPUSH
8156: CALL_OW 88
// CreateApemans ( 5 , east_ape ) ;
8160: LD_INT 5
8162: PPUSH
8163: LD_INT 13
8165: PPUSH
8166: CALL 5110 0 2
// CreateTigers ( 1 + Difficulty , east_ape , [ 10 , 20 , 30 ] [ Difficulty ] ) ;
8170: LD_INT 1
8172: PUSH
8173: LD_OWVAR 67
8177: PLUS
8178: PPUSH
8179: LD_INT 13
8181: PPUSH
8182: LD_INT 10
8184: PUSH
8185: LD_INT 20
8187: PUSH
8188: LD_INT 30
8190: PUSH
8191: EMPTY
8192: LIST
8193: LIST
8194: LIST
8195: PUSH
8196: LD_OWVAR 67
8200: ARRAY
8201: PPUSH
8202: CALL 5263 0 3
// end ;
8206: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman ] ] ) do
8207: LD_INT 22
8209: PUSH
8210: LD_INT 2
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: LD_INT 25
8219: PUSH
8220: LD_INT 12
8222: PUSH
8223: EMPTY
8224: LIST
8225: LIST
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PPUSH
8231: CALL_OW 69
8235: IFFALSE 8278
8237: GO 8239
8239: DISABLE
// begin Say ( Kunt , 10c_KN-ape2 ) ;
8240: LD_EXP 22
8244: PPUSH
8245: LD_STRING 10c_KN-ape2
8247: PPUSH
8248: CALL_OW 88
// SetTech ( 3 , 2 , state_enabled ) ;
8252: LD_INT 3
8254: PPUSH
8255: LD_INT 2
8257: PPUSH
8258: LD_INT 1
8260: PPUSH
8261: CALL_OW 322
// SetTech ( 4 , 2 , state_enabled ) ;
8265: LD_INT 4
8267: PPUSH
8268: LD_INT 2
8270: PPUSH
8271: LD_INT 1
8273: PPUSH
8274: CALL_OW 322
// end ;
8278: END
// every 0 0$01 trigger ape_brain do
8279: LD_EXP 35
8283: IFFALSE 8379
8285: GO 8287
8287: DISABLE
// begin DialogueOn ;
8288: CALL_OW 6
// Say ( Louis , 10c_DL-apbrain1 ) ;
8292: LD_EXP 4
8296: PPUSH
8297: LD_STRING 10c_DL-apbrain1
8299: PPUSH
8300: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain1 ) ;
8304: LD_EXP 22
8308: PPUSH
8309: LD_STRING 10c_KN-apbrain1
8311: PPUSH
8312: CALL_OW 88
// Say ( Louis , 10c_DL-apbrain2 ) ;
8316: LD_EXP 4
8320: PPUSH
8321: LD_STRING 10c_DL-apbrain2
8323: PPUSH
8324: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain2 ) ;
8328: LD_EXP 22
8332: PPUSH
8333: LD_STRING 10c_KN-apbrain2
8335: PPUSH
8336: CALL_OW 88
// if IsLive ( Rolf ) then
8340: LD_EXP 5
8344: PPUSH
8345: CALL_OW 300
8349: IFFALSE 8375
// begin Say ( Rolf , 10c_RF-apbrain1 ) ;
8351: LD_EXP 5
8355: PPUSH
8356: LD_STRING 10c_RF-apbrain1
8358: PPUSH
8359: CALL_OW 88
// Say ( Kunt , 10c_KN-apbrain3 ) ;
8363: LD_EXP 22
8367: PPUSH
8368: LD_STRING 10c_KN-apbrain3
8370: PPUSH
8371: CALL_OW 88
// end ; DialogueOff ;
8375: CALL_OW 7
// end ;
8379: END
// every 0 0$01 trigger ape_neut do
8380: LD_EXP 36
8384: IFFALSE 8544
8386: GO 8388
8388: DISABLE
// begin DialogueOn ;
8389: CALL_OW 6
// Say ( Louis , 10c_DL-apenatur1 ) ;
8393: LD_EXP 4
8397: PPUSH
8398: LD_STRING 10c_DL-apenatur1
8400: PPUSH
8401: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur1 ) ;
8405: LD_EXP 22
8409: PPUSH
8410: LD_STRING 10c_KN-apenatur1
8412: PPUSH
8413: CALL_OW 88
// Say ( Louis , 10c_DL-apenatur2 ) ;
8417: LD_EXP 4
8421: PPUSH
8422: LD_STRING 10c_DL-apenatur2
8424: PPUSH
8425: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur2 ) ;
8429: LD_EXP 22
8433: PPUSH
8434: LD_STRING 10c_KN-apenatur2
8436: PPUSH
8437: CALL_OW 88
// Say ( Louis , 10c_DL-apenatur3 ) ;
8441: LD_EXP 4
8445: PPUSH
8446: LD_STRING 10c_DL-apenatur3
8448: PPUSH
8449: CALL_OW 88
// Say ( Kunt , 10c_KN-apenatur3 ) ;
8453: LD_EXP 22
8457: PPUSH
8458: LD_STRING 10c_KN-apenatur3
8460: PPUSH
8461: CALL_OW 88
// DialogueOff ;
8465: CALL_OW 7
// Wait ( Rand ( 0 0$14 , 0 0$37 ) ) ;
8469: LD_INT 490
8471: PPUSH
8472: LD_INT 1295
8474: PPUSH
8475: CALL_OW 12
8479: PPUSH
8480: CALL_OW 67
// InGameOn ;
8484: CALL_OW 8
// CenterOnUnits ( Kunt ) ;
8488: LD_EXP 22
8492: PPUSH
8493: CALL_OW 85
// Wait ( 0 0$02 ) ;
8497: LD_INT 70
8499: PPUSH
8500: CALL_OW 67
// SetLives ( IsInUnit ( Kunt ) , 1 ) ;
8504: LD_EXP 22
8508: PPUSH
8509: CALL_OW 310
8513: PPUSH
8514: LD_INT 1
8516: PPUSH
8517: CALL_OW 234
// Wait ( 0 0$01 ) ;
8521: LD_INT 35
8523: PPUSH
8524: CALL_OW 67
// Say ( Kunt , 10c_KN-labruin1 ) ;
8528: LD_EXP 22
8532: PPUSH
8533: LD_STRING 10c_KN-labruin1
8535: PPUSH
8536: CALL_OW 88
// InGameOff ;
8540: CALL_OW 9
// end ;
8544: END
// every 0 0$01 trigger GetTech ( 2 , tech_sibPow ) = state_researched do
8545: LD_INT 2
8547: PPUSH
8548: LD_INT 21
8550: PPUSH
8551: CALL_OW 321
8555: PUSH
8556: LD_INT 2
8558: EQUAL
8559: IFFALSE 8588
8561: GO 8563
8563: DISABLE
// begin Say ( sci ( 2 , Kunt ) [ 1 ] , 10c_DS-SibEng1 ) ;
8564: LD_INT 2
8566: PPUSH
8567: LD_EXP 22
8571: PPUSH
8572: CALL 6795 0 2
8576: PUSH
8577: LD_INT 1
8579: ARRAY
8580: PPUSH
8581: LD_STRING 10c_DS-SibEng1
8583: PPUSH
8584: CALL_OW 88
// end ;
8588: END
// every 0 0$01 trigger GetTech ( 2 , tech_sibEng ) = state_researched do
8589: LD_INT 2
8591: PPUSH
8592: LD_INT 22
8594: PPUSH
8595: CALL_OW 321
8599: PUSH
8600: LD_INT 2
8602: EQUAL
8603: IFFALSE 8660
8605: GO 8607
8607: DISABLE
// begin Say ( sci ( 2 , [ Kunt , Louis ] ) [ 1 ] , 10c_DS-SibEng2 ) ;
8608: LD_INT 2
8610: PPUSH
8611: LD_EXP 22
8615: PUSH
8616: LD_EXP 4
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL 6795 0 2
8629: PUSH
8630: LD_INT 1
8632: ARRAY
8633: PPUSH
8634: LD_STRING 10c_DS-SibEng2
8636: PPUSH
8637: CALL_OW 88
// Say ( Louis , 10c_DL-SibEng1 ) ;
8641: LD_EXP 4
8645: PPUSH
8646: LD_STRING 10c_DL-SibEng1
8648: PPUSH
8649: CALL_OW 88
// ChangeMissionObjectives ( SibEng ) ;
8653: LD_STRING SibEng
8655: PPUSH
8656: CALL_OW 337
// end ;
8660: END
// every 0 0$01 trigger GetVehicle ( 2 , engine_siberite ) do
8661: LD_INT 2
8663: PPUSH
8664: LD_INT 3
8666: PPUSH
8667: CALL 6917 0 2
8671: IFFALSE 8714
8673: GO 8675
8675: DISABLE
// begin Say ( m ( 2 , Louis ) [ 1 ] , 10c_DS-SibEng3 ) ;
8676: LD_INT 2
8678: PPUSH
8679: LD_EXP 4
8683: PPUSH
8684: CALL 6856 0 2
8688: PUSH
8689: LD_INT 1
8691: ARRAY
8692: PPUSH
8693: LD_STRING 10c_DS-SibEng3
8695: PPUSH
8696: CALL_OW 88
// Wait ( 0 0$44 ) ;
8700: LD_INT 1540
8702: PPUSH
8703: CALL_OW 67
// ChangeMissionObjectives ( SibEngOut ) ;
8707: LD_STRING SibEngOut
8709: PPUSH
8710: CALL_OW 337
// end ;
8714: END
// every 18 18$19 do
8715: GO 8717
8717: DISABLE
// begin SayRadio ( Shariff , 10c_DS-Cm1 ) ;
8718: LD_EXP 24
8722: PPUSH
8723: LD_STRING 10c_DS-Cm1
8725: PPUSH
8726: CALL_OW 94
// end ;
8730: END
// every 27 27$12 do
8731: GO 8733
8733: DISABLE
// begin SayRadio ( Gensher , 10c_DG-Cm1 ) ;
8734: LD_EXP 25
8738: PPUSH
8739: LD_STRING 10c_DG-Cm1
8741: PPUSH
8742: CALL_OW 94
// end ;
8746: END
// every 30 30$00 trigger join_to_legion = false do
8747: LD_EXP 38
8751: PUSH
8752: LD_INT 0
8754: EQUAL
8755: IFFALSE 8764
8757: GO 8759
8759: DISABLE
// begin PrepareAttack ( ) ;
8760: CALL 9201 0 0
// end ;
8764: END
// every 29 29$00 do
8765: GO 8767
8767: DISABLE
// begin InGameOn ;
8768: CALL_OW 8
// SayRadio ( Kurt , 10c_DK-LegionOffer1 ) ;
8772: LD_EXP 27
8776: PPUSH
8777: LD_STRING 10c_DK-LegionOffer1
8779: PPUSH
8780: CALL_OW 94
// InGameOff ;
8784: CALL_OW 9
// ChangeMissionObjectives ( Legion ) ;
8788: LD_STRING Legion
8790: PPUSH
8791: CALL_OW 337
// end ; end_of_file
8795: END
// every 1 1$00 + 0 0$25 trigger game do var amount , time , p ;
8796: LD_EXP 1
8800: IFFALSE 9198
8802: GO 8804
8804: DISABLE
8805: LD_INT 0
8807: PPUSH
8808: PPUSH
8809: PPUSH
// begin time := [ 1 1$30 , 2 2$00 , 2 2$40 ] [ Difficulty ] ;
8810: LD_ADDR_VAR 0 2
8814: PUSH
8815: LD_INT 3150
8817: PUSH
8818: LD_INT 4200
8820: PUSH
8821: LD_INT 5600
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_OWVAR 67
8833: ARRAY
8834: ST_TO_ADDR
// case Difficulty of 1 :
8835: LD_OWVAR 67
8839: PUSH
8840: LD_INT 1
8842: DOUBLE
8843: EQUAL
8844: IFTRUE 8848
8846: GO 8859
8848: POP
// amount := 3000 ; 2 :
8849: LD_ADDR_VAR 0 1
8853: PUSH
8854: LD_INT 3000
8856: ST_TO_ADDR
8857: GO 8898
8859: LD_INT 2
8861: DOUBLE
8862: EQUAL
8863: IFTRUE 8867
8865: GO 8878
8867: POP
// amount := 2400 ; 3 :
8868: LD_ADDR_VAR 0 1
8872: PUSH
8873: LD_INT 2400
8875: ST_TO_ADDR
8876: GO 8898
8878: LD_INT 3
8880: DOUBLE
8881: EQUAL
8882: IFTRUE 8886
8884: GO 8897
8886: POP
// amount := 1900 ; end ;
8887: LD_ADDR_VAR 0 1
8891: PUSH
8892: LD_INT 1900
8894: ST_TO_ADDR
8895: GO 8898
8897: POP
// repeat begin p := Rand ( 1 , 5 ) ;
8898: LD_ADDR_VAR 0 3
8902: PUSH
8903: LD_INT 1
8905: PPUSH
8906: LD_INT 5
8908: PPUSH
8909: CALL_OW 12
8913: ST_TO_ADDR
// amount := amount - ( p * 10 ) ;
8914: LD_ADDR_VAR 0 1
8918: PUSH
8919: LD_VAR 0 1
8923: PUSH
8924: LD_VAR 0 3
8928: PUSH
8929: LD_INT 10
8931: MUL
8932: MINUS
8933: ST_TO_ADDR
// CreateCratesArea ( p , first_spawn , true ) ;
8934: LD_VAR 0 3
8938: PPUSH
8939: LD_INT 11
8941: PPUSH
8942: LD_INT 1
8944: PPUSH
8945: CALL_OW 55
// Wait ( time + Rand ( - 0 0$10 , 0 0$15 ) ) ;
8949: LD_VAR 0 2
8953: PUSH
8954: LD_INT 350
8956: NEG
8957: PPUSH
8958: LD_INT 525
8960: PPUSH
8961: CALL_OW 12
8965: PLUS
8966: PPUSH
8967: CALL_OW 67
// end until amount > 0 ;
8971: LD_VAR 0 1
8975: PUSH
8976: LD_INT 0
8978: GREATER
8979: IFFALSE 8898
// time := [ 2 2$30 , 3 3$00 , 3 3$40 ] [ Difficulty ] ;
8981: LD_ADDR_VAR 0 2
8985: PUSH
8986: LD_INT 5250
8988: PUSH
8989: LD_INT 6300
8991: PUSH
8992: LD_INT 7700
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: LIST
8999: PUSH
9000: LD_OWVAR 67
9004: ARRAY
9005: ST_TO_ADDR
// case Difficulty of 1 :
9006: LD_OWVAR 67
9010: PUSH
9011: LD_INT 1
9013: DOUBLE
9014: EQUAL
9015: IFTRUE 9019
9017: GO 9030
9019: POP
// amount := 9000 ; 2 :
9020: LD_ADDR_VAR 0 1
9024: PUSH
9025: LD_INT 9000
9027: ST_TO_ADDR
9028: GO 9069
9030: LD_INT 2
9032: DOUBLE
9033: EQUAL
9034: IFTRUE 9038
9036: GO 9049
9038: POP
// amount := 7400 ; 3 :
9039: LD_ADDR_VAR 0 1
9043: PUSH
9044: LD_INT 7400
9046: ST_TO_ADDR
9047: GO 9069
9049: LD_INT 3
9051: DOUBLE
9052: EQUAL
9053: IFTRUE 9057
9055: GO 9068
9057: POP
// amount := 5900 ; end ;
9058: LD_ADDR_VAR 0 1
9062: PUSH
9063: LD_INT 5900
9065: ST_TO_ADDR
9066: GO 9069
9068: POP
// repeat begin p := Rand ( 1 , 5 ) ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: PPUSH
9077: LD_INT 5
9079: PPUSH
9080: CALL_OW 12
9084: ST_TO_ADDR
// amount := amount - ( p * 10 ) ;
9085: LD_ADDR_VAR 0 1
9089: PUSH
9090: LD_VAR 0 1
9094: PUSH
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 10
9102: MUL
9103: MINUS
9104: ST_TO_ADDR
// CreateCratesArea ( p , second_spawn , true ) ;
9105: LD_VAR 0 3
9109: PPUSH
9110: LD_INT 12
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: CALL_OW 55
// Wait ( time + Rand ( - 0 0$10 , 0 0$25 ) ) ;
9120: LD_VAR 0 2
9124: PUSH
9125: LD_INT 350
9127: NEG
9128: PPUSH
9129: LD_INT 875
9131: PPUSH
9132: CALL_OW 12
9136: PLUS
9137: PPUSH
9138: CALL_OW 67
// end until amount > 0 ;
9142: LD_VAR 0 1
9146: PUSH
9147: LD_INT 0
9149: GREATER
9150: IFFALSE 9069
// while ( true ) do
9152: LD_INT 1
9154: IFFALSE 9198
// begin Wait ( time + Rand ( - 0 0$10 , 0 0$25 ) ) ;
9156: LD_VAR 0 2
9160: PUSH
9161: LD_INT 350
9163: NEG
9164: PPUSH
9165: LD_INT 875
9167: PPUSH
9168: CALL_OW 12
9172: PLUS
9173: PPUSH
9174: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
9178: LD_INT 1
9180: PPUSH
9181: LD_INT 5
9183: PPUSH
9184: CALL_OW 12
9188: PPUSH
9189: LD_INT 1
9191: PPUSH
9192: CALL_OW 57
// end ;
9196: GO 9152
// end ; end_of_file
9198: PPOPN 3
9200: END
// export function PrepareAttack ( ) ; var i , un , east_tab , west_tab , skill , veh ; begin
9201: LD_INT 0
9203: PPUSH
9204: PPUSH
9205: PPUSH
9206: PPUSH
9207: PPUSH
9208: PPUSH
9209: PPUSH
// Randomize ;
9210: CALL_OW 10
// east_tab := [ ] ;
9214: LD_ADDR_VAR 0 4
9218: PUSH
9219: EMPTY
9220: ST_TO_ADDR
// west_tab := [ ] ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: EMPTY
9227: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
9228: LD_ADDR_VAR 0 6
9232: PUSH
9233: LD_INT 7
9235: PUSH
9236: LD_INT 8
9238: PUSH
9239: LD_INT 9
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PUSH
9247: LD_OWVAR 67
9251: ARRAY
9252: ST_TO_ADDR
// uc_side := 1 ;
9253: LD_ADDR_OWVAR 20
9257: PUSH
9258: LD_INT 1
9260: ST_TO_ADDR
// uc_nation := 1 ;
9261: LD_ADDR_OWVAR 21
9265: PUSH
9266: LD_INT 1
9268: ST_TO_ADDR
// hc_name :=  ;
9269: LD_ADDR_OWVAR 26
9273: PUSH
9274: LD_STRING 
9276: ST_TO_ADDR
// hc_gallery :=  ;
9277: LD_ADDR_OWVAR 33
9281: PUSH
9282: LD_STRING 
9284: ST_TO_ADDR
// vc_chassis := us_medium_tracked ;
9285: LD_ADDR_OWVAR 37
9289: PUSH
9290: LD_INT 3
9292: ST_TO_ADDR
// vc_engine := engine_combustion ;
9293: LD_ADDR_OWVAR 39
9297: PUSH
9298: LD_INT 1
9300: ST_TO_ADDR
// vc_control := control_manual ;
9301: LD_ADDR_OWVAR 38
9305: PUSH
9306: LD_INT 1
9308: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
9309: LD_ADDR_VAR 0 2
9313: PUSH
9314: DOUBLE
9315: LD_INT 1
9317: DEC
9318: ST_TO_ADDR
9319: LD_INT 5
9321: PUSH
9322: LD_INT 6
9324: PUSH
9325: LD_INT 7
9327: PUSH
9328: EMPTY
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: LD_OWVAR 67
9337: ARRAY
9338: PUSH
9339: FOR_TO
9340: IFFALSE 9465
// begin vc_weapon := [ us_rocket_launcher , us_double_gun , us_rocket_launcher , us_double_gun , us_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
9342: LD_ADDR_OWVAR 40
9346: PUSH
9347: LD_INT 7
9349: PUSH
9350: LD_INT 5
9352: PUSH
9353: LD_INT 7
9355: PUSH
9356: LD_INT 5
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: LIST
9366: LIST
9367: LIST
9368: PUSH
9369: LD_INT 1
9371: PPUSH
9372: LD_INT 5
9374: PPUSH
9375: CALL_OW 12
9379: ARRAY
9380: ST_TO_ADDR
// veh := CreateVehicle ;
9381: LD_ADDR_VAR 0 7
9385: PUSH
9386: CALL_OW 45
9390: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
9391: LD_VAR 0 7
9395: PPUSH
9396: LD_INT 3
9398: PPUSH
9399: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9403: LD_VAR 0 7
9407: PPUSH
9408: LD_INT 15
9410: PPUSH
9411: LD_INT 0
9413: PPUSH
9414: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
9418: LD_INT 0
9420: PPUSH
9421: LD_INT 3
9423: PPUSH
9424: LD_VAR 0 6
9428: PPUSH
9429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
9433: CALL_OW 44
9437: PPUSH
9438: LD_VAR 0 7
9442: PPUSH
9443: CALL_OW 52
// east_tab := east_tab ^ veh ;
9447: LD_ADDR_VAR 0 4
9451: PUSH
9452: LD_VAR 0 4
9456: PUSH
9457: LD_VAR 0 7
9461: ADD
9462: ST_TO_ADDR
// end ;
9463: GO 9339
9465: POP
9466: POP
// end ;
9467: LD_VAR 0 1
9471: RET
