// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// PrepareNature ( nature_area , 6 , 3 , 2 , 1 ) ;
   8: LD_INT 18
  10: PPUSH
  11: LD_INT 6
  13: PPUSH
  14: LD_INT 3
  16: PPUSH
  17: LD_INT 2
  19: PPUSH
  20: LD_INT 1
  22: PPUSH
  23: CALL 1559 0 5
// PrepareRussian ;
  27: CALL 2460 0 0
// WestBase ;
  31: CALL 431 0 0
// PrepareLouis ;
  35: CALL 44 0 0
// Action ;
  39: CALL 15091 0 0
// end ; end_of_file
  43: END
// export Louis , Louis_Veh ; export function PrepareLouis ; begin
  44: LD_INT 0
  46: PPUSH
// uc_side := 2 ;
  47: LD_ADDR_OWVAR 20
  51: PUSH
  52: LD_INT 2
  54: ST_TO_ADDR
// Louis := CreateCharacter ( Louis ) ;
  55: LD_ADDR_EXP 1
  59: PUSH
  60: LD_STRING Louis
  62: PPUSH
  63: CALL_OW 34
  67: ST_TO_ADDR
// if Louis = false then
  68: LD_EXP 1
  72: PUSH
  73: LD_INT 0
  75: EQUAL
  76: IFFALSE 150
// begin hc_gallery :=  ;
  78: LD_ADDR_OWVAR 33
  82: PUSH
  83: LD_STRING 
  85: ST_TO_ADDR
// hc_name := Louis Tester ;
  86: LD_ADDR_OWVAR 26
  90: PUSH
  91: LD_STRING Louis Tester
  93: ST_TO_ADDR
// hc_class := 1 ;
  94: LD_ADDR_OWVAR 28
  98: PUSH
  99: LD_INT 1
 101: ST_TO_ADDR
// hc_skills := [ 6 , 2 , 4 , 3 ] ;
 102: LD_ADDR_OWVAR 31
 106: PUSH
 107: LD_INT 6
 109: PUSH
 110: LD_INT 2
 112: PUSH
 113: LD_INT 4
 115: PUSH
 116: LD_INT 3
 118: PUSH
 119: EMPTY
 120: LIST
 121: LIST
 122: LIST
 123: LIST
 124: ST_TO_ADDR
// hc_sex := sex_male ;
 125: LD_ADDR_OWVAR 27
 129: PUSH
 130: LD_INT 1
 132: ST_TO_ADDR
// Louis := CreateHuman ;
 133: LD_ADDR_EXP 1
 137: PUSH
 138: CALL_OW 44
 142: ST_TO_ADDR
// FogOff ( 1 ) ;
 143: LD_INT 1
 145: PPUSH
 146: CALL_OW 344
// end ; uc_nation := 2 ;
 150: LD_ADDR_OWVAR 21
 154: PUSH
 155: LD_INT 2
 157: ST_TO_ADDR
// vc_chassis := [ ar_half_tracked , ar_half_tracked , ar_medium_trike ] [ Difficulty ] ;
 158: LD_ADDR_OWVAR 37
 162: PUSH
 163: LD_INT 14
 165: PUSH
 166: LD_INT 14
 168: PUSH
 169: LD_INT 13
 171: PUSH
 172: EMPTY
 173: LIST
 174: LIST
 175: LIST
 176: PUSH
 177: LD_OWVAR 67
 181: ARRAY
 182: ST_TO_ADDR
// vc_engine := engine_combustion ;
 183: LD_ADDR_OWVAR 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// vc_control := control_manual ;
 191: LD_ADDR_OWVAR 38
 195: PUSH
 196: LD_INT 1
 198: ST_TO_ADDR
// vc_weapon := [ ar_flame_thrower , ar_gun , ar_light_gun ] [ Difficulty ] ;
 199: LD_ADDR_OWVAR 40
 203: PUSH
 204: LD_INT 26
 206: PUSH
 207: LD_INT 27
 209: PUSH
 210: LD_INT 23
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// Louis_Veh := CreateVehicle ;
 224: LD_ADDR_EXP 2
 228: PUSH
 229: CALL_OW 45
 233: ST_TO_ADDR
// SetMark ( Louis_Veh , 1 ) ;
 234: LD_EXP 2
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: CALL_OW 242
// SetDir ( Louis_Veh , 4 ) ;
 246: LD_EXP 2
 250: PPUSH
 251: LD_INT 4
 253: PPUSH
 254: CALL_OW 233
// PlaceUnitArea ( Louis_Veh , start_area , false ) ;
 258: LD_EXP 2
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 49
// SetFuel ( Louis_Veh , [ 90 , 80 , 70 ] [ Difficulty ] ) ;
 273: LD_EXP 2
 277: PPUSH
 278: LD_INT 90
 280: PUSH
 281: LD_INT 80
 283: PUSH
 284: LD_INT 70
 286: PUSH
 287: EMPTY
 288: LIST
 289: LIST
 290: LIST
 291: PUSH
 292: LD_OWVAR 67
 296: ARRAY
 297: PPUSH
 298: CALL_OW 240
// PlaceHumanInUnit ( Louis , Louis_Veh ) ;
 302: LD_EXP 1
 306: PPUSH
 307: LD_EXP 2
 311: PPUSH
 312: CALL_OW 52
// InGameOn ;
 316: CALL_OW 8
// CenterNowOnXY ( 188 , 99 ) ;
 320: LD_INT 188
 322: PPUSH
 323: LD_INT 99
 325: PPUSH
 326: CALL_OW 86
// ComMoveXY ( Louis , 179 , 99 ) ;
 330: LD_EXP 1
 334: PPUSH
 335: LD_INT 179
 337: PPUSH
 338: LD_INT 99
 340: PPUSH
 341: CALL_OW 111
// end ;
 345: LD_VAR 0 1
 349: RET
// export Gali , Nicolas , Mike , Jenna , Rick ; export function LoadFrom03 ; begin
 350: LD_INT 0
 352: PPUSH
// uc_side := 5 ;
 353: LD_ADDR_OWVAR 20
 357: PUSH
 358: LD_INT 5
 360: ST_TO_ADDR
// Gali := CreateCharacter ( Gali_03 ) ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_STRING Gali_03
 368: PPUSH
 369: CALL_OW 34
 373: ST_TO_ADDR
// Mike := CreateCharacter ( Mike_03 ) ;
 374: LD_ADDR_EXP 5
 378: PUSH
 379: LD_STRING Mike_03
 381: PPUSH
 382: CALL_OW 34
 386: ST_TO_ADDR
// Nicolas := CreateCharacter ( Nicolas_03 ) ;
 387: LD_ADDR_EXP 4
 391: PUSH
 392: LD_STRING Nicolas_03
 394: PPUSH
 395: CALL_OW 34
 399: ST_TO_ADDR
// Jenna := CreateCharacter ( Jenna_03 ) ;
 400: LD_ADDR_EXP 6
 404: PUSH
 405: LD_STRING Jenna_03
 407: PPUSH
 408: CALL_OW 34
 412: ST_TO_ADDR
// Rick := CreateCharacter ( Rick_03 ) ;
 413: LD_ADDR_EXP 7
 417: PUSH
 418: LD_STRING Rick_03
 420: PPUSH
 421: CALL_OW 34
 425: ST_TO_ADDR
// end ;
 426: LD_VAR 0 1
 430: RET
// export Rolf , Ar_Squad , Skill ; export function WestBase ; var i , un ; begin
 431: LD_INT 0
 433: PPUSH
 434: PPUSH
 435: PPUSH
// LoadFrom03 ;
 436: CALL 350 0 0
// SetBName ( ar_depot , pavlov ) ;
 440: LD_INT 18
 442: PPUSH
 443: LD_STRING pavlov
 445: PPUSH
 446: CALL_OW 500
// uc_side := 5 ;
 450: LD_ADDR_OWVAR 20
 454: PUSH
 455: LD_INT 5
 457: ST_TO_ADDR
// uc_nation := 2 ;
 458: LD_ADDR_OWVAR 21
 462: PUSH
 463: LD_INT 2
 465: ST_TO_ADDR
// hc_gallery := sandar ;
 466: LD_ADDR_OWVAR 33
 470: PUSH
 471: LD_STRING sandar
 473: ST_TO_ADDR
// hc_face_number := 9 ;
 474: LD_ADDR_OWVAR 34
 478: PUSH
 479: LD_INT 9
 481: ST_TO_ADDR
// hc_name := Rolf Bergkampf ;
 482: LD_ADDR_OWVAR 26
 486: PUSH
 487: LD_STRING Rolf Bergkampf
 489: ST_TO_ADDR
// hc_basic_skills := [ 2 , 0 , 2 , 0 ] ;
 490: LD_ADDR_OWVAR 30
 494: PUSH
 495: LD_INT 2
 497: PUSH
 498: LD_INT 0
 500: PUSH
 501: LD_INT 2
 503: PUSH
 504: LD_INT 0
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 1 ] ;
 513: LD_ADDR_OWVAR 31
 517: PUSH
 518: LD_INT 7
 520: PUSH
 521: LD_INT 2
 523: PUSH
 524: LD_INT 4
 526: PUSH
 527: LD_INT 1
 529: PUSH
 530: EMPTY
 531: LIST
 532: LIST
 533: LIST
 534: LIST
 535: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 536: LD_ADDR_OWVAR 29
 540: PUSH
 541: LD_INT 10
 543: PUSH
 544: LD_INT 10
 546: PUSH
 547: EMPTY
 548: LIST
 549: LIST
 550: ST_TO_ADDR
// hc_sex := sex_male ;
 551: LD_ADDR_OWVAR 27
 555: PUSH
 556: LD_INT 1
 558: ST_TO_ADDR
// hc_class := 1 ;
 559: LD_ADDR_OWVAR 28
 563: PUSH
 564: LD_INT 1
 566: ST_TO_ADDR
// Rolf := CreateHuman ;
 567: LD_ADDR_EXP 8
 571: PUSH
 572: CALL_OW 44
 576: ST_TO_ADDR
// Ar_Squad := [ ] ;
 577: LD_ADDR_EXP 9
 581: PUSH
 582: EMPTY
 583: ST_TO_ADDR
// Skill := [ 5 , 4 , 4 ] [ Difficulty ] ;
 584: LD_ADDR_EXP 10
 588: PUSH
 589: LD_INT 5
 591: PUSH
 592: LD_INT 4
 594: PUSH
 595: LD_INT 4
 597: PUSH
 598: EMPTY
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_OWVAR 67
 607: ARRAY
 608: ST_TO_ADDR
// uc_nation := 0 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 0
 616: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
 617: LD_ADDR_OWVAR 30
 621: PUSH
 622: LD_INT 0
 624: PUSH
 625: LD_INT 0
 627: PUSH
 628: LD_INT 0
 630: PUSH
 631: LD_INT 0
 633: PUSH
 634: EMPTY
 635: LIST
 636: LIST
 637: LIST
 638: LIST
 639: ST_TO_ADDR
// hc_skills := [ 3 , 0 , 0 , 0 ] ;
 640: LD_ADDR_OWVAR 31
 644: PUSH
 645: LD_INT 3
 647: PUSH
 648: LD_INT 0
 650: PUSH
 651: LD_INT 0
 653: PUSH
 654: LD_INT 0
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: ST_TO_ADDR
// hc_gallery :=  ;
 663: LD_ADDR_OWVAR 33
 667: PUSH
 668: LD_STRING 
 670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
 671: LD_ADDR_OWVAR 28
 675: PUSH
 676: LD_INT 15
 678: ST_TO_ADDR
// hc_name :=  ;
 679: LD_ADDR_OWVAR 26
 683: PUSH
 684: LD_STRING 
 686: ST_TO_ADDR
// PlaceHumanInUnit ( CreateHuman , arradar ) ;
 687: CALL_OW 44
 691: PPUSH
 692: LD_INT 42
 694: PPUSH
 695: CALL_OW 52
// hc_class := class_apeman_engineer ;
 699: LD_ADDR_OWVAR 28
 703: PUSH
 704: LD_INT 16
 706: ST_TO_ADDR
// for i = 1 to 2 do
 707: LD_ADDR_VAR 0 2
 711: PUSH
 712: DOUBLE
 713: LD_INT 1
 715: DEC
 716: ST_TO_ADDR
 717: LD_INT 2
 719: PUSH
 720: FOR_TO
 721: IFFALSE 737
// PlaceHumanInUnit ( CreateHuman , ar_depot ) ;
 723: CALL_OW 44
 727: PPUSH
 728: LD_INT 18
 730: PPUSH
 731: CALL_OW 52
 735: GO 720
 737: POP
 738: POP
// uc_nation := 2 ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_INT 2
 746: ST_TO_ADDR
// PlaceHumanInUnit ( CreateHumanWithClass ( 9 , skill ) , arr_arm ) ;
 747: LD_INT 9
 749: PPUSH
 750: LD_EXP 10
 754: PPUSH
 755: CALL 1017 0 2
 759: PPUSH
 760: LD_INT 15
 762: PPUSH
 763: CALL_OW 52
// for i in FilterAllUnits ( [ [ [ f_side , 5 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ] ) do
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 5
 777: PUSH
 778: EMPTY
 779: LIST
 780: LIST
 781: PUSH
 782: LD_INT 58
 784: PUSH
 785: EMPTY
 786: LIST
 787: PUSH
 788: LD_INT 30
 790: PUSH
 791: LD_INT 32
 793: PUSH
 794: EMPTY
 795: LIST
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: LIST
 802: PUSH
 803: EMPTY
 804: LIST
 805: PPUSH
 806: CALL_OW 69
 810: PUSH
 811: FOR_IN
 812: IFFALSE 838
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , skill ) , i ) ;
 814: LD_INT 1
 816: PPUSH
 817: LD_EXP 10
 821: PPUSH
 822: CALL 1017 0 2
 826: PPUSH
 827: LD_VAR 0 2
 831: PPUSH
 832: CALL_OW 52
 836: GO 811
 838: POP
 839: POP
// if Jenna then
 840: LD_EXP 6
 844: IFFALSE 860
// PlaceHumanInUnit ( Jenna , ar_depot ) else
 846: LD_EXP 6
 850: PPUSH
 851: LD_INT 18
 853: PPUSH
 854: CALL_OW 52
 858: GO 880
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , ar_lab ) ;
 860: LD_INT 4
 862: PPUSH
 863: LD_EXP 10
 867: PPUSH
 868: CALL 1017 0 2
 872: PPUSH
 873: LD_INT 25
 875: PPUSH
 876: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , skill ) , ar_lab ) ;
 880: LD_INT 4
 882: PPUSH
 883: LD_EXP 10
 887: PPUSH
 888: CALL 1017 0 2
 892: PPUSH
 893: LD_INT 25
 895: PPUSH
 896: CALL_OW 52
// PlaceHumanInUnit ( Rolf , arr_arm ) ;
 900: LD_EXP 8
 904: PPUSH
 905: LD_INT 15
 907: PPUSH
 908: CALL_OW 52
// Ar_Squad := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ Rolf , Jenna ] ;
 912: LD_ADDR_EXP 9
 916: PUSH
 917: LD_INT 22
 919: PUSH
 920: LD_INT 5
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PUSH
 927: LD_INT 21
 929: PUSH
 930: LD_INT 1
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 25
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: PUSH
 950: LD_INT 25
 952: PUSH
 953: LD_INT 2
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 25
 962: PUSH
 963: LD_INT 3
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 25
 972: PUSH
 973: LD_INT 4
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: LIST
 984: LIST
 985: LIST
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PUSH
 997: LD_EXP 8
1001: PUSH
1002: LD_EXP 6
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: DIFF
1011: ST_TO_ADDR
// end ; end_of_file
1012: LD_VAR 0 1
1016: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
1017: LD_INT 0
1019: PPUSH
1020: PPUSH
1021: PPUSH
1022: PPUSH
1023: PPUSH
1024: PPUSH
// hc_class := clas ;
1025: LD_ADDR_OWVAR 28
1029: PUSH
1030: LD_VAR 0 1
1034: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
1035: LD_ADDR_VAR 0 4
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_INT 1
1047: NEG
1048: PPUSH
1049: LD_INT 1
1051: PPUSH
1052: CALL_OW 12
1056: PLUS
1057: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
1058: LD_ADDR_VAR 0 5
1062: PUSH
1063: LD_VAR 0 2
1067: PUSH
1068: LD_INT 1
1070: NEG
1071: PPUSH
1072: LD_INT 1
1074: PPUSH
1075: CALL_OW 12
1079: PLUS
1080: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
1081: LD_ADDR_VAR 0 6
1085: PUSH
1086: LD_VAR 0 2
1090: PUSH
1091: LD_INT 1
1093: NEG
1094: PPUSH
1095: LD_INT 1
1097: PPUSH
1098: CALL_OW 12
1102: PLUS
1103: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
1104: LD_ADDR_VAR 0 7
1108: PUSH
1109: LD_VAR 0 2
1113: PUSH
1114: LD_INT 1
1116: NEG
1117: PPUSH
1118: LD_INT 1
1120: PPUSH
1121: CALL_OW 12
1125: PLUS
1126: ST_TO_ADDR
// if clas = 1 or clas = 5 or clas = 8 or clas = 9 then
1127: LD_VAR 0 1
1131: PUSH
1132: LD_INT 1
1134: EQUAL
1135: PUSH
1136: LD_VAR 0 1
1140: PUSH
1141: LD_INT 5
1143: EQUAL
1144: OR
1145: PUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_INT 8
1153: EQUAL
1154: OR
1155: PUSH
1156: LD_VAR 0 1
1160: PUSH
1161: LD_INT 9
1163: EQUAL
1164: OR
1165: IFFALSE 1190
// bonus := [ 2 , 0 , 0 , 0 ] ;
1167: LD_ADDR_VAR 0 8
1171: PUSH
1172: LD_INT 2
1174: PUSH
1175: LD_INT 0
1177: PUSH
1178: LD_INT 0
1180: PUSH
1181: LD_INT 0
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: LIST
1188: LIST
1189: ST_TO_ADDR
// if clas = 2 then
1190: LD_VAR 0 1
1194: PUSH
1195: LD_INT 2
1197: EQUAL
1198: IFFALSE 1223
// bonus := [ 0 , 2 , 0 , 0 ] ;
1200: LD_ADDR_VAR 0 8
1204: PUSH
1205: LD_INT 0
1207: PUSH
1208: LD_INT 2
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 0
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: ST_TO_ADDR
// if clas = 3 then
1223: LD_VAR 0 1
1227: PUSH
1228: LD_INT 3
1230: EQUAL
1231: IFFALSE 1256
// bonus := [ 0 , 0 , 2 , 0 ] ;
1233: LD_ADDR_VAR 0 8
1237: PUSH
1238: LD_INT 0
1240: PUSH
1241: LD_INT 0
1243: PUSH
1244: LD_INT 2
1246: PUSH
1247: LD_INT 0
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: ST_TO_ADDR
// if clas = 4 then
1256: LD_VAR 0 1
1260: PUSH
1261: LD_INT 4
1263: EQUAL
1264: IFFALSE 1289
// bonus := [ 0 , 0 , 0 , 2 ] ;
1266: LD_ADDR_VAR 0 8
1270: PUSH
1271: LD_INT 0
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: ST_TO_ADDR
// if clas > 4 and not clas = 5 and not clas = 8 and not clas = 9 then
1289: LD_VAR 0 1
1293: PUSH
1294: LD_INT 4
1296: GREATER
1297: PUSH
1298: LD_VAR 0 1
1302: PUSH
1303: LD_INT 5
1305: EQUAL
1306: NOT
1307: AND
1308: PUSH
1309: LD_VAR 0 1
1313: PUSH
1314: LD_INT 8
1316: EQUAL
1317: NOT
1318: AND
1319: PUSH
1320: LD_VAR 0 1
1324: PUSH
1325: LD_INT 9
1327: EQUAL
1328: NOT
1329: AND
1330: IFFALSE 1355
// bonus := [ 0 , 0 , 0 , 0 ] ;
1332: LD_ADDR_VAR 0 8
1336: PUSH
1337: LD_INT 0
1339: PUSH
1340: LD_INT 0
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 0
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
1355: LD_ADDR_OWVAR 30
1359: PUSH
1360: LD_INT 0
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: CALL_OW 12
1370: PUSH
1371: LD_INT 0
1373: PPUSH
1374: LD_INT 2
1376: PPUSH
1377: CALL_OW 12
1381: PUSH
1382: LD_INT 0
1384: PPUSH
1385: LD_INT 2
1387: PPUSH
1388: CALL_OW 12
1392: PUSH
1393: LD_INT 0
1395: PPUSH
1396: LD_INT 2
1398: PPUSH
1399: CALL_OW 12
1403: PUSH
1404: EMPTY
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
1410: LD_ADDR_OWVAR 31
1414: PUSH
1415: LD_VAR 0 4
1419: PUSH
1420: LD_VAR 0 8
1424: PUSH
1425: LD_INT 1
1427: ARRAY
1428: PLUS
1429: PUSH
1430: LD_VAR 0 5
1434: PUSH
1435: LD_VAR 0 8
1439: PUSH
1440: LD_INT 2
1442: ARRAY
1443: PLUS
1444: PUSH
1445: LD_VAR 0 6
1449: PUSH
1450: LD_VAR 0 8
1454: PUSH
1455: LD_INT 3
1457: ARRAY
1458: PLUS
1459: PUSH
1460: LD_VAR 0 7
1464: PUSH
1465: LD_VAR 0 8
1469: PUSH
1470: LD_INT 4
1472: ARRAY
1473: PLUS
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
1481: LD_ADDR_OWVAR 27
1485: PUSH
1486: LD_INT 1
1488: PPUSH
1489: LD_INT 2
1491: PPUSH
1492: CALL_OW 12
1496: ST_TO_ADDR
// hc_gallery :=  ;
1497: LD_ADDR_OWVAR 33
1501: PUSH
1502: LD_STRING 
1504: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
1505: LD_ADDR_OWVAR 29
1509: PUSH
1510: LD_INT 8
1512: PPUSH
1513: LD_INT 12
1515: PPUSH
1516: CALL_OW 12
1520: PUSH
1521: LD_INT 9
1523: PPUSH
1524: LD_INT 11
1526: PPUSH
1527: CALL_OW 12
1531: PUSH
1532: EMPTY
1533: LIST
1534: LIST
1535: ST_TO_ADDR
// hc_name :=  ;
1536: LD_ADDR_OWVAR 26
1540: PUSH
1541: LD_STRING 
1543: ST_TO_ADDR
// result := CreateHuman ;
1544: LD_ADDR_VAR 0 3
1548: PUSH
1549: CALL_OW 44
1553: ST_TO_ADDR
// end ;
1554: LD_VAR 0 3
1558: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
1559: LD_INT 0
1561: PPUSH
1562: PPUSH
1563: PPUSH
1564: PPUSH
1565: PPUSH
1566: PPUSH
// uc_nation = nation_nature ;
1567: LD_ADDR_OWVAR 21
1571: PUSH
1572: LD_INT 0
1574: ST_TO_ADDR
// uc_side = 0 ;
1575: LD_ADDR_OWVAR 20
1579: PUSH
1580: LD_INT 0
1582: ST_TO_ADDR
// l = 0 ;
1583: LD_ADDR_VAR 0 7
1587: PUSH
1588: LD_INT 0
1590: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
1591: LD_ADDR_OWVAR 24
1595: PUSH
1596: LD_INT 0
1598: PPUSH
1599: LD_INT 5
1601: PPUSH
1602: CALL_OW 12
1606: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
1607: LD_ADDR_OWVAR 35
1611: PUSH
1612: LD_INT 5
1614: NEG
1615: PPUSH
1616: LD_INT 0
1618: PPUSH
1619: CALL_OW 12
1623: ST_TO_ADDR
// hc_gallery =  ;
1624: LD_ADDR_OWVAR 33
1628: PUSH
1629: LD_STRING 
1631: ST_TO_ADDR
// hc_class = class_apeman ;
1632: LD_ADDR_OWVAR 28
1636: PUSH
1637: LD_INT 12
1639: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
1640: LD_ADDR_OWVAR 29
1644: PUSH
1645: LD_INT 11
1647: PPUSH
1648: LD_INT 13
1650: PPUSH
1651: CALL_OW 12
1655: PUSH
1656: LD_INT 10
1658: PPUSH
1659: LD_INT 11
1661: PPUSH
1662: CALL_OW 12
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: ST_TO_ADDR
// hc_sex = sex_male ;
1671: LD_ADDR_OWVAR 27
1675: PUSH
1676: LD_INT 1
1678: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
1679: LD_ADDR_OWVAR 31
1683: PUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_INT 2
1689: PPUSH
1690: CALL_OW 12
1694: PUSH
1695: LD_INT 0
1697: PUSH
1698: LD_INT 0
1700: PUSH
1701: LD_INT 0
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// apeman = CreateHuman ;
1710: LD_ADDR_VAR 0 8
1714: PUSH
1715: CALL_OW 44
1719: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
1720: LD_VAR 0 8
1724: PPUSH
1725: LD_VAR 0 1
1729: PPUSH
1730: LD_INT 0
1732: PPUSH
1733: CALL_OW 49
// l = l + 1 ;
1737: LD_ADDR_VAR 0 7
1741: PUSH
1742: LD_VAR 0 7
1746: PUSH
1747: LD_INT 1
1749: PLUS
1750: ST_TO_ADDR
// end until l = num1 ;
1751: LD_VAR 0 7
1755: PUSH
1756: LD_VAR 0 2
1760: EQUAL
1761: IFFALSE 1591
// l = 0 ;
1763: LD_ADDR_VAR 0 7
1767: PUSH
1768: LD_INT 0
1770: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
1771: LD_ADDR_OWVAR 35
1775: PUSH
1776: LD_INT 0
1778: PPUSH
1779: LD_INT 25
1781: PPUSH
1782: CALL_OW 12
1786: ST_TO_ADDR
// hc_class = class_tiger ;
1787: LD_ADDR_OWVAR 28
1791: PUSH
1792: LD_INT 14
1794: ST_TO_ADDR
// hc_sex = sex_male ;
1795: LD_ADDR_OWVAR 27
1799: PUSH
1800: LD_INT 1
1802: ST_TO_ADDR
// hc_gallery = sandnature ;
1803: LD_ADDR_OWVAR 33
1807: PUSH
1808: LD_STRING sandnature
1810: ST_TO_ADDR
// hc_face_number = 3 ;
1811: LD_ADDR_OWVAR 34
1815: PUSH
1816: LD_INT 3
1818: ST_TO_ADDR
// tiger = CreateHuman ;
1819: LD_ADDR_VAR 0 9
1823: PUSH
1824: CALL_OW 44
1828: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
1829: LD_VAR 0 9
1833: PPUSH
1834: LD_VAR 0 1
1838: PPUSH
1839: LD_INT 0
1841: PPUSH
1842: CALL_OW 49
// l = l + 1 ;
1846: LD_ADDR_VAR 0 7
1850: PUSH
1851: LD_VAR 0 7
1855: PUSH
1856: LD_INT 1
1858: PLUS
1859: ST_TO_ADDR
// end until l = num2 ;
1860: LD_VAR 0 7
1864: PUSH
1865: LD_VAR 0 3
1869: EQUAL
1870: IFFALSE 1771
// l = 0 ;
1872: LD_ADDR_VAR 0 7
1876: PUSH
1877: LD_INT 0
1879: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
1880: LD_ADDR_OWVAR 28
1884: PUSH
1885: LD_INT 18
1887: ST_TO_ADDR
// hc_gallery = sandnature ;
1888: LD_ADDR_OWVAR 33
1892: PUSH
1893: LD_STRING sandnature
1895: ST_TO_ADDR
// hc_face_number = 1 ;
1896: LD_ADDR_OWVAR 34
1900: PUSH
1901: LD_INT 1
1903: ST_TO_ADDR
// bird = CreateHuman ;
1904: LD_ADDR_VAR 0 10
1908: PUSH
1909: CALL_OW 44
1913: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
1914: LD_VAR 0 10
1918: PPUSH
1919: LD_INT 0
1921: PPUSH
1922: CALL_OW 51
// l = l + 1 ;
1926: LD_ADDR_VAR 0 7
1930: PUSH
1931: LD_VAR 0 7
1935: PUSH
1936: LD_INT 1
1938: PLUS
1939: ST_TO_ADDR
// end until l = num3 ;
1940: LD_VAR 0 7
1944: PUSH
1945: LD_VAR 0 4
1949: EQUAL
1950: IFFALSE 1880
// l = 0 ;
1952: LD_ADDR_VAR 0 7
1956: PUSH
1957: LD_INT 0
1959: ST_TO_ADDR
// repeat begin hc_class = 21 ;
1960: LD_ADDR_OWVAR 28
1964: PUSH
1965: LD_INT 21
1967: ST_TO_ADDR
// hc_gallery = sandnature ;
1968: LD_ADDR_OWVAR 33
1972: PUSH
1973: LD_STRING sandnature
1975: ST_TO_ADDR
// hc_face_number = 5 ;
1976: LD_ADDR_OWVAR 34
1980: PUSH
1981: LD_INT 5
1983: ST_TO_ADDR
// horse := CreateHuman ;
1984: LD_ADDR_VAR 0 11
1988: PUSH
1989: CALL_OW 44
1993: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
1994: LD_VAR 0 11
1998: PPUSH
1999: LD_VAR 0 1
2003: PPUSH
2004: LD_INT 0
2006: PPUSH
2007: CALL_OW 49
// l = l + 1 ;
2011: LD_ADDR_VAR 0 7
2015: PUSH
2016: LD_VAR 0 7
2020: PUSH
2021: LD_INT 1
2023: PLUS
2024: ST_TO_ADDR
// end until l = num4 ;
2025: LD_VAR 0 7
2029: PUSH
2030: LD_VAR 0 5
2034: EQUAL
2035: IFFALSE 1960
// end ;
2037: LD_VAR 0 6
2041: RET
// export function PlaceWeaponOnTowers ( base , list ) ; var i , filter ; begin
2042: LD_INT 0
2044: PPUSH
2045: PPUSH
2046: PPUSH
// filter := FilterAllUnits ( [ [ [ f_side , GetSide ( base ) ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ] ) ;
2047: LD_ADDR_VAR 0 5
2051: PUSH
2052: LD_INT 22
2054: PUSH
2055: LD_VAR 0 1
2059: PPUSH
2060: CALL_OW 255
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: PUSH
2069: LD_INT 2
2071: PUSH
2072: LD_INT 30
2074: PUSH
2075: LD_INT 32
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PUSH
2082: LD_INT 30
2084: PUSH
2085: LD_INT 33
2087: PUSH
2088: EMPTY
2089: LIST
2090: LIST
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: PUSH
2097: EMPTY
2098: LIST
2099: LIST
2100: PUSH
2101: EMPTY
2102: LIST
2103: PPUSH
2104: CALL_OW 69
2108: ST_TO_ADDR
// if filter > 0 then
2109: LD_VAR 0 5
2113: PUSH
2114: LD_INT 0
2116: GREATER
2117: IFFALSE 2226
// begin for i = 1 to filter do
2119: LD_ADDR_VAR 0 4
2123: PUSH
2124: DOUBLE
2125: LD_INT 1
2127: DEC
2128: ST_TO_ADDR
2129: LD_VAR 0 5
2133: PUSH
2134: FOR_TO
2135: IFFALSE 2222
// if GetBase ( base ) = GetBase ( filter [ i ] ) and GetBWeapon ( filter [ i ] ) = 0 then
2137: LD_VAR 0 1
2141: PPUSH
2142: CALL_OW 274
2146: PUSH
2147: LD_VAR 0 5
2151: PUSH
2152: LD_VAR 0 4
2156: ARRAY
2157: PPUSH
2158: CALL_OW 274
2162: EQUAL
2163: PUSH
2164: LD_VAR 0 5
2168: PUSH
2169: LD_VAR 0 4
2173: ARRAY
2174: PPUSH
2175: CALL_OW 269
2179: PUSH
2180: LD_INT 0
2182: EQUAL
2183: AND
2184: IFFALSE 2220
// PlaceWeaponTurret ( filter [ i ] , list [ Rand ( 1 , list ) ] ) ;
2186: LD_VAR 0 5
2190: PUSH
2191: LD_VAR 0 4
2195: ARRAY
2196: PPUSH
2197: LD_VAR 0 2
2201: PUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_VAR 0 2
2209: PPUSH
2210: CALL_OW 12
2214: ARRAY
2215: PPUSH
2216: CALL_OW 431
2220: GO 2134
2222: POP
2223: POP
// end else
2224: GO 2234
// result := false ;
2226: LD_ADDR_VAR 0 3
2230: PUSH
2231: LD_INT 0
2233: ST_TO_ADDR
// end ;
2234: LD_VAR 0 3
2238: RET
// export function RandX ( min_val , max_val , x ) ; var i ; begin
2239: LD_INT 0
2241: PPUSH
2242: PPUSH
// for i = 1 to x do
2243: LD_ADDR_VAR 0 5
2247: PUSH
2248: DOUBLE
2249: LD_INT 1
2251: DEC
2252: ST_TO_ADDR
2253: LD_VAR 0 3
2257: PUSH
2258: FOR_TO
2259: IFFALSE 2283
// result := Rand ( min_val , max_val ) ;
2261: LD_ADDR_VAR 0 4
2265: PUSH
2266: LD_VAR 0 1
2270: PPUSH
2271: LD_VAR 0 2
2275: PPUSH
2276: CALL_OW 12
2280: ST_TO_ADDR
2281: GO 2258
2283: POP
2284: POP
// end ;
2285: LD_VAR 0 4
2289: RET
// export function IsDriver ( un ) ; begin
2290: LD_INT 0
2292: PPUSH
// if un in FilterAllUnits ( [ f_driving ] ) then
2293: LD_VAR 0 1
2297: PUSH
2298: LD_INT 55
2300: PUSH
2301: EMPTY
2302: LIST
2303: PPUSH
2304: CALL_OW 69
2308: IN
2309: IFFALSE 2321
// result := true else
2311: LD_ADDR_VAR 0 2
2315: PUSH
2316: LD_INT 1
2318: ST_TO_ADDR
2319: GO 2329
// result := false ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_INT 0
2328: ST_TO_ADDR
// end ;
2329: LD_VAR 0 2
2333: RET
// export function SayMen ; var filter ; begin
2334: LD_INT 0
2336: PPUSH
2337: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_sex , sex_male ] ] ) diff Louis ;
2338: LD_ADDR_VAR 0 2
2342: PUSH
2343: LD_INT 22
2345: PUSH
2346: LD_INT 2
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 26
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: EMPTY
2360: LIST
2361: LIST
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: PPUSH
2367: CALL_OW 69
2371: PUSH
2372: LD_EXP 1
2376: DIFF
2377: ST_TO_ADDR
// result := filter [ 1 ] ;
2378: LD_ADDR_VAR 0 1
2382: PUSH
2383: LD_VAR 0 2
2387: PUSH
2388: LD_INT 1
2390: ARRAY
2391: ST_TO_ADDR
// end ;
2392: LD_VAR 0 1
2396: RET
// export function SaySci ; var filter ; begin
2397: LD_INT 0
2399: PPUSH
2400: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Louis ;
2401: LD_ADDR_VAR 0 2
2405: PUSH
2406: LD_INT 22
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 25
2418: PUSH
2419: LD_INT 4
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PPUSH
2430: CALL_OW 69
2434: PUSH
2435: LD_EXP 1
2439: DIFF
2440: ST_TO_ADDR
// result := filter [ 1 ] ;
2441: LD_ADDR_VAR 0 1
2445: PUSH
2446: LD_VAR 0 2
2450: PUSH
2451: LD_INT 1
2453: ARRAY
2454: ST_TO_ADDR
// end ; end_of_file
2455: LD_VAR 0 1
2459: RET
// export rupatrol , ruforce , rskill , rvehlist , rbullist , r2vehlist , r2bullist ; export ruamo , ru_sforce , ru_angry , Gladkov , Platonov , CanUseBazooka , main_sci_dead , dont_attack ; export function PrepareRussian ; var i , p , un , towers , filter , list ; begin
2460: LD_INT 0
2462: PPUSH
2463: PPUSH
2464: PPUSH
2465: PPUSH
2466: PPUSH
2467: PPUSH
2468: PPUSH
// uc_side := 3 ;
2469: LD_ADDR_OWVAR 20
2473: PUSH
2474: LD_INT 3
2476: ST_TO_ADDR
// uc_nation := 3 ;
2477: LD_ADDR_OWVAR 21
2481: PUSH
2482: LD_INT 3
2484: ST_TO_ADDR
// CanUseBazooka = false ;
2485: LD_ADDR_EXP 23
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// main_sci_dead = false ;
2493: LD_ADDR_EXP 24
2497: PUSH
2498: LD_INT 0
2500: ST_TO_ADDR
// dont_attack = false ;
2501: LD_ADDR_EXP 25
2505: PUSH
2506: LD_INT 0
2508: ST_TO_ADDR
// rskill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2509: LD_ADDR_EXP 13
2513: PUSH
2514: LD_INT 5
2516: PUSH
2517: LD_INT 6
2519: PUSH
2520: LD_INT 7
2522: PUSH
2523: EMPTY
2524: LIST
2525: LIST
2526: LIST
2527: PUSH
2528: LD_OWVAR 67
2532: ARRAY
2533: ST_TO_ADDR
// rupatrol := [ ] ;
2534: LD_ADDR_EXP 11
2538: PUSH
2539: EMPTY
2540: ST_TO_ADDR
// ruforce := [ ] ;
2541: LD_ADDR_EXP 12
2545: PUSH
2546: EMPTY
2547: ST_TO_ADDR
// ru_sforce := [ ] ;
2548: LD_ADDR_EXP 19
2552: PUSH
2553: EMPTY
2554: ST_TO_ADDR
// rvehlist := [ ] ;
2555: LD_ADDR_EXP 14
2559: PUSH
2560: EMPTY
2561: ST_TO_ADDR
// rbullist := [ ] ;
2562: LD_ADDR_EXP 15
2566: PUSH
2567: EMPTY
2568: ST_TO_ADDR
// r2vehlist := [ ] ;
2569: LD_ADDR_EXP 16
2573: PUSH
2574: EMPTY
2575: ST_TO_ADDR
// r2bullist := [ ] ;
2576: LD_ADDR_EXP 17
2580: PUSH
2581: EMPTY
2582: ST_TO_ADDR
// ru_angry := [ 0 , 0 , 49 ] [ Difficulty ] ;
2583: LD_ADDR_EXP 20
2587: PUSH
2588: LD_INT 0
2590: PUSH
2591: LD_INT 0
2593: PUSH
2594: LD_INT 49
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: LIST
2601: PUSH
2602: LD_OWVAR 67
2606: ARRAY
2607: ST_TO_ADDR
// ruamo := [ 3 , 4 , 5 ] [ Difficulty ] ;
2608: LD_ADDR_EXP 18
2612: PUSH
2613: LD_INT 3
2615: PUSH
2616: LD_INT 4
2618: PUSH
2619: LD_INT 5
2621: PUSH
2622: EMPTY
2623: LIST
2624: LIST
2625: LIST
2626: PUSH
2627: LD_OWVAR 67
2631: ARRAY
2632: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
2633: LD_INT 3
2635: PPUSH
2636: LD_INT 6
2638: PPUSH
2639: CALL_OW 343
// Gladkov := NewCharacter ( Gladkov ) ;
2643: LD_ADDR_EXP 21
2647: PUSH
2648: LD_STRING Gladkov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// PlaceHumanInUnit ( Gladkov , ru_depot2 ) ;
2656: LD_EXP 21
2660: PPUSH
2661: LD_INT 51
2663: PPUSH
2664: CALL_OW 52
// Platonov := NewCharacter ( Platonov ) ;
2668: LD_ADDR_EXP 22
2672: PUSH
2673: LD_STRING Platonov
2675: PPUSH
2676: CALL_OW 25
2680: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2681: LD_ADDR_VAR 0 2
2685: PUSH
2686: DOUBLE
2687: LD_INT 1
2689: DEC
2690: ST_TO_ADDR
2691: LD_INT 4
2693: PUSH
2694: LD_INT 5
2696: PUSH
2697: LD_INT 6
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: LIST
2704: PUSH
2705: LD_OWVAR 67
2709: ARRAY
2710: PUSH
2711: FOR_TO
2712: IFFALSE 2795
// begin if i < 4 then
2714: LD_VAR 0 2
2718: PUSH
2719: LD_INT 4
2721: LESS
2722: IFFALSE 2744
// un := CreateHumanWithClass ( 1 , rskill ) else
2724: LD_ADDR_VAR 0 4
2728: PUSH
2729: LD_INT 1
2731: PPUSH
2732: LD_EXP 13
2736: PPUSH
2737: CALL 1017 0 2
2741: ST_TO_ADDR
2742: GO 2762
// un := CreateHumanWithClass ( 9 , rskill ) ;
2744: LD_ADDR_VAR 0 4
2748: PUSH
2749: LD_INT 9
2751: PPUSH
2752: LD_EXP 13
2756: PPUSH
2757: CALL 1017 0 2
2761: ST_TO_ADDR
// ruforce := ruforce ^ un ;
2762: LD_ADDR_EXP 12
2766: PUSH
2767: LD_EXP 12
2771: PUSH
2772: LD_VAR 0 4
2776: ADD
2777: ST_TO_ADDR
// PlaceUnitArea ( un , forest_spawn , false ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 12
2785: PPUSH
2786: LD_INT 0
2788: PPUSH
2789: CALL_OW 49
// end ;
2793: GO 2711
2795: POP
2796: POP
// for i = 1 to 2 do
2797: LD_ADDR_VAR 0 2
2801: PUSH
2802: DOUBLE
2803: LD_INT 1
2805: DEC
2806: ST_TO_ADDR
2807: LD_INT 2
2809: PUSH
2810: FOR_TO
2811: IFFALSE 2908
// begin vc_chassis := ru_medium_tracked ;
2813: LD_ADDR_OWVAR 37
2817: PUSH
2818: LD_INT 22
2820: ST_TO_ADDR
// vc_engine := engine_combustion ;
2821: LD_ADDR_OWVAR 39
2825: PUSH
2826: LD_INT 1
2828: ST_TO_ADDR
// vc_control := control_computer ;
2829: LD_ADDR_OWVAR 38
2833: PUSH
2834: LD_INT 3
2836: ST_TO_ADDR
// if i = 2 then
2837: LD_VAR 0 2
2841: PUSH
2842: LD_INT 2
2844: EQUAL
2845: IFFALSE 2857
// vc_weapon := ru_gun else
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 44
2854: ST_TO_ADDR
2855: GO 2865
// vc_weapon := ru_gatling_gun ;
2857: LD_ADDR_OWVAR 40
2861: PUSH
2862: LD_INT 43
2864: ST_TO_ADDR
// un := CreateVehicle ;
2865: LD_ADDR_VAR 0 4
2869: PUSH
2870: CALL_OW 45
2874: ST_TO_ADDR
// rupatrol := rupatrol ^ un ;
2875: LD_ADDR_EXP 11
2879: PUSH
2880: LD_EXP 11
2884: PUSH
2885: LD_VAR 0 4
2889: ADD
2890: ST_TO_ADDR
// PlaceUnitArea ( un , ru_patrol , false ) ;
2891: LD_VAR 0 4
2895: PPUSH
2896: LD_INT 13
2898: PPUSH
2899: LD_INT 0
2901: PPUSH
2902: CALL_OW 49
// end ;
2906: GO 2810
2908: POP
2909: POP
// towers := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] , [ f_empty ] ] ) ;
2910: LD_ADDR_VAR 0 5
2914: PUSH
2915: LD_INT 22
2917: PUSH
2918: LD_INT 3
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: PUSH
2925: LD_INT 2
2927: PUSH
2928: LD_INT 30
2930: PUSH
2931: LD_INT 32
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 30
2940: PUSH
2941: LD_INT 33
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: LIST
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: PUSH
2957: LD_INT 58
2959: PUSH
2960: EMPTY
2961: LIST
2962: PUSH
2963: EMPTY
2964: LIST
2965: LIST
2966: PPUSH
2967: CALL_OW 69
2971: ST_TO_ADDR
// for i = 1 to towers do
2972: LD_ADDR_VAR 0 2
2976: PUSH
2977: DOUBLE
2978: LD_INT 1
2980: DEC
2981: ST_TO_ADDR
2982: LD_VAR 0 5
2986: PUSH
2987: FOR_TO
2988: IFFALSE 3020
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , rskill ) , towers [ i ] ) ;
2990: LD_INT 1
2992: PPUSH
2993: LD_EXP 13
2997: PPUSH
2998: CALL 1017 0 2
3002: PPUSH
3003: LD_VAR 0 5
3007: PUSH
3008: LD_VAR 0 2
3012: ARRAY
3013: PPUSH
3014: CALL_OW 52
3018: GO 2987
3020: POP
3021: POP
// for i = 1 to 3 do
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: DOUBLE
3028: LD_INT 1
3030: DEC
3031: ST_TO_ADDR
3032: LD_INT 3
3034: PUSH
3035: FOR_TO
3036: IFFALSE 3080
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 4 , rskill ) , ru_lab1 ) ;
3038: LD_INT 4
3040: PPUSH
3041: LD_EXP 13
3045: PPUSH
3046: CALL 1017 0 2
3050: PPUSH
3051: LD_INT 53
3053: PPUSH
3054: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , rskill ) , ru_lab2 ) ;
3058: LD_INT 4
3060: PPUSH
3061: LD_EXP 13
3065: PPUSH
3066: CALL 1017 0 2
3070: PPUSH
3071: LD_INT 52
3073: PPUSH
3074: CALL_OW 52
// end ;
3078: GO 3035
3080: POP
3081: POP
// for i = 1 to 6 do
3082: LD_ADDR_VAR 0 2
3086: PUSH
3087: DOUBLE
3088: LD_INT 1
3090: DEC
3091: ST_TO_ADDR
3092: LD_INT 6
3094: PUSH
3095: FOR_TO
3096: IFFALSE 3120
// PlaceHumanInUnit ( CreateHumanWithClass ( 2 , rskill ) , ru_depot2 ) ;
3098: LD_INT 2
3100: PPUSH
3101: LD_EXP 13
3105: PPUSH
3106: CALL 1017 0 2
3110: PPUSH
3111: LD_INT 51
3113: PPUSH
3114: CALL_OW 52
3118: GO 3095
3120: POP
3121: POP
// for i = 1 to 6 do
3122: LD_ADDR_VAR 0 2
3126: PUSH
3127: DOUBLE
3128: LD_INT 1
3130: DEC
3131: ST_TO_ADDR
3132: LD_INT 6
3134: PUSH
3135: FOR_TO
3136: IFFALSE 3160
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , rskill ) , ru_fac ) ;
3138: LD_INT 3
3140: PPUSH
3141: LD_EXP 13
3145: PPUSH
3146: CALL 1017 0 2
3150: PPUSH
3151: LD_INT 71
3153: PPUSH
3154: CALL_OW 52
3158: GO 3135
3160: POP
3161: POP
// for p = 1 to 2 do
3162: LD_ADDR_VAR 0 3
3166: PUSH
3167: DOUBLE
3168: LD_INT 1
3170: DEC
3171: ST_TO_ADDR
3172: LD_INT 2
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3333
// for i = 1 to 6 do
3178: LD_ADDR_VAR 0 2
3182: PUSH
3183: DOUBLE
3184: LD_INT 1
3186: DEC
3187: ST_TO_ADDR
3188: LD_INT 6
3190: PUSH
3191: FOR_TO
3192: IFFALSE 3329
// if i < [ 3 , 4 , 5 ] [ Difficulty ] then
3194: LD_VAR 0 2
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: LD_INT 4
3204: PUSH
3205: LD_INT 5
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_OWVAR 67
3217: ARRAY
3218: LESS
3219: IFFALSE 3275
// PlaceHumanInUnit ( CreateHumanWithClass ( 9 , rskill ) , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ p ] ) else
3221: LD_INT 9
3223: PPUSH
3224: LD_EXP 13
3228: PPUSH
3229: CALL 1017 0 2
3233: PPUSH
3234: LD_INT 22
3236: PUSH
3237: LD_INT 3
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PUSH
3244: LD_INT 30
3246: PUSH
3247: LD_INT 5
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PPUSH
3258: CALL_OW 69
3262: PUSH
3263: LD_VAR 0 3
3267: ARRAY
3268: PPUSH
3269: CALL_OW 52
3273: GO 3327
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , rskill ) , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
3275: LD_INT 1
3277: PPUSH
3278: LD_EXP 13
3282: PPUSH
3283: CALL 1017 0 2
3287: PPUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 3
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 30
3300: PUSH
3301: LD_INT 5
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PPUSH
3312: CALL_OW 69
3316: PUSH
3317: LD_VAR 0 3
3321: ARRAY
3322: PPUSH
3323: CALL_OW 52
3327: GO 3191
3329: POP
3330: POP
3331: GO 3175
3333: POP
3334: POP
// uc_side := 6 ;
3335: LD_ADDR_OWVAR 20
3339: PUSH
3340: LD_INT 6
3342: ST_TO_ADDR
// for i = 1 to 3 do
3343: LD_ADDR_VAR 0 2
3347: PUSH
3348: DOUBLE
3349: LD_INT 1
3351: DEC
3352: ST_TO_ADDR
3353: LD_INT 3
3355: PUSH
3356: FOR_TO
3357: IFFALSE 3381
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , rskill ) , ru2_lab ) ;
3359: LD_INT 4
3361: PPUSH
3362: LD_EXP 13
3366: PPUSH
3367: CALL 1017 0 2
3371: PPUSH
3372: LD_INT 192
3374: PPUSH
3375: CALL_OW 52
3379: GO 3356
3381: POP
3382: POP
// for p = 1 to 4 do
3383: LD_ADDR_VAR 0 3
3387: PUSH
3388: DOUBLE
3389: LD_INT 1
3391: DEC
3392: ST_TO_ADDR
3393: LD_INT 4
3395: PUSH
3396: FOR_TO
3397: IFFALSE 3554
// for i = 1 to 6 do
3399: LD_ADDR_VAR 0 2
3403: PUSH
3404: DOUBLE
3405: LD_INT 1
3407: DEC
3408: ST_TO_ADDR
3409: LD_INT 6
3411: PUSH
3412: FOR_TO
3413: IFFALSE 3550
// if i < [ 3 , 4 , 5 ] [ Difficulty ] then
3415: LD_VAR 0 2
3419: PUSH
3420: LD_INT 3
3422: PUSH
3423: LD_INT 4
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: LD_OWVAR 67
3438: ARRAY
3439: LESS
3440: IFFALSE 3496
// PlaceHumanInUnit ( CreateHumanWithClass ( 9 , rskill ) , FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_barracks ] ] ) [ p ] ) else
3442: LD_INT 9
3444: PPUSH
3445: LD_EXP 13
3449: PPUSH
3450: CALL 1017 0 2
3454: PPUSH
3455: LD_INT 22
3457: PUSH
3458: LD_INT 6
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: LD_INT 30
3467: PUSH
3468: LD_INT 5
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: PPUSH
3479: CALL_OW 69
3483: PUSH
3484: LD_VAR 0 3
3488: ARRAY
3489: PPUSH
3490: CALL_OW 52
3494: GO 3548
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , rskill ) , FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_barracks ] ] ) [ p ] ) ;
3496: LD_INT 1
3498: PPUSH
3499: LD_EXP 13
3503: PPUSH
3504: CALL 1017 0 2
3508: PPUSH
3509: LD_INT 22
3511: PUSH
3512: LD_INT 6
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PUSH
3519: LD_INT 30
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 69
3537: PUSH
3538: LD_VAR 0 3
3542: ARRAY
3543: PPUSH
3544: CALL_OW 52
3548: GO 3412
3550: POP
3551: POP
3552: GO 3396
3554: POP
3555: POP
// for i = 1 to 6 do
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: DOUBLE
3562: LD_INT 1
3564: DEC
3565: ST_TO_ADDR
3566: LD_INT 6
3568: PUSH
3569: FOR_TO
3570: IFFALSE 3594
// PlaceHumanInUnit ( CreateHumanWithClass ( 2 , rskill ) , ru_depot1 ) ;
3572: LD_INT 2
3574: PPUSH
3575: LD_EXP 13
3579: PPUSH
3580: CALL 1017 0 2
3584: PPUSH
3585: LD_INT 123
3587: PPUSH
3588: CALL_OW 52
3592: GO 3569
3594: POP
3595: POP
// for i = 1 to 6 do
3596: LD_ADDR_VAR 0 2
3600: PUSH
3601: DOUBLE
3602: LD_INT 1
3604: DEC
3605: ST_TO_ADDR
3606: LD_INT 6
3608: PUSH
3609: FOR_TO
3610: IFFALSE 3634
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , rskill ) , ru_fac2 ) ;
3612: LD_INT 3
3614: PPUSH
3615: LD_EXP 13
3619: PPUSH
3620: CALL 1017 0 2
3624: PPUSH
3625: LD_INT 172
3627: PPUSH
3628: CALL_OW 52
3632: GO 3609
3634: POP
3635: POP
// towers := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] , [ f_empty ] ] ) ;
3636: LD_ADDR_VAR 0 5
3640: PUSH
3641: LD_INT 22
3643: PUSH
3644: LD_INT 6
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: LD_INT 2
3653: PUSH
3654: LD_INT 30
3656: PUSH
3657: LD_INT 32
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PUSH
3664: LD_INT 30
3666: PUSH
3667: LD_INT 33
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 58
3685: PUSH
3686: EMPTY
3687: LIST
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PPUSH
3693: CALL_OW 69
3697: ST_TO_ADDR
// for i = 1 to towers do
3698: LD_ADDR_VAR 0 2
3702: PUSH
3703: DOUBLE
3704: LD_INT 1
3706: DEC
3707: ST_TO_ADDR
3708: LD_VAR 0 5
3712: PUSH
3713: FOR_TO
3714: IFFALSE 3746
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , rskill ) , towers [ i ] ) ;
3716: LD_INT 1
3718: PPUSH
3719: LD_EXP 13
3723: PPUSH
3724: CALL 1017 0 2
3728: PPUSH
3729: LD_VAR 0 5
3733: PUSH
3734: LD_VAR 0 2
3738: ARRAY
3739: PPUSH
3740: CALL_OW 52
3744: GO 3713
3746: POP
3747: POP
// rbullist := [ b_oil_power , 84 , 141 , 2 ] ;
3748: LD_ADDR_EXP 15
3752: PUSH
3753: LD_INT 26
3755: PUSH
3756: LD_INT 84
3758: PUSH
3759: LD_INT 141
3761: PUSH
3762: LD_INT 2
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: ST_TO_ADDR
// if Difficulty > 1 then
3771: LD_OWVAR 67
3775: PUSH
3776: LD_INT 1
3778: GREATER
3779: IFFALSE 3821
// begin ComResearch ( ru_lab2 , tech_weap2 ) ;
3781: LD_INT 52
3783: PPUSH
3784: LD_INT 52
3786: PPUSH
3787: CALL_OW 124
// ComResearch ( ru_lab1 , tech_comp2 ) ;
3791: LD_INT 53
3793: PPUSH
3794: LD_INT 58
3796: PPUSH
3797: CALL_OW 124
// if Difficulty > 2 then
3801: LD_OWVAR 67
3805: PUSH
3806: LD_INT 2
3808: GREATER
3809: IFFALSE 3821
// AddComResearch ( ru_lab2 , tech_weap3 ) ;
3811: LD_INT 52
3813: PPUSH
3814: LD_INT 53
3816: PPUSH
3817: CALL_OW 184
// end ; end ;
3821: LD_VAR 0 1
3825: RET
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) > 0 do var i , p , un , list , list2 , list3 , dep , lab , fac , towers , crane , bar , eng , sol , mech , sci , filter , live , crane_parking , enemy , doc , hurts ;
3826: LD_INT 22
3828: PUSH
3829: LD_INT 3
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PPUSH
3836: CALL_OW 69
3840: PUSH
3841: LD_INT 0
3843: GREATER
3844: IFFALSE 6199
3846: GO 3848
3848: DISABLE
3849: LD_INT 0
3851: PPUSH
3852: PPUSH
3853: PPUSH
3854: PPUSH
3855: PPUSH
3856: PPUSH
3857: PPUSH
3858: PPUSH
3859: PPUSH
3860: PPUSH
3861: PPUSH
3862: PPUSH
3863: PPUSH
3864: PPUSH
3865: PPUSH
3866: PPUSH
3867: PPUSH
3868: PPUSH
3869: PPUSH
3870: PPUSH
3871: PPUSH
3872: PPUSH
// begin enable ;
3873: ENABLE
// live := 675 ;
3874: LD_ADDR_VAR 0 18
3878: PUSH
3879: LD_INT 675
3881: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
3882: LD_ADDR_VAR 0 7
3886: PUSH
3887: LD_INT 22
3889: PUSH
3890: LD_INT 3
3892: PUSH
3893: EMPTY
3894: LIST
3895: LIST
3896: PUSH
3897: LD_INT 30
3899: PUSH
3900: LD_INT 1
3902: PUSH
3903: EMPTY
3904: LIST
3905: LIST
3906: PUSH
3907: EMPTY
3908: LIST
3909: LIST
3910: PPUSH
3911: CALL_OW 69
3915: PUSH
3916: LD_INT 1
3918: ARRAY
3919: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
3920: LD_ADDR_VAR 0 9
3924: PUSH
3925: LD_INT 22
3927: PUSH
3928: LD_INT 3
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: PUSH
3935: LD_INT 30
3937: PUSH
3938: LD_INT 3
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PPUSH
3949: CALL_OW 69
3953: PUSH
3954: LD_INT 1
3956: ARRAY
3957: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
3958: LD_ADDR_VAR 0 8
3962: PUSH
3963: LD_INT 22
3965: PUSH
3966: LD_INT 3
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 2
3975: PUSH
3976: LD_INT 30
3978: PUSH
3979: LD_INT 6
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: LD_INT 30
3988: PUSH
3989: LD_INT 8
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PPUSH
4005: CALL_OW 69
4009: PUSH
4010: LD_INT 1
4012: ARRAY
4013: ST_TO_ADDR
// crane_parking := ru1_crane_parking ;
4014: LD_ADDR_VAR 0 19
4018: PUSH
4019: LD_INT 6
4021: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , live ] ] ] ) ;
4022: LD_ADDR_VAR 0 21
4026: PUSH
4027: LD_INT 22
4029: PUSH
4030: LD_INT 3
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 25
4039: PUSH
4040: LD_INT 4
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: PUSH
4047: LD_INT 24
4049: PUSH
4050: LD_VAR 0 18
4054: PUSH
4055: EMPTY
4056: LIST
4057: LIST
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: LIST
4063: PUSH
4064: EMPTY
4065: LIST
4066: PPUSH
4067: CALL_OW 69
4071: ST_TO_ADDR
// hurts := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , live ] ] ] ] ) diff UnitFilter ( ru_sforce , [ f_class , class_bazooker ] ) ;
4072: LD_ADDR_VAR 0 22
4076: PUSH
4077: LD_INT 22
4079: PUSH
4080: LD_INT 3
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 21
4089: PUSH
4090: LD_INT 1
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 3
4099: PUSH
4100: LD_INT 24
4102: PUSH
4103: LD_VAR 0 18
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: EMPTY
4122: LIST
4123: PPUSH
4124: CALL_OW 69
4128: PUSH
4129: LD_EXP 19
4133: PPUSH
4134: LD_INT 25
4136: PUSH
4137: LD_INT 9
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL_OW 72
4148: DIFF
4149: ST_TO_ADDR
// if hurts then
4150: LD_VAR 0 22
4154: IFFALSE 4553
// begin for i = 1 to hurts do
4156: LD_ADDR_VAR 0 1
4160: PUSH
4161: DOUBLE
4162: LD_INT 1
4164: DEC
4165: ST_TO_ADDR
4166: LD_VAR 0 22
4170: PUSH
4171: FOR_TO
4172: IFFALSE 4223
// if GetDistUnits ( hurts [ i ] , dep ) > 10 then
4174: LD_VAR 0 22
4178: PUSH
4179: LD_VAR 0 1
4183: ARRAY
4184: PPUSH
4185: LD_VAR 0 7
4189: PPUSH
4190: CALL_OW 296
4194: PUSH
4195: LD_INT 10
4197: GREATER
4198: IFFALSE 4221
// ComMoveXY ( hurts [ i ] , 89 , 137 ) ;
4200: LD_VAR 0 22
4204: PUSH
4205: LD_VAR 0 1
4209: ARRAY
4210: PPUSH
4211: LD_INT 89
4213: PPUSH
4214: LD_INT 137
4216: PPUSH
4217: CALL_OW 111
4221: GO 4171
4223: POP
4224: POP
// list := UnitFilter ( hurts , [ f_distxy , 93 , 137 , 20 ] ) ;
4225: LD_ADDR_VAR 0 4
4229: PUSH
4230: LD_VAR 0 22
4234: PPUSH
4235: LD_INT 92
4237: PUSH
4238: LD_INT 93
4240: PUSH
4241: LD_INT 137
4243: PUSH
4244: LD_INT 20
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: PPUSH
4253: CALL_OW 72
4257: ST_TO_ADDR
// if doc = 0 then
4258: LD_VAR 0 21
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: IFFALSE 4369
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] ] ] ) ;
4268: LD_ADDR_VAR 0 17
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 3
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 25
4285: PUSH
4286: LD_INT 3
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: PPUSH
4300: CALL_OW 69
4304: ST_TO_ADDR
// if IsInUnit ( filter [ 1 ] ) then
4305: LD_VAR 0 17
4309: PUSH
4310: LD_INT 1
4312: ARRAY
4313: PPUSH
4314: CALL_OW 310
4318: IFFALSE 4333
// ComExitBuilding ( filter [ 1 ] ) ;
4320: LD_VAR 0 17
4324: PUSH
4325: LD_INT 1
4327: ARRAY
4328: PPUSH
4329: CALL_OW 122
// ComEnterUnit ( filter [ 1 ] , lab ) ;
4333: LD_VAR 0 17
4337: PUSH
4338: LD_INT 1
4340: ARRAY
4341: PPUSH
4342: LD_VAR 0 8
4346: PPUSH
4347: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 4 ) ;
4351: LD_VAR 0 17
4355: PUSH
4356: LD_INT 1
4358: ARRAY
4359: PPUSH
4360: LD_INT 4
4362: PPUSH
4363: CALL_OW 183
// end else
4367: GO 4551
// if doc > 4 then
4369: LD_VAR 0 21
4373: PUSH
4374: LD_INT 4
4376: GREATER
4377: IFFALSE 4465
// begin for i = 1 to 4 do
4379: LD_ADDR_VAR 0 1
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 4
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4461
// if IsInUnit ( doc [ i ] ) then
4395: LD_VAR 0 21
4399: PUSH
4400: LD_VAR 0 1
4404: ARRAY
4405: PPUSH
4406: CALL_OW 310
4410: IFFALSE 4429
// ComExitBuilding ( doc [ i ] ) else
4412: LD_VAR 0 21
4416: PUSH
4417: LD_VAR 0 1
4421: ARRAY
4422: PPUSH
4423: CALL_OW 122
4427: GO 4459
// if list then
4429: LD_VAR 0 4
4433: IFFALSE 4459
// ComHeal ( doc [ i ] , list [ 1 ] ) ;
4435: LD_VAR 0 21
4439: PUSH
4440: LD_VAR 0 1
4444: ARRAY
4445: PPUSH
4446: LD_VAR 0 4
4450: PUSH
4451: LD_INT 1
4453: ARRAY
4454: PPUSH
4455: CALL_OW 128
4459: GO 4392
4461: POP
4462: POP
// end else
4463: GO 4551
// begin for i = 1 to doc do
4465: LD_ADDR_VAR 0 1
4469: PUSH
4470: DOUBLE
4471: LD_INT 1
4473: DEC
4474: ST_TO_ADDR
4475: LD_VAR 0 21
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4549
// if IsInUnit ( doc [ i ] ) then
4483: LD_VAR 0 21
4487: PUSH
4488: LD_VAR 0 1
4492: ARRAY
4493: PPUSH
4494: CALL_OW 310
4498: IFFALSE 4517
// ComExitBuilding ( doc [ i ] ) else
4500: LD_VAR 0 21
4504: PUSH
4505: LD_VAR 0 1
4509: ARRAY
4510: PPUSH
4511: CALL_OW 122
4515: GO 4547
// if list then
4517: LD_VAR 0 4
4521: IFFALSE 4547
// ComHeal ( doc [ i ] , list [ 1 ] ) ;
4523: LD_VAR 0 21
4527: PUSH
4528: LD_VAR 0 1
4532: ARRAY
4533: PPUSH
4534: LD_VAR 0 4
4538: PUSH
4539: LD_INT 1
4541: ARRAY
4542: PPUSH
4543: CALL_OW 128
4547: GO 4480
4549: POP
4550: POP
// end ; end else
4551: GO 4645
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_outside ] ] ] ) ;
4553: LD_ADDR_VAR 0 17
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 3
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 25
4570: PUSH
4571: LD_INT 4
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PUSH
4578: LD_INT 56
4580: PUSH
4581: EMPTY
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: LIST
4588: PUSH
4589: EMPTY
4590: LIST
4591: PPUSH
4592: CALL_OW 69
4596: ST_TO_ADDR
// if filter then
4597: LD_VAR 0 17
4601: IFFALSE 4645
// for i = 1 to filter do
4603: LD_ADDR_VAR 0 1
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_VAR 0 17
4617: PUSH
4618: FOR_TO
4619: IFFALSE 4643
// ComEnterUnit ( filter [ i ] , lab ) ;
4621: LD_VAR 0 17
4625: PUSH
4626: LD_VAR 0 1
4630: ARRAY
4631: PPUSH
4632: LD_VAR 0 8
4636: PPUSH
4637: CALL_OW 120
4641: GO 4618
4643: POP
4644: POP
// end ; list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , class_bazooker ] ] ) ;
4645: LD_ADDR_VAR 0 4
4649: PUSH
4650: LD_INT 22
4652: PUSH
4653: LD_INT 3
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: PUSH
4660: LD_INT 25
4662: PUSH
4663: LD_INT 9
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: PPUSH
4674: CALL_OW 69
4678: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4679: LD_ADDR_VAR 0 17
4683: PUSH
4684: LD_INT 22
4686: PUSH
4687: LD_INT 2
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: LD_INT 3
4696: PUSH
4697: LD_INT 21
4699: PUSH
4700: LD_INT 3
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: EMPTY
4712: LIST
4713: LIST
4714: PPUSH
4715: CALL_OW 69
4719: ST_TO_ADDR
// if CanUseBazooka then
4720: LD_EXP 23
4724: IFFALSE 4740
// IntBazooka ( list , filter ) ;
4726: LD_VAR 0 4
4730: PPUSH
4731: LD_VAR 0 17
4735: PPUSH
4736: CALL 10231 0 2
// if BuildingStatus ( fac ) = bs_idle then
4740: LD_VAR 0 9
4744: PPUSH
4745: CALL_OW 461
4749: PUSH
4750: LD_INT 2
4752: EQUAL
4753: IFFALSE 5053
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) = 0 then
4755: LD_INT 22
4757: PUSH
4758: LD_INT 3
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: PUSH
4765: LD_INT 34
4767: PUSH
4768: LD_INT 52
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PUSH
4784: LD_INT 0
4786: EQUAL
4787: IFFALSE 4798
// ProduceCrane ( fac ) ;
4789: LD_VAR 0 9
4793: PPUSH
4794: CALL 9357 0 1
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
4798: LD_INT 22
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 34
4810: PUSH
4811: LD_INT 51
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: PUSH
4827: LD_INT 0
4829: EQUAL
4830: IFFALSE 4841
// ProduceCargoBay ( fac ) ;
4832: LD_VAR 0 9
4836: PPUSH
4837: CALL 9470 0 1
// if rvehlist >= 4 then
4841: LD_EXP 14
4845: PUSH
4846: LD_INT 4
4848: GREATEREQUAL
4849: IFFALSE 4896
// ComConstruct ( fac , rvehlist [ 1 ] , rvehlist [ 2 ] , rvehlist [ 3 ] , rvehlist [ 4 ] ) ;
4851: LD_VAR 0 9
4855: PPUSH
4856: LD_EXP 14
4860: PUSH
4861: LD_INT 1
4863: ARRAY
4864: PPUSH
4865: LD_EXP 14
4869: PUSH
4870: LD_INT 2
4872: ARRAY
4873: PPUSH
4874: LD_EXP 14
4878: PUSH
4879: LD_INT 3
4881: ARRAY
4882: PPUSH
4883: LD_EXP 14
4887: PUSH
4888: LD_INT 4
4890: ARRAY
4891: PPUSH
4892: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_bweapon , 0 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) then
4896: LD_INT 22
4898: PUSH
4899: LD_INT 3
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: LD_INT 35
4908: PUSH
4909: LD_INT 0
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: PUSH
4916: LD_INT 2
4918: PUSH
4919: LD_INT 30
4921: PUSH
4922: LD_INT 32
4924: PUSH
4925: EMPTY
4926: LIST
4927: LIST
4928: PUSH
4929: LD_INT 30
4931: PUSH
4932: LD_INT 33
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: LIST
4948: PPUSH
4949: CALL_OW 69
4953: IFFALSE 5053
// begin towers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_bweapon , 0 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
4955: LD_ADDR_VAR 0 10
4959: PUSH
4960: LD_INT 22
4962: PUSH
4963: LD_INT 3
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PUSH
4970: LD_INT 35
4972: PUSH
4973: LD_INT 0
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 2
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 32
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 30
4995: PUSH
4996: LD_INT 33
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: ST_TO_ADDR
// ComPlaceWeapon ( towers [ 1 ] , [ ru_heavy_gun , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
5018: LD_VAR 0 10
5022: PUSH
5023: LD_INT 1
5025: ARRAY
5026: PPUSH
5027: LD_INT 46
5029: PUSH
5030: LD_INT 45
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 1
5039: PPUSH
5040: LD_INT 2
5042: PPUSH
5043: CALL_OW 12
5047: ARRAY
5048: PPUSH
5049: CALL_OW 148
// end ; end ; sol := FilterAllUnits ( [ [ f_side , 3 ] , [ f_outside ] , [ f_or , [ f_class , 1 ] , [ f_class , 9 ] ] ] ) diff ruforce ;
5053: LD_ADDR_VAR 0 14
5057: PUSH
5058: LD_INT 22
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 56
5070: PUSH
5071: EMPTY
5072: LIST
5073: PUSH
5074: LD_INT 2
5076: PUSH
5077: LD_INT 25
5079: PUSH
5080: LD_INT 1
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 25
5089: PUSH
5090: LD_INT 9
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: LIST
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 69
5111: PUSH
5112: LD_EXP 12
5116: DIFF
5117: ST_TO_ADDR
// if sol then
5118: LD_VAR 0 14
5122: IFFALSE 5315
// begin list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) ;
5124: LD_ADDR_VAR 0 4
5128: PUSH
5129: LD_INT 22
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PUSH
5139: LD_INT 30
5141: PUSH
5142: LD_INT 5
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PPUSH
5153: CALL_OW 69
5157: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ] ) ;
5158: LD_ADDR_VAR 0 10
5162: PUSH
5163: LD_INT 22
5165: PUSH
5166: LD_INT 3
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 58
5175: PUSH
5176: EMPTY
5177: LIST
5178: PUSH
5179: LD_INT 30
5181: PUSH
5182: LD_INT 32
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: EMPTY
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: ST_TO_ADDR
// if towers then
5202: LD_VAR 0 10
5206: IFFALSE 5232
// ComEnterUnit ( sol [ 1 ] , towers [ 1 ] ) else
5208: LD_VAR 0 14
5212: PUSH
5213: LD_INT 1
5215: ARRAY
5216: PPUSH
5217: LD_VAR 0 10
5221: PUSH
5222: LD_INT 1
5224: ARRAY
5225: PPUSH
5226: CALL_OW 120
5230: GO 5315
// if list then
5232: LD_VAR 0 4
5236: IFFALSE 5315
// begin for i = 1 to list do
5238: LD_ADDR_VAR 0 1
5242: PUSH
5243: DOUBLE
5244: LD_INT 1
5246: DEC
5247: ST_TO_ADDR
5248: LD_VAR 0 4
5252: PUSH
5253: FOR_TO
5254: IFFALSE 5313
// begin p := UnitsInside ( list [ i ] ) ;
5256: LD_ADDR_VAR 0 2
5260: PUSH
5261: LD_VAR 0 4
5265: PUSH
5266: LD_VAR 0 1
5270: ARRAY
5271: PPUSH
5272: CALL_OW 313
5276: ST_TO_ADDR
// if p < 6 then
5277: LD_VAR 0 2
5281: PUSH
5282: LD_INT 6
5284: LESS
5285: IFFALSE 5311
// begin ComEnterUnit ( sol [ 1 ] , list [ i ] ) ;
5287: LD_VAR 0 14
5291: PUSH
5292: LD_INT 1
5294: ARRAY
5295: PPUSH
5296: LD_VAR 0 4
5300: PUSH
5301: LD_VAR 0 1
5305: ARRAY
5306: PPUSH
5307: CALL_OW 120
// end ; end ;
5311: GO 5253
5313: POP
5314: POP
// end ; end ; filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5315: LD_ADDR_VAR 0 17
5319: PUSH
5320: LD_INT 22
5322: PUSH
5323: LD_INT 3
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 21
5332: PUSH
5333: LD_INT 3
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: LD_INT 3
5342: PUSH
5343: LD_INT 24
5345: PUSH
5346: LD_INT 1000
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: PPUSH
5362: CALL_OW 69
5366: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , live ] ] ] ) ;
5367: LD_ADDR_VAR 0 13
5371: PUSH
5372: LD_INT 22
5374: PUSH
5375: LD_INT 3
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: LD_INT 24
5394: PUSH
5395: LD_VAR 0 18
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: PUSH
5404: EMPTY
5405: LIST
5406: LIST
5407: LIST
5408: PUSH
5409: EMPTY
5410: LIST
5411: PPUSH
5412: CALL_OW 69
5416: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_weapon , ru_crane ] , [ f_lives , live ] ] ] ) ;
5417: LD_ADDR_VAR 0 11
5421: PUSH
5422: LD_INT 22
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: LD_INT 34
5434: PUSH
5435: LD_INT 52
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: LD_INT 24
5444: PUSH
5445: LD_VAR 0 18
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: PUSH
5454: EMPTY
5455: LIST
5456: LIST
5457: LIST
5458: PUSH
5459: EMPTY
5460: LIST
5461: PPUSH
5462: CALL_OW 69
5466: ST_TO_ADDR
// if rbullist > 0 and filter = 0 and eng and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) then
5467: LD_EXP 15
5471: PUSH
5472: LD_INT 0
5474: GREATER
5475: PUSH
5476: LD_VAR 0 17
5480: PUSH
5481: LD_INT 0
5483: EQUAL
5484: AND
5485: PUSH
5486: LD_VAR 0 13
5490: AND
5491: PUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 3
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PUSH
5502: LD_INT 30
5504: PUSH
5505: LD_INT 1
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: PPUSH
5516: CALL_OW 69
5520: AND
5521: IFFALSE 5614
// begin for i = 1 to eng do
5523: LD_ADDR_VAR 0 1
5527: PUSH
5528: DOUBLE
5529: LD_INT 1
5531: DEC
5532: ST_TO_ADDR
5533: LD_VAR 0 13
5537: PUSH
5538: FOR_TO
5539: IFFALSE 5612
// if not HasTask ( eng [ i ] ) then
5541: LD_VAR 0 13
5545: PUSH
5546: LD_VAR 0 1
5550: ARRAY
5551: PPUSH
5552: CALL_OW 314
5556: NOT
5557: IFFALSE 5610
// ComBuild ( eng [ i ] , rbullist [ 1 ] , rbullist [ 2 ] , rbullist [ 3 ] , rbullist [ 4 ] ) ;
5559: LD_VAR 0 13
5563: PUSH
5564: LD_VAR 0 1
5568: ARRAY
5569: PPUSH
5570: LD_EXP 15
5574: PUSH
5575: LD_INT 1
5577: ARRAY
5578: PPUSH
5579: LD_EXP 15
5583: PUSH
5584: LD_INT 2
5586: ARRAY
5587: PPUSH
5588: LD_EXP 15
5592: PUSH
5593: LD_INT 3
5595: ARRAY
5596: PPUSH
5597: LD_EXP 15
5601: PUSH
5602: LD_INT 4
5604: ARRAY
5605: PPUSH
5606: CALL_OW 145
5610: GO 5538
5612: POP
5613: POP
// end ; if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_workshop ] , [ f_btype , b_armoury ] ] ] ) then
5614: LD_INT 22
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 2
5626: PUSH
5627: LD_INT 30
5629: PUSH
5630: LD_INT 0
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 30
5639: PUSH
5640: LD_INT 2
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: LD_INT 30
5649: PUSH
5650: LD_INT 4
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: LIST
5661: LIST
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: PPUSH
5667: CALL_OW 69
5671: IFFALSE 5749
// begin p := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_workshop ] , [ f_btype , b_armoury ] ] ] ) [ 1 ] ;
5673: LD_ADDR_VAR 0 2
5677: PUSH
5678: LD_INT 22
5680: PUSH
5681: LD_INT 3
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 30
5693: PUSH
5694: LD_INT 0
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 30
5703: PUSH
5704: LD_INT 2
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 30
5713: PUSH
5714: LD_INT 4
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: PPUSH
5731: CALL_OW 69
5735: PUSH
5736: LD_INT 1
5738: ARRAY
5739: ST_TO_ADDR
// ComUpgrade ( p ) ;
5740: LD_VAR 0 2
5744: PPUSH
5745: CALL_OW 146
// end ; if filter > 0 then
5749: LD_VAR 0 17
5753: PUSH
5754: LD_INT 0
5756: GREATER
5757: IFFALSE 6007
// begin if crane then
5759: LD_VAR 0 11
5763: IFFALSE 5829
// for i = 1 to crane do
5765: LD_ADDR_VAR 0 1
5769: PUSH
5770: DOUBLE
5771: LD_INT 1
5773: DEC
5774: ST_TO_ADDR
5775: LD_VAR 0 11
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5827
// if not HasTask ( crane [ i ] ) then
5783: LD_VAR 0 11
5787: PUSH
5788: LD_VAR 0 1
5792: ARRAY
5793: PPUSH
5794: CALL_OW 314
5798: NOT
5799: IFFALSE 5825
// ComRepairBuilding ( crane [ i ] , filter [ 1 ] ) ;
5801: LD_VAR 0 11
5805: PUSH
5806: LD_VAR 0 1
5810: ARRAY
5811: PPUSH
5812: LD_VAR 0 17
5816: PUSH
5817: LD_INT 1
5819: ARRAY
5820: PPUSH
5821: CALL_OW 130
5825: GO 5780
5827: POP
5828: POP
// if eng then
5829: LD_VAR 0 13
5833: IFFALSE 6005
// for i = 1 to eng do
5835: LD_ADDR_VAR 0 1
5839: PUSH
5840: DOUBLE
5841: LD_INT 1
5843: DEC
5844: ST_TO_ADDR
5845: LD_VAR 0 13
5849: PUSH
5850: FOR_TO
5851: IFFALSE 6003
// begin if IsInUnit ( eng [ i ] ) then
5853: LD_VAR 0 13
5857: PUSH
5858: LD_VAR 0 1
5862: ARRAY
5863: PPUSH
5864: CALL_OW 310
5868: IFFALSE 5887
// ComExitBuilding ( eng [ i ] ) else
5870: LD_VAR 0 13
5874: PUSH
5875: LD_VAR 0 1
5879: ARRAY
5880: PPUSH
5881: CALL_OW 122
5885: GO 6001
// if not HasTask ( eng [ i ] ) then
5887: LD_VAR 0 13
5891: PUSH
5892: LD_VAR 0 1
5896: ARRAY
5897: PPUSH
5898: CALL_OW 314
5902: NOT
5903: IFFALSE 6001
// if filter < 2 then
5905: LD_VAR 0 17
5909: PUSH
5910: LD_INT 2
5912: LESS
5913: IFFALSE 5941
// ComRepairBuilding ( eng [ i ] , filter [ 1 ] ) else
5915: LD_VAR 0 13
5919: PUSH
5920: LD_VAR 0 1
5924: ARRAY
5925: PPUSH
5926: LD_VAR 0 17
5930: PUSH
5931: LD_INT 1
5933: ARRAY
5934: PPUSH
5935: CALL_OW 130
5939: GO 6001
// begin if i <= 3 then
5941: LD_VAR 0 1
5945: PUSH
5946: LD_INT 3
5948: LESSEQUAL
5949: IFFALSE 5977
// ComRepairBuilding ( eng [ i ] , filter [ 1 ] ) else
5951: LD_VAR 0 13
5955: PUSH
5956: LD_VAR 0 1
5960: ARRAY
5961: PPUSH
5962: LD_VAR 0 17
5966: PUSH
5967: LD_INT 1
5969: ARRAY
5970: PPUSH
5971: CALL_OW 130
5975: GO 6001
// ComRepairBuilding ( eng [ i ] , filter [ 2 ] ) ;
5977: LD_VAR 0 13
5981: PUSH
5982: LD_VAR 0 1
5986: ARRAY
5987: PPUSH
5988: LD_VAR 0 17
5992: PUSH
5993: LD_INT 2
5995: ARRAY
5996: PPUSH
5997: CALL_OW 130
// end ; end ;
6001: GO 5850
6003: POP
6004: POP
// end else
6005: GO 6199
// if rbullist = 0 then
6007: LD_EXP 15
6011: PUSH
6012: LD_INT 0
6014: EQUAL
6015: IFFALSE 6199
// begin for i = 1 to eng do
6017: LD_ADDR_VAR 0 1
6021: PUSH
6022: DOUBLE
6023: LD_INT 1
6025: DEC
6026: ST_TO_ADDR
6027: LD_VAR 0 13
6031: PUSH
6032: FOR_TO
6033: IFFALSE 6132
// if not HasTask ( eng [ i ] ) and not IsInUnit ( eng [ i ] ) then
6035: LD_VAR 0 13
6039: PUSH
6040: LD_VAR 0 1
6044: ARRAY
6045: PPUSH
6046: CALL_OW 314
6050: NOT
6051: PUSH
6052: LD_VAR 0 13
6056: PUSH
6057: LD_VAR 0 1
6061: ARRAY
6062: PPUSH
6063: CALL_OW 310
6067: NOT
6068: AND
6069: IFFALSE 6130
// ComEnterUnit ( eng [ i ] , FilterAllUnits ( [ [ f_side , GetSide ( eng [ 1 ] ) ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
6071: LD_VAR 0 13
6075: PUSH
6076: LD_VAR 0 1
6080: ARRAY
6081: PPUSH
6082: LD_INT 22
6084: PUSH
6085: LD_VAR 0 13
6089: PUSH
6090: LD_INT 1
6092: ARRAY
6093: PPUSH
6094: CALL_OW 255
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: PUSH
6103: LD_INT 30
6105: PUSH
6106: LD_INT 1
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PPUSH
6117: CALL_OW 69
6121: PUSH
6122: LD_INT 1
6124: ARRAY
6125: PPUSH
6126: CALL_OW 120
6130: GO 6032
6132: POP
6133: POP
// for i = 1 to crane do
6134: LD_ADDR_VAR 0 1
6138: PUSH
6139: DOUBLE
6140: LD_INT 1
6142: DEC
6143: ST_TO_ADDR
6144: LD_VAR 0 11
6148: PUSH
6149: FOR_TO
6150: IFFALSE 6197
// if not IsInArea ( crane [ i ] , crane_parking ) then
6152: LD_VAR 0 11
6156: PUSH
6157: LD_VAR 0 1
6161: ARRAY
6162: PPUSH
6163: LD_VAR 0 19
6167: PPUSH
6168: CALL_OW 308
6172: NOT
6173: IFFALSE 6195
// ComMoveToArea ( crane [ i ] , crane_parking ) ;
6175: LD_VAR 0 11
6179: PUSH
6180: LD_VAR 0 1
6184: ARRAY
6185: PPUSH
6186: LD_VAR 0 19
6190: PPUSH
6191: CALL_OW 113
6195: GO 6149
6197: POP
6198: POP
// end ; end ;
6199: PPOPN 22
6201: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 6 ] ) > 0 do var i , p , un , list , list2 , list3 , dep , lab , fac , towers , crane , bar , eng , sol , mech , sci , filter , live , crane_parking , enemy , doc , hurts ;
6202: LD_INT 22
6204: PUSH
6205: LD_INT 6
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: PUSH
6217: LD_INT 0
6219: GREATER
6220: IFFALSE 8603
6222: GO 6224
6224: DISABLE
6225: LD_INT 0
6227: PPUSH
6228: PPUSH
6229: PPUSH
6230: PPUSH
6231: PPUSH
6232: PPUSH
6233: PPUSH
6234: PPUSH
6235: PPUSH
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
6240: PPUSH
6241: PPUSH
6242: PPUSH
6243: PPUSH
6244: PPUSH
6245: PPUSH
6246: PPUSH
6247: PPUSH
6248: PPUSH
// begin enable ;
6249: ENABLE
// live := 675 ;
6250: LD_ADDR_VAR 0 18
6254: PUSH
6255: LD_INT 675
6257: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
6258: LD_ADDR_VAR 0 7
6262: PUSH
6263: LD_INT 22
6265: PUSH
6266: LD_INT 6
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: PUSH
6273: LD_INT 30
6275: PUSH
6276: LD_INT 1
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PUSH
6292: LD_INT 1
6294: ARRAY
6295: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
6296: LD_ADDR_VAR 0 9
6300: PUSH
6301: LD_INT 22
6303: PUSH
6304: LD_INT 6
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 30
6313: PUSH
6314: LD_INT 3
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 69
6329: PUSH
6330: LD_INT 1
6332: ARRAY
6333: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
6334: LD_ADDR_VAR 0 8
6338: PUSH
6339: LD_INT 22
6341: PUSH
6342: LD_INT 6
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PUSH
6349: LD_INT 2
6351: PUSH
6352: LD_INT 30
6354: PUSH
6355: LD_INT 6
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: PUSH
6362: LD_INT 30
6364: PUSH
6365: LD_INT 8
6367: PUSH
6368: EMPTY
6369: LIST
6370: LIST
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PPUSH
6381: CALL_OW 69
6385: PUSH
6386: LD_INT 1
6388: ARRAY
6389: ST_TO_ADDR
// crane_parking := ru2_crane_parking ;
6390: LD_ADDR_VAR 0 19
6394: PUSH
6395: LD_INT 7
6397: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , live ] ] ] ) ;
6398: LD_ADDR_VAR 0 21
6402: PUSH
6403: LD_INT 22
6405: PUSH
6406: LD_INT 6
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PUSH
6413: LD_INT 25
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 24
6425: PUSH
6426: LD_VAR 0 18
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: LIST
6439: PUSH
6440: EMPTY
6441: LIST
6442: PPUSH
6443: CALL_OW 69
6447: ST_TO_ADDR
// hurts := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , live ] ] ] ] ) ;
6448: LD_ADDR_VAR 0 22
6452: PUSH
6453: LD_INT 22
6455: PUSH
6456: LD_INT 6
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: PUSH
6463: LD_INT 21
6465: PUSH
6466: LD_INT 1
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 3
6475: PUSH
6476: LD_INT 24
6478: PUSH
6479: LD_VAR 0 18
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: PUSH
6497: EMPTY
6498: LIST
6499: PPUSH
6500: CALL_OW 69
6504: ST_TO_ADDR
// if hurts then
6505: LD_VAR 0 22
6509: IFFALSE 6957
// begin for i = 1 to hurts do
6511: LD_ADDR_VAR 0 1
6515: PUSH
6516: DOUBLE
6517: LD_INT 1
6519: DEC
6520: ST_TO_ADDR
6521: LD_VAR 0 22
6525: PUSH
6526: FOR_TO
6527: IFFALSE 6578
// if GetDistUnits ( hurts [ i ] , dep ) > 10 then
6529: LD_VAR 0 22
6533: PUSH
6534: LD_VAR 0 1
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 7
6544: PPUSH
6545: CALL_OW 296
6549: PUSH
6550: LD_INT 10
6552: GREATER
6553: IFFALSE 6576
// ComMoveXY ( hurts [ i ] , 122 , 89 ) ;
6555: LD_VAR 0 22
6559: PUSH
6560: LD_VAR 0 1
6564: ARRAY
6565: PPUSH
6566: LD_INT 122
6568: PPUSH
6569: LD_INT 89
6571: PPUSH
6572: CALL_OW 111
6576: GO 6526
6578: POP
6579: POP
// list := UnitFilter ( hurts , [ f_distxy , 122 , 89 , 10 ] ) ;
6580: LD_ADDR_VAR 0 4
6584: PUSH
6585: LD_VAR 0 22
6589: PPUSH
6590: LD_INT 92
6592: PUSH
6593: LD_INT 122
6595: PUSH
6596: LD_INT 89
6598: PUSH
6599: LD_INT 10
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: ST_TO_ADDR
// if doc = 0 then
6613: LD_VAR 0 21
6617: PUSH
6618: LD_INT 0
6620: EQUAL
6621: IFFALSE 6773
// begin filter := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] ] ] ) ;
6623: LD_ADDR_VAR 0 17
6627: PUSH
6628: LD_INT 22
6630: PUSH
6631: LD_INT 6
6633: PUSH
6634: EMPTY
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 25
6640: PUSH
6641: LD_INT 3
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: EMPTY
6653: LIST
6654: PPUSH
6655: CALL_OW 69
6659: ST_TO_ADDR
// if IsInUnit ( filter [ 1 ] ) then
6660: LD_VAR 0 17
6664: PUSH
6665: LD_INT 1
6667: ARRAY
6668: PPUSH
6669: CALL_OW 310
6673: IFFALSE 6688
// ComExitBuilding ( filter [ 1 ] ) ;
6675: LD_VAR 0 17
6679: PUSH
6680: LD_INT 1
6682: ARRAY
6683: PPUSH
6684: CALL_OW 122
// ComEnterUnit ( filter [ 1 ] , FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] ] ] ] ) [ 1 ] ) ;
6688: LD_VAR 0 17
6692: PUSH
6693: LD_INT 1
6695: ARRAY
6696: PPUSH
6697: LD_INT 22
6699: PUSH
6700: LD_INT 6
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: LD_INT 30
6712: PUSH
6713: LD_INT 6
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 30
6722: PUSH
6723: LD_INT 8
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: EMPTY
6740: LIST
6741: PPUSH
6742: CALL_OW 69
6746: PUSH
6747: LD_INT 1
6749: ARRAY
6750: PPUSH
6751: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 4 ) ;
6755: LD_VAR 0 17
6759: PUSH
6760: LD_INT 1
6762: ARRAY
6763: PPUSH
6764: LD_INT 4
6766: PPUSH
6767: CALL_OW 183
// end else
6771: GO 6955
// if doc > 4 then
6773: LD_VAR 0 21
6777: PUSH
6778: LD_INT 4
6780: GREATER
6781: IFFALSE 6869
// begin for i = 1 to 4 do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 4
6795: PUSH
6796: FOR_TO
6797: IFFALSE 6865
// if IsInUnit ( doc [ i ] ) then
6799: LD_VAR 0 21
6803: PUSH
6804: LD_VAR 0 1
6808: ARRAY
6809: PPUSH
6810: CALL_OW 310
6814: IFFALSE 6833
// ComExitBuilding ( doc [ i ] ) else
6816: LD_VAR 0 21
6820: PUSH
6821: LD_VAR 0 1
6825: ARRAY
6826: PPUSH
6827: CALL_OW 122
6831: GO 6863
// if list then
6833: LD_VAR 0 4
6837: IFFALSE 6863
// ComHeal ( doc [ i ] , list [ 1 ] ) ;
6839: LD_VAR 0 21
6843: PUSH
6844: LD_VAR 0 1
6848: ARRAY
6849: PPUSH
6850: LD_VAR 0 4
6854: PUSH
6855: LD_INT 1
6857: ARRAY
6858: PPUSH
6859: CALL_OW 128
6863: GO 6796
6865: POP
6866: POP
// end else
6867: GO 6955
// begin for i = 1 to doc do
6869: LD_ADDR_VAR 0 1
6873: PUSH
6874: DOUBLE
6875: LD_INT 1
6877: DEC
6878: ST_TO_ADDR
6879: LD_VAR 0 21
6883: PUSH
6884: FOR_TO
6885: IFFALSE 6953
// if IsInUnit ( doc [ i ] ) then
6887: LD_VAR 0 21
6891: PUSH
6892: LD_VAR 0 1
6896: ARRAY
6897: PPUSH
6898: CALL_OW 310
6902: IFFALSE 6921
// ComExitBuilding ( doc [ i ] ) else
6904: LD_VAR 0 21
6908: PUSH
6909: LD_VAR 0 1
6913: ARRAY
6914: PPUSH
6915: CALL_OW 122
6919: GO 6951
// if list then
6921: LD_VAR 0 4
6925: IFFALSE 6951
// ComHeal ( doc [ i ] , list [ 1 ] ) ;
6927: LD_VAR 0 21
6931: PUSH
6932: LD_VAR 0 1
6936: ARRAY
6937: PPUSH
6938: LD_VAR 0 4
6942: PUSH
6943: LD_INT 1
6945: ARRAY
6946: PPUSH
6947: CALL_OW 128
6951: GO 6884
6953: POP
6954: POP
// end ; end else
6955: GO 7049
// begin filter := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_outside ] ] ] ) ;
6957: LD_ADDR_VAR 0 17
6961: PUSH
6962: LD_INT 22
6964: PUSH
6965: LD_INT 6
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 25
6974: PUSH
6975: LD_INT 4
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: PUSH
6982: LD_INT 56
6984: PUSH
6985: EMPTY
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: PPUSH
6996: CALL_OW 69
7000: ST_TO_ADDR
// if filter then
7001: LD_VAR 0 17
7005: IFFALSE 7049
// for i = 1 to filter do
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_VAR 0 17
7021: PUSH
7022: FOR_TO
7023: IFFALSE 7047
// ComEnterUnit ( filter [ i ] , lab ) ;
7025: LD_VAR 0 17
7029: PUSH
7030: LD_VAR 0 1
7034: ARRAY
7035: PPUSH
7036: LD_VAR 0 8
7040: PPUSH
7041: CALL_OW 120
7045: GO 7022
7047: POP
7048: POP
// end ; list := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , class_bazooker ] ] ) ;
7049: LD_ADDR_VAR 0 4
7053: PUSH
7054: LD_INT 22
7056: PUSH
7057: LD_INT 6
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 25
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PPUSH
7078: CALL_OW 69
7082: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
7083: LD_ADDR_VAR 0 17
7087: PUSH
7088: LD_INT 22
7090: PUSH
7091: LD_INT 2
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 3
7100: PUSH
7101: LD_INT 21
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PPUSH
7119: CALL_OW 69
7123: ST_TO_ADDR
// if CanUseBazooka then
7124: LD_EXP 23
7128: IFFALSE 7144
// IntBazooka ( list , filter ) ;
7130: LD_VAR 0 4
7134: PPUSH
7135: LD_VAR 0 17
7139: PPUSH
7140: CALL 10231 0 2
// if BuildingStatus ( fac ) = bs_idle then
7144: LD_VAR 0 9
7148: PPUSH
7149: CALL_OW 461
7153: PUSH
7154: LD_INT 2
7156: EQUAL
7157: IFFALSE 7457
// begin if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) = 0 then
7159: LD_INT 22
7161: PUSH
7162: LD_INT 6
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: LD_INT 34
7171: PUSH
7172: LD_INT 52
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 69
7187: PUSH
7188: LD_INT 0
7190: EQUAL
7191: IFFALSE 7202
// ProduceCrane ( fac ) ;
7193: LD_VAR 0 9
7197: PPUSH
7198: CALL 9357 0 1
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) = 0 then
7202: LD_INT 22
7204: PUSH
7205: LD_INT 6
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: LD_INT 34
7214: PUSH
7215: LD_INT 51
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: PPUSH
7226: CALL_OW 69
7230: PUSH
7231: LD_INT 0
7233: EQUAL
7234: IFFALSE 7245
// ProduceCargoBay ( fac ) ;
7236: LD_VAR 0 9
7240: PPUSH
7241: CALL 9470 0 1
// if rvehlist >= 4 then
7245: LD_EXP 14
7249: PUSH
7250: LD_INT 4
7252: GREATEREQUAL
7253: IFFALSE 7300
// ComConstruct ( fac , r2vehlist [ 1 ] , r2vehlist [ 2 ] , r2vehlist [ 3 ] , r2vehlist [ 4 ] ) ;
7255: LD_VAR 0 9
7259: PPUSH
7260: LD_EXP 16
7264: PUSH
7265: LD_INT 1
7267: ARRAY
7268: PPUSH
7269: LD_EXP 16
7273: PUSH
7274: LD_INT 2
7276: ARRAY
7277: PPUSH
7278: LD_EXP 16
7282: PUSH
7283: LD_INT 3
7285: ARRAY
7286: PPUSH
7287: LD_EXP 16
7291: PUSH
7292: LD_INT 4
7294: ARRAY
7295: PPUSH
7296: CALL_OW 125
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_bweapon , 0 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) then
7300: LD_INT 22
7302: PUSH
7303: LD_INT 6
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: LD_INT 35
7312: PUSH
7313: LD_INT 0
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: LD_INT 2
7322: PUSH
7323: LD_INT 30
7325: PUSH
7326: LD_INT 32
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: PUSH
7333: LD_INT 30
7335: PUSH
7336: LD_INT 33
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: LIST
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PPUSH
7353: CALL_OW 69
7357: IFFALSE 7457
// begin towers := FilterAllUnits ( [ [ f_side , 6 ] , [ f_bweapon , 0 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7359: LD_ADDR_VAR 0 10
7363: PUSH
7364: LD_INT 22
7366: PUSH
7367: LD_INT 6
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: LD_INT 35
7376: PUSH
7377: LD_INT 0
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: PUSH
7384: LD_INT 2
7386: PUSH
7387: LD_INT 30
7389: PUSH
7390: LD_INT 32
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: PUSH
7397: LD_INT 30
7399: PUSH
7400: LD_INT 33
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: LIST
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: LIST
7416: PPUSH
7417: CALL_OW 69
7421: ST_TO_ADDR
// ComPlaceWeapon ( towers [ 1 ] , [ ru_heavy_gun , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
7422: LD_VAR 0 10
7426: PUSH
7427: LD_INT 1
7429: ARRAY
7430: PPUSH
7431: LD_INT 46
7433: PUSH
7434: LD_INT 45
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PUSH
7441: LD_INT 1
7443: PPUSH
7444: LD_INT 2
7446: PPUSH
7447: CALL_OW 12
7451: ARRAY
7452: PPUSH
7453: CALL_OW 148
// end ; end ; sol := FilterAllUnits ( [ [ f_side , 6 ] , [ f_outside ] , [ f_or , [ f_class , 1 ] , [ f_class , 9 ] ] ] ) diff ruforce ;
7457: LD_ADDR_VAR 0 14
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 6
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 56
7474: PUSH
7475: EMPTY
7476: LIST
7477: PUSH
7478: LD_INT 2
7480: PUSH
7481: LD_INT 25
7483: PUSH
7484: LD_INT 1
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 25
7493: PUSH
7494: LD_INT 9
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: PPUSH
7511: CALL_OW 69
7515: PUSH
7516: LD_EXP 12
7520: DIFF
7521: ST_TO_ADDR
// if sol then
7522: LD_VAR 0 14
7526: IFFALSE 7719
// begin list := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_barracks ] ] ) ;
7528: LD_ADDR_VAR 0 4
7532: PUSH
7533: LD_INT 22
7535: PUSH
7536: LD_INT 6
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 30
7545: PUSH
7546: LD_INT 5
7548: PUSH
7549: EMPTY
7550: LIST
7551: LIST
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 69
7561: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ] ) ;
7562: LD_ADDR_VAR 0 10
7566: PUSH
7567: LD_INT 22
7569: PUSH
7570: LD_INT 6
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: LD_INT 58
7579: PUSH
7580: EMPTY
7581: LIST
7582: PUSH
7583: LD_INT 30
7585: PUSH
7586: LD_INT 32
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: PUSH
7598: EMPTY
7599: LIST
7600: PPUSH
7601: CALL_OW 69
7605: ST_TO_ADDR
// if towers then
7606: LD_VAR 0 10
7610: IFFALSE 7636
// ComEnterUnit ( sol [ 1 ] , towers [ 1 ] ) else
7612: LD_VAR 0 14
7616: PUSH
7617: LD_INT 1
7619: ARRAY
7620: PPUSH
7621: LD_VAR 0 10
7625: PUSH
7626: LD_INT 1
7628: ARRAY
7629: PPUSH
7630: CALL_OW 120
7634: GO 7719
// if list then
7636: LD_VAR 0 4
7640: IFFALSE 7719
// begin for i = 1 to list do
7642: LD_ADDR_VAR 0 1
7646: PUSH
7647: DOUBLE
7648: LD_INT 1
7650: DEC
7651: ST_TO_ADDR
7652: LD_VAR 0 4
7656: PUSH
7657: FOR_TO
7658: IFFALSE 7717
// begin p := UnitsInside ( list [ i ] ) ;
7660: LD_ADDR_VAR 0 2
7664: PUSH
7665: LD_VAR 0 4
7669: PUSH
7670: LD_VAR 0 1
7674: ARRAY
7675: PPUSH
7676: CALL_OW 313
7680: ST_TO_ADDR
// if p < 6 then
7681: LD_VAR 0 2
7685: PUSH
7686: LD_INT 6
7688: LESS
7689: IFFALSE 7715
// begin ComEnterUnit ( sol [ 1 ] , list [ i ] ) ;
7691: LD_VAR 0 14
7695: PUSH
7696: LD_INT 1
7698: ARRAY
7699: PPUSH
7700: LD_VAR 0 4
7704: PUSH
7705: LD_VAR 0 1
7709: ARRAY
7710: PPUSH
7711: CALL_OW 120
// end ; end ;
7715: GO 7657
7717: POP
7718: POP
// end ; end ; filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7719: LD_ADDR_VAR 0 17
7723: PUSH
7724: LD_INT 22
7726: PUSH
7727: LD_INT 6
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: LD_INT 21
7736: PUSH
7737: LD_INT 3
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 3
7746: PUSH
7747: LD_INT 24
7749: PUSH
7750: LD_INT 1000
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 69
7770: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , live ] ] ] ) ;
7771: LD_ADDR_VAR 0 13
7775: PUSH
7776: LD_INT 22
7778: PUSH
7779: LD_INT 6
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PUSH
7786: LD_INT 25
7788: PUSH
7789: LD_INT 2
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 24
7798: PUSH
7799: LD_VAR 0 18
7803: PUSH
7804: EMPTY
7805: LIST
7806: LIST
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: LIST
7812: PUSH
7813: EMPTY
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_weapon , ru_crane ] , [ f_lives , live ] ] ] ) ;
7821: LD_ADDR_VAR 0 11
7825: PUSH
7826: LD_INT 22
7828: PUSH
7829: LD_INT 6
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 34
7838: PUSH
7839: LD_INT 52
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 24
7848: PUSH
7849: LD_VAR 0 18
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: PUSH
7863: EMPTY
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: ST_TO_ADDR
// if r2bullist > 0 and filter = 0 and eng and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_warehouse ] ] ) then
7871: LD_EXP 17
7875: PUSH
7876: LD_INT 0
7878: GREATER
7879: PUSH
7880: LD_VAR 0 17
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: AND
7889: PUSH
7890: LD_VAR 0 13
7894: AND
7895: PUSH
7896: LD_INT 22
7898: PUSH
7899: LD_INT 6
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 30
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PPUSH
7920: CALL_OW 69
7924: AND
7925: IFFALSE 8018
// begin for i = 1 to eng do
7927: LD_ADDR_VAR 0 1
7931: PUSH
7932: DOUBLE
7933: LD_INT 1
7935: DEC
7936: ST_TO_ADDR
7937: LD_VAR 0 13
7941: PUSH
7942: FOR_TO
7943: IFFALSE 8016
// if not HasTask ( eng [ i ] ) then
7945: LD_VAR 0 13
7949: PUSH
7950: LD_VAR 0 1
7954: ARRAY
7955: PPUSH
7956: CALL_OW 314
7960: NOT
7961: IFFALSE 8014
// ComBuild ( eng [ i ] , r2bullist [ 1 ] , r2bullist [ 2 ] , r2bullist [ 3 ] , r2bullist [ 4 ] ) ;
7963: LD_VAR 0 13
7967: PUSH
7968: LD_VAR 0 1
7972: ARRAY
7973: PPUSH
7974: LD_EXP 17
7978: PUSH
7979: LD_INT 1
7981: ARRAY
7982: PPUSH
7983: LD_EXP 17
7987: PUSH
7988: LD_INT 2
7990: ARRAY
7991: PPUSH
7992: LD_EXP 17
7996: PUSH
7997: LD_INT 3
7999: ARRAY
8000: PPUSH
8001: LD_EXP 17
8005: PUSH
8006: LD_INT 4
8008: ARRAY
8009: PPUSH
8010: CALL_OW 145
8014: GO 7942
8016: POP
8017: POP
// end ; if FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_workshop ] , [ f_btype , b_armoury ] ] ] ) then
8018: LD_INT 22
8020: PUSH
8021: LD_INT 6
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 30
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 30
8043: PUSH
8044: LD_INT 2
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: LD_INT 30
8053: PUSH
8054: LD_INT 4
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PPUSH
8071: CALL_OW 69
8075: IFFALSE 8153
// begin p := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_workshop ] , [ f_btype , b_armoury ] ] ] ) [ 1 ] ;
8077: LD_ADDR_VAR 0 2
8081: PUSH
8082: LD_INT 22
8084: PUSH
8085: LD_INT 6
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: LD_INT 2
8094: PUSH
8095: LD_INT 30
8097: PUSH
8098: LD_INT 0
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: PUSH
8105: LD_INT 30
8107: PUSH
8108: LD_INT 2
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PUSH
8115: LD_INT 30
8117: PUSH
8118: LD_INT 4
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: LIST
8129: LIST
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PPUSH
8135: CALL_OW 69
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: ST_TO_ADDR
// ComUpgrade ( p ) ;
8144: LD_VAR 0 2
8148: PPUSH
8149: CALL_OW 146
// end ; if filter > 0 then
8153: LD_VAR 0 17
8157: PUSH
8158: LD_INT 0
8160: GREATER
8161: IFFALSE 8411
// begin if crane then
8163: LD_VAR 0 11
8167: IFFALSE 8233
// for i = 1 to crane do
8169: LD_ADDR_VAR 0 1
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_VAR 0 11
8183: PUSH
8184: FOR_TO
8185: IFFALSE 8231
// if not HasTask ( crane [ i ] ) then
8187: LD_VAR 0 11
8191: PUSH
8192: LD_VAR 0 1
8196: ARRAY
8197: PPUSH
8198: CALL_OW 314
8202: NOT
8203: IFFALSE 8229
// ComRepairBuilding ( crane [ i ] , filter [ 1 ] ) ;
8205: LD_VAR 0 11
8209: PUSH
8210: LD_VAR 0 1
8214: ARRAY
8215: PPUSH
8216: LD_VAR 0 17
8220: PUSH
8221: LD_INT 1
8223: ARRAY
8224: PPUSH
8225: CALL_OW 130
8229: GO 8184
8231: POP
8232: POP
// if eng then
8233: LD_VAR 0 13
8237: IFFALSE 8409
// for i = 1 to eng do
8239: LD_ADDR_VAR 0 1
8243: PUSH
8244: DOUBLE
8245: LD_INT 1
8247: DEC
8248: ST_TO_ADDR
8249: LD_VAR 0 13
8253: PUSH
8254: FOR_TO
8255: IFFALSE 8407
// begin if IsInUnit ( eng [ i ] ) then
8257: LD_VAR 0 13
8261: PUSH
8262: LD_VAR 0 1
8266: ARRAY
8267: PPUSH
8268: CALL_OW 310
8272: IFFALSE 8291
// ComExitBuilding ( eng [ i ] ) else
8274: LD_VAR 0 13
8278: PUSH
8279: LD_VAR 0 1
8283: ARRAY
8284: PPUSH
8285: CALL_OW 122
8289: GO 8405
// if not HasTask ( eng [ i ] ) then
8291: LD_VAR 0 13
8295: PUSH
8296: LD_VAR 0 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 314
8306: NOT
8307: IFFALSE 8405
// if filter < 2 then
8309: LD_VAR 0 17
8313: PUSH
8314: LD_INT 2
8316: LESS
8317: IFFALSE 8345
// ComRepairBuilding ( eng [ i ] , filter [ 1 ] ) else
8319: LD_VAR 0 13
8323: PUSH
8324: LD_VAR 0 1
8328: ARRAY
8329: PPUSH
8330: LD_VAR 0 17
8334: PUSH
8335: LD_INT 1
8337: ARRAY
8338: PPUSH
8339: CALL_OW 130
8343: GO 8405
// begin if i <= 3 then
8345: LD_VAR 0 1
8349: PUSH
8350: LD_INT 3
8352: LESSEQUAL
8353: IFFALSE 8381
// ComRepairBuilding ( eng [ i ] , filter [ 1 ] ) else
8355: LD_VAR 0 13
8359: PUSH
8360: LD_VAR 0 1
8364: ARRAY
8365: PPUSH
8366: LD_VAR 0 17
8370: PUSH
8371: LD_INT 1
8373: ARRAY
8374: PPUSH
8375: CALL_OW 130
8379: GO 8405
// ComRepairBuilding ( eng [ i ] , filter [ 2 ] ) ;
8381: LD_VAR 0 13
8385: PUSH
8386: LD_VAR 0 1
8390: ARRAY
8391: PPUSH
8392: LD_VAR 0 17
8396: PUSH
8397: LD_INT 2
8399: ARRAY
8400: PPUSH
8401: CALL_OW 130
// end ; end ;
8405: GO 8254
8407: POP
8408: POP
// end else
8409: GO 8603
// if r2bullist = 0 then
8411: LD_EXP 17
8415: PUSH
8416: LD_INT 0
8418: EQUAL
8419: IFFALSE 8603
// begin for i = 1 to eng do
8421: LD_ADDR_VAR 0 1
8425: PUSH
8426: DOUBLE
8427: LD_INT 1
8429: DEC
8430: ST_TO_ADDR
8431: LD_VAR 0 13
8435: PUSH
8436: FOR_TO
8437: IFFALSE 8536
// if not HasTask ( eng [ i ] ) and not IsInUnit ( eng [ i ] ) then
8439: LD_VAR 0 13
8443: PUSH
8444: LD_VAR 0 1
8448: ARRAY
8449: PPUSH
8450: CALL_OW 314
8454: NOT
8455: PUSH
8456: LD_VAR 0 13
8460: PUSH
8461: LD_VAR 0 1
8465: ARRAY
8466: PPUSH
8467: CALL_OW 310
8471: NOT
8472: AND
8473: IFFALSE 8534
// ComEnterUnit ( eng [ i ] , FilterAllUnits ( [ [ f_side , GetSide ( eng [ 1 ] ) ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
8475: LD_VAR 0 13
8479: PUSH
8480: LD_VAR 0 1
8484: ARRAY
8485: PPUSH
8486: LD_INT 22
8488: PUSH
8489: LD_VAR 0 13
8493: PUSH
8494: LD_INT 1
8496: ARRAY
8497: PPUSH
8498: CALL_OW 255
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: LD_INT 30
8509: PUSH
8510: LD_INT 1
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PPUSH
8521: CALL_OW 69
8525: PUSH
8526: LD_INT 1
8528: ARRAY
8529: PPUSH
8530: CALL_OW 120
8534: GO 8436
8536: POP
8537: POP
// for i = 1 to crane do
8538: LD_ADDR_VAR 0 1
8542: PUSH
8543: DOUBLE
8544: LD_INT 1
8546: DEC
8547: ST_TO_ADDR
8548: LD_VAR 0 11
8552: PUSH
8553: FOR_TO
8554: IFFALSE 8601
// if not IsInArea ( crane [ i ] , crane_parking ) then
8556: LD_VAR 0 11
8560: PUSH
8561: LD_VAR 0 1
8565: ARRAY
8566: PPUSH
8567: LD_VAR 0 19
8571: PPUSH
8572: CALL_OW 308
8576: NOT
8577: IFFALSE 8599
// ComMoveToArea ( crane [ i ] , crane_parking ) ;
8579: LD_VAR 0 11
8583: PUSH
8584: LD_VAR 0 1
8588: ARRAY
8589: PPUSH
8590: LD_VAR 0 19
8594: PPUSH
8595: CALL_OW 113
8599: GO 8553
8601: POP
8602: POP
// end ; end ;
8603: PPOPN 22
8605: END
// every 0 0$03 trigger ruforce do var x , y , i , p ;
8606: LD_EXP 12
8610: IFFALSE 8942
8612: GO 8614
8614: DISABLE
8615: LD_INT 0
8617: PPUSH
8618: PPUSH
8619: PPUSH
8620: PPUSH
// begin x := [ 81 , 108 , 145 , 108 ] ;
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_INT 81
8628: PUSH
8629: LD_INT 108
8631: PUSH
8632: LD_INT 145
8634: PUSH
8635: LD_INT 108
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: ST_TO_ADDR
// y := [ 7 , 4 , 20 , 4 ] ;
8644: LD_ADDR_VAR 0 2
8648: PUSH
8649: LD_INT 7
8651: PUSH
8652: LD_INT 4
8654: PUSH
8655: LD_INT 20
8657: PUSH
8658: LD_INT 4
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: LIST
8665: LIST
8666: ST_TO_ADDR
// p := 0 ;
8667: LD_ADDR_VAR 0 4
8671: PUSH
8672: LD_INT 0
8674: ST_TO_ADDR
// while ( in_base = false ) do
8675: LD_EXP 28
8679: PUSH
8680: LD_INT 0
8682: EQUAL
8683: IFFALSE 8942
// begin Wait ( 0 0$01 ) ;
8685: LD_INT 35
8687: PPUSH
8688: CALL_OW 67
// for i = 1 to ruforce do
8692: LD_ADDR_VAR 0 3
8696: PUSH
8697: DOUBLE
8698: LD_INT 1
8700: DEC
8701: ST_TO_ADDR
8702: LD_EXP 12
8706: PUSH
8707: FOR_TO
8708: IFFALSE 8938
// begin if not See ( 2 , ruforce [ i ] ) then
8710: LD_INT 2
8712: PPUSH
8713: LD_EXP 12
8717: PUSH
8718: LD_VAR 0 3
8722: ARRAY
8723: PPUSH
8724: CALL_OW 292
8728: NOT
8729: IFFALSE 8890
// begin if not HasTask ( ruforce [ i ] ) then
8731: LD_EXP 12
8735: PUSH
8736: LD_VAR 0 3
8740: ARRAY
8741: PPUSH
8742: CALL_OW 314
8746: NOT
8747: IFFALSE 8840
// begin if ( p < 4 ) then
8749: LD_VAR 0 4
8753: PUSH
8754: LD_INT 4
8756: LESS
8757: IFFALSE 8775
// p = p + 1 else
8759: LD_ADDR_VAR 0 4
8763: PUSH
8764: LD_VAR 0 4
8768: PUSH
8769: LD_INT 1
8771: PLUS
8772: ST_TO_ADDR
8773: GO 8783
// p = 1 ;
8775: LD_ADDR_VAR 0 4
8779: PUSH
8780: LD_INT 1
8782: ST_TO_ADDR
// AddComMoveXY ( ruforce [ i ] , x [ p ] , y [ p ] ) ;
8783: LD_EXP 12
8787: PUSH
8788: LD_VAR 0 3
8792: ARRAY
8793: PPUSH
8794: LD_VAR 0 1
8798: PUSH
8799: LD_VAR 0 4
8803: ARRAY
8804: PPUSH
8805: LD_VAR 0 2
8809: PUSH
8810: LD_VAR 0 4
8814: ARRAY
8815: PPUSH
8816: CALL_OW 171
// AddComWait ( ruforce [ i ] , 0 0$09 ) ;
8820: LD_EXP 12
8824: PUSH
8825: LD_VAR 0 3
8829: ARRAY
8830: PPUSH
8831: LD_INT 315
8833: PPUSH
8834: CALL_OW 202
// end else
8838: GO 8888
// if GetDistUnitXY ( ruforce [ i ] , 76 , 12 ) > 72 then
8840: LD_EXP 12
8844: PUSH
8845: LD_VAR 0 3
8849: ARRAY
8850: PPUSH
8851: LD_INT 76
8853: PPUSH
8854: LD_INT 12
8856: PPUSH
8857: CALL_OW 297
8861: PUSH
8862: LD_INT 72
8864: GREATER
8865: IFFALSE 8888
// ComMoveXY ( ruforce [ i ] , 76 , 12 ) ;
8867: LD_EXP 12
8871: PUSH
8872: LD_VAR 0 3
8876: ARRAY
8877: PPUSH
8878: LD_INT 76
8880: PPUSH
8881: LD_INT 12
8883: PPUSH
8884: CALL_OW 111
// end else
8888: GO 8936
// ComAttackUnit ( ruforce [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , ruforce [ i ] ) ) ;
8890: LD_EXP 12
8894: PUSH
8895: LD_VAR 0 3
8899: ARRAY
8900: PPUSH
8901: LD_INT 22
8903: PUSH
8904: LD_INT 2
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PPUSH
8911: CALL_OW 69
8915: PPUSH
8916: LD_EXP 12
8920: PUSH
8921: LD_VAR 0 3
8925: ARRAY
8926: PPUSH
8927: CALL_OW 74
8931: PPUSH
8932: CALL_OW 115
// end ;
8936: GO 8707
8938: POP
8939: POP
// end ;
8940: GO 8675
// end ;
8942: PPOPN 4
8944: END
// every 0 0$01 trigger rupatrol do var i , p , x , y ;
8945: LD_EXP 11
8949: IFFALSE 9354
8951: GO 8953
8953: DISABLE
8954: LD_INT 0
8956: PPUSH
8957: PPUSH
8958: PPUSH
8959: PPUSH
// begin x := [ 66 , 157 ] ;
8960: LD_ADDR_VAR 0 3
8964: PUSH
8965: LD_INT 66
8967: PUSH
8968: LD_INT 157
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: ST_TO_ADDR
// y := [ 21 , 57 ] ;
8975: LD_ADDR_VAR 0 4
8979: PUSH
8980: LD_INT 21
8982: PUSH
8983: LD_INT 57
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// while ( rupatrol ) do
8990: LD_EXP 11
8994: IFFALSE 9354
// begin Wait ( 0 0$01 ) ;
8996: LD_INT 35
8998: PPUSH
8999: CALL_OW 67
// for i = 1 to rupatrol do
9003: LD_ADDR_VAR 0 1
9007: PUSH
9008: DOUBLE
9009: LD_INT 1
9011: DEC
9012: ST_TO_ADDR
9013: LD_EXP 11
9017: PUSH
9018: FOR_TO
9019: IFFALSE 9350
// begin if GetFuel ( rupatrol [ i ] ) < 30 then
9021: LD_EXP 11
9025: PUSH
9026: LD_VAR 0 1
9030: ARRAY
9031: PPUSH
9032: CALL_OW 261
9036: PUSH
9037: LD_INT 30
9039: LESS
9040: IFFALSE 9107
// begin ComMoveXY ( rupatrol [ i ] , 124 , 92 ) ;
9042: LD_EXP 11
9046: PUSH
9047: LD_VAR 0 1
9051: ARRAY
9052: PPUSH
9053: LD_INT 124
9055: PPUSH
9056: LD_INT 92
9058: PPUSH
9059: CALL_OW 111
// if GetDistUnits ( rupatrol [ i ] , ru_depot1 ) < 6 then
9063: LD_EXP 11
9067: PUSH
9068: LD_VAR 0 1
9072: ARRAY
9073: PPUSH
9074: LD_INT 123
9076: PPUSH
9077: CALL_OW 296
9081: PUSH
9082: LD_INT 6
9084: LESS
9085: IFFALSE 9105
// SetFuel ( rupatrol [ i ] , 100 ) ;
9087: LD_EXP 11
9091: PUSH
9092: LD_VAR 0 1
9096: ARRAY
9097: PPUSH
9098: LD_INT 100
9100: PPUSH
9101: CALL_OW 240
// end else
9105: GO 9300
// if not HasTask ( rupatrol [ i ] ) then
9107: LD_EXP 11
9111: PUSH
9112: LD_VAR 0 1
9116: ARRAY
9117: PPUSH
9118: CALL_OW 314
9122: NOT
9123: IFFALSE 9234
// begin AddComMoveXY ( rupatrol [ i ] , x [ i ] , y [ i ] ) ;
9125: LD_EXP 11
9129: PUSH
9130: LD_VAR 0 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 3
9140: PUSH
9141: LD_VAR 0 1
9145: ARRAY
9146: PPUSH
9147: LD_VAR 0 4
9151: PUSH
9152: LD_VAR 0 1
9156: ARRAY
9157: PPUSH
9158: CALL_OW 171
// AddComWait ( rupatrol [ i ] , Rand ( 0 0$01 , 0 0$21 ) ) ;
9162: LD_EXP 11
9166: PUSH
9167: LD_VAR 0 1
9171: ARRAY
9172: PPUSH
9173: LD_INT 35
9175: PPUSH
9176: LD_INT 735
9178: PPUSH
9179: CALL_OW 12
9183: PPUSH
9184: CALL_OW 202
// AddComMoveToArea ( rupatrol [ i ] , ru_patrol ) ;
9188: LD_EXP 11
9192: PUSH
9193: LD_VAR 0 1
9197: ARRAY
9198: PPUSH
9199: LD_INT 13
9201: PPUSH
9202: CALL_OW 173
// AddComWait ( rupatrol [ i ] , Rand ( 0 0$01 , 0 0$11 ) ) ;
9206: LD_EXP 11
9210: PUSH
9211: LD_VAR 0 1
9215: ARRAY
9216: PPUSH
9217: LD_INT 35
9219: PPUSH
9220: LD_INT 385
9222: PPUSH
9223: CALL_OW 12
9227: PPUSH
9228: CALL_OW 202
// end else
9232: GO 9300
// if See ( 2 , rupatrol [ i ] ) then
9234: LD_INT 2
9236: PPUSH
9237: LD_EXP 11
9241: PUSH
9242: LD_VAR 0 1
9246: ARRAY
9247: PPUSH
9248: CALL_OW 292
9252: IFFALSE 9300
// ComAttackUnit ( rupatrol [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , rupatrol [ i ] ) ) ;
9254: LD_EXP 11
9258: PUSH
9259: LD_VAR 0 1
9263: ARRAY
9264: PPUSH
9265: LD_INT 22
9267: PUSH
9268: LD_INT 2
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: PPUSH
9275: CALL_OW 69
9279: PPUSH
9280: LD_EXP 11
9284: PUSH
9285: LD_VAR 0 1
9289: ARRAY
9290: PPUSH
9291: CALL_OW 74
9295: PPUSH
9296: CALL_OW 115
// if GetDistUnitXY ( rupatrol [ i ] , 94 , 60 ) > 72 then
9300: LD_EXP 11
9304: PUSH
9305: LD_VAR 0 1
9309: ARRAY
9310: PPUSH
9311: LD_INT 94
9313: PPUSH
9314: LD_INT 60
9316: PPUSH
9317: CALL_OW 297
9321: PUSH
9322: LD_INT 72
9324: GREATER
9325: IFFALSE 9348
// ComMoveXY ( rupatrol [ i ] , 94 , 60 ) ;
9327: LD_EXP 11
9331: PUSH
9332: LD_VAR 0 1
9336: ARRAY
9337: PPUSH
9338: LD_INT 94
9340: PPUSH
9341: LD_INT 60
9343: PPUSH
9344: CALL_OW 111
// end ;
9348: GO 9018
9350: POP
9351: POP
// end ;
9352: GO 8990
// end ;
9354: PPOPN 4
9356: END
// export function ProduceCrane ( fac ) ; begin
9357: LD_INT 0
9359: PPUSH
// if FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_computer ] ] ) and FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_noncombat ] ] ) then
9360: LD_INT 22
9362: PUSH
9363: LD_VAR 0 1
9367: PPUSH
9368: CALL_OW 255
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 30
9379: PUSH
9380: LD_INT 24
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: PPUSH
9391: CALL_OW 69
9395: PUSH
9396: LD_INT 22
9398: PUSH
9399: LD_VAR 0 1
9403: PPUSH
9404: CALL_OW 255
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: LD_INT 30
9415: PUSH
9416: LD_INT 19
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: AND
9432: IFFALSE 9457
// ComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_computer , ru_crane ) else
9434: LD_VAR 0 1
9438: PPUSH
9439: LD_INT 21
9441: PPUSH
9442: LD_INT 1
9444: PPUSH
9445: LD_INT 3
9447: PPUSH
9448: LD_INT 52
9450: PPUSH
9451: CALL_OW 125
9455: GO 9465
// result = false ;
9457: LD_ADDR_VAR 0 2
9461: PUSH
9462: LD_INT 0
9464: ST_TO_ADDR
// end ;
9465: LD_VAR 0 2
9469: RET
// export function ProduceCargoBay ( fac ) ; begin
9470: LD_INT 0
9472: PPUSH
// if FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_computer ] ] ) and FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_noncombat ] ] ) then
9473: LD_INT 22
9475: PUSH
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 255
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: PUSH
9490: LD_INT 30
9492: PUSH
9493: LD_INT 24
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PPUSH
9504: CALL_OW 69
9508: PUSH
9509: LD_INT 22
9511: PUSH
9512: LD_VAR 0 1
9516: PPUSH
9517: CALL_OW 255
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 30
9528: PUSH
9529: LD_INT 19
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: AND
9545: IFFALSE 9570
// ComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ) else
9547: LD_VAR 0 1
9551: PPUSH
9552: LD_INT 21
9554: PPUSH
9555: LD_INT 1
9557: PPUSH
9558: LD_INT 3
9560: PPUSH
9561: LD_INT 51
9563: PPUSH
9564: CALL_OW 125
9568: GO 9578
// result = false ;
9570: LD_ADDR_VAR 0 2
9574: PUSH
9575: LD_INT 0
9577: ST_TO_ADDR
// end ;
9578: LD_VAR 0 2
9582: RET
// export function ProduceBulldozer ( fac ) ; begin
9583: LD_INT 0
9585: PPUSH
// if FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_computer ] ] ) and FilterAllUnits ( [ [ f_side , GetSide ( fac ) ] , [ f_btype , b_ext_noncombat ] ] ) then
9586: LD_INT 22
9588: PUSH
9589: LD_VAR 0 1
9593: PPUSH
9594: CALL_OW 255
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PUSH
9603: LD_INT 30
9605: PUSH
9606: LD_INT 24
9608: PUSH
9609: EMPTY
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL_OW 69
9621: PUSH
9622: LD_INT 22
9624: PUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 255
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PUSH
9639: LD_INT 30
9641: PUSH
9642: LD_INT 19
9644: PUSH
9645: EMPTY
9646: LIST
9647: LIST
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: PPUSH
9653: CALL_OW 69
9657: AND
9658: IFFALSE 9683
// ComConstruct ( fac , ru_heavy_wheeled , engine_combustion , control_computer , ru_bulldozer ) else
9660: LD_VAR 0 1
9664: PPUSH
9665: LD_INT 23
9667: PPUSH
9668: LD_INT 1
9670: PPUSH
9671: LD_INT 3
9673: PPUSH
9674: LD_INT 53
9676: PPUSH
9677: CALL_OW 125
9681: GO 9691
// result = false ;
9683: LD_ADDR_VAR 0 2
9687: PUSH
9688: LD_INT 0
9690: ST_TO_ADDR
// end ;
9691: LD_VAR 0 2
9695: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
9696: LD_INT 0
9698: PPUSH
9699: PPUSH
// area = ListEnvironmentArea ( area ) ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_VAR 0 2
9709: PPUSH
9710: CALL_OW 353
9714: ST_TO_ADDR
// if bulldozer > 0 then
9715: LD_VAR 0 1
9719: PUSH
9720: LD_INT 0
9722: GREATER
9723: IFFALSE 9834
// for i = 1 to area do
9725: LD_ADDR_VAR 0 4
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 2
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9832
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
9743: LD_VAR 0 2
9747: PUSH
9748: LD_VAR 0 4
9752: ARRAY
9753: PUSH
9754: LD_INT 1
9756: ARRAY
9757: PPUSH
9758: LD_VAR 0 2
9762: PUSH
9763: LD_VAR 0 4
9767: ARRAY
9768: PUSH
9769: LD_INT 2
9771: ARRAY
9772: PPUSH
9773: CALL_OW 351
9777: IFFALSE 9830
// if not HasTask ( bulldozer ) then
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 314
9788: NOT
9789: IFFALSE 9830
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_VAR 0 2
9800: PUSH
9801: LD_VAR 0 4
9805: ARRAY
9806: PUSH
9807: LD_INT 1
9809: ARRAY
9810: PPUSH
9811: LD_VAR 0 2
9815: PUSH
9816: LD_VAR 0 4
9820: ARRAY
9821: PUSH
9822: LD_INT 2
9824: ARRAY
9825: PPUSH
9826: CALL_OW 171
9830: GO 9740
9832: POP
9833: POP
// end ;
9834: LD_VAR 0 3
9838: RET
// export function ProduceNewCombatCar ( fac ) ; var chassis , weapon , w1 , w2 ; begin
9839: LD_INT 0
9841: PPUSH
9842: PPUSH
9843: PPUSH
9844: PPUSH
9845: PPUSH
// weapon := [ ru_gun , ru_rocket_launcher , ru_heavy_gun ] ;
9846: LD_ADDR_VAR 0 4
9850: PUSH
9851: LD_INT 44
9853: PUSH
9854: LD_INT 45
9856: PUSH
9857: LD_INT 46
9859: PUSH
9860: EMPTY
9861: LIST
9862: LIST
9863: LIST
9864: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] ;
9865: LD_ADDR_VAR 0 3
9869: PUSH
9870: LD_INT 22
9872: PUSH
9873: LD_INT 24
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: ST_TO_ADDR
// w1 := Rand ( 1 , weapon ) ;
9880: LD_ADDR_VAR 0 5
9884: PUSH
9885: LD_INT 1
9887: PPUSH
9888: LD_VAR 0 4
9892: PPUSH
9893: CALL_OW 12
9897: ST_TO_ADDR
// if weapon [ w1 ] <> ru_heavy_gun then
9898: LD_VAR 0 4
9902: PUSH
9903: LD_VAR 0 5
9907: ARRAY
9908: PUSH
9909: LD_INT 46
9911: NONEQUAL
9912: IFFALSE 9934
// w2 := Rand ( 1 , chassis ) else
9914: LD_ADDR_VAR 0 6
9918: PUSH
9919: LD_INT 1
9921: PPUSH
9922: LD_VAR 0 3
9926: PPUSH
9927: CALL_OW 12
9931: ST_TO_ADDR
9932: GO 9942
// w2 := 2 ;
9934: LD_ADDR_VAR 0 6
9938: PUSH
9939: LD_INT 2
9941: ST_TO_ADDR
// if fac = FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_ext_computer ] ] ) then
9942: LD_VAR 0 1
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: PUSH
9976: LD_INT 1
9978: ARRAY
9979: EQUAL
9980: PUSH
9981: LD_INT 22
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 30
9993: PUSH
9994: LD_INT 24
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: PPUSH
10005: CALL_OW 69
10009: AND
10010: IFFALSE 10084
// begin rvehlist := rvehlist ^ chassis [ w2 ] ;
10012: LD_ADDR_EXP 14
10016: PUSH
10017: LD_EXP 14
10021: PUSH
10022: LD_VAR 0 3
10026: PUSH
10027: LD_VAR 0 6
10031: ARRAY
10032: ADD
10033: ST_TO_ADDR
// rvehlist := rvehlist ^ engine_combustion ;
10034: LD_ADDR_EXP 14
10038: PUSH
10039: LD_EXP 14
10043: PUSH
10044: LD_INT 1
10046: ADD
10047: ST_TO_ADDR
// rvehlist := rvehlist ^ control_computer ;
10048: LD_ADDR_EXP 14
10052: PUSH
10053: LD_EXP 14
10057: PUSH
10058: LD_INT 3
10060: ADD
10061: ST_TO_ADDR
// rvehlist := rvehlist ^ weapon [ w1 ] ;
10062: LD_ADDR_EXP 14
10066: PUSH
10067: LD_EXP 14
10071: PUSH
10072: LD_VAR 0 4
10076: PUSH
10077: LD_VAR 0 5
10081: ARRAY
10082: ADD
10083: ST_TO_ADDR
// end ; if fac = FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) [ 1 ] and FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_ext_computer ] ] ) then
10084: LD_VAR 0 1
10088: PUSH
10089: LD_INT 22
10091: PUSH
10092: LD_INT 6
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: PUSH
10099: LD_INT 30
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: EMPTY
10106: LIST
10107: LIST
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: PPUSH
10113: CALL_OW 69
10117: PUSH
10118: LD_INT 1
10120: ARRAY
10121: EQUAL
10122: PUSH
10123: LD_INT 22
10125: PUSH
10126: LD_INT 6
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: PUSH
10133: LD_INT 30
10135: PUSH
10136: LD_INT 24
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PPUSH
10147: CALL_OW 69
10151: AND
10152: IFFALSE 10226
// begin r2vehlist := r2vehlist ^ chassis [ w2 ] ;
10154: LD_ADDR_EXP 16
10158: PUSH
10159: LD_EXP 16
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: LD_VAR 0 6
10173: ARRAY
10174: ADD
10175: ST_TO_ADDR
// r2vehlist := r2vehlist ^ engine_combustion ;
10176: LD_ADDR_EXP 16
10180: PUSH
10181: LD_EXP 16
10185: PUSH
10186: LD_INT 1
10188: ADD
10189: ST_TO_ADDR
// r2vehlist := r2vehlist ^ control_computer ;
10190: LD_ADDR_EXP 16
10194: PUSH
10195: LD_EXP 16
10199: PUSH
10200: LD_INT 3
10202: ADD
10203: ST_TO_ADDR
// r2vehlist := r2vehlist ^ weapon [ w1 ] ;
10204: LD_ADDR_EXP 16
10208: PUSH
10209: LD_EXP 16
10213: PUSH
10214: LD_VAR 0 4
10218: PUSH
10219: LD_VAR 0 5
10223: ARRAY
10224: ADD
10225: ST_TO_ADDR
// end ; end ;
10226: LD_VAR 0 2
10230: RET
// export function IntBazooka ( list , filter ) ; var ta , c , i ; begin
10231: LD_INT 0
10233: PPUSH
10234: PPUSH
10235: PPUSH
10236: PPUSH
// c := Rand ( 1 , 3 ) ;
10237: LD_ADDR_VAR 0 5
10241: PUSH
10242: LD_INT 1
10244: PPUSH
10245: LD_INT 3
10247: PPUSH
10248: CALL_OW 12
10252: ST_TO_ADDR
// for i = 1 to list do
10253: LD_ADDR_VAR 0 6
10257: PUSH
10258: DOUBLE
10259: LD_INT 1
10261: DEC
10262: ST_TO_ADDR
10263: LD_VAR 0 1
10267: PUSH
10268: FOR_TO
10269: IFFALSE 10451
// for ta in filter do
10271: LD_ADDR_VAR 0 4
10275: PUSH
10276: LD_VAR 0 2
10280: PUSH
10281: FOR_IN
10282: IFFALSE 10447
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10284: LD_VAR 0 1
10288: PUSH
10289: LD_VAR 0 6
10293: ARRAY
10294: PPUSH
10295: LD_VAR 0 4
10299: PPUSH
10300: CALL_OW 296
10304: PUSH
10305: LD_INT 13
10307: LESSEQUAL
10308: IFFALSE 10445
// begin case c of 1 :
10310: LD_VAR 0 5
10314: PUSH
10315: LD_INT 1
10317: DOUBLE
10318: EQUAL
10319: IFTRUE 10323
10321: GO 10361
10323: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10324: LD_VAR 0 1
10328: PUSH
10329: LD_VAR 0 6
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 4
10339: PPUSH
10340: CALL_OW 250
10344: PPUSH
10345: LD_VAR 0 4
10349: PPUSH
10350: CALL_OW 251
10354: PPUSH
10355: CALL_OW 154
10359: GO 10445
10361: LD_INT 2
10363: DOUBLE
10364: EQUAL
10365: IFTRUE 10369
10367: GO 10433
10369: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10370: LD_VAR 0 1
10374: PUSH
10375: LD_VAR 0 6
10379: ARRAY
10380: PPUSH
10381: LD_VAR 0 4
10385: PPUSH
10386: CALL_OW 250
10390: PUSH
10391: LD_INT 1
10393: NEG
10394: PPUSH
10395: LD_INT 1
10397: PPUSH
10398: CALL_OW 12
10402: PLUS
10403: PPUSH
10404: LD_VAR 0 4
10408: PPUSH
10409: CALL_OW 251
10413: PUSH
10414: LD_INT 1
10416: NEG
10417: PPUSH
10418: LD_INT 1
10420: PPUSH
10421: CALL_OW 12
10425: PLUS
10426: PPUSH
10427: CALL_OW 153
10431: GO 10445
10433: LD_INT 3
10435: DOUBLE
10436: EQUAL
10437: IFTRUE 10441
10439: GO 10444
10441: POP
// ; end ;
10442: GO 10445
10444: POP
// end ; end ;
10445: GO 10281
10447: POP
10448: POP
10449: GO 10268
10451: POP
10452: POP
// end ;
10453: LD_VAR 0 3
10457: RET
// every 4 4$00 trigger FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] , [ f_weapon , ru_bulldozer ] ] ] ] ] ) >= ruamo and dont_attack = false do var i , un , filter ;
10458: LD_INT 2
10460: PUSH
10461: LD_INT 22
10463: PUSH
10464: LD_INT 6
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PUSH
10471: LD_INT 22
10473: PUSH
10474: LD_INT 3
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 21
10488: PUSH
10489: LD_INT 2
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: PUSH
10496: LD_INT 3
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: LD_INT 34
10504: PUSH
10505: LD_INT 51
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 34
10514: PUSH
10515: LD_INT 52
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: PUSH
10522: LD_INT 34
10524: PUSH
10525: LD_INT 53
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: PUSH
10555: LD_EXP 18
10559: GREATEREQUAL
10560: PUSH
10561: LD_EXP 25
10565: PUSH
10566: LD_INT 0
10568: EQUAL
10569: AND
10570: IFFALSE 10927
10572: GO 10574
10574: DISABLE
10575: LD_INT 0
10577: PPUSH
10578: PPUSH
10579: PPUSH
// begin enable ;
10580: ENABLE
// filter := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_bulldozer ] ] ] ) ;
10581: LD_ADDR_VAR 0 3
10585: PUSH
10586: LD_INT 2
10588: PUSH
10589: LD_INT 22
10591: PUSH
10592: LD_INT 6
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: PUSH
10599: LD_INT 22
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: EMPTY
10606: LIST
10607: LIST
10608: PUSH
10609: EMPTY
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: LD_INT 21
10616: PUSH
10617: LD_INT 2
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: LD_INT 34
10629: PUSH
10630: LD_INT 53
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: LIST
10645: PPUSH
10646: CALL_OW 69
10650: ST_TO_ADDR
// for i = 1 to filter do
10651: LD_ADDR_VAR 0 1
10655: PUSH
10656: DOUBLE
10657: LD_INT 1
10659: DEC
10660: ST_TO_ADDR
10661: LD_VAR 0 3
10665: PUSH
10666: FOR_TO
10667: IFFALSE 10735
// if not HasTask ( filter [ i ] ) then
10669: LD_VAR 0 3
10673: PUSH
10674: LD_VAR 0 1
10678: ARRAY
10679: PPUSH
10680: CALL_OW 314
10684: NOT
10685: IFFALSE 10733
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , filter [ i ] ) ) ;
10687: LD_VAR 0 3
10691: PUSH
10692: LD_VAR 0 1
10696: ARRAY
10697: PPUSH
10698: LD_INT 22
10700: PUSH
10701: LD_INT 2
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PPUSH
10708: CALL_OW 69
10712: PPUSH
10713: LD_VAR 0 3
10717: PUSH
10718: LD_VAR 0 1
10722: ARRAY
10723: PPUSH
10724: CALL_OW 74
10728: PPUSH
10729: CALL_OW 115
10733: GO 10666
10735: POP
10736: POP
// while ( UnitFilter ( filter , [ f_inarea , ru_at ] ) > 0 ) do
10737: LD_VAR 0 3
10741: PPUSH
10742: LD_INT 95
10744: PUSH
10745: LD_INT 19
10747: PUSH
10748: EMPTY
10749: LIST
10750: LIST
10751: PPUSH
10752: CALL_OW 72
10756: PUSH
10757: LD_INT 0
10759: GREATER
10760: IFFALSE 10927
// begin Wait ( 0 0$02 ) ;
10762: LD_INT 70
10764: PPUSH
10765: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_or , [ f_side , 6 ] , [ f_side , 3 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_bulldozer ] ] ] ) ;
10769: LD_ADDR_VAR 0 3
10773: PUSH
10774: LD_INT 2
10776: PUSH
10777: LD_INT 22
10779: PUSH
10780: LD_INT 6
10782: PUSH
10783: EMPTY
10784: LIST
10785: LIST
10786: PUSH
10787: LD_INT 22
10789: PUSH
10790: LD_INT 3
10792: PUSH
10793: EMPTY
10794: LIST
10795: LIST
10796: PUSH
10797: EMPTY
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 21
10804: PUSH
10805: LD_INT 2
10807: PUSH
10808: EMPTY
10809: LIST
10810: LIST
10811: PUSH
10812: LD_INT 3
10814: PUSH
10815: LD_INT 34
10817: PUSH
10818: LD_INT 53
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: EMPTY
10830: LIST
10831: LIST
10832: LIST
10833: PPUSH
10834: CALL_OW 69
10838: ST_TO_ADDR
// for i = 1 to filter do
10839: LD_ADDR_VAR 0 1
10843: PUSH
10844: DOUBLE
10845: LD_INT 1
10847: DEC
10848: ST_TO_ADDR
10849: LD_VAR 0 3
10853: PUSH
10854: FOR_TO
10855: IFFALSE 10923
// if not HasTask ( filter [ i ] ) then
10857: LD_VAR 0 3
10861: PUSH
10862: LD_VAR 0 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 314
10872: NOT
10873: IFFALSE 10921
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , filter [ i ] ) ) ;
10875: LD_VAR 0 3
10879: PUSH
10880: LD_VAR 0 1
10884: ARRAY
10885: PPUSH
10886: LD_INT 22
10888: PUSH
10889: LD_INT 2
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: PPUSH
10896: CALL_OW 69
10900: PPUSH
10901: LD_VAR 0 3
10905: PUSH
10906: LD_VAR 0 1
10910: ARRAY
10911: PPUSH
10912: CALL_OW 74
10916: PPUSH
10917: CALL_OW 115
10921: GO 10854
10923: POP
10924: POP
// end ;
10925: GO 10737
// end ;
10927: PPOPN 3
10929: END
// every 0 0$01 trigger ru_sforce > 0 do var i , filter ;
10930: LD_EXP 19
10934: PUSH
10935: LD_INT 0
10937: GREATER
10938: IFFALSE 11034
10940: GO 10942
10942: DISABLE
10943: LD_INT 0
10945: PPUSH
10946: PPUSH
// begin enable ;
10947: ENABLE
// for i = 1 to ru_sforce do
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: DOUBLE
10954: LD_INT 1
10956: DEC
10957: ST_TO_ADDR
10958: LD_EXP 19
10962: PUSH
10963: FOR_TO
10964: IFFALSE 11032
// if not HasTask ( ru_sforce [ i ] ) then
10966: LD_EXP 19
10970: PUSH
10971: LD_VAR 0 1
10975: ARRAY
10976: PPUSH
10977: CALL_OW 314
10981: NOT
10982: IFFALSE 11030
// ComAttackUnit ( ru_sforce [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , ru_sforce [ i ] ) ) ;
10984: LD_EXP 19
10988: PUSH
10989: LD_VAR 0 1
10993: ARRAY
10994: PPUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 2
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PPUSH
11010: LD_EXP 19
11014: PUSH
11015: LD_VAR 0 1
11019: ARRAY
11020: PPUSH
11021: CALL_OW 74
11025: PPUSH
11026: CALL_OW 115
11030: GO 10963
11032: POP
11033: POP
// end ;
11034: PPOPN 2
11036: END
// every 0 0$01 trigger tick >= 35 * 60 * 7 do
11037: LD_OWVAR 1
11041: PUSH
11042: LD_INT 35
11044: PUSH
11045: LD_INT 60
11047: MUL
11048: PUSH
11049: LD_INT 7
11051: MUL
11052: GREATEREQUAL
11053: IFFALSE 11132
11055: GO 11057
11057: DISABLE
// begin if FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) = 0 then
11058: LD_INT 34
11060: PUSH
11061: LD_INT 53
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: PPUSH
11068: CALL_OW 69
11072: PUSH
11073: LD_INT 0
11075: EQUAL
11076: IFFALSE 11085
// ProduceBulldozer ( ru_fac ) ;
11078: LD_INT 71
11080: PPUSH
11081: CALL 9583 0 1
// Wait ( 1 1$00 ) ;
11085: LD_INT 2100
11087: PPUSH
11088: CALL_OW 67
// CutTreeInArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) [ 1 ] , tree1 ) ;
11092: LD_INT 22
11094: PUSH
11095: LD_INT 3
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: LD_INT 34
11104: PUSH
11105: LD_INT 53
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PUSH
11112: EMPTY
11113: LIST
11114: LIST
11115: PPUSH
11116: CALL_OW 69
11120: PUSH
11121: LD_INT 1
11123: ARRAY
11124: PPUSH
11125: LD_INT 8
11127: PPUSH
11128: CALL 9696 0 2
// end ;
11132: END
// every 0 0$01 trigger tick >= 35 * 60 * 10 do
11133: LD_OWVAR 1
11137: PUSH
11138: LD_INT 35
11140: PUSH
11141: LD_INT 60
11143: MUL
11144: PUSH
11145: LD_INT 10
11147: MUL
11148: GREATEREQUAL
11149: IFFALSE 11228
11151: GO 11153
11153: DISABLE
// begin if FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) = 0 then
11154: LD_INT 34
11156: PUSH
11157: LD_INT 53
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PPUSH
11164: CALL_OW 69
11168: PUSH
11169: LD_INT 0
11171: EQUAL
11172: IFFALSE 11181
// ProduceBulldozer ( ru_fac ) ;
11174: LD_INT 71
11176: PPUSH
11177: CALL 9583 0 1
// Wait ( 1 1$00 ) ;
11181: LD_INT 2100
11183: PPUSH
11184: CALL_OW 67
// CutTreeInArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) [ 1 ] , tree2 ) ;
11188: LD_INT 22
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 34
11200: PUSH
11201: LD_INT 53
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PPUSH
11212: CALL_OW 69
11216: PUSH
11217: LD_INT 1
11219: ARRAY
11220: PPUSH
11221: LD_INT 9
11223: PPUSH
11224: CALL 9696 0 2
// end ;
11228: END
// export bulldog ; every 0 0$01 trigger tick >= 35 * 60 * 16 do
11229: LD_OWVAR 1
11233: PUSH
11234: LD_INT 35
11236: PUSH
11237: LD_INT 60
11239: MUL
11240: PUSH
11241: LD_INT 16
11243: MUL
11244: GREATEREQUAL
11245: IFFALSE 11258
11247: GO 11249
11249: DISABLE
// bulldog := 0 ;
11250: LD_ADDR_EXP 26
11254: PUSH
11255: LD_INT 0
11257: ST_TO_ADDR
11258: END
// every 6 6$00 trigger tick >= 35 * 60 * 16 and bulldog < Difficulty do
11259: LD_OWVAR 1
11263: PUSH
11264: LD_INT 35
11266: PUSH
11267: LD_INT 60
11269: MUL
11270: PUSH
11271: LD_INT 16
11273: MUL
11274: GREATEREQUAL
11275: PUSH
11276: LD_EXP 26
11280: PUSH
11281: LD_OWVAR 67
11285: LESS
11286: AND
11287: IFFALSE 11381
11289: GO 11291
11291: DISABLE
// begin enable ;
11292: ENABLE
// bulldog := bulldog + 1 ;
11293: LD_ADDR_EXP 26
11297: PUSH
11298: LD_EXP 26
11302: PUSH
11303: LD_INT 1
11305: PLUS
11306: ST_TO_ADDR
// if FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) = 0 then
11307: LD_INT 34
11309: PUSH
11310: LD_INT 53
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PPUSH
11317: CALL_OW 69
11321: PUSH
11322: LD_INT 0
11324: EQUAL
11325: IFFALSE 11334
// ProduceBulldozer ( ru_fac ) ;
11327: LD_INT 71
11329: PPUSH
11330: CALL 9583 0 1
// Wait ( 2 2$00 ) ;
11334: LD_INT 4200
11336: PPUSH
11337: CALL_OW 67
// CutTreeInArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) [ 1 ] , tree3 ) ;
11341: LD_INT 22
11343: PUSH
11344: LD_INT 3
11346: PUSH
11347: EMPTY
11348: LIST
11349: LIST
11350: PUSH
11351: LD_INT 34
11353: PUSH
11354: LD_INT 53
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PUSH
11361: EMPTY
11362: LIST
11363: LIST
11364: PPUSH
11365: CALL_OW 69
11369: PUSH
11370: LD_INT 1
11372: ARRAY
11373: PPUSH
11374: LD_INT 10
11376: PPUSH
11377: CALL 9696 0 2
// end ;
11381: END
// every 5 5$30 trigger in_base and ruamo < [ 8 , 10 , 12 ] [ Difficulty ] do var i ;
11382: LD_EXP 28
11386: PUSH
11387: LD_EXP 18
11391: PUSH
11392: LD_INT 8
11394: PUSH
11395: LD_INT 10
11397: PUSH
11398: LD_INT 12
11400: PUSH
11401: EMPTY
11402: LIST
11403: LIST
11404: LIST
11405: PUSH
11406: LD_OWVAR 67
11410: ARRAY
11411: LESS
11412: AND
11413: IFFALSE 11457
11415: GO 11417
11417: DISABLE
11418: LD_INT 0
11420: PPUSH
// begin for i = 1 to ruamo do
11421: LD_ADDR_VAR 0 1
11425: PUSH
11426: DOUBLE
11427: LD_INT 1
11429: DEC
11430: ST_TO_ADDR
11431: LD_EXP 18
11435: PUSH
11436: FOR_TO
11437: IFFALSE 11455
// begin ProduceNewCombatCar ( ru_fac ) ;
11439: LD_INT 71
11441: PPUSH
11442: CALL 9839 0 1
// ProduceNewCombatCar ( ru_fac2 ) ;
11446: LD_INT 172
11448: PPUSH
11449: CALL 9839 0 1
// end ;
11453: GO 11436
11455: POP
11456: POP
// end ;
11457: PPOPN 1
11459: END
// every 30 30$00 do var i ;
11460: GO 11462
11462: DISABLE
11463: LD_INT 0
11465: PPUSH
// begin for i = 1 to [ 1 , 1 , 2 ] [ Difficulty ] do
11466: LD_ADDR_VAR 0 1
11470: PUSH
11471: DOUBLE
11472: LD_INT 1
11474: DEC
11475: ST_TO_ADDR
11476: LD_INT 1
11478: PUSH
11479: LD_INT 1
11481: PUSH
11482: LD_INT 2
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: LIST
11489: PUSH
11490: LD_OWVAR 67
11494: ARRAY
11495: PUSH
11496: FOR_TO
11497: IFFALSE 11515
// begin ProduceNewCombatCar ( ru_fac ) ;
11499: LD_INT 71
11501: PPUSH
11502: CALL 9839 0 1
// ProduceNewCombatCar ( ru_fac2 ) ;
11506: LD_INT 172
11508: PPUSH
11509: CALL 9839 0 1
// end ;
11513: GO 11496
11515: POP
11516: POP
// end ;
11517: PPOPN 1
11519: END
// every 50 50$00 do var i ;
11520: GO 11522
11522: DISABLE
11523: LD_INT 0
11525: PPUSH
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
11526: LD_ADDR_VAR 0 1
11530: PUSH
11531: DOUBLE
11532: LD_INT 1
11534: DEC
11535: ST_TO_ADDR
11536: LD_INT 2
11538: PUSH
11539: LD_INT 3
11541: PUSH
11542: LD_INT 4
11544: PUSH
11545: EMPTY
11546: LIST
11547: LIST
11548: LIST
11549: PUSH
11550: LD_OWVAR 67
11554: ARRAY
11555: PUSH
11556: FOR_TO
11557: IFFALSE 11575
// begin ProduceNewCombatCar ( ru_fac ) ;
11559: LD_INT 71
11561: PPUSH
11562: CALL 9839 0 1
// ProduceNewCombatCar ( ru_fac2 ) ;
11566: LD_INT 172
11568: PPUSH
11569: CALL 9839 0 1
// end ;
11573: GO 11556
11575: POP
11576: POP
// end ;
11577: PPOPN 1
11579: END
// every 16 16$00 trigger Difficulty > 1 do var i , un ;
11580: LD_OWVAR 67
11584: PUSH
11585: LD_INT 1
11587: GREATER
11588: IFFALSE 11723
11590: GO 11592
11592: DISABLE
11593: LD_INT 0
11595: PPUSH
11596: PPUSH
// begin enable ;
11597: ENABLE
// uc_side := 3 ;
11598: LD_ADDR_OWVAR 20
11602: PUSH
11603: LD_INT 3
11605: ST_TO_ADDR
// uc_nation := 3 ;
11606: LD_ADDR_OWVAR 21
11610: PUSH
11611: LD_INT 3
11613: ST_TO_ADDR
// for i = 1 to [ 1 , 4 , 7 ] [ Difficulty ] do
11614: LD_ADDR_VAR 0 1
11618: PUSH
11619: DOUBLE
11620: LD_INT 1
11622: DEC
11623: ST_TO_ADDR
11624: LD_INT 1
11626: PUSH
11627: LD_INT 4
11629: PUSH
11630: LD_INT 7
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: LIST
11637: PUSH
11638: LD_OWVAR 67
11642: ARRAY
11643: PUSH
11644: FOR_TO
11645: IFFALSE 11721
// begin un := CreateHumanWithClass ( [ class_soldier , class_bazooker ] [ Rand ( 1 , 2 ) ] , rskill - 1 ) ;
11647: LD_ADDR_VAR 0 2
11651: PUSH
11652: LD_INT 1
11654: PUSH
11655: LD_INT 9
11657: PUSH
11658: EMPTY
11659: LIST
11660: LIST
11661: PUSH
11662: LD_INT 1
11664: PPUSH
11665: LD_INT 2
11667: PPUSH
11668: CALL_OW 12
11672: ARRAY
11673: PPUSH
11674: LD_EXP 13
11678: PUSH
11679: LD_INT 1
11681: MINUS
11682: PPUSH
11683: CALL 1017 0 2
11687: ST_TO_ADDR
// ru_sforce := ru_sforce ^ un ;
11688: LD_ADDR_EXP 19
11692: PUSH
11693: LD_EXP 19
11697: PUSH
11698: LD_VAR 0 2
11702: ADD
11703: ST_TO_ADDR
// PlaceUnitArea ( un , ru_north_spawn , false ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 17
11711: PPUSH
11712: LD_INT 0
11714: PPUSH
11715: CALL_OW 49
// end ;
11719: GO 11644
11721: POP
11722: POP
// end ;
11723: PPOPN 2
11725: END
// every 0 0$03 do var i , c , p , skr , filter , cargo , dep ;
11726: GO 11728
11728: DISABLE
11729: LD_INT 0
11731: PPUSH
11732: PPUSH
11733: PPUSH
11734: PPUSH
11735: PPUSH
11736: PPUSH
11737: PPUSH
// begin enable ;
11738: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11739: LD_ADDR_VAR 0 5
11743: PUSH
11744: LD_INT 50
11746: PUSH
11747: EMPTY
11748: LIST
11749: PUSH
11750: LD_INT 2
11752: PUSH
11753: LD_INT 22
11755: PUSH
11756: LD_INT 3
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 22
11765: PUSH
11766: LD_INT 6
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: LIST
11777: PUSH
11778: LD_INT 2
11780: PUSH
11781: LD_INT 25
11783: PUSH
11784: LD_INT 2
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 25
11793: PUSH
11794: LD_INT 16
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: LIST
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: LIST
11810: PPUSH
11811: CALL_OW 69
11815: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11816: LD_ADDR_VAR 0 6
11820: PUSH
11821: LD_INT 2
11823: PUSH
11824: LD_INT 22
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 22
11836: PUSH
11837: LD_INT 6
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 34
11851: PUSH
11852: LD_INT 51
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 69
11867: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11868: LD_ADDR_VAR 0 7
11872: PUSH
11873: LD_INT 2
11875: PUSH
11876: LD_INT 22
11878: PUSH
11879: LD_INT 3
11881: PUSH
11882: EMPTY
11883: LIST
11884: LIST
11885: PUSH
11886: LD_INT 22
11888: PUSH
11889: LD_INT 6
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: LIST
11900: PUSH
11901: LD_INT 2
11903: PUSH
11904: LD_INT 30
11906: PUSH
11907: LD_INT 0
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: LD_INT 30
11916: PUSH
11917: LD_INT 1
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: LIST
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PPUSH
11933: CALL_OW 69
11937: ST_TO_ADDR
// skr = GetListOfCratesInArea ( super_crates ) ;
11938: LD_ADDR_VAR 0 4
11942: PUSH
11943: LD_INT 20
11945: PPUSH
11946: CALL_OW 435
11950: ST_TO_ADDR
// c = 1 ;
11951: LD_ADDR_VAR 0 2
11955: PUSH
11956: LD_INT 1
11958: ST_TO_ADDR
// while c < skr do
11959: LD_VAR 0 2
11963: PUSH
11964: LD_VAR 0 4
11968: LESS
11969: IFFALSE 12249
// begin if cargo = 0 then
11971: LD_VAR 0 6
11975: PUSH
11976: LD_INT 0
11978: EQUAL
11979: IFFALSE 12074
// begin for p = 1 to 2 do
11981: LD_ADDR_VAR 0 3
11985: PUSH
11986: DOUBLE
11987: LD_INT 1
11989: DEC
11990: ST_TO_ADDR
11991: LD_INT 2
11993: PUSH
11994: FOR_TO
11995: IFFALSE 12058
// if not HasTask ( filter [ p ] ) then
11997: LD_VAR 0 5
12001: PUSH
12002: LD_VAR 0 3
12006: ARRAY
12007: PPUSH
12008: CALL_OW 314
12012: NOT
12013: IFFALSE 12056
// ComCollect ( filter [ p ] , skr [ c ] , skr [ c + 1 ] ) ;
12015: LD_VAR 0 5
12019: PUSH
12020: LD_VAR 0 3
12024: ARRAY
12025: PPUSH
12026: LD_VAR 0 4
12030: PUSH
12031: LD_VAR 0 2
12035: ARRAY
12036: PPUSH
12037: LD_VAR 0 4
12041: PUSH
12042: LD_VAR 0 2
12046: PUSH
12047: LD_INT 1
12049: PLUS
12050: ARRAY
12051: PPUSH
12052: CALL_OW 117
12056: GO 11994
12058: POP
12059: POP
// c = c + 2 ;
12060: LD_ADDR_VAR 0 2
12064: PUSH
12065: LD_VAR 0 2
12069: PUSH
12070: LD_INT 2
12072: PLUS
12073: ST_TO_ADDR
// end ; if cargo > 0 then
12074: LD_VAR 0 6
12078: PUSH
12079: LD_INT 0
12081: GREATER
12082: IFFALSE 12247
// begin for i = 1 to cargo do
12084: LD_ADDR_VAR 0 1
12088: PUSH
12089: DOUBLE
12090: LD_INT 1
12092: DEC
12093: ST_TO_ADDR
12094: LD_VAR 0 6
12098: PUSH
12099: FOR_TO
12100: IFFALSE 12231
// begin if GetFuel ( cargo [ i ] ) > 40 then
12102: LD_VAR 0 6
12106: PUSH
12107: LD_VAR 0 1
12111: ARRAY
12112: PPUSH
12113: CALL_OW 261
12117: PUSH
12118: LD_INT 40
12120: GREATER
12121: IFFALSE 12166
// ComCollect ( cargo [ i ] , skr [ c ] , skr [ c + 1 ] ) else
12123: LD_VAR 0 6
12127: PUSH
12128: LD_VAR 0 1
12132: ARRAY
12133: PPUSH
12134: LD_VAR 0 4
12138: PUSH
12139: LD_VAR 0 2
12143: ARRAY
12144: PPUSH
12145: LD_VAR 0 4
12149: PUSH
12150: LD_VAR 0 2
12154: PUSH
12155: LD_INT 1
12157: PLUS
12158: ARRAY
12159: PPUSH
12160: CALL_OW 117
12164: GO 12229
// if not See ( 2 , cargo [ i ] ) and GetCargo ( cargo [ i ] , mat_cans ) = 0 then
12166: LD_INT 2
12168: PPUSH
12169: LD_VAR 0 6
12173: PUSH
12174: LD_VAR 0 1
12178: ARRAY
12179: PPUSH
12180: CALL_OW 292
12184: NOT
12185: PUSH
12186: LD_VAR 0 6
12190: PUSH
12191: LD_VAR 0 1
12195: ARRAY
12196: PPUSH
12197: LD_INT 1
12199: PPUSH
12200: CALL_OW 289
12204: PUSH
12205: LD_INT 0
12207: EQUAL
12208: AND
12209: IFFALSE 12229
// SetFuel ( cargo [ i ] , 100 ) ;
12211: LD_VAR 0 6
12215: PUSH
12216: LD_VAR 0 1
12220: ARRAY
12221: PPUSH
12222: LD_INT 100
12224: PPUSH
12225: CALL_OW 240
// end ;
12229: GO 12099
12231: POP
12232: POP
// c = c + 2 ;
12233: LD_ADDR_VAR 0 2
12237: PUSH
12238: LD_VAR 0 2
12242: PUSH
12243: LD_INT 2
12245: PLUS
12246: ST_TO_ADDR
// end ; end ;
12247: GO 11959
// end ;
12249: PPOPN 7
12251: END
// every 4 4$00 trigger ru_angry >= [ 960 , 870 , 780 ] and gladkov_attack and dont_attack = false do var i , veh ;
12252: LD_EXP 20
12256: PUSH
12257: LD_INT 960
12259: PUSH
12260: LD_INT 870
12262: PUSH
12263: LD_INT 780
12265: PUSH
12266: EMPTY
12267: LIST
12268: LIST
12269: LIST
12270: GREATEREQUAL
12271: PUSH
12272: LD_EXP 38
12276: AND
12277: PUSH
12278: LD_EXP 25
12282: PUSH
12283: LD_INT 0
12285: EQUAL
12286: AND
12287: IFFALSE 12466
12289: GO 12291
12291: DISABLE
12292: LD_INT 0
12294: PPUSH
12295: PPUSH
// begin enable ;
12296: ENABLE
// ru_angry := ru_angry - 500 ;
12297: LD_ADDR_EXP 20
12301: PUSH
12302: LD_EXP 20
12306: PUSH
12307: LD_INT 500
12309: MINUS
12310: ST_TO_ADDR
// uc_side := 7 ;
12311: LD_ADDR_OWVAR 20
12315: PUSH
12316: LD_INT 7
12318: ST_TO_ADDR
// uc_nation := 3 ;
12319: LD_ADDR_OWVAR 21
12323: PUSH
12324: LD_INT 3
12326: ST_TO_ADDR
// for i = 1 to 8 do
12327: LD_ADDR_VAR 0 1
12331: PUSH
12332: DOUBLE
12333: LD_INT 1
12335: DEC
12336: ST_TO_ADDR
12337: LD_INT 8
12339: PUSH
12340: FOR_TO
12341: IFFALSE 12464
// begin vc_chassis := [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ Difficulty ] ;
12343: LD_ADDR_OWVAR 37
12347: PUSH
12348: LD_INT 22
12350: PUSH
12351: LD_INT 24
12353: PUSH
12354: LD_INT 24
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: LIST
12361: PUSH
12362: LD_OWVAR 67
12366: ARRAY
12367: ST_TO_ADDR
// vc_engine := engine_combustion ;
12368: LD_ADDR_OWVAR 39
12372: PUSH
12373: LD_INT 1
12375: ST_TO_ADDR
// vc_control := control_manual ;
12376: LD_ADDR_OWVAR 38
12380: PUSH
12381: LD_INT 1
12383: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_gatling_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
12384: LD_ADDR_OWVAR 40
12388: PUSH
12389: LD_INT 44
12391: PUSH
12392: LD_INT 43
12394: PUSH
12395: LD_INT 45
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: PUSH
12403: LD_INT 1
12405: PPUSH
12406: LD_INT 3
12408: PPUSH
12409: CALL_OW 12
12413: ARRAY
12414: ST_TO_ADDR
// veh := CreateVehicle ;
12415: LD_ADDR_VAR 0 2
12419: PUSH
12420: CALL_OW 45
12424: ST_TO_ADDR
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , rskill ) , veh ) ;
12425: LD_INT 3
12427: PPUSH
12428: LD_EXP 13
12432: PPUSH
12433: CALL 1017 0 2
12437: PPUSH
12438: LD_VAR 0 2
12442: PPUSH
12443: CALL_OW 52
// PlaceUnitArea ( veh , ru_south_spawn , false ) ;
12447: LD_VAR 0 2
12451: PPUSH
12452: LD_INT 4
12454: PPUSH
12455: LD_INT 0
12457: PPUSH
12458: CALL_OW 49
// end ;
12462: GO 12340
12464: POP
12465: POP
// end ;
12466: PPOPN 2
12468: END
// every 3 3$00 trigger gladkov_attack and dont_attack = false do var i , veh ;
12469: LD_EXP 38
12473: PUSH
12474: LD_EXP 25
12478: PUSH
12479: LD_INT 0
12481: EQUAL
12482: AND
12483: IFFALSE 12810
12485: GO 12487
12487: DISABLE
12488: LD_INT 0
12490: PPUSH
12491: PPUSH
// begin uc_side := 7 ;
12492: LD_ADDR_OWVAR 20
12496: PUSH
12497: LD_INT 7
12499: ST_TO_ADDR
// uc_nation := 3 ;
12500: LD_ADDR_OWVAR 21
12504: PUSH
12505: LD_INT 3
12507: ST_TO_ADDR
// for i = 1 to 8 do
12508: LD_ADDR_VAR 0 1
12512: PUSH
12513: DOUBLE
12514: LD_INT 1
12516: DEC
12517: ST_TO_ADDR
12518: LD_INT 8
12520: PUSH
12521: FOR_TO
12522: IFFALSE 12645
// begin vc_chassis := [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ Difficulty ] ;
12524: LD_ADDR_OWVAR 37
12528: PUSH
12529: LD_INT 22
12531: PUSH
12532: LD_INT 24
12534: PUSH
12535: LD_INT 24
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: LIST
12542: PUSH
12543: LD_OWVAR 67
12547: ARRAY
12548: ST_TO_ADDR
// vc_engine := engine_combustion ;
12549: LD_ADDR_OWVAR 39
12553: PUSH
12554: LD_INT 1
12556: ST_TO_ADDR
// vc_control := control_manual ;
12557: LD_ADDR_OWVAR 38
12561: PUSH
12562: LD_INT 1
12564: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_gatling_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
12565: LD_ADDR_OWVAR 40
12569: PUSH
12570: LD_INT 44
12572: PUSH
12573: LD_INT 43
12575: PUSH
12576: LD_INT 45
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: PUSH
12584: LD_INT 1
12586: PPUSH
12587: LD_INT 3
12589: PPUSH
12590: CALL_OW 12
12594: ARRAY
12595: ST_TO_ADDR
// veh := CreateVehicle ;
12596: LD_ADDR_VAR 0 2
12600: PUSH
12601: CALL_OW 45
12605: ST_TO_ADDR
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , rskill ) , veh ) ;
12606: LD_INT 3
12608: PPUSH
12609: LD_EXP 13
12613: PPUSH
12614: CALL 1017 0 2
12618: PPUSH
12619: LD_VAR 0 2
12623: PPUSH
12624: CALL_OW 52
// PlaceUnitArea ( veh , ru_south_spawn , false ) ;
12628: LD_VAR 0 2
12632: PPUSH
12633: LD_INT 4
12635: PPUSH
12636: LD_INT 0
12638: PPUSH
12639: CALL_OW 49
// end ;
12643: GO 12521
12645: POP
12646: POP
// Wait ( 0 0$30 ) ;
12647: LD_INT 1050
12649: PPUSH
12650: CALL_OW 67
// for i = 1 to [ 2 , 4 , 6 ] [ Difficulty ] do
12654: LD_ADDR_VAR 0 1
12658: PUSH
12659: DOUBLE
12660: LD_INT 1
12662: DEC
12663: ST_TO_ADDR
12664: LD_INT 2
12666: PUSH
12667: LD_INT 4
12669: PUSH
12670: LD_INT 6
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: LIST
12677: PUSH
12678: LD_OWVAR 67
12682: ARRAY
12683: PUSH
12684: FOR_TO
12685: IFFALSE 12808
// begin vc_chassis := [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ Difficulty ] ;
12687: LD_ADDR_OWVAR 37
12691: PUSH
12692: LD_INT 22
12694: PUSH
12695: LD_INT 24
12697: PUSH
12698: LD_INT 24
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: ST_TO_ADDR
// vc_engine := engine_combustion ;
12712: LD_ADDR_OWVAR 39
12716: PUSH
12717: LD_INT 1
12719: ST_TO_ADDR
// vc_control := control_manual ;
12720: LD_ADDR_OWVAR 38
12724: PUSH
12725: LD_INT 1
12727: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_gatling_gun , ru_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
12728: LD_ADDR_OWVAR 40
12732: PUSH
12733: LD_INT 44
12735: PUSH
12736: LD_INT 43
12738: PUSH
12739: LD_INT 45
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 1
12749: PPUSH
12750: LD_INT 3
12752: PPUSH
12753: CALL_OW 12
12757: ARRAY
12758: ST_TO_ADDR
// veh := CreateVehicle ;
12759: LD_ADDR_VAR 0 2
12763: PUSH
12764: CALL_OW 45
12768: ST_TO_ADDR
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , rskill ) , veh ) ;
12769: LD_INT 3
12771: PPUSH
12772: LD_EXP 13
12776: PPUSH
12777: CALL 1017 0 2
12781: PPUSH
12782: LD_VAR 0 2
12786: PPUSH
12787: CALL_OW 52
// PlaceUnitArea ( veh , ru_south_spawn , false ) ;
12791: LD_VAR 0 2
12795: PPUSH
12796: LD_INT 4
12798: PPUSH
12799: LD_INT 0
12801: PPUSH
12802: CALL_OW 49
// end ;
12806: GO 12684
12808: POP
12809: POP
// end ;
12810: PPOPN 2
12812: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 7 ] ) do var filter , i ;
12813: LD_INT 22
12815: PUSH
12816: LD_INT 7
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: IFFALSE 12943
12829: GO 12831
12831: DISABLE
12832: LD_INT 0
12834: PPUSH
12835: PPUSH
// begin enable ;
12836: ENABLE
// filter := FilterAllUnits ( [ f_side , 7 ] ) ;
12837: LD_ADDR_VAR 0 1
12841: PUSH
12842: LD_INT 22
12844: PUSH
12845: LD_INT 7
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PPUSH
12852: CALL_OW 69
12856: ST_TO_ADDR
// for i = 1 to filter do
12857: LD_ADDR_VAR 0 2
12861: PUSH
12862: DOUBLE
12863: LD_INT 1
12865: DEC
12866: ST_TO_ADDR
12867: LD_VAR 0 1
12871: PUSH
12872: FOR_TO
12873: IFFALSE 12941
// if not HasTask ( filter [ i ] ) then
12875: LD_VAR 0 1
12879: PUSH
12880: LD_VAR 0 2
12884: ARRAY
12885: PPUSH
12886: CALL_OW 314
12890: NOT
12891: IFFALSE 12939
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , filter [ i ] ) ) ;
12893: LD_VAR 0 1
12897: PUSH
12898: LD_VAR 0 2
12902: ARRAY
12903: PPUSH
12904: LD_INT 22
12906: PUSH
12907: LD_INT 2
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PPUSH
12914: CALL_OW 69
12918: PPUSH
12919: LD_VAR 0 1
12923: PUSH
12924: LD_VAR 0 2
12928: ARRAY
12929: PPUSH
12930: CALL_OW 74
12934: PPUSH
12935: CALL_OW 115
12939: GO 12872
12941: POP
12942: POP
// end ;
12943: PPOPN 2
12945: END
// export main_sci ; export function AmmoEvent ; var un , i ; begin
12946: LD_INT 0
12948: PPUSH
12949: PPUSH
12950: PPUSH
// uc_side := 3 ;
12951: LD_ADDR_OWVAR 20
12955: PUSH
12956: LD_INT 3
12958: ST_TO_ADDR
// uc_nation := 3 ;
12959: LD_ADDR_OWVAR 21
12963: PUSH
12964: LD_INT 3
12966: ST_TO_ADDR
// for i = 1 to 3 do
12967: LD_ADDR_VAR 0 3
12971: PUSH
12972: DOUBLE
12973: LD_INT 1
12975: DEC
12976: ST_TO_ADDR
12977: LD_INT 3
12979: PUSH
12980: FOR_TO
12981: IFFALSE 13035
// begin PrepareHuman ( false , 4 , 6 ) ;
12983: LD_INT 0
12985: PPUSH
12986: LD_INT 4
12988: PPUSH
12989: LD_INT 6
12991: PPUSH
12992: CALL_OW 380
// un := CreateHuman ;
12996: LD_ADDR_VAR 0 2
13000: PUSH
13001: CALL_OW 44
13005: ST_TO_ADDR
// PlaceUnitArea ( un , ru_south_spawn , false ) ;
13006: LD_VAR 0 2
13010: PPUSH
13011: LD_INT 4
13013: PPUSH
13014: LD_INT 0
13016: PPUSH
13017: CALL_OW 49
// ComEnterUnit ( un , ru_lab1 ) ;
13021: LD_VAR 0 2
13025: PPUSH
13026: LD_INT 53
13028: PPUSH
13029: CALL_OW 120
// end ;
13033: GO 12980
13035: POP
13036: POP
// hc_sex = sex_male ;
13037: LD_ADDR_OWVAR 27
13041: PUSH
13042: LD_INT 1
13044: ST_TO_ADDR
// main_sci = CreateHuman ;
13045: LD_ADDR_EXP 27
13049: PUSH
13050: CALL_OW 44
13054: ST_TO_ADDR
// PlaceUnitArea ( main_sci , ru_south_spawn , false ) ;
13055: LD_EXP 27
13059: PPUSH
13060: LD_INT 4
13062: PPUSH
13063: LD_INT 0
13065: PPUSH
13066: CALL_OW 49
// ComEnterUnit ( main_sci , ru_lab1 ) ;
13070: LD_EXP 27
13074: PPUSH
13075: LD_INT 53
13077: PPUSH
13078: CALL_OW 120
// end ;
13082: LD_VAR 0 1
13086: RET
// every 0 0$01 trigger IsInUnit ( main_sci ) do
13087: LD_EXP 27
13091: PPUSH
13092: CALL_OW 310
13096: IFFALSE 13124
13098: GO 13100
13100: DISABLE
// begin dont_attack = false ;
13101: LD_ADDR_EXP 25
13105: PUSH
13106: LD_INT 0
13108: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
13109: LD_INT 12600
13111: PPUSH
13112: CALL_OW 67
// CanUseBazooka = true ;
13116: LD_ADDR_EXP 23
13120: PUSH
13121: LD_INT 1
13123: ST_TO_ADDR
// end ; end_of_file
13124: END
// on VehicleConstructed ( veh , fac ) do var i ;
13125: LD_INT 0
13127: PPUSH
// begin if GetSide ( fac ) = 3 then
13128: LD_VAR 0 2
13132: PPUSH
13133: CALL_OW 255
13137: PUSH
13138: LD_INT 3
13140: EQUAL
13141: IFFALSE 13208
// if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_crane , ru_bulldozer ] then
13143: LD_VAR 0 1
13147: PPUSH
13148: CALL_OW 264
13152: PUSH
13153: LD_INT 51
13155: PUSH
13156: LD_INT 52
13158: PUSH
13159: LD_INT 53
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: LIST
13166: IN
13167: NOT
13168: IFFALSE 13208
// for i = 1 to 4 do
13170: LD_ADDR_VAR 0 3
13174: PUSH
13175: DOUBLE
13176: LD_INT 1
13178: DEC
13179: ST_TO_ADDR
13180: LD_INT 4
13182: PUSH
13183: FOR_TO
13184: IFFALSE 13206
// rvehlist := Delete ( rvehlist , 1 ) ;
13186: LD_ADDR_EXP 14
13190: PUSH
13191: LD_EXP 14
13195: PPUSH
13196: LD_INT 1
13198: PPUSH
13199: CALL_OW 3
13203: ST_TO_ADDR
13204: GO 13183
13206: POP
13207: POP
// if GetSide ( fac ) = 6 then
13208: LD_VAR 0 2
13212: PPUSH
13213: CALL_OW 255
13217: PUSH
13218: LD_INT 6
13220: EQUAL
13221: IFFALSE 13288
// if not GetWeapon ( veh ) in [ ru_cargo_bay , ru_crane , ru_bulldozer ] then
13223: LD_VAR 0 1
13227: PPUSH
13228: CALL_OW 264
13232: PUSH
13233: LD_INT 51
13235: PUSH
13236: LD_INT 52
13238: PUSH
13239: LD_INT 53
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: LIST
13246: IN
13247: NOT
13248: IFFALSE 13288
// for i = 1 to 4 do
13250: LD_ADDR_VAR 0 3
13254: PUSH
13255: DOUBLE
13256: LD_INT 1
13258: DEC
13259: ST_TO_ADDR
13260: LD_INT 4
13262: PUSH
13263: FOR_TO
13264: IFFALSE 13286
// r2vehlist := Delete ( r2vehlist , 1 ) ;
13266: LD_ADDR_EXP 16
13270: PUSH
13271: LD_EXP 16
13275: PPUSH
13276: LD_INT 1
13278: PPUSH
13279: CALL_OW 3
13283: ST_TO_ADDR
13284: GO 13263
13286: POP
13287: POP
// end ;
13288: PPOPN 3
13290: END
// on ActiveUnitChanged ( un ) do begin if bazooka_dialog = false then
13291: LD_EXP 31
13295: PUSH
13296: LD_INT 0
13298: EQUAL
13299: IFFALSE 13359
// if un = arr_arm or un = FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 9 ] ] ) [ 1 ] then
13301: LD_VAR 0 1
13305: PUSH
13306: LD_INT 15
13308: EQUAL
13309: PUSH
13310: LD_VAR 0 1
13314: PUSH
13315: LD_INT 22
13317: PUSH
13318: LD_INT 2
13320: PUSH
13321: EMPTY
13322: LIST
13323: LIST
13324: PUSH
13325: LD_INT 25
13327: PUSH
13328: LD_INT 9
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: EMPTY
13336: LIST
13337: LIST
13338: PPUSH
13339: CALL_OW 69
13343: PUSH
13344: LD_INT 1
13346: ARRAY
13347: EQUAL
13348: OR
13349: IFFALSE 13359
// bazooka_dialog := true ;
13351: LD_ADDR_EXP 31
13355: PUSH
13356: LD_INT 1
13358: ST_TO_ADDR
// end ;
13359: PPOPN 1
13361: END
// every 0 0$01 trigger IsSelected ( arr_arm ) do
13362: LD_INT 15
13364: PPUSH
13365: CALL_OW 306
13369: IFFALSE 13382
13371: GO 13373
13373: DISABLE
// bazooka_dialog := true ;
13374: LD_ADDR_EXP 31
13378: PUSH
13379: LD_INT 1
13381: ST_TO_ADDR
13382: END
// on BuildingComplete ( b ) do var i ;
13383: LD_INT 0
13385: PPUSH
// begin if GetSide ( b ) = 3 then
13386: LD_VAR 0 1
13390: PPUSH
13391: CALL_OW 255
13395: PUSH
13396: LD_INT 3
13398: EQUAL
13399: IFFALSE 13439
// for i = 1 to 4 do
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: DOUBLE
13407: LD_INT 1
13409: DEC
13410: ST_TO_ADDR
13411: LD_INT 4
13413: PUSH
13414: FOR_TO
13415: IFFALSE 13437
// rbullist := Delete ( rbullist , 1 ) ;
13417: LD_ADDR_EXP 15
13421: PUSH
13422: LD_EXP 15
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 3
13434: ST_TO_ADDR
13435: GO 13414
13437: POP
13438: POP
// if GetSide ( b ) = 6 then
13439: LD_VAR 0 1
13443: PPUSH
13444: CALL_OW 255
13448: PUSH
13449: LD_INT 6
13451: EQUAL
13452: IFFALSE 13492
// for i = 1 to 4 do
13454: LD_ADDR_VAR 0 2
13458: PUSH
13459: DOUBLE
13460: LD_INT 1
13462: DEC
13463: ST_TO_ADDR
13464: LD_INT 4
13466: PUSH
13467: FOR_TO
13468: IFFALSE 13490
// r2bullist := Delete ( r2bullist , 1 ) ;
13470: LD_ADDR_EXP 17
13474: PUSH
13475: LD_EXP 17
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: CALL_OW 3
13487: ST_TO_ADDR
13488: GO 13467
13490: POP
13491: POP
// if GetBType ( b ) = b_siberite_power then
13492: LD_VAR 0 1
13496: PPUSH
13497: CALL_OW 266
13501: PUSH
13502: LD_INT 28
13504: EQUAL
13505: IFFALSE 13515
// sib_pow := true ;
13507: LD_ADDR_EXP 33
13511: PUSH
13512: LD_INT 1
13514: ST_TO_ADDR
// end ;
13515: PPOPN 2
13517: END
// on UnitDestroyed ( un ) do begin if un = Louis then
13518: LD_VAR 0 1
13522: PUSH
13523: LD_EXP 1
13527: EQUAL
13528: IFFALSE 13537
// YouLost ( LouisDead ) ;
13530: LD_STRING LouisDead
13532: PPUSH
13533: CALL_OW 104
// if un = arr_arm then
13537: LD_VAR 0 1
13541: PUSH
13542: LD_INT 15
13544: EQUAL
13545: IFFALSE 13559
// Say ( Louis , DL-force ) ;
13547: LD_EXP 1
13551: PPUSH
13552: LD_STRING DL-force
13554: PPUSH
13555: CALL_OW 88
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 9 ] ] ) then
13559: LD_VAR 0 1
13563: PUSH
13564: LD_INT 22
13566: PUSH
13567: LD_INT 2
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: PUSH
13574: LD_INT 25
13576: PUSH
13577: LD_INT 9
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PPUSH
13588: CALL_OW 69
13592: IN
13593: IFFALSE 13619
// if bazooka_num > 0 then
13595: LD_EXP 30
13599: PUSH
13600: LD_INT 0
13602: GREATER
13603: IFFALSE 13619
// bazooka_num = bazooka_num - 1 ;
13605: LD_ADDR_EXP 30
13609: PUSH
13610: LD_EXP 30
13614: PUSH
13615: LD_INT 1
13617: MINUS
13618: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_bulldozer ] ] ] ) then
13619: LD_VAR 0 1
13623: PUSH
13624: LD_INT 22
13626: PUSH
13627: LD_INT 3
13629: PUSH
13630: EMPTY
13631: LIST
13632: LIST
13633: PUSH
13634: LD_INT 21
13636: PUSH
13637: LD_INT 2
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: LD_INT 3
13646: PUSH
13647: LD_INT 34
13649: PUSH
13650: LD_INT 52
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 3
13663: PUSH
13664: LD_INT 34
13666: PUSH
13667: LD_INT 51
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: PUSH
13674: EMPTY
13675: LIST
13676: LIST
13677: PUSH
13678: LD_INT 3
13680: PUSH
13681: LD_INT 34
13683: PUSH
13684: LD_INT 53
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PUSH
13695: EMPTY
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 69
13706: IN
13707: IFFALSE 13793
// begin rvehlist := rvehlist ^ GetChassis ( un ) ;
13709: LD_ADDR_EXP 14
13713: PUSH
13714: LD_EXP 14
13718: PUSH
13719: LD_VAR 0 1
13723: PPUSH
13724: CALL_OW 265
13728: ADD
13729: ST_TO_ADDR
// rvehlist := rvehlist ^ GetEngine ( un ) ;
13730: LD_ADDR_EXP 14
13734: PUSH
13735: LD_EXP 14
13739: PUSH
13740: LD_VAR 0 1
13744: PPUSH
13745: CALL_OW 262
13749: ADD
13750: ST_TO_ADDR
// rvehlist := rvehlist ^ GetControl ( un ) ;
13751: LD_ADDR_EXP 14
13755: PUSH
13756: LD_EXP 14
13760: PUSH
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 263
13770: ADD
13771: ST_TO_ADDR
// rvehlist := rvehlist ^ GetWeapon ( un ) ;
13772: LD_ADDR_EXP 14
13776: PUSH
13777: LD_EXP 14
13781: PUSH
13782: LD_VAR 0 1
13786: PPUSH
13787: CALL_OW 264
13791: ADD
13792: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
13793: LD_VAR 0 1
13797: PUSH
13798: LD_INT 22
13800: PUSH
13801: LD_INT 3
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: PUSH
13808: LD_INT 21
13810: PUSH
13811: LD_INT 3
13813: PUSH
13814: EMPTY
13815: LIST
13816: LIST
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: PPUSH
13822: CALL_OW 69
13826: IN
13827: IFFALSE 14070
// begin if GetBType ( un ) = b_factory then
13829: LD_VAR 0 1
13833: PPUSH
13834: CALL_OW 266
13838: PUSH
13839: LD_INT 3
13841: EQUAL
13842: IFFALSE 13860
// rbullist := rbullist ^ b_workshop else
13844: LD_ADDR_EXP 15
13848: PUSH
13849: LD_EXP 15
13853: PUSH
13854: LD_INT 2
13856: ADD
13857: ST_TO_ADDR
13858: GO 13985
// if GetBType ( un ) in [ b_lab_full , b_lab , b_lab_half ] then
13860: LD_VAR 0 1
13864: PPUSH
13865: CALL_OW 266
13869: PUSH
13870: LD_INT 8
13872: PUSH
13873: LD_INT 6
13875: PUSH
13876: LD_INT 7
13878: PUSH
13879: EMPTY
13880: LIST
13881: LIST
13882: LIST
13883: IN
13884: IFFALSE 13902
// rbullist := rbullist ^ b_lab else
13886: LD_ADDR_EXP 15
13890: PUSH
13891: LD_EXP 15
13895: PUSH
13896: LD_INT 6
13898: ADD
13899: ST_TO_ADDR
13900: GO 13985
// if GetBType ( un ) = b_warehouse then
13902: LD_VAR 0 1
13906: PPUSH
13907: CALL_OW 266
13911: PUSH
13912: LD_INT 1
13914: EQUAL
13915: IFFALSE 13933
// rbullist := rbullist ^ b_depot else
13917: LD_ADDR_EXP 15
13921: PUSH
13922: LD_EXP 15
13926: PUSH
13927: LD_INT 0
13929: ADD
13930: ST_TO_ADDR
13931: GO 13985
// if GetBType ( un ) = b_barracks then
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 266
13942: PUSH
13943: LD_INT 5
13945: EQUAL
13946: IFFALSE 13964
// rbullist := rbullist ^ b_armoury else
13948: LD_ADDR_EXP 15
13952: PUSH
13953: LD_EXP 15
13957: PUSH
13958: LD_INT 4
13960: ADD
13961: ST_TO_ADDR
13962: GO 13985
// rbullist := rbullist ^ GetBType ( un ) ;
13964: LD_ADDR_EXP 15
13968: PUSH
13969: LD_EXP 15
13973: PUSH
13974: LD_VAR 0 1
13978: PPUSH
13979: CALL_OW 266
13983: ADD
13984: ST_TO_ADDR
// rbullist := rbullist ^ GetX ( un ) ;
13985: LD_ADDR_EXP 15
13989: PUSH
13990: LD_EXP 15
13994: PUSH
13995: LD_VAR 0 1
13999: PPUSH
14000: CALL_OW 250
14004: ADD
14005: ST_TO_ADDR
// rbullist := rbullist ^ GetY ( un ) ;
14006: LD_ADDR_EXP 15
14010: PUSH
14011: LD_EXP 15
14015: PUSH
14016: LD_VAR 0 1
14020: PPUSH
14021: CALL_OW 251
14025: ADD
14026: ST_TO_ADDR
// rbullist := rbullist ^ GetDir ( un ) ;
14027: LD_ADDR_EXP 15
14031: PUSH
14032: LD_EXP 15
14036: PUSH
14037: LD_VAR 0 1
14041: PPUSH
14042: CALL_OW 254
14046: ADD
14047: ST_TO_ADDR
// ru_angry := ru_angry + Rand ( 1 , 39 ) ;
14048: LD_ADDR_EXP 20
14052: PUSH
14053: LD_EXP 20
14057: PUSH
14058: LD_INT 1
14060: PPUSH
14061: LD_INT 39
14063: PPUSH
14064: CALL_OW 12
14068: PLUS
14069: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_bulldozer ] ] ] ) then
14070: LD_VAR 0 1
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 6
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 21
14087: PUSH
14088: LD_INT 2
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: LD_INT 3
14097: PUSH
14098: LD_INT 34
14100: PUSH
14101: LD_INT 52
14103: PUSH
14104: EMPTY
14105: LIST
14106: LIST
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: LD_INT 3
14114: PUSH
14115: LD_INT 34
14117: PUSH
14118: LD_INT 51
14120: PUSH
14121: EMPTY
14122: LIST
14123: LIST
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 34
14134: PUSH
14135: LD_INT 53
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: PPUSH
14153: CALL_OW 69
14157: IN
14158: IFFALSE 14244
// begin r2vehlist := r2vehlist ^ GetChassis ( un ) ;
14160: LD_ADDR_EXP 16
14164: PUSH
14165: LD_EXP 16
14169: PUSH
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 265
14179: ADD
14180: ST_TO_ADDR
// r2vehlist := r2vehlist ^ GetEngine ( un ) ;
14181: LD_ADDR_EXP 16
14185: PUSH
14186: LD_EXP 16
14190: PUSH
14191: LD_VAR 0 1
14195: PPUSH
14196: CALL_OW 262
14200: ADD
14201: ST_TO_ADDR
// r2vehlist := r2vehlist ^ GetControl ( un ) ;
14202: LD_ADDR_EXP 16
14206: PUSH
14207: LD_EXP 16
14211: PUSH
14212: LD_VAR 0 1
14216: PPUSH
14217: CALL_OW 263
14221: ADD
14222: ST_TO_ADDR
// r2vehlist := r2vehlist ^ GetWeapon ( un ) ;
14223: LD_ADDR_EXP 16
14227: PUSH
14228: LD_EXP 16
14232: PUSH
14233: LD_VAR 0 1
14237: PPUSH
14238: CALL_OW 264
14242: ADD
14243: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) then
14244: LD_VAR 0 1
14248: PUSH
14249: LD_INT 22
14251: PUSH
14252: LD_INT 6
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: PUSH
14259: LD_INT 21
14261: PUSH
14262: LD_INT 3
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: PUSH
14269: EMPTY
14270: LIST
14271: LIST
14272: PPUSH
14273: CALL_OW 69
14277: IN
14278: IFFALSE 14521
// begin if GetBType ( un ) = b_factory then
14280: LD_VAR 0 1
14284: PPUSH
14285: CALL_OW 266
14289: PUSH
14290: LD_INT 3
14292: EQUAL
14293: IFFALSE 14311
// r2bullist := r2bullist ^ b_workshop else
14295: LD_ADDR_EXP 17
14299: PUSH
14300: LD_EXP 17
14304: PUSH
14305: LD_INT 2
14307: ADD
14308: ST_TO_ADDR
14309: GO 14436
// if GetBType ( un ) in [ b_lab_full , b_lab , b_lab_half ] then
14311: LD_VAR 0 1
14315: PPUSH
14316: CALL_OW 266
14320: PUSH
14321: LD_INT 8
14323: PUSH
14324: LD_INT 6
14326: PUSH
14327: LD_INT 7
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: IN
14335: IFFALSE 14353
// r2bullist := r2bullist ^ b_lab else
14337: LD_ADDR_EXP 17
14341: PUSH
14342: LD_EXP 17
14346: PUSH
14347: LD_INT 6
14349: ADD
14350: ST_TO_ADDR
14351: GO 14436
// if GetBType ( un ) = b_warehouse then
14353: LD_VAR 0 1
14357: PPUSH
14358: CALL_OW 266
14362: PUSH
14363: LD_INT 1
14365: EQUAL
14366: IFFALSE 14384
// r2bullist := r2bullist ^ b_depot else
14368: LD_ADDR_EXP 17
14372: PUSH
14373: LD_EXP 17
14377: PUSH
14378: LD_INT 0
14380: ADD
14381: ST_TO_ADDR
14382: GO 14436
// if GetBType ( un ) = b_barracks then
14384: LD_VAR 0 1
14388: PPUSH
14389: CALL_OW 266
14393: PUSH
14394: LD_INT 5
14396: EQUAL
14397: IFFALSE 14415
// r2bullist := r2bullist ^ b_armoury else
14399: LD_ADDR_EXP 17
14403: PUSH
14404: LD_EXP 17
14408: PUSH
14409: LD_INT 4
14411: ADD
14412: ST_TO_ADDR
14413: GO 14436
// r2bullist := r2bullist ^ GetBType ( un ) ;
14415: LD_ADDR_EXP 17
14419: PUSH
14420: LD_EXP 17
14424: PUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 266
14434: ADD
14435: ST_TO_ADDR
// r2bullist := r2bullist ^ GetX ( un ) ;
14436: LD_ADDR_EXP 17
14440: PUSH
14441: LD_EXP 17
14445: PUSH
14446: LD_VAR 0 1
14450: PPUSH
14451: CALL_OW 250
14455: ADD
14456: ST_TO_ADDR
// r2bullist := r2bullist ^ GetY ( un ) ;
14457: LD_ADDR_EXP 17
14461: PUSH
14462: LD_EXP 17
14466: PUSH
14467: LD_VAR 0 1
14471: PPUSH
14472: CALL_OW 251
14476: ADD
14477: ST_TO_ADDR
// r2bullist := r2bullist ^ GetDir ( un ) ;
14478: LD_ADDR_EXP 17
14482: PUSH
14483: LD_EXP 17
14487: PUSH
14488: LD_VAR 0 1
14492: PPUSH
14493: CALL_OW 254
14497: ADD
14498: ST_TO_ADDR
// ru_angry := ru_angry + Rand ( 1 , 39 ) ;
14499: LD_ADDR_EXP 20
14503: PUSH
14504: LD_EXP 20
14508: PUSH
14509: LD_INT 1
14511: PPUSH
14512: LD_INT 39
14514: PPUSH
14515: CALL_OW 12
14519: PLUS
14520: ST_TO_ADDR
// end ; end ;
14521: PPOPN 1
14523: END
// on ResearchComplete ( tech , lab ) do begin if tech = 7 then
14524: LD_VAR 0 1
14528: PUSH
14529: LD_INT 7
14531: EQUAL
14532: IFFALSE 14565
// begin ChangeMissionObjectives ( TRado ) ;
14534: LD_STRING TRado
14536: PPUSH
14537: CALL_OW 337
// Say ( SaySci , Dsci-Brad ) ;
14541: CALL 2397 0 0
14545: PPUSH
14546: LD_STRING Dsci-Brad
14548: PPUSH
14549: CALL_OW 88
// Say ( Louis , DL-Brad ) ;
14553: LD_EXP 1
14557: PPUSH
14558: LD_STRING DL-Brad
14560: PPUSH
14561: CALL_OW 88
// end ; if tech = 8 then
14565: LD_VAR 0 1
14569: PUSH
14570: LD_INT 8
14572: EQUAL
14573: IFFALSE 14587
// Say ( SaySci , Dsci-bio ) ;
14575: CALL 2397 0 0
14579: PPUSH
14580: LD_STRING Dsci-bio
14582: PPUSH
14583: CALL_OW 88
// end ;
14587: PPOPN 2
14589: END
// on EnterBuilding ( b , un ) do var deps ;
14590: LD_INT 0
14592: PPUSH
// begin deps := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14593: LD_ADDR_VAR 0 3
14597: PUSH
14598: LD_INT 22
14600: PUSH
14601: LD_INT 2
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 2
14610: PUSH
14611: LD_INT 30
14613: PUSH
14614: LD_INT 0
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: LIST
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PPUSH
14640: CALL_OW 69
14644: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman ] ] ) or un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) then
14645: LD_VAR 0 2
14649: PUSH
14650: LD_INT 22
14652: PUSH
14653: LD_INT 2
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: PUSH
14660: LD_INT 25
14662: PUSH
14663: LD_INT 12
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: PPUSH
14674: CALL_OW 69
14678: IN
14679: PUSH
14680: LD_VAR 0 2
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 2
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PUSH
14695: LD_INT 25
14697: PUSH
14698: LD_INT 15
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PPUSH
14709: CALL_OW 69
14713: IN
14714: OR
14715: IFFALSE 14748
// if b in deps then
14717: LD_VAR 0 1
14721: PUSH
14722: LD_VAR 0 3
14726: IN
14727: IFFALSE 14748
// begin Wait ( 0 0$0.3 ) ;
14729: LD_INT 10
14731: PPUSH
14732: CALL_OW 67
// SetClass ( un , 16 ) ;
14736: LD_VAR 0 2
14740: PPUSH
14741: LD_INT 16
14743: PPUSH
14744: CALL_OW 336
// end ; end ;
14748: PPOPN 3
14750: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ f_control , control_computer ] ) and comp_destroyed = false then
14751: LD_VAR 0 1
14755: PUSH
14756: LD_INT 33
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PPUSH
14766: CALL_OW 69
14770: IN
14771: PUSH
14772: LD_EXP 35
14776: PUSH
14777: LD_INT 0
14779: EQUAL
14780: AND
14781: IFFALSE 14834
// begin comp_destroyed := true ;
14783: LD_ADDR_EXP 35
14787: PUSH
14788: LD_INT 1
14790: ST_TO_ADDR
// DialogueOn ;
14791: CALL_OW 6
// CenterNowOnUnits ( un ) ;
14795: LD_VAR 0 1
14799: PPUSH
14800: CALL_OW 87
// DWait ( 0 0$0.1 ) ;
14804: LD_INT 4
14806: PPUSH
14807: CALL_OW 68
// Say ( Louis , DL-compd ) ;
14811: LD_EXP 1
14815: PPUSH
14816: LD_STRING DL-compd
14818: PPUSH
14819: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
14823: LD_INT 10
14825: PPUSH
14826: CALL_OW 68
// DialogueOff ;
14830: CALL_OW 7
// end ; if un = main_sci then
14834: LD_VAR 0 1
14838: PUSH
14839: LD_EXP 27
14843: EQUAL
14844: IFFALSE 14854
// main_sci_dead = true ;
14846: LD_ADDR_EXP 24
14850: PUSH
14851: LD_INT 1
14853: ST_TO_ADDR
// if un in FilterUnitsInArea ( ru_at , [ f_control , control_computer ] ) and comp_attack = false then
14854: LD_VAR 0 1
14858: PUSH
14859: LD_INT 19
14861: PPUSH
14862: LD_INT 33
14864: PUSH
14865: LD_INT 3
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PPUSH
14872: CALL_OW 70
14876: IN
14877: PUSH
14878: LD_EXP 36
14882: PUSH
14883: LD_INT 0
14885: EQUAL
14886: AND
14887: IFFALSE 14921
// begin comp_ct := comp_ct + 1 ;
14889: LD_ADDR_EXP 37
14893: PUSH
14894: LD_EXP 37
14898: PUSH
14899: LD_INT 1
14901: PLUS
14902: ST_TO_ADDR
// if comp_ct >= 16 then
14903: LD_EXP 37
14907: PUSH
14908: LD_INT 16
14910: GREATEREQUAL
14911: IFFALSE 14921
// comp_attack := true ;
14913: LD_ADDR_EXP 36
14917: PUSH
14918: LD_INT 1
14920: ST_TO_ADDR
// end ; end ;
14921: PPOPN 1
14923: END
// every 5 5$30 trigger tick < 35 * 60 * 70 do
14924: LD_OWVAR 1
14928: PUSH
14929: LD_INT 35
14931: PUSH
14932: LD_INT 60
14934: MUL
14935: PUSH
14936: LD_INT 70
14938: MUL
14939: LESS
14940: IFFALSE 15028
14942: GO 14944
14944: DISABLE
// begin enable ;
14945: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_area , true ) ;
14946: LD_INT 1
14948: PPUSH
14949: LD_INT 5
14951: PPUSH
14952: CALL_OW 12
14956: PPUSH
14957: LD_INT 16
14959: PPUSH
14960: LD_INT 1
14962: PPUSH
14963: CALL_OW 55
// Wait ( Rand ( 0 0$01 , 0 0$10 ) ) ;
14967: LD_INT 35
14969: PPUSH
14970: LD_INT 350
14972: PPUSH
14973: CALL_OW 12
14977: PPUSH
14978: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_area , true ) ;
14982: LD_INT 1
14984: PPUSH
14985: LD_INT 5
14987: PPUSH
14988: CALL_OW 12
14992: PPUSH
14993: LD_INT 16
14995: PPUSH
14996: LD_INT 1
14998: PPUSH
14999: CALL_OW 55
// Wait ( 0 0$05 ) ;
15003: LD_INT 175
15005: PPUSH
15006: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
15010: LD_INT 1
15012: PPUSH
15013: LD_INT 5
15015: PPUSH
15016: CALL_OW 12
15020: PPUSH
15021: LD_INT 1
15023: PPUSH
15024: CALL_OW 57
// end ;
15028: END
// every 3 3$20 do
15029: GO 15031
15031: DISABLE
// begin enable ;
15032: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , super_crates , true ) ;
15033: LD_INT 1
15035: PPUSH
15036: LD_INT 5
15038: PPUSH
15039: CALL_OW 12
15043: PPUSH
15044: LD_INT 20
15046: PPUSH
15047: LD_INT 1
15049: PPUSH
15050: CALL_OW 55
// Wait ( Rand ( 0 0$08 , 0 0$15 ) ) ;
15054: LD_INT 280
15056: PPUSH
15057: LD_INT 525
15059: PPUSH
15060: CALL_OW 12
15064: PPUSH
15065: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , super_crates , true ) ;
15069: LD_INT 1
15071: PPUSH
15072: LD_INT 5
15074: PPUSH
15075: CALL_OW 12
15079: PPUSH
15080: LD_INT 20
15082: PPUSH
15083: LD_INT 1
15085: PPUSH
15086: CALL_OW 55
// end ; end_of_file
15090: END
// export in_base , on_hill , bazooka_num , bazooka_dialog , go_to_end ; export sib_pow , gali_arive , comp_destroyed , comp_attack , comp_ct , gladkov_attack ; export function Action ; begin
15091: LD_INT 0
15093: PPUSH
// in_base := false ;
15094: LD_ADDR_EXP 28
15098: PUSH
15099: LD_INT 0
15101: ST_TO_ADDR
// on_hill := false ;
15102: LD_ADDR_EXP 29
15106: PUSH
15107: LD_INT 0
15109: ST_TO_ADDR
// go_to_end := false ;
15110: LD_ADDR_EXP 32
15114: PUSH
15115: LD_INT 0
15117: ST_TO_ADDR
// sib_pow := false ;
15118: LD_ADDR_EXP 33
15122: PUSH
15123: LD_INT 0
15125: ST_TO_ADDR
// gali_arive := false ;
15126: LD_ADDR_EXP 34
15130: PUSH
15131: LD_INT 0
15133: ST_TO_ADDR
// comp_destroyed := false ;
15134: LD_ADDR_EXP 35
15138: PUSH
15139: LD_INT 0
15141: ST_TO_ADDR
// comp_attack := false ;
15142: LD_ADDR_EXP 36
15146: PUSH
15147: LD_INT 0
15149: ST_TO_ADDR
// gladkov_attack := false ;
15150: LD_ADDR_EXP 38
15154: PUSH
15155: LD_INT 0
15157: ST_TO_ADDR
// comp_ct := 0 ;
15158: LD_ADDR_EXP 37
15162: PUSH
15163: LD_INT 0
15165: ST_TO_ADDR
// bazooka_num := [ 5 , 4 , 4 ] [ Difficulty ] ;
15166: LD_ADDR_EXP 30
15170: PUSH
15171: LD_INT 5
15173: PUSH
15174: LD_INT 4
15176: PUSH
15177: LD_INT 4
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: LIST
15184: PUSH
15185: LD_OWVAR 67
15189: ARRAY
15190: ST_TO_ADDR
// bazooka_dialog := false ;
15191: LD_ADDR_EXP 31
15195: PUSH
15196: LD_INT 0
15198: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
15199: LD_INT 70
15201: PPUSH
15202: CALL_OW 67
// InGameOff ;
15206: CALL_OW 9
// ChangeMissionObjectives ( TWest ) ;
15210: LD_STRING TWest
15212: PPUSH
15213: CALL_OW 337
// SaveForQuickRestart ;
15217: CALL_OW 22
// if Gali or Mike then
15221: LD_EXP 3
15225: PUSH
15226: LD_EXP 5
15230: OR
15231: IFFALSE 15241
// gali_arive := true ;
15233: LD_ADDR_EXP 34
15237: PUSH
15238: LD_INT 1
15240: ST_TO_ADDR
// end ;
15241: LD_VAR 0 1
15245: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 9 ] ] ) = 2 do
15246: LD_INT 22
15248: PUSH
15249: LD_INT 2
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: LD_INT 25
15258: PUSH
15259: LD_INT 9
15261: PUSH
15262: EMPTY
15263: LIST
15264: LIST
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: PPUSH
15270: CALL_OW 69
15274: PUSH
15275: LD_INT 2
15277: EQUAL
15278: IFFALSE 15291
15280: GO 15282
15282: DISABLE
// bazooka_dialog = true ;
15283: LD_ADDR_EXP 31
15287: PUSH
15288: LD_INT 1
15290: ST_TO_ADDR
15291: END
// every 0 0$01 trigger IsInArea ( Louis , Hill ) and in_base = false do
15292: LD_EXP 1
15296: PPUSH
15297: LD_INT 11
15299: PPUSH
15300: CALL_OW 308
15304: PUSH
15305: LD_EXP 28
15309: PUSH
15310: LD_INT 0
15312: EQUAL
15313: AND
15314: IFFALSE 15503
15316: GO 15318
15318: DISABLE
// begin InGameOn ;
15319: CALL_OW 8
// ComMoveXY ( Louis , 191 , 150 ) ;
15323: LD_EXP 1
15327: PPUSH
15328: LD_INT 191
15330: PPUSH
15331: LD_INT 150
15333: PPUSH
15334: CALL_OW 111
// AddComTurnXY ( Louis , 0 , 0 ) ;
15338: LD_EXP 1
15342: PPUSH
15343: LD_INT 0
15345: PPUSH
15346: LD_INT 0
15348: PPUSH
15349: CALL_OW 178
// AddComWait ( Louis , 0 0$01 ) ;
15353: LD_EXP 1
15357: PPUSH
15358: LD_INT 35
15360: PPUSH
15361: CALL_OW 202
// Say ( Louis , DL-Hill ) ;
15365: LD_EXP 1
15369: PPUSH
15370: LD_STRING DL-Hill
15372: PPUSH
15373: CALL_OW 88
// ProduceNewCombatCar ( ru_fac2 ) ;
15377: LD_INT 172
15379: PPUSH
15380: CALL 9839 0 1
// FogOff ( 2 ) ;
15384: LD_INT 2
15386: PPUSH
15387: CALL_OW 344
// PlaceSeeing ( 125 , 93 , 2 , 5 ) ;
15391: LD_INT 125
15393: PPUSH
15394: LD_INT 93
15396: PPUSH
15397: LD_INT 2
15399: PPUSH
15400: LD_INT 5
15402: PPUSH
15403: CALL_OW 330
// PlaceSeeing ( 95 , 135 , 2 , 5 ) ;
15407: LD_INT 95
15409: PPUSH
15410: LD_INT 135
15412: PPUSH
15413: LD_INT 2
15415: PPUSH
15416: LD_INT 5
15418: PPUSH
15419: CALL_OW 330
// RemoveSeeing ( 125 , 93 , 2 ) ;
15423: LD_INT 125
15425: PPUSH
15426: LD_INT 93
15428: PPUSH
15429: LD_INT 2
15431: PPUSH
15432: CALL_OW 331
// RemoveSeeing ( 95 , 135 , 2 ) ;
15436: LD_INT 95
15438: PPUSH
15439: LD_INT 135
15441: PPUSH
15442: LD_INT 2
15444: PPUSH
15445: CALL_OW 331
// CenterOnXY ( 123 , 99 ) ;
15449: LD_INT 123
15451: PPUSH
15452: LD_INT 99
15454: PPUSH
15455: CALL_OW 84
// Wait ( 0 0$03 ) ;
15459: LD_INT 105
15461: PPUSH
15462: CALL_OW 67
// CenterOnXY ( 112 , 140 ) ;
15466: LD_INT 112
15468: PPUSH
15469: LD_INT 140
15471: PPUSH
15472: CALL_OW 84
// Wait ( 0 0$03 ) ;
15476: LD_INT 105
15478: PPUSH
15479: CALL_OW 67
// CenterNowOnUnits ( Louis ) ;
15483: LD_EXP 1
15487: PPUSH
15488: CALL_OW 87
// FogOff ( 0 ) ;
15492: LD_INT 0
15494: PPUSH
15495: CALL_OW 344
// InGameOff ;
15499: CALL_OW 9
// end ;
15503: END
// every 0 0$01 trigger See ( 5 , Louis ) and IsInArea ( Louis , ar_spot ) do
15504: LD_INT 5
15506: PPUSH
15507: LD_EXP 1
15511: PPUSH
15512: CALL_OW 292
15516: PUSH
15517: LD_EXP 1
15521: PPUSH
15522: LD_INT 21
15524: PPUSH
15525: CALL_OW 308
15529: AND
15530: IFFALSE 16063
15532: GO 15534
15534: DISABLE
// begin in_base := true ;
15535: LD_ADDR_EXP 28
15539: PUSH
15540: LD_INT 1
15542: ST_TO_ADDR
// InGameOn ;
15543: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 5 ] ) , 2 ) ;
15547: LD_INT 22
15549: PUSH
15550: LD_INT 5
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PPUSH
15557: CALL_OW 69
15561: PPUSH
15562: LD_INT 2
15564: PPUSH
15565: CALL_OW 235
// CenterOnXY ( 80 , 84 ) ;
15569: LD_INT 80
15571: PPUSH
15572: LD_INT 84
15574: PPUSH
15575: CALL_OW 84
// ComMoveXY ( Louis , 76 , 79 ) ;
15579: LD_EXP 1
15583: PPUSH
15584: LD_INT 76
15586: PPUSH
15587: LD_INT 79
15589: PPUSH
15590: CALL_OW 111
// ComExitBuilding ( Rolf ) ;
15594: LD_EXP 8
15598: PPUSH
15599: CALL_OW 122
// AddComMoveXY ( Rolf , 78 , 81 ) ;
15603: LD_EXP 8
15607: PPUSH
15608: LD_INT 78
15610: PPUSH
15611: LD_INT 81
15613: PPUSH
15614: CALL_OW 171
// AddComTurnUnit ( Rolf , Louis ) ;
15618: LD_EXP 8
15622: PPUSH
15623: LD_EXP 1
15627: PPUSH
15628: CALL_OW 179
// AddComTurnUnit ( Louis , Rolf ) ;
15632: LD_EXP 1
15636: PPUSH
15637: LD_EXP 8
15641: PPUSH
15642: CALL_OW 179
// Say ( Rolf , DR-1 ) ;
15646: LD_EXP 8
15650: PPUSH
15651: LD_STRING DR-1
15653: PPUSH
15654: CALL_OW 88
// Say ( Louis , DL-1 ) ;
15658: LD_EXP 1
15662: PPUSH
15663: LD_STRING DL-1
15665: PPUSH
15666: CALL_OW 88
// Say ( Rolf , DR-2 ) ;
15670: LD_EXP 8
15674: PPUSH
15675: LD_STRING DR-2
15677: PPUSH
15678: CALL_OW 88
// Say ( Louis , DL-2 ) ;
15682: LD_EXP 1
15686: PPUSH
15687: LD_STRING DL-2
15689: PPUSH
15690: CALL_OW 88
// Say ( Rolf , DR-3 ) ;
15694: LD_EXP 8
15698: PPUSH
15699: LD_STRING DR-3
15701: PPUSH
15702: CALL_OW 88
// Say ( Rolf , DR-4 ) ;
15706: LD_EXP 8
15710: PPUSH
15711: LD_STRING DR-4
15713: PPUSH
15714: CALL_OW 88
// Say ( Louis , DL-3 ) ;
15718: LD_EXP 1
15722: PPUSH
15723: LD_STRING DL-3
15725: PPUSH
15726: CALL_OW 88
// Say ( Rolf , DR-5 ) ;
15730: LD_EXP 8
15734: PPUSH
15735: LD_STRING DR-5
15737: PPUSH
15738: CALL_OW 88
// Say ( Louis , DL-4 ) ;
15742: LD_EXP 1
15746: PPUSH
15747: LD_STRING DL-4
15749: PPUSH
15750: CALL_OW 88
// Say ( Rolf , DR-6 ) ;
15754: LD_EXP 8
15758: PPUSH
15759: LD_STRING DR-6
15761: PPUSH
15762: CALL_OW 88
// Say ( Louis , DL-5 ) ;
15766: LD_EXP 1
15770: PPUSH
15771: LD_STRING DL-5
15773: PPUSH
15774: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
15778: LD_INT 7
15780: PPUSH
15781: CALL_OW 67
// if comp_destroyed then
15785: LD_EXP 35
15789: IFFALSE 15815
// begin Say ( Rolf , DR-6a ) ;
15791: LD_EXP 8
15795: PPUSH
15796: LD_STRING DR-6a
15798: PPUSH
15799: CALL_OW 88
// Say ( Louis , DL-6b ) ;
15803: LD_EXP 1
15807: PPUSH
15808: LD_STRING DL-6b
15810: PPUSH
15811: CALL_OW 88
// end ; if Jenna then
15815: LD_EXP 6
15819: IFFALSE 15997
// begin ComExitBuilding ( Jenna ) ;
15821: LD_EXP 6
15825: PPUSH
15826: CALL_OW 122
// Wait ( 0 0$0.1 ) ;
15830: LD_INT 4
15832: PPUSH
15833: CALL_OW 67
// ComMoveXY ( Jenna , GetX ( Louis ) - 1 , GetY ( Louis ) ) ;
15837: LD_EXP 6
15841: PPUSH
15842: LD_EXP 1
15846: PPUSH
15847: CALL_OW 250
15851: PUSH
15852: LD_INT 1
15854: MINUS
15855: PPUSH
15856: LD_EXP 1
15860: PPUSH
15861: CALL_OW 251
15865: PPUSH
15866: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
15870: LD_INT 35
15872: PPUSH
15873: CALL_OW 67
// until GetDistUnits ( Jenna , Louis ) < 6 ;
15877: LD_EXP 6
15881: PPUSH
15882: LD_EXP 1
15886: PPUSH
15887: CALL_OW 296
15891: PUSH
15892: LD_INT 6
15894: LESS
15895: IFFALSE 15870
// ComTurnUnit ( Jenna , Louis ) ;
15897: LD_EXP 6
15901: PPUSH
15902: LD_EXP 1
15906: PPUSH
15907: CALL_OW 119
// ComTurnUnit ( Louis , Jenna ) ;
15911: LD_EXP 1
15915: PPUSH
15916: LD_EXP 6
15920: PPUSH
15921: CALL_OW 119
// Say ( Jenna , DJ-1 ) ;
15925: LD_EXP 6
15929: PPUSH
15930: LD_STRING DJ-1
15932: PPUSH
15933: CALL_OW 88
// Say ( Louis , DL-6 ) ;
15937: LD_EXP 1
15941: PPUSH
15942: LD_STRING DL-6
15944: PPUSH
15945: CALL_OW 88
// Say ( Jenna , DJ-2 ) ;
15949: LD_EXP 6
15953: PPUSH
15954: LD_STRING DJ-2
15956: PPUSH
15957: CALL_OW 88
// Say ( Louis , DL-7 ) ;
15961: LD_EXP 1
15965: PPUSH
15966: LD_STRING DL-7
15968: PPUSH
15969: CALL_OW 88
// Say ( Jenna , DJ-3 ) ;
15973: LD_EXP 6
15977: PPUSH
15978: LD_STRING DJ-3
15980: PPUSH
15981: CALL_OW 88
// Say ( Louis , DL-8 ) ;
15985: LD_EXP 1
15989: PPUSH
15990: LD_STRING DL-8
15992: PPUSH
15993: CALL_OW 88
// end ; InGameOff ;
15997: CALL_OW 9
// ChangeMissionObjectives ( TSib ) ;
16001: LD_STRING TSib
16003: PPUSH
16004: CALL_OW 337
// if Difficulty < 3 then
16008: LD_OWVAR 67
16012: PUSH
16013: LD_INT 3
16015: LESS
16016: IFFALSE 16034
// PlaceSeeing ( 36 , 33 , 2 , 10 ) ;
16018: LD_INT 36
16020: PPUSH
16021: LD_INT 33
16023: PPUSH
16024: LD_INT 2
16026: PPUSH
16027: LD_INT 10
16029: PPUSH
16030: CALL_OW 330
// PlaceSeeing ( 26 , 33 , 2 , 10 ) ;
16034: LD_INT 26
16036: PPUSH
16037: LD_INT 33
16039: PPUSH
16040: LD_INT 2
16042: PPUSH
16043: LD_INT 10
16045: PPUSH
16046: CALL_OW 330
// RemoveSeeing ( 26 , 33 , 2 ) ;
16050: LD_INT 26
16052: PPUSH
16053: LD_INT 33
16055: PPUSH
16056: LD_INT 2
16058: PPUSH
16059: CALL_OW 331
// end ;
16063: END
// every 1 1$02 trigger tick > ( 35 * 60 * 10 ) and Rand ( 1 , 100 ) > 75 do var veh , vehs , i ;
16064: LD_OWVAR 1
16068: PUSH
16069: LD_INT 35
16071: PUSH
16072: LD_INT 60
16074: MUL
16075: PUSH
16076: LD_INT 10
16078: MUL
16079: GREATER
16080: PUSH
16081: LD_INT 1
16083: PPUSH
16084: LD_INT 100
16086: PPUSH
16087: CALL_OW 12
16091: PUSH
16092: LD_INT 75
16094: GREATER
16095: AND
16096: IFFALSE 16576
16098: GO 16100
16100: DISABLE
16101: LD_INT 0
16103: PPUSH
16104: PPUSH
16105: PPUSH
// begin uc_side := 2 ;
16106: LD_ADDR_OWVAR 20
16110: PUSH
16111: LD_INT 2
16113: ST_TO_ADDR
// uc_nation := 2 ;
16114: LD_ADDR_OWVAR 21
16118: PUSH
16119: LD_INT 2
16121: ST_TO_ADDR
// vehs := [ ] ;
16122: LD_ADDR_VAR 0 2
16126: PUSH
16127: EMPTY
16128: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16129: LD_ADDR_OWVAR 37
16133: PUSH
16134: LD_INT 14
16136: ST_TO_ADDR
// vc_engine := engine_combustion ;
16137: LD_ADDR_OWVAR 39
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// vc_control := control_manual ;
16145: LD_ADDR_OWVAR 38
16149: PUSH
16150: LD_INT 1
16152: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
16153: LD_ADDR_OWVAR 40
16157: PUSH
16158: LD_INT 32
16160: ST_TO_ADDR
// for i = 1 to 2 do
16161: LD_ADDR_VAR 0 3
16165: PUSH
16166: DOUBLE
16167: LD_INT 1
16169: DEC
16170: ST_TO_ADDR
16171: LD_INT 2
16173: PUSH
16174: FOR_TO
16175: IFFALSE 16303
// begin veh := CreateVehicle ;
16177: LD_ADDR_VAR 0 1
16181: PUSH
16182: CALL_OW 45
16186: ST_TO_ADDR
// vehs = vehs ^ veh ;
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: LD_VAR 0 2
16196: PUSH
16197: LD_VAR 0 1
16201: ADD
16202: ST_TO_ADDR
// SetDir ( veh , Rand ( 2 , 3 ) ) ;
16203: LD_VAR 0 1
16207: PPUSH
16208: LD_INT 2
16210: PPUSH
16211: LD_INT 3
16213: PPUSH
16214: CALL_OW 12
16218: PPUSH
16219: CALL_OW 233
// PlaceUnitArea ( veh , ar_park , false ) ;
16223: LD_VAR 0 1
16227: PPUSH
16228: LD_INT 15
16230: PPUSH
16231: LD_INT 0
16233: PPUSH
16234: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , 4 ) , veh ) ;
16238: LD_INT 3
16240: PPUSH
16241: LD_INT 4
16243: PPUSH
16244: CALL 1017 0 2
16248: PPUSH
16249: LD_VAR 0 1
16253: PPUSH
16254: CALL_OW 52
// SetCargo ( veh , mat_oil , Rand ( 20 , 60 ) ) ;
16258: LD_VAR 0 1
16262: PPUSH
16263: LD_INT 2
16265: PPUSH
16266: LD_INT 20
16268: PPUSH
16269: LD_INT 60
16271: PPUSH
16272: CALL_OW 12
16276: PPUSH
16277: CALL_OW 290
// SetFuel ( veh , Rand ( 78 , 88 ) ) ;
16281: LD_VAR 0 1
16285: PPUSH
16286: LD_INT 78
16288: PPUSH
16289: LD_INT 88
16291: PPUSH
16292: CALL_OW 12
16296: PPUSH
16297: CALL_OW 240
// end ;
16301: GO 16174
16303: POP
16304: POP
// vc_weapon := ar_flame_thrower ;
16305: LD_ADDR_OWVAR 40
16309: PUSH
16310: LD_INT 26
16312: ST_TO_ADDR
// veh := CreateVehicle ;
16313: LD_ADDR_VAR 0 1
16317: PUSH
16318: CALL_OW 45
16322: ST_TO_ADDR
// vehs = vehs ^ veh ;
16323: LD_ADDR_VAR 0 2
16327: PUSH
16328: LD_VAR 0 2
16332: PUSH
16333: LD_VAR 0 1
16337: ADD
16338: ST_TO_ADDR
// SetDir ( veh , Rand ( 2 , 3 ) ) ;
16339: LD_VAR 0 1
16343: PPUSH
16344: LD_INT 2
16346: PPUSH
16347: LD_INT 3
16349: PPUSH
16350: CALL_OW 12
16354: PPUSH
16355: CALL_OW 233
// PlaceUnitArea ( veh , ar_park , false ) ;
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_INT 15
16366: PPUSH
16367: LD_INT 0
16369: PPUSH
16370: CALL_OW 49
// if Mike then
16374: LD_EXP 5
16378: IFFALSE 16394
// PlaceHumanInUnit ( Mike , veh ) ;
16380: LD_EXP 5
16384: PPUSH
16385: LD_VAR 0 1
16389: PPUSH
16390: CALL_OW 52
// if Gali then
16394: LD_EXP 3
16398: IFFALSE 16415
// PlaceUnitArea ( Gali , ar_north_spawn , false ) ;
16400: LD_EXP 3
16404: PPUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 0
16410: PPUSH
16411: CALL_OW 49
// if Nicolas then
16415: LD_EXP 4
16419: IFFALSE 16436
// PlaceUnitArea ( Nicolas , ar_north_spawn , false ) ;
16421: LD_EXP 4
16425: PPUSH
16426: LD_INT 1
16428: PPUSH
16429: LD_INT 0
16431: PPUSH
16432: CALL_OW 49
// if Rick then
16436: LD_EXP 7
16440: IFFALSE 16457
// PlaceUnitArea ( Rick , ar_north_spawn , false ) ;
16442: LD_EXP 7
16446: PPUSH
16447: LD_INT 1
16449: PPUSH
16450: LD_INT 0
16452: PPUSH
16453: CALL_OW 49
// PlaceUnitArea ( CreateHumanWithClass ( 1 , 5 ) , ar_north_spawn , false ) ;
16457: LD_INT 1
16459: PPUSH
16460: LD_INT 5
16462: PPUSH
16463: CALL 1017 0 2
16467: PPUSH
16468: LD_INT 1
16470: PPUSH
16471: LD_INT 0
16473: PPUSH
16474: CALL_OW 49
// SetSide ( FilterAllUnits ( [ f_side , 5 ] ) , 2 ) ;
16478: LD_INT 22
16480: PUSH
16481: LD_INT 5
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: PPUSH
16488: CALL_OW 69
16492: PPUSH
16493: LD_INT 2
16495: PPUSH
16496: CALL_OW 235
// if Gali then
16500: LD_EXP 3
16504: IFFALSE 16520
// SayRadio ( Gali , DGa-G1 ) else
16506: LD_EXP 3
16510: PPUSH
16511: LD_STRING DGa-G1
16513: PPUSH
16514: CALL_OW 94
16518: GO 16532
// SayRadio ( Mike , DGa-G1 ) ;
16520: LD_EXP 5
16524: PPUSH
16525: LD_STRING DGa-G1
16527: PPUSH
16528: CALL_OW 94
// Say ( Rolf , DR-G1 ) ;
16532: LD_EXP 8
16536: PPUSH
16537: LD_STRING DR-G1
16539: PPUSH
16540: CALL_OW 88
// if Gali then
16544: LD_EXP 3
16548: IFFALSE 16564
// SayRadio ( Gali , DGa-G2 ) else
16550: LD_EXP 3
16554: PPUSH
16555: LD_STRING DGa-G2
16557: PPUSH
16558: CALL_OW 94
16562: GO 16576
// SayRadio ( Mike , DGa-G2 ) ;
16564: LD_EXP 5
16568: PPUSH
16569: LD_STRING DGa-G2
16571: PPUSH
16572: CALL_OW 94
// end ;
16576: PPOPN 3
16578: END
// every 0 0$01 trigger GetDistUnits ( Gali , Louis ) < 7 or GetDistUnits ( Mike , Louis ) < 7 do
16579: LD_EXP 3
16583: PPUSH
16584: LD_EXP 1
16588: PPUSH
16589: CALL_OW 296
16593: PUSH
16594: LD_INT 7
16596: LESS
16597: PUSH
16598: LD_EXP 5
16602: PPUSH
16603: LD_EXP 1
16607: PPUSH
16608: CALL_OW 296
16612: PUSH
16613: LD_INT 7
16615: LESS
16616: OR
16617: IFFALSE 16882
16619: GO 16621
16621: DISABLE
// begin InGameOn ;
16622: CALL_OW 8
// DialogueOn ;
16626: CALL_OW 6
// CenterNowOnUnits ( Louis ) ;
16630: LD_EXP 1
16634: PPUSH
16635: CALL_OW 87
// ComTurnUnit ( [ Mike , Gali , Nicolas , Rick ] , Louis ) ;
16639: LD_EXP 5
16643: PUSH
16644: LD_EXP 3
16648: PUSH
16649: LD_EXP 4
16653: PUSH
16654: LD_EXP 7
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: LIST
16663: LIST
16664: PPUSH
16665: LD_EXP 1
16669: PPUSH
16670: CALL_OW 119
// ComTurnUnit ( Louis , Mike ) ;
16674: LD_EXP 1
16678: PPUSH
16679: LD_EXP 5
16683: PPUSH
16684: CALL_OW 119
// Say ( Rolf , DR-G2 ) ;
16688: LD_EXP 8
16692: PPUSH
16693: LD_STRING DR-G2
16695: PPUSH
16696: CALL_OW 88
// if Nicolas then
16700: LD_EXP 4
16704: IFFALSE 16718
// Say ( Nicolas , DMi-G1 ) ;
16706: LD_EXP 4
16710: PPUSH
16711: LD_STRING DMi-G1
16713: PPUSH
16714: CALL_OW 88
// if Gali then
16718: LD_EXP 3
16722: IFFALSE 16738
// Say ( Gali , DJi-G1 ) else
16724: LD_EXP 3
16728: PPUSH
16729: LD_STRING DJi-G1
16731: PPUSH
16732: CALL_OW 88
16736: GO 16750
// Say ( Mike , DJi-G1 ) ;
16738: LD_EXP 5
16742: PPUSH
16743: LD_STRING DJi-G1
16745: PPUSH
16746: CALL_OW 88
// if Rick then
16750: LD_EXP 7
16754: IFFALSE 16770
// Say ( Rick , DGa-G3 ) else
16756: LD_EXP 7
16760: PPUSH
16761: LD_STRING DGa-G3
16763: PPUSH
16764: CALL_OW 88
16768: GO 16788
// if Nicolas then
16770: LD_EXP 4
16774: IFFALSE 16788
// Say ( Rick , DGa-G3 ) ;
16776: LD_EXP 7
16780: PPUSH
16781: LD_STRING DGa-G3
16783: PPUSH
16784: CALL_OW 88
// Say ( Louis , DL-G1 ) ;
16788: LD_EXP 1
16792: PPUSH
16793: LD_STRING DL-G1
16795: PPUSH
16796: CALL_OW 88
// Say ( Rolf , DR-G3 ) ;
16800: LD_EXP 8
16804: PPUSH
16805: LD_STRING DR-G3
16807: PPUSH
16808: CALL_OW 88
// if Gali then
16812: LD_EXP 3
16816: IFFALSE 16832
// Say ( Gali , DGa-G4 ) else
16818: LD_EXP 3
16822: PPUSH
16823: LD_STRING DGa-G4
16825: PPUSH
16826: CALL_OW 88
16830: GO 16844
// Say ( Mike , DGa-G4 ) ;
16832: LD_EXP 5
16836: PPUSH
16837: LD_STRING DGa-G4
16839: PPUSH
16840: CALL_OW 88
// Say ( Louis , DL-G2 ) ;
16844: LD_EXP 1
16848: PPUSH
16849: LD_STRING DL-G2
16851: PPUSH
16852: CALL_OW 88
// if Nicolas then
16856: LD_EXP 4
16860: IFFALSE 16874
// Say ( Nicolas , DMi-G2 ) ;
16862: LD_EXP 4
16866: PPUSH
16867: LD_STRING DMi-G2
16869: PPUSH
16870: CALL_OW 88
// DialogueOff ;
16874: CALL_OW 7
// InGameOff ;
16878: CALL_OW 9
// end ;
16882: END
// every 0 0$01 trigger GetResourceType ( GetBase ( ar_depot ) , mat_cans ) < 200 do
16883: LD_INT 18
16885: PPUSH
16886: CALL_OW 274
16890: PPUSH
16891: LD_INT 1
16893: PPUSH
16894: CALL_OW 275
16898: PUSH
16899: LD_INT 200
16901: LESS
16902: IFFALSE 17215
16904: GO 16906
16906: DISABLE
// begin Ar_Squad := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ Louis , Rolf , Jenna ] ;
16907: LD_ADDR_EXP 9
16911: PUSH
16912: LD_INT 22
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PUSH
16922: LD_INT 2
16924: PUSH
16925: LD_INT 25
16927: PUSH
16928: LD_INT 1
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: LD_INT 25
16937: PUSH
16938: LD_INT 2
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PUSH
16945: LD_INT 25
16947: PUSH
16948: LD_INT 3
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 25
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: PUSH
16972: EMPTY
16973: LIST
16974: LIST
16975: PPUSH
16976: CALL_OW 69
16980: PUSH
16981: LD_EXP 1
16985: PUSH
16986: LD_EXP 8
16990: PUSH
16991: LD_EXP 6
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: DIFF
17001: ST_TO_ADDR
// DialogueOn ;
17002: CALL_OW 6
// Say ( Louis , DL-9 ) ;
17006: LD_EXP 1
17010: PPUSH
17011: LD_STRING DL-9
17013: PPUSH
17014: CALL_OW 88
// Say ( Rolf , DR-7 ) ;
17018: LD_EXP 8
17022: PPUSH
17023: LD_STRING DR-7
17025: PPUSH
17026: CALL_OW 88
// Say ( Louis , DL-10 ) ;
17030: LD_EXP 1
17034: PPUSH
17035: LD_STRING DL-10
17037: PPUSH
17038: CALL_OW 88
// Say ( SayMen , DRa-1 ) ;
17042: CALL 2334 0 0
17046: PPUSH
17047: LD_STRING DRa-1
17049: PPUSH
17050: CALL_OW 88
// Say ( Louis , DL-11 ) ;
17054: LD_EXP 1
17058: PPUSH
17059: LD_STRING DL-11
17061: PPUSH
17062: CALL_OW 88
// Say ( Ar_Squad [ 1 ] , DRa-2 ) ;
17066: LD_EXP 9
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PPUSH
17075: LD_STRING DRa-2
17077: PPUSH
17078: CALL_OW 88
// Say ( SayMen , DRa-3 ) ;
17082: CALL 2334 0 0
17086: PPUSH
17087: LD_STRING DRa-3
17089: PPUSH
17090: CALL_OW 88
// Say ( Ar_Squad [ 1 ] , DRa-4 ) ;
17094: LD_EXP 9
17098: PUSH
17099: LD_INT 1
17101: ARRAY
17102: PPUSH
17103: LD_STRING DRa-4
17105: PPUSH
17106: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) then
17110: LD_INT 22
17112: PUSH
17113: LD_INT 2
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: PUSH
17120: LD_INT 25
17122: PUSH
17123: LD_INT 4
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: PPUSH
17134: CALL_OW 69
17138: IFFALSE 17159
// begin Say ( SaySci , Dsci-1 ) ;
17140: CALL 2397 0 0
17144: PPUSH
17145: LD_STRING Dsci-1
17147: PPUSH
17148: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
17152: LD_INT 10
17154: PPUSH
17155: CALL_OW 68
// end ; Say ( Louis , DL-Radar ) ;
17159: LD_EXP 1
17163: PPUSH
17164: LD_STRING DL-Radar
17166: PPUSH
17167: CALL_OW 88
// DialogueOff ;
17171: CALL_OW 7
// Wait ( 0 0$0.3 ) ;
17175: LD_INT 10
17177: PPUSH
17178: CALL_OW 67
// ChangeMissionObjectives ( TRad ) ;
17182: LD_STRING TRad
17184: PPUSH
17185: CALL_OW 337
// SetTech ( 7 , 2 , state_enabled ) ;
17189: LD_INT 7
17191: PPUSH
17192: LD_INT 2
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 322
// SetTech ( 8 , 2 , state_enabled ) ;
17202: LD_INT 8
17204: PPUSH
17205: LD_INT 2
17207: PPUSH
17208: LD_INT 1
17210: PPUSH
17211: CALL_OW 322
// end ;
17215: END
// every 0 0$01 trigger bazooka_dialog do
17216: LD_EXP 31
17220: IFFALSE 17276
17222: GO 17224
17224: DISABLE
// begin DialogueOn ;
17225: CALL_OW 6
// Say ( Louis , DL-Baz1 ) ;
17229: LD_EXP 1
17233: PPUSH
17234: LD_STRING DL-Baz1
17236: PPUSH
17237: CALL_OW 88
// Say ( Rolf , DR-Baz1 ) ;
17241: LD_EXP 8
17245: PPUSH
17246: LD_STRING DR-Baz1
17248: PPUSH
17249: CALL_OW 88
// Say ( Louis , DL-BazN ) ;
17253: LD_EXP 1
17257: PPUSH
17258: LD_STRING DL-BazN
17260: PPUSH
17261: CALL_OW 88
// DialogueOff ;
17265: CALL_OW 7
// Hint ( NBaz ) ;
17269: LD_STRING NBaz
17271: PPUSH
17272: CALL_OW 339
// end ;
17276: END
// every 0 0$0.1 trigger bazooka_num do
17277: LD_EXP 30
17281: IFFALSE 17387
17283: GO 17285
17285: DISABLE
// begin enable ;
17286: ENABLE
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 9 ] ] ) = bazooka_num then
17287: LD_INT 22
17289: PUSH
17290: LD_INT 2
17292: PUSH
17293: EMPTY
17294: LIST
17295: LIST
17296: PUSH
17297: LD_INT 25
17299: PUSH
17300: LD_INT 9
17302: PUSH
17303: EMPTY
17304: LIST
17305: LIST
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PPUSH
17311: CALL_OW 69
17315: PUSH
17316: LD_EXP 30
17320: EQUAL
17321: IFFALSE 17338
// SetTech ( tech_bazooka , 2 , state_disabled ) else
17323: LD_INT 44
17325: PPUSH
17326: LD_INT 2
17328: PPUSH
17329: LD_INT 0
17331: PPUSH
17332: CALL_OW 322
17336: GO 17387
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 9 ] ] ) < bazooka_num then
17338: LD_INT 22
17340: PUSH
17341: LD_INT 2
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: PUSH
17348: LD_INT 25
17350: PUSH
17351: LD_INT 9
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PPUSH
17362: CALL_OW 69
17366: PUSH
17367: LD_EXP 30
17371: LESS
17372: IFFALSE 17387
// SetTech ( tech_bazooka , 2 , state_researched ) ;
17374: LD_INT 44
17376: PPUSH
17377: LD_INT 2
17379: PPUSH
17380: LD_INT 2
17382: PPUSH
17383: CALL_OW 322
// end ;
17387: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_bazooker ] ] ) > bazooka_num do
17388: LD_INT 22
17390: PUSH
17391: LD_INT 2
17393: PUSH
17394: EMPTY
17395: LIST
17396: LIST
17397: PUSH
17398: LD_INT 25
17400: PUSH
17401: LD_INT 9
17403: PUSH
17404: EMPTY
17405: LIST
17406: LIST
17407: PUSH
17408: EMPTY
17409: LIST
17410: LIST
17411: PPUSH
17412: CALL_OW 69
17416: PUSH
17417: LD_EXP 30
17421: GREATER
17422: IFFALSE 17468
17424: GO 17426
17426: DISABLE
// begin enable ;
17427: ENABLE
// SetClass ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_bazooker ] ] ) [ 1 ] , 1 ) ;
17428: LD_INT 22
17430: PUSH
17431: LD_INT 2
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: PUSH
17438: LD_INT 25
17440: PUSH
17441: LD_INT 9
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: PPUSH
17452: CALL_OW 69
17456: PUSH
17457: LD_INT 1
17459: ARRAY
17460: PPUSH
17461: LD_INT 1
17463: PPUSH
17464: CALL_OW 336
// end ;
17468: END
// every 0 0$01 trigger bazooka_num = 0 do
17469: LD_EXP 30
17473: PUSH
17474: LD_INT 0
17476: EQUAL
17477: IFFALSE 17495
17479: GO 17481
17481: DISABLE
// begin SetTech ( tech_bazooka , 2 , state_disabled ) ;
17482: LD_INT 44
17484: PPUSH
17485: LD_INT 2
17487: PPUSH
17488: LD_INT 0
17490: PPUSH
17491: CALL_OW 322
// end ;
17495: END
// every 0 0$01 trigger comp_attack do var un ;
17496: LD_EXP 36
17500: IFFALSE 17668
17502: GO 17504
17504: DISABLE
17505: LD_INT 0
17507: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 9 ] ] ] ) diff [ Louis , Rolf ] ;
17508: LD_ADDR_VAR 0 1
17512: PUSH
17513: LD_INT 22
17515: PUSH
17516: LD_INT 2
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: LD_INT 25
17528: PUSH
17529: LD_INT 1
17531: PUSH
17532: EMPTY
17533: LIST
17534: LIST
17535: PUSH
17536: LD_INT 25
17538: PUSH
17539: LD_INT 9
17541: PUSH
17542: EMPTY
17543: LIST
17544: LIST
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: LIST
17550: PUSH
17551: EMPTY
17552: LIST
17553: LIST
17554: PPUSH
17555: CALL_OW 69
17559: PUSH
17560: LD_EXP 1
17564: PUSH
17565: LD_EXP 8
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: DIFF
17574: ST_TO_ADDR
// DialogueOn ;
17575: CALL_OW 6
// Say ( un [ 1 ] , DRand-ruattack1 ) ;
17579: LD_VAR 0 1
17583: PUSH
17584: LD_INT 1
17586: ARRAY
17587: PPUSH
17588: LD_STRING DRand-ruattack1
17590: PPUSH
17591: CALL_OW 88
// Say ( Louis , DL-ruattack1 ) ;
17595: LD_EXP 1
17599: PPUSH
17600: LD_STRING DL-ruattack1
17602: PPUSH
17603: CALL_OW 88
// if IsLive ( Rolf ) then
17607: LD_EXP 8
17611: PPUSH
17612: CALL_OW 300
17616: IFFALSE 17632
// Say ( Rolf , DR-ruattack1 ) else
17618: LD_EXP 8
17622: PPUSH
17623: LD_STRING DR-ruattack1
17625: PPUSH
17626: CALL_OW 88
17630: GO 17648
// Say ( un [ 2 ] , DR-ruattack1 ) ;
17632: LD_VAR 0 1
17636: PUSH
17637: LD_INT 2
17639: ARRAY
17640: PPUSH
17641: LD_STRING DR-ruattack1
17643: PPUSH
17644: CALL_OW 88
// Say ( un [ 1 ] , DRand-ruattack2 ) ;
17648: LD_VAR 0 1
17652: PUSH
17653: LD_INT 1
17655: ARRAY
17656: PPUSH
17657: LD_STRING DRand-ruattack2
17659: PPUSH
17660: CALL_OW 88
// DialogueOff ;
17664: CALL_OW 7
// end ;
17668: PPOPN 1
17670: END
// every 0 0$01 trigger tick > 35 * 60 * 30 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) > 0 do
17671: LD_OWVAR 1
17675: PUSH
17676: LD_INT 35
17678: PUSH
17679: LD_INT 60
17681: MUL
17682: PUSH
17683: LD_INT 30
17685: MUL
17686: GREATER
17687: PUSH
17688: LD_INT 22
17690: PUSH
17691: LD_INT 2
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 30
17700: PUSH
17701: LD_INT 1
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: PPUSH
17712: CALL_OW 69
17716: PUSH
17717: LD_INT 0
17719: GREATER
17720: AND
17721: IFFALSE 17975
17723: GO 17725
17725: DISABLE
// begin InGameOn ;
17726: CALL_OW 8
// DialogueOn ;
17730: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , Dradio1 ) ;
17734: LD_INT 22
17736: PUSH
17737: LD_INT 2
17739: PUSH
17740: EMPTY
17741: LIST
17742: LIST
17743: PUSH
17744: LD_INT 2
17746: PUSH
17747: LD_INT 25
17749: PUSH
17750: LD_INT 3
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: PUSH
17757: LD_INT 25
17759: PUSH
17760: LD_INT 4
17762: PUSH
17763: EMPTY
17764: LIST
17765: LIST
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: LIST
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: PPUSH
17776: CALL_OW 69
17780: PUSH
17781: LD_INT 1
17783: ARRAY
17784: PPUSH
17785: LD_STRING Dradio1
17787: PPUSH
17788: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
17792: LD_INT 10
17794: PPUSH
17795: CALL_OW 68
// SayRadio ( Platonov , DPlat1 ) ;
17799: LD_EXP 22
17803: PPUSH
17804: LD_STRING DPlat1
17806: PPUSH
17807: CALL_OW 94
// SayRadio ( Gladkov , DGlad1 ) ;
17811: LD_EXP 21
17815: PPUSH
17816: LD_STRING DGlad1
17818: PPUSH
17819: CALL_OW 94
// SayRadio ( Platonov , DPlat2 ) ;
17823: LD_EXP 22
17827: PPUSH
17828: LD_STRING DPlat2
17830: PPUSH
17831: CALL_OW 94
// SayRadio ( Gladkov , DGlad2 ) ;
17835: LD_EXP 21
17839: PPUSH
17840: LD_STRING DGlad2
17842: PPUSH
17843: CALL_OW 94
// DWait ( 0 0$0.3 ) ;
17847: LD_INT 10
17849: PPUSH
17850: CALL_OW 68
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , Dradio2 ) ;
17854: LD_INT 22
17856: PUSH
17857: LD_INT 2
17859: PUSH
17860: EMPTY
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 2
17866: PUSH
17867: LD_INT 25
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: EMPTY
17874: LIST
17875: LIST
17876: PUSH
17877: LD_INT 25
17879: PUSH
17880: LD_INT 4
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: LIST
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PPUSH
17896: CALL_OW 69
17900: PUSH
17901: LD_INT 1
17903: ARRAY
17904: PPUSH
17905: LD_STRING Dradio2
17907: PPUSH
17908: CALL_OW 88
// Say ( Louis , DLradio1 ) ;
17912: LD_EXP 1
17916: PPUSH
17917: LD_STRING DLradio1
17919: PPUSH
17920: CALL_OW 88
// if IsLive ( Nicolas ) then
17924: LD_EXP 4
17928: PPUSH
17929: CALL_OW 300
17933: IFFALSE 17959
// begin Say ( Nicolas , DVercken1 ) ;
17935: LD_EXP 4
17939: PPUSH
17940: LD_STRING DVercken1
17942: PPUSH
17943: CALL_OW 88
// Say ( Gali , DGali1 ) ;
17947: LD_EXP 3
17951: PPUSH
17952: LD_STRING DGali1
17954: PPUSH
17955: CALL_OW 88
// end ; gladkov_attack := true ;
17959: LD_ADDR_EXP 38
17963: PUSH
17964: LD_INT 1
17966: ST_TO_ADDR
// DialogueOff ;
17967: CALL_OW 7
// InGameOff ;
17971: CALL_OW 9
// end ;
17975: END
// every 0 0$01 trigger GetResourceType ( GetBase ( ar_depot ) , 3 ) >= 200 do
17976: LD_INT 18
17978: PPUSH
17979: CALL_OW 274
17983: PPUSH
17984: LD_INT 3
17986: PPUSH
17987: CALL_OW 275
17991: PUSH
17992: LD_INT 200
17994: GREATEREQUAL
17995: IFFALSE 18063
17997: GO 17999
17999: DISABLE
// begin go_to_end := true ;
18000: LD_ADDR_EXP 32
18004: PUSH
18005: LD_INT 1
18007: ST_TO_ADDR
// DialogueOn ;
18008: CALL_OW 6
// Say ( Louis , DL-Sib ) ;
18012: LD_EXP 1
18016: PPUSH
18017: LD_STRING DL-Sib
18019: PPUSH
18020: CALL_OW 88
// if sib_pow then
18024: LD_EXP 33
18028: IFFALSE 18042
// Say ( Louis , DL-SibPowDes ) ;
18030: LD_EXP 1
18034: PPUSH
18035: LD_STRING DL-SibPowDes
18037: PPUSH
18038: CALL_OW 88
// DialogueOff ;
18042: CALL_OW 7
// ChangeMissionObjectives ( TEnd ) ;
18046: LD_STRING TEnd
18048: PPUSH
18049: CALL_OW 337
// SetAreaMapShow ( exit_area , 1 ) ;
18053: LD_INT 14
18055: PPUSH
18056: LD_INT 1
18058: PPUSH
18059: CALL_OW 424
// end ;
18063: END
// every 0 0$01 trigger FilterAllUnits ( [ f_btype , b_siberite_power ] ) do
18064: LD_INT 30
18066: PUSH
18067: LD_INT 28
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PPUSH
18074: CALL_OW 69
18078: IFFALSE 18288
18080: GO 18082
18082: DISABLE
// begin DialogueOn ;
18083: CALL_OW 6
// if IsLive ( Jenna ) then
18087: LD_EXP 6
18091: PPUSH
18092: CALL_OW 300
18096: IFFALSE 18112
// Say ( Jenna , DSibPow-1 ) else
18098: LD_EXP 6
18102: PPUSH
18103: LD_STRING DSibPow-1
18105: PPUSH
18106: CALL_OW 88
18110: GO 18170
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , DSibPow-1 ) ;
18112: LD_INT 22
18114: PUSH
18115: LD_INT 2
18117: PUSH
18118: EMPTY
18119: LIST
18120: LIST
18121: PUSH
18122: LD_INT 2
18124: PUSH
18125: LD_INT 25
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 25
18137: PUSH
18138: LD_INT 4
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PPUSH
18154: CALL_OW 69
18158: PUSH
18159: LD_INT 1
18161: ARRAY
18162: PPUSH
18163: LD_STRING DSibPow-1
18165: PPUSH
18166: CALL_OW 88
// Say ( Louis , DLSibPow-1 ) ;
18170: LD_EXP 1
18174: PPUSH
18175: LD_STRING DLSibPow-1
18177: PPUSH
18178: CALL_OW 88
// if IsLive ( Jenna ) then
18182: LD_EXP 6
18186: PPUSH
18187: CALL_OW 300
18191: IFFALSE 18207
// Say ( Jenna , DSibPow-2 ) else
18193: LD_EXP 6
18197: PPUSH
18198: LD_STRING DSibPow-2
18200: PPUSH
18201: CALL_OW 88
18205: GO 18265
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , DSibPow-2 ) ;
18207: LD_INT 22
18209: PUSH
18210: LD_INT 2
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: PUSH
18217: LD_INT 2
18219: PUSH
18220: LD_INT 25
18222: PUSH
18223: LD_INT 3
18225: PUSH
18226: EMPTY
18227: LIST
18228: LIST
18229: PUSH
18230: LD_INT 25
18232: PUSH
18233: LD_INT 4
18235: PUSH
18236: EMPTY
18237: LIST
18238: LIST
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: LIST
18244: PUSH
18245: EMPTY
18246: LIST
18247: LIST
18248: PPUSH
18249: CALL_OW 69
18253: PUSH
18254: LD_INT 1
18256: ARRAY
18257: PPUSH
18258: LD_STRING DSibPow-2
18260: PPUSH
18261: CALL_OW 88
// Say ( Louis , DLSibPow-2 ) ;
18265: LD_EXP 1
18269: PPUSH
18270: LD_STRING DLSibPow-2
18272: PPUSH
18273: CALL_OW 88
// DialogueOff ;
18277: CALL_OW 7
// ChangeMissionObjectives ( ESib ) ;
18281: LD_STRING ESib
18283: PPUSH
18284: CALL_OW 337
// end ;
18288: END
// every 0 0$30 trigger tick > 35 * 60 * [ 19 , 16 , 13 ] [ Difficulty ] do
18289: LD_OWVAR 1
18293: PUSH
18294: LD_INT 35
18296: PUSH
18297: LD_INT 60
18299: MUL
18300: PUSH
18301: LD_INT 19
18303: PUSH
18304: LD_INT 16
18306: PUSH
18307: LD_INT 13
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: LIST
18314: PUSH
18315: LD_OWVAR 67
18319: ARRAY
18320: MUL
18321: GREATER
18322: IFFALSE 18525
18324: GO 18326
18326: DISABLE
// begin InGameOn ;
18327: CALL_OW 8
// DialogueOn ;
18331: CALL_OW 6
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , DAR1 ) ;
18335: LD_INT 22
18337: PUSH
18338: LD_INT 2
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PUSH
18345: LD_INT 2
18347: PUSH
18348: LD_INT 25
18350: PUSH
18351: LD_INT 3
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: PUSH
18358: LD_INT 25
18360: PUSH
18361: LD_INT 4
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: LIST
18372: PUSH
18373: EMPTY
18374: LIST
18375: LIST
18376: PPUSH
18377: CALL_OW 69
18381: PUSH
18382: LD_INT 1
18384: ARRAY
18385: PPUSH
18386: LD_STRING DAR1
18388: PPUSH
18389: CALL_OW 88
// SayRadio ( Platonov , DAPlat1 ) ;
18393: LD_EXP 22
18397: PPUSH
18398: LD_STRING DAPlat1
18400: PPUSH
18401: CALL_OW 94
// SayRadio ( Gladkov , DAGlad1 ) ;
18405: LD_EXP 21
18409: PPUSH
18410: LD_STRING DAGlad1
18412: PPUSH
18413: CALL_OW 94
// Say ( Louis , DAR2 ) ;
18417: LD_EXP 1
18421: PPUSH
18422: LD_STRING DAR2
18424: PPUSH
18425: CALL_OW 88
// if IsLive ( Gali ) then
18429: LD_EXP 3
18433: PPUSH
18434: CALL_OW 300
18438: IFFALSE 18466
// begin Say ( Gali , DARG1 ) ;
18440: LD_EXP 3
18444: PPUSH
18445: LD_STRING DARG1
18447: PPUSH
18448: CALL_OW 88
// Say ( Gali , DARG2 ) ;
18452: LD_EXP 3
18456: PPUSH
18457: LD_STRING DARG2
18459: PPUSH
18460: CALL_OW 88
// end else
18464: GO 18478
// Say ( Rolf , DARR1 ) ;
18466: LD_EXP 8
18470: PPUSH
18471: LD_STRING DARR1
18473: PPUSH
18474: CALL_OW 88
// Say ( Louis , DAR2a ) ;
18478: LD_EXP 1
18482: PPUSH
18483: LD_STRING DAR2a
18485: PPUSH
18486: CALL_OW 88
// DialogueOff ;
18490: CALL_OW 7
// InGameOff ;
18494: CALL_OW 9
// dont_attack = true ;
18498: LD_ADDR_EXP 25
18502: PUSH
18503: LD_INT 1
18505: ST_TO_ADDR
// Wait ( Rand ( 5 5$00 , 7 7$00 ) ) ;
18506: LD_INT 10500
18508: PPUSH
18509: LD_INT 14700
18511: PPUSH
18512: CALL_OW 12
18516: PPUSH
18517: CALL_OW 67
// AmmoEvent ;
18521: CALL 12946 0 0
// end ;
18525: END
// every 0 0$01 trigger See ( 2 , main_sci ) and CanUseBazooka = false do
18526: LD_INT 2
18528: PPUSH
18529: LD_EXP 27
18533: PPUSH
18534: CALL_OW 292
18538: PUSH
18539: LD_EXP 23
18543: PUSH
18544: LD_INT 0
18546: EQUAL
18547: AND
18548: IFFALSE 18592
18550: GO 18552
18552: DISABLE
// begin if Difficulty < 3 then
18553: LD_OWVAR 67
18557: PUSH
18558: LD_INT 3
18560: LESS
18561: IFFALSE 18571
// game_speed := 2 ;
18563: LD_ADDR_OWVAR 65
18567: PUSH
18568: LD_INT 2
18570: ST_TO_ADDR
// CenterOnUnits ( main_sci ) ;
18571: LD_EXP 27
18575: PPUSH
18576: CALL_OW 85
// Say ( Louis , DAR3 ) ;
18580: LD_EXP 1
18584: PPUSH
18585: LD_STRING DAR3
18587: PPUSH
18588: CALL_OW 88
// end ;
18592: END
// every 0 0$01 trigger main_sci_dead and CanUseBazooka = false do
18593: LD_EXP 24
18597: PUSH
18598: LD_EXP 23
18602: PUSH
18603: LD_INT 0
18605: EQUAL
18606: AND
18607: IFFALSE 18717
18609: GO 18611
18611: DISABLE
// begin Say ( Louis , DAR4 ) ;
18612: LD_EXP 1
18616: PPUSH
18617: LD_STRING DAR4
18619: PPUSH
18620: CALL_OW 88
// Wait ( 4 4$00 ) ;
18624: LD_INT 8400
18626: PPUSH
18627: CALL_OW 67
// Say ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) [ 1 ] , DAR5 ) ;
18631: LD_INT 22
18633: PUSH
18634: LD_INT 2
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 2
18643: PUSH
18644: LD_INT 25
18646: PUSH
18647: LD_INT 3
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PUSH
18654: LD_INT 25
18656: PUSH
18657: LD_INT 4
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: LIST
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PPUSH
18673: CALL_OW 69
18677: PUSH
18678: LD_INT 1
18680: ARRAY
18681: PPUSH
18682: LD_STRING DAR5
18684: PPUSH
18685: CALL_OW 88
// SetTech ( 29 , 2 , state_researched ) ;
18689: LD_INT 29
18691: PPUSH
18692: LD_INT 2
18694: PPUSH
18695: LD_INT 2
18697: PPUSH
18698: CALL_OW 322
// Wait ( 0 0$10 ) ;
18702: LD_INT 350
18704: PPUSH
18705: CALL_OW 67
// dont_attack = false ;
18709: LD_ADDR_EXP 25
18713: PUSH
18714: LD_INT 0
18716: ST_TO_ADDR
// end ;
18717: END
// every 0 0$03 trigger go_to_end and FilterUnitsInArea ( exit_area , [ f_weapon , ar_cargo_bay ] ) >= 2 do var i , filter , cargo ;
18718: LD_EXP 32
18722: PUSH
18723: LD_INT 14
18725: PPUSH
18726: LD_INT 34
18728: PUSH
18729: LD_INT 32
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: PPUSH
18736: CALL_OW 70
18740: PUSH
18741: LD_INT 2
18743: GREATEREQUAL
18744: AND
18745: IFFALSE 18861
18747: GO 18749
18749: DISABLE
18750: LD_INT 0
18752: PPUSH
18753: PPUSH
18754: PPUSH
// begin enable ;
18755: ENABLE
// cargo := 0 ;
18756: LD_ADDR_VAR 0 3
18760: PUSH
18761: LD_INT 0
18763: ST_TO_ADDR
// filter := FilterUnitsInArea ( exit_area , [ f_weapon , ar_cargo_bay ] ) ;
18764: LD_ADDR_VAR 0 2
18768: PUSH
18769: LD_INT 14
18771: PPUSH
18772: LD_INT 34
18774: PUSH
18775: LD_INT 32
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PPUSH
18782: CALL_OW 70
18786: ST_TO_ADDR
// for i = 1 to filter do
18787: LD_ADDR_VAR 0 1
18791: PUSH
18792: DOUBLE
18793: LD_INT 1
18795: DEC
18796: ST_TO_ADDR
18797: LD_VAR 0 2
18801: PUSH
18802: FOR_TO
18803: IFFALSE 18837
// cargo := cargo + GetCargo ( filter [ i ] , 3 ) ;
18805: LD_ADDR_VAR 0 3
18809: PUSH
18810: LD_VAR 0 3
18814: PUSH
18815: LD_VAR 0 2
18819: PUSH
18820: LD_VAR 0 1
18824: ARRAY
18825: PPUSH
18826: LD_INT 3
18828: PPUSH
18829: CALL_OW 289
18833: PLUS
18834: ST_TO_ADDR
18835: GO 18802
18837: POP
18838: POP
// if cargo = 200 then
18839: LD_VAR 0 3
18843: PUSH
18844: LD_INT 200
18846: EQUAL
18847: IFFALSE 18861
// begin END_MISSION ;
18849: CALL 18864 0 0
// go_to_end := false ;
18853: LD_ADDR_EXP 32
18857: PUSH
18858: LD_INT 0
18860: ST_TO_ADDR
// end ; end ; end_of_file
18861: PPOPN 3
18863: END
// export function END_MISSION ; var names , filter , i , tab , cargos ; begin
18864: LD_INT 0
18866: PPUSH
18867: PPUSH
18868: PPUSH
18869: PPUSH
18870: PPUSH
18871: PPUSH
// if FilterAllUnits ( [ f_or , [ [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_btype , b_warehouse ] ] ) = 0 then
18872: LD_INT 2
18874: PUSH
18875: LD_INT 22
18877: PUSH
18878: LD_INT 3
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: PUSH
18885: LD_INT 22
18887: PUSH
18888: LD_INT 6
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: PUSH
18895: EMPTY
18896: LIST
18897: LIST
18898: PUSH
18899: LD_INT 30
18901: PUSH
18902: LD_INT 1
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: PUSH
18909: EMPTY
18910: LIST
18911: LIST
18912: LIST
18913: PPUSH
18914: CALL_OW 69
18918: PUSH
18919: LD_INT 0
18921: EQUAL
18922: IFFALSE 18936
// SaveVariable ( 1 , var_rus ) else
18924: LD_INT 1
18926: PPUSH
18927: LD_STRING var_rus
18929: PPUSH
18930: CALL_OW 39
18934: GO 18946
// SaveVariable ( 0 , var_rus ) ;
18936: LD_INT 0
18938: PPUSH
18939: LD_STRING var_rus
18941: PPUSH
18942: CALL_OW 39
// if GetTech ( 8 , 2 ) = state_researched then
18946: LD_INT 8
18948: PPUSH
18949: LD_INT 2
18951: PPUSH
18952: CALL_OW 321
18956: PUSH
18957: LD_INT 2
18959: EQUAL
18960: IFFALSE 18974
// SaveVariable ( 1 , var_bio ) else
18962: LD_INT 1
18964: PPUSH
18965: LD_STRING var_bio
18967: PPUSH
18968: CALL_OW 39
18972: GO 18984
// SaveVariable ( 0 , var_bio ) ;
18974: LD_INT 0
18976: PPUSH
18977: LD_STRING var_bio
18979: PPUSH
18980: CALL_OW 39
// if GetTech ( 29 , 2 ) = state_researched then
18984: LD_INT 29
18986: PPUSH
18987: LD_INT 2
18989: PPUSH
18990: CALL_OW 321
18994: PUSH
18995: LD_INT 2
18997: EQUAL
18998: IFFALSE 19012
// SaveVariable ( 1 , var_ammo ) else
19000: LD_INT 1
19002: PPUSH
19003: LD_STRING var_ammo
19005: PPUSH
19006: CALL_OW 39
19010: GO 19022
// SaveVariable ( 0 , var_ammo ) ;
19012: LD_INT 0
19014: PPUSH
19015: LD_STRING var_ammo
19017: PPUSH
19018: CALL_OW 39
// tab := [ ] ;
19022: LD_ADDR_VAR 0 5
19026: PUSH
19027: EMPTY
19028: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
19029: LD_ADDR_VAR 0 3
19033: PUSH
19034: LD_INT 22
19036: PUSH
19037: LD_INT 2
19039: PUSH
19040: EMPTY
19041: LIST
19042: LIST
19043: PUSH
19044: LD_INT 21
19046: PUSH
19047: LD_INT 2
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 58
19059: PUSH
19060: EMPTY
19061: LIST
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: LIST
19071: PPUSH
19072: CALL_OW 69
19076: ST_TO_ADDR
// cargos := 0 ;
19077: LD_ADDR_VAR 0 6
19081: PUSH
19082: LD_INT 0
19084: ST_TO_ADDR
// for i = 1 to filter do
19085: LD_ADDR_VAR 0 4
19089: PUSH
19090: DOUBLE
19091: LD_INT 1
19093: DEC
19094: ST_TO_ADDR
19095: LD_VAR 0 3
19099: PUSH
19100: FOR_TO
19101: IFFALSE 19333
// begin if GetWeapon ( filter [ i ] ) = ar_cargo_bay and cargos < 2 then
19103: LD_VAR 0 3
19107: PUSH
19108: LD_VAR 0 4
19112: ARRAY
19113: PPUSH
19114: CALL_OW 264
19118: PUSH
19119: LD_INT 32
19121: EQUAL
19122: PUSH
19123: LD_VAR 0 6
19127: PUSH
19128: LD_INT 2
19130: LESS
19131: AND
19132: IFFALSE 19229
// begin cargos := cargos + 1 ;
19134: LD_ADDR_VAR 0 6
19138: PUSH
19139: LD_VAR 0 6
19143: PUSH
19144: LD_INT 1
19146: PLUS
19147: ST_TO_ADDR
// tab := tab ^ [ GetChassis ( filter [ i ] ) , GetEngine ( filter [ i ] ) , GetControl ( filter [ i ] ) , GetWeapon ( filter [ i ] ) ] ;
19148: LD_ADDR_VAR 0 5
19152: PUSH
19153: LD_VAR 0 5
19157: PUSH
19158: LD_VAR 0 3
19162: PUSH
19163: LD_VAR 0 4
19167: ARRAY
19168: PPUSH
19169: CALL_OW 265
19173: PUSH
19174: LD_VAR 0 3
19178: PUSH
19179: LD_VAR 0 4
19183: ARRAY
19184: PPUSH
19185: CALL_OW 262
19189: PUSH
19190: LD_VAR 0 3
19194: PUSH
19195: LD_VAR 0 4
19199: ARRAY
19200: PPUSH
19201: CALL_OW 263
19205: PUSH
19206: LD_VAR 0 3
19210: PUSH
19211: LD_VAR 0 4
19215: ARRAY
19216: PPUSH
19217: CALL_OW 264
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: LIST
19226: LIST
19227: ADD
19228: ST_TO_ADDR
// end ; if GetWeapon ( filter [ i ] ) <> ar_cargo_bay then
19229: LD_VAR 0 3
19233: PUSH
19234: LD_VAR 0 4
19238: ARRAY
19239: PPUSH
19240: CALL_OW 264
19244: PUSH
19245: LD_INT 32
19247: NONEQUAL
19248: IFFALSE 19331
// tab := tab ^ [ GetChassis ( filter [ i ] ) , GetEngine ( filter [ i ] ) , GetControl ( filter [ i ] ) , GetWeapon ( filter [ i ] ) ] ;
19250: LD_ADDR_VAR 0 5
19254: PUSH
19255: LD_VAR 0 5
19259: PUSH
19260: LD_VAR 0 3
19264: PUSH
19265: LD_VAR 0 4
19269: ARRAY
19270: PPUSH
19271: CALL_OW 265
19275: PUSH
19276: LD_VAR 0 3
19280: PUSH
19281: LD_VAR 0 4
19285: ARRAY
19286: PPUSH
19287: CALL_OW 262
19291: PUSH
19292: LD_VAR 0 3
19296: PUSH
19297: LD_VAR 0 4
19301: ARRAY
19302: PPUSH
19303: CALL_OW 263
19307: PUSH
19308: LD_VAR 0 3
19312: PUSH
19313: LD_VAR 0 4
19317: ARRAY
19318: PPUSH
19319: CALL_OW 264
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: LIST
19328: LIST
19329: ADD
19330: ST_TO_ADDR
// end ;
19331: GO 19100
19333: POP
19334: POP
// SaveVariable ( tab , unit_vehs ) ;
19335: LD_VAR 0 5
19339: PPUSH
19340: LD_STRING unit_vehs
19342: PPUSH
19343: CALL_OW 39
// if GetTech ( 8 , 2 ) = state_researched then
19347: LD_INT 8
19349: PPUSH
19350: LD_INT 2
19352: PPUSH
19353: CALL_OW 321
19357: PUSH
19358: LD_INT 2
19360: EQUAL
19361: IFFALSE 19375
// AddMedal ( med1 , 1 ) else
19363: LD_STRING med1
19365: PPUSH
19366: LD_INT 1
19368: PPUSH
19369: CALL_OW 101
19373: GO 19386
// AddMedal ( med1 , - 1 ) ;
19375: LD_STRING med1
19377: PPUSH
19378: LD_INT 1
19380: NEG
19381: PPUSH
19382: CALL_OW 101
// if sib_pow then
19386: LD_EXP 33
19390: IFFALSE 19404
// AddMedal ( med2 , 1 ) else
19392: LD_STRING med2
19394: PPUSH
19395: LD_INT 1
19397: PPUSH
19398: CALL_OW 101
19402: GO 19415
// AddMedal ( med2 , - 1 ) ;
19404: LD_STRING med2
19406: PPUSH
19407: LD_INT 1
19409: NEG
19410: PPUSH
19411: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_bazooker ] ] ) > 0 then
19415: LD_INT 22
19417: PUSH
19418: LD_INT 2
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: PUSH
19425: LD_INT 25
19427: PUSH
19428: LD_INT 9
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: PUSH
19435: EMPTY
19436: LIST
19437: LIST
19438: PPUSH
19439: CALL_OW 69
19443: PUSH
19444: LD_INT 0
19446: GREATER
19447: IFFALSE 19461
// AddMedal ( med3 , 1 ) else
19449: LD_STRING med3
19451: PPUSH
19452: LD_INT 1
19454: PPUSH
19455: CALL_OW 101
19459: GO 19472
// AddMedal ( med3 , - 1 ) ;
19461: LD_STRING med3
19463: PPUSH
19464: LD_INT 1
19466: NEG
19467: PPUSH
19468: CALL_OW 101
// GiveMedals ( MAIN ) ;
19472: LD_STRING MAIN
19474: PPUSH
19475: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 15 ] ] , [ f_not , [ f_class , 16 ] ] ] ) ) ;
19479: LD_INT 22
19481: PUSH
19482: LD_INT 2
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: PUSH
19489: LD_INT 21
19491: PUSH
19492: LD_INT 1
19494: PUSH
19495: EMPTY
19496: LIST
19497: LIST
19498: PUSH
19499: LD_INT 3
19501: PUSH
19502: LD_INT 25
19504: PUSH
19505: LD_INT 15
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: PUSH
19516: LD_INT 3
19518: PUSH
19519: LD_INT 25
19521: PUSH
19522: LD_INT 16
19524: PUSH
19525: EMPTY
19526: LIST
19527: LIST
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: EMPTY
19534: LIST
19535: LIST
19536: LIST
19537: LIST
19538: PPUSH
19539: CALL_OW 69
19543: PPUSH
19544: CALL_OW 43
// SaveCharacters ( Louis , Louis ) ;
19548: LD_EXP 1
19552: PPUSH
19553: LD_STRING Louis
19555: PPUSH
19556: CALL_OW 38
// if IsLive ( Rolf ) then
19560: LD_EXP 8
19564: PPUSH
19565: CALL_OW 300
19569: IFFALSE 19583
// begin SaveCharacters ( Rolf , Rolf_08 ) ;
19571: LD_EXP 8
19575: PPUSH
19576: LD_STRING Rolf_08
19578: PPUSH
19579: CALL_OW 38
// end ; if IsLive ( Jenna ) then
19583: LD_EXP 6
19587: PPUSH
19588: CALL_OW 300
19592: IFFALSE 19606
// begin SaveCharacters ( Jenna , Jenna_08 ) ;
19594: LD_EXP 6
19598: PPUSH
19599: LD_STRING Jenna_08
19601: PPUSH
19602: CALL_OW 38
// end ; if IsLive ( Rick ) then
19606: LD_EXP 7
19610: PPUSH
19611: CALL_OW 300
19615: IFFALSE 19629
// begin SaveCharacters ( Rick , Rick_08 ) ;
19617: LD_EXP 7
19621: PPUSH
19622: LD_STRING Rick_08
19624: PPUSH
19625: CALL_OW 38
// end ; if IsLive ( Mike ) then
19629: LD_EXP 5
19633: PPUSH
19634: CALL_OW 300
19638: IFFALSE 19652
// begin SaveCharacters ( Mike , Mike_08 ) ;
19640: LD_EXP 5
19644: PPUSH
19645: LD_STRING Mike_08
19647: PPUSH
19648: CALL_OW 38
// end ; if IsLive ( Nicolas ) then
19652: LD_EXP 4
19656: PPUSH
19657: CALL_OW 300
19661: IFFALSE 19675
// begin SaveCharacters ( Nicolas , Nicolas_08 ) ;
19663: LD_EXP 4
19667: PPUSH
19668: LD_STRING Nicolas_08
19670: PPUSH
19671: CALL_OW 38
// end ; if IsLive ( Gali ) then
19675: LD_EXP 3
19679: PPUSH
19680: CALL_OW 300
19684: IFFALSE 19698
// begin SaveCharacters ( Gali , Gali_08 ) ;
19686: LD_EXP 3
19690: PPUSH
19691: LD_STRING Gali_08
19693: PPUSH
19694: CALL_OW 38
// end ; SetSide ( [ Louis , Rolf , Gali , Nicolas , Jenna , Rick , Mike ] , 5 ) ;
19698: LD_EXP 1
19702: PUSH
19703: LD_EXP 8
19707: PUSH
19708: LD_EXP 3
19712: PUSH
19713: LD_EXP 4
19717: PUSH
19718: LD_EXP 6
19722: PUSH
19723: LD_EXP 7
19727: PUSH
19728: LD_EXP 5
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: PPUSH
19742: LD_INT 5
19744: PPUSH
19745: CALL_OW 235
// filter := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
19749: LD_ADDR_VAR 0 3
19753: PUSH
19754: LD_INT 22
19756: PUSH
19757: LD_INT 2
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: PUSH
19764: LD_INT 21
19766: PUSH
19767: LD_INT 1
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL_OW 69
19782: ST_TO_ADDR
// names := [ a_08 , b_08 , c_08 , d_08 , e_08 , f_08 , g_08 , h_08 , i_08 , j_08 , k_08 , l_08 , m_08 , n_08 , o_08 , p_08 ] ;
19783: LD_ADDR_VAR 0 2
19787: PUSH
19788: LD_STRING a_08
19790: PUSH
19791: LD_STRING b_08
19793: PUSH
19794: LD_STRING c_08
19796: PUSH
19797: LD_STRING d_08
19799: PUSH
19800: LD_STRING e_08
19802: PUSH
19803: LD_STRING f_08
19805: PUSH
19806: LD_STRING g_08
19808: PUSH
19809: LD_STRING h_08
19811: PUSH
19812: LD_STRING i_08
19814: PUSH
19815: LD_STRING j_08
19817: PUSH
19818: LD_STRING k_08
19820: PUSH
19821: LD_STRING l_08
19823: PUSH
19824: LD_STRING m_08
19826: PUSH
19827: LD_STRING n_08
19829: PUSH
19830: LD_STRING o_08
19832: PUSH
19833: LD_STRING p_08
19835: PUSH
19836: EMPTY
19837: LIST
19838: LIST
19839: LIST
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: ST_TO_ADDR
// for i = 1 to filter do
19854: LD_ADDR_VAR 0 4
19858: PUSH
19859: DOUBLE
19860: LD_INT 1
19862: DEC
19863: ST_TO_ADDR
19864: LD_VAR 0 3
19868: PUSH
19869: FOR_TO
19870: IFFALSE 19938
// if IsLive ( filter [ i ] ) and GetClass ( filter [ i ] ) < 11 then
19872: LD_VAR 0 3
19876: PUSH
19877: LD_VAR 0 4
19881: ARRAY
19882: PPUSH
19883: CALL_OW 300
19887: PUSH
19888: LD_VAR 0 3
19892: PUSH
19893: LD_VAR 0 4
19897: ARRAY
19898: PPUSH
19899: CALL_OW 257
19903: PUSH
19904: LD_INT 11
19906: LESS
19907: AND
19908: IFFALSE 19936
// SaveCharacters ( filter [ i ] , names [ i ] ) ;
19910: LD_VAR 0 3
19914: PUSH
19915: LD_VAR 0 4
19919: ARRAY
19920: PPUSH
19921: LD_VAR 0 2
19925: PUSH
19926: LD_VAR 0 4
19930: ARRAY
19931: PPUSH
19932: CALL_OW 38
19936: GO 19869
19938: POP
19939: POP
// YouWin ;
19940: CALL_OW 103
// SetNextMission ( 1 ) ;
19944: LD_INT 1
19946: PPUSH
19947: CALL_OW 536
// end ;
19951: LD_VAR 0 1
19955: RET
