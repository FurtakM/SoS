// export function CustomInitMacro ; begin
   0: LD_INT 0
   2: PPUSH
// end ;
   3: LD_VAR 0 1
   7: RET
// export function CustomEvent ( event ) ; begin
   8: LD_INT 0
  10: PPUSH
// end ; end_of_file
  11: LD_VAR 0 2
  15: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
  16: LD_INT 0
  18: PPUSH
// ar_miner := 81 ;
  19: LD_ADDR_EXP 8
  23: PUSH
  24: LD_INT 81
  26: ST_TO_ADDR
// ar_crane := 88 ;
  27: LD_ADDR_EXP 7
  31: PUSH
  32: LD_INT 88
  34: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_INT 89
  42: ST_TO_ADDR
// us_hack := 99 ;
  43: LD_ADDR_EXP 3
  47: PUSH
  48: LD_INT 99
  50: ST_TO_ADDR
// us_artillery := 97 ;
  51: LD_ADDR_EXP 4
  55: PUSH
  56: LD_INT 97
  58: ST_TO_ADDR
// ar_bio_bomb := 91 ;
  59: LD_ADDR_EXP 5
  63: PUSH
  64: LD_INT 91
  66: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
  67: LD_ADDR_EXP 6
  71: PUSH
  72: LD_INT 92
  74: ST_TO_ADDR
// ru_radar := 98 ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 98
  82: ST_TO_ADDR
// tech_Artillery := 80 ;
  83: LD_ADDR_EXP 9
  87: PUSH
  88: LD_INT 80
  90: ST_TO_ADDR
// tech_RadMat := 81 ;
  91: LD_ADDR_EXP 10
  95: PUSH
  96: LD_INT 81
  98: ST_TO_ADDR
// tech_BasicTools := 82 ;
  99: LD_ADDR_EXP 11
 103: PUSH
 104: LD_INT 82
 106: ST_TO_ADDR
// tech_Cargo := 83 ;
 107: LD_ADDR_EXP 12
 111: PUSH
 112: LD_INT 83
 114: ST_TO_ADDR
// tech_Track := 84 ;
 115: LD_ADDR_EXP 13
 119: PUSH
 120: LD_INT 84
 122: ST_TO_ADDR
// tech_Crane := 85 ;
 123: LD_ADDR_EXP 14
 127: PUSH
 128: LD_INT 85
 130: ST_TO_ADDR
// tech_Bulldozer := 86 ;
 131: LD_ADDR_EXP 15
 135: PUSH
 136: LD_INT 86
 138: ST_TO_ADDR
// tech_Hovercraft := 87 ;
 139: LD_ADDR_EXP 16
 143: PUSH
 144: LD_INT 87
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// every 1 do
 152: GO 154
 154: DISABLE
// InitGlobalVariables ; end_of_file
 155: CALL 16 0 0
 159: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
 160: LD_VAR 0 2
 164: PUSH
 165: LD_INT 100
 167: EQUAL
 168: IFFALSE 1117
// begin if not StreamModeActive then
 170: LD_EXP 17
 174: NOT
 175: IFFALSE 185
// StreamModeActive := true ;
 177: LD_ADDR_EXP 17
 181: PUSH
 182: LD_INT 1
 184: ST_TO_ADDR
// if p3 = 0 then
 185: LD_VAR 0 3
 189: PUSH
 190: LD_INT 0
 192: EQUAL
 193: IFFALSE 199
// InitStreamMode ;
 195: CALL 1275 0 0
// if p3 = 1 then
 199: LD_VAR 0 3
 203: PUSH
 204: LD_INT 1
 206: EQUAL
 207: IFFALSE 217
// sRocket := true ;
 209: LD_ADDR_EXP 22
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// if p3 = 2 then
 217: LD_VAR 0 3
 221: PUSH
 222: LD_INT 2
 224: EQUAL
 225: IFFALSE 235
// sSpeed := true ;
 227: LD_ADDR_EXP 21
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// if p3 = 3 then
 235: LD_VAR 0 3
 239: PUSH
 240: LD_INT 3
 242: EQUAL
 243: IFFALSE 253
// sEngine := true ;
 245: LD_ADDR_EXP 23
 249: PUSH
 250: LD_INT 1
 252: ST_TO_ADDR
// if p3 = 4 then
 253: LD_VAR 0 3
 257: PUSH
 258: LD_INT 4
 260: EQUAL
 261: IFFALSE 271
// sSpec := true ;
 263: LD_ADDR_EXP 20
 267: PUSH
 268: LD_INT 1
 270: ST_TO_ADDR
// if p3 = 5 then
 271: LD_VAR 0 3
 275: PUSH
 276: LD_INT 5
 278: EQUAL
 279: IFFALSE 289
// sLevel := true ;
 281: LD_ADDR_EXP 24
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// if p3 = 6 then
 289: LD_VAR 0 3
 293: PUSH
 294: LD_INT 6
 296: EQUAL
 297: IFFALSE 307
// sArmoury := true ;
 299: LD_ADDR_EXP 25
 303: PUSH
 304: LD_INT 1
 306: ST_TO_ADDR
// if p3 = 7 then
 307: LD_VAR 0 3
 311: PUSH
 312: LD_INT 7
 314: EQUAL
 315: IFFALSE 325
// sRadar := true ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 1
 324: ST_TO_ADDR
// if p3 = 8 then
 325: LD_VAR 0 3
 329: PUSH
 330: LD_INT 8
 332: EQUAL
 333: IFFALSE 343
// sBunker := true ;
 335: LD_ADDR_EXP 27
 339: PUSH
 340: LD_INT 1
 342: ST_TO_ADDR
// if p3 = 9 then
 343: LD_VAR 0 3
 347: PUSH
 348: LD_INT 9
 350: EQUAL
 351: IFFALSE 361
// sHack := true ;
 353: LD_ADDR_EXP 28
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// if p3 = 10 then
 361: LD_VAR 0 3
 365: PUSH
 366: LD_INT 10
 368: EQUAL
 369: IFFALSE 379
// sFire := true ;
 371: LD_ADDR_EXP 29
 375: PUSH
 376: LD_INT 1
 378: ST_TO_ADDR
// if p3 = 11 then
 379: LD_VAR 0 3
 383: PUSH
 384: LD_INT 11
 386: EQUAL
 387: IFFALSE 397
// sRefresh := true ;
 389: LD_ADDR_EXP 30
 393: PUSH
 394: LD_INT 1
 396: ST_TO_ADDR
// if p3 = 12 then
 397: LD_VAR 0 3
 401: PUSH
 402: LD_INT 12
 404: EQUAL
 405: IFFALSE 415
// sExp := true ;
 407: LD_ADDR_EXP 31
 411: PUSH
 412: LD_INT 1
 414: ST_TO_ADDR
// if p3 = 13 then
 415: LD_VAR 0 3
 419: PUSH
 420: LD_INT 13
 422: EQUAL
 423: IFFALSE 433
// sDepot := true ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 1
 432: ST_TO_ADDR
// if p3 = 14 then
 433: LD_VAR 0 3
 437: PUSH
 438: LD_INT 14
 440: EQUAL
 441: IFFALSE 451
// sFlag := true ;
 443: LD_ADDR_EXP 33
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// if p3 = 15 then
 451: LD_VAR 0 3
 455: PUSH
 456: LD_INT 15
 458: EQUAL
 459: IFFALSE 469
// sKamikadze := true ;
 461: LD_ADDR_EXP 41
 465: PUSH
 466: LD_INT 1
 468: ST_TO_ADDR
// if p3 = 16 then
 469: LD_VAR 0 3
 473: PUSH
 474: LD_INT 16
 476: EQUAL
 477: IFFALSE 487
// sTroll := true ;
 479: LD_ADDR_EXP 42
 483: PUSH
 484: LD_INT 1
 486: ST_TO_ADDR
// if p3 = 17 then
 487: LD_VAR 0 3
 491: PUSH
 492: LD_INT 17
 494: EQUAL
 495: IFFALSE 505
// sSlow := true ;
 497: LD_ADDR_EXP 43
 501: PUSH
 502: LD_INT 1
 504: ST_TO_ADDR
// if p3 = 18 then
 505: LD_VAR 0 3
 509: PUSH
 510: LD_INT 18
 512: EQUAL
 513: IFFALSE 523
// sLack := true ;
 515: LD_ADDR_EXP 44
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// if p3 = 19 then
 523: LD_VAR 0 3
 527: PUSH
 528: LD_INT 19
 530: EQUAL
 531: IFFALSE 541
// sTank := true ;
 533: LD_ADDR_EXP 46
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// if p3 = 20 then
 541: LD_VAR 0 3
 545: PUSH
 546: LD_INT 20
 548: EQUAL
 549: IFFALSE 559
// sRemote := true ;
 551: LD_ADDR_EXP 47
 555: PUSH
 556: LD_INT 1
 558: ST_TO_ADDR
// if p3 = 21 then
 559: LD_VAR 0 3
 563: PUSH
 564: LD_INT 21
 566: EQUAL
 567: IFFALSE 577
// sPowell := true ;
 569: LD_ADDR_EXP 48
 573: PUSH
 574: LD_INT 1
 576: ST_TO_ADDR
// if p3 = 22 then
 577: LD_VAR 0 3
 581: PUSH
 582: LD_INT 22
 584: EQUAL
 585: IFFALSE 595
// sTeleport := true ;
 587: LD_ADDR_EXP 51
 591: PUSH
 592: LD_INT 1
 594: ST_TO_ADDR
// if p3 = 23 then
 595: LD_VAR 0 3
 599: PUSH
 600: LD_INT 23
 602: EQUAL
 603: IFFALSE 613
// sOilTower := true ;
 605: LD_ADDR_EXP 53
 609: PUSH
 610: LD_INT 1
 612: ST_TO_ADDR
// if p3 = 24 then
 613: LD_VAR 0 3
 617: PUSH
 618: LD_INT 24
 620: EQUAL
 621: IFFALSE 631
// sShovel := true ;
 623: LD_ADDR_EXP 54
 627: PUSH
 628: LD_INT 1
 630: ST_TO_ADDR
// if p3 = 25 then
 631: LD_VAR 0 3
 635: PUSH
 636: LD_INT 25
 638: EQUAL
 639: IFFALSE 649
// sSheik := true ;
 641: LD_ADDR_EXP 55
 645: PUSH
 646: LD_INT 1
 648: ST_TO_ADDR
// if p3 = 26 then
 649: LD_VAR 0 3
 653: PUSH
 654: LD_INT 26
 656: EQUAL
 657: IFFALSE 667
// sEarthquake := true ;
 659: LD_ADDR_EXP 57
 663: PUSH
 664: LD_INT 1
 666: ST_TO_ADDR
// if p3 = 27 then
 667: LD_VAR 0 3
 671: PUSH
 672: LD_INT 27
 674: EQUAL
 675: IFFALSE 685
// sAI := true ;
 677: LD_ADDR_EXP 58
 681: PUSH
 682: LD_INT 1
 684: ST_TO_ADDR
// if p3 = 28 then
 685: LD_VAR 0 3
 689: PUSH
 690: LD_INT 28
 692: EQUAL
 693: IFFALSE 703
// sCargo := true ;
 695: LD_ADDR_EXP 61
 699: PUSH
 700: LD_INT 1
 702: ST_TO_ADDR
// if p3 = 29 then
 703: LD_VAR 0 3
 707: PUSH
 708: LD_INT 29
 710: EQUAL
 711: IFFALSE 721
// sDLaser := true ;
 713: LD_ADDR_EXP 62
 717: PUSH
 718: LD_INT 1
 720: ST_TO_ADDR
// if p3 = 30 then
 721: LD_VAR 0 3
 725: PUSH
 726: LD_INT 30
 728: EQUAL
 729: IFFALSE 739
// sExchange := true ;
 731: LD_ADDR_EXP 63
 735: PUSH
 736: LD_INT 1
 738: ST_TO_ADDR
// if p3 = 31 then
 739: LD_VAR 0 3
 743: PUSH
 744: LD_INT 31
 746: EQUAL
 747: IFFALSE 757
// sFac := true ;
 749: LD_ADDR_EXP 64
 753: PUSH
 754: LD_INT 1
 756: ST_TO_ADDR
// if p3 = 32 then
 757: LD_VAR 0 3
 761: PUSH
 762: LD_INT 32
 764: EQUAL
 765: IFFALSE 775
// sPower := true ;
 767: LD_ADDR_EXP 65
 771: PUSH
 772: LD_INT 1
 774: ST_TO_ADDR
// if p3 = 33 then
 775: LD_VAR 0 3
 779: PUSH
 780: LD_INT 33
 782: EQUAL
 783: IFFALSE 793
// sRandom := true ;
 785: LD_ADDR_EXP 66
 789: PUSH
 790: LD_INT 1
 792: ST_TO_ADDR
// if p3 = 34 then
 793: LD_VAR 0 3
 797: PUSH
 798: LD_INT 34
 800: EQUAL
 801: IFFALSE 811
// sShield := true ;
 803: LD_ADDR_EXP 67
 807: PUSH
 808: LD_INT 1
 810: ST_TO_ADDR
// if p3 = 35 then
 811: LD_VAR 0 3
 815: PUSH
 816: LD_INT 35
 818: EQUAL
 819: IFFALSE 829
// sTime := true ;
 821: LD_ADDR_EXP 68
 825: PUSH
 826: LD_INT 1
 828: ST_TO_ADDR
// if p3 = 36 then
 829: LD_VAR 0 3
 833: PUSH
 834: LD_INT 36
 836: EQUAL
 837: IFFALSE 847
// sTools := true ;
 839: LD_ADDR_EXP 69
 843: PUSH
 844: LD_INT 1
 846: ST_TO_ADDR
// if p3 = 101 then
 847: LD_VAR 0 3
 851: PUSH
 852: LD_INT 101
 854: EQUAL
 855: IFFALSE 865
// sSold := true ;
 857: LD_ADDR_EXP 34
 861: PUSH
 862: LD_INT 1
 864: ST_TO_ADDR
// if p3 = 102 then
 865: LD_VAR 0 3
 869: PUSH
 870: LD_INT 102
 872: EQUAL
 873: IFFALSE 883
// sDiff := true ;
 875: LD_ADDR_EXP 35
 879: PUSH
 880: LD_INT 1
 882: ST_TO_ADDR
// if p3 = 103 then
 883: LD_VAR 0 3
 887: PUSH
 888: LD_INT 103
 890: EQUAL
 891: IFFALSE 901
// sFog := true ;
 893: LD_ADDR_EXP 38
 897: PUSH
 898: LD_INT 1
 900: ST_TO_ADDR
// if p3 = 104 then
 901: LD_VAR 0 3
 905: PUSH
 906: LD_INT 104
 908: EQUAL
 909: IFFALSE 919
// sReset := true ;
 911: LD_ADDR_EXP 39
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// if p3 = 105 then
 919: LD_VAR 0 3
 923: PUSH
 924: LD_INT 105
 926: EQUAL
 927: IFFALSE 937
// sSun := true ;
 929: LD_ADDR_EXP 40
 933: PUSH
 934: LD_INT 1
 936: ST_TO_ADDR
// if p3 = 106 then
 937: LD_VAR 0 3
 941: PUSH
 942: LD_INT 106
 944: EQUAL
 945: IFFALSE 955
// sTiger := true ;
 947: LD_ADDR_EXP 36
 951: PUSH
 952: LD_INT 1
 954: ST_TO_ADDR
// if p3 = 107 then
 955: LD_VAR 0 3
 959: PUSH
 960: LD_INT 107
 962: EQUAL
 963: IFFALSE 973
// sBomb := true ;
 965: LD_ADDR_EXP 37
 969: PUSH
 970: LD_INT 1
 972: ST_TO_ADDR
// if p3 = 108 then
 973: LD_VAR 0 3
 977: PUSH
 978: LD_INT 108
 980: EQUAL
 981: IFFALSE 991
// sWound := true ;
 983: LD_ADDR_EXP 45
 987: PUSH
 988: LD_INT 1
 990: ST_TO_ADDR
// if p3 = 109 then
 991: LD_VAR 0 3
 995: PUSH
 996: LD_INT 109
 998: EQUAL
 999: IFFALSE 1009
// sBetray := true ;
1001: LD_ADDR_EXP 49
1005: PUSH
1006: LD_INT 1
1008: ST_TO_ADDR
// if p3 = 110 then
1009: LD_VAR 0 3
1013: PUSH
1014: LD_INT 110
1016: EQUAL
1017: IFFALSE 1027
// sContamin := true ;
1019: LD_ADDR_EXP 50
1023: PUSH
1024: LD_INT 1
1026: ST_TO_ADDR
// if p3 = 111 then
1027: LD_VAR 0 3
1031: PUSH
1032: LD_INT 111
1034: EQUAL
1035: IFFALSE 1045
// sOil := true ;
1037: LD_ADDR_EXP 52
1041: PUSH
1042: LD_INT 1
1044: ST_TO_ADDR
// if p3 = 112 then
1045: LD_VAR 0 3
1049: PUSH
1050: LD_INT 112
1052: EQUAL
1053: IFFALSE 1063
// sStu := true ;
1055: LD_ADDR_EXP 56
1059: PUSH
1060: LD_INT 1
1062: ST_TO_ADDR
// if p3 = 113 then
1063: LD_VAR 0 3
1067: PUSH
1068: LD_INT 113
1070: EQUAL
1071: IFFALSE 1081
// sBazooka := true ;
1073: LD_ADDR_EXP 59
1077: PUSH
1078: LD_INT 1
1080: ST_TO_ADDR
// if p3 = 114 then
1081: LD_VAR 0 3
1085: PUSH
1086: LD_INT 114
1088: EQUAL
1089: IFFALSE 1099
// sMortar := true ;
1091: LD_ADDR_EXP 60
1095: PUSH
1096: LD_INT 1
1098: ST_TO_ADDR
// if p3 = 115 then
1099: LD_VAR 0 3
1103: PUSH
1104: LD_INT 115
1106: EQUAL
1107: IFFALSE 1117
// sRanger := true ;
1109: LD_ADDR_EXP 70
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// end ; if p2 = 101 then
1117: LD_VAR 0 2
1121: PUSH
1122: LD_INT 101
1124: EQUAL
1125: IFFALSE 1253
// begin case p3 of 1 :
1127: LD_VAR 0 3
1131: PUSH
1132: LD_INT 1
1134: DOUBLE
1135: EQUAL
1136: IFTRUE 1140
1138: GO 1147
1140: POP
// hHackUnlimitedResources ; 2 :
1141: CALL 12288 0 0
1145: GO 1253
1147: LD_INT 2
1149: DOUBLE
1150: EQUAL
1151: IFTRUE 1155
1153: GO 1162
1155: POP
// hHackSetLevel10 ; 3 :
1156: CALL 12421 0 0
1160: GO 1253
1162: LD_INT 3
1164: DOUBLE
1165: EQUAL
1166: IFTRUE 1170
1168: GO 1177
1170: POP
// hHackSetLevel10YourUnits ; 4 :
1171: CALL 12506 0 0
1175: GO 1253
1177: LD_INT 4
1179: DOUBLE
1180: EQUAL
1181: IFTRUE 1185
1183: GO 1192
1185: POP
// hHackInvincible ; 5 :
1186: CALL 12954 0 0
1190: GO 1253
1192: LD_INT 5
1194: DOUBLE
1195: EQUAL
1196: IFTRUE 1200
1198: GO 1207
1200: POP
// hHackInvisible ; 6 :
1201: CALL 13065 0 0
1205: GO 1253
1207: LD_INT 6
1209: DOUBLE
1210: EQUAL
1211: IFTRUE 1215
1213: GO 1222
1215: POP
// hHackChangeYourSide ; 7 :
1216: CALL 13122 0 0
1220: GO 1253
1222: LD_INT 7
1224: DOUBLE
1225: EQUAL
1226: IFTRUE 1230
1228: GO 1237
1230: POP
// hHackChangeUnitSide ; 8 :
1231: CALL 13164 0 0
1235: GO 1253
1237: LD_INT 8
1239: DOUBLE
1240: EQUAL
1241: IFTRUE 1245
1243: GO 1252
1245: POP
// hHackFog ; end ;
1246: CALL 13265 0 0
1250: GO 1253
1252: POP
// end ; end ;
1253: PPOPN 6
1255: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1256: GO 1258
1258: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1259: LD_STRING initStreamRollete();
1261: PPUSH
1262: CALL_OW 559
// InitStreamMode ;
1266: CALL 1275 0 0
// DefineStreamItems ( ) ;
1270: CALL 1715 0 0
// end ;
1274: END
// function InitStreamMode ; begin
1275: LD_INT 0
1277: PPUSH
// streamModeActive := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// normalCounter := 36 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 36
1293: ST_TO_ADDR
// hardcoreCounter := 16 ;
1294: LD_ADDR_EXP 19
1298: PUSH
1299: LD_INT 16
1301: ST_TO_ADDR
// sRocket := false ;
1302: LD_ADDR_EXP 22
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// sSpeed := false ;
1310: LD_ADDR_EXP 21
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// sEngine := false ;
1318: LD_ADDR_EXP 23
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// sSpec := false ;
1326: LD_ADDR_EXP 20
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// sLevel := false ;
1334: LD_ADDR_EXP 24
1338: PUSH
1339: LD_INT 0
1341: ST_TO_ADDR
// sArmoury := false ;
1342: LD_ADDR_EXP 25
1346: PUSH
1347: LD_INT 0
1349: ST_TO_ADDR
// sRadar := false ;
1350: LD_ADDR_EXP 26
1354: PUSH
1355: LD_INT 0
1357: ST_TO_ADDR
// sBunker := false ;
1358: LD_ADDR_EXP 27
1362: PUSH
1363: LD_INT 0
1365: ST_TO_ADDR
// sHack := false ;
1366: LD_ADDR_EXP 28
1370: PUSH
1371: LD_INT 0
1373: ST_TO_ADDR
// sFire := false ;
1374: LD_ADDR_EXP 29
1378: PUSH
1379: LD_INT 0
1381: ST_TO_ADDR
// sRefresh := false ;
1382: LD_ADDR_EXP 30
1386: PUSH
1387: LD_INT 0
1389: ST_TO_ADDR
// sExp := false ;
1390: LD_ADDR_EXP 31
1394: PUSH
1395: LD_INT 0
1397: ST_TO_ADDR
// sDepot := false ;
1398: LD_ADDR_EXP 32
1402: PUSH
1403: LD_INT 0
1405: ST_TO_ADDR
// sFlag := false ;
1406: LD_ADDR_EXP 33
1410: PUSH
1411: LD_INT 0
1413: ST_TO_ADDR
// sKamikadze := false ;
1414: LD_ADDR_EXP 41
1418: PUSH
1419: LD_INT 0
1421: ST_TO_ADDR
// sTroll := false ;
1422: LD_ADDR_EXP 42
1426: PUSH
1427: LD_INT 0
1429: ST_TO_ADDR
// sSlow := false ;
1430: LD_ADDR_EXP 43
1434: PUSH
1435: LD_INT 0
1437: ST_TO_ADDR
// sLack := false ;
1438: LD_ADDR_EXP 44
1442: PUSH
1443: LD_INT 0
1445: ST_TO_ADDR
// sTank := false ;
1446: LD_ADDR_EXP 46
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// sRemote := false ;
1454: LD_ADDR_EXP 47
1458: PUSH
1459: LD_INT 0
1461: ST_TO_ADDR
// sPowell := false ;
1462: LD_ADDR_EXP 48
1466: PUSH
1467: LD_INT 0
1469: ST_TO_ADDR
// sTeleport := false ;
1470: LD_ADDR_EXP 51
1474: PUSH
1475: LD_INT 0
1477: ST_TO_ADDR
// sOilTower := false ;
1478: LD_ADDR_EXP 53
1482: PUSH
1483: LD_INT 0
1485: ST_TO_ADDR
// sShovel := false ;
1486: LD_ADDR_EXP 54
1490: PUSH
1491: LD_INT 0
1493: ST_TO_ADDR
// sSheik := false ;
1494: LD_ADDR_EXP 55
1498: PUSH
1499: LD_INT 0
1501: ST_TO_ADDR
// sEarthquake := false ;
1502: LD_ADDR_EXP 57
1506: PUSH
1507: LD_INT 0
1509: ST_TO_ADDR
// sAI := false ;
1510: LD_ADDR_EXP 58
1514: PUSH
1515: LD_INT 0
1517: ST_TO_ADDR
// sCargo := false ;
1518: LD_ADDR_EXP 61
1522: PUSH
1523: LD_INT 0
1525: ST_TO_ADDR
// sDLaser := false ;
1526: LD_ADDR_EXP 62
1530: PUSH
1531: LD_INT 0
1533: ST_TO_ADDR
// sExchange := false ;
1534: LD_ADDR_EXP 63
1538: PUSH
1539: LD_INT 0
1541: ST_TO_ADDR
// sFac := false ;
1542: LD_ADDR_EXP 64
1546: PUSH
1547: LD_INT 0
1549: ST_TO_ADDR
// sPower := false ;
1550: LD_ADDR_EXP 65
1554: PUSH
1555: LD_INT 0
1557: ST_TO_ADDR
// sRandom := false ;
1558: LD_ADDR_EXP 66
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// sShield := false ;
1566: LD_ADDR_EXP 67
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// sTime := false ;
1574: LD_ADDR_EXP 68
1578: PUSH
1579: LD_INT 0
1581: ST_TO_ADDR
// sTools := false ;
1582: LD_ADDR_EXP 69
1586: PUSH
1587: LD_INT 0
1589: ST_TO_ADDR
// sSold := false ;
1590: LD_ADDR_EXP 34
1594: PUSH
1595: LD_INT 0
1597: ST_TO_ADDR
// sDiff := false ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_INT 0
1605: ST_TO_ADDR
// sFog := false ;
1606: LD_ADDR_EXP 38
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// sReset := false ;
1614: LD_ADDR_EXP 39
1618: PUSH
1619: LD_INT 0
1621: ST_TO_ADDR
// sSun := false ;
1622: LD_ADDR_EXP 40
1626: PUSH
1627: LD_INT 0
1629: ST_TO_ADDR
// sTiger := false ;
1630: LD_ADDR_EXP 36
1634: PUSH
1635: LD_INT 0
1637: ST_TO_ADDR
// sBomb := false ;
1638: LD_ADDR_EXP 37
1642: PUSH
1643: LD_INT 0
1645: ST_TO_ADDR
// sWound := false ;
1646: LD_ADDR_EXP 45
1650: PUSH
1651: LD_INT 0
1653: ST_TO_ADDR
// sBetray := false ;
1654: LD_ADDR_EXP 49
1658: PUSH
1659: LD_INT 0
1661: ST_TO_ADDR
// sContamin := false ;
1662: LD_ADDR_EXP 50
1666: PUSH
1667: LD_INT 0
1669: ST_TO_ADDR
// sOil := false ;
1670: LD_ADDR_EXP 52
1674: PUSH
1675: LD_INT 0
1677: ST_TO_ADDR
// sStu := false ;
1678: LD_ADDR_EXP 56
1682: PUSH
1683: LD_INT 0
1685: ST_TO_ADDR
// sBazooka := false ;
1686: LD_ADDR_EXP 59
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
// sMortar := false ;
1694: LD_ADDR_EXP 60
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// sRanger := false ;
1702: LD_ADDR_EXP 70
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// end ;
1710: LD_VAR 0 1
1714: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
1715: LD_INT 0
1717: PPUSH
1718: PPUSH
1719: PPUSH
1720: PPUSH
1721: PPUSH
// result := [ ] ;
1722: LD_ADDR_VAR 0 1
1726: PUSH
1727: EMPTY
1728: ST_TO_ADDR
// if campaign_id = 1 then
1729: LD_OWVAR 69
1733: PUSH
1734: LD_INT 1
1736: EQUAL
1737: IFFALSE 4675
// begin case mission_number of 1 :
1739: LD_OWVAR 70
1743: PUSH
1744: LD_INT 1
1746: DOUBLE
1747: EQUAL
1748: IFTRUE 1752
1750: GO 1816
1752: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
1753: LD_ADDR_VAR 0 1
1757: PUSH
1758: LD_INT 2
1760: PUSH
1761: LD_INT 4
1763: PUSH
1764: LD_INT 11
1766: PUSH
1767: LD_INT 12
1769: PUSH
1770: LD_INT 15
1772: PUSH
1773: LD_INT 16
1775: PUSH
1776: LD_INT 22
1778: PUSH
1779: LD_INT 23
1781: PUSH
1782: LD_INT 26
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 101
1798: PUSH
1799: LD_INT 102
1801: PUSH
1802: LD_INT 106
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: LIST
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: ST_TO_ADDR
1814: GO 4673
1816: LD_INT 2
1818: DOUBLE
1819: EQUAL
1820: IFTRUE 1824
1822: GO 1896
1824: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
1825: LD_ADDR_VAR 0 1
1829: PUSH
1830: LD_INT 2
1832: PUSH
1833: LD_INT 4
1835: PUSH
1836: LD_INT 11
1838: PUSH
1839: LD_INT 12
1841: PUSH
1842: LD_INT 15
1844: PUSH
1845: LD_INT 16
1847: PUSH
1848: LD_INT 22
1850: PUSH
1851: LD_INT 23
1853: PUSH
1854: LD_INT 26
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 101
1870: PUSH
1871: LD_INT 102
1873: PUSH
1874: LD_INT 105
1876: PUSH
1877: LD_INT 106
1879: PUSH
1880: LD_INT 108
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: PUSH
1890: EMPTY
1891: LIST
1892: LIST
1893: ST_TO_ADDR
1894: GO 4673
1896: LD_INT 3
1898: DOUBLE
1899: EQUAL
1900: IFTRUE 1904
1902: GO 1980
1904: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
1905: LD_ADDR_VAR 0 1
1909: PUSH
1910: LD_INT 2
1912: PUSH
1913: LD_INT 4
1915: PUSH
1916: LD_INT 5
1918: PUSH
1919: LD_INT 11
1921: PUSH
1922: LD_INT 12
1924: PUSH
1925: LD_INT 15
1927: PUSH
1928: LD_INT 16
1930: PUSH
1931: LD_INT 22
1933: PUSH
1934: LD_INT 26
1936: PUSH
1937: LD_INT 36
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: LIST
1950: LIST
1951: PUSH
1952: LD_INT 101
1954: PUSH
1955: LD_INT 102
1957: PUSH
1958: LD_INT 105
1960: PUSH
1961: LD_INT 106
1963: PUSH
1964: LD_INT 108
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: LIST
1973: PUSH
1974: EMPTY
1975: LIST
1976: LIST
1977: ST_TO_ADDR
1978: GO 4673
1980: LD_INT 4
1982: DOUBLE
1983: EQUAL
1984: IFTRUE 1988
1986: GO 2072
1988: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
1989: LD_ADDR_VAR 0 1
1993: PUSH
1994: LD_INT 2
1996: PUSH
1997: LD_INT 4
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: LD_INT 8
2005: PUSH
2006: LD_INT 11
2008: PUSH
2009: LD_INT 12
2011: PUSH
2012: LD_INT 15
2014: PUSH
2015: LD_INT 16
2017: PUSH
2018: LD_INT 22
2020: PUSH
2021: LD_INT 23
2023: PUSH
2024: LD_INT 26
2026: PUSH
2027: LD_INT 36
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 101
2046: PUSH
2047: LD_INT 102
2049: PUSH
2050: LD_INT 105
2052: PUSH
2053: LD_INT 106
2055: PUSH
2056: LD_INT 108
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: PUSH
2066: EMPTY
2067: LIST
2068: LIST
2069: ST_TO_ADDR
2070: GO 4673
2072: LD_INT 5
2074: DOUBLE
2075: EQUAL
2076: IFTRUE 2080
2078: GO 2180
2080: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2081: LD_ADDR_VAR 0 1
2085: PUSH
2086: LD_INT 2
2088: PUSH
2089: LD_INT 4
2091: PUSH
2092: LD_INT 5
2094: PUSH
2095: LD_INT 6
2097: PUSH
2098: LD_INT 8
2100: PUSH
2101: LD_INT 11
2103: PUSH
2104: LD_INT 12
2106: PUSH
2107: LD_INT 15
2109: PUSH
2110: LD_INT 16
2112: PUSH
2113: LD_INT 22
2115: PUSH
2116: LD_INT 23
2118: PUSH
2119: LD_INT 25
2121: PUSH
2122: LD_INT 26
2124: PUSH
2125: LD_INT 36
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: LIST
2143: PUSH
2144: LD_INT 101
2146: PUSH
2147: LD_INT 102
2149: PUSH
2150: LD_INT 105
2152: PUSH
2153: LD_INT 106
2155: PUSH
2156: LD_INT 108
2158: PUSH
2159: LD_INT 109
2161: PUSH
2162: LD_INT 112
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: PUSH
2174: EMPTY
2175: LIST
2176: LIST
2177: ST_TO_ADDR
2178: GO 4673
2180: LD_INT 6
2182: DOUBLE
2183: EQUAL
2184: IFTRUE 2188
2186: GO 2308
2188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2189: LD_ADDR_VAR 0 1
2193: PUSH
2194: LD_INT 2
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: LD_INT 5
2202: PUSH
2203: LD_INT 6
2205: PUSH
2206: LD_INT 8
2208: PUSH
2209: LD_INT 11
2211: PUSH
2212: LD_INT 12
2214: PUSH
2215: LD_INT 15
2217: PUSH
2218: LD_INT 16
2220: PUSH
2221: LD_INT 20
2223: PUSH
2224: LD_INT 21
2226: PUSH
2227: LD_INT 22
2229: PUSH
2230: LD_INT 23
2232: PUSH
2233: LD_INT 25
2235: PUSH
2236: LD_INT 26
2238: PUSH
2239: LD_INT 30
2241: PUSH
2242: LD_INT 31
2244: PUSH
2245: LD_INT 32
2247: PUSH
2248: LD_INT 36
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: LIST
2268: LIST
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 101
2274: PUSH
2275: LD_INT 102
2277: PUSH
2278: LD_INT 105
2280: PUSH
2281: LD_INT 106
2283: PUSH
2284: LD_INT 108
2286: PUSH
2287: LD_INT 109
2289: PUSH
2290: LD_INT 112
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: LIST
2297: LIST
2298: LIST
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: ST_TO_ADDR
2306: GO 4673
2308: LD_INT 7
2310: DOUBLE
2311: EQUAL
2312: IFTRUE 2316
2314: GO 2416
2316: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2317: LD_ADDR_VAR 0 1
2321: PUSH
2322: LD_INT 2
2324: PUSH
2325: LD_INT 4
2327: PUSH
2328: LD_INT 5
2330: PUSH
2331: LD_INT 7
2333: PUSH
2334: LD_INT 11
2336: PUSH
2337: LD_INT 12
2339: PUSH
2340: LD_INT 15
2342: PUSH
2343: LD_INT 16
2345: PUSH
2346: LD_INT 20
2348: PUSH
2349: LD_INT 21
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: LD_INT 23
2357: PUSH
2358: LD_INT 25
2360: PUSH
2361: LD_INT 26
2363: PUSH
2364: EMPTY
2365: LIST
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: LIST
2372: LIST
2373: LIST
2374: LIST
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 101
2382: PUSH
2383: LD_INT 102
2385: PUSH
2386: LD_INT 103
2388: PUSH
2389: LD_INT 105
2391: PUSH
2392: LD_INT 106
2394: PUSH
2395: LD_INT 108
2397: PUSH
2398: LD_INT 112
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: LIST
2408: LIST
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: ST_TO_ADDR
2414: GO 4673
2416: LD_INT 8
2418: DOUBLE
2419: EQUAL
2420: IFTRUE 2424
2422: GO 2552
2424: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
2425: LD_ADDR_VAR 0 1
2429: PUSH
2430: LD_INT 2
2432: PUSH
2433: LD_INT 4
2435: PUSH
2436: LD_INT 5
2438: PUSH
2439: LD_INT 6
2441: PUSH
2442: LD_INT 7
2444: PUSH
2445: LD_INT 8
2447: PUSH
2448: LD_INT 11
2450: PUSH
2451: LD_INT 12
2453: PUSH
2454: LD_INT 15
2456: PUSH
2457: LD_INT 16
2459: PUSH
2460: LD_INT 20
2462: PUSH
2463: LD_INT 21
2465: PUSH
2466: LD_INT 22
2468: PUSH
2469: LD_INT 23
2471: PUSH
2472: LD_INT 25
2474: PUSH
2475: LD_INT 26
2477: PUSH
2478: LD_INT 30
2480: PUSH
2481: LD_INT 31
2483: PUSH
2484: LD_INT 32
2486: PUSH
2487: LD_INT 36
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: LIST
2501: LIST
2502: LIST
2503: LIST
2504: LIST
2505: LIST
2506: LIST
2507: LIST
2508: LIST
2509: LIST
2510: LIST
2511: PUSH
2512: LD_INT 101
2514: PUSH
2515: LD_INT 102
2517: PUSH
2518: LD_INT 103
2520: PUSH
2521: LD_INT 105
2523: PUSH
2524: LD_INT 106
2526: PUSH
2527: LD_INT 108
2529: PUSH
2530: LD_INT 109
2532: PUSH
2533: LD_INT 112
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: LIST
2542: LIST
2543: LIST
2544: LIST
2545: PUSH
2546: EMPTY
2547: LIST
2548: LIST
2549: ST_TO_ADDR
2550: GO 4673
2552: LD_INT 9
2554: DOUBLE
2555: EQUAL
2556: IFTRUE 2560
2558: GO 2696
2560: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
2561: LD_ADDR_VAR 0 1
2565: PUSH
2566: LD_INT 2
2568: PUSH
2569: LD_INT 4
2571: PUSH
2572: LD_INT 5
2574: PUSH
2575: LD_INT 6
2577: PUSH
2578: LD_INT 7
2580: PUSH
2581: LD_INT 8
2583: PUSH
2584: LD_INT 11
2586: PUSH
2587: LD_INT 12
2589: PUSH
2590: LD_INT 15
2592: PUSH
2593: LD_INT 16
2595: PUSH
2596: LD_INT 20
2598: PUSH
2599: LD_INT 21
2601: PUSH
2602: LD_INT 22
2604: PUSH
2605: LD_INT 23
2607: PUSH
2608: LD_INT 25
2610: PUSH
2611: LD_INT 26
2613: PUSH
2614: LD_INT 28
2616: PUSH
2617: LD_INT 30
2619: PUSH
2620: LD_INT 31
2622: PUSH
2623: LD_INT 32
2625: PUSH
2626: LD_INT 36
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: LIST
2633: LIST
2634: LIST
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 101
2654: PUSH
2655: LD_INT 102
2657: PUSH
2658: LD_INT 103
2660: PUSH
2661: LD_INT 105
2663: PUSH
2664: LD_INT 106
2666: PUSH
2667: LD_INT 108
2669: PUSH
2670: LD_INT 109
2672: PUSH
2673: LD_INT 112
2675: PUSH
2676: LD_INT 114
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: LIST
2683: LIST
2684: LIST
2685: LIST
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: ST_TO_ADDR
2694: GO 4673
2696: LD_INT 10
2698: DOUBLE
2699: EQUAL
2700: IFTRUE 2704
2702: GO 2888
2704: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
2705: LD_ADDR_VAR 0 1
2709: PUSH
2710: LD_INT 2
2712: PUSH
2713: LD_INT 4
2715: PUSH
2716: LD_INT 5
2718: PUSH
2719: LD_INT 6
2721: PUSH
2722: LD_INT 7
2724: PUSH
2725: LD_INT 8
2727: PUSH
2728: LD_INT 9
2730: PUSH
2731: LD_INT 10
2733: PUSH
2734: LD_INT 11
2736: PUSH
2737: LD_INT 12
2739: PUSH
2740: LD_INT 13
2742: PUSH
2743: LD_INT 14
2745: PUSH
2746: LD_INT 15
2748: PUSH
2749: LD_INT 16
2751: PUSH
2752: LD_INT 17
2754: PUSH
2755: LD_INT 18
2757: PUSH
2758: LD_INT 19
2760: PUSH
2761: LD_INT 20
2763: PUSH
2764: LD_INT 21
2766: PUSH
2767: LD_INT 22
2769: PUSH
2770: LD_INT 23
2772: PUSH
2773: LD_INT 24
2775: PUSH
2776: LD_INT 25
2778: PUSH
2779: LD_INT 26
2781: PUSH
2782: LD_INT 28
2784: PUSH
2785: LD_INT 30
2787: PUSH
2788: LD_INT 31
2790: PUSH
2791: LD_INT 32
2793: PUSH
2794: LD_INT 36
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: LIST
2827: PUSH
2828: LD_INT 101
2830: PUSH
2831: LD_INT 102
2833: PUSH
2834: LD_INT 103
2836: PUSH
2837: LD_INT 104
2839: PUSH
2840: LD_INT 105
2842: PUSH
2843: LD_INT 106
2845: PUSH
2846: LD_INT 107
2848: PUSH
2849: LD_INT 108
2851: PUSH
2852: LD_INT 109
2854: PUSH
2855: LD_INT 110
2857: PUSH
2858: LD_INT 111
2860: PUSH
2861: LD_INT 112
2863: PUSH
2864: LD_INT 114
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: ST_TO_ADDR
2886: GO 4673
2888: LD_INT 11
2890: DOUBLE
2891: EQUAL
2892: IFTRUE 2896
2894: GO 3088
2896: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
2897: LD_ADDR_VAR 0 1
2901: PUSH
2902: LD_INT 2
2904: PUSH
2905: LD_INT 3
2907: PUSH
2908: LD_INT 4
2910: PUSH
2911: LD_INT 5
2913: PUSH
2914: LD_INT 6
2916: PUSH
2917: LD_INT 7
2919: PUSH
2920: LD_INT 8
2922: PUSH
2923: LD_INT 9
2925: PUSH
2926: LD_INT 10
2928: PUSH
2929: LD_INT 11
2931: PUSH
2932: LD_INT 12
2934: PUSH
2935: LD_INT 13
2937: PUSH
2938: LD_INT 14
2940: PUSH
2941: LD_INT 15
2943: PUSH
2944: LD_INT 16
2946: PUSH
2947: LD_INT 17
2949: PUSH
2950: LD_INT 18
2952: PUSH
2953: LD_INT 19
2955: PUSH
2956: LD_INT 20
2958: PUSH
2959: LD_INT 21
2961: PUSH
2962: LD_INT 22
2964: PUSH
2965: LD_INT 23
2967: PUSH
2968: LD_INT 24
2970: PUSH
2971: LD_INT 25
2973: PUSH
2974: LD_INT 26
2976: PUSH
2977: LD_INT 28
2979: PUSH
2980: LD_INT 30
2982: PUSH
2983: LD_INT 31
2985: PUSH
2986: LD_INT 32
2988: PUSH
2989: LD_INT 34
2991: PUSH
2992: LD_INT 36
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: LIST
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: LIST
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_INT 101
3030: PUSH
3031: LD_INT 102
3033: PUSH
3034: LD_INT 103
3036: PUSH
3037: LD_INT 104
3039: PUSH
3040: LD_INT 105
3042: PUSH
3043: LD_INT 106
3045: PUSH
3046: LD_INT 107
3048: PUSH
3049: LD_INT 108
3051: PUSH
3052: LD_INT 109
3054: PUSH
3055: LD_INT 110
3057: PUSH
3058: LD_INT 111
3060: PUSH
3061: LD_INT 112
3063: PUSH
3064: LD_INT 114
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: ST_TO_ADDR
3086: GO 4673
3088: LD_INT 12
3090: DOUBLE
3091: EQUAL
3092: IFTRUE 3096
3094: GO 3304
3096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3097: LD_ADDR_VAR 0 1
3101: PUSH
3102: LD_INT 1
3104: PUSH
3105: LD_INT 2
3107: PUSH
3108: LD_INT 3
3110: PUSH
3111: LD_INT 4
3113: PUSH
3114: LD_INT 5
3116: PUSH
3117: LD_INT 6
3119: PUSH
3120: LD_INT 7
3122: PUSH
3123: LD_INT 8
3125: PUSH
3126: LD_INT 9
3128: PUSH
3129: LD_INT 10
3131: PUSH
3132: LD_INT 11
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 13
3140: PUSH
3141: LD_INT 14
3143: PUSH
3144: LD_INT 15
3146: PUSH
3147: LD_INT 16
3149: PUSH
3150: LD_INT 17
3152: PUSH
3153: LD_INT 18
3155: PUSH
3156: LD_INT 19
3158: PUSH
3159: LD_INT 20
3161: PUSH
3162: LD_INT 21
3164: PUSH
3165: LD_INT 22
3167: PUSH
3168: LD_INT 23
3170: PUSH
3171: LD_INT 24
3173: PUSH
3174: LD_INT 25
3176: PUSH
3177: LD_INT 26
3179: PUSH
3180: LD_INT 27
3182: PUSH
3183: LD_INT 28
3185: PUSH
3186: LD_INT 30
3188: PUSH
3189: LD_INT 31
3191: PUSH
3192: LD_INT 32
3194: PUSH
3195: LD_INT 33
3197: PUSH
3198: LD_INT 34
3200: PUSH
3201: LD_INT 36
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: LIST
3239: PUSH
3240: LD_INT 101
3242: PUSH
3243: LD_INT 102
3245: PUSH
3246: LD_INT 103
3248: PUSH
3249: LD_INT 104
3251: PUSH
3252: LD_INT 105
3254: PUSH
3255: LD_INT 106
3257: PUSH
3258: LD_INT 107
3260: PUSH
3261: LD_INT 108
3263: PUSH
3264: LD_INT 109
3266: PUSH
3267: LD_INT 110
3269: PUSH
3270: LD_INT 111
3272: PUSH
3273: LD_INT 112
3275: PUSH
3276: LD_INT 113
3278: PUSH
3279: LD_INT 114
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: ST_TO_ADDR
3302: GO 4673
3304: LD_INT 13
3306: DOUBLE
3307: EQUAL
3308: IFTRUE 3312
3310: GO 3508
3312: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3313: LD_ADDR_VAR 0 1
3317: PUSH
3318: LD_INT 1
3320: PUSH
3321: LD_INT 2
3323: PUSH
3324: LD_INT 3
3326: PUSH
3327: LD_INT 4
3329: PUSH
3330: LD_INT 5
3332: PUSH
3333: LD_INT 8
3335: PUSH
3336: LD_INT 9
3338: PUSH
3339: LD_INT 10
3341: PUSH
3342: LD_INT 11
3344: PUSH
3345: LD_INT 12
3347: PUSH
3348: LD_INT 14
3350: PUSH
3351: LD_INT 15
3353: PUSH
3354: LD_INT 16
3356: PUSH
3357: LD_INT 17
3359: PUSH
3360: LD_INT 18
3362: PUSH
3363: LD_INT 19
3365: PUSH
3366: LD_INT 20
3368: PUSH
3369: LD_INT 21
3371: PUSH
3372: LD_INT 22
3374: PUSH
3375: LD_INT 23
3377: PUSH
3378: LD_INT 24
3380: PUSH
3381: LD_INT 25
3383: PUSH
3384: LD_INT 26
3386: PUSH
3387: LD_INT 27
3389: PUSH
3390: LD_INT 28
3392: PUSH
3393: LD_INT 30
3395: PUSH
3396: LD_INT 31
3398: PUSH
3399: LD_INT 32
3401: PUSH
3402: LD_INT 33
3404: PUSH
3405: LD_INT 34
3407: PUSH
3408: LD_INT 36
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: PUSH
3444: LD_INT 101
3446: PUSH
3447: LD_INT 102
3449: PUSH
3450: LD_INT 103
3452: PUSH
3453: LD_INT 104
3455: PUSH
3456: LD_INT 105
3458: PUSH
3459: LD_INT 106
3461: PUSH
3462: LD_INT 107
3464: PUSH
3465: LD_INT 108
3467: PUSH
3468: LD_INT 109
3470: PUSH
3471: LD_INT 110
3473: PUSH
3474: LD_INT 111
3476: PUSH
3477: LD_INT 112
3479: PUSH
3480: LD_INT 113
3482: PUSH
3483: LD_INT 114
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: ST_TO_ADDR
3506: GO 4673
3508: LD_INT 14
3510: DOUBLE
3511: EQUAL
3512: IFTRUE 3516
3514: GO 3728
3516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
3517: LD_ADDR_VAR 0 1
3521: PUSH
3522: LD_INT 1
3524: PUSH
3525: LD_INT 2
3527: PUSH
3528: LD_INT 3
3530: PUSH
3531: LD_INT 4
3533: PUSH
3534: LD_INT 5
3536: PUSH
3537: LD_INT 6
3539: PUSH
3540: LD_INT 7
3542: PUSH
3543: LD_INT 8
3545: PUSH
3546: LD_INT 9
3548: PUSH
3549: LD_INT 10
3551: PUSH
3552: LD_INT 11
3554: PUSH
3555: LD_INT 12
3557: PUSH
3558: LD_INT 13
3560: PUSH
3561: LD_INT 14
3563: PUSH
3564: LD_INT 15
3566: PUSH
3567: LD_INT 16
3569: PUSH
3570: LD_INT 17
3572: PUSH
3573: LD_INT 18
3575: PUSH
3576: LD_INT 19
3578: PUSH
3579: LD_INT 20
3581: PUSH
3582: LD_INT 21
3584: PUSH
3585: LD_INT 22
3587: PUSH
3588: LD_INT 23
3590: PUSH
3591: LD_INT 24
3593: PUSH
3594: LD_INT 25
3596: PUSH
3597: LD_INT 26
3599: PUSH
3600: LD_INT 27
3602: PUSH
3603: LD_INT 28
3605: PUSH
3606: LD_INT 29
3608: PUSH
3609: LD_INT 30
3611: PUSH
3612: LD_INT 31
3614: PUSH
3615: LD_INT 32
3617: PUSH
3618: LD_INT 33
3620: PUSH
3621: LD_INT 34
3623: PUSH
3624: LD_INT 36
3626: PUSH
3627: EMPTY
3628: LIST
3629: LIST
3630: LIST
3631: LIST
3632: LIST
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: LIST
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: PUSH
3664: LD_INT 101
3666: PUSH
3667: LD_INT 102
3669: PUSH
3670: LD_INT 103
3672: PUSH
3673: LD_INT 104
3675: PUSH
3676: LD_INT 105
3678: PUSH
3679: LD_INT 106
3681: PUSH
3682: LD_INT 107
3684: PUSH
3685: LD_INT 108
3687: PUSH
3688: LD_INT 109
3690: PUSH
3691: LD_INT 110
3693: PUSH
3694: LD_INT 111
3696: PUSH
3697: LD_INT 112
3699: PUSH
3700: LD_INT 113
3702: PUSH
3703: LD_INT 114
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: LIST
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: PUSH
3722: EMPTY
3723: LIST
3724: LIST
3725: ST_TO_ADDR
3726: GO 4673
3728: LD_INT 15
3730: DOUBLE
3731: EQUAL
3732: IFTRUE 3736
3734: GO 3948
3736: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: LD_INT 3
3750: PUSH
3751: LD_INT 4
3753: PUSH
3754: LD_INT 5
3756: PUSH
3757: LD_INT 6
3759: PUSH
3760: LD_INT 7
3762: PUSH
3763: LD_INT 8
3765: PUSH
3766: LD_INT 9
3768: PUSH
3769: LD_INT 10
3771: PUSH
3772: LD_INT 11
3774: PUSH
3775: LD_INT 12
3777: PUSH
3778: LD_INT 13
3780: PUSH
3781: LD_INT 14
3783: PUSH
3784: LD_INT 15
3786: PUSH
3787: LD_INT 16
3789: PUSH
3790: LD_INT 17
3792: PUSH
3793: LD_INT 18
3795: PUSH
3796: LD_INT 19
3798: PUSH
3799: LD_INT 20
3801: PUSH
3802: LD_INT 21
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 23
3810: PUSH
3811: LD_INT 24
3813: PUSH
3814: LD_INT 25
3816: PUSH
3817: LD_INT 26
3819: PUSH
3820: LD_INT 27
3822: PUSH
3823: LD_INT 28
3825: PUSH
3826: LD_INT 29
3828: PUSH
3829: LD_INT 30
3831: PUSH
3832: LD_INT 31
3834: PUSH
3835: LD_INT 32
3837: PUSH
3838: LD_INT 33
3840: PUSH
3841: LD_INT 34
3843: PUSH
3844: LD_INT 36
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: LIST
3856: LIST
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: PUSH
3884: LD_INT 101
3886: PUSH
3887: LD_INT 102
3889: PUSH
3890: LD_INT 103
3892: PUSH
3893: LD_INT 104
3895: PUSH
3896: LD_INT 105
3898: PUSH
3899: LD_INT 106
3901: PUSH
3902: LD_INT 107
3904: PUSH
3905: LD_INT 108
3907: PUSH
3908: LD_INT 109
3910: PUSH
3911: LD_INT 110
3913: PUSH
3914: LD_INT 111
3916: PUSH
3917: LD_INT 112
3919: PUSH
3920: LD_INT 113
3922: PUSH
3923: LD_INT 114
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: ST_TO_ADDR
3946: GO 4673
3948: LD_INT 16
3950: DOUBLE
3951: EQUAL
3952: IFTRUE 3956
3954: GO 4080
3956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
3957: LD_ADDR_VAR 0 1
3961: PUSH
3962: LD_INT 2
3964: PUSH
3965: LD_INT 4
3967: PUSH
3968: LD_INT 5
3970: PUSH
3971: LD_INT 7
3973: PUSH
3974: LD_INT 11
3976: PUSH
3977: LD_INT 12
3979: PUSH
3980: LD_INT 15
3982: PUSH
3983: LD_INT 16
3985: PUSH
3986: LD_INT 20
3988: PUSH
3989: LD_INT 21
3991: PUSH
3992: LD_INT 22
3994: PUSH
3995: LD_INT 23
3997: PUSH
3998: LD_INT 25
4000: PUSH
4001: LD_INT 26
4003: PUSH
4004: LD_INT 30
4006: PUSH
4007: LD_INT 31
4009: PUSH
4010: LD_INT 32
4012: PUSH
4013: LD_INT 33
4015: PUSH
4016: LD_INT 34
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 101
4042: PUSH
4043: LD_INT 102
4045: PUSH
4046: LD_INT 103
4048: PUSH
4049: LD_INT 106
4051: PUSH
4052: LD_INT 108
4054: PUSH
4055: LD_INT 112
4057: PUSH
4058: LD_INT 113
4060: PUSH
4061: LD_INT 114
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: LIST
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: ST_TO_ADDR
4078: GO 4673
4080: LD_INT 17
4082: DOUBLE
4083: EQUAL
4084: IFTRUE 4088
4086: GO 4300
4088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4089: LD_ADDR_VAR 0 1
4093: PUSH
4094: LD_INT 1
4096: PUSH
4097: LD_INT 2
4099: PUSH
4100: LD_INT 3
4102: PUSH
4103: LD_INT 4
4105: PUSH
4106: LD_INT 5
4108: PUSH
4109: LD_INT 6
4111: PUSH
4112: LD_INT 7
4114: PUSH
4115: LD_INT 8
4117: PUSH
4118: LD_INT 9
4120: PUSH
4121: LD_INT 10
4123: PUSH
4124: LD_INT 11
4126: PUSH
4127: LD_INT 12
4129: PUSH
4130: LD_INT 13
4132: PUSH
4133: LD_INT 14
4135: PUSH
4136: LD_INT 15
4138: PUSH
4139: LD_INT 16
4141: PUSH
4142: LD_INT 17
4144: PUSH
4145: LD_INT 18
4147: PUSH
4148: LD_INT 19
4150: PUSH
4151: LD_INT 20
4153: PUSH
4154: LD_INT 21
4156: PUSH
4157: LD_INT 22
4159: PUSH
4160: LD_INT 23
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: LD_INT 25
4168: PUSH
4169: LD_INT 26
4171: PUSH
4172: LD_INT 27
4174: PUSH
4175: LD_INT 28
4177: PUSH
4178: LD_INT 29
4180: PUSH
4181: LD_INT 30
4183: PUSH
4184: LD_INT 31
4186: PUSH
4187: LD_INT 32
4189: PUSH
4190: LD_INT 33
4192: PUSH
4193: LD_INT 34
4195: PUSH
4196: LD_INT 36
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: LIST
4204: LIST
4205: LIST
4206: LIST
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: LIST
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 101
4238: PUSH
4239: LD_INT 102
4241: PUSH
4242: LD_INT 103
4244: PUSH
4245: LD_INT 104
4247: PUSH
4248: LD_INT 105
4250: PUSH
4251: LD_INT 106
4253: PUSH
4254: LD_INT 107
4256: PUSH
4257: LD_INT 108
4259: PUSH
4260: LD_INT 109
4262: PUSH
4263: LD_INT 110
4265: PUSH
4266: LD_INT 111
4268: PUSH
4269: LD_INT 112
4271: PUSH
4272: LD_INT 113
4274: PUSH
4275: LD_INT 114
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: ST_TO_ADDR
4298: GO 4673
4300: LD_INT 18
4302: DOUBLE
4303: EQUAL
4304: IFTRUE 4308
4306: GO 4444
4308: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4309: LD_ADDR_VAR 0 1
4313: PUSH
4314: LD_INT 2
4316: PUSH
4317: LD_INT 4
4319: PUSH
4320: LD_INT 5
4322: PUSH
4323: LD_INT 7
4325: PUSH
4326: LD_INT 11
4328: PUSH
4329: LD_INT 12
4331: PUSH
4332: LD_INT 15
4334: PUSH
4335: LD_INT 16
4337: PUSH
4338: LD_INT 20
4340: PUSH
4341: LD_INT 21
4343: PUSH
4344: LD_INT 22
4346: PUSH
4347: LD_INT 23
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 26
4355: PUSH
4356: LD_INT 30
4358: PUSH
4359: LD_INT 31
4361: PUSH
4362: LD_INT 32
4364: PUSH
4365: LD_INT 33
4367: PUSH
4368: LD_INT 34
4370: PUSH
4371: LD_INT 35
4373: PUSH
4374: LD_INT 36
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 101
4402: PUSH
4403: LD_INT 102
4405: PUSH
4406: LD_INT 103
4408: PUSH
4409: LD_INT 106
4411: PUSH
4412: LD_INT 108
4414: PUSH
4415: LD_INT 112
4417: PUSH
4418: LD_INT 113
4420: PUSH
4421: LD_INT 114
4423: PUSH
4424: LD_INT 115
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: ST_TO_ADDR
4442: GO 4673
4444: LD_INT 19
4446: DOUBLE
4447: EQUAL
4448: IFTRUE 4452
4450: GO 4672
4452: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
4453: LD_ADDR_VAR 0 1
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: LD_INT 2
4463: PUSH
4464: LD_INT 3
4466: PUSH
4467: LD_INT 4
4469: PUSH
4470: LD_INT 5
4472: PUSH
4473: LD_INT 6
4475: PUSH
4476: LD_INT 7
4478: PUSH
4479: LD_INT 8
4481: PUSH
4482: LD_INT 9
4484: PUSH
4485: LD_INT 10
4487: PUSH
4488: LD_INT 11
4490: PUSH
4491: LD_INT 12
4493: PUSH
4494: LD_INT 13
4496: PUSH
4497: LD_INT 14
4499: PUSH
4500: LD_INT 15
4502: PUSH
4503: LD_INT 16
4505: PUSH
4506: LD_INT 17
4508: PUSH
4509: LD_INT 18
4511: PUSH
4512: LD_INT 19
4514: PUSH
4515: LD_INT 20
4517: PUSH
4518: LD_INT 21
4520: PUSH
4521: LD_INT 22
4523: PUSH
4524: LD_INT 23
4526: PUSH
4527: LD_INT 24
4529: PUSH
4530: LD_INT 25
4532: PUSH
4533: LD_INT 26
4535: PUSH
4536: LD_INT 27
4538: PUSH
4539: LD_INT 28
4541: PUSH
4542: LD_INT 29
4544: PUSH
4545: LD_INT 30
4547: PUSH
4548: LD_INT 31
4550: PUSH
4551: LD_INT 32
4553: PUSH
4554: LD_INT 33
4556: PUSH
4557: LD_INT 34
4559: PUSH
4560: LD_INT 35
4562: PUSH
4563: LD_INT 36
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: LIST
4586: LIST
4587: LIST
4588: LIST
4589: LIST
4590: LIST
4591: LIST
4592: LIST
4593: LIST
4594: LIST
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: LD_INT 101
4606: PUSH
4607: LD_INT 102
4609: PUSH
4610: LD_INT 103
4612: PUSH
4613: LD_INT 104
4615: PUSH
4616: LD_INT 105
4618: PUSH
4619: LD_INT 106
4621: PUSH
4622: LD_INT 107
4624: PUSH
4625: LD_INT 108
4627: PUSH
4628: LD_INT 109
4630: PUSH
4631: LD_INT 110
4633: PUSH
4634: LD_INT 111
4636: PUSH
4637: LD_INT 112
4639: PUSH
4640: LD_INT 113
4642: PUSH
4643: LD_INT 114
4645: PUSH
4646: LD_INT 115
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: ST_TO_ADDR
4670: GO 4673
4672: POP
// end else
4673: GO 4892
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
4675: LD_ADDR_VAR 0 1
4679: PUSH
4680: LD_INT 1
4682: PUSH
4683: LD_INT 2
4685: PUSH
4686: LD_INT 3
4688: PUSH
4689: LD_INT 4
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 6
4697: PUSH
4698: LD_INT 7
4700: PUSH
4701: LD_INT 8
4703: PUSH
4704: LD_INT 9
4706: PUSH
4707: LD_INT 10
4709: PUSH
4710: LD_INT 11
4712: PUSH
4713: LD_INT 12
4715: PUSH
4716: LD_INT 13
4718: PUSH
4719: LD_INT 14
4721: PUSH
4722: LD_INT 15
4724: PUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 17
4730: PUSH
4731: LD_INT 18
4733: PUSH
4734: LD_INT 19
4736: PUSH
4737: LD_INT 20
4739: PUSH
4740: LD_INT 21
4742: PUSH
4743: LD_INT 22
4745: PUSH
4746: LD_INT 23
4748: PUSH
4749: LD_INT 24
4751: PUSH
4752: LD_INT 25
4754: PUSH
4755: LD_INT 26
4757: PUSH
4758: LD_INT 27
4760: PUSH
4761: LD_INT 28
4763: PUSH
4764: LD_INT 29
4766: PUSH
4767: LD_INT 30
4769: PUSH
4770: LD_INT 31
4772: PUSH
4773: LD_INT 32
4775: PUSH
4776: LD_INT 33
4778: PUSH
4779: LD_INT 34
4781: PUSH
4782: LD_INT 35
4784: PUSH
4785: LD_INT 36
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: PUSH
4826: LD_INT 101
4828: PUSH
4829: LD_INT 102
4831: PUSH
4832: LD_INT 103
4834: PUSH
4835: LD_INT 104
4837: PUSH
4838: LD_INT 105
4840: PUSH
4841: LD_INT 106
4843: PUSH
4844: LD_INT 107
4846: PUSH
4847: LD_INT 108
4849: PUSH
4850: LD_INT 109
4852: PUSH
4853: LD_INT 110
4855: PUSH
4856: LD_INT 111
4858: PUSH
4859: LD_INT 112
4861: PUSH
4862: LD_INT 113
4864: PUSH
4865: LD_INT 114
4867: PUSH
4868: LD_INT 115
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: ST_TO_ADDR
// if result then
4892: LD_VAR 0 1
4896: IFFALSE 5185
// begin normal :=  ;
4898: LD_ADDR_VAR 0 3
4902: PUSH
4903: LD_STRING 
4905: ST_TO_ADDR
// hardcore :=  ;
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: LD_STRING 
4913: ST_TO_ADDR
// for i = 1 to normalCounter do
4914: LD_ADDR_VAR 0 5
4918: PUSH
4919: DOUBLE
4920: LD_INT 1
4922: DEC
4923: ST_TO_ADDR
4924: LD_EXP 18
4928: PUSH
4929: FOR_TO
4930: IFFALSE 5031
// begin tmp := 0 ;
4932: LD_ADDR_VAR 0 2
4936: PUSH
4937: LD_STRING 0
4939: ST_TO_ADDR
// if result [ 1 ] then
4940: LD_VAR 0 1
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: IFFALSE 5013
// if result [ 1 ] [ 1 ] = i then
4950: LD_VAR 0 1
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PUSH
4963: LD_VAR 0 5
4967: EQUAL
4968: IFFALSE 5013
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
4970: LD_ADDR_VAR 0 1
4974: PUSH
4975: LD_VAR 0 1
4979: PPUSH
4980: LD_INT 1
4982: PPUSH
4983: LD_VAR 0 1
4987: PUSH
4988: LD_INT 1
4990: ARRAY
4991: PPUSH
4992: LD_INT 1
4994: PPUSH
4995: CALL_OW 3
4999: PPUSH
5000: CALL_OW 1
5004: ST_TO_ADDR
// tmp := 1 ;
5005: LD_ADDR_VAR 0 2
5009: PUSH
5010: LD_STRING 1
5012: ST_TO_ADDR
// end ; normal := normal & tmp ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_VAR 0 3
5022: PUSH
5023: LD_VAR 0 2
5027: STR
5028: ST_TO_ADDR
// end ;
5029: GO 4929
5031: POP
5032: POP
// for i = 1 to hardcoreCounter do
5033: LD_ADDR_VAR 0 5
5037: PUSH
5038: DOUBLE
5039: LD_INT 1
5041: DEC
5042: ST_TO_ADDR
5043: LD_EXP 19
5047: PUSH
5048: FOR_TO
5049: IFFALSE 5154
// begin tmp := 0 ;
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_STRING 0
5058: ST_TO_ADDR
// if result [ 2 ] then
5059: LD_VAR 0 1
5063: PUSH
5064: LD_INT 2
5066: ARRAY
5067: IFFALSE 5136
// if result [ 2 ] [ 1 ] = 100 + i then
5069: LD_VAR 0 1
5073: PUSH
5074: LD_INT 2
5076: ARRAY
5077: PUSH
5078: LD_INT 1
5080: ARRAY
5081: PUSH
5082: LD_INT 100
5084: PUSH
5085: LD_VAR 0 5
5089: PLUS
5090: EQUAL
5091: IFFALSE 5136
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5093: LD_ADDR_VAR 0 1
5097: PUSH
5098: LD_VAR 0 1
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_VAR 0 1
5110: PUSH
5111: LD_INT 2
5113: ARRAY
5114: PPUSH
5115: LD_INT 1
5117: PPUSH
5118: CALL_OW 3
5122: PPUSH
5123: CALL_OW 1
5127: ST_TO_ADDR
// tmp := 1 ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: LD_STRING 1
5135: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 2
5150: STR
5151: ST_TO_ADDR
// end ;
5152: GO 5048
5154: POP
5155: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5156: LD_STRING getStreamItemsFromMission("
5158: PUSH
5159: LD_VAR 0 3
5163: STR
5164: PUSH
5165: LD_STRING ","
5167: STR
5168: PUSH
5169: LD_VAR 0 4
5173: STR
5174: PUSH
5175: LD_STRING ")
5177: STR
5178: PPUSH
5179: CALL_OW 559
// end else
5183: GO 5192
// ToLua ( getStreamItemsFromMission("","") ) ;
5185: LD_STRING getStreamItemsFromMission("","")
5187: PPUSH
5188: CALL_OW 559
// end ;
5192: LD_VAR 0 1
5196: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5197: LD_EXP 17
5201: PUSH
5202: LD_EXP 22
5206: AND
5207: IFFALSE 5331
5209: GO 5211
5211: DISABLE
5212: LD_INT 0
5214: PPUSH
5215: PPUSH
// begin enable ;
5216: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_INT 22
5224: PUSH
5225: LD_OWVAR 2
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: PUSH
5234: LD_INT 2
5236: PUSH
5237: LD_INT 34
5239: PUSH
5240: LD_INT 7
5242: PUSH
5243: EMPTY
5244: LIST
5245: LIST
5246: PUSH
5247: LD_INT 34
5249: PUSH
5250: LD_INT 45
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 34
5259: PUSH
5260: LD_INT 28
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: LD_INT 34
5269: PUSH
5270: LD_INT 47
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: LIST
5281: LIST
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: PPUSH
5288: CALL_OW 69
5292: ST_TO_ADDR
// if not tmp then
5293: LD_VAR 0 2
5297: NOT
5298: IFFALSE 5302
// exit ;
5300: GO 5331
// for i in tmp do
5302: LD_ADDR_VAR 0 1
5306: PUSH
5307: LD_VAR 0 2
5311: PUSH
5312: FOR_IN
5313: IFFALSE 5329
// begin SetLives ( i , 0 ) ;
5315: LD_VAR 0 1
5319: PPUSH
5320: LD_INT 0
5322: PPUSH
5323: CALL_OW 234
// end ;
5327: GO 5312
5329: POP
5330: POP
// end ;
5331: PPOPN 2
5333: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5334: LD_EXP 17
5338: PUSH
5339: LD_EXP 23
5343: AND
5344: IFFALSE 5428
5346: GO 5348
5348: DISABLE
5349: LD_INT 0
5351: PPUSH
5352: PPUSH
// begin enable ;
5353: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5354: LD_ADDR_VAR 0 2
5358: PUSH
5359: LD_INT 22
5361: PUSH
5362: LD_OWVAR 2
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: LD_INT 32
5373: PUSH
5374: LD_INT 3
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: ST_TO_ADDR
// if not tmp then
5390: LD_VAR 0 2
5394: NOT
5395: IFFALSE 5399
// exit ;
5397: GO 5428
// for i in tmp do
5399: LD_ADDR_VAR 0 1
5403: PUSH
5404: LD_VAR 0 2
5408: PUSH
5409: FOR_IN
5410: IFFALSE 5426
// begin SetLives ( i , 0 ) ;
5412: LD_VAR 0 1
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 234
// end ;
5424: GO 5409
5426: POP
5427: POP
// end ;
5428: PPOPN 2
5430: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5431: LD_EXP 17
5435: PUSH
5436: LD_EXP 20
5440: AND
5441: IFFALSE 5534
5443: GO 5445
5445: DISABLE
5446: LD_INT 0
5448: PPUSH
// begin enable ;
5449: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5450: LD_ADDR_VAR 0 1
5454: PUSH
5455: LD_INT 22
5457: PUSH
5458: LD_OWVAR 2
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PUSH
5467: LD_INT 2
5469: PUSH
5470: LD_INT 25
5472: PUSH
5473: LD_INT 5
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 25
5482: PUSH
5483: LD_INT 9
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PUSH
5490: LD_INT 25
5492: PUSH
5493: LD_INT 8
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PPUSH
5510: CALL_OW 69
5514: PUSH
5515: FOR_IN
5516: IFFALSE 5532
// begin SetClass ( i , 1 ) ;
5518: LD_VAR 0 1
5522: PPUSH
5523: LD_INT 1
5525: PPUSH
5526: CALL_OW 336
// end ;
5530: GO 5515
5532: POP
5533: POP
// end ;
5534: PPOPN 1
5536: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5537: LD_EXP 17
5541: PUSH
5542: LD_EXP 21
5546: AND
5547: PUSH
5548: LD_OWVAR 65
5552: PUSH
5553: LD_INT 7
5555: LESS
5556: AND
5557: IFFALSE 5571
5559: GO 5561
5561: DISABLE
// begin enable ;
5562: ENABLE
// game_speed := 7 ;
5563: LD_ADDR_OWVAR 65
5567: PUSH
5568: LD_INT 7
5570: ST_TO_ADDR
// end ;
5571: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5572: LD_EXP 17
5576: PUSH
5577: LD_EXP 24
5581: AND
5582: IFFALSE 5784
5584: GO 5586
5586: DISABLE
5587: LD_INT 0
5589: PPUSH
5590: PPUSH
5591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5592: LD_ADDR_VAR 0 3
5596: PUSH
5597: LD_INT 81
5599: PUSH
5600: LD_OWVAR 2
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 1
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: CALL_OW 69
5627: ST_TO_ADDR
// if not tmp then
5628: LD_VAR 0 3
5632: NOT
5633: IFFALSE 5637
// exit ;
5635: GO 5784
// if tmp > 5 then
5637: LD_VAR 0 3
5641: PUSH
5642: LD_INT 5
5644: GREATER
5645: IFFALSE 5657
// k := 5 else
5647: LD_ADDR_VAR 0 2
5651: PUSH
5652: LD_INT 5
5654: ST_TO_ADDR
5655: GO 5667
// k := tmp ;
5657: LD_ADDR_VAR 0 2
5661: PUSH
5662: LD_VAR 0 3
5666: ST_TO_ADDR
// for i := 1 to k do
5667: LD_ADDR_VAR 0 1
5671: PUSH
5672: DOUBLE
5673: LD_INT 1
5675: DEC
5676: ST_TO_ADDR
5677: LD_VAR 0 2
5681: PUSH
5682: FOR_TO
5683: IFFALSE 5782
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5685: LD_VAR 0 3
5689: PUSH
5690: LD_VAR 0 1
5694: ARRAY
5695: PPUSH
5696: LD_VAR 0 1
5700: PUSH
5701: LD_INT 4
5703: MOD
5704: PUSH
5705: LD_INT 1
5707: PLUS
5708: PPUSH
5709: CALL_OW 259
5713: PUSH
5714: LD_INT 10
5716: LESS
5717: IFFALSE 5780
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5719: LD_VAR 0 3
5723: PUSH
5724: LD_VAR 0 1
5728: ARRAY
5729: PPUSH
5730: LD_VAR 0 1
5734: PUSH
5735: LD_INT 4
5737: MOD
5738: PUSH
5739: LD_INT 1
5741: PLUS
5742: PPUSH
5743: LD_VAR 0 3
5747: PUSH
5748: LD_VAR 0 1
5752: ARRAY
5753: PPUSH
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 4
5761: MOD
5762: PUSH
5763: LD_INT 1
5765: PLUS
5766: PPUSH
5767: CALL_OW 259
5771: PUSH
5772: LD_INT 1
5774: PLUS
5775: PPUSH
5776: CALL_OW 237
5780: GO 5682
5782: POP
5783: POP
// end ;
5784: PPOPN 3
5786: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5787: LD_EXP 17
5791: PUSH
5792: LD_EXP 25
5796: AND
5797: IFFALSE 5817
5799: GO 5801
5801: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5802: LD_INT 4
5804: PPUSH
5805: LD_OWVAR 2
5809: PPUSH
5810: LD_INT 0
5812: PPUSH
5813: CALL_OW 324
5817: END
// every 0 0$1 trigger StreamModeActive and sShovel do
5818: LD_EXP 17
5822: PUSH
5823: LD_EXP 54
5827: AND
5828: IFFALSE 5848
5830: GO 5832
5832: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
5833: LD_INT 19
5835: PPUSH
5836: LD_OWVAR 2
5840: PPUSH
5841: LD_INT 0
5843: PPUSH
5844: CALL_OW 324
5848: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5849: LD_EXP 17
5853: PUSH
5854: LD_EXP 26
5858: AND
5859: IFFALSE 5961
5861: GO 5863
5863: DISABLE
5864: LD_INT 0
5866: PPUSH
5867: PPUSH
// begin enable ;
5868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
5869: LD_ADDR_VAR 0 2
5873: PUSH
5874: LD_INT 22
5876: PUSH
5877: LD_OWVAR 2
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: LD_INT 34
5891: PUSH
5892: LD_INT 11
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 34
5901: PUSH
5902: LD_INT 30
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PPUSH
5918: CALL_OW 69
5922: ST_TO_ADDR
// if not tmp then
5923: LD_VAR 0 2
5927: NOT
5928: IFFALSE 5932
// exit ;
5930: GO 5961
// for i in tmp do
5932: LD_ADDR_VAR 0 1
5936: PUSH
5937: LD_VAR 0 2
5941: PUSH
5942: FOR_IN
5943: IFFALSE 5959
// begin SetLives ( i , 0 ) ;
5945: LD_VAR 0 1
5949: PPUSH
5950: LD_INT 0
5952: PPUSH
5953: CALL_OW 234
// end ;
5957: GO 5942
5959: POP
5960: POP
// end ;
5961: PPOPN 2
5963: END
// every 0 0$1 trigger StreamModeActive and sBunker do
5964: LD_EXP 17
5968: PUSH
5969: LD_EXP 27
5973: AND
5974: IFFALSE 5994
5976: GO 5978
5978: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
5979: LD_INT 32
5981: PPUSH
5982: LD_OWVAR 2
5986: PPUSH
5987: LD_INT 0
5989: PPUSH
5990: CALL_OW 324
5994: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
5995: LD_EXP 17
5999: PUSH
6000: LD_EXP 28
6004: AND
6005: IFFALSE 6186
6007: GO 6009
6009: DISABLE
6010: LD_INT 0
6012: PPUSH
6013: PPUSH
6014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: LD_INT 22
6022: PUSH
6023: LD_OWVAR 2
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PUSH
6032: LD_INT 33
6034: PUSH
6035: LD_INT 3
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: PPUSH
6046: CALL_OW 69
6050: ST_TO_ADDR
// if not tmp then
6051: LD_VAR 0 2
6055: NOT
6056: IFFALSE 6060
// exit ;
6058: GO 6186
// side := 0 ;
6060: LD_ADDR_VAR 0 3
6064: PUSH
6065: LD_INT 0
6067: ST_TO_ADDR
// for i := 1 to 8 do
6068: LD_ADDR_VAR 0 1
6072: PUSH
6073: DOUBLE
6074: LD_INT 1
6076: DEC
6077: ST_TO_ADDR
6078: LD_INT 8
6080: PUSH
6081: FOR_TO
6082: IFFALSE 6130
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6084: LD_OWVAR 2
6088: PUSH
6089: LD_VAR 0 1
6093: NONEQUAL
6094: PUSH
6095: LD_OWVAR 2
6099: PPUSH
6100: LD_VAR 0 1
6104: PPUSH
6105: CALL_OW 81
6109: PUSH
6110: LD_INT 2
6112: EQUAL
6113: AND
6114: IFFALSE 6128
// begin side := i ;
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: ST_TO_ADDR
// break ;
6126: GO 6130
// end ;
6128: GO 6081
6130: POP
6131: POP
// if not side then
6132: LD_VAR 0 3
6136: NOT
6137: IFFALSE 6141
// exit ;
6139: GO 6186
// for i := 1 to tmp do
6141: LD_ADDR_VAR 0 1
6145: PUSH
6146: DOUBLE
6147: LD_INT 1
6149: DEC
6150: ST_TO_ADDR
6151: LD_VAR 0 2
6155: PUSH
6156: FOR_TO
6157: IFFALSE 6184
// if Prob ( 60 ) then
6159: LD_INT 60
6161: PPUSH
6162: CALL_OW 13
6166: IFFALSE 6182
// SetSide ( i , side ) ;
6168: LD_VAR 0 1
6172: PPUSH
6173: LD_VAR 0 3
6177: PPUSH
6178: CALL_OW 235
6182: GO 6156
6184: POP
6185: POP
// end ;
6186: PPOPN 3
6188: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6189: LD_EXP 17
6193: PUSH
6194: LD_EXP 30
6198: AND
6199: IFFALSE 6318
6201: GO 6203
6203: DISABLE
6204: LD_INT 0
6206: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6207: LD_ADDR_VAR 0 1
6211: PUSH
6212: LD_INT 22
6214: PUSH
6215: LD_OWVAR 2
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: PUSH
6224: LD_INT 21
6226: PUSH
6227: LD_INT 1
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 23
6239: PUSH
6240: LD_INT 0
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 69
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6316
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6264: LD_VAR 0 1
6268: PPUSH
6269: CALL_OW 257
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 3
6282: PUSH
6283: LD_INT 4
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: IN
6292: IFFALSE 6314
// SetClass ( un , rand ( 1 , 4 ) ) ;
6294: LD_VAR 0 1
6298: PPUSH
6299: LD_INT 1
6301: PPUSH
6302: LD_INT 4
6304: PPUSH
6305: CALL_OW 12
6309: PPUSH
6310: CALL_OW 336
6314: GO 6261
6316: POP
6317: POP
// end ;
6318: PPOPN 1
6320: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6321: LD_EXP 17
6325: PUSH
6326: LD_EXP 29
6330: AND
6331: IFFALSE 6410
6333: GO 6335
6335: DISABLE
6336: LD_INT 0
6338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6339: LD_ADDR_VAR 0 1
6343: PUSH
6344: LD_INT 22
6346: PUSH
6347: LD_OWVAR 2
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 21
6358: PUSH
6359: LD_INT 3
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: PPUSH
6370: CALL_OW 69
6374: ST_TO_ADDR
// if not tmp then
6375: LD_VAR 0 1
6379: NOT
6380: IFFALSE 6384
// exit ;
6382: GO 6410
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6384: LD_VAR 0 1
6388: PUSH
6389: LD_INT 1
6391: PPUSH
6392: LD_VAR 0 1
6396: PPUSH
6397: CALL_OW 12
6401: ARRAY
6402: PPUSH
6403: LD_INT 100
6405: PPUSH
6406: CALL_OW 234
// end ;
6410: PPOPN 1
6412: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6413: LD_EXP 17
6417: PUSH
6418: LD_EXP 31
6422: AND
6423: IFFALSE 6521
6425: GO 6427
6427: DISABLE
6428: LD_INT 0
6430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6431: LD_ADDR_VAR 0 1
6435: PUSH
6436: LD_INT 22
6438: PUSH
6439: LD_OWVAR 2
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 21
6450: PUSH
6451: LD_INT 1
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 69
6466: ST_TO_ADDR
// if not tmp then
6467: LD_VAR 0 1
6471: NOT
6472: IFFALSE 6476
// exit ;
6474: GO 6521
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_VAR 0 1
6488: PPUSH
6489: CALL_OW 12
6493: ARRAY
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 4
6500: PPUSH
6501: CALL_OW 12
6505: PPUSH
6506: LD_INT 3000
6508: PPUSH
6509: LD_INT 9000
6511: PPUSH
6512: CALL_OW 12
6516: PPUSH
6517: CALL_OW 492
// end ;
6521: PPOPN 1
6523: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6524: LD_EXP 17
6528: PUSH
6529: LD_EXP 32
6533: AND
6534: IFFALSE 6554
6536: GO 6538
6538: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6539: LD_INT 1
6541: PPUSH
6542: LD_OWVAR 2
6546: PPUSH
6547: LD_INT 0
6549: PPUSH
6550: CALL_OW 324
6554: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6555: LD_EXP 17
6559: PUSH
6560: LD_EXP 33
6564: AND
6565: IFFALSE 6648
6567: GO 6569
6569: DISABLE
6570: LD_INT 0
6572: PPUSH
6573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_INT 22
6581: PUSH
6582: LD_OWVAR 2
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 21
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PPUSH
6605: CALL_OW 69
6609: ST_TO_ADDR
// if not tmp then
6610: LD_VAR 0 2
6614: NOT
6615: IFFALSE 6619
// exit ;
6617: GO 6648
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 2
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6646
// SetBLevel ( i , 10 ) ;
6632: LD_VAR 0 1
6636: PPUSH
6637: LD_INT 10
6639: PPUSH
6640: CALL_OW 241
6644: GO 6629
6646: POP
6647: POP
// end ;
6648: PPOPN 2
6650: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
6651: LD_EXP 17
6655: PUSH
6656: LD_EXP 34
6660: AND
6661: IFFALSE 6772
6663: GO 6665
6665: DISABLE
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6671: LD_ADDR_VAR 0 3
6675: PUSH
6676: LD_INT 22
6678: PUSH
6679: LD_OWVAR 2
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PUSH
6688: LD_INT 25
6690: PUSH
6691: LD_INT 1
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: ST_TO_ADDR
// if not tmp then
6707: LD_VAR 0 3
6711: NOT
6712: IFFALSE 6716
// exit ;
6714: GO 6772
// un := tmp [ rand ( 1 , tmp ) ] ;
6716: LD_ADDR_VAR 0 2
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 1
6728: PPUSH
6729: LD_VAR 0 3
6733: PPUSH
6734: CALL_OW 12
6738: ARRAY
6739: ST_TO_ADDR
// if Crawls ( un ) then
6740: LD_VAR 0 2
6744: PPUSH
6745: CALL_OW 318
6749: IFFALSE 6760
// ComWalk ( un ) ;
6751: LD_VAR 0 2
6755: PPUSH
6756: CALL_OW 138
// SetClass ( un , class_sniper ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 5
6767: PPUSH
6768: CALL_OW 336
// end ;
6772: PPOPN 3
6774: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6775: LD_EXP 17
6779: PUSH
6780: LD_EXP 35
6784: AND
6785: PUSH
6786: LD_OWVAR 67
6790: PUSH
6791: LD_INT 3
6793: LESS
6794: AND
6795: IFFALSE 6814
6797: GO 6799
6799: DISABLE
// Difficulty := Difficulty + 1 ;
6800: LD_ADDR_OWVAR 67
6804: PUSH
6805: LD_OWVAR 67
6809: PUSH
6810: LD_INT 1
6812: PLUS
6813: ST_TO_ADDR
6814: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6815: LD_EXP 17
6819: PUSH
6820: LD_EXP 36
6824: AND
6825: IFFALSE 6928
6827: GO 6829
6829: DISABLE
6830: LD_INT 0
6832: PPUSH
// begin for i := 1 to 5 do
6833: LD_ADDR_VAR 0 1
6837: PUSH
6838: DOUBLE
6839: LD_INT 1
6841: DEC
6842: ST_TO_ADDR
6843: LD_INT 5
6845: PUSH
6846: FOR_TO
6847: IFFALSE 6926
// begin uc_nation := nation_nature ;
6849: LD_ADDR_OWVAR 21
6853: PUSH
6854: LD_INT 0
6856: ST_TO_ADDR
// uc_side := 0 ;
6857: LD_ADDR_OWVAR 20
6861: PUSH
6862: LD_INT 0
6864: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6865: LD_ADDR_OWVAR 29
6869: PUSH
6870: LD_INT 12
6872: PUSH
6873: LD_INT 12
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: ST_TO_ADDR
// hc_agressivity := 20 ;
6880: LD_ADDR_OWVAR 35
6884: PUSH
6885: LD_INT 20
6887: ST_TO_ADDR
// hc_class := class_tiger ;
6888: LD_ADDR_OWVAR 28
6892: PUSH
6893: LD_INT 14
6895: ST_TO_ADDR
// hc_gallery :=  ;
6896: LD_ADDR_OWVAR 33
6900: PUSH
6901: LD_STRING 
6903: ST_TO_ADDR
// hc_name :=  ;
6904: LD_ADDR_OWVAR 26
6908: PUSH
6909: LD_STRING 
6911: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
6912: CALL_OW 44
6916: PPUSH
6917: LD_INT 0
6919: PPUSH
6920: CALL_OW 51
// end ;
6924: GO 6846
6926: POP
6927: POP
// end ;
6928: PPOPN 1
6930: END
// every 0 0$1 trigger StreamModeActive and sBomb do
6931: LD_EXP 17
6935: PUSH
6936: LD_EXP 37
6940: AND
6941: IFFALSE 6950
6943: GO 6945
6945: DISABLE
// StreamSibBomb ;
6946: CALL 6951 0 0
6950: END
// export function StreamSibBomb ; var i , x , y ; begin
6951: LD_INT 0
6953: PPUSH
6954: PPUSH
6955: PPUSH
6956: PPUSH
// result := false ;
6957: LD_ADDR_VAR 0 1
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// for i := 1 to 16 do
6965: LD_ADDR_VAR 0 2
6969: PUSH
6970: DOUBLE
6971: LD_INT 1
6973: DEC
6974: ST_TO_ADDR
6975: LD_INT 16
6977: PUSH
6978: FOR_TO
6979: IFFALSE 7178
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_INT 10
6988: PUSH
6989: LD_INT 20
6991: PUSH
6992: LD_INT 30
6994: PUSH
6995: LD_INT 40
6997: PUSH
6998: LD_INT 50
7000: PUSH
7001: LD_INT 60
7003: PUSH
7004: LD_INT 70
7006: PUSH
7007: LD_INT 80
7009: PUSH
7010: LD_INT 90
7012: PUSH
7013: LD_INT 100
7015: PUSH
7016: LD_INT 110
7018: PUSH
7019: LD_INT 120
7021: PUSH
7022: LD_INT 130
7024: PUSH
7025: LD_INT 140
7027: PUSH
7028: LD_INT 150
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: LIST
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 15
7053: PPUSH
7054: CALL_OW 12
7058: ARRAY
7059: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7060: LD_ADDR_VAR 0 4
7064: PUSH
7065: LD_INT 10
7067: PUSH
7068: LD_INT 20
7070: PUSH
7071: LD_INT 30
7073: PUSH
7074: LD_INT 40
7076: PUSH
7077: LD_INT 50
7079: PUSH
7080: LD_INT 60
7082: PUSH
7083: LD_INT 70
7085: PUSH
7086: LD_INT 80
7088: PUSH
7089: LD_INT 90
7091: PUSH
7092: LD_INT 100
7094: PUSH
7095: LD_INT 110
7097: PUSH
7098: LD_INT 120
7100: PUSH
7101: LD_INT 130
7103: PUSH
7104: LD_INT 140
7106: PUSH
7107: LD_INT 150
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 1
7129: PPUSH
7130: LD_INT 15
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// if ValidHex ( x , y ) then
7139: LD_VAR 0 3
7143: PPUSH
7144: LD_VAR 0 4
7148: PPUSH
7149: CALL_OW 488
7153: IFFALSE 7176
// begin result := [ x , y ] ;
7155: LD_ADDR_VAR 0 1
7159: PUSH
7160: LD_VAR 0 3
7164: PUSH
7165: LD_VAR 0 4
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: ST_TO_ADDR
// break ;
7174: GO 7178
// end ; end ;
7176: GO 6978
7178: POP
7179: POP
// if result then
7180: LD_VAR 0 1
7184: IFFALSE 7244
// begin ToLua ( playSibBomb() ) ;
7186: LD_STRING playSibBomb()
7188: PPUSH
7189: CALL_OW 559
// wait ( 0 0$14 ) ;
7193: LD_INT 490
7195: PPUSH
7196: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
7200: LD_VAR 0 1
7204: PUSH
7205: LD_INT 1
7207: ARRAY
7208: PPUSH
7209: LD_VAR 0 1
7213: PUSH
7214: LD_INT 2
7216: ARRAY
7217: PPUSH
7218: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7222: LD_VAR 0 1
7226: PUSH
7227: LD_INT 1
7229: ARRAY
7230: PPUSH
7231: LD_VAR 0 1
7235: PUSH
7236: LD_INT 2
7238: ARRAY
7239: PPUSH
7240: CALL_OW 429
// end ; end ;
7244: LD_VAR 0 1
7248: RET
// every 0 0$1 trigger StreamModeActive and sReset do
7249: LD_EXP 17
7253: PUSH
7254: LD_EXP 39
7258: AND
7259: IFFALSE 7271
7261: GO 7263
7263: DISABLE
// YouLost (  ) ;
7264: LD_STRING 
7266: PPUSH
7267: CALL_OW 104
7271: END
// every 0 0$1 trigger StreamModeActive and sFog do
7272: LD_EXP 17
7276: PUSH
7277: LD_EXP 38
7281: AND
7282: IFFALSE 7296
7284: GO 7286
7286: DISABLE
// FogOff ( your_side ) ;
7287: LD_OWVAR 2
7291: PPUSH
7292: CALL_OW 344
7296: END
// every 0 0$1 trigger StreamModeActive and sSun do
7297: LD_EXP 17
7301: PUSH
7302: LD_EXP 40
7306: AND
7307: IFFALSE 7335
7309: GO 7311
7311: DISABLE
// begin solar_recharge_percent := 0 ;
7312: LD_ADDR_OWVAR 79
7316: PUSH
7317: LD_INT 0
7319: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7320: LD_INT 10500
7322: PPUSH
7323: CALL_OW 67
// solar_recharge_percent := 100 ;
7327: LD_ADDR_OWVAR 79
7331: PUSH
7332: LD_INT 100
7334: ST_TO_ADDR
// end ;
7335: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
7336: LD_EXP 17
7340: PUSH
7341: LD_EXP 41
7345: AND
7346: IFFALSE 7585
7348: GO 7350
7350: DISABLE
7351: LD_INT 0
7353: PPUSH
7354: PPUSH
7355: PPUSH
// begin tmp := [ ] ;
7356: LD_ADDR_VAR 0 3
7360: PUSH
7361: EMPTY
7362: ST_TO_ADDR
// for i := 1 to 6 do
7363: LD_ADDR_VAR 0 1
7367: PUSH
7368: DOUBLE
7369: LD_INT 1
7371: DEC
7372: ST_TO_ADDR
7373: LD_INT 6
7375: PUSH
7376: FOR_TO
7377: IFFALSE 7482
// begin uc_nation := nation_nature ;
7379: LD_ADDR_OWVAR 21
7383: PUSH
7384: LD_INT 0
7386: ST_TO_ADDR
// uc_side := 0 ;
7387: LD_ADDR_OWVAR 20
7391: PUSH
7392: LD_INT 0
7394: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7395: LD_ADDR_OWVAR 29
7399: PUSH
7400: LD_INT 12
7402: PUSH
7403: LD_INT 12
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: ST_TO_ADDR
// hc_agressivity := 20 ;
7410: LD_ADDR_OWVAR 35
7414: PUSH
7415: LD_INT 20
7417: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7418: LD_ADDR_OWVAR 28
7422: PUSH
7423: LD_INT 17
7425: ST_TO_ADDR
// hc_gallery :=  ;
7426: LD_ADDR_OWVAR 33
7430: PUSH
7431: LD_STRING 
7433: ST_TO_ADDR
// hc_name :=  ;
7434: LD_ADDR_OWVAR 26
7438: PUSH
7439: LD_STRING 
7441: ST_TO_ADDR
// un := CreateHuman ;
7442: LD_ADDR_VAR 0 2
7446: PUSH
7447: CALL_OW 44
7451: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7452: LD_VAR 0 2
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: CALL_OW 51
// tmp := tmp ^ un ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_VAR 0 3
7473: PUSH
7474: LD_VAR 0 2
7478: ADD
7479: ST_TO_ADDR
// end ;
7480: GO 7376
7482: POP
7483: POP
// repeat wait ( 0 0$1 ) ;
7484: LD_INT 35
7486: PPUSH
7487: CALL_OW 67
// for un in tmp do
7491: LD_ADDR_VAR 0 2
7495: PUSH
7496: LD_VAR 0 3
7500: PUSH
7501: FOR_IN
7502: IFFALSE 7576
// begin if IsDead ( un ) then
7504: LD_VAR 0 2
7508: PPUSH
7509: CALL_OW 301
7513: IFFALSE 7533
// begin tmp := tmp diff un ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_VAR 0 3
7524: PUSH
7525: LD_VAR 0 2
7529: DIFF
7530: ST_TO_ADDR
// continue ;
7531: GO 7501
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7533: LD_VAR 0 2
7537: PPUSH
7538: LD_INT 3
7540: PUSH
7541: LD_INT 22
7543: PUSH
7544: LD_INT 0
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PPUSH
7555: CALL_OW 69
7559: PPUSH
7560: LD_VAR 0 2
7564: PPUSH
7565: CALL_OW 74
7569: PPUSH
7570: CALL_OW 115
// end ;
7574: GO 7501
7576: POP
7577: POP
// until not tmp ;
7578: LD_VAR 0 3
7582: NOT
7583: IFFALSE 7484
// end ;
7585: PPOPN 3
7587: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7588: LD_EXP 17
7592: PUSH
7593: LD_EXP 42
7597: AND
7598: IFFALSE 7652
7600: GO 7602
7602: DISABLE
// begin ToLua ( displayTroll(); ) ;
7603: LD_STRING displayTroll();
7605: PPUSH
7606: CALL_OW 559
// wait ( 3 3$00 ) ;
7610: LD_INT 6300
7612: PPUSH
7613: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7617: LD_STRING hideTroll();
7619: PPUSH
7620: CALL_OW 559
// wait ( 1 1$00 ) ;
7624: LD_INT 2100
7626: PPUSH
7627: CALL_OW 67
// ToLua ( displayTroll(); ) ;
7631: LD_STRING displayTroll();
7633: PPUSH
7634: CALL_OW 559
// wait ( 1 1$00 ) ;
7638: LD_INT 2100
7640: PPUSH
7641: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7645: LD_STRING hideTroll();
7647: PPUSH
7648: CALL_OW 559
// end ;
7652: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7653: LD_EXP 17
7657: PUSH
7658: LD_EXP 43
7662: AND
7663: IFFALSE 7726
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin p := 0 ;
7671: LD_ADDR_VAR 0 1
7675: PUSH
7676: LD_INT 0
7678: ST_TO_ADDR
// repeat game_speed := 1 ;
7679: LD_ADDR_OWVAR 65
7683: PUSH
7684: LD_INT 1
7686: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7687: LD_INT 35
7689: PPUSH
7690: CALL_OW 67
// p := p + 1 ;
7694: LD_ADDR_VAR 0 1
7698: PUSH
7699: LD_VAR 0 1
7703: PUSH
7704: LD_INT 1
7706: PLUS
7707: ST_TO_ADDR
// until p >= 60 ;
7708: LD_VAR 0 1
7712: PUSH
7713: LD_INT 60
7715: GREATEREQUAL
7716: IFFALSE 7679
// game_speed := 4 ;
7718: LD_ADDR_OWVAR 65
7722: PUSH
7723: LD_INT 4
7725: ST_TO_ADDR
// end ;
7726: PPOPN 1
7728: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
7729: LD_EXP 17
7733: PUSH
7734: LD_EXP 44
7738: AND
7739: IFFALSE 7885
7741: GO 7743
7743: DISABLE
7744: LD_INT 0
7746: PPUSH
7747: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7748: LD_ADDR_VAR 0 1
7752: PUSH
7753: LD_INT 22
7755: PUSH
7756: LD_OWVAR 2
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 2
7767: PUSH
7768: LD_INT 30
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: PUSH
7778: LD_INT 30
7780: PUSH
7781: LD_INT 1
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PPUSH
7797: CALL_OW 69
7801: ST_TO_ADDR
// if not depot then
7802: LD_VAR 0 1
7806: NOT
7807: IFFALSE 7811
// exit ;
7809: GO 7885
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7811: LD_ADDR_VAR 0 2
7815: PUSH
7816: LD_VAR 0 1
7820: PUSH
7821: LD_INT 1
7823: PPUSH
7824: LD_VAR 0 1
7828: PPUSH
7829: CALL_OW 12
7833: ARRAY
7834: PPUSH
7835: CALL_OW 274
7839: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: LD_INT 1
7847: PPUSH
7848: LD_INT 0
7850: PPUSH
7851: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
7855: LD_VAR 0 2
7859: PPUSH
7860: LD_INT 2
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
7870: LD_VAR 0 2
7874: PPUSH
7875: LD_INT 3
7877: PPUSH
7878: LD_INT 0
7880: PPUSH
7881: CALL_OW 277
// end ;
7885: PPOPN 2
7887: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
7888: LD_EXP 17
7892: PUSH
7893: LD_EXP 45
7897: AND
7898: IFFALSE 7995
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
7906: LD_ADDR_VAR 0 1
7910: PUSH
7911: LD_INT 22
7913: PUSH
7914: LD_OWVAR 2
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 21
7925: PUSH
7926: LD_INT 1
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 23
7938: PUSH
7939: LD_INT 0
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: LIST
7954: PPUSH
7955: CALL_OW 69
7959: ST_TO_ADDR
// if not tmp then
7960: LD_VAR 0 1
7964: NOT
7965: IFFALSE 7969
// exit ;
7967: GO 7995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
7969: LD_VAR 0 1
7973: PUSH
7974: LD_INT 1
7976: PPUSH
7977: LD_VAR 0 1
7981: PPUSH
7982: CALL_OW 12
7986: ARRAY
7987: PPUSH
7988: LD_INT 200
7990: PPUSH
7991: CALL_OW 234
// end ;
7995: PPOPN 1
7997: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
7998: LD_EXP 17
8002: PUSH
8003: LD_EXP 46
8007: AND
8008: IFFALSE 8087
8010: GO 8012
8012: DISABLE
8013: LD_INT 0
8015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8016: LD_ADDR_VAR 0 1
8020: PUSH
8021: LD_INT 22
8023: PUSH
8024: LD_OWVAR 2
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 21
8035: PUSH
8036: LD_INT 2
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: ST_TO_ADDR
// if not tmp then
8052: LD_VAR 0 1
8056: NOT
8057: IFFALSE 8061
// exit ;
8059: GO 8087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
8061: LD_VAR 0 1
8065: PUSH
8066: LD_INT 1
8068: PPUSH
8069: LD_VAR 0 1
8073: PPUSH
8074: CALL_OW 12
8078: ARRAY
8079: PPUSH
8080: LD_INT 60
8082: PPUSH
8083: CALL_OW 234
// end ;
8087: PPOPN 1
8089: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8090: LD_EXP 17
8094: PUSH
8095: LD_EXP 47
8099: AND
8100: IFFALSE 8199
8102: GO 8104
8104: DISABLE
8105: LD_INT 0
8107: PPUSH
8108: PPUSH
// begin enable ;
8109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8110: LD_ADDR_VAR 0 1
8114: PUSH
8115: LD_INT 22
8117: PUSH
8118: LD_OWVAR 2
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: PUSH
8127: LD_INT 61
8129: PUSH
8130: EMPTY
8131: LIST
8132: PUSH
8133: LD_INT 33
8135: PUSH
8136: LD_INT 2
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 69
8152: ST_TO_ADDR
// if not tmp then
8153: LD_VAR 0 1
8157: NOT
8158: IFFALSE 8162
// exit ;
8160: GO 8199
// for i in tmp do
8162: LD_ADDR_VAR 0 2
8166: PUSH
8167: LD_VAR 0 1
8171: PUSH
8172: FOR_IN
8173: IFFALSE 8197
// if IsControledBy ( i ) then
8175: LD_VAR 0 2
8179: PPUSH
8180: CALL_OW 312
8184: IFFALSE 8195
// ComUnlink ( i ) ;
8186: LD_VAR 0 2
8190: PPUSH
8191: CALL_OW 136
8195: GO 8172
8197: POP
8198: POP
// end ;
8199: PPOPN 2
8201: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
8202: LD_EXP 17
8206: PUSH
8207: LD_EXP 48
8211: AND
8212: IFFALSE 8352
8214: GO 8216
8216: DISABLE
8217: LD_INT 0
8219: PPUSH
8220: PPUSH
// begin ToLua ( displayPowell(); ) ;
8221: LD_STRING displayPowell();
8223: PPUSH
8224: CALL_OW 559
// uc_side := 0 ;
8228: LD_ADDR_OWVAR 20
8232: PUSH
8233: LD_INT 0
8235: ST_TO_ADDR
// uc_nation := 2 ;
8236: LD_ADDR_OWVAR 21
8240: PUSH
8241: LD_INT 2
8243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
8244: LD_ADDR_OWVAR 37
8248: PUSH
8249: LD_INT 14
8251: ST_TO_ADDR
// vc_engine := engine_siberite ;
8252: LD_ADDR_OWVAR 39
8256: PUSH
8257: LD_INT 3
8259: ST_TO_ADDR
// vc_control := control_apeman ;
8260: LD_ADDR_OWVAR 38
8264: PUSH
8265: LD_INT 5
8267: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
8268: LD_ADDR_OWVAR 40
8272: PUSH
8273: LD_INT 29
8275: ST_TO_ADDR
// un := CreateVehicle ;
8276: LD_ADDR_VAR 0 2
8280: PUSH
8281: CALL_OW 45
8285: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_INT 1
8293: PPUSH
8294: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
8298: LD_INT 35
8300: PPUSH
8301: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
8305: LD_VAR 0 2
8309: PPUSH
8310: LD_INT 22
8312: PUSH
8313: LD_OWVAR 2
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: PPUSH
8327: LD_VAR 0 2
8331: PPUSH
8332: CALL_OW 74
8336: PPUSH
8337: CALL_OW 115
// until IsDead ( un ) ;
8341: LD_VAR 0 2
8345: PPUSH
8346: CALL_OW 301
8350: IFFALSE 8298
// end ;
8352: PPOPN 2
8354: END
// every 0 0$1 trigger StreamModeActive and sStu do
8355: LD_EXP 17
8359: PUSH
8360: LD_EXP 56
8364: AND
8365: IFFALSE 8381
8367: GO 8369
8369: DISABLE
// begin ToLua ( displayStucuk(); ) ;
8370: LD_STRING displayStucuk();
8372: PPUSH
8373: CALL_OW 559
// ResetFog ;
8377: CALL_OW 335
// end ;
8381: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
8382: LD_EXP 17
8386: PUSH
8387: LD_EXP 49
8391: AND
8392: IFFALSE 8533
8394: GO 8396
8396: DISABLE
8397: LD_INT 0
8399: PPUSH
8400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8401: LD_ADDR_VAR 0 2
8405: PUSH
8406: LD_INT 22
8408: PUSH
8409: LD_OWVAR 2
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 21
8420: PUSH
8421: LD_INT 1
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 69
8436: ST_TO_ADDR
// if not tmp then
8437: LD_VAR 0 2
8441: NOT
8442: IFFALSE 8446
// exit ;
8444: GO 8533
// un := tmp [ rand ( 1 , tmp ) ] ;
8446: LD_ADDR_VAR 0 1
8450: PUSH
8451: LD_VAR 0 2
8455: PUSH
8456: LD_INT 1
8458: PPUSH
8459: LD_VAR 0 2
8463: PPUSH
8464: CALL_OW 12
8468: ARRAY
8469: ST_TO_ADDR
// SetSide ( un , 0 ) ;
8470: LD_VAR 0 1
8474: PPUSH
8475: LD_INT 0
8477: PPUSH
8478: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
8482: LD_VAR 0 1
8486: PPUSH
8487: LD_OWVAR 3
8491: PUSH
8492: LD_VAR 0 1
8496: DIFF
8497: PPUSH
8498: LD_VAR 0 1
8502: PPUSH
8503: CALL_OW 74
8507: PPUSH
8508: CALL_OW 115
// wait ( 0 0$20 ) ;
8512: LD_INT 700
8514: PPUSH
8515: CALL_OW 67
// SetSide ( un , your_side ) ;
8519: LD_VAR 0 1
8523: PPUSH
8524: LD_OWVAR 2
8528: PPUSH
8529: CALL_OW 235
// end ;
8533: PPOPN 2
8535: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
8536: LD_EXP 17
8540: PUSH
8541: LD_EXP 50
8545: AND
8546: IFFALSE 8652
8548: GO 8550
8550: DISABLE
8551: LD_INT 0
8553: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8554: LD_ADDR_VAR 0 1
8558: PUSH
8559: LD_INT 22
8561: PUSH
8562: LD_OWVAR 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 2
8573: PUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 0
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PUSH
8584: LD_INT 30
8586: PUSH
8587: LD_INT 1
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PPUSH
8603: CALL_OW 69
8607: ST_TO_ADDR
// if not depot then
8608: LD_VAR 0 1
8612: NOT
8613: IFFALSE 8617
// exit ;
8615: GO 8652
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
8617: LD_VAR 0 1
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: CALL_OW 250
8630: PPUSH
8631: LD_VAR 0 1
8635: PUSH
8636: LD_INT 1
8638: ARRAY
8639: PPUSH
8640: CALL_OW 251
8644: PPUSH
8645: LD_INT 70
8647: PPUSH
8648: CALL_OW 495
// end ;
8652: PPOPN 1
8654: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
8655: LD_EXP 17
8659: PUSH
8660: LD_EXP 51
8664: AND
8665: IFFALSE 8876
8667: GO 8669
8669: DISABLE
8670: LD_INT 0
8672: PPUSH
8673: PPUSH
8674: PPUSH
8675: PPUSH
8676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8677: LD_ADDR_VAR 0 5
8681: PUSH
8682: LD_INT 22
8684: PUSH
8685: LD_OWVAR 2
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: PUSH
8694: LD_INT 21
8696: PUSH
8697: LD_INT 1
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: ST_TO_ADDR
// if not tmp then
8713: LD_VAR 0 5
8717: NOT
8718: IFFALSE 8722
// exit ;
8720: GO 8876
// for i in tmp do
8722: LD_ADDR_VAR 0 1
8726: PUSH
8727: LD_VAR 0 5
8731: PUSH
8732: FOR_IN
8733: IFFALSE 8874
// begin d := rand ( 0 , 5 ) ;
8735: LD_ADDR_VAR 0 4
8739: PUSH
8740: LD_INT 0
8742: PPUSH
8743: LD_INT 5
8745: PPUSH
8746: CALL_OW 12
8750: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
8751: LD_ADDR_VAR 0 2
8755: PUSH
8756: LD_VAR 0 1
8760: PPUSH
8761: CALL_OW 250
8765: PPUSH
8766: LD_VAR 0 4
8770: PPUSH
8771: LD_INT 3
8773: PPUSH
8774: LD_INT 12
8776: PPUSH
8777: CALL_OW 12
8781: PPUSH
8782: CALL_OW 272
8786: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
8787: LD_ADDR_VAR 0 3
8791: PUSH
8792: LD_VAR 0 1
8796: PPUSH
8797: CALL_OW 251
8801: PPUSH
8802: LD_VAR 0 4
8806: PPUSH
8807: LD_INT 3
8809: PPUSH
8810: LD_INT 12
8812: PPUSH
8813: CALL_OW 12
8817: PPUSH
8818: CALL_OW 273
8822: ST_TO_ADDR
// if ValidHex ( x , y ) then
8823: LD_VAR 0 2
8827: PPUSH
8828: LD_VAR 0 3
8832: PPUSH
8833: CALL_OW 488
8837: IFFALSE 8872
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
8839: LD_VAR 0 1
8843: PPUSH
8844: LD_VAR 0 2
8848: PPUSH
8849: LD_VAR 0 3
8853: PPUSH
8854: LD_INT 3
8856: PPUSH
8857: LD_INT 6
8859: PPUSH
8860: CALL_OW 12
8864: PPUSH
8865: LD_INT 1
8867: PPUSH
8868: CALL_OW 483
// end ;
8872: GO 8732
8874: POP
8875: POP
// end ;
8876: PPOPN 5
8878: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
8879: LD_EXP 17
8883: PUSH
8884: LD_EXP 52
8888: AND
8889: IFFALSE 8983
8891: GO 8893
8893: DISABLE
8894: LD_INT 0
8896: PPUSH
8897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
8898: LD_ADDR_VAR 0 2
8902: PUSH
8903: LD_INT 22
8905: PUSH
8906: LD_OWVAR 2
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 32
8917: PUSH
8918: LD_INT 1
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 21
8927: PUSH
8928: LD_INT 2
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// if not tmp then
8945: LD_VAR 0 2
8949: NOT
8950: IFFALSE 8954
// exit ;
8952: GO 8983
// for i in tmp do
8954: LD_ADDR_VAR 0 1
8958: PUSH
8959: LD_VAR 0 2
8963: PUSH
8964: FOR_IN
8965: IFFALSE 8981
// SetFuel ( i , 0 ) ;
8967: LD_VAR 0 1
8971: PPUSH
8972: LD_INT 0
8974: PPUSH
8975: CALL_OW 240
8979: GO 8964
8981: POP
8982: POP
// end ;
8983: PPOPN 2
8985: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
8986: LD_EXP 17
8990: PUSH
8991: LD_EXP 53
8995: AND
8996: IFFALSE 9062
8998: GO 9000
9000: DISABLE
9001: LD_INT 0
9003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9004: LD_ADDR_VAR 0 1
9008: PUSH
9009: LD_INT 22
9011: PUSH
9012: LD_OWVAR 2
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PUSH
9021: LD_INT 30
9023: PUSH
9024: LD_INT 29
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL_OW 69
9039: ST_TO_ADDR
// if not tmp then
9040: LD_VAR 0 1
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9062
// DestroyUnit ( tmp [ 1 ] ) ;
9049: LD_VAR 0 1
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: CALL_OW 65
// end ;
9062: PPOPN 1
9064: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
9065: LD_EXP 17
9069: PUSH
9070: LD_EXP 55
9074: AND
9075: IFFALSE 9204
9077: GO 9079
9079: DISABLE
9080: LD_INT 0
9082: PPUSH
// begin uc_side := 0 ;
9083: LD_ADDR_OWVAR 20
9087: PUSH
9088: LD_INT 0
9090: ST_TO_ADDR
// uc_nation := nation_arabian ;
9091: LD_ADDR_OWVAR 21
9095: PUSH
9096: LD_INT 2
9098: ST_TO_ADDR
// hc_gallery :=  ;
9099: LD_ADDR_OWVAR 33
9103: PUSH
9104: LD_STRING 
9106: ST_TO_ADDR
// hc_name :=  ;
9107: LD_ADDR_OWVAR 26
9111: PUSH
9112: LD_STRING 
9114: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
9115: LD_INT 1
9117: PPUSH
9118: LD_INT 11
9120: PPUSH
9121: LD_INT 10
9123: PPUSH
9124: CALL_OW 380
// un := CreateHuman ;
9128: LD_ADDR_VAR 0 1
9132: PUSH
9133: CALL_OW 44
9137: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9138: LD_VAR 0 1
9142: PPUSH
9143: LD_INT 1
9145: PPUSH
9146: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9150: LD_INT 35
9152: PPUSH
9153: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9157: LD_VAR 0 1
9161: PPUSH
9162: LD_INT 22
9164: PUSH
9165: LD_OWVAR 2
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PPUSH
9174: CALL_OW 69
9178: PPUSH
9179: LD_VAR 0 1
9183: PPUSH
9184: CALL_OW 74
9188: PPUSH
9189: CALL_OW 115
// until IsDead ( un ) ;
9193: LD_VAR 0 1
9197: PPUSH
9198: CALL_OW 301
9202: IFFALSE 9150
// end ;
9204: PPOPN 1
9206: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
9207: LD_EXP 17
9211: PUSH
9212: LD_EXP 57
9216: AND
9217: IFFALSE 9229
9219: GO 9221
9221: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
9222: LD_STRING earthquake(getX(game), 0, 32)
9224: PPUSH
9225: CALL_OW 559
9229: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
9230: LD_EXP 17
9234: PUSH
9235: LD_EXP 58
9239: AND
9240: IFFALSE 9331
9242: GO 9244
9244: DISABLE
9245: LD_INT 0
9247: PPUSH
// begin enable ;
9248: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
9249: LD_ADDR_VAR 0 1
9253: PUSH
9254: LD_INT 22
9256: PUSH
9257: LD_OWVAR 2
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: PUSH
9266: LD_INT 21
9268: PUSH
9269: LD_INT 2
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PUSH
9276: LD_INT 33
9278: PUSH
9279: LD_INT 3
9281: PUSH
9282: EMPTY
9283: LIST
9284: LIST
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: LIST
9290: PPUSH
9291: CALL_OW 69
9295: ST_TO_ADDR
// if not tmp then
9296: LD_VAR 0 1
9300: NOT
9301: IFFALSE 9305
// exit ;
9303: GO 9331
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
9305: LD_VAR 0 1
9309: PUSH
9310: LD_INT 1
9312: PPUSH
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 12
9322: ARRAY
9323: PPUSH
9324: LD_INT 1
9326: PPUSH
9327: CALL_OW 234
// end ;
9331: PPOPN 1
9333: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
9334: LD_EXP 17
9338: PUSH
9339: LD_EXP 59
9343: AND
9344: IFFALSE 9485
9346: GO 9348
9348: DISABLE
9349: LD_INT 0
9351: PPUSH
9352: PPUSH
9353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9354: LD_ADDR_VAR 0 3
9358: PUSH
9359: LD_INT 22
9361: PUSH
9362: LD_OWVAR 2
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: PUSH
9371: LD_INT 25
9373: PUSH
9374: LD_INT 1
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PPUSH
9385: CALL_OW 69
9389: ST_TO_ADDR
// if not tmp then
9390: LD_VAR 0 3
9394: NOT
9395: IFFALSE 9399
// exit ;
9397: GO 9485
// un := tmp [ rand ( 1 , tmp ) ] ;
9399: LD_ADDR_VAR 0 2
9403: PUSH
9404: LD_VAR 0 3
9408: PUSH
9409: LD_INT 1
9411: PPUSH
9412: LD_VAR 0 3
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: ST_TO_ADDR
// if Crawls ( un ) then
9423: LD_VAR 0 2
9427: PPUSH
9428: CALL_OW 318
9432: IFFALSE 9443
// ComWalk ( un ) ;
9434: LD_VAR 0 2
9438: PPUSH
9439: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
9443: LD_VAR 0 2
9447: PPUSH
9448: LD_INT 9
9450: PPUSH
9451: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
9455: LD_INT 28
9457: PPUSH
9458: LD_OWVAR 2
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
9470: LD_INT 29
9472: PPUSH
9473: LD_OWVAR 2
9477: PPUSH
9478: LD_INT 2
9480: PPUSH
9481: CALL_OW 322
// end ;
9485: PPOPN 3
9487: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
9488: LD_EXP 17
9492: PUSH
9493: LD_EXP 60
9497: AND
9498: IFFALSE 9609
9500: GO 9502
9502: DISABLE
9503: LD_INT 0
9505: PPUSH
9506: PPUSH
9507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9508: LD_ADDR_VAR 0 3
9512: PUSH
9513: LD_INT 22
9515: PUSH
9516: LD_OWVAR 2
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 25
9527: PUSH
9528: LD_INT 1
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PPUSH
9539: CALL_OW 69
9543: ST_TO_ADDR
// if not tmp then
9544: LD_VAR 0 3
9548: NOT
9549: IFFALSE 9553
// exit ;
9551: GO 9609
// un := tmp [ rand ( 1 , tmp ) ] ;
9553: LD_ADDR_VAR 0 2
9557: PUSH
9558: LD_VAR 0 3
9562: PUSH
9563: LD_INT 1
9565: PPUSH
9566: LD_VAR 0 3
9570: PPUSH
9571: CALL_OW 12
9575: ARRAY
9576: ST_TO_ADDR
// if Crawls ( un ) then
9577: LD_VAR 0 2
9581: PPUSH
9582: CALL_OW 318
9586: IFFALSE 9597
// ComWalk ( un ) ;
9588: LD_VAR 0 2
9592: PPUSH
9593: CALL_OW 138
// SetClass ( un , class_mortar ) ;
9597: LD_VAR 0 2
9601: PPUSH
9602: LD_INT 8
9604: PPUSH
9605: CALL_OW 336
// end ;
9609: PPOPN 3
9611: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
9612: LD_EXP 17
9616: PUSH
9617: LD_EXP 61
9621: AND
9622: IFFALSE 9766
9624: GO 9626
9626: DISABLE
9627: LD_INT 0
9629: PPUSH
9630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
9631: LD_ADDR_VAR 0 2
9635: PUSH
9636: LD_INT 22
9638: PUSH
9639: LD_OWVAR 2
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 21
9650: PUSH
9651: LD_INT 2
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 2
9660: PUSH
9661: LD_INT 34
9663: PUSH
9664: LD_INT 12
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PUSH
9671: LD_INT 34
9673: PUSH
9674: LD_INT 51
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PUSH
9681: LD_INT 34
9683: PUSH
9684: LD_INT 32
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 69
9706: ST_TO_ADDR
// if not tmp then
9707: LD_VAR 0 2
9711: NOT
9712: IFFALSE 9716
// exit ;
9714: GO 9766
// for i in tmp do
9716: LD_ADDR_VAR 0 1
9720: PUSH
9721: LD_VAR 0 2
9725: PUSH
9726: FOR_IN
9727: IFFALSE 9764
// if GetCargo ( i , mat_artifact ) = 0 then
9729: LD_VAR 0 1
9733: PPUSH
9734: LD_INT 4
9736: PPUSH
9737: CALL_OW 289
9741: PUSH
9742: LD_INT 0
9744: EQUAL
9745: IFFALSE 9762
// SetCargo ( i , mat_siberit , 100 ) ;
9747: LD_VAR 0 1
9751: PPUSH
9752: LD_INT 3
9754: PPUSH
9755: LD_INT 100
9757: PPUSH
9758: CALL_OW 290
9762: GO 9726
9764: POP
9765: POP
// end ;
9766: PPOPN 2
9768: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
9769: LD_EXP 17
9773: PUSH
9774: LD_EXP 62
9778: AND
9779: IFFALSE 9962
9781: GO 9783
9783: DISABLE
9784: LD_INT 0
9786: PPUSH
9787: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
9788: LD_ADDR_VAR 0 2
9792: PUSH
9793: LD_INT 22
9795: PUSH
9796: LD_OWVAR 2
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PPUSH
9805: CALL_OW 69
9809: ST_TO_ADDR
// if not tmp then
9810: LD_VAR 0 2
9814: NOT
9815: IFFALSE 9819
// exit ;
9817: GO 9962
// for i := 1 to 2 do
9819: LD_ADDR_VAR 0 1
9823: PUSH
9824: DOUBLE
9825: LD_INT 1
9827: DEC
9828: ST_TO_ADDR
9829: LD_INT 2
9831: PUSH
9832: FOR_TO
9833: IFFALSE 9960
// begin uc_side := your_side ;
9835: LD_ADDR_OWVAR 20
9839: PUSH
9840: LD_OWVAR 2
9844: ST_TO_ADDR
// uc_nation := nation_american ;
9845: LD_ADDR_OWVAR 21
9849: PUSH
9850: LD_INT 1
9852: ST_TO_ADDR
// vc_chassis := us_morphling ;
9853: LD_ADDR_OWVAR 37
9857: PUSH
9858: LD_INT 5
9860: ST_TO_ADDR
// vc_engine := engine_siberite ;
9861: LD_ADDR_OWVAR 39
9865: PUSH
9866: LD_INT 3
9868: ST_TO_ADDR
// vc_control := control_computer ;
9869: LD_ADDR_OWVAR 38
9873: PUSH
9874: LD_INT 3
9876: ST_TO_ADDR
// vc_weapon := us_double_laser ;
9877: LD_ADDR_OWVAR 40
9881: PUSH
9882: LD_INT 10
9884: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
9885: LD_VAR 0 2
9889: PUSH
9890: LD_INT 1
9892: ARRAY
9893: PPUSH
9894: CALL_OW 310
9898: NOT
9899: IFFALSE 9946
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
9901: CALL_OW 45
9905: PPUSH
9906: LD_VAR 0 2
9910: PUSH
9911: LD_INT 1
9913: ARRAY
9914: PPUSH
9915: CALL_OW 250
9919: PPUSH
9920: LD_VAR 0 2
9924: PUSH
9925: LD_INT 1
9927: ARRAY
9928: PPUSH
9929: CALL_OW 251
9933: PPUSH
9934: LD_INT 12
9936: PPUSH
9937: LD_INT 1
9939: PPUSH
9940: CALL_OW 50
9944: GO 9958
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
9946: CALL_OW 45
9950: PPUSH
9951: LD_INT 1
9953: PPUSH
9954: CALL_OW 51
// end ;
9958: GO 9832
9960: POP
9961: POP
// end ;
9962: PPOPN 2
9964: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
9965: LD_EXP 17
9969: PUSH
9970: LD_EXP 63
9974: AND
9975: IFFALSE 10197
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
9986: PPUSH
9987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9988: LD_ADDR_VAR 0 6
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_OWVAR 2
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: PUSH
10005: LD_INT 21
10007: PUSH
10008: LD_INT 1
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PUSH
10015: LD_INT 3
10017: PUSH
10018: LD_INT 23
10020: PUSH
10021: LD_INT 0
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 69
10041: ST_TO_ADDR
// if not tmp then
10042: LD_VAR 0 6
10046: NOT
10047: IFFALSE 10051
// exit ;
10049: GO 10197
// s1 := rand ( 1 , 4 ) ;
10051: LD_ADDR_VAR 0 2
10055: PUSH
10056: LD_INT 1
10058: PPUSH
10059: LD_INT 4
10061: PPUSH
10062: CALL_OW 12
10066: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
10067: LD_ADDR_VAR 0 4
10071: PUSH
10072: LD_VAR 0 6
10076: PUSH
10077: LD_INT 1
10079: ARRAY
10080: PPUSH
10081: LD_VAR 0 2
10085: PPUSH
10086: CALL_OW 259
10090: ST_TO_ADDR
// if s1 = 1 then
10091: LD_VAR 0 2
10095: PUSH
10096: LD_INT 1
10098: EQUAL
10099: IFFALSE 10119
// s2 := rand ( 2 , 4 ) else
10101: LD_ADDR_VAR 0 3
10105: PUSH
10106: LD_INT 2
10108: PPUSH
10109: LD_INT 4
10111: PPUSH
10112: CALL_OW 12
10116: ST_TO_ADDR
10117: GO 10127
// s2 := 1 ;
10119: LD_ADDR_VAR 0 3
10123: PUSH
10124: LD_INT 1
10126: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
10127: LD_ADDR_VAR 0 5
10131: PUSH
10132: LD_VAR 0 6
10136: PUSH
10137: LD_INT 1
10139: ARRAY
10140: PPUSH
10141: LD_VAR 0 3
10145: PPUSH
10146: CALL_OW 259
10150: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
10151: LD_VAR 0 6
10155: PUSH
10156: LD_INT 1
10158: ARRAY
10159: PPUSH
10160: LD_VAR 0 2
10164: PPUSH
10165: LD_VAR 0 5
10169: PPUSH
10170: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
10174: LD_VAR 0 6
10178: PUSH
10179: LD_INT 1
10181: ARRAY
10182: PPUSH
10183: LD_VAR 0 3
10187: PPUSH
10188: LD_VAR 0 4
10192: PPUSH
10193: CALL_OW 237
// end ;
10197: PPOPN 6
10199: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
10200: LD_EXP 17
10204: PUSH
10205: LD_EXP 64
10209: AND
10210: IFFALSE 10289
10212: GO 10214
10214: DISABLE
10215: LD_INT 0
10217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
10218: LD_ADDR_VAR 0 1
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_OWVAR 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 30
10237: PUSH
10238: LD_INT 3
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: PPUSH
10249: CALL_OW 69
10253: ST_TO_ADDR
// if not tmp then
10254: LD_VAR 0 1
10258: NOT
10259: IFFALSE 10263
// exit ;
10261: GO 10289
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10263: LD_VAR 0 1
10267: PUSH
10268: LD_INT 1
10270: PPUSH
10271: LD_VAR 0 1
10275: PPUSH
10276: CALL_OW 12
10280: ARRAY
10281: PPUSH
10282: LD_INT 1
10284: PPUSH
10285: CALL_OW 234
// end ;
10289: PPOPN 1
10291: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
10292: LD_EXP 17
10296: PUSH
10297: LD_EXP 65
10301: AND
10302: IFFALSE 10414
10304: GO 10306
10306: DISABLE
10307: LD_INT 0
10309: PPUSH
10310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
10311: LD_ADDR_VAR 0 2
10315: PUSH
10316: LD_INT 22
10318: PUSH
10319: LD_OWVAR 2
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: PUSH
10328: LD_INT 2
10330: PUSH
10331: LD_INT 30
10333: PUSH
10334: LD_INT 27
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: LD_INT 30
10343: PUSH
10344: LD_INT 26
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 30
10353: PUSH
10354: LD_INT 28
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: PUSH
10361: EMPTY
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PPUSH
10371: CALL_OW 69
10375: ST_TO_ADDR
// if not tmp then
10376: LD_VAR 0 2
10380: NOT
10381: IFFALSE 10385
// exit ;
10383: GO 10414
// for i in tmp do
10385: LD_ADDR_VAR 0 1
10389: PUSH
10390: LD_VAR 0 2
10394: PUSH
10395: FOR_IN
10396: IFFALSE 10412
// SetLives ( i , 1 ) ;
10398: LD_VAR 0 1
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: CALL_OW 234
10410: GO 10395
10412: POP
10413: POP
// end ;
10414: PPOPN 2
10416: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
10417: LD_EXP 17
10421: PUSH
10422: LD_EXP 66
10426: AND
10427: IFFALSE 10701
10429: GO 10431
10431: DISABLE
10432: LD_INT 0
10434: PPUSH
10435: PPUSH
10436: PPUSH
// begin i := rand ( 1 , 7 ) ;
10437: LD_ADDR_VAR 0 1
10441: PUSH
10442: LD_INT 1
10444: PPUSH
10445: LD_INT 7
10447: PPUSH
10448: CALL_OW 12
10452: ST_TO_ADDR
// case i of 1 :
10453: LD_VAR 0 1
10457: PUSH
10458: LD_INT 1
10460: DOUBLE
10461: EQUAL
10462: IFTRUE 10466
10464: GO 10476
10466: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
10467: LD_STRING earthquake(getX(game), 0, 32)
10469: PPUSH
10470: CALL_OW 559
10474: GO 10701
10476: LD_INT 2
10478: DOUBLE
10479: EQUAL
10480: IFTRUE 10484
10482: GO 10498
10484: POP
// begin ToLua ( displayStucuk(); ) ;
10485: LD_STRING displayStucuk();
10487: PPUSH
10488: CALL_OW 559
// ResetFog ;
10492: CALL_OW 335
// end ; 3 :
10496: GO 10701
10498: LD_INT 3
10500: DOUBLE
10501: EQUAL
10502: IFTRUE 10506
10504: GO 10610
10506: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10507: LD_ADDR_VAR 0 2
10511: PUSH
10512: LD_INT 22
10514: PUSH
10515: LD_OWVAR 2
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 25
10526: PUSH
10527: LD_INT 1
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL_OW 69
10542: ST_TO_ADDR
// if not tmp then
10543: LD_VAR 0 2
10547: NOT
10548: IFFALSE 10552
// exit ;
10550: GO 10701
// un := tmp [ rand ( 1 , tmp ) ] ;
10552: LD_ADDR_VAR 0 3
10556: PUSH
10557: LD_VAR 0 2
10561: PUSH
10562: LD_INT 1
10564: PPUSH
10565: LD_VAR 0 2
10569: PPUSH
10570: CALL_OW 12
10574: ARRAY
10575: ST_TO_ADDR
// if Crawls ( un ) then
10576: LD_VAR 0 3
10580: PPUSH
10581: CALL_OW 318
10585: IFFALSE 10596
// ComWalk ( un ) ;
10587: LD_VAR 0 3
10591: PPUSH
10592: CALL_OW 138
// SetClass ( un , class_mortar ) ;
10596: LD_VAR 0 3
10600: PPUSH
10601: LD_INT 8
10603: PPUSH
10604: CALL_OW 336
// end ; 4 :
10608: GO 10701
10610: LD_INT 4
10612: DOUBLE
10613: EQUAL
10614: IFTRUE 10618
10616: GO 10679
10618: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: LD_INT 22
10626: PUSH
10627: LD_OWVAR 2
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PUSH
10636: LD_INT 30
10638: PUSH
10639: LD_INT 29
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: ST_TO_ADDR
// if not tmp then
10655: LD_VAR 0 2
10659: NOT
10660: IFFALSE 10664
// exit ;
10662: GO 10701
// DestroyUnit ( tmp [ 1 ] ) ;
10664: LD_VAR 0 2
10668: PUSH
10669: LD_INT 1
10671: ARRAY
10672: PPUSH
10673: CALL_OW 65
// end ; 5 .. 7 :
10677: GO 10701
10679: LD_INT 5
10681: DOUBLE
10682: GREATEREQUAL
10683: IFFALSE 10691
10685: LD_INT 7
10687: DOUBLE
10688: LESSEQUAL
10689: IFTRUE 10693
10691: GO 10700
10693: POP
// StreamSibBomb ; end ;
10694: CALL 6951 0 0
10698: GO 10701
10700: POP
// end ;
10701: PPOPN 3
10703: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
10704: LD_EXP 17
10708: PUSH
10709: LD_EXP 67
10713: AND
10714: IFFALSE 10870
10716: GO 10718
10718: DISABLE
10719: LD_INT 0
10721: PPUSH
10722: PPUSH
10723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10724: LD_ADDR_VAR 0 2
10728: PUSH
10729: LD_INT 81
10731: PUSH
10732: LD_OWVAR 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 2
10743: PUSH
10744: LD_INT 21
10746: PUSH
10747: LD_INT 1
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: LD_INT 21
10756: PUSH
10757: LD_INT 2
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PPUSH
10773: CALL_OW 69
10777: ST_TO_ADDR
// if not tmp then
10778: LD_VAR 0 2
10782: NOT
10783: IFFALSE 10787
// exit ;
10785: GO 10870
// p := 0 ;
10787: LD_ADDR_VAR 0 3
10791: PUSH
10792: LD_INT 0
10794: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10795: LD_INT 35
10797: PPUSH
10798: CALL_OW 67
// p := p + 1 ;
10802: LD_ADDR_VAR 0 3
10806: PUSH
10807: LD_VAR 0 3
10811: PUSH
10812: LD_INT 1
10814: PLUS
10815: ST_TO_ADDR
// for i in tmp do
10816: LD_ADDR_VAR 0 1
10820: PUSH
10821: LD_VAR 0 2
10825: PUSH
10826: FOR_IN
10827: IFFALSE 10858
// if GetLives ( i ) < 1000 then
10829: LD_VAR 0 1
10833: PPUSH
10834: CALL_OW 256
10838: PUSH
10839: LD_INT 1000
10841: LESS
10842: IFFALSE 10856
// SetLives ( i , 1000 ) ;
10844: LD_VAR 0 1
10848: PPUSH
10849: LD_INT 1000
10851: PPUSH
10852: CALL_OW 234
10856: GO 10826
10858: POP
10859: POP
// until p > 20 ;
10860: LD_VAR 0 3
10864: PUSH
10865: LD_INT 20
10867: GREATER
10868: IFFALSE 10795
// end ;
10870: PPOPN 3
10872: END
// every 0 0$1 trigger StreamModeActive and sTime do
10873: LD_EXP 17
10877: PUSH
10878: LD_EXP 68
10882: AND
10883: IFFALSE 10918
10885: GO 10887
10887: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
10888: LD_INT 28
10890: PPUSH
10891: LD_OWVAR 2
10895: PPUSH
10896: LD_INT 2
10898: PPUSH
10899: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
10903: LD_INT 30
10905: PPUSH
10906: LD_OWVAR 2
10910: PPUSH
10911: LD_INT 2
10913: PPUSH
10914: CALL_OW 322
// end ;
10918: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
10919: LD_EXP 17
10923: PUSH
10924: LD_EXP 69
10928: AND
10929: IFFALSE 11050
10931: GO 10933
10933: DISABLE
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10938: LD_ADDR_VAR 0 2
10942: PUSH
10943: LD_INT 22
10945: PUSH
10946: LD_OWVAR 2
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 21
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: LD_INT 23
10970: PUSH
10971: LD_INT 0
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: LIST
10986: PPUSH
10987: CALL_OW 69
10991: ST_TO_ADDR
// if not tmp then
10992: LD_VAR 0 2
10996: NOT
10997: IFFALSE 11001
// exit ;
10999: GO 11050
// for i in tmp do
11001: LD_ADDR_VAR 0 1
11005: PUSH
11006: LD_VAR 0 2
11010: PUSH
11011: FOR_IN
11012: IFFALSE 11048
// begin if Crawls ( i ) then
11014: LD_VAR 0 1
11018: PPUSH
11019: CALL_OW 318
11023: IFFALSE 11034
// ComWalk ( i ) ;
11025: LD_VAR 0 1
11029: PPUSH
11030: CALL_OW 138
// SetClass ( i , 2 ) ;
11034: LD_VAR 0 1
11038: PPUSH
11039: LD_INT 2
11041: PPUSH
11042: CALL_OW 336
// end ;
11046: GO 11011
11048: POP
11049: POP
// end ;
11050: PPOPN 2
11052: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
11053: LD_EXP 17
11057: PUSH
11058: LD_EXP 70
11062: AND
11063: IFFALSE 11344
11065: GO 11067
11067: DISABLE
11068: LD_INT 0
11070: PPUSH
11071: PPUSH
11072: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
11073: LD_OWVAR 2
11077: PPUSH
11078: LD_INT 9
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: LD_INT 1
11086: PPUSH
11087: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
11091: LD_INT 9
11093: PPUSH
11094: LD_OWVAR 2
11098: PPUSH
11099: CALL_OW 343
// uc_side := 9 ;
11103: LD_ADDR_OWVAR 20
11107: PUSH
11108: LD_INT 9
11110: ST_TO_ADDR
// uc_nation := 2 ;
11111: LD_ADDR_OWVAR 21
11115: PUSH
11116: LD_INT 2
11118: ST_TO_ADDR
// hc_name := Dark Warrior ;
11119: LD_ADDR_OWVAR 26
11123: PUSH
11124: LD_STRING Dark Warrior
11126: ST_TO_ADDR
// hc_gallery :=  ;
11127: LD_ADDR_OWVAR 33
11131: PUSH
11132: LD_STRING 
11134: ST_TO_ADDR
// hc_noskilllimit := true ;
11135: LD_ADDR_OWVAR 76
11139: PUSH
11140: LD_INT 1
11142: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
11143: LD_ADDR_OWVAR 31
11147: PUSH
11148: LD_INT 30
11150: PUSH
11151: LD_INT 30
11153: PUSH
11154: LD_INT 30
11156: PUSH
11157: LD_INT 30
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: ST_TO_ADDR
// un := CreateHuman ;
11166: LD_ADDR_VAR 0 3
11170: PUSH
11171: CALL_OW 44
11175: ST_TO_ADDR
// hc_noskilllimit := false ;
11176: LD_ADDR_OWVAR 76
11180: PUSH
11181: LD_INT 0
11183: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11184: LD_VAR 0 3
11188: PPUSH
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 51
// p := 0 ;
11196: LD_ADDR_VAR 0 2
11200: PUSH
11201: LD_INT 0
11203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11204: LD_INT 35
11206: PPUSH
11207: CALL_OW 67
// p := p + 1 ;
11211: LD_ADDR_VAR 0 2
11215: PUSH
11216: LD_VAR 0 2
11220: PUSH
11221: LD_INT 1
11223: PLUS
11224: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
11225: LD_VAR 0 3
11229: PPUSH
11230: CALL_OW 256
11234: PUSH
11235: LD_INT 1000
11237: LESS
11238: IFFALSE 11252
// SetLives ( un , 1000 ) ;
11240: LD_VAR 0 3
11244: PPUSH
11245: LD_INT 1000
11247: PPUSH
11248: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
11252: LD_VAR 0 3
11256: PPUSH
11257: LD_INT 81
11259: PUSH
11260: LD_OWVAR 2
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PUSH
11269: LD_INT 91
11271: PUSH
11272: LD_VAR 0 3
11276: PUSH
11277: LD_INT 30
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: LIST
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: PPUSH
11289: CALL_OW 69
11293: PPUSH
11294: LD_VAR 0 3
11298: PPUSH
11299: CALL_OW 74
11303: PPUSH
11304: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
11308: LD_VAR 0 2
11312: PUSH
11313: LD_INT 60
11315: GREATER
11316: PUSH
11317: LD_VAR 0 3
11321: PPUSH
11322: CALL_OW 301
11326: OR
11327: IFFALSE 11204
// if un then
11329: LD_VAR 0 3
11333: IFFALSE 11344
// RemoveUnit ( un ) ;
11335: LD_VAR 0 3
11339: PPUSH
11340: CALL_OW 64
// end ;
11344: PPOPN 3
11346: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
11347: LD_INT 0
11349: PPUSH
// case cmd of 301 :
11350: LD_VAR 0 1
11354: PUSH
11355: LD_INT 301
11357: DOUBLE
11358: EQUAL
11359: IFTRUE 11363
11361: GO 11395
11363: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
11364: LD_VAR 0 6
11368: PPUSH
11369: LD_VAR 0 7
11373: PPUSH
11374: LD_VAR 0 8
11378: PPUSH
11379: LD_VAR 0 4
11383: PPUSH
11384: LD_VAR 0 5
11388: PPUSH
11389: CALL 12596 0 5
11393: GO 11516
11395: LD_INT 302
11397: DOUBLE
11398: EQUAL
11399: IFTRUE 11403
11401: GO 11440
11403: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
11404: LD_VAR 0 6
11408: PPUSH
11409: LD_VAR 0 7
11413: PPUSH
11414: LD_VAR 0 8
11418: PPUSH
11419: LD_VAR 0 9
11423: PPUSH
11424: LD_VAR 0 4
11428: PPUSH
11429: LD_VAR 0 5
11433: PPUSH
11434: CALL 12687 0 6
11438: GO 11516
11440: LD_INT 303
11442: DOUBLE
11443: EQUAL
11444: IFTRUE 11448
11446: GO 11485
11448: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
11449: LD_VAR 0 6
11453: PPUSH
11454: LD_VAR 0 7
11458: PPUSH
11459: LD_VAR 0 8
11463: PPUSH
11464: LD_VAR 0 9
11468: PPUSH
11469: LD_VAR 0 4
11473: PPUSH
11474: LD_VAR 0 5
11478: PPUSH
11479: CALL 11521 0 6
11483: GO 11516
11485: LD_INT 304
11487: DOUBLE
11488: EQUAL
11489: IFTRUE 11493
11491: GO 11515
11493: POP
// hHackTeleport ( unit , x , y ) ; end ;
11494: LD_VAR 0 2
11498: PPUSH
11499: LD_VAR 0 4
11503: PPUSH
11504: LD_VAR 0 5
11508: PPUSH
11509: CALL 13280 0 3
11513: GO 11516
11515: POP
// end ;
11516: LD_VAR 0 12
11520: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
11521: LD_INT 0
11523: PPUSH
11524: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
11525: LD_VAR 0 1
11529: PUSH
11530: LD_INT 1
11532: LESS
11533: PUSH
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 3
11541: GREATER
11542: OR
11543: PUSH
11544: LD_VAR 0 5
11548: PPUSH
11549: LD_VAR 0 6
11553: PPUSH
11554: CALL_OW 428
11558: OR
11559: IFFALSE 11563
// exit ;
11561: GO 12283
// uc_side := your_side ;
11563: LD_ADDR_OWVAR 20
11567: PUSH
11568: LD_OWVAR 2
11572: ST_TO_ADDR
// uc_nation := nation ;
11573: LD_ADDR_OWVAR 21
11577: PUSH
11578: LD_VAR 0 1
11582: ST_TO_ADDR
// bc_level = 1 ;
11583: LD_ADDR_OWVAR 43
11587: PUSH
11588: LD_INT 1
11590: ST_TO_ADDR
// case btype of 1 :
11591: LD_VAR 0 2
11595: PUSH
11596: LD_INT 1
11598: DOUBLE
11599: EQUAL
11600: IFTRUE 11604
11602: GO 11615
11604: POP
// bc_type := b_depot ; 2 :
11605: LD_ADDR_OWVAR 42
11609: PUSH
11610: LD_INT 0
11612: ST_TO_ADDR
11613: GO 12227
11615: LD_INT 2
11617: DOUBLE
11618: EQUAL
11619: IFTRUE 11623
11621: GO 11634
11623: POP
// bc_type := b_warehouse ; 3 :
11624: LD_ADDR_OWVAR 42
11628: PUSH
11629: LD_INT 1
11631: ST_TO_ADDR
11632: GO 12227
11634: LD_INT 3
11636: DOUBLE
11637: EQUAL
11638: IFTRUE 11642
11640: GO 11653
11642: POP
// bc_type := b_lab ; 4 .. 9 :
11643: LD_ADDR_OWVAR 42
11647: PUSH
11648: LD_INT 6
11650: ST_TO_ADDR
11651: GO 12227
11653: LD_INT 4
11655: DOUBLE
11656: GREATEREQUAL
11657: IFFALSE 11665
11659: LD_INT 9
11661: DOUBLE
11662: LESSEQUAL
11663: IFTRUE 11667
11665: GO 11719
11667: POP
// begin bc_type := b_lab_half ;
11668: LD_ADDR_OWVAR 42
11672: PUSH
11673: LD_INT 7
11675: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
11676: LD_ADDR_OWVAR 44
11680: PUSH
11681: LD_INT 10
11683: PUSH
11684: LD_INT 11
11686: PUSH
11687: LD_INT 12
11689: PUSH
11690: LD_INT 15
11692: PUSH
11693: LD_INT 14
11695: PUSH
11696: LD_INT 13
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: PUSH
11707: LD_VAR 0 2
11711: PUSH
11712: LD_INT 3
11714: MINUS
11715: ARRAY
11716: ST_TO_ADDR
// end ; 10 .. 13 :
11717: GO 12227
11719: LD_INT 10
11721: DOUBLE
11722: GREATEREQUAL
11723: IFFALSE 11731
11725: LD_INT 13
11727: DOUBLE
11728: LESSEQUAL
11729: IFTRUE 11733
11731: GO 11810
11733: POP
// begin bc_type := b_lab_full ;
11734: LD_ADDR_OWVAR 42
11738: PUSH
11739: LD_INT 8
11741: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
11742: LD_ADDR_OWVAR 44
11746: PUSH
11747: LD_INT 10
11749: PUSH
11750: LD_INT 12
11752: PUSH
11753: LD_INT 14
11755: PUSH
11756: LD_INT 13
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: PUSH
11765: LD_VAR 0 2
11769: PUSH
11770: LD_INT 9
11772: MINUS
11773: ARRAY
11774: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
11775: LD_ADDR_OWVAR 45
11779: PUSH
11780: LD_INT 11
11782: PUSH
11783: LD_INT 15
11785: PUSH
11786: LD_INT 12
11788: PUSH
11789: LD_INT 15
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: PUSH
11798: LD_VAR 0 2
11802: PUSH
11803: LD_INT 9
11805: MINUS
11806: ARRAY
11807: ST_TO_ADDR
// end ; 14 :
11808: GO 12227
11810: LD_INT 14
11812: DOUBLE
11813: EQUAL
11814: IFTRUE 11818
11816: GO 11829
11818: POP
// bc_type := b_workshop ; 15 :
11819: LD_ADDR_OWVAR 42
11823: PUSH
11824: LD_INT 2
11826: ST_TO_ADDR
11827: GO 12227
11829: LD_INT 15
11831: DOUBLE
11832: EQUAL
11833: IFTRUE 11837
11835: GO 11848
11837: POP
// bc_type := b_factory ; 16 :
11838: LD_ADDR_OWVAR 42
11842: PUSH
11843: LD_INT 3
11845: ST_TO_ADDR
11846: GO 12227
11848: LD_INT 16
11850: DOUBLE
11851: EQUAL
11852: IFTRUE 11856
11854: GO 11867
11856: POP
// bc_type := b_ext_gun ; 17 :
11857: LD_ADDR_OWVAR 42
11861: PUSH
11862: LD_INT 17
11864: ST_TO_ADDR
11865: GO 12227
11867: LD_INT 17
11869: DOUBLE
11870: EQUAL
11871: IFTRUE 11875
11873: GO 11903
11875: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
11876: LD_ADDR_OWVAR 42
11880: PUSH
11881: LD_INT 19
11883: PUSH
11884: LD_INT 23
11886: PUSH
11887: LD_INT 19
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: LIST
11894: PUSH
11895: LD_VAR 0 1
11899: ARRAY
11900: ST_TO_ADDR
11901: GO 12227
11903: LD_INT 18
11905: DOUBLE
11906: EQUAL
11907: IFTRUE 11911
11909: GO 11922
11911: POP
// bc_type := b_ext_radar ; 19 :
11912: LD_ADDR_OWVAR 42
11916: PUSH
11917: LD_INT 20
11919: ST_TO_ADDR
11920: GO 12227
11922: LD_INT 19
11924: DOUBLE
11925: EQUAL
11926: IFTRUE 11930
11928: GO 11941
11930: POP
// bc_type := b_ext_radio ; 20 :
11931: LD_ADDR_OWVAR 42
11935: PUSH
11936: LD_INT 22
11938: ST_TO_ADDR
11939: GO 12227
11941: LD_INT 20
11943: DOUBLE
11944: EQUAL
11945: IFTRUE 11949
11947: GO 11960
11949: POP
// bc_type := b_ext_siberium ; 21 :
11950: LD_ADDR_OWVAR 42
11954: PUSH
11955: LD_INT 21
11957: ST_TO_ADDR
11958: GO 12227
11960: LD_INT 21
11962: DOUBLE
11963: EQUAL
11964: IFTRUE 11968
11966: GO 11979
11968: POP
// bc_type := b_ext_computer ; 22 :
11969: LD_ADDR_OWVAR 42
11973: PUSH
11974: LD_INT 24
11976: ST_TO_ADDR
11977: GO 12227
11979: LD_INT 22
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// bc_type := b_ext_track ; 23 :
11988: LD_ADDR_OWVAR 42
11992: PUSH
11993: LD_INT 16
11995: ST_TO_ADDR
11996: GO 12227
11998: LD_INT 23
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// bc_type := b_ext_laser ; 24 :
12007: LD_ADDR_OWVAR 42
12011: PUSH
12012: LD_INT 25
12014: ST_TO_ADDR
12015: GO 12227
12017: LD_INT 24
12019: DOUBLE
12020: EQUAL
12021: IFTRUE 12025
12023: GO 12036
12025: POP
// bc_type := b_control_tower ; 25 :
12026: LD_ADDR_OWVAR 42
12030: PUSH
12031: LD_INT 36
12033: ST_TO_ADDR
12034: GO 12227
12036: LD_INT 25
12038: DOUBLE
12039: EQUAL
12040: IFTRUE 12044
12042: GO 12055
12044: POP
// bc_type := b_breastwork ; 26 :
12045: LD_ADDR_OWVAR 42
12049: PUSH
12050: LD_INT 31
12052: ST_TO_ADDR
12053: GO 12227
12055: LD_INT 26
12057: DOUBLE
12058: EQUAL
12059: IFTRUE 12063
12061: GO 12074
12063: POP
// bc_type := b_bunker ; 27 :
12064: LD_ADDR_OWVAR 42
12068: PUSH
12069: LD_INT 32
12071: ST_TO_ADDR
12072: GO 12227
12074: LD_INT 27
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12093
12082: POP
// bc_type := b_turret ; 28 :
12083: LD_ADDR_OWVAR 42
12087: PUSH
12088: LD_INT 33
12090: ST_TO_ADDR
12091: GO 12227
12093: LD_INT 28
12095: DOUBLE
12096: EQUAL
12097: IFTRUE 12101
12099: GO 12112
12101: POP
// bc_type := b_armoury ; 29 :
12102: LD_ADDR_OWVAR 42
12106: PUSH
12107: LD_INT 4
12109: ST_TO_ADDR
12110: GO 12227
12112: LD_INT 29
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12120
12118: GO 12131
12120: POP
// bc_type := b_barracks ; 30 :
12121: LD_ADDR_OWVAR 42
12125: PUSH
12126: LD_INT 5
12128: ST_TO_ADDR
12129: GO 12227
12131: LD_INT 30
12133: DOUBLE
12134: EQUAL
12135: IFTRUE 12139
12137: GO 12150
12139: POP
// bc_type := b_solar_power ; 31 :
12140: LD_ADDR_OWVAR 42
12144: PUSH
12145: LD_INT 27
12147: ST_TO_ADDR
12148: GO 12227
12150: LD_INT 31
12152: DOUBLE
12153: EQUAL
12154: IFTRUE 12158
12156: GO 12169
12158: POP
// bc_type := b_oil_power ; 32 :
12159: LD_ADDR_OWVAR 42
12163: PUSH
12164: LD_INT 26
12166: ST_TO_ADDR
12167: GO 12227
12169: LD_INT 32
12171: DOUBLE
12172: EQUAL
12173: IFTRUE 12177
12175: GO 12188
12177: POP
// bc_type := b_siberite_power ; 33 :
12178: LD_ADDR_OWVAR 42
12182: PUSH
12183: LD_INT 28
12185: ST_TO_ADDR
12186: GO 12227
12188: LD_INT 33
12190: DOUBLE
12191: EQUAL
12192: IFTRUE 12196
12194: GO 12207
12196: POP
// bc_type := b_oil_mine ; 34 :
12197: LD_ADDR_OWVAR 42
12201: PUSH
12202: LD_INT 29
12204: ST_TO_ADDR
12205: GO 12227
12207: LD_INT 34
12209: DOUBLE
12210: EQUAL
12211: IFTRUE 12215
12213: GO 12226
12215: POP
// bc_type := b_siberite_mine ; end ;
12216: LD_ADDR_OWVAR 42
12220: PUSH
12221: LD_INT 30
12223: ST_TO_ADDR
12224: GO 12227
12226: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
12227: LD_ADDR_VAR 0 8
12231: PUSH
12232: LD_VAR 0 5
12236: PPUSH
12237: LD_VAR 0 6
12241: PPUSH
12242: LD_VAR 0 3
12246: PPUSH
12247: CALL_OW 47
12251: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
12252: LD_OWVAR 42
12256: PUSH
12257: LD_INT 32
12259: PUSH
12260: LD_INT 33
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: IN
12267: IFFALSE 12283
// PlaceWeaponTurret ( b , weapon ) ;
12269: LD_VAR 0 8
12273: PPUSH
12274: LD_VAR 0 4
12278: PPUSH
12279: CALL_OW 431
// end ;
12283: LD_VAR 0 7
12287: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
12288: LD_INT 0
12290: PPUSH
12291: PPUSH
12292: PPUSH
12293: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12294: LD_ADDR_VAR 0 4
12298: PUSH
12299: LD_INT 22
12301: PUSH
12302: LD_OWVAR 2
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: LD_INT 30
12316: PUSH
12317: LD_INT 0
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PUSH
12324: LD_INT 30
12326: PUSH
12327: LD_INT 1
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: LIST
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PPUSH
12343: CALL_OW 69
12347: ST_TO_ADDR
// if not tmp then
12348: LD_VAR 0 4
12352: NOT
12353: IFFALSE 12357
// exit ;
12355: GO 12416
// for i in tmp do
12357: LD_ADDR_VAR 0 2
12361: PUSH
12362: LD_VAR 0 4
12366: PUSH
12367: FOR_IN
12368: IFFALSE 12414
// for j = 1 to 3 do
12370: LD_ADDR_VAR 0 3
12374: PUSH
12375: DOUBLE
12376: LD_INT 1
12378: DEC
12379: ST_TO_ADDR
12380: LD_INT 3
12382: PUSH
12383: FOR_TO
12384: IFFALSE 12410
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
12386: LD_VAR 0 2
12390: PPUSH
12391: CALL_OW 274
12395: PPUSH
12396: LD_VAR 0 3
12400: PPUSH
12401: LD_INT 99999
12403: PPUSH
12404: CALL_OW 277
12408: GO 12383
12410: POP
12411: POP
12412: GO 12367
12414: POP
12415: POP
// end ;
12416: LD_VAR 0 1
12420: RET
// export function hHackSetLevel10 ; var i , j ; begin
12421: LD_INT 0
12423: PPUSH
12424: PPUSH
12425: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
12426: LD_ADDR_VAR 0 2
12430: PUSH
12431: LD_INT 21
12433: PUSH
12434: LD_INT 1
12436: PUSH
12437: EMPTY
12438: LIST
12439: LIST
12440: PPUSH
12441: CALL_OW 69
12445: PUSH
12446: FOR_IN
12447: IFFALSE 12499
// if IsSelected ( i ) then
12449: LD_VAR 0 2
12453: PPUSH
12454: CALL_OW 306
12458: IFFALSE 12497
// begin for j := 1 to 4 do
12460: LD_ADDR_VAR 0 3
12464: PUSH
12465: DOUBLE
12466: LD_INT 1
12468: DEC
12469: ST_TO_ADDR
12470: LD_INT 4
12472: PUSH
12473: FOR_TO
12474: IFFALSE 12495
// SetSkill ( i , j , 10 ) ;
12476: LD_VAR 0 2
12480: PPUSH
12481: LD_VAR 0 3
12485: PPUSH
12486: LD_INT 10
12488: PPUSH
12489: CALL_OW 237
12493: GO 12473
12495: POP
12496: POP
// end ;
12497: GO 12446
12499: POP
12500: POP
// end ;
12501: LD_VAR 0 1
12505: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
12506: LD_INT 0
12508: PPUSH
12509: PPUSH
12510: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
12511: LD_ADDR_VAR 0 2
12515: PUSH
12516: LD_INT 22
12518: PUSH
12519: LD_OWVAR 2
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: PUSH
12528: LD_INT 21
12530: PUSH
12531: LD_INT 1
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PPUSH
12542: CALL_OW 69
12546: PUSH
12547: FOR_IN
12548: IFFALSE 12589
// begin for j := 1 to 4 do
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: DOUBLE
12556: LD_INT 1
12558: DEC
12559: ST_TO_ADDR
12560: LD_INT 4
12562: PUSH
12563: FOR_TO
12564: IFFALSE 12585
// SetSkill ( i , j , 10 ) ;
12566: LD_VAR 0 2
12570: PPUSH
12571: LD_VAR 0 3
12575: PPUSH
12576: LD_INT 10
12578: PPUSH
12579: CALL_OW 237
12583: GO 12563
12585: POP
12586: POP
// end ;
12587: GO 12547
12589: POP
12590: POP
// end ;
12591: LD_VAR 0 1
12595: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
12596: LD_INT 0
12598: PPUSH
// uc_side := your_side ;
12599: LD_ADDR_OWVAR 20
12603: PUSH
12604: LD_OWVAR 2
12608: ST_TO_ADDR
// uc_nation := nation ;
12609: LD_ADDR_OWVAR 21
12613: PUSH
12614: LD_VAR 0 1
12618: ST_TO_ADDR
// InitHc ;
12619: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
12623: LD_INT 0
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PPUSH
12636: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
12640: LD_VAR 0 4
12644: PPUSH
12645: LD_VAR 0 5
12649: PPUSH
12650: CALL_OW 428
12654: PUSH
12655: LD_INT 0
12657: EQUAL
12658: IFFALSE 12682
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
12660: CALL_OW 44
12664: PPUSH
12665: LD_VAR 0 4
12669: PPUSH
12670: LD_VAR 0 5
12674: PPUSH
12675: LD_INT 1
12677: PPUSH
12678: CALL_OW 48
// end ;
12682: LD_VAR 0 6
12686: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
12687: LD_INT 0
12689: PPUSH
12690: PPUSH
// uc_side := your_side ;
12691: LD_ADDR_OWVAR 20
12695: PUSH
12696: LD_OWVAR 2
12700: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
12701: LD_VAR 0 1
12705: PUSH
12706: LD_INT 1
12708: PUSH
12709: LD_INT 2
12711: PUSH
12712: LD_INT 3
12714: PUSH
12715: LD_INT 4
12717: PUSH
12718: LD_INT 5
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: IN
12728: IFFALSE 12740
// uc_nation := nation_american else
12730: LD_ADDR_OWVAR 21
12734: PUSH
12735: LD_INT 1
12737: ST_TO_ADDR
12738: GO 12783
// if chassis in [ 11 , 12 , 13 , 14 ] then
12740: LD_VAR 0 1
12744: PUSH
12745: LD_INT 11
12747: PUSH
12748: LD_INT 12
12750: PUSH
12751: LD_INT 13
12753: PUSH
12754: LD_INT 14
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: IN
12763: IFFALSE 12775
// uc_nation := nation_arabian else
12765: LD_ADDR_OWVAR 21
12769: PUSH
12770: LD_INT 2
12772: ST_TO_ADDR
12773: GO 12783
// uc_nation := nation_russian ;
12775: LD_ADDR_OWVAR 21
12779: PUSH
12780: LD_INT 3
12782: ST_TO_ADDR
// vc_chassis := chassis ;
12783: LD_ADDR_OWVAR 37
12787: PUSH
12788: LD_VAR 0 1
12792: ST_TO_ADDR
// vc_engine := engine ;
12793: LD_ADDR_OWVAR 39
12797: PUSH
12798: LD_VAR 0 2
12802: ST_TO_ADDR
// vc_control := control ;
12803: LD_ADDR_OWVAR 38
12807: PUSH
12808: LD_VAR 0 3
12812: ST_TO_ADDR
// vc_weapon := weapon ;
12813: LD_ADDR_OWVAR 40
12817: PUSH
12818: LD_VAR 0 4
12822: ST_TO_ADDR
// un := CreateVehicle ;
12823: LD_ADDR_VAR 0 8
12827: PUSH
12828: CALL_OW 45
12832: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
12833: LD_VAR 0 8
12837: PPUSH
12838: LD_INT 0
12840: PPUSH
12841: LD_INT 5
12843: PPUSH
12844: CALL_OW 12
12848: PPUSH
12849: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
12853: LD_VAR 0 8
12857: PPUSH
12858: LD_VAR 0 5
12862: PPUSH
12863: LD_VAR 0 6
12867: PPUSH
12868: LD_INT 1
12870: PPUSH
12871: CALL_OW 48
// end ;
12875: LD_VAR 0 7
12879: RET
// export hInvincible ; every 1 do
12880: GO 12882
12882: DISABLE
// hInvincible := [ ] ;
12883: LD_ADDR_EXP 71
12887: PUSH
12888: EMPTY
12889: ST_TO_ADDR
12890: END
// every 10 do var i ;
12891: GO 12893
12893: DISABLE
12894: LD_INT 0
12896: PPUSH
// begin enable ;
12897: ENABLE
// if not hInvincible then
12898: LD_EXP 71
12902: NOT
12903: IFFALSE 12907
// exit ;
12905: GO 12951
// for i in hInvincible do
12907: LD_ADDR_VAR 0 1
12911: PUSH
12912: LD_EXP 71
12916: PUSH
12917: FOR_IN
12918: IFFALSE 12949
// if GetLives ( i ) < 1000 then
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 256
12929: PUSH
12930: LD_INT 1000
12932: LESS
12933: IFFALSE 12947
// SetLives ( i , 1000 ) ;
12935: LD_VAR 0 1
12939: PPUSH
12940: LD_INT 1000
12942: PPUSH
12943: CALL_OW 234
12947: GO 12917
12949: POP
12950: POP
// end ;
12951: PPOPN 1
12953: END
// export function hHackInvincible ; var i ; begin
12954: LD_INT 0
12956: PPUSH
12957: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
12958: LD_ADDR_VAR 0 2
12962: PUSH
12963: LD_INT 2
12965: PUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 21
12978: PUSH
12979: LD_INT 2
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: PPUSH
12991: CALL_OW 69
12995: PUSH
12996: FOR_IN
12997: IFFALSE 13058
// if IsSelected ( i ) then
12999: LD_VAR 0 2
13003: PPUSH
13004: CALL_OW 306
13008: IFFALSE 13056
// begin if i in hInvincible then
13010: LD_VAR 0 2
13014: PUSH
13015: LD_EXP 71
13019: IN
13020: IFFALSE 13040
// hInvincible := hInvincible diff i else
13022: LD_ADDR_EXP 71
13026: PUSH
13027: LD_EXP 71
13031: PUSH
13032: LD_VAR 0 2
13036: DIFF
13037: ST_TO_ADDR
13038: GO 13056
// hInvincible := hInvincible union i ;
13040: LD_ADDR_EXP 71
13044: PUSH
13045: LD_EXP 71
13049: PUSH
13050: LD_VAR 0 2
13054: UNION
13055: ST_TO_ADDR
// end ;
13056: GO 12996
13058: POP
13059: POP
// end ;
13060: LD_VAR 0 1
13064: RET
// export function hHackInvisible ; var i , j ; begin
13065: LD_INT 0
13067: PPUSH
13068: PPUSH
13069: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
13070: LD_ADDR_VAR 0 2
13074: PUSH
13075: LD_INT 21
13077: PUSH
13078: LD_INT 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PPUSH
13085: CALL_OW 69
13089: PUSH
13090: FOR_IN
13091: IFFALSE 13115
// if IsSelected ( i ) then
13093: LD_VAR 0 2
13097: PPUSH
13098: CALL_OW 306
13102: IFFALSE 13113
// ComForceInvisible ( i ) ;
13104: LD_VAR 0 2
13108: PPUSH
13109: CALL_OW 496
13113: GO 13090
13115: POP
13116: POP
// end ;
13117: LD_VAR 0 1
13121: RET
// export function hHackChangeYourSide ; begin
13122: LD_INT 0
13124: PPUSH
// if your_side = 8 then
13125: LD_OWVAR 2
13129: PUSH
13130: LD_INT 8
13132: EQUAL
13133: IFFALSE 13145
// your_side := 0 else
13135: LD_ADDR_OWVAR 2
13139: PUSH
13140: LD_INT 0
13142: ST_TO_ADDR
13143: GO 13159
// your_side := your_side + 1 ;
13145: LD_ADDR_OWVAR 2
13149: PUSH
13150: LD_OWVAR 2
13154: PUSH
13155: LD_INT 1
13157: PLUS
13158: ST_TO_ADDR
// end ;
13159: LD_VAR 0 1
13163: RET
// export function hHackChangeUnitSide ; var i , j ; begin
13164: LD_INT 0
13166: PPUSH
13167: PPUSH
13168: PPUSH
// for i in all_units do
13169: LD_ADDR_VAR 0 2
13173: PUSH
13174: LD_OWVAR 3
13178: PUSH
13179: FOR_IN
13180: IFFALSE 13258
// if IsSelected ( i ) then
13182: LD_VAR 0 2
13186: PPUSH
13187: CALL_OW 306
13191: IFFALSE 13256
// begin j := GetSide ( i ) ;
13193: LD_ADDR_VAR 0 3
13197: PUSH
13198: LD_VAR 0 2
13202: PPUSH
13203: CALL_OW 255
13207: ST_TO_ADDR
// if j = 8 then
13208: LD_VAR 0 3
13212: PUSH
13213: LD_INT 8
13215: EQUAL
13216: IFFALSE 13228
// j := 0 else
13218: LD_ADDR_VAR 0 3
13222: PUSH
13223: LD_INT 0
13225: ST_TO_ADDR
13226: GO 13242
// j := j + 1 ;
13228: LD_ADDR_VAR 0 3
13232: PUSH
13233: LD_VAR 0 3
13237: PUSH
13238: LD_INT 1
13240: PLUS
13241: ST_TO_ADDR
// SetSide ( i , j ) ;
13242: LD_VAR 0 2
13246: PPUSH
13247: LD_VAR 0 3
13251: PPUSH
13252: CALL_OW 235
// end ;
13256: GO 13179
13258: POP
13259: POP
// end ;
13260: LD_VAR 0 1
13264: RET
// export function hHackFog ; begin
13265: LD_INT 0
13267: PPUSH
// FogOff ( true ) ;
13268: LD_INT 1
13270: PPUSH
13271: CALL_OW 344
// end ;
13275: LD_VAR 0 1
13279: RET
// export function hHackTeleport ( unit , x , y ) ; begin
13280: LD_INT 0
13282: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_VAR 0 2
13292: PPUSH
13293: LD_VAR 0 3
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: LD_INT 1
13303: PPUSH
13304: CALL_OW 483
// CenterOnXY ( x , y ) ;
13308: LD_VAR 0 2
13312: PPUSH
13313: LD_VAR 0 3
13317: PPUSH
13318: CALL_OW 84
// end ; end_of_file
13322: LD_VAR 0 4
13326: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
13327: LD_VAR 0 1
13331: PUSH
13332: LD_INT 200
13334: DOUBLE
13335: GREATEREQUAL
13336: IFFALSE 13344
13338: LD_INT 299
13340: DOUBLE
13341: LESSEQUAL
13342: IFTRUE 13346
13344: GO 13378
13346: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
13347: LD_VAR 0 1
13351: PPUSH
13352: LD_VAR 0 2
13356: PPUSH
13357: LD_VAR 0 3
13361: PPUSH
13362: LD_VAR 0 4
13366: PPUSH
13367: LD_VAR 0 5
13371: PPUSH
13372: CALL 13622 0 5
13376: GO 13455
13378: LD_INT 300
13380: DOUBLE
13381: GREATEREQUAL
13382: IFFALSE 13390
13384: LD_INT 399
13386: DOUBLE
13387: LESSEQUAL
13388: IFTRUE 13392
13390: GO 13454
13392: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
13393: LD_VAR 0 1
13397: PPUSH
13398: LD_VAR 0 2
13402: PPUSH
13403: LD_VAR 0 3
13407: PPUSH
13408: LD_VAR 0 4
13412: PPUSH
13413: LD_VAR 0 5
13417: PPUSH
13418: LD_VAR 0 6
13422: PPUSH
13423: LD_VAR 0 7
13427: PPUSH
13428: LD_VAR 0 8
13432: PPUSH
13433: LD_VAR 0 9
13437: PPUSH
13438: LD_VAR 0 10
13442: PPUSH
13443: LD_VAR 0 11
13447: PPUSH
13448: CALL 11347 0 11
13452: GO 13455
13454: POP
// end ;
13455: PPOPN 11
13457: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
13458: LD_VAR 0 1
13462: PPUSH
13463: LD_VAR 0 2
13467: PPUSH
13468: LD_VAR 0 3
13472: PPUSH
13473: LD_VAR 0 4
13477: PPUSH
13478: LD_VAR 0 5
13482: PPUSH
13483: CALL 13604 0 5
// end ; end_of_file
13487: PPOPN 5
13489: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
13490: LD_INT 0
13492: PPUSH
13493: PPUSH
13494: PPUSH
13495: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL_OW 264
13505: PUSH
13506: LD_EXP 5
13510: EQUAL
13511: IFFALSE 13583
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13513: LD_INT 68
13515: PPUSH
13516: LD_VAR 0 1
13520: PPUSH
13521: CALL_OW 255
13525: PPUSH
13526: CALL_OW 321
13530: PUSH
13531: LD_INT 2
13533: EQUAL
13534: IFFALSE 13546
// eff := 70 else
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_INT 70
13543: ST_TO_ADDR
13544: GO 13554
// eff := 30 ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 30
13553: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL_OW 250
13563: PPUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL_OW 251
13573: PPUSH
13574: LD_VAR 0 4
13578: PPUSH
13579: CALL_OW 495
// end ; end ;
13583: LD_VAR 0 2
13587: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
13588: LD_INT 0
13590: PPUSH
// end ;
13591: LD_VAR 0 4
13595: RET
// export function SOS_Command ( cmd ) ; begin
13596: LD_INT 0
13598: PPUSH
// end ;
13599: LD_VAR 0 2
13603: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
13604: LD_INT 0
13606: PPUSH
// if cmd = 121 then
13607: LD_VAR 0 1
13611: PUSH
13612: LD_INT 121
13614: EQUAL
13615: IFFALSE 13617
// end ;
13617: LD_VAR 0 6
13621: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
13622: LD_INT 0
13624: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
13625: LD_VAR 0 1
13629: PUSH
13630: LD_INT 250
13632: EQUAL
13633: PUSH
13634: LD_VAR 0 2
13638: PPUSH
13639: CALL_OW 264
13643: PUSH
13644: LD_EXP 8
13648: EQUAL
13649: AND
13650: IFFALSE 13671
// MinerPlaceMine ( unit , x , y ) ;
13652: LD_VAR 0 2
13656: PPUSH
13657: LD_VAR 0 4
13661: PPUSH
13662: LD_VAR 0 5
13666: PPUSH
13667: CALL 16046 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
13671: LD_VAR 0 1
13675: PUSH
13676: LD_INT 251
13678: EQUAL
13679: PUSH
13680: LD_VAR 0 2
13684: PPUSH
13685: CALL_OW 264
13689: PUSH
13690: LD_EXP 8
13694: EQUAL
13695: AND
13696: IFFALSE 13717
// MinerDetonateMine ( unit , x , y ) ;
13698: LD_VAR 0 2
13702: PPUSH
13703: LD_VAR 0 4
13707: PPUSH
13708: LD_VAR 0 5
13712: PPUSH
13713: CALL 16323 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
13717: LD_VAR 0 1
13721: PUSH
13722: LD_INT 252
13724: EQUAL
13725: PUSH
13726: LD_VAR 0 2
13730: PPUSH
13731: CALL_OW 264
13735: PUSH
13736: LD_EXP 8
13740: EQUAL
13741: AND
13742: IFFALSE 13763
// MinerCreateMinefield ( unit , x , y ) ;
13744: LD_VAR 0 2
13748: PPUSH
13749: LD_VAR 0 4
13753: PPUSH
13754: LD_VAR 0 5
13758: PPUSH
13759: CALL 16740 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
13763: LD_VAR 0 1
13767: PUSH
13768: LD_INT 253
13770: EQUAL
13771: PUSH
13772: LD_VAR 0 2
13776: PPUSH
13777: CALL_OW 257
13781: PUSH
13782: LD_INT 5
13784: EQUAL
13785: AND
13786: IFFALSE 13807
// ComBinocular ( unit , x , y ) ;
13788: LD_VAR 0 2
13792: PPUSH
13793: LD_VAR 0 4
13797: PPUSH
13798: LD_VAR 0 5
13802: PPUSH
13803: CALL 17111 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
13807: LD_VAR 0 1
13811: PUSH
13812: LD_INT 254
13814: EQUAL
13815: PUSH
13816: LD_VAR 0 2
13820: PPUSH
13821: CALL_OW 264
13825: PUSH
13826: LD_EXP 3
13830: EQUAL
13831: AND
13832: PUSH
13833: LD_VAR 0 3
13837: PPUSH
13838: CALL_OW 263
13842: PUSH
13843: LD_INT 3
13845: EQUAL
13846: AND
13847: IFFALSE 13863
// HackDestroyVehicle ( unit , selectedUnit ) ;
13849: LD_VAR 0 2
13853: PPUSH
13854: LD_VAR 0 3
13858: PPUSH
13859: CALL 15406 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
13863: LD_VAR 0 1
13867: PUSH
13868: LD_INT 255
13870: EQUAL
13871: PUSH
13872: LD_VAR 0 2
13876: PPUSH
13877: CALL_OW 264
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: LD_INT 53
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: IN
13892: AND
13893: PUSH
13894: LD_VAR 0 4
13898: PPUSH
13899: LD_VAR 0 5
13903: PPUSH
13904: CALL_OW 488
13908: AND
13909: IFFALSE 13933
// CutTreeXYR ( unit , x , y , 12 ) ;
13911: LD_VAR 0 2
13915: PPUSH
13916: LD_VAR 0 4
13920: PPUSH
13921: LD_VAR 0 5
13925: PPUSH
13926: LD_INT 12
13928: PPUSH
13929: CALL 13972 0 4
// end ;
13933: LD_VAR 0 6
13937: RET
// export initPlantMineScript , plantMineList ; every 1 trigger not initPlantMineScript do
13938: LD_EXP 72
13942: NOT
13943: IFFALSE 13963
13945: GO 13947
13947: DISABLE
// begin initPlantMineScript := true ;
13948: LD_ADDR_EXP 72
13952: PUSH
13953: LD_INT 1
13955: ST_TO_ADDR
// plantMineList := [ ] ;
13956: LD_ADDR_EXP 73
13960: PUSH
13961: EMPTY
13962: ST_TO_ADDR
// end ;
13963: END
// export function ComGroupPlantMineXY ( units , x , y ) ; begin
13964: LD_INT 0
13966: PPUSH
// end ;
13967: LD_VAR 0 4
13971: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13972: LD_INT 0
13974: PPUSH
13975: PPUSH
13976: PPUSH
13977: PPUSH
13978: PPUSH
13979: PPUSH
13980: PPUSH
13981: PPUSH
13982: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13983: LD_VAR 0 1
13987: NOT
13988: PUSH
13989: LD_VAR 0 2
13993: PPUSH
13994: LD_VAR 0 3
13998: PPUSH
13999: CALL_OW 488
14003: NOT
14004: OR
14005: PUSH
14006: LD_VAR 0 4
14010: NOT
14011: OR
14012: IFFALSE 14016
// exit ;
14014: GO 14356
// list := [ ] ;
14016: LD_ADDR_VAR 0 13
14020: PUSH
14021: EMPTY
14022: ST_TO_ADDR
// if x - r < 0 then
14023: LD_VAR 0 2
14027: PUSH
14028: LD_VAR 0 4
14032: MINUS
14033: PUSH
14034: LD_INT 0
14036: LESS
14037: IFFALSE 14049
// min_x := 0 else
14039: LD_ADDR_VAR 0 7
14043: PUSH
14044: LD_INT 0
14046: ST_TO_ADDR
14047: GO 14065
// min_x := x - r ;
14049: LD_ADDR_VAR 0 7
14053: PUSH
14054: LD_VAR 0 2
14058: PUSH
14059: LD_VAR 0 4
14063: MINUS
14064: ST_TO_ADDR
// if y - r < 0 then
14065: LD_VAR 0 3
14069: PUSH
14070: LD_VAR 0 4
14074: MINUS
14075: PUSH
14076: LD_INT 0
14078: LESS
14079: IFFALSE 14091
// min_y := 0 else
14081: LD_ADDR_VAR 0 8
14085: PUSH
14086: LD_INT 0
14088: ST_TO_ADDR
14089: GO 14107
// min_y := y - r ;
14091: LD_ADDR_VAR 0 8
14095: PUSH
14096: LD_VAR 0 3
14100: PUSH
14101: LD_VAR 0 4
14105: MINUS
14106: ST_TO_ADDR
// max_x := x + r ;
14107: LD_ADDR_VAR 0 9
14111: PUSH
14112: LD_VAR 0 2
14116: PUSH
14117: LD_VAR 0 4
14121: PLUS
14122: ST_TO_ADDR
// max_y := y + r ;
14123: LD_ADDR_VAR 0 10
14127: PUSH
14128: LD_VAR 0 3
14132: PUSH
14133: LD_VAR 0 4
14137: PLUS
14138: ST_TO_ADDR
// for _x = min_x to max_x do
14139: LD_ADDR_VAR 0 11
14143: PUSH
14144: DOUBLE
14145: LD_VAR 0 7
14149: DEC
14150: ST_TO_ADDR
14151: LD_VAR 0 9
14155: PUSH
14156: FOR_TO
14157: IFFALSE 14274
// for _y = min_y to max_y do
14159: LD_ADDR_VAR 0 12
14163: PUSH
14164: DOUBLE
14165: LD_VAR 0 8
14169: DEC
14170: ST_TO_ADDR
14171: LD_VAR 0 10
14175: PUSH
14176: FOR_TO
14177: IFFALSE 14270
// begin if not ValidHex ( _x , _y ) then
14179: LD_VAR 0 11
14183: PPUSH
14184: LD_VAR 0 12
14188: PPUSH
14189: CALL_OW 488
14193: NOT
14194: IFFALSE 14198
// continue ;
14196: GO 14176
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
14198: LD_VAR 0 11
14202: PPUSH
14203: LD_VAR 0 12
14207: PPUSH
14208: CALL_OW 351
14212: PUSH
14213: LD_VAR 0 11
14217: PPUSH
14218: LD_VAR 0 12
14222: PPUSH
14223: CALL_OW 554
14227: AND
14228: IFFALSE 14268
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
14230: LD_ADDR_VAR 0 13
14234: PUSH
14235: LD_VAR 0 13
14239: PPUSH
14240: LD_VAR 0 13
14244: PUSH
14245: LD_INT 1
14247: PLUS
14248: PPUSH
14249: LD_VAR 0 11
14253: PUSH
14254: LD_VAR 0 12
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: PPUSH
14263: CALL_OW 2
14267: ST_TO_ADDR
// end ;
14268: GO 14176
14270: POP
14271: POP
14272: GO 14156
14274: POP
14275: POP
// if not list then
14276: LD_VAR 0 13
14280: NOT
14281: IFFALSE 14285
// exit ;
14283: GO 14356
// for i in list do
14285: LD_ADDR_VAR 0 6
14289: PUSH
14290: LD_VAR 0 13
14294: PUSH
14295: FOR_IN
14296: IFFALSE 14354
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
14298: LD_VAR 0 1
14302: PPUSH
14303: LD_STRING M
14305: PUSH
14306: LD_VAR 0 6
14310: PUSH
14311: LD_INT 1
14313: ARRAY
14314: PUSH
14315: LD_VAR 0 6
14319: PUSH
14320: LD_INT 2
14322: ARRAY
14323: PUSH
14324: LD_INT 0
14326: PUSH
14327: LD_INT 0
14329: PUSH
14330: LD_INT 0
14332: PUSH
14333: LD_INT 0
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: PPUSH
14348: CALL_OW 447
14352: GO 14295
14354: POP
14355: POP
// end ;
14356: LD_VAR 0 5
14360: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
14361: LD_EXP 74
14365: NOT
14366: IFFALSE 14416
14368: GO 14370
14370: DISABLE
// begin initHack := true ;
14371: LD_ADDR_EXP 74
14375: PUSH
14376: LD_INT 1
14378: ST_TO_ADDR
// hackTanks := [ ] ;
14379: LD_ADDR_EXP 75
14383: PUSH
14384: EMPTY
14385: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
14386: LD_ADDR_EXP 76
14390: PUSH
14391: EMPTY
14392: ST_TO_ADDR
// hackLimit := 3 ;
14393: LD_ADDR_EXP 77
14397: PUSH
14398: LD_INT 3
14400: ST_TO_ADDR
// hackDist := 12 ;
14401: LD_ADDR_EXP 78
14405: PUSH
14406: LD_INT 12
14408: ST_TO_ADDR
// hackCounter := [ ] ;
14409: LD_ADDR_EXP 79
14413: PUSH
14414: EMPTY
14415: ST_TO_ADDR
// end ;
14416: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
14417: LD_EXP 74
14421: PUSH
14422: LD_INT 34
14424: PUSH
14425: LD_EXP 3
14429: PUSH
14430: EMPTY
14431: LIST
14432: LIST
14433: PPUSH
14434: CALL_OW 69
14438: AND
14439: IFFALSE 14694
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
// begin enable ;
14448: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
14449: LD_ADDR_VAR 0 1
14453: PUSH
14454: LD_INT 34
14456: PUSH
14457: LD_EXP 3
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PPUSH
14466: CALL_OW 69
14470: PUSH
14471: FOR_IN
14472: IFFALSE 14692
// begin if not i in hackTanks then
14474: LD_VAR 0 1
14478: PUSH
14479: LD_EXP 75
14483: IN
14484: NOT
14485: IFFALSE 14568
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
14487: LD_ADDR_EXP 75
14491: PUSH
14492: LD_EXP 75
14496: PPUSH
14497: LD_EXP 75
14501: PUSH
14502: LD_INT 1
14504: PLUS
14505: PPUSH
14506: LD_VAR 0 1
14510: PPUSH
14511: CALL_OW 1
14515: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
14516: LD_ADDR_EXP 76
14520: PUSH
14521: LD_EXP 76
14525: PPUSH
14526: LD_EXP 76
14530: PUSH
14531: LD_INT 1
14533: PLUS
14534: PPUSH
14535: EMPTY
14536: PPUSH
14537: CALL_OW 1
14541: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
14542: LD_ADDR_EXP 79
14546: PUSH
14547: LD_EXP 79
14551: PPUSH
14552: LD_EXP 79
14556: PUSH
14557: LD_INT 1
14559: PLUS
14560: PPUSH
14561: EMPTY
14562: PPUSH
14563: CALL_OW 1
14567: ST_TO_ADDR
// end ; if not IsOk ( i ) then
14568: LD_VAR 0 1
14572: PPUSH
14573: CALL_OW 302
14577: NOT
14578: IFFALSE 14591
// begin HackUnlinkAll ( i ) ;
14580: LD_VAR 0 1
14584: PPUSH
14585: CALL 14697 0 1
// continue ;
14589: GO 14471
// end ; HackCheckCapturedStatus ( i ) ;
14591: LD_VAR 0 1
14595: PPUSH
14596: CALL 15140 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
14600: LD_ADDR_VAR 0 2
14604: PUSH
14605: LD_INT 81
14607: PUSH
14608: LD_VAR 0 1
14612: PPUSH
14613: CALL_OW 255
14617: PUSH
14618: EMPTY
14619: LIST
14620: LIST
14621: PUSH
14622: LD_INT 33
14624: PUSH
14625: LD_INT 3
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: PUSH
14632: LD_INT 91
14634: PUSH
14635: LD_VAR 0 1
14639: PUSH
14640: LD_EXP 78
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: PUSH
14650: LD_INT 50
14652: PUSH
14653: EMPTY
14654: LIST
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: ST_TO_ADDR
// if not tmp then
14667: LD_VAR 0 2
14671: NOT
14672: IFFALSE 14676
// continue ;
14674: GO 14471
// HackLink ( i , tmp ) ;
14676: LD_VAR 0 1
14680: PPUSH
14681: LD_VAR 0 2
14685: PPUSH
14686: CALL 14833 0 2
// end ;
14690: GO 14471
14692: POP
14693: POP
// end ;
14694: PPOPN 2
14696: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
14697: LD_INT 0
14699: PPUSH
14700: PPUSH
14701: PPUSH
// if not hack in hackTanks then
14702: LD_VAR 0 1
14706: PUSH
14707: LD_EXP 75
14711: IN
14712: NOT
14713: IFFALSE 14717
// exit ;
14715: GO 14828
// index := GetElementIndex ( hackTanks , hack ) ;
14717: LD_ADDR_VAR 0 4
14721: PUSH
14722: LD_EXP 75
14726: PPUSH
14727: LD_VAR 0 1
14731: PPUSH
14732: CALL 22262 0 2
14736: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
14737: LD_EXP 76
14741: PUSH
14742: LD_VAR 0 4
14746: ARRAY
14747: IFFALSE 14828
// begin for i in hackTanksCaptured [ index ] do
14749: LD_ADDR_VAR 0 3
14753: PUSH
14754: LD_EXP 76
14758: PUSH
14759: LD_VAR 0 4
14763: ARRAY
14764: PUSH
14765: FOR_IN
14766: IFFALSE 14792
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
14768: LD_VAR 0 3
14772: PUSH
14773: LD_INT 1
14775: ARRAY
14776: PPUSH
14777: LD_VAR 0 3
14781: PUSH
14782: LD_INT 2
14784: ARRAY
14785: PPUSH
14786: CALL_OW 235
14790: GO 14765
14792: POP
14793: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
14794: LD_ADDR_EXP 76
14798: PUSH
14799: LD_EXP 76
14803: PPUSH
14804: LD_VAR 0 4
14808: PPUSH
14809: EMPTY
14810: PPUSH
14811: CALL_OW 1
14815: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
14816: LD_VAR 0 1
14820: PPUSH
14821: LD_INT 0
14823: PPUSH
14824: CALL_OW 505
// end ; end ;
14828: LD_VAR 0 2
14832: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
14833: LD_INT 0
14835: PPUSH
14836: PPUSH
14837: PPUSH
// if not hack in hackTanks or not vehicles then
14838: LD_VAR 0 1
14842: PUSH
14843: LD_EXP 75
14847: IN
14848: NOT
14849: PUSH
14850: LD_VAR 0 2
14854: NOT
14855: OR
14856: IFFALSE 14860
// exit ;
14858: GO 15135
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
14860: LD_ADDR_VAR 0 2
14864: PUSH
14865: LD_VAR 0 1
14869: PPUSH
14870: LD_VAR 0 2
14874: PPUSH
14875: LD_INT 1
14877: PPUSH
14878: LD_INT 1
14880: PPUSH
14881: CALL 22912 0 4
14885: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
14886: LD_ADDR_VAR 0 5
14890: PUSH
14891: LD_EXP 75
14895: PPUSH
14896: LD_VAR 0 1
14900: PPUSH
14901: CALL 22262 0 2
14905: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
14906: LD_EXP 76
14910: PUSH
14911: LD_VAR 0 5
14915: ARRAY
14916: PUSH
14917: LD_EXP 77
14921: LESS
14922: IFFALSE 15111
// begin for i := 1 to vehicles do
14924: LD_ADDR_VAR 0 4
14928: PUSH
14929: DOUBLE
14930: LD_INT 1
14932: DEC
14933: ST_TO_ADDR
14934: LD_VAR 0 2
14938: PUSH
14939: FOR_TO
14940: IFFALSE 15109
// begin if hackTanksCaptured [ index ] = hackLimit then
14942: LD_EXP 76
14946: PUSH
14947: LD_VAR 0 5
14951: ARRAY
14952: PUSH
14953: LD_EXP 77
14957: EQUAL
14958: IFFALSE 14962
// break ;
14960: GO 15109
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
14962: LD_ADDR_EXP 79
14966: PUSH
14967: LD_EXP 79
14971: PPUSH
14972: LD_VAR 0 5
14976: PPUSH
14977: LD_EXP 79
14981: PUSH
14982: LD_VAR 0 5
14986: ARRAY
14987: PUSH
14988: LD_INT 1
14990: PLUS
14991: PPUSH
14992: CALL_OW 1
14996: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
14997: LD_ADDR_EXP 76
15001: PUSH
15002: LD_EXP 76
15006: PPUSH
15007: LD_VAR 0 5
15011: PUSH
15012: LD_EXP 76
15016: PUSH
15017: LD_VAR 0 5
15021: ARRAY
15022: PUSH
15023: LD_INT 1
15025: PLUS
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PPUSH
15031: LD_VAR 0 2
15035: PUSH
15036: LD_VAR 0 4
15040: ARRAY
15041: PUSH
15042: LD_VAR 0 2
15046: PUSH
15047: LD_VAR 0 4
15051: ARRAY
15052: PPUSH
15053: CALL_OW 255
15057: PUSH
15058: EMPTY
15059: LIST
15060: LIST
15061: PPUSH
15062: CALL 22477 0 3
15066: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
15067: LD_VAR 0 2
15071: PUSH
15072: LD_VAR 0 4
15076: ARRAY
15077: PPUSH
15078: LD_VAR 0 1
15082: PPUSH
15083: CALL_OW 255
15087: PPUSH
15088: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
15092: LD_VAR 0 2
15096: PUSH
15097: LD_VAR 0 4
15101: ARRAY
15102: PPUSH
15103: CALL_OW 141
// end ;
15107: GO 14939
15109: POP
15110: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15111: LD_VAR 0 1
15115: PPUSH
15116: LD_EXP 76
15120: PUSH
15121: LD_VAR 0 5
15125: ARRAY
15126: PUSH
15127: LD_INT 0
15129: PLUS
15130: PPUSH
15131: CALL_OW 505
// end ;
15135: LD_VAR 0 3
15139: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
15140: LD_INT 0
15142: PPUSH
15143: PPUSH
15144: PPUSH
15145: PPUSH
// if not hack in hackTanks then
15146: LD_VAR 0 1
15150: PUSH
15151: LD_EXP 75
15155: IN
15156: NOT
15157: IFFALSE 15161
// exit ;
15159: GO 15401
// index := GetElementIndex ( hackTanks , hack ) ;
15161: LD_ADDR_VAR 0 4
15165: PUSH
15166: LD_EXP 75
15170: PPUSH
15171: LD_VAR 0 1
15175: PPUSH
15176: CALL 22262 0 2
15180: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: DOUBLE
15187: LD_EXP 76
15191: PUSH
15192: LD_VAR 0 4
15196: ARRAY
15197: INC
15198: ST_TO_ADDR
15199: LD_INT 1
15201: PUSH
15202: FOR_DOWNTO
15203: IFFALSE 15375
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
15205: LD_ADDR_VAR 0 5
15209: PUSH
15210: LD_EXP 76
15214: PUSH
15215: LD_VAR 0 4
15219: ARRAY
15220: PUSH
15221: LD_VAR 0 3
15225: ARRAY
15226: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
15227: LD_VAR 0 5
15231: PUSH
15232: LD_INT 1
15234: ARRAY
15235: PPUSH
15236: CALL_OW 302
15240: NOT
15241: PUSH
15242: LD_VAR 0 5
15246: PUSH
15247: LD_INT 1
15249: ARRAY
15250: PPUSH
15251: CALL_OW 255
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 255
15265: NONEQUAL
15266: OR
15267: IFFALSE 15373
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
15269: LD_VAR 0 5
15273: PUSH
15274: LD_INT 1
15276: ARRAY
15277: PPUSH
15278: CALL_OW 305
15282: PUSH
15283: LD_VAR 0 5
15287: PUSH
15288: LD_INT 1
15290: ARRAY
15291: PPUSH
15292: CALL_OW 255
15296: PUSH
15297: LD_VAR 0 1
15301: PPUSH
15302: CALL_OW 255
15306: EQUAL
15307: AND
15308: IFFALSE 15332
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
15310: LD_VAR 0 5
15314: PUSH
15315: LD_INT 1
15317: ARRAY
15318: PPUSH
15319: LD_VAR 0 5
15323: PUSH
15324: LD_INT 2
15326: ARRAY
15327: PPUSH
15328: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
15332: LD_ADDR_EXP 76
15336: PUSH
15337: LD_EXP 76
15341: PPUSH
15342: LD_VAR 0 4
15346: PPUSH
15347: LD_EXP 76
15351: PUSH
15352: LD_VAR 0 4
15356: ARRAY
15357: PPUSH
15358: LD_VAR 0 3
15362: PPUSH
15363: CALL_OW 3
15367: PPUSH
15368: CALL_OW 1
15372: ST_TO_ADDR
// end ; end ;
15373: GO 15202
15375: POP
15376: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15377: LD_VAR 0 1
15381: PPUSH
15382: LD_EXP 76
15386: PUSH
15387: LD_VAR 0 4
15391: ARRAY
15392: PUSH
15393: LD_INT 0
15395: PLUS
15396: PPUSH
15397: CALL_OW 505
// end ;
15401: LD_VAR 0 2
15405: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
15406: LD_INT 0
15408: PPUSH
15409: PPUSH
15410: PPUSH
15411: PPUSH
// if not hack in hackTanks then
15412: LD_VAR 0 1
15416: PUSH
15417: LD_EXP 75
15421: IN
15422: NOT
15423: IFFALSE 15427
// exit ;
15425: GO 15512
// index := GetElementIndex ( hackTanks , hack ) ;
15427: LD_ADDR_VAR 0 5
15431: PUSH
15432: LD_EXP 75
15436: PPUSH
15437: LD_VAR 0 1
15441: PPUSH
15442: CALL 22262 0 2
15446: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
15447: LD_ADDR_VAR 0 4
15451: PUSH
15452: DOUBLE
15453: LD_INT 1
15455: DEC
15456: ST_TO_ADDR
15457: LD_EXP 76
15461: PUSH
15462: LD_VAR 0 5
15466: ARRAY
15467: PUSH
15468: FOR_TO
15469: IFFALSE 15510
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
15471: LD_EXP 76
15475: PUSH
15476: LD_VAR 0 5
15480: ARRAY
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_VAR 0 2
15496: EQUAL
15497: IFFALSE 15508
// KillUnit ( vehicle ) ;
15499: LD_VAR 0 2
15503: PPUSH
15504: CALL_OW 66
15508: GO 15468
15510: POP
15511: POP
// end ;
15512: LD_VAR 0 3
15516: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
15517: LD_EXP 80
15521: NOT
15522: IFFALSE 15557
15524: GO 15526
15526: DISABLE
// begin initMiner := true ;
15527: LD_ADDR_EXP 80
15531: PUSH
15532: LD_INT 1
15534: ST_TO_ADDR
// minersList := [ ] ;
15535: LD_ADDR_EXP 81
15539: PUSH
15540: EMPTY
15541: ST_TO_ADDR
// minerMinesList := [ ] ;
15542: LD_ADDR_EXP 82
15546: PUSH
15547: EMPTY
15548: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
15549: LD_ADDR_EXP 83
15553: PUSH
15554: LD_INT 5
15556: ST_TO_ADDR
// end ;
15557: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
15558: LD_EXP 80
15562: PUSH
15563: LD_INT 34
15565: PUSH
15566: LD_EXP 8
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PPUSH
15575: CALL_OW 69
15579: AND
15580: IFFALSE 16043
15582: GO 15584
15584: DISABLE
15585: LD_INT 0
15587: PPUSH
15588: PPUSH
15589: PPUSH
15590: PPUSH
// begin enable ;
15591: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
15592: LD_ADDR_VAR 0 1
15596: PUSH
15597: LD_INT 34
15599: PUSH
15600: LD_EXP 8
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PPUSH
15609: CALL_OW 69
15613: PUSH
15614: FOR_IN
15615: IFFALSE 15687
// begin if not i in minersList then
15617: LD_VAR 0 1
15621: PUSH
15622: LD_EXP 81
15626: IN
15627: NOT
15628: IFFALSE 15685
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
15630: LD_ADDR_EXP 81
15634: PUSH
15635: LD_EXP 81
15639: PPUSH
15640: LD_EXP 81
15644: PUSH
15645: LD_INT 1
15647: PLUS
15648: PPUSH
15649: LD_VAR 0 1
15653: PPUSH
15654: CALL_OW 1
15658: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
15659: LD_ADDR_EXP 82
15663: PUSH
15664: LD_EXP 82
15668: PPUSH
15669: LD_EXP 82
15673: PUSH
15674: LD_INT 1
15676: PLUS
15677: PPUSH
15678: EMPTY
15679: PPUSH
15680: CALL_OW 1
15684: ST_TO_ADDR
// end end ;
15685: GO 15614
15687: POP
15688: POP
// for i := minerMinesList downto 1 do
15689: LD_ADDR_VAR 0 1
15693: PUSH
15694: DOUBLE
15695: LD_EXP 82
15699: INC
15700: ST_TO_ADDR
15701: LD_INT 1
15703: PUSH
15704: FOR_DOWNTO
15705: IFFALSE 16041
// begin if IsLive ( minersList [ i ] ) then
15707: LD_EXP 81
15711: PUSH
15712: LD_VAR 0 1
15716: ARRAY
15717: PPUSH
15718: CALL_OW 300
15722: IFFALSE 15750
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
15724: LD_EXP 81
15728: PUSH
15729: LD_VAR 0 1
15733: ARRAY
15734: PPUSH
15735: LD_EXP 82
15739: PUSH
15740: LD_VAR 0 1
15744: ARRAY
15745: PPUSH
15746: CALL_OW 505
// if not minerMinesList [ i ] then
15750: LD_EXP 82
15754: PUSH
15755: LD_VAR 0 1
15759: ARRAY
15760: NOT
15761: IFFALSE 15765
// continue ;
15763: GO 15704
// for j := minerMinesList [ i ] downto 1 do
15765: LD_ADDR_VAR 0 2
15769: PUSH
15770: DOUBLE
15771: LD_EXP 82
15775: PUSH
15776: LD_VAR 0 1
15780: ARRAY
15781: INC
15782: ST_TO_ADDR
15783: LD_INT 1
15785: PUSH
15786: FOR_DOWNTO
15787: IFFALSE 16037
// begin side := GetSide ( minersList [ i ] ) ;
15789: LD_ADDR_VAR 0 3
15793: PUSH
15794: LD_EXP 81
15798: PUSH
15799: LD_VAR 0 1
15803: ARRAY
15804: PPUSH
15805: CALL_OW 255
15809: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
15810: LD_ADDR_VAR 0 4
15814: PUSH
15815: LD_EXP 82
15819: PUSH
15820: LD_VAR 0 1
15824: ARRAY
15825: PUSH
15826: LD_VAR 0 2
15830: ARRAY
15831: PUSH
15832: LD_INT 1
15834: ARRAY
15835: PPUSH
15836: LD_EXP 82
15840: PUSH
15841: LD_VAR 0 1
15845: ARRAY
15846: PUSH
15847: LD_VAR 0 2
15851: ARRAY
15852: PUSH
15853: LD_INT 2
15855: ARRAY
15856: PPUSH
15857: CALL_OW 428
15861: ST_TO_ADDR
// if not tmp then
15862: LD_VAR 0 4
15866: NOT
15867: IFFALSE 15871
// continue ;
15869: GO 15786
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
15871: LD_VAR 0 4
15875: PUSH
15876: LD_INT 81
15878: PUSH
15879: LD_VAR 0 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: PPUSH
15888: CALL_OW 69
15892: IN
15893: PUSH
15894: LD_EXP 82
15898: PUSH
15899: LD_VAR 0 1
15903: ARRAY
15904: PUSH
15905: LD_VAR 0 2
15909: ARRAY
15910: PUSH
15911: LD_INT 1
15913: ARRAY
15914: PPUSH
15915: LD_EXP 82
15919: PUSH
15920: LD_VAR 0 1
15924: ARRAY
15925: PUSH
15926: LD_VAR 0 2
15930: ARRAY
15931: PUSH
15932: LD_INT 2
15934: ARRAY
15935: PPUSH
15936: CALL_OW 458
15940: AND
15941: IFFALSE 16035
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
15943: LD_EXP 82
15947: PUSH
15948: LD_VAR 0 1
15952: ARRAY
15953: PUSH
15954: LD_VAR 0 2
15958: ARRAY
15959: PUSH
15960: LD_INT 1
15962: ARRAY
15963: PPUSH
15964: LD_EXP 82
15968: PUSH
15969: LD_VAR 0 1
15973: ARRAY
15974: PUSH
15975: LD_VAR 0 2
15979: ARRAY
15980: PUSH
15981: LD_INT 2
15983: ARRAY
15984: PPUSH
15985: LD_VAR 0 3
15989: PPUSH
15990: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
15994: LD_ADDR_EXP 82
15998: PUSH
15999: LD_EXP 82
16003: PPUSH
16004: LD_VAR 0 1
16008: PPUSH
16009: LD_EXP 82
16013: PUSH
16014: LD_VAR 0 1
16018: ARRAY
16019: PPUSH
16020: LD_VAR 0 2
16024: PPUSH
16025: CALL_OW 3
16029: PPUSH
16030: CALL_OW 1
16034: ST_TO_ADDR
// end ; end ;
16035: GO 15786
16037: POP
16038: POP
// end ;
16039: GO 15704
16041: POP
16042: POP
// end ;
16043: PPOPN 4
16045: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
// result := false ;
16050: LD_ADDR_VAR 0 4
16054: PUSH
16055: LD_INT 0
16057: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
16058: LD_VAR 0 1
16062: PPUSH
16063: CALL_OW 264
16067: PUSH
16068: LD_EXP 8
16072: EQUAL
16073: NOT
16074: IFFALSE 16078
// exit ;
16076: GO 16318
// index := GetElementIndex ( minersList , unit ) ;
16078: LD_ADDR_VAR 0 5
16082: PUSH
16083: LD_EXP 81
16087: PPUSH
16088: LD_VAR 0 1
16092: PPUSH
16093: CALL 22262 0 2
16097: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
16098: LD_EXP 82
16102: PUSH
16103: LD_VAR 0 5
16107: ARRAY
16108: PUSH
16109: LD_EXP 83
16113: GREATEREQUAL
16114: IFFALSE 16118
// exit ;
16116: GO 16318
// ComMoveXY ( unit , x , y ) ;
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 2
16127: PPUSH
16128: LD_VAR 0 3
16132: PPUSH
16133: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16137: LD_INT 35
16139: PPUSH
16140: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
16144: LD_VAR 0 1
16148: PPUSH
16149: LD_VAR 0 2
16153: PPUSH
16154: LD_VAR 0 3
16158: PPUSH
16159: CALL 52326 0 3
16163: NOT
16164: PUSH
16165: LD_VAR 0 1
16169: PPUSH
16170: CALL_OW 314
16174: AND
16175: IFFALSE 16179
// exit ;
16177: GO 16318
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
16179: LD_VAR 0 2
16183: PPUSH
16184: LD_VAR 0 3
16188: PPUSH
16189: CALL_OW 428
16193: PUSH
16194: LD_VAR 0 1
16198: EQUAL
16199: PUSH
16200: LD_VAR 0 1
16204: PPUSH
16205: CALL_OW 314
16209: NOT
16210: AND
16211: IFFALSE 16137
// PlaySoundXY ( x , y , PlantMine ) ;
16213: LD_VAR 0 2
16217: PPUSH
16218: LD_VAR 0 3
16222: PPUSH
16223: LD_STRING PlantMine
16225: PPUSH
16226: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
16230: LD_VAR 0 2
16234: PPUSH
16235: LD_VAR 0 3
16239: PPUSH
16240: LD_VAR 0 1
16244: PPUSH
16245: CALL_OW 255
16249: PPUSH
16250: LD_INT 0
16252: PPUSH
16253: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
16257: LD_ADDR_EXP 82
16261: PUSH
16262: LD_EXP 82
16266: PPUSH
16267: LD_VAR 0 5
16271: PUSH
16272: LD_EXP 82
16276: PUSH
16277: LD_VAR 0 5
16281: ARRAY
16282: PUSH
16283: LD_INT 1
16285: PLUS
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PPUSH
16291: LD_VAR 0 2
16295: PUSH
16296: LD_VAR 0 3
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PPUSH
16305: CALL 22477 0 3
16309: ST_TO_ADDR
// result := true ;
16310: LD_ADDR_VAR 0 4
16314: PUSH
16315: LD_INT 1
16317: ST_TO_ADDR
// end ;
16318: LD_VAR 0 4
16322: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
16323: LD_INT 0
16325: PPUSH
16326: PPUSH
16327: PPUSH
// if not unit in minersList then
16328: LD_VAR 0 1
16332: PUSH
16333: LD_EXP 81
16337: IN
16338: NOT
16339: IFFALSE 16343
// exit ;
16341: GO 16735
// index := GetElementIndex ( minersList , unit ) ;
16343: LD_ADDR_VAR 0 6
16347: PUSH
16348: LD_EXP 81
16352: PPUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL 22262 0 2
16362: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: DOUBLE
16369: LD_EXP 82
16373: PUSH
16374: LD_VAR 0 6
16378: ARRAY
16379: INC
16380: ST_TO_ADDR
16381: LD_INT 1
16383: PUSH
16384: FOR_DOWNTO
16385: IFFALSE 16546
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
16387: LD_EXP 82
16391: PUSH
16392: LD_VAR 0 6
16396: ARRAY
16397: PUSH
16398: LD_VAR 0 5
16402: ARRAY
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PUSH
16408: LD_VAR 0 2
16412: EQUAL
16413: PUSH
16414: LD_EXP 82
16418: PUSH
16419: LD_VAR 0 6
16423: ARRAY
16424: PUSH
16425: LD_VAR 0 5
16429: ARRAY
16430: PUSH
16431: LD_INT 2
16433: ARRAY
16434: PUSH
16435: LD_VAR 0 3
16439: EQUAL
16440: AND
16441: IFFALSE 16544
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16443: LD_EXP 82
16447: PUSH
16448: LD_VAR 0 6
16452: ARRAY
16453: PUSH
16454: LD_VAR 0 5
16458: ARRAY
16459: PUSH
16460: LD_INT 1
16462: ARRAY
16463: PPUSH
16464: LD_EXP 82
16468: PUSH
16469: LD_VAR 0 6
16473: ARRAY
16474: PUSH
16475: LD_VAR 0 5
16479: ARRAY
16480: PUSH
16481: LD_INT 2
16483: ARRAY
16484: PPUSH
16485: LD_VAR 0 1
16489: PPUSH
16490: CALL_OW 255
16494: PPUSH
16495: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16499: LD_ADDR_EXP 82
16503: PUSH
16504: LD_EXP 82
16508: PPUSH
16509: LD_VAR 0 6
16513: PPUSH
16514: LD_EXP 82
16518: PUSH
16519: LD_VAR 0 6
16523: ARRAY
16524: PPUSH
16525: LD_VAR 0 5
16529: PPUSH
16530: CALL_OW 3
16534: PPUSH
16535: CALL_OW 1
16539: ST_TO_ADDR
// exit ;
16540: POP
16541: POP
16542: GO 16735
// end ; end ;
16544: GO 16384
16546: POP
16547: POP
// for i := minerMinesList [ index ] downto 1 do
16548: LD_ADDR_VAR 0 5
16552: PUSH
16553: DOUBLE
16554: LD_EXP 82
16558: PUSH
16559: LD_VAR 0 6
16563: ARRAY
16564: INC
16565: ST_TO_ADDR
16566: LD_INT 1
16568: PUSH
16569: FOR_DOWNTO
16570: IFFALSE 16733
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
16572: LD_EXP 82
16576: PUSH
16577: LD_VAR 0 6
16581: ARRAY
16582: PUSH
16583: LD_VAR 0 5
16587: ARRAY
16588: PUSH
16589: LD_INT 1
16591: ARRAY
16592: PPUSH
16593: LD_EXP 82
16597: PUSH
16598: LD_VAR 0 6
16602: ARRAY
16603: PUSH
16604: LD_VAR 0 5
16608: ARRAY
16609: PUSH
16610: LD_INT 2
16612: ARRAY
16613: PPUSH
16614: LD_VAR 0 2
16618: PPUSH
16619: LD_VAR 0 3
16623: PPUSH
16624: CALL_OW 298
16628: PUSH
16629: LD_INT 6
16631: LESS
16632: IFFALSE 16731
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16634: LD_EXP 82
16638: PUSH
16639: LD_VAR 0 6
16643: ARRAY
16644: PUSH
16645: LD_VAR 0 5
16649: ARRAY
16650: PUSH
16651: LD_INT 1
16653: ARRAY
16654: PPUSH
16655: LD_EXP 82
16659: PUSH
16660: LD_VAR 0 6
16664: ARRAY
16665: PUSH
16666: LD_VAR 0 5
16670: ARRAY
16671: PUSH
16672: LD_INT 2
16674: ARRAY
16675: PPUSH
16676: LD_VAR 0 1
16680: PPUSH
16681: CALL_OW 255
16685: PPUSH
16686: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16690: LD_ADDR_EXP 82
16694: PUSH
16695: LD_EXP 82
16699: PPUSH
16700: LD_VAR 0 6
16704: PPUSH
16705: LD_EXP 82
16709: PUSH
16710: LD_VAR 0 6
16714: ARRAY
16715: PPUSH
16716: LD_VAR 0 5
16720: PPUSH
16721: CALL_OW 3
16725: PPUSH
16726: CALL_OW 1
16730: ST_TO_ADDR
// end ; end ;
16731: GO 16569
16733: POP
16734: POP
// end ;
16735: LD_VAR 0 4
16739: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
16740: LD_INT 0
16742: PPUSH
16743: PPUSH
16744: PPUSH
16745: PPUSH
16746: PPUSH
16747: PPUSH
16748: PPUSH
16749: PPUSH
16750: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
16751: LD_VAR 0 1
16755: PPUSH
16756: CALL_OW 264
16760: PUSH
16761: LD_EXP 8
16765: EQUAL
16766: NOT
16767: PUSH
16768: LD_VAR 0 1
16772: PUSH
16773: LD_EXP 81
16777: IN
16778: NOT
16779: OR
16780: IFFALSE 16784
// exit ;
16782: GO 17106
// index := GetElementIndex ( minersList , unit ) ;
16784: LD_ADDR_VAR 0 6
16788: PUSH
16789: LD_EXP 81
16793: PPUSH
16794: LD_VAR 0 1
16798: PPUSH
16799: CALL 22262 0 2
16803: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
16804: LD_ADDR_VAR 0 8
16808: PUSH
16809: LD_EXP 83
16813: PUSH
16814: LD_EXP 82
16818: PUSH
16819: LD_VAR 0 6
16823: ARRAY
16824: MINUS
16825: ST_TO_ADDR
// if not minesFreeAmount then
16826: LD_VAR 0 8
16830: NOT
16831: IFFALSE 16835
// exit ;
16833: GO 17106
// tmp := [ ] ;
16835: LD_ADDR_VAR 0 7
16839: PUSH
16840: EMPTY
16841: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
16842: LD_ADDR_VAR 0 5
16846: PUSH
16847: DOUBLE
16848: LD_INT 1
16850: DEC
16851: ST_TO_ADDR
16852: LD_VAR 0 8
16856: PUSH
16857: FOR_TO
16858: IFFALSE 17053
// begin _d := rand ( 0 , 5 ) ;
16860: LD_ADDR_VAR 0 11
16864: PUSH
16865: LD_INT 0
16867: PPUSH
16868: LD_INT 5
16870: PPUSH
16871: CALL_OW 12
16875: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
16876: LD_ADDR_VAR 0 12
16880: PUSH
16881: LD_INT 2
16883: PPUSH
16884: LD_INT 6
16886: PPUSH
16887: CALL_OW 12
16891: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
16892: LD_ADDR_VAR 0 9
16896: PUSH
16897: LD_VAR 0 2
16901: PPUSH
16902: LD_VAR 0 11
16906: PPUSH
16907: LD_VAR 0 12
16911: PPUSH
16912: CALL_OW 272
16916: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
16917: LD_ADDR_VAR 0 10
16921: PUSH
16922: LD_VAR 0 3
16926: PPUSH
16927: LD_VAR 0 11
16931: PPUSH
16932: LD_VAR 0 12
16936: PPUSH
16937: CALL_OW 273
16941: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
16942: LD_VAR 0 9
16946: PPUSH
16947: LD_VAR 0 10
16951: PPUSH
16952: CALL_OW 488
16956: PUSH
16957: LD_VAR 0 9
16961: PUSH
16962: LD_VAR 0 10
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_VAR 0 7
16975: IN
16976: NOT
16977: AND
16978: PUSH
16979: LD_VAR 0 9
16983: PPUSH
16984: LD_VAR 0 10
16988: PPUSH
16989: CALL_OW 458
16993: NOT
16994: AND
16995: IFFALSE 17037
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
16997: LD_ADDR_VAR 0 7
17001: PUSH
17002: LD_VAR 0 7
17006: PPUSH
17007: LD_VAR 0 7
17011: PUSH
17012: LD_INT 1
17014: PLUS
17015: PPUSH
17016: LD_VAR 0 9
17020: PUSH
17021: LD_VAR 0 10
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: PPUSH
17030: CALL_OW 1
17034: ST_TO_ADDR
17035: GO 17051
// i := i - 1 ;
17037: LD_ADDR_VAR 0 5
17041: PUSH
17042: LD_VAR 0 5
17046: PUSH
17047: LD_INT 1
17049: MINUS
17050: ST_TO_ADDR
// end ;
17051: GO 16857
17053: POP
17054: POP
// for i in tmp do
17055: LD_ADDR_VAR 0 5
17059: PUSH
17060: LD_VAR 0 7
17064: PUSH
17065: FOR_IN
17066: IFFALSE 17104
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
17068: LD_VAR 0 1
17072: PPUSH
17073: LD_VAR 0 5
17077: PUSH
17078: LD_INT 1
17080: ARRAY
17081: PPUSH
17082: LD_VAR 0 5
17086: PUSH
17087: LD_INT 2
17089: ARRAY
17090: PPUSH
17091: CALL 16046 0 3
17095: NOT
17096: IFFALSE 17102
// exit ;
17098: POP
17099: POP
17100: GO 17106
17102: GO 17065
17104: POP
17105: POP
// end ;
17106: LD_VAR 0 4
17110: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
17111: LD_INT 0
17113: PPUSH
17114: PPUSH
17115: PPUSH
17116: PPUSH
17117: PPUSH
17118: PPUSH
17119: PPUSH
// if not GetClass ( unit ) = class_sniper then
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL_OW 257
17129: PUSH
17130: LD_INT 5
17132: EQUAL
17133: NOT
17134: IFFALSE 17138
// exit ;
17136: GO 17526
// dist := 8 ;
17138: LD_ADDR_VAR 0 5
17142: PUSH
17143: LD_INT 8
17145: ST_TO_ADDR
// viewRange := 12 ;
17146: LD_ADDR_VAR 0 7
17150: PUSH
17151: LD_INT 12
17153: ST_TO_ADDR
// side := GetSide ( unit ) ;
17154: LD_ADDR_VAR 0 6
17158: PUSH
17159: LD_VAR 0 1
17163: PPUSH
17164: CALL_OW 255
17168: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
17169: LD_INT 61
17171: PPUSH
17172: LD_VAR 0 6
17176: PPUSH
17177: CALL_OW 321
17181: PUSH
17182: LD_INT 2
17184: EQUAL
17185: IFFALSE 17195
// viewRange := 16 ;
17187: LD_ADDR_VAR 0 7
17191: PUSH
17192: LD_INT 16
17194: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
17195: LD_VAR 0 1
17199: PPUSH
17200: LD_VAR 0 2
17204: PPUSH
17205: LD_VAR 0 3
17209: PPUSH
17210: CALL_OW 297
17214: PUSH
17215: LD_VAR 0 5
17219: GREATER
17220: IFFALSE 17299
// begin ComMoveXY ( unit , x , y ) ;
17222: LD_VAR 0 1
17226: PPUSH
17227: LD_VAR 0 2
17231: PPUSH
17232: LD_VAR 0 3
17236: PPUSH
17237: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
17241: LD_INT 35
17243: PPUSH
17244: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
17248: LD_VAR 0 1
17252: PPUSH
17253: LD_VAR 0 2
17257: PPUSH
17258: LD_VAR 0 3
17262: PPUSH
17263: CALL 52326 0 3
17267: NOT
17268: IFFALSE 17272
// exit ;
17270: GO 17526
// until GetDistUnitXY ( unit , x , y ) < dist ;
17272: LD_VAR 0 1
17276: PPUSH
17277: LD_VAR 0 2
17281: PPUSH
17282: LD_VAR 0 3
17286: PPUSH
17287: CALL_OW 297
17291: PUSH
17292: LD_VAR 0 5
17296: LESS
17297: IFFALSE 17241
// end ; ComTurnXY ( unit , x , y ) ;
17299: LD_VAR 0 1
17303: PPUSH
17304: LD_VAR 0 2
17308: PPUSH
17309: LD_VAR 0 3
17313: PPUSH
17314: CALL_OW 118
// wait ( 5 ) ;
17318: LD_INT 5
17320: PPUSH
17321: CALL_OW 67
// _d := GetDir ( unit ) ;
17325: LD_ADDR_VAR 0 10
17329: PUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: CALL_OW 254
17339: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
17340: LD_ADDR_VAR 0 8
17344: PUSH
17345: LD_VAR 0 1
17349: PPUSH
17350: CALL_OW 250
17354: PPUSH
17355: LD_VAR 0 10
17359: PPUSH
17360: LD_VAR 0 5
17364: PPUSH
17365: CALL_OW 272
17369: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
17370: LD_ADDR_VAR 0 9
17374: PUSH
17375: LD_VAR 0 1
17379: PPUSH
17380: CALL_OW 251
17384: PPUSH
17385: LD_VAR 0 10
17389: PPUSH
17390: LD_VAR 0 5
17394: PPUSH
17395: CALL_OW 273
17399: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17400: LD_VAR 0 8
17404: PPUSH
17405: LD_VAR 0 9
17409: PPUSH
17410: CALL_OW 488
17414: NOT
17415: IFFALSE 17419
// exit ;
17417: GO 17526
// ComAnimCustom ( unit , 1 ) ;
17419: LD_VAR 0 1
17423: PPUSH
17424: LD_INT 1
17426: PPUSH
17427: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
17431: LD_VAR 0 8
17435: PPUSH
17436: LD_VAR 0 9
17440: PPUSH
17441: LD_VAR 0 6
17445: PPUSH
17446: LD_VAR 0 7
17450: PPUSH
17451: CALL_OW 330
// repeat wait ( 1 ) ;
17455: LD_INT 1
17457: PPUSH
17458: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
17462: LD_VAR 0 1
17466: PPUSH
17467: CALL_OW 316
17471: PUSH
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL_OW 314
17481: OR
17482: PUSH
17483: LD_VAR 0 1
17487: PPUSH
17488: CALL_OW 302
17492: NOT
17493: OR
17494: PUSH
17495: LD_VAR 0 1
17499: PPUSH
17500: CALL_OW 301
17504: OR
17505: IFFALSE 17455
// RemoveSeeing ( _x , _y , side ) ;
17507: LD_VAR 0 8
17511: PPUSH
17512: LD_VAR 0 9
17516: PPUSH
17517: LD_VAR 0 6
17521: PPUSH
17522: CALL_OW 331
// end ; end_of_file end_of_file
17526: LD_VAR 0 4
17530: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17531: LD_INT 0
17533: PPUSH
17534: PPUSH
// if exist_mode then
17535: LD_VAR 0 2
17539: IFFALSE 17564
// unit := CreateCharacter ( prefix & ident ) else
17541: LD_ADDR_VAR 0 5
17545: PUSH
17546: LD_VAR 0 3
17550: PUSH
17551: LD_VAR 0 1
17555: STR
17556: PPUSH
17557: CALL_OW 34
17561: ST_TO_ADDR
17562: GO 17579
// unit := NewCharacter ( ident ) ;
17564: LD_ADDR_VAR 0 5
17568: PUSH
17569: LD_VAR 0 1
17573: PPUSH
17574: CALL_OW 25
17578: ST_TO_ADDR
// result := unit ;
17579: LD_ADDR_VAR 0 4
17583: PUSH
17584: LD_VAR 0 5
17588: ST_TO_ADDR
// end ;
17589: LD_VAR 0 4
17593: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17594: LD_INT 0
17596: PPUSH
17597: PPUSH
// if not side or not nation then
17598: LD_VAR 0 1
17602: NOT
17603: PUSH
17604: LD_VAR 0 2
17608: NOT
17609: OR
17610: IFFALSE 17614
// exit ;
17612: GO 18378
// case nation of nation_american :
17614: LD_VAR 0 2
17618: PUSH
17619: LD_INT 1
17621: DOUBLE
17622: EQUAL
17623: IFTRUE 17627
17625: GO 17841
17627: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17628: LD_ADDR_VAR 0 4
17632: PUSH
17633: LD_INT 35
17635: PUSH
17636: LD_INT 45
17638: PUSH
17639: LD_INT 46
17641: PUSH
17642: LD_INT 47
17644: PUSH
17645: LD_INT 82
17647: PUSH
17648: LD_INT 83
17650: PUSH
17651: LD_INT 84
17653: PUSH
17654: LD_INT 85
17656: PUSH
17657: LD_INT 86
17659: PUSH
17660: LD_INT 1
17662: PUSH
17663: LD_INT 2
17665: PUSH
17666: LD_INT 6
17668: PUSH
17669: LD_INT 15
17671: PUSH
17672: LD_INT 16
17674: PUSH
17675: LD_INT 7
17677: PUSH
17678: LD_INT 12
17680: PUSH
17681: LD_INT 13
17683: PUSH
17684: LD_INT 10
17686: PUSH
17687: LD_INT 14
17689: PUSH
17690: LD_INT 20
17692: PUSH
17693: LD_INT 21
17695: PUSH
17696: LD_INT 22
17698: PUSH
17699: LD_INT 25
17701: PUSH
17702: LD_INT 32
17704: PUSH
17705: LD_INT 27
17707: PUSH
17708: LD_INT 36
17710: PUSH
17711: LD_INT 69
17713: PUSH
17714: LD_INT 39
17716: PUSH
17717: LD_INT 34
17719: PUSH
17720: LD_INT 40
17722: PUSH
17723: LD_INT 48
17725: PUSH
17726: LD_INT 49
17728: PUSH
17729: LD_INT 50
17731: PUSH
17732: LD_INT 51
17734: PUSH
17735: LD_INT 52
17737: PUSH
17738: LD_INT 53
17740: PUSH
17741: LD_INT 54
17743: PUSH
17744: LD_INT 55
17746: PUSH
17747: LD_INT 56
17749: PUSH
17750: LD_INT 57
17752: PUSH
17753: LD_INT 58
17755: PUSH
17756: LD_INT 59
17758: PUSH
17759: LD_INT 60
17761: PUSH
17762: LD_INT 61
17764: PUSH
17765: LD_INT 62
17767: PUSH
17768: LD_INT 80
17770: PUSH
17771: LD_INT 82
17773: PUSH
17774: LD_INT 83
17776: PUSH
17777: LD_INT 84
17779: PUSH
17780: LD_INT 85
17782: PUSH
17783: LD_INT 86
17785: PUSH
17786: EMPTY
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: ST_TO_ADDR
17839: GO 18302
17841: LD_INT 2
17843: DOUBLE
17844: EQUAL
17845: IFTRUE 17849
17847: GO 18071
17849: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
17850: LD_ADDR_VAR 0 4
17854: PUSH
17855: LD_INT 35
17857: PUSH
17858: LD_INT 45
17860: PUSH
17861: LD_INT 46
17863: PUSH
17864: LD_INT 47
17866: PUSH
17867: LD_INT 82
17869: PUSH
17870: LD_INT 83
17872: PUSH
17873: LD_INT 84
17875: PUSH
17876: LD_INT 85
17878: PUSH
17879: LD_INT 87
17881: PUSH
17882: LD_INT 70
17884: PUSH
17885: LD_INT 1
17887: PUSH
17888: LD_INT 11
17890: PUSH
17891: LD_INT 3
17893: PUSH
17894: LD_INT 4
17896: PUSH
17897: LD_INT 5
17899: PUSH
17900: LD_INT 6
17902: PUSH
17903: LD_INT 15
17905: PUSH
17906: LD_INT 18
17908: PUSH
17909: LD_INT 7
17911: PUSH
17912: LD_INT 17
17914: PUSH
17915: LD_INT 8
17917: PUSH
17918: LD_INT 20
17920: PUSH
17921: LD_INT 21
17923: PUSH
17924: LD_INT 22
17926: PUSH
17927: LD_INT 72
17929: PUSH
17930: LD_INT 26
17932: PUSH
17933: LD_INT 69
17935: PUSH
17936: LD_INT 39
17938: PUSH
17939: LD_INT 40
17941: PUSH
17942: LD_INT 41
17944: PUSH
17945: LD_INT 42
17947: PUSH
17948: LD_INT 43
17950: PUSH
17951: LD_INT 48
17953: PUSH
17954: LD_INT 49
17956: PUSH
17957: LD_INT 50
17959: PUSH
17960: LD_INT 51
17962: PUSH
17963: LD_INT 52
17965: PUSH
17966: LD_INT 53
17968: PUSH
17969: LD_INT 54
17971: PUSH
17972: LD_INT 55
17974: PUSH
17975: LD_INT 56
17977: PUSH
17978: LD_INT 60
17980: PUSH
17981: LD_INT 61
17983: PUSH
17984: LD_INT 62
17986: PUSH
17987: LD_INT 66
17989: PUSH
17990: LD_INT 67
17992: PUSH
17993: LD_INT 68
17995: PUSH
17996: LD_INT 81
17998: PUSH
17999: LD_INT 82
18001: PUSH
18002: LD_INT 83
18004: PUSH
18005: LD_INT 84
18007: PUSH
18008: LD_INT 85
18010: PUSH
18011: LD_INT 87
18013: PUSH
18014: EMPTY
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: LIST
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: LIST
18068: ST_TO_ADDR
18069: GO 18302
18071: LD_INT 3
18073: DOUBLE
18074: EQUAL
18075: IFTRUE 18079
18077: GO 18301
18079: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
18080: LD_ADDR_VAR 0 4
18084: PUSH
18085: LD_INT 46
18087: PUSH
18088: LD_INT 47
18090: PUSH
18091: LD_INT 1
18093: PUSH
18094: LD_INT 2
18096: PUSH
18097: LD_INT 82
18099: PUSH
18100: LD_INT 83
18102: PUSH
18103: LD_INT 84
18105: PUSH
18106: LD_INT 85
18108: PUSH
18109: LD_INT 86
18111: PUSH
18112: LD_INT 11
18114: PUSH
18115: LD_INT 9
18117: PUSH
18118: LD_INT 20
18120: PUSH
18121: LD_INT 19
18123: PUSH
18124: LD_INT 21
18126: PUSH
18127: LD_INT 24
18129: PUSH
18130: LD_INT 22
18132: PUSH
18133: LD_INT 25
18135: PUSH
18136: LD_INT 28
18138: PUSH
18139: LD_INT 29
18141: PUSH
18142: LD_INT 30
18144: PUSH
18145: LD_INT 31
18147: PUSH
18148: LD_INT 37
18150: PUSH
18151: LD_INT 38
18153: PUSH
18154: LD_INT 32
18156: PUSH
18157: LD_INT 27
18159: PUSH
18160: LD_INT 33
18162: PUSH
18163: LD_INT 69
18165: PUSH
18166: LD_INT 39
18168: PUSH
18169: LD_INT 34
18171: PUSH
18172: LD_INT 40
18174: PUSH
18175: LD_INT 71
18177: PUSH
18178: LD_INT 23
18180: PUSH
18181: LD_INT 44
18183: PUSH
18184: LD_INT 48
18186: PUSH
18187: LD_INT 49
18189: PUSH
18190: LD_INT 50
18192: PUSH
18193: LD_INT 51
18195: PUSH
18196: LD_INT 52
18198: PUSH
18199: LD_INT 53
18201: PUSH
18202: LD_INT 54
18204: PUSH
18205: LD_INT 55
18207: PUSH
18208: LD_INT 56
18210: PUSH
18211: LD_INT 57
18213: PUSH
18214: LD_INT 58
18216: PUSH
18217: LD_INT 59
18219: PUSH
18220: LD_INT 63
18222: PUSH
18223: LD_INT 64
18225: PUSH
18226: LD_INT 65
18228: PUSH
18229: LD_INT 82
18231: PUSH
18232: LD_INT 83
18234: PUSH
18235: LD_INT 84
18237: PUSH
18238: LD_INT 85
18240: PUSH
18241: LD_INT 86
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: LIST
18281: LIST
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: ST_TO_ADDR
18299: GO 18302
18301: POP
// if state > - 1 and state < 3 then
18302: LD_VAR 0 3
18306: PUSH
18307: LD_INT 1
18309: NEG
18310: GREATER
18311: PUSH
18312: LD_VAR 0 3
18316: PUSH
18317: LD_INT 3
18319: LESS
18320: AND
18321: IFFALSE 18378
// for i in result do
18323: LD_ADDR_VAR 0 5
18327: PUSH
18328: LD_VAR 0 4
18332: PUSH
18333: FOR_IN
18334: IFFALSE 18376
// if GetTech ( i , side ) <> state then
18336: LD_VAR 0 5
18340: PPUSH
18341: LD_VAR 0 1
18345: PPUSH
18346: CALL_OW 321
18350: PUSH
18351: LD_VAR 0 3
18355: NONEQUAL
18356: IFFALSE 18374
// result := result diff i ;
18358: LD_ADDR_VAR 0 4
18362: PUSH
18363: LD_VAR 0 4
18367: PUSH
18368: LD_VAR 0 5
18372: DIFF
18373: ST_TO_ADDR
18374: GO 18333
18376: POP
18377: POP
// end ;
18378: LD_VAR 0 4
18382: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18383: LD_INT 0
18385: PPUSH
18386: PPUSH
18387: PPUSH
// result := true ;
18388: LD_ADDR_VAR 0 3
18392: PUSH
18393: LD_INT 1
18395: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18396: LD_ADDR_VAR 0 5
18400: PUSH
18401: LD_VAR 0 2
18405: PPUSH
18406: CALL_OW 480
18410: ST_TO_ADDR
// if not tmp then
18411: LD_VAR 0 5
18415: NOT
18416: IFFALSE 18420
// exit ;
18418: GO 18469
// for i in tmp do
18420: LD_ADDR_VAR 0 4
18424: PUSH
18425: LD_VAR 0 5
18429: PUSH
18430: FOR_IN
18431: IFFALSE 18467
// if GetTech ( i , side ) <> state_researched then
18433: LD_VAR 0 4
18437: PPUSH
18438: LD_VAR 0 1
18442: PPUSH
18443: CALL_OW 321
18447: PUSH
18448: LD_INT 2
18450: NONEQUAL
18451: IFFALSE 18465
// begin result := false ;
18453: LD_ADDR_VAR 0 3
18457: PUSH
18458: LD_INT 0
18460: ST_TO_ADDR
// exit ;
18461: POP
18462: POP
18463: GO 18469
// end ;
18465: GO 18430
18467: POP
18468: POP
// end ;
18469: LD_VAR 0 3
18473: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18474: LD_INT 0
18476: PPUSH
18477: PPUSH
18478: PPUSH
18479: PPUSH
18480: PPUSH
18481: PPUSH
18482: PPUSH
18483: PPUSH
18484: PPUSH
18485: PPUSH
18486: PPUSH
18487: PPUSH
18488: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18489: LD_VAR 0 1
18493: NOT
18494: PUSH
18495: LD_VAR 0 1
18499: PPUSH
18500: CALL_OW 257
18504: PUSH
18505: LD_INT 9
18507: NONEQUAL
18508: OR
18509: IFFALSE 18513
// exit ;
18511: GO 19086
// side := GetSide ( unit ) ;
18513: LD_ADDR_VAR 0 9
18517: PUSH
18518: LD_VAR 0 1
18522: PPUSH
18523: CALL_OW 255
18527: ST_TO_ADDR
// tech_space := tech_spacanom ;
18528: LD_ADDR_VAR 0 12
18532: PUSH
18533: LD_INT 29
18535: ST_TO_ADDR
// tech_time := tech_taurad ;
18536: LD_ADDR_VAR 0 13
18540: PUSH
18541: LD_INT 28
18543: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18544: LD_ADDR_VAR 0 11
18548: PUSH
18549: LD_VAR 0 1
18553: PPUSH
18554: CALL_OW 310
18558: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18559: LD_VAR 0 11
18563: PPUSH
18564: CALL_OW 247
18568: PUSH
18569: LD_INT 2
18571: EQUAL
18572: IFFALSE 18576
// exit ;
18574: GO 19086
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18576: LD_ADDR_VAR 0 8
18580: PUSH
18581: LD_INT 81
18583: PUSH
18584: LD_VAR 0 9
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 3
18595: PUSH
18596: LD_INT 21
18598: PUSH
18599: LD_INT 3
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PPUSH
18614: CALL_OW 69
18618: ST_TO_ADDR
// if not tmp then
18619: LD_VAR 0 8
18623: NOT
18624: IFFALSE 18628
// exit ;
18626: GO 19086
// if in_unit then
18628: LD_VAR 0 11
18632: IFFALSE 18656
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18634: LD_ADDR_VAR 0 10
18638: PUSH
18639: LD_VAR 0 8
18643: PPUSH
18644: LD_VAR 0 11
18648: PPUSH
18649: CALL_OW 74
18653: ST_TO_ADDR
18654: GO 18676
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18656: LD_ADDR_VAR 0 10
18660: PUSH
18661: LD_VAR 0 8
18665: PPUSH
18666: LD_VAR 0 1
18670: PPUSH
18671: CALL_OW 74
18675: ST_TO_ADDR
// if not enemy then
18676: LD_VAR 0 10
18680: NOT
18681: IFFALSE 18685
// exit ;
18683: GO 19086
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18685: LD_VAR 0 11
18689: PUSH
18690: LD_VAR 0 11
18694: PPUSH
18695: LD_VAR 0 10
18699: PPUSH
18700: CALL_OW 296
18704: PUSH
18705: LD_INT 13
18707: GREATER
18708: AND
18709: PUSH
18710: LD_VAR 0 1
18714: PPUSH
18715: LD_VAR 0 10
18719: PPUSH
18720: CALL_OW 296
18724: PUSH
18725: LD_INT 12
18727: GREATER
18728: OR
18729: IFFALSE 18733
// exit ;
18731: GO 19086
// missile := [ 1 ] ;
18733: LD_ADDR_VAR 0 14
18737: PUSH
18738: LD_INT 1
18740: PUSH
18741: EMPTY
18742: LIST
18743: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18744: LD_VAR 0 9
18748: PPUSH
18749: LD_VAR 0 12
18753: PPUSH
18754: CALL_OW 325
18758: IFFALSE 18787
// missile := Insert ( missile , missile + 1 , 2 ) ;
18760: LD_ADDR_VAR 0 14
18764: PUSH
18765: LD_VAR 0 14
18769: PPUSH
18770: LD_VAR 0 14
18774: PUSH
18775: LD_INT 1
18777: PLUS
18778: PPUSH
18779: LD_INT 2
18781: PPUSH
18782: CALL_OW 2
18786: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18787: LD_VAR 0 9
18791: PPUSH
18792: LD_VAR 0 13
18796: PPUSH
18797: CALL_OW 325
18801: PUSH
18802: LD_VAR 0 10
18806: PPUSH
18807: CALL_OW 255
18811: PPUSH
18812: LD_VAR 0 13
18816: PPUSH
18817: CALL_OW 325
18821: NOT
18822: AND
18823: IFFALSE 18852
// missile := Insert ( missile , missile + 1 , 3 ) ;
18825: LD_ADDR_VAR 0 14
18829: PUSH
18830: LD_VAR 0 14
18834: PPUSH
18835: LD_VAR 0 14
18839: PUSH
18840: LD_INT 1
18842: PLUS
18843: PPUSH
18844: LD_INT 3
18846: PPUSH
18847: CALL_OW 2
18851: ST_TO_ADDR
// if missile < 2 then
18852: LD_VAR 0 14
18856: PUSH
18857: LD_INT 2
18859: LESS
18860: IFFALSE 18864
// exit ;
18862: GO 19086
// x := GetX ( enemy ) ;
18864: LD_ADDR_VAR 0 4
18868: PUSH
18869: LD_VAR 0 10
18873: PPUSH
18874: CALL_OW 250
18878: ST_TO_ADDR
// y := GetY ( enemy ) ;
18879: LD_ADDR_VAR 0 5
18883: PUSH
18884: LD_VAR 0 10
18888: PPUSH
18889: CALL_OW 251
18893: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18894: LD_ADDR_VAR 0 6
18898: PUSH
18899: LD_VAR 0 4
18903: PUSH
18904: LD_INT 1
18906: NEG
18907: PPUSH
18908: LD_INT 1
18910: PPUSH
18911: CALL_OW 12
18915: PLUS
18916: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18917: LD_ADDR_VAR 0 7
18921: PUSH
18922: LD_VAR 0 5
18926: PUSH
18927: LD_INT 1
18929: NEG
18930: PPUSH
18931: LD_INT 1
18933: PPUSH
18934: CALL_OW 12
18938: PLUS
18939: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18940: LD_VAR 0 6
18944: PPUSH
18945: LD_VAR 0 7
18949: PPUSH
18950: CALL_OW 488
18954: NOT
18955: IFFALSE 18977
// begin _x := x ;
18957: LD_ADDR_VAR 0 6
18961: PUSH
18962: LD_VAR 0 4
18966: ST_TO_ADDR
// _y := y ;
18967: LD_ADDR_VAR 0 7
18971: PUSH
18972: LD_VAR 0 5
18976: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18977: LD_ADDR_VAR 0 3
18981: PUSH
18982: LD_INT 1
18984: PPUSH
18985: LD_VAR 0 14
18989: PPUSH
18990: CALL_OW 12
18994: ST_TO_ADDR
// case i of 1 :
18995: LD_VAR 0 3
18999: PUSH
19000: LD_INT 1
19002: DOUBLE
19003: EQUAL
19004: IFTRUE 19008
19006: GO 19025
19008: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
19009: LD_VAR 0 1
19013: PPUSH
19014: LD_VAR 0 10
19018: PPUSH
19019: CALL_OW 115
19023: GO 19086
19025: LD_INT 2
19027: DOUBLE
19028: EQUAL
19029: IFTRUE 19033
19031: GO 19055
19033: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_VAR 0 6
19043: PPUSH
19044: LD_VAR 0 7
19048: PPUSH
19049: CALL_OW 153
19053: GO 19086
19055: LD_INT 3
19057: DOUBLE
19058: EQUAL
19059: IFTRUE 19063
19061: GO 19085
19063: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19064: LD_VAR 0 1
19068: PPUSH
19069: LD_VAR 0 6
19073: PPUSH
19074: LD_VAR 0 7
19078: PPUSH
19079: CALL_OW 154
19083: GO 19086
19085: POP
// end ;
19086: LD_VAR 0 2
19090: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19091: LD_INT 0
19093: PPUSH
19094: PPUSH
19095: PPUSH
19096: PPUSH
19097: PPUSH
19098: PPUSH
// if not unit or not building then
19099: LD_VAR 0 1
19103: NOT
19104: PUSH
19105: LD_VAR 0 2
19109: NOT
19110: OR
19111: IFFALSE 19115
// exit ;
19113: GO 19273
// x := GetX ( building ) ;
19115: LD_ADDR_VAR 0 5
19119: PUSH
19120: LD_VAR 0 2
19124: PPUSH
19125: CALL_OW 250
19129: ST_TO_ADDR
// y := GetY ( building ) ;
19130: LD_ADDR_VAR 0 6
19134: PUSH
19135: LD_VAR 0 2
19139: PPUSH
19140: CALL_OW 251
19144: ST_TO_ADDR
// for i = 0 to 5 do
19145: LD_ADDR_VAR 0 4
19149: PUSH
19150: DOUBLE
19151: LD_INT 0
19153: DEC
19154: ST_TO_ADDR
19155: LD_INT 5
19157: PUSH
19158: FOR_TO
19159: IFFALSE 19271
// begin _x := ShiftX ( x , i , 3 ) ;
19161: LD_ADDR_VAR 0 7
19165: PUSH
19166: LD_VAR 0 5
19170: PPUSH
19171: LD_VAR 0 4
19175: PPUSH
19176: LD_INT 3
19178: PPUSH
19179: CALL_OW 272
19183: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19184: LD_ADDR_VAR 0 8
19188: PUSH
19189: LD_VAR 0 6
19193: PPUSH
19194: LD_VAR 0 4
19198: PPUSH
19199: LD_INT 3
19201: PPUSH
19202: CALL_OW 273
19206: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19207: LD_VAR 0 7
19211: PPUSH
19212: LD_VAR 0 8
19216: PPUSH
19217: CALL_OW 488
19221: NOT
19222: IFFALSE 19226
// continue ;
19224: GO 19158
// if HexInfo ( _x , _y ) = 0 then
19226: LD_VAR 0 7
19230: PPUSH
19231: LD_VAR 0 8
19235: PPUSH
19236: CALL_OW 428
19240: PUSH
19241: LD_INT 0
19243: EQUAL
19244: IFFALSE 19269
// begin ComMoveXY ( unit , _x , _y ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: LD_VAR 0 7
19255: PPUSH
19256: LD_VAR 0 8
19260: PPUSH
19261: CALL_OW 111
// exit ;
19265: POP
19266: POP
19267: GO 19273
// end ; end ;
19269: GO 19158
19271: POP
19272: POP
// end ;
19273: LD_VAR 0 3
19277: RET
// export function ScanBase ( side , base_area ) ; begin
19278: LD_INT 0
19280: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19281: LD_ADDR_VAR 0 3
19285: PUSH
19286: LD_VAR 0 2
19290: PPUSH
19291: LD_INT 81
19293: PUSH
19294: LD_VAR 0 1
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: PPUSH
19303: CALL_OW 70
19307: ST_TO_ADDR
// end ;
19308: LD_VAR 0 3
19312: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19313: LD_INT 0
19315: PPUSH
19316: PPUSH
19317: PPUSH
19318: PPUSH
// result := false ;
19319: LD_ADDR_VAR 0 2
19323: PUSH
19324: LD_INT 0
19326: ST_TO_ADDR
// side := GetSide ( unit ) ;
19327: LD_ADDR_VAR 0 3
19331: PUSH
19332: LD_VAR 0 1
19336: PPUSH
19337: CALL_OW 255
19341: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19342: LD_ADDR_VAR 0 4
19346: PUSH
19347: LD_VAR 0 1
19351: PPUSH
19352: CALL_OW 248
19356: ST_TO_ADDR
// case nat of 1 :
19357: LD_VAR 0 4
19361: PUSH
19362: LD_INT 1
19364: DOUBLE
19365: EQUAL
19366: IFTRUE 19370
19368: GO 19381
19370: POP
// tech := tech_lassight ; 2 :
19371: LD_ADDR_VAR 0 5
19375: PUSH
19376: LD_INT 12
19378: ST_TO_ADDR
19379: GO 19420
19381: LD_INT 2
19383: DOUBLE
19384: EQUAL
19385: IFTRUE 19389
19387: GO 19400
19389: POP
// tech := tech_mortar ; 3 :
19390: LD_ADDR_VAR 0 5
19394: PUSH
19395: LD_INT 41
19397: ST_TO_ADDR
19398: GO 19420
19400: LD_INT 3
19402: DOUBLE
19403: EQUAL
19404: IFTRUE 19408
19406: GO 19419
19408: POP
// tech := tech_bazooka ; end ;
19409: LD_ADDR_VAR 0 5
19413: PUSH
19414: LD_INT 44
19416: ST_TO_ADDR
19417: GO 19420
19419: POP
// if Researched ( side , tech ) then
19420: LD_VAR 0 3
19424: PPUSH
19425: LD_VAR 0 5
19429: PPUSH
19430: CALL_OW 325
19434: IFFALSE 19461
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19436: LD_ADDR_VAR 0 2
19440: PUSH
19441: LD_INT 5
19443: PUSH
19444: LD_INT 8
19446: PUSH
19447: LD_INT 9
19449: PUSH
19450: EMPTY
19451: LIST
19452: LIST
19453: LIST
19454: PUSH
19455: LD_VAR 0 4
19459: ARRAY
19460: ST_TO_ADDR
// end ;
19461: LD_VAR 0 2
19465: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19466: LD_INT 0
19468: PPUSH
19469: PPUSH
19470: PPUSH
// if not mines then
19471: LD_VAR 0 2
19475: NOT
19476: IFFALSE 19480
// exit ;
19478: GO 19624
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19480: LD_ADDR_VAR 0 5
19484: PUSH
19485: LD_INT 81
19487: PUSH
19488: LD_VAR 0 1
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: PUSH
19497: LD_INT 3
19499: PUSH
19500: LD_INT 21
19502: PUSH
19503: LD_INT 3
19505: PUSH
19506: EMPTY
19507: LIST
19508: LIST
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: PUSH
19514: EMPTY
19515: LIST
19516: LIST
19517: PPUSH
19518: CALL_OW 69
19522: ST_TO_ADDR
// for i in mines do
19523: LD_ADDR_VAR 0 4
19527: PUSH
19528: LD_VAR 0 2
19532: PUSH
19533: FOR_IN
19534: IFFALSE 19622
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19536: LD_VAR 0 4
19540: PUSH
19541: LD_INT 1
19543: ARRAY
19544: PPUSH
19545: LD_VAR 0 4
19549: PUSH
19550: LD_INT 2
19552: ARRAY
19553: PPUSH
19554: CALL_OW 458
19558: NOT
19559: IFFALSE 19563
// continue ;
19561: GO 19533
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19563: LD_VAR 0 4
19567: PUSH
19568: LD_INT 1
19570: ARRAY
19571: PPUSH
19572: LD_VAR 0 4
19576: PUSH
19577: LD_INT 2
19579: ARRAY
19580: PPUSH
19581: CALL_OW 428
19585: PUSH
19586: LD_VAR 0 5
19590: IN
19591: IFFALSE 19620
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19593: LD_VAR 0 4
19597: PUSH
19598: LD_INT 1
19600: ARRAY
19601: PPUSH
19602: LD_VAR 0 4
19606: PUSH
19607: LD_INT 2
19609: ARRAY
19610: PPUSH
19611: LD_VAR 0 1
19615: PPUSH
19616: CALL_OW 456
// end ;
19620: GO 19533
19622: POP
19623: POP
// end ;
19624: LD_VAR 0 3
19628: RET
// export function Count ( array ) ; var i ; begin
19629: LD_INT 0
19631: PPUSH
19632: PPUSH
// result := 0 ;
19633: LD_ADDR_VAR 0 2
19637: PUSH
19638: LD_INT 0
19640: ST_TO_ADDR
// for i in array do
19641: LD_ADDR_VAR 0 3
19645: PUSH
19646: LD_VAR 0 1
19650: PUSH
19651: FOR_IN
19652: IFFALSE 19676
// if i then
19654: LD_VAR 0 3
19658: IFFALSE 19674
// result := result + 1 ;
19660: LD_ADDR_VAR 0 2
19664: PUSH
19665: LD_VAR 0 2
19669: PUSH
19670: LD_INT 1
19672: PLUS
19673: ST_TO_ADDR
19674: GO 19651
19676: POP
19677: POP
// end ;
19678: LD_VAR 0 2
19682: RET
// export function IsEmpty ( building ) ; begin
19683: LD_INT 0
19685: PPUSH
// if not building then
19686: LD_VAR 0 1
19690: NOT
19691: IFFALSE 19695
// exit ;
19693: GO 19738
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19695: LD_ADDR_VAR 0 2
19699: PUSH
19700: LD_VAR 0 1
19704: PUSH
19705: LD_INT 22
19707: PUSH
19708: LD_VAR 0 1
19712: PPUSH
19713: CALL_OW 255
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: LD_INT 58
19724: PUSH
19725: EMPTY
19726: LIST
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: PPUSH
19732: CALL_OW 69
19736: IN
19737: ST_TO_ADDR
// end ;
19738: LD_VAR 0 2
19742: RET
// export function IsNotFull ( building ) ; begin
19743: LD_INT 0
19745: PPUSH
// if not building then
19746: LD_VAR 0 1
19750: NOT
19751: IFFALSE 19755
// exit ;
19753: GO 19774
// result := UnitsInside ( building ) < 6 ;
19755: LD_ADDR_VAR 0 2
19759: PUSH
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 313
19769: PUSH
19770: LD_INT 6
19772: LESS
19773: ST_TO_ADDR
// end ;
19774: LD_VAR 0 2
19778: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19779: LD_INT 0
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
// tmp := [ ] ;
19785: LD_ADDR_VAR 0 3
19789: PUSH
19790: EMPTY
19791: ST_TO_ADDR
// list := [ ] ;
19792: LD_ADDR_VAR 0 5
19796: PUSH
19797: EMPTY
19798: ST_TO_ADDR
// for i = 16 to 25 do
19799: LD_ADDR_VAR 0 4
19803: PUSH
19804: DOUBLE
19805: LD_INT 16
19807: DEC
19808: ST_TO_ADDR
19809: LD_INT 25
19811: PUSH
19812: FOR_TO
19813: IFFALSE 19886
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19815: LD_ADDR_VAR 0 3
19819: PUSH
19820: LD_VAR 0 3
19824: PUSH
19825: LD_INT 22
19827: PUSH
19828: LD_VAR 0 1
19832: PPUSH
19833: CALL_OW 255
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PUSH
19842: LD_INT 91
19844: PUSH
19845: LD_VAR 0 1
19849: PUSH
19850: LD_INT 6
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 30
19860: PUSH
19861: LD_VAR 0 4
19865: PUSH
19866: EMPTY
19867: LIST
19868: LIST
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: LIST
19874: PUSH
19875: EMPTY
19876: LIST
19877: PPUSH
19878: CALL_OW 69
19882: ADD
19883: ST_TO_ADDR
19884: GO 19812
19886: POP
19887: POP
// for i = 1 to tmp do
19888: LD_ADDR_VAR 0 4
19892: PUSH
19893: DOUBLE
19894: LD_INT 1
19896: DEC
19897: ST_TO_ADDR
19898: LD_VAR 0 3
19902: PUSH
19903: FOR_TO
19904: IFFALSE 19992
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19906: LD_ADDR_VAR 0 5
19910: PUSH
19911: LD_VAR 0 5
19915: PUSH
19916: LD_VAR 0 3
19920: PUSH
19921: LD_VAR 0 4
19925: ARRAY
19926: PPUSH
19927: CALL_OW 266
19931: PUSH
19932: LD_VAR 0 3
19936: PUSH
19937: LD_VAR 0 4
19941: ARRAY
19942: PPUSH
19943: CALL_OW 250
19947: PUSH
19948: LD_VAR 0 3
19952: PUSH
19953: LD_VAR 0 4
19957: ARRAY
19958: PPUSH
19959: CALL_OW 251
19963: PUSH
19964: LD_VAR 0 3
19968: PUSH
19969: LD_VAR 0 4
19973: ARRAY
19974: PPUSH
19975: CALL_OW 254
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: PUSH
19986: EMPTY
19987: LIST
19988: ADD
19989: ST_TO_ADDR
19990: GO 19903
19992: POP
19993: POP
// result := list ;
19994: LD_ADDR_VAR 0 2
19998: PUSH
19999: LD_VAR 0 5
20003: ST_TO_ADDR
// end ;
20004: LD_VAR 0 2
20008: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
20009: LD_INT 0
20011: PPUSH
20012: PPUSH
20013: PPUSH
20014: PPUSH
20015: PPUSH
20016: PPUSH
20017: PPUSH
// if not factory then
20018: LD_VAR 0 1
20022: NOT
20023: IFFALSE 20027
// exit ;
20025: GO 20620
// if control = control_apeman then
20027: LD_VAR 0 4
20031: PUSH
20032: LD_INT 5
20034: EQUAL
20035: IFFALSE 20144
// begin tmp := UnitsInside ( factory ) ;
20037: LD_ADDR_VAR 0 8
20041: PUSH
20042: LD_VAR 0 1
20046: PPUSH
20047: CALL_OW 313
20051: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
20052: LD_VAR 0 8
20056: PPUSH
20057: LD_INT 25
20059: PUSH
20060: LD_INT 12
20062: PUSH
20063: EMPTY
20064: LIST
20065: LIST
20066: PPUSH
20067: CALL_OW 72
20071: NOT
20072: IFFALSE 20082
// control := control_manual ;
20074: LD_ADDR_VAR 0 4
20078: PUSH
20079: LD_INT 1
20081: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20082: LD_ADDR_VAR 0 8
20086: PUSH
20087: LD_VAR 0 1
20091: PPUSH
20092: CALL 19779 0 1
20096: ST_TO_ADDR
// if tmp then
20097: LD_VAR 0 8
20101: IFFALSE 20144
// begin for i in tmp do
20103: LD_ADDR_VAR 0 7
20107: PUSH
20108: LD_VAR 0 8
20112: PUSH
20113: FOR_IN
20114: IFFALSE 20142
// if i [ 1 ] = b_ext_radio then
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 1
20123: ARRAY
20124: PUSH
20125: LD_INT 22
20127: EQUAL
20128: IFFALSE 20140
// begin control := control_remote ;
20130: LD_ADDR_VAR 0 4
20134: PUSH
20135: LD_INT 2
20137: ST_TO_ADDR
// break ;
20138: GO 20142
// end ;
20140: GO 20113
20142: POP
20143: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20144: LD_VAR 0 1
20148: PPUSH
20149: LD_VAR 0 2
20153: PPUSH
20154: LD_VAR 0 3
20158: PPUSH
20159: LD_VAR 0 4
20163: PPUSH
20164: LD_VAR 0 5
20168: PPUSH
20169: CALL_OW 448
20173: IFFALSE 20208
// begin result := [ chassis , engine , control , weapon ] ;
20175: LD_ADDR_VAR 0 6
20179: PUSH
20180: LD_VAR 0 2
20184: PUSH
20185: LD_VAR 0 3
20189: PUSH
20190: LD_VAR 0 4
20194: PUSH
20195: LD_VAR 0 5
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: ST_TO_ADDR
// exit ;
20206: GO 20620
// end ; _chassis := AvailableChassisList ( factory ) ;
20208: LD_ADDR_VAR 0 9
20212: PUSH
20213: LD_VAR 0 1
20217: PPUSH
20218: CALL_OW 475
20222: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20223: LD_ADDR_VAR 0 11
20227: PUSH
20228: LD_VAR 0 1
20232: PPUSH
20233: CALL_OW 476
20237: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20238: LD_ADDR_VAR 0 12
20242: PUSH
20243: LD_VAR 0 1
20247: PPUSH
20248: CALL_OW 477
20252: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20253: LD_ADDR_VAR 0 10
20257: PUSH
20258: LD_VAR 0 1
20262: PPUSH
20263: CALL_OW 478
20267: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20268: LD_VAR 0 9
20272: NOT
20273: PUSH
20274: LD_VAR 0 11
20278: NOT
20279: OR
20280: PUSH
20281: LD_VAR 0 12
20285: NOT
20286: OR
20287: PUSH
20288: LD_VAR 0 10
20292: NOT
20293: OR
20294: IFFALSE 20329
// begin result := [ chassis , engine , control , weapon ] ;
20296: LD_ADDR_VAR 0 6
20300: PUSH
20301: LD_VAR 0 2
20305: PUSH
20306: LD_VAR 0 3
20310: PUSH
20311: LD_VAR 0 4
20315: PUSH
20316: LD_VAR 0 5
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: ST_TO_ADDR
// exit ;
20327: GO 20620
// end ; if not chassis in _chassis then
20329: LD_VAR 0 2
20333: PUSH
20334: LD_VAR 0 9
20338: IN
20339: NOT
20340: IFFALSE 20366
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20342: LD_ADDR_VAR 0 2
20346: PUSH
20347: LD_VAR 0 9
20351: PUSH
20352: LD_INT 1
20354: PPUSH
20355: LD_VAR 0 9
20359: PPUSH
20360: CALL_OW 12
20364: ARRAY
20365: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20366: LD_VAR 0 2
20370: PPUSH
20371: LD_VAR 0 3
20375: PPUSH
20376: CALL 20625 0 2
20380: NOT
20381: IFFALSE 20440
// repeat engine := _engine [ 1 ] ;
20383: LD_ADDR_VAR 0 3
20387: PUSH
20388: LD_VAR 0 11
20392: PUSH
20393: LD_INT 1
20395: ARRAY
20396: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20397: LD_ADDR_VAR 0 11
20401: PUSH
20402: LD_VAR 0 11
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 3
20414: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20415: LD_VAR 0 2
20419: PPUSH
20420: LD_VAR 0 3
20424: PPUSH
20425: CALL 20625 0 2
20429: PUSH
20430: LD_VAR 0 11
20434: PUSH
20435: EMPTY
20436: EQUAL
20437: OR
20438: IFFALSE 20383
// if not control in _control then
20440: LD_VAR 0 4
20444: PUSH
20445: LD_VAR 0 12
20449: IN
20450: NOT
20451: IFFALSE 20477
// control := _control [ rand ( 1 , _control ) ] ;
20453: LD_ADDR_VAR 0 4
20457: PUSH
20458: LD_VAR 0 12
20462: PUSH
20463: LD_INT 1
20465: PPUSH
20466: LD_VAR 0 12
20470: PPUSH
20471: CALL_OW 12
20475: ARRAY
20476: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20477: LD_VAR 0 2
20481: PPUSH
20482: LD_VAR 0 5
20486: PPUSH
20487: CALL 20845 0 2
20491: NOT
20492: IFFALSE 20551
// repeat weapon := _weapon [ 1 ] ;
20494: LD_ADDR_VAR 0 5
20498: PUSH
20499: LD_VAR 0 10
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20508: LD_ADDR_VAR 0 10
20512: PUSH
20513: LD_VAR 0 10
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: CALL_OW 3
20525: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20526: LD_VAR 0 2
20530: PPUSH
20531: LD_VAR 0 5
20535: PPUSH
20536: CALL 20845 0 2
20540: PUSH
20541: LD_VAR 0 10
20545: PUSH
20546: EMPTY
20547: EQUAL
20548: OR
20549: IFFALSE 20494
// result := [ ] ;
20551: LD_ADDR_VAR 0 6
20555: PUSH
20556: EMPTY
20557: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20558: LD_VAR 0 1
20562: PPUSH
20563: LD_VAR 0 2
20567: PPUSH
20568: LD_VAR 0 3
20572: PPUSH
20573: LD_VAR 0 4
20577: PPUSH
20578: LD_VAR 0 5
20582: PPUSH
20583: CALL_OW 448
20587: IFFALSE 20620
// result := [ chassis , engine , control , weapon ] ;
20589: LD_ADDR_VAR 0 6
20593: PUSH
20594: LD_VAR 0 2
20598: PUSH
20599: LD_VAR 0 3
20603: PUSH
20604: LD_VAR 0 4
20608: PUSH
20609: LD_VAR 0 5
20613: PUSH
20614: EMPTY
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: ST_TO_ADDR
// end ;
20620: LD_VAR 0 6
20624: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20625: LD_INT 0
20627: PPUSH
// if not chassis or not engine then
20628: LD_VAR 0 1
20632: NOT
20633: PUSH
20634: LD_VAR 0 2
20638: NOT
20639: OR
20640: IFFALSE 20644
// exit ;
20642: GO 20840
// case engine of engine_solar :
20644: LD_VAR 0 2
20648: PUSH
20649: LD_INT 2
20651: DOUBLE
20652: EQUAL
20653: IFTRUE 20657
20655: GO 20695
20657: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20658: LD_ADDR_VAR 0 3
20662: PUSH
20663: LD_INT 11
20665: PUSH
20666: LD_INT 12
20668: PUSH
20669: LD_INT 13
20671: PUSH
20672: LD_INT 14
20674: PUSH
20675: LD_INT 1
20677: PUSH
20678: LD_INT 2
20680: PUSH
20681: LD_INT 3
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: LIST
20690: LIST
20691: LIST
20692: ST_TO_ADDR
20693: GO 20824
20695: LD_INT 1
20697: DOUBLE
20698: EQUAL
20699: IFTRUE 20703
20701: GO 20765
20703: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20704: LD_ADDR_VAR 0 3
20708: PUSH
20709: LD_INT 11
20711: PUSH
20712: LD_INT 12
20714: PUSH
20715: LD_INT 13
20717: PUSH
20718: LD_INT 14
20720: PUSH
20721: LD_INT 1
20723: PUSH
20724: LD_INT 2
20726: PUSH
20727: LD_INT 3
20729: PUSH
20730: LD_INT 4
20732: PUSH
20733: LD_INT 5
20735: PUSH
20736: LD_INT 21
20738: PUSH
20739: LD_INT 23
20741: PUSH
20742: LD_INT 22
20744: PUSH
20745: LD_INT 24
20747: PUSH
20748: EMPTY
20749: LIST
20750: LIST
20751: LIST
20752: LIST
20753: LIST
20754: LIST
20755: LIST
20756: LIST
20757: LIST
20758: LIST
20759: LIST
20760: LIST
20761: LIST
20762: ST_TO_ADDR
20763: GO 20824
20765: LD_INT 3
20767: DOUBLE
20768: EQUAL
20769: IFTRUE 20773
20771: GO 20823
20773: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20774: LD_ADDR_VAR 0 3
20778: PUSH
20779: LD_INT 13
20781: PUSH
20782: LD_INT 14
20784: PUSH
20785: LD_INT 2
20787: PUSH
20788: LD_INT 3
20790: PUSH
20791: LD_INT 4
20793: PUSH
20794: LD_INT 5
20796: PUSH
20797: LD_INT 21
20799: PUSH
20800: LD_INT 22
20802: PUSH
20803: LD_INT 23
20805: PUSH
20806: LD_INT 24
20808: PUSH
20809: EMPTY
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: ST_TO_ADDR
20821: GO 20824
20823: POP
// result := ( chassis in result ) ;
20824: LD_ADDR_VAR 0 3
20828: PUSH
20829: LD_VAR 0 1
20833: PUSH
20834: LD_VAR 0 3
20838: IN
20839: ST_TO_ADDR
// end ;
20840: LD_VAR 0 3
20844: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20845: LD_INT 0
20847: PPUSH
// if not chassis or not weapon then
20848: LD_VAR 0 1
20852: NOT
20853: PUSH
20854: LD_VAR 0 2
20858: NOT
20859: OR
20860: IFFALSE 20864
// exit ;
20862: GO 21890
// case weapon of us_machine_gun :
20864: LD_VAR 0 2
20868: PUSH
20869: LD_INT 2
20871: DOUBLE
20872: EQUAL
20873: IFTRUE 20877
20875: GO 20907
20877: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20878: LD_ADDR_VAR 0 3
20882: PUSH
20883: LD_INT 1
20885: PUSH
20886: LD_INT 2
20888: PUSH
20889: LD_INT 3
20891: PUSH
20892: LD_INT 4
20894: PUSH
20895: LD_INT 5
20897: PUSH
20898: EMPTY
20899: LIST
20900: LIST
20901: LIST
20902: LIST
20903: LIST
20904: ST_TO_ADDR
20905: GO 21874
20907: LD_INT 3
20909: DOUBLE
20910: EQUAL
20911: IFTRUE 20915
20913: GO 20945
20915: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20916: LD_ADDR_VAR 0 3
20920: PUSH
20921: LD_INT 1
20923: PUSH
20924: LD_INT 2
20926: PUSH
20927: LD_INT 3
20929: PUSH
20930: LD_INT 4
20932: PUSH
20933: LD_INT 5
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: LIST
20942: ST_TO_ADDR
20943: GO 21874
20945: LD_INT 11
20947: DOUBLE
20948: EQUAL
20949: IFTRUE 20953
20951: GO 20983
20953: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20954: LD_ADDR_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: PUSH
20962: LD_INT 2
20964: PUSH
20965: LD_INT 3
20967: PUSH
20968: LD_INT 4
20970: PUSH
20971: LD_INT 5
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: LIST
20980: ST_TO_ADDR
20981: GO 21874
20983: LD_INT 4
20985: DOUBLE
20986: EQUAL
20987: IFTRUE 20991
20989: GO 21017
20991: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20992: LD_ADDR_VAR 0 3
20996: PUSH
20997: LD_INT 2
20999: PUSH
21000: LD_INT 3
21002: PUSH
21003: LD_INT 4
21005: PUSH
21006: LD_INT 5
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: ST_TO_ADDR
21015: GO 21874
21017: LD_INT 5
21019: DOUBLE
21020: EQUAL
21021: IFTRUE 21025
21023: GO 21051
21025: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
21026: LD_ADDR_VAR 0 3
21030: PUSH
21031: LD_INT 2
21033: PUSH
21034: LD_INT 3
21036: PUSH
21037: LD_INT 4
21039: PUSH
21040: LD_INT 5
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: LIST
21048: ST_TO_ADDR
21049: GO 21874
21051: LD_INT 9
21053: DOUBLE
21054: EQUAL
21055: IFTRUE 21059
21057: GO 21085
21059: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21060: LD_ADDR_VAR 0 3
21064: PUSH
21065: LD_INT 2
21067: PUSH
21068: LD_INT 3
21070: PUSH
21071: LD_INT 4
21073: PUSH
21074: LD_INT 5
21076: PUSH
21077: EMPTY
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: ST_TO_ADDR
21083: GO 21874
21085: LD_INT 7
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21093
21091: GO 21119
21093: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21094: LD_ADDR_VAR 0 3
21098: PUSH
21099: LD_INT 2
21101: PUSH
21102: LD_INT 3
21104: PUSH
21105: LD_INT 4
21107: PUSH
21108: LD_INT 5
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: ST_TO_ADDR
21117: GO 21874
21119: LD_INT 12
21121: DOUBLE
21122: EQUAL
21123: IFTRUE 21127
21125: GO 21153
21127: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21128: LD_ADDR_VAR 0 3
21132: PUSH
21133: LD_INT 2
21135: PUSH
21136: LD_INT 3
21138: PUSH
21139: LD_INT 4
21141: PUSH
21142: LD_INT 5
21144: PUSH
21145: EMPTY
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: ST_TO_ADDR
21151: GO 21874
21153: LD_INT 13
21155: DOUBLE
21156: EQUAL
21157: IFTRUE 21161
21159: GO 21187
21161: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21162: LD_ADDR_VAR 0 3
21166: PUSH
21167: LD_INT 2
21169: PUSH
21170: LD_INT 3
21172: PUSH
21173: LD_INT 4
21175: PUSH
21176: LD_INT 5
21178: PUSH
21179: EMPTY
21180: LIST
21181: LIST
21182: LIST
21183: LIST
21184: ST_TO_ADDR
21185: GO 21874
21187: LD_INT 14
21189: DOUBLE
21190: EQUAL
21191: IFTRUE 21195
21193: GO 21213
21195: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21196: LD_ADDR_VAR 0 3
21200: PUSH
21201: LD_INT 4
21203: PUSH
21204: LD_INT 5
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: ST_TO_ADDR
21211: GO 21874
21213: LD_INT 6
21215: DOUBLE
21216: EQUAL
21217: IFTRUE 21221
21219: GO 21239
21221: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21222: LD_ADDR_VAR 0 3
21226: PUSH
21227: LD_INT 4
21229: PUSH
21230: LD_INT 5
21232: PUSH
21233: EMPTY
21234: LIST
21235: LIST
21236: ST_TO_ADDR
21237: GO 21874
21239: LD_INT 10
21241: DOUBLE
21242: EQUAL
21243: IFTRUE 21247
21245: GO 21265
21247: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21248: LD_ADDR_VAR 0 3
21252: PUSH
21253: LD_INT 4
21255: PUSH
21256: LD_INT 5
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: ST_TO_ADDR
21263: GO 21874
21265: LD_INT 22
21267: DOUBLE
21268: EQUAL
21269: IFTRUE 21273
21271: GO 21299
21273: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21274: LD_ADDR_VAR 0 3
21278: PUSH
21279: LD_INT 11
21281: PUSH
21282: LD_INT 12
21284: PUSH
21285: LD_INT 13
21287: PUSH
21288: LD_INT 14
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: LIST
21295: LIST
21296: ST_TO_ADDR
21297: GO 21874
21299: LD_INT 23
21301: DOUBLE
21302: EQUAL
21303: IFTRUE 21307
21305: GO 21333
21307: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21308: LD_ADDR_VAR 0 3
21312: PUSH
21313: LD_INT 11
21315: PUSH
21316: LD_INT 12
21318: PUSH
21319: LD_INT 13
21321: PUSH
21322: LD_INT 14
21324: PUSH
21325: EMPTY
21326: LIST
21327: LIST
21328: LIST
21329: LIST
21330: ST_TO_ADDR
21331: GO 21874
21333: LD_INT 24
21335: DOUBLE
21336: EQUAL
21337: IFTRUE 21341
21339: GO 21367
21341: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21342: LD_ADDR_VAR 0 3
21346: PUSH
21347: LD_INT 11
21349: PUSH
21350: LD_INT 12
21352: PUSH
21353: LD_INT 13
21355: PUSH
21356: LD_INT 14
21358: PUSH
21359: EMPTY
21360: LIST
21361: LIST
21362: LIST
21363: LIST
21364: ST_TO_ADDR
21365: GO 21874
21367: LD_INT 30
21369: DOUBLE
21370: EQUAL
21371: IFTRUE 21375
21373: GO 21401
21375: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21376: LD_ADDR_VAR 0 3
21380: PUSH
21381: LD_INT 11
21383: PUSH
21384: LD_INT 12
21386: PUSH
21387: LD_INT 13
21389: PUSH
21390: LD_INT 14
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: ST_TO_ADDR
21399: GO 21874
21401: LD_INT 25
21403: DOUBLE
21404: EQUAL
21405: IFTRUE 21409
21407: GO 21427
21409: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21410: LD_ADDR_VAR 0 3
21414: PUSH
21415: LD_INT 13
21417: PUSH
21418: LD_INT 14
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: ST_TO_ADDR
21425: GO 21874
21427: LD_INT 27
21429: DOUBLE
21430: EQUAL
21431: IFTRUE 21435
21433: GO 21453
21435: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21436: LD_ADDR_VAR 0 3
21440: PUSH
21441: LD_INT 13
21443: PUSH
21444: LD_INT 14
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: ST_TO_ADDR
21451: GO 21874
21453: LD_INT 28
21455: DOUBLE
21456: EQUAL
21457: IFTRUE 21461
21459: GO 21479
21461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21462: LD_ADDR_VAR 0 3
21466: PUSH
21467: LD_INT 13
21469: PUSH
21470: LD_INT 14
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: ST_TO_ADDR
21477: GO 21874
21479: LD_INT 29
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21487
21485: GO 21505
21487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21488: LD_ADDR_VAR 0 3
21492: PUSH
21493: LD_INT 13
21495: PUSH
21496: LD_INT 14
21498: PUSH
21499: EMPTY
21500: LIST
21501: LIST
21502: ST_TO_ADDR
21503: GO 21874
21505: LD_INT 31
21507: DOUBLE
21508: EQUAL
21509: IFTRUE 21513
21511: GO 21531
21513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21514: LD_ADDR_VAR 0 3
21518: PUSH
21519: LD_INT 13
21521: PUSH
21522: LD_INT 14
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: ST_TO_ADDR
21529: GO 21874
21531: LD_INT 26
21533: DOUBLE
21534: EQUAL
21535: IFTRUE 21539
21537: GO 21557
21539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21540: LD_ADDR_VAR 0 3
21544: PUSH
21545: LD_INT 13
21547: PUSH
21548: LD_INT 14
21550: PUSH
21551: EMPTY
21552: LIST
21553: LIST
21554: ST_TO_ADDR
21555: GO 21874
21557: LD_INT 42
21559: DOUBLE
21560: EQUAL
21561: IFTRUE 21565
21563: GO 21591
21565: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21566: LD_ADDR_VAR 0 3
21570: PUSH
21571: LD_INT 21
21573: PUSH
21574: LD_INT 22
21576: PUSH
21577: LD_INT 23
21579: PUSH
21580: LD_INT 24
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: ST_TO_ADDR
21589: GO 21874
21591: LD_INT 43
21593: DOUBLE
21594: EQUAL
21595: IFTRUE 21599
21597: GO 21625
21599: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21600: LD_ADDR_VAR 0 3
21604: PUSH
21605: LD_INT 21
21607: PUSH
21608: LD_INT 22
21610: PUSH
21611: LD_INT 23
21613: PUSH
21614: LD_INT 24
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: ST_TO_ADDR
21623: GO 21874
21625: LD_INT 44
21627: DOUBLE
21628: EQUAL
21629: IFTRUE 21633
21631: GO 21659
21633: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21634: LD_ADDR_VAR 0 3
21638: PUSH
21639: LD_INT 21
21641: PUSH
21642: LD_INT 22
21644: PUSH
21645: LD_INT 23
21647: PUSH
21648: LD_INT 24
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: ST_TO_ADDR
21657: GO 21874
21659: LD_INT 45
21661: DOUBLE
21662: EQUAL
21663: IFTRUE 21667
21665: GO 21693
21667: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21668: LD_ADDR_VAR 0 3
21672: PUSH
21673: LD_INT 21
21675: PUSH
21676: LD_INT 22
21678: PUSH
21679: LD_INT 23
21681: PUSH
21682: LD_INT 24
21684: PUSH
21685: EMPTY
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: ST_TO_ADDR
21691: GO 21874
21693: LD_INT 49
21695: DOUBLE
21696: EQUAL
21697: IFTRUE 21701
21699: GO 21727
21701: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21702: LD_ADDR_VAR 0 3
21706: PUSH
21707: LD_INT 21
21709: PUSH
21710: LD_INT 22
21712: PUSH
21713: LD_INT 23
21715: PUSH
21716: LD_INT 24
21718: PUSH
21719: EMPTY
21720: LIST
21721: LIST
21722: LIST
21723: LIST
21724: ST_TO_ADDR
21725: GO 21874
21727: LD_INT 51
21729: DOUBLE
21730: EQUAL
21731: IFTRUE 21735
21733: GO 21761
21735: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21736: LD_ADDR_VAR 0 3
21740: PUSH
21741: LD_INT 21
21743: PUSH
21744: LD_INT 22
21746: PUSH
21747: LD_INT 23
21749: PUSH
21750: LD_INT 24
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: LIST
21757: LIST
21758: ST_TO_ADDR
21759: GO 21874
21761: LD_INT 52
21763: DOUBLE
21764: EQUAL
21765: IFTRUE 21769
21767: GO 21795
21769: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21770: LD_ADDR_VAR 0 3
21774: PUSH
21775: LD_INT 21
21777: PUSH
21778: LD_INT 22
21780: PUSH
21781: LD_INT 23
21783: PUSH
21784: LD_INT 24
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: LIST
21791: LIST
21792: ST_TO_ADDR
21793: GO 21874
21795: LD_INT 53
21797: DOUBLE
21798: EQUAL
21799: IFTRUE 21803
21801: GO 21821
21803: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21804: LD_ADDR_VAR 0 3
21808: PUSH
21809: LD_INT 23
21811: PUSH
21812: LD_INT 24
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: ST_TO_ADDR
21819: GO 21874
21821: LD_INT 46
21823: DOUBLE
21824: EQUAL
21825: IFTRUE 21829
21827: GO 21847
21829: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 23
21837: PUSH
21838: LD_INT 24
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: ST_TO_ADDR
21845: GO 21874
21847: LD_INT 47
21849: DOUBLE
21850: EQUAL
21851: IFTRUE 21855
21853: GO 21873
21855: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21856: LD_ADDR_VAR 0 3
21860: PUSH
21861: LD_INT 23
21863: PUSH
21864: LD_INT 24
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: ST_TO_ADDR
21871: GO 21874
21873: POP
// result := ( chassis in result ) ;
21874: LD_ADDR_VAR 0 3
21878: PUSH
21879: LD_VAR 0 1
21883: PUSH
21884: LD_VAR 0 3
21888: IN
21889: ST_TO_ADDR
// end ;
21890: LD_VAR 0 3
21894: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21895: LD_INT 0
21897: PPUSH
21898: PPUSH
21899: PPUSH
21900: PPUSH
21901: PPUSH
21902: PPUSH
21903: PPUSH
// result := array ;
21904: LD_ADDR_VAR 0 5
21908: PUSH
21909: LD_VAR 0 1
21913: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21914: LD_VAR 0 1
21918: NOT
21919: PUSH
21920: LD_VAR 0 2
21924: NOT
21925: OR
21926: PUSH
21927: LD_VAR 0 3
21931: NOT
21932: OR
21933: PUSH
21934: LD_VAR 0 2
21938: PUSH
21939: LD_VAR 0 1
21943: GREATER
21944: OR
21945: PUSH
21946: LD_VAR 0 3
21950: PUSH
21951: LD_VAR 0 1
21955: GREATER
21956: OR
21957: IFFALSE 21961
// exit ;
21959: GO 22257
// if direction then
21961: LD_VAR 0 4
21965: IFFALSE 22029
// begin d := 1 ;
21967: LD_ADDR_VAR 0 9
21971: PUSH
21972: LD_INT 1
21974: ST_TO_ADDR
// if i_from > i_to then
21975: LD_VAR 0 2
21979: PUSH
21980: LD_VAR 0 3
21984: GREATER
21985: IFFALSE 22011
// length := ( array - i_from ) + i_to else
21987: LD_ADDR_VAR 0 11
21991: PUSH
21992: LD_VAR 0 1
21996: PUSH
21997: LD_VAR 0 2
22001: MINUS
22002: PUSH
22003: LD_VAR 0 3
22007: PLUS
22008: ST_TO_ADDR
22009: GO 22027
// length := i_to - i_from ;
22011: LD_ADDR_VAR 0 11
22015: PUSH
22016: LD_VAR 0 3
22020: PUSH
22021: LD_VAR 0 2
22025: MINUS
22026: ST_TO_ADDR
// end else
22027: GO 22090
// begin d := - 1 ;
22029: LD_ADDR_VAR 0 9
22033: PUSH
22034: LD_INT 1
22036: NEG
22037: ST_TO_ADDR
// if i_from > i_to then
22038: LD_VAR 0 2
22042: PUSH
22043: LD_VAR 0 3
22047: GREATER
22048: IFFALSE 22068
// length := i_from - i_to else
22050: LD_ADDR_VAR 0 11
22054: PUSH
22055: LD_VAR 0 2
22059: PUSH
22060: LD_VAR 0 3
22064: MINUS
22065: ST_TO_ADDR
22066: GO 22090
// length := ( array - i_to ) + i_from ;
22068: LD_ADDR_VAR 0 11
22072: PUSH
22073: LD_VAR 0 1
22077: PUSH
22078: LD_VAR 0 3
22082: MINUS
22083: PUSH
22084: LD_VAR 0 2
22088: PLUS
22089: ST_TO_ADDR
// end ; if not length then
22090: LD_VAR 0 11
22094: NOT
22095: IFFALSE 22099
// exit ;
22097: GO 22257
// tmp := array ;
22099: LD_ADDR_VAR 0 10
22103: PUSH
22104: LD_VAR 0 1
22108: ST_TO_ADDR
// for i = 1 to length do
22109: LD_ADDR_VAR 0 6
22113: PUSH
22114: DOUBLE
22115: LD_INT 1
22117: DEC
22118: ST_TO_ADDR
22119: LD_VAR 0 11
22123: PUSH
22124: FOR_TO
22125: IFFALSE 22245
// begin for j = 1 to array do
22127: LD_ADDR_VAR 0 7
22131: PUSH
22132: DOUBLE
22133: LD_INT 1
22135: DEC
22136: ST_TO_ADDR
22137: LD_VAR 0 1
22141: PUSH
22142: FOR_TO
22143: IFFALSE 22231
// begin k := j + d ;
22145: LD_ADDR_VAR 0 8
22149: PUSH
22150: LD_VAR 0 7
22154: PUSH
22155: LD_VAR 0 9
22159: PLUS
22160: ST_TO_ADDR
// if k > array then
22161: LD_VAR 0 8
22165: PUSH
22166: LD_VAR 0 1
22170: GREATER
22171: IFFALSE 22181
// k := 1 ;
22173: LD_ADDR_VAR 0 8
22177: PUSH
22178: LD_INT 1
22180: ST_TO_ADDR
// if not k then
22181: LD_VAR 0 8
22185: NOT
22186: IFFALSE 22198
// k := array ;
22188: LD_ADDR_VAR 0 8
22192: PUSH
22193: LD_VAR 0 1
22197: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22198: LD_ADDR_VAR 0 10
22202: PUSH
22203: LD_VAR 0 10
22207: PPUSH
22208: LD_VAR 0 8
22212: PPUSH
22213: LD_VAR 0 1
22217: PUSH
22218: LD_VAR 0 7
22222: ARRAY
22223: PPUSH
22224: CALL_OW 1
22228: ST_TO_ADDR
// end ;
22229: GO 22142
22231: POP
22232: POP
// array := tmp ;
22233: LD_ADDR_VAR 0 1
22237: PUSH
22238: LD_VAR 0 10
22242: ST_TO_ADDR
// end ;
22243: GO 22124
22245: POP
22246: POP
// result := array ;
22247: LD_ADDR_VAR 0 5
22251: PUSH
22252: LD_VAR 0 1
22256: ST_TO_ADDR
// end ;
22257: LD_VAR 0 5
22261: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22262: LD_INT 0
22264: PPUSH
22265: PPUSH
// result := 0 ;
22266: LD_ADDR_VAR 0 3
22270: PUSH
22271: LD_INT 0
22273: ST_TO_ADDR
// if not array or not value in array then
22274: LD_VAR 0 1
22278: NOT
22279: PUSH
22280: LD_VAR 0 2
22284: PUSH
22285: LD_VAR 0 1
22289: IN
22290: NOT
22291: OR
22292: IFFALSE 22296
// exit ;
22294: GO 22350
// for i = 1 to array do
22296: LD_ADDR_VAR 0 4
22300: PUSH
22301: DOUBLE
22302: LD_INT 1
22304: DEC
22305: ST_TO_ADDR
22306: LD_VAR 0 1
22310: PUSH
22311: FOR_TO
22312: IFFALSE 22348
// if value = array [ i ] then
22314: LD_VAR 0 2
22318: PUSH
22319: LD_VAR 0 1
22323: PUSH
22324: LD_VAR 0 4
22328: ARRAY
22329: EQUAL
22330: IFFALSE 22346
// begin result := i ;
22332: LD_ADDR_VAR 0 3
22336: PUSH
22337: LD_VAR 0 4
22341: ST_TO_ADDR
// exit ;
22342: POP
22343: POP
22344: GO 22350
// end ;
22346: GO 22311
22348: POP
22349: POP
// end ;
22350: LD_VAR 0 3
22354: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22355: LD_INT 0
22357: PPUSH
// vc_chassis := chassis ;
22358: LD_ADDR_OWVAR 37
22362: PUSH
22363: LD_VAR 0 1
22367: ST_TO_ADDR
// vc_engine := engine ;
22368: LD_ADDR_OWVAR 39
22372: PUSH
22373: LD_VAR 0 2
22377: ST_TO_ADDR
// vc_control := control ;
22378: LD_ADDR_OWVAR 38
22382: PUSH
22383: LD_VAR 0 3
22387: ST_TO_ADDR
// vc_weapon := weapon ;
22388: LD_ADDR_OWVAR 40
22392: PUSH
22393: LD_VAR 0 4
22397: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22398: LD_ADDR_OWVAR 41
22402: PUSH
22403: LD_VAR 0 5
22407: ST_TO_ADDR
// end ;
22408: LD_VAR 0 6
22412: RET
// export function WantPlant ( unit ) ; var task ; begin
22413: LD_INT 0
22415: PPUSH
22416: PPUSH
// result := false ;
22417: LD_ADDR_VAR 0 2
22421: PUSH
22422: LD_INT 0
22424: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22425: LD_ADDR_VAR 0 3
22429: PUSH
22430: LD_VAR 0 1
22434: PPUSH
22435: CALL_OW 437
22439: ST_TO_ADDR
// if task then
22440: LD_VAR 0 3
22444: IFFALSE 22472
// if task [ 1 ] [ 1 ] = p then
22446: LD_VAR 0 3
22450: PUSH
22451: LD_INT 1
22453: ARRAY
22454: PUSH
22455: LD_INT 1
22457: ARRAY
22458: PUSH
22459: LD_STRING p
22461: EQUAL
22462: IFFALSE 22472
// result := true ;
22464: LD_ADDR_VAR 0 2
22468: PUSH
22469: LD_INT 1
22471: ST_TO_ADDR
// end ;
22472: LD_VAR 0 2
22476: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22477: LD_INT 0
22479: PPUSH
22480: PPUSH
22481: PPUSH
22482: PPUSH
// if pos < 1 then
22483: LD_VAR 0 2
22487: PUSH
22488: LD_INT 1
22490: LESS
22491: IFFALSE 22495
// exit ;
22493: GO 22798
// if pos = 1 then
22495: LD_VAR 0 2
22499: PUSH
22500: LD_INT 1
22502: EQUAL
22503: IFFALSE 22536
// result := Replace ( arr , pos [ 1 ] , value ) else
22505: LD_ADDR_VAR 0 4
22509: PUSH
22510: LD_VAR 0 1
22514: PPUSH
22515: LD_VAR 0 2
22519: PUSH
22520: LD_INT 1
22522: ARRAY
22523: PPUSH
22524: LD_VAR 0 3
22528: PPUSH
22529: CALL_OW 1
22533: ST_TO_ADDR
22534: GO 22798
// begin tmp := arr ;
22536: LD_ADDR_VAR 0 6
22540: PUSH
22541: LD_VAR 0 1
22545: ST_TO_ADDR
// s_arr := [ tmp ] ;
22546: LD_ADDR_VAR 0 7
22550: PUSH
22551: LD_VAR 0 6
22555: PUSH
22556: EMPTY
22557: LIST
22558: ST_TO_ADDR
// for i = 1 to pos - 1 do
22559: LD_ADDR_VAR 0 5
22563: PUSH
22564: DOUBLE
22565: LD_INT 1
22567: DEC
22568: ST_TO_ADDR
22569: LD_VAR 0 2
22573: PUSH
22574: LD_INT 1
22576: MINUS
22577: PUSH
22578: FOR_TO
22579: IFFALSE 22624
// begin tmp := tmp [ pos [ i ] ] ;
22581: LD_ADDR_VAR 0 6
22585: PUSH
22586: LD_VAR 0 6
22590: PUSH
22591: LD_VAR 0 2
22595: PUSH
22596: LD_VAR 0 5
22600: ARRAY
22601: ARRAY
22602: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22603: LD_ADDR_VAR 0 7
22607: PUSH
22608: LD_VAR 0 7
22612: PUSH
22613: LD_VAR 0 6
22617: PUSH
22618: EMPTY
22619: LIST
22620: ADD
22621: ST_TO_ADDR
// end ;
22622: GO 22578
22624: POP
22625: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22626: LD_ADDR_VAR 0 6
22630: PUSH
22631: LD_VAR 0 6
22635: PPUSH
22636: LD_VAR 0 2
22640: PUSH
22641: LD_VAR 0 2
22645: ARRAY
22646: PPUSH
22647: LD_VAR 0 3
22651: PPUSH
22652: CALL_OW 1
22656: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22657: LD_ADDR_VAR 0 7
22661: PUSH
22662: LD_VAR 0 7
22666: PPUSH
22667: LD_VAR 0 7
22671: PPUSH
22672: LD_VAR 0 6
22676: PPUSH
22677: CALL_OW 1
22681: ST_TO_ADDR
// for i = s_arr downto 2 do
22682: LD_ADDR_VAR 0 5
22686: PUSH
22687: DOUBLE
22688: LD_VAR 0 7
22692: INC
22693: ST_TO_ADDR
22694: LD_INT 2
22696: PUSH
22697: FOR_DOWNTO
22698: IFFALSE 22782
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22700: LD_ADDR_VAR 0 6
22704: PUSH
22705: LD_VAR 0 7
22709: PUSH
22710: LD_VAR 0 5
22714: PUSH
22715: LD_INT 1
22717: MINUS
22718: ARRAY
22719: PPUSH
22720: LD_VAR 0 2
22724: PUSH
22725: LD_VAR 0 5
22729: PUSH
22730: LD_INT 1
22732: MINUS
22733: ARRAY
22734: PPUSH
22735: LD_VAR 0 7
22739: PUSH
22740: LD_VAR 0 5
22744: ARRAY
22745: PPUSH
22746: CALL_OW 1
22750: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22751: LD_ADDR_VAR 0 7
22755: PUSH
22756: LD_VAR 0 7
22760: PPUSH
22761: LD_VAR 0 5
22765: PUSH
22766: LD_INT 1
22768: MINUS
22769: PPUSH
22770: LD_VAR 0 6
22774: PPUSH
22775: CALL_OW 1
22779: ST_TO_ADDR
// end ;
22780: GO 22697
22782: POP
22783: POP
// result := s_arr [ 1 ] ;
22784: LD_ADDR_VAR 0 4
22788: PUSH
22789: LD_VAR 0 7
22793: PUSH
22794: LD_INT 1
22796: ARRAY
22797: ST_TO_ADDR
// end ; end ;
22798: LD_VAR 0 4
22802: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22803: LD_INT 0
22805: PPUSH
22806: PPUSH
// if not list then
22807: LD_VAR 0 1
22811: NOT
22812: IFFALSE 22816
// exit ;
22814: GO 22907
// i := list [ pos1 ] ;
22816: LD_ADDR_VAR 0 5
22820: PUSH
22821: LD_VAR 0 1
22825: PUSH
22826: LD_VAR 0 2
22830: ARRAY
22831: ST_TO_ADDR
// if not i then
22832: LD_VAR 0 5
22836: NOT
22837: IFFALSE 22841
// exit ;
22839: GO 22907
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22841: LD_ADDR_VAR 0 1
22845: PUSH
22846: LD_VAR 0 1
22850: PPUSH
22851: LD_VAR 0 2
22855: PPUSH
22856: LD_VAR 0 1
22860: PUSH
22861: LD_VAR 0 3
22865: ARRAY
22866: PPUSH
22867: CALL_OW 1
22871: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22872: LD_ADDR_VAR 0 1
22876: PUSH
22877: LD_VAR 0 1
22881: PPUSH
22882: LD_VAR 0 3
22886: PPUSH
22887: LD_VAR 0 5
22891: PPUSH
22892: CALL_OW 1
22896: ST_TO_ADDR
// result := list ;
22897: LD_ADDR_VAR 0 4
22901: PUSH
22902: LD_VAR 0 1
22906: ST_TO_ADDR
// end ;
22907: LD_VAR 0 4
22911: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22912: LD_INT 0
22914: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22915: LD_ADDR_VAR 0 5
22919: PUSH
22920: LD_VAR 0 1
22924: PPUSH
22925: CALL_OW 250
22929: PPUSH
22930: LD_VAR 0 1
22934: PPUSH
22935: CALL_OW 251
22939: PPUSH
22940: LD_VAR 0 2
22944: PPUSH
22945: LD_VAR 0 3
22949: PPUSH
22950: LD_VAR 0 4
22954: PPUSH
22955: CALL 22965 0 5
22959: ST_TO_ADDR
// end ;
22960: LD_VAR 0 5
22964: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22965: LD_INT 0
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
// if not list then
22971: LD_VAR 0 3
22975: NOT
22976: IFFALSE 22980
// exit ;
22978: GO 23368
// result := [ ] ;
22980: LD_ADDR_VAR 0 6
22984: PUSH
22985: EMPTY
22986: ST_TO_ADDR
// for i in list do
22987: LD_ADDR_VAR 0 7
22991: PUSH
22992: LD_VAR 0 3
22996: PUSH
22997: FOR_IN
22998: IFFALSE 23200
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23000: LD_ADDR_VAR 0 9
23004: PUSH
23005: LD_VAR 0 7
23009: PPUSH
23010: LD_VAR 0 1
23014: PPUSH
23015: LD_VAR 0 2
23019: PPUSH
23020: CALL_OW 297
23024: ST_TO_ADDR
// if not result then
23025: LD_VAR 0 6
23029: NOT
23030: IFFALSE 23056
// result := [ [ i , tmp ] ] else
23032: LD_ADDR_VAR 0 6
23036: PUSH
23037: LD_VAR 0 7
23041: PUSH
23042: LD_VAR 0 9
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: PUSH
23051: EMPTY
23052: LIST
23053: ST_TO_ADDR
23054: GO 23198
// begin if result [ result ] [ 2 ] < tmp then
23056: LD_VAR 0 6
23060: PUSH
23061: LD_VAR 0 6
23065: ARRAY
23066: PUSH
23067: LD_INT 2
23069: ARRAY
23070: PUSH
23071: LD_VAR 0 9
23075: LESS
23076: IFFALSE 23118
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23078: LD_ADDR_VAR 0 6
23082: PUSH
23083: LD_VAR 0 6
23087: PPUSH
23088: LD_VAR 0 6
23092: PUSH
23093: LD_INT 1
23095: PLUS
23096: PPUSH
23097: LD_VAR 0 7
23101: PUSH
23102: LD_VAR 0 9
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PPUSH
23111: CALL_OW 2
23115: ST_TO_ADDR
23116: GO 23198
// for j = 1 to result do
23118: LD_ADDR_VAR 0 8
23122: PUSH
23123: DOUBLE
23124: LD_INT 1
23126: DEC
23127: ST_TO_ADDR
23128: LD_VAR 0 6
23132: PUSH
23133: FOR_TO
23134: IFFALSE 23196
// begin if tmp < result [ j ] [ 2 ] then
23136: LD_VAR 0 9
23140: PUSH
23141: LD_VAR 0 6
23145: PUSH
23146: LD_VAR 0 8
23150: ARRAY
23151: PUSH
23152: LD_INT 2
23154: ARRAY
23155: LESS
23156: IFFALSE 23194
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23158: LD_ADDR_VAR 0 6
23162: PUSH
23163: LD_VAR 0 6
23167: PPUSH
23168: LD_VAR 0 8
23172: PPUSH
23173: LD_VAR 0 7
23177: PUSH
23178: LD_VAR 0 9
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PPUSH
23187: CALL_OW 2
23191: ST_TO_ADDR
// break ;
23192: GO 23196
// end ; end ;
23194: GO 23133
23196: POP
23197: POP
// end ; end ;
23198: GO 22997
23200: POP
23201: POP
// if result and not asc then
23202: LD_VAR 0 6
23206: PUSH
23207: LD_VAR 0 4
23211: NOT
23212: AND
23213: IFFALSE 23288
// begin tmp := result ;
23215: LD_ADDR_VAR 0 9
23219: PUSH
23220: LD_VAR 0 6
23224: ST_TO_ADDR
// for i = tmp downto 1 do
23225: LD_ADDR_VAR 0 7
23229: PUSH
23230: DOUBLE
23231: LD_VAR 0 9
23235: INC
23236: ST_TO_ADDR
23237: LD_INT 1
23239: PUSH
23240: FOR_DOWNTO
23241: IFFALSE 23286
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23243: LD_ADDR_VAR 0 6
23247: PUSH
23248: LD_VAR 0 6
23252: PPUSH
23253: LD_VAR 0 9
23257: PUSH
23258: LD_VAR 0 7
23262: MINUS
23263: PUSH
23264: LD_INT 1
23266: PLUS
23267: PPUSH
23268: LD_VAR 0 9
23272: PUSH
23273: LD_VAR 0 7
23277: ARRAY
23278: PPUSH
23279: CALL_OW 1
23283: ST_TO_ADDR
23284: GO 23240
23286: POP
23287: POP
// end ; tmp := [ ] ;
23288: LD_ADDR_VAR 0 9
23292: PUSH
23293: EMPTY
23294: ST_TO_ADDR
// if mode then
23295: LD_VAR 0 5
23299: IFFALSE 23368
// begin for i = 1 to result do
23301: LD_ADDR_VAR 0 7
23305: PUSH
23306: DOUBLE
23307: LD_INT 1
23309: DEC
23310: ST_TO_ADDR
23311: LD_VAR 0 6
23315: PUSH
23316: FOR_TO
23317: IFFALSE 23356
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23319: LD_ADDR_VAR 0 9
23323: PUSH
23324: LD_VAR 0 9
23328: PPUSH
23329: LD_VAR 0 7
23333: PPUSH
23334: LD_VAR 0 6
23338: PUSH
23339: LD_VAR 0 7
23343: ARRAY
23344: PUSH
23345: LD_INT 1
23347: ARRAY
23348: PPUSH
23349: CALL_OW 1
23353: ST_TO_ADDR
23354: GO 23316
23356: POP
23357: POP
// result := tmp ;
23358: LD_ADDR_VAR 0 6
23362: PUSH
23363: LD_VAR 0 9
23367: ST_TO_ADDR
// end ; end ;
23368: LD_VAR 0 6
23372: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23373: LD_INT 0
23375: PPUSH
23376: PPUSH
23377: PPUSH
23378: PPUSH
23379: PPUSH
23380: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23381: LD_ADDR_VAR 0 5
23385: PUSH
23386: LD_INT 0
23388: PUSH
23389: LD_INT 0
23391: PUSH
23392: LD_INT 0
23394: PUSH
23395: EMPTY
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: LIST
23401: LIST
23402: ST_TO_ADDR
// if not x or not y then
23403: LD_VAR 0 2
23407: NOT
23408: PUSH
23409: LD_VAR 0 3
23413: NOT
23414: OR
23415: IFFALSE 23419
// exit ;
23417: GO 25065
// if not range then
23419: LD_VAR 0 4
23423: NOT
23424: IFFALSE 23434
// range := 10 ;
23426: LD_ADDR_VAR 0 4
23430: PUSH
23431: LD_INT 10
23433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23434: LD_ADDR_VAR 0 8
23438: PUSH
23439: LD_INT 81
23441: PUSH
23442: LD_VAR 0 1
23446: PUSH
23447: EMPTY
23448: LIST
23449: LIST
23450: PUSH
23451: LD_INT 92
23453: PUSH
23454: LD_VAR 0 2
23458: PUSH
23459: LD_VAR 0 3
23463: PUSH
23464: LD_VAR 0 4
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: PUSH
23475: LD_INT 3
23477: PUSH
23478: LD_INT 21
23480: PUSH
23481: LD_INT 3
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: PUSH
23488: EMPTY
23489: LIST
23490: LIST
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: LIST
23496: PPUSH
23497: CALL_OW 69
23501: ST_TO_ADDR
// if not tmp then
23502: LD_VAR 0 8
23506: NOT
23507: IFFALSE 23511
// exit ;
23509: GO 25065
// for i in tmp do
23511: LD_ADDR_VAR 0 6
23515: PUSH
23516: LD_VAR 0 8
23520: PUSH
23521: FOR_IN
23522: IFFALSE 25040
// begin points := [ 0 , 0 , 0 ] ;
23524: LD_ADDR_VAR 0 9
23528: PUSH
23529: LD_INT 0
23531: PUSH
23532: LD_INT 0
23534: PUSH
23535: LD_INT 0
23537: PUSH
23538: EMPTY
23539: LIST
23540: LIST
23541: LIST
23542: ST_TO_ADDR
// bpoints := 1 ;
23543: LD_ADDR_VAR 0 10
23547: PUSH
23548: LD_INT 1
23550: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23551: LD_VAR 0 6
23555: PPUSH
23556: CALL_OW 247
23560: PUSH
23561: LD_INT 1
23563: DOUBLE
23564: EQUAL
23565: IFTRUE 23569
23567: GO 24147
23569: POP
// begin if GetClass ( i ) = 1 then
23570: LD_VAR 0 6
23574: PPUSH
23575: CALL_OW 257
23579: PUSH
23580: LD_INT 1
23582: EQUAL
23583: IFFALSE 23604
// points := [ 10 , 5 , 3 ] ;
23585: LD_ADDR_VAR 0 9
23589: PUSH
23590: LD_INT 10
23592: PUSH
23593: LD_INT 5
23595: PUSH
23596: LD_INT 3
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23604: LD_VAR 0 6
23608: PPUSH
23609: CALL_OW 257
23613: PUSH
23614: LD_INT 2
23616: PUSH
23617: LD_INT 3
23619: PUSH
23620: LD_INT 4
23622: PUSH
23623: EMPTY
23624: LIST
23625: LIST
23626: LIST
23627: IN
23628: IFFALSE 23649
// points := [ 3 , 2 , 1 ] ;
23630: LD_ADDR_VAR 0 9
23634: PUSH
23635: LD_INT 3
23637: PUSH
23638: LD_INT 2
23640: PUSH
23641: LD_INT 1
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: LIST
23648: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23649: LD_VAR 0 6
23653: PPUSH
23654: CALL_OW 257
23658: PUSH
23659: LD_INT 5
23661: EQUAL
23662: IFFALSE 23683
// points := [ 130 , 5 , 2 ] ;
23664: LD_ADDR_VAR 0 9
23668: PUSH
23669: LD_INT 130
23671: PUSH
23672: LD_INT 5
23674: PUSH
23675: LD_INT 2
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: LIST
23682: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23683: LD_VAR 0 6
23687: PPUSH
23688: CALL_OW 257
23692: PUSH
23693: LD_INT 8
23695: EQUAL
23696: IFFALSE 23717
// points := [ 35 , 35 , 30 ] ;
23698: LD_ADDR_VAR 0 9
23702: PUSH
23703: LD_INT 35
23705: PUSH
23706: LD_INT 35
23708: PUSH
23709: LD_INT 30
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: LIST
23716: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23717: LD_VAR 0 6
23721: PPUSH
23722: CALL_OW 257
23726: PUSH
23727: LD_INT 9
23729: EQUAL
23730: IFFALSE 23751
// points := [ 20 , 55 , 40 ] ;
23732: LD_ADDR_VAR 0 9
23736: PUSH
23737: LD_INT 20
23739: PUSH
23740: LD_INT 55
23742: PUSH
23743: LD_INT 40
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: LIST
23750: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23751: LD_VAR 0 6
23755: PPUSH
23756: CALL_OW 257
23760: PUSH
23761: LD_INT 12
23763: PUSH
23764: LD_INT 16
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: IN
23771: IFFALSE 23792
// points := [ 5 , 3 , 2 ] ;
23773: LD_ADDR_VAR 0 9
23777: PUSH
23778: LD_INT 5
23780: PUSH
23781: LD_INT 3
23783: PUSH
23784: LD_INT 2
23786: PUSH
23787: EMPTY
23788: LIST
23789: LIST
23790: LIST
23791: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23792: LD_VAR 0 6
23796: PPUSH
23797: CALL_OW 257
23801: PUSH
23802: LD_INT 17
23804: EQUAL
23805: IFFALSE 23826
// points := [ 100 , 50 , 75 ] ;
23807: LD_ADDR_VAR 0 9
23811: PUSH
23812: LD_INT 100
23814: PUSH
23815: LD_INT 50
23817: PUSH
23818: LD_INT 75
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: LIST
23825: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23826: LD_VAR 0 6
23830: PPUSH
23831: CALL_OW 257
23835: PUSH
23836: LD_INT 15
23838: EQUAL
23839: IFFALSE 23860
// points := [ 10 , 5 , 3 ] ;
23841: LD_ADDR_VAR 0 9
23845: PUSH
23846: LD_INT 10
23848: PUSH
23849: LD_INT 5
23851: PUSH
23852: LD_INT 3
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: LIST
23859: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23860: LD_VAR 0 6
23864: PPUSH
23865: CALL_OW 257
23869: PUSH
23870: LD_INT 14
23872: EQUAL
23873: IFFALSE 23894
// points := [ 10 , 0 , 0 ] ;
23875: LD_ADDR_VAR 0 9
23879: PUSH
23880: LD_INT 10
23882: PUSH
23883: LD_INT 0
23885: PUSH
23886: LD_INT 0
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23894: LD_VAR 0 6
23898: PPUSH
23899: CALL_OW 257
23903: PUSH
23904: LD_INT 11
23906: EQUAL
23907: IFFALSE 23928
// points := [ 30 , 10 , 5 ] ;
23909: LD_ADDR_VAR 0 9
23913: PUSH
23914: LD_INT 30
23916: PUSH
23917: LD_INT 10
23919: PUSH
23920: LD_INT 5
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: LIST
23927: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23928: LD_VAR 0 1
23932: PPUSH
23933: LD_INT 5
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: IFFALSE 23961
// bpoints := bpoints * 1.8 ;
23946: LD_ADDR_VAR 0 10
23950: PUSH
23951: LD_VAR 0 10
23955: PUSH
23956: LD_REAL  1.80000000000000E+0000
23959: MUL
23960: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23961: LD_VAR 0 6
23965: PPUSH
23966: CALL_OW 257
23970: PUSH
23971: LD_INT 1
23973: PUSH
23974: LD_INT 2
23976: PUSH
23977: LD_INT 3
23979: PUSH
23980: LD_INT 4
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: LIST
23987: LIST
23988: IN
23989: PUSH
23990: LD_VAR 0 1
23994: PPUSH
23995: LD_INT 51
23997: PPUSH
23998: CALL_OW 321
24002: PUSH
24003: LD_INT 2
24005: EQUAL
24006: AND
24007: IFFALSE 24024
// bpoints := bpoints * 1.2 ;
24009: LD_ADDR_VAR 0 10
24013: PUSH
24014: LD_VAR 0 10
24018: PUSH
24019: LD_REAL  1.20000000000000E+0000
24022: MUL
24023: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24024: LD_VAR 0 6
24028: PPUSH
24029: CALL_OW 257
24033: PUSH
24034: LD_INT 5
24036: PUSH
24037: LD_INT 7
24039: PUSH
24040: LD_INT 9
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: LIST
24047: IN
24048: PUSH
24049: LD_VAR 0 1
24053: PPUSH
24054: LD_INT 52
24056: PPUSH
24057: CALL_OW 321
24061: PUSH
24062: LD_INT 2
24064: EQUAL
24065: AND
24066: IFFALSE 24083
// bpoints := bpoints * 1.5 ;
24068: LD_ADDR_VAR 0 10
24072: PUSH
24073: LD_VAR 0 10
24077: PUSH
24078: LD_REAL  1.50000000000000E+0000
24081: MUL
24082: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24083: LD_VAR 0 1
24087: PPUSH
24088: LD_INT 66
24090: PPUSH
24091: CALL_OW 321
24095: PUSH
24096: LD_INT 2
24098: EQUAL
24099: IFFALSE 24116
// bpoints := bpoints * 1.1 ;
24101: LD_ADDR_VAR 0 10
24105: PUSH
24106: LD_VAR 0 10
24110: PUSH
24111: LD_REAL  1.10000000000000E+0000
24114: MUL
24115: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24116: LD_ADDR_VAR 0 10
24120: PUSH
24121: LD_VAR 0 10
24125: PUSH
24126: LD_VAR 0 6
24130: PPUSH
24131: LD_INT 1
24133: PPUSH
24134: CALL_OW 259
24138: PUSH
24139: LD_REAL  1.15000000000000E+0000
24142: MUL
24143: MUL
24144: ST_TO_ADDR
// end ; unit_vehicle :
24145: GO 24969
24147: LD_INT 2
24149: DOUBLE
24150: EQUAL
24151: IFTRUE 24155
24153: GO 24957
24155: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24156: LD_VAR 0 6
24160: PPUSH
24161: CALL_OW 264
24165: PUSH
24166: LD_INT 2
24168: PUSH
24169: LD_INT 42
24171: PUSH
24172: LD_INT 24
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: IN
24180: IFFALSE 24201
// points := [ 25 , 5 , 3 ] ;
24182: LD_ADDR_VAR 0 9
24186: PUSH
24187: LD_INT 25
24189: PUSH
24190: LD_INT 5
24192: PUSH
24193: LD_INT 3
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: LIST
24200: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24201: LD_VAR 0 6
24205: PPUSH
24206: CALL_OW 264
24210: PUSH
24211: LD_INT 4
24213: PUSH
24214: LD_INT 43
24216: PUSH
24217: LD_INT 25
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: LIST
24224: IN
24225: IFFALSE 24246
// points := [ 40 , 15 , 5 ] ;
24227: LD_ADDR_VAR 0 9
24231: PUSH
24232: LD_INT 40
24234: PUSH
24235: LD_INT 15
24237: PUSH
24238: LD_INT 5
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: LIST
24245: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24246: LD_VAR 0 6
24250: PPUSH
24251: CALL_OW 264
24255: PUSH
24256: LD_INT 3
24258: PUSH
24259: LD_INT 23
24261: PUSH
24262: EMPTY
24263: LIST
24264: LIST
24265: IN
24266: IFFALSE 24287
// points := [ 7 , 25 , 8 ] ;
24268: LD_ADDR_VAR 0 9
24272: PUSH
24273: LD_INT 7
24275: PUSH
24276: LD_INT 25
24278: PUSH
24279: LD_INT 8
24281: PUSH
24282: EMPTY
24283: LIST
24284: LIST
24285: LIST
24286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24287: LD_VAR 0 6
24291: PPUSH
24292: CALL_OW 264
24296: PUSH
24297: LD_INT 5
24299: PUSH
24300: LD_INT 27
24302: PUSH
24303: LD_INT 44
24305: PUSH
24306: EMPTY
24307: LIST
24308: LIST
24309: LIST
24310: IN
24311: IFFALSE 24332
// points := [ 14 , 50 , 16 ] ;
24313: LD_ADDR_VAR 0 9
24317: PUSH
24318: LD_INT 14
24320: PUSH
24321: LD_INT 50
24323: PUSH
24324: LD_INT 16
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: LIST
24331: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24332: LD_VAR 0 6
24336: PPUSH
24337: CALL_OW 264
24341: PUSH
24342: LD_INT 6
24344: PUSH
24345: LD_INT 46
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: IN
24352: IFFALSE 24373
// points := [ 32 , 120 , 70 ] ;
24354: LD_ADDR_VAR 0 9
24358: PUSH
24359: LD_INT 32
24361: PUSH
24362: LD_INT 120
24364: PUSH
24365: LD_INT 70
24367: PUSH
24368: EMPTY
24369: LIST
24370: LIST
24371: LIST
24372: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
24373: LD_VAR 0 6
24377: PPUSH
24378: CALL_OW 264
24382: PUSH
24383: LD_INT 7
24385: PUSH
24386: LD_INT 28
24388: PUSH
24389: LD_INT 45
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: LIST
24396: IN
24397: IFFALSE 24418
// points := [ 35 , 20 , 45 ] ;
24399: LD_ADDR_VAR 0 9
24403: PUSH
24404: LD_INT 35
24406: PUSH
24407: LD_INT 20
24409: PUSH
24410: LD_INT 45
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: LIST
24417: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24418: LD_VAR 0 6
24422: PPUSH
24423: CALL_OW 264
24427: PUSH
24428: LD_INT 47
24430: PUSH
24431: EMPTY
24432: LIST
24433: IN
24434: IFFALSE 24455
// points := [ 67 , 45 , 75 ] ;
24436: LD_ADDR_VAR 0 9
24440: PUSH
24441: LD_INT 67
24443: PUSH
24444: LD_INT 45
24446: PUSH
24447: LD_INT 75
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24455: LD_VAR 0 6
24459: PPUSH
24460: CALL_OW 264
24464: PUSH
24465: LD_INT 26
24467: PUSH
24468: EMPTY
24469: LIST
24470: IN
24471: IFFALSE 24492
// points := [ 120 , 30 , 80 ] ;
24473: LD_ADDR_VAR 0 9
24477: PUSH
24478: LD_INT 120
24480: PUSH
24481: LD_INT 30
24483: PUSH
24484: LD_INT 80
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: LIST
24491: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24492: LD_VAR 0 6
24496: PPUSH
24497: CALL_OW 264
24501: PUSH
24502: LD_INT 22
24504: PUSH
24505: EMPTY
24506: LIST
24507: IN
24508: IFFALSE 24529
// points := [ 40 , 1 , 1 ] ;
24510: LD_ADDR_VAR 0 9
24514: PUSH
24515: LD_INT 40
24517: PUSH
24518: LD_INT 1
24520: PUSH
24521: LD_INT 1
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24529: LD_VAR 0 6
24533: PPUSH
24534: CALL_OW 264
24538: PUSH
24539: LD_INT 29
24541: PUSH
24542: EMPTY
24543: LIST
24544: IN
24545: IFFALSE 24566
// points := [ 70 , 200 , 400 ] ;
24547: LD_ADDR_VAR 0 9
24551: PUSH
24552: LD_INT 70
24554: PUSH
24555: LD_INT 200
24557: PUSH
24558: LD_INT 400
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: LIST
24565: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24566: LD_VAR 0 6
24570: PPUSH
24571: CALL_OW 264
24575: PUSH
24576: LD_INT 14
24578: PUSH
24579: LD_INT 53
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: IN
24586: IFFALSE 24607
// points := [ 40 , 10 , 20 ] ;
24588: LD_ADDR_VAR 0 9
24592: PUSH
24593: LD_INT 40
24595: PUSH
24596: LD_INT 10
24598: PUSH
24599: LD_INT 20
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: LIST
24606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24607: LD_VAR 0 6
24611: PPUSH
24612: CALL_OW 264
24616: PUSH
24617: LD_INT 9
24619: PUSH
24620: EMPTY
24621: LIST
24622: IN
24623: IFFALSE 24644
// points := [ 5 , 70 , 20 ] ;
24625: LD_ADDR_VAR 0 9
24629: PUSH
24630: LD_INT 5
24632: PUSH
24633: LD_INT 70
24635: PUSH
24636: LD_INT 20
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: LIST
24643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24644: LD_VAR 0 6
24648: PPUSH
24649: CALL_OW 264
24653: PUSH
24654: LD_INT 10
24656: PUSH
24657: EMPTY
24658: LIST
24659: IN
24660: IFFALSE 24681
// points := [ 35 , 110 , 70 ] ;
24662: LD_ADDR_VAR 0 9
24666: PUSH
24667: LD_INT 35
24669: PUSH
24670: LD_INT 110
24672: PUSH
24673: LD_INT 70
24675: PUSH
24676: EMPTY
24677: LIST
24678: LIST
24679: LIST
24680: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24681: LD_VAR 0 6
24685: PPUSH
24686: CALL_OW 265
24690: PUSH
24691: LD_INT 25
24693: EQUAL
24694: IFFALSE 24715
// points := [ 80 , 65 , 100 ] ;
24696: LD_ADDR_VAR 0 9
24700: PUSH
24701: LD_INT 80
24703: PUSH
24704: LD_INT 65
24706: PUSH
24707: LD_INT 100
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: LIST
24714: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24715: LD_VAR 0 6
24719: PPUSH
24720: CALL_OW 263
24724: PUSH
24725: LD_INT 1
24727: EQUAL
24728: IFFALSE 24763
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24730: LD_ADDR_VAR 0 10
24734: PUSH
24735: LD_VAR 0 10
24739: PUSH
24740: LD_VAR 0 6
24744: PPUSH
24745: CALL_OW 311
24749: PPUSH
24750: LD_INT 3
24752: PPUSH
24753: CALL_OW 259
24757: PUSH
24758: LD_INT 4
24760: MUL
24761: MUL
24762: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24763: LD_VAR 0 6
24767: PPUSH
24768: CALL_OW 263
24772: PUSH
24773: LD_INT 2
24775: EQUAL
24776: IFFALSE 24827
// begin j := IsControledBy ( i ) ;
24778: LD_ADDR_VAR 0 7
24782: PUSH
24783: LD_VAR 0 6
24787: PPUSH
24788: CALL_OW 312
24792: ST_TO_ADDR
// if j then
24793: LD_VAR 0 7
24797: IFFALSE 24827
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24799: LD_ADDR_VAR 0 10
24803: PUSH
24804: LD_VAR 0 10
24808: PUSH
24809: LD_VAR 0 7
24813: PPUSH
24814: LD_INT 3
24816: PPUSH
24817: CALL_OW 259
24821: PUSH
24822: LD_INT 3
24824: MUL
24825: MUL
24826: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24827: LD_VAR 0 6
24831: PPUSH
24832: CALL_OW 264
24836: PUSH
24837: LD_INT 5
24839: PUSH
24840: LD_INT 6
24842: PUSH
24843: LD_INT 46
24845: PUSH
24846: LD_INT 44
24848: PUSH
24849: LD_INT 47
24851: PUSH
24852: LD_INT 45
24854: PUSH
24855: LD_INT 28
24857: PUSH
24858: LD_INT 7
24860: PUSH
24861: LD_INT 27
24863: PUSH
24864: LD_INT 29
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: LIST
24872: LIST
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: LIST
24878: IN
24879: PUSH
24880: LD_VAR 0 1
24884: PPUSH
24885: LD_INT 52
24887: PPUSH
24888: CALL_OW 321
24892: PUSH
24893: LD_INT 2
24895: EQUAL
24896: AND
24897: IFFALSE 24914
// bpoints := bpoints * 1.2 ;
24899: LD_ADDR_VAR 0 10
24903: PUSH
24904: LD_VAR 0 10
24908: PUSH
24909: LD_REAL  1.20000000000000E+0000
24912: MUL
24913: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24914: LD_VAR 0 6
24918: PPUSH
24919: CALL_OW 264
24923: PUSH
24924: LD_INT 6
24926: PUSH
24927: LD_INT 46
24929: PUSH
24930: LD_INT 47
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: LIST
24937: IN
24938: IFFALSE 24955
// bpoints := bpoints * 1.2 ;
24940: LD_ADDR_VAR 0 10
24944: PUSH
24945: LD_VAR 0 10
24949: PUSH
24950: LD_REAL  1.20000000000000E+0000
24953: MUL
24954: ST_TO_ADDR
// end ; unit_building :
24955: GO 24969
24957: LD_INT 3
24959: DOUBLE
24960: EQUAL
24961: IFTRUE 24965
24963: GO 24968
24965: POP
// ; end ;
24966: GO 24969
24968: POP
// for j = 1 to 3 do
24969: LD_ADDR_VAR 0 7
24973: PUSH
24974: DOUBLE
24975: LD_INT 1
24977: DEC
24978: ST_TO_ADDR
24979: LD_INT 3
24981: PUSH
24982: FOR_TO
24983: IFFALSE 25036
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24985: LD_ADDR_VAR 0 5
24989: PUSH
24990: LD_VAR 0 5
24994: PPUSH
24995: LD_VAR 0 7
24999: PPUSH
25000: LD_VAR 0 5
25004: PUSH
25005: LD_VAR 0 7
25009: ARRAY
25010: PUSH
25011: LD_VAR 0 9
25015: PUSH
25016: LD_VAR 0 7
25020: ARRAY
25021: PUSH
25022: LD_VAR 0 10
25026: MUL
25027: PLUS
25028: PPUSH
25029: CALL_OW 1
25033: ST_TO_ADDR
25034: GO 24982
25036: POP
25037: POP
// end ;
25038: GO 23521
25040: POP
25041: POP
// result := Replace ( result , 4 , tmp ) ;
25042: LD_ADDR_VAR 0 5
25046: PUSH
25047: LD_VAR 0 5
25051: PPUSH
25052: LD_INT 4
25054: PPUSH
25055: LD_VAR 0 8
25059: PPUSH
25060: CALL_OW 1
25064: ST_TO_ADDR
// end ;
25065: LD_VAR 0 5
25069: RET
// export function DangerAtRange ( unit , range ) ; begin
25070: LD_INT 0
25072: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25073: LD_ADDR_VAR 0 3
25077: PUSH
25078: LD_VAR 0 1
25082: PPUSH
25083: CALL_OW 255
25087: PPUSH
25088: LD_VAR 0 1
25092: PPUSH
25093: CALL_OW 250
25097: PPUSH
25098: LD_VAR 0 1
25102: PPUSH
25103: CALL_OW 251
25107: PPUSH
25108: LD_VAR 0 2
25112: PPUSH
25113: CALL 23373 0 4
25117: ST_TO_ADDR
// end ;
25118: LD_VAR 0 3
25122: RET
// export function DangerInArea ( side , area ) ; begin
25123: LD_INT 0
25125: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25126: LD_ADDR_VAR 0 3
25130: PUSH
25131: LD_VAR 0 2
25135: PPUSH
25136: LD_INT 81
25138: PUSH
25139: LD_VAR 0 1
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PPUSH
25148: CALL_OW 70
25152: ST_TO_ADDR
// end ;
25153: LD_VAR 0 3
25157: RET
// export function IsExtension ( b ) ; begin
25158: LD_INT 0
25160: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25161: LD_ADDR_VAR 0 2
25165: PUSH
25166: LD_VAR 0 1
25170: PUSH
25171: LD_INT 23
25173: PUSH
25174: LD_INT 20
25176: PUSH
25177: LD_INT 22
25179: PUSH
25180: LD_INT 17
25182: PUSH
25183: LD_INT 24
25185: PUSH
25186: LD_INT 21
25188: PUSH
25189: LD_INT 19
25191: PUSH
25192: LD_INT 16
25194: PUSH
25195: LD_INT 25
25197: PUSH
25198: LD_INT 18
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: IN
25213: ST_TO_ADDR
// end ;
25214: LD_VAR 0 2
25218: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
25219: LD_INT 0
25221: PPUSH
25222: PPUSH
25223: PPUSH
// result := [ ] ;
25224: LD_ADDR_VAR 0 3
25228: PUSH
25229: EMPTY
25230: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25231: LD_ADDR_VAR 0 4
25235: PUSH
25236: LD_VAR 0 2
25240: PPUSH
25241: LD_INT 21
25243: PUSH
25244: LD_INT 3
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 70
25255: ST_TO_ADDR
// if not tmp then
25256: LD_VAR 0 4
25260: NOT
25261: IFFALSE 25265
// exit ;
25263: GO 25323
// for i in tmp do
25265: LD_ADDR_VAR 0 5
25269: PUSH
25270: LD_VAR 0 4
25274: PUSH
25275: FOR_IN
25276: IFFALSE 25311
// if GetBase ( i ) <> base then
25278: LD_VAR 0 5
25282: PPUSH
25283: CALL_OW 274
25287: PUSH
25288: LD_VAR 0 1
25292: NONEQUAL
25293: IFFALSE 25309
// ComLinkToBase ( base , i ) ;
25295: LD_VAR 0 1
25299: PPUSH
25300: LD_VAR 0 5
25304: PPUSH
25305: CALL_OW 169
25309: GO 25275
25311: POP
25312: POP
// result := tmp ;
25313: LD_ADDR_VAR 0 3
25317: PUSH
25318: LD_VAR 0 4
25322: ST_TO_ADDR
// end ;
25323: LD_VAR 0 3
25327: RET
// export function ComComplete ( unit , b ) ; var i ; begin
25328: LD_INT 0
25330: PPUSH
25331: PPUSH
// if BuildingStatus ( b ) = bs_build then
25332: LD_VAR 0 2
25336: PPUSH
25337: CALL_OW 461
25341: PUSH
25342: LD_INT 1
25344: EQUAL
25345: IFFALSE 25405
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25347: LD_VAR 0 1
25351: PPUSH
25352: LD_STRING h
25354: PUSH
25355: LD_VAR 0 2
25359: PPUSH
25360: CALL_OW 250
25364: PUSH
25365: LD_VAR 0 2
25369: PPUSH
25370: CALL_OW 251
25374: PUSH
25375: LD_VAR 0 2
25379: PUSH
25380: LD_INT 0
25382: PUSH
25383: LD_INT 0
25385: PUSH
25386: LD_INT 0
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: LIST
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: PUSH
25398: EMPTY
25399: LIST
25400: PPUSH
25401: CALL_OW 446
// end ;
25405: LD_VAR 0 3
25409: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25410: LD_INT 0
25412: PPUSH
25413: PPUSH
25414: PPUSH
25415: PPUSH
25416: PPUSH
25417: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
25418: LD_VAR 0 1
25422: NOT
25423: PUSH
25424: LD_VAR 0 1
25428: PPUSH
25429: CALL_OW 263
25433: PUSH
25434: LD_INT 2
25436: EQUAL
25437: NOT
25438: OR
25439: IFFALSE 25443
// exit ;
25441: GO 25759
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25443: LD_ADDR_VAR 0 6
25447: PUSH
25448: LD_INT 22
25450: PUSH
25451: LD_VAR 0 1
25455: PPUSH
25456: CALL_OW 255
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 2
25467: PUSH
25468: LD_INT 30
25470: PUSH
25471: LD_INT 36
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 34
25480: PUSH
25481: LD_INT 31
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: LIST
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PPUSH
25497: CALL_OW 69
25501: ST_TO_ADDR
// if not tmp then
25502: LD_VAR 0 6
25506: NOT
25507: IFFALSE 25511
// exit ;
25509: GO 25759
// result := [ ] ;
25511: LD_ADDR_VAR 0 2
25515: PUSH
25516: EMPTY
25517: ST_TO_ADDR
// for i in tmp do
25518: LD_ADDR_VAR 0 3
25522: PUSH
25523: LD_VAR 0 6
25527: PUSH
25528: FOR_IN
25529: IFFALSE 25600
// begin t := UnitsInside ( i ) ;
25531: LD_ADDR_VAR 0 4
25535: PUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL_OW 313
25545: ST_TO_ADDR
// if t then
25546: LD_VAR 0 4
25550: IFFALSE 25598
// for j in t do
25552: LD_ADDR_VAR 0 7
25556: PUSH
25557: LD_VAR 0 4
25561: PUSH
25562: FOR_IN
25563: IFFALSE 25596
// result := Insert ( result , result + 1 , j ) ;
25565: LD_ADDR_VAR 0 2
25569: PUSH
25570: LD_VAR 0 2
25574: PPUSH
25575: LD_VAR 0 2
25579: PUSH
25580: LD_INT 1
25582: PLUS
25583: PPUSH
25584: LD_VAR 0 7
25588: PPUSH
25589: CALL_OW 2
25593: ST_TO_ADDR
25594: GO 25562
25596: POP
25597: POP
// end ;
25598: GO 25528
25600: POP
25601: POP
// if not result then
25602: LD_VAR 0 2
25606: NOT
25607: IFFALSE 25611
// exit ;
25609: GO 25759
// mech := result [ 1 ] ;
25611: LD_ADDR_VAR 0 5
25615: PUSH
25616: LD_VAR 0 2
25620: PUSH
25621: LD_INT 1
25623: ARRAY
25624: ST_TO_ADDR
// if result > 1 then
25625: LD_VAR 0 2
25629: PUSH
25630: LD_INT 1
25632: GREATER
25633: IFFALSE 25745
// for i = 2 to result do
25635: LD_ADDR_VAR 0 3
25639: PUSH
25640: DOUBLE
25641: LD_INT 2
25643: DEC
25644: ST_TO_ADDR
25645: LD_VAR 0 2
25649: PUSH
25650: FOR_TO
25651: IFFALSE 25743
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25653: LD_ADDR_VAR 0 4
25657: PUSH
25658: LD_VAR 0 2
25662: PUSH
25663: LD_VAR 0 3
25667: ARRAY
25668: PPUSH
25669: LD_INT 3
25671: PPUSH
25672: CALL_OW 259
25676: PUSH
25677: LD_VAR 0 2
25681: PUSH
25682: LD_VAR 0 3
25686: ARRAY
25687: PPUSH
25688: CALL_OW 432
25692: MINUS
25693: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25694: LD_VAR 0 4
25698: PUSH
25699: LD_VAR 0 5
25703: PPUSH
25704: LD_INT 3
25706: PPUSH
25707: CALL_OW 259
25711: PUSH
25712: LD_VAR 0 5
25716: PPUSH
25717: CALL_OW 432
25721: MINUS
25722: GREATEREQUAL
25723: IFFALSE 25741
// mech := result [ i ] ;
25725: LD_ADDR_VAR 0 5
25729: PUSH
25730: LD_VAR 0 2
25734: PUSH
25735: LD_VAR 0 3
25739: ARRAY
25740: ST_TO_ADDR
// end ;
25741: GO 25650
25743: POP
25744: POP
// ComLinkTo ( vehicle , mech ) ;
25745: LD_VAR 0 1
25749: PPUSH
25750: LD_VAR 0 5
25754: PPUSH
25755: CALL_OW 135
// end ;
25759: LD_VAR 0 2
25763: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25764: LD_INT 0
25766: PPUSH
25767: PPUSH
25768: PPUSH
25769: PPUSH
25770: PPUSH
25771: PPUSH
25772: PPUSH
25773: PPUSH
25774: PPUSH
25775: PPUSH
25776: PPUSH
25777: PPUSH
25778: PPUSH
// result := [ ] ;
25779: LD_ADDR_VAR 0 7
25783: PUSH
25784: EMPTY
25785: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25786: LD_VAR 0 1
25790: PPUSH
25791: CALL_OW 266
25795: PUSH
25796: LD_INT 0
25798: PUSH
25799: LD_INT 1
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: IN
25806: NOT
25807: IFFALSE 25811
// exit ;
25809: GO 27442
// if name then
25811: LD_VAR 0 3
25815: IFFALSE 25831
// SetBName ( base_dep , name ) ;
25817: LD_VAR 0 1
25821: PPUSH
25822: LD_VAR 0 3
25826: PPUSH
25827: CALL_OW 500
// base := GetBase ( base_dep ) ;
25831: LD_ADDR_VAR 0 15
25835: PUSH
25836: LD_VAR 0 1
25840: PPUSH
25841: CALL_OW 274
25845: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25846: LD_ADDR_VAR 0 16
25850: PUSH
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 255
25860: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25861: LD_ADDR_VAR 0 17
25865: PUSH
25866: LD_VAR 0 1
25870: PPUSH
25871: CALL_OW 248
25875: ST_TO_ADDR
// if sources then
25876: LD_VAR 0 5
25880: IFFALSE 25927
// for i = 1 to 3 do
25882: LD_ADDR_VAR 0 8
25886: PUSH
25887: DOUBLE
25888: LD_INT 1
25890: DEC
25891: ST_TO_ADDR
25892: LD_INT 3
25894: PUSH
25895: FOR_TO
25896: IFFALSE 25925
// AddResourceType ( base , i , sources [ i ] ) ;
25898: LD_VAR 0 15
25902: PPUSH
25903: LD_VAR 0 8
25907: PPUSH
25908: LD_VAR 0 5
25912: PUSH
25913: LD_VAR 0 8
25917: ARRAY
25918: PPUSH
25919: CALL_OW 276
25923: GO 25895
25925: POP
25926: POP
// buildings := GetBaseBuildings ( base , area ) ;
25927: LD_ADDR_VAR 0 18
25931: PUSH
25932: LD_VAR 0 15
25936: PPUSH
25937: LD_VAR 0 2
25941: PPUSH
25942: CALL 25219 0 2
25946: ST_TO_ADDR
// InitHc ;
25947: CALL_OW 19
// InitUc ;
25951: CALL_OW 18
// uc_side := side ;
25955: LD_ADDR_OWVAR 20
25959: PUSH
25960: LD_VAR 0 16
25964: ST_TO_ADDR
// uc_nation := nation ;
25965: LD_ADDR_OWVAR 21
25969: PUSH
25970: LD_VAR 0 17
25974: ST_TO_ADDR
// if buildings then
25975: LD_VAR 0 18
25979: IFFALSE 27301
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25981: LD_ADDR_VAR 0 19
25985: PUSH
25986: LD_VAR 0 18
25990: PPUSH
25991: LD_INT 2
25993: PUSH
25994: LD_INT 30
25996: PUSH
25997: LD_INT 29
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 30
26006: PUSH
26007: LD_INT 30
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: LIST
26018: PPUSH
26019: CALL_OW 72
26023: ST_TO_ADDR
// if tmp then
26024: LD_VAR 0 19
26028: IFFALSE 26076
// for i in tmp do
26030: LD_ADDR_VAR 0 8
26034: PUSH
26035: LD_VAR 0 19
26039: PUSH
26040: FOR_IN
26041: IFFALSE 26074
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26043: LD_VAR 0 8
26047: PPUSH
26048: CALL_OW 250
26052: PPUSH
26053: LD_VAR 0 8
26057: PPUSH
26058: CALL_OW 251
26062: PPUSH
26063: LD_VAR 0 16
26067: PPUSH
26068: CALL_OW 441
26072: GO 26040
26074: POP
26075: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26076: LD_VAR 0 18
26080: PPUSH
26081: LD_INT 2
26083: PUSH
26084: LD_INT 30
26086: PUSH
26087: LD_INT 32
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: PUSH
26094: LD_INT 30
26096: PUSH
26097: LD_INT 33
26099: PUSH
26100: EMPTY
26101: LIST
26102: LIST
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: LIST
26108: PPUSH
26109: CALL_OW 72
26113: IFFALSE 26201
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26115: LD_ADDR_VAR 0 8
26119: PUSH
26120: LD_VAR 0 18
26124: PPUSH
26125: LD_INT 2
26127: PUSH
26128: LD_INT 30
26130: PUSH
26131: LD_INT 32
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: PUSH
26138: LD_INT 30
26140: PUSH
26141: LD_INT 33
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: LIST
26152: PPUSH
26153: CALL_OW 72
26157: PUSH
26158: FOR_IN
26159: IFFALSE 26199
// begin if not GetBWeapon ( i ) then
26161: LD_VAR 0 8
26165: PPUSH
26166: CALL_OW 269
26170: NOT
26171: IFFALSE 26197
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26173: LD_VAR 0 8
26177: PPUSH
26178: LD_VAR 0 8
26182: PPUSH
26183: LD_VAR 0 2
26187: PPUSH
26188: CALL 27447 0 2
26192: PPUSH
26193: CALL_OW 431
// end ;
26197: GO 26158
26199: POP
26200: POP
// end ; for i = 1 to personel do
26201: LD_ADDR_VAR 0 8
26205: PUSH
26206: DOUBLE
26207: LD_INT 1
26209: DEC
26210: ST_TO_ADDR
26211: LD_VAR 0 6
26215: PUSH
26216: FOR_TO
26217: IFFALSE 27281
// begin if i > 4 then
26219: LD_VAR 0 8
26223: PUSH
26224: LD_INT 4
26226: GREATER
26227: IFFALSE 26231
// break ;
26229: GO 27281
// case i of 1 :
26231: LD_VAR 0 8
26235: PUSH
26236: LD_INT 1
26238: DOUBLE
26239: EQUAL
26240: IFTRUE 26244
26242: GO 26324
26244: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26245: LD_ADDR_VAR 0 12
26249: PUSH
26250: LD_VAR 0 18
26254: PPUSH
26255: LD_INT 22
26257: PUSH
26258: LD_VAR 0 16
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 58
26269: PUSH
26270: EMPTY
26271: LIST
26272: PUSH
26273: LD_INT 2
26275: PUSH
26276: LD_INT 30
26278: PUSH
26279: LD_INT 32
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 30
26288: PUSH
26289: LD_INT 4
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 30
26298: PUSH
26299: LD_INT 5
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: LIST
26316: PPUSH
26317: CALL_OW 72
26321: ST_TO_ADDR
26322: GO 26546
26324: LD_INT 2
26326: DOUBLE
26327: EQUAL
26328: IFTRUE 26332
26330: GO 26394
26332: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26333: LD_ADDR_VAR 0 12
26337: PUSH
26338: LD_VAR 0 18
26342: PPUSH
26343: LD_INT 22
26345: PUSH
26346: LD_VAR 0 16
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 2
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 0
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: LD_INT 30
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: LIST
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: PPUSH
26387: CALL_OW 72
26391: ST_TO_ADDR
26392: GO 26546
26394: LD_INT 3
26396: DOUBLE
26397: EQUAL
26398: IFTRUE 26402
26400: GO 26464
26402: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26403: LD_ADDR_VAR 0 12
26407: PUSH
26408: LD_VAR 0 18
26412: PPUSH
26413: LD_INT 22
26415: PUSH
26416: LD_VAR 0 16
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 30
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: LD_INT 30
26440: PUSH
26441: LD_INT 3
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: LIST
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PPUSH
26457: CALL_OW 72
26461: ST_TO_ADDR
26462: GO 26546
26464: LD_INT 4
26466: DOUBLE
26467: EQUAL
26468: IFTRUE 26472
26470: GO 26545
26472: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26473: LD_ADDR_VAR 0 12
26477: PUSH
26478: LD_VAR 0 18
26482: PPUSH
26483: LD_INT 22
26485: PUSH
26486: LD_VAR 0 16
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 2
26497: PUSH
26498: LD_INT 30
26500: PUSH
26501: LD_INT 6
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: LD_INT 30
26510: PUSH
26511: LD_INT 7
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: LD_INT 30
26520: PUSH
26521: LD_INT 8
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL_OW 72
26542: ST_TO_ADDR
26543: GO 26546
26545: POP
// if i = 1 then
26546: LD_VAR 0 8
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26665
// begin tmp := [ ] ;
26556: LD_ADDR_VAR 0 19
26560: PUSH
26561: EMPTY
26562: ST_TO_ADDR
// for j in f do
26563: LD_ADDR_VAR 0 9
26567: PUSH
26568: LD_VAR 0 12
26572: PUSH
26573: FOR_IN
26574: IFFALSE 26647
// if GetBType ( j ) = b_bunker then
26576: LD_VAR 0 9
26580: PPUSH
26581: CALL_OW 266
26585: PUSH
26586: LD_INT 32
26588: EQUAL
26589: IFFALSE 26616
// tmp := Insert ( tmp , 1 , j ) else
26591: LD_ADDR_VAR 0 19
26595: PUSH
26596: LD_VAR 0 19
26600: PPUSH
26601: LD_INT 1
26603: PPUSH
26604: LD_VAR 0 9
26608: PPUSH
26609: CALL_OW 2
26613: ST_TO_ADDR
26614: GO 26645
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26616: LD_ADDR_VAR 0 19
26620: PUSH
26621: LD_VAR 0 19
26625: PPUSH
26626: LD_VAR 0 19
26630: PUSH
26631: LD_INT 1
26633: PLUS
26634: PPUSH
26635: LD_VAR 0 9
26639: PPUSH
26640: CALL_OW 2
26644: ST_TO_ADDR
26645: GO 26573
26647: POP
26648: POP
// if tmp then
26649: LD_VAR 0 19
26653: IFFALSE 26665
// f := tmp ;
26655: LD_ADDR_VAR 0 12
26659: PUSH
26660: LD_VAR 0 19
26664: ST_TO_ADDR
// end ; x := personel [ i ] ;
26665: LD_ADDR_VAR 0 13
26669: PUSH
26670: LD_VAR 0 6
26674: PUSH
26675: LD_VAR 0 8
26679: ARRAY
26680: ST_TO_ADDR
// if x = - 1 then
26681: LD_VAR 0 13
26685: PUSH
26686: LD_INT 1
26688: NEG
26689: EQUAL
26690: IFFALSE 26899
// begin for j in f do
26692: LD_ADDR_VAR 0 9
26696: PUSH
26697: LD_VAR 0 12
26701: PUSH
26702: FOR_IN
26703: IFFALSE 26895
// repeat InitHc ;
26705: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26709: LD_VAR 0 9
26713: PPUSH
26714: CALL_OW 266
26718: PUSH
26719: LD_INT 5
26721: EQUAL
26722: IFFALSE 26792
// begin if UnitsInside ( j ) < 3 then
26724: LD_VAR 0 9
26728: PPUSH
26729: CALL_OW 313
26733: PUSH
26734: LD_INT 3
26736: LESS
26737: IFFALSE 26773
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26739: LD_INT 0
26741: PPUSH
26742: LD_INT 5
26744: PUSH
26745: LD_INT 8
26747: PUSH
26748: LD_INT 9
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: LIST
26755: PUSH
26756: LD_VAR 0 17
26760: ARRAY
26761: PPUSH
26762: LD_VAR 0 4
26766: PPUSH
26767: CALL_OW 380
26771: GO 26790
// PrepareHuman ( false , i , skill ) ;
26773: LD_INT 0
26775: PPUSH
26776: LD_VAR 0 8
26780: PPUSH
26781: LD_VAR 0 4
26785: PPUSH
26786: CALL_OW 380
// end else
26790: GO 26809
// PrepareHuman ( false , i , skill ) ;
26792: LD_INT 0
26794: PPUSH
26795: LD_VAR 0 8
26799: PPUSH
26800: LD_VAR 0 4
26804: PPUSH
26805: CALL_OW 380
// un := CreateHuman ;
26809: LD_ADDR_VAR 0 14
26813: PUSH
26814: CALL_OW 44
26818: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26819: LD_ADDR_VAR 0 7
26823: PUSH
26824: LD_VAR 0 7
26828: PPUSH
26829: LD_INT 1
26831: PPUSH
26832: LD_VAR 0 14
26836: PPUSH
26837: CALL_OW 2
26841: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26842: LD_VAR 0 14
26846: PPUSH
26847: LD_VAR 0 9
26851: PPUSH
26852: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26856: LD_VAR 0 9
26860: PPUSH
26861: CALL_OW 313
26865: PUSH
26866: LD_INT 6
26868: EQUAL
26869: PUSH
26870: LD_VAR 0 9
26874: PPUSH
26875: CALL_OW 266
26879: PUSH
26880: LD_INT 32
26882: PUSH
26883: LD_INT 31
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: IN
26890: OR
26891: IFFALSE 26705
26893: GO 26702
26895: POP
26896: POP
// end else
26897: GO 27279
// for j = 1 to x do
26899: LD_ADDR_VAR 0 9
26903: PUSH
26904: DOUBLE
26905: LD_INT 1
26907: DEC
26908: ST_TO_ADDR
26909: LD_VAR 0 13
26913: PUSH
26914: FOR_TO
26915: IFFALSE 27277
// begin InitHc ;
26917: CALL_OW 19
// if not f then
26921: LD_VAR 0 12
26925: NOT
26926: IFFALSE 27015
// begin PrepareHuman ( false , i , skill ) ;
26928: LD_INT 0
26930: PPUSH
26931: LD_VAR 0 8
26935: PPUSH
26936: LD_VAR 0 4
26940: PPUSH
26941: CALL_OW 380
// un := CreateHuman ;
26945: LD_ADDR_VAR 0 14
26949: PUSH
26950: CALL_OW 44
26954: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26955: LD_ADDR_VAR 0 7
26959: PUSH
26960: LD_VAR 0 7
26964: PPUSH
26965: LD_INT 1
26967: PPUSH
26968: LD_VAR 0 14
26972: PPUSH
26973: CALL_OW 2
26977: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26978: LD_VAR 0 14
26982: PPUSH
26983: LD_VAR 0 1
26987: PPUSH
26988: CALL_OW 250
26992: PPUSH
26993: LD_VAR 0 1
26997: PPUSH
26998: CALL_OW 251
27002: PPUSH
27003: LD_INT 10
27005: PPUSH
27006: LD_INT 0
27008: PPUSH
27009: CALL_OW 50
// continue ;
27013: GO 26914
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27015: LD_VAR 0 12
27019: PUSH
27020: LD_INT 1
27022: ARRAY
27023: PPUSH
27024: CALL_OW 313
27028: PUSH
27029: LD_VAR 0 12
27033: PUSH
27034: LD_INT 1
27036: ARRAY
27037: PPUSH
27038: CALL_OW 266
27042: PUSH
27043: LD_INT 32
27045: PUSH
27046: LD_INT 31
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: IN
27053: AND
27054: PUSH
27055: LD_VAR 0 12
27059: PUSH
27060: LD_INT 1
27062: ARRAY
27063: PPUSH
27064: CALL_OW 313
27068: PUSH
27069: LD_INT 6
27071: EQUAL
27072: OR
27073: IFFALSE 27093
// f := Delete ( f , 1 ) ;
27075: LD_ADDR_VAR 0 12
27079: PUSH
27080: LD_VAR 0 12
27084: PPUSH
27085: LD_INT 1
27087: PPUSH
27088: CALL_OW 3
27092: ST_TO_ADDR
// if not f then
27093: LD_VAR 0 12
27097: NOT
27098: IFFALSE 27116
// begin x := x + 2 ;
27100: LD_ADDR_VAR 0 13
27104: PUSH
27105: LD_VAR 0 13
27109: PUSH
27110: LD_INT 2
27112: PLUS
27113: ST_TO_ADDR
// continue ;
27114: GO 26914
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27116: LD_VAR 0 12
27120: PUSH
27121: LD_INT 1
27123: ARRAY
27124: PPUSH
27125: CALL_OW 266
27129: PUSH
27130: LD_INT 5
27132: EQUAL
27133: IFFALSE 27207
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27135: LD_VAR 0 12
27139: PUSH
27140: LD_INT 1
27142: ARRAY
27143: PPUSH
27144: CALL_OW 313
27148: PUSH
27149: LD_INT 3
27151: LESS
27152: IFFALSE 27188
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27154: LD_INT 0
27156: PPUSH
27157: LD_INT 5
27159: PUSH
27160: LD_INT 8
27162: PUSH
27163: LD_INT 9
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: LIST
27170: PUSH
27171: LD_VAR 0 17
27175: ARRAY
27176: PPUSH
27177: LD_VAR 0 4
27181: PPUSH
27182: CALL_OW 380
27186: GO 27205
// PrepareHuman ( false , i , skill ) ;
27188: LD_INT 0
27190: PPUSH
27191: LD_VAR 0 8
27195: PPUSH
27196: LD_VAR 0 4
27200: PPUSH
27201: CALL_OW 380
// end else
27205: GO 27224
// PrepareHuman ( false , i , skill ) ;
27207: LD_INT 0
27209: PPUSH
27210: LD_VAR 0 8
27214: PPUSH
27215: LD_VAR 0 4
27219: PPUSH
27220: CALL_OW 380
// un := CreateHuman ;
27224: LD_ADDR_VAR 0 14
27228: PUSH
27229: CALL_OW 44
27233: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27234: LD_ADDR_VAR 0 7
27238: PUSH
27239: LD_VAR 0 7
27243: PPUSH
27244: LD_INT 1
27246: PPUSH
27247: LD_VAR 0 14
27251: PPUSH
27252: CALL_OW 2
27256: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27257: LD_VAR 0 14
27261: PPUSH
27262: LD_VAR 0 12
27266: PUSH
27267: LD_INT 1
27269: ARRAY
27270: PPUSH
27271: CALL_OW 52
// end ;
27275: GO 26914
27277: POP
27278: POP
// end ;
27279: GO 26216
27281: POP
27282: POP
// result := result ^ buildings ;
27283: LD_ADDR_VAR 0 7
27287: PUSH
27288: LD_VAR 0 7
27292: PUSH
27293: LD_VAR 0 18
27297: ADD
27298: ST_TO_ADDR
// end else
27299: GO 27442
// begin for i = 1 to personel do
27301: LD_ADDR_VAR 0 8
27305: PUSH
27306: DOUBLE
27307: LD_INT 1
27309: DEC
27310: ST_TO_ADDR
27311: LD_VAR 0 6
27315: PUSH
27316: FOR_TO
27317: IFFALSE 27440
// begin if i > 4 then
27319: LD_VAR 0 8
27323: PUSH
27324: LD_INT 4
27326: GREATER
27327: IFFALSE 27331
// break ;
27329: GO 27440
// x := personel [ i ] ;
27331: LD_ADDR_VAR 0 13
27335: PUSH
27336: LD_VAR 0 6
27340: PUSH
27341: LD_VAR 0 8
27345: ARRAY
27346: ST_TO_ADDR
// if x = - 1 then
27347: LD_VAR 0 13
27351: PUSH
27352: LD_INT 1
27354: NEG
27355: EQUAL
27356: IFFALSE 27360
// continue ;
27358: GO 27316
// PrepareHuman ( false , i , skill ) ;
27360: LD_INT 0
27362: PPUSH
27363: LD_VAR 0 8
27367: PPUSH
27368: LD_VAR 0 4
27372: PPUSH
27373: CALL_OW 380
// un := CreateHuman ;
27377: LD_ADDR_VAR 0 14
27381: PUSH
27382: CALL_OW 44
27386: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27387: LD_VAR 0 14
27391: PPUSH
27392: LD_VAR 0 1
27396: PPUSH
27397: CALL_OW 250
27401: PPUSH
27402: LD_VAR 0 1
27406: PPUSH
27407: CALL_OW 251
27411: PPUSH
27412: LD_INT 10
27414: PPUSH
27415: LD_INT 0
27417: PPUSH
27418: CALL_OW 50
// result := result ^ un ;
27422: LD_ADDR_VAR 0 7
27426: PUSH
27427: LD_VAR 0 7
27431: PUSH
27432: LD_VAR 0 14
27436: ADD
27437: ST_TO_ADDR
// end ;
27438: GO 27316
27440: POP
27441: POP
// end ; end ;
27442: LD_VAR 0 7
27446: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27447: LD_INT 0
27449: PPUSH
27450: PPUSH
27451: PPUSH
27452: PPUSH
27453: PPUSH
27454: PPUSH
27455: PPUSH
27456: PPUSH
27457: PPUSH
27458: PPUSH
27459: PPUSH
27460: PPUSH
27461: PPUSH
27462: PPUSH
27463: PPUSH
27464: PPUSH
// result := false ;
27465: LD_ADDR_VAR 0 3
27469: PUSH
27470: LD_INT 0
27472: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27473: LD_VAR 0 1
27477: NOT
27478: PUSH
27479: LD_VAR 0 1
27483: PPUSH
27484: CALL_OW 266
27488: PUSH
27489: LD_INT 32
27491: PUSH
27492: LD_INT 33
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: IN
27499: NOT
27500: OR
27501: IFFALSE 27505
// exit ;
27503: GO 28641
// nat := GetNation ( tower ) ;
27505: LD_ADDR_VAR 0 12
27509: PUSH
27510: LD_VAR 0 1
27514: PPUSH
27515: CALL_OW 248
27519: ST_TO_ADDR
// side := GetSide ( tower ) ;
27520: LD_ADDR_VAR 0 16
27524: PUSH
27525: LD_VAR 0 1
27529: PPUSH
27530: CALL_OW 255
27534: ST_TO_ADDR
// x := GetX ( tower ) ;
27535: LD_ADDR_VAR 0 10
27539: PUSH
27540: LD_VAR 0 1
27544: PPUSH
27545: CALL_OW 250
27549: ST_TO_ADDR
// y := GetY ( tower ) ;
27550: LD_ADDR_VAR 0 11
27554: PUSH
27555: LD_VAR 0 1
27559: PPUSH
27560: CALL_OW 251
27564: ST_TO_ADDR
// if not x or not y then
27565: LD_VAR 0 10
27569: NOT
27570: PUSH
27571: LD_VAR 0 11
27575: NOT
27576: OR
27577: IFFALSE 27581
// exit ;
27579: GO 28641
// weapon := 0 ;
27581: LD_ADDR_VAR 0 18
27585: PUSH
27586: LD_INT 0
27588: ST_TO_ADDR
// fac_list := [ ] ;
27589: LD_ADDR_VAR 0 17
27593: PUSH
27594: EMPTY
27595: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
27596: LD_ADDR_VAR 0 6
27600: PUSH
27601: LD_VAR 0 1
27605: PPUSH
27606: CALL_OW 274
27610: PPUSH
27611: LD_VAR 0 2
27615: PPUSH
27616: CALL 25219 0 2
27620: PPUSH
27621: LD_INT 30
27623: PUSH
27624: LD_INT 3
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PPUSH
27631: CALL_OW 72
27635: ST_TO_ADDR
// if not factories then
27636: LD_VAR 0 6
27640: NOT
27641: IFFALSE 27645
// exit ;
27643: GO 28641
// for i in factories do
27645: LD_ADDR_VAR 0 8
27649: PUSH
27650: LD_VAR 0 6
27654: PUSH
27655: FOR_IN
27656: IFFALSE 27681
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27658: LD_ADDR_VAR 0 17
27662: PUSH
27663: LD_VAR 0 17
27667: PUSH
27668: LD_VAR 0 8
27672: PPUSH
27673: CALL_OW 478
27677: UNION
27678: ST_TO_ADDR
27679: GO 27655
27681: POP
27682: POP
// if not fac_list then
27683: LD_VAR 0 17
27687: NOT
27688: IFFALSE 27692
// exit ;
27690: GO 28641
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27692: LD_ADDR_VAR 0 5
27696: PUSH
27697: LD_INT 4
27699: PUSH
27700: LD_INT 5
27702: PUSH
27703: LD_INT 9
27705: PUSH
27706: LD_INT 10
27708: PUSH
27709: LD_INT 6
27711: PUSH
27712: LD_INT 7
27714: PUSH
27715: LD_INT 11
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: LIST
27722: LIST
27723: LIST
27724: LIST
27725: LIST
27726: PUSH
27727: LD_INT 27
27729: PUSH
27730: LD_INT 28
27732: PUSH
27733: LD_INT 26
27735: PUSH
27736: LD_INT 30
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: PUSH
27745: LD_INT 43
27747: PUSH
27748: LD_INT 44
27750: PUSH
27751: LD_INT 46
27753: PUSH
27754: LD_INT 45
27756: PUSH
27757: LD_INT 47
27759: PUSH
27760: LD_INT 49
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: PUSH
27771: EMPTY
27772: LIST
27773: LIST
27774: LIST
27775: PUSH
27776: LD_VAR 0 12
27780: ARRAY
27781: ST_TO_ADDR
// for i in list do
27782: LD_ADDR_VAR 0 8
27786: PUSH
27787: LD_VAR 0 5
27791: PUSH
27792: FOR_IN
27793: IFFALSE 27826
// if not i in fac_list then
27795: LD_VAR 0 8
27799: PUSH
27800: LD_VAR 0 17
27804: IN
27805: NOT
27806: IFFALSE 27824
// list := list diff i ;
27808: LD_ADDR_VAR 0 5
27812: PUSH
27813: LD_VAR 0 5
27817: PUSH
27818: LD_VAR 0 8
27822: DIFF
27823: ST_TO_ADDR
27824: GO 27792
27826: POP
27827: POP
// if not list then
27828: LD_VAR 0 5
27832: NOT
27833: IFFALSE 27837
// exit ;
27835: GO 28641
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27837: LD_VAR 0 12
27841: PUSH
27842: LD_INT 3
27844: EQUAL
27845: PUSH
27846: LD_INT 49
27848: PUSH
27849: LD_VAR 0 5
27853: IN
27854: AND
27855: PUSH
27856: LD_INT 31
27858: PPUSH
27859: LD_VAR 0 16
27863: PPUSH
27864: CALL_OW 321
27868: PUSH
27869: LD_INT 2
27871: EQUAL
27872: AND
27873: IFFALSE 27933
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27875: LD_INT 22
27877: PUSH
27878: LD_VAR 0 16
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 35
27889: PUSH
27890: LD_INT 49
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 91
27899: PUSH
27900: LD_VAR 0 1
27904: PUSH
27905: LD_INT 10
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: LIST
27917: PPUSH
27918: CALL_OW 69
27922: NOT
27923: IFFALSE 27933
// weapon := ru_time_lapser ;
27925: LD_ADDR_VAR 0 18
27929: PUSH
27930: LD_INT 49
27932: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27933: LD_VAR 0 12
27937: PUSH
27938: LD_INT 1
27940: PUSH
27941: LD_INT 2
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: IN
27948: PUSH
27949: LD_INT 11
27951: PUSH
27952: LD_VAR 0 5
27956: IN
27957: PUSH
27958: LD_INT 30
27960: PUSH
27961: LD_VAR 0 5
27965: IN
27966: OR
27967: AND
27968: PUSH
27969: LD_INT 6
27971: PPUSH
27972: LD_VAR 0 16
27976: PPUSH
27977: CALL_OW 321
27981: PUSH
27982: LD_INT 2
27984: EQUAL
27985: AND
27986: IFFALSE 28151
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27988: LD_INT 22
27990: PUSH
27991: LD_VAR 0 16
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 2
28002: PUSH
28003: LD_INT 35
28005: PUSH
28006: LD_INT 11
28008: PUSH
28009: EMPTY
28010: LIST
28011: LIST
28012: PUSH
28013: LD_INT 35
28015: PUSH
28016: LD_INT 30
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: LIST
28027: PUSH
28028: LD_INT 91
28030: PUSH
28031: LD_VAR 0 1
28035: PUSH
28036: LD_INT 18
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: LIST
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: LIST
28048: PPUSH
28049: CALL_OW 69
28053: NOT
28054: PUSH
28055: LD_INT 22
28057: PUSH
28058: LD_VAR 0 16
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 2
28069: PUSH
28070: LD_INT 30
28072: PUSH
28073: LD_INT 32
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 30
28082: PUSH
28083: LD_INT 33
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 91
28097: PUSH
28098: LD_VAR 0 1
28102: PUSH
28103: LD_INT 12
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: LIST
28115: PUSH
28116: EMPTY
28117: LIST
28118: PPUSH
28119: CALL_OW 69
28123: PUSH
28124: LD_INT 2
28126: GREATER
28127: AND
28128: IFFALSE 28151
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28130: LD_ADDR_VAR 0 18
28134: PUSH
28135: LD_INT 11
28137: PUSH
28138: LD_INT 30
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_VAR 0 12
28149: ARRAY
28150: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28151: LD_VAR 0 18
28155: NOT
28156: PUSH
28157: LD_INT 40
28159: PPUSH
28160: LD_VAR 0 16
28164: PPUSH
28165: CALL_OW 321
28169: PUSH
28170: LD_INT 2
28172: EQUAL
28173: AND
28174: PUSH
28175: LD_INT 7
28177: PUSH
28178: LD_VAR 0 5
28182: IN
28183: PUSH
28184: LD_INT 28
28186: PUSH
28187: LD_VAR 0 5
28191: IN
28192: OR
28193: PUSH
28194: LD_INT 45
28196: PUSH
28197: LD_VAR 0 5
28201: IN
28202: OR
28203: AND
28204: IFFALSE 28458
// begin hex := GetHexInfo ( x , y ) ;
28206: LD_ADDR_VAR 0 4
28210: PUSH
28211: LD_VAR 0 10
28215: PPUSH
28216: LD_VAR 0 11
28220: PPUSH
28221: CALL_OW 546
28225: ST_TO_ADDR
// if hex [ 1 ] then
28226: LD_VAR 0 4
28230: PUSH
28231: LD_INT 1
28233: ARRAY
28234: IFFALSE 28238
// exit ;
28236: GO 28641
// height := hex [ 2 ] ;
28238: LD_ADDR_VAR 0 15
28242: PUSH
28243: LD_VAR 0 4
28247: PUSH
28248: LD_INT 2
28250: ARRAY
28251: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28252: LD_ADDR_VAR 0 14
28256: PUSH
28257: LD_INT 0
28259: PUSH
28260: LD_INT 2
28262: PUSH
28263: LD_INT 3
28265: PUSH
28266: LD_INT 5
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: LIST
28273: LIST
28274: ST_TO_ADDR
// for i in tmp do
28275: LD_ADDR_VAR 0 8
28279: PUSH
28280: LD_VAR 0 14
28284: PUSH
28285: FOR_IN
28286: IFFALSE 28456
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28288: LD_ADDR_VAR 0 9
28292: PUSH
28293: LD_VAR 0 10
28297: PPUSH
28298: LD_VAR 0 8
28302: PPUSH
28303: LD_INT 5
28305: PPUSH
28306: CALL_OW 272
28310: PUSH
28311: LD_VAR 0 11
28315: PPUSH
28316: LD_VAR 0 8
28320: PPUSH
28321: LD_INT 5
28323: PPUSH
28324: CALL_OW 273
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28333: LD_VAR 0 9
28337: PUSH
28338: LD_INT 1
28340: ARRAY
28341: PPUSH
28342: LD_VAR 0 9
28346: PUSH
28347: LD_INT 2
28349: ARRAY
28350: PPUSH
28351: CALL_OW 488
28355: IFFALSE 28454
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28357: LD_ADDR_VAR 0 4
28361: PUSH
28362: LD_VAR 0 9
28366: PUSH
28367: LD_INT 1
28369: ARRAY
28370: PPUSH
28371: LD_VAR 0 9
28375: PUSH
28376: LD_INT 2
28378: ARRAY
28379: PPUSH
28380: CALL_OW 546
28384: ST_TO_ADDR
// if hex [ 1 ] then
28385: LD_VAR 0 4
28389: PUSH
28390: LD_INT 1
28392: ARRAY
28393: IFFALSE 28397
// continue ;
28395: GO 28285
// h := hex [ 2 ] ;
28397: LD_ADDR_VAR 0 13
28401: PUSH
28402: LD_VAR 0 4
28406: PUSH
28407: LD_INT 2
28409: ARRAY
28410: ST_TO_ADDR
// if h + 7 < height then
28411: LD_VAR 0 13
28415: PUSH
28416: LD_INT 7
28418: PLUS
28419: PUSH
28420: LD_VAR 0 15
28424: LESS
28425: IFFALSE 28454
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28427: LD_ADDR_VAR 0 18
28431: PUSH
28432: LD_INT 7
28434: PUSH
28435: LD_INT 28
28437: PUSH
28438: LD_INT 45
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: LIST
28445: PUSH
28446: LD_VAR 0 12
28450: ARRAY
28451: ST_TO_ADDR
// break ;
28452: GO 28456
// end ; end ; end ;
28454: GO 28285
28456: POP
28457: POP
// end ; if not weapon then
28458: LD_VAR 0 18
28462: NOT
28463: IFFALSE 28523
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28465: LD_ADDR_VAR 0 5
28469: PUSH
28470: LD_VAR 0 5
28474: PUSH
28475: LD_INT 11
28477: PUSH
28478: LD_INT 30
28480: PUSH
28481: LD_INT 49
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: LIST
28488: DIFF
28489: ST_TO_ADDR
// if not list then
28490: LD_VAR 0 5
28494: NOT
28495: IFFALSE 28499
// exit ;
28497: GO 28641
// weapon := list [ rand ( 1 , list ) ] ;
28499: LD_ADDR_VAR 0 18
28503: PUSH
28504: LD_VAR 0 5
28508: PUSH
28509: LD_INT 1
28511: PPUSH
28512: LD_VAR 0 5
28516: PPUSH
28517: CALL_OW 12
28521: ARRAY
28522: ST_TO_ADDR
// end ; if weapon then
28523: LD_VAR 0 18
28527: IFFALSE 28641
// begin tmp := CostOfWeapon ( weapon ) ;
28529: LD_ADDR_VAR 0 14
28533: PUSH
28534: LD_VAR 0 18
28538: PPUSH
28539: CALL_OW 451
28543: ST_TO_ADDR
// j := GetBase ( tower ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 1
28553: PPUSH
28554: CALL_OW 274
28558: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28559: LD_VAR 0 9
28563: PPUSH
28564: LD_INT 1
28566: PPUSH
28567: CALL_OW 275
28571: PUSH
28572: LD_VAR 0 14
28576: PUSH
28577: LD_INT 1
28579: ARRAY
28580: GREATEREQUAL
28581: PUSH
28582: LD_VAR 0 9
28586: PPUSH
28587: LD_INT 2
28589: PPUSH
28590: CALL_OW 275
28594: PUSH
28595: LD_VAR 0 14
28599: PUSH
28600: LD_INT 2
28602: ARRAY
28603: GREATEREQUAL
28604: AND
28605: PUSH
28606: LD_VAR 0 9
28610: PPUSH
28611: LD_INT 3
28613: PPUSH
28614: CALL_OW 275
28618: PUSH
28619: LD_VAR 0 14
28623: PUSH
28624: LD_INT 3
28626: ARRAY
28627: GREATEREQUAL
28628: AND
28629: IFFALSE 28641
// result := weapon ;
28631: LD_ADDR_VAR 0 3
28635: PUSH
28636: LD_VAR 0 18
28640: ST_TO_ADDR
// end ; end ;
28641: LD_VAR 0 3
28645: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28646: LD_INT 0
28648: PPUSH
28649: PPUSH
// result := true ;
28650: LD_ADDR_VAR 0 3
28654: PUSH
28655: LD_INT 1
28657: ST_TO_ADDR
// if array1 = array2 then
28658: LD_VAR 0 1
28662: PUSH
28663: LD_VAR 0 2
28667: EQUAL
28668: IFFALSE 28728
// begin for i = 1 to array1 do
28670: LD_ADDR_VAR 0 4
28674: PUSH
28675: DOUBLE
28676: LD_INT 1
28678: DEC
28679: ST_TO_ADDR
28680: LD_VAR 0 1
28684: PUSH
28685: FOR_TO
28686: IFFALSE 28724
// if array1 [ i ] <> array2 [ i ] then
28688: LD_VAR 0 1
28692: PUSH
28693: LD_VAR 0 4
28697: ARRAY
28698: PUSH
28699: LD_VAR 0 2
28703: PUSH
28704: LD_VAR 0 4
28708: ARRAY
28709: NONEQUAL
28710: IFFALSE 28722
// begin result := false ;
28712: LD_ADDR_VAR 0 3
28716: PUSH
28717: LD_INT 0
28719: ST_TO_ADDR
// break ;
28720: GO 28724
// end ;
28722: GO 28685
28724: POP
28725: POP
// end else
28726: GO 28736
// result := false ;
28728: LD_ADDR_VAR 0 3
28732: PUSH
28733: LD_INT 0
28735: ST_TO_ADDR
// end ;
28736: LD_VAR 0 3
28740: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28741: LD_INT 0
28743: PPUSH
28744: PPUSH
28745: PPUSH
// pom := GetBase ( fac ) ;
28746: LD_ADDR_VAR 0 5
28750: PUSH
28751: LD_VAR 0 1
28755: PPUSH
28756: CALL_OW 274
28760: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28761: LD_ADDR_VAR 0 4
28765: PUSH
28766: LD_VAR 0 2
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: LD_VAR 0 2
28779: PUSH
28780: LD_INT 2
28782: ARRAY
28783: PPUSH
28784: LD_VAR 0 2
28788: PUSH
28789: LD_INT 3
28791: ARRAY
28792: PPUSH
28793: LD_VAR 0 2
28797: PUSH
28798: LD_INT 4
28800: ARRAY
28801: PPUSH
28802: CALL_OW 449
28806: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28807: LD_ADDR_VAR 0 3
28811: PUSH
28812: LD_VAR 0 5
28816: PPUSH
28817: LD_INT 1
28819: PPUSH
28820: CALL_OW 275
28824: PUSH
28825: LD_VAR 0 4
28829: PUSH
28830: LD_INT 1
28832: ARRAY
28833: GREATEREQUAL
28834: PUSH
28835: LD_VAR 0 5
28839: PPUSH
28840: LD_INT 2
28842: PPUSH
28843: CALL_OW 275
28847: PUSH
28848: LD_VAR 0 4
28852: PUSH
28853: LD_INT 2
28855: ARRAY
28856: GREATEREQUAL
28857: AND
28858: PUSH
28859: LD_VAR 0 5
28863: PPUSH
28864: LD_INT 3
28866: PPUSH
28867: CALL_OW 275
28871: PUSH
28872: LD_VAR 0 4
28876: PUSH
28877: LD_INT 3
28879: ARRAY
28880: GREATEREQUAL
28881: AND
28882: ST_TO_ADDR
// end ;
28883: LD_VAR 0 3
28887: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28888: LD_INT 0
28890: PPUSH
28891: PPUSH
28892: PPUSH
28893: PPUSH
// pom := GetBase ( building ) ;
28894: LD_ADDR_VAR 0 3
28898: PUSH
28899: LD_VAR 0 1
28903: PPUSH
28904: CALL_OW 274
28908: ST_TO_ADDR
// if not pom then
28909: LD_VAR 0 3
28913: NOT
28914: IFFALSE 28918
// exit ;
28916: GO 29088
// btype := GetBType ( building ) ;
28918: LD_ADDR_VAR 0 5
28922: PUSH
28923: LD_VAR 0 1
28927: PPUSH
28928: CALL_OW 266
28932: ST_TO_ADDR
// if btype = b_armoury then
28933: LD_VAR 0 5
28937: PUSH
28938: LD_INT 4
28940: EQUAL
28941: IFFALSE 28951
// btype := b_barracks ;
28943: LD_ADDR_VAR 0 5
28947: PUSH
28948: LD_INT 5
28950: ST_TO_ADDR
// if btype = b_depot then
28951: LD_VAR 0 5
28955: PUSH
28956: LD_INT 0
28958: EQUAL
28959: IFFALSE 28969
// btype := b_warehouse ;
28961: LD_ADDR_VAR 0 5
28965: PUSH
28966: LD_INT 1
28968: ST_TO_ADDR
// if btype = b_workshop then
28969: LD_VAR 0 5
28973: PUSH
28974: LD_INT 2
28976: EQUAL
28977: IFFALSE 28987
// btype := b_factory ;
28979: LD_ADDR_VAR 0 5
28983: PUSH
28984: LD_INT 3
28986: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28987: LD_ADDR_VAR 0 4
28991: PUSH
28992: LD_VAR 0 5
28996: PPUSH
28997: LD_VAR 0 1
29001: PPUSH
29002: CALL_OW 248
29006: PPUSH
29007: CALL_OW 450
29011: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29012: LD_ADDR_VAR 0 2
29016: PUSH
29017: LD_VAR 0 3
29021: PPUSH
29022: LD_INT 1
29024: PPUSH
29025: CALL_OW 275
29029: PUSH
29030: LD_VAR 0 4
29034: PUSH
29035: LD_INT 1
29037: ARRAY
29038: GREATEREQUAL
29039: PUSH
29040: LD_VAR 0 3
29044: PPUSH
29045: LD_INT 2
29047: PPUSH
29048: CALL_OW 275
29052: PUSH
29053: LD_VAR 0 4
29057: PUSH
29058: LD_INT 2
29060: ARRAY
29061: GREATEREQUAL
29062: AND
29063: PUSH
29064: LD_VAR 0 3
29068: PPUSH
29069: LD_INT 3
29071: PPUSH
29072: CALL_OW 275
29076: PUSH
29077: LD_VAR 0 4
29081: PUSH
29082: LD_INT 3
29084: ARRAY
29085: GREATEREQUAL
29086: AND
29087: ST_TO_ADDR
// end ;
29088: LD_VAR 0 2
29092: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29093: LD_INT 0
29095: PPUSH
29096: PPUSH
29097: PPUSH
// pom := GetBase ( building ) ;
29098: LD_ADDR_VAR 0 4
29102: PUSH
29103: LD_VAR 0 1
29107: PPUSH
29108: CALL_OW 274
29112: ST_TO_ADDR
// if not pom then
29113: LD_VAR 0 4
29117: NOT
29118: IFFALSE 29122
// exit ;
29120: GO 29223
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29122: LD_ADDR_VAR 0 5
29126: PUSH
29127: LD_VAR 0 2
29131: PPUSH
29132: LD_VAR 0 1
29136: PPUSH
29137: CALL_OW 248
29141: PPUSH
29142: CALL_OW 450
29146: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29147: LD_ADDR_VAR 0 3
29151: PUSH
29152: LD_VAR 0 4
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: CALL_OW 275
29164: PUSH
29165: LD_VAR 0 5
29169: PUSH
29170: LD_INT 1
29172: ARRAY
29173: GREATEREQUAL
29174: PUSH
29175: LD_VAR 0 4
29179: PPUSH
29180: LD_INT 2
29182: PPUSH
29183: CALL_OW 275
29187: PUSH
29188: LD_VAR 0 5
29192: PUSH
29193: LD_INT 2
29195: ARRAY
29196: GREATEREQUAL
29197: AND
29198: PUSH
29199: LD_VAR 0 4
29203: PPUSH
29204: LD_INT 3
29206: PPUSH
29207: CALL_OW 275
29211: PUSH
29212: LD_VAR 0 5
29216: PUSH
29217: LD_INT 3
29219: ARRAY
29220: GREATEREQUAL
29221: AND
29222: ST_TO_ADDR
// end ;
29223: LD_VAR 0 3
29227: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
29228: LD_INT 0
29230: PPUSH
29231: PPUSH
29232: PPUSH
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
29238: PPUSH
29239: PPUSH
// result := false ;
29240: LD_ADDR_VAR 0 6
29244: PUSH
29245: LD_INT 0
29247: ST_TO_ADDR
// if not base or not btype or not x or not y then
29248: LD_VAR 0 1
29252: NOT
29253: PUSH
29254: LD_VAR 0 2
29258: NOT
29259: OR
29260: PUSH
29261: LD_VAR 0 3
29265: NOT
29266: OR
29267: PUSH
29268: LD_VAR 0 4
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 29887
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
29278: LD_ADDR_VAR 0 12
29282: PUSH
29283: LD_VAR 0 2
29287: PPUSH
29288: LD_VAR 0 3
29292: PPUSH
29293: LD_VAR 0 4
29297: PPUSH
29298: LD_VAR 0 5
29302: PPUSH
29303: LD_VAR 0 1
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: CALL_OW 248
29316: PPUSH
29317: LD_INT 0
29319: PPUSH
29320: CALL 30724 0 6
29324: ST_TO_ADDR
// if not hexes then
29325: LD_VAR 0 12
29329: NOT
29330: IFFALSE 29334
// exit ;
29332: GO 29887
// for i = 1 to hexes do
29334: LD_ADDR_VAR 0 7
29338: PUSH
29339: DOUBLE
29340: LD_INT 1
29342: DEC
29343: ST_TO_ADDR
29344: LD_VAR 0 12
29348: PUSH
29349: FOR_TO
29350: IFFALSE 29885
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29352: LD_ADDR_VAR 0 11
29356: PUSH
29357: LD_VAR 0 12
29361: PUSH
29362: LD_VAR 0 7
29366: ARRAY
29367: PUSH
29368: LD_INT 1
29370: ARRAY
29371: PPUSH
29372: LD_VAR 0 12
29376: PUSH
29377: LD_VAR 0 7
29381: ARRAY
29382: PUSH
29383: LD_INT 2
29385: ARRAY
29386: PPUSH
29387: CALL_OW 428
29391: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29392: LD_VAR 0 12
29396: PUSH
29397: LD_VAR 0 7
29401: ARRAY
29402: PUSH
29403: LD_INT 1
29405: ARRAY
29406: PPUSH
29407: LD_VAR 0 12
29411: PUSH
29412: LD_VAR 0 7
29416: ARRAY
29417: PUSH
29418: LD_INT 2
29420: ARRAY
29421: PPUSH
29422: CALL_OW 351
29426: PUSH
29427: LD_VAR 0 12
29431: PUSH
29432: LD_VAR 0 7
29436: ARRAY
29437: PUSH
29438: LD_INT 1
29440: ARRAY
29441: PPUSH
29442: LD_VAR 0 12
29446: PUSH
29447: LD_VAR 0 7
29451: ARRAY
29452: PUSH
29453: LD_INT 2
29455: ARRAY
29456: PPUSH
29457: CALL_OW 488
29461: NOT
29462: OR
29463: PUSH
29464: LD_VAR 0 11
29468: PPUSH
29469: CALL_OW 247
29473: PUSH
29474: LD_INT 3
29476: EQUAL
29477: OR
29478: IFFALSE 29484
// exit ;
29480: POP
29481: POP
29482: GO 29887
// if not tmp or not tmp in base then
29484: LD_VAR 0 11
29488: NOT
29489: PUSH
29490: LD_VAR 0 11
29494: PUSH
29495: LD_VAR 0 1
29499: IN
29500: NOT
29501: OR
29502: IFFALSE 29506
// continue ;
29504: GO 29349
// result := true ;
29506: LD_ADDR_VAR 0 6
29510: PUSH
29511: LD_INT 1
29513: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29514: LD_ADDR_VAR 0 15
29518: PUSH
29519: LD_VAR 0 1
29523: PPUSH
29524: LD_INT 22
29526: PUSH
29527: LD_VAR 0 11
29531: PPUSH
29532: CALL_OW 255
29536: PUSH
29537: EMPTY
29538: LIST
29539: LIST
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: LD_INT 30
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 30
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: LIST
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PPUSH
29573: CALL_OW 72
29577: ST_TO_ADDR
// if dep then
29578: LD_VAR 0 15
29582: IFFALSE 29718
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29584: LD_ADDR_VAR 0 14
29588: PUSH
29589: LD_VAR 0 15
29593: PUSH
29594: LD_INT 1
29596: ARRAY
29597: PPUSH
29598: CALL_OW 250
29602: PPUSH
29603: LD_VAR 0 15
29607: PUSH
29608: LD_INT 1
29610: ARRAY
29611: PPUSH
29612: CALL_OW 254
29616: PPUSH
29617: LD_INT 5
29619: PPUSH
29620: CALL_OW 272
29624: PUSH
29625: LD_VAR 0 15
29629: PUSH
29630: LD_INT 1
29632: ARRAY
29633: PPUSH
29634: CALL_OW 251
29638: PPUSH
29639: LD_VAR 0 15
29643: PUSH
29644: LD_INT 1
29646: ARRAY
29647: PPUSH
29648: CALL_OW 254
29652: PPUSH
29653: LD_INT 5
29655: PPUSH
29656: CALL_OW 273
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29665: LD_VAR 0 14
29669: PUSH
29670: LD_INT 1
29672: ARRAY
29673: PPUSH
29674: LD_VAR 0 14
29678: PUSH
29679: LD_INT 2
29681: ARRAY
29682: PPUSH
29683: CALL_OW 488
29687: IFFALSE 29718
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29689: LD_VAR 0 11
29693: PPUSH
29694: LD_VAR 0 14
29698: PUSH
29699: LD_INT 1
29701: ARRAY
29702: PPUSH
29703: LD_VAR 0 14
29707: PUSH
29708: LD_INT 2
29710: ARRAY
29711: PPUSH
29712: CALL_OW 111
// continue ;
29716: GO 29349
// end ; end ; r := GetDir ( tmp ) ;
29718: LD_ADDR_VAR 0 13
29722: PUSH
29723: LD_VAR 0 11
29727: PPUSH
29728: CALL_OW 254
29732: ST_TO_ADDR
// if r = 5 then
29733: LD_VAR 0 13
29737: PUSH
29738: LD_INT 5
29740: EQUAL
29741: IFFALSE 29751
// r := 0 ;
29743: LD_ADDR_VAR 0 13
29747: PUSH
29748: LD_INT 0
29750: ST_TO_ADDR
// for j = r to 5 do
29751: LD_ADDR_VAR 0 8
29755: PUSH
29756: DOUBLE
29757: LD_VAR 0 13
29761: DEC
29762: ST_TO_ADDR
29763: LD_INT 5
29765: PUSH
29766: FOR_TO
29767: IFFALSE 29881
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29769: LD_ADDR_VAR 0 9
29773: PUSH
29774: LD_VAR 0 11
29778: PPUSH
29779: CALL_OW 250
29783: PPUSH
29784: LD_VAR 0 8
29788: PPUSH
29789: LD_INT 2
29791: PPUSH
29792: CALL_OW 272
29796: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29797: LD_ADDR_VAR 0 10
29801: PUSH
29802: LD_VAR 0 11
29806: PPUSH
29807: CALL_OW 251
29811: PPUSH
29812: LD_VAR 0 8
29816: PPUSH
29817: LD_INT 2
29819: PPUSH
29820: CALL_OW 273
29824: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29825: LD_VAR 0 9
29829: PPUSH
29830: LD_VAR 0 10
29834: PPUSH
29835: CALL_OW 488
29839: PUSH
29840: LD_VAR 0 9
29844: PPUSH
29845: LD_VAR 0 10
29849: PPUSH
29850: CALL_OW 428
29854: NOT
29855: AND
29856: IFFALSE 29879
// begin ComMoveXY ( tmp , _x , _y ) ;
29858: LD_VAR 0 11
29862: PPUSH
29863: LD_VAR 0 9
29867: PPUSH
29868: LD_VAR 0 10
29872: PPUSH
29873: CALL_OW 111
// break ;
29877: GO 29881
// end ; end ;
29879: GO 29766
29881: POP
29882: POP
// end ;
29883: GO 29349
29885: POP
29886: POP
// end ;
29887: LD_VAR 0 6
29891: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
29892: LD_INT 0
29894: PPUSH
29895: PPUSH
29896: PPUSH
29897: PPUSH
29898: PPUSH
29899: PPUSH
29900: PPUSH
29901: PPUSH
29902: PPUSH
29903: PPUSH
// result := false ;
29904: LD_ADDR_VAR 0 6
29908: PUSH
29909: LD_INT 0
29911: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29912: LD_VAR 0 1
29916: NOT
29917: PUSH
29918: LD_VAR 0 1
29922: PPUSH
29923: CALL_OW 266
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: IN
29938: NOT
29939: OR
29940: PUSH
29941: LD_VAR 0 2
29945: NOT
29946: OR
29947: PUSH
29948: LD_VAR 0 5
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 2
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: LD_INT 4
29967: PUSH
29968: LD_INT 5
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: IN
29979: NOT
29980: OR
29981: PUSH
29982: LD_VAR 0 3
29986: PPUSH
29987: LD_VAR 0 4
29991: PPUSH
29992: CALL_OW 488
29996: NOT
29997: OR
29998: IFFALSE 30002
// exit ;
30000: GO 30719
// pom := GetBase ( depot ) ;
30002: LD_ADDR_VAR 0 10
30006: PUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 274
30016: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30017: LD_ADDR_VAR 0 11
30021: PUSH
30022: LD_VAR 0 2
30026: PPUSH
30027: LD_VAR 0 1
30031: PPUSH
30032: CALL_OW 248
30036: PPUSH
30037: CALL_OW 450
30041: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30042: LD_VAR 0 10
30046: PPUSH
30047: LD_INT 1
30049: PPUSH
30050: CALL_OW 275
30054: PUSH
30055: LD_VAR 0 11
30059: PUSH
30060: LD_INT 1
30062: ARRAY
30063: GREATEREQUAL
30064: PUSH
30065: LD_VAR 0 10
30069: PPUSH
30070: LD_INT 2
30072: PPUSH
30073: CALL_OW 275
30077: PUSH
30078: LD_VAR 0 11
30082: PUSH
30083: LD_INT 2
30085: ARRAY
30086: GREATEREQUAL
30087: AND
30088: PUSH
30089: LD_VAR 0 10
30093: PPUSH
30094: LD_INT 3
30096: PPUSH
30097: CALL_OW 275
30101: PUSH
30102: LD_VAR 0 11
30106: PUSH
30107: LD_INT 3
30109: ARRAY
30110: GREATEREQUAL
30111: AND
30112: NOT
30113: IFFALSE 30117
// exit ;
30115: GO 30719
// if GetBType ( depot ) = b_depot then
30117: LD_VAR 0 1
30121: PPUSH
30122: CALL_OW 266
30126: PUSH
30127: LD_INT 0
30129: EQUAL
30130: IFFALSE 30142
// dist := 28 else
30132: LD_ADDR_VAR 0 14
30136: PUSH
30137: LD_INT 28
30139: ST_TO_ADDR
30140: GO 30150
// dist := 36 ;
30142: LD_ADDR_VAR 0 14
30146: PUSH
30147: LD_INT 36
30149: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30150: LD_VAR 0 1
30154: PPUSH
30155: LD_VAR 0 3
30159: PPUSH
30160: LD_VAR 0 4
30164: PPUSH
30165: CALL_OW 297
30169: PUSH
30170: LD_VAR 0 14
30174: GREATER
30175: IFFALSE 30179
// exit ;
30177: GO 30719
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30179: LD_ADDR_VAR 0 12
30183: PUSH
30184: LD_VAR 0 2
30188: PPUSH
30189: LD_VAR 0 3
30193: PPUSH
30194: LD_VAR 0 4
30198: PPUSH
30199: LD_VAR 0 5
30203: PPUSH
30204: LD_VAR 0 1
30208: PPUSH
30209: CALL_OW 248
30213: PPUSH
30214: LD_INT 0
30216: PPUSH
30217: CALL 30724 0 6
30221: ST_TO_ADDR
// if not hexes then
30222: LD_VAR 0 12
30226: NOT
30227: IFFALSE 30231
// exit ;
30229: GO 30719
// hex := GetHexInfo ( x , y ) ;
30231: LD_ADDR_VAR 0 15
30235: PUSH
30236: LD_VAR 0 3
30240: PPUSH
30241: LD_VAR 0 4
30245: PPUSH
30246: CALL_OW 546
30250: ST_TO_ADDR
// if hex [ 1 ] then
30251: LD_VAR 0 15
30255: PUSH
30256: LD_INT 1
30258: ARRAY
30259: IFFALSE 30263
// exit ;
30261: GO 30719
// height := hex [ 2 ] ;
30263: LD_ADDR_VAR 0 13
30267: PUSH
30268: LD_VAR 0 15
30272: PUSH
30273: LD_INT 2
30275: ARRAY
30276: ST_TO_ADDR
// for i = 1 to hexes do
30277: LD_ADDR_VAR 0 7
30281: PUSH
30282: DOUBLE
30283: LD_INT 1
30285: DEC
30286: ST_TO_ADDR
30287: LD_VAR 0 12
30291: PUSH
30292: FOR_TO
30293: IFFALSE 30623
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30295: LD_VAR 0 12
30299: PUSH
30300: LD_VAR 0 7
30304: ARRAY
30305: PUSH
30306: LD_INT 1
30308: ARRAY
30309: PPUSH
30310: LD_VAR 0 12
30314: PUSH
30315: LD_VAR 0 7
30319: ARRAY
30320: PUSH
30321: LD_INT 2
30323: ARRAY
30324: PPUSH
30325: CALL_OW 488
30329: NOT
30330: PUSH
30331: LD_VAR 0 12
30335: PUSH
30336: LD_VAR 0 7
30340: ARRAY
30341: PUSH
30342: LD_INT 1
30344: ARRAY
30345: PPUSH
30346: LD_VAR 0 12
30350: PUSH
30351: LD_VAR 0 7
30355: ARRAY
30356: PUSH
30357: LD_INT 2
30359: ARRAY
30360: PPUSH
30361: CALL_OW 428
30365: PUSH
30366: LD_INT 0
30368: GREATER
30369: OR
30370: PUSH
30371: LD_VAR 0 12
30375: PUSH
30376: LD_VAR 0 7
30380: ARRAY
30381: PUSH
30382: LD_INT 1
30384: ARRAY
30385: PPUSH
30386: LD_VAR 0 12
30390: PUSH
30391: LD_VAR 0 7
30395: ARRAY
30396: PUSH
30397: LD_INT 2
30399: ARRAY
30400: PPUSH
30401: CALL_OW 351
30405: OR
30406: IFFALSE 30412
// exit ;
30408: POP
30409: POP
30410: GO 30719
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30412: LD_ADDR_VAR 0 8
30416: PUSH
30417: LD_VAR 0 12
30421: PUSH
30422: LD_VAR 0 7
30426: ARRAY
30427: PUSH
30428: LD_INT 1
30430: ARRAY
30431: PPUSH
30432: LD_VAR 0 12
30436: PUSH
30437: LD_VAR 0 7
30441: ARRAY
30442: PUSH
30443: LD_INT 2
30445: ARRAY
30446: PPUSH
30447: CALL_OW 546
30451: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30452: LD_VAR 0 8
30456: PUSH
30457: LD_INT 1
30459: ARRAY
30460: PUSH
30461: LD_VAR 0 8
30465: PUSH
30466: LD_INT 2
30468: ARRAY
30469: PUSH
30470: LD_VAR 0 13
30474: PUSH
30475: LD_INT 2
30477: PLUS
30478: GREATER
30479: OR
30480: PUSH
30481: LD_VAR 0 8
30485: PUSH
30486: LD_INT 2
30488: ARRAY
30489: PUSH
30490: LD_VAR 0 13
30494: PUSH
30495: LD_INT 2
30497: MINUS
30498: LESS
30499: OR
30500: PUSH
30501: LD_VAR 0 8
30505: PUSH
30506: LD_INT 3
30508: ARRAY
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 8
30515: PUSH
30516: LD_INT 9
30518: PUSH
30519: LD_INT 10
30521: PUSH
30522: LD_INT 11
30524: PUSH
30525: LD_INT 12
30527: PUSH
30528: LD_INT 13
30530: PUSH
30531: LD_INT 16
30533: PUSH
30534: LD_INT 17
30536: PUSH
30537: LD_INT 18
30539: PUSH
30540: LD_INT 19
30542: PUSH
30543: LD_INT 20
30545: PUSH
30546: LD_INT 21
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: LIST
30562: LIST
30563: IN
30564: NOT
30565: OR
30566: PUSH
30567: LD_VAR 0 8
30571: PUSH
30572: LD_INT 5
30574: ARRAY
30575: NOT
30576: OR
30577: PUSH
30578: LD_VAR 0 8
30582: PUSH
30583: LD_INT 6
30585: ARRAY
30586: PUSH
30587: LD_INT 1
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: LD_INT 7
30595: PUSH
30596: LD_INT 9
30598: PUSH
30599: LD_INT 10
30601: PUSH
30602: LD_INT 11
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: IN
30613: NOT
30614: OR
30615: IFFALSE 30621
// exit ;
30617: POP
30618: POP
30619: GO 30719
// end ;
30621: GO 30292
30623: POP
30624: POP
// side := GetSide ( depot ) ;
30625: LD_ADDR_VAR 0 9
30629: PUSH
30630: LD_VAR 0 1
30634: PPUSH
30635: CALL_OW 255
30639: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30640: LD_VAR 0 9
30644: PPUSH
30645: LD_VAR 0 3
30649: PPUSH
30650: LD_VAR 0 4
30654: PPUSH
30655: LD_INT 20
30657: PPUSH
30658: CALL 23373 0 4
30662: PUSH
30663: LD_INT 4
30665: ARRAY
30666: IFFALSE 30670
// exit ;
30668: GO 30719
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30670: LD_VAR 0 2
30674: PUSH
30675: LD_INT 29
30677: PUSH
30678: LD_INT 30
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: IN
30685: PUSH
30686: LD_VAR 0 3
30690: PPUSH
30691: LD_VAR 0 4
30695: PPUSH
30696: LD_VAR 0 9
30700: PPUSH
30701: CALL_OW 440
30705: NOT
30706: AND
30707: IFFALSE 30711
// exit ;
30709: GO 30719
// result := true ;
30711: LD_ADDR_VAR 0 6
30715: PUSH
30716: LD_INT 1
30718: ST_TO_ADDR
// end ;
30719: LD_VAR 0 6
30723: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30724: LD_INT 0
30726: PPUSH
30727: PPUSH
30728: PPUSH
30729: PPUSH
30730: PPUSH
30731: PPUSH
30732: PPUSH
30733: PPUSH
30734: PPUSH
30735: PPUSH
30736: PPUSH
30737: PPUSH
30738: PPUSH
30739: PPUSH
30740: PPUSH
30741: PPUSH
30742: PPUSH
30743: PPUSH
30744: PPUSH
30745: PPUSH
30746: PPUSH
30747: PPUSH
30748: PPUSH
30749: PPUSH
30750: PPUSH
30751: PPUSH
30752: PPUSH
30753: PPUSH
30754: PPUSH
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
30766: PPUSH
30767: PPUSH
30768: PPUSH
30769: PPUSH
30770: PPUSH
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
30783: PPUSH
// result = [ ] ;
30784: LD_ADDR_VAR 0 7
30788: PUSH
30789: EMPTY
30790: ST_TO_ADDR
// temp_list = [ ] ;
30791: LD_ADDR_VAR 0 9
30795: PUSH
30796: EMPTY
30797: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: LD_INT 3
30814: PUSH
30815: LD_INT 4
30817: PUSH
30818: LD_INT 5
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: IN
30829: NOT
30830: PUSH
30831: LD_VAR 0 1
30835: PUSH
30836: LD_INT 0
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: IN
30846: PUSH
30847: LD_VAR 0 5
30851: PUSH
30852: LD_INT 1
30854: PUSH
30855: LD_INT 2
30857: PUSH
30858: LD_INT 3
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: LIST
30865: IN
30866: NOT
30867: AND
30868: OR
30869: IFFALSE 30873
// exit ;
30871: GO 49264
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30873: LD_VAR 0 1
30877: PUSH
30878: LD_INT 6
30880: PUSH
30881: LD_INT 7
30883: PUSH
30884: LD_INT 8
30886: PUSH
30887: LD_INT 13
30889: PUSH
30890: LD_INT 12
30892: PUSH
30893: LD_INT 15
30895: PUSH
30896: LD_INT 11
30898: PUSH
30899: LD_INT 14
30901: PUSH
30902: LD_INT 10
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: IN
30916: IFFALSE 30926
// btype = b_lab ;
30918: LD_ADDR_VAR 0 1
30922: PUSH
30923: LD_INT 6
30925: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30926: LD_VAR 0 6
30930: PUSH
30931: LD_INT 0
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 2
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: LIST
30944: IN
30945: NOT
30946: PUSH
30947: LD_VAR 0 1
30951: PUSH
30952: LD_INT 0
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 2
30960: PUSH
30961: LD_INT 3
30963: PUSH
30964: LD_INT 6
30966: PUSH
30967: LD_INT 36
30969: PUSH
30970: LD_INT 4
30972: PUSH
30973: LD_INT 5
30975: PUSH
30976: LD_INT 31
30978: PUSH
30979: LD_INT 32
30981: PUSH
30982: LD_INT 33
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: IN
30998: NOT
30999: PUSH
31000: LD_VAR 0 6
31004: PUSH
31005: LD_INT 1
31007: EQUAL
31008: AND
31009: OR
31010: PUSH
31011: LD_VAR 0 1
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: LD_INT 3
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: IN
31026: NOT
31027: PUSH
31028: LD_VAR 0 6
31032: PUSH
31033: LD_INT 2
31035: EQUAL
31036: AND
31037: OR
31038: IFFALSE 31048
// mode = 0 ;
31040: LD_ADDR_VAR 0 6
31044: PUSH
31045: LD_INT 0
31047: ST_TO_ADDR
// case mode of 0 :
31048: LD_VAR 0 6
31052: PUSH
31053: LD_INT 0
31055: DOUBLE
31056: EQUAL
31057: IFTRUE 31061
31059: GO 42514
31061: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31062: LD_ADDR_VAR 0 11
31066: PUSH
31067: LD_INT 0
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: LD_INT 1
31082: NEG
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 1
31090: PUSH
31091: LD_INT 0
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: LD_INT 1
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 0
31110: PUSH
31111: LD_INT 1
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: LD_INT 0
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: LD_INT 1
31135: NEG
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 1
31143: NEG
31144: PUSH
31145: LD_INT 2
31147: NEG
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: LD_INT 2
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 1
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 1
31208: PUSH
31209: LD_INT 3
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: NEG
31229: PUSH
31230: LD_INT 2
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31255: LD_ADDR_VAR 0 12
31259: PUSH
31260: LD_INT 0
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: LD_INT 1
31275: NEG
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: PUSH
31284: LD_INT 0
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 1
31293: PUSH
31294: LD_INT 1
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 0
31303: PUSH
31304: LD_INT 1
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 1
31313: NEG
31314: PUSH
31315: LD_INT 0
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: NEG
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: LD_INT 1
31339: NEG
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 2
31347: PUSH
31348: LD_INT 0
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 2
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: NEG
31368: PUSH
31369: LD_INT 1
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 2
31378: NEG
31379: PUSH
31380: LD_INT 0
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 2
31389: NEG
31390: PUSH
31391: LD_INT 1
31393: NEG
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: NEG
31402: PUSH
31403: LD_INT 1
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 3
31412: NEG
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 3
31423: NEG
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31451: LD_ADDR_VAR 0 13
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 0
31468: PUSH
31469: LD_INT 1
31471: NEG
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: LD_INT 0
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: NEG
31533: PUSH
31534: LD_INT 2
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 2
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 2
31554: PUSH
31555: LD_INT 2
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 1
31564: PUSH
31565: LD_INT 2
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 2
31598: NEG
31599: PUSH
31600: LD_INT 3
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 3
31610: NEG
31611: PUSH
31612: LD_INT 2
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 3
31622: NEG
31623: PUSH
31624: LD_INT 3
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31650: LD_ADDR_VAR 0 14
31654: PUSH
31655: LD_INT 0
31657: PUSH
31658: LD_INT 0
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: LD_INT 1
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 1
31708: NEG
31709: PUSH
31710: LD_INT 0
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 1
31719: NEG
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 1
31731: NEG
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 1
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 1
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: LD_INT 2
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 1
31785: NEG
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 1
31796: NEG
31797: PUSH
31798: LD_INT 3
31800: NEG
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PUSH
31806: LD_INT 0
31808: PUSH
31809: LD_INT 3
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31846: LD_ADDR_VAR 0 15
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 0
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: NEG
31905: PUSH
31906: LD_INT 0
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 1
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 2
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 2
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: LD_INT 1
31984: NEG
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 2
31992: PUSH
31993: LD_INT 1
31995: NEG
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 3
32003: PUSH
32004: LD_INT 0
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 3
32013: PUSH
32014: LD_INT 1
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32039: LD_ADDR_VAR 0 16
32043: PUSH
32044: LD_INT 0
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 1
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 1
32067: PUSH
32068: LD_INT 0
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 1
32077: PUSH
32078: LD_INT 1
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 1
32097: NEG
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: NEG
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 1
32120: NEG
32121: PUSH
32122: LD_INT 2
32124: NEG
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: PUSH
32143: LD_INT 2
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: LD_INT 2
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: LD_INT 1
32166: NEG
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 2
32174: NEG
32175: PUSH
32176: LD_INT 2
32178: NEG
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 3
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 3
32196: PUSH
32197: LD_INT 3
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 2
32206: PUSH
32207: LD_INT 3
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32232: LD_ADDR_VAR 0 17
32236: PUSH
32237: LD_INT 0
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: LD_INT 1
32252: NEG
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 1
32260: PUSH
32261: LD_INT 0
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 1
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: LD_INT 1
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: LD_INT 0
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 1
32301: NEG
32302: PUSH
32303: LD_INT 1
32305: NEG
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 1
32313: NEG
32314: PUSH
32315: LD_INT 2
32317: NEG
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: LD_INT 2
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 1
32336: PUSH
32337: LD_INT 1
32339: NEG
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 2
32347: PUSH
32348: LD_INT 0
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 2
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 2
32367: PUSH
32368: LD_INT 2
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 1
32377: PUSH
32378: LD_INT 2
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 0
32387: PUSH
32388: LD_INT 2
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 2
32419: NEG
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: NEG
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32462: LD_ADDR_VAR 0 18
32466: PUSH
32467: LD_INT 0
32469: PUSH
32470: LD_INT 0
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 0
32479: PUSH
32480: LD_INT 1
32482: NEG
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 1
32500: PUSH
32501: LD_INT 1
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: LD_INT 1
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: LD_INT 1
32520: NEG
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: NEG
32532: PUSH
32533: LD_INT 1
32535: NEG
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 1
32543: NEG
32544: PUSH
32545: LD_INT 2
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: LD_INT 2
32558: NEG
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 1
32566: PUSH
32567: LD_INT 1
32569: NEG
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 2
32577: PUSH
32578: LD_INT 0
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 2
32587: PUSH
32588: LD_INT 1
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 2
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: LD_INT 2
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 0
32617: PUSH
32618: LD_INT 2
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: LD_INT 1
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 2
32638: NEG
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 2
32649: NEG
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: NEG
32662: PUSH
32663: LD_INT 2
32665: NEG
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32692: LD_ADDR_VAR 0 19
32696: PUSH
32697: LD_INT 0
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 0
32709: PUSH
32710: LD_INT 1
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 0
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 1
32730: PUSH
32731: LD_INT 1
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 0
32740: PUSH
32741: LD_INT 1
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 1
32750: NEG
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 1
32761: NEG
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 1
32773: NEG
32774: PUSH
32775: LD_INT 2
32777: NEG
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: LD_INT 1
32799: NEG
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: LD_INT 0
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 2
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 2
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 1
32837: PUSH
32838: LD_INT 2
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 0
32847: PUSH
32848: LD_INT 2
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 1
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 2
32868: NEG
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 2
32891: NEG
32892: PUSH
32893: LD_INT 2
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32922: LD_ADDR_VAR 0 20
32926: PUSH
32927: LD_INT 0
32929: PUSH
32930: LD_INT 0
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 0
32939: PUSH
32940: LD_INT 1
32942: NEG
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 1
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 1
32960: PUSH
32961: LD_INT 1
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: LD_INT 1
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: NEG
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 1
32991: NEG
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: LD_INT 2
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 0
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 1
33026: PUSH
33027: LD_INT 1
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 2
33047: PUSH
33048: LD_INT 1
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 2
33057: PUSH
33058: LD_INT 2
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 1
33067: PUSH
33068: LD_INT 2
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 0
33077: PUSH
33078: LD_INT 2
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: LD_INT 1
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 2
33109: NEG
33110: PUSH
33111: LD_INT 1
33113: NEG
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: NEG
33122: PUSH
33123: LD_INT 2
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: EMPTY
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33152: LD_ADDR_VAR 0 21
33156: PUSH
33157: LD_INT 0
33159: PUSH
33160: LD_INT 0
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: LD_INT 1
33172: NEG
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 1
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 1
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 0
33245: PUSH
33246: LD_INT 2
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 1
33256: PUSH
33257: LD_INT 1
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: PUSH
33268: LD_INT 0
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 2
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 2
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: LD_INT 2
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 0
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: LD_INT 0
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: LD_INT 1
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: LD_INT 2
33355: NEG
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33382: LD_ADDR_VAR 0 22
33386: PUSH
33387: LD_INT 0
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: LD_INT 1
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: LD_INT 1
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: LD_INT 1
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 1
33440: NEG
33441: PUSH
33442: LD_INT 0
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 1
33451: NEG
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 1
33463: NEG
33464: PUSH
33465: LD_INT 2
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 2
33478: NEG
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: LD_INT 1
33489: NEG
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: PUSH
33498: LD_INT 0
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 2
33507: PUSH
33508: LD_INT 1
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 2
33517: PUSH
33518: LD_INT 2
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: LD_INT 2
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 0
33537: PUSH
33538: LD_INT 2
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 2
33558: NEG
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 2
33569: NEG
33570: PUSH
33571: LD_INT 1
33573: NEG
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33612: LD_ADDR_VAR 0 23
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: LD_INT 1
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: LD_INT 2
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 1
33716: PUSH
33717: LD_INT 1
33719: NEG
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 2
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 2
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 2
33747: PUSH
33748: LD_INT 2
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 2
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 0
33767: PUSH
33768: LD_INT 2
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: NEG
33778: PUSH
33779: LD_INT 1
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: NEG
33789: PUSH
33790: LD_INT 0
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 2
33799: NEG
33800: PUSH
33801: LD_INT 1
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 2
33811: NEG
33812: PUSH
33813: LD_INT 2
33815: NEG
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: LD_INT 3
33827: NEG
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: LD_INT 3
33839: NEG
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 2
33850: NEG
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: LD_INT 2
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33892: LD_ADDR_VAR 0 24
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 2
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 2
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 2
34017: PUSH
34018: LD_INT 1
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: LD_INT 2
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 1
34037: PUSH
34038: LD_INT 2
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: LD_INT 2
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: LD_INT 1
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 2
34068: NEG
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 2
34079: NEG
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 2
34091: NEG
34092: PUSH
34093: LD_INT 2
34095: NEG
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: PUSH
34104: LD_INT 2
34106: NEG
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 2
34114: PUSH
34115: LD_INT 1
34117: NEG
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 3
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 3
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34168: LD_ADDR_VAR 0 25
34172: PUSH
34173: LD_INT 0
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: LD_INT 2
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 1
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 2
34293: PUSH
34294: LD_INT 1
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 2
34303: PUSH
34304: LD_INT 2
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 2
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: LD_INT 2
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 1
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 2
34344: NEG
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: PUSH
34353: LD_INT 2
34355: NEG
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 2
34367: NEG
34368: PUSH
34369: LD_INT 2
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 3
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 3
34389: PUSH
34390: LD_INT 2
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 2
34399: PUSH
34400: LD_INT 3
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: PUSH
34410: LD_INT 3
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34442: LD_ADDR_VAR 0 26
34446: PUSH
34447: LD_INT 0
34449: PUSH
34450: LD_INT 0
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 0
34459: PUSH
34460: LD_INT 1
34462: NEG
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PUSH
34468: LD_INT 1
34470: PUSH
34471: LD_INT 0
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: LD_INT 0
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: PUSH
34509: LD_INT 1
34511: NEG
34512: PUSH
34513: LD_INT 1
34515: NEG
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: NEG
34524: PUSH
34525: LD_INT 2
34527: NEG
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 0
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: LD_INT 1
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: LD_INT 0
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 1
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 2
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: PUSH
34588: LD_INT 2
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 0
34597: PUSH
34598: LD_INT 2
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: NEG
34619: PUSH
34620: LD_INT 0
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 2
34629: NEG
34630: PUSH
34631: LD_INT 1
34633: NEG
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 2
34641: NEG
34642: PUSH
34643: LD_INT 2
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 2
34684: NEG
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34718: LD_ADDR_VAR 0 27
34722: PUSH
34723: LD_INT 0
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: LD_INT 1
34738: NEG
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: LD_INT 0
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 1
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 1
34776: NEG
34777: PUSH
34778: LD_INT 0
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 1
34787: NEG
34788: PUSH
34789: LD_INT 1
34791: NEG
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: LD_INT 2
34803: NEG
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 0
34811: PUSH
34812: LD_INT 2
34814: NEG
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: LD_INT 1
34825: NEG
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: PUSH
34844: LD_INT 1
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: PUSH
34854: LD_INT 2
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 2
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 2
34894: NEG
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 2
34905: NEG
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: LD_INT 2
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 3
34951: NEG
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 3
34963: NEG
34964: PUSH
34965: LD_INT 2
34967: NEG
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34998: LD_ADDR_VAR 0 28
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: LD_INT 0
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 1
35018: NEG
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 0
35046: PUSH
35047: LD_INT 1
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 1
35056: NEG
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 1
35067: NEG
35068: PUSH
35069: LD_INT 1
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 2
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 0
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 2
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 2
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: LD_INT 2
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: LD_INT 2
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 2
35185: NEG
35186: PUSH
35187: LD_INT 1
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 2
35197: NEG
35198: PUSH
35199: LD_INT 2
35201: NEG
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 2
35209: NEG
35210: PUSH
35211: LD_INT 3
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 3
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 3
35233: NEG
35234: PUSH
35235: LD_INT 1
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 3
35245: NEG
35246: PUSH
35247: LD_INT 2
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35280: LD_ADDR_VAR 0 29
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 1
35308: PUSH
35309: LD_INT 0
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: LD_INT 1
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: LD_INT 0
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 1
35349: NEG
35350: PUSH
35351: LD_INT 1
35353: NEG
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 2
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: LD_INT 2
35376: NEG
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 2
35405: PUSH
35406: LD_INT 1
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: PUSH
35416: LD_INT 2
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: LD_INT 2
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 1
35435: NEG
35436: PUSH
35437: LD_INT 1
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 2
35446: NEG
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 2
35458: NEG
35459: PUSH
35460: LD_INT 2
35462: NEG
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 2
35470: NEG
35471: PUSH
35472: LD_INT 3
35474: NEG
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 2
35482: PUSH
35483: LD_INT 1
35485: NEG
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 3
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 3
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: LD_INT 2
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 3
35524: NEG
35525: PUSH
35526: LD_INT 2
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35559: LD_ADDR_VAR 0 30
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 0
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: LD_INT 0
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 0
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: LD_INT 0
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 2
35684: PUSH
35685: LD_INT 1
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 2
35694: PUSH
35695: LD_INT 2
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 1
35704: PUSH
35705: LD_INT 2
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: LD_INT 0
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 2
35736: NEG
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: LD_INT 3
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 1
35760: PUSH
35761: LD_INT 2
35763: NEG
35764: PUSH
35765: EMPTY
35766: LIST
35767: LIST
35768: PUSH
35769: LD_INT 3
35771: PUSH
35772: LD_INT 2
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 2
35781: PUSH
35782: LD_INT 3
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 2
35791: NEG
35792: PUSH
35793: LD_INT 1
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PUSH
35800: LD_INT 3
35802: NEG
35803: PUSH
35804: LD_INT 1
35806: NEG
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35837: LD_ADDR_VAR 0 31
35841: PUSH
35842: LD_INT 0
35844: PUSH
35845: LD_INT 0
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 1
35895: NEG
35896: PUSH
35897: LD_INT 0
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 1
35906: NEG
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: NEG
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 1
35930: PUSH
35931: LD_INT 1
35933: NEG
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 2
35941: PUSH
35942: LD_INT 0
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 2
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 0
35981: PUSH
35982: LD_INT 2
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 1
35991: NEG
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 2
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 2
36014: NEG
36015: PUSH
36016: LD_INT 2
36018: NEG
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: LD_INT 3
36030: NEG
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: PUSH
36036: LD_INT 2
36038: PUSH
36039: LD_INT 1
36041: NEG
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 3
36049: PUSH
36050: LD_INT 1
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 1
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: NEG
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36115: LD_ADDR_VAR 0 32
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 0
36132: PUSH
36133: LD_INT 1
36135: NEG
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 1
36153: PUSH
36154: LD_INT 1
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 0
36163: PUSH
36164: LD_INT 1
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: LD_INT 2
36200: NEG
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 1
36222: NEG
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 2
36230: PUSH
36231: LD_INT 1
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: PUSH
36241: LD_INT 2
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 1
36250: PUSH
36251: LD_INT 2
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 0
36260: PUSH
36261: LD_INT 2
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 1
36270: NEG
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 2
36281: NEG
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 2
36292: NEG
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: LD_INT 3
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: LD_INT 2
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 3
36327: PUSH
36328: LD_INT 2
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: LD_INT 2
36337: PUSH
36338: LD_INT 3
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 2
36347: NEG
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 3
36358: NEG
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36393: LD_ADDR_VAR 0 33
36397: PUSH
36398: LD_INT 0
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: LD_INT 1
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 1
36421: PUSH
36422: LD_INT 0
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: LD_INT 1
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 0
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 1
36451: NEG
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 1
36462: NEG
36463: PUSH
36464: LD_INT 1
36466: NEG
36467: PUSH
36468: EMPTY
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 1
36474: NEG
36475: PUSH
36476: LD_INT 2
36478: NEG
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 1
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 2
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 2
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: PUSH
36518: LD_INT 2
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 0
36527: PUSH
36528: LD_INT 2
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 1
36537: NEG
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 2
36548: NEG
36549: PUSH
36550: LD_INT 0
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 2
36559: NEG
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 2
36571: NEG
36572: PUSH
36573: LD_INT 2
36575: NEG
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 2
36583: NEG
36584: PUSH
36585: LD_INT 3
36587: NEG
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 2
36595: PUSH
36596: LD_INT 1
36598: NEG
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 3
36606: PUSH
36607: LD_INT 1
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: PUSH
36617: LD_INT 3
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 2
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 3
36637: NEG
36638: PUSH
36639: LD_INT 2
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36672: LD_ADDR_VAR 0 34
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 0
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 1
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: NEG
36754: PUSH
36755: LD_INT 2
36757: NEG
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: LD_INT 2
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 1
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 2
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 2
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 2
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: LD_INT 1
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: NEG
36829: PUSH
36830: LD_INT 0
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 2
36839: NEG
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 2
36851: NEG
36852: PUSH
36853: LD_INT 2
36855: NEG
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: LD_INT 3
36867: NEG
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 2
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 3
36886: PUSH
36887: LD_INT 2
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 2
36896: PUSH
36897: LD_INT 3
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 2
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36952: LD_ADDR_VAR 0 35
36956: PUSH
36957: LD_INT 0
36959: PUSH
36960: LD_INT 0
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 0
36969: PUSH
36970: LD_INT 1
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 1
36980: PUSH
36981: LD_INT 0
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: LD_INT 1
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: NEG
37011: PUSH
37012: LD_INT 0
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 1
37021: NEG
37022: PUSH
37023: LD_INT 1
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 2
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 2
37043: NEG
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37064: LD_ADDR_VAR 0 36
37068: PUSH
37069: LD_INT 0
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 0
37081: PUSH
37082: LD_INT 1
37084: NEG
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 1
37092: PUSH
37093: LD_INT 0
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 0
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: NEG
37123: PUSH
37124: LD_INT 0
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 1
37133: NEG
37134: PUSH
37135: LD_INT 1
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: LD_INT 2
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 1
37157: PUSH
37158: LD_INT 2
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37176: LD_ADDR_VAR 0 37
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 0
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 1
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: LD_INT 0
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: LD_INT 1
37249: NEG
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 1
37257: PUSH
37258: LD_INT 1
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: LD_INT 1
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: LIST
37287: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37288: LD_ADDR_VAR 0 38
37292: PUSH
37293: LD_INT 0
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 0
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 1
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 1
37326: PUSH
37327: LD_INT 1
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 0
37336: PUSH
37337: LD_INT 1
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 1
37346: NEG
37347: PUSH
37348: LD_INT 0
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 1
37357: NEG
37358: PUSH
37359: LD_INT 1
37361: NEG
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 2
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 2
37379: NEG
37380: PUSH
37381: LD_INT 1
37383: NEG
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37400: LD_ADDR_VAR 0 39
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: LD_INT 1
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 1
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 1
37438: PUSH
37439: LD_INT 1
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 0
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: NEG
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 2
37485: NEG
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: LD_INT 2
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37512: LD_ADDR_VAR 0 40
37516: PUSH
37517: LD_INT 0
37519: PUSH
37520: LD_INT 0
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 0
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 1
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 1
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 0
37560: PUSH
37561: LD_INT 1
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: NEG
37571: PUSH
37572: LD_INT 0
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 1
37581: NEG
37582: PUSH
37583: LD_INT 1
37585: NEG
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: LD_INT 1
37596: NEG
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: LIST
37619: LIST
37620: LIST
37621: LIST
37622: LIST
37623: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37624: LD_ADDR_VAR 0 41
37628: PUSH
37629: LD_INT 0
37631: PUSH
37632: LD_INT 0
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: LD_INT 1
37644: NEG
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: LD_INT 0
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: PUSH
37663: LD_INT 1
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 0
37672: PUSH
37673: LD_INT 1
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PUSH
37680: LD_INT 1
37682: NEG
37683: PUSH
37684: LD_INT 0
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: LD_INT 1
37693: NEG
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: NEG
37706: PUSH
37707: LD_INT 2
37709: NEG
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 1
37717: PUSH
37718: LD_INT 1
37720: NEG
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: LD_INT 2
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 2
37738: PUSH
37739: LD_INT 1
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 2
37748: PUSH
37749: LD_INT 2
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 2
37779: NEG
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 2
37790: NEG
37791: PUSH
37792: LD_INT 1
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 2
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 2
37814: NEG
37815: PUSH
37816: LD_INT 3
37818: NEG
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: LD_INT 1
37829: NEG
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 3
37837: PUSH
37838: LD_INT 0
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 3
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 3
37857: PUSH
37858: LD_INT 2
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 3
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 2
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 3
37898: NEG
37899: PUSH
37900: LD_INT 0
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 3
37909: NEG
37910: PUSH
37911: LD_INT 1
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 3
37921: NEG
37922: PUSH
37923: LD_INT 2
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 3
37933: NEG
37934: PUSH
37935: LD_INT 3
37937: NEG
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37974: LD_ADDR_VAR 0 42
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: LD_INT 1
37994: NEG
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 1
38032: NEG
38033: PUSH
38034: LD_INT 0
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: LD_INT 1
38047: NEG
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 1
38055: NEG
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: LD_INT 2
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: LD_INT 1
38144: NEG
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 2
38152: NEG
38153: PUSH
38154: LD_INT 2
38156: NEG
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 2
38164: NEG
38165: PUSH
38166: LD_INT 3
38168: NEG
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 1
38176: NEG
38177: PUSH
38178: LD_INT 3
38180: NEG
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 0
38188: PUSH
38189: LD_INT 3
38191: NEG
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 1
38199: PUSH
38200: LD_INT 2
38202: NEG
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 3
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: LD_INT 3
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 1
38240: PUSH
38241: LD_INT 3
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: LD_INT 3
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: LD_INT 2
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 3
38271: NEG
38272: PUSH
38273: LD_INT 2
38275: NEG
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 3
38283: NEG
38284: PUSH
38285: LD_INT 3
38287: NEG
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38324: LD_ADDR_VAR 0 43
38328: PUSH
38329: LD_INT 0
38331: PUSH
38332: LD_INT 0
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 0
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: PUSH
38353: LD_INT 0
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 1
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: LD_INT 1
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: EMPTY
38388: LIST
38389: LIST
38390: PUSH
38391: LD_INT 1
38393: NEG
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 1
38405: NEG
38406: PUSH
38407: LD_INT 2
38409: NEG
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: PUSH
38429: LD_INT 1
38431: NEG
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 2
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 2
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: PUSH
38460: LD_INT 2
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 2
38490: NEG
38491: PUSH
38492: LD_INT 0
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 2
38501: NEG
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 1
38513: NEG
38514: PUSH
38515: LD_INT 3
38517: NEG
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: LD_INT 3
38528: NEG
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 1
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 3
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 3
38568: PUSH
38569: LD_INT 1
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 3
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 3
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 2
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 2
38609: NEG
38610: PUSH
38611: LD_INT 1
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 3
38620: NEG
38621: PUSH
38622: LD_INT 0
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 3
38631: NEG
38632: PUSH
38633: LD_INT 1
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38672: LD_ADDR_VAR 0 44
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: LD_INT 0
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 0
38689: PUSH
38690: LD_INT 1
38692: NEG
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: LD_INT 0
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: LD_INT 1
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 1
38730: NEG
38731: PUSH
38732: LD_INT 0
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 1
38753: NEG
38754: PUSH
38755: LD_INT 2
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 1
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 2
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 2
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: PUSH
38807: LD_INT 2
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 2
38827: NEG
38828: PUSH
38829: LD_INT 0
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 2
38838: NEG
38839: PUSH
38840: LD_INT 1
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 2
38850: NEG
38851: PUSH
38852: LD_INT 2
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 2
38862: NEG
38863: PUSH
38864: LD_INT 3
38866: NEG
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 2
38874: PUSH
38875: LD_INT 1
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 3
38885: PUSH
38886: LD_INT 0
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 3
38895: PUSH
38896: LD_INT 1
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 3
38905: PUSH
38906: LD_INT 2
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 3
38915: PUSH
38916: LD_INT 3
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: PUSH
38923: LD_INT 2
38925: PUSH
38926: LD_INT 3
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: LD_INT 1
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 3
38946: NEG
38947: PUSH
38948: LD_INT 0
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 3
38957: NEG
38958: PUSH
38959: LD_INT 1
38961: NEG
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 3
38969: NEG
38970: PUSH
38971: LD_INT 2
38973: NEG
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 3
38981: NEG
38982: PUSH
38983: LD_INT 3
38985: NEG
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39022: LD_ADDR_VAR 0 45
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: LD_INT 0
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 0
39039: PUSH
39040: LD_INT 1
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: LD_INT 0
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: LD_INT 1
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: LD_INT 1
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 1
39091: NEG
39092: PUSH
39093: LD_INT 1
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 2
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 1
39126: PUSH
39127: LD_INT 1
39129: NEG
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 2
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 2
39147: PUSH
39148: LD_INT 2
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: LD_INT 2
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 0
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 1
39177: NEG
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 2
39188: NEG
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 2
39200: NEG
39201: PUSH
39202: LD_INT 2
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 2
39212: NEG
39213: PUSH
39214: LD_INT 3
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: NEG
39225: PUSH
39226: LD_INT 3
39228: NEG
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: LD_INT 0
39236: PUSH
39237: LD_INT 3
39239: NEG
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: LD_INT 2
39250: NEG
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 3
39258: PUSH
39259: LD_INT 2
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 3
39268: PUSH
39269: LD_INT 3
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 2
39278: PUSH
39279: LD_INT 3
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: LD_INT 3
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 0
39298: PUSH
39299: LD_INT 3
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: LD_INT 2
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 3
39319: NEG
39320: PUSH
39321: LD_INT 2
39323: NEG
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 3
39331: NEG
39332: PUSH
39333: LD_INT 3
39335: NEG
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39372: LD_ADDR_VAR 0 46
39376: PUSH
39377: LD_INT 0
39379: PUSH
39380: LD_INT 0
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: LD_INT 1
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: LD_INT 0
39420: PUSH
39421: LD_INT 1
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 0
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 1
39441: NEG
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 1
39453: NEG
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 0
39465: PUSH
39466: LD_INT 2
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 1
39476: PUSH
39477: LD_INT 1
39479: NEG
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 2
39487: PUSH
39488: LD_INT 0
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 2
39497: PUSH
39498: LD_INT 1
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: LD_INT 2
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 0
39517: PUSH
39518: LD_INT 2
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 1
39527: NEG
39528: PUSH
39529: LD_INT 1
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: LD_INT 0
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: LD_INT 1
39553: NEG
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: LD_INT 1
39561: NEG
39562: PUSH
39563: LD_INT 3
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 0
39573: PUSH
39574: LD_INT 3
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: LD_INT 2
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 2
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 3
39606: PUSH
39607: LD_INT 0
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 3
39616: PUSH
39617: LD_INT 1
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: PUSH
39627: LD_INT 3
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 0
39636: PUSH
39637: LD_INT 3
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 1
39646: NEG
39647: PUSH
39648: LD_INT 2
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: LD_INT 2
39657: NEG
39658: PUSH
39659: LD_INT 1
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 3
39668: NEG
39669: PUSH
39670: LD_INT 0
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 3
39679: NEG
39680: PUSH
39681: LD_INT 1
39683: NEG
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39720: LD_ADDR_VAR 0 47
39724: PUSH
39725: LD_INT 0
39727: PUSH
39728: LD_INT 0
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 1
39740: NEG
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 1
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 1
39778: NEG
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 1
39789: NEG
39790: PUSH
39791: LD_INT 1
39793: NEG
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 0
39813: PUSH
39814: LD_INT 2
39816: NEG
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: LD_INT 1
39827: NEG
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 2
39847: NEG
39848: PUSH
39849: LD_INT 2
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39871: LD_ADDR_VAR 0 48
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: LD_INT 1
39891: NEG
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 0
39919: PUSH
39920: LD_INT 1
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: LD_INT 0
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: NEG
39953: PUSH
39954: LD_INT 2
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: LD_INT 2
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: LD_INT 1
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 2
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 2
39996: PUSH
39997: LD_INT 1
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40018: LD_ADDR_VAR 0 49
40022: PUSH
40023: LD_INT 0
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 0
40035: PUSH
40036: LD_INT 1
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: PUSH
40057: LD_INT 1
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 1
40076: NEG
40077: PUSH
40078: LD_INT 0
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: NEG
40088: PUSH
40089: LD_INT 1
40091: NEG
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 1
40099: PUSH
40100: LD_INT 1
40102: NEG
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 2
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 2
40120: PUSH
40121: LD_INT 1
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 2
40130: PUSH
40131: LD_INT 2
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 2
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40162: LD_ADDR_VAR 0 50
40166: PUSH
40167: LD_INT 0
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 1
40200: PUSH
40201: LD_INT 1
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 0
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 1
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 2
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 1
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: LD_INT 2
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: LIST
40296: LIST
40297: LIST
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40306: LD_ADDR_VAR 0 51
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 0
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 1
40364: NEG
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: NEG
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 1
40387: PUSH
40388: LD_INT 2
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 0
40397: PUSH
40398: LD_INT 2
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: NEG
40408: PUSH
40409: LD_INT 1
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 2
40418: NEG
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 2
40429: NEG
40430: PUSH
40431: LD_INT 1
40433: NEG
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40453: LD_ADDR_VAR 0 52
40457: PUSH
40458: LD_INT 0
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 0
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 1
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: PUSH
40492: LD_INT 1
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 0
40501: PUSH
40502: LD_INT 1
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: NEG
40512: PUSH
40513: LD_INT 0
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: NEG
40535: PUSH
40536: LD_INT 2
40538: NEG
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PUSH
40544: LD_INT 1
40546: NEG
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 2
40557: NEG
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 2
40568: NEG
40569: PUSH
40570: LD_INT 1
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 2
40580: NEG
40581: PUSH
40582: LD_INT 2
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40604: LD_ADDR_VAR 0 53
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: LD_INT 0
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 0
40621: PUSH
40622: LD_INT 1
40624: NEG
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 1
40632: PUSH
40633: LD_INT 0
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 1
40642: PUSH
40643: LD_INT 1
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 0
40652: PUSH
40653: LD_INT 1
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 1
40662: NEG
40663: PUSH
40664: LD_INT 0
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 1
40673: NEG
40674: PUSH
40675: LD_INT 1
40677: NEG
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: LD_INT 2
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: LD_INT 2
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: LD_INT 1
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 2
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 2
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 2
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 1
40749: PUSH
40750: LD_INT 2
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 0
40759: PUSH
40760: LD_INT 2
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 1
40769: NEG
40770: PUSH
40771: LD_INT 1
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: LD_INT 2
40780: NEG
40781: PUSH
40782: LD_INT 0
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: LD_INT 2
40791: NEG
40792: PUSH
40793: LD_INT 1
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 2
40803: NEG
40804: PUSH
40805: LD_INT 2
40807: NEG
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: LIST
40823: LIST
40824: LIST
40825: LIST
40826: LIST
40827: LIST
40828: LIST
40829: LIST
40830: LIST
40831: LIST
40832: LIST
40833: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40834: LD_ADDR_VAR 0 54
40838: PUSH
40839: LD_INT 0
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 0
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 1
40862: PUSH
40863: LD_INT 0
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 1
40872: PUSH
40873: LD_INT 1
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 1
40903: NEG
40904: PUSH
40905: LD_INT 1
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 1
40915: NEG
40916: PUSH
40917: LD_INT 2
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 0
40927: PUSH
40928: LD_INT 2
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 1
40938: PUSH
40939: LD_INT 1
40941: NEG
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: LD_INT 0
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 2
40959: PUSH
40960: LD_INT 1
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 2
40969: PUSH
40970: LD_INT 2
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 2
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: LD_INT 2
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 1
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 2
41010: NEG
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 2
41021: NEG
41022: PUSH
41023: LD_INT 1
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 2
41033: NEG
41034: PUSH
41035: LD_INT 2
41037: NEG
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41064: LD_ADDR_VAR 0 55
41068: PUSH
41069: LD_INT 0
41071: PUSH
41072: LD_INT 0
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 0
41081: PUSH
41082: LD_INT 1
41084: NEG
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: LD_INT 0
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: PUSH
41103: LD_INT 1
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 0
41112: PUSH
41113: LD_INT 1
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: NEG
41123: PUSH
41124: LD_INT 0
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 1
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: NEG
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 1
41145: NEG
41146: PUSH
41147: LD_INT 2
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 0
41157: PUSH
41158: LD_INT 2
41160: NEG
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 1
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 2
41189: PUSH
41190: LD_INT 1
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 2
41199: PUSH
41200: LD_INT 2
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: LD_INT 2
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 2
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: LD_INT 1
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 2
41240: NEG
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 2
41251: NEG
41252: PUSH
41253: LD_INT 1
41255: NEG
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 2
41263: NEG
41264: PUSH
41265: LD_INT 2
41267: NEG
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: LIST
41277: LIST
41278: LIST
41279: LIST
41280: LIST
41281: LIST
41282: LIST
41283: LIST
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: LIST
41289: LIST
41290: LIST
41291: LIST
41292: LIST
41293: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41294: LD_ADDR_VAR 0 56
41298: PUSH
41299: LD_INT 0
41301: PUSH
41302: LD_INT 0
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 0
41311: PUSH
41312: LD_INT 1
41314: NEG
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 1
41322: PUSH
41323: LD_INT 0
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 1
41332: PUSH
41333: LD_INT 1
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_INT 1
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 1
41352: NEG
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 1
41363: NEG
41364: PUSH
41365: LD_INT 1
41367: NEG
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 1
41375: NEG
41376: PUSH
41377: LD_INT 2
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 2
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 1
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 2
41409: PUSH
41410: LD_INT 0
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 2
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 2
41429: PUSH
41430: LD_INT 2
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: LD_INT 2
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 0
41449: PUSH
41450: LD_INT 2
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 1
41459: NEG
41460: PUSH
41461: LD_INT 1
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 2
41470: NEG
41471: PUSH
41472: LD_INT 0
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 2
41481: NEG
41482: PUSH
41483: LD_INT 1
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 2
41493: NEG
41494: PUSH
41495: LD_INT 2
41497: NEG
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: LIST
41507: LIST
41508: LIST
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41524: LD_ADDR_VAR 0 57
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 0
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 1
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 1
41562: PUSH
41563: LD_INT 1
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 0
41572: PUSH
41573: LD_INT 1
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: LD_INT 0
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 1
41593: NEG
41594: PUSH
41595: LD_INT 1
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: NEG
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: LD_INT 0
41617: PUSH
41618: LD_INT 2
41620: NEG
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: PUSH
41629: LD_INT 1
41631: NEG
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 2
41639: PUSH
41640: LD_INT 0
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 2
41649: PUSH
41650: LD_INT 1
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 2
41659: PUSH
41660: LD_INT 2
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 1
41669: PUSH
41670: LD_INT 2
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 0
41679: PUSH
41680: LD_INT 2
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 2
41700: NEG
41701: PUSH
41702: LD_INT 0
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 2
41711: NEG
41712: PUSH
41713: LD_INT 1
41715: NEG
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 2
41723: NEG
41724: PUSH
41725: LD_INT 2
41727: NEG
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41754: LD_ADDR_VAR 0 58
41758: PUSH
41759: LD_INT 0
41761: PUSH
41762: LD_INT 0
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 1
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 0
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 1
41792: PUSH
41793: LD_INT 1
41795: PUSH
41796: EMPTY
41797: LIST
41798: LIST
41799: PUSH
41800: LD_INT 0
41802: PUSH
41803: LD_INT 1
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 1
41812: NEG
41813: PUSH
41814: LD_INT 0
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: LD_INT 1
41823: NEG
41824: PUSH
41825: LD_INT 1
41827: NEG
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 1
41835: NEG
41836: PUSH
41837: LD_INT 2
41839: NEG
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 0
41847: PUSH
41848: LD_INT 2
41850: NEG
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 1
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 2
41869: PUSH
41870: LD_INT 0
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 2
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 2
41889: PUSH
41890: LD_INT 2
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 1
41899: PUSH
41900: LD_INT 2
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 0
41909: PUSH
41910: LD_INT 2
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 1
41919: NEG
41920: PUSH
41921: LD_INT 1
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 2
41930: NEG
41931: PUSH
41932: LD_INT 0
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 2
41941: NEG
41942: PUSH
41943: LD_INT 1
41945: NEG
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 2
41953: NEG
41954: PUSH
41955: LD_INT 2
41957: NEG
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: LIST
41967: LIST
41968: LIST
41969: LIST
41970: LIST
41971: LIST
41972: LIST
41973: LIST
41974: LIST
41975: LIST
41976: LIST
41977: LIST
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: LIST
41983: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41984: LD_ADDR_VAR 0 59
41988: PUSH
41989: LD_INT 0
41991: PUSH
41992: LD_INT 0
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: LD_INT 1
42004: NEG
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 1
42012: PUSH
42013: LD_INT 0
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 1
42022: PUSH
42023: LD_INT 1
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 0
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 1
42042: NEG
42043: PUSH
42044: LD_INT 0
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 1
42053: NEG
42054: PUSH
42055: LD_INT 1
42057: NEG
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42072: LD_ADDR_VAR 0 60
42076: PUSH
42077: LD_INT 0
42079: PUSH
42080: LD_INT 0
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 0
42089: PUSH
42090: LD_INT 1
42092: NEG
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 1
42100: PUSH
42101: LD_INT 0
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 1
42110: PUSH
42111: LD_INT 1
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 0
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 1
42130: NEG
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 1
42141: NEG
42142: PUSH
42143: LD_INT 1
42145: NEG
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42160: LD_ADDR_VAR 0 61
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 0
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 1
42188: PUSH
42189: LD_INT 0
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 1
42198: PUSH
42199: LD_INT 1
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 0
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 1
42218: NEG
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: NEG
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42248: LD_ADDR_VAR 0 62
42252: PUSH
42253: LD_INT 0
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 0
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 1
42276: PUSH
42277: LD_INT 0
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 1
42286: PUSH
42287: LD_INT 1
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 0
42296: PUSH
42297: LD_INT 1
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: NEG
42307: PUSH
42308: LD_INT 0
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 1
42317: NEG
42318: PUSH
42319: LD_INT 1
42321: NEG
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42336: LD_ADDR_VAR 0 63
42340: PUSH
42341: LD_INT 0
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: LD_INT 1
42356: NEG
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 1
42364: PUSH
42365: LD_INT 0
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 1
42374: PUSH
42375: LD_INT 1
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 0
42384: PUSH
42385: LD_INT 1
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 1
42394: NEG
42395: PUSH
42396: LD_INT 0
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 1
42405: NEG
42406: PUSH
42407: LD_INT 1
42409: NEG
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42424: LD_ADDR_VAR 0 64
42428: PUSH
42429: LD_INT 0
42431: PUSH
42432: LD_INT 0
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 0
42441: PUSH
42442: LD_INT 1
42444: NEG
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 1
42452: PUSH
42453: LD_INT 0
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 1
42462: PUSH
42463: LD_INT 1
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 0
42472: PUSH
42473: LD_INT 1
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 1
42482: NEG
42483: PUSH
42484: LD_INT 0
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: NEG
42494: PUSH
42495: LD_INT 1
42497: NEG
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: ST_TO_ADDR
// end ; 1 :
42512: GO 48409
42514: LD_INT 1
42516: DOUBLE
42517: EQUAL
42518: IFTRUE 42522
42520: GO 45145
42522: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42523: LD_ADDR_VAR 0 11
42527: PUSH
42528: LD_INT 1
42530: NEG
42531: PUSH
42532: LD_INT 3
42534: NEG
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: PUSH
42540: LD_INT 0
42542: PUSH
42543: LD_INT 3
42545: NEG
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 1
42553: PUSH
42554: LD_INT 2
42556: NEG
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: LIST
42566: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42567: LD_ADDR_VAR 0 12
42571: PUSH
42572: LD_INT 2
42574: PUSH
42575: LD_INT 1
42577: NEG
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: LD_INT 3
42585: PUSH
42586: LD_INT 0
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 3
42595: PUSH
42596: LD_INT 1
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: LIST
42607: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42608: LD_ADDR_VAR 0 13
42612: PUSH
42613: LD_INT 3
42615: PUSH
42616: LD_INT 2
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 3
42625: PUSH
42626: LD_INT 3
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 2
42635: PUSH
42636: LD_INT 3
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: LIST
42647: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42648: LD_ADDR_VAR 0 14
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 3
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: LD_INT 3
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: NEG
42676: PUSH
42677: LD_INT 2
42679: PUSH
42680: EMPTY
42681: LIST
42682: LIST
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: LIST
42688: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42689: LD_ADDR_VAR 0 15
42693: PUSH
42694: LD_INT 2
42696: NEG
42697: PUSH
42698: LD_INT 1
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 3
42707: NEG
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 3
42718: NEG
42719: PUSH
42720: LD_INT 1
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: LIST
42732: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42733: LD_ADDR_VAR 0 16
42737: PUSH
42738: LD_INT 2
42740: NEG
42741: PUSH
42742: LD_INT 3
42744: NEG
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 3
42752: NEG
42753: PUSH
42754: LD_INT 2
42756: NEG
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 3
42764: NEG
42765: PUSH
42766: LD_INT 3
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: LIST
42778: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42779: LD_ADDR_VAR 0 17
42783: PUSH
42784: LD_INT 1
42786: NEG
42787: PUSH
42788: LD_INT 3
42790: NEG
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: LD_INT 3
42801: NEG
42802: PUSH
42803: EMPTY
42804: LIST
42805: LIST
42806: PUSH
42807: LD_INT 1
42809: PUSH
42810: LD_INT 2
42812: NEG
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: LIST
42822: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42823: LD_ADDR_VAR 0 18
42827: PUSH
42828: LD_INT 2
42830: PUSH
42831: LD_INT 1
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 3
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: PUSH
42852: LD_INT 1
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: LIST
42863: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42864: LD_ADDR_VAR 0 19
42868: PUSH
42869: LD_INT 3
42871: PUSH
42872: LD_INT 2
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 3
42881: PUSH
42882: LD_INT 3
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 2
42891: PUSH
42892: LD_INT 3
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: LIST
42903: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42904: LD_ADDR_VAR 0 20
42908: PUSH
42909: LD_INT 1
42911: PUSH
42912: LD_INT 3
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 0
42921: PUSH
42922: LD_INT 3
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PUSH
42929: LD_INT 1
42931: NEG
42932: PUSH
42933: LD_INT 2
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: LIST
42944: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42945: LD_ADDR_VAR 0 21
42949: PUSH
42950: LD_INT 2
42952: NEG
42953: PUSH
42954: LD_INT 1
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 3
42963: NEG
42964: PUSH
42965: LD_INT 0
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: LD_INT 3
42974: NEG
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42989: LD_ADDR_VAR 0 22
42993: PUSH
42994: LD_INT 2
42996: NEG
42997: PUSH
42998: LD_INT 3
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 3
43008: NEG
43009: PUSH
43010: LD_INT 2
43012: NEG
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 3
43020: NEG
43021: PUSH
43022: LD_INT 3
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: EMPTY
43031: LIST
43032: LIST
43033: LIST
43034: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43035: LD_ADDR_VAR 0 23
43039: PUSH
43040: LD_INT 0
43042: PUSH
43043: LD_INT 3
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 1
43053: NEG
43054: PUSH
43055: LD_INT 4
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 1
43065: PUSH
43066: LD_INT 3
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: LIST
43078: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43079: LD_ADDR_VAR 0 24
43083: PUSH
43084: LD_INT 3
43086: PUSH
43087: LD_INT 0
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 3
43096: PUSH
43097: LD_INT 1
43099: NEG
43100: PUSH
43101: EMPTY
43102: LIST
43103: LIST
43104: PUSH
43105: LD_INT 4
43107: PUSH
43108: LD_INT 1
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: LIST
43119: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43120: LD_ADDR_VAR 0 25
43124: PUSH
43125: LD_INT 3
43127: PUSH
43128: LD_INT 3
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 4
43137: PUSH
43138: LD_INT 3
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 3
43147: PUSH
43148: LD_INT 4
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: LIST
43159: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43160: LD_ADDR_VAR 0 26
43164: PUSH
43165: LD_INT 0
43167: PUSH
43168: LD_INT 3
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 1
43177: PUSH
43178: LD_INT 4
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 1
43187: NEG
43188: PUSH
43189: LD_INT 3
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: LIST
43200: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43201: LD_ADDR_VAR 0 27
43205: PUSH
43206: LD_INT 3
43208: NEG
43209: PUSH
43210: LD_INT 0
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 3
43219: NEG
43220: PUSH
43221: LD_INT 1
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 4
43230: NEG
43231: PUSH
43232: LD_INT 1
43234: NEG
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: LIST
43244: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43245: LD_ADDR_VAR 0 28
43249: PUSH
43250: LD_INT 3
43252: NEG
43253: PUSH
43254: LD_INT 3
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 3
43264: NEG
43265: PUSH
43266: LD_INT 4
43268: NEG
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: LD_INT 4
43276: NEG
43277: PUSH
43278: LD_INT 3
43280: NEG
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: LIST
43290: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43291: LD_ADDR_VAR 0 29
43295: PUSH
43296: LD_INT 1
43298: NEG
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 1
43321: PUSH
43322: LD_INT 2
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: NEG
43333: PUSH
43334: LD_INT 4
43336: NEG
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 0
43344: PUSH
43345: LD_INT 4
43347: NEG
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: PUSH
43356: LD_INT 3
43358: NEG
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 1
43366: NEG
43367: PUSH
43368: LD_INT 5
43370: NEG
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: LD_INT 0
43378: PUSH
43379: LD_INT 5
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 1
43389: PUSH
43390: LD_INT 4
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 1
43400: NEG
43401: PUSH
43402: LD_INT 6
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 6
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: PUSH
43424: LD_INT 5
43426: NEG
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: LIST
43444: LIST
43445: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43446: LD_ADDR_VAR 0 30
43450: PUSH
43451: LD_INT 2
43453: PUSH
43454: LD_INT 1
43456: NEG
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: LD_INT 0
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 3
43474: PUSH
43475: LD_INT 1
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: LD_INT 1
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 4
43495: PUSH
43496: LD_INT 0
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: LD_INT 4
43505: PUSH
43506: LD_INT 1
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 4
43515: PUSH
43516: LD_INT 1
43518: NEG
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 5
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 5
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 5
43546: PUSH
43547: LD_INT 1
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 6
43557: PUSH
43558: LD_INT 0
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 6
43567: PUSH
43568: LD_INT 1
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43589: LD_ADDR_VAR 0 31
43593: PUSH
43594: LD_INT 3
43596: PUSH
43597: LD_INT 2
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 3
43606: PUSH
43607: LD_INT 3
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 2
43616: PUSH
43617: LD_INT 3
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 4
43626: PUSH
43627: LD_INT 3
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 4
43636: PUSH
43637: LD_INT 4
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 3
43646: PUSH
43647: LD_INT 4
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 5
43656: PUSH
43657: LD_INT 4
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 5
43666: PUSH
43667: LD_INT 5
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 4
43676: PUSH
43677: LD_INT 5
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 6
43686: PUSH
43687: LD_INT 5
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 6
43696: PUSH
43697: LD_INT 6
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 5
43706: PUSH
43707: LD_INT 6
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43728: LD_ADDR_VAR 0 32
43732: PUSH
43733: LD_INT 1
43735: PUSH
43736: LD_INT 3
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: LD_INT 3
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: LD_INT 2
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 1
43766: PUSH
43767: LD_INT 4
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 0
43776: PUSH
43777: LD_INT 4
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: LD_INT 1
43786: NEG
43787: PUSH
43788: LD_INT 3
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 1
43797: PUSH
43798: LD_INT 5
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: LD_INT 5
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 1
43817: NEG
43818: PUSH
43819: LD_INT 4
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 1
43828: PUSH
43829: LD_INT 6
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: LD_INT 6
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 1
43848: NEG
43849: PUSH
43850: LD_INT 5
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43871: LD_ADDR_VAR 0 33
43875: PUSH
43876: LD_INT 2
43878: NEG
43879: PUSH
43880: LD_INT 1
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 3
43889: NEG
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 3
43900: NEG
43901: PUSH
43902: LD_INT 1
43904: NEG
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 3
43912: NEG
43913: PUSH
43914: LD_INT 1
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 4
43923: NEG
43924: PUSH
43925: LD_INT 0
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 4
43934: NEG
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 4
43946: NEG
43947: PUSH
43948: LD_INT 1
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 5
43957: NEG
43958: PUSH
43959: LD_INT 0
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 5
43968: NEG
43969: PUSH
43970: LD_INT 1
43972: NEG
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 5
43980: NEG
43981: PUSH
43982: LD_INT 1
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 6
43991: NEG
43992: PUSH
43993: LD_INT 0
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 6
44002: NEG
44003: PUSH
44004: LD_INT 1
44006: NEG
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: LIST
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44026: LD_ADDR_VAR 0 34
44030: PUSH
44031: LD_INT 2
44033: NEG
44034: PUSH
44035: LD_INT 3
44037: NEG
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 3
44045: NEG
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: LD_INT 3
44057: NEG
44058: PUSH
44059: LD_INT 3
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 3
44069: NEG
44070: PUSH
44071: LD_INT 4
44073: NEG
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 4
44081: NEG
44082: PUSH
44083: LD_INT 3
44085: NEG
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 4
44093: NEG
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 4
44105: NEG
44106: PUSH
44107: LD_INT 5
44109: NEG
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: LD_INT 5
44117: NEG
44118: PUSH
44119: LD_INT 4
44121: NEG
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 5
44129: NEG
44130: PUSH
44131: LD_INT 5
44133: NEG
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 5
44141: NEG
44142: PUSH
44143: LD_INT 6
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 6
44153: NEG
44154: PUSH
44155: LD_INT 5
44157: NEG
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 6
44165: NEG
44166: PUSH
44167: LD_INT 6
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44189: LD_ADDR_VAR 0 41
44193: PUSH
44194: LD_INT 0
44196: PUSH
44197: LD_INT 2
44199: NEG
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 1
44207: NEG
44208: PUSH
44209: LD_INT 3
44211: NEG
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 1
44219: PUSH
44220: LD_INT 2
44222: NEG
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: LIST
44232: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44233: LD_ADDR_VAR 0 42
44237: PUSH
44238: LD_INT 2
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 2
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: LD_INT 3
44261: PUSH
44262: LD_INT 1
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: LIST
44273: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44274: LD_ADDR_VAR 0 43
44278: PUSH
44279: LD_INT 2
44281: PUSH
44282: LD_INT 2
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: LD_INT 2
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 2
44301: PUSH
44302: LD_INT 3
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: LIST
44313: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44314: LD_ADDR_VAR 0 44
44318: PUSH
44319: LD_INT 0
44321: PUSH
44322: LD_INT 2
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: LD_INT 1
44331: PUSH
44332: LD_INT 3
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 1
44341: NEG
44342: PUSH
44343: LD_INT 2
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: LIST
44354: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44355: LD_ADDR_VAR 0 45
44359: PUSH
44360: LD_INT 2
44362: NEG
44363: PUSH
44364: LD_INT 0
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: PUSH
44371: LD_INT 2
44373: NEG
44374: PUSH
44375: LD_INT 1
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 3
44384: NEG
44385: PUSH
44386: LD_INT 1
44388: NEG
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44399: LD_ADDR_VAR 0 46
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: LD_INT 2
44410: NEG
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 2
44418: NEG
44419: PUSH
44420: LD_INT 3
44422: NEG
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: PUSH
44428: LD_INT 3
44430: NEG
44431: PUSH
44432: LD_INT 2
44434: NEG
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: LIST
44444: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44445: LD_ADDR_VAR 0 47
44449: PUSH
44450: LD_INT 2
44452: NEG
44453: PUSH
44454: LD_INT 3
44456: NEG
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 1
44464: NEG
44465: PUSH
44466: LD_INT 3
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44478: LD_ADDR_VAR 0 48
44482: PUSH
44483: LD_INT 1
44485: PUSH
44486: LD_INT 2
44488: NEG
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 2
44496: PUSH
44497: LD_INT 1
44499: NEG
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44509: LD_ADDR_VAR 0 49
44513: PUSH
44514: LD_INT 3
44516: PUSH
44517: LD_INT 1
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 3
44526: PUSH
44527: LD_INT 2
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44538: LD_ADDR_VAR 0 50
44542: PUSH
44543: LD_INT 2
44545: PUSH
44546: LD_INT 3
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 1
44555: PUSH
44556: LD_INT 3
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44567: LD_ADDR_VAR 0 51
44571: PUSH
44572: LD_INT 1
44574: NEG
44575: PUSH
44576: LD_INT 2
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 2
44585: NEG
44586: PUSH
44587: LD_INT 1
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44598: LD_ADDR_VAR 0 52
44602: PUSH
44603: LD_INT 3
44605: NEG
44606: PUSH
44607: LD_INT 1
44609: NEG
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 3
44617: NEG
44618: PUSH
44619: LD_INT 2
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44631: LD_ADDR_VAR 0 53
44635: PUSH
44636: LD_INT 1
44638: NEG
44639: PUSH
44640: LD_INT 3
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 0
44650: PUSH
44651: LD_INT 3
44653: NEG
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 1
44661: PUSH
44662: LD_INT 2
44664: NEG
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: LIST
44674: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44675: LD_ADDR_VAR 0 54
44679: PUSH
44680: LD_INT 2
44682: PUSH
44683: LD_INT 1
44685: NEG
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 3
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 3
44703: PUSH
44704: LD_INT 1
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: LIST
44715: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44716: LD_ADDR_VAR 0 55
44720: PUSH
44721: LD_INT 3
44723: PUSH
44724: LD_INT 2
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 3
44733: PUSH
44734: LD_INT 3
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: LD_INT 2
44743: PUSH
44744: LD_INT 3
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: LIST
44755: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44756: LD_ADDR_VAR 0 56
44760: PUSH
44761: LD_INT 1
44763: PUSH
44764: LD_INT 3
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 0
44773: PUSH
44774: LD_INT 3
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 1
44783: NEG
44784: PUSH
44785: LD_INT 2
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: LIST
44796: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44797: LD_ADDR_VAR 0 57
44801: PUSH
44802: LD_INT 2
44804: NEG
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 3
44815: NEG
44816: PUSH
44817: LD_INT 0
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: LD_INT 3
44826: NEG
44827: PUSH
44828: LD_INT 1
44830: NEG
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: LIST
44840: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44841: LD_ADDR_VAR 0 58
44845: PUSH
44846: LD_INT 2
44848: NEG
44849: PUSH
44850: LD_INT 3
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 3
44860: NEG
44861: PUSH
44862: LD_INT 2
44864: NEG
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 3
44872: NEG
44873: PUSH
44874: LD_INT 3
44876: NEG
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: LIST
44886: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44887: LD_ADDR_VAR 0 59
44891: PUSH
44892: LD_INT 1
44894: NEG
44895: PUSH
44896: LD_INT 2
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 0
44906: PUSH
44907: LD_INT 2
44909: NEG
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: LD_INT 1
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: LIST
44930: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44931: LD_ADDR_VAR 0 60
44935: PUSH
44936: LD_INT 1
44938: PUSH
44939: LD_INT 1
44941: NEG
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: LD_INT 2
44949: PUSH
44950: LD_INT 0
44952: PUSH
44953: EMPTY
44954: LIST
44955: LIST
44956: PUSH
44957: LD_INT 2
44959: PUSH
44960: LD_INT 1
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: LIST
44971: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44972: LD_ADDR_VAR 0 61
44976: PUSH
44977: LD_INT 2
44979: PUSH
44980: LD_INT 1
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 2
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 1
44999: PUSH
45000: LD_INT 2
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: LIST
45011: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45012: LD_ADDR_VAR 0 62
45016: PUSH
45017: LD_INT 1
45019: PUSH
45020: LD_INT 2
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 0
45029: PUSH
45030: LD_INT 2
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: LD_INT 1
45039: NEG
45040: PUSH
45041: LD_INT 1
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: LIST
45052: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45053: LD_ADDR_VAR 0 63
45057: PUSH
45058: LD_INT 1
45060: NEG
45061: PUSH
45062: LD_INT 1
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 2
45071: NEG
45072: PUSH
45073: LD_INT 0
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: LD_INT 2
45082: NEG
45083: PUSH
45084: LD_INT 1
45086: NEG
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: LIST
45096: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45097: LD_ADDR_VAR 0 64
45101: PUSH
45102: LD_INT 1
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 2
45116: NEG
45117: PUSH
45118: LD_INT 1
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: LD_INT 2
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: LIST
45142: ST_TO_ADDR
// end ; 2 :
45143: GO 48409
45145: LD_INT 2
45147: DOUBLE
45148: EQUAL
45149: IFTRUE 45153
45151: GO 48408
45153: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45154: LD_ADDR_VAR 0 29
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: PUSH
45172: LD_INT 1
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 5
45182: PUSH
45183: LD_INT 0
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 5
45192: PUSH
45193: LD_INT 1
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 4
45202: PUSH
45203: LD_INT 1
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 3
45212: PUSH
45213: LD_INT 0
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: LD_INT 1
45225: NEG
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 3
45233: PUSH
45234: LD_INT 2
45236: NEG
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 5
45244: PUSH
45245: LD_INT 2
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: PUSH
45252: LD_INT 3
45254: PUSH
45255: LD_INT 3
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: PUSH
45262: LD_INT 3
45264: PUSH
45265: LD_INT 2
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 4
45274: PUSH
45275: LD_INT 3
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 4
45284: PUSH
45285: LD_INT 4
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 3
45294: PUSH
45295: LD_INT 4
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 2
45304: PUSH
45305: LD_INT 3
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 2
45314: PUSH
45315: LD_INT 2
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 4
45324: PUSH
45325: LD_INT 2
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 2
45334: PUSH
45335: LD_INT 4
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: PUSH
45342: LD_INT 0
45344: PUSH
45345: LD_INT 4
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 0
45354: PUSH
45355: LD_INT 3
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: LD_INT 1
45364: PUSH
45365: LD_INT 4
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: PUSH
45372: LD_INT 1
45374: PUSH
45375: LD_INT 5
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 0
45384: PUSH
45385: LD_INT 5
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 1
45394: NEG
45395: PUSH
45396: LD_INT 4
45398: PUSH
45399: EMPTY
45400: LIST
45401: LIST
45402: PUSH
45403: LD_INT 1
45405: NEG
45406: PUSH
45407: LD_INT 3
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 2
45416: PUSH
45417: LD_INT 5
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 2
45426: NEG
45427: PUSH
45428: LD_INT 3
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 3
45437: NEG
45438: PUSH
45439: LD_INT 0
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 3
45448: NEG
45449: PUSH
45450: LD_INT 1
45452: NEG
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: LD_INT 2
45460: NEG
45461: PUSH
45462: LD_INT 0
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 2
45471: NEG
45472: PUSH
45473: LD_INT 1
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 3
45482: NEG
45483: PUSH
45484: LD_INT 1
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 4
45493: NEG
45494: PUSH
45495: LD_INT 0
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: PUSH
45502: LD_INT 4
45504: NEG
45505: PUSH
45506: LD_INT 1
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 4
45516: NEG
45517: PUSH
45518: LD_INT 2
45520: NEG
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 2
45528: NEG
45529: PUSH
45530: LD_INT 2
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: LD_INT 4
45539: NEG
45540: PUSH
45541: LD_INT 4
45543: NEG
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 4
45551: NEG
45552: PUSH
45553: LD_INT 5
45555: NEG
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 3
45563: NEG
45564: PUSH
45565: LD_INT 4
45567: NEG
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: LD_INT 3
45575: NEG
45576: PUSH
45577: LD_INT 3
45579: NEG
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 4
45587: NEG
45588: PUSH
45589: LD_INT 3
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 5
45599: NEG
45600: PUSH
45601: LD_INT 4
45603: NEG
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 5
45611: NEG
45612: PUSH
45613: LD_INT 5
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 3
45623: NEG
45624: PUSH
45625: LD_INT 5
45627: NEG
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: LD_INT 5
45635: NEG
45636: PUSH
45637: LD_INT 3
45639: NEG
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45692: LD_ADDR_VAR 0 30
45696: PUSH
45697: LD_INT 4
45699: PUSH
45700: LD_INT 4
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 4
45709: PUSH
45710: LD_INT 3
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 5
45719: PUSH
45720: LD_INT 4
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 5
45729: PUSH
45730: LD_INT 5
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 4
45739: PUSH
45740: LD_INT 5
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 3
45749: PUSH
45750: LD_INT 4
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 3
45759: PUSH
45760: LD_INT 3
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 5
45769: PUSH
45770: LD_INT 3
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 3
45779: PUSH
45780: LD_INT 5
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 0
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 0
45799: PUSH
45800: LD_INT 2
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: LD_INT 3
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 1
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 0
45829: PUSH
45830: LD_INT 4
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_INT 1
45839: NEG
45840: PUSH
45841: LD_INT 3
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 1
45850: NEG
45851: PUSH
45852: LD_INT 2
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 2
45861: PUSH
45862: LD_INT 4
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 2
45871: NEG
45872: PUSH
45873: LD_INT 2
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 4
45882: NEG
45883: PUSH
45884: LD_INT 0
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 4
45893: NEG
45894: PUSH
45895: LD_INT 1
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 3
45905: NEG
45906: PUSH
45907: LD_INT 0
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 3
45916: NEG
45917: PUSH
45918: LD_INT 1
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 4
45927: NEG
45928: PUSH
45929: LD_INT 1
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 5
45938: NEG
45939: PUSH
45940: LD_INT 0
45942: PUSH
45943: EMPTY
45944: LIST
45945: LIST
45946: PUSH
45947: LD_INT 5
45949: NEG
45950: PUSH
45951: LD_INT 1
45953: NEG
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 5
45961: NEG
45962: PUSH
45963: LD_INT 2
45965: NEG
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: LD_INT 3
45973: NEG
45974: PUSH
45975: LD_INT 2
45977: PUSH
45978: EMPTY
45979: LIST
45980: LIST
45981: PUSH
45982: LD_INT 3
45984: NEG
45985: PUSH
45986: LD_INT 3
45988: NEG
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: PUSH
45994: LD_INT 3
45996: NEG
45997: PUSH
45998: LD_INT 4
46000: NEG
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 2
46008: NEG
46009: PUSH
46010: LD_INT 3
46012: NEG
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 2
46020: NEG
46021: PUSH
46022: LD_INT 2
46024: NEG
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: LD_INT 3
46032: NEG
46033: PUSH
46034: LD_INT 2
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 4
46044: NEG
46045: PUSH
46046: LD_INT 3
46048: NEG
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 4
46056: NEG
46057: PUSH
46058: LD_INT 4
46060: NEG
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 2
46068: NEG
46069: PUSH
46070: LD_INT 4
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 4
46080: NEG
46081: PUSH
46082: LD_INT 2
46084: NEG
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 0
46092: PUSH
46093: LD_INT 4
46095: NEG
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 0
46103: PUSH
46104: LD_INT 5
46106: NEG
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: PUSH
46112: LD_INT 1
46114: PUSH
46115: LD_INT 4
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: PUSH
46126: LD_INT 3
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 0
46136: PUSH
46137: LD_INT 3
46139: NEG
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 1
46147: NEG
46148: PUSH
46149: LD_INT 4
46151: NEG
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 1
46159: NEG
46160: PUSH
46161: LD_INT 5
46163: NEG
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 2
46171: PUSH
46172: LD_INT 3
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 2
46182: NEG
46183: PUSH
46184: LD_INT 5
46186: NEG
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46239: LD_ADDR_VAR 0 31
46243: PUSH
46244: LD_INT 0
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 0
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 1
46266: PUSH
46267: LD_INT 4
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 1
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 0
46286: PUSH
46287: LD_INT 5
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 1
46296: NEG
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: LD_INT 1
46307: NEG
46308: PUSH
46309: LD_INT 3
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 2
46318: PUSH
46319: LD_INT 5
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 2
46328: NEG
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 3
46339: NEG
46340: PUSH
46341: LD_INT 0
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 3
46350: NEG
46351: PUSH
46352: LD_INT 1
46354: NEG
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 2
46362: NEG
46363: PUSH
46364: LD_INT 0
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 2
46373: NEG
46374: PUSH
46375: LD_INT 1
46377: PUSH
46378: EMPTY
46379: LIST
46380: LIST
46381: PUSH
46382: LD_INT 3
46384: NEG
46385: PUSH
46386: LD_INT 1
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PUSH
46393: LD_INT 4
46395: NEG
46396: PUSH
46397: LD_INT 0
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PUSH
46404: LD_INT 4
46406: NEG
46407: PUSH
46408: LD_INT 1
46410: NEG
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 4
46418: NEG
46419: PUSH
46420: LD_INT 2
46422: NEG
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 2
46430: NEG
46431: PUSH
46432: LD_INT 2
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: PUSH
46439: LD_INT 4
46441: NEG
46442: PUSH
46443: LD_INT 4
46445: NEG
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: LD_INT 4
46453: NEG
46454: PUSH
46455: LD_INT 5
46457: NEG
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: LD_INT 3
46465: NEG
46466: PUSH
46467: LD_INT 4
46469: NEG
46470: PUSH
46471: EMPTY
46472: LIST
46473: LIST
46474: PUSH
46475: LD_INT 3
46477: NEG
46478: PUSH
46479: LD_INT 3
46481: NEG
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PUSH
46487: LD_INT 4
46489: NEG
46490: PUSH
46491: LD_INT 3
46493: NEG
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: LD_INT 5
46501: NEG
46502: PUSH
46503: LD_INT 4
46505: NEG
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: PUSH
46511: LD_INT 5
46513: NEG
46514: PUSH
46515: LD_INT 5
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 3
46525: NEG
46526: PUSH
46527: LD_INT 5
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 5
46537: NEG
46538: PUSH
46539: LD_INT 3
46541: NEG
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 0
46549: PUSH
46550: LD_INT 3
46552: NEG
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 0
46560: PUSH
46561: LD_INT 4
46563: NEG
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 1
46571: PUSH
46572: LD_INT 3
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 1
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 0
46593: PUSH
46594: LD_INT 2
46596: NEG
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 1
46604: NEG
46605: PUSH
46606: LD_INT 3
46608: NEG
46609: PUSH
46610: EMPTY
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 1
46616: NEG
46617: PUSH
46618: LD_INT 4
46620: NEG
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: LD_INT 2
46628: PUSH
46629: LD_INT 2
46631: NEG
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 2
46639: NEG
46640: PUSH
46641: LD_INT 4
46643: NEG
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: PUSH
46649: LD_INT 4
46651: PUSH
46652: LD_INT 0
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: PUSH
46659: LD_INT 4
46661: PUSH
46662: LD_INT 1
46664: NEG
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 5
46672: PUSH
46673: LD_INT 0
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 5
46682: PUSH
46683: LD_INT 1
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 4
46692: PUSH
46693: LD_INT 1
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 3
46702: PUSH
46703: LD_INT 0
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: LD_INT 3
46712: PUSH
46713: LD_INT 1
46715: NEG
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 3
46723: PUSH
46724: LD_INT 2
46726: NEG
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_INT 5
46734: PUSH
46735: LD_INT 2
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46789: LD_ADDR_VAR 0 32
46793: PUSH
46794: LD_INT 4
46796: NEG
46797: PUSH
46798: LD_INT 0
46800: PUSH
46801: EMPTY
46802: LIST
46803: LIST
46804: PUSH
46805: LD_INT 4
46807: NEG
46808: PUSH
46809: LD_INT 1
46811: NEG
46812: PUSH
46813: EMPTY
46814: LIST
46815: LIST
46816: PUSH
46817: LD_INT 3
46819: NEG
46820: PUSH
46821: LD_INT 0
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 3
46830: NEG
46831: PUSH
46832: LD_INT 1
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: LD_INT 4
46841: NEG
46842: PUSH
46843: LD_INT 1
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 5
46852: NEG
46853: PUSH
46854: LD_INT 0
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PUSH
46861: LD_INT 5
46863: NEG
46864: PUSH
46865: LD_INT 1
46867: NEG
46868: PUSH
46869: EMPTY
46870: LIST
46871: LIST
46872: PUSH
46873: LD_INT 5
46875: NEG
46876: PUSH
46877: LD_INT 2
46879: NEG
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PUSH
46885: LD_INT 3
46887: NEG
46888: PUSH
46889: LD_INT 2
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: PUSH
46896: LD_INT 3
46898: NEG
46899: PUSH
46900: LD_INT 3
46902: NEG
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: PUSH
46908: LD_INT 3
46910: NEG
46911: PUSH
46912: LD_INT 4
46914: NEG
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 2
46922: NEG
46923: PUSH
46924: LD_INT 3
46926: NEG
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: PUSH
46932: LD_INT 2
46934: NEG
46935: PUSH
46936: LD_INT 2
46938: NEG
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: LD_INT 3
46946: NEG
46947: PUSH
46948: LD_INT 2
46950: NEG
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 4
46958: NEG
46959: PUSH
46960: LD_INT 3
46962: NEG
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: LD_INT 4
46970: NEG
46971: PUSH
46972: LD_INT 4
46974: NEG
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: LD_INT 2
46982: NEG
46983: PUSH
46984: LD_INT 4
46986: NEG
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 4
46994: NEG
46995: PUSH
46996: LD_INT 2
46998: NEG
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 0
47006: PUSH
47007: LD_INT 4
47009: NEG
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: LD_INT 0
47017: PUSH
47018: LD_INT 5
47020: NEG
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 1
47028: PUSH
47029: LD_INT 4
47031: NEG
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: LD_INT 1
47039: PUSH
47040: LD_INT 3
47042: NEG
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PUSH
47048: LD_INT 0
47050: PUSH
47051: LD_INT 3
47053: NEG
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: PUSH
47059: LD_INT 1
47061: NEG
47062: PUSH
47063: LD_INT 4
47065: NEG
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PUSH
47071: LD_INT 1
47073: NEG
47074: PUSH
47075: LD_INT 5
47077: NEG
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: LD_INT 2
47085: PUSH
47086: LD_INT 3
47088: NEG
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PUSH
47094: LD_INT 2
47096: NEG
47097: PUSH
47098: LD_INT 5
47100: NEG
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: PUSH
47106: LD_INT 3
47108: PUSH
47109: LD_INT 0
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: PUSH
47116: LD_INT 3
47118: PUSH
47119: LD_INT 1
47121: NEG
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 4
47129: PUSH
47130: LD_INT 0
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 4
47139: PUSH
47140: LD_INT 1
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 3
47149: PUSH
47150: LD_INT 1
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 2
47159: PUSH
47160: LD_INT 0
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 2
47169: PUSH
47170: LD_INT 1
47172: NEG
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 2
47180: PUSH
47181: LD_INT 2
47183: NEG
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 4
47191: PUSH
47192: LD_INT 2
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 4
47201: PUSH
47202: LD_INT 4
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 4
47211: PUSH
47212: LD_INT 3
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: LD_INT 5
47221: PUSH
47222: LD_INT 4
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: LD_INT 5
47231: PUSH
47232: LD_INT 5
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 4
47241: PUSH
47242: LD_INT 5
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: PUSH
47249: LD_INT 3
47251: PUSH
47252: LD_INT 4
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: PUSH
47259: LD_INT 3
47261: PUSH
47262: LD_INT 3
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 5
47271: PUSH
47272: LD_INT 3
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 3
47281: PUSH
47282: LD_INT 5
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: LIST
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47336: LD_ADDR_VAR 0 33
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: LD_INT 4
47347: NEG
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: PUSH
47353: LD_INT 4
47355: NEG
47356: PUSH
47357: LD_INT 5
47359: NEG
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 3
47367: NEG
47368: PUSH
47369: LD_INT 4
47371: NEG
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: LD_INT 3
47379: NEG
47380: PUSH
47381: LD_INT 3
47383: NEG
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 4
47391: NEG
47392: PUSH
47393: LD_INT 3
47395: NEG
47396: PUSH
47397: EMPTY
47398: LIST
47399: LIST
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: LD_INT 4
47407: NEG
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: PUSH
47413: LD_INT 5
47415: NEG
47416: PUSH
47417: LD_INT 5
47419: NEG
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: PUSH
47425: LD_INT 3
47427: NEG
47428: PUSH
47429: LD_INT 5
47431: NEG
47432: PUSH
47433: EMPTY
47434: LIST
47435: LIST
47436: PUSH
47437: LD_INT 5
47439: NEG
47440: PUSH
47441: LD_INT 3
47443: NEG
47444: PUSH
47445: EMPTY
47446: LIST
47447: LIST
47448: PUSH
47449: LD_INT 0
47451: PUSH
47452: LD_INT 3
47454: NEG
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: PUSH
47460: LD_INT 0
47462: PUSH
47463: LD_INT 4
47465: NEG
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 1
47473: PUSH
47474: LD_INT 3
47476: NEG
47477: PUSH
47478: EMPTY
47479: LIST
47480: LIST
47481: PUSH
47482: LD_INT 1
47484: PUSH
47485: LD_INT 2
47487: NEG
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: PUSH
47493: LD_INT 0
47495: PUSH
47496: LD_INT 2
47498: NEG
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 1
47506: NEG
47507: PUSH
47508: LD_INT 3
47510: NEG
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: PUSH
47516: LD_INT 1
47518: NEG
47519: PUSH
47520: LD_INT 4
47522: NEG
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: PUSH
47528: LD_INT 2
47530: PUSH
47531: LD_INT 2
47533: NEG
47534: PUSH
47535: EMPTY
47536: LIST
47537: LIST
47538: PUSH
47539: LD_INT 2
47541: NEG
47542: PUSH
47543: LD_INT 4
47545: NEG
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 4
47553: PUSH
47554: LD_INT 0
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: LD_INT 4
47563: PUSH
47564: LD_INT 1
47566: NEG
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PUSH
47572: LD_INT 5
47574: PUSH
47575: LD_INT 0
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: PUSH
47582: LD_INT 5
47584: PUSH
47585: LD_INT 1
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: LD_INT 4
47594: PUSH
47595: LD_INT 1
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: PUSH
47602: LD_INT 3
47604: PUSH
47605: LD_INT 0
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: LD_INT 3
47614: PUSH
47615: LD_INT 1
47617: NEG
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: LD_INT 3
47625: PUSH
47626: LD_INT 2
47628: NEG
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: LD_INT 5
47636: PUSH
47637: LD_INT 2
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: PUSH
47644: LD_INT 3
47646: PUSH
47647: LD_INT 3
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 3
47656: PUSH
47657: LD_INT 2
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PUSH
47664: LD_INT 4
47666: PUSH
47667: LD_INT 3
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 4
47676: PUSH
47677: LD_INT 4
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 3
47686: PUSH
47687: LD_INT 4
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: LD_INT 2
47696: PUSH
47697: LD_INT 3
47699: PUSH
47700: EMPTY
47701: LIST
47702: LIST
47703: PUSH
47704: LD_INT 2
47706: PUSH
47707: LD_INT 2
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PUSH
47714: LD_INT 4
47716: PUSH
47717: LD_INT 2
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: LD_INT 2
47726: PUSH
47727: LD_INT 4
47729: PUSH
47730: EMPTY
47731: LIST
47732: LIST
47733: PUSH
47734: LD_INT 0
47736: PUSH
47737: LD_INT 4
47739: PUSH
47740: EMPTY
47741: LIST
47742: LIST
47743: PUSH
47744: LD_INT 0
47746: PUSH
47747: LD_INT 3
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PUSH
47754: LD_INT 1
47756: PUSH
47757: LD_INT 4
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: PUSH
47764: LD_INT 1
47766: PUSH
47767: LD_INT 5
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 0
47776: PUSH
47777: LD_INT 5
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: LD_INT 1
47786: NEG
47787: PUSH
47788: LD_INT 4
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: PUSH
47795: LD_INT 1
47797: NEG
47798: PUSH
47799: LD_INT 3
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_INT 2
47808: PUSH
47809: LD_INT 5
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 2
47818: NEG
47819: PUSH
47820: LD_INT 3
47822: PUSH
47823: EMPTY
47824: LIST
47825: LIST
47826: PUSH
47827: EMPTY
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47874: LD_ADDR_VAR 0 34
47878: PUSH
47879: LD_INT 0
47881: PUSH
47882: LD_INT 4
47884: NEG
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: PUSH
47890: LD_INT 0
47892: PUSH
47893: LD_INT 5
47895: NEG
47896: PUSH
47897: EMPTY
47898: LIST
47899: LIST
47900: PUSH
47901: LD_INT 1
47903: PUSH
47904: LD_INT 4
47906: NEG
47907: PUSH
47908: EMPTY
47909: LIST
47910: LIST
47911: PUSH
47912: LD_INT 1
47914: PUSH
47915: LD_INT 3
47917: NEG
47918: PUSH
47919: EMPTY
47920: LIST
47921: LIST
47922: PUSH
47923: LD_INT 0
47925: PUSH
47926: LD_INT 3
47928: NEG
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_INT 1
47936: NEG
47937: PUSH
47938: LD_INT 4
47940: NEG
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: LD_INT 1
47948: NEG
47949: PUSH
47950: LD_INT 5
47952: NEG
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 2
47960: PUSH
47961: LD_INT 3
47963: NEG
47964: PUSH
47965: EMPTY
47966: LIST
47967: LIST
47968: PUSH
47969: LD_INT 2
47971: NEG
47972: PUSH
47973: LD_INT 5
47975: NEG
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: PUSH
47981: LD_INT 3
47983: PUSH
47984: LD_INT 0
47986: PUSH
47987: EMPTY
47988: LIST
47989: LIST
47990: PUSH
47991: LD_INT 3
47993: PUSH
47994: LD_INT 1
47996: NEG
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 4
48004: PUSH
48005: LD_INT 0
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 4
48014: PUSH
48015: LD_INT 1
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: LD_INT 3
48024: PUSH
48025: LD_INT 1
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: PUSH
48032: LD_INT 2
48034: PUSH
48035: LD_INT 0
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: PUSH
48042: LD_INT 2
48044: PUSH
48045: LD_INT 1
48047: NEG
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 2
48055: PUSH
48056: LD_INT 2
48058: NEG
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: PUSH
48064: LD_INT 4
48066: PUSH
48067: LD_INT 2
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 4
48076: PUSH
48077: LD_INT 4
48079: PUSH
48080: EMPTY
48081: LIST
48082: LIST
48083: PUSH
48084: LD_INT 4
48086: PUSH
48087: LD_INT 3
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 5
48096: PUSH
48097: LD_INT 4
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 5
48106: PUSH
48107: LD_INT 5
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: PUSH
48114: LD_INT 4
48116: PUSH
48117: LD_INT 5
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PUSH
48124: LD_INT 3
48126: PUSH
48127: LD_INT 4
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: LD_INT 3
48136: PUSH
48137: LD_INT 3
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PUSH
48144: LD_INT 5
48146: PUSH
48147: LD_INT 3
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 3
48156: PUSH
48157: LD_INT 5
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_INT 0
48166: PUSH
48167: LD_INT 3
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: LD_INT 0
48176: PUSH
48177: LD_INT 2
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PUSH
48184: LD_INT 1
48186: PUSH
48187: LD_INT 3
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 1
48196: PUSH
48197: LD_INT 4
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: PUSH
48204: LD_INT 0
48206: PUSH
48207: LD_INT 4
48209: PUSH
48210: EMPTY
48211: LIST
48212: LIST
48213: PUSH
48214: LD_INT 1
48216: NEG
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: EMPTY
48222: LIST
48223: LIST
48224: PUSH
48225: LD_INT 1
48227: NEG
48228: PUSH
48229: LD_INT 2
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 2
48238: PUSH
48239: LD_INT 4
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_INT 2
48248: NEG
48249: PUSH
48250: LD_INT 2
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 4
48259: NEG
48260: PUSH
48261: LD_INT 0
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 4
48270: NEG
48271: PUSH
48272: LD_INT 1
48274: NEG
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 3
48282: NEG
48283: PUSH
48284: LD_INT 0
48286: PUSH
48287: EMPTY
48288: LIST
48289: LIST
48290: PUSH
48291: LD_INT 3
48293: NEG
48294: PUSH
48295: LD_INT 1
48297: PUSH
48298: EMPTY
48299: LIST
48300: LIST
48301: PUSH
48302: LD_INT 4
48304: NEG
48305: PUSH
48306: LD_INT 1
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 5
48315: NEG
48316: PUSH
48317: LD_INT 0
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: PUSH
48324: LD_INT 5
48326: NEG
48327: PUSH
48328: LD_INT 1
48330: NEG
48331: PUSH
48332: EMPTY
48333: LIST
48334: LIST
48335: PUSH
48336: LD_INT 5
48338: NEG
48339: PUSH
48340: LD_INT 2
48342: NEG
48343: PUSH
48344: EMPTY
48345: LIST
48346: LIST
48347: PUSH
48348: LD_INT 3
48350: NEG
48351: PUSH
48352: LD_INT 2
48354: PUSH
48355: EMPTY
48356: LIST
48357: LIST
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: ST_TO_ADDR
// end ; end ;
48406: GO 48409
48408: POP
// case btype of b_depot , b_warehouse :
48409: LD_VAR 0 1
48413: PUSH
48414: LD_INT 0
48416: DOUBLE
48417: EQUAL
48418: IFTRUE 48428
48420: LD_INT 1
48422: DOUBLE
48423: EQUAL
48424: IFTRUE 48428
48426: GO 48629
48428: POP
// case nation of nation_american :
48429: LD_VAR 0 5
48433: PUSH
48434: LD_INT 1
48436: DOUBLE
48437: EQUAL
48438: IFTRUE 48442
48440: GO 48498
48442: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48443: LD_ADDR_VAR 0 9
48447: PUSH
48448: LD_VAR 0 11
48452: PUSH
48453: LD_VAR 0 12
48457: PUSH
48458: LD_VAR 0 13
48462: PUSH
48463: LD_VAR 0 14
48467: PUSH
48468: LD_VAR 0 15
48472: PUSH
48473: LD_VAR 0 16
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: LIST
48482: LIST
48483: LIST
48484: LIST
48485: PUSH
48486: LD_VAR 0 4
48490: PUSH
48491: LD_INT 1
48493: PLUS
48494: ARRAY
48495: ST_TO_ADDR
48496: GO 48627
48498: LD_INT 2
48500: DOUBLE
48501: EQUAL
48502: IFTRUE 48506
48504: GO 48562
48506: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48507: LD_ADDR_VAR 0 9
48511: PUSH
48512: LD_VAR 0 17
48516: PUSH
48517: LD_VAR 0 18
48521: PUSH
48522: LD_VAR 0 19
48526: PUSH
48527: LD_VAR 0 20
48531: PUSH
48532: LD_VAR 0 21
48536: PUSH
48537: LD_VAR 0 22
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: LIST
48549: PUSH
48550: LD_VAR 0 4
48554: PUSH
48555: LD_INT 1
48557: PLUS
48558: ARRAY
48559: ST_TO_ADDR
48560: GO 48627
48562: LD_INT 3
48564: DOUBLE
48565: EQUAL
48566: IFTRUE 48570
48568: GO 48626
48570: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48571: LD_ADDR_VAR 0 9
48575: PUSH
48576: LD_VAR 0 23
48580: PUSH
48581: LD_VAR 0 24
48585: PUSH
48586: LD_VAR 0 25
48590: PUSH
48591: LD_VAR 0 26
48595: PUSH
48596: LD_VAR 0 27
48600: PUSH
48601: LD_VAR 0 28
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: PUSH
48614: LD_VAR 0 4
48618: PUSH
48619: LD_INT 1
48621: PLUS
48622: ARRAY
48623: ST_TO_ADDR
48624: GO 48627
48626: POP
48627: GO 49182
48629: LD_INT 2
48631: DOUBLE
48632: EQUAL
48633: IFTRUE 48643
48635: LD_INT 3
48637: DOUBLE
48638: EQUAL
48639: IFTRUE 48643
48641: GO 48699
48643: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48644: LD_ADDR_VAR 0 9
48648: PUSH
48649: LD_VAR 0 29
48653: PUSH
48654: LD_VAR 0 30
48658: PUSH
48659: LD_VAR 0 31
48663: PUSH
48664: LD_VAR 0 32
48668: PUSH
48669: LD_VAR 0 33
48673: PUSH
48674: LD_VAR 0 34
48678: PUSH
48679: EMPTY
48680: LIST
48681: LIST
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: PUSH
48687: LD_VAR 0 4
48691: PUSH
48692: LD_INT 1
48694: PLUS
48695: ARRAY
48696: ST_TO_ADDR
48697: GO 49182
48699: LD_INT 16
48701: DOUBLE
48702: EQUAL
48703: IFTRUE 48761
48705: LD_INT 17
48707: DOUBLE
48708: EQUAL
48709: IFTRUE 48761
48711: LD_INT 18
48713: DOUBLE
48714: EQUAL
48715: IFTRUE 48761
48717: LD_INT 19
48719: DOUBLE
48720: EQUAL
48721: IFTRUE 48761
48723: LD_INT 22
48725: DOUBLE
48726: EQUAL
48727: IFTRUE 48761
48729: LD_INT 20
48731: DOUBLE
48732: EQUAL
48733: IFTRUE 48761
48735: LD_INT 21
48737: DOUBLE
48738: EQUAL
48739: IFTRUE 48761
48741: LD_INT 23
48743: DOUBLE
48744: EQUAL
48745: IFTRUE 48761
48747: LD_INT 24
48749: DOUBLE
48750: EQUAL
48751: IFTRUE 48761
48753: LD_INT 25
48755: DOUBLE
48756: EQUAL
48757: IFTRUE 48761
48759: GO 48817
48761: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48762: LD_ADDR_VAR 0 9
48766: PUSH
48767: LD_VAR 0 35
48771: PUSH
48772: LD_VAR 0 36
48776: PUSH
48777: LD_VAR 0 37
48781: PUSH
48782: LD_VAR 0 38
48786: PUSH
48787: LD_VAR 0 39
48791: PUSH
48792: LD_VAR 0 40
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: PUSH
48805: LD_VAR 0 4
48809: PUSH
48810: LD_INT 1
48812: PLUS
48813: ARRAY
48814: ST_TO_ADDR
48815: GO 49182
48817: LD_INT 6
48819: DOUBLE
48820: EQUAL
48821: IFTRUE 48873
48823: LD_INT 7
48825: DOUBLE
48826: EQUAL
48827: IFTRUE 48873
48829: LD_INT 8
48831: DOUBLE
48832: EQUAL
48833: IFTRUE 48873
48835: LD_INT 13
48837: DOUBLE
48838: EQUAL
48839: IFTRUE 48873
48841: LD_INT 12
48843: DOUBLE
48844: EQUAL
48845: IFTRUE 48873
48847: LD_INT 15
48849: DOUBLE
48850: EQUAL
48851: IFTRUE 48873
48853: LD_INT 11
48855: DOUBLE
48856: EQUAL
48857: IFTRUE 48873
48859: LD_INT 14
48861: DOUBLE
48862: EQUAL
48863: IFTRUE 48873
48865: LD_INT 10
48867: DOUBLE
48868: EQUAL
48869: IFTRUE 48873
48871: GO 48929
48873: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48874: LD_ADDR_VAR 0 9
48878: PUSH
48879: LD_VAR 0 41
48883: PUSH
48884: LD_VAR 0 42
48888: PUSH
48889: LD_VAR 0 43
48893: PUSH
48894: LD_VAR 0 44
48898: PUSH
48899: LD_VAR 0 45
48903: PUSH
48904: LD_VAR 0 46
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: PUSH
48917: LD_VAR 0 4
48921: PUSH
48922: LD_INT 1
48924: PLUS
48925: ARRAY
48926: ST_TO_ADDR
48927: GO 49182
48929: LD_INT 36
48931: DOUBLE
48932: EQUAL
48933: IFTRUE 48937
48935: GO 48993
48937: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48938: LD_ADDR_VAR 0 9
48942: PUSH
48943: LD_VAR 0 47
48947: PUSH
48948: LD_VAR 0 48
48952: PUSH
48953: LD_VAR 0 49
48957: PUSH
48958: LD_VAR 0 50
48962: PUSH
48963: LD_VAR 0 51
48967: PUSH
48968: LD_VAR 0 52
48972: PUSH
48973: EMPTY
48974: LIST
48975: LIST
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: PUSH
48981: LD_VAR 0 4
48985: PUSH
48986: LD_INT 1
48988: PLUS
48989: ARRAY
48990: ST_TO_ADDR
48991: GO 49182
48993: LD_INT 4
48995: DOUBLE
48996: EQUAL
48997: IFTRUE 49019
48999: LD_INT 5
49001: DOUBLE
49002: EQUAL
49003: IFTRUE 49019
49005: LD_INT 34
49007: DOUBLE
49008: EQUAL
49009: IFTRUE 49019
49011: LD_INT 37
49013: DOUBLE
49014: EQUAL
49015: IFTRUE 49019
49017: GO 49075
49019: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49020: LD_ADDR_VAR 0 9
49024: PUSH
49025: LD_VAR 0 53
49029: PUSH
49030: LD_VAR 0 54
49034: PUSH
49035: LD_VAR 0 55
49039: PUSH
49040: LD_VAR 0 56
49044: PUSH
49045: LD_VAR 0 57
49049: PUSH
49050: LD_VAR 0 58
49054: PUSH
49055: EMPTY
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: PUSH
49063: LD_VAR 0 4
49067: PUSH
49068: LD_INT 1
49070: PLUS
49071: ARRAY
49072: ST_TO_ADDR
49073: GO 49182
49075: LD_INT 31
49077: DOUBLE
49078: EQUAL
49079: IFTRUE 49125
49081: LD_INT 32
49083: DOUBLE
49084: EQUAL
49085: IFTRUE 49125
49087: LD_INT 33
49089: DOUBLE
49090: EQUAL
49091: IFTRUE 49125
49093: LD_INT 27
49095: DOUBLE
49096: EQUAL
49097: IFTRUE 49125
49099: LD_INT 26
49101: DOUBLE
49102: EQUAL
49103: IFTRUE 49125
49105: LD_INT 28
49107: DOUBLE
49108: EQUAL
49109: IFTRUE 49125
49111: LD_INT 29
49113: DOUBLE
49114: EQUAL
49115: IFTRUE 49125
49117: LD_INT 30
49119: DOUBLE
49120: EQUAL
49121: IFTRUE 49125
49123: GO 49181
49125: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49126: LD_ADDR_VAR 0 9
49130: PUSH
49131: LD_VAR 0 59
49135: PUSH
49136: LD_VAR 0 60
49140: PUSH
49141: LD_VAR 0 61
49145: PUSH
49146: LD_VAR 0 62
49150: PUSH
49151: LD_VAR 0 63
49155: PUSH
49156: LD_VAR 0 64
49160: PUSH
49161: EMPTY
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: PUSH
49169: LD_VAR 0 4
49173: PUSH
49174: LD_INT 1
49176: PLUS
49177: ARRAY
49178: ST_TO_ADDR
49179: GO 49182
49181: POP
// temp_list2 = [ ] ;
49182: LD_ADDR_VAR 0 10
49186: PUSH
49187: EMPTY
49188: ST_TO_ADDR
// for i in temp_list do
49189: LD_ADDR_VAR 0 8
49193: PUSH
49194: LD_VAR 0 9
49198: PUSH
49199: FOR_IN
49200: IFFALSE 49252
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49202: LD_ADDR_VAR 0 10
49206: PUSH
49207: LD_VAR 0 10
49211: PUSH
49212: LD_VAR 0 8
49216: PUSH
49217: LD_INT 1
49219: ARRAY
49220: PUSH
49221: LD_VAR 0 2
49225: PLUS
49226: PUSH
49227: LD_VAR 0 8
49231: PUSH
49232: LD_INT 2
49234: ARRAY
49235: PUSH
49236: LD_VAR 0 3
49240: PLUS
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: EMPTY
49247: LIST
49248: ADD
49249: ST_TO_ADDR
49250: GO 49199
49252: POP
49253: POP
// result = temp_list2 ;
49254: LD_ADDR_VAR 0 7
49258: PUSH
49259: LD_VAR 0 10
49263: ST_TO_ADDR
// end ;
49264: LD_VAR 0 7
49268: RET
// export function EnemyInRange ( unit , dist ) ; begin
49269: LD_INT 0
49271: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49272: LD_ADDR_VAR 0 3
49276: PUSH
49277: LD_VAR 0 1
49281: PPUSH
49282: CALL_OW 255
49286: PPUSH
49287: LD_VAR 0 1
49291: PPUSH
49292: CALL_OW 250
49296: PPUSH
49297: LD_VAR 0 1
49301: PPUSH
49302: CALL_OW 251
49306: PPUSH
49307: LD_VAR 0 2
49311: PPUSH
49312: CALL 23373 0 4
49316: PUSH
49317: LD_INT 4
49319: ARRAY
49320: ST_TO_ADDR
// end ;
49321: LD_VAR 0 3
49325: RET
// export function PlayerSeeMe ( unit ) ; begin
49326: LD_INT 0
49328: PPUSH
// result := See ( your_side , unit ) ;
49329: LD_ADDR_VAR 0 2
49333: PUSH
49334: LD_OWVAR 2
49338: PPUSH
49339: LD_VAR 0 1
49343: PPUSH
49344: CALL_OW 292
49348: ST_TO_ADDR
// end ;
49349: LD_VAR 0 2
49353: RET
// export function ReverseDir ( unit ) ; begin
49354: LD_INT 0
49356: PPUSH
// if not unit then
49357: LD_VAR 0 1
49361: NOT
49362: IFFALSE 49366
// exit ;
49364: GO 49389
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49366: LD_ADDR_VAR 0 2
49370: PUSH
49371: LD_VAR 0 1
49375: PPUSH
49376: CALL_OW 254
49380: PUSH
49381: LD_INT 3
49383: PLUS
49384: PUSH
49385: LD_INT 6
49387: MOD
49388: ST_TO_ADDR
// end ;
49389: LD_VAR 0 2
49393: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
49394: LD_INT 0
49396: PPUSH
49397: PPUSH
49398: PPUSH
49399: PPUSH
49400: PPUSH
// if not hexes then
49401: LD_VAR 0 2
49405: NOT
49406: IFFALSE 49410
// exit ;
49408: GO 49558
// dist := 9999 ;
49410: LD_ADDR_VAR 0 5
49414: PUSH
49415: LD_INT 9999
49417: ST_TO_ADDR
// for i = 1 to hexes do
49418: LD_ADDR_VAR 0 4
49422: PUSH
49423: DOUBLE
49424: LD_INT 1
49426: DEC
49427: ST_TO_ADDR
49428: LD_VAR 0 2
49432: PUSH
49433: FOR_TO
49434: IFFALSE 49546
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
49436: LD_VAR 0 1
49440: PPUSH
49441: LD_VAR 0 2
49445: PUSH
49446: LD_VAR 0 4
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: ARRAY
49455: PPUSH
49456: LD_VAR 0 2
49460: PUSH
49461: LD_VAR 0 4
49465: ARRAY
49466: PUSH
49467: LD_INT 2
49469: ARRAY
49470: PPUSH
49471: CALL_OW 297
49475: PUSH
49476: LD_VAR 0 5
49480: LESS
49481: IFFALSE 49544
// begin hex := hexes [ i ] ;
49483: LD_ADDR_VAR 0 7
49487: PUSH
49488: LD_VAR 0 2
49492: PUSH
49493: LD_VAR 0 4
49497: ARRAY
49498: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49499: LD_ADDR_VAR 0 5
49503: PUSH
49504: LD_VAR 0 1
49508: PPUSH
49509: LD_VAR 0 2
49513: PUSH
49514: LD_VAR 0 4
49518: ARRAY
49519: PUSH
49520: LD_INT 1
49522: ARRAY
49523: PPUSH
49524: LD_VAR 0 2
49528: PUSH
49529: LD_VAR 0 4
49533: ARRAY
49534: PUSH
49535: LD_INT 2
49537: ARRAY
49538: PPUSH
49539: CALL_OW 297
49543: ST_TO_ADDR
// end ; end ;
49544: GO 49433
49546: POP
49547: POP
// result := hex ;
49548: LD_ADDR_VAR 0 3
49552: PUSH
49553: LD_VAR 0 7
49557: ST_TO_ADDR
// end ;
49558: LD_VAR 0 3
49562: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49563: LD_INT 0
49565: PPUSH
49566: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49567: LD_VAR 0 1
49571: NOT
49572: PUSH
49573: LD_VAR 0 1
49577: PUSH
49578: LD_INT 21
49580: PUSH
49581: LD_INT 2
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 23
49590: PUSH
49591: LD_INT 2
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: PPUSH
49602: CALL_OW 69
49606: IN
49607: NOT
49608: OR
49609: IFFALSE 49613
// exit ;
49611: GO 49660
// for i = 1 to 3 do
49613: LD_ADDR_VAR 0 3
49617: PUSH
49618: DOUBLE
49619: LD_INT 1
49621: DEC
49622: ST_TO_ADDR
49623: LD_INT 3
49625: PUSH
49626: FOR_TO
49627: IFFALSE 49658
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49629: LD_VAR 0 1
49633: PPUSH
49634: CALL_OW 250
49638: PPUSH
49639: LD_VAR 0 1
49643: PPUSH
49644: CALL_OW 251
49648: PPUSH
49649: LD_INT 1
49651: PPUSH
49652: CALL_OW 453
49656: GO 49626
49658: POP
49659: POP
// end ;
49660: LD_VAR 0 2
49664: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49665: LD_INT 0
49667: PPUSH
49668: PPUSH
49669: PPUSH
49670: PPUSH
49671: PPUSH
49672: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
49673: LD_VAR 0 1
49677: NOT
49678: PUSH
49679: LD_VAR 0 2
49683: NOT
49684: OR
49685: PUSH
49686: LD_VAR 0 1
49690: PPUSH
49691: CALL_OW 314
49695: OR
49696: IFFALSE 49700
// exit ;
49698: GO 50141
// x := GetX ( enemy_unit ) ;
49700: LD_ADDR_VAR 0 7
49704: PUSH
49705: LD_VAR 0 2
49709: PPUSH
49710: CALL_OW 250
49714: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49715: LD_ADDR_VAR 0 8
49719: PUSH
49720: LD_VAR 0 2
49724: PPUSH
49725: CALL_OW 251
49729: ST_TO_ADDR
// if not x or not y then
49730: LD_VAR 0 7
49734: NOT
49735: PUSH
49736: LD_VAR 0 8
49740: NOT
49741: OR
49742: IFFALSE 49746
// exit ;
49744: GO 50141
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49746: LD_ADDR_VAR 0 6
49750: PUSH
49751: LD_VAR 0 7
49755: PPUSH
49756: LD_INT 0
49758: PPUSH
49759: LD_INT 4
49761: PPUSH
49762: CALL_OW 272
49766: PUSH
49767: LD_VAR 0 8
49771: PPUSH
49772: LD_INT 0
49774: PPUSH
49775: LD_INT 4
49777: PPUSH
49778: CALL_OW 273
49782: PUSH
49783: EMPTY
49784: LIST
49785: LIST
49786: PUSH
49787: LD_VAR 0 7
49791: PPUSH
49792: LD_INT 1
49794: PPUSH
49795: LD_INT 4
49797: PPUSH
49798: CALL_OW 272
49802: PUSH
49803: LD_VAR 0 8
49807: PPUSH
49808: LD_INT 1
49810: PPUSH
49811: LD_INT 4
49813: PPUSH
49814: CALL_OW 273
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_VAR 0 7
49827: PPUSH
49828: LD_INT 2
49830: PPUSH
49831: LD_INT 4
49833: PPUSH
49834: CALL_OW 272
49838: PUSH
49839: LD_VAR 0 8
49843: PPUSH
49844: LD_INT 2
49846: PPUSH
49847: LD_INT 4
49849: PPUSH
49850: CALL_OW 273
49854: PUSH
49855: EMPTY
49856: LIST
49857: LIST
49858: PUSH
49859: LD_VAR 0 7
49863: PPUSH
49864: LD_INT 3
49866: PPUSH
49867: LD_INT 4
49869: PPUSH
49870: CALL_OW 272
49874: PUSH
49875: LD_VAR 0 8
49879: PPUSH
49880: LD_INT 3
49882: PPUSH
49883: LD_INT 4
49885: PPUSH
49886: CALL_OW 273
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_VAR 0 7
49899: PPUSH
49900: LD_INT 4
49902: PPUSH
49903: LD_INT 4
49905: PPUSH
49906: CALL_OW 272
49910: PUSH
49911: LD_VAR 0 8
49915: PPUSH
49916: LD_INT 4
49918: PPUSH
49919: LD_INT 4
49921: PPUSH
49922: CALL_OW 273
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PUSH
49931: LD_VAR 0 7
49935: PPUSH
49936: LD_INT 5
49938: PPUSH
49939: LD_INT 4
49941: PPUSH
49942: CALL_OW 272
49946: PUSH
49947: LD_VAR 0 8
49951: PPUSH
49952: LD_INT 5
49954: PPUSH
49955: LD_INT 4
49957: PPUSH
49958: CALL_OW 273
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: LIST
49974: ST_TO_ADDR
// for i = tmp downto 1 do
49975: LD_ADDR_VAR 0 4
49979: PUSH
49980: DOUBLE
49981: LD_VAR 0 6
49985: INC
49986: ST_TO_ADDR
49987: LD_INT 1
49989: PUSH
49990: FOR_DOWNTO
49991: IFFALSE 50092
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49993: LD_VAR 0 6
49997: PUSH
49998: LD_VAR 0 4
50002: ARRAY
50003: PUSH
50004: LD_INT 1
50006: ARRAY
50007: PPUSH
50008: LD_VAR 0 6
50012: PUSH
50013: LD_VAR 0 4
50017: ARRAY
50018: PUSH
50019: LD_INT 2
50021: ARRAY
50022: PPUSH
50023: CALL_OW 488
50027: NOT
50028: PUSH
50029: LD_VAR 0 6
50033: PUSH
50034: LD_VAR 0 4
50038: ARRAY
50039: PUSH
50040: LD_INT 1
50042: ARRAY
50043: PPUSH
50044: LD_VAR 0 6
50048: PUSH
50049: LD_VAR 0 4
50053: ARRAY
50054: PUSH
50055: LD_INT 2
50057: ARRAY
50058: PPUSH
50059: CALL_OW 428
50063: PUSH
50064: LD_INT 0
50066: NONEQUAL
50067: OR
50068: IFFALSE 50090
// tmp := Delete ( tmp , i ) ;
50070: LD_ADDR_VAR 0 6
50074: PUSH
50075: LD_VAR 0 6
50079: PPUSH
50080: LD_VAR 0 4
50084: PPUSH
50085: CALL_OW 3
50089: ST_TO_ADDR
50090: GO 49990
50092: POP
50093: POP
// j := GetClosestHex ( unit , tmp ) ;
50094: LD_ADDR_VAR 0 5
50098: PUSH
50099: LD_VAR 0 1
50103: PPUSH
50104: LD_VAR 0 6
50108: PPUSH
50109: CALL 49394 0 2
50113: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50114: LD_VAR 0 1
50118: PPUSH
50119: LD_VAR 0 5
50123: PUSH
50124: LD_INT 1
50126: ARRAY
50127: PPUSH
50128: LD_VAR 0 5
50132: PUSH
50133: LD_INT 2
50135: ARRAY
50136: PPUSH
50137: CALL_OW 111
// end ;
50141: LD_VAR 0 3
50145: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50146: LD_INT 0
50148: PPUSH
50149: PPUSH
50150: PPUSH
// uc_side = 0 ;
50151: LD_ADDR_OWVAR 20
50155: PUSH
50156: LD_INT 0
50158: ST_TO_ADDR
// uc_nation = 0 ;
50159: LD_ADDR_OWVAR 21
50163: PUSH
50164: LD_INT 0
50166: ST_TO_ADDR
// InitHc_All ( ) ;
50167: CALL_OW 584
// InitVc ;
50171: CALL_OW 20
// if mastodonts then
50175: LD_VAR 0 6
50179: IFFALSE 50246
// for i = 1 to mastodonts do
50181: LD_ADDR_VAR 0 11
50185: PUSH
50186: DOUBLE
50187: LD_INT 1
50189: DEC
50190: ST_TO_ADDR
50191: LD_VAR 0 6
50195: PUSH
50196: FOR_TO
50197: IFFALSE 50244
// begin vc_chassis := 31 ;
50199: LD_ADDR_OWVAR 37
50203: PUSH
50204: LD_INT 31
50206: ST_TO_ADDR
// vc_control := control_rider ;
50207: LD_ADDR_OWVAR 38
50211: PUSH
50212: LD_INT 4
50214: ST_TO_ADDR
// animal := CreateVehicle ;
50215: LD_ADDR_VAR 0 12
50219: PUSH
50220: CALL_OW 45
50224: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50225: LD_VAR 0 12
50229: PPUSH
50230: LD_VAR 0 8
50234: PPUSH
50235: LD_INT 0
50237: PPUSH
50238: CALL 52434 0 3
// end ;
50242: GO 50196
50244: POP
50245: POP
// if horses then
50246: LD_VAR 0 5
50250: IFFALSE 50317
// for i = 1 to horses do
50252: LD_ADDR_VAR 0 11
50256: PUSH
50257: DOUBLE
50258: LD_INT 1
50260: DEC
50261: ST_TO_ADDR
50262: LD_VAR 0 5
50266: PUSH
50267: FOR_TO
50268: IFFALSE 50315
// begin hc_class := 21 ;
50270: LD_ADDR_OWVAR 28
50274: PUSH
50275: LD_INT 21
50277: ST_TO_ADDR
// hc_gallery :=  ;
50278: LD_ADDR_OWVAR 33
50282: PUSH
50283: LD_STRING 
50285: ST_TO_ADDR
// animal := CreateHuman ;
50286: LD_ADDR_VAR 0 12
50290: PUSH
50291: CALL_OW 44
50295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50296: LD_VAR 0 12
50300: PPUSH
50301: LD_VAR 0 8
50305: PPUSH
50306: LD_INT 0
50308: PPUSH
50309: CALL 52434 0 3
// end ;
50313: GO 50267
50315: POP
50316: POP
// if birds then
50317: LD_VAR 0 1
50321: IFFALSE 50388
// for i = 1 to birds do
50323: LD_ADDR_VAR 0 11
50327: PUSH
50328: DOUBLE
50329: LD_INT 1
50331: DEC
50332: ST_TO_ADDR
50333: LD_VAR 0 1
50337: PUSH
50338: FOR_TO
50339: IFFALSE 50386
// begin hc_class = 18 ;
50341: LD_ADDR_OWVAR 28
50345: PUSH
50346: LD_INT 18
50348: ST_TO_ADDR
// hc_gallery =  ;
50349: LD_ADDR_OWVAR 33
50353: PUSH
50354: LD_STRING 
50356: ST_TO_ADDR
// animal := CreateHuman ;
50357: LD_ADDR_VAR 0 12
50361: PUSH
50362: CALL_OW 44
50366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50367: LD_VAR 0 12
50371: PPUSH
50372: LD_VAR 0 8
50376: PPUSH
50377: LD_INT 0
50379: PPUSH
50380: CALL 52434 0 3
// end ;
50384: GO 50338
50386: POP
50387: POP
// if tigers then
50388: LD_VAR 0 2
50392: IFFALSE 50476
// for i = 1 to tigers do
50394: LD_ADDR_VAR 0 11
50398: PUSH
50399: DOUBLE
50400: LD_INT 1
50402: DEC
50403: ST_TO_ADDR
50404: LD_VAR 0 2
50408: PUSH
50409: FOR_TO
50410: IFFALSE 50474
// begin hc_class = class_tiger ;
50412: LD_ADDR_OWVAR 28
50416: PUSH
50417: LD_INT 14
50419: ST_TO_ADDR
// hc_gallery =  ;
50420: LD_ADDR_OWVAR 33
50424: PUSH
50425: LD_STRING 
50427: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
50428: LD_ADDR_OWVAR 35
50432: PUSH
50433: LD_INT 7
50435: NEG
50436: PPUSH
50437: LD_INT 7
50439: PPUSH
50440: CALL_OW 12
50444: ST_TO_ADDR
// animal := CreateHuman ;
50445: LD_ADDR_VAR 0 12
50449: PUSH
50450: CALL_OW 44
50454: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50455: LD_VAR 0 12
50459: PPUSH
50460: LD_VAR 0 8
50464: PPUSH
50465: LD_INT 0
50467: PPUSH
50468: CALL 52434 0 3
// end ;
50472: GO 50409
50474: POP
50475: POP
// if apemans then
50476: LD_VAR 0 3
50480: IFFALSE 50603
// for i = 1 to apemans do
50482: LD_ADDR_VAR 0 11
50486: PUSH
50487: DOUBLE
50488: LD_INT 1
50490: DEC
50491: ST_TO_ADDR
50492: LD_VAR 0 3
50496: PUSH
50497: FOR_TO
50498: IFFALSE 50601
// begin hc_class = class_apeman ;
50500: LD_ADDR_OWVAR 28
50504: PUSH
50505: LD_INT 12
50507: ST_TO_ADDR
// hc_gallery =  ;
50508: LD_ADDR_OWVAR 33
50512: PUSH
50513: LD_STRING 
50515: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
50516: LD_ADDR_OWVAR 35
50520: PUSH
50521: LD_INT 5
50523: NEG
50524: PPUSH
50525: LD_INT 5
50527: PPUSH
50528: CALL_OW 12
50532: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
50533: LD_ADDR_OWVAR 31
50537: PUSH
50538: LD_INT 1
50540: PPUSH
50541: LD_INT 3
50543: PPUSH
50544: CALL_OW 12
50548: PUSH
50549: LD_INT 1
50551: PPUSH
50552: LD_INT 3
50554: PPUSH
50555: CALL_OW 12
50559: PUSH
50560: LD_INT 0
50562: PUSH
50563: LD_INT 0
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: ST_TO_ADDR
// animal := CreateHuman ;
50572: LD_ADDR_VAR 0 12
50576: PUSH
50577: CALL_OW 44
50581: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50582: LD_VAR 0 12
50586: PPUSH
50587: LD_VAR 0 8
50591: PPUSH
50592: LD_INT 0
50594: PPUSH
50595: CALL 52434 0 3
// end ;
50599: GO 50497
50601: POP
50602: POP
// if enchidnas then
50603: LD_VAR 0 4
50607: IFFALSE 50674
// for i = 1 to enchidnas do
50609: LD_ADDR_VAR 0 11
50613: PUSH
50614: DOUBLE
50615: LD_INT 1
50617: DEC
50618: ST_TO_ADDR
50619: LD_VAR 0 4
50623: PUSH
50624: FOR_TO
50625: IFFALSE 50672
// begin hc_class = 13 ;
50627: LD_ADDR_OWVAR 28
50631: PUSH
50632: LD_INT 13
50634: ST_TO_ADDR
// hc_gallery =  ;
50635: LD_ADDR_OWVAR 33
50639: PUSH
50640: LD_STRING 
50642: ST_TO_ADDR
// animal := CreateHuman ;
50643: LD_ADDR_VAR 0 12
50647: PUSH
50648: CALL_OW 44
50652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50653: LD_VAR 0 12
50657: PPUSH
50658: LD_VAR 0 8
50662: PPUSH
50663: LD_INT 0
50665: PPUSH
50666: CALL 52434 0 3
// end ;
50670: GO 50624
50672: POP
50673: POP
// if fishes then
50674: LD_VAR 0 7
50678: IFFALSE 50745
// for i = 1 to fishes do
50680: LD_ADDR_VAR 0 11
50684: PUSH
50685: DOUBLE
50686: LD_INT 1
50688: DEC
50689: ST_TO_ADDR
50690: LD_VAR 0 7
50694: PUSH
50695: FOR_TO
50696: IFFALSE 50743
// begin hc_class = 20 ;
50698: LD_ADDR_OWVAR 28
50702: PUSH
50703: LD_INT 20
50705: ST_TO_ADDR
// hc_gallery =  ;
50706: LD_ADDR_OWVAR 33
50710: PUSH
50711: LD_STRING 
50713: ST_TO_ADDR
// animal := CreateHuman ;
50714: LD_ADDR_VAR 0 12
50718: PUSH
50719: CALL_OW 44
50723: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50724: LD_VAR 0 12
50728: PPUSH
50729: LD_VAR 0 9
50733: PPUSH
50734: LD_INT 0
50736: PPUSH
50737: CALL 52434 0 3
// end ;
50741: GO 50695
50743: POP
50744: POP
// end ;
50745: LD_VAR 0 10
50749: RET
// export function WantHeal ( sci , unit ) ; begin
50750: LD_INT 0
50752: PPUSH
// if GetTaskList ( sci ) > 0 then
50753: LD_VAR 0 1
50757: PPUSH
50758: CALL_OW 437
50762: PUSH
50763: LD_INT 0
50765: GREATER
50766: IFFALSE 50836
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50768: LD_VAR 0 1
50772: PPUSH
50773: CALL_OW 437
50777: PUSH
50778: LD_INT 1
50780: ARRAY
50781: PUSH
50782: LD_INT 1
50784: ARRAY
50785: PUSH
50786: LD_STRING l
50788: EQUAL
50789: PUSH
50790: LD_VAR 0 1
50794: PPUSH
50795: CALL_OW 437
50799: PUSH
50800: LD_INT 1
50802: ARRAY
50803: PUSH
50804: LD_INT 4
50806: ARRAY
50807: PUSH
50808: LD_VAR 0 2
50812: EQUAL
50813: AND
50814: IFFALSE 50826
// result := true else
50816: LD_ADDR_VAR 0 3
50820: PUSH
50821: LD_INT 1
50823: ST_TO_ADDR
50824: GO 50834
// result := false ;
50826: LD_ADDR_VAR 0 3
50830: PUSH
50831: LD_INT 0
50833: ST_TO_ADDR
// end else
50834: GO 50844
// result := false ;
50836: LD_ADDR_VAR 0 3
50840: PUSH
50841: LD_INT 0
50843: ST_TO_ADDR
// end ;
50844: LD_VAR 0 3
50848: RET
// export function HealTarget ( sci ) ; begin
50849: LD_INT 0
50851: PPUSH
// if not sci then
50852: LD_VAR 0 1
50856: NOT
50857: IFFALSE 50861
// exit ;
50859: GO 50926
// result := 0 ;
50861: LD_ADDR_VAR 0 2
50865: PUSH
50866: LD_INT 0
50868: ST_TO_ADDR
// if GetTaskList ( sci ) then
50869: LD_VAR 0 1
50873: PPUSH
50874: CALL_OW 437
50878: IFFALSE 50926
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50880: LD_VAR 0 1
50884: PPUSH
50885: CALL_OW 437
50889: PUSH
50890: LD_INT 1
50892: ARRAY
50893: PUSH
50894: LD_INT 1
50896: ARRAY
50897: PUSH
50898: LD_STRING l
50900: EQUAL
50901: IFFALSE 50926
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50903: LD_ADDR_VAR 0 2
50907: PUSH
50908: LD_VAR 0 1
50912: PPUSH
50913: CALL_OW 437
50917: PUSH
50918: LD_INT 1
50920: ARRAY
50921: PUSH
50922: LD_INT 4
50924: ARRAY
50925: ST_TO_ADDR
// end ;
50926: LD_VAR 0 2
50930: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50931: LD_INT 0
50933: PPUSH
50934: PPUSH
50935: PPUSH
50936: PPUSH
// if not base_units then
50937: LD_VAR 0 1
50941: NOT
50942: IFFALSE 50946
// exit ;
50944: GO 51033
// result := false ;
50946: LD_ADDR_VAR 0 2
50950: PUSH
50951: LD_INT 0
50953: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50954: LD_ADDR_VAR 0 5
50958: PUSH
50959: LD_VAR 0 1
50963: PPUSH
50964: LD_INT 21
50966: PUSH
50967: LD_INT 3
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: PPUSH
50974: CALL_OW 72
50978: ST_TO_ADDR
// if not tmp then
50979: LD_VAR 0 5
50983: NOT
50984: IFFALSE 50988
// exit ;
50986: GO 51033
// for i in tmp do
50988: LD_ADDR_VAR 0 3
50992: PUSH
50993: LD_VAR 0 5
50997: PUSH
50998: FOR_IN
50999: IFFALSE 51031
// begin result := EnemyInRange ( i , 22 ) ;
51001: LD_ADDR_VAR 0 2
51005: PUSH
51006: LD_VAR 0 3
51010: PPUSH
51011: LD_INT 22
51013: PPUSH
51014: CALL 49269 0 2
51018: ST_TO_ADDR
// if result then
51019: LD_VAR 0 2
51023: IFFALSE 51029
// exit ;
51025: POP
51026: POP
51027: GO 51033
// end ;
51029: GO 50998
51031: POP
51032: POP
// end ;
51033: LD_VAR 0 2
51037: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51038: LD_INT 0
51040: PPUSH
51041: PPUSH
// if not units then
51042: LD_VAR 0 1
51046: NOT
51047: IFFALSE 51051
// exit ;
51049: GO 51121
// result := [ ] ;
51051: LD_ADDR_VAR 0 3
51055: PUSH
51056: EMPTY
51057: ST_TO_ADDR
// for i in units do
51058: LD_ADDR_VAR 0 4
51062: PUSH
51063: LD_VAR 0 1
51067: PUSH
51068: FOR_IN
51069: IFFALSE 51119
// if GetTag ( i ) = tag then
51071: LD_VAR 0 4
51075: PPUSH
51076: CALL_OW 110
51080: PUSH
51081: LD_VAR 0 2
51085: EQUAL
51086: IFFALSE 51117
// result := Insert ( result , result + 1 , i ) ;
51088: LD_ADDR_VAR 0 3
51092: PUSH
51093: LD_VAR 0 3
51097: PPUSH
51098: LD_VAR 0 3
51102: PUSH
51103: LD_INT 1
51105: PLUS
51106: PPUSH
51107: LD_VAR 0 4
51111: PPUSH
51112: CALL_OW 2
51116: ST_TO_ADDR
51117: GO 51068
51119: POP
51120: POP
// end ;
51121: LD_VAR 0 3
51125: RET
// export function IsDriver ( un ) ; begin
51126: LD_INT 0
51128: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51129: LD_ADDR_VAR 0 2
51133: PUSH
51134: LD_VAR 0 1
51138: PUSH
51139: LD_INT 55
51141: PUSH
51142: EMPTY
51143: LIST
51144: PPUSH
51145: CALL_OW 69
51149: IN
51150: ST_TO_ADDR
// end ;
51151: LD_VAR 0 2
51155: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51156: LD_INT 0
51158: PPUSH
51159: PPUSH
// list := [ ] ;
51160: LD_ADDR_VAR 0 5
51164: PUSH
51165: EMPTY
51166: ST_TO_ADDR
// case d of 0 :
51167: LD_VAR 0 3
51171: PUSH
51172: LD_INT 0
51174: DOUBLE
51175: EQUAL
51176: IFTRUE 51180
51178: GO 51313
51180: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51181: LD_ADDR_VAR 0 5
51185: PUSH
51186: LD_VAR 0 1
51190: PUSH
51191: LD_INT 4
51193: MINUS
51194: PUSH
51195: LD_VAR 0 2
51199: PUSH
51200: LD_INT 4
51202: MINUS
51203: PUSH
51204: LD_INT 2
51206: PUSH
51207: EMPTY
51208: LIST
51209: LIST
51210: LIST
51211: PUSH
51212: LD_VAR 0 1
51216: PUSH
51217: LD_INT 3
51219: MINUS
51220: PUSH
51221: LD_VAR 0 2
51225: PUSH
51226: LD_INT 1
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: LIST
51233: PUSH
51234: LD_VAR 0 1
51238: PUSH
51239: LD_INT 4
51241: PLUS
51242: PUSH
51243: LD_VAR 0 2
51247: PUSH
51248: LD_INT 4
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: LIST
51255: PUSH
51256: LD_VAR 0 1
51260: PUSH
51261: LD_INT 3
51263: PLUS
51264: PUSH
51265: LD_VAR 0 2
51269: PUSH
51270: LD_INT 3
51272: PLUS
51273: PUSH
51274: LD_INT 5
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: LIST
51281: PUSH
51282: LD_VAR 0 1
51286: PUSH
51287: LD_VAR 0 2
51291: PUSH
51292: LD_INT 4
51294: PLUS
51295: PUSH
51296: LD_INT 0
51298: PUSH
51299: EMPTY
51300: LIST
51301: LIST
51302: LIST
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: LIST
51308: LIST
51309: LIST
51310: ST_TO_ADDR
// end ; 1 :
51311: GO 52011
51313: LD_INT 1
51315: DOUBLE
51316: EQUAL
51317: IFTRUE 51321
51319: GO 51454
51321: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51322: LD_ADDR_VAR 0 5
51326: PUSH
51327: LD_VAR 0 1
51331: PUSH
51332: LD_VAR 0 2
51336: PUSH
51337: LD_INT 4
51339: MINUS
51340: PUSH
51341: LD_INT 3
51343: PUSH
51344: EMPTY
51345: LIST
51346: LIST
51347: LIST
51348: PUSH
51349: LD_VAR 0 1
51353: PUSH
51354: LD_INT 3
51356: MINUS
51357: PUSH
51358: LD_VAR 0 2
51362: PUSH
51363: LD_INT 3
51365: MINUS
51366: PUSH
51367: LD_INT 2
51369: PUSH
51370: EMPTY
51371: LIST
51372: LIST
51373: LIST
51374: PUSH
51375: LD_VAR 0 1
51379: PUSH
51380: LD_INT 4
51382: MINUS
51383: PUSH
51384: LD_VAR 0 2
51388: PUSH
51389: LD_INT 1
51391: PUSH
51392: EMPTY
51393: LIST
51394: LIST
51395: LIST
51396: PUSH
51397: LD_VAR 0 1
51401: PUSH
51402: LD_VAR 0 2
51406: PUSH
51407: LD_INT 3
51409: PLUS
51410: PUSH
51411: LD_INT 0
51413: PUSH
51414: EMPTY
51415: LIST
51416: LIST
51417: LIST
51418: PUSH
51419: LD_VAR 0 1
51423: PUSH
51424: LD_INT 4
51426: PLUS
51427: PUSH
51428: LD_VAR 0 2
51432: PUSH
51433: LD_INT 4
51435: PLUS
51436: PUSH
51437: LD_INT 5
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: LIST
51444: PUSH
51445: EMPTY
51446: LIST
51447: LIST
51448: LIST
51449: LIST
51450: LIST
51451: ST_TO_ADDR
// end ; 2 :
51452: GO 52011
51454: LD_INT 2
51456: DOUBLE
51457: EQUAL
51458: IFTRUE 51462
51460: GO 51591
51462: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51463: LD_ADDR_VAR 0 5
51467: PUSH
51468: LD_VAR 0 1
51472: PUSH
51473: LD_VAR 0 2
51477: PUSH
51478: LD_INT 3
51480: MINUS
51481: PUSH
51482: LD_INT 3
51484: PUSH
51485: EMPTY
51486: LIST
51487: LIST
51488: LIST
51489: PUSH
51490: LD_VAR 0 1
51494: PUSH
51495: LD_INT 4
51497: PLUS
51498: PUSH
51499: LD_VAR 0 2
51503: PUSH
51504: LD_INT 4
51506: PUSH
51507: EMPTY
51508: LIST
51509: LIST
51510: LIST
51511: PUSH
51512: LD_VAR 0 1
51516: PUSH
51517: LD_VAR 0 2
51521: PUSH
51522: LD_INT 4
51524: PLUS
51525: PUSH
51526: LD_INT 0
51528: PUSH
51529: EMPTY
51530: LIST
51531: LIST
51532: LIST
51533: PUSH
51534: LD_VAR 0 1
51538: PUSH
51539: LD_INT 3
51541: MINUS
51542: PUSH
51543: LD_VAR 0 2
51547: PUSH
51548: LD_INT 1
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: LIST
51555: PUSH
51556: LD_VAR 0 1
51560: PUSH
51561: LD_INT 4
51563: MINUS
51564: PUSH
51565: LD_VAR 0 2
51569: PUSH
51570: LD_INT 4
51572: MINUS
51573: PUSH
51574: LD_INT 2
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: LIST
51581: PUSH
51582: EMPTY
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: ST_TO_ADDR
// end ; 3 :
51589: GO 52011
51591: LD_INT 3
51593: DOUBLE
51594: EQUAL
51595: IFTRUE 51599
51597: GO 51732
51599: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51600: LD_ADDR_VAR 0 5
51604: PUSH
51605: LD_VAR 0 1
51609: PUSH
51610: LD_INT 3
51612: PLUS
51613: PUSH
51614: LD_VAR 0 2
51618: PUSH
51619: LD_INT 4
51621: PUSH
51622: EMPTY
51623: LIST
51624: LIST
51625: LIST
51626: PUSH
51627: LD_VAR 0 1
51631: PUSH
51632: LD_INT 4
51634: PLUS
51635: PUSH
51636: LD_VAR 0 2
51640: PUSH
51641: LD_INT 4
51643: PLUS
51644: PUSH
51645: LD_INT 5
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: LIST
51652: PUSH
51653: LD_VAR 0 1
51657: PUSH
51658: LD_INT 4
51660: MINUS
51661: PUSH
51662: LD_VAR 0 2
51666: PUSH
51667: LD_INT 1
51669: PUSH
51670: EMPTY
51671: LIST
51672: LIST
51673: LIST
51674: PUSH
51675: LD_VAR 0 1
51679: PUSH
51680: LD_VAR 0 2
51684: PUSH
51685: LD_INT 4
51687: MINUS
51688: PUSH
51689: LD_INT 3
51691: PUSH
51692: EMPTY
51693: LIST
51694: LIST
51695: LIST
51696: PUSH
51697: LD_VAR 0 1
51701: PUSH
51702: LD_INT 3
51704: MINUS
51705: PUSH
51706: LD_VAR 0 2
51710: PUSH
51711: LD_INT 3
51713: MINUS
51714: PUSH
51715: LD_INT 2
51717: PUSH
51718: EMPTY
51719: LIST
51720: LIST
51721: LIST
51722: PUSH
51723: EMPTY
51724: LIST
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: ST_TO_ADDR
// end ; 4 :
51730: GO 52011
51732: LD_INT 4
51734: DOUBLE
51735: EQUAL
51736: IFTRUE 51740
51738: GO 51873
51740: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51741: LD_ADDR_VAR 0 5
51745: PUSH
51746: LD_VAR 0 1
51750: PUSH
51751: LD_VAR 0 2
51755: PUSH
51756: LD_INT 4
51758: PLUS
51759: PUSH
51760: LD_INT 0
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: LIST
51767: PUSH
51768: LD_VAR 0 1
51772: PUSH
51773: LD_INT 3
51775: PLUS
51776: PUSH
51777: LD_VAR 0 2
51781: PUSH
51782: LD_INT 3
51784: PLUS
51785: PUSH
51786: LD_INT 5
51788: PUSH
51789: EMPTY
51790: LIST
51791: LIST
51792: LIST
51793: PUSH
51794: LD_VAR 0 1
51798: PUSH
51799: LD_INT 4
51801: PLUS
51802: PUSH
51803: LD_VAR 0 2
51807: PUSH
51808: LD_INT 4
51810: PUSH
51811: EMPTY
51812: LIST
51813: LIST
51814: LIST
51815: PUSH
51816: LD_VAR 0 1
51820: PUSH
51821: LD_VAR 0 2
51825: PUSH
51826: LD_INT 3
51828: MINUS
51829: PUSH
51830: LD_INT 3
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: LIST
51837: PUSH
51838: LD_VAR 0 1
51842: PUSH
51843: LD_INT 4
51845: MINUS
51846: PUSH
51847: LD_VAR 0 2
51851: PUSH
51852: LD_INT 4
51854: MINUS
51855: PUSH
51856: LD_INT 2
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: LIST
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: ST_TO_ADDR
// end ; 5 :
51871: GO 52011
51873: LD_INT 5
51875: DOUBLE
51876: EQUAL
51877: IFTRUE 51881
51879: GO 52010
51881: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51882: LD_ADDR_VAR 0 5
51886: PUSH
51887: LD_VAR 0 1
51891: PUSH
51892: LD_INT 4
51894: MINUS
51895: PUSH
51896: LD_VAR 0 2
51900: PUSH
51901: LD_INT 1
51903: PUSH
51904: EMPTY
51905: LIST
51906: LIST
51907: LIST
51908: PUSH
51909: LD_VAR 0 1
51913: PUSH
51914: LD_VAR 0 2
51918: PUSH
51919: LD_INT 4
51921: MINUS
51922: PUSH
51923: LD_INT 3
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: LIST
51930: PUSH
51931: LD_VAR 0 1
51935: PUSH
51936: LD_INT 4
51938: PLUS
51939: PUSH
51940: LD_VAR 0 2
51944: PUSH
51945: LD_INT 4
51947: PLUS
51948: PUSH
51949: LD_INT 5
51951: PUSH
51952: EMPTY
51953: LIST
51954: LIST
51955: LIST
51956: PUSH
51957: LD_VAR 0 1
51961: PUSH
51962: LD_INT 3
51964: PLUS
51965: PUSH
51966: LD_VAR 0 2
51970: PUSH
51971: LD_INT 4
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: LIST
51978: PUSH
51979: LD_VAR 0 1
51983: PUSH
51984: LD_VAR 0 2
51988: PUSH
51989: LD_INT 3
51991: PLUS
51992: PUSH
51993: LD_INT 0
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: LIST
52000: PUSH
52001: EMPTY
52002: LIST
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: ST_TO_ADDR
// end ; end ;
52008: GO 52011
52010: POP
// result := list ;
52011: LD_ADDR_VAR 0 4
52015: PUSH
52016: LD_VAR 0 5
52020: ST_TO_ADDR
// end ;
52021: LD_VAR 0 4
52025: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52026: LD_INT 0
52028: PPUSH
52029: PPUSH
52030: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52031: LD_VAR 0 1
52035: NOT
52036: PUSH
52037: LD_VAR 0 2
52041: PUSH
52042: LD_INT 1
52044: PUSH
52045: LD_INT 2
52047: PUSH
52048: LD_INT 3
52050: PUSH
52051: LD_INT 4
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: LIST
52058: LIST
52059: IN
52060: NOT
52061: OR
52062: IFFALSE 52066
// exit ;
52064: GO 52158
// tmp := [ ] ;
52066: LD_ADDR_VAR 0 5
52070: PUSH
52071: EMPTY
52072: ST_TO_ADDR
// for i in units do
52073: LD_ADDR_VAR 0 4
52077: PUSH
52078: LD_VAR 0 1
52082: PUSH
52083: FOR_IN
52084: IFFALSE 52127
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52086: LD_ADDR_VAR 0 5
52090: PUSH
52091: LD_VAR 0 5
52095: PPUSH
52096: LD_VAR 0 5
52100: PUSH
52101: LD_INT 1
52103: PLUS
52104: PPUSH
52105: LD_VAR 0 4
52109: PPUSH
52110: LD_VAR 0 2
52114: PPUSH
52115: CALL_OW 259
52119: PPUSH
52120: CALL_OW 2
52124: ST_TO_ADDR
52125: GO 52083
52127: POP
52128: POP
// if not tmp then
52129: LD_VAR 0 5
52133: NOT
52134: IFFALSE 52138
// exit ;
52136: GO 52158
// result := SortListByListDesc ( units , tmp ) ;
52138: LD_ADDR_VAR 0 3
52142: PUSH
52143: LD_VAR 0 1
52147: PPUSH
52148: LD_VAR 0 5
52152: PPUSH
52153: CALL_OW 77
52157: ST_TO_ADDR
// end ;
52158: LD_VAR 0 3
52162: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52163: LD_INT 0
52165: PPUSH
52166: PPUSH
52167: PPUSH
// result := false ;
52168: LD_ADDR_VAR 0 3
52172: PUSH
52173: LD_INT 0
52175: ST_TO_ADDR
// x := GetX ( building ) ;
52176: LD_ADDR_VAR 0 4
52180: PUSH
52181: LD_VAR 0 2
52185: PPUSH
52186: CALL_OW 250
52190: ST_TO_ADDR
// y := GetY ( building ) ;
52191: LD_ADDR_VAR 0 5
52195: PUSH
52196: LD_VAR 0 2
52200: PPUSH
52201: CALL_OW 251
52205: ST_TO_ADDR
// if not building or not x or not y then
52206: LD_VAR 0 2
52210: NOT
52211: PUSH
52212: LD_VAR 0 4
52216: NOT
52217: OR
52218: PUSH
52219: LD_VAR 0 5
52223: NOT
52224: OR
52225: IFFALSE 52229
// exit ;
52227: GO 52321
// if GetTaskList ( unit ) then
52229: LD_VAR 0 1
52233: PPUSH
52234: CALL_OW 437
52238: IFFALSE 52321
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52240: LD_STRING e
52242: PUSH
52243: LD_VAR 0 1
52247: PPUSH
52248: CALL_OW 437
52252: PUSH
52253: LD_INT 1
52255: ARRAY
52256: PUSH
52257: LD_INT 1
52259: ARRAY
52260: EQUAL
52261: PUSH
52262: LD_VAR 0 4
52266: PUSH
52267: LD_VAR 0 1
52271: PPUSH
52272: CALL_OW 437
52276: PUSH
52277: LD_INT 1
52279: ARRAY
52280: PUSH
52281: LD_INT 2
52283: ARRAY
52284: EQUAL
52285: AND
52286: PUSH
52287: LD_VAR 0 5
52291: PUSH
52292: LD_VAR 0 1
52296: PPUSH
52297: CALL_OW 437
52301: PUSH
52302: LD_INT 1
52304: ARRAY
52305: PUSH
52306: LD_INT 3
52308: ARRAY
52309: EQUAL
52310: AND
52311: IFFALSE 52321
// result := true end ;
52313: LD_ADDR_VAR 0 3
52317: PUSH
52318: LD_INT 1
52320: ST_TO_ADDR
// end ;
52321: LD_VAR 0 3
52325: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52326: LD_INT 0
52328: PPUSH
// result := false ;
52329: LD_ADDR_VAR 0 4
52333: PUSH
52334: LD_INT 0
52336: ST_TO_ADDR
// if GetTaskList ( unit ) then
52337: LD_VAR 0 1
52341: PPUSH
52342: CALL_OW 437
52346: IFFALSE 52429
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52348: LD_STRING M
52350: PUSH
52351: LD_VAR 0 1
52355: PPUSH
52356: CALL_OW 437
52360: PUSH
52361: LD_INT 1
52363: ARRAY
52364: PUSH
52365: LD_INT 1
52367: ARRAY
52368: EQUAL
52369: PUSH
52370: LD_VAR 0 2
52374: PUSH
52375: LD_VAR 0 1
52379: PPUSH
52380: CALL_OW 437
52384: PUSH
52385: LD_INT 1
52387: ARRAY
52388: PUSH
52389: LD_INT 2
52391: ARRAY
52392: EQUAL
52393: AND
52394: PUSH
52395: LD_VAR 0 3
52399: PUSH
52400: LD_VAR 0 1
52404: PPUSH
52405: CALL_OW 437
52409: PUSH
52410: LD_INT 1
52412: ARRAY
52413: PUSH
52414: LD_INT 3
52416: ARRAY
52417: EQUAL
52418: AND
52419: IFFALSE 52429
// result := true ;
52421: LD_ADDR_VAR 0 4
52425: PUSH
52426: LD_INT 1
52428: ST_TO_ADDR
// end ; end ;
52429: LD_VAR 0 4
52433: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52434: LD_INT 0
52436: PPUSH
52437: PPUSH
52438: PPUSH
52439: PPUSH
// if not unit or not area then
52440: LD_VAR 0 1
52444: NOT
52445: PUSH
52446: LD_VAR 0 2
52450: NOT
52451: OR
52452: IFFALSE 52456
// exit ;
52454: GO 52620
// tmp := AreaToList ( area , i ) ;
52456: LD_ADDR_VAR 0 6
52460: PUSH
52461: LD_VAR 0 2
52465: PPUSH
52466: LD_VAR 0 5
52470: PPUSH
52471: CALL_OW 517
52475: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52476: LD_ADDR_VAR 0 5
52480: PUSH
52481: DOUBLE
52482: LD_INT 1
52484: DEC
52485: ST_TO_ADDR
52486: LD_VAR 0 6
52490: PUSH
52491: LD_INT 1
52493: ARRAY
52494: PUSH
52495: FOR_TO
52496: IFFALSE 52618
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52498: LD_ADDR_VAR 0 7
52502: PUSH
52503: LD_VAR 0 6
52507: PUSH
52508: LD_INT 1
52510: ARRAY
52511: PUSH
52512: LD_VAR 0 5
52516: ARRAY
52517: PUSH
52518: LD_VAR 0 6
52522: PUSH
52523: LD_INT 2
52525: ARRAY
52526: PUSH
52527: LD_VAR 0 5
52531: ARRAY
52532: PUSH
52533: EMPTY
52534: LIST
52535: LIST
52536: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
52537: LD_VAR 0 7
52541: PUSH
52542: LD_INT 1
52544: ARRAY
52545: PPUSH
52546: LD_VAR 0 7
52550: PUSH
52551: LD_INT 2
52553: ARRAY
52554: PPUSH
52555: CALL_OW 428
52559: PUSH
52560: LD_INT 0
52562: EQUAL
52563: IFFALSE 52616
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52565: LD_VAR 0 1
52569: PPUSH
52570: LD_VAR 0 7
52574: PUSH
52575: LD_INT 1
52577: ARRAY
52578: PPUSH
52579: LD_VAR 0 7
52583: PUSH
52584: LD_INT 2
52586: ARRAY
52587: PPUSH
52588: LD_VAR 0 3
52592: PPUSH
52593: CALL_OW 48
// result := IsPlaced ( unit ) ;
52597: LD_ADDR_VAR 0 4
52601: PUSH
52602: LD_VAR 0 1
52606: PPUSH
52607: CALL_OW 305
52611: ST_TO_ADDR
// exit ;
52612: POP
52613: POP
52614: GO 52620
// end ; end ;
52616: GO 52495
52618: POP
52619: POP
// end ;
52620: LD_VAR 0 4
52624: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52625: LD_INT 0
52627: PPUSH
52628: PPUSH
52629: PPUSH
// if not side or side > 8 then
52630: LD_VAR 0 1
52634: NOT
52635: PUSH
52636: LD_VAR 0 1
52640: PUSH
52641: LD_INT 8
52643: GREATER
52644: OR
52645: IFFALSE 52649
// exit ;
52647: GO 52836
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52649: LD_ADDR_VAR 0 4
52653: PUSH
52654: LD_INT 22
52656: PUSH
52657: LD_VAR 0 1
52661: PUSH
52662: EMPTY
52663: LIST
52664: LIST
52665: PUSH
52666: LD_INT 21
52668: PUSH
52669: LD_INT 3
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: PUSH
52676: EMPTY
52677: LIST
52678: LIST
52679: PPUSH
52680: CALL_OW 69
52684: ST_TO_ADDR
// if not tmp then
52685: LD_VAR 0 4
52689: NOT
52690: IFFALSE 52694
// exit ;
52692: GO 52836
// enable_addtolog := true ;
52694: LD_ADDR_OWVAR 81
52698: PUSH
52699: LD_INT 1
52701: ST_TO_ADDR
// AddToLog ( [ ) ;
52702: LD_STRING [
52704: PPUSH
52705: CALL_OW 561
// for i in tmp do
52709: LD_ADDR_VAR 0 3
52713: PUSH
52714: LD_VAR 0 4
52718: PUSH
52719: FOR_IN
52720: IFFALSE 52827
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52722: LD_STRING [
52724: PUSH
52725: LD_VAR 0 3
52729: PPUSH
52730: CALL_OW 266
52734: STR
52735: PUSH
52736: LD_STRING , 
52738: STR
52739: PUSH
52740: LD_VAR 0 3
52744: PPUSH
52745: CALL_OW 250
52749: STR
52750: PUSH
52751: LD_STRING , 
52753: STR
52754: PUSH
52755: LD_VAR 0 3
52759: PPUSH
52760: CALL_OW 251
52764: STR
52765: PUSH
52766: LD_STRING , 
52768: STR
52769: PUSH
52770: LD_VAR 0 3
52774: PPUSH
52775: CALL_OW 254
52779: STR
52780: PUSH
52781: LD_STRING , 
52783: STR
52784: PUSH
52785: LD_VAR 0 3
52789: PPUSH
52790: LD_INT 1
52792: PPUSH
52793: CALL_OW 268
52797: STR
52798: PUSH
52799: LD_STRING , 
52801: STR
52802: PUSH
52803: LD_VAR 0 3
52807: PPUSH
52808: LD_INT 2
52810: PPUSH
52811: CALL_OW 268
52815: STR
52816: PUSH
52817: LD_STRING ],
52819: STR
52820: PPUSH
52821: CALL_OW 561
// end ;
52825: GO 52719
52827: POP
52828: POP
// AddToLog ( ]; ) ;
52829: LD_STRING ];
52831: PPUSH
52832: CALL_OW 561
// end ;
52836: LD_VAR 0 2
52840: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52841: LD_INT 0
52843: PPUSH
52844: PPUSH
52845: PPUSH
52846: PPUSH
52847: PPUSH
// if not area or not rate or not max then
52848: LD_VAR 0 1
52852: NOT
52853: PUSH
52854: LD_VAR 0 2
52858: NOT
52859: OR
52860: PUSH
52861: LD_VAR 0 4
52865: NOT
52866: OR
52867: IFFALSE 52871
// exit ;
52869: GO 53063
// while 1 do
52871: LD_INT 1
52873: IFFALSE 53063
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52875: LD_ADDR_VAR 0 9
52879: PUSH
52880: LD_VAR 0 1
52884: PPUSH
52885: LD_INT 1
52887: PPUSH
52888: CALL_OW 287
52892: PUSH
52893: LD_INT 10
52895: MUL
52896: ST_TO_ADDR
// r := rate / 10 ;
52897: LD_ADDR_VAR 0 7
52901: PUSH
52902: LD_VAR 0 2
52906: PUSH
52907: LD_INT 10
52909: DIVREAL
52910: ST_TO_ADDR
// time := 1 1$00 ;
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: LD_INT 2100
52918: ST_TO_ADDR
// if amount < min then
52919: LD_VAR 0 9
52923: PUSH
52924: LD_VAR 0 3
52928: LESS
52929: IFFALSE 52947
// r := r * 2 else
52931: LD_ADDR_VAR 0 7
52935: PUSH
52936: LD_VAR 0 7
52940: PUSH
52941: LD_INT 2
52943: MUL
52944: ST_TO_ADDR
52945: GO 52973
// if amount > max then
52947: LD_VAR 0 9
52951: PUSH
52952: LD_VAR 0 4
52956: GREATER
52957: IFFALSE 52973
// r := r / 2 ;
52959: LD_ADDR_VAR 0 7
52963: PUSH
52964: LD_VAR 0 7
52968: PUSH
52969: LD_INT 2
52971: DIVREAL
52972: ST_TO_ADDR
// time := time / r ;
52973: LD_ADDR_VAR 0 8
52977: PUSH
52978: LD_VAR 0 8
52982: PUSH
52983: LD_VAR 0 7
52987: DIVREAL
52988: ST_TO_ADDR
// if time < 0 then
52989: LD_VAR 0 8
52993: PUSH
52994: LD_INT 0
52996: LESS
52997: IFFALSE 53014
// time := time * - 1 ;
52999: LD_ADDR_VAR 0 8
53003: PUSH
53004: LD_VAR 0 8
53008: PUSH
53009: LD_INT 1
53011: NEG
53012: MUL
53013: ST_TO_ADDR
// wait ( time ) ;
53014: LD_VAR 0 8
53018: PPUSH
53019: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
53023: LD_INT 35
53025: PPUSH
53026: LD_INT 875
53028: PPUSH
53029: CALL_OW 12
53033: PPUSH
53034: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53038: LD_INT 1
53040: PPUSH
53041: LD_INT 5
53043: PPUSH
53044: CALL_OW 12
53048: PPUSH
53049: LD_VAR 0 1
53053: PPUSH
53054: LD_INT 1
53056: PPUSH
53057: CALL_OW 55
// end ;
53061: GO 52871
// end ;
53063: LD_VAR 0 5
53067: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53068: LD_INT 0
53070: PPUSH
53071: PPUSH
53072: PPUSH
53073: PPUSH
53074: PPUSH
53075: PPUSH
53076: PPUSH
53077: PPUSH
// if not turrets or not factories then
53078: LD_VAR 0 1
53082: NOT
53083: PUSH
53084: LD_VAR 0 2
53088: NOT
53089: OR
53090: IFFALSE 53094
// exit ;
53092: GO 53401
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53094: LD_ADDR_VAR 0 10
53098: PUSH
53099: LD_INT 5
53101: PUSH
53102: LD_INT 6
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: LD_INT 2
53111: PUSH
53112: LD_INT 4
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: PUSH
53119: LD_INT 3
53121: PUSH
53122: LD_INT 5
53124: PUSH
53125: EMPTY
53126: LIST
53127: LIST
53128: PUSH
53129: EMPTY
53130: LIST
53131: LIST
53132: LIST
53133: PUSH
53134: LD_INT 24
53136: PUSH
53137: LD_INT 25
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: PUSH
53144: LD_INT 23
53146: PUSH
53147: LD_INT 27
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PUSH
53158: LD_INT 42
53160: PUSH
53161: LD_INT 43
53163: PUSH
53164: EMPTY
53165: LIST
53166: LIST
53167: PUSH
53168: LD_INT 44
53170: PUSH
53171: LD_INT 46
53173: PUSH
53174: EMPTY
53175: LIST
53176: LIST
53177: PUSH
53178: LD_INT 45
53180: PUSH
53181: LD_INT 47
53183: PUSH
53184: EMPTY
53185: LIST
53186: LIST
53187: PUSH
53188: EMPTY
53189: LIST
53190: LIST
53191: LIST
53192: PUSH
53193: EMPTY
53194: LIST
53195: LIST
53196: LIST
53197: ST_TO_ADDR
// result := [ ] ;
53198: LD_ADDR_VAR 0 3
53202: PUSH
53203: EMPTY
53204: ST_TO_ADDR
// for i in turrets do
53205: LD_ADDR_VAR 0 4
53209: PUSH
53210: LD_VAR 0 1
53214: PUSH
53215: FOR_IN
53216: IFFALSE 53399
// begin nat := GetNation ( i ) ;
53218: LD_ADDR_VAR 0 7
53222: PUSH
53223: LD_VAR 0 4
53227: PPUSH
53228: CALL_OW 248
53232: ST_TO_ADDR
// weapon := 0 ;
53233: LD_ADDR_VAR 0 8
53237: PUSH
53238: LD_INT 0
53240: ST_TO_ADDR
// if not nat then
53241: LD_VAR 0 7
53245: NOT
53246: IFFALSE 53250
// continue ;
53248: GO 53215
// for j in list [ nat ] do
53250: LD_ADDR_VAR 0 5
53254: PUSH
53255: LD_VAR 0 10
53259: PUSH
53260: LD_VAR 0 7
53264: ARRAY
53265: PUSH
53266: FOR_IN
53267: IFFALSE 53308
// if GetBWeapon ( i ) = j [ 1 ] then
53269: LD_VAR 0 4
53273: PPUSH
53274: CALL_OW 269
53278: PUSH
53279: LD_VAR 0 5
53283: PUSH
53284: LD_INT 1
53286: ARRAY
53287: EQUAL
53288: IFFALSE 53306
// begin weapon := j [ 2 ] ;
53290: LD_ADDR_VAR 0 8
53294: PUSH
53295: LD_VAR 0 5
53299: PUSH
53300: LD_INT 2
53302: ARRAY
53303: ST_TO_ADDR
// break ;
53304: GO 53308
// end ;
53306: GO 53266
53308: POP
53309: POP
// if not weapon then
53310: LD_VAR 0 8
53314: NOT
53315: IFFALSE 53319
// continue ;
53317: GO 53215
// for k in factories do
53319: LD_ADDR_VAR 0 6
53323: PUSH
53324: LD_VAR 0 2
53328: PUSH
53329: FOR_IN
53330: IFFALSE 53395
// begin weapons := AvailableWeaponList ( k ) ;
53332: LD_ADDR_VAR 0 9
53336: PUSH
53337: LD_VAR 0 6
53341: PPUSH
53342: CALL_OW 478
53346: ST_TO_ADDR
// if not weapons then
53347: LD_VAR 0 9
53351: NOT
53352: IFFALSE 53356
// continue ;
53354: GO 53329
// if weapon in weapons then
53356: LD_VAR 0 8
53360: PUSH
53361: LD_VAR 0 9
53365: IN
53366: IFFALSE 53393
// begin result := [ i , weapon ] ;
53368: LD_ADDR_VAR 0 3
53372: PUSH
53373: LD_VAR 0 4
53377: PUSH
53378: LD_VAR 0 8
53382: PUSH
53383: EMPTY
53384: LIST
53385: LIST
53386: ST_TO_ADDR
// exit ;
53387: POP
53388: POP
53389: POP
53390: POP
53391: GO 53401
// end ; end ;
53393: GO 53329
53395: POP
53396: POP
// end ;
53397: GO 53215
53399: POP
53400: POP
// end ;
53401: LD_VAR 0 3
53405: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53406: LD_INT 0
53408: PPUSH
// if not side or side > 8 then
53409: LD_VAR 0 3
53413: NOT
53414: PUSH
53415: LD_VAR 0 3
53419: PUSH
53420: LD_INT 8
53422: GREATER
53423: OR
53424: IFFALSE 53428
// exit ;
53426: GO 53487
// if not range then
53428: LD_VAR 0 4
53432: NOT
53433: IFFALSE 53444
// range := - 12 ;
53435: LD_ADDR_VAR 0 4
53439: PUSH
53440: LD_INT 12
53442: NEG
53443: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53444: LD_VAR 0 1
53448: PPUSH
53449: LD_VAR 0 2
53453: PPUSH
53454: LD_VAR 0 3
53458: PPUSH
53459: LD_VAR 0 4
53463: PPUSH
53464: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53468: LD_VAR 0 1
53472: PPUSH
53473: LD_VAR 0 2
53477: PPUSH
53478: LD_VAR 0 3
53482: PPUSH
53483: CALL_OW 331
// end ;
53487: LD_VAR 0 5
53491: RET
// export function Video ( mode ) ; begin
53492: LD_INT 0
53494: PPUSH
// ingame_video = mode ;
53495: LD_ADDR_OWVAR 52
53499: PUSH
53500: LD_VAR 0 1
53504: ST_TO_ADDR
// interface_hidden = mode ;
53505: LD_ADDR_OWVAR 54
53509: PUSH
53510: LD_VAR 0 1
53514: ST_TO_ADDR
// end ;
53515: LD_VAR 0 2
53519: RET
// export function Join ( array , element ) ; begin
53520: LD_INT 0
53522: PPUSH
// result := Replace ( array , array + 1 , element ) ;
53523: LD_ADDR_VAR 0 3
53527: PUSH
53528: LD_VAR 0 1
53532: PPUSH
53533: LD_VAR 0 1
53537: PUSH
53538: LD_INT 1
53540: PLUS
53541: PPUSH
53542: LD_VAR 0 2
53546: PPUSH
53547: CALL_OW 1
53551: ST_TO_ADDR
// end ;
53552: LD_VAR 0 3
53556: RET
// export function JoinUnion ( array , element ) ; begin
53557: LD_INT 0
53559: PPUSH
// result := array union element ;
53560: LD_ADDR_VAR 0 3
53564: PUSH
53565: LD_VAR 0 1
53569: PUSH
53570: LD_VAR 0 2
53574: UNION
53575: ST_TO_ADDR
// end ;
53576: LD_VAR 0 3
53580: RET
// export function GetBehemoths ( side ) ; begin
53581: LD_INT 0
53583: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
53584: LD_ADDR_VAR 0 2
53588: PUSH
53589: LD_INT 22
53591: PUSH
53592: LD_VAR 0 1
53596: PUSH
53597: EMPTY
53598: LIST
53599: LIST
53600: PUSH
53601: LD_INT 31
53603: PUSH
53604: LD_INT 25
53606: PUSH
53607: EMPTY
53608: LIST
53609: LIST
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PPUSH
53615: CALL_OW 69
53619: ST_TO_ADDR
// end ;
53620: LD_VAR 0 2
53624: RET
// export function Shuffle ( array ) ; var i , index ; begin
53625: LD_INT 0
53627: PPUSH
53628: PPUSH
53629: PPUSH
// result := [ ] ;
53630: LD_ADDR_VAR 0 2
53634: PUSH
53635: EMPTY
53636: ST_TO_ADDR
// if not array then
53637: LD_VAR 0 1
53641: NOT
53642: IFFALSE 53646
// exit ;
53644: GO 53745
// Randomize ;
53646: CALL_OW 10
// for i = array downto 1 do
53650: LD_ADDR_VAR 0 3
53654: PUSH
53655: DOUBLE
53656: LD_VAR 0 1
53660: INC
53661: ST_TO_ADDR
53662: LD_INT 1
53664: PUSH
53665: FOR_DOWNTO
53666: IFFALSE 53743
// begin index := rand ( 1 , array ) ;
53668: LD_ADDR_VAR 0 4
53672: PUSH
53673: LD_INT 1
53675: PPUSH
53676: LD_VAR 0 1
53680: PPUSH
53681: CALL_OW 12
53685: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53686: LD_ADDR_VAR 0 2
53690: PUSH
53691: LD_VAR 0 2
53695: PPUSH
53696: LD_VAR 0 2
53700: PUSH
53701: LD_INT 1
53703: PLUS
53704: PPUSH
53705: LD_VAR 0 1
53709: PUSH
53710: LD_VAR 0 4
53714: ARRAY
53715: PPUSH
53716: CALL_OW 2
53720: ST_TO_ADDR
// array := Delete ( array , index ) ;
53721: LD_ADDR_VAR 0 1
53725: PUSH
53726: LD_VAR 0 1
53730: PPUSH
53731: LD_VAR 0 4
53735: PPUSH
53736: CALL_OW 3
53740: ST_TO_ADDR
// end ;
53741: GO 53665
53743: POP
53744: POP
// end ;
53745: LD_VAR 0 2
53749: RET
// export function GetBaseMaterials ( base ) ; begin
53750: LD_INT 0
53752: PPUSH
// result := [ 0 , 0 , 0 ] ;
53753: LD_ADDR_VAR 0 2
53757: PUSH
53758: LD_INT 0
53760: PUSH
53761: LD_INT 0
53763: PUSH
53764: LD_INT 0
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: LIST
53771: ST_TO_ADDR
// if not base then
53772: LD_VAR 0 1
53776: NOT
53777: IFFALSE 53781
// exit ;
53779: GO 53830
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53781: LD_ADDR_VAR 0 2
53785: PUSH
53786: LD_VAR 0 1
53790: PPUSH
53791: LD_INT 1
53793: PPUSH
53794: CALL_OW 275
53798: PUSH
53799: LD_VAR 0 1
53803: PPUSH
53804: LD_INT 2
53806: PPUSH
53807: CALL_OW 275
53811: PUSH
53812: LD_VAR 0 1
53816: PPUSH
53817: LD_INT 3
53819: PPUSH
53820: CALL_OW 275
53824: PUSH
53825: EMPTY
53826: LIST
53827: LIST
53828: LIST
53829: ST_TO_ADDR
// end ;
53830: LD_VAR 0 2
53834: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53835: LD_INT 0
53837: PPUSH
53838: PPUSH
// result := array ;
53839: LD_ADDR_VAR 0 3
53843: PUSH
53844: LD_VAR 0 1
53848: ST_TO_ADDR
// if size > 0 then
53849: LD_VAR 0 2
53853: PUSH
53854: LD_INT 0
53856: GREATER
53857: IFFALSE 53903
// for i := array downto size do
53859: LD_ADDR_VAR 0 4
53863: PUSH
53864: DOUBLE
53865: LD_VAR 0 1
53869: INC
53870: ST_TO_ADDR
53871: LD_VAR 0 2
53875: PUSH
53876: FOR_DOWNTO
53877: IFFALSE 53901
// result := Delete ( result , result ) ;
53879: LD_ADDR_VAR 0 3
53883: PUSH
53884: LD_VAR 0 3
53888: PPUSH
53889: LD_VAR 0 3
53893: PPUSH
53894: CALL_OW 3
53898: ST_TO_ADDR
53899: GO 53876
53901: POP
53902: POP
// end ;
53903: LD_VAR 0 3
53907: RET
// export function ComExit ( unit ) ; var tmp ; begin
53908: LD_INT 0
53910: PPUSH
53911: PPUSH
// if not IsInUnit ( unit ) then
53912: LD_VAR 0 1
53916: PPUSH
53917: CALL_OW 310
53921: NOT
53922: IFFALSE 53926
// exit ;
53924: GO 53986
// tmp := IsInUnit ( unit ) ;
53926: LD_ADDR_VAR 0 3
53930: PUSH
53931: LD_VAR 0 1
53935: PPUSH
53936: CALL_OW 310
53940: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53941: LD_VAR 0 3
53945: PPUSH
53946: CALL_OW 247
53950: PUSH
53951: LD_INT 2
53953: EQUAL
53954: IFFALSE 53967
// ComExitVehicle ( unit ) else
53956: LD_VAR 0 1
53960: PPUSH
53961: CALL_OW 121
53965: GO 53976
// ComExitBuilding ( unit ) ;
53967: LD_VAR 0 1
53971: PPUSH
53972: CALL_OW 122
// result := tmp ;
53976: LD_ADDR_VAR 0 2
53980: PUSH
53981: LD_VAR 0 3
53985: ST_TO_ADDR
// end ;
53986: LD_VAR 0 2
53990: RET
// export function ResetHc ; begin
53991: LD_INT 0
53993: PPUSH
// InitHc ;
53994: CALL_OW 19
// hc_importance := 0 ;
53998: LD_ADDR_OWVAR 32
54002: PUSH
54003: LD_INT 0
54005: ST_TO_ADDR
// end ;
54006: LD_VAR 0 1
54010: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54011: LD_INT 0
54013: PPUSH
54014: PPUSH
54015: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54016: LD_ADDR_VAR 0 6
54020: PUSH
54021: LD_VAR 0 1
54025: PUSH
54026: LD_VAR 0 3
54030: PLUS
54031: PUSH
54032: LD_INT 2
54034: DIV
54035: ST_TO_ADDR
// if _x < 0 then
54036: LD_VAR 0 6
54040: PUSH
54041: LD_INT 0
54043: LESS
54044: IFFALSE 54061
// _x := _x * - 1 ;
54046: LD_ADDR_VAR 0 6
54050: PUSH
54051: LD_VAR 0 6
54055: PUSH
54056: LD_INT 1
54058: NEG
54059: MUL
54060: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54061: LD_ADDR_VAR 0 7
54065: PUSH
54066: LD_VAR 0 2
54070: PUSH
54071: LD_VAR 0 4
54075: PLUS
54076: PUSH
54077: LD_INT 2
54079: DIV
54080: ST_TO_ADDR
// if _y < 0 then
54081: LD_VAR 0 7
54085: PUSH
54086: LD_INT 0
54088: LESS
54089: IFFALSE 54106
// _y := _y * - 1 ;
54091: LD_ADDR_VAR 0 7
54095: PUSH
54096: LD_VAR 0 7
54100: PUSH
54101: LD_INT 1
54103: NEG
54104: MUL
54105: ST_TO_ADDR
// result := [ _x , _y ] ;
54106: LD_ADDR_VAR 0 5
54110: PUSH
54111: LD_VAR 0 6
54115: PUSH
54116: LD_VAR 0 7
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: ST_TO_ADDR
// end ;
54125: LD_VAR 0 5
54129: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54130: LD_INT 0
54132: PPUSH
54133: PPUSH
54134: PPUSH
54135: PPUSH
// task := GetTaskList ( unit ) ;
54136: LD_ADDR_VAR 0 7
54140: PUSH
54141: LD_VAR 0 1
54145: PPUSH
54146: CALL_OW 437
54150: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54151: LD_VAR 0 7
54155: NOT
54156: PUSH
54157: LD_VAR 0 1
54161: PPUSH
54162: LD_VAR 0 2
54166: PPUSH
54167: CALL_OW 308
54171: NOT
54172: AND
54173: IFFALSE 54177
// exit ;
54175: GO 54295
// if IsInArea ( unit , area ) then
54177: LD_VAR 0 1
54181: PPUSH
54182: LD_VAR 0 2
54186: PPUSH
54187: CALL_OW 308
54191: IFFALSE 54209
// begin ComMoveToArea ( unit , goAway ) ;
54193: LD_VAR 0 1
54197: PPUSH
54198: LD_VAR 0 3
54202: PPUSH
54203: CALL_OW 113
// exit ;
54207: GO 54295
// end ; if task [ 1 ] [ 1 ] <> M then
54209: LD_VAR 0 7
54213: PUSH
54214: LD_INT 1
54216: ARRAY
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PUSH
54222: LD_STRING M
54224: NONEQUAL
54225: IFFALSE 54229
// exit ;
54227: GO 54295
// x := task [ 1 ] [ 2 ] ;
54229: LD_ADDR_VAR 0 5
54233: PUSH
54234: LD_VAR 0 7
54238: PUSH
54239: LD_INT 1
54241: ARRAY
54242: PUSH
54243: LD_INT 2
54245: ARRAY
54246: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54247: LD_ADDR_VAR 0 6
54251: PUSH
54252: LD_VAR 0 7
54256: PUSH
54257: LD_INT 1
54259: ARRAY
54260: PUSH
54261: LD_INT 3
54263: ARRAY
54264: ST_TO_ADDR
// if InArea ( x , y , area ) then
54265: LD_VAR 0 5
54269: PPUSH
54270: LD_VAR 0 6
54274: PPUSH
54275: LD_VAR 0 2
54279: PPUSH
54280: CALL_OW 309
54284: IFFALSE 54295
// ComStop ( unit ) ;
54286: LD_VAR 0 1
54290: PPUSH
54291: CALL_OW 141
// end ;
54295: LD_VAR 0 4
54299: RET
// export function Abs ( value ) ; begin
54300: LD_INT 0
54302: PPUSH
// result := value ;
54303: LD_ADDR_VAR 0 2
54307: PUSH
54308: LD_VAR 0 1
54312: ST_TO_ADDR
// if value < 0 then
54313: LD_VAR 0 1
54317: PUSH
54318: LD_INT 0
54320: LESS
54321: IFFALSE 54338
// result := value * - 1 ;
54323: LD_ADDR_VAR 0 2
54327: PUSH
54328: LD_VAR 0 1
54332: PUSH
54333: LD_INT 1
54335: NEG
54336: MUL
54337: ST_TO_ADDR
// end ;
54338: LD_VAR 0 2
54342: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
54343: LD_INT 0
54345: PPUSH
54346: PPUSH
54347: PPUSH
54348: PPUSH
54349: PPUSH
54350: PPUSH
54351: PPUSH
54352: PPUSH
// if not unit or not building then
54353: LD_VAR 0 1
54357: NOT
54358: PUSH
54359: LD_VAR 0 2
54363: NOT
54364: OR
54365: IFFALSE 54369
// exit ;
54367: GO 54595
// x := GetX ( building ) ;
54369: LD_ADDR_VAR 0 4
54373: PUSH
54374: LD_VAR 0 2
54378: PPUSH
54379: CALL_OW 250
54383: ST_TO_ADDR
// y := GetY ( building ) ;
54384: LD_ADDR_VAR 0 6
54388: PUSH
54389: LD_VAR 0 2
54393: PPUSH
54394: CALL_OW 251
54398: ST_TO_ADDR
// d := GetDir ( building ) ;
54399: LD_ADDR_VAR 0 8
54403: PUSH
54404: LD_VAR 0 2
54408: PPUSH
54409: CALL_OW 254
54413: ST_TO_ADDR
// r := 4 ;
54414: LD_ADDR_VAR 0 9
54418: PUSH
54419: LD_INT 4
54421: ST_TO_ADDR
// for i := 1 to 5 do
54422: LD_ADDR_VAR 0 10
54426: PUSH
54427: DOUBLE
54428: LD_INT 1
54430: DEC
54431: ST_TO_ADDR
54432: LD_INT 5
54434: PUSH
54435: FOR_TO
54436: IFFALSE 54593
// begin _x := ShiftX ( x , d , r + i ) ;
54438: LD_ADDR_VAR 0 5
54442: PUSH
54443: LD_VAR 0 4
54447: PPUSH
54448: LD_VAR 0 8
54452: PPUSH
54453: LD_VAR 0 9
54457: PUSH
54458: LD_VAR 0 10
54462: PLUS
54463: PPUSH
54464: CALL_OW 272
54468: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
54469: LD_ADDR_VAR 0 7
54473: PUSH
54474: LD_VAR 0 6
54478: PPUSH
54479: LD_VAR 0 8
54483: PPUSH
54484: LD_VAR 0 9
54488: PUSH
54489: LD_VAR 0 10
54493: PLUS
54494: PPUSH
54495: CALL_OW 273
54499: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
54500: LD_VAR 0 5
54504: PPUSH
54505: LD_VAR 0 7
54509: PPUSH
54510: CALL_OW 488
54514: PUSH
54515: LD_VAR 0 5
54519: PPUSH
54520: LD_VAR 0 7
54524: PPUSH
54525: CALL_OW 428
54529: PPUSH
54530: CALL_OW 247
54534: PUSH
54535: LD_INT 3
54537: PUSH
54538: LD_INT 2
54540: PUSH
54541: EMPTY
54542: LIST
54543: LIST
54544: IN
54545: NOT
54546: AND
54547: IFFALSE 54591
// begin ComMoveXY ( unit , _x , _y ) ;
54549: LD_VAR 0 1
54553: PPUSH
54554: LD_VAR 0 5
54558: PPUSH
54559: LD_VAR 0 7
54563: PPUSH
54564: CALL_OW 111
// result := [ _x , _y ] ;
54568: LD_ADDR_VAR 0 3
54572: PUSH
54573: LD_VAR 0 5
54577: PUSH
54578: LD_VAR 0 7
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: ST_TO_ADDR
// exit ;
54587: POP
54588: POP
54589: GO 54595
// end ; end ;
54591: GO 54435
54593: POP
54594: POP
// end ; end_of_file
54595: LD_VAR 0 3
54599: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
54600: LD_INT 0
54602: PPUSH
54603: PPUSH
54604: PPUSH
54605: PPUSH
54606: PPUSH
54607: PPUSH
54608: PPUSH
54609: PPUSH
54610: PPUSH
54611: PPUSH
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
54625: PPUSH
54626: PPUSH
54627: PPUSH
54628: PPUSH
54629: PPUSH
54630: PPUSH
54631: PPUSH
54632: PPUSH
54633: PPUSH
54634: PPUSH
54635: PPUSH
// if not list then
54636: LD_VAR 0 1
54640: NOT
54641: IFFALSE 54645
// exit ;
54643: GO 59304
// base := list [ 1 ] ;
54645: LD_ADDR_VAR 0 3
54649: PUSH
54650: LD_VAR 0 1
54654: PUSH
54655: LD_INT 1
54657: ARRAY
54658: ST_TO_ADDR
// group := list [ 2 ] ;
54659: LD_ADDR_VAR 0 4
54663: PUSH
54664: LD_VAR 0 1
54668: PUSH
54669: LD_INT 2
54671: ARRAY
54672: ST_TO_ADDR
// path := list [ 3 ] ;
54673: LD_ADDR_VAR 0 5
54677: PUSH
54678: LD_VAR 0 1
54682: PUSH
54683: LD_INT 3
54685: ARRAY
54686: ST_TO_ADDR
// flags := list [ 4 ] ;
54687: LD_ADDR_VAR 0 6
54691: PUSH
54692: LD_VAR 0 1
54696: PUSH
54697: LD_INT 4
54699: ARRAY
54700: ST_TO_ADDR
// mined := [ ] ;
54701: LD_ADDR_VAR 0 27
54705: PUSH
54706: EMPTY
54707: ST_TO_ADDR
// bombed := [ ] ;
54708: LD_ADDR_VAR 0 28
54712: PUSH
54713: EMPTY
54714: ST_TO_ADDR
// healers := [ ] ;
54715: LD_ADDR_VAR 0 31
54719: PUSH
54720: EMPTY
54721: ST_TO_ADDR
// to_heal := [ ] ;
54722: LD_ADDR_VAR 0 30
54726: PUSH
54727: EMPTY
54728: ST_TO_ADDR
// repairs := [ ] ;
54729: LD_ADDR_VAR 0 33
54733: PUSH
54734: EMPTY
54735: ST_TO_ADDR
// to_repair := [ ] ;
54736: LD_ADDR_VAR 0 32
54740: PUSH
54741: EMPTY
54742: ST_TO_ADDR
// if not group or not path then
54743: LD_VAR 0 4
54747: NOT
54748: PUSH
54749: LD_VAR 0 5
54753: NOT
54754: OR
54755: IFFALSE 54759
// exit ;
54757: GO 59304
// side := GetSide ( group [ 1 ] ) ;
54759: LD_ADDR_VAR 0 35
54763: PUSH
54764: LD_VAR 0 4
54768: PUSH
54769: LD_INT 1
54771: ARRAY
54772: PPUSH
54773: CALL_OW 255
54777: ST_TO_ADDR
// if flags then
54778: LD_VAR 0 6
54782: IFFALSE 54926
// begin f_ignore_area := flags [ 1 ] ;
54784: LD_ADDR_VAR 0 17
54788: PUSH
54789: LD_VAR 0 6
54793: PUSH
54794: LD_INT 1
54796: ARRAY
54797: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
54798: LD_ADDR_VAR 0 18
54802: PUSH
54803: LD_VAR 0 6
54807: PUSH
54808: LD_INT 2
54810: ARRAY
54811: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
54812: LD_ADDR_VAR 0 19
54816: PUSH
54817: LD_VAR 0 6
54821: PUSH
54822: LD_INT 3
54824: ARRAY
54825: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
54826: LD_ADDR_VAR 0 20
54830: PUSH
54831: LD_VAR 0 6
54835: PUSH
54836: LD_INT 4
54838: ARRAY
54839: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
54840: LD_ADDR_VAR 0 21
54844: PUSH
54845: LD_VAR 0 6
54849: PUSH
54850: LD_INT 5
54852: ARRAY
54853: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
54854: LD_ADDR_VAR 0 22
54858: PUSH
54859: LD_VAR 0 6
54863: PUSH
54864: LD_INT 6
54866: ARRAY
54867: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
54868: LD_ADDR_VAR 0 23
54872: PUSH
54873: LD_VAR 0 6
54877: PUSH
54878: LD_INT 7
54880: ARRAY
54881: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
54882: LD_ADDR_VAR 0 24
54886: PUSH
54887: LD_VAR 0 6
54891: PUSH
54892: LD_INT 8
54894: ARRAY
54895: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
54896: LD_ADDR_VAR 0 25
54900: PUSH
54901: LD_VAR 0 6
54905: PUSH
54906: LD_INT 9
54908: ARRAY
54909: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
54910: LD_ADDR_VAR 0 26
54914: PUSH
54915: LD_VAR 0 6
54919: PUSH
54920: LD_INT 10
54922: ARRAY
54923: ST_TO_ADDR
// end else
54924: GO 55006
// begin f_ignore_area := false ;
54926: LD_ADDR_VAR 0 17
54930: PUSH
54931: LD_INT 0
54933: ST_TO_ADDR
// f_capture := false ;
54934: LD_ADDR_VAR 0 18
54938: PUSH
54939: LD_INT 0
54941: ST_TO_ADDR
// f_ignore_civ := false ;
54942: LD_ADDR_VAR 0 19
54946: PUSH
54947: LD_INT 0
54949: ST_TO_ADDR
// f_murder := false ;
54950: LD_ADDR_VAR 0 20
54954: PUSH
54955: LD_INT 0
54957: ST_TO_ADDR
// f_mines := false ;
54958: LD_ADDR_VAR 0 21
54962: PUSH
54963: LD_INT 0
54965: ST_TO_ADDR
// f_repair := false ;
54966: LD_ADDR_VAR 0 22
54970: PUSH
54971: LD_INT 0
54973: ST_TO_ADDR
// f_heal := false ;
54974: LD_ADDR_VAR 0 23
54978: PUSH
54979: LD_INT 0
54981: ST_TO_ADDR
// f_spacetime := false ;
54982: LD_ADDR_VAR 0 24
54986: PUSH
54987: LD_INT 0
54989: ST_TO_ADDR
// f_attack_depot := false ;
54990: LD_ADDR_VAR 0 25
54994: PUSH
54995: LD_INT 0
54997: ST_TO_ADDR
// f_crawl := false ;
54998: LD_ADDR_VAR 0 26
55002: PUSH
55003: LD_INT 0
55005: ST_TO_ADDR
// end ; if f_heal then
55006: LD_VAR 0 23
55010: IFFALSE 55037
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
55012: LD_ADDR_VAR 0 31
55016: PUSH
55017: LD_VAR 0 4
55021: PPUSH
55022: LD_INT 25
55024: PUSH
55025: LD_INT 4
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: PPUSH
55032: CALL_OW 72
55036: ST_TO_ADDR
// if f_repair then
55037: LD_VAR 0 22
55041: IFFALSE 55068
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
55043: LD_ADDR_VAR 0 33
55047: PUSH
55048: LD_VAR 0 4
55052: PPUSH
55053: LD_INT 25
55055: PUSH
55056: LD_INT 3
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: PPUSH
55063: CALL_OW 72
55067: ST_TO_ADDR
// units_path := [ ] ;
55068: LD_ADDR_VAR 0 16
55072: PUSH
55073: EMPTY
55074: ST_TO_ADDR
// for i = 1 to group do
55075: LD_ADDR_VAR 0 7
55079: PUSH
55080: DOUBLE
55081: LD_INT 1
55083: DEC
55084: ST_TO_ADDR
55085: LD_VAR 0 4
55089: PUSH
55090: FOR_TO
55091: IFFALSE 55120
// units_path := Replace ( units_path , i , path ) ;
55093: LD_ADDR_VAR 0 16
55097: PUSH
55098: LD_VAR 0 16
55102: PPUSH
55103: LD_VAR 0 7
55107: PPUSH
55108: LD_VAR 0 5
55112: PPUSH
55113: CALL_OW 1
55117: ST_TO_ADDR
55118: GO 55090
55120: POP
55121: POP
// repeat for i = group downto 1 do
55122: LD_ADDR_VAR 0 7
55126: PUSH
55127: DOUBLE
55128: LD_VAR 0 4
55132: INC
55133: ST_TO_ADDR
55134: LD_INT 1
55136: PUSH
55137: FOR_DOWNTO
55138: IFFALSE 59260
// begin wait ( 5 ) ;
55140: LD_INT 5
55142: PPUSH
55143: CALL_OW 67
// tmp := [ ] ;
55147: LD_ADDR_VAR 0 14
55151: PUSH
55152: EMPTY
55153: ST_TO_ADDR
// attacking := false ;
55154: LD_ADDR_VAR 0 29
55158: PUSH
55159: LD_INT 0
55161: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
55162: LD_VAR 0 4
55166: PUSH
55167: LD_VAR 0 7
55171: ARRAY
55172: PPUSH
55173: CALL_OW 301
55177: PUSH
55178: LD_VAR 0 4
55182: PUSH
55183: LD_VAR 0 7
55187: ARRAY
55188: NOT
55189: OR
55190: IFFALSE 55299
// begin if GetType ( group [ i ] ) = unit_human then
55192: LD_VAR 0 4
55196: PUSH
55197: LD_VAR 0 7
55201: ARRAY
55202: PPUSH
55203: CALL_OW 247
55207: PUSH
55208: LD_INT 1
55210: EQUAL
55211: IFFALSE 55257
// begin to_heal := to_heal diff group [ i ] ;
55213: LD_ADDR_VAR 0 30
55217: PUSH
55218: LD_VAR 0 30
55222: PUSH
55223: LD_VAR 0 4
55227: PUSH
55228: LD_VAR 0 7
55232: ARRAY
55233: DIFF
55234: ST_TO_ADDR
// healers := healers diff group [ i ] ;
55235: LD_ADDR_VAR 0 31
55239: PUSH
55240: LD_VAR 0 31
55244: PUSH
55245: LD_VAR 0 4
55249: PUSH
55250: LD_VAR 0 7
55254: ARRAY
55255: DIFF
55256: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
55257: LD_ADDR_VAR 0 4
55261: PUSH
55262: LD_VAR 0 4
55266: PPUSH
55267: LD_VAR 0 7
55271: PPUSH
55272: CALL_OW 3
55276: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
55277: LD_ADDR_VAR 0 16
55281: PUSH
55282: LD_VAR 0 16
55286: PPUSH
55287: LD_VAR 0 7
55291: PPUSH
55292: CALL_OW 3
55296: ST_TO_ADDR
// continue ;
55297: GO 55137
// end ; if f_repair then
55299: LD_VAR 0 22
55303: IFFALSE 55792
// begin if GetType ( group [ i ] ) = unit_vehicle then
55305: LD_VAR 0 4
55309: PUSH
55310: LD_VAR 0 7
55314: ARRAY
55315: PPUSH
55316: CALL_OW 247
55320: PUSH
55321: LD_INT 2
55323: EQUAL
55324: IFFALSE 55514
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
55326: LD_VAR 0 4
55330: PUSH
55331: LD_VAR 0 7
55335: ARRAY
55336: PPUSH
55337: CALL_OW 256
55341: PUSH
55342: LD_INT 700
55344: LESS
55345: PUSH
55346: LD_VAR 0 4
55350: PUSH
55351: LD_VAR 0 7
55355: ARRAY
55356: PUSH
55357: LD_VAR 0 32
55361: IN
55362: NOT
55363: AND
55364: IFFALSE 55388
// to_repair := to_repair union group [ i ] ;
55366: LD_ADDR_VAR 0 32
55370: PUSH
55371: LD_VAR 0 32
55375: PUSH
55376: LD_VAR 0 4
55380: PUSH
55381: LD_VAR 0 7
55385: ARRAY
55386: UNION
55387: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
55388: LD_VAR 0 4
55392: PUSH
55393: LD_VAR 0 7
55397: ARRAY
55398: PPUSH
55399: CALL_OW 256
55403: PUSH
55404: LD_INT 1000
55406: EQUAL
55407: PUSH
55408: LD_VAR 0 4
55412: PUSH
55413: LD_VAR 0 7
55417: ARRAY
55418: PUSH
55419: LD_VAR 0 32
55423: IN
55424: AND
55425: IFFALSE 55449
// to_repair := to_repair diff group [ i ] ;
55427: LD_ADDR_VAR 0 32
55431: PUSH
55432: LD_VAR 0 32
55436: PUSH
55437: LD_VAR 0 4
55441: PUSH
55442: LD_VAR 0 7
55446: ARRAY
55447: DIFF
55448: ST_TO_ADDR
// if group [ i ] in to_repair then
55449: LD_VAR 0 4
55453: PUSH
55454: LD_VAR 0 7
55458: ARRAY
55459: PUSH
55460: LD_VAR 0 32
55464: IN
55465: IFFALSE 55512
// begin if not IsInArea ( group [ i ] , f_repair ) then
55467: LD_VAR 0 4
55471: PUSH
55472: LD_VAR 0 7
55476: ARRAY
55477: PPUSH
55478: LD_VAR 0 22
55482: PPUSH
55483: CALL_OW 308
55487: NOT
55488: IFFALSE 55510
// ComMoveToArea ( group [ i ] , f_repair ) ;
55490: LD_VAR 0 4
55494: PUSH
55495: LD_VAR 0 7
55499: ARRAY
55500: PPUSH
55501: LD_VAR 0 22
55505: PPUSH
55506: CALL_OW 113
// continue ;
55510: GO 55137
// end ; end else
55512: GO 55792
// if group [ i ] in repairs then
55514: LD_VAR 0 4
55518: PUSH
55519: LD_VAR 0 7
55523: ARRAY
55524: PUSH
55525: LD_VAR 0 33
55529: IN
55530: IFFALSE 55792
// begin if IsInUnit ( group [ i ] ) then
55532: LD_VAR 0 4
55536: PUSH
55537: LD_VAR 0 7
55541: ARRAY
55542: PPUSH
55543: CALL_OW 310
55547: IFFALSE 55615
// begin z := IsInUnit ( group [ i ] ) ;
55549: LD_ADDR_VAR 0 13
55553: PUSH
55554: LD_VAR 0 4
55558: PUSH
55559: LD_VAR 0 7
55563: ARRAY
55564: PPUSH
55565: CALL_OW 310
55569: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
55570: LD_VAR 0 13
55574: PUSH
55575: LD_VAR 0 32
55579: IN
55580: PUSH
55581: LD_VAR 0 13
55585: PPUSH
55586: LD_VAR 0 22
55590: PPUSH
55591: CALL_OW 308
55595: AND
55596: IFFALSE 55613
// ComExitVehicle ( group [ i ] ) ;
55598: LD_VAR 0 4
55602: PUSH
55603: LD_VAR 0 7
55607: ARRAY
55608: PPUSH
55609: CALL_OW 121
// end else
55613: GO 55792
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
55615: LD_ADDR_VAR 0 13
55619: PUSH
55620: LD_VAR 0 4
55624: PPUSH
55625: LD_INT 95
55627: PUSH
55628: LD_VAR 0 22
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: PUSH
55637: LD_INT 58
55639: PUSH
55640: EMPTY
55641: LIST
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: PPUSH
55647: CALL_OW 72
55651: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
55652: LD_VAR 0 4
55656: PUSH
55657: LD_VAR 0 7
55661: ARRAY
55662: PPUSH
55663: CALL_OW 314
55667: NOT
55668: IFFALSE 55790
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
55670: LD_ADDR_VAR 0 10
55674: PUSH
55675: LD_VAR 0 13
55679: PPUSH
55680: LD_VAR 0 4
55684: PUSH
55685: LD_VAR 0 7
55689: ARRAY
55690: PPUSH
55691: CALL_OW 74
55695: ST_TO_ADDR
// if not x then
55696: LD_VAR 0 10
55700: NOT
55701: IFFALSE 55705
// continue ;
55703: GO 55137
// if GetLives ( x ) < 1000 then
55705: LD_VAR 0 10
55709: PPUSH
55710: CALL_OW 256
55714: PUSH
55715: LD_INT 1000
55717: LESS
55718: IFFALSE 55742
// ComRepairVehicle ( group [ i ] , x ) else
55720: LD_VAR 0 4
55724: PUSH
55725: LD_VAR 0 7
55729: ARRAY
55730: PPUSH
55731: LD_VAR 0 10
55735: PPUSH
55736: CALL_OW 129
55740: GO 55790
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
55742: LD_VAR 0 23
55746: PUSH
55747: LD_VAR 0 4
55751: PUSH
55752: LD_VAR 0 7
55756: ARRAY
55757: PPUSH
55758: CALL_OW 256
55762: PUSH
55763: LD_INT 1000
55765: LESS
55766: AND
55767: NOT
55768: IFFALSE 55790
// ComEnterUnit ( group [ i ] , x ) ;
55770: LD_VAR 0 4
55774: PUSH
55775: LD_VAR 0 7
55779: ARRAY
55780: PPUSH
55781: LD_VAR 0 10
55785: PPUSH
55786: CALL_OW 120
// end ; continue ;
55790: GO 55137
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
55792: LD_VAR 0 23
55796: PUSH
55797: LD_VAR 0 4
55801: PUSH
55802: LD_VAR 0 7
55806: ARRAY
55807: PPUSH
55808: CALL_OW 247
55812: PUSH
55813: LD_INT 1
55815: EQUAL
55816: AND
55817: IFFALSE 56295
// begin if group [ i ] in healers then
55819: LD_VAR 0 4
55823: PUSH
55824: LD_VAR 0 7
55828: ARRAY
55829: PUSH
55830: LD_VAR 0 31
55834: IN
55835: IFFALSE 56108
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
55837: LD_VAR 0 4
55841: PUSH
55842: LD_VAR 0 7
55846: ARRAY
55847: PPUSH
55848: LD_VAR 0 23
55852: PPUSH
55853: CALL_OW 308
55857: NOT
55858: PUSH
55859: LD_VAR 0 4
55863: PUSH
55864: LD_VAR 0 7
55868: ARRAY
55869: PPUSH
55870: CALL_OW 314
55874: NOT
55875: AND
55876: IFFALSE 55900
// ComMoveToArea ( group [ i ] , f_heal ) else
55878: LD_VAR 0 4
55882: PUSH
55883: LD_VAR 0 7
55887: ARRAY
55888: PPUSH
55889: LD_VAR 0 23
55893: PPUSH
55894: CALL_OW 113
55898: GO 56106
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
55900: LD_VAR 0 4
55904: PUSH
55905: LD_VAR 0 7
55909: ARRAY
55910: PPUSH
55911: CALL 50849 0 1
55915: PPUSH
55916: CALL_OW 256
55920: PUSH
55921: LD_INT 1000
55923: EQUAL
55924: IFFALSE 55943
// ComStop ( group [ i ] ) else
55926: LD_VAR 0 4
55930: PUSH
55931: LD_VAR 0 7
55935: ARRAY
55936: PPUSH
55937: CALL_OW 141
55941: GO 56106
// if not HasTask ( group [ i ] ) and to_heal then
55943: LD_VAR 0 4
55947: PUSH
55948: LD_VAR 0 7
55952: ARRAY
55953: PPUSH
55954: CALL_OW 314
55958: NOT
55959: PUSH
55960: LD_VAR 0 30
55964: AND
55965: IFFALSE 56106
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
55967: LD_ADDR_VAR 0 13
55971: PUSH
55972: LD_VAR 0 30
55976: PPUSH
55977: LD_INT 3
55979: PUSH
55980: LD_INT 54
55982: PUSH
55983: EMPTY
55984: LIST
55985: PUSH
55986: EMPTY
55987: LIST
55988: LIST
55989: PPUSH
55990: CALL_OW 72
55994: PPUSH
55995: LD_VAR 0 4
55999: PUSH
56000: LD_VAR 0 7
56004: ARRAY
56005: PPUSH
56006: CALL_OW 74
56010: ST_TO_ADDR
// if z then
56011: LD_VAR 0 13
56015: IFFALSE 56106
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
56017: LD_INT 91
56019: PUSH
56020: LD_VAR 0 13
56024: PUSH
56025: LD_INT 10
56027: PUSH
56028: EMPTY
56029: LIST
56030: LIST
56031: LIST
56032: PUSH
56033: LD_INT 81
56035: PUSH
56036: LD_VAR 0 13
56040: PPUSH
56041: CALL_OW 255
56045: PUSH
56046: EMPTY
56047: LIST
56048: LIST
56049: PUSH
56050: EMPTY
56051: LIST
56052: LIST
56053: PPUSH
56054: CALL_OW 69
56058: PUSH
56059: LD_INT 0
56061: EQUAL
56062: IFFALSE 56086
// ComHeal ( group [ i ] , z ) else
56064: LD_VAR 0 4
56068: PUSH
56069: LD_VAR 0 7
56073: ARRAY
56074: PPUSH
56075: LD_VAR 0 13
56079: PPUSH
56080: CALL_OW 128
56084: GO 56106
// ComMoveToArea ( group [ i ] , f_heal ) ;
56086: LD_VAR 0 4
56090: PUSH
56091: LD_VAR 0 7
56095: ARRAY
56096: PPUSH
56097: LD_VAR 0 23
56101: PPUSH
56102: CALL_OW 113
// end ; continue ;
56106: GO 55137
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
56108: LD_VAR 0 4
56112: PUSH
56113: LD_VAR 0 7
56117: ARRAY
56118: PPUSH
56119: CALL_OW 256
56123: PUSH
56124: LD_INT 700
56126: LESS
56127: PUSH
56128: LD_VAR 0 4
56132: PUSH
56133: LD_VAR 0 7
56137: ARRAY
56138: PUSH
56139: LD_VAR 0 30
56143: IN
56144: NOT
56145: AND
56146: IFFALSE 56170
// to_heal := to_heal union group [ i ] ;
56148: LD_ADDR_VAR 0 30
56152: PUSH
56153: LD_VAR 0 30
56157: PUSH
56158: LD_VAR 0 4
56162: PUSH
56163: LD_VAR 0 7
56167: ARRAY
56168: UNION
56169: ST_TO_ADDR
// if group [ i ] in to_heal then
56170: LD_VAR 0 4
56174: PUSH
56175: LD_VAR 0 7
56179: ARRAY
56180: PUSH
56181: LD_VAR 0 30
56185: IN
56186: IFFALSE 56295
// begin if GetLives ( group [ i ] ) = 1000 then
56188: LD_VAR 0 4
56192: PUSH
56193: LD_VAR 0 7
56197: ARRAY
56198: PPUSH
56199: CALL_OW 256
56203: PUSH
56204: LD_INT 1000
56206: EQUAL
56207: IFFALSE 56233
// to_heal := to_heal diff group [ i ] else
56209: LD_ADDR_VAR 0 30
56213: PUSH
56214: LD_VAR 0 30
56218: PUSH
56219: LD_VAR 0 4
56223: PUSH
56224: LD_VAR 0 7
56228: ARRAY
56229: DIFF
56230: ST_TO_ADDR
56231: GO 56295
// begin if not IsInArea ( group [ i ] , to_heal ) then
56233: LD_VAR 0 4
56237: PUSH
56238: LD_VAR 0 7
56242: ARRAY
56243: PPUSH
56244: LD_VAR 0 30
56248: PPUSH
56249: CALL_OW 308
56253: NOT
56254: IFFALSE 56278
// ComMoveToArea ( group [ i ] , f_heal ) else
56256: LD_VAR 0 4
56260: PUSH
56261: LD_VAR 0 7
56265: ARRAY
56266: PPUSH
56267: LD_VAR 0 23
56271: PPUSH
56272: CALL_OW 113
56276: GO 56293
// ComHold ( group [ i ] ) ;
56278: LD_VAR 0 4
56282: PUSH
56283: LD_VAR 0 7
56287: ARRAY
56288: PPUSH
56289: CALL_OW 140
// continue ;
56293: GO 55137
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
56295: LD_VAR 0 4
56299: PUSH
56300: LD_VAR 0 7
56304: ARRAY
56305: PPUSH
56306: LD_INT 10
56308: PPUSH
56309: CALL 49269 0 2
56313: NOT
56314: PUSH
56315: LD_VAR 0 16
56319: PUSH
56320: LD_VAR 0 7
56324: ARRAY
56325: PUSH
56326: EMPTY
56327: EQUAL
56328: NOT
56329: AND
56330: IFFALSE 56596
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
56332: LD_VAR 0 4
56336: PUSH
56337: LD_VAR 0 7
56341: ARRAY
56342: PPUSH
56343: CALL_OW 262
56347: PUSH
56348: LD_INT 1
56350: PUSH
56351: LD_INT 2
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: IN
56358: IFFALSE 56399
// if GetFuel ( group [ i ] ) < 10 then
56360: LD_VAR 0 4
56364: PUSH
56365: LD_VAR 0 7
56369: ARRAY
56370: PPUSH
56371: CALL_OW 261
56375: PUSH
56376: LD_INT 10
56378: LESS
56379: IFFALSE 56399
// SetFuel ( group [ i ] , 12 ) ;
56381: LD_VAR 0 4
56385: PUSH
56386: LD_VAR 0 7
56390: ARRAY
56391: PPUSH
56392: LD_INT 12
56394: PPUSH
56395: CALL_OW 240
// if units_path [ i ] then
56399: LD_VAR 0 16
56403: PUSH
56404: LD_VAR 0 7
56408: ARRAY
56409: IFFALSE 56594
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
56411: LD_VAR 0 4
56415: PUSH
56416: LD_VAR 0 7
56420: ARRAY
56421: PPUSH
56422: LD_VAR 0 16
56426: PUSH
56427: LD_VAR 0 7
56431: ARRAY
56432: PUSH
56433: LD_INT 1
56435: ARRAY
56436: PUSH
56437: LD_INT 1
56439: ARRAY
56440: PPUSH
56441: LD_VAR 0 16
56445: PUSH
56446: LD_VAR 0 7
56450: ARRAY
56451: PUSH
56452: LD_INT 1
56454: ARRAY
56455: PUSH
56456: LD_INT 2
56458: ARRAY
56459: PPUSH
56460: CALL_OW 297
56464: PUSH
56465: LD_INT 6
56467: GREATER
56468: IFFALSE 56543
// begin if not HasTask ( group [ i ] ) then
56470: LD_VAR 0 4
56474: PUSH
56475: LD_VAR 0 7
56479: ARRAY
56480: PPUSH
56481: CALL_OW 314
56485: NOT
56486: IFFALSE 56541
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
56488: LD_VAR 0 4
56492: PUSH
56493: LD_VAR 0 7
56497: ARRAY
56498: PPUSH
56499: LD_VAR 0 16
56503: PUSH
56504: LD_VAR 0 7
56508: ARRAY
56509: PUSH
56510: LD_INT 1
56512: ARRAY
56513: PUSH
56514: LD_INT 1
56516: ARRAY
56517: PPUSH
56518: LD_VAR 0 16
56522: PUSH
56523: LD_VAR 0 7
56527: ARRAY
56528: PUSH
56529: LD_INT 1
56531: ARRAY
56532: PUSH
56533: LD_INT 2
56535: ARRAY
56536: PPUSH
56537: CALL_OW 114
// end else
56541: GO 56594
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
56543: LD_ADDR_VAR 0 15
56547: PUSH
56548: LD_VAR 0 16
56552: PUSH
56553: LD_VAR 0 7
56557: ARRAY
56558: PPUSH
56559: LD_INT 1
56561: PPUSH
56562: CALL_OW 3
56566: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
56567: LD_ADDR_VAR 0 16
56571: PUSH
56572: LD_VAR 0 16
56576: PPUSH
56577: LD_VAR 0 7
56581: PPUSH
56582: LD_VAR 0 15
56586: PPUSH
56587: CALL_OW 1
56591: ST_TO_ADDR
// continue ;
56592: GO 55137
// end ; end ; end else
56594: GO 59258
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
56596: LD_ADDR_VAR 0 14
56600: PUSH
56601: LD_INT 81
56603: PUSH
56604: LD_VAR 0 4
56608: PUSH
56609: LD_VAR 0 7
56613: ARRAY
56614: PPUSH
56615: CALL_OW 255
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: PPUSH
56624: CALL_OW 69
56628: ST_TO_ADDR
// if not tmp then
56629: LD_VAR 0 14
56633: NOT
56634: IFFALSE 56638
// continue ;
56636: GO 55137
// if f_ignore_area then
56638: LD_VAR 0 17
56642: IFFALSE 56730
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
56644: LD_ADDR_VAR 0 15
56648: PUSH
56649: LD_VAR 0 14
56653: PPUSH
56654: LD_INT 3
56656: PUSH
56657: LD_INT 92
56659: PUSH
56660: LD_VAR 0 17
56664: PUSH
56665: LD_INT 1
56667: ARRAY
56668: PUSH
56669: LD_VAR 0 17
56673: PUSH
56674: LD_INT 2
56676: ARRAY
56677: PUSH
56678: LD_VAR 0 17
56682: PUSH
56683: LD_INT 3
56685: ARRAY
56686: PUSH
56687: EMPTY
56688: LIST
56689: LIST
56690: LIST
56691: LIST
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: PPUSH
56697: CALL_OW 72
56701: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
56702: LD_VAR 0 14
56706: PUSH
56707: LD_VAR 0 15
56711: DIFF
56712: IFFALSE 56730
// tmp := tmp diff tmp2 ;
56714: LD_ADDR_VAR 0 14
56718: PUSH
56719: LD_VAR 0 14
56723: PUSH
56724: LD_VAR 0 15
56728: DIFF
56729: ST_TO_ADDR
// end ; if not f_murder then
56730: LD_VAR 0 20
56734: NOT
56735: IFFALSE 56793
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
56737: LD_ADDR_VAR 0 15
56741: PUSH
56742: LD_VAR 0 14
56746: PPUSH
56747: LD_INT 3
56749: PUSH
56750: LD_INT 50
56752: PUSH
56753: EMPTY
56754: LIST
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PPUSH
56760: CALL_OW 72
56764: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
56765: LD_VAR 0 14
56769: PUSH
56770: LD_VAR 0 15
56774: DIFF
56775: IFFALSE 56793
// tmp := tmp diff tmp2 ;
56777: LD_ADDR_VAR 0 14
56781: PUSH
56782: LD_VAR 0 14
56786: PUSH
56787: LD_VAR 0 15
56791: DIFF
56792: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
56793: LD_ADDR_VAR 0 14
56797: PUSH
56798: LD_VAR 0 4
56802: PUSH
56803: LD_VAR 0 7
56807: ARRAY
56808: PPUSH
56809: LD_VAR 0 14
56813: PPUSH
56814: LD_INT 1
56816: PPUSH
56817: LD_INT 1
56819: PPUSH
56820: CALL 22912 0 4
56824: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
56825: LD_VAR 0 4
56829: PUSH
56830: LD_VAR 0 7
56834: ARRAY
56835: PPUSH
56836: CALL_OW 257
56840: PUSH
56841: LD_INT 1
56843: EQUAL
56844: IFFALSE 57292
// begin if WantPlant ( group [ i ] ) then
56846: LD_VAR 0 4
56850: PUSH
56851: LD_VAR 0 7
56855: ARRAY
56856: PPUSH
56857: CALL 22413 0 1
56861: IFFALSE 56865
// continue ;
56863: GO 55137
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
56865: LD_VAR 0 18
56869: PUSH
56870: LD_VAR 0 4
56874: PUSH
56875: LD_VAR 0 7
56879: ARRAY
56880: PPUSH
56881: CALL_OW 310
56885: NOT
56886: AND
56887: PUSH
56888: LD_VAR 0 14
56892: PUSH
56893: LD_INT 1
56895: ARRAY
56896: PUSH
56897: LD_VAR 0 14
56901: PPUSH
56902: LD_INT 21
56904: PUSH
56905: LD_INT 2
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: LD_INT 58
56914: PUSH
56915: EMPTY
56916: LIST
56917: PUSH
56918: EMPTY
56919: LIST
56920: LIST
56921: PPUSH
56922: CALL_OW 72
56926: IN
56927: AND
56928: IFFALSE 56964
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
56930: LD_VAR 0 4
56934: PUSH
56935: LD_VAR 0 7
56939: ARRAY
56940: PPUSH
56941: LD_VAR 0 14
56945: PUSH
56946: LD_INT 1
56948: ARRAY
56949: PPUSH
56950: CALL_OW 120
// attacking := true ;
56954: LD_ADDR_VAR 0 29
56958: PUSH
56959: LD_INT 1
56961: ST_TO_ADDR
// continue ;
56962: GO 55137
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
56964: LD_VAR 0 26
56968: PUSH
56969: LD_VAR 0 4
56973: PUSH
56974: LD_VAR 0 7
56978: ARRAY
56979: PPUSH
56980: CALL_OW 257
56984: PUSH
56985: LD_INT 1
56987: EQUAL
56988: AND
56989: PUSH
56990: LD_VAR 0 4
56994: PUSH
56995: LD_VAR 0 7
56999: ARRAY
57000: PPUSH
57001: CALL_OW 256
57005: PUSH
57006: LD_INT 800
57008: LESS
57009: AND
57010: PUSH
57011: LD_VAR 0 4
57015: PUSH
57016: LD_VAR 0 7
57020: ARRAY
57021: PPUSH
57022: CALL_OW 318
57026: NOT
57027: AND
57028: IFFALSE 57045
// ComCrawl ( group [ i ] ) ;
57030: LD_VAR 0 4
57034: PUSH
57035: LD_VAR 0 7
57039: ARRAY
57040: PPUSH
57041: CALL_OW 137
// if f_mines then
57045: LD_VAR 0 21
57049: IFFALSE 57292
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
57051: LD_VAR 0 14
57055: PUSH
57056: LD_INT 1
57058: ARRAY
57059: PPUSH
57060: CALL_OW 247
57064: PUSH
57065: LD_INT 3
57067: EQUAL
57068: PUSH
57069: LD_VAR 0 14
57073: PUSH
57074: LD_INT 1
57076: ARRAY
57077: PUSH
57078: LD_VAR 0 27
57082: IN
57083: NOT
57084: AND
57085: IFFALSE 57292
// begin x := GetX ( tmp [ 1 ] ) ;
57087: LD_ADDR_VAR 0 10
57091: PUSH
57092: LD_VAR 0 14
57096: PUSH
57097: LD_INT 1
57099: ARRAY
57100: PPUSH
57101: CALL_OW 250
57105: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
57106: LD_ADDR_VAR 0 11
57110: PUSH
57111: LD_VAR 0 14
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: PPUSH
57120: CALL_OW 251
57124: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
57125: LD_ADDR_VAR 0 12
57129: PUSH
57130: LD_VAR 0 4
57134: PUSH
57135: LD_VAR 0 7
57139: ARRAY
57140: PPUSH
57141: CALL 49354 0 1
57145: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
57146: LD_VAR 0 4
57150: PUSH
57151: LD_VAR 0 7
57155: ARRAY
57156: PPUSH
57157: LD_VAR 0 10
57161: PPUSH
57162: LD_VAR 0 11
57166: PPUSH
57167: LD_VAR 0 14
57171: PUSH
57172: LD_INT 1
57174: ARRAY
57175: PPUSH
57176: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
57180: LD_VAR 0 4
57184: PUSH
57185: LD_VAR 0 7
57189: ARRAY
57190: PPUSH
57191: LD_VAR 0 10
57195: PPUSH
57196: LD_VAR 0 12
57200: PPUSH
57201: LD_INT 7
57203: PPUSH
57204: CALL_OW 272
57208: PPUSH
57209: LD_VAR 0 11
57213: PPUSH
57214: LD_VAR 0 12
57218: PPUSH
57219: LD_INT 7
57221: PPUSH
57222: CALL_OW 273
57226: PPUSH
57227: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
57231: LD_VAR 0 4
57235: PUSH
57236: LD_VAR 0 7
57240: ARRAY
57241: PPUSH
57242: LD_INT 71
57244: PPUSH
57245: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
57249: LD_ADDR_VAR 0 27
57253: PUSH
57254: LD_VAR 0 27
57258: PPUSH
57259: LD_VAR 0 27
57263: PUSH
57264: LD_INT 1
57266: PLUS
57267: PPUSH
57268: LD_VAR 0 14
57272: PUSH
57273: LD_INT 1
57275: ARRAY
57276: PPUSH
57277: CALL_OW 1
57281: ST_TO_ADDR
// attacking := true ;
57282: LD_ADDR_VAR 0 29
57286: PUSH
57287: LD_INT 1
57289: ST_TO_ADDR
// continue ;
57290: GO 55137
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
57292: LD_VAR 0 4
57296: PUSH
57297: LD_VAR 0 7
57301: ARRAY
57302: PPUSH
57303: CALL_OW 257
57307: PUSH
57308: LD_INT 17
57310: EQUAL
57311: PUSH
57312: LD_VAR 0 4
57316: PUSH
57317: LD_VAR 0 7
57321: ARRAY
57322: PPUSH
57323: CALL_OW 110
57327: PUSH
57328: LD_INT 71
57330: EQUAL
57331: NOT
57332: AND
57333: IFFALSE 57479
// begin attacking := false ;
57335: LD_ADDR_VAR 0 29
57339: PUSH
57340: LD_INT 0
57342: ST_TO_ADDR
// k := 5 ;
57343: LD_ADDR_VAR 0 9
57347: PUSH
57348: LD_INT 5
57350: ST_TO_ADDR
// if tmp < k then
57351: LD_VAR 0 14
57355: PUSH
57356: LD_VAR 0 9
57360: LESS
57361: IFFALSE 57373
// k := tmp ;
57363: LD_ADDR_VAR 0 9
57367: PUSH
57368: LD_VAR 0 14
57372: ST_TO_ADDR
// for j = 1 to k do
57373: LD_ADDR_VAR 0 8
57377: PUSH
57378: DOUBLE
57379: LD_INT 1
57381: DEC
57382: ST_TO_ADDR
57383: LD_VAR 0 9
57387: PUSH
57388: FOR_TO
57389: IFFALSE 57477
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
57391: LD_VAR 0 14
57395: PUSH
57396: LD_VAR 0 8
57400: ARRAY
57401: PUSH
57402: LD_VAR 0 14
57406: PPUSH
57407: LD_INT 58
57409: PUSH
57410: EMPTY
57411: LIST
57412: PPUSH
57413: CALL_OW 72
57417: IN
57418: NOT
57419: IFFALSE 57475
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
57421: LD_VAR 0 4
57425: PUSH
57426: LD_VAR 0 7
57430: ARRAY
57431: PPUSH
57432: LD_VAR 0 14
57436: PUSH
57437: LD_VAR 0 8
57441: ARRAY
57442: PPUSH
57443: CALL_OW 115
// attacking := true ;
57447: LD_ADDR_VAR 0 29
57451: PUSH
57452: LD_INT 1
57454: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
57455: LD_VAR 0 4
57459: PUSH
57460: LD_VAR 0 7
57464: ARRAY
57465: PPUSH
57466: LD_INT 71
57468: PPUSH
57469: CALL_OW 109
// continue ;
57473: GO 57388
// end ; end ;
57475: GO 57388
57477: POP
57478: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
57479: LD_VAR 0 4
57483: PUSH
57484: LD_VAR 0 7
57488: ARRAY
57489: PPUSH
57490: CALL_OW 257
57494: PUSH
57495: LD_INT 8
57497: EQUAL
57498: PUSH
57499: LD_VAR 0 4
57503: PUSH
57504: LD_VAR 0 7
57508: ARRAY
57509: PPUSH
57510: CALL_OW 264
57514: PUSH
57515: LD_INT 28
57517: PUSH
57518: LD_INT 45
57520: PUSH
57521: LD_INT 7
57523: PUSH
57524: LD_INT 47
57526: PUSH
57527: EMPTY
57528: LIST
57529: LIST
57530: LIST
57531: LIST
57532: IN
57533: OR
57534: IFFALSE 57790
// begin attacking := false ;
57536: LD_ADDR_VAR 0 29
57540: PUSH
57541: LD_INT 0
57543: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
57544: LD_VAR 0 14
57548: PUSH
57549: LD_INT 1
57551: ARRAY
57552: PPUSH
57553: CALL_OW 266
57557: PUSH
57558: LD_INT 32
57560: PUSH
57561: LD_INT 31
57563: PUSH
57564: LD_INT 33
57566: PUSH
57567: LD_INT 4
57569: PUSH
57570: LD_INT 5
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: LIST
57577: LIST
57578: LIST
57579: IN
57580: IFFALSE 57766
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
57582: LD_ADDR_VAR 0 9
57586: PUSH
57587: LD_VAR 0 14
57591: PUSH
57592: LD_INT 1
57594: ARRAY
57595: PPUSH
57596: CALL_OW 266
57600: PPUSH
57601: LD_VAR 0 14
57605: PUSH
57606: LD_INT 1
57608: ARRAY
57609: PPUSH
57610: CALL_OW 250
57614: PPUSH
57615: LD_VAR 0 14
57619: PUSH
57620: LD_INT 1
57622: ARRAY
57623: PPUSH
57624: CALL_OW 251
57628: PPUSH
57629: LD_VAR 0 14
57633: PUSH
57634: LD_INT 1
57636: ARRAY
57637: PPUSH
57638: CALL_OW 254
57642: PPUSH
57643: LD_VAR 0 14
57647: PUSH
57648: LD_INT 1
57650: ARRAY
57651: PPUSH
57652: CALL_OW 248
57656: PPUSH
57657: LD_INT 0
57659: PPUSH
57660: CALL 30724 0 6
57664: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
57665: LD_ADDR_VAR 0 8
57669: PUSH
57670: LD_VAR 0 4
57674: PUSH
57675: LD_VAR 0 7
57679: ARRAY
57680: PPUSH
57681: LD_VAR 0 9
57685: PPUSH
57686: CALL 49394 0 2
57690: ST_TO_ADDR
// if j then
57691: LD_VAR 0 8
57695: IFFALSE 57764
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
57697: LD_VAR 0 8
57701: PUSH
57702: LD_INT 1
57704: ARRAY
57705: PPUSH
57706: LD_VAR 0 8
57710: PUSH
57711: LD_INT 2
57713: ARRAY
57714: PPUSH
57715: CALL_OW 488
57719: IFFALSE 57764
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
57721: LD_VAR 0 4
57725: PUSH
57726: LD_VAR 0 7
57730: ARRAY
57731: PPUSH
57732: LD_VAR 0 8
57736: PUSH
57737: LD_INT 1
57739: ARRAY
57740: PPUSH
57741: LD_VAR 0 8
57745: PUSH
57746: LD_INT 2
57748: ARRAY
57749: PPUSH
57750: CALL_OW 116
// attacking := true ;
57754: LD_ADDR_VAR 0 29
57758: PUSH
57759: LD_INT 1
57761: ST_TO_ADDR
// continue ;
57762: GO 55137
// end ; end else
57764: GO 57790
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
57766: LD_VAR 0 4
57770: PUSH
57771: LD_VAR 0 7
57775: ARRAY
57776: PPUSH
57777: LD_VAR 0 14
57781: PUSH
57782: LD_INT 1
57784: ARRAY
57785: PPUSH
57786: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
57790: LD_VAR 0 4
57794: PUSH
57795: LD_VAR 0 7
57799: ARRAY
57800: PPUSH
57801: CALL_OW 265
57805: PUSH
57806: LD_INT 11
57808: EQUAL
57809: IFFALSE 58087
// begin k := 10 ;
57811: LD_ADDR_VAR 0 9
57815: PUSH
57816: LD_INT 10
57818: ST_TO_ADDR
// x := 0 ;
57819: LD_ADDR_VAR 0 10
57823: PUSH
57824: LD_INT 0
57826: ST_TO_ADDR
// if tmp < k then
57827: LD_VAR 0 14
57831: PUSH
57832: LD_VAR 0 9
57836: LESS
57837: IFFALSE 57849
// k := tmp ;
57839: LD_ADDR_VAR 0 9
57843: PUSH
57844: LD_VAR 0 14
57848: ST_TO_ADDR
// for j = k downto 1 do
57849: LD_ADDR_VAR 0 8
57853: PUSH
57854: DOUBLE
57855: LD_VAR 0 9
57859: INC
57860: ST_TO_ADDR
57861: LD_INT 1
57863: PUSH
57864: FOR_DOWNTO
57865: IFFALSE 57940
// begin if GetType ( tmp [ j ] ) = unit_human then
57867: LD_VAR 0 14
57871: PUSH
57872: LD_VAR 0 8
57876: ARRAY
57877: PPUSH
57878: CALL_OW 247
57882: PUSH
57883: LD_INT 1
57885: EQUAL
57886: IFFALSE 57938
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
57888: LD_VAR 0 4
57892: PUSH
57893: LD_VAR 0 7
57897: ARRAY
57898: PPUSH
57899: LD_VAR 0 14
57903: PUSH
57904: LD_VAR 0 8
57908: ARRAY
57909: PPUSH
57910: CALL 49665 0 2
// x := tmp [ j ] ;
57914: LD_ADDR_VAR 0 10
57918: PUSH
57919: LD_VAR 0 14
57923: PUSH
57924: LD_VAR 0 8
57928: ARRAY
57929: ST_TO_ADDR
// attacking := true ;
57930: LD_ADDR_VAR 0 29
57934: PUSH
57935: LD_INT 1
57937: ST_TO_ADDR
// end ; end ;
57938: GO 57864
57940: POP
57941: POP
// if not x then
57942: LD_VAR 0 10
57946: NOT
57947: IFFALSE 58087
// begin attacking := true ;
57949: LD_ADDR_VAR 0 29
57953: PUSH
57954: LD_INT 1
57956: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
57957: LD_VAR 0 4
57961: PUSH
57962: LD_VAR 0 7
57966: ARRAY
57967: PPUSH
57968: CALL_OW 250
57972: PPUSH
57973: LD_VAR 0 4
57977: PUSH
57978: LD_VAR 0 7
57982: ARRAY
57983: PPUSH
57984: CALL_OW 251
57988: PPUSH
57989: CALL_OW 546
57993: PUSH
57994: LD_INT 2
57996: ARRAY
57997: PUSH
57998: LD_VAR 0 14
58002: PUSH
58003: LD_INT 1
58005: ARRAY
58006: PPUSH
58007: CALL_OW 250
58011: PPUSH
58012: LD_VAR 0 14
58016: PUSH
58017: LD_INT 1
58019: ARRAY
58020: PPUSH
58021: CALL_OW 251
58025: PPUSH
58026: CALL_OW 546
58030: PUSH
58031: LD_INT 2
58033: ARRAY
58034: EQUAL
58035: IFFALSE 58063
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
58037: LD_VAR 0 4
58041: PUSH
58042: LD_VAR 0 7
58046: ARRAY
58047: PPUSH
58048: LD_VAR 0 14
58052: PUSH
58053: LD_INT 1
58055: ARRAY
58056: PPUSH
58057: CALL 49665 0 2
58061: GO 58087
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58063: LD_VAR 0 4
58067: PUSH
58068: LD_VAR 0 7
58072: ARRAY
58073: PPUSH
58074: LD_VAR 0 14
58078: PUSH
58079: LD_INT 1
58081: ARRAY
58082: PPUSH
58083: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
58087: LD_VAR 0 4
58091: PUSH
58092: LD_VAR 0 7
58096: ARRAY
58097: PPUSH
58098: CALL_OW 264
58102: PUSH
58103: LD_INT 29
58105: EQUAL
58106: IFFALSE 58472
// begin if WantsToAttack ( group [ i ] ) in bombed then
58108: LD_VAR 0 4
58112: PUSH
58113: LD_VAR 0 7
58117: ARRAY
58118: PPUSH
58119: CALL_OW 319
58123: PUSH
58124: LD_VAR 0 28
58128: IN
58129: IFFALSE 58133
// continue ;
58131: GO 55137
// k := 8 ;
58133: LD_ADDR_VAR 0 9
58137: PUSH
58138: LD_INT 8
58140: ST_TO_ADDR
// x := 0 ;
58141: LD_ADDR_VAR 0 10
58145: PUSH
58146: LD_INT 0
58148: ST_TO_ADDR
// if tmp < k then
58149: LD_VAR 0 14
58153: PUSH
58154: LD_VAR 0 9
58158: LESS
58159: IFFALSE 58171
// k := tmp ;
58161: LD_ADDR_VAR 0 9
58165: PUSH
58166: LD_VAR 0 14
58170: ST_TO_ADDR
// for j = 1 to k do
58171: LD_ADDR_VAR 0 8
58175: PUSH
58176: DOUBLE
58177: LD_INT 1
58179: DEC
58180: ST_TO_ADDR
58181: LD_VAR 0 9
58185: PUSH
58186: FOR_TO
58187: IFFALSE 58319
// begin if GetType ( tmp [ j ] ) = unit_building then
58189: LD_VAR 0 14
58193: PUSH
58194: LD_VAR 0 8
58198: ARRAY
58199: PPUSH
58200: CALL_OW 247
58204: PUSH
58205: LD_INT 3
58207: EQUAL
58208: IFFALSE 58317
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
58210: LD_VAR 0 14
58214: PUSH
58215: LD_VAR 0 8
58219: ARRAY
58220: PUSH
58221: LD_VAR 0 28
58225: IN
58226: NOT
58227: PUSH
58228: LD_VAR 0 14
58232: PUSH
58233: LD_VAR 0 8
58237: ARRAY
58238: PPUSH
58239: CALL_OW 313
58243: AND
58244: IFFALSE 58317
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
58246: LD_VAR 0 4
58250: PUSH
58251: LD_VAR 0 7
58255: ARRAY
58256: PPUSH
58257: LD_VAR 0 14
58261: PUSH
58262: LD_VAR 0 8
58266: ARRAY
58267: PPUSH
58268: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
58272: LD_ADDR_VAR 0 28
58276: PUSH
58277: LD_VAR 0 28
58281: PPUSH
58282: LD_VAR 0 28
58286: PUSH
58287: LD_INT 1
58289: PLUS
58290: PPUSH
58291: LD_VAR 0 14
58295: PUSH
58296: LD_VAR 0 8
58300: ARRAY
58301: PPUSH
58302: CALL_OW 1
58306: ST_TO_ADDR
// attacking := true ;
58307: LD_ADDR_VAR 0 29
58311: PUSH
58312: LD_INT 1
58314: ST_TO_ADDR
// break ;
58315: GO 58319
// end ; end ;
58317: GO 58186
58319: POP
58320: POP
// if not attacking and f_attack_depot then
58321: LD_VAR 0 29
58325: NOT
58326: PUSH
58327: LD_VAR 0 25
58331: AND
58332: IFFALSE 58427
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58334: LD_ADDR_VAR 0 13
58338: PUSH
58339: LD_VAR 0 14
58343: PPUSH
58344: LD_INT 2
58346: PUSH
58347: LD_INT 30
58349: PUSH
58350: LD_INT 0
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: PUSH
58357: LD_INT 30
58359: PUSH
58360: LD_INT 1
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: LIST
58371: PPUSH
58372: CALL_OW 72
58376: ST_TO_ADDR
// if z then
58377: LD_VAR 0 13
58381: IFFALSE 58427
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
58383: LD_VAR 0 4
58387: PUSH
58388: LD_VAR 0 7
58392: ARRAY
58393: PPUSH
58394: LD_VAR 0 13
58398: PPUSH
58399: LD_VAR 0 4
58403: PUSH
58404: LD_VAR 0 7
58408: ARRAY
58409: PPUSH
58410: CALL_OW 74
58414: PPUSH
58415: CALL_OW 115
// attacking := true ;
58419: LD_ADDR_VAR 0 29
58423: PUSH
58424: LD_INT 1
58426: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
58427: LD_VAR 0 4
58431: PUSH
58432: LD_VAR 0 7
58436: ARRAY
58437: PPUSH
58438: CALL_OW 256
58442: PUSH
58443: LD_INT 500
58445: LESS
58446: IFFALSE 58472
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58448: LD_VAR 0 4
58452: PUSH
58453: LD_VAR 0 7
58457: ARRAY
58458: PPUSH
58459: LD_VAR 0 14
58463: PUSH
58464: LD_INT 1
58466: ARRAY
58467: PPUSH
58468: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
58472: LD_VAR 0 4
58476: PUSH
58477: LD_VAR 0 7
58481: ARRAY
58482: PPUSH
58483: CALL_OW 264
58487: PUSH
58488: LD_INT 49
58490: EQUAL
58491: IFFALSE 58612
// begin if not HasTask ( group [ i ] ) then
58493: LD_VAR 0 4
58497: PUSH
58498: LD_VAR 0 7
58502: ARRAY
58503: PPUSH
58504: CALL_OW 314
58508: NOT
58509: IFFALSE 58612
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
58511: LD_ADDR_VAR 0 9
58515: PUSH
58516: LD_INT 81
58518: PUSH
58519: LD_VAR 0 4
58523: PUSH
58524: LD_VAR 0 7
58528: ARRAY
58529: PPUSH
58530: CALL_OW 255
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PPUSH
58539: CALL_OW 69
58543: PPUSH
58544: LD_VAR 0 4
58548: PUSH
58549: LD_VAR 0 7
58553: ARRAY
58554: PPUSH
58555: CALL_OW 74
58559: ST_TO_ADDR
// if k then
58560: LD_VAR 0 9
58564: IFFALSE 58612
// if GetDistUnits ( group [ i ] , k ) > 10 then
58566: LD_VAR 0 4
58570: PUSH
58571: LD_VAR 0 7
58575: ARRAY
58576: PPUSH
58577: LD_VAR 0 9
58581: PPUSH
58582: CALL_OW 296
58586: PUSH
58587: LD_INT 10
58589: GREATER
58590: IFFALSE 58612
// ComMoveUnit ( group [ i ] , k ) ;
58592: LD_VAR 0 4
58596: PUSH
58597: LD_VAR 0 7
58601: ARRAY
58602: PPUSH
58603: LD_VAR 0 9
58607: PPUSH
58608: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
58612: LD_VAR 0 4
58616: PUSH
58617: LD_VAR 0 7
58621: ARRAY
58622: PPUSH
58623: CALL_OW 256
58627: PUSH
58628: LD_INT 250
58630: LESS
58631: PUSH
58632: LD_VAR 0 4
58636: PUSH
58637: LD_VAR 0 7
58641: ARRAY
58642: PUSH
58643: LD_INT 21
58645: PUSH
58646: LD_INT 2
58648: PUSH
58649: EMPTY
58650: LIST
58651: LIST
58652: PUSH
58653: LD_INT 23
58655: PUSH
58656: LD_INT 2
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PPUSH
58667: CALL_OW 69
58671: IN
58672: AND
58673: IFFALSE 58798
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
58675: LD_ADDR_VAR 0 9
58679: PUSH
58680: LD_OWVAR 3
58684: PUSH
58685: LD_VAR 0 4
58689: PUSH
58690: LD_VAR 0 7
58694: ARRAY
58695: DIFF
58696: PPUSH
58697: LD_VAR 0 4
58701: PUSH
58702: LD_VAR 0 7
58706: ARRAY
58707: PPUSH
58708: CALL_OW 74
58712: ST_TO_ADDR
// if not k then
58713: LD_VAR 0 9
58717: NOT
58718: IFFALSE 58722
// continue ;
58720: GO 55137
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
58722: LD_VAR 0 9
58726: PUSH
58727: LD_INT 81
58729: PUSH
58730: LD_VAR 0 4
58734: PUSH
58735: LD_VAR 0 7
58739: ARRAY
58740: PPUSH
58741: CALL_OW 255
58745: PUSH
58746: EMPTY
58747: LIST
58748: LIST
58749: PPUSH
58750: CALL_OW 69
58754: IN
58755: PUSH
58756: LD_VAR 0 9
58760: PPUSH
58761: LD_VAR 0 4
58765: PUSH
58766: LD_VAR 0 7
58770: ARRAY
58771: PPUSH
58772: CALL_OW 296
58776: PUSH
58777: LD_INT 5
58779: LESS
58780: AND
58781: IFFALSE 58798
// ComAutodestruct ( group [ i ] ) ;
58783: LD_VAR 0 4
58787: PUSH
58788: LD_VAR 0 7
58792: ARRAY
58793: PPUSH
58794: CALL 49563 0 1
// end ; if f_attack_depot then
58798: LD_VAR 0 25
58802: IFFALSE 58914
// begin k := 6 ;
58804: LD_ADDR_VAR 0 9
58808: PUSH
58809: LD_INT 6
58811: ST_TO_ADDR
// if tmp < k then
58812: LD_VAR 0 14
58816: PUSH
58817: LD_VAR 0 9
58821: LESS
58822: IFFALSE 58834
// k := tmp ;
58824: LD_ADDR_VAR 0 9
58828: PUSH
58829: LD_VAR 0 14
58833: ST_TO_ADDR
// for j = 1 to k do
58834: LD_ADDR_VAR 0 8
58838: PUSH
58839: DOUBLE
58840: LD_INT 1
58842: DEC
58843: ST_TO_ADDR
58844: LD_VAR 0 9
58848: PUSH
58849: FOR_TO
58850: IFFALSE 58912
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
58852: LD_VAR 0 8
58856: PPUSH
58857: CALL_OW 266
58861: PUSH
58862: LD_INT 0
58864: PUSH
58865: LD_INT 1
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: IN
58872: IFFALSE 58910
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
58874: LD_VAR 0 4
58878: PUSH
58879: LD_VAR 0 7
58883: ARRAY
58884: PPUSH
58885: LD_VAR 0 14
58889: PUSH
58890: LD_VAR 0 8
58894: ARRAY
58895: PPUSH
58896: CALL_OW 115
// attacking := true ;
58900: LD_ADDR_VAR 0 29
58904: PUSH
58905: LD_INT 1
58907: ST_TO_ADDR
// break ;
58908: GO 58912
// end ;
58910: GO 58849
58912: POP
58913: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
58914: LD_VAR 0 4
58918: PUSH
58919: LD_VAR 0 7
58923: ARRAY
58924: PPUSH
58925: CALL_OW 302
58929: PUSH
58930: LD_VAR 0 29
58934: NOT
58935: AND
58936: IFFALSE 59258
// begin if GetTag ( group [ i ] ) = 71 then
58938: LD_VAR 0 4
58942: PUSH
58943: LD_VAR 0 7
58947: ARRAY
58948: PPUSH
58949: CALL_OW 110
58953: PUSH
58954: LD_INT 71
58956: EQUAL
58957: IFFALSE 58998
// begin if HasTask ( group [ i ] ) then
58959: LD_VAR 0 4
58963: PUSH
58964: LD_VAR 0 7
58968: ARRAY
58969: PPUSH
58970: CALL_OW 314
58974: IFFALSE 58980
// continue else
58976: GO 55137
58978: GO 58998
// SetTag ( group [ i ] , 0 ) ;
58980: LD_VAR 0 4
58984: PUSH
58985: LD_VAR 0 7
58989: ARRAY
58990: PPUSH
58991: LD_INT 0
58993: PPUSH
58994: CALL_OW 109
// end ; k := 8 ;
58998: LD_ADDR_VAR 0 9
59002: PUSH
59003: LD_INT 8
59005: ST_TO_ADDR
// x := 0 ;
59006: LD_ADDR_VAR 0 10
59010: PUSH
59011: LD_INT 0
59013: ST_TO_ADDR
// if tmp < k then
59014: LD_VAR 0 14
59018: PUSH
59019: LD_VAR 0 9
59023: LESS
59024: IFFALSE 59036
// k := tmp ;
59026: LD_ADDR_VAR 0 9
59030: PUSH
59031: LD_VAR 0 14
59035: ST_TO_ADDR
// for j = 1 to k do
59036: LD_ADDR_VAR 0 8
59040: PUSH
59041: DOUBLE
59042: LD_INT 1
59044: DEC
59045: ST_TO_ADDR
59046: LD_VAR 0 9
59050: PUSH
59051: FOR_TO
59052: IFFALSE 59150
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
59054: LD_VAR 0 14
59058: PUSH
59059: LD_VAR 0 8
59063: ARRAY
59064: PPUSH
59065: CALL_OW 247
59069: PUSH
59070: LD_INT 1
59072: EQUAL
59073: PUSH
59074: LD_VAR 0 14
59078: PUSH
59079: LD_VAR 0 8
59083: ARRAY
59084: PPUSH
59085: CALL_OW 256
59089: PUSH
59090: LD_INT 250
59092: LESS
59093: PUSH
59094: LD_VAR 0 20
59098: AND
59099: PUSH
59100: LD_VAR 0 20
59104: NOT
59105: PUSH
59106: LD_VAR 0 14
59110: PUSH
59111: LD_VAR 0 8
59115: ARRAY
59116: PPUSH
59117: CALL_OW 256
59121: PUSH
59122: LD_INT 250
59124: GREATEREQUAL
59125: AND
59126: OR
59127: AND
59128: IFFALSE 59148
// begin x := tmp [ j ] ;
59130: LD_ADDR_VAR 0 10
59134: PUSH
59135: LD_VAR 0 14
59139: PUSH
59140: LD_VAR 0 8
59144: ARRAY
59145: ST_TO_ADDR
// break ;
59146: GO 59150
// end ;
59148: GO 59051
59150: POP
59151: POP
// if x then
59152: LD_VAR 0 10
59156: IFFALSE 59180
// ComAttackUnit ( group [ i ] , x ) else
59158: LD_VAR 0 4
59162: PUSH
59163: LD_VAR 0 7
59167: ARRAY
59168: PPUSH
59169: LD_VAR 0 10
59173: PPUSH
59174: CALL_OW 115
59178: GO 59204
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
59180: LD_VAR 0 4
59184: PUSH
59185: LD_VAR 0 7
59189: ARRAY
59190: PPUSH
59191: LD_VAR 0 14
59195: PUSH
59196: LD_INT 1
59198: ARRAY
59199: PPUSH
59200: CALL_OW 115
// if not HasTask ( group [ i ] ) then
59204: LD_VAR 0 4
59208: PUSH
59209: LD_VAR 0 7
59213: ARRAY
59214: PPUSH
59215: CALL_OW 314
59219: NOT
59220: IFFALSE 59258
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
59222: LD_VAR 0 4
59226: PUSH
59227: LD_VAR 0 7
59231: ARRAY
59232: PPUSH
59233: LD_VAR 0 14
59237: PPUSH
59238: LD_VAR 0 4
59242: PUSH
59243: LD_VAR 0 7
59247: ARRAY
59248: PPUSH
59249: CALL_OW 74
59253: PPUSH
59254: CALL_OW 115
// end ; end ; end ;
59258: GO 55137
59260: POP
59261: POP
// wait ( 0 0$2 ) ;
59262: LD_INT 70
59264: PPUSH
59265: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
59269: LD_VAR 0 4
59273: NOT
59274: PUSH
59275: LD_VAR 0 4
59279: PUSH
59280: EMPTY
59281: EQUAL
59282: OR
59283: PUSH
59284: LD_INT 81
59286: PUSH
59287: LD_VAR 0 35
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: PPUSH
59296: CALL_OW 69
59300: NOT
59301: OR
59302: IFFALSE 55122
// end ;
59304: LD_VAR 0 2
59308: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
59309: LD_INT 0
59311: PPUSH
59312: PPUSH
59313: PPUSH
59314: PPUSH
59315: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
59316: LD_VAR 0 1
59320: NOT
59321: PUSH
59322: LD_EXP 86
59326: PUSH
59327: LD_VAR 0 1
59331: ARRAY
59332: NOT
59333: OR
59334: PUSH
59335: LD_VAR 0 2
59339: NOT
59340: OR
59341: PUSH
59342: LD_VAR 0 3
59346: NOT
59347: OR
59348: IFFALSE 59352
// exit ;
59350: GO 59865
// side := mc_sides [ base ] ;
59352: LD_ADDR_VAR 0 6
59356: PUSH
59357: LD_EXP 112
59361: PUSH
59362: LD_VAR 0 1
59366: ARRAY
59367: ST_TO_ADDR
// if not side then
59368: LD_VAR 0 6
59372: NOT
59373: IFFALSE 59377
// exit ;
59375: GO 59865
// for i in solds do
59377: LD_ADDR_VAR 0 7
59381: PUSH
59382: LD_VAR 0 2
59386: PUSH
59387: FOR_IN
59388: IFFALSE 59449
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
59390: LD_VAR 0 7
59394: PPUSH
59395: CALL_OW 310
59399: PPUSH
59400: CALL_OW 266
59404: PUSH
59405: LD_INT 32
59407: PUSH
59408: LD_INT 31
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: IN
59415: IFFALSE 59435
// solds := solds diff i else
59417: LD_ADDR_VAR 0 2
59421: PUSH
59422: LD_VAR 0 2
59426: PUSH
59427: LD_VAR 0 7
59431: DIFF
59432: ST_TO_ADDR
59433: GO 59447
// SetTag ( i , 18 ) ;
59435: LD_VAR 0 7
59439: PPUSH
59440: LD_INT 18
59442: PPUSH
59443: CALL_OW 109
59447: GO 59387
59449: POP
59450: POP
// if not solds then
59451: LD_VAR 0 2
59455: NOT
59456: IFFALSE 59460
// exit ;
59458: GO 59865
// repeat wait ( 0 0$2 ) ;
59460: LD_INT 70
59462: PPUSH
59463: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
59467: LD_ADDR_VAR 0 5
59471: PUSH
59472: LD_VAR 0 6
59476: PPUSH
59477: LD_VAR 0 3
59481: PPUSH
59482: CALL 19278 0 2
59486: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
59487: LD_EXP 86
59491: PUSH
59492: LD_VAR 0 1
59496: ARRAY
59497: NOT
59498: PUSH
59499: LD_EXP 86
59503: PUSH
59504: LD_VAR 0 1
59508: ARRAY
59509: PUSH
59510: EMPTY
59511: EQUAL
59512: OR
59513: IFFALSE 59550
// begin for i in solds do
59515: LD_ADDR_VAR 0 7
59519: PUSH
59520: LD_VAR 0 2
59524: PUSH
59525: FOR_IN
59526: IFFALSE 59539
// ComStop ( i ) ;
59528: LD_VAR 0 7
59532: PPUSH
59533: CALL_OW 141
59537: GO 59525
59539: POP
59540: POP
// solds := [ ] ;
59541: LD_ADDR_VAR 0 2
59545: PUSH
59546: EMPTY
59547: ST_TO_ADDR
// exit ;
59548: GO 59865
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
59550: LD_VAR 0 5
59554: NOT
59555: PUSH
59556: LD_VAR 0 5
59560: PUSH
59561: LD_INT 3
59563: GREATER
59564: OR
59565: PUSH
59566: LD_EXP 108
59570: PUSH
59571: LD_VAR 0 1
59575: ARRAY
59576: OR
59577: IFFALSE 59618
// begin for i in solds do
59579: LD_ADDR_VAR 0 7
59583: PUSH
59584: LD_VAR 0 2
59588: PUSH
59589: FOR_IN
59590: IFFALSE 59614
// if HasTask ( i ) then
59592: LD_VAR 0 7
59596: PPUSH
59597: CALL_OW 314
59601: IFFALSE 59612
// ComStop ( i ) ;
59603: LD_VAR 0 7
59607: PPUSH
59608: CALL_OW 141
59612: GO 59589
59614: POP
59615: POP
// break ;
59616: GO 59853
// end ; for i in solds do
59618: LD_ADDR_VAR 0 7
59622: PUSH
59623: LD_VAR 0 2
59627: PUSH
59628: FOR_IN
59629: IFFALSE 59845
// begin if IsInUnit ( i ) then
59631: LD_VAR 0 7
59635: PPUSH
59636: CALL_OW 310
59640: IFFALSE 59651
// ComExitBuilding ( i ) ;
59642: LD_VAR 0 7
59646: PPUSH
59647: CALL_OW 122
// if GetLives ( i ) > 333 then
59651: LD_VAR 0 7
59655: PPUSH
59656: CALL_OW 256
59660: PUSH
59661: LD_INT 333
59663: GREATER
59664: IFFALSE 59692
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59666: LD_VAR 0 7
59670: PPUSH
59671: LD_VAR 0 5
59675: PPUSH
59676: LD_VAR 0 7
59680: PPUSH
59681: CALL_OW 74
59685: PPUSH
59686: CALL_OW 115
59690: GO 59843
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
59692: LD_ADDR_VAR 0 8
59696: PUSH
59697: LD_EXP 86
59701: PUSH
59702: LD_VAR 0 1
59706: ARRAY
59707: PPUSH
59708: LD_INT 2
59710: PUSH
59711: LD_INT 30
59713: PUSH
59714: LD_INT 0
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PUSH
59721: LD_INT 30
59723: PUSH
59724: LD_INT 1
59726: PUSH
59727: EMPTY
59728: LIST
59729: LIST
59730: PUSH
59731: LD_INT 30
59733: PUSH
59734: LD_INT 6
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: LIST
59745: LIST
59746: PPUSH
59747: CALL_OW 72
59751: PPUSH
59752: LD_VAR 0 7
59756: PPUSH
59757: CALL_OW 74
59761: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
59762: LD_VAR 0 7
59766: PPUSH
59767: LD_VAR 0 8
59771: PPUSH
59772: CALL_OW 250
59776: PPUSH
59777: LD_INT 3
59779: PPUSH
59780: LD_INT 5
59782: PPUSH
59783: CALL_OW 272
59787: PPUSH
59788: LD_VAR 0 8
59792: PPUSH
59793: CALL_OW 251
59797: PPUSH
59798: LD_INT 3
59800: PPUSH
59801: LD_INT 5
59803: PPUSH
59804: CALL_OW 273
59808: PPUSH
59809: CALL_OW 111
// SetTag ( i , 0 ) ;
59813: LD_VAR 0 7
59817: PPUSH
59818: LD_INT 0
59820: PPUSH
59821: CALL_OW 109
// solds := solds diff i ;
59825: LD_ADDR_VAR 0 2
59829: PUSH
59830: LD_VAR 0 2
59834: PUSH
59835: LD_VAR 0 7
59839: DIFF
59840: ST_TO_ADDR
// continue ;
59841: GO 59628
// end ; end ;
59843: GO 59628
59845: POP
59846: POP
// until solds ;
59847: LD_VAR 0 2
59851: IFFALSE 59460
// MC_Reset ( base , 18 ) ;
59853: LD_VAR 0 1
59857: PPUSH
59858: LD_INT 18
59860: PPUSH
59861: CALL 65862 0 2
// end ;
59865: LD_VAR 0 4
59869: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
59870: LD_INT 0
59872: PPUSH
59873: PPUSH
59874: PPUSH
59875: PPUSH
59876: PPUSH
59877: PPUSH
59878: PPUSH
59879: PPUSH
59880: PPUSH
59881: PPUSH
59882: PPUSH
59883: PPUSH
59884: PPUSH
59885: PPUSH
59886: PPUSH
59887: PPUSH
59888: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59889: LD_ADDR_VAR 0 13
59893: PUSH
59894: LD_EXP 86
59898: PUSH
59899: LD_VAR 0 1
59903: ARRAY
59904: PPUSH
59905: LD_INT 25
59907: PUSH
59908: LD_INT 3
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PPUSH
59915: CALL_OW 72
59919: ST_TO_ADDR
// if mc_remote_driver [ base ] then
59920: LD_EXP 126
59924: PUSH
59925: LD_VAR 0 1
59929: ARRAY
59930: IFFALSE 59954
// mechs := mechs diff mc_remote_driver [ base ] ;
59932: LD_ADDR_VAR 0 13
59936: PUSH
59937: LD_VAR 0 13
59941: PUSH
59942: LD_EXP 126
59946: PUSH
59947: LD_VAR 0 1
59951: ARRAY
59952: DIFF
59953: ST_TO_ADDR
// for i in mechs do
59954: LD_ADDR_VAR 0 5
59958: PUSH
59959: LD_VAR 0 13
59963: PUSH
59964: FOR_IN
59965: IFFALSE 60000
// if GetTag ( i ) > 0 then
59967: LD_VAR 0 5
59971: PPUSH
59972: CALL_OW 110
59976: PUSH
59977: LD_INT 0
59979: GREATER
59980: IFFALSE 59998
// mechs := mechs diff i ;
59982: LD_ADDR_VAR 0 13
59986: PUSH
59987: LD_VAR 0 13
59991: PUSH
59992: LD_VAR 0 5
59996: DIFF
59997: ST_TO_ADDR
59998: GO 59964
60000: POP
60001: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60002: LD_ADDR_VAR 0 9
60006: PUSH
60007: LD_EXP 86
60011: PUSH
60012: LD_VAR 0 1
60016: ARRAY
60017: PPUSH
60018: LD_INT 2
60020: PUSH
60021: LD_INT 25
60023: PUSH
60024: LD_INT 1
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: LD_INT 25
60033: PUSH
60034: LD_INT 5
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: LD_INT 25
60043: PUSH
60044: LD_INT 8
60046: PUSH
60047: EMPTY
60048: LIST
60049: LIST
60050: PUSH
60051: LD_INT 25
60053: PUSH
60054: LD_INT 9
60056: PUSH
60057: EMPTY
60058: LIST
60059: LIST
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: LIST
60065: LIST
60066: LIST
60067: PPUSH
60068: CALL_OW 72
60072: ST_TO_ADDR
// if not defenders and not solds then
60073: LD_VAR 0 2
60077: NOT
60078: PUSH
60079: LD_VAR 0 9
60083: NOT
60084: AND
60085: IFFALSE 60089
// exit ;
60087: GO 61779
// depot_under_attack := false ;
60089: LD_ADDR_VAR 0 17
60093: PUSH
60094: LD_INT 0
60096: ST_TO_ADDR
// sold_defenders := [ ] ;
60097: LD_ADDR_VAR 0 18
60101: PUSH
60102: EMPTY
60103: ST_TO_ADDR
// if mechs then
60104: LD_VAR 0 13
60108: IFFALSE 60261
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
60110: LD_ADDR_VAR 0 5
60114: PUSH
60115: LD_VAR 0 2
60119: PPUSH
60120: LD_INT 21
60122: PUSH
60123: LD_INT 2
60125: PUSH
60126: EMPTY
60127: LIST
60128: LIST
60129: PPUSH
60130: CALL_OW 72
60134: PUSH
60135: FOR_IN
60136: IFFALSE 60259
// begin if GetTag ( i ) <> 20 then
60138: LD_VAR 0 5
60142: PPUSH
60143: CALL_OW 110
60147: PUSH
60148: LD_INT 20
60150: NONEQUAL
60151: IFFALSE 60165
// SetTag ( i , 20 ) ;
60153: LD_VAR 0 5
60157: PPUSH
60158: LD_INT 20
60160: PPUSH
60161: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
60165: LD_VAR 0 5
60169: PPUSH
60170: CALL_OW 263
60174: PUSH
60175: LD_INT 1
60177: EQUAL
60178: PUSH
60179: LD_VAR 0 5
60183: PPUSH
60184: CALL_OW 311
60188: NOT
60189: AND
60190: IFFALSE 60257
// begin un := mechs [ 1 ] ;
60192: LD_ADDR_VAR 0 11
60196: PUSH
60197: LD_VAR 0 13
60201: PUSH
60202: LD_INT 1
60204: ARRAY
60205: ST_TO_ADDR
// ComExit ( un ) ;
60206: LD_VAR 0 11
60210: PPUSH
60211: CALL 53908 0 1
// AddComEnterUnit ( un , i ) ;
60215: LD_VAR 0 11
60219: PPUSH
60220: LD_VAR 0 5
60224: PPUSH
60225: CALL_OW 180
// SetTag ( un , 19 ) ;
60229: LD_VAR 0 11
60233: PPUSH
60234: LD_INT 19
60236: PPUSH
60237: CALL_OW 109
// mechs := mechs diff un ;
60241: LD_ADDR_VAR 0 13
60245: PUSH
60246: LD_VAR 0 13
60250: PUSH
60251: LD_VAR 0 11
60255: DIFF
60256: ST_TO_ADDR
// end ; end ;
60257: GO 60135
60259: POP
60260: POP
// if solds then
60261: LD_VAR 0 9
60265: IFFALSE 60324
// for i in solds do
60267: LD_ADDR_VAR 0 5
60271: PUSH
60272: LD_VAR 0 9
60276: PUSH
60277: FOR_IN
60278: IFFALSE 60322
// if not GetTag ( i ) then
60280: LD_VAR 0 5
60284: PPUSH
60285: CALL_OW 110
60289: NOT
60290: IFFALSE 60320
// begin defenders := defenders union i ;
60292: LD_ADDR_VAR 0 2
60296: PUSH
60297: LD_VAR 0 2
60301: PUSH
60302: LD_VAR 0 5
60306: UNION
60307: ST_TO_ADDR
// SetTag ( i , 18 ) ;
60308: LD_VAR 0 5
60312: PPUSH
60313: LD_INT 18
60315: PPUSH
60316: CALL_OW 109
// end ;
60320: GO 60277
60322: POP
60323: POP
// repeat wait ( 0 0$2 ) ;
60324: LD_INT 70
60326: PPUSH
60327: CALL_OW 67
// enemy := mc_scan [ base ] ;
60331: LD_ADDR_VAR 0 3
60335: PUSH
60336: LD_EXP 109
60340: PUSH
60341: LD_VAR 0 1
60345: ARRAY
60346: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
60347: LD_EXP 86
60351: PUSH
60352: LD_VAR 0 1
60356: ARRAY
60357: NOT
60358: PUSH
60359: LD_EXP 86
60363: PUSH
60364: LD_VAR 0 1
60368: ARRAY
60369: PUSH
60370: EMPTY
60371: EQUAL
60372: OR
60373: IFFALSE 60410
// begin for i in defenders do
60375: LD_ADDR_VAR 0 5
60379: PUSH
60380: LD_VAR 0 2
60384: PUSH
60385: FOR_IN
60386: IFFALSE 60399
// ComStop ( i ) ;
60388: LD_VAR 0 5
60392: PPUSH
60393: CALL_OW 141
60397: GO 60385
60399: POP
60400: POP
// defenders := [ ] ;
60401: LD_ADDR_VAR 0 2
60405: PUSH
60406: EMPTY
60407: ST_TO_ADDR
// exit ;
60408: GO 61779
// end ; for i in defenders do
60410: LD_ADDR_VAR 0 5
60414: PUSH
60415: LD_VAR 0 2
60419: PUSH
60420: FOR_IN
60421: IFFALSE 61239
// begin e := NearestUnitToUnit ( enemy , i ) ;
60423: LD_ADDR_VAR 0 14
60427: PUSH
60428: LD_VAR 0 3
60432: PPUSH
60433: LD_VAR 0 5
60437: PPUSH
60438: CALL_OW 74
60442: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60443: LD_ADDR_VAR 0 8
60447: PUSH
60448: LD_EXP 86
60452: PUSH
60453: LD_VAR 0 1
60457: ARRAY
60458: PPUSH
60459: LD_INT 2
60461: PUSH
60462: LD_INT 30
60464: PUSH
60465: LD_INT 0
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: LD_INT 30
60474: PUSH
60475: LD_INT 1
60477: PUSH
60478: EMPTY
60479: LIST
60480: LIST
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: LIST
60486: PPUSH
60487: CALL_OW 72
60491: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
60492: LD_ADDR_VAR 0 17
60496: PUSH
60497: LD_VAR 0 8
60501: NOT
60502: PUSH
60503: LD_VAR 0 8
60507: PPUSH
60508: LD_INT 3
60510: PUSH
60511: LD_INT 24
60513: PUSH
60514: LD_INT 600
60516: PUSH
60517: EMPTY
60518: LIST
60519: LIST
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PPUSH
60525: CALL_OW 72
60529: OR
60530: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
60531: LD_VAR 0 5
60535: PPUSH
60536: CALL_OW 247
60540: PUSH
60541: LD_INT 2
60543: DOUBLE
60544: EQUAL
60545: IFTRUE 60549
60547: GO 60945
60549: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
60550: LD_VAR 0 5
60554: PPUSH
60555: CALL_OW 256
60559: PUSH
60560: LD_INT 650
60562: GREATER
60563: PUSH
60564: LD_VAR 0 5
60568: PPUSH
60569: LD_VAR 0 14
60573: PPUSH
60574: CALL_OW 296
60578: PUSH
60579: LD_INT 40
60581: LESS
60582: PUSH
60583: LD_VAR 0 14
60587: PPUSH
60588: LD_EXP 111
60592: PUSH
60593: LD_VAR 0 1
60597: ARRAY
60598: PPUSH
60599: CALL_OW 308
60603: OR
60604: AND
60605: IFFALSE 60727
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
60607: LD_VAR 0 5
60611: PPUSH
60612: CALL_OW 262
60616: PUSH
60617: LD_INT 1
60619: EQUAL
60620: PUSH
60621: LD_VAR 0 5
60625: PPUSH
60626: CALL_OW 261
60630: PUSH
60631: LD_INT 30
60633: LESS
60634: AND
60635: PUSH
60636: LD_VAR 0 8
60640: AND
60641: IFFALSE 60711
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
60643: LD_VAR 0 5
60647: PPUSH
60648: LD_VAR 0 8
60652: PPUSH
60653: LD_VAR 0 5
60657: PPUSH
60658: CALL_OW 74
60662: PPUSH
60663: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
60667: LD_VAR 0 5
60671: PPUSH
60672: LD_VAR 0 8
60676: PPUSH
60677: LD_VAR 0 5
60681: PPUSH
60682: CALL_OW 74
60686: PPUSH
60687: CALL_OW 296
60691: PUSH
60692: LD_INT 6
60694: LESS
60695: IFFALSE 60709
// SetFuel ( i , 100 ) ;
60697: LD_VAR 0 5
60701: PPUSH
60702: LD_INT 100
60704: PPUSH
60705: CALL_OW 240
// end else
60709: GO 60725
// ComAttackUnit ( i , e ) ;
60711: LD_VAR 0 5
60715: PPUSH
60716: LD_VAR 0 14
60720: PPUSH
60721: CALL_OW 115
// end else
60725: GO 60828
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
60727: LD_VAR 0 14
60731: PPUSH
60732: LD_EXP 111
60736: PUSH
60737: LD_VAR 0 1
60741: ARRAY
60742: PPUSH
60743: CALL_OW 308
60747: NOT
60748: PUSH
60749: LD_VAR 0 5
60753: PPUSH
60754: LD_VAR 0 14
60758: PPUSH
60759: CALL_OW 296
60763: PUSH
60764: LD_INT 40
60766: GREATEREQUAL
60767: AND
60768: PUSH
60769: LD_VAR 0 5
60773: PPUSH
60774: CALL_OW 256
60778: PUSH
60779: LD_INT 650
60781: LESSEQUAL
60782: OR
60783: PUSH
60784: LD_VAR 0 5
60788: PPUSH
60789: LD_EXP 110
60793: PUSH
60794: LD_VAR 0 1
60798: ARRAY
60799: PPUSH
60800: CALL_OW 308
60804: NOT
60805: AND
60806: IFFALSE 60828
// ComMoveToArea ( i , mc_parking [ base ] ) ;
60808: LD_VAR 0 5
60812: PPUSH
60813: LD_EXP 110
60817: PUSH
60818: LD_VAR 0 1
60822: ARRAY
60823: PPUSH
60824: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
60828: LD_VAR 0 5
60832: PPUSH
60833: CALL_OW 256
60837: PUSH
60838: LD_INT 998
60840: LESS
60841: PUSH
60842: LD_VAR 0 5
60846: PPUSH
60847: CALL_OW 263
60851: PUSH
60852: LD_INT 1
60854: EQUAL
60855: AND
60856: PUSH
60857: LD_VAR 0 5
60861: PPUSH
60862: CALL_OW 311
60866: AND
60867: PUSH
60868: LD_VAR 0 5
60872: PPUSH
60873: LD_EXP 110
60877: PUSH
60878: LD_VAR 0 1
60882: ARRAY
60883: PPUSH
60884: CALL_OW 308
60888: AND
60889: IFFALSE 60943
// begin mech := IsDrivenBy ( i ) ;
60891: LD_ADDR_VAR 0 10
60895: PUSH
60896: LD_VAR 0 5
60900: PPUSH
60901: CALL_OW 311
60905: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
60906: LD_VAR 0 10
60910: PPUSH
60911: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
60915: LD_VAR 0 10
60919: PPUSH
60920: LD_VAR 0 5
60924: PPUSH
60925: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
60929: LD_VAR 0 10
60933: PPUSH
60934: LD_VAR 0 5
60938: PPUSH
60939: CALL_OW 180
// end ; end ; unit_human :
60943: GO 61210
60945: LD_INT 1
60947: DOUBLE
60948: EQUAL
60949: IFTRUE 60953
60951: GO 61209
60953: POP
// begin b := IsInUnit ( i ) ;
60954: LD_ADDR_VAR 0 19
60958: PUSH
60959: LD_VAR 0 5
60963: PPUSH
60964: CALL_OW 310
60968: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
60969: LD_ADDR_VAR 0 20
60973: PUSH
60974: LD_VAR 0 19
60978: NOT
60979: PUSH
60980: LD_VAR 0 19
60984: PPUSH
60985: CALL_OW 266
60989: PUSH
60990: LD_INT 32
60992: PUSH
60993: LD_INT 31
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: IN
61000: OR
61001: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
61002: LD_VAR 0 17
61006: PUSH
61007: LD_VAR 0 2
61011: PPUSH
61012: LD_INT 21
61014: PUSH
61015: LD_INT 2
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: PPUSH
61022: CALL_OW 72
61026: PUSH
61027: LD_INT 1
61029: LESSEQUAL
61030: OR
61031: PUSH
61032: LD_VAR 0 20
61036: AND
61037: PUSH
61038: LD_VAR 0 5
61042: PUSH
61043: LD_VAR 0 18
61047: IN
61048: NOT
61049: AND
61050: IFFALSE 61143
// begin if b then
61052: LD_VAR 0 19
61056: IFFALSE 61105
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
61058: LD_VAR 0 19
61062: PPUSH
61063: LD_VAR 0 3
61067: PPUSH
61068: LD_VAR 0 19
61072: PPUSH
61073: CALL_OW 74
61077: PPUSH
61078: CALL_OW 296
61082: PUSH
61083: LD_INT 10
61085: LESS
61086: PUSH
61087: LD_VAR 0 19
61091: PPUSH
61092: CALL_OW 461
61096: PUSH
61097: LD_INT 7
61099: NONEQUAL
61100: AND
61101: IFFALSE 61105
// continue ;
61103: GO 60420
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
61105: LD_ADDR_VAR 0 18
61109: PUSH
61110: LD_VAR 0 18
61114: PPUSH
61115: LD_VAR 0 18
61119: PUSH
61120: LD_INT 1
61122: PLUS
61123: PPUSH
61124: LD_VAR 0 5
61128: PPUSH
61129: CALL_OW 1
61133: ST_TO_ADDR
// ComExitBuilding ( i ) ;
61134: LD_VAR 0 5
61138: PPUSH
61139: CALL_OW 122
// end ; if sold_defenders then
61143: LD_VAR 0 18
61147: IFFALSE 61207
// if i in sold_defenders then
61149: LD_VAR 0 5
61153: PUSH
61154: LD_VAR 0 18
61158: IN
61159: IFFALSE 61207
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
61161: LD_VAR 0 5
61165: PPUSH
61166: CALL_OW 314
61170: NOT
61171: PUSH
61172: LD_VAR 0 5
61176: PPUSH
61177: LD_VAR 0 14
61181: PPUSH
61182: CALL_OW 296
61186: PUSH
61187: LD_INT 30
61189: LESS
61190: AND
61191: IFFALSE 61207
// ComAttackUnit ( i , e ) ;
61193: LD_VAR 0 5
61197: PPUSH
61198: LD_VAR 0 14
61202: PPUSH
61203: CALL_OW 115
// end ; end ; end ;
61207: GO 61210
61209: POP
// if IsDead ( i ) then
61210: LD_VAR 0 5
61214: PPUSH
61215: CALL_OW 301
61219: IFFALSE 61237
// defenders := defenders diff i ;
61221: LD_ADDR_VAR 0 2
61225: PUSH
61226: LD_VAR 0 2
61230: PUSH
61231: LD_VAR 0 5
61235: DIFF
61236: ST_TO_ADDR
// end ;
61237: GO 60420
61239: POP
61240: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
61241: LD_VAR 0 3
61245: NOT
61246: PUSH
61247: LD_VAR 0 2
61251: NOT
61252: OR
61253: PUSH
61254: LD_EXP 86
61258: PUSH
61259: LD_VAR 0 1
61263: ARRAY
61264: NOT
61265: OR
61266: IFFALSE 60324
// MC_Reset ( base , 18 ) ;
61268: LD_VAR 0 1
61272: PPUSH
61273: LD_INT 18
61275: PPUSH
61276: CALL 65862 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61280: LD_ADDR_VAR 0 2
61284: PUSH
61285: LD_VAR 0 2
61289: PUSH
61290: LD_VAR 0 2
61294: PPUSH
61295: LD_INT 2
61297: PUSH
61298: LD_INT 25
61300: PUSH
61301: LD_INT 1
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 25
61310: PUSH
61311: LD_INT 5
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: PUSH
61318: LD_INT 25
61320: PUSH
61321: LD_INT 8
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PUSH
61328: LD_INT 25
61330: PUSH
61331: LD_INT 9
61333: PUSH
61334: EMPTY
61335: LIST
61336: LIST
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: PPUSH
61345: CALL_OW 72
61349: DIFF
61350: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
61351: LD_VAR 0 3
61355: NOT
61356: PUSH
61357: LD_VAR 0 2
61361: PPUSH
61362: LD_INT 21
61364: PUSH
61365: LD_INT 2
61367: PUSH
61368: EMPTY
61369: LIST
61370: LIST
61371: PPUSH
61372: CALL_OW 72
61376: AND
61377: IFFALSE 61715
// begin tmp := FilterByTag ( defenders , 19 ) ;
61379: LD_ADDR_VAR 0 12
61383: PUSH
61384: LD_VAR 0 2
61388: PPUSH
61389: LD_INT 19
61391: PPUSH
61392: CALL 51038 0 2
61396: ST_TO_ADDR
// if tmp then
61397: LD_VAR 0 12
61401: IFFALSE 61471
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
61403: LD_ADDR_VAR 0 12
61407: PUSH
61408: LD_VAR 0 12
61412: PPUSH
61413: LD_INT 25
61415: PUSH
61416: LD_INT 3
61418: PUSH
61419: EMPTY
61420: LIST
61421: LIST
61422: PPUSH
61423: CALL_OW 72
61427: ST_TO_ADDR
// if tmp then
61428: LD_VAR 0 12
61432: IFFALSE 61471
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
61434: LD_ADDR_EXP 98
61438: PUSH
61439: LD_EXP 98
61443: PPUSH
61444: LD_VAR 0 1
61448: PPUSH
61449: LD_EXP 98
61453: PUSH
61454: LD_VAR 0 1
61458: ARRAY
61459: PUSH
61460: LD_VAR 0 12
61464: UNION
61465: PPUSH
61466: CALL_OW 1
61470: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
61471: LD_VAR 0 1
61475: PPUSH
61476: LD_INT 19
61478: PPUSH
61479: CALL 65862 0 2
// repeat wait ( 0 0$1 ) ;
61483: LD_INT 35
61485: PPUSH
61486: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
61490: LD_EXP 86
61494: PUSH
61495: LD_VAR 0 1
61499: ARRAY
61500: NOT
61501: PUSH
61502: LD_EXP 86
61506: PUSH
61507: LD_VAR 0 1
61511: ARRAY
61512: PUSH
61513: EMPTY
61514: EQUAL
61515: OR
61516: IFFALSE 61553
// begin for i in defenders do
61518: LD_ADDR_VAR 0 5
61522: PUSH
61523: LD_VAR 0 2
61527: PUSH
61528: FOR_IN
61529: IFFALSE 61542
// ComStop ( i ) ;
61531: LD_VAR 0 5
61535: PPUSH
61536: CALL_OW 141
61540: GO 61528
61542: POP
61543: POP
// defenders := [ ] ;
61544: LD_ADDR_VAR 0 2
61548: PUSH
61549: EMPTY
61550: ST_TO_ADDR
// exit ;
61551: GO 61779
// end ; for i in defenders do
61553: LD_ADDR_VAR 0 5
61557: PUSH
61558: LD_VAR 0 2
61562: PUSH
61563: FOR_IN
61564: IFFALSE 61653
// begin if not IsInArea ( i , mc_parking [ base ] ) then
61566: LD_VAR 0 5
61570: PPUSH
61571: LD_EXP 110
61575: PUSH
61576: LD_VAR 0 1
61580: ARRAY
61581: PPUSH
61582: CALL_OW 308
61586: NOT
61587: IFFALSE 61611
// ComMoveToArea ( i , mc_parking [ base ] ) else
61589: LD_VAR 0 5
61593: PPUSH
61594: LD_EXP 110
61598: PUSH
61599: LD_VAR 0 1
61603: ARRAY
61604: PPUSH
61605: CALL_OW 113
61609: GO 61651
// if GetControl ( i ) = control_manual then
61611: LD_VAR 0 5
61615: PPUSH
61616: CALL_OW 263
61620: PUSH
61621: LD_INT 1
61623: EQUAL
61624: IFFALSE 61651
// if IsDrivenBy ( i ) then
61626: LD_VAR 0 5
61630: PPUSH
61631: CALL_OW 311
61635: IFFALSE 61651
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
61637: LD_VAR 0 5
61641: PPUSH
61642: CALL_OW 311
61646: PPUSH
61647: CALL_OW 121
// end ;
61651: GO 61563
61653: POP
61654: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
61655: LD_VAR 0 2
61659: PPUSH
61660: LD_INT 95
61662: PUSH
61663: LD_EXP 110
61667: PUSH
61668: LD_VAR 0 1
61672: ARRAY
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PPUSH
61678: CALL_OW 72
61682: PUSH
61683: LD_VAR 0 2
61687: EQUAL
61688: PUSH
61689: LD_EXP 109
61693: PUSH
61694: LD_VAR 0 1
61698: ARRAY
61699: OR
61700: PUSH
61701: LD_EXP 86
61705: PUSH
61706: LD_VAR 0 1
61710: ARRAY
61711: NOT
61712: OR
61713: IFFALSE 61483
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
61715: LD_ADDR_EXP 108
61719: PUSH
61720: LD_EXP 108
61724: PPUSH
61725: LD_VAR 0 1
61729: PPUSH
61730: LD_VAR 0 2
61734: PPUSH
61735: LD_INT 21
61737: PUSH
61738: LD_INT 2
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: PPUSH
61745: CALL_OW 72
61749: PPUSH
61750: CALL_OW 1
61754: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
61755: LD_VAR 0 1
61759: PPUSH
61760: LD_INT 19
61762: PPUSH
61763: CALL 65862 0 2
// MC_Reset ( base , 20 ) ;
61767: LD_VAR 0 1
61771: PPUSH
61772: LD_INT 20
61774: PPUSH
61775: CALL 65862 0 2
// end ; end_of_file
61779: LD_VAR 0 4
61783: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
61784: LD_INT 0
61786: PPUSH
61787: PPUSH
// skirmish := false ;
61788: LD_ADDR_EXP 84
61792: PUSH
61793: LD_INT 0
61795: ST_TO_ADDR
// debug_mc := false ;
61796: LD_ADDR_EXP 85
61800: PUSH
61801: LD_INT 0
61803: ST_TO_ADDR
// mc_bases := [ ] ;
61804: LD_ADDR_EXP 86
61808: PUSH
61809: EMPTY
61810: ST_TO_ADDR
// mc_sides := [ ] ;
61811: LD_ADDR_EXP 112
61815: PUSH
61816: EMPTY
61817: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61818: LD_ADDR_EXP 87
61822: PUSH
61823: EMPTY
61824: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61825: LD_ADDR_EXP 88
61829: PUSH
61830: EMPTY
61831: ST_TO_ADDR
// mc_need_heal := [ ] ;
61832: LD_ADDR_EXP 89
61836: PUSH
61837: EMPTY
61838: ST_TO_ADDR
// mc_healers := [ ] ;
61839: LD_ADDR_EXP 90
61843: PUSH
61844: EMPTY
61845: ST_TO_ADDR
// mc_build_list := [ ] ;
61846: LD_ADDR_EXP 91
61850: PUSH
61851: EMPTY
61852: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61853: LD_ADDR_EXP 118
61857: PUSH
61858: EMPTY
61859: ST_TO_ADDR
// mc_builders := [ ] ;
61860: LD_ADDR_EXP 92
61864: PUSH
61865: EMPTY
61866: ST_TO_ADDR
// mc_construct_list := [ ] ;
61867: LD_ADDR_EXP 93
61871: PUSH
61872: EMPTY
61873: ST_TO_ADDR
// mc_turret_list := [ ] ;
61874: LD_ADDR_EXP 94
61878: PUSH
61879: EMPTY
61880: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61881: LD_ADDR_EXP 95
61885: PUSH
61886: EMPTY
61887: ST_TO_ADDR
// mc_miners := [ ] ;
61888: LD_ADDR_EXP 100
61892: PUSH
61893: EMPTY
61894: ST_TO_ADDR
// mc_mines := [ ] ;
61895: LD_ADDR_EXP 99
61899: PUSH
61900: EMPTY
61901: ST_TO_ADDR
// mc_minefields := [ ] ;
61902: LD_ADDR_EXP 101
61906: PUSH
61907: EMPTY
61908: ST_TO_ADDR
// mc_crates := [ ] ;
61909: LD_ADDR_EXP 102
61913: PUSH
61914: EMPTY
61915: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61916: LD_ADDR_EXP 103
61920: PUSH
61921: EMPTY
61922: ST_TO_ADDR
// mc_crates_area := [ ] ;
61923: LD_ADDR_EXP 104
61927: PUSH
61928: EMPTY
61929: ST_TO_ADDR
// mc_vehicles := [ ] ;
61930: LD_ADDR_EXP 105
61934: PUSH
61935: EMPTY
61936: ST_TO_ADDR
// mc_attack := [ ] ;
61937: LD_ADDR_EXP 106
61941: PUSH
61942: EMPTY
61943: ST_TO_ADDR
// mc_produce := [ ] ;
61944: LD_ADDR_EXP 107
61948: PUSH
61949: EMPTY
61950: ST_TO_ADDR
// mc_defender := [ ] ;
61951: LD_ADDR_EXP 108
61955: PUSH
61956: EMPTY
61957: ST_TO_ADDR
// mc_parking := [ ] ;
61958: LD_ADDR_EXP 110
61962: PUSH
61963: EMPTY
61964: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61965: LD_ADDR_EXP 96
61969: PUSH
61970: EMPTY
61971: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61972: LD_ADDR_EXP 98
61976: PUSH
61977: EMPTY
61978: ST_TO_ADDR
// mc_scan := [ ] ;
61979: LD_ADDR_EXP 109
61983: PUSH
61984: EMPTY
61985: ST_TO_ADDR
// mc_scan_area := [ ] ;
61986: LD_ADDR_EXP 111
61990: PUSH
61991: EMPTY
61992: ST_TO_ADDR
// mc_tech := [ ] ;
61993: LD_ADDR_EXP 113
61997: PUSH
61998: EMPTY
61999: ST_TO_ADDR
// mc_class := [ ] ;
62000: LD_ADDR_EXP 127
62004: PUSH
62005: EMPTY
62006: ST_TO_ADDR
// mc_class_case_use := [ ] ;
62007: LD_ADDR_EXP 128
62011: PUSH
62012: EMPTY
62013: ST_TO_ADDR
// end ;
62014: LD_VAR 0 1
62018: RET
// export function MC_Kill ( base ) ; begin
62019: LD_INT 0
62021: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
62022: LD_ADDR_EXP 86
62026: PUSH
62027: LD_EXP 86
62031: PPUSH
62032: LD_VAR 0 1
62036: PPUSH
62037: EMPTY
62038: PPUSH
62039: CALL_OW 1
62043: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62044: LD_ADDR_EXP 87
62048: PUSH
62049: LD_EXP 87
62053: PPUSH
62054: LD_VAR 0 1
62058: PPUSH
62059: EMPTY
62060: PPUSH
62061: CALL_OW 1
62065: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62066: LD_ADDR_EXP 88
62070: PUSH
62071: LD_EXP 88
62075: PPUSH
62076: LD_VAR 0 1
62080: PPUSH
62081: EMPTY
62082: PPUSH
62083: CALL_OW 1
62087: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62088: LD_ADDR_EXP 89
62092: PUSH
62093: LD_EXP 89
62097: PPUSH
62098: LD_VAR 0 1
62102: PPUSH
62103: EMPTY
62104: PPUSH
62105: CALL_OW 1
62109: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62110: LD_ADDR_EXP 90
62114: PUSH
62115: LD_EXP 90
62119: PPUSH
62120: LD_VAR 0 1
62124: PPUSH
62125: EMPTY
62126: PPUSH
62127: CALL_OW 1
62131: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62132: LD_ADDR_EXP 91
62136: PUSH
62137: LD_EXP 91
62141: PPUSH
62142: LD_VAR 0 1
62146: PPUSH
62147: EMPTY
62148: PPUSH
62149: CALL_OW 1
62153: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62154: LD_ADDR_EXP 92
62158: PUSH
62159: LD_EXP 92
62163: PPUSH
62164: LD_VAR 0 1
62168: PPUSH
62169: EMPTY
62170: PPUSH
62171: CALL_OW 1
62175: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62176: LD_ADDR_EXP 93
62180: PUSH
62181: LD_EXP 93
62185: PPUSH
62186: LD_VAR 0 1
62190: PPUSH
62191: EMPTY
62192: PPUSH
62193: CALL_OW 1
62197: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62198: LD_ADDR_EXP 94
62202: PUSH
62203: LD_EXP 94
62207: PPUSH
62208: LD_VAR 0 1
62212: PPUSH
62213: EMPTY
62214: PPUSH
62215: CALL_OW 1
62219: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62220: LD_ADDR_EXP 95
62224: PUSH
62225: LD_EXP 95
62229: PPUSH
62230: LD_VAR 0 1
62234: PPUSH
62235: EMPTY
62236: PPUSH
62237: CALL_OW 1
62241: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62242: LD_ADDR_EXP 96
62246: PUSH
62247: LD_EXP 96
62251: PPUSH
62252: LD_VAR 0 1
62256: PPUSH
62257: EMPTY
62258: PPUSH
62259: CALL_OW 1
62263: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62264: LD_ADDR_EXP 97
62268: PUSH
62269: LD_EXP 97
62273: PPUSH
62274: LD_VAR 0 1
62278: PPUSH
62279: LD_INT 0
62281: PPUSH
62282: CALL_OW 1
62286: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62287: LD_ADDR_EXP 98
62291: PUSH
62292: LD_EXP 98
62296: PPUSH
62297: LD_VAR 0 1
62301: PPUSH
62302: EMPTY
62303: PPUSH
62304: CALL_OW 1
62308: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62309: LD_ADDR_EXP 99
62313: PUSH
62314: LD_EXP 99
62318: PPUSH
62319: LD_VAR 0 1
62323: PPUSH
62324: EMPTY
62325: PPUSH
62326: CALL_OW 1
62330: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62331: LD_ADDR_EXP 100
62335: PUSH
62336: LD_EXP 100
62340: PPUSH
62341: LD_VAR 0 1
62345: PPUSH
62346: EMPTY
62347: PPUSH
62348: CALL_OW 1
62352: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62353: LD_ADDR_EXP 101
62357: PUSH
62358: LD_EXP 101
62362: PPUSH
62363: LD_VAR 0 1
62367: PPUSH
62368: EMPTY
62369: PPUSH
62370: CALL_OW 1
62374: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62375: LD_ADDR_EXP 102
62379: PUSH
62380: LD_EXP 102
62384: PPUSH
62385: LD_VAR 0 1
62389: PPUSH
62390: EMPTY
62391: PPUSH
62392: CALL_OW 1
62396: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62397: LD_ADDR_EXP 103
62401: PUSH
62402: LD_EXP 103
62406: PPUSH
62407: LD_VAR 0 1
62411: PPUSH
62412: EMPTY
62413: PPUSH
62414: CALL_OW 1
62418: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62419: LD_ADDR_EXP 104
62423: PUSH
62424: LD_EXP 104
62428: PPUSH
62429: LD_VAR 0 1
62433: PPUSH
62434: EMPTY
62435: PPUSH
62436: CALL_OW 1
62440: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62441: LD_ADDR_EXP 105
62445: PUSH
62446: LD_EXP 105
62450: PPUSH
62451: LD_VAR 0 1
62455: PPUSH
62456: EMPTY
62457: PPUSH
62458: CALL_OW 1
62462: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62463: LD_ADDR_EXP 106
62467: PUSH
62468: LD_EXP 106
62472: PPUSH
62473: LD_VAR 0 1
62477: PPUSH
62478: EMPTY
62479: PPUSH
62480: CALL_OW 1
62484: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62485: LD_ADDR_EXP 107
62489: PUSH
62490: LD_EXP 107
62494: PPUSH
62495: LD_VAR 0 1
62499: PPUSH
62500: EMPTY
62501: PPUSH
62502: CALL_OW 1
62506: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62507: LD_ADDR_EXP 108
62511: PUSH
62512: LD_EXP 108
62516: PPUSH
62517: LD_VAR 0 1
62521: PPUSH
62522: EMPTY
62523: PPUSH
62524: CALL_OW 1
62528: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62529: LD_ADDR_EXP 109
62533: PUSH
62534: LD_EXP 109
62538: PPUSH
62539: LD_VAR 0 1
62543: PPUSH
62544: EMPTY
62545: PPUSH
62546: CALL_OW 1
62550: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62551: LD_ADDR_EXP 110
62555: PUSH
62556: LD_EXP 110
62560: PPUSH
62561: LD_VAR 0 1
62565: PPUSH
62566: EMPTY
62567: PPUSH
62568: CALL_OW 1
62572: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62573: LD_ADDR_EXP 111
62577: PUSH
62578: LD_EXP 111
62582: PPUSH
62583: LD_VAR 0 1
62587: PPUSH
62588: EMPTY
62589: PPUSH
62590: CALL_OW 1
62594: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62595: LD_ADDR_EXP 113
62599: PUSH
62600: LD_EXP 113
62604: PPUSH
62605: LD_VAR 0 1
62609: PPUSH
62610: EMPTY
62611: PPUSH
62612: CALL_OW 1
62616: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62617: LD_ADDR_EXP 115
62621: PUSH
62622: LD_EXP 115
62626: PPUSH
62627: LD_VAR 0 1
62631: PPUSH
62632: EMPTY
62633: PPUSH
62634: CALL_OW 1
62638: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62639: LD_ADDR_EXP 116
62643: PUSH
62644: LD_EXP 116
62648: PPUSH
62649: LD_VAR 0 1
62653: PPUSH
62654: EMPTY
62655: PPUSH
62656: CALL_OW 1
62660: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62661: LD_ADDR_EXP 117
62665: PUSH
62666: LD_EXP 117
62670: PPUSH
62671: LD_VAR 0 1
62675: PPUSH
62676: EMPTY
62677: PPUSH
62678: CALL_OW 1
62682: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62683: LD_ADDR_EXP 118
62687: PUSH
62688: LD_EXP 118
62692: PPUSH
62693: LD_VAR 0 1
62697: PPUSH
62698: EMPTY
62699: PPUSH
62700: CALL_OW 1
62704: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62705: LD_ADDR_EXP 119
62709: PUSH
62710: LD_EXP 119
62714: PPUSH
62715: LD_VAR 0 1
62719: PPUSH
62720: EMPTY
62721: PPUSH
62722: CALL_OW 1
62726: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62727: LD_ADDR_EXP 120
62731: PUSH
62732: LD_EXP 120
62736: PPUSH
62737: LD_VAR 0 1
62741: PPUSH
62742: EMPTY
62743: PPUSH
62744: CALL_OW 1
62748: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62749: LD_ADDR_EXP 121
62753: PUSH
62754: LD_EXP 121
62758: PPUSH
62759: LD_VAR 0 1
62763: PPUSH
62764: EMPTY
62765: PPUSH
62766: CALL_OW 1
62770: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62771: LD_ADDR_EXP 122
62775: PUSH
62776: LD_EXP 122
62780: PPUSH
62781: LD_VAR 0 1
62785: PPUSH
62786: EMPTY
62787: PPUSH
62788: CALL_OW 1
62792: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62793: LD_ADDR_EXP 123
62797: PUSH
62798: LD_EXP 123
62802: PPUSH
62803: LD_VAR 0 1
62807: PPUSH
62808: EMPTY
62809: PPUSH
62810: CALL_OW 1
62814: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62815: LD_ADDR_EXP 124
62819: PUSH
62820: LD_EXP 124
62824: PPUSH
62825: LD_VAR 0 1
62829: PPUSH
62830: EMPTY
62831: PPUSH
62832: CALL_OW 1
62836: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62837: LD_ADDR_EXP 125
62841: PUSH
62842: LD_EXP 125
62846: PPUSH
62847: LD_VAR 0 1
62851: PPUSH
62852: EMPTY
62853: PPUSH
62854: CALL_OW 1
62858: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62859: LD_ADDR_EXP 126
62863: PUSH
62864: LD_EXP 126
62868: PPUSH
62869: LD_VAR 0 1
62873: PPUSH
62874: EMPTY
62875: PPUSH
62876: CALL_OW 1
62880: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62881: LD_ADDR_EXP 127
62885: PUSH
62886: LD_EXP 127
62890: PPUSH
62891: LD_VAR 0 1
62895: PPUSH
62896: EMPTY
62897: PPUSH
62898: CALL_OW 1
62902: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62903: LD_ADDR_EXP 128
62907: PUSH
62908: LD_EXP 128
62912: PPUSH
62913: LD_VAR 0 1
62917: PPUSH
62918: LD_INT 0
62920: PPUSH
62921: CALL_OW 1
62925: ST_TO_ADDR
// end ;
62926: LD_VAR 0 2
62930: RET
// export function MC_Add ( side , units ) ; var base ; begin
62931: LD_INT 0
62933: PPUSH
62934: PPUSH
// base := mc_bases + 1 ;
62935: LD_ADDR_VAR 0 4
62939: PUSH
62940: LD_EXP 86
62944: PUSH
62945: LD_INT 1
62947: PLUS
62948: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62949: LD_ADDR_EXP 112
62953: PUSH
62954: LD_EXP 112
62958: PPUSH
62959: LD_VAR 0 4
62963: PPUSH
62964: LD_VAR 0 1
62968: PPUSH
62969: CALL_OW 1
62973: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62974: LD_ADDR_EXP 86
62978: PUSH
62979: LD_EXP 86
62983: PPUSH
62984: LD_VAR 0 4
62988: PPUSH
62989: LD_VAR 0 2
62993: PPUSH
62994: CALL_OW 1
62998: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62999: LD_ADDR_EXP 87
63003: PUSH
63004: LD_EXP 87
63008: PPUSH
63009: LD_VAR 0 4
63013: PPUSH
63014: EMPTY
63015: PPUSH
63016: CALL_OW 1
63020: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63021: LD_ADDR_EXP 88
63025: PUSH
63026: LD_EXP 88
63030: PPUSH
63031: LD_VAR 0 4
63035: PPUSH
63036: EMPTY
63037: PPUSH
63038: CALL_OW 1
63042: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63043: LD_ADDR_EXP 89
63047: PUSH
63048: LD_EXP 89
63052: PPUSH
63053: LD_VAR 0 4
63057: PPUSH
63058: EMPTY
63059: PPUSH
63060: CALL_OW 1
63064: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63065: LD_ADDR_EXP 90
63069: PUSH
63070: LD_EXP 90
63074: PPUSH
63075: LD_VAR 0 4
63079: PPUSH
63080: EMPTY
63081: PPUSH
63082: CALL_OW 1
63086: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63087: LD_ADDR_EXP 91
63091: PUSH
63092: LD_EXP 91
63096: PPUSH
63097: LD_VAR 0 4
63101: PPUSH
63102: EMPTY
63103: PPUSH
63104: CALL_OW 1
63108: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63109: LD_ADDR_EXP 92
63113: PUSH
63114: LD_EXP 92
63118: PPUSH
63119: LD_VAR 0 4
63123: PPUSH
63124: EMPTY
63125: PPUSH
63126: CALL_OW 1
63130: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63131: LD_ADDR_EXP 93
63135: PUSH
63136: LD_EXP 93
63140: PPUSH
63141: LD_VAR 0 4
63145: PPUSH
63146: EMPTY
63147: PPUSH
63148: CALL_OW 1
63152: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63153: LD_ADDR_EXP 94
63157: PUSH
63158: LD_EXP 94
63162: PPUSH
63163: LD_VAR 0 4
63167: PPUSH
63168: EMPTY
63169: PPUSH
63170: CALL_OW 1
63174: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63175: LD_ADDR_EXP 95
63179: PUSH
63180: LD_EXP 95
63184: PPUSH
63185: LD_VAR 0 4
63189: PPUSH
63190: EMPTY
63191: PPUSH
63192: CALL_OW 1
63196: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63197: LD_ADDR_EXP 96
63201: PUSH
63202: LD_EXP 96
63206: PPUSH
63207: LD_VAR 0 4
63211: PPUSH
63212: EMPTY
63213: PPUSH
63214: CALL_OW 1
63218: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63219: LD_ADDR_EXP 97
63223: PUSH
63224: LD_EXP 97
63228: PPUSH
63229: LD_VAR 0 4
63233: PPUSH
63234: LD_INT 0
63236: PPUSH
63237: CALL_OW 1
63241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63242: LD_ADDR_EXP 98
63246: PUSH
63247: LD_EXP 98
63251: PPUSH
63252: LD_VAR 0 4
63256: PPUSH
63257: EMPTY
63258: PPUSH
63259: CALL_OW 1
63263: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
63264: LD_ADDR_EXP 99
63268: PUSH
63269: LD_EXP 99
63273: PPUSH
63274: LD_VAR 0 4
63278: PPUSH
63279: EMPTY
63280: PPUSH
63281: CALL_OW 1
63285: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
63286: LD_ADDR_EXP 100
63290: PUSH
63291: LD_EXP 100
63295: PPUSH
63296: LD_VAR 0 4
63300: PPUSH
63301: EMPTY
63302: PPUSH
63303: CALL_OW 1
63307: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
63308: LD_ADDR_EXP 101
63312: PUSH
63313: LD_EXP 101
63317: PPUSH
63318: LD_VAR 0 4
63322: PPUSH
63323: EMPTY
63324: PPUSH
63325: CALL_OW 1
63329: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63330: LD_ADDR_EXP 102
63334: PUSH
63335: LD_EXP 102
63339: PPUSH
63340: LD_VAR 0 4
63344: PPUSH
63345: EMPTY
63346: PPUSH
63347: CALL_OW 1
63351: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63352: LD_ADDR_EXP 103
63356: PUSH
63357: LD_EXP 103
63361: PPUSH
63362: LD_VAR 0 4
63366: PPUSH
63367: EMPTY
63368: PPUSH
63369: CALL_OW 1
63373: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63374: LD_ADDR_EXP 104
63378: PUSH
63379: LD_EXP 104
63383: PPUSH
63384: LD_VAR 0 4
63388: PPUSH
63389: EMPTY
63390: PPUSH
63391: CALL_OW 1
63395: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63396: LD_ADDR_EXP 105
63400: PUSH
63401: LD_EXP 105
63405: PPUSH
63406: LD_VAR 0 4
63410: PPUSH
63411: EMPTY
63412: PPUSH
63413: CALL_OW 1
63417: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63418: LD_ADDR_EXP 106
63422: PUSH
63423: LD_EXP 106
63427: PPUSH
63428: LD_VAR 0 4
63432: PPUSH
63433: EMPTY
63434: PPUSH
63435: CALL_OW 1
63439: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63440: LD_ADDR_EXP 107
63444: PUSH
63445: LD_EXP 107
63449: PPUSH
63450: LD_VAR 0 4
63454: PPUSH
63455: EMPTY
63456: PPUSH
63457: CALL_OW 1
63461: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63462: LD_ADDR_EXP 108
63466: PUSH
63467: LD_EXP 108
63471: PPUSH
63472: LD_VAR 0 4
63476: PPUSH
63477: EMPTY
63478: PPUSH
63479: CALL_OW 1
63483: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63484: LD_ADDR_EXP 109
63488: PUSH
63489: LD_EXP 109
63493: PPUSH
63494: LD_VAR 0 4
63498: PPUSH
63499: EMPTY
63500: PPUSH
63501: CALL_OW 1
63505: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63506: LD_ADDR_EXP 110
63510: PUSH
63511: LD_EXP 110
63515: PPUSH
63516: LD_VAR 0 4
63520: PPUSH
63521: EMPTY
63522: PPUSH
63523: CALL_OW 1
63527: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63528: LD_ADDR_EXP 111
63532: PUSH
63533: LD_EXP 111
63537: PPUSH
63538: LD_VAR 0 4
63542: PPUSH
63543: EMPTY
63544: PPUSH
63545: CALL_OW 1
63549: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63550: LD_ADDR_EXP 113
63554: PUSH
63555: LD_EXP 113
63559: PPUSH
63560: LD_VAR 0 4
63564: PPUSH
63565: EMPTY
63566: PPUSH
63567: CALL_OW 1
63571: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63572: LD_ADDR_EXP 115
63576: PUSH
63577: LD_EXP 115
63581: PPUSH
63582: LD_VAR 0 4
63586: PPUSH
63587: EMPTY
63588: PPUSH
63589: CALL_OW 1
63593: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63594: LD_ADDR_EXP 116
63598: PUSH
63599: LD_EXP 116
63603: PPUSH
63604: LD_VAR 0 4
63608: PPUSH
63609: EMPTY
63610: PPUSH
63611: CALL_OW 1
63615: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63616: LD_ADDR_EXP 117
63620: PUSH
63621: LD_EXP 117
63625: PPUSH
63626: LD_VAR 0 4
63630: PPUSH
63631: EMPTY
63632: PPUSH
63633: CALL_OW 1
63637: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63638: LD_ADDR_EXP 118
63642: PUSH
63643: LD_EXP 118
63647: PPUSH
63648: LD_VAR 0 4
63652: PPUSH
63653: EMPTY
63654: PPUSH
63655: CALL_OW 1
63659: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63660: LD_ADDR_EXP 119
63664: PUSH
63665: LD_EXP 119
63669: PPUSH
63670: LD_VAR 0 4
63674: PPUSH
63675: EMPTY
63676: PPUSH
63677: CALL_OW 1
63681: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63682: LD_ADDR_EXP 120
63686: PUSH
63687: LD_EXP 120
63691: PPUSH
63692: LD_VAR 0 4
63696: PPUSH
63697: EMPTY
63698: PPUSH
63699: CALL_OW 1
63703: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63704: LD_ADDR_EXP 121
63708: PUSH
63709: LD_EXP 121
63713: PPUSH
63714: LD_VAR 0 4
63718: PPUSH
63719: EMPTY
63720: PPUSH
63721: CALL_OW 1
63725: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63726: LD_ADDR_EXP 122
63730: PUSH
63731: LD_EXP 122
63735: PPUSH
63736: LD_VAR 0 4
63740: PPUSH
63741: EMPTY
63742: PPUSH
63743: CALL_OW 1
63747: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63748: LD_ADDR_EXP 123
63752: PUSH
63753: LD_EXP 123
63757: PPUSH
63758: LD_VAR 0 4
63762: PPUSH
63763: EMPTY
63764: PPUSH
63765: CALL_OW 1
63769: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63770: LD_ADDR_EXP 124
63774: PUSH
63775: LD_EXP 124
63779: PPUSH
63780: LD_VAR 0 4
63784: PPUSH
63785: EMPTY
63786: PPUSH
63787: CALL_OW 1
63791: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63792: LD_ADDR_EXP 125
63796: PUSH
63797: LD_EXP 125
63801: PPUSH
63802: LD_VAR 0 4
63806: PPUSH
63807: EMPTY
63808: PPUSH
63809: CALL_OW 1
63813: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63814: LD_ADDR_EXP 126
63818: PUSH
63819: LD_EXP 126
63823: PPUSH
63824: LD_VAR 0 4
63828: PPUSH
63829: EMPTY
63830: PPUSH
63831: CALL_OW 1
63835: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63836: LD_ADDR_EXP 127
63840: PUSH
63841: LD_EXP 127
63845: PPUSH
63846: LD_VAR 0 4
63850: PPUSH
63851: EMPTY
63852: PPUSH
63853: CALL_OW 1
63857: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63858: LD_ADDR_EXP 128
63862: PUSH
63863: LD_EXP 128
63867: PPUSH
63868: LD_VAR 0 4
63872: PPUSH
63873: LD_INT 0
63875: PPUSH
63876: CALL_OW 1
63880: ST_TO_ADDR
// result := base ;
63881: LD_ADDR_VAR 0 3
63885: PUSH
63886: LD_VAR 0 4
63890: ST_TO_ADDR
// end ;
63891: LD_VAR 0 3
63895: RET
// export function MC_Start ( ) ; var i ; begin
63896: LD_INT 0
63898: PPUSH
63899: PPUSH
// for i = 1 to mc_bases do
63900: LD_ADDR_VAR 0 2
63904: PUSH
63905: DOUBLE
63906: LD_INT 1
63908: DEC
63909: ST_TO_ADDR
63910: LD_EXP 86
63914: PUSH
63915: FOR_TO
63916: IFFALSE 64993
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63918: LD_ADDR_EXP 86
63922: PUSH
63923: LD_EXP 86
63927: PPUSH
63928: LD_VAR 0 2
63932: PPUSH
63933: LD_EXP 86
63937: PUSH
63938: LD_VAR 0 2
63942: ARRAY
63943: PUSH
63944: LD_INT 0
63946: DIFF
63947: PPUSH
63948: CALL_OW 1
63952: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63953: LD_ADDR_EXP 87
63957: PUSH
63958: LD_EXP 87
63962: PPUSH
63963: LD_VAR 0 2
63967: PPUSH
63968: EMPTY
63969: PPUSH
63970: CALL_OW 1
63974: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63975: LD_ADDR_EXP 88
63979: PUSH
63980: LD_EXP 88
63984: PPUSH
63985: LD_VAR 0 2
63989: PPUSH
63990: EMPTY
63991: PPUSH
63992: CALL_OW 1
63996: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63997: LD_ADDR_EXP 89
64001: PUSH
64002: LD_EXP 89
64006: PPUSH
64007: LD_VAR 0 2
64011: PPUSH
64012: EMPTY
64013: PPUSH
64014: CALL_OW 1
64018: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
64019: LD_ADDR_EXP 90
64023: PUSH
64024: LD_EXP 90
64028: PPUSH
64029: LD_VAR 0 2
64033: PPUSH
64034: EMPTY
64035: PUSH
64036: EMPTY
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PPUSH
64042: CALL_OW 1
64046: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
64047: LD_ADDR_EXP 91
64051: PUSH
64052: LD_EXP 91
64056: PPUSH
64057: LD_VAR 0 2
64061: PPUSH
64062: EMPTY
64063: PPUSH
64064: CALL_OW 1
64068: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
64069: LD_ADDR_EXP 118
64073: PUSH
64074: LD_EXP 118
64078: PPUSH
64079: LD_VAR 0 2
64083: PPUSH
64084: EMPTY
64085: PPUSH
64086: CALL_OW 1
64090: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
64091: LD_ADDR_EXP 92
64095: PUSH
64096: LD_EXP 92
64100: PPUSH
64101: LD_VAR 0 2
64105: PPUSH
64106: EMPTY
64107: PPUSH
64108: CALL_OW 1
64112: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
64113: LD_ADDR_EXP 93
64117: PUSH
64118: LD_EXP 93
64122: PPUSH
64123: LD_VAR 0 2
64127: PPUSH
64128: EMPTY
64129: PPUSH
64130: CALL_OW 1
64134: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
64135: LD_ADDR_EXP 94
64139: PUSH
64140: LD_EXP 94
64144: PPUSH
64145: LD_VAR 0 2
64149: PPUSH
64150: LD_EXP 86
64154: PUSH
64155: LD_VAR 0 2
64159: ARRAY
64160: PPUSH
64161: LD_INT 2
64163: PUSH
64164: LD_INT 30
64166: PUSH
64167: LD_INT 32
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_INT 30
64176: PUSH
64177: LD_INT 33
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: LIST
64188: PPUSH
64189: CALL_OW 72
64193: PPUSH
64194: CALL_OW 1
64198: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
64199: LD_ADDR_EXP 95
64203: PUSH
64204: LD_EXP 95
64208: PPUSH
64209: LD_VAR 0 2
64213: PPUSH
64214: LD_EXP 86
64218: PUSH
64219: LD_VAR 0 2
64223: ARRAY
64224: PPUSH
64225: LD_INT 2
64227: PUSH
64228: LD_INT 30
64230: PUSH
64231: LD_INT 32
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 30
64240: PUSH
64241: LD_INT 31
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: EMPTY
64249: LIST
64250: LIST
64251: LIST
64252: PUSH
64253: LD_INT 58
64255: PUSH
64256: EMPTY
64257: LIST
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: PPUSH
64263: CALL_OW 72
64267: PPUSH
64268: CALL_OW 1
64272: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
64273: LD_ADDR_EXP 96
64277: PUSH
64278: LD_EXP 96
64282: PPUSH
64283: LD_VAR 0 2
64287: PPUSH
64288: EMPTY
64289: PPUSH
64290: CALL_OW 1
64294: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
64295: LD_ADDR_EXP 100
64299: PUSH
64300: LD_EXP 100
64304: PPUSH
64305: LD_VAR 0 2
64309: PPUSH
64310: EMPTY
64311: PPUSH
64312: CALL_OW 1
64316: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
64317: LD_ADDR_EXP 99
64321: PUSH
64322: LD_EXP 99
64326: PPUSH
64327: LD_VAR 0 2
64331: PPUSH
64332: EMPTY
64333: PPUSH
64334: CALL_OW 1
64338: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
64339: LD_ADDR_EXP 101
64343: PUSH
64344: LD_EXP 101
64348: PPUSH
64349: LD_VAR 0 2
64353: PPUSH
64354: EMPTY
64355: PPUSH
64356: CALL_OW 1
64360: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
64361: LD_ADDR_EXP 102
64365: PUSH
64366: LD_EXP 102
64370: PPUSH
64371: LD_VAR 0 2
64375: PPUSH
64376: EMPTY
64377: PPUSH
64378: CALL_OW 1
64382: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64383: LD_ADDR_EXP 103
64387: PUSH
64388: LD_EXP 103
64392: PPUSH
64393: LD_VAR 0 2
64397: PPUSH
64398: EMPTY
64399: PPUSH
64400: CALL_OW 1
64404: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
64405: LD_ADDR_EXP 104
64409: PUSH
64410: LD_EXP 104
64414: PPUSH
64415: LD_VAR 0 2
64419: PPUSH
64420: EMPTY
64421: PPUSH
64422: CALL_OW 1
64426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64427: LD_ADDR_EXP 105
64431: PUSH
64432: LD_EXP 105
64436: PPUSH
64437: LD_VAR 0 2
64441: PPUSH
64442: EMPTY
64443: PPUSH
64444: CALL_OW 1
64448: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64449: LD_ADDR_EXP 106
64453: PUSH
64454: LD_EXP 106
64458: PPUSH
64459: LD_VAR 0 2
64463: PPUSH
64464: EMPTY
64465: PPUSH
64466: CALL_OW 1
64470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64471: LD_ADDR_EXP 107
64475: PUSH
64476: LD_EXP 107
64480: PPUSH
64481: LD_VAR 0 2
64485: PPUSH
64486: EMPTY
64487: PPUSH
64488: CALL_OW 1
64492: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64493: LD_ADDR_EXP 108
64497: PUSH
64498: LD_EXP 108
64502: PPUSH
64503: LD_VAR 0 2
64507: PPUSH
64508: EMPTY
64509: PPUSH
64510: CALL_OW 1
64514: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64515: LD_ADDR_EXP 97
64519: PUSH
64520: LD_EXP 97
64524: PPUSH
64525: LD_VAR 0 2
64529: PPUSH
64530: LD_INT 0
64532: PPUSH
64533: CALL_OW 1
64537: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64538: LD_ADDR_EXP 110
64542: PUSH
64543: LD_EXP 110
64547: PPUSH
64548: LD_VAR 0 2
64552: PPUSH
64553: LD_INT 0
64555: PPUSH
64556: CALL_OW 1
64560: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64561: LD_ADDR_EXP 98
64565: PUSH
64566: LD_EXP 98
64570: PPUSH
64571: LD_VAR 0 2
64575: PPUSH
64576: EMPTY
64577: PPUSH
64578: CALL_OW 1
64582: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64583: LD_ADDR_EXP 109
64587: PUSH
64588: LD_EXP 109
64592: PPUSH
64593: LD_VAR 0 2
64597: PPUSH
64598: LD_INT 0
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64606: LD_ADDR_EXP 111
64610: PUSH
64611: LD_EXP 111
64615: PPUSH
64616: LD_VAR 0 2
64620: PPUSH
64621: EMPTY
64622: PPUSH
64623: CALL_OW 1
64627: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64628: LD_ADDR_EXP 114
64632: PUSH
64633: LD_EXP 114
64637: PPUSH
64638: LD_VAR 0 2
64642: PPUSH
64643: LD_INT 0
64645: PPUSH
64646: CALL_OW 1
64650: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64651: LD_ADDR_EXP 115
64655: PUSH
64656: LD_EXP 115
64660: PPUSH
64661: LD_VAR 0 2
64665: PPUSH
64666: EMPTY
64667: PPUSH
64668: CALL_OW 1
64672: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64673: LD_ADDR_EXP 116
64677: PUSH
64678: LD_EXP 116
64682: PPUSH
64683: LD_VAR 0 2
64687: PPUSH
64688: EMPTY
64689: PPUSH
64690: CALL_OW 1
64694: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64695: LD_ADDR_EXP 117
64699: PUSH
64700: LD_EXP 117
64704: PPUSH
64705: LD_VAR 0 2
64709: PPUSH
64710: EMPTY
64711: PPUSH
64712: CALL_OW 1
64716: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64717: LD_ADDR_EXP 119
64721: PUSH
64722: LD_EXP 119
64726: PPUSH
64727: LD_VAR 0 2
64731: PPUSH
64732: LD_EXP 86
64736: PUSH
64737: LD_VAR 0 2
64741: ARRAY
64742: PPUSH
64743: LD_INT 2
64745: PUSH
64746: LD_INT 30
64748: PUSH
64749: LD_INT 6
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 30
64758: PUSH
64759: LD_INT 7
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 30
64768: PUSH
64769: LD_INT 8
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: PPUSH
64782: CALL_OW 72
64786: PPUSH
64787: CALL_OW 1
64791: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64792: LD_ADDR_EXP 120
64796: PUSH
64797: LD_EXP 120
64801: PPUSH
64802: LD_VAR 0 2
64806: PPUSH
64807: EMPTY
64808: PPUSH
64809: CALL_OW 1
64813: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64814: LD_ADDR_EXP 121
64818: PUSH
64819: LD_EXP 121
64823: PPUSH
64824: LD_VAR 0 2
64828: PPUSH
64829: EMPTY
64830: PPUSH
64831: CALL_OW 1
64835: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64836: LD_ADDR_EXP 122
64840: PUSH
64841: LD_EXP 122
64845: PPUSH
64846: LD_VAR 0 2
64850: PPUSH
64851: EMPTY
64852: PPUSH
64853: CALL_OW 1
64857: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64858: LD_ADDR_EXP 123
64862: PUSH
64863: LD_EXP 123
64867: PPUSH
64868: LD_VAR 0 2
64872: PPUSH
64873: EMPTY
64874: PPUSH
64875: CALL_OW 1
64879: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64880: LD_ADDR_EXP 124
64884: PUSH
64885: LD_EXP 124
64889: PPUSH
64890: LD_VAR 0 2
64894: PPUSH
64895: EMPTY
64896: PPUSH
64897: CALL_OW 1
64901: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64902: LD_ADDR_EXP 125
64906: PUSH
64907: LD_EXP 125
64911: PPUSH
64912: LD_VAR 0 2
64916: PPUSH
64917: EMPTY
64918: PPUSH
64919: CALL_OW 1
64923: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64924: LD_ADDR_EXP 126
64928: PUSH
64929: LD_EXP 126
64933: PPUSH
64934: LD_VAR 0 2
64938: PPUSH
64939: EMPTY
64940: PPUSH
64941: CALL_OW 1
64945: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64946: LD_ADDR_EXP 127
64950: PUSH
64951: LD_EXP 127
64955: PPUSH
64956: LD_VAR 0 2
64960: PPUSH
64961: EMPTY
64962: PPUSH
64963: CALL_OW 1
64967: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64968: LD_ADDR_EXP 128
64972: PUSH
64973: LD_EXP 128
64977: PPUSH
64978: LD_VAR 0 2
64982: PPUSH
64983: LD_INT 0
64985: PPUSH
64986: CALL_OW 1
64990: ST_TO_ADDR
// end ;
64991: GO 63915
64993: POP
64994: POP
// MC_InitSides ( ) ;
64995: CALL 65281 0 0
// MC_InitResearch ( ) ;
64999: CALL 65020 0 0
// CustomInitMacro ( ) ;
65003: CALL 0 0 0
// skirmish := true ;
65007: LD_ADDR_EXP 84
65011: PUSH
65012: LD_INT 1
65014: ST_TO_ADDR
// end ;
65015: LD_VAR 0 1
65019: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
65020: LD_INT 0
65022: PPUSH
65023: PPUSH
65024: PPUSH
65025: PPUSH
65026: PPUSH
65027: PPUSH
// if not mc_bases then
65028: LD_EXP 86
65032: NOT
65033: IFFALSE 65037
// exit ;
65035: GO 65276
// for i = 1 to 8 do
65037: LD_ADDR_VAR 0 2
65041: PUSH
65042: DOUBLE
65043: LD_INT 1
65045: DEC
65046: ST_TO_ADDR
65047: LD_INT 8
65049: PUSH
65050: FOR_TO
65051: IFFALSE 65077
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
65053: LD_ADDR_EXP 113
65057: PUSH
65058: LD_EXP 113
65062: PPUSH
65063: LD_VAR 0 2
65067: PPUSH
65068: EMPTY
65069: PPUSH
65070: CALL_OW 1
65074: ST_TO_ADDR
65075: GO 65050
65077: POP
65078: POP
// tmp := [ ] ;
65079: LD_ADDR_VAR 0 5
65083: PUSH
65084: EMPTY
65085: ST_TO_ADDR
// for i = 1 to mc_sides do
65086: LD_ADDR_VAR 0 2
65090: PUSH
65091: DOUBLE
65092: LD_INT 1
65094: DEC
65095: ST_TO_ADDR
65096: LD_EXP 112
65100: PUSH
65101: FOR_TO
65102: IFFALSE 65160
// if not mc_sides [ i ] in tmp then
65104: LD_EXP 112
65108: PUSH
65109: LD_VAR 0 2
65113: ARRAY
65114: PUSH
65115: LD_VAR 0 5
65119: IN
65120: NOT
65121: IFFALSE 65158
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
65123: LD_ADDR_VAR 0 5
65127: PUSH
65128: LD_VAR 0 5
65132: PPUSH
65133: LD_VAR 0 5
65137: PUSH
65138: LD_INT 1
65140: PLUS
65141: PPUSH
65142: LD_EXP 112
65146: PUSH
65147: LD_VAR 0 2
65151: ARRAY
65152: PPUSH
65153: CALL_OW 2
65157: ST_TO_ADDR
65158: GO 65101
65160: POP
65161: POP
// if not tmp then
65162: LD_VAR 0 5
65166: NOT
65167: IFFALSE 65171
// exit ;
65169: GO 65276
// for j in tmp do
65171: LD_ADDR_VAR 0 3
65175: PUSH
65176: LD_VAR 0 5
65180: PUSH
65181: FOR_IN
65182: IFFALSE 65274
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
65184: LD_ADDR_VAR 0 6
65188: PUSH
65189: LD_INT 22
65191: PUSH
65192: LD_VAR 0 3
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PPUSH
65201: CALL_OW 69
65205: ST_TO_ADDR
// if not un then
65206: LD_VAR 0 6
65210: NOT
65211: IFFALSE 65215
// continue ;
65213: GO 65181
// nation := GetNation ( un [ 1 ] ) ;
65215: LD_ADDR_VAR 0 4
65219: PUSH
65220: LD_VAR 0 6
65224: PUSH
65225: LD_INT 1
65227: ARRAY
65228: PPUSH
65229: CALL_OW 248
65233: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
65234: LD_ADDR_EXP 113
65238: PUSH
65239: LD_EXP 113
65243: PPUSH
65244: LD_VAR 0 3
65248: PPUSH
65249: LD_VAR 0 3
65253: PPUSH
65254: LD_VAR 0 4
65258: PPUSH
65259: LD_INT 1
65261: PPUSH
65262: CALL 17594 0 3
65266: PPUSH
65267: CALL_OW 1
65271: ST_TO_ADDR
// end ;
65272: GO 65181
65274: POP
65275: POP
// end ;
65276: LD_VAR 0 1
65280: RET
// export function MC_InitSides ( ) ; var i ; begin
65281: LD_INT 0
65283: PPUSH
65284: PPUSH
// if not mc_bases then
65285: LD_EXP 86
65289: NOT
65290: IFFALSE 65294
// exit ;
65292: GO 65368
// for i = 1 to mc_bases do
65294: LD_ADDR_VAR 0 2
65298: PUSH
65299: DOUBLE
65300: LD_INT 1
65302: DEC
65303: ST_TO_ADDR
65304: LD_EXP 86
65308: PUSH
65309: FOR_TO
65310: IFFALSE 65366
// if mc_bases [ i ] then
65312: LD_EXP 86
65316: PUSH
65317: LD_VAR 0 2
65321: ARRAY
65322: IFFALSE 65364
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
65324: LD_ADDR_EXP 112
65328: PUSH
65329: LD_EXP 112
65333: PPUSH
65334: LD_VAR 0 2
65338: PPUSH
65339: LD_EXP 86
65343: PUSH
65344: LD_VAR 0 2
65348: ARRAY
65349: PUSH
65350: LD_INT 1
65352: ARRAY
65353: PPUSH
65354: CALL_OW 255
65358: PPUSH
65359: CALL_OW 1
65363: ST_TO_ADDR
65364: GO 65309
65366: POP
65367: POP
// end ;
65368: LD_VAR 0 1
65372: RET
// every 0 0$01 trigger skirmish do
65373: LD_EXP 84
65377: IFFALSE 65531
65379: GO 65381
65381: DISABLE
// begin enable ;
65382: ENABLE
// MC_CheckBuildings ( ) ;
65383: CALL 70029 0 0
// MC_CheckPeopleLife ( ) ;
65387: CALL 70154 0 0
// RaiseSailEvent ( 100 ) ;
65391: LD_INT 100
65393: PPUSH
65394: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65398: LD_INT 103
65400: PPUSH
65401: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65405: LD_INT 104
65407: PPUSH
65408: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65412: LD_INT 105
65414: PPUSH
65415: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65419: LD_INT 106
65421: PPUSH
65422: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65426: LD_INT 107
65428: PPUSH
65429: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65433: LD_INT 108
65435: PPUSH
65436: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65440: LD_INT 109
65442: PPUSH
65443: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65447: LD_INT 110
65449: PPUSH
65450: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65454: LD_INT 111
65456: PPUSH
65457: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65461: LD_INT 112
65463: PPUSH
65464: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65468: LD_INT 113
65470: PPUSH
65471: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65475: LD_INT 120
65477: PPUSH
65478: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65482: LD_INT 121
65484: PPUSH
65485: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65489: LD_INT 122
65491: PPUSH
65492: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65496: LD_INT 123
65498: PPUSH
65499: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65503: LD_INT 124
65505: PPUSH
65506: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65510: LD_INT 125
65512: PPUSH
65513: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65517: LD_INT 126
65519: PPUSH
65520: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65524: LD_INT 200
65526: PPUSH
65527: CALL_OW 427
// end ;
65531: END
// on SailEvent ( event ) do begin if event < 100 then
65532: LD_VAR 0 1
65536: PUSH
65537: LD_INT 100
65539: LESS
65540: IFFALSE 65551
// CustomEvent ( event ) ;
65542: LD_VAR 0 1
65546: PPUSH
65547: CALL 8 0 1
// if event = 100 then
65551: LD_VAR 0 1
65555: PUSH
65556: LD_INT 100
65558: EQUAL
65559: IFFALSE 65565
// MC_ClassManager ( ) ;
65561: CALL 65957 0 0
// if event = 101 then
65565: LD_VAR 0 1
65569: PUSH
65570: LD_INT 101
65572: EQUAL
65573: IFFALSE 65579
// MC_RepairBuildings ( ) ;
65575: CALL 70739 0 0
// if event = 102 then
65579: LD_VAR 0 1
65583: PUSH
65584: LD_INT 102
65586: EQUAL
65587: IFFALSE 65593
// MC_Heal ( ) ;
65589: CALL 71624 0 0
// if event = 103 then
65593: LD_VAR 0 1
65597: PUSH
65598: LD_INT 103
65600: EQUAL
65601: IFFALSE 65607
// MC_Build ( ) ;
65603: CALL 72046 0 0
// if event = 104 then
65607: LD_VAR 0 1
65611: PUSH
65612: LD_INT 104
65614: EQUAL
65615: IFFALSE 65621
// MC_TurretWeapon ( ) ;
65617: CALL 73659 0 0
// if event = 105 then
65621: LD_VAR 0 1
65625: PUSH
65626: LD_INT 105
65628: EQUAL
65629: IFFALSE 65635
// MC_BuildUpgrade ( ) ;
65631: CALL 73210 0 0
// if event = 106 then
65635: LD_VAR 0 1
65639: PUSH
65640: LD_INT 106
65642: EQUAL
65643: IFFALSE 65649
// MC_PlantMines ( ) ;
65645: CALL 74089 0 0
// if event = 107 then
65649: LD_VAR 0 1
65653: PUSH
65654: LD_INT 107
65656: EQUAL
65657: IFFALSE 65663
// MC_CollectCrates ( ) ;
65659: CALL 74887 0 0
// if event = 108 then
65663: LD_VAR 0 1
65667: PUSH
65668: LD_INT 108
65670: EQUAL
65671: IFFALSE 65677
// MC_LinkRemoteControl ( ) ;
65673: CALL 76663 0 0
// if event = 109 then
65677: LD_VAR 0 1
65681: PUSH
65682: LD_INT 109
65684: EQUAL
65685: IFFALSE 65691
// MC_ProduceVehicle ( ) ;
65687: CALL 76844 0 0
// if event = 110 then
65691: LD_VAR 0 1
65695: PUSH
65696: LD_INT 110
65698: EQUAL
65699: IFFALSE 65705
// MC_SendAttack ( ) ;
65701: CALL 77310 0 0
// if event = 111 then
65705: LD_VAR 0 1
65709: PUSH
65710: LD_INT 111
65712: EQUAL
65713: IFFALSE 65719
// MC_Defend ( ) ;
65715: CALL 77418 0 0
// if event = 112 then
65719: LD_VAR 0 1
65723: PUSH
65724: LD_INT 112
65726: EQUAL
65727: IFFALSE 65733
// MC_Research ( ) ;
65729: CALL 78045 0 0
// if event = 113 then
65733: LD_VAR 0 1
65737: PUSH
65738: LD_INT 113
65740: EQUAL
65741: IFFALSE 65747
// MC_MinesTrigger ( ) ;
65743: CALL 79159 0 0
// if event = 120 then
65747: LD_VAR 0 1
65751: PUSH
65752: LD_INT 120
65754: EQUAL
65755: IFFALSE 65761
// MC_RepairVehicle ( ) ;
65757: CALL 79258 0 0
// if event = 121 then
65761: LD_VAR 0 1
65765: PUSH
65766: LD_INT 121
65768: EQUAL
65769: IFFALSE 65775
// MC_TameApe ( ) ;
65771: CALL 79988 0 0
// if event = 122 then
65775: LD_VAR 0 1
65779: PUSH
65780: LD_INT 122
65782: EQUAL
65783: IFFALSE 65789
// MC_ChangeApeClass ( ) ;
65785: CALL 80817 0 0
// if event = 123 then
65789: LD_VAR 0 1
65793: PUSH
65794: LD_INT 123
65796: EQUAL
65797: IFFALSE 65803
// MC_Bazooka ( ) ;
65799: CALL 81467 0 0
// if event = 124 then
65803: LD_VAR 0 1
65807: PUSH
65808: LD_INT 124
65810: EQUAL
65811: IFFALSE 65817
// MC_TeleportExit ( ) ;
65813: CALL 81665 0 0
// if event = 125 then
65817: LD_VAR 0 1
65821: PUSH
65822: LD_INT 125
65824: EQUAL
65825: IFFALSE 65831
// MC_Deposits ( ) ;
65827: CALL 82312 0 0
// if event = 126 then
65831: LD_VAR 0 1
65835: PUSH
65836: LD_INT 126
65838: EQUAL
65839: IFFALSE 65845
// MC_RemoteDriver ( ) ;
65841: CALL 82937 0 0
// if event = 200 then
65845: LD_VAR 0 1
65849: PUSH
65850: LD_INT 200
65852: EQUAL
65853: IFFALSE 65859
// MC_Idle ( ) ;
65855: CALL 84886 0 0
// end ;
65859: PPOPN 1
65861: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65862: LD_INT 0
65864: PPUSH
65865: PPUSH
// if not mc_bases [ base ] or not tag then
65866: LD_EXP 86
65870: PUSH
65871: LD_VAR 0 1
65875: ARRAY
65876: NOT
65877: PUSH
65878: LD_VAR 0 2
65882: NOT
65883: OR
65884: IFFALSE 65888
// exit ;
65886: GO 65952
// for i in mc_bases [ base ] union mc_ape [ base ] do
65888: LD_ADDR_VAR 0 4
65892: PUSH
65893: LD_EXP 86
65897: PUSH
65898: LD_VAR 0 1
65902: ARRAY
65903: PUSH
65904: LD_EXP 115
65908: PUSH
65909: LD_VAR 0 1
65913: ARRAY
65914: UNION
65915: PUSH
65916: FOR_IN
65917: IFFALSE 65950
// if GetTag ( i ) = tag then
65919: LD_VAR 0 4
65923: PPUSH
65924: CALL_OW 110
65928: PUSH
65929: LD_VAR 0 2
65933: EQUAL
65934: IFFALSE 65948
// SetTag ( i , 0 ) ;
65936: LD_VAR 0 4
65940: PPUSH
65941: LD_INT 0
65943: PPUSH
65944: CALL_OW 109
65948: GO 65916
65950: POP
65951: POP
// end ;
65952: LD_VAR 0 3
65956: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65957: LD_INT 0
65959: PPUSH
65960: PPUSH
65961: PPUSH
65962: PPUSH
65963: PPUSH
65964: PPUSH
65965: PPUSH
65966: PPUSH
// if not mc_bases then
65967: LD_EXP 86
65971: NOT
65972: IFFALSE 65976
// exit ;
65974: GO 66434
// for i = 1 to mc_bases do
65976: LD_ADDR_VAR 0 2
65980: PUSH
65981: DOUBLE
65982: LD_INT 1
65984: DEC
65985: ST_TO_ADDR
65986: LD_EXP 86
65990: PUSH
65991: FOR_TO
65992: IFFALSE 66432
// begin tmp := MC_ClassCheckReq ( i ) ;
65994: LD_ADDR_VAR 0 4
65998: PUSH
65999: LD_VAR 0 2
66003: PPUSH
66004: CALL 66439 0 1
66008: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
66009: LD_ADDR_EXP 127
66013: PUSH
66014: LD_EXP 127
66018: PPUSH
66019: LD_VAR 0 2
66023: PPUSH
66024: LD_VAR 0 4
66028: PPUSH
66029: CALL_OW 1
66033: ST_TO_ADDR
// if not tmp then
66034: LD_VAR 0 4
66038: NOT
66039: IFFALSE 66043
// continue ;
66041: GO 65991
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
66043: LD_ADDR_VAR 0 6
66047: PUSH
66048: LD_EXP 86
66052: PUSH
66053: LD_VAR 0 2
66057: ARRAY
66058: PPUSH
66059: LD_INT 2
66061: PUSH
66062: LD_INT 30
66064: PUSH
66065: LD_INT 4
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 30
66074: PUSH
66075: LD_INT 5
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: LIST
66086: PPUSH
66087: CALL_OW 72
66091: PUSH
66092: LD_EXP 86
66096: PUSH
66097: LD_VAR 0 2
66101: ARRAY
66102: PPUSH
66103: LD_INT 2
66105: PUSH
66106: LD_INT 30
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 30
66118: PUSH
66119: LD_INT 1
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: LIST
66130: PPUSH
66131: CALL_OW 72
66135: PUSH
66136: LD_EXP 86
66140: PUSH
66141: LD_VAR 0 2
66145: ARRAY
66146: PPUSH
66147: LD_INT 30
66149: PUSH
66150: LD_INT 3
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PPUSH
66157: CALL_OW 72
66161: PUSH
66162: LD_EXP 86
66166: PUSH
66167: LD_VAR 0 2
66171: ARRAY
66172: PPUSH
66173: LD_INT 2
66175: PUSH
66176: LD_INT 30
66178: PUSH
66179: LD_INT 6
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: PUSH
66186: LD_INT 30
66188: PUSH
66189: LD_INT 7
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 30
66198: PUSH
66199: LD_INT 8
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: PPUSH
66212: CALL_OW 72
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: ST_TO_ADDR
// for j = 1 to 4 do
66223: LD_ADDR_VAR 0 3
66227: PUSH
66228: DOUBLE
66229: LD_INT 1
66231: DEC
66232: ST_TO_ADDR
66233: LD_INT 4
66235: PUSH
66236: FOR_TO
66237: IFFALSE 66428
// begin if not tmp [ j ] then
66239: LD_VAR 0 4
66243: PUSH
66244: LD_VAR 0 3
66248: ARRAY
66249: NOT
66250: IFFALSE 66254
// continue ;
66252: GO 66236
// for p in tmp [ j ] do
66254: LD_ADDR_VAR 0 5
66258: PUSH
66259: LD_VAR 0 4
66263: PUSH
66264: LD_VAR 0 3
66268: ARRAY
66269: PUSH
66270: FOR_IN
66271: IFFALSE 66424
// begin if not b [ j ] then
66273: LD_VAR 0 6
66277: PUSH
66278: LD_VAR 0 3
66282: ARRAY
66283: NOT
66284: IFFALSE 66288
// break ;
66286: GO 66424
// e := 0 ;
66288: LD_ADDR_VAR 0 7
66292: PUSH
66293: LD_INT 0
66295: ST_TO_ADDR
// for k in b [ j ] do
66296: LD_ADDR_VAR 0 8
66300: PUSH
66301: LD_VAR 0 6
66305: PUSH
66306: LD_VAR 0 3
66310: ARRAY
66311: PUSH
66312: FOR_IN
66313: IFFALSE 66340
// if IsNotFull ( k ) then
66315: LD_VAR 0 8
66319: PPUSH
66320: CALL 19743 0 1
66324: IFFALSE 66338
// begin e := k ;
66326: LD_ADDR_VAR 0 7
66330: PUSH
66331: LD_VAR 0 8
66335: ST_TO_ADDR
// break ;
66336: GO 66340
// end ;
66338: GO 66312
66340: POP
66341: POP
// if e and not UnitGoingToBuilding ( p , e ) then
66342: LD_VAR 0 7
66346: PUSH
66347: LD_VAR 0 5
66351: PPUSH
66352: LD_VAR 0 7
66356: PPUSH
66357: CALL 52163 0 2
66361: NOT
66362: AND
66363: IFFALSE 66422
// begin if IsInUnit ( p ) then
66365: LD_VAR 0 5
66369: PPUSH
66370: CALL_OW 310
66374: IFFALSE 66385
// ComExitBuilding ( p ) ;
66376: LD_VAR 0 5
66380: PPUSH
66381: CALL_OW 122
// ComEnterUnit ( p , e ) ;
66385: LD_VAR 0 5
66389: PPUSH
66390: LD_VAR 0 7
66394: PPUSH
66395: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66399: LD_VAR 0 5
66403: PPUSH
66404: LD_VAR 0 3
66408: PPUSH
66409: CALL_OW 183
// AddComExitBuilding ( p ) ;
66413: LD_VAR 0 5
66417: PPUSH
66418: CALL_OW 182
// end ; end ;
66422: GO 66270
66424: POP
66425: POP
// end ;
66426: GO 66236
66428: POP
66429: POP
// end ;
66430: GO 65991
66432: POP
66433: POP
// end ;
66434: LD_VAR 0 1
66438: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66439: LD_INT 0
66441: PPUSH
66442: PPUSH
66443: PPUSH
66444: PPUSH
66445: PPUSH
66446: PPUSH
66447: PPUSH
66448: PPUSH
66449: PPUSH
66450: PPUSH
66451: PPUSH
66452: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66453: LD_VAR 0 1
66457: NOT
66458: PUSH
66459: LD_EXP 86
66463: PUSH
66464: LD_VAR 0 1
66468: ARRAY
66469: NOT
66470: OR
66471: PUSH
66472: LD_EXP 86
66476: PUSH
66477: LD_VAR 0 1
66481: ARRAY
66482: PPUSH
66483: LD_INT 2
66485: PUSH
66486: LD_INT 30
66488: PUSH
66489: LD_INT 0
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 30
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: LIST
66510: PPUSH
66511: CALL_OW 72
66515: NOT
66516: OR
66517: IFFALSE 66521
// exit ;
66519: GO 70024
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66521: LD_ADDR_VAR 0 4
66525: PUSH
66526: LD_EXP 86
66530: PUSH
66531: LD_VAR 0 1
66535: ARRAY
66536: PPUSH
66537: LD_INT 2
66539: PUSH
66540: LD_INT 25
66542: PUSH
66543: LD_INT 1
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 25
66552: PUSH
66553: LD_INT 2
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 25
66562: PUSH
66563: LD_INT 3
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 25
66572: PUSH
66573: LD_INT 4
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 25
66582: PUSH
66583: LD_INT 5
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 25
66592: PUSH
66593: LD_INT 8
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 25
66602: PUSH
66603: LD_INT 9
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: PPUSH
66620: CALL_OW 72
66624: ST_TO_ADDR
// if not tmp then
66625: LD_VAR 0 4
66629: NOT
66630: IFFALSE 66634
// exit ;
66632: GO 70024
// for i in tmp do
66634: LD_ADDR_VAR 0 3
66638: PUSH
66639: LD_VAR 0 4
66643: PUSH
66644: FOR_IN
66645: IFFALSE 66676
// if GetTag ( i ) then
66647: LD_VAR 0 3
66651: PPUSH
66652: CALL_OW 110
66656: IFFALSE 66674
// tmp := tmp diff i ;
66658: LD_ADDR_VAR 0 4
66662: PUSH
66663: LD_VAR 0 4
66667: PUSH
66668: LD_VAR 0 3
66672: DIFF
66673: ST_TO_ADDR
66674: GO 66644
66676: POP
66677: POP
// if not tmp then
66678: LD_VAR 0 4
66682: NOT
66683: IFFALSE 66687
// exit ;
66685: GO 70024
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66687: LD_ADDR_VAR 0 5
66691: PUSH
66692: LD_EXP 86
66696: PUSH
66697: LD_VAR 0 1
66701: ARRAY
66702: PPUSH
66703: LD_INT 2
66705: PUSH
66706: LD_INT 25
66708: PUSH
66709: LD_INT 1
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 25
66718: PUSH
66719: LD_INT 5
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 25
66728: PUSH
66729: LD_INT 8
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: LD_INT 25
66738: PUSH
66739: LD_INT 9
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: PPUSH
66753: CALL_OW 72
66757: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66758: LD_ADDR_VAR 0 6
66762: PUSH
66763: LD_EXP 86
66767: PUSH
66768: LD_VAR 0 1
66772: ARRAY
66773: PPUSH
66774: LD_INT 25
66776: PUSH
66777: LD_INT 2
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PPUSH
66784: CALL_OW 72
66788: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66789: LD_ADDR_VAR 0 7
66793: PUSH
66794: LD_EXP 86
66798: PUSH
66799: LD_VAR 0 1
66803: ARRAY
66804: PPUSH
66805: LD_INT 25
66807: PUSH
66808: LD_INT 3
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PPUSH
66815: CALL_OW 72
66819: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66820: LD_ADDR_VAR 0 8
66824: PUSH
66825: LD_EXP 86
66829: PUSH
66830: LD_VAR 0 1
66834: ARRAY
66835: PPUSH
66836: LD_INT 25
66838: PUSH
66839: LD_INT 4
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 24
66848: PUSH
66849: LD_INT 251
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PPUSH
66860: CALL_OW 72
66864: ST_TO_ADDR
// if mc_scan [ base ] then
66865: LD_EXP 109
66869: PUSH
66870: LD_VAR 0 1
66874: ARRAY
66875: IFFALSE 67336
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66877: LD_ADDR_EXP 128
66881: PUSH
66882: LD_EXP 128
66886: PPUSH
66887: LD_VAR 0 1
66891: PPUSH
66892: LD_INT 4
66894: PPUSH
66895: CALL_OW 1
66899: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66900: LD_ADDR_VAR 0 12
66904: PUSH
66905: LD_EXP 86
66909: PUSH
66910: LD_VAR 0 1
66914: ARRAY
66915: PPUSH
66916: LD_INT 2
66918: PUSH
66919: LD_INT 30
66921: PUSH
66922: LD_INT 4
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 30
66931: PUSH
66932: LD_INT 5
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: PPUSH
66944: CALL_OW 72
66948: ST_TO_ADDR
// if not b then
66949: LD_VAR 0 12
66953: NOT
66954: IFFALSE 66958
// exit ;
66956: GO 70024
// p := [ ] ;
66958: LD_ADDR_VAR 0 11
66962: PUSH
66963: EMPTY
66964: ST_TO_ADDR
// if sci >= 2 then
66965: LD_VAR 0 8
66969: PUSH
66970: LD_INT 2
66972: GREATEREQUAL
66973: IFFALSE 67004
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66975: LD_ADDR_VAR 0 8
66979: PUSH
66980: LD_VAR 0 8
66984: PUSH
66985: LD_INT 1
66987: ARRAY
66988: PUSH
66989: LD_VAR 0 8
66993: PUSH
66994: LD_INT 2
66996: ARRAY
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: ST_TO_ADDR
67002: GO 67065
// if sci = 1 then
67004: LD_VAR 0 8
67008: PUSH
67009: LD_INT 1
67011: EQUAL
67012: IFFALSE 67033
// sci := [ sci [ 1 ] ] else
67014: LD_ADDR_VAR 0 8
67018: PUSH
67019: LD_VAR 0 8
67023: PUSH
67024: LD_INT 1
67026: ARRAY
67027: PUSH
67028: EMPTY
67029: LIST
67030: ST_TO_ADDR
67031: GO 67065
// if sci = 0 then
67033: LD_VAR 0 8
67037: PUSH
67038: LD_INT 0
67040: EQUAL
67041: IFFALSE 67065
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
67043: LD_ADDR_VAR 0 11
67047: PUSH
67048: LD_VAR 0 4
67052: PPUSH
67053: LD_INT 4
67055: PPUSH
67056: CALL 52026 0 2
67060: PUSH
67061: LD_INT 1
67063: ARRAY
67064: ST_TO_ADDR
// if eng > 4 then
67065: LD_VAR 0 6
67069: PUSH
67070: LD_INT 4
67072: GREATER
67073: IFFALSE 67119
// for i = eng downto 4 do
67075: LD_ADDR_VAR 0 3
67079: PUSH
67080: DOUBLE
67081: LD_VAR 0 6
67085: INC
67086: ST_TO_ADDR
67087: LD_INT 4
67089: PUSH
67090: FOR_DOWNTO
67091: IFFALSE 67117
// eng := eng diff eng [ i ] ;
67093: LD_ADDR_VAR 0 6
67097: PUSH
67098: LD_VAR 0 6
67102: PUSH
67103: LD_VAR 0 6
67107: PUSH
67108: LD_VAR 0 3
67112: ARRAY
67113: DIFF
67114: ST_TO_ADDR
67115: GO 67090
67117: POP
67118: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
67119: LD_ADDR_VAR 0 4
67123: PUSH
67124: LD_VAR 0 4
67128: PUSH
67129: LD_VAR 0 5
67133: PUSH
67134: LD_VAR 0 6
67138: UNION
67139: PUSH
67140: LD_VAR 0 7
67144: UNION
67145: PUSH
67146: LD_VAR 0 8
67150: UNION
67151: DIFF
67152: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
67153: LD_ADDR_VAR 0 13
67157: PUSH
67158: LD_EXP 86
67162: PUSH
67163: LD_VAR 0 1
67167: ARRAY
67168: PPUSH
67169: LD_INT 2
67171: PUSH
67172: LD_INT 30
67174: PUSH
67175: LD_INT 32
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 30
67184: PUSH
67185: LD_INT 31
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: LIST
67196: PPUSH
67197: CALL_OW 72
67201: PUSH
67202: LD_EXP 86
67206: PUSH
67207: LD_VAR 0 1
67211: ARRAY
67212: PPUSH
67213: LD_INT 2
67215: PUSH
67216: LD_INT 30
67218: PUSH
67219: LD_INT 4
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 30
67228: PUSH
67229: LD_INT 5
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: LIST
67240: PPUSH
67241: CALL_OW 72
67245: PUSH
67246: LD_INT 6
67248: MUL
67249: PLUS
67250: ST_TO_ADDR
// if bcount < tmp then
67251: LD_VAR 0 13
67255: PUSH
67256: LD_VAR 0 4
67260: LESS
67261: IFFALSE 67307
// for i = tmp downto bcount do
67263: LD_ADDR_VAR 0 3
67267: PUSH
67268: DOUBLE
67269: LD_VAR 0 4
67273: INC
67274: ST_TO_ADDR
67275: LD_VAR 0 13
67279: PUSH
67280: FOR_DOWNTO
67281: IFFALSE 67305
// tmp := Delete ( tmp , tmp ) ;
67283: LD_ADDR_VAR 0 4
67287: PUSH
67288: LD_VAR 0 4
67292: PPUSH
67293: LD_VAR 0 4
67297: PPUSH
67298: CALL_OW 3
67302: ST_TO_ADDR
67303: GO 67280
67305: POP
67306: POP
// result := [ tmp , 0 , 0 , p ] ;
67307: LD_ADDR_VAR 0 2
67311: PUSH
67312: LD_VAR 0 4
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_VAR 0 11
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: ST_TO_ADDR
// exit ;
67334: GO 70024
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67336: LD_EXP 86
67340: PUSH
67341: LD_VAR 0 1
67345: ARRAY
67346: PPUSH
67347: LD_INT 2
67349: PUSH
67350: LD_INT 30
67352: PUSH
67353: LD_INT 6
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 30
67362: PUSH
67363: LD_INT 7
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 30
67372: PUSH
67373: LD_INT 8
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: PPUSH
67386: CALL_OW 72
67390: NOT
67391: PUSH
67392: LD_EXP 86
67396: PUSH
67397: LD_VAR 0 1
67401: ARRAY
67402: PPUSH
67403: LD_INT 30
67405: PUSH
67406: LD_INT 3
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: PPUSH
67413: CALL_OW 72
67417: NOT
67418: AND
67419: IFFALSE 67491
// begin if eng = tmp then
67421: LD_VAR 0 6
67425: PUSH
67426: LD_VAR 0 4
67430: EQUAL
67431: IFFALSE 67435
// exit ;
67433: GO 70024
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67435: LD_ADDR_EXP 128
67439: PUSH
67440: LD_EXP 128
67444: PPUSH
67445: LD_VAR 0 1
67449: PPUSH
67450: LD_INT 1
67452: PPUSH
67453: CALL_OW 1
67457: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67458: LD_ADDR_VAR 0 2
67462: PUSH
67463: LD_INT 0
67465: PUSH
67466: LD_VAR 0 4
67470: PUSH
67471: LD_VAR 0 6
67475: DIFF
67476: PUSH
67477: LD_INT 0
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: ST_TO_ADDR
// exit ;
67489: GO 70024
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67491: LD_EXP 113
67495: PUSH
67496: LD_EXP 112
67500: PUSH
67501: LD_VAR 0 1
67505: ARRAY
67506: ARRAY
67507: PUSH
67508: LD_EXP 86
67512: PUSH
67513: LD_VAR 0 1
67517: ARRAY
67518: PPUSH
67519: LD_INT 2
67521: PUSH
67522: LD_INT 30
67524: PUSH
67525: LD_INT 6
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 30
67534: PUSH
67535: LD_INT 7
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 30
67544: PUSH
67545: LD_INT 8
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: PPUSH
67558: CALL_OW 72
67562: AND
67563: PUSH
67564: LD_EXP 86
67568: PUSH
67569: LD_VAR 0 1
67573: ARRAY
67574: PPUSH
67575: LD_INT 30
67577: PUSH
67578: LD_INT 3
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PPUSH
67585: CALL_OW 72
67589: NOT
67590: AND
67591: IFFALSE 67805
// begin if sci >= 6 then
67593: LD_VAR 0 8
67597: PUSH
67598: LD_INT 6
67600: GREATEREQUAL
67601: IFFALSE 67605
// exit ;
67603: GO 70024
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67605: LD_ADDR_EXP 128
67609: PUSH
67610: LD_EXP 128
67614: PPUSH
67615: LD_VAR 0 1
67619: PPUSH
67620: LD_INT 2
67622: PPUSH
67623: CALL_OW 1
67627: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67628: LD_ADDR_VAR 0 9
67632: PUSH
67633: LD_VAR 0 4
67637: PUSH
67638: LD_VAR 0 8
67642: DIFF
67643: PPUSH
67644: LD_INT 4
67646: PPUSH
67647: CALL 52026 0 2
67651: ST_TO_ADDR
// p := [ ] ;
67652: LD_ADDR_VAR 0 11
67656: PUSH
67657: EMPTY
67658: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67659: LD_VAR 0 8
67663: PUSH
67664: LD_INT 6
67666: LESS
67667: PUSH
67668: LD_VAR 0 9
67672: PUSH
67673: LD_INT 6
67675: GREATER
67676: AND
67677: IFFALSE 67758
// begin for i = 1 to 6 - sci do
67679: LD_ADDR_VAR 0 3
67683: PUSH
67684: DOUBLE
67685: LD_INT 1
67687: DEC
67688: ST_TO_ADDR
67689: LD_INT 6
67691: PUSH
67692: LD_VAR 0 8
67696: MINUS
67697: PUSH
67698: FOR_TO
67699: IFFALSE 67754
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67701: LD_ADDR_VAR 0 11
67705: PUSH
67706: LD_VAR 0 11
67710: PPUSH
67711: LD_VAR 0 11
67715: PUSH
67716: LD_INT 1
67718: PLUS
67719: PPUSH
67720: LD_VAR 0 9
67724: PUSH
67725: LD_INT 1
67727: ARRAY
67728: PPUSH
67729: CALL_OW 2
67733: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67734: LD_ADDR_VAR 0 9
67738: PUSH
67739: LD_VAR 0 9
67743: PPUSH
67744: LD_INT 1
67746: PPUSH
67747: CALL_OW 3
67751: ST_TO_ADDR
// end ;
67752: GO 67698
67754: POP
67755: POP
// end else
67756: GO 67778
// if sort then
67758: LD_VAR 0 9
67762: IFFALSE 67778
// p := sort [ 1 ] ;
67764: LD_ADDR_VAR 0 11
67768: PUSH
67769: LD_VAR 0 9
67773: PUSH
67774: LD_INT 1
67776: ARRAY
67777: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67778: LD_ADDR_VAR 0 2
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: LD_INT 0
67791: PUSH
67792: LD_VAR 0 11
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: ST_TO_ADDR
// exit ;
67803: GO 70024
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67805: LD_EXP 113
67809: PUSH
67810: LD_EXP 112
67814: PUSH
67815: LD_VAR 0 1
67819: ARRAY
67820: ARRAY
67821: PUSH
67822: LD_EXP 86
67826: PUSH
67827: LD_VAR 0 1
67831: ARRAY
67832: PPUSH
67833: LD_INT 2
67835: PUSH
67836: LD_INT 30
67838: PUSH
67839: LD_INT 6
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 30
67848: PUSH
67849: LD_INT 7
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 30
67858: PUSH
67859: LD_INT 8
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: PPUSH
67872: CALL_OW 72
67876: AND
67877: PUSH
67878: LD_EXP 86
67882: PUSH
67883: LD_VAR 0 1
67887: ARRAY
67888: PPUSH
67889: LD_INT 30
67891: PUSH
67892: LD_INT 3
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PPUSH
67899: CALL_OW 72
67903: AND
67904: IFFALSE 68638
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67906: LD_ADDR_EXP 128
67910: PUSH
67911: LD_EXP 128
67915: PPUSH
67916: LD_VAR 0 1
67920: PPUSH
67921: LD_INT 3
67923: PPUSH
67924: CALL_OW 1
67928: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67929: LD_ADDR_VAR 0 2
67933: PUSH
67934: LD_INT 0
67936: PUSH
67937: LD_INT 0
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: ST_TO_ADDR
// if not eng then
67952: LD_VAR 0 6
67956: NOT
67957: IFFALSE 68020
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67959: LD_ADDR_VAR 0 11
67963: PUSH
67964: LD_VAR 0 4
67968: PPUSH
67969: LD_INT 2
67971: PPUSH
67972: CALL 52026 0 2
67976: PUSH
67977: LD_INT 1
67979: ARRAY
67980: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67981: LD_ADDR_VAR 0 2
67985: PUSH
67986: LD_VAR 0 2
67990: PPUSH
67991: LD_INT 2
67993: PPUSH
67994: LD_VAR 0 11
67998: PPUSH
67999: CALL_OW 1
68003: ST_TO_ADDR
// tmp := tmp diff p ;
68004: LD_ADDR_VAR 0 4
68008: PUSH
68009: LD_VAR 0 4
68013: PUSH
68014: LD_VAR 0 11
68018: DIFF
68019: ST_TO_ADDR
// end ; if tmp and sci < 6 then
68020: LD_VAR 0 4
68024: PUSH
68025: LD_VAR 0 8
68029: PUSH
68030: LD_INT 6
68032: LESS
68033: AND
68034: IFFALSE 68222
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
68036: LD_ADDR_VAR 0 9
68040: PUSH
68041: LD_VAR 0 4
68045: PUSH
68046: LD_VAR 0 8
68050: PUSH
68051: LD_VAR 0 7
68055: UNION
68056: DIFF
68057: PPUSH
68058: LD_INT 4
68060: PPUSH
68061: CALL 52026 0 2
68065: ST_TO_ADDR
// p := [ ] ;
68066: LD_ADDR_VAR 0 11
68070: PUSH
68071: EMPTY
68072: ST_TO_ADDR
// if sort then
68073: LD_VAR 0 9
68077: IFFALSE 68193
// for i = 1 to 6 - sci do
68079: LD_ADDR_VAR 0 3
68083: PUSH
68084: DOUBLE
68085: LD_INT 1
68087: DEC
68088: ST_TO_ADDR
68089: LD_INT 6
68091: PUSH
68092: LD_VAR 0 8
68096: MINUS
68097: PUSH
68098: FOR_TO
68099: IFFALSE 68191
// begin if i = sort then
68101: LD_VAR 0 3
68105: PUSH
68106: LD_VAR 0 9
68110: EQUAL
68111: IFFALSE 68115
// break ;
68113: GO 68191
// if GetClass ( i ) = 4 then
68115: LD_VAR 0 3
68119: PPUSH
68120: CALL_OW 257
68124: PUSH
68125: LD_INT 4
68127: EQUAL
68128: IFFALSE 68132
// continue ;
68130: GO 68098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68132: LD_ADDR_VAR 0 11
68136: PUSH
68137: LD_VAR 0 11
68141: PPUSH
68142: LD_VAR 0 11
68146: PUSH
68147: LD_INT 1
68149: PLUS
68150: PPUSH
68151: LD_VAR 0 9
68155: PUSH
68156: LD_VAR 0 3
68160: ARRAY
68161: PPUSH
68162: CALL_OW 2
68166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68167: LD_ADDR_VAR 0 4
68171: PUSH
68172: LD_VAR 0 4
68176: PUSH
68177: LD_VAR 0 9
68181: PUSH
68182: LD_VAR 0 3
68186: ARRAY
68187: DIFF
68188: ST_TO_ADDR
// end ;
68189: GO 68098
68191: POP
68192: POP
// if p then
68193: LD_VAR 0 11
68197: IFFALSE 68222
// result := Replace ( result , 4 , p ) ;
68199: LD_ADDR_VAR 0 2
68203: PUSH
68204: LD_VAR 0 2
68208: PPUSH
68209: LD_INT 4
68211: PPUSH
68212: LD_VAR 0 11
68216: PPUSH
68217: CALL_OW 1
68221: ST_TO_ADDR
// end ; if tmp and mech < 6 then
68222: LD_VAR 0 4
68226: PUSH
68227: LD_VAR 0 7
68231: PUSH
68232: LD_INT 6
68234: LESS
68235: AND
68236: IFFALSE 68424
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68238: LD_ADDR_VAR 0 9
68242: PUSH
68243: LD_VAR 0 4
68247: PUSH
68248: LD_VAR 0 8
68252: PUSH
68253: LD_VAR 0 7
68257: UNION
68258: DIFF
68259: PPUSH
68260: LD_INT 3
68262: PPUSH
68263: CALL 52026 0 2
68267: ST_TO_ADDR
// p := [ ] ;
68268: LD_ADDR_VAR 0 11
68272: PUSH
68273: EMPTY
68274: ST_TO_ADDR
// if sort then
68275: LD_VAR 0 9
68279: IFFALSE 68395
// for i = 1 to 6 - mech do
68281: LD_ADDR_VAR 0 3
68285: PUSH
68286: DOUBLE
68287: LD_INT 1
68289: DEC
68290: ST_TO_ADDR
68291: LD_INT 6
68293: PUSH
68294: LD_VAR 0 7
68298: MINUS
68299: PUSH
68300: FOR_TO
68301: IFFALSE 68393
// begin if i = sort then
68303: LD_VAR 0 3
68307: PUSH
68308: LD_VAR 0 9
68312: EQUAL
68313: IFFALSE 68317
// break ;
68315: GO 68393
// if GetClass ( i ) = 3 then
68317: LD_VAR 0 3
68321: PPUSH
68322: CALL_OW 257
68326: PUSH
68327: LD_INT 3
68329: EQUAL
68330: IFFALSE 68334
// continue ;
68332: GO 68300
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68334: LD_ADDR_VAR 0 11
68338: PUSH
68339: LD_VAR 0 11
68343: PPUSH
68344: LD_VAR 0 11
68348: PUSH
68349: LD_INT 1
68351: PLUS
68352: PPUSH
68353: LD_VAR 0 9
68357: PUSH
68358: LD_VAR 0 3
68362: ARRAY
68363: PPUSH
68364: CALL_OW 2
68368: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68369: LD_ADDR_VAR 0 4
68373: PUSH
68374: LD_VAR 0 4
68378: PUSH
68379: LD_VAR 0 9
68383: PUSH
68384: LD_VAR 0 3
68388: ARRAY
68389: DIFF
68390: ST_TO_ADDR
// end ;
68391: GO 68300
68393: POP
68394: POP
// if p then
68395: LD_VAR 0 11
68399: IFFALSE 68424
// result := Replace ( result , 3 , p ) ;
68401: LD_ADDR_VAR 0 2
68405: PUSH
68406: LD_VAR 0 2
68410: PPUSH
68411: LD_INT 3
68413: PPUSH
68414: LD_VAR 0 11
68418: PPUSH
68419: CALL_OW 1
68423: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68424: LD_VAR 0 4
68428: PUSH
68429: LD_INT 6
68431: GREATER
68432: PUSH
68433: LD_VAR 0 6
68437: PUSH
68438: LD_INT 6
68440: LESS
68441: AND
68442: IFFALSE 68636
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68444: LD_ADDR_VAR 0 9
68448: PUSH
68449: LD_VAR 0 4
68453: PUSH
68454: LD_VAR 0 8
68458: PUSH
68459: LD_VAR 0 7
68463: UNION
68464: PUSH
68465: LD_VAR 0 6
68469: UNION
68470: DIFF
68471: PPUSH
68472: LD_INT 2
68474: PPUSH
68475: CALL 52026 0 2
68479: ST_TO_ADDR
// p := [ ] ;
68480: LD_ADDR_VAR 0 11
68484: PUSH
68485: EMPTY
68486: ST_TO_ADDR
// if sort then
68487: LD_VAR 0 9
68491: IFFALSE 68607
// for i = 1 to 6 - eng do
68493: LD_ADDR_VAR 0 3
68497: PUSH
68498: DOUBLE
68499: LD_INT 1
68501: DEC
68502: ST_TO_ADDR
68503: LD_INT 6
68505: PUSH
68506: LD_VAR 0 6
68510: MINUS
68511: PUSH
68512: FOR_TO
68513: IFFALSE 68605
// begin if i = sort then
68515: LD_VAR 0 3
68519: PUSH
68520: LD_VAR 0 9
68524: EQUAL
68525: IFFALSE 68529
// break ;
68527: GO 68605
// if GetClass ( i ) = 2 then
68529: LD_VAR 0 3
68533: PPUSH
68534: CALL_OW 257
68538: PUSH
68539: LD_INT 2
68541: EQUAL
68542: IFFALSE 68546
// continue ;
68544: GO 68512
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68546: LD_ADDR_VAR 0 11
68550: PUSH
68551: LD_VAR 0 11
68555: PPUSH
68556: LD_VAR 0 11
68560: PUSH
68561: LD_INT 1
68563: PLUS
68564: PPUSH
68565: LD_VAR 0 9
68569: PUSH
68570: LD_VAR 0 3
68574: ARRAY
68575: PPUSH
68576: CALL_OW 2
68580: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68581: LD_ADDR_VAR 0 4
68585: PUSH
68586: LD_VAR 0 4
68590: PUSH
68591: LD_VAR 0 9
68595: PUSH
68596: LD_VAR 0 3
68600: ARRAY
68601: DIFF
68602: ST_TO_ADDR
// end ;
68603: GO 68512
68605: POP
68606: POP
// if p then
68607: LD_VAR 0 11
68611: IFFALSE 68636
// result := Replace ( result , 2 , p ) ;
68613: LD_ADDR_VAR 0 2
68617: PUSH
68618: LD_VAR 0 2
68622: PPUSH
68623: LD_INT 2
68625: PPUSH
68626: LD_VAR 0 11
68630: PPUSH
68631: CALL_OW 1
68635: ST_TO_ADDR
// end ; exit ;
68636: GO 70024
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68638: LD_EXP 113
68642: PUSH
68643: LD_EXP 112
68647: PUSH
68648: LD_VAR 0 1
68652: ARRAY
68653: ARRAY
68654: NOT
68655: PUSH
68656: LD_EXP 86
68660: PUSH
68661: LD_VAR 0 1
68665: ARRAY
68666: PPUSH
68667: LD_INT 30
68669: PUSH
68670: LD_INT 3
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PPUSH
68677: CALL_OW 72
68681: AND
68682: PUSH
68683: LD_EXP 91
68687: PUSH
68688: LD_VAR 0 1
68692: ARRAY
68693: AND
68694: IFFALSE 69302
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68696: LD_ADDR_EXP 128
68700: PUSH
68701: LD_EXP 128
68705: PPUSH
68706: LD_VAR 0 1
68710: PPUSH
68711: LD_INT 5
68713: PPUSH
68714: CALL_OW 1
68718: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68719: LD_ADDR_VAR 0 2
68723: PUSH
68724: LD_INT 0
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: LD_INT 0
68732: PUSH
68733: LD_INT 0
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: ST_TO_ADDR
// if sci > 1 then
68742: LD_VAR 0 8
68746: PUSH
68747: LD_INT 1
68749: GREATER
68750: IFFALSE 68778
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68752: LD_ADDR_VAR 0 4
68756: PUSH
68757: LD_VAR 0 4
68761: PUSH
68762: LD_VAR 0 8
68766: PUSH
68767: LD_VAR 0 8
68771: PUSH
68772: LD_INT 1
68774: ARRAY
68775: DIFF
68776: DIFF
68777: ST_TO_ADDR
// if tmp and not sci then
68778: LD_VAR 0 4
68782: PUSH
68783: LD_VAR 0 8
68787: NOT
68788: AND
68789: IFFALSE 68858
// begin sort := SortBySkill ( tmp , 4 ) ;
68791: LD_ADDR_VAR 0 9
68795: PUSH
68796: LD_VAR 0 4
68800: PPUSH
68801: LD_INT 4
68803: PPUSH
68804: CALL 52026 0 2
68808: ST_TO_ADDR
// if sort then
68809: LD_VAR 0 9
68813: IFFALSE 68829
// p := sort [ 1 ] ;
68815: LD_ADDR_VAR 0 11
68819: PUSH
68820: LD_VAR 0 9
68824: PUSH
68825: LD_INT 1
68827: ARRAY
68828: ST_TO_ADDR
// if p then
68829: LD_VAR 0 11
68833: IFFALSE 68858
// result := Replace ( result , 4 , p ) ;
68835: LD_ADDR_VAR 0 2
68839: PUSH
68840: LD_VAR 0 2
68844: PPUSH
68845: LD_INT 4
68847: PPUSH
68848: LD_VAR 0 11
68852: PPUSH
68853: CALL_OW 1
68857: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68858: LD_ADDR_VAR 0 4
68862: PUSH
68863: LD_VAR 0 4
68867: PUSH
68868: LD_VAR 0 7
68872: DIFF
68873: ST_TO_ADDR
// if tmp and mech < 6 then
68874: LD_VAR 0 4
68878: PUSH
68879: LD_VAR 0 7
68883: PUSH
68884: LD_INT 6
68886: LESS
68887: AND
68888: IFFALSE 69076
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68890: LD_ADDR_VAR 0 9
68894: PUSH
68895: LD_VAR 0 4
68899: PUSH
68900: LD_VAR 0 8
68904: PUSH
68905: LD_VAR 0 7
68909: UNION
68910: DIFF
68911: PPUSH
68912: LD_INT 3
68914: PPUSH
68915: CALL 52026 0 2
68919: ST_TO_ADDR
// p := [ ] ;
68920: LD_ADDR_VAR 0 11
68924: PUSH
68925: EMPTY
68926: ST_TO_ADDR
// if sort then
68927: LD_VAR 0 9
68931: IFFALSE 69047
// for i = 1 to 6 - mech do
68933: LD_ADDR_VAR 0 3
68937: PUSH
68938: DOUBLE
68939: LD_INT 1
68941: DEC
68942: ST_TO_ADDR
68943: LD_INT 6
68945: PUSH
68946: LD_VAR 0 7
68950: MINUS
68951: PUSH
68952: FOR_TO
68953: IFFALSE 69045
// begin if i = sort then
68955: LD_VAR 0 3
68959: PUSH
68960: LD_VAR 0 9
68964: EQUAL
68965: IFFALSE 68969
// break ;
68967: GO 69045
// if GetClass ( i ) = 3 then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 257
68978: PUSH
68979: LD_INT 3
68981: EQUAL
68982: IFFALSE 68986
// continue ;
68984: GO 68952
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68986: LD_ADDR_VAR 0 11
68990: PUSH
68991: LD_VAR 0 11
68995: PPUSH
68996: LD_VAR 0 11
69000: PUSH
69001: LD_INT 1
69003: PLUS
69004: PPUSH
69005: LD_VAR 0 9
69009: PUSH
69010: LD_VAR 0 3
69014: ARRAY
69015: PPUSH
69016: CALL_OW 2
69020: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69021: LD_ADDR_VAR 0 4
69025: PUSH
69026: LD_VAR 0 4
69030: PUSH
69031: LD_VAR 0 9
69035: PUSH
69036: LD_VAR 0 3
69040: ARRAY
69041: DIFF
69042: ST_TO_ADDR
// end ;
69043: GO 68952
69045: POP
69046: POP
// if p then
69047: LD_VAR 0 11
69051: IFFALSE 69076
// result := Replace ( result , 3 , p ) ;
69053: LD_ADDR_VAR 0 2
69057: PUSH
69058: LD_VAR 0 2
69062: PPUSH
69063: LD_INT 3
69065: PPUSH
69066: LD_VAR 0 11
69070: PPUSH
69071: CALL_OW 1
69075: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69076: LD_ADDR_VAR 0 4
69080: PUSH
69081: LD_VAR 0 4
69085: PUSH
69086: LD_VAR 0 6
69090: DIFF
69091: ST_TO_ADDR
// if tmp and eng < 6 then
69092: LD_VAR 0 4
69096: PUSH
69097: LD_VAR 0 6
69101: PUSH
69102: LD_INT 6
69104: LESS
69105: AND
69106: IFFALSE 69300
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69108: LD_ADDR_VAR 0 9
69112: PUSH
69113: LD_VAR 0 4
69117: PUSH
69118: LD_VAR 0 8
69122: PUSH
69123: LD_VAR 0 7
69127: UNION
69128: PUSH
69129: LD_VAR 0 6
69133: UNION
69134: DIFF
69135: PPUSH
69136: LD_INT 2
69138: PPUSH
69139: CALL 52026 0 2
69143: ST_TO_ADDR
// p := [ ] ;
69144: LD_ADDR_VAR 0 11
69148: PUSH
69149: EMPTY
69150: ST_TO_ADDR
// if sort then
69151: LD_VAR 0 9
69155: IFFALSE 69271
// for i = 1 to 6 - eng do
69157: LD_ADDR_VAR 0 3
69161: PUSH
69162: DOUBLE
69163: LD_INT 1
69165: DEC
69166: ST_TO_ADDR
69167: LD_INT 6
69169: PUSH
69170: LD_VAR 0 6
69174: MINUS
69175: PUSH
69176: FOR_TO
69177: IFFALSE 69269
// begin if i = sort then
69179: LD_VAR 0 3
69183: PUSH
69184: LD_VAR 0 9
69188: EQUAL
69189: IFFALSE 69193
// break ;
69191: GO 69269
// if GetClass ( i ) = 2 then
69193: LD_VAR 0 3
69197: PPUSH
69198: CALL_OW 257
69202: PUSH
69203: LD_INT 2
69205: EQUAL
69206: IFFALSE 69210
// continue ;
69208: GO 69176
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69210: LD_ADDR_VAR 0 11
69214: PUSH
69215: LD_VAR 0 11
69219: PPUSH
69220: LD_VAR 0 11
69224: PUSH
69225: LD_INT 1
69227: PLUS
69228: PPUSH
69229: LD_VAR 0 9
69233: PUSH
69234: LD_VAR 0 3
69238: ARRAY
69239: PPUSH
69240: CALL_OW 2
69244: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69245: LD_ADDR_VAR 0 4
69249: PUSH
69250: LD_VAR 0 4
69254: PUSH
69255: LD_VAR 0 9
69259: PUSH
69260: LD_VAR 0 3
69264: ARRAY
69265: DIFF
69266: ST_TO_ADDR
// end ;
69267: GO 69176
69269: POP
69270: POP
// if p then
69271: LD_VAR 0 11
69275: IFFALSE 69300
// result := Replace ( result , 2 , p ) ;
69277: LD_ADDR_VAR 0 2
69281: PUSH
69282: LD_VAR 0 2
69286: PPUSH
69287: LD_INT 2
69289: PPUSH
69290: LD_VAR 0 11
69294: PPUSH
69295: CALL_OW 1
69299: ST_TO_ADDR
// end ; exit ;
69300: GO 70024
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
69302: LD_EXP 113
69306: PUSH
69307: LD_EXP 112
69311: PUSH
69312: LD_VAR 0 1
69316: ARRAY
69317: ARRAY
69318: NOT
69319: PUSH
69320: LD_EXP 86
69324: PUSH
69325: LD_VAR 0 1
69329: ARRAY
69330: PPUSH
69331: LD_INT 30
69333: PUSH
69334: LD_INT 3
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PPUSH
69341: CALL_OW 72
69345: AND
69346: PUSH
69347: LD_EXP 91
69351: PUSH
69352: LD_VAR 0 1
69356: ARRAY
69357: NOT
69358: AND
69359: IFFALSE 70024
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
69361: LD_ADDR_EXP 128
69365: PUSH
69366: LD_EXP 128
69370: PPUSH
69371: LD_VAR 0 1
69375: PPUSH
69376: LD_INT 6
69378: PPUSH
69379: CALL_OW 1
69383: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69384: LD_ADDR_VAR 0 2
69388: PUSH
69389: LD_INT 0
69391: PUSH
69392: LD_INT 0
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: ST_TO_ADDR
// if sci >= 1 then
69407: LD_VAR 0 8
69411: PUSH
69412: LD_INT 1
69414: GREATEREQUAL
69415: IFFALSE 69437
// tmp := tmp diff sci [ 1 ] ;
69417: LD_ADDR_VAR 0 4
69421: PUSH
69422: LD_VAR 0 4
69426: PUSH
69427: LD_VAR 0 8
69431: PUSH
69432: LD_INT 1
69434: ARRAY
69435: DIFF
69436: ST_TO_ADDR
// if tmp and not sci then
69437: LD_VAR 0 4
69441: PUSH
69442: LD_VAR 0 8
69446: NOT
69447: AND
69448: IFFALSE 69517
// begin sort := SortBySkill ( tmp , 4 ) ;
69450: LD_ADDR_VAR 0 9
69454: PUSH
69455: LD_VAR 0 4
69459: PPUSH
69460: LD_INT 4
69462: PPUSH
69463: CALL 52026 0 2
69467: ST_TO_ADDR
// if sort then
69468: LD_VAR 0 9
69472: IFFALSE 69488
// p := sort [ 1 ] ;
69474: LD_ADDR_VAR 0 11
69478: PUSH
69479: LD_VAR 0 9
69483: PUSH
69484: LD_INT 1
69486: ARRAY
69487: ST_TO_ADDR
// if p then
69488: LD_VAR 0 11
69492: IFFALSE 69517
// result := Replace ( result , 4 , p ) ;
69494: LD_ADDR_VAR 0 2
69498: PUSH
69499: LD_VAR 0 2
69503: PPUSH
69504: LD_INT 4
69506: PPUSH
69507: LD_VAR 0 11
69511: PPUSH
69512: CALL_OW 1
69516: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69517: LD_ADDR_VAR 0 4
69521: PUSH
69522: LD_VAR 0 4
69526: PUSH
69527: LD_VAR 0 7
69531: DIFF
69532: ST_TO_ADDR
// if tmp and mech < 6 then
69533: LD_VAR 0 4
69537: PUSH
69538: LD_VAR 0 7
69542: PUSH
69543: LD_INT 6
69545: LESS
69546: AND
69547: IFFALSE 69729
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69549: LD_ADDR_VAR 0 9
69553: PUSH
69554: LD_VAR 0 4
69558: PUSH
69559: LD_VAR 0 7
69563: DIFF
69564: PPUSH
69565: LD_INT 3
69567: PPUSH
69568: CALL 52026 0 2
69572: ST_TO_ADDR
// p := [ ] ;
69573: LD_ADDR_VAR 0 11
69577: PUSH
69578: EMPTY
69579: ST_TO_ADDR
// if sort then
69580: LD_VAR 0 9
69584: IFFALSE 69700
// for i = 1 to 6 - mech do
69586: LD_ADDR_VAR 0 3
69590: PUSH
69591: DOUBLE
69592: LD_INT 1
69594: DEC
69595: ST_TO_ADDR
69596: LD_INT 6
69598: PUSH
69599: LD_VAR 0 7
69603: MINUS
69604: PUSH
69605: FOR_TO
69606: IFFALSE 69698
// begin if i = sort then
69608: LD_VAR 0 3
69612: PUSH
69613: LD_VAR 0 9
69617: EQUAL
69618: IFFALSE 69622
// break ;
69620: GO 69698
// if GetClass ( i ) = 3 then
69622: LD_VAR 0 3
69626: PPUSH
69627: CALL_OW 257
69631: PUSH
69632: LD_INT 3
69634: EQUAL
69635: IFFALSE 69639
// continue ;
69637: GO 69605
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69639: LD_ADDR_VAR 0 11
69643: PUSH
69644: LD_VAR 0 11
69648: PPUSH
69649: LD_VAR 0 11
69653: PUSH
69654: LD_INT 1
69656: PLUS
69657: PPUSH
69658: LD_VAR 0 9
69662: PUSH
69663: LD_VAR 0 3
69667: ARRAY
69668: PPUSH
69669: CALL_OW 2
69673: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69674: LD_ADDR_VAR 0 4
69678: PUSH
69679: LD_VAR 0 4
69683: PUSH
69684: LD_VAR 0 9
69688: PUSH
69689: LD_VAR 0 3
69693: ARRAY
69694: DIFF
69695: ST_TO_ADDR
// end ;
69696: GO 69605
69698: POP
69699: POP
// if p then
69700: LD_VAR 0 11
69704: IFFALSE 69729
// result := Replace ( result , 3 , p ) ;
69706: LD_ADDR_VAR 0 2
69710: PUSH
69711: LD_VAR 0 2
69715: PPUSH
69716: LD_INT 3
69718: PPUSH
69719: LD_VAR 0 11
69723: PPUSH
69724: CALL_OW 1
69728: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69729: LD_ADDR_VAR 0 4
69733: PUSH
69734: LD_VAR 0 4
69738: PUSH
69739: LD_VAR 0 6
69743: DIFF
69744: ST_TO_ADDR
// if tmp and eng < 4 then
69745: LD_VAR 0 4
69749: PUSH
69750: LD_VAR 0 6
69754: PUSH
69755: LD_INT 4
69757: LESS
69758: AND
69759: IFFALSE 69949
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69761: LD_ADDR_VAR 0 9
69765: PUSH
69766: LD_VAR 0 4
69770: PUSH
69771: LD_VAR 0 7
69775: PUSH
69776: LD_VAR 0 6
69780: UNION
69781: DIFF
69782: PPUSH
69783: LD_INT 2
69785: PPUSH
69786: CALL 52026 0 2
69790: ST_TO_ADDR
// p := [ ] ;
69791: LD_ADDR_VAR 0 11
69795: PUSH
69796: EMPTY
69797: ST_TO_ADDR
// if sort then
69798: LD_VAR 0 9
69802: IFFALSE 69918
// for i = 1 to 4 - eng do
69804: LD_ADDR_VAR 0 3
69808: PUSH
69809: DOUBLE
69810: LD_INT 1
69812: DEC
69813: ST_TO_ADDR
69814: LD_INT 4
69816: PUSH
69817: LD_VAR 0 6
69821: MINUS
69822: PUSH
69823: FOR_TO
69824: IFFALSE 69916
// begin if i = sort then
69826: LD_VAR 0 3
69830: PUSH
69831: LD_VAR 0 9
69835: EQUAL
69836: IFFALSE 69840
// break ;
69838: GO 69916
// if GetClass ( i ) = 2 then
69840: LD_VAR 0 3
69844: PPUSH
69845: CALL_OW 257
69849: PUSH
69850: LD_INT 2
69852: EQUAL
69853: IFFALSE 69857
// continue ;
69855: GO 69823
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69857: LD_ADDR_VAR 0 11
69861: PUSH
69862: LD_VAR 0 11
69866: PPUSH
69867: LD_VAR 0 11
69871: PUSH
69872: LD_INT 1
69874: PLUS
69875: PPUSH
69876: LD_VAR 0 9
69880: PUSH
69881: LD_VAR 0 3
69885: ARRAY
69886: PPUSH
69887: CALL_OW 2
69891: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69892: LD_ADDR_VAR 0 4
69896: PUSH
69897: LD_VAR 0 4
69901: PUSH
69902: LD_VAR 0 9
69906: PUSH
69907: LD_VAR 0 3
69911: ARRAY
69912: DIFF
69913: ST_TO_ADDR
// end ;
69914: GO 69823
69916: POP
69917: POP
// if p then
69918: LD_VAR 0 11
69922: IFFALSE 69947
// result := Replace ( result , 2 , p ) ;
69924: LD_ADDR_VAR 0 2
69928: PUSH
69929: LD_VAR 0 2
69933: PPUSH
69934: LD_INT 2
69936: PPUSH
69937: LD_VAR 0 11
69941: PPUSH
69942: CALL_OW 1
69946: ST_TO_ADDR
// end else
69947: GO 69993
// for i = eng downto 5 do
69949: LD_ADDR_VAR 0 3
69953: PUSH
69954: DOUBLE
69955: LD_VAR 0 6
69959: INC
69960: ST_TO_ADDR
69961: LD_INT 5
69963: PUSH
69964: FOR_DOWNTO
69965: IFFALSE 69991
// tmp := tmp union eng [ i ] ;
69967: LD_ADDR_VAR 0 4
69971: PUSH
69972: LD_VAR 0 4
69976: PUSH
69977: LD_VAR 0 6
69981: PUSH
69982: LD_VAR 0 3
69986: ARRAY
69987: UNION
69988: ST_TO_ADDR
69989: GO 69964
69991: POP
69992: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69993: LD_ADDR_VAR 0 2
69997: PUSH
69998: LD_VAR 0 2
70002: PPUSH
70003: LD_INT 1
70005: PPUSH
70006: LD_VAR 0 4
70010: PUSH
70011: LD_VAR 0 5
70015: DIFF
70016: PPUSH
70017: CALL_OW 1
70021: ST_TO_ADDR
// exit ;
70022: GO 70024
// end ; end ;
70024: LD_VAR 0 2
70028: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
70029: LD_INT 0
70031: PPUSH
70032: PPUSH
70033: PPUSH
// if not mc_bases then
70034: LD_EXP 86
70038: NOT
70039: IFFALSE 70043
// exit ;
70041: GO 70149
// for i = 1 to mc_bases do
70043: LD_ADDR_VAR 0 2
70047: PUSH
70048: DOUBLE
70049: LD_INT 1
70051: DEC
70052: ST_TO_ADDR
70053: LD_EXP 86
70057: PUSH
70058: FOR_TO
70059: IFFALSE 70140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70061: LD_ADDR_VAR 0 3
70065: PUSH
70066: LD_EXP 86
70070: PUSH
70071: LD_VAR 0 2
70075: ARRAY
70076: PPUSH
70077: LD_INT 21
70079: PUSH
70080: LD_INT 3
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 3
70089: PUSH
70090: LD_INT 24
70092: PUSH
70093: LD_INT 1000
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PPUSH
70108: CALL_OW 72
70112: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
70113: LD_ADDR_EXP 87
70117: PUSH
70118: LD_EXP 87
70122: PPUSH
70123: LD_VAR 0 2
70127: PPUSH
70128: LD_VAR 0 3
70132: PPUSH
70133: CALL_OW 1
70137: ST_TO_ADDR
// end ;
70138: GO 70058
70140: POP
70141: POP
// RaiseSailEvent ( 101 ) ;
70142: LD_INT 101
70144: PPUSH
70145: CALL_OW 427
// end ;
70149: LD_VAR 0 1
70153: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
70154: LD_INT 0
70156: PPUSH
70157: PPUSH
70158: PPUSH
70159: PPUSH
70160: PPUSH
70161: PPUSH
70162: PPUSH
// if not mc_bases then
70163: LD_EXP 86
70167: NOT
70168: IFFALSE 70172
// exit ;
70170: GO 70734
// for i = 1 to mc_bases do
70172: LD_ADDR_VAR 0 2
70176: PUSH
70177: DOUBLE
70178: LD_INT 1
70180: DEC
70181: ST_TO_ADDR
70182: LD_EXP 86
70186: PUSH
70187: FOR_TO
70188: IFFALSE 70725
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
70190: LD_ADDR_VAR 0 5
70194: PUSH
70195: LD_EXP 86
70199: PUSH
70200: LD_VAR 0 2
70204: ARRAY
70205: PUSH
70206: LD_EXP 115
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: UNION
70217: PPUSH
70218: LD_INT 21
70220: PUSH
70221: LD_INT 1
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 1
70230: PUSH
70231: LD_INT 3
70233: PUSH
70234: LD_INT 54
70236: PUSH
70237: EMPTY
70238: LIST
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 3
70246: PUSH
70247: LD_INT 24
70249: PUSH
70250: LD_INT 800
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: LIST
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PPUSH
70270: CALL_OW 72
70274: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
70275: LD_ADDR_VAR 0 6
70279: PUSH
70280: LD_EXP 86
70284: PUSH
70285: LD_VAR 0 2
70289: ARRAY
70290: PPUSH
70291: LD_INT 21
70293: PUSH
70294: LD_INT 1
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 1
70303: PUSH
70304: LD_INT 3
70306: PUSH
70307: LD_INT 54
70309: PUSH
70310: EMPTY
70311: LIST
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 3
70319: PUSH
70320: LD_INT 24
70322: PUSH
70323: LD_INT 250
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: LIST
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PPUSH
70343: CALL_OW 72
70347: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
70348: LD_ADDR_VAR 0 7
70352: PUSH
70353: LD_VAR 0 5
70357: PUSH
70358: LD_VAR 0 6
70362: DIFF
70363: ST_TO_ADDR
// if not need_heal_1 then
70364: LD_VAR 0 6
70368: NOT
70369: IFFALSE 70402
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70371: LD_ADDR_EXP 89
70375: PUSH
70376: LD_EXP 89
70380: PPUSH
70381: LD_VAR 0 2
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PPUSH
70393: EMPTY
70394: PPUSH
70395: CALL 22477 0 3
70399: ST_TO_ADDR
70400: GO 70472
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70402: LD_ADDR_EXP 89
70406: PUSH
70407: LD_EXP 89
70411: PPUSH
70412: LD_VAR 0 2
70416: PUSH
70417: LD_INT 1
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PPUSH
70424: LD_EXP 89
70428: PUSH
70429: LD_VAR 0 2
70433: ARRAY
70434: PUSH
70435: LD_INT 1
70437: ARRAY
70438: PPUSH
70439: LD_INT 3
70441: PUSH
70442: LD_INT 24
70444: PUSH
70445: LD_INT 1000
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: PUSH
70461: LD_VAR 0 6
70465: UNION
70466: PPUSH
70467: CALL 22477 0 3
70471: ST_TO_ADDR
// if not need_heal_2 then
70472: LD_VAR 0 7
70476: NOT
70477: IFFALSE 70510
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70479: LD_ADDR_EXP 89
70483: PUSH
70484: LD_EXP 89
70488: PPUSH
70489: LD_VAR 0 2
70493: PUSH
70494: LD_INT 2
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PPUSH
70501: EMPTY
70502: PPUSH
70503: CALL 22477 0 3
70507: ST_TO_ADDR
70508: GO 70542
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70510: LD_ADDR_EXP 89
70514: PUSH
70515: LD_EXP 89
70519: PPUSH
70520: LD_VAR 0 2
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PPUSH
70532: LD_VAR 0 7
70536: PPUSH
70537: CALL 22477 0 3
70541: ST_TO_ADDR
// if need_heal_2 then
70542: LD_VAR 0 7
70546: IFFALSE 70707
// for j in need_heal_2 do
70548: LD_ADDR_VAR 0 3
70552: PUSH
70553: LD_VAR 0 7
70557: PUSH
70558: FOR_IN
70559: IFFALSE 70705
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70561: LD_ADDR_VAR 0 5
70565: PUSH
70566: LD_EXP 86
70570: PUSH
70571: LD_VAR 0 2
70575: ARRAY
70576: PPUSH
70577: LD_INT 2
70579: PUSH
70580: LD_INT 30
70582: PUSH
70583: LD_INT 6
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 30
70592: PUSH
70593: LD_INT 7
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 30
70602: PUSH
70603: LD_INT 8
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 30
70612: PUSH
70613: LD_INT 0
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 30
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: PPUSH
70638: CALL_OW 72
70642: ST_TO_ADDR
// if tmp then
70643: LD_VAR 0 5
70647: IFFALSE 70703
// begin k := NearestUnitToUnit ( tmp , j ) ;
70649: LD_ADDR_VAR 0 4
70653: PUSH
70654: LD_VAR 0 5
70658: PPUSH
70659: LD_VAR 0 3
70663: PPUSH
70664: CALL_OW 74
70668: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70669: LD_VAR 0 3
70673: PPUSH
70674: LD_VAR 0 4
70678: PPUSH
70679: CALL_OW 296
70683: PUSH
70684: LD_INT 5
70686: GREATER
70687: IFFALSE 70703
// ComMoveToNearbyEntrance ( j , k ) ;
70689: LD_VAR 0 3
70693: PPUSH
70694: LD_VAR 0 4
70698: PPUSH
70699: CALL 54343 0 2
// end ; end ;
70703: GO 70558
70705: POP
70706: POP
// if not need_heal_1 and not need_heal_2 then
70707: LD_VAR 0 6
70711: NOT
70712: PUSH
70713: LD_VAR 0 7
70717: NOT
70718: AND
70719: IFFALSE 70723
// continue ;
70721: GO 70187
// end ;
70723: GO 70187
70725: POP
70726: POP
// RaiseSailEvent ( 102 ) ;
70727: LD_INT 102
70729: PPUSH
70730: CALL_OW 427
// end ;
70734: LD_VAR 0 1
70738: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70739: LD_INT 0
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
70745: PPUSH
70746: PPUSH
70747: PPUSH
70748: PPUSH
// if not mc_bases then
70749: LD_EXP 86
70753: NOT
70754: IFFALSE 70758
// exit ;
70756: GO 71619
// for i = 1 to mc_bases do
70758: LD_ADDR_VAR 0 2
70762: PUSH
70763: DOUBLE
70764: LD_INT 1
70766: DEC
70767: ST_TO_ADDR
70768: LD_EXP 86
70772: PUSH
70773: FOR_TO
70774: IFFALSE 71617
// begin if not mc_building_need_repair [ i ] then
70776: LD_EXP 87
70780: PUSH
70781: LD_VAR 0 2
70785: ARRAY
70786: NOT
70787: IFFALSE 70974
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70789: LD_ADDR_VAR 0 6
70793: PUSH
70794: LD_EXP 105
70798: PUSH
70799: LD_VAR 0 2
70803: ARRAY
70804: PPUSH
70805: LD_INT 3
70807: PUSH
70808: LD_INT 24
70810: PUSH
70811: LD_INT 1000
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 2
70824: PUSH
70825: LD_INT 34
70827: PUSH
70828: LD_INT 13
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 34
70837: PUSH
70838: LD_INT 52
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 34
70847: PUSH
70848: LD_EXP 7
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PPUSH
70867: CALL_OW 72
70871: ST_TO_ADDR
// if cranes then
70872: LD_VAR 0 6
70876: IFFALSE 70938
// for j in cranes do
70878: LD_ADDR_VAR 0 3
70882: PUSH
70883: LD_VAR 0 6
70887: PUSH
70888: FOR_IN
70889: IFFALSE 70936
// if not IsInArea ( j , mc_parking [ i ] ) then
70891: LD_VAR 0 3
70895: PPUSH
70896: LD_EXP 110
70900: PUSH
70901: LD_VAR 0 2
70905: ARRAY
70906: PPUSH
70907: CALL_OW 308
70911: NOT
70912: IFFALSE 70934
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70914: LD_VAR 0 3
70918: PPUSH
70919: LD_EXP 110
70923: PUSH
70924: LD_VAR 0 2
70928: ARRAY
70929: PPUSH
70930: CALL_OW 113
70934: GO 70888
70936: POP
70937: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70938: LD_ADDR_EXP 88
70942: PUSH
70943: LD_EXP 88
70947: PPUSH
70948: LD_VAR 0 2
70952: PPUSH
70953: EMPTY
70954: PPUSH
70955: CALL_OW 1
70959: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70960: LD_VAR 0 2
70964: PPUSH
70965: LD_INT 101
70967: PPUSH
70968: CALL 65862 0 2
// continue ;
70972: GO 70773
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70974: LD_ADDR_EXP 92
70978: PUSH
70979: LD_EXP 92
70983: PPUSH
70984: LD_VAR 0 2
70988: PPUSH
70989: EMPTY
70990: PPUSH
70991: CALL_OW 1
70995: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70996: LD_VAR 0 2
71000: PPUSH
71001: LD_INT 103
71003: PPUSH
71004: CALL 65862 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
71008: LD_ADDR_VAR 0 5
71012: PUSH
71013: LD_EXP 86
71017: PUSH
71018: LD_VAR 0 2
71022: ARRAY
71023: PUSH
71024: LD_EXP 115
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: UNION
71035: PPUSH
71036: LD_INT 2
71038: PUSH
71039: LD_INT 25
71041: PUSH
71042: LD_INT 2
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 25
71051: PUSH
71052: LD_INT 16
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: LIST
71063: PUSH
71064: EMPTY
71065: LIST
71066: PPUSH
71067: CALL_OW 72
71071: PUSH
71072: LD_EXP 89
71076: PUSH
71077: LD_VAR 0 2
71081: ARRAY
71082: PUSH
71083: LD_INT 1
71085: ARRAY
71086: PUSH
71087: LD_EXP 89
71091: PUSH
71092: LD_VAR 0 2
71096: ARRAY
71097: PUSH
71098: LD_INT 2
71100: ARRAY
71101: UNION
71102: DIFF
71103: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
71104: LD_ADDR_VAR 0 6
71108: PUSH
71109: LD_EXP 105
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PPUSH
71120: LD_INT 2
71122: PUSH
71123: LD_INT 34
71125: PUSH
71126: LD_INT 13
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 34
71135: PUSH
71136: LD_INT 52
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 34
71145: PUSH
71146: LD_EXP 7
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: PPUSH
71161: CALL_OW 72
71165: ST_TO_ADDR
// if cranes then
71166: LD_VAR 0 6
71170: IFFALSE 71306
// begin for j in cranes do
71172: LD_ADDR_VAR 0 3
71176: PUSH
71177: LD_VAR 0 6
71181: PUSH
71182: FOR_IN
71183: IFFALSE 71304
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
71185: LD_VAR 0 3
71189: PPUSH
71190: CALL_OW 256
71194: PUSH
71195: LD_INT 1000
71197: EQUAL
71198: PUSH
71199: LD_VAR 0 3
71203: PPUSH
71204: CALL_OW 314
71208: NOT
71209: AND
71210: IFFALSE 71244
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
71212: LD_VAR 0 3
71216: PPUSH
71217: LD_EXP 87
71221: PUSH
71222: LD_VAR 0 2
71226: ARRAY
71227: PPUSH
71228: LD_VAR 0 3
71232: PPUSH
71233: CALL_OW 74
71237: PPUSH
71238: CALL_OW 130
71242: GO 71302
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
71244: LD_VAR 0 3
71248: PPUSH
71249: CALL_OW 256
71253: PUSH
71254: LD_INT 500
71256: LESS
71257: PUSH
71258: LD_VAR 0 3
71262: PPUSH
71263: LD_EXP 110
71267: PUSH
71268: LD_VAR 0 2
71272: ARRAY
71273: PPUSH
71274: CALL_OW 308
71278: NOT
71279: AND
71280: IFFALSE 71302
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71282: LD_VAR 0 3
71286: PPUSH
71287: LD_EXP 110
71291: PUSH
71292: LD_VAR 0 2
71296: ARRAY
71297: PPUSH
71298: CALL_OW 113
// end ;
71302: GO 71182
71304: POP
71305: POP
// end ; if tmp > 3 then
71306: LD_VAR 0 5
71310: PUSH
71311: LD_INT 3
71313: GREATER
71314: IFFALSE 71334
// tmp := ShrinkArray ( tmp , 4 ) ;
71316: LD_ADDR_VAR 0 5
71320: PUSH
71321: LD_VAR 0 5
71325: PPUSH
71326: LD_INT 4
71328: PPUSH
71329: CALL 53835 0 2
71333: ST_TO_ADDR
// if not tmp then
71334: LD_VAR 0 5
71338: NOT
71339: IFFALSE 71343
// continue ;
71341: GO 70773
// for j in tmp do
71343: LD_ADDR_VAR 0 3
71347: PUSH
71348: LD_VAR 0 5
71352: PUSH
71353: FOR_IN
71354: IFFALSE 71613
// begin if IsInUnit ( j ) then
71356: LD_VAR 0 3
71360: PPUSH
71361: CALL_OW 310
71365: IFFALSE 71376
// ComExitBuilding ( j ) ;
71367: LD_VAR 0 3
71371: PPUSH
71372: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71376: LD_VAR 0 3
71380: PUSH
71381: LD_EXP 88
71385: PUSH
71386: LD_VAR 0 2
71390: ARRAY
71391: IN
71392: NOT
71393: IFFALSE 71451
// begin SetTag ( j , 101 ) ;
71395: LD_VAR 0 3
71399: PPUSH
71400: LD_INT 101
71402: PPUSH
71403: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71407: LD_ADDR_EXP 88
71411: PUSH
71412: LD_EXP 88
71416: PPUSH
71417: LD_VAR 0 2
71421: PUSH
71422: LD_EXP 88
71426: PUSH
71427: LD_VAR 0 2
71431: ARRAY
71432: PUSH
71433: LD_INT 1
71435: PLUS
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PPUSH
71441: LD_VAR 0 3
71445: PPUSH
71446: CALL 22477 0 3
71450: ST_TO_ADDR
// end ; wait ( 1 ) ;
71451: LD_INT 1
71453: PPUSH
71454: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71458: LD_ADDR_VAR 0 7
71462: PUSH
71463: LD_EXP 87
71467: PUSH
71468: LD_VAR 0 2
71472: ARRAY
71473: ST_TO_ADDR
// if mc_scan [ i ] then
71474: LD_EXP 109
71478: PUSH
71479: LD_VAR 0 2
71483: ARRAY
71484: IFFALSE 71546
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71486: LD_ADDR_VAR 0 7
71490: PUSH
71491: LD_EXP 87
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PPUSH
71502: LD_INT 3
71504: PUSH
71505: LD_INT 30
71507: PUSH
71508: LD_INT 32
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 30
71517: PUSH
71518: LD_INT 33
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 30
71527: PUSH
71528: LD_INT 31
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: PPUSH
71541: CALL_OW 72
71545: ST_TO_ADDR
// if not to_repair_tmp then
71546: LD_VAR 0 7
71550: NOT
71551: IFFALSE 71555
// continue ;
71553: GO 71353
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71555: LD_ADDR_VAR 0 8
71559: PUSH
71560: LD_VAR 0 7
71564: PPUSH
71565: LD_VAR 0 3
71569: PPUSH
71570: CALL_OW 74
71574: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
71575: LD_VAR 0 8
71579: PPUSH
71580: LD_INT 16
71582: PPUSH
71583: CALL 25070 0 2
71587: PUSH
71588: LD_INT 4
71590: ARRAY
71591: PUSH
71592: LD_INT 10
71594: LESS
71595: IFFALSE 71611
// ComRepairBuilding ( j , to_repair ) ;
71597: LD_VAR 0 3
71601: PPUSH
71602: LD_VAR 0 8
71606: PPUSH
71607: CALL_OW 130
// end ;
71611: GO 71353
71613: POP
71614: POP
// end ;
71615: GO 70773
71617: POP
71618: POP
// end ;
71619: LD_VAR 0 1
71623: RET
// export function MC_Heal ; var i , j , tmp ; begin
71624: LD_INT 0
71626: PPUSH
71627: PPUSH
71628: PPUSH
71629: PPUSH
// if not mc_bases then
71630: LD_EXP 86
71634: NOT
71635: IFFALSE 71639
// exit ;
71637: GO 72041
// for i = 1 to mc_bases do
71639: LD_ADDR_VAR 0 2
71643: PUSH
71644: DOUBLE
71645: LD_INT 1
71647: DEC
71648: ST_TO_ADDR
71649: LD_EXP 86
71653: PUSH
71654: FOR_TO
71655: IFFALSE 72039
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71657: LD_EXP 89
71661: PUSH
71662: LD_VAR 0 2
71666: ARRAY
71667: PUSH
71668: LD_INT 1
71670: ARRAY
71671: NOT
71672: PUSH
71673: LD_EXP 89
71677: PUSH
71678: LD_VAR 0 2
71682: ARRAY
71683: PUSH
71684: LD_INT 2
71686: ARRAY
71687: NOT
71688: AND
71689: IFFALSE 71727
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71691: LD_ADDR_EXP 90
71695: PUSH
71696: LD_EXP 90
71700: PPUSH
71701: LD_VAR 0 2
71705: PPUSH
71706: EMPTY
71707: PPUSH
71708: CALL_OW 1
71712: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71713: LD_VAR 0 2
71717: PPUSH
71718: LD_INT 102
71720: PPUSH
71721: CALL 65862 0 2
// continue ;
71725: GO 71654
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71727: LD_ADDR_VAR 0 4
71731: PUSH
71732: LD_EXP 86
71736: PUSH
71737: LD_VAR 0 2
71741: ARRAY
71742: PPUSH
71743: LD_INT 25
71745: PUSH
71746: LD_INT 4
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PPUSH
71753: CALL_OW 72
71757: ST_TO_ADDR
// if not tmp then
71758: LD_VAR 0 4
71762: NOT
71763: IFFALSE 71767
// continue ;
71765: GO 71654
// if mc_taming [ i ] then
71767: LD_EXP 117
71771: PUSH
71772: LD_VAR 0 2
71776: ARRAY
71777: IFFALSE 71801
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71779: LD_ADDR_EXP 117
71783: PUSH
71784: LD_EXP 117
71788: PPUSH
71789: LD_VAR 0 2
71793: PPUSH
71794: EMPTY
71795: PPUSH
71796: CALL_OW 1
71800: ST_TO_ADDR
// for j in tmp do
71801: LD_ADDR_VAR 0 3
71805: PUSH
71806: LD_VAR 0 4
71810: PUSH
71811: FOR_IN
71812: IFFALSE 72035
// begin if IsInUnit ( j ) then
71814: LD_VAR 0 3
71818: PPUSH
71819: CALL_OW 310
71823: IFFALSE 71834
// ComExitBuilding ( j ) ;
71825: LD_VAR 0 3
71829: PPUSH
71830: CALL_OW 122
// if not j in mc_healers [ i ] then
71834: LD_VAR 0 3
71838: PUSH
71839: LD_EXP 90
71843: PUSH
71844: LD_VAR 0 2
71848: ARRAY
71849: IN
71850: NOT
71851: IFFALSE 71897
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71853: LD_ADDR_EXP 90
71857: PUSH
71858: LD_EXP 90
71862: PPUSH
71863: LD_VAR 0 2
71867: PUSH
71868: LD_EXP 90
71872: PUSH
71873: LD_VAR 0 2
71877: ARRAY
71878: PUSH
71879: LD_INT 1
71881: PLUS
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PPUSH
71887: LD_VAR 0 3
71891: PPUSH
71892: CALL 22477 0 3
71896: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71897: LD_VAR 0 3
71901: PPUSH
71902: CALL_OW 110
71906: PUSH
71907: LD_INT 102
71909: NONEQUAL
71910: IFFALSE 71924
// SetTag ( j , 102 ) ;
71912: LD_VAR 0 3
71916: PPUSH
71917: LD_INT 102
71919: PPUSH
71920: CALL_OW 109
// Wait ( 3 ) ;
71924: LD_INT 3
71926: PPUSH
71927: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71931: LD_EXP 89
71935: PUSH
71936: LD_VAR 0 2
71940: ARRAY
71941: PUSH
71942: LD_INT 1
71944: ARRAY
71945: IFFALSE 71977
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71947: LD_VAR 0 3
71951: PPUSH
71952: LD_EXP 89
71956: PUSH
71957: LD_VAR 0 2
71961: ARRAY
71962: PUSH
71963: LD_INT 1
71965: ARRAY
71966: PUSH
71967: LD_INT 1
71969: ARRAY
71970: PPUSH
71971: CALL_OW 128
71975: GO 72033
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71977: LD_VAR 0 3
71981: PPUSH
71982: CALL_OW 314
71986: NOT
71987: PUSH
71988: LD_EXP 89
71992: PUSH
71993: LD_VAR 0 2
71997: ARRAY
71998: PUSH
71999: LD_INT 2
72001: ARRAY
72002: AND
72003: IFFALSE 72033
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
72005: LD_VAR 0 3
72009: PPUSH
72010: LD_EXP 89
72014: PUSH
72015: LD_VAR 0 2
72019: ARRAY
72020: PUSH
72021: LD_INT 2
72023: ARRAY
72024: PUSH
72025: LD_INT 1
72027: ARRAY
72028: PPUSH
72029: CALL_OW 128
// end ;
72033: GO 71811
72035: POP
72036: POP
// end ;
72037: GO 71654
72039: POP
72040: POP
// end ;
72041: LD_VAR 0 1
72045: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
72046: LD_INT 0
72048: PPUSH
72049: PPUSH
72050: PPUSH
72051: PPUSH
72052: PPUSH
// if not mc_bases then
72053: LD_EXP 86
72057: NOT
72058: IFFALSE 72062
// exit ;
72060: GO 73205
// for i = 1 to mc_bases do
72062: LD_ADDR_VAR 0 2
72066: PUSH
72067: DOUBLE
72068: LD_INT 1
72070: DEC
72071: ST_TO_ADDR
72072: LD_EXP 86
72076: PUSH
72077: FOR_TO
72078: IFFALSE 73203
// begin if mc_scan [ i ] then
72080: LD_EXP 109
72084: PUSH
72085: LD_VAR 0 2
72089: ARRAY
72090: IFFALSE 72094
// continue ;
72092: GO 72077
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
72094: LD_EXP 91
72098: PUSH
72099: LD_VAR 0 2
72103: ARRAY
72104: NOT
72105: PUSH
72106: LD_EXP 93
72110: PUSH
72111: LD_VAR 0 2
72115: ARRAY
72116: NOT
72117: AND
72118: PUSH
72119: LD_EXP 92
72123: PUSH
72124: LD_VAR 0 2
72128: ARRAY
72129: AND
72130: IFFALSE 72168
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
72132: LD_ADDR_EXP 92
72136: PUSH
72137: LD_EXP 92
72141: PPUSH
72142: LD_VAR 0 2
72146: PPUSH
72147: EMPTY
72148: PPUSH
72149: CALL_OW 1
72153: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72154: LD_VAR 0 2
72158: PPUSH
72159: LD_INT 103
72161: PPUSH
72162: CALL 65862 0 2
// continue ;
72166: GO 72077
// end ; if mc_construct_list [ i ] then
72168: LD_EXP 93
72172: PUSH
72173: LD_VAR 0 2
72177: ARRAY
72178: IFFALSE 72398
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72180: LD_ADDR_VAR 0 4
72184: PUSH
72185: LD_EXP 86
72189: PUSH
72190: LD_VAR 0 2
72194: ARRAY
72195: PPUSH
72196: LD_INT 25
72198: PUSH
72199: LD_INT 2
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PPUSH
72206: CALL_OW 72
72210: PUSH
72211: LD_EXP 88
72215: PUSH
72216: LD_VAR 0 2
72220: ARRAY
72221: DIFF
72222: ST_TO_ADDR
// if not tmp then
72223: LD_VAR 0 4
72227: NOT
72228: IFFALSE 72232
// continue ;
72230: GO 72077
// for j in tmp do
72232: LD_ADDR_VAR 0 3
72236: PUSH
72237: LD_VAR 0 4
72241: PUSH
72242: FOR_IN
72243: IFFALSE 72394
// begin if not mc_builders [ i ] then
72245: LD_EXP 92
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: NOT
72256: IFFALSE 72314
// begin SetTag ( j , 103 ) ;
72258: LD_VAR 0 3
72262: PPUSH
72263: LD_INT 103
72265: PPUSH
72266: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72270: LD_ADDR_EXP 92
72274: PUSH
72275: LD_EXP 92
72279: PPUSH
72280: LD_VAR 0 2
72284: PUSH
72285: LD_EXP 92
72289: PUSH
72290: LD_VAR 0 2
72294: ARRAY
72295: PUSH
72296: LD_INT 1
72298: PLUS
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PPUSH
72304: LD_VAR 0 3
72308: PPUSH
72309: CALL 22477 0 3
72313: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72314: LD_VAR 0 3
72318: PPUSH
72319: CALL_OW 310
72323: IFFALSE 72334
// ComExitBuilding ( j ) ;
72325: LD_VAR 0 3
72329: PPUSH
72330: CALL_OW 122
// wait ( 3 ) ;
72334: LD_INT 3
72336: PPUSH
72337: CALL_OW 67
// if not mc_construct_list [ i ] then
72341: LD_EXP 93
72345: PUSH
72346: LD_VAR 0 2
72350: ARRAY
72351: NOT
72352: IFFALSE 72356
// break ;
72354: GO 72394
// if not HasTask ( j ) then
72356: LD_VAR 0 3
72360: PPUSH
72361: CALL_OW 314
72365: NOT
72366: IFFALSE 72392
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72368: LD_VAR 0 3
72372: PPUSH
72373: LD_EXP 93
72377: PUSH
72378: LD_VAR 0 2
72382: ARRAY
72383: PUSH
72384: LD_INT 1
72386: ARRAY
72387: PPUSH
72388: CALL 25328 0 2
// end ;
72392: GO 72242
72394: POP
72395: POP
// end else
72396: GO 73201
// if mc_build_list [ i ] then
72398: LD_EXP 91
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: IFFALSE 73201
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72410: LD_ADDR_VAR 0 5
72414: PUSH
72415: LD_EXP 86
72419: PUSH
72420: LD_VAR 0 2
72424: ARRAY
72425: PPUSH
72426: LD_INT 2
72428: PUSH
72429: LD_INT 30
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 30
72441: PUSH
72442: LD_INT 1
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: LIST
72453: PPUSH
72454: CALL_OW 72
72458: ST_TO_ADDR
// if depot then
72459: LD_VAR 0 5
72463: IFFALSE 72481
// depot := depot [ 1 ] else
72465: LD_ADDR_VAR 0 5
72469: PUSH
72470: LD_VAR 0 5
72474: PUSH
72475: LD_INT 1
72477: ARRAY
72478: ST_TO_ADDR
72479: GO 72489
// depot := 0 ;
72481: LD_ADDR_VAR 0 5
72485: PUSH
72486: LD_INT 0
72488: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72489: LD_EXP 91
72493: PUSH
72494: LD_VAR 0 2
72498: ARRAY
72499: PUSH
72500: LD_INT 1
72502: ARRAY
72503: PUSH
72504: LD_INT 1
72506: ARRAY
72507: PPUSH
72508: CALL 25158 0 1
72512: PUSH
72513: LD_EXP 86
72517: PUSH
72518: LD_VAR 0 2
72522: ARRAY
72523: PPUSH
72524: LD_INT 2
72526: PUSH
72527: LD_INT 30
72529: PUSH
72530: LD_INT 2
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 30
72539: PUSH
72540: LD_INT 3
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: LIST
72551: PPUSH
72552: CALL_OW 72
72556: NOT
72557: AND
72558: IFFALSE 72663
// begin for j = 1 to mc_build_list [ i ] do
72560: LD_ADDR_VAR 0 3
72564: PUSH
72565: DOUBLE
72566: LD_INT 1
72568: DEC
72569: ST_TO_ADDR
72570: LD_EXP 91
72574: PUSH
72575: LD_VAR 0 2
72579: ARRAY
72580: PUSH
72581: FOR_TO
72582: IFFALSE 72661
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72584: LD_EXP 91
72588: PUSH
72589: LD_VAR 0 2
72593: ARRAY
72594: PUSH
72595: LD_VAR 0 3
72599: ARRAY
72600: PUSH
72601: LD_INT 1
72603: ARRAY
72604: PUSH
72605: LD_INT 2
72607: EQUAL
72608: IFFALSE 72659
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72610: LD_ADDR_EXP 91
72614: PUSH
72615: LD_EXP 91
72619: PPUSH
72620: LD_VAR 0 2
72624: PPUSH
72625: LD_EXP 91
72629: PUSH
72630: LD_VAR 0 2
72634: ARRAY
72635: PPUSH
72636: LD_VAR 0 3
72640: PPUSH
72641: LD_INT 1
72643: PPUSH
72644: LD_INT 0
72646: PPUSH
72647: CALL 21895 0 4
72651: PPUSH
72652: CALL_OW 1
72656: ST_TO_ADDR
// break ;
72657: GO 72661
// end ;
72659: GO 72581
72661: POP
72662: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
72663: LD_EXP 91
72667: PUSH
72668: LD_VAR 0 2
72672: ARRAY
72673: PUSH
72674: LD_INT 1
72676: ARRAY
72677: PUSH
72678: LD_INT 1
72680: ARRAY
72681: PUSH
72682: LD_INT 0
72684: EQUAL
72685: PUSH
72686: LD_VAR 0 5
72690: PUSH
72691: LD_VAR 0 5
72695: PPUSH
72696: LD_EXP 91
72700: PUSH
72701: LD_VAR 0 2
72705: ARRAY
72706: PUSH
72707: LD_INT 1
72709: ARRAY
72710: PUSH
72711: LD_INT 1
72713: ARRAY
72714: PPUSH
72715: LD_EXP 91
72719: PUSH
72720: LD_VAR 0 2
72724: ARRAY
72725: PUSH
72726: LD_INT 1
72728: ARRAY
72729: PUSH
72730: LD_INT 2
72732: ARRAY
72733: PPUSH
72734: LD_EXP 91
72738: PUSH
72739: LD_VAR 0 2
72743: ARRAY
72744: PUSH
72745: LD_INT 1
72747: ARRAY
72748: PUSH
72749: LD_INT 3
72751: ARRAY
72752: PPUSH
72753: LD_EXP 91
72757: PUSH
72758: LD_VAR 0 2
72762: ARRAY
72763: PUSH
72764: LD_INT 1
72766: ARRAY
72767: PUSH
72768: LD_INT 4
72770: ARRAY
72771: PPUSH
72772: CALL 29892 0 5
72776: AND
72777: OR
72778: IFFALSE 73059
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72780: LD_ADDR_VAR 0 4
72784: PUSH
72785: LD_EXP 86
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: PPUSH
72796: LD_INT 25
72798: PUSH
72799: LD_INT 2
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PPUSH
72806: CALL_OW 72
72810: PUSH
72811: LD_EXP 88
72815: PUSH
72816: LD_VAR 0 2
72820: ARRAY
72821: DIFF
72822: ST_TO_ADDR
// if not tmp then
72823: LD_VAR 0 4
72827: NOT
72828: IFFALSE 72832
// continue ;
72830: GO 72077
// for j in tmp do
72832: LD_ADDR_VAR 0 3
72836: PUSH
72837: LD_VAR 0 4
72841: PUSH
72842: FOR_IN
72843: IFFALSE 73055
// begin if not mc_builders [ i ] then
72845: LD_EXP 92
72849: PUSH
72850: LD_VAR 0 2
72854: ARRAY
72855: NOT
72856: IFFALSE 72914
// begin SetTag ( j , 103 ) ;
72858: LD_VAR 0 3
72862: PPUSH
72863: LD_INT 103
72865: PPUSH
72866: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72870: LD_ADDR_EXP 92
72874: PUSH
72875: LD_EXP 92
72879: PPUSH
72880: LD_VAR 0 2
72884: PUSH
72885: LD_EXP 92
72889: PUSH
72890: LD_VAR 0 2
72894: ARRAY
72895: PUSH
72896: LD_INT 1
72898: PLUS
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PPUSH
72904: LD_VAR 0 3
72908: PPUSH
72909: CALL 22477 0 3
72913: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72914: LD_VAR 0 3
72918: PPUSH
72919: CALL_OW 310
72923: IFFALSE 72934
// ComExitBuilding ( j ) ;
72925: LD_VAR 0 3
72929: PPUSH
72930: CALL_OW 122
// wait ( 3 ) ;
72934: LD_INT 3
72936: PPUSH
72937: CALL_OW 67
// if not mc_build_list [ i ] then
72941: LD_EXP 91
72945: PUSH
72946: LD_VAR 0 2
72950: ARRAY
72951: NOT
72952: IFFALSE 72956
// break ;
72954: GO 73055
// if not HasTask ( j ) then
72956: LD_VAR 0 3
72960: PPUSH
72961: CALL_OW 314
72965: NOT
72966: IFFALSE 73053
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72968: LD_VAR 0 3
72972: PPUSH
72973: LD_EXP 91
72977: PUSH
72978: LD_VAR 0 2
72982: ARRAY
72983: PUSH
72984: LD_INT 1
72986: ARRAY
72987: PUSH
72988: LD_INT 1
72990: ARRAY
72991: PPUSH
72992: LD_EXP 91
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: PUSH
73003: LD_INT 1
73005: ARRAY
73006: PUSH
73007: LD_INT 2
73009: ARRAY
73010: PPUSH
73011: LD_EXP 91
73015: PUSH
73016: LD_VAR 0 2
73020: ARRAY
73021: PUSH
73022: LD_INT 1
73024: ARRAY
73025: PUSH
73026: LD_INT 3
73028: ARRAY
73029: PPUSH
73030: LD_EXP 91
73034: PUSH
73035: LD_VAR 0 2
73039: ARRAY
73040: PUSH
73041: LD_INT 1
73043: ARRAY
73044: PUSH
73045: LD_INT 4
73047: ARRAY
73048: PPUSH
73049: CALL_OW 145
// end ;
73053: GO 72842
73055: POP
73056: POP
// end else
73057: GO 73201
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
73059: LD_EXP 86
73063: PUSH
73064: LD_VAR 0 2
73068: ARRAY
73069: PPUSH
73070: LD_EXP 91
73074: PUSH
73075: LD_VAR 0 2
73079: ARRAY
73080: PUSH
73081: LD_INT 1
73083: ARRAY
73084: PUSH
73085: LD_INT 1
73087: ARRAY
73088: PPUSH
73089: LD_EXP 91
73093: PUSH
73094: LD_VAR 0 2
73098: ARRAY
73099: PUSH
73100: LD_INT 1
73102: ARRAY
73103: PUSH
73104: LD_INT 2
73106: ARRAY
73107: PPUSH
73108: LD_EXP 91
73112: PUSH
73113: LD_VAR 0 2
73117: ARRAY
73118: PUSH
73119: LD_INT 1
73121: ARRAY
73122: PUSH
73123: LD_INT 3
73125: ARRAY
73126: PPUSH
73127: LD_EXP 91
73131: PUSH
73132: LD_VAR 0 2
73136: ARRAY
73137: PUSH
73138: LD_INT 1
73140: ARRAY
73141: PUSH
73142: LD_INT 4
73144: ARRAY
73145: PPUSH
73146: CALL 29228 0 5
73150: NOT
73151: IFFALSE 73201
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
73153: LD_ADDR_EXP 91
73157: PUSH
73158: LD_EXP 91
73162: PPUSH
73163: LD_VAR 0 2
73167: PPUSH
73168: LD_EXP 91
73172: PUSH
73173: LD_VAR 0 2
73177: ARRAY
73178: PPUSH
73179: LD_INT 1
73181: PPUSH
73182: LD_INT 1
73184: NEG
73185: PPUSH
73186: LD_INT 0
73188: PPUSH
73189: CALL 21895 0 4
73193: PPUSH
73194: CALL_OW 1
73198: ST_TO_ADDR
// continue ;
73199: GO 72077
// end ; end ; end ;
73201: GO 72077
73203: POP
73204: POP
// end ;
73205: LD_VAR 0 1
73209: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
73210: LD_INT 0
73212: PPUSH
73213: PPUSH
73214: PPUSH
73215: PPUSH
73216: PPUSH
73217: PPUSH
// if not mc_bases then
73218: LD_EXP 86
73222: NOT
73223: IFFALSE 73227
// exit ;
73225: GO 73654
// for i = 1 to mc_bases do
73227: LD_ADDR_VAR 0 2
73231: PUSH
73232: DOUBLE
73233: LD_INT 1
73235: DEC
73236: ST_TO_ADDR
73237: LD_EXP 86
73241: PUSH
73242: FOR_TO
73243: IFFALSE 73652
// begin tmp := mc_build_upgrade [ i ] ;
73245: LD_ADDR_VAR 0 4
73249: PUSH
73250: LD_EXP 118
73254: PUSH
73255: LD_VAR 0 2
73259: ARRAY
73260: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
73261: LD_ADDR_VAR 0 6
73265: PUSH
73266: LD_EXP 119
73270: PUSH
73271: LD_VAR 0 2
73275: ARRAY
73276: PPUSH
73277: LD_INT 2
73279: PUSH
73280: LD_INT 30
73282: PUSH
73283: LD_INT 6
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 30
73292: PUSH
73293: LD_INT 7
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: LIST
73304: PPUSH
73305: CALL_OW 72
73309: ST_TO_ADDR
// if not tmp and not lab then
73310: LD_VAR 0 4
73314: NOT
73315: PUSH
73316: LD_VAR 0 6
73320: NOT
73321: AND
73322: IFFALSE 73326
// continue ;
73324: GO 73242
// if tmp then
73326: LD_VAR 0 4
73330: IFFALSE 73450
// for j in tmp do
73332: LD_ADDR_VAR 0 3
73336: PUSH
73337: LD_VAR 0 4
73341: PUSH
73342: FOR_IN
73343: IFFALSE 73448
// begin if UpgradeCost ( j ) then
73345: LD_VAR 0 3
73349: PPUSH
73350: CALL 28888 0 1
73354: IFFALSE 73446
// begin ComUpgrade ( j ) ;
73356: LD_VAR 0 3
73360: PPUSH
73361: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73365: LD_ADDR_EXP 118
73369: PUSH
73370: LD_EXP 118
73374: PPUSH
73375: LD_VAR 0 2
73379: PPUSH
73380: LD_EXP 118
73384: PUSH
73385: LD_VAR 0 2
73389: ARRAY
73390: PUSH
73391: LD_VAR 0 3
73395: DIFF
73396: PPUSH
73397: CALL_OW 1
73401: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73402: LD_ADDR_EXP 93
73406: PUSH
73407: LD_EXP 93
73411: PPUSH
73412: LD_VAR 0 2
73416: PUSH
73417: LD_EXP 93
73421: PUSH
73422: LD_VAR 0 2
73426: ARRAY
73427: PUSH
73428: LD_INT 1
73430: PLUS
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PPUSH
73436: LD_VAR 0 3
73440: PPUSH
73441: CALL 22477 0 3
73445: ST_TO_ADDR
// end ; end ;
73446: GO 73342
73448: POP
73449: POP
// if not lab or not mc_lab_upgrade [ i ] then
73450: LD_VAR 0 6
73454: NOT
73455: PUSH
73456: LD_EXP 120
73460: PUSH
73461: LD_VAR 0 2
73465: ARRAY
73466: NOT
73467: OR
73468: IFFALSE 73472
// continue ;
73470: GO 73242
// for j in lab do
73472: LD_ADDR_VAR 0 3
73476: PUSH
73477: LD_VAR 0 6
73481: PUSH
73482: FOR_IN
73483: IFFALSE 73648
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73485: LD_VAR 0 3
73489: PPUSH
73490: CALL_OW 266
73494: PUSH
73495: LD_INT 6
73497: PUSH
73498: LD_INT 7
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: IN
73505: PUSH
73506: LD_VAR 0 3
73510: PPUSH
73511: CALL_OW 461
73515: PUSH
73516: LD_INT 1
73518: NONEQUAL
73519: AND
73520: IFFALSE 73646
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73522: LD_VAR 0 3
73526: PPUSH
73527: LD_EXP 120
73531: PUSH
73532: LD_VAR 0 2
73536: ARRAY
73537: PUSH
73538: LD_INT 1
73540: ARRAY
73541: PPUSH
73542: CALL 29093 0 2
73546: IFFALSE 73646
// begin ComCancel ( j ) ;
73548: LD_VAR 0 3
73552: PPUSH
73553: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73557: LD_VAR 0 3
73561: PPUSH
73562: LD_EXP 120
73566: PUSH
73567: LD_VAR 0 2
73571: ARRAY
73572: PUSH
73573: LD_INT 1
73575: ARRAY
73576: PPUSH
73577: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73581: LD_VAR 0 3
73585: PUSH
73586: LD_EXP 93
73590: PUSH
73591: LD_VAR 0 2
73595: ARRAY
73596: IN
73597: NOT
73598: IFFALSE 73644
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73600: LD_ADDR_EXP 93
73604: PUSH
73605: LD_EXP 93
73609: PPUSH
73610: LD_VAR 0 2
73614: PUSH
73615: LD_EXP 93
73619: PUSH
73620: LD_VAR 0 2
73624: ARRAY
73625: PUSH
73626: LD_INT 1
73628: PLUS
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PPUSH
73634: LD_VAR 0 3
73638: PPUSH
73639: CALL 22477 0 3
73643: ST_TO_ADDR
// break ;
73644: GO 73648
// end ; end ; end ;
73646: GO 73482
73648: POP
73649: POP
// end ;
73650: GO 73242
73652: POP
73653: POP
// end ;
73654: LD_VAR 0 1
73658: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73659: LD_INT 0
73661: PPUSH
73662: PPUSH
73663: PPUSH
73664: PPUSH
73665: PPUSH
73666: PPUSH
73667: PPUSH
73668: PPUSH
73669: PPUSH
// if not mc_bases then
73670: LD_EXP 86
73674: NOT
73675: IFFALSE 73679
// exit ;
73677: GO 74084
// for i = 1 to mc_bases do
73679: LD_ADDR_VAR 0 2
73683: PUSH
73684: DOUBLE
73685: LD_INT 1
73687: DEC
73688: ST_TO_ADDR
73689: LD_EXP 86
73693: PUSH
73694: FOR_TO
73695: IFFALSE 74082
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73697: LD_EXP 94
73701: PUSH
73702: LD_VAR 0 2
73706: ARRAY
73707: NOT
73708: PUSH
73709: LD_EXP 86
73713: PUSH
73714: LD_VAR 0 2
73718: ARRAY
73719: PPUSH
73720: LD_INT 30
73722: PUSH
73723: LD_INT 3
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PPUSH
73730: CALL_OW 72
73734: NOT
73735: OR
73736: IFFALSE 73740
// continue ;
73738: GO 73694
// busy := false ;
73740: LD_ADDR_VAR 0 8
73744: PUSH
73745: LD_INT 0
73747: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73748: LD_ADDR_VAR 0 4
73752: PUSH
73753: LD_EXP 86
73757: PUSH
73758: LD_VAR 0 2
73762: ARRAY
73763: PPUSH
73764: LD_INT 30
73766: PUSH
73767: LD_INT 3
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PPUSH
73774: CALL_OW 72
73778: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73779: LD_ADDR_VAR 0 6
73783: PUSH
73784: LD_EXP 94
73788: PUSH
73789: LD_VAR 0 2
73793: ARRAY
73794: PPUSH
73795: LD_INT 2
73797: PUSH
73798: LD_INT 30
73800: PUSH
73801: LD_INT 32
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: LD_INT 30
73810: PUSH
73811: LD_INT 33
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: LIST
73822: PPUSH
73823: CALL_OW 72
73827: ST_TO_ADDR
// if not t then
73828: LD_VAR 0 6
73832: NOT
73833: IFFALSE 73837
// continue ;
73835: GO 73694
// for j in tmp do
73837: LD_ADDR_VAR 0 3
73841: PUSH
73842: LD_VAR 0 4
73846: PUSH
73847: FOR_IN
73848: IFFALSE 73878
// if not BuildingStatus ( j ) = bs_idle then
73850: LD_VAR 0 3
73854: PPUSH
73855: CALL_OW 461
73859: PUSH
73860: LD_INT 2
73862: EQUAL
73863: NOT
73864: IFFALSE 73876
// begin busy := true ;
73866: LD_ADDR_VAR 0 8
73870: PUSH
73871: LD_INT 1
73873: ST_TO_ADDR
// break ;
73874: GO 73878
// end ;
73876: GO 73847
73878: POP
73879: POP
// if busy then
73880: LD_VAR 0 8
73884: IFFALSE 73888
// continue ;
73886: GO 73694
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73888: LD_ADDR_VAR 0 7
73892: PUSH
73893: LD_VAR 0 6
73897: PPUSH
73898: LD_INT 35
73900: PUSH
73901: LD_INT 0
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PPUSH
73908: CALL_OW 72
73912: ST_TO_ADDR
// if tw then
73913: LD_VAR 0 7
73917: IFFALSE 73994
// begin tw := tw [ 1 ] ;
73919: LD_ADDR_VAR 0 7
73923: PUSH
73924: LD_VAR 0 7
73928: PUSH
73929: LD_INT 1
73931: ARRAY
73932: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73933: LD_ADDR_VAR 0 9
73937: PUSH
73938: LD_VAR 0 7
73942: PPUSH
73943: LD_EXP 111
73947: PUSH
73948: LD_VAR 0 2
73952: ARRAY
73953: PPUSH
73954: CALL 27447 0 2
73958: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73959: LD_EXP 125
73963: PUSH
73964: LD_VAR 0 2
73968: ARRAY
73969: IFFALSE 73992
// if not weapon in mc_allowed_tower_weapons [ i ] then
73971: LD_VAR 0 9
73975: PUSH
73976: LD_EXP 125
73980: PUSH
73981: LD_VAR 0 2
73985: ARRAY
73986: IN
73987: NOT
73988: IFFALSE 73992
// continue ;
73990: GO 73694
// end else
73992: GO 74057
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73994: LD_ADDR_VAR 0 5
73998: PUSH
73999: LD_EXP 94
74003: PUSH
74004: LD_VAR 0 2
74008: ARRAY
74009: PPUSH
74010: LD_VAR 0 4
74014: PPUSH
74015: CALL 53068 0 2
74019: ST_TO_ADDR
// if not tmp2 then
74020: LD_VAR 0 5
74024: NOT
74025: IFFALSE 74029
// continue ;
74027: GO 73694
// tw := tmp2 [ 1 ] ;
74029: LD_ADDR_VAR 0 7
74033: PUSH
74034: LD_VAR 0 5
74038: PUSH
74039: LD_INT 1
74041: ARRAY
74042: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
74043: LD_ADDR_VAR 0 9
74047: PUSH
74048: LD_VAR 0 5
74052: PUSH
74053: LD_INT 2
74055: ARRAY
74056: ST_TO_ADDR
// end ; if not weapon then
74057: LD_VAR 0 9
74061: NOT
74062: IFFALSE 74066
// continue ;
74064: GO 73694
// ComPlaceWeapon ( tw , weapon ) ;
74066: LD_VAR 0 7
74070: PPUSH
74071: LD_VAR 0 9
74075: PPUSH
74076: CALL_OW 148
// end ;
74080: GO 73694
74082: POP
74083: POP
// end ;
74084: LD_VAR 0 1
74088: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
74089: LD_INT 0
74091: PPUSH
74092: PPUSH
74093: PPUSH
74094: PPUSH
74095: PPUSH
74096: PPUSH
// if not mc_bases then
74097: LD_EXP 86
74101: NOT
74102: IFFALSE 74106
// exit ;
74104: GO 74882
// for i = 1 to mc_bases do
74106: LD_ADDR_VAR 0 2
74110: PUSH
74111: DOUBLE
74112: LD_INT 1
74114: DEC
74115: ST_TO_ADDR
74116: LD_EXP 86
74120: PUSH
74121: FOR_TO
74122: IFFALSE 74880
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
74124: LD_EXP 99
74128: PUSH
74129: LD_VAR 0 2
74133: ARRAY
74134: NOT
74135: PUSH
74136: LD_EXP 99
74140: PUSH
74141: LD_VAR 0 2
74145: ARRAY
74146: PUSH
74147: LD_EXP 100
74151: PUSH
74152: LD_VAR 0 2
74156: ARRAY
74157: EQUAL
74158: OR
74159: PUSH
74160: LD_EXP 109
74164: PUSH
74165: LD_VAR 0 2
74169: ARRAY
74170: OR
74171: IFFALSE 74175
// continue ;
74173: GO 74121
// if mc_miners [ i ] then
74175: LD_EXP 100
74179: PUSH
74180: LD_VAR 0 2
74184: ARRAY
74185: IFFALSE 74567
// begin for j = mc_miners [ i ] downto 1 do
74187: LD_ADDR_VAR 0 3
74191: PUSH
74192: DOUBLE
74193: LD_EXP 100
74197: PUSH
74198: LD_VAR 0 2
74202: ARRAY
74203: INC
74204: ST_TO_ADDR
74205: LD_INT 1
74207: PUSH
74208: FOR_DOWNTO
74209: IFFALSE 74565
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
74211: LD_EXP 100
74215: PUSH
74216: LD_VAR 0 2
74220: ARRAY
74221: PUSH
74222: LD_VAR 0 3
74226: ARRAY
74227: PPUSH
74228: CALL_OW 301
74232: PUSH
74233: LD_EXP 100
74237: PUSH
74238: LD_VAR 0 2
74242: ARRAY
74243: PUSH
74244: LD_VAR 0 3
74248: ARRAY
74249: PPUSH
74250: CALL_OW 257
74254: PUSH
74255: LD_INT 1
74257: NONEQUAL
74258: OR
74259: IFFALSE 74322
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
74261: LD_ADDR_VAR 0 5
74265: PUSH
74266: LD_EXP 100
74270: PUSH
74271: LD_VAR 0 2
74275: ARRAY
74276: PUSH
74277: LD_EXP 100
74281: PUSH
74282: LD_VAR 0 2
74286: ARRAY
74287: PUSH
74288: LD_VAR 0 3
74292: ARRAY
74293: DIFF
74294: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74295: LD_ADDR_EXP 100
74299: PUSH
74300: LD_EXP 100
74304: PPUSH
74305: LD_VAR 0 2
74309: PPUSH
74310: LD_VAR 0 5
74314: PPUSH
74315: CALL_OW 1
74319: ST_TO_ADDR
// continue ;
74320: GO 74208
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74322: LD_EXP 100
74326: PUSH
74327: LD_VAR 0 2
74331: ARRAY
74332: PUSH
74333: LD_VAR 0 3
74337: ARRAY
74338: PPUSH
74339: CALL_OW 257
74343: PUSH
74344: LD_INT 1
74346: EQUAL
74347: PUSH
74348: LD_EXP 100
74352: PUSH
74353: LD_VAR 0 2
74357: ARRAY
74358: PUSH
74359: LD_VAR 0 3
74363: ARRAY
74364: PPUSH
74365: CALL_OW 459
74369: NOT
74370: AND
74371: PUSH
74372: LD_EXP 100
74376: PUSH
74377: LD_VAR 0 2
74381: ARRAY
74382: PUSH
74383: LD_VAR 0 3
74387: ARRAY
74388: PPUSH
74389: CALL_OW 314
74393: NOT
74394: AND
74395: IFFALSE 74563
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74397: LD_EXP 100
74401: PUSH
74402: LD_VAR 0 2
74406: ARRAY
74407: PUSH
74408: LD_VAR 0 3
74412: ARRAY
74413: PPUSH
74414: CALL_OW 310
74418: IFFALSE 74441
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74420: LD_EXP 100
74424: PUSH
74425: LD_VAR 0 2
74429: ARRAY
74430: PUSH
74431: LD_VAR 0 3
74435: ARRAY
74436: PPUSH
74437: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74441: LD_EXP 100
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: PUSH
74452: LD_VAR 0 3
74456: ARRAY
74457: PPUSH
74458: CALL_OW 314
74462: NOT
74463: IFFALSE 74563
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
74465: LD_EXP 100
74469: PUSH
74470: LD_VAR 0 2
74474: ARRAY
74475: PUSH
74476: LD_VAR 0 3
74480: ARRAY
74481: PPUSH
74482: LD_EXP 99
74486: PUSH
74487: LD_VAR 0 2
74491: ARRAY
74492: PUSH
74493: LD_VAR 0 3
74497: PUSH
74498: LD_EXP 99
74502: PUSH
74503: LD_VAR 0 2
74507: ARRAY
74508: MOD
74509: PUSH
74510: LD_INT 1
74512: PLUS
74513: ARRAY
74514: PUSH
74515: LD_INT 1
74517: ARRAY
74518: PPUSH
74519: LD_EXP 99
74523: PUSH
74524: LD_VAR 0 2
74528: ARRAY
74529: PUSH
74530: LD_VAR 0 3
74534: PUSH
74535: LD_EXP 99
74539: PUSH
74540: LD_VAR 0 2
74544: ARRAY
74545: MOD
74546: PUSH
74547: LD_INT 1
74549: PLUS
74550: ARRAY
74551: PUSH
74552: LD_INT 2
74554: ARRAY
74555: PPUSH
74556: LD_INT 0
74558: PPUSH
74559: CALL_OW 193
// end ; end ;
74563: GO 74208
74565: POP
74566: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74567: LD_ADDR_VAR 0 5
74571: PUSH
74572: LD_EXP 86
74576: PUSH
74577: LD_VAR 0 2
74581: ARRAY
74582: PPUSH
74583: LD_INT 2
74585: PUSH
74586: LD_INT 30
74588: PUSH
74589: LD_INT 4
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 30
74598: PUSH
74599: LD_INT 5
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 30
74608: PUSH
74609: LD_INT 32
74611: PUSH
74612: EMPTY
74613: LIST
74614: LIST
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: PPUSH
74622: CALL_OW 72
74626: ST_TO_ADDR
// if not tmp then
74627: LD_VAR 0 5
74631: NOT
74632: IFFALSE 74636
// continue ;
74634: GO 74121
// list := [ ] ;
74636: LD_ADDR_VAR 0 6
74640: PUSH
74641: EMPTY
74642: ST_TO_ADDR
// for j in tmp do
74643: LD_ADDR_VAR 0 3
74647: PUSH
74648: LD_VAR 0 5
74652: PUSH
74653: FOR_IN
74654: IFFALSE 74723
// begin for k in UnitsInside ( j ) do
74656: LD_ADDR_VAR 0 4
74660: PUSH
74661: LD_VAR 0 3
74665: PPUSH
74666: CALL_OW 313
74670: PUSH
74671: FOR_IN
74672: IFFALSE 74719
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74674: LD_VAR 0 4
74678: PPUSH
74679: CALL_OW 257
74683: PUSH
74684: LD_INT 1
74686: EQUAL
74687: PUSH
74688: LD_VAR 0 4
74692: PPUSH
74693: CALL_OW 459
74697: NOT
74698: AND
74699: IFFALSE 74717
// list := list ^ k ;
74701: LD_ADDR_VAR 0 6
74705: PUSH
74706: LD_VAR 0 6
74710: PUSH
74711: LD_VAR 0 4
74715: ADD
74716: ST_TO_ADDR
74717: GO 74671
74719: POP
74720: POP
// end ;
74721: GO 74653
74723: POP
74724: POP
// list := list diff mc_miners [ i ] ;
74725: LD_ADDR_VAR 0 6
74729: PUSH
74730: LD_VAR 0 6
74734: PUSH
74735: LD_EXP 100
74739: PUSH
74740: LD_VAR 0 2
74744: ARRAY
74745: DIFF
74746: ST_TO_ADDR
// if not list then
74747: LD_VAR 0 6
74751: NOT
74752: IFFALSE 74756
// continue ;
74754: GO 74121
// k := mc_mines [ i ] - mc_miners [ i ] ;
74756: LD_ADDR_VAR 0 4
74760: PUSH
74761: LD_EXP 99
74765: PUSH
74766: LD_VAR 0 2
74770: ARRAY
74771: PUSH
74772: LD_EXP 100
74776: PUSH
74777: LD_VAR 0 2
74781: ARRAY
74782: MINUS
74783: ST_TO_ADDR
// if k > list then
74784: LD_VAR 0 4
74788: PUSH
74789: LD_VAR 0 6
74793: GREATER
74794: IFFALSE 74806
// k := list ;
74796: LD_ADDR_VAR 0 4
74800: PUSH
74801: LD_VAR 0 6
74805: ST_TO_ADDR
// for j = 1 to k do
74806: LD_ADDR_VAR 0 3
74810: PUSH
74811: DOUBLE
74812: LD_INT 1
74814: DEC
74815: ST_TO_ADDR
74816: LD_VAR 0 4
74820: PUSH
74821: FOR_TO
74822: IFFALSE 74876
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74824: LD_ADDR_EXP 100
74828: PUSH
74829: LD_EXP 100
74833: PPUSH
74834: LD_VAR 0 2
74838: PUSH
74839: LD_EXP 100
74843: PUSH
74844: LD_VAR 0 2
74848: ARRAY
74849: PUSH
74850: LD_INT 1
74852: PLUS
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PPUSH
74858: LD_VAR 0 6
74862: PUSH
74863: LD_VAR 0 3
74867: ARRAY
74868: PPUSH
74869: CALL 22477 0 3
74873: ST_TO_ADDR
74874: GO 74821
74876: POP
74877: POP
// end ;
74878: GO 74121
74880: POP
74881: POP
// end ;
74882: LD_VAR 0 1
74886: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
74887: LD_INT 0
74889: PPUSH
74890: PPUSH
74891: PPUSH
74892: PPUSH
74893: PPUSH
74894: PPUSH
74895: PPUSH
74896: PPUSH
74897: PPUSH
74898: PPUSH
// if not mc_bases then
74899: LD_EXP 86
74903: NOT
74904: IFFALSE 74908
// exit ;
74906: GO 76658
// for i = 1 to mc_bases do
74908: LD_ADDR_VAR 0 2
74912: PUSH
74913: DOUBLE
74914: LD_INT 1
74916: DEC
74917: ST_TO_ADDR
74918: LD_EXP 86
74922: PUSH
74923: FOR_TO
74924: IFFALSE 76656
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74926: LD_EXP 86
74930: PUSH
74931: LD_VAR 0 2
74935: ARRAY
74936: NOT
74937: PUSH
74938: LD_EXP 93
74942: PUSH
74943: LD_VAR 0 2
74947: ARRAY
74948: OR
74949: IFFALSE 74953
// continue ;
74951: GO 74923
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74953: LD_EXP 102
74957: PUSH
74958: LD_VAR 0 2
74962: ARRAY
74963: NOT
74964: PUSH
74965: LD_EXP 103
74969: PUSH
74970: LD_VAR 0 2
74974: ARRAY
74975: AND
74976: IFFALSE 75014
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74978: LD_ADDR_EXP 103
74982: PUSH
74983: LD_EXP 103
74987: PPUSH
74988: LD_VAR 0 2
74992: PPUSH
74993: EMPTY
74994: PPUSH
74995: CALL_OW 1
74999: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
75000: LD_VAR 0 2
75004: PPUSH
75005: LD_INT 107
75007: PPUSH
75008: CALL 65862 0 2
// continue ;
75012: GO 74923
// end ; target := [ ] ;
75014: LD_ADDR_VAR 0 6
75018: PUSH
75019: EMPTY
75020: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
75021: LD_ADDR_VAR 0 3
75025: PUSH
75026: DOUBLE
75027: LD_EXP 102
75031: PUSH
75032: LD_VAR 0 2
75036: ARRAY
75037: INC
75038: ST_TO_ADDR
75039: LD_INT 1
75041: PUSH
75042: FOR_DOWNTO
75043: IFFALSE 75303
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
75045: LD_EXP 102
75049: PUSH
75050: LD_VAR 0 2
75054: ARRAY
75055: PUSH
75056: LD_VAR 0 3
75060: ARRAY
75061: PUSH
75062: LD_INT 2
75064: ARRAY
75065: PPUSH
75066: LD_EXP 102
75070: PUSH
75071: LD_VAR 0 2
75075: ARRAY
75076: PUSH
75077: LD_VAR 0 3
75081: ARRAY
75082: PUSH
75083: LD_INT 3
75085: ARRAY
75086: PPUSH
75087: CALL_OW 488
75091: PUSH
75092: LD_EXP 102
75096: PUSH
75097: LD_VAR 0 2
75101: ARRAY
75102: PUSH
75103: LD_VAR 0 3
75107: ARRAY
75108: PUSH
75109: LD_INT 2
75111: ARRAY
75112: PPUSH
75113: LD_EXP 102
75117: PUSH
75118: LD_VAR 0 2
75122: ARRAY
75123: PUSH
75124: LD_VAR 0 3
75128: ARRAY
75129: PUSH
75130: LD_INT 3
75132: ARRAY
75133: PPUSH
75134: CALL_OW 284
75138: PUSH
75139: LD_INT 0
75141: EQUAL
75142: AND
75143: IFFALSE 75198
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
75145: LD_ADDR_VAR 0 5
75149: PUSH
75150: LD_EXP 102
75154: PUSH
75155: LD_VAR 0 2
75159: ARRAY
75160: PPUSH
75161: LD_VAR 0 3
75165: PPUSH
75166: CALL_OW 3
75170: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
75171: LD_ADDR_EXP 102
75175: PUSH
75176: LD_EXP 102
75180: PPUSH
75181: LD_VAR 0 2
75185: PPUSH
75186: LD_VAR 0 5
75190: PPUSH
75191: CALL_OW 1
75195: ST_TO_ADDR
// continue ;
75196: GO 75042
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
75198: LD_EXP 86
75202: PUSH
75203: LD_VAR 0 2
75207: ARRAY
75208: PUSH
75209: LD_INT 1
75211: ARRAY
75212: PPUSH
75213: CALL_OW 255
75217: PPUSH
75218: LD_EXP 102
75222: PUSH
75223: LD_VAR 0 2
75227: ARRAY
75228: PUSH
75229: LD_VAR 0 3
75233: ARRAY
75234: PUSH
75235: LD_INT 2
75237: ARRAY
75238: PPUSH
75239: LD_EXP 102
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PUSH
75250: LD_VAR 0 3
75254: ARRAY
75255: PUSH
75256: LD_INT 3
75258: ARRAY
75259: PPUSH
75260: LD_INT 30
75262: PPUSH
75263: CALL 23373 0 4
75267: PUSH
75268: LD_INT 4
75270: ARRAY
75271: PUSH
75272: LD_INT 0
75274: EQUAL
75275: IFFALSE 75301
// begin target := mc_crates [ i ] [ j ] ;
75277: LD_ADDR_VAR 0 6
75281: PUSH
75282: LD_EXP 102
75286: PUSH
75287: LD_VAR 0 2
75291: ARRAY
75292: PUSH
75293: LD_VAR 0 3
75297: ARRAY
75298: ST_TO_ADDR
// break ;
75299: GO 75303
// end ; end ;
75301: GO 75042
75303: POP
75304: POP
// if not target then
75305: LD_VAR 0 6
75309: NOT
75310: IFFALSE 75314
// continue ;
75312: GO 74923
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75314: LD_ADDR_VAR 0 7
75318: PUSH
75319: LD_EXP 105
75323: PUSH
75324: LD_VAR 0 2
75328: ARRAY
75329: PPUSH
75330: LD_INT 2
75332: PUSH
75333: LD_INT 3
75335: PUSH
75336: LD_INT 58
75338: PUSH
75339: EMPTY
75340: LIST
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 61
75348: PUSH
75349: EMPTY
75350: LIST
75351: PUSH
75352: LD_INT 33
75354: PUSH
75355: LD_INT 5
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 33
75364: PUSH
75365: LD_INT 3
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 2
75381: PUSH
75382: LD_INT 34
75384: PUSH
75385: LD_INT 32
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 34
75394: PUSH
75395: LD_INT 51
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 34
75404: PUSH
75405: LD_INT 12
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PPUSH
75422: CALL_OW 72
75426: ST_TO_ADDR
// if not cargo then
75427: LD_VAR 0 7
75431: NOT
75432: IFFALSE 76075
// begin if mc_crates_collector [ i ] < 5 then
75434: LD_EXP 103
75438: PUSH
75439: LD_VAR 0 2
75443: ARRAY
75444: PUSH
75445: LD_INT 5
75447: LESS
75448: IFFALSE 75814
// begin if mc_ape [ i ] then
75450: LD_EXP 115
75454: PUSH
75455: LD_VAR 0 2
75459: ARRAY
75460: IFFALSE 75507
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75462: LD_ADDR_VAR 0 5
75466: PUSH
75467: LD_EXP 115
75471: PUSH
75472: LD_VAR 0 2
75476: ARRAY
75477: PPUSH
75478: LD_INT 25
75480: PUSH
75481: LD_INT 16
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 24
75490: PUSH
75491: LD_INT 750
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PPUSH
75502: CALL_OW 72
75506: ST_TO_ADDR
// if not tmp then
75507: LD_VAR 0 5
75511: NOT
75512: IFFALSE 75559
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75514: LD_ADDR_VAR 0 5
75518: PUSH
75519: LD_EXP 86
75523: PUSH
75524: LD_VAR 0 2
75528: ARRAY
75529: PPUSH
75530: LD_INT 25
75532: PUSH
75533: LD_INT 2
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 24
75542: PUSH
75543: LD_INT 750
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PPUSH
75554: CALL_OW 72
75558: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75559: LD_EXP 115
75563: PUSH
75564: LD_VAR 0 2
75568: ARRAY
75569: PUSH
75570: LD_EXP 86
75574: PUSH
75575: LD_VAR 0 2
75579: ARRAY
75580: PPUSH
75581: LD_INT 25
75583: PUSH
75584: LD_INT 2
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 24
75593: PUSH
75594: LD_INT 750
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PPUSH
75605: CALL_OW 72
75609: AND
75610: PUSH
75611: LD_VAR 0 5
75615: PUSH
75616: LD_INT 5
75618: LESS
75619: AND
75620: IFFALSE 75702
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75622: LD_ADDR_VAR 0 3
75626: PUSH
75627: LD_EXP 86
75631: PUSH
75632: LD_VAR 0 2
75636: ARRAY
75637: PPUSH
75638: LD_INT 25
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 24
75650: PUSH
75651: LD_INT 750
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PPUSH
75662: CALL_OW 72
75666: PUSH
75667: FOR_IN
75668: IFFALSE 75700
// begin tmp := tmp union j ;
75670: LD_ADDR_VAR 0 5
75674: PUSH
75675: LD_VAR 0 5
75679: PUSH
75680: LD_VAR 0 3
75684: UNION
75685: ST_TO_ADDR
// if tmp >= 5 then
75686: LD_VAR 0 5
75690: PUSH
75691: LD_INT 5
75693: GREATEREQUAL
75694: IFFALSE 75698
// break ;
75696: GO 75700
// end ;
75698: GO 75667
75700: POP
75701: POP
// end ; if not tmp then
75702: LD_VAR 0 5
75706: NOT
75707: IFFALSE 75711
// continue ;
75709: GO 74923
// for j in tmp do
75711: LD_ADDR_VAR 0 3
75715: PUSH
75716: LD_VAR 0 5
75720: PUSH
75721: FOR_IN
75722: IFFALSE 75812
// if not GetTag ( j ) then
75724: LD_VAR 0 3
75728: PPUSH
75729: CALL_OW 110
75733: NOT
75734: IFFALSE 75810
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75736: LD_ADDR_EXP 103
75740: PUSH
75741: LD_EXP 103
75745: PPUSH
75746: LD_VAR 0 2
75750: PUSH
75751: LD_EXP 103
75755: PUSH
75756: LD_VAR 0 2
75760: ARRAY
75761: PUSH
75762: LD_INT 1
75764: PLUS
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PPUSH
75770: LD_VAR 0 3
75774: PPUSH
75775: CALL 22477 0 3
75779: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75780: LD_VAR 0 3
75784: PPUSH
75785: LD_INT 107
75787: PPUSH
75788: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75792: LD_EXP 103
75796: PUSH
75797: LD_VAR 0 2
75801: ARRAY
75802: PUSH
75803: LD_INT 5
75805: GREATEREQUAL
75806: IFFALSE 75810
// break ;
75808: GO 75812
// end ;
75810: GO 75721
75812: POP
75813: POP
// end ; if mc_crates_collector [ i ] and target then
75814: LD_EXP 103
75818: PUSH
75819: LD_VAR 0 2
75823: ARRAY
75824: PUSH
75825: LD_VAR 0 6
75829: AND
75830: IFFALSE 76073
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75832: LD_EXP 103
75836: PUSH
75837: LD_VAR 0 2
75841: ARRAY
75842: PUSH
75843: LD_VAR 0 6
75847: PUSH
75848: LD_INT 1
75850: ARRAY
75851: LESS
75852: IFFALSE 75872
// tmp := mc_crates_collector [ i ] else
75854: LD_ADDR_VAR 0 5
75858: PUSH
75859: LD_EXP 103
75863: PUSH
75864: LD_VAR 0 2
75868: ARRAY
75869: ST_TO_ADDR
75870: GO 75886
// tmp := target [ 1 ] ;
75872: LD_ADDR_VAR 0 5
75876: PUSH
75877: LD_VAR 0 6
75881: PUSH
75882: LD_INT 1
75884: ARRAY
75885: ST_TO_ADDR
// k := 0 ;
75886: LD_ADDR_VAR 0 4
75890: PUSH
75891: LD_INT 0
75893: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75894: LD_ADDR_VAR 0 3
75898: PUSH
75899: LD_EXP 103
75903: PUSH
75904: LD_VAR 0 2
75908: ARRAY
75909: PUSH
75910: FOR_IN
75911: IFFALSE 76071
// begin k := k + 1 ;
75913: LD_ADDR_VAR 0 4
75917: PUSH
75918: LD_VAR 0 4
75922: PUSH
75923: LD_INT 1
75925: PLUS
75926: ST_TO_ADDR
// if k > tmp then
75927: LD_VAR 0 4
75931: PUSH
75932: LD_VAR 0 5
75936: GREATER
75937: IFFALSE 75941
// break ;
75939: GO 76071
// if not GetClass ( j ) in [ 2 , 16 ] then
75941: LD_VAR 0 3
75945: PPUSH
75946: CALL_OW 257
75950: PUSH
75951: LD_INT 2
75953: PUSH
75954: LD_INT 16
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: IN
75961: NOT
75962: IFFALSE 76015
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75964: LD_ADDR_EXP 103
75968: PUSH
75969: LD_EXP 103
75973: PPUSH
75974: LD_VAR 0 2
75978: PPUSH
75979: LD_EXP 103
75983: PUSH
75984: LD_VAR 0 2
75988: ARRAY
75989: PUSH
75990: LD_VAR 0 3
75994: DIFF
75995: PPUSH
75996: CALL_OW 1
76000: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76001: LD_VAR 0 3
76005: PPUSH
76006: LD_INT 0
76008: PPUSH
76009: CALL_OW 109
// continue ;
76013: GO 75910
// end ; if IsInUnit ( j ) then
76015: LD_VAR 0 3
76019: PPUSH
76020: CALL_OW 310
76024: IFFALSE 76035
// ComExitBuilding ( j ) ;
76026: LD_VAR 0 3
76030: PPUSH
76031: CALL_OW 122
// wait ( 3 ) ;
76035: LD_INT 3
76037: PPUSH
76038: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76042: LD_VAR 0 3
76046: PPUSH
76047: LD_VAR 0 6
76051: PUSH
76052: LD_INT 2
76054: ARRAY
76055: PPUSH
76056: LD_VAR 0 6
76060: PUSH
76061: LD_INT 3
76063: ARRAY
76064: PPUSH
76065: CALL_OW 117
// end ;
76069: GO 75910
76071: POP
76072: POP
// end ; end else
76073: GO 76654
// begin for j in cargo do
76075: LD_ADDR_VAR 0 3
76079: PUSH
76080: LD_VAR 0 7
76084: PUSH
76085: FOR_IN
76086: IFFALSE 76652
// begin if GetTag ( j ) <> 0 then
76088: LD_VAR 0 3
76092: PPUSH
76093: CALL_OW 110
76097: PUSH
76098: LD_INT 0
76100: NONEQUAL
76101: IFFALSE 76105
// continue ;
76103: GO 76085
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
76105: LD_VAR 0 3
76109: PPUSH
76110: CALL_OW 256
76114: PUSH
76115: LD_INT 1000
76117: LESS
76118: PUSH
76119: LD_VAR 0 3
76123: PPUSH
76124: LD_EXP 110
76128: PUSH
76129: LD_VAR 0 2
76133: ARRAY
76134: PPUSH
76135: CALL_OW 308
76139: NOT
76140: AND
76141: IFFALSE 76163
// ComMoveToArea ( j , mc_parking [ i ] ) ;
76143: LD_VAR 0 3
76147: PPUSH
76148: LD_EXP 110
76152: PUSH
76153: LD_VAR 0 2
76157: ARRAY
76158: PPUSH
76159: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
76163: LD_VAR 0 3
76167: PPUSH
76168: CALL_OW 256
76172: PUSH
76173: LD_INT 1000
76175: LESS
76176: PUSH
76177: LD_VAR 0 3
76181: PPUSH
76182: LD_EXP 110
76186: PUSH
76187: LD_VAR 0 2
76191: ARRAY
76192: PPUSH
76193: CALL_OW 308
76197: AND
76198: IFFALSE 76202
// continue ;
76200: GO 76085
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76202: LD_VAR 0 3
76206: PPUSH
76207: CALL_OW 262
76211: PUSH
76212: LD_INT 2
76214: EQUAL
76215: PUSH
76216: LD_VAR 0 3
76220: PPUSH
76221: CALL_OW 261
76225: PUSH
76226: LD_INT 15
76228: LESS
76229: AND
76230: IFFALSE 76234
// continue ;
76232: GO 76085
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76234: LD_VAR 0 3
76238: PPUSH
76239: CALL_OW 262
76243: PUSH
76244: LD_INT 1
76246: EQUAL
76247: PUSH
76248: LD_VAR 0 3
76252: PPUSH
76253: CALL_OW 261
76257: PUSH
76258: LD_INT 10
76260: LESS
76261: AND
76262: IFFALSE 76591
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76264: LD_ADDR_VAR 0 8
76268: PUSH
76269: LD_EXP 86
76273: PUSH
76274: LD_VAR 0 2
76278: ARRAY
76279: PPUSH
76280: LD_INT 2
76282: PUSH
76283: LD_INT 30
76285: PUSH
76286: LD_INT 0
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 30
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: LIST
76307: PPUSH
76308: CALL_OW 72
76312: ST_TO_ADDR
// if not depot then
76313: LD_VAR 0 8
76317: NOT
76318: IFFALSE 76322
// continue ;
76320: GO 76085
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76322: LD_VAR 0 3
76326: PPUSH
76327: LD_VAR 0 8
76331: PPUSH
76332: LD_VAR 0 3
76336: PPUSH
76337: CALL_OW 74
76341: PPUSH
76342: CALL_OW 296
76346: PUSH
76347: LD_INT 6
76349: LESS
76350: IFFALSE 76366
// SetFuel ( j , 100 ) else
76352: LD_VAR 0 3
76356: PPUSH
76357: LD_INT 100
76359: PPUSH
76360: CALL_OW 240
76364: GO 76591
// if GetFuel ( j ) = 0 then
76366: LD_VAR 0 3
76370: PPUSH
76371: CALL_OW 261
76375: PUSH
76376: LD_INT 0
76378: EQUAL
76379: IFFALSE 76591
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76381: LD_ADDR_EXP 105
76385: PUSH
76386: LD_EXP 105
76390: PPUSH
76391: LD_VAR 0 2
76395: PPUSH
76396: LD_EXP 105
76400: PUSH
76401: LD_VAR 0 2
76405: ARRAY
76406: PUSH
76407: LD_VAR 0 3
76411: DIFF
76412: PPUSH
76413: CALL_OW 1
76417: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76418: LD_VAR 0 3
76422: PPUSH
76423: CALL_OW 263
76427: PUSH
76428: LD_INT 1
76430: EQUAL
76431: IFFALSE 76447
// ComExitVehicle ( IsInUnit ( j ) ) ;
76433: LD_VAR 0 3
76437: PPUSH
76438: CALL_OW 310
76442: PPUSH
76443: CALL_OW 121
// if GetControl ( j ) = control_remote then
76447: LD_VAR 0 3
76451: PPUSH
76452: CALL_OW 263
76456: PUSH
76457: LD_INT 2
76459: EQUAL
76460: IFFALSE 76471
// ComUnlink ( j ) ;
76462: LD_VAR 0 3
76466: PPUSH
76467: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76471: LD_ADDR_VAR 0 9
76475: PUSH
76476: LD_VAR 0 2
76480: PPUSH
76481: LD_INT 3
76483: PPUSH
76484: CALL 85966 0 2
76488: ST_TO_ADDR
// if fac then
76489: LD_VAR 0 9
76493: IFFALSE 76589
// begin for k in fac do
76495: LD_ADDR_VAR 0 4
76499: PUSH
76500: LD_VAR 0 9
76504: PUSH
76505: FOR_IN
76506: IFFALSE 76587
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76508: LD_ADDR_VAR 0 10
76512: PUSH
76513: LD_VAR 0 9
76517: PPUSH
76518: LD_VAR 0 3
76522: PPUSH
76523: CALL_OW 265
76527: PPUSH
76528: LD_VAR 0 3
76532: PPUSH
76533: CALL_OW 262
76537: PPUSH
76538: LD_VAR 0 3
76542: PPUSH
76543: CALL_OW 263
76547: PPUSH
76548: LD_VAR 0 3
76552: PPUSH
76553: CALL_OW 264
76557: PPUSH
76558: CALL 20009 0 5
76562: ST_TO_ADDR
// if components then
76563: LD_VAR 0 10
76567: IFFALSE 76585
// begin MC_InsertProduceList ( i , components ) ;
76569: LD_VAR 0 2
76573: PPUSH
76574: LD_VAR 0 10
76578: PPUSH
76579: CALL 85511 0 2
// break ;
76583: GO 76587
// end ; end ;
76585: GO 76505
76587: POP
76588: POP
// end ; continue ;
76589: GO 76085
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76591: LD_VAR 0 3
76595: PPUSH
76596: LD_INT 1
76598: PPUSH
76599: CALL_OW 289
76603: PUSH
76604: LD_INT 100
76606: LESS
76607: PUSH
76608: LD_VAR 0 3
76612: PPUSH
76613: CALL_OW 314
76617: NOT
76618: AND
76619: IFFALSE 76648
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76621: LD_VAR 0 3
76625: PPUSH
76626: LD_VAR 0 6
76630: PUSH
76631: LD_INT 2
76633: ARRAY
76634: PPUSH
76635: LD_VAR 0 6
76639: PUSH
76640: LD_INT 3
76642: ARRAY
76643: PPUSH
76644: CALL_OW 117
// break ;
76648: GO 76652
// end ;
76650: GO 76085
76652: POP
76653: POP
// end ; end ;
76654: GO 74923
76656: POP
76657: POP
// end ;
76658: LD_VAR 0 1
76662: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76663: LD_INT 0
76665: PPUSH
76666: PPUSH
76667: PPUSH
76668: PPUSH
// if not mc_bases then
76669: LD_EXP 86
76673: NOT
76674: IFFALSE 76678
// exit ;
76676: GO 76839
// for i = 1 to mc_bases do
76678: LD_ADDR_VAR 0 2
76682: PUSH
76683: DOUBLE
76684: LD_INT 1
76686: DEC
76687: ST_TO_ADDR
76688: LD_EXP 86
76692: PUSH
76693: FOR_TO
76694: IFFALSE 76837
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76696: LD_ADDR_VAR 0 4
76700: PUSH
76701: LD_EXP 105
76705: PUSH
76706: LD_VAR 0 2
76710: ARRAY
76711: PUSH
76712: LD_EXP 108
76716: PUSH
76717: LD_VAR 0 2
76721: ARRAY
76722: UNION
76723: PPUSH
76724: LD_INT 33
76726: PUSH
76727: LD_INT 2
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PPUSH
76734: CALL_OW 72
76738: ST_TO_ADDR
// if tmp then
76739: LD_VAR 0 4
76743: IFFALSE 76835
// for j in tmp do
76745: LD_ADDR_VAR 0 3
76749: PUSH
76750: LD_VAR 0 4
76754: PUSH
76755: FOR_IN
76756: IFFALSE 76833
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76758: LD_VAR 0 3
76762: PPUSH
76763: CALL_OW 312
76767: NOT
76768: PUSH
76769: LD_VAR 0 3
76773: PPUSH
76774: CALL_OW 256
76778: PUSH
76779: LD_INT 250
76781: GREATEREQUAL
76782: AND
76783: IFFALSE 76796
// Connect ( j ) else
76785: LD_VAR 0 3
76789: PPUSH
76790: CALL 25410 0 1
76794: GO 76831
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76796: LD_VAR 0 3
76800: PPUSH
76801: CALL_OW 256
76805: PUSH
76806: LD_INT 250
76808: LESS
76809: PUSH
76810: LD_VAR 0 3
76814: PPUSH
76815: CALL_OW 312
76819: AND
76820: IFFALSE 76831
// ComUnlink ( j ) ;
76822: LD_VAR 0 3
76826: PPUSH
76827: CALL_OW 136
76831: GO 76755
76833: POP
76834: POP
// end ;
76835: GO 76693
76837: POP
76838: POP
// end ;
76839: LD_VAR 0 1
76843: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76844: LD_INT 0
76846: PPUSH
76847: PPUSH
76848: PPUSH
76849: PPUSH
76850: PPUSH
// if not mc_bases then
76851: LD_EXP 86
76855: NOT
76856: IFFALSE 76860
// exit ;
76858: GO 77305
// for i = 1 to mc_bases do
76860: LD_ADDR_VAR 0 2
76864: PUSH
76865: DOUBLE
76866: LD_INT 1
76868: DEC
76869: ST_TO_ADDR
76870: LD_EXP 86
76874: PUSH
76875: FOR_TO
76876: IFFALSE 77303
// begin if not mc_produce [ i ] then
76878: LD_EXP 107
76882: PUSH
76883: LD_VAR 0 2
76887: ARRAY
76888: NOT
76889: IFFALSE 76893
// continue ;
76891: GO 76875
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76893: LD_ADDR_VAR 0 5
76897: PUSH
76898: LD_EXP 86
76902: PUSH
76903: LD_VAR 0 2
76907: ARRAY
76908: PPUSH
76909: LD_INT 30
76911: PUSH
76912: LD_INT 3
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PPUSH
76919: CALL_OW 72
76923: ST_TO_ADDR
// if not fac then
76924: LD_VAR 0 5
76928: NOT
76929: IFFALSE 76933
// continue ;
76931: GO 76875
// for j in fac do
76933: LD_ADDR_VAR 0 3
76937: PUSH
76938: LD_VAR 0 5
76942: PUSH
76943: FOR_IN
76944: IFFALSE 77299
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76946: LD_VAR 0 3
76950: PPUSH
76951: CALL_OW 461
76955: PUSH
76956: LD_INT 2
76958: NONEQUAL
76959: PUSH
76960: LD_VAR 0 3
76964: PPUSH
76965: LD_INT 15
76967: PPUSH
76968: CALL 25070 0 2
76972: PUSH
76973: LD_INT 4
76975: ARRAY
76976: OR
76977: IFFALSE 76981
// continue ;
76979: GO 76943
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76981: LD_VAR 0 3
76985: PPUSH
76986: LD_EXP 107
76990: PUSH
76991: LD_VAR 0 2
76995: ARRAY
76996: PUSH
76997: LD_INT 1
76999: ARRAY
77000: PUSH
77001: LD_INT 1
77003: ARRAY
77004: PPUSH
77005: LD_EXP 107
77009: PUSH
77010: LD_VAR 0 2
77014: ARRAY
77015: PUSH
77016: LD_INT 1
77018: ARRAY
77019: PUSH
77020: LD_INT 2
77022: ARRAY
77023: PPUSH
77024: LD_EXP 107
77028: PUSH
77029: LD_VAR 0 2
77033: ARRAY
77034: PUSH
77035: LD_INT 1
77037: ARRAY
77038: PUSH
77039: LD_INT 3
77041: ARRAY
77042: PPUSH
77043: LD_EXP 107
77047: PUSH
77048: LD_VAR 0 2
77052: ARRAY
77053: PUSH
77054: LD_INT 1
77056: ARRAY
77057: PUSH
77058: LD_INT 4
77060: ARRAY
77061: PPUSH
77062: CALL_OW 448
77066: PUSH
77067: LD_VAR 0 3
77071: PPUSH
77072: LD_EXP 107
77076: PUSH
77077: LD_VAR 0 2
77081: ARRAY
77082: PUSH
77083: LD_INT 1
77085: ARRAY
77086: PUSH
77087: LD_INT 1
77089: ARRAY
77090: PUSH
77091: LD_EXP 107
77095: PUSH
77096: LD_VAR 0 2
77100: ARRAY
77101: PUSH
77102: LD_INT 1
77104: ARRAY
77105: PUSH
77106: LD_INT 2
77108: ARRAY
77109: PUSH
77110: LD_EXP 107
77114: PUSH
77115: LD_VAR 0 2
77119: ARRAY
77120: PUSH
77121: LD_INT 1
77123: ARRAY
77124: PUSH
77125: LD_INT 3
77127: ARRAY
77128: PUSH
77129: LD_EXP 107
77133: PUSH
77134: LD_VAR 0 2
77138: ARRAY
77139: PUSH
77140: LD_INT 1
77142: ARRAY
77143: PUSH
77144: LD_INT 4
77146: ARRAY
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: PPUSH
77154: CALL 28741 0 2
77158: AND
77159: IFFALSE 77297
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
77161: LD_VAR 0 3
77165: PPUSH
77166: LD_EXP 107
77170: PUSH
77171: LD_VAR 0 2
77175: ARRAY
77176: PUSH
77177: LD_INT 1
77179: ARRAY
77180: PUSH
77181: LD_INT 1
77183: ARRAY
77184: PPUSH
77185: LD_EXP 107
77189: PUSH
77190: LD_VAR 0 2
77194: ARRAY
77195: PUSH
77196: LD_INT 1
77198: ARRAY
77199: PUSH
77200: LD_INT 2
77202: ARRAY
77203: PPUSH
77204: LD_EXP 107
77208: PUSH
77209: LD_VAR 0 2
77213: ARRAY
77214: PUSH
77215: LD_INT 1
77217: ARRAY
77218: PUSH
77219: LD_INT 3
77221: ARRAY
77222: PPUSH
77223: LD_EXP 107
77227: PUSH
77228: LD_VAR 0 2
77232: ARRAY
77233: PUSH
77234: LD_INT 1
77236: ARRAY
77237: PUSH
77238: LD_INT 4
77240: ARRAY
77241: PPUSH
77242: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77246: LD_ADDR_VAR 0 4
77250: PUSH
77251: LD_EXP 107
77255: PUSH
77256: LD_VAR 0 2
77260: ARRAY
77261: PPUSH
77262: LD_INT 1
77264: PPUSH
77265: CALL_OW 3
77269: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77270: LD_ADDR_EXP 107
77274: PUSH
77275: LD_EXP 107
77279: PPUSH
77280: LD_VAR 0 2
77284: PPUSH
77285: LD_VAR 0 4
77289: PPUSH
77290: CALL_OW 1
77294: ST_TO_ADDR
// break ;
77295: GO 77299
// end ; end ;
77297: GO 76943
77299: POP
77300: POP
// end ;
77301: GO 76875
77303: POP
77304: POP
// end ;
77305: LD_VAR 0 1
77309: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77310: LD_INT 0
77312: PPUSH
77313: PPUSH
77314: PPUSH
// if not mc_bases then
77315: LD_EXP 86
77319: NOT
77320: IFFALSE 77324
// exit ;
77322: GO 77413
// for i = 1 to mc_bases do
77324: LD_ADDR_VAR 0 2
77328: PUSH
77329: DOUBLE
77330: LD_INT 1
77332: DEC
77333: ST_TO_ADDR
77334: LD_EXP 86
77338: PUSH
77339: FOR_TO
77340: IFFALSE 77411
// begin if mc_attack [ i ] then
77342: LD_EXP 106
77346: PUSH
77347: LD_VAR 0 2
77351: ARRAY
77352: IFFALSE 77409
// begin tmp := mc_attack [ i ] [ 1 ] ;
77354: LD_ADDR_VAR 0 3
77358: PUSH
77359: LD_EXP 106
77363: PUSH
77364: LD_VAR 0 2
77368: ARRAY
77369: PUSH
77370: LD_INT 1
77372: ARRAY
77373: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77374: LD_ADDR_EXP 106
77378: PUSH
77379: LD_EXP 106
77383: PPUSH
77384: LD_VAR 0 2
77388: PPUSH
77389: EMPTY
77390: PPUSH
77391: CALL_OW 1
77395: ST_TO_ADDR
// Attack ( tmp ) ;
77396: LD_VAR 0 3
77400: PPUSH
77401: CALL 54600 0 1
// exit ;
77405: POP
77406: POP
77407: GO 77413
// end ; end ;
77409: GO 77339
77411: POP
77412: POP
// end ;
77413: LD_VAR 0 1
77417: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77418: LD_INT 0
77420: PPUSH
77421: PPUSH
77422: PPUSH
77423: PPUSH
77424: PPUSH
77425: PPUSH
77426: PPUSH
// if not mc_bases then
77427: LD_EXP 86
77431: NOT
77432: IFFALSE 77436
// exit ;
77434: GO 78040
// for i = 1 to mc_bases do
77436: LD_ADDR_VAR 0 2
77440: PUSH
77441: DOUBLE
77442: LD_INT 1
77444: DEC
77445: ST_TO_ADDR
77446: LD_EXP 86
77450: PUSH
77451: FOR_TO
77452: IFFALSE 78038
// begin if not mc_bases [ i ] then
77454: LD_EXP 86
77458: PUSH
77459: LD_VAR 0 2
77463: ARRAY
77464: NOT
77465: IFFALSE 77469
// continue ;
77467: GO 77451
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77469: LD_ADDR_VAR 0 7
77473: PUSH
77474: LD_EXP 86
77478: PUSH
77479: LD_VAR 0 2
77483: ARRAY
77484: PUSH
77485: LD_INT 1
77487: ARRAY
77488: PPUSH
77489: CALL 19313 0 1
77493: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77494: LD_ADDR_EXP 109
77498: PUSH
77499: LD_EXP 109
77503: PPUSH
77504: LD_VAR 0 2
77508: PPUSH
77509: LD_EXP 86
77513: PUSH
77514: LD_VAR 0 2
77518: ARRAY
77519: PUSH
77520: LD_INT 1
77522: ARRAY
77523: PPUSH
77524: CALL_OW 255
77528: PPUSH
77529: LD_EXP 111
77533: PUSH
77534: LD_VAR 0 2
77538: ARRAY
77539: PPUSH
77540: CALL 19278 0 2
77544: PPUSH
77545: CALL_OW 1
77549: ST_TO_ADDR
// if not mc_scan [ i ] then
77550: LD_EXP 109
77554: PUSH
77555: LD_VAR 0 2
77559: ARRAY
77560: NOT
77561: IFFALSE 77716
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77563: LD_ADDR_VAR 0 4
77567: PUSH
77568: LD_EXP 86
77572: PUSH
77573: LD_VAR 0 2
77577: ARRAY
77578: PPUSH
77579: LD_INT 2
77581: PUSH
77582: LD_INT 25
77584: PUSH
77585: LD_INT 5
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 25
77594: PUSH
77595: LD_INT 8
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 25
77604: PUSH
77605: LD_INT 9
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: PPUSH
77618: CALL_OW 72
77622: ST_TO_ADDR
// if not tmp then
77623: LD_VAR 0 4
77627: NOT
77628: IFFALSE 77632
// continue ;
77630: GO 77451
// for j in tmp do
77632: LD_ADDR_VAR 0 3
77636: PUSH
77637: LD_VAR 0 4
77641: PUSH
77642: FOR_IN
77643: IFFALSE 77714
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77645: LD_VAR 0 3
77649: PPUSH
77650: CALL_OW 310
77654: PPUSH
77655: CALL_OW 266
77659: PUSH
77660: LD_INT 5
77662: EQUAL
77663: PUSH
77664: LD_VAR 0 3
77668: PPUSH
77669: CALL_OW 257
77673: PUSH
77674: LD_INT 1
77676: EQUAL
77677: AND
77678: PUSH
77679: LD_VAR 0 3
77683: PPUSH
77684: CALL_OW 459
77688: NOT
77689: AND
77690: PUSH
77691: LD_VAR 0 7
77695: AND
77696: IFFALSE 77712
// ComChangeProfession ( j , class ) ;
77698: LD_VAR 0 3
77702: PPUSH
77703: LD_VAR 0 7
77707: PPUSH
77708: CALL_OW 123
77712: GO 77642
77714: POP
77715: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77716: LD_EXP 109
77720: PUSH
77721: LD_VAR 0 2
77725: ARRAY
77726: PUSH
77727: LD_EXP 108
77731: PUSH
77732: LD_VAR 0 2
77736: ARRAY
77737: NOT
77738: AND
77739: PUSH
77740: LD_EXP 86
77744: PUSH
77745: LD_VAR 0 2
77749: ARRAY
77750: PPUSH
77751: LD_INT 30
77753: PUSH
77754: LD_INT 32
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PPUSH
77761: CALL_OW 72
77765: NOT
77766: AND
77767: PUSH
77768: LD_EXP 86
77772: PUSH
77773: LD_VAR 0 2
77777: ARRAY
77778: PPUSH
77779: LD_INT 2
77781: PUSH
77782: LD_INT 30
77784: PUSH
77785: LD_INT 4
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 30
77794: PUSH
77795: LD_INT 5
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: PPUSH
77807: CALL_OW 72
77811: NOT
77812: AND
77813: IFFALSE 77945
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77815: LD_ADDR_VAR 0 4
77819: PUSH
77820: LD_EXP 86
77824: PUSH
77825: LD_VAR 0 2
77829: ARRAY
77830: PPUSH
77831: LD_INT 2
77833: PUSH
77834: LD_INT 25
77836: PUSH
77837: LD_INT 1
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 25
77846: PUSH
77847: LD_INT 5
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 25
77856: PUSH
77857: LD_INT 8
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 25
77866: PUSH
77867: LD_INT 9
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: PPUSH
77881: CALL_OW 72
77885: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77886: LD_ADDR_VAR 0 4
77890: PUSH
77891: LD_VAR 0 4
77895: PUSH
77896: LD_VAR 0 4
77900: PPUSH
77901: LD_INT 18
77903: PPUSH
77904: CALL 51038 0 2
77908: DIFF
77909: ST_TO_ADDR
// if tmp then
77910: LD_VAR 0 4
77914: IFFALSE 77945
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
77916: LD_VAR 0 2
77920: PPUSH
77921: LD_VAR 0 4
77925: PPUSH
77926: LD_EXP 111
77930: PUSH
77931: LD_VAR 0 2
77935: ARRAY
77936: PPUSH
77937: CALL 59309 0 3
// exit ;
77941: POP
77942: POP
77943: GO 78040
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
77945: LD_EXP 109
77949: PUSH
77950: LD_VAR 0 2
77954: ARRAY
77955: PUSH
77956: LD_EXP 108
77960: PUSH
77961: LD_VAR 0 2
77965: ARRAY
77966: AND
77967: IFFALSE 78036
// begin tmp := mc_defender [ i ] ;
77969: LD_ADDR_VAR 0 4
77973: PUSH
77974: LD_EXP 108
77978: PUSH
77979: LD_VAR 0 2
77983: ARRAY
77984: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77985: LD_ADDR_EXP 108
77989: PUSH
77990: LD_EXP 108
77994: PPUSH
77995: LD_VAR 0 2
77999: PPUSH
78000: EMPTY
78001: PPUSH
78002: CALL_OW 1
78006: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
78007: LD_VAR 0 2
78011: PPUSH
78012: LD_VAR 0 4
78016: PPUSH
78017: LD_EXP 109
78021: PUSH
78022: LD_VAR 0 2
78026: ARRAY
78027: PPUSH
78028: CALL 59870 0 3
// exit ;
78032: POP
78033: POP
78034: GO 78040
// end ; end ;
78036: GO 77451
78038: POP
78039: POP
// end ;
78040: LD_VAR 0 1
78044: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78045: LD_INT 0
78047: PPUSH
78048: PPUSH
78049: PPUSH
78050: PPUSH
78051: PPUSH
78052: PPUSH
78053: PPUSH
78054: PPUSH
78055: PPUSH
78056: PPUSH
78057: PPUSH
// if not mc_bases then
78058: LD_EXP 86
78062: NOT
78063: IFFALSE 78067
// exit ;
78065: GO 79154
// for i = 1 to mc_bases do
78067: LD_ADDR_VAR 0 2
78071: PUSH
78072: DOUBLE
78073: LD_INT 1
78075: DEC
78076: ST_TO_ADDR
78077: LD_EXP 86
78081: PUSH
78082: FOR_TO
78083: IFFALSE 79152
// begin tmp := mc_lab [ i ] ;
78085: LD_ADDR_VAR 0 6
78089: PUSH
78090: LD_EXP 119
78094: PUSH
78095: LD_VAR 0 2
78099: ARRAY
78100: ST_TO_ADDR
// if not tmp then
78101: LD_VAR 0 6
78105: NOT
78106: IFFALSE 78110
// continue ;
78108: GO 78082
// idle_lab := 0 ;
78110: LD_ADDR_VAR 0 11
78114: PUSH
78115: LD_INT 0
78117: ST_TO_ADDR
// for j in tmp do
78118: LD_ADDR_VAR 0 3
78122: PUSH
78123: LD_VAR 0 6
78127: PUSH
78128: FOR_IN
78129: IFFALSE 79148
// begin researching := false ;
78131: LD_ADDR_VAR 0 10
78135: PUSH
78136: LD_INT 0
78138: ST_TO_ADDR
// side := GetSide ( j ) ;
78139: LD_ADDR_VAR 0 4
78143: PUSH
78144: LD_VAR 0 3
78148: PPUSH
78149: CALL_OW 255
78153: ST_TO_ADDR
// if not mc_tech [ side ] then
78154: LD_EXP 113
78158: PUSH
78159: LD_VAR 0 4
78163: ARRAY
78164: NOT
78165: IFFALSE 78169
// continue ;
78167: GO 78128
// if BuildingStatus ( j ) = bs_idle then
78169: LD_VAR 0 3
78173: PPUSH
78174: CALL_OW 461
78178: PUSH
78179: LD_INT 2
78181: EQUAL
78182: IFFALSE 78370
// begin if idle_lab and UnitsInside ( j ) < 6 then
78184: LD_VAR 0 11
78188: PUSH
78189: LD_VAR 0 3
78193: PPUSH
78194: CALL_OW 313
78198: PUSH
78199: LD_INT 6
78201: LESS
78202: AND
78203: IFFALSE 78274
// begin tmp2 := UnitsInside ( idle_lab ) ;
78205: LD_ADDR_VAR 0 9
78209: PUSH
78210: LD_VAR 0 11
78214: PPUSH
78215: CALL_OW 313
78219: ST_TO_ADDR
// if tmp2 then
78220: LD_VAR 0 9
78224: IFFALSE 78266
// for x in tmp2 do
78226: LD_ADDR_VAR 0 7
78230: PUSH
78231: LD_VAR 0 9
78235: PUSH
78236: FOR_IN
78237: IFFALSE 78264
// begin ComExitBuilding ( x ) ;
78239: LD_VAR 0 7
78243: PPUSH
78244: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78248: LD_VAR 0 7
78252: PPUSH
78253: LD_VAR 0 3
78257: PPUSH
78258: CALL_OW 180
// end ;
78262: GO 78236
78264: POP
78265: POP
// idle_lab := 0 ;
78266: LD_ADDR_VAR 0 11
78270: PUSH
78271: LD_INT 0
78273: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78274: LD_ADDR_VAR 0 5
78278: PUSH
78279: LD_EXP 113
78283: PUSH
78284: LD_VAR 0 4
78288: ARRAY
78289: PUSH
78290: FOR_IN
78291: IFFALSE 78351
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78293: LD_VAR 0 3
78297: PPUSH
78298: LD_VAR 0 5
78302: PPUSH
78303: CALL_OW 430
78307: PUSH
78308: LD_VAR 0 4
78312: PPUSH
78313: LD_VAR 0 5
78317: PPUSH
78318: CALL 18383 0 2
78322: AND
78323: IFFALSE 78349
// begin researching := true ;
78325: LD_ADDR_VAR 0 10
78329: PUSH
78330: LD_INT 1
78332: ST_TO_ADDR
// ComResearch ( j , t ) ;
78333: LD_VAR 0 3
78337: PPUSH
78338: LD_VAR 0 5
78342: PPUSH
78343: CALL_OW 124
// break ;
78347: GO 78351
// end ;
78349: GO 78290
78351: POP
78352: POP
// if not researching then
78353: LD_VAR 0 10
78357: NOT
78358: IFFALSE 78370
// idle_lab := j ;
78360: LD_ADDR_VAR 0 11
78364: PUSH
78365: LD_VAR 0 3
78369: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78370: LD_VAR 0 3
78374: PPUSH
78375: CALL_OW 461
78379: PUSH
78380: LD_INT 10
78382: EQUAL
78383: IFFALSE 78971
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78385: LD_EXP 115
78389: PUSH
78390: LD_VAR 0 2
78394: ARRAY
78395: NOT
78396: PUSH
78397: LD_EXP 116
78401: PUSH
78402: LD_VAR 0 2
78406: ARRAY
78407: NOT
78408: AND
78409: PUSH
78410: LD_EXP 113
78414: PUSH
78415: LD_VAR 0 4
78419: ARRAY
78420: PUSH
78421: LD_INT 1
78423: GREATER
78424: AND
78425: IFFALSE 78556
// begin ComCancel ( j ) ;
78427: LD_VAR 0 3
78431: PPUSH
78432: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78436: LD_ADDR_EXP 113
78440: PUSH
78441: LD_EXP 113
78445: PPUSH
78446: LD_VAR 0 4
78450: PPUSH
78451: LD_EXP 113
78455: PUSH
78456: LD_VAR 0 4
78460: ARRAY
78461: PPUSH
78462: LD_EXP 113
78466: PUSH
78467: LD_VAR 0 4
78471: ARRAY
78472: PUSH
78473: LD_INT 1
78475: MINUS
78476: PPUSH
78477: LD_EXP 113
78481: PUSH
78482: LD_VAR 0 4
78486: ARRAY
78487: PPUSH
78488: LD_INT 0
78490: PPUSH
78491: CALL 21895 0 4
78495: PPUSH
78496: CALL_OW 1
78500: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78501: LD_ADDR_EXP 113
78505: PUSH
78506: LD_EXP 113
78510: PPUSH
78511: LD_VAR 0 4
78515: PPUSH
78516: LD_EXP 113
78520: PUSH
78521: LD_VAR 0 4
78525: ARRAY
78526: PPUSH
78527: LD_EXP 113
78531: PUSH
78532: LD_VAR 0 4
78536: ARRAY
78537: PPUSH
78538: LD_INT 1
78540: PPUSH
78541: LD_INT 0
78543: PPUSH
78544: CALL 21895 0 4
78548: PPUSH
78549: CALL_OW 1
78553: ST_TO_ADDR
// continue ;
78554: GO 78128
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78556: LD_EXP 115
78560: PUSH
78561: LD_VAR 0 2
78565: ARRAY
78566: PUSH
78567: LD_EXP 116
78571: PUSH
78572: LD_VAR 0 2
78576: ARRAY
78577: NOT
78578: AND
78579: IFFALSE 78706
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78581: LD_ADDR_EXP 116
78585: PUSH
78586: LD_EXP 116
78590: PPUSH
78591: LD_VAR 0 2
78595: PUSH
78596: LD_EXP 116
78600: PUSH
78601: LD_VAR 0 2
78605: ARRAY
78606: PUSH
78607: LD_INT 1
78609: PLUS
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PPUSH
78615: LD_EXP 115
78619: PUSH
78620: LD_VAR 0 2
78624: ARRAY
78625: PUSH
78626: LD_INT 1
78628: ARRAY
78629: PPUSH
78630: CALL 22477 0 3
78634: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78635: LD_EXP 115
78639: PUSH
78640: LD_VAR 0 2
78644: ARRAY
78645: PUSH
78646: LD_INT 1
78648: ARRAY
78649: PPUSH
78650: LD_INT 112
78652: PPUSH
78653: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78657: LD_ADDR_VAR 0 9
78661: PUSH
78662: LD_EXP 115
78666: PUSH
78667: LD_VAR 0 2
78671: ARRAY
78672: PPUSH
78673: LD_INT 1
78675: PPUSH
78676: CALL_OW 3
78680: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78681: LD_ADDR_EXP 115
78685: PUSH
78686: LD_EXP 115
78690: PPUSH
78691: LD_VAR 0 2
78695: PPUSH
78696: LD_VAR 0 9
78700: PPUSH
78701: CALL_OW 1
78705: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78706: LD_EXP 115
78710: PUSH
78711: LD_VAR 0 2
78715: ARRAY
78716: PUSH
78717: LD_EXP 116
78721: PUSH
78722: LD_VAR 0 2
78726: ARRAY
78727: AND
78728: PUSH
78729: LD_EXP 116
78733: PUSH
78734: LD_VAR 0 2
78738: ARRAY
78739: PUSH
78740: LD_INT 1
78742: ARRAY
78743: PPUSH
78744: CALL_OW 310
78748: NOT
78749: AND
78750: PUSH
78751: LD_VAR 0 3
78755: PPUSH
78756: CALL_OW 313
78760: PUSH
78761: LD_INT 6
78763: EQUAL
78764: AND
78765: IFFALSE 78821
// begin tmp2 := UnitsInside ( j ) ;
78767: LD_ADDR_VAR 0 9
78771: PUSH
78772: LD_VAR 0 3
78776: PPUSH
78777: CALL_OW 313
78781: ST_TO_ADDR
// if tmp2 = 6 then
78782: LD_VAR 0 9
78786: PUSH
78787: LD_INT 6
78789: EQUAL
78790: IFFALSE 78821
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78792: LD_VAR 0 9
78796: PUSH
78797: LD_INT 1
78799: ARRAY
78800: PPUSH
78801: LD_INT 112
78803: PPUSH
78804: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78808: LD_VAR 0 9
78812: PUSH
78813: LD_INT 1
78815: ARRAY
78816: PPUSH
78817: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78821: LD_EXP 116
78825: PUSH
78826: LD_VAR 0 2
78830: ARRAY
78831: PUSH
78832: LD_EXP 116
78836: PUSH
78837: LD_VAR 0 2
78841: ARRAY
78842: PUSH
78843: LD_INT 1
78845: ARRAY
78846: PPUSH
78847: CALL_OW 314
78851: NOT
78852: AND
78853: PUSH
78854: LD_EXP 116
78858: PUSH
78859: LD_VAR 0 2
78863: ARRAY
78864: PUSH
78865: LD_INT 1
78867: ARRAY
78868: PPUSH
78869: CALL_OW 310
78873: NOT
78874: AND
78875: IFFALSE 78901
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78877: LD_EXP 116
78881: PUSH
78882: LD_VAR 0 2
78886: ARRAY
78887: PUSH
78888: LD_INT 1
78890: ARRAY
78891: PPUSH
78892: LD_VAR 0 3
78896: PPUSH
78897: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78901: LD_EXP 116
78905: PUSH
78906: LD_VAR 0 2
78910: ARRAY
78911: PUSH
78912: LD_INT 1
78914: ARRAY
78915: PPUSH
78916: CALL_OW 310
78920: PUSH
78921: LD_EXP 116
78925: PUSH
78926: LD_VAR 0 2
78930: ARRAY
78931: PUSH
78932: LD_INT 1
78934: ARRAY
78935: PPUSH
78936: CALL_OW 310
78940: PPUSH
78941: CALL_OW 461
78945: PUSH
78946: LD_INT 3
78948: NONEQUAL
78949: AND
78950: IFFALSE 78971
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78952: LD_EXP 116
78956: PUSH
78957: LD_VAR 0 2
78961: ARRAY
78962: PUSH
78963: LD_INT 1
78965: ARRAY
78966: PPUSH
78967: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78971: LD_VAR 0 3
78975: PPUSH
78976: CALL_OW 461
78980: PUSH
78981: LD_INT 6
78983: EQUAL
78984: PUSH
78985: LD_VAR 0 6
78989: PUSH
78990: LD_INT 1
78992: GREATER
78993: AND
78994: IFFALSE 79146
// begin sci := [ ] ;
78996: LD_ADDR_VAR 0 8
79000: PUSH
79001: EMPTY
79002: ST_TO_ADDR
// for x in ( tmp diff j ) do
79003: LD_ADDR_VAR 0 7
79007: PUSH
79008: LD_VAR 0 6
79012: PUSH
79013: LD_VAR 0 3
79017: DIFF
79018: PUSH
79019: FOR_IN
79020: IFFALSE 79072
// begin if sci = 6 then
79022: LD_VAR 0 8
79026: PUSH
79027: LD_INT 6
79029: EQUAL
79030: IFFALSE 79034
// break ;
79032: GO 79072
// if BuildingStatus ( x ) = bs_idle then
79034: LD_VAR 0 7
79038: PPUSH
79039: CALL_OW 461
79043: PUSH
79044: LD_INT 2
79046: EQUAL
79047: IFFALSE 79070
// sci := sci ^ UnitsInside ( x ) ;
79049: LD_ADDR_VAR 0 8
79053: PUSH
79054: LD_VAR 0 8
79058: PUSH
79059: LD_VAR 0 7
79063: PPUSH
79064: CALL_OW 313
79068: ADD
79069: ST_TO_ADDR
// end ;
79070: GO 79019
79072: POP
79073: POP
// if not sci then
79074: LD_VAR 0 8
79078: NOT
79079: IFFALSE 79083
// continue ;
79081: GO 78128
// for x in sci do
79083: LD_ADDR_VAR 0 7
79087: PUSH
79088: LD_VAR 0 8
79092: PUSH
79093: FOR_IN
79094: IFFALSE 79144
// if IsInUnit ( x ) and not HasTask ( x ) then
79096: LD_VAR 0 7
79100: PPUSH
79101: CALL_OW 310
79105: PUSH
79106: LD_VAR 0 7
79110: PPUSH
79111: CALL_OW 314
79115: NOT
79116: AND
79117: IFFALSE 79142
// begin ComExitBuilding ( x ) ;
79119: LD_VAR 0 7
79123: PPUSH
79124: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79128: LD_VAR 0 7
79132: PPUSH
79133: LD_VAR 0 3
79137: PPUSH
79138: CALL_OW 180
// end ;
79142: GO 79093
79144: POP
79145: POP
// end ; end ;
79146: GO 78128
79148: POP
79149: POP
// end ;
79150: GO 78082
79152: POP
79153: POP
// end ;
79154: LD_VAR 0 1
79158: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79159: LD_INT 0
79161: PPUSH
79162: PPUSH
// if not mc_bases then
79163: LD_EXP 86
79167: NOT
79168: IFFALSE 79172
// exit ;
79170: GO 79253
// for i = 1 to mc_bases do
79172: LD_ADDR_VAR 0 2
79176: PUSH
79177: DOUBLE
79178: LD_INT 1
79180: DEC
79181: ST_TO_ADDR
79182: LD_EXP 86
79186: PUSH
79187: FOR_TO
79188: IFFALSE 79251
// if mc_mines [ i ] and mc_miners [ i ] then
79190: LD_EXP 99
79194: PUSH
79195: LD_VAR 0 2
79199: ARRAY
79200: PUSH
79201: LD_EXP 100
79205: PUSH
79206: LD_VAR 0 2
79210: ARRAY
79211: AND
79212: IFFALSE 79249
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79214: LD_EXP 100
79218: PUSH
79219: LD_VAR 0 2
79223: ARRAY
79224: PUSH
79225: LD_INT 1
79227: ARRAY
79228: PPUSH
79229: CALL_OW 255
79233: PPUSH
79234: LD_EXP 99
79238: PUSH
79239: LD_VAR 0 2
79243: ARRAY
79244: PPUSH
79245: CALL 19466 0 2
79249: GO 79187
79251: POP
79252: POP
// end ;
79253: LD_VAR 0 1
79257: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79258: LD_INT 0
79260: PPUSH
79261: PPUSH
79262: PPUSH
79263: PPUSH
79264: PPUSH
79265: PPUSH
79266: PPUSH
79267: PPUSH
// if not mc_bases or not mc_parking then
79268: LD_EXP 86
79272: NOT
79273: PUSH
79274: LD_EXP 110
79278: NOT
79279: OR
79280: IFFALSE 79284
// exit ;
79282: GO 79983
// for i = 1 to mc_bases do
79284: LD_ADDR_VAR 0 2
79288: PUSH
79289: DOUBLE
79290: LD_INT 1
79292: DEC
79293: ST_TO_ADDR
79294: LD_EXP 86
79298: PUSH
79299: FOR_TO
79300: IFFALSE 79981
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79302: LD_EXP 86
79306: PUSH
79307: LD_VAR 0 2
79311: ARRAY
79312: NOT
79313: PUSH
79314: LD_EXP 110
79318: PUSH
79319: LD_VAR 0 2
79323: ARRAY
79324: NOT
79325: OR
79326: IFFALSE 79330
// continue ;
79328: GO 79299
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79330: LD_ADDR_VAR 0 5
79334: PUSH
79335: LD_EXP 86
79339: PUSH
79340: LD_VAR 0 2
79344: ARRAY
79345: PUSH
79346: LD_INT 1
79348: ARRAY
79349: PPUSH
79350: CALL_OW 255
79354: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79355: LD_ADDR_VAR 0 6
79359: PUSH
79360: LD_EXP 86
79364: PUSH
79365: LD_VAR 0 2
79369: ARRAY
79370: PPUSH
79371: LD_INT 30
79373: PUSH
79374: LD_INT 3
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PPUSH
79381: CALL_OW 72
79385: ST_TO_ADDR
// if not fac then
79386: LD_VAR 0 6
79390: NOT
79391: IFFALSE 79442
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79393: LD_ADDR_VAR 0 6
79397: PUSH
79398: LD_EXP 86
79402: PUSH
79403: LD_VAR 0 2
79407: ARRAY
79408: PPUSH
79409: LD_INT 2
79411: PUSH
79412: LD_INT 30
79414: PUSH
79415: LD_INT 0
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 30
79424: PUSH
79425: LD_INT 1
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: LIST
79436: PPUSH
79437: CALL_OW 72
79441: ST_TO_ADDR
// if not fac then
79442: LD_VAR 0 6
79446: NOT
79447: IFFALSE 79451
// continue ;
79449: GO 79299
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79451: LD_ADDR_VAR 0 7
79455: PUSH
79456: LD_EXP 110
79460: PUSH
79461: LD_VAR 0 2
79465: ARRAY
79466: PPUSH
79467: LD_INT 22
79469: PUSH
79470: LD_VAR 0 5
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 21
79481: PUSH
79482: LD_INT 2
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 3
79491: PUSH
79492: LD_INT 24
79494: PUSH
79495: LD_INT 1000
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: LIST
79510: PPUSH
79511: CALL_OW 70
79515: ST_TO_ADDR
// for j in fac do
79516: LD_ADDR_VAR 0 3
79520: PUSH
79521: LD_VAR 0 6
79525: PUSH
79526: FOR_IN
79527: IFFALSE 79608
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79529: LD_ADDR_VAR 0 7
79533: PUSH
79534: LD_VAR 0 7
79538: PUSH
79539: LD_INT 22
79541: PUSH
79542: LD_VAR 0 5
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 91
79553: PUSH
79554: LD_VAR 0 3
79558: PUSH
79559: LD_INT 15
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 21
79569: PUSH
79570: LD_INT 2
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 3
79579: PUSH
79580: LD_INT 24
79582: PUSH
79583: LD_INT 1000
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: PPUSH
79600: CALL_OW 69
79604: UNION
79605: ST_TO_ADDR
79606: GO 79526
79608: POP
79609: POP
// if not vehs then
79610: LD_VAR 0 7
79614: NOT
79615: IFFALSE 79641
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79617: LD_ADDR_EXP 98
79621: PUSH
79622: LD_EXP 98
79626: PPUSH
79627: LD_VAR 0 2
79631: PPUSH
79632: EMPTY
79633: PPUSH
79634: CALL_OW 1
79638: ST_TO_ADDR
// continue ;
79639: GO 79299
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79641: LD_ADDR_VAR 0 8
79645: PUSH
79646: LD_EXP 86
79650: PUSH
79651: LD_VAR 0 2
79655: ARRAY
79656: PPUSH
79657: LD_INT 30
79659: PUSH
79660: LD_INT 3
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PPUSH
79667: CALL_OW 72
79671: ST_TO_ADDR
// if tmp then
79672: LD_VAR 0 8
79676: IFFALSE 79779
// begin for j in tmp do
79678: LD_ADDR_VAR 0 3
79682: PUSH
79683: LD_VAR 0 8
79687: PUSH
79688: FOR_IN
79689: IFFALSE 79777
// for k in UnitsInside ( j ) do
79691: LD_ADDR_VAR 0 4
79695: PUSH
79696: LD_VAR 0 3
79700: PPUSH
79701: CALL_OW 313
79705: PUSH
79706: FOR_IN
79707: IFFALSE 79773
// if k then
79709: LD_VAR 0 4
79713: IFFALSE 79771
// if not k in mc_repair_vehicle [ i ] then
79715: LD_VAR 0 4
79719: PUSH
79720: LD_EXP 98
79724: PUSH
79725: LD_VAR 0 2
79729: ARRAY
79730: IN
79731: NOT
79732: IFFALSE 79771
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79734: LD_ADDR_EXP 98
79738: PUSH
79739: LD_EXP 98
79743: PPUSH
79744: LD_VAR 0 2
79748: PPUSH
79749: LD_EXP 98
79753: PUSH
79754: LD_VAR 0 2
79758: ARRAY
79759: PUSH
79760: LD_VAR 0 4
79764: UNION
79765: PPUSH
79766: CALL_OW 1
79770: ST_TO_ADDR
79771: GO 79706
79773: POP
79774: POP
79775: GO 79688
79777: POP
79778: POP
// end ; if not mc_repair_vehicle [ i ] then
79779: LD_EXP 98
79783: PUSH
79784: LD_VAR 0 2
79788: ARRAY
79789: NOT
79790: IFFALSE 79794
// continue ;
79792: GO 79299
// for j in mc_repair_vehicle [ i ] do
79794: LD_ADDR_VAR 0 3
79798: PUSH
79799: LD_EXP 98
79803: PUSH
79804: LD_VAR 0 2
79808: ARRAY
79809: PUSH
79810: FOR_IN
79811: IFFALSE 79977
// begin if GetClass ( j ) <> 3 then
79813: LD_VAR 0 3
79817: PPUSH
79818: CALL_OW 257
79822: PUSH
79823: LD_INT 3
79825: NONEQUAL
79826: IFFALSE 79867
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79828: LD_ADDR_EXP 98
79832: PUSH
79833: LD_EXP 98
79837: PPUSH
79838: LD_VAR 0 2
79842: PPUSH
79843: LD_EXP 98
79847: PUSH
79848: LD_VAR 0 2
79852: ARRAY
79853: PUSH
79854: LD_VAR 0 3
79858: DIFF
79859: PPUSH
79860: CALL_OW 1
79864: ST_TO_ADDR
// continue ;
79865: GO 79810
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79867: LD_VAR 0 3
79871: PPUSH
79872: CALL_OW 311
79876: NOT
79877: PUSH
79878: LD_VAR 0 3
79882: PUSH
79883: LD_EXP 89
79887: PUSH
79888: LD_VAR 0 2
79892: ARRAY
79893: PUSH
79894: LD_INT 1
79896: ARRAY
79897: IN
79898: NOT
79899: AND
79900: PUSH
79901: LD_VAR 0 3
79905: PUSH
79906: LD_EXP 89
79910: PUSH
79911: LD_VAR 0 2
79915: ARRAY
79916: PUSH
79917: LD_INT 2
79919: ARRAY
79920: IN
79921: NOT
79922: AND
79923: IFFALSE 79975
// begin if IsInUnit ( j ) then
79925: LD_VAR 0 3
79929: PPUSH
79930: CALL_OW 310
79934: IFFALSE 79945
// ComExitBuilding ( j ) ;
79936: LD_VAR 0 3
79940: PPUSH
79941: CALL_OW 122
// if not HasTask ( j ) then
79945: LD_VAR 0 3
79949: PPUSH
79950: CALL_OW 314
79954: NOT
79955: IFFALSE 79975
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
79957: LD_VAR 0 3
79961: PPUSH
79962: LD_VAR 0 7
79966: PUSH
79967: LD_INT 1
79969: ARRAY
79970: PPUSH
79971: CALL_OW 189
// end ; end ;
79975: GO 79810
79977: POP
79978: POP
// end ;
79979: GO 79299
79981: POP
79982: POP
// end ;
79983: LD_VAR 0 1
79987: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79988: LD_INT 0
79990: PPUSH
79991: PPUSH
79992: PPUSH
79993: PPUSH
79994: PPUSH
79995: PPUSH
79996: PPUSH
79997: PPUSH
79998: PPUSH
79999: PPUSH
80000: PPUSH
// if not mc_bases then
80001: LD_EXP 86
80005: NOT
80006: IFFALSE 80010
// exit ;
80008: GO 80812
// for i = 1 to mc_bases do
80010: LD_ADDR_VAR 0 2
80014: PUSH
80015: DOUBLE
80016: LD_INT 1
80018: DEC
80019: ST_TO_ADDR
80020: LD_EXP 86
80024: PUSH
80025: FOR_TO
80026: IFFALSE 80810
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80028: LD_EXP 114
80032: PUSH
80033: LD_VAR 0 2
80037: ARRAY
80038: NOT
80039: PUSH
80040: LD_EXP 89
80044: PUSH
80045: LD_VAR 0 2
80049: ARRAY
80050: PUSH
80051: LD_INT 1
80053: ARRAY
80054: OR
80055: PUSH
80056: LD_EXP 89
80060: PUSH
80061: LD_VAR 0 2
80065: ARRAY
80066: PUSH
80067: LD_INT 2
80069: ARRAY
80070: OR
80071: PUSH
80072: LD_EXP 112
80076: PUSH
80077: LD_VAR 0 2
80081: ARRAY
80082: PPUSH
80083: LD_INT 1
80085: PPUSH
80086: CALL_OW 325
80090: NOT
80091: OR
80092: PUSH
80093: LD_EXP 109
80097: PUSH
80098: LD_VAR 0 2
80102: ARRAY
80103: OR
80104: IFFALSE 80108
// continue ;
80106: GO 80025
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80108: LD_ADDR_VAR 0 8
80112: PUSH
80113: LD_EXP 86
80117: PUSH
80118: LD_VAR 0 2
80122: ARRAY
80123: PPUSH
80124: LD_INT 25
80126: PUSH
80127: LD_INT 4
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 50
80136: PUSH
80137: EMPTY
80138: LIST
80139: PUSH
80140: LD_INT 3
80142: PUSH
80143: LD_INT 60
80145: PUSH
80146: EMPTY
80147: LIST
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: LIST
80157: PPUSH
80158: CALL_OW 72
80162: PUSH
80163: LD_EXP 90
80167: PUSH
80168: LD_VAR 0 2
80172: ARRAY
80173: DIFF
80174: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80175: LD_ADDR_VAR 0 9
80179: PUSH
80180: LD_EXP 86
80184: PUSH
80185: LD_VAR 0 2
80189: ARRAY
80190: PPUSH
80191: LD_INT 2
80193: PUSH
80194: LD_INT 30
80196: PUSH
80197: LD_INT 0
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 30
80206: PUSH
80207: LD_INT 1
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: LIST
80218: PPUSH
80219: CALL_OW 72
80223: ST_TO_ADDR
// if not tmp or not dep then
80224: LD_VAR 0 8
80228: NOT
80229: PUSH
80230: LD_VAR 0 9
80234: NOT
80235: OR
80236: IFFALSE 80240
// continue ;
80238: GO 80025
// side := GetSide ( tmp [ 1 ] ) ;
80240: LD_ADDR_VAR 0 11
80244: PUSH
80245: LD_VAR 0 8
80249: PUSH
80250: LD_INT 1
80252: ARRAY
80253: PPUSH
80254: CALL_OW 255
80258: ST_TO_ADDR
// dep := dep [ 1 ] ;
80259: LD_ADDR_VAR 0 9
80263: PUSH
80264: LD_VAR 0 9
80268: PUSH
80269: LD_INT 1
80271: ARRAY
80272: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80273: LD_ADDR_VAR 0 7
80277: PUSH
80278: LD_EXP 114
80282: PUSH
80283: LD_VAR 0 2
80287: ARRAY
80288: PPUSH
80289: LD_INT 22
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 25
80301: PUSH
80302: LD_INT 12
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PPUSH
80313: CALL_OW 70
80317: PUSH
80318: LD_INT 22
80320: PUSH
80321: LD_INT 0
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 25
80330: PUSH
80331: LD_INT 12
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 91
80340: PUSH
80341: LD_VAR 0 9
80345: PUSH
80346: LD_INT 20
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: LIST
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: LIST
80358: PPUSH
80359: CALL_OW 69
80363: UNION
80364: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80365: LD_ADDR_VAR 0 10
80369: PUSH
80370: LD_EXP 114
80374: PUSH
80375: LD_VAR 0 2
80379: ARRAY
80380: PPUSH
80381: LD_INT 81
80383: PUSH
80384: LD_VAR 0 11
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PPUSH
80393: CALL_OW 70
80397: ST_TO_ADDR
// if not apes or danger_at_area then
80398: LD_VAR 0 7
80402: NOT
80403: PUSH
80404: LD_VAR 0 10
80408: OR
80409: IFFALSE 80459
// begin if mc_taming [ i ] then
80411: LD_EXP 117
80415: PUSH
80416: LD_VAR 0 2
80420: ARRAY
80421: IFFALSE 80457
// begin MC_Reset ( i , 121 ) ;
80423: LD_VAR 0 2
80427: PPUSH
80428: LD_INT 121
80430: PPUSH
80431: CALL 65862 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80435: LD_ADDR_EXP 117
80439: PUSH
80440: LD_EXP 117
80444: PPUSH
80445: LD_VAR 0 2
80449: PPUSH
80450: EMPTY
80451: PPUSH
80452: CALL_OW 1
80456: ST_TO_ADDR
// end ; continue ;
80457: GO 80025
// end ; for j in tmp do
80459: LD_ADDR_VAR 0 3
80463: PUSH
80464: LD_VAR 0 8
80468: PUSH
80469: FOR_IN
80470: IFFALSE 80806
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80472: LD_VAR 0 3
80476: PUSH
80477: LD_EXP 117
80481: PUSH
80482: LD_VAR 0 2
80486: ARRAY
80487: IN
80488: NOT
80489: PUSH
80490: LD_EXP 117
80494: PUSH
80495: LD_VAR 0 2
80499: ARRAY
80500: PUSH
80501: LD_INT 3
80503: LESS
80504: AND
80505: IFFALSE 80563
// begin SetTag ( j , 121 ) ;
80507: LD_VAR 0 3
80511: PPUSH
80512: LD_INT 121
80514: PPUSH
80515: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80519: LD_ADDR_EXP 117
80523: PUSH
80524: LD_EXP 117
80528: PPUSH
80529: LD_VAR 0 2
80533: PUSH
80534: LD_EXP 117
80538: PUSH
80539: LD_VAR 0 2
80543: ARRAY
80544: PUSH
80545: LD_INT 1
80547: PLUS
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PPUSH
80553: LD_VAR 0 3
80557: PPUSH
80558: CALL 22477 0 3
80562: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80563: LD_VAR 0 3
80567: PUSH
80568: LD_EXP 117
80572: PUSH
80573: LD_VAR 0 2
80577: ARRAY
80578: IN
80579: IFFALSE 80804
// begin if GetClass ( j ) <> 4 then
80581: LD_VAR 0 3
80585: PPUSH
80586: CALL_OW 257
80590: PUSH
80591: LD_INT 4
80593: NONEQUAL
80594: IFFALSE 80647
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80596: LD_ADDR_EXP 117
80600: PUSH
80601: LD_EXP 117
80605: PPUSH
80606: LD_VAR 0 2
80610: PPUSH
80611: LD_EXP 117
80615: PUSH
80616: LD_VAR 0 2
80620: ARRAY
80621: PUSH
80622: LD_VAR 0 3
80626: DIFF
80627: PPUSH
80628: CALL_OW 1
80632: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80633: LD_VAR 0 3
80637: PPUSH
80638: LD_INT 0
80640: PPUSH
80641: CALL_OW 109
// continue ;
80645: GO 80469
// end ; if IsInUnit ( j ) then
80647: LD_VAR 0 3
80651: PPUSH
80652: CALL_OW 310
80656: IFFALSE 80667
// ComExitBuilding ( j ) ;
80658: LD_VAR 0 3
80662: PPUSH
80663: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80667: LD_ADDR_VAR 0 6
80671: PUSH
80672: LD_VAR 0 7
80676: PPUSH
80677: LD_VAR 0 3
80681: PPUSH
80682: CALL_OW 74
80686: ST_TO_ADDR
// if not ape then
80687: LD_VAR 0 6
80691: NOT
80692: IFFALSE 80696
// break ;
80694: GO 80806
// x := GetX ( ape ) ;
80696: LD_ADDR_VAR 0 4
80700: PUSH
80701: LD_VAR 0 6
80705: PPUSH
80706: CALL_OW 250
80710: ST_TO_ADDR
// y := GetY ( ape ) ;
80711: LD_ADDR_VAR 0 5
80715: PUSH
80716: LD_VAR 0 6
80720: PPUSH
80721: CALL_OW 251
80725: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80726: LD_VAR 0 4
80730: PPUSH
80731: LD_VAR 0 5
80735: PPUSH
80736: CALL_OW 488
80740: NOT
80741: PUSH
80742: LD_VAR 0 11
80746: PPUSH
80747: LD_VAR 0 4
80751: PPUSH
80752: LD_VAR 0 5
80756: PPUSH
80757: LD_INT 20
80759: PPUSH
80760: CALL 23373 0 4
80764: PUSH
80765: LD_INT 4
80767: ARRAY
80768: OR
80769: IFFALSE 80773
// break ;
80771: GO 80806
// if not HasTask ( j ) then
80773: LD_VAR 0 3
80777: PPUSH
80778: CALL_OW 314
80782: NOT
80783: IFFALSE 80804
// ComTameXY ( j , x , y ) ;
80785: LD_VAR 0 3
80789: PPUSH
80790: LD_VAR 0 4
80794: PPUSH
80795: LD_VAR 0 5
80799: PPUSH
80800: CALL_OW 131
// end ; end ;
80804: GO 80469
80806: POP
80807: POP
// end ;
80808: GO 80025
80810: POP
80811: POP
// end ;
80812: LD_VAR 0 1
80816: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80817: LD_INT 0
80819: PPUSH
80820: PPUSH
80821: PPUSH
80822: PPUSH
80823: PPUSH
80824: PPUSH
80825: PPUSH
80826: PPUSH
// if not mc_bases then
80827: LD_EXP 86
80831: NOT
80832: IFFALSE 80836
// exit ;
80834: GO 81462
// for i = 1 to mc_bases do
80836: LD_ADDR_VAR 0 2
80840: PUSH
80841: DOUBLE
80842: LD_INT 1
80844: DEC
80845: ST_TO_ADDR
80846: LD_EXP 86
80850: PUSH
80851: FOR_TO
80852: IFFALSE 81460
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80854: LD_EXP 115
80858: PUSH
80859: LD_VAR 0 2
80863: ARRAY
80864: NOT
80865: PUSH
80866: LD_EXP 115
80870: PUSH
80871: LD_VAR 0 2
80875: ARRAY
80876: PPUSH
80877: LD_INT 25
80879: PUSH
80880: LD_INT 12
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PPUSH
80887: CALL_OW 72
80891: NOT
80892: OR
80893: IFFALSE 80897
// continue ;
80895: GO 80851
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80897: LD_ADDR_VAR 0 5
80901: PUSH
80902: LD_EXP 115
80906: PUSH
80907: LD_VAR 0 2
80911: ARRAY
80912: PUSH
80913: LD_INT 1
80915: ARRAY
80916: PPUSH
80917: CALL_OW 255
80921: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80922: LD_VAR 0 5
80926: PPUSH
80927: LD_INT 2
80929: PPUSH
80930: CALL_OW 325
80934: IFFALSE 81187
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80936: LD_ADDR_VAR 0 4
80940: PUSH
80941: LD_EXP 115
80945: PUSH
80946: LD_VAR 0 2
80950: ARRAY
80951: PPUSH
80952: LD_INT 25
80954: PUSH
80955: LD_INT 16
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PPUSH
80962: CALL_OW 72
80966: ST_TO_ADDR
// if tmp < 6 then
80967: LD_VAR 0 4
80971: PUSH
80972: LD_INT 6
80974: LESS
80975: IFFALSE 81187
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80977: LD_ADDR_VAR 0 6
80981: PUSH
80982: LD_EXP 86
80986: PUSH
80987: LD_VAR 0 2
80991: ARRAY
80992: PPUSH
80993: LD_INT 2
80995: PUSH
80996: LD_INT 30
80998: PUSH
80999: LD_INT 0
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 30
81008: PUSH
81009: LD_INT 1
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: LIST
81020: PPUSH
81021: CALL_OW 72
81025: ST_TO_ADDR
// if depot then
81026: LD_VAR 0 6
81030: IFFALSE 81187
// begin selected := 0 ;
81032: LD_ADDR_VAR 0 7
81036: PUSH
81037: LD_INT 0
81039: ST_TO_ADDR
// for j in depot do
81040: LD_ADDR_VAR 0 3
81044: PUSH
81045: LD_VAR 0 6
81049: PUSH
81050: FOR_IN
81051: IFFALSE 81082
// begin if UnitsInside ( j ) < 6 then
81053: LD_VAR 0 3
81057: PPUSH
81058: CALL_OW 313
81062: PUSH
81063: LD_INT 6
81065: LESS
81066: IFFALSE 81080
// begin selected := j ;
81068: LD_ADDR_VAR 0 7
81072: PUSH
81073: LD_VAR 0 3
81077: ST_TO_ADDR
// break ;
81078: GO 81082
// end ; end ;
81080: GO 81050
81082: POP
81083: POP
// if selected then
81084: LD_VAR 0 7
81088: IFFALSE 81187
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81090: LD_ADDR_VAR 0 3
81094: PUSH
81095: LD_EXP 115
81099: PUSH
81100: LD_VAR 0 2
81104: ARRAY
81105: PPUSH
81106: LD_INT 25
81108: PUSH
81109: LD_INT 12
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PPUSH
81116: CALL_OW 72
81120: PUSH
81121: FOR_IN
81122: IFFALSE 81185
// if not HasTask ( j ) then
81124: LD_VAR 0 3
81128: PPUSH
81129: CALL_OW 314
81133: NOT
81134: IFFALSE 81183
// begin if not IsInUnit ( j ) then
81136: LD_VAR 0 3
81140: PPUSH
81141: CALL_OW 310
81145: NOT
81146: IFFALSE 81162
// ComEnterUnit ( j , selected ) ;
81148: LD_VAR 0 3
81152: PPUSH
81153: LD_VAR 0 7
81157: PPUSH
81158: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81162: LD_VAR 0 3
81166: PPUSH
81167: LD_INT 16
81169: PPUSH
81170: CALL_OW 183
// AddComExitBuilding ( j ) ;
81174: LD_VAR 0 3
81178: PPUSH
81179: CALL_OW 182
// end ;
81183: GO 81121
81185: POP
81186: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81187: LD_VAR 0 5
81191: PPUSH
81192: LD_INT 11
81194: PPUSH
81195: CALL_OW 325
81199: IFFALSE 81458
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81201: LD_ADDR_VAR 0 4
81205: PUSH
81206: LD_EXP 115
81210: PUSH
81211: LD_VAR 0 2
81215: ARRAY
81216: PPUSH
81217: LD_INT 25
81219: PUSH
81220: LD_INT 16
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PPUSH
81227: CALL_OW 72
81231: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81232: LD_VAR 0 4
81236: PUSH
81237: LD_INT 6
81239: GREATEREQUAL
81240: PUSH
81241: LD_VAR 0 5
81245: PPUSH
81246: LD_INT 2
81248: PPUSH
81249: CALL_OW 325
81253: NOT
81254: OR
81255: IFFALSE 81458
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81257: LD_ADDR_VAR 0 8
81261: PUSH
81262: LD_EXP 86
81266: PUSH
81267: LD_VAR 0 2
81271: ARRAY
81272: PPUSH
81273: LD_INT 2
81275: PUSH
81276: LD_INT 30
81278: PUSH
81279: LD_INT 4
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 30
81288: PUSH
81289: LD_INT 5
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: LIST
81300: PPUSH
81301: CALL_OW 72
81305: ST_TO_ADDR
// if barracks then
81306: LD_VAR 0 8
81310: IFFALSE 81458
// begin selected := 0 ;
81312: LD_ADDR_VAR 0 7
81316: PUSH
81317: LD_INT 0
81319: ST_TO_ADDR
// for j in barracks do
81320: LD_ADDR_VAR 0 3
81324: PUSH
81325: LD_VAR 0 8
81329: PUSH
81330: FOR_IN
81331: IFFALSE 81362
// begin if UnitsInside ( j ) < 6 then
81333: LD_VAR 0 3
81337: PPUSH
81338: CALL_OW 313
81342: PUSH
81343: LD_INT 6
81345: LESS
81346: IFFALSE 81360
// begin selected := j ;
81348: LD_ADDR_VAR 0 7
81352: PUSH
81353: LD_VAR 0 3
81357: ST_TO_ADDR
// break ;
81358: GO 81362
// end ; end ;
81360: GO 81330
81362: POP
81363: POP
// if selected then
81364: LD_VAR 0 7
81368: IFFALSE 81458
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81370: LD_ADDR_VAR 0 3
81374: PUSH
81375: LD_EXP 115
81379: PUSH
81380: LD_VAR 0 2
81384: ARRAY
81385: PPUSH
81386: LD_INT 25
81388: PUSH
81389: LD_INT 12
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PPUSH
81396: CALL_OW 72
81400: PUSH
81401: FOR_IN
81402: IFFALSE 81456
// if not IsInUnit ( j ) and not HasTask ( j ) then
81404: LD_VAR 0 3
81408: PPUSH
81409: CALL_OW 310
81413: NOT
81414: PUSH
81415: LD_VAR 0 3
81419: PPUSH
81420: CALL_OW 314
81424: NOT
81425: AND
81426: IFFALSE 81454
// begin ComEnterUnit ( j , selected ) ;
81428: LD_VAR 0 3
81432: PPUSH
81433: LD_VAR 0 7
81437: PPUSH
81438: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81442: LD_VAR 0 3
81446: PPUSH
81447: LD_INT 15
81449: PPUSH
81450: CALL_OW 183
// end ;
81454: GO 81401
81456: POP
81457: POP
// end ; end ; end ; end ; end ;
81458: GO 80851
81460: POP
81461: POP
// end ;
81462: LD_VAR 0 1
81466: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81467: LD_INT 0
81469: PPUSH
81470: PPUSH
81471: PPUSH
81472: PPUSH
// if not mc_bases then
81473: LD_EXP 86
81477: NOT
81478: IFFALSE 81482
// exit ;
81480: GO 81660
// for i = 1 to mc_bases do
81482: LD_ADDR_VAR 0 2
81486: PUSH
81487: DOUBLE
81488: LD_INT 1
81490: DEC
81491: ST_TO_ADDR
81492: LD_EXP 86
81496: PUSH
81497: FOR_TO
81498: IFFALSE 81658
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81500: LD_ADDR_VAR 0 4
81504: PUSH
81505: LD_EXP 86
81509: PUSH
81510: LD_VAR 0 2
81514: ARRAY
81515: PPUSH
81516: LD_INT 25
81518: PUSH
81519: LD_INT 9
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PPUSH
81526: CALL_OW 72
81530: ST_TO_ADDR
// if not tmp then
81531: LD_VAR 0 4
81535: NOT
81536: IFFALSE 81540
// continue ;
81538: GO 81497
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81540: LD_EXP 112
81544: PUSH
81545: LD_VAR 0 2
81549: ARRAY
81550: PPUSH
81551: LD_INT 29
81553: PPUSH
81554: CALL_OW 325
81558: NOT
81559: PUSH
81560: LD_EXP 112
81564: PUSH
81565: LD_VAR 0 2
81569: ARRAY
81570: PPUSH
81571: LD_INT 28
81573: PPUSH
81574: CALL_OW 325
81578: NOT
81579: AND
81580: IFFALSE 81584
// continue ;
81582: GO 81497
// for j in tmp do
81584: LD_ADDR_VAR 0 3
81588: PUSH
81589: LD_VAR 0 4
81593: PUSH
81594: FOR_IN
81595: IFFALSE 81654
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81597: LD_VAR 0 3
81601: PUSH
81602: LD_EXP 89
81606: PUSH
81607: LD_VAR 0 2
81611: ARRAY
81612: PUSH
81613: LD_INT 1
81615: ARRAY
81616: IN
81617: NOT
81618: PUSH
81619: LD_VAR 0 3
81623: PUSH
81624: LD_EXP 89
81628: PUSH
81629: LD_VAR 0 2
81633: ARRAY
81634: PUSH
81635: LD_INT 2
81637: ARRAY
81638: IN
81639: NOT
81640: AND
81641: IFFALSE 81652
// ComSpaceTimeShoot ( j ) ;
81643: LD_VAR 0 3
81647: PPUSH
81648: CALL 18474 0 1
81652: GO 81594
81654: POP
81655: POP
// end ;
81656: GO 81497
81658: POP
81659: POP
// end ;
81660: LD_VAR 0 1
81664: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81665: LD_INT 0
81667: PPUSH
81668: PPUSH
81669: PPUSH
81670: PPUSH
81671: PPUSH
81672: PPUSH
81673: PPUSH
81674: PPUSH
81675: PPUSH
// if not mc_bases then
81676: LD_EXP 86
81680: NOT
81681: IFFALSE 81685
// exit ;
81683: GO 82307
// for i = 1 to mc_bases do
81685: LD_ADDR_VAR 0 2
81689: PUSH
81690: DOUBLE
81691: LD_INT 1
81693: DEC
81694: ST_TO_ADDR
81695: LD_EXP 86
81699: PUSH
81700: FOR_TO
81701: IFFALSE 82305
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81703: LD_EXP 121
81707: PUSH
81708: LD_VAR 0 2
81712: ARRAY
81713: NOT
81714: PUSH
81715: LD_INT 38
81717: PPUSH
81718: LD_EXP 112
81722: PUSH
81723: LD_VAR 0 2
81727: ARRAY
81728: PPUSH
81729: CALL_OW 321
81733: PUSH
81734: LD_INT 2
81736: NONEQUAL
81737: OR
81738: IFFALSE 81742
// continue ;
81740: GO 81700
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81742: LD_ADDR_VAR 0 8
81746: PUSH
81747: LD_EXP 86
81751: PUSH
81752: LD_VAR 0 2
81756: ARRAY
81757: PPUSH
81758: LD_INT 30
81760: PUSH
81761: LD_INT 34
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PPUSH
81768: CALL_OW 72
81772: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81773: LD_ADDR_VAR 0 9
81777: PUSH
81778: LD_EXP 86
81782: PUSH
81783: LD_VAR 0 2
81787: ARRAY
81788: PPUSH
81789: LD_INT 25
81791: PUSH
81792: LD_INT 4
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PPUSH
81799: CALL_OW 72
81803: PPUSH
81804: LD_INT 0
81806: PPUSH
81807: CALL 51038 0 2
81811: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81812: LD_VAR 0 9
81816: NOT
81817: PUSH
81818: LD_VAR 0 8
81822: NOT
81823: OR
81824: PUSH
81825: LD_EXP 86
81829: PUSH
81830: LD_VAR 0 2
81834: ARRAY
81835: PPUSH
81836: LD_INT 124
81838: PPUSH
81839: CALL 51038 0 2
81843: OR
81844: IFFALSE 81848
// continue ;
81846: GO 81700
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81848: LD_EXP 122
81852: PUSH
81853: LD_VAR 0 2
81857: ARRAY
81858: PUSH
81859: LD_EXP 121
81863: PUSH
81864: LD_VAR 0 2
81868: ARRAY
81869: LESS
81870: PUSH
81871: LD_EXP 122
81875: PUSH
81876: LD_VAR 0 2
81880: ARRAY
81881: PUSH
81882: LD_VAR 0 8
81886: LESS
81887: AND
81888: IFFALSE 82303
// begin tmp := sci [ 1 ] ;
81890: LD_ADDR_VAR 0 7
81894: PUSH
81895: LD_VAR 0 9
81899: PUSH
81900: LD_INT 1
81902: ARRAY
81903: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81904: LD_VAR 0 7
81908: PPUSH
81909: LD_INT 124
81911: PPUSH
81912: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81916: LD_ADDR_VAR 0 3
81920: PUSH
81921: DOUBLE
81922: LD_EXP 121
81926: PUSH
81927: LD_VAR 0 2
81931: ARRAY
81932: INC
81933: ST_TO_ADDR
81934: LD_EXP 121
81938: PUSH
81939: LD_VAR 0 2
81943: ARRAY
81944: PUSH
81945: FOR_DOWNTO
81946: IFFALSE 82289
// begin if IsInUnit ( tmp ) then
81948: LD_VAR 0 7
81952: PPUSH
81953: CALL_OW 310
81957: IFFALSE 81968
// ComExitBuilding ( tmp ) ;
81959: LD_VAR 0 7
81963: PPUSH
81964: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81968: LD_INT 35
81970: PPUSH
81971: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81975: LD_VAR 0 7
81979: PPUSH
81980: CALL_OW 310
81984: NOT
81985: PUSH
81986: LD_VAR 0 7
81990: PPUSH
81991: CALL_OW 314
81995: NOT
81996: AND
81997: IFFALSE 81968
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81999: LD_ADDR_VAR 0 6
82003: PUSH
82004: LD_VAR 0 7
82008: PPUSH
82009: CALL_OW 250
82013: PUSH
82014: LD_VAR 0 7
82018: PPUSH
82019: CALL_OW 251
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82028: LD_INT 35
82030: PPUSH
82031: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82035: LD_ADDR_VAR 0 4
82039: PUSH
82040: LD_EXP 121
82044: PUSH
82045: LD_VAR 0 2
82049: ARRAY
82050: PUSH
82051: LD_VAR 0 3
82055: ARRAY
82056: PUSH
82057: LD_INT 1
82059: ARRAY
82060: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82061: LD_ADDR_VAR 0 5
82065: PUSH
82066: LD_EXP 121
82070: PUSH
82071: LD_VAR 0 2
82075: ARRAY
82076: PUSH
82077: LD_VAR 0 3
82081: ARRAY
82082: PUSH
82083: LD_INT 2
82085: ARRAY
82086: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82087: LD_VAR 0 7
82091: PPUSH
82092: LD_INT 10
82094: PPUSH
82095: CALL 25070 0 2
82099: PUSH
82100: LD_INT 4
82102: ARRAY
82103: IFFALSE 82141
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82105: LD_VAR 0 7
82109: PPUSH
82110: LD_VAR 0 6
82114: PUSH
82115: LD_INT 1
82117: ARRAY
82118: PPUSH
82119: LD_VAR 0 6
82123: PUSH
82124: LD_INT 2
82126: ARRAY
82127: PPUSH
82128: CALL_OW 111
// wait ( 0 0$10 ) ;
82132: LD_INT 350
82134: PPUSH
82135: CALL_OW 67
// end else
82139: GO 82167
// begin ComMoveXY ( tmp , x , y ) ;
82141: LD_VAR 0 7
82145: PPUSH
82146: LD_VAR 0 4
82150: PPUSH
82151: LD_VAR 0 5
82155: PPUSH
82156: CALL_OW 111
// wait ( 0 0$3 ) ;
82160: LD_INT 105
82162: PPUSH
82163: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82167: LD_VAR 0 7
82171: PPUSH
82172: LD_VAR 0 4
82176: PPUSH
82177: LD_VAR 0 5
82181: PPUSH
82182: CALL_OW 307
82186: IFFALSE 82028
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82188: LD_VAR 0 7
82192: PPUSH
82193: LD_VAR 0 4
82197: PPUSH
82198: LD_VAR 0 5
82202: PPUSH
82203: LD_VAR 0 8
82207: PUSH
82208: LD_VAR 0 3
82212: ARRAY
82213: PPUSH
82214: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82218: LD_INT 35
82220: PPUSH
82221: CALL_OW 67
// until not HasTask ( tmp ) ;
82225: LD_VAR 0 7
82229: PPUSH
82230: CALL_OW 314
82234: NOT
82235: IFFALSE 82218
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82237: LD_ADDR_EXP 122
82241: PUSH
82242: LD_EXP 122
82246: PPUSH
82247: LD_VAR 0 2
82251: PUSH
82252: LD_EXP 122
82256: PUSH
82257: LD_VAR 0 2
82261: ARRAY
82262: PUSH
82263: LD_INT 1
82265: PLUS
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PPUSH
82271: LD_VAR 0 8
82275: PUSH
82276: LD_VAR 0 3
82280: ARRAY
82281: PPUSH
82282: CALL 22477 0 3
82286: ST_TO_ADDR
// end ;
82287: GO 81945
82289: POP
82290: POP
// MC_Reset ( i , 124 ) ;
82291: LD_VAR 0 2
82295: PPUSH
82296: LD_INT 124
82298: PPUSH
82299: CALL 65862 0 2
// end ; end ;
82303: GO 81700
82305: POP
82306: POP
// end ;
82307: LD_VAR 0 1
82311: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82312: LD_INT 0
82314: PPUSH
82315: PPUSH
82316: PPUSH
// if not mc_bases then
82317: LD_EXP 86
82321: NOT
82322: IFFALSE 82326
// exit ;
82324: GO 82932
// for i = 1 to mc_bases do
82326: LD_ADDR_VAR 0 2
82330: PUSH
82331: DOUBLE
82332: LD_INT 1
82334: DEC
82335: ST_TO_ADDR
82336: LD_EXP 86
82340: PUSH
82341: FOR_TO
82342: IFFALSE 82930
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82344: LD_ADDR_VAR 0 3
82348: PUSH
82349: LD_EXP 86
82353: PUSH
82354: LD_VAR 0 2
82358: ARRAY
82359: PPUSH
82360: LD_INT 25
82362: PUSH
82363: LD_INT 4
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PPUSH
82370: CALL_OW 72
82374: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82375: LD_VAR 0 3
82379: NOT
82380: PUSH
82381: LD_EXP 123
82385: PUSH
82386: LD_VAR 0 2
82390: ARRAY
82391: NOT
82392: OR
82393: PUSH
82394: LD_EXP 86
82398: PUSH
82399: LD_VAR 0 2
82403: ARRAY
82404: PPUSH
82405: LD_INT 2
82407: PUSH
82408: LD_INT 30
82410: PUSH
82411: LD_INT 0
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 30
82420: PUSH
82421: LD_INT 1
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: LIST
82432: PPUSH
82433: CALL_OW 72
82437: NOT
82438: OR
82439: IFFALSE 82489
// begin if mc_deposits_finder [ i ] then
82441: LD_EXP 124
82445: PUSH
82446: LD_VAR 0 2
82450: ARRAY
82451: IFFALSE 82487
// begin MC_Reset ( i , 125 ) ;
82453: LD_VAR 0 2
82457: PPUSH
82458: LD_INT 125
82460: PPUSH
82461: CALL 65862 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82465: LD_ADDR_EXP 124
82469: PUSH
82470: LD_EXP 124
82474: PPUSH
82475: LD_VAR 0 2
82479: PPUSH
82480: EMPTY
82481: PPUSH
82482: CALL_OW 1
82486: ST_TO_ADDR
// end ; continue ;
82487: GO 82341
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82489: LD_EXP 123
82493: PUSH
82494: LD_VAR 0 2
82498: ARRAY
82499: PUSH
82500: LD_INT 1
82502: ARRAY
82503: PUSH
82504: LD_INT 3
82506: ARRAY
82507: PUSH
82508: LD_INT 1
82510: EQUAL
82511: PUSH
82512: LD_INT 20
82514: PPUSH
82515: LD_EXP 112
82519: PUSH
82520: LD_VAR 0 2
82524: ARRAY
82525: PPUSH
82526: CALL_OW 321
82530: PUSH
82531: LD_INT 2
82533: NONEQUAL
82534: AND
82535: IFFALSE 82585
// begin if mc_deposits_finder [ i ] then
82537: LD_EXP 124
82541: PUSH
82542: LD_VAR 0 2
82546: ARRAY
82547: IFFALSE 82583
// begin MC_Reset ( i , 125 ) ;
82549: LD_VAR 0 2
82553: PPUSH
82554: LD_INT 125
82556: PPUSH
82557: CALL 65862 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82561: LD_ADDR_EXP 124
82565: PUSH
82566: LD_EXP 124
82570: PPUSH
82571: LD_VAR 0 2
82575: PPUSH
82576: EMPTY
82577: PPUSH
82578: CALL_OW 1
82582: ST_TO_ADDR
// end ; continue ;
82583: GO 82341
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82585: LD_EXP 123
82589: PUSH
82590: LD_VAR 0 2
82594: ARRAY
82595: PUSH
82596: LD_INT 1
82598: ARRAY
82599: PUSH
82600: LD_INT 1
82602: ARRAY
82603: PPUSH
82604: LD_EXP 123
82608: PUSH
82609: LD_VAR 0 2
82613: ARRAY
82614: PUSH
82615: LD_INT 1
82617: ARRAY
82618: PUSH
82619: LD_INT 2
82621: ARRAY
82622: PPUSH
82623: LD_EXP 112
82627: PUSH
82628: LD_VAR 0 2
82632: ARRAY
82633: PPUSH
82634: CALL_OW 440
82638: IFFALSE 82681
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82640: LD_ADDR_EXP 123
82644: PUSH
82645: LD_EXP 123
82649: PPUSH
82650: LD_VAR 0 2
82654: PPUSH
82655: LD_EXP 123
82659: PUSH
82660: LD_VAR 0 2
82664: ARRAY
82665: PPUSH
82666: LD_INT 1
82668: PPUSH
82669: CALL_OW 3
82673: PPUSH
82674: CALL_OW 1
82678: ST_TO_ADDR
82679: GO 82928
// begin if not mc_deposits_finder [ i ] then
82681: LD_EXP 124
82685: PUSH
82686: LD_VAR 0 2
82690: ARRAY
82691: NOT
82692: IFFALSE 82744
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82694: LD_ADDR_EXP 124
82698: PUSH
82699: LD_EXP 124
82703: PPUSH
82704: LD_VAR 0 2
82708: PPUSH
82709: LD_VAR 0 3
82713: PUSH
82714: LD_INT 1
82716: ARRAY
82717: PUSH
82718: EMPTY
82719: LIST
82720: PPUSH
82721: CALL_OW 1
82725: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82726: LD_VAR 0 3
82730: PUSH
82731: LD_INT 1
82733: ARRAY
82734: PPUSH
82735: LD_INT 125
82737: PPUSH
82738: CALL_OW 109
// end else
82742: GO 82928
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82744: LD_EXP 124
82748: PUSH
82749: LD_VAR 0 2
82753: ARRAY
82754: PUSH
82755: LD_INT 1
82757: ARRAY
82758: PPUSH
82759: CALL_OW 310
82763: IFFALSE 82786
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82765: LD_EXP 124
82769: PUSH
82770: LD_VAR 0 2
82774: ARRAY
82775: PUSH
82776: LD_INT 1
82778: ARRAY
82779: PPUSH
82780: CALL_OW 122
82784: GO 82928
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82786: LD_EXP 124
82790: PUSH
82791: LD_VAR 0 2
82795: ARRAY
82796: PUSH
82797: LD_INT 1
82799: ARRAY
82800: PPUSH
82801: CALL_OW 314
82805: NOT
82806: PUSH
82807: LD_EXP 124
82811: PUSH
82812: LD_VAR 0 2
82816: ARRAY
82817: PUSH
82818: LD_INT 1
82820: ARRAY
82821: PPUSH
82822: LD_EXP 123
82826: PUSH
82827: LD_VAR 0 2
82831: ARRAY
82832: PUSH
82833: LD_INT 1
82835: ARRAY
82836: PUSH
82837: LD_INT 1
82839: ARRAY
82840: PPUSH
82841: LD_EXP 123
82845: PUSH
82846: LD_VAR 0 2
82850: ARRAY
82851: PUSH
82852: LD_INT 1
82854: ARRAY
82855: PUSH
82856: LD_INT 2
82858: ARRAY
82859: PPUSH
82860: CALL_OW 297
82864: PUSH
82865: LD_INT 6
82867: GREATER
82868: AND
82869: IFFALSE 82928
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82871: LD_EXP 124
82875: PUSH
82876: LD_VAR 0 2
82880: ARRAY
82881: PUSH
82882: LD_INT 1
82884: ARRAY
82885: PPUSH
82886: LD_EXP 123
82890: PUSH
82891: LD_VAR 0 2
82895: ARRAY
82896: PUSH
82897: LD_INT 1
82899: ARRAY
82900: PUSH
82901: LD_INT 1
82903: ARRAY
82904: PPUSH
82905: LD_EXP 123
82909: PUSH
82910: LD_VAR 0 2
82914: ARRAY
82915: PUSH
82916: LD_INT 1
82918: ARRAY
82919: PUSH
82920: LD_INT 2
82922: ARRAY
82923: PPUSH
82924: CALL_OW 111
// end ; end ; end ;
82928: GO 82341
82930: POP
82931: POP
// end ;
82932: LD_VAR 0 1
82936: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82937: LD_INT 0
82939: PPUSH
82940: PPUSH
82941: PPUSH
82942: PPUSH
82943: PPUSH
82944: PPUSH
82945: PPUSH
82946: PPUSH
82947: PPUSH
82948: PPUSH
82949: PPUSH
// if not mc_bases then
82950: LD_EXP 86
82954: NOT
82955: IFFALSE 82959
// exit ;
82957: GO 83899
// for i = 1 to mc_bases do
82959: LD_ADDR_VAR 0 2
82963: PUSH
82964: DOUBLE
82965: LD_INT 1
82967: DEC
82968: ST_TO_ADDR
82969: LD_EXP 86
82973: PUSH
82974: FOR_TO
82975: IFFALSE 83897
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82977: LD_EXP 86
82981: PUSH
82982: LD_VAR 0 2
82986: ARRAY
82987: NOT
82988: PUSH
82989: LD_EXP 109
82993: PUSH
82994: LD_VAR 0 2
82998: ARRAY
82999: OR
83000: IFFALSE 83004
// continue ;
83002: GO 82974
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83004: LD_ADDR_VAR 0 7
83008: PUSH
83009: LD_EXP 86
83013: PUSH
83014: LD_VAR 0 2
83018: ARRAY
83019: PUSH
83020: LD_INT 1
83022: ARRAY
83023: PPUSH
83024: CALL_OW 248
83028: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83029: LD_VAR 0 7
83033: PUSH
83034: LD_INT 3
83036: EQUAL
83037: PUSH
83038: LD_EXP 105
83042: PUSH
83043: LD_VAR 0 2
83047: ARRAY
83048: PUSH
83049: LD_EXP 108
83053: PUSH
83054: LD_VAR 0 2
83058: ARRAY
83059: UNION
83060: PPUSH
83061: LD_INT 33
83063: PUSH
83064: LD_INT 2
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PPUSH
83071: CALL_OW 72
83075: NOT
83076: OR
83077: IFFALSE 83081
// continue ;
83079: GO 82974
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83081: LD_ADDR_VAR 0 9
83085: PUSH
83086: LD_EXP 86
83090: PUSH
83091: LD_VAR 0 2
83095: ARRAY
83096: PPUSH
83097: LD_INT 30
83099: PUSH
83100: LD_INT 36
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PPUSH
83107: CALL_OW 72
83111: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83112: LD_ADDR_VAR 0 10
83116: PUSH
83117: LD_EXP 105
83121: PUSH
83122: LD_VAR 0 2
83126: ARRAY
83127: PPUSH
83128: LD_INT 34
83130: PUSH
83131: LD_INT 31
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PPUSH
83138: CALL_OW 72
83142: ST_TO_ADDR
// if not cts and not mcts then
83143: LD_VAR 0 9
83147: NOT
83148: PUSH
83149: LD_VAR 0 10
83153: NOT
83154: AND
83155: IFFALSE 83159
// continue ;
83157: GO 82974
// x := cts ;
83159: LD_ADDR_VAR 0 11
83163: PUSH
83164: LD_VAR 0 9
83168: ST_TO_ADDR
// if not x then
83169: LD_VAR 0 11
83173: NOT
83174: IFFALSE 83186
// x := mcts ;
83176: LD_ADDR_VAR 0 11
83180: PUSH
83181: LD_VAR 0 10
83185: ST_TO_ADDR
// if not x then
83186: LD_VAR 0 11
83190: NOT
83191: IFFALSE 83195
// continue ;
83193: GO 82974
// if mc_remote_driver [ i ] then
83195: LD_EXP 126
83199: PUSH
83200: LD_VAR 0 2
83204: ARRAY
83205: IFFALSE 83592
// for j in mc_remote_driver [ i ] do
83207: LD_ADDR_VAR 0 3
83211: PUSH
83212: LD_EXP 126
83216: PUSH
83217: LD_VAR 0 2
83221: ARRAY
83222: PUSH
83223: FOR_IN
83224: IFFALSE 83590
// begin if GetClass ( j ) <> 3 then
83226: LD_VAR 0 3
83230: PPUSH
83231: CALL_OW 257
83235: PUSH
83236: LD_INT 3
83238: NONEQUAL
83239: IFFALSE 83292
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83241: LD_ADDR_EXP 126
83245: PUSH
83246: LD_EXP 126
83250: PPUSH
83251: LD_VAR 0 2
83255: PPUSH
83256: LD_EXP 126
83260: PUSH
83261: LD_VAR 0 2
83265: ARRAY
83266: PUSH
83267: LD_VAR 0 3
83271: DIFF
83272: PPUSH
83273: CALL_OW 1
83277: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83278: LD_VAR 0 3
83282: PPUSH
83283: LD_INT 0
83285: PPUSH
83286: CALL_OW 109
// continue ;
83290: GO 83223
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83292: LD_EXP 105
83296: PUSH
83297: LD_VAR 0 2
83301: ARRAY
83302: PPUSH
83303: LD_INT 34
83305: PUSH
83306: LD_INT 31
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 58
83315: PUSH
83316: EMPTY
83317: LIST
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PPUSH
83323: CALL_OW 72
83327: PUSH
83328: LD_VAR 0 3
83332: PPUSH
83333: CALL 51126 0 1
83337: NOT
83338: AND
83339: IFFALSE 83410
// begin if IsInUnit ( j ) then
83341: LD_VAR 0 3
83345: PPUSH
83346: CALL_OW 310
83350: IFFALSE 83361
// ComExitBuilding ( j ) ;
83352: LD_VAR 0 3
83356: PPUSH
83357: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83361: LD_VAR 0 3
83365: PPUSH
83366: LD_EXP 105
83370: PUSH
83371: LD_VAR 0 2
83375: ARRAY
83376: PPUSH
83377: LD_INT 34
83379: PUSH
83380: LD_INT 31
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 58
83389: PUSH
83390: EMPTY
83391: LIST
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PPUSH
83397: CALL_OW 72
83401: PUSH
83402: LD_INT 1
83404: ARRAY
83405: PPUSH
83406: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83410: LD_VAR 0 3
83414: PPUSH
83415: CALL_OW 310
83419: NOT
83420: PUSH
83421: LD_VAR 0 3
83425: PPUSH
83426: CALL_OW 310
83430: PPUSH
83431: CALL_OW 266
83435: PUSH
83436: LD_INT 36
83438: NONEQUAL
83439: PUSH
83440: LD_VAR 0 3
83444: PPUSH
83445: CALL 51126 0 1
83449: NOT
83450: AND
83451: OR
83452: IFFALSE 83588
// begin if IsInUnit ( j ) then
83454: LD_VAR 0 3
83458: PPUSH
83459: CALL_OW 310
83463: IFFALSE 83474
// ComExitBuilding ( j ) ;
83465: LD_VAR 0 3
83469: PPUSH
83470: CALL_OW 122
// ct := 0 ;
83474: LD_ADDR_VAR 0 8
83478: PUSH
83479: LD_INT 0
83481: ST_TO_ADDR
// for k in x do
83482: LD_ADDR_VAR 0 4
83486: PUSH
83487: LD_VAR 0 11
83491: PUSH
83492: FOR_IN
83493: IFFALSE 83566
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83495: LD_VAR 0 4
83499: PPUSH
83500: CALL_OW 264
83504: PUSH
83505: LD_INT 31
83507: EQUAL
83508: PUSH
83509: LD_VAR 0 4
83513: PPUSH
83514: CALL_OW 311
83518: NOT
83519: AND
83520: PUSH
83521: LD_VAR 0 4
83525: PPUSH
83526: CALL_OW 266
83530: PUSH
83531: LD_INT 36
83533: EQUAL
83534: PUSH
83535: LD_VAR 0 4
83539: PPUSH
83540: CALL_OW 313
83544: PUSH
83545: LD_INT 3
83547: LESS
83548: AND
83549: OR
83550: IFFALSE 83564
// begin ct := k ;
83552: LD_ADDR_VAR 0 8
83556: PUSH
83557: LD_VAR 0 4
83561: ST_TO_ADDR
// break ;
83562: GO 83566
// end ;
83564: GO 83492
83566: POP
83567: POP
// if ct then
83568: LD_VAR 0 8
83572: IFFALSE 83588
// ComEnterUnit ( j , ct ) ;
83574: LD_VAR 0 3
83578: PPUSH
83579: LD_VAR 0 8
83583: PPUSH
83584: CALL_OW 120
// end ; end ;
83588: GO 83223
83590: POP
83591: POP
// places := 0 ;
83592: LD_ADDR_VAR 0 5
83596: PUSH
83597: LD_INT 0
83599: ST_TO_ADDR
// for j = 1 to x do
83600: LD_ADDR_VAR 0 3
83604: PUSH
83605: DOUBLE
83606: LD_INT 1
83608: DEC
83609: ST_TO_ADDR
83610: LD_VAR 0 11
83614: PUSH
83615: FOR_TO
83616: IFFALSE 83692
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83618: LD_VAR 0 11
83622: PUSH
83623: LD_VAR 0 3
83627: ARRAY
83628: PPUSH
83629: CALL_OW 264
83633: PUSH
83634: LD_INT 31
83636: EQUAL
83637: IFFALSE 83655
// places := places + 1 else
83639: LD_ADDR_VAR 0 5
83643: PUSH
83644: LD_VAR 0 5
83648: PUSH
83649: LD_INT 1
83651: PLUS
83652: ST_TO_ADDR
83653: GO 83690
// if GetBType ( x [ j ] ) = b_control_tower then
83655: LD_VAR 0 11
83659: PUSH
83660: LD_VAR 0 3
83664: ARRAY
83665: PPUSH
83666: CALL_OW 266
83670: PUSH
83671: LD_INT 36
83673: EQUAL
83674: IFFALSE 83690
// places := places + 3 ;
83676: LD_ADDR_VAR 0 5
83680: PUSH
83681: LD_VAR 0 5
83685: PUSH
83686: LD_INT 3
83688: PLUS
83689: ST_TO_ADDR
83690: GO 83615
83692: POP
83693: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83694: LD_VAR 0 5
83698: PUSH
83699: LD_INT 0
83701: EQUAL
83702: PUSH
83703: LD_VAR 0 5
83707: PUSH
83708: LD_EXP 126
83712: PUSH
83713: LD_VAR 0 2
83717: ARRAY
83718: LESSEQUAL
83719: OR
83720: IFFALSE 83724
// continue ;
83722: GO 82974
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83724: LD_ADDR_VAR 0 6
83728: PUSH
83729: LD_EXP 86
83733: PUSH
83734: LD_VAR 0 2
83738: ARRAY
83739: PPUSH
83740: LD_INT 25
83742: PUSH
83743: LD_INT 3
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PPUSH
83750: CALL_OW 72
83754: PUSH
83755: LD_EXP 126
83759: PUSH
83760: LD_VAR 0 2
83764: ARRAY
83765: DIFF
83766: PPUSH
83767: LD_INT 3
83769: PPUSH
83770: CALL 52026 0 2
83774: ST_TO_ADDR
// for j in tmp do
83775: LD_ADDR_VAR 0 3
83779: PUSH
83780: LD_VAR 0 6
83784: PUSH
83785: FOR_IN
83786: IFFALSE 83821
// if GetTag ( j ) > 0 then
83788: LD_VAR 0 3
83792: PPUSH
83793: CALL_OW 110
83797: PUSH
83798: LD_INT 0
83800: GREATER
83801: IFFALSE 83819
// tmp := tmp diff j ;
83803: LD_ADDR_VAR 0 6
83807: PUSH
83808: LD_VAR 0 6
83812: PUSH
83813: LD_VAR 0 3
83817: DIFF
83818: ST_TO_ADDR
83819: GO 83785
83821: POP
83822: POP
// if not tmp then
83823: LD_VAR 0 6
83827: NOT
83828: IFFALSE 83832
// continue ;
83830: GO 82974
// if places then
83832: LD_VAR 0 5
83836: IFFALSE 83895
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83838: LD_ADDR_EXP 126
83842: PUSH
83843: LD_EXP 126
83847: PPUSH
83848: LD_VAR 0 2
83852: PPUSH
83853: LD_EXP 126
83857: PUSH
83858: LD_VAR 0 2
83862: ARRAY
83863: PUSH
83864: LD_VAR 0 6
83868: PUSH
83869: LD_INT 1
83871: ARRAY
83872: UNION
83873: PPUSH
83874: CALL_OW 1
83878: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83879: LD_VAR 0 6
83883: PUSH
83884: LD_INT 1
83886: ARRAY
83887: PPUSH
83888: LD_INT 126
83890: PPUSH
83891: CALL_OW 109
// end ; end ;
83895: GO 82974
83897: POP
83898: POP
// end ;
83899: LD_VAR 0 1
83903: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83904: LD_INT 0
83906: PPUSH
83907: PPUSH
83908: PPUSH
83909: PPUSH
83910: PPUSH
83911: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83912: LD_VAR 0 1
83916: NOT
83917: PUSH
83918: LD_VAR 0 2
83922: NOT
83923: OR
83924: PUSH
83925: LD_VAR 0 3
83929: NOT
83930: OR
83931: PUSH
83932: LD_VAR 0 4
83936: PUSH
83937: LD_INT 1
83939: PUSH
83940: LD_INT 2
83942: PUSH
83943: LD_INT 3
83945: PUSH
83946: LD_INT 4
83948: PUSH
83949: LD_INT 5
83951: PUSH
83952: LD_INT 8
83954: PUSH
83955: LD_INT 9
83957: PUSH
83958: LD_INT 15
83960: PUSH
83961: LD_INT 16
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: IN
83975: NOT
83976: OR
83977: IFFALSE 83981
// exit ;
83979: GO 84881
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83981: LD_ADDR_VAR 0 2
83985: PUSH
83986: LD_VAR 0 2
83990: PPUSH
83991: LD_INT 21
83993: PUSH
83994: LD_INT 3
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 24
84003: PUSH
84004: LD_INT 250
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PPUSH
84015: CALL_OW 72
84019: ST_TO_ADDR
// case class of 1 , 15 :
84020: LD_VAR 0 4
84024: PUSH
84025: LD_INT 1
84027: DOUBLE
84028: EQUAL
84029: IFTRUE 84039
84031: LD_INT 15
84033: DOUBLE
84034: EQUAL
84035: IFTRUE 84039
84037: GO 84124
84039: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84040: LD_ADDR_VAR 0 8
84044: PUSH
84045: LD_VAR 0 2
84049: PPUSH
84050: LD_INT 2
84052: PUSH
84053: LD_INT 30
84055: PUSH
84056: LD_INT 32
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 30
84065: PUSH
84066: LD_INT 31
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: LIST
84077: PPUSH
84078: CALL_OW 72
84082: PUSH
84083: LD_VAR 0 2
84087: PPUSH
84088: LD_INT 2
84090: PUSH
84091: LD_INT 30
84093: PUSH
84094: LD_INT 4
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 30
84103: PUSH
84104: LD_INT 5
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: LIST
84115: PPUSH
84116: CALL_OW 72
84120: ADD
84121: ST_TO_ADDR
84122: GO 84370
84124: LD_INT 2
84126: DOUBLE
84127: EQUAL
84128: IFTRUE 84138
84130: LD_INT 16
84132: DOUBLE
84133: EQUAL
84134: IFTRUE 84138
84136: GO 84184
84138: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84139: LD_ADDR_VAR 0 8
84143: PUSH
84144: LD_VAR 0 2
84148: PPUSH
84149: LD_INT 2
84151: PUSH
84152: LD_INT 30
84154: PUSH
84155: LD_INT 0
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 30
84164: PUSH
84165: LD_INT 1
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: LIST
84176: PPUSH
84177: CALL_OW 72
84181: ST_TO_ADDR
84182: GO 84370
84184: LD_INT 3
84186: DOUBLE
84187: EQUAL
84188: IFTRUE 84192
84190: GO 84238
84192: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84193: LD_ADDR_VAR 0 8
84197: PUSH
84198: LD_VAR 0 2
84202: PPUSH
84203: LD_INT 2
84205: PUSH
84206: LD_INT 30
84208: PUSH
84209: LD_INT 2
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 30
84218: PUSH
84219: LD_INT 3
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: LIST
84230: PPUSH
84231: CALL_OW 72
84235: ST_TO_ADDR
84236: GO 84370
84238: LD_INT 4
84240: DOUBLE
84241: EQUAL
84242: IFTRUE 84246
84244: GO 84303
84246: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84247: LD_ADDR_VAR 0 8
84251: PUSH
84252: LD_VAR 0 2
84256: PPUSH
84257: LD_INT 2
84259: PUSH
84260: LD_INT 30
84262: PUSH
84263: LD_INT 6
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 30
84272: PUSH
84273: LD_INT 7
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 30
84282: PUSH
84283: LD_INT 8
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: PPUSH
84296: CALL_OW 72
84300: ST_TO_ADDR
84301: GO 84370
84303: LD_INT 5
84305: DOUBLE
84306: EQUAL
84307: IFTRUE 84323
84309: LD_INT 8
84311: DOUBLE
84312: EQUAL
84313: IFTRUE 84323
84315: LD_INT 9
84317: DOUBLE
84318: EQUAL
84319: IFTRUE 84323
84321: GO 84369
84323: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84324: LD_ADDR_VAR 0 8
84328: PUSH
84329: LD_VAR 0 2
84333: PPUSH
84334: LD_INT 2
84336: PUSH
84337: LD_INT 30
84339: PUSH
84340: LD_INT 4
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 30
84349: PUSH
84350: LD_INT 5
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: PPUSH
84362: CALL_OW 72
84366: ST_TO_ADDR
84367: GO 84370
84369: POP
// if not tmp then
84370: LD_VAR 0 8
84374: NOT
84375: IFFALSE 84379
// exit ;
84377: GO 84881
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84379: LD_VAR 0 4
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: LD_INT 15
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: IN
84394: PUSH
84395: LD_EXP 95
84399: PUSH
84400: LD_VAR 0 1
84404: ARRAY
84405: AND
84406: IFFALSE 84562
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84408: LD_ADDR_VAR 0 9
84412: PUSH
84413: LD_EXP 95
84417: PUSH
84418: LD_VAR 0 1
84422: ARRAY
84423: PUSH
84424: LD_INT 1
84426: ARRAY
84427: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84428: LD_VAR 0 9
84432: PUSH
84433: LD_EXP 96
84437: PUSH
84438: LD_VAR 0 1
84442: ARRAY
84443: IN
84444: NOT
84445: IFFALSE 84560
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84447: LD_ADDR_EXP 96
84451: PUSH
84452: LD_EXP 96
84456: PPUSH
84457: LD_VAR 0 1
84461: PUSH
84462: LD_EXP 96
84466: PUSH
84467: LD_VAR 0 1
84471: ARRAY
84472: PUSH
84473: LD_INT 1
84475: PLUS
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: PPUSH
84481: LD_VAR 0 9
84485: PPUSH
84486: CALL 22477 0 3
84490: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84491: LD_ADDR_EXP 95
84495: PUSH
84496: LD_EXP 95
84500: PPUSH
84501: LD_VAR 0 1
84505: PPUSH
84506: LD_EXP 95
84510: PUSH
84511: LD_VAR 0 1
84515: ARRAY
84516: PUSH
84517: LD_VAR 0 9
84521: DIFF
84522: PPUSH
84523: CALL_OW 1
84527: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84528: LD_VAR 0 3
84532: PPUSH
84533: LD_EXP 96
84537: PUSH
84538: LD_VAR 0 1
84542: ARRAY
84543: PUSH
84544: LD_EXP 96
84548: PUSH
84549: LD_VAR 0 1
84553: ARRAY
84554: ARRAY
84555: PPUSH
84556: CALL_OW 120
// end ; exit ;
84560: GO 84881
// end ; if tmp > 1 then
84562: LD_VAR 0 8
84566: PUSH
84567: LD_INT 1
84569: GREATER
84570: IFFALSE 84674
// for i = 2 to tmp do
84572: LD_ADDR_VAR 0 6
84576: PUSH
84577: DOUBLE
84578: LD_INT 2
84580: DEC
84581: ST_TO_ADDR
84582: LD_VAR 0 8
84586: PUSH
84587: FOR_TO
84588: IFFALSE 84672
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84590: LD_VAR 0 8
84594: PUSH
84595: LD_VAR 0 6
84599: ARRAY
84600: PPUSH
84601: CALL_OW 461
84605: PUSH
84606: LD_INT 6
84608: EQUAL
84609: IFFALSE 84670
// begin x := tmp [ i ] ;
84611: LD_ADDR_VAR 0 9
84615: PUSH
84616: LD_VAR 0 8
84620: PUSH
84621: LD_VAR 0 6
84625: ARRAY
84626: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84627: LD_ADDR_VAR 0 8
84631: PUSH
84632: LD_VAR 0 8
84636: PPUSH
84637: LD_VAR 0 6
84641: PPUSH
84642: CALL_OW 3
84646: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84647: LD_ADDR_VAR 0 8
84651: PUSH
84652: LD_VAR 0 8
84656: PPUSH
84657: LD_INT 1
84659: PPUSH
84660: LD_VAR 0 9
84664: PPUSH
84665: CALL_OW 2
84669: ST_TO_ADDR
// end ;
84670: GO 84587
84672: POP
84673: POP
// for i in tmp do
84674: LD_ADDR_VAR 0 6
84678: PUSH
84679: LD_VAR 0 8
84683: PUSH
84684: FOR_IN
84685: IFFALSE 84754
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84687: LD_VAR 0 6
84691: PPUSH
84692: CALL_OW 313
84696: PUSH
84697: LD_INT 6
84699: LESS
84700: PUSH
84701: LD_VAR 0 6
84705: PPUSH
84706: CALL_OW 266
84710: PUSH
84711: LD_INT 31
84713: PUSH
84714: LD_INT 32
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: IN
84721: NOT
84722: AND
84723: PUSH
84724: LD_VAR 0 6
84728: PPUSH
84729: CALL_OW 313
84733: PUSH
84734: LD_INT 0
84736: EQUAL
84737: OR
84738: IFFALSE 84752
// begin j := i ;
84740: LD_ADDR_VAR 0 7
84744: PUSH
84745: LD_VAR 0 6
84749: ST_TO_ADDR
// break ;
84750: GO 84754
// end ; end ;
84752: GO 84684
84754: POP
84755: POP
// if j then
84756: LD_VAR 0 7
84760: IFFALSE 84778
// ComEnterUnit ( unit , j ) else
84762: LD_VAR 0 3
84766: PPUSH
84767: LD_VAR 0 7
84771: PPUSH
84772: CALL_OW 120
84776: GO 84881
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84778: LD_ADDR_VAR 0 10
84782: PUSH
84783: LD_VAR 0 2
84787: PPUSH
84788: LD_INT 2
84790: PUSH
84791: LD_INT 30
84793: PUSH
84794: LD_INT 0
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 30
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: LIST
84815: PPUSH
84816: CALL_OW 72
84820: ST_TO_ADDR
// if depot then
84821: LD_VAR 0 10
84825: IFFALSE 84881
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84827: LD_ADDR_VAR 0 10
84831: PUSH
84832: LD_VAR 0 10
84836: PPUSH
84837: LD_VAR 0 3
84841: PPUSH
84842: CALL_OW 74
84846: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84847: LD_VAR 0 3
84851: PPUSH
84852: LD_VAR 0 10
84856: PPUSH
84857: CALL_OW 296
84861: PUSH
84862: LD_INT 10
84864: GREATER
84865: IFFALSE 84881
// ComStandNearbyBuilding ( unit , depot ) ;
84867: LD_VAR 0 3
84871: PPUSH
84872: LD_VAR 0 10
84876: PPUSH
84877: CALL 19091 0 2
// end ; end ; end ;
84881: LD_VAR 0 5
84885: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84886: LD_INT 0
84888: PPUSH
84889: PPUSH
84890: PPUSH
84891: PPUSH
// if not mc_bases then
84892: LD_EXP 86
84896: NOT
84897: IFFALSE 84901
// exit ;
84899: GO 85140
// for i = 1 to mc_bases do
84901: LD_ADDR_VAR 0 2
84905: PUSH
84906: DOUBLE
84907: LD_INT 1
84909: DEC
84910: ST_TO_ADDR
84911: LD_EXP 86
84915: PUSH
84916: FOR_TO
84917: IFFALSE 85138
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84919: LD_ADDR_VAR 0 4
84923: PUSH
84924: LD_EXP 86
84928: PUSH
84929: LD_VAR 0 2
84933: ARRAY
84934: PPUSH
84935: LD_INT 21
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PPUSH
84945: CALL_OW 72
84949: PUSH
84950: LD_EXP 115
84954: PUSH
84955: LD_VAR 0 2
84959: ARRAY
84960: UNION
84961: ST_TO_ADDR
// if not tmp then
84962: LD_VAR 0 4
84966: NOT
84967: IFFALSE 84971
// continue ;
84969: GO 84916
// for j in tmp do
84971: LD_ADDR_VAR 0 3
84975: PUSH
84976: LD_VAR 0 4
84980: PUSH
84981: FOR_IN
84982: IFFALSE 85134
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84984: LD_VAR 0 3
84988: PPUSH
84989: CALL_OW 110
84993: NOT
84994: PUSH
84995: LD_VAR 0 3
84999: PPUSH
85000: CALL_OW 314
85004: NOT
85005: AND
85006: PUSH
85007: LD_VAR 0 3
85011: PPUSH
85012: CALL_OW 311
85016: NOT
85017: AND
85018: PUSH
85019: LD_VAR 0 3
85023: PPUSH
85024: CALL_OW 310
85028: NOT
85029: AND
85030: PUSH
85031: LD_VAR 0 3
85035: PUSH
85036: LD_EXP 89
85040: PUSH
85041: LD_VAR 0 2
85045: ARRAY
85046: PUSH
85047: LD_INT 1
85049: ARRAY
85050: IN
85051: NOT
85052: AND
85053: PUSH
85054: LD_VAR 0 3
85058: PUSH
85059: LD_EXP 89
85063: PUSH
85064: LD_VAR 0 2
85068: ARRAY
85069: PUSH
85070: LD_INT 2
85072: ARRAY
85073: IN
85074: NOT
85075: AND
85076: PUSH
85077: LD_VAR 0 3
85081: PUSH
85082: LD_EXP 98
85086: PUSH
85087: LD_VAR 0 2
85091: ARRAY
85092: IN
85093: NOT
85094: AND
85095: IFFALSE 85132
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85097: LD_VAR 0 2
85101: PPUSH
85102: LD_EXP 86
85106: PUSH
85107: LD_VAR 0 2
85111: ARRAY
85112: PPUSH
85113: LD_VAR 0 3
85117: PPUSH
85118: LD_VAR 0 3
85122: PPUSH
85123: CALL_OW 257
85127: PPUSH
85128: CALL 83904 0 4
// end ;
85132: GO 84981
85134: POP
85135: POP
// end ;
85136: GO 84916
85138: POP
85139: POP
// end ;
85140: LD_VAR 0 1
85144: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85145: LD_INT 0
85147: PPUSH
85148: PPUSH
85149: PPUSH
85150: PPUSH
85151: PPUSH
85152: PPUSH
// if not mc_bases [ base ] then
85153: LD_EXP 86
85157: PUSH
85158: LD_VAR 0 1
85162: ARRAY
85163: NOT
85164: IFFALSE 85168
// exit ;
85166: GO 85350
// tmp := [ ] ;
85168: LD_ADDR_VAR 0 6
85172: PUSH
85173: EMPTY
85174: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85175: LD_ADDR_VAR 0 7
85179: PUSH
85180: LD_VAR 0 3
85184: PPUSH
85185: LD_INT 0
85187: PPUSH
85188: CALL_OW 517
85192: ST_TO_ADDR
// if not list then
85193: LD_VAR 0 7
85197: NOT
85198: IFFALSE 85202
// exit ;
85200: GO 85350
// for i = 1 to amount do
85202: LD_ADDR_VAR 0 5
85206: PUSH
85207: DOUBLE
85208: LD_INT 1
85210: DEC
85211: ST_TO_ADDR
85212: LD_VAR 0 2
85216: PUSH
85217: FOR_TO
85218: IFFALSE 85298
// begin x := rand ( 1 , list [ 1 ] ) ;
85220: LD_ADDR_VAR 0 8
85224: PUSH
85225: LD_INT 1
85227: PPUSH
85228: LD_VAR 0 7
85232: PUSH
85233: LD_INT 1
85235: ARRAY
85236: PPUSH
85237: CALL_OW 12
85241: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85242: LD_ADDR_VAR 0 6
85246: PUSH
85247: LD_VAR 0 6
85251: PPUSH
85252: LD_VAR 0 5
85256: PPUSH
85257: LD_VAR 0 7
85261: PUSH
85262: LD_INT 1
85264: ARRAY
85265: PUSH
85266: LD_VAR 0 8
85270: ARRAY
85271: PUSH
85272: LD_VAR 0 7
85276: PUSH
85277: LD_INT 2
85279: ARRAY
85280: PUSH
85281: LD_VAR 0 8
85285: ARRAY
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PPUSH
85291: CALL_OW 1
85295: ST_TO_ADDR
// end ;
85296: GO 85217
85298: POP
85299: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85300: LD_ADDR_EXP 99
85304: PUSH
85305: LD_EXP 99
85309: PPUSH
85310: LD_VAR 0 1
85314: PPUSH
85315: LD_VAR 0 6
85319: PPUSH
85320: CALL_OW 1
85324: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85325: LD_ADDR_EXP 101
85329: PUSH
85330: LD_EXP 101
85334: PPUSH
85335: LD_VAR 0 1
85339: PPUSH
85340: LD_VAR 0 3
85344: PPUSH
85345: CALL_OW 1
85349: ST_TO_ADDR
// end ;
85350: LD_VAR 0 4
85354: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85355: LD_INT 0
85357: PPUSH
// if not mc_bases [ base ] then
85358: LD_EXP 86
85362: PUSH
85363: LD_VAR 0 1
85367: ARRAY
85368: NOT
85369: IFFALSE 85373
// exit ;
85371: GO 85398
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85373: LD_ADDR_EXP 91
85377: PUSH
85378: LD_EXP 91
85382: PPUSH
85383: LD_VAR 0 1
85387: PPUSH
85388: LD_VAR 0 2
85392: PPUSH
85393: CALL_OW 1
85397: ST_TO_ADDR
// end ;
85398: LD_VAR 0 3
85402: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85403: LD_INT 0
85405: PPUSH
// if not mc_bases [ base ] then
85406: LD_EXP 86
85410: PUSH
85411: LD_VAR 0 1
85415: ARRAY
85416: NOT
85417: IFFALSE 85421
// exit ;
85419: GO 85458
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85421: LD_ADDR_EXP 91
85425: PUSH
85426: LD_EXP 91
85430: PPUSH
85431: LD_VAR 0 1
85435: PPUSH
85436: LD_EXP 91
85440: PUSH
85441: LD_VAR 0 1
85445: ARRAY
85446: PUSH
85447: LD_VAR 0 2
85451: UNION
85452: PPUSH
85453: CALL_OW 1
85457: ST_TO_ADDR
// end ;
85458: LD_VAR 0 3
85462: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85463: LD_INT 0
85465: PPUSH
// if not mc_bases [ base ] then
85466: LD_EXP 86
85470: PUSH
85471: LD_VAR 0 1
85475: ARRAY
85476: NOT
85477: IFFALSE 85481
// exit ;
85479: GO 85506
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85481: LD_ADDR_EXP 107
85485: PUSH
85486: LD_EXP 107
85490: PPUSH
85491: LD_VAR 0 1
85495: PPUSH
85496: LD_VAR 0 2
85500: PPUSH
85501: CALL_OW 1
85505: ST_TO_ADDR
// end ;
85506: LD_VAR 0 3
85510: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85511: LD_INT 0
85513: PPUSH
// if not mc_bases [ base ] then
85514: LD_EXP 86
85518: PUSH
85519: LD_VAR 0 1
85523: ARRAY
85524: NOT
85525: IFFALSE 85529
// exit ;
85527: GO 85566
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85529: LD_ADDR_EXP 107
85533: PUSH
85534: LD_EXP 107
85538: PPUSH
85539: LD_VAR 0 1
85543: PPUSH
85544: LD_EXP 107
85548: PUSH
85549: LD_VAR 0 1
85553: ARRAY
85554: PUSH
85555: LD_VAR 0 2
85559: ADD
85560: PPUSH
85561: CALL_OW 1
85565: ST_TO_ADDR
// end ;
85566: LD_VAR 0 3
85570: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85571: LD_INT 0
85573: PPUSH
// if not mc_bases [ base ] then
85574: LD_EXP 86
85578: PUSH
85579: LD_VAR 0 1
85583: ARRAY
85584: NOT
85585: IFFALSE 85589
// exit ;
85587: GO 85643
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85589: LD_ADDR_EXP 108
85593: PUSH
85594: LD_EXP 108
85598: PPUSH
85599: LD_VAR 0 1
85603: PPUSH
85604: LD_VAR 0 2
85608: PPUSH
85609: CALL_OW 1
85613: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85614: LD_ADDR_EXP 97
85618: PUSH
85619: LD_EXP 97
85623: PPUSH
85624: LD_VAR 0 1
85628: PPUSH
85629: LD_VAR 0 2
85633: PUSH
85634: LD_INT 0
85636: PLUS
85637: PPUSH
85638: CALL_OW 1
85642: ST_TO_ADDR
// end ;
85643: LD_VAR 0 3
85647: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85648: LD_INT 0
85650: PPUSH
// if not mc_bases [ base ] then
85651: LD_EXP 86
85655: PUSH
85656: LD_VAR 0 1
85660: ARRAY
85661: NOT
85662: IFFALSE 85666
// exit ;
85664: GO 85691
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85666: LD_ADDR_EXP 97
85670: PUSH
85671: LD_EXP 97
85675: PPUSH
85676: LD_VAR 0 1
85680: PPUSH
85681: LD_VAR 0 2
85685: PPUSH
85686: CALL_OW 1
85690: ST_TO_ADDR
// end ;
85691: LD_VAR 0 3
85695: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85696: LD_INT 0
85698: PPUSH
85699: PPUSH
85700: PPUSH
85701: PPUSH
// if not mc_bases [ base ] then
85702: LD_EXP 86
85706: PUSH
85707: LD_VAR 0 1
85711: ARRAY
85712: NOT
85713: IFFALSE 85717
// exit ;
85715: GO 85782
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85717: LD_ADDR_EXP 106
85721: PUSH
85722: LD_EXP 106
85726: PPUSH
85727: LD_VAR 0 1
85731: PUSH
85732: LD_EXP 106
85736: PUSH
85737: LD_VAR 0 1
85741: ARRAY
85742: PUSH
85743: LD_INT 1
85745: PLUS
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PPUSH
85751: LD_VAR 0 1
85755: PUSH
85756: LD_VAR 0 2
85760: PUSH
85761: LD_VAR 0 3
85765: PUSH
85766: LD_VAR 0 4
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: PPUSH
85777: CALL 22477 0 3
85781: ST_TO_ADDR
// end ;
85782: LD_VAR 0 5
85786: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85787: LD_INT 0
85789: PPUSH
// if not mc_bases [ base ] then
85790: LD_EXP 86
85794: PUSH
85795: LD_VAR 0 1
85799: ARRAY
85800: NOT
85801: IFFALSE 85805
// exit ;
85803: GO 85830
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85805: LD_ADDR_EXP 123
85809: PUSH
85810: LD_EXP 123
85814: PPUSH
85815: LD_VAR 0 1
85819: PPUSH
85820: LD_VAR 0 2
85824: PPUSH
85825: CALL_OW 1
85829: ST_TO_ADDR
// end ;
85830: LD_VAR 0 3
85834: RET
// export function MC_GetMinesField ( base ) ; begin
85835: LD_INT 0
85837: PPUSH
// result := mc_mines [ base ] ;
85838: LD_ADDR_VAR 0 2
85842: PUSH
85843: LD_EXP 99
85847: PUSH
85848: LD_VAR 0 1
85852: ARRAY
85853: ST_TO_ADDR
// end ;
85854: LD_VAR 0 2
85858: RET
// export function MC_GetProduceList ( base ) ; begin
85859: LD_INT 0
85861: PPUSH
// result := mc_produce [ base ] ;
85862: LD_ADDR_VAR 0 2
85866: PUSH
85867: LD_EXP 107
85871: PUSH
85872: LD_VAR 0 1
85876: ARRAY
85877: ST_TO_ADDR
// end ;
85878: LD_VAR 0 2
85882: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85883: LD_INT 0
85885: PPUSH
85886: PPUSH
// if not mc_bases then
85887: LD_EXP 86
85891: NOT
85892: IFFALSE 85896
// exit ;
85894: GO 85961
// if mc_bases [ base ] then
85896: LD_EXP 86
85900: PUSH
85901: LD_VAR 0 1
85905: ARRAY
85906: IFFALSE 85961
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85908: LD_ADDR_VAR 0 3
85912: PUSH
85913: LD_EXP 86
85917: PUSH
85918: LD_VAR 0 1
85922: ARRAY
85923: PPUSH
85924: LD_INT 30
85926: PUSH
85927: LD_VAR 0 2
85931: PUSH
85932: EMPTY
85933: LIST
85934: LIST
85935: PPUSH
85936: CALL_OW 72
85940: ST_TO_ADDR
// if result then
85941: LD_VAR 0 3
85945: IFFALSE 85961
// result := result [ 1 ] ;
85947: LD_ADDR_VAR 0 3
85951: PUSH
85952: LD_VAR 0 3
85956: PUSH
85957: LD_INT 1
85959: ARRAY
85960: ST_TO_ADDR
// end ; end ;
85961: LD_VAR 0 3
85965: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85966: LD_INT 0
85968: PPUSH
85969: PPUSH
// if not mc_bases then
85970: LD_EXP 86
85974: NOT
85975: IFFALSE 85979
// exit ;
85977: GO 86024
// if mc_bases [ base ] then
85979: LD_EXP 86
85983: PUSH
85984: LD_VAR 0 1
85988: ARRAY
85989: IFFALSE 86024
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85991: LD_ADDR_VAR 0 3
85995: PUSH
85996: LD_EXP 86
86000: PUSH
86001: LD_VAR 0 1
86005: ARRAY
86006: PPUSH
86007: LD_INT 30
86009: PUSH
86010: LD_VAR 0 2
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PPUSH
86019: CALL_OW 72
86023: ST_TO_ADDR
// end ;
86024: LD_VAR 0 3
86028: RET
// export function MC_SetTame ( base , area ) ; begin
86029: LD_INT 0
86031: PPUSH
// if not mc_bases or not base then
86032: LD_EXP 86
86036: NOT
86037: PUSH
86038: LD_VAR 0 1
86042: NOT
86043: OR
86044: IFFALSE 86048
// exit ;
86046: GO 86073
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86048: LD_ADDR_EXP 114
86052: PUSH
86053: LD_EXP 114
86057: PPUSH
86058: LD_VAR 0 1
86062: PPUSH
86063: LD_VAR 0 2
86067: PPUSH
86068: CALL_OW 1
86072: ST_TO_ADDR
// end ;
86073: LD_VAR 0 3
86077: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86078: LD_INT 0
86080: PPUSH
86081: PPUSH
// if not mc_bases or not base then
86082: LD_EXP 86
86086: NOT
86087: PUSH
86088: LD_VAR 0 1
86092: NOT
86093: OR
86094: IFFALSE 86098
// exit ;
86096: GO 86200
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86098: LD_ADDR_VAR 0 4
86102: PUSH
86103: LD_EXP 86
86107: PUSH
86108: LD_VAR 0 1
86112: ARRAY
86113: PPUSH
86114: LD_INT 30
86116: PUSH
86117: LD_VAR 0 2
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PPUSH
86126: CALL_OW 72
86130: ST_TO_ADDR
// if not tmp then
86131: LD_VAR 0 4
86135: NOT
86136: IFFALSE 86140
// exit ;
86138: GO 86200
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86140: LD_ADDR_EXP 118
86144: PUSH
86145: LD_EXP 118
86149: PPUSH
86150: LD_VAR 0 1
86154: PPUSH
86155: LD_EXP 118
86159: PUSH
86160: LD_VAR 0 1
86164: ARRAY
86165: PPUSH
86166: LD_EXP 118
86170: PUSH
86171: LD_VAR 0 1
86175: ARRAY
86176: PUSH
86177: LD_INT 1
86179: PLUS
86180: PPUSH
86181: LD_VAR 0 4
86185: PUSH
86186: LD_INT 1
86188: ARRAY
86189: PPUSH
86190: CALL_OW 2
86194: PPUSH
86195: CALL_OW 1
86199: ST_TO_ADDR
// end ;
86200: LD_VAR 0 3
86204: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86205: LD_INT 0
86207: PPUSH
86208: PPUSH
// if not mc_bases or not base or not kinds then
86209: LD_EXP 86
86213: NOT
86214: PUSH
86215: LD_VAR 0 1
86219: NOT
86220: OR
86221: PUSH
86222: LD_VAR 0 2
86226: NOT
86227: OR
86228: IFFALSE 86232
// exit ;
86230: GO 86293
// for i in kinds do
86232: LD_ADDR_VAR 0 4
86236: PUSH
86237: LD_VAR 0 2
86241: PUSH
86242: FOR_IN
86243: IFFALSE 86291
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86245: LD_ADDR_EXP 120
86249: PUSH
86250: LD_EXP 120
86254: PPUSH
86255: LD_VAR 0 1
86259: PUSH
86260: LD_EXP 120
86264: PUSH
86265: LD_VAR 0 1
86269: ARRAY
86270: PUSH
86271: LD_INT 1
86273: PLUS
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PPUSH
86279: LD_VAR 0 4
86283: PPUSH
86284: CALL 22477 0 3
86288: ST_TO_ADDR
86289: GO 86242
86291: POP
86292: POP
// end ;
86293: LD_VAR 0 3
86297: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86298: LD_INT 0
86300: PPUSH
// if not mc_bases or not base or not areas then
86301: LD_EXP 86
86305: NOT
86306: PUSH
86307: LD_VAR 0 1
86311: NOT
86312: OR
86313: PUSH
86314: LD_VAR 0 2
86318: NOT
86319: OR
86320: IFFALSE 86324
// exit ;
86322: GO 86349
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86324: LD_ADDR_EXP 104
86328: PUSH
86329: LD_EXP 104
86333: PPUSH
86334: LD_VAR 0 1
86338: PPUSH
86339: LD_VAR 0 2
86343: PPUSH
86344: CALL_OW 1
86348: ST_TO_ADDR
// end ;
86349: LD_VAR 0 3
86353: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86354: LD_INT 0
86356: PPUSH
// if not mc_bases or not base or not teleports_exit then
86357: LD_EXP 86
86361: NOT
86362: PUSH
86363: LD_VAR 0 1
86367: NOT
86368: OR
86369: PUSH
86370: LD_VAR 0 2
86374: NOT
86375: OR
86376: IFFALSE 86380
// exit ;
86378: GO 86405
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86380: LD_ADDR_EXP 121
86384: PUSH
86385: LD_EXP 121
86389: PPUSH
86390: LD_VAR 0 1
86394: PPUSH
86395: LD_VAR 0 2
86399: PPUSH
86400: CALL_OW 1
86404: ST_TO_ADDR
// end ;
86405: LD_VAR 0 3
86409: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86410: LD_INT 0
86412: PPUSH
86413: PPUSH
86414: PPUSH
// if not mc_bases or not base or not ext_list then
86415: LD_EXP 86
86419: NOT
86420: PUSH
86421: LD_VAR 0 1
86425: NOT
86426: OR
86427: PUSH
86428: LD_VAR 0 5
86432: NOT
86433: OR
86434: IFFALSE 86438
// exit ;
86436: GO 86611
// tmp := GetFacExtXYD ( x , y , d ) ;
86438: LD_ADDR_VAR 0 8
86442: PUSH
86443: LD_VAR 0 2
86447: PPUSH
86448: LD_VAR 0 3
86452: PPUSH
86453: LD_VAR 0 4
86457: PPUSH
86458: CALL 51156 0 3
86462: ST_TO_ADDR
// if not tmp then
86463: LD_VAR 0 8
86467: NOT
86468: IFFALSE 86472
// exit ;
86470: GO 86611
// for i in tmp do
86472: LD_ADDR_VAR 0 7
86476: PUSH
86477: LD_VAR 0 8
86481: PUSH
86482: FOR_IN
86483: IFFALSE 86609
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86485: LD_ADDR_EXP 91
86489: PUSH
86490: LD_EXP 91
86494: PPUSH
86495: LD_VAR 0 1
86499: PPUSH
86500: LD_EXP 91
86504: PUSH
86505: LD_VAR 0 1
86509: ARRAY
86510: PPUSH
86511: LD_EXP 91
86515: PUSH
86516: LD_VAR 0 1
86520: ARRAY
86521: PUSH
86522: LD_INT 1
86524: PLUS
86525: PPUSH
86526: LD_VAR 0 5
86530: PUSH
86531: LD_INT 1
86533: ARRAY
86534: PUSH
86535: LD_VAR 0 7
86539: PUSH
86540: LD_INT 1
86542: ARRAY
86543: PUSH
86544: LD_VAR 0 7
86548: PUSH
86549: LD_INT 2
86551: ARRAY
86552: PUSH
86553: LD_VAR 0 7
86557: PUSH
86558: LD_INT 3
86560: ARRAY
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: PPUSH
86568: CALL_OW 2
86572: PPUSH
86573: CALL_OW 1
86577: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86578: LD_ADDR_VAR 0 5
86582: PUSH
86583: LD_VAR 0 5
86587: PPUSH
86588: LD_INT 1
86590: PPUSH
86591: CALL_OW 3
86595: ST_TO_ADDR
// if not ext_list then
86596: LD_VAR 0 5
86600: NOT
86601: IFFALSE 86607
// exit ;
86603: POP
86604: POP
86605: GO 86611
// end ;
86607: GO 86482
86609: POP
86610: POP
// end ;
86611: LD_VAR 0 6
86615: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86616: LD_INT 0
86618: PPUSH
// if not mc_bases or not base or not weapon_list then
86619: LD_EXP 86
86623: NOT
86624: PUSH
86625: LD_VAR 0 1
86629: NOT
86630: OR
86631: PUSH
86632: LD_VAR 0 2
86636: NOT
86637: OR
86638: IFFALSE 86642
// exit ;
86640: GO 86667
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86642: LD_ADDR_EXP 125
86646: PUSH
86647: LD_EXP 125
86651: PPUSH
86652: LD_VAR 0 1
86656: PPUSH
86657: LD_VAR 0 2
86661: PPUSH
86662: CALL_OW 1
86666: ST_TO_ADDR
// end ;
86667: LD_VAR 0 3
86671: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86672: LD_INT 0
86674: PPUSH
// if not mc_bases or not base or not tech_list then
86675: LD_EXP 86
86679: NOT
86680: PUSH
86681: LD_VAR 0 1
86685: NOT
86686: OR
86687: PUSH
86688: LD_VAR 0 2
86692: NOT
86693: OR
86694: IFFALSE 86698
// exit ;
86696: GO 86723
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86698: LD_ADDR_EXP 113
86702: PUSH
86703: LD_EXP 113
86707: PPUSH
86708: LD_VAR 0 1
86712: PPUSH
86713: LD_VAR 0 2
86717: PPUSH
86718: CALL_OW 1
86722: ST_TO_ADDR
// end ;
86723: LD_VAR 0 3
86727: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86728: LD_INT 0
86730: PPUSH
// if not mc_bases or not parking_area or not base then
86731: LD_EXP 86
86735: NOT
86736: PUSH
86737: LD_VAR 0 2
86741: NOT
86742: OR
86743: PUSH
86744: LD_VAR 0 1
86748: NOT
86749: OR
86750: IFFALSE 86754
// exit ;
86752: GO 86779
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86754: LD_ADDR_EXP 110
86758: PUSH
86759: LD_EXP 110
86763: PPUSH
86764: LD_VAR 0 1
86768: PPUSH
86769: LD_VAR 0 2
86773: PPUSH
86774: CALL_OW 1
86778: ST_TO_ADDR
// end ;
86779: LD_VAR 0 3
86783: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86784: LD_INT 0
86786: PPUSH
// if not mc_bases or not base or not scan_area then
86787: LD_EXP 86
86791: NOT
86792: PUSH
86793: LD_VAR 0 1
86797: NOT
86798: OR
86799: PUSH
86800: LD_VAR 0 2
86804: NOT
86805: OR
86806: IFFALSE 86810
// exit ;
86808: GO 86835
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86810: LD_ADDR_EXP 111
86814: PUSH
86815: LD_EXP 111
86819: PPUSH
86820: LD_VAR 0 1
86824: PPUSH
86825: LD_VAR 0 2
86829: PPUSH
86830: CALL_OW 1
86834: ST_TO_ADDR
// end ;
86835: LD_VAR 0 3
86839: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86840: LD_INT 0
86842: PPUSH
86843: PPUSH
// if not mc_bases or not base then
86844: LD_EXP 86
86848: NOT
86849: PUSH
86850: LD_VAR 0 1
86854: NOT
86855: OR
86856: IFFALSE 86860
// exit ;
86858: GO 86924
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86860: LD_ADDR_VAR 0 3
86864: PUSH
86865: LD_INT 1
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 3
86873: PUSH
86874: LD_INT 4
86876: PUSH
86877: LD_INT 11
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86887: LD_ADDR_EXP 113
86891: PUSH
86892: LD_EXP 113
86896: PPUSH
86897: LD_VAR 0 1
86901: PPUSH
86902: LD_EXP 113
86906: PUSH
86907: LD_VAR 0 1
86911: ARRAY
86912: PUSH
86913: LD_VAR 0 3
86917: DIFF
86918: PPUSH
86919: CALL_OW 1
86923: ST_TO_ADDR
// end ;
86924: LD_VAR 0 2
86928: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86929: LD_INT 0
86931: PPUSH
// result := mc_vehicles [ base ] ;
86932: LD_ADDR_VAR 0 3
86936: PUSH
86937: LD_EXP 105
86941: PUSH
86942: LD_VAR 0 1
86946: ARRAY
86947: ST_TO_ADDR
// if onlyCombat then
86948: LD_VAR 0 2
86952: IFFALSE 87130
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86954: LD_ADDR_VAR 0 3
86958: PUSH
86959: LD_VAR 0 3
86963: PUSH
86964: LD_VAR 0 3
86968: PPUSH
86969: LD_INT 2
86971: PUSH
86972: LD_INT 34
86974: PUSH
86975: LD_INT 12
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: PUSH
86982: LD_INT 34
86984: PUSH
86985: LD_INT 51
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 34
86994: PUSH
86995: LD_EXP 2
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 34
87006: PUSH
87007: LD_INT 32
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 34
87016: PUSH
87017: LD_INT 13
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 34
87026: PUSH
87027: LD_INT 52
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 34
87036: PUSH
87037: LD_EXP 7
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 34
87048: PUSH
87049: LD_INT 14
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 34
87058: PUSH
87059: LD_INT 53
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 34
87068: PUSH
87069: LD_EXP 1
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 34
87080: PUSH
87081: LD_INT 31
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 34
87090: PUSH
87091: LD_INT 48
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 34
87100: PUSH
87101: LD_INT 8
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: PPUSH
87124: CALL_OW 72
87128: DIFF
87129: ST_TO_ADDR
// end ; end_of_file
87130: LD_VAR 0 3
87134: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87135: LD_INT 0
87137: PPUSH
87138: PPUSH
87139: PPUSH
// if not mc_bases or not skirmish then
87140: LD_EXP 86
87144: NOT
87145: PUSH
87146: LD_EXP 84
87150: NOT
87151: OR
87152: IFFALSE 87156
// exit ;
87154: GO 87321
// for i = 1 to mc_bases do
87156: LD_ADDR_VAR 0 4
87160: PUSH
87161: DOUBLE
87162: LD_INT 1
87164: DEC
87165: ST_TO_ADDR
87166: LD_EXP 86
87170: PUSH
87171: FOR_TO
87172: IFFALSE 87319
// begin if sci in mc_bases [ i ] then
87174: LD_VAR 0 2
87178: PUSH
87179: LD_EXP 86
87183: PUSH
87184: LD_VAR 0 4
87188: ARRAY
87189: IN
87190: IFFALSE 87317
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87192: LD_ADDR_EXP 115
87196: PUSH
87197: LD_EXP 115
87201: PPUSH
87202: LD_VAR 0 4
87206: PUSH
87207: LD_EXP 115
87211: PUSH
87212: LD_VAR 0 4
87216: ARRAY
87217: PUSH
87218: LD_INT 1
87220: PLUS
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PPUSH
87226: LD_VAR 0 1
87230: PPUSH
87231: CALL 22477 0 3
87235: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87236: LD_ADDR_VAR 0 5
87240: PUSH
87241: LD_EXP 86
87245: PUSH
87246: LD_VAR 0 4
87250: ARRAY
87251: PPUSH
87252: LD_INT 2
87254: PUSH
87255: LD_INT 30
87257: PUSH
87258: LD_INT 0
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 30
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: LIST
87279: PPUSH
87280: CALL_OW 72
87284: PPUSH
87285: LD_VAR 0 1
87289: PPUSH
87290: CALL_OW 74
87294: ST_TO_ADDR
// if tmp then
87295: LD_VAR 0 5
87299: IFFALSE 87315
// ComStandNearbyBuilding ( ape , tmp ) ;
87301: LD_VAR 0 1
87305: PPUSH
87306: LD_VAR 0 5
87310: PPUSH
87311: CALL 19091 0 2
// break ;
87315: GO 87319
// end ; end ;
87317: GO 87171
87319: POP
87320: POP
// end ;
87321: LD_VAR 0 3
87325: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87326: LD_INT 0
87328: PPUSH
87329: PPUSH
87330: PPUSH
// if not mc_bases or not skirmish then
87331: LD_EXP 86
87335: NOT
87336: PUSH
87337: LD_EXP 84
87341: NOT
87342: OR
87343: IFFALSE 87347
// exit ;
87345: GO 87436
// for i = 1 to mc_bases do
87347: LD_ADDR_VAR 0 4
87351: PUSH
87352: DOUBLE
87353: LD_INT 1
87355: DEC
87356: ST_TO_ADDR
87357: LD_EXP 86
87361: PUSH
87362: FOR_TO
87363: IFFALSE 87434
// begin if building in mc_busy_turret_list [ i ] then
87365: LD_VAR 0 1
87369: PUSH
87370: LD_EXP 96
87374: PUSH
87375: LD_VAR 0 4
87379: ARRAY
87380: IN
87381: IFFALSE 87432
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87383: LD_ADDR_VAR 0 5
87387: PUSH
87388: LD_EXP 96
87392: PUSH
87393: LD_VAR 0 4
87397: ARRAY
87398: PUSH
87399: LD_VAR 0 1
87403: DIFF
87404: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87405: LD_ADDR_EXP 96
87409: PUSH
87410: LD_EXP 96
87414: PPUSH
87415: LD_VAR 0 4
87419: PPUSH
87420: LD_VAR 0 5
87424: PPUSH
87425: CALL_OW 1
87429: ST_TO_ADDR
// break ;
87430: GO 87434
// end ; end ;
87432: GO 87362
87434: POP
87435: POP
// end ;
87436: LD_VAR 0 3
87440: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87441: LD_INT 0
87443: PPUSH
87444: PPUSH
87445: PPUSH
// if not mc_bases or not skirmish then
87446: LD_EXP 86
87450: NOT
87451: PUSH
87452: LD_EXP 84
87456: NOT
87457: OR
87458: IFFALSE 87462
// exit ;
87460: GO 87661
// for i = 1 to mc_bases do
87462: LD_ADDR_VAR 0 5
87466: PUSH
87467: DOUBLE
87468: LD_INT 1
87470: DEC
87471: ST_TO_ADDR
87472: LD_EXP 86
87476: PUSH
87477: FOR_TO
87478: IFFALSE 87659
// if building in mc_bases [ i ] then
87480: LD_VAR 0 1
87484: PUSH
87485: LD_EXP 86
87489: PUSH
87490: LD_VAR 0 5
87494: ARRAY
87495: IN
87496: IFFALSE 87657
// begin tmp := mc_bases [ i ] diff building ;
87498: LD_ADDR_VAR 0 6
87502: PUSH
87503: LD_EXP 86
87507: PUSH
87508: LD_VAR 0 5
87512: ARRAY
87513: PUSH
87514: LD_VAR 0 1
87518: DIFF
87519: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87520: LD_ADDR_EXP 86
87524: PUSH
87525: LD_EXP 86
87529: PPUSH
87530: LD_VAR 0 5
87534: PPUSH
87535: LD_VAR 0 6
87539: PPUSH
87540: CALL_OW 1
87544: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87545: LD_VAR 0 1
87549: PUSH
87550: LD_EXP 94
87554: PUSH
87555: LD_VAR 0 5
87559: ARRAY
87560: IN
87561: IFFALSE 87600
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87563: LD_ADDR_EXP 94
87567: PUSH
87568: LD_EXP 94
87572: PPUSH
87573: LD_VAR 0 5
87577: PPUSH
87578: LD_EXP 94
87582: PUSH
87583: LD_VAR 0 5
87587: ARRAY
87588: PUSH
87589: LD_VAR 0 1
87593: DIFF
87594: PPUSH
87595: CALL_OW 1
87599: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87600: LD_VAR 0 1
87604: PUSH
87605: LD_EXP 95
87609: PUSH
87610: LD_VAR 0 5
87614: ARRAY
87615: IN
87616: IFFALSE 87655
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87618: LD_ADDR_EXP 95
87622: PUSH
87623: LD_EXP 95
87627: PPUSH
87628: LD_VAR 0 5
87632: PPUSH
87633: LD_EXP 95
87637: PUSH
87638: LD_VAR 0 5
87642: ARRAY
87643: PUSH
87644: LD_VAR 0 1
87648: DIFF
87649: PPUSH
87650: CALL_OW 1
87654: ST_TO_ADDR
// break ;
87655: GO 87659
// end ;
87657: GO 87477
87659: POP
87660: POP
// end ;
87661: LD_VAR 0 4
87665: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87666: LD_INT 0
87668: PPUSH
87669: PPUSH
87670: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87671: LD_EXP 86
87675: NOT
87676: PUSH
87677: LD_EXP 84
87681: NOT
87682: OR
87683: PUSH
87684: LD_VAR 0 3
87688: PUSH
87689: LD_EXP 112
87693: IN
87694: NOT
87695: OR
87696: IFFALSE 87700
// exit ;
87698: GO 87823
// for i = 1 to mc_vehicles do
87700: LD_ADDR_VAR 0 6
87704: PUSH
87705: DOUBLE
87706: LD_INT 1
87708: DEC
87709: ST_TO_ADDR
87710: LD_EXP 105
87714: PUSH
87715: FOR_TO
87716: IFFALSE 87821
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87718: LD_VAR 0 2
87722: PUSH
87723: LD_EXP 105
87727: PUSH
87728: LD_VAR 0 6
87732: ARRAY
87733: IN
87734: PUSH
87735: LD_VAR 0 1
87739: PUSH
87740: LD_EXP 105
87744: PUSH
87745: LD_VAR 0 6
87749: ARRAY
87750: IN
87751: OR
87752: IFFALSE 87819
// begin tmp := mc_vehicles [ i ] diff old ;
87754: LD_ADDR_VAR 0 7
87758: PUSH
87759: LD_EXP 105
87763: PUSH
87764: LD_VAR 0 6
87768: ARRAY
87769: PUSH
87770: LD_VAR 0 2
87774: DIFF
87775: ST_TO_ADDR
// tmp := tmp diff new ;
87776: LD_ADDR_VAR 0 7
87780: PUSH
87781: LD_VAR 0 7
87785: PUSH
87786: LD_VAR 0 1
87790: DIFF
87791: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87792: LD_ADDR_EXP 105
87796: PUSH
87797: LD_EXP 105
87801: PPUSH
87802: LD_VAR 0 6
87806: PPUSH
87807: LD_VAR 0 7
87811: PPUSH
87812: CALL_OW 1
87816: ST_TO_ADDR
// break ;
87817: GO 87821
// end ;
87819: GO 87715
87821: POP
87822: POP
// end ;
87823: LD_VAR 0 5
87827: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87828: LD_INT 0
87830: PPUSH
87831: PPUSH
87832: PPUSH
87833: PPUSH
// if not mc_bases or not skirmish then
87834: LD_EXP 86
87838: NOT
87839: PUSH
87840: LD_EXP 84
87844: NOT
87845: OR
87846: IFFALSE 87850
// exit ;
87848: GO 88233
// side := GetSide ( vehicle ) ;
87850: LD_ADDR_VAR 0 5
87854: PUSH
87855: LD_VAR 0 1
87859: PPUSH
87860: CALL_OW 255
87864: ST_TO_ADDR
// for i = 1 to mc_bases do
87865: LD_ADDR_VAR 0 4
87869: PUSH
87870: DOUBLE
87871: LD_INT 1
87873: DEC
87874: ST_TO_ADDR
87875: LD_EXP 86
87879: PUSH
87880: FOR_TO
87881: IFFALSE 88231
// begin if factory in mc_bases [ i ] then
87883: LD_VAR 0 2
87887: PUSH
87888: LD_EXP 86
87892: PUSH
87893: LD_VAR 0 4
87897: ARRAY
87898: IN
87899: IFFALSE 88229
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87901: LD_EXP 108
87905: PUSH
87906: LD_VAR 0 4
87910: ARRAY
87911: PUSH
87912: LD_EXP 97
87916: PUSH
87917: LD_VAR 0 4
87921: ARRAY
87922: LESS
87923: PUSH
87924: LD_VAR 0 1
87928: PPUSH
87929: CALL_OW 264
87933: PUSH
87934: LD_INT 31
87936: PUSH
87937: LD_INT 32
87939: PUSH
87940: LD_INT 51
87942: PUSH
87943: LD_EXP 2
87947: PUSH
87948: LD_INT 12
87950: PUSH
87951: LD_INT 30
87953: PUSH
87954: LD_EXP 1
87958: PUSH
87959: LD_INT 11
87961: PUSH
87962: LD_INT 53
87964: PUSH
87965: LD_INT 14
87967: PUSH
87968: LD_EXP 5
87972: PUSH
87973: LD_INT 29
87975: PUSH
87976: LD_EXP 3
87980: PUSH
87981: LD_INT 13
87983: PUSH
87984: LD_INT 52
87986: PUSH
87987: LD_EXP 7
87991: PUSH
87992: LD_INT 48
87994: PUSH
87995: LD_INT 8
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: IN
88018: NOT
88019: AND
88020: IFFALSE 88068
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88022: LD_ADDR_EXP 108
88026: PUSH
88027: LD_EXP 108
88031: PPUSH
88032: LD_VAR 0 4
88036: PUSH
88037: LD_EXP 108
88041: PUSH
88042: LD_VAR 0 4
88046: ARRAY
88047: PUSH
88048: LD_INT 1
88050: PLUS
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PPUSH
88056: LD_VAR 0 1
88060: PPUSH
88061: CALL 22477 0 3
88065: ST_TO_ADDR
88066: GO 88112
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88068: LD_ADDR_EXP 105
88072: PUSH
88073: LD_EXP 105
88077: PPUSH
88078: LD_VAR 0 4
88082: PUSH
88083: LD_EXP 105
88087: PUSH
88088: LD_VAR 0 4
88092: ARRAY
88093: PUSH
88094: LD_INT 1
88096: PLUS
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PPUSH
88102: LD_VAR 0 1
88106: PPUSH
88107: CALL 22477 0 3
88111: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88112: LD_VAR 0 1
88116: PPUSH
88117: CALL_OW 263
88121: PUSH
88122: LD_INT 2
88124: EQUAL
88125: IFFALSE 88145
// begin repeat wait ( 0 0$1 ) ;
88127: LD_INT 35
88129: PPUSH
88130: CALL_OW 67
// until IsControledBy ( vehicle ) ;
88134: LD_VAR 0 1
88138: PPUSH
88139: CALL_OW 312
88143: IFFALSE 88127
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88145: LD_VAR 0 1
88149: PPUSH
88150: LD_EXP 110
88154: PUSH
88155: LD_VAR 0 4
88159: ARRAY
88160: PPUSH
88161: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88165: LD_VAR 0 1
88169: PPUSH
88170: CALL_OW 263
88174: PUSH
88175: LD_INT 1
88177: NONEQUAL
88178: IFFALSE 88182
// break ;
88180: GO 88231
// repeat wait ( 0 0$1 ) ;
88182: LD_INT 35
88184: PPUSH
88185: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88189: LD_VAR 0 1
88193: PPUSH
88194: LD_EXP 110
88198: PUSH
88199: LD_VAR 0 4
88203: ARRAY
88204: PPUSH
88205: CALL_OW 308
88209: IFFALSE 88182
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88211: LD_VAR 0 1
88215: PPUSH
88216: CALL_OW 311
88220: PPUSH
88221: CALL_OW 121
// exit ;
88225: POP
88226: POP
88227: GO 88233
// end ; end ;
88229: GO 87880
88231: POP
88232: POP
// end ;
88233: LD_VAR 0 3
88237: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88238: LD_INT 0
88240: PPUSH
88241: PPUSH
88242: PPUSH
88243: PPUSH
// if not mc_bases or not skirmish then
88244: LD_EXP 86
88248: NOT
88249: PUSH
88250: LD_EXP 84
88254: NOT
88255: OR
88256: IFFALSE 88260
// exit ;
88258: GO 88613
// repeat wait ( 0 0$1 ) ;
88260: LD_INT 35
88262: PPUSH
88263: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88267: LD_VAR 0 2
88271: PPUSH
88272: LD_VAR 0 3
88276: PPUSH
88277: CALL_OW 284
88281: IFFALSE 88260
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88283: LD_VAR 0 2
88287: PPUSH
88288: LD_VAR 0 3
88292: PPUSH
88293: CALL_OW 283
88297: PUSH
88298: LD_INT 4
88300: EQUAL
88301: IFFALSE 88305
// exit ;
88303: GO 88613
// for i = 1 to mc_bases do
88305: LD_ADDR_VAR 0 7
88309: PUSH
88310: DOUBLE
88311: LD_INT 1
88313: DEC
88314: ST_TO_ADDR
88315: LD_EXP 86
88319: PUSH
88320: FOR_TO
88321: IFFALSE 88611
// begin if mc_crates_area [ i ] then
88323: LD_EXP 104
88327: PUSH
88328: LD_VAR 0 7
88332: ARRAY
88333: IFFALSE 88444
// for j in mc_crates_area [ i ] do
88335: LD_ADDR_VAR 0 8
88339: PUSH
88340: LD_EXP 104
88344: PUSH
88345: LD_VAR 0 7
88349: ARRAY
88350: PUSH
88351: FOR_IN
88352: IFFALSE 88442
// if InArea ( x , y , j ) then
88354: LD_VAR 0 2
88358: PPUSH
88359: LD_VAR 0 3
88363: PPUSH
88364: LD_VAR 0 8
88368: PPUSH
88369: CALL_OW 309
88373: IFFALSE 88440
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88375: LD_ADDR_EXP 102
88379: PUSH
88380: LD_EXP 102
88384: PPUSH
88385: LD_VAR 0 7
88389: PUSH
88390: LD_EXP 102
88394: PUSH
88395: LD_VAR 0 7
88399: ARRAY
88400: PUSH
88401: LD_INT 1
88403: PLUS
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PPUSH
88409: LD_VAR 0 4
88413: PUSH
88414: LD_VAR 0 2
88418: PUSH
88419: LD_VAR 0 3
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: LIST
88428: PPUSH
88429: CALL 22477 0 3
88433: ST_TO_ADDR
// exit ;
88434: POP
88435: POP
88436: POP
88437: POP
88438: GO 88613
// end ;
88440: GO 88351
88442: POP
88443: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88444: LD_ADDR_VAR 0 9
88448: PUSH
88449: LD_EXP 86
88453: PUSH
88454: LD_VAR 0 7
88458: ARRAY
88459: PPUSH
88460: LD_INT 2
88462: PUSH
88463: LD_INT 30
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 30
88475: PUSH
88476: LD_INT 1
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: LIST
88487: PPUSH
88488: CALL_OW 72
88492: ST_TO_ADDR
// if not depot then
88493: LD_VAR 0 9
88497: NOT
88498: IFFALSE 88502
// continue ;
88500: GO 88320
// for j in depot do
88502: LD_ADDR_VAR 0 8
88506: PUSH
88507: LD_VAR 0 9
88511: PUSH
88512: FOR_IN
88513: IFFALSE 88607
// if GetDistUnitXY ( j , x , y ) < 30 then
88515: LD_VAR 0 8
88519: PPUSH
88520: LD_VAR 0 2
88524: PPUSH
88525: LD_VAR 0 3
88529: PPUSH
88530: CALL_OW 297
88534: PUSH
88535: LD_INT 30
88537: LESS
88538: IFFALSE 88605
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88540: LD_ADDR_EXP 102
88544: PUSH
88545: LD_EXP 102
88549: PPUSH
88550: LD_VAR 0 7
88554: PUSH
88555: LD_EXP 102
88559: PUSH
88560: LD_VAR 0 7
88564: ARRAY
88565: PUSH
88566: LD_INT 1
88568: PLUS
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PPUSH
88574: LD_VAR 0 4
88578: PUSH
88579: LD_VAR 0 2
88583: PUSH
88584: LD_VAR 0 3
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: LIST
88593: PPUSH
88594: CALL 22477 0 3
88598: ST_TO_ADDR
// exit ;
88599: POP
88600: POP
88601: POP
88602: POP
88603: GO 88613
// end ;
88605: GO 88512
88607: POP
88608: POP
// end ;
88609: GO 88320
88611: POP
88612: POP
// end ;
88613: LD_VAR 0 6
88617: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88618: LD_INT 0
88620: PPUSH
88621: PPUSH
88622: PPUSH
88623: PPUSH
// if not mc_bases or not skirmish then
88624: LD_EXP 86
88628: NOT
88629: PUSH
88630: LD_EXP 84
88634: NOT
88635: OR
88636: IFFALSE 88640
// exit ;
88638: GO 88917
// side := GetSide ( lab ) ;
88640: LD_ADDR_VAR 0 4
88644: PUSH
88645: LD_VAR 0 2
88649: PPUSH
88650: CALL_OW 255
88654: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88655: LD_VAR 0 4
88659: PUSH
88660: LD_EXP 112
88664: IN
88665: NOT
88666: PUSH
88667: LD_EXP 113
88671: NOT
88672: OR
88673: PUSH
88674: LD_EXP 86
88678: NOT
88679: OR
88680: IFFALSE 88684
// exit ;
88682: GO 88917
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88684: LD_ADDR_EXP 113
88688: PUSH
88689: LD_EXP 113
88693: PPUSH
88694: LD_VAR 0 4
88698: PPUSH
88699: LD_EXP 113
88703: PUSH
88704: LD_VAR 0 4
88708: ARRAY
88709: PUSH
88710: LD_VAR 0 1
88714: DIFF
88715: PPUSH
88716: CALL_OW 1
88720: ST_TO_ADDR
// for i = 1 to mc_bases do
88721: LD_ADDR_VAR 0 5
88725: PUSH
88726: DOUBLE
88727: LD_INT 1
88729: DEC
88730: ST_TO_ADDR
88731: LD_EXP 86
88735: PUSH
88736: FOR_TO
88737: IFFALSE 88915
// begin if lab in mc_bases [ i ] then
88739: LD_VAR 0 2
88743: PUSH
88744: LD_EXP 86
88748: PUSH
88749: LD_VAR 0 5
88753: ARRAY
88754: IN
88755: IFFALSE 88913
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88757: LD_VAR 0 1
88761: PUSH
88762: LD_INT 11
88764: PUSH
88765: LD_INT 4
88767: PUSH
88768: LD_INT 3
88770: PUSH
88771: LD_INT 2
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: IN
88780: PUSH
88781: LD_EXP 116
88785: PUSH
88786: LD_VAR 0 5
88790: ARRAY
88791: AND
88792: IFFALSE 88913
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88794: LD_ADDR_VAR 0 6
88798: PUSH
88799: LD_EXP 116
88803: PUSH
88804: LD_VAR 0 5
88808: ARRAY
88809: PUSH
88810: LD_INT 1
88812: ARRAY
88813: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88814: LD_ADDR_EXP 116
88818: PUSH
88819: LD_EXP 116
88823: PPUSH
88824: LD_VAR 0 5
88828: PPUSH
88829: EMPTY
88830: PPUSH
88831: CALL_OW 1
88835: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88836: LD_VAR 0 6
88840: PPUSH
88841: LD_INT 0
88843: PPUSH
88844: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88848: LD_VAR 0 6
88852: PPUSH
88853: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88857: LD_ADDR_EXP 115
88861: PUSH
88862: LD_EXP 115
88866: PPUSH
88867: LD_VAR 0 5
88871: PPUSH
88872: LD_EXP 115
88876: PUSH
88877: LD_VAR 0 5
88881: ARRAY
88882: PPUSH
88883: LD_INT 1
88885: PPUSH
88886: LD_VAR 0 6
88890: PPUSH
88891: CALL_OW 2
88895: PPUSH
88896: CALL_OW 1
88900: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88901: LD_VAR 0 5
88905: PPUSH
88906: LD_INT 112
88908: PPUSH
88909: CALL 65862 0 2
// end ; end ; end ;
88913: GO 88736
88915: POP
88916: POP
// end ;
88917: LD_VAR 0 3
88921: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88922: LD_INT 0
88924: PPUSH
88925: PPUSH
88926: PPUSH
88927: PPUSH
88928: PPUSH
88929: PPUSH
88930: PPUSH
88931: PPUSH
// if not mc_bases or not skirmish then
88932: LD_EXP 86
88936: NOT
88937: PUSH
88938: LD_EXP 84
88942: NOT
88943: OR
88944: IFFALSE 88948
// exit ;
88946: GO 90319
// for i = 1 to mc_bases do
88948: LD_ADDR_VAR 0 3
88952: PUSH
88953: DOUBLE
88954: LD_INT 1
88956: DEC
88957: ST_TO_ADDR
88958: LD_EXP 86
88962: PUSH
88963: FOR_TO
88964: IFFALSE 90317
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88966: LD_VAR 0 1
88970: PUSH
88971: LD_EXP 86
88975: PUSH
88976: LD_VAR 0 3
88980: ARRAY
88981: IN
88982: PUSH
88983: LD_VAR 0 1
88987: PUSH
88988: LD_EXP 93
88992: PUSH
88993: LD_VAR 0 3
88997: ARRAY
88998: IN
88999: OR
89000: PUSH
89001: LD_VAR 0 1
89005: PUSH
89006: LD_EXP 108
89010: PUSH
89011: LD_VAR 0 3
89015: ARRAY
89016: IN
89017: OR
89018: PUSH
89019: LD_VAR 0 1
89023: PUSH
89024: LD_EXP 105
89028: PUSH
89029: LD_VAR 0 3
89033: ARRAY
89034: IN
89035: OR
89036: PUSH
89037: LD_VAR 0 1
89041: PUSH
89042: LD_EXP 115
89046: PUSH
89047: LD_VAR 0 3
89051: ARRAY
89052: IN
89053: OR
89054: PUSH
89055: LD_VAR 0 1
89059: PUSH
89060: LD_EXP 116
89064: PUSH
89065: LD_VAR 0 3
89069: ARRAY
89070: IN
89071: OR
89072: IFFALSE 90315
// begin if un in mc_ape [ i ] then
89074: LD_VAR 0 1
89078: PUSH
89079: LD_EXP 115
89083: PUSH
89084: LD_VAR 0 3
89088: ARRAY
89089: IN
89090: IFFALSE 89129
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89092: LD_ADDR_EXP 115
89096: PUSH
89097: LD_EXP 115
89101: PPUSH
89102: LD_VAR 0 3
89106: PPUSH
89107: LD_EXP 115
89111: PUSH
89112: LD_VAR 0 3
89116: ARRAY
89117: PUSH
89118: LD_VAR 0 1
89122: DIFF
89123: PPUSH
89124: CALL_OW 1
89128: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89129: LD_VAR 0 1
89133: PUSH
89134: LD_EXP 116
89138: PUSH
89139: LD_VAR 0 3
89143: ARRAY
89144: IN
89145: IFFALSE 89169
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89147: LD_ADDR_EXP 116
89151: PUSH
89152: LD_EXP 116
89156: PPUSH
89157: LD_VAR 0 3
89161: PPUSH
89162: EMPTY
89163: PPUSH
89164: CALL_OW 1
89168: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89169: LD_VAR 0 1
89173: PPUSH
89174: CALL_OW 247
89178: PUSH
89179: LD_INT 2
89181: EQUAL
89182: PUSH
89183: LD_VAR 0 1
89187: PPUSH
89188: CALL_OW 110
89192: PUSH
89193: LD_INT 20
89195: EQUAL
89196: PUSH
89197: LD_VAR 0 1
89201: PUSH
89202: LD_EXP 108
89206: PUSH
89207: LD_VAR 0 3
89211: ARRAY
89212: IN
89213: OR
89214: PUSH
89215: LD_VAR 0 1
89219: PPUSH
89220: CALL_OW 264
89224: PUSH
89225: LD_INT 12
89227: PUSH
89228: LD_INT 51
89230: PUSH
89231: LD_EXP 2
89235: PUSH
89236: LD_INT 32
89238: PUSH
89239: LD_INT 13
89241: PUSH
89242: LD_INT 52
89244: PUSH
89245: LD_INT 31
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: IN
89257: OR
89258: AND
89259: IFFALSE 89567
// begin if un in mc_defender [ i ] then
89261: LD_VAR 0 1
89265: PUSH
89266: LD_EXP 108
89270: PUSH
89271: LD_VAR 0 3
89275: ARRAY
89276: IN
89277: IFFALSE 89316
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89279: LD_ADDR_EXP 108
89283: PUSH
89284: LD_EXP 108
89288: PPUSH
89289: LD_VAR 0 3
89293: PPUSH
89294: LD_EXP 108
89298: PUSH
89299: LD_VAR 0 3
89303: ARRAY
89304: PUSH
89305: LD_VAR 0 1
89309: DIFF
89310: PPUSH
89311: CALL_OW 1
89315: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89316: LD_ADDR_VAR 0 8
89320: PUSH
89321: LD_VAR 0 3
89325: PPUSH
89326: LD_INT 3
89328: PPUSH
89329: CALL 85966 0 2
89333: ST_TO_ADDR
// if fac then
89334: LD_VAR 0 8
89338: IFFALSE 89567
// begin for j in fac do
89340: LD_ADDR_VAR 0 4
89344: PUSH
89345: LD_VAR 0 8
89349: PUSH
89350: FOR_IN
89351: IFFALSE 89565
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89353: LD_ADDR_VAR 0 9
89357: PUSH
89358: LD_VAR 0 8
89362: PPUSH
89363: LD_VAR 0 1
89367: PPUSH
89368: CALL_OW 265
89372: PPUSH
89373: LD_VAR 0 1
89377: PPUSH
89378: CALL_OW 262
89382: PPUSH
89383: LD_VAR 0 1
89387: PPUSH
89388: CALL_OW 263
89392: PPUSH
89393: LD_VAR 0 1
89397: PPUSH
89398: CALL_OW 264
89402: PPUSH
89403: CALL 20009 0 5
89407: ST_TO_ADDR
// if components then
89408: LD_VAR 0 9
89412: IFFALSE 89563
// begin if GetWeapon ( un ) = ar_control_tower then
89414: LD_VAR 0 1
89418: PPUSH
89419: CALL_OW 264
89423: PUSH
89424: LD_INT 31
89426: EQUAL
89427: IFFALSE 89544
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89429: LD_VAR 0 1
89433: PPUSH
89434: CALL_OW 311
89438: PPUSH
89439: LD_INT 0
89441: PPUSH
89442: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89446: LD_ADDR_EXP 126
89450: PUSH
89451: LD_EXP 126
89455: PPUSH
89456: LD_VAR 0 3
89460: PPUSH
89461: LD_EXP 126
89465: PUSH
89466: LD_VAR 0 3
89470: ARRAY
89471: PUSH
89472: LD_VAR 0 1
89476: PPUSH
89477: CALL_OW 311
89481: DIFF
89482: PPUSH
89483: CALL_OW 1
89487: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89488: LD_ADDR_VAR 0 7
89492: PUSH
89493: LD_EXP 107
89497: PUSH
89498: LD_VAR 0 3
89502: ARRAY
89503: PPUSH
89504: LD_INT 1
89506: PPUSH
89507: LD_VAR 0 9
89511: PPUSH
89512: CALL_OW 2
89516: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89517: LD_ADDR_EXP 107
89521: PUSH
89522: LD_EXP 107
89526: PPUSH
89527: LD_VAR 0 3
89531: PPUSH
89532: LD_VAR 0 7
89536: PPUSH
89537: CALL_OW 1
89541: ST_TO_ADDR
// end else
89542: GO 89561
// MC_InsertProduceList ( i , [ components ] ) ;
89544: LD_VAR 0 3
89548: PPUSH
89549: LD_VAR 0 9
89553: PUSH
89554: EMPTY
89555: LIST
89556: PPUSH
89557: CALL 85511 0 2
// break ;
89561: GO 89565
// end ; end ;
89563: GO 89350
89565: POP
89566: POP
// end ; end ; if GetType ( un ) = unit_building then
89567: LD_VAR 0 1
89571: PPUSH
89572: CALL_OW 247
89576: PUSH
89577: LD_INT 3
89579: EQUAL
89580: IFFALSE 89983
// begin btype := GetBType ( un ) ;
89582: LD_ADDR_VAR 0 5
89586: PUSH
89587: LD_VAR 0 1
89591: PPUSH
89592: CALL_OW 266
89596: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89597: LD_VAR 0 5
89601: PUSH
89602: LD_INT 29
89604: PUSH
89605: LD_INT 30
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: IN
89612: IFFALSE 89685
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89614: LD_VAR 0 1
89618: PPUSH
89619: CALL_OW 250
89623: PPUSH
89624: LD_VAR 0 1
89628: PPUSH
89629: CALL_OW 251
89633: PPUSH
89634: LD_VAR 0 1
89638: PPUSH
89639: CALL_OW 255
89643: PPUSH
89644: CALL_OW 440
89648: NOT
89649: IFFALSE 89685
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89651: LD_VAR 0 1
89655: PPUSH
89656: CALL_OW 250
89660: PPUSH
89661: LD_VAR 0 1
89665: PPUSH
89666: CALL_OW 251
89670: PPUSH
89671: LD_VAR 0 1
89675: PPUSH
89676: CALL_OW 255
89680: PPUSH
89681: CALL_OW 441
// end ; if btype = b_warehouse then
89685: LD_VAR 0 5
89689: PUSH
89690: LD_INT 1
89692: EQUAL
89693: IFFALSE 89711
// begin btype := b_depot ;
89695: LD_ADDR_VAR 0 5
89699: PUSH
89700: LD_INT 0
89702: ST_TO_ADDR
// pos := 1 ;
89703: LD_ADDR_VAR 0 6
89707: PUSH
89708: LD_INT 1
89710: ST_TO_ADDR
// end ; if btype = b_factory then
89711: LD_VAR 0 5
89715: PUSH
89716: LD_INT 3
89718: EQUAL
89719: IFFALSE 89737
// begin btype := b_workshop ;
89721: LD_ADDR_VAR 0 5
89725: PUSH
89726: LD_INT 2
89728: ST_TO_ADDR
// pos := 1 ;
89729: LD_ADDR_VAR 0 6
89733: PUSH
89734: LD_INT 1
89736: ST_TO_ADDR
// end ; if btype = b_barracks then
89737: LD_VAR 0 5
89741: PUSH
89742: LD_INT 5
89744: EQUAL
89745: IFFALSE 89755
// btype := b_armoury ;
89747: LD_ADDR_VAR 0 5
89751: PUSH
89752: LD_INT 4
89754: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89755: LD_VAR 0 5
89759: PUSH
89760: LD_INT 7
89762: PUSH
89763: LD_INT 8
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: IN
89770: IFFALSE 89780
// btype := b_lab ;
89772: LD_ADDR_VAR 0 5
89776: PUSH
89777: LD_INT 6
89779: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89780: LD_ADDR_EXP 91
89784: PUSH
89785: LD_EXP 91
89789: PPUSH
89790: LD_VAR 0 3
89794: PUSH
89795: LD_EXP 91
89799: PUSH
89800: LD_VAR 0 3
89804: ARRAY
89805: PUSH
89806: LD_INT 1
89808: PLUS
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PPUSH
89814: LD_VAR 0 5
89818: PUSH
89819: LD_VAR 0 1
89823: PPUSH
89824: CALL_OW 250
89828: PUSH
89829: LD_VAR 0 1
89833: PPUSH
89834: CALL_OW 251
89838: PUSH
89839: LD_VAR 0 1
89843: PPUSH
89844: CALL_OW 254
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: PPUSH
89855: CALL 22477 0 3
89859: ST_TO_ADDR
// if pos = 1 then
89860: LD_VAR 0 6
89864: PUSH
89865: LD_INT 1
89867: EQUAL
89868: IFFALSE 89983
// begin tmp := mc_build_list [ i ] ;
89870: LD_ADDR_VAR 0 7
89874: PUSH
89875: LD_EXP 91
89879: PUSH
89880: LD_VAR 0 3
89884: ARRAY
89885: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89886: LD_VAR 0 7
89890: PPUSH
89891: LD_INT 2
89893: PUSH
89894: LD_INT 30
89896: PUSH
89897: LD_INT 0
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 30
89906: PUSH
89907: LD_INT 1
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: LIST
89918: PPUSH
89919: CALL_OW 72
89923: IFFALSE 89933
// pos := 2 ;
89925: LD_ADDR_VAR 0 6
89929: PUSH
89930: LD_INT 2
89932: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89933: LD_ADDR_VAR 0 7
89937: PUSH
89938: LD_VAR 0 7
89942: PPUSH
89943: LD_VAR 0 6
89947: PPUSH
89948: LD_VAR 0 7
89952: PPUSH
89953: CALL 22803 0 3
89957: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89958: LD_ADDR_EXP 91
89962: PUSH
89963: LD_EXP 91
89967: PPUSH
89968: LD_VAR 0 3
89972: PPUSH
89973: LD_VAR 0 7
89977: PPUSH
89978: CALL_OW 1
89982: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
89983: LD_VAR 0 1
89987: PUSH
89988: LD_EXP 86
89992: PUSH
89993: LD_VAR 0 3
89997: ARRAY
89998: IN
89999: IFFALSE 90038
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90001: LD_ADDR_EXP 86
90005: PUSH
90006: LD_EXP 86
90010: PPUSH
90011: LD_VAR 0 3
90015: PPUSH
90016: LD_EXP 86
90020: PUSH
90021: LD_VAR 0 3
90025: ARRAY
90026: PUSH
90027: LD_VAR 0 1
90031: DIFF
90032: PPUSH
90033: CALL_OW 1
90037: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90038: LD_VAR 0 1
90042: PUSH
90043: LD_EXP 93
90047: PUSH
90048: LD_VAR 0 3
90052: ARRAY
90053: IN
90054: IFFALSE 90093
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90056: LD_ADDR_EXP 93
90060: PUSH
90061: LD_EXP 93
90065: PPUSH
90066: LD_VAR 0 3
90070: PPUSH
90071: LD_EXP 93
90075: PUSH
90076: LD_VAR 0 3
90080: ARRAY
90081: PUSH
90082: LD_VAR 0 1
90086: DIFF
90087: PPUSH
90088: CALL_OW 1
90092: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90093: LD_VAR 0 1
90097: PUSH
90098: LD_EXP 105
90102: PUSH
90103: LD_VAR 0 3
90107: ARRAY
90108: IN
90109: IFFALSE 90148
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90111: LD_ADDR_EXP 105
90115: PUSH
90116: LD_EXP 105
90120: PPUSH
90121: LD_VAR 0 3
90125: PPUSH
90126: LD_EXP 105
90130: PUSH
90131: LD_VAR 0 3
90135: ARRAY
90136: PUSH
90137: LD_VAR 0 1
90141: DIFF
90142: PPUSH
90143: CALL_OW 1
90147: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90148: LD_VAR 0 1
90152: PUSH
90153: LD_EXP 108
90157: PUSH
90158: LD_VAR 0 3
90162: ARRAY
90163: IN
90164: IFFALSE 90203
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90166: LD_ADDR_EXP 108
90170: PUSH
90171: LD_EXP 108
90175: PPUSH
90176: LD_VAR 0 3
90180: PPUSH
90181: LD_EXP 108
90185: PUSH
90186: LD_VAR 0 3
90190: ARRAY
90191: PUSH
90192: LD_VAR 0 1
90196: DIFF
90197: PPUSH
90198: CALL_OW 1
90202: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90203: LD_VAR 0 1
90207: PUSH
90208: LD_EXP 95
90212: PUSH
90213: LD_VAR 0 3
90217: ARRAY
90218: IN
90219: IFFALSE 90258
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90221: LD_ADDR_EXP 95
90225: PUSH
90226: LD_EXP 95
90230: PPUSH
90231: LD_VAR 0 3
90235: PPUSH
90236: LD_EXP 95
90240: PUSH
90241: LD_VAR 0 3
90245: ARRAY
90246: PUSH
90247: LD_VAR 0 1
90251: DIFF
90252: PPUSH
90253: CALL_OW 1
90257: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90258: LD_VAR 0 1
90262: PUSH
90263: LD_EXP 94
90267: PUSH
90268: LD_VAR 0 3
90272: ARRAY
90273: IN
90274: IFFALSE 90313
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90276: LD_ADDR_EXP 94
90280: PUSH
90281: LD_EXP 94
90285: PPUSH
90286: LD_VAR 0 3
90290: PPUSH
90291: LD_EXP 94
90295: PUSH
90296: LD_VAR 0 3
90300: ARRAY
90301: PUSH
90302: LD_VAR 0 1
90306: DIFF
90307: PPUSH
90308: CALL_OW 1
90312: ST_TO_ADDR
// end ; break ;
90313: GO 90317
// end ;
90315: GO 88963
90317: POP
90318: POP
// end ;
90319: LD_VAR 0 2
90323: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90324: LD_INT 0
90326: PPUSH
90327: PPUSH
90328: PPUSH
// if not mc_bases or not skirmish then
90329: LD_EXP 86
90333: NOT
90334: PUSH
90335: LD_EXP 84
90339: NOT
90340: OR
90341: IFFALSE 90345
// exit ;
90343: GO 90560
// for i = 1 to mc_bases do
90345: LD_ADDR_VAR 0 3
90349: PUSH
90350: DOUBLE
90351: LD_INT 1
90353: DEC
90354: ST_TO_ADDR
90355: LD_EXP 86
90359: PUSH
90360: FOR_TO
90361: IFFALSE 90558
// begin if building in mc_construct_list [ i ] then
90363: LD_VAR 0 1
90367: PUSH
90368: LD_EXP 93
90372: PUSH
90373: LD_VAR 0 3
90377: ARRAY
90378: IN
90379: IFFALSE 90556
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90381: LD_ADDR_EXP 93
90385: PUSH
90386: LD_EXP 93
90390: PPUSH
90391: LD_VAR 0 3
90395: PPUSH
90396: LD_EXP 93
90400: PUSH
90401: LD_VAR 0 3
90405: ARRAY
90406: PUSH
90407: LD_VAR 0 1
90411: DIFF
90412: PPUSH
90413: CALL_OW 1
90417: ST_TO_ADDR
// if building in mc_lab [ i ] then
90418: LD_VAR 0 1
90422: PUSH
90423: LD_EXP 119
90427: PUSH
90428: LD_VAR 0 3
90432: ARRAY
90433: IN
90434: IFFALSE 90489
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90436: LD_ADDR_EXP 120
90440: PUSH
90441: LD_EXP 120
90445: PPUSH
90446: LD_VAR 0 3
90450: PPUSH
90451: LD_EXP 120
90455: PUSH
90456: LD_VAR 0 3
90460: ARRAY
90461: PPUSH
90462: LD_INT 1
90464: PPUSH
90465: LD_EXP 120
90469: PUSH
90470: LD_VAR 0 3
90474: ARRAY
90475: PPUSH
90476: LD_INT 0
90478: PPUSH
90479: CALL 21895 0 4
90483: PPUSH
90484: CALL_OW 1
90488: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90489: LD_VAR 0 1
90493: PUSH
90494: LD_EXP 86
90498: PUSH
90499: LD_VAR 0 3
90503: ARRAY
90504: IN
90505: NOT
90506: IFFALSE 90552
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90508: LD_ADDR_EXP 86
90512: PUSH
90513: LD_EXP 86
90517: PPUSH
90518: LD_VAR 0 3
90522: PUSH
90523: LD_EXP 86
90527: PUSH
90528: LD_VAR 0 3
90532: ARRAY
90533: PUSH
90534: LD_INT 1
90536: PLUS
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PPUSH
90542: LD_VAR 0 1
90546: PPUSH
90547: CALL 22477 0 3
90551: ST_TO_ADDR
// exit ;
90552: POP
90553: POP
90554: GO 90560
// end ; end ;
90556: GO 90360
90558: POP
90559: POP
// end ;
90560: LD_VAR 0 2
90564: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90565: LD_INT 0
90567: PPUSH
90568: PPUSH
90569: PPUSH
90570: PPUSH
90571: PPUSH
90572: PPUSH
90573: PPUSH
// if not mc_bases or not skirmish then
90574: LD_EXP 86
90578: NOT
90579: PUSH
90580: LD_EXP 84
90584: NOT
90585: OR
90586: IFFALSE 90590
// exit ;
90588: GO 91251
// for i = 1 to mc_bases do
90590: LD_ADDR_VAR 0 3
90594: PUSH
90595: DOUBLE
90596: LD_INT 1
90598: DEC
90599: ST_TO_ADDR
90600: LD_EXP 86
90604: PUSH
90605: FOR_TO
90606: IFFALSE 91249
// begin if building in mc_construct_list [ i ] then
90608: LD_VAR 0 1
90612: PUSH
90613: LD_EXP 93
90617: PUSH
90618: LD_VAR 0 3
90622: ARRAY
90623: IN
90624: IFFALSE 91247
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90626: LD_ADDR_EXP 93
90630: PUSH
90631: LD_EXP 93
90635: PPUSH
90636: LD_VAR 0 3
90640: PPUSH
90641: LD_EXP 93
90645: PUSH
90646: LD_VAR 0 3
90650: ARRAY
90651: PUSH
90652: LD_VAR 0 1
90656: DIFF
90657: PPUSH
90658: CALL_OW 1
90662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90663: LD_ADDR_EXP 86
90667: PUSH
90668: LD_EXP 86
90672: PPUSH
90673: LD_VAR 0 3
90677: PUSH
90678: LD_EXP 86
90682: PUSH
90683: LD_VAR 0 3
90687: ARRAY
90688: PUSH
90689: LD_INT 1
90691: PLUS
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PPUSH
90697: LD_VAR 0 1
90701: PPUSH
90702: CALL 22477 0 3
90706: ST_TO_ADDR
// btype := GetBType ( building ) ;
90707: LD_ADDR_VAR 0 5
90711: PUSH
90712: LD_VAR 0 1
90716: PPUSH
90717: CALL_OW 266
90721: ST_TO_ADDR
// side := GetSide ( building ) ;
90722: LD_ADDR_VAR 0 8
90726: PUSH
90727: LD_VAR 0 1
90731: PPUSH
90732: CALL_OW 255
90736: ST_TO_ADDR
// if btype = b_lab then
90737: LD_VAR 0 5
90741: PUSH
90742: LD_INT 6
90744: EQUAL
90745: IFFALSE 90795
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90747: LD_ADDR_EXP 119
90751: PUSH
90752: LD_EXP 119
90756: PPUSH
90757: LD_VAR 0 3
90761: PUSH
90762: LD_EXP 119
90766: PUSH
90767: LD_VAR 0 3
90771: ARRAY
90772: PUSH
90773: LD_INT 1
90775: PLUS
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PPUSH
90781: LD_VAR 0 1
90785: PPUSH
90786: CALL 22477 0 3
90790: ST_TO_ADDR
// exit ;
90791: POP
90792: POP
90793: GO 91251
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90795: LD_VAR 0 5
90799: PUSH
90800: LD_INT 0
90802: PUSH
90803: LD_INT 2
90805: PUSH
90806: LD_INT 4
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: LIST
90813: IN
90814: IFFALSE 90938
// begin if btype = b_armoury then
90816: LD_VAR 0 5
90820: PUSH
90821: LD_INT 4
90823: EQUAL
90824: IFFALSE 90834
// btype := b_barracks ;
90826: LD_ADDR_VAR 0 5
90830: PUSH
90831: LD_INT 5
90833: ST_TO_ADDR
// if btype = b_depot then
90834: LD_VAR 0 5
90838: PUSH
90839: LD_INT 0
90841: EQUAL
90842: IFFALSE 90852
// btype := b_warehouse ;
90844: LD_ADDR_VAR 0 5
90848: PUSH
90849: LD_INT 1
90851: ST_TO_ADDR
// if btype = b_workshop then
90852: LD_VAR 0 5
90856: PUSH
90857: LD_INT 2
90859: EQUAL
90860: IFFALSE 90870
// btype := b_factory ;
90862: LD_ADDR_VAR 0 5
90866: PUSH
90867: LD_INT 3
90869: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90870: LD_VAR 0 5
90874: PPUSH
90875: LD_VAR 0 8
90879: PPUSH
90880: CALL_OW 323
90884: PUSH
90885: LD_INT 1
90887: EQUAL
90888: IFFALSE 90934
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90890: LD_ADDR_EXP 118
90894: PUSH
90895: LD_EXP 118
90899: PPUSH
90900: LD_VAR 0 3
90904: PUSH
90905: LD_EXP 118
90909: PUSH
90910: LD_VAR 0 3
90914: ARRAY
90915: PUSH
90916: LD_INT 1
90918: PLUS
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PPUSH
90924: LD_VAR 0 1
90928: PPUSH
90929: CALL 22477 0 3
90933: ST_TO_ADDR
// exit ;
90934: POP
90935: POP
90936: GO 91251
// end ; if btype in [ b_bunker , b_turret ] then
90938: LD_VAR 0 5
90942: PUSH
90943: LD_INT 32
90945: PUSH
90946: LD_INT 33
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: IN
90953: IFFALSE 91243
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90955: LD_ADDR_EXP 94
90959: PUSH
90960: LD_EXP 94
90964: PPUSH
90965: LD_VAR 0 3
90969: PUSH
90970: LD_EXP 94
90974: PUSH
90975: LD_VAR 0 3
90979: ARRAY
90980: PUSH
90981: LD_INT 1
90983: PLUS
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PPUSH
90989: LD_VAR 0 1
90993: PPUSH
90994: CALL 22477 0 3
90998: ST_TO_ADDR
// if btype = b_bunker then
90999: LD_VAR 0 5
91003: PUSH
91004: LD_INT 32
91006: EQUAL
91007: IFFALSE 91243
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91009: LD_ADDR_EXP 95
91013: PUSH
91014: LD_EXP 95
91018: PPUSH
91019: LD_VAR 0 3
91023: PUSH
91024: LD_EXP 95
91028: PUSH
91029: LD_VAR 0 3
91033: ARRAY
91034: PUSH
91035: LD_INT 1
91037: PLUS
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PPUSH
91043: LD_VAR 0 1
91047: PPUSH
91048: CALL 22477 0 3
91052: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91053: LD_ADDR_VAR 0 6
91057: PUSH
91058: LD_EXP 86
91062: PUSH
91063: LD_VAR 0 3
91067: ARRAY
91068: PPUSH
91069: LD_INT 25
91071: PUSH
91072: LD_INT 1
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 3
91081: PUSH
91082: LD_INT 54
91084: PUSH
91085: EMPTY
91086: LIST
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PPUSH
91096: CALL_OW 72
91100: ST_TO_ADDR
// if tmp then
91101: LD_VAR 0 6
91105: IFFALSE 91111
// exit ;
91107: POP
91108: POP
91109: GO 91251
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91111: LD_ADDR_VAR 0 6
91115: PUSH
91116: LD_EXP 86
91120: PUSH
91121: LD_VAR 0 3
91125: ARRAY
91126: PPUSH
91127: LD_INT 2
91129: PUSH
91130: LD_INT 30
91132: PUSH
91133: LD_INT 4
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PUSH
91140: LD_INT 30
91142: PUSH
91143: LD_INT 5
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: LIST
91154: PPUSH
91155: CALL_OW 72
91159: ST_TO_ADDR
// if not tmp then
91160: LD_VAR 0 6
91164: NOT
91165: IFFALSE 91171
// exit ;
91167: POP
91168: POP
91169: GO 91251
// for j in tmp do
91171: LD_ADDR_VAR 0 4
91175: PUSH
91176: LD_VAR 0 6
91180: PUSH
91181: FOR_IN
91182: IFFALSE 91241
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91184: LD_ADDR_VAR 0 7
91188: PUSH
91189: LD_VAR 0 4
91193: PPUSH
91194: CALL_OW 313
91198: PPUSH
91199: LD_INT 25
91201: PUSH
91202: LD_INT 1
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PPUSH
91209: CALL_OW 72
91213: ST_TO_ADDR
// if units then
91214: LD_VAR 0 7
91218: IFFALSE 91239
// begin ComExitBuilding ( units [ 1 ] ) ;
91220: LD_VAR 0 7
91224: PUSH
91225: LD_INT 1
91227: ARRAY
91228: PPUSH
91229: CALL_OW 122
// exit ;
91233: POP
91234: POP
91235: POP
91236: POP
91237: GO 91251
// end ; end ;
91239: GO 91181
91241: POP
91242: POP
// end ; end ; exit ;
91243: POP
91244: POP
91245: GO 91251
// end ; end ;
91247: GO 90605
91249: POP
91250: POP
// end ;
91251: LD_VAR 0 2
91255: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91256: LD_INT 0
91258: PPUSH
91259: PPUSH
91260: PPUSH
91261: PPUSH
91262: PPUSH
91263: PPUSH
91264: PPUSH
// if not mc_bases or not skirmish then
91265: LD_EXP 86
91269: NOT
91270: PUSH
91271: LD_EXP 84
91275: NOT
91276: OR
91277: IFFALSE 91281
// exit ;
91279: GO 91512
// btype := GetBType ( building ) ;
91281: LD_ADDR_VAR 0 6
91285: PUSH
91286: LD_VAR 0 1
91290: PPUSH
91291: CALL_OW 266
91295: ST_TO_ADDR
// x := GetX ( building ) ;
91296: LD_ADDR_VAR 0 7
91300: PUSH
91301: LD_VAR 0 1
91305: PPUSH
91306: CALL_OW 250
91310: ST_TO_ADDR
// y := GetY ( building ) ;
91311: LD_ADDR_VAR 0 8
91315: PUSH
91316: LD_VAR 0 1
91320: PPUSH
91321: CALL_OW 251
91325: ST_TO_ADDR
// d := GetDir ( building ) ;
91326: LD_ADDR_VAR 0 9
91330: PUSH
91331: LD_VAR 0 1
91335: PPUSH
91336: CALL_OW 254
91340: ST_TO_ADDR
// for i = 1 to mc_bases do
91341: LD_ADDR_VAR 0 4
91345: PUSH
91346: DOUBLE
91347: LD_INT 1
91349: DEC
91350: ST_TO_ADDR
91351: LD_EXP 86
91355: PUSH
91356: FOR_TO
91357: IFFALSE 91510
// begin if not mc_build_list [ i ] then
91359: LD_EXP 91
91363: PUSH
91364: LD_VAR 0 4
91368: ARRAY
91369: NOT
91370: IFFALSE 91374
// continue ;
91372: GO 91356
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
91374: LD_VAR 0 6
91378: PUSH
91379: LD_VAR 0 7
91383: PUSH
91384: LD_VAR 0 8
91388: PUSH
91389: LD_VAR 0 9
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: PPUSH
91400: LD_EXP 91
91404: PUSH
91405: LD_VAR 0 4
91409: ARRAY
91410: PUSH
91411: LD_INT 1
91413: ARRAY
91414: PPUSH
91415: CALL 28646 0 2
91419: IFFALSE 91508
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
91421: LD_ADDR_EXP 91
91425: PUSH
91426: LD_EXP 91
91430: PPUSH
91431: LD_VAR 0 4
91435: PPUSH
91436: LD_EXP 91
91440: PUSH
91441: LD_VAR 0 4
91445: ARRAY
91446: PPUSH
91447: LD_INT 1
91449: PPUSH
91450: CALL_OW 3
91454: PPUSH
91455: CALL_OW 1
91459: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91460: LD_ADDR_EXP 93
91464: PUSH
91465: LD_EXP 93
91469: PPUSH
91470: LD_VAR 0 4
91474: PUSH
91475: LD_EXP 93
91479: PUSH
91480: LD_VAR 0 4
91484: ARRAY
91485: PUSH
91486: LD_INT 1
91488: PLUS
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PPUSH
91494: LD_VAR 0 1
91498: PPUSH
91499: CALL 22477 0 3
91503: ST_TO_ADDR
// exit ;
91504: POP
91505: POP
91506: GO 91512
// end ; end ;
91508: GO 91356
91510: POP
91511: POP
// end ;
91512: LD_VAR 0 3
91516: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91517: LD_INT 0
91519: PPUSH
91520: PPUSH
91521: PPUSH
// if not mc_bases or not skirmish then
91522: LD_EXP 86
91526: NOT
91527: PUSH
91528: LD_EXP 84
91532: NOT
91533: OR
91534: IFFALSE 91538
// exit ;
91536: GO 91728
// for i = 1 to mc_bases do
91538: LD_ADDR_VAR 0 4
91542: PUSH
91543: DOUBLE
91544: LD_INT 1
91546: DEC
91547: ST_TO_ADDR
91548: LD_EXP 86
91552: PUSH
91553: FOR_TO
91554: IFFALSE 91641
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91556: LD_VAR 0 1
91560: PUSH
91561: LD_EXP 94
91565: PUSH
91566: LD_VAR 0 4
91570: ARRAY
91571: IN
91572: PUSH
91573: LD_VAR 0 1
91577: PUSH
91578: LD_EXP 95
91582: PUSH
91583: LD_VAR 0 4
91587: ARRAY
91588: IN
91589: NOT
91590: AND
91591: IFFALSE 91639
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91593: LD_ADDR_EXP 95
91597: PUSH
91598: LD_EXP 95
91602: PPUSH
91603: LD_VAR 0 4
91607: PUSH
91608: LD_EXP 95
91612: PUSH
91613: LD_VAR 0 4
91617: ARRAY
91618: PUSH
91619: LD_INT 1
91621: PLUS
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PPUSH
91627: LD_VAR 0 1
91631: PPUSH
91632: CALL 22477 0 3
91636: ST_TO_ADDR
// break ;
91637: GO 91641
// end ; end ;
91639: GO 91553
91641: POP
91642: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91643: LD_VAR 0 1
91647: PPUSH
91648: CALL_OW 257
91652: PUSH
91653: LD_EXP 112
91657: IN
91658: PUSH
91659: LD_VAR 0 1
91663: PPUSH
91664: CALL_OW 266
91668: PUSH
91669: LD_INT 5
91671: EQUAL
91672: AND
91673: PUSH
91674: LD_VAR 0 2
91678: PPUSH
91679: CALL_OW 110
91683: PUSH
91684: LD_INT 18
91686: NONEQUAL
91687: AND
91688: IFFALSE 91728
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91690: LD_VAR 0 2
91694: PPUSH
91695: CALL_OW 257
91699: PUSH
91700: LD_INT 5
91702: PUSH
91703: LD_INT 8
91705: PUSH
91706: LD_INT 9
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: LIST
91713: IN
91714: IFFALSE 91728
// SetClass ( unit , 1 ) ;
91716: LD_VAR 0 2
91720: PPUSH
91721: LD_INT 1
91723: PPUSH
91724: CALL_OW 336
// end ;
91728: LD_VAR 0 3
91732: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91733: LD_INT 0
91735: PPUSH
91736: PPUSH
// if not mc_bases or not skirmish then
91737: LD_EXP 86
91741: NOT
91742: PUSH
91743: LD_EXP 84
91747: NOT
91748: OR
91749: IFFALSE 91753
// exit ;
91751: GO 91869
// if GetLives ( abandoned_vehicle ) > 250 then
91753: LD_VAR 0 2
91757: PPUSH
91758: CALL_OW 256
91762: PUSH
91763: LD_INT 250
91765: GREATER
91766: IFFALSE 91770
// exit ;
91768: GO 91869
// for i = 1 to mc_bases do
91770: LD_ADDR_VAR 0 6
91774: PUSH
91775: DOUBLE
91776: LD_INT 1
91778: DEC
91779: ST_TO_ADDR
91780: LD_EXP 86
91784: PUSH
91785: FOR_TO
91786: IFFALSE 91867
// begin if driver in mc_bases [ i ] then
91788: LD_VAR 0 1
91792: PUSH
91793: LD_EXP 86
91797: PUSH
91798: LD_VAR 0 6
91802: ARRAY
91803: IN
91804: IFFALSE 91865
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91806: LD_VAR 0 1
91810: PPUSH
91811: LD_EXP 86
91815: PUSH
91816: LD_VAR 0 6
91820: ARRAY
91821: PPUSH
91822: LD_INT 2
91824: PUSH
91825: LD_INT 30
91827: PUSH
91828: LD_INT 0
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: PUSH
91835: LD_INT 30
91837: PUSH
91838: LD_INT 1
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: LIST
91849: PPUSH
91850: CALL_OW 72
91854: PUSH
91855: LD_INT 1
91857: ARRAY
91858: PPUSH
91859: CALL 54343 0 2
// break ;
91863: GO 91867
// end ; end ;
91865: GO 91785
91867: POP
91868: POP
// end ;
91869: LD_VAR 0 5
91873: RET
